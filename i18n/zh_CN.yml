# '\n********************\n\nPLEASE ATTACH THE FOLLOWING FILES TO THE BUG REPORT:\nPreprocessed source(s) and associated run script(s) are located at:'
H8F8E0E346199: '\n********************\n\n请将以下文件附加到错误报告中：\n预处理后的源文件和相关的运行脚本位于：'
# '\nDirectory where processed files are stored.\nLinks to definition locations will only be\ngenerated if the file is in this dir.'
H71324B3824F3: '\n存储已处理文件的目录。\n仅当文件位于此目录中时，才会生成定义位置的链接。'
# '\nThe directory for merging symbols.'
H41BC7E2887B5: '\n合并符号的目录。'
# '\nThe output directory for saving the results.'
H9976AAF7AB83: '\n保存结果的输出目录。'
# '\nTurn on time profiler. Generates clang-doc-tracing.json'
H57CFA45FD036: '\n启用时间剖析器。生成clang-doc-tracing.json'
# '\nURL of repository that hosts code.\nUsed for links to definition locations.'
HC00AE5E38B4C: '\n...'
# '  Type "'
H1DFDE84EB693: '  输入 "'
# " '%0 %select{sink:|source:}1' must be with '%select{omp_cur_iteration - 1|omp_cur_iteration}1'"
HCB22E641D2E6: "'%0 %select{sink:|source:}1' 必须与 '%select{omp_cur_iteration - 1|omp_cur_iteration}1' 一起使用"
# " '%0' in a raw string literal delimiter is a C++2c extension"
H03B242298EB9: "'%0' 在原始字符串字面量分隔符中是C++2c扩展"
# " '%0' in a raw string literal delimiter is incompatible with standards before C++2c"
HFCBE1727461C: "'%0' 在原始字符串字面量分隔符中与C++2c之前的版本标准不兼容"
# ' (default: '
H6248B40D9879: ' (默认值: '
# ' <subcommand> --help" to get more help on a specific subcommand'
H386881D1E849: ' <子命令> --help" 获取特定子命令的更多帮助信息'
# ' BOLT Code Heatmap tool\n\n  Produces code heatmaps using sampled profile\n\n  Inputs:\n  - Binary (supports BOLT-optimized binaries),\n  - Sampled profile collected from the binary:\n    - perf data or pre-aggregated profile data (instrumentation profile not supported)\n    - perf data can have basic (IP) or branch-stack (LBR) samples\n\n  Outputs:\n  - Heatmaps: colored ASCII (requires a color-capable terminal or a conversion tool like `aha`)\n    Multiple heatmaps are produced by default with different granularities (set by `block-size` option)\n  - Section hotness: per-section samples% and utilization%\n  - Cumulative distribution: working set size corresponding to a given percentile of samples\n'
H8E5615231EC0: ' BOLT代码热点图工具\n\n  使用采样剖析生成代码热点图\n\n  输入:\n  - 可执行文件（支持BOLT优化后的文件），\n  - 从二进制采集的采样剖析数据:\n    - perf数据或预聚合剖析数据（不支持插桩剖析）\n    - perf数据可包含基本（IP）或分支栈（LBR）样本\n\n  输出:\n  - 热点图：彩色ASCII格式（需要支持颜色的终端或转换工具如`aha`）\n    默认生成多种粒度的热点图（由`block-size`选项控制）\n  - 区段热度：各区段的样本百分比和利用率百分比\n  - 累积分布：对应特定样本百分位的工作集大小\n'
# ' BrainF compiler\n'
H25D59DE4A1CF: ' BrainF 编译器\n'
# ' [options]'
HE3EDA38172DD: '[选项]'
# ' [subcommand]'
HEBFEA7B72C8E: '[子命令]'
# ' positional argument'
HB552499219D4: ' 位置参数'
# ' positional arguments: See: '
H847D7E575852: ' 位置参数：请参见：'
# '#else after #else'
H73FE4A6784FB: '在#else之后出现#else'
# '#else without #if'
HF8F50363B288: '#else 之前缺少 #if'
# '#embed is a %select{C23|Clang}0 extension'
H799E9AA4840E: '#embed 是 %select{C23|Clang}0 的扩展'
# '#embed is incompatible with C standards before C23'
H1AF95A3E3444: '#embed 与 C23 之前的 C 标准不兼容'
# '#endif without #if'
H56B14C401F16: '#endif 之前缺少 #if'
# '#ident is a language extension'
H45C329EC97BC: '#ident 是语言扩展'
# '#import is a language extension'
H8768B3DA6294: '#import 是语言扩展'
# '#import of type library is an unsupported Microsoft feature'
H1CFAB9C94AB6: '#import 类型库是微软不支持的功能'
# '#include nested too deeply'
H21908EF6D74E: '#include 嵌套过深'
# "#include of '%0' not seen while attempting to %select{create|use}1 precompiled header"
H05355AF7456A: "在尝试%select{创建|使用}1预编译头时，未找到 '%0' 的#include"
# '#include resolved using non-portable Microsoft search rules as: %0'
HE0D8871EA3B6: '#include 使用不可移植的微软搜索规则解析为: %0'
# '#include_next in file found relative to primary source file or found by absolute path; will search from start of include path'
H92850FB4B236: '#include_next 在文件中相对于主源文件或通过绝对路径找到；将从包含路径的开头重新搜索'
# '#include_next in primary source file; will search from start of include path'
HA1F5AE68D4B4: '#include_next 在主源文件中使用；将从包含路径的开头开始搜索'
# '#include_next is a language extension'
H924C2DCE9AC7: '#include_next 是语言扩展'
# '#line directive requires a positive integer argument'
H2EB091899FF1: '#line 指令需要一个正整数参数'
# '#line directive with zero argument is a GNU extension'
H05235496C826: '无参数的 #line 指令是 GNU 扩展'
# '#line number greater than 32767 is incompatible with C++98'
HF9B195DC3866: '#line 的行号大于 32767 与 C++98 不兼容'
# '#pragma %0(".drectve") has undefined behavior, use #pragma comment(linker, ...) instead'
H6CC89C517043: '#pragma %0(".drectve") 行为未定义，建议使用 #pragma comment(linker, ...)'
# '#pragma %0(pop, ...) failed: %1'
H1F44FB9E690A: '#pragma %0(pop, ...) 失败：%1'
# '#pragma align(packed) may not be compatible with objects generated with AIX XL C/C++'
H19CC6269DA45: '#pragma align(packed) 可能与AIX XL C/C++生成的对象不兼容'
# '#pragma entered here'
H4EB06A1F820E: '#pragma 从此处开始生效'
# "#pragma execution_character_set expected '%0'"
H3700F774625D: "#pragma execution_character_set 期望 '%0'"
# "#pragma execution_character_set expected 'push' or 'pop'"
HF944C9D4F311: "#pragma execution_character_set 期望 'push' 或 'pop'"
# "#pragma execution_character_set invalid value '%0', only 'UTF-8' is supported"
HF7B9B86DDFE7: "#pragma execution_character_set 的参数无效 '%0'，仅支持 'UTF-8'"
# '#pragma hdrstop filename not supported, /Fp can be used to specify precompiled header filename'
HB20EE88D126A: '#pragma hdrstop 不支持指定文件名，可通过 /Fp 指定预编译头文件名'
# '#pragma hdrstop not seen while attempting to use precompiled header'
H482D12372789: '使用预编译头时未检测到 #pragma hdrstop'
# '#pragma once in main file'
H9D36B8727C26: '主文件中包含 #pragma once'
# '#pragma options align=reset failed: %0'
H3024180A558C: '#pragma options align=reset 失败: %0'
# '#pragma redefine_extname is applicable to external C declarations only; not applied to %select{function|variable}0 %1'
HAF6CFAD80C5F: '#pragma redefine_extname仅适用于外部C声明；不应用于%select{函数|变量}0 %1'
# '#pragma system_header ignored in main file'
HE58DA574E5C2: '#pragma system_header 在主文件中被忽略'
# '#pragma visibility pop with no matching #pragma visibility push'
H3EDA32C5E985: '#pragma visibility pop 没有对应的 #pragma visibility push'
# '#pragma visibility push with no matching #pragma visibility pop'
HB15E579A68AB: '#pragma visibility push 没有对应的 #pragma visibility pop'
# "#pragma warning expected '%0'"
HE762E253E06E: "#pragma warning 期望 '%0'"
# "#pragma warning expected 'push', 'pop', 'default', 'disable', 'error', 'once', 'suppress', 1, 2, 3, or 4"
HBCB4550F177A: "#pragma warning 期望 'push'、'pop'、'default'、'disable'、'error'、'once'、'suppress'、1、2、3 或 4"
# '#pragma warning expected a warning number'
HB9A465F10016: '#pragma warning 期望一个警告编号'
# '#pragma warning(push, level) requires a level between 0 and 4'
H99A37FD4A6D8: '#pragma warning(push, level) 需要级别在 0 到 4 之间'
# '#warning is a %select{C23|C++23}0 extension'
H0F157EC51CD6: '#warning 是 %select{C23|C++23}0 的扩展'
# '#warning is incompatible with C standards before C23'
H447994BFEB83: '#warning 与 C23 之前的 C 标准不兼容'
# '#warning is incompatible with C++ standards before C++23'
H42FA898C6606: '#warning 与 C++23 之前的 C++ 标准不兼容'
# '%0 %select{parameter|return}1 type is unsupported; support for vector types for this target is introduced in %2'
HDC6BFCFF388E: '%0 %select{参数|返回}1 类型不受支持；此目标的向量类型支持在 %2 中引入'
# "%0 '%1' is acquired exclusively and shared in the same scope"
H7390A9DF88C0: "%0 '%1' 在同一作用域中被独占获取和共享"
# "%0 '%1' is not held on every path through here%select{| with equal reentrancy depth}2"
HDC5F203131ED: "%0 '%1' 并非在此路径的所有执行路径中都持有 %select{|且具有相同的重入深度}2"
# "%0 '%1' is still held at the end of function"
HC378A7D8C58E: "%0 '%1' 在函数结束时仍然被持有"
# "%0 '%1' must be acquired before '%2'"
H1AA537616F4E: "%0 '%1' 必须在 '%2' 之前获取"
# "%0 '%2' not managed by '%1'"
H7EC62D1C1AF9: "%0 '%2' 未被 '%1' 管理"
# "%0 (%1) exceeds limit (%2) in '%3'"
HE73AA4C10244: "%0 (%1) 超过 '%3' 中的限制 (%2)"
# '%0 acquired here'
HEA3E3310E736: '%0 在此处获取'
# '%0 additional files entered using a total of %1B (%human1B) of space'
HBB08F5A2D9D4: '%0 使用总共 %1B (%human1B) 空间输入了附加文件'
# '%0 and %1%select{ attributes|}2 are not compatible'
H3E0737276230: '%0 和 %1%select{属性|}2 不兼容'
# '%0 appears multiple times in clauses on the same declare target directive'
H71D418F6E9B9: '%0 在同一 declare 目标指令的子句中多次出现'
# '%0 applied to an expression is a GNU extension'
HE4B8DDF4E86C: '%0 应用于表达式是一个 GNU 扩展'
# '%0 argument must be a constant unsigned integer expression'
HD9AE42B82C9D: '%0 参数必须是常量无符号整数表达式'
# '%0 argument of MTE builtin function must be a null or a pointer (%1 invalid)'
H1FAF65C9963B: '%0 MTE内建函数参数必须是空指针或指针类型（%1 无效）'
# '%0 argument of MTE builtin function must be a pointer (%1 invalid)'
H0BF1182D2AC8: '%0 MTE内建函数参数必须是指针类型（%1 无效）'
# '%0 argument of MTE builtin function must be an integer type (%1 invalid)'
H2B10B0C97CC4: '%0 MTE内建函数参数必须是整数类型（%1 无效）'
# '%0 argument to %1 must be of vector type'
H61B90BC8950E: '%0 参数传递给 %1 时必须为向量类型'
# '%0 attribute %plural{0:takes no arguments|1:takes one argument|:requires exactly %1 arguments}1'
H8625FD5B48BC: '%0 属性 %plural{0:不需要参数|1:需要一个参数|:需要恰好 %1 个参数}1'
# '%0 attribute applied to non-RVV type %1'
H49243AEFBCDB: '%0 属性应用于非RVV类型 %1'
# '%0 attribute applied to non-SVE type %1'
H7CA8225CCF33: '%0 属性应用于非SVE类型 %1'
# "%0 attribute applies to function parameters only if their type is a reference to a 'scoped_lockable'-annotated type"
H8F04340A3021: "%0 属性仅适用于其类型是引用带有 'scoped_lockable' 注解类型的函数参数"
# "%0 attribute argument '%1' not supported on a global variable"
H12B4D27D7798: "%0 属性参数 '%1' 不支持全局变量"
# '%0 attribute argument is invalid: %select{max must be 0 since min is 0|min must not be greater than max}1'
HD3E478873102: '%0 属性参数无效：%select{max必须设为 0，因为min已经是 0|min不能大于max}1'
# '%0 attribute argument may only refer to a function parameter of integer type'
H05E563701DF2: '%0 属性参数只能引用整数类型的函数参数'
# '%0 attribute argument must be a string literal specifying a Swift function name'
H056A97564B83: '%0 属性参数必须是一个指定Swift函数名的字符串字面量'
# '%0 attribute argument not supported: %1'
HB519160711B1: '%0 属性参数不支持：%1'
# "%0 attribute can only be applied in a context annotated with 'capability' attribute"
H9411040D8420: "%0 属性只能应用于标注有 'capability' 属性的上下文中"
# '%0 attribute can only be applied once per parameter'
H3C2BAB720741: '%0 属性每个参数只能应用一次'
# '%0 attribute can only be applied to a %select{function|method}1 with an error parameter'
H5477D07BA320: '%0 属性只能应用于带有错误参数的%select{函数|方法}1'
# '%0 attribute can only be applied to a ARM, HLSL, SPIR-V or RISC-V builtin'
H57FF55F870DD: '%0 属性只能应用于ARM、HLSL、SPIR-V或RISC-V内建函数'
# '%0 attribute can only be applied to instance variables or properties'
H30E90B5958C9: '%0 属性只能应用于实例变量或属性'
# "%0 attribute cannot be applied to %select{a function parameter|a variable with 'register' storage class|a 'catch' variable|a bit-field|an enumeration}1"
HD202D2E58321: "%0 属性不能应用于%select{函数参数|具有 'register' 存储类的变量|'catch' 变量|位域|枚举}1"
# '%0 attribute cannot be applied to %select{methods in protocols|dealloc}1'
HC18046C82752: '%0 属性不能应用于%select{协议中的方法|dealloc}1'
# '%0 attribute cannot be applied to a %select{function|method}1 with no parameters'
H9F395B21D226: '%0 属性不能应用于没有参数的%select{函数|方法}1'
# '%0 attribute cannot be applied to a module'
H6CF918E64873: '%0 属性不能应用于模块'
# '%0 attribute cannot be applied to a module import'
H3AD0DE140148: '%0 属性不能应用于模块导入'
# '%0 attribute cannot be applied to non-static member functions'
HCA6FA0E6C0E4: '%0 属性不能应用于非静态成员函数'
# '%0 attribute cannot be applied to sizeless type %1'
H60D82BB85EBA: '%0 属性不能应用于大小未知类型 %1'
# '%0 attribute cannot be applied to this declaration'
H1A106E97EE94: '%0 属性不能应用于此声明'
# '%0 attribute cannot be repeated'
H1FB2864F8926: '%0 属性不能重复使用'
# '%0 attribute cannot be used from %select{a block|an Objective-C function|this context}1'
HFCD2CCA9A22B: '%0 属性不能从%select{块|Objective-C函数|此上下文}1使用'
# '%0 attribute cannot be used with pointers to members'
H828AE7C76F14: '%0 属性不能用于成员指针'
# "%0 attribute cannot specify more than one 'self:' parameter"
HC2B60D257432: "%0 属性不能指定超过一个 'self:' 参数"
# '%0 attribute does not appear on the first declaration'
HE84901B6BFC0: '%0 属性未出现在首次声明中'
# '%0 attribute expression never produces a constant expression'
H6DB854C2324C: '%0 属性表达式无法生成常量表达式'
# "%0 attribute for 'subscript' getter cannot have a 'newValue:' parameter"
HEBB5613EEF15: "%0 属性的 'subscript' 获取器不能包含 'newValue:' 参数"
# "%0 attribute for 'subscript' must %select{be a getter or setter|have at least one parameter|have a 'self:' parameter}1"
H445CA4D5B31B: "%0 属性的 'subscript' 必须%select{是getter或setter|至少有一个参数|具有 'self:' 参数}1"
# "%0 attribute for 'subscript' setter cannot have multiple 'newValue:' parameters"
H2C95053B8BED: "%0 'subscript' setter 的属性不能有多个 'newValue:' 参数"
# "%0 attribute for 'subscript' setter must have a 'newValue:' parameter"
HD3A5819D09C5: "%0 'subscript' setter 的属性必须包含一个 'newValue:' 参数"
# "%0 attribute for getter must not have any parameters besides 'self:'"
HA628A2E87201: "%0 getter 属性除了 'self:' 之外不能有其他参数"
# '%0 attribute for setter must have one parameter for new value'
H349FB00769DE: '%0 setter 属性必须有一个新值参数'
# '%0 attribute has invalid identifier for the %select{base|context|parameter}1 name'
HC37D287D1C6D: '%0 属性为 %select{base|context|parameter}1 名称提供了无效的标识符'
# '%0 attribute has no effect on defaulted or deleted functions'
HDFBEF81FB2EF: '%0 属性对默认或已删除的函数无效'
# '%0 attribute ignored'
HCD3BE326728C: '%0 属性被忽略'
# '%0 attribute ignored because Clang does not yet support this attribute signature'
HB0B12C0AB26E: '因 Clang 尚不支持该属性签名，%0 属性被忽略'
# '%0 attribute ignored for field of type %1'
HBE46E60BBC6F: '类型 %1 的字段上，%0 属性被忽略'
# '%0 attribute ignored on a non-definition declaration'
H208A7E24C5FA: '在非定义声明上，%0 属性被忽略'
# '%0 attribute ignored on inline function'
H96102C6ED34D: '在内联函数上，%0 属性被忽略'
# '%0 attribute ignored on local class%select{| member}1'
HFF01D57072C2: '在局部类 %select{| 成员}1 上，%0 属性被忽略'
# '%0 attribute ignored when parsing type'
HD37333D19CA5: '解析类型时，%0 属性被忽略'
# '%0 attribute is deprecated and ignored in %1'
HEFE3D7F726A1: '%0 属性在 %1 中已被弃用并忽略'
# '%0 attribute is ignored because %1 is not a function pointer'
H4475E1120012: '因 %1 不是函数指针，%0 属性被忽略'
# '%0 attribute is ignored because there exists no call expression inside the statement'
H7E65A2DFE3B4: '因语句内不存在调用表达式，%0 属性被忽略'
# '%0 attribute is ignored in non-aggregate type %1'
HDDFDF4BAA343: '在非聚合类型 %1 中，%0 属性被忽略'
# '%0 attribute is invalid for the implicit this argument'
H2D89A7CAF8E9: '%0 属性对隐式 this 参数无效'
# '%0 attribute is missing parameter label clause'
HD08320D115DE: '%0 属性缺少参数标签子句'
# '%0 attribute is not supported in %select{C|C++|Objective-C}1'
H40645DEA04DB: '%0 属性在 %select{C|C++|Objective-C}1 中不受支持'
# "%0 attribute is not supported on '%1'"
H46128D024C15: "%0 属性不受 '%1' 支持"
# '%0 attribute is not supported on targets missing %1; specify an appropriate -march= or -mcpu='
H8B26915B3400: '%0 属性在缺少 %1 的目标上不受支持；请指定适当的 -march= 或 -mcpu='
# '%0 attribute is not yet supported on AIX'
H09BE0575B2ED: '%0 属性在 AIX 上尚未支持'
# '%0 attribute is only allowed on empty statements'
H523B4DCA9F57: '%0 属性仅允许用于空语句'
# '%0 attribute is permitted on definitions only'
H7BE8228ED388: '%0 属性仅允许用于定义'
# "%0 attribute isn't implemented by this Objective-C runtime"
H4540FD7320B4: '%0 属性未在此 Objective-C 运行时中实现'
# '%0 attribute may not be used with no-return-attribute functions'
H9936965C5605: '%0 属性不可与带有 no-return-attribute 的函数一起使用'
# '%0 attribute may not be used with variadic functions'
HC4348E6FE2CB: '%0 属性不可与可变参数函数一起使用'
# '%0 attribute minimum and maximum arguments are equal'
HCEAC369F8447: '%0 属性的最小和最大参数值相等'
# "%0 attribute must be applied to a %select{function|method}1 annotated with non-'none' attribute 'swift_async'"
H1EED532B31A7: '%0 属性必须应用于带有非 "none" "swift_async" 属性的%select{函数|方法}1'
# '%0 attribute must be greater than 0'
H2544E0569FB3: '%0 属性必须大于 0'
# '%0 attribute on %1 must be preceded by %2 attribute'
H0419F1FBA2F3: '%0 属性在 %1 上必须出现在 %2 属性之前'
# '%0 attribute on entry function does not match the target profile'
H789CC95F4AD2: '%0 属性在入口函数中与目标配置文件不匹配'
# '%0 attribute only applies to %select{Objective-C object|pointer|pointer-to-CF-pointer|pointer/reference-to-OSObject-pointer}1 parameters'
H5089073C0897: '%0 属性仅适用于 %select{Objective-C 对象|指针|指向 CF 指针的指针|指向 OSObject 指针的指针/引用}1 参数'
# '%0 attribute only applies to %select{Objective-C object|pointer|pointer-to-CF-pointer}1 parameters'
HF1529765C253: '%0 属性仅适用于 %select{Objective-C 对象|指针|指向 CF 指针的指针}1 参数'
# '%0 attribute only applies to %select{functions|methods|properties}1 that return %select{an Objective-C object|a pointer|a non-retainable pointer}2'
H0AEFAD59CD2C: '%0 属性仅适用于返回 %select{Objective-C 对象|指针|不可保留指针}2的%select{函数|方法|属性}1'
# '%0 attribute only applies to %select{pointer|integer}1 arguments'
H3971FB6B9374: '%0 属性仅适用于%select{指针|整数}1参数'
# '%0 attribute only applies to a pointer or reference (%1 is invalid)'
HC8C4E00A6BE4: '%0 属性仅适用于指针或引用（%1 无效）'
# '%0 attribute only applies to return values that are pointers'
H83B4DE3C5663: '%0 属性仅适用于返回值为指针的情况'
# '%0 attribute only applies to return values that are pointers or references'
HA603B89762A9: '%0 属性仅适用于返回值为指针或引用的情况'
# '%0 attribute only applies to%select{| constant}1 pointer arguments'
H1E90BC4B3746: '%0 属性仅适用于 %select{|常量}1指针参数'
# '%0 attribute parameter %1 is negative and will be ignored'
HB94334A9F06D: '%0 属性的参数 %1 为负数，将被忽略'
# '%0 attribute parameter %1 is out of bounds'
H9C7D1C19F9DB: '%0 属性的参数 %1 超出范围'
# '%0 attribute parameter %1 is out of bounds: %plural{0:no parameters to index into|1:can only be 1, since there is one parameter|:must be between 1 and %2}2'
HF05125794562: '%0 属性的参数 %1 超出范围：%plural{0:没有参数可供索引|1:只能是 1，因为只有一个参数|:必须在 1 和 %2 之间}2'
# '%0 attribute parameter types do not match: parameter %1 of function %2 has type %3, but parameter %4 of function %5 has type %6'
H4FBE5E81E84C: '%0 属性的参数类型不匹配：函数 %2 的参数 %1 类型为 %3，而函数 %5 的参数 %4 类型为 %6'
# '%0 attribute parameters do not match the previous declaration'
HBB1E6D667EEA: '%0 属性的参数与之前的声明不匹配'
# '%0 attribute references function %1, which %plural{0:takes no arguments|1:takes one argument|:takes exactly %2 arguments}2'
HC6916839EF90: '%0 属性引用函数 %1，该函数 %plural{0:没有参数|1:有一个参数|:恰好有 %2 个参数}2'
# '%0 attribute references parameter %1, but the function %2 has only %3 parameters'
H95C6EBBF3D05: '%0 属性引用参数 %1，但函数 %2 只有 %3 个参数'
# '%0 attribute requires %select{int or bool|an integer constant|a string|an identifier}1'
H4D660FD4970F: '%0 属性需要 %select{int或bool类型|一个整型常量|一个字符串|一个标识符}1'
# '%0 attribute requires a %select{positive|non-negative}1 integral compile time constant expression'
H88B2A4A1C6F1: '%0 属性需要一个%select{正数|非负数}1 类型的整型编译时常量表达式'
# '%0 attribute requires an integer argument which is a constant power of two between %1 and %2 inclusive; provided argument was %3'
HBE3281153430: '%0 属性需要一个介于 %1 和 %2 之间的 2 的常量幂整数参数；提供的参数是 %3'
# "%0 attribute requires arguments whose type is annotated with 'capability' attribute; type here is %1"
H6A637254187D: '%0 属性需要参数类型带有 "capability" 属性；此处的类型是 %1'
# '%0 attribute requires integer constant between %1 and %2 inclusive'
HEAC447E72E0E: '%0 属性需要介于 %1 和 %2 之间的整型常量'
# '%0 attribute requires parameter %1 to be %select{int or bool|an integer constant|a string|an identifier|a constant expression|a builtin function}2'
H410FC41452B2: '%0 属性要求参数 %1 为 %select{int或bool类型|一个整型常量|一个字符串|一个标识符|一个常量表达式|一个内建函数}2'
# '%0 attribute requires that both caller and callee functions have a prototype'
H16EEA1808E57: '%0 属性要求调用函数和被调用函数都具有原型声明'
# '%0 attribute requires that the return value is the result of a function call'
H374EE3F9FB1E: '%0 属性要求返回值必须是函数调用的结果'
# '%0 attribute takes at least %1 argument%s1'
HADEF6E200C29: '%0 属性至少需要 %1 个参数%s1'
# '%0 attribute takes no more than %1 argument%s1'
H19CAD7127F59: '%0 属性最多允许 %1 个参数%s1'
# "%0 attribute with '%1' convention can only be applied to a %select{function|method}2 returning %select{an integral type|a pointer}3"
HD834E8E626F3: '%0 属性使用 "%1" 约定时只能应用于返回%select{整型类型|指针}3的%select{函数|方法}2'
# "%0 attribute with '%1' convention must have an integral-typed parameter in completion handler at index %2, type here is %3"
HA510BC647385: '%0 属性使用 "%1" 约定时，完成处理程序在索引 %2 处必须具有整型参数，此处的类型为 %3'
# "%0 attribute with 'nonnull_error' convention can only be applied to a %select{function|method}1 with a completion handler with an error parameter"
HB02ECE112485: '%0 属性使用 "nonnull_error" 约定时只能应用于具有带有错误参数的完成处理程序的%select{函数|方法}1'
# '%0 attribute without capability arguments can only be applied to non-static methods of a class'
H1A6503974C19: '%0 属性在没有能力参数时只能应用于类的非静态方法'
# "%0 attribute without capability arguments refers to 'this', but %1 isn't annotated with 'capability' or 'scoped_lockable' attribute"
H4FEFB6A31DD8: "%0 属性引用了 'this'，但 %1 未标注 'capability' 或 'scoped_lockable' 属性"
# "%0 availability is ignored without a valid 'SDKSettings.json' in the SDK"
H44C1644AD110: '%0 可用性因 SDK 中缺少有效 "SDKSettings.json" 而被忽略'
# '%0 begins here'
H3AEE48765E33: '%0 开始于此处'
# '%0 bridges to %1, not %2'
HF3302ECAA235: '%0 桥接至 %1 而非 %2'
# "%0 byte order mark detected in '%1', but encoding is not supported"
H4406B8F3C975: "%0 在 '%1' 中检测到字节序标记，但当前编码不支持该标记"
# '%0 calling convention is not supported %select{for this target|on variadic function|on constructor/destructor|on builtin function}1'
HEDD5B64E1439: '%0 调用约定 %select{不适用于此目标|不适用于可变参数函数|不适用于构造函数/析构函数|不适用于内建函数}1'
# '%0 can appear only once in a capture list'
H17CCB4C13684: '捕获列表中 %0 只能出现一次'
# "%0 cannot appear before '::' because it is not a class%select{ or namespace|, namespace, or enumeration}1; did you mean ':'?"
H95866D5EB8E3: "%0 不能出现在 '::' 前，因为它不是类%select{或命名空间|、命名空间或枚举}1；是否应改为使用“:”？"
# '%0 cannot appear here'
H7B57CA319863: '%0 不能出现在此处'
# '%0 cannot appear here, place it after "%select{class|struct|interface|union|enum}1" to apply it to the type declaration'
H2B1210C2EB9F: '%0 不能出现在这里，将其放在 "%select{类|结构体|接口|联合|枚举}1" 后面以将其应用于类型声明'
# '%0 cannot be a template'
H09B919FC579B: '%0 不能是模板'
# '%0 cannot be applied to a module'
HED10CE4A1D68: '%0 不能应用于模块'
# '%0 cannot be applied to a module import'
HE5DD1D7C816C: '%0 不能应用于模块导入'
# '%0 cannot be captured because it does not have automatic storage duration'
HBA5ABB384993: '%0 无法被捕获，因为它没有自动存储期'
# "%0 cannot be declared 'weak_import' because its definition has been provided"
HE0A69210AAA7: "已提供 %0 的定义，因此其不能声明为 'weak_import'"
# '%0 cannot be declared consteval'
H16F780D20CBE: '%0 不能声明为 consteval'
# '%0 cannot be declared inside a namespace'
H52C308DDDEAD: '%0 不能声明在命名空间内'
# '%0 cannot be declared static in global scope'
HE95F0FB30315: '全局作用域中的 %0 不能声明为 static'
# '%0 cannot be defined in a condition'
H4D213A54365F: '%0 不能在条件中定义'
# '%0 cannot be defined in a parameter type'
H73A9723882B3: '%0 不能在参数类型中定义'
# '%0 cannot be defined in a type alias template'
H481A328DC270: '%0 不能在类型别名模板中定义'
# '%0 cannot be defined in a type specifier'
H66CFEB606651: '%0 不能在类型说明符中定义'
# '%0 cannot be defined in an enumeration'
H9015777D8EDA: '%0 不能在枚举中定义'
# '%0 cannot be defined in the result type of a function'
HBCF321DF1229: '%0 不能在函数的返回类型中定义'
# '%0 cannot be specialized%select{|: %2}1'
H2F24480223D6: '%0 不能被特化 %select{|: %2}1'
# '%0 cannot be the name of a parameter'
H86909FCB5AFA: '%0 不能作为参数名'
# '%0 cannot be the name of a variable or data member'
H97536A002E4D: '%0 不能作为变量或数据成员的名称'
# '%0 cannot be used as the type of a kernel parameter'
H4649232301DD: '%0 不能用作内核参数的类型'
# '%0 cannot bridge to %1'
H223FE9046675: '%0 无法桥接到 %1'
# '%0 cannot have a dependent return type; use %1 instead'
H622C863D5758: '%0 不能具有依赖返回类型；请改用 %1'
# "%0 cannot use 'super' because it is a root class"
HCB7FBC7D0FE7: "%0 不能使用 'super'，因为它是一个根类"
# '%0 causes a section type conflict with %1'
HC2A4EF19BEEF: '%0 与 %1 存在段类型冲突'
# '%0 clause previously used here'
HB8E770744C3C: '此处之前使用过 %0 子句'
# '%0 clause should not be followed by arguments; tokens will be ignored'
HC180595F601D: '%0 子句不应跟有参数；将忽略这些标记'
# '%0 command failed due to signal (use -v to see invocation)'
H6D5905ABD1C8: '%0 命令因信号而失败（使用 -v 查看调用信息）'
# '%0 command failed with exit code %1 (use -v to see invocation)'
H4949FF66B370: '%0 命令以退出码 %1 失败（使用 -v 查看调用信息）'
# '%0 currently has no effect on a using declaration'
HF72F1D74D1D1: '当前 %0 对 using 声明没有效果'
# '%0 declared as a reference to a reference'
H6B7D1478B098: '%0 被声明为引用的引用'
# '%0 declared here'
HF5B76F9106FA: '%0 在此处声明'
# '%0 defined here'
HAF9360C4877D: '%0 在此处定义'
# "%0 differs in precompiled file '%1' vs. current file"
HA74FA48CA1FC: "预编译文件 '%1' 与当前文件中的 %0 存在差异"
# '%0 dimension is outside the allowed range [1, %1]'
H082ED204EAD0: '%0 维度超出允许的范围 [1, %1]'
# '%0 does not have a member named %1'
H9A87A68C56D5: '%0 没有名为 %1 的成员'
# '%0 does not have a member named %1; did you mean %2?'
HB35AA56437F0: '%0 没有名为 %1 的成员；您是指 %2 吗？'
# '%0 does not identify a valid pointer authentication key for the current target'
H788DB99BF41E: '%0 指定的指针认证密钥对当前目标无效'
# '%0 does not name a template but is followed by template arguments'
H33B12988518D: '%0 不是模板名称，但随后跟有模板参数'
# '%0 does not name a template but is followed by template arguments; did you mean %1?'
H4461F93F60D6: '%0 不是模板名称，但随后跟有模板参数；您是指 %1 吗？'
# '%0 does not point into a class'
H54F4142F16BD: '%0 不指向一个类'
# '%0 does not refer to a type name in pseudo-destructor expression; expected the name of type %1'
H439E7BF75B12: '%0 不是指向伪析构表达式中的类型名称；期望类型 %1 的名称'
# '%0 does not refer to a value'
H21D124F292F8: '%0 未引用有效值'
# '%0 does not refer to the name of a parameter pack'
H84CFFC360255: '%0 未引用参数包的名称'
# '%0 does not refer to the name of a parameter pack; did you mean %1?'
H833E3DFEF469: '%0 未引用参数包的名称；您是指 %1 吗？'
# "%0 does not support input file format of file '%1': '%select{Source|ModuleMap|Precompiled|Unknown}2'"
HBC389132B383: "文件 '%1' 的输入文件格式不被 %0 支持：'%select{源文件|模块映射|预编译文件|未知}2'"
# "%0 does not support the '%1' %select{type qualifier|storage class specifier}2"
H0775C84F5711: "%0 不支持 '%1' %select{类型限定符|存储类说明符}2"
# "%0 does not support the option '%1'"
HCC61DEFC8375: "%0 不支持选项 '%1'"
# '%0 evaluates to a null function pointer'
H8F92FCB5C04A: '%0 求值为一个空函数指针'
# '%0 has C-linkage specified, but returns incomplete type %1 which could be incompatible with C'
H36CF04C5AD21: '%0 指定了C链接，但返回不完整类型 %1，这可能与C不兼容'
# '%0 has C-linkage specified, but returns user-defined type %1 which is incompatible with C'
H33D15C91E278: '%0 指定了C链接，但返回用户定义类型 %1，这与C不兼容'
# '%0 has a non-throwing exception specification but can still throw'
H115C08CCD253: '%0 声明了无抛出异常规范，但仍可能抛出异常'
# '%0 has been explicitly marked %select{unavailable|deleted|deprecated}1 here'
H8BC49D6916A0: '%0 已在此处显式标记为 %select{不可用|已删除|已弃用}1'
# '%0 has been marked as being introduced in %1 %2 %select{|in %5 environment }4here, but the deployment target is %1 %3%select{| %6 environment }4'
H0D47117119FF: '%0 被标记为在 %1 %2 %select{|%5 环境中}4 引入，但部署目标是 %1 %3%select{|%6 环境}4'
# "%0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%select{no super class|super class with type %5}4|instance variable '%4' access control is %select{|@private|@protected|@public|@package}5}3"
H8AC2F2F00B17: "%0 在不同模块中有不同定义；第一个差异是 %select{模块 '%2' 的定义|在这里定义}1 发现 %select{%select{没有基类|基类类型为 %5}4|实例变量 '%4' 的访问控制是 %select{|@private|@protected|@public|@package}5}3"
# '%0 has lower precedence than %1; %1 will be evaluated first'
HFFF20BD3A51A: '%0 的优先级比 %1 低；将先计算 %1'
# '%0 has no out-of-line virtual method definitions; its vtable will be emitted in every translation unit'
HF80DD309C805: '%0 没有外部虚方法定义；它的虚表将在每个翻译单元中生成'
# '%0 has unknown return type; cast the call to its declared return type'
H98622C79AEFA: '%0 的返回类型未知；将其调用转换为声明的返回类型'
# '%0 has unknown type, which is not supported for this kind of declaration'
H62292154D971: '%0 的类型未知，这种类型的声明不受支持'
# '%0 has unknown type; cast it to its declared type to use it'
HB47BA1F1A811: '%0 的类型未知；将其转换为声明的类型后再使用'
# '%0 has virtual functions but non-virtual destructor'
HE7971ACC4D33: '%0 有虚函数但没有虚析构函数'
# '%0 in capture list does not name a variable'
HDBFB52EAD640: '%0 在捕获列表中未命名变量'
# '%0 is a %select{struct|interface|union|class|enum}1 here'
H03376E721EF2: '%0 这里是一个 %select{结构体|接口|联合体|类|枚举}1'
# '%0 is a builtin with type %1'
HF5D497B12074: '%0 是类型为 %1 的内建函数'
# '%0 is a core feature in %select{OpenCL C|C++ for OpenCL}1 version %2 but not supported on this target'
HB2B1D8E45B2F: '%0 是 %select{OpenCL C|OpenCL 的 C++}1 版本 %2 的核心特性，但此目标不支持'
# '%0 is a large (%1 bytes) pass-by-value argument; pass it by reference instead ?'
H3328D1D6C300: '%0 是一个大（%1 字节）的按值传递参数；建议改为引用传递？'
# '%0 is a reserved attribute identifier'
HA23BACAA2167: '%0 是保留的属性标识符'
# '%0 is a reserved name for a module'
H539795173149: '%0 是保留的模块名称'
# '%0 is an %select{unsafe pointer used for buffer access|unsafe buffer that does not perform bounds checks}1'
HD2DA3F5D5287: '%0 是 %select{用于缓冲区访问的不安全指针|不执行边界检查的不安全缓冲区}1'
# '%0 is an immediate %select{function|constructor}5 because %select{its body|the%select{| default}7 initializer of %8}6 %select{evaluates the address of %select{an immediate|a consteval}2 function %1|contains a call to %select{an immediate|a consteval}2 %select{function|constructor}4 %1 and that call is not a constant expression}3'
H2D11120EB0CD: '%0 是一个 %select{立即函数|立即构造函数}5 因为 %select{其函数体|%select{|默认}7 的 %8 初始化器}6 %select{计算了 %select{一个立即|consteval}2 函数 %1 的地址|包含对 %select{立即|consteval}2 %select{函数|构造函数}4 %1 的调用，而该调用不是常量表达式}3'
# '%0 is an implicit parameter'
H18B31C3BE2ED: '%0 是一个隐式参数'
# '%0 is an incomplete type'
H23B2652D4493: '%0 是一个不完整类型'
# '%0 is an invalid name for a module'
H04BC4C58E825: '%0 是无效的模块名称'
# "%0 is currently enabled, but was not in the precompiled file '%1'"
H7E4FD8DFEFA0: "%0 当前已启用，但在预编译文件 '%1' 中未启用"
# '%0 is defined here; did you mean %1?'
H3B788FE6A551: '%0 在此处定义；您是指 %1 吗？'
# '%0 is deprecated'
HFB3435CCEF09: '%0 已弃用'
# '%0 is deprecated: %1'
HBBBFE1910250: '%0 已弃用：%1'
# '%0 is expected to be a non-type template, but instantiated to a %select{class|type alias}1 template'
H0D2CA33F6096: '%0 应该是一个非类型模板，但实例化为一个 %select{类|类型别名}1 模板'
# '%0 is incompatible with selectors that return a %select{struct|union|vector}1 type'
HF29FF6DC9511: '%0 与返回 %select{结构体|联合|向量}1 类型的选择器不兼容'
# '%0 is incomplete'
HE1EB0B2A5FDF: '%0 是不完整的类型'
# "%0 is missing exception specification '%1'"
HFEFEB7B90D08: "%0 缺少异常说明 '%1'"
# '%0 is no longer a pack expansion but a pack indexing type; add a name to specify a pack expansion'
H52ECBB1B9A17: '%0 现在是打包索引类型而非打包扩展；请添加名称以指定打包扩展'
# '%0 is not %select{trivially relocatable|replaceable|trivially copyable|constructible with provided types}1'
H286C96520443: '%0 不是%select{平凡可重定位|可替换|平凡可复制|可通过提供的类型构造}1'
# '%0 is not a class type'
H5598919CD04A: '%0 不是类类型'
# '%0 is not a class%select{ or namespace|, namespace, or enumeration}1'
H6791F56D81BD: '%0 不是类%select{或命名空间|、命名空间或枚举类型}1'
# '%0 is not a direct base of %1, cannot inherit constructors'
H9090F9B02C3F: '%0 不是 %1 的直接基类，无法继承构造函数'
# '%0 is not a global variable, static local variable or static data member'
HC570BF566E38: '%0 不是全局变量、静态局部变量或静态数据成员'
# '%0 is not a global variable, static local variable or static data member; did you mean %1'
H32A3026BA924: '%0 不是全局变量、静态局部变量或静态数据成员；您是指 %1 吗？'
# '%0 is not a recognized builtin%select{|; consider including <intrin.h> to access non-builtin intrinsics}1'
HB8FF0E17F733: '%0 不是已识别的内建函数 %select{|；请包含 <intrin.h> 以访问非内建本机函数}1'
# '%0 is not a structural type because it has a %select{non-static data member|base class}1 of non-structural type %2'
HF393BE38CC50: '%0 不是结构性类型，因为它具有非结构性类型 %2 的 %select{非静态数据成员|基类}1'
# '%0 is not a structural type because it has a %select{non-static data member|base class}1 that is not public'
H7772D2C2337B: '%0 不是结构性类型，因为它具有非公共的 %select{非静态数据成员|基类}1'
# '%0 is not a structural type because it has a mutable non-static data member'
HF8F430793986: '%0 不是结构性类型，因为它具有可变的非静态数据成员'
# '%0 is not a structural type because it has a non-static data member of rvalue reference type'
H3FC432618326: '%0 不是结构性类型，因为它具有右值引用类型的非静态数据成员'
# '%0 is not a valid SYCL kernel name type; a non-union class type is required'
H0BC00170201E: '%0 不是有效的 SYCL 内核名称类型；需要非联合类类型'
# '%0 is not a valid literal type for NSNumber'
H994AF662B0D5: '%0 不是NSNumber的有效文字类型'
# '%0 is not a valid property name (accessing an object of type %1)'
HA0D8AFF85380: '%0 不是有效的属性名称（访问类型为 %1 的对象）'
# "%0 is not an availability stage; use 'introduced', 'deprecated', or 'obsoleted'"
H5FED6488A0D9: "%0 不是可用性阶段；请使用 'introduced'、'deprecated' 或 'obsoleted'"
# '%0 is not an enumerated type'
H7F1BAB170C64: '%0 不是枚举类型'
# '%0 is not defined, but forward declared here; conversion would be valid if it was derived from %1'
H176B6CEA9A74: '%0 未定义，但在此处有前置声明；如果其派生于 %1 类型则转换有效'
# '%0 is not defined, evaluates to 0'
HBDB44DE505CF: '%0 未定义，计算结果为 0'
# '%0 is not literal because it has a non-trivial destructor'
HC9535B0A1692: '%0 不是文字类型，因为它具有非平凡的析构函数'
# '%0 is not literal because it has a user-provided destructor'
H35BFFB66B4EF: '%0 不是文字类型，因为它具有用户提供的析构函数'
# '%0 is not literal because it has base class %1 of non-literal type'
H41CFD9851FA8: '%0 不是文字类型，因为它具有基类 %1 属于非文字类型'
# '%0 is not literal because it has data member %1 of %select{non-literal|volatile}3 type %2'
H39754ECC239F: '%0 不是文字类型，因为它具有%select{非文字型|volatile}3 类型 %2 的成员 %1'
# '%0 is not literal because it is not an aggregate and has no constexpr constructors other than copy or move constructors'
HD7160BA9A570: '%0 不是文字类型，因为它不是聚合类型且除了拷贝或移动构造函数外没有constexpr构造函数'
# '%0 is not literal because its destructor is not constexpr'
HEAC0F5C26B7E: '%0 不是文字类型，因为它的析构函数不是constexpr'
# '%0 is not polymorphic'
H67C71DB95F18: '%0 不是多态类型'
# '%0 is not supported on HVX %1'
H7927AD732A30: '%0 不受HVX %1 支持'
# '%0 is not supported on this target'
H331CCFBB5DA0: '%0 不受此目标平台支持'
# '%0 is not supported with -fembed-bitcode'
H580226EF44DA: '%0 不能与-fembed-bitcode选项同时使用'
# '%0 is not virtual and cannot be declared pure'
HFCE20933CC31: '%0 不是虚函数，不能声明为纯虚函数'
# '%0 is only available %select{|in %4 environment }3on %1 %2 or newer'
H1926B8ADA9BD: '%0 仅在 %select{|%4 环境 }3%1 %2 或更高版本中可用'
# '%0 is only available for the SPIR-V target'
H92D6E58DBBBB: '%0 仅适用于SPIR-V目标架构'
# '%0 is only supported when \'-mrvv-vector-bits=<bits>\' is specified with a value of "zvl" or a power 2 in the range [64,65536]'
H714177E08C3D: '%0 仅在指定‘-mrvv-vector-bits=<bits>’参数为 "zvl" 或 64 到 65536 之间的 2 的幂时支持'
# "%0 is only supported when '-msve-vector-bits=<bits>' is specified with a value of 128, 256, 512, 1024 or 2048"
H5256E220BB0F: '在指定‘-msve-vector-bits=<bits>’参数值为 128、256、512、1024或 2048 时支持 %0'
# "%0 is required to declare the member 'unhandled_exception()'"
H72F7248FC774: "%0 必须声明成员 'unhandled_exception()'"
# "%0 is required to declare the member 'unhandled_exception()' when exceptions are enabled"
HA2F4C1A14DF7: "当启用异常时，%0 必须声明成员 'unhandled_exception()'"
# "%0 is required to have a non-throwing noexcept specification when the promise type declares 'get_return_object_on_allocation_failure()'"
H267685A6E8FC: "当 promise 类型声明 'get_return_object_on_allocation_failure()' 时，%0 必须具有不抛出异常的 noexcept 说明"
# '%0 is unavailable'
HD9DCE040D90B: '%0 不可用'
# '%0 is unavailable in ARC'
H5A0EF77D1311: '%0 在 ARC 中不可用'
# '%0 is unavailable: %1'
H3F1A4B4C46AF: '%0 不可用：%1'
# '%0 is unsupported with LoongArch linker relaxation (-mrelax)'
H711EE6DE37A1: '%0 不支持 LoongArch 链接器松弛优化 (-mrelax)'
# '%0 is unsupported with RISC-V linker relaxation (-mrelax)'
H7184497D9FBD: '%0 不支持 RISC-V 链接器松弛优化 (-mrelax)'
# '%0 is used as a header guard here, followed by #define of a different macro'
HD1F7F8F6EEEE: '%0 在此处用作头文件卫士，随后是不同宏的 #define'
# "%0 layout not recognized. Must be a non-polymorphic class type with no bases and two fields: a 'const E *' and either another 'const E *' or a 'std::size_t'"
HED28B381356F: "%0 布局未被识别。必须是一个无基类且非多态的类类型，并且包含两个字段：一个 'const E *' 和另一个 'const E *' 或 'std::size_t'"
# '%0 macro redefined'
H137240D8643E: '%0 宏被重新定义'
# "%0 managed by '%1' is '%3' instead of '%2'"
H2BF1BAAD2D9C: "由 '%1' 管理的 %0 是 '%3' 而不是 '%2'"
# "%0 marked 'override' but does not override any member functions"
H4E355023D40F: "%0 标记为 'override'，但未覆盖任何成员函数"
# '%0 may be deprecated because the receiver type is unknown'
H33FCAE6FB142: '%0 可能因接收器类型未知而被弃用'
# '%0 may be duplicated when built into a shared library: it is mutable, has hidden visibility, and external linkage'
H5AAA1A09F587: '当构建为共享库时，%0 可能会被重复：它是可变的，具有隐藏可见性且具有外部链接'
# '%0 may be unavailable because the receiver type is unknown'
H5F639AF749BC: '%0 可能因接收器类型未知而不可用'
# '%0 may not be nested in a struct due to flexible array member'
H56A636FEC1E0: '%0 可能因柔性数组成员而无法嵌套在结构体中'
# '%0 may not be used as an array element due to flexible array member'
H4CE3DAD3A8F2: '%0 可能因柔性数组成员而无法用作数组元素'
# '%0 may not intend to support class template argument deduction'
H3F1AA6022CE0: '%0 可能不打算支持类模板实参推导'
# '%0 may not respond to %1'
HE863B7C4E09E: '%0 可能无法响应 %1'
# '%0 must be explicitly converted to %1; use %select{%objcclass2|%objcinstance2}3 method for this conversion'
H7B5D141884DB: '%0 必须显式转换为 %1；使用 %select{%objcclass2|%objcinstance2}3 方法进行此转换'
# '%0 must be name of an Objective-C class to be able to convert %1 to %2'
HF9706A398326: '%0 必须是Objective-C类的名称，以便将 %1 转换为 %2'
# '%0 must be specified on definition if it is specified on any declaration'
H593384CDC4FD: '如果在任何声明中指定了 %0，必须在定义中指定它'
# '%0 must be used within a preprocessing directive'
HAA08D126AF16: '%0 必须在预处理指令中使用'
# "%0 must not appear in both clauses 'to' and 'link'"
HC3403F617C92: "%0 不得同时出现在 ' to ' 和 ' link ' 子句中"
# '%0 must return type %1'
H561F31EBFB23: '%0 必须返回类型 %1'
# '%0 needs target feature %1'
H5236119E54CB: '%0 需要目标特性 %1'
# '%0 needs to be instantiated from a class template with proper template arguments'
H6CDDF6DD374E: '%0 需要从具有适当模板参数的类模板实例化'
# '%0 needs to have exactly %1 template parameters'
HD0C675913338: '%0 必须恰好有 %1 个模板参数'
# '%0 only allowed in __except block or filter expression'
H5D665A901228: '%0 仅允许在__except块或过滤表达式中使用'
# '%0 only allowed in __except filter expression'
H6152837B25ED: '%0 仅允许在__except过滤表达式中使用'
# '%0 only allowed in __finally block'
H4B415A24C89A: '%0 仅允许在__finally块中使用'
# '%0 only applies to pointer types; type here is %1'
HAB4FE8662D8D: '%0 仅适用于指针类型；此处的类型是 %1'
# "%0 overrides a destructor but is not marked 'override'"
HEE01F5122D86: "%0 覆盖了一个析构函数但未标记为 'override'"
# "%0 overrides a member function but is not marked 'override'"
H7449F9821D96: "%0 覆盖了一个成员函数但未标记为 'override'"
# "%0 parameter marked 'called_once' is called twice"
H9B0F1F204498: "%0 标记为 'called_once' 的参数被调用了两次"
# "%0 parameter marked 'called_once' is never %select{used|called}1 when %select{taking true branch|taking false branch|handling this case|none of the cases applies|entering the loop|skipping the loop|taking one of the branches}2"
HBB87206669E4: "%0 标记为 'called_once' 的参数在%select{取真分支|取假分支|处理这种情况|所有情况都不适用|进入循环时|跳过循环时|取其中一个分支}2时%select{未被使用|未被调用}1"
# "%0 redeclared with '%1' access"
H6D05457F8E04: '%0 重新声明为具有 "%1" 访问权限'
# '%0 released here'
H2E4FF4BE13D1: '%0 在此处释放'
# "%0 requires %1 type support, but ABI '%2' does not support it"
H03B0999A3C3B: "%0 需要 %1 类型支持，但 ABI '%2' 不支持该特性"
# "%0 requires %select{|%2 bit size}1 %3 %select{|return }4type support, but target '%5' does not support it"
HE937C1210F37: "%0 需要 %select{|%2 位大小}1 %3 %select{|返回}4 类型支持，但目标架构 '%5' 不支持该特性"
# '%0 requires HVX, use -mhvx/-mhvx= to enable it'
H9F7369C63134: '%0 需要 HVX 支持，请使用 -mhvx/-mhvx= 开启该功能'
# "%0 requires debug info. Use %1 or debug options that enable debugger's stepping function; option ignored"
H985F4F582A8C: '%0 需要调试信息。请使用 %1 或启用调试器单步执行功能的选项；当前选项被忽略'
# '%0 requires more than 1 template argument; provide the remaining arguments explicitly to use it here'
H33A930D763B0: '%0 需要超过 1 个模板参数；请显式提供剩余参数以在此处使用'
# '%0 returns a reference'
H81B0F21DCC91: '%0 返回引用'
# '%0 should be declared prior to the call site%select{| or in %2| or in an associated namespace of one of its arguments}1'
H80A1DB32BBA2: '%0 应在调用位置之前声明 %select{|或在 %2 中|或在其实参关联命名空间之一中}1'
# "%0 should not return a null pointer unless it is declared 'throw()'%select{| or 'noexcept'}1"
HD6330A6C968B: "%0 除非被声明为 'throw()'%select{|或 'noexcept'}1，否则不应返回空指针"
# '%0 size too large'
HC155B92BBDDE: '%0 尺寸过大'
# '%0 specified here'
H2793186BA8E0: '%0 在此处指定'
# '%0 template must have at least two parameters'
HC33714C2985B: '%0 模板必须至少有两个参数'
# '%0 type %1 not found; include the base header with -finclude-default-header'
HB4775AA2AD70: '%0 类型 %1 未找到；请通过 -finclude-default-header 引入基础头文件'
# '%0 type was not found; include <coroutine> before defining a coroutine'
H89DE99125E80: '%0 类型未找到；在定义协程前请包含 <coroutine>'
# '%0 used as the name of the previous parameter rather than as part of the selector'
HAA86630AF908: '%0 被用作前一个参数的名称而非选择器的一部分'
# '%0 used in array declarator outside of function prototype'
H667299EFB745: '%0 在函数原型外的数组声明符中使用'
# '%0 used in declare target directive is not a variable or a function name'
H56AD7716F4DF: '%0 在声明目标指令中不是变量或函数名'
# '%0 used in non-outermost array type derivation'
H7D46A3E1139D: '%0 在非最外层数组类型推导中使用'
# '%0 variable cannot be %1'
H88684475A953: '%0 变量不能是 %1'
# "%0 variable cannot be in a %1 clause in '#pragma omp %2' directive"
HF56ADE356ADE: '%0 变量不能在 #pragma omp %2 指令的 %1 子句中使用'
# '%0 variable must be %1'
H2457271DFCB0: '%0 变量必须是 %1'
# "%0 was %select{disabled|enabled}1 in precompiled file '%3' but is currently %select{disabled|enabled}2"
H4CAD7163A1ED: "%0 在预编译文件 '%3' 中%select{已禁用|已启用}1，但当前%select{已禁用|已启用}2"
# '%0 was deserialized'
H39D399F5AEF8: '%0 已反序列化'
# '%0 was marked unused but was used'
H40B831F8FB51: '%0 被标记为未使用，但实际被使用了'
# '%0 will return the size of the pointer, not the array itself'
H8CFDDD42E21F: '%0 将返回指针的大小而非数组本身'
# '%0%select{ attribute|}1 cannot be applied to a base specifier'
H11035A3B905C: '%0%select{属性|}1 不能应用于基类说明符'
# '%0%select{ attribute|}1 cannot be applied to a declaration'
H127063747A92: '%0%select{属性|}1 不能应用于声明'
# '%0%select{ attribute|}1 cannot be applied to a statement'
H1C3F2544F25A: '%0%select{属性|}1 不能应用于语句'
# '%0%select{ attribute|}1 cannot be applied to types'
H96D80DF95948: '%0%select{属性|}1 不能应用于类型'
# '%0%select{ attribute|}1 only applies to %2'
H45C12381C633: '%0%select{属性|}1 仅适用于 %2'
# '%0%select{ attribute|}1 only applies to %select{functions|unions|variables and functions|functions and methods|functions, methods and blocks|functions, methods, and parameters|variables|variables and fields|variables, data members and tag types|types and namespaces|variables, functions and classes|kernel functions|non-K&R-style functions|for loop statements|virtual functions|parameters and implicit object parameters|non-member functions|functions, classes, or enumerations|classes|typedefs}2'
H9D37840D3CB2: '%0%select{ attribute|}1 仅适用于 %select{函数|联合|变量和函数|函数和方法|函数、方法和代码块|函数、方法和参数|变量|变量和字段|变量、数据成员和标号类型|类型和命名空间|变量、函数和类|内核函数|非K&R风格函数|for循环语句|虚函数|参数和隐式对象参数|非成员函数|函数、类或枚举|类|typedef}2'
# '%0%select{ attribute|}1 only applies to fields or variables of character array type; type is %2'
H0DF527EADF11: '%0%select{属性|}1 仅适用于字符数组类型的字段或变量；实际类型为 %2'
# "%0%select{| following the 'template' keyword}1 cannot refer to a dependent template"
HA18DA36B7236: "%0%select{|在 'template' 关键字后}1不能引用依赖模板"
# "%0%select{| following the 'template' keyword}1 does not refer to a template"
HCADF8F759262: "%0%select{|在 'template' 关键字后}1未引用模板"
# "%0: '%1' input unused in cpp mode"
HF14789F9D841: "%0: 'cpp模式中未使用 '%1' 输入"
# "%0: '%1' input unused%select{ when '%3' is present|}2"
HA6B5E8785AC8: "%0: '%1' 输入未使用%select{当存在 '%3' 时|}2"
# "%0: 'get_return_object_on_allocation_failure()' must be a static member function"
HB26892211ABD: "%0: 'get_return_object_on_allocation_failure()' 必须是一个静态成员函数"
# "%0: previously preprocessed input%select{ unused when '%2' is present|}1"
H1EB52EB9DA3B: "%0: 之前预处理的输入%select{当存在 '%2' 时未使用|}1"
# "%0; allow reordering by specifying '#pragma clang loop vectorize(enable)' before the loop or by providing the compiler option '-ffast-math'"
H50F1AE498158: "%0; 通过在循环前指定 '#pragma clang loop vectorize(enable)' 允许重新排序，或使用编译器选项 '-ffast-math'"
# "%0; allow reordering by specifying '#pragma clang loop vectorize(enable)' before the loop; if the arrays will always be independent, specify '#pragma clang loop vectorize(assume_safety)' before the loop or provide the '__restrict__' qualifier with the independent array arguments -- erroneous results will occur if these options are incorrectly applied"
H696063533F0E: "%0; 通过在循环前指定 '#pragma clang loop vectorize(enable)' 允许重新排序；如果数组总是独立的，可在循环前指定 '#pragma clang loop vectorize(assume_safety)'，或为独立数组参数添加 '__restrict__' 限定符 —— 错误结果将出现在错误应用这些选项时"
# '%0B (%human0B) in local locations, %1B (%human1B) in locations loaded from AST files, for a total of %2B (%human2B) (%3%% of available space)'
H9B3C5907D274: '%0B (%human0B) 在本地位置，%1B (%human1B) 在AST文件加载位置，总计 %2B (%human2B) (%3%% 的可用空间)'
# '%0{storage class} argument for SPIR-V builtin is not a 32-bits integer'
H519A82184DBD: '%0{存储类别} 参数用于 SPIR-V 内建函数时不是 32 位整数'
# '%1 %0 is hidden by a non-type declaration of %0 here'
HC05432050C69: '%1 %0 被此处的非类型声明 %0 隐藏'
# '%1 is a %select{private|protected}0 member of %3'
H4162E2E8D4C1: '%1 是 %3 的 %select{私有|受保护}0 成员'
# '%2 defined as %select{a struct|an interface|a class}0%select{| template}1 here but previously declared as %select{a struct|an interface|a class}3%select{| template}1; this is valid, but may result in linker errors under the Microsoft C++ ABI'
H65DDB76661CA: '%2 被定义为 %select{一个结构体|一个接口|一个类}0%select{|模板}1 这里，但之前声明为 %select{一个结构体|一个接口|一个类}3%select{|模板}1；这是有效的，但可能导致在 Microsoft C++ ABI 下的链接器错误'
# '%diff{$ and $ are not pointers to compatible types|pointers to incompatible types}0,1'
HE4DF3395C0FE: '%diff{指针 $ 和 $ 指向不兼容类型|指向不兼容类型的指针}0,1'
# '%diff{promoted type $ of K&R function parameter is not compatible with the parameter type $|promoted type of K&R function parameter is not compatible with parameter type}0,1 declared in a previous prototype'
HBE91EA4F0CCD: '%diff{K&R 函数参数提升后的类型 $ 与之前原型中声明的参数类型 $ 不兼容|K&R 函数参数的提升类型与参数类型不兼容}0,1 在之前的原型中声明'
# '%diff{return type $ must match previous return type $|return type must match previous return type}0,1 when %select{block literal|lambda expression}2 has unspecified explicit return type'
H503B0717AF47: '%diff{当 %select{块字面量|lambda 表达式}2 的显式返回类型未指定时，返回类型 $ 必须与之前的返回类型 $ 匹配|返回类型必须与之前的返回类型匹配}0,1'
# "%ordinal0 argument must be a %select{|scalar|vector|matrix|vector of|scalar or vector of}1%plural{[2,3]:%plural{0:|:%plural{0:|:,}2}3|:}1%plural{0:|: }1%select{|integer|signed integer|unsigned integer|'int'|pointer to a valid matrix element}2%plural{0:|: }2%plural{0:|:%plural{0:|:or }2}3%select{|floating-point|16 or 32 bit floating-point}3%plural{0:|: }3%plural{[0,3]:type|:types}1 (was %4)"
HAE59C0ED31CA: "第 %ordinal0 个参数必须是 %select{|标量|向量|矩阵|指向向量的|标量或指向向量的}1%plural{[2,3]:%plural{0:|:%plural{0:|:,}2}3|:}1%plural{0:|: }1%select{|整数|有符号整数|无符号整数|'int'|指向有效矩阵元素的指针}2%plural{0:|: }2%plural{0:|:%plural{0:|: 或 }2}3%select{|浮点|16 或 32 位浮点}3%plural{0:|: }3%plural{[0,3]:类型|:类型}1（实际为 %4）"
# '%ordinal0 argument must be a WebAssembly table'
HF0E3AF42C5DD: '%ordinal0 参数必须是 WebAssembly 表'
# '%ordinal0 argument must be an externref'
H80DC046B6BA1: '%ordinal0参数必须是externref'
# '%ordinal0 argument must be an integer'
HB74677AB0CCF: '%ordinal0 参数必须是整数'
# '%ordinal0 argument must match the element type of the WebAssembly table in the %ordinal1 argument'
HCC6BF06B970F: '%ordinal0 参数必须与 %ordinal1 参数中 WebAssembly 表的元素类型一致'
# '%ordinal3 parameter of%select{| type aware}0%select{| destroying}1 %2 must have type %4'
H2E6F520064CE: '%ordinal3 参数 %select{|具有类型感知能力}0%select{|销毁}1 %2 必须具有类型 %4'
# '%plural{1:enumeration value %1 not explicitly handled in switch|2:enumeration values %1 and %2 not explicitly handled in switch|3:enumeration values %1, %2, and %3 not explicitly handled in switch|:%0 enumeration values not explicitly handled in switch: %1, %2, %3...}0'
HE8DAC9A52D87: '%plural{1:枚举值 %1 在 switch 中未显式处理|2:枚举值 %1 和 %2 在 switch 中未显式处理|3:枚举值 %1、%2 和 %3 在 switch 中未显式处理|:%0 个枚举值在 switch 中未显式处理：%1、%2、%3...}0'
# '%plural{1:enumeration value %1 not handled in switch|2:enumeration values %1 and %2 not handled in switch|3:enumeration values %1, %2, and %3 not handled in switch|:%0 enumeration values not handled in switch: %1, %2, %3...}0'
H0E3F79F6C010: '%plural{1:枚举值 %1 在 switch 中未处理|2:枚举值 %1 和 %2 在 switch 中未处理|3:枚举值 %1、%2 和 %3 在 switch 中未处理|:%0 个枚举值在 switch 中未处理：%1、%2、%3...}0'
# "%plural{2:'delete' used to delete pointer to object allocated with 'std::allocator<...>::allocate'|:%select{non-array delete|array delete|'std::allocator<...>::deallocate'}0 used to delete pointer to %select{array object of type %2|non-array object of type %2|object allocated with 'new'}0}1"
H1294E54BD6EF: "%plural{2:'delete' 用于删除通过 'std::allocator<...>::allocate' 分配的指针|:%select{非数组 delete|数组 delete|'std::allocator<...>::deallocate'}0 用于删除 %select{类型 %2 的数组对象|类型 %2 的非数组对象|通过 'new' 分配的对象}0 的指针}1"
# '%plural{[0,2]:must use a qualified name when declaring|3:cannot declare}0 a %select{constructor|destructor|conversion operator|deduction guide}0 as a friend'
H180E877A4B1E: '%plural{[0,2]:声明时必须使用限定名|3:不能声明}0 %select{构造函数|析构函数|类型转换运算符|推导指引}0 作为友元'
# "%q0 %select{with definition in module '%2'|defined here}1 has different definitions in different modules; first difference is this %select{||||static assert|field|method|type alias|typedef|data member|friend declaration|function template|method|instance variable|property|unexpected decl}3"
HC2ECA20D4E80: "%q0 %select{在模块 '%2' 中有定义|在此处定义}1 在不同模块中有不同的定义；第一个差异是 %select{||||静态断言|字段|方法|类型别名|typedef|数据成员|友元声明|函数模板|方法|实例变量|属性|意外声明}3"
# '%q0 cannot be thread local when declared %q1'
H1F0205F4AD29: '%q0 在声明为 %q1 时不能是线程局部变量'
# "%q0 from module '%1' is not present in definition of %q2%select{ in module '%4'| provided earlier}3"
H9DF776E318FF: "%q0 在模块 '%1' 中不存在于 %q2%select{在模块 '%4' 的定义中|之前提供的定义中}3"
# "%q0 has different definitions in different modules; %select{definition in module '%2' is here|defined here}1"
HB3D6EB7685C3: "%q0 在不同模块中有不同的定义；%select{模块 '%2' 中的定义在此处|在此处定义}1"
# "%q0 has different definitions in different modules; %select{definition in module '%2'|defined here}1 first difference is %select{enum that is %select{not scoped|scoped}4|enum scoped with keyword %select{struct|class}4|enum %select{without|with}4 specified type|enum with specified type %4|enum with %4 element%s4|%ordinal4 element has name %5|%ordinal4 element %5 %select{has|does not have}6 an initializer|%ordinal4 element %5 has an initializer|}3"
H39CEC8B6DBEB: "%q0 在不同模块中有不同的定义；%select{模块 '%2' 的定义|此处定义}1 首个差异是 %select{该枚举 %select{未带作用域|带作用域}4|枚举用 %select{结构体|类}4 关键词带作用域|枚举 %select{无|有}4 指定类型|枚举的指定类型是 %4|枚举有 %4 元素%s4|%ordinal4 元素的名称是 %5|%ordinal4 元素 %5 %select{有|没有}6 初始化器|%ordinal4 元素 %5 有初始化器|}3"
# "%q0 has different definitions in different modules; %select{definition in module '%2'|defined here}1 first difference is %select{return type is %4|%ordinal4 parameter with name %5|%ordinal4 parameter with type %5%select{| decayed from %7}6|%ordinal4 parameter with%select{out|}5 a default argument|%ordinal4 parameter with a default argument|function body}3"
H68AA8A549FAA: "%q0 在不同模块中有不同的定义；%select{模块 '%2' 的定义|此处定义}1 首个差异是 %select{返回类型为 %4|%ordinal4 参数名为 %5|%ordinal4 参数类型为 %5%select{| 衰减为 %7}6|%ordinal4 参数%select{外|}5 有默认参数|%ordinal4 参数有默认参数|函数体}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%4 base %plural{1:class|:classes}4|%4 virtual base %plural{1:class|:classes}4|%ordinal4 base class with type %5|%ordinal4 %select{non-virtual|virtual}5 base class %6|%ordinal4 base class %5 with %select{public|protected|private|no}6 access specifier}3"
HC4303FABC437: "%q0 在不同模块中有不同的定义；第一个差异是 %select{在模块 '%2' 的定义|在此处定义}1 发现 %select{有 %4 个基类 %plural{1:类|:类}4|有 %4 个虚基类 %plural{1:类|:类}4|%ordinal4 基类类型为 %5|%ordinal4 %select{非虚|虚}5 基类 %6|%ordinal4 基类 %5 的访问说明符为 %select{public|protected|private|无}6}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%4 referenced %plural{1:protocol|:protocols}4|%ordinal4 referenced protocol with name %5}3"
HC9695A16C965: "%q0 在不同模块中有不同的定义；第一个差异是 %select{在模块 '%2' 中的定义|在此处定义}1 发现 %select{引用了 %4 %plural{1:协议|:协议}4|%ordinal4 参考的协议名称为 %5}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%select{method %5|constructor|destructor}4 that has %6 parameter%s6|%select{method %5|constructor|destructor}4 with %ordinal6 parameter of type %7%select{| decayed from %9}8|%select{method %5|constructor|destructor}4 with %ordinal6 parameter named %7}3"
HA17814A91726: "%q0 在不同模块中有不同的定义；第一个差异是 %select{模块 '%2' 中的定义|在此处定义}1 发现 %select{%select{方法 %5|构造函数|析构函数}4 具有 %6 参数%s6|%select{方法 %5|构造函数|析构函数}4 的第 %ordinal6 参数类型为 %7%select{| 衰减为 %9}8|%select{方法 %5|构造函数|析构函数}4 的第 %ordinal6 参数名为 %7}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%select{typedef|type alias}4 name %5|%select{typedef|type alias}4 %5 with underlying type %6}3"
H290AB6198D53: "%q0 在不同模块中有不同的定义；第一个差异是 %select{模块 '%2' 中的定义|在此处定义}1 发现 %select{%select{typedef|类型别名}4 名称 %5|%select{typedef|类型别名}4 %5 其底层类型为 %6}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{data member with name %4|data member %4 with type %5|data member %4 with%select{out|}5 an initializer|data member %4 with an initializer|data member %4 %select{is constexpr|is not constexpr}5}3"
H3C6A067820A4: "%q0 在不同模块中有不同的定义；第一个差异是 %select{模块 '%2' 中的定义|在此处定义}1 发现 %select{具有名称 %4 的数据成员|数据成员 %4 的类型 %5|数据成员 %4%select{有|}5 初始值设定项|数据成员 %4 具有初始值设定项|数据成员 %4 %select{是constexpr|不是constexpr}5}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{end of class|public access specifier|private access specifier|protected access specifier|static assert|field|method|type alias|typedef|data member|friend declaration|function template|method|instance variable|property}3"
HC7FCD2470FA2: "%q0 在不同模块中有不同的定义；第一个差异是 %select{模块 '%2' 中的定义|在此处定义}1 发现 %select{类结尾|public访问说明符|private访问说明符|protected访问说明符|静态断言|字段|方法|类型别名|typedef|数据成员|朋友声明|函数模板|方法|实例变量|属性}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{field %4|field %4 with type %5|%select{non-|}5bit-field %4|bit-field %4 with one width expression|%select{non-|}5mutable field %4|field %4 with %select{no|an}5 initializer|field %4 with an initializer}3"
H60D85DC0E685: "%q0 在不同模块中有不同的定义；第一个差异是 %select{模块 '%2' 中的定义|在此处定义}1 发现 %select{字段 %4|字段 %4 的类型 %5|%select{非-|}5 位字段 %4|位字段 %4 具有单个宽度表达式|%select{非-|}5 可变字段 %4|字段 %4 具有%select{无|}5 初始值设定项|字段 %4 具有初始值设定项}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{method %4 with return type %5|%select{class|instance}5 method %4|%select{no|'required'|'optional'}4 method control|method %4 with %select{no designated initializer|designated initializer}5|%select{regular|direct}5 method %4|method %4}3"
H5AECB1226BDE: "%q0 在不同模块中有不同的定义；第一个差异是 %select{模块 '%2' 中的定义|在此处定义}1 发现 %select{返回类型为 %5 的方法 %4|%select{类|实例}5 方法 %4|%select{无|'required'|'optional'}4 方法控制|方法 %4 具有%select{无指定初始化器|指定初始化器}5|%select{常规|直接}5 方法 %4|方法 %4}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{property %4|property %4 with type %5|%select{no|'required'|'optional'}4 property control|property %4 with %select{default |}6'%select{none|readonly|getter|assign|readwrite|retain|copy|nonatomic|setter|atomic|weak|strong|unsafe_unretained|nullability|null_resettable|class|direct}5' attribute}3"
H47E62251068F: "%q0 在不同模块中有不同的定义；第一个差异是 %select{模块 '%2' 中的定义|在此处定义}1 发现 %select{属性 %4|属性 %4 的类型 %5|%select{无|'required'|'optional'}4 属性控制|属性 %4 具有%select{默认 |}6'%select{none|readonly|getter|assign|readwrite|retain|copy|nonatomic|setter|atomic|weak|strong|unsafe_unretained|nullability|null_resettable|class|direct}5' 属性}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{static assert with condition|static assert with message|static assert with %select{|no }4message|%select{method %5|constructor|destructor}4|%select{method %5|constructor|destructor}4 is %select{not deleted|deleted}6|%select{method %5|constructor|destructor}4 is %select{not defaulted|defaulted}6|%select{method %5|constructor|destructor}4 is %select{|pure }6%select{not virtual|virtual}7|%select{method %5|constructor|destructor}4 is %select{not static|static}6|%select{method %5|constructor|destructor}4 is %select{not volatile|volatile}6|%select{method %5|constructor|destructor}4 is %select{not const|const}6|%select{method %5|constructor|destructor}4 is %select{not inline|inline}6|%select{method %5|constructor|destructor}4 with %ordinal6 parameter with%select{out|}7 a default argument|%select{method %5|constructor|destructor}4 with %ordinal6 parameter with a default argument|%select{method %5|constructor|destructor}4 with %select{no |}6template arguments|%select{method %5|constructor|destructor}4 with %6 template argument%s6|%select{method %5|constructor|destructor}4 with %6 for %ordinal7 template argument|%select{method %5|constructor|destructor}4 with %select{no body|body}6|%select{method %5|constructor|destructor}4 with body|friend %select{class|function}4|friend %4|friend function %4|function template %4 with %5 template parameter%s5|function template %4 with %ordinal5 template parameter being a %select{type|non-type|template}6 template parameter|function template %4 with %ordinal5 template parameter %select{with no name|named %7}6|function template %4 with %ordinal5 template parameter with %select{no |}6default argument|function template %4 with %ordinal5 template parameter with default argument %6|function template %4 with %ordinal5 template parameter with one type|function template %4 with %ordinal5 template parameter %select{not |}6being a template parameter pack|}3"
HCEB41952ED68: "%q0 在不同模块中具有不同的定义；第一个差异是 %select{模块 '%2' 中的定义|在此处定义}1 发现 %select{带有条件的静态断言|带有消息的静态断言|%select{|无 }4消息的静态断言|%select{方法 %5|构造函数|析构函数}4|%select{方法 %5|构造函数|析构函数}4 是 %select{未删除|已删除}6|%select{方法 %5|构造函数|析构函数}4 是 %select{未默认|已默认}6|%select{方法 %5|构造函数|析构函数}4 是 %select{|纯 }6%select{非虚|虚}7|%select{方法 %5|构造函数|析构函数}4 是 %select{非静态|静态}6|%select{方法 %5|构造函数|析构函数}4 是 %select{非volatile|volatile}6|%select{方法 %5|构造函数|析构函数}4 是 %select{非const|const}6|%select{方法 %5|构造函数|析构函数}4 是 %select{非内联|内联}6|%select{方法 %5|构造函数|析构函数}4 具有第 %ordinal6 参数带有%select{出|}7 默认参数|%select{方法 %5|构造函数|析构函数}4 具有第 %ordinal6 参数带有默认参数|%select{方法 %5|构造函数|析构函数}4 具有%select{无 |}6 模板参数|%select{方法 %5|构造函数|析构函数}4 具有 %6 模板参数%s6|%select{方法 %5|构造函数|析构函数}4 具有 %6 作为第 %ordinal7 模板参数|%select{方法 %5|构造函数|析构函数}4 具有%select{无|有}6函数体|%select{方法 %5|构造函数|析构函数}4 具有函数体|友元 %select{类|函数}4|友元 %4|友元函数 %4|函数模板 %4 具有 %5 模板参数%s5|函数模板 %4 具有第 %ordinal5 模板参数是 %select{类型|非类型|模板}6 模板参数|函数模板 %4 具有第 %ordinal5 模板参数%select{无名称|名称为 %7}6|函数模板 %4 具有第 %ordinal5 模板参数%select{无|}6 默认参数|函数模板 %4 具有第 %ordinal5 模板参数默认参数 %6|函数模板 %4 具有第 %ordinal5 模板参数具有一个类型|函数模板 %4 具有第 %ordinal5 模板参数%select{不|}6 是模板参数包|}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{unnamed template parameter|template parameter %5|template parameter with %select{no |}4default argument|template parameter with default argument}3"
HA9E92FE31082: "%q0 在不同模块中有不同的定义；第一个差异是 %select{模块 '%2' 中的定义|在此处定义}1 发现 %select{未命名的模板参数|模板参数 %5|模板参数%select{无 |}4 默认参数|模板参数具有默认参数}3"
# '%q0 hides overloaded virtual %select{function|functions}1'
H2FDDD909C4BF: '%q0 隐藏重载虚 %select{函数|函数}1'
# '%q0 is not a member of class %1'
H76BB7974AA85: '%q0 不是类 %1 的成员'
# '%q0 must have external linkage when declared %q1'
HEEACDE119817: '%q0 声明为 %q1 时必须具有外部链接性'
# '%q0 redeclared inline; %1 attribute ignored'
HE698B2D72430: '%q0 重复声明为内联；忽略 %1 属性'
# '%q0 redeclared without %1 attribute: previous %1 ignored'
HD8FE54A130EE: '%q0 未重复声明 %1 属性：忽略先前的 %1 属性'
# "%q0 redeclared without 'dllimport' attribute: 'dllexport' attribute added"
H6D76D4BE2232: "%q0 未重复声明 'dllimport' 属性：添加 'dllexport' 属性"
# '%select{#elif|#elifdef|#elifndef}0 after #else'
H66B8B159F15D: '%select{#elif|#elifdef|#elifndef}0 在#else之后'
# '%select{#elif|#elifdef|#elifndef}0 without #if'
HF4D335F3B905: '%select{#elif|#elifdef|#elifndef}0 未在#if之后'
# '%select{#line|GNU line marker}0 directive interprets number as decimal, not octal'
HDF9BCDB36B4E: '%select{#line|GNU行标记}0 指令将数字解释为十进制而非八进制'
# '%select{#line|GNU line marker}0 directive requires a simple digit sequence'
H065F2C4ACA47: '%select{#line|GNU行标记}0 指令需要简单的数字序列'
# '%select{%1 and |}0%2 tokens %select{introducing statement expression|terminating statement expression|introducing attribute|terminating attribute|forming pointer to member type}3 appear in different macro expansion contexts'
H64A1AC254D6A: '%select{%1 和 |}0%2 标记 %select{引入语句表达式|终止语句表达式|引入属性|终止属性|形成成员指针类型}3 出现在不同的宏展开上下文中'
# '%select{%1 and |}0%2 tokens %select{introducing statement expression|terminating statement expression|introducing attribute|terminating attribute|forming pointer to member type}3 are separated by whitespace'
H9C7F5E5CC536: '%select{%1 和 |}0%2 标记 %select{引入语句表达式|终止语句表达式|引入属性|终止属性|形成成员指针类型}3 被空白字符分隔'
# '%select{%1 is a virtual base class of base class %2 declared here|virtual base class %1 declared here}0'
H0907DB13630C: '%select{%1 是基类 %2 的虚基类在此处声明|虚基类 %1 此处声明}0'
# '%select{%2 has subobjects that are|%3 has type %2 that is}0 non-trivial to %select{default-initialize|destruct|copy}1'
H48AF719C5841: '%select{%2 包含的子对象是|%3 的类型 %2 是}0 非平凡的 %select{默认初始化|销毁|复制}1'
# '%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes address space of nested pointer'
H229282294F90: '%select{%diff{将 $ 赋值给 $|将不同类型赋值}1,0|%diff{将 $ 传递给类型为 $ 的参数|将不同类型传递给参数}0,1|%diff{从结果类型为 $ 的函数返回 $|从不同返回类型的函数返回}1,0|%diff{将 $ 转换为类型 $|在类型之间转换}0,1|%diff{用类型为 $ 的表达式初始化 $|用不同类型的表达式初始化}0,1|%diff{将 $ 发送到类型为 $ 的参数|将不同类型发送给参数}0,1|%diff{将 $ 铸为类型 $|在类型之间进行类型转换}0,1}2 改变了嵌套指针的地址空间'
# '%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes address space of pointer'
H34858D5559B9: '%select{%diff{将 $ 赋值给 $|将不同类型赋值}1,0|%diff{将 $ 传递给类型为 $ 的参数|将不同类型传递给参数}0,1|%diff{从结果类型为 $ 的函数返回 $|从不同返回类型的函数返回}1,0|%diff{将 $ 转换为类型 $|在类型之间转换}0,1|%diff{用类型为 $ 的表达式初始化 $|用不同类型的表达式初始化}0,1|%diff{将 $ 发送到类型为 $ 的参数|将不同类型发送给参数}0,1|%diff{将 $ 铸为类型 $|在类型之间进行类型转换}0,1}2 改变了指针的地址空间'
# '%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes pointer authentication of pointee type'
H8986390D3B16: '%select{%diff{将$赋给$|类型不匹配的赋值}1,0|%diff{将$传给类型为$的参数|类型不匹配的参数传递}0,1|%diff{从返回类型为$的函数返回$|函数返回类型不匹配}1,0|%diff{将$转换为类型$|类型间的转换}0,1|%diff{用类型$的表达式初始化$|类型不匹配的初始化}0,1|%diff{将$传给类型为$的参数|类型不匹配的参数传递}0,1|%diff{将$强制转换为类型$|类型间的强制转换}0,1}2 改变了目标类型的指针认证'
# '%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes retain/release properties of pointer'
HCD0B002FCAD8: '%select{%diff{将 $ 赋值给 $|将不同类型赋值}1,0|%diff{将 $ 传递给类型为 $ 的参数|将不同类型传递给参数}0,1|%diff{从结果类型为 $ 的函数返回 $|从不同返回类型的函数返回}1,0|%diff{将 $ 转换为类型 $|在类型之间转换}0,1|%diff{用类型为 $ 的表达式初始化 $|用不同类型的表达式初始化}0,1|%diff{将 $ 发送到类型为 $ 的参数|将不同类型发送给参数}0,1|%diff{将 $ 铸为类型 $|在类型之间进行类型转换}0,1}2 改变了指针的 retain/release 属性'
# "%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 converts between pointers to integer types %select{with different sign|where one is of the unique plain 'char' type and the other is not}3"
H1F24CCDCD587: "%select{%diff{将 $ 赋值给 $|将不同类型赋值}0,1|%diff{将 $ 传递给类型为 $ 的参数|将不同类型传递给参数}0,1|%diff{从结果类型为 $ 的函数返回 $|从不同返回类型的函数返回}1,0|%diff{将 $ 转换为类型 $|在类型之间转换}0,1|%diff{用类型为 $ 的表达式初始化 $|用不同类型的表达式初始化}0,1|%diff{将 $ 发送到类型为 $ 的参数|将不同类型发送给参数}0,1|%diff{将 $ 铸为类型 $|在类型之间进行类型转换}0,1}2 在整数指针类型之间转换 %select{带有不同的符号|其中一个为普通 'char' 类型而另一个不是}3"
# '%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 converts between void pointer and function pointer'
HA7C5AA745059: '%select{%diff{将 $ 赋值给 $|将不同类型赋值}0,1|%diff{将 $ 传递给类型为 $ 的参数|将不同类型传递给参数}0,1|%diff{从结果类型为 $ 的函数返回 $|从不同返回类型的函数返回}1,0|%diff{将 $ 转换为类型 $|在类型之间转换}0,1|%diff{用类型为 $ 的表达式初始化 $|用不同类型的表达式初始化}0,1|%diff{将 $ 发送到类型为 $ 的参数|将不同类型发送给参数}0,1|%diff{将 $ 铸为类型 $|在类型之间进行类型转换}0,1}2 在 void 指针和函数指针之间转换'
# '%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers'
H7F0C4095C720: '%select{%diff{将 $ 赋值给 $|将不同类型赋值}0,1|%diff{将 $ 传递给类型为 $ 的参数|将不同类型传递给参数}0,1|%diff{从结果类型为 $ 的函数返回 $|从不同返回类型的函数返回}1,0|%diff{将 $ 转换为类型 $|在类型之间转换}0,1|%diff{用类型为 $ 的表达式初始化 $|用不同类型的表达式初始化}0,1|%diff{将 $ 发送到类型为 $ 的参数|将不同类型发送给参数}0,1|%diff{将 $ 铸为类型 $|在类型之间进行类型转换}0,1}2 舍弃了指针类型中的限定符'
# '%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers in nested pointer types'
HA6738ACC7EBA: '%select{%diff{将 $ 赋值给 $|将不同类型赋值}0,1|%diff{将 $ 传递给类型为 $ 的参数|将不同类型传递给参数}0,1|%diff{从结果类型为 $ 的函数返回 $|从不同返回类型的函数返回}1,0|%diff{将 $ 转换为类型 $|在类型之间转换}0,1|%diff{用类型为 $ 的表达式初始化 $|用不同类型的表达式初始化}0,1|%diff{将 $ 发送到类型为 $ 的参数|将不同类型发送给参数}0,1|%diff{将 $ 铸为类型 $|在类型之间进行类型转换}0,1}2 舍弃了嵌套指针类型中的限定符'
# '%select{%diff{assigning to $ from incompatible type $|assigning to type from incompatible type}0,1|%diff{passing $ to parameter of incompatible type $|passing type to parameter of incompatible type}0,1|%diff{returning $ from a function with incompatible result type $|returning type from a function with incompatible result type}0,1|%diff{converting $ to incompatible type $|converting type to incompatible type}0,1|%diff{initializing $ with an expression of incompatible type $|initializing type with an expression of incompatible type}0,1|%diff{sending $ to parameter of incompatible type $|sending type to parameter of incompatible type}0,1|%diff{casting $ to incompatible type $|casting type to incompatible type}0,1}2'
HCAB9D3041C51: '%select{%diff{将类型 $ 赋值给类型不兼容的 $|将类型赋值给不兼容类型}0,1|%diff{将类型 $ 传递给类型不兼容的参数 $|将类型传递给不兼容参数类型}0,1|%diff{从结果类型不兼容的 $ 函数返回 $|从结果类型不兼容的函数返回类型}0,1|%diff{将类型 $ 转换为类型不兼容的 $|将类型转换为不兼容类型}0,1|%diff{用类型不兼容的 $ 表达式初始化 $|用类型不兼容的表达式初始化类型}0,1|%diff{将类型 $ 发送到类型不兼容的参数 $|将类型发送给不兼容参数类型}0,1|%diff{将类型 $ 铸为类型不兼容的 $|将类型铸为不兼容类型}0,1}2'
# '%select{%diff{assigning to $ from incompatible type $|assigning to type from incompatible type}0,1|%diff{passing $ to parameter of incompatible type $|passing type to parameter of incompatible type}0,1|%diff{returning $ from a function with incompatible result type $|returning type from a function with incompatible result type}0,1|%diff{converting $ to incompatible type $|converting type to incompatible type}0,1|%diff{initializing $ with an expression of incompatible type $|initializing type with an expression of incompatible type}0,1|%diff{sending $ to parameter of incompatible type $|sending type to parameter of incompatible type}0,1|%diff{casting $ to incompatible type $|casting type to incompatible type}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3%select{|: different classes%diff{ ($ vs $)|}5,6|: different number of parameters (%5 vs %6)|: type mismatch at %ordinal5 parameter%diff{ ($ vs $)|}6,7|: different return type%diff{ ($ vs $)|}5,6|: different qualifiers (%5 vs %6)|: different exception specifications}4'
H5631F8DA82CD: '%select{%diff{将类型 $ 赋值给类型不兼容的 $|将类型赋值给不兼容类型}0,1|%diff{将类型 $ 传递给类型不兼容的参数 $|将类型传递给不兼容参数类型}0,1|%diff{从结果类型不兼容的 $ 函数返回 $|从结果类型不兼容的函数返回类型}0,1|%diff{将类型 $ 转换为类型不兼容的 $|将类型转换为不兼容类型}0,1|%diff{用类型不兼容的 $ 表达式初始化 $|用类型不兼容的表达式初始化类型}0,1|%diff{将类型 $ 发送到类型不兼容的参数 $|将类型发送给不兼容参数类型}0,1|%diff{将类型 $ 铸为类型不兼容的 $|将类型铸为不兼容类型}0,1}2%select{|; 通过 * 解引用|; 通过 & 获取地址|; 移除 *|; 移除 &}3%select{|: 不同的类%diff{ ($ vs $)|}5,6|: 参数数量不同 (%5 vs %6)|: 第 %ordinal5 参数类型不匹配%diff{ ($ vs $)|}6,7|: 返回类型不同%diff{ ($ vs $)|}5,6|: 限定符不同 (%5 vs %6)|: 异常规范不同}4'
# '%select{%select{increment|decrement}1 of readonly property|no setter method %2 for %select{increment|decrement}1 of property}0'
HAF55C5B7D9CC: '%select{%select{只读属性的递增|只读属性的递减}|缺少 %select{递增|递减}1 属性的设置方法 %2}0'
# "%select{%select{reference|'std::initializer_list'}0 member|member with %select{reference|'std::initializer_list'}0 subobject}1 declared here"
H1B5CDFE7B6DA: "%select{%select{引用|'std::initializer_list'}0 成员|%select{引用|'std::initializer_list'}0 子对象}1 在此处声明"
# "%select{'#pragma clang fp eval_method'|option 'ffp-eval-method'}0 cannot be used with %select{option 'fapprox-func'|option 'mreassociate'|option 'freciprocal'|option 'ffp-eval-method'|'#pragma clang fp reassociate'|'#pragma clang fp reciprocal'}1"
HD4A3AC42422A: "%select{'#pragma clang fp eval_method'|选项 '-ffp-eval-method'}0 不能与 %select{选项 '-fapprox-func'|选项 '-mreassociate'|选项 '-freciprocal'|选项 '-ffp-eval-method'|'#pragma clang fp reassociate'|'#pragma clang fp reciprocal'}1 一起使用"
# "%select{'auto'|'decltype(auto)'|'__auto_type'|template arguments}0 deduced as %1 in declaration of %2 and deduced as %3 in declaration of %4"
H11DB7A31A7DA: "%select{'auto'|'decltype(auto)'|'__auto_type'|模板参数}0 在 %2 的声明中推导为 %1，并在 %4 的声明中推导为 %3"
# "%select{'auto'|'decltype(auto)'|'__auto_type'|use of %select{class template|function template|variable template|alias template|template template parameter|concept|template}2 %3 requires template arguments; argument deduction}0 not allowed %select{in function prototype|in non-static struct member|in struct member|in non-static union member|in union member|in non-static class member|in interface member|in exception declaration|in template parameter until C++17|in block literal|in template argument|in typedef|in type alias|in function return type|in conversion function type|here|in lambda parameter|in type allocated by 'new'|in K&R-style function parameter|in template parameter|in friend declaration|in function prototype that is not a function declaration|in requires expression parameter|in array declaration|in declaration of conversion function template|in lambda parameter before C++14}1"
H7226E87E7B56: "%select{'auto'|'decltype(auto)'|'__auto_type'|使用 %select{类模板|函数模板|变量模板|别名模板|模板模板参数|概念|模板}2 %3 需要模板参数；不允许进行参数推导}0 在 %select{函数原型|非静态结构成员|结构成员|非静态联合成员|联合成员|非静态类成员|接口成员|异常声明|C++17 之前的模板参数|块字面量|模板参数|typedef|类型别名|函数返回类型|转换函数类型|此处|lambda 参数|new 分配的类型|K&R 样式函数参数|模板参数|友元声明|非函数声明的函数原型|requires 表达式参数|数组声明|转换函数模板声明|C++14 之前的 lambda 参数}1 进行参数推导"
# "%select{'mutable'|'static'|'constexpr'|'consteval'}0 cannot appear multiple times in a lambda declarator"
HA9F29290F39F: "%select{'mutable'|'static'|'constexpr'|'consteval'}0 不能在 lambda 声明符中重复出现"
# "%select{'size' argument to memset is '0'|setting buffer to a 'sizeof' expression}0; did you mean to transpose the last two arguments?"
HBE450D9F2F6C: "%select{memset 的 'size' 参数为 '0'|使用 'sizeof' 表达式设置缓冲区}0；是否想交换最后两个参数？"
# '%select{<ERROR>|constexpr|consteval|constinit}0 can only be used in %select{|variable and function|function|variable}0 declarations'
H8ABC77B14403: '%select{<错误>|constexpr|consteval|constinit}0 只能用于 %select{|变量和函数|函数|变量}0 声明'
# '%select{<ERROR>|equality|three-way|equality|relational}0 comparison operator is not a friend of %select{|incomplete class }1%2'
HFE0AE74FD7A7: '%select{<错误>|相等|三向|相等|关系}0 比较运算符不是 %select{|不完整类 }1%2 的友元'
# '%select{<error>|function template|variable template|alias template|template template parameter|concept|template}0 %1 requires template arguments; argument deduction only allowed for class templates or alias templates'
HDE23AA7C6E82: '%select{<错误>|函数模板|变量模板|别名模板|模板模板参数|概念|模板}0 %1 需要模板参数；仅类模板或别名模板允许参数推导'
# '%select{@available|__builtin_available}0 does not guard availability here; use if (%select{@available|__builtin_available}0) instead'
HBA44F219FD20: '%select{@available|__builtin_available}0 不在此处进行可用性检查；请改用 if (%select{@available|__builtin_available}0)'
# "%select{MIPS|MSP430|RISC-V|AVR}0 '%select{interrupt|signal}1' attribute only applies to functions that have %select{no parameters|a 'void' return type}2"
HC530D462FB18: "%select{MIPS|MSP430|RISC-V|AVR}0 '%select{interrupt|signal}1' 属性仅适用于 %select{无参数|返回类型为 'void' 的}2 函数"
# "%select{OpenACC '%3' construct|while loop|do loop}0 cannot appear in intervening code of a '%1' with a '%2' clause"
HB2C5F39C46C3: "%select{OpenACC '%3' 构造|while 循环|do 循环}0 不能出现在带有 '%2' 子句的 '%1' 中间代码段"
# "%select{OpenACC 'gang' clause with a 'dim' value greater than 1|OpenACC 'reduction' clause}0 cannot appear on the same '%1' construct as a %select{'reduction' clause|'gang' clause with a 'dim' value greater than 1}0"
H3449F0200ABB: "%select{OpenACC 'gang' 子句（dim 值大于 1）|OpenACC 'reduction' 子句}0 不能与同一 '%1' 构造中的 %select{'reduction' 子句|'gang' 子句（dim 值大于 1）}0 同时存在"
# '%select{OpenACC sub-array|OpenMP array section}0 is not allowed here'
H8129F6E36883: '%select{OpenACC 子数组|OpenMP 数组区间}0 在此处无效'
# '%select{PCH|current translation unit}0 has no VFS overlays'
H1F8E7EA59762: '%select{预编译头|当前翻译单元}0 没有虚拟文件系统覆盖层'
# '%select{PCH|current translation unit}0 has the following VFS overlays:\n%1'
HF3357458F7A1: '%select{预编译头|当前翻译单元}0 的虚拟文件系统覆盖层如下：\n%1'
# "%select{PCH|module|precompiled }0 file '%1' uses a newer format that cannot be read"
H07F5AC341880: "%select{预编译头|模块|预编译}0文件 '%1' 使用了新版格式，无法读取"
# "%select{PCH|module|precompiled}0 file '%1' built from a different branch (%2) than the compiler (%3)"
H9745C76C9827: "%select{预编译头|模块|预编译}0文件 '%1' 的编译器分支(%2)与当前编译器(%3)不同"
# "%select{PCH|module|precompiled}0 file '%1' contains compiler errors"
H4EAD7147E188: "%select{预编译头|模块|预编译}0文件 '%1' 包含编译错误"
# "%select{PCH|module|precompiled}0 file '%1' is out of date and needs to be rebuilt%select{|: %3}2"
H34F1D2EC0C97: "%select{预编译头|模块|预编译}0文件 '%1' 已过期，需要重新构建 %select{|: %3}2"
# "%select{PCH|module|precompiled}0 file '%1' not found%select{|: %3}2"
HD144036A5800: "%select{预编译头|模块|预编译}0文件 '%1' 未找到 %select{|: %3}2"
# "%select{PCH|module|precompiled}0 file '%1' uses an older format that is no longer supported"
HBC82CDA04A3A: "%select{预编译头|模块|预编译}0 文件 '%1' 使用了已弃用的旧格式"
# '%select{__block variables|global variables|fields|instance variables}0 cannot have __autoreleasing ownership'
H8459C5DA92C1: '%select{__block 变量|全局变量|字段|实例变量}0 不能使用 __autoreleasing 所有权'
# '%select{__device__|__global__|__host__|__host__ __device__}0 function %1 cannot overload %select{__device__|__global__|__host__|__host__ __device__}2 function %3'
HD56CBB05D1A2: '%select{__device__|__global__|__host__|__host__ __device__}0 函数 %1 不能与 %select{__device__|__global__|__host__|__host__ __device__}2 函数 %3 重载'
# '%select{a reference type|an array type|a non-vector or non-vectorizable scalar type}0 is an invalid argument to attribute %1'
H9A7D97DDD421: '%select{一个引用类型|一个数组类型|一个非向量或不可向量化标量类型}0 是属性 %1 的无效参数'
# "%select{a variable|a parameter|'this'}0 cannot appear in more than one %1 clause"
HE09D18DCA51A: "%select{一个变量|一个参数|'this'}0 不能出现在超过一个 %1 子句中"
# "%select{active|which applies to}0 '%1' clause here"
H2AA7AEE20DF7: "%select{激活的|应用于此处的}0 '%1' 子句"
# '%select{address of|reference to}0 stack memory associated with %select{local variable|parameter|compound literal}2 %1 %select{returned|passed to musttail function}3'
HDE8352A90808: '%select{地址的|引用的}0 栈内存与 %select{局部变量|参数|复合字面量}2 %1 %select{返回|传递给 musttail 函数}3'
# '%select{alias|ifunc}0 definition is part of a cycle'
H75F8799A172C: '%select{别名|ifunc}0 定义属于一个循环'
# '%select{alias|ifunc}0 must point to a defined %select{variable or |}1function'
HA8FBD807C04A: '%select{别名|ifunc}0 必须指向已定义的 %select{变量或 |}1 函数'
# "%select{alias|ifunc}1 will not be in section '%0' but in the same section as the %select{aliasee|resolver}2"
H14919DB80F8A: "%select{别名|ifunc}1 将不会位于 '%0' 节中，而是与 %select{别名目标|解析器}2 处于相同的节"
# '%select{alias|ifunc}2 will always resolve to %0 even if weak definition of %1 is overridden'
H739E4FBA0F0D: '%select{别名|ifunc}2 将始终解析为 %0 即使 %1 的弱定义被覆盖'
# '%select{aligning a value|the result of checking whether a value is aligned}0 to 1 byte is %select{a no-op|always true}0'
H6A34843E702F: '%select{将值对齐|检查值是否对齐的结果}0 到 1 字节是 %select{无操作|始终为真}0'
# '%select{alignment of|offset of the aligned pointer from}0 the base pointee object (%1 %plural{1:byte|:bytes}1) is %select{less than|not a multiple of}0 the asserted %2 %plural{1:byte|:bytes}2'
H473934A0D013: '%select{基对象指针的对齐值|对齐指针与基对象的偏移量}0 (%1 %plural{1:字节|:字节}1) 小于或不是 %select{对齐值的倍数|所声明的}0 %2 %plural{1:字节|:字节}2 的倍数'
# '%select{alignment|size}0 of field %1 (%2 bits) does not match the %select{alignment|size}0 of the first field in transparent union; transparent_union attribute ignored'
HF5A022BDF3DB: '%select{对齐值|大小}0 的字段 %1 (%2 位) 与透明联合中第一个字段的 %select{对齐值|大小}0 不匹配；透明联合属性被忽略'
# '%select{alignment|size}0 of first field is %1 bits'
H996CEE2D3252: '%select{对齐值|大小}0 的第一个字段是 %1 位'
# '%select{all|second and third}0 arguments to %1 must be of scalar or vector type with matching scalar element type%diff{: $ vs $|}2,3'
HE09C48EB126A: '%select{所有|第二个和第三个}0 参数到 %1 必须为标量或向量类型且具有匹配的标量元素类型 %diff{: $ vs $|}2,3'
# '%select{an attribute specifier sequence|%0}1 in this position is a C++23 extension'
H561F9F6DB91B: '%select{属性说明符序列|%0}1 在此位置是 C++23 扩展'
# '%select{an attribute specifier sequence|%1}0 in this position is incompatible with C++ standards before C++23'
HEF130F97BB12: '%select{属性说明符序列|%1}0 在此位置与 C++23 之前的版本不兼容'
# '%select{and|because}0 %1 (%2 %3 %4) evaluated to false'
H66E1D07D582D: '%select{和|因为}0 %1 (%2 %3 %4) 求值为假'
# '%select{and|because}0 %1 does not satisfy %2'
H1152B396A251: '%select{并且|因为}0 %1 不满足 %2'
# '%select{and|because}0 %1 does not satisfy %2:'
H7FDA8323151A: '%select{并且|因为}0 %1 不满足 %2:'
# '%select{and|because}0 %1 evaluated to false'
H26D0E6409D84: '%select{和|因为}0 %1 求值为假'
# '%select{and|because}0 %1 may throw an exception'
H22182AFC34C5: '%select{和|因为}0 %1 可能抛出异常'
# "%select{and|because}0 '%1' would be invalid"
HAD3CC48247E5: "%select{并且|因为}0 '%1' 将会无效"
# "%select{and|because}0 '%1' would be invalid%2"
HEF46AC24BE27: "%select{并且|因为}0 '%1' 将会无效 %2"
# "%select{and|because}0 '%1' would be invalid: %2"
HD3831227C190: "%select{并且|因为}0 '%1' 会导致无效：%2"
# '%select{and|because}0 type constraint %1 was not satisfied:'
H0831E4850047: '%select{和|因为}0 类型约束 %1 未被满足:'
# '%select{anonymous struct|union}0 member %1 has a non-trivial %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}2'
H443C398B6494: '%select{匿名结构体|联合体}0 成员 %1 具有非平凡的 %select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}2'
# '%select{anonymous struct|union}0 member %1 with a non-trivial %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}2 is incompatible with C++98'
HE6728E1CAD49: '%select{匿名结构体|联合体}0 成员 %1 具有非平凡的 %select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}2 与 C++98 不兼容'
# '%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 %select{floating-point|enumeration}1 type %2 %plural{2:with|4:from|:and}0 %select{enumeration|floating-point}1 type %3'
H510A2D2A82E0: '%select{浮点型|枚举类型}1 类型 %2 %plural{2:与|4:来自|:和}0 %select{枚举|浮点型}1 类型 %3 之间的%select{算术运算|按位运算|比较|条件表达式|复合赋值}0'
# '%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 %select{floating-point|enumeration}1 type %2 %plural{2:with|4:from|:and}0 %select{enumeration|floating-point}1 type %3 is deprecated'
H08C01E0FFD79: '%select{浮点型|枚举类型}1 类型 %2 %plural{2:与|4:来自|:和}0 %select{枚举|浮点型}1 类型 %3 之间的%select{算术运算|按位运算|比较|条件表达式|复合赋值}0 已弃用'
# '%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different Unicode character types %1 and %2'
H815FA4B1A658: '%select{不同 Unicode 字符类型 %1 和 %2 之间的算术运算|按位运算|比较|条件表达式|复合赋值}0'
# '%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2'
H15481858FE39: '%select{不同枚举类型的算术运算|不同枚举类型的按位运算|不同枚举类型的比较|不同枚举类型的条件表达式|不同枚举类型的复合赋值}0%diff{ ($和$)|}1,2'
# '%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2 is deprecated'
HB2E74DC62C72: '%select{不同枚举类型的算术运算|不同枚举类型的按位运算|不同枚举类型的比较|不同枚举类型的条件表达式|不同枚举类型的复合赋值}0%diff{ ($和$)|}1,2 是已弃用的'
# '%select{assignment to readonly property|no setter method %1 for assignment to property}0'
H7FB56A6FE5D6: '%select{将只读属性赋值|属性赋值没有设置器方法 %1}0'
# '%select{base class|inherited virtual base class}0 %1 has %select{private|protected}3 %select{default |copy |move |*ERROR* |*ERROR* |*ERROR*|}2constructor'
H3EE5604475F7: '%select{基类|继承的虚基类}0 %1 具有%select{私有|受保护}3 %select{默认 |拷贝 |移动 |*ERROR* |*ERROR* |*ERROR*|}2 构造函数'
# '%select{bit-field %1|anonymous bit-field}0 is too wide (%2 bits)'
H4CB82469419C: '%select{位段 %1|匿名位段}0 过宽（%2 位）'
# "%select{block pointer|pointer|reference}0 to function type %select{%2 |}1cannot have '%3' qualifier"
H0BABB964A63A: "%select{块指针|指针|引用}0 到函数类型 %select{%2 |}1 不能带有 '%3' 限定符"
# '%select{call to non-static member function|use of non-static data member}0 %2 of %1 from nested type %3'
H4DA493B4F5FF: '%select{调用非静态成员函数|使用非静态数据成员}0 %2 的 %1 来自嵌套类型 %3'
# '%select{cannot assign to return value because function %1 returns a const value|cannot assign to variable %1 with const-qualified type %2|cannot assign to %select{non-|}1static data member %2 with const-qualified type %3|cannot assign to non-static data member within const member function %1|cannot assign to %select{variable %2|non-static data member %2|lvalue}1 with %select{|nested }3const-qualified data member %4|read-only variable is not assignable}0'
H957C121C1C4E: '%select{不能将返回值赋值因为函数 %1 返回 const 值|不能将 const 限定类型 %2 的变量 %1 赋值|不能将 const 限定类型 %3 的%select{非-|}1 静态数据成员 %2 赋值|不能在 const 成员函数 %1 内对非静态数据成员赋值|不能对%select{变量 %2|非静态数据成员 %2|左值}1 赋值，因为其 %select{|嵌套 }3const 限定数据成员 %4|只读变量不可赋值}0'
# "%select{case value|enumerator value|non-type template argument|non-type parameter of template template parameter|array size|explicit specifier argument|noexcept specifier argument|call to 'size()'|call to 'data()'}0 %select{cannot be narrowed from type %2 to %3|evaluates to %2, which cannot be narrowed to type %3}1"
HECF4733C9DA0: "%select{情况值|枚举值|非类型模板实参|模板模板参数的非类型参数|数组大小|显式说明符实参|noexcept 说明符实参|调用 'size()'|调用 'data()'}0 %select{不能从类型 %2 窄化到 %3|计算为 %2，无法窄化为类型 %3}1"
# "%select{case value|enumerator value|non-type template argument|non-type parameter of template template parameter|array size|explicit specifier argument|noexcept specifier argument|call to 'size()'|call to 'data()'}0 is not a constant expression"
HFB41B693F137: "%select{情况值|枚举值|非类型模板实参|模板模板参数的非类型参数|数组大小|显式说明符实参|noexcept 说明符实参|调用 'size()'|调用 'data()'}0 不是常量表达式"
# '%select{cast|implicit conversion}0 of %select{Objective-C|block|C}1 pointer type %2 to %select{Objective-C|block|C}3 pointer type %4 requires a bridged cast'
H312933E2115D: '%select{转换|隐式转换}0 %select{Objective-C|块|C}1 指针类型 %2 到 %select{Objective-C|块|C}3 指针类型 %4 需要桥接转换'
# '%select{category %1|class extension}0 cannot conform to protocol %2 because of direct members declared in interface %3'
H86E18740A145: '%select{分类 %1|类扩展}0 因为在接口 %3 中声明的直接成员，无法符合协议 %2'
# '%select{category|class extension}0 conforms to protocol %1 which defines method %2'
H1219B6B58D30: '%select{分类|类扩展}0 符合协议 %1，其中定义了方法 %2'
# '%select{character|integer}0 literal with user-defined suffix cannot be used in preprocessor constant expression'
HF3B4B5DEEBAB: '%select{字符|整数}0 字面量带有用户定义后缀，不能在预处理器常量表达式中使用'
# '%select{class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration}0 specialization of %1 must occur at global scope'
HB1B7C78CE71E: '%select{类模板|类模板部分|变量模板|变量模板部分|函数模板|成员函数|静态数据成员|成员类|枚举类型}0 特化 %1 必须出现在全局作用域中'
# '%select{class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration}0 specialization of %1 not in %select{a namespace enclosing %2|class %2 or an enclosing namespace}3'
HFB74AB926D65: '%select{类模板|类模板部分|变量模板|变量模板部分|函数模板|成员函数|静态数据成员|成员类|枚举类型}0 特化 %1 不在 %select{包含 %2 的命名空间中|类 %2 或其上层命名空间}3'
# '%select{class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration}0 specialization of %1 not in %select{a namespace enclosing %2|class %2 or an enclosing namespace}3 is a Microsoft extension'
H61AEC4FCDF68: '%select{类模板|类模板部分|变量模板|变量模板部分|函数模板|成员函数|静态数据成员|成员类|枚举类型}0 特化 %1 不在 %select{包含 %2 的命名空间中|类 %2 或其上层命名空间}3 是 Microsoft 扩展'
# '%select{class|instance}0 method %1 also declared here'
H40D03C99413F: '%select{类|实例}0 方法 %1 还在这里声明'
# '%select{class|instance}0 method %1 has a different number of parameters in different translation units (%2 vs. %3)'
H1C2BED5A5D12: '%select{类|实例}0 方法 %1 在不同翻译单元中的参数数量不同 (%2 vs. %3)'
# '%select{class|instance}0 method %1 has a parameter with a different types in different translation units (%2 vs. %3)'
H27FF7F628706: '%select{类|实例}0 方法 %1 在不同翻译单元中的参数类型不同 (%2 vs. %3)'
# '%select{class|instance}0 method %1 has incompatible result types in different translation units (%2 vs. %3)'
H81568F1228D2: '%select{类|实例}0 方法 %1 在不同翻译单元中的返回类型不兼容 (%2 vs. %3)'
# '%select{class|instance}0 method %1 is assumed to return an instance of its receiver type (%2)'
H57512855C27C: '%select{类|实例}0 方法 %1 默认返回接收者的实例类型 (%2)'
# '%select{class|instance}0 method %1 is variadic in one translation unit and not variadic in another'
HF51A27778394: '%select{类|实例}0 方法 %1 在一个翻译单元中是可变参数函数而在另一个中不是'
# '%select{class|protocol|category|class extension|implementation|category implementation}0 started here'
HB972B56B97CE: '%select{类|协议|分类|类扩展|实现|分类实现}0 在此处开始'
# '%select{class|struct|interface|union|enum|enum class|enum struct}0 cannot be marked %select{<ERROR>|constexpr|consteval|constinit}1'
H6CC4F10FF6EF: '%select{类|结构体|接口|联合体|枚举|枚举类|枚举结构体}0 无法被标记为 %select{<ERROR>|constexpr|consteval|constinit}1'
# '%select{class|type alias}0 template declared here'
HC92E96CB1535: '%select{类|类型别名}0 模板在此处声明'
# '%select{class|variable}0 template partial specialization contains %select{a template parameter|template parameters}1 that cannot be deduced; this partial specialization will never be used'
H8F8D0B49DE65: '%select{类|变量}0 的模板偏特化包含 %select{无法推导的模板参数|无法推导的模板参数}1，该偏特化将永远不会被使用'
# '%select{class|variable}0 template partial specialization does not specialize any template argument; to %select{declare|define}1 the primary template, remove the template argument list'
HC805ED783ADF: '%select{类|变量}0 模板部分特化未特化任何模板参数；要 %select{声明|定义}1 主模板，请移除模板参数列表'
# '%select{class|variable}0 template partial specialization is not more specialized than the primary template'
HD6682742D913: '%select{类|变量}0 模板部分特化并不比主模板更具体'
# '%select{codeseg|section}0 does not match previous declaration'
H9AFE01E1A06A: '%select{代码段|节}0 与之前的声明不匹配'
# "%select{command line contains|precompiled file '%1' was built with}0 '-detailed-preprocessing-record' but %select{precompiled file '%1' was not built with it|it is not present on the command line}0"
HDDE8830E5E4D: "%select{命令行包含|预编译文件 '%1' 构建时包含}0 '-detailed-preprocessing-record' 但 %select{预编译文件 '%1' 未包含该选项|命令行未包含该选项}0"
# "%select{command line contains|precompiled file '%1' was built with}0 '-undef' but %select{precompiled file '%1' was not built with it|it is not present on the command line}0"
H538B2717C6E0: "%select{命令行包含|预编译文件 '%1' 构建时包含}0 '-undef' 但 %select{预编译文件 '%1' 未包含该选项|命令行未包含该选项}0"
# '%select{comparison between %diff{ ($ and $)|}0,1|arithmetic operation with operands of type %diff{ ($ and $)|}0,1|conditional operator with the second and third operands of type %diff{ ($ and $)|}0,1}2 which are pointers to non-overlapping address spaces'
H47A4B5F7D5D9: '%select{涉及 %diff{ ($ 和 $)|}0,1 的比较|运算符的操作数类型为 %diff{ ($ 和 $)|}0,1|条件运算符的第二个和第三个操作数类型为 %diff{ ($ 和 $)|}0,1}2 其指针指向不同地址空间'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 from %1 to %2 converts between mismatching address spaces'
HB50BD1C6F363: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C 风格强制转换|函数式强制转换|addrspace_cast}0 从 %1 转换到 %2 在不匹配的地址空间之间进行'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 from %1 to %2 is not allowed'
H0994EC770949: '从类型 %1 到 %2 的 %select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 转换不允许'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 from rvalue to reference type %2'
H79F10447DC2A: '从右值到引用类型 %2 的 %select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 转换'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2 casts away qualifiers'
H56EB9B5EABD1: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 从 %1 到 %2 的转换去除了限定符'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2, which are not related by inheritance, is not allowed'
HC3DB71EF3442: '从 %1 到 %2 的 %select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 转换不允许，因为它们之间没有继承关系'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from bit-field lvalue to reference type %2'
H1DAD5B4DA5AC: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 从位段左值到引用类型 %2 的转换'
# '%select{const_cast||||C-style cast|functional-style cast|}0 to %2, which is not a reference, pointer-to-object, or pointer-to-data-member'
H2773305E9004: '%select{const_cast||||C-style cast|functional-style cast|}0 转换到 %2，其不是引用、对象指针或数据成员指针'
# "%select{constexpr|consteval}0 function's return type %1 is not a literal type"
H8C05F94E8F5F: '%select{constexpr|consteval}0 函数的返回类型 %1 不是字面类型'
# '%select{constexpr|consteval}1 %select{function|constructor}0 never produces a constant expression'
H022CBA14DE42: '%select{constexpr|consteval}1 %select{函数|构造函数}0 的常量表达式计算始终失败'
# "%select{constexpr|consteval}2 %select{function|constructor}1's %ordinal0 parameter type %3 is not a literal type"
H6B5DAAD976BB: '%select{constexpr|consteval}2 %select{函数|构造函数}1 的第 %ordinal0 个参数类型 %3 不是字面类型'
# '%select{constructor for %1 must explicitly initialize the|implicit default constructor for %1 must explicitly initialize the|cannot use constructor inherited from base class %4;}0 %select{base class|member}2 %3 %select{which|which|of %1}0 does not have a default constructor'
HE93B407A4DE4: '%select{构造函数 %1 必须显式初始化|隐式默认构造函数 %1 必须显式初始化|不能使用从基类 %4 继承的构造函数;}0 %select{基类|成员}2 %3 %select{未|未|在 %1 中}0 具有默认构造函数'
# '%select{constructor for %1|implicit default constructor for %1|cannot use constructor inherited from %1:}0 must explicitly initialize the %select{reference|const}2 member %3'
H5DD624CAFF41: '%select{构造函数 %1|隐式默认构造函数 %1|不能使用从 %1 继承的构造函数:}0 必须显式初始化 %select{引用|const}2 成员 %3'
# '%select{constructor|destructor}1 %0 must not return void expression'
H76E14738E327: '%select{构造函数|析构函数}1 %0 不得返回 void 表达式'
# '%select{const|reference}0 member %1 will never be initialized'
H67E2118A2E7C: '%select{const|引用}0 成员 %1 将永远不会被初始化'
# '%select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1 invokes deleted constructor'
HE9CE7E623BF3: '%select{复制变量|复制参数|初始化模板参数|返回对象|初始化表达式结果|抛出对象|复制成员子对象|复制数组元素|分配对象|复制临时|初始化基类子对象|初始化向量元素|捕获值}0 类型为 %1 的对象调用了已删除的构造函数'
# '%select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}1 of type %2 when binding a reference to a temporary would %select{invoke an inaccessible constructor|find no viable constructor|find ambiguous constructors|invoke a deleted constructor}0 in C++98'
H29AE4DB3DE15: '在 C++98 中，%select{复制变量|复制参数|初始化模板参数|返回对象|初始化表达式结果|抛出对象|复制成员子对象|复制数组元素|分配对象|复制临时|初始化基类子对象|初始化向量元素|捕获值}1 类型为 %2 的对象，在绑定临时引用时会 %select{调用不可访问的构造函数|找不到有效构造函数|存在二义性构造函数|调用了已删除的构造函数}0'
# '%select{copy|move}0 assignment operator of %1 is implicitly deleted because field %2 is of %select{reference|const-qualified}4 type %3'
HA5E40C813D22: '%select{拷贝|移动}0 赋值运算符 %1 被隐式删除，因为字段 %2 是 %select{引用|const限定}4 类型 %3'
# '%select{data member %1|base class %2}0 declared here'
HC9ED4A45B57E: '%select{数据成员 %1|基类 %2}0 在此处声明'
# '%select{data member |non-public member function |static member function |user-declared constructor|user-declared destructor|operator |nested class }0%1 is not permitted within an interface type'
H9EC34E188C56: '%select{数据成员 |非公开成员函数 |静态成员函数 |用户声明构造函数|用户声明析构函数|运算符 |嵌套类 }0%1 不允许出现在接口类型中'
# '%select{declaration|definition|default argument declared|explicit specialization declared|partial specialization declared}0 here is not %select{visible|reachable|reachable|reachable|reachable|reachable}0'
H804351062C9E: '%select{声明|定义|默认参数声明|显式特化声明|部分特化声明}0 此处的 %select{不可见|不可达|不可达|不可达|不可达|不可达}0'
# "%select{declaration|definition|default argument|explicit specialization|partial specialization}0 of %1 must be imported from module '%2' before it is required"
HC491502A3888: "%select{声明|定义|默认参数|显式特化|部分特化}0 的 %1 必须在需要前从模块 '%2' 导入"
# '%select{declaration|definition|default argument|explicit specialization|partial specialization}0 of %1 must be imported from one of the following modules before it is required:%2'
HA8E1DF60359B: '%select{声明|定义|默认参数|显式特化|偏特化}0的 %1 必须在需要前从以下模块导入：%2'
# '%select{declaration|definition}0 of %select{struct|interface|union|class|enum}1 in a dependent scope'
H690477FDDE60: '%select{声明|定义}0的%select{结构体|接口|联合|类|枚举}1在依赖作用域中'
# '%select{decremented|incremented}0 here'
HD8461A402F1F: '此处%select{递减|递增}0'
# '%select{decrement|increment}0 of object of volatile-qualified type %1 is deprecated'
H57C759966E48: '%select{递减|递增}0类型为volatile限定的 %1 的对象已弃用'
# '%select{default construction|assignment}0 of lambda is incompatible with C++ standards before C++20'
H3C92D92BB26F: '%select{默认构造|赋值}0的lambda与C++20之前的C++标准不兼容'
# '%select{default constructor of|constructor inherited by}0 %1 is implicitly deleted because all %select{data members|data members of an anonymous union member}2 are const-qualified'
HF80E1E94C448: '%select{的默认构造函数|继承构造函数}0%1 因所有%select{数据成员|匿名联合成员的数据成员}2为const限定而隐式删除'
# '%select{default constructor of|constructor inherited by}0 %1 is implicitly deleted because field %2 of %select{reference|const-qualified}4 type %3 would not be initialized'
H3F45472DFCD6: '%select{的默认构造函数|继承构造函数}0 %1 被隐式删除，因为字段 %2 的 %select{引用|const限定}4 类型 %3 未被初始化'
# "%select{default constructor of|copy constructor of|move constructor of|copy assignment operator of|move assignment operator of|destructor of|constructor inherited by}0 %1 is implicitly deleted because %select{base class %3|%select{||||variant }4field %3}2 %select{has %select{no|a deleted|multiple|an inaccessible|a non-trivial}4 %select{%select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|%select{default|corresponding|default|default|default}4 constructor}0|destructor}5%select{||s||}4|is an ObjC pointer|has an address-discriminated '__ptrauth' qualifier}6"
H8B06D5202BF4: "%select{默认构造函数的|拷贝构造函数的|移动构造函数的|拷贝赋值运算符的|移动赋值运算符的|析构函数的|由继承的构造函数}0 %1 被隐式删除，因为 %select{基类 %3|%select{||||变体 }4字段 %3}2 %select{具有 %select{无|被删除的|多个|不可访问的|非平凡的}4 %select{%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数|%select{默认|对应|默认|默认|默认}4 构造函数}0|析构函数}5%select{||s||}4|是一个ObjC指针|具有地址判别型 '__ptrauth' 限定符}6"
# "%select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot be 'constexpr' in a class with virtual base class"
HAA0AD1F4C5AC: '%select{默认构造函数|复制构造函数|移动构造函数|复制赋值运算符|移动赋值运算符|析构函数}0在具有虚基类的类中不能为constexpr'
# '%select{defaulted|deleted}0 function definitions are a C++11 extension'
H2588FE2C83FF: '%select{默认化|删除化}0函数定义是C++11扩展'
# '%select{defaulted|deleted}0 function definitions are incompatible with C++98'
HE7CB963644EA: '%select{默认化|删除化}0函数定义与C++98不兼容'
# "%select{definition|#undef}0 of configuration macro '%1' has no effect on the import of '%2'; pass '%select{-D%1=...|-U%1}0' on the command line to configure the module"
H20DEB068BA86: "%select{定义|#undef}0 的配置宏 '%1' 对导入 '%2' 无影响；请通过命令行Pass'%select{-D%1=...|-U%1}0' 配置模块"
# '%select{delete|destructor}0 called on %1 that is abstract but has non-virtual destructor'
HD3B2B405330A: '对具有非虚析构函数的抽象 %1 调用 %select{delete|析构函数}0'
# '%select{delete|destructor}0 called on non-final %1 that has virtual functions but non-virtual destructor'
HD186820BFF8C: '对非final且包含虚函数但非虚析构函数的 %1 调用 %select{delete|析构函数}0'
# '%select{delimited|named}0 escape sequences are a %select{C++23|C2y|Clang}1 extension'
HDBE05BE4D14B: '%select{限定|命名}0转义序列是 %select{C++23|C2y|Clang}1 扩展'
# '%select{delimited|named}0 escape sequences are incompatible with C++ standards before C++23'
HFB62920439FF: '%select{限定|命名}0转义序列与C++23之前的C++标准不兼容'
# '%select{destination for|source of|first operand of|second operand of}0 this %1 call is a pointer to %select{|class containing a }2dynamic class %3; vtable pointer will be %select{overwritten|copied|moved|compared}4'
H63A8D05F544B: '此 %1 调用的%select{目标|源|第一个操作数|第二个操作数}0是指向 %select{|包含动态类的类}2%3 的指针；vtable指针将被%select{覆盖|复制|移动|比较}4'
# '%select{destination for|source of|first operand of|second operand of}0 this %1 call is a pointer to record %2 that is not trivial to %select{primitive-default-initialize|primitive-copy}3'
HB6A0DAA8C1C8: '%select{此 %1 调用的|源|第一个操作数的|第二个操作数的}0 目标是指向非 %select{原始默认初始化|原始复制}3 类型 %2 的指针'
# '%select{destination for|source of}0 this %1 call is a pointer to ownership-qualified type %2'
HEE4DB03498AC: '此 %1 调用的%select{目标|源}0是指向所有权限定类型 %2 的指针'
# '%select{destructor|deallocator}0 has a %select{non-throwing|implicit non-throwing}1 exception specification'
H78E56ACB6245: '%select{析构函数|解分配器}0具有%select{不抛出异常的|隐式不抛出异常的}1异常规范'
# '%select{dictionary|array}1 subscript base type %0 is not an Objective-C object'
HE2828D54BB1B: '%select{字典|array}1 下标基类型 %0 不是 Objective-C 对象'
# '%select{equality|inequality|relational|three-way}0 comparison result unused'
H69C6598EFBD9: '%select{相等|不等|关系|三向}0 比较结果未被使用'
# '%select{expected an expression statement|expected built-in assignment operator|expected expression of scalar type|expected lvalue expression}0'
H7F94DE3BA105: '%select{期望表达式语句|期望内建赋值运算符|期望标量类型表达式|期望左值表达式}0'
# "%select{expected an expression statement|expected built-in binary or unary operator|expected unary decrement/increment operation|expected expression of scalar type|expected assignment expression|expected built-in binary operator|expected one of '+', '*', '-', '/', '&', '^', '%|', '<<', or '>>' built-in operations|expected in right hand side of expression}0"
H13014A5049BE: "%select{期望表达式语句|期望内建二元或一元运算符|期望一元增减运算|期望标量类型表达式|期望赋值表达式|期望内建二元运算符|期望 '+' '*' '-' '/' '&' '^' '%' '|' '<<' 或 '>>' 内建运算|期望在表达式右侧}0"
# '%select{expected assignment expression|expected compound statement|expected exactly two expression statements|expected in right hand side of the first expression}0'
H71EE048AAB44: '%select{期望赋值表达式|期望复合语句|期望恰好两个表达式语句|期望在第一个表达式右侧}0'
# "%select{expected compound statement|expected exactly one expression statement|expected assignment statement|expected conditional operator|expect result value to be at false expression|expect binary operator in conditional expression|expect '<', '>' or '==' as order operator|expect comparison in a form of 'x == e', 'e == x', 'x ordop expr', or 'expr ordop x'|expect lvalue for result value|expect scalar value|expect integer value|unexpected 'else' statement|expect '==' operator|expect an assignment statement 'v = x'|expect a 'if' statement|expect no more than two statements|expect a compound statement|expect 'else' statement|expect a form 'r = x == e; if (r) ...'}0"
H2BEDF1CDD9ED: "%select{期望复合语句|期望恰好一个表达式语句|期望赋值语句|期望条件运算符|期望假分支结果值|期望条件表达式中的二元运算符|期望 '<' '>' 或 '==' 作为顺序运算符|期望 'x == e' 'e == x' 'x ordop expr' 或 'expr ordop x' 形式的比较|期望左值作为结果值|期望标量值|期望整数值|意外的 'else' 语句|期望 '==' 运算符|期望赋值语句 'v = x'|期望 'if' 语句|期望不超过两个语句|期望复合语句|期望 'else' 语句|期望 'r = x == e; if (r) ...' 形式}0"
# '%select{explicit|friend}0 specialization cannot have a trailing requires clause unless it declares a function template'
H4B8C1F1CA2BB: '%select{显式|友元}0 特殊化除非声明函数模板，否则不能有尾随 requires 子句'
# '%select{expression|base type|declaration type|data member type|bit-field size|static assertion|fixed underlying type|enumerator value|using declaration|friend declaration|qualifier|initializer|default argument|non-type template parameter type|exception type|explicit specialization|partial specialization|__if_exists name|__if_not_exists name|lambda|block|type constraint|requirement|requires clause}0 contains%plural{0: an|:}1 unexpanded parameter pack%plural{0:|1: %2|2:s %2 and %3|:s %2, %3, ...}1'
HE9A8E0B2E8F5: '%select{表达式|基类型|声明类型|数据成员类型|位段大小|静态断言|固定底层类型|枚举值|使用声明|友元声明|限定符|初始化器|默认参数|非类型模板参数类型|异常类型|显式特殊化|部分特殊化|__if_exists 名称|__if_not_exists 名称|lambda|block|类型约束|需求|requires 子句}0 包含 %plural{0: 一个|:}1 未展开的参数包 %plural{0:|1: %2|2:s %2 和 %3|:s %2, %3, ...}1'
# '%select{extension|category}0 of non-parameterized class %1 cannot have type parameters'
H6F4F8CBFDF9B: '%select{扩展|分类}0 非参数化类 %1 不能有类型参数'
# '%select{fewer|more}0 specifiers in format string than expected'
H294968301C0D: '%select{更少|更多}0 格式说明符在格式字符串中比期望的'
# "%select{field width|precision}0 used with '%1' conversion specifier, resulting in undefined behavior"
H2CF9930D6217: " '%1' 转换说明符使用了%select{字段宽度|精度}0，导致未定义行为"
# '%select{field|base class}0 %1 will be initialized after %select{field|base}2 %3'
HE92BDD84B944: '%select{字段|基类}0 %1 将在 %select{字段|基类}2 %3 之后被初始化'
# '%select{first two|all}1 arguments to %0 must be vectors'
HF5292D19FFBC: '%select{前两个|所有}1 个 %0 参数必须是向量类型'
# '%select{first two|all}1 arguments to %0 must have the same type'
H648C1151AF74: '%select{前两个|所有}1 个 %0 参数必须具有相同类型'
# "%select{first|second|third|fourth}0 parameter of 'main' (%select{argument count|argument array|environment|platform-specific data}0) must be of type %1"
HF5B9D5CD8E73: "%select{第一个|第二个|第三个|第四个}0 'main' 参数 (%select{参数计数|参数数组|环境|平台特定数据}0) 必须为类型 %1"
# '%select{first|second|third}0 parameter has unexpected type %1 (should be %2)'
HB94305DC6AD8: '%select{第一个|第二个|第三个}0 参数类型意外 %1（应为 %2）'
# '%select{first|second}0 operand was implicitly converted to type %1'
HBF77ADC8F095: '%select{第一个|第二个}0 操作数被隐式转换为类型 %1'
# '%select{forward class declaration|class definition|category|extension}0 has too %select{few|many}1 type parameters (expected %2, have %3)'
HF027D432E158: '%select{前向类声明|类定义|类别|扩展}0 的类型参数数量%select{太少|太多}1（期望 %2，实际 %3）'
# '%select{function %1 which returns const-qualified type %2 declared here|variable %1 declared const here|%select{non-|}1static data member %2 declared const here|member function %q1 is declared const here|%select{|nested }1data member %2 declared const here}0'
HA9209A7005BD: '%select{返回const限定类型 %2 的函数 %1 在此声明|在此声明为const的变量 %1|非%select{静态|匿名}1数据成员 %2 在此声明为const|在此声明为const的成员函数%q1|%select{嵌套|}1 数据成员 %2 在此声明为const}0'
# '%select{function parameter|typedef}0 cannot be %select{<ERROR>|constexpr|consteval|constinit}1'
H86C3A8B0C257: '%select{函数参数|typedef}0 不能是 %select{<ERROR>|constexpr|consteval|constinit}1'
# '%select{function template|class template|variable template|type alias template|template template parameter}0 %1 declared here'
H91E08CCD64B6: '%select{函数模板|类模板|变量模板|类型别名模板|模板模板参数}0 %1 在此处声明'
# '%select{function with deduced return type|declaration with trailing return type}0 must be the only declaration in its group'
HA1CB6C2DD073: '%select{具有推导返回类型的函数|带有尾随返回类型的声明}0 必须是其组中唯一的声明'
# "%select{function|block|lambda|coroutine}0 declared 'noreturn' should not return"
HBB674CBF2E79: "%select{函数|代码块|lambda|协程}0 声明为 'noreturn' 不应返回"
# "%select{function|class|variable}0 cannot be defined in an explicit instantiation; if this declaration is meant to be a %select{function|class|variable}0 definition, remove the 'template' keyword"
HF2F19E25243A: "%select{函数|类|变量}0 不能在显式实例化中定义；如果此声明旨在作为 %select{函数|类|变量}0 的定义，请移除 'template' 关键字"
# "%select{function|constructor|destructor|lambda|block|member initializer of constructor}0 with '%1' attribute must not %select{allocate or deallocate memory|throw or catch exceptions|have static local variables|use thread-local variables|access ObjC methods or properties}2"
H8DE43E9D40B0: "%select{函数|构造函数|析构函数|lambda|代码块|构造函数的成员初始化器}0 具有 '%1' 属性，不得 %select{分配或释放内存|抛出或捕获异常|具有静态局部变量|使用线程局部变量|访问ObjC方法或属性}2"
# "%select{function|constructor|destructor|lambda|block|member initializer of constructor}0 with '%1' attribute must not call non-'%1' %select{function|constructor|destructor|lambda|block}2 '%3'"
HD57CFC80D164: "%select{函数|构造函数|析构函数|lambda|代码块|构造函数的成员初始化器}0 具有 '%1' 属性，不得调用非 '%1' %select{函数|构造函数|析构函数|lambda|代码块}2 '%3'"
# "%select{function|constructor|destructor|lambda|block|member initializer of constructor}0 with '%1' attribute must not call non-'%1' expression"
H5BD0868978EA: "%select{函数|构造函数|析构函数|lambda|代码块|构造函数的成员初始化器}0 具有 '%1' 属性，不得调用非 '%1' 表达式"
# "%select{function|constructor|destructor|lambda|block|member initializer}0 cannot be inferred '%1' because it %select{allocates or deallocates memory|throws or catches exceptions|has a static local variable|uses a thread-local variable|accesses an ObjC method or property}2"
H2867CEC6E928: "%select{函数|构造函数|析构函数|lambda|代码块|成员初始化器}0 无法推断 '%1' 属性，因为其 %select{分配或释放内存|抛出或捕获异常|具有静态局部变量|使用线程局部变量|访问ObjC方法或属性}2"
# "%select{function|constructor|destructor|lambda|block|member initializer}0 cannot be inferred '%1' because it calls non-'%1' %select{function|constructor|destructor|lambda|block}2 '%3'"
H314F30794920: "%select{函数|构造函数|析构函数|lambda|代码块|成员初始化器}0 无法推断 '%1' 属性，因为其调用了非 '%1' %select{函数|构造函数|析构函数|lambda|代码块}2 '%3'"
# "%select{function|constructor|destructor|lambda|block}0 does not permit inference of '%1' because it is declared '%2'"
HB9A03E541F67: "%select{函数|构造函数|析构函数|lambda|代码块}0 无法推断 '%1' 属性，因其已被声明为 '%2'"
# "%select{function|constructor|destructor|lambda|block}0 with '%1' attribute should be declared noexcept"
HB030E37D6AD6: "%select{函数|构造函数|析构函数|lambda|代码块}0 具有 '%1' 属性时应声明为 noexcept"
# "%select{function|kernel}0 cannot be called 'main'"
H12368C59A019: "%select{函数|内核函数}0 不能名为 'main'"
# '%select{function|method|block}0 has been explicitly marked sentinel here'
H02C89F36F346: '%select{函数|方法|代码块}0 在此处被显式标记为 sentinel'
# "%select{function|method}0 %1 could be declared with attribute 'noreturn'"
H2A06C5AB5A01: "%select{函数|方法}0 %1 可以用属性 'noreturn' 进行声明"
# "%select{function|parameter}0 declared '[[carries_dependency]]' after its first declaration"
HA7BEBD006826: "%select{函数|参数}0 声明为 '[[carries_dependency]]'，但此属性出现在其首次声明之后"
# '%select{function|variable}0 %1 is not needed and will not be emitted'
HF8ADE574A433: '%select{函数|变量}0 %1 未被使用且将不会被编译'
# '%select{function|variable}0 %q1 has internal linkage but is not defined'
H45C099CD2E21: '%select{函数|变量}0 %q1 具有内部链接但未被定义'
# '%select{function|variable}0 %q1 is used but not defined in this translation unit, and cannot be defined in any other translation unit because its type does not have linkage'
H4CCCEB729733: '%select{函数|变量}0 %q1 在此翻译单元中被使用但未定义，且其类型无链接性，因此无法在其他翻译单元中定义'
# '%select{global|private}0 module fragment cannot be exported'
H32D31F303DCC: '%select{全局|私有}0 模块片段无法被导出'
# '%select{hex|octal}0 escape sequence out of range'
HD900722CD654: '%select{十六进制|八进制}0 转义序列超出范围'
# '%select{if|switch}0 initialization statements are incompatible with C++ standards before C++17'
H48F2A35749E7: '%select{if|switch}0 初始化语句与 C++17 之前的 C++ 标准不兼容'
# '%select{implicit conversion|cast}0 of %select{%2|a non-Objective-C pointer type %2|a block pointer|an Objective-C pointer|an indirect pointer to an Objective-C pointer}1 to %3 is disallowed with ARC'
H2BE56E173B04: '%select{隐式转换|强制类型转换}0 将 %select{%2|非 Objective-C 指针类型 %2|块指针|Objective-C 指针|指向 Objective-C 指针的间接指针}1 转换为 %3 在 ARC 中不允许'
# '%select{implicit conversion|cast}0 of weak-unavailable object of type %1 to a __weak object of type %2'
H5E0A61E4DC2C: '%select{隐式转换|显式转换}0 类型为 %1 的 weak-unavailable 对象到类型为 %2 的 __weak 对象'
# '%select{implicitly |}2captured%select{| by reference}3%select{%select{ due to use|}2 here| via initialization of lambda capture %0}1'
H0BA3D7D599E5: '%select{隐式 |}2 捕获 %select{|通过引用}3%select{%select{ 因为此处的使用|}2 |通过 lambda 捕获 %0 的初始化}1'
# '%select{implicit|explicit}0 instantiation first required here'
HB12903FE55DA: '%select{隐式|显式}0 实例化首次在此处需要'
# '%select{implicit|explicit}0 instantiation of template %1 within its own definition'
H0FEA9F8C421A: '%select{隐式|显式}0 实例化模板 %1 在其自身定义中'
# '%select{implicit|explicit}0 instantiation of undefined template %1'
H04E01542E9F2: '%select{隐式|显式}0 实例化未定义的模板 %1'
# "%select{incompatible|duplicate}0 directives '%1' and '%2'"
HEFD5CC9864D7: "%select{不兼容|重复}0 指令 '%1' 和 '%2'"
# '%select{instance variable|property}2 with %0 attribute must be an object type (invalid %1)'
HFD8E12A874BC: '%select{实例变量|属性}2 需要 %0 属性必须为对象类型（无效 %1）'
# '%select{instance|class}1 method %0 not found ; did you mean %2?'
H113C6B0985AF: '%select{实例|类}1 方法 %0 未找到；是否想表达 %2？'
# '%select{integer|float}0 literal is too large to be represented as a %select{32-bit %select{signed|}1 integer|float}0 type'
H84C45039D88A: '%select{整数|浮点}0 字面量过大无法表示为 %select{32 位 %select{有符号|}1 整数|浮点}0 类型'
# '%select{integer|integral}1 constant expression must have %select{integer|integral or unscoped enumeration}1 type, not %0'
H07847569345A: '%select{整型|积分型}1 常量表达式必须具有 %select{整型|积分型或无作用域枚举}1 类型，而非 %0'
# "%select{interrupt service routine|function with attribute 'no_caller_saved_registers'}0 should only call a function with attribute 'no_caller_saved_registers' or be compiled with '-mgeneral-regs-only'"
HE2C243372C8E: "%select{中断服务例程|带有属性 'no_caller_saved_registers' 的函数}0 应仅调用带有 'no_caller_saved_registers' 属性的函数或使用 '-mgeneral-regs-only' 编译"
# "%select{invalid use of|unknown}2 attribute subject matcher sub-rule '%0'; '%1' matcher %select{does not support sub-rules|supports the following sub-rules: %3}2"
H8BFF482F0D6A: "%select{无效用法|未知}2 属性匹配子规则 '%0'；'%1' 匹配器 %select{不支持子规则|支持以下子规则： %3}2"
# "%select{invalid value '%0'; must be positive|value '%0' is too large}1"
HEC3DA4A69943: "%select{无效值 '%0'；必须为正数|值 '%0' 过大}1"
# "%select{invalid|missing}0 option%select{ %1|}0; expected 'contract', 'reassociate', 'reciprocal', or 'exceptions'"
H280D64C6E2E8: "%select{无效|缺失}0 选项%select{ %1|}0；期望 'contract'、'reassociate'、'reciprocal' 或 'exceptions'"
# '%select{invalid|missing}0 option%select{ %1|}0; expected vectorize, vectorize_width, interleave, interleave_count, unroll, unroll_count, pipeline, pipeline_initiation_interval, vectorize_predicate, or distribute'
HC3AB036EF44A: '%select{无效|缺失}0 选项%select{ %1|}0；期望 vectorize、vectorize_width、interleave、interleave_count、unroll、unroll_count、pipeline、pipeline_initiation_interval、vectorize_predicate 或 distribute'
# '%select{in|co|contra}0variant type parameter %1 conflicts with previous %select{in|co|contra}2variant type parameter %3'
H893590D91D8F: '%select{in|co|contra}0variant 类型参数 %1 与之前的 %select{in|co|contra}2variant 类型参数 %3 冲突'
# '%select{left |right |}0operand to %select{assignment|compound assignment|increment|decrement}1 expression must be %select{an l-value|of scalar type (was %3)}2'
H115469577E3D: '%select{左|右|}0 操作数到 %select{赋值|复合赋值|递增|递减}1 表达式必须为 %select{l-value|标量类型（实际类型为 %3）}2'
# '%select{left|right}0 side of operator converted from negative value to unsigned: %1'
H1DC6B6DA95C3: '%select{左|右}0 操作数的运算符将负值转换为无符号数：%1'
# '%select{left|right}1 operand to ? is void, but %select{right|left}1 operand is of type %0'
H8125EE82CC5A: '%select{左|右}1 操作数到 ? 运算符的类型为 void，但 %select{右|左}1 操作数类型为 %0'
# '%select{loading directly from|assigning directly to}0 pointer to type %1 requires cl_khr_fp16. Use vector data %select{load|store}0 builtin functions instead'
H66CF7FCAA26B: '%select{直接加载自|直接赋值到}0 类型为 %1 的指针需要 cl_khr_fp16 扩展。请改用向量数据 %select{加载|存储}0 内建函数'
# '%select{local variable|parameter|typedef}0 %1 cannot be declared __module_private__'
H1DE6DC0BF8C5: '%select{局部变量|参数|typedef类型}0 %1 不能声明为 __module_private__'
# "%select{map type '%1' is not allowed|map type must be specified}0 for '#pragma omp %2'"
HA49CE3340880: "%select{映射类型 '%1' 不允许|必须指定映射类型}0 用于 '#pragma omp %2'"
# "%select{missing '#include'|missing '#include %3'}2; %select{||default argument of |explicit specialization of |partial specialization of }0%1 must be %select{declared|defined|defined|declared|declared}0 before it is used"
H0EC06C773CD9: "%select{缺少 '#include'|缺少 '#include %3'}2; %select{||默认参数的 |显式特例化的 |部分特例化的 }0%1 必须在使用前被 %select{声明|定义|定义|声明|声明}0"
# '%select{no_destroy|always_destroy}0 attribute can only be applied to a variable with static or thread storage duration'
H7D17D7EDA6B0: '%select{no_destroy|always_destroy}0 属性只能应用于具有静态或线程存储持续期的变量'
# '%select{non-constexpr|constexpr|consteval}1 declaration of %0 follows %select{non-constexpr|constexpr|consteval}2 declaration'
H2DCC831B3932: '%select{非 constexpr|constexpr|consteval}1 声明的 %0 跟随 %select{非 constexpr|constexpr|consteval}2 声明'
# '%select{non-constexpr|undefined}0 %select{function|constructor}1 %2 cannot be used in a constant expression'
H338EAA31FD42: '%select{非 constexpr|未定义}0 %select{函数|构造函数}1 %2 不能用于常量表达式'
# '%select{non-const|volatile}0 lvalue reference %diff{to type $ cannot bind to a temporary of type $|cannot bind to incompatible temporary}1,2'
HD89DCBC20587: '%select{非 const|volatile}0 左值引用 %diff{到类型 $ 不能绑定到临时类型 $|不能绑定到不兼容的临时}1,2'
# '%select{non-const|volatile}0 lvalue reference %diff{to type $ cannot bind to a value of unrelated type $|cannot bind to a value of unrelated type}1,2'
H1777D1633EE8: '%select{非 const|volatile}0 左值引用 %diff{到类型 $ 不能绑定到无关类型 $|不能绑定到无关类型}1,2'
# '%select{non-const|volatile}0 lvalue reference to type %1 cannot bind to an initializer list temporary'
H3CF62E12AA3E: '%select{非 const|volatile}0 类型 %1 的左值引用不能绑定到初始化列表临时值'
# '%select{non-const|volatile}0 reference cannot bind to bit-field%select{| %1}2'
H8AF09902E67B: '%select{非 const|volatile}0 引用不能绑定到位段 %select{| %1}2'
# '%select{non-const|volatile}0 reference cannot bind to matrix element'
HA82833F246FF: '%select{非 const|volatile}0 引用不能绑定到矩阵元素'
# '%select{non-const|volatile}0 reference cannot bind to vector element'
H6E26FD01A944: '%select{非 const|volatile}0 引用不能绑定到向量元素'
# '%select{non-integral type %0|%0}1 is an invalid underlying type'
HAB3E494D65F5: '%select{非整型类型 %0|%0}1 是无效的基础类型'
# '%select{non-kernel function|function scope}0 variable cannot be declared in %1 address space'
H0866366952CF: '%select{非内核函数|函数作用域}0 变量不能声明在 %1 地址空间中'
# "%select{non-member function|static member function|explicit object member function|deduction guide}0 %select{of type %2 |}1cannot have '%3' qualifier"
HFB817CBCD184: "%select{非成员函数|静态成员函数|显式对象成员函数|推导指引}0 %select{的类型 %2 |}1 不能有 '%3' 限定符"
# '%select{non-member|member}0 %select{<ERROR>|equality|three-way|equality|relational}1 comparison operator must have %select{2|1}0 parameters'
HB5C9D99264DA: '%select{非成员|成员}0 %select{<ERROR>|相等|三向|相等|关系}1 比较运算符必须有 %select{2|1}0 个参数'
# '%select{non-member|static member|non-static member}0 function cannot perform a tail call to %select{non-member|static member|non-static member|pointer-to-member}1 function%select{| %3}2'
HE869F55E570F: '%select{非成员|静态成员|非静态成员}0 函数不能尾调用 %select{非成员|静态成员|非静态成员|成员指针}1 函数 %select{| %3}2'
# "%select{non-pointer|function pointer|void pointer}0 argument to '__builtin_launder' is not allowed"
H5F5CB4F84C85: "%select{非指针|函数指针|void 指针}0 参数传递给 '__builtin_launder' 不允许"
# "%select{non-struct type|non-class type|non-union type|non-enum type|typedef|type alias|template|alias template|template template argument}1 %0 cannot be referenced with the '%select{struct|interface|union|class|enum}2' specifier"
HA353FC8D883A: "%select{非结构体类型|非类类型|非联合类型|非枚举类型|typedef|类型别名|模板|别名模板|模板模板参数}1 %0 不能通过 '%select{struct|interface|union|class|enum}2' 规范符引用"
# '%select{non-virtual|virtual}0 derivation here'
H7895E4BCBED9: '此处%select{非虚|虚}0派生'
# "%select{non-|function }0pointer argument to '__builtin_is_within_lifetime' is not allowed"
HEC6E2A0FBA29: "传递给 '__builtin_is_within_lifetime' 的%select{非-|函数 }0指针参数不允许"
# '%select{non-|}0overlapping comparisons always evaluate to %select{false|true}0'
HDA33BE63192F: '%select{非|}0 重叠比较始终求值为 %select{假|真}0'
# '%select{non-|}0type aware %1 declared here in %2'
HC09774CA5903: '%select{非-|}0 类型感知 %1 在 %2 中声明于此'
# "%select{no|too many}0 integer expression arguments provided to OpenACC 'num_gangs' %select{|clause: '%1' directive expects maximum of %2, %3 were provided}0"
HDF54FE517944: "为OpenACC 'num_gangs' %select{|子句 '%1' 指令最多接受 %2，但提供了 %3 个}0提供了 %select{no|too many}0 整型表达式参数"
# "%select{orphaned 'omp section' directives are prohibited, it|'omp section' directive}0 must be closely nested to a sections region%select{|, not a %1 region}0"
HF07F4A64D372: "%select{孤儿的 'omp section' 指令被禁止，它|'omp section' 指令}0必须紧密嵌套到一个 sections 区域 %select{|，而不是一个 %1 区域}0"
# "%select{overridden|current}0 method is explicitly declared 'instancetype'%select{| and is expected to return an instance of its class type}0"
HB89C11914779: "%select{覆盖|当前}0方法显式声明为 'instancetype'%select{|并期望返回其类类型的实例}0"
# "%select{overridden|current}0 method is part of the '%select{|alloc|copy|init|mutableCopy|new|autorelease|dealloc|finalize|release|retain|retainCount|self}1' method family%select{| and is expected to return an instance of its class type}0"
HB76B1E081BAA: "%select{覆盖|当前}0方法属于 '%select{|alloc|copy|init|mutableCopy|new|autorelease|dealloc|finalize|release|retain|retainCount|self}1' 方法族 %select{|并期望返回其类类型的实例}0"
# '%select{parameters|function return value}0 cannot have __fp16 type; did you forget * ?'
H3BDED28AD784: '%select{参数|函数返回值}0不能具有 __fp16 类型；是否漏掉了 * ？'
# '%select{parameter|non-static data member}3 %0 %select{|of %1 }3shadows member inherited from type %2'
H35412B47BBE2: '%select{参数|非静态数据成员}3 %0 %select{|of %1 }3遮蔽了从类型 %2 继承的成员'
# '%select{parameter|parameter pack}0 declared here'
H2699C14A1A0C: '%select{参数|参数包}0 声明于此'
# "%select{parenthesize the third argument|cast the second argument to 'int'}0 to silence"
H798E3A404637: '%select{括号化第三个参数|将第二个参数强制转换为 int}0 来消除警告'
# '%select{partial specialization|explicit specialization|explicit instantiation}0 of alias templates is not permitted'
H336DD87FEE99: '%select{部分特化|显式特化|显式实例化}0 别名模板是不允许的'
# '%select{pointers|references}0 are unsupported in HLSL'
H134DDEB0FD66: '%select{指针|引用}0 在HLSL中不受支持'
# '%select{pointers|references}0 to functions are not allowed'
H30519C3FCFC8: '函数%select{指针|引用}0不允许'
# '%select{pointer|block pointer|member pointer}0 is missing a nullability type specifier (_Nonnull, _Nullable, or _Null_unspecified)'
HF29961D95705: '%select{指针|块指针|成员指针}0 缺少空值类型说明符 (_Nonnull, _Nullable 或 _Null_unspecified)'
# '%select{pointer|reference}0 to %select{|subobject of }1%select{temporary|%3}2 is not a constant expression'
H7F2DE7357BB3: '%select{指向|指向子对象的 %select{|%3}2 的 %select{临时对象|}1 指针}0 不是一个常量表达式'
# "%select{pointer|reference}0 to %select{|subobject of }1%select{type_info object|string literal|temporary object|predefined '%3' variable}2 is not allowed in a template argument"
HD8CE51EB9A3E: "%select{指向|引用}0 %select{|子对象的 }1%select{type_info对象|字符串字面量|临时对象|预定义的 '%3' 变量}2 不能在模板参数中使用"
# '%select{pointer|reference}0 to %select{|subobject of }1heap-allocated object is not a constant expression'
H9D1E7F5B4FD5: '%select{指向|引用}0 %select{|子对象的 }1堆分配对象不是常量表达式'
# '%select{pointer|reference}0 to WebAssembly reference type is not allowed'
HECDCB166B532: '%select{指针|引用}0 到 WebAssembly 引用类型不允许'
# '%select{pointer|reference}0 to a consteval declaration is not a constant expression'
H8FC8E4B28636: '%select{指针|引用}0 到 consteval 声明不是常量表达式'
# '%select{pointer|reference}1 to non-const type %0 with no explicit ownership'
H0FF342784C44: '%select{指针|引用}1 到非 const 类型 %0 未显式指定所有权'
# "%select{precompiled file '%1' was|current translation unit is}0 compiled with the target feature '%2' but the %select{current translation unit is|precompiled file '%1' was}0 not"
H61983A41BC0C: "%select{预编译文件 '%1' 构建时|当前翻译单元}0 启用了目标特性 '%2' 但 %select{当前翻译单元|预编译文件 '%1'}0 未启用"
# '%select{precompiled header|module}0 uses __DATE__ or __TIME__'
H2637E05CCFD6: '%select{预编译头|模块}0使用了__DATE__或__TIME__'
# '%select{program scope|static local|extern}0 variable must reside in %1 address space'
H8250A4383E97: '%select{程序作用域|静态局部|extern}0 变量必须位于 %1 地址空间中'
# '%select{property|instance variable}0 access cannot be qualified with %1'
H8153C2BE3904: '%select{属性|实例变量}0的访问不能使用 %1 修饰符'
# "%select{public|private|project}1 umbrella header file not found in input: '%0'"
HFB4B45B92460: "%select{公共|私有|项目}1 伞状头文件未在输入中找到: '%0'"
# "%select{qualifier in |static |}0array size %select{||'[*] '}0is a C99 feature"
H5561702CDE0D: "%select{限定符在 |静态 |}0 数组大小 %select{||'[*] '}0 是C99特性"
# "%select{qualifier in |static |}0array size %select{||'[*] '}0is a C99 feature, not permitted in C++"
HD9EDD0C87400: "%select{限定符在 |静态 |}0 数组大小 %select{||'[*] '}0 是C99特性，不被C++允许"
# '%select{read of|read of|assignment to|increment of|decrement of|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>}0 volatile %select{temporary|object %2|member %2}1 is not allowed in a constant expression'
H88BF34501395: '%select{读取|读取|对...的赋值|递增|递减|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>}0 volatile %select{临时对象|对象 %2|成员 %2}1 在常量表达式中不允许'
# '%select{read of|read of|assignment to|increment of|decrement of|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>}0 volatile-qualified type %1 is not allowed in a constant expression'
HFA8AACB1DC9D: '%select{读取|读取|对...的赋值|递增|递减|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>}0 %1 的volatile限定类型在常量表达式中不允许'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of subobject of|destruction of|read of}0 %select{object outside its lifetime|uninitialized object}1 is not allowed in a constant expression'
H030F1EA383B2: '%select{读取|读取|对...的赋值|递增|递减|成员调用|dynamic_cast|typeid应用|子对象构造|析构|读取}0 %select{超出其生命周期的对象|未初始化对象}1在常量表达式中不允许'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of subobject of|destruction of|read of}0 member %1 of union with %select{active member %3|no active member}2 is not allowed in a constant expression'
HAA36C87281CE: '%select{读取|读取|对...的赋值|递增|递减|成员调用|dynamic_cast|typeid应用|子对象构造|析构|读取}0 union成员 %1 在%select{有活动成员 %3|无活动成员}2时不允许出现在常量表达式中'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 %select{temporary|variable}1 whose %plural{8:storage duration|:lifetime}0 has ended'
H1E2EE7FC7CDC: '%select{读取|读取|对...的赋值|递增|递减|成员调用|dynamic_cast|typeid应用|构造|析构|读取}0 %select{临时对象|变量}1其 %plural{8:存储持续期|:生命周期}0已结束'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 dereferenced null pointer is not allowed in a constant expression'
H22FE9FDFDD6D: '%select{读取|读取|对...的赋值|递增|递减|成员调用|dynamic_cast|typeid应用|构造|析构|读取}0 解引用空指针在常量表达式中不允许'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 dereferenced one-past-the-end pointer is not allowed in a constant expression'
H0D344CA7C10F: '%select{读取|读取|对...的赋值|递增|递减|成员调用|dynamic_cast|typeid应用|构造|析构|读取}0 解引用结束位置后指针在常量表达式中不允许'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 element of array without known bound is not allowed in a constant expression'
H5DD079C28614: '%select{读取|读取|对...的赋值|递增|递减|成员调用|dynamic_cast|typeid应用|构造|析构|读取}0 未知边界数组的元素在常量表达式中不允许'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 heap allocated object that has been deleted'
H0F4326DA1EA9: '%select{读取|读取|对...的赋值|递增|递减|成员调用|dynamic_cast|typeid应用|构造|析构|读取}0 已被删除的堆分配对象在常量表达式中不允许'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 mutable member %1 is not allowed in a constant expression'
H08EBC2661AFA: '%select{读取|读取|对...的赋值|递增|递减|成员调用|dynamic_cast|typeid应用|构造|析构|读取}0 mutable成员 %1 在常量表达式中不允许'
# "%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 object '%1' whose value is not known"
H2547ED9973E0: "%select{读取|读取|对...的赋值|递增|递减|成员调用|dynamic_cast|typeid应用|构造|析构|读取}0 值未知的对象 '%1' 在常量表达式中不允许"
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 temporary is not allowed in a constant expression outside the expression that created the temporary'
H1A04D5C0C6D4: '%select{读取|读取|对...的赋值|递增|递减|成员调用|dynamic_cast|typeid应用|构造|析构|读取}0 临时对象在创建它的表达式之外的常量表达式中不允许'
# '%select{reading|writing}1 the value pointed to by %0 requires holding %select{any mutex|any mutex exclusively}1'
H20B2C79559EA: '%select{读取|写入}1所指向的 %0 需要持有%select{任意互斥锁|独占互斥锁}1'
# '%select{reading|writing}1 variable %0 requires holding %select{any mutex|any mutex exclusively}1'
HAB41C50F5547: '%select{读取|写入}1变量 %0 需要持有%select{任意互斥锁|独占互斥锁}1'
# "%select{reading|writing}3 the value pointed to by %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
HA3CF53D5D321: "%select{读取|写入}3 %1 所指向的值需要保持 %0 %select{'%2'|' 独占的 %2'}3"
# "%select{reading|writing}3 variable %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
HBF61FE4FFCA3: "%select{读取|写入}3 变量 %1 需要保持 %0 %select{'%2'|' 独占的 %2'}3"
# "%select{reference|backing array for 'std::initializer_list'}2 %select{|subobject of }1member %0 %select{binds to|is}2 a temporary object whose lifetime is shorter than the lifetime of the constructed object"
H31A36503387B: "%select{引用|'std::initializer_list' 的后备数组}2 %select{|成员 %0 的子对象}1 %select{绑定到|是}2 一个临时对象，其生命周期比构造对象的生命周期短"
# "%select{reference|backing array for 'std::initializer_list'}2 %select{|subobject of }1member %0 %select{binds to|is}2 a temporary object whose lifetime would be shorter than the lifetime of the constructed object"
H54C5751F42B3: "%select{引用|'std::initializer_list' 的后备数组}2 %select{|成员 %0 的子对象}1 %select{绑定到|是}2 一个临时对象，其生命周期将比构造对象的生命周期短"
# '%select{reference|pointer}0 member declared here'
H8AC5A0A64CFD: '%select{引用|指针}0 成员在此声明'
# '%select{reinterpret_cast|C-style cast}0 from %1 to %2 changes address space of nested pointers'
HDAB148B74E30: '从 %1 到 %2 的 %select{reinterpret_cast|C风格转换}0更改了嵌套指针的地址空间'
# '%select{reinterpret_cast|dynamic_cast|%select{this conversion|cast that performs the conversions of a reinterpret_cast}1|cast from %1}0 is not allowed in a constant expression%select{| in C++ standards before C++20||}0'
H1688ED0E5178: '%select{reinterpret_cast|dynamic_cast|%select{此转换|执行reinterpret_cast转换的转换}1|来自 %1 的转换}0 在常量表达式中不允许 %select{|在C++20之前的C++标准中||}0'
# '%select{remainder|division}0 by zero is undefined'
HDDF6DBF3AFB2: '%select{余数|除法}0 除以零是未定义的'
# "%select{return type|parameter type|property}1 may not be qualified with '__ptrauth'; type is %0"
H89CAD73DCBC0: "%select{返回类型|参数类型|属性}1 不可使用 '__ptrauth' 限定符修饰；类型为 %0"
# '%select{returning|passing}0 a VL-dependent argument %select{from|to}0 a function with a different streaming-mode is undefined behaviour when the streaming and non-streaming vector lengths are different at runtime'
HD835E99E7B94: '%select{返回|传递}0 一个VL相关的参数%select{从|到}0 具有不同流式模式的函数，在流式和非流式向量长度运行时不同的情况下属于未定义行为'
# '%select{returning|passing}0 a VL-dependent argument %select{from|to}0 a locally streaming function is undefined behaviour when the streaming and non-streaming vector lengths are different at runtime'
H78DE8F398FA2: '%select{返回|传递}0 一个VL相关的参数%select{从|到}0 一个本地流式函数，在流式和非流式向量长度运行时不同的情况下属于未定义行为'
# '%select{return|parameter|variable|field|instance variable|synthesized instance variable}0 type %1 is an abstract class'
H83DAE33A1A29: '%select{返回类型|参数类型|变量类型|字段类型|实例变量类型|合成实例变量类型}0 %1 是抽象类'
# "%select{self-|array |pointer }0comparison always evaluates to %select{a constant|true|false|'std::strong_ordering::equal'}1"
H25C7EE9B164E: "%select{自我|数组 |指针 }0比较始终计算为%select{一个常量|true|false|'std::strong_ordering::equal'}1"
# "%select{shader model|Vulkan environment|shader stage}0 '%1' in target '%2' is invalid for HLSL code generation"
H559D5EF03AE6: "%select{着色器模型|Vulkan环境|着色器阶段}0 '%1' 在目标 '%2' 中对HLSL代码生成无效"
# "%select{shader model|Vulkan environment|shader stage}0 is required as %select{OS|environment}1 in target '%2' for HLSL code generation"
H2955A7AC1204: "需要将%select{着色器模型|Vulkan环境|着色器阶段}0 指定为%select{操作系统|环境}1 在目标 '%2' 中进行HLSL代码生成"
# '%select{signed value|extra discriminator|blended pointer|blended integer}0 must have %select{pointer|integer|pointer or integer}1 type; type here is %2'
HA4822404707C: '%select{有符号值|额外判别器|混合指针|混合整数}0 必须具有%select{指针|整数|指针或整数}1 类型；此处类型为 %2'
# "%select{signed |}0'size_t' literal is out of range of possible %select{signed |}0'size_t' values"
HADACA5CF45B7: "'%select{有符号 |}0'size_t' 字面量超出可能%select{有符号 |}0'size_t' 值的范围"
# '%select{signed|unsigned}0 _BitInt must have a bit size of at least %select{2|1}0'
H866585566251: '%select{有符号|无符号}0 _BitInt 必须具有至少 %select{2|1}0 位大小'
# '%select{signed|unsigned}0 _BitInt of bit sizes greater than %1 not supported'
HB66515AEE2F3: '%select{有符号|无符号}0 _BitInt 的位大小超过 %1 不受支持'
# "%select{source|destination}2 of '%select{%select{memcpy|wmemcpy}1|%select{memmove|wmemmove}1}0' is %3"
H752C91AB4DE4: "'%select{%select{memcpy|wmemcpy}1|%select{memmove|wmemmove}1}0' 的%select{源|目标}2 是 %3"
# "%select{statement after '#pragma omp %1' must be a for loop|expected %2 for loops after '#pragma omp %1'%select{|, but found only %4}3}0"
H5AE78EDFB051: '%select{#pragma omp %1 后的语句必须是一个for循环|期望在#pragma omp %1 后有 %2 个for循环 %select{|，但仅找到 %4}3}0'
# '%select{statement|directive}0 outside teams construct here'
HCEC20E30EFC9: '%select{语句|指令}0 在 teams 结构外部此处'
# "%select{static data member is predetermined as shared|variable with static storage duration is predetermined as shared|loop iteration variable is predetermined as private|loop iteration variable is predetermined as linear|loop iteration variable is predetermined as lastprivate|constant variable is predetermined as shared|global variable is predetermined as shared|non-shared variable in a task construct is predetermined as firstprivate|variable with automatic storage duration is predetermined as private}0%select{|; perhaps you forget to enclose 'omp %2' directive into a parallel or another task region?}1"
HF1446F769957: "%select{静态数据成员被预设为共享|具有静态存储期的变量被预设为共享|循环迭代变量被预设为私有|循环迭代变量被预设为线性|循环迭代变量被预设为 lastprivate|常量变量被预设为共享|全局变量被预设为共享|任务构造中非共享变量被预设为 firstprivate|自动存储期变量被预设为私有}0%select{|; 或许您忘记将 'omp %2' 指令包含在并行或另一个任务区域内？}1"
# "%select{string|character|boolean|numeric}0 literal must be prefixed by '@' in a collection"
H437BC3E10750: "%select{字符串|字符|布尔|数值}0 文字必须以前缀 '@' 开头"
# "%select{string|numeric}0 literal must be prefixed by '@'"
HE32E641B2BF1: "%select{字符串|数值}0 文字必须以前缀 '@' 开头"
# '%select{struct|interface|class}0 with virtual base %plural{1:class|:classes}1 is not a literal type'
H74349A7BD7CA: '%select{struct|interface|class}0 含有虚基类 %plural{1:类|:类}1 不是字面类型'
# '%select{struct|interface|class}0%select{| template}1 %2 was previously declared as a %select{struct|interface|class}3%select{| template}1; this is valid, but may result in linker errors under the Microsoft C++ ABI'
H2D10AD8D0564: '%select{结构|接口|类}0%select{| 模板}1 %2 之前被声明为 %select{结构|接口|类}3%select{| 模板}1；该声明有效，但可能在 Microsoft C++ ABI 下引发链接器错误'
# '%select{struct|interface|union|class|enum}0 %1 does not declare any constructor to initialize its non-modifiable members'
HAB227F7E6966: '%select{结构|接口|联合|类|枚举}0 %1 未声明任何构造函数来初始化其不可修改成员'
# '%select{struct|union|enum}0 defined within a struct or union is not visible in C++'
H20DE76C1377D: '%select{结构体|联合体|枚举}0 内定义的结构体或联合体在 C++ 中不可见'
# '%select{struct|union}0 kernel parameters may not contain pointers'
H1723C50B8752: '%select{结构|联合}0 内核参数不能包含指针'
# '%select{struct|union}0 without named members is a GNU extension'
HBECD0A183C46: '%select{结构|联合}0 无命名成员是 GNU 扩展'
# '%select{subtraction|addition}0 of address-of-label expressions is not supported with ptrauth indirect gotos'
H131327EB0D0D: '%select{标签地址差|标签地址和}0 不支持带有 ptrauth 间接 goto'
# '%select{template type|non-type template|template template}0 parameter%select{| pack}1 conflicts with previous %select{template type|non-type template|template template}0 parameter%select{ pack|}1'
HACD51B91D6D5: '%select{模板类型|非类型模板|模板模板}0 参数 %select{| 包}1 与之前的 %select{模板类型|非类型模板|模板模板}0 参数%select{ 包|}1 冲突'
# '%select{template type|non-type template|template template}0 parameter%select{| pack}1 does not match %select{template type|non-type template|template template}0 parameter%select{ pack|}1 in template argument'
H42D8D01F5E06: '%select{模板类型|非类型模板|模板模板}0 参数 %select{| 包}1 与模板实参中的 %select{模板类型|非类型模板|模板模板}0 参数%select{ 包|}1 不匹配'
# '%select{template|partial|member}0 specialization cannot be declared __module_private__'
H0A90D5264D30: '%select{模板|部分|成员}0 专项化不能被声明为 __module_private__'
# '%select{temporary %select{whose address is used as value of|%select{|implicitly }2bound to}4 %select{%select{|reference }4member of local variable|local %select{variable|reference}4}1|array backing %select{initializer list subobject of local variable|local initializer list}1}0 %select{%3 |}2will be destroyed at the end of the full-expression'
H1685FEE7827D: '临时%select{其地址被用作 %select{|隐式}2绑定到 %select{%select{|引用}4本地变量的成员|本地%select{变量|引用}4}1|数组后端%select{本地变量的初始化列表子对象|本地初始化列表}1}0 %select{%3 |}2%select{将被销毁在完整表达式结束时|}3'
# "%select{the message|the expression}0 in %select{a static assertion|this asm operand}0 must be a string literal or an object with 'data()' and 'size()' member functions"
H320EEB9B1530: '%select{消息|表达式}0 在 %select{静态断言|这个asm操作数}0 必须由常量表达式生成'
# '%select{the message|the expression}0 in %select{a static assertion|this asm operand}0 must be produced by a constant expression'
H9571480E2335: '%select{消息|表达式}0 在 %select{静态断言|此asm操作数}0 中必须由常量表达式生成'
# "%select{the message|the expression}0 in %select{a static assertion|this asm operand}0 must have a '%select{size|data}1()' member function returning an object convertible to '%select{std::size_t|const char *}1'"
HE077A8EBD022: "%select{消息|表达式}0 在 %select{静态断言|此asm操作数}0 中必须具有返回可转换为 '%select{std::size_t|const char *}1' 的 %select{size|data}1() 成员函数"
# '%select{the message|the expression}0 in %select{this static assertion|this asm operand}0 is not a constant expression'
H1136016D414E: '%select{消息|表达式}0 在 %select{此静态断言|此asm操作数}0 中不是常量表达式'
# '%select{too few|too many}0 template arguments for %select{class template|function template|variable template|alias template|template template parameter|concept|template}1 %2'
HA3BFC0466346: '%select{模板实参不足|模板实参过多}0 对于 %select{类模板|函数模板|变量模板|别名模板|模板模板参数|概念|模板}1 %2'
# '%select{too few|too many}0 template parameters in template %select{|template parameter }1redeclaration'
H2FC8E4427754: '%select{模板参数不足|模板参数过多}0 在模板 %select{| 模板参数 }1重声明中'
# '%select{too few|too many}0 template parameters in template template argument'
HEDDF73011D6C: '%select{模板参数太少|模板参数太多}0 在模板模板参数中'
# '%select{too many|too few}0 elements in vector %select{initialization|operand}3 (expected %1 elements, have %2)'
HEB48F48C2E39: '%select{太少|太多}0 元素在向量%select{初始化|操作数}3中（期望 %1 个，实际 %2 个）'
# '%select{type tag|argument}0 index %1 is greater than the number of arguments specified'
H7C0418F179E9: '%select{类型标记|参数}0 索引 %1 大于指定参数的数量'
# '%select{typedef|type alias|type alias template}0 redefinition with different types%diff{ ($ vs $)|}1,2'
H7F72DD3ED811: '%select{typedef|type alias|type alias template}0 类型重新定义%diff{ ($ vs $)|}1,2'
# '%select{uninitialized use occurs|variable is captured by block}0 here'
H80571A54148A: '%select{未初始化的使用发生|变量被块捕获}0 此处'
# "%select{unknown|duplicate}0 modifier %1 in OpenACC modifier-list on '%2' clause"
H8603FBD5B2C6: "%select{未知|重复}0 修饰符 %1 在 OpenACC '%2' 子句修饰符列表中"
# '%select{unknown|unsupported}0 machine mode %1'
HB579643BB1CB: '%select{未知|不受支持}0 的机器模式 %1'
# '%select{unsafe pointer operation|unsafe pointer arithmetic|unsafe buffer access|function introduces unsafe buffer manipulation|unsafe invocation of %1|field %1 prone to unsafe buffer manipulation}0'
HD969AD0BDB13: '%select{不安全指针操作|不安全指针运算|不安全缓冲区访问|函数引入不安全缓冲区操作|调用 %1 不安全|字段 %1 易导致不安全缓冲区操作}0'
# "%select{unsupported|duplicate|unknown}0%select{| CPU| tune CPU}1 '%2' in the '%select{target|target_clones|target_version}3' attribute string;"
H8412993B41A2: "%select{不支持|重复|未知}0%select{| CPU| tune CPU}1 '%2' 在 '%select{target|target_clones|target_version}3' 属性字符串中;"
# "%select{unsupported|duplicate|unknown}0%select{| CPU| tune CPU}1 '%2' in the '%select{target|target_clones|target_version}3' attribute string; '%select{target|target_clones|target_version}3' attribute ignored"
H952DC46C8259: "%select{不支持|重复|未知}0%select{| CPU| tune CPU}1 '%2' 在 '%select{target|target_clones|target_version}3' 属性字符串中; 忽略 %select{target|target_clones|target_version}3 属性"
# '%select{using this character in an identifier|starting an identifier with this character}0 is incompatible with C99'
H2BC4F8FF7FD4: '%select{在标识符中使用该字符|以该字符开头的标识符}0 不符合C99规范'
# "%select{values of type|enum values with underlying type}2 '%0' should not be used as format arguments; add an explicit cast to %1 instead"
H74FA7B9CE6BC: "%select{类型|基础类型为的枚举值}2 '%0' 不应作为格式参数使用；请显式转换为 %1 类型"
# '%select{value|type}0-dependent expression passed as an argument to debug command'
HF8F02B43BB62: '%select{值|类型}0 依赖表达式被传递给调试命令'
# '%select{variable|static data member}0 instantiated with function type %1'
HE6193A7D74C4: '%select{变量|静态数据成员}0 实例化为函数类型 %1'
# '%select{variable|variable template|variable template partial specialization|variable template explicit specialization}0 %1 declared with deduced type %2 cannot appear in its own initializer'
H7CD30BEC5DE9: '%select{变量|变量模板|变量模板偏特化|变量模板显式特化}0 %1 声明为推导类型 %2 时不能出现在自身的初始化器中'
# '%select{via initialization of|binding reference}0 variable %select{%2 |}1here'
HB0440A5001E5: '%select{通过初始化|绑定引用}0 变量 %select{%2 |}1 此处'
# "%select{virtual method|function pointer}0 cannot be inferred '%1'"
H57712FD11644: "%select{虚方法|函数指针}0 无法推断 '%1'"
# '%select{void function|void method|constructor|destructor}1 %0 must not return a value'
HE90DDC8579B5: '%select{void函数|void方法|构造函数|析构函数}1 %0 必须不返回值'
# '%select{void function|void method|constructor|destructor}1 %0 should not return a value'
H917D4EA3DC61: '%select{void函数|void方法|构造函数|析构函数}1 %0 不应返回值'
# '%select{wide|Unicode}0 character literals may not contain multiple characters'
HEBA1B65B6166: '%select{宽|Unicode}0 字符文字不能包含多个字符'
# "%select{x86|x86-64}0 'interrupt' attribute only applies to functions that have %select{a 'void' return type|only a pointer parameter optionally followed by an integer parameter|a pointer as the first parameter|a %2 type as the second parameter}1"
H6EAE552C7EA8: "%select{x86|x86-64}0 'interrupt' 属性仅适用于%select{返回类型为void的函数|仅带有可选后续整数参数的指针参数|第一个参数为指针|第二个参数为 %2 类型}1 的函数"
# "%select{|'%1-%2' }0diagnostics %select{with '%2' severity |}0%select{expected|seen}3 but not %select{seen|expected}3: %4"
H6E1DC1644300: "%select{|'%1-%2' }0 诊断信息%select{以 '%2' 严重性 |}0%select{期望|检测到}3 但未%select{检测到|期望}3： %4"
# '%select{|a template declaration|an explicit template specialization|an explicit template instantiation}0 can only %select{|declare|declare|instantiate}0 a single entity'
HCEE3630F178B: '%select{|一个模板声明|一个显式模板特化|一个显式模板实例化}0 只能 %select{|声明|声明|实例化}0 单个实体'
# "%select{|captured }1%0 parameter marked 'called_once' is never called"
H5EDD8753404F: "%select{|被捕获的 }1%0 参数标记为 'called_once' 但从未被调用"
# '%select{|captured }1completion handler is never called'
H31A1FA39F285: '%select{|被捕获的 }1完成处理程序从未被调用'
# "%select{|change to 'snprintf' for explicit bounds checking | buffer pointer and size may not match|string argument is not guaranteed to be null-terminated|'va_list' is unsafe}0"
H071DEF637982: "%select{|改为使用 'snprintf' 进行显式边界检查 | 缓冲区指针和大小可能不匹配|string参数不保证以空字符终止|'va_list' 不安全}0"
# '%select{|direct }0%select{method|property}1 declaration conflicts with previous %select{|direct }2declaration of %select{method|property}1 %3'
H1D02391D3A58: '%select{|直接 }0%select{方法|属性}1 声明与之前的 %select{|直接 }2 声明冲突 %select{方法|属性}1 %3'
# '%select{|empty }0%select{struct|union}1 has size 0 in C, %select{size 1|non-zero size}2 in C++'
HEA8D8C4B49F9: '%select{|空 }0%select{结构体|联合体}1 在C中有大小 0，在C++中%select{大小为 1|非零大小}2'
# "%select{|implicit }0use of 'this' pointer is only allowed within the evaluation of a call to a 'constexpr' member function"
HE1347141F3D2: '%select{|隐式 }0使用 "this" 指针仅允许在constexpr成员函数调用的求值过程中使用'
# '%select{|implicitly }1declared %select{private|protected}0 here'
H8D12655CD9C3: '%select{|隐式 }1声明为 %select{私有|保护}0 这里'
# "%select{|incremented }0enumerator value which exceeds the range of 'int' is a C23 extension (%1 is too %select{small|large}2)"
H7317CEFA834D: '%select{|递增的 }0枚举值超出int类型的范围是C23扩展 (%1 过于%select{小|大}2)'
# "%select{|incremented }0enumerator value which exceeds the range of 'int' is incompatible with C standards before C23 (%1 is too %select{small|large}2)"
H02CD4F5E389B: '%select{|递增的 }0枚举值超出int类型的范围与C23之前的标准不兼容 (%1 过于%select{小|大}2)'
# '%select{|member|base class}0 %1 declared here'
H83331E20A1A3: '%select{|成员|基类}0 %1 声明于此'
# '%select{|member}0 using declaration %1 instantiates to an empty pack'
H03EFD19ED92A: '%select{|成员}0 using声明 %1 实例化为空包'
# '%select{|non-aggregate }0type %1 cannot be initialized with an initializer list'
H94A9DAA06E2F: '%select{|非聚合 }0类型 %1 不能用初始化列表初始化'
# '%select{|overriding }1method cannot be unavailable on %0 when %select{the protocol method it implements|its overridden method}1 is available'
H11BFB9C90008: '%select{|覆盖 }1方法在 %0 不可用时，当%select{实现的协议方法|覆盖的方法}1 是可用时不允许'
# '%select{|overriding }4method %select{introduced after|deprecated before|obsoleted before}0 %select{the protocol method it implements|overridden method}4 on %1 (%2 vs. %3)'
H3102E4185799: '%select{|覆盖 }4方法%select{在...之后引入|在...之前弃用|在...之前淘汰}0 %select{实现的协议方法|覆盖的方法}4 在 %1 (%2 对比 %3)'
# '%select{|pointer to |reference to }0incomplete type %1 is not allowed in exception specification'
HBD4554E2864A: '%select{|指向|对...的引用}0 不完整类型 %1 不允许出现在异常说明中'
# "%select{|previous }0'hint' clause with value '%1'"
HBBFA3E1A9C6B: "%select{|之前的 }0'hint' 子句值为 '%1'"
# "%select{|previous }0directive with no 'hint' clause specified"
H8CE1C8734C39: "%select{|之前的 }0未指定 'hint' 子句的指令"
# '%select{|previous }0using declaration'
H5AE3701DBB92: '%select{|之前的 }0using声明'
# '%select{|previous }0using-enum declaration'
H5BC63E8C8F5E: '%select{|之前的 }0using-enum声明'
# '%select{|reference to }0sizeless type %1 is not allowed in exception specification'
H3E89611A15B6: '%select{|对 }0大小缺失的类型 %1 的引用在异常规格中不允许'
# '%select{|second }0%1 token is here'
H00E98F1D44F7: '%select{|第二个 }0%1 标记在此处'
# '%select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2 uses deleted function%select{|: %4}3'
HD806C936F5D9: '%select{|static_cast|reinterpret_cast|dynamic_cast|C风格转换|函数式转换|}0 从 %1 到 %2 的转换使用了已删除的函数 %select{|: %4}3'
# '%select{|success |failure }0memory order argument to atomic operation is invalid'
HFAC869D2863E: '%select{|成功 |失败 }0原子操作的内存顺序参数无效'
# '%select{|type aware }0%select{|destroying }1%2 cannot take a dependent type as its %ordinal3 parameter; use %4 instead'
H965362A13DF2: '%select{|类型感知 }0%select{|销毁 }1%2 不能将其第%ordinal3参数作为依赖类型使用；应使用 %4 代替'
# '%select{|type aware }0%select{|destroying }1%2 cannot take a dependent type as its %ordinal3 parameter; use %5 (%4) instead'
H8DC61B9CED29: '%select{|类型感知 }0%select{|销毁 }1%2 不能将其第%ordinal3参数作为依赖类型使用；应使用 %5 (%4)代替'
# '%select{|type aware }0%select{|destroying }1%2 must have at least %select{|one|two|three|four|five}3 parameter%s3'
HDBF7BEA2895C: '%select{|类型感知 }0%select{|销毁 }1%2 需至少有 %select{|一个|两个|三个|四个|五个}3 参数'
# '%select{|type aware }0%select{|destroying }1%2 takes type %5 (%4) as %ordinal3 parameter'
HCA17F3BCF987: '%select{|类型感知 }0%select{|销毁 }1%2 的第%ordinal3参数采用类型 %5 (%4)'
# "%select{|umbrella }0header '%1' not found"
H3FDB64D57A92: "%select{|umbrella }0头文件 '%1' 未找到"
# '%select{|unsafe_unretained|strong|weak}1 property %0 may not also be declared %select{|__unsafe_unretained|__strong|__weak|__autoreleasing}2'
HC9D6BEED9F9F: '%select{|unsafe_unretained|strong|weak}1 属性 %0 可能也不能被声明为 %select{|__unsafe_unretained|__strong|__weak|__autoreleasing}2'
# '%select{||reinterpret_cast||C-style cast||}0 from scalar %1 to vector %2 of different size'
HFF11D1B4EA50: '%select{||reinterpret_cast||C风格转换||}0 从标量 %1 到不同大小的向量 %2'
# '%select{||reinterpret_cast||C-style cast||}0 from vector %1 to scalar %2 of different size'
H4BC2B3E593E1: '%select{||reinterpret_cast||C风格转换||}0 从向量 %1 到不同大小的标量 %2'
# '%select{||reinterpret_cast||C-style cast||}0 from vector %1 to vector %2 of different size'
H855233AE0D42: '%select{||reinterpret_cast||C风格转换||}0 从向量 %1 到不同大小的向量 %2'
# "%select{|||||virtual function called on|dynamic_cast applied to|typeid applied to|construction of|destruction of}0 object '%1' whose dynamic type is not constant"
H292A692F3948: "%select{|||||虚函数调用|dynamic_cast 应用于|typeid 应用于|构造|析构}0 对象 '%1' 其动态类型不是常量"
# "'##' cannot appear at end of __VA_OPT__ argument"
H2B78B6D67ACA: "'##' 不能出现在__VA_OPT__参数末尾"
# "'##' cannot appear at end of macro expansion"
H0D880CABAC3F: "'##' 不能出现在宏展开末尾"
# "'##' cannot appear at start of __VA_OPT__ argument"
H2F2411264E60: "'##' 不能出现在__VA_OPT__参数开头"
# "'##' cannot appear at start of macro expansion"
H49669D0F3359: "'##' 不能出现在宏展开开头"
# "'#include <filename>' attaches the declarations to the named module '%0', which is not usually intended; consider moving that directive before the module declaration"
HE8759FB5FF70: "'#include <filename>' 将声明附加到名为 %0 的模块，这通常不是预期行为；建议将该指令移动到模块声明之前"
# "'#pragma %0' can only appear at file scope"
HCE0F9341D433: "'#pragma %0' 只能出现在文件作用域"
# "'#pragma %0' can only appear at file scope or at the start of a compound statement"
HD3947EF6D864: "'#pragma %0' 只能出现在文件作用域或复合语句开头"
# "'#pragma %0' is not supported on this target - ignored"
H10F342B08150: "'#pragma %0' 在此目标上不支持 - 已忽略"
# "'#pragma STDC FENV_ACCESS ON' is illegal when precise is disabled"
H17CE846EF8B0: "'#pragma STDC FENV_ACCESS ON' 在precise被禁用时非法"
# "'#pragma alloc_text' is applicable only to functions"
H29BA150C71BF: "'#pragma alloc_text' 仅适用于函数"
# "'#pragma alloc_text' is applicable only to functions with C linkage"
H8053A181B977: "'#pragma alloc_text' 仅适用于具有C链接的函数"
# "'#pragma clang arc_cf_code_audited' was not ended within this file"
H3175433AA2FB: "'#pragma clang arc_cf_code_audited' 未在此文件中结束"
# "'#pragma clang assume_nonnull' was not ended within this file"
H344021929D5B: "'#pragma clang assume_nonnull' 未在此文件中结束"
# "'#pragma clang attribute %select{%1.|}0pop' with no matching '#pragma clang attribute %select{%1.|}0push'"
H170B16ACF46E: "'#pragma clang attribute %select{%1.|}0pop' 没有匹配的 '#pragma clang attribute %select{%1.|}0push'"
# "'#pragma clang attribute push' regions ends here"
HF6A5F5655AB0: "'#pragma clang attribute push' 区域在此结束"
# "'#pragma clang attribute' attribute with no matching '#pragma clang attribute push'"
HAAE6327E2566: "'#pragma clang attribute' 属性没有匹配的 '#pragma clang attribute push'"
# "'#pragma comment %0' ignored"
HEB14674C1594: "忽略 '#pragma comment %0'"
# "'#pragma float_control push/pop' can only appear at file or namespace scope or within a language linkage specification"
H053264F8F924: "'#pragma float_control push/pop' 仅可在文件或命名空间作用域内，或在语言链接规范内出现"
# "'#pragma float_control(except, on)' is illegal when precise is disabled"
H28022D025F51: "当 precise 禁用时，'#pragma float_control(except, on)' 是非法的"
# "'#pragma float_control(precise, off)' is illegal when except is enabled"
H922887ACFECE: "当 except 启用时，'#pragma float_control(precise, off)' 是非法的"
# "'#pragma float_control(precise, off)' is illegal when fenv_access is enabled"
HAFA440F76585: "当 fenv_access 启用时，'#pragma float_control(precise, off)' 是非法的"
# "'#pragma init_seg' is only supported when targeting a Microsoft environment"
H4E91F2EF3757: "'#pragma init_seg' 仅在针对Microsoft环境时受支持"
# "'#pragma omp %0' %select{|with '%2' clause }1cannot be an immediate substatement"
HA805BCE4C312: "'#pragma omp %0' %select{|包含 '%2' 子句 }1不能是直接子语句"
# "'#pragma omp %0' directive must appear only in file scope"
H3C04CBDE708E: "'#pragma omp %0' 指令必须仅出现在文件作用域中"
# "'#pragma omp %0' must appear in the scope of the %q1 variable declaration"
HCD521713958F: "'#pragma omp %0' 必须出现在 %q1 变量声明的作用域内"
# "'#pragma omp %0' must precede all references to variable %q1"
HA982E769431D: "'#pragma omp %0' 必须在变量 %q1 的所有引用前出现"
# "'#pragma omp declare %select{simd|variant}0' can only be applied to functions"
HC2DB961C6B39: "'#pragma omp declare %select{simd|variant}0' 仅可应用于函数"
# "'#pragma omp declare variant' cannot be applied for function after first usage; the original function might be used"
H504957D176C7: "'#pragma omp declare variant' 不能在函数首次使用后应用；原始函数可能已被使用"
# "'#pragma omp declare variant' cannot be applied to the function that was defined already; the original function might be used"
HB5A7CD5EEB6F: "'#pragma omp declare variant' 不能应用于已定义的函数；原始函数可能已被使用"
# "'#pragma omp declare variant' does not support %select{function templates|virtual functions|deduced return types|constructors|destructors|deleted functions|defaulted functions|constexpr functions|consteval function}0"
H240B964685D1: "'#pragma omp declare variant' 不支持 %select{函数模板|虚函数|推导返回类型|构造函数|析构函数|被删除函数|默认函数|constexpr函数|consteval函数}0"
# "'#pragma omp declare variant' is not compatible with any target-specific attributes"
HDFFC2CD6FA69: "'#pragma omp declare variant' 与任何目标特定属性不兼容"
# "'#pragma omp end assumes' with no matching '#pragma omp begin assumes'"
HAF63C041427E: "未找到对应的 '#pragma omp begin assumes'，但出现了 '#pragma omp end assumes'"
# "'#pragma omp end declare variant' with no matching '#pragma omp begin declare variant'"
HD60959180819: "未找到对应的 '#pragma omp begin declare variant'，但出现了 '#pragma omp end declare variant'"
# "'#pragma unsafe_buffer_usage' was not ended"
H8FB2F039CC57: "'#pragma unsafe_buffer_usage' 未结束"
# "'$' in identifier"
HB5654708DC14: "标识符中包含 '$'"
# "'%%n' specifier not supported on this platform"
HC8B8AD4E064B: "此平台不支持 '%%n' 格式说明符"
# "'%0' %select{length modifier|conversion specifier}1 is not supported by ISO C"
H5FE655A569EF: "ISO C 不支持 '%0' %select{长度修饰符|转换说明符}1"
# "'%0' ABI is not supported with FPU"
H0E4CA678D6B9: "'%0' ABI 与 FPU 不兼容"
# "'%0' action ignored; '%1' action specified previously"
H140C3ABC4AE4: "忽略 '%0' 操作，已指定之前的 '%1' 操作"
# "'%0' and '%1' clause are mutually exclusive and may not appear on the same directive"
H124967FEEE58: "'%0' 和 '%1' 子句是互斥的，不能出现在同一指令中"
# "'%0' argument on '%1' clause is not permitted on a%select{|n orphaned}2 '%3' construct%select{| associated with a '%5' compute construct}4"
H43AC213E21A0: "不允许在 %select{|孤立的}2 '%3' 构造体 %select{|与 '%5' 计算构造体关联}4中对 '%1' 子句使用 '%0' 参数"
# "'%0' argument to '%1' clause not allowed on a '%2' construct%select{| associated with a '%4' construct}3 that has a '%5' clause"
H08457CF75CEB: "不允许在 %select{|与 '%4' 构造体关联}3的 '%2' 构造体中对带有 '%5' 子句的 '%0' 参数使用 '%1' 子句"
# "'%0' as a module map name is deprecated, rename it to %select{module.modulemap|module.private.modulemap}1%select{| in the 'Modules' directory of the framework}2"
H871445ACDF0B: "'%0' 作为模块映射名称已弃用，应重命名为 %select{module.modulemap|module.private.modulemap}1%select{|并在框架的 'Modules' 目录中}2"
# "'%0' attribute cannot be specified on a definition"
H3887172CED45: "无法在定义上指定 '%0' 属性"
# "'%0' call operates on objects of type %1 while the size is based on a different type %2"
H9E506A66F2D3: "'%0' 调用作用于类型 %1 的对象，而大小基于不同类型 %2"
# "'%0' can only be used if the target supports the mfhc1 and mthc1 instructions"
HD98657B082CC: "仅当目标支持 mfhc1 和 mthc1 指令时才能使用 '%0'"
# "'%0' can only be used with the '%1' ABI"
HAC173E806F23: "仅能与 '%1' ABI 一起使用 '%0'"
# "'%0' cannot be a part of nested name specifier; did you mean ':'?"
H6E2E8EF01102: "'%0' 不能作为嵌套名称限定符的一部分；是否应使用 ':'？"
# "'%0' cannot be called with %select{a null pointer|a one-past-the-end pointer|a pointer to an object whose lifetime has not yet begun}1"
H9E6A8072EAD3: "无法用 %select{空指针|超出末尾的指针|生命周期尚未开始的对象的指针}1 调用 '%0'"
# "'%0' cannot be signed or unsigned"
HE82DC08D960E: "'%0' 不能指定为有符号或无符号类型"
# "'%0' cannot be used in an unevaluated context"
HACCAB0092430: "'%0' 不能在未求值的上下文中使用"
# "'%0' cannot be used in the handler of a try block"
HCC6C7DE7C0DC: "'%0' 不能在 try 块的处理器中使用"
# "'%0' cannot be used outside a function"
HF038C50615EF: "'%0' 不能在函数外部使用"
# "'%0' casts have no effect when not using ARC"
H0985DFE3C8AA: "'%0' 类型转换在不使用 ARC 时没有效果"
# "'%0' clause is specified here"
H573F42F97FF4: "'%0' 子句在此处指定"
# "'%0' clause not allowed on a 'kernels loop' construct that has a '%1' clause with a%select{n| 'num'}2 argument"
HA63B4E6AC69A: "'%0' 子句不允许用于带有参数为 %select{n| 'num'}2 的 '%1' 子句的 'kernels loop' 结构"
# "'%0' clause requires 'dispatch' context selector"
H94FAB67C930A: "'%0' 子句需要 'dispatch' 上下文选择器"
# "'%0' clause specifies a loop count greater than the number of available loops"
H13BED1AA5B60: "'%0' 子句指定了比可用循环数量更多的循环计数"
# "'%0' clause used here"
HC259BC00C8FD: "'%0' 子句在此处使用"
# "'%0' clause with '%1' modifier cannot be specified if an 'ordered' clause is specified"
HFFE6A9A75740: "如果指定了 'ordered' 子句，则带有 '%1' 修饰符的 '%0' 子句不能指定"
# "'%0' clauses cannot be mixed with '%1' clause"
H0A2484D8EEB5: "'%0' 子句不能与 '%1' 子句混合使用"
# "'%0' construct is here"
H4E6A1EF91E1B: "'%0' 结构在此处"
# "'%0' declared as a member pointer to a reference of type %1"
HF4FF87D5007C: "'%0' 被声明为指向类型 %1 的引用的成员指针"
# "'%0' declared as a member pointer to void"
HB8704C365E55: "'%0' 被声明为指向 void 的成员指针"
# "'%0' declared as a pointer to a reference of type %1"
H95E780665FDE: "'%0' 被声明为指向类型 %1 的引用的指针"
# "'%0' declared as an array with a negative size"
H44D9A6FDB5F3: "'%0' 被声明为具有负大小的数组"
# "'%0' declared as array of functions of type %1"
HF167BCD9180C: "'%0' 被声明为类型 %1 的函数的数组"
# "'%0' declared as array of references of type %1"
H07B7977DE9AC: "'%0' 被声明为类型 %1 的引用的数组"
# "'%0' directive cannot follow %select{'%2' directive|other expected directives}1"
H81459AA5C045: "'%0' 指令不能跟随 %select{'%2' 指令|其他期望指令}1"
# "'%0' directive found here"
H689CAA47B15F: "'%0' 指令在此处找到"
# "'%0' does not contain a GCC installation"
H5EA2B901E3DD: "'%0' 不包含 GCC 安装"
# "'%0' does not support '-%1'; flag ignored"
H5F193B6442A3: "'%0' 不支持 '-%1'; 标志被忽略"
# "'%0' does not support '-moutline'; flag ignored"
H8FCF49E8EFFE: "'%0' 不支持 '-moutline'; 标志被忽略"
# "'%0' file not found"
HE40852833202: "'%0' 文件未找到"
# '\'%0\' file not found with <angled> %select{include|import}1; use "quotes" instead'
HB65E7D8C29D0: '\'%0\' 文件未找到，使用 <angled> %select{include|import}1 包含；请改用 "quotes"'
# "'%0' file not found, did you mean '%1'?"
HA3BAEA90173D: "'%0' 文件未找到，您是不是指 '%1'？"
# "'%0' function must have a prototype"
H161348B5A00F: "'%0' 函数必须有原型声明"
# "'%0' ignored on this declaration"
H3A73EC6937F0: "'%0' 在此声明中被忽略"
# "'%0' included multiple times, additional include site here"
H67346CC37DF8: "'%0' 被多次包含，此处为额外包含位置"
# "'%0' included multiple times, additional include site in header from module '%1'"
HC2226976DFB3: "'%0' 被多次包含，额外包含位置在模块 '%1' 的头文件中"
# "'%0' invalid for input of type %1"
H0F254F5D0DEC: "'%0' 对类型 %1 的输入无效"
# "'%0' is a C11 extension"
HACD9CD0EB9B2: "'%0' 是 C11 的扩展"
# "'%0' is a C2y extension"
H46F684F39EE1: "'%0' 是一个C2y扩展"
# "'%0' is a C99 extension"
H553903351EEE: "'%0' 是 C99 的扩展"
# "'%0' is a context %select{set|selector|property}1 not a context %select{set|selector|property}2"
H0E6818DF21E4: "'%0' 是上下文 %select{set|selector|property}1 而非上下文 %select{set|selector|property}2"
# "'%0' is a keyword in C++11"
H6E1B6EF2D90A: "'%0' 是 C++11 的关键字"
# "'%0' is a keyword in C++20"
HED77874B7FB4: "'%0' 是 C++20 的关键字"
# "'%0' is a keyword in C23"
H55337290EE76: "'%0' 是 C23 的关键字"
# "'%0' is a keyword in C99"
H305C2462E219: "'%0' 是 C99 的关键字"
# "'%0' is bound to current loop, GCC binds it to the enclosing loop"
H6C2FAF9A98CF: "'%0' 绑定到当前循环，而GCC将其绑定到外部循环"
# "'%0' is ignored since it is only supported for HIP"
HAF6605CCA46F: "'%0' 被忽略，因为它仅在HIP中支持"
# "'%0' is incompatible with C standards before C11"
H0DA1AA64E023: "'%0' 与C11之前的C标准不兼容"
# "'%0' is incompatible with C standards before C23"
HDD86BE78B3D0: "'%0' 与C23之前的C标准不兼容"
# "'%0' is incompatible with C standards before C2y"
H1CC83438FCCD: "'%0' 与C2y之前的C标准不兼容"
# "'%0' is invalid in friend declarations"
H3D161449A142: "'%0' 在friend声明中无效"
# "'%0' is not a valid Unicode character name"
H469DC75B6244: "'%0' 不是有效的Unicode字符名称"
# "'%0' is not a valid builtin name for %1"
H4BF3E4DBB43C: "'%0' 不是 %1 的有效内建名称"
# "'%0' is not a valid context property for the context selector '%1' and the context set '%2'; property ignored"
HEB6F750CA90C: "'%0' 不是上下文选择器 '%1' 和上下文集合 '%2' 的有效属性；属性被忽略"
# "'%0' is not a valid context selector for the context set '%1'; selector ignored"
H6CA470A4E352: "'%0' 不是上下文集合 '%1' 的有效选择器；选择器被忽略"
# "'%0' is not a valid context set in a `declare variant`; set ignored"
HA1E62D28111D: "'%0' 在`declare variant`中不是有效的上下文集合；集合被忽略"
# "'%0' is not a valid object format flag"
H0558CE31CE90: "'%0' 不是有效的目标格式标志"
# "'%0' is not permitted on a declaration of a type"
H43ABF8D7D74B: "'%0' 不允许用于类型声明"
# "'%0' is not supported in C++ for OpenCL"
HDCEA34FAF8C7: "'%0' 在C++的OpenCL中不受支持"
# "'%0' is only allowed on variable declarations"
H6BFADFD542E9: "'%0' 仅允许用于变量声明"
# "'%0' is only available in %1"
H468F8034CF09: "'%0' 仅在 %1 中可用"
# "'%0' is used without '-mstack-protector-guard-offset', and there is no default"
H8812B24333D0: "'%0' 未与 '-mstack-protector-guard-offset' 选项一起使用，且没有默认值"
# "'%0' keyword is a C++11 extension"
H23175F3671E1: "'%0' 关键字是C++11的扩展"
# "'%0' keyword is incompatible with C++98"
HCFDB7E16EAB8: "'%0' 关键字与C++98不兼容"
# "'%0' keyword not permitted with interface types"
HFAA4A308281C: "'%0' 关键字不允许与接口类型一起使用"
# "'%0' may overflow; destination buffer in argument %1 has size %2, but the corresponding specifier may require size %3"
H45D6462C38BC: "'%0' 可能发生溢出；参数 %1 中的目标缓冲区大小为 %2，但对应的说明符可能需要大小 %3"
# "'%0' not supported, please use -iquote instead"
HD03640F49183: "'%0' 不受支持，请改用 -iquote"
# "'%0' only applies to %select{function|pointer|Objective-C object or block pointer}1 types; type here is %2"
H76B771A1DA3E: "'%0' 仅适用于%select{函数|指针|Objective-C对象或块指针}1类型；此处的类型是 %2"
# "'%0' only applies to medium and large code models"
H2B43B16BADDB: "'%0' 仅适用于中等和大型代码模型"
# "'%0' option requires target HLSL Version >= 2018%select{| and shader model >= 6.2}1, but HLSL Version is '%2'%select{| and shader model is '%3'}1"
H73FD169C1664: "'%0' 选项要求目标HLSL版本 >= 2018%select{|且着色器模型 >= 6.2}1，但HLSL版本是 '%2'%select{|且着色器模型是 '%3'}1"
# "'%0' parameter can only be used with swiftcall%select{ or swiftasynccall|}1 calling convention%select{|s}1"
H7F6C0A7A9011: "'%0' 参数只能与swiftcall%select{或swiftasynccall|}1 调用约定 %select{|s}1 一起使用"
# "'%0' parameter must have pointer%select{| to unqualified pointer}1 type; type here is %2"
HA49C073BB7A8: "'%0' 参数必须具有指针 %select{|到无限定符指针}1类型；此处的类型是 %2"
# "'%0' previously encountered here"
HC082D10D967F: "'%0' 之前在这里遇到过"
# "'%0' qualifier is not allowed on a constructor"
HD3C37F48AA10: "'%0' 限定符不能用于构造函数"
# "'%0' qualifier is not allowed on a destructor"
H63A821EC7A98: "'%0' 限定符不能用于析构函数"
# "'%0' qualifier may not appear after the virtual specifier '%1'"
HC82C66448381: "'%0' 限定符不能出现在virtual说明符 '%1' 之后"
# "'%0' qualifier may not be applied to a reference"
H39DF4A724F57: "'%0' 限定符不能应用于引用"
# "'%0' qualifier on function type %1 has no effect"
HCA4F5C288E32: "'%0' 限定符对函数类型 %1 没有影响"
# "'%0' qualifier on function type %1 has no effect and is a Clang extension"
HA82B1E90695B: "'%0' 限定符对函数类型 %1 没有影响，并且是Clang的扩展"
# "'%0' qualifier on omitted return type %1 has no effect"
H226C520C0A5C: "'%0' 限定符对省略的返回类型 %1 没有影响"
# "'%0' qualifier on reference type %1 has no effect"
H9D5F7EA85F79: "'%0' 限定符对引用类型 %1 没有影响"
# "'%0' qualifier%s1 on base class type %2 %plural{1:has|:have}1 no effect"
HB4BF74C2E9A3: "'%0' 限定符%s1在基类类型 %2 %plural{1:没有|:没有}1影响"
# "'%0' region encountered before requires directive with '%1' clause"
HAC48A5EE380D: "'%0' 区域在包含 '%1' 子句的requires指令之前被遇到"
# "'%0' required by '%1'"
H149191A7D780: "'%0' 由 '%1' 要求"
# "'%0' required for precompiled header not found"
HBDA853057C16: "用于预编译头的 '%0' 未找到"
# "'%0' size argument is too large; destination buffer has size %1, but size argument is %2"
H1B04445BBECB: "'%0' 的大小参数过大；目标缓冲区的大小为 %1，但大小参数是 %2"
# "'%0' specifier is not allowed outside a class definition"
H496E8612120E: "'%0' 规定符不允许在类定义外部使用"
# "'%0' statement cannot be used in OpenMP for loop"
HB1E296AE95BC: "'%0' 语句不能在OpenMP for循环中使用"
# "'%0' statement cannot be used in OpenMP simd region"
H1C587C7353B1: "'%0' 语句不能在OpenMP simd区域中使用"
# "'%0' type not found; include <omp.h>"
H4CF50F4E769F: "未找到 '%0' 类型；请包含 <omp.h>"
# "'%0' type qualifier%s1 on return type %plural{1:has|:have}1 no effect"
H065A9C128711: "'%0' 类型限定符%s1 在返回类型 %plural{1:没有|:没有}1 效果"
# "'%0' type specifier is incompatible with C++98"
HB674C3599FA0: "'%0' 类型说明符与C++98不兼容"
# "'%0' variables must have global storage"
H08EBA7A5907F: "'%0' 变量必须具有全局存储"
# "'%0' will always be truncated; specified size is %1, but format string expands to at least %2"
H0AA6DDAAABA2: "'%0' 将始终被截断；指定的大小为 %1，但格式字符串展开到至少 %2"
# "'%0' will always evaluate to 'true' in a manifestly constant-evaluated expression"
H75D7A83FFEC6: "'%0' 在显式常量求值表达式中始终会求值为 'true'"
# "'%0' will always overflow; destination buffer has size %1, but format string expands to at least %2"
H6C8DA523F6B3: "'%0' 将始终溢出；目标缓冲区大小为 %1，但格式字符串展开到至少 %2"
# "'%0' will always overflow; destination buffer has size %1, but size argument is %2"
H6A8E065AE173: "'%0' 将始终溢出；目标缓冲区的大小为 %1，但尺寸参数是 %2"
# "'%0' will always overflow; destination buffer has size %1, but the source string has length %2 (including NUL byte)"
H4E1F13141ECB: "'%0' 将始终溢出；目标缓冲区的大小为 %1，但源字符串长度为 %2（包含NUL字节）"
# "'%0' within '%1'"
HFD060F45F3E4: "'%0' 在 '%1' 内"
# "'%0': selected processor lacks floating point registers"
H5E83058CA4FE: "'%0'：所选处理器缺少浮点寄存器"
# "'%0': unable to pass LLVM bit-code files to linker"
H5B7DB64DAEE9: "'%0'：无法将LLVM比特码文件传递给链接器"
# "'%0': unable to use AST files with this tool"
HEA339F2E046F: "'%0'：无法与此工具一起使用AST文件"
# "'%0': unable to use module files with this tool"
H25C074B573CF: "'%0'：无法与此工具一起使用模块文件"
# "'%0(%select{source|sink:vec}1)' clause%select{|s}1 cannot be mixed with '%0(%select{sink:vec|source}1)' clause%select{s|}1"
H081C849E3FF9: "'%0(%select{source|sink:vec}1)' 子句 %select{|s}1 不能与 '%0(%select{sink:vec|source}1)' 子句 %select{s|}1 混用"
# "'%1' attribute on property %0 does not match the property inherited from %2"
H0392738DA622: "'%1' 属性与属性 %0 从 %2 继承的属性不匹配"
# "'%1' cannot be used in %select{a constructor|a destructor|the 'main' function|a constexpr function|a function with a deduced return type|a varargs function|a consteval function}0"
HB2DCA2D92D0E: "'%1' 不能用于 %select{构造函数|析构函数|main函数|constexpr函数|具有推导返回类型的函数|可变参数函数|consteval函数}0"
# "'%select{#|#@}0' is not followed by a macro parameter"
HFFC615C42B6A: "'%select{#|#@}0' 后未跟随宏参数"
# "'%select{%select{memcpy|wmemcpy}1|%select{memmove|wmemmove}1}0' not supported: %select{size to copy (%4) is not a multiple of size of element type %3 (%5)|source is not a contiguous array of at least %4 elements of type %3|destination is not a contiguous array of at least %4 elements of type %3}2"
HEE3F2A4E1A36: "'%select{%select{memcpy|wmemcpy}1|%select{memmove|wmemmove}1}0' 不受支持：%select{要复制的大小（%4）不是元素类型 %3（%5）的倍数|源不是至少 %4 个 %3 元素的连续数组|目标不是至少 %4 个 %3 元素的连续数组}2"
# "'%select{*|.*}0' specified field %select{width|precision}0 is missing a matching 'int' argument"
H0D1F0E4F63B2: "'%select{*|.*}0' 指定的字段 %select{宽度|精度}0 缺少匹配的 'int' 参数"
# "'%select{--|++}0' on an object of complex type is a C2y extension"
HDA93C21904C8: "'%select{--|++}0' 对复数类型对象是C2y扩展"
# "'%select{--|++}0' on an object of complex type is incompatible with C standards before C2y"
H20E81B85B020: "'%select{--|++}0' 对复数类型对象与C2y之前的C标准不兼容"
# "'%select{\\|@}0%1' command does not terminate a verbatim text block"
H42F81A2BAA36: "'%select{\\|@}0%1' 命令未终止原始文本块"
# "'%select{\\|@}0%1' command has %plural{0:no|:%2}2 word argument%s2, expected %3"
HBEDC67E6720C: "'%select{\\|@}0%1' 命令有 %plural{0:没有|:%2}2 参数，期望 %3 个"
# "'%select{\\|@}0%1' command used in a comment that is attached to a %select{function returning void|constructor|destructor|method returning void}2"
HFBFA65D15A47: "'%select{\\|@}0%1' 命令用于附加到%select{返回void的函数|构造函数|析构函数|返回void的方法}2的注释中"
# "'%select{\\|@}0%1' command used in a comment that is not attached to a function or method declaration"
H9A9CB5F0CECC: "'%select{\\|@}0%1' 命令用于未附加到函数或方法声明的注释中"
# "'%select{\\|@}0%select{classdesign|coclass|dependency|helper|helperclass|helps|instancesize|ownership|performance|security|superclass}1' command should not be used in a comment attached to a non-container declaration"
H63CA64568B3F: "'%select{\\|@}0%select{classdesign|coclass|dependency|helper|helperclass|helps|instancesize|ownership|performance|security|superclass}1' 命令不应用于附加到非容器声明的注释中"
# "'%select{\\|@}0%select{class|interface|protocol|struct|union}1' command should not be used in a comment attached to a non-%select{class|interface|protocol|struct|union}2 declaration"
H2B2D23C85C31: "'%select{\\|@}0%select{class|interface|protocol|struct|union}1' 命令不应用于附加到非 %select{class|interface|protocol|struct|union}2 声明的注释中"
# "'%select{\\|@}0%select{function|functiongroup|method|methodgroup|callback}1' command should be used in a comment attached to %select{a function|a function|an Objective-C method|an Objective-C method|a pointer to function}2 declaration"
H30965075CCD3: "'%select{\\|@}0%select{function|functiongroup|method|methodgroup|callback}1' 命令应用于附加到%select{函数|函数|Objective-C方法|Objective-C方法|函数指针}2声明的注释中"
# "'%select{\\|@}0param' command used in a comment that is not attached to a function declaration"
HA6D99227D713: "'%select{\\|@}0param' 命令用于未附加到函数声明的注释中"
# "'%select{\\|@}0tparam' command used in a comment that is not attached to a template declaration"
H78D96F6B0A65: "'%select{\\|@}0tparam' 命令用于未附加到模板声明的注释中"
# "'%select{auto|decltype(auto)}0' in return type deduced as %1 here but deduced as %2 in earlier return statement"
HDFEF08FDDF8E: "'%select{auto|decltype(auto)}0' 返回类型在此处推导为 %1，但在之前的return语句中推导为 %2"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' argument cannot refer to a union member"
HF50BCD9CECE6: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' 参数不能引用联合成员"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' argument must be a simple declaration reference"
HF6AC15305460: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' 参数必须是简单的声明引用"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' cannot be applied to a union member"
H01022C27C2BB: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' 不能应用于联合成员"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' only applies to pointers%select{ or C99 flexible array members|||}0%select{|; did you mean to use 'counted_by'?}1"
H077E0A5BF4C4: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' 仅适用于指针%select{或C99柔性数组成员|||}0%select{|；是否应使用 'counted_by'?}1"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' requires a non-boolean integer type argument"
H69D52A4DAF87: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' 需要一个非布尔整数类型的参数"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}1' field %0 isn't within the same struct as the annotated %select{pointer|flexible array}2"
HBD3F5637D173: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}1' 字段 %0 不在与标注的 %select{pointer|flexible array}2 同一个结构体中"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}4' %select{cannot|should not}3 be applied to %select{a pointer with pointee|an array with element}0 of unknown size because %1 is %select{an incomplete type|a sizeless type|a function type|a struct type with a flexible array member%select{|. This will be an error in a future compiler version}3}2"
HEFA740A9E276: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}4' %select{不能|不应}3 应用于 %select{指向未知大小的指针|元素为未知大小的数组}0，因为 %1 是 %select{不完整类型|无尺寸类型|函数类型|带有柔性数组成员的结构体类型 %select{|。这将在未来的编译器版本中变为错误}3}2"
# "'%select{if|switch}0' initialization statements are a C++17 extension"
HBFF569602D2E: "'%select{if|switch}0' 初始化语句是 C++17 扩展"
# "'%select{make_unsigned|make_signed}0' is only compatible with non-%select{bool|_BitInt(1)}1 integers and enum types, but was given %2%select{| whose underlying type is %4}3"
H89BC3FB5059E: "'%select{make_unsigned|make_signed}0' 仅兼容非 %select{bool|_BitInt(1)}1 整数和枚举类型，但传入了 %2%select{| 其基础类型为 %4}3"
# "'%select{memcpy|wmemcpy}0' between overlapping memory regions"
HF4936F4E6501: "'%select{memcpy|wmemcpy}0' 在重叠内存区域之间操作"
# "'%select{pure|const}0' attribute on function returning 'void'; attribute ignored"
H219A6665B476: "'%select{pure|const}0' 属性应用于返回 'void' 的函数；属性被忽略"
# "'%select{trivially_relocatable_if_eligible|replaceable_if_eligible}0' keyword is a C++2c extension"
H6BB09EC63ECD: "'%select{trivially_relocatable_if_eligible|replaceable_if_eligible}0' 关键字是 C++2c 扩展特性"
# "'%select{trivially_relocatable|replaceable}0_if_eligible' keyword is incompatible with standards before C++2c"
HE67149BBE77B: "'%select{trivially_relocatable|replaceable}0_if_eligible' 关键字与 C++2c 之前的版本不兼容"
# "'%select{|short|long|long long}0 %1' is invalid"
H4742130B5F6C: "'%select{|short|long|long long}0 %1' 是无效的类型"
# "'&&' of a value and its negation always evaluates to false"
H35E9DA987909: "'&&' 与自身的否定值运算始终计算为 false"
# "'&&' within '||'"
H8790A025A3C5: "'&&' 在 '||' 运算符内使用"
# "'&' cannot precede a capture when the capture default is '&'"
HA416D7E37193: "当捕获默认为 '&' 时，'&' 不能出现在捕获前"
# "'&' must precede a capture when the capture default is '='"
HC2B64117C04B: "当捕获默认为 '=' 时，捕获前必须使用 '&'"
# "'*' query has already been specified"
H24FF63F5C6A0: "'*' 查询已被指定过"
# "'--hip-path' must be specified when offloading to SPIR-V unless '-nogpuinc' is given"
HF39C24E57C93: "当向 SPIR-V 进行设备端编译时（除非指定了 '-nogpuinc'），必须通过 '--hip-path' 指定路径"
# "'->' applied to return value of the operator->() declared here"
H2D7F207160DF: "此处应用了返回值的 '->' 运算符，该运算符在此处声明"
# "'-fopenmp-targets' must be used in conjunction with a '-fopenmp' option compatible with offloading; e.g., '-fopenmp=libomp' or '-fopenmp=libiomp5'"
HECE3FA60C323: "'-fopenmp-targets' 必须与兼容设备端编译的 '-fopenmp' 选项联用；例如 '-fopenmp=libomp' 或 '-fopenmp=libiomp5'"
# "'-fsanitize=memtag-stack' requires hardware support (+memtag). For Armv8 or Armv9, try compiling with -march=armv8a+memtag or -march=armv9a+memtag"
H3869C74238EE: "'-fsanitize=memtag-stack' 需要硬件支持（+memtag）。对于 Armv8 或 Armv9，尝试使用 -march=armv8a+memtag 或 -march=armv9a+memtag 编译"
# "'-ftrivial-auto-var-init-max-size=*' is used without '-ftrivial-auto-var-init=zero' or '-ftrivial-auto-var-init=pattern'"
H85D7452F85FC: "在未指定 '-ftrivial-auto-var-init=zero' 或 '-ftrivial-auto-var-init=pattern' 时，无法使用 '-ftrivial-auto-var-init-max-size=*'"
# "'-ftrivial-auto-var-init-max-size=*' only accepts positive integers (in bytes)"
H15368DD22E8B: "'-ftrivial-auto-var-init-max-size=*' 只接受正整数（以字节为单位）"
# "'-ftrivial-auto-var-init-stop-after=*' is used without '-ftrivial-auto-var-init=zero' or '-ftrivial-auto-var-init=pattern'"
HA64F3C5CF11D: "在未指定 '-ftrivial-auto-var-init=zero' 或 '-ftrivial-auto-var-init=pattern' 时，无法使用 '-ftrivial-auto-var-init-stop-after=*'"
# "'-ftrivial-auto-var-init-stop-after=*' only accepts positive integers"
H964D5FF3D330: "'-ftrivial-auto-var-init-stop-after=*' 只接受正整数"
# "'-fuse-ld=' taking a path is deprecated; use '--ld-path=' instead"
H24009BC2E029: "'-fuse-ld=' 接受路径的功能已弃用；请改用 '--ld-path= '"
# "'-mbranch-protection=' option is incompatible with the '%0' architecture"
H4CC02B48C139: "'-mbranch-protection= ' 选项与 '%0' 架构不兼容"
# "'-mindirect-jump=%0' is unsupported with the '%1' architecture"
HA019BCF52E06: "'-mindirect-jump=%0' 不支持 '%1' 架构"
# "'-x %0' after last input file has no effect"
H37D74D222DAD: "在最后一个输入文件之后的 '-x %0' 无效"
# "'.  Try: '"
H3E571CE448AB: "'.  尝试：'"
# "'...' as the only parameter of a function is incompatible with C standards before C23"
H0778011D458B: "函数的唯一参数为 '...' 与 C23 之前的 C 标准不兼容"
# "'...' in this location creates a C-style varargs function%select{, not a function parameter pack|}0"
HDE7D8371A836: "在此位置使用 '...' 会创建一个 C 样式可变参数函数%select{，而不是函数参数包|}0"
# "'...' must %select{immediately precede declared identifier|be innermost component of anonymous pack declaration}0"
H636262C7094A: "'...' 必须 %select{ 紧接声明的标识符之前 | 作为匿名包声明的最内层组件 }0"
# "'/*' within block comment"
HF2D384BEFA1C: "块注释内的 '/*'"
# "'/U%0' treated as the '/U' option"
HE813F64217D5: "将 '/U%0' 视为 '/U' 选项"
# "':' without preceding '?'"
H8AFE0C8D8DEE: "缺少前置 '?' 的 ':'"
# "'<::' is treated as digraph '<:' (aka '[') followed by ':' in C++98"
H79B7386C3992: "在 C++98 中，'<::' 被视为双字符符号 '<:'（即 '['）后接 ':'"
# "'<=>' is a single token in C++20; add a space to avoid a change in behavior"
HA94282EE55ED: "在 C++20 中 '<=>' 是单个标记；添加空格以避免行为变化"
# "'<=>' operator is incompatible with C++ standards before C++20"
H95F1D52E2E7F: "'<=>' 运算符与 C++20 之前的 C++ 标准不兼容"
# "'= %select{default|delete}0' is a function definition and must occur in a standalone declaration"
H500D10ACAD58: "'= %select{default|delete}0' 是函数定义，必须出现在独立声明中"
# "'= delete' with a message is a C++2c extension"
H31210BBF787E: "带有消息的 '= delete' 是 C++2c 扩展"
# "'= delete' with a message is incompatible with C++ standards before C++2c"
HF4121BB98E1E: "带有消息的 '= delete' 与 C++2c 之前的 C++ 标准不兼容"
# "'@encode' of incomplete type %0"
H26BBB8B07598: "不完全类型 %0 的 '@encode'"
# "'@end' appears where closing brace '}' is expected"
H0D104C2A47DE: "'@end' 出现的位置期望有闭合的大括号 '}'"
# "'@end' must appear in an Objective-C context"
H53F73799BBFE: "'@end' 必须出现在 Objective-C 上下文中"
# "'NSObject' attribute is for pointer types only"
HB79535A35025: 'NSObject 属性仅适用于指针类型'
# "'NSObject' attribute may be put on a typedef only; attribute is ignored"
H5749529C7AA1: 'NSObject 属性只能放在 typedef 上；属性被忽略'
# "'[[%select{nodiscard|gnu::warn_unused_result}0]]' attribute ignored when applied to a typedef; consider using '__attribute__((warn_unused_result))' or '[[clang::warn_unused_result]]' instead"
HC050BA19FE21: "当应用于 typedef 时忽略 [[%select{nodiscard|gnu::warn_unused_result}0]] 属性；建议改用 '__attribute__((warn_unused_result))' 或 '[[clang::warn_unused_result]]'"
# "'[[carries_dependency]]' attribute only allowed on parameter in a function declaration or lambda"
HA6D310EC7345: '[[carries_dependency]] 属性只能用在函数声明或 lambda 的参数上'
# "'[]' after delete interpreted as 'delete[]'; add parentheses to treat this as a lambda-expression"
H9FAF75D55EEF: "delete 后的 '[]' 被解释为 'delete[]'；添加括号以将其视为 lambda 表达式"
# "'_BitInt' %select{vector|matrix}0 element width must be a power of 2"
HE9CD7B30FBE6: "'_BitInt' %select{向量|矩阵}0 元素宽度必须是 2 的幂"
# "'_BitInt' in %select{C17 and earlier|C++}0 is a Clang extension"
HDE7EEC66FEFB: '%select{C17 及更早版本|C++}0 中的 _BitInt 是 Clang 扩展'
# "'_BitInt' suffix for literals is a C23 extension"
HA6733F109D23: '字面量的 _BitInt 后缀是 C23 扩展'
# "'_BitInt' suffix for literals is a Clang extension"
HE33869F03EE8: '字面量的 _BitInt 后缀是 Clang 扩展'
# "'_BitInt' suffix for literals is incompatible with C standards before C23"
H8F9C2C09F088: '字面量的 _BitInt 后缀与 C23 之前的 C 标准不兼容'
# "'_Complex %0' is invalid"
HF4E888A73841: "'_Complex %0' 是无效的"
# "'_Countof' requires an argument of array type; %0 invalid"
H8DD99C0DA777: "'_Countof' 需要数组类型的参数；%0 无效"
# "'_ExtInt' is deprecated; use '_BitInt' instead"
H6A2C7F4FE8E7: '_ExtInt 已弃用；请改用 _BitInt'
# "'_Noreturn' can only appear on functions"
H8C4082088BE9: '_Noreturn 仅能用于函数'
# "'_Noreturn' keyword must precede function declarator"
HC448318DE5F1: '_Noreturn 关键字必须出现在函数说明符之前'
# "'_Sat' specifier is only valid on '_Fract' or '_Accum', not '%0'"
H43A3B4233E86: "_Sat 限定符仅适用于 '_Fract' 或 '_Accum'，而非 '%0'"
# "'_Static_assert' with no message is a C23 extension"
H1BCF5D7E02AE: '无消息的 _Static_assert 是 C23 扩展'
# "'_Static_assert' with no message is incompatible with C standards before C23"
H977D55CE0649: '无消息的 _Static_assert 与 C23 之前的 C 标准不兼容'
# "'__FLT_EVAL_METHOD__' cannot be expanded inside a scope containing '#pragma clang fp eval_method'"
H2CAB7A2D4110: "在包含 '#pragma clang fp eval_method' 的作用域内无法展开 '__FLT_EVAL_METHOD__'"
# "'__auto_type' is a GNU extension"
H2094509BC6E5: '__auto_type 是 GNU 扩展'
# "'__builtin_bit_cast' %select{source|destination}0 type must be trivially copyable"
H90D0B71921CD: '__builtin_bit_cast %select{源|目标}0 类型必须是可简单复制的'
# "'__builtin_choose_expr' requires a constant expression"
H090BF417F6DF: "'__builtin_choose_expr' 需要一个常量表达式"
# "'__builtin_counted_by_ref' argument cannot have side-effects"
HD566565DD11F: "'__builtin_counted_by_ref' 参数不能有副作用"
# "'__builtin_counted_by_ref' argument must reference a flexible array member"
HABF270462F6F: "'__builtin_counted_by_ref' 参数必须引用一个柔性数组成员"
# "'__builtin_ms_va_start' used in System V ABI function"
H007690BB92E1: "在 System V ABI 函数中使用了 '__clang_arm_builtin_alias' 属性"
# "'__clang__' is a predefined macro name, not an attribute scope specifier; did you mean '_Clang' instead?"
HE8F991CDE8C6: "'__clang__' 是预定义的宏名称，而非属性作用域；是否应改为 '_Clang'？"
# "'__clang_arm_builtin_alias' attribute can only be applied to an ARM builtin"
H79EABB0EF1E5: "'__clang_arm_builtin_alias' 属性只能应用于 ARM 内建函数"
# "'__clang_arm_mve_strict_polymorphism' attribute can only be applied to an MVE/NEON vector type"
H202E8786A308: "'__clang_arm_mve_strict_polymorphism' 属性只能应用于 MVE/NEON 向量类型"
# "'__declspec' attributes are not enabled; use '-fdeclspec' or '-fms-extensions' to enable support for __declspec attributes"
H465DF3E43560: "'__declspec' 属性未启用；请使用 '-fdeclspec' 或 '-fms-extensions' 启用对 __declspec 属性的支持"
# "'__declspec(dllexport)' cannot be applied to more than one default constructor in %0"
HB67031034443: "'__declspec(dllexport)' 不能应用于 %0 中的多个默认构造函数"
# "'__declspec(thread)' applied to variable that already has a thread-local storage specifier"
HFE6629E646D9: "已为带有线程本地存储说明符的变量应用了 '__declspec(thread)'"
# "'__funcref' attribute can only be applied to a function pointer type"
H5101424932DE: "'__funcref' 属性只能应用于函数指针类型"
# "'__kindof' specifier cannot be applied to non-object type %0"
HBB66D4C1FC38: "无法将 '__kindof' 规范应用于非对象类型 %0"
# "'__kindof' type specifier must precede the declarator"
H111C48694838: "'__kindof' 类型说明符必须出现在声明符之前"
# "'__leave' statement not in __try block"
HA19FB1CE432F: "'__leave' 语句不在 __try 块中"
# "'__local' variable cannot have an initializer"
H0B1BBFD1CDEA: "'__local' 变量不能带有初始化器"
# "'__pixel' must be preceded by '__vector'.  '%0' declaration specifier not allowed here"
H88B3B9C40157: "'__pixel' 必须由 '__vector' 前导。不允许在此处使用 '%0' 声明说明符"
# "'__ptrauth' qualification mismatch%diff{ ($ and $)|}0,1"
H6E0E8F990A99: "'__ptrauth' 限定符不匹配%diff{ ($和$)|}1,0"
# "'__ptrauth' qualifier must take between 1 and 3 arguments"
HD53DD31D4F33: "'__ptrauth' 限定符必须接受 1 到 3 个参数"
# "'__ptrauth' qualifier only applies to pointer or pointer sized integer types; %0 is invalid"
HEA3E527DDE36: "'__ptrauth' 限定符仅适用于指针或指针大小的整数类型；%0 不合法"
# "'__super' cannot be used with a using declaration"
HE7865E9E15F7: "'__super' 不能与 using 声明一起使用"
# "'__thread' before '%0'"
H4E940DC3AE07: "'__thread' 位于 '%0' 之前"
# "'abi_tag' %0 missing in original declaration"
H1628165A1258: "原始声明中缺少 'abi_tag' %0"
# "'abi_tag' attribute on %select{non-inline|anonymous}0 namespace ignored"
HDBC2CCB057F1: "%select{非内联|匿名}0命名空间的 'abi_tag' 属性被忽略"
# "'abstract' keyword is a Microsoft extension"
HA16E3E3ED791: "'abstract' 关键字是Microsoft扩展"
# "'adjust_arg' argument %0 used in multiple clauses"
H05E9C9F203D8: "'adjust_arg' 参数 %0 在多个子句中被使用"
# "'align_value' attribute requires integer constant"
H6853424EF803: "'align_value' 属性需要整型常量"
# "'alignas' is incompatible with C++98"
H0BBFE28F35BF: "'alignas' 与C++98不兼容"
# "'aligned' attribute requires integer constant"
H1ADA356A8681: "'aligned' 属性需要整型常量"
# "'alignof' on an incomplete array type is a C2y extension"
HFD6D41C433A2: "'alignof' 用于不完整数组类型是C2y扩展"
# "'alignof' on an incomplete array type is incompatible with C standards before C2y"
HF644B202EC9A: "'alignof' 用于不完整数组类型与C2y之前的标准不兼容"
# "'append_args' is not allowed with varargs functions"
H99449471B7D4: "不可与变长参数函数同时使用 'append_args'"
# "'assign' property of object type may become a dangling reference; consider using 'unsafe_unretained'"
H7256F2B86929: "'assign' 对象类型属性可能导致悬垂引用；建议使用 'unsafe_unretained'"
# "'atomic capture' with a compound statement only supports two statements"
H0E46970C2D96: "'atomic capture' 配合复合语句仅支持两个语句"
# "'auto' as a functional-style cast is incompatible with C++ standards before C++23"
HD4DCD08E6C51: "作为函数式类型转换的 'auto' 与C++23之前的标准不兼容"
# "'auto' deduced as 'id' in declaration of %0"
HD22AA217F352: "'auto' 在 %0 的声明中推导为 'id' 类型"
# "'auto' return without trailing return type; deduced return types are a C++14 extension"
H2CC514506858: "无显式返回类型的 'auto' 返回值；类型推导是C++14扩展"
# "'auto' storage class specifier is not permitted in C++11, and will not be supported in future releases"
H51939B968318: "'auto' 存储类说明符在C++11中已被弃用，未来版本将不再支持"
# "'auto' storage class specifier is redundant and incompatible with C++11"
HFAD8EB4C5407: "'auto' 存储类说明符是冗余的，并与C++11不兼容"
# "'auto' type specifier is a %select{C++11|HLSL 202y}0 extension"
H96C499C3C66C: "'auto' 类型说明符是 %select{C++11|HLSL 202y}0 扩展"
# "'auto' type specifier is incompatible with C++98"
HA4F3AA6BB021: "'auto' 类型说明符与C++98不兼容"
# "'auto' variable template instantiation is not allowed"
H7677E31876EE: "不允许对 'auto' 变量模板进行实例化"
# "'begin' and 'end' returning different types (%0 and %1) is a C++17 extension"
H440F964925D8: "'begin' 和 'end' 返回不同类型（%0 和 %1）是C++17扩展"
# "'begin' and 'end' returning different types (%0 and %1) is incompatible with C++ standards before C++17"
HCE5BB9C433E6: "'begin' 和 'end' 返回不同类型（%0 和 %1）与C++17之前的标准不兼容"
# "'break' is bound to loop, GCC binds it to switch"
HB56827FEFDD0: "'break' 与循环绑定，GCC 将其与 switch 绑定"
# "'break' statement not in loop or switch statement"
HD351562F6355: "'break' 语句不在循环或 switch 语句中"
# "'break' will never be executed"
H6E907B3877AE: "'break' 将永远不会被执行"
# "'callback' argument at position %0 references unavailable implicit 'this'"
HFC4B047896FC: "位置 %0 的 'callback' 参数引用了不可用的隐式 'this'"
# "'callback' attribute argument %0 is not a known function parameter"
H5112D2E8FE1B: "'callback' 属性参数 %0 不是已知的函数参数"
# "'callback' attribute callee does not have function type"
H11C2E7DC48A0: "'callback' 属性的调用方没有函数类型"
# "'callback' attribute callee may not be variadic"
H5339D3799089: "'callback' 属性的调用方不能是可变参数的"
# "'callback' attribute references function of type %0 which expects %1 %plural{1:argument|:arguments}1 but attribute specifies %2 parameter index %plural{1:argument|:arguments}2"
HE68D93E84E5E: "'callback' 属性引用了类型为 %0 的函数，该函数期望 %1 %plural{1:参数|:参数}1 但属性指定了 %2 参数索引 %plural{1:参数|:参数}2"
# "'callback' attribute specifies invalid callback callee"
HAE51B1A6C397: "'callback' 属性指定了无效的回调调用方"
# "'callback' attribute specifies no callback callee"
HC67CEF8B86D2: "'callback' 属性未指定回调调用方"
# "'called_once' attribute only applies to function-like parameters"
HFCB51789AAF0: "'called_once' 属性仅适用于函数式参数"
# "'case' statement not in switch statement"
H3C29CC73E754: "'case' 语句不在 switch 语句中"
# "'char8_t' type specifier is incompatible with C++ standards before C++20"
H6EF68EF28349: "'char8_t' 类型说明符与 C++20 之前的 C++ 标准不兼容"
# "'cleanup' argument %select{|%1 |%1 }0is not a %select{||single }0function"
HF9B0713C400E: "'cleanup' 参数 %select{|%1 |%1 }0 不是一个 %select{||单一 }0 函数"
# "'cleanup' function %0 must take 1 parameter"
H70C0FCE6BEDE: "'cleanup' 函数 %0 必须接受 1 个参数"
# "'cleanup' function %0 parameter has %diff{type $ which is incompatible with type $|incompatible type}1,2"
H24491DE4E886: "'cleanup' 函数 %0 的参数具有 %diff{类型 $ 与类型 $ 不兼容|不兼容类型}1,2"
# "'cmse_nonsecure_entry' cannot be applied to functions with internal linkage"
H36BD2CDFCAC5: "'cmse_nonsecure_entry' 不能应用于具有内部链接的函数"
# "'co_await' modifier can only be applied to range-based for loop"
H23B6AEBD1B5B: "'co_await' 修饰符只能应用于基于范围的 for 循环"
# "'const' attribute imposes more restrictions; 'pure' attribute ignored"
HAC8EEAA61CD9: "'const' 属性施加了更多限制；忽略 'pure' 属性"
# "'consteval' specifier is incompatible with C++ standards before C++20"
HFAB40415D777: "'consteval' 规定与 C++20 之前的 C++ 标准不兼容"
# "'constexpr' can only be used in variable declarations"
HCCD21640DBE9: "'constexpr' 仅可在变量声明中使用"
# "'constexpr' non-static member function will not be implicitly 'const' in C++14; add 'const' to avoid a change in behavior"
H23AE1DDB6BF2: "'constexpr' 非静态成员函数在C++14中将不会隐式为 'const'；添加const以避免行为变化"
# "'constexpr' on lambda expressions is a C++17 extension"
H99E246301B16: "lambda表达式上的 'constexpr' 是C++17扩展"
# "'constexpr' specifier is incompatible with C++98"
H26D17B863D82: "'constexpr' 说明符与C++98不兼容"
# "'constinit' specifier added after initialization of variable"
H941EB6451F6C: "'constinit' 说明符在变量初始化后添加"
# "'constinit' specifier is incompatible with C++ standards before C++20"
HA94D78D91751: "'constinit' 说明符与C++20之前的C++标准不兼容"
# "'constinit' specifier missing on initializing declaration of %0"
H55C3572EEC7C: "%0 的初始化声明缺少 'constinit' 说明符"
# "'continue' statement not in loop statement"
HCD539EA88B8F: "'continue' 语句不在循环语句中"
# "'copy' attribute must be specified for the block property when -fobjc-gc-only is specified"
H87791A0AEA62: "当指定-fobjc-gc-only时，块属性必须指定 'copy' 属性"
# "'counted_by' cannot refer to the flexible array member %0"
H5B04880F56A4: "'counted_by' 不能引用柔性数组成员 %0"
# "'counted_by' on arrays only applies to C99 flexible array members"
HB17E489D7021: "'counted_by' 仅适用于C99柔性数组成员"
# "'cpu_dispatch' function redeclared with different CPUs"
HCA2FB0047F16: "'cpu_dispatch' 函数用不同CPU重新声明"
# "'decltype' type specifier is incompatible with C++98"
H06E59DDEED89: "'decltype' 类型说明符与C++98不兼容"
# "'decltype(auto)' can only be used as a return type in a function declaration"
H5356DF2FE6D3: "'decltype(auto)' 只能用作函数声明的返回类型"
# "'decltype(auto)' cannot be combined with other type specifiers"
H139F443827AC: "'decltype(auto)' 不能与其他类型说明符组合使用"
# "'decltype(auto)' not allowed here"
HA795F2923798: "'decltype(auto)' 在此处不允许"
# "'decltype(auto)' type specifier is a C++14 extension"
H7E1DB4CB833F: "'decltype(auto)' 类型说明符是C++14扩展"
# "'decltype(auto)' type specifier is incompatible with C++ standards before C++14"
HA38CAC8829B9: "'decltype(auto)' 类型说明符与C++14之前的C++标准不兼容"
# "'default' clause for 'metadirective' is deprecated; use 'otherwise' instead"
H505947545CF6: "'metadirective' 的 'default' 子句已弃用；请改用 'otherwise'"
# "'default' statement not in switch statement"
H1133498536DD: "'default' 语句不在switch语句中"
# "'defined' cannot appear within this context"
HDAE80537A1D3: "'defined' 不能出现在此上下文中"
# "'defined' cannot be used as a macro name"
HB4BA3900B80E: "'defined' 不能用作宏名称"
# "'delete%select{|[]}0' applied to a pointer that was allocated with 'new%select{[]|}0'; did you mean 'delete%select{[]|}0'?"
H84CC0C534191: "'delete%select{|[]}0' 应用于由 'new%select{[]|}0' 分配的指针；是否应改为 'delete%select{[]|}0'？"
# "'delete' applied to a pointer-to-array type %0 treated as 'delete[]'"
H011BFAE8BB84: "将指针数组类型 %0 作为 'delete[]' 处理"
# "'delete' cannot delete objects of type %0 in address space '%1'"
H7E66A4AF7B26: "无法在地址空间 '%1' 中删除类型 %0 的对象"
# "'depend' clause for 'ordered' is deprecated; use 'doacross' instead"
HB07DCDAB27B1: "'depend' 子句用于 'ordered' 已弃用；请改用 'doacross'"
# "'depend' clause requires the 'targetsync' interop type"
H2DD7E54EBF24: "'depend' 子句需要 'targetsync' 互操作类型"
# "'deprecated' attribute on anonymous namespace ignored"
HE49B32CE23AF: "匿名命名空间上的 'deprecated' 属性被忽略"
# "'device_type(%0)' does not match previously specified 'device_type(%1)' for the same declaration"
HDE923438E688: "'device_type(%0)' 与同一声明之前指定的 'device_type(%1)' 不匹配"
# "'diagnose_if' is a clang extension"
H6ABE610AE6BE: "'diagnose_if' 是 clang 的扩展"
# "'dllexport' attribute ignored on explicit instantiation definition"
H5570C9EC211D: "显式实例化定义上的 'dllexport' 属性被忽略"
# "'enable_if' is a clang extension"
HF8D51A54A3FE: "'enable_if' 是 clang 的扩展"
# "'explicit' can only appear on non-static member functions"
H4ED84C1B6695: "'explicit' 仅可用于非静态成员函数"
# "'explicit' can only be applied to a constructor or conversion function"
H31AF261810E7: "'explicit' 仅可应用于构造函数或转换函数"
# "'explicit' can only be specified inside the class definition"
H4954093357D9: "'explicit' 仅可在类定义内部指定"
# "'explicit' is not permitted on top-level modules"
HDAE06689A152: "顶级模块中不允许使用 'explicit'"
# "'extern' variable has an initializer"
HB91B40E25B4C: "'extern' 变量有初始值设定项"
# "'extern' variable may not be referenced by '%0' clause on an OpenACC 'declare' directive"
H270234BE5B42: "外部变量可能无法被 OpenACC 'declare' 指令的 '%0' 子句引用"
# "'flush' directive with memory order clause '%0' cannot have the list"
HC2158D6851BB: "带有内存顺序子句 '%0' 的 'flush' 指令不能有列表"
# "'for co_await' belongs to CoroutineTS instead of C++20, which is deprecated"
H6DA54D0F5428: "'for co_await' 属于 CoroutineTS 而非 C++20，已被弃用"
# "'friend' must appear first in a non-function declaration"
HEBE4422274B2: "'friend' 必须出现在非函数声明的开头"
# "'friend' used outside of class"
HABD952B07FCB: "在类外部使用 'friend'"
# "'gnu_inline' attribute requires function to be marked 'inline', attribute ignored"
HEDCF2C7F36F0: "'gnu_inline' 属性要求函数被标记为 'inline'，该属性被忽略"
# "'gnu_inline' attribute without 'extern' in C++ treated as externally available, this changed in Clang 10"
H021467CD0886: "'gnu_inline' 属性在 C++ 中若未带 'extern' 则被视为外部可用，此行为在 Clang 10 版本后有所更改"
# "'hybrid_patchable' is ignored on functions without external linkage"
H0ADF7398ED3A: "'hybrid_patchable' 在没有外部链接性的函数上被忽略"
# "'inline' can only appear on functions%select{| and non-local variables}0"
H89E78E1738F9: "'inline' 只能出现在函数 %select{|和非局部变量}0 上"
# "'inscan' modifier can be used only in 'omp for', 'omp simd', 'omp for simd', 'omp parallel for', or 'omp parallel for simd' directive"
HD994FA838907: "'inscan' 修饰符只能在 'omp for'、'omp simd'、'omp for simd'、'omp parallel for' 或 'omp parallel for simd' 指令中使用"
# "'internal_linkage' attribute on a non-static local variable is ignored"
H66A8BF53EA8F: "非静态局部变量上的 'internal_linkage' 属性被忽略"
# "'lifetime_capture_by' argument references itself"
H3627CC1FAD24: "'lifetime_capture_by' 参数引用自身"
# "'lifetime_capture_by' argument references unavailable implicit 'this'"
HCCCF5641FC93: "'lifetime_capture_by' 参数引用不可用的隐式 'this'"
# "'lifetime_capture_by' attribute argument %0 is not a known function parameter; must be a function parameter, 'this', 'global' or 'unknown'"
H3A8F776F3ADB: "'lifetime_capture_by' 属性参数 %0 不是已知的函数参数；必须是函数参数、'this'、'global' 或 'unknown'"
# "'lifetime_capture_by' attribute specifies no capturing entity"
HA61E4C8D2E68: "'lifetime_capture_by' 属性未指定任何捕获实体"
# "'lifetimebound' attribute cannot be applied to a %select{constructor|destructor}0"
H67DD72C3F644: "'lifetimebound' 属性无法应用于 %select{构造函数|析构函数}0"
# "'lifetimebound' attribute cannot be applied to a parameter of a function that returns void; did you mean 'lifetime_capture_by(X)'"
H7AF0F9960FBE: "'lifetimebound' 属性无法应用于返回 void 类型函数的参数；是否应使用 'lifetime_capture_by(X)'"
# "'lifetimebound' attribute cannot be applied to an implicit object parameter of a function that returns void; did you mean 'lifetime_capture_by(X)'"
H246C1F79D057: "'lifetimebound' 属性无法应用于返回 void 类型函数的隐式对象参数；是否应使用 'lifetime_capture_by(X)'"
# "'lifetimebound' attribute cannot be applied; %select{non-|static |explicit object }0member function has no implicit object parameter"
H4EDB6AB20113: "'lifetimebound' 属性无法应用；%select{非-|静态 |显式对象 }0 成员函数没有隐式对象参数"
# "'linear' clause cannot be specified along with 'ordered' clause with a parameter"
H20416EEA599F: "'linear' 子句不能与带有参数的 'ordered' 子句同时指定"
# "'long long' is a C++11 extension"
HC63DB1FBE144: "'long long' 是 C++11 扩展"
# "'long long' is an extension when C99 mode is not enabled"
H90F12D1B1D4D: "'long long' 在未启用 C99 模式时属于扩展"
# "'long long' is incompatible with C++98"
H0DAB29466D2C: "'long long' 与 C++98 不兼容"
# "'main' cannot be a multiversioned function"
HAFF8B40A53DE: "'main' 不能是多版本化函数"
# "'main' is not allowed to be declared %select{constexpr|consteval}0"
H13F25D825A17: "'main' 不允许被声明为 %select{constexpr|consteval}0"
# "'main' is not allowed to be declared _Noreturn"
HE455B9A59591: "'main' 不允许被声明为 _Noreturn"
# "'main' is not allowed to be declared inline"
HBC0A4A59C65E: "'main' 不允许被声明为 inline"
# "'main' is not allowed to be declared static"
HB1B95BDA01B7: "'main' 不允许被声明为 static"
# "'main' is not allowed to be declared variadic"
HD3EE247E6A72: "'main' 不允许被声明为可变参数函数"
# "'main' is not allowed to be deleted"
HB0C6AFB93EDB: "'main' 不允许被声明为 deleted"
# "'main' must return 'int'"
HD54CCE2AF684: "'main' 必须返回 'int'"
# '\'main\' should not be \'extern "%select{C|C++}0"\''
H19102C631788: '\'main\' 不应声明为 \'extern "%select{C|C++}0"\''
# "'main' should not be declared static"
H9A6B59304912: "'main' 不应被声明为 static"
# "'malloc' argument %0 must take a pointer type as its first argument"
HEF17CC57A675: "'malloc' 参数 %0 的首个参数必须是指针类型"
# "'malloc' argument %select{for deallocator |%1 |%1 }0is not a %select{||single }0function"
HC684E8204794: "'malloc' 参数 %select{用于释放器 |%1 |%1 }0 不是 %select{||单一}0 函数"
# "'malloc' argument '%0' refers to non-pointer type %1 of %2"
HFD06C554D4E6: "'malloc' 参数 '%0' 引用了 %2 的非指针类型 %1"
# "'mig_server_routine' attribute only applies to routines that return a kern_return_t"
HF1C5C16FC7E6: "'mig_server_routine' 属性仅适用于返回 kern_return_t 的例程"
# "'module' declaration found while building header unit"
HA86B9DC6C734: "构建头单元时检测到 'module' 声明"
# "'module' declaration found while building module from module map"
H880BB7F53078: "从模块映射构建模块时检测到 'module' 声明"
# "'module;' introducing a global module fragment can appear only at the start of the translation unit"
H617DC2BE71CE: "'module;' 引入全局模块片段只能出现在翻译单元的开头"
# "'musttail' attribute for this call is impossible because %select{long calls cannot be tail called on PPC|indirect calls cannot be tail called on PPC|external calls cannot be tail called on PPC}0"
H14240DA28AAD: "'musttail' 属性对此调用不可能，因为 %select{在 PPC 上无法尾调用长调用|在 PPC 上无法尾调用间接调用|在 PPC 上无法尾调用外部调用}0"
# "'musttail' attribute is not supported on AIX"
H92717FE13CEF: "AIX 不支持 'musttail' 属性"
# "'mutable' and 'const' cannot be mixed"
H6CE01BCA1797: "'mutable' 和 'const' 不能混用"
# "'mutable' can only be applied to member variables"
HC1CD8F78BDE1: "'mutable' 只能应用于成员变量"
# "'mutable' cannot be applied to functions"
H9B6452717014: "'mutable' 不能应用于函数"
# "'mutable' cannot be applied to references"
H7CCDA0B2596A: "'mutable' 不能应用于引用"
# "'mutable' on a reference type is a Microsoft extension"
H6E975C04AF4E: "引用类型上的 'mutable' 是Microsoft扩展"
# "'mutexinoutset' modifier not allowed in 'depend' clause on 'taskwait' directive"
H54D9DFD0A59D: "'taskwait' 指令的 'depend' 子句中不能使用 'mutexinoutset' 修饰符"
# "'new' cannot allocate an array of %0 with no explicit ownership"
H01CEEA4215DD: "'new' 不能分配未显式指定所有权的 %0 类型数组"
# "'new' cannot allocate object of variably modified type %0"
HB68377C1CB34: "'new' 不能分配可变长度类型 %0 的对象"
# "'new' cannot allocate objects of type %0 in address space '%1'"
H8F2EE8209986: "'new' 不能在 '%1' 地址空间中分配类型 %0 的对象"
# "'new' expression with placement arguments refers to non-placement 'operator delete'"
H9A938FDFCB36: "带有placement参数的 'new' 表达式指向非placement的 'operator delete'"
# "'nocf_check' attribute ignored; use -fcf-protection to enable the attribute"
HCD98AFA044EC: "'nocf_check' 属性被忽略；请使用-fcf-protection选项启用该属性"
# "'noderef' can only be used on an array or pointer type"
H265BDBEEC1EC: "'noderef' 只能用于数组或指针类型"
# "'noexcept' can only be used in a compound requirement (with '{' '}' around the expression)"
H88CA64B4E3F6: "'noexcept' 只能用于复合需求（需用 '{' '}' 包裹表达式）"
# "'nonmonotonic' modifier can only be specified with 'dynamic' or 'guided' schedule kind"
H60F2BCD19874: "'nonmonotonic' 修饰符只能与 'dynamic' 或 'guided' 调度类型一起使用"
# "'nonnull' attribute applied to function with no pointer arguments"
H0D4CBB499E30: "'nonnull' 属性应用于无指针参数的函数"
# "'nonnull' attribute when used on parameters takes no arguments"
H8544A5398585: "用在参数上的 'nonnull' 属性不需要参数"
# "'not_tail_called' attribute prevents being called as a tail call"
HD566EBB2A50E: "'not_tail_called' 属性阻止作为尾调用调用"
# "'nothrow' attribute conflicts with exception specification; attribute ignored"
HA43C7748DBD1: "'nothrow' 属性与异常规范冲突；属性被忽略"
# "'nowait' clause is here"
H4C9748BD1A0B: "'nowait' 子句在此处"
# "'nullptr' is a C23 extension"
H0CCA94E13259: "'nullptr' 是C23扩展"
# "'nullptr' is incompatible with C++98"
HA3F1CF3D3055: "'nullptr' 与C++98不兼容"
# "'objc_bridge(id)' is only allowed on structs and typedefs of void pointers"
H19339C3149E3: "'objc_bridge(id)' 仅允许用于 void 指针类型的结构体和 typedef"
# "'objc_class_stub' attribute cannot be specified on a class that does not have the 'objc_subclassing_restricted' attribute"
H131E98846FD9: "未声明 'objc_subclassing_restricted' 属性的类不能使用 'objc_class_stub' 属性"
# "'objc_designated_initializer' attribute only applies to init methods of interface or class extension declarations"
H0C4330D28BB6: "'objc_designated_initializer' 属性仅适用于接口或类扩展声明的初始化方法"
# "'objc_direct' attribute cannot be applied to %select{methods|properties}0 declared in an Objective-C protocol"
H0E0D013ED449: "'objc_direct' 属性不能应用于 Objective-C 协议中声明的 %select{方法|属性}0"
# "'objc_externally_retained' can only be applied to local variables %select{of retainable type|with strong ownership}0"
H863E7A12B731: "'objc_externally_retained' 仅能用于 %select{可保留类型的局部变量|具有强所有权的局部变量}0"
# "'objc_independent_class' attribute may be put on Objective-C object pointer type only; attribute is ignored"
H917C3A1684AC: "'objc_independent_class' 属性只能应用于 Objective-C 对象指针类型；该属性被忽略"
# "'objc_independent_class' attribute may be put on a typedef only; attribute is ignored"
HCF5FB9401D67: "'objc_independent_class' 属性只能应用于 typedef；该属性被忽略"
# "'offsetof' on non-POD type %0"
H2BFD47074829: "对非POD类型 %0 使用 'offsetof'"
# "'offsetof' on non-standard-layout type %0"
H0A19805CBC92: "对非标准布局类型 %0 使用 'offsetof'"
# "'omp_interop_t' must be defined when 'append_args' clause is used; include <omp.h>"
H584E24086261: "'omp_interop_t' 在使用 'append_args' 子句时必须被定义；请包含 <omp.h>"
# "'ompx_attribute' clause only allows 'amdgpu_flat_work_group_size', 'amdgpu_waves_per_eu', and 'launch_bounds'; %0 is ignored"
H15379B8D06F4: "'ompx_attribute' 子句仅允许 'amdgpu_flat_work_group_size', 'amdgpu_waves_per_eu' 和 'launch_bounds'；%0 被忽略"
# "'ompx_bare' clauses requires explicit grid size via 'num_teams' and 'thread_limit' clauses"
HC78DCADADB1C: "'ompx_bare' 子句需要通过 'num_teams' 和 'thread_limit' 子句显式指定网格大小"
# "'operator new' provided by %0 is not usable with the function signature of %1"
HC75862C47BD1: "%0 提供的 'operator new' 与 %1 的函数签名不兼容"
# "'operator->' declared here produces an object of type %0"
HC1D7E6DA4A9D: "在这里声明的 'operator->' 会产生类型为 %0 的对象"
# "'ordered' clause with a parameter cannot be specified in '#pragma omp %0' directive"
HE291A06801DB: "带有参数的 'ordered' 子句不能在 '#pragma omp %0' 指令中指定"
# "'ordered' clause%select{| with specified parameter}0"
H337028DA61A4: "'ordered' 子句 %select{| 带指定参数}0"
# "'ordered' directive %select{without any clauses|with 'threads' clause}0 cannot be closely nested inside ordered region with specified parameter"
HB16FD1003ED0: "'ordered' 指令%select{无任何子句|带有 'threads' 子句}0 不能紧密嵌套在带有指定参数的有序区域内部"
# "'ordered' directive with '%0' clause cannot be closely nested inside ordered region without specified parameter"
H1845D44BB3DE: "带有 '%0' 子句的 'ordered' 指令不能紧密嵌套在无指定参数的有序区域内部"
# "'overloadable' function %0 must have a prototype"
HA041210B9619: "'overloadable' 函数 %0 必须具有原型"
# "'ownership_returns' attribute index does not match; here it is %0"
H1C0451B398DB: "'ownership_returns' 属性索引不匹配；此处为 %0"
# "'ownership_returns' attribute only applies to functions that return a pointer"
HE96B6120100D: "'ownership_returns' 属性仅适用于返回指针的函数"
# "'ownership_takes' attribute class does not match; here it is '%0'"
H2E44647C4A59: "'ownership_takes' 属性类不匹配；此处为 '%0'"
# "'packed' attribute was ignored on bit-fields with single-byte alignment in older versions of GCC and Clang"
H8DB05E11AD0A: "在旧版 GCC 和 Clang 中，'packed' 属性会忽略单字节对齐的位段"
# "'reduction' clause cannot be used with 'nogroup' clause"
H186A32581806: "'reduction' 子句不能与 'nogroup' 子句一起使用"
# "'reduction' clause not allowed with '#pragma omp loop bind(teams)'"
H4981CB6A6643: "不允许在 '#pragma omp loop bind(teams)' 中使用 'reduction' 子句"
# "'reduction' clause with 'inscan' modifier is used here"
HE04EBCC11985: "带有 'inscan' 修饰符的 'reduction' 子句在此处使用"
# "'reduction' clause with 'task' modifier allowed only on non-simd parallel or worksharing constructs"
HD0FEE7231060: "带有 'task' 修饰符的 'reduction' 子句仅允许用于非SIMD并行或工作共享构造"
# "'register' storage class specifier is deprecated and incompatible with C++17"
HDBC08F071224: "'register' 存储类说明符已弃用，并且与 C++17 不兼容"
# "'register' storage specifier on @catch parameter will be ignored"
H4232960B8CCE: "@catch 参数上的 'register' 存储说明符将被忽略"
# "'regparm' is not valid on this platform"
H1E534F14C852: "'regparm' 在此平台上无效"
# "'regparm' parameter must be between 0 and %0 inclusive"
H63349C70781C: "'regparm' 参数必须在 0 到 %0 之间（含两端）"
# "'reinterpret_cast' %select{from|to}3 class %0 %select{to|from}3 its %select{virtual base|base at non-zero offset}2 %1 behaves differently from 'static_cast'"
HF87527FE7FBB: "'reinterpret_cast' 将 %select{来自|到}3 类 %0 %select{到|来自}3 其 %select{虚基类|非零偏移基类}2 %1 的行为与 'static_cast' 不同"
# "'require_constant_initialization' attribute added after initialization of variable"
HCCF005312D01: "变量初始化后添加了 'require_constant_initialization' 属性"
# "'restrict' qualifier on an array of pointers is a C23 extension"
H831A2BF01322: "指针数组上的 'restrict' 限定符是 C23 扩展"
# "'restrict' qualifier on an array of pointers is incompatible with C standards before C23"
H7AB582A89AF4: "指针数组上的 'restrict' 限定符与 C23 之前的标准不兼容"
# "'return' will never be executed"
HF9D8B2478204: "'return' 将永远不会被执行"
# "'sealed' keyword is a Microsoft extension"
H2371564F3064: "'sealed' 关键字是 Microsoft 扩展"
# "'selectany' can only be applied to data items with external linkage"
H0D95115281D5: "'selectany' 仅可应用于具有外部链接性的数据项"
# "'sentinel' attribute only supported for variadic %select{functions|blocks}0"
H0C7CDE5CC83E: "'sentinel' 属性仅支持可变参数的 %select{函数|代码块}0"
# "'sentinel' attribute requires named arguments"
HB4DB8DB54C63: "'sentinel' 属性需要命名参数"
# "'sentinel' parameter 1 less than zero"
HE854964454A6: "'sentinel' 参数 1 小于零"
# "'sentinel' parameter 2 not 0 or 1"
H99541E948450: "'sentinel' 参数 2 不是 0 或 1"
# "'size' argument to bzero is '0'"
H50A840FAEA15: "传递给 bzero 的 'size' 参数为 '0'"
# "'size_t' suffix for literals is a C++23 extension"
HE55B1E186F37: "字面量的 'size_t' 后缀是 C++23 扩展"
# "'size_t' suffix for literals is a C++23 feature"
HFE4E8B889F8C: "字面量的 'size_t' 后缀是 C++23 特性"
# "'size_t' suffix for literals is incompatible with C++ standards before C++23"
H01C26A9D5D7B: "'size_t' 后缀的字面量与C++23之前的C++标准不兼容"
# "'static' can only be specified inside the class definition"
HC2C3574A2AC5: "'static' 只能在类定义内部指定"
# "'static' function %0 declared in header file should be declared 'static inline'"
HAC6B8325923D: "在头文件中声明的 'static' 函数 %0 应声明为 'static inline'"
# "'static' may not be used with an unspecified variable length array size"
H8C886B8B17D3: "'static' 不能与未指定的可变长度数组大小一起使用"
# "'static' may not be used without an array size"
H3CD973765C05: "'static' 在没有数组大小时不能使用"
# "'static' member function %0 overrides a virtual function in a base class"
H917973A36E2C: "'static' 成员函数 %0 覆盖了基类中的虚函数"
# "'static_assert' declarations are incompatible with C++98"
HEBCFD6945359: "'static_assert' 声明与C++98标准不兼容"
# "'static_assert' with a user-generated message is a C++26 extension"
HFCA41F0C6554: "带有用户生成消息的 'static_assert' 是C++26扩展"
# "'static_assert' with a user-generated message is incompatible with C++ standards before C++26"
H71F257CCE8FF: "带有用户生成消息的 'static_assert' 与C++26之前的C++标准不兼容"
# "'static_assert' with no message is a C++17 extension"
H89070CD2F991: "无消息的 'static_assert' 是C++17扩展"
# "'static_assert' with no message is incompatible with C++ standards before C++17"
HFE8F37E6AE5C: "无消息的 'static_assert' 与C++17之前的C++标准不兼容"
# "'std::allocator<...>::deallocate' used to delete a null pointer"
HF2B279909DBC: "'std::allocator<...>::deallocate' 被用来删除空指针"
# "'std::source_location::__impl' must be standard-layout and have only two 'const char *' fields '_M_file_name' and '_M_function_name', and two integral fields '_M_line' and '_M_column'"
HCA27D3915F0B: "'std::source_location::__impl' 必须是标准布局类型，并且只有两个 'const char *' 类型的字段 '_M_file_name' 和 '_M_function_name'，以及两个整数类型的字段 '_M_line' 和 '_M_column'"
# "'std::source_location::__impl' was not found; it must be defined before '__builtin_source_location' is called"
HD0F806FB73A8: "'std::source_location::__impl' 未找到；它必须在调用 '__builtin_source_location' 之前被定义"
# "'super' is only valid in a method body"
HB06D73D4C0E7: "'super' 仅在方法体内有效"
# "'swift_async' completion handler parameter must have block type returning 'void', type here is %0"
H9874890FB098: "'swift_async' 完成处理程序参数必须具有返回 'void' 的块类型，此处类型为 %0"
# "'swift_error_result' parameter must follow 'swift_context' parameter"
HFA5F4F66F83B: "'swift_error_result' 参数必须跟在 'swift_context' 参数之后"
# "'swift_indirect_result' parameters must be first parameters of function"
H624EF03C7676: "'swift_indirect_result' 参数必须是函数的第一个参数"
# "'switch' missing 'default' label"
H855B85E209CE: "'switch' 缺少 'default' 标签"
# "'sycl_kernel' attribute only applies to a function template with at least two template parameters"
H5AFFA7408711: "'sycl_kernel' 属性仅适用于至少包含两个模板参数的函数模板"
# "'sycl_kernel_entry_point' attribute cannot be added to a function after the function is defined"
H018E12D5A5B2: "'sycl_kernel_entry_point' 属性不能在函数定义后添加到该函数"
# "'sycl_kernel_entry_point' attribute cannot be applied to a %select{non-static member function|variadic function|deleted function|defaulted function|constexpr function|consteval function|function declared with the 'noreturn' attribute|coroutine|function defined with a function try block}0"
H86CAEB999295: "'sycl_kernel_entry_point' 属性不能应用于 %select{非静态成员函数|可变参数函数|已删除函数|默认实现函数|constexpr 函数|consteval 函数|带有 'noreturn' 属性声明的函数|协程|使用函数 try 块定义的函数}0"
# "'sycl_kernel_entry_point' attribute only applies to functions with a 'void' return type"
H99CA3F9B2DC2: "'sycl_kernel_entry_point' 属性仅适用于返回类型为 'void' 的函数"
# "'sycl_kernel_entry_point' attribute only applies to functions with a non-deduced 'void' return type"
H14251E8B39CA: "'sycl_kernel_entry_point' 属性仅适用于具有非推导 'void' 返回类型的函数"
# "'sycl_kernel_entry_point' kernel name argument conflicts with a previous declaration"
HFAE6DB6B8BBB: "'sycl_kernel_entry_point' 内核名称参数与之前的声明冲突"
# "'sycl_kernel_entry_point' kernel name argument does not match prior declaration%diff{: $ vs $|}0,1"
H6714A3237372: "'sycl_kernel_entry_point' 内核名称参数与之前的声明不匹配 %diff{: $ vs $|}0,1"
# "'target_clones' attribute does not match previous declaration"
HBD2CF88C376B: "'target_clones' 属性与之前的声明不匹配"
# "'target_clones' multiversioning requires a default target"
HCC23909A82CE: "'target_clones' 多版本化需要默认目标"
# "'template' cannot be used after a declarative nested name specifier"
H7173607CA62C: "'template' 不能用在声明性嵌套名称限定符之后"
# "'template' keyword not permitted after 'using' keyword"
H026D09D01933: "不允许在 'using' 关键字之后使用 'template' 关键字"
# "'template' keyword not permitted here"
HF55CDE212145: "此处不允许使用 'template' 关键字"
# "'template' keyword not permitted in destructor name"
H67CEB40C2F65: "不允许在析构函数名称中使用 'template' 关键字"
# "'template' keyword outside of a template"
H5580CDE2DB12: "在模板外部使用 'template' 关键字"
# "'template<>' header not required for explicitly-specialized class %0 declared here"
H3FF5BAF37ECE: "显式特化的类 %0 声明此处不需要 'template<>' 头部"
# "'this' argument to member function %0 has type %1, but function is not marked %select{const|restrict|const or restrict|volatile|const or volatile|volatile or restrict|const, volatile, or restrict}2"
HB5D291C13072: "成员函数 %0 的 'this' 参数类型为 %1，但函数未标记为 %select{const|restrict|const 或 restrict|volatile|const 或 volatile|volatile 或 restrict|const、volatile 或 restrict}2"
# "'this' argument to member function %0 is an %select{lvalue|rvalue}1, but function has %select{non-const lvalue|rvalue}2 ref-qualifier"
H0AF4BFFD004C: "成员函数 %0 的 'this' 参数是 %select{lvalue|rvalue}1 类型，但函数具有 %select{非 const lvalue|rvalue}2 引用限定符"
# "'this' cannot be %select{implicitly |}0captured in this context"
H0697D44E3441: "'this' 在此上下文中不能%select{隐式|}0 被捕获"
# "'this' cannot be captured by reference"
H13B6762030CD: "'this' 不能通过引用来捕获"
# "'this' cannot be%select{| implicitly}0 used in a static member function declaration"
H4C9AC15A6831: "静态成员函数声明中 %select{|隐式}0不能使用 'this'"
# "'this' pointer cannot be null in well-defined C++ code; comparison may be assumed to always evaluate to %select{true|false}0"
HC979F6DEC864: "'this' 指针在符合 C++ 标准的代码中不能为 null；该比较可能被假定始终求值为 %select{true|false}0"
# "'this' pointer cannot be null in well-defined C++ code; pointer may be assumed to always convert to true"
HE4633A40CE28: "'this' 指针在定义良好的 C++ 代码中不能为 null；该指针可能被假定始终转换为 true"
# "'this' pointer references not allowed in naked functions"
H95FED6FF2C73: "不允许在裸函数中引用 'this' 指针"
# "'trivial_abi' cannot be applied to %0"
H39CEA0BB8E5A: "'trivial_abi' 无法应用于 %0"
# "'trivial_abi' is disallowed on %0 because %select{its copy constructors and move constructors are all deleted|it is polymorphic|it has a base of a non-trivial class type|it has a virtual base|it has a __weak field|it has a field of a non-trivial class type|it has an address-discriminated '__ptrauth' field}1"
HF2341EAAEAEC: "'trivial_abi' 不允许用于 %0，因为%select{其拷贝构造函数和移动构造函数均被删除|它是多态的|它具有非平凡类类型的基类|它具有虚基类|它具有__weak字段|它具有非平凡类类型的字段|它具有地址判别型 '__ptrauth' 字段}1"
# "'true' is not defined, evaluates to 0"
HEC6C8880A6A3: "'true' 未定义，将计算为 0"
# "'type_tag_for_datatype' attribute requires the initializer to be an %select{integer|integral}0 constant expression"
H2191B1B324E8: "'type_tag_for_datatype' 属性要求初始化器必须是一个 %select{整数|积分}0 常量表达式"
# "'type_tag_for_datatype' attribute requires the initializer to be an %select{integer|integral}0 constant expression that can be represented by a 64 bit integer"
HD8F7C3D572F8: "'type_tag_for_datatype' 属性要求初始化器必须是一个 %select{整数|积分}0 常量表达式，并且可以由 64 位整数表示"
# "'typeid' of incomplete type %0"
H9D618623D4E9: "对不完整类型 %0 使用 'typeid'"
# "'typeid' of variably modified type %0"
HB7FBFC93B3FA: "对可变长度类型 %0 使用 'typeid'"
# "'typename' is redundant; base classes are implicitly types"
HD8EB6D904937: "'typename' 是冗余的；基类会隐式视为类型"
# "'typename' keyword used on a non-type"
HEFF0F4A3C4F6: "'typename' 关键字用在非类型上"
# "'typename' outside of a template is a C++11 extension"
H2C5188CF8D58: "'typename' 在模板外部是C++11扩展"
# "'typename' outside of a template is incompatible with C++98"
H89322C630BA2: "'typename' 在模板外部与C++98不兼容"
# "'unavailable' availability overrides all other availability information"
H321E5EA6571D: "'unavailable' 可用性覆盖所有其他可用性信息"
# "'using namespace' is not allowed in classes"
H133BFD711C94: "不允许在类中使用 'using namespace'"
# "'using_if_exists' attribute cannot be applied to an inheriting constructor"
H551D8C76B087: "'using_if_exists' 属性不能应用于继承构造函数"
# "'va_start' cannot be used in a captured statement"
H7AC0FC921988: "无法在捕获的语句中使用 'va_start'"
# "'va_start' cannot be used outside a function"
HFCBDF5268E7D: "无法在函数外部使用 'va_start'"
# "'va_start' used in %select{System V|Win64}0 ABI function"
HCA2FE8C64692: "在 %select{System V|Win64}0 ABI 函数中使用 'va_start'"
# "'va_start' used in function with fixed args"
HDCEB40407EDC: "在具有固定参数的函数中使用 'va_start'"
# "'vec_step' requires built-in scalar or vector type, %0 invalid"
H2D0A081561E0: "'vec_step' 需要内建标量或向量类型，%0 无效"
# "'virtual' can only appear on non-static member functions"
HB1449ED6BD56: "'virtual' 只能出现在非静态成员函数上"
# "'virtual' can only be specified inside the class definition"
HC2C042A27D12: "'virtual' 只能在类定义内部指定"
# "'virtual' cannot be specified on member function templates"
H345B16C9EDA3: "'virtual' 不能用于成员函数模板上"
# "'void' as parameter must not have type qualifiers"
H3B7FE1A42F0E: "作为参数的 'void' 不能带有类型限定符"
# "'void' must be the first and only parameter if specified"
H7DDAB71DFE28: "如果指定了 'void'，它必须是唯一的且第一个参数"
# "'||' of a value and its negation always evaluates to true"
H067D990351EF: "一个值与其否定的 '||' 运算结果始终为真"
# "'~' in destructor name should be after nested name specifier"
H85ED3FE9838A: "析构函数名称中的 '~' 应位于嵌套名称限定符之后"
# "(Deprecated) Controls whether '-Winvalid-gnu-asm-cast' defaults to an error or a warning"
HBE7A04BC29B9: "(已弃用) 控制 '-Winvalid-gnu-asm-cast' 默认为错误还是警告"
# "(For new pass manager) 'per-pass': one report for each pass; 'per-pass-run': one report for each pass invocation"
H0C49717D08C4: "(用于新Pass管理器) 'per-pass': 每个Pass生成一份报告; 'per-pass-run': 每次Pass调用生成一份报告"
# '(integrated-as) Emit an object file which can be used with an incremental linker'
HC13894BE0052: '(集成式汇编器) 生成可用于增量链接器的可重定位目标文件'
# '(integrated-as) Emit an object file which cannot be used with an incremental linker'
H902BD058678C: '(集成式汇编器) 生成不可用于增量链接器的可重定位目标文件'
# '(integrated-as) Relax all machine instructions'
H523BAD847EDC: '(集成式汇编器) 放宽所有机器指令'
# "(skipping %0 'operator->'%s0 in backtrace)"
H3980AA6C4367: "(跳过回溯中的 %0 'operator->'%s0)"
# '(skipping %0 call%s0 in backtrace; use -fconstexpr-backtrace-limit=0 to see all)'
HD7D8BC5DDF54: '(跳过回溯中的 %0 个调用%s0；使用-fconstexpr-backtrace-limit=0显示所有内容)'
# '(skipping %0 context%s0 in backtrace; use -ftemplate-backtrace-limit=0 to see all)'
H1BB10F671BF7: '(跳过回溯中的 %0 个上下文%s0；使用-ftemplate-backtrace-limit=0显示所有内容)'
# '*no default*'
H01EF8BE8DE07: '*无默认值*'
# '--rtlib=libgcc requires --unwindlib=libgcc'
HED8A5F89C398: '--rtlib=libgcc需要同时指定--unwindlib=libgcc'
# '-E or -x required when input is from standard input'
H5AC04D68943E: '当输入来自标准输入时，需要指定-E或-x选项'
# '-O4 is equivalent to -O3'
H0B5239D5C711: '-O4等同于-O3'
# '-Wa,--allow-experimental-crel must be specified to use -Wa,--crel. CREL is experimental and uses a non-standard section type code'
HB2A451FA1760: '使用-Wa,--crel时必须指定-Wa,--allow-experimental-crel。CREL是实验性功能，使用非标准的节类型代码'
# '-code-completion-at=<file>:<line>:<column> requires <line> and <column> to be integers greater than zero'
HEFD41ED402A1: '-code-completion-at=<文件>:<行>:<列> 要求 <行> 和 <列> 是大于零的整数'
# '-dealloc is being overridden in a category'
H75DBC0C062A1: '-dealloc在分类中被重载'
# '-dependency-file requires at least one -MT or -MQ option'
HF99E1B6F31F8: '-dependency-file需要至少一个-MT或-MQ选项'
# '-emit-llvm cannot be used when linking'
H8745DC614FEB: '链接时不能使用-emit-llvm'
# '-fdelayed-template-parsing is deprecated after C++20'
HD52CE72E55C9: 'C++20之后，-fdelayed-template-parsing已弃用'
# '-fembed-bitcode is not supported on versions of iOS prior to 6.0'
HD9B9277DB1F5: '在iOS 6.0之前的版本中不支持-fembed-bitcode'
# '-fexperimental-omit-vtable-rtti call only be used with -fno-rtti'
H27AC8E91BEE0: '-fexperimental-omit-vtable-rtti只能与-fno-rtti一起使用'
# "-fglobal-isel support for the '%0' architecture is incomplete"
HB8576FBD6C6A: "对架构 '%0' 的 -fglobal-isel 支持不完整"
# '-fglobal-isel support is incomplete for this architecture at the current optimization level'
HD08F381A1C6F: '当前优化级别下，此架构的 -fglobal-isel 支持不完整'
# '-fjmc works only for ELF; option ignored'
H862E3BB749F5: '-fjmc 仅适用于 ELF；选项被忽略'
# '-fobjc-arc is not supported on platforms using the legacy runtime'
HE6B9338AE9F6: '使用旧版运行时的平台不支持 -fobjc-arc'
# '-fobjc-arc is not supported on versions of OS X prior to 10.6'
H0AF526E18958: 'OS X 10.6 之前的版本不支持 -fobjc-arc'
# '-fobjc-weak is not supported in Objective-C garbage collection'
H7AD62E69E380: '在 Objective-C 垃圾回收中不支持 -fobjc-weak'
# '-fobjc-weak is not supported on the current deployment target'
H062C1F6DCD65: '当前部署目标不支持 -fobjc-weak'
# '-fsanitize-address-field-padding applied to %0'
H3C21F4C44A7E: '对 %0 应用 -fsanitize-address-field-padding'
# '-fsanitize-address-field-padding ignored for %0 because it %select{is not C++|is packed|is a union|is trivially copyable|has trivial destructor|is standard layout|is in a ignorelisted file|is ignorelisted}1'
H6C62B9F141CF: '因 %0 %select{不是 C++|是已打包的|是联合体|可简单复制|有平凡析构函数|是标准布局|位于忽略列表文件中|已忽略}1，故忽略其 -fsanitize-address-field-padding'
# "-ftest-module-file-extension argument '%0' is not of the required form 'blockname:major:minor:hashed:user info'"
HA7F31D279886: "-ftest-module-file-extension 参数 '%0' 不符合必需的格式 'blockname:major:minor:hashed:user info'"
# '-ftrivial-auto-var-init-stop-after=%0 has been enabled to limit the number of times ftrivial-auto-var-init=%1 gets applied.'
HA5103A32F2CB: '已启用 -ftrivial-auto-var-init-stop-after=%0 以限制应用 ftrivial-auto-var-init=%1 的次数。'
# '-header-include-filtering=%0 requires a compatible value for -header-include-format'
HFD5CA9639FF5: '-header-include-filtering=%0 需要与 -header-include-format 指定的值兼容'
# '-header-include-format=%0 requires a compatible value for -header-include-filtering'
H11F9E33E0B1B: '-header-include-format=%0 需要与 -header-include-filtering 指定的值兼容'
# '-mcmse is not supported for %0'
HBC9BABD34806: '%0 不支持 -mcmse'
# '-mharden-sls is only supported on armv7-a or later'
H370C2A9E9085: '-mharden-sls 仅支持 armv7-a 或更高版本'
# '-mtocdata option is ignored for %0 because %1'
HFF374450D777: '因 %1，故忽略 %0 的 -mtocdata 选项'
# '-mxcoff-roptr is not supported with -shared'
H6DCDD2D9C271: '与 -shared 一起使用时，不支持 -mxcoff-roptr'
# '-mxcoff-roptr is supported only with -fdata-sections'
H64F8AE7E83F9: '仅在与 -fdata-sections 一起使用时支持 -mxcoff-roptr'
# '-verify prefixes must start with a letter and contain only alphanumeric characters, hyphens, and underscores'
H52220FBA1BD4: '-verify 前缀必须以字母开头，并且仅包含字母数字字符、连字符和下划线'
# '.dwo output filename'
HEF051A2EFA9C: '.dwo 输出文件名'
# '// comments are not allowed in this language'
HC63D7ED8A253: '// 注释在此语言中不允许'
# '/arm64EC has been overridden by specified target: %0; option ignored'
HD52B23C67DCF: '指定的目标 %0 覆盖了 /arm64EC；选项被忽略'
# '32-bit targets are not supported when building for Mac Catalyst'
H2B5ECA150DDF: '构建 Mac Catalyst 时，不支持 32 位目标'
# '90th percentile durations'
HCFF900413C06: '第 90 百分位持续时间'
# '99th percentile durations'
H401BE67F4D43: '第 99 百分位持续时间'
# ": Did you mean '"
HF9464896A916: ": 您指的是 '"
# ': Not enough positional command line arguments specified!\n'
H41F31955D402: ': 指定的位置命令行参数不足！\n'
# ': See: '
HAF76FB12E339: ': 请参见：'
# ': Too many positional arguments specified!\n'
H166421801500: ': 指定的位置参数过多！\n'
# ': Unknown '
H62CC89B124B8: ': 未知的 '
# '<INDEX FILE>'
HA21BDF8C3F73: '<索引文件>'
# '<Line Number>'
H6986C655554D: '<行号>'
# '<Line Number>.<Discriminator>'
H9B952BEB1010: '<行号>.<区分符>'
# '<Line Number>:<Column Number>'
H3D8D3ACA02BF: '<行号>:<列号>'
# '<Line Number>:<Column Number>.<Discriminator> (default)'
HF63B70CCE643: '<行号>:<列号>.<区分符>（默认）'
# '<PROJECT ROOT>'
H49C3DE6F4DBC: '<项目根目录>'
# '<Search Root Directory>'
H6D7091309552: '<搜索根目录>'
# '<Source file>'
H6EC586CC52E3: '<源文件>'
# '<Source files>'
H3C1CECBB7A05: '<源文件>'
# '<arguments to be passed to front end>...'
H60720E11CCAF: '<要传递给前端的参数>...'
# '<base profile file>'
H8C88CD489F08: '<基础配置文件>'
# '<check-file>'
HAFAA29ACBEA3: '<检查文件>'
# '<data file>'
HF37127A33D60: '<数据文件>'
# '<demangler-path>|<demangler-option>'
H7D9510852764: '<解码器路径>|<解码器选项>'
# '<destination>'
H10F397C9B9E7: '<目标路径>'
# '<diagnostic-name>'
H48ABA509B551: '<诊断名称>'
# '<executable>'
H194C8BA9DC59: '<可执行文件>'
# '<fdata1> [<fdata2>]...'
H31B7871CCFAC: '<fdata1> [<fdata2>]...'
# '<filename...>'
HFE7069E9DD18: '<文件名...>'
# '<filename>'
HB80C8D77FF58: '<文件名>'
# '<first file>'
H701B2C95DDEA: '<第一个文件>'
# '<from>,<to> Map coverage data paths to local source file paths'
HA29C275A5689: '<from>,<to> 将覆盖数据路径映射到本地源文件路径'
# '<gcc-tool arguments>...'
H14ED68F16708: '<gcc-tool 参数>...'
# '<globals to compare>'
HDCFEFCD16186: '<要比较的全局变量>'
# '<gpu executable>'
HE3D4861759AD: '<GPU 可执行文件>'
# '<high>,<low> value indicate thresholds for high and lowcoverage watermark'
HEAFB910E7206: '<high>,<low> 值表示高和低覆盖水位阈值'
# '<input .ll file>'
HBDCA7FE10EAC: '<输入.ll文件>'
# '<input IR file>'
H7E82294FE4BC: '<输入IR文件>'
# '<input PDB file>'
H709A48456EF7: '<输入PDB文件>'
# '<input PDB files>'
H126A4B67EBAB: '<输入PDB文件>'
# '<input YAML file>'
H7A7A324B78FC: '<输入YAML文件>'
# '<input bitcode file>'
H0498EDBECDA2: '<输入比特码文件>'
# '<input bitcode files>'
H18F82A53F250: '<输入比特码文件>'
# '<input bitcode>'
HC1462E145577: '<输入比特码>'
# '<input brainf>'
H925565A9DFB3: '<输入brainf文件>'
# '<input file #1>'
H8FA0EC745E89: '<输入文件 #1>'
# '<input file #2>'
H09D1580255E0: '<输入文件 #2>'
# '<input file>'
HC2587AA6902C: '<输入文件>'
# '<input files>'
H9415F263685E: '<输入文件>'
# '<input kernel json file>'
HF85B67BC3727: '<输入内核JSON文件>'
# '<input llvm ll/bc file>'
HC39181A9A624: '<输入 llvm ll/bc 文件>'
# '<input llvm ll/bc files>'
H41A5FA014705: '<输入 llvm ll/bc 文件列表>'
# '<input object files or .dSYM bundles>'
HDA6B96681ECA: '<输入对象文件或.dSYM包>'
# '<input object files>'
HD219B490846E: '<输入对象文件>'
# '<input symbols>'
H45D1386EF577: '<输入符号>'
# '<input toy file>'
H84A385940941: '<输入Toy文件>'
# '<input>'
H89C4EB09495F: '<输入>'
# '<list of one or more header list files>'
H27C475BB767E: '<一个或多个头文件列表文件>'
# '<maxsize>'
H327F70512C50: '<maxsize>'
# '<module summary index>'
HC647DB885E7B: '<模块摘要索引>'
# '<opt arguments>...'
HCE37C5C87525: '<优化参数>...'
# '<output file>'
H44B468338EC5: '<输出文件>'
# '<path to index file | remote:server.address>'
H55C1FC4669FC: '<索引文件路径 | 远程服务器地址>'
# '<profdata-file>'
H83762F3A8AFE: '<profdata文件>'
# '<program arguments>...'
H9648B06044BF: '<程序参数>...'
# '<program to run>'
H9127819F0F1D: '<要运行的程序>'
# '<safe-tool arguments>...'
H5EABB33684C4: '<安全工具参数>...'
# '<second file>'
H59A18696A728: '<第二个文件>'
# '<source0> [... <sourceN>]'
H4D671F64A81C: '<source0> [... <sourceN>]'
# '<source>'
HE6634DF59D09: '<source>'
# "<start line>:<end line> - format a range of\nlines (both 1-based).\nMultiple ranges can be formatted by specifying\nseveral -lines arguments.\nCan't be used with -offset and -length.\nCan only be used with one input file."
HDEA3B9BD2A49: '<起始行>:<结束行> - 格式化行范围（均为 1-based计数）。\n可以通过多个 -lines 参数指定多个范围。\n不能与 -offset 和 -length 一起使用。\n只能用于单个输入文件。'
# '<symbol-file>'
H6E5CDBA6FB29: '<符号文件>'
# '<test profile file>'
H11468CAF4D7F: '<测试配置文件>'
# '<tool arguments>...'
HF6F458922E63: '<工具参数>...'
# '<topdown|bottomup>'
H9180E4B0E8C6: '<topdown|bottomup>'
# '<weight>,<filename>'
HCEE927C66E78: '<权重>,<文件名>'
# '<xray fdr mode log>'
H4907FD73C66B: '<XRay FDR模式日志>'
# '<xray log file 1>'
HB4D281AAED36: '<XRay日志文件 1>'
# '<xray log file 2>'
H1C142C095FCF: '<XRay日志文件 2>'
# '<xray log file>'
HE9A7E93A5C35: '<XRay日志文件>'
# '<xray trace>'
HA7901FE618F5: '<XRay跟踪>'
# '= *cannot print option value*\n'
HE274379BF9C1: '= *无法打印选项值*\n'
# '= *unknown option value*\n'
H164C5812BA3B: '= *未知的选项值*\n'
# '?: operator with omitted middle operand cannot be mangled'
H3E44EE9DABB8: '?: 操作符省略中间操作数时无法进行名称编码'
# '@%0 must be followed by a number to form an NSNumber object'
HDF1E414372F2: '@%0 必须后跟数字以形成 NSNumber 对象'
# "@catch parameter cannot have storage specifier '%0'"
HAEB289D52AD8: "@catch 参数不能使用存储说明符 '%0'"
# '@catch parameter declarator cannot be qualified'
H9BAC8F95B81C: '@catch 参数说明符不能带有限定符'
# '@catch parameter is not a pointer to an interface type'
HE87FCFF30D0A: '@catch 参数不是接口类型的指针'
# '@defs is not supported in Objective-C++'
H64B526C3172C: '@defs 在 Objective-C++ 中不受支持'
# '@implementation cannot have type parameters'
HA936A031AC88: '@implementation 不能包含类型参数'
# '@implementation declaration cannot be protocol qualified'
H4CA986D1E0F8: '@implementation 声明不能带有协议限定符'
# "@import of module '%0' in implementation of '%1'; use #import"
H16AC87FD7968: "@import 模块 '%0' 在 '%1' 的实现中使用；请改用 #import"
# '@protocol is using a forward protocol declaration of %0'
H0D6847EE9BAD: '@protocol 使用了 %0 的前向协议声明'
# '@selector expression formed with direct selector %0'
HB5C475EA47ED: '@selector 表达式使用直接选择子 %0'
# '@selector expression formed with potentially direct selector %0'
H7FC0DE89B5F4: '@selector 表达式使用潜在直接选择子 %0'
# '@synchronized requires an Objective-C object type (%0 invalid)'
H4E94A0FBFD2A: '@synchronized 需要 Objective-C 对象类型 (%0 无效)'
# "@synthesize not allowed in a category's implementation"
HAD49CB90931E: '@synthesize 不允许在分类的实现中使用'
# '@synthesize not allowed on a class property %0'
H37538A67AC33: '@synthesize 不允许用于类属性 %0'
# '@throw (rethrow) used outside of a @catch block'
HAB2C03614B94: '@throw (重新抛出) 未在 @catch 块中使用'
# '@throw requires an Objective-C object type (%0 invalid)'
HF85FCC60471E: '@throw 需要 Objective-C 对象类型 (%0 无效)'
# '@try statement without a @catch and @finally clause'
H0097E9BE678E: '@try 语句缺少 @catch 和 @finally 子句'
# 'A CSV file containing (JITDylib, Function) pairs tospeculatively look up'
H27E7912AA129: '包含（JITDylib, Function）对的CSV文件，用于推测性查找'
# 'A No-Op Barrier Pass'
H189EA9AAB8E2: '无操作屏障Pass'
# 'A boolean option to show CFG dag or text with block profile counts and branch probabilities right after PGO profile annotation step. The profile counts are computed using branch probabilities from the runtime profile data and block frequency propagation algorithm. To view the raw counts from the profile, use option -pgo-view-raw-counts instead. To limit graph display to only one function, use filtering option -view-bfi-func-name.'
H1F6AD91CDAD1: '一个布尔选项，用于在PGO配置文件标注步骤后显示CFG图或文本，显示带有块频次计数和分支概率的控制流图。频次计数通过运行时配置文件中的分支概率和块频率传播算法计算得出。若要查看原始配置文件计数，请改用 -pgo-view-raw-counts 选项。若要限制仅显示某个函数的图，可使用过滤选项 -view-bfi-func-name。'
# 'A boolean option to show CFG dag or text with raw profile counts from profile data. See also option -pgo-view-counts. To limit graph display to only one function, use filtering option -view-bfi-func-name.'
H84462D2AF2CA: '一个布尔选项，用于显示从配置文件数据中获取原始频次计数的CFG图或文本。另请参阅 -pgo-view-counts 选项。若要限制仅显示某个函数的图，可使用过滤选项 -view-bfi-func-name。'
# 'A comma-separated list of regexes to match against suffix of a header, and disable analysis if matched.'
HC652CCDF0460: '以逗号分隔的正则表达式列表，用于匹配头文件后缀。若匹配则禁用分析。'
# 'A comma-separated list of regexes to match against suffix of a header. Only headers that match will be analyzed.'
H98978B75D13A: '以逗号分隔的正则表达式列表，用于匹配头文件后缀。仅分析匹配的头文件。'
# 'A count is cold if it is below the minimum count to reach this percentile of total counts.'
H2339A8FDD5A8: '若计数低于达到总计数该百分位所需的最小值，则计数视为冷计数。'
# 'A count is hot if it exceeds the minimum count to reach this percentile of total counts.'
H7D01FE9FC1EB: '若计数超过达到总计数该百分位所需的最小值，则计数视为热计数。'
# 'A debug option to add additional penalty to the computed one.'
H2D6A17BDE0D3: '一个调试选项，用于向计算出的惩罚值添加额外惩罚。'
# 'A file containing a list of files to process, one per line.'
H3723DB39ACD6: '一个包含要处理的文件列表的文件，每行一个。'
# 'A file containing list of basic blocks to extract'
HBF68C649BA33: '一个包含要提取的基本块列表的文件'
# 'A file containing list of symbol names to preserve'
HCBA362E0A436: '一个包含要保留的符号名称列表的文件'
# 'A file containing regexes of symbol names that are not expected to be updated when changing namespaces around them.'
HE689FDC11988: '一个包含符号名称正则表达式的文件，这些符号名称在周围命名空间更改时不会被更新。'
# 'A file in which to write minimized bitcode for the thin link only'
HC50A535724B5: '仅用于薄链接的最小化比特码的写入文件'
# 'A fixed cold count that overrides the count derived from profile-summary-cutoff-cold'
H6BD0A927E583: '一个固定冷计数，覆盖由profile-summary-cutoff-cold导出的计数值'
# 'A fixed hot count that overrides the count derived from profile-summary-cutoff-hot'
HDDA22CC4FF28: '一个固定热计数，覆盖由profile-summary-cutoff-hot导出的计数值'
# "A flag that overrides the target's expected cost for an instruction to a single constant value. Mostly useful for getting consistent testing."
HB9C94533EB20: '覆盖目标期望指令成本的标志，将其设置为单一固定值。主要用于获得一致的测试结果。'
# "A flag that overrides the target's max interleave factor for scalar loops."
H8C8153E64ADB: '覆盖目标标量循环的最大交织因子的标志。'
# "A flag that overrides the target's max interleave factor for vectorized loops."
H3505D260BD96: '覆盖目标向量化循环的最大交织因子的标志。'
# "A flag that overrides the target's number of scalar registers."
HFF8F958A02D3: '覆盖目标标量寄存器数量的标志。'
# "A flag that overrides the target's number of vector registers."
HEC99B1D21B33: '覆盖目标向量寄存器数量的标志。'
# "A flag that overrides the target's preferred addressing mode."
H7B1AA7CE93D4: '覆盖目标首选寻址模式的标志。'
# 'A function is considered hot for staleness error check if its total sample count is above the specified percentile'
H652DA545BF0D: '如果函数的总样本计数超过指定的百分位数，则认为该函数为热点函数'
# 'A function name, assumed to be global, which will be treated as the root of an interesting graph, which will be profiled independently from other similar graphs.'
H3FD0C1E415AD: '一个假设为全局的函数名称，将被视为有趣图的根节点，并与其他类似图独立进行分析。'
# 'A huge scheduling region will have maps reduced by this many nodes at a time. Defaults to HugeRegion / 2.'
HAEEA6B54FAD5: '巨大的调度区域每次会减少这么多节点的地图。默认值为HugeRegion / 2。'
# 'A key=value pair. Replace __nvvm_reflect(name) with value.'
H3D02297FABD7: '键值对。用值替换__nvvm_reflect(name)'
# 'A lexical block (Function, Class, etc.).'
HC41EB530ACBA: '词法块（函数、类等）。'
# "A list of mangled vtable type info names. Classes specified by the type info names and their derived ones will not be vtable-ICP'ed. Useful when the profiled types and actual types in the optimized binary could be different due to profiling limitations. Type info names are those string literals used in LLVM type metadata"
HB3A60F3783C6: '混淆的vtable类型信息名称列表。由类型信息名称指定的类及其派生类将不会被vtable-ICP化。当由于性能分析限制导致性能分析类型和优化二进制中的实际类型不同时，这很有用。类型信息名称是LLVM类型元数据中使用的字符串字面量'
# 'A list of symbol names to preserve'
HC033F70F7A4D: '一个包含要保留的符号名称列表的文件'
# "A multiplier on top of cycle savings to decide whether the savings won't justify the cost"
H6A89F885E7F6: '在循环节省上乘以该系数，以决定节省是否不足以抵消成本'
# "A string that'll be prepended to all log statements. Useful when running multiple instances on same host."
HE0B8D8E429AE: '附加到所有日志语句前的字符串。在相同主机上运行多个实例时很有用。'
# 'A textual (comma separated) description of the pass pipeline e.g.,-passes="foo,bar", to have analysis passes available before a pass, add "require<foo-analysis>". See https://llvm.org/docs/NewPassManager.html#invoking-opt for more details on the pass pipeline syntax. '
HB4D744456DA4: 'pass管线的文本格式（逗号分隔）描述，例如：-passes="foo,bar"。若希望在某个pass前启用分析pass，请添加 "require<foo-analysis>"。关于pass管线语法的更多细节请参考 https://llvm.org/docs/NewPassManager.html#invoking-opt'
# 'A textual description of the alias analysis pipeline for handling managed aliasing queries'
H4D54EF8DEC89: '处理托管别名查询的别名分析管线的文本描述'
# 'A textual description of the cgscc pass pipeline inserted at the CGSCCOptimizerLate extension point into default pipelines'
HFA3CF56CCD45: '插入到默认管线中CGSCCOptimizerLate扩展点的cgscc pass管线的文本描述'
# 'A textual description of the function pass pipeline inserted at the Peephole extension points into default pipelines'
H1744F3F7F9B4: '插入到默认管线中Peephole扩展点的函数pass管线的文本描述'
# 'A textual description of the function pass pipeline inserted at the ScalarOptimizerLate extension point into default pipelines'
HA2E18C3D97E7: '插入到默认管线中ScalarOptimizerLate扩展点的函数pass管线的文本描述'
# 'A textual description of the function pass pipeline inserted at the VectorizerEnd extension point into default pipelines'
HD2BE547AE303: '插入到默认管线中VectorizerEnd扩展点的函数pass管线的文本描述'
# 'A textual description of the function pass pipeline inserted at the VectorizerStart extension point into default pipelines'
HA843C3B1B6F5: '插入到默认管线中VectorizerStart扩展点的函数pass管线的文本描述'
# 'A textual description of the loop pass pipeline inserted at the LateLoopOptimizations extension point into default pipelines'
H081E56CD31AA: '插入到默认管线中LateLoopOptimizations扩展点的循环pass管线的文本描述'
# 'A textual description of the loop pass pipeline inserted at the LoopOptimizerEnd extension point into default pipelines'
HFDB774C5E68A: '插入到默认管线中LoopOptimizerEnd扩展点的循环pass管线的文本描述'
# 'A textual description of the module pass pipeline inserted at the EarlySimplification extension point into default pipelines'
HADF08723EA0B: '插入到默认管线中EarlySimplification扩展点的模块pass管线的文本描述'
# 'A textual description of the module pass pipeline inserted at the FullLinkTimeOptimizationEarly extension point into default pipelines'
HBAAC4BEB26E7: '插入到默认管线中FullLinkTimeOptimizationEarly扩展点的模块pass管线的文本描述'
# 'A textual description of the module pass pipeline inserted at the FullLinkTimeOptimizationLast extension point into default pipelines'
HC7A2BAD76212: '插入到默认管线中FullLinkTimeOptimizationLast扩展点的模块pass管线的文本描述'
# 'A textual description of the module pass pipeline inserted at the OptimizerEarly extension point into default pipelines'
H556744FF114A: '插入到默认管线中OptimizerEarly扩展点的模块pass管线的文本描述'
# 'A textual description of the module pass pipeline inserted at the OptimizerLast extension point into default pipelines'
H97AB14D6A40C: '插入到默认管线中OptimizerLast扩展点的模块pass管线的文本描述'
# 'A textual description of the module pass pipeline inserted at the PipelineStart extension point into default pipelines'
H5D27DE009EB3: '插入到默认管线中PipelineStart扩展点的模块pass管线的文本描述'
# 'A textual description of the pass pipeline for testing'
H07C815591653: '测试用的pass管线的文本描述'
# "A textual description of the pass pipeline, same as what's passed to `opt -passes`."
HAD654D568007: '与`opt -passes`传递的内容相同的pass管线的文本描述'
# "A textual description of the pass pipeline. To have analysis passes available before a certain pass, add 'require<foo-analysis>'."
HB92573A0FB9B: "pass管线的文本描述。要在某个pass之前提供分析pass，请添加 'require<foo-analysis>'。"
# "A textual description of the pass pipeline. To have analysis passes available before a certain pass, add 'require<foo-analysis>'. '-passes' overrides the pass pipeline (but not all effects) from specifying '--opt-level=O?' (O2 is the default) to clang-linker-wrapper.  Be sure to include the corresponding 'default<O?>' in '-passes'."
H4608F37A5D56: 'pass管线的文本描述。要在某个pass之前提供分析pass，请添加\'require<foo-analysis>\'。"-passes" 会覆盖clang-linker-wrapper中通过指定 "--opt-level=O?"（默认O2）设置的pass管线（但并非所有效果）。请确保在 "-passes" 中包含对应的 "default<O?>"。'
# 'A threshold controls whether an indirect call will be specialized'
HE03B79F00E10: '一个阈值控制间接调用是否会被特化'
# 'A threshold of live range size which may cause high compile time cost in global splitting.'
H1C364B861BCF: '可能导致全局分割时编译时间成本过高的活范围大小阈值'
# 'A throughput of the processor floating-point arithmetic units expressed in the number of vector fused multiply-add instructions per clock cycle.'
H419471CCE4DF: '处理器浮点运算单元的吞吐量，以每时钟周期向量融合乘加指令数量表示'
# 'A tile size for each loop dimension, filled with --polly-default-tile-size'
H104573A3D1B6: '每个循环维度的块大小，使用--polly-default-tile-size填充'
# 'A tile size for each loop dimension, filled with --polly-register-tile-size'
H8DEB87E7711B: '每个循环维度的块大小，使用--polly-register-tile-size填充'
# 'A tool to bundle several input files of the specified type <type> \nreferring to the same source file but different targets into a single \none. The resulting file can also be unbundled into different files by \nthis tool if -unbundle is provided.\n'
HD409DEDBF7C5: '用于将指定类型 <type> 的多个输入文件（这些文件对应同一源文件但针对不同目标）捆绑为一个文件的工具。如果提供了 -unbundle 参数，该工具还可以将结果文件解捆为不同的文件。\n'
# 'A tool to detect the presence of offloading devices on the system. \n\nThe tool will output each detected GPU architecture separated by a\nnewline character. If multiple GPUs of the same architecture are found\na string will be printed for each\n'
H1DF8966C5917: '检测系统中存在的卸载设备的工具。\n\n该工具将用换行符分隔每个检测到的GPU架构输出。如果发现多个相同架构的GPU，将为每个GPU打印字符串\n'
# 'A tool to format C/C++/Java/JavaScript/JSON/Objective-C/Protobuf/C# code.\n\nIf no arguments are specified, it formats the code from standard input\nand writes the result to the standard output.\nIf <file>s are given, it reformats the files. If -i is specified\ntogether with <file>s, the files are edited in-place. Otherwise, the\nresult is written to the standard output.\n'
HBD33E3D62435: '用于格式化C/C++/Java/JavaScript/JSON/Objective-C/Protobuf/C#代码的工具。\n\n如果未指定任何参数，它将从标准输入读取代码并输出到标准输出。如果指定了 <file>s，则会重新格式化这些文件。如果同时指定了 -i 和 <file>s，文件将被就地编辑。否则，结果将写入标准输出。\n'
# 'A tool to generate an optimization report from YAML optimization record files.\n'
HACA86A981224: '用于从YAML优化记录文件生成优化报告的工具。\n'
# 'A utility for bundling several object files into a single binary.\nThe output binary can then be embedded into the host section table\nto create a fatbinary containing offloading code.\n'
H87DB5533D231: '用于将多个对象文件捆绑到单个二进制文件中的实用工具。\n输出的二进制文件可以嵌入到主机的节表中，以创建包含卸载代码的fatbinary。\n'
# 'A utility used to launch unit tests built for a GPU target. This is\nintended to provide an intrface simular to cross-compiling emulators\n'
H43DC1BE6F67F: '用于启动为GPU目标构建的单元测试的实用工具。旨在提供与交叉编译模拟器相似的接口\n'
# 'AArch64 A57 FP Load-Balancing'
H89C796F20C61: 'AArch64 A57 浮点负载均衡'
# 'AArch64 Assembly Printer'
H149E1B5ADAFC: 'AArch64汇编打印程序'
# 'AArch64 Branch Targets'
H9304B7C9D5D8: 'AArch64 分支目标'
# 'AArch64 CCMP Pass'
HD86F88A4A107: 'AArch64 CCMP Pass'
# 'AArch64 CondOpt Pass'
H57677EA713E0: 'AArch64 条件优化Pass'
# 'AArch64 Conditional Branch Tuning'
H22AFD058BC38: 'AArch64 条件分支优化'
# 'AArch64 Dead register definitions'
HDD34EEF0A0FD: 'AArch64 死寄存器定义'
# 'AArch64 Instruction Selection'
H5E1BF7DD5E18: 'AArch64 指令选择'
# 'AArch64 Local Dynamic TLS Access Clean-up'
H60D83F556D1C: 'AArch64 本地动态 TLS 访问清理'
# 'AArch64 MI Peephole Optimization'
H5CB8022D53B1: 'AArch64 MI 窥孔优化'
# 'AArch64 Pointer Authentication'
H3B42C021D00A: 'AArch64 指针认证'
# 'AArch64 Post Coalescer Pass'
H06C95CD832E0: 'AArch64 后合并Pass'
# 'AArch64 Promote Constant Pass'
H70B4D04F132C: 'AArch64 常量提升Pass'
# 'AArch64 SIMD instructions optimization pass'
H407FCE4191EB: 'AArch64 SIMD 指令优化pass'
# 'AArch64 Stack Tagging'
HE4582C5513D0: 'AArch64 栈标记'
# 'AArch64 Stack Tagging PreRA Pass'
H576B6E1D60C6: 'AArch64 堆栈标记预RA Pass'
# 'AArch64 Store Pair Suppression'
HD68B4FD8992D: 'AArch64 存储对抑制'
# 'AArch64 compress jump tables pass'
HB1CD15516755: 'AArch64 跳转表压缩 pass'
# 'AArch64 fix for A53 erratum 835769'
HBBD9D2E5295C: 'AArch64 修复 A53 错误 835769'
# 'AArch64 homogeneous prolog/epilog lowering pass'
H2B5E843A360C: 'AArch64 同质化函数头/尾下层转换pass'
# 'AArch64 load / store optimization pass'
HC1E1B5661C2B: 'AArch64 加载/存储优化pass'
# 'AArch64 pseudo instruction expansion pass'
H39C8B02C1D58: 'AArch64 伪指令扩展pass'
# 'AArch64 redundant copy elimination pass'
HAEB13D1AFB9C: 'AArch64冗余复制消除pass'
# 'AArch64 sls hardening pass'
H988D224CDB63: 'AArch64 sls 安全强化pass'
# 'AArch64 speculation hardening pass'
H7D2AB26196EE: 'AArch64 投机执行安全强化pass'
# 'AArch64Arm64ECCallLowering'
H73581D76FB10: 'AArch64Arm64EC 调用降级'
# "ABI '%0' is not supported for '%1'"
H7FF392C86EBF: "ABI '%0' 不支持 '%1' 的使用"
# "ABI '%0' is not supported on CPU '%1'"
H1189F24D3D62: "ABI '%0' 在 CPU '%1' 上不受支持"
# 'AIX PPC Assembly Printer'
H954F34380A8A: 'AIX PPC汇编打印程序'
# 'AMD vector math library'
HA177FC4B0F5A: 'AMD向量数学库'
# 'AMDGPU Address space based Alias Analysis'
HEE464CD5CFF9: 'AMDGPU 基于地址空间的别名分析'
# 'AMDGPU Address space based Alias Analysis Wrapper'
HA70F43663430: 'AMDGPU 基于地址空间的别名分析包装器'
# 'AMDGPU Assembly Printer'
HFD4F4422703F: 'AMDGPU汇编打印程序'
# 'AMDGPU Attributor'
HB96C03301054: 'AMDGPU 属性分析器'
# 'AMDGPU CFG Structurizer'
HFAE00DA66175: 'AMDGPU CFG结构化'
# 'AMDGPU DAG->DAG Pattern Instruction Selection'
H1C6011A1E507: 'AMDGPU DAG->DAG模式指令选择'
# 'AMDGPU GlobalISel divergence lowering'
H60A2AE965388: 'AMDGPU GlobalISel 分支降低优化'
# 'AMDGPU IR late optimizations'
H2A662801978F: 'AMDGPU IR 后期优化'
# 'AMDGPU IR optimizations'
H6CEDA43B5424: 'AMDGPU IR 优化'
# 'AMDGPU Image Intrinsic Optimizer'
H28FFA260019F: 'AMDGPU 图像内建函数优化器'
# 'AMDGPU Inline All Functions'
HFBEEFEAD43D4: 'AMDGPU 内联所有函数'
# 'AMDGPU Insert Delay ALU'
HD712301B82FE: 'AMDGPU 插入延迟 ALU'
# 'AMDGPU Insert waits for SGPR read hazards'
H3CE801DC5FBE: 'AMDGPU 插入等待以处理 SGPR 读取冲突'
# 'AMDGPU Kernel Attributes'
H5B736779332B: 'AMDGPU 内核属性'
# 'AMDGPU Lower Kernel Arguments'
H345C5C7C45FB: 'AMDGPU 内核参数转换'
# 'AMDGPU Mark last scratch load'
H570A9C93F411: 'AMDGPU 标记最后一个显存加载'
# 'AMDGPU Pre-RA Long Branch Reg'
HF352DB9ED395: 'AMDGPU 寄存器分配前长跳转寄存器处理'
# 'AMDGPU Pre-RA optimizations'
HB1D166D82990: 'AMDGPU 寄存器分配前优化'
# 'AMDGPU Preload Kernel Arguments'
H8AF72F195656: 'AMDGPU预加载内核参数'
# 'AMDGPU Preload Kernel Arguments Prolog'
HA4C7048C1EF3: 'AMDGPU 预加载内核参数前导代码'
# 'AMDGPU Printf lowering'
H9F0BCA780CE7: 'AMDGPU Printf下层转换'
# 'AMDGPU Promote Kernel Arguments'
HAD6BF4A8858C: 'AMDGPU 内核参数提升'
# 'AMDGPU Register Bank Legalize'
HD913B83CEA2C: 'AMDGPU 寄存器组合法化'
# 'AMDGPU Register Bank Select'
H910A7C3E575C: 'AMDGPU 寄存器组选择'
# 'AMDGPU Remove Incompatible Functions'
H697AE5C583A4: 'AMDGPU 移除不兼容函数'
# 'AMDGPU Reserve WWM Registers'
H9CD9A7466F8D: 'AMDGPU 预留 WWM 寄存器'
# 'AMDGPU Rewrite Out Arguments'
H1EE5CA590389: 'AMDGPU 重写输出参数'
# 'AMDGPU Software lowering of LDS'
H06C3E98E4BA5: 'AMDGPU 软件LDS下层转换'
# 'AMDGPU atomic optimizations'
HD4C4B30A81C8: 'AMDGPU 原子操作优化'
# 'AMDGPU promote alloca to vector'
H76A58E341CF5: 'AMDGPU 将alloca提升为向量'
# 'AMDGPU promote alloca to vector or LDS'
H505D453A0AB0: 'AMDGPU 将alloca提升为向量或LDS'
# 'ANALYSIS'
HB0D5F3D274BF: '分析'
# 'ANALYSIS_ALIASING'
H652422606A7D: '别名分析'
# 'ANALYSIS_FP_COMMUTE'
H5B6E5D0BD096: '浮点运算交换分析'
# 'API notes replacement type %0 has a different size from original type %1'
HB87A25B6CDE7: 'API注释中的替换类型 %0 与原始类型 %1 的大小不同'
# 'ARC %select{unused|__unsafe_unretained|__strong|__weak|__autoreleasing}0 lifetime qualifier on return type is ignored'
H4E4E8ED8984D: 'ARC忽略返回类型上的%select{未使用的|__unsafe_unretained|__strong|__weak|__autoreleasing}0 生命周期限定符'
# 'ARC Assmebly Printer'
H528084674BCB: 'ARC汇编打印程序'
# 'ARC DAG->DAG Pattern Instruction Selection'
H40C54AF1B605: 'ARC DAG->DAG 模式指令选择'
# 'ARC finalize branches'
H275EE97FB8AE: 'ARC 最终化分支'
# 'ARC forbids %select{implementation|synthesis}0 of %1'
HC91D535AD424: 'ARC禁止%select{实现|合成}0 %1'
# 'ARC forbids explicit message send of %0'
H35558B925DCC: 'ARC禁止显式发送 %0 消息'
# 'ARC forbids flexible array members with retainable object type'
HBA6CEB1E81A4: 'ARC禁止使用可保留对象类型的柔性数组成员'
# 'ARC forbids synthesizing a property of an Objective-C object with unspecified ownership or storage attribute'
H8E9C79FD3192: 'ARC禁止合成一个未指定所有权或存储属性的Objective-C对象属性'
# 'ARC forbids use of %0 in a @selector'
H9E100CA24C33: 'ARC禁止在@selector中使用 %0'
# 'ARM Assembly Printer'
H821520E8B386: 'ARM汇编打印程序'
# 'ARM Branch Targets'
H320FDCF5D874: 'ARM 分支目标'
# 'ARM EHABI exceptions'
HF924BFE7B7BB: 'ARM EHABI 异常处理'
# 'ARM Execution Domain Fix'
H8BB9925360D9: 'ARM 执行域修复'
# 'ARM Instruction Selection'
HD4C5D9A9956F: 'ARM 指令选择'
# 'ARM Low Overhead Loops pass'
HF8B8270CD0E0: 'ARM 低开销循环pass'
# 'ARM MVE TailPred and VPT Optimisations pass'
HE6A4A21F0251: 'ARM MVE 尾预测和VPT优化Pass'
# 'ARM MVE VPT block pass'
HE579D00C5557: 'ARM MVE VPT块pass'
# 'ARM block placement'
HE7AFE256FA69: 'ARM 块布局'
# 'ARM constant island placement and branch shortening pass'
H12503A372FDC: 'ARM 常量岛放置和分支缩短pass'
# 'ARM fix for Cortex-A57 AES Erratum 1742098'
HFB722C2D2741: 'ARM 修复Cortex-A57 AES错误 1742098'
# 'ARM load / store optimization pass'
HFAD45B23E308: 'ARM 加载/存储优化pass'
# 'ARM pre- register allocation load / store optimization pass'
HAF68B491BF25: 'ARM 寄存器分配前加载/存储优化pass'
# 'ARM pseudo instruction expansion pass'
H77670EF47A4C: 'ARM 伪指令扩展pass'
# 'ARM sls hardening pass'
H7DDE5DF1D5E8: 'ARM sls 安全强化pass'
# 'AST and IR generation'
H9BC428E8F3F3: '抽象语法树（AST）和中间表示（IR）生成'
# 'AVR Assembly Printer'
HEC272DC617AD: 'AVR汇编打印程序'
# 'AVR DAG->DAG Instruction Selection'
H8D3BB39761E3: 'AVR DAG->DAG 指令选择'
# 'AVR Shift Expansion'
HB0A514A46417: 'AVR 移位扩展'
# 'AVR pseudo instruction expansion pass'
H957B71DEFB30: 'AVR 伪指令扩展pass'
# "AVX vector %select{return|argument}0 of type %1 without '%2' enabled changes the ABI"
HA1797A0B7AA1: 'AVX向量 %select{return|argument}0 的类型 %1 在未启用 %2 时会改变ABI'
# 'Abbreviation for -input-style=delimited -pretty -log=verbose. Intended to simplify lit tests'
H80629E8FC6D8: '缩写形式：-input-style=delimited -pretty -log=verbose。用于简化lit测试'
# 'Abort if an isl error is encountered'
HA9BB62CCA982: '遇到isl错误时终止'
# 'Abort if any reduction results in invalid IR'
HE190E2B8E3A2: '当任何规约导致无效IR时终止'
# 'Abort when the max iterations for devirtualization CGSCC repeat pass is reached'
H625080B5E512: '当虚函数调用优化CGSCC重复遍历的最大迭代次数达到时终止'
# 'Absolute error tolerated'
H0DDBDDDD2804: '允许的绝对误差'
# 'Abstract subprograms'
HE11B4671C4D0: '抽象子程序'
# 'Accelerate framework'
HC4987E7BA17F: '加速框架'
# 'Accept a PCH file that was created with a different modules cache path'
H30FC52342749: '接受由不同模块缓存路径创建的PCH文件'
# 'Accept a PCH file that was created with compiler errors'
H3D9D9492A95B: '接受由编译器错误生成的PCH文件'
# 'Accept a PCM file that was created with compiler errors'
H491D98E75DB9: '接受由编译器错误生成的PCM文件'
# 'Accept in ARM, reject in Thumb'
H947CDAFC2217: '在ARM中接受，在Thumb中拒绝'
# 'Accept in both ISAs, emit implicit ITs in Thumb'
H1A576FCAF9D9: '在两个指令集架构中接受，在Thumb中隐式生成IT指令'
# 'Accept non-standard constructs supported by the Borland compiler'
HA22BD3681EC1: '接受Borland编译器支持的非标准语法'
# 'Accept some non-standard constructs supported by the Microsoft compiler'
HECEF41C80814: '接受Microsoft编译器支持的部分非标准语法'
# 'Accept some non-standard constructs supported by the z/OS compiler'
H043675240BDC: '接受z/OS编译器支持的部分非标准语法'
# 'Access dynamic shadow through an ifunc global on platforms that support this'
HB6225A3E2790: '在支持的平台上通过ifunc全局访问动态阴影'
# 'Act like old LiveDebugValues did'
HFD5F11157A46: '模拟旧版LiveDebugValues的行为'
# 'Action to perform on deprecated def'
H5D2AEBD499B4: '对已弃用的定义执行的操作：'
# 'Action to perform:'
H0985CD6D5E8B: '执行的操作：'
# 'Add !range metadata to NVVM intrinsics.'
H210E13100D6D: '为 NVVM 内建函数添加 !range 元数据'
# 'Add -rpath with architecture-specific resource directory to the linker flags. When --hip-link is specified, also add -rpath with HIP runtime library directory to the linker flags'
H0E7215A9DCD3: '向链接器标志添加包含架构特定资源目录的-rpath参数。当指定--hip-link时，也添加包含HIP运行时库目录的-rpath参数'
# 'Add .note.gnu.property with BTI to assembly files'
HD58C1F70322E: '向汇编文件添加包含BTI的.note.gnu.property注释'
# 'Add .note.gnu.property with BTI to assembly files (AArch64 only)'
H497BB320D249: '在汇编文件中添加包含BTI的.note.gnu.property节（仅AArch64）'
# 'Add <dir> to system include search path, as if in %INCLUDE%'
H8CB70533A0CD: '将 <dir> 添加到系统包含搜索路径，如同在%INCLUDE%中定义'
# 'Add AMDGPU uniform metadata'
HE950C74F7CBF: '添加AMDGPU统一元数据'
# 'Add C++ implicit destructors to CFGs for all analyses'
H7BE6C1575B4A: '为所有分析的控制流图添加C++隐式析构函数'
# 'Add Contextual/Debug comments to all C++ predicates'
H23C6808D6E2D: '为所有C++谓词添加上下文/调试注释'
# 'Add DW_AT_linkage_name to function declaration DIEs referenced by DW_AT_call_origin attributes. Enabled by default for -gsce debugger tuning.'
H71407E50301C: '为通过DW_AT_call_origin属性引用的函数声明DIE添加DW_AT_linkage_name。默认启用-gsce调试器优化时。'
# 'Add MIR Flow Sensitive Discriminators'
H2C6CDC724E3F: '添加MIR流敏感判别器'
# 'Add OpenCL builtin function declarations (experimental)'
HC7FA758DA63E: '添加OpenCL内建函数声明（实验性功能）'
# 'Add TBAA tags to direct variables'
HAAED7844B106: '为直接变量添加TBAA标签'
# 'Add TBAA tags to dummy arguments'
H3C7A729C0FA0: '为虚拟参数添加TBAA标签'
# 'Add TBAA tags to global variables'
HE3F5E682DA95: '为全局变量添加TBAA标签'
# 'Add TBAA tags to local allocations.'
H4C0FDC192CCF: '向局部分配添加TBAA标签'
# 'Add __emutls_[vt]. variables for emultated TLS model'
H0F84398949DD: '为模拟的TLS模型添加__emutls_[vt].变量'
# 'Add a call to __hwasan_add_frame_record for storing into the stack ring buffer'
H42AEFE2097E5: '在堆栈环形缓冲区中添加对__hwasan_add_frame_record的调用以进行存储'
# 'Add a note for each bug report to denote their analysis entry points'
H540B9CECB600: '为每个错误报告添加注释以标注其分析入口点'
# "Add a preheader to a hardware loop if one doesn't exist"
H90D8EF6E5EFA: '如果不存在硬件循环前导，则添加前导'
# "Add an attribute to a function. This can be a pair of 'function-name:attribute-name', to apply an attribute to a specific function. For example -force-attribute=foo:noinline. Specifying only an attribute will apply the attribute to every function in the module. This option can be specified multiple times."
H025869CF3D3D: "向函数添加属性。 这可以是'函数名:属性名'的配对形式，用于为特定函数应用属性。例如 -force-attribute=foo:noinline。仅指定属性名会将该属性应用到模块中的每个函数。此选项可多次指定。"
# 'Add an implicit negative check with this pattern to every\npositive check. This can be used to ensure that no instances of\nthis pattern occur which are not matched by a positive pattern'
H9C46F681BD1E: '为每个正检查添加此模式的隐式负检查。 这可用于确保没有未被正模式匹配的该模式实例'
# 'Add block information to the output of -streams'
H31B10635B121: '为-streams输出添加块信息'
# 'Add comments to directives.'
HB60639F27CEA: '向指令添加注释。'
# 'Add cs prefix to call and jmp to indirect thunk'
HF4B763BF676A: '在间接跳转指令前添加cs前缀'
# 'Add debug loc information when generating tables for '
HFC939A7BE90F: '生成表时添加调试位置信息'
# 'Add dependent library'
H340E932EB390: '添加相关库'
# 'Add dir to the list of library search paths'
HAF0260DD25B2: '将目录添加到库搜索路径列表'
# 'Add directory to AFTER include search path'
HC2FABF8EF08B: '将目录添加到后置包含搜索路径'
# 'Add directory to QUOTE include search path'
H24E806E38760: '添加目录到QUOTE包含搜索路径'
# 'Add directory to SYSTEM framework search path'
H8A929D35C6A7: '添加目录到SYSTEM框架搜索路径'
# 'Add directory to SYSTEM framework search path, absolute paths are relative to -isysroot'
H690B2B7E95FE: '添加目录到SYSTEM框架搜索路径，绝对路径相对于-isysroot'
# 'Add directory to SYSTEM include search path'
H87F8A546FC28: '添加目录到SYSTEM包含搜索路径'
# 'Add directory to SYSTEM include search path, absolute paths are relative to -isysroot'
HCAEDF5228592: '添加目录到SYSTEM包含搜索路径，绝对路径相对于-isysroot'
# 'Add directory to embed search path'
H6605669711E5: '添加目录到嵌入式搜索路径'
# 'Add directory to end of the SYSTEM include search path'
HD7B48A7E62C9: '将目录添加到SYSTEM包含搜索路径的末尾'
# 'Add directory to framework include search path'
H18A8E8D0F71C: '添加目录到框架包含搜索路径'
# 'Add directory to include search path'
H8E2DBDC224AD: '添加目录到包含搜索路径'
# 'Add directory to include search path with warnings suppressed'
H3D1B9139D392: '添加目录到包含搜索路径并抑制警告'
# 'Add directory to library search path'
H7382A4AE54AB: '添加目录到库搜索路径'
# 'Add directory to the API notes search path referenced by module name'
H15347B13D121: '通过模块名称引用添加目录到API notes搜索路径'
# 'Add directory to the C SYSTEM include search path'
H04DB229B7703: '添加目录到C语言SYSTEM包含搜索路径'
# 'Add directory to the C++ SYSTEM include search path'
H99AF1D3B47BB: '添加目录到C++语言SYSTEM包含搜索路径'
# 'Add directory to the ObjC SYSTEM include search path'
H4AD0218E28C9: '添加目录到Objective-C语言SYSTEM包含搜索路径'
# 'Add directory to the ObjC++ SYSTEM include search path'
H4E8397371575: '添加目录到Objective-C++语言SYSTEM包含搜索路径'
# 'Add directory to the end of the list of include search paths'
HA9C01D5A6394: '将目录添加到包含搜索路径列表的末尾'
# "Add directory to the internal system framework search path; these are assumed to not be user-provided and are used to model system and standard frameworks' paths."
H52CD13889F28: '将目录添加到内部系统框架搜索路径；这些路径假设不是用户提供的，并用于模拟系统和标准框架的路径'
# 'Add directory to the internal system include search path with implicit extern "C" semantics; these are assumed to not be user-provided and are used to model system and standard headers\' paths.'
HA6F738C6C497: '添加目录到内部系统包含搜索路径并隐含extern "C" 语义；这些路径不被视为用户提供的，并用于模拟系统和标准头文件的路径。'
# "Add directory to the internal system include search path; these are assumed to not be user-provided and are used to model system and standard headers' paths."
H76AF34D02BE9: '添加目录到内部系统包含搜索路径；这些路径不被视为用户提供的，并用于模拟系统和标准头文件的路径。'
# 'Add dirs in env var <var> to include search path with warnings suppressed'
HFB17BE810349: '在环境变量 <var> 中添加目录到包含搜索路径并抑制警告'
# 'Add extra TOC register dependencies'
HB5EA8815333D: '添加额外的TOC寄存器依赖项'
# 'Add informational comments to the .ll file'
H1430FC8452EC: '向.ll文件添加信息性注释'
# 'Add instruction count to a LSR cost model'
H35835E4FFD3B: '向LSR成本模型添加指令计数'
# 'Add library.'
H87317E57D7DD: '添加库。'
# 'Add lifetime markers to generated constant size allocas'
HC8366738065B: '向生成的固定大小alloca添加生存期标记'
# 'Add linker option'
HEB1AFB3AB781: '添加链接器选项'
# 'Add missing headers to depfile'
H874052E89FC5: '将缺失的头文件添加到依赖文件'
# 'Add no-alias annotation for instructions that are disambiguated by memchecks'
H7736CFB59CC2: '为通过memchecks消除歧义的指令添加no-alias注解'
# 'Add printf calls that print the statement being executed'
H09CC61D8FD2B: '添加打印正在执行语句的printf调用'
# 'Add printf calls that print the values of all scalar values used in a statement. Requires -polly-codegen-trace-stmts.'
H955E9733D080: '添加打印语句中所有标量值的printf调用。 需要指定-polly-codegen-trace-stmts。'
# 'Add printf calls that show the values loaded/stored.'
H7361CFCA90ED: '添加显示加载/存储值的printf调用'
# 'Add prototypes to prototypes-less functions'
H129252A67396: '为无原型的函数添加原型'
# 'Add relocations to function pointers to the current function'
HC90D5751B49C: '向当前函数的函数指针添加重定位信息'
# 'Add run-time performance monitoring'
H67AB397B08D2: '添加运行时性能监控'
# 'Add system library paths to library search paths'
H444464D6D9E2: '将系统库路径添加到库搜索路径'
# 'Add the view as compare context.'
H9E4AA9613AAE: '将视图作为比较上下文添加。'
# 'Additional IR scalar types (always includes i1, i8, i16, i32, i64, float and double)'
H0A5D563266B6: '附加的IR标量类型（始终包含i1、i8、i16、i32、i64、float和double）'
# 'Additional argument to append to the compiler command line'
HEBA0B777F61D: '附加要追加到编译器命令行的参数'
# 'Additional argument to prepend to the compiler command line'
H6170CF05A381: '附加要前置到编译器命令行的参数'
# "Additional arguments to forward to LLVM's option processing"
HF5FFCDFCC6A2: '传递给LLVM选项处理的额外参数'
# "Additional arguments to forward to MLIR's option processing"
HF4553A1AE254: '传递给MLIR选项处理的额外参数'
# 'Additional arguments to pass to the linker'
H4F377C1D9775: '要传递给链接器的附加参数'
# 'Additional shared objects to load into executing programs'
HE9D3E5D77A09: '要加载到正在执行的程序中的附加共享对象'
# 'Address of the invoked server.'
H6E702787A95D: '被调用服务器的地址'
# 'Address of the invoked server. Defaults to 0.0.0.0:50051'
H54519DAF9B40: '被调用服务器的地址。默认为 0.0.0.0:50051'
# 'Address sinking in CGP using GEPs.'
HC7C32F638F6D: '使用GEPs在CGP中进行地址下沉'
# "AddressSanitizer doesn't support linking with debug runtime libraries yet"
H46222370DDE7: 'AddressSanitizer目前不支持与调试运行时库链接'
# 'Adjust basic block layout to better use TB[BH]'
HB4BC97D1857E: '调整基本块布局以更好地使用TB[BH]'
# 'Adjust wave priority'
HBA116352E062: '调整wave优先级'
# 'AdvSIMD Scalar Operation Optimization'
H45225A2C5722: 'AdvSIMD 标量运算优化'
# 'Advanced attributes alias.'
HA39A91E5AAD4: '高级属性别名。'
# 'Aggregate arguments to code-extracted functions'
H328995968B2E: '将提取函数的堆栈参数聚合'
# 'Aggregate stack times across threads'
H5CF510D1EBBA: '跨线程聚合堆栈时间'
# 'Aggressive extension optimization'
HA4AE7C7FBB62: '激进的扩展优化'
# 'Aggressively try to fuse everything'
H9E616808E7EC: '激进地尝试融合所有内容'
# 'Algorithm to use for splitting basic blocks into multiple statements'
H077B22383231: '用于将基本块拆分为多个语句的算法'
# 'Alias Analysis Pipeline'
HE33821D525F2: '别名分析流水线'
# 'Alias for --'
HA3FB2C7B610D: '--的别名'
# 'Alias for --blocks-x'
H57C6A0E441DA: '--blocks-x的别名'
# 'Alias for --demangled-names'
HE840FF95BF7A: '--demangled-names的别名'
# 'Alias for --dry-run'
H0FA96A999664: '--dry-run的别名'
# 'Alias for --help'
HF39AA3CC9361: '--help的别名'
# 'Alias for --indirect-call-promotion'
HDBD75B583A13: '--indirect-call-promotion的别名'
# 'Alias for --input-files'
HDFC325842CEB: '--input-files的别名'
# 'Alias for --intermediate-format'
HD7D86B4F5A3A: '--intermediate-format的别名'
# 'Alias for --no-warn'
H6C7B7F57DEA7: '--no-warn的别名'
# 'Alias for --num-threads'
HE9977CCA0811: '--num-threads的别名'
# 'Alias for --output'
HA7011D865212: '--output的别名'
# 'Alias for --output-dir'
HC51012922C34: '--output-dir的别名'
# 'Alias for --perfdata'
H136FC40E1E00: '--perfdata的别名'
# 'Alias for --perfscript'
H3EE8965681A7: '--perfscript的别名'
# 'Alias for --remapping-file'
H24A193959D48: '--remapping-file的别名'
# 'Alias for --save-temps=cwd'
HB0770869E271: '--save-temps=cwd的别名'
# 'Alias for --threads-x'
H2B37E4881B6D: '--threads-x的别名'
# 'Alias for --unsymbolized-profile'
HAAA114F8EC1E: '--unsymbolized-profile的别名'
# 'Alias for -Xclang'
HCD7F2ECE0041: '-Xclang的别名'
# 'Alias for -Xclangas'
H132AA9B77570: '-Xclangas的别名'
# 'Alias for -all-stacks'
HBF7B049FB306: '-all-stacks的别名'
# 'Alias for -check-prefix permitting multiple comma separated values'
HD103BAE71227: '-check-prefix的别名，允许使用逗号分隔的多个值'
# 'Alias for -color-edges'
HC19B12CB2430: '-color-edges的别名'
# 'Alias for -deduce-sibling-calls'
H2E10ADB53A0A: '-deduce-sibling-calls的别名'
# 'Alias for -deduce-sibling-calls-1'
HF24D573B4E93: '-deduce-sibling-calls-1的别名'
# 'Alias for -deduce-sibling-calls-2'
H4800F023F658: '-deduce-sibling-calls-2的别名'
# 'Alias for -deduce_sibling_calls'
HFE68AA381CCA: '-deduce_sibling_calls的别名'
# 'Alias for -edge-color'
H5FEAD1AEB73F: '-edge-color的别名'
# 'Alias for -edge-label'
HAFADF6FC17E1: '-edge-label的别名'
# 'Alias for -fextend-variable-liveness=all.'
H2B2334ED3B9F: '-fextend-variable-liveness=all的别名'
# 'Alias for -fsanitize-ignorelist='
H6624562D7869: '-fsanitize-ignorelist=的别名'
# 'Alias for -help'
HEA697AFD46B7: '-help的别名'
# 'Alias for -instr-map'
HB57A8B70724F: '-instr-map的别名'
# 'Alias for -instr-map-1'
H6F2C86FF53ED: '-instr-map-1的别名'
# 'Alias for -instr-map-2'
HD9A737CB2F17: '-instr-map-2的别名'
# 'Alias for -instr_map'
H13EC2B696DE5: '-instr_map的别名'
# 'Alias for -keep-going'
HC2FBFBC9B1BF: '-keep-going的别名'
# 'Alias for -keep-going-1'
HFC1713D60AC5: '-keep-going-1的别名'
# 'Alias for -keep-going-2'
HB73DA9252C0A: '-keep-going-2的别名'
# 'Alias for -keep_going'
H25546D53A1D1: '-keep_going的别名'
# 'Alias for -mllvm'
HE5CF0AF34303: '-mllvm的别名'
# 'Alias for -output'
H11E85BC44369: '-output的别名'
# 'Alias for -output-format'
HCE5EA67FACF7: '-output-format的别名'
# 'Alias for -passes'
HAC9042256B8B: '-passes的别名'
# 'Alias for -sort'
H439A5386F45B: '-sort的别名'
# 'Alias for -sortorder'
H29F0D261B98A: '-sortorder的别名'
# 'Alias for -symbolize'
HD9D9FFEE4D20: '-symbolize的别名'
# 'Alias for -top'
H0697652EC65F: '-top的别名'
# 'Alias for -version'
HD2E0461080FA: '-version的别名'
# 'Alias for -vertex-color'
HB336A9FE055A: '-vertex-color的别名'
# 'Alias for -vertex-label'
HB5305BD11A1C: '-vertex-label的别名'
# 'Alias for -vertex-label-trun'
HBB4740B7076F: '-vertex-label-trun的别名'
# 'Alias of -format'
HD5F8D2C37C5D: '-format的别名'
# 'Align ARM NEON spills in prolog and epilog'
HA6EB49748CD3: '在函数序言和尾言中对齐ARM NEON的寄存器溢出'
# 'Align branches within 32-byte boundaries to mitigate the performance impact of the Intel JCC erratum.'
H5A28F46326DE: '在 32 字节边界对齐分支，以减轻Intel JCC缺陷的性能影响'
# 'Align constant islands in code'
H461BA6D2D6E3: '在代码中对齐常量区域'
# 'Align doubles to two words in structs (x86 only)'
HEDC15B5DDF59: '在结构体中将双精度对齐为两个字（仅x86）'
# 'Align selected branches (fused, jcc, jmp) within 32-byte boundary'
H61C864267E04: '在 32 字节边界对齐选定的分支（融合、jcc、jmp）'
# "Align selected instructions to mitigate negative performance impact of Intel's micro code update for errata skx102.  May break assumptions about labels corresponding to particular instructions, and should be used with caution."
H4F2747860017: '对选定指令进行对齐以缓解Intel微代码更新（针对errata skx102）的负面影响。可能会破坏标签与特定指令对应关系的假设，需谨慎使用。'
# 'Aligned allocation/deallocation functions are unavailable'
H93CADD3D554F: '对齐的分配/释放函数不可用'
# 'Alignment of bundle for binary files'
H746C20CFEB90: '二进制文件的捆绑对齐'
# 'All Pointer Authentication scanners'
HE5781D397620: '所有指针认证扫描器'
# "All compile commands come from LSP and 'compile_commands.json' files are ignored"
H35E96D7E99B1: "所有编译命令均来自LSP，忽略 'compile_commands.json' 文件"
# "All compile commands come from the 'compile_commands.json' files"
H2E03660ADBFF: "所有编译命令均来自 'compile_commands.json' 文件"
# 'All decisions not in replay are inlined'
H9B15B2C90AE0: '所有未在重放中的决策均内联'
# 'All decisions not in replay are not inlined'
H1838D4DFB9C1: '所有未在重放中的决策均不内联'
# 'All decisions not in replay send to original advisor (default)'
H8494FD0B179D: '所有未在重放中的决策发送给原始顾问（默认）'
# 'All edges.'
HA0232E12FF85: '所有边。'
# 'All elements.'
HD1FF88F0C212: '所有元素。'
# 'All implemented scanners'
HC6B3DAC5AC10: '所有实现的扫描器'
# 'All input lines'
HAA2659CBF3BE: '所有输入行'
# 'All known subsections'
H605028076261: '所有已知子部分'
# 'All non-critical edges.'
H4DF2A4AF93D9: '所有非关键边。'
# 'All of the above and take the minimum of measurements'
H8D49782EBA5E: '上述所有情况，并取测量值的最小值'
# 'All outputs.'
HA29C21D07A12: '所有输出。'
# 'All possible int comparisons in GPRs.'
H166898BCED35: 'GPRs 中所有可能的 int 类型比较。'
# 'All suitable variables will have the TOC data transformation applied'
H5309722D6033: '所有适用变量将应用TOC数据转换'
# 'All vtables have type infos'
H69D2DF6DECC5: '所有虚表都有类型信息'
# 'All warnings.'
H294EA62DA621: '所有警告。'
# 'Allocate -frepack-arrays temporaries on the heap (default)'
H23DD0FDC2602: '将-frepack-arrays临时对象分配到堆（默认）'
# 'Allocate array temporaries on the heap (default)'
HF192F6B25D6C: '在堆上分配数组临时对象（默认）'
# 'Allocate from a slab of the given size (allowable suffixes: Kb, Mb, Gb. default = Kb)'
H8D1230E33C0D: '从给定大小的内存块中分配（允许的后缀：Kb、Mb、Gb，默认为Kb）'
# 'Allocate memory upfront rather than on-demand'
H067B160BE7A4: '预先分配内存而非按需分配'
# 'Allocate temporary arrays for -frepack-arrays in stack memory'
H60EEEE1BB97A: '在栈内存中为-frepack-arrays临时数组分配空间'
# 'Allocate to an enum type only as many bytes as it needs for the declared range of possible values'
H5482421F99A5: '为枚举类型仅分配其声明值范围所需的字节数'
# "Allow '$' in identifiers"
H6DB82DC47410: '允许标识符中包含$'
# 'Allow (may be subject to certain conditions) conversion of memcpy to TP loop.'
HF0E5B5A536C5: '允许（可能受某些条件限制）将 memcpy 转换为 TP 循环。'
# 'Allow AArch64 Local Dynamic TLS code generation'
H307A55AE7B7F: '允许AArch64本地动态TLS代码生成'
# 'Allow DSE to optimize memory accesses.'
H6047B03BEC73: '允许DSE优化内存访问'
# 'Allow GNU-extension keywords regardless of language standard'
H2947F99E638F: '允许使用GNU扩展的关键字，无论语言标准'
# 'Allow G_INSERT to be considered an artifact. Hack around AMDGPU test infinite loops.'
H8D40AAA978F4: '允许将G_INSERT视为中间产物。绕过AMDGPU测试中的无限循环。'
# 'Allow JumpThreading to thread across loop headers, for testing'
H0966C1037306: '允许JumpThreading跨循环头进行处理（用于测试）'
# 'Allow Objective-C array and dictionary subscripting in legacy runtime'
HCDF0596C06B7: '允许在旧版运行时中使用Objective-C数组和字典的下标访问'
# 'Allow SimplifyCFG to merge invokes together when appropriate'
H6D05BDC01566: '允许SimplifyCFG在适当情况下合并调用指令'
# 'Allow __declspec as a keyword'
HCB246A7067C5: '允许将__declspec作为关键字'
# 'Allow aggressive, lossy floating-point optimizations'
H0FAF2AF8BF00: '允许激进的、有损的浮点优化'
# 'Allow atomic operations to ignore denormal mode'
HCF502E940887: '允许原子操作忽略非规格化模式'
# 'Allow calls to the specified functions in SCoPs even if their side-effects are unknown. This can be used to do debug output in Polly-transformed code.'
H1410ADCFCAA7: '即使指定函数的副作用未知，仍允许在SCoPs中调用它们。这可用于在Polly优化后的代码中进行调试输出。'
# 'Allow certain math function calls to be replaced with an approximately equivalent calculation'
H7E6336F3B5B7: '允许用近似等效的计算替换某些数学函数调用'
# 'Allow cloning of callsites involved in recursive cycles'
HF572EEE2B09E: '允许克隆涉及递归循环的调用点'
# 'Allow cloning of contexts having recursive cycles'
H599BF96DBCB9: '允许克隆存在递归循环的上下文'
# 'Allow cloning of contexts through recursive cycles'
HB9EECACDCD85: '允许通过递归循环克隆上下文'
# 'Allow combining of BaseGV field in Address sinking.'
H2D77F4CB6201: '允许在Address sinking中合并BaseGV字段'
# 'Allow combining of BaseOffs field in Address sinking.'
HF852DDC4F55A: '允许在地址下沈优化中合并BaseOffs字段'
# 'Allow combining of BaseReg field in Address sinking.'
H26B9669FA2AC: '允许在地址下沈优化中合并BaseReg字段'
# 'Allow combining of ScaledReg field in Address sinking.'
HDEF3EE554628: '允许在地址下沈优化中合并ScaledReg字段'
# 'Allow compiler to annotate sanitizer instrumentation with extra debug info for all sanitizers, where supported'
HCBC6B18AD214: '允许编译器为所有支持的sanitizer插桩标注额外的调试信息'
# 'Allow compiler to merge handlers for all sanitizers'
H5230AC99F094: '允许编译器合并所有sanitizers的处理程序'
# 'Allow compiler to merge handlers for specified sanitizers'
HD4BB34899488: '允许编译器合并指定sanitizers的处理程序'
# 'Allow conditional instructions outside of an IT block'
H08E49F0EFDBF: '允许在IT块之外使用条件指令'
# 'Allow counter promotion across the whole loop nest.'
HD6A96DE259B4: '允许在整个循环嵌套中提升计数器'
# 'Allow creation of Phis in Address sinking.'
HE9D1F49BEE6D: '允许在地址下沈优化中创建Phi节点'
# 'Allow creation of selects in Address sinking.'
HF3DF8C2D011E: '允许在地址下沈优化中创建选择指令'
# 'Allow device side init function in HIP (experimental)'
HBC635735388C: '允许在HIP中使用设备端初始化函数（实验性）'
# 'Allow different element types for array accesses'
HE3FBA82C5731: '允许数组访问时使用不同的元素类型'
# 'Allow division operations to be reassociated'
HAD0D8D2448AD: '允许重新关联除法操作'
# 'Allow enabling loop hints to reorder FP operations during vectorization.'
HD2BC949EEEE2: '允许在向量化期间使用循环提示重新排序FP运算'
# 'Allow exactly one expensive instruction to be speculatively executed'
H2182F06086EB: '允许推测执行恰好一条昂贵指令'
# 'Allow floating-point optimizations that assume arguments and results are not NaNs or +-inf. This defines the \\_\\_FINITE\\_MATH\\_ONLY\\_\\_ preprocessor macro.'
H49916D802745: '允许假设参数和结果不为NaN或±inf的浮点优化。此选项定义预处理器宏 \\_\\_FINITE\\_MATH\\_ONLY\\_\\_'
# 'Allow for a mixture of Mips16 and Mips32 code in a single output file'
H85A1B3521C3C: '允许在单个输出文件中混合Mips16和Mips32代码'
# 'Allow functions with known modref behavior'
HE8FEED2897E6: '允许具有已知modref行为的函数'
# 'Allow generation of a loop remainder (extra iterations) when unrolling a loop.'
HA9A95BA27CAD: '允许在展开循环时生成循环余数（额外迭代）'
# 'Allow generation of complex IT blocks.'
H0C587C47350A: '允许生成复杂的IT块。'
# 'Allow generation of data access to code sections (AArch64/ARM only)'
H4E803F81C9B5: '允许对代码段进行数据访问（仅AArch64/ARM）'
# 'Allow header insertions (deprecated. Use -disable-insert instead)'
H2636E70EED6C: '允许头文件插入（已弃用。使用-disable-insert代替）'
# 'Allow header removals (deprecated. Use -disable-remove instead)'
H6A88BB16BC90: '允许头文件移除（已弃用。使用-disable-remove代替）'
# 'Allow incomplete IR on a best effort basis (references to unknown metadata will be dropped)'
H05F1B598EC8B: '允许基于尽力原则使用不完整的IR（对未知元数据的引用将被丢弃）'
# "Allow inlining when caller has a superset of callee's nobuiltin attributes."
H21EB86A2A3AB: '允许在调用者具有被调用函数nobuiltin属性的超集时进行内联'
# 'Allow loop rotation multiple times in order to reach a better latch exit'
HE5B48E5AC62B: '允许多次旋转循环以达到更好的循环退出'
# 'Allow mapping symbol at section beginning to be implicit, lowering number of mapping symbols at the expense of some portability. Recommended for projects that can build all their object files using this option'
HE30942163DF4: '允许将位于节开头的符号的映射隐式化，以减少映射符号的数量，但会降低可移植性。建议用于可以使用此选项构建所有目标文件的项目'
# 'Allow memory accesses to be unaligned (AArch32/MIPSr6 only)'
H4DACD884827E: '允许非对齐内存访问（仅AArch32/MIPSr6）'
# 'Allow memory accesses to be unaligned (AArch64/LoongArch/RISC-V only)'
H075169115FA2: '允许非对齐内存访问（仅AArch64/LoongArch/RISC-V）'
# 'Allow mergefunc to create aliases'
H96D31DA83FB1: '允许mergefunc创建别名'
# 'Allow merging of constants'
H7B7B2A69B6A1: '允许合并常量'
# 'Allow non affine access functions in arrays'
H1B750054F6AE: '允许数组中使用非仿射访问函数'
# 'Allow non affine conditions for branches'
H02FFF4B1AF5A: '允许分支使用非仿射条件'
# 'Allow non affine conditions for loops'
H7C67DD81E47E: '允许循环使用非仿射条件'
# 'Allow non-power-of-2 vectorization.'
HA2D0D7F2C7BF: '允许非 2 的幂次向量化。'
# 'Allow non-solo packetization of volatile memory references'
H5792B0D4B6CC: '允许易失性内存引用的非独立分组'
# 'Allow operation with no registered dialects'
H7A999A69E320: '允许未注册方言的操作'
# 'Allow operation with no registered dialects (discouraged: testing only!)'
HF9B2D65D3FE4: '允许未注册方言的操作（不推荐：仅限测试！）'
# 'Allow operations coming from an unregistered dialect'
HC8673F2EA652: '允许来自未注册方言的操作'
# 'Allow optimization to assume there are no NaNs.'
H4027A2790C01: '允许优化假设没有NaN存在。'
# 'Allow optimization to assume there are no infinities.'
H2F8AEF326E4D: '允许优化假设没有无穷大存在。'
# 'Allow optimizations that ignore the sign of floating point zeros'
H74EA3796D9B9: '允许优化忽略浮点零的符号'
# 'Allow partial writes'
H36F20305E82F: '允许部分写入'
# 'Allow passing GC Pointer arguments in callee saved registers'
HAAA2F5C160B0: '允许将GC指针参数传递到被调用者保存的寄存器中'
# 'Allow placing main program variables on the stack (default)'
HFA7AA687FA70: '允许将主程序变量放在栈上（默认）'
# 'Allow prefixes to be specified but not appear in the test.'
HE9A068B65F59: '允许指定前缀但不在测试中出现。'
# 'Allow reassociation transformations for floating-point instructions'
H69FAD124BA17: '允许对浮点指令进行重新关联变换'
# 'Allow relaxed uniform region checks'
HECAF51D715EB: '允许松弛的统一区域检查'
# 'Allow reordering across at most this many instructions when hoisting'
H03C130FA1582: '允许在提升时最多跨此数量的指令重新排序'
# 'Allow runtime unroll for AMDGPU if local memory used in a loop'
H6AD964FBACC9: '如果循环中使用了本地内存，则允许AMDGPU的运行时展开'
# 'Allow runtime unrolled loops to be unrolled with epilog instead of prolog.'
H402D9BD954E3: '允许运行时展开的循环使用尾部而非头部展开'
# 'Allow runtime unrolling for loops with multiple exits, when epilog is generated'
H612B7424A810: '在生成尾部时允许具有多个出口的循环进行运行时展开'
# 'Allow sample loader inliner to inline recursive calls.'
HA6530F6AAC71: '允许样本加载内联器内联递归调用。'
# 'Allow scalar memory accesses to be unaligned (RISC-V only)'
HFC86196CBA64: '允许标量内存访问非对齐（仅RISC-V）'
# 'Allow slot1 store and slot0 load'
H7437ACC71E24: '允许slot1存储和slot0加载'
# 'Allow speculation of preheader instructions'
H363DA7F8452D: '允许预头指令的推测'
# 'Allow spill in spill slot of greater size than register size'
H9CD29F6A2A53: '允许溢出到比寄存器更大的溢出槽位'
# 'Allow static variables in .sdata'
H770981D5F907: '允许在.sdata段中使用静态变量'
# 'Allow the Attributor to create shallow wrappers for non-exact definitions.'
HB6DC09C0C648: '允许Attributor为非精确定义创建浅层包装器'
# 'Allow the Attributor to do call site specific analysis'
H2595BA1E26D0: '允许Attributor进行调用点特定分析'
# 'Allow the Attributor to use IP information derived from non-exact functions via cloning'
H0E8CFBCDE797: '允许Attributor通过克隆使用来自非精确函数的IP信息'
# 'Allow the compiler to assume that each translation unit has a unique source file identifier (see -funique-source-file-identifier) at link time'
H857226BB03C5: '允许编译器假设每个翻译单元在链接时具有唯一的源文件标识符（参见 -funique-source-file-identifier）'
# 'Allow the detection of full functions'
H6DD82ED565A3: '允许检测完整函数'
# 'Allow the formation of VW_W operations (e.g., VWADD_W) with splat constants'
H845C6DF92D8C: '允许使用splat常量形成VW_W操作（例如VWADD_W）'
# 'Allow the input file to be empty. This is useful when making\nchecks that some error message does not occur, for example.'
H658BEA7D8D36: '允许输入文件为空。这在验证某些错误信息不会出现时很有用，例如。'
# 'Allow the loop remainder to be unrolled.'
H54EBCBE4781C: '允许展开循环余数'
# 'Allow the use of FMAs if available and profitable. This may result in different results, due to less rounding error.'
H996DA0DE6CCE: '允许使用可用且有利的FMAs。这可能导致不同结果，因舍入误差更少。'
# 'Allow to search for module maps in subdirectories of search paths'
H4C313304A657: '允许在搜索路径的子目录中搜索模块映射文件'
# "Allow to speculate on the execution of 'error blocks'."
H88DB79B94D55: '允许对"错误块"的执行进行推测'
# 'Allow unsafe floating-point math optimizations which may decrease precision'
H67E450B90F32: '允许使用可能降低精度的不安全浮点数学优化'
# 'Allow unsigned operations such as comparisons or zero-extends.'
H33CDECA8CBA8: '允许使用无符号操作，例如比较或零扩展'
# 'Allow use of CMSE (Armv8-M Security Extensions)'
H21EADF8CC690: '允许使用CMSE（Armv8-M安全扩展）'
# 'Allow use of CRC instructions (ARM/Mips only)'
H0928C2372DB2: '允许使用CRC指令（仅限ARM/Mips）'
# 'Allow using blocks with parameters of more specific type than the type system guarantees when a parameter is qualified id'
HEADAE3890D46: '允许在参数类型比类型系统保证的更具体时使用块，当参数为qualified id时'
# 'Allow using registers for gc pointer in landing pad'
H6D19D992878A: '允许在着陆垫中使用寄存器保存gc指针'
# 'Allow using registers for non pointer deopt args'
HD185DF4F0E95: '允许使用寄存器保存非指针deopt参数'
# 'Allow variadic functions in CUDA device code.'
H918161EF13F5: '允许在CUDA设备代码中使用可变参数函数。'
# 'Allow vector memory accesses to be unaligned (RISC-V only)'
HB7E7D4EF733A: '允许向量内存访问为未对齐（仅RISC-V）'
# 'Allow widening of indvars to eliminate s/zext'
HC582FEBF6EC9: '允许扩展indvars以消除s/zext'
# 'Allowed symbol scopes (comma-separated list)'
H09C539E5B693: '允许的符号作用域（逗号分隔列表）'
# 'Allows assuming by-value parameters do not alias any other value. Has no effect on non-trivially-copyable classes in C++.'
HA18120EB5360: '允许假设按值传递的参数不与其他值重叠。对C++中非平凡可复制类无影响。'
# 'Allows control over excess precision on targets where native support for BFloat16 precision types is not available. By default, excess precision is used to calculate intermediate results following the rules specified in ISO C99.'
HBB6845887CAC: '在不支持BFloat16精度类型的系统上控制额外精度。默认情况下，按照ISO C99规则使用额外精度计算中间结果。'
# 'Allows control over excess precision on targets where native support for Float16 precision types is not available. By default, excess precision is used to calculate intermediate results following the rules specified in ISO C99.'
HC49D9EDA0518: '在不支持Float16精度类型的系统上控制额外精度。默认情况下，按照ISO C99规则使用额外精度计算中间结果。'
# 'Allows control over excess precision on targets where native support for the precision types is not available. By default, excess precision is used to calculate intermediate results following the rules specified in ISO C99.'
HF60814E6692A: '在不支持对应精度类型的系统上控制额外精度。默认情况下，按照ISO C99规则使用额外精度计算中间结果。'
# 'Allows loop nests to be peeled.'
HFE032116CB53: '允许拆解循环嵌套'
# 'Allows loops to be partially unrolled until -unroll-threshold loop size is reached.'
HAAF79FCD3521: '允许部分展开循环直至达到-unroll-threshold循环大小'
# 'Allows loops to be peeled when the dynamic trip count is known to be low.'
HE4D86D272F84: '当动态迭代次数已知较低时允许拆解循环'
# 'Allows loops to be unroll-and-jammed.'
H08E5D5835443: '允许循环展开并合并'
# 'Allows to add additional results to private functions to return ownership of returned memrefs to callers. This can avoid spurious buffer clones in the callee.'
H2478745EEA16: '允许向私有函数添加额外返回值以将返回的memrefs所有权返回给调用者。这可避免被调用者中的冗余缓冲区复制。'
# 'Allows using features specific to Hugo'
H5D750A78EC0D: '允许使用Hugo特定的功能'
# 'Also show functions without any scops'
H8AA7DD878BF3: '也显示没有作用域的函数'
# 'Also write profiles with all-zero counters. Intended for testing/debugging.'
HC00EF438F6CF: '也生成所有计数器均为零的配置文件。用于测试/调试'
# 'Always Step Into.'
H2D9E73855459: '始终步入。'
# 'Always convert memcpy to TP loop.'
H43BC365E404A: '始终将 memcpy 转换为 TP 循环。'
# 'Always detect stack use after return.'
HAA3BC6D7C687: '始终检测函数返回后使用栈'
# 'Always dump input'
HA3473C53D75A: '始终转储输入'
# 'Always emit EH frame entries'
HDDDD83A3567E: '始终生成EH帧条目'
# 'Always emit __xray_customevent(...) calls even if the containing function is not always instrumented'
H3096C16CDC52: '始终生成__xray_customevent(...)调用，即使包含的函数未被插桩'
# 'Always emit __xray_typedevent(...) calls even if the containing function is not always instrumented'
H2E61DC30BF81: '始终生成__xray_typedevent(...)调用，即使包含的函数未被插桩'
# 'Always emit a debug frame section'
HB80937D1780A: '始终生成调试帧节区'
# 'Always emit a debug frame section.'
H23A9192A38F7: '始终生成调试帧段'
# 'Always exclude wrong side overloads in overloading resolution for CUDA/HIP'
HA5AB629FB85E: '始终在CUDA/HIP的重载解析中排除错误一侧的重载'
# 'Always generate function calls for address sanitizer instrumentation'
HA25586514168: '启用Address Sanitizer插桩的函数调用生成'
# 'Always modify dest registers regardless of color'
H58E66AB0CF8C: '无论寄存器颜色如何始终修改目标寄存器'
# 'Always set the bit'
H9287AFC9334D: '始终设置该位'
# 'Always track the overflow bit.'
H577F71683BBC: '始终跟踪溢出位。'
# 'Always use $gp as the global base register.'
HC4090BE1945A: '始终使用$gp作为全局基寄存器'
# 'Always use DW_AT_ranges in DWARFv5 whenever it could allow more address pool entry sharing to reduce relocations/object size'
H5C1DD29350B5: '在DWARFv5中始终使用DW_AT_ranges属性，只要能通过更多地址池条目共享来减少重定位和目标文件大小'
# 'Always use compact branches if possible.'
H9248BC8A7969: '如果可能，始终使用紧凑分支。'
# 'Always use descriptors for POINTER and ALLOCATABLE'
H088038A3E688: '始终为POINTER和ALLOCATABLE类型使用描述符'
# 'Always used text-based completion'
H186681547B61: '始终使用基于文本的补全'
# 'Always write temporary files as bitcode instead of textual IR'
H1C24DC778992: '始终将临时文件写为比特码而非文本IR'
# 'An ID for compilation unit, which should be the same for the same compilation unit but different for different compilation units. It is used to externalize device-side static variables for single source offloading languages CUDA and HIP so that they can be accessed by the host code of the same compilation unit.'
HEAEE5FF78DA6: '编译单元的ID，应为同一编译单元使用相同ID，不同单元使用不同ID。用于CUDA和HIP单源offloading语言外部化设备静态变量，以便同一编译单元的主机代码访问。'
# 'An additional cost threshold that must be exceeded for merging to be considered beneficial.'
H80CD60A8D728: '合并操作被认为有益时必须超过的额外成本阈值'
# 'An allocatable left-hand side of an intrinsic assignment is assumed to be allocated and match the shape/type of the right-hand side'
H80F5410F8454: '假设内建赋值的左操作数可分配，并与右操作数的形状/类型匹配'
# 'An integer in percent used to specify the hot blocks/edges to be displayed in red: a block or edge whose frequency is no less than the max frequency of the function multiplied by this percent.'
H785F9B56BA61: '以百分比形式指定要以红色显示的热块/边的整数值：其频率不低于函数最大频率乘以此百分比的块或边'
# 'Analysis'
H62C7FCF46E27: '分析'
# 'Analysis containing CSE Info'
H844D68401590: '包含CSE信息的分析'
# 'Analysis for ComputingKnownBits'
H7CC4A0AB7F2C: 'ComputingKnownBits分析'
# 'Analysis if a function is memory bound'
H4D110E7E06DE: '分析函数是否为内存绑定型'
# 'Analyze Machine Code For Garbage Collection'
H9DF9D8E23EF5: '分析机器码以进行垃圾回收'
# 'Analyze and emit instructions for Win64 Unwind v2'
HBAD8BCB2E044: '分析并为Win64 Unwind v2生成指令'
# 'Analyze array contents for load forwarding'
H400B26D98EF4: '分析加载转发的数组内容'
# 'Annotate LTO phase (prelink / postlink), or main (no LTO) for sample-profile inline pass name.'
HE2E0B6955283: '为sample-profile内联pass名称标注LTO阶段（prelink/postlink）或主阶段（无LTO）。'
# 'Annotate SI Control Flow'
H917E9747DC24: '注释SI控制流'
# 'Annotate call sites of function declarations.'
H117120C6D4F8: '标注函数声明的调用点'
# 'Annotate sanitizer instrumentation with extra debug info for the specified sanitizers, if supported'
H2FA3995AD0E4: '对指定的sanitizer插桩标注额外的调试信息（若支持）'
# 'Annotate table jump instruction to correlate it with the jump table.'
H49774B77C4AA: '标注表格跳转指令，使其与跳转表关联'
# 'Any subsection not covered by another option'
HE0257BE6772D: '任何未被其他选项覆盖的子部分'
# 'Append function hash to the name of COMDAT function to avoid function hash mismatch due to the preinliner'
HFFA3462002F7: '将COMDAT函数的名称附加函数哈希，以避免因预内联导致的函数哈希不匹配'
# "Append the exit code to the output so it gets diff'd too"
H9E3A9D6959C1: '将退出码附加到输出以便进行差异比较'
# 'Append vectorize enable/disable metadata from polly'
H9E5D3061A26C: '从Polly附加工向量化启用/禁用元数据'
# 'Appends one trailing underscore to external names'
HD2751F46D9D1: '在外部名称末尾追加一个下划线'
# 'Apple'
H476432A3E85A: 'Apple'
# 'Applies path clonings for the -basic-block-sections=list option'
H2424A194F26C: '为-basic-block-sections=list选项应用路径克隆'
# 'Apply CHR for all functions'
H577A52B0B7CC: '对所有函数应用CHR优化'
# 'Apply an iterative post-processing to infer correct BFI counts'
H66ADFA49B9E1: '通过迭代后处理推断正确的BFI计数值'
# 'Apply edits to analyzed source files'
HFDE3C74EED4D: '对分析的源文件应用修改'
# 'Apply first slot optimization for stack tagging (eliminate ADDG Rt, Rn, 0, 0).'
H2ADE0B593B04: '为栈标记应用第一个插槽优化（消除 ADDG Rt, Rn, 0, 0 指令）'
# 'Apply fix-it advice creating a file with the given suffix'
H2BD66E062CA1: '应用创建指定后缀文件的修复建议'
# 'Apply fix-it advice even in the presence of unfixable errors'
H011FCA2E909C: '即使存在无法修复的错误也应用修复建议'
# 'Apply fix-it advice only for warnings, not errors'
H6ED66F770BAD: '仅对警告而非错误应用修复建议'
# 'Apply fix-it advice to the input source'
HFFEDA0075E38: '对输入源代码应用修复建议'
# 'Apply fix-it changes and recompile'
H6D9BFB4F5F51: '应用修复更改并重新编译'
# 'Apply fix-it changes to temporary files'
HF35652D64499: '将修复更改应用到临时文件'
# 'Apply given attribute to all functions'
H0A840E827150: '将给定属性应用于所有函数'
# 'Apply global symbol visibility to external declarations without an explicit visibility'
HB6DB5D64D7AE: '对外部声明中未显式指定可见性的符号应用全局符号可见性'
# 'Apply no_sanitize to the whole file'
H1820034AB28F: '对整个文件应用 no_sanitize'
# 'Apply post-rescheduling optimizations such as tiling (requires -polly-reschedule)'
HD42F33B0AD22: '应用重新调度后的优化（例如分块，需要 -polly-reschedule）'
# 'Apply the profile guided size optimizations only if the working set size is large (except for cold code.)'
HCAA14E2BEA3D: '仅当工作集大小较大时应用基于配置文件的大小优化（冷代码除外）'
# 'Apply the profile guided size optimizations only to cold code under instrumentation PGO.'
H88E35D1AFA04: '仅在插桩PGO的冷代码中应用配置文件引导型尺寸优化'
# 'Apply the profile guided size optimizations only to cold code under partial-profile sample PGO.'
HA712F1C73153: '在部分配置文件采样 PGO 下仅对冷代码应用基于配置文件的大小优化'
# 'Apply the profile guided size optimizations only to cold code under sample PGO.'
H15AF6FCF8AC2: '在采样 PGO 下仅对冷代码应用基于配置文件的大小优化'
# 'Apply the profile guided size optimizations only to cold code.'
HFC7E2CE1D9BB: '仅对冷代码应用基于配置文件的大小优化'
# 'Apply the terminal rule'
HE81B9410B1C9: '应用终端规则'
# 'Apply user-directed transformation from metadata'
HC2B25CDB2B7C: '从元数据中应用用户指定的转换'
# 'Approximately limit number of return registers for replacing out arguments'
H004F37FECEE5: '近似限制用于替换传出参数的返回寄存器数量'
# 'Architecture to generate code for (see --version)'
H3DBAAEAEDF16: '生成代码的目标架构（参见 --version）'
# 'Argument Register Usage Information Storage'
H5FFD7A67FE89: '参数寄存器使用信息存储'
# 'Argument Stack Rebase'
HAB61ED834BD0: '参数栈基址重定位'
# 'Argument to pass to the CompilerInvocation'
H3D79343D82D3: '传递给 CompilerInvocation 的参数'
# 'Arguments passed onto the interesting-ness test'
H2C80A4DD32DD: '传递给 interesting-ness 测试的参数'
# 'Arguments to pass to the DTLTO distributor process.'
H02599B65A936: '传递给DTLTO分发器进程的参数'
# 'Arguments to pass to the remote compiler for backend compilations.'
HE57FA5E1C8EF: '传递给远程编译器用于后端编译的参数'
# 'Arm Performance Libraries'
H044D40FECAA8: 'Arm性能库'
# 'Array subrange.'
HC09EA244D244: '数组子范围。'
# 'Array.'
H75555184EF20: '数组。'
# 'As secure log file name'
H1E6AE7BB635A: '作为安全日志文件名'
# 'As we import functions called from hot callsite, multiply the `import-instr-limit` threshold by this factor before processing newly imported functions'
HFC6F5302C981: '在处理从热调用点导入的函数时，将 `import-instr-limit` 阈值乘以此因子'
# 'As we import functions, multiply the `import-instr-limit` threshold by this factor before processing newly imported functions'
H807021E7830C: '在导入函数时，将 `import-instr-limit` 阈值乘以此因子'
# 'Asm comments indentation'
HA72479C6AB4B: '汇编注释缩进'
# 'Assemble a .s file (default)'
H6369F207FAFB: '汇编一个.s文件（默认）'
# 'Assembler instructions.'
H66538D7A1ED5: '汇编指令。'
# 'Assembler line.'
H85B24622E0B1: '汇编代码行。'
# 'Assert no nested parallel regions in the GPU'
H418AEEF6FF3F: '断言GPU中不存在嵌套并行区域'
# 'Assert no thread in a parallel region modifies an ICV'
HBA986658A86D: '断言并行区域中的线程不会修改ICV'
# 'Assert that the compilation takes place in a freestanding environment'
H511BD8C1C674: '断言编译发生在自由-standing环境（无宿主环境）中'
# 'Assign reference type allocas to local address space'
H59903DB020B4: '将引用类型alloca分配到本地地址空间'
# 'Assign register bank of generic virtual registers'
H2974E89C9B08: '为通用虚寄存器分配寄存器组'
# 'Assign valid PTX names to globals'
HB126730FBD94: '为全局变量分配有效的PTX名称'
# 'Assignment Tracking Analysis'
H52ADB4784DA7: '赋值跟踪分析'
# 'Assigns WebAssembly register numbers for virtual registers'
H3989AF635266: '为虚寄存器分配WebAssembly寄存器编号'
# 'Assume SVE vector registers are at least this big, with zero meaning no minimum size is assumed.'
H2E16603634C1: '假设 SVE 向量寄存器至少为这个大小，0 表示不假设最小尺寸'
# 'Assume SVE vector registers are at most this big, with zero meaning no maximum size is assumed.'
H9D138AF1C883: '假设SVE向量寄存器的最大值不超过该值，零表示不假设最大值。'
# 'Assume V extension vector registers are at least this big, with zero meaning no minimum size is assumed. A value of -1 means use Zvl*b extension. This is primarily used to enable autovectorization with fixed width vectors.'
HD680D88BB0DC: '假设V扩展向量寄存器的最小值不小于该值，零表示不假设最小值。-1表示使用Zvl*b扩展。这主要用于启用固定宽度向量的自动向量化。'
# 'Assume V extension vector registers are at most this big, with zero meaning no maximum size is assumed.'
H72E88FB1B9F8: '假设V扩展向量寄存器的最大值不超过该值，零表示不假设最大值。'
# 'Assume all functions may be convergent.'
H4C995A5519E7: '假设所有函数都可能是收敛函数（convergent）'
# 'Assume all functions with C linkage do not unwind'
H687362EE1CE8: '假设具有C链接的函数不会展开（unwind）'
# 'Assume all non-trivial loops are finite.'
HE8DEA9F53022: '假设所有非平凡循环都是有限的'
# 'Assume data segments are relative to text segment'
HDE84E251972D: '假设数据段相对于文本段是相对的'
# 'Assume distributed loops do not have more iterations than participating teams.'
H40EE5717199D: '假设分布式循环的迭代次数不超过参与团队的数量。'
# 'Assume no atomic operations on fine-grained memory'
H63C989F614F3: '假设不会对细粒度内存执行原子操作'
# 'Assume no atomic operations on remote memory'
H0DEE4D7E8196: '假设不会对远程内存执行原子操作'
# 'Assume that UAVs/SRVs may alias'
HCF25B628FDEC: '假设UAV/SRV可能别名'
# "Assume that exception objects' destructors are non-throwing"
HA13DECB16694: '假设异常对象的析构函数不会抛出（non-throwing）'
# 'Assume that execution stops at trap instruction'
HFD7E94900060: '假设程序在遇到陷阱指令时会终止执行'
# 'Assume that externally defined data is in the small data if it meets the -G <size> threshold (MIPS)'
H79ED681B6E82: '假设符合-G <size> 阈值（MIPS）的外部定义数据位于小数据区中'
# 'Assume that kernels are launched with uniform block sizes (default true for CUDA/HIP and false otherwise)'
HA763A763DA9A: '假设内核以统一块大小启动（默认为CUDA/HIP启用，其他情况禁用）'
# 'Assume that no thread in a parallel region will encounter a parallel region.'
HCB2AEFAC7594: '假设在一个并行区域内，任何线程都不会遇到另一个并行区域。'
# 'Assume that no thread in a parallel region will modify an ICV.'
HF1302F78B04D: '假设在一个并行区域内，任何线程都不会修改ICV。'
# 'Assume that overflowing float-to-int casts are undefined (default)'
HCD9EDFDB1A53: '假设浮点到整数的转换溢出是未定义行为（默认）'
# 'Assume that the precompiled header is a precompiled preamble covering the first N bytes of the main file'
H9D4E9ACCBF56: '假设预编译头是覆盖主文件前N字节的预编译前导部分'
# 'Assume that the product of the two iteration trip counts will never overflow'
HE37E63049A0E: '假设两个迭代次数的乘积不会溢出'
# 'Assume that top byte of an address is ignored'
H9BFCB8929B9A: '假设地址的高位字节会被忽略'
# 'Assume the input has already undergone ThinLTO function importing and the other pre-optimization pipeline changes.'
H2CA2E2C1C103: '假设输入已经完成ThinLTO函数导入和预优化流水线的其他修改。'
# 'Assume the module is loaded at the specified address'
H85B7A3226995: '假设模块被加载到指定地址'
# 'Assume the non latch exit block to be predictable'
HEBCC8B6F378D: '假设非latch退出块是可预测的'
# 'Assume thread-local variables are defined in the executable'
H9F2FA53E0530: '假定线程局部变量在可执行文件中定义'
# 'Assume work-shared loops do not have more iterations than participating threads.'
HF6F555EC0542: '假设工作共享循环的迭代次数不超过参与线程的数量。'
# 'Assumed aligned memory accesses.'
H1F99EB0F5177: '假设内存访问是对齐的。'
# 'Assumed extra stack use if there are any variable sized objects (in bytes)'
HC8C97CA4569F: '假设存在任何变长对象时的额外栈使用量（以字节为单位）'
# 'Assumed stack use of any external call (in bytes)'
H4EA740EFEAD0: '假设外部调用的栈使用量（以字节为单位）'
# 'Assumption Cache Tracker'
HD200FE62329F: '假设缓存跟踪器'
# 'At top of block or after label'
H305A8BE31E6D: '在块顶部或标签之后'
# 'Attach calleeguids as value profile metadata for indirect calls.'
HDF15CBA413B3: '将calleeguids作为间接调用的值剖析元数据附加'
# 'Attach debug info to a function'
H08A666FD7289: '将调试信息附加到一个函数'
# 'Attach debug info to everything'
HED658EC60D0F: '将调试信息附加到所有内容'
# 'Attempt coalescing during PBQP register allocation.'
H7648F369F9C7: '尝试在PBQP寄存器分配过程中进行合并。'
# 'Attempt to allocate array temporaries created under -frepack-arrays on the stack'
HB0B7FBFAAEA5: '尝试将-frepack-arrays创建的数组临时对象分配到栈'
# 'Attempt to allocate array temporaries on the stack, no matter their size'
H1898E5AD9AA7: '无论数组临时对象大小如何，都尝试在栈上分配'
# 'Attempt to drop solution if it is less profitable'
H339D061FB39B: '尝试丢弃利润较低的解决方案'
# 'Attempt to match the ABI of Clang <version>'
H0603A0819A4F: '尝试匹配Clang <version> 的ABI'
# 'Attempt to vectorize for this register size in bits'
HC4E22D3921AE: '尝试为此寄存器大小（以位为单位）进行向量化'
# 'Attempt to vectorize horizontal reductions'
H7D29B593C54B: '尝试向量化水平规约'
# 'Attempt to vectorize horizontal reductions feeding into a store'
H86C2FB57AC78: '尝试向量化输入存储的水平规约'
# 'Attribute Options'
H80A446F5E125: '属性选项'
# "Attribute all functions' range with zero count even it's not hit by any samples."
H6A8CFBBE8142: '即使没有采样命中，也给所有函数的范围分配零计数值。'
# 'Auto-generates preprocessed source files and a reproduction script'
H2B36EB61E3F1: '自动生成预处理源文件和复现脚本'
# 'Automatically put hot code on 2MB page(s) (hugify) at runtime. No manual call to hugify is needed in the binary (which is what --hot-text relies on).'
H0155A65DE424: '在运行时将热点代码放在 2MB页面（hugify）上。无需在二进制文件中手动调用hugify（这是--hot-text所依赖的）。'
# 'Auxiliary target triple.'
H7C66B9F24C8E: '辅助目标三元组。'
# 'Average inst/cycle when no target itinerary exists.'
HAC1A1866B355: '无目标行程时的平均inst/cycle'
# 'Avoid FPU mode dependent operations when used with the O32 ABI'
HFD29595F0062: '与O32 ABI配合使用时避免FPU模式相关操作'
# 'Avoid logging potentially-sensitive request details'
H7AE408773694: '避免记录可能敏感的请求细节'
# 'Avoid optimizing x86 call frames for size'
HEAFF156A02EB: '避免优化x86调用帧的大小'
# 'Avoid translating the elements of DICompositeTypes during the LLVM IR import (discouraged: testing only!)'
H92E0AEF9C7F0: '避免在导入LLVM IR时转换DICompositeTypes的元素（不建议：仅用于测试！）'
# 'Avoid using scaled registers with vscale-relative addressing'
H9CD1A0FBC370: '避免使用与vscale相关的寻址中的缩放寄存器'
# 'BAT dump options'
HE7548A5409DC: 'BAT转储选项'
# 'BC Analyzer Options'
H4B23BE663585: 'BC分析器选项'
# 'BOLT - Binary Optimization and Layout Tool\n'
H01223DC88456: 'BOLT - 二进制优化和布局工具\n'
# 'BOLT generic options'
H833927334F93: 'BOLT通用选项'
# 'BOLT instrumentation options'
H236274761B58: 'BOLT插桩选项'
# 'BOLT optimization options'
HF7FB7C2D71C6: 'BOLT优化选项'
# 'BOLT options in relocation mode'
H72F40B1DAEF4: 'BOLT重定位模式选项'
# 'BOLTDIFF generic options'
HBCE6535FC79B: 'BOLTDIFF通用选项'
# 'BPF Assembly Printer'
H12132B1ED395: 'BPF汇编打印器'
# 'BPF Check And Adjust IR'
H4D7204899754: 'BPF检查并调整中间表示'
# 'BPF DAG->DAG Pattern Instruction Selection'
H7C44CC075E35: 'BPF DAG->DAG 模式指令选择'
# 'BPF MachineSSA Peephole Optimization For ZEXT Eliminate'
H1FCC7FDAD7BB: 'BPF MachineSSA针对ZEXT消除的微优化'
# 'BPF PreEmit Checking'
H9D3E8CD483F5: 'BPF代码生成前检查'
# 'BPF PreEmit Peephole Optimization'
H9917446E38FB: 'BPF代码生成前的微优化'
# 'BPF PreEmit SimplifyPatchable'
HD1C3DD579B0E: 'BPF代码生成前简化可修补部分'
# 'BPF: Disable Avoiding Speculative Code Motion.'
HA01C55FDDABF: 'BPF：禁用避免推测性代码移动。'
# 'BPF: Disable Serializing ICMP insns.'
H688F09F03EC9: 'BPF：禁用序列化ICMP指令。'
# 'Bail out on unprofitable SCoPs before rescheduling'
HD7D2870382BF: '在重新调度前放弃无利可图的SCoPs'
# 'Base Directory for generated documentation.\nURLs will be rooted at this directory for HTML links.'
HD430D315BE29: '生成文档的基本目录。\nURL将以此目录为根路径用于HTML链接。'
# 'Base Type (int, bool, etc.).'
H7F681232E46A: '基本类型（int、bool等）。'
# 'Base cost of vector insert/extract element'
HA29AACEEF76F: '向量插入/提取元素的基础耗时'
# 'Base file path for the interactive mode. The incoming filename should have the name <inliner-interactive-channel-base>.in, while the outgoing name should be <inliner-interactive-channel-base>.out'
HED13A1932932: '交互模式的基础文件路径。输入文件名应为 <inliner-interactive-channel-base>.in，输出文件名应为 <inliner-interactive-channel-base>.out'
# 'Base file path for the interactive mode. The incoming filename should have the name <regalloc-evict-interactive-channel-base>.in, while the outgoing name should be <regalloc-evict-interactive-channel-base>.out'
HEEBA85373FA8: '交互模式的基础文件路径。输入文件名应为 <regalloc-evict-interactive-channel-base>.in，输出文件名应为 <regalloc-evict-interactive-channel-base>.out'
# 'Base file path for the interactive mode. The incoming filename should have the name <regalloc-priority-interactive-channel-base>.in, while the outgoing name should be <regalloc-priority-interactive-channel-base>.out'
H9411EE803DAA: '交互模式的基础文件路径。输入文件名应为 <regalloc-priority-interactive-channel-base>.in，输出文件名应为 <regalloc-priority-interactive-channel-base>.out'
# 'Base penalty for splitting cold code (as a multiple of TCC_Basic)'
H9A157E9C325A: '冷代码拆分的基础惩罚值（作为TCC_Basic的倍数）'
# 'Base types (int, bool, etc.).'
H6DA8FED6F2CE: '基本类型（int、bool等）。'
# 'Basic Alias Analysis (stateless AA impl)'
H5B13D0BE4C70: '基础别名分析（无状态AA实现）'
# 'Basic Block Frequency'
H288285DDFDA1: '基本块频率'
# 'Basic Block Placement Stats'
H907EA5CFB1D6: '基本块放置统计'
# 'Basic Register Allocator'
H79DC6E995B15: '基础寄存器分配器'
# 'Basic algebraic expansions of complex arithmetic operations involving are disabled.'
HDF7A39346B61: '涉及复数算术运算的基本代数展开已禁用。'
# 'Basic algebraic expansions of complex arithmetic operations involving are enabled.'
H262F35B467F4: '涉及复数算术运算的基本代数展开已启用。'
# 'Basic attributes alias.'
HE45CB3A77EAA: '基本属性别名。'
# 'Basic block limit for a function for RDF optimizations'
H4FCE83C0EE11: 'RDF优化时函数的基本块限制'
# 'Basic block.'
H0E36AB3035D5: '基本块。'
# 'Basic register allocator'
HAA9EC9D57F33: '基本寄存器分配器'
# 'Be more conservative in ARM load/store opt'
HDDB9289EB602: '在ARM的加载/存储优化中更加保守'
# 'Before everything'
HD2BEA8D1D530: '在最前面'
# 'Best scheduler for the target'
H5C9427319FEA: '目标的最佳调度器'
# 'Binary encoding'
H2B45E735D11B: '二进制编码'
# 'Binary encoding (default)'
H75E6792272B3: '二进制编码（默认）'
# 'BinaryAnalysis\n'
HC08403F87EF1: '二进制分析\n'
# 'BinaryAnalysis options'
H0030C9E3CDAC: '二进制分析选项'
# 'Bit simplification'
HD2769EDD49F1: '位简化'
# 'Bit size of immediate TLS offsets'
HE94155328C5F: 'TLS偏移量的立即数位大小'
# 'Bitstream'
HA8A9704FB47E: '比特流'
# 'Bitwidth of the index type for the host (warning this should be 64 until the GPU layering is fixed)'
H1A2F700B75FE: '主机索引类型的位宽（警告：在GPU分层修复之前应为 64）'
# 'Block Frequency Analysis'
H0F710FC006A0: '块频率分析'
# 'Block frequency percentage a loop exit block needs over the original exit to be considered the new exit.'
H1B72423F0425: '循环出口块需要相对于原始出口的块频率百分比，以被视为新出口'
# 'Block until the parser can be used'
H1C8FDBE8C1C0: '直到解析器可以使用时解除阻塞'
# 'Bottom-up register pressure aware list scheduling which tries to balance ILP and register pressure'
H9D996A6F7F40: '自底向上感知寄存器压力的列表调度，试图平衡指令级并行（ILP）和寄存器压力'
# 'Bottom-up register pressure aware list scheduling which tries to balance latency and register pressure'
H394C581D41AA: '自底向上感知寄存器压力的列表调度，试图平衡延迟和寄存器压力'
# 'Bottom-up register reduction list scheduling'
H669DA6589497: '自底向上寄存器缩减列表调度'
# 'Bound on stack depth while inlining (4 by default)'
H517AFAFA9D42: '内联时栈深度的上限（默认 4）'
# 'Bound the dependence analysis by a maximal amount of computational steps (0 means no bound)'
H649A261EB1B0: '通过最大计算步骤数限制依赖分析（0表示无限制）'
# 'Bound the scheduler by maximal amountof computational steps. '
H51E6C0F8C158: '通过最大计算步骤数限制调度器'
# 'Bound the scop analysis by a maximal amount of computational steps (0 means no bound)'
H82EB650E9442: '通过最大计算步骤数限制scop分析（0表示无限制）'
# 'Branch Coalescing'
H2DBEA167A999: '分支合并'
# 'Branch Probability'
HC336B7481E8C: '分支概率'
# 'Branch Probability Analysis'
HE38E9B0A525A: '分支概率分析'
# 'Branch Probability Basic Block Placement'
H87FA8A5489AA: '分支概率基本块放置'
# 'Branch relaxation pass'
H6AFFC7671D8D: '分支松弛优化pass'
# 'Break backedge through symbolic execution of 1st iteration attempting to prove that the backedge is never taken'
HE2539A780F40: '通过第一个迭代的符号执行来断开后跳边，试图证明该后跳边永远不会被使用'
# 'Break critical edges in CFG'
HD9D1E732D541: '在控制流图中分解关键边'
# 'Break large PHI nodes for DAGISel'
HCF5413A8839F: '分解DAGISel的大型PHI节点'
# 'Break post-RA scheduling anti-dependencies: "critical", "all", or "none"'
H75472E865DE3: "断开寄存器分配后调度的反依赖关系：'critical'、'all' 或 'none'"
# 'BreakFalseDeps'
H5FF559A5250F: '消除虚假依赖'
# 'Breakdown the count by function name taking into consideration the filepath info from the DebugLoc of the remark.'
HC1EFEB5BC743: '按函数名细分计数，考虑来自remark的DebugLoc的文件路径信息。'
# 'Breakdown the count by function name.'
H55D8DD7267D8: '按函数名细分计数。'
# 'Bucket number per loop for PPC loop chain common'
H095EE2A27794: '每个循环的PPC循环链公共桶数量'
# 'Buffer the last N characters of debug output until program termination. [default 0 -- immediate print-out]'
HEA243B6BB971: '在程序终止前缓冲调试输出的最后N个字符。[默认 0 —— 立即输出]'
# "BugPoint Test Pass - Intentionally 'misoptimize' CallInsts"
H89AAE42B7AE6: "BugPoint 测试 Pass - 故意对 CallInsts '误优化'"
# 'BugPoint Test Pass - Intentionally crash on CallInsts'
HDE32B6B83F4F: 'BugPoint 测试 Pass - 在 CallInsts 上故意崩溃'
# 'BugPoint Test Pass - Intentionally crash on declared functions'
H42F2EE82DA8D: 'BugPoint 测试 Pass - 在声明的函数上故意崩溃'
# 'BugPoint Test Pass - Intentionally crash on fabs calls with fpmath metadata and an fadd as argument'
H1E926C1BB889: 'BugPoint 测试 Pass - 在带有 fpmath 元数据且参数为 fadd 的 fabs 调用上故意崩溃'
# "BugPoint Test Pass - Intentionally crash on function attribute 'bugpoint-crash'"
H05C0FF4CFB70: 'BugPoint 测试 Pass - 在函数属性 "bugpoint-crash" 上故意崩溃'
# 'BugPoint Test Pass - Intentionally crash on too many CUs'
H8C6E2ED6A47E: 'BugPoint 测试 Pass - 在编译单元过多时故意崩溃'
# 'Build ASTs and convert to LLVM, discarding output'
HFD98A9A1FB1A: '构建AST并转换为LLVM IR，丢弃输出'
# 'Build ASTs and print the list of declaration node qualified names'
HCB31A5A33A8E: '构建AST并打印声明节点的限定名列表'
# 'Build ASTs and then debug dump their name lookup tables'
HB898C7F894F2: '构建AST后调试转储其名称查找表'
# 'Build ASTs and then debug dump them'
H7902F2D13330: '构建AST后进行调试转储'
# 'Build ASTs and then debug dump them in the specified format, forcing deserialization. Supported formats include: default, json'
HE96A00FC958F: '以指定格式强制反序列化后转储AST，支持格式包括：default、json'
# 'Build ASTs and then debug dump them in the specified format. Supported formats include: default, json'
H92BA7F1490EF: '以指定格式转储AST，支持格式包括：default、json'
# 'Build ASTs and then debug dump them, forcing deserialization'
HEE028C067F24: '强制反序列化后转储AST'
# 'Build ASTs and then lower to ClangIR'
HDF4F258BFB65: '构建AST后转换为ClangIR'
# 'Build ASTs and then pretty-print them'
H9599366C5CC9: '构建AST并格式化输出'
# 'Build ASTs and view them with GraphViz'
H03B49E6509AA: '构建AST并通过GraphViz可视化'
# 'Build ASTs then convert to LLVM, emit .bc file'
H3D999491C902: '构建AST后转换为LLVM IR，输出.bc文件'
# 'Build VPlan for every supported loop nest in the function and bail out right after the build (stress test the VPlan H-CFG construction in the VPlan-native vectorization path).'
HE361DC02BCE3: '为函数中每个支持的循环嵌套构建VPlan，并在构建后立即退出（在VPlan原生向量化路径中对VPlan H-CFG构造进行压力测试）'
# 'Build a C++20 Header Unit from a header'
H9A493A45835C: '从头文件构建C++20头单元'
# 'Build a C++20 Header Unit from a header that should be found in the user (fmodule-header=user) or system (fmodule-header=system) search path.'
H0DC1129B500A: '从头文件构建C++20头单元，该头文件应位于用户(fmodule-header=user)或系统(fmodule-header=system)搜索路径下'
# 'Build for HVX v60'
H5F194250AE06: '为HVX v60构建'
# 'Build for HVX v62'
HAFED34899A8C: '为HVX v62构建'
# 'Build for HVX v65'
H207B9B2D5225: '为HVX v65构建'
# 'Build for HVX v66'
HEA3895BB213D: '为HVX v66构建'
# 'Build for HVX v67'
H42B647301419: '为HVX v67构建'
# 'Build for HVX v68'
H77FF21179BCC: '为HVX v68构建'
# 'Build for HVX v69'
H905F9940179D: '为HVX v69构建'
# 'Build for HVX v71'
H165F94AD0A42: '为HVX v71构建'
# 'Build for HVX v73'
H67E019A7BE26: '为HVX v73构建'
# 'Build for HVX v75'
HEB883439B283: '为HVX v75构建'
# 'Build for HVX v79'
H231DD2C4D603: '为HVX v79构建'
# 'Build for Hexagon V5'
H1C71E9B94F5C: '构建Hexagon V5版本'
# 'Build for Hexagon V55'
H58046BC87A11: '构建Hexagon V55版本'
# 'Build for Hexagon V60'
H05D6BD8DE043: '构建Hexagon V60版本'
# 'Build for Hexagon V62'
H397E863A80C2: '构建Hexagon V62版本'
# 'Build for Hexagon V65'
HD1EC00E09426: '构建Hexagon V65版本'
# 'Build for Hexagon V66'
HE5554963D68F: '构建Hexagon V66版本'
# 'Build for Hexagon V67'
H87AB7CC8B603: '构建Hexagon V67版本'
# 'Build for Hexagon V67T'
HB3C7C60D0839: '构建Hexagon V67T版本'
# 'Build for Hexagon V68'
H712B082469B0: '构建Hexagon V68版本'
# 'Build for Hexagon V69'
H33FDB62409F4: '为Hexagon V69构建'
# 'Build for Hexagon V71'
HF8AB85CAF9EB: '为Hexagon V71构建'
# 'Build for Hexagon V71T'
H6AC6FBE66236: '为Hexagon V71T构建'
# 'Build for Hexagon V73'
H7840346BDBBB: '为Hexagon V73构建'
# 'Build for Hexagon V75'
HB923BD289BC7: '为Hexagon V75构建'
# 'Build for Hexagon V79'
H860D9669E777: '为Hexagon V79构建'
# 'Build path'
H51B665BD227F: '构建路径'
# 'Build the parse tree, then lower it to FIR'
H5AA5D4111927: '构建解析树后转换为FIR'
# 'Build the parse tree, then lower it to HLFIR'
H209B3028A0CD: '构建解析树后转换为HLFIR'
# 'Build this module as a system module. Only used with -emit-module'
HF896829DCA95: '将此模块作为系统模块构建。仅在使用-emit-module时生效'
# 'Bundle Machine CFG Edges'
H7815BA6F9789: '捆绑机器控制流图边'
# 'Bundle output files of HIP device compilation'
HCA7306204A95: '打包HIP设备编译的输出文件'
# 'Burnside Bridge Compiler\n'
H5B149431AA40: 'Burnside Bridge 编译器\n'
# 'By default, we analyze the benchmarks for the triple/CPU they were measured for, but if you want to analyze them for some other combination (specified via -mtriple/-mcpu), you can pass this flag.'
H76350EEAD124: '默认情况下，我们为基准测试所测量的 triple/CPU 分析基准测试，但如果要分析其他组合（通过 -mtriple/-mcpu 指定），可以传递此标志。'
# 'Bypass the profitability model of load slicing'
H3E3A7818BD1C: '绕过负载切片的效益模型'
# 'C does not support default arguments'
H9634D9BB0DF6: 'C不支持默认参数'
# 'C requires #line number to be less than %0, allowed as extension'
H2FF7FD761591: 'C要求#line的行号小于 %0，作为扩展允许'
# 'C requires a comma prior to the ellipsis in a variadic function type'
HF2B9DE1954B1: 'C需要在可变函数类型中的省略号前有逗号'
# "C++ ABI '%0' is not supported on target triple '%1'"
H00336F051C87: "C++ ABI '%0' 在目标三元组 '%1' 上不受支持"
# 'C++ ABI to use. This will override the target C++ ABI.'
H9B471B29FD3A: '使用的C++ ABI。此选项将覆盖目标C++ ABI'
# 'C++ implementation file name'
HE4F416D1C66F: 'C++ 实现文件名称'
# 'C++ operator %0 (aka %1) used as a macro name'
H2A2A24E029F0: 'C++运算符 %0（别名 %1）被用作宏名'
# 'C++ standard library to use'
HEE4D104DB34B: '使用的C++标准库'
# 'C++11 only allows consecutive left square brackets when introducing an attribute'
H2040F8CA0C12: 'C++11仅允许在引入属性时连续使用左方括号'
# 'C++98 requires an accessible copy constructor for class %2 when binding a reference to a temporary; was %select{private|protected}0'
H89F3A4330FF6: 'C++98要求当绑定到临时对象时，类 %2 需要可访问的拷贝构造函数；当前是 %select{private|protected}0'
# 'C99 forbids casting nonscalar type %0 to the same type'
H26E6559D43AC: 'C99禁止将非标量类型 %0 显式转换为自身'
# 'C99 forbids conditional expressions with only one void side'
HD3A412BC601A: 'C99 禁止只带有单个 void 类型操作数的条件表达式'
# 'CF object of type %0 is bridged to %1, which is not an Objective-C class'
H41EE49AD057C: '类型 %0 的CF对象被桥接到非Objective-C类 %1'
# 'CFGuard'
H6826B8A9825A: 'CFGuard保护'
# 'CFI Verify Options'
H72E6B238AC79: 'CFI验证选项'
# 'CFString literal is not a string constant'
H89C093890935: 'CFString 字面量不是字符串常量'
# 'CHR considers a branch bias greater than this ratio as biased'
HDF87AB6569F2: 'CHR 将超过此比率的分支偏向视为有偏向'
# 'CHR merges a group of N branches/selects where N >= this value'
H5C657F973B2B: '当 N >= 该值时，CHR 合并一组 N 个分支/选择语句'
# 'CIR module verification error before running CIR-to-CIR passes'
H045DC8C3B34D: '运行 CIR-to-CIR 之前 CIR 模块验证失败'
# 'CIR-to-CIR transformation failed'
H9F8DAC16F05E: 'CIR-to-CIR 转换失败'
# 'CL.EXE COMPATIBILITY OPTIONS'
H505EEFB93C8E: 'CL.EXE 兼容性选项'
# 'COFF Symbol RVAs (DEBUG_S_COFF_SYMBOL_RVA subsection)'
HFE26A86E5CFD: 'COFF符号RVA（DEBUG_S_COFF_SYMBOL_RVA子部分）'
# "CPU '%0' does not support '%1' execution mode"
H489FB3B6F514: "CPU '%0' 不支持 '%1' 执行模式"
# 'CPU list contains duplicate entries; attribute ignored'
H40F374760829: 'CPU 列表包含重复条目；属性被忽略'
# 'CSKY DAG->DAG Pattern Instruction Selection'
H21AAA3835725: 'CSKY DAG->DAG 模式指令选择'
# 'CSKY constant island placement and branch shortening pass'
H1AC93DA4EF44: 'CSKY常量岛屿放置与缩短跳转指令pass'
# 'CSS stylesheets to extend the default styles.'
H9DE4F76128DB: '扩展默认样式的 CSS 样式表。'
# 'CSV format'
H6111A3501F49: 'CSV格式'
# 'CUDA device code does not support va_arg'
H3A59FE235409: 'CUDA 设备代码不支持 va_arg'
# 'CUDA device code does not support variadic functions'
H218B98CDADDE: 'CUDA 设备代码不支持可变参数函数'
# 'CUDA does not support global %0 for __device__ functions'
H8DC2F94408E4: 'CUDA 不支持在 __device__ 函数中使用全局 %0'
# 'CUDA installation path'
H42DE34B3E373: 'CUDA安装路径'
# 'CUDA offload target is supported only along with --emit-llvm'
H1424A8C5858B: 'CUDA offload 目标需与 --emit-llvm 选项同时使用'
# 'CUDA older than 10.0 does not support .alias'
H4BD47BC9C21A: '10.0 之前的 CUDA 版本不支持 .alias'
# "CUDA special function '%0' must have scalar return type"
H4386F29D7C1C: "CUDA 特殊函数 '%0' 必须有标量返回类型"
# 'CUDA version %0 is only partially supported'
HABB5F3AD45B9: 'CUDA 版本 %0 仅部分支持'
# 'CUDA version%0 is newer than the latest%select{| partially}1 supported version %2'
HC8470F3A3C10: 'CUDA 版本 %0 比最新 %select{| 部分}1 支持的版本 %2 更新'
# 'CXX Dump Options'
HEC70FF6EBB76: 'CXX转储选项'
# 'CXX Map Options'
H4ACF6390C9B8: 'CXX映射选项'
# 'Cache Directory'
HBD7A05972161: '缓存目录'
# 'Calculate the intrinsic cost based only on argument types'
H204B60BE4CD1: '仅根据参数类型计算固有函数的开销'
# 'Call nonlazybind functions via direct GOT load for Mach-O'
H734541906E0F: '对于 Mach-O 使用直接 GOT 加载调用 nonlazybind 函数'
# 'Call penalty that is applied per callsite when inlining'
HF8A8A3618DB8: '内联时每个调用点应用的调用惩罚值'
# 'Call score power (when --split-strategy=cdsplit)'
H657B2E4D7127: '调用得分幂次（当 --split-strategy=cdsplit 时）'
# 'Call score scale coefficient (when --split-strategy=cdsplit)'
H3C68D9A52C2C: '调用得分缩放系数（当 --split-strategy=cdsplit 时）'
# 'Call site block.'
H1A44C6CE10A5: '调用站点块。'
# 'Call site parameter.'
H13AFDEB70D71: '调用站点参数。'
# 'CallGraph Construction'
H59F475A8E976: '调用图构建'
# 'Can specify at most '
H04A2B40FE103: '最多可以指定 '
# 'Canonicalize Freeze Instructions in Loops'
HA0687B0F1DED: '在循环中规范冻结指令'
# 'Canonicalize natural loops'
H36CFB482F86F: '规范自然循环'
# 'Capture the number of times a stack was invoked. In flamegraph mode, this count also includes invocations of all callees.'
HC70FACC6E899: '捕获栈被调用的次数。在火焰图模式下，此计数还包括所有被调用者的调用次数。'
# 'Capture the total time spent in an all invocations of a stack.'
H44E274E610C2: '捕获栈所有调用中的总耗时。'
# 'Causes the backend to crash instead of generating a nop VSX copy'
H3232545B99E1: '导致后端在生成 nop VSX 复制时崩溃'
# 'Change byte and word instructions to larger sizes'
HEF144CF00477: '将字节和字指令改为更大尺寸'
# 'Change diagnostic formatting to match IDE and command line tools'
H8A6273359475: '修改诊断信息格式以匹配IDE和命令行工具'
# 'Change indirect jump instructions to inhibit speculation'
H3608CF11CF48: '修改间接跳转指令以抑制推测执行'
# 'Change namespace.'
H43653D361A25: '更改命名空间。'
# 'Change the C++ ABI to returning `this` pointer from constructors and non-deleting destructors. (No effect on Microsoft ABI)'
H33EEEB0B1310: '修改C++ ABI以使构造函数和非删除型析构函数返回`this`指针。 (对Microsoft ABI无影响)'
# "Change the greedy register allocator's live range priority calculation to make the AllocationPriority of the register class more important then whether the range is global"
H8D990FD681E2: '更改贪婪寄存器分配器的存活区间优先级计算方式，使寄存器类的AllocationPriority比全局区间更重要'
# 'Change variadic calling convention'
HD4EADD7ABB24: '更改可变参数调用约定'
# 'Check CFA info and insert CFI instructions if needed'
HB1FAB917FF49: '检查CFA信息并在需要时插入CFI指令'
# 'Check all diagnostics (expected, unexpected, near-misses)'
HDD500F45AE52: '检查所有诊断信息（期望、未期望、接近匹配）'
# 'Check debug info from -debugify'
H8AF6D59AB27A: '检查 -debugify 生成的调试信息'
# 'Check debug info from -debugify-function'
HE67C041D8BED: '检查 -debugify-function 生成的调试信息'
# 'Check elements integrity.'
HEA4B7C7680A0: '检查元素完整性。'
# 'Check floating-point load'
H7623BFCEEC52: '检查浮点加载'
# 'Check floating-point return values'
H59EBDCF68E8C: '检查浮点返回值'
# 'Check floating-point stores'
H27184F67D1D6: '检查浮点存储'
# 'Check for parallel loops'
H86C1DC29F0D4: '检查并行循环'
# 'Check for vectorizable loops'
H3CD8604AF754: '检查可向量化循环'
# 'Check if block frequency is queried for an unknown block for debugging missed BFI updates'
H105B69431A40: '检查是否为未知块查询块频率以调试缺失的BFI更新'
# 'Check if input heterogeneous archive is valid in terms of TargetID rules.\n'
HA0A80D536062: '根据TargetID规则验证输入异构归档文件的有效性。\n'
# 'Check module hash using the argument as a string table'
H43F3CCEA9F64: '使用参数作为字符串表验证模块哈希'
# 'Check only expected diagnostics'
H1D795C0D9F5F: '仅检查期望诊断信息'
# 'Check pointer authentication auth/resign failures'
HBEEB7E32E077: '检查指针认证的auth/resign失败'
# 'Check stack-use-after-scope'
H899C3D082FBF: '检查栈作用域后使用'
# 'Check that emitted diagnostics match expected-* lines on the corresponding line'
H0CFA18038D08: '检查生成的诊断信息是否与对应行的expected-*行匹配'
# 'Check the input source files from C++20 modules explicitly'
HA2774E416A4F: '显式检查C++20模块中的输入源文件'
# 'Chip to use to serialize to cubin.'
H07B7361E60E0: '用于序列化到cubin的芯片类型。'
# 'Choose DWARF debug sections compression:'
H2B65135A807B: '选择DWARF调试节压缩方式：'
# 'Choose a file type (not all types are supported by all targets):'
HAA6114F47F11: '选择文件类型（并非所有类型都受所有目标支持）：'
# 'Choose an output file type:'
H92BDEF215C75: '选择输出文件类型：'
# 'Choose analyzer checkers to disable'
H77983530DA75: '选择要禁用的分析器检查项'
# 'Choose analyzer checkers to enable'
H41B48112BDF6: '选择要启用的分析器检查项'
# 'Choose analyzer options to enable'
HCB7427D52FDE: '选择要启用的分析器选项'
# 'Choose code model'
HA2B6154EBE1C: '选择代码模型'
# 'Choose float ABI type'
HA37D38E85873: '选择浮点ABI类型'
# 'Choose large data threshold for x86_64 medium code model'
HE1DFA96AAF80: '为x86_64中等代码模型选择大数据阈值'
# 'Choose level of diagnostic information'
HD8EA761DDF80: '选择诊断信息详细程度'
# 'Choose relocation model'
HD54EDB40A370: '选择重定位模型'
# 'Choose speculation scheme'
HCB6C8E99AC45: '选择推测方案'
# 'Choose style of NEON code to emit from AArch64 backend:'
H2D6E1D10E2D8: '选择AArch64后端生成的NEON代码风格：'
# 'Choose the OpenMP library to use:'
HE50F5292F771: '选择要使用的OpenMP库：'
# 'Choose the dynamic linker/loader.'
H10D084FE139A: '选择动态链接器/加载器。'
# 'Choose the number of compile threads (jit-kind=orc-lazy only)'
H098814BE3E37: '选择编译线程数（仅适用于jit-kind=orc-lazy）'
# 'Choose the priority mode to use in module inline'
H3DB5A6B44603: '选择模块内联中使用的优先级模式'
# 'Choose the report output format:'
HAA84783D1EFB: '选择报告输出格式：'
# 'Choose the strategy to replace exit value in IndVarSimplify'
H3B106241E759: '选择在IndVarSimplify中替换退出值的策略'
# 'Choose threading model'
HC20B03302377: '选择线程模型'
# 'Choose to use MD5 to represent string in name table (only meaningful for -extbinary)'
H2AF20046DB81: '选择在名称表中使用MD5表示字符串（仅对-extbinary有意义）'
# 'Choose underlying JIT kind.'
HCA7AB9E73E1E: '选择底层JIT类型。'
# 'Chunksize to use by the OpenMP runtime calls'
H9BE7E3A1146E: 'OpenMP运行时调用使用的块大小'
# "Clang permits use of type 'double' regardless pragma if 'cl_khr_fp64' is supported"
H36E837B04A86: "如果支持 'cl_khr_fp64' 扩展，Clang将允许使用类型 'double' 而忽略pragma"
# 'Clang-format options'
H5807AFA36D8E: 'Clang格式化选项'
# 'ClangIR code gen Not Yet Implemented: %0'
HC54E3E6A2065: 'ClangIR 代码生成尚未实现: %0'
# 'ClangIR code gen Not Yet Implemented: %0: %1'
H56E1FD5A9575: 'ClangIR 代码生成尚未实现: %0: %1'
# 'ClangIR: Disable MLIR module verifier'
H751870E4D956: 'ClangIR：禁用MLIR模块验证器'
# 'Class definition format'
HDB879BF08A12: '类定义格式'
# 'Class recursion depth (0=no limit)'
HB9C55ABE5CC8: '类递归深度（0=no limit）'
# 'Class sort order'
H85CBA379BBF6: '类排序顺序'
# 'Class, Structure or Union.'
H496FA9D4B718: '类、结构体或联合。'
# 'Class.'
H148765CD0A8E: '类。'
# 'Cleanup of TFRs/COPYs'
H9B2D2779E91B: '清理TFRs/COPYs'
# 'Clear call-used registers upon function return (AArch64/x86 only)'
H477A7A2C3A31: '函数返回时清除调用使用的寄存器（仅适用于AArch64/x86）'
# 'Clear the Clang AST before running backend code generation'
H25C2CBF7F396: '在运行后端代码生成前清除Clang的AST'
# 'Clearance between two register writes for inserting XOR to avoid partial register update'
H72C3AC434C02: '插入XOR以避免部分寄存器更新的两次寄存器写入之间的间隔'
# 'Clone multicolor basic blocks but do not demote cross scopes'
H6C8216BC2E37: '复制多颜色基本块但不降级跨作用域'
# 'Coalesce copies (default=true)'
H8F39652946C0: '合并复制（默认=true）'
# 'Coalesce copies by rescheduling (default=true)'
H0B50CD5328B9: '通过重新调度合并拷贝（默认=true）'
# 'Coalesce copies on split edges (default=subtarget)'
H9B11258186AA: '在分裂边合并拷贝（默认=subtarget）'
# 'Coalesce copies that span blocks (default=subtarget)'
H60E87F9D68CA: '合并跨越块的拷贝（默认=subtarget）'
# 'Code and read-only data relocatable, accessed PC-relative'
H7787A55DE1DB: '可重定位代码和只读数据，通过PC相对访问'
# 'Code growth limit for address mode optimization'
H68CE7F106A6D: '地址模式优化的代码增长限制'
# 'Code sinking'
H7049DF5F2CFA: '代码下沉'
# 'Code size'
H555486354DDF: '代码大小'
# 'Code size and latency'
H66FA420C1EB1: '代码大小和延迟'
# 'CodeGen (expected to match llc)'
HD2FDC55840F0: '代码生成（应与llc匹配）'
# "Codegen optimization level (0, 1, 2 or 3, default = '2')"
H0604F43896B4: "代码生成优化级别（0、1、2或 3，默认='2'）"
# 'Collect access count histograms'
HEFDB6DB25681: '收集访问计数直方图'
# 'Collect control flow of function'
HECF6D002A2F5: '收集函数的控制流'
# 'Collect probability-driven block placement stats'
H3B3A74A7C1CA: '收集概率驱动的块放置统计信息'
# "Collect these seeds. Use empty for none or a comma-separated list of '"
H6FDC6608AD13: "收集这些种子。使用空表示无，或逗号分隔的列表：'"
# 'Collects information ahead of time for MC lowering'
H247A53130B24: '提前收集机器代码（MC）降级所需的信息'
# 'Color Options'
HF1A7AFA23440: '颜色选项'
# 'Color for dot-cfg after elements'
HE6BC004D0C08: 'Dot-cfg后元素的颜色'
# 'Color for dot-cfg before elements'
HCBAF257C085C: 'Dot-cfg前元素的颜色'
# 'Color for dot-cfg common elements'
H49F473D0D7F3: 'Dot-cfg公共元素的颜色'
# 'Colored disassembly of strings of hex bytes'
H4E6D0548B4D8: '十六进制字节字符串的彩色反汇编'
# 'Combination of ropi and rwpi'
HFA6236DECFF7: 'ropi和rwpi的组合'
# 'Combine AArch64 MachineInstrs after legalization'
HD7E343321E16: '在合法化之后合并AArch64机器指令'
# 'Combine AArch64 machine instrs before legalization'
H4D22AAB36024: '在合法化之前合并AArch64机器指令'
# 'Combine AMDGPU machine instrs after legalization'
H2FD87CC8B39B: '在合法化之后合并AMDGPU机器指令'
# 'Combine AMDGPU machine instrs after regbankselect'
H372E81B03355: '在regbankselect之后合并AMDGPU机器指令'
# 'Combine AMDGPU machine instrs before legalization'
H6682D3768EA0: '在合法化之前合并AMDGPU机器指令'
# 'Combine Mips machine instrs after legalization'
HA03CAB5DCA3D: '在合法化之后合并Mips机器指令'
# 'Combine Mips machine instrs before legalization'
H7EFE7A48A439: '在合法化之前合并Mips机器指令'
# 'Combine RISC-V MachineInstrs after legalization'
H4BDB10B3DC9C: '在合法化之后合并RISC-V机器指令'
# 'Combine RISC-V machine instrs before legalization'
H358426A68073: '在合法化之前合并RISC-V机器指令'
# 'Combine SPIRV machine instrs before legalization'
H7E2252FE6075: '在合法化之前合并SPIRV机器指令'
# 'Combine ext and trunc to TBL'
H8DCB8DB3D191: '将ext和trunc合并为TBL'
# 'Combine extends of AArch64 masked gather intrinsics'
HF9B54CB5AC6B: '合并 AArch64 掩码 gather 内建函数的扩展'
# 'Combine interleaved loads into wide loads and shufflevector instructions'
HC7C7ED4923BB: '将交错加载合并为宽加载和shufflevector指令'
# 'Combine redundant instructions'
H6A7B591C5F01: '合并冗余指令'
# 'Combine the label of the offset with the label of the pointer when doing pointer arithmetic.'
HB7BD5BAE0A94: '在进行指针算术时，将偏移量的标签与指针的标签合并'
# 'Combine the label of the pointer with the label of the data when loading from memory.'
H4B6E43BF4FF7: '在从内存加载时，将指针的标签与数据的标签合并'
# 'Combine the label of the pointer with the label of the data when storing in memory.'
H66A9D747B5EF: '在内存存储时，将指针的标签与数据的标签合并'
# 'Comma separated list of attribute names that are allowed to be seeded.'
H725610B9DAC4: '允许的属性名称的逗号分隔列表'
# 'Comma separated list of debug counter skip and count'
H9FAFDA93ACE1: '调试计数器跳过和计数参数的逗号分隔列表'
# 'Comma separated list of debug counter skip and count arguments'
H6FCA88B30FCF: '调试计数器跳过和计数参数的逗号分隔列表'
# 'Comma separated list of files containing a new line separated list of API symbols to ignore when extracting API information.'
H4521BA006280: '逗号分隔的文件列表，每个文件包含按换行分隔的API符号（在提取API信息时需忽略的）'
# 'Comma separated list of function names that are allowed to be seeded.'
HD18F456FDFD5: '允许的函数名称的逗号分隔列表'
# 'Comma separated list of functions to replace with native, or all'
HFF9C64BB9821: '用逗号分隔的函数列表，用于替换为原生实现，或指定all'
# 'Comma separated list of globs for white-listing gcc-compatible drivers that are safe to execute. Drivers matching any of these globs will be used to extract system includes. e.g. /usr/bin/**/clang-*,/path/to/repo/**/g++-*'
H454E7FBEF67B: '用逗号分隔的通配符列表，用于白名单筛选安全执行的与gcc兼容的驱动程序。匹配这些通配符的驱动程序将用于提取系统包含路径。例如：/usr/bin/**/clang-*,/path/to/repo/**/g++-*'
# 'Comma separated list of locations to filter actions from logging'
H089CBD249A00: '要从日志中过滤操作的位置列表，用逗号分隔'
# "Comma-separated list of comment prefixes to use from check file\n(defaults to 'COM,RUN'). Please avoid using this feature in\nLLVM's LIT-based test suites, which should be easier to\nmaintain if they all follow a consistent comment style. This\nfeature is meant for non-LIT test suites using FileCheck."
H40AA0BE08629: "来自检查文件的注释前缀列表，用逗号分隔（默认为 'COM,RUN'）。请避免在LLVM的基于LIT的测试套件中使用此功能，这些套件应遵循一致的注释风格以便维护。此功能专为使用FileCheck的非LIT测试套件设计。"
# "Comma-separated list of globs describing the list of callbacks to output. Globs are processed in order of appearance. Globs with the '-' prefix remove callbacks from the set. e.g. '*,-Macro*'."
HB2EA0F3C4C38: '用通配符描述的回调列表，按出现顺序处理。带 "-" 前缀的通配符将从集合中移除回调。例如：*,-Macro*'
# 'Comma-separated list of vectorizer passes. If not set we run the predefined pipeline.'
H5F9267E8F02A: '向量化pass的逗号分隔列表。若未设置则运行预定义管线。'
# 'Command line options to pass to the downstream compiler.'
H24FC3F9175A2: '传递给下游编译器的命令行选项。'
# 'Command to compile the bitcode (use with -compile-custom) (default: llc)'
H3748E1E74688: '编译比特码的命令（与-compile-custom一起使用，默认值：llc）'
# 'Command to execute and then exit.'
H9D395E8BC35F: '执行并退出的命令。'
# 'Command to execute the bitcode (use with -run-custom) (default: simulate)'
H8B8E553AB463: '执行比特码的命令（与-run-custom一起使用，默认值：simulate）'
# 'CommonOptionsParser: failed to parse command-line arguments. '
H6D048D13358D: 'CommonOptionsParser: 无法解析命令行参数。'
# 'Compare Options'
H10812CD37717: '比较选项'
# 'Compare all elements.'
HD1160DBAE7C6: '比较所有元素。'
# 'Compare bits 62 and 61 of address (TBI should be disabled)'
HC1881DEFBF5A: '比较地址的第 62 和 61 位（应禁用TBI）'
# 'Compare with the result of XPAC (requires Armv8.3-a)'
HBA5A269FECBF: '与XPAC的结果进行比较（需要Armv8.3-a）'
# 'Compare with the result of XPACLRI'
HAAF036306B3E: '与XPACLRI的结果进行比较'
# 'Compilation YAML databases containing additional compilation information for .pdll files'
HE9807E72350C: '包含.dll文件附加编译信息的YAML数据库'
# 'Compilation YAML databases containing additional compilation information for .td files'
HFBD096AE492B: '包含.td文件附加编译信息的YAML数据库'
# 'Compilation format to use to serialize to cubin.'
HB1FF55993026: '用于序列化到cubin的编译格式。'
# 'Compile CUDA code for both host and device (default). Has no effect on non-CUDA compilations.'
H77D43CB7BF77: '为宿主和设备编译CUDA代码（默认）。对非CUDA编译无影响。'
# 'Compile CUDA code for device only'
H15DCB9A13744: '仅编译CUDA代码到设备'
# 'Compile CUDA code for host only. Has no effect on non-CUDA compilations.'
H0F42A4E8A53F: '仅编译CUDA代码到宿主。对非CUDA编译无影响。'
# 'Compile HIP source to relocatable'
HDC4174A29E78: '将HIP源代码编译为可重定位代码'
# 'Compile SYCL code for device only'
HC13E70999744: '仅编译SYCL代码到设备'
# 'Compile SYCL code for host only. Has no effect on non-SYCL compilations'
HEB697C17E8BD: '仅编译SYCL代码到宿主。对非SYCL编译无影响。'
# "Compile all functions that don't use floating point as Mips 16"
H5CC84DC9C7B5: '将不使用浮点运算的所有函数编译为Mips 16'
# 'Compile common globals like normal definitions'
HD71FBB30E436: '将公共全局变量视为普通定义进行编译'
# 'Compile for both the offloading host and device (default).'
H9A1D25E1163E: '为卸载宿主和设备同时编译（默认）'
# 'Compile only'
H8E8E6B258925: '仅编译'
# 'Compile unit.'
HD0B9CF45B690: '编译单元。'
# 'Compile with LLC'
H0F009B4F1879: '使用LLC编译'
# 'Compile with LLC with integrated assembler'
HEC7B02DFBAC4: '使用集成汇编器的LLC编译'
# 'Compiler generated elements.'
HCD76E8AFE5EE: '编译器生成的元素。'
# 'Compiler runtime library to use'
H8A88FADF9B7C: '要使用的编译器运行时库'
# 'Compiler to use for DTLTO ThinLTO backend compilations.'
H870FEFEAA364: '用于DTLTO ThinLTO后端编译的编译器'
# 'Complex Deinterleaving'
H7404ACD7E023: '复杂去交错'
# 'Compress all sections when writing the profile (only meaningful for -extbinary)'
HCB671C4254BD: '在写入分析资料时压缩所有段（仅对-extbinary有意义）'
# 'Compress offload device binaries (HIP only)'
H500BC9AF0B40: '压缩卸载设备的二进制文件（仅HIP）'
# 'Compress output file when bundling.\n'
HFEA3EDE7947A: '打包时压缩输出文件。\n'
# 'Compressing recursion by deduplicating adjacent frame sequences up to the specified size. -1 means no size limit.'
H30029AFB7F05: '通过合并相邻的帧序列来压缩递归深度，最多合并到指定大小。-1表示无大小限制。'
# 'Compression level for offload device binaries (HIP only)'
HAD420748A1D9: '卸载设备二进制文件的压缩级别（仅HIP）'
# 'Compute and report stale profile statistical metrics.'
H8415583C1A20: '计算并报告过时分析数据的统计指标。'
# "Compute and store the hash of input files used to build an AST. Files with mismatching mtime's are considered valid if both contents is identical"
H9585117CC641: '计算并存储用于构建AST的输入文件的哈希。如果文件内容相同，即使mtime不同，也被视为有效'
# 'Compute dead symbols'
H06FD59310A4C: '计算死符号'
# 'Compute known content of array elements'
HF867A4592891: '计算数组元素的已知内容'
# 'Compute mean of all readings'
H8282EDF1CC14: '计算所有读数的均值'
# 'Compute stale profile statistical metrics and write it into the native object file(.llvm_stats section).'
H2211EA0D1BE2: '计算陈旧的配置文件统计指标并将结果写入本地目标文件的.llvm_stats节。'
# 'Compute the full inline cost of a call site even when the cost exceeds the threshold.'
HF635A2D8BE0B: '即使成本超过阈值，也计算调用点的完全内联成本。'
# 'Conditions to use when printing elements.'
H57BD843032A5: '打印元素时使用的条件。'
# 'Configure the polly loop optimizer'
H40019CBBC00E: '配置 Polly 循环优化器'
# 'Connect to an out-of-process executor through a TCP socket'
H89D591EB992E: '通过TCP套接字连接到外部进程执行器。'
# 'Connect to an out-of-process executor via TCP'
H84FC6B32A5A3: '通过TCP连接到外部进程执行器。'
# 'Consider R1 caller preserved so stack saves of caller preserved registers can be LICM candidates'
H7A2CC0A44257: '将R1视为调用者保存寄存器，以便调用者保存的寄存器栈保存可以成为LICM候选。'
# 'Consider a profile matches a function if the similarity of their callee sequences is above the specified percentile.'
HE02A66F58798: '如果配置文件和函数的被调用者序列相似度高于指定的百分位数，则认为该配置文件匹配该函数。'
# 'Consider all leaf descendants of internal nodes of the suffix tree as candidates for outlining (if false, only leaf children are considered)'
HCFBF788CDF8F: '将后缀树内部节点的所有叶后代视为外线化的候选（如果为false，则仅考虑叶节点）'
# 'Consider calls to be predicable'
HF4AE01562CCA: '将调用视为可预测的。'
# 'Constant Hoisting'
HA20E9E7B7D12: '常量提升'
# 'Constant specifier.'
H27C86387B88E: '常量说明符。'
# 'Constant.'
H69328F1434C8: '常量。'
# 'Context sensitive profile file path'
H6AAD89B511B3: '上下文敏感的配置文件路径'
# 'Contiguously Lay Out Funclets'
H35F4CF635E0B: '连续布局Funclets'
# 'Continue if files are not mapped correctly.'
H0AB9362D475E: '如果文件映射不正确则继续。'
# 'Control Flow Optimizer'
H072A594766A3: '控制流优化器'
# 'Control conversion of memcpy to Tail predicated loops (WLSTP)'
HE778B3B33793: '控制将memcpy转换为尾部条件循环（WLSTP）'
# 'Control emission of Swift async extended frame info'
H02D3442EBA23: '控制Swift异步扩展帧信息的生成'
# "Control how the assembler should align branches with NOP. If the boundary's size is not 0, it should be a power of 2 and no less than 32. Branches will be aligned to prevent from being across or against the boundary of specified size. The default value 0 does not align branches."
H8B5A4A325A23: '控制汇编器如何使用NOP对齐分支。如果边界大小不为 0，则必须为 2 的幂次且不小于 32。分支将被对齐以避免跨越或逆向指定大小的边界。默认值 0 不进行分支对齐。'
# 'Control jump table emission on Hexagon target'
H6602FAB1D723: '控制Hexagon目标的跳转表生成。'
# 'Control lookup table emission on Hexagon target'
HAAA735B3BA36: '控制Hexagon目标的查找表生成。'
# 'Control the CR-bit tracking feature on PowerPC. ``-mcrbits`` (the enablement of CR-bit tracking support) is the default for POWER8 and above, as well as for all other CPUs when optimization is applied (-O2 and above).'
H81C5A0E206B5: '控制PowerPC架构上的CR位跟踪功能。``-mcrbits``（启用CR位跟踪支持）是默认设置，适用于POWER8及更高版本，以及在应用优化（-O2及以上）时的所有其他CPU。'
# 'Control the amount of inlining in pre-instrumentation inliner (default = 75)'
H601514BCD01B: '控制预插入阶段内联器的内联量（默认值=75）'
# 'Control the amount of inlining to perform (default = 225)'
H54F72241070E: '控制要执行的内联量（默认值=225）'
# 'Control the amount of phi node folding to perform (default = 2)'
H27887A938BFF: '控制要执行的phi节点折叠量（默认值=2）'
# 'Control the maximal conditional load/store that we are willing to speculatively execute to eliminate conditional branch (default = 6)'
HEA5F4A80FEFE: '控制愿意推测执行的最大条件加载/存储以消除条件分支（默认值=6）'
# 'Control the maximal total instruction cost that we are willing to speculatively execute to fold a 2-entry PHI node into a select (default = 4)'
H57D2DDD9FD2C: '控制愿意推测执行的最大总指令成本以将 2 条目PHI节点折叠为选择（默认值=4）'
# 'Control the number of bonus instructions (default = 1)'
H7BC9F590620F: '控制额外指令的数量（默认值=1）'
# 'Control the rules which are enabled. These options all take a comma separated list of rules to disable and may be specified by number or number range (e.g. 1-10).'
H7704451C821B: '控制启用的规则。这些选项都接受以逗号分隔的禁用规则列表，可通过编号或编号范围（例如 1-10）指定规则。'
# 'Control the use of vectorisation using tail-folding for SVE where the option is specified in the form (Initial)[+(Flag1|Flag2|...)]:\ndisabled      (Initial) No loop types will vectorize using tail-folding\ndefault       (Initial) Uses the default tail-folding settings for the target CPU\nall           (Initial) All legal loop types will vectorize using tail-folding\nsimple        (Initial) Use tail-folding for simple loops (not reductions or recurrences)\nreductions    Use tail-folding for loops containing reductions\nnoreductions  Inverse of above\nrecurrences   Use tail-folding for loops containing fixed order recurrences\nnorecurrences Inverse of above\nreverse       Use tail-folding for loops requiring reversed predicates\nnoreverse     Inverse of above'
H48B9B6BA5047: '通过尾折叠向量化控制SVE的使用，该选项以以下形式指定：(Initial)[+(Flag1|Flag2|...)]:\ndisabled      (Initial) 禁用所有使用尾折叠向量化的循环类型\ndefault       (Initial) 使用目标CPU的默认尾折叠设置\nall           (Initial) 所有合法循环类型都将使用尾折叠向量化\nsimple        (Initial) 为简单循环（非规约或递推）使用尾折叠\nreductions    为包含规约的循环使用尾折叠\nnoreductions  与上述相反\nrecurrences   为包含固定顺序递推的循环使用尾折叠\nnorecurrences 与上述相反\nreverse       为需要反转谓词的循环使用尾折叠\nnoreverse     与上述相反'
# "Control use of approximate reciprocal and reciprocal square root instructions followed by <n> iterations of Newton-Raphson refinement. <value> = ( ['!'] ['vec-'] ('rcp'|'sqrt') [('h'|'s'|'d')] [':'<n>] ) | 'all' | 'default' | 'none'"
HC7E65C6B3833: "控制使用近似倒数和倒数平方根指令后跟随 <n> 次 Newton-Raphson 迭代优化。<value> = ( ['!'] ['vec-'] ('rcp'|'sqrt') [('h'|'s'|'d')] [':'<n>] ) | 'all' | 'default' | 'none'"
# 'Control vtordisp placement'
HE1318392829D: '控制 vtordisp 的放置'
# 'Control vtordisp placement on win32 targets'
H1B28D470DA9E: '在 win32 目标平台上控制 vtordisp 的放置'
# "Control where files for distributed backends are created. Expects 'oldprefix;newprefix' and if path prefix of output file is oldprefix it will be replaced with newprefix."
HC0263D605A37: "控制分布式后端文件的创建位置。期望格式为 'oldprefix;newprefix'，如果输出文件的路径前缀是oldprefix，则将其替换为newprefix。"
# 'Control whether the compiler can use scalable vectors to vectorize a loop'
H6A90BC2050A3: '控制编译器是否可以使用可扩展向量来向量化循环'
# 'Control whether unstable and experimental library features are enabled. This option enables various library features that are either experimental (also known as TSes), or have been but are not stable yet in the selected Standard Library implementation. It is not recommended to use this option in production code, since neither ABI nor API stability are guaranteed. This is intended to provide a preview of features that will ship in the future for experimentation purposes'
H292802AB79DD: '控制是否启用不稳定且实验性的库功能。此选项启用各种实验性库功能（也称为 TSes），或尚未在所选标准库实现中稳定的特性。不建议在生产代码中使用此选项，因为既不保证 ABI 也不保证 API 的稳定性。此选项旨在为未来将发布的功能提供实验性预览'
# 'Controls Negator transformations in InstCombine pass'
H08542ADEE520: '控制InstCombine pass中的Negator变换'
# 'Controls how scalar integer arguments are extended in calls to unprototyped and varargs functions'
H7A8FE1AC1071: '控制未声明原型和可变参数函数中标量整数参数的扩展方式'
# 'Controls if structs should be imported as literal structs, i.e., nameless structs.'
H2343CB68FB97: '控制结构体是否应作为字面结构体导入，即无名结构体'
# 'Controls the backend parallelism of -flto=thin (default of 0 means the number of threads will be derived from the number of CPUs detected)'
H6966D13FD63C: '控制 -flto=thin 的后端并行性（默认值 0 表示线程数将根据检测到的 CPU 数量推导）'
# 'Controls the semantics of floating-point calculations.'
H71E38C97DF72: '控制浮点计算的语义。'
# 'Controls transformations in div-rem-pairs pass'
HECF2FCF96025: '控制div-rem-pairs pass中的变换'
# 'Controls transformations in partially-inline-libcalls'
HD0E8FE10DABD: '控制partially-inline-libcalls中的变换'
# 'Controls whether PPC per opcode peephole is performed on a MI'
HE5F923C4F31C: '控制是否对MI执行PPC每条指令的peephole优化'
# 'Controls whether PPC reg+reg to reg+imm peephole is performed on a MI'
HE845FFE9D736: '控制是否对MI执行将寄存器+寄存器转换为寄存器+立即数的peephole优化'
# 'Controls whether a DAG combine is performed for a node'
H093B59DCA1FC: '控制是否对某个节点执行DAG合并'
# 'Controls whether rewriteCandidateWithBasis is executed.'
H07C470C4B05C: '控制是否执行rewriteCandidateWithBasis'
# 'Controls whether to select function with GlobalISel'
HBD7BF3862B9C: '控制是否使用GlobalISel选择函数'
# 'Controls which MemoryDefs are eliminated.'
H791CB4538D1F: '控制消除哪些MemoryDefs'
# 'Controls which SLP graphs should be vectorized.'
H3651F2112EDB: '控制应向量化哪些SLP图'
# 'Controls which assumes gets created'
HC60E96036F48: '控制创建哪些假设条件'
# 'Controls which checks to insert'
H85AB8C69F0A9: '控制插入哪些检查'
# 'Controls which conditions are eliminated'
HCCAC8F989163: '控制消除哪些条件'
# 'Controls which instruction to instrument'
HC782D790D691: '控制插桩哪些指令'
# 'Controls which instructions are eliminated'
H11684921476B: '控制消除哪些指令'
# 'Controls which instructions are removed'
HAA6FE4D6ECC8: '控制删除哪些指令'
# 'Controls which instructions are value numbered'
HB785D2555BC9: '控制对哪些指令进行值编号'
# 'Controls which instructions are visited'
H636F2545BF3D: '控制访问哪些指令'
# 'Controls which instructions we create phi of ops for'
HE27BA11ED3BE: '控制为哪些指令的操作数创建phi节点'
# 'Controls which pairs are considered for renaming'
HD4F491A48E58: '控制考虑哪些配对进行重命名'
# 'Controls which register COPYs are forwarded'
H3AAE7A42C897: '控制哪些寄存器COPY操作会被转发'
# 'Controls which tag collisions are avoided'
H425F30EA7D35: '控制需要避免哪些标签冲突'
# 'Controls which variables C++ static destructors are registered for'
HBD9C8A005FBD: '控制 C++ 静态析构函数注册的变量'
# 'Controls which variables are renamed with predicateinfo'
H64B5B42BA3C1: '控制使用predicateinfo重命名的变量'
# 'Conventional ABI instrumentation for sanitizer runtime. Default: Conventional'
HAE6876018E56: 'Sanitizer运行时的传统ABI插桩。默认值：传统'
# 'Convert align attributes to assumptions during inlining.'
H3BBD1D4AD52A: '在内联时将align属性转换为假设。'
# 'Convert all cmovs to branches.'
HC3FD80CE54EF: '将所有cmovs转换为跳转。'
# 'Convert available_externally into locals, renaming them to avoid link-time clashes.'
H719EAE04A8AC: '将available_externally转换为本地变量，并重命名以避免链接时冲突。'
# 'Convert cmovs to branches whenever they have memory operands.'
HF77C545DF219: '当cmov具有内存操作数时，将其转换为跳转。'
# 'Convert eligible reg+reg instructions to reg+imm'
HC9D049FFF42E: '将符合条件的reg+reg指令转换为reg+imm'
# 'Convert i1 constants to i32/i64 if they are returned'
HB5295C482B89: '若返回值为i1常量时将其转换为i32/i64'
# 'Convert irreducible control-flow into natural loops'
HE7DC2EC0D50F: '将不可约简控制流转换为自然循环'
# 'Convert noalias attributes to metadata during inlining.'
H693AF480BD18: '在内联时将noalias属性转换为元数据。'
# 'Convert registers to WebAssembly locals'
H42DF7CAF4C71: '将寄存器转换为WebAssembly局部变量'
# 'Convert switches into an integer range comparison (default = false)'
HDCDA8562FA9F: '将switch转换为整数范围比较（默认=false）'
# 'Convert switches to lookup tables (default = false)'
H5FE1320AA9A1: '将switch转换为查找表（默认=false）'
# 'Convert the generated profile to a profile with a new layout'
H7167152F0FAC: '将生成的配置文件转换为具有新布局的配置文件'
# 'Cost for first time use of callee-saved register.'
H378B86E985E0: '首次使用被调用者保存寄存器的成本。'
# 'Cost multiplier to multiply onto inlined call sites where the new call was previously an intra-SCC call (not relevant when the original call was already intra-SCC). This can accumulate over multiple inlinings (e.g. if a call site already had a cost multiplier and one of its inlined calls was also subject to this, the inlined call would have the original multiplier multiplied by intra-scc-cost-multiplier). This is to prevent tons of inlining through a child SCC which can cause terrible compile times'
H698CAA7A18F5: '用于乘以内联调用站点的倍增因子，当新调用原本是同一强连通分量（SCC）内的调用（当原始调用已经是intra-SCC时无关）。该因子可能在多次内联中累积（例如，如果调用站点已有成本倍增因子，且其内联调用中的某个调用也适用此因子，则内联调用的成本将乘以intra-scc-cost-multiplier）。这可防止通过子SCC进行大量内联导致编译时间过长'
# 'Cost of a single instruction when inlining'
H036B559D08B8: '内联时单条指令的成本'
# 'Cost of alloca argument'
HC1E9D60217AE: 'alloca参数的成本'
# 'Cost of jump instructions.'
H7ED2E2DD5641: '跳转指令的成本。'
# 'Cost of load/store instruction when inlining'
H4C8BA9CE961B: '内联时的加载/存储指令成本'
# 'Cost penalty for blocks that can avoid breaking CFG by copying. Copying can increase fallthrough, but it also increases icache pressure. This parameter controls the penalty to account for that. Percent as integer.'
HC9F72F77D39D: '对可避免破坏控制流图的块施加复制惩罚。复制可增加直通执行，但也会增加ICache压力。此参数控制该惩罚值。以整数表示的百分比。'
# 'Cost that models the probabilistic risk of an instruction misfetch due to a jump comparing to falling through, whose cost is zero.'
H84CCB8356D8E: '对由于跳转而非直落导致指令误获取的概率风险建模的成本，其成本为零。'
# 'Costing strategy for intrinsic instructions'
H8D22576D5E28: '内建函数的计费策略'
# 'Count statements with scalar accesses as not optimizable'
H20E33614C70B: '将具有标量访问的语句计为不可优化'
# 'Count the induction variable only once when interleaving'
HDCB004AC534E: '在交错时仅计算一次归纳变量'
# 'Counts based on the value each specified argument has. The argument has to have a number value to be considered.'
HE174F4DEB8D5: '基于每个指定参数的值进行计数。参数必须具有数值才能被考虑。'
# 'Counts individual remarks based on how many of the remark exists.'
H16283CDE8F40: '根据存在的备注数量对每个备注进行单独计数。'
# 'Coverage executable or object file'
H2B8E5F52400C: '覆盖可执行文件或目标文件'
# 'Covered executable or object file.'
H20476C00EDC5: '已覆盖的可执行文件或目标文件'
# 'Create DLL'
H8F2F15C96BC4: '创建 DLL'
# 'Create Garbage Collector Module Metadata'
H7493F37F2CB6: '创建垃圾回收器模块元数据'
# 'Create a copy of byval function arguments early.'
HFD4F400F3DC5: '尽早创建byval函数参数的副本。'
# 'Create a dot file of CFGs with block coverage inference information'
HEAFA159C65C9: '创建带有块覆盖推断信息的CFG的dot文件'
# 'Create a table of coverage-instrumented PCs'
HE002CE3DC7B7: '创建带有覆盖分析的 PC 表'
# 'Create a website with graphical changes'
H01E9364CFCA0: '创建带有图形变化的网站'
# 'Create a website with graphical changes in quiet mode'
H70CA1F4FAB9C: '在静默模式下创建带有图形变化的网站'
# 'Create cfi directives that assume the code might be more than 2gb away'
H558862C2332B: '创建假设代码可能相距超过 2GB的cfi指令'
# 'Create debug DLL'
H983B4E5552B9: '创建调试 DLL'
# 'Create empty files if bundles are missing when unbundling.\n'
H57F1E8EF31C0: '解包时如果缺少包则创建空文件。\n'
# 'Create hotpatchable image'
HA0C5E8AB1DC6: '创建可热补丁的镜像'
# 'Create lane mask for data only, using active.lane.mask intrinsic'
HFF5BD5C1DCB1: '仅针对数据创建通道掩码，使用active.lane.mask固有函数'
# 'Create lane mask using active.lane.mask intrinsic, and use it for both data and control flow'
H1B146FBA9B46: '使用active.lane.mask固有函数创建通道掩码，并将其用于数据和控制流'
# 'Create lane mask with compare/stepvector'
HE51056AA8ABD: '使用compare/stepvector创建通道掩码'
# 'Create phony target for each dependency (other than main file)'
H49C550B30EC3: '为每个依赖项（除主文件外）创建虚拟目标'
# 'Create pi-block nodes.'
H3DDF1DCDF3C3: '创建pi-block节点。'
# 'Create redzones for byval arguments (extra copy required)'
HF6B190018549: '为byval参数创建红区（需要额外复制）'
# 'Create unit-strided versions of loops'
H1EF207263F28: '为循环创建单位步长版本'
# "Creates .debug_names section, if the input binary doesn't have it already, for DWARF5 CU/TUs."
HFA262F88083F: '如果输入二进制文件没有该部分，则创建DWARF5 CU/TUs的.debug_names部分。'
# 'Cross module exports (DEBUG_S_CROSSSCOPEEXPORTS subsection)'
HE827878921EC: '跨模块导出（DEBUG_S_CROSSSCOPEEXPORTS子部分）'
# 'Cross module imports (DEBUG_S_CROSSSCOPEIMPORTS subsection)'
HE6104A2735AD: '跨模块导入（DEBUG_S_CROSSSCOPEIMPORTS子部分）'
# 'Cull hazards on function boundaries'
HD35403A45243: '在函数边界处消除危险'
# 'Cull hazards on memory waits'
HF9A83C7746B5: '在内存等待时消除危险'
# 'Cutoff for generating "extract" instructions'
HF67D76A2F279: '生成 "extract" 指令的阈值'
# 'Cutoff percentages (times 10000) for generating detailed summary'
HF12B62925337: '生成详细摘要的百分比阈值（乘以 10000）'
# 'Cutoff value about how many symbols in profile symbol list will be used. This is very useful for performance debugging'
H866011BDFA50: '符号数目阈值，用于确定在性能分析符号列表中使用的符号数量。这对性能调试非常有用'
# 'Cycle Info Analysis'
HD7B2CE61522D: '循环信息分析'
# 'DAG combiner enable load/<replace bytes>/store with a narrower store'
H7A381CB1EB04: '启用DAG组合器，使用更窄的存储进行load/<替换字节>/store操作'
# 'DAG combiner enable merging multiple stores into a wider store'
H9B98909FAA22: '启用DAG组合器，将多个存储合并为更宽的存储'
# 'DAG combiner enable reducing the width of load/op/store sequence'
H56650D4975A5: 'DAG 组合器启用减少加载/操作/存储序列的宽度'
# 'DAG combiner force override the narrowing profitable check when reducing the width of load/op/store sequences'
HA751CC58B87A: 'DAG 组合器强制覆盖窄化收益检查，当减少加载/操作/存储序列的宽度时'
# 'DAG combiner limit number of steps when searching DAG for predecessor nodes'
HEF62B0854706: 'DAG 组合器限制在 DAG 中搜索前驱节点时的步骤数量'
# 'DAG combiner may split indexing from loads'
HFB4258B46B3C: 'DAG 组合器可能将加载中的索引分离'
# 'DEBUG/DEVELOPMENT OPTIONS'
H43B5FBE6C89C: '调试/开发选项'
# "DEPRECATED: Filename defining the whitelist for imbuing the 'always instrument' XRay attribute."
HC9A9C6768A2E: "已弃用：定义 'always instrument' XRay 属性白名单的文件名。"
# "DEPRECATED: Filename defining the whitelist for imbuing the 'never instrument' XRay attribute."
H640211D9F2F8: "已弃用：定义 'never instrument' XRay 属性白名单的文件名。"
# 'DRIVER OPTIONS'
H8F860C8326CF: '驱动程序选项'
# 'DWARF'
HDD71DBDFB287: 'DWARF'
# 'DWARF debug sections compression type'
H91FF9BE5328B: 'DWARF 调试节的压缩类型'
# 'DWARF-like CFI based exception handling'
HC32F13DA0A07: '基于类似DWARF的CFI异常处理'
# 'DWO output filename'
H6E851EAFE0D8: 'DWO 输出文件名'
# 'DXContainer Global Emitter'
H7800E8E1E097: 'DX容器全局发射器'
# 'DXIL Array Flattener'
H8F82D482C158: 'DXIL数组扁平化'
# 'DXIL CBuffer Access'
HD94C3B98AA6B: 'DXIL常量缓冲区访问'
# 'DXIL Data Scalarization'
H8CA416EED877: 'DXIL数据标量化'
# 'DXIL Finalize Linkage'
H674F973B6F8F: 'DXIL最终链接处理'
# 'DXIL Forward Handle Accesses'
HC699E42DFEAE: 'DXIL前向句柄访问'
# 'DXIL Intrinsic Expansion'
H92F9B358ADE0: 'DXIL 内建扩展'
# 'DXIL Legalizer'
HB4D0483DF9F7: 'DXIL 合法化'
# 'DXIL Metadata Pretty Printer'
HF96947D33548: 'DXIL元数据格式化打印程序'
# 'DXIL Module Metadata analysis'
HA9F2740D603A: 'DXIL模块元数据分析'
# 'DXIL Op Lowering'
HEEFF9D70DBBF: 'DXIL 操作降级'
# 'DXIL Post Optimization Validation'
H0D86A1C91B64: 'DXIL优化后验证'
# 'DXIL Prepare Module'
HF62B7360E273: 'DXIL 模块预处理'
# 'DXIL Resource Access'
HF5E458A33121: 'DXIL 资源访问'
# 'DXIL Resource Binding Analysis'
HC92CD4D22E79: 'DXIL资源绑定分析'
# 'DXIL Resource Implicit Binding'
H9C2D45B76116: 'DXIL资源隐式绑定'
# 'DXIL Resource Type Analysis'
HF10ABCFBFE52: 'DXIL资源类型分析'
# 'DXIL Resources Analysis'
HDA90852D3576: 'DXIL资源分析'
# 'DXIL Root Signature Analysis'
HBF76A637272F: 'DXIL根签名分析'
# 'DXIL Shader Flag Analysis'
H7A214ED13A39: 'DXIL着色器标志分析'
# 'DXIL Translate Metadata'
HF4C419C952DF: 'DXIL元数据转换'
# 'DXIL validator installation path'
H9657CC613141: 'DXIL验证程序安装路径'
# 'Darwin libsystem_m'
H91DFA86D618A: 'Darwin libsystem_m'
# 'Data aggregation options'
H2670869C509A: '数据聚合选项'
# 'Dbi Stream Options'
HD27A954F7342: 'Dbi流选项'
# 'Dead Argument Elimination'
HA9265D7501D4: '死参消除'
# 'Dead Argument Hacking (BUGPOINT USE ONLY; DO NOT USE)'
HDA7D75078335: '死参处理（BUGPOINT专用；请勿使用）'
# 'Dead Code Elimination'
HF23F9DE62329: '无用代码消除'
# 'Debug Variable Analysis'
H4B43DA399B8A: '调试变量分析'
# 'Debug control MBBs that are scheduled'
HFA489B3CE974: '调试控制已调度的 MBBs'
# 'Debug control for aggressive anti-dep breaker'
HDCDB4687E0FE: '调试控制激进反数据依赖断裂'
# 'Debug dumping for the orc-lazy JIT.'
HB541A1485401: '调试输出 orc-lazy JIT 信息。'
# 'Debug func'
H4ECA9A2353F4: '调试函数'
# 'Debug information offset.'
H34EB3EE5B41D: '调试信息偏移量。'
# 'Debug information tags.'
H2591856B760C: '调试信息标签。'
# 'Debug line.'
HC0773DFAAF93: '调试行。'
# 'Debug lines that are zero.'
H28A0CEC425F6: '值为零的调试行。'
# 'Debug location ranges.'
H40716F5089BC: '调试位置范围。'
# 'Debug max inst'
H8671ED460AD3: '调试最大指令数'
# 'Debug min inst'
H10F353058E6B: '调试最小指令数'
# 'Debug option to outline greedily, without restriction that calculated benefit outweighs cost'
H173943EFDB58: '调试选项：贪婪提取，不考虑计算的收益必须超过成本的限制'
# 'Debugify MIR before and Strip debug after each pass except those known to be unsafe when debug info is present'
H0F54403815FA: '在除已知不安全的Pass外，对每个Pass在开始前调试化 MIR 并在结束后剥离调试信息'
# 'Debugify MIR before, by checking and stripping the debug info after, each pass except those known to be unsafe when debug info is present'
HC24A7BC34E88: '在除已知不安全的Pass外，对每个Pass在开始前验证并调试化 MIR，在结束后剥离调试信息'
# 'Decided the kind of output desired'
H734A5ED4813F: '确定所需的输出类型'
# 'Declare callbacks extern weak, and only call if non-null.'
H2C4EDA19C0CD: '将回调声明为外部弱符号，并仅在非空时调用。'
# 'Declare variables at top when emitting C/C++'
HB43A4E22EF20: '在生成 C/C++ 代码时将变量声明在顶部'
# "Decreases 'x86-br-merging-base-cost' in cases that it is unlikely that all conditionals will be executed. For example for merging the conditionals (a == b && c > d), if its known that a == b is unlikely, then it is unlikely that if the conditionals are split both sides will be executed, so it may be desirable to decrease the instruction cost threshold. Set to -1 to never merge unlikely branches."
H63754944E6A3: '在不太可能执行所有条件分支的情况下降低 x86-br-merging-base-cost。例如合并条件 (a == b && c > d) 时，若已知 a == b 不太可能发生，则可能需要降低指令成本阈值。设置为 -1 表示永不合并不可能分支。'
# 'Deduce sibling calls when unrolling function call stacks'
HDD364524269F: '在展开函数调用栈时推导兄弟调用'
# 'Default (no attribute)'
H2C9C1DE32DAB: '默认（无属性）'
# 'Default DWARF version to use, if a -g option caused DWARF debug info to be produced'
HFF353DB7A2F1: '如果-g选项生成DWARF调试信息，则使用的默认DWARF版本'
# 'Default address minimization strategy'
H1000E773EFCF: '默认的地址最小化策略'
# 'Default alignment for loops'
HFA44E84983F7: '循环的默认对齐方式'
# 'Default amount of inlining to perform'
H05B97F3AF721: '执行内联的默认数量'
# 'Default for platform'
H91B018E0FAE2: '平台默认值'
# 'Default for platform and JIT-kind'
H0675076F20CF: '平台和JIT类型默认值'
# 'Default max threads per block for kernel launch bounds for HIP'
HDE6E6DE6B0D5: 'HIP内核启动边界中每个块的默认最大线程数'
# 'Default mispredict rate (initialized to 25%).'
HA90859109DC8: '默认误预测率（初始化为 25%）。'
# 'Default register allocator'
HF2112AFDE4A0: '默认寄存器分配器'
# 'Default threshold (max size of unrolled loop), used in all but O3 optimizations'
H450E3D6B5565: '默认阈值（最大展开循环的大小），在除O3优化外的所有优化中使用'
# 'Default type visibility'
H7E06B3502FFA: '默认类型可见性'
# 'Defer host/device related diagnostic messages for CUDA/HIP'
HD7B0D94624F9: '延迟显示CUDA/HIP相关的主机/设备诊断信息'
# "Define '__STDC__' to '1' in MSVC Compatibility mode"
HE12E4DC30513: '在MSVC兼容模式下将 "__STDC__" 定义为 "1"'
# 'Define <macro> to <value> (or 1 if <value> omitted)'
HC9C0FAB29C48: '将宏 <macro> 定义为 <value>（若省略 <value> 则定义为 1）'
# 'Define __STDC__'
H403D03CBAA5E: '定义__STDC__'
# 'Define a value for a symbol'
HF0BE0602E7DD: '为符号定义一个值'
# 'Define a variable to be used in capture patterns.'
H430D1D820ECC: '定义一个在捕获模式中使用的变量。'
# 'Define custom MSan AndMask'
H293D08EE84D2: '定义自定义MSan AndMask'
# 'Define custom MSan OriginBase'
H8FF05FDD24B0: '定义自定义MSan OriginBase'
# 'Define custom MSan ShadowBase'
H936AD234A7BD: '定义自定义MSan ShadowBase'
# 'Define custom MSan XorMask'
HE0448D308359: '定义自定义MSan XorMask'
# 'Define macro'
H1A169BE8E69A: '定义宏'
# 'Define threshold for number of checks per debug location to force origin update.'
H97F94F0D6F64: '定义每个调试位置的检查数量阈值以强制更新来源。'
# 'Define where potential integer overflows in generated expressions should be tracked.'
H76CDAC079D12: '定义在生成的表达式中应跟踪的整数溢出位置。'
# 'Defined the specified macros to their specified definition. The syntax is <macro>=<definition>'
H8B59655A675D: '将指定的宏定义为指定的定义。语法是 <macro>=<definition>'
# 'Defines a symbol to be an integer constant'
H876930F92D82: '将符号定义为整数常量'
# 'Defines the __DEPRECATED macro'
H49D43A572A26: '定义__DEPRECATED宏'
# 'Delete specified Globals from Module'
HB4A9BA47E594: '从模块中删除指定的全局变量'
# 'Delinearize array access functions'
HA9C6C1714FE6: '对数组访问函数进行去线性化处理'
# 'Delta passes to not run, separated by commas. By default, run all delta passes.'
H76B8D7EFA5BE: '不运行的delta passes列表，用逗号分隔。默认运行所有delta passes。'
# 'Delta passes to run, separated by commas. By default, run all delta passes.'
H192F0FF37D50: '要运行的delta passes列表，用逗号分隔。默认运行所有delta passes。'
# 'Demangle function names'
H0F5F6B77621B: '展开函数名称'
# 'Demote catchswitch BBs only (for wasm EH)'
H0707EDF1B004: '仅降级catchswitch基本块（仅限wasm异常处理）'
# 'Dependence Analysis'
H1CE69C87EFED: '依赖性分析'
# 'Dependences should be simplified (yes/no)'
HFE9403DC8E00: '是否简化依赖关系（是/否）'
# 'Dependency filename'
H48F0BFFD012C: '依赖文件名'
# 'Deprecated (like /Og /Oi /Ot /Oy /Ob2); use /O2'
HC8F13BE3A9B1: '已弃用（类似/Og /Oi /Ot /Oy /Ob2）；请改用/O2'
# 'Deprecated (like not passing /EH)'
HB203EF80F1D6: '已弃用（类似于未指定/EH参数）'
# 'Deprecated (set output file name); use /Fe or /Fe'
H43E83CDF9C2D: '已弃用（设置输出文件名）；请改用/Fe或/Fe'
# "Deprecated; use '-O3 -ffast-math -fstack-arrays' for the same behavior, or '-O3 -fstack-arrays' to enable only conforming optimizations"
H894A29167B0A: '已弃用；如需相同行为请使用 "-O3 -ffast-math -fstack-arrays"，或使用 "-O3 -fstack-arrays" 仅启用符合标准的优化'
# "Deprecated; use '-O3 -ffast-math' for the same behavior, or '-O3' to enable only conforming optimizations"
H68FB98DB67B0: '已弃用；如需相同行为请使用 "-O3 -ffast-math"，或使用 "-O3" 仅启用符合标准的优化'
# 'Deprecated; use /EHsc'
H0521F1C5E495: '已弃用；请改用/EHsc'
# 'Depth limit for finding address space through traversal'
HD8946F32E697: '遍历查找地址空间的深度限制'
# 'Depth limit when simplifying vector instructions and their operands'
H77D06B036D51: '简化向量指令及其操作数时的深度限制'
# 'Deref attributes and metadata infer facts at definition only'
HA8F233351C69: '仅在定义时推断解引用属性和元数据的事实'
# 'Details for each and every function'
HC3D59D83E7DB: '每个函数的详细信息'
# 'Detect Dead Lanes'
H72FCA4FFA4F4: '检测无效通道'
# 'Detect and exploit reductions'
HE6789AB23B98: '检测并利用缩减操作'
# 'Detect parallelism'
H2FE6FC8C4E2A: '检测并行性'
# 'Detect single entry single exit regions'
H9F71476F6AF4: '检测单入口单出口区域'
# "Detect stack use after return if binary flag 'ASAN_OPTIONS=detect_stack_use_after_return' is set."
H52A7D51EA3C5: "如果二进制标志 'ASAN_OPTIONS=detect_stack_use_after_return' 被设置，则检测栈使用后返回的情况。"
# 'Determine based on deployment target'
H73C787FF3B61: '根据部署目标确定'
# 'Determine what attributes are manifested in the IR'
H535B6DB54DEC: '确定哪些属性在IR中被体现'
# 'Determine when the Swift async frame pointer should be set'
H0BCAA17B1F0F: '确定何时应设置Swift异步帧指针'
# 'Determines whether the optimizer honors parentheses when floating-point expressions are evaluated'
HD46386982C52: '确定优化器在计算浮点表达式时是否保留括号优先级'
# 'Diagnostic ID mapping utility'
HC6CDFACE6E9C: '诊断ID映射实用工具'
# 'Diff Options'
H28F8A773273E: '差异选项'
# 'Directly create compilation output files. This may lead to incorrect incremental builds if the compiler crashes'
H2C3E48B98787: '直接创建编译输出文件。如果编译器崩溃，可能导致增量构建结果不正确'
# 'Directories referenced in the debug information.'
HA9318D60737D: '调试信息中引用的目录。'
# 'Directories to search for object files by build ID'
HC9E3A565BEEA: '按构建ID搜索对象文件的目录'
# 'Directory for crash diagnostic files.'
H168FC0AAB4F7: '崩溃诊断文件的目录。'
# 'Directory for outputting generated files.'
H8BAEDDCD56DA: '输出生成文件的目录。'
# 'Directory in which coverage information is written out'
HE36AE6B0A9D2: '覆盖信息写入的目录'
# 'Directory in which to emit symbol graphs.'
HD25DF8577F21: '要生成符号图的目录'
# 'Directory of include files'
H4769C553D95E: '头文件目录'
# 'Directory to dump module dependencies to'
H34B714818DA5: '要转储模块依赖关系的目录'
# "Directory to output dSYM's (if any) to"
H6E5284514F1A: '要输出dSYM（如果有）的目录'
# 'Directory to store cached object files (must be user writable)'
HF3C59BF42111: '缓存对象文件的目录（必须可写）'
# 'Directory used as a base for relative coverage mapping paths'
H60985D18A905: '用于相对覆盖映射路径基础的目录'
# 'Disable BPF_ST (immediate store) insn'
HD28C63C4DB63: '禁用BPF_ST（立即存储）insn'
# 'Disable C++ access control'
H88EE329A1455: '禁用C++访问控制'
# 'Disable C++ builtin type char8_t'
HE8005A3ED4D9: '禁用C++内建类型char8_t'
# 'Disable C++ builtin type wchar_t'
H2F081FBCFFCE: '禁用C++内建类型wchar_t'
# 'Disable C++ copy constructor elision'
H7BE31CDC2832: '禁用C++拷贝构造函数省略'
# 'Disable C++ static destructor registration'
H2B2B7EA1E24C: '禁用C++静态析构函数注册'
# 'Disable C++14 sized global deallocation functions'
H31DC24E25DC3: '禁用C++14大小全局释放函数'
# 'Disable C++17 aligned allocation functions'
H45EDF7CE8D2D: '禁用C++17对齐分配函数'
# 'Disable CHR for all functions'
HE1BB044E9400: '禁用所有函数的CHR'
# 'Disable CIR transformations pipeline'
H0D1EAB308F4D: '禁用CIR转换管线'
# 'Disable CTR loops for PPC'
HFB1BF72E3D56: '禁用PPC的CTR循环'
# 'Disable CUDA Warp Function'
HED60E177B610: '禁用CUDA Warp功能'
# 'Disable Codegen Prepare'
H9DF18DE3903B: '禁用代码生成准备阶段'
# 'Disable ConstantHoisting'
HA432AE659D39: '禁用ConstantHoisting'
# 'Disable Copy Propagation pass'
H6FAF844B65AE: '禁用Copy Propagation pass'
# 'Disable Dealloc Return for Hexagon target'
HC23D9F3300FD: '禁用Hexagon目标的Dealloc返回'
# 'Disable Early If-conversion'
H0D9C330086F8: '禁用早期If转换'
# 'Disable GC optimizations in CodeGenPrepare'
HFD8A99D7BFCD: '禁用CodeGenPrepare中的GC优化'
# 'Disable GNU style inline asm'
H1CF933954FC2: '禁用GNU风格内联asm'
# 'Disable Hardware Loops for Hexagon target'
H783975C3C5DB: '禁用Hexagon目标的硬件循环'
# 'Disable Hexagon Addressing Mode Optimization'
H071B2E4C0FD8: '禁用Hexagon寻址模式优化'
# 'Disable Hexagon CFG Optimization'
HEF36B4E6BB85: '禁用Hexagon控制流图优化'
# 'Disable Hexagon HVX IEEE floating-point'
H506C4D61FBA6: '禁用Hexagon HVX IEEE浮点数'
# 'Disable Hexagon HVX QFloat instructions'
HF256A44FD3F5: '禁用Hexagon HVX QFloat指令'
# 'Disable Hexagon MI Scheduling'
HA39B5931FB8D: '禁用Hexagon MI调度'
# 'Disable Hexagon Vector eXtensions'
HDECA543F8233: '禁用Hexagon向量扩展（HVX）'
# 'Disable Hexagon constant propagation'
HED97EBD49929: '禁用Hexagon常量传播'
# 'Disable Hexagon instruction shuffling'
HC9709908CDDF: '禁用Hexagon指令重排'
# 'Disable Hexagon loop alignment pass'
HCE964D02A0A9: '禁用Hexagon循环对齐pass'
# 'Disable Hexagon packetizer pass'
HCB5AE1AB8542: '禁用Hexagon包装配对pass'
# 'Disable Hexagon specific Mask generation pass'
H8E1C9C7C8EC3: '禁用Hexagon特定的Mask生成pass'
# 'Disable JIT lazy compilation'
H24C8D24310DC: '禁用JIT延迟编译'
# 'Disable LTO mode (default)'
H508DDA148F38: '禁用LTO模式（默认）'
# 'Disable LTO mode (default) for offload compilation'
H7985601FAE0D: '为卸载编译禁用LTO模式（默认）'
# 'Disable Linear Function Test Replace optimization'
HA3DA3179BF69: '禁用线性函数测试替换优化'
# 'Disable Loongson Advanced SIMD Extension (LASX).'
HEC68A6D43B64: '禁用龙芯高级SIMD扩展（LASX）。'
# 'Disable Loongson SIMD Extension (LSX).'
H51EB682DB218: '禁用龙芯SIMD扩展（LSX）。'
# 'Disable Loop Idiom Vectorize Pass.'
HCD6AF30D16E4: '禁用循环惯用法向量化Pass。'
# 'Disable Loop Strength Reduction Pass'
HFDE52CD02ECB: '禁用循环强度削减Pass'
# 'Disable MC/DC coverage criteria'
H5A71DE0EA17B: '禁用MC/DC覆盖率标准'
# 'Disable MIRProfileLoader before BlockPlacement'
H7119CF48A829: '在RegAlloc之前禁用MIRProfile加载器'
# 'Disable MIRProfileLoader before RegAlloc'
HCEBEE56EAD41: '禁用机器公共子表达式消除'
# 'Disable MSA ASE (MIPS only)'
H771BF5C8F84F: '禁用MSA ASE（仅限MIPS）'
# 'Disable MT ASE (MIPS only)'
H1B6CF37939E2: '禁用MT ASE（仅MIPS）'
# 'Disable Machine Common Subexpression Elimination'
H600985BEDBBF: '禁用机器死代码消除'
# 'Disable Machine Dead Code Elimination'
H436919B5DD6D: '禁用机器死代码消除'
# 'Disable Machine LICM'
HCA4B000FCB0F: '禁用机器循环不变式代码移动'
# 'Disable Machine Sinking'
H84436D44017D: '禁用机器下沉优化'
# 'Disable MergeICmps Pass'
H127BD98A6338: '禁用合并ICmp指令优化过程'
# 'Disable New Value Jumps'
H3397AA24247F: '禁用新值跳转'
# 'Disable ODR indicator globals'
H2F9A01FFB645: '禁用ODR指示全局变量'
# 'Disable OpenMP optimizations involving SPMD-ization.'
HAF8239BD178C: '禁用涉及SPMD化的OpenMP优化'
# 'Disable OpenMP optimizations involving deglobalization.'
H74B4ADA2F47B: '禁用涉及去全局化的OpenMP优化'
# 'Disable OpenMP optimizations involving folding.'
HBD10CEF55EEF: '禁用涉及折叠的OpenMP优化'
# 'Disable OpenMP optimizations that eliminate barriers.'
H5C4E1057F8BD: '禁用消除屏障的OpenMP优化'
# 'Disable OpenMP optimizations that replace the state machine.'
HC78F7C4114D3: '禁用替换状态机的OpenMP优化'
# 'Disable OpenMP specific optimizations.'
HA40A50850068: '禁用特定于OpenMP的优化'
# 'Disable OpenMP support'
HFCB159BB2AD0: '禁用OpenMP支持'
# 'Disable Optimization of PNotP'
HE9DF380BE58C: '禁用PNotP优化'
# 'Disable Optimization of Sign/Zero Extends'
H821C42065D98: '禁用符号/零扩展优化'
# 'Disable Optimization of extensions to i64.'
HD38C1BE50891: '禁用到i64的扩展优化'
# 'Disable PPC loop instr form prep'
H8547684E746B: '禁用PPC循环指令形式预处理'
# 'Disable Partial Libcall Inlining'
HDD48CA4D7B3E: '禁用部分库调用内联'
# 'Disable Peephole Optimization'
H6E6615A7A740: '禁用窥孔优化'
# 'Disable Post Regalloc Scheduler'
HD739F0016551: '禁用寄存器分配后调度器'
# 'Disable PostRA Machine Sinking'
HBB5CB09CF7E3: '禁用寄存器分配后机器下沉优化'
# 'Disable SVR4-style position-independent code (Mips only)'
HA6D44538AD07: '禁用SVR4风格的位置无关代码（仅Mips）'
# 'Disable SYCL C++ extensions'
H66EB15B22DDA: '禁用SYCL C++扩展'
# 'Disable Sparc leaf procedure optimization.'
H4EAE17DB87E5: '禁用Sparc叶过程优化。'
# 'Disable Stack Slot Coloring'
HC67B1F734851: '禁用栈槽着色'
# 'Disable Trap Unreachable for BPF'
HAE15965950D8: '禁用BPF的陷阱不可达'
# 'Disable V8+ mode'
HF617D77F2415: '禁用V8+模式'
# 'Disable VSX FMA instruction mutation'
HEA8BD8C0F7FD: '禁用VSX FMA指令变异'
# 'Disable VSX Swap Removal for PPC'
H5BF6CF30BC27: '禁用PPC的VSX交换消除'
# 'Disable Value Profiling'
H0CA8694E7036: '禁用值剖分析'
# 'Disable XMM8-XMM15 register usage'
H1FBE9270DAE0: '禁用XMM8-XMM15寄存器的使用'
# 'Disable adding the optnone attribute to functions at O0'
H7B7D0B68A353: '禁用在O0优化级别为函数添加optnone属性'
# 'Disable advance peeling. Issues for convergent targets (D134803).'
H96D4946929C2: '禁用高级循环展开。针对收敛目标存在的问题（D134803）。'
# 'Disable advanced copy optimization'
H450999EB2A6C: '禁用所有向量合并转换'
# 'Disable aliasing mode in HWAddressSanitizer'
HDA55D81C7ABD: '禁用HWAddressSanitizer中的别名分析模式'
# 'Disable all Clang extensions for OpenMP directives and clauses'
HAECEE0FE6723: '禁用所有OpenMP指令和子句的Clang扩展'
# 'Disable all options'
H2FCF77933240: '禁用所有选项'
# 'Disable all outlining'
H452D85B48206: '禁用所有函数外联'
# 'Disable all rules in the '
H96795369E1EA: '禁用 中的所有规则'
# 'Disable all static analyzer checks'
H8DC2486B7F10: '禁用所有静态分析器检查'
# 'Disable all vector combine transforms'
H63388692148E: '禁用CTR循环的分析'
# 'Disable all warnings'
H113C54A4E2E2: '禁用所有警告'
# 'Disable amcas[_db].{b/h/w/d}'
H4094C4B64BFB: '禁用amcas[_db].{b/h/w/d}'
# 'Disable amswap[_db].{b/h} and amadd[_db].{b/h}'
HF02B3FF824A2: '禁用amswap[_db].{b/h}和amadd[_db].{b/h}'
# 'Disable analysis for CTR loops'
H4E1A550B8424: '禁用对CTR循环的分析'
# 'Disable analyzing function argument and return types for mandatory definedness'
H035F5FA49F38: '禁用分析函数参数和返回类型的强制定义性'
# 'Disable annotate table jump instruction to correlate it with the jump table.'
HE3C86797416A: '禁用对跳转表指令添加注释以关联跳转表'
# 'Disable any #pragma clang __debug that can lead to crashing behavior. This is meant for testing.'
H22EE3114285C: '禁用可能导致崩溃的#pragma clang __debug指令。此功能用于测试。'
# 'Disable atomic operations instrumentation in ThreadSanitizer'
H436F5749CCF4: '禁用ThreadSanitizer中的原子操作插桩'
# 'Disable atomic optimizer'
H91DDEC6A5CA5: '禁用原子优化器'
# 'Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash'
HCBAE420C8090: '禁用在clang崩溃时自动生成预处理源文件和复现脚本'
# 'Disable automatic bitcode upgrade for version mismatch'
H5A3DEE200EB5: '禁用调试信息的自动升级'
# 'Disable autoupgrade of debug info'
HC2D0BCF7F57C: '禁用后端优化'
# 'Disable backend optimizations'
HB773D8B41328: '禁用二元操作提取到混洗的转换'
# 'Disable binop extract to shuffle transforms'
H6FB234E00070: '禁用分支折叠'
# 'Disable block signature string)'
H0B1A3707BF42: '禁用块签名字符串'
# 'Disable both standard system #include directories and builtin #include directories'
H7E21F38033ED: '同时禁用标准系统#include目录和内建#include目录'
# 'Disable branch folding'
HF6094945EF27: '禁用CodeGenPrepare中的分支优化'
# 'Disable branch optimizations in CodeGenPrepare'
H9E934B1894F9: '禁用bswap指令'
# 'Disable bswap insns'
HEC30AD38E748: '禁用调用约定降级阶段'
# 'Disable buffer security check'
H8BA30D52B9A7: '禁用缓冲区安全检查'
# 'Disable builtin #include directories only'
HF9A61F76A5C0: '仅禁用内建的#include目录'
# 'Disable calling convention lowering pass'
H9858ACECE04B: '禁用那些试图静态验证去线性化下标的有效性的检查。启用此选项可能导致某些语言出现不正确的依赖向量，这些语言允许一个维度的下标下溢或溢出到另一个维度。'
# 'Disable caret diagnostics but keep column info'
H597AC3D9E291: '禁用-caret诊断但保留列信息'
# 'Disable char8_t from c++2a'
H5E206E934042: '禁用来自c++2a的char8_t'
# 'Disable checking of constexpr function bodies for validity within a constant expression context'
H6ABC0DD0EC14: '禁用在常量表达式上下文中检查constexpr函数体的有效性'
# 'Disable checks that try to statically verify validity of delinearized subscripts. Enabling this option may result in incorrect dependence vectors for languages that allow the subscript of one dimension to underflow or overflow into another dimension.'
H5CACAB20797B: '禁用ILP调度阶段的集群低占用率重新调度'
# 'Disable clustered low occupancy rescheduling for ILP scheduling stage.'
HA583E3ADAB6E: '禁用ILP调度阶段的集群低占用率重新调度'
# 'Disable code coverage analysis'
H7E958EA264B1: '禁用代码覆盖率分析'
# "Disable codegen and compile-time checks for C++23's [[assume]] attribute"
H8CC8CAFE3A4B: '禁用C++23的[[assume]]属性的代码生成和编译时检查'
# 'Disable codegen data for function merging. Local merging is still enabled within a module.'
HA6F585942D4A: '禁用函数合并的代码生成数据。模块内的局部合并仍保持启用'
# 'Disable colors in diagnostics'
HDC4DB95966A6: '禁用诊断中的颜色显示'
# 'Disable column and caret diagnostics'
H66ABD4DABB22: '禁用列和-caret诊断'
# 'Disable combining of interleaved loads'
HDC89DC5720AF: '禁用交错加载的合并'
# 'Disable command line arguments round-trip.'
H529251337527: '禁用命令行参数的往返Pass'
# 'Disable compare instruction optimization'
HCA46CE080B75: '禁用比较指令优化'
# 'Disable constant-folding of FP intrinsics and libcalls.'
HFF24E246DB9A: '禁用浮点固有函数和库调用的常量折叠'
# 'Disable control flow integrity (CFI) checks for cross-DSO calls.'
HBA298571E50D: '禁用跨DSO调用的控制流完整性(CFI)检查'
# 'Disable control-flow mitigations for Load Value Injection (LVI)'
HC84915AF941B: '禁用针对负载值注入(LVI)的控制流缓解措施'
# 'Disable convert to D suffix'
HEE0A84D95394: '禁用转换为D后缀'
# 'Disable coverage pruning (i.e. instrument all blocks/edges)'
HF9991A3D9D32: '禁用覆盖剪枝（即插桩所有代码块/边）'
# 'Disable creation of CodeFoundation-type constant strings'
H8A3AF608A73D: '禁用创建CodeFoundation类型的常量字符串'
# 'Disable critical edge splitting during PHI elimination'
HF87FC46C993D: '禁用PHI消除期间的关键边分割'
# 'Disable critical path priority in sched=list-ilp'
H2CD6F07C5299: '禁用sched=list-ilp中的关键路径优先级'
# 'Disable custom behaviour (use the default class which does nothing).'
HDD6103F48106: '禁用自定义行为（使用默认类，该类不执行任何操作）'
# 'Disable cycle-level precision during preRA scheduling'
HF9826B2C9560: '禁用预RA调度中的时钟周期级精度'
# 'Disable delayed template parsing'
H78E92B7DA979: '禁用延迟模板解析'
# 'Disable detection of uninitialized parameters and return values'
H58D5476F7351: '禁用对未初始化参数和返回值的检测'
# 'Disable diagnostic notes.'
HC94928475428: '禁用诊断注释信息'
# 'Disable direct TLS access through segment registers'
H458A3D5DF9C8: '禁用通过段寄存器直接访问TLS'
# 'Disable elimination of dead PHI nodes.'
HC1471E3BABD6: '禁用无用PHI节点的消除'
# 'Disable emission .debug_ranges section.'
H8261A262490A: '禁用.debug_ranges调试信息段的生成'
# 'Disable emission of core files if possible'
H5CA16DE0180D: '尽可能禁用生成核心转储文件'
# 'Disable emission of the extended flags in .loc directives.'
HC16B51206891: '禁用.loc指令中扩展标志的生成'
# 'Disable emitting complete constructors and destructors as aliases when possible'
H4E4DBEA88413: '禁用在可能时将完整构造函数和析构函数作为别名进行生成'
# 'Disable emitting metadata for binary analysis sanitizers'
H9438B3F5F3E7: '禁用为二进制分析 sanitizer 生成元数据'
# 'Disable experimental bounds safety extension for C'
H949767942150: '禁用C语言的实验性边界安全扩展'
# 'Disable experimental late parsing of attributes'
HAEA82819E6DD: '禁用实验性后期属性解析'
# 'Disable ext(promotable(ld)) -> promoted(ext(ld)) optimization in CodeGenPrepare'
HFA8DE3453A19: '禁用CodeGenPrepare中将ext(promotable(ld))转换为promoted(ext(ld))的优化'
# 'Disable external API notes support'
H4877A26CE44B: '禁用外部API注释支持'
# 'Disable fat LTO object support'
HECD714B1BF31: '禁用胖LTO对象支持'
# 'Disable features of APX'
H69A07C7EF30D: '禁用APX的功能'
# 'Disable features of coverage instrumentation for Sanitizers'
H0B74A3F5C9BC: '禁用Sanitizer覆盖插桩功能'
# 'Disable fixed point types'
H9D07DD6F2288: '禁用定点数类型'
# 'Disable fixing up resolved relocations for Hexagon'
H2F59DE7595A3: '禁用Hexagon平台已解析重定位的修复'
# 'Disable frame pointer elimination'
H163B87ED062D: '禁用帧指针消除'
# 'Disable frame pointer elimination for non-leaf frame'
HAF65627719BE: '禁用非叶帧的帧指针消除'
# 'Disable frame pointer omission (x86 only, default)'
H1E0AE27D951E: '禁用帧指针省略（仅x86，默认）'
# 'Disable frecipe.{s/d} and frsqrte.{s/d}'
H62E54664CC80: '禁用frecipe.{s/d}和frsqrte.{s/d}'
# 'Disable freeing of memory on exit'
HF1F277AF14E7: '禁用退出时的内存释放'
# 'Disable function entry/exit instrumentation in ThreadSanitizer'
H1351B571C7D6: '在ThreadSanitizer中禁用函数入口/出口插桩'
# 'Disable function inlining'
H5A7ECCE87EED: '禁用函数内联'
# 'Disable function internalization.'
H8C418ABB3A74: '禁用函数内部化'
# 'Disable function multiversioning'
H1ECFC327C1B3: '禁用函数多版本化'
# 'Disable function outlining (AArch64 only)'
H3491F6797D9A: '禁用函数外联（仅AArch64）'
# 'Disable fusing of spill code into instructions'
H7DEB69686DC1: '禁用将溢出代码融合到指令中'
# 'Disable generation of RTTI data'
H41B72E945CBF: '禁用RTTI数据生成'
# 'Disable generation of const64'
HE3959EA50320: '禁用const64的生成'
# 'Disable generation of discriminator information.'
HC17557FCC17F: '禁用调试器信息生成'
# 'Disable generation of gather instructions in auto-vectorization(x86 only)'
H983AEC35DB6E: '禁用自动向量化中的 gather 指令生成（仅限 x86）'
# 'Disable generation of instruction packets'
H1BEE193809E5: '禁用指令包生成'
# 'Disable generation of linker directives for automatic library linking'
HD9086365BC76: '禁用为自动库链接生成链接器指令'
# 'Disable generation of memcpy in loop idiom recognition'
H75B5FDDE583A: '禁用循环惯用法识别中的memcpy生成'
# 'Disable generation of memmove in loop idiom recognition'
HBDF5135E8486: '禁用循环惯用法识别中的memmove生成'
# 'Disable generation of memop instructions'
H58306072EDD8: '禁用memop指令生成'
# 'Disable generation of new-value jumps'
H7CFC8831E9E7: '禁用新值跳转生成'
# 'Disable generation of new-value stores'
HD912422CF388: '禁用新值存储生成'
# 'Disable generation of profile instrumentation.'
H91EE299476D4: '禁用性能分析探针的生成。'
# 'Disable generation of rtti information'
HD27D5DABC1FC: '禁用运行时类型信息(RTTI)的生成'
# 'Disable generation of scatter instructions in auto-vectorization(x86 only)'
HE3E5F2C6BEE2: '禁用自动向量化中的 scatter 指令生成（仅限 x86）'
# 'Disable global outlining only by ignoring the codegen data generation or use'
H9030F85E3C32: '通过忽略代码生成数据生成或使用来仅禁用全局外线'
# 'Disable gotol insn'
HA056175A68C0: '禁用goto指令'
# 'Disable hazard detection during preRA scheduling'
H42E4A02F5152: '禁用寄存器分配前调度中的危险检测'
# 'Disable header insertions'
H11A783969925: '禁用头文件插入'
# 'Disable header removals'
H0705FC99009C: '禁用头文件移除'
# 'Disable heap memory profiling'
HD2AF1D7462E3: '禁用堆内存分析'
# 'Disable hoisting instructions to hotter blocks'
HECAA5605738C: '禁用将指令提升到更热的代码块'
# 'Disable identical code folding (default)'
H2724011BEF3B: '禁用相同代码折叠（默认）'
# 'Disable implicit addition of a top-level module op during parsing'
H38ED3CECF1BE: '禁用在解析期间隐式添加顶层模块操作（module op）'
# 'Disable implicit builtin knowledge of a specific function'
H72774275D87A: '禁用特定函数的隐式内建知识'
# 'Disable implicit builtin knowledge of functions'
H4AC3CF326B03: '禁用函数的隐式内建知识'
# 'Disable implicit builtin knowledge of math functions'
H19E24A418BA8: '禁用数学函数的隐式内建知识'
# 'Disable inclusion of timestamp in precompiled headers'
H0CF0F2D88326: '禁用在预编译头中包含时间戳'
# 'Disable indirect call promotion'
HEA9F9E3D24D2: '禁用间接调用提升'
# 'Disable instrumentation manager (use the default class which ignores instruments.).'
HFBC374870D12: '禁用工具管理器（使用忽略工具的默认类）'
# 'Disable integer(KIND=16) from TargetCharacteristics'
H1BFDF2763387: '禁用来自TargetCharacteristics的整数(KIND=16)'
# 'Disable integer(KIND=2) from TargetCharacteristics'
HBBF18B435116: '禁用来自TargetCharacteristics的整数(KIND=2)'
# 'Disable integrated assembler'
HA16408310A5F: '禁用集成汇编器'
# 'Disable isel of shifter-op'
H7D5BCC95A13C: '禁用移位操作数（shifter-op）的指令选择'
# 'Disable just-my-code debugging (default)'
H32F1427A6837: '禁用仅我的代码调试（默认）'
# 'Disable keeping all variables that have a persistent storage duration, including global, static and thread-local variables, to guarantee that they can be directly addressed'
H49BC5C7A9B8E: '禁用保留所有具有持久存储期的变量（包括全局、静态和线程局部变量），以保证它们可以直接寻址'
# 'Disable last run tracking'
HC4C7223E1ECA: '禁用最后运行跟踪'
# 'Disable late function splitting using profile information (x86 and aarch64 ELF)'
HE4A96F3E3F80: '禁用使用配置文件信息进行后期函数分割（x86和aarch64 ELF）'
# 'Disable lazy module loading'
HEF9F9437498A: '禁用延迟模块加载'
# 'Disable ldsx insns'
H5394D7A0EA62: '禁用ldsx指令'
# 'Disable lifetime-markers emission even when optimizations are enabled'
HBD15CF06A54D: '即使启用优化，也禁用生命周期标记的生成'
# 'Disable linemarker output and preprocess to stdout'
HA445684726D8: '禁用行标记输出并将预处理结果输出到标准输出'
# 'Disable linemarker output in -E mode'
HF1226A7F981C: '在-E模式下禁用行标记输出'
# 'Disable linker dead stripping of globals in AddressSanitizer'
H529E513B965C: '禁用AddressSanitizer中全局变量的链接器死代码剥离'
# 'Disable linker relaxation'
H1AC503411592: '禁用链接器松弛'
# 'Disable live use priority in sched=list-ilp'
H265D7EB1A110: '在sched=list-ilp中禁用活动使用优先级'
# 'Disable load widening'
HE007529C1391: '禁用载入扩展'
# 'Disable load-acquire and store-release insns'
HC50A5A53467A: '禁用载入获取（load-acquire）和存储释放（store-release）指令'
# 'Disable load/store vectorizer'
H0E242722155F: '禁用载入/存储向量化'
# 'Disable loading default configuration files'
H3C44B12DD359: '禁用加载默认配置文件'
# 'Disable looking for compound instructions for Hexagon'
HD818D391C2CA: '禁用为Hexagon寻找复合指令'
# 'Disable looking for duplex instructions for Hexagon'
H3BEF6EB4C76F: '禁用为Hexagon寻找双工指令'
# 'Disable loop unrolling in all relevant passes'
H8679BDFD2EE8: '禁用所有相关passes的循环展开'
# 'Disable loop-level heuristics.'
H3756953B43F4: '禁用循环级别启发式策略'
# 'Disable machine peepholes for BPF'
H195E092FC1CB: '禁用BPF架构的机器级peephole优化'
# 'Disable machine peepholes for PPC'
HD0AFF1F89154: '禁用PPC架构的机器级peephole优化'
# 'Disable memory access instrumentation in ThreadSanitizer'
H29829654F38C: '禁用ThreadSanitizer中的内存访问探针'
# 'Disable memory promotion in LICM pass'
HFD9EDE137232: '禁用LICM pass中的内存提升'
# 'Disable merging into combines'
H1147057C0FDD: '禁用合并到combines中'
# 'Disable merging of globals'
H0911384E3022: '禁用全局变量的合并'
# 'Disable minimum alignment of 1 for arguments passed by value on stack'
HAF9C1AF67E2F: '禁用对栈上按值传递的参数的最小对齐 1'
# 'Disable mitigations for Load Value Injection (LVI)'
HE89F1385E864: '禁用对Load Value Injection (LVI)的缓解措施'
# 'Disable module-based external API notes support'
H8FEB52AFA393: '禁用基于模块的外部API注释支持'
# 'Disable modules for C++'
H95B7103D9331: '禁用C++的模块'
# 'Disable movsx insns'
H904B978BABF1: '禁用movsx指令'
# 'Disable multi-region partial inlining'
H11B004AA7429: '禁用多区域部分内联'
# 'Disable multi-threading within MLIR, overrides any further call to MLIRContext::enableMultiThreading()'
HE606F0AD2719: '禁用MLIR中的多线程，覆盖任何后续对MLIRContext::enableMultiThreading()的调用'
# 'Disable multiplicative reductions'
H68023B4BA449: '禁用乘法简化'
# 'Disable no-stall priority in sched=list-ilp'
H41669C812FF9: '禁用sched=list-ilp中的无停顿优先级'
# 'Disable non conforming code from compiling (default)'
HC27C523454B5: '禁用不符合标准的代码编译（默认）'
# 'Disable non-allocatable physical register copy optimization'
H9F6E8121BA35: '禁用不可分配物理寄存器复制优化'
# 'Disable odd single-precision floating point registers'
HC69012E33908: '禁用奇数单精度浮点寄存器'
# "Disable omitting 'dls lr, lr' instructions"
HBB8A633ECC4C: "禁用省略 'dls lr, lr' 指令"
# 'Disable on-demand initialization of thread-local variables'
HD53AA5AC4AC6: '禁用线程局部变量的按需初始化'
# 'Disable one or more combiner rules temporarily in '
HD45ADA00F46A: '禁用在…中临时禁用一个或多个组合规则'
# 'Disable optimization'
HD31C9965E766: '禁用优化'
# 'Disable optimizations based on strict aliasing rules'
H0CE3F6B4E092: '禁用基于严格别名规则的优化'
# 'Disable optimizations based on vtable pointer identity'
HB754D32A5739: '禁用基于vtable指针身份的优化'
# 'Disable optimize'
H7A717771741E: '禁用优化'
# 'Disable optimized frm insertion.'
HC173F38AB5E6: '禁用优化frm插入'
# 'Disable origins tracking in MemorySanitizer'
H6CD4173EEC53: '禁用MemorySanitizer中的起源跟踪'
# 'Disable output'
H10D88D0CF0F6: '禁用输出'
# 'Disable partial inlining'
H928A39907BEB: '禁用部分内联'
# 'Disable physreg def-use affinity'
HC8A2DB30E27A: '禁用物理寄存器的def-use关联性'
# 'Disable platform support explicitly'
H0A0D6D39B390: '显式禁用平台支持'
# 'Disable poisoning array cookies when using custom operator new[] in AddressSanitizer'
H04ADC5D02283: '禁用在使用自定义operator new[]时AddressSanitizer中的数组cookie污染'
# 'Disable polly legality check'
H4B855C14E497: '禁用Polly合法性检查'
# 'Disable pre-instrumentation inliner'
H6AAEA4B38739: '禁用预插入探针内联器'
# 'Disable pre-register allocation tail duplication'
H74925BF6B59C: '禁用预寄存器分配尾部复制'
# 'Disable precise memory mode (AMDGPU only)'
H638CDA8718C5: '禁用精确内存模式（仅AMDGPU）'
# 'Disable precompiled headers, overrides /Yc and /Yu'
HA85F69F96408: '禁用预编译头，覆盖/Yc和/Yu'
# 'Disable predefined and command line preprocessor macros'
HB44C3311DC89: '禁用预定义和命令行预处理器宏'
# 'Disable predefined target OS macros'
H55CEC6079E93: '禁用预定义的目标操作系统宏'
# "Disable printing the 'ready' prompt"
H60B484C23636: '禁用打印“ready”提示符'
# 'Disable probability-driven block placement'
H99FD887473AA: '禁用概率驱动的块放置'
# 'Disable promote alloca to LDS'
H12640892E5F6: '禁用将alloca提升到LDS'
# 'Disable promote alloca to vector'
H58F548447B08: '禁用将alloca提升为向量'
# 'Disable protection against removing loop preheaders'
H11458F88A73B: '禁用防止删除循环预头的保护机制'
# 'Disable raw string literals'
H5372647D5F22: '禁用原始字符串字面量'
# 'Disable real(KIND=10) from TargetCharacteristics'
H7AB18BD04A08: '禁用来自TargetCharacteristics的real(KIND=10)'
# 'Disable real(KIND=3) from TargetCharacteristics'
H184DC371A7A3: '禁用来自TargetCharacteristics的real(KIND=3)'
# 'Disable recovery for specified sanitizers'
HA007863682E4: '禁用指定sanitizers的恢复功能'
# 'Disable regpressure priority in sched=list-ilp'
HF6314D19EB9F: '禁用在sched=list-ilp调度中寄存器压力优先级'
# 'Disable removal of sext.w'
HB0977BC6B970: '禁用删除sext.w指令'
# 'Disable removal of sign-extend insn'
H484EAB4F216F: '禁用删除符号扩展指令'
# 'Disable replace with vector math call pass'
HC8A504A99877: '禁用用向量数学调用替换的pass'
# 'Disable sanitizer coverage instrumentation for modules and functions that match the provided special case list, even the allowed ones'
H8AE573AF38D9: '禁用与提供的特殊案例列表匹配的模块和函数的sanitizer覆盖检查插装，即使允许的那些'
# 'Disable sanitizer metadata for modules and functions that match the provided special case list'
H09C17F700040: '禁用与提供的特殊案例列表匹配的模块和函数的sanitizer元数据'
# 'Disable sanitizer statistics gathering.'
HFB69298094E2: '禁用sanitizer统计信息收集。'
# 'Disable sc.q instruction.'
H283A06DB04BD: '禁用sc.q指令。'
# 'Disable schedule adjustment for new value stores.'
H391300C49ACE: '禁用新值存储的调度调整'
# 'Disable scheduled-height priority in sched=list-ilp'
H9402AC53BA7A: '禁用在sched=list-ilp调度中的调度高度优先级'
# "Disable scheduler's two-address hack"
HE3E8E40A1932: '禁用调度器的二地址优化技巧'
# 'Disable scheduling addi instruction beforeload for ppc'
H06295571D2AE: '禁用在PPC中在加载前调度addi指令'
# 'Disable sdiv/smod insns'
HE1C6E99EA2FD: '禁用sdiv/smod指令'
# 'Disable select to branch conversion.'
H3543CDE71CB9: '禁用select到分支的转换'
# 'Disable sharing the FileManager when building a module implicitly'
H8B60BD26410A: '禁用在隐式构建模块时共享FileManager'
# 'Disable simplify-libcalls'
H49E652857C1A: '禁用简化库调用'
# 'Disable small data sections sorting'
H8333FC4754B0: '禁用小数据段排序'
# 'Disable specific target library builtin function'
HC0FDBC3C7F0C: '禁用特定目标库内建函数'
# 'Disable speculative execution side effect suppression (SESES)'
HC1901080B0A5: '禁用推测执行副作用抑制（SESES）'
# 'Disable spell-checking'
HF73309AEBDCA: '禁用拼写检查'
# 'Disable splitting double registers'
H5E3AECE38535: '禁用拆分双寄存器'
# 'Disable stack clash protection'
H8811AFD259AC: '禁用堆栈冲突保护'
# 'Disable stack coloring'
HC094CB265B68: '禁用栈着色'
# 'Disable stack probes which are enabled by default'
H7F863834E502: '禁用默认启用的堆栈探测'
# 'Disable standard #include directories for the C++ standard library'
HED953CC1E7C1: '禁用C++标准库的标准#include目录'
# 'Disable standard system #include directories'
HAB8A8040E467: '禁用标准系统#include目录'
# 'Disable standard system #include directories only'
HA5DB077BC490: '仅禁用标准系统#include目录'
# 'Disable store widening'
H4BB106975BD7: '禁用存储扩展'
# 'Disable store(extract) optimizations in CodeGenPrepare'
HD78BB1861BFD: '禁用CodeGenPrepare中的store(extract)优化'
# 'Disable string pooling'
HC733A3918F74: '禁用字符串池化'
# 'Disable strip W suffix'
HF34CE2AC1BA4: '禁用剥离W后缀'
# 'Disable support for K&R C function declarations'
HEA32A58B7196: '禁用对K&R C函数声明的支持'
# 'Disable support for exception handling'
HAC5AC768AAF8: '禁用异常处理支持'
# 'Disable support for int128_t type'
H064E25645BF2: '禁用对int128_t类型的支持'
# 'Disable symbolizing crash backtraces.'
HA299A2AEAED6: '禁用符号化崩溃回溯。'
# 'Disable tail call optimization, keeping the call stack accurate'
H8EF83315B758: '禁用尾调用优化，保持调用栈准确'
# 'Disable tail duplication'
HACA1C01DCC7A: '禁用尾部重复'
# 'Disable tail folding'
HA81C7EA6791A: '禁用尾部折叠'
# 'Disable tail-predication in the ARM LowOverheadLoop pass'
HF132A6CB93FD: '在ARM LowOverheadLoop Pass中禁用尾部推测'
# 'Disable that single precision floating-point divide and sqrt used in '
H475D4ABE9D62: '禁用在中使用的单精度浮点除法和平方根'
# 'Disable the ARM Parallel DSP pass'
H8178C8159BC2: '禁用ARM并行DSP Pass'
# 'Disable the CFI fixup pass'
H170DD55153F0: '禁用CFI修复Pass'
# 'Disable the DAG combiner'
HF3DAFFFFA107: '禁用DAG组合器'
# 'Disable the Sparc delay slot filler.'
HDE8C0A85D477: '禁用Sparc延迟插槽填充器。'
# 'Disable the abort'
H9CB580C2DD7C: '禁用中止'
# 'Disable the abort but emit a diagnostic on failure'
H84A7D406A5F3: '禁用中止，但在失败时会生成诊断信息'
# 'Disable the emission of assembler pseudo instructions'
H9E100408BFFF: '禁用生成汇编伪指令'
# 'Disable the expand reduction intrinsics pass from running'
H040AA8C3CBF5: '禁用展开约简固有函数传递的运行'
# 'Disable the generation of 4-operand madd.s, madd.d and related instructions.'
HB91438C02652: '禁用生成 4 操作数madd.s、madd.d及相关指令。'
# 'Disable the generation of low-overhead loops'
H1104A5C142EF: '禁用生成低开销循环'
# 'Disable the integrated assembler'
H779AD38A6D36: '禁用集成汇编器'
# 'Disable the loop interchange pass'
H8A139F798C85: '禁用循环交换pass'
# 'Disable the loop vectorization passes'
H55BB6EBCE09F: '禁用循环向量化pass'
# 'Disable the module hash'
H7FE90FAE4F03: '禁用模块哈希'
# 'Disable the parsing of an implicit top-level module op'
HF5D65FFCFADF: '禁用解析隐式顶层模块操作'
# 'Disable the pass entirely'
HA841AC9C39A5: '完全禁用该Pass'
# 'Disable the peephole optimizer'
H5AEFA90F7A64: '禁用窥孔优化器'
# 'Disable the select-optimization pass from running'
H0DA28C5C19DF: '禁用选择优化Pass的运行'
# 'Disable the usage of LEB128 directives, and generate .byte instead.'
HFFB7D99931FD: '禁用使用LEB128指令，并生成.byte代替。'
# 'Disable the use of non-volatile CR register fields'
H01F2C9F9FECF: '禁用使用非易失性CR寄存器字段'
# 'Disable the use of stack protectors'
HCC816F874533: '禁用栈保护机制'
# 'Disable the vector mask scheduling mutation'
H6FF8BC95F625: '禁用向量掩码调度变异'
# 'Disable the verifier on parsing (very unsafe)'
H314B68416CA8: '禁用解析时的验证器（非常不安全）'
# 'Disable the wasm-opt optimizer'
H214565A17764: '禁用wasm-opt优化器'
# 'Disable thread-safe initialization of static variables'
H9A6053E9675B: '禁用静态变量线程安全初始化'
# 'Disable threadgroup split execution mode (AMDGPU only)'
HFE9B2C98E16A: '禁用线程组拆分执行模式（仅AMDGPU）'
# 'Disable trapping for all sanitizers'
H434CA7F72650: '禁用所有sanitizer的溢出检测'
# 'Disable trapping for specified sanitizers'
H8374BC4644FA: '禁用指定sanitizer的溢出检测'
# 'Disable treating throwing global C++ operator new as always returning valid memory (annotates with __attribute__((returns_nonnull)) and throw()). This is detectable in source.'
H1293614D97E9: '禁用将抛出异常的全局C++ operator new视为始终返回有效内存（使用__attribute__((returns_nonnull))和throw()进行注解）。这在源代码中是可以检测到的。'
# 'Disable trigraphs (default)'
H739A08E7CEDE: '禁用三元符（默认）'
# 'Disable two address hints for register allocation'
H82ADA80F88F5: '禁用寄存器分配的两个地址提示'
# 'Disable two-phase name lookup in templates (default)'
HB877DF6B6337: '禁用模板中的两阶段名称查找（默认）'
# 'Disable type promotion pass'
HE0F6634D8D16: '禁用类型提升pass'
# 'Disable unclustered high register pressure reduction scheduling stage.'
HAE3C6A80BF96: '禁用未聚类的高寄存器压力减少调度阶段。'
# 'Disable unused template argument warnings.'
H8A2178DF0ED5: '禁用未使用的模板参数警告。'
# 'Disable unwind v2 (epilog) information for x64 Windows'
H2002C343134B: '禁用针对x64 Windows的展开v2（后序）信息'
# 'Disable use of DFA during scheduling'
HFCEBEB8744EF: '禁用调度期间的DFA使用'
# 'Disable use of LD/ST pairs for SME2 or SVE2p1'
H886738D62F05: '禁用SME2或SVE2p1中的LD/ST指令对使用'
# 'Disable use of builtin functions'
H6011A85599FF: '禁用内建函数'
# 'Disable use-after-destroy detection in MemorySanitizer'
H76DBA1F549C7: '禁用MemorySanitizer的已释放内存使用检测'
# 'Disable use-after-scope detection in AddressSanitizer'
HDEA7FE9A7621: '禁用AddressSanitizer的作用域外内存使用检测'
# 'Disable using constant pool for large integers.'
H8489E618879C: '禁用大整数的常量池使用'
# 'Disable using instrumentation data for profile-guided optimization'
H0DABDB711ED0: '禁用使用插桩数据进行配置文件引导型优化'
# 'Disable using library calls for save and restore'
HABD1CF6BBA21: '禁用保存和恢复的库调用'
# 'Disable validation'
H26FB09D2AB0A: '禁用验证'
# 'Disable validation of precompiled headers'
H2DA6E28812C6: '禁用预编译头验证'
# 'Disable validation of the diagnostic options when loading the module'
HE4C65ABEFA0D: '加载模块时禁用诊断选项的验证'
# 'Disable vector double new-value-stores'
H46E40B609BEA: '禁用向量双值新值存储'
# 'Disable verification of LLVM IR'
H1AB74862104E: '禁用LLVM IR的验证'
# 'Disable virtual register cycle interference checks'
H2BA1419A0C46: '禁用虚寄存器循环干扰检查'
# 'Disable whole program visibility (overrides enabling options)'
H1D60C5E310B2: '禁用整个程序可见性（覆盖启用选项）'
# 'Disable writing diagnostic options'
H37E0E37A8998: '禁用记录诊断选项'
# 'Disable writing header search paths'
HCFD8074000E3: '禁用写入头文件搜索路径'
# 'Disable x86 relax relocations'
HB7F95908656B: '禁用x86松弛重定位'
# 'Disabled.'
HBC2D62F7229F: '已禁用。'
# 'Disables -fvisibility-inlines-hidden-static-local-var (this is the default on non-darwin targets)'
H2552506748D2: '禁用-fvisibility-inlines-hidden-static-local-var（这是非Darwin目标的默认设置）'
# 'Disables combining addressing modes with different parts in optimizeMemoryInst.'
H1A57049BF682: '禁用在optimizeMemoryInst中合并不同部分的寻址模式'
# 'Disables debug printing for the new pass manager'
H92F40F826D39: '禁用新Pass管理器的调试打印'
# 'Disables evaluation of GetElementPtr with constant operands'
H5A42772B82EF: '禁用带有常量操作数的GetElementPtr求值'
# 'Disables inttoptr/ptrtoint roundtrip optimization'
H03E816B33DC1: '禁用inttoptr/ptrtoint往返优化'
# 'Disables potentially expensive checks in the transform interpreter, providing more speed at the expense of potential memory problems and silent corruptions'
H8C53B2F32644: '禁用转换解释器中可能昂贵的检查，以更快的速度换取潜在的内存问题和静默损坏'
# 'Disables the global instruction selector'
HD7298FC773DA: '禁用全局指令选择器'
# "Disallow '$' in identifiers"
HEC529DE7E6EB: '禁止在标识符中使用 "$"'
# 'Disallow MIPS delay filler to search backward.'
H93B2211830F9: '禁止MIPS延迟填充向后搜索。'
# 'Disallow MIPS delay filler to search forward.'
H0A7403D7CADA: '禁止MIPS延迟填充向前搜索。'
# 'Disallow MIPS delay filler to search successor basic blocks.'
H806FD91060E7: '禁止MIPS延迟填充搜索后续基本块。'
# 'Disallow __declspec as a keyword'
HC17ADE50EB84: '禁用将__declspec作为关键字'
# "Disallow alternative token representations '<:', ':>', '<%', '%>', '%:', '%:%:'"
HF519C51A2110: '禁止使用替代的标记表示形式 "<:", ":>", "<%", "%>", "%:", "%:%:"'
# 'Disallow atomic operations to ignore denormal mode'
HE8CD8EB9071A: '禁止原子操作忽略非正规模式'
# 'Disallow complex IT blocks'
H020AA42EE64B: '禁止复杂IT块'
# 'Disallow converting instructions with negative immediates to their negation or inversion.'
H4A70CE206CB7: '禁止将带有负立即数的指令转换为其否定或反向形式'
# 'Disallow generation of complex IT blocks. It is off by default.'
HB67D63CAAB67: '禁止生成复杂的IT块。默认情况下处于禁用状态。'
# 'Disallow generation of data access to code sections (AArch64/ARM only)'
HF9C8C76A5FB2: '禁止生成对代码段的数据访问（仅适用于AArch64/ARM）'
# 'Disallow merging of constants'
H70C4FD1FC35B: '禁止合并常量'
# 'Disallow use of CRC instructions (ARM only)'
HB840DEC2FEB5: '禁止使用CRC指令（仅适用于ARM）'
# 'Disallow use of CRC instructions (Mips only)'
H9E92A4FAF94C: '禁止使用CRC指令（仅适用于Mips）'
# 'Disallow use of movt/movw pairs (ARM only)'
H1C82DB59E408: '禁止使用movt/movw指令对（仅适用于ARM）'
# 'Disassemble strings of hex bytes'
H613CDE699EC0: '反汇编十六进制字节字符串'
# 'Disassembler Options'
H4DCD7C09D805: '反汇编选项'
# 'Discard names from Value (other than GlobalValue).'
H742AC63D224D: '丢弃 Value（除 GlobalValue 外）的名称。'
# 'Discard value names in LLVM IR'
HCD7AD84832F7: '在LLVM IR中丢弃值名称'
# 'Discarded elements by the linker.'
HD3934CD11684: '被链接器丢弃的元素。'
# 'Discriminator.'
H206A9AC4C507: '判别器。'
# 'Discriminators for inlined function instances.'
HCFDAECEFD17E: '内联函数实例的判别器。'
# "Display PDB's MS system elements."
H9055330B7E79: '显示PDB的MS系统元素。'
# 'Display all available options'
H4F3544FDA0B5: '显示所有可用选项'
# 'Display all basic blocks'
H75BB63BE80F7: '显示所有基本块'
# 'Display all class members including data, constants, typedefs, functions, etc'
HCA18E04B4029: '显示所有类成员，包括数据、常量、typedef、函数等'
# 'Display all symbols (default)'
H809598610BD8: '显示所有符号（默认）'
# 'Display all types (implies -classes, -enums, -typedefs)'
H5D20AC3AE6F6: '显示所有类型（包含 -classes、-enums、-typedefs 参数的功能）'
# 'Display any symbol or type with the specified exact name'
H2B91D0A39EC5: '显示具有指定精确名称的任何符号或类型'
# 'Display arrays'
HDC2B25BF5710: '显示数组类型'
# 'Display available options'
H46A7DC1788BB: '显示可用选项'
# 'Display available options (--help-hidden for more)'
HB2294B093626: '显示可用选项（使用 --help-hidden 查看更多）'
# 'Display branch counts instead of percentages (requires -b)'
HE5D58860A9A5: '显示分支计数而非百分比（需配合 -b 参数）'
# 'Display branch probabilities'
H1A848099A8E1: '显示分支概率'
# 'Display class types'
H4B4B15B36D12: '显示类类型'
# 'Display compilands'
H98204E2FD2A3: '显示编译单元'
# 'Display data symbols'
HE0831CC1C7E5: '显示数据符号'
# 'Display each error as well as a summary. [default]'
HB4E9ED4A232D: '显示每个错误以及摘要。 [default]'
# 'Display each error in detail but no summary.'
H84BA445E865B: '详细显示每个错误但不生成摘要。'
# 'Display enum types'
H7D0238663B0A: '显示枚举类型'
# 'Display execution times'
HA3302D5C387F: '显示执行时间'
# 'Display exploded graph using GraphViz'
H57BD4170B555: '使用GraphViz显示展开图'
# 'Display function signatures'
H616CCB32163A: '显示函数签名'
# 'Display function symbols'
H2496573880E0: '显示函数符号'
# 'Display help for hidden options'
H64D149DE5706: '显示隐藏选项的帮助信息'
# 'Display include stacks for diagnostic notes'
HBF49F525A9C8: '显示诊断注释的包含堆栈'
# 'Display injected sources'
H615D1D35669F: '显示注入的源代码'
# 'Display list of all available options'
HC3085F81E368: '显示所有可用选项的列表'
# 'Display list of available options (--help-list-hidden for more)'
H6C69B229E72D: '显示可用选项的列表（使用 --help-list-hidden 查看更多）'
# "Display lists of good files (no compile errors), problem files, and a combined list with problem files preceded by a '#'."
HC6E030BB5330: "显示良好文件列表（无编译错误）、问题文件列表，以及以 '#' 开头的问题文件合并列表。"
# 'Display method for pass statistics'
H93E064D4A3FD: '显示Pass统计信息的方法'
# 'Display method for timing data'
H6D05268C903F: '显示时间数据的方法'
# 'Display more information when dumping selection DAG nodes.'
H7335ABA75176: '在转储选择DAG节点时显示更多信息'
# 'Display only a summary of the errors found.'
HD9988E75DBC1: '仅显示发现错误的摘要。'
# 'Display patch-like changes'
H944897EBC1CF: '以补丁格式显示变更'
# 'Display patch-like changes in quiet mode'
H1874C26C00E8: '以安静模式显示补丁格式变更'
# 'Display patch-like changes in quiet mode with color'
HDA3927492A7C: '以安静模式并使用颜色显示补丁格式变更'
# 'Display patch-like changes with color'
HC5827DF84A7E: '使用颜色显示补丁格式变更'
# 'Display pointer types'
H5EE2D9F1E113: '显示指针类型'
# 'Display statistics as json data'
H332F68176CB1: '以JSON数据形式显示统计信息'
# 'Display suggestions to update code associated with -Wunsafe-buffer-usage warnings'
H5B046555524E: '显示与-Wunsafe-buffer-usage警告关联的代码更新建议'
# 'Display symbols for each compiland'
H087A1D8A2407: '为每个编译单元显示符号'
# 'Display the SLP trees with Graphviz'
H5A01A170758F: '使用Graphviz显示SLP树'
# "Display the compiler's target processor"
HFDA3133B76AB: '显示编译器的目标处理器'
# 'Display the count broken down by the filepath of each remark emitted. Requires remarks to have DebugLoc information.'
HDD5492CA6C68: '按每个备注发出的文件路径显示统计结果。需要备注包含DebugLoc信息。'
# 'Display the list of -analyzer-config options. These are meant for development purposes only!'
HEEAD9A5EE121: '显示-analyzer-config选项列表。这些仅用于开发目的！'
# 'Display the list of analyzer checkers that are available'
H74EADAEE0F8E: '显示可用的分析器检查器列表'
# 'Display the list of checker and package options'
H9FD261E9343C: '显示检查器和包选项列表'
# 'Display the list of checker and package options meant for development purposes only'
H99D575B08548: '显示仅用于开发目的的检查器和包选项列表'
# 'Display the list of developer-only checkers such as modeling and debug checkers'
H5D875C21A22A: '显示仅开发者可用的检查器列表，例如建模和调试检查器'
# 'Display the list of enabled analyzer checkers'
HDD1AC8873D07: '显示已启用的分析器检查器列表'
# 'Display the list of in development analyzer checkers. These are NOT considered safe, they are unstable and will emit incorrect reports. Enable ONLY FOR DEVELOPMENT purposes'
H9701D9AE6717: '显示正在开发中的分析器检查器列表。这些不被视为安全，可能不稳定，并会发出不正确的报告。仅允许用于开发目的'
# 'Display the list of in development checker and package options. These are NOT considered safe, they are unstable and will emit incorrect reports. Enable ONLY FOR DEVELOPMENT purposes'
H44975E30827B: '显示正在开发中的检查器和包选项列表。这些不被视为安全，可能不稳定，并会发出不正确的报告。仅允许用于开发目的'
# 'Display the statistics of each pass'
HC9CD9384324F: '显示每个pass的统计信息'
# 'Display the version of the compiler'
H5C279623CA4C: '显示编译器的版本'
# 'Display the version of this program'
H5228B6ADFC09: '显示本程序的版本'
# 'Display thunk symbols'
H60D32CD26A79: '显示thunk符号'
# 'Display typedef types'
H80D29E660696: '显示typedef类型'
# 'Display unconditional branch info (requires -b)'
H860C02BEA720: '显示无条件分支信息（需要-b选项）'
# 'Display vftable shapes'
H0BAEA6CF044D: '显示虚函数表形状'
# 'Displays only those classes which have at least the specified amount of immediate padding, ignoring padding internal to bases and aggregates.'
H4365E41B0200: '仅显示那些具有至少指定数量直接填充的类，忽略基类和聚合体内部的填充'
# 'Displays only those classes which have at least the specified amount of padding.'
HC457A02E6744: '仅显示那些填充量至少为指定值的类'
# 'Displays only those types which are greater than or equal to the specified size.'
H939E231DB942: '仅显示那些大小大于或等于指定值的类型'
# 'Distributor to use for ThinLTO backend compilations. Specifying this enables DTLTO.'
H94E676409243: '用于ThinLTO后端编译的分发器。指定此选项可启用DTLTO'
# 'Divisor of cold branch probability.BranchProbability = 1/ColdBranchProbDenom'
HFEB48317469C: '冷分支概率的除数。BranchProbability = 1/ColdBranchProbDenom'
# 'Do PGO instrumentation sampling'
H20E4EAC6B490: '进行PGO插桩采样'
# 'Do counter register promotion'
H9B115D4FE5B7: '进行计数器寄存器提升'
# 'Do counter update using atomic fetch add  for promoted counters only'
H7767713DC2D0: '仅对提升的计数器使用原子获取并加操作进行更新'
# 'Do more PHI writes than necessary in order to avoid partial accesses'
HE1D29CA7DAB8: '进行更多的PHI写入以避免部分访问'
# 'Do not accept non-standard constructs supported by the z/OS compiler'
HD8F703A83AED: '不接受z/OS编译器支持的非标准结构'
# 'Do not add %INCLUDE% to include search path'
H7E3445F24099: '不将%INCLUDE%添加到包含搜索路径'
# 'Do not add -rpath with architecture-specific resource directory to the linker flags. When --hip-link is specified, do not add -rpath with HIP runtime library directory to the linker flags'
H98822B20FC31: '不将带架构特定资源目录的-rpath添加到链接器标志。当指定--hip-link时，不将带HIP运行时库目录的-rpath添加到链接器标志'
# 'Do not add a BTI instruction after a setjmp or other return-twice construct (Arm/AArch64 only)'
H97946DA95B7B: '不在setjmp或其他返回两次结构之后添加BTI指令（仅限Arm/AArch64）'
# 'Do not add include paths for CUDA/HIP and do not include the default CUDA/HIP wrapper headers'
HCB5DBE4305C2: '不添加CUDA/HIP的包含路径，也不包含默认的CUDA/HIP包装头文件'
# 'Do not add instruction count to lsr cost model'
HE7651E5EC0B1: '不将指令计数添加到LSR成本模型中'
# 'Do not add parameter bounds and do no gist simplify sets accordingly'
HC6FB1327B189: '不添加参数边界，并且不相应地简化集合'
# 'Do not align and prefetch loops'
HFA5D85E291BA: '不进行循环对齐和预取'
# 'Do not allocate the LR register for general purpose usage, only for calls. (AArch64 only)'
H80E0CE8F43D2: '不要为通用用途分配LR寄存器，仅用于函数调用。 (仅AArch64)'
# 'Do not allow compiler to annotate sanitizer instrumentation with extra debug info for any sanitizers'
H4387C2461E4F: '不允许编译器为任何检查工具的插桩添加额外调试信息注解'
# 'Do not allow compiler to annotate sanitizer instrumentation with extra debug info for the specified sanitizers'
H0A0FD94EAF41: '不允许编译器为指定检查工具的插桩添加额外调试信息注解'
# 'Do not allow compiler to merge handlers for any sanitizers'
HC4FB93EDAFBC: '禁止编译器合并任何sanitizer的处理程序'
# 'Do not allow compiler to merge handlers for specified sanitizers'
H14D0727FA9D4: '禁止编译器合并指定sanitizer的处理程序'
# 'Do not assume C++ operator new may not return NULL'
H1F6F59A37FC5: '不假设C++运算符new不会返回NULL'
# 'Do not assume that any loop is finite.'
H5580E1E87EBF: '不假设任何循环是有限的。'
# 'Do not assume that externally defined data is in the small data if it meets the -G <size> threshold (MIPS)'
HAD54547B8D0E: '不假设符合-G<size> 阈值的外部定义数据位于小数据区 (MIPS)'
# 'Do not automatically generate or update the global module index'
H6DB4D9D7E3EF: '不自动生成或更新全局模块索引'
# 'Do not automatically import modules for error recovery'
H8260A94CB46D: '不自动导入模块以进行错误恢复'
# 'Do not build run-time checks to proof absence of integer wrapping'
H067730FFEE80: '不构建运行时检查以证明不存在整数溢出'
# 'Do not bundle output files of HIP device compilation'
H3591F62084D9: '不打包HIP设备编译的输出文件'
# 'Do not check authenticated address'
H0709C5934F02: '不检查认证地址'
# 'Do not color Edges'
HAA019B0E453C: '不着色边'
# 'Do not color Vertices'
HCD93BE0D4AC9: '不着色顶点'
# 'Do not color vertices'
H1FA039A4B956: '不着色顶点'
# 'Do not combine ALU and memory operators'
H22D1C7806EDC: '不合并ALU和内存操作符'
# 'Do not consider inline-asm a scheduling/packetization boundary.'
H930DAD5CB7A3: '不将内联汇编视为调度/分组边界。'
# 'Do not convert branches that may exit the loop'
H912C8CC5220C: '不转换可能导致退出循环的分支'
# 'Do not convert find-first-byte loop(s).'
H586B9EEE9F17: '不转换查找第一个字节的循环。'
# 'Do not create a host fallback if offloading to the device fails.'
HFCABEED29F02: '如果设备卸载失败，不创建主机回退。'
# 'Do not create extra branches to split comparison logic.'
H67D6951DD9C2: '不创建额外分支来拆分比较逻辑。'
# 'Do not create unit-strided loops (default)'
HA7BFEC1D48BB: '不创建单位步长循环（默认）'
# 'Do not discard comments when preprocessing'
HF9B5FA45AABB: '预处理时不丢弃注释'
# 'Do not discard value names in LLVM IR'
H4D77D8B34317: '不丢弃LLVM IR中的值名称'
# 'Do not dllexport/dllimport inline member functions of dllexport/import classes'
H178235CEFFFB: '不dllexport/dllimport导出/导入类的内联成员函数'
# 'Do not drop any type tests'
H0426A41590E9: '不省略任何类型检查'
# 'Do not dump MSF file headers'
H5B5B36671D5C: '不导出MSF文件头'
# 'Do not elide types when printing diagnostics'
HAAA41F99F968: '打印诊断信息时不要省略类型'
# 'Do not eliminate read instrumentation for read-before-writes'
HFAB29E5FAAB8: '不消除读操作的读写前检测'
# 'Do not embed'
H58D31A15C486: '不嵌入'
# 'Do not emit  debug info for defined but unused types'
HB04F2AC6377B: '不生成已定义但未使用的类型的调试信息'
# 'Do not emit RTTI data'
H0669AFF65C8F: '不生成RTTI数据'
# "Do not emit a trap instruction for 'unreachable' IR instructions after noreturn calls, even if --trap-unreachable is set."
HB71318F0BBDA: '即使设置了--trap-unreachable，也不在noreturn调用后的不可达IR指令处生成陷阱指令。'
# 'Do not emit code that uses the red zone.'
H4923C3F307F8: '不生成使用red zone的代码'
# 'Do not emit code to make initialization of local statics thread safe'
HB028FFDC42D1: '不生成使局部静态变量初始化线程安全的代码'
# 'Do not emit code to perform on-demand initialization of thread-local variables'
HC624E884FFD9: '不生成按需初始化线程局部变量的代码'
# 'Do not emit macro debug information'
H8F91A57AE16C: '不生成宏的调试信息'
# 'Do not emit metadata containing compiler name and version'
HAB66E1C6275C: '不生成包含编译器名称和版本的元数据'
# 'Do not emit pseudo probes for sample profiling'
H98592A339F09: '不为采样分析生成伪探测点'
# 'Do not emit remarks about assumptions that are known'
H0F5A09E813C1: '不生成关于已知假设的注释'
# 'Do not enforce -fmodules-decluse and private header restrictions for textual headers. This flag will be removed in a future Clang release.'
H0CAD9E73AF57: '不强制执行 -fmodules-decluse 和私有头文件限制对文本头文件的要求。此标记将在未来的Clang版本中移除。'
# 'Do not error on use of NSAllocateCollectable/NSReallocateCollectable'
HFB2D301661F8: '不对 NSAllocateCollectable/NSReallocateCollectable 的使用报错'
# 'Do not execute loaded code'
HAC6A8BA715B2: '不执行加载的代码'
# 'Do not extend the -G behaviour to object local data (MIPS)'
HE38064F00B03: '不将 -G 行为扩展到局部对象数据（MIPS）'
# 'Do not fail and just print warnings.'
H194F6AFAEB48: '不失败，仅打印警告。'
# 'Do not fail on the first error.'
H09A7570CEE99: '不在首次错误时失败'
# 'Do not follow the AAPCS standard requirement stating that volatile bit-field width is dictated by the field container type. (ARM only).'
H33C6AFA87C27: '不遵循 AAPCS 标准中关于易失性位段宽度由容器类型决定的要求（仅限ARM）'
# 'Do not force validation of user headers when repeatedly loading a module file within single build session'
HC2C2C627ADC2: '在单次构建会话中重复加载模块文件时不要强制验证用户头文件'
# 'Do not generate code for uses of this PCH that assumes an explicit object file will be built for the PCH'
H882EA3DF4A8E: '不为此PCH生成假定显式目标文件会被构建的代码'
# 'Do not generate comments'
H64C7ECF357DC: '不生成注释'
# 'Do not generate debug info for types in an object file built from this PCH and do not generate them elsewhere'
H4C63A76D37C7: '不为此PCH生成对象文件中的类型调试信息，也不在其他位置生成'
# 'Do not generate same-address load-load barrier instructions (dbar 0x700)'
HAC760584246F: '不要生成同地址加载-加载屏障指令（dbar 0x700）'
# 'Do not globally set the denormals-are-zero (DAZ) and flush-to-zero (FTZ) bits in the floating-point control register on program startup'
H792FD67CD9D7: '程序启动时不全局设置浮点控制寄存器中的denormals-are-zero（DAZ）和flush-to-zero（FTZ）位'
# 'Do not hoist instructions if targetblock is N times hotter than the source.'
HFE3581AD2058: '如果目标块的热度是源块的N倍，则不提升指令。'
# "Do not include PTX for the following GPU architecture (e.g. sm_35) or 'all'. May be specified more than once."
H3358F862A98F: "不包含以下GPU架构的PTX（例如 sm_35）或 'all'。可多次指定此选项。"
# 'Do not include column number on diagnostics'
H6BC5ADEE7CCD: '不在诊断信息中包含列号'
# 'Do not include declarations inside namespaces (incl. global namespace) in the code-completion results.'
HB945B735ADE9: '不在代码补全结果中包含命名空间内的声明（包括全局命名空间）。'
# 'Do not include fixit information in diagnostics'
H9F028B9AB9A0: '不在诊断信息中包含修正建议信息'
# 'Do not include global declarations in code-completion results.'
H5184034D4282: '不在代码补全结果中包含全局声明'
# 'Do not include source location information with diagnostics'
HC43E127B525B: '不在诊断信息中包含源位置信息'
# 'Do not include the default HIP wrapper headers and include paths'
HF033C0F0A8BE: '不包含默认的HIP包装头文件和包含路径'
# 'Do not inline functions with a stack size that exceeds the specified limit'
HF6E40440F4E2: '不内联堆栈大小超过指定限制的函数'
# 'Do not inline hlfir.copy_in operations'
H36767557A51A: '不内联hlfir.copy_in操作'
# 'Do not inline recursive functions with a stack size that exceeds the specified limit'
HE8D9228D38D0: '不内联堆栈大小超过指定限制的递归函数'
# 'Do not instrument callsites to functions in this list. Intended for testing.'
HEEE67A6ADD3A: '不检测此列表中函数的调用点。用于测试目的。'
# 'Do not instrument functions smaller than this threshold.'
H0676C97A079B: '不检测小于该阈值的函数。'
# 'Do not instrument functions with the number of critical edges  greater than this threshold.'
HAC5F841AADEE: '不检测临界边数量超过该阈值的函数。'
# 'Do not instrument promotable allocas'
HFE692DA83BC2: '不为可提升的alloca进行插桩'
# 'Do not label Edges'
H02B067792434: '不标记边'
# 'Do not label Vertices'
HF8CF06D59C0D: '不标记顶点'
# 'Do not let object file auto-link default libraries'
H77A1B6D3EF99: '不允许目标文件自动链接默认库'
# 'Do not link against HIP runtime libraries'
H29FEC2BA3B74: '不链接HIP运行时库'
# 'Do not link device library for CUDA/HIP device compilation'
HEC768FBA7D56: '不为CUDA/HIP设备编译链接设备库'
# 'Do not make the jump table addresses canonical in the symbol table'
H6138F7A3816E: '不在符号表中使跳转表地址标准化'
# 'Do not modify integer comparisons.'
H85B2E33EE3E8: '不修改整数比较。'
# 'Do not omit the RTTI component from virtual tables'
H29D8FAD7370D: '不省略虚函数表中的RTTI组件'
# 'Do not optimize lifetime zones that are broken'
HDB8A084545A8: '不优化已损坏的生命周期区域'
# 'Do not output any .gcov files'
H5B1E0C37199B: '不输出任何.gcov文件'
# 'Do not override toolchain to compile HIP source to relocatable'
H67099DA33091: '不覆盖工具链以将HIP源代码编译为可重定位目标'
# 'Do not pack non-contiguous assumed shape dummy arrays into contiguous memory'
HCB4D2BF8E235: '不要将非连续的假设形状虚拟数组打包到连续内存'
# 'Do not place constants in the .rodata section instead of the .sdata if they meet the -G <size> threshold (MIPS)'
H21A91E9ACB5C: '不将符合-G<size> 阈值的常量放入.rodata节段而非.sdata节（MIPS）'
# 'Do not preserve comments in inline assembly'
H942DAB64A211: '不在内联汇编中保留注释'
# 'Do not prevent DecoderTable duplications caused by HwModes'
H38CABD41B4CC: '不阻止由HwModes导致的DecoderTable重复'
# 'Do not print instruction tables'
HF7003F2ECEFB: '不打印指令表'
# 'Do not print per-code histogram'
HC08155C4172C: '不打印按代码划分的直方图'
# 'Do not print the name of each compiled file (default)'
H5DF4E1712DEF: '不显示每个已编译文件的名称（默认）'
# 'Do not process trigraph sequences'
H0D43C57804DE: '不处理三元序列'
# 'Do not produce relaxation hints for linkers to try optimizing PIC call sequences into direct calls (MIPS only)'
HCE5BC5F9BE43: '不为链接器生成优化PIC调用序列的提示（仅MIPS）'
# 'Do not prune non-affecting module map files when writing module files'
H5ABD84685A1F: '写入模块文件时不修剪无影响的模块映射文件'
# 'Do not put each data item in its own section (default)'
HF88D281A3FD5: '不将每个数据项放入独立节段（默认）'
# 'Do not put each function in its own section (default)'
HCE20256E9133: '不将每个函数放入独立节段（默认）'
# 'Do not re-analyze paths leading to exhausted nodes with a different strategy (may decrease code coverage)'
HDFE0F346053C: '不以不同策略重新分析导致节点耗尽的路径（可能导致代码覆盖率下降）'
# 'Do not read real performance counters, use dummy values (for testing)'
H85D51A611E68: '不读取真实的性能计数器，使用占位值（用于测试）'
# 'Do not rebase if number of dependent constants of a Base is less than this number.'
H5F4C154B55E1: '如果基类的依赖常量数量小于该数值，则不重新定位'
# 'Do not record stack ring history'
HFF15CDD011A3: '不记录堆栈环形历史'
# 'Do not remove finalize method in gc mode'
H986F722192B5: '在gc模式下不移除finalize方法'
# 'Do not remove function attributes'
HAF5DC7041092: '不移除函数属性'
# 'Do not remove global named metadata'
H8C721AA4D60E: '不移除全局命名元数据'
# 'Do not remove global variables'
H715B487CBBAD: '不移除全局变量'
# 'Do not remove implausible terminators or other similar cleanups'
HFBFADCCB2615: '不移除不合理的终止符或其他类似的清理操作'
# 'Do not report an error for non-bitcode files in archives'
H656A3544880E: '对于归档文件中的非比特码文件不报告错误'
# 'Do not require member pointer base types to be complete if they would be significant under the Microsoft ABI'
H7A0FDA03C4CD: '不强制要求在Microsoft ABI下有意义的成员指针基类型必须完整'
# "Do not resolve lli process symbols in JIT'd code"
HF4ADB638CB76: '不在JIT编译的代码中解析lli进程符号'
# 'Do not resolve to llvm-jitlink process symbols'
H0C15A19D6DA3: '不解析llvm-jitlink进程符号'
# 'Do not run the verifier'
H227D5D3081B9: '不运行验证器'
# 'Do not run the verifier during the optimization pipeline'
H812C7F5AE104: '不在优化管线中运行验证器'
# 'Do not run verifier on input LLVM (dangerous!)'
H91033F23321D: '不在输入的LLVM上运行验证器（危险！）'
# 'Do not separate the constant offset from a GEP instruction'
H1A5B4ED53276: '不将GEP指令中的常量偏移量分离出来'
# 'Do not set the default structure layout to be compatible with the Microsoft compiler standard'
H9523EC62FA32: '不将结构布局默认设置为与Microsoft编译器标准兼容'
# 'Do not sink instructions that have too many uses.'
H7989366B848B: '不下沉使用次数过多的指令'
# 'Do not sink instructions that require cloning unless they execute less than this percent of the time.'
HFCE852F940A6: '除非这些指令的执行频率低于该百分比，否则不克隆下沉指令'
# 'Do not split loads or stores'
H5C77F77F7EDB: '不分裂加载或存储操作'
# 'Do not strip debug info metadata'
H72442AB7AE2C: '不剥离调试信息元数据'
# 'Do not strip debug type info metadata'
H773E596FDA32: '不剥离调试类型信息元数据'
# 'Do not take inbounds assumptions at all'
H3B09FD23C9A9: '完全不采用区间假设'
# 'Do not treat C++ operator name keywords as synonyms for operators'
HF45D733F49BB: '不将C++运算符关键字视为运算符的同义词'
# 'Do not treat all horizontal whitespace as equivalent'
H821E9671833B: '不将所有水平空白字符视为等效'
# 'Do not treat usage of null pointers as undefined behavior'
H81D67D4AE33E: '不将空指针的使用视为未定义行为'
# 'Do not treat warnings as errors (default)'
H9D2EBEBFE5AF: '不将警告视为错误（默认）'
# 'Do not try to find alias store for a load if the block number in the straight line is higher than this threshold.'
HA9F23FA6536D: '如果直线路径中的块号超过此阈值，则不尝试为加载查找别名存储。'
# 'Do not try to find alias store for a load if there is a in-path block whose instruction number is higher than this threshold.'
H9F8822A4702E: '如果路径内块的指令号超过此阈值，则不尝试为加载查找别名存储。'
# 'Do not use CSPGO.'
HF15B70CBCC17: '不使用CSPGO。'
# 'Do not use GP relative accesses for symbols known to be in a small data section (MIPS)'
HD0753F3CDAB8: '不使用GP相对寻址访问已知在小数据节中的符号（MIPS）'
# 'Do not use HLFIR lowering (deprecated)'
HE332EA8EB38E: '不使用HLFIR降级（已弃用）'
# 'Do not use PGO.'
H19DC80776155: '不使用PGO。'
# 'Do not use an early exit if isLiveOutPastPHIs returns true.'
HA74DFEC29B52: '如果 isLiveOutPastPHIs 返回 true，则不使用提前退出'
# 'Do not use compact branches if possible.'
H541C69D3E8C0: '如果可能，不使用紧凑分支。'
# 'Do not use div.w[u] and mod.w[u] instructions with input not sign-extended.'
H5B65DD1D4E29: '不要在输入未进行符号扩展时使用div.w[u]和mod.w[u]指令'
# 'Do not use hardware multiplier'
H2D984261D820: '不使用硬件乘法器'
# 'Do not use jump tables for lowering switches'
H553BE5736ED7: '不要在降级switch语句时使用跳转表'
# 'Do not use more megabytes of memory'
HABD5A40DFA1B: '不使用超过此数量的兆字节内存'
# 'Do not use the -dce pass to reduce testcases'
HAA57D41E6E51: '不使用-dce pass来精简测试用例'
# 'Do not use the -simplifycfg pass to reduce testcases'
H29CCC0670DF0: '不使用-simplifycfg pass来精简测试用例'
# 'Do not use the analyzed objects when unparsing'
H83CE402540D9: '在反编译时不要使用已分析的对象'
# 'Do not use the experimental C++ class ABI for classes with virtual tables'
H6D985C46C06C: '不要为带有虚表的类使用实验性的C++类ABI'
# 'Do not validate testcase is interesting after counting chunks (may speed up reduction)'
HA696CDBE3AE6: '在计算块之后不验证测试用例是否有趣（可能加快缩减）'
# 'Do not verify input module'
H39AA36F540E0: '不验证输入模块'
# 'Do not warn about individual formatting changes needed. Used only with --dry-run or -n'
H754226DD39F9: '不报告需要单独格式更改的警告。仅与 --dry-run 或 -n 一起使用'
# 'Do not write current time into COFF output (breaks link.exe /incremental)'
HBABC5A49FA79: '不要将当前时间写入COFF输出（破坏link.exe /incremental）'
# 'Do not write result bitcode file'
H22D616F37560: '不写入结果比特码文件'
# 'Do not zero initialize globals without default initialization'
HECF1970A8089: '不要对未进行默认初始化的全局变量进行零初始化'
# 'Do nothing'
HD268BA5209C4: '不执行任何操作'
# 'Do profile annotation and inlining for functions in top-down order of call graph during sample profile loading. It only works for new pass manager. '
HF43D143A0C90: '在加载示例配置文件期间，按调用图自上而下的顺序为函数进行配置文件注释和内联。仅适用于新式Pass管理器。'
# 'Do pseudo probe verification'
HC942827254CC: '执行伪探针验证'
# 'Do static counter allocation for value profiler'
H465B564B215B: '为值分析器进行静态计数器分配'
# 'Document only public declarations.'
HAA6808E72416: '仅文档化公共声明。'
# 'Documentation in HTML format.'
H35BAD16C1698: '以HTML格式生成文档。'
# 'Documentation in JSON format'
HF1E57A499766: '以JSON格式生成文档'
# 'Documentation in MD format.'
HA974194AB003: '以Markdown格式生成文档。'
# 'Documentation in YAML format.'
H5814855B30B7: '以YAML格式生成文档。'
# 'Documentation in mustache HTML format'
H1B1C504B8FE0: '以mustache HTML格式生成文档'
# 'Dominance Frontier Construction'
H0D043E29B031: '支配前缘构造'
# 'Dominator Tree Construction'
HD7B4E93722B4: '支配树构建'
# "Don't Use the new driver for offloading compilation."
H348818D3A16A: '不要使用新的驱动程序进行卸载编译'
# "Don't allow device side init function in HIP (experimental)"
H8D56505F6239: '不允许在HIP中使用设备端初始化函数（实验性）'
# "Don't allow loop unrolling to simulate more than this number of iterations when checking full unroll profitability"
HA88E0E56432E: '不允许循环展开在检查完全展开可行性时模拟超过此数量的迭代次数'
# "Don't assume assembly file starts in the text section"
HFEF6F05E02CF: '不假设汇编文件从文本段开始'
# "Don't assume data segments are relative to text segment"
H1D0D36BE1FD6: '不要假设数据段相对于文本段'
# "Don't assume that C++'s global operator new can't alias any pointer"
HC32AE2553730: '不要假设C++的全局operator new不能与任何指针别名'
# "Don't assume that kernels are launched with uniform block sizes (default true for CUDA/HIP and false otherwise)"
H328B84E6AEC0: '不要假设内核是以统一的块大小启动的（默认CUDA/HIP为true，其他情况为false）'
# "Don't automatically start assembly file with a text section"
HB573B3460C18: '不要自动以代码段开头生成汇编文件'
# "Don't clear counters across dumps (use with instrumentation-sleep-time option)"
HFB41C45D3123: '不跨转储清除计数器（需与 instrumentation-sleep-time 选项配合使用)'
# "Don't clear the Clang AST before running backend code generation"
H438A0AAAB7E0: '在运行后端代码生成前不要清除Clang的AST'
# "Don't convert memcpy to TP loop."
H4B53144272CD: '不将memcpy转换为TP循环。'
# "Don't defer host/device related diagnostic messages for CUDA/HIP"
H9AB401869BF7: '不要延迟CUDA/HIP的主机/设备相关诊断信息'
# "Don't demangle function names"
H618F1A05266D: '不解除函数名的符号修饰'
# "Don't disable block signature string)"
HD22256B8D923: '不要禁用块签名字符串)'
# "Don't disable features used for crash debugging (crash reports, llvm-symbolizer and core dumps)"
HA02320B35AF6: '不禁用崩溃调试所用功能（崩溃报告、llvm-symbolizer 和核心转储）'
# "Don't disable freeing of memory on exit"
HE9E8ABFA5D70: '不要禁用退出时的内存释放'
# "Don't discard temporary labels"
H59AD35796471: '不丢弃临时标签'
# "Don't display class definitions"
HF6C8FDDA5009: '不显示类定义'
# "Don't display full enum definitions"
HB5A6C783A07D: '不显示完整的枚举定义'
# "Don't do the coverage check."
H193F8F133737: '不执行覆盖检查。'
# "Don't dump anything."
HA287D365311B: '不输出任何内容。'
# "Don't emit an address-significance table"
H7A772E673769: '不要生成地址重要性表'
# "Don't emit anything (for timing purposes)"
H097B7300276D: '不生成任何内容（用于计时目的）'
# "Don't emit compiler path and command line into CodeView debug information"
H76DE26A5896D: '不要将编译器路径和命令行写入CodeView调试信息'
# "Don't emit errors on invalid analyzer-config inputs"
H344F10286BA2: '不要对无效分析器配置输入发出错误'
# "Don't emit inline line tables."
H18C272BB702A: '不要生成内联行表'
# "Don't emit warning for unused driver arguments"
HCD60E199F7C0: '不为未使用的驱动程序参数生成警告'
# "Don't emit warnings about unused arguments for the following arguments"
H2C209A90E709: '不为以下参数生成有关未使用参数的警告'
# "Don't error out if the detected version of the CUDA install is too low for the requested CUDA gpu architecture."
H16AC4195802C: '若检测到的CUDA安装版本过低且无法支持请求的CUDA GPU架构时，不报错'
# "Don't expand conditional move related pseudos for Mips 16"
H68A3ACC276BC: '不展开Mips 16 相关的条件移动伪指令'
# "Don't export branch data (LCOV)"
H15B1E91EF10C: '不导出分支数据（LCOV）'
# "Don't export expanded source regions"
H4609EDADC332: '不导出展开的源区域'
# "Don't export per-function data"
H2769FE377EEE: '不导出每个函数的数据'
# "Don't extract blocks when searching for miscompilations"
H82D476F902A7: '在搜索误编译时不提取代码块'
# "Don't extract loops when searching for miscompilations"
H9384DB503321: '在搜索误编译时不提取循环'
# "Don't generate implicit floating point or vector instructions"
H54B5124D5D1B: '不生成隐式浮点或向量指令'
# "Don't generate local calls to out-of-line atomic operations"
H96F508547438: '不生成对行外原子操作的本地调用'
# "Don't include vectorization factors, etc."
HB5557A169D42: '不包含向量化因子等'
# "Don't instrument functions with loops unless they also meet the minimum function size"
H574C69576F45: '除非函数大小达到最小值，否则不对包含循环的函数进行插桩'
# "Don't instrument scalar globals"
H6894CA3DD417: '不对标量全局变量进行插装'
# "Don't instrument scalar stack variables"
H87D069F48ECC: '不对标量栈变量进行插装'
# "Don't keep static const variables even if unused"
H286AB8A3B099: '即使未使用，也不保留静态常量变量'
# "Don't match or outline intrinsics"
H34D78D938C2B: '不匹配或外联固有函数'
# "Don't mutate strict-float node to a legalize node"
H6DCCA4AAE41B: '不将严格浮点节点转换为合法化节点'
# "Don't output the .ll file"
H1B261E3A62B3: '不输出.ll文件'
# "Don't perform type checking of the assembly code (wasm only)"
HDF197C4FAB89: '不执行汇编代码的类型检查（仅wasm）'
# "Don't place zero initialized data in BSS"
H2108D326FE0B: '不将零初始化数据放置在BSS段'
# "Don't place zero-initialized symbols into bss section"
H6FEBA18EB379: '不将零初始化的符号放入bss段'
# "Don't prefer any addressing mode"
H8ABFDD32EA98: '不优先选择任何寻址模式'
# "Don't preserve line numbers (default)"
H9468F0C93544: '不保留行号（默认）'
# "Don't preserve order of LLVM use-lists when serializing"
HC0EBF389C575: '序列化时不对LLVM使用列表的顺序进行保留'
# "Don't propagate function-attrs in thinLTO"
HA4C570976962: '在thinLTO中不传播函数属性'
# "Don't relax loads to long loads - for testing purposes"
H30C29761BE41: '不将加载操作松弛为长加载 - 用于测试目的'
# "Don't run the LLVM IR verifier pass"
H5E9DB83319CA: '不运行LLVM IR验证器Pass'
# "Don't run the LLVM verifier during the optimization pipeline"
HBB1839A83C81: '不在优化管线中运行LLVM验证器'
# "Don't show any SymIndexId fields (overrides -hierarchy)"
H9033D913589F: '不显示任何SymIndexId字段（覆盖-hierarchy选项）'
# "Don't show compiler generated types and symbols"
H6CE8BA80D4D4: '不显示编译器生成的类型和符号'
# "Don't show symbols from system libraries"
H1D2970DB0285: '不显示系统库中的符号'
# "Don't specialize functions that have less than this number of instructions"
H6394C9853CC0: '不专门化指令数量少于该数值的函数'
# "Don't specify that kernel argument names are preserved (HIP only)"
H682A59EE1E8F: '不指定内核参数名称将被保留（仅适用于HIP）'
# "Don't specify that single precision floating-point divide and sqrt used in the program source are correctly rounded (HIP device compilation only)"
HAC5422C51310: '不指定程序源代码中使用的单精度浮点除法和平方根运算需要正确舍入（仅适用于HIP设备编译）'
# "Don't tail-predicate loops"
H2D6501929AEC: '不尾判定循环'
# "Don't tail-predicate loops, create scalar epilogue"
H9B8DA5043D54: '不尾判定循环，创建标量尾部代码'
# "Don't treat conditional branches as disclosure gadgets. This may improve performance, at the cost of security."
H9B8D554F070F: '不将条件分支视为信息泄露构件。这可能会提升性能，但会降低安全性。'
# "Don't treat control flow paths that fall off the end of a non-void function as unreachable"
H5D4780A60912: '不将非void函数末尾未明确终止的控制流路径视为不可达代码'
# "Don't treat unattributed constexpr functions as __host__ __device__."
HE736239C2F73: '不将未加注释的constexpr函数视为__host__ __device__'
# "Don't try to avoid heapifying local blocks"
HA0E5E1480194: '不尝试避免将本地块堆化'
# "Don't use GOT indirection to reference external data symbols"
H446ED22B127C: '引用外部数据符号时不使用GOT间接寻址'
# "Don't use LLVM/Offload as portable offloading runtime."
H993CF148793E: '不使用LLVM/Offload作为可移植的卸载运行时'
# "Don't use __cxa_atexit for calling destructors"
HB9FAC41CF208: '不使用__cxa_atexit调用析构函数'
# "Don't use a const qualified type for string literals in C and ObjC"
H45BD6EFBF0D7: '在C和ObjC中不对字符串字面量使用const限定类型'
# "Don't use a uniquing type map for debug info"
HD459DA46855B: '不使用唯一类型映射处理调试信息'
# "Don't use approximate transcendental functions"
H0ED50C803EDB: '不要使用近似超越函数'
# "Don't use atexit or __cxa_atexit to register global destructors"
HC46180126A88: '不要使用 atexit 或 __cxa_atexit 注册全局析构函数'
# "Don't use constructor homing for debug info"
HD49F3B3625FB: '不要为调试信息使用构造函数定位'
# "Don't use ignorelist file for sanitizers"
HFDCDF48F9121: '不要为 sanitizers 使用忽略列表文件'
# "Don't use new kernel launching API for HIP"
HFB5E65669ABA: '不要为 HIP 使用新的内核启动 API'
# "Don't use the new driver for OpenMP offloading."
H301CA6785230: '不要使用 OpenMP 卸载的新驱动程序'
# "Don't use unique names for text and data sections"
H8E78A20B661E: '不要为文本和数据段使用唯一名称'
# "Don't verify input files for the modules if the module has been successfully validated or loaded during this build session"
HE1A69C7730A8: '如果在此构建会话期间已成功验证或加载模块，则不要验证模块的输入文件'
# "Don't verify that MIR is fully legal between GlobalISel passes"
H2547A49B1E5F: '不验证GlobalISel passes之间的MIR是否完全合法'
# "Don't work around Cortex-A57 Erratum 1742098 (ARM only)"
H3E4B9BDEA672: '不要为 Cortex-A57 错误 1742098 进行变通处理（仅 ARM）'
# "Don't work around Cortex-A72 Erratum 1655431 (ARM only)"
HBBA28409C8FE: '不要为 Cortex-A72 错误 1655431 进行变通处理（仅 ARM）'
# "Don't work around VLLDM erratum CVE-2021-35465 (ARM only)"
H2D48982037C5: '不要为 VLLDM 错误 CVE-2021-35465 进行变通处理（仅 ARM）'
# "Don't workaround Cortex-A53 erratum 835769 (AArch64 only)"
H674F1B2934BD: '不要为 Cortex-A53 错误 835769 进行变通处理（仅 AArch64）'
# "Don't write fields with default values"
HDC62F7F06017: '不写入具有默认值的字段'
# "Dot-separated value representing the Microsoft compiler version number to report in _MSC_VER (0 = don't define it (default))"
H3158063BCCC4: '用点分隔的数值，表示报告到 _MSC_VER 的 Microsoft 编译器版本号（0 = 不定义该宏（默认））'
# 'Dr. Watson Assassin.\n'
H2FDABEFA9036: '沃森博士终结者。\n'
# 'Drop all type test sequences'
HA428B8584F95: '丢弃所有类型测试序列'
# 'Drop the profile symbol list when merging AutoFDO profiles (only meaningful for -sample)'
HF313BEF9935A: '合并AutoFDO配置文件时丢弃profile符号列表（仅对-sample有意义）'
# 'Drop type test assume sequences'
HB2138C89F2F0: '丢弃类型测试假设序列'
# 'DummyCGSCCPass'
H4B94DA391D3F: 'DummyCGSCCPass'
# 'Dump AMDGPU HSA Metadata'
HAD21DA71DA94: '转储AMDGPU HSA元数据'
# 'Dump C11 CodeView debug chunks'
HE18236D9F17D: '转储C11 CodeView调试块'
# 'Dump C13 CodeView debug chunk subsection'
H0E6AB0F1E2CC: '转储C13 CodeView调试块子部分'
# 'Dump CallingContextGraph to stdout after each stage.'
HE2FF79E701CA: '在每个阶段后将CallingContextGraph转储到标准输出'
# 'Dump IR after transformation happens'
H27451FBBE078: '在发生转换后转储IR'
# 'Dump IR from modules to stderr on shutdown'
H16357A60101D: '在关闭时将模块的IR转储到标准错误输出'
# 'Dump IR to reproduce successful transformations.'
H30BFC03DFD55: '转储可重现成功转换的IR'
# 'Dump JITted-compiled object to file <input file>.o'
HCEEB046B9401: '将JIT编译后的对象转储到文件<输入文件>.o'
# 'Dump JITted-compiled object to file specified with -object-filename (<input file>.o by default).'
HF39EA47FD712: '将JIT编译后的对象转储到通过-object-filename指定的文件（默认为<输入文件>.o）'
# 'Dump MIR with SPIR-V dependencies info'
H3C877ECA1BED: '转储带有SPIR-V依赖信息的MIR'
# 'Dump __jit_debug_descriptor contents to stdout'
HEDC251CD7F96: '将__jit_debug_descriptor内容转储到标准输出'
# 'Dump __jit_debug_descriptor in-memory debug objects as tool output'
HEFEA598ED348: '将__jit_debug_descriptor内存调试对象作为工具输出转储'
# 'Dump a detailed breakdown of IPI types usage/size'
HE1625844BBC6: '详细分解IPI类型使用/大小'
# 'Dump a detailed breakdown of S_UDT record usage / stats'
HFAECE5B8125B: '详细分解S_UDT记录使用/统计信息'
# 'Dump a detailed breakdown of symbol usage/size for each module'
HC9A6B5A07738: '按模块详细分解符号使用/大小'
# 'Dump a detailed breakdown of type usage/size'
H55DC9D5447F4: '详细分解类型使用/大小'
# "Dump all declarations in old header (JSON format) to stdout. If the option is specified, other command options will be ignored. An empty JSON will be returned if old header isn't specified."
H716B07B285CE: '将旧头文件（JSON格式）中的所有声明转储到标准输出。如果指定了该选项，则其他命令选项将被忽略。如果未指定旧头文件，则返回空JSON。'
# 'Dump all records as machine-readable JSON'
HC8D3646E5507: '以可机器读取的JSON格式转储所有记录'
# 'Dump all substituted intrs'
H17F291CCDE2E: '转储所有替换的内建函数'
# 'Dump array types'
H49086B41135B: '转储数组类型'
# 'Dump binary data from specified range of blocks.'
H84E1DDB15414: '从指定的块范围转储二进制数据'
# 'Dump binary data from specified range of bytes'
H8032C8C6B89F: '从指定的字节范围转储二进制数据'
# 'Dump binary data from specified streams.  Format is SN[:Start][@Size]'
H025773DC5489: '按指定流转储二进制数据。格式为SN[:Start][@Size]'
# 'Dump bytes of PDB Name Map'
HEA0DA34178F3: '转储PDB名称映射的字节'
# 'Dump code-completion information at a location'
HAD967F4C2789: '在指定位置转储代码补全信息'
# 'Dump compiland information'
HC4F8C0431CDD: '转储编译单元信息'
# 'Dump configuration options to stdout and exit.\nCan be used with -style option.'
HC24D568EFEC0: '将配置选项转储到标准输出后退出。\n可与-style选项联用。'
# 'Dump declarations that are deserialized from PCH, for testing'
HE581DC659FD7: '为测试转储从预编译头反序列化的声明'
# 'Dump dropped debug variables stats'
H85E673327785: '转储被丢弃的调试变量统计信息'
# 'Dump dropped debug variables stats for MIR passes'
HEA66796E7964: '为MIR pass的丢弃调试变量统计信息生成转储'
# "Dump each stream's block map (implies -stream-metadata)"
H5165BD588D74: '转储每个流的块映射（隐含-stream-metadata选项）'
# 'Dump edit and continue map'
HBCE09E7C4018: '转储编辑和继续映射'
# 'Dump enum types'
HB104D7EA4F5F: '转储枚举类型'
# 'Dump everything we know how to dump.'
H37AD9BC8A78E: '转储所有我们支持的转储内容'
# 'Dump exploded graph to the specified file'
H77D296A430F7: '将爆炸图转储到指定文件'
# 'Dump external symbols'
HA768DB613A32: '转储外部符号'
# 'Dump free page map'
HE90F56D21A38: '转储空闲页映射'
# 'Dump function names to stdout.'
H13D3781376F8: '将函数名转储到标准输出。'
# 'Dump function signature information'
H1625F7D7A62D: '转储函数签名信息'
# 'Dump global symbols'
H4E004D714E1B: '转储全局符号'
# 'Dump graphs for each function/round in the compilation unit.'
H2EA9EDCA4026: '转储编译单元中每个函数/轮次的图形。'
# 'Dump image section headers'
H01B54D632FED: '转储镜像节头'
# 'Dump input on failure'
H6F31E933D50C: '失败时转储输入'
# "Dump input to stderr, adding annotations representing\ncurrently enabled diagnostics.  When there are multiple\noccurrences of this option, the <value> that appears earliest\nin the list below has precedence.  The default is 'fail'.\n"
H768FAF2A8E36: "将输入附加注释输出到stderr，这些注释表示当前启用的诊断。\n当存在此选项的多个出现时，列表中最早出现的 <value> 具有优先权。\n默认值为 'fail'。\n"
# 'Dump list of actions to perform'
HD3BA4698DD33: '转储要执行的操作列表'
# 'Dump low level bitcode trace'
H1754A9E4C373: '转储低级比特码跟踪信息'
# 'Dump module after Polly transformations into a file suffixed with "-after"'
HDF35672E1E22: '转储Polly变换后的模块到以“-after”为后缀的文件中'
# 'Dump module after Polly transformations to the given file'
HFE02E969722D: '转储Polly变换后的模块到指定文件'
# 'Dump module before Polly transformations into a file suffixed with "-before"'
HF0A6CA5B945A: '转储Polly变换前的模块到以“-before”为后缀的文件中'
# 'Dump module before Polly transformations to the given file'
H3D5A0282D19D: '转储Polly变换前的模块到指定文件'
# 'Dump module info'
H35667204516C: '转储模块信息'
# 'Dump modules to stdout.'
HAFE4570AAD96: '将模块转储到标准输出。'
# 'Dump modules to the current working directory. (WARNING: will overwrite existing files).'
H5DEA08F3B824: '将模块转储到当前工作目录。（警告：会覆盖现有文件。）'
# 'Dump new file contents in YAML, if specified.'
H0F661C11A2F3: '如果指定了，则以YAML格式转储新文件内容。'
# 'Dump provenance'
H0B7FC19C4E7C: '转储来源信息'
# 'Dump ranges of deserialized declarations to use as bug minimization hints'
HABFDC2505B83: '将反序列化声明的范围转储以用作错误最小化提示'
# 'Dump record layout information'
H1A9181305386: '转储记录布局信息'
# 'Dump record layout information for all complete types'
HFF3CB6AA485A: '转储所有完整类型的记录布局信息'
# 'Dump record layout information in a simple form used for testing'
HEC89F4D9A445: '以测试用的简单形式转储记录布局信息'
# 'Dump record layout information with canonical field types'
H371339BFDE60: '使用规范字段类型转储记录布局信息'
# 'Dump register information to help debugging'
HA4313634E698: '转储寄存器信息以帮助调试'
# 'Dump resource usage at schedule boundary.'
H8B22EBFC198A: '在调度边界转储资源使用情况。'
# 'Dump results in JSON format to stdout.'
H76D763966BEB: '以JSON格式将结果输出到stdout。'
# 'Dump section contributions'
HDC1D19FADC7C: '转储节贡献信息'
# 'Dump section map'
HBED8393F6931: '转储节映射'
# 'Dump source file info'
H9D1B330F5346: '转储源文件信息'
# 'Dump sum of timings for all stacks. By default separates stacks per-thread.'
H39EFC1DB7865: '转储所有堆栈的时间总和。默认情况下按线程分开堆栈。'
# 'Dump symbol record substream'
H254B4E85A075: '转储符号记录子流'
# 'Dump symbols after the semantic analysis'
HDA7B67B72F4C: '语义分析后转储符号'
# 'Dump symbols and the parse tree after the semantic checks'
H8BBAF59A717D: '语义检查后转储符号及解析树'
# 'Dump symbols and their source code locations'
H8E456C399A58: '转储符号及其源代码位置'
# 'Dump templight information to stdout'
H1AD586FAA55A: '将templight信息输出到标准输出'
# 'Dump the DBI Stream Headers (Stream 2)'
H129FA94CBB86: '转储DBI流头（流 2）'
# 'Dump the FIR created by lowering and exit'
H91B777999917: '转储由下层转换生成的FIR并退出'
# 'Dump the HLFIR created by lowering and exit'
H2BFC1CB7ACAA: '转储由下层转换生成的HLFIR并退出'
# 'Dump the IPI Stream (Stream 5)'
H0EC59D4B528C: '转储IPI流（流 5）'
# 'Dump the PDB Stream (Stream 1)'
H4577B257A885: '转储PDB流（流 1）'
# 'Dump the PDB String Table'
H46D5A974F1C3: '转储PDB字符串表'
# 'Dump the Publics Stream'
H9A8FF0F8500C: '转储公共符号流'
# "Dump the SCCs in the ThinLTO index's callgraph"
H05F63DC7879B: '转储ThinLTO索引调用图中的强连通分量'
# 'Dump the TPI Stream (Stream 3)'
H838873B9AC8D: '转储TPI流（流 3）'
# 'Dump the compiler configuration options'
H3D1A24CE8D0E: '转储编译器配置选项'
# 'Dump the cooked character stream in -E mode'
H7DB9E0B6C82A: '-E模式下转储处理后的字符流'
# 'Dump the coverage mapping records, for testing'
H95CDC790B673: '转储覆盖映射记录（用于测试）'
# 'Dump the dependency graph to dot files.'
HF4BCFC89AF2D: '将依赖关系图转储为dot文件。'
# 'Dump the gcov file to stderr'
H58322A4E2763: '将gcov文件转储到标准错误输出'
# 'Dump the id record with the given type index'
H759F0D055070: '转储具有指定类型索引的标识记录'
# 'Dump the layouts of all vtables that will be emitted in a translation unit'
H5286BCB58A1F: '转储将在翻译单元中生成的所有vtables布局'
# 'Dump the list of input files and their weights, then exit'
HFD20CED5CA14: '转储输入文件及其权重的列表，然后退出'
# "Dump the number of streams and each stream's size"
HD36F7FCDEEBC: '转储流的数量及每个流的大小'
# 'Dump the parse tree'
H64405164E18C: '转储解析树'
# 'Dump the parse tree (skips the semantic checks)'
H65A5DE3C84CD: '跳过语义检查后转储解析树'
# 'Dump the pre-FIR tree'
H313B5A95699E: '转储预FIR树'
# 'Dump the pre-fir parse tree'
HA7DC87D10265: '转储预fir解析树'
# "Dump the source files that contribute to each module's."
H804482274E2A: '转储为每个模块贡献的源文件。'
# 'Dump the type record with the given type index'
H8A9E9857BE0A: '转储具有指定类型索引的类型记录'
# 'Dump the unsymbolized profile to the output file. It will show unwinder output for CS profile generation.'
H9822074C616B: '将未符号化的配置文件转储到输出文件。它将显示用于生成CS配置文件的展开程序输出。'
# 'Dump type server map'
HA60CB6E2EBD6: '转储类型服务器映射'
# 'Dump typedefs'
HB4499E4CA24E: '转储typedef定义'
# 'Dump udt types'
H4EEAE7678976: '转储用户定义类型'
# 'Dump virtual table shapes'
H94754C1D9BD7: '转储虚表形状'
# 'Duplicate the snippet'
HB2CC4A27F6FB: '复制代码片段'
# 'During rematerialization for a copy, if the def instruction has many other copy uses to be rematerialized, delay the multiple separate live interval update work and do them all at once after all those rematerialization are done. It will save a lot of repeated work. '
H2B948F8A8B8A: '在复制的重新生成过程中，如果定义指令有大量其他需要重新生成的复制使用，延迟多个独立的活跃区间更新工作，等到所有这些重新生成完成后一次性完成。这将节省大量重复工作。'
# 'Dwarf version'
H5862F01F0C5E: 'DWARF版本'
# 'Dynamic libraries to load before linking'
H926C9AA42A23: '链接前加载的动态库'
# 'Dynamic scheduling'
H762ACA0C3351: '动态调度'
# 'Dynamically link the sanitizer runtime'
HE0360B0DDF0D: '动态链接sanitizer运行时'
# 'EABI GNU'
H7E2A3B789B36: 'EABI GNU'
# 'EABI version 4'
H3C615C59EEA1: 'EABI 版本 4'
# 'EABI version 5'
HDD2C36FB7B3F: 'EABI 版本 5'
# 'Eagerly compute live intervals for all physreg units.'
H8BDCB87E4D2E: '积极计算所有物理寄存器单元的活跃区间。'
# 'Eagerly invalidate more analyses in default pipelines'
HC29BAEFB7500: '积极使默认流水线中的更多分析失效'
# 'Early CSE'
H7995F9E82B8F: '早期CSE'
# 'Early CSE w/ MemorySSA'
HA097BFA29921: '基于MemorySSA的早期CSE'
# 'Early If Converter'
HEACD98DB3CB0: '早期If转换'
# 'Early If Predicator'
H3899A5E56B26: '早期If预测'
# 'Early Machine Loop Invariant Code Motion'
H93B90001D05A: '早期机器循环不变代码移动'
# 'Early Tail Duplication'
H9F05343E7731: '早期尾部复制'
# 'Early expansion of MUX'
HC9BB5C4937A3: 'MUX的早期扩展'
# 'Element attributes.'
HA3DEA8BD288F: '元素属性。'
# 'Element debug location.'
HDDAB4BDAA546: '元素调试位置。'
# 'Element declaration and definition references.'
HF82FBA3D05B2: '元素声明和定义引用。'
# 'Element referenced across Compile Units.'
H6E34E57CF7C6: '元素跨编译单元引用。'
# 'Element referenced only in the Compile Unit.'
HB0C2FAF86940: '元素仅在编译单元内引用。'
# 'Element to print.'
H1150FC4D6BB7: '要打印的元素。'
# 'Elements to compare.'
H7D8A91E768C7: '要比较的元素。'
# 'Elide ElementsAttrs with "..." that have more elements than the given upper limit'
HE475543A5C00: '省略具有超过给定上限元素的 "..." 形式的ElementsAttrs'
# 'Elide printing value of resources if string is too long in chars.'
H89DF7B30813D: '如果字符串过长（以字符为单位），则省略资源值的打印。'
# 'Elide resources when generating bytecode'
HE18501EFA3FF: '生成字节码时省略资源'
# 'Eliminate PHI nodes for register allocation'
H951E7DE45FDF: '消除用于寄存器分配的PHI节点'
# 'Eliminate scalar loop carried dependences'
H57EB486234E9: '消除标量循环相关依赖'
# 'Embed DXIL'
H07B28C451A5A: '嵌入DXIL'
# 'Embed LLVM IR bitcode as data'
H595F481498B5: '将LLVM IR比特码作为数据嵌入'
# 'Embed LLVM bitcode'
H4AADB26DC12B: '嵌入LLVM比特码'
# 'Embed LLVM bitcode in object files produced by LTO'
H16F1861B6BE7: '将LLVM比特码嵌入LTO生成的目标文件'
# 'Embed Offloading device-side binary into host object file as a section.'
H5475B2E44660: '将卸载设备端二进制文件嵌入到主机对象文件的一个节区中'
# 'Embed PDB in shader container (ignored)'
HEF26692F47BE: '将PDB嵌入着色器容器（忽略）'
# 'Embed after all optimization passes'
HD4E0BFB5C58B: '在所有优化pass之后嵌入'
# 'Embed function arity information into the KCFI patchable function prefix'
H9B1AB0019717: '将函数元数信息嵌入到KCFI可修补函数前缀中'
# 'Embed placeholder LLVM IR data as a marker'
HCFCB6093DA4B: '将占位符LLVM IR数据嵌入为标记'
# 'Embed post merge, but before optimizations'
HEA0EFEB4A060: '在合并后但优化前嵌入'
# 'Embed source text in DWARF debug sections'
HC2C8736B7263: '将源代码文本嵌入到DWARF调试段中'
# 'Embed the contents of all files read by this compilation into the produced module file.'
HECD9878DE365: '将此编译过程中读取的所有文件的内容嵌入到生成的模块文件中。'
# 'Embed the contents of the specified file into the module file being compiled.'
H5C7A5481DBF2: '将指定文件的内容嵌入到正在编译的模块文件中。'
# 'Emit  debug info for defined but unused types'
H4259F2A07B2E: '为已定义但未使用的类型生成调试信息'
# 'Emit (experimental) loops (with sparse.iterate).'
H6558C2381246: '生成（实验性）循环（使用sparse.iterate）。'
# 'Emit .secure_log_unique directives to this filename.'
HA73462D861E9: '将.secure_log_unique指令输出到此文件名。'
# 'Emit .su file containing information on function stack sizes'
H17B887378AAE: '生成包含函数栈大小信息的.su文件'
# 'Emit AT&T-style assembly'
HED9E24C24759: '生成AT&T风格汇编'
# 'Emit Apple-style NEON assembly'
H45694CDA7EC7: '生成Apple风格NEON汇编'
# 'Emit Clang AST files for source inputs'
H2EA489E49444: '为源输入生成Clang AST文件'
# 'Emit CodeGen Data into custom sections'
H363A7576BA25: '将代码生成数据写入自定义段'
# 'Emit GNU Assembly Syntax on z/OS.'
H56A1FC66D6EC: '在z/OS上生成GNU汇编语法。'
# 'Emit GOTPCRELX/REX_GOTPCRELX/CODE_4_GOTPCRELX instead of GOTPCREL on x86-64 ELF'
HA621D70D3E80: '在x86-64 ELF上，使用GOTPCRELX/REX_GOTPCRELX/CODE_4_GOTPCRELX代替GOTPCREL'
# 'Emit IR to support LTO unit features (CFI, whole program vtable opt)'
H1C0C26CCDFE7: '生成支持LTO单元功能（CFI、整个程序vtable优化）的IR'
# 'Emit Import Call sections on supported targets that can be used by the Windows kernel to enable import call optimization'
HD73224065892: '在支持的目标平台上生成导入调用段，Windows内核可使用这些段启用导入调用优化'
# 'Emit Intel-style assembly'
HD0D98D71E373: '生成Intel风格汇编'
# 'Emit JSON-formatted debug info quality metrics.'
HE95341B061E7: '生成JSON格式的调试信息质量指标。'
# 'Emit LLVM textual assembly'
H5687C7B339C1: '生成LLVM文本汇编'
# 'Emit OpenMP code only for SIMD-based constructs.'
H566FF0EF84C2: '只为基于SIMD的结构生成OpenMP代码。'
# 'Emit PCs for atomic operations used by binary analysis sanitizers'
H1D074F0F258F: '为二进制分析检查器使用的原子操作生成PC信息'
# 'Emit PCs for atomic operations.'
H62316BF0E45F: '为原子操作生成PC'
# 'Emit PCs for code covered with binary analysis sanitizers'
H3D28246BA2B9: '为被二进制分析检查器覆盖的代码生成PC信息'
# 'Emit PCs for covered functions.'
H831FD59B3528: '为覆盖函数生成PC'
# 'Emit PCs for start of functions that are subject for use-after-return checking'
H797088C91ACC: '为需要进行使用后返回检查的函数的起始位置生成PC'
# 'Emit PCs for start of functions that are subject for use-after-return checking.'
HEC66708B7812: '为需要进行返回后使用检查的函数起始处生成PC信息。'
# 'Emit RTTI data (default)'
H28F26C2AAAEF: '生成RTTI数据（默认）'
# 'Emit R_RISCV_SET_ULEB128/E_RISCV_SUB_ULEB128 if appropriate'
H2DC3F5A68E91: '如果合适则生成R_RISCV_SET_ULEB128/E_RISCV_SUB_ULEB128'
# 'Emit SPIR-V NonSemantic.Shader.DebugInfo.100 instructions'
H3620039F4736: '生成SPIR-V NonSemantic.Shader.DebugInfo.100指令'
# 'Emit VPU instructions for VE'
H336AA1A757FD: '为VE生成VPU指令'
# 'Emit Windows Control Flow Guard tables and checks'
H2B3A6CDD77E1: '生成Windows控制流保护表和检查代码'
# 'Emit Windows Control Flow Guard tables only (no checks)'
H12EF1A548A1C: '仅生成Windows控制流保护表（不包含检查代码）'
# 'Emit Windows EH Continuation Guard tables'
H7CFD101BE344: '生成Windows EH延续保护表'
# 'Emit a call to trap function rather than a trap instruction'
H7926ECB4152F: '生成对陷井函数的调用而非陷井指令'
# 'Emit a compilation database fragment to the specified directory'
HBAB9D592240A: '将编译数据库片段输出到指定目录'
# 'Emit a diagnostic when "fast" instruction selection falls back to SelectionDAG.'
H88EB0DEF1034: '当 "fast" 指令选择回退到SelectionDAG时生成诊断信息'
# 'Emit a fatal error if format parsing fails'
H0EBAF7E7ADAA: '如果格式解析失败则生成致命错误'
# "Emit a native object ('.o') file"
HAE97C70DDD39: "生成本地目标文件（'.o'）"
# 'Emit a section containing jump table addresses and sizes'
H0281F291EFBA: '生成包含跳转表地址和大小的节'
# 'Emit a section containing remark diagnostics metadata. By default, this is enabled for the following formats: yaml-strtab, bitstream.'
H75D67E9CFF88: '生成包含备注诊断元数据的节。默认情况下，此功能对以下格式启用：yaml-strtab、bitstream。'
# 'Emit a section containing stack size metadata'
H698AD84DCB32: '生成包含栈大小元数据的节'
# 'Emit a warning if less than N% of records in the input profile are matched to the IR.'
HB962CC606D2C: '如果输入配置文件中匹配到IR的记录少于N%，则生成警告'
# 'Emit a warning if less than N% of samples in the input profile are matched to the IR.'
HED39F9DCFD05: '如果输入配置文件中匹配到IR的采样数据少于N%，则生成警告'
# 'Emit all declarations, even if unused'
HF5BC1521C99D: '输出所有声明，即使未使用'
# 'Emit an address-significance table'
H378504D13B46: '输出地址显著性表'
# "Emit an assembly ('.s') file"
H34226183B99D: "生成汇编文件（'.s'）"
# 'Emit an error if a C++ static local initializer would need a guard variable'
HA81110278BFB: '如果C++静态局部初始化器需要守卫变量，则输出错误'
# 'Emit analyzer results as errors rather than warnings'
H3B5E1411AD19: '以错误而非警告形式输出分析器结果'
# 'Emit basic blocks into separate sections'
H67EB14D9E7DC: '将基本块放入单独的节中'
# 'Emit bytecode when generating output'
H6A294EDCD1D8: '生成输出时生成字节码'
# 'Emit call site debug information, if debug information is enabled.'
H4DFAA1C6FE5A: '如果启用了调试信息，则生成调用站点调试信息'
# 'Emit code that can be JIT compiled for OpenMP offloading. Implies -foffload-lto=full'
HCB19BAB5F044: '生成可用于OpenMP卸载的JIT编译代码。隐含-foffload-lto=full'
# 'Emit code that prints the runtime check result dynamically.'
H83A96897A283: '生成可动态打印运行时检查结果的代码'
# 'Emit codegen data into the object file. LLD for MachO (currently) merges them into default.cgdata.'
HE5A9DF802056: '将代码生成数据写入目标文件。目前LLD的MachO版本会将它们合并到default.cgdata中。'
# 'Emit codegen data into the object file. LLD for MachO (currently) merges them into the specified <path>.'
HB514733CE70A: '将代码生成数据写入目标文件。目前LLD的MachO版本会将它们合并到指定的 <path> 中。'
# 'Emit colored output (default=autodetect)'
H1C348B34C157: '生成彩色输出（默认=自动检测）'
# 'Emit compiler path and command line into CodeView debug information'
H252107FF70F1: '将编译器路径和命令行信息写入CodeView调试信息'
# 'Emit complete descriptions of template parameters in forward declarations'
H73932760DABC: '在前向声明中输出模板参数的完整描述'
# 'Emit data into separate sections'
HF75AE625B842: '将数据生成到独立的节中'
# 'Emit debug info that places array-bounds instrumentation in an inline function called __ubsan_check_array_bounds.'
HCA08BC9E900F: '生成将数组边界插桩放置在名为__ubsan_check_array_bounds的内联函数中的调试信息。'
# 'Emit debug line info directives only'
HE3308044AB2D: '仅输出调试行信息指令'
# 'Emit debug line number tables only'
H8174B5298FE7: '仅输出调试行号表'
# 'Emit emitc.file ops with matching id'
H236B850BC868: '生成带有匹配ID的emitc.file操作'
# 'Emit emptylines and comment lines as skipped regions (only disable it on test)'
H7D7A380200FE: '将空行和注释行作为跳过的区域（仅在测试时禁用）'
# 'Emit error if a specific declaration is deserialized from PCH, for testing'
H2CD80B3DD8B2: '如果某个特定声明来自PCH的反序列化，则输出错误（用于测试）'
# 'Emit expensive warnings during LLVM IR import (discouraged: testing only!)'
H04DDF8C7828C: '在LLVM IR导入期间生成昂贵的警告（不建议：仅用于测试！）'
# 'Emit extra debug info to make sample profile more accurate'
H367D707A9507: '输出额外的调试信息以提高样本分析的准确性'
# 'Emit final result as bitcode instead of text IR'
H7F4BFD221CF3: '将最终结果作为比特码而非文本IR输出'
# 'Emit full debug info for all types used by the program'
H30220D4F255D: '为程序中使用的所有类型输出完整的调试信息'
# 'Emit functional code (with scf.for/while).'
HB278CDF9ABA9: '生成功能性代码（使用scf.for/while）。'
# 'Emit functional code or interfaces (to debug) for sparse loops'
HBDA72C0CBE39: '为稀疏循环生成调试用的功能代码或接口'
# 'Emit functions into separate sections'
H09C9B71236EA: '将函数生成到独立的节中'
# 'Emit generic NEON assembly'
H39274034DB2D: '生成通用NEON汇编'
# 'Emit hermetic module files (no nested USE association)'
HD5D99550F319: '输出隔离的模块文件（无嵌套USE关联）'
# 'Emit hexagon jump tables in function section'
HEE6DA2F43CCC: '在函数节中生成hexagon跳转表'
# 'Emit hexagon lookup tables in function section'
H100801A51219: '在函数节中生成hexagon查找表'
# 'Emit homogeneous prologue and epilogue for the size optimization (default = off)'
H835061FF9BD7: '生成用于尺寸优化的统一函数序言和尾迹（默认关闭）'
# 'Emit imports files for distributed backends.'
H99F865E8CA6D: '生成分布式后端的导入文件。'
# 'Emit information about accumulator register spills and copies'
H99CD32F2A0A4: '输出累加器寄存器溢出和复制的相关信息'
# 'Emit internal instruction representation to assembly file'
H61E38F521500: '将内部指令表示输出到汇编文件'
# 'Emit kernels to call ctor/dtor globals.'
HF3F0CC8F9DC0: '生成调用构造函数/析构函数全局变量的内核'
# 'Emit limited coverage mapping information (experimental)'
H42E2BE163D31: '生成有限的覆盖映射信息（实验性）'
# 'Emit log of dataflow analysis. With no arg, writes textual log to stderr. With an arg, writes HTML logs under the specified directory (one per analyzed function).'
HFAAFE42FF67A: '输出数据流分析日志。无参数时将文本日志写入标准错误。有参数时在指定目录下生成HTML日志（每个分析函数一个）'
# 'Emit macro debug information'
H5AADCC833ADB: '输出宏调试信息'
# 'Emit metadata containing compiler name and version'
H02D252B322FC: '输出包含编译器名称和版本的元数据'
# 'Emit module hash'
H8D92949B5594: '生成模块哈希'
# 'Emit module summary index'
H81A5D22F1814: '生成模块摘要索引'
# 'Emit native object files'
HD1D98EAD4C67: '输出本机目标文件'
# 'Emit non-functional but easy-to-read interfaces to debug.'
HFB7CBF2DAD9A: '生成非功能性但易于阅读的调试接口。'
# 'Emit nothing, for performance testing'
H59E0020EF2FE: '不生成任何内容，用于性能测试'
# 'Emit numeric info in dump even if symbolic info is available'
H44DA13315AA2: '即使存在符号信息也输出转储中的数值信息'
# 'Emit output in the selected format if supported'
HDFDB7BBE51F4: '如果支持则以选定格式输出'
# 'Emit pretty printed symbol graphs'
H9D5251957AE9: '以美观格式输出符号图'
# 'Emit pristine LLVM IR from the frontend by not running any LLVM passes at all.Same as -S + -emit-llvm + -disable-llvm-passes.'
H4945F63ADF72: '前端不运行任何LLVM passes，直接输出原始LLVM中间表示。等同于-S + -emit-llvm + -disable-llvm-passes。'
# 'Emit private/local variables as clauses/specifiers on MLIR ops.'
HBCB27910E0F7: '将私有/局部变量作为子句/说明符生成在MLIR操作上'
# 'Emit pseudo probes for sample profiling'
HEE6673E22F38: '生成采样分析的伪探针'
# 'Emit pseudo probes to enable PGO profile generation.'
H68FBB431D14A: '生成伪探针以启用PGO配置文件生成'
# 'Emit reproducer on (option: off, crash (default), error, always)'
HA45B571A7690: '在崩溃、错误或始终时生成复现文件（选项：关闭、崩溃（默认）、错误、始终）'
# 'Emit section containing metadata on function stack sizes'
H55BB0296572C: '生成包含函数堆栈大小元数据的节'
# 'Emit special compound instrumentation for reads-before-writes'
H7C94AB6DD4CB: '为写前读访问生成特殊复合插桩'
# 'Emit special debug info to enable PGO profile generation.'
H92226FB5F865: '生成特殊的调试信息以启用PGO配置文件生成'
# 'Emit special instrumentation for accesses to volatiles'
H807EB1BCE795: '为volatile变量的访问生成特殊插桩'
# 'Emit the GNU .debug_macro format with DWARF <5'
H05986F777FFF: '当DWARF版本小于 5 时生成GNU的.debug_macro格式'
# 'Emit the XCOFF traceback table'
H2AD67289821E: '生成XCOFF跟踪表'
# 'Emit the basic block address map section'
HE67CB0846DD5: '生成基本块地址映射节'
# 'Emit the basic block address map section.'
HD66B24BE91BF: '生成基本块地址映射节'
# 'Emit the specified combiners'
HD6132B919401: '生成指定的组合器'
# 'Emit type record hashes in a .debug$H section'
HE5D98DDE9AE9: '在.debug$H节中生成类型记录哈希'
# "Emit verbose output about the analyzer's progress"
HF03ADA31D285: '显示分析器的详细进度输出'
# 'Emit x8 as fp instead of s0'
H88FD472C55F8: '将x8作为fp而非s0输出'
# 'Emit xray_fn_idx section'
HCE1B25AEB13C: '生成xray_fn_idx节'
# 'Emits more virtual tables to improve devirtualization'
HEF76217E9284: '生成更多虚函数表以提升虚函数调用优化'
# 'Emulate weak link against library X. Must resolve to a TextAPI file, and all symbols in the interface will resolve to null.'
H1586C40C45A2: '模拟与库X的弱链接。必须解析为一个TextAPI文件，且接口中的所有符号都将解析为null'
# 'Emulate weak link against library X. X must point to a TextAPI file, and all symbols in the interface will resolve to null'
HDE0D8058522D: '模拟与库X的弱链接。X必须指向一个TextAPI文件，且接口中的所有符号都将解析为null'
# 'Enable -Wall'
HFE182F701ACC: '启用-Wall'
# 'Enable -Wall and -Wextra'
HCCDF3CF2B538: '启用-Wall和-Wextra'
# 'Enable -Weverything'
H85639A20AE92: '启用-Weverything'
# 'Enable -Wsystem-headers'
HCF6CBF83669C: '启用-Wsystem-headers'
# 'Enable -Wsystem-headers when building <module>'
H7BD118FCCA2F: '在构建 <module> 时启用-Wsystem-headers'
# 'Enable -time-passes memory tracking (this may be slow)'
HCD77711AC848: '启用-time-passes内存跟踪（这可能会很慢）'
# 'Enable .XOR. as a synonym of .NEQV.'
H26B24A90CE2E: '启用.XOR.作为.NEQV.的别名'
# 'Enable / disable ARM interworking (for debugging only)'
H0E7C6271B7D5: '启用/禁用ARM互操作（仅用于调试）'
# 'Enable / disable SVE scalable vectors in Global ISel'
H2EC78B18E661: '在全局指令选择中启用/禁用SVE可扩展向量'
# 'Enable / disable promotion of unnamed_addr constants into constant pools'
HFAE28EE53BD3: '启用/禁用将unnamed_addr常量提升到常量池'
# 'Enable 16-bit types and disable min precision types.Available in HLSL 2018 and shader model 6.2.'
HAAC77E9561C2: '启用 16 位类型并禁用最小精度类型。适用于HLSL 2018 和着色器模型 6.2。'
# 'Enable <feature> in module map requires declarations'
H5C8DA92AFFD8: '在模块映射需要声明时启用 <feature>'
# 'Enable AArch64 SME memory operations to lower to librt functions'
H2DE7C9221C4E: '启用AArch64 SME内存操作以降级到librt函数'
# 'Enable AArch64 logical imm instruction optimization'
H3E7D3BE3C68D: '启用AArch64逻辑立即数指令优化'
# 'Enable AMDGPU Alias Analysis'
H6232FED85C51: '启用AMDGPU别名分析'
# 'Enable AMDGPU function call support'
HA046043EEDCA: '启用AMDGPU函数调用支持'
# 'Enable AMDGPUAttributorPass'
H9BDDE4ABB4D1: '启用AMDGPUAttributorPass'
# 'Enable APX features (EGPR, NDD and NF) for instructions with relocations on x86-64 ELF'
H93395525FD86: '启用针对x86-64 ELF上带有重定位指令的APX特性（EGPR、NDD和NF）'
# 'Enable ARC-style weak references in Objective-C'
H9B793CE9E824: '启用Objective-C中的ARC风格弱引用'
# 'Enable ARM load/store optimization pass'
HF1C1057F91DB: '启用ARM的加载/存储优化passes'
# 'Enable AddressSanitizer'
H10A93E69F908: '启用AddressSanitizer'
# 'Enable AltiVec vector initializer syntax'
H39CF1AD1DDBB: '启用AltiVec向量初始化语法'
# 'Enable Apple gcc-compatible #pragma pack handling'
HF6255EFF4697: '启用与Apple gcc兼容的#pragma pack处理'
# 'Enable BFI update verification for CodeGenPrepare.'
HDEF1BBE64E03: '启用CodeGenPrepare的BFI更新验证'
# 'Enable C++ builtin type char8_t'
HB51A1047EAD1: '启用C++内建类型char8_t'
# 'Enable C++ builtin type wchar_t (default)'
H2E6A98E0A8E9: '启用C++内建类型wchar_t（默认启用）'
# 'Enable C++ exceptions'
HD8120A0570B1: '启用C++异常处理'
# 'Enable C++14 sized global deallocation functions'
HA9B36C7CDED1: '启用C++14带大小的全局释放函数'
# 'Enable C++17 aligned allocation functions'
H3A997E1CD1C0: '启用C++17对齐分配函数'
# 'Enable C-SKY asm compressed instruction'
HE6033CE9D615: '启用C-SKY汇编压缩指令'
# 'Enable CABAC instructions'
HCAFDAD7AAC69: '启用CABAC指令'
# 'Enable CREL relocation format (ELF only)'
H0C82A363E7CF: '启用CREL重定位格式（仅限ELF）'
# 'Enable CodeView debug information in object files'
H190F12E62C0D: '在目标文件中启用CodeView调试信息'
# 'Enable Control Flow Guard with /guard:cf, or only the table with /guard:cf,nochecks. Enable EH Continuation Guard with /guard:ehcont'
H0DCA490E39F9: '通过/guard:cf启用控制流保护，或仅使用/guard:cf,nochecks启用表部分。通过/guard:ehcont启用异常处理延续保护'
# 'Enable CopyToPhi DAG Mutation'
H795903E75A63: '启用CopyToPhi DAG变异'
# "Enable DAG combiner's use of IR alias analysis"
HEFB2E9C4316E: '启用DAG组合器对IR别名分析的使用'
# "Enable DAG combiner's use of TBAA"
HC13D2DED69A7: '启用DAG组合器对TBAA的使用'
# 'Enable DFA jump threading'
HDA1B9DF0576D: '启用DFA跳转线程化'
# 'Enable DPP combiner'
H1C2845754879: '启用DPP组合器'
# 'Enable Debug Info Metadata preservation testing in optimizations.'
H261A5A2FD07D: '在优化过程中启用调试信息元数据保留测试'
# 'Enable Debugger hook for debugging MLIR Actions'
H7236F64CF290: '启用用于调试MLIR操作的调试器钩子'
# 'Enable EH Asynchronous exceptions'
H2CA5CA1CFDC6: '启用EH异步异常'
# 'Enable EVL-based induction variable simplify Pass'
H0167530440BA: '启用基于EVL的归纳变量简化Pass'
# 'Enable FP math optimizations that assume approx func'
HA55AFA6BF75B: '启用假定近似函数的浮点数学优化'
# 'Enable FP math optimizations that assume no +-Infs'
H3B25285FD614: '启用假定没有±无穷大的浮点数学优化'
# 'Enable FP math optimizations that assume no NaNs'
H9640D97F95AD: '启用假定没有NaN的浮点数学优化'
# 'Enable FP math optimizations that assume the sign of 0 is insignificant'
HE827F0FDD8E0: '启用假定 0 的符号不重要的浮点数学优化'
# 'Enable Fast Math processing'
H2F61C44B4052: '启用快速数学处理'
# 'Enable Freestanding (disable builtins / TLI) during LTO'
H4C62FBB216B5: '在LTO期间启用Freestanding模式（禁用内建函数/目标库信息）'
# 'Enable GPU Mode managed|unified'
H1342A6457C14: '启用GPU模式 managed|unified'
# 'Enable Global-ISel Big Endian Lowering'
H51843BE1AC18: '启用Global-ISel的大端模式转换'
# 'Enable GlobalISel at or below an opt level (-1 to disable)'
HD97724CE8B7C: '启用GlobalISel（在等于或低于指定优化级别时），-1表示禁用'
# "Enable GlobalISel's post-legalizer load/store optimization pass"
H6BA2F1588338: '启用GlobalISel的后合法性检查加载/存储优化passes'
# "Enable GlobalISel's pre-legalizer load/store optimization pass"
H7E199DBC971A: '启用GlobalISel的前合法性检查加载/存储优化passes'
# 'Enable HIP Standard Parallelism Offload support'
H1C99F32D38F4: '启用HIP标准并行性卸载支持'
# 'Enable HIP acceleration for standard parallel algorithms'
H03CDA0DFF566: '为标准并行算法启用HIP加速'
# 'Enable HVX IEEE floating point extensions'
HEDB94BF0B878: '启用HVX IEEE浮点扩展'
# 'Enable HVX vector combining'
HDFF35C9FE78C: '启用HVX向量组合'
# 'Enable Hexagon HVX IEEE floating-point'
HB190E3ACA8B9: '启用Hexagon HVX IEEE浮点运算'
# 'Enable Hexagon HVX QFloat instructions'
HD10ED4BFBA4F: '启用Hexagon HVX QFloat指令'
# 'Enable Hexagon SDNode scheduling'
H421486189A34: '启用Hexagon SDNode调度'
# 'Enable Hexagon Vector eXtensions'
H849D45B20815: '启用Hexagon向量扩展（Vector eXtensions）'
# 'Enable Hexagon Vector print instr pass'
HF6F3126A4402: '启用Hexagon向量指令打印转换'
# 'Enable Hexagon constant-extender optimization'
HB232046E41EF: '启用Hexagon常量扩展优化'
# 'Enable Hexagon copy hoisting'
H52502969FA5F: '启用Hexagon复制提升'
# 'Enable Hexagon-specific memcpy for volatile destination.'
H37F33A534B6A: '启用针对易失性目标的Hexagon专用memcpy'
# 'Enable IBM XL #pragma pack handling'
H56C08FC94B0D: '启用IBM XL #pragma pack处理'
# 'Enable ICMP_EQ to ICMP_S(L|G)T conversion.'
H50B860EE6750: '启用ICMP_EQ到ICMP_S(L|G)T转换'
# 'Enable JumpTableToSwitch pass (default = off)'
H595911A42177: '启用JumpTableToSwitch转换（默认关闭）'
# 'Enable KernelAddressSanitizer instrumentation'
HDC17AF33380B: '启用内核AddressSanitizer插桩'
# 'Enable KernelHWAddressSanitizer instrumentation'
HE6892C669196: '启用内核HWAddressSanitizer插桩'
# 'Enable KernelMemorySanitizer instrumentation'
H98BCB50602AD: '启用内核MemorySanitizer插桩'
# 'Enable Key Instructions, which reduces the jumpiness of optimized code stepping (DWARF only). Requires LLVM built with LLVM_EXPERIMENTAL_KEY_INSTRUCTIONS.'
H235B8746F9EA: '启用关键指令（Key Instructions），减少优化代码单步执行时的跳变（仅DWARF）。要求LLVM在构建时启用LLVM_EXPERIMENTAL_KEY_INSTRUCTIONS'
# 'Enable LSR phi elimination'
H6F6B88180DCF: '启用LSR phi消除'
# "Enable LTO in 'full' mode"
HDE2B72E90D39: "以 'full' 模式启用LTO"
# "Enable LTO in 'full' mode for offload compilation"
H1AD130930D3D: "为外置编译启用 'full' 模式的LTO"
# 'Enable Loongson Advanced SIMD Extension (LASX).'
H8708BF686447: '启用Loongson高级SIMD扩展（LASX）'
# 'Enable Loongson SIMD Extension (LSX).'
H9319CC082DD4: '启用Loongson SIMD扩展（LSX）'
# 'Enable MASM-style hex float initializers (3F800000r)'
H44F2E6A19192: '启用MASM风格的十六进制浮点初始化器（3F800000r）'
# 'Enable MC/DC criteria when generating code coverage'
HDDD25377703C: '在生成代码覆盖率时启用MC/DC准则'
# 'Enable ML policy for inliner. Currently trained for -Oz only'
H4BD737EDDE37: '启用内联器的机器学习策略。目前仅针对-Oz进行训练'
# 'Enable MSA ASE (MIPS only)'
HF57FBC9A1C49: '启用MSA ASE（仅MIPS）'
# 'Enable MT ASE (MIPS only)'
H4037C7D0B0DC: '启用MT ASE（仅MIPS）'
# 'Enable Machine Pipeliner for AArch64'
HC2A6D688CFC7: '启用AArch64的机器流水线'
# 'Enable Machine Pipeliner for PPC'
H533D989E39D2: '启用PPC的机器流水线'
# 'Enable Machine Pipeliner for RISC-V'
H06DAB50244BB: '启用RISC-V的机器流水线'
# 'Enable MemProf context disambiguation'
H31287310FC75: '启用MemProf上下文消歧'
# 'Enable MemProf support for summarizing and cloning indirect calls'
H467E2FD95CC9: '启用MemProf对间接调用的汇总和克隆支持'
# 'Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size'
H305D879EAD05: '启用ODR指示符全局变量以避免部分清理程序中的错误ODR违规报告，但会增加二进制文件大小'
# 'Enable Objective-C Ivar layout bitmap print trace'
H8E7C0A4EC106: '启用Objective-C实例变量布局位图打印跟踪'
# 'Enable Objective-C exceptions'
HC28B4C97C29D: '启用Objective-C异常'
# 'Enable Objective-C garbage collection'
HC3AA6362E4C5: '启用Objective-C垃圾回收'
# 'Enable OpenACC'
HFA0D5CED023C: '启用OpenACC'
# 'Enable OpenMP support'
HBFD2A2659227: '启用OpenMP支持'
# 'Enable OpenMP support with experimental SIMD support'
H3F6D5F2001FE: '启用OpenMP支持并带有实验性SIMD支持'
# 'Enable PC tracing in sanitizer coverage'
H63A67D8CBA77: '在sanitizer覆盖中启用PC跟踪'
# 'Enable PC tracing with guard in sanitizer coverage'
HF28D97CE20BD: '在sanitizer覆盖中启用带有保护机制的PC跟踪'
# 'Enable PGO instrumentation'
H275AC31A4E6B: '启用PGO插桩'
# 'Enable Passing SSP Canary info in Trackback on AIX'
HF2D40BF85363: '启用在AIX上将SSP Canary信息传递到Trackback'
# 'Enable PatchPoint Liveness Analysis Pass'
HC23201EA3F30: '启用PatchPoint活跃性分析Pass'
# 'Enable PostRA load and store clustering in the machine scheduler'
H7DBDA92CD831: '启用机器调度器中的后寄存器分配的加载和存储聚类'
# 'Enable Pre-RA optimizations pass'
HBF2BE955A63C: '启用前寄存器分配优化Pass'
# 'Enable RDF-based optimizations'
HB93D1CE5916C: '启用基于RDF的优化'
# 'Enable SDWA peepholer'
HAA3AA4CDEBA5: '启用SDWA窥孔优化'
# 'Enable SVE intrinsic opts'
HC49B4494813B: '启用SVE内建函数优化'
# 'Enable SVR4-style position-independent code (Mips only)'
H39A5D03E5D80: '启用SVR4风格的位置无关代码（仅Mips）'
# 'Enable SWP at Os.'
HE7BF8843A5BE: '在Os优化级别启用SWP'
# 'Enable SYCL C++ extensions'
HB66B108F597C: '启用SYCL C++扩展'
# 'Enable Software Pipelining'
H701BBA1060C2: '启用软件流水线'
# 'Enable System z vector language extension'
H0ADCFE4F5EB1: '启用System z向量语言扩展'
# 'Enable ThinLTO caching.'
H4E40230CBB89: '启用ThinLTO缓存'
# 'Enable Unroll And Jam Pass'
HC78C6B520033: '启用展开并压缩Pass'
# 'Enable V8+ mode, allowing use of 64-bit V9 instructions in 32-bit code'
H51CF3B974577: '启用V8+模式，允许在 32 位代码中使用 64 位V9指令'
# 'Enable VGPR liverange optimizations for if-else structure'
H7A56B298E40B: '启用if-else结构的VGPR存活范围优化'
# 'Enable VOPD, dual issue of VALU in wave32'
H89877353D212: '启用VOPD，在wave32中实现VALU双发射'
# 'Enable VPlan-native vectorization path with support for outer loop vectorization.'
H5546DBF9A313: '启用支持外层循环向量化的VPlan原生向量化路径'
# 'Enable X86 indirect branch tracking pass.'
H9D4BDB5AD7B9: '启用X86间接分支跟踪Pass'
# 'Enable a 2nd level loop of loop tiling'
HCA8FDA365AE9: '启用循环分块的第二级循环'
# 'Enable a specific type of debug output (comma separated list of types)'
H3151AFA58B61: '启用特定类型的调试输出（用逗号分隔的类型列表）'
# 'Enable abort calls when "fast" instruction selection fails to lower an instruction: 0 disable the abort, 1 will abort but for args, calls and terminators, 2 will also abort for argument lowering, and 3 will never fallback to SelectionDAG.'
H1EC44B72B380: '当“快速”指令选择无法降低指令时启用终止调用：0禁用终止，1将终止但针对参数、调用和终止符，2也会在参数降低时终止，3将永不回退到SelectionDAG'
# 'Enable abort calls when "global" instruction selection fails to lower/select an instruction'
HC411401F6CE3: '在“global”指令选择失败时启用abort调用以降低/选择指令'
# 'Enable adding flow sensitive discriminators'
H127CCD0CABA6: '启用基于流敏感的discriminator添加'
# 'Enable adding inline-remark attribute to callsites processed by inliner but decided to be not inlined'
HFF28D2651FAF: '为内联器处理但未被内联的调用点启用添加inline-remark属性'
# 'Enable additional debug output'
HBEA92C1C802B: '启用附加调试输出'
# 'Enable address discrimination of function pointers in init/fini arrays'
H45A216E54E14: '启用初始化/终止数组中函数指针的地址区分'
# 'Enable address discrimination of vtable pointers'
H248ADBB468B0: '启用虚表指针的地址区分'
# 'Enable aggressive formation of fused FP ops'
HD91A957036F5: '启用融合浮点运算的激进形成'
# 'Enable aliasing mode in HWAddressSanitizer'
HFC48EEE3F6A8: '在HWAddressSanitizer中启用别名模式'
# 'Enable all Clang extensions for OpenMP directives and clauses'
H1D7ED18ACD09: '启用所有OpenMP指令和子句的Clang扩展'
# 'Enable all mitigations for Load Value Injection (LVI)'
H62EE869ADC27: '启用所有针对负载值注入（LVI）的缓解措施'
# 'Enable all options'
HEE8F72CD2211: '启用所有选项'
# 'Enable all traces.'
H57C177E41601: '启用所有跟踪。'
# "Enable alternative token representations '<:', ':>', '<%', '%>', '%:', '%:%:' (default)"
H4DF4837FAB61: "启用替代的标记表示 '<:', ':>', '<%', '%>', '%:', '%:%:'（默认）"
# 'Enable amcas[_db].{b/h/w/d}'
H63806DAD9D8C: '启用 amcas[_db].{b/h/w/d}'
# 'Enable amdgpu library simplifications'
HECCE410BA86E: '启用amdgpu库简化'
# 'Enable amswap[_db].{b/h} and amadd[_db].{b/h}'
H8299FC02710F: '启用 amswap[_db].{b/h} 和 amadd[_db].{b/h}'
# 'Enable analysis of vscale-relative immediates in LSR'
H82C5A0E019DD: '启用LSR中与vscale相关的立即数分析'
# 'Enable analyzing function argument and return types for mandatory definedness'
HF2001822C16A: '启用对函数参数和返回类型的强制定义性分析'
# 'Enable annotate table jump instruction to correlate it with the jump table.'
HFDE9D12C2ECD: '启用对跳转表指令进行注释以关联其与跳转表'
# 'Enable array bounds checking'
HD533CAFCE917: '启用数组边界检查'
# 'Enable assumed rank lowering'
H38B9CF78153E: '启用降级假定的秩'
# 'Enable atomic operations instrumentation in ThreadSanitizer (default)'
H28E05B9D8B0A: '启用ThreadSanitizer中的原子操作插桩（默认）'
# 'Enable authentication of pointers from GOT (ELF only)'
HEE1192FA1CBD: '启用对GOT（仅限ELF）中指针的验证'
# 'Enable auto-vectorization of floatint point types on v68.'
H407986FED01C: '在v68上启用浮点类型（floatint point types）的自动向量化'
# 'Enable basic block tracing in sanitizer coverage'
HB288E3CF4716: '启用sanitizer覆盖中的基本块跟踪'
# 'Enable binary and hex Motorola integers (%110 and $ABC)'
H929D942FA2B2: '启用二进制和十六进制Motorola整数（%110 和$ABC）'
# 'Enable binary and hex masm integers (0b110 and 0ABCh)'
H299555A297D6: '启用二进制和十六进制masm整数（0b110和 0ABCh）'
# 'Enable binary output on terminals'
HB1EFC8602261: '在终端启用二进制输出'
# 'Enable bottleneck analysis (disabled by default)'
H0EF8CE1914F9: '启用瓶颈分析（默认禁用）'
# 'Enable branch hint.'
HA68C6AA0EC92: '启用分支提示。'
# 'Enable branch prediction'
HA09824F26C29: '启用分支预测'
# 'Enable branch probability info'
HACC86396C5DC: '启用分支概率信息'
# 'Enable buffer security check (default)'
HC4E83D1F5690: '启用缓冲区安全检查（默认）'
# 'Enable builtin #include directories even when -nostdinc is used before or after -ibuiltininc. Using -nobuiltininc after the option disables it'
H03545481E610: '即使在使用-nobuiltininc之前或之后使用-nostdinc，也启用内建#include目录。在选项之后使用-nobuiltininc将禁用它'
# 'Enable caret and column diagnostics (default)'
HB9B531DB1BD2: '启用插入符号和列诊断（默认）'
# 'Enable casting unknown expression results to id'
H1BB41E97517E: '启用将未知表达式结果强制转换为id'
# "Enable cf-protection in 'full' mode"
HB3ADE4BC6E10: '在 "full" 模式下启用cf保护'
# 'Enable chain commoning in PPC loop prepare pass.'
HA72C1C0CBB48: '在PPC循环准备pass中启用链式公共子表达式优化。'
# 'Enable char8_t from C++2a'
HE9352E073F40: '启用C++2a中的char8_t'
# 'Enable checking for cache bank conflicts'
HD40C33D97687: '启用缓存银行冲突检查'
# "Enable checking of SDNode's single-use status"
H2C3A08FCCF0D: '启用对SDNode单次使用状态的检查'
# 'Enable checking of constexpr function bodies for validity within a constant expression context'
HD3707040DC7C: '启用检查constexpr函数体在常量表达式上下文中的有效性'
# 'Enable cmp instruction tracing in sanitizer coverage'
H903963183CE2: '启用sanitizer覆盖中的cmp指令跟踪'
# 'Enable code sinking'
HC9AEC37E0425: '启用代码下沈'
# 'Enable cold function only instrumentation.'
H103EC2AD6CD5: '启用仅冷函数插桩。'
# 'Enable collecting coverage from system headers'
H14D681672737: '启用从系统头文件收集代码覆盖率'
# 'Enable colors in diagnostics'
H2602C065FC54: '在诊断信息中启用颜色'
# 'Enable command line arguments round-trip.'
H0FC588FEB00A: '启用命令行参数的往返处理'
# 'Enable commoning of GEP instructions'
H21E18391E092: '启用GEP指令的公共化'
# 'Enable conflict detection in loop-access analysis'
H9866609C7AAA: '启用循环访问分析中的冲突检测'
# 'Enable consecutive memop optimization in AArch64PostLegalizerCombiner'
H8A9AB4FF7791: '启用AArch64PostLegalizerCombiner中的连续内存操作优化'
# 'Enable continuous instrumentation profiling mode'
HCFE5EA586D23: '启用连续插桩分析模式'
# 'Enable control flow (and PHI) hoisting in LICM'
H655AACCB94AB: '启用LICM中的控制流（和PHI节点）提升'
# 'Enable control flow integrity (CFI) checks for cross-DSO calls.'
H65983BF9B362: '启用跨DSO调用的控制流完整性（CFI）检查'
# 'Enable control flow structurization into `spirv.mlir.selection` and `spirv.mlir.loop`. This may need to be disabled to support deserialization of early exits (see #138688)'
H34FF13170268: '启用控制流结构化到`spirv.mlir.selection`和`spirv.mlir.loop`。可能需要禁用此功能以支持早退反序列化（见#138688）'
# 'Enable control height reduction optimization (CHR)'
H0F0478FE42AF: '启用控制高度降低优化（CHR）'
# 'Enable conversion of arithmetic operations to predicate instructions'
H0A4B03E5BC23: '启用将算术运算转换为谓词指令'
# 'Enable converting conditional transfers into MUX instructions'
HC372E511555B: '启用将条件转移转换为MUX指令'
# 'Enable converting phi types in CodeGenPrepare'
H646E9AD5179B: '启用CodeGenPrepare阶段中的PHI类型转换'
# 'Enable crash diagnostic reporting (default)'
H57A29C53DDA2: '启用崩溃诊断报告（默认）'
# 'Enable cross-cu references in DWO files'
H371A16C91C53: '启用DWO文件中的跨编译单元引用'
# 'Enable cyclic critical path analysis.'
HF81A62B6A5A8: '启用循环关键路径分析。'
# 'Enable debug info for the debug entry values.'
H62773C4101CF: '启用调试入口值的调试信息。'
# 'Enable debug messages while writing module files'
H8923A1076553: '在写入模块文件时启用调试信息'
# 'Enable debug output'
H8FF327476155: '启用调试输出'
# 'Enable debug output for only polly passes.'
HBDB1EA3DBD28: '仅启用Polly pass的调试输出。'
# 'Enable debugger suppport (default = !-noexec)'
H835D3E853677: '启用调试器支持（默认=!-noexec）'
# 'Enable debugging in the OpenMP offloading device RTL'
H333C6CC1A821: '启用OpenMP设备端RTL的调试'
# 'Enable debuginfod'
H6FC46DBD1099: '启用debuginfod'
# 'Enable deferred inlining'
H2F93ACD0E23A: '启用延迟内联'
# 'Enable dense outer loop sparse parallelization.'
H9C0E69F4C10C: '启用密集外层循环稀疏并行化。'
# 'Enable dense parallelization for any loop.'
H966B38C95DEA: '启用任意循环的密集并行化。'
# 'Enable detailed timing of insert generation'
H2B4DFBE7DA6E: '启用插入生成的详细计时'
# 'Enable detection of uninitialized parameters and return values'
H37967C89985E: '启用对未初始化参数和返回值的检测'
# 'Enable device-side debug info generation. Disables ptxas optimizations.'
HBE33969C4B31: '启用设备端调试信息生成。禁用ptxas优化。'
# 'Enable direct TLS access through segment registers (default)'
H6B41286A3288: '通过段寄存器直接访问TLS（默认）'
# 'Enable div instruction tracing in sanitizer coverage'
H70F6EE4DB4D3: '在sanitizer覆盖中启用div指令跟踪'
# 'Enable early if-conversion'
HCD88FA9972DA: '启用早期if转换'
# 'Enable early if-conversion on X86'
H54EA1744EB53: '在X86上启用早期if转换'
# 'Enable elimination of non-kernel functions and unused globals'
H565DB5148508: '启用消除非内核函数和未使用的全局变量'
# 'Enable emitting RISC-V ELF attributes for ABI features'
HEE2BA9740DE2: '启用为ABI特性生成RISC-V ELF属性'
# 'Enable emitting complete constructors and destructors as aliases when possible'
HD806A5232009: '尽可能将完整的构造函数和析构函数作为别名进行生成'
# 'Enable enhanced struct-path aware Type Based Alias Analysis'
HB0D34B7D8979: '启用增强的结构体路径感知的基于类型别名分析'
# 'Enable experimental bounds safety extension for C'
H19BF4377E02E: '启用C语言的实验性边界安全扩展'
# 'Enable experimental late parsing of attributes'
H9BF048F97F63: '启用属性的实验性延迟解析'
# 'Enable extended information within the SHT_LLVM_BB_ADDR_MAP that is extracted from PGO related analysis.'
H90477C1DC52F: '启用在SHT_LLVM_BB_ADDR_MAP中包含来自PGO相关分析的扩展信息。'
# 'Enable external API notes support'
H5E8A30586330: '启用对外部API注释的支持'
# 'Enable fat LTO object support'
H21F1B6309F52: '启用fat LTO对象支持'
# 'Enable features of APX'
HD328EFFFB9A0: '启用APX的功能'
# 'Enable fixed point types'
H0490DFC8424C: '启用定点数类型'
# 'Enable formatting of code changed by applying replacements.\nUse -style to choose formatting style.\n'
H8F0F987DA270: '启用应用替换后修改的代码的格式化。\n使用-style选项选择格式化风格。\n'
# 'Enable frame pointer elimination'
HAEAFB8EDDF71: '启用帧指针消除'
# 'Enable frame pointer elimination, but reserve the frame pointer register'
HE8BA912638EF: '启用帧指针消除，但保留帧指针寄存器'
# 'Enable frame pointer omission (x86 only)'
H4DBA3F274530: '启用省略帧指针（仅限x86）'
# 'Enable frecipe.{s/d} and frsqrte.{s/d}'
H3977CB98EF0D: '启用frecipe.{s/d}和frsqrte.{s/d}'
# 'Enable frequency counters in sanitizer coverage'
H5B9962B0B423: '在sanitizer覆盖中启用频率计数器'
# 'Enable full Microsoft Visual C++ compatibility'
H12B2EDEE6E67: '启用完整的Microsoft Visual C++兼容性'
# 'Enable function entry/exit instrumentation in ThreadSanitizer (default)'
H852113DDBCFA: '在ThreadSanitizer中启用函数入口/出口探针（默认）'
# 'Enable function merging as part of the optimization pipeline'
H3BF73DD457C7: '启用作为优化流程一部分的函数合并'
# 'Enable function outlining (AArch64 only)'
H15FFCDCECD61: '启用函数外线（仅AArch64）'
# 'Enable function specialization on the address of global values'
H46D83DE2E772: '启用对全局值地址的函数专业化'
# 'Enable garbage-collecting empty basic blocks'
H82096BB5EF83: '启用垃圾回收空基本块'
# 'Enable generating trap for unreachable'
HA93A4015EC75: '启用为不可达代码生成trap指令'
# 'Enable generation of calls to objc_claimAutoreleasedReturnValue'
HBF41104B9A28: '启用对objc_claimAutoreleasedReturnValue调用的生成'
# 'Enable generation of complex instructions'
HD949F4B874C3: '启用复杂指令的生成'
# 'Enable generation of instruction packets'
H9270F92493EE: '启用指令包生成'
# 'Enable generation of memop instructions'
HA7AE5A0F239A: '启用memop指令生成'
# 'Enable generation of new-value jumps'
H88666002BB2B: '启用新值跳转生成'
# 'Enable generation of new-value stores'
HE01CC1564066: '启用新值存储生成'
# 'Enable gep instruction tracing in sanitizer coverage'
H24F638FE5491: '在sanitizer覆盖中启用gep指令跟踪'
# 'Enable global load scalarization'
HEACC856F3BB8: '启用全局加载标量化'
# 'Enable global merge functions that are based on hash function'
H5280CEF67BB7: '启用基于哈希函数的全局函数合并'
# 'Enable global merge pass on constants'
H16452CA5347D: '启用对常量的全局合并Pass'
# 'Enable global merge pass on external linkage'
HB636A98A47D2: '启用对外部链接的全局合并Pass'
# 'Enable global value internalization in LTO'
HD751EE9A7CD2: '在LTO中启用全局值内部化'
# 'Enable gp-relative addressing of mips small data items'
H4B029B95E3C4: '启用Mips小数据项的GP相对寻址'
# 'Enable hashing of all compiler options that could impact the semantics of a module in an implicit build'
H3D8DF6DE718C: '在隐式构建中启用对可能影响模块语义的所有编译器选项进行哈希处理'
# 'Enable hashing the content of a module file'
H181E6C00680E: '启用对模块文件内容进行哈希处理'
# 'Enable heap memory profiling'
H80510263BC9C: '启用堆内存分析'
# 'Enable heap memory profiling and dump results into <directory>'
H29A449A8CDB1: '启用堆内存分析并将结果转储到 <directory>'
# 'Enable hexagon-qdsp6 backward compatibility'
HC33E9FDD1F01: '启用hexagon-qdsp6向下兼容'
# 'Enable hot-cold splitting pass'
H303E669D24AE: '启用热点-冷点分割Pass'
# 'Enable hot/cold operator new library calls'
HC2E3EA90629E: '启用热点/冷点operator new库调用'
# 'Enable identical code folding'
H28BAA680F117: '启用相同代码折叠'
# 'Enable if predication of stores during vectorization.'
HA5E79DD1344A: '启用向量化过程中存储的条件预测'
# 'Enable if-conversion during vectorization.'
H0446E14EDCAC: '启用向量化过程中的条件转换。'
# 'Enable image intrinsic optimizer pass'
H97E756CD1450: '启用图像本机优化pass'
# 'Enable implicit vector bit-casts'
HEB80538424B3: '启用隐式向量位模式转换'
# "Enable import metadata like 'thinlto_src_module' and 'thinlto_src_file'"
H2A8113D65BE4: "启用导入元数据如 'thinlto_src_module' 和 'thinlto_src_file'"
# 'Enable imprecision in EarlyCSE in pathological cases, in exchange for faster compile. Caps the MemorySSA clobbering calls.'
HAA73048B5B86: '在极端情况下启用EarlyCSE中的不精确性，以换取更快的编译速度。限制MemorySSA破坏调用。'
# 'Enable imprecision in LICM in pathological cases, in exchange for faster compile. Caps the MemorySSA clobbering calls.'
H636968D53932: '在极端情况下启用LICM中的不精确性，以换取更快的编译速度。限制MemorySSA破坏调用。'
# 'Enable incremental processing extensions such as processing statements on the global scope.'
H6BA53F1C325A: '启用增量处理扩展（如在全局作用域处理语句等）'
# 'Enable inline 8-bit counters in sanitizer coverage'
H519F01E8620F: '在sanitizer覆盖中启用内联 8 位计数器'
# 'Enable inline bool flag in sanitizer coverage'
HC8EAB045EC47: '在sanitizer覆盖中启用内联bool标志'
# 'Enable inline deferral during PGO'
H66E4DB2AD29F: '在性能引导优化期间启用内联延迟'
# 'Enable inliner stats for imported functions'
H0D332728E36F: '启用导入函数的内联统计信息'
# 'Enable instsimplify'
HB39E8D05245E: '启用指令简化'
# 'Enable inter-procedural analyses'
H528C6719D608: '启用过程间分析'
# 'Enable interleave MVE vector operation lowering'
H8E26ADE70A0E: '启用在MVE向量操作转换中交错'
# 'Enable interprocedural register allocation to reduce load/store at procedure calls.'
H6F0CA76DA224: '启用过程间寄存器分配以减少过程调用中的加载/存储操作。'
# 'Enable ir outliner pass'
H06C93577A2B7: '启用IR提取pass'
# 'Enable just-my-code debugging'
H59918B7E8599: '启用仅我的代码调试'
# 'Enable keeping all variables that have a persistent storage duration, including global, static and thread-local variables, to guarantee that they can be directly addressed'
H04E5C2AB8675: '启用保留所有具有持久存储持续时间的变量（包括全局、静态和线程局部变量），以保证它们可以直接寻址'
# 'Enable late function splitting using profile information (x86 and aarch64 ELF)'
H4664498771BF: '在x86和aarch64 ELF上使用配置文件信息进行延迟函数分割'
# 'Enable lazy compilation when using the MCJIT engine'
H1A4A6063E46C: '在使用MCJIT引擎时启用懒编译'
# 'Enable linker dead stripping of globals in AddressSanitizer'
H9E8C5D19A202: '在AddressSanitizer中启用链接器全局变量的死代码消除'
# 'Enable linker job to emit a static library.'
H1300A9593E8D: '启用链接器任务以生成静态库'
# 'Enable linker relaxation'
H4AD9A11300BE: '启用链接器松弛优化'
# 'Enable load and store clustering in the machine scheduler'
H9A7A3DC7E082: '在机器调度器中启用加载/存储聚类'
# 'Enable load store vectorizer'
H6C9482FFD1BF: '启用加载/存储向量化'
# 'Enable logical abbreviations'
H0D1D59444F4E: '启用逻辑缩写'
# 'Enable long calls for save-restore stubs.'
H12EA9151A98D: '启用保存/恢复桩代码的长调用。'
# 'Enable loop data prefetch on AMDGPU'
H4B4F5CE87A14: '在AMDGPU上启用循环数据预取'
# 'Enable loop data prefetch on Hexagon'
H90194BED7184: '在Hexagon上启用循环数据预取'
# 'Enable loop header duplication at any optimization level'
H88A7D3561B15: '在任意优化级别启用循环头复制'
# 'Enable loop interleaving in Loop vectorization passes'
H437D1745A932: '在循环向量化passes中启用循环交错'
# 'Enable loop iv regalloc heuristic'
H2FAF4EF1BAC2: '启用循环iv寄存器分配启发式算法'
# 'Enable loop tiling'
HF3F1904F445C: '启用循环分块'
# 'Enable loop vectorizer for HVX'
H0E3AC61CFA2F: '启用HVX的循环向量化'
# 'Enable lower module lds pass'
H5FAE08416AEA: '启用降低模块lds的pass'
# 'Enable lowering interleaved accesses to intrinsics'
H848C570E6895: '启用将交错访问转换为固有函数'
# 'Enable lowering math functions to their corresponding MASS (scalar) entries'
H87849497C3F3: '启用将数学函数转换为对应的MASS（标量）条目'
# 'Enable lowering of lds to global memory pass and asan instrument resulting IR.'
H778C2CAE9787: '启用将lds转换为全局内存的pass，并对生成的IR进行asan插桩'
# 'Enable lowering of the matrix intrinsics'
HFC73281BE936: '启用矩阵固有函数的转换'
# 'Enable machine DCE inside regalloc'
H59DAE158F032: '在寄存器分配中启用机器DCE'
# 'Enable machine block placement based on the ext-tsp model, optimizing I-cache utilization.'
HE6CB65616359: '基于ext-tsp模型启用机器块放置，优化指令缓存利用率'
# 'Enable masked loads/stores for HVX'
H9199C5705B41: '启用HVX的掩码加载/存储'
# 'Enable matrix data type and related builtin functions'
H43FB20CC8C7B: '启用矩阵数据类型及相关内建函数'
# 'Enable max stack depth tracing'
H509FC7F703A3: '启用最大栈深度跟踪'
# 'Enable mcount instrumentation'
H29618381AE6B: '启用mcount插桩'
# 'Enable mcount instrumentation with prof'
H0C1503D1A868: '启用与prof一起使用的mcount插桩'
# 'Enable memcpyopt even when libcalls are disabled'
HF4D685F00134: '即使禁用库调用，也启用memcpy优化'
# 'Enable memop clustering.'
H4CE08B6CBECC: '启用内存操作聚类'
# 'Enable memory access instrumentation in ThreadSanitizer (default)'
H40FD5983A03D: '在ThreadSanitizer中启用内存访问插桩（默认）'
# 'Enable merging Loop End and Dec instructions.'
H2EA5947F6FF8: '启用合并循环结束和递减指令'
# 'Enable merging of globals'
H626AD7B90529: '启用全局变量合并'
# 'Enable merging of redundant sexts when one is dominating the other.'
H1BD2BF0E8B4D: '当一个符号扩展指令支配另一个时，启用合并冗余的符号扩展指令'
# 'Enable mips16 constant islands.'
HC33E1B95CA7C: '启用mips16常量岛'
# 'Enable mips16 hard float.'
H077B35DE76F5: '启用mips16硬浮点'
# 'Enable missed optimization remarks from passes whose name match the given regular expression'
H5892F9670CED: '启用与给定正则表达式匹配的passes的错失优化提示'
# 'Enable mode register pass'
H1263C2240107: '启用模式寄存器pass'
# 'Enable module inliner'
H809D724384CF: '启用模块内联器'
# 'Enable module-based external API notes support'
HAD6C2BA49C14: '启用基于模块的外部API注释支持'
# 'Enable modules for C++'
HBB0113F4D937: '启用C++的模块支持'
# 'Enable name/filename string compression'
H9667A6AB14A5: '启用名称/文件名字符串压缩'
# 'Enable non legal immediates (for testing purposes only)'
H2DA699F30B71: '启用非法立即数（仅用于测试目的）'
# 'Enable odd single-precision floating point registers'
H6A9DE1E88E0D: '启用奇数单精度浮点寄存器'
# 'Enable on-demand initialization of thread-local variables'
H7700944705A7: '启用线程局部变量的按需初始化'
# 'Enable only control-flow mitigations for Load Value Injection (LVI)'
HF9542EDE9001: '仅启用针对加载值注入（LVI）的控制流缓解措施'
# 'Enable operand tree forwarding'
HB93EA483D9C3: '启用操作数树转发'
# 'Enable optimization analysis remarks from passes whose name match the given regular expression'
H2B83EB5BDF40: '启用与给定正则表达式匹配的passes名称的优化分析备注'
# 'Enable optimization of existing hot/cold operator new library calls'
H7F82E9E27CD9: '启用现有热/冷operator new库调用的优化'
# 'Enable optimization remarks from passes whose name match the given regular expression'
H2198D7418FE6: '启用与给定正则表达式匹配的passes名称的优化备注'
# 'Enable optimizations'
H5D736AD67AD6: '启用优化'
# 'Enable optimizations based on strict aliasing rules'
HCF0A62237B7C: '启用基于严格别名规则的优化'
# "Enable optimizations based on the strict definition of an enum's value range"
H186F36BCDB9E: '启用基于枚举值范围严格定义的优化'
# 'Enable optimizations based on the strict definition of flexible arrays.'
H63F456F0E338: '启用基于柔性数组严格定义的优化'
# 'Enable optimizations based on the strict rules for overwriting polymorphic C++ objects'
H13CA0465139C: '启用基于覆盖多态C++对象严格规则的优化'
# 'Enable optimizations on complex GEPs'
H50EEF415122A: '启用复杂GEP的优化'
# 'Enable optimizations that may decrease FP precision'
H67D78B43979D: '启用可能降低浮点精度的优化'
# 'Enable optimized register allocation compilation path.'
H0059F32A3970: '启用优化的寄存器分配编译路径。'
# 'Enable or disable Control Flow Guard checks and guard tables emission'
H20C0331A083C: '启用或禁用控制流保护检查和保护表生成'
# 'Enable origins tracking in MemorySanitizer'
H2743C4FAB786: '在MemorySanitizer中启用起源跟踪'
# 'Enable overlapping among matches in a group of consecutive\nCHECK-DAG directives.  This option is deprecated and is only\nprovided for convenience as old tests are migrated to the new\nnon-overlapping CHECK-DAG implementation.\n'
HA5495662EA0A: '启用连续CHECK-DAG指令组中匹配项的重叠。此选项已弃用，仅出于便利性提供，因为旧测试正在迁移到新的非重叠CHECK-DAG实现。\n'
# 'Enable parser support for the __unknown_anytype type; for testing purposes only'
H4226A11EC54A: '启用对__unknown_anytype类型的解析支持；仅用于测试目的'
# 'Enable partial store merging in DSE'
HEF8E935B1092: '在DSE中启用部分存储合并'
# 'Enable partial-overwrite tracking in DSE'
H4283D5D63662: '在DSE中启用部分覆盖跟踪'
# 'Enable pass to eliminate conditions based on linear constraints'
H59888AB6AA6D: '启用基于线性约束消除条件的pass'
# 'Enable perf profiling support'
H6FDDBD2502B8: '启用性能分析支持'
# 'Enable phi-translation of add instructions'
H2871DDB08B81: '启用add指令的phi转换'
# 'Enable placement of extracted cold functions into a separate section after hot-cold splitting.'
HC9DB0E175EB1: '在热冷分割后，启用将提取的冷函数放置到单独的段中。'
# 'Enable pointer authentication intrinsics'
H367806655729: '启用指针认证intrinsic函数'
# 'Enable poisoning array cookies when using custom operator new[] in AddressSanitizer'
HC79D664C6E42: '在AddressSanitizer中使用自定义operator new[]时启用数组cookie中毒'
# 'Enable pre-link mode optimizations'
H20BCBBC300E0: '启用预链接模式优化'
# 'Enable precise memory mode (AMDGPU only)'
HE9548687DBB5: '启用精确内存模式（仅AMDGPU）'
# 'Enable predefined and command line preprocessor macros'
H69A47E977056: '启用预定义和命令行预处理器宏'
# 'Enable predefined target OS macros'
H9D44D77675A5: '启用预定义目标操作系统宏'
# 'Enable profile hotness information in diagnostic line'
H6ECB1E31250D: '在诊断行中启用热度信息'
# 'Enable profile instrumentation sampling (default = off)'
H16EB6D513222: '启用配置文件插桩采样（默认关闭）'
# 'Enable promoting aligned anyext load to wider load'
H1CA89F41F132: '启用将对齐的anyext加载提升为更宽的加载'
# 'Enable promotion of flat kernel pointer arguments to global'
H4206A6231E2E: '启用将平坦内核指针参数提升为全局'
# 'Enable quadword atomics ABI on AIX (AIX PPC64 only). Uses lqarx/stqcx. instructions.'
H01E0F762B340: '启用AIX上的quadword原子操作ABI（仅限AIX PPC64）。使用lqarx/stqcx指令。'
# 'Enable raw string literals'
H8C8B44AEB3E9: '启用原始字符串字面量'
# 'Enable reassociation of accumulation chains'
H35D68C90E430: '启用累积链的重新关联'
# 'Enable reciprocal sqrt optimization'
H6556F5DE61D3: '启用倒数平方根优化'
# 'Enable recognition of non-constant strided pointer induction variables.'
H95B2F8C1B69F: '启用识别非常量步进指针归纳变量。'
# 'Enable recovery for specified sanitizers'
H2A20F3F3EA12: '为指定的sanitizer启用恢复功能'
# 'Enable recovery mode (continue-after-error).'
HBD337CDF104A: '启用恢复模式（错误后继续）。'
# 'Enable regalloc advisor mode'
H7AE29F2A8C3F: '启用寄存器分配顾问模式'
# 'Enable register pressure scheduling.'
HC0DF1D86F80E: '启用寄存器压力调度。'
# 'Enable register reassign optimizations on gfx10+'
H2EA748D732DD: '启用gfx10+架构的寄存器重新分配优化'
# 'Enable register tiling'
H02ACF2158ECD: '启用寄存器分块'
# 'Enable relocating counters at runtime.'
H1C98545F997D: '启用运行时重新定位计数器。'
# 'Enable removal of functions when theyuse features not supported by the target GPU'
HA60D39957FD6: '启用移除使用目标GPU不支持特性的函数'
# 'Enable required s_wait_alu on SGPR hazards'
H5931DB0CC40E: '启用SGPR冲突时的必需s_wait_alu指令'
# 'Enable rewrite partial reg uses pass'
HC2E09FB1800A: '启用部分寄存器使用重写优化'
# 'Enable runtime checks for stack overflow.'
H20B19FA46C02: '启用运行时堆栈溢出检查。'
# 'Enable runtime interleaving until load/store ports are saturated'
H83E188A2297B: '启用运行时交错直到加载/存储端口饱和'
# 'Enable s_delay_alu insertion'
H8A9476D62164: '启用s_delay_alu指令插入'
# 'Enable safe identical code folding'
H31D3779CB68C: '启用安全的相同代码折叠'
# 'Enable sample-based profile guided optimizations'
H96541402ED68: '启用基于采样的配置文件引导优化'
# 'Enable sanitizer coverage for indirect calls'
HB591DDDA07BD: '启用间接调用的sanitizer覆盖范围'
# 'Enable sanitizer for supported offloading devices'
HFDA0060284A3: '为支持的外设设备启用sanitizer'
# 'Enable sanitizer statistics gathering.'
HC1E74A5D06CE: '启用sanitizer统计信息收集'
# 'Enable sc.q instruction.'
H657B7BD0EB9D: '启用sc.q指令。'
# 'Enable scalar IR passes'
HD2045AE5F150: '启用标量IR passes'
# 'Enable scheduling addi instruction as earlyas possible post ra'
H3324B351B51A: '启用在寄存器分配后尽早调度addi指令'
# 'Enable scheduling after register allocation'
H142271112BA0: '启用寄存器分配后的指令调度'
# 'Enable scheduling for macro fusion.'
H3396D13A8F30: '启用宏融合的指令调度'
# 'Enable select to branch optimizations'
H7DB0FCE3CF68: '启用选择指令转分支优化'
# 'Enable setting constant bits to reduce size of mask immediates'
HD06E3ECAB947: '启用设置常量位以减小掩码立即数的大小'
# 'Enable setting lr as a predicate in tail predication regions.'
H5D3D99EE631D: '启用在尾部谓词区域中将lr设置为谓词'
# 'Enable setting the FP exceptions build attribute not to use exceptions'
H29262DC5BE27: '启用设置浮点异常构建属性以不使用异常'
# 'Enable shared library instrumentation with XRay'
HBB7CC7BAF352: '启用XRay的共享库插桩'
# 'Enable signing and authentication of all indirect calls'
H85AEAA3DF7E2: '启用所有间接调用的签名和认证'
# 'Enable signing and authentication of indirect goto targets'
H7778174B9D56: '启用间接 goto 目标的签名和身份验证'
# 'Enable signing and authentication of return addresses'
HB69C655EC5B4: '启用返回地址的签名和身份验证'
# 'Enable signing of function pointers in init/fini arrays'
HF447A017CA1C: '启用在初始化/终止数组中的函数指针签名'
# 'Enable simple copy propagation during register reloading'
HB0CCABAD4B9C: '启用寄存器重载期间的简单复制传播'
# 'Enable single byte coverage'
HCE6038C8EF64: '启用单字节覆盖'
# 'Enable sinking and folding of instruction copies'
HAFBBC2D2907E: '启用指令副本的下沉和折叠'
# 'Enable sinking and/cmp into branches.'
HC2C79127C7B6: '启用将下沉和cmp操作合并到分支中'
# 'Enable some non conforming code to compile'
H97500F6CC226: '允许某些不符合标准的代码进行编译'
# 'Enable some traditional CPP emulation'
H86897CE40B49: '启用某些传统的CPP模拟'
# 'Enable sparse parallelization for any storage and loop.'
H86D1CE3B297F: '启用任意存储和循环的稀疏并行化。'
# 'Enable sparse parallelization regardless of storage for the outer loop.'
HD78181DC6B92: '启用外层循环的稀疏并行化，不考虑存储。'
# 'Enable special debugger support behavior'
H526152B74AA2: '启用特殊调试器支持行为'
# 'Enable special debugger support for Objective-C subscripting and literals'
H40F60E7DDF05: '为Objective-C的下标和字面量启用特殊调试器支持'
# 'Enable specialization of functions that take a literal constant as an argument'
H8CB997684347: '启用对以字面常量作为参数的函数进行专用化'
# 'Enable specifying registers without the % prefix'
H4FA626EAB19A: '启用指定不带%前缀的寄存器'
# 'Enable speculative execution side effect suppression (SESES). Includes LVI control flow integrity mitigations'
H8F91025B1797: '启用推测执行副作用抑制（SESES）。包含LVI控制流完整性缓解措施'
# 'Enable spilling SGPRs to VGPRs'
HBC64889F75D9: '启用将SGPRs溢出到VGPRs'
# 'Enable spilling VGPRs to AGPRs'
HCAAEDB0207AA: '启用将VGPRs溢出到AGPRs'
# 'Enable spills from gpr to vsr rather than stack'
H93A49F7D7A81: '启用从GPR到VSR的溢出而非堆栈'
# 'Enable spills in prologue to vector registers.'
H14C00957A630: '启用在函数前导部分向向量寄存器溢出'
# 'Enable splitting large offset of GEP.'
HC17E8C448D7B: '启用分割GEP的大型偏移量'
# 'Enable splitting of a ThinLTO LTOUnit'
HD2FEBF5117B2: '启用分割ThinLTO LTO单元'
# 'Enable stack clash protection'
HD6B8B4D2B61B: '启用堆栈冲突保护'
# 'Enable stack frame shrink wrapping'
H96A0AAD52568: '启用堆栈帧压缩'
# 'Enable stack probes'
H2C8F59EB6B80: '启用堆栈探针'
# 'Enable stack protectors'
H92CD4261F56E: '启用堆栈保护程序'
# 'Enable stack protectors for all functions'
H4AAD4C1AF839: '为所有函数启用堆栈保护程序'
# 'Enable stack protectors for some functions vulnerable to stack smashing. Compared to -fstack-protector, this uses a stronger heuristic that includes functions containing arrays of any size (and any type), as well as any calls to alloca or the taking of an address from a local variable'
H01F993B30A66: '启用堆栈保护程序以防御某些易受堆栈溢出攻击的函数。与-fstack-protector相比，该选项使用更强的启发式方法，包括包含任意大小（以及任意类型）数组的函数，以及任何alloca调用或本地变量地址的获取'
# "Enable stack protectors for some functions vulnerable to stack smashing. This uses a loose heuristic which considers functions vulnerable if they contain a char (or 8bit integer) array or constant sized calls to alloca , which are of greater size than ssp-buffer-size (default: 8 bytes). All variable sized calls to alloca are considered vulnerable. A function with a stack protector has a guard value added to the stack frame that is checked on function exit. The guard value must be positioned in the stack frame such that a buffer overflow from a vulnerable variable will overwrite the guard value before overwriting the function's return address. The reference stack guard value is stored in a global variable."
H216044E73536: '启用堆栈保护程序以防御某些易受堆栈溢出攻击的函数。该选项使用宽松启发式方法，若函数包含大于ssp-buffer-size（默认：8字节）大小的char（或 8 位整数）数组或固定大小的alloca调用，则视为易受攻击。所有变长alloca调用均视为易受攻击。带有堆栈保护程序的函数会在堆栈帧中添加一个保护值，并在函数退出时进行验证。保护值的位置需确保缓冲区溢出会先覆盖该值而非函数返回地址。参考堆栈保护值存储于全局变量中。'
# 'Enable static hinting of branches on ppc'
H1318D7CF750E: '启用在PPC上对分支进行静态提示'
# 'Enable statistics output from program (available with Asserts)'
H7E1E434B51DE: '启用程序的统计信息输出（在启用断言时可用）'
# 'Enable stress test of coldcc by adding calling conv to all internal functions.'
H864C98F93D8C: '通过向所有内部函数添加调用约定来启用对coldcc的应力测试'
# 'Enable stricter verification with -verify-scev is passed'
HA0BAD2CA5C13: '当使用-verify-scev时启用更严格的验证'
# 'Enable string pooling (default)'
H01420F7F4ED8: '启用字符串池（默认）'
# 'Enable subreg liveness tracking'
H59D79C24D746: '启用子寄存器活跃度跟踪'
# 'Enable subregister liveness tracking for SystemZ (experimental)'
H278D5FB962A3: '启用SystemZ的子寄存器活跃度跟踪（实验性）'
# 'Enable subregister liveness tracking.'
HA8D796B2328B: '启用子寄存器活跃度跟踪。'
# 'Enable support for exception handling'
HFB1350CAA576: '启用异常处理支持'
# 'Enable support for ignoring exception handling constructs'
H1F7624DB7FC3: '启用忽略异常处理构造的支持'
# 'Enable support for int128_t type'
H8EC6E7CC318F: '启用int128_t类型支持'
# 'Enable support for the C++ Coroutines'
H7925EA35B0A4: '启用对C++协程的支持'
# 'Enable symbolic stride memory access versioning'
H614C3C8C780E: '启用符号步长内存访问版本化'
# 'Enable tail-predication, but not for reduction loops'
H7759A373B899: '启用尾预测，但不适用于规约循环'
# 'Enable tail-predication, but not for reduction loops, and force this which might be unsafe'
HEC8679DD9C06: '启用尾预测，但不适用于规约循环，并强制执行此操作，这可能不安全'
# 'Enable tail-predication, including reduction loops'
H9E0011DEC062: '启用尾预测，包括规约循环'
# 'Enable tail-predication, including reduction loops, and force this which might be unsafe'
H65CA4B853D34: '启用尾预测，包括规约循环，并强制执行此操作，这可能不安全'
# 'Enable that single precision floating-point divide and sqrt used in '
H40916D94286B: '启用在...中使用单精度浮点除法和平方根运算'
# 'Enable the "fast" instruction selector'
HB827608C6F32: '启用“快速”指令选择器'
# 'Enable the "global" instruction selector'
HC28B60B42675: '启用“全局”指令选择器'
# "Enable the 'blocks' language feature"
H8A0F69B5F85C: '启用 "blocks" 语言特性'
# "Enable the 'modules' language feature"
H047278B48AFB: "启用 'modules' 语言特性"
# 'Enable the AArch64 branch target pass'
H288D5F3BECED: '启用AArch64分支目标Pass'
# 'Enable the AIX Extended Altivec ABI.'
H2F5C4C6F1979: '启用AIX扩展Altivec ABI。'
# 'Enable the CCMP formation pass'
HD0F0CA1649A7: '启用CCMP形成Pass'
# 'Enable the GVN hoisting pass (default = off)'
HEAFC22E87450: '启用GVN提升Pass（默认关闭）'
# 'Enable the GVN sinking pass (default = off)'
H58E31BED29F9: '启用GVN下沉Pass（默认关闭）'
# 'Enable the IR outliner on linkonceodr functions'
H040BEC05F858: '启用Linkonceodr函数的IR外联'
# 'Enable the LoopFlatten Pass'
HAC22881851DD: '启用LoopFlatten Pass'
# 'Enable the LoopInterchange Pass'
HDD03023B6FBB: '启用LoopInterchange Pass'
# 'Enable the OpenMP region merging optimization.'
HE96DB2508A4B: '启用OpenMP区域合并优化。'
# 'Enable the Polly DOT printer in -O3'
H4E0A173B05AF: '在-O3选项中启用Polly DOT打印器'
# 'Enable the Polly DOT printer in -O3 (no BB content)'
HEAA8FA2DC249: '在-O3选项中启用Polly DOT打印器（无BB内容）'
# 'Enable the RISC-V VL Optimizer pass'
HC773BD141E4D: '启用RISC-V VL优化Pass'
# 'Enable the VR4300 mulmul bug fix.'
HF647968864FA: '启用VR4300 mulmul错误修复。'
# 'Enable the X86 cmov-to-branch optimization.'
HA57709995537: '启用X86 cmov到分支优化。'
# 'Enable the abort'
HF630F0E0D97E: '启用终止'
# 'Enable the attributor inter-procedural deduction pass'
HC3A4293C13B2: '启用attributor过程间推导Pass'
# 'Enable the condition optimizer pass'
H9D8DD66B429A: '启用条件优化Pass'
# 'Enable the conditional branch tuning pass'
H08843D4DB1BA: '启用条件分支优化Pass'
# 'Enable the copy propagation with AArch64 copy instr'
H7A7BF4C2FF44: '启用带有AArch64复制指令的传播Pass'
# 'Enable the copy propagation with RISC-V copy instr'
H8FDD7DCFE43D: '启用带有RISC-V复制指令的传播Pass'
# 'Enable the cost-benefit analysis for the inliner'
H4A32DF87AC31: '启用内联器的效益成本分析'
# 'Enable the early if converter pass'
HC1AB5BB544BB: '启用早期if转换Pass'
# 'Enable the experimental Loop Versioning LICM pass'
HAC7286F63BD3: '启用实验性循环版本化LICMPass'
# 'Enable the experimental new constant interpreter'
HA94181FC4D28: '启用实验性新常量解释器'
# 'Enable the extended Altivec ABI on AIX. Use volatile and nonvolatile vector registers'
H6369C2DE5BEE: '在AIX上启用扩展的Altivec ABI。使用volatile和非volatile向量寄存器'
# 'Enable the generation of 4-operand madd.s, madd.d and related instructions.'
H2954D704DCA6: '启用生成 4 操作数的madd.s、madd.d及相关指令'
# 'Enable the generation of WLS loops'
HB0BD6C355304: '启用WLS循环生成'
# 'Enable the generation of masked gathers and scatters'
H69417D79F86A: '启用掩码 gather 和 scatter 指令的生成'
# 'Enable the generation of masked loads and stores'
H8811F179AC8C: '启用掩码加载和存储生成'
# 'Enable the global merge pass'
HF3A16D1A310B: '启用全局合并Pass'
# 'Enable the initializes attr improvement in DSE'
H2C13638D3B7A: '在DSE中启用初始化属性优化'
# 'Enable the integrated assembler'
H6897999B76AE: '启用集成汇编器'
# 'Enable the legacy pass manager. This is strictly for bugpoint due to it not working with the new PM, please do not use otherwise.'
H4ACF17F9F060: '启用旧版Pass管理器。此选项仅用于bugpoint，因为其无法与新PM配合使用，请勿用于其他情况。'
# 'Enable the live debug variables pass'
H97C40BB61A18: '启用活调试变量Pass'
# 'Enable the load/store pair optimization pass'
HAF961AA83173: '启用加载/存储对优化Pass'
# 'Enable the loop data prefetch pass'
H1F5F62A8C420: '启用循环数据预取Pass'
# 'Enable the loop interchange pass'
HACD3CEF0E137: '启用循环交换pass'
# 'Enable the loop vectorization passes'
HD80457B01B02: '启用循环向量化passes'
# 'Enable the machine combiner pass'
H6170C8360FA8: '启用机器组合Pass'
# 'Enable the machine instruction scheduling pass.'
H5ED9F17A2AD8: '启用机器指令调度Pass。'
# 'Enable the machine outliner'
H6AA5708D3CBD: '启用机器外联优化'
# 'Enable the machine outliner on linkonceodr functions'
HC9ED1CD426C7: '在linkonceodr函数上启用机器外联优化'
# 'Enable the new pass manager'
H93E040EA4A3C: '启用新的pass管理器'
# 'Enable the new, experimental LoopDistribution Pass'
H349A804BD347: '启用新的实验性LoopDistribution Pass'
# 'Enable the old style PARAMETER statement'
H17563270F079: '启用旧式PARAMETER语句'
# 'Enable the pass that emits the linker optimization hints (LOH)'
HA4C27576F1AF: '启用生成链接器优化提示（LOH）的pass'
# 'Enable the pass that removes dead definitions and replaces stores to them with stores to the zero register'
HB91327722E91: '启用移除未使用的定义并将它们的存储替换为对零寄存器的存储的pass'
# 'Enable the pass that removes dead definitions and replaces stores to them with stores to x0'
H3F4AC3AD0D0C: '启用移除未使用的定义并将它们的存储替换为对x0寄存器的存储的pass'
# 'Enable the pass that removes dead definitons and replaces stores to them with stores to r0'
H8430D489B8AD: '启用移除未使用的定义并将它们的存储替换为对r0寄存器的存储的pass'
# 'Enable the polly optimizer (with -O1, -O2 or -O3)'
H2F44BA5CB43F: '启用Polly优化器（需配合-O1、-O2或-O3选项）'
# 'Enable the post-ra machine instruction scheduling pass.'
H81A625E2EDC2: '启用寄存器分配后的机器指令调度pass'
# 'Enable the profile guided size optimizations. '
HD0F54569CD57: '启用基于配置文件的大小优化。'
# 'Enable the promote constant pass'
H39117666C528: '启用提升常量的pass'
# 'Enable the redundant copy elimination pass'
HCC7E809780AA: '启用冗余拷贝消除pass'
# 'Enable the scheduler to generate .cur'
H9F36FFDB648E: '启用调度器生成.cur文件'
# 'Enable the specified remark'
HF163370BA2BE: '启用指定的备注'
# 'Enable the specified warning'
HB465ABA562BF: '启用指定的警告'
# 'Enable the superword-level parallelism vectorization passes'
H03A53AF6091A: '启用超字级并行向量化passes'
# 'Enable the tile register allocation pass'
H8BFDE65405FB: '启用分块寄存器分配pass'
# 'Enable the use of AA during codegen.'
H330FE8DFBA44: '启用代码生成期间使用别名分析（AA）'
# 'Enable the use of TLS Descriptors'
HC87014CCBA07: '启用TLS描述符的使用'
# 'Enable the use of the block frequency analysis to access PGO heuristics minimizing code growth in cold regions and being more aggressive in hot regions.'
H6383E4E8CC05: '启用块频率分析以利用程序配置文件引导（PGO）启发式方法，在冷代码区域减少代码膨胀，在热代码区域更激进优化。'
# 'Enable the use of the block frequency analysis to reduce the chance to execute const materialization more frequently than without hoisting.'
H05FE62E1BC2A: '启用块频率分析以降低常量材料化的执行频率超过未提升时的可能性。'
# 'Enable the vectorisation of loops with in-order (strict) FP reductions'
HC23A0D871AA8: '启用对顺序（严格）FP缩减的循环进行向量化'
# 'Enable the wasm-opt optimizer (default)'
H66A2CFFFDC43: '启用wasm-opt优化器（默认）'
# 'Enable the widening of global strings to alignment boundaries'
HEA83816331AB: '启用将全局字符串扩展到对齐边界。'
# 'Enable the workaround for OCL name mangling mismatch.'
H76DA67C39D2D: '启用OCL名称修饰不匹配的解决方法。'
# 'Enable thread-safe initialization of static variables'
H50C0425B9069: '启用静态变量的线程安全初始化'
# 'Enable threadgroup split execution mode (AMDGPU only)'
H94C846ABEAAC: '启用线程组拆分执行模式（仅AMDGPU）'
# 'Enable timing class latency'
H68F7539AA86E: '启用时序类延迟测量'
# 'Enable timing of insert generation'
HF299FBD7AEA4: '启用插入生成的计时'
# 'Enable tls optimization peephole'
H5607F3078246: '启用TLS优化小孔优化'
# 'Enable tracing of loads'
HFCB6983FD21E: '启用加载操作跟踪'
# 'Enable tracing of stores'
HE51956EA02F1: '启用存储操作跟踪'
# 'Enable trapping for all sanitizers'
H797FF784214D: '为所有sanitizers启用trap'
# 'Enable trapping for specified sanitizers'
H8D7750937E63: '为指定的sanitizers启用trap'
# 'Enable traps on authentication failures'
HB1958D1E9CCE: '在认证失败时启用trap'
# 'Enable treating throwing global C++ operator new as always returning valid memory (annotates with __attribute__((returns_nonnull)) and throw()). This is detectable in source.'
H98A09520B600: '将抛出异常的全局C++ operator new视为始终返回有效内存（使用__attribute__((returns_nonnull))和throw()进行注解）。这在源代码中是可检测的'
# 'Enable trigraphs'
HD29B31F12F2E: '启用三字符序列'
# 'Enable two-phase name lookup in templates'
H808ED9B492E8: '启用模板中的两阶段名称查找'
# 'Enable two-round ThinLTO code generation. The first round emits codegen data, while the second round uses the emitted codegen data for further optimizations.'
H4183BCD4B48B: '启用两轮ThinLTO代码生成。第一轮生成代码生成数据，第二轮使用这些数据进行进一步优化。'
# 'Enable type and address discrimination of vtable pointer of std::type_info'
H10834C3F61A6: '启用std::type_info虚表指针的类型和地址区分'
# 'Enable type discrimination of vtable pointers'
H5E406CE94798: '启用虚表指针的类型区分'
# 'Enable type discrimination on C function pointers'
HB262A3E07E79: '启用C函数指针的类型区分'
# 'Enable unsafe double to float shrinking for math lib calls'
HADD895A7C263: '启用数学库调用中的不安全双精度到单精度缩小'
# 'Enable unswitch cost multiplier that prohibits exponential explosion in nontrivial unswitch.'
H05E336233C05: '启用非平凡unswitch中禁止指数爆炸的unswitch成本乘数'
# 'Enable unwind v2 (epilog) information for x64 Windows'
H53CAE0AFFD48: '启用x64 Windows的展开（unwind）v2（epilog）信息'
# 'Enable use of AA during MI DAG construction'
H13EA04236348: '启用在MI DAG构建期间使用别名分析'
# 'Enable use of AdvSIMD scalar integer instructions'
H2C1BB8E0F766: '启用使用AdvSIMD标量整数指令'
# 'Enable use of GPR32 in inline assembly for APX'
HD4DD583F3412: '启用APX内联汇编中的GPR32寄存器使用'
# 'Enable use of TBAA during MI DAG construction'
H8EF1EE9B884D: '启用在MI DAG构建期间使用TBAA'
# 'Enable use of a base pointer for complex stack frames'
H6F6CB09044A3: '启用为复杂堆栈帧使用基指针'
# 'Enable use of builtin functions'
H6E647497900D: '启用内建函数的使用'
# 'Enable use of experimental RISC-V extensions.'
H16ED2241C9C1: '启用实验性的RISC-V扩展功能'
# 'Enable use of hot hints (only supported for unambigously hot allocations)'
H80EB4017A5F5: '启用使用热点提示（仅支持明确的热点分配）'
# 'Enable use of the DWARFv5 DW_OP_convert operator'
H68201FB3FEC3: '启用使用DWARFv5 DW_OP_convert操作符'
# 'Enable use of the MCJIT object caching'
H8DEBC9578EBC: '启用使用MCJIT对象缓存'
# 'Enable use-after-destroy detection in MemorySanitizer'
H9D193DAF1144: '启用MemorySanitizer的销毁后使用检测'
# 'Enable use-after-scope detection in AddressSanitizer'
H57E5EACCD6DF: '启用AddressSanitizer的作用域外使用检测'
# 'Enable using coldcc calling conv for cold internal functions'
H2D564DBF6E20: '启用为冷内部函数使用coldcc调用约定'
# 'Enable using library calls for save and restore'
H5D8D6E37F3DB: '启用使用库调用进行保存和恢复'
# 'Enable value profiling'
HC22D05737DD8: '启用值分析'
# 'Enable vec acc forwarding'
H5E7B35E50AEB: '启用向量累加转发'
# 'Enable vec alu forwarding'
HB58D78835B76: '启用向量ALU转发'
# 'Enable vectorization for wider vector utilization'
HA93E4FD1B769: '启用更广泛向量利用的向量化'
# 'Enable vectorization of early exit loops with uncountable exits.'
H5BAE1D5D430F: '启用具有不可计数退出的早期退出循环的向量化'
# 'Enable vectorization of epilogue loops.'
H633875436202: '启用尾部循环的向量化。'
# 'Enable vectorization on interleaved memory accesses in a loop'
HAC5648620E31: '在循环中启用交错内存访问的向量化。'
# 'Enable vectorization on masked interleaved memory accesses in a loop'
H043FDB797D48: '在循环中启用屏蔽的交错内存访问的向量化。'
# 'Enable verbose debugging for Loop Fusion'
H0D6210EADA30: '启用循环融合的详细调试。'
# 'Enable verbose output'
H11B3BB594E91: '启用详细输出。'
# 'Enable verbose output (results, IR, etc.) to stderr'
HCCA7B2AA9E71: '将详细输出（结果、IR等）发送到标准错误（stderr）。'
# 'Enable verification of LLVM IR'
H21971438C1F9: '启用LLVM IR的验证'
# 'Enable verification of MemorySSA.'
H0C498CC2C452: '启用内存SSA的验证。'
# 'Enable verification of assumption cache'
HA1CDE46C471E: '启用假设缓存的验证。'
# 'Enable vextract optimization'
HEA51F4DB759E: '启用vextract优化。'
# 'Enable virtual function elimination'
HB0B4C26F8F08: '启用虚函数消除。'
# 'Enable vtune profiling support'
H19C598762536: '启用VTune性能分析支持。'
# 'Enable warnings for deprecated constructs and define __DEPRECATED'
H141A6A5BBE2F: '为弃用的构造启用警告并定义__DEPRECATED'
# 'Enable warnings for undefined macros with a prefix in the comma separated list <arg>'
HCD611C0CC9C3: '为逗号分隔列表 <arg> 中带有前缀的未定义宏启用警告'
# 'Enable whole program visibility'
HED7D14DA2E46: '启用整个程序的可见性。'
# 'Enable whole program visibility during LTO'
H467630D788B8: '在链接时优化（LTO）期间启用整个程序可见性'
# 'Enable workarounds for GR712RC errata'
H12F1DF5F1AA6: '启用针对GR712RC缺陷的补救措施'
# 'Enable workarounds for UT700 errata'
HEED588686E0F: '启用针对UT700缺陷的补救措施'
# 'Enable/disable fusing matrix instructions.'
HCF6BF736057E: '启用/禁用矩阵指令的融合。'
# 'Enable/disable matrix shape verification.'
HBF4777571623: '启用/禁用矩阵形状的验证。'
# 'Enables DWARF32 format for ELF binaries, if debug information emission is enabled.'
HC14824860E5E: '如果启用了调试信息生成，则为ELF二进制文件启用DWARF32格式'
# 'Enables DWARF64 format for ELF binaries, if debug information emission is enabled.'
H636F6BB5F153: '如果启用了调试信息生成，则为ELF二进制文件启用DWARF64格式'
# 'Enables UNSIGNED type'
H12352306E73A: '启用UNSIGNED类型'
# 'Enables autovectorization of some loops containing histograms'
HC9BA8F6B64F6: '启用包含直方图的某些循环的自动向量化。'
# 'Enables dead virtual function elimination optimization. Requires -flto=full'
HF54593F712BA: '启用死虚函数消除优化。需要-flto=full'
# 'Enables more verbose remarks.'
H247202E5D41C: '启用更详细的注释。'
# "Enables scope for regex variables. Variables with names that\ndo not start with '$' will be reset at the beginning of\neach CHECK-LABEL block."
H1C0B00C976AB: '启用正则表达式变量的作用域。名称不以 "$" 开头的变量将在每个 CHECK-LABEL 块的开头被重置。'
# 'Enables spilling/reloading SVE predicates as data vectors (ZPRs)'
H7E00B4776D94: '启用将SVE谓词作为数据向量（ZPRs）进行溢出/重新加载。'
# 'Enables splitting of the LTO unit'
H14642BDE0542: '启用LTO单元拆分'
# 'Enables strict availability diagnostic mode for HLSL built-in functions.'
H68650E3ED1FE: '启用HLSL内建函数的严格可用性诊断模式。'
# 'Enables the global instruction selector'
H6762200C8D35: '启用全局指令选择器'
# 'Enables the use of non-default rounding modes and non-default exception handling on targets that are not currently ready.'
H405A02EF316C: '启用目标平台尚未准备就绪时的非默认舍入模式和非默认异常处理。'
# 'Enables tracing of vector stores'
H5763CA739FFE: '启用向量存储的跟踪。'
# 'Enables whole-program vtable optimization. Requires -flto'
H251D67CF92D1: '启用整个程序的虚表优化。需要使用-flto选项。'
# 'End sequence.'
H06B975DED7C7: '结束序列。'
# 'Enforce name visibility rules across submodules of the same top-level module.'
H3A526080F9BF: '强制执行同一顶层模块内子模块之间的名称可见性规则。'
# 'Enforce targets of indirect branches and function returns'
H01AC3BBC07B8: '强制执行间接跳转和函数返回的目标验证。'
# "Enqueue and re-visit child loops in the loop PM after unrolling. This shouldn't typically be needed as child loops (or their clones) were already visited."
H26C9D96CFA95: '在展开后将子循环添加到队列并重新访问。通常不需要此操作，因为子循环（或其克隆）已被访问过。'
# 'Ensure that all functions can be hotpatched at runtime'
H2573A45755AF: '确保所有函数在运行时可热补丁。'
# 'Ensure that llvm.experimental.noalias.scope.decl for identical scopes are not dominating'
H529A91904E5D: '确保相同作用域的llvm.experimental.noalias.scope.decl不会支配彼此'
# 'Ensure that the global variables are in the global address space'
HE46C47C5C88F: '确保全局变量位于全局地址空间'
# "Ensures debug_value's that have been stackified become stack relative"
H7ED7A97DC8DC: '确保经过栈化的debug_value变为栈相对'
# 'Entry point name'
H289D7303E351: '入口点名称'
# 'Entry point name for hlsl'
HE591D017B2D3: 'HLSL的入口点名称'
# 'Enumerate different FRM and VXRM'
H01FEC6A04D14: '枚举不同的FRM和VXRM'
# 'Enumeration.'
H14D4DDE07BE9: '枚举。'
# 'Enumerator.'
H1BB8B827F47C: '枚举项。'
# 'Epilogue begin.'
HAB658397C42F: '尾部开始。'
# "Equivalent to '-mrecip=all'"
H732521E2A55F: "等效于 '-mrecip=all'"
# 'Equivalent to -march=mips1'
H7FC3E35D9090: '等效于 -march=mips1'
# 'Equivalent to -march=mips2'
HE867B04F1EDA: '等效于 -march=mips2'
# 'Equivalent to -march=mips3'
H2E91BF8C7F63: '等效于 -march=mips3'
# 'Equivalent to -march=mips32'
HD42FF697CA84: '等效于 -march=mips32'
# 'Equivalent to -march=mips32r2'
H1346CAA8E004: '等效于 -march=mips32r2'
# 'Equivalent to -march=mips32r3'
H1F78C0BD4227: '等效于 -march=mips32r3'
# 'Equivalent to -march=mips32r5'
H46694C52E140: '等效于 -march=mips32r5'
# 'Equivalent to -march=mips32r6'
H7EF21D815E8D: '等效于 -march=mips32r6'
# 'Equivalent to -march=mips4'
H28139C7F49F1: '等效于 -march=mips4'
# 'Equivalent to -march=mips5'
H677B666B87C9: '等效于 -march=mips5'
# 'Equivalent to -march=mips64'
H4A78C54743DE: '等效于 -march=mips64'
# 'Equivalent to -march=mips64r2'
HAA2577781717: '等效于 -march=mips64r2'
# 'Equivalent to -march=mips64r3'
H5285D4DA9B3F: '等效于 -march=mips64r3'
# 'Equivalent to -march=mips64r5'
H271253ED3AFA: '等效于 -march=mips64r5'
# 'Equivalent to -march=mips64r6'
H9AB4B9314716: '等效于 -march=mips64r6'
# 'Equivalent to -verify=expected'
H8E09CC7EDD92: '等效于 -verify=expected'
# 'Erase GP Operand'
HB8F1F7E9AA26: '删除GP操作数'
# 'Erase the existing functions'
H8F328C294A4D: '删除现有的函数'
# 'Errata workaround pass'
H882D2A8DC3F5: '错误修正绕过处理'
# 'Error collecting HIP undefined fatbin symbols: %0'
H8A6EDE3371D0: '读取 HIP 未定义 fatbin 符号时出错: %0'
# 'Error for missing parenthesis around predicate registers'
H227937134E2E: '缺少谓词寄存器周围的括号的错误'
# "Error for register names that aren't contigious"
H8D6DA19266F4: '非连续寄存器名称的错误'
# 'Error in reading profile %0: %1'
H431D01FCD538: '读取配置文件 %0 时出错: %1'
# 'Error messages only'
H0A7E083717DD: '仅错误信息'
# 'Error on use'
HD221DA4D89E6: '使用时报错'
# 'Errors and warnings'
H2848EBF5EBC2: '错误和警告'
# 'Errors only'
H970D9ABE25E2: '仅错误'
# 'Errors, warnings and remarks'
HF85336965841: '错误、警告和备注'
# 'Evenly re-distribute flow among unknown subgraphs.'
H5604C90F2BE4: '在未知子图间均匀重新分配流程。'
# 'Exact dependences without transitive dependences'
HA1B7947727A7: '精确依赖项，不包括传递依赖项'
# 'Exception catch block.'
H6264B2F9B33C: '异常捕获块。'
# 'Exception try block.'
H5C51BB50B6C6: '异常尝试块。'
# 'Exclude compilands by regular expression'
HE55B6BA9D8DC: '通过正则表达式排除编译单元'
# 'Exclude functions matching the filter from the output.'
H1D0BAA0AC132: '从输出中排除与过滤器匹配的函数。'
# 'Exclude sanitization for the top hottest code responsible for the given fraction of PGO counters (0.0 [default] = skip none; 1.0 = skip all). Argument format: <sanitizer1>=<value1>,<sanitizer2>=<value2>,...'
H7D028CB3230B: '排除导致给定比例PGO计数器的最热代码的清理（0.0 [默认] = 不跳过任何；1.0 = 跳过全部）。参数格式：<sanitizer1>=<value1>,<sanitizer2>=<value2>,...'
# 'Exclude symbols by regular expression'
H599455B9067B: '通过正则表达式排除符号'
# 'Exclude types by regular expression'
H40334405F17A: '通过正则表达式排除类型'
# 'Exclude wrong side overloads only if there are same side overloads in overloading resolution for CUDA/HIP'
H5AA1CC8C618A: '在CUDA/HIP的重载解析中，仅当存在同侧重载时才排除错误侧重载'
# "Execute MCJIT'ed code in a separate process."
HC2E4E9BA2FB9: '在独立进程中执行MCJIT编译后的代码。'
# 'Execute graph viewer in the background. Creates tmp file litter.'
HA7075AF10C7F: '在后台执行图形查看器。会创建临时文件残留。'
# 'Execute with JIT'
HE5464053A6D4: '使用JIT执行'
# 'Execute with the interpreter'
HEC3165B8EAB3: '使用解释器执行'
# 'Executes the snippets within the same process'
H22C3FC000703: '在同一进程中执行代码片段'
# 'Execution model (WebAssembly only)'
H41BAD8F12174: '执行模型（仅限WebAssembly）'
# 'Exhaustive Search for registers bypassing the depth and interference cutoffs of last chance recoloring'
H3536DA79C20E: '绕过最后机会重新着色的深度和干扰阈值的寄存器全面搜索'
# 'Exit early if an unpredictable value come from the same loop'
H1F5EDB8C4566: '如果不可预测的值来自同一循环，则提前退出'
# 'Exit with an error when an instruction is unsupported for any reason (default)'
HDA0C7DD7EA63: '当指令不支持时以错误退出（默认）'
# 'Expand 64-bit division in AMDGPUCodeGenPrepare'
HEA34070476C9: '在AMDGPUCodeGenPrepare中展开 64 位除法'
# 'Expand Atomic instructions'
H30D3E9ACF190: '展开原子指令'
# 'Expand certain fp instructions'
H98876AA7B147: '展开特定浮点指令'
# 'Expand constant expressions to instructions for testing purposes'
H9BED0D03A404: '为测试目的将常量表达式展开为指令'
# 'Expand double precision loads and stores to their single precision counterparts'
H09525D3EC7B4: '将双精度加载和存储展开为对应的单精度指令'
# 'Expand eligible cr-logical binary ops to branches'
H785023B9F185: '将符合条件的cr-逻辑二进制操作展开为分支指令'
# 'Expand fp'
H2ACDE0C56583: '展开浮点指令'
# 'Expand hlfir.matmul as elemental operation'
HB8FB6378B2A3: '将hlfir.matmul展开为元素级操作'
# 'Expand indirectbr instructions'
H0645EC041241: '展开间接跳转指令'
# 'Expand large div/rem'
H6BA324BB9D05: '展开大除法/取余运算'
# 'Expand macros without full preprocessing'
H13AAEB743C7B: '在不进行完整预处理的情况下展开宏'
# 'Expand memcmp() to load/stores'
H44E3E46EDFEB: '将memcmp()展开为加载/存储指令'
# 'Expand memcpy into load/store pairs in order'
H9B1207BABDAD: '按顺序将memcpy展开为load/store对'
# "Expand operand's MIOperandInfo DAG into suboperands"
H0AED692FCB12: '展开操作数的MIOperandInfo DAG为子操作数'
# 'Expand out of range branch instructions and fix forbidden slot hazards'
HB54E4CE04809: '展开超出范围的分支指令并修复禁止的槽位冲突'
# 'Expand out of range branches'
H08752DCA250D: '展开越界的分支'
# 'Expand reduction intrinsics'
H9287AE31FDD0: '展开归约型内联函数'
# 'Expand variadic functions'
HC0CCC1B4F1F9: '展开可变参数函数'
# 'Expect external char-aligned symbols to be without ABI alignment (SystemZ only)'
HEE285623EE10: '期望外部字符对齐符号无ABI对齐（仅限SystemZ）'
# 'Experimental pc tracing'
H45FAF05767D2: '实验性程序计数器跟踪'
# 'Explain input dump and quit'
HB398CAAA9E7D: '解释输入转储并退出'
# 'Explain why a node was skipped (default=true)'
H51DC101E0A71: '解释为何跳过某个节点（默认=true）'
# 'Explain why a pattern was skipped for inclusion in the GlobalISel selector'
HAC0A3B68049F: '解释为何某个模式被排除在全局指令选择器之外'
# 'Exploit reductions in dependence analysis'
H76A87C10B6BB: '利用依赖分析中的简化'
# 'Export debug info (by testing original Debug Info) failures into specified (JSON) file (should be abs path as we use append mode to insert new JSON objects).'
H632F15D60721: '将原始调试信息失败导出到指定的JSON文件（应为绝对路径，因为我们使用追加模式插入新JSON对象）。'
# 'Export debug info preservation failures into specified (JSON) file (should be abs path as we use append mode to insert new JSON objects)'
HD135A5123609: '将调试信息保存失败导出到指定的JSON文件（应为绝对路径，因为我们以追加模式插入新的JSON对象）'
# 'Export full callsite graph'
H8538ECACAB5E: '导出完整的调用点图'
# 'Export graph to dot files.'
H314220D2E444: '导出图形到dot文件'
# 'Export only nodes with contexts feeding given -memprof-dot-alloc-id'
H11F3042B06F8: '仅导出上下文与给定的 -memprof-dot-alloc-id 关联的节点'
# 'Export only nodes with given -memprof-dot-context-id'
H910BF34B1ED8: '仅导出具有给定 -memprof-dot-context-id 的节点'
# 'Export only summary information for each source file'
HD9DCC346A6DB: '仅导出每个源文件的摘要信息'
# 'Export per-pass debugify statistics to this file'
H798BCDB12E0E: '将每个pass的调试统计信息导出到此文件'
# 'Export the polyhedral description of the detected Scops'
H517A4767D0DE: '导出检测到的Scops的多面体描述'
# 'Export typeid resolutions to summary and globals'
H705A17261B58: '将 typeid 解析导出到摘要和全局'
# 'Exporting options'
HA28E86F82A20: '导出选项'
# 'Extend the -G behaviour to object local data (MIPS)'
H807C41A2617A: '扩展 -G 行为到对象本地数据（MIPS）'
# 'Extend the liveness of user variables through optimizations to prevent stale or optimized-out variable values when debugging.'
HE9566864B09C: '延长用户变量在优化过程中的存活期，防止调试时出现陈旧或被优化掉的变量值。'
# 'Extensible binary encoding'
H16E285BD9929: '可扩展的二进制编码'
# 'Extensible binary encoding (default)'
HBCE99B0D176C: '可扩展的二进制编码（默认）'
# 'External Alias Analysis'
H99D45183AADE: '外部别名分析'
# 'Externalize enqueued block runtime handles'
HD158E9A6F40A: '外部化已排队块的运行时句柄'
# 'Extra archive files to be loaded'
HD60827C100DD: '额外要加载的归档文件'
# 'Extra directory of include files'
H401E9781A70C: '额外的包含文件目录'
# 'Extra modules to be loaded'
H4905A00383B5: '额外要加载的模块'
# 'Extra object files to be loaded'
HFBB158EB888B: '额外要加载的对象文件'
# 'Extract API information'
HAD16D93996E0: '提取API信息'
# 'Extract HwModes-specific instructions into new DecoderTables, significantly reducing Table Duplications'
HF76D682A9D15: '将 HwModes 特定指令提取到新的 DecoderTables 中，显著减少表格重复'
# 'Extract at most one loop into a new function'
H2D39B07FBC4D: '提取最多一个循环到新函数'
# 'Extract from <file>.'
H4A68D5BEAE14: '从 <file> 中提取'
# 'Extract loops into new functions'
H053EB2868DBF: '将循环提取到新函数中'
# 'FAILURE'
HF9C22E097EEB: '失败'
# 'FILECHECK_OPTS'
H2A422AA39933: 'FILECHECK_OPTS'
# 'FIX-IT applied suggested code changes'
H19B769DF31D9: 'FIX-IT 已应用建议的代码更改'
# 'FIX-IT detected an error it cannot fix'
HD809189A8863: 'FIX-IT 检测到无法修复的错误'
# 'FIX-IT detected errors it could not fix; no output will be generated'
HEE3E7F0F9BA0: 'FIX-IT 检测到无法修复的错误；将不会生成输出'
# 'FIX-IT unable to apply suggested code changes'
H2B4E9FB21753: 'FIX-IT 无法应用建议的代码更改'
# 'FIX-IT unable to apply suggested code changes in a macro'
H3E3C2FB702A6: 'FIX-IT 无法在宏中应用建议的代码更改'
# 'Factor for the unroll threshold to account for code simplifications still taking place'
HBD6D5665E545: '用于考虑代码简化仍在进行时的展开阈值因子'
# 'Factor to apply to what qualifies as a long branch to reserve a pair of scalar registers. If this value is 0 the long branch registers are never reserved. As this value grows the greater chance the branch distance will fall within the threshold and the registers will be marked to be reserved. We lean towards always reserving a register for  long jumps'
H106A273943F9: '若值为 0 则长分支寄存器永不保留。随着该值增大，分支距离越可能在阈值内，寄存器会被标记为保留。我们倾向于总是为长跳转保留寄存器'
# "Fail if an object couldn't be found for a binary ID in the profile"
H4235E7E596D5: '如果在概要文件中找不到对象，则失败'
# 'Fail if any profile is invalid.'
HFB8AB051E56E: '若任何配置文件无效则失败'
# 'Fail only if all profiles are invalid.'
HF5E080277997: '仅当所有配置文件无效时才失败'
# 'Failure mode:'
H1A58BCEE2CF5: '失败模式:'
# 'Falkor HW Prefetch Fix'
H323CD584CC0F: 'Falkor 硬件预取修正'
# 'Falkor HW Prefetch Fix Late Phase'
H682A690E57FE: 'Falkor 硬件预取后期修复阶段'
# 'Fallback style for reformatting after inserting new\nheaders if there is no clang-format config file found.'
H581E7F83176F: '如果没有找到clang-format配置文件，则在插入新头文件后重新格式化时使用的样式。'
# 'Fallback to indirect when incorrect'
HD59C4BCB012E: '当不正确时回退到间接方式'
# 'Fast Register Allocator'
H749535234AA8: '快速寄存器分配器'
# 'Fast Tile Register Configure'
HE2B5F0EAEB3A: '快速Tile寄存器配置'
# 'Fast Tile Register Preconfigure'
H049C9C8DDC88: '快速Tile寄存器预配置'
# 'Fast register allocator'
H0FB6B67552E0: '快速寄存器分配器'
# 'Fast suboptimal list scheduling'
HE44BDB59069E: '快速次优列表调度'
# 'Features to use to serialize to cubin.'
H480406601DAF: '用于序列化到cubin的特性。'
# 'File checksums (DEBUG_S_CHECKSUMS subsection)'
H0341151319EC: '文件校验和（DEBUG_S_CHECKSUMS子部分）'
# 'File containing RuntimeDyld verifier checks.'
H91AFD2697B81: '包含RuntimeDyld验证检查的文件。'
# 'File containing diagnostic suppression mappings. See user manual for file format.'
H65FE3D35314C: '包含诊断抑制映射的文件。请参阅用户手册以了解文件格式。'
# 'File containing entry point of the transform script, if different from the input file'
H6B64668AC58F: '如果与输入文件不同，包含变换脚本入口点的文件'
# 'File containing verifier checks'
H4CA0F6F72C6E: '包含验证检查的文件'
# "File doesn't need an exec stack"
H9CC2858800DD: '文件不需要exec stack'
# 'File for serializing diagnostics in a binary format'
H94768CE895D7: '用于以二进制格式序列化诊断的文件'
# 'File holding the seed used by the randomize structure layout feature'
HE8D1A6EACA51: '包含随机化结构布局功能所用种子的文件'
# 'File is for a position independent executable'
HC6398B79E913: '文件是用于位置无关可执行文件'
# 'File listing native ABI functions and how the pass treats them'
H779A21941187: '列出本机ABI函数及其处理方式的文件'
# 'File name to use for YAML optimization record output'
HDFBB63F1AC25: 'YAML优化记录输出所用的文件名'
# 'File name to use for split dwarf debug info output'
H6FBC3D7AD088: '生成拆分DWARF调试信息所用的文件名'
# 'File path for cold function only instrumentation(requires use with --pgo-instrument-cold-function-only)'
H833BBD566D2F: '仅对冷函数进行插桩的文件路径（需要与--pgo-instrument-cold-function-only一起使用）'
# 'File path to where .cgdata file is read'
HD25E7479AD77: '.cgdata文件的读取路径'
# 'File to append -stats and -timer output to'
H8C0548CC1115: '-stats和-timer输出追加的文件'
# 'File to check (defaults to stdin)'
H44D35D906559: '要检查的文件（默认为stdin）'
# 'File to emit dot graph of new summary into'
HB22275C53F6F: '将新摘要的dot图输出的文件'
# 'File to read (analysis mode) or write (latency/uops/inverse_throughput modes) benchmark results. “-” uses stdin/stdout.'
H44970F94DF2D: '读取（分析模式）或写入（延迟/uops/逆吞吐量模式）基准测试结果的文件。 "-" 使用stdin/stdout。'
# 'File to record the coroutines got elided'
H175805F86595: '记录被省略的协程的文件'
# 'File with the profile data obtained after an instrumented run'
HD4AF1660449E: '包含插桩后运行所得剖面数据的文件'
# 'File(s) containing definitions of additional transform script symbols'
HF1DBCA863288: '包含额外变换脚本符号定义的文件'
# 'Filename (or -) to log diagnostics to'
HDACB45AABD12: '记录诊断信息的文件名（或“-”）'
# 'Filename (or -) to write dependency output to'
H8BC9F30BC52B: '写入依赖关系输出的文件名（或“-”）'
# 'Filename (or -) to write header include output to'
H5BF600319EF5: '写入头文件包含输出的文件名（或“-”）'
# 'Filename (or -) to write stack usage output to'
H3BC188E55BBD: '写入栈使用情况输出的文件名（或“-”）'
# 'Filename defining the list of functions/files to instrument. The file uses the sanitizer special case list format.'
HC15DFAEF876C: '指定要分析的函数/文件列表的文件名。该文件使用sanitizer特殊案例列表格式。'
# 'Filename defining the list of functions/types for imbuing XRay attributes.'
H59E8B9411DF9: '指定要赋予XRay属性的函数/类型的列表的文件名。'
# 'Filename to pipe in as stdin (default: /dev/null)'
HBE65800DDA37: '作为stdin输入的文件名（默认：/dev/null）'
# 'Filename to write DOT-formatted header dependencies to'
HA2996F065595: '写入DOT格式的头文件依赖关系的文件名'
# 'Filename to write statistics to'
HE239C00D43A5: '写入统计信息的文件名'
# 'Filename where the element is defined.'
H1FDF8DE162D7: '元素定义所在的文件名。'
# 'Files referenced in the debug information.'
HBAB8680F7972: '调试信息中引用的文件。'
# 'Fill Lanai delay slots with NOPs.'
H5DF685F1DB1E: '用NOP填充Lanai延迟插槽。'
# 'Fill a percentage of the latency between neighboring MFMA with s_nops.'
H17E41E561253: '在相邻MFMA之间用s_nops填充指定百分比的延迟。'
# 'Fill all delay slots with NOPs.'
HDA6B69446833: '用NOP填充所有延迟插槽。'
# 'Fill delay slot for MIPS'
HAFAF170DC965: '为MIPS架构填充延迟槽'
# 'Filter all non-error diagnostics (discouraged: testing only!)'
H9EF0422D020C: '过滤所有非错误诊断（不推荐：仅用于测试！）'
# 'Filter the benchmarks before analysing them'
H30E98BA4CBDB: '在分析之前过滤基准测试'
# 'Filtering and Sorting Options'
HAE5C92A1E57B: '筛选和排序选项'
# 'Finalize ISel and expand pseudo-instructions'
HAC66FC917CAA: '最终确定ISel并展开伪指令'
# 'Finalize machine instruction bundles'
H54F93CB22051: '最终确定机器指令包'
# 'Find methods that overrides a virtual method.'
H26E803BD2E38: '查找覆盖virtual method的方法。'
# "Find objects in DIR or based on FILE's path"
H4D2FE19AC654: '在目录DIR或基于文件FILE的路径中查找对象'
# 'Find subclasses of a class.'
HC1D51E00B82D: '查找一个类的子类。'
# 'Fix copies between 32 and 16 bit registers by extending to 32 bit'
H2E54AD53EEA9: '通过扩展到 32 位来修复 32 位和 16 位寄存器之间的复制'
# 'Fix function entry count in profile use.'
H99125FC0562C: '修正配置文件使用中的函数入口计数。'
# 'Fix mismatching bitcasts for WebAssembly'
H6D3A5F07020F: '修复WebAssembly中的不匹配位转换'
# 'Fixup Statepoint Caller Saved'
H2BF0C8053839: '修复Statepoint调用者保存寄存器'
# 'Fixup each natural loop to have a single exit block'
H866DA2E73BC2: '调整每个自然循环以拥有单一出口块'
# 'Flatten the CFG'
H68BF16D61F64: '展平控制流图'
# 'Flow Sensitive profile file name.'
HD4BF3081650C: '流敏感配置文件文件名。'
# 'Flow Sensitive profile remapping file name.'
H21713A45D881: '流敏感配置文件重映射文件名。'
# 'Flush denormal floating point values to zero in CUDA/HIP device mode.'
HF25D292D7C52: '在CUDA/HIP设备模式下将次正规浮点值冲洗为零。'
# 'Fold memory accesses to model more possible delinearizations (does not scale well)'
HC5006CA24C2C: '折叠内存访问以建模更多可能的非线性化（扩展性不佳）'
# 'Fold null checks into faulting memory operations'
HC5500C22FC68: '将空指针检查合并到引发故障的内存操作中'
# 'Folder name for view splitting.'
HE1AD57EFF1BD: '视图拆分的文件夹名称。'
# 'Follow Fortran 2003 rules for (re)allocating the LHS of the intrinsic assignment'
H1CD29CD7E654: '遵循Fortran 2003 规则重新分配固有赋值的左操作数'
# 'Follow the AAPCS standard requirement stating that volatile bit-field width is dictated by the field container type. (ARM only).'
H318AB39D2C02: '遵循AAPCS标准要求，即volatile位字段的宽度由字段容器类型决定。（仅限ARM）'
# 'Follows the AAPCS standard that all volatile bit-field write generates at least one load. (ARM only).'
HBE2099993756: '遵循AAPCS标准，所有volatile位字段写入操作至少生成一个加载操作。（仅限ARM）'
# 'For -verify only: Inject a symbol into the extern symbol table.'
H691B584BF08D: '-verify专用：将符号注入外部符号表。'
# 'For -verify only: Map a section to a specific address.'
H943A8FBB7A51: '-verify专用：将某个段映射到特定地址。'
# 'For -verify only: Separation between sections in phony target address space.'
HFFEB26CFD553: '-verify专用：虚构目标地址空间中段之间的分隔符。'
# 'For -verify only: end of phony target address range.'
H2C3EAFFA8499: '-verify专用：虚构目标地址范围的结束。'
# 'For -verify only: start of phony target address range.'
H1B0A5AC1E801: '-verify专用：虚构目标地址范围的起始。'
# 'For MachO, disable atexit()-based global destructor lowering'
HFC5FF11ED2AC: '对于MachO，禁用基于atexit()的全局析构函数转换'
# 'For a large interval, if it is coalesced with other live intervals many times more than the threshold, stop its coalescing to control the compile time. '
H31454C2664AA: '对于大间隔，如果与其他活跃间隔的合并次数远超阈值，则停止合并以控制编译时间。'
# "For a list of available CPUs for the target use '-mcpu=help'"
HFB257544DEA1: '要查看目标可用的CPU列表，请使用“-mcpu=help”选项'
# "For a list of available architectures for the target use '-mcpu=help'"
HCFFD910F1E45: '要查看目标可用的架构列表，请使用“-mcpu=help”选项'
# 'For all options that iterate over modules, ignore modules from system libraries'
HF30AFF2F9F8C: '对于遍历模块的所有选项，忽略系统库中的模块'
# 'For all options that iterate over modules, limit to the specified module'
H076A99AD2B76: '对于遍历模块的所有选项，限制到指定的模块'
# 'For cold function instrumentation, skip instrumenting functions whose entry count is above the given value.'
HE6D6C775176E: '对于冷函数插桩，跳过入口计数超过给定值的函数插桩'
# 'For cold function instrumentation, treat count unknown(e.g. unprofiled) functions as cold.'
H063B03A52387: '对于冷函数插桩，将计数未知（例如未分析）的函数视为冷函数'
# 'For context sensitive PGO counts. Does not work with CSSPGO.'
HBBB3E8C601A8: '针对上下文敏感的PGO计数。不支持与CSSPGO一起使用'
# 'For each function, emit a dot graph depicting potential LVI gadgets'
H57E599CB6769: '为每个函数生成展示潜在LVI漏洞的dot图'
# 'For each function, emit a dot graph depicting potential LVI gadgets, and do not insert any fences'
HAC353EF77E07: '为每个函数生成展示潜在LVI漏洞的dot图，并不插入任何屏障'
# 'For each function, emit a dot graph to stdout depicting potential LVI gadgets, used for testing purposes only'
H3C8BB209ABDE: '为每个函数将展示潜在LVI漏洞的dot图输出到标准输出，仅用于测试目的'
# 'For merge, use the provided unstripped binary to correlate the raw profile.'
H5C641C769774: '在合并时，使用提供的未剥离二进制文件关联原始配置文件'
# 'For partially supported constructs, emit private/local variables as clauses/specifiers on MLIR ops.'
H5E0F9648E945: '对于部分支持的结构，将私有/局部变量作为子句/说明符生成在MLIR操作上'
# 'For paths in debug info, remap directory <old> to <new>. If multiple options match a path, the last option wins'
H3D3679C30C18: '在调试信息中，将目录 <old> 重映射为 <new>。如果多个选项匹配同一路径，则最后一个选项生效'
# 'For sample profiles, list function names (with calling context for csspgo) for overlapped functions with similarities below the cutoff (percentage times 10000).'
H463D2852BF2F: '对于采样配置文件，列出相似度低于阈值（百分比乘以 10000）的重叠函数名称（包含csspgo的调用上下文）'
# 'For shared library loaded with the main program, change local-dynamic access(es) to initial-exec access(es) at the function level (AIX 64-bit only).'
HD94E43E648D1: '针对与主程序一起加载的共享库，在函数级别将local-dynamic访问模式更改为initial-exec访问模式（仅限AIX 64 位）'
# 'For show, read and extract profile metadata from debug info and show the functions it found. For merge, use the provided debug info to correlate the raw profile.'
H3F78033E8267: '在显示时，从调试信息中读取并提取配置文件元数据并显示找到的函数。在合并时，使用提供的调试信息关联原始配置文件'
# 'For symbols in profile symbol list, regard their profiles to be accurate. It may be overridden by profile-sample-accurate. '
H960468D026B4: '对于配置文件符号列表中的符号，将其配置文件视为准确。可能会被profile-sample-accurate覆盖'
# "For test - keep the ML Inline advisor's FunctionPropertiesInfo cache"
H68E3D966BDA0: '用于测试 - 保留ML内联顾问的FunctionPropertiesInfo缓存'
# "For testing purposes, always break large PHIs even if it isn't profitable."
H0BECF527CC8D: '出于测试目的，即使没有收益，也始终拆分大型PHI节点'
# 'For the function which is cold in instr profile but hot in sample profile, if the ratio of the number of zero counters divided by the total number of counters is above the threshold, the profile of the function will be regarded as being harmful for performance and will be dropped.'
H326030B813BD: '对于在仪器配置文件中为冷而在采样配置文件中为热的函数，如果零计数器数量与总计数器数量的比率超过阈值，则该函数的配置文件将被视为对性能有害并被丢弃'
# 'For the module ID for the file to process, useful to match what is in the index.'
HB6A96C6D31C3: '用于要处理文件的模块ID，有助于匹配索引中的内容'
# 'For use with /winsysroot, defaults to newest found'
H9FFDA74D3CE8: '与/winsysroot配合使用时，默认使用最新找到的'
# 'Force a peel count regardless of profiling information.'
H6BA57EBF2817: '强制指定循环展开次数，无论配置文件信息如何'
# 'Force a specific generic_v<N> flag to be added. For testing purposes only.'
H12597D7C787F: '强制添加特定的generic_v<N> 标志。仅用于测试目的'
# 'Force align the stack to the minimum alignment'
H6ABD893EDD1A: '强制将栈对齐到最小对齐值'
# 'Force all edges in the function summary to cold'
HF7516A69CF5A: '强制将函数摘要中的所有边标记为冷'
# 'Force all functions to be noinline'
HB0A34849A65E: '强制所有函数为noinline'
# 'Force all indexed operations to be legal for the GlobalISel combiner'
H8B4D9E88A547: '强制所有索引操作对GlobalISel组合器合法'
# 'Force all memory accesses to be aligned (AArch32/MIPSr6 only)'
HB9DB3E9A0275: '强制所有内存访问对齐（仅限AArch32/MIPSr6）'
# 'Force all memory accesses to be aligned (AArch64/LoongArch/RISC-V only)'
H592DBE5D5A8A: '强制所有内存访问对齐（仅限AArch64/LoongArch/RISC-V）'
# 'Force all scalar memory accesses to be aligned (RISC-V only)'
H47C5C3723D44: '强制所有标量内存访问对齐（仅RISC-V）'
# 'Force all vector memory accesses to be aligned (RISC-V only)'
H8477BA8471BC: '强制所有向量内存访问对齐（仅RISC-V）'
# 'Force all waitcnt instrs to be emitted as s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)'
H687C328A88F2: '强制将所有waitcnt指令生成为s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)'
# 'Force all waitcnt load counters to wait until 0'
H896788DC2080: '强制所有waitcnt加载计数器等待直到 0'
# 'Force allowance of nested hardware loops'
HAD8E45F66910: '允许嵌套硬件循环'
# 'Force analysis to continue in the presence of unsupported instructions'
H0386966E38DA: '在存在不受支持的指令时继续进行分析'
# 'Force behavior as if the user specified pragma omp requires unified_shared_memory.'
H0D0C1138BD58: '强制行为如同用户指定了pragma omp requires unified_shared_memory。'
# 'Force bidirectional post reg-alloc list scheduling'
H2AB733A479DE: '强制执行寄存器分配后的双向列表调度'
# 'Force bidirectional pre reg-alloc list scheduling'
H9527EDFB6708: '强制执行寄存器分配前的双向列表调度'
# 'Force bottom-up post reg-alloc list scheduling'
HC9A155CC7DD9: '强制执行寄存器分配后的自底向上列表调度'
# 'Force bottom-up pre reg-alloc list scheduling'
HD5FFAD3EC478: '强制执行寄存器分配前的自底向上列表调度'
# 'Force codegen to assume rounding mode can change dynamically'
H5694C07468F1: '强制代码生成假设舍入模式可以动态变化'
# 'Force disable the lazy-loading on-demand of metadata when loading bitcode for importing.'
H2329A45D867C: '强制禁用加载bitcode时元数据的按需惰性加载'
# 'Force double to be <n> bits'
H6A3CAE57D5DB: '强制double为 <n> 位'
# 'Force each unsigned fixed point type to have an extra bit of padding to align their scales with those of signed fixed point types'
H2DB086248971: '强制每个无符号定点类型都有一个额外的填充位，使其量程与有符号定点类型对齐'
# 'Force emit s_waitcnt expcnt(0) instrs'
H88E5FE04F072: '强制生成带有expcnt(0)的s_waitcnt指令'
# 'Force emit s_waitcnt lgkmcnt(0) instrs'
HE8A3AAF43D8E: '强制生成带有lgkmcnt(0)的s_waitcnt指令'
# 'Force emit s_waitcnt vmcnt(0) instrs'
H38DB94C17996: '强制生成带有vmcnt(0)的s_waitcnt指令'
# 'Force enable speculative execution side effect suppression. (Note: User must pass -mlvi-cfi in order to mitigate indirect branches and returns.)'
H5C45F8896F6A: '强制启用推测执行副作用抑制。（注意：需传递-mlvi-cfi选项以缓解间接分支和返回。）'
# 'Force enable speculative load hardening'
HE35AC46B0548: '强制启用推测加载强化'
# 'Force function reduction to keep main'
H0BB63C069108: '强制函数简化时保留main'
# 'Force function specialization for every call site with a constant argument'
H16827AFD0E0F: '强制对具有常量参数的每个调用点进行函数专化'
# 'Force function to be mips32'
H47CC37388F1A: '强制使用mips32架构'
# 'Force generation of loop guard intrinsic'
H660425C561DD: '强制生成循环守卫内建函数'
# 'Force generation of thread parallel code ignoring any cost model'
HD5652803169B: '强制生成线程并行代码，忽略任何成本模型'
# 'Force hardware loop counter to be updated through a phi'
H6034A18A690A: '强制通过phi节点更新硬件循环计数器'
# 'Force hardware loops intrinsics to be inserted'
H526108F8C3D0: '强制插入硬件循环内建函数'
# 'Force interpretation: disable JIT'
HE0B08266ED91: '强制解释模式：禁用JIT'
# 'Force linking the clang builtins runtime library'
H602A2DB51D2C: '强制链接clang内建运行时库'
# 'Force long double to be 128 bits'
HF5330D6B0F62: '强制long double为 64 位'
# 'Force long double to be 64 bits'
HF1CEF43473D8: '强制long double为 128 位'
# 'Force long double to be 80 bits, padded to 128 bits for storage'
H2FBC78A0A1C7: '强制long double为 80 位，存储时填充至 128 位'
# 'Force machine combiner to use a specific strategy for machine trace metrics evaluation.'
H8D7274D95AD0: '强制机器组合器使用特定策略求值机器轨迹指标。'
# 'Force matrix instruction fusion even if not profitable.'
HABD067814D75: '强制融合矩阵指令，即使没有收益。'
# 'Force optimization experiment (for testing)'
H23001FDFF697: '强制启用优化实验（用于测试）'
# 'Force outline regions with live exits'
H13A02DD93B7D: '强制提取具有活动出口的区域'
# 'Force outlining cold blocks from loops.'
H04711024D9E9: '强制从循环中提取冷块。'
# 'Force pipeliner to use specified II.'
H17E89A49B48C: '强制流水线器使用指定的II。'
# 'Force pipeliner to use specified issue width.'
HA8DD64472E32: '强制流水线器使用指定的发射宽度。'
# 'Force realign the stack at entry to every function'
H31A8B99D0D70: '强制在每个函数入口处重新对齐栈'
# 'Force store splitting no matter what the target query says.'
H7A397BF735D5: '无论目标查询如何，强制拆分存储。'
# 'Force the (profiled-guided) size optimizations. '
HA4B424DB2FF9: '强制执行（基于分析的）尺寸优化。'
# 'Force the alignment of all blocks in the function in log2 format (e.g 4 means align on 16B boundaries).'
HB1C496FAEC2F: '以log2格式强制对齐函数中的所有块（例如 4 表示对齐到 16 字节边界）。'
# "Force the alignment of all blocks that have no fall-through predecessors (i.e. don't add nops that are executed). In log2 format (e.g 4 means align on 16B boundaries)."
HEC173CEDA264: '强制对齐所有没有穿透前驱的块（即不添加会被执行的nop）。以log2格式（例如 4 表示对齐到 16 字节边界）。'
# 'Force the alignment of all functions in log2 format (e.g. 4 means align on 16B boundaries).'
HAC694582BD7C: '以log2格式强制对齐所有函数（例如 4 表示对齐到 16 字节边界）。'
# 'Force the interpretation of -stream as a string, even if it is a valid integer'
HD1DE45392158: '即使-stream是有效整数，也强制将其解释为字符串'
# 'Force the static analyzer to analyze functions defined in header files'
HAB6B5ACFD382: '强制静态分析器分析头文件中定义的函数'
# 'Force the tail folding style'
HA1C7FE88ED1D: '强制使用尾部折叠风格。'
# 'Force the use of a base pointer in every function'
HBE1018F652C4: '强制在每个函数中使用基指针。'
# 'Force the use of precise cost loop rotation strategy.'
HEC5F52CCB084: '强制使用精确成本循环旋转策略。'
# 'Force the use of resource intervals in the schedule model'
HC146F04B90B5: '强制在调度模型中使用资源间隔。'
# 'Force the use of streaming code for all functions'
H9D121C14481F: '强制所有函数使用流式代码。'
# 'Force the use of streaming-compatible code for all functions'
H3939F502979A: '强制所有函数使用兼容流式代码。'
# 'Force thread model single in LICM pass'
H95CEFB645311: '在循环不变代码移动（LICM）Pass中强制使用单线程模型。'
# 'Force to instrument function entry basicblock.'
HCB64281E774F: '强制在函数入口基本块中插入探针。'
# 'Force to instrument loop entries.'
H3FF84C8727C9: '强制对循环入口进行插装。'
# 'Force top-down post reg-alloc list scheduling'
H624C5BFC69FE: '强制执行寄存器分配后的自顶向下列表调度'
# 'Force top-down pre reg-alloc list scheduling'
HF7823207CF83: '强制执行寄存器分配前的自顶向下列表调度'
# 'Force use of AdvSIMD scalar instructions everywhere'
H5BE24FD8EC8D: '强制在所有地方使用AdvSIMD标量指令'
# 'Force using MLIR complex operations instead of libm complex operations'
HE874B9895802: '强制使用MLIR的复数运算而非libm的复数运算'
# 'Force validation of user headers when repeatedly loading a module file within single build session'
H0E2DB592B82B: '在单次构建会话内重复加载模块文件时强制验证用户头文件'
# 'Force wchar_t to be a short unsigned int'
H344B5212E317: '强制wchar_t为short unsigned int'
# 'Force wchar_t to be an unsigned int'
H43342C927949: '强制wchar_t为unsigned int'
# 'Force whether the StructurizeCFG pass skips uniform regions'
H1E4EFD3EA072: '强制指定StructurizeCFG是否跳过统一区域'
# 'Forces the maximum bytes allowed to be emitted when padding for alignment'
H3B4D326FCA22: '强制设置对齐填充时允许的最大字节数'
# 'Forcibly enables non-trivial loop unswitching rather than following the configuration passed into the pass.'
H2E9D92A16FC3: '强制启用非平凡循环拆分，而非遵循传递给该pass的配置。'
# 'Forget everything in SCEV when doing LoopUnroll, instead of just the current top-most loop. This is sometimes preferred to reduce compile time.'
HDBEAD86F6F49: '在进行LoopUnroll时，清空SCEV中的所有信息，而非仅当前顶层循环。这有时可减少编译时间。'
# 'Form fused FP ops (e.g. FMAs)'
H88EF5D85058D: '形成融合浮点运算（例如FMAs）'
# 'Format a range of this length (in bytes).\nMultiple ranges can be formatted by specifying\nseveral -offset and -length pairs.\nWhen only a single -offset is specified without\n-length, clang-format will format up to the end\nof the file.\nCan only be used with one input file.'
H93D871018723: '格式化此长度（以字节为单位）的范围。\n可通过指定多个-offset和-length参数对多个范围进行格式化。\n当仅指定单个-offset且未指定-length时，clang-format将格式化到文件末尾。\n仅支持单个输入文件。'
# 'Format a range starting at this byte offset.\nMultiple ranges can be formatted by specifying\nseveral -offset and -length pairs.\nCan only be used with one input file.'
H28E3CD62FED9: '从该字节偏移量开始的范围进行格式化。\n可通过指定多个-offset和-length参数对多个范围进行格式化。\n仅支持单个输入文件。'
# "Format consumable by Brendan Gregg's FlameGraph tool. Only valid with -all-stacks."
HE769F9BDFBAB: '可被Brendan Gregg的FlameGraph工具使用的格式。仅在使用-all-stacks时有效。'
# 'Format for outputted docs.'
HC5A8B725033A: '输出文档的格式。'
# 'Format message diagnostics so that they fit within N columns'
H5F2F2FEC74C8: '格式化诊断信息，使其适应N列'
# 'Format of index export'
H9AED5C1C80E8: '索引导出的格式'
# 'Format of output profile'
HAE3C92A81F31: '输出配置文件的格式'
# 'Format of the index to be written'
H036107DC230C: '要写入的索引格式'
# 'Formatting Options'
H7C2DC2E6B392: '格式化选项'
# 'Forward options to the linker'
H0E5969703D2A: '将选项转发给链接器'
# 'Forward switch condition to phi ops (default = false)'
HB7C76B2E6FA2: '将switch条件转发给phi操作（默认值为false）'
# 'Four-byte version string for gcov files.'
H32782AC0D44C: 'gcov文件的四字节版本字符串。'
# 'Frame Data (DEBUG_S_FRAMEDATA subsection)'
H4EACA6AC6ABA: '帧数据（DEBUG_S_FRAMEDATA子部分）'
# 'Fuchsia API Level prohibits specifying a minor or sub-minor version'
H73A16BC6357D: 'Fuchsia API 级别禁止指定次要或子次要版本'
# 'Full version of the Windows SDK, defaults to newest found'
HD00F6CBB0217: 'Windows SDK的完整版本，默认为最新找到的版本'
# 'Fully encode c++ class template specialization'
H83B6D3243278: '完整编码c++类模板特化'
# 'Fully expand the memory accesses of the detected Scops'
H41926418D084: '完全展开检测到的Scops的内存访问'
# 'Fully relocatable, position independent code'
H2EE1300E53E0: '完全可重定位，位置无关代码'
# 'Function Alias Analysis Results'
H5E305706D9B2: '函数别名分析结果'
# 'Function Entry Count'
HF80E7DCD1642: '函数入口计数'
# 'Function attribute to apply to cold functions as determined by PGO'
H345451AD326B: '根据PGO确定的冷函数应用的函数属性'
# 'Function entry point.'
HAD67FD8DA947: '函数入口点。'
# 'Function filtering options'
H71383E432CB7: '函数筛选选项'
# 'Function level overlap information for every function (with calling context for csspgo) in test profile with max count value greater than the parameter value'
H66ADA33E3E20: '测试配置中每个函数（包含csspgo调用上下文）的函数级重叠信息，其最大计数值大于参数值'
# 'Function mem bound threshold in %'
HC48D6911C0B3: '函数内存边界阈值百分比 (%)'
# 'Function names that are public.'
H1CBBD51F21AA: '公开的函数名称。'
# 'Function number to canonicalize.'
H14E5011F4FDD: '需要规范化的函数编号。'
# 'Function register usage analysis'
HC45FBE8F1495: '函数寄存器使用分析'
# 'Function to call as entry point.'
H9A688E8595B8: '作为入口点调用的函数。'
# 'Function type.'
HC8800532CD60: '函数类型。'
# 'Function.'
H7375AFF85987: '函数。'
# 'Fuse FP ops whenever profitable'
H9F1BE3BC2E20: '在有利时融合FP运算'
# 'GC Lowering'
HB5C53C8FC4DB: 'GC 下降处理'
# 'GCC does not allow %0 attribute in this position on a function definition'
H6258B157AA4F: 'GCC 不允许在此位置在函数定义上使用 %0 属性'
# 'GCC does not allow an attribute in this position on a function declaration'
H6328F86D9296: 'GCC 不允许在此位置在函数声明上使用属性'
# 'GCC does not allow the %0 attribute to be written on a type'
HAF18361FDD0D: 'GCC 不允许将 %0 属性应用于类型'
# "GCC does not allow the 'cleanup' attribute argument to be anything other than a simple identifier"
HB0EE895D3D5D: "GCC 要求 'cleanup' 属性参数只能是简单标识符"
# 'GCC does not allow variable declarations in for loop initializers before C99'
HD212EAC451BD: '在C99之前，GCC 不允许在for循环初始化器中声明变量'
# 'GCC encoding (only meaningful for -sample)'
H893D2EDBC511: 'GCC 编码（仅在 -sample 时有意义）'
# 'GCC requires a function with the %0 attribute to be variadic'
H4044A123EF83: 'GCC 要求带有 %0 属性的函数必须是可变参数函数'
# 'GCN Create VOPD Instructions'
HD50B13295BAC: 'GCN创建VOPD指令'
# 'GCN DPP Combine'
H19E8A5665832: 'GCN DPP合并'
# 'GCN NSA Reassign'
H506D8BF350C1: 'GCN NSA 重新分配'
# 'GLIBC Vector Math library'
HFDA2A482B5C5: 'GLIBC 向量数学库'
# 'GNU OpenMP'
H7F5648C19468: 'GNU OpenMP'
# 'GNU decimal type extension not supported'
HE1719E002830: 'GNU十进制类型扩展未被支持'
# 'GNU vector conditional operand cannot be %select{void|a throw expression}0'
H5DF13110207F: 'GNU向量条件操作数不能是 %select{void|throw表达式}0'
# 'GNU-style inline assembly is disabled'
H2E56E6455BF0: '已禁用GNU风格的内联汇编'
# 'GNUstep Objective-C runtime version %0 incompatible with target binary format'
HBFB3FAB065B9: 'GNUstep Objective-C运行时版本 %0 与目标二进制格式不兼容'
# "GPU arch %0 is supported by CUDA versions between %1 and %2 (inclusive), but installation at %3 is %4; use '--cuda-path' to specify a different CUDA install, pass a different GPU arch with '--cuda-gpu-arch', or pass '--no-cuda-version-check'"
HA444373A0822: "GPU架构 %0 在CUDA %1 到 %2 版本（含）中受支持，但 %3 处的安装版本为 %4；请使用 '--cuda-path' 指定其他CUDA安装路径，或通过 '--cuda-gpu-arch' 指定不同GPU架构，或使用 '--no-cuda-version-check' 禁用版本检查"
# 'Gang up loads and stores generated by inlining of memcpy'
HE535C0271E93: '通过内联memcpy生成的合并加载和存储操作'
# 'Gate the invocation of the tracing callbacks on a global variable. Currently only supported for trace-pc-guard and trace-cmp.'
HE7375E04E4A1: '通过全局变量门控跟踪回调的调用。当前仅支持trace-pc-guard和trace-cmp。'
# 'Generalize pointers in CFI indirect call type signature checks'
H05CAF1DC1C80: '在CFI间接调用类型签名检查中泛化指针'
# 'Generate "extract" instructions'
HC571F6794268: '生成“提取”指令'
# 'Generate "insert" instructions'
H783E8CF7431F: '生成“插入”指令'
# 'Generate ARM CDE builtin code-generator for clang'
H5A5EC1A5B6C3: '为 clang 生成 ARM CDE 内建代码生成器'
# 'Generate ARM CDE builtin definitions for clang'
H4D955CE0B09F: '为 clang 生成 ARM CDE 内建定义'
# 'Generate ARM CDE builtin sema checks for clang'
H322C3CB145B5: '为 clang 生成 ARM CDE 内建语义检查'
# 'Generate ARM MVE builtin code-generator for clang'
H51464E4006BA: '为 clang 生成 ARM MVE 内建代码生成器'
# 'Generate ARM MVE builtin definitions for clang'
HB30829C9D62F: '为 clang 生成 ARM MVE 内建定义'
# 'Generate ARM MVE builtin sema checks for clang'
H9EB24BD38363: '为 clang 生成 ARM MVE 内建语义检查'
# 'Generate ARM NEON sema support for clang'
HB47F65A392BE: '为 clang 生成 ARM NEON 语义支持'
# 'Generate ARM NEON tests for clang'
HB3324D2A49FC: '为 clang 生成 ARM NEON 测试用例'
# 'Generate AST expressions for unmodified and modified accesses'
H729F2BA5C5BE: '为未修改和修改后的访问生成AST表达式'
# 'Generate C++20 header units from header files'
H8199E8EA3A2D: '从头文件生成C++20头单元'
# 'Generate CXX11 attributes info'
H008C47C9924C: '生成 CXX11 属性信息'
# 'Generate Clang AST comment nodes'
H1A2137DB81DD: '生成 Clang AST 注释节点'
# 'Generate Clang AST declaration nodes'
H0D831097F249: '生成 Clang AST 声明节点'
# 'Generate Clang AST statement nodes'
H9DA2A7F822D1: '生成 Clang AST 语句节点'
# 'Generate Clang AST type nodes'
H6C40DA5710E5: '生成 Clang AST 类型节点'
# 'Generate Clang AbstractTypeReader class'
H0B517D2DC9BE: '生成 Clang 抽象类型读取器类（AbstractTypeReader）'
# 'Generate Clang AbstractTypeWriter class'
H3C1A155F700F: '生成 Clang 抽象类型写入器类（AbstractTypeWriter）'
# 'Generate Clang BasicReader classes'
HCAC9D912FD7C: '生成 Clang 基础读取器类（BasicReader）'
# 'Generate Clang BasicWriter classes'
H7777A854222B: '生成 Clang 基础写入器类（BasicWriter）'
# 'Generate Clang Static Analyzer checkers'
HAF44CF1570A7: '生成Clang静态分析器检查器'
# 'Generate Clang constexpr interpreter opcodes'
HCE00FBA3D9DA: '生成Clang constexpr解释器操作码'
# 'Generate Clang diagnostic compatibility ids'
HB3B0D51C372C: '生成Clang诊断兼容性标识符'
# 'Generate Clang diagnostic enums for selects'
HFF484ABCD39B: '为选择项生成Clang诊断枚举'
# 'Generate Clang diagnostic groups'
HD491E8E3F838: '生成Clang诊断组'
# 'Generate Clang diagnostic interface headers'
HC78769A357D2: '生成Clang诊断接口头文件'
# 'Generate Clang diagnostic name index'
H26D83AD60FA3: '生成Clang诊断名称索引'
# 'Generate Clang diagnostics definitions'
H42FB0D88C678: '生成Clang诊断定义'
# 'Generate CodeView debug information'
H5E04C2FAE7DA: '生成CodeView调试信息'
# 'Generate DWARF4 type units.'
H93A2FEDB326C: '生成DWARF4类型单元。'
# 'Generate Extract API information as a side effect of compilation.'
H35927234EEF2: '将编译过程中提取的API信息作为副作用生成'
# 'Generate IR involving scalable vector types'
HBFD721B3719E: '生成涉及可扩展向量类型的中间表示（IR）'
# 'Generate Interface Stub Files, emit merged text not binary.'
H48D6D551365C: '生成接口存根文件，输出合并后的文本而非二进制文件'
# 'Generate Interface Stub Files.'
H93E694C37FB8: '生成接口存根文件'
# 'Generate LBR info with perf itrace argument'
H63A1CBFF2B95: '使用perf itrace参数生成LBR信息'
# 'Generate M NOPs before function entry'
H411052747AED: '在函数入口前生成M个NOP指令'
# 'Generate M NOPs before function entry and N-M NOPs after function entry. If section is specified, use it instead of __patchable_function_entries.'
H4A7E3BFEB46A: '在函数入口前生成M个NOP指令，在函数入口后生成N-M个NOP指令。如果指定了段，则使用该段而不是__patchable_function_entries.'
# 'Generate Metal library'
H30181B8F806A: '生成Metal库'
# 'Generate Offload API header contents'
H228CB18FCD9A: '生成Offload API头文件内容'
# 'Generate Offload API print header'
HDB1F685BA2FE: '生成Offload API打印头文件'
# 'Generate Offload API wrapper function definitions'
HE6C5D6F8A8FB: '生成Offload API包装函数定义'
# 'Generate Offload Error Code enum'
HD6D65DD43A04: '生成Offload错误码枚举'
# 'Generate OpenCL builtin declaration handlers'
HA18DDE5AEDF3: '生成OpenCL内建声明处理器'
# 'Generate OpenCL builtin declaration tests'
H5DAE86CEEBCA: '生成OpenCL内建声明测试'
# 'Generate OpenCL builtin header'
H2590CD761606: '生成OpenCL内建头文件'
# 'Generate SPIR-V code'
HC1B38B428E45: '生成SPIR-V代码'
# 'Generate Scalar MASS entries'
H428973D80E2B: '生成标量MASS条目'
# 'Generate XRay instrumentation sleds on function entry and exit'
H3016D234FBA9: '在函数入口和出口处生成XRay检测滑道'
# 'Generate a .mlir reproducer file at the given output path if the pass manager crashes or fails'
HBC83C0234127: '如果pass manager崩溃或失败，在指定的输出路径生成.mlir复现文件'
# 'Generate a YAML optimization record file'
H1942B716CF27: '生成YAML优化记录文件'
# 'Generate a __mcount_loc section entry for each __fentry__ call.'
HE460D06CF31F: '为每个__fentry__调用生成一个__mcount_loc节条目'
# 'Generate a clang attribute list'
H89A583ECD8F5: '生成clang属性列表'
# 'Generate a clang attribute spelling index'
HE19534D90FCA: '生成clang属性拼写索引'
# 'Generate a clang attribute spelling list'
H4F8740D65FE7: '生成clang属性拼写列表'
# 'Generate a clang attribute subject match rule list'
HC95A81873DA9: '生成clang属性主题匹配规则列表'
# 'Generate a clang parsed attribute kinds'
H78888371BD55: '生成clang已解析属性类型列表'
# 'Generate a clang parsed attribute list'
HD97B596A50F3: '生成clang已解析属性列表'
# 'Generate a clang template instantiate code'
H961D4AD666CA: '生成clang模板实例化代码'
# 'Generate a list of all Offload API function names'
H3DB190C217E7: '生成所有Offload API函数名称列表'
# 'Generate a list of attributes supported by #pragma clang attribute for testing purposes'
HE3D52A2C4CA9: '为测试目的生成由#pragma clang attribute支持的属性列表'
# 'Generate a list of regular keyword attributes with info about their arguments'
H86F657FC95B7: '生成常规关键字属性列表及其参数信息'
# 'Generate a partial profile (only meaningful for -extbinary)'
H8B3C403992F1: '生成部分配置文件（仅对-extbinary有意义）'
# 'Generate a pch file for all code up to and including <filename>'
H3A6818A5EE16: '为所有直到并包含 <filename> 的代码生成预编译头文件'
# 'Generate a recursive AST visitor for clang attributes'
HD2CD27931B90: '为clang属性生成递归AST访问器'
# 'Generate a sparse profile (only meaningful for -instr)'
H2390B2DEB1A2: '生成稀疏配置文件（仅对-instr有意义）'
# 'Generate a table of attribute documentation'
H4075E225B4D0: '生成属性文档表格'
# 'Generate absolute set instructions'
HD09B902A76CD: '生成绝对集合指令'
# 'Generate additional symbol graphs for extended modules.'
H621EAE5CB426: '为扩展模块生成附加的符号图'
# 'Generate all instruction with TC'
HCB4E103EFF3E: '使用TC生成所有指令'
# 'Generate all parser-related attribute string switches'
HBC7D18EAD0C4: '生成所有与解析器相关的属性字符串开关'
# 'Generate all parser-related attribute subject match rulestring switches'
H3DDA6CE234B8: '生成所有与解析器相关的属性主题匹配规则字符串开关'
# 'Generate all reports.'
H56F361794B7A: '生成所有报告'
# 'Generate an mlir reproducer at the provided filename (no crash required)'
HEF652CF84C8A: '在提供的文件名处生成mlir复现文件（无需崩溃）'
# 'Generate an optimization record file in a specific format'
H93DDC23AE075: '以特定格式生成优化记录文件'
# 'Generate an optimized version of the match table'
HB99621634FE9: '生成匹配表的优化版本'
# 'Generate any type of IT block'
H3521C624C6E3: '生成任意类型的IT块'
# 'Generate arm_bf16.h for clang'
H4049A4CCEEB2: '为clang生成arm_bf16.h'
# 'Generate arm_cde.h for clang'
H20C9AE949999: '为clang生成arm_cde.h'
# 'Generate arm_fp16.h for clang'
HA003409EA627: '为clang生成arm_fp16.h'
# 'Generate arm_immcheck_types.inc (immediate range check types) for clang'
H3E399A3BC5ED: '为clang生成arm_immcheck_types.inc（立即数范围检查类型）'
# 'Generate arm_mve.h for clang'
H9B02FDBF61FE: '为clang生成arm_mve.h'
# 'Generate arm_neon.h for clang'
HBC7A4B2C0607: '为clang生成arm_neon.h'
# 'Generate arm_sme.h for clang'
HE4D6EF6670EF: '为clang生成arm_sme.h'
# 'Generate arm_sme_builtin_cg_map.inc for clang'
H9942231BE658: '为clang生成arm_sme_builtin_cg_map.inc'
# 'Generate arm_sme_builtins.inc for clang'
HB5A0445595D2: '为clang生成arm_sme_builtins.inc'
# 'Generate arm_sme_builtins_za_state.inc for clang'
H1A92D0667981: '为clang生成arm_sme_builtins_za_state.inc'
# 'Generate arm_sme_sema_rangechecks.inc for clang'
H934D5C9C551E: '为clang生成arm_sme_sema_rangechecks.inc'
# 'Generate arm_sme_streaming_attrs.inc for clang'
HB0ACDD97739D: '为clang生成arm_sme_streaming_attrs.inc'
# 'Generate arm_sve.h for clang'
HA4A04F03FE49: '为clang生成arm_sve.h'
# 'Generate arm_sve_builtin_cg_map.inc for clang'
H85004239686F: '为clang生成arm_sve_builtin_cg_map.inc'
# 'Generate arm_sve_builtins.inc for clang'
H521827D71962: '为clang生成arm_sve_builtins.inc'
# 'Generate arm_sve_sema_rangechecks.inc for clang'
H7845A0DBDBD3: '为clang生成arm_sve_sema_rangechecks.inc'
# 'Generate arm_sve_streaming_attrs.inc for clang'
H0E1FDBC6C09B: '为clang生成arm_sve_streaming_attrs.inc'
# 'Generate arm_sve_typeflags.inc for clang'
HACE26ADDC9C9: '为clang生成arm_sve_typeflags.inc'
# 'Generate arm_vector_types.h for clang'
H7C1E9F56F891: '为clang生成arm_vector_types.h'
# 'Generate attribute documentation'
H5EECEC688125: '生成属性文档'
# 'Generate attribute spelling list'
H5E3166505291: '生成属性拼写列表'
# 'Generate attributes for this dialect'
HE3FD9C3103CA: '为此方言生成属性'
# 'Generate bitsplit instructions'
HE0B4AD43ABB0: '生成位分割指令'
# 'Generate branches with extended addressability, usually via indirect jumps.'
H84AA69F9BF2B: '通过间接跳转生成具有扩展寻址能力的分支'
# 'Generate calls to instrument function entry and exit'
HFC18B10AD85D: '生成用于检测函数入口和出口的调用'
# 'Generate clang PCH attribute reader'
HACB0FB3DEE14: '生成clang PCH 属性读取器'
# 'Generate clang PCH attribute writer'
H0829BFECBA6A: '生成clang PCH 属性写入器'
# 'Generate clang attribute clases'
HCAA1C36C6E17: '生成clang属性类'
# 'Generate clang attribute implementations'
H58D8D7EF6BF7: '生成clang属性实现'
# 'Generate clang attribute text node dumper'
H7B79A1565130: '生成clang属性文本节点转储器'
# 'Generate clang attribute traverser'
H82452D8DFFBB: '生成clang属性遍历器'
# 'Generate clang builtins list'
H7DD3DD5CD09E: '生成clang内建函数列表'
# 'Generate code for CUDA device'
H28657BCC831E: '为CUDA设备生成代码'
# 'Generate code for SYCL device.'
HFDECAC3EE76F: '为SYCL设备生成代码'
# 'Generate code for an additional runtime variant of the deployment target'
HC009196F06DE: '为目标部署环境生成额外的运行时变体代码'
# 'Generate code for statically linking libclosure (BlocksRuntime)'
H655EBC8C95D8: '为静态链接libclosure（BlocksRuntime）生成代码'
# 'Generate code for the given target'
H978948BBCF74: '为指定的目标生成代码'
# 'Generate code for uses of this PCH that assumes an explicit object file will be built for the PCH'
H73D5D7524BBC: '为假设将为此PCH显式生成目标文件的该PCH的使用生成代码'
# 'Generate code for uses of this module that assumes an explicit object file will be built for the module'
H0A914343419E: '为假设将为此模块显式生成目标文件的该模块的使用生成代码'
# 'Generate code only for an OpenMP target device.'
H22275002B232: '仅为目标设备生成OpenMP目标代码'
# 'Generate code which only uses the general purpose registers (AArch64/x86 only)'
HE13BDFDB4618: '生成仅使用通用寄存器（AArch64/x86专属）的代码'
# 'Generate command properties for commands that are used in documentation comments'
HDF34DF8FD98C: '为文档注释中使用的命令生成命令属性'
# 'Generate coverage instrumentation for GlobalISel'
H98DAD8E8562B: '为GlobalISel生成覆盖测试工具'
# 'Generate coverage mapping to enable code coverage analysis'
H3FA8EAFBA329: '生成用于代码覆盖分析的覆盖映射'
# 'Generate data collectors for AST nodes'
HB676E426CC9E: '生成AST节点的数据收集器'
# 'Generate debug info for types in an object file built from this PCH and do not generate them elsewhere'
H2C592F95A21D: '为从该PCH生成的目标文件中的类型生成调试信息，并不在其他地方生成它们'
# 'Generate debug info for types in an object file built from this module and do not generate them elsewhere'
HE7EB6B773956: '为从该模块生成的目标文件中的类型生成调试信息，并不在其他地方生成它们'
# 'Generate debug info with external references to clang modules or precompiled headers'
HAD4093E5621B: '生成带有对 clang 模块或预编译头的外部引用的调试信息'
# 'Generate debugging info in the 64-bit DWARF format'
H70C04792FFA2: '以 64 位DWARF格式生成调试信息'
# 'Generate declarations for Offload API implementation functions'
H36074FE5A628: '生成Offload API实现函数的声明'
# 'Generate definitions of Clang Syntax Tree node clasess'
H83004344D792: '生成Clang语法树节点类的定义'
# 'Generate diagnostic documentation'
H376A46B39692: '生成诊断文档'
# 'Generate directives for this dialect'
HF8CA4ECC7825: '为此方言生成指令'
# 'Generate dot files into specified directory for changed IRs'
HD4CB202E81D5: '将更改后的中间表示（IR）的dot文件生成到指定目录'
# 'Generate dwarf aranges'
H6F048344D108: '生成DWARF aranges'
# 'Generate dwarf debugging info for assembly source files'
H5645E7139B8A: '为汇编源文件生成DWARF调试信息'
# 'Generate efficient matchers for HTML tag names that are used in documentation comments'
H20BDF8097FEE: '为用在文档注释中的HTML标签名称生成高效匹配器'
# 'Generate efficient matchers for HTML tag properties'
H7F720B1F0148: '为HTML标签属性生成高效匹配器'
# 'Generate explicit import from anonymous namespace to containing scope'
HAFE44C2C60BD: '从匿名命名空间显式导入到包含的作用域'
# 'Generate export file for the Offload library'
H1A8F89282970: '为Offload库生成导出文件'
# 'Generate extract instructions'
HABD4DCD38172: '生成提取指令'
# 'Generate function to translate named character references to UTF-8 sequences'
H2212027837CC: '生成将命名字符引用转换为UTF-8序列的函数'
# 'Generate hot text symbols. Apply this option to a precompiled binary that manually calls into hugify, such that at runtime hugify call will put hot code into 2M pages. This requires relocation.'
HE07FCEA6613B: '为预编译二进制文件生成热代码符号。需要手动调用hugify时使用此选项，这样在运行时hugify调用会将热代码放入 2M页面。此操作需要重定位支持。'
# 'Generate instrumented code to collect context sensitive execution counts into <directory>/default.profraw (overridden by LLVM_PROFILE_FILE env var)'
H10A2DF54F49A: '生成收集上下文敏感的执行计数的工具化代码，结果保存到 <directory>/default.profraw（可被LLVM_PROFILE_FILE环境变量覆盖）'
# 'Generate instrumented code to collect context sensitive execution counts into default.profraw (overridden by LLVM_PROFILE_FILE env var)'
HCBAB6F9C9B4D: '生成收集上下文敏感的执行计数的工具化代码，结果保存到default.profraw（可被LLVM_PROFILE_FILE环境变量覆盖）'
# 'Generate instrumented code to collect coverage info for cold functions into <directory>/default.profraw (overridden by LLVM_PROFILE_FILE env var)'
H389023BECF0C: '生成收集冷函数覆盖信息的工具化代码，结果保存到 <directory>/default.profraw（可被LLVM_PROFILE_FILE环境变量覆盖）'
# "Generate instrumented code to collect coverage info for cold functions into default.profraw file (overridden by '=' form of option or LLVM_PROFILE_FILE env var)"
H40F8D1777D6C: '生成收集冷函数覆盖信息的工具化代码，结果保存到default.profraw文件（可被等号形式的选项或LLVM_PROFILE_FILE环境变量覆盖）'
# 'Generate instrumented code to collect execution counts into <directory>/default.profraw (overridden by LLVM_PROFILE_FILE env var)'
H884AE4DB8A23: '生成收集执行计数的工具化代码，结果保存到 <directory>/default.profraw（可被LLVM_PROFILE_FILE环境变量覆盖）'
# 'Generate instrumented code to collect execution counts into <file> (overridden by LLVM_PROFILE_FILE env var)'
HF1CDB71BC3BA: '生成收集执行计数的工具化代码，结果保存到 <file>（可被LLVM_PROFILE_FILE环境变量覆盖）'
# 'Generate instrumented code to collect execution counts into default.profraw (overridden by LLVM_PROFILE_FILE env var)'
HEDA64E6D9E58: '生成收集执行计数的工具化代码，结果保存到default.profraw（可被LLVM_PROFILE_FILE环境变量覆盖）'
# "Generate instrumented code to collect execution counts into default.profraw file (overridden by '=' form of option or LLVM_PROFILE_FILE env var)"
HCED0768BDFD7: '生成收集执行计数的工具化代码，结果保存到default.profraw文件（可被等号形式的选项或LLVM_PROFILE_FILE环境变量覆盖）'
# 'Generate instrumented code to collect temporal information'
H454449192474: '生成收集时间信息的工具化代码'
# 'Generate intrinsics with this target prefix'
H5CEC7C3808CA: '使用此目标前缀生成内建函数'
# 'Generate invalid output'
H668CF0E474FA: '生成无效输出'
# 'Generate list of Clang Syntax Tree node types'
H3A9E31163210: '生成Clang语法树节点类型的列表'
# 'Generate list of commands that are used in documentation comments'
H55166381B0A4: '生成文档注释中使用的命令列表'
# 'Generate list of valid ARM CDE builtin aliases for clang'
H1E92420752F1: '生成clang有效的ARM CDE内建别名列表'
# 'Generate list of valid ARM MVE builtin aliases for clang'
H18CC5313A2F6: '生成clang有效的ARM MVE内建别名列表'
# 'Generate lldb option definitions'
HF07E69C59A11: '生成lldb选项定义'
# 'Generate lldb property definitions'
HBD76019A4518: '生成lldb属性定义'
# 'Generate lldb property enum definitions'
H4D3EB8680DC4: '生成lldb属性枚举定义'
# 'Generate local calls to out-of-line atomic operations'
H160B36160D89: '生成对非内联原子操作的本地调用'
# 'Generate loop nest for tiling.'
H40BB5343F902: '为平铺生成循环嵌套'
# 'Generate low-precision inline sequences for some float libcalls'
HA2542185A00F: '为部分浮点库调用生成低精度内联序列'
# 'Generate machine code, but discard output'
HA74064264324: '生成机器码，但丢弃输出结果'
# 'Generate mcount/__fentry__ calls as nops. To activate they need to be patched in.'
HE3A927985452: '将mcount/__fentry__调用生成为空操作（nop）。要激活它们需要进行补丁修复'
# 'Generate nested function profiles for CSSPGO'
H267DA13728E4: '为CSSPGO生成嵌套函数配置文件'
# 'Generate option documentation'
HF1C9A7ED3825: '生成选项文档'
# 'Generate output compatible with the standard GNU Objective-C runtime'
H0A3E1D413F6F: '生成与标准GNU Objective-C运行时兼容的输出'
# 'Generate pre-compiled header file'
H6076A415050D: '生成预编译头文件'
# 'Generate pre-compiled module file from a module map'
H32E4ACE09217: '从模块映射文件生成预编译模块文件'
# 'Generate pre-compiled module file from a standard C++ module interface unit'
H332BF5CFA1C0: '从标准C++模块接口单元生成预编译模块文件'
# 'Generate random hotness values'
H5B6B1D07D43D: '生成随机热点值'
# 'Generate read-only position independent code (ARM only)'
H8619C4BF8421: '生成只读位置无关代码（仅限ARM）'
# 'Generate read-write position independent code (ARM only)'
H49DE9A8DC6D7: '生成读写位置无关代码（仅限ARM）'
# 'Generate reduced prebuilt module interface from a standard C++ module interface unit'
HBCD3850127B9: '从标准C++模块接口单元生成精简的预构建模块接口'
# 'Generate relocatable device code, also known as separate compilation mode'
H2AB415613F7B: '生成可重定位设备代码，也称为单独编译模式'
# 'Generate riscv_andes_vector_builtin_cg.inc for clang'
H99B584F39405: '生成clang的riscv_andes_vector_builtin_cg.inc'
# 'Generate riscv_andes_vector_builtin_sema.inc for clang'
HBB62F00F6C63: '生成clang的riscv_andes_vector_builtin_sema.inc'
# 'Generate riscv_andes_vector_builtins.inc for clang'
H01F7AE9F3E5F: '生成clang的riscv_andes_vector_builtins.inc'
# 'Generate riscv_sifive_vector_builtin_cg.inc for clang'
H2F882B6DED2D: '为clang生成riscv_sifive_vector_builtin_cg.inc'
# 'Generate riscv_sifive_vector_builtin_sema.inc for clang'
HD872420A09E4: '为clang生成riscv_sifive_vector_builtin_sema.inc'
# 'Generate riscv_sifive_vector_builtins.inc for clang'
HD182FA023D72: '为clang生成riscv_sifive_vector_builtins.inc'
# 'Generate riscv_vector.h for clang'
HECE8F71BFB56: '为clang生成riscv_vector.h'
# 'Generate riscv_vector_builtin_cg.inc for clang'
H5A79CE9F1F74: '为clang生成riscv_vector_builtin_cg.inc'
# 'Generate riscv_vector_builtin_sema.inc for clang'
HA3230378A26C: '为clang生成riscv_vector_builtin_sema.inc'
# 'Generate riscv_vector_builtins.inc for clang'
H5D02D25DD210: '为clang生成riscv_vector_builtins.inc'
# 'Generate same-address load-load barrier instructions (dbar 0x700)'
HA12298FF2D2D: '生成相同地址加载-加载屏障指令（dbar 0x700）'
# 'Generate software floating point library calls'
H05167BC54E72: '生成软件浮点库调用'
# 'Generate source-level debug information'
HAEF3BF8D74CD: '生成源级调试信息'
# 'Generate source-level debug information with dwarf version 2'
HD2B80CB88FC9: '使用DWARF版本 2 生成源级调试信息'
# 'Generate source-level debug information with dwarf version 3'
HA4075062488F: '使用DWARF版本 3 生成源级调试信息'
# 'Generate source-level debug information with dwarf version 4'
H248AE385BE0D: '使用DWARF版本 4 生成源级调试信息'
# 'Generate source-level debug information with dwarf version 5'
HE4BA3B14D0D7: '使用DWARF版本 5 生成源级调试信息'
# 'Generate source-level debug information with the default dwarf version'
H938AF5B9960A: '使用默认DWARF版本生成源级调试信息'
# 'Generate the clang parsed attribute helpers'
HFA9E86870CB2: '生成clang解析属性的辅助函数'
# 'Generate the profile for Linux kernel binary.'
HB596668CB82B: '为Linux内核二进制文件生成配置文件'
# 'Generate the reduced BMI'
HED698C3C66EE: '生成精简的BMI'
# 'Generate thread parallel code (isl codegen only)'
H34625E399986: '生成线程并行代码（仅isl代码生成器支持）'
# 'Generate types for this dialect'
H62C541A61A79: '为此方言生成类型'
# 'Generate unique debug info for each instruction with a memory operand. Should be enabled for profile-driven cache prefetching, both in the build of the binary being profiled, as well as in the build of the binary consuming the profile.'
H337DAB1315D8: '为带有内存操作数的每个指令生成唯一的调试信息。启用此选项后，在被分析的二进制构建和使用该分析结果的二进制构建中，都需开启该选项以支持基于配置文件的缓存预取。'
# 'Generate unoptimized CFGs for all analyses'
HA85B8A701BAB: '为所有分析生成未经优化的控制流图（CFG）'
# 'Generate unwinding tables for all functions'
HF1490D883AAC: '为所有函数生成解包表'
# 'Generate verbose assembly output'
H0B7F9E41E63B: '生成详细的汇编输出'
# 'Generated inlined abstract references.'
H21A52BEF39EC: '生成内联抽象引用。'
# 'Generates tables to help identify patterns matched'
HD3439779FA7F: '生成帮助识别匹配模式的表格'
# 'Generator to run'
H9B18D7EC4146: '要运行的代码生成器'
# 'Generic Options'
H5EEF255AAE70: '通用选项'
# 'Generic memory optimizations'
H800F1622EB9A: '通用内存优化'
# 'Get the symbol definition from <line> <start-column> <end-column>'
H9C96E5C80114: '从第 <line> 行的 <start-column> 到 <end-column> 列获取符号定义'
# 'Give each function an independent TBAA tree (default)'
H7A952E99A7FC: '为每个函数分配独立的TBAA树（默认）'
# 'Give global C++ operator new and delete declarations hidden visibility'
HAD504B33021E: '为全局C++的operator new和delete声明赋予隐藏可见性'
# "Give global types 'default' visibility and global functions and variables 'hidden' visibility by default"
H095BFBCE25DF: '默认情况下，全局类型采用 "default" 可见性，全局函数和变量采用 "hidden" 可见性'
# 'Give inline C++ member functions hidden visibility by default'
HAF1CF839FC8A: '默认为内联C++成员函数赋予隐藏可见性'
# 'Give the maximum number of instructions that we will use for creating a floating-point immediate value'
HB7780EA795D5: '指定用于创建浮点立即数值的最大指令数量'
# 'Give the maximum size (in number of nodes) of the web of instructions that we will consider for VW expansion'
H6AD97D209EFA: '指定在考虑VW扩展时我们将处理的指令网络的最大大小（以节点数量计）'
# 'Give unique names to every basic block section'
HE9E6E34AE2B8: '为每个基本块段分配唯一名称'
# 'Give unique names to every section'
HAE1CB86AEAE6: '为每个段分配唯一名称'
# 'Global Pointer Addressing Size.  The default size is 8.'
H7DA66DD4C059: '全局指针寻址大小。默认值为 8。'
# 'Global Value Numbering'
H7BB46D78F883: '全局值编号'
# 'Global merge function pass'
H22AF90C7A55F: '全局合并函数pass'
# 'GlobalISel Combiner'
H204136E4EB5C: 'GlobalISel 组合器'
# 'Globally set the denormals-are-zero (DAZ) and flush-to-zero (FTZ) bits in the floating-point control register on program startup'
H3BA6F3373251: '在程序启动时，全局设置浮点控制寄存器中的denormals-are-zero（DAZ）和flush-to-zero（FTZ）标志位'
# 'Globals Alias Analysis'
H9A682873774C: '全局变量别名分析'
# 'Good Bye World Pass'
H6716A126CB42: '再见世界 Pass'
# 'Gradient gain threshold (%).'
H28D3EF05A6AB: '梯度增益阈值 (%)'
# 'Greedy Register Allocator'
HB8463656EACF: '贪婪寄存器分配器'
# 'Greedy register allocator'
HE2214CA75FBC: '贪婪寄存器分配器'
# 'Guard UBSAN checks with `llvm.allow.ubsan.check()`.'
H368DFFFB3230: '用`llvm.allow.ubsan.check()`保护UBSAN检查。'
# 'Guard against compiler/runtime version mismatch.'
HA3897596A344: '防范编译器/运行时版本不匹配。'
# 'Guided scheduling'
H4B9648519786: '引导调度'
# 'HIP Standard Parallel Algorithm Acceleration library path, used for finding and implicitly including the library header'
H8403B00ECFB8: 'HIP标准并行算法加速库路径，用于查找并隐式包含库头文件'
# 'HIP device library'
H14BC304940A6: 'HIP设备库'
# 'HIP does not support OpenMP target directives; directive has been ignored'
H0DF90C6E349C: 'HIP 不支持OpenMP目标指令；该指令已被忽略'
# 'HIP runtime installation path, used for finding HIP version and adding HIP include path.'
HD2A8F00A760F: 'HIP运行时安装路径，用于查找HIP版本并添加HIP包含路径'
# 'HIP version in the format of major.minor.patch'
H4C1B608415FC: 'HIP版本格式为major.minor.patch'
# 'HLSL Version'
HB3FA8D10C87C: 'HLSL版本'
# "HLSL code generation is unsupported for target '%0'"
HE92A9C826849: "不支持为目标 '%0' 生成HLSL代码"
# 'HLSL only. Disables all standard includes containing non-native compiler types and functions.'
H1F13E0FA5ECA: '仅HLSL。禁用包含非本机编译器类型和函数的所有标准包含文件'
# 'HLSL resource needs to have [[hlsl::resource_class()]] attribute'
HAC100FF02618: 'HLSL资源需要具有[[hlsl::resource_class()]]属性'
# "HTML end tag '%0' is forbidden"
H685A0F5F60EA: "HTML结束标签 '%0' 是被禁止的"
# 'HTML end tag does not match any start tag'
H04F1BAAABD62: 'HTML结束标签与任何开始标签不匹配'
# 'HTML output'
H9222F90CA7BE: 'HTML 输出'
# "HTML start tag '%0' closed by '%1'"
H5D28040DFF0A: "HTML开始标签 '%0' 被 '%1' 关闭"
# "HTML start tag prematurely ended, expected attribute name or '>'"
HB396911AC86C: "HTML开始标签提前结束，期望属性名或 '>'"
# "HTML tag '%0' requires an end tag"
HC3A525011E51: "HTML标签 '%0' 需要结束标签"
# 'HTML tag started here'
H3CB5C9051AF3: 'HTML标签从这里开始'
# 'HWASan shadow mapping dynamic offset location'
H0D34082EDF7B: 'HWASan阴影映射动态偏移位置'
# 'HWASan shadow mapping offset [EXPERIMENTAL]'
H2991A813E596: 'HWASan阴影映射偏移 [实验性]'
# 'Handle <= and >= in finite loops'
H5AA1FAB9586D: '处理有限循环中的<=和>=运算'
# 'Handle C++ exceptions (insert cleanup blocks for unwinding)'
H250354C717B0: '处理C++异常（为展开插入清理块）'
# 'Handle C++ initializer order'
HC63CC32922AA: '处理C++初始化顺序'
# 'Handle global objects'
H5D8738E4497F: '处理全局对象'
# 'Handle stack memory'
H9B9B06338F2E: '处理堆栈内存'
# 'Hard float ABI (uses FP registers)'
HEEAB4CE3F0BA: '硬浮点ABI（使用浮点寄存器）'
# 'Hard-coded mapping'
H6EC79E37D2B2: '硬编码映射'
# 'Harden indirect calls and jumps against using speculatively stored attacker controlled addresses. This is designed to mitigate Spectre v1.2 style attacks.'
H64FF4BC73D36: '通过传递函数高字节中的状态进行过程间强化，以缓解Spectre v1.2类型的攻击。'
# 'Harden inline assembly code that may be vulnerable to Load Value Injection (LVI). This feature is experimental.'
H9EF1510D3F11: '为可能存在负载值注入（LVI）漏洞的内联汇编代码提供防护。此功能处于实验阶段。'
# 'Harden interprocedurally by passing our state in and out of functions in the high bits of the stack pointer.'
HD67DA497275B: '通过在函数调用时将状态存储在栈指针高位字节中，实现过程间强化，以缓解推测性存储攻击。该设计旨在抵御Spectre v1.2类型的攻击。'
# 'Harden the value loaded *after* it is loaded by flushing the loaded bits to 1. This is hard to do in general but can be done easily for GPRs.'
HC7A0E024F604: '在加载后通过将加载的位刷新为 1 来强化该值。一般来说这很难实现，但对于通用寄存器（GPRs）来说很容易做到。'
# 'Hardware Loop Insertion'
HD9C10B054698: '硬件循环插入'
# 'Hardware multiplier use mode for MSP430'
HE8A05395F9BD: 'MSP430硬件乘法器使用模式'
# 'Hash long pathnames'
H2984D386D5E0: '哈希长路径名'
# 'Hazard size for streaming mode memory accesses. 0 = disabled.'
H4C73818D60FE: '流模式内存访问的潜在冲突大小。0=禁用。'
# 'Heatmap options'
H6D36D04383CD: '热图选项'
# 'Helps find bugs by verifying the IR whenever we emit new instructions (*very* expensive).'
H92F16AA997F0: '通过每次生成新指令时验证中间表示（IR）来帮助查找错误（*非常*消耗资源）。'
# 'Heuristics-based inliner version'
H91CCDBD88F85: '基于启发式的内联版本'
# 'Hexagon Assembly Printer'
H04AB1ED5271E: 'Hexagon汇编打印机'
# 'Hexagon Branch Relaxation'
HE56E26D71726: 'Hexagon分支松弛'
# 'Hexagon CFG Optimizer'
HADEAF8F4224F: 'Hexagon CFG 优化器'
# 'Hexagon Common GEP'
H7416FD0F0215: 'Hexagon 公共GEP优化'
# 'Hexagon Constant Propagation'
H4545D96F56E6: 'Hexagon 常量传播'
# 'Hexagon Copy-To-Combine Pass'
HA9D6C5272766: 'Hexagon 复制合并Pass'
# 'Hexagon DAG->DAG Pattern Instruction Selection'
H8C61F3028012: 'Hexagon DAG->DAG 模式指令选择'
# 'Hexagon Expand Condsets'
H77C9EE5ECE10: 'Hexagon 展开Condsets'
# 'Hexagon Generate Load/Store Set Absolute Address Instruction'
HDCC2529025E3: 'Hexagon 生成绝对地址加载/存储指令'
# 'Hexagon Hardware Loops'
H430E0FA91788: 'Hexagon 硬件循环'
# 'Hexagon Hardware Loops Fixup'
HEBB89CCF449D: 'Hexagon 硬件循环修复'
# 'Hexagon Load Widening'
H629EAC297715: 'Hexagon 加载扩展'
# 'Hexagon Loop Rescheduling'
H9B5F9E54FF64: 'Hexagon 循环重调度'
# 'Hexagon LoopAlign pass'
H079823890488: 'Hexagon 循环对齐Pass'
# 'Hexagon NewValueJump'
HD050A64FD350: 'Hexagon NewValueJump优化'
# 'Hexagon Packetizer'
HD80045280EC2: 'Hexagon 数据包生成器'
# 'Hexagon Peephole'
H96F1818D0A76: 'Hexagon 窥孔优化'
# 'Hexagon RDF optimizations'
H0E48883DC0AC: 'Hexagon RDF优化'
# 'Hexagon Split Const32s and Const64s'
HE37A260C9D82: 'Hexagon 拆分Const32和Const64常量'
# 'Hexagon Split Double Registers'
H6CA85CE5559C: 'Hexagon 拆分双寄存器'
# 'Hexagon Store Widening'
H23CE261CD27B: 'Hexagon 存储扩展'
# 'Hexagon TFR Cleanup'
H6ECA189DB2DB: 'Hexagon TFR 清理'
# 'Hexagon Vector Combine'
H9F8DB4B385EA: 'Hexagon向量合并'
# 'Hexagon VectorPrint pass'
H540A5ECB5448: 'Hexagon 向量打印Pass'
# 'Hexagon bit simplification'
HF73F7F5D57C5: 'Hexagon 位简化优化'
# 'Hexagon call frame information'
H93CA35321D07: 'Hexagon 调用帧信息'
# 'Hexagon constant-extender optimization'
H1C0F5065601C: 'Hexagon 常量扩展优化'
# 'Hexagon early if conversion'
H5C9514E28A85: 'Hexagon 早期if转换'
# 'Hexagon generate "extract" instructions'
H7636CC8F55F3: '生成Hexagon "extract" 指令'
# 'Hexagon generate "insert" instructions'
H3778EAC02853: 'Hexagon生成 "insert" 指令'
# 'Hexagon generate mux instructions'
H5C45CA2F85F2: 'Hexagon 生成多路选择指令'
# 'Hexagon generate predicate operations'
H40F613387EB4: 'Hexagon生成谓词操作'
# 'Hexagon mask'
HEEBCEB3469AC: 'Hexagon 掩码'
# 'Hexagon move phi copy'
HDCDB2AA0AED1: 'Hexagon 移动phi复制'
# 'Hexagon optimize vextract'
H278043636EF5: 'Hexagon 优化vextract指令'
# 'Hexagon-specific predictive commoning for HVX vectors'
H536F10F1AEBD: '针对HVX向量的Hexagon专用预测性公共优化'
# 'Hide blocks with relative frequency below the given value'
H3675151E5C00: '隐藏相对频率低于给定值的块'
# 'Hide nodes with more predecessor/successor than cutoff'
HBFFDABE2C9B6: '隐藏前驱/后继节点数量超过阈值的节点'
# 'High level execution tracing'
HEC0DB93568EB: '高级执行跟踪'
# 'High level qualifier for z/OS C++RT side deck datasets'
HAA6C6806CE9D: 'z/OS C++RT侧边数据集的高层限定符'
# 'High level qualifier for z/OS CSSLIB dataset'
H3CB003A4AC08: 'z/OS CSSLIB数据集的高层限定符'
# 'High level qualifier for z/OS Language Environment datasets'
HF68A673FB7E5: 'z/OS语言环境数据集的高层限定符'
# 'High register pressure threhold.'
H72FE4FE03B96: '高寄存器压力阈值。'
# 'Highlight the code regions that will be optimized in a (CFG BBs and LLVM-IR instructions)'
H011F5431A825: '突出显示将在其中优化的代码区域（包括控制流图（CFG）块和LLVM-IR指令）'
# 'Highlight the code regions that will be optimized in a (CFG only BBs)'
H8868F2ACA588: '突出显示将在其中优化的代码区域（仅控制流图（CFG）块）'
# 'Hoist common instructions up to the parent block'
H626E78174BD3: '将公共指令提升到父块'
# 'Hoist conditional stores even if an unconditional store does not precede - hoist multiple conditional stores into a single predicated store'
HAF676B43A7DA: '即使没有无条件存储指令在前，也提升条件存储指令——将多个条件存储提升为单个条件存储指令'
# 'Hoist conditional stores if an unconditional store precedes'
H051D0419768A: '如果存在无条件存储指令在前，则提升条件存储指令'
# 'Hoist inner loop runtime memory checks to outer loop if possible'
H1896B47EDC00: '如果可能，将内层循环的运行时内存检查提升到外层循环'
# 'Hoist instructions from the beginning of the BB up to the maximum specified depth (default = 100, unlimited = -1)'
H19FF88ADEF86: '从基本块（BB）的开头提升指令，最多提升到指定的深度（默认值=100，无限制=-1）'
# 'Hoist invariant loads'
H04F2E5FA708B: '提升不变量加载指令。'
# 'Hoist invariant loads.'
HFD3073FAF6A0: '提升不变量加载指令。'
# 'Hoist invariant stores'
H37B16BDD134A: '提升不变量存储指令'
# 'Hoist loads if the target supports conditional faulting'
HFE6E57FFE11D: '如果目标支持条件异常，则提升加载操作'
# 'Hoist loads/stores if the target supports conditional faulting (default = false)'
H360599A9B4F2: '如果目标支持条件异常，则提升加载/存储（默认 = false）'
# 'Hoist stores if the target supports conditional faulting'
HD60C7781C619: '如果目标支持条件异常，则提升存储操作'
# 'Hoisting alloca instructions in non-entry blocks to the entry block'
H1611B6B7938C: '将非入口块中的alloca指令提升至入口块'
# 'Hot callsite threshold for proirity-based sample profile loader inlining.'
HF203067F3822: '基于优先级的样本配置文件加载器内联的热点调用点阈值'
# 'Hot percentile cutoff.'
HCEE9FC61C4DD: '热点百分位数截止值'
# 'How cgscc inline replay file is formatted'
HD50D41502699: 'cgscc内联重放文件的格式'
# "How cgscc inline replay treats sites that don't come from the replay. Original: defers to original advisor, AlwaysInline: inline all sites not in replay, NeverInline: inline no sites not in replay"
H6F8523C009E8: 'cgscc内联重放如何处理来自重放的调用点以外的站点。Original：遵循原始建议器，AlwaysInline：内联所有不在重放中的站点，NeverInline：不内联任何不在重放中的站点'
# "How many functions in a module could be used for MergeFunctions to pass a basic correctness check. '0' disables this check. Works only with '-debug' key."
H65C2FF1A291C: "在模块中可用于MergeFunctions通过基本正确性检查的函数数量。'0' 禁用此检查。仅与 '-debug' 键一起使用"
# 'How many idle instructions we would like before certain undef register reads'
HAF5EEC679340: '在某些未定义寄存器读取之前希望有多少空闲指令'
# 'How many kernel arguments to preload onto SGPRs'
H2C2BF298A146: '预加载到SGPRs中的内核参数数量'
# 'How many lifetime ends to handle for a single alloca.'
H1A9776E5D001: '单个alloca处理的生命周期结束数量'
# 'How much code-generation to perform'
HB6C2FA93092D: '要执行的代码生成量'
# 'How sample profile inline replay file is formatted'
H7CB1B737EC5A: '样本配置文件内联重放文件的格式'
# "How sample profile inline replay treats sites that don't come from the replay. Original: defers to original advisor, AlwaysInline: inline all sites not in replay, NeverInline: inline no sites not in replay"
H023EFDA855FF: '样本配置文件内联重放如何处理来自重放的调用点以外的站点。Original：遵循原始建议器，AlwaysInline：内联所有不在重放中的站点，NeverInline：不内联任何不在重放中的站点'
# 'How to aggregate multi-values result'
HE0FCAEDB7A77: '如何聚合多值结果'
# 'How wide an instruction window to bypass looking for another guard'
H190528E1E0D0: '要绕过查找其他保护的指令窗口的宽度'
# 'HowToUseLLJIT'
H56EB31810445: '如何使用LLJIT'
# 'Human readable output. Only valid without -all-stacks.'
H1D2D4ECF9DBD: '可读性输出。仅在不使用 -all-stacks 时有效。'
# 'Human-readable format'
H5B717FB38D2F: '可读性格式'
# 'IBM MASS vector library'
HC5A8A1BFD3A5: 'IBM MASS 向量库'
# 'IBOutletCollection properties should be copy/strong and not assign'
H91B04B0AEDF0: 'IBOutletCollection属性应使用copy/strong而非assign'
# 'IEEE 754 denormal numbers'
HB645808304FA: 'IEEE 754 非正规数'
# 'IR2Vec Options'
H353091CB276E: 'IR2Vec 选项'
# 'IRDL file to register before processing the input'
H9ADEB68395C9: '在处理输入前需要注册的IRDL文件'
# 'IRTranslator LLVM IR -> MI'
HA8BDC735DCBC: 'IRTranslator LLVM IR -> 机器指令'
# 'ISO C does not allow indirection on operand of type %0'
HC4C25916B558: 'ISO C不允许对类型 %0 的操作数进行间接访问'
# "ISO C does not support '~' for complex conjugation of %0"
H592FB210723A: "ISO C不支持使用 '~' 对 %0 进行复数共轭"
# "ISO C forbids forward references to 'enum' types"
H3A2E43246AF1: "ISO C禁止向前引用 'enum' 类型"
# "ISO C forbids taking the address of an expression of type 'void'"
H5DC6DC421D10: "ISO C不允许为类型 'void' 的表达式取地址"
# "ISO C requires a named parameter before '...'"
HAAD7320B82D0: 'ISO C要求在 "..." 之前有一个命名参数'
# 'ISO C requires a translation unit to contain at least one declaration'
HD453AE5DFC44: 'ISO C要求翻译单元中至少包含一个声明'
# 'ISO C++ considers this destructor name lookup to be ambiguous'
H51664244F36F: 'ISO C++认为此析构函数名查找存在歧义'
# 'ISO C++ does not allow %select{an attribute list|%0}1 to appear here'
H6EEF885F4392: 'ISO C++不允许在此处出现%select{属性列表|%0}1'
# 'ISO C++ does not allow %select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2 because it casts away qualifiers, even though the source and destination types are unrelated'
HA24736A782D5: 'ISO C++不允许在此处使用 %select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 从 %1 到 %2 进行转换，因为该转换会丢弃限定符，即使源类型和目标类型无关'
# "ISO C++ does not permit the 'bool' keyword after 'concept'"
HED15AAEA01CD: "ISO C++禁止在 'concept' 之后使用 'bool' 关键字"
# "ISO C++ forbids forward references to 'enum' types"
H565E6A76B7E7: "ISO C++禁止向前引用 'enum' 类型"
# "ISO C++ only allows ':' in member enumeration declaration to introduce a fixed underlying type, not an anonymous bit-field"
HD765E30339DE: "ISO C++仅允许在成员枚举声明中使用 ':' 来引入固定的基础类型，而不是匿名位字段"
# 'ISO C++ requires a definition in this translation unit for %select{function|variable}0 %q1 because its type does not have linkage'
HCF564C1243BB: 'ISO C++要求为%select{函数|变量}0 %q1在当前翻译单元中提供定义，因为其类型没有链接性'
# 'ISO C++ requires field designators to be specified in declaration order; field %1 will be initialized after field %0'
HF7272CADD93F: 'ISO C++ 要求字段设计符按声明顺序指定；字段 %1 将在字段 %0 之后初始化'
# "ISO C++ requires the name after '::~' to be found in the same scope as the name before '::~'"
H1B12535D9EA0: "ISO C++ 要求 '::~' 之后的名称与 '::~' 之前的名称处于同一作用域"
# "ISO C++ specifies that qualified reference to %0 is a constructor name rather than a %select{template name|type}1 in this context, despite preceding %select{'typename'|'template'}2 keyword"
H0AEAB31369D3: "ISO C++ 规定在此上下文中，对 %0 的限定引用是一个构造函数名称而非%select{模板名称|类型}1，尽管前面有 %select{'typename'|'template'}2 关键字"
# 'ISO C++ standards before C++17 do not allow new expression for type %0 to use list-initialization'
H36A45BAF91C7: 'ISO C++17之前的版本不允许类型 %0 的new表达式使用列表初始化'
# 'ISO C++11 does not allow access declarations; use using declarations instead'
H949947FDD999: 'ISO C++11 不允许使用访问声明；请改用using声明'
# 'ISO C++11 does not allow conversion from string literal to %0'
HDCEA926F7FF8: 'ISO C++11 不允许将字符串字面量转换为 %0'
# 'ISO C++11 requires a parenthesized pack declaration to have a name'
H70DD46DED2FB: 'ISO C++11 要求括号化的打包声明必须具有名称'
# "ISO C++17 does not allow 'register' storage class specifier"
HFBD7E25436E2: 'ISO C++17 不允许使用 "register" 存储类说明符'
# 'ISO C++17 does not allow a decomposition group to be empty'
H38C9A47FB6B4: 'ISO C++17 不允许分解组为空'
# 'ISO C++17 does not allow dynamic exception specifications'
HDA1158B635F1: 'ISO C++17 不允许使用动态异常规格说明'
# 'ISO C++17 does not allow incrementing expression of type bool'
H8CE1E8E6EA54: 'ISO C++17 不允许对bool类型的表达式进行递增操作'
# "ISO C++20 considers use of overloaded operator '%0' (with operand types %1 and %2) to be ambiguous despite there being a unique best viable function%select{ with non-reversed arguments|}3"
HE2B331A9C128: 'ISO C++20 认为此处使用重载的运算符 "%0"（操作数类型为 %1 和 %2）存在歧义，尽管存在一个具有非反转参数的唯一最佳可行函数%select{ |}3'
# "ISO C++20 requires return type of selected 'operator==' function for rewritten '%1' comparison to be 'bool', not %0"
H96DD21560E53: 'ISO C++20 要求重写后的 "%1" 比较所选的 "operator==" 函数的返回类型应为 "bool"，而非 %0'
# 'ISO C90 does not allow subscripting non-lvalue array'
HB75A7925DCA5: 'ISO C90 不允许对非常量左值数组进行下标访问'
# 'ISO C99 requires whitespace after the macro name'
HDC593F4C1475: 'ISO C99 要求宏名称后必须有空白字符'
# 'IT block support'
H110A8754A4BC: 'IT块支持'
# 'Id of alloc to export if -memprof-dot-scope=alloc or to highlight if -memprof-dot-scope=all'
HB6A8CDFE5726: '如果-memprof-dot-scope=alloc则导出的alloc标识，或如果-memprof-dot-scope=all则突出显示的alloc标识'
# 'Id of context to export if -memprof-dot-scope=context or to highlight otherwise'
H0412058D0B19: '如果使用 -memprof-dot-scope=context 则导出该上下文的ID，否则高亮显示'
# "Identifies whether Control Flow Integrity protects all indirect control flow instructions in the provided object file, DSO or binary.\nNote: Anything statically linked into the provided file *must* be compiled with '-g'. This can be relaxed through the '--ignore-dwarf' flag."
H7027E6C59DD5: "确定提供的对象文件、DSO或二进制文件是否通过控制流完整性保护所有间接控制流指令。注意：提供文件中静态链接的任何内容*必须*使用 '-g' 编译。可通过 '--ignore-dwarf' 标志放宽此要求。"
# 'If Converter'
H8621034DF5DA: '条件语句转换器'
# "If ThinLTO and WPD is enabled and this option is true, vtable profiles will be used by ICP pass for more efficient indirect call sequence. If false, type profiles won't be used."
H97A5D327A1D2: '如果启用ThinLTO和WPD，并且此选项为true，则ICP pass将使用虚表剖面来更高效地处理间接调用序列。如果为false，则不会使用类型剖面。'
# 'If a personality routine is marked uninstrumented from the ABI list, do not create a wrapper for it.'
H830E42B2D102: '如果ABI列表中标记了某个personality routine为未被插入探针，则不为其创建包装函数'
# 'If an allocatable left-hand side of an intrinsic assignment is unallocated or its shape/type does not match the right-hand side, then it is automatically (re)allocated'
HFF2E7612E3B3: '如果固有赋值的可分配左操作数未分配，或其形状/类型与右操作数不匹配，则会自动（重新）分配'
# 'If enabled, drop make.implicit metadata in unswitched implicit null checks to save time analyzing if we can keep it.'
H84A812339ADF: '如果启用，则在未展开的隐式空指针检查中删除make.implicit元数据以节省分析是否保留所需的时间'
# 'If enabled, simple loop unswitching will also consider llvm.experimental.guard intrinsics as unswitch candidates.'
H0DECF1F15908: '如果启用，简单循环展开将把llvm.experimental.guard指令视为可展开候选'
# 'If enabled, the freeze instruction will be added to condition of loop unswitch to prevent miscompilation.'
H29F9314FFE86: '如果启用，则在循环展开条件中添加freeze指令以防止编译错误'
# 'If present, forces/disables the use of long calls'
H244BD3DDA186: '如果存在此选项，则强制使用/禁用长调用'
# 'If present, stops packetizing after N instructions'
HC908BB95C55F: '如果存在此选项，则在执行N条指令后停止打包'
# 'If profile count information is used in tail duplication cost model, the gained fall through number from tail duplication should be at least this percent of hot count.'
H4BE057670DD8: '如果在尾部复制成本模型中使用了配置文件计数信息，则尾部复制获得的直接跳转数量至少应为此百分比的热点计数'
# 'If set to true, IRCE may eliminate wide range checks in loops with narrow latch condition.'
HC7CC2CE2097F: '如果设为true，IRCE可能会消除循环中具有窄循环条件的宽范围检查'
# 'If set, and on a color-capable terminal controls whether or not to print diagnostics in color'
H22D7A9441E62: '如果设置此选项，并且在支持颜色的终端上，控制是否以彩色显示诊断信息'
# 'If set, assume that loads and stores do not alias'
H938298BEB1B1: '如果设置此选项，则假设加载和存储操作不会发生别名'
# 'If set, benchmark all sizes from sweep-min-size to sweep-max-size'
H918C41E05E1C: '如果设置此选项，则测试从sweep-min-size到sweep-max-size的所有尺寸'
# 'If set, changes formatting warnings to errors'
HF6B939F6D70E: '如果设置此选项，则将格式化警告转换为错误'
# 'If set, do not actually make the formatting changes'
H11412975A779: '如果设置此选项，则不实际进行格式修改'
# "If set, don't error out on the specified warning type."
H94EED0D743F6: '如果设置此选项，则不对指定的警告类型报错'
# 'If set, fail with exit code 1 on incomplete format.'
H3940587B501D: '如果设置此选项，则在格式不完整时退出并返回代码 1'
# 'If set, overrides the include sorting behavior\ndetermined by the SortIncludes style flag'
HA0F9A020C51D: '如果设置此选项，则覆盖由SortIncludes风格标志确定的包含排序行为'
# 'If set, overrides the qualifier alignment style\ndetermined by the QualifierAlignment style flag'
H7D8374F39C0A: '如果设置此选项，则覆盖由QualifierAlignment风格标志确定的限定符对齐方式'
# 'If set, shows the list of processed files'
HB1247E3D1FC1: '如果设置此选项，则显示已处理的文件列表'
# 'If set, unknown format options are only warned about.\nThis can be used to enable formatting, even if the\nconfiguration contains unknown (newer) options.\nUse with caution, as this might lead to dramatically\ndiffering format depending on an option being\nsupported or not.'
HB78C3D57EF8C: '若启用此选项，未知格式选项仅会触发警告。\n可用于即使配置包含未知（较新）选项时仍启用格式化。\n谨慎使用，因为这可能导致格式因选项是否被支持而产生显著差异。'
# 'If specified, IR printed using the -print-[before|after]{-all} options will be dumped into files in this directory rather than written to stderr'
HC6C4D32713B0: '如果指定，使用 -print-[before|after]{-all} 选项输出的IR将导出到该目录中的文件，而非写入stderr'
# 'If stats should be appended to stats-file instead of overwriting it'
H7B41C07F5D40: '如果需要将统计信息追加到stats-file而不是覆盖它'
# 'If the function being instrumented contains more than this number of memory accesses, use callbacks instead of inline checks (-1 means never use callbacks).'
HD30970E83223: '如果被插桩的函数包含超过该数量的内存访问，则使用回调函数而非内联检查（-1表示从不使用回调函数）'
# 'If the function being instrumented requires more than this number of checks and origin stores, use callbacks instead of inline checks (-1 means never use callbacks).'
H5B3AA5D69CF8: '如果被插桩的函数需要超过该数量的检查和原存储位置，则使用回调函数而非内联检查（-1表示从不使用回调函数）'
# 'If the function being instrumented requires more than this number of origin stores, use callbacks instead of inline checks (-1 means never use callbacks).'
H3A18D04548FF: '如果被插桩的函数需要超过该数量的原存储位置，则使用回调函数而非内联检查（-1表示从不使用回调函数）'
# 'If the profile density is below the given threshold, it will be suggested to increase the sampling rate.'
HDF4D3E04985A: '如果配置文件密度低于给定阈值，则建议提高采样率'
# 'If the runtime tripcount for the loop is lower than the threshold, the loop is considered as flat and will be less aggressively unrolled.'
HAC4BCB57FDE7: '如果循环的运行时迭代次数低于阈值，则认为该循环为平坦循环，并减少其展开的激进程度'
# 'If the sample profile is accurate, we will mark all un-sampled branches and calls as having 0 samples. Otherwise, treat them conservatively as unknown. '
H815D8C5F471D: '如果采样配置文件准确，则将所有未采样的分支和调用标记为 0 样本。否则，将其保守处理为未知'
# 'If the sample profile is accurate, we will mark all un-sampled callsite and function as having 0 samples. Otherwise, treat un-sampled callsites and functions conservatively as unknown. '
H196C3B85DE70: '如果采样配置文件准确，则将所有未采样的调用点和函数标记为 0 样本。否则，将未采样的调用点和函数保守处理为未知'
# "If the size of a function is smaller than the threshold, assume it can be inlined by PGO early inliner and it won't be adjusted based on sample profile."
HE6D98DD47634: '如果函数大小小于阈值，则假设其可被PGO早期内联优化处理，且不会根据采样配置文件进行调整'
# 'If the total count of context profile is smaller than the threshold, it will be merged into context-less base profile.'
H78D9F132106C: '如果上下文配置文件的总计数小于阈值，则将其合并到无上下文的基础配置文件中'
# 'If the total count of the profile is smaller than threshold, it will be trimmed.'
H29DFE55539B7: '如果配置文件的总计数小于阈值，则进行裁剪'
# 'If the valnos size of an interval is larger than the threshold, it is regarded as a large interval. '
H65099468E23D: '如果区间的valnos大小超过阈值，则将其视为大区间'
# 'If true, annotate inline advisor remarks with LTO and pass information.'
HBCBB7977FE78: '如果启用，在LTO和Pass信息中为内联建议备注添加注释'
# 'If true, artificially skip inline transformation in sample-loader pass, and merge (or scale) profiles (as configured by --sample-profile-merge-inlinee).'
HB64A7E1DFEB3: '如果启用，在sample-loader Pass中人为跳过内联转换，并合并（或缩放）配置文件（根据--sample-profile-merge-inlinee配置）'
# 'If true, basic blocks are re-numbered before MBP layout is printed into a dot graph. Only used when a function is being printed.'
HBEE86CE05AA8: '如果启用，在生成MBP布局的dot图前会重新编号基本块。仅在打印函数时使用'
# 'If true, import function declaration as fallback if the function definition is not imported.'
HD7D070FB023F: '如果启用，当函数定义未导入时，将导入函数声明作为备用方案'
# 'If true, keep the vtable symbols in indexed profiles'
H52D48DA006BE: '如果启用，将在索引配置文件中保留虚表符号'
# 'If true, scale the working set size of the partial sample profile by the partial profile ratio to reflect the size of the program being compiled.'
HBDDA0894BE03: '如果启用，将根据部分配置文件比率缩放程序编译时的部分样本配置文件的工作集大小'
# 'If true, the virtual table address will be instrumented to know the types of a C++ pointer. The information is used in indirect call promotion to do selective vtable-based comparison.'
H3E8FA9464A37: '如果启用，将插桩虚表地址以识别C++指针类型。该信息用于间接调用提升时进行选择性虚表比较'
# 'If using a contextual profile in this module, and an indirect call target is marked as alwaysinline, perform indirect call promotion for that target. If multiple targets for an indirect call site fit this description, they are all promoted.'
H51C56F762F1D: '如果本模块使用上下文配置文件，并且间接调用目标标记为alwaysinline，则对该目标执行间接调用提升。如果间接调用点存在多个符合条件的目标，将全部进行提升'
# 'Ignore #line directives when displaying diagnostic locations'
HD98F069577E5: '在显示诊断位置时忽略#line指令'
# 'Ignore RecMII'
H2050B14C1C4D: '忽略RecMII'
# 'Ignore TTI attributes compatibility check between callee/caller during inline cost calculation'
H6DBD3A9D0CF3: '忽略内联成本计算期间调用者/被调用者之间的TTI属性兼容性检查'
# "Ignore all DWARF data. This relaxes the requirements for all statically linked libraries to have been compiled with '-g', but will result in false positives for 'CFI unprotected' instructions."
H39BB8E06FB84: "忽略所有DWARF数据。这会松弛对所有静态链接库必须使用 '-g' 编译的要求，但会导致 'CFI unprotected' 指令出现误报。"
# 'Ignore attribute objc_direct so that direct methods can be tested'
HCF66187C2621: '忽略objc_direct属性以便测试直接方法'
# 'Ignore balance information, always return (1: Even, 2: Odd).'
HFC882D591A40: '忽略平衡信息，始终返回（1：偶数，2：奇数）。'
# 'Ignore bit-field types when aligning structures'
H37A6736DD441: '对齐结构体时忽略位域类型'
# 'Ignore call stack samples for hybrid samples and produce context-insensitive profile.'
H7E47B7D4BE2D: '忽略混合样本中的调用栈样本，并生成上下文无关的分析结果。'
# 'Ignore case distinctions when searching.'
H17840E450A3A: '搜索时忽略大小写区分。'
# 'Ignore element line number.'
H68F79AF97A49: '忽略元素行号。'
# 'Ignore environment variables to detect CUDA installation'
HAC9812BECEE3: '忽略用于检测CUDA安装的环境变量'
# 'Ignore existing branch weights on IR and always overwrite.'
HB7CA4D0B2FB1: '忽略中间表示（IR）中现有的分支权重，并始终覆盖。'
# 'Ignore functions that match a regex. Multiple regexes can be comma separated. Scop detection will ignore all functions that match ANY of the regexes provided.'
HDF7F5F41C8A9: '忽略与正则表达式匹配的函数。多个正则表达式可用逗号分隔。Scop检测将忽略所有与提供的正则表达式匹配的函数。'
# 'Ignore insert conflict and keep running to fix.'
HABB3F2EDAFC7: '忽略插入冲突并继续运行以修复。'
# 'Ignore possible aliasing of the array bases'
H64EE4A3BEF1A: '忽略数组基址的可能别名问题。'
# 'Ignore redundant instrumentation'
H4E0E4A3BF250: '忽略冗余插桩'
# 'Ignore the definition of the given macro when building and loading modules'
H7770258C460D: '在构建和加载模块时忽略给定宏的定义'
# 'Ignore the whitespace from the input file when emitting preprocessor output. It will only contain whitespace when necessary, e.g. to keep two minus signs from merging into to an increment operator. Useful with the -P option to normalize whitespace such that two files with only formatting changes are equal.\n\nOnly valid with -E on C-like inputs and incompatible with -traditional-cpp.'
HD37ED8478D7E: '在生成预处理输出时忽略输入文件的空白符。仅在必要时保留空白符，例如防止两个减号合并为增量运算符。与-P选项配合使用时可规范化空白符，使仅格式不同的两个文件内容相等。\n\n仅适用于C类输入的-E选项且与-traditional-cpp不兼容。'
# 'Ignore unexpected diagnostic messages'
H81B938CFE11E: '忽略意外的诊断消息'
# 'Ignore warnings from system headers (default)'
H7D4D3672A31D: '忽略系统头文件的警告（默认）'
# "Implement the 'patchable-function' attribute"
H53EFAEE072B9: "实现 'patchable-function' 属性"
# 'Implicit null checks'
H40CAC5790CAC: '隐式空指针检查'
# 'Implicitly search the file system for module map files.'
HA09A2D8486F2: '隐式搜索文件系统中的模块映射文件'
# "Implies all other options in 'Symbol Types' category"
HA831AAE57383: '启用‘符号类型’类别中的所有其他选项。'
# 'Implies most other options.'
H6CE9D8EF9C43: '隐含其他大多数选项。'
# 'Implies the SAVE attribute for non-automatic local objects in subprograms unless RECURSIVE'
H4C9AEE72AB8A: '在子程序中，除非是RECURSIVE，否则对非自动本地对象隐含SAVE属性'
# 'Import all external functions in index.'
H6AA576FCF40F: '导入索引中的所有外部函数。'
# 'Import constant global variables with references'
H2A392B0AB0D3: '导入带有引用的常量全局变量'
# 'Import declaration.'
H4A43ED2EE433: '导入声明。'
# 'Import full type definitions for ThinLTO.'
HC44C755DA4C3: '为ThinLTO导入完整的类型定义。'
# 'Import functions with noinline attribute'
HD198F1298814: '导入带有noinline属性的函数'
# 'Import module.'
H6E01604A8D9D: '导入模块。'
# 'Import summary to use for testing the ThinLTO backend via opt'
HED7EEF5C6F9E: '导入用于通过opt测试ThinLTO后端的摘要'
# 'Import the polyhedral description of the detected Scops'
H5D0606A7CB94: '导入检测到的Scops的多面体描述。'
# 'Import typeid resolutions from summary and globals'
HC32DC5EADEE2: '从总结和全局导入 typeid 解析'
# 'Import.'
H0E5CF36B48DC: '导入。'
# 'Improve global merge pass to ignore globals only used alone'
H26A9763EC62A: '改进全局合并pass以忽略仅单独使用的全局变量'
# 'Improve global merge pass to look at uses'
HA9CE9E94603C: '改进全局合并pass以查看使用情况'
# 'Improve the code quality by splitting alternate instructions'
H103FED3C5FE8: '通过拆分替代指令提高代码质量'
# 'In all cases'
HCC1A697CD02F: '在所有情况下'
# 'In conjunection with -type-index and -id-index, dumps the entire dependency graph for the specified index instead of just the single record with the specified index'
H835459E7E97D: '与-type-index和-id-index选项结合使用时，将转储指定索引的整个依赖关系图，而不仅仅是具有该索引的单个记录'
# "In profiling mode like sampleFDO, if a function doesn't have profile, we cannot tell the function is cold for sure because it may be a function newly added without ever being sampled. With the flag enabled, compiler can put such profile unknown functions into a special section, so runtime system can choose to handle it in a different way than .text section, to save RAM for example. "
H4571B587B651: '在类似sampleFDO的分析模式中，如果函数没有配置文件，我们无法确定该函数是否为冷函数，因为它可能是从未被采样的新添加的函数。启用该标志后，编译器可以将这些配置文件未知的函数放入特殊段，这样运行时系统可以选择以不同于.text段的方式处理它们，例如节省RAM。'
# 'In the OpenMP data clauses treat `a(N)` as `a(N:N)`.'
H1CA9E31B3F5D: '在OpenMP数据子句中将`a(N)`视为`a(N:N)`。'
# 'In the dump requested by -dump-input, print <N> input lines\nbefore and <N> input lines after any lines specified by\n-dump-input-filter.  When there are multiple occurrences of\nthis option, the largest specified <N> has precedence.  The\ndefault is 5.\n'
HEB48ED43B50E: '在由-dump-input请求的转储中，打印指定行之前和之后各 <N> 行输入行。如果该选项出现多次，则最大的 <N> 值优先。默认值为 5。\n'
# "In the dump requested by -dump-input, print only input lines of\nkind <value> plus any context specified by -dump-input-context.\nWhen there are multiple occurrences of this option, the <value>\nthat appears earliest in the list below has precedence.  The\ndefault is 'error' when -dump-input=fail, and it's 'all' when\n-dump-input=always.\n"
H9104E1DEC417: '仅打印类型为 <value> 的输入行以及由-dump-input-context指定的上下文。如果该选项出现多次，则列表中出现最早的 <value> 值优先。当-dump-input=fail时，默认值为 "error"；当-dump-input=always时，默认值为 "all"。\n'
# 'In the report, sort the timers in each group in wall clock time order'
H2F13A69F022D: '在报告中，按各组中的实时时钟时间对计时器进行排序'
# 'Include BLOCKINFO details in low level dump'
H27C5E3DE841C: '在低级转储中包含BLOCKINFO详细信息'
# "Include PTX for the following GPU architecture (e.g. sm_35) or 'all'. May be specified more than once."
H2031AC36E8FB: "包含以下GPU架构（例如sm_35）的PTX，或 'all'。可以多次指定该选项。"
# 'Include Parameters in templates.'
H8654E7CEAC51: '在模板中包含参数。'
# 'Include all attributes.'
H5307C43E1D9E: '包含所有属性。'
# 'Include and chain a header file after turning it into PCH'
HBFEBA9B95050: '将头文件转换为PCH后包含并链接它'
# 'Include brief documentation comments in code-completion results.'
H235F6D6F7048: '在代码补全结果中包含简要文档注释'
# 'Include code completion results which require small fix-its.'
HFB6D833443A2: '包含需要小修正的代码补全结果'
# 'Include code patterns in code-completion results'
H22A7B204F988: '在代码补全结果中包含代码模式'
# 'Include comments from within macros in preprocessed output'
H6B3D5AD18D24: '在预处理输出中包含宏内的注释'
# 'Include comments in preprocessed output'
H5CEC03939D7C: '在预处理输出中包含注释'
# 'Include declaration types in AST dumps'
H327A3B852BC1: '在AST转储中包含声明类型'
# 'Include default header file for OpenCL and HLSL'
H5BEB3A92485B: '包含OpenCL和HLSL的默认头文件'
# 'Include file before parsing'
H9043E8EF9CD8: '在解析前包含文件'
# "Include line table offset in function's debug info and emit end sequence after each function's line data."
H98EA6A67A95E: '在函数的调试信息中包含行表偏移，并在每个函数的行数据后发出结束序列。'
# 'Include macros from file before parsing'
H36D4DE65DD21: '在解析前包含文件中的宏'
# 'Include macros in code-completion results'
H3EC7A0C589B9: '在代码补全结果中包含宏'
# 'Include module files in dependency output'
H1900641C3AE2: '在依赖项输出中包含模块文件'
# 'Include only compilands those which match a regular expression'
H077919CD113F: '仅包含与正则表达式匹配的编译单元'
# 'Include only symbols which match a regular expression'
HC57ED85CA0C0: '仅包含与正则表达式匹配的符号'
# 'Include only types which match a regular expression'
HF1FE163F1EFB: '仅包含与正则表达式匹配的类型'
# 'Include path for coverage check.'
HCF44564AEDD8: '包含覆盖检查的路径。'
# 'Include precompiled header file'
HCCC9D73787DC: '包含预编译头文件'
# 'Include system headers in dependency output'
HA0C79FE37C8B: '在依赖项输出中包含系统头文件'
# 'Include what you use. Insert the owning header for top-level symbols, unless the header is already directly included or the symbol is forward-declared'
H8E18AB6F55BF: '使用即包含。除非已直接包含该头文件或符号已被前置声明，否则为顶层符号插入所属头文件'
# 'Incorporate CUDA device-side binary into host object file.'
HC64F11374476: '将CUDA设备端二进制文件合并到主机目标文件中。'
# 'Increase alignment of LDS if it is not on align boundary'
H6B6D9E0BE911: '如果LDS未对齐到对齐边界，则增加其对齐'
# "Increases 'x86-br-merging-base-cost' in cases that it is likely that all conditionals will be executed. For example for merging the conditionals (a == b && c > d), if its known that a == b is likely, then it is likely that if the conditionals are split both sides will be executed, so it may be desirable to increase the instruction cost threshold. Set to -1 to never merge likely branches."
H9238554A10FA: '在所有条件分支可能都会执行的情况下，增加 "x86-br-merging-base-cost" 的值。例如对于合并条件（a == b && c > d），如果已知a == b很可能成立，则如果条件被拆分，两边都可能被执行，因此可能需要提高指令成本阈值。设置为-1以永远不合并可能的分支。'
# "Increases 'x86-br-merging-base-cost' in cases that the target supports conditional compare instructions."
H0EFC5555FAAB: '在目标支持条件比较指令的情况下，增加 "x86-br-merging-base-cost" 的值。'
# 'Incremental depth computation will be used for basic blocks with more instructions.'
HE1566572AE0C: '对于指令较多的基本块，将使用增量深度计算。'
# 'Index of module to extract'
H61BCB37228FB: '要提取的模块的索引'
# 'Indicate the sample profile being used is flattened, i.e., no inline hierarchy exists in the profile'
H8CEB9B04AD89: '表示使用的样本配置文件是扁平化的，即配置文件中不存在内联层次结构'
# 'Indirect access memory instruction weight'
H4459013C64C1: '间接访问内存指令的权重'
# 'Induction Variable Users'
HCAD9EC424CF6: '归纳变量使用者'
# 'Infer address spaces'
H384231A2B40A: '推断地址空间'
# 'Infer counts from stale profile data.'
H68A503AAE479: '从过时的配置文件数据推断计数'
# 'Infer missing call frames due to compiler tail call elimination.'
H3DAC7DFCC466: '由于编译器尾调用消除而推断缺失的调用帧'
# 'Infer nuw/nsw flags using context where suitable'
H6B2FAC7DF345: '在适用的上下文中使用上下文推断nuw/nsw标志'
# 'Inheritance.'
H21B03FF2F5DB: '继承。'
# 'Inhibit optimization of S->D register accesses on A15'
H9EE07FA9B2FD: '抑制A15上S->D寄存器访问的优化'
# 'Init Undef Pass'
HA592C8476F8C: '初始化未定义Pass'
# "Initialize trivial automatic stack variables. Defaults to 'uninitialized'"
H413F6C855E54: '初始化平凡的自动栈变量。默认值为 "uninitialized"'
# 'Inject absolute symbol definitions (syntax: <name>=<addr>)'
HD553F9022403: '注入绝对符号定义（语法：<name>=<addr>）'
# 'Inject symbol aliases (syntax: <alias-name>=<aliasee>)'
H4CF0C6E38779: '注入符号别名（语法：<alias-name>=<aliasee>）'
# 'Inline all applicable functions on the device.'
H843E2B29FDA6: '在设备上内联所有适用的函数'
# 'Inline all functions early'
HBFFBF85B1F6E: '尽早内联所有函数'
# "Inline cold call sites in profile loader if it's beneficial for code size."
H86BDD048441C: '如果对代码大小有益，则在配置文件加载器中内联冷调用点'
# 'Inline expressions that are used only once rather than generating a let-binding'
HBC10ADACCD0B: '内联仅使用一次的表达式，而非生成let绑定'
# 'Inline functions as deemed beneficial by the compiler'
H648E731FB641: '根据编译器判断为有益时进行函数内联'
# 'Inline functions which are (explicitly or implicitly) marked inline'
H8CD71C20FEE1: '内联显式或隐式标记为inline的函数'
# 'Inline shadow poisoning for blocks up to the given size in bytes.'
HD3284F467146: '对最多给定字节数的块进行影子中毒内联'
# 'Inline suitable functions'
H8AADDFE804BD: '内联合适的函数'
# 'Inline threshold for device compilation for CUDA/HIP'
H94D1EB14515E: 'CUDA/HIP设备编译的内联阈值'
# 'Inlined function.'
H5766708CD3DD: '内联函数。'
# 'Inlinee lines (DEBUG_S_INLINEELINES subsection)'
H605540E4F837: '被内联函数的代码行 (DEBUG_S_INLINEELINES 子部分)'
# 'Inliner for always_inline functions'
H228DE039DDE2: '对always_inline函数的内联处理程序'
# 'Inner loop block size threshold to analyze in unroll for AMDGPU'
H2139A958B6DF: 'AMDGPU在展开时分析内部循环块大小的阈值'
# 'Inplace edit <file>s'
H1E18B41D725B: '原地编辑 <file> 文件'
# 'Inplace edit <file>s, if specified.'
H469713E2DE1D: '如果指定了，则原地编辑 <file> 文件'
# 'Input JSON stream encoding'
HDA67A1195E8E: '输入JSON流编码'
# 'Input file. Can be specified multiple times for multiple input files.'
H5D0C7337A0AA: '输入文件。可以多次指定以指定多个输入文件'
# "Input file. The format is an array of contexts.\nEach context is a dictionary with the following keys:\n'Guid', mandatory. The value is a 64-bit integer.\n'Counters', mandatory. An array of 32-bit ints. These are the counter values.\n'Contexts', optional. An array containing arrays of contexts. The context array at a position 'i' is the set of callees at that callsite index. Use an empty array to indicate no callees."
H53610FB0F715: "输入文件。格式是一个上下文数组。\n每个上下文是一个包含以下键的字典：\n'Guid'，必填。值为 64 位整数。\n'Counters'，必填。一个 32 位整数数组。这些是计数器值。\n'Contexts'，可选。包含上下文数组的数组。位置 'i' 的上下文数组是该调用站点索引处的被调用者集合。使用空数组表示无被调用者。"
# "Input language ('ir' or 'mir')"
HAAA3662FD097: "输入语言（'ir' 或 'mir'）"
# 'Input lines with annotations'
H7B5B0A60C876: '带有注解的输入行'
# 'Input lines with starting points of annotations'
H2C5EEFB1318C: '带有注解起始位置的输入行'
# 'Input lines with starting points of error annotations'
H738B96DDE138: '带有错误注解起始位置的输入行'
# 'Input remark format to parse'
H719353F24FE9: '要解析的输入注释格式'
# 'Insert BLOCK/LOOP/TRY/TRY_TABLE markers for WebAssembly scopes'
H7D3A208C7E5E: '为WebAssembly作用域插入BLOCK/LOOP/TRY/TRY_TABLE标记'
# 'Insert CFI remember/restore state instructions'
H6E95A98450BA: '插入CFI记住/恢复状态指令'
# 'Insert KCFI indirect call checks'
H9190E8521B57: '插入 KCFI 间接调用检查'
# 'Insert XRay ops'
HB3BFBF584BC3: '插入XRay操作'
# 'Insert a break point on the last enabled count of a chunks list'
H14F2710F0183: '在块列表的最后一个启用计数处插入断点'
# 'Insert a specific header. This should run with STDIN mode.\nThe result is written to stdout. It is currently used for\neditor integration. Support YAML/JSON format:\n  -insert-header="{\n     FilePath: "/path/to/foo.cc",\n     QuerySymbolInfos: [\n       {RawIdentifier: foo,\n        Range: {Offset: 0, Length: 3}}\n     ],\n     HeaderInfos: [ {Headers: "\\"foo_a.h\\"",\n                     QualifiedName: "a::foo"} ]}"'
HAF484669F973: '插入特定头文件。此功能需在STDIN模式下运行。\n结果将输出到标准输出。当前用于\n编辑器集成。支持YAML/JSON格式：\n  -insert-header="{\n     FilePath: "/path/to/foo.cc",\n     QuerySymbolInfos: [\n       {RawIdentifier: foo,\n        Range: {Offset: 0, Length: 3}}\n     ],\n     HeaderInfos: [ {Headers: "\\"foo_a.h\\"",\n                     QualifiedName: "a::foo"} ]}"'
# 'Insert calls to __dfsan_*_callback functions on data events.'
HBF62B008B7B5: '在数据事件上插入对__dfsan_*_callback函数的调用'
# 'Insert calls to __dfsan_nonzero_label on observing a parameter, load or return with a nonzero label'
HCF1838FEBC0F: '在观察到带有非零标签的参数、加载或返回时插入对__dfsan_nonzero_label的调用'
# 'Insert calls to callback functions on conditionals.'
H462621715E94: '在条件判断时插入对回调函数的调用'
# 'Insert calls to callback functions on data reaching a function.'
H874EB16726E7: '在数据到达函数时插入对回调函数的调用'
# 'Insert calls to fentry at function entry (x86/SystemZ only)'
H5602F1E7FC9F: '在函数入口处插入对fentry的调用（仅支持x86/SystemZ）'
# 'Insert checks for constant shadow values'
HEF594A46B3BD: '插入对常量阴影值的检查'
# 'Insert fentry calls'
HCD006A416E6E: '插入fentry调用'
# 'Insert instructions into the prologue for storing into the stack ring buffer'
H46F958F6D7F3: '在序言中插入指令以将数据存储到堆栈环形缓冲区'
# 'Insert instructions into the prologue for storing into the stack ring buffer directly'
H31D52AECD84E: '直接在序言中插入指令以将数据存储到堆栈环形缓冲区'
# 'Insert pseudo probe annotations for value profiling'
H219A8D7D9F81: '为值分析插入伪探针注释'
# 'Insert required mode register values'
HA0E87197EB1B: '插入所需的模式寄存器值'
# 'Insert sanitizers on OptimizerEarlyEP.'
HC54CCA49CF20: '在OptimizerEarlyEP上插入实验性的`assertalign`节点'
# 'Insert stack protectors'
H2189E21FAD58: '插入栈保护机制'
# 'Insert stores for EH state numbers'
HAFD53ADD3CBA: '为EH状态号插入存储指令'
# 'Insert symbols at valid longjmp targets for /guard:cf'
H36BD6FBCD02B: '在/guard:cf的有效longjmp目标处插入符号'
# 'Insert symbols at valid targets for /guard:ehcont'
H071F81C54D78: '在/guard:ehcont的有效目标处插入符号'
# 'Insert the experimental `assertalign` node.'
H893CAC606686: '在vmvNr.vs之前插入vsetvlis以确保vtype有效并清除vill'
# 'Insert vsetvlis before vmvNr.vs to ensure vtype is valid and vill is cleared'
H0091B7D0D6C7: '而非生成流水线代码，用生成的调度注释指令，供-modulo-schedule-test选项使用'
# 'InstPrinter options'
HFBC5B2731840: 'InstPrinter选项'
# 'Instantiate templates already while building a PCH'
H9EE0E3239942: '在构建PCH时实例化模板'
# 'Instead of emitting the pipelined code, annotate instructions with the generated schedule for feeding into the -modulo-schedule-test pass'
HD7DD1AFC4508: '而非运行LTO，列出每个IR文件中的依赖库'
# 'Instead of expanding system headers when emitting preprocessor output, preserve the #include directive. Useful when producing preprocessed output for test case reduction. May produce incorrect output if preprocessor symbols that control the included content (e.g. _XOPEN_SOURCE) are defined in the including source file. The portability of the resulting source to other compilation environments is not guaranteed.\n\nOnly valid with -E.'
H2BDDF0355665: '在生成预处理器输出时，保留#include指令而不是展开系统头文件。适用于生成测试用例缩减的预处理输出。如果预处理符号（如_XOPEN_SOURCE）在包含的源文件中定义了控制包含内容，可能导致输出不正确。无法保证生成的源代码在其他编译环境中的可移植性。\n\n仅与-E选项配合使用。'
# 'Instead of running LTO, list the dependent libraries in each IR file'
H03C32E83B1C7: '而非运行LTO，列出每个IR文件中的符号'
# 'Instead of running LTO, list the symbols in each IR file'
HA0AFB51F310C: '而非运行LTO，打印每个IR文件中的mach-o cpu'
# 'Instead of running LTO, print the mach-o cpu in each IR file'
HE9DA1147E6B8: '推迟变量的实际溢出代码插入到分配结束时。这样分配器可能仍能为该变量找到合适的着色方案，因为其他被逐出的变量腾出了空间'
# 'Instruction Inverse Throughput'
H08AC91953156: '指令逆吞吐量'
# 'Instruction Latency'
HFD97D6973432: '指令延迟'
# "Instruction cutoff for aggressive tail duplication during layout. Used at -O3. Tail merging during layout is forced to have a threshold that won't conflict."
H0BFD5BDD2709: '布局阶段尾部重复的指令阈值。布局阶段的尾部合并将强制使用不冲突的阈值'
# "Instruction cutoff for tail duplication during layout. Tail merging during layout is forced to have a threshold that won't conflict."
HCFA67B310DAB: '寄存器分配前可用的指令调度器：'
# 'Instruction latency'
H6CD53FB2E731: '指令延迟'
# 'Instruction schedulers available (before register allocation):'
H4C7D1036B846: '为包含指针操作数的操作添加检测'
# 'Instructions, lines, scopes, symbols and types.'
HD37C6649C311: '指令、代码行、作用域、符号和类型。'
# 'Instrument (context sensitive) the IR to generate profile.'
HAAB0AE0AE781: '（上下文敏感）对IR进行插桩以生成分析资料。'
# 'Instrument - operations with pointer operands'
HDBC71D3E6754: '为指针操作数的 <, <=, >, >=运算符添加检测'
# 'Instrument <, <=, >, >= with pointer operands'
H6DA2CC308CCE: '为指针操作数插入 <, <=, >, >='
# 'Instrument <, <=, >, >=, - with pointer operands'
H012240D9415C: '为指针操作数插入 <, <=, >, >=, -'
# 'Instrument atomics'
HBB3D2F3D5275: '插入原子操作'
# 'Instrument code to produce gcov data files (*.gcda)'
HFE3A9A25C96C: '插入代码以生成gcov数据文件（*.gcda）'
# 'Instrument control-flow architecture protection'
H2142469CBC51: '插入控制流架构保护检测代码'
# 'Instrument device library for HIP, which is a LLVM bitcode containing __cyg_profile_func_enter and __cyg_profile_func_exit'
H24C9537239C3: '为HIP设备库插入检测代码，该库是包含__cyg_profile_func_enter和__cyg_profile_func_exit的LLVM比特码'
# 'Instrument floating-point comparisons'
HFB5DAE0497FE: '插入浮点数比较'
# 'Instrument function entry and exit'
H744C2AF9F0F5: '插入函数入口和出口'
# 'Instrument function entry only, after inlining, without arguments to the instrumentation call'
H10B2DF0B7A61: '仅在内联后插入函数入口检测，不带参数'
# 'Instrument function entry with call to __CheckForDebuggerJustMyCode'
H38C50073F978: '用__CheckForDebuggerJustMyCode函数入口进行插装'
# 'Instrument function entry/exit with calls to e.g. mcount() (post inlining)'
H41E9F3846338: '在函数入口/出口插入对例如mcount()的调用（内联后）'
# 'Instrument functions with a call to __CheckForDebuggerJustMyCode'
H179F36D1CDA5: '插入调用 __CheckForDebuggerJustMyCode 的函数'
# 'Instrument globals'
HF9B96A5EACA6: '插入全局变量'
# 'Instrument memintrinsics (memset/memcpy/memmove)'
HE6033F8FFDF9: '插入 memintrinsics（memset/memcpy/memmove）'
# 'Instrument memory accesses'
H9382264E0AFD: '插入内存访问'
# "Instrument only functions from files where names don't match all the regexes separated by a semi-colon"
HD8259B6217C3: '仅检测文件名不匹配所有分号分隔正则表达式的函数'
# 'Instrument only functions from files where names match any regex separated by a semi-colon'
H261C37210502: '仅检测文件名匹配任一分号分隔正则表达式的函数'
# 'Instrument scalar stack variables'
HC15A017384F6: '插入标量栈变量'
# 'Instrument the IR to generate profile.'
H5521F08582E8: '对IR进行插桩以生成分析资料。'
# 'Instrument the same temp just once'
H47FE01195CE1: '同一临时变量仅插入一次'
# 'Instrumentation profile (default)'
H8B8FBAF3F224: '插桩剖析（默认）'
# 'Intel SVML library'
H43C24287102B: 'Intel SVML 库'
# 'Interchange if you gain more than this number'
H1A5217DD30CE: '如果收益超过此数值则进行循环变换'
# 'Internal Options'
HE6B42A71FEB4: '内部选项'
# 'Internal and debugging options'
H1AFE239C87EF: '内部和调试选项'
# 'Internal traces and extra debugging code.'
HFC2113D2B3C3: '内部跟踪信息和额外的调试代码。'
# 'Internalize linked symbols'
H4254AEAF9E4E: '内部化链接的符号'
# 'Intrinsics Generator Options'
H4BD784F50D5F: '固有函数生成器选项'
# 'Introduce mul24 intrinsics in AMDGPUCodeGenPrepare'
H3C667C2E6C53: '在 AMDGPUCodeGenPrepare 中引入 mul24 内建函数'
# 'Invalid code ranges.'
H1F42CA5A3D9B: '无效的代码范围。'
# 'Invalid symbol coverages values.'
H3E269D60065B: '无效的符号覆盖率值。'
# 'Invalid symbol locations.'
H5E97A467E1AD: '无效的符号位置。'
# 'Issue call to specified function rather than a trap instruction'
HA69FCF5CDF0A: '调用指定函数而非执行trap指令'
# 'Iterate to a fixed point when attempting to convert reg-reg instructions to reg-imm'
HD223D51415E6: '在尝试将寄存器-寄存器指令转换为寄存器-立即数时迭代到固定点'
# 'Iterative inference: delta convergence precision; smaller values typically lead to better results at the cost of worsen runtime'
H1328F2EA33BA: '迭代推理：收敛精度的增量；较小的值通常能获得更好的结果，但会增加运行时间'
# 'Iterative inference: maximum number of update iterations per block'
H5F6BCC565010: '迭代推理：每个块的最大更新迭代次数'
# 'JIT the code and run it by invoking the main function'
HC922A3A5E7D1: '通过调用主函数来JIT编译代码并运行它'
# 'JITLink Options'
H759F3B87058B: 'JITLink 选项'
# 'JSON format'
H5766BFD5841D: 'JSON 格式'
# 'Join isolated components having positive flow.'
HA5D28D00BB60: '合并具有正流量的孤立组件'
# 'Jump score power (when --split-strategy=cdsplit)'
H4F864F9914B4: '跳转得分幂（当 --split-strategy=cdsplit 时）'
# 'Just print the preprocessed file'
H19C52BC87B22: '仅打印预处理后的文件'
# 'Just run preprocessor, no output (for timings)'
HA774A3EF0AA6: '仅运行预处理器，不生成输出（用于计时）'
# 'Kaleidoscope example program\n'
HCF3536F4FAAB: 'Kaleidoscope 示例程序\n'
# 'Keep all benchmarks (default)'
HD3F623D56EDC: '保留所有基准测试（默认）'
# 'Keep all non-cold contexts (increases cloning overheads)'
H4544ED3678BF: '保留所有非冷上下文（会增加克隆开销）'
# 'Keep aside the last <num-test-traces> traces in the profile when computing the function order and instead use them to evaluate that order'
H77D85A9D26A6: '在计算函数顺序时保留最后 <num-test-traces> 个配置文件中的轨迹，并使用它们来求值该顺序'
# 'Keep copies of symbols in LTO indexing'
HB94AF3670BCE: '在LTO索引中保留符号的副本'
# 'Keep going on errors encountered'
H418BF6CA6A97: '遇到错误时继续执行'
# 'Keep going on errors encountered in trace 1'
H99638570EFA7: '在trace 1 中遇到错误时继续执行'
# 'Keep going on errors encountered in trace 2'
HCFE6CEB4DFCA: '在trace 2 中遇到错误时继续执行'
# 'Keep initializers of constants'
H36ACE3809A61: '保留常量的初始化器'
# 'Keep max reading'
H5A60CCC0248E: '保留最大读数'
# 'Keep min reading'
H6EAFD9A719C6: '保留最小读数'
# 'Keep only the benchmarks that *DO* involve memory'
HF9706AF3813D: '保留仅涉及内存的基准测试'
# 'Keep only those benchmarks that do *NOT* involve memory'
H135A99676AA8: '保留仅不涉及内存的基准测试'
# 'Keep readings set with min-variance'
H09D9C8B784B4: '以最小方差(min-variance)设置的读数'
# 'Keep static const variables even if unused'
H6813EA88BF1D: '保留未使用的 static const 变量'
# 'Keep the last K contexts while merging cold profile. 1 means the context-less base profile'
H3B3B98C36252: '在合并冷配置文件时保留最后K个上下文。1表示无上下文的基础配置文件'
# 'Keep the last K contexts while merging profile. -1 means no depth limit.'
HE51374D52FCC: '在合并配置文件时保留最后K个上下文。-1表示没有深度限制。'
# 'Keep the last K contexts while merging unsymbolized profile. -1 means no depth limit.'
HCA7356B0D5FB: '在合并无符号配置文件时保留最后K个上下文。-1表示没有深度限制。'
# 'Keep the last K frames while merging cold profile. 1 means the context-less base profile'
H4AC5A2FF5CAD: '在合并冷配置文件时保留最后K个帧。1表示无上下文的基础配置文件'
# 'Kernel code model'
H99C64FCE935F: '内核代码模型'
# 'Kernel limit wave threshold in %'
H670F8AEC39A0: '内核波限阈值百分比 (%)'
# 'Kind of debug info to add'
HBD02ACC04B34: '要添加的调试信息类型'
# 'LCSSA Verifier'
HF121CA5D89C7: 'LCSSA验证器'
# 'LLDB Instrumentation Generator'
H3C61B845C07E: 'LLDB 插桩生成器'
# 'LLJITDumpObjects'
H6958140CABBB: 'LLJIT转储对象'
# 'LLJITWithCustomObjectLinkingLayer'
H632B9B1CBCE5: '带有自定义对象链接层的LLJIT'
# 'LLJITWithGDBRegistrationListener'
HB6D370668767: '带有GDB注册监听器的LLJIT'
# 'LLJITWithInitializers'
HACE516CC94B0: 'LLJITWithInitializers'
# 'LLJITWithLazyReexports'
H3A104CF605C4: 'LLJITWithLazyReexports'
# 'LLJITWithObjectCache'
H71A8C9D07573: 'LLJITWithObjectCache'
# 'LLJITWithObjectLinkingLayerPlugin'
H748539F4EA26: 'LLJITWithObjectLinkingLayerPlugin'
# 'LLJITWithRemoteDebugging'
H3A8FDD7C38FF: 'LLJITWithRemoteDebugging'
# 'LLJITWithThinLTOSummaries'
HE8A81BB7479F: 'LLJITWithThinLTOSummaries'
# 'LLVM C++ ABI Data Dumper\n'
HEF94C326E777: 'LLVM C++ ABI 数据转储工具\n'
# 'LLVM C++ mangled name remapper\n'
H374D96C0B2FD: 'LLVM C++ 装饰名称重映射器\n'
# 'LLVM Contextual Profile Utils\n'
H96B79F1155FF: 'LLVM 上下文分析数据工具\n'
# 'LLVM IR Similarity Visualizer\n'
H1B7F78E6F996: 'LLVM IR 相似性可视化工具\n'
# 'LLVM OpenMP'
H6A5AC73C091C: 'LLVM OpenMP'
# 'LLVM PDB Dumper\n'
HD0867800CD16: 'LLVM PDB 转储工具\n'
# 'LLVM automatic testcase reducer.\nSee https://llvm.org/docs/CommandGuide/llvm-reduce.html for more information.\n'
HD6FE445BE8E3: 'LLVM 自动测试用例缩减工具。\n请参阅 https://llvm.org/docs/CommandGuide/llvm-reduce.html 以获取更多信息。\n'
# 'LLVM automatic testcase reducer. See\nhttp://llvm.org/cmds/bugpoint.html for more information.\n'
H28E8E607A645: 'LLVM 自动测试用例缩减器。详情请访问\nhttp://llvm.org/cmds/bugpoint.html 获取更多信息。\n'
# 'LLVM code coverage tool\n'
HB94353E136F7: 'LLVM 代码覆盖率工具\n'
# 'LLVM module splitter\n'
H99370B462DED: 'LLVM 模块分割器\n'
# 'LLVM profile data\n'
H799B04E164DC: 'LLVM 分析数据\n'
# 'LMUL argument must be in the range [0,3] or [5,7]'
H3949F7728682: 'LMUL 参数必须在范围 [0,3] 或 [5,7] 内'
# 'LSR search space complexity limit'
H6C951DA0F280: 'LSR搜索空间复杂度限制'
# 'LTO Options'
H45ADD610F25F: 'LTO 选项'
# 'LTO requires -fuse-ld=lld'
H1F6F6CBC7560: 'LTO 需要使用 -fuse-ld=lld 选项'
# 'Label.'
H213B873A2E3C: '标签。'
# 'Lanai Assembly Printer'
HABEAC7BF71A9: 'Lanai 汇编打印器'
# 'Lanai DAG->DAG Pattern Instruction Selection'
HF0BD56FB7903: 'Lanai DAG->DAG 模式指令选择'
# 'Lanai memory ALU combiner pass'
H6ECAF3A1B377: 'Lanai内存ALU组合器Pass'
# 'Language standard to compile for'
HC9609252D3B1: '要编译的语言标准'
# 'Large code model'
H6118BEDCF561: '大型代码模型'
# 'Large stride memory access threshold'
H0DDCC23DCFC1: '大步长内存访问阈值'
# 'Large stride memory access weight'
HD5651F61773D: '大步长内存访问权重'
# 'Last chance recoloring max depth'
HF4F4F97F3F0A: '最后机会重新着色最大深度'
# 'Last chance recoloring maximum number of considered interference at a time'
HB5BF2EA66D0A: '最后机会重新着色每次考虑的干扰最大数量'
# 'Launch an out-of-process executor to run code'
HB7F275AE5070: '启动一个进程外执行器来运行代码'
# 'Lazy Block Frequency Analysis'
HAEAE6F9C4ECD: '懒惰块频率分析'
# 'Lazy Branch Probability Analysis'
H0F9273E7A928: '懒惰分支概率分析'
# 'Lazy Machine Block Frequency Analysis'
H58403538D0D3: '懒惰机器块频率分析'
# 'Lazy Value Information Analysis'
HD066D1FABC77: '惰性值信息分析'
# 'Least BB number of huge function.'
H5201BDD0F5FF: '巨大函数的最小基本块数量。'
# 'Leave out unnecessary information when printing MIR'
HEE7C41A11713: '在打印MIR时省略不必要的信息'
# "Legalize the Machine IR a function's Machine IR"
H082594DE8633: '使函数的机器IR合法化'
# 'Level of field padding for AddressSanitizer'
H02387EE95AC8: 'AddressSanitizer 的字段填充级别'
# 'Lex file in raw mode and dump raw tokens'
H9BBDD925BA53: '以原始模式处理 Lex 文件并转储原始标记'
# 'Lex tokens from a .s file'
H4216F66AFBE5: '从.s文件中词法分析标记'
# 'Lexical block.'
HDAAEFA6A8637: '词法块。'
# 'Lexical scope level (File=0, Compile Unit=1).'
H7F636BA87B45: '词法作用域级别（文件=0，编译单元=1）。'
# 'Libraries to link dynamically'
H9E0097DC803F: '动态链接的库'
# "Like 'ExecutorNative' if ORC runtime provided, otherwise like 'GenericIR'"
H4792AD158E44: "如果提供了Orc运行时则类似于 'ExecutorNative'，否则类似于 'GenericIR'"
# 'Like -MD, but also implies -E and writes to stdout by default'
H09E4A86636C3: '类似于 -MD，但同时也隐含 -E 并默认写入 stdout'
# 'Like -MMD, but also implies -E and writes to stdout by default'
H3264A1580B97: '类似于 -MMD，但同时也隐含 -E 并默认写入 stdout'
# 'Like -O2 but optimize for code size above all else. Similar to clang -Oz. Same as -passes="default<Oz>"'
H2F3FC31B4B90: '类似于-O2，但以代码大小为最高优先级进行优化。类似于clang的-Oz选项。等同于-passes="default<Oz>"'
# 'Like -O2 but size-conscious. Similar to clang -Os. Same as -passes="default<Os>"'
H17C4D6C7AE33: '类似于-O2，但更注重代码大小。类似于clang的-Os选项。等同于-passes="default<Os>"'
# 'Like -finstrument-functions, but insert the calls after inlining'
H71DE1A83F0E0: '类似于 -finstrument-functions，但将调用插入到内联之后'
# 'Like -fmodules-decluse but requires all headers to be in modules'
H9B04279148C1: '类似于 -fmodules-decluse，但要求所有头文件都在模块中'
# "Like -fno-semantic-interposition but don't use local aliases"
H1E8DA2527D1D: '类似于 -fno-semantic-interposition，但不使用本地别名'
# 'Like -printlineinfo but does not load the object first'
H4419DBB99339: '类似于-printlineinfo但不先加载对象文件'
# 'Like /Z7'
H4FD8854D9F4E: '类似于 /Z7'
# 'Like /showIncludes but omit system headers'
H688724C80945: '类似于 /showIncludes，但省略系统头文件'
# 'Limit all regclasses to N registers'
H63DA69AD987D: '将所有寄存器类限制为N个寄存器'
# 'Limit block size to analyze in load/store widening pass'
H7ECB2D63C850: '限制加载/存储扩展pass中分析的块大小'
# 'Limit cases to analyze when converting a switch to select'
H4850FF8E3DC7: '在将switch转换为select时限制要分析的情况'
# 'Limit debug information produced to reduce size of debug binary'
H538935517F09: '限制生成的调试信息以减少调试二进制文件的大小'
# 'Limit float precision to the given value'
HF96C59869298: '将浮点精度限制为指定的值'
# 'Limit maximum recursion depth when calculating costs of speculatively executed instructions'
H66110CD9CA1F: '在计算推测执行指令的开销时限制最大递归深度'
# 'Limit on instruction search range in frame index elimination'
HBC1B1C08E702: '帧索引消除中指令搜索范围的限制'
# 'Limit on the cost of instructions that can be repeated due to loop flattening'
HD92D80EEAC82: '由于循环展平可重复指令的成本限制'
# 'Limit on the number of reused registers in frame index elimination'
H607E68347FE8: '帧索引消除中可复用寄存器数量的限制'
# 'Limit options in the Modules category to the specified module index'
HB070B9863405: '将模块类别中的选项限制为指定的模块索引'
# 'Limit ready list to N instructions'
H5F2D4380F5BB: '将就绪列表限制为N条指令'
# 'Limit register pressure of scheduled loop'
H7D5776BBBD61: '限制调度循环的寄存器压力'
# 'Limit the length of PHI chains to lookup'
H44DF903D7B74: '限制要查找的PHI链长度'
# 'Limit the number of collected seeds groups in a BB to cap compilation time.'
HCB093C287DF8: '限制基本块（BB）中收集的种子组数量以控制编译时间'
# 'Limit the number of instructions to process (0 for no limit)'
H0F105AAF8005: '限制要处理的指令数量（0表示无限制）'
# 'Limit the number of loads analysed'
H27294DA00A2A: '限制分析的加载操作数量'
# 'Limit the number of operands to inline for Token Factors'
HEA9F8176A261: '限制为Token Factors联机的操份数量'
# 'Limit the number of registers available for integer arguments'
HD3D75863FAEB: '限制可用于整型参数的寄存器数量'
# 'Limit the number of times for the same StoreNode and RootNode to bail out in store merging dependence check'
H611EA77C379A: '在存储合并依赖检查中，限制相同StoreNode和RootNode的放弃次数'
# 'Limit the recursion depth when building a vectorizable tree'
HAF7BB4678550: '构建可向量化树时限制递归深度'
# 'Limit the size of the SLP scheduling region per block'
HEAF5A10A6293: '限制每个块的SLP调度区域大小'
# 'Limit the size of the seed bundle to cap compilation time.'
H4DFB40A73CC1: '限制种子包的大小以控制编译时间。'
# 'Limits the range of tokens in -check file on which various features are tested. Example --check-lines=3-7 restricts testing to lines 3 to 7 (inclusive) or --check-lines=5 to restrict to one line. Default is testing entire file.'
H2A6188976AA0: '限制-check文件中测试各项功能的行范围。示例：--check-lines=3-7 将测试限制在 3 到 7 行（含），或--check-lines=5 限制为单行。默认测试整个文件。'
# 'Linalg ODS Gen from YAML'
H78D204B7569D: 'Linalg ODS Gen from YAML'
# 'Line kind to use when printing lines.'
H1ECE7CAA5A71: '打印行时使用的行类型'
# 'Line qualifiers (Newstatement, BasicBlock, etc.).'
H20226D797BE3: '行限定符（Newstatement、BasicBlock等）。'
# 'Line tables'
H4C16BA3AF07D: '行表'
# 'Linearize DAG, no scheduling'
HD1B44C093366: '线性化DAG，不进行调度'
# 'Lines (DEBUG_S_LINES subsection)'
H916009E842F5: '行（DEBUG_S_LINES子部分）'
# 'Lines referenced in the debug information.'
H59B1C9901129: '调试信息中引用的行'
# 'Lines.'
HC7986E72D11E: '行。'
# 'Link Options'
HCC3832473F0F: '链接选项'
# 'Link XRay runtime library when -fxray-instrument is specified (default)'
H3CD4BCB6EB07: '当指定 -fxray-instrument 时链接 XRay 运行时库（默认）'
# 'Link against library X in the library search paths'
HCEDA0BA2279F: '在库搜索路径中链接库X'
# 'Link against library X in the library search paths with hidden visibility'
H0C1A37003713: '在库搜索路径中以隐藏可见性链接库X'
# 'Link against library X with hidden visibility'
H7FCFC84F1391: '以隐藏可见性链接库X'
# 'Link and internalize needed symbols from the given bitcode file before performing optimizations.'
H592432E99C1A: '在执行优化之前，链接并内联化给定比特码文件中所需的符号'
# 'Link as a hybrid ARM64X image'
H741A1167C632: '作为混合 ARM64X 镜像进行链接'
# 'Link builtin bitcodes after the optimization pipeline'
HA396158ACBD5: '在优化管线后链接内建位代码'
# 'Link clang-offload-bundler bundles for HIP'
HB7831777CE51: '为 HIP 链接 clang-offload-bundler 包'
# 'Link device libraries for GPU device compilation'
H585B50C49350: '为 GPU 设备编译链接设备库'
# 'Link only needed symbols'
H7CCE9D08A2A1: '仅链接需要的符号'
# 'Link stack frames through backchain on System Z'
H0C4B76743142: '通过回溯链链接System Z的堆栈帧'
# 'Link the LLVM C Library for GPUs'
HD105C9964C21: '为GPU链接LLVM C库'
# 'Link the flang-rt shared library'
H92B8D27A2242: '链接flang-rt共享库'
# 'Link the flang-rt static library'
H31D4E54E52D3: '链接flang-rt静态库'
# 'Link the following file lazily'
HB68406E1D5AC: '惰性链接以下文件'
# 'Link the given bitcode file before performing optimizations.'
H1729D1922ED4: '在执行优化前链接给定的比特码文件。'
# 'Link two nested MLIR modules into a single LLVM IR module. Useful if both the host and device code can be run on the same CPU, as in SPIR-V CPU Runner tests.'
HF4FD097D1426: '将两个嵌套的MLIR模块链接为单个LLVM IR模块。当主机和设备代码可在同一CPU上运行时有用，例如SPIR-V CPU Runner测试。'
# 'Linkage name.'
HC775F1647BB7: '链接名称。'
# 'Linking with hot/cold operator new interfaces'
H1970EBF2160A: '链接热/冷操作new接口'
# 'Linux PPC Assembly Printer'
H99056A1F92AF: 'Linux PPC 汇编打印器'
# 'List bundle IDs in the bundled file.\n'
H3D67FC934FB6: '列出捆绑文件中的包ID。\n'
# 'List each file/graph name if/when it is linked'
H0D70E4352A2A: '链接时按需列出每个文件/图名称'
# 'List ignored files.'
H1A394A6B07E1: '列出被忽略的文件。'
# 'List of files with compilation or modularization problems for assistant mode.  This will be excluded.'
H7F26F6260A72: '助手模式下需要排除的包含编译或模块化问题的文件列表。'
# 'List of functions to print disassembly for. Accept demangled names only. Only work with show-disassembly-only'
H3054F37FF6EE: '要反汇编的函数列表。仅接受展开的名称。仅与show-disassembly-only选项配合使用'
# "List of key and value arguments. Required keywords are 'file' and 'triple'."
H45A6C5D3DB8C: '键值参数列表。必需的关键词是 "file" 和 "triple"。'
# 'List of modes to link in by default into XRay instrumented binaries.'
HA0397880FB9D: '默认链接到XRay已插入二进制文件中的模式列表'
# 'List of profitability heuristics to be used. They are applied in the given order'
HA13A6720841E: '要使用的收益性启发式方法列表。它们按给定顺序应用'
# 'List of symbols to export from the resulting object file'
H1BA25E23CBFD: '要从生成的对象文件中导出的符号列表'
# 'Live DEBUG_VALUE analysis'
H61CCF64E7BF9: '活动DEBUG_VALUE分析'
# 'Live Interval Analysis'
H1E8AD554BB44: '活跃间隔分析'
# 'Live Range Shrink Pass'
H1774992DE87F: '活动范围缩小Pass'
# 'Live Register Matrix'
H01100D0853E2: '活跃寄存器矩阵'
# 'Live Stack Slot Analysis'
H2C770BB0409B: '活跃栈槽分析'
# 'Live Variable Analysis'
HDDDE0A8181A8: '活跃变量分析'
# 'Load MIR Sample Profile'
HE68192F483EE: '加载MIR样本配置文件'
# 'Load a pch file and use it instead of all code up to and including <filename>'
H2B4B69D546AF: '加载预编译头文件并用它替代所有代码（直至并包含 <filename>）'
# 'Load all members of static archives'
H37DC6D24F9AF: '加载静态库中的所有成员'
# 'Load all members of static archives that implement Objective-C classes or categories, or Swift structs, classes or extensions'
HCC377DE628E7: '加载静态库中实现Objective-C类或分类，或Swift结构体、类或扩展的成员'
# 'Load and verify that a pre-compiled header file is not stale'
H71047E98C4FB: '加载并验证预编译头文件未过时'
# 'Load dialects from plugin library'
H4452CA7D250C: '从插件库加载方言'
# 'Load module without materializing metadata, then materialize only the metadata'
H43A90C52B97C: '先不物化元数据加载模块，然后仅物化元数据'
# 'Load pass plugin from a dynamic shared object file (only with new pass manager).'
HDC805E376CE5: '从动态共享对象文件加载Pass插件（仅适用于新Pass管理器）'
# 'Load passes from plugin library'
H8D748D07CDD6: '从插件库加载passes'
# 'Load shadow address into a local variable for each function'
HFDF300DF287B: '为每个函数将影子地址加载到本地变量中'
# 'Load target address from GOT'
H9E377C7D35D0: '从GOT加载目标地址'
# 'Load the clang builtins module map file.'
H593B89CC5BB8: '加载clang内建模块映射文件'
# 'Load the named plugin (dynamic shared object)'
HB2664DBBD1D2: '加载指定的插件（动态共享对象）'
# 'Load the specified plugin'
H92708A3C1B95: '加载指定的插件'
# 'Load this module map file'
HF58B1913A1B8: '加载此模块映射文件'
# 'Load top-level profiles that the sample reader initially skipped for the call-graph matching (only meaningful for extended binary format)'
H98AEC89E8CA3: '加载采样读取器最初跳过的顶层配置文件（仅对扩展二进制格式有意义）'
# 'Load, link and verify the resulting memory image.'
H9DA1560B06F8: '加载、链接并验证生成的内存映像'
# 'Load, link, and execute the inputs.'
H33C79A8E17E5: '加载、链接并执行输入文件'
# 'Load, link, and print line information for each function using the debug object'
HD0FE71B40225: '使用调试对象为每个函数加载、链接并打印行信息'
# 'Load, link, and print line information for each function.'
HD0F8E4BC3426: '加载、链接并打印每个函数的行信息。'
# 'Local Stack Slot Allocation'
H9064C8611F98: '本地栈槽分配'
# 'Local reassignment can yield better allocation decisions, but may be compile time intensive'
HDA7A0257A39E: '本地重新分配可以做出更好的分配决策，但可能增加编译时间'
# 'Local strategy.'
H69F9DACD1EB4: '本地策略。'
# 'Locations and Variables'
HAAA0526E734E: '位置和变量'
# 'Locations only'
H997812E5B96A: '仅位置'
# "Log action execution to a file, or stderr if  '-' is passed"
H7DDDF7706229: '将操作执行记录到文件中，如果设为 "-" 则记录到标准错误'
# 'Look up implicit modules in the prebuilt module path'
H7389FC31B294: '在预构建模块路径中查找隐式模块'
# 'LoongArch Assembly Printer'
H883C4FD99127: 'LoongArch 汇编打印器'
# 'LoongArch DAG->DAG Pattern Instruction Selection'
HCE16825D2625: 'LoongArch DAG->DAG 模式指令选择'
# 'LoongArch Dead register definitions'
HAC29789F40DC: '龙芯架构死寄存器定义'
# 'LoongArch Merge Base Offset'
H4ADCE551F44A: '龙芯架构合并基址偏移'
# 'LoongArch Optimize W Instructions'
HE6925B9D5E46: '龙芯架构优化W指令'
# 'LoongArch Pre-RA pseudo instruction expansion pass'
HABF2FA12711A: '龙芯架构寄存器分配前伪指令扩展Pass'
# 'LoongArch atomic pseudo instruction expansion pass'
H9277CF038FA3: '龙芯架构原子伪指令扩展Pass'
# 'Loop Data Prefetch'
H4A7486BE5EE1: '循环数据预取'
# 'Loop Invariant Code Motion'
H1F7B4F47808C: '循环不变量代码移动'
# 'Loop Strength Reduction'
HD2B0D185F01F: '循环强度削弱'
# 'Loop Terminator Folding'
HA587F9DFACE9: '循环终止指令折叠'
# 'Loop over the snippet'
H8CE72D20104F: '遍历代码片段'
# 'Loop rescheduling'
H3C5B4019E9D4: '循环重调度'
# 'Loop-Closed SSA Form Pass'
HA93B03345334: '循环闭合静态单赋值形式处理'
# "LoopVersioningLICM's minimum allowed percentage of possible invariant instructions per loop"
H9A2539A9680F: '每个循环允许的最小不变指令百分比（LoopVersioningLICM）'
# "LoopVersioningLICM's threshold for maximum allowed loop nest/depth"
H17B01644371B: '允许的最大循环嵌套或深度阈值（LoopVersioningLICM）'
# 'Loops with a constant trip count smaller than this value will not use the count register.'
H9C4270A71595: '迭代次数小于该值的循环将不会使用计数寄存器'
# 'Loops with a constant trip count that is smaller than this value are vectorized only if no scalar iteration overheads are incurred.'
HEB5EC35573F1: '如果不会产生标量迭代开销，循环次数为常量且小于该值的循环才会被向量化。'
# 'Low level details'
H736A60384473: '低级细节'
# 'Lower @llvm.global_dtors via `__cxa_atexit`'
H38BCAF8DE61E: '通过__cxa_atexit降低@llvm.global_dtors'
# 'Lower AArch64 MachineInstrs after legalization'
HAA249D8E7311: '在合法化后降低AArch64机器指令'
# 'Lower Alloca'
H607A1E54E99B: '降低Alloca'
# 'Lower GPU ctor / dtors to globals on the device.'
HAFC608781787: '将GPU的构造函数/析构函数降级为设备上的全局变量。'
# 'Lower MASSV entries'
HA1CC2E7E8DB7: '降低MASSV条目'
# "Lower SwitchInst's to branches"
H254491D92394: '将SwitchInst转换为分支指令'
# 'Lower Unreachable'
H28B0408D99E5: '降低Unreachable'
# 'Lower aggregate copies, and llvm.mem* intrinsics into loops'
HF50CBF4651A2: '将聚合复制以及循环中的llvm.mem*内建函数转换为非原子形式'
# 'Lower all intrinsic procedure implementation in their own functions'
H898AB0478AF6: '将所有内建过程实现降级到独立的函数中'
# 'Lower allocations to fortran runtime calls'
H567EFB84A4D9: '将分配操作降级为Fortran运行时调用'
# 'Lower arguments (NVPTX)'
H0BEAE5323F8F: '降低参数（NVPTX）'
# 'Lower atomic intrinsics to non-atomic form'
H691AF9D6E735: '将原子内建函数转换为非原子形式'
# 'Lower atomics of local memory to simple load/stores'
H26EEFC4DB3B1: '将本地内存的原子操作转换为简单的加载/存储'
# 'Lower bound for a buffer to be considered for stack protection'
HD34EE96BB584: '视为栈保护时的缓冲区下限'
# 'Lower ctors and dtors for AMDGPU'
HF7F8D40F075B: '为AMDGPU降级构造函数和析构函数'
# 'Lower ctors and dtors for NVPTX'
HFEBDC177145F: '为NVPTX降级构造函数和析构函数'
# 'Lower interleaved memory accesses to target specific intrinsics'
H47470ECDFD4E: '将交错内存访问转换为目标特定的内建函数'
# 'Lower invoke and unwind, for unwindless code generators'
H0DB5191C7AE1: '为无展开代码生成器降级调用和展开'
# 'Lower kernel argument loads in IR pass'
H46087569AE6A: '在IR pass中降低内核参数加载'
# 'Lower thread local variables'
HCFB0F36689FE: '降级线程局部变量'
# 'Lower threshold (in bytes) for widening to HVX vectors'
H2F815B7CEA99: '扩展为HVX向量的最小阈值（字节）'
# 'Lower to high level FIR'
H5AA0AFC0202E: '降级到高级FIR'
# 'Lower uses of LDS variables from non-kernel functions'
H08631E6900A9: '从非kernel函数中降低LDS变量的使用'
# 'Lower variables reachable from one kernel, otherwise abort'
H53F0B2E74B9F: '可从一个内核访问的变量将被展开，否则中止'
# 'Lower via HLFIR transformational intrinsic operations such as hlfir.sum'
H6FB7E3DD0B99: '通过HLFIR转换内建操作（如hlfir.sum）进行降级'
# 'Lower via mixture of above strategies'
HC2846B7FC01C: '通过上述策略的混合方式展开'
# 'Lower via module struct'
HA8D215D9A1DE: '通过模块结构展开'
# 'Lower via table lookup'
HDC139AA56721: '通过表查找展开'
# 'Lowers br_unless into inverted br_if'
H7B5FDAFDDAB0: '将br_unless转换为反向的br_if'
# 'M68k Assembly Printer'
HC2BE99D7AAA9: 'M68k 汇编打印器'
# 'M68k DAG->DAG Pattern Instruction Selection'
H81D40D6EAF4E: 'M68k DAG->DAG 模式指令选择'
# 'M68k MOVEM collapser pass'
H0AB275B2A2C5: 'M68k MOVEM 折叠 pass'
# 'M68k PIC Global Base Reg Initialization'
HD01B16D18C62: 'M68k PIC 全局基寄存器初始化'
# 'M68k pseudo instruction expansion pass'
H8C1C2FF3E960: 'M68k 伪指令扩展 pass'
# 'MC Options'
HF844BA7E67B9: 'MC 选项'
# 'MCJIT'
H06F256016480: 'MCJIT'
# 'MIPS DAG->DAG Pattern Instruction Selection'
H4A85ADA9A35B: 'MIPS DAG->DAG 模式指令选择'
# 'MIPS Specific: Compact branch policy.'
HDB7172F0C6EB: 'MIPS专用：紧凑分支策略'
# "MIPS: Don't trap on integer division by zero."
H3C2E18133FF5: 'MIPS：禁止在整数除以零时触发异常。'
# 'MIPS: Emit R_{MICRO}MIPS_JALR relocation with jalr'
HED32A15E03DE: 'MIPS：在jalr指令中使用R_{MICRO}MIPS_JALR重定位'
# 'MIPS: Expand all branches to long format.'
H441E04A7504F: 'MIPS：将所有分支展开为长格式。'
# 'MIPS: Skip branch expansion pass.'
HDA9370733E14: 'MIPS: 跳过分支扩展pass。'
# 'MIPS: Try to allocate variables in the following sections if possible: .rodata, .sdata, .data .'
HE9B7319D8937: 'MIPS：尽可能将变量分配到以下段中：.rodata, .sdata, .data 。'
# 'MIPS: Use gp_rel for data that is not defined by the current object.'
HD75E517CA71E: 'MIPS：对当前对象未定义的数据使用gp_rel。'
# 'MIPS: Use gp_rel for object-local data.'
H545674F997F2: 'MIPS：对对象本地数据使用gp_rel。'
# 'MIPS: permit tail calls.'
H0C7FED214ED3: 'MIPS：允许尾调用。'
# 'MIR Printer'
H94EFB069787F: 'MIR 打印器'
# 'MISSED'
HD46F0E6CE802: 'MISSED'
# 'MLIR CPU execution driver\n'
H6CE30C11490B: 'MLIR CPU 执行驱动程序\n'
# 'MLIR LSP Language Server'
HC4C223FFD5B8: 'MLIR LSP 语言服务器'
# 'MLIR test case query tool.\n'
H55F5673383F5: 'MLIR 测试用例查询工具。\n'
# 'MLIR test case reduction tool.\n'
H51C59AF94F1B: 'MLIR 测试用例精简工具。\n'
# 'MS-style inline assembly is not available: %0'
H730B2A8B0BD8: 'Microsoft风格的内联汇编不可用：%0'
# 'MSF Container Options'
H3C329400C4C7: 'MSF 容器选项'
# 'MSF File Options'
H4EFCF40C1C07: 'MSF 文件选项'
# 'MSP430 Assembly Printer'
HCA8BC34B7977: 'MSP430 汇编打印器'
# 'MSP430 DAG->DAG Pattern Instruction Selection'
H9B855DBB6F56: 'MSP430 DAG->DAG 模式指令选择'
# 'MVE gather/scattering lowering pass'
HEFE04D3A4063: 'MVE gather/scatter降级Pass'
# 'MVE lane interleaving'
H439E688DEBCA: 'MVE 通道交错'
# 'MVE tail-predication pass options'
H401525ED37E3: 'MVE尾预测向量优化选项'
# 'Mach-O: dump the raw contents of the listed segments instead of parsing them:'
HD2ADEEA8E714: 'Mach-O：转储以下段的原始内容而不是解析它们：'
# 'Machine Block Frequency Analysis'
H7E1FF2D34591: '机器指令级块频率分析'
# 'Machine Branch Probability Analysis'
HDAEAA64E78E7: '机器指令级分支概率分析'
# 'Machine CFG Printer Pass'
HEFF257D542EC: '机器指令级控制流图打印Pass'
# 'Machine Check Debug Module'
H5340142C3573: '机器指令级检查调试模块'
# 'Machine Common Subexpression Elimination'
H4C5AC03D0280: '机器指令级公共子表达式消除'
# 'Machine Copy Propagation Pass'
H4162739F0E51: '机器指令级复制传播Pass'
# 'Machine Cycle Info Analysis'
H573F9920FA64: '机器指令级周期信息分析'
# 'Machine Debugify Module'
H1918B0E46C7D: '机器指令级模块调试化'
# 'Machine Dominance Frontier Construction'
HACFFF417BF5C: '机器指令级支配边界构造'
# 'Machine Function Outliner'
HEAF804C2398F: '机器指令级函数提取Pass'
# 'Machine Function Printer'
H5377EFCC5465: '机器指令级函数打印Pass'
# 'Machine InstCombiner'
H33E9EB463E41: '机器指令级指令窥孔优化器'
# 'Machine Instruction Scheduler'
H83994F7A225C: '机器指令级指令调度器'
# 'Machine Late Instructions Cleanup Pass'
H85C102FDCCD8: '机器指令级后期指令清理Pass'
# 'Machine Loop Invariant Code Motion'
H4BBB4B53869D: '机器指令级循环不变代码移动'
# 'Machine Module Information'
HD424C5585BBC: '机器指令级模块信息'
# 'Machine Natural Loop Construction'
H18E1BBE724BC: '机器指令级自然循环构造'
# 'Machine Sanitizer Binary Metadata'
H981195858AEF: '机器指令级sanitizer二进制元数据'
# 'Machine Strip Debug Module'
HC906EF4D8D67: '机器指令级剥离调试模块'
# 'Machine Trace Metrics'
HD6F5807E2725: '机器指令级跟踪指标'
# 'Machine Uniformity Info Analysis'
HF8ED9A64EFA7: '机器指令级统一性信息分析'
# 'Machine code sinking'
H8D9C4D604139: '机器指令级代码下沉'
# 'Machine instruction scheduler to use'
H6D20879B4B16: '使用的机器指令级指令调度器'
# 'MachineDominator Tree Construction'
H0EB86F56D320: '机器指令级支配树构造'
# 'MachineLICM should avoid speculation'
HA9CBAFDEBFAA: '机器指令级LICM 应避免推测'
# 'MachineLICM should hoist even cheap instructions'
H98697F2D8341: '机器指令级LICM 应提升甚至低成本指令'
# 'MachinePostDominator Tree Construction'
H556CF668A622: '机器指令级后向支配树构造'
# 'Main file name to use for debug info and source if missing'
H28B54D392A83: '若缺失则用于调试信息和源文件的主文件名'
# 'Make -gen-asm-parser emit assembly parser #N'
HE5BFEAE0A31B: '使 -gen-asm-parser 发射汇编解析器 #N'
# 'Make -gen-asm-writer emit assembly writer #N'
H1EC4E0DFB493: '使 -gen-asm-writer 发射汇编生成器 #N'
# 'Make StdCall calling convention the default'
H597E577C2DF9: '将StdCall调用约定设为默认'
# 'Make all profile counter updates atomic (for testing only)'
HF170445DE3AF: '使所有配置文件计数器更新原子化（仅用于测试）'
# 'Make an absence of debug location information explicit.'
H9B828535ADE5: '使调试位置信息的缺失显式化'
# 'Make assembler not emit warnings'
HE1F052382E9E: '禁止汇编器输出警告'
# 'Make assembler warnings fatal'
HE5A6B0140C8A: '将汇编器警告设为致命错误'
# 'Make char type unsigned'
H0811C60DAE54: '将char类型设为无符号'
# 'Make counter updates atomic'
HF0DF6FDD3F46: '使计数器更新原子化'
# 'Make small offsets be this amount for testing purposes'
HA8D9F86D01B4: '使小偏移量为该数量（仅用于测试）'
# 'Make the jump table addresses canonical in the symbol table'
H96E8C8D2BE5D: '使跳转表地址在符号表中为规范形式'
# 'Make the x10 register call-saved (AArch64 only)'
HBF2D2B8AB5A7: '将x10寄存器设为调用保存（仅适用于AArch64）'
# 'Make the x11 register call-saved (AArch64 only)'
H361FBEA409F7: '将x11寄存器设为调用保存（仅适用于AArch64）'
# 'Make the x12 register call-saved (AArch64 only)'
HC22300ADD634: '将x12寄存器设为调用保存寄存器（仅限AArch64）'
# 'Make the x13 register call-saved (AArch64 only)'
H115B747B671D: '将x13寄存器设为调用保存寄存器（仅限AArch64）'
# 'Make the x14 register call-saved (AArch64 only)'
H3E53A0765B94: '将x14寄存器设为调用保存寄存器（仅限AArch64）'
# 'Make the x15 register call-saved (AArch64 only)'
HBD1C266220AD: '将x15寄存器设为调用保存寄存器（仅限AArch64）'
# 'Make the x18 register call-saved (AArch64 only)'
HFB92CC39C02E: '将x18寄存器设为调用保存寄存器（仅限AArch64）'
# 'Make the x8 register call-saved (AArch64 only)'
H346589ED29E7: '将x8寄存器设为调用保存寄存器（仅限AArch64）'
# 'Make the x9 register call-saved (AArch64 only)'
H2A86BF8B5845: '将x9寄存器设为调用保存寄存器（仅限AArch64）'
# 'Make time trace capture verbose event details (e.g. source filenames). This can increase the size of the output by 2-3 times'
HAFFB278A14B8: '启用时间追踪捕获的详细事件信息（例如源文件名）。这可能会使输出体积增大 2-3倍'
# 'Mangling number exceeds limit (65535)'
HB23269E224B2: '编码的数字超过限制（65535）'
# 'Manifest Attributor internal string attributes.'
H94BF7FE1AB16: '显示 Attributor 内部字符串属性'
# 'Manually specify the CUDA feature to use'
HDDA17BF1758B: '手动指定要使用的CUDA特性'
# 'Map file source paths in debug info'
H1AD32AEEC75F: '在调试信息中映射文件源路径'
# 'Mapping between default visibility and export'
H9B100E19B599: '默认可见性与导出之间的映射'
# 'Margin representing the unused percentage of the register pressure limit'
HC98A7EB598BA: '表示寄存器压力限制未使用百分比的余量'
# 'Mark <function> as being replaceable by the Windows kernel loader'
HE4564C872616: '将 <function> 标记为可被Windows内核加载器替换'
# 'Mark code section jump table data regions.'
H820E75B4A88C: '标记代码段跳转表数据区域'
# 'Mark cold functions with minsize.'
H17C76AA34906: '用 minsize 标记冷函数。'
# 'Mark cold functions with optnone.'
H16FE57B8D4DF: '用 optnone 标记冷函数。'
# 'Mark cold functions with optsize.'
H10A3EEBA4167: '用 optsize 标记冷函数。'
# 'Mark intrinsics that match the specified regexp as taking alias.scopes, noalias, and tbaa metadata'
H2D0DBCB8116B: '将匹配指定正则表达式的内建函数标记为使用 alias.scopes、noalias 和 tbaa 元数据'
# 'Mark intrinsics that match the specified regexp as taking an access group metadata'
HFCB2F343E2E0: '将匹配指定正则表达式的内建函数标记为带有访问组元数据'
# 'Mark outline function calls with ColdCC'
H4A447EEA400F: '用 ColdCC 标记外联函数调用'
# 'Mark some metadata features uncovered in functions with associated no_sanitize attributes.'
H04B3B3707DAA: '用关联的 no_sanitize 属性标记函数中未被覆盖的某些元数据特征'
# 'Mark the file as not needing an executable stack'
H4B702846F054: '标记该文件不需要可执行栈'
# 'Marked up disassembly of strings of hex bytes'
HEACC40B7D059: '带有注释的十六进制字节字符串反汇编'
# 'Match allocation profiles onto existing hot/cold operator new calls'
H6EADDFEDDECF: '将分配配置文件匹配到现有的 hot/cold operator new 调用'
# 'Match functions using namespace and edit distance'
HE4F3BAC888AB: '使用命名空间和编辑距离匹配函数'
# 'Match functions with call graph'
HBB25B5D67EE6: '通过调用图匹配函数'
# 'Match profile with function hash'
H34EA8794C102: '通过函数哈希匹配配置文件'
# 'Match string for rename'
HFCC0109CD543: '重命名用匹配字符串'
# 'Max #stores to inline memcpy'
HD503383C20D0: '内联memcpy的最大存储数量'
# 'Max #stores to inline memmove'
HBA55FF5D30C1: '内联memmove的最大存储数量'
# 'Max #stores to inline memset'
H2710D6276878: '内联memset的最大存储数量'
# 'Max PHIs in BB to duplicate for jump threading'
H877E847520D6: '为跳跃线程化可复制的基本块中Phi节点的最大数量'
# 'Max average trip count which will cause loop peeling.'
HF3BB048901AF: '导致循环剥皮的最大平均迭代次数'
# 'Max block size to duplicate for jump threading'
HBFBAF7D2C906: '为跳跃线程化可复制的最大块大小'
# 'Max coefficients in AddRec during evolving'
H3496AC43AF41: '在演化过程中AddRec中的最大系数数'
# 'Max count of stack frame shrink-wraps'
H837664B5CADB: '栈帧收缩的最大次数'
# 'Max depth to recursively search for missing frames through tail calls.'
HF33980EA2977: '通过尾调用递归搜索缺失帧的最大深度'
# 'Max integer bitwidth to consider in float2int(default=64)'
H564282CBC7AC: '在float2int中考虑的最大整数位宽（默认=64）'
# 'Max num VGPRs for whole-wave register allocation.'
H7B8CA4EA95B5: '波级寄存器分配的最大VGPR数量'
# 'Max num uses visited for identifying load invariance in loop using invariant start (default = 8)'
H482EC7115683: '使用不变式起始点在循环中识别不变式载入时访问的最大使用次数（默认=8）'
# 'Max number counter promotions per loop to avoid increasing register pressure too much'
H57369D9DCC7A: '每个循环允许的计数器提升最大次数以避免寄存器压力过大'
# 'Max number of BBs to explore for reachability analysis'
H59AE85966A2A: '可达性分析中探索的最大基本块数量'
# 'Max number of VRegs allowed to pass GC pointer meta args in'
HFCD4D70A5FD8: '允许通过VRegs传递GC指针元参数的最大数量'
# 'Max number of address users to look at'
H5E86D74534B7: '要检查的最大地址用户数量'
# 'Max number of allowed counter promotions'
H870A811CD7E4: '允许的计数器提升最大数量'
# 'Max number of annotations for a single indirect call callsite'
HEA902A4CD336: '单个间接调用调用点的注释最大数量'
# 'Max number of basic blocks on the path between hoisting locations (default = 4, unlimited = -1)'
H48EFC5F46396: '在提升位置之间的路径上基本块的最大数量（默认值=4，无限制=-1）'
# 'Max number of blocks searched to find a threading path'
HF1261B57416B: '搜索以寻找线程路径的基本块最大数量'
# 'Max number of blocks to be partially inlined'
H7AAFBCD2FD5C: '要部分内联的基本块最大数量'
# 'Max number of blocks visited while enumerating paths around a switch'
H3917E93C3F69: '在枚举开关周围的路径时访问的基本块最大数量'
# "Max number of blocks we're willing to speculate on (and recurse into) when deducing if a value is fully available or not in GVN (default = 600)"
HCC0B004EA3EE: '在GVN中推断某个值是否完全可用时，愿意推测（并递归进入）的基本块最大数量（默认值=600）'
# 'Max number of dependences to attempt Load PRE (default = 100)'
HAEF9EFC0D587: '尝试Load PRE的依赖关系最大数量（默认值=100）'
# 'Max number of devirtualizations for devirt module pass'
H37CF7FA70B53: '虚函数解除虚化模块Pass的最大迭代次数'
# 'Max number of duplications by CHR for a region'
HB5C21E0295E9: 'CHR为某个区域进行复制的最大次数'
# 'Max number of instructions to hoist (default unlimited = -1)'
H1E95E88763B1: '要提升的指令最大数量（默认无限制=-1）'
# 'Max number of instructions to scan for aggressive instcombine.'
H5E9EDAFCAA29: '为激进指令组合扫描的指令最大数量'
# 'Max number of instructions to scan for vector combining.'
H596CAD742579: '为向量组合扫描的指令最大数量'
# 'Max number of instructions to scan in each basic block in GVN (default = 100)'
H8FA4F608C594: '在GVN的每个基本块中扫描的指令最大数量（默认值=100）'
# 'Max number of iterations to be peeled from a loop, such that fusion can take place'
HA1B7957932D5: '从循环中剥落的迭代次数最大值，以便进行融合'
# 'Max number of iterations to prefetch ahead'
H74DE81E5BEDC: '预取的迭代次数最大值'
# 'Max number of memchecks allowed per eliminated load on average'
H929763545CE5: '平均每个被消除的加载允许的内存检查最大数量'
# 'Max number of memory uses to explore during partial unswitching analysis'
H5E2B4A7FE9D0: '在部分反向分支分析期间探索的内存使用次数最大值'
# 'Max number of mux expansions'
H413CD17EDBFC: '多路扩展的最大数量'
# 'Max number of partial inlining. The default is unlimited'
HEF03ECFDE4EE: '部分内联的最大数量。默认值为无限制'
# 'Max number of paths enumerated around a switch'
H733A7744C96C: '在 switch 语句周围枚举的路径的最大数量'
# 'Max number of precise value annotations for a single memopintrinsic'
H43400B846308: '单个内存操作固有函数 (memopintrinsic) 的精确值注释的最大数量'
# 'Max number of predecessors to consider tail merging'
H077931C4B5A6: '考虑尾合并的前驱节点的最大数量'
# 'Max number of promotions for a single indirect call callsite'
H1160EEB59410: '单个间接调用调用点 (callsite) 的提升次数的最大数量'
# 'Max number of promotions for a single indirect call callsite in sample profile loader'
H05F78FEA2FAF: '在采样配置文件加载器中，单个间接调用调用点 (callsite) 的提升次数的最大数量'
# 'Max number of promotions for this compilation'
HBE53E07F67D3: '本次编译的提升次数的最大数量'
# 'Max number of segment coalescings'
H76831528316D: '合并段的最大数量'
# 'Max number of statepoints allowed to pass GC Ptrs in registers'
HBF13380980F5: '允许通过寄存器传递垃圾回收指针 (GC Ptrs) 的状态点的最大数量'
# 'Max number of stores to be predicated behind an if.'
HC838F9655113: '在 if 语句之后有条件判断的存储操作的最大数量'
# 'Max number of visited instructions when trying to find dominating value of select dependency (default = 100)'
H9E6FEA476B9C: '在尝试查找选择依赖项的支配值时遍历的指令数量的最大值 (默认值 = 100)'
# 'Max number of vtables annotated for a vtable load instruction.'
H1F81EEE11A92: '单个虚函数表加载指令 (vtable load) 的虚表注释数量的最大值'
# 'Max results to display'
HB76D3DEE4518: '显示结果的最大数量'
# 'Max size of a block which is still considered small enough to thread through'
H36A8554A7A20: '仍被视为足够小以进行线程处理的块的最大大小'
# 'Max total number of preprocessed tokens for -Wmax-tokens.'
HC95A06179FBD: '预处理令牌的最大总数（用于-Wmax-tokens）'
# 'Maximal number of attributor iterations.'
HD46DDBA87859: '属性器 (attributor) 迭代的最大次数'
# 'Maximal number of callees specialized for a call base'
HA4B29DB6599A: '为调用基 (call base) 专门化的被调用函数的最大数量'
# 'Maximal number of chained initializations (to avoid stack overflows)'
H907C6E291577: '链式初始化的最大数量 (避免堆栈溢出)'
# 'Maximal number of fixpoint iterations.'
HD4791B6062DE: '不动点迭代的最大次数'
# 'Maximal number of uses to explore.'
H3B80E7F90921: '要探索的用法的最大数量'
# 'Maximize bandwidth when selecting vectorization factor which will be determined by the smallest type in loop.'
H1FD207584DE2: '选择向量化因子时最大化带宽，该因子将由循环中最小的类型确定。'
# 'Maximize the band depth (yes/no)'
H16AE46F8C5D0: '最大带深度（是/否）'
# 'Maximum SLP vectorization factor (0=unlimited)'
HFDC1B422DFB3: '最大SLP向量化因子（0=无限制）'
# 'Maximum alloca size to use for inline cost'
H85D97309D239: '内联成本使用的alloca最大尺寸'
# 'Maximum allowed iterations to unroll under pragma unroll full.'
H369A26E92574: '在pragma unroll full下允许的最大展开迭代次数。'
# 'Maximum amount of memory to use. 0 disables check. Defaults to 400MB (800MB under valgrind, 0 with sanitizers).'
HD9F29E050069: '允许使用的最大内存容量。0表示禁用检查。默认为 400MB（在valgrind下为 800MB，使用sanitizers时为 0）。'
# 'Maximum amount of nodes to process while searching SCEVUnknown Phi strongly connected components'
H733D2DA20417: '在搜索SCEVUnknown Phi强连通分量时处理节点的最大数量'
# 'Maximum amount of shared memory to use.'
H87E40E4A881F: '允许使用的共享内存最大容量。'
# 'Maximum array size considered when doing a combine'
HA910C2785634: '组合操作时考虑的最大数组尺寸'
# "Maximum block frequency, expressed as a percentage of caller's entry frequency, for a call site to be considered cold for enabling coldcc"
H39E2E109FC72: '以调用者入口频率的百分比表示的块频率最大值，用于将调用位置标记为冷调用从而启用冷调用约定'
# "Maximum block frequency, expressed as a percentage of caller's entry frequency, for a callsite to be cold in the absence of profile information."
HDD8AD6EFCAAB: '在缺乏性能分析信息时，以调用者入口频率的百分比表示的块频率最大值，用于将调用位置标记为冷调用'
# 'Maximum byte size to consider promote alloca to vector'
HDC8E89EF71AD: '考虑将alloca提升为向量的最大字节大小'
# 'Maximum codesize growth allowed per function'
H78609FC7BCF8: '每个函数允许的代码大小最大增长'
# 'Maximum cost accepted for the transformation'
H83731968FC73: '允许的变换成本最大值'
# 'Maximum cost multiplier of TCC_expensive for the dependence slice of a cold operand to be considered inexpensive.'
H6DFC35CF6D50: '冷操作数依赖切片的TCC_expensive成本乘数最大值，使其被视为低成本。'
# 'Maximum cost of combining conditions when folding branches'
H781B5E7517C1: '折叠分支时合并条件的最大成本'
# 'Maximum depth allowed for the recursive algorithm used to explore MIV direction vectors.'
H1A8D3D915439: '用于探索MIV方向向量的递归算法的最大递归深度'
# 'Maximum depth for recursive loop guard collection'
H30DB13FC6626: '循环守卫收集的最大递归深度'
# 'Maximum depth of loop nest considered for the transform'
HB49D9378BE58: '变换时考虑的最大循环嵌套深度'
# 'Maximum depth of recursive SCEV complexity comparisons'
H91C70931DE15: '递归SCEV复杂度比较的最大深度'
# 'Maximum depth of recursive SCEV operations implication analysis'
H11D5122A9F0A: '递归SCEV操作蕴含分析的最大深度'
# 'Maximum depth of recursive SExt/ZExt/Trunc'
HC985D30DDFD4: '递归SExt/ZExt/Trunc的最大深度'
# 'Maximum depth of recursive arithmetics'
HAE0E4B668E3D: '递归算术运算的最大深度'
# 'Maximum depth of recursive constant evolving'
H729F236B8A12: '递归常量演化（constant evolving）的最大深度'
# 'Maximum depth of recursive value complexity comparisons'
HF2B077915503: '递归值复杂度比较的最大深度'
# 'Maximum distance between a tfr feeding a store we consider the store still to be newifiable'
HA3A3AE754AA0: '在认为存储仍可newifiable时，tfr与存储之间的最大距离'
# 'Maximum distance of loop carried dependences that are handled'
HC5B916D346C8: '处理的循环相关依赖的最大距离'
# 'Maximum factor by which expected native size may increase before blocking any further inlining.'
H1A06B982376C: '内联过程中允许原生代码尺寸增加的最大倍数，超过该值将阻止进一步内联。'
# 'Maximum factor for an interleaved access group (default = 8)'
HCB89C86317C6: '交织访问组的最大因子（默认=8）'
# 'Maximum frequency of path for an operand to be considered cold.'
H229E4B064589: '将操作数视为冷路径的最大路径频率'
# 'Maximum global merge offset'
HDC72CED70E8A: '全局合并偏移的最大值'
# 'Maximum input DBG_VALUE insts supported by debug range extension'
H5626CEECD47D: '调试范围扩展支持的输入DBG_VALUE指令最大数量'
# 'Maximum input basic blocks before DBG_VALUE limit applies'
H05C4A13D67D8: '应用DBG_VALUE限制前的最大基本块数量'
# 'Maximum instructions to analyze per moved initialization'
H28DB4399F2D2: '每个移动初始化分析的最大指令数'
# 'Maximum instructions to consider tail duplicating'
H4A94E8A5FC9B: '考虑尾部复制的最大指令数'
# 'Maximum instructions to consider tail duplicating blocks that end with indirect branches.'
H24A02DE8C7F1: '考虑尾部复制间接分支终止块的最大指令数'
# 'Maximum interleave factor for MVE VLDn to generate.'
H213FF805CEF2: '生成MVE VLDn时的最大交织因子'
# 'Maximum length of a memory clause, instructions'
H7D54283EC716: '内存子句的最大长度（以指令为单位）'
# 'Maximum length of dependent chains to hoist (default = 10, unlimited = -1)'
HC4AAAE7F5958: '提升依赖链的最大长度（默认=10，无限制=-1）'
# 'Maximum length of recurrence chain when evaluating the benefit of commuting operands'
H84087A27148D: '求值操作数交换收益时递归链的最大长度'
# 'Maximum nesting level for parentheses, brackets, and braces'
H62138B784DC3: '括号、方括号和大括号的最大嵌套层级'
# 'Maximum num basic blocks before debug info dropped'
HF7FD1D6C6637: '在丢弃调试信息前的基本块最大数量'
# "Maximum number of 'operator->'s to call for a member access"
H2363B77A7D06: "成员访问时调用的 'operator->' 的最大数量"
# 'Maximum number of BBs allowed in a function after inlining (compile time constraint)'
H02A0499B6C90: '内联后函数中允许的最大基本块数（编译时间约束）'
# 'Maximum number of ISL operations to invest for known analysis; 0=no limit'
H1E380A641D89: '已知分析中可投入的ISL操作最大数量；0表示无限制'
# 'Maximum number of base-updates to check generating postindex.'
HA9EAB9913B99: '生成后索引时需要检查的基础更新最大数量'
# 'Maximum number of basic blocks in a function to run ext-TSP block placement.'
HEAD0A5AFAB52: '执行扩展-TSP块布局时函数中的最大基本块数'
# 'Maximum number of branches in the accumulator tree'
HE163718A2F82: '累积树中的最大分支数'
# 'Maximum number of call targets per call site to enable branch funnels'
H2188104092EB: '启用分支漏斗的每个调用点允许的最大调用目标数'
# 'Maximum number of comparisons done when trying to merge runtime memory checks. (default = 100)'
H9FAF3F7149E1: '启用分支漏斗的每个调用点允许的最大调用目标数'
# 'Maximum number of conditions in MC/DC coverage'
H6395D2BBFABE: 'MC/DC覆盖率中条件的最大数量'
# 'Maximum number of cycles in the timeline view, or 0 for unlimited. Defaults to 80 cycles'
H17E412044F75: '时间线视图中的最大周期数或 0 表示无限制，默认 80 周期'
# 'Maximum number of dataflow edges to traverse when evaluating the benefit of commuting operands'
H635DA15AA164: '求值交换操作数收益时遍历的数据流边最大数量'
# 'Maximum number of dependences collected by loop-access analysis (default = 100)'
H498CAFF81EAD: '循环访问分析中收集的依赖关系最大数量（默认=100）'
# 'Maximum number of instruction to generate when lowering constant multiplication instead of calling library function [default=14]'
HA8EBACF52A9C: '将常量乘法转换为库函数调用前生成的指令最大数量 [默认=14]'
# 'Maximum number of instructions for ObjectSizeOffsetVisitor to look at'
H87E9B845C1F1: '对象大小偏移访问器可查看的指令最大数量'
# 'Maximum number of instructions per speculated block.'
H9257791CBCD4: '每个推测块可生成的指令最大数量'
# 'Maximum number of isl operations to invest for lifetime analysis; 0=no limit'
HEF3BE03FC67D: '生存期分析中可投入的ISL操作最大数量；0表示无限制'
# 'Maximum number of iterations SCEV will symbolically execute a constant derived loop'
H2F35B8D580F6: 'SCEV将符号执行的常量派生循环的最大迭代次数'
# 'Maximum number of iterations to go through when propagating sample block/edge weights through the CFG.'
H76A911EDD837: '通过CFG传播样本块/边权重时遍历的最大迭代次数'
# 'Maximum number of iterations to print in timeline view'
H61122E3872D7: '时间线视图中打印的最大迭代次数'
# 'Maximum number of iterations we keep dismantling potential values.'
HACE4628A8A6D: '持续拆解潜在值时保留的最大迭代次数'
# 'Maximum number of load-store instructions that should be handled in the dependency matrix. Higher value may lead to more interchanges at the cost of compile-time'
HC041FD354820: '依赖矩阵中应处理的加载-存储指令最大数量。数值越大可能提升循环变换效果但增加编译时间'
# 'Maximum number of memory instructions to place in the same hard clause'
H0D0A665E7C31: '同一硬约束条款中可放置的内存指令最大数量'
# 'Maximum number of parameters for a split function'
H21349A957046: '拆分函数允许的最大参数数量'
# 'Maximum number of physical registers which can be used for register mappings'
HDA7C27C95D63: '可用于寄存器映射的物理寄存器最大数量'
# 'Maximum number of potential values to be tracked for each position.'
H955218AAB793: '每个位置可追踪的潜在值的最大数量'
# 'Maximum number of predicated jumps to be converted to New Value Jump'
HF3F6203AD570: '可转换为New Value Jump的条件跳转的最大数量'
# 'Maximum number of prefixes to use for padding'
H7458F00CCA26: '用于填充的前缀最大数量'
# 'Maximum number of ptr states the optimizer keeps track of'
HB7E5E43FBE1D: '优化器跟踪的指针状态最大数量'
# 'Maximum number of replacements'
H6F2E3DB8E40F: '替换的最大数量'
# "Maximum number of results to stream as a response to single request. Limit is to keep the server from being DOS'd. Defaults to 10000."
H8CFDD20881AA: '单个请求响应中流式传输的结果最大数量。限制是为了防止服务器遭受DOS攻击。默认值为 10000。'
# 'Maximum number of rows to keep in constraint system'
H99BCC72F0CE0: '约束系统中保留的行数最大值'
# 'Maximum number of simplification steps in HLIR'
H8BBD18037D20: 'HLIR中的简化步骤最大数量'
# 'Maximum number of split partitions'
HFE60C6DE65ED: '拆分分区的最大数量'
# 'Maximum number of test vectors in MC/DC coverage'
HAFD4B8816F42: 'MC/DC覆盖率中测试向量的最大数量'
# 'Maximum number of threads (for emulation thread-local storage)'
H0870E5A4F08E: '最大线程数（用于模拟线程局部存储）'
# 'Maximum number of threads to use to process chunks. Set to 1 to disable parallelism.'
H35B2504140C1: '用于处理块的最大线程数。设置为 1 可禁用并行处理。'
# 'Maximum number of times to run the full set of delta passes (default=5)'
H2DC8A9AE4C6B: '运行完整delta passes集的次数最大值（默认为 5）'
# 'Maximum number of undroppable users for instruction sinking'
H51772496A3DD: '指令下沈（instruction sinking）不可删除用户的最大数量'
# 'Maximum number phis to handle in intptr/ptrint folding'
H8EB042BFB02C: 'intptr/ptrint折叠中处理的phi节点最大数量'
# 'Maximum of xors'
H1D5D83FA6AD6: 'XOR操作的最大数量'
# 'Maximum optimization to perform'
HE99B191AFFD1: '可执行的优化级别最大值'
# 'Maximum predecessors (maximum successors at the same time) to consider tail duplicating blocks.'
HEA56889501D6: '考虑尾部复制块的最大前驱（同时考虑的最大后继）数量'
# 'Maximum recursion depth when finding forked SCEVs (default = 5)'
H0BFBD51E5518: '查找分支SCEV时的最大递归深度（默认值为 5）'
# 'Maximum recursion level'
HE3B9BD0F99EA: '最大递归层级'
# 'Maximum search distance for definition of CR bit spill on ppc'
H3E64147E3DA7: 'ppc上CR位溢出定义的最大搜索距离'
# 'Maximum size for the name of non-global values.'
HD0F170A76DAC: '非全局值名称的最大尺寸'
# 'Maximum size of ALL constants to promote into a constant pool'
H601F886CFD14: '所有常量提升到常量池的最大尺寸'
# 'Maximum size of IFMap'
H36B1B6A77B2F: 'IFMap的最大尺寸'
# 'Maximum size of OrderedRegisterList'
H272C7A54D906: 'OrderedRegisterList的最大尺寸'
# 'Maximum size of constant to promote into a constant pool'
H64D76AF05D3E: '要提升到常量池的常量的最大尺寸'
# "Maximum size of range check type for which can be produced runtime overflow check of its limit's computation"
H186E992A3695: '可以产生其极限计算运行时溢出检查的范围检查类型的最大尺寸'
# 'Maximum stages allowed in the generated scheduled.'
H48FD271D1F26: '生成调度中允许的最大阶段数'
# 'Maximum successors (maximum predecessors at the same time) to consider tail duplicating blocks.'
H43B65927F125: '考虑尾部复制块时的最大后继（同时的最大前驱）数量'
# 'Maximum throughput from the decoders (instructions per cycle)'
H7563F8838724: '解码器的吞吐量（每周期指令数）的最大值'
# 'Maximum time a channel may stay idle until server closes the connection, in seconds. Defaults to 480.'
HAA88BB6FEBEE: '通道在服务器关闭连接前保持空闲的最大时间（秒）。默认为 480'
# 'Maximum users to visit in copy from constant transform'
H0BCD40F173F6: '常量转换中访问的最大用户数'
# 'Maximum vector size (in 32b registers) to use when promoting alloca'
HBBF17E62FD6E: '在提升alloca时使用的向量大小（以 32 位寄存器为单位）的最大值'
# 'May have atomic operations on fine-grained memory'
HADF7ECC58A34: '可能在细粒度内存上执行原子操作'
# 'May have atomic operations on remote memory'
H32B8F16B1079: '可能在远程内存上执行原子操作'
# 'Measure the parse tree'
HCE9EAC149D17: '测量解析树'
# 'Medium code model'
H72290D3E5AED: '中等代码模型'
# 'MemProf memory access profile'
H1BF9427AF0C9: 'MemProf 内存访问剖析'
# 'Member.'
H2A50D724340B: '成员。'
# 'Memory Dependence Analysis'
H4CBD5FC4ABBF: '内存依赖性分析'
# 'Memory SSA'
H3A3FEB09FB66: '内存SSA'
# 'Memory reference level analysis that distinguish access instructions in the same statement'
H0AE95D83B775: '区分同一语句中的访问指令的内存引用级别分析'
# 'Memory reference level analysis that distinguish accessed references in the same statement'
H4E1E23E6B24B: '区分同一语句中被访问的引用的内存引用级别分析'
# 'Merge all const globals without looking at uses'
H6449013A03CB: '不考虑使用情况合并所有常量全局变量'
# 'Merge and hoist M0 initializations'
H2D268DBDEF86: '合并并提升M0初始化'
# 'Merge clones before assigning functions'
H18C7B017FA56: '在分配函数前合并克隆'
# 'Merge context profiles before calculating thresholds.'
H1C9DF3097EF8: '在计算阈值前合并上下文配置文件'
# 'Merge context sample profiles whose count is below cold threshold'
HC6C3845D54A1: '合并计数低于冷阈值的上下文采样配置文件'
# 'Merge contiguous icmps into a memcmp'
H7D045C95D910: '将连续的icmp合并为memcmp'
# 'Merge disjoint stack slots'
HC48D29B2D11A: '合并不相交栈槽'
# 'Merge global variables'
HBC9C437F360A: '合并全局变量'
# "Merge past inlinee's profile to outline version if sample profile loader decided not to inline a call site. It will only be enabled when top-down order of profile loading is enabled. "
H647C9F0ED977: '如果采样配置文件加载器决定不内联调用站点，则将过去的内联函数配置文件合并到外部版本。仅在启用自上而下的配置文件加载顺序时启用此功能'
# 'Merge the given AST file into the translation unit being compiled.'
H044732F67319: '将给定的AST文件合并到正在编译的翻译单元中'
# "Method to generate ID's for compilation units for single source offloading languages CUDA and HIP: 'hash' (ID's generated by hashing file path and command line options) | 'random' (ID's generated as random numbers) | 'none' (disabled). Default is 'hash'. This option will be overridden by option '-cuid=[ID]' if it is specified."
HF56CB8DC51CB: "为CUDA和HIP单源offloading语言的编译单元生成ID的方法：'hash'（通过哈希文件路径和命令行选项生成ID） | 'random'（通过随机数生成ID） | 'none'（禁用）。默认是 'hash'。如果指定了选项 '-cuid=[ID]'，此选项将被覆盖。"
# 'MicroMips instruction size reduce pass'
H43AA98943979: 'MicroMips指令大小缩减pass'
# "Microsoft compiler version number to report in _MSC_VER (0 = don't define it (default))"
H84908CA49591: '在_MSC_VER中报告的Microsoft编译器版本号（0 = 不定义它（默认））'
# 'Middle half duplicate mode'
H18C80D21224E: '中间半重复模式'
# 'Middle half loop mode'
H43135A085735: '中间半循环模式'
# 'Min number of instructions to consider tail merging'
HCFE1247214B4: '考虑尾部合并的最小指令数'
# 'Min percent of cold bytes at a callsite to discard non-cold contexts'
HF5E8027EF436: '调用点处丢弃非冷上下文所需的最小冷字节百分比'
# 'Min percent of cold bytes matched to hint allocation cold'
HF5A0792EF995: '与冷分配提示匹配的冷字节最小百分比'
# 'Min percent of cold bytes to hint alloc cold during cloning'
H30A19A7158C7: '克隆期间提示分配冷字节的最小百分比'
# 'Min percent of max cold bytes for critical cold context'
HC9060B18CE7F: '关键冷上下文的最小最大冷字节百分比'
# 'Min stride to add prefetches'
H9E2620BA9D60: '添加预取的最小步长'
# 'MinGW specific. Disable support for automatic dllimport in code generation and linking'
H3256426D82B0: 'MinGW专用。禁用代码生成和链接中的自动dllimport支持'
# 'MinGW specific. Enable code generation support for automatic dllimport, and enable support for it in the linker. Enabled by default.'
H2BCAB89FF663: 'MinGW专用。启用代码生成对自动dllimport的支持，并在链接器中启用该支持。默认启用。'
# 'MinInstrCount strategy.'
H611D13E20CE8: 'MinInstrCount 策略。'
# 'Minimal Transform dialect driver\n'
H4CF75EEC17A9: '最小化转换方言驱动程序\n'
# 'Minimal common base load/store instructions triggering DS/DQ form preparation'
H0EEF17599CF6: '触发DS/DQ形式准备的最小公共基数加载/存储指令数量'
# 'Minimal common base load/store instructions triggering chain commoning preparation. Must be not smaller than 4'
H8810625AE483: '触发链式公共化准备的最小公共基数加载/存储指令数量。必须不小于 4'
# 'Minimize AVX to SSE transition penalty'
H8DBDD3BC94CA: '最小化AVX到SSE转换的惩罚'
# 'Minimize number of registers used'
H4957842A8433: '最小化使用的寄存器数量'
# 'Minimum BranchProbability to consider a region cold.'
HD5C5EDF501D8: '视为冷区域的最小BranchProbability'
# 'Minimum block executions to consider its BranchProbabilityInfo valid'
HC699EC9E0880: '有效BranchProbabilityInfo所需的最小块执行次数'
# "Minimum block frequency, expressed as a multiple of caller's entry frequency, for a callsite to be hot in the absence of profile information."
H7B3632E358D5: '在没有配置文件信息的情况下，使调用点成为热点所需的最小块频率（以调用者入口频率的倍数表示）'
# 'Minimum density for building a jump table in a normal function'
H0D43760047E0: '普通函数中构建跳转表所需的最小密度'
# 'Minimum density for building a jump table in an optsize function'
H6EFB80EE1C35: '优化大小的函数中构建跳转表所需的最小密度'
# 'Minimum depth of loop nest considered for the transform'
H277B1F275C2D: '考虑转换的循环嵌套的最小深度'
# 'Minimum distance between predicate definition and farther of the two predicated uses'
HBAA80BA0F268: '谓词定义与两个条件使用中较远者的最小距离'
# 'Minimum gain per loop (in cycles) threshold.'
H563FE7251C8B: '每个循环（以周期计）的最小收益阈值'
# 'Minimum length of accumulator chains required for the optimization to kick in'
HE6E58DA8C268: '启动优化所需的累积链的最小长度'
# 'Minimum number of extenders to trigger replacement'
HA7EB99ED5DCC: '触发替换所需的最小扩展器数量'
# 'Minimum number of similar functions with the same hash required for merging.'
H332DB9D9B554: '合并所需的相同哈希值的相似函数的最小数量'
# 'Minimum number of times a block must be executed to be retained.'
H78B91828296F: '块必须被执行的最小次数以保留'
# "Minimum priority, runs on idle CPUs. May leave 'performance' cores unused."
H2308F82368EA: '最低优先级，在空闲CPU上运行。可能会使‘performance’核心未被使用。'
# "Minimum profile count required for an optimization remark to be output. Use 'auto' to apply the threshold from profile summary"
H3D2B4D99467F: '输出优化备注所需的最小配置文件计数。使用 "auto" 应用来自配置文件摘要的阈值'
# "Minimum profile count required for an optimization remark to be output. Use 'auto' to apply the threshold from profile summary."
H05750FA1DE8F: '输出优化备注所需的最小配置文件计数。使用 "auto" 应用来自配置文件摘要的阈值'
# 'Minimum ratio comparing relative sizes of each outline candidate and original function'
H4C5E36FE2F68: '比较每个外联候选和原始函数相对大小的最小比率'
# 'Minimum relative gain per loop threshold (1/X). Defaults to 12.5%'
H2DECB545864A: '每个循环的最小相对收益阈值（1/X）。默认为 12.5%'
# 'Minimum time granularity (in microseconds) traced by time profiler'
H82ABB54FDFA0: '时间分析器跟踪的最小时间粒度（以微秒为单位）'
# 'Minimum type size in bits for breaking large PHI nodes'
HB05B1AF899B8: '用于拆分大型PHI节点的最小类型位宽'
# 'Mips Assembly Printer'
H033FCF512C08: 'Mips 汇编打印器'
# 'Mips VR4300 mulmul bugfix'
HBC6DCC9857CF: 'Mips VR4300 mulmul错误修复'
# 'Miscellaneous Options'
HE9A41E28CF82: '杂项选项'
# 'Missing debug location (gaps).'
HCFAF9A1705D6: '缺少调试位置（间隙）。'
# 'Mode for reading thread pointer'
H56EB4841FF26: '读取线程指针的模式'
# 'Mode of the RegBankSelect pass'
HC6D74CC5D13F: 'RegBankSelect pass的模式'
# 'Model read-only scalar values in the scop description'
HEF37BBE0A859: '在scop描述中建模只读标量值'
# 'Model the cost of loop rotation more precisely by using profile data.'
H5615ACF94C6A: '通过使用profile数据更精确地建模循环旋转的成本。'
# 'Modextract Options'
H29E9EFFE5231: 'Modextract 选项'
# 'Module & File Options'
HDFC5298823CB: '模块与文件选项'
# 'Module Options'
H15D7561EF70B: '模块选项'
# 'Module Summary Analysis'
H35F5D0BFCE0A: '模块摘要分析'
# 'Module Verifier'
HB268B018B769: '模块验证器'
# 'Module concatenation'
H521219EE1D9E: '模块级连接'
# 'Module extractor'
HDE0289089F3A: '模块提取器'
# 'Module summary index filename'
H3224F1E17512: '模块摘要索引文件名'
# 'Module summary info'
HCFDC7E39A72C: '模块摘要信息'
# 'Module.'
H9EC9858FCED5: '模块'
# 'Modulo Schedule test pass'
H9F5185006F74: '模调度测试Pass'
# 'Modulo Software Pipelining'
HC40B97D6B9FA: '模软件流水线'
# 'Move ARGUMENT instructions for WebAssembly'
H688758DE208F: '为WebAssembly移动参数指令'
# 'Move contextual profiling roots and the graphs under them in their own module.'
HC78C448BC37B: '将上下文剖析根及其下的图表移至它们自己的模块中。'
# 'Move the symbols with the given name. This will delete these symbols wherever they are originally defined, and make sure their linkage is External where they are imported. It is meant to be used with the name of contextual profiling roots.'
H50A29B7AC907: '移动具有给定名称的符号。这将删除它们在原始定义处的所有符号，并确保在导入时它们的链接性为External。此选项应与上下文剖析根的名称一起使用。'
# 'Move/duplicate certain instructions close to their use'
HD38286726698: '移动/复制某些指令靠近其使用位置'
# 'Multiplier to apply to threshold when determining whether or not to fold branch to common destination when vector operations are present'
HC6051096B6ED: '当存在vector operations时，决定是否折叠到常见目标分支时，应用到阈值上的乘数'
# 'Multiplier to bump up callsite threshold for previous inlining.'
H80636EF6462B: '上一次内联时调用点阈值的乘数'
# 'Multiplier to multiply cycle savings by during inlining'
H1D068428F9A5: '在内联过程中乘以cycle savings的乘数'
# 'Multiply the `import-instr-limit` threshold for cold callsites'
HC6AF6BE5F0E1: '为冷调用点将import-instr-limit阈值乘以'
# 'Multiply the `import-instr-limit` threshold for critical callsites'
HA6A6A6EE28A9: '为关键调用点将import-instr-limit阈值乘以'
# 'Multiply the `import-instr-limit` threshold for hot callsites'
H4850606E5CF1: '为热调用点将import-instr-limit阈值乘以'
# 'Must specify at least '
HEC0DF6B1AD3C: '必须至少指定 '
# 'My Pass Name'
H68A400666676: 'My Pass Name'
# 'N must be a power of two. Align loops to the boundary'
H2A7AB317ED00: 'N必须是 2 的幂次方。将循环对齐到边界'
# 'NVPTX Address space based Alias Analysis'
H9D1213E22820: 'NVPTX基于地址空间的别名分析'
# 'NVPTX Address space based Alias Analysis Wrapper'
HB227AE568CB7: 'NVPTX基于地址空间的别名分析包装器'
# 'NVPTX Assembly Printer'
H0111C7243DC7: 'NVPTX 汇编打印器'
# 'NVPTX DAG->DAG Pattern Instruction Selection'
HB23F4D978D1F: 'NVPTX DAG->DAG 模式指令选择'
# 'NVPTX Forward Params'
H3B9CC422F869: 'NVPTX参数前向Pass'
# 'NVPTX Peephole'
H5BF795D76A44: 'NVPTX窥孔优化'
# 'NVPTX ProxyReg Erasure'
HDFA70554F191: 'NVPTX代理寄存器擦除'
# 'NVPTX Specific: 0 use sqrt.approx, 1 use sqrt.rn.'
H11B08A79FA4D: 'NVPTX 特定：0使用sqrt.approx，1使用sqrt.rn。'
# 'NVPTX Specific: Disable generation of f16 math ops.'
HDAF968D22832: 'NVPTX 特定：禁用生成f16 math ops。'
# "NVPTX Specific: FMA contraction (0: don't do it 1: do it  2: do it aggressively"
HD36FDD8676CA: 'NVPTX 专用：FMA 收缩（0：不执行 1：执行 2：激进执行'
# 'NVPTX Specific: Override the precision of the lowering for f32 fdiv'
H1927850A3B01: 'NVPTX 特有：覆盖f32 fdiv降低精度的精度'
# 'NVPTX Specific: force 4-byte minimal alignment for byval params of device functions.'
H40664A3C3B0F: 'NVPTX 特定：强制设备函数的byval参数使用 4 字节最小对齐。'
# 'NVPTX Specific: schedule for register pressue'
H0940771EECAF: 'NVPTX 特定：根据寄存器压力进行调度'
# 'NVPTX Specific: whether to use lg2.approx for log2'
HDC539A3BEBE1: 'NVPTX 特定：是否使用lg2.approx进行log2运算'
# 'NVPTX Tag Invariant Loads'
HB8013F653097: 'NVPTX 标记不变加载'
# 'NVPTX target requires CUDA 9.2 or above; CUDA %0 detected'
HC81CA29CBF97: 'NVPTX 目标需要 CUDA 9.2 或更高版本；检测到 CUDA %0'
# 'NVVM reflection, enabled by default'
H0FD65ACF0E14: 'NVVM反射，默认启用'
# 'Name for native GCC compiler'
H0AD88C41A101: '本地GCC编译器的名称'
# 'Name for the section containing cold functions extracted by hot-cold splitting.'
H350954655BC3: '包含由hot-cold splitting提取的冷函数的段的名称。'
# 'Name of checks to match against'
HAD04C40729DF: '要匹配的检查项名称'
# 'Name of op to match on'
H9F76B5F57ED0: '要匹配的操作符名称'
# 'Name of project.'
HD47E84631ECF: '项目名称。'
# 'Name of the entry point transform symbol'
H9FE29477F41B: '入口点转换符号的名称'
# 'Name of the interesting-ness test to be run'
H01AA1C566B65: '要运行的有趣性测试名称'
# 'Name of the macro to be defined'
H74E9FD90F24A: '要定义的宏名称'
# 'Name of the macro to be defined -- ignored by mlir-pdll'
H03D44F059B30: '要定义的宏名称 -- 被mlir-pdll忽略'
# 'Name of the macro to be defined -- ignored by mlir-src-sharder'
H3F90161CF695: '要定义的宏名称 -- 被mlir-src-sharder忽略'
# 'Name of the split dwarf debug info file to encode in the object file'
HCFEFDA365E00: '要编码到目标文件中的split dwarf调试信息文件名称'
# 'Namespace.'
HD451EBBFFEAD: '命名空间。'
# 'Narrow LSR complex solution using expectation of registers number'
H13DBBF2C516C: '使用寄存器数量期望值缩小LSR复杂解'
# 'Narrow LSR search space by filtering non-optimal formulae with the same ScaledReg and Scale'
HBD4BDD760DFA: '通过过滤具有相同ScaledReg和Scale的非最优公式来缩小LSR搜索空间'
# 'Nary reassociation'
HAC5287C54D8E: 'N元重新关联'
# 'Natural Loop Information'
HB731CE00868C: '自然循环信息'
# 'Neon vector size must be 64 or 128 bits'
H97DBFE49CD6B: 'NEON向量大小必须为 64 或 128 位'
# 'Nested profile, the input should be CS flat profile'
HA55917D514EC: '嵌套配置文件，输入应为CS平面配置文件'
# 'Never'
H80C3052D33CC: '从不'
# 'Never Step Into.'
HA04C48D1B790: '从不单步步入。'
# 'Never detect stack use after return.'
HC4D92AB5F1A8: '从不检测返回后栈的使用。'
# 'Never dump input'
H182384737343: '从不转储输入'
# 'Never emit tail calls'
H295822EA6C7C: '从不生成尾调用'
# 'Never insert #include directives as part of code completion'
H6893E7F599D8: '在代码补全时从不插入#include指令'
# 'Never set the bit'
H77A3923DD75B: '从不设置该位'
# 'Never track the overflow bit.'
HF22B430EF914: '从不跟踪溢出位。'
# 'New FS discriminators encoding (incompatible with the original encoding)'
H525B7044D16E: '新的FS判别符编码（与原始编码不兼容）'
# 'New namespace.'
H7E03703F3B39: '新的命名空间。'
# 'New statement.'
HBA1639E60F46: '新语句。'
# 'No Vectorization'
H1F3B2817613C: '不向量化'
# 'No action'
HF34AC77F7E82: '不执行操作'
# 'No checking'
H4F955C5DB2D5: '不检查'
# 'No code generation'
H3AC7DD01B6EE: '不生成代码'
# 'No compression'
HB3E344B2C4BB: '不压缩'
# 'No constructors'
HAD09B30D8B5D: '无构造函数'
# 'No destructors'
H24AE7DC3B6A4: '无析构函数'
# 'No effect'
H7ED12CB7B709: '无效果'
# 'No extract instruction with offset 0'
HEB2933468549: '没有偏移量为 0 的提取指令'
# 'No implicit externals allowed'
H6CDA41F7B635: '不允许隐式外部符号'
# 'No implicit typing allowed unless overridden by IMPLICIT statements'
HA46325FCDDD6: '除非被IMPLICIT语句覆盖，否则不允许隐式类型声明'
# 'No offloading entry generated while offloading is mandatory.'
H4E35CC32EE7C: '强制卸载时未生成卸载条目。'
# 'No optimizer'
HF1ED527BC3E1: '无优化器'
# 'No profile correlation'
H7B0904A6A54F: '无剖面关联'
# 'No speculation'
H4F7A24022364: '无推测'
# 'No vector functions library'
H42FA0B1EA03D: '无向量化函数库'
# 'No verification'
H41C637F6055E: '无验证'
# 'Non-relocatable code'
H9A85EA682847: '不可重定位代码'
# 'None.'
H9A9707BE07DA: '无。'
# 'Normalize integers in CFI indirect call type signature checks'
H47F05B50721C: '在CFI间接调用类型签名检查中标准化整数'
# "Not emit the visibility attribute for asm in AIX OS or give all symbols 'unspecified' visibility in XCOFF object file"
H98251062C447: "不在AIX操作系统中的asm中生成可见性属性，或在XCOFF对象文件中为所有符号赋予 'unspecified' 可见性"
# 'Number limit for gluing ld/st of memcpy.'
HD8077326B9B0: 'memcpy合并ld/st的数量限制'
# 'Number of addresses from which to enable MIMG NSA.'
HCE8A8E1997D3: '启用MIMG NSA的地址数量'
# 'Number of backend threads'
HE56514D09150: '后端线程数量'
# "Number of blocks in the 'x' dimension"
H76CD51A21746: "'x' 维度中的块数量"
# "Number of blocks in the 'y' dimension"
H6D16D2BE9F69: "'y' 维度中的块数量"
# "Number of blocks in the 'z' dimension"
H2E857E7750A0: "'z' 维度中的块数量"
# 'Number of compile threads'
H083DE0C34AB1: '编译线程数'
# 'Number of cycles to assume for a call instruction'
H48B171D665C7: '假设的调用指令周期数'
# 'Number of entries in the micro-op queue'
H6A848E9631B1: '微操作队列条目数'
# 'Number of instructions to allow ahead of the critical path in sched=list-ilp'
H6B314605368E: '调度时允许超出关键路径的指令数（在sched=list-ilp中）'
# 'Number of instructions to prefetch ahead'
HF2FFA16038B4: '预取的指令数'
# 'Number of interferences after which we declare an interference unevictable and bail out. This is a compilation cost-saving consideration. To disable, pass a very large number.'
H7D7A199C7C69: '声明干扰无法逐出并终止的干扰数量阈值。这是出于降低编译成本的考虑。要禁用此功能，请传入一个非常大的数值。'
# 'Number of intervals to track'
HB4B7D2AC3D9C: '要跟踪的间隔数'
# 'Number of iterations to run'
HE50757CD0D43: '运行的迭代次数'
# 'Number of materialization threads to use'
H7A97C7DA89FF: '使用的物质化线程数'
# 'Number of merge threads to use (default: autodetect)'
H2EA5A0F7B460: '使用的合并线程数（默认：自动检测）'
# 'Number of metadatas above which we emit an index to enable lazy-loading'
H4896D21A9235: '元数据数量超过时生成索引以启用惰性加载'
# 'Number of output files'
H5DDB526BD36F: '输出文件数'
# 'Number of partitions to use for parallel full LTO codegen, ld.lld only.'
HEC293753B227: '用于并行全LTO代码生成的分区数，仅适用于ld.lld。'
# 'Number of registers to limit to when printing regmask operands in IR dumps. unlimited = -1'
H0373C047E939: '限制为的寄存器数量（在IR转储中打印寄存器掩码操作数时使用）。-1 表示无限制'
# 'Number of seconds program is allowed to run before it is killed (default is 300s), 0 disables timeout'
HE6EB2161F536: '程序允许运行的时间（默认 300 秒），0表示禁用超时'
# "Number of threads in the 'x' dimension"
H07DD57A90CC5: "'x' 维度中的线程数"
# "Number of threads in the 'y' dimension"
H986B3D9F34E9: "'y' 维度中的线程数"
# "Number of threads in the 'z' dimension"
HFC9646CFE097: "'z' 维度中的线程数"
# 'Number of threads to use (0 = auto)'
H9A06154F2AD2: '使用的线程数（0 = 自动检测）'
# 'Number of times to divide chunks prior to first test'
H4AB8A9674250: '首次测试前分割块的次数'
# 'Number of times to rerun the outliner after the initial outline'
H45429D789C93: '初始外提后重新运行外提的次数'
# 'Number of times to shuffle and verify use-lists'
HEBDA566F30F3: '打乱和验证使用列表的次数'
# 'Number of tracked SGPRs before initiating hazard cull on memory wait'
H34DB613CB239: '在内存等待启动危险消除前跟踪的SGPR数量'
# "Number of triangle-shaped-CFG's that need to be in a row for the triangle tail duplication heuristic to kick in. 0 to disable."
HAF152F5B6E3F: '需要连续出现的三角形控制流图（CFG）的数量，以便触发三角尾部复制启发式算法。输入 0 以禁用。'
# 'Number of unswitch candidates that are ignored when calculating cost multiplier.'
H4873CA41A98E: '计算成本乘数时忽略的unswitch候选数量'
# 'Number of uses of a base pointer to check before it is no longer considered for post-indexing.'
H02421600E168: '检查基址指针的使用次数阈值，超过后不再考虑后索引优化'
# 'OBJECT_MODE setting %0 is not recognized and is not a valid setting'
HEC8A063EC23B: 'OBJECT_MODE设置 %0 无法识别，且不是有效设置'
# 'ODS output filename'
H1E3A5BE01485: 'ODS输出文件名'
# 'OPTIONS:\n'
H90A71B46515B: '选项：\n'
# 'OVERVIEW: '
H41828FCAB87A: '概述：'
# 'ObjC ARC contraction'
H3B8218111844: 'Objective-C ARC 合并'
# 'Object file format name.'
H116E706BF6D9: '对象文件格式名称。'
# 'Objective-C GC does not allow weak variables on the stack'
H501EF197353A: 'Objective-C垃圾回收机制不允许在栈上使用弱变量'
# 'Objective-C declarations may only appear in global scope'
HBE7743C7A3D5: 'Objective-C声明只能出现在全局作用域中'
# 'Objective-C dispatch method to use'
H71CD5643C8D8: '要使用的Objective-C调度方法'
# 'Objective-C index expression has incomplete class type %0'
H3BF9CC2B38D9: 'Objective-C索引表达式具有不完整类类型 %0'
# 'Objective-C message has incomplete result type %0'
HA58AB6CD0922: 'Objective-C消息具有不完整的结果类型 %0'
# 'Objective-C methods as coroutines are not yet supported'
H197AF4BB9670: 'Objective-C方法作为协程尚未得到支持'
# 'Objective-C object of type %0 is bridged to %1, which is not valid CF object'
HC21532E95928: '类型 %0 的Objective-C对象被桥接到无效的CF对象 %1'
# 'Objective-C++ Automatic Reference Counting standard library kind'
HBD2739B5128E: 'Objective-C++自动引用计数标准库类型'
# 'Offloading entry for declare target variable %0 is incorrect: the address is invalid.'
H44B1C3BF0A67: '声明目标变量 %0 的卸载条目不正确：地址无效。'
# 'Offloading entry for declare target variable is incorrect: the address is invalid.'
H3668F9F00CF1: '声明目标变量的卸载条目不正确：地址无效。'
# 'Offloading entry for target region in %0 is incorrect: either the address or the ID is invalid.'
HB922AD26B2CB: '在 %0 中的目标区域卸载条目不正确：地址或ID无效。'
# 'Offset element to print.'
HCA7A2283660F: '要打印的偏移元素'
# 'Offsets are in UTF-16 code units'
H3B426E622CC8: '偏移量以UTF-16代码单元为单位'
# 'Offsets are in UTF-8 bytes'
HB9A6C5C455E1: '偏移量以UTF-8字节为单位'
# 'Offsets are in unicode codepoints'
H0151FBB5A950: '偏移量以Unicode代码点为单位'
# 'Old namespace.'
HC6DBF56DB427: '旧命名空间'
# 'Omit all lfences before branch instructions.'
H64285876BCDE: '省略分支指令前的所有lfences'
# 'Omit all lfences other than the first to be placed in a basic block.'
HF3797EC0A201: '除第一个外省略基本块内其他所有lfences'
# 'Omit frame pointer setup for leaf functions'
HE755622424D0: '省略叶子函数的帧指针设置'
# 'Omit function index section at the expense of single-function patching performance'
HE5E5A5FAB8F1: '以牺牲单函数修补性能为代价，省略函数索引节'
# 'Omit the RTTI component from virtual tables'
H4D1372C43A35: '从虚表中省略RTTI组件'
# "Omit the frame pointer from functions that don't need it. Some stack unwinding cases, such as profilers and sanitizers, may prefer specifying -fno-omit-frame-pointer. On many targets, -O1 and higher omit the frame pointer by default. -m[no-]omit-leaf-frame-pointer takes precedence for leaf functions"
H40ED6B28D90F: '省略不需要它的函数的帧指针。某些堆栈展开情况（例如分析器和sanitizer）可能更倾向于指定-fno-omit-frame-pointer。在许多目标平台上，默认情况下-O1及以上级别会省略帧指针。-m[no-]omit-leaf-frame-pointer选项对叶子函数具有优先权'
# 'On AIX, request creation of a build-id string, "0xHEXSTRING", in the string table of the loader section inside the linked binary'
H9CC108588817: '在AIX上，请求在链接二进制文件的加载器节的字符串表中创建一个 "0xHEXSTRING" 格式的构建ID字符串'
# 'On Windows, do not emit /defaultlib: directives to link compiler-rt libraries'
H9E62CED5E13B: '在Windows上，不生成链接compiler-rt库的/defaultlib:指令'
# 'On Windows, emit /defaultlib: directives to link compiler-rt libraries (default)'
H84415BE98E65: '在Windows上，生成链接compiler-rt库的/defaultlib:指令（默认行为）'
# 'One completion item for each semantically distinct completion, with full type information'
HE890AD8AA9F7: '每个语义上不同的补全项一个完成项，包含完整类型信息'
# 'One shadow type id for each of `float`, `double`, `long double`. `d`,`l`,`q`,`e` mean double, x86_fp80, fp128 (quad) and ppc_fp128 (extended double) respectively. The default is to shadow `float` as `double`, and `double` and `x86_fp80` as `fp128`'
H95084AA4612D: '每个`float`、`double`、`long double`浮点类型对应一个影子类型标识符。`d`、`l`、`q`、`e`分别代表double、x86_fp80、fp128（quad）和ppc_fp128（extended double）。默认情况下，将`float`影子为`double`，将`double`和`x86_fp80`影子为`fp128`'
# 'One statement per basic block'
HD6EC7448F7DB: '每个基本块一条语句'
# 'Only AST generation'
HCF69EA2C9F2B: '仅生成AST'
# 'Only a certain kind of dependences (all/raw)'
HDDC1270FFF46: '仅特定类型的依赖关系（all/raw）'
# 'Only allow instructions before a call, if their cost is below DuplicationThreshold'
HF553DB6BFC41: '仅允许调用前成本低于DuplicationThreshold的指令'
# 'Only check if the module has objective-C defined in it'
H77EBD1C814CB: '仅检查模块中是否定义了Objective-C代码'
# "Only comparisons where inputs don't need [sz]ext."
HF4DF79025CD9: '仅输入不需要[sz]ext的比较。'
# 'Only comparisons with sext result.'
H4718DE1FE775: '仅结果带有sext的比较。'
# 'Only comparisons with zext result.'
H13645F5A29D7: '仅结果带有zext的比较。'
# 'Only compile for the offloading device.'
H215BF96D8531: '仅为目标设备编译'
# 'Only compile for the offloading host.'
H064D887D36F7: '仅为主机编译'
# 'Only consider IR changes for passes whose names match the specified value. No-op without -print-changed'
HEBE7550E221C: '仅对名称匹配指定值的passes的IR变更进行统计。需配合-print-changed参数生效'
# 'Only count the calls that are recursive'
H531F12291A31: '仅统计递归调用次数'
# 'Only display members that contribute to class size.'
HAA83522F47FE: '仅显示影响类大小的成员。'
# 'Only display the basic block whose name matches this for all view-*-dags options'
HB71A82047A43: '仅显示名称匹配的basic block（适用于所有view-*-dags选项）'
# 'Only display whether errors occurred.'
HDB4BCEB24DBE: '仅显示是否发生错误。'
# 'Only do the coverage check.'
HD8B2B9D841CB: '仅执行覆盖检查'
# 'Only dump files with relative paths or absolute paths with the prefix specified by -s'
HD834488625EB: '仅输出具有相对路径或以 -s 指定前缀的绝对路径的文件'
# 'Only emit EH frame entries when compact unwind is not available'
HBF3C0E4970CD: '仅在无法使用紧凑型展开时生成EH帧条目'
# 'Only emit checks for arguments of functions whose names match the given regular expression'
HA389B7E0BDB5: '仅对名称匹配给定正则表达式的函数的参数生成检查'
# 'Only enable generating memmove in non-nested loops'
H29441902D683: '仅在非嵌套循环中启用生成 memmove'
# 'Only enumerate VLMAX for VL operand'
H6E315308AF5A: '仅枚举 VL 操作数的 VLMAX'
# 'Only execute frontend initialization'
H918B5DDB51E1: '仅执行前端初始化'
# 'Only functions matching the filter are shown in the output. For overlapping CSSPGO, this takes a function name with calling context.'
H189EF6F2A967: '仅显示匹配过滤器的函数。对于重叠 CSSPGO，该过滤器接受带有调用上下文的函数名。'
# "Only fuse 'blessed' FP ops."
H7765353506F0: '仅融合受支持的FP操作。'
# "Only fuse FP ops when the result won't be affected."
HDA090F75D8FD: '仅在结果不受影响时融合FP操作。'
# 'Only generate the minimal instruction sequence'
H0CBFA1B64E41: '仅生成最小的指令序列'
# 'Only has an effect when specified with -print-pipeline-passes. Disables verifying that the textual pipeline generated by -print-pipeline-passes can be used to create a pipeline.'
HD2EDB018C926: '仅当与-print-pipeline-passes选项一起使用时才有效。禁用验证由-print-pipeline-passes生成的文本管线是否可用于创建管线。'
# 'Only i32 comparisons in GPRs.'
HC06CC3A659A2: '仅在GPR中进行i32比较。'
# 'Only i32 comparisons with sext result.'
HAF411A709509: '仅带有sext结果的i32比较。'
# 'Only i32 comparisons with zext result.'
HF0A9D937090A: '仅带有zext结果的i32比较。'
# 'Only i64 comparisons in GPRs.'
HD8F85598F6F1: '仅在GPR中进行i64比较。'
# 'Only i64 comparisons with sext result.'
H43DD157FC439: '仅带有sext结果的i64比较。'
# 'Only i64 comparisons with zext result.'
H32746962EC6F: '仅带有zext结果的i64比较。'
# 'Only import first N functions if N>=0 (default -1)'
H22AE4A1BA0B0: '仅当 N≥0 时导入前 N 个函数（默认值为 -1）'
# 'Only import functions with less than N instructions'
HFF880FC2904D: '仅导入指令数量少于 N 的函数'
# 'Only include passes which match a specified regular expression in the generated optimization record (by default, include all passes)'
H8C18E65FDB94: '仅包含与指定正则表达式匹配的passes到生成的优化记录中（默认包含所有passes）'
# 'Only inline functions explicitly or implicitly marked inline'
H4FB05EC4AB48: '仅内联显式或隐式标记为inline的函数'
# 'Only instrument 1 of N groups'
HE6DD6434319A: '仅插桩 1 组中的N组'
# 'Only keep the intrinsics with the specified substring in their record name'
HCC2CC4639600: '仅保留记录名称中包含指定子字符串的固有函数'
# 'Only lfence before groups of terminators where at least one branch instruction has an input to the addressing mode that is a register other than %rip.'
H7E6136B9D7D9: '仅在至少有一个分支指令的寻址模式输入是不同于 %rip 的寄存器时，在终止指令组前插入 lfence'
# 'Only loops with vectorization factor equal to or larger than the specified value are considered for epilogue vectorization.'
H4A61EE8AECF1: '仅考虑向量化因子等于或大于指定值的循环进行尾部向量化'
# 'Only match instructions with the given prefix'
H83B563F0FFD8: '仅匹配具有给定前缀的指令'
# 'Only output names of functions whose max count values are below the cutoff value'
HC54ECBB9C757: '仅输出最大计数值低于阈值的函数名称'
# 'Only precompile the input'
H8B49F001F9E2: '仅预编译输入'
# 'Only print AMD GPUs'
HAEAFB4C4A2F4: '仅打印AMD GPU'
# 'Only print IR for functions whose name match this for all print-[before|after][-all] options'
HBF4D64D1868D: '仅对名称与之匹配的函数输出 IR，适用于所有 print-[before|after]-all 选项'
# 'Only print NVIDIA GPUs'
HA8E45EB5D306: '仅打印NVIDIA GPU'
# 'Only print to a depth of N elements.'
HFC218BA7E9C0: '仅输出 N 个元素的深度'
# 'Only process files that match this filter. This flag only applies to all-TUs.'
H9C7DF00BB84A: '仅处理匹配此过滤器的文件。此标志仅适用于 all-TUs。'
# 'Only read thinlto index and print the index as LLVM assembly.'
H4D1BB8D241C8: '仅读取 thinlto 索引并以 LLVM 汇编格式打印索引'
# 'Only record optimization remarks from passes whose names match the given regular expression'
HB7A5156C3AD3: '仅记录名称匹配给定正则表达式的 passes 的优化备注'
# 'Only record remark information for passes whose names match the given regular expression'
H53791F3D3835: '仅记录与给定正则表达式匹配的passes名称的备注信息'
# 'Only rename namespaces in files that match the given pattern.'
H3FFAEADCD3A9: '仅重命名匹配给定模式的文件中的命名空间'
# 'Only reorder expressions within a basic block when exposing CSE opportunities'
HEC96777F89E9: '仅在基本块内重新排序表达式以暴露公共子表达式机会'
# "Only run on certain regions (The provided identifier must appear in the name of the region's entry block"
H88F1D2665F48: '仅在特定区域运行（提供的标识符必须出现在该区域入口块的名称中'
# 'Only run on functions that match a regex. Multiple regexes can be comma separated. Scop detection will run on all functions that match ANY of the regexes provided.'
H1DBFD722220A: '仅运行匹配正则表达式的函数。多个正则表达式可以用逗号分隔。Scop检测将运行在匹配任意提供的正则表达式的所有函数上。'
# 'Only run ordered assignment scheduling with no codegen'
HD5721C8545D7: '仅运行有序分配调度，且不进行代码生成'
# 'Only run preprocess and compilation steps'
HF940D137E364: '仅执行预处理和编译步骤'
# 'Only run preprocess, compile, and assemble steps'
H81C1E28BCD95: '仅执行预处理、编译和汇编步骤'
# 'Only run scop detection, but no other optimizations'
HBD3276584517: '仅运行scop检测，但不进行其他优化'
# 'Only run the driver.'
H11F300F88E2D: '仅运行驱动程序'
# 'Only run the preprocessor'
HCB8008C01361: '仅运行预处理器'
# 'Only schedule this MBB#'
HAAC66E179615: '仅调度此MBB#'
# 'Only schedule this function'
HDDB8FF491938: '仅调度此函数'
# 'Only show debug message if the branch probability is greater than this value (in percentage).'
H364FCDA181C3: '仅在分支概率大于此值（以百分比表示）时显示调试信息。'
# 'Only show debug message if the source branch weight is greater  than this value.'
HAD26C2C5503B: '仅在源分支权重大于此值时显示调试信息。'
# 'Only show error-related paths in the analysis graph'
HA2114E4FC51E: '仅在分析图中显示与错误相关的路径'
# 'Only split jump tables containing functions whose sizes are less or equal than this threshold.'
H115A29858DAD: '仅拆分包含函数大小小于或等于此阈值的jump tables。'
# 'Only split jump tables with size less or equal than JumpTableSizeThreshold.'
H159246FC6C6B: '仅拆分大小小于或等于JumpTableSizeThreshold的jump tables。'
# 'Only supported on AArch64, PowerPC, RISC-V, SPARC, SystemZ, and X86'
H6BC9222A7886: '仅支持AArch64、PowerPC、RISC-V、SPARC、SystemZ和X86'
# 'Only try to inject loop invariant conditions and unswitch on them to eliminate branches that are not-taken 1/<this option> times or less.'
H93BBEDA4C81E: '仅尝试注入循环不变条件并在其上进行反变换以消除那些未被采取的次数少于或等于 1/此选项值的分支。'
# 'Only use DAG-combiner alias analysis in this function'
H9A1CF1A6CF3A: '在此函数中仅使用DAG-combiner别名分析'
# 'Only use warnings from specified component'
H87D3AEA990F7: '仅使用指定组件的警告'
# 'Only vectorize if you gain more than this number '
H4BBF18444D60: '仅在收益超过此数值时向量化'
# 'Only vectorize small trees if they are fully vectorizable'
H374794964C3E: '仅向量化完全可向量化的较小树'
# 'Only view functions that match this pattern'
H0D8068A91934: '仅查看匹配此模式的函数'
# 'Only warn if #include directives are inside extern or namespace blocks if the included header is in the header list.'
H9AF148F3DBE5: '仅当包含的头文件在头文件列表中时，如果#include指令位于extern或命名空间块内才发出警告。'
# 'Only write combined global index for ThinLTO backends'
HDCE16F222238: '仅将ThinLTO后端的组合全局索引写回'
# 'Only write output if it changed'
H89C2A6721B4D: '仅当输出有变化时才写入输出'
# 'Only write to the output file if it changed'
H82DD0380BC4C: '仅在内容有变化时写入输出文件'
# "OpenACC %select{clause '%1'|directive '%2'|sub-array bound}0 requires expression of integer type (%3 invalid)"
H24F0AB7B1FF3: "OpenACC %select{子句 '%1'|指令 '%2'|子数组边界}0需要整型表达式（%3 无效）"
# "OpenACC '%0' clause applies to 'device_type' '%1', which conflicts with previous '%0' clause"
HF0863871567F: "OpenACC '%0' 子句应用于 'device_type' '%1'，与先前的 '%0' 子句冲突"
# "OpenACC '%0' clause cannot appear more than once%select{| in a 'device_type' region}2 on a '%1' directive"
H5BA479702441: "OpenACC '%0' 子句不能在 '%1' 指令 %select{|的 'device_type' 区域}2中出现多次"
# "OpenACC '%0' clause cannot appear on the same '%2' construct as a '%1' clause %select{inside a compute construct with a|and a}3 'num_gangs' clause with more than one argument"
H86F6667DC7E5: "OpenACC '%0' 子句不能与同一 '%2' 结构中的 '%1' 子句%select{在带有|和}3 'num_gangs' 子句（参数超过一个时）共存"
# "OpenACC '%0' clause on a 'declare' directive is not allowed at global or namespace scope"
H0D95AB23A6A9: "在全局或命名空间作用域中不允许在 'declare' 指令的 '%0' 子句上使用"
# "OpenACC '%0' construct can only be applied to a 'for' loop"
H7F39DD2F9D48: "OpenACC '%0' 结构必须应用于一个 'for' 循环"
# "OpenACC '%0' construct must have a terminating condition"
HA5F584B3696E: "OpenACC '%0' 结构必须有一个终止条件"
# "OpenACC '%0' construct must have at least one %1 clause"
H5108FA0063F8: "OpenACC '%0' 结构必须至少包含一个 %1 子句"
# "OpenACC '%0' construct must have initialization clause in canonical form ('var = init' or 'T var = init')"
HB6396996D535: "OpenACC '%0' 结构必须以规范形式包含初始化子句（'var = init' 或 'T var = init'）"
# "OpenACC '%0' modifier not valid on '%1' clause"
H3160CD5E4802: "OpenACC '%0' 修饰符在 '%1' 子句上无效"
# "OpenACC '%0' variable must monotonically increase or decrease ('++', '--', or compound assignment)"
H4842B31AA1BD: "OpenACC '%0' 变量必须单调递增或递减（使用 '++'、'--' 或复合赋值）"
# "OpenACC '%1' clause %select{|with more than 1 argument }0may not appear on a '%2' construct with a '%3' clause%select{ with more than 1 argument|}0"
HE77D7FA4A4F6: "OpenACC '%1' 子句 %select{|带有超过 1 个参数的 }0不能出现在带有 '%3' 子句%select{ 带有超过 1 个参数的|}0 的 '%2' 构造中"
# "OpenACC '%1' clause cannot appear more than once on a '%0' directive"
H22BA6A918DDE: "OpenACC '%1' 子句在 '%0' 指令上不能出现多次"
# "OpenACC '%1' clause is not valid on '%0' directive"
H226495157F78: "OpenACC '%1' 子句在 '%0' 指令上无效"
# "OpenACC 'bind' clause on a declaration must bind to the same name as previous 'bind' clauses"
HC59CAAD94E7A: '声明上的OpenACC bind子句必须与之前bind子句绑定相同名称'
# "OpenACC 'collapse' clause loop count must be a %select{constant expression|positive integer value, evaluated to %1}0"
HF187F732137C: "OpenACC 'collapse' 子句循环计数必须是 %select{常量表达式|正整数值，计算为 %1}0"
# "OpenACC 'device_type' clause on a 'set' construct only permits one architecture"
HB63E35D8A787: "OpenACC 'device_type' 子句在 'set' 构造中仅允许一种架构"
# "OpenACC 'gang' clause may have at most one %select{unnamed or 'num'|'dim'|'static'}0 argument"
HC064C4557CFE: "OpenACC 'gang' 子句最多可以有一个 %select{未命名或 'num'|'dim'|'static'}0 参数"
# "OpenACC 'reduction' composite variable must not have non-scalar field"
H9A717A5BB65E: "OpenACC 'reduction' 组合变量不能包含非标量字段"
# "OpenACC 'reduction' variable must be a composite of scalar types; %1 %select{is not a class or struct|is incomplete|is not an aggregate}0"
HD35F9CAD567D: "OpenACC 'reduction' 变量必须是标量类型的聚合；%1%select{不是类或结构体|类型不完整|不是聚合类型}0"
# "OpenACC 'reduction' variable must be of scalar type, sub-array, or a composite of scalar types;%select{| sub-array base}1 type is %0"
HEC7D1B479B8F: "OpenACC 'reduction' 变量必须是标量类型、子数组或标量类型的组合;%select{|子数组基}1类型是 %0"
# "OpenACC 'reduction' variable must have the same operator in all nested constructs (%0 vs %1)"
H28C388119D4E: "OpenACC 'reduction' 变量在所有嵌套构造中必须使用相同的运算符 (%0 与 %1 冲突)"
# "OpenACC 'routine' construct must have at least one 'gang', 'seq', 'vector', or 'worker' clause that applies to each 'device_type'"
H32818FCDE6B7: "OpenACC 'routine' 构造必须为每个 'device_type' 至少有一个 'gang'、'seq'、'vector' 或 'worker' 子句"
# "OpenACC 'routine' directive with a name refers to a function with the same name as the function on the following line; this may be unintended"
H18CDEE7EFD75: "OpenACC 'routine' 指令带有名称，该名称与下一行的函数名称相同，这可能是无意的"
# "OpenACC 'tile' clause size expression must be %select{an asterisk or a constant expression|positive integer value, evaluated to %1}0"
HA638C30812B2: "OpenACC 'tile' 子句尺寸表达式必须是 %select{星号或常量表达式|正整数值，计算为 %1}0"
# "OpenACC 'update' construct may not appear in place of the statement following a%select{n if statement| while statement| do statement| switch statement| label statement}0"
H3E931AFE1E4E: "OpenACC 'update' 构造不能出现在 %select{if语句后的|while语句后的|do语句后的|switch语句后的|标签语句后的}0语句位置"
# "OpenACC clause '%0' after 'device_type' clause on a 'routine' conflicts with the '%1' clause before the first 'device_type'"
HA93644C02FFF: "OpenACC子句 '%0' 在 'routine' 指令中的 'device_type' 子句之后，与之前的 '%1' 子句冲突"
# "OpenACC clause '%0' may not appear on the same construct as a '%1' clause on a '%2' construct"
HFD5E5BF152EC: "OpenACC '%0' 子句不能与 '%1' 子句出现在同一 '%2' 构造中"
# "OpenACC clause '%0' may not follow a '%1' clause in a '%2' construct"
H3810BDC5F66B: "OpenACC '%0' 子句不能在 '%2' 构造中跟随 '%1' 子句"
# "OpenACC clause '%0' on a 'routine' directive conflicts with the '%1' clause applying to the same 'device_type'"
H672EE4A10B1D: "OpenACC 'routine' 指令上的 '%0' 子句与应用于同一 'device_type' 的 '%1' 子句冲突"
# "OpenACC clause name '%0' is a deprecated clause name and is now an alias for '%1'"
H0277741A1F9D: "OpenACC 子句名称 '%0' 是已弃用的子句名称，现为 '%1' 的别名"
# "OpenACC construct '%0' cannot be used here; it can only be used in a statement context"
HCF6F4162FC42: "OpenACC 构造 '%0' 不能在此处使用；它只能在语句上下文中使用"
# "OpenACC construct 'routine' with implicit function not yet implemented, pragma ignored"
H861502AB5841: "OpenACC 构造 'routine' 带有隐式函数尚未实现，pragma 被忽略"
# "OpenACC construct 'self' has no effect when an 'if' clause evaluates to true"
H4B8F857AB30C: "OpenACC 构造 'self' 在 'if' 子句求值为真时无效"
# 'OpenACC directives will result in no runtime behavior; use -fclangir to enable runtime effect'
H106A424B384D: 'OpenACC指令不会产生运行时行为；使用-fclangir选项启用运行时效果'
# 'OpenACC integer expression has incomplete class type %0'
H5F66C1830606: 'OpenACC 整数表达式具有不完整类类型 %0'
# 'OpenACC integer expression requires explicit conversion from %0 to %1'
H20507033806F: 'OpenACC 整数表达式需要将 %0 显式转换为 %1'
# 'OpenACC routine name %0 does not name a function'
H38F10B674F17: 'OpenACC例行程序名称 %0 未命名一个函数'
# 'OpenACC routine name %0 names a set of overloads'
H417FD900A33B: 'OpenACC例行程序名称 %0 指代一组重载函数'
# 'OpenACC sub-array %select{lower bound|length}0 evaluated to a value (%1) that would be out of the range of the subscripted array size of %2'
HD993EBC2FF56: 'OpenACC子数组%select{下界|长度}0计算得到的值(%1)超出了所下标数组 %2 的大小范围'
# 'OpenACC sub-array %select{lower bound|length}0 evaluated to negative value %1'
H9C42001B0E35: 'OpenACC子数组%select{下界|长度}0计算得到负值 %1'
# 'OpenACC sub-array base is of incomplete type %0'
H568C42694CA4: 'OpenACC子数组基类型为不完全类型 %0'
# 'OpenACC sub-array cannot be of function type %0'
H1F4C209C1D7A: 'OpenACC子数组不能是函数类型 %0'
# 'OpenACC sub-array length is unspecified and cannot be inferred because the subscripted value is %select{not an array|an array of unknown bound}0'
H3D8516DAE66C: 'OpenACC子数组长度未指定且无法推断，因为所下标值为%select{非数组|未知边界的数组}0'
# 'OpenACC sub-array specified range [%0:%1] would be out of the range of the subscripted array size of %2'
H7C8F28679BDB: 'OpenACC子数组指定范围[%0:%1]超出了所下标数组 %2 的大小范围'
# 'OpenACC sub-array subscripted value is not an array or pointer'
H64A7517C6764: 'OpenACC子数组所下标值不是数组或指针'
# "OpenACC variable %select{in 'use_device' clause|on 'declare' construct}0 is not a valid variable name or array name"
H5FFA8811F2EF: "OpenACC变量 %select{'use_device' 子句中的|'declare' 结构中的}0不是一个有效的变量名或数组名"
# 'OpenACC variable in cache directive is not a valid sub-array or array element'
H0DEC3018E66D: 'OpenACC在cache指令中的变量不是一个有效的子数组或数组元素'
# 'OpenACC variable is not a valid variable name, sub-array, array element,%select{| member of a composite variable,}0 or composite variable member'
HA8B26141C7C6: 'OpenACC变量不是一个有效的变量名、子数组、数组元素 %select{|或复合变量的成员,}0 或复合变量成员'
# 'OpenCL extension %0 is core feature or supported optional core feature - ignoring'
H1E2DAA7C8DD9: 'OpenCL扩展 %0 是核心特性或支持的可选核心特性 - 忽略'
# 'OpenCL extension %0 unknown or does not require pragma - ignoring'
HB7D9C7E097C0: 'OpenCL扩展 %0 未知或不需要pragma - 忽略'
# 'OpenCL language standard to compile for.'
H165955277EF6: '要编译的OpenCL语言标准'
# 'OpenCL only. Allow denormals to be flushed to zero.'
H8AAB3F5FE401: 'OpenCL专用。允许将非规格化数（denormals）冲刷为零'
# 'OpenCL only. Allow floating-point optimizations that assume arguments and results are not NaNs or +-Inf.'
HD11F5701CC10: 'OpenCL专用。允许假设参数和结果不是NaNs或±Inf的浮点优化'
# 'OpenCL only. Allow unsafe floating-point optimizations.  Also implies -cl-no-signed-zeros and -cl-mad-enable.'
HF643B16A83F5: 'OpenCL专用。允许不安全的浮点优化。同时隐含启用-cl-no-signed-zeros和-cl-mad-enable选项。'
# 'OpenCL only. Allow use of less precise MAD computations in the generated binary.'
H9C454BE02287: 'OpenCL专用。允许在生成的二进制文件中使用精度较低的MAD计算。'
# 'OpenCL only. Allow use of less precise no signed zeros computations in the generated binary.'
H8DE8DC71375B: 'OpenCL专用。允许在生成的二进制文件中使用精度较低的无符号零计算。'
# 'OpenCL only. Defines that the global work-size be a multiple of the work-group size specified to clEnqueueNDRangeKernel'
H3AFC0A3E3E23: '定义全局工作尺寸必须是传递给clEnqueueNDRangeKernel函数的工作组尺寸的倍数。'
# 'OpenCL only. Disables all standard includes containing non-native compiler types and functions.'
H89344E39C234: '禁用包含非本机编译器类型和函数的所有标准头文件。'
# "OpenCL only. Enable or disable OpenCL extensions/optional features. The argument is a comma-separated sequence of one or more extension names, each prefixed by '+' or '-'."
H2870B3BCDE72: "启用或禁用OpenCL扩展/可选特性。参数是用逗号分隔的一个或多个扩展名列表，每个扩展名前需加上 '+' 或 '-' 前缀。"
# 'OpenCL only. Generate kernel argument metadata.'
HD27868AF8559: '生成内核参数元数据。'
# 'OpenCL only. Sets -cl-finite-math-only and -cl-unsafe-math-optimizations, and defines __FAST_RELAXED_MATH__.'
HA1D24030C687: '设置-cl-finite-math-only和-cl-unsafe-math-optimizations选项，并定义__FAST_RELAXED_MATH__宏。'
# 'OpenCL only. Specify that single precision floating-point divide and sqrt used in the program source are correctly rounded.'
H2DD948248943: '指定程序源代码中使用的单精度浮点除法和sqrt运算结果必须正确舍入。'
# 'OpenCL only. This option disables all optimizations. By default optimizations are enabled.'
HB24BF4359851: '此选项禁用所有优化。默认情况下优化是启用的。'
# 'OpenCL only. This option is added for compatibility with OpenCL 1.0.'
HEF34F847970F: '此选项为兼容OpenCL 1.0而添加。'
# 'OpenCL only. Treat double precision floating-point constant as single precision constant.'
H9F9807A3E0E7: '将双精度浮点常量视为单精度常量处理。'
# 'OpenMP array shaping operation is not allowed here'
H6B78DAFB84E5: 'OpenMP数组成形操作在此处不允许'
# 'OpenMP captured regions are not yet supported in %select{streaming functions|functions with ZA state|functions with ZT0 state}0'
HBFAEB31DF5F3: 'OpenMP捕获区域在%select{流函数|具有ZA状态的函数|具有ZT0状态的函数}0中尚未支持'
# "OpenMP clause '%0' is only available as extension, use '-fopenmp-extensions'"
H7D732B734761: "OpenMP子句 '%0' 仅作为扩展可用，请使用 '-fopenmp-extensions'"
# 'OpenMP constructs may not be nested inside a simd region%select{| except for ordered simd, simd, scan, or atomic directive}0'
HC65424272817: 'OpenMP结构不能嵌套在simd区域内 %select{|，除非是ordered simd、simd、scan或atomic指令}0'
# 'OpenMP constructs may not be nested inside an atomic region'
HE2C47884F9E6: 'OpenMP结构不能嵌套在原子区域内'
# "OpenMP extension clause '%0' only allowed with '#pragma omp %1'"
HB7695EC8B674: "OpenMP扩展子句 '%0' 仅允许与 '#pragma omp %1' 一起使用"
# 'OpenMP iterator is not allowed here'
HB9668BC52F3C: 'OpenMP迭代器不允许在这里使用'
# 'OpenMP loop iteration variable cannot have more than 64 bits size and will be narrowed'
H85A842BD8107: 'OpenMP循环迭代变量的大小不能超过 64 位，将被截断'
# "OpenMP offloading target '%0' is similar to target '%1' already specified; will be ignored"
H66F93F9F54F1: "OpenMP卸载目标 '%0' 与已指定的 '%1' 目标相似；将被忽略"
# 'OpenMP only allows an ordered construct with the simd clause nested in a simd construct'
H52C83AA3C087: 'OpenMP仅允许将带有simd子句的ordered结构嵌套在simd结构中'
# 'OpenMP standard version'
HA403864CFA0F: 'OpenMP 标准版本'
# 'OpenMP support in flang is still experimental'
HA42DEF114A36: 'flang中的OpenMP支持仍处于实验阶段'
# "OpenMP target architecture '%0' pointer size is incompatible with host '%1'"
HF18160FDA94C: "OpenMP目标架构 '%0' 的指针大小与主机 '%1' 不兼容"
# "OpenMP target is invalid: '%0'"
H6461D2D7A8F6: "无效的OpenMP目标：'%0'"
# 'Optimise without changing ABI'
H19D2D13E9ED7: '在不改变ABI的情况下优化'
# 'Optimization level 0. Similar to clang -O0. Same as -passes="default<O0>"'
H809F6417B5CD: '优化级别 0。类似于 clang -O0。等同于 -passes="default<O0>"'
# 'Optimization level 1. Similar to clang -O1. Same as -passes="default<O1>"'
H563E0780E60E: '优化级别 1。类似于 clang -O1。等同于 -passes="default<O1>"'
# 'Optimization level 2. Similar to clang -O2. Same as -passes="default<O2>"'
H71099B09BC66: '优化级别 2。类似于 clang -O2。等同于 -passes="default<O2>"'
# 'Optimization level 3. Similar to clang -O3. Same as -passes="default<O3>"'
H73EA61C4E41D: '优化级别 3。类似于 clang -O3。等同于 -passes="default<O3>"'
# 'Optimization level for NVVM compilation'
HA23F3D2204EA: 'NVVM 编译的优化级别'
# "Optimization level. [-O0, -O1, -O2, or -O3] (default = '-O2')"
H8F5A63304993: "优化级别。[-O0, -O1, -O2, 或 -O3]（默认值 = '-O2'）"
# 'Optimization remarks file containing inline remarks to be replayed by cgscc inlining.'
HEFDDA07D8CA1: '包含由 cgscc 内联重放的内联备注的优化备注文件。'
# 'Optimization remarks file containing inline remarks to be replayed by inlining from sample profile loader.'
H7FC66DD3A1D4: '包含由采样配置文件加载器内联重放的内联备注的优化备注文件。'
# 'Optimizations available (use "-passes=" for the new pass manager)'
H61E922DB15A6: '可用的优化选项（使用 "-passes=" 以使用新的 pass 管理器）'
# 'Optimize AArch64 selected instructions'
HC4CE467B7223: '优化AArch64选定指令'
# 'Optimize LiveIntervals for WebAssembly'
H18D7A3DF4B0B: '为WebAssembly优化存活区间'
# 'Optimize SCoPs using ISL'
HCB9C725F1344: '使用 ISL 优化 SCoPs'
# 'Optimize addressing mode'
HD2F645235970: '优化寻址模式'
# 'Optimize callbacks'
H4FA5D57DC24A: '优化回调函数'
# 'Optimize calls with "returned" attributes for WebAssembly'
H77D4D84768F4: '为带有“returned”属性的调用优化WebAssembly'
# 'Optimize for code generation'
HB09B7FAA4243: '为代码生成进行优化'
# 'Optimize for size'
H36D83A6CA81E: '按大小优化'
# 'Optimize for size  (like /Og     /Os /Oy /Ob2 /GF /Gy)'
H45F672EE3075: '优化以减小体积（类似于/Og /Os /Oy /Ob2 /GF /Gy选项）'
# 'Optimize for size (like clang -Os)'
HFB8E68DF5FCB: '优化以减小体积（类似clang -Os选项）'
# 'Optimize for speed'
H56E47BC17587: '按速度优化'
# 'Optimize for speed (like /Og /Oi /Ot /Oy /Ob2 /GF /Gy)'
HC5F6A322D605: '优化以提升速度（类似于/Og /Oi /Ot /Oy /Ob2 /GF /Gy选项）'
# 'Optimize for speed (like clang -O3)'
HA3959EB2D045: '优化以提升速度（类似clang -O3选项）'
# 'Optimize instrumentation'
H4C86894C9330: '优化插入代码'
# 'Optimize machine instruction PHIs'
H86D600E2A81C: '优化机器指令的PHI节点'
# 'Optimize memory intrinsic result values for WebAssembly'
HFC7D2A9B2DB2: '优化WebAssembly的内存内建函数结果值'
# 'Optimize selects'
H2F525E20DF58: '优化选择指令'
# 'Optimize spill slots'
HE31BB3136FBC: '优化溢出槽位'
# 'Optimize the memop size <= this value'
HD160B7A51C58: '优化 memop 大小 <= 此值'
# 'Optimizer Pipeline'
H226573EDB1C0: '优化器流水线'
# 'Option passed to ISL'
HA7C0FFCC5B20: '传递给 ISL 的选项'
# 'Optional function name to filter collection by'
H65912274A33B: '用于筛选收集的可选函数名'
# 'Optional function name to filter collection by (accepts regular expressions)'
HB4B18F2D54D8: '用于筛选收集的可选函数名（接受正则表达式）'
# 'Optional remark arg to filter collection by (accepts regular expressions).'
H3E0D571E2D16: '可选的备注参数，用于通过正则表达式过滤收集结果。'
# 'Optional remark arg to filter collection by.'
H4BB3B1D09826: '可选的备注参数，用于过滤收集结果。'
# 'Optional remark name to filter collection by (accepts regular expressions).'
H1C5E04FF9D98: '可选的备注名称，用于通过正则表达式过滤收集结果。'
# 'Optional remark name to filter collection by.'
H660F0832C261: '要按其过滤的可选备注名称。'
# 'Optional remark pass name to filter collection by (accepts regular expressions).'
H2B175B559D90: '按正则表达式过滤收集的可选备注pass名称（接受正则表达式）。'
# 'Optional remark pass name to filter collection by.'
H4733818447B2: '按名称过滤收集的可选备注pass名称。'
# 'Optional remark type to filter collection by.'
HA70FC86A45D5: '要按其过滤的可选备注类型。'
# 'Options for -gen-(attrdef|typedef|enum|op|dialect)-doc'
H639716290785: '-gen-(attrdef|typedef|enum|op|dialect)-doc 的选项'
# 'Options for -gen-asm-matcher'
H01AF394D0C16: '-gen-asm-matcher 的选项'
# 'Options for -gen-asm-parser'
H9ACA7721D57A: '-gen-asm-parser 的选项'
# 'Options for -gen-asm-writer'
HC2084E3135D4: '-gen-asm-writer 的选项'
# 'Options for -gen-attrdef-*'
H904334F41DE4: '-gen-attrdef-* 的选项'
# 'Options for -gen-bytecode'
H6F6AAAD1A1D2: '-gen-bytecode 的选项'
# 'Options for -gen-dag-isel'
H28817938BEA9: '-gen-dag-isel 的选项'
# 'Options for -gen-dialect-*'
HA2A748C26694: '-gen-dialect-* 的选项'
# 'Options for -gen-disassembler'
H7B14D2A69B34: '-gen-disassembler 的选项'
# 'Options for -gen-global-isel'
HAE024C7C3B27: '-gen-global-isel 的选项'
# 'Options for -gen-global-isel-combiner'
H4132B3D1DEF9: '-gen-global-isel-combiner 的选项'
# 'Options for -gen-instr-info'
H0D7A354B88C3: '-gen-instr-info 的选项'
# 'Options for -gen-intrinsic-enums'
H65B201D59766: '-gen-intrinsic-enums 的选项'
# 'Options for -gen-irdl-dialect'
HAAF45CF21F4C: '-gen-irdl-dialect 的选项'
# 'Options for -gen-pass-capi-header and -gen-pass-capi-impl'
H849A90D3FA97: '-gen-pass-capi-header 和 -gen-pass-capi-impl 的选项'
# 'Options for -gen-pass-decls'
HD4DF70DE63FF: '-gen-pass-decls 的选项'
# 'Options for -gen-python-op-bindings'
HFFB2EE013BDE: '-gen-python-op-bindings 的选项'
# 'Options for -gen-register-info'
H1593471B9CB0: '-gen-register-info 的选项'
# 'Options for -gen-sdnode-info'
H1CDBACD50609: '生成SD节点信息选项'
# 'Options for -gen-typedef-*'
H9F13AB96225A: '生成typedef定义选项'
# 'Options for -print-enums'
HCC367BFA06F6: '打印枚举选项'
# 'Options for gen-directive-decl'
HB3B2620C73DD: '生成指令声明选项'
# 'Options for op definition generators'
H563831A68B15: '操作符定义生成器选项'
# 'Options to disable Loop Idiom Recognize Pass.'
HEC1AFA3F201E: '禁用循环惯用法识别Pass的选项。'
# 'Options to pass to the fuzzer'
H35D63FFBE491: '要传递给模糊测试工具的选项'
# 'Options: <empty>'
H86F57A40CF46: '选项：空'
# 'Options: <empty>|Legal|Discard|Convert. If non-empty, ignore TargetTransformInfo and always use this transformation for the %evl parameter (Used in testing).'
H04319FFE1FD4: '选项：空|Legal|Discard|Convert。如果非空，则忽略 TargetTransformInfo 并始终使用此转换来处理 %evl 参数（用于测试）。'
# 'Orc JIT'
H76C72319C493: 'Orc JIT'
# 'Orc-based lazy JIT.'
H732AA2A7BDF4: '基于Orc的延迟JIT。'
# 'Orc-specific linker'
HCE705FE1F603: 'Orc专用链接器'
# 'Order local stack symbols.'
H1D5554EC3474: '按顺序排列本地堆栈符号。'
# 'Other Options'
H9CB6F2FB01DF: '其他选项'
# 'Outline loop blocks from loop chain if (frequency of loop) / (frequency of block) is greater than this ratio'
HB57131BBFAC5: '如果（循环的频率）/（块的频率）大于该比率，则从循环链中提取循环块'
# 'Output'
H4BED336194A9: '输出'
# 'Output .gcov in intermediate text format'
HF37052F8B66C: '以中间文本格式输出.gcov文件'
# 'Output Filename'
H253060EBAB8E: '输出文件名'
# 'Output Options'
HFCD12607F17F: '输出选项'
# 'Output a side-by-side diff in HTML.'
H57654452ACF4: '输出并排对比的HTML格式。'
# 'Output assembly code file during compilation'
H6310B853EF5F: '编译时输出汇编代码文件'
# 'Output assembly listing file'
H1DE8B74129C4: '输出汇编列表文件'
# 'Output dwarf accelerator tables.'
H13E79CD2B348: '输出DWARF加速表。'
# 'Output file'
HB6AEEF874B66: '输出文件'
# 'Output file for export'
HF9225788216E: '导出的输出文件'
# 'Output file. Can be specified multiple times for multiple output files.'
HEE2A7A1E3079: '输出文件。可以多次指定以生成多个输出文件。'
# 'Output filename'
H85DF5E35434C: '输出文件名'
# 'Output filename for pass remarks'
HB92A0E8D19B1: 'pass备注的输出文件名'
# 'Output filename for the reduced test case'
HD417AF7888E3: '用于输出精简测试用例的文件名'
# 'Output format for line-based coverage reports'
H556FF7AB0CB0: '基于行的覆盖报告的输出格式'
# 'Output format for timing data'
H55AABD7334B6: '时序数据的输出格式'
# 'Output graphs with edge colors determined by this field'
H794FD3A570E0: '以该字段确定边颜色的图形输出'
# 'Output graphs with edges colored by this field'
HF746FFB4D465: '以该字段着色的边图形输出'
# 'Output graphs with edges labeled with this field'
H24D87E28CEB2: '以该字段标记的边图形输出'
# 'Output graphs with vertex colors determined by this field'
H074479A80832: '以该字段确定顶点颜色的图形输出'
# 'Output graphs with vertices colored by this field'
H2DF9C4C8C65F: '以该字段着色的顶点图形输出'
# 'Output graphs with vertices labeled with this field'
HE53D4D1DCDFD: '以该字段标记的顶点图形输出'
# "Output in chrome's trace event format. May be visualized with the Catapult trace viewer."
H9A05A1436798: '以Chrome的跟踪事件格式输出。可用Catapult跟踪查看器可视化。'
# 'Output input source as HTML'
HE9E58C4AFE0A: '以HTML格式输出输入源代码'
# 'Output instructions per ScopStmt'
H0963CFA695BF: '按ScopStmt输出指令'
# 'Output object file'
H427E379BB7CB: '输出目标文件'
# 'Output options'
HCA4409BA27DC: '输出选项'
# 'Output profile file'
H3C5CF3CF6071: '输出配置文件文件'
# 'Output replacements as XML.'
H1724D4877353: '以XML格式输出替换内容'
# 'Output resource usage of launched kernels'
H76E82EB3BAF1: '输出已启动内核的资源使用情况'
# 'Output the total number corresponding to the count for the provided input file.'
H8049C03B1803: '输出与提供的输入文件计数对应的总数。'
# "Output trace to the given file name or '-' for stdout."
H8DCBEA863061: '将跟踪输出到指定文件名或使用 "-" 表示标准输出'
# 'Outputs for view.'
H377C2CC892EF: '用于视图的输出'
# 'Overapproximation of dependences'
HEFB667282405: '依赖关系的上近似'
# 'Overlay the virtual filesystem described by file over the real file system'
H291889337D71: '将描述的虚文件系统覆盖到真实文件系统之上'
# 'Overlay the virtual filesystem described by file over the real file system. Additionally, pass this overlay file to the linker if it supports it'
HAFADC554CE4B: '将描述的虚文件系统覆盖到真实文件系统之上。如果链接器支持，将此覆盖文件传递给链接器'
# 'Override cost based safe divisor widening for div/rem instructions'
H81D91B0A076D: '覆盖div/rem指令的基于成本的安全除数扩展'
# 'Override default dump names'
H7A6C6DC9BBC4: '覆盖默认的转储名称'
# 'Override host target triple'
HF3CC7F9CE700: '覆盖推断的主机目标三元组'
# 'Override inferred gcda file'
H68DED86E4EE4: '覆盖推断的gcda文件'
# 'Override inferred gcno file'
H756521C312EE: '覆盖推断的gcno文件'
# 'Override optimization level for codegen hooks, legacy PM only'
HCB07980F5249: '覆盖代码生成钩子的优化级别（仅适用于旧版PM）'
# 'Override output filename'
HAFF5159DAF01: '覆盖输出文件名'
# 'Override record layouts with those in the given file'
H3D9B83089303: '使用给定文件中的记录布局覆盖现有布局'
# "Override source file's content (in the overlaying\nvirtual file system) with input from <stdin> and run\nthe tool on the new content with the compilation\noptions of the source file. This mode is currently\nused for editor integration."
H9F6FADB4D508: '覆盖基础文件内容（在覆盖的\n虚文件系统中）以从<标准输入>读取输入，并使用源文件的编译选项运行工具处理新内容。此模式目前用于编辑器集成。'
# 'Override target triple detection'
H3331B75D4B40: '覆盖目标三元组检测'
# 'Override target triple for module'
HAD133DEC039A: '覆盖模块的目标三元组'
# "Override the 'argv[0]' value passed into the executing program"
HD3C4FA0CA7DA: "覆盖传递给执行程序的 'argv[0]' 值"
# 'Override the behaviour of '
H053262A576A2: '覆盖...的行为'
# 'Override the behaviour of expand-variadics'
H8E4D335E1CAD: '覆盖expand-variadics的行为'
# 'Override the default ABI to return all structs on the stack'
H796683BA46B0: '覆盖默认的ABI以在栈上返回所有结构体'
# 'Override the default ABI to return small structs in registers'
H14D9E95511EF: '覆盖默认的ABI以在寄存器中返回小结构体'
# 'Override the path to the output spec json file. See -ml-inliner-model-under-training documentation for the specification of that file.'
HA0B2BFC5945E: '覆盖输出规格JSON文件的路径。参见 -ml-inliner-model-under-training 文档以了解该文件的规范。'
# 'Override the processor dispatch width'
HBBE12C3A519F: '覆盖处理器分派宽度'
# 'Override the profitability heuristics for Machine CSE'
H05022840BC44: '覆盖机器CSE的利润启发式规则'
# 'Override the variant of check applied to authenticated LR during tail call'
H929544275FD6: '覆盖尾调用期间对认证LR应用的检查变体'
# 'Override the vector register size in bits, which is otherwise found by querying TTI.'
H8FCFAFF95563: '覆盖向量寄存器大小（以位为单位），否则将通过查询TTI获取该值。'
# 'Override the visibility of globals based on their final DLL storage class.'
HB70286716DCC: '覆盖全局变量的可见性，基于它们最终的DLL存储类别'
# 'Override unique ID of ctor/dtor globals.'
HA514528D025F: '覆盖构造函数/析构函数全局变量的唯一ID。'
# 'Override use of color (default = isatty)'
HFB4A1E45D51F: '覆盖颜色使用设置（默认值为isatty）'
# 'Override validator version for module. Format: <major.minor>;Default: DXIL.dll version or current internal version'
H29DBA8820EEB: '覆盖模块的validator版本。格式： <major.minor>; 默认：DXIL.dll版本或当前内部版本'
# 'Overrides result used for getMaximumVF query which is used exclusively by SLP vectorizer.'
H790D0193AFF1: '覆盖由SLP向量化器独占使用的 getMaximumVF 查询结果。'
# 'Overrides the _OPENACC macro value for experimental testing during OpenACC support development'
H1F6C8876A478: '在OpenACC支持开发期间覆盖实验性测试的_OPENACC宏值'
# 'Overwrite edited files.'
HA46F1C96B7DC: '覆盖写入编辑后的文件。'
# 'PASSED'
H75168D9452E2: '通过'
# 'PBQP register allocator'
HC52F58BD0440: 'PBQP寄存器分配器'
# 'PCH was compiled with different VFS overlay files than are currently in use'
H6654F3AEB3F7: 'PCH是使用与当前不同的VFS覆盖文件编译的'
# 'PDB Stream Options'
HE58091817322: 'PDB流选项'
# 'PDLL Frontend'
H667EECC1B90F: 'PDLL 前端'
# 'PDLL LSP Language Server'
HCB7860D44409: 'PDLL LSP 语言服务器'
# 'PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace, preprocessed source, and associated run script.\n'
H3E1C9F287454: '请提交bug报告到https://github.com/llvm/llvm-project/issues/并包含崩溃回溯、预处理源文件和关联的运行脚本。\n'
# 'PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\n'
H0DE59CCB7CD2: '请提交bug报告到https://github.com/llvm/llvm-project/issues/并包含崩溃回溯。\n'
# 'POSIX thread model'
HAAFA3F8D71A1: 'POSIX 线程模型'
# 'Pack non-contiguous assumed shape dummy arrays into contiguous memory'
H921464C334CB: '将非连续假定形状虚拟数组打包到连续内存中'
# 'Pack non-contiguous assummed shape arrays into contiguous memory'
H3E0440CD78CB: '将非连续假定形状数组打包到连续内存中'
# 'Pad previous instructions to implement align directives'
H461F83B5992B: '填充前序指令以实现对齐指令'
# 'Pad previous instructions to implement branch alignment'
H9A3FD2CE91B3: '填充前序指令以实现分支对齐'
# 'Pair of function name and filename, where function should be imported from bitcode in filename'
H0856646593E7: '函数名和文件名的配对，其中函数应从文件名对应的比特码中导入'
# 'Parameter.'
H78B17095F0E6: '参数。'
# 'Parse OpenMP pragmas and generate parallel code.'
H203F2D0AAEA4: '解析OpenMP pragma并生成并行代码'
# 'Parse and pretty-print the input'
HE106679F4FE4: '解析并格式化输出输入内容'
# 'Parse templated function definitions at the end of the translation unit'
H187BB681FD43: '在翻译单元末尾解析模板函数定义'
# 'Partially inline calls to library functions'
HD08FDB669104: '部分内联库函数调用'
# 'Partition data sections using profile information.'
HBDB4D3B42575: '使用分析信息划分数据段。'
# 'Partition functions into N groups and select only functions in group i to be instrumented using -fprofile-selected-function-group'
H245EBE517AA5: '将函数分为N组，并仅选择第i组中的函数进行instrumentation（使用-fprofile-selected-function-group选项）'
# 'Partition functions into N groups using -fprofile-function-groups and select only functions in group i to be instrumented. The valid range is 0 to N-1 inclusive'
HE1BA0DFA9946: '使用-fprofile-function-groups将函数分为N组，并仅选择第i组中的函数进行instrumentation。有效范围为 0 到N-1（包含端点）'
# 'Pascal string is too long'
HDF5B602956C9: 'Pascal字符串过长'
# 'Pass -b <arg> to the linker on AIX'
HC027AB59908D: '在AIX系统上将-b <arg> 传递给链接器'
# 'Pass -z <arg> to the linker'
HC96FADA8EF05: '将-z <arg> 传递给链接器'
# 'Pass <arg> to clang -cc1'
H7056B37839B2: '将 <arg> 传递给clang -cc1'
# 'Pass <arg> to clang -cc1as'
HB0D05A4A9173: '向clang -cc1as传递参数 <arg>'
# 'Pass <arg> to fatbinary invocation'
HE6E06CC967E5: '将 <arg> 传递给fatbinary调用'
# 'Pass <arg> to plugin <name>'
H194FFD6DEF4E: '将 <arg> 传递给插件 <name>'
# 'Pass <arg> to the CUDA/HIP device compilation'
H6E93CAC5A2A4: '将 <arg> 传递给CUDA/HIP设备编译'
# 'Pass <arg> to the CUDA/HIP host compilation'
HBD5864C8EAAC: '将 <arg> 传递给CUDA/HIP主机编译'
# 'Pass <arg> to the assembler'
H260454350861: '将 <arg> 传递给汇编器'
# 'Pass <arg> to the clang driver'
H0BA43F60ADF1: '将 <arg> 传递给clang驱动程序'
# 'Pass <arg> to the compilation if the target matches <arch>'
H28A6957698C7: '如果目标匹配 <arch>，则将 <arg> 传递给编译过程'
# 'Pass <arg> to the flang compiler'
HA8F1AD31AB5E: '将 <arg> 传递给flang编译器'
# 'Pass <arg> to the linker'
H47C4E471D4CC: '将 <arg> 传递给链接器'
# 'Pass <arg> to the offload linkers or the ones identified by -<triple>'
HF43CE14F52D9: '将 <arg> 传递给卸载链接器或由-<triple> 标识的链接器'
# 'Pass <arg> to the preprocessor'
HECFF1F09AA70: '将 <arg> 传递给ptxas汇编器'
# 'Pass <arg> to the ptxas assembler'
HDA10BB61A91B: '将 <arg> 传递给静态分析器'
# 'Pass <arg> to the static analyzer'
H665CD83A1EA3: '将 <arg> 传递给由 <triple> 标识的目标卸载工具链'
# 'Pass <arg> to the target offloading toolchain identified by <triple>.'
HD393E82FA340: '将 <arg> 传递给目标卸载工具链'
# 'Pass <arg> to the target offloading toolchain.'
H786E5FF9D985: '将 <arg> 传递给目标卸载工具链。'
# 'Pass a workload definition. This is a file containing a JSON dictionary. The keys are root functions, the values are lists of functions to import in the module defining the root. It is assumed -funique-internal-linkage-names was used, to ensure local linkage functions have unique names. For example: \n{\n  "rootFunction_1": ["function_to_import_1", "function_to_import_2"], \n  "rootFunction_2": ["function_to_import_3", "function_to_import_4"] \n}'
H8F2A17B54334: '传递一个工作负载定义。这是一个包含JSON字典的文件。键是根函数，值是模块中要导入的函数列表，该模块定义了该根函数。假设使用了-funique-internal-linkage-names选项，以确保内部链接函数具有唯一名称。例如：\n{\n  "rootFunction_1": ["function_to_import_1", "function_to_import_2"], \n  "rootFunction_2": ["function_to_import_3", "function_to_import_4"] \n}'
# 'Pass all reduction arguments by reference'
H1F6E6E7DA880: '通过引用传递所有规约参数'
# 'Pass the comma separated arguments in <arg> to the assembler'
H0BB4ECAE0BD9: '将 <arg> 中用逗号分隔的参数传递给汇编器'
# 'Pass the comma separated arguments in <arg> to the linker'
H01CAEC128AC9: '将 <arg> 中用逗号分隔的参数传递给链接器'
# 'Pass the comma separated arguments in <arg> to the preprocessor'
H596C87A5B391: '将 <arg> 中用逗号分隔的参数传递给预处理器'
# 'Passes available:'
H13989372E812: '可用的Pass：'
# 'Path and name to DWP file.'
H6E3C7CBCF218: 'DWP文件的路径和名称。'
# 'Path of .dwp file. When not specified, it will be <binary>.dwp in the same directory as the main binary.'
H743B0B321E91: '路径为.dwp文件。当未指定时，它将在主二进制文件的同一目录下使用 <binary>.dwp。'
# 'Path of debug info binary, llvm-profgen will load the DWARF info from it instead of the executable binary.'
H7CB4490678CE: '包含DWARF信息的调试信息二进制文件路径。llvm-profgen将从此处加载DWARF信息，而不是可执行二进制文件。'
# 'Path of perf-script trace created by Linux perf tool with `script` command(the raw perf.data should be profiled with -b)'
H3DEF1722D3DA: '由Linux perf工具使用`script`命令创建的perf-script跟踪文件（原始perf.data应使用-b参数进行分析）'
# 'Path of profiled executable binary.'
H3B42E7676CEA: '已分析的可执行二进制文件路径。'
# 'Path of raw perf data created by Linux perf tool (it should be profiled with -b)'
HFDF5B6ACDEB6: '由Linux perf工具创建的原始perf数据路径（应使用-b参数进行分析）'
# 'Path of the LLVM sample profile'
H33F3BE9ADD2D: 'LLVM样本分析文件路径。'
# 'Path of the unsymbolized profile created by `llvm-profgen` with `--skip-symbolization`'
H946923D050AC: '通过`llvm-profgen --skip-symbolization`生成的未符号化分析文件路径。'
# 'Path to CSV file containing lines of function names and attributes to add to them in the form of `f1,attr1` or `f2,attr2=str`.'
HAA93B63D725F: '包含函数名及其属性的CSV文件路径，格式为`f1,attr1`或`f2,attr2=str`。'
# 'Path to SavedModel from the previous training iteration.\nThe directory is also expected to contain a JSON specification of the \noutputs expected to be logged, where the first entry must be the \ninlining decision. The file containing the specification should be \ncalled output_spec.json. The expected JSON value is an array of \ndictionaries. Each dictionary should have 2 keys: \n\n- "tensor_spec, followed by the TensorSpec description of the\noutput; and \n- "logging_name", a string indicating the name to use when\nlogging the output values. \n\nExample:\n[\n  {\n    "logging_name" : "some_name", \n    "tensor_spec" : { \n      "name" : "model_name", \n      "port" : 0,\n      "shape" : [2, 3],\n      "type" : "float"\n      }\n  }\n]\n\nThe first value must always correspond to the decision.'
H9AB7FF7DDB14: '上一次训练迭代的SavedModel路径。\n该目录还应包含一个JSON格式的输出规范文件，指定需要记录的输出内容，其中第一个条目必须是内联决策。规范文件名为output_spec.json，其JSON格式应为数组，每个元素为包含以下两个键的字典：\n\n- "tensor_spec"，后接输出的TensorSpec描述；\n- "logging_name"，用于记录输出值的名称字符串。\n\n示例：\n[\n  {\n    "logging_name" : "some_name", \n    "tensor_spec" : { \n      "name" : "model_name", \n      "port" : 0,\n      "shape" : [2, 3],\n      "type" : "float"\n      }\n  }\n]\n\n首条必须始终对应内联决策。'
# 'Path to a directory containing a .clang-format file\ndescribing a formatting style to use for formatting\ncode when -style=file.\n'
H1C68FD05289D: '包含.clang-format格式化配置文件的目录路径，\n当使用-style=file选项时用于代码格式化。\n'
# 'Path to a system assembler, picked up on AIX only'
HD76EB0189931: 'AIX系统专用的系统汇编器路径'
# 'Path to binary from which the profile was collected.'
HDF7F0FA583A9: '分析数据来源的二进制文件路径。'
# 'Path to file containing newline-separated [<weight>,]<filename> entries'
H39AF8CCE2C18: '包含以换行符分隔的[<权重>,]文件路径的文件路径'
# 'Path to file containing the list of function symbols used to populate profile symbol list'
H85546B6474C7: '用于填充分析符号列表的函数符号列表文件路径'
# 'Path to ignorelist file for sanitizers'
H685EED5F185D: '检查器的忽略列表文件路径'
# 'Path to libomptarget-amdgcn bitcode library'
H409595E6068A: 'libomptarget-amdgcn比特码库路径'
# 'Path to libomptarget-nvptx bitcode library'
H1DFEDD2BDCE9: 'libomptarget-nvptx比特码库路径'
# 'Path to libomptarget-spirv bitcode library'
H17C48C664B7B: 'libomptarget-spirv比特码库路径'
# "Path to opt. (default: search path for 'opt'.)"
H87E2E1DC35F9: 'opt工具路径（默认：搜索路径中的 "opt"）。'
# 'Path to ptxas (used for compiling CUDA code)'
H902CF64E7382: 'ptxas的路径（用于编译CUDA代码）'
# 'Path to saved model evaluating native size from IR.'
H90E4D367F618: '从IR求值本机大小的保存模型路径。'
# 'Path to system headers on z/OS'
H858924F171F6: 'z/OS系统头文件路径'
# 'Path to system ignorelist file for sanitizers'
H6EB010D2085A: '系统检查器的忽略列表文件路径'
# 'Path to the DIA SDK'
HEE09636C6E6A: 'DIA SDK的路径'
# 'Path to the IR file produced by the frontend for the host.'
H6108420B0DC9: '前端为宿主生成的IR文件的路径'
# 'Path to the VCToolChain'
H5C43C23950E7: 'VCToolChain的路径'
# 'Path to the Windows SDK'
H6252659C1D52: 'Windows SDK的路径'
# 'Path to the YAML configuration file to be used for multilib selection'
H370257D7FAE7: '用于多库选择的YAML配置文件路径'
# 'Path to the file where tracer logs will be stored'
HB84166BE320D: '要存储跟踪日志文件的路径'
# 'Path to the instrumented context sensitive profile.'
H374A91784042: '上下文敏感分析文件的路径。'
# 'Path to the memory profile.'
H0F3D8AAD8CB7: '内存分析文件路径。'
# 'Path to the prefetch hints profile. See also -x86-discriminate-memops'
HC95B0BC0D2ED: '预取提示分析文件路径。请参阅 -x86-discriminate-memops'
# 'Path to the profile remapping file.'
H16575118DC15: '分析文件重映射路径。'
# 'Path to the profile.'
H327691C6666D: '分析文件路径。'
# 'Path to the project. Required when connecting using remote index.'
HD4FC494735F6: '项目路径。使用远程索引时必填。'
# 'Path to the vocabulary file for IR2Vec'
HD630B03243E1: 'IR2Vec词汇文件的路径'
# 'Path to where .dwo files will be written out to.'
H41452088F682: '要写入.dwo文件的路径。'
# 'Path where the development - mode inlining log is saved.'
H72974DF4C8AA: '开发模式内联日志保存路径。'
# 'Pathname where the element is defined.'
H33A4EFF1B837: '元素定义的路径名。'
# 'Peephole Optimizations'
H6FFA8D4ADC02: '窥孔优化'
# 'Penalty of calling a function that requires a change to PSTATE.SM'
H135B935B6400: '调用需要更改PSTATE.SM函数的惩罚值'
# 'Penalty of inlining a call that requires a change to PSTATE.SM'
HF8B0216049CB: '内联需要更改PSTATE.SM调用的惩罚值'
# 'Percentage of prologue execution count to use as threshold when evaluating whether a block is cold enough to be profitable to move eligible spills there'
HB814EF09C393: '求值是否将块移动到合适的溢出位置时，用作阈值的函数序言执行次数的百分比'
# 'Percentage threshold for splitting single-instruction critical edge. If the branch threshold is higher than this threshold, we allow speculative execution of up to 1 instruction to avoid branching to splitted critical edge'
HF3E418A57D78: '允许对单指令关键边进行推测执行时的分支阈值百分比。若分支阈值高于该值，允许最多推测执行 1 条指令以避免转向分裂后的关键边'
# 'Percentage threshold of matched basic blocks at which stale profile inference is executed.'
H38AE58F6A0A2: '执行陈旧分析推断的基本块匹配百分比阈值。'
# 'Percentile of profile quality distributions over hottest functions to report.'
H5CD854B0BEDF: '最热函数中需报告的分析质量分布百分位数。'
# 'Percentile profile summary cutoff used to determine cold blocks. Unused if set to zero.'
H3E03792B2D91: '确定冷块的分析摘要百分位数阈值。若设为零则忽略。'
# 'Perform ODR checks for decls in the global module fragment.'
H69A7B0ED61B4: '对全局模块片段中的声明执行ODR检查'
# 'Perform SME peephole optimization'
HCDB7263D2CEF: '执行SME小孔优化'
# 'Perform ThinLTO end-to-end'
H303BC754B9A0: '执行 ThinLTO 端到端处理'
# 'Perform ThinLTO importing using provided function summary index'
HC1B8CB3D2919: '使用提供的函数摘要索引执行ThinLTO导入'
# 'Perform ThinLTO optimizations.'
H801619F35DAD: '执行 ThinLTO 优化。'
# 'Perform a single ThinLTO stage:'
H6083E399B9A6: '执行单个ThinLTO阶段：'
# 'Perform both promotion and cross-module importing (requires -thinlto-index).'
H625E880C0440: '同时执行提升和跨模块导入（需要 -thinlto-index 参数）。'
# 'Perform branch folding during placement. Reduces code size.'
HC83634EE199F: '在指令调度时进行跳转合并。可减少代码体积。'
# 'Perform context sensitive PGO instrumentation'
H9FA2FCAD28BD: '执行上下文敏感的PGO插装'
# 'Perform dummy load from authenticated address'
H53EA500A8E1C: '从认证地址执行空操作加载'
# 'Perform expensive assert validation on every query to Instruction Precedence Tracking'
HB66C9831C0D5: '在每次查询指令优先级跟踪时执行昂贵的断言验证'
# "Perform extra assertion checking to verify that PHINodes's hash function is well-behaved w.r.t. its isEqual predicate"
HC9E8890BCE7F: '执行额外的断言检查，以验证PHINodes的哈希函数与其isEqual谓词在行为上是否一致'
# "Perform extra assertion checking to verify that SimpleValue's hash function is well-behaved w.r.t. its isEqual predicate"
H56A34E9BD071: '执行额外的断言检查，以验证SimpleValue的哈希函数与其isEqual谓词在行为上是否一致'
# 'Perform frequent verification checks on nodes.'
H17FE3747FAAC: '对节点频繁执行验证检查'
# 'Perform internalization driven by -exported-symbol (requires -thinlto-index).'
H1934C0B7F9D0: '根据 -exported-symbol 执行内部化处理（需要 -thinlto-index 参数）。'
# 'Perform link through clang-sycl-linker via the target offloading toolchain.'
H3D0FA081F298: '通过目标卸载工具链使用clang-sycl-linker进行链接'
# 'Perform mandatory inlinings module-wide, before performing inlining'
HBFA39AA6F76F: '在模块范围内执行强制内联，然后再进行内联操作'
# 'Perform optimizations based on pattern matching'
H48981223D558: '基于模式匹配执行优化'
# 'Perform optimizations of matrix multiplications based on pattern matching'
H175644A4FF20: '基于模式匹配优化矩阵乘法'
# 'Perform optimizations of tensor contractions based on pattern matching'
H07134EDA2398: '基于模式匹配优化张量收缩'
# 'Perform pre-import promotion (requires -thinlto-index).'
HD57DCDC50753: '执行导入前的提升（需要 -thinlto-index 参数）。'
# 'Perform tail duplication during placement. Creates more fallthrough opportunities in outline branches.'
HF926F65659FB: '在放置期间执行尾部复制。在外部分支中创建更多的穿透机会'
# 'Perform verification checks on CallingContextGraph.'
H0D2194DF6309: '对CallingContextGraph执行验证检查'
# 'Performs lazy compilation on whole module boundaries rather than individual functions'
H0286F9E0FE8F: '在模块边界执行惰性编译，而非单个函数'
# 'Permit merging of identical functions when optimizing.'
H3F2353AD4C4D: '允许在优化时合并相同的函数'
# 'Phi Values Analysis'
H4E3B42E3B884: 'PHI值分析'
# 'Place ASan constructors in comdat sections'
H88C0022D413C: '将ASan构造函数放置在comdat节中'
# 'Place Backedge Safepoints'
H8C4883CA47B7: '放置循环后跳安全点'
# 'Place MSan constructors in comdat sections'
H3E7B76D6C9CA: '将MSan构造函数放置在comdat节中'
# 'Place all main program variables in static memory (otherwise scalars may be placed on the stack)'
HC378DD7FF55D: '将所有主程序变量置于静态内存（否则标量可能位于栈上）'
# 'Place constant objects with relocatable address values in the RO data section and add -bforceimprw to the linker flags (AIX only)'
HD2C46719D2EF: '将地址值可重定位的常量对象置于RO数据段，并向链接器标志添加-bforceimprw（仅AIX）'
# 'Place constants in the .rodata section instead of the .sdata section even if they meet the -G <size> threshold (MIPS)'
H509FF0828C91: '即使满足-G <size> 阈值，仍将常量置于.rodata节而非.sdata节（仅MIPS）'
# 'Place debug types in their own section (ELF Only)'
H73B21ADBA4FE: '将调试类型置于独立节（仅ELF）'
# 'Place each data in its own section'
H7C2A5E2E04CE: '将每个数据置于独立节'
# 'Place each function in its own section'
H9BBADC5A5281: '将每个函数置于独立节'
# "Place each function's basic blocks in unique sections (ELF Only)"
H517D3F2B0E57: '为每个函数的基本块分配独立节（仅ELF）'
# 'Place uninitialized global variables in a common block'
H97F2AD11B476: '将未初始化的全局变量置于公共块'
# 'Platform to use with LLJIT'
HAEF32BE4B3F4: '与LLJIT一起使用的平台'
# 'Pointer to member.'
HDE1D650C630F: '成员指针。'
# 'Pointer.'
H2EBACB6EF9AE: '指针。'
# 'Polly - Calculate dependences'
H6CAD158D9763: 'Polly - 计算依赖关系'
# 'Polly - Calculate dependences for all the SCoPs of a function'
H32F2275306BF: 'Polly - 为函数的所有SCoP计算依赖关系'
# 'Polly - Create LLVM-IR from SCoPs'
H64A957DE1EE7: 'Polly - 从SCoP生成LLVM-IR'
# 'Polly - Create polyhedral description of Scops'
HFD5B7E2064CE: 'Polly - 创建Scop的多面体描述'
# 'Polly - Create polyhedral description of all Scops of a function'
H3225EA9E728D: 'Polly - 为函数的所有Scop创建多面体描述'
# 'Polly - DeLICM/DePRE'
H209DA16A8BB4: 'Polly - DeLICM/DePRE'
# 'Polly - Detect static control parts (SCoPs)'
HFF16BBB95B79: 'Polly - 检测静态控制部分（SCoPs）'
# 'Polly - Dump Function'
HF98ECB8A4F3A: 'Polly - 转储函数'
# 'Polly - Dump Module'
H406314AC52B6: 'Polly - 转储模块'
# 'Polly - Dump polyhedral description of Scops optimized with the isl scheduling optimizer and the set of post-scheduling transformations is applied on the schedule tree'
H29D7996B3B49: 'Polly - 转换Scop的多面体描述，使用isl调度优化器，并在调度树上应用后调度转换的集合'
# 'Polly - Export Scops as JSON (Writes a .jscop file for each Scop)'
H20651143EB75: 'Polly - 将SCoP导出为JSON格式（为每个SCoP生成一个.jscop文件）'
# 'Polly - Flatten schedule'
HB1962B7EDBD9: 'Polly - 展平调度'
# 'Polly - Forward operand tree'
HBFECA734FD00: 'Polly - 前向操作数树'
# 'Polly - Generate an AST from the SCoP (isl)'
HDBF9CF6A0C48: 'Polly - 从SCoP生成AST（isl）'
# 'Polly - Generate an AST of the SCoP (isl)'
H12CE909F63DA: 'Polly - 生成SCoP的抽象语法树（isl）'
# 'Polly - Import Scops from JSON (Reads a .jscop file for each Scop)'
H16E203839258: 'Polly - 从JSON导入SCoP（为每个SCoP读取.jscop文件）'
# 'Polly - Interface to polyhedral analysis engine'
HEE4D2D43660E: 'Polly - 与多面体分析引擎交互'
# 'Polly - Maximal static expansion of SCoP'
H0CA779A2D7D3: 'Polly - 静态扩展SCoP至最大'
# 'Polly - Optimize schedule of SCoP'
H377579EA76A0: 'Polly - 优化SCoP的调度'
# 'Polly - Prepare code for polly'
HA31E0A502467: 'Polly - 为Polly准备代码'
# 'Polly - Print DeLICM/DePRE'
HE392A0315DF8: 'Polly - 打印DeLICM/DePRE结果'
# 'Polly - Print Scop import result'
H4A167D1D4274: 'Polly - 打印SCoP导入结果'
# 'Polly - Print Scops of function'
H31ABAE6ABC4E: 'Polly - 打印函数的 Scops'
# 'Polly - Print Scops of function (with no function bodies)'
HF9B4E2CB9C70: 'Polly - 打印函数的 Scops（无函数体时）'
# 'Polly - Print Simplify actions'
H5741448BF9F8: 'Polly - 打印简化操作'
# 'Polly - Print dependences'
HD5CEBA14DA9B: 'Polly - 打印依赖关系'
# 'Polly - Print dependences for all the SCoPs of a function'
HD7464B6EDE01: 'Polly - 打印函数中所有SCoP的依赖关系'
# 'Polly - Print flattened schedule'
H33EAB5733200: 'Polly - 打印展平后的调度'
# 'Polly - Print forward operand tree result'
H7CD855EC5084: 'Polly - 打印前向操作数树结果'
# 'Polly - Print interface to polyhedral analysis engine analysis'
HF7F243A50BCB: 'Polly - 打印多面体分析引擎接口的分析结果'
# 'Polly - Print optimizer schedule of SCoP'
HB4511056F80D: 'Polly - 打印SCoP的优化器调度'
# 'Polly - Print polyhedral description of Scops'
HE3A4EE9454B0: 'Polly - 打印Scops的多面体描述'
# 'Polly - Print polyhedral description of all Scops of a function'
H23C591077544: 'Polly - 打印函数中所有Scops的多面体描述'
# 'Polly - Print static control parts (SCoPs)'
H2CB7C4BBD709: 'Polly - 打印静态控制部分（SCoPs）'
# 'Polly - Print the AST from a SCoP (isl)'
H984A4B6D2819: 'Polly - 从SCoP打印AST（isl）'
# 'Polly - Prune unprofitable SCoPs'
HB8C0844D69B4: 'Polly - 剪除无利可图的SCoPs'
# 'Polly - Remove dead iterations'
H67A46F65DA9E: 'Polly - 移除无用迭代'
# 'Polly - Run canonicalization passes'
H0C8C62952E1F: 'Polly - 运行标准化Pass'
# 'Polly - Simplify'
HE98E9DE36187: 'Polly - 简化'
# 'Polly - View Scops of function'
HD3BFFB69003F: 'Polly - 查看函数的 Scops'
# 'Polly - View Scops of function (with no function bodies)'
H8C7475C4A4E8: 'Polly - 查看函数的 Scops（无函数体时）'
# 'Polly Options'
H4116368BA8CD: 'Polly选项'
# 'Pop up a window to show MISched dags after they are processed'
HAAFE046654B3: '处理后弹出窗口显示MISched dags'
# 'Pop up a window to show SUnit dags after they are processed'
HDD5439EA4C3E: '处理后弹出窗口显示SUnit dags'
# 'Pop up a window to show a dag displaying MBP layout and associated block frequencies of the CFG.'
HBC76A8873486: '处理后弹出窗口显示一个展示CFG布局及其关联块频率的dag图'
# 'Pop up a window to show a dag displaying how block frequencies propagation through the CFG.'
H5017224EFFF8: '处理后弹出窗口显示一个展示CFG中块频率传播方式的dag图'
# 'Pop up a window to show a dag displaying how machine block frequencies propagate through the CFG.'
H06EB3103BBDD: '弹出窗口显示DAG，展示机器块频率如何通过控制流图（CFG）传播。'
# 'Pop up a window to show dags before legalize'
HCEEBF08E9304: '弹出窗口显示legalize之前的DAG'
# 'Pop up a window to show dags before legalize types'
H7DF81922AFEE: '弹出窗口显示类型legalize之前的DAG'
# 'Pop up a window to show dags before the first dag combine pass'
HD6B32ED73930: '在第一次dag combine pass之前弹出窗口显示dag'
# 'Pop up a window to show dags before the post legalize types dag combine pass'
H411955B7261A: '在类型合法化后的dag combine pass之前弹出窗口显示dag'
# 'Pop up a window to show dags before the second dag combine pass'
HC7BCA3632D13: '在第二次dag combine pass之前弹出窗口显示dag'
# 'Pop up a window to show edge bundle graphs'
H5831F520A8FB: '弹出窗口显示边捆绑图'
# 'Pop up a window to show isel dags as they are selected'
HA52C2A41472F: '弹出窗口显示指令选择过程中生成的DAG'
# 'Pop up a window to show sched dags as they are processed'
H1FD861E7E0A4: '弹出窗口显示调度过程中处理的DAG'
# 'Populate profile symbol list (only meaningful for -extbinary)'
HB40FFCA64E8B: '填充符号列表（仅对-extbinary有意义）'
# 'Position independent'
H3F7792F17E68: '位置无关'
# 'Post RA hazard recognizer'
H03992384B25F: '寄存器分配后危险识别器'
# 'Post RA top-down list latency scheduler'
H59EA1D628EE5: '寄存器分配后自顶向下列表延迟调度器'
# 'Post reg-alloc list scheduling direction'
H4071BC55C6A4: '寄存器分配后列表调度方向'
# 'Post-Dominator Tree Construction'
HEC3645FCF915: '后支配树构建'
# 'Post-RA pseudo instruction expansion pass'
H3AEF4966A271: '寄存器分配后伪指令展开Pass'
# 'PostRA Machine Instruction Scheduler'
H0087D700C0B6: '寄存器重命名后指令调度器'
# 'PostRA Machine Sink'
H2B8A5A72B764: '寄存器分配后指令下沉优化'
# 'Postfix to append to the import .jsop files.'
H00F609EA3C78: '附加到导入的.jsop文件后的后缀。'
# 'Potential PHI threshold per loop for PPC loop prep of DQ form'
HD78EEEDE2049: 'PPC循环预处理DQ形式每个循环的潜在PHI阈值'
# 'Potential PHI threshold per loop for PPC loop prep of DS form'
H88F3C7B998C1: 'PPC循环预处理DS形式每个循环的潜在PHI阈值'
# 'Potential PHI threshold per loop for PPC loop prep of update form'
HFA306C3E0204: 'PPC循环预处理更新形式每个循环的潜在PHI阈值'
# 'Potential common base number threshold per function for PPC loop prep'
H1CB6AA07DE6F: 'PPC循环预处理每个函数的公共基数阈值'
# 'PowerPC Branch Selector'
H9BA07427B81D: 'PowerPC分支选择器'
# 'PowerPC CTR Loops Verify'
H6280529F23F2: 'PowerPC CTR循环验证'
# 'PowerPC CTR loops generation'
HFCFC8E19EA44: 'PowerPC CTR循环生成'
# 'PowerPC DAG->DAG Pattern Instruction Selection'
H52FD8AB73B79: 'PowerPC DAG->DAG模式指令选择'
# 'PowerPC Early-Return Creation'
HFB276D43768D: 'PowerPC早期返回创建'
# 'PowerPC Expand Atomic'
HE518E2C5903E: 'PowerPC 展开原子操作'
# 'PowerPC MI Peephole Optimization'
HD03B52E2308F: 'PowerPC MI窥孔优化'
# 'PowerPC Pre-Emit Peephole'
H690293F011C6: 'PowerPC 预发射小孔优化'
# 'PowerPC Reduce CR logical Operation'
H604BA96457F7: 'PowerPC 减少CR逻辑操作'
# 'PowerPC TLS Dynamic Call Fixup'
H754F83D11B51: 'PowerPC TLS动态调用修复'
# 'PowerPC TOC Register Dependencies'
HBE3F61F91CCA: 'PowerPC TOC 寄存器依赖项'
# 'PowerPC VSX Copy Legalization'
HCE743C058611: 'PowerPC VSX 复制合法化'
# 'PowerPC VSX FMA Mutation'
H934573D30FC1: 'PowerPC VSX FMA变换'
# 'PowerPC VSX Swap Removal'
H61E16EA71951: 'PowerPC VSX交换消除'
# 'Pre reg-alloc list scheduling direction'
HBAA66F24441A: '寄存器分配前列表调度方向'
# 'Pre-ISel Intrinsic Lowering'
H2F5309EAAE70: '指令选择前固有函数降级'
# 'Pre-RA optimizations'
H81B4ED48A8E1: '预RA优化'
# 'Pre-load dynamic libraries (e.g. language runtimes required by the ORC runtime)'
HDF44F8CD7956: '预加载动态库（例如ORC运行时所需的语言运行时）'
# 'Predicate conditions in read only loops'
H0D01A5F11CC3: '在只读循环中谓词条件'
# 'Prefer add+cnt over addvl/inc/dec'
H791228095B74: '建议使用 add+cnt 而非 addvl/inc/dec'
# 'Prefer aligned allocation for C++ Coroutines'
HF3DEE91EAA7A: '为C++协程优先使用对齐分配'
# 'Prefer hex format for immediate values'
H5AF7A8CAAB05: '建议对立即数使用十六进制格式'
# 'Prefer hex format when printing immediate values'
H641A692609DF: '输出立即数时建议使用十六进制格式'
# 'Prefer in-loop vector reductions, overriding the targets preference.'
HC3384EBFEDE5: '优先使用循环内向量缩减，覆盖目标的默认偏好。'
# 'Prefer post-indexed addressing mode'
HFA137A1FDE64: '优先使用后索引寻址模式'
# 'Prefer pre-indexed addressing mode'
HCF74AFA989EA: '优先使用前索引寻址模式'
# 'Prefer predicated Move to CSEL'
H29D20CBEE6CD: '建议使用条件选择的 Move 而非 CSEL'
# 'Prefer predicating a reduction operation over an after loop select.'
HE552FE7410D6: '建议在循环后选择前对缩减操作进行条件判断。'
# 'Prefer translating all intrinsics into llvm.call_intrinsic instead of using dialect supported intrinsics'
H35AE35D12C89: '建议将所有内建函数转换为 llvm.call_intrinsic，而非使用方言支持的内建函数'
# 'Prefer whole register move for vector registers.'
HD64DE7AD7D41: '建议对向量寄存器使用全寄存器移动。'
# 'Prefetch write addresses'
HD84230748C7F: '预取写入地址'
# 'Prefix filenames with the main file'
HFC5DC735C294: '在文件名前添加主文件名'
# 'Prefix for feature names.'
H2B0C0B21A30C: '功能名称的前缀。'
# 'Prefix for memory access callbacks'
H4F526B73B916: '内存访问回调的前缀'
# 'Prefix of line code for repository.'
H1C11371CF193: '存储库的行代码前缀。'
# "Prefix to use for outputs (default: 'bugpoint')"
H51241093AFDE: "输出使用的前缀（默认：'bugpoint'）"
# "Prefix to use from check file (defaults to 'CHECK')"
HC4A6D5922731: "从检查文件中使用的前缀（默认为 'CHECK'）"
# "Prefixes for aliases that don't need to be renamed, separated by a comma"
H93C76DC96906: '不需要重命名的别名前缀，用逗号分隔'
# "Prefixes for functions that don't need to be renamed, separated by a comma"
H8D84AAE61D99: '不需要重命名的函数前缀，用逗号分隔'
# "Prefixes for global values that don't need to be renamed, separated by a comma"
H25F3716C6D6C: '不需要重命名的全局值前缀，用逗号分隔'
# "Prefixes for structs that don't need to be renamed, separated by a comma"
HFF2FE350C63E: '不需要重命名的结构体前缀，用逗号分隔'
# 'Preload commands from file and start interactive mode'
HF342699558DE: '从文件预加载命令并启动交互模式'
# "Prepare '-aux-triple' only without populating '-aux-target-cpu' and '-aux-target-feature'."
H5F5A3F872C66: "仅准备 '-aux-triple' 而不填充 '-aux-target-cpu' 和 '-aux-target-feature'"
# 'Prepare DWARF exceptions'
H95C39A5915AA: '准备DWARF异常'
# 'Prepare SjLj exceptions'
HCA47286F067B: '准备 SjLj 异常处理'
# 'Prepare WebAssembly exceptions'
H90B1A43A5B08: '准备WebAssembly异常'
# 'Prepare Windows exceptions'
H09ADD0F6BE1B: '准备 Windows 异常处理'
# 'Prepare callbr'
H28D8A749A5F8: '准备callbr'
# 'Prepares for basic block sections, by splitting functions into clusters of basic blocks.'
H6AFC803DF7AB: '为基本块分段做准备，通过将函数拆分为基本块簇。'
# 'Prepend header file paths with this prefix. If not specified, the files are considered to be relative to the header list file.'
HB8A4FB692FE7: '在头文件路径前添加此前缀。如果没有指定，则认为文件相对于头文件列表文件。'
# 'Preprocess to file'
HADD296905BBE: '预处理到文件'
# 'Preprocess to stdout'
HB9E8D78ECAA1: '预处理到标准输出'
# 'Preserve Comments in outputted assembly'
H6543E9060512: '保留输出的汇编中的注释'
# 'Preserve canonical loop structure (default = true)'
H9226DB4F030F: '保留规范循环结构（默认=true）'
# 'Preserve debug info in thunk when mergefunc transformations are made.'
HC15D6215FF01: '在进行mergefunc转换时保留thunk中的调试信息'
# 'Preserve expressions in AST rather than dropping them when encountering semantic errors'
H606CF076FD66: '在遇到语义错误时保留AST中的表达式而非丢弃'
# 'Preserve line and column number when merging locations.'
H6B50620B43DC: '合并位置时保留行号和列号'
# 'Preserve line numbers'
HF7C338130FB4: '保留行号'
# 'Preserve order of LLVM use-lists when serializing'
HE297D90494BB: '序列化时保留LLVM使用列表的顺序'
# 'Preserve path components'
HA8274603DA36: '保留路径组件'
# 'Preserve subregisters in tied operands'
HB16CD82DFFE2: '保留绑定操作数中的子寄存器'
# 'Preserve the type for recovery expressions when possible'
HB104FC8C2A4B: '尽可能保留恢复表达式类型'
# 'Preserve use-list order when writing LLVM assembly.'
HA8838E5FAEE3: '在生成LLVM汇编时保留使用列表顺序'
# 'Preserve use-list order when writing LLVM bitcode.'
HED82044E4F6B: '在生成LLVM比特码时保留使用列表顺序'
# 'Pretend that scalable vectors are supported, even if the target does not support them. This flag should only be used for testing.'
HE0B0560A96EA: '假设可扩展向量被支持，即使目标平台不支持。此标志仅用于测试目的。'
# 'Pretty print debug locations of instructions when dumping'
HFD520C9CFE2C: '在转储时以美观格式打印指令的调试位置'
# 'Pretty print perf data (branch weights, etc) when dumping'
H25D67F8F93BF: '在转储时以美观格式打印性能数据（分支权重等）'
# 'Pretty-print JSON'
HED0E5D700CC6: '以美观格式打印JSON'
# 'Pretty-print JSON output'
HF19F323787A0: '以美观格式打印JSON输出'
# 'Pretty-print JSON output in the trace'
HE76D2162F789: '在跟踪中以美观格式打印JSON输出'
# 'Prevent expanding floating point division in AMDGPUCodeGenPrepare'
H5221E44BB247: '阻止在AMDGPUCodeGenPrepare中展开浮点除法'
# 'Prevent expanding integer division in AMDGPUCodeGenPrepare'
HA00F77EDC803: '阻止在AMDGPUCodeGenPrepare中展开整数除法'
# 'Prevent function(s) from being devirtualized'
HF36ABB428107: '阻止函数去虚化'
# 'Prevent misexpect diagnostics from being output if the profile counts are within N% of the expected. '
HAB811F421D71: '若剖析计数在期望值的N%范围内，则抑制不期望的诊断输出。'
# "Prevent optimization remarks from being output if they do not have at least this profile count. Use 'auto' to apply the threshold from profile summary"
H80EFE9F96F6F: '如果优化建议的配置文件计数不足，则阻止其输出。使用 "auto" 以应用来自配置文件摘要的阈值'
# 'Prevents emitting diagnostics when profile counts are within N% of the threshold..'
H77AE0CC1048E: '当剖面计数在阈值N%范围内时抑制诊断信息的生成'
# 'Primary key when ordering logical view (default: line).'
H7BB0C9861C88: '按逻辑视图排序时的主要键（默认：line）'
# 'Print (but do not run) the commands to run for this compilation'
HCEF688AF1304: '打印（但不运行）本次编译需要执行的命令'
# "Print Attributor's internal call graph"
H256F97E689ED: '打印Attributor的内部调用图'
# 'Print DenseElementsAttrs with a hex string that have more elements than the given upper limit (use -1 to disable)'
H4B4EB65A8AF9: '打印元素数超过给定上限的DenseElementsAttrs的十六进制字符串（使用-1禁用）'
# 'Print Enum list for this class'
HB3042274A9F1: '打印此类的Enum列表'
# 'Print ExecutionSession state after resolving entry point'
HA2AA771729BC: '在解析入口点后打印ExecutionSession状态'
# 'Print ExecutionSession state before resolving entry point'
H66A839FE6545: '在解析入口点前打印ExecutionSession状态'
# 'Print IR after each pass'
HA5EFB8CE8B9F: '在每次Pass后打印IR'
# 'Print IR after specified passes'
H3D9D708F1675: '在指定的Pass后打印IR'
# 'Print IR after the pass with this number as reported by print-pass-numbers'
HB20A8CE7B1FD: '在通过print-pass-numbers报告的此编号的Pass后打印IR'
# 'Print IR before each pass'
HDA98FFA60DB4: '在每次Pass前打印IR'
# 'Print IR before specified passes'
H328B86DC8BAB: '在指定的Pass前打印IR'
# 'Print IR before the pass with this number as reported by print-pass-numbers'
H67F2CC34678A: '在通过print-pass-numbers报告的此编号的Pass前打印IR'
# 'Print IR to path when opt-bisect-limit is reached'
H1CC46248A49A: '当达到opt-bisect-limit时将IR输出到路径'
# 'Print LLVM IR input to isel pass'
HB1E12014CD83: '打印传递给指令选择Pass的LLVM IR输入'
# 'Print MIR debug-locations'
H23CF1A75AA16: '打印MIR的调试位置'
# 'Print Machine Cycle Info Analysis'
H9577B97D25AE: '打印机器周期信息分析'
# 'Print Machine Uniformity Info Analysis'
HFCF3D928DF44: '打印机器统一性信息分析'
# 'Print Options'
H183A70DB44AF: '打印选项'
# 'Print SSA IDs using NameLocs as prefixes'
H17EB8F4CEEED: '使用NameLocs作为前缀打印SSA IDs'
# "Print a '-passes' compatible string describing the pipeline (best-effort only)."
H4C4CBF86A7C9: '生成与 "-passes" 兼容的字符串描述管线（仅尽力而为）。'
# 'Print a template comparison tree for differing templates'
H94B203D5EC04: '为不同的模板打印模板比较树'
# 'Print absolute paths in diagnostics'
H3475474B9AF0: '在诊断信息中打印绝对路径'
# 'Print addresses of MachineInstrs when dumping'
H3F08CE170EBB: '在转储时打印MachineInstrs的地址'
# 'Print addresses of instructions when dumping'
HF2156C7D4A91: '在转储时打印指令的地址'
# 'Print all GPUs (default)'
HBE69208AFD33: '列出所有GPU（默认）'
# 'Print all cost kinds'
HCAA4E47DE719: '打印所有成本类型'
# 'Print all hardware statistics'
H14BBD9376F77: '打印所有硬件统计信息'
# "Print all of Clang's warning options"
HF45E26CFBC96: '打印Clang的所有警告选项'
# 'Print all option values after command line parsing'
HB0F721DC4298: '在解析命令行参数后打印所有选项的值'
# 'Print all records to stdout (default)'
H8BF745CB973A: '将所有记录打印到标准输出（默认）'
# 'Print all results from files matching this regular expression.'
H37B62E065C22: '打印与该正则表达式匹配的文件的所有结果。'
# 'Print all views including hardware statistics'
H8A87BEED0121: '打印包括硬件统计信息的所有视图'
# 'Print allocation requests made to the memory manager by RuntimeDyld'
H36E2ACD7E011: '打印运行时动态链接器（RuntimeDyld）向内存管理器请求的分配请求'
# 'Print any external commands that are to be executed instead of actually executing them - for testing purposes.\n'
HF77F09852A60: '打印任何需要执行的外部命令而不是实际执行它们 - 用于测试目的。\n'
# 'Print architectural register names rather than the ABI names (such as r14 instead of sp)'
H9E57937A3E1F: '使用架构寄存器名称而不是ABI名称（例如用r14而不是sp）'
# 'Print assembly as linked'
HF50C5F3BF962: '打印链接后的汇编代码'
# 'Print assembly as parsed'
H75C25DD05B7B: '打印解析后的汇编代码'
# 'Print attribute dependencies'
HDE5247667B07: '打印属性依赖关系'
# 'Print available passes that can be specified in -passes=foo and exit'
HE05D65950FB2: '打印可以在-passes=foo中指定的所有可用pass并退出'
# 'Print before passes that change them'
HAEB698616AF4: '在改变它们的pass之前打印'
# 'Print binary blobs using hex escapes'
H0160E60E08F5: '使用十六进制转义打印二进制块'
# 'Print binary load events.'
H2F65BD41A1E8: '打印二进制加载事件。'
# "Print call graph to 'dot' file"
H699252A05887: "将调用图打印到 'dot' 文件"
# 'Print canonical function name.'
H39DE0BCE8940: '打印规范函数名。'
# 'Print changed IRs'
HB7CE030FBB95: '打印修改后的IR'
# 'Print cl.exe style /showIncludes to stdout'
H84DEF3CD15ED: '以cl.exe风格打印/showIncludes到标准输出'
# 'Print command line.'
H1C5C42AF6D29: '打印命令行。'
# 'Print critical path length to stdout'
H8F78BF714145: '将关键路径长度输出到标准输出'
# 'Print debug info in MLIR output'
H6859C4B3FF46: '在MLIR输出中打印调试信息'
# 'Print debug information.\n'
HB8A507E6D179: '打印调试信息。\n'
# 'Print demangled function name'
HC4B0C0E810C3: '打印解装饰的函数名'
# 'Print detailed output about what is being run to stderr.'
HE984DCC7A8C4: '将正在运行的内容的详细输出打印到stderr。'
# 'Print diagnostic category'
HCF5E624088CE: '打印诊断类别'
# 'Print directive pattern matches, or add them to the input dump\nif enabled.\n'
H928F89E57268: '打印指令模式匹配，或如果已启用则添加到输入转储\n'
# 'Print disassembled code.'
HDACEC7EBFD41: '打印反汇编代码。'
# 'Print dispatch statistics'
H2DF0F56E2112: '打印分派统计信息'
# "Print dominance tree of function to 'dot' file"
HFDEAF60A0F86: "将函数支配树打印到 'dot' 文件"
# "Print dominance tree of function to 'dot' file (with no function bodies)"
H255806455D28: "将函数支配树打印到 'dot' 文件（不包含函数体）"
# 'Print embed directives in -E mode in addition to normal output'
HA988C571D048: '在-E模式下除正常输出外，打印嵌入指令'
# 'Print encoding information in the instruction info view'
HDDF771C744F8: '在指令信息视图中打印编码信息'
# 'Print extra debugging information'
HFF9ED81B933D: '打印额外调试信息'
# 'Print extra information about adaptors and pass managers'
H8E608CF10762: '打印适配器和Pass管理器的额外信息'
# 'Print final code'
H91C18F74D9CF: '打印最终代码'
# 'Print fix-its in machine parseable form'
H8FDA449E8857: '以机器可解析形式打印修复建议'
# 'Print function to stderr'
H4E08D51481D2: '将函数打印到 stderr'
# 'Print graphs around indirect CF instructions in DOT format.'
HF75F04A7E3C5: '以DOT格式打印间接控制流指令周围的图形。'
# 'Print imported functions'
H3746D79A84CE: '打印导入的函数'
# 'Print include directives in -E mode in addition to normal output'
HD07C75D32665: '在-E模式下除正常输出外，打印包含指令'
# 'Print index-based devirtualization messages'
HBF58405294ED: '打印基于索引的虚函数解除信息'
# 'Print info about included files to stderr'
H622C6A0F6DB5: '将包含文件的信息打印到标准错误输出'
# 'Print information about actions taken'
H1ED18B4AD272: '打印执行操作的相关信息'
# 'Print information about the activities of Polly'
HCF30D81D0973: '打印Polly活动信息'
# 'Print information for functions rejected for importing'
HBD21C28A83D7: '打印被拒绝导入函数的相关信息'
# 'Print information helpful in diagnosing internal FileCheck\nissues, or add it to the input dump if enabled.  Implies\n-v.\n'
H651EBEE00CDE: '打印有助于诊断FileCheck内部问题的信息，或在启用时添加到输入转储中。隐含-v选项。\n'
# 'Print instruction latencies as verbose asm comments'
HD27FB6BC6036: '将指令延迟作为详细汇编注释打印'
# 'Print instruction tables'
H2620BE69E6DD: '打印指令表'
# 'Print instruction tables with additional information: bypass latency, LLVM opcode, used resources'
HFB383E77CA64: '打印带有附加信息的指令表：旁路延迟、LLVM操作码、使用资源'
# "Print instructions that the allocator wants to fuse, but the X86 backend currently can't"
HE530C7C7214A: '打印分配器希望融合但X86后端当前无法融合的指令'
# 'Print internal analyzer statistics.'
HAE4856542BC1: '打印内部分析器统计信息'
# 'Print legacy PassManager debugging information'
HDFED9BD864B2: '打印旧版PassManager调试信息'
# 'Print list of delta passes, passable to --delta-passes as a comma separated list'
H93E693FB4735: '打印delta passes列表，可用作逗号分隔的--delta-passes参数'
# 'Print machine instrs after ISel'
H555E49FB33C1: '打印ISel之后的机器指令'
# 'Print machine verifier errors on invalid reduction attempts triple'
HE100DF904ED4: '在无效的三元组缩减尝试时打印机器验证错误'
# 'Print macro definitions in -E mode in addition to normal output'
H0486B7210917: '在-E模式下除正常输出外，打印宏定义'
# 'Print macro definitions in -E mode instead of normal output'
HB1EFD9100CC5: '在-E模式下打印宏定义而非正常输出'
# "Print matching stats for each allocation context in this module's profiles"
H8ED3695B4B5D: '打印该模块配置文件中每个分配上下文的匹配统计信息'
# 'Print memory access functions'
H2D490B90F012: '打印内存访问函数'
# 'Print memory barrier information in the instruction info view'
H565E0827BDFD: '在指令信息视图中打印内存屏障信息'
# 'Print module to stderr'
HFFEB1D6642AE: '将模块打印到 stderr'
# 'Print more information to dbgs about GlobalISel legalizer rules being verified'
H00897DED79CD: '打印更多关于GlobalISel合法化规则验证的信息到dbgs'
# 'Print name of local stack variable'
H5190847365AF: '打印局部栈变量的名称'
# 'Print non-default options after command line parsing'
HEA27B7232530: '在命令行解析后打印非默认选项'
# 'Print numeric register names rather than the ABI names (such as $r0 instead of $zero)'
H165530C50853: '打印数字寄存器名称而非ABI名称（例如使用$r0而非$zero）'
# 'Print only the CFG without blocks body'
H75782D2B7733: '仅打印不含块体的控制流图（CFG）'
# 'Print option name with mappable diagnostics'
H158CBF9FD24C: '与可映射诊断信息一起打印选项名称'
# 'Print out debug counter info after all counters accumulated'
H2CE0455E9D85: '在所有计数器累积完成后打印调试计数器信息'
# 'Print out debug counter information after all counters have been accumulated'
H94A5B1103F3F: '在所有计数器累积完成后打印调试计数器信息'
# 'Print out mismatched BFI counts after setting profile metadata The print is enabled under -Rpass-analysis=pgo, or internal option -pass-remarks-analysis=pgo.'
H3025AA257D2E: '在设置配置文件元数据后打印不匹配的BFI计数。该打印功能在启用-Rpass-analysis=pgo选项，或内部选项-pass-remarks-analysis=pgo时生效。'
# 'Print out the non-match BFI count if a hot raw profile count becomes non-hot, or a cold raw profile count becomes hot. The print is enabled under -Rpass-analysis=pgo, or internal option -pass-remarks-analysis=pgo.'
HDD8F14466662: '当热原始配置文件计数变为非热，或冷原始配置文件计数变为热时，打印不匹配的BFI计数。该打印功能在启用-Rpass-analysis=pgo选项，或内部选项-pass-remarks-analysis=pgo时生效。'
# 'Print out the parsed ODS information from the input file'
H863FE61CF758: '打印输入文件中解析的ODS信息'
# 'Print pass management debugging information'
H639A1D9CCF1A: '打印Pass管理调试信息'
# 'Print pass names and their ordinals'
H333E30843F56: '打印Pass名称及其序号'
# 'Print performance metrics and statistics'
HE4EAA5755D11: '打印性能指标和统计信息'
# "Print postdominance tree of function to 'dot' file"
HB29C66E944CC: "将函数后支配树打印到 'dot' 文件"
# "Print postdominance tree of function to 'dot' file (with no function bodies)"
HD6176265DDFA: "将函数后支配树打印到 'dot' 文件（不包含函数体）"
# 'Print pretty debug info in MLIR output'
H1D9ED83CA568: '在MLIR输出中打印格式化的调试信息'
# 'Print pseudo probe section and disassembled info.'
H32640273947C: '打印伪探测节和反汇编信息'
# "Print regions of function to 'dot' file"
HA2F7AC936E9B: "将函数区域打印到 'dot' 文件"
# "Print regions of function to 'dot' file (with no function bodies)"
HB4D8B8B65FF0: "将函数区域打印到 'dot' 文件（不包含函数体）"
# 'Print register file statistics'
HD3E0FCA5570D: '打印寄存器文件统计信息'
# 'Print registered symbol, section, got and stub addresses'
H4788FF394730: '打印已注册符号、节、GOT和存根地址'
# 'Print retire control unit statistics'
HD5CFA03245CF: '打印退休控制单元统计信息'
# 'Print schedule DAGs'
HCD1F3A6E0736: '打印调度DAG'
# 'Print scheduler statistics'
HEAC85495C43E: '打印调度器统计信息'
# 'Print setting flow sensitive branch probabilities'
H93BFBD2C1FA2: '打印设置流敏感分支概率'
# 'Print source locations.'
H1D581A019738: '打印源代码位置。'
# 'Print source range spans in numeric form'
H6EBB5160F7AF: '以数值形式打印源代码范围跨度'
# 'Print statistic for the index in every input files'
H269BBBFD3979: '打印每个输入文件的索引统计信息'
# 'Print subprocess statistics'
HFA43D801ECBB: '打印子进程统计信息'
# 'Print summary view (enabled by default)'
HC78BAF3172BC: '打印摘要视图（默认启用）'
# 'Print supported -march extensions (RISC-V, AArch64 and ARM only)'
HFE614E88285A: '打印支持的 -march 扩展（仅 RISC-V、AArch64 和 ARM）'
# 'Print supported cpu models for the given target (if target is not specified,it will print the supported cpus for the default target)'
H83F7E7816369: '为指定的目标打印支持的CPU模型（如果未指定目标，则打印默认目标支持的CPU）'
# 'Print symbolic changes'
HEBF2FA11F574: '打印符号化更改'
# 'Print the "preamble" of a file, which is a candidate for implicit precompiled headers.'
H70A29FD77B18: '打印文件的“前言”，即隐式预编译头的候选部分。'
# 'Print the blame context (if possible) for BAD instructions. This specifies the number of lines of context to include, where zero disables this feature.'
HBD7D1281AF22: '打印BAD指令的归因上下文（如果可能）。该参数指定要包含的行数，其中零表示禁用此功能。'
# 'Print the block frequency info.'
HC5D2B22203B4: '打印块频率信息。'
# 'Print the branch probability info.'
H9D987607E791: '打印分支概率信息。'
# 'Print the canonical YAML for this file.'
HE1A3AA010C12: '打印该文件的规范YAML格式。'
# 'Print the compiler version'
HB74950BD8E88: '打印编译器版本'
# 'Print the current module after OpenMP optimizations.'
HF02AEAC96CD7: '打印OpenMP优化后的当前模块。'
# 'Print the current module before OpenMP optimizations.'
H8661FCFF114F: '打印OpenMP优化前的当前模块。'
# "Print the directory pathname containing Clang's runtime libraries"
HCF6BD300D146: '打印包含 Clang 运行时库的目录路径'
# 'Print the effective target triple'
H651D58C4EE40: '打印实际的目标三元组'
# 'Print the extensions enabled by the given target and -march/-mcpu options. (AArch64 and RISC-V only)'
HBF8F8BB9DED1: '打印目标和 -march/-mcpu 选项启用的扩展（仅 AArch64 和 RISC-V）'
# 'Print the flags used for selecting multilibs (experimental)'
H99D8793DE319: '打印用于选择多库的标志（实验性）'
# 'Print the full library path of <file>'
H996FD2BF6EA4: '打印 <file> 的完整库路径'
# 'Print the full program path of <name>'
H6425BA00826B: '打印 <name> 的完整程序路径'
# 'Print the generic op form'
H393E4B90F6FC: '打印通用操作符形式。'
# 'Print the global id for each value when reading the module summary'
H017C8976AB50: '在读取模块摘要时打印每个值的全局ID。'
# 'Print the instruction info view (enabled by default)'
HFDE24D0249FD: '打印指令信息视图（默认启用）'
# 'Print the internal representation of the AST as JSON.'
H4463E0E4D8B4: '打印AST的内部表示为JSON格式。'
# 'Print the internal representation of the AST.'
H034FD53E1499: '打印AST的内部表示。'
# 'Print the last form of the IR before crash (use -print-on-crash-path to dump to a file)'
H05148AD74D0F: '打印崩溃前IR的最终形式（使用-print-on-crash-path参数将结果保存到文件）'
# 'Print the last form of the IR before crash to a file'
H41B3ECBC245F: '打印崩溃前IR的最终形式到文件'
# 'Print the library path for the currently used compiler runtime library ("libgcc.a" or "libclang_rt.builtins.*.a")'
H1C5056AC3308: '打印当前使用的编译器运行时库的路径（“libgcc.a”或“libclang_rt.builtins.*.a”）'
# 'Print the list of headers to insert and remove'
H9F64205F2D86: '打印需要插入和移除的头文件列表'
# 'Print the list of registered dialects and exit'
H8D48045AF8B2: '打印已注册的方言列表并退出'
# 'Print the list of registered passes and exit'
HC59B7DDDC5DA: '打印已注册的转换列表并退出'
# 'Print the machine block frequency info.'
HD84FA75ACBC1: '打印机器块频率信息。'
# 'Print the matched nodes.'
H4BB21D1928B8: '打印匹配的节点。'
# 'Print the name of each compiled file'
HDCE85FDCBE9D: '打印每个已编译文件的名称'
# 'Print the normalized target triple'
H96ECE7DAB2DE: '打印规范化的目标三元组'
# 'Print the output in json format'
H7346664F1361: '以JSON格式打印输出'
# 'Print the output of crashing program'
H8E49BCDD2D2A: '打印崩溃程序的输出'
# 'Print the output of the dependency directives source minimizer'
HF8EAF7DCE928: '打印依赖项指令源最小化器的输出'
# 'Print the overhead of checks matching this glob'
HC2F8104B88AF: '打印与该通配符匹配的检查的开销'
# 'Print the path for the C++ Standard library module manifest'
H8EDB3804EDF6: '打印 C++ 标准库模块清单的路径'
# 'Print the paths used for finding ROCm installation'
H5DE6FB91D815: '打印用于查找 ROCm 安装路径的路径'
# 'Print the paths used for finding libraries and programs'
H88A6C4296147: '打印用于查找库和程序的路径'
# 'Print the pipeline that will be run'
HB9A00F6CD048: '打印将要运行的流水线'
# 'Print the registered targets'
H0D2C6AE9215B: '打印已注册的目标'
# 'Print the resource directory pathname'
HA37C029422E4: '打印资源目录路径名'
# 'Print the resource directory pathname that contains lib and include directories with the runtime libraries and MODULE files.'
HA7ED2E95EC04: '打印包含运行时库和MODULE文件的lib及include目录的资源目录路径名'
# 'Print the resource pressure view (enabled by default)'
HEECE83A65DB5: '打印资源压力视图（默认启用）'
# 'Print the summary only.'
H174D6B098765: '仅打印摘要。'
# 'Print the symbol being queried and all its relevant headers in\nJSON format to stdout:\n  {\n    "FilePath": "/path/to/foo.cc",\n    "QuerySymbolInfos": [\n       {"RawIdentifier": "foo",\n        "Range": {"Offset": 0, "Length": 3}}\n    ],\n    "HeaderInfos": [ {"Header": "\\"foo_a.h\\"",\n                      "QualifiedName": "a::foo"} ]\n  }'
H5CB3BBFB3D04: '将查询的符号及其相关头文件以JSON格式打印到标准输出：\n  {\n    "FilePath": "/path/to/foo.cc",\n    "QuerySymbolInfos": [\n       {"RawIdentifier": "foo",\n        "Range": {"Offset": 0, "Length": 3}}\n    ],\n    "HeaderInfos": [ {"Header": "\\"foo_a.h\\"",\n                      "QualifiedName": "a::foo"} ]\n  }'
# 'Print the timeline view'
H7E4B03837F1C: '打印时间线视图'
# 'Print the tokenization of the file.'
H0F40582164F4: '打印文件的词法分析结果。'
# 'Print to stdout'
H002EC692CF47: '打印到标准输出'
# 'Print type inference debug logs'
H97D56E58C1ED: '打印类型推断调试日志'
# 'Print unique SSA ID numbers for values, block arguments and naming conflicts across all regions'
H3CF739160E73: '打印所有区域内值、块参数和命名冲突的唯一SSA标识号'
# 'Print unique element ID'
H4EAB338925EE: '打印唯一元素ID'
# 'Print users of operation results and block arguments as a comment'
HFE8B9CDAE8D0: '将操作结果和块参数的使用者作为注释打印'
# 'Print version information'
H2471C1D1E728: '打印版本信息'
# 'Print warnings as well as errors'
H5031BC87FCBE: '同时打印警告和错误'
# 'Print with local scope and inline information (eliding aliases for attributes, types, and locations)'
H7DD376461997: '打印带有本地作用域和内联信息（消除属性、类型和位置的别名）'
# 'Printing a logical representation of low-level debug information.\n'
HC0290F8303A5: '打印底层调试信息的逻辑表示形式。\n'
# "Prints 'unknown' instructions that were handled heuristically. Use -msan-dump-strict-instructions to print instructions that could not be handled explicitly nor heuristically."
HBC7AE3CB843B: "打印通过启发式处理的'未知'指令。使用-msan-dump-strict-instructions来打印既无法显式也无启发式处理的指令。"
# 'Prints comments for instruction based on inline cost analysis'
H8F93FDBF8523: '根据内联成本分析为指令添加注释'
# 'Prints debug information for the new pass manager'
H2612FCB765F4: '打印新Pass管理器的调试信息'
# 'Prints full register names with percent'
HE6A6B46C9FA7: '以百分号打印完整的寄存器名称'
# 'Prints full register names with vs{31-63} as v{0-31}'
HBBE64D4048A6: '将vs{31-63}显示为v{0-31}，并打印完整寄存器名称'
# 'Prints the blame context (if possible) for ALL instructions. This specifies the number of lines of context for non-BAD instructions (see --blame-context). If --blame-context is unspecified, it prints this number of contextual lines for BAD instructions as well.'
H1C7BC51D6E48: '为所有指令打印责怪上下文（如果可能）。这指定了非BAD指令的上下文行数（见--blame-context选项）。如果未指定--blame-context，则也会为BAD指令打印该数量的上下文行数。'
# 'Prints the combined library module before the output'
HF27FB27BCDA7: '在输出前打印组合库模块'
# 'Prints the pass pipeline and returns.'
HB0A215EA899E: '打印pass管线并退出。'
# 'Prioritize loop cache cost'
H567449F48120: '优先考虑循环缓存成本'
# 'Prioritize the IVs order of each instruction'
HC3D79764BA67: '优先考虑每个指令的IV顺序'
# 'Prioritize vectorization'
H12B49F99EBF6: '优先考虑向量化'
# 'Probability value in the range [0.0, 1.0] of unconditional pseudo-random checks.'
HE60D8EB808AB: '概率值范围在[0.0, 1.0]之间的无条件伪随机检查'
# 'Probability value in the range [0.0, 1.0] to keep instrumentation of a function. Note: instrumentation can be skipped randomly OR because of the hot percentile cutoff, if both are supplied.'
H055D3EE8123A: '保留函数插装的概率值范围在[0.0, 1.0]。注意：插装可能因随机跳过或因热点百分位数阈值而被跳过（若同时指定两者）'
# 'Proceed with Loop Idiom Vectorize Pass, but do not convert byte-compare loop(s).'
H5DD9E25ED00B: '继续执行循环惯用法向量化转换，但不转换字节比较循环'
# 'Proceed with loop idiom recognize pass, but do not convert loop(s) to memcpy.'
H0FF75025AEC2: '继续执行循环惯用法识别转换，但不将循环转换为memcpy'
# 'Proceed with loop idiom recognize pass, but do not convert loop(s) to memset.'
H5ED765213633: '继续执行循环惯用法识别转换，但不将循环转换为memset'
# 'Proceed with loop idiom recognize pass, but do not convert loop(s) to strlen.'
HF94C8F5C3643: '继续执行循环惯用法识别pass，但不将循环转换为strlen。'
# 'Proceed with loop idiom recognize pass, enable conversion of loop(s) to wcslen.'
H3D374F7E71F0: '继续执行循环惯用法识别pass，启用将循环转换为wcslen。'
# 'Process Id for the profiled executable binary.'
HEAA24D9E11FE: '已分析可执行二进制文件的进程ID'
# 'Process Implicit Definitions'
H436E5B2FC994: '处理隐式定义'
# 'Process functions in a top-down order defined by the profiled call graph when -sample-profile-top-down-load is on.'
HCCB8730D9A20: '当启用-sample-profile-top-down-load时，根据分析调用图定义的自顶向下顺序处理函数'
# 'Process scops that are unlikely to benefit from Polly optimizations.'
H97882415014C: '处理那些不太可能从Polly优化中受益的scop'
# 'Process source files in fixed form'
H83D6F8A6F254: '以固定形式处理源文件'
# 'Process source files in free form'
H00F60A25C21E: '以自由形式处理源文件'
# 'Process trigraph sequences'
HE92D60C3DD89: '处理三字符序列'
# 'Processor register names.'
H69E6140DD062: '处理器寄存器名称。'
# 'Produce a faster access sequence for local-dynamic TLS variables where the offset from the TLS base is encoded as an immediate operand (AIX 64-bit only). This access sequence is not used for variables larger than 32KB.'
H96608A9C1D3A: '为局部动态TLS变量生成更快的访问序列，其中TLS基址的偏移量被编码为立即操作数（仅AIX 64 位）。该访问序列不用于大于 32KB的变量。'
# 'Produce a faster access sequence for local-exec TLS variables where the offset from the TLS base is encoded as an immediate operand (AIX 64-bit only). This access sequence is not used for variables larger than 32KB.'
HDB020B6BCE8A: '为局部执行TLS变量生成更快的访问序列，其中TLS基址的偏移量被编码为立即操作数（仅AIX 64 位）。该访问序列不用于大于 32KB的变量。'
# 'Produce gcov notes files (*.gcno)'
HA873BCAA45B3: '生成gcov注释文件（*.gcno）'
# 'Produce progress indicator when performing measurements'
H2B5CD09D6FEE: '执行测量时生成进度指示'
# 'Produce relaxation hints for linkers to try optimizing PIC call sequences into direct calls (MIPS only)'
HA18E999EA6E6: '为链接器生成松弛提示，尝试将PIC调用序列优化为直接调用（仅MIPS）'
# "Produced object files can use all ELF features supported by this binutils version and newer. If -fno-integrated-as is specified, the generated assembly will consider GNU as support. 'none' means that all ELF features can be used, regardless of binutils support. Defaults to 2.26."
H0EBB90A612ED: "生成的对象文件可以使用此binutils版本及更新版本支持的所有ELF特性。如果指定了-fno-integrated-as选项，生成的汇编将考虑GNU汇编器的支持。'none' 表示无论binutils是否支持，均可使用所有ELF特性。默认值为 2.26。"
# "Produced object files can use all ELF features supported by this binutils version and newer.If -no-integrated-as is specified, the generated assembly will consider GNU as support.'none' means that all ELF features can be used, regardless of binutils support"
H1E14DD582B2D: "生成的对象文件可以使用本binutils版本及后续版本支持的所有ELF特性。若指定了-no-integrated-as选项，生成的汇编将考虑GNU汇编器支持。'none' 表示可以使用所有ELF特性，无论binutils是否支持"
# 'Produces individual indexes for distributed backends.'
H3927BD641AFE: '为分布式后端生成独立索引。'
# 'ProfGen Options'
HA88661D355E6: 'ProfGen选项'
# "Profile action execution to a file, or stderr if  '-' is passed"
HF893EEFBCD55: '将性能分析结果输出到文件，或stderr（若传递 "-"）'
# 'Profile file loaded by -sample-profile'
HD83B6219FC6C: '-sample-profile加载的性能分析文件'
# 'Profile kind supported by show:'
H1EF9A7F6A57E: 'show支持的性能分析类型:'
# 'Profile kind:'
H8083370A6330: '性能分析类型:'
# 'Profile remapping file loaded by -sample-profile'
H0C4B9EDC4542: '-sample-profile加载的性能分析重映射文件'
# 'Profile summary info'
H60C73C1F9C77: '分析概要信息'
# 'Profile uses flow sensitive discriminators'
H238CF0A82CE7: '性能分析使用流敏感判别器'
# 'Profile with nested inlinee flatten out'
HDCD21980624B: '展开嵌套内联函数的分析配置文件'
# 'Prologue end.'
HCA56411EA86A: '函数序言结束。'
# 'Prologue/Epilogue Insertion'
H8D5DD8D22319: '插入函数序言/尾迹'
# 'Prologue/Epilogue Insertion & Frame Finalization'
HA5A6E86B1573: '函数序言/尾言插入及帧最终化'
# 'Promote Memory to Register'
H8DCCB244621C: '将内存提升为寄存器'
# 'Promote all vector constants'
HC242F7743ACD: '提升所有向量常量'
# 'Propagate attributes in index'
HA59CB2A030BF: '传播索引中的属性'
# 'Propagate labels from condition values of select instructions to results.'
H2CDE89FF2376: '将select指令的条件值的标签传播到结果中。'
# 'Propagate non floating-point const stores as floating point values.For debugging purposes only'
HE1F8858006F6: '将非浮点型const存储传播为浮点值。仅用于调试目的'
# 'Provide additional constraints on the context parameters'
H7259373CFB29: '为上下文参数提供额外约束'
# 'Provide information about a particular module file'
HA7807B5E312C: '提供某个特定模块文件的信息'
# 'Provide minimal debug info in the object/executable to facilitate online symbolication/stack traces in the absence of .dwo/.dwp files when using Split DWARF'
HD5C39FAF7423: '在对象/可执行文件中生成最小的调试信息，以便在使用Split DWARF且没有.dwo/.dwp文件时进行在线符号解析/堆栈跟踪'
# 'Provide the index produced by a ThinLink, required to perform the promotion and/or importing.'
HF72EED5DEBD8: '提供由ThinLink生成的索引，用于执行提升和/或导入操作。'
# 'Prune dependences between unrelated Phi nodes.'
HF00163550893: '修剪无关Phi节点之间的依赖关系。'
# 'Prune loop carried order dependences.'
H49F00DC5D681: '修剪循环携带的顺序依赖关系。'
# 'Put MODULE files in <dir>'
HEED5CC89CC67: '将MODULE文件放入 <dir> 目录'
# 'Put crash-report files in <dir>'
H837FCDFF092D: '将崩溃报告文件放入 <dir> 目录'
# 'Put each data item in its own section'
HF905C168CBCB: '将每个数据项放入独立的节区'
# 'Put each function in its own section'
H169F18C51BFF: '将每个函数放入独立的节区'
# 'Put global and static data smaller than the limit into a special section'
H7B737FFA3469: '将小于限制的全局和静态数据放入特殊节区'
# 'Put objects of at most <size> bytes into small data section (MIPS / Hexagon)'
HB5EE66FF14A5: '将最多 <size> 字节的对象放入小数据段（MIPS/Hexagon）'
# 'Putting Jump Table in function section'
H0F2B2856EA39: '将跳转表放入函数节中'
# 'Qualified name of the symbol being queried.'
H4AFFA7C26BA4: '正在查询的符号的限定名称。'
# 'Qualified name to look up.'
H93CF54DB05CD: '要查找的限定名称。'
# 'Queries LTOModule::hasCtorDtor() on each IR file'
HDD169C16F456: '在每个IR文件上查询LTOModule::hasCtorDtor()'
# 'Query a given symbol (e.g. "a::b::foo") in\ndatabase directly without parsing the file.'
H8F2B84E16EA3: '直接在数据库中查询给定符号（例如“a::b::foo”），无需解析文件。'
# 'Query string to be fuzzy-matched'
HA5E343EDC113: '需要模糊匹配的查询字符串'
# 'Quotient that is obtained by dividing Nc, the parameter of themacro-kernel, by Nr, the parameter of the micro-kernel'
HFC3149B97C2A: '将宏内核的参数Nc除以微内核的参数Nr所得的商'
# 'R600 Clause Merge'
HFCF9C3C3445E: 'R600 子句合并'
# 'R600 Control Flow Finalizer'
H19DB6E58B0FB: 'R600 控制流最终处理'
# 'R600 Emit Clause Markers'
H668E900B8AFA: 'R600 发射子句标记'
# 'R600 Expand Special Instrs'
H12D8DBCC740A: 'R600 展开特殊指令'
# 'R600 Packetizer'
H38622892495A: 'R600 数据包分组器'
# 'R600 Vector Reg Merger'
H9C6C89BC6C1D: 'R600 向量寄存器合并'
# 'R600ExpandSpecialInstrs'
HD068997DE698: 'R600展开特殊指令'
# "RISC-V 'interrupt' attribute '%0' requires extension '%1'"
H8A25210ABAD4: "RISC-V 'interrupt' 属性 '%0' 需要扩展 '%1'"
# "RISC-V 'interrupt' attribute contains invalid combination of interrupt types"
H3F0F8D14C6DB: "RISC-V 'interrupt' 属性包含无效的中断类型组合"
# 'RISC-V Assembly Printer'
H9361560AFA27: 'RISC-V汇编打印机'
# 'RISC-V CodeGenPrepare'
H405FA7A845BC: 'RISC-V 代码生成准备'
# 'RISC-V DAG->DAG Pattern Instruction Selection'
H1C9181DFD79E: 'RISC-V DAG->DAG模式指令选择'
# 'RISC-V Dead register definitions'
HC73090960463: 'RISC-V死寄存器定义'
# 'RISC-V Fold Masks'
H0F357F81783D: 'RISC-V 合并掩码'
# 'RISC-V Fold Memory Offset'
HBC0E6B2D64FC: 'RISC-V折叠内存偏移'
# 'RISC-V Indirect Branch Tracking'
H10B581240D72: 'RISC-V间接分支跟踪'
# 'RISC-V Insert Read/Write CSR Pass'
H05452489D81B: 'RISC-V插入读写CSR Pass'
# 'RISC-V Insert VSETVLI pass'
H38C90053B8F4: 'RISC-V插入VSETVLI Pass'
# 'RISC-V Insert Write VXRM Pass'
H73DBEFBC725F: 'RISC-V插入写入VXRM Pass'
# 'RISC-V Landing Pad Setup'
HAD75D026A39E: 'RISC-V 异常处理着陆垫设置'
# 'RISC-V Late Branch Optimisation Pass'
HED8417E9F658: 'RISC-V 晚期分支优化Pass'
# 'RISC-V Load / Store Optimizer'
H10B62FA90EDD: 'RISC-V加载/存储优化器'
# 'RISC-V Make Compressible'
H0497794478D9: 'RISC-V使可压缩'
# 'RISC-V Merge Base Offset'
HA38F1E005B04: 'RISC-V合并基址偏移'
# 'RISC-V Optimize W Instructions'
H2B91D1998005: 'RISC-V优化W指令'
# 'RISC-V Redundant Copy Elimination'
HD915B17CC89F: 'RISC-V 消除冗余复制'
# 'RISC-V VL Optimizer'
H811C35753CA5: 'RISC-V VL优化器'
# 'RISC-V VMV0 Elimination'
H474A6943E72F: 'RISC-V VMV0 消除'
# 'RISC-V Zacas ABI fix'
HF1D5344F95CB: 'RISC-V Zacas ABI修复'
# 'RISC-V Zcmp Push/Pop optimization pass'
HD89E7CCB5461: 'RISC-V Zcmp压栈/弹栈优化Pass'
# 'RISC-V Zcmp move merging pass'
H9FBA8B3D1AEE: 'RISC-V Zcmp移动合并Pass'
# 'RISC-V atomic pseudo instruction expansion pass'
H3692DAF330DE: 'RISC-V原子伪指令扩展Pass'
# 'RISC-V gather/scatter lowering pass'
H05AC68772FF6: 'RISC-V gather/scatter降级pass'
# 'RISC-V post-regalloc pseudo instruction expansion pass'
H7D576AB43EFF: 'RISC-V寄存器分配后伪指令扩展pass'
# 'RISC-V pseudo instruction expansion pass'
H0A43861EEE99: 'RISC-V伪指令扩展pass'
# "RISC-V type %0 requires the '%1' extension"
HD2DE400562E4: "RISC-V类型 %0 需要 '%1' 扩展"
# 'ROCm device library path. Alternative to rocm-path.'
H671F96D79AC7: 'ROCm设备库路径。rocm-path的替代选项'
# 'ROCm installation path, used for finding and automatically linking required bitcode libraries.'
HF802D566C208: 'ROCm安装路径，用于查找和自动链接所需的比特码库'
# 'ROPI is not compatible with c++'
HF729D02F7368: 'ROPI与C++不兼容'
# 'RTDyld Options'
HE939F729D84E: 'RTDyld选项'
# 'Random hotness seed to use (0 to generate new seed)'
H8A5B93398F3C: '使用的随机热度种子（0表示生成新种子）'
# 'Range reduction is disabled for complex arithmetic operations'
H2F5A5383A90A: '禁用复数算术运算的范围缩减'
# 'Range reduction is enabled for complex arithmetic operations.'
H9F0817B3FD56: '启用复数算术运算的范围缩减'
# 'Range to search for II'
HFC1D9F881BD5: '搜索II的范围'
# 'Ratio of VGPRs to budget for promoting alloca to vectors'
H825278A853D1: '将alloca提升为向量时，VGPR与预算的比例'
# 'Re-materialize load from stub in PIC mode'
H3683BABDE7E9: '在PIC模式下重新生成来自存根的加载'
# 'ReachingDefAnalysis'
H10A4CB1F102D: '可达定义分析'
# 'Read commands from file'
HDC06C8ECE255: '从文件读取命令'
# 'Read function map names in indexed CodeGenData. Can be disabled to save memory and time for final consumption of the indexed CodeGenData in production.'
H1E1056B753A2: '读取索引CodeGenData中的函数映射名称。可在生产环境中禁用以节省内存和时间，用于最终消费索引CodeGenData。'
# 'Read specified document from input (default = 1)'
H289DB22297D5: '从输入中读取指定的文档（默认值=1）'
# 'Read summary from given YAML file before running pass'
HA5D8047CC861: '在运行Pass之前从指定的YAML文件读取摘要'
# 'Read summary from given bitcode or YAML file before running pass'
HF2C570D041A3: '在运行Pass之前从给定的bitcode或YAML文件读取摘要'
# 'Read-write data relocatable, accessed relative to static base'
HDB933E15EC9A: '可重定位的读写数据，相对于静态基址访问'
# 'Reads and parses a basic block sections profile.'
HB98EF81EB7F2: '读取并解析基本块段配置文件。'
# 'Realign stack to the value of this flag (power of two)'
H85DCE488EFC2: '将栈重新对齐为此标志的值（必须是 2 的幂）'
# 'Reassociate expressions'
H525BB5A9D397: '重新关联表达式'
# 'Rebalance address calculation trees to improve instruction selection'
HD14562B4E0A1: '重新平衡地址计算树以优化指令选择'
# 'Rebalance address tree only if it is imbalanced'
HB25FBDDE88D4: '仅在地址树不平衡时进行重新平衡'
# 'Rebalance address tree only if this allows optimizations'
H15A2B09D172E: '仅当可以进行优化时才重新平衡地址树'
# 'Reciprocal throughput'
H5BE31D7872D9: '倒数吞吐量'
# 'Recognize Hexagon-specific loop idioms'
H0CB87B633349: '识别Hexagon特定循环惯用法'
# 'Recognize and construct Pascal-style string literals'
HA6AC1DFB5663: '识别并构造Pascal风格的字符串字面量'
# 'Recognize reduction patterns.'
H8EBBA21EF01B: '识别规约模式。'
# 'Record GlobalISel rule coverage files of this prefix if instrumentation was generated'
HB262A353ECFE: '如果生成了插桩，则记录该前缀的GlobalISel规则覆盖率文件'
# 'Record stack frames with tagged allocations in a thread-local ring buffer'
H1B5FE744704A: '将带有标记分配的栈帧记录到线程本地的环形缓冲区中'
# 'Record time trace'
H572EF7DA605F: '记录时间轨迹'
# 'Recursively extract all called functions'
H04C195C76643: '递归提取所有被调用函数'
# 'Redirect output to the specified file.'
H7E10ABCF17E8: '将输出重定向到指定文件。'
# 'Reduce named metadata without taking its type into account'
H057F6A50F385: '不考虑类型的情况下减少命名元数据'
# 'Reduce terminal output'
H77FB68186DA4: '减少终端输出'
# 'Reduce the number of instrumented blocks'
HCA859F9847BF: '减少插桩块的数量'
# 'Reduced priority compared to interactive work.'
H7591B998C026: '与交互式工作相比优先级降低。'
# 'Refactoring options'
HF98C4D962B99: '重构选项'
# 'Reference type.'
HECBDD73B4748: '引用类型。'
# 'Refrain from using FP whenever possible'
H567347A5F936: '尽可能避免使用FP'
# 'Regalloc eviction policy'
HF2E6FE69E8A8: '寄存器分配驱逐策略'
# 'Regalloc priority policy'
H20E1A4B298F4: '寄存器分配优先级策略'
# 'Regard unreachable functions as possible devirtualize targets.'
HC7FBD9EBE035: '将不可达函数视为可能的虚函数解析目标。'
# "Regex of name of op's to exclude (no filter if empty)"
HA7F3D7BB58EA: '要排除的操作符名称的正则表达式（若为空则不进行过滤）'
# "Regex of name of op's to include (no filter if empty)"
H5284DD90C012: '要包含的操作符名称的正则表达式（若为空则不进行过滤）'
# 'Register Allocation Scoring Pass'
H4ED04651AE8B: '寄存器分配评分Pass'
# 'Register Coalescer'
HAC4DFBDFBBCC: '寄存器合并器'
# 'Register Usage Information Collector'
HE69ABB0B3B23: '寄存器使用信息收集器'
# 'Register Usage Information Propagation'
H3B0328B5CFCB: '寄存器使用信息传播'
# 'Register Usage Information Storage'
H9CFCD5C04174: '寄存器使用信息存储'
# 'Register allocator to use'
H01245B8A9746: '要使用的寄存器分配器'
# 'Register allocator to use for RVV register.'
H16A5AC5915C9: '要使用的RVV寄存器分配器。'
# 'Register allocator to use for SGPRs'
H14FE52F5159B: '要使用的SGPR寄存器分配器'
# 'Register allocator to use for VGPRs'
HB6E601BA3FB0: '要使用的VGPR寄存器分配器'
# 'Register allocator to use for WWM registers'
H2FF0F90865DC: '要使用的WWM寄存器分配器'
# 'Register allocator to use for new pass manager'
H2F824F849DFC: '新pass管理器要使用的寄存器分配器'
# 'Reject specializations whose codesize savings are less than this much percent of the original function size'
H6EAED91C8037: '拒绝代码大小节省低于原始函数大小该百分比的特殊化'
# 'Reject specializations whose inlining bonus is less than this much percent of the original function size'
H6A8C88532B88: '拒绝内联奖励低于原始函数大小该百分比的特殊化'
# 'Reject specializations whose latency savings are less than this much percent of the original function size'
H289ADC17A173: '拒绝延迟节省低于原始函数大小该百分比的特殊化'
# 'Reject the profile if the mismatch percent is higher than the given number.'
H8455CF01EC30: '如果不匹配百分比高于给定数值，则拒绝该配置文件。'
# 'Relation kind for the predicate.'
HA372CC9D1BF6: '谓词的关系类型。'
# 'Relative error tolerated'
HA4C6C4674C77: '允许的相对误差'
# 'Relative frequency of outline region to the entry block'
H22B3E2A06E70: '轮廓区域相对于入口块的相对频率'
# 'Relative hotness percentage threshold for indirect call promotion in proirity-based sample profile loader inlining.'
H046C25DB3427: '基于proirity的优先级样本配置文件加载器内联中，间接调用提升的相对热度百分比阈值。'
# 'Relax checks of new-value validity'
H6708AC4FB40C: '放宽新值有效性的检查'
# "Relax language rules and try to match the behavior of the target's native float-to-int conversion instructions"
HC867ACE28A09: '放宽语言规则，尝试与目标原生的float-to-int转换指令的行为相匹配'
# 'Relax occupancy targets for kernels which are memory bound (amdgpu-membound-threshold), or Wave Limited (amdgpu-limit-wave-threshold).'
HF2EE3E994ED5: '放宽由内存限制（amdgpu-membound-threshold）或波长限制（amdgpu-limit-wave-threshold）导致的内核占用率目标。'
# 'Relax out of range conditional branches'
H0294D6B1AD74: '放宽越界的条件分支'
# 'Relocatable external references, non-relocatable code'
H5C17064AB794: '可重定位的外部引用，不可重定位的代码'
# 'Remapping file'
H3732B171A6F4: '重映射文件'
# 'Remark file utilities\n'
HF16F906278C7: '备注文件工具\n'
# 'Remote execution (rsh/ssh) extra options'
H866585C76383: '远程执行（rsh/ssh）额外选项'
# 'Remote execution (rsh/ssh) host'
HBAFCAFBDA09E: '远程执行（rsh/ssh）主机'
# 'Remote execution (rsh/ssh) port'
HF897190244A2: '远程执行（rsh/ssh）端口'
# 'Remote execution (rsh/ssh) user id'
H34FEDDEF1D08: '远程执行（rsh/ssh）用户标识'
# 'Remote execution client (rsh/ssh)'
H9FB0D35F3462: '远程执行客户端（rsh/ssh）'
# 'Remove .symtab section'
HDFF82FC1A75B: '移除.symtab节'
# "Remove CUDA/HIP offloading device architecture (e.g. sm_35, gfx906) from the list of devices to compile for. 'all' resets the list to its default value."
HC1BC07C832AB: "从要编译的设备列表中移除CUDA/HIP卸载设备架构（例如sm_35、gfx906）。'all' 将列表重置为默认值"
# 'Remove Loads Into Fake Uses'
H633E035AD42E: '移除伪用途中的加载操作'
# 'Remove Redundant DEBUG_VALUE analysis'
H9B54876630EC: '删除冗余的DEBUG_VALUE分析'
# 'Remove Sign and Zero Extends for Args'
H7F0FDF466871: '移除参数的符号和零扩展'
# "Remove an attribute from a function. This can be a pair of 'function-name:attribute-name' to remove an attribute from a specific function. For example -force-remove-attribute=foo:noinline. Specifying only an attribute will remove the attribute from all functions in the module. This option can be specified multiple times."
HC96183D47DE8: "移除函数的属性。这可以是 'function-name:attribute-name' 的键值对，用于移除特定函数的属性。例如 -force-remove-attribute=foo:noinline。仅指定属性名时，将从模块内所有函数中移除该属性。该选项可重复使用。"
# 'Remove dead machine instructions'
H849DB0ECAC7B: '删除死机器指令'
# 'Remove duplicate DecoderTable entries generated due to HwModes'
HA7463EA0ACB3: '移除因HwModes生成的重复DecoderTable条目'
# 'Remove pseudo-probe after sample profile annotation.'
H6C8C4BABBDBA: '在样本配置文件注释后移除伪探针。'
# 'Remove redundant Address-Size override prefix'
H8CDB6DE4DE72: '移除冗余的Address-Size覆盖前缀'
# 'Remove redundant instructions'
HC432DEAE7361: '移除冗余指令'
# 'Remove the change description files regardless of successful\nmerging/replacing.'
HE8F5AA354FF8: '无论合并/替换是否成功，移除变更描述文件。'
# 'Remove unreachable blocks from the CFG'
H71C9E890BAC6: '从控制流图中删除不可达块'
# 'Remove unreachable machine basic blocks'
H6EBEC50FE707: '删除不可达的机器基本块'
# 'Removes debug compile units which reference to non-existing global constants'
HEC2FF74E6087: '移除引用不存在全局常量的调试编译单元'
# 'Removes empty basic blocks and redirects their uses to their fallthrough blocks.'
H1E3948BB5559: '删除空的基本块并将它们的用处重定向到后续基本块。'
# 'Removes irreducible control flow'
HD2920C925B96: '移除不可约简的控制流'
# 'Removes range checks and sets br_table default targets'
H2B9F2567CD82: '删除范围检查并设置br_table默认目标'
# 'Rename Independent Subregisters'
HE4B797E90A33: '重命名独立子寄存器'
# 'Rename Register Operands'
H1AB17AA29EA4: '重命名寄存器操作数'
# 'Rename Register Operands Canonically'
H9BD8A9C1263B: '规范重命名寄存器操作数'
# 'Rename counter variable of a comdat function based on cfg hash'
HB71CC1C2B75A: '基于cfg哈希重命名comdat函数的计数器变量'
# 'Reorder instructions to use the WebAssembly value stack'
H6D195AC096F5: '重新排序指令以使用WebAssembly值栈'
# 'Reorders blocks in topological order'
H903DAE6FC729: '按拓扑顺序重新排列块'
# 'Repack arrays that are non-contiguous in any dimension. If set to false, only the arrays non-contiguous in the leading dimension will be repacked'
H16B0416B17A1: '重新打包在任何维度上非连续的数组。若设置为false，则仅重新打包主维度上非连续的数组'
# 'Repeat compilation N times for timing'
HD8053595EBB4: '重复编译N次以测量时间'
# "Replace 'mul x, Const' with more effective instructions like SHIFT, LEA, etc."
HC54A5626311D: '用更有效的指令（如SHIFT、LEA等）替换 "mul x, Const"'
# 'Replace ARM non-local ADR instructions with ADRP'
H4558533FD5F3: '将ARM非本地ADR指令替换为ADRP'
# 'Replace PHIs by their incoming values'
H49377A409B02: '用其输入值替换PHI节点'
# 'Replace all memory allocation / deallocation calls with hipManagedMalloc / hipFree equivalents'
HC778D804F89A: '用hipManagedMalloc/hipFree等效函数替换所有内存分配/释放调用'
# 'Replace intrinsics with calls to vector library'
H4BF82E4A463A: '用向量库调用替换intrinsics'
# 'Replace narrow shifts with wider shifts.'
HF4525F5A5F2E: '用更宽的移位操作替换窄移位操作'
# 'Replace occurrences of __nvvm_reflect() calls with 0/1'
H9A0C0F0562E0: '将__nvvm_reflect()调用替换为 0 或 1'
# 'Replace physical registers with virtual registers'
H2480E837105C: '用虚寄存器替换物理寄存器'
# 'Replace pointer out arguments with struct returns for non-private address space'
H8307543C4AE7: '在非私有地址空间中，将指针输出参数替换为结构体返回'
# 'Replace returns with jumps to ``__x86_return_thunk`` (x86 only, error otherwise)'
H59B021D12978: '用对__x86_return_thunk的跳转替换返回（仅x86支持，否则报错）'
# 'Replace string for rename'
H722DD7E4F6B2: '重命名时使用的替换字符串'
# 'Replace target triples in input files with this triple'
H1FCD419A56EC: '用此目标三元组替换输入文件中的目标三元组'
# 'Replace the contents of the <from> file with the contents of the <to> file'
H96ECB37ACA86: '将 <from> 文件的内容替换为 <to> 文件的内容'
# 'Replace unspecified target triples in input files with this triple'
H1555B263A14F: '用此三元组替换输入文件中未指定的目标三元组'
# 'Replacement Options'
H70C1BA182651: '替换选项'
# 'Replay on functions that have remarks associated with them (default)'
H318EBF2AE0C8: '在带有备注的函数上重新执行（默认）'
# 'Replay on the entire module'
H7E3D6FBCD48C: '在整个模块上重新执行'
# 'Replay previous inlining and adjust context profile accordingly'
HC992566EB323: '重新执行之前的内联操作，并相应调整上下文配置文件'
# 'Report Options'
HB03D5D95141E: '报告选项'
# 'Report host JIT support'
HD82BFA66FA55: '报告主机JIT支持'
# 'Report missed transformations by optimization passes whose name matches the given POSIX regular expression'
H38AEDA823701: '报告与给定POSIX正则表达式匹配的优化pass未执行的转换'
# 'Report top stacks within each thread id'
H9AC494BD87C5: '报告每个线程ID内的顶部堆栈'
# 'Report top/bottom cycles when dumping SUnit instances'
H06A96EFDD1F5: '在倾倒SUnit实例时报告顶部/底部循环'
# 'Report total allocation sizes of hinted allocations'
H900F23D3261D: '报告提示分配的总分配大小'
# 'Report transformation analysis from optimization passes whose name matches the given POSIX regular expression'
HB0E9E547E094: '报告与给定POSIX正则表达式匹配的优化pass的转换分析'
# 'Report transformations performed by optimization passes whose name matches the given POSIX regular expression'
H815014839294: '报告与给定POSIX正则表达式匹配的优化pass执行的转换'
# 'Reports layout used for print, compare and select.'
HF32D32507443: '报告用于打印、比较和选择的布局'
# 'Require & in extract patterns'
H9F971AAB4945: '在提取模式中要求使用&符号'
# 'Require all positive matches to cover an entire input line.\nAllows leading and trailing whitespace if --strict-whitespace\nis not also passed.'
HA9004341F6EF: '要求所有正向匹配覆盖整行输入内容。\n如果未同时传入--strict-whitespace参数，则允许前后空格。'
# 'Require declaration of modules used within a module'
HE82DE2BF2262: '要求声明模块内部使用的模块'
# 'Require math functions to indicate errors by setting errno'
HE643AF2E91DD: '要求数学函数通过设置errno来指示错误'
# 'Require member pointer base types to be complete if they would be significant under the Microsoft ABI'
HF98EE3CAFBC8: '如果在Microsoft ABI下有意义，要求成员指针基类型为完整类型'
# 'Require target function definition when promoting indirect calls'
H559562EE460E: '在提升间接调用时要求目标函数定义'
# 'Reserve application registers (%g2-%g4)'
H9C435D2EFFB6: '保留应用程序寄存器 (%g2-%g4)'
# "Reserve physical registers, so they can't be used by register allocator. Should only be used for testing register allocator."
HB426310B498F: '保留物理寄存器，使其无法被寄存器分配器使用。仅用于测试寄存器分配器时使用。'
# 'Reserve register r19 (Hexagon only)'
HDD745592B167: '保留寄存器r19（仅Hexagon）'
# 'Reserve the G1 register (SPARC only)'
H20A9F2798EED: '保留G1寄存器（仅SPARC）'
# 'Reserve the G2 register (SPARC only)'
HF2BF8B6A9338: '保留G2寄存器（仅SPARC）'
# 'Reserve the G3 register (SPARC only)'
HEFD5459112F2: '保留G3寄存器（仅限SPARC）'
# 'Reserve the G4 register (SPARC only)'
HED0501965935: '保留G4寄存器（仅限SPARC）'
# 'Reserve the G5 register (SPARC only)'
H484BE92A9AAA: '保留G5寄存器（仅限SPARC）'
# 'Reserve the G6 register (SPARC only)'
H3E53244E7E33: '保留G6寄存器（仅限SPARC）'
# 'Reserve the G7 register (SPARC only)'
H8A30A1691BA0: '保留G7寄存器（仅限SPARC）'
# 'Reserve the I0 register (SPARC only)'
H42D22EDC8263: '保留I0寄存器（仅限SPARC）'
# 'Reserve the I1 register (SPARC only)'
HDC1C8763F288: '保留I1寄存器（仅限SPARC）'
# 'Reserve the I2 register (SPARC only)'
HF4C9D78BA277: '保留I2寄存器（仅限SPARC）'
# 'Reserve the I3 register (SPARC only)'
H6F74928ECDE5: '保留I3寄存器（仅限SPARC）'
# 'Reserve the I4 register (SPARC only)'
H96A8F3461A2B: '保留I4寄存器（仅限SPARC）'
# 'Reserve the I5 register (SPARC only)'
H2CC0E7760C25: '保留I5寄存器（仅限SPARC）'
# 'Reserve the L0 register (SPARC only)'
HE5E9B59351B3: '保留L0寄存器（仅限SPARC）'
# 'Reserve the L1 register (SPARC only)'
HC7B2711CCD38: '保留L1寄存器（仅限SPARC）'
# 'Reserve the L2 register (SPARC only)'
HE3E6D3620DCE: '保留L2寄存器（仅限SPARC）'
# 'Reserve the L3 register (SPARC only)'
H2079C316B58D: '保留L3寄存器（仅限SPARC）'
# 'Reserve the L4 register (SPARC only)'
HFDCEA5E83E9A: '保留L4寄存器（仅限SPARC）'
# 'Reserve the L5 register (SPARC only)'
H0DAAEFB046EA: '保留L5寄存器（仅限SPARC）'
# 'Reserve the L6 register (SPARC only)'
HA3AB8DC9562A: '保留L6寄存器（仅限SPARC）'
# 'Reserve the L7 register (SPARC only)'
HCB368E5B3769: '保留L7寄存器（仅限SPARC）'
# 'Reserve the O0 register (SPARC only)'
H23D89F231DEE: '保留O0寄存器（仅限SPARC）'
# 'Reserve the O1 register (SPARC only)'
H565A40459A05: '保留O1寄存器（仅限SPARC）'
# 'Reserve the O2 register (SPARC only)'
H36A0BD878A7A: '保留O2寄存器（仅限SPARC）'
# 'Reserve the O3 register (SPARC only)'
H254E112FF4DF: '保留O3寄存器（仅限SPARC）'
# 'Reserve the O4 register (SPARC only)'
H1284739ABBC2: '保留O4寄存器（仅限SPARC）'
# 'Reserve the O5 register (SPARC only)'
H855A27DC8B76: '保留O5寄存器（仅限SPARC）'
# 'Reserve the a0 register (M68k only)'
HC6CC635B6FFE: '保留a0寄存器（仅限M68k）'
# 'Reserve the a1 register (M68k only)'
H1017DAEE99AB: '保留a1寄存器（仅限M68k）'
# 'Reserve the a2 register (M68k only)'
H7621CB376F01: '保留a2寄存器（仅限M68k）'
# 'Reserve the a3 register (M68k only)'
HE22C009182A1: '保留a3寄存器（仅限M68k）'
# 'Reserve the a4 register (M68k only)'
H3178F7022236: '保留a4寄存器（仅限M68k）'
# 'Reserve the a5 register (M68k only)'
HA629301B0BC6: '保留a5寄存器（仅限M68k）'
# 'Reserve the a6 register (M68k only)'
H94D9B1D39C5A: '保留a6寄存器（仅限M68k）'
# 'Reserve the d0 register (M68k only)'
H9890925E1B8B: '保留d0寄存器（仅限M68k）'
# 'Reserve the d1 register (M68k only)'
H9D44B760CA90: '保留d1寄存器（仅限M68k）'
# 'Reserve the d2 register (M68k only)'
H7A1C1C89C2E5: '保留d2寄存器（仅限M68k）'
# 'Reserve the d3 register (M68k only)'
H2D88664BB126: '保留d3寄存器（仅限M68k）'
# 'Reserve the d4 register (M68k only)'
HA604540B0E07: '保留d4寄存器（仅限M68k）'
# 'Reserve the d5 register (M68k only)'
H90F714B743C6: '保留d5寄存器（仅限M68k）'
# 'Reserve the d6 register (M68k only)'
H39C48EDA520F: '保留d6寄存器（仅限M68k）'
# 'Reserve the d7 register (M68k only)'
H02BEF5875762: '保留d7寄存器（仅限M68k）'
# 'Reserve the r9 register (ARM only)'
H32BC76F3A5B8: '保留r9寄存器（仅限ARM）'
# 'Reserve the x1 register (AArch64/RISC-V only)'
H017A3C6C7049: '保留x1寄存器（仅限AArch64/RISC-V）'
# 'Reserve the x10 register (AArch64/RISC-V only)'
H2D00D0C6D8F6: '保留x10寄存器（仅限AArch64/RISC-V）'
# 'Reserve the x11 register (AArch64/RISC-V only)'
H22733F8F5483: '保留x11寄存器（仅限AArch64/RISC-V）'
# 'Reserve the x12 register (AArch64/RISC-V only)'
HAA70056FA5B7: '保留x12寄存器（仅限AArch64/RISC-V）'
# 'Reserve the x13 register (AArch64/RISC-V only)'
H50BB54A67F09: '保留x13寄存器（仅限AArch64/RISC-V）'
# 'Reserve the x14 register (AArch64/RISC-V only)'
HE826489CFC34: '保留x14寄存器（仅限AArch64/RISC-V）'
# 'Reserve the x15 register (AArch64/RISC-V only)'
HC23E86C037A9: '保留x15寄存器（仅限AArch64/RISC-V）'
# 'Reserve the x16 register (AArch64/RISC-V only)'
H86953DAD10E7: '保留x16寄存器（仅限AArch64/RISC-V）'
# 'Reserve the x17 register (AArch64/RISC-V only)'
HE02356B0C142: '保留x17寄存器（仅限AArch64/RISC-V）'
# 'Reserve the x18 register (AArch64/RISC-V only)'
HF2317F641E49: '保留x18寄存器（仅限AArch64/RISC-V）'
# 'Reserve the x19 register (AArch64/RISC-V only)'
H8F6A7020EC68: '保留x19寄存器（仅限AArch64/RISC-V）'
# 'Reserve the x2 register (AArch64/RISC-V only)'
HDEC6D50548DB: '保留x2寄存器（仅限AArch64/RISC-V）'
# 'Reserve the x20 register (AArch64/RISC-V only)'
H45338EFD5444: '保留x20寄存器（仅限AArch64/RISC-V）'
# 'Reserve the x21 register (AArch64/RISC-V only)'
HA93990937323: '保留x21寄存器（仅限AArch64/RISC-V）'
# 'Reserve the x22 register (AArch64/RISC-V only)'
H26B62228E618: '保留x22寄存器（仅限AArch64/RISC-V）'
# 'Reserve the x23 register (AArch64/RISC-V only)'
HF22114CBFC6D: '保留x23寄存器（仅限AArch64/RISC-V）'
# 'Reserve the x24 register (AArch64/RISC-V only)'
H83F65EC51004: '保留x24寄存器（仅限AArch64/RISC-V）'
# 'Reserve the x25 register (AArch64/RISC-V only)'
H2B3946E5495E: '保留x25寄存器（仅限AArch64/RISC-V）'
# 'Reserve the x26 register (AArch64/RISC-V only)'
H094A3CECAC3C: '保留x26寄存器（仅限AArch64/RISC-V）'
# 'Reserve the x27 register (AArch64/RISC-V only)'
H061585C0784C: '保留x27寄存器（仅适用于AArch64/RISC-V）'
# 'Reserve the x28 register (AArch64/RISC-V only)'
H1DF10547E904: '保留x28寄存器（仅适用于AArch64/RISC-V）'
# 'Reserve the x29 register (AArch64/RISC-V only)'
H87F78D168B6D: '保留x29寄存器（仅适用于AArch64/RISC-V）'
# 'Reserve the x3 register (AArch64/RISC-V only)'
H725FF72DC894: '保留x3寄存器（仅适用于AArch64/RISC-V）'
# 'Reserve the x30 register (AArch64/RISC-V only)'
H59143D663AD6: '保留x30寄存器（仅适用于AArch64/RISC-V）'
# 'Reserve the x31 register (AArch64/RISC-V only)'
HFFDF93DA3671: '保留x31寄存器（仅适用于AArch64/RISC-V）'
# 'Reserve the x4 register (AArch64/RISC-V only)'
H9F239EBCD413: '保留x4寄存器（仅适用于AArch64/RISC-V）'
# 'Reserve the x5 register (AArch64/RISC-V only)'
H2EA831621531: '保留x5寄存器（仅适用于AArch64/RISC-V）'
# 'Reserve the x6 register (AArch64/RISC-V only)'
HCE48DE527FE3: '保留x6寄存器（仅适用于AArch64/RISC-V）'
# 'Reserve the x7 register (AArch64/RISC-V only)'
HD802526DCF57: '保留x7寄存器（仅适用于AArch64/RISC-V）'
# 'Reserve the x8 register (AArch64/RISC-V only)'
H37CBBA5AD749: '保留x8寄存器（仅适用于AArch64/RISC-V）'
# 'Reserve the x9 register (AArch64/RISC-V only)'
H0CB86AACC5EE: '保留x9寄存器（仅适用于AArch64/RISC-V）'
# 'Reset machine function if ISel failed'
H7A45CC070EB3: '如果指令选择失败则重置机器函数'
# 'Resolution-based LTO test harness'
HFC41C14199C7: '基于解析的 LTO 测试框架'
# 'Resolve file paths relative to the specified directory'
HB397A2AE991E: '相对于指定目录解析文件路径'
# 'Restore original linkage of globals prior to CodeGen'
H30AC23ACCA7B: '在代码生成前恢复全局变量的原始链接关系'
# 'Restore the default behavior of not embedding source text in DWARF debug sections'
H98E5316CC560: '恢复默认行为，不将源文本嵌入DWARF调试部分'
# 'Restore the default behaviour of not generating long calls'
H49E0BF0F6145: '恢复默认行为，不生成长调用'
# 'Restrict DWARF features to those defined in the specified version, avoiding features from later versions.'
H3EFE36E674FA: '将DWARF功能限制为指定版本中定义的那些，避免使用后续版本的功能'
# 'Restrict all prior -I flags to double-quoted inclusion and remove current directory from include path'
H3D88078880FD: '将所有之前的-I标志限制为双引号包含的路径，并从包含路径中移除当前目录'
# 'Restrict code to those available for App Extensions'
H187919D11FCC: '将代码限制为应用扩展可用的功能'
# 'Restrict range of B instructions (DEBUG)'
HC083C6F4C8EE: '限制B指令的范围（DEBUG）'
# 'Restrict range of BPcc/FBPfcc instructions (DEBUG)'
H85B5CACDDD43: '限制BPcc/FBPfcc指令的范围（DEBUG）'
# 'Restrict range of BPr instructions (DEBUG)'
H0FAB44C44A31: '限制BPr指令的范围（DEBUG）'
# 'Restrict range of Bcc instructions (DEBUG)'
H400749DA0205: '限制Bcc指令的范围（DEBUG）'
# 'Restrict range of CB instructions (DEBUG)'
HE052E990A1F8: '限制CB指令的范围（DEBUG）'
# 'Restrict range of CB[N]Z instructions (DEBUG)'
HCAA4E790CDDA: '限制CB[N]Z指令的范围（DEBUG）'
# 'Restrict range of TB[N]Z instructions (DEBUG)'
H8319D33A4041: '限制TB[N]Z指令的范围（DEBUG）'
# 'Restrict range of branch instructions (DEBUG)'
H80C66F8F6D0A: '限制分支指令的范围（DEBUG）'
# 'Restrict range of loopN instructions (testing only)'
HDC7B8D8739B5: '限制loopN指令的范围（仅用于测试）'
# 'Restrict remat for statepoint operands'
H915A155B8538: '限制状态点操作数的重分配'
# 'Restrict sanitizer coverage instrumentation exclusively to modules and functions that match the provided special case list, except the blocked ones'
HF665154F84D1: '将sanitizer覆盖插桩严格限制为与提供的特殊案例列表匹配的模块和函数（排除被屏蔽的）'
# 'Restrict specifier.'
H0429709567D5: '限制说明符。'
# 'Restrict to vendor:'
H32644C5851E5: '限制为供应商：'
# 'Resume compilation after a specific pass'
H0C491338806A: '在特定pass之后恢复编译'
# 'Resume compilation before a specific pass'
H1BE82678A264: '在特定pass之前恢复编译'
# 'Retain macro definitions in /E mode'
HED02F9B02911: '在/E模式下保留宏定义'
# 'Return all structs in memory (PPC32 only)'
H1FA38C42BEE4: '在内存中返回所有结构体（仅限PPC32）'
# 'Return small structs in registers (PPC32 only)'
H2418E605C08F: '在寄存器中返回小结构体（仅限PPC32）'
# 'Reverse allocation order of local live ranges, such that shorter local live ranges will tend to be allocated first'
HB6873693AAD6: '反转局部活跃范围的分配顺序，使较短的局部活跃范围更可能优先分配'
# 'Rewrite Legacy Objective-C source to C++'
H756144AF61D7: '将旧版Objective-C源代码重写为C++'
# 'Rewrite Objective-C source to C++'
H97D2AC714B44: '将Objective-C源代码重写为C++'
# 'Rewrite Partial Register Uses'
HCE6FCECEDA90: '重写部分寄存器使用'
# 'Rewrite unaligned loads as a pair of aligned loads'
HB7B2CD3A9808: '将非对齐加载重写为一对对齐加载'
# 'Rewrite undef for PHI'
HD99A47BCF5A8: '重写PHI节点的undef值'
# 'Rewriter playground'
HE6E28450C65C: '重写器沙盒'
# 'Rewriter to run'
HD27186628DE0: '要运行的重写器'
# 'Right before the vectorizer'
HE1F20E3A6191: '向量化之前'
# 'Root for relative input paths'
H44AB7F76C38B: '相对输入路径的根目录'
# 'Root.'
H81747C7D336A: '根。'
# "Roughly estimate the number of cycles that 'long latency' instructions take for targets with no itinerary"
HEEDD34050A74: '对没有行程表的目标平台，粗略估算长延迟指令的周期数'
# 'Round section sizes up to the section alignment'
HE0CCC8143863: '将段大小向上取整到段对齐'
# 'Round-trip the IR after parsing and ensure it succeeds'
HB85D02D3E83D: '在解析后往返中间表示并确保成功'
# 'Run GCN iterative scheduler for ILP scheduling (experimental)'
H1C7DB026D127: '运行GCN迭代调度器进行ILP调度（实验性）'
# 'Run GCN iterative scheduler for minimal register usage (experimental)'
HEE1CE35E76A1: '运行GCN迭代调度器以最小化寄存器使用（实验性）'
# 'Run GCN scheduler to maximize ilp'
HFF1542675A34: '运行GCN调度器以最大化ILP'
# 'Run GCN scheduler to maximize memory clause'
H7E5277DF8B56: '运行GCN调度器以最大化内存条款'
# 'Run GCN scheduler to maximize occupancy'
H55CABD9DC534: '运行GCN调度器以最大化占用率'
# 'Run GCN scheduler to maximize occupancy (experimental)'
H2546364E49BB: '运行GCN调度器以最大化占用率（实验性）'
# "Run Hexagon's custom scheduler"
HD930CA19D3B9: '运行Hexagon的自定义调度器'
# 'Run MachineScheduler post regalloc (independent of preRA sched)'
H2FBC06B95112: '在寄存器分配后运行MachineScheduler（与preRA调度无关）'
# 'Run PGO context sensitive IR instrumentation'
HF2D51A482F76: '运行PGO上下文敏感IR插装'
# 'Run Partial inlining pass'
H67505263F683: '运行部分内联pass'
# 'Run PowerPC PostRA specific scheduler'
H78B21F1324B5: '运行PowerPC PostRA特定调度器'
# 'Run PowerPC PreRA specific scheduler'
H394DF3D974FB: '运行PowerPC PreRA特定调度器'
# "Run R600's custom scheduler"
H72CC1BA879B5: '运行R600的自定义调度器'
# "Run SI's custom scheduler"
HD076B4B4194B: '运行SI的自定义调度器'
# 'Run SimplifyCFG after expanding atomic operations to make use of cmpxchg flow-based information'
H0C90ACC17582: '在展开原子操作后运行SimplifyCFG以利用cmpxchg基于流的信息'
# 'Run a global pre-inliner to merge context profile based on estimated global top-down inline decisions'
H5BFD65B47642: '运行全局预内联程序，根据估计的全局自顶向下内联决策合并上下文配置文件'
# 'Run a quick verification useful for regression testing'
H47645E615F6C: '运行可用于回归测试的快速验证'
# 'Run all passes twice, re-using the same pass manager (legacy PM only).'
HD061B5F25379: '使用相同的pass管理器（仅限旧版PM）重复运行所有passes两次'
# 'Run amdgpu-regbankselect and amdgpu-regbanklegalize instead of regbankselect'
H5E9AEFE2CEF6: '运行amdgpu-regbankselect和amdgpu-regbanklegalize代替regbankselect'
# 'Run an early inliner pass before Polly'
H54AEF889D7EF: '在 Polly 之前运行早期内联Pass'
# 'Run analysis on specific function (for C++ include parameters in name)'
H3C6F4C08F518: '对特定函数进行分析（对于C++，名称中包含参数）'
# 'Run asan instrumentation on LDS instructions lowered to global memory'
H9EB47AECF813: '对降低到全局内存的 LDS 指令运行 asan 插装'
# 'Run cc1 in-process'
H9A5B5F4BB70B: '在进程内运行cc1'
# 'Run cleanup optimization passes after vectorization'
HD6645D1D40DA: '向量化之后运行清理优化Pass'
# 'Run code-completion at each point (slow)'
HF356338EEEA8: '在每个点运行代码补全（较慢）'
# 'Run compiler only for specified passes (comma separated list)'
H08D41AC776F1: '仅运行指定的传递（逗号分隔列表）'
# 'Run early if-conversion'
H7D7CDDBB010E: '运行早期 if 转换'
# 'Run everything twice, re-using the same pass manager and verify the result is the same.'
H7032E14A02BE: '复用相同的Pass管理器两次运行所有内容并验证结果一致'
# 'Run in quiet mode'
HE4D4F6750673: '在静默模式下运行'
# 'Run indirect-call promotion for call instructions only'
H8967C75A35F7: '仅对 call 指令运行间接调用提升'
# 'Run indirect-call promotion for invoke instruction only'
H4BE6E5960D01: '仅对 invoke 指令运行间接调用提升'
# 'Run indirect-call promotion in LTO mode'
HD86948C0B3ED: '在 LTO 模式下运行间接调用提升'
# 'Run indirect-call promotion in SamplePGO mode'
HFD50D337E7CB: '在 SamplePGO 模式下运行间接调用提升'
# 'Run instrumented parse and dump the parsing log'
HB71F9FFCCF1A: '运行带有分析工具的解析并转储解析日志'
# 'Run live interval analysis earlier in the pipeline'
H35280A9E9FE7: '在流水线早期运行活跃间隔分析'
# 'Run loop-rotation in the prepare-for-lto stage. This option should be used for testing only.'
HF3A983596CA9: '在 prepare-for-lto 阶段运行循环旋转。此选项仅用于测试。'
# 'Run many different optimization sequences on program to find bugs'
H612ED68363A4: '对程序运行多种不同的优化序列以查找错误'
# 'Run on all functions guaranteed to be beneficial'
HE1FEAE7130C4: '在所有保证有益的函数上运行'
# 'Run only CodeGen passes and translate FIR to LLVM IR'
H1A5B7B8CBB9C: '仅运行代码生成Pass并将 FIR 转换为 LLVM IR'
# 'Run opt passes and codegen at O0'
H81E08FD2A09C: '在 O0 级别运行中端优化和代码生成'
# 'Run opt passes and codegen at O1'
H474C4A7BA297: '在 O1 级别运行中端优化和代码生成'
# 'Run opt passes and codegen at O2'
H3F347B539B5D: '在 O2 级别运行中端优化和代码生成'
# 'Run opt passes and codegen at O3'
H59E1D82AC2DB: '在 O3 级别运行中端优化和代码生成'
# 'Run optimizations through valgrind'
HE1CE530E789B: '通过 valgrind 运行优化'
# 'Run pre-RA exec mask optimizations'
H3C26C74A3208: '运行预RA执行掩码优化'
# 'Run pre-emit peephole optimizations.'
H4E182C271921: '运行预发射窥孔优化。'
# 'Run preprocessor, dump internal rep of tokens'
H45922516F2A2: '运行预处理器，转储标记的内部表示'
# 'Run program Just-In-Time'
H7E1CCE7CE553: '即时（Just-In-Time）运行程序'
# 'Run static analysis engine'
H84EF43F50B25: '运行静态分析引擎'
# 'Run the Fast mode (default mapping)'
HFFDBC5733152: '运行快速模式（默认映射）'
# 'Run the InputOuputTest action. Use for development and testing only.'
H0B55FCB86E0F: '运行InputOuputTest操作。仅用于开发和测试。'
# 'Run the LLVM verifier after every LLVM pass'
H136DF2CC2C10: '在每个LLVM pass后运行LLVM验证器'
# 'Run the Loop vectorization passes'
H593612B18031: '运行循环向量化管线'
# 'Run the NewGVN pass'
HB971140FD767: '运行NewGVNPass'
# 'Run the SLP vectorization passes'
H568F60BAF50F: '运行SLP向量化passes'
# 'Run the dead code elimination'
H072ED3EF8554: '运行死代码消除'
# 'Run the loop rotation transformation after PGO instrumentation'
H99F728F7A8D4: '在PGO工具链之后运行循环旋转转换'
# 'Run the pipeline stored in the reproducer'
HE376D46CB8F5: '运行存储在复现器中的流水线'
# 'Run the preprocessor, parser and semantic analysis stages'
HC4E9B82FB80F: '运行预处理器、解析器和语义分析阶段'
# 'Run the static analyzer'
H12842C536C2E: '运行静态分析器'
# "Run the vectorizer only on file paths that match any in the list of comma-separated regex's."
H4461671734B6: '仅在与逗号分隔的正则表达式列表中任意项匹配的文件路径上运行向量化器。'
# 'Run the verifier after each transformation pass'
H1D9EDA842E47: '在每次运行转换Pass后运行验证器'
# 'Runs certain features (e.g. hover) at each point in the file. Somewhat slow.'
H5799AB4D2B8E: '在文件的每个位置运行某些功能（例如悬停）。速度较慢。'
# 'Runtime determined (OMP_SCHEDULE)'
H89C96D1C59A0: '运行时确定 (OMP_SCHEDULE)'
# 'RuntimeDyld'
HB046756B987A: 'RuntimeDyld'
# 'Rvalue reference.'
H1006B6835AD7: 'Rvalue 引用。'
# 'SCE targets (e.g. PS4)'
H24C3BD16186C: 'SCE 目标平台（例如 PS4）'
# "SDK does not contain 'libarclite' at the path '%0'; try increasing the minimum deployment target"
HBB626BB3124D: "SDK在路径 '%0' 中不包含 'libarclite'；尝试提高最低部署目标"
# "SDK settings were ignored as 'SDKSettings.json' could not be parsed"
HF609237E0BEB: "由于无法解析 'SDKSettings.json'，SDK设置被忽略"
# "SEH '__try' is not supported on this target"
H06D89FCA39AA: "SEH的 '__try' 在该目标平台上不受支持"
# 'SI Fix SGPR copies'
HDB9A9026CAAF: 'SI 修复SGPR复制'
# 'SI Fix VGPR copies'
H0BCE6618F46C: 'SI修复VGPR寄存器副本'
# 'SI Fold Operands'
H2A817B2075A4: 'SI折叠操作数'
# 'SI Form memory clauses'
H4B75CB116FD5: 'SI 形成内存子句'
# 'SI Insert Hard Clauses'
H0DD59BBBCDBF: 'SI插入硬约束条件'
# 'SI Insert Waitcnts'
HE04885DD4D00: 'SI 插入Waitcnt指令'
# 'SI Load Store Optimizer'
H267BF961C532: 'SI 加载存储优化器'
# 'SI Lower WWM Copies'
HEE5F5720909B: 'SI 转换WWM复制'
# 'SI Lower i1 Copies'
H5A7C0C9EA184: 'SI 转换i1类型复制'
# 'SI Memory Legalizer'
H0FE7146D147C: 'SI 内存合法化'
# 'SI Optimize VGPR LiveRange'
H8E8730AB73D6: 'SI 优化VGPR存活范围'
# 'SI Peephole SDWA'
H2175B3F2C8E1: 'SI窥孔优化SDWA指令'
# 'SI Pre-allocate WWM Registers'
H4206E704E134: 'SI 预分配WWM寄存器'
# 'SI Shrink Instructions'
HBAF7A342AB3A: 'SI缩减指令'
# 'SI Whole Quad Mode'
HFFEC46D8FF13: 'SI 全四元组模式'
# 'SI insert s_cbranch_execz instructions'
HDC4FDC149030: 'SI 插入s_cbranch_execz指令'
# 'SI lower SGPR spill instructions'
H3F5058866166: 'SI 降低 SGPR 存储指令'
# 'SI lower control flow'
H9237847AA8B8: 'SI降低控制流'
# 'SI optimize exec mask operations'
H3185D5441AB0: 'SI 优化 exec 掩码操作'
# 'SI optimize exec mask operations pre-RA'
H08D9A111CF96: 'SI 优化 exec 掩码操作（pre-RA）'
# 'SI peephole optimizations'
H1E6ED6F3445E: 'SI窥孔优化'
# 'SI post-RA bundler'
H6FF7F01FEB53: 'SI寄存器分配后捆绑器'
# 'SIMD Library for Evaluating Elementary Functions'
H4F65620685F5: '初等函数向量化计算库'
# 'SME Peephole Optimization'
HB6505176089D: 'SME窥孔优化'
# 'SOURCEFILE'
H4695CE0F3CCA: 'SOURCEFILE'
# 'SPARC DAG->DAG Pattern Instruction Selection'
HEB1F489D0073: 'SPARC DAG->DAG模式指令选择'
# 'SPIR-V Regularizer'
HA3F8831A4FED: 'SPIR-V标准化处理'
# 'SPIR-V Shader capability'
H3F602E05A4A8: 'SPIR-V 着色器功能'
# 'SPIR-V Translator compatibility mode'
HF7AF8DE76675: 'SPIR-V翻译器兼容模式'
# 'SPIR-V capabilities to avoid if there are other options enabling a feature'
H9E1D87EB2349: '如果其他选项启用了某个功能，则避免使用SPIR-V能力'
# 'SPIRV Assembly Printer'
H86AC0377A655: 'SPIRV汇编打印机'
# 'SPIRV NonSemantic.Shader.DebugInfo.100 emitter'
H16A3D5391B31: 'SPIRV NonSemantic.Shader.DebugInfo.100发射器'
# 'SPIRV convergence regions analysis'
HB13555632C11: 'SPIRV收敛区域分析'
# 'SPIRV emit intrinsics'
H98E5DCAE36C2: 'SPIRV注入固有函数'
# 'SPIRV legalize bitcast pass'
H9940486F0CC0: 'SPIRV合法化位模式转换'
# 'SPIRV module analysis'
HD4BE1FB1BEF1: 'SPIRV模块分析'
# 'SPIRV post legalizer'
HF7EB3FED68B9: 'SPIRV后法典化处理'
# 'SPIRV pre legalizer'
HD74E28A77753: 'SPIRV前法典化处理'
# 'SPIRV prepare functions'
H17164FF97DDE: 'SPIRV准备函数'
# 'SPIRV split region exit blocks'
H2A782FAE48E8: 'SPIRV 分割区域退出块'
# 'SPIRV strip convergent intrinsics'
HDA93080C3642: 'SPIRV剥离收敛固有函数'
# 'STOKE pass options'
H4008C64D6703: 'STOKE pass选项'
# "SUBCOMMAND '"
H49B0CF838F29: "子命令 '"
# 'SUBCOMMANDS:\n\n'
H5B04A2FD12F5: '子命令列表：\n\n'
# 'SVE vector type %0 cannot be used in a non-streaming function'
H9A5DD8A133CA: 'SVE向量类型 %0 不能在非流式函数中使用'
# 'SVE vector type %0 cannot be used in a target without sve'
H9A595E01748A: 'SVE向量类型 %0 不能在没有sve的目标中使用'
# 'SYCL host compilation'
H61E19C960525: 'SYCL主机编译'
# 'SYCL language standard to compile for.'
HD9004BF51D18: '要编译的SYCL语言标准。'
# 'Safe Stack instrumentation pass'
H90200C1EBE5D: '安全栈插桩pass'
# 'Safepoint IR Verifier'
H55862F19A9A2: '安全点IR验证器'
# 'Salvage stale MemProf profile'
H99E23DAB6376: '保留过时的MemProf配置文件'
# 'Salvage stale profile by fuzzy matching and use the remapped location for sample profile query.'
H5090826C05A6: '通过模糊匹配保留过时的配置文件，并使用重映射的位置进行示例配置文件查询。'
# 'Salvage unused profile by matching with new functions on call graph.'
H21FAAE36AF70: '通过调用图与新函数匹配保留未使用的配置文件。'
# 'Same as "/diasdkdir <dir>/DIA SDK" /vctoolsdir <dir>/VC/Tools/MSVC/<vctoolsversion> "/winsdkdir <dir>/Windows Kits/10"'
HEB5E99FA660E: '与“/diasdkdir <dir>/DIA SDK” /vctoolsdir <dir>/VC/Tools/MSVC/<vctoolsversion> “/winsdkdir <dir>/Windows Kits/10”相同'
# 'Same as /Ob2'
H8A3F940C0EB5: '等同于/Ob2'
# 'Same as prepare-and-assemble-snippet, but also creates the full sequence that can be dumped to a file using --dump-object-to-disk'
H77B67B5A93B5: '与 prepare-and-assemble-snippet 相同，但还会生成完整的序列，可以通过 --dump-object-to-disk 选项将其保存到文件'
# 'Same as prepare-measured-code, but also runs the measurement (default)'
H1BADD228E79D: '与 prepare-measured-code 相同，但还会执行测量（默认选项）'
# 'Same as prepare-snippet, but also dumps an excerpt of the sequence (hex encoded)'
H329F8CE6355E: '与 prepare-snippet 相同，但会导出序列片段（十六进制编码）'
# 'Same priority as other clangd work.'
H91A607AFE9B7: '与其他 clangd 任务具有相同优先级。'
# 'Sample profile'
H06DF786C2443: '采样剖析'
# 'Sanitize loads from memory.'
H0BDA70010B81: '对内存中的加载进行清理。'
# 'Sanitize loads from memory. When disable, no significant security is provided.'
H6827B410126B: '对内存中的加载进行清理。当禁用时，不会提供显著的安全保障。'
# 'Sanitizer Coverage. 0: none, 1: entry block, 2: all blocks, 3: all blocks and critical edges'
H6153504BE2F9: '清理程序覆盖范围。0: 无，1: 入口块，2: 所有块，3: 所有块和关键边'
# 'Sanitizer Statistics Processing Tool'
H8F91AACBD96D: ' sanitizer 统计数据处理工具'
# 'Sanitizer coverage type'
HB92F228F8C30: 'Sanitizer 覆盖类型'
# 'Save ThinLTO generated object files using filenames created in the given directory.'
HC53E73C90B26: '使用给定目录中创建的文件名保存ThinLTO生成的目标文件。'
# 'Save ThinLTO temp files using filenames created by adding suffixes to the given file path prefix.'
H2E31524DF75E: '使用在给定文件路径前缀后添加后缀生成的文件名保存ThinLTO临时文件。'
# 'Save arguments passed by registers to ABI-defined stack positions'
H9D88220945B3: '将通过寄存器传递的参数保存到ABI定义的栈位置'
# "Save intermediate compilation results. <arg> can be set to 'cwd' for current working directory, or 'obj' which will save temporary files in the same directory as the final output file"
H353A183FAD67: "保存中间编译结果。<arg> 可以设置为 'cwd' 表示当前工作目录，或 'obj' 将临时文件保存到最终输出文件所在目录"
# 'Save intermediate module file results when compiling a standard C++ module unit.'
HC4664B3AE862: '编译标准C++模块单元时保存中间模块文件结果'
# 'Save llvm statistics.'
H5CC2FF1F8C02: '保存 llvm 统计数据。'
# 'Save selected temporary files. Cannot be specified together with -save-temps'
H9B274443882B: '保存选定的临时文件。不能与 -save-temps 一起指定'
# 'Save statistics to the specified file'
H869C572478B5: '将统计信息保存到指定文件'
# 'Save subprocess statistics to the given file'
HBB6AB7F311A5: '将子进程统计信息保存到指定文件'
# 'Save temp files'
H4A37FEDB9D14: '保存临时文件'
# 'Save temporary files'
H57B3E4133626: '保存临时文件'
# "Save temporary labels in the symbol table. Note this may change .s semantics and shouldn't generally be used on compiler-generated code."
H93DB00E1BEA2: '在符号表中保存临时标签。注意这可能会改变.s的语义，通常不应在编译器生成的代码中使用。'
# 'Save the IR before running optimizations'
H4A2342002AC8: '在运行优化之前保存中间表示（IR）'
# 'Save the device memory output of the replayed kernel execution.'
H6C85C6C553C1: '保存重放内核执行的设备内存输出。'
# 'Scalable vectorization is available and favored when the cost is inconclusive.'
H66BDF3C7947B: '可扩展向量化可用且在成本不确定时被优先选择。'
# 'Scalable vectorization is disabled.'
HEDA81875966D: '可扩展向量化已禁用。'
# 'Scalar Evolution Analysis'
H8691C6809389: '标量演化分析'
# 'Scalar Replacement Of Aggregates'
HC922609C7C15: '聚合体标量替换'
# 'Scalar independence heuristic'
H6DBF46490571: '标量独立性启发式算法'
# 'ScalarEvolution-based Alias Analysis'
HB1C967D70FE5: '基于ScalarEvolution的别名分析'
# 'Scalarize unsupported masked memory intrinsics'
H4C20D577FF69: '将不受支持的带掩码内存固有函数标量化'
# 'Scalarize vector operations'
H31C547703795: '标量化解算符操作'
# 'Scale the memop size counts using the basic  block count value'
H77E1E3932329: '使用基本块计数值缩放内存操作大小计数'
# 'Scale to limit the cost of inline deferral'
HEB04CD55185A: '调整以限制内联延迟的成本'
# 'Scavenge virtual registers inside basic blocks'
HDFF735ACD536: '在基本块内回收虚寄存器'
# 'Schedule VSX FMA instruction mutation early'
HCC0329BA7D34: '提前调度VSX FMA指令的变异'
# 'Schedule bottom-up for max ILP'
HD1699FACAF31: '按自底向上调度以最大化ILP'
# 'Schedule bottom-up for min ILP'
H10AC8BD5ECDA: '按自底向上调度以最小化ILP'
# 'Scheduling type of parallel OpenMP for loops'
H999BCCD4C603: 'OpenMP并行for循环的调度类型'
# 'Scope contributions to the debug information.'
H9BF0B0DDBE12: '调试信息的作用域贡献。'
# 'Scope kind to use when printing scopes.'
H494C78291AB2: '打印作用域时使用的范围类型。'
# 'Scope of graph to export to dot'
H9536D6B1D873: '导出到dot格式的图的作用域。'
# 'Scoped NoAlias Alias Analysis'
HB6BD5D72C4B3: '作用域无别名别名分析'
# 'Scopes.'
H4E6EE0359B5C: '作用域。'
# 'Search $prefix$file for executables, libraries, and data files. If $prefix is a directory, search $prefix/$file'
H6DC87438E4A7: '在 $prefix$file 路径中搜索可执行文件、库和数据文件。如果 $prefix 是目录，则搜索 $prefix/$file'
# 'Search elements matching the given pattern.'
H98914CD94E9A: '搜索与给定模式匹配的元素。'
# 'Search even non-imported modules to resolve references'
H1FD982ACF76B: '即使模块未导入，也搜索用于解析引用的模块'
# 'Search for the GCC installation with the specified triple.'
H74F06477D6B9: '使用指定的三元组查找具有指定目标的GCC安装'
# 'Section-specific Dump Options'
H9E36553E678B: '特定段落的转储选项'
# 'Seed for the random number generator'
H9C3EECBF2BE5: '随机数生成器的种子值'
# 'Seed used for randomness'
H228A43C8FFBC: '用于随机性的种子值'
# 'Select DPP or Iterative strategy for scan'
HE53499864EE5: '为扫描选择DPP或迭代策略'
# 'Select Options'
HD84BE9DE2F9E: '选择选项'
# 'Select Windows run-time library'
HAC106D381AC2: '选择Windows运行时库'
# 'Select custom AMDGPU scheduling strategy.'
H64E4378BB72D: '选择自定义AMDGPU调度策略。'
# 'Select label scheme for branch control-flow architecture protection'
H7B3CA40CA6B3: '为分支控制流架构保护选择标签方案'
# "Select math operations' runtime behavior:"
HBD0952A00DD6: '选择数学运算的运行时行为：'
# 'Select return address signing scope'
H4F99B374ECF5: '选择返回地址签名作用域'
# 'Select straight-line speculation hardening scope (ARM/AArch64/X86 only). <arg> must be: all, none, retbr(ARM/AArch64), blr(ARM/AArch64), comdat(ARM/AArch64), nocomdat(ARM/AArch64), return(X86), indirect-jmp(X86)'
H7FE74692FDC9: '选择直连推测强化作用域（仅适用于ARM/AArch64/X86）。<arg> 必须为：all、none、retbr（ARM/AArch64）、blr（ARM/AArch64）、comdat（ARM/AArch64）、nocomdat（ARM/AArch64）、return（X86）、indirect-jmp（X86）'
# 'Select target instructions out of generic instructions'
H687BF304766B: '从通用指令中选择目标指令'
# 'Select the HWAddressSanitizer ABI to target (interceptor or platform, default interceptor). This option is currently unused.'
H2E53C4CE5E14: '选择目标HWAddressSanitizer ABI（拦截器或平台，默认拦截器）。此选项目前未使用'
# "Select the SIMD extension(s) to be enabled in LoongArch either 'none', 'lsx', 'lasx'."
H58773894FD9F: "在LoongArch中启用的SIMD扩展，可选 'none', 'lsx', 'lasx'."
# 'Select the asm variant (integer) to use for output (3: unspecified)'
H269BE00B3354: '选择用于输出的汇编变体（整数）（3: 未指定）'
# 'Select the assembly style for input'
HC379BD26B358: '选择输入的汇编风格'
# "Select the container format for clang modules and PCH. Supported options are 'raw' and 'obj'."
H35A81EACF6D7: "选择clang模块和PCH的容器格式。支持的选项为 'raw' 和 'obj'."
# 'Select the frame chain model used to emit frame records (Arm only).'
H6E15DFB39F91: '选择用于生成帧记录的帧链模型（仅适用于Arm）'
# 'Select the kind of output desired'
H4B7026DCAB45: '指定所需的输出类型'
# 'Select the mode of detecting stack use-after-return in AddressSanitizer'
H18AC10CFE63E: '在AddressSanitizer中选择检测栈使用后返回的模式'
# 'Select the scheduling optimizer'
HF3643F4F750F: '选择调度优化器'
# 'Select the vectorization strategy'
HF0DE7753D578: '选择向量化策略'
# 'Select tutorial version'
HA1F9E472551C: '选择教程版本'
# 'Select underlying type for wchar_t'
H871CFB3D3DBF: '选择wchar_t的基础类型'
# "Select which XRay instrumentation points to emit. Options: all, none, function-entry, function-exit, function, custom. Default is 'all'.  'function' includes both 'function-entry' and 'function-exit'."
HF1CF9325D610: "选择要生成的XRay插桩点。选项：all, none, function-entry, function-exit, function, custom. 默认值为 'all'。  'function' 包括 'function-entry' 和 'function-exit'"
# 'Select which denormal numbers the code is permitted to require'
H2AC882EF26F4: '指定代码允许要求的非规格化数类型'
# 'Select which denormal numbers the code is permitted to require for float'
HE697FDB681DE: '指定代码允许要求的float类型的非规格化数'
# 'Selected elements are displayed in a tabular format.'
HEA919FEE4B68: '选择的元素以表格格式显示。'
# 'Selected elements are displayed in a tree view (Include children)'
H177003785A78: '选择的元素以树状视图显示（包含子项）'
# 'Selected elements are displayed in a tree view. (Include parents)'
HDF9A5F80B1E1: '选择的元素以树状视图显示。（包含父项）'
# 'Selects the execution mode to use for running snippets'
HD1AD171EDC3B: '选择用于运行代码片段的执行模式'
# 'Serialize compiler diagnostics to a file'
HDAE0DE265E80: '将编译器诊断信息序列化到文件中'
# 'Set CPU for optimization without affecting instruction set'
H4812860590FE: '设置优化的CPU，不影响指令集'
# 'Set DWARF fission mode'
HA6B185D6C1A5: '设置DWARF分裂模式'
# 'Set EABI type (default depends on triple):'
HE8D11354B2F8: '设置EABI类型（默认值取决于三元组）：'
# 'Set EABI type. Default depends on triple)'
H10E2EAF33A04: '设置EABI类型。默认值取决于triple)'
# 'Set Fuchsia API level'
H6549E92FCDF2: '设置Fuchsia API级别'
# 'Set Hexagon Vector Length'
H7AAC4AA29051: '设置Hexagon向量长度'
# 'Set LTO mode'
HC407FF843F6C: '设置LTO模式'
# 'Set LTO mode for offload compilation'
HAFC85CCA6F44: '设置卸载编译的LTO模式'
# 'Set OpenMP version (e.g. 45 for OpenMP 4.5, 51 for OpenMP 5.1). Default value is 31 for Flang'
H4AABB415543E: '设置OpenMP版本（例如 4.5对应 45，5.1对应 51）。默认值为Flang的 31'
# 'Set OpenMP version (e.g. 45 for OpenMP 4.5, 51 for OpenMP 5.1). Default value is 51 for Clang'
H81EB65FB7662: '设置OpenMP版本（例如 45 对应OpenMP 4.5，51对应OpenMP 5.1）。默认值为Clang的 51'
# 'Set ThinLTO cache entry expiration time.'
HAC92585FAE36: '设置ThinLTO缓存条目过期时间。'
# 'Set ThinLTO cache pruning directory maximum number of files.'
H5D4AE530977A: '设置ThinLTO缓存清理目录最大文件数。'
# 'Set ThinLTO cache pruning directory maximum size in bytes.'
H28BB199174A5: '设置ThinLTO缓存清理目录最大大小（以字节为单位）。'
# 'Set ThinLTO cache pruning interval.'
H4990BDC788D5: '设置ThinLTO缓存清理间隔。'
# 'Set __cdecl as a default calling convention'
H0DA21BF93B54: '将__cdecl设置为默认调用约定'
# 'Set __fastcall as a default calling convention'
H407DDA0187F9: '将__fastcall设置为默认调用约定'
# 'Set __regcall as a default calling convention'
HBA376537ABE7: '将__regcall设置为默认调用约定'
# 'Set __regcall4 as a default calling convention to respect __regcall ABI v.4'
H58F2490637FE: '将__regcall4设置为默认调用约定以符合__regcall ABI v.4'
# 'Set __stdcall as a default calling convention'
HE1D6B80E6229: '将__stdcall设置为默认调用约定'
# 'Set __vectorcall as a default calling convention'
H37C4705F7696: '将__vectorcall设置为默认调用约定'
# 'Set architecture for code generation'
HAC7DFD303E5D: '设置代码生成的架构'
# 'Set assembly output file name (with /FA)'
H342E214704DE: '设置汇编输出文件名（使用/FA选项）'
# 'Set build target to arm64ec'
H05FB1FB7BA76: '设置构建目标为arm64ec'
# 'Set default AMDHSA Code Object Version (module flag or asm directive still take priority if present)'
H146533C17448: '设置默认的AMDHSA代码对象版本（若存在模块标志或asm指令则优先使用）'
# "Set default MTE mode to 'sync' (default) or 'async'"
H20B84E4CC1C3: "设置默认的MTE模式为 'sync'（默认）或 'async'"
# 'Set default calling convention'
HDE29EF09B114: '设置默认调用约定'
# 'Set default maximum struct packing alignment'
HB9DF8419AE20: '设置默认最大结构体填充对齐值'
# 'Set default maximum struct packing alignment to 1'
H4F682E117F17: '将默认最大结构体填充对齐值设为 1'
# 'Set directory to SYSTEM include search path with prefix'
H68EB156B894F: '将带有前缀的目录添加到SYSTEM包含搜索路径'
# 'Set directory to include search path with prefix'
H949A45EF9093: '将带有前缀的目录添加到包含搜索路径'
# 'Set endian conversion of data for unformatted files'
H5882EA320C88: '设置非格式化文件数据的字节序转换方式'
# 'Set exception handling model'
HBE5ECEAC70BC: '设置异常处理模型'
# 'Set filename used to determine the language and to find\n.clang-format file.\nOnly used when reading from stdin.\nIf this is not passed, the .clang-format file is searched\nrelative to the current working directory when reading stdin.\nUnrecognized filenames are treated as C++.\nsupported:\n  CSharp: .cs\n  Java: .java\n  JavaScript: .js .mjs .cjs .ts\n  Json: .json .ipynb\n  Objective-C: .m .mm\n  Proto: .proto .protodevel\n  TableGen: .td\n  TextProto: .txtpb .textpb .pb.txt .textproto .asciipb\n  Verilog: .sv .svh .v .vh'
H13B2BD633E05: '指定用于确定语言并查找.clang-format文件的文件名。\n当从标准输入读取时使用此选项。\n若未指定此选项，则在读取标准输入时相对当前工作目录搜索.clang-format文件。\n未识别的文件名将视为C++。\n支持的文件扩展名：\n  C#：.cs\n  Java：.java\n  JavaScript：.js .mjs .cjs .ts\n  JSON：.json .ipynb\n  Objective-C：.m .mm\n  Protocol Buffers：.proto .protodevel\n  TableGen：.td\n  文本协议缓冲区：.txtpb .textpb .pb.txt .textproto .asciipb\n  Verilog：.sv .svh .v .vh'
# 'Set hexagon hvx loop upper bound align limit'
HE4A380690C61: '设置hexagon hvx循环上界对齐限制'
# 'Set hexagon loop align bundle limit'
H16F9FCEB4FD8: '设置hexagon循环指令包对齐限制'
# 'Set hexagon loop align edge threshold'
HB0E799C9958F: '设置hexagon循环边阈值对齐限制'
# 'Set hexagon loop lower bound align limit'
H191108F43D31: '设置hexagon循环下界对齐限制'
# 'Set hexagon loop upper bound align limit'
HAC06445A5323: '设置hexagon循环上界对齐限制'
# 'Set hexagon tiny-core loop align bundle limit'
HC2C9248FD7B4: '设置hexagon tiny-core循环指令包对齐限制'
# 'Set hexagon tiny-core loop upper bound align limit'
HB3D8449C583E: '设置hexagon tiny-core循环上界对齐限制'
# 'Set how to use window scheduling algorithm.'
H38DFCE09E411: '设置如何使用窗口调度算法。'
# 'Set iOS deployment target'
HF07609B74103: '设置iOS部署目标'
# 'Set inclusive limit count of TLS local-dynamic access(es) in a function to use initial-exec'
H219EA990A3B9: '设置函数中TLS本地动态访问的包含限制计数以使用初始执行'
# 'Set language version (c++14,c++17,c++20,c++23preview,c++latest,c11,c17)'
H7E89784949AD: '设置语言版本（c++14,c++17,c++20,c++23preview,c++latest,c11,c17）'
# 'Set lazy loading to pretend to import a module'
H618CB094A526: '设置延迟加载以模拟导入一个模块'
# 'Set level of crash diagnostic reporting, (option: off, compiler, all)'
HCE18F9865CAD: '设置崩溃诊断报告级别（选项：off, compiler, all）'
# 'Set macOS deployment target'
H19A10025F765: '设置macOS部署目标'
# 'Set max number of processed functions per pass.'
HEC89F562858B: '设置每个遍历的最大处理函数数量。'
# 'Set maximum number of loads used in expanded memcmp'
HB5230B1550BF: '设置展开的memcmp使用的最大加载数'
# 'Set maximum number of loads used in expanded memcmp for -Os/Oz'
H8B44477BDB6F: '为-Os/Oz优化设置展开的memcmp使用的最大加载数'
# 'Set maximum offset for global merge pass'
HC56716718D87: '设置全局合并遍历的最大偏移量'
# 'Set maximum runtime in seconds. Defaults to infinite.'
HF2324CC71F76: '设置最大运行时间（以秒为单位）。默认为无限。'
# 'Set maximum size of jump tables.'
H8A331A3A6A26: '设置跳转表的最大大小。'
# 'Set minimum jump tables'
H5B26E9EE289B: '设置跳转表的最小数量'
# 'Set minimum mem intrinsic size to expand in IR'
H0E2DA83065C4: '设置IR中展开的内存内建函数的最小大小'
# 'Set minimum number of entries to use a jump table on AArch64'
H5D2DDCBDE91E: '设置AArch64上使用跳转表所需的最小条目数'
# 'Set minimum number of entries to use a jump table on PPC'
H695C03675C01: '设置PPC使用跳转表的最小条目数'
# 'Set minimum number of entries to use a jump table on RISCV'
H747561D1A3EA: '设置RISCV使用跳转表的最小条目数'
# 'Set minimum number of entries to use a jump table.'
HB0CDB46F3718: '设置使用跳转表所需的最小条目数。'
# "Set multiple /O flags at once; e.g. '/O2y-' for '/O2 /Oy-'"
HEBA0D85CE2CB: "一次性设置多个/O标志；例如 '/O2y-' 表示 '/O2 /Oy-'"
# 'Set output executable file name'
H82C970101BA4: '设置输出可执行文件名'
# 'Set output object file (with /c)'
HBAF5373A221F: '设置输出目标文件（需配合/c选项）'
# 'Set page size for slab (requires -slab-allocate and -noexec)'
H674467BA0F71: '设置slab的页面大小（需要-slab-allocate和-noexec选项）'
# 'Set pch file name (with /Yc and /Yu)'
H0833DDB5ABF7: '设置预编译头文件名（需配合/Yc和/Yu选项）'
# 'Set preprocess output file name (with /P)'
H13AACC04AA24: '设置预处理输出文件名（需配合/P选项）'
# 'Set project title for the coverage report'
HBA2F951324E5: '设置覆盖率报告的项目标题'
# 'Set runtime encoding, supports only UTF-8'
HE66D162F5CCB: '设置运行时编码，仅支持UTF-8'
# 'Set slab target address (requires -slab-allocate and -noexec)'
H20F55BE4E6F3: '设置slab目标地址（需要-slab-allocate和-noexec选项）'
# 'Set source and runtime encoding to UTF-8 (default)'
H652EEA8353CA: '将源代码和运行时编码设置为UTF-8（默认）'
# 'Set source encoding, supports only UTF-8'
H3F8729E6E52F: '设置源代码编码，仅支持UTF-8'
# 'Set stack probe size (default 4096)'
HD0B9F95D20C7: '设置栈探测大小（默认 4096）'
# 'Set tab expansion size for html coverage reports (default = 2)'
H020BCDC65A3D: '设置HTML覆盖率报告中的制表符扩展大小（默认值为 2）'
# 'Set target profile'
H5E78CA7AD76D: '设置目标配置文件'
# 'Set the -iwithprefix/-iwithprefixbefore prefix'
HE253558596E6: '设置 -iwithprefix/-iwithprefixbefore 前缀'
# 'Set the Data Stream Control Register.'
H13FF9AB8D2D0: '设置数据流控制寄存器。'
# 'Set the case probability threshold for peeling the case from a switch statement. A value greater than 100 will void this optimization'
H4CFCB81E6294: '设置从switch语句剥离case的概率阈值。大于 100 的值将使此优化失效'
# 'Set the count value cutoff. Functions with the maximum count less than this value will not be printed out. (Default is 0)'
H314CB3F4FF30: '设置计数值截止值。最大计数小于该值的函数将不会被打印。（默认值为 0）'
# 'Set the default double precision kind to an 8 byte wide type'
H826E52CBA80A: '设置默认双精度类型为 8 字节宽类型'
# 'Set the default integer and logical kind to an 8 byte wide type'
HBB03F45115A1: '设置默认整数和逻辑类型为 8 字节宽类型'
# 'Set the default most-general representation to multiple inheritance'
H4BB3649A0500: '设置默认最通用的表示为多重继承'
# 'Set the default most-general representation to single inheritance'
HD5A0F69F41ED: '设置默认最通用的表示为单继承'
# 'Set the default most-general representation to virtual inheritance'
H106974060665: '设置默认最通用的表示为虚继承'
# 'Set the default real kind to an 8 byte wide type'
H7B0DABF8B0EB: '设置默认实数类型为 8 字节宽类型'
# 'Set the default structure layout to be compatible with the Microsoft compiler standard'
H10F147D00248: '设置默认结构体布局与Microsoft编译器标准兼容'
# 'Set the default symbol visibility for all global definitions'
HFCD98D3F8272: '设置所有全局定义的默认符号可见性'
# 'Set the deployment target to be the specified OS and OS version'
H814D918A5F74: '设置部署目标为指定的操作系统及其版本'
# 'Set the device id.'
H4C967743D4CC: '设置设备ID。'
# "Set the driver mode to either 'gcc', 'g++', 'cpp', 'cl' or 'flang'"
HD0838A0BABB3: "设置驱动程序模式为 'gcc'、'g++'、'cpp'、'cl' 或 'flang'"
# 'Set the kind of module destructors emitted by AddressSanitizer instrumentation. These destructors are emitted to unregister instrumented global variables when code is unloaded (e.g. via `dlclose()`).'
H83083E1D2A16: '设置AddressSanitizer插桩所生成的模块析构函数类型。这些析构函数用于在代码卸载时（例如通过`dlclose()`）注销被插桩的全局变量。'
# 'Set the loop counter bitwidth'
H9F5F138BD1EC: '设置循环计数器位宽'
# 'Set the loop decrement value'
H5680DA5C48FB: '设置循环递减值'
# 'Set the lower bound of a trip count to decide on vectorization while tail-folding.'
H098C7B4E7AF1: '在尾折叠期间设置循环次数的下限以决定向量化。'
# 'Set the max unroll count for full unrolling, for testing purposes'
HF7A0139ED19B: '设置完全展开的最大展开次数，用于测试目的'
# 'Set the max unroll count for partial and runtime unrolling, fortesting purposes'
H9B56B49168A1: '设置部分和运行时展开的最大展开次数，用于测试目的'
# 'Set the maximum bitwidth for _BitInt (this option is expected to be removed in the future)'
HA5D88B68C72D: '设置_BitInt的最大位宽（此选项预计将在未来被移除）'
# 'Set the maximum depth of recursive constexpr function calls'
HBB90EC0111F9: '设置 constexpr 函数递归调用的最大深度'
# 'Set the maximum depth of recursive template instantiation'
H80FAEB4CB009: '设置模板递归实例化最大深度'
# 'Set the maximum number of clang-format errors to emit\nbefore stopping (0 = no limit).\nUsed only with --dry-run or -n'
HCC14B05C0F0B: '设置clang-format错误的最大输出数量\n达到限制后停止（0=无限制）。\n仅在使用--dry-run或-n时生效'
# 'Set the maximum number of entries to print in a constexpr evaluation backtrace (0 = no limit)'
H894E58266D5D: '设置在 constexpr 求值回溯中打印的最大条目数（0=无限制）'
# 'Set the maximum number of entries to print in a macro expansion backtrace (0 = no limit)'
H41EB48896694: '设置在宏展开回溯中打印的最大条目数（0=无限制）'
# 'Set the maximum number of entries to print in a template instantiation backtrace (0 = no limit)'
H0B1001101AD7: '设置在模板实例化回溯中打印的最大条目数（0表示无限制）'
# 'Set the maximum number of errors to emit before stopping (0 = no limit).'
H4B9FB4A77BFC: '设置在停止前报告的最大错误数（0表示无限制）。'
# 'Set the maximum number of outgoing blocks for using a boolean value to record the exiting block in the ControlFlowHub.'
H72D58573A0FE: '设置在控制流中心使用布尔值记录出口块时的最大出边数。'
# 'Set the maximum number of source lines to show in a caret diagnostic (0 = no limit).'
H501810E09B46: '设置在插入符号诊断中显示的最大源代码行数（0表示无限制）'
# 'Set the maximum number of steps in constexpr function evaluation'
H220ED2A089D9: '设置 constexpr 函数求值的最大步骤数'
# 'Set the maximum number of times to perform spell checking on unrecognized identifiers (0 = no limit)'
HAFFC709D0C08: '设置对未识别标识符进行拼写检查的最大次数（0表示无限制）'
# 'Set the maximum path length when checking whether a basic block is followed by a block that either has a terminating deoptimizing call or is terminated with an unreachable'
H332DCFF60584: '设置检查基本块是否被包含终止去优化调用或以不可达终止的块时的最大路径长度'
# 'Set the minimum number of repetitions of a divisor to allow transformation to multiplications by the reciprocal'
HC1FEBC49F8C7: '设置允许转换为乘以倒数的除数重复最小次数'
# 'Set the mode for address space map based mangling; OpenCL testing purposes only'
HD09BAE7AD91C: '设置基于地址空间映射的名称修饰模式；仅用于OpenCL测试目的'
# 'Set the number of scavenger slots'
H180660FD5B55: '设置碎片收集槽位数量'
# 'Set the number of teams.'
H7688CE2C3ADF: '设置团队数量。'
# 'Set the number of threads.'
H6EBBEB07E8B0: '设置线程数量。'
# 'Set the out-of-process executor'
HAF02B074B342: '设置进程外执行器'
# 'Set the output <file> for debug infos'
HA5E541919277: '设置调试信息的输出文件'
# 'Set the p2align operands for WebAssembly loads and stores'
H7736F9C56939: '设置WebAssembly加载和存储的p2align操作数'
# 'Set the parallelization strategy'
HF0A794612D46: '设置并行化策略'
# "Set the profile instrumentation burst duration, which can range from 1 to the value of 'sampled-instr-period' (0 is invalid). This number of samples will be recorded for each 'sampled-instr-period' count update. Setting to 1 enables simple sampling, in which case it is recommended to set 'sampled-instr-period' to a prime number."
H5CA10C80C24A: "设置配置文件采样突发时长，取值范围为 1 到 'sampled-instr-period' 的值（0无效）。每个采样周期将记录该数量的样本。设置为 1 时启用简单采样，此时建议将 'sampled-instr-period' 设为质数。"
# "Set the profile instrumentation sample period. A sample period of 0 is invalid. For each sample period, a fixed number of consecutive samples will be recorded. The number is controlled by 'sampled-instr-burst-duration' flag. The default sample period of 65536 is optimized for generating efficient code that leverages unsigned short integer wrapping in overflow, but this is disabled under simple sampling (burst duration = 1)."
HC029DE20A3E1: "设置配置文件采样周期。0无效。每个采样周期将记录固定数量的连续样本。具体数量由 'sampled-instr-burst-duration' 参数控制。默认采样周期 65536 经过优化，可生成利用无符号短整型溢出的高效代码，但在简单采样（突发时长=1）时该优化会被禁用。"
# "Set the rsp quoting to either 'posix', or 'windows'"
HFF7A11383873: '设置RSP文件的引号方式为 "posix" 或 "windows"'
# 'Set the stack alignment'
HAAE3F7EC9ADE: '设置堆栈对齐方式'
# 'Set the stack probe size'
H188751A74B18: '设置堆栈探测大小'
# 'Set the system root directory (usually /)'
H9329C47A6507: '设置系统根目录（通常是/）'
# 'Set the tab stop distance.'
HC9DBC229821F: '设置制表符间距。'
# 'Set the target triple'
H886553395ADD: '设置目标三元组'
# 'Set the threshold for pgo-verify-bfi:  only print out mismatched BFI if the difference percentage is greater than this value (in percentage).'
H467C6DAEB903: '设置pgo-verify-bfi的阈值：仅当差异百分比超过此值（按百分比计算）时输出不匹配的BFI。'
# 'Set the threshold for pgo-verify-bfi: skip the counts whose profile count value is below.'
HCF37C352FCE6: '设置pgo-verify-bfi的阈值：跳过那些配置文件计数值低于该值的计数。'
# 'Set the unroll peeling count, for testing purposes'
H00413175E081: '设置展开剥离计数，用于测试目的'
# 'Set the z/OS release of the runtime environment'
HD212DAE31048: '设置运行时环境的z/OS版本'
# 'Set up preprocessor for static analyzer (done automatically when static analyzer is run).'
HE7E0E6B1AE87: '为静态分析器设置预处理器（当运行静态分析器时会自动完成）'
# 'Set update method of profile counters'
HA14B65C6D0B2: '设置剖析计数器的更新方法'
# 'Set upper limit for the number of transformations performed during a single round of hoisting the reassociated expressions.'
HC739332F82AA: '设置在单次提升重新关联表达式过程中执行的转换操作的上限次数。'
# 'Set wave priority'
HBB7FE34C07C2: '设置wave优先级'
# 'Set width of the columns showing resource booking.'
HC849BD248519: '设置显示资源分配的列的宽度。'
# 'Set width of the columns with the resources and schedule units'
H67C4E5790866: '设置包含资源和调度单元的列的宽度'
# 'Sets the ASan constructor kind'
H7243B87BA43D: '设置ASan构造函数类型'
# 'Sets the ASan destructor kind. The default is to use the value provided to the pass constructor'
H3151987CC244: '设置ASan析构函数类型。默认使用传递给pass构造函数的值'
# 'Sets the IEEE bit in the expected default floating point  mode register. Floating point opcodes that support exception flag gathering quiet and propagate signaling NaN inputs per IEEE 754-2008. This option changes the ABI. (AMDGPU only)'
H40BE9F55402A: '在默认浮点模式寄存器中设置IEEE位。支持IEEE 754-2008标准的浮点指令可收集异常标志并传播静默NaN/显式NaN输入。此选项会改变ABI。（仅AMDGPU有效）'
# 'Sets the SIMD width. Zero is autoselect.'
HA8F45CFC1E01: '设置SIMD宽度。零表示自动选择。'
# 'Sets the bias which adds weight to occupancy vs latency. Set it to 100 to chase the occupancy only.'
HDE531962A442: '设置偏向权重（occupancy vs latency）。设置为 100 时仅优化occupancy。'
# 'Sets the cost threshold for when multiple conditionals will be merged into one branch versus be split in multiple branches. Merging conditionals saves branches at the cost of additional instructions. This value sets the instruction cost limit, below which conditionals will be merged, and above which conditionals will be split. Set to -1 to never merge branches.'
H908B80F5C5DD: '设置合并多个条件为一个分支或拆分为多个分支的成本阈值。合并条件可以减少分支数量但会增加指令数量。该值设置指令成本限制：低于该值时合并条件，高于该值时拆分条件。设置为-1可禁用合并。'
# 'Sets the default matrix layout'
HB552288B1A94: '设置默认矩阵布局'
# 'Sets the maximum allowed output size (0 means no limit) [ELF only]'
H7FE764745013: '设置最大允许输出大小（0表示无限制）[仅ELF格式]'
# 'Sets the minimum function size to instrument with XRay'
HF47DF90C1776: '设置XRay工具需要记录的最小函数大小'
# 'Sets the mode of detection for stack-use-after-return.'
H3FEDDC9474EF: '设置检测栈使用后返回（stack-use-after-return）的模式。'
# 'Sets the preferable loop alignment for experiments (as log2 bytes) for innermost loops only. If specified, this option overrides alignment set by x86-experimental-pref-loop-alignment.'
H0A768F10FB45: '设置实验性内层循环的首选循环对齐方式（以log2字节为单位）。若指定该选项，将覆盖由x86-experimental-pref-loop-alignment设置的对齐值。'
# 'Sets the vectorization interleave count. Zero is autoselect.'
H0275ABE673BB: '设置向量化交织次数。零表示自动选择。'
# 'Sets various macros to claim compatibility with the given GCC version (default is 4.2.1)'
HF256B239FB01: '设置各种宏以声明与给定GCC版本的兼容性（默认为 4.2.1）'
# 'Shadow Stack GC Lowering'
H04B76D4FEDB5: 'Shadow Stack GC 降级'
# 'Should __STATIC__ be defined'
H46691D14FB8F: '是否应定义__STATIC__宏'
# 'Should a closed world be assumed, or not. Default if not set.'
H5AB58A4464B6: '是否假设封闭世界环境。未设置时使用默认值。'
# 'Should enable CSE in Legalizer'
H77887DE8DF92: '是否在Legalizer中启用CSE'
# 'Should enable CSE in irtranslator'
H91C4D8FE802C: '是否在irtranslator中启用CSE'
# 'Should mir-strip-debug only strip debug info from debugified modules by default'
H3DC291F161A1: '是否仅默认剥离由debugified模块生成的调试信息'
# 'Should we attempt to sink negations?'
HA914A0DB2603: '是否尝试下移否定操作？'
# 'Show FailedToMaterialize errors'
HE9058727A1A0: '显示FailedToMaterialize错误'
# 'Show MCDC statistics in summary table'
HC702D8A97A6E: '在汇总表中显示MCDC统计信息'
# 'Show True/False counts'
HFE8C8190B143: '显示True/False计数'
# 'Show True/False percent'
H07C8D556E1B3: '显示True/False百分比'
# 'Show binary counters (1/0) in lines and branches instead of integer execution counts'
HB45D3670503F: '在行和分支中显示二进制计数器（1/0）而非整数执行计数'
# 'Show binary ids in the profile. '
HB609CBDF46B1: '在配置文件中显示二进制ID。'
# 'Show bindings of tools to actions'
H25DE8385EB09: '显示工具与操作的绑定关系'
# 'Show branch condition statistics in summary table'
H231A08B7A99F: '在汇总表中显示分支条件统计信息'
# 'Show call-multigraph (do not remove parallel edges)'
HCC8B57A6B12A: '显示调用多重图（不移除并行边）'
# 'Show code coverage only for functions listed in the given file'
H0D504442CF50: '仅显示给定文件中列出的函数的代码覆盖率'
# 'Show code coverage only for functions that match the given regular expression'
H6E2F7500DDDA: '仅显示匹配给定正则表达式的函数的代码覆盖率'
# 'Show code coverage only for functions with line coverage greater than the given threshold'
H6945238A4869: '仅显示行覆盖率大于给定阈值的函数的代码覆盖率'
# 'Show code coverage only for functions with line coverage less than the given threshold'
H1A772B15E654: '仅显示行覆盖率小于给定阈值的函数的代码覆盖率'
# 'Show code coverage only for functions with region coverage greater than the given threshold'
HF06D994C900A: '仅显示区域覆盖率大于给定阈值的函数的代码覆盖率'
# 'Show code coverage only for functions with region coverage less than the given threshold'
H4FA285578577: '仅显示区域覆盖率小于给定阈值的函数的代码覆盖率'
# 'Show code coverage only for functions with the given name'
H9786810746F0: '仅显示具有给定名称的函数的代码覆盖率'
# 'Show commands to run and use verbose output'
HE1D432762909: '显示运行和使用详细输出的命令'
# 'Show context sensitive counts'
HE2280C2DDA17: '显示上下文敏感计数'
# 'Show counter values for shown functions'
H129F56F5FD53: '为显示的函数显示计数器值'
# 'Show coverage for branch conditions'
HC96F564B6A82: '显示分支条件的覆盖率'
# 'Show coverage for each function'
H3CCABA0A8100: '为每个函数显示覆盖率'
# 'Show coverage summaries for each function'
HBAF14E467A0F: '为每个函数显示覆盖率汇总'
# 'Show created time for each page.'
H321E973C4182: '为每个页面显示创建时间。'
# 'Show detailed profile summary'
HEDDF2BF2C691: '显示详细配置文件摘要'
# 'Show detailed warning message.'
H9E7102D900DA: '显示详细警告信息。'
# 'Show details of invoking getNextResoufceCycle.'
HA4F0023B8FF3: '显示调用getNextResoufceCycle的详细信息。'
# 'Show directory coverage'
H83933D919BBD: '显示目录覆盖率'
# 'Show edges labeled with weights'
H376FB60A851E: '显示带有权重标记的边'
# 'Show encoding in .s output'
HB528C74F2189: '显示.s输出中的编码'
# 'Show expanded source regions'
H387D478FCAFF: '显示展开的源区域'
# 'Show function instantiations'
HCFC0922F8DE2: '显示函数实例化'
# 'Show header includes and nesting depth'
HFC379692A313: '显示头文件包含及其嵌套深度'
# 'Show heat colors in CFG'
HF38DE9931AB9: '在控制流图中显示热图颜色'
# 'Show heat colors in call-graph'
HDDDF3F1C338F: '在调用图中显示热图颜色'
# 'Show indirect call site target values for shown functions'
H4D99B80D7C36: '为所选函数显示间接调用站点目标值'
# 'Show instantiation statistics in summary table'
HAD4D78E39FA9: '在摘要表中显示实例化统计信息'
# 'Show instr profile data in text dump format'
HE77B1EB739B5: '以文本转储格式显示指令配置文件数据'
# 'Show instruction encoding information in transliterate mode'
H15214D90288C: '在转写模式下显示指令编码信息'
# 'Show instruction encodings'
H76A361C43AC1: '显示指令编码'
# 'Show instructions operands as parsed'
HE4EAD3961196: '显示按原样解析的指令操作数'
# 'Show internal debug dump'
H79FC9F317159: '显示内部调试转储'
# 'Show internal instruction representation'
H969E08C4B063: '显示内部指令表示'
# 'Show internal instruction representation in transliterate mode'
HCF07E4857D2B: '在转写模式下显示内部指令表示形式'
# 'Show lexical and class parents'
H2CD760A9C080: '显示词法和类父类'
# 'Show line numbers in diagnostic code snippets'
H08938EFDB15B: '在诊断代码片段中显示行号'
# 'Show only simple regions in the graphviz viewer'
H09E6F5F4BBB1: '在Graphviz查看器中仅显示简单区域'
# 'Show only the configs matching this regex'
H2BD050A28852: '仅显示与该正则表达式匹配的配置'
# 'Show only the functions that have been executed.'
HD6154133C806: '仅显示已执行的函数。'
# 'Show profile summary of a list of hot functions'
H0361C5298777: '显示热门函数列表的分析摘要'
# 'Show profile symbol list if it exists in the profile. '
HC84B87BCF81B: '如果分析文件中存在符号列表，则显示该列表。 '
# 'Show profile version. '
HD8D6C82AA426: '显示分析文件版本。 '
# 'Show region statistics in summary table'
H3D65F3DC6E98: '在摘要表中显示区域统计信息'
# 'Show sample profile data in the JSON format (deprecated, please use --show-format=json)'
H828A9B7D7ACC: '以JSON格式显示样本分析数据（已弃用，请改用--show-format=json）'
# 'Show skipped includes in -H output.'
H2CB52D019FEC: '在-H输出中显示跳过的包含文件'
# 'Show temporal profile traces in the profile.'
H72096941B959: '在分析文件中显示时间分析轨迹。'
# 'Show the MCDC Coverage for each applicable boolean expression'
HD1B4BD4AF9D7: '显示每个适用布尔表达式的MCDC覆盖率。'
# 'Show the Polly CFG right after code generation'
H029F6C967468: '在代码生成后立即显示Polly的CFG'
# 'Show the collected coverage object files'
H31D89D92BF30: '显示已收集的覆盖对象文件'
# 'Show the collected paths to source files'
H26A34004C8C4: '显示已收集的源文件路径'
# 'Show the execution counts for each line'
HBDA134A1E3B8: '显示每行的执行次数。'
# 'Show the execution counts for each line, or the execution counts for each region on lines that have multiple regions'
H9AF77074F9BE: '显示每行的执行次数，或在存在多个区域的行上显示每个区域的执行次数。'
# 'Show the execution counts for each region'
HE82C34C08B90: '显示每个区域的执行次数。'
# 'Show the information of each section in the sample profile. The flag is only usable when the sample profile is in extbinary format'
HF5346C9B396B: '显示样本分析文件中每个部分的信息。该标志仅在样本分析文件为extbinary格式时可用'
# 'Show the list of functions with the largest internal counts'
HDB413363F895: '显示内部计数最大的函数列表'
# 'Show the profiled sizes of the memory intrinsic calls for shown functions'
HEACDF1B2720A: '显示已显示函数中内存内联函数调用的分析大小'
# 'Show the sizes of all debug sections, expressed in bytes.'
H78A0DAA47053: '以字节为单位显示所有调试部分的大小。'
# 'Show the sources across all compilation units.'
H9382C23DCF90: '显示所有编译单元中的源代码。'
# 'Show times for llvm-jitlink phases'
HD3302520BB6D: '显示llvm-jitlink各个阶段的耗时'
# 'Show times for llvm-rtdyld phases'
HB7BC3C6A17C2: '显示llvm-rtdyld阶段的时间'
# 'Show verbose output when opt-bisect-limit is set'
H8536EE8B8C8C: '当设置opt-bisect-limit时显示详细输出'
# 'Show vtable names for shown functions'
H79407841F063: '显示已列出函数的虚表名称'
# 'Shrink Wrap Pass'
HE4743C131F02: '收缩包装Pass'
# 'Shuffle machine instructions alternating directions'
H3D7E0E8AF77B: '交替方向打乱机器指令'
# 'Silence ObjC rewriting warnings'
HDDBF5BEB68D8: '静默ObjC重写警告'
# 'Similar completion items (e.g. function overloads) are combined. Type information shown where possible'
H1DEA188ACC34: '相似的完成项（例如函数重载）会被合并。尽可能显示类型信息'
# 'Similar to -ftime-trace. Specify the JSON file or a directory which will contain the JSON file'
H53211B2FCAB2: '类似于-ftime-trace。指定JSON文件或包含该JSON文件的目录'
# 'Similar to data-and-control, but remove the runtime check'
HDAE5253998D0: '类似于 data-and-control，但移除运行时检查'
# 'Similar to list-burr but schedules in source order when possible'
H322EBF2ED613: '类似于list-burr但在可能时按源代码顺序调度'
# 'Simple speculation'
H736302864F3E: '简单推测'
# 'Simplify DDG by merging nodes that have less interesting edges.'
H140319D98680: '通过合并具有较少重要边的节点来简化DDG'
# 'Simplify SCoP after optimizations'
H9435BBE6A7ED: '优化后简化SCoP'
# 'Simplify the CFG'
H3F01631183F4: '简化控制流图'
# 'Simplify the CFG after atomic expansion pass'
H4B39E0A8393B: '原子扩展Pass后执行CFG简化'
# 'Simply drop type test sequences'
H6F563FE46789: '直接丢弃类型测试序列'
# 'Simulate installation in the given directory'
H2E8832D0BC0E: '模拟在指定目录中的安装'
# 'Single thread model'
H0A1A3414EA60: '单线程模型'
# 'Sink common instructions (default = false)'
H458310DD7CCF: '下沉常见指令（默认=false）'
# 'Sink common instructions down to the end block'
HB6833655C393: '下沉常见指令直到结束块'
# 'Sink instructions into cycles to avoid register spills'
HA19B07EB7A73: '将指令下沉到循环中以避免寄存器溢出'
# 'Size limit for the MII.'
HFE4E64539F6A: 'MII的大小限制'
# 'Size limit in Hexagon early if-conversion'
HEE45F9DDA387: 'Hexagon早期if转换中的大小限制'
# 'Size of the expression which is considered huge'
H4AAD9C3152F7: '被视为巨大的表达式大小'
# 'Size of the load queue'
H51731E4081C2: '加载队列的大小'
# 'Size of the store queue'
H7CD5021D4D3E: '存储队列的大小'
# 'Size-specialize memcmp and bcmp calls'
H4D487410E126: '根据大小专门化memcmp和bcmp调用'
# 'SjLj exception handling'
HA2DEA63BE575: 'SjLj 异常处理'
# 'Skip 64-bit divide for dynamic 32-bit values'
HBC981EB66354: '跳过对动态 32 位值的 64 位除法'
# 'Skip Callsite up to this number for this compilation'
HD2D3E00B6C18: '在此编译中跳过最多数量的调用点'
# 'Skip Cost Analysis'
HEBC9E235FCC3: '跳过成本分析'
# 'Skip ODR checks for decls in the global module fragment.'
H3261F074F5AE: '跳过全局模块片段中声明的ODR检查'
# 'Skip checks for relocated modules when loading PCM files'
HD81AE42FB9F0: '在加载PCM文件时跳过已重定位模块的检查'
# "Skip emitting basic block entries in the SHT_LLVM_BB_ADDR_MAP section. It's used to save binary size when BB entries are unnecessary for some PGOAnalysisMap features."
H71707934B534: '跳过在SHT_LLVM_BB_ADDR_MAP节中生成基本块条目。当某些PGOAnalysisMap功能不需要基本块条目时，可用于节省二进制文件大小。'
# 'Skip function bodies when possible'
HC6384E72882E: '尽可能跳过函数体'
# 'Skip instructions on input which lack scheduling information'
H0CA4A6B1674E: '跳过输入中缺少调度信息的指令'
# 'Skip instructions or lines on input which are unsupported for any reason'
H66EA3C6B0D85: '跳过输入中因任何原因不受支持的指令或行'
# 'Skip lines on the input which fail to parse for any reason'
HF1FE9D6E74D2: '跳过输入中因任何原因无法解析的行'
# 'Skip merging empty blocks if (frequency of empty block) / (frequency of destination block) is greater than this ratio'
HD3ACA543F291: '如果空块的频率与目标块的频率之比大于该比率，则跳过合并空块'
# 'Skip merging functions with no parameters.'
H4C33F6695ED3: '跳过没有参数的函数合并'
# 'Skip op verification when using custom printers'
HE99716DCF0A6: '使用自定义打印器时跳过操作验证'
# 'Skip pass list reduction steps'
H94E9DA2F7021: '跳过pass列表缩减步骤'
# 'Skip printing info about analyses'
H89B96A0AA8C3: '跳过打印关于分析的信息'
# 'Skip regions when printing ops.'
HE9909BB5AB83: '在打印操作时跳过区域'
# 'Skip relative hotness check for ICP up to given number of targets.'
H1CF24D29FE78: '跳过ICP最多达到指定目标数的相对热度检查'
# 'Skip setting up RAX register when passing variable arguments (x86 only)'
H88536767AEC5: '在传递可变参数时跳过设置RAX寄存器（仅限x86）'
# 'Skip source code files with file paths that match the given regular expression'
HF5248544A184: '跳过与给定正则表达式匹配的源代码文件路径对应的文件'
# 'Skip the check if the number of hot functions is smaller than the specified number.'
HC72D43FB0410: '如果热函数数量小于指定值，则跳过该检查'
# 'Skip the dependency check for pragma-based transformations'
H9266BB52380C: '跳过基于pragma的转换的依赖检查'
# 'Slot index numbering'
H25CDF44B807D: '槽索引编号方式'
# 'Small code model'
HDBB10FAFE07D: '小型代码模型'
# 'Small data and bss section threshold size (default=0)'
HCE054C60032A: '小数据和bss段的阈值大小（默认=0）'
# 'Small data and bss section threshold size (default=8)'
HD23849593CCC: '小数据和bss段的阈值大小（默认=8）'
# 'Soft float ABI (implied by -soft-float)'
HC0C86A6BE8AC: '软浮点 ABI（由 -soft-float 隐含指定）'
# 'Sort by element kind.'
H873DE05DDF9E: '按元素类型排序。'
# 'Sort by element line number.'
HE0D755567860: '按元素行号排序。'
# 'Sort by element name.'
H0C2C0BB04670: '按元素名称排序。'
# 'Sort by element offset.'
HAEFFB6AFF193: '按元素偏移量排序。'
# 'Sort classes by amount of immediate padding'
HC0D1B98A168E: '按类的直接填充量排序'
# 'Sort classes by amount of padding'
H6740525F2A73: '按类的填充量排序'
# 'Sort classes by name'
H525546C671ED: '按类名排序'
# 'Sort classes by percentage of space consumed by immediate padding'
H807712AAABEC: '按直接填充消耗空间的百分比排序类'
# 'Sort classes by percentage of space consumed by padding'
H2970C3CE6488: '按填充消耗空间的百分比排序类'
# 'Sort classes by size'
H4175309835B2: '按大小排序类'
# 'Sort profiled recursion by edge weights.'
HDC0AFFCFAE60: '按边权重排序被分析的递归'
# 'Sort symbols by name'
HEF9C9A551533: '按名称排序符号'
# 'Sort symbols by size'
H194BBF71E1B6: '按大小排序符号'
# 'Sort the resources printed in the dump trace'
H66B4BBE5718F: '对转储跟踪中打印的资源进行排序'
# 'Source Code Analysis - Dead Symbol Removal Frequency'
H658C75F7C985: '源代码分析 - 无效符号移除频率'
# 'Source Code Analysis - Output Options'
H418F37A89230: '源代码分析 - 输出选项'
# 'Source Code Analysis - Symbolic Constraint Engines'
HD8341B8B44B5: '源代码分析 - 符号约束引擎'
# 'Source language name.'
HE1B71BB29701: '源语言名称。'
# 'Source prefix to elide'
HF556E14613B2: '要省略的源前缀'
# "Source-level compatibility for Altivec vectors (for PowerPC targets). This includes results of vector comparison (scalar for 'xl', vector for 'gcc') as well as behavior when initializing with a scalar (splatting for 'xl', element zero only for 'gcc'). For 'mixed', the compatibility is as 'gcc' for 'vector bool/vector pixel' and as 'xl' for other types. Current default is 'mixed'."
HCF923B012626: "源级兼容性设置（针对PowerPC目标平台的AltiVec向量）。包括向量比较结果（'xl' 为标量，'gcc' 为向量）以及使用标量初始化时的行为（'xl' 为扩展，'gcc' 仅保留第一个元素）。对于 'mixed' 模式，'vector bool/vector pixel' 类型与 'gcc' 兼容，其他类型与 'xl' 兼容。当前默认为 'mixed'。"
# 'SourceLocation in file %0 at offset %1 is invalid'
H2A6519004798: '文件 %0 中偏移量 %1 处的SourceLocation无效'
# 'Sparc Assembly Printer'
H91EE11A0F136: 'Sparc汇编打印机'
# 'Spawn a separate process for each cc1'
H4079AEA987DF: '为每个cc1进程创建独立的子进程'
# 'Spawns a subprocess for each snippet execution, allows for the use of memory annotations'
HB0B29965076D: '为每个代码片段执行启动子进程，允许使用内存注释'
# 'Specifies PowerPC native vector element order (default)'
HE6ABC638069C: '指定PowerPC原生向量元素顺序（默认值）'
# 'Specifies PowerPC non-native vector element order'
H1D9287995DAC: '指定PowerPC非原生向量元素顺序'
# 'Specifies a list of variables to be exempt from the TOC data transformation.'
HAF01AE884575: '指定要免于TOC数据转换的变量列表。'
# 'Specifies a list of variables to which the TOC data transformation will be applied.'
H33958769FAEF: '指定要应用TOC数据转换的变量列表。'
# "Specifies preferred vector width for auto-vectorization. Defaults to 'none' which allows target specific decisions."
H30D4DB622AB0: "指定自动向量化使用的首选向量宽度。默认为 'none'，允许目标特定的决策。"
# 'Specifies that the sample profile is accurate'
H3A3F53CE7955: '指定样本配置文件是准确的'
# 'Specifies the JITDylib to be used for any subsequent -extra-module arguments.'
HFDCED35F4977: '指定用于后续的-extra-module参数的JITDylib'
# 'Specifies the JITDylib to be used for any subsequent input file, -L<seacrh-path>, and -l<library> arguments'
H72683DE0AF39: '指定用于后续输入文件、-L<搜索路径>和-l<库>参数的JITDylib'
# "Specifies the debug info's compilation dir"
H64EB79AAF220: '指定调试信息的编译目录'
# 'Specifies the evaluation method to use for floating-point arithmetic.'
HB1694AF39E4A: '指定用于浮点运算的求值方法。'
# 'Specifies the exception behavior of floating-point operations.'
HF7A17A05FFEE: '指定浮点运算的异常行为。'
# "Specifies the largest alignment guaranteed by '::operator new(size_t)'"
H7C74E7BEFD7B: "指定 '::operator new(size_t)' 保证的最大对齐方式"
# 'Specifies the name we should consider the input file'
H048BF6366B06: '指定输入文件的名称'
# 'Specifies the size of batches for processing CUs. Higher number has better performance, but more memory usage. Default value is 1.'
HE1BE8B43F7F0: '指定处理CUs的批处理大小。数值越大性能越好，但内存使用越高。默认值为 1。'
# 'Specify "safe" i.e. known-good backend:'
H8A9DA72ACD37: '指定“安全”即已知良好的后端:'
# "Specify <function, basic block1[;basic block2...]> pairs to extract.\nEach pair will create a function.\nIf multiple basic blocks are specified in one pair,\nthe first block in the sequence should dominate the rest.\nIf an unnamed basic block is to be extracted,\n'%' should be added before the basic block variable names.\neg:\n  --bb=f:bb1;bb2 will extract one function with both bb1 and bb2;\n  --bb=f:bb1 --bb=f:bb2 will extract two functions, one with bb1, one with bb2.\n  --bb=f:%1 will extract one function with basic block 1;"
H5393854BACA7: "指定<函数, 基本块 1[;基本块 2...]>对进行提取。\n每对将创建一个函数。\n若单个对指定多个基本块，\n序列中第一个块应支配其余块。\n若提取未命名基本块，\n基本块变量名前应添加 '%'。\n示例：\n  --bb=f:bb1;bb2 将提取包含bb1和bb2的函数；\n  --bb=f:bb1 --bb=f:bb2 将分别提取包含bb1和bb2的两个函数。\n  --bb=f:%1 将提取包含基本块 1 的函数;"
# 'Specify <script> as linker script'
HE790F52CC3F0: '指定链接器脚本 <script>'
# 'Specify CU wavefront execution mode (AMDGPU only)'
H0AC391ACF1B8: '指定CU波前执行模式（仅AMDGPU）'
# 'Specify O2(not Os) spill func threshold'
HEC690666E75E: '指定O2（而非Os）的spill函数阈值'
# 'Specify Os spill func threshold'
H2796D0A3FC8E: '指定Os的spill函数阈值'
# 'Specify WGP wavefront execution mode (AMDGPU only)'
H1A9B58D9172E: '指定WGP波前执行模式（仅AMDGPU）'
# 'Specify a SamplePGO profile file'
H5B1BF8C410B3: '指定SamplePGO剖面文件'
# 'Specify a context sensitive PGO profile file'
H6CD3C27C7374: '指定上下文敏感型PGO剖面文件'
# "Specify a default target triple when it's not available in the module"
H8905580ACB2D: '当模块中未提供时，指定默认目标三元组'
# "Specify a directory where Clang can find 'include' and 'lib{,32,64}/gcc{,-cross}/$triple/$version'. Clang will use the GCC installation with the largest version"
H5F9EC5F91118: "指定Clang可以找到 'include' 和 'lib{,32,64}/gcc{,-cross}/$triple/$version' 的目录。Clang将使用版本最大的GCC安装"
# "Specify a directory where Flang can find 'lib{,32,64}/gcc{,-cross}/$triple/$version'. Flang will use the GCC installation with the largest version"
H59AA0290DBA6: "指定Flang可以找到 'lib{,32,64}/gcc{,-cross}/$triple/$version' 的目录。Flang将使用版本最大的GCC安装"
# 'Specify a plugin to optimize LFENCE insertion'
H749CB0E11874: '指定优化LFENCE插入的插件'
# 'Specify a reference program output (for miscompilation detection)'
H7D6525B849BF: '指定用于误编译检测的参考程序输出'
# 'Specify a symbol resolution: filename,symbolname,resolution\nwhere "resolution" is a sequence (which may be empty) of the\nfollowing characters:\n p - prevailing: the linker has chosen this definition of the\n     symbol\n l - local: the definition of this symbol is unpreemptable at\n     runtime and is known to be in this linkage unit\n x - externally visible: the definition of this symbol is\n     visible outside of the LTO unit\nA resolution for each symbol must be specified'
HFA08A87A55A4: '指定符号解析：文件名,符号名,解析方式\n其中"解析方式"是以下字符的序列（可能为空）：\n p - 选定的：链接器已选择该符号的定义\n l - 本地：该符号的定义在运行时不可替代且属于当前链接单元\n x - 外部可见：该符号的定义在LTO单元之外可见\n必须为每个符号指定解析方式'
# 'Specify alias to extract'
H4D5920CD11AC: '指定要提取的别名'
# 'Specify alias(es) to extract using a regular expression'
H5A885E78EEAE: '使用正则表达式指定要提取的别名'
# "Specify an offloading device architecture for CUDA, HIP, or OpenMP. (e.g. sm_35). If 'native' is used the compiler will detect locally installed architectures. For HIP offloading, the device architecture can be followed by target ID features delimited by a colon (e.g. gfx908:xnack+:sramecc-). May be specified more than once."
H03D163E89A58: "指定CUDA、HIP或OpenMP的卸载设备架构。例如sm_35。如果使用 'native'，编译器将检测本地安装的架构。对于HIP卸载，设备架构后可跟随用冒号分隔的目标ID特性（例如gfx908:xnack+:sramecc-）。可以多次指定该选项。"
# 'Specify an output filename for an HTML report. This describes both recommendations and reasons for changes.'
H8B1F64A00015: '指定HTML报告的输出文件名。该报告将描述建议和变更原因。'
# 'Specify bit size of immediate TLS offsets (AArch64 ELF only): 12 (for 4KB) | 24 (for 16MB, default) | 32 (for 4GB) | 48 (for 256TB, needs -mcmodel=large)'
H26411589DDDC: '指定即时TLS偏移的位大小（仅AArch64 ELF）：12（4KB）| 24（16MB，默认）| 32（4GB）| 48（256TB，需要-mcmodel=large）'
# 'Specify code object ABI version. Defaults to 6. (AMDGPU only)'
HA8698B7A4F07: '指定代码对象ABI版本。默认为 6。（仅AMDGPU）'
# 'Specify comma-separated list of offloading target triples (CUDA and HIP only)'
H4646687E209A: '指定以逗号分隔的卸载目标三元组列表（CUDA和HIP仅）'
# 'Specify comma-separated list of triples OpenMP offloading targets to be supported'
H3568A2B2B198: '指定要支持的以逗号分隔的OpenMP卸载目标三元组列表'
# 'Specify command to run'
H1E332E02D801: '指定要运行的命令'
# 'Specify configuration file'
HF189739D324B: '指定配置文件'
# "Specify default stream. The default value is 'legacy'. (CUDA/HIP only)"
H9CAF3E629210: "指定默认流。默认值为 'legacy'。（CUDA/HIP仅）"
# 'Specify file to retrieve coverage information from'
HF677E8D618FB: '指定用于检索覆盖信息的文件'
# 'Specify file to retrieve the list of functions to apply CHR to'
H43EA914C6AE3: '指定用于检索要应用CHR的函数列表的文件'
# 'Specify file to retrieve the list of modules to apply CHR to'
HB6D52312D695: '指定用于检索要应用CHR的模块列表的文件'
# 'Specify frame pointer elimination optimization'
HCB5E3F71D5CB: '指定帧指针消除优化'
# 'Specify function to extract'
H6994C514E482: '指定要提取的函数'
# 'Specify function(s) to extract using a regular expression'
H807560CFE84D: '使用正则表达式指定要提取的函数'
# 'Specify global to extract'
HDBAFDC1CCA62: '指定要提取的全局变量'
# 'Specify global(s) to extract using a regular expression'
H3D4D2BF99055: '使用正则表达式指定要提取的全局变量'
# 'Specify gotol lower bound'
H0CEAACB24E44: '指定gotol的下界'
# 'Specify how to interpret the input file'
H8145E9D12D4E: '指定如何解释输入文件'
# 'Specify input format'
H2E3E293CB7F2: '指定输入格式'
# 'Specify list of enabled SPIR-V extensions'
H3D0774E8209D: '指定启用的SPIR-V扩展列表'
# 'Specify lowering strategy for function LDS access:'
H5D945C2F2C1F: '指定函数LDS访问的降级策略:'
# 'Specify maximum number of prefixes to use for padding'
H3374CFFFC8CB: '指定用于填充的最大前缀数目'
# 'Specify name of main file output in depfile'
HA7D009581C27: '指定depfile中主文件的名称'
# 'Specify name of main file output to quote in depfile'
H50F02814EC9E: '指定在depfile中引用的主文件名称'
# 'Specify output filename'
H1761FE158718: '指定输出文件名'
# 'Specify remark argument/s to count (accepts regular expressions).'
H822EAE5D54AB: '指定要计数的remark参数（接受正则表达式）。'
# 'Specify remark argument/s to count by.'
HAEE8EE4F6186: '按remark参数指定计数依据。'
# 'Specify target SDNode namespace (default=<Target>ISD)'
H929FE737DC80: '指定目标SDNode命名空间（默认=<Target>ISD）'
# 'Specify target triple (e.g. i686-apple-darwin9)'
HB87754B01AFD: '指定目标三元组（例如i686-apple-darwin9）'
# 'Specify that backslash in string introduces an escape character'
H5D6C9DDA7494: '指定字符串中的反斜杠表示转义字符'
# 'Specify that floating-point optimizations are not allowed that assume arguments and results are not +-inf.'
H8BEEB06E6F67: '指定不允许假设参数和结果不为正负无穷的浮点优化'
# 'Specify that floating-point optimizations are not allowed that assume arguments and results are not NANs.'
H8FA0A762F433: '指定不允许假设参数和结果不为NAN的浮点优化'
# 'Specify that kernel argument names are preserved (HIP only)'
H623A10E0D7BD: '指定保留内核参数名称（仅限HIP）'
# 'Specify that single precision floating-point divide and sqrt used in the program source are correctly rounded (HIP device compilation only)'
H6D7A7AAF7A65: '指定程序源代码中单精度浮点除法和平方根运算需正确舍入（仅限HIP设备编译）'
# 'Specify that the assembler should encode SSE instructions with VEX prefix'
HE1B00D0701B9: '指定汇编器应使用VEX前缀编码SSE指令'
# 'Specify the "test" i.e. suspect back-end:'
HECCC4473972C: '指定“test”即可疑的后端:'
# 'Specify the BPF stack size limit'
HDC6898D3AB44: '指定BPF堆栈大小限制'
# 'Specify the Swift version to use when filtering API notes'
HC09727464228: '指定用于筛选API注释的Swift版本'
# 'Specify the available SPIR-V extensions. If this option is not specified, then all extensions are available.'
HA471B42FD9F7: '指定可用的SPIR-V扩展。若未指定此选项，则所有扩展均可用。'
# "Specify the boundary's size to align branches"
H7FCB2E0E7262: '指定对齐分支的边界大小'
# 'Specify the class to use for constant Objective-C string objects.'
H3B4E080AFF98: '指定常量Objective-C字符串对象使用的类'
# 'Specify the compression level (integer)'
HA372218D9884: '指定压缩级别（整数）'
# 'Specify the current profile is used as a partial profile.'
H3B5AA73241EA: '指定当前配置文件作为部分配置文件。'
# 'Specify the darwin target variant triple'
H1C214E10868A: '指定Darwin目标变种三元组'
# 'Specify the default character set for source files'
H23A2C73FDF8A: '指定源文件的默认字符集'
# 'Specify the default maximum struct packing alignment'
HA57D1AA26D37: '指定默认最大结构体打包对齐'
# "Specify the entry function (default = 'main') of the executable"
H95F6DBF9D7B0: "指定可执行文件的入口函数（默认='main'）"
# 'Specify the filename of the process to launch for remote MCJIT execution.  If none is specified,\n\tremote execution will be simulated in-process.'
HB6260E716DE3: '指定用于远程MCJIT执行的进程的文件名。如果没有指定，\n\t将在进程中模拟远程执行。'
# 'Specify the function selection heuristic used during inlining'
H700459284955: '指定内联期间使用的函数选择启发式方法'
# 'Specify the function to be called on overflow'
H514658550A0D: '指定溢出时调用的函数'
# 'Specify the interval (in seconds) after which a module file will be considered unused'
H7EDAFDC5BFCC: '指定模块文件被视为未使用的间隔时间（以秒为单位）'
# 'Specify the interval (in seconds) between attempts to prune the module cache'
HC07FD162EBA7: '指定尝试清理模块缓存的间隔时间（以秒为单位）'
# 'Specify the mapping of module name to precompiled module file, or load a module file if name is omitted.'
H9433E5C683C8: '指定模块名称到预编译模块文件的映射，或加载模块文件（如果省略名称）'
# 'Specify the maximum alignment to enforce on pointers lacking an explicit alignment'
H46AC799A7735: '指定对未明确指定对齐的指针强制应用的最大对齐值'
# 'Specify the maximum amount of instructions to inspect when searching for a conditional branch from an indirect control flow.'
H6CFBC17F5A5D: '指定在间接控制流中搜索条件分支时要检查的最大指令数量。'
# 'Specify the maximum amount of instructions to inspect when searching for an undefined instruction from a conditional branch.'
HBCCACE2ACD35: '指定在从条件分支搜索未定义指令时要检查的最大指令数量。'
# 'Specify the module cache path'
H2FE40A911909: '指定模块缓存路径'
# 'Specify the module user build path'
HE6E81535FDBA: '指定模块用户构建路径'
# 'Specify the name of an IR file to load for function definitions'
H66FD8DF154C5: '指定用于加载函数定义的中间表示（IR）文件名'
# 'Specify the name of the .dwo file to encode in the DWARF output'
HFD25A07F8173: '指定要在DWARF输出中编码的.dwo文件的名称'
# 'Specify the name of the module to build'
HC274D886E608: '指定要构建的模块名称'
# 'Specify the name of the root module.'
H385C12B5E6FA: '指定根模块的名称。'
# 'Specify the number of threads to use for device offloading tasks during compilation.'
H1A088440B2D0: '设置编译期间设备卸载任务所使用的线程数'
# "Specify the output file type ('asm', 'null', or 'obj')"
H908E78C67406: '指定输出文件类型（"asm"、"null" 或 "obj"）'
# 'Specify the output file. default: reduced.ll|.bc|.mir'
HDB7BE70A48BF: '指定输出文件。默认值：reduced.ll|.bc|.mir'
# 'Specify the output filename'
H3C3BD1616514: '指定输出文件名'
# 'Specify the output name of the file containing the optimization remarks. Implies -fsave-optimization-record. On Darwin platforms, this cannot be used with multiple -arch <arch> options.'
HD73FD36131DB: '指定包含优化备注的文件的输出名称。隐含启用 -fsave-optimization-record。在 Darwin 平台上，此选项不能与多个 -arch <arch> 选项一起使用。'
# 'Specify the overflow patterns to exclude from arithmetic sanitizer instrumentation'
H317E2D4E0BC0: '指定从算术检查器插入检测代码中排除的溢出模式'
# 'Specify the path of profile data file. This is mainly for test purpose.'
HE901E0A55767: '指定概要数据文件的路径。这主要用于测试目的。'
# 'Specify the path of profile remapping file. This is mainly for test purpose.'
H853E5B17061C: '指定概要重映射文件的路径。这主要用于测试目的。'
# 'Specify the path prefix of the MemProf dot files.'
H5392A6A236E7: '指定MemProf dot文件的路径前缀。'
# 'Specify the path to the "safe" backend program'
HD696058226F4: '指定“安全”后端程序的路径'
# 'Specify the prebuilt module path'
H3FAB39F2C50D: '指定预构建模块路径'
# 'Specify the printf lowering scheme (AMDGPU only), allowed values are "hostcall"(printing happens during kernel execution, this scheme relies on hostcalls which require system to support pcie atomics) and "buffered"(printing happens after all kernel threads exit, this uses a printf buffer and does not rely on pcie atomic support)'
H36B6C5D95ECD: '指定printf降级方案（仅AMDGPU），允许的取值为 "hostcall"（在内核执行期间进行打印，该方案依赖于主机调用，需要系统支持pcie原子操作）和 "buffered"（在所有内核线程退出后进行打印，使用printf缓冲区，不依赖pcie原子支持）'
# 'Specify the profile path in PGO use compilation'
H383968EDB0F3: '在PGO使用编译中指定配置文件路径'
# 'Specify the property to collect remarks by.'
H8278427A48F9: '指定用于按属性收集注释的属性。'
# 'Specify the property to group remarks by.'
HE59A5BD76AE3: '指定用于按属性分组注释的属性。'
# 'Specify the size in bits of an RVV vector register'
H0AB4126F0C29: '指定RVV向量寄存器的位数'
# 'Specify the size in bits of an SVE vector register. Defaults to the vector length agnostic value of "scalable". (AArch64 only)'
H2F3DFF504736: '指定SVE向量寄存器的位数。默认为与向量长度无关的 "scalable" 值。（仅限AArch64）'
# 'Specify the source file identifier for -funique-source-file-names; uses the source file path if not specified'
H0140BA1E31AB: '指定-funique-source-file-names的源文件标识符；若未指定，则使用源文件路径'
# 'Specify the stackmap encoding version (default = 3)'
H7CF270813613: '指定栈映射编码版本（默认值=3）'
# 'Specify the target Objective-C runtime kind and version'
HFE1F1D7E8E7B: '指定目标Objective-C运行时类型和版本'
# 'Specify the target environment'
H62189CA73425: '指定目标环境'
# 'Specify the type of coverage instrumentation for Sanitizers'
HCCE91ECD2AD5: '指定Sanitizers的覆盖检测类型'
# 'Specify the type of metadata to emit for binary analysis sanitizers'
HCEF5AB90855A: '指定为二进制分析Sanitizers生成的元数据类型'
# 'Specify the types of comparisons to emit GPR-only code for.'
HDBA609305F00: '指定要生成仅GPR代码的比较类型。'
# 'Specify the version of the memprof format to use'
H1B82817FBBA6: '指定要使用的memprof格式版本'
# 'Specify the vscale maximum. Defaults to the vector length agnostic value of "0". (AArch64/RISC-V only)'
HA66591A80BFB: '指定vscale最大值。默认为与向量长度无关的 "0" 值。（仅限AArch64/RISC-V）'
# 'Specify the vscale minimum. Defaults to "1". (AArch64/RISC-V only)'
H0C205532C01D: '指定vscale最小值。默认值为 "1"。（仅限AArch64/RISC-V）'
# 'Specify time trace file destination'
HC99CB0CDDE38: '指定时间跟踪文件的目标位置'
# 'Specify types of branches to align'
H8693C7688390: '指定要对齐的分支类型'
# 'Specify types of branches to align (plus separated list of types):\njcc      indicates conditional jumps\nfused    indicates fused conditional jumps\njmp      indicates direct unconditional jumps\ncall     indicates direct and indirect calls\nret      indicates rets\nindirect indicates indirect unconditional jumps'
H3D330EC77559: '指定要对齐的分支类型（用加号分隔的类型列表）：\njcc      表示条件跳转\nfused    表示融合条件跳转\njmp      表示直接无条件跳转\ncall     表示直接和间接调用\nret      表示返回\nindirect 表示间接无条件跳转'
# 'Specify wavefront size 32 mode (AMDGPU only)'
HA9AC5ACEB8A1: '指定wavefront大小 32 模式（仅AMDGPU）'
# 'Specify wavefront size 64 mode (AMDGPU only)'
H33E655B3FFCB: '指定wavefront大小为 64 模式（仅AMDGPU）'
# 'Specify where to find the compiled intrinsic modules'
H60F443A1A2B8: '指定查找编译后的intrinsic模块的位置'
# 'Specify which frame pointers to retain.'
H899F4C930DBE: '指定要保留的帧指针'
# 'Speculate that non-constant strides are unit in LAA'
HD4B90FE88764: '推测在LAA中非常量步长为单位步长'
# 'Speculate unpredictable branches (default = false)'
HBDC5587A6F17: '推测不可预测的分支（默认值=false）'
# 'Speculative execution is applied only to targets with divergent branches, even if the pass was configured to apply only to all targets.'
HA74AC4F303A4: '推测执行仅应用于具有分支分歧的目标，即使该pass被配置为仅应用于所有目标。'
# 'Speculative execution is not applied to basic blocks where the cost of the instructions to speculatively execute exceeds this limit.'
HE2B4F7F554AA: '如果推测执行指令的成本超过此限制，则不应用于基本块。'
# 'Speculative execution is not applied to basic blocks where the number of instructions that would not be speculatively executed exceeds this limit.'
H9EB9A3987580: '如果不会被推测执行的指令数量超过此限制，则不应用于基本块。'
# 'SpeculativeJIT'
H6F038D1D3644: 'SpeculativeJIT'
# 'Speculatively execute instructions'
HF1EBCFA9992F: '推测执行指令'
# 'Spill Code Placement Analysis'
HC707A69CEDE9: '溢出代码位置分析'
# 'Spill mode for splitting live ranges'
H33C680059059: '用于拆分活跃范围的溢出模式'
# 'Split GEPs to a variadic base and a constant offset for better CSE'
HCB9C6A238522: '拆分GEP为可变基址和常量偏移以提升公共子表达式消除效率'
# 'Split Options'
H33A61DDF11E4: '拆分选项'
# 'Split all critical edges during PHI elimination'
H4A2C55331EC3: '在PHI消除期间拆分所有关键边'
# 'Split all partitions'
H2671573A0660: '拆分所有分区'
# 'Split critical edges during machine sinking'
H4AC49C950879: '在机器下沉期间拆分关键边'
# 'Split machine functions using profile information'
HD03C9F1F9730: '使用配置信息拆分机器函数'
# 'Split marker to use for merging the ouput'
H5ED0DBD3456A: '用于合并输出的拆分标记'
# 'Split out cold basic blocks from machine functions based on profile information'
H1074CBD18EC9: '基于性能信息从机器函数中拆分出冷基本块'
# 'Split out cold blocks from machine functions based on profile information.'
H59A610956F3E: '基于性能信息从机器函数中拆分出冷基本块'
# 'Split static data'
HAD68510283FA: '拆分静态数据'
# 'Split static data sections into hot and cold sections using profile information'
H0855E4DC6A4D: '使用性能信息将静态数据段拆分为热段和冷段'
# 'Split the input file into chunks using the given or default marker and process each chunk independently'
H630FB595F295: '使用给定或默认的标记将输入文件拆分为块，并独立处理每个块'
# 'Split the output by Compile Units.'
H6C6E1FDA7719: '按编译单元分割输出。'
# 'Split the profile to two sections with one containing sample profiles with inlined functions and the other without (only meaningful for -extbinary)'
H4FBB422A3FD9: '将性能资料拆分为两个部分，其中一部分包含内联函数的示例性能资料，另一部分不包含（仅对-extbinary有意义）'
# 'Split without externalizing locals'
H8A331352F2E7: '不外联局部变量进行拆分'
# "Splits all EH code and it's descendants by default."
HA93F604541F1: '默认情况下将所有EH代码及其后代分开。'
# 'Stable  ABI instrumentation for sanitizer runtime. Default: Conventional'
H1B5D3202D1AE: '为sanitizer运行时提供稳定的ABI工具。默认：传统'
# 'Stack Frame Layout'
H33A25E80B45A: '栈帧布局'
# 'Stack Slot Coloring'
H85960DF4AF9A: '栈槽着色'
# 'StackMap Liveness Analysis'
H6CCE8B66D5C3: '栈映射活性分析'
# 'Standard converging scheduler.'
HA7AD7FEE5D0B: '标准收敛调度器。'
# 'Start each pass with collecting and end it with checking of debug info preservation.'
H3F51E578F392: '以收集开始并以检查调试信息保留结束每个pass'
# 'Start each pass with debugify and end it with check-debugify'
H2D5ADDBBEEF2: '以debugify开始每个pass并以check-debugify结束'
# 'Start emitting warnings for unused driver arguments'
HE346B2A53C42: '开始为未使用的驱动程序参数生成警告'
# 'Start the pipeline with collecting and end it with checking of debug info preservation.'
HE5F5305CC00C: '整个流水线以收集开始，以检查调试信息保留情况结束'
# 'Start the pipeline with debugify and end it with check-debugify'
H0175081FA86E: '整个流水线以debugify开始，以check-debugify结束'
# 'Statement-level analysis'
H08A2201C3BBE: '语句级分析'
# 'Static Data Annotator'
H8F3F11306A56: '静态数据注释器'
# 'Static Data Profile Info'
H42C5E08B9C8C: '静态数据剖面信息'
# 'Static analyzer report output format (html|plist|plist-multi-file|plist-html|sarif|sarif-html|text).'
HA5BB1BCA30A0: '静态分析器报告输出格式（html|plist|plist-multi-file|plist-html|sarif|sarif-html|text）'
# 'Static scheduling'
H9688287692D9: '静态调度'
# 'Statically link the sanitizer runtime (Not supported for ASan, TSan or UBSan on darwin)'
H5D51614B7830: '静态链接sanitizer运行时（在darwin上不支持ASan、TSan或UBSan）'
# 'Statically resolve calls to versioned functions from non-versioned callers.'
HDACBD3DAB33D: '静态解析非版本化调用者对版本化函数的调用'
# 'Stop PCH generation after including this file.  When using a PCH, skip tokens until after this file is included.'
HEE422676F0B0: '在包含此文件后停止PCH生成。使用PCH时，跳过标记直到包含此文件之后'
# 'Stop compilation after a specific pass'
HD6BD4366BCBC: '在特定pass之后停止编译'
# 'Stop compilation before a specific pass'
H50FA55AE29C2: '在特定pass之前停止编译'
# 'Stop inferring nofree attribute during function-attrs pass'
HAF941AF0C8A5: '在function-attrs pass不推断nofree属性'
# 'Stop inferring nounwind attribute during function-attrs pass'
H8B6C2FE67EDE: '在function-attrs pass不推断nounwind属性'
# 'Stop initializing trivial automatic stack variables after the specified number of instances'
H023CB238F8AC: '在指定实例数量后停止初始化简单的自动栈变量'
# 'Stop initializing trivial automatic stack variables if var size exceeds the specified number of instances (in bytes)'
HFF75ED2CDFB4: '如果变量大小超过指定的实例数量（以字节为单位），则停止初始化简单的自动栈变量'
# 'Stop processing after parsing rules and dump state'
HC94659F6E6B6: '停止在解析规则后处理并转储状态'
# 'Stop removing an empty block if removing it will introduce more than this number of phi entries in its successor'
H9A65443D39E6: '如果删除它会在其后续块中引入超过该数量的Phi条目，则停止删除空块'
# 'Stop scheduling after N instructions'
H9C405DA9723C: '在N条指令后停止调度'
# 'Store string literals as writable data'
HAB4FC207616D: '将字符串字面量存储为可写数据'
# 'Store-level granularity'
H6039083A6A50: '存储级粒度'
# 'Straight line strength reduction'
H31FF5C722167: '直线强度削弱'
# 'Stress Options'
HB2B1AD1DE1DF: '压力测试选项'
# 'Stress test LSR IV chains'
H1CC9D49F4B69: '对LSR IV链进行压力测试'
# 'Stress test ext(promotable(ld)) -> promoted(ext(ld)) optimization in CodeGenPrepare'
HB72AD83333E7: '在CodeGenPrepare中对ext(promotable(ld)) -> promoted(ext(ld))优化进行压力测试'
# 'Stress test instruction scheduling'
HA55B8E05F17D: '对指令调度进行压力测试'
# 'Stress test store(extract) optimizations in CodeGenPrepare'
HBA93839DF706: '在CodeGenPrepare中对store(extract)优化进行压力测试'
# 'String Table (DEBUG_S_STRINGTABLE subsection) (not typically present in PDB file)'
H346701412AE3: '字符串表（DEBUG_S_STRINGTABLE 子节）（通常不在PDB文件中存在）'
# 'String to initialize the database'
H3CBC3A337427: '初始化数据库的字符串'
# 'Strip (or keep only, if negative) a given number of path components when emitting check metadata.'
H95EB3AD2C385: '在生成检查元数据时，剥离（或仅保留，如果为负数）指定数量的路径组件'
# 'Strip debugger symbol info from translation unit'
HE92E5C253ED7: '从翻译单元中剥离调试器符号信息'
# 'Strip module-level named metadata'
HDD827ABBE60A: '剥离模块级命名元数据'
# 'Strip names from Value during LTO (other than GlobalValue).'
HC04AE0DCC2F5: '在LTO过程中从Value中剥离名称（除GlobalValue外）'
# 'Strip prefix of the fully qualified names'
HC496A1D3FAD4: '剥离完全限定名称的前缀'
# 'Strip specified level of directory name from source path in the profile counter name for static functions.'
HB9A6EFA2E4BB: '从静态函数的配置文件计数器名称中的源路径剥离指定级别的目录名'
# 'Strip-mine outer loops for the loop-vectorizer to trigger'
HA84FED7AAA88: '为循环向量化触发而剥离外部循环'
# 'Structure.'
H12CCB9A83FCE: '结构体。'
# 'Structurize the CFG'
H86D5CD019397: '结构化控制流图'
# 'Stuff'
H226D042D922D: '内容'
# 'Subprogram.'
H5A13F062C508: '子程序。'
# 'Subrange encoding information for arrays.'
H9B8612490EAE: '数组的子范围编码信息。'
# 'Summary of elements missing/added/matched/printed.'
HE867CEA332FA: '缺失/添加/匹配/打印元素的汇总。'
# 'Supplement an instr profile with sample profile, to correct the profile unrepresentativeness issue. The sample profile is the input of the flag. Output will be in instr format (The flag only works with -instr)'
HB26399824318: '使用样本配置文件补充instr配置文件，以纠正配置文件代表性不足的问题。样本配置文件是该标志的输入。输出将以instr格式呈现（该标志仅与-instr一起使用）'
# 'Support POSIX threads in generated code'
H519A7A85C373: '在生成的代码中支持POSIX线程'
# 'Suppress STP for AArch64'
H0D98334CA140: '抑制AArch64的STP'
# 'Suppress all deprecated warnings'
HE5E64D48AF93: '抑制所有已弃用的警告'
# 'Suppress all linking warnings'
H012398BE48C2: '抑制所有链接警告'
# 'Suppress all warnings'
HE2E5B3B89DBD: '抑制所有警告'
# 'Suppress counter promotion if exit blocks contain ret.'
H69AEA135B910: '如果退出块包含ret，则抑制计数器提升'
# 'Suppress duplication of instrs into per-HwMode decoder tables'
HC365469D96E4: '抑制将指令复制到每个HwMode解码表中'
# 'Suppress inlining of functions whose stack size exceeds the given value'
H25336627EFCB: '抑制堆栈大小超过给定值的函数的内联'
# 'Suppress output of running passes (both stdout and stderr)'
H777CD18B4BD8: '抑制运行passes的输出（包括stdout和stderr）'
# 'Suppress rematerialization of dynamic shadow address by passing it through inline asm in prologue.'
H9476840CC1D4: '通过在函数序言中通过内联汇编传递来抑制动态阴影地址的重新生成'
# 'Suppress slot sharing during stack coloring'
H734CB119B295: '在栈着色期间抑制槽共享'
# 'Suppress type errors (Wasm)'
H63BEE3B3DE32: '抑制类型错误（Wasm）'
# 'Suppress verbose debugify output'
H650FEBD3E6CA: '抑制详细的调试输出'
# 'Swap add and addi in cases where the add may be combined with a shift'
HB791E099C036: '在可以将加法与移位组合的情况下交换add和addi'
# 'Swap target blocks of a conditional branch for MVE expander'
H6042CB5BEBAE: '为MVE展开器交换条件分支的目标块'
# 'Switch to fast cluster algorithm with the lost of some fusion opportunities'
H3997C1BEC2C0: '切换到快速聚类算法（会丢失部分融合机会）'
# 'Symbol ID of the symbol being queried (hex).'
H06F2A7E436A9: '被查询符号的符号ID（十六进制）。'
# 'Symbol ID to look up (hex)'
H98F75068720A: '要查找的符号ID（十六进制）'
# 'Symbol Options'
HBFC1F4F0A88E: '符号选项'
# 'Symbol Rewrite Map'
H1CDA542441BA: '符号重映射映射表'
# 'Symbol Type Options'
H035FC129AB6C: '符号类型选项'
# 'Symbol kind to use when printing symbols.'
HB4C2F9BD84AD: '打印符号时使用的符号类型'
# 'Symbol location coverage.'
H80C30D273074: '符号位置覆盖。'
# 'Symbol remapping file'
H3423735D2CB7: '符号重映射文件'
# 'Symbol to call as main entry point'
H39AD275C387D: '作为主入口点调用的符号'
# 'Symbol to put in the symtab in the resulting dso'
HFB4EE7AEFE5C: '要放入生成的dso符号表中的符号'
# 'Symbols (DEBUG_S_SYMBOLS subsection) (not typically present in PDB file)'
HDB1B5EBB0319: '符号（DEBUG_S_SYMBOLS 子节）（通常不在PDB文件中存在）'
# 'Symbols (Variable, Members, etc.).'
HE394D83CA76F: '符号（变量、成员等）。'
# 'Symbols.'
H73E0811A7FD7: '符号。'
# 'Syntax variant to use for output printing'
HDCC1F5EAEC7B: '用于输出打印的语法变体'
# 'Synthesize retain and release calls for Objective-C pointers'
H40E12820EB61: '为Objective-C指针合成retain和release调用'
# 'System directory for configuration files'
H2B1CA8129B49: '系统配置文件目录'
# 'SystemZ Assembly Printer'
HF4545950D35C: 'SystemZ汇编打印机'
# 'SystemZ Comparison Elimination'
HA6D4515C513E: 'SystemZ比较消除'
# 'SystemZ Copy Physregs'
HBF6729EB5D82: 'SystemZ拷贝物理寄存器'
# 'SystemZ DAG->DAG Pattern Instruction Selection'
H66AEC705D460: 'SystemZ DAG->DAG模式指令选择'
# 'SystemZ Instruction Shortening'
H75E7D5BFB7B2: 'SystemZ指令缩短'
# 'SystemZ Local Dynamic TLS Access Clean-up'
H860F0223FC41: 'SystemZ本地动态TLS访问清理'
# 'SystemZ Long Branch'
H20A34CC2B958: 'SystemZ长分支'
# 'SystemZ Post Rewrite pass'
H26F388ADE65D: 'SystemZ重写后pass'
# 'SystemZ Test Data Class optimization'
H7C47CE39188C: 'SystemZ测试数据类优化'
# 'TableGen LSP Language Server'
H927DAB993B40: 'TableGen LSP 语言服务器'
# 'Tail Call Elimination'
H783C2FABF530: '尾调用消除'
# 'Tail Duplication'
H71C746D731D5: '尾部重复'
# 'Tail-folding and predication preferences over creating a scalar epilogue loop.'
HC5BDD1DF7A2D: '优先使用尾部折叠和预测而非创建标量尾循环'
# 'Take more precise inbounds assumptions (do not scale well)'
H08762D9FA006: '采用更精确的inbounds假设（扩展性较差）'
# 'Take raw hexadecimal bytes as input for disassembly. Whitespace is ignored'
H21819087D66E: '将要反汇编的原始十六进制字节作为输入。空白字符将被忽略'
# 'Takes a posix regex and prints the link graphs of all files matching that regex after fixups have been applied'
HB3F945A20F78: '接收一个posix正则表达式，并在修复程序应用后输出所有匹配文件的链接图'
# 'Target CPU, ignored if --mtriple is not used'
H9C0D15DCF3BD: '目标CPU，如果未使用--mtriple选项则被忽略'
# 'Target Library Information'
H5C80DD9524F8: '目标库信息'
# 'Target Pass Configuration'
HE8EFE346FCF6: '目标Pass配置'
# 'Target Transform Information'
H381DDCC824B8: '目标转换信息'
# 'Target a particular ABI type'
H8CB1D450BB9C: '指定特定的ABI类型'
# 'Target a specific auxiliary cpu type'
HC63DF9647BBE: '指定特定的辅助CPU类型'
# 'Target a specific cpu type'
HA6E72D889CDB: '指定特定的CPU类型'
# 'Target a specific cpu type (-mcpu=help for details)'
HB995589A2608: '指定特定的CPU类型（使用 -mcpu=help 查看详细信息）'
# 'Target arch to assemble for, see -version for available targets'
H6A0D4D1161C4: '要汇编的目标架构，可通过 -version 查看可用目标'
# 'Target architecture. See -version for available targets'
HDD6FE0D72BD5: '目标架构。可通过 -version 查看可用目标'
# 'Target cost kind'
HDAD667E32250: '目标成本类型'
# 'Target default float ABI type'
HEAFE690D5657: '目标默认浮点ABI类型'
# 'Target linker version'
H57EDF14C8F4F: '目标链接器版本'
# 'Target specific attributes'
H8E47E4436FE2: '目标特定的属性'
# 'Target specific attributes (-mattr=help for details)'
HAB90F22130BF: '特定于目标的属性（使用 -mattr=help 查看详细信息）'
# 'Target specific auxiliary attributes'
H2BA14C72345A: '目标特定的辅助属性'
# 'Target triple for disassembler'
H83C90E391152: '反汇编器的目标三元组'
# 'Target triple to assemble for, see -version for available targets'
HC643C7A09170: '要汇编的目标三元组，可通过 -version 查看可用目标'
# 'Target triple. See -version for available targets'
H3857DE6DE1E0: '目标三元组。可通过 -version 查看可用目标'
# 'Target triple. When present, a TargetMachine is created and TargetMachine::splitModule is used instead of the common SplitModule logic.'
H2B7CF41128A9: '目标三元组。当存在时，将创建TargetMachine并使用TargetMachine::splitModule代替通用的SplitModule逻辑。'
# 'Template Parameter.'
HF63F96014E9F: '模板参数。'
# 'Template alias.'
H3C8CFAE8AE20: '模板别名。'
# 'Template arguments encoded in the template name.'
H1C3D42D15648: '模板名称中编码的模板参数。'
# 'Template functions or specializations without host, device and global attributes have implicit host device attributes (CUDA/HIP only)'
HA4C9090C9925: '没有host、device和global属性的模板函数或特化将隐式具有host device属性（仅限CUDA/HIP）'
# 'Template pack.'
HA1E3326A0AE4: '模板参数包。'
# 'Template parameters replaced by its arguments.'
H2B376AF57DB4: '模板参数被其参数替换。'
# 'Template template parameter.'
HB1F99591F368: '模板模板参数。'
# 'Template type parameter.'
H16F66C4F3D61: '模板类型参数。'
# 'Template value parameter.'
H128B1A19518C: '模板值参数。'
# 'Template.'
H0518E81F03C2: '模板。'
# 'Temporary development switch used to gradually uplift SimplifyCFG into preserving DomTree,'
HBE52749BCFE7: '临时开发开关，用于逐步将SimplifyCFG增强为保留DomTree，'
# 'Terminate process if it loads user32.dll.'
H3BC023827DF8: '如果加载了user32.dll，则终止进程。'
# 'Test harness files'
HA4814F3A55AD: '测试框架文件'
# 'Text encoding'
H104683D616E5: '文本编码'
# 'Text output'
H722885D8D390: '文本输出'
# 'Textual description of the function type to be called'
HFA8DBC9DB008: '要调用的函数类型的文本描述'
# 'Textual description of the pass pipeline to run'
HE98FE702D92A: '要运行的pass管线的文本描述'
# 'The CPU number that the benchmarking process should executon on'
H67AECA2CBAEE: '基准测试进程应运行的CPU编号'
# 'The InteractiveModelRunner will echo back to stderr the data received from the host (for debugging purposes).'
HA27F90224438: 'InteractiveModelRunner会将从主机接收到的数据回显到stderr（用于调试）。'
# 'The LMUL to use for getRegisterBitWidth queries. Affects LMUL used by autovectorized code. Fractional LMULs are not supported.'
H065EFBB6A92E: '用于getRegisterBitWidth查询的LMUL。会影响自动向量化代码使用的LMUL。不支持分数LMUL。'
# 'The OOO window for processor resources during scheduling.'
H7F8CE8011253: '调度期间处理器资源的OOO窗口。'
# 'The alignment to use when accessing the buffers\nDefault is unaligned\nUse 0 to disable address randomization'
H9D92202DC06A: '访问缓冲区时使用的对齐方式\n默认为未对齐\n使用 0 禁用地址随机化'
# 'The amount of branches that we are willing to explore withthe exact algorithm before giving up.'
H46BDE8E006FD: '在放弃之前，使用精确算法愿意探索的分支数量。'
# 'The associativity of the first cache level.'
H091472E28B2B: '第一级缓存的关联性。'
# 'The associativity of the second cache level.'
HEE9D38673E97: '第二级缓存的关联性。'
# 'The average lifetime (s) for an allocation to be considered cold'
H31CAA2FC4467: '被视为冷分配的分配平均生命周期（秒）'
# 'The average number of profile counters allocated per value profiling site.'
H3EFF8568FB96: '每个值分析站点分配的性能计数器平均数量。'
# 'The base class for the ops in the dialect we are planning to emit'
HA507EEDE87C4: '我们计划生成的方言中操作的基类'
# 'The bonus weight of users of allocas within loop when sorting profitable allocas'
HBDF3A84E4987: '在排序有利的alloca时，循环内使用alloca的用户的额外权重'
# 'The clause simdlen must fit the %0-bit lanes in the architectural constraints for SVE (min is 128-bit, max is 2048-bit, by steps of 128-bit)'
H637FD9B0F74C: 'simdlen子句必须符合SVE架构约束中的 %0 位通道（最小为 128 位，最大为 2048 位，步长为 128 位）'
# 'The clause simdlen(1) has no effect when targeting aarch64.'
H28E8D9873AFA: '当目标为aarch64时，simdlen(1)子句无效'
# 'The code working set size is considered huge if the number of blocks required to reach the -profile-summary-cutoff-hot percentile exceeds this count.'
H1D058B3A0D64: '如果达到-profile-summary-cutoff-hot百分位所需的块数超过此计数，则代码工作集大小被视为巨大。'
# 'The code working set size is considered large if the number of blocks required to reach the -profile-summary-cutoff-hot percentile exceeds this count.'
H0799198BEFDB: '如果达到-profile-summary-cutoff-hot百分位所需的块数超过此计数，则代码工作集大小被视为较大。'
# 'The coefficient used when initializing II in the window algorithm.'
H8ABBDA1465FF: '在窗口算法中初始化II时使用的系数。'
# 'The compilation directory to embed in the coverage mapping.'
HC40AB6D0A1C3: '要嵌入到代码覆盖映射中的编译目录'
# 'The compilation directory to embed in the debug info'
H7AE615281122: '要嵌入到调试信息中的编译目录'
# 'The compilation directory to embed in the debug info and coverage mapping.'
HAD4DB13A434F: '要嵌入到调试信息和代码覆盖映射中的编译目录'
# 'The cost of a histcnt instruction'
HC55AE2001899: 'histcnt指令的开销'
# "The cost of a loop that is considered 'small' by the interleaver."
HF5F932DA0017: '交错器认为是"小"的循环的开销。'
# 'The cost of a step in a different basic block than the killing MemoryDef(default = 5)'
H38215D7CEF6B: '与杀死MemoryDef所在基本块不同的基本块中的步骤开销（默认 = 5）'
# 'The cost of a step in the same basic block as the killing MemoryDef(default = 1)'
HA3C397AE67B6: '与杀死MemoryDef所在基本块相同的步骤开销（默认 = 1）'
# 'The cost of decreasing a block count by one.'
HBA666F36C915: '减少一个块计数的开销。'
# "The cost of decreasing a block's count by one."
H9FCF3A04FBC3: '减少一个块的计数的开销。'
# 'The cost of decreasing a jump count by one.'
H01994AC78D25: '减少一个跳跃计数的开销。'
# "The cost of decreasing the entry block's count by one."
HCE46A7F305CE: '减少入口块的计数的开销。'
# 'The cost of increasing a block count by one.'
HAE44BF594D73: '增加一个块计数的开销。'
# "The cost of increasing a block's count by one."
H35BD66941EB2: '增加一个块的计数的开销。'
# 'The cost of increasing a count of zero-weight block by one.'
H15D3659B2D6D: '增加零权重块的计数的开销。'
# 'The cost of increasing a jump count by one.'
HBEF3551C10D0: '增加一次跳转计数的成本。'
# 'The cost of increasing an unknown block count by one.'
H70FD1895A2F3: '增加一个未知块计数的成本。'
# "The cost of increasing an unknown block's count by one."
H058C9FB6BA79: '增加一个未知块的计数成本。'
# 'The cost of increasing an unknown fall-through jump count by one.'
H8E3789B6B289: '增加一个未知穿透跳转计数的成本。'
# 'The cost of increasing an unknown jump count by one.'
H08B8AF9F180A: '增加未知跳转计数的成本。'
# "The cost of increasing the entry block's count by one."
H199FDB30E747: '增加入口块计数的成本。'
# 'The cost threshold for call sites that get inlined without the cost-benefit analysis'
HBDFEA6BEED2A: '无需成本效益分析即可内联的调用点的成本阈值'
# 'The cost threshold for loop unrolling'
H4E87362F1A39: '循环展开的成本阈值'
# 'The cost threshold for loop unrolling when optimizing for size'
H3ADA25107614: '在优化大小时循环展开的成本阈值'
# 'The cost threshold for partial loop unrolling'
H467DE32D1CDF: '部分循环展开的成本阈值'
# 'The cost threshold for unswitching a loop.'
HEDD158AF26CA: '循环分解的成本阈值'
# 'The current shard index'
H876C17A38CA1: '当前分片索引'
# 'The default 2nd-level tile size (if not enough were provided by --polly-2nd-level-tile-sizes)'
H1853EDCB107B: '默认的第 2 级分块大小（如果未通过--polly-2nd-level-tile-sizes提供足够的值）'
# 'The default address space is assumed as the flat address space. This is mainly for test purpose.'
HE348DDF306A6: '默认的地址空间被假设为平坦地址空间。这主要用于测试目的。'
# 'The default associativity of the first cache level (if not enough were provided by the TargetTransformInfo).'
HCCD8A81B4765: '第一级缓存的默认关联性（如果未通过TargetTransformInfo提供足够的值）'
# 'The default associativity of the second cache level (if not enough were provided by the TargetTransformInfo).'
HEEAD0D6C75FB: '第二级缓存的默认关联性（如果未通过TargetTransformInfo提供足够的值）'
# 'The default maximum header size for automatic loop rotation'
HF0260F4FDAA5: '自动循环旋转的默认最大头尺寸'
# 'The default memprof options'
H38DAB40B2AAC: '默认的memprof选项'
# 'The default register tile size (if not enough were provided by --polly-register-tile-sizes)'
H64576F36AC63: '默认的寄存器分块大小（如果未通过--polly-register-tile-sizes提供足够的值）'
# 'The default size of the first cache level specified in bytes (if not enough were provided by the TargetTransformInfo).'
H868C869C4E16: '以字节为单位指定的第一级缓存的默认大小（如果未通过TargetTransformInfo提供足够的值）'
# 'The default size of the second cache level specified in bytes (if not enough were provided by the TargetTransformInfo).'
HD12A54581382: '指定的第二级缓存默认大小（以字节为单位，如果目标转换信息未提供足够信息时使用）'
# 'The default tile size (if not enough were provided by --polly-tile-sizes)'
HE4A483AAF938: '默认的分块大小（如果未通过 --polly-tile-sizes 提供足够信息时使用）'
# 'The desired fields order.'
HFD5615C7395D: '期望的字段顺序'
# 'The dialect to gen for'
H28E806FCDC03: '要生成的目标方言'
# 'The dialect to run the generator for'
H6FB81B13F4F4: '要运行生成器的目标方言'
# 'The directory to import the .jscop files from.'
H46C31664F90D: '要导入.jscop 文件的目录'
# 'The directory which holds the compiler resource files'
HD211B444AC1B: '保存编译器资源文件的目录'
# 'The element type include parents in its name.'
H2A080E537B74: '元素类型名称包含父类型。'
# 'The estimated size of the generated function (# of instrs)'
HF9641D0FB6D1: '生成函数的预计大小（指令数量）'
# 'The exception model'
HE9B3D391FF5A: '异常模型'
# 'The file offset to explain'
HBBF973A12DBA: '需要解释的文件偏移量'
# 'The file to write the stream to'
HCE306C17C319: '要写入流的文件'
# 'The float ABI to use'
HD1594C861A1C: '使用的浮点ABI'
# 'The format of the remarks.'
H4E4CD6B16734: '备注的格式'
# 'The format that output stacks should be output in. Only applies with all-stacks.'
H212557A1C0DC: '堆栈输出应使用的格式。仅在启用 all-stacks 时生效'
# 'The format used for serializing remarks (default: YAML)'
H5541A330FC11: '用于序列化备注的格式（默认：YAML）'
# 'The function to be called'
H3E644E558FC4: '要调用的函数'
# 'The gcc binary to use.'
H0F09D1C4ABDE: '要使用的 gcc 二进制文件'
# 'The index or name of the stream whose contents to export'
H516360D4E007: '要导出其内容的流的索引或名称'
# 'The isl scheduling optimizer'
H0188CDF20DCD: 'ISL调度优化器'
# 'The kind of context sensitive profile guided optimization'
H057E88E7BF63: '上下文敏感的配置文件引导优化类型'
# 'The kind of dependence analysis to use'
HAC9C6B2E0446: '要使用的依赖性分析类型'
# 'The kind of profile guided optimization'
H930EACDC046E: '配置文件引导优化类型'
# 'The level of dependence analysis'
HDB7D1F3D8221: '依赖性分析的级别'
# 'The limit on recursion depth for LSRs setup cost'
H429ADCFB8F2B: 'LSR 的设置成本递归深度限制'
# 'The limit to use while constructing the DAG prior to scheduling, at which point a trade-off is made to avoid excessive compile time.'
H7C463E6FF16B: '在调度前构建 DAG 时使用的限制，在达到此限制时会进行权衡以避免编译时间过长'
# 'The list of function names in which Emscripten-style exception handling is enabled (see emscripten EMSCRIPTEN_CATCHING_ALLOWED options)'
H0AFF9B181379: '启用Emscripten风格异常处理（见emscripten EMSCRIPTEN_CATCHING_ALLOWED选项）的功能名称列表'
# 'The list of the names of classes being moved, e.g. "Foo,a::Foo,b::Foo".'
HC13468BE141E: '被移动的类名列表，例如 "Foo,a::Foo,b::Foo"'
# 'The lower bound of size growth limit for proirity-based sample profile loader inlining.'
HA4426ABB67AB: '基于优先级的样本配置文件加载程序内联的大小增长下限'
# 'The lower limit of the difference between best II and base II in the window algorithm. If the difference is smaller than this lower limit, window scheduling will not be performed.'
H2D09F1B7EEED: '窗口算法中最佳II与基II差异的下限。若差异小于该下限，则不执行窗口调度'
# 'The lower limit of the scheduling region in the window algorithm.'
H40693E0BEF44: '窗口算法中调度区域的下限'
# 'The max number of exiting blocks of a loop to allow  speculative counter promotion'
H126EBD7EDF69: '允许推测计数器提升的循环退出块最大数量'
# 'The max number of instructions to consider hoisting loads over (the algorithm is quadratic over this number)'
HB921741F8462: '考虑提升加载操作时的最大指令数（该算法与该数值的平方成正比）'
# 'The max number of iteration for converge'
HD528CDF78026: '收敛的最大迭代次数'
# 'The max of trip count upper bound that is considered in unrolling'
HD5BFA5564179: '未展开时在展开中考虑的迭代次数上限的最大值'
# 'The max version for the optimized memory  intrinsic calls'
H2E88F9E75F60: '优化内存内建函数调用的最大版本号'
# 'The maximal coefficient allowed (-1 is unlimited)'
H09B28C36A559: '允许的最大系数（-1表示无限制）'
# 'The maximal constant term allowed (-1 is unlimited)'
HF9153E8F373E: '允许的最大常量项（-1表示无限制）'
# 'The maximal number of arrays to compare in each alias group.'
HE46CCE04E50E: '每个别名组中比较的最大数组数量'
# 'The maximal number of disjunts allowed in memory accesses to to build RTCs.'
H810D09DBDCF0: '构建RTC时允许内存访问中的析取式最大数量'
# 'The maximal number of parameters allowed in RTCs.'
HD93322BFBD09: 'RTC中允许的最大参数数量'
# "The maximum 'boost' (represented as a percentage >= 100) applied to the threshold when aggressively unrolling a loop due to the dynamic cost savings. If completely unrolling a loop will reduce the total runtime from X to Y, we boost the loop unroll threshold to DefaultThreshold*std::min(MaxPercentThresholdBoost, X/Y). This limit avoids excessive code bloat."
H02A5B75E496D: '当激进地展开循环时，根据动态成本节省应用的最大提升百分比（>=100）。若完全展开循环可将总运行时间从X缩短到Y，会将展开阈值提升至DefaultThreshold*std::min(MaxPercentThresholdBoost, X/Y)。该限制可避免代码膨胀过度'
# 'The maximum LMUL value to use for fixed length vectors. Fractional LMUL values are not supported.'
H8B177E0FA80A: '固定长度向量使用的最大LMUL值。不支持分数LMUL值'
# 'The maximum allowed number of runtime memory checks'
HF580EDA4AA2E: '允许的最大运行时内存检查数量'
# 'The maximum cost used for building integers.'
H61DA215B1301: '构建整数时使用的最大成本'
# 'The maximum distance (in bytes) of a backward jump for ExtTSP'
H1AADC32AA7A5: 'ExtTSP向后跳转的最大距离（以字节为单位）'
# 'The maximum distance (in bytes) of a forward jump for ExtTSP'
H8BF30ACF7ADE: 'ExtTSP前向跳转的最大距离（以字节为单位）'
# 'The maximum distance (in bytes) of backward jumps for ExtTSP value'
H7CD48ED835E9: 'ExtTSP值的后向跳转最大距离（以字节为单位）'
# 'The maximum interleave count to use when interleaving a scalar reduction in a nested loop.'
H672121274D43: '在嵌套循环中交错标量约简时允许的最大交错次数'
# 'The maximum length of a constant string for a builtin string cmp call eligible for inlining. The default value is 3.'
H6551F5EAB050: '允许内联的内建字符串比较调用的常量字符串最大长度。默认值为 3'
# 'The maximum length of a constant string to inline a memchr call.'
HAAA048CEEC02: '允许内联memchr调用的常量字符串最大长度'
# 'The maximum length of a single temporal profile trace (default: 10000)'
HFAF4CED9A0E5: '单个时间剖面轨迹的最大长度（默认：10000）'
# 'The maximum levels the DFS-based missing frame search should go with'
H45092EF73D81: '基于DFS的缺失帧搜索应达到的最大层级'
# 'The maximum look-ahead depth for operand reordering scores'
H3909DC008995: '操作数重排评分的最大预读深度'
# 'The maximum look-ahead depth for searching best rooting option'
H23AE19C8EFE0: '寻找最佳根定位选项时的最大预读深度'
# 'The maximum nesting depth allowed for assembly macros.'
H59D58A80D82C: '允许的汇编宏嵌套深度最大值'
# 'The maximum number candidates that only partially overwrite the killing MemoryDef to consider (default = 5)'
HF74C3F17FA82: '允许考虑仅部分覆盖杀死MemoryDef的候选数量（默认=5）'
# 'The maximum number of SCEV checks allowed for Loop Distribution'
H6ED62802FFA5: '循环分布允许的最大SCEV验证次数'
# 'The maximum number of SCEV checks allowed for Loop Distribution for loop marked with #pragma clang loop distribute(enable)'
H4DE7DF87A45B: '标记有#pragma clang loop distribute(enable)的循环分布允许的最大SCEV验证次数'
# 'The maximum number of SCEV checks allowed for Loop Load Elimination'
H7F641B62EEBD: '循环负载消除允许的最大SCEV验证次数'
# 'The maximum number of SCEV checks allowed with a vectorize(enable) pragma'
H4BEEB9147A41: '标记有vectorize(enable) pragma时允许的最大SCEV验证次数'
# 'The maximum number of SCEV checks allowed.'
HAB10FFD86827: '允许的最大SCEV验证次数'
# 'The maximum number of blocks to check when trying to prove that all paths to an exit go through a killing block (default = 50)'
HE588309A8379: '尝试证明所有退出路径都经过杀死块时要检查的块最大数量（默认=50）'
# 'The maximum number of callsites in a function, above which stale profile matching will be skipped.'
H22730C5AA352: '函数中调用站点数量超过该值时将跳过陈旧配置文件匹配'
# 'The maximum number of clones allowed for a single function specialization'
H9DEE4E0B8275: '单个函数特化允许的最大克隆数量'
# 'The maximum number of functions to track per lattice value'
HCD37A486700C: '每个晶格值要跟踪的最大函数数量'
# 'The maximum number of heap allocations to consider in one function before skipping (to save compilation time). Set to 0 for no limit.'
H9E920C5F07AD: '在跳过之前考虑一个函数中的堆分配的最大数量（以节省编译时间）。设置为 0 表示无限制。'
# 'The maximum number of incoming values a PHI node can have to be considered during the specialization bonus estimation'
H03E2B05D3E4E: '在专用化奖励估算期间，PHI节点可以拥有的传入值的最大数量'
# 'The maximum number of instructions considered for cycle sinking.'
HEC82079C9F71: '考虑循环下沈的指令最大数量'
# 'The maximum number of iterations allowed when searching for transitive phis'
H0F558354650E: '在搜索传递PHI节点时允许的迭代次数最大值'
# 'The maximum number of iterations function specialization is run'
H8854F37807C4: '函数专用化运行时允许的最大迭代次数'
# 'The maximum number of parameters allowed when merging functions.'
H24D089F01734: '合并函数时允许的最大参数数量'
# 'The maximum number of predecessors a basic block can have to be considered during the estimation of dead code'
HFD5552B5CF15: '在死代码估算期间，基本块可以拥有的前驱块的最大数量'
# 'The maximum number of scheduling group conflicts which we attempt to solve with the exponential time exact solver. Problem sizes greater than this willbe solved by the less accurate greedy algorithm. Selecting solver by size is superseded by manually selecting the solver (e.g. by amdgpu-igrouplp-exact-solver'
H071D666725DB: '使用指数时间精确求解器尝试解决的调度组冲突最大数量。大于该大小的问题将由精度较低的贪心算法解决。通过大小选择求解器将被手动选择的求解器（例如通过amdgpu-igrouplp-exact-solver参数）覆盖'
# 'The maximum number of steps while walking upwards to find MemoryDefs that may be killed (default = 90)'
HA207F5C7ADD1: '向上遍历时寻找可能被杀死的MemoryDefs步骤的最大数量（默认值为 90）'
# 'The maximum number of stored temporal profile traces (default: 100)'
H6A4CCB113506: '存储的时序剖面轨迹最大数量（默认：100）'
# 'The maximum number of stores/phis MemorySSAwill consider trying to walk past (default = 100)'
H0C4FBDD67710: 'MemorySSA将尝试遍历的最大存储/PHI节点数量（默认值为 100）'
# 'The maximum number of times a live range can be evicted before preventing it from being evicted'
HEF28AF0C80C6: '在阻止其被替换之前，活动范围可以被替换的最大次数'
# 'The maximum number of times the analyzer will go through a loop'
H82DC4EFFB765: '分析器遍历循环的最大次数'
# 'The maximum number of vtable for the last candidate.'
H839DD45E9E74: '最后一个候选的vtable最大数量'
# 'The maximum number of warnings to emit when correlating profile from debug info (0 = no limit)'
H710123CD3CA7: '根据调试信息关联剖面数据时允许的最大警告数量（0=无限制）'
# 'The maximum ratio between densities of two chains for merging'
H459D99ED8D7D: '合并时两条链密度之间的最大比率'
# "The maximum size of a callee that get's inlined without sufficient cycle savings"
H37B172BFF744: '在没有足够循环节省的情况下，可内联的被调用函数的最大大小'
# 'The maximum size of a chain to apply splitting'
H74E01FDFE4C4: '应用拆分时链的最大大小'
# 'The maximum size of a chain to create'
H29DFAD1C81AC: '创建链时的最大大小'
# 'The maximum size of a function to consider for inference.'
HEC9218936482: '考虑推断时函数的最大大小'
# 'The maximum size of an object in the sdata section'
HE9CFD8856EDF: 'sdata段中对象的最大大小'
# 'The maximum size to use in sweep-mode'
HC4DABE2321EB: '在sweep模式下使用的最大尺寸'
# 'The maximum stride, considered to be profitable.'
H091F45C95DD9: '被认为有利的最大步长值'
# 'The maximum total number of memory locations alias sets may contain before degradation'
H926FBF01198C: '别名集在降级前可包含的最大总内存位置数'
# 'The minimal number of cycles between issuing two dependent consecutive vector fused multiply-add instructions.'
H4AA5B2DBB66A: '连续向量融合乘加指令之间需要的最小周期数'
# 'The minimal number of per-loop instructions before a single loop region is considered profitable'
H4CE0D632999A: '单个循环区域被视为有利前，每个循环的最小指令数量'
# 'The minimum TotalLifetimeAccessDensity / AllocCount for an allocation to be considered hot'
HA94E6199F898: '分配被视作热点所需的最小 TotalLifetimeAccessDensity / AllocCount 比值'
# 'The minimum count to optimize memory intrinsic calls'
HEF63EC815D8B: '优化内存内联函数调用所需的最小计数值'
# 'The minimum instruction count required when merging functions.'
HB052AF91D102: '合并函数时所需的最小指令数量'
# 'The minimum number of arguments a function call must have before it is considered having many arguments.'
H384F6CF79650: '函数调用被视为具有大量参数所需的最小参数数量'
# 'The minimum number of basic blocks required for a function to run stale profile call graph matching.'
H6DFC7FF9B6F4: '函数运行陈旧调用图匹配所需的最小基本块数量'
# 'The minimum number of call anchors required for a function to run stale profile call graph matching.'
HA0900373C45C: '函数运行陈旧调用图匹配所需的最小调用锚点数量'
# 'The minimum number of instructions a basic block should contain before being considered big.'
H35A15684714E: '被视为大基本块前，基本块应包含的最小指令数量'
# 'The minimum number of instructions a basic block should contain before being considered medium-sized.'
HE3CFEDACCE84: '被视为中等尺寸基本块前，基本块应包含的最小指令数量'
# 'The minimum number of instructions that are outlined in a frame helper (default = 2)'
HDCE9324580BB: '帧辅助函数中被提取的最小指令数量（默认值 = 2）'
# 'The minimum number of instructions that should be included in the snippet'
HD8B3E130AB22: '代码片段应包含的最小指令数量'
# 'The minimum number of loads, which should be considered strided, if the stride is > 1 or is runtime value'
HA691E257E6C6: '当步长 >1 或为运行时值时，应被视为步长式加载的最小加载次数'
# 'The minimum size in bytes before an outlining candidate is accepted'
H382DFDE541E3: '接受提取候选所需的最小字节尺寸'
# 'The minimum size in bytes of each global that should considered in merging.'
HAE0FA4D9E816: '合并时应考虑的每个全局变量的最小字节尺寸'
# 'The minimum size to use in sweep-mode'
HA2F6EC5B505C: '在sweep模式下使用的最小尺寸'
# 'The model being trained for register allocation eviction'
H7FEA0D631D24: '寄存器分配替换所训练的模型'
# 'The model being trained for register allocation priority'
H417CF14D5A6E: '用于寄存器分配优先级训练的模型'
# 'The name for this study'
H400FDCCEAC14: '此次研究的名称'
# 'The name of a function (or its substring) whose CFG is viewed/printed.'
HD3E3246593FE: '要查看/打印其控制流图（CFG）的函数（或其子字符串）的名称。'
# 'The name of a validation counter to run concurrently with the main counter to validate benchmarking assumptions'
HABCFB9B683CF: '与主计数器并行运行以验证基准测试假设的验证计数器名称'
# 'The name of the ABI to be targeted from the backend.'
H3EC72F95FC35: '后端要针对的目标ABI名称'
# 'The name of the distribution to use'
HF09A01C5BE8E: '要使用的发行版名称'
# 'The name of the executor to use.'
H9A67A8D34CB5: '要使用的执行器名称'
# "The name of the predefined style used as a\nfallback in case clang-format is invoked with\n-style=file, but can not find the .clang-format\nfile to use. Defaults to 'LLVM'.\nUse -fallback-style=none to skip formatting."
H605E77115F2D: "当以-style=file调用clang-format但无法找到要使用的.clang-format文件时，用作回退的预定义样式名称。默认为 'LLVM'。\n使用-fallback-style=none可跳过格式化。"
# 'The name of the struct/class.'
HA728CE8CB2EB: '结构体/类的名称'
# 'The name of this group of passes'
HE53A929D4575: '此passes组的名称'
# 'The number of MemoryDefs we consider as candidates to eliminated other stores per basic block (default = 5000)'
HB4E81F98BD76: '在每个基本块中视为候选以消除其他存储操作的MemoryDefs数量（默认值=5000）'
# 'The number of benchmarks run to perform'
H643296C3A4C1: '要执行的基准测试次数'
# 'The number of blocks to scan during memory dependency analysis (default = 200)'
HD2242DBDE5D7: '在内存依赖性分析期间要扫描的基本块数量（默认值=200）'
# 'The number of instructions to scan in a block in memory dependency analysis (default = 100)'
H2BC6010D3D27: '在内存依赖性分析中每个块要扫描的指令数量（默认值=100）'
# 'The number of instructions to search for a redundant dmb'
HD7126DC70D5E: '搜索冗余dmb指令的数量'
# 'The number of loads per basic block for inline expansion of memcmp that is only being compared against zero.'
HE7402F9BFD73: '仅与零比较时用于memcmp内联扩展的每个基本块的加载次数'
# 'The number of loop iterations to strip-mine for pre-vectorization'
H73D394A3273E: '预向量化所需的循环迭代剥离次数'
# 'The number of memory instructions to scan for dead store elimination (default = 150)'
H0D792B752EF6: '死存储消除要扫描的内存指令数量（默认值=150）'
# 'The number of precise steps between two approximating iterations. (A value of -1 schedules another approximation stage before the actual dead code elimination.'
H795458185A22: '两次近似迭代之间的精确步骤数。（-1的值会在实际死代码消除前安排另一个近似阶段。'
# 'The number of predecessors to search for a stronger condition to use to thread over a weaker condition'
H7527D41A84C6: '要搜索以找到可用于跨较弱条件使用的更强条件的前驱数量'
# 'The number of searches per loop in the window algorithm. 0 means no search number limit.'
H1DDD94D0908A: '窗口算法中每个循环的搜索次数。0表示没有搜索次数限制。'
# 'The number of shards into which the op classes will be divided'
H2AD8480DFFBC: '操作类将被划分为的分片数量'
# 'The number of threads used to process all files in parallel. Set to 0 for hardware concurrency. This flag only applies to all-TUs.'
H14270C0E6B74: '并行处理所有文件使用的线程数。设置为 0 以使用硬件线程数。此标志仅适用于所有翻译单元。'
# 'The number of times to repeat measurements on the benchmark k before aggregating the results'
HEB3E720640C3: '在聚合结果前对基准测试k进行测量的重复次数阈值'
# 'The option is used to turn on/off warnings about hash mismatch for comdat or weak functions.'
HB9E7F6492359: '该选项用于启用或禁用关于comdat或弱函数哈希不匹配的警告。'
# 'The option to specify the name of the function whose CFG will be displayed.'
H14BF30CA9694: '指定要显示其控制流图的函数名称的选项。'
# 'The option to specify the name of the function whose block frequency info is printed.'
H669D97AE9C69: '指定要打印其基本块频率信息的函数名称的选项。'
# 'The option to specify the name of the function whose branch probability info is printed.'
H64FA83ADF33F: '指定要打印其分支概率信息的函数名称的选项。'
# 'The option to specify the name of the functions to verify.'
H99F22C3FC88F: '指定要验证的函数名称的选项。'
# 'The overhead cost associated with each function call when merging functions.'
HFC522517EF09: '合并函数时每个函数调用相关的开销成本。'
# 'The overhead cost associated with each instruction when lowering to machine instruction.'
H77BF5CB5FA41: '将指令降低到机器指令时每个指令相关的开销成本。'
# 'The overhead cost associated with each parameter when merging functions.'
H1DB7993015A4: '合并函数时每个参数相关的开销成本。'
# 'The page size of the target in bytes'
H1B53A7D2781D: '目标平台的页面大小（以字节为单位）'
# 'The percentage threshold against remaining unpromoted indirect call count for the promotion'
HE86B36D2F491: '间接调用计数未被优化部分的百分比阈值，用于优化。'
# 'The percentage threshold against remaining unpromoted indirect call count for the promotion for calls'
H781076CED89A: '调用间接调用计数未被优化部分的百分比阈值，用于调用优化。'
# 'The percentage threshold against remaining unpromoted indirect call count for the promotion for jump tables'
H136B41571D6C: '跳转表间接调用计数未被优化部分的百分比阈值，用于跳转表优化。'
# 'The percentage threshold against total count for the promotion'
H6676D5E1FF86: '总调用计数的百分比阈值，用于优化。'
# 'The percentage threshold against total count for the promotion for calls'
H48EACF9E7526: '调用总调用计数的百分比阈值，用于调用优化。'
# 'The percentage threshold against total count for the promotion for jump tables'
HA1920C4CE7DC: '跳转表总调用计数的百分比阈值，用于跳转表优化。'
# 'The percentage threshold for the memory intrinsic calls optimization'
HED02E6485AF5: '内存内联函数调用优化的百分比阈值。'
# 'The percentage threshold of vtable-count / function-count for cost-benefit analysis.'
H65D337CD6C45: '成本效益分析中vtable-count / function-count的百分比阈值。'
# 'The position of the cursor when invoking\nclang-format from an editor integration'
H2456492C399B: '通过编辑器集成调用clang-format时的光标位置'
# 'The power exponent for the distance-based locality'
HE2E30EB8297B: '基于距离的局部性的幂指数'
# 'The prefix of the dialect extension'
HB374D232EB61: '方言扩展的前缀'
# 'The prefix to use for this group of passes. The form will be mlirCreate<prefix><passname>, the prefix can avoid conflicts across libraries.'
HDCE2477640BC: '该传递组的前缀。形式为mlirCreate<prefix><passname>，该前缀可以避免不同库之间的冲突。'
# 'The prefix used for the CFG dot file names.'
H3299C4982B02: '控制流图（CFG）dot文件名的前缀。'
# 'The prefix used for the CallGraph dot file names.'
HAC819E10CA1B: '调用图（CallGraph）dot文件名的前缀。'
# 'The prefix used for the DDG dot file names.'
HF593C1E1F184: '数据依赖图（DDG）dot文件名的前缀。'
# 'The prefix used for the Machine CFG dot file names.'
H54988740C957: '机器控制流图（Machine CFG）dot文件名的前缀。'
# 'The probability of a guard failing is assumed to be the reciprocal of this value (default = 1 << 20)'
H54F7AFA0E05B: '假设guard失败的概率是该值的倒数（默认值=1 << 20）'
# 'The probability threshold of enabling branch hint.'
HDA416C9E705B: '启用分支提示的概率阈值。'
# 'The profile guided size optimization profile summary cutoff for instrumentation profile.'
H416C25DD1085: '插桩剖面用于配置文件引导型尺寸优化的摘要截止值'
# 'The profile guided size optimization profile summary cutoff for sample profile.'
H7CFAC61196B3: '基于采样配置文件的大小优化配置文件摘要截断值。'
# 'The ratio of searches per loop in the window algorithm. 100 means search all positions in the loop, while 0 means not performing any search.'
H69F36D760102: '窗口算法中每个循环的搜索比率。100表示搜索循环中的所有位置，而 0 表示不进行任何搜索。'
# 'The relative/absolute file path of new cc.'
HE0F45871CC31: '新cc的相对/绝对文件路径。'
# 'The relative/absolute file path of new header.'
H4D4C2CCB6DC7: '新头文件的相对/绝对文件路径。'
# 'The relative/absolute file path of old cc.'
H9627E5223A5E: '旧cc的相对/绝对文件路径。'
# 'The relative/absolute file path of old header.'
H13E40B3B27E1: '旧头文件的相对/绝对文件路径。'
# 'The relocation model to use'
H8DE955C1B327: '使用的重定位模型'
# 'The sample period (nbranches/sample), used for LBR sampling'
H61D3CFB88363: 'LBR采样使用的采样周期（nbranches/sample）'
# 'The scale factor for the frequency-based locality'
H4C2907D8364D: '基于频率的局部性的比例因子'
# 'The scale factor used to scale the working set size of the partial sample profile along with the partial profile ratio. This includes the factor of the profile counter per block and the factor to scale the working set size to use the same shared thresholds as PGO.'
H7BF4A788068D: '用于按比例缩放部分样本配置文件的工作集大小以及部分配置文件比率的缩放因子。这包括每个块的配置文件计数器因子以及用于使用与PGO相同共享阈值的缩放工作集大小的因子。'
# 'The seed used by the randomize structure layout feature'
H3D8BA8E60ECF: '随机化结构布局功能使用的种子'
# 'The selected source range in which the refactoring should be initiated (<file>:<line>:<column>-<line>:<column> or <file>:<line>:<column>)'
H9B806B9A88F2: '重构应启动的选定源代码范围（<文件>:<行>:<列>-<行>:<列> 或 <文件>:<行>:<列>）'
# 'The size growth ratio limit for proirity-based sample profile loader inlining.'
H93A8BBE0A03D: '基于优先级的样本配置文件加载器内联的大小增长比率限制。'
# "The size in bits of a vector register (if not set, this information is taken from LLVM's target information."
H4457D4EEB097: '向量寄存器的位数大小（若未设置，则从LLVM的目标信息中获取。'
# 'The size of a line in the cache'
H3FC377B654FB: '缓存中的一行大小'
# 'The size of the cache'
H1AFA9403E784: '缓存的大小'
# 'The size of the first cache level specified in bytes.'
H79C5863504EE: '以字节为单位指定的第一个缓存层级的大小。'
# 'The size of the first level cache line size specified in bytes.'
H0A19D3F7EF60: '以字节为单位指定的第一级缓存行大小。'
# 'The size of the second level specified in bytes.'
HE64C9129467C: '以字节为单位指定的第二级缓存大小。'
# 'The string to embed in the .LLVM.command.line section.'
H96651B0831DF: '要嵌入到.LLVM.command.line节中的字符串'
# 'The string to embed in the Dwarf debug AT_producer record.'
H309333DFFAC0: '要嵌入到DWARF调试AT_producer记录中的字符串'
# 'The string to embed in the Dwarf debug flags record.'
H8A887C2C292E: '要嵌入到DWARF调试标志记录中的字符串'
# 'The style name used for reformatting.'
H6C1DBF661954: '用于代码格式化的样式名称。'
# 'The style name used for reformatting. Default is "llvm"'
H6E46319C3C34: '用于代码格式化的样式名称。默认值为 "llvm"'
# 'The summary file to use for function importing.'
H956C0535484D: '用于函数导入的摘要文件。'
# 'The target Objective-C runtime supports ARC weak operations'
HDFF376EEF6B3: '目标Objective-C运行时支持ARC弱操作'
# 'The text prefix to use for cold basic block clusters'
H9A41E3E09F36: '用于冷基本块簇的文本前缀'
# "The thread model to use. Defaults to 'posix')"
HBBA4CDE4A320: "使用的线程模型. Defaults to 'posix)"
# 'The threshold (unit M) for flushing LLVM bitcode.'
H38AA697B02D6: 'LLVM比特码刷新的阈值（单位M）。'
# 'The threshold for fast cluster'
HC068F875B090: '快速聚类的阈值'
# 'The threshold for splitting a virtual register with a hint, in percentage'
H722FAD4D0C5E: '根据提示拆分虚寄存器的百分比阈值'
# 'The threshold the lifetime access density (accesses per byte per lifetime sec) must be under to consider an allocation cold'
HDA979A1E26A3: '分配被判定为冷数据时，生命周期访问密度阈值（每生命周期秒每字节的访问次数）必须低于的值'
# 'The type of aggregation to do on call stacks.'
H148D7C9D6F12: '对调用堆栈执行的聚合类型。'
# 'The type of output desired'
HD9FFCDBCB5F5: '期望的输出类型'
# 'The upper bound of size growth limit for proirity-based sample profile loader inlining.'
H4AEDA738C805: '基于优先级的样本配置文件加载器内联的大小增长上限。'
# 'The upper limit of II in the window algorithm.'
H6259F5DF8819: '窗口算法中II的上限值。'
# 'The value specified in simdlen must be a power of 2 when targeting Advanced SIMD.'
HAAC03787F717: 'simdlen指定的值在针对Advanced SIMD目标时必须是 2 的幂。'
# 'The vectorization factor for byte-compare patterns.'
H892AED0C291C: '字节比较模式的向量化因子。'
# 'The vectorization style for loop idiom transform.'
HEB4892D4C0B2: '循环惯用法转换的向量化风格。'
# 'The version of darwin target variant SDK used for compilation'
H11C241DE938D: '用于编译的darwin目标变体SDK版本'
# 'The version of target SDK used for compilation'
H4C1FC7BD91CD: '用于编译的目标SDK版本'
# 'The visibility for definitions without an explicit DLL storage class. If Keep is specified the visibility is not adjusted [-fvisibility-from-dllstorageclass]'
H5B42685299F4: '未显式指定DLL存储类的定义的可见性。如果指定Keep，则不调整可见性 [-fvisibility-from-dllstorageclass]'
# 'The visibility for dllexport definitions. If Keep is specified the visibility is not adjusted [-fvisibility-from-dllstorageclass]'
H89FA30D717F3: 'dllexport定义的可见性。如果指定Keep，则不调整可见性 [-fvisibility-from-dllstorageclass]'
# 'The visibility for dllimport external declarations. If Keep is specified the visibility is not adjusted [-fvisibility-from-dllstorageclass]'
H67F478EEEC59: 'dllimport外部声明的可见性。如果指定Keep，则不调整可见性 [-fvisibility-from-dllstorageclass]'
# 'The visibility for external declarations without an explicit DLL storage class. If Keep is specified the visibility is not adjusted [-fvisibility-from-dllstorageclass]'
H64D964A1CD05: '未显式指定DLL存储类的外部声明的可见性。如果指定Keep，则不调整可见性 [-fvisibility-from-dllstorageclass]'
# "The visibility for global C++ operator new and delete declarations. If 'source' is specified the visibility is not adjusted"
H9A7A28615088: '全局C++ operator new和delete声明的可见性。如果指定 "source"，则不调整可见性'
# 'The weight of backward jumps for ExtTSP value'
H0E7F2365F191: 'ExtTSP值中后向跳转的权重'
# 'The weight of conditional backward jumps for ExtTSP value'
H1A51FA791B5C: 'ExtTSP值中条件后向跳转的权重'
# 'The weight of conditional fallthrough jumps for ExtTSP value'
H17243DA21A4A: 'ExtTSP值中条件穿透跳转的权重'
# 'The weight of conditional forward jumps for ExtTSP value'
H37AE1F715474: 'ExtTSP值中条件前向跳转的权重'
# 'The weight of unconditional backward jumps for ExtTSP value'
HF65A2E202044: 'ExtTSP值中无条件后向跳转的权重'
# 'The weight of unconditional fallthrough jumps for ExtTSP value'
HAE55A03F6662: 'ExtTSP值中无条件穿透跳转的权重'
# 'The weight of unconditional forward jumps for ExtTSP value'
HAB44DC9D2D01: 'ExtTSP值中无条件前向跳转的权重'
# 'These control extra attributes that are added when the element is printed.'
HB2159F65700A: '这些控制打印元素时添加的额外属性。'
# 'These control how the elements are printed.'
H28147009F248: '这些控制元素的打印方式。'
# 'These control the generated warnings.'
H7F9E68DBF772: '这些控制生成的警告。'
# 'These control the output generated.'
HFE9BA932DCA9: '这些控制生成的输出。'
# 'These control the view comparison.'
H014A13BA2172: '这些控制视图比较。'
# 'These control which elements are printed.'
H47E80A7E5CE7: '这些控制打印哪些元素。'
# 'These control which elements are selected.'
H093D8C9A169D: '这些控制选择哪些元素。'
# 'These control which sections are dumped. Where applicable these parameters take an optional =<offset> argument to dump only the entry at the specified offset.'
H4A05AC913F89: '这些控制要转储的部分。如适用，这些参数可选带 =<偏移量> 参数以仅转储指定偏移量处的条目。'
# 'ThinLink: produces the index by linking only the summaries.'
H0F627A52D002: 'ThinLink：仅通过链接摘要生成索引。'
# "This appends the content hash to the globally outlined function name. It's beneficial for enhancing the precision of the stable hash and for ordering the outlined functions."
H53B60C3E684B: '此功能将内容哈希附加到全局外联函数名称。这有助于提高稳定哈希的精确性，并对排列外联函数有帮助。'
# 'This argument does not take a value.\n\tInstead, it consumes any positional arguments until the next recognized option.'
H3C3E5BFE7ADE: '此参数不接受值。\n\t相反，它会消耗后续的所有位置参数直到遇到下一个识别的选项。'
# 'This checks if there is a fdo instr. profile hash mismatch for this function'
HFBA287CE45D4: '检查此函数的FDO插桩剖面哈希是否匹配'
# 'This compilation is part of building a PCH with corresponding object file.'
H26F9EC33106E: '此编译是构建带有对应目标文件的PCH的一部分。'
# 'This flag controls the behaviour of fcmp equality comparisons.For equality comparisons such as `x == 0.0f`, we can perform the '
HF143A3F023BD: '此标志控制fcmp相等比较的行为。对于类似`x == 0.0f`的相等比较，我们可以执行'
# 'This is the default. TOC data transformation is not applied to any variables. Only variables specified explicitly in -mtocdata= will have the TOC data transformation.'
HEF7B686F6202: '这是默认设置。TOC数据转换不会应用于任何变量。仅在-mtocdata=中显式指定的变量会应用TOC数据转换。'
# 'This option is for testing purposes only. It forces BOLT to convert low_pc/high_pc to ranges always.'
H46D236F6D0BE: '此选项仅用于测试目的。它强制BOLT始终将low_pc/high_pc转换为范围。'
# "Thread pointer access method. For AArch32: 'soft' uses a function call, or 'tpidrurw', 'tpidruro' or 'tpidrprw' use the three CP15 registers. 'cp15' is an alias for 'tpidruro'. For AArch64: 'tpidr_el0', 'tpidr_el1', 'tpidr_el2', 'tpidr_el3' or 'tpidrro_el0' use the five system registers. 'elN' is an alias for 'tpidr_elN'."
H7A1A2BC28705: '线程指针访问方法。对于AArch32："soft" 使用函数调用，或 "tpidrurw"、"tpidruro" 或 "tpidrprw" 使用三个CP15寄存器。"cp15" 是 "tpidruro" 的别名。对于AArch64："tpidr_el0"、"tpidr_el1"、"tpidr_el2"、"tpidr_el3" 或 "tpidrro_el0" 使用五个系统寄存器。"elN" 是 "tpidr_elN" 的别名。'
# 'Threshold (in bytes) for the runtime check guarding the memmove.'
HD35FCD3FC79E: '运行时检查memmove的阈值（以字节为单位）'
# 'Threshold (in bytes) to perform the transformation, if the runtime loop count (mem transfer size) is known at compile-time.'
H1AD5098411FA: '若运行时循环计数（内存传输大小）在编译时已知，执行转换的阈值（以字节为单位）'
# 'Threshold (max size of unrolled loop) to use in aggressive (O3) optimizations'
H18A6C6D55082: '激进（O3）优化中使用的最大展开循环大小阈值'
# 'Threshold for hot callsites '
H362D13EBB118: '热点调用点的阈值 '
# 'Threshold for inlining addition operands into a SCEV'
HB303871617D0: '将表达式内联到SCEV中的内联添加操作数阈值'
# 'Threshold for inlining cold callsites'
H250BE680BE10: '冷调用点的内联阈值'
# 'Threshold for inlining functions with cold attribute'
H574FD1578D90: '带有 cold 属性的内联函数的阈值'
# 'Threshold for inlining functions with inline hint'
H393692A6F6FF: '带有 inline 建议的内联函数的阈值'
# 'Threshold for inlining multiplication operands into a SCEV'
H07C5BF953E30: '将乘法操作数内联到 SCEV 的阈值'
# 'Threshold for locally hot callsites '
H1A9D72E0CF73: '本地热点调用点的阈值'
# 'Threshold for partial unrolling'
H6543FABE0767: '部分展开的阈值'
# 'Threshold for switching to iteratively computing SCEV ranges'
H887AD3A95DC6: '切换为迭代计算 SCEV 范围时的阈值'
# 'Threshold for the size of CSUses'
H30C9036D7937: 'CSUses 的大小阈值'
# 'Threshold for triggering vextract replacement'
HF1A005DB3C4F: '触发 vextract 替换的阈值'
# 'Threshold to use for inner loop when doing unroll and jam.'
HE4FFB8758E97: '展开并合并时内部循环使用的阈值'
# 'Thumb IT blocks insertion pass'
HD5E87C90A3F2: 'Thumb IT块插入阶段'
# 'Thumb2 instruction size reduce pass'
HDFB1F7BB57C2: 'Thumb2指令大小缩减pass'
# 'Tile Copy Lowering'
HD512AA776C9C: 'Tile复制降低'
# 'Tile Register Configure'
HE55B620CE39A: 'Tile 寄存器配置'
# 'Tile Register Pre-configure'
H093374BD2768: 'Tile寄存器预配置'
# 'Tile size for matrix instruction fusion using square-shaped tiles.'
H77BEE628E9E0: '使用方形块的矩阵指令融合的块大小'
# 'Tilikum Crossing Optimizer\n'
H56081A939218: 'Tilikum Crossing 优化器\n'
# 'Time each pass run, printing elapsed time for each run on exit'
H9DEAE5CE8A5D: '计时每个 pass 的运行，并在退出时打印每个运行的耗时'
# 'Time each pass, printing elapsed time for each on exit'
H6752B4F3ED5A: '计时每个 pass，并在退出时打印每个的耗时'
# 'Time individual commands'
H84A9CD566359: '统计各命令的耗时'
# 'Time phases of parser and backend'
HC89B41C0C2D0: '计时解析器和后端的各个阶段'
# 'Time to be used in __DATE__, __TIME__, and __TIMESTAMP__ macros'
H972ECB48D75B: '__DATE__、__TIME__和__TIMESTAMP__宏中使用的时区'
# 'Time when the current build session started'
H702F4D424F4D: '当前构建会话启动时的时区'
# 'Tiny code model'
H84F95E67A022: '精简代码模型'
# 'Tool Options'
HCB6E15CE20D4: '工具选项'
# 'Tool options'
H6AA40067A445: '工具选项'
# 'Tool used for detecting AMD GPU arch in the system.'
HF986F57FE389: '用于检测系统中AMD GPU架构的工具。'
# 'Tool used for detecting NVIDIA GPU arch in the system.'
H3CE78A0FD186: '用于检测系统中NVIDIA GPU架构的工具。'
# 'Toolchain identification name.'
H577F665D266E: '工具链标识名称。'
# 'Toplevel siblings divisor for cost multiplier.'
H47B1D12D6302: '顶层同级节点的开销乘数除数'
# 'Total samples cutoff for functions used to calculate profile density.'
H4F0CF57C68FB: '用于计算剖面密度的函数总样本数阈值'
# 'Total size of all blocks (including zero-fill) in all graphs (post-fixup)'
HA9F2ACABE207: '所有图（后修复）中所有块（包括零填充）的总大小'
# 'Total size of all blocks (including zero-fill) in all graphs (pre-pruning)'
H33F7C5E01044: '所有图（前剪枝）中所有块（包括零填充）的总大小'
# 'Trace global value placement'
H3F11F16F204E: '跟踪全局值的放置'
# 'Trace the hash of the function with this name.'
H2FA3F2871F69: '跟踪具有此名称的函数的哈希值'
# 'Traces to enable.'
H5DD3783FD8E4: '启用的跟踪选项'
# 'Tracing of CMP and similar instructions'
H46B2C1DD8A24: '跟踪CMP和其他类似指令'
# 'Tracing of DIV instructions'
H6C4B7FBBDB1C: '跟踪DIV指令'
# 'Tracing of GEP instructions'
H9495E0A41197: '跟踪GEP指令'
# 'Tracing of load instructions'
H9296E34AACB7: '跟踪加载指令'
# 'Tracing of store instructions'
HD37453D2BD66: '跟踪存储指令'
# 'Track failure strings in detecting scop regions'
HA2AAD146A60C: '在检测scop区域时跟踪失败字符串'
# 'Track origins (allocation sites) of poisoned memory'
H3D9C4DED10A1: '跟踪被污染内存的来源（分配点）'
# 'Track origins of labels'
H6DEEA7E74FFD: '跟踪标签的来源'
# 'Track reg pressure and switch priority to in-depth'
HD40E656EBBE9: '跟踪寄存器压力并将切换优先级改为深入'
# 'Track the overflow bit if requested.'
H6AA670469C83: '如果需要，则跟踪溢出位。'
# 'Training log for the register allocator eviction model'
H6E2B0424977E: '寄存器分配器驱逐模型的训练日志'
# 'Training log for the register allocator priority model'
HDBA649A1B080: '寄存器分配器优先级模型的训练日志'
# 'Transform functions to use DSP intrinsics'
H926BA6FE32A4: '转换函数以使用DSP内建函数'
# "Transitional flag to turn off NVPTX's requirement on preserving structured CFG. The requirement should be disabled only when unexpected regressions happen."
H280C497E1DC8: '过渡标志，用于关闭NVPTX对保留结构化CFG的要求。仅在出现意外退化时才应禁用此要求。'
# 'Translations to perform'
HD6F4D5A5B7BD: '要执行的转换'
# 'Trap on integer division by zero.'
HDD1ADB807B39: '在整数除以零时触发陷阱。'
# 'Trap on integer overflow'
H912BF1C6F685: '整数溢出时触发陷阱'
# 'Trap when incorrect'
H9EC2646A38E0: '错误时触发陷阱'
# 'Treat <file> as C source file'
H5AAFC1A35AEE: '将 <file> 视为C源文件'
# 'Treat <file> as C++ source file'
H467B7FCAE3B7: '将 <file> 视为C++源文件'
# 'Treat INCLUDE lines like #include directives in -E mode'
H8BB5A80B42A6: '在-E模式下将INCLUDE行视为#include指令'
# 'Treat all #include paths starting with <prefix> as including a system header.'
H4CD79E350724: '将所有以 <prefix> 开头的#include路径视为包含系统头文件。'
# 'Treat all #include paths starting with <prefix> as not including a system header.'
H7FC347478B10: '将所有以 <prefix> 开头的#include路径视为不包含系统头文件。'
# 'Treat all parameters to functions that are pointers as dereferencible. This is useful for invariant load hoisting, since we can generate less runtime checks. This is only valid if all pointers to functions are always initialized, so that Polly can choose to hoist their loads. '
H01E314D59C27: '将函数的所有指针参数视为可解引用的。这对于不变量加载提升很有用，因为可以生成更少的运行时检查。只有当所有指向函数的指针始终被初始化时，Polly才能选择提升它们的加载操作。'
# 'Treat all source files as C'
H55FA85BDA2A5: '将所有源文件视为C语言'
# 'Treat all source files as C++'
H7EEC5BB50052: '将所有源文件视为C++语言'
# 'Treat any <pattern> strings as regular expressions when selecting instead of just as an exact string match.'
HB8CFB19C5C18: '在选择时将任何 <pattern> 字符串视为正则表达式，而不是精确字符串匹配。'
# 'Treat each comma separated argument in <arg> as a documentation comment block command'
HCB49DF1FFB5A: '将 <arg> 中的每个逗号分隔的参数视为文档注释块命令'
# 'Treat editor placeholders as valid source code'
H5F226C718000: '将编辑器占位符视为有效源代码'
# "Treat fixed form lines with 'd' or 'D' in the first column as blank."
HADC0D4FE88CA: "将固定格式中首列有 'd' 或 'D' 的行视为空白行。"
# "Treat fixed form lines with 'd' or 'D' in the first column as comments."
H3F2B7A8C2293: "将固定格式中首列有 'd' 或 'D' 的行视为注释。"
# 'Treat hip and hipv4 offload kinds as compatible with openmp kind, and vice versa.\n'
HC9954ACD9B9E: '将hip和hipv4 offload类型视为与openmp类型兼容，反之亦然。\n'
# 'Treat input as a PDB file (default)'
H24602D862E82: '将输入视为PDB文件（默认）'
# 'Treat input as raw contents of /names named stream'
H2F74766FAAE9: '将输入视为/names命名流的原始内容'
# 'Treat input as raw contents of DBI stream'
H56798B0B0190: '将输入视为DBI流的原始内容'
# 'Treat input as raw contents of PDB stream'
H6E74D779FAE8: '将输入视为PDB流的原始内容'
# 'Treat input as raw contents of a module stream'
H720BDBA3C128: '将输入视为模块流的原始内容'
# 'Treat issues where a fixed-width property is requested from a scalable type as a warning, instead of an error'
HE3ED92F98BA0: '将从可扩展类型请求固定宽度属性的问题视为警告，而不是错误'
# "Treat pointer overflow as two's complement"
HF00886F33282: '将指针溢出视为补码形式'
# "Treat signed integer overflow as two's complement"
H1BAF0BBFDBF6: '将有符号整数溢出视为补码形式'
# 'Treat source input files as Objective-C inputs'
H10D7DE6018B0: '将源输入文件视为Objective-C输入'
# 'Treat source input files as Objective-C++ inputs'
HF4443D8F9187: '将源输入文件视为Objective-C++输入'
# 'Treat stack lifetimes as starting on first use, not on START marker.'
H1D5DFE08E7A8: '将栈生命周期的起始点视为首次使用，而不是START标记。'
# 'Treat string literals as const'
H79E1F4486D77: '将字符串字面量视为const类型'
# 'Treat subsequent input files as having type <language>'
HC2DB15026570: '将后续输入文件视为具有类型 <language>'
# 'Treat the given module as-if it were containing the post-thinlink module containing the root'
H678738B3F81B: '将给定模块视为经过薄链接后的根模块'
# 'Treat usage of null pointers as undefined behavior (default)'
HEF76E5F5F913: '将空指针的使用视为未定义行为（默认）'
# 'Treat warnings as errors'
H518C417B2786: '将警告视为错误'
# 'Trim cold functions until profile size is below specified limit in bytes. This uses a heursitic and functions may be excessively trimmed'
H9C86C77C9C88: '修剪冷函数，直到配置文件大小低于指定的字节限制。这使用了一种启发式方法，可能导致函数被过度修剪'
# 'Trim context sample profiles whose count is below cold threshold'
HD98B893B0D67: '修剪计数低于冷阈值的上下文采样配置文件'
# 'Triple default EABI version'
H929ED20C3916: '三元组默认EABI版本'
# 'Triple to use to serialize to cubin.'
HCE48A7F9471E: '用于序列化到cubin的目标三元组'
# 'Try emitting Compact-Unwind for non-canonical entries. Maybe overridden by other constraints'
H3E74499232A9: '尝试为非常量条目生成紧凑的展开信息。可能被其他约束条件覆盖'
# 'Try hoisting constant gep expressions'
HEBF48C3AF674: '尝试提升常量gep表达式'
# 'Try to avoid heapifying local blocks'
HD9B64861AC5A: '尝试避免堆化本地块'
# 'Try to avoid reuse of byte array addresses using aliases'
HD4627CAE2B4C: '尝试使用别名避免重复使用字节数组地址'
# 'Try to construct schedules where the outer member of each band satisfies the coincidence constraints (yes/no)'
H60DF39720CB5: '尝试构建每个带的外层成员满足重合约束的调度（是/否）'
# 'Try to delinearize array references.'
H2EA0163561FB: '尝试解除数组引用的线性化'
# 'Try to evenly distribute flow when there are multiple equally likely options.'
HAEBC34FD2276: '当存在多个可能性相等的选项时，尝试均匀分配流程'
# 'Try to map `do concurrent` loops to OpenMP [none|host|device]'
H0998E6C983F8: '尝试将`do concurrent`循环映射到OpenMP [none|host|device]'
# 'Try to propagate nonnull argument attributes from callsites to caller functions.'
H020E4D562B19: '尝试将调用点的nonnull参数属性传播到被调函数'
# 'Try to simplify all loads.'
HBDC33CA86746: '尝试简化所有加载操作'
# 'Try to vectorize with non-power-of-2 number of elements.'
H0125A5F09D1C: '尝试使用非 2 的幂次元素数量进行向量化'
# 'Try wider VFs if they enable the use of vector variants'
H26EA4E292B56: '如果可以使用向量变体，则尝试更宽的VFs'
# 'Tune debug info for a particular debugger'
H77BC7AA0BB02: '为特定调试器调整调试信息'
# 'Tune for a specific cpu type'
H3345FF3520DA: '针对特定CPU类型进行优化'
# 'Turn all knobs to 11'
H1AC91DEDAC4E: '将所有选项调至最大（11）'
# 'Turn fastcc calls into tail calls by (potentially) changing ABI.'
HF62148DE9C4D: '通过（可能）更改ABI将fastcc调用转换为尾调用'
# 'Turn off Type Based Alias Analysis'
H63440B325F63: '关闭基于类型的别名分析'
# 'Turn off loop unroller'
H0C19FC5B8215: '关闭循环展开优化'
# 'Turn off sparse parallelization.'
H32757C1F23A6: '关闭稀疏并行化。'
# 'Turn off struct-path aware Type Based Alias Analysis'
H8E0ED82C6CEB: '关闭支持结构体路径的基于类型别名分析'
# 'Turn off window algorithm.'
H6D475479FF1D: '关闭窗口算法。'
# 'Turn on DominatorTree and LoopInfo verification after Loop Distribution'
H14C9F8E485D6: '在循环分布后启用DominatorTree和LoopInfo验证'
# 'Turn on loop unroller'
H189401528396: '启用循环展开器'
# 'Turn on module map output and specify output path or file name. If no path is specified and if prefix option is specified, use prefix for file path.'
H6B0988247E72: '启用模块映射输出并指定输出路径或文件名。如果没有指定路径且指定了前缀选项，则使用前缀作为文件路径'
# 'Turn on runtime checks for various forms of undefined or suspicious behavior. See user manual for available checks'
H44BD445B1D2C: '启用针对各种未定义或可疑行为的运行时检查。请参阅用户手册以获取可用的检查项'
# 'Turn on time profiler. Generates JSON file based on output filename.'
H605BD513ED60: '启用时间分析器。根据输出文件名生成JSON文件。'
# 'Turns on stale matching with block pseudo probes.'
HFFCF05795EA6: '启用块伪探测的过时匹配'
# 'Two-Address instruction pass'
HD8164AEBCCB3: '双地址指令pass'
# 'Type Options'
H7C8D98E334E0: '类型选项'
# 'Type Promotion'
H4F87D1DD8D47: '类型提升'
# 'Type Record Options'
H979D586C9237: '类型记录选项'
# 'Type definition.'
H37A26D2D1A2C: '类型定义。'
# 'Type kind to use when printing types.'
H3F4786926275: '打印类型时使用的类型种类'
# 'Type of checking for incorrect devirtualizations'
HB2F8536F04B5: '虚函数静态化错误检查的类型'
# 'Type of symbols to dump (default all)'
HDEE9A9BDCFC8: '要转储的符号类型（默认全部）'
# 'Type of the files to be bundled/unbundled.\nCurrent supported types are:\n  i    - cpp-output\n  ii   - c++-cpp-output\n  cui  - cuda-cpp-output\n  hipi - hip-cpp-output\n  d    - dependency\n  ll   - llvm\n  bc   - llvm-bc\n  s    - assembler\n  o    - object\n  a    - archive of objects\n  gch  - precompiled-header\n  ast  - clang AST file'
H23DE32DB4F4F: '要捆绑/解捆的文件类型。\n当前支持的类型包括：\n  i    - cpp输出\n  ii   - c++-cpp输出\n  cui  - cuda-cpp输出\n  hipi - hip-cpp输出\n  d    - 依赖项\n  ll   - llvm\n  bc   - llvm-bc\n  s    - 汇编\n  o    - 对象\n  a    - 对象的归档\n  gch  - 预编译头\n  ast  - clang AST 文件'
# 'Type sizes.'
H42125920C0CF: '类型大小。'
# 'Type-Based Alias Analysis'
H432902366273: '基于类型别名分析'
# 'Types (Pointer, Reference, etc.).'
H09ADEF8BEED1: '类型（指针、引用等）。'
# 'Types.'
H1145E1A9F2E2: '类型。'
# 'UNKOWN'
HD91DF451ADF1: '未知'
# 'USAGE: '
H4060E2625813: '用法： '
# 'Unbundle bundled file into several output files.\n'
H1DD69F0F0D6F: '将捆绑文件解捆为多个输出文件。\n'
# 'Unconditionally apply unchecked-ld-st optimization (even for large stack frames, or in the presence of variable sized allocas).'
H26BF316F7B25: '强制应用 unchecked-ld-st 优化（即使在大型栈帧或存在变量大小的alloca时）'
# 'UndName Options'
H2ACB6A59624D: 'UndName 选项'
# 'Undefine macro'
H85ECFBA229C4: '取消定义宏'
# 'Undefine macro <macro>'
HE9FB0C5A98C8: '取消定义宏 <macro>'
# 'Undefined / no particular sort order'
H2DF8FA5D8D5C: '未定义/无特定排序顺序'
# 'Undefines the __DEPRECATED macro'
HFAB714AB2388: '取消定义 __DEPRECATED 宏'
# 'Underlying type for type definitions.'
HE810C104AEFC: '类型定义的底层类型'
# 'Unexpected vftable component type %0 for component number %1'
H40151C08E668: '组件号 %1 的vftable组件类型 %0 意外'
# 'Uniformity Analysis'
H18CD82918982: '统一性分析'
# 'Unify divergent function exit nodes'
H8B72079558B4: '统一发散函数退出节点'
# 'Unify function instantiations'
H7D11BF20733C: '统一函数实例化'
# 'Unify multiple OpenCL metadata due to linking'
H1E880963D2AC: '合并链接导致的多个OpenCL元数据'
# 'Union.'
H8AC81596AB6F: '联合体。'
# 'Uniqueify Internal Linkage Symbol Names by appending the MD5 hash of the module path'
HE20B29760EEF: '通过附加模块路径的MD5哈希来唯一化内部链接符号名称'
# 'Unpack machine instruction bundles'
H6975BC91D598: '解包机器指令包'
# 'Unparse and stop (skips the semantic checks)'
HB65257706E07: '反编译并停止（跳过语义检查）'
# 'Unparse and stop.'
H8A6570E46B2D: '反编译并停止。'
# 'Unparse with dependent modules and stop.'
HDFEBDFAE4C78: '与依赖模块一起反编译并停止。'
# 'Unparse with symbols and stop.'
H0D9F89477381: '带符号反编译并停止。'
# 'Unroll factor (affecting 4x32-bit operations) to use for memory operations when lowering memcpy as a loop'
HE43C43B147A4: '将 memcpy 作为循环展开时，用于内存操作的展开因子（影响 4x32位操作）'
# 'Unroll loops'
H14907BD20FBA: '展开循环'
# 'Unroll loops with run-time trip counts'
H094122EA378B: '展开具有运行时循环次数的循环'
# 'Unroll threshold for AMDGPU if local memory used in a loop'
H9E766FE7E2B8: 'AMDGPU中循环使用局部内存时的展开阈值'
# 'Unroll threshold for AMDGPU if private memory used in a loop'
HAC396B9BAD8B: 'AMDGPU中循环使用私有内存时的展开阈值'
# 'Unroll threshold increment for AMDGPU for each if statement inside loop'
H93579CFAA697: 'AMDGPU中循环内每包含一个if语句时的展开阈值增量'
# 'Unrolled size limit for loops with an unroll(full) or unroll_count pragma.'
H455348AAE5AE: '使用unroll(full)或unroll_count pragma的循环展开的大小限制'
# 'Unrolled size limit for loops with an unroll_and_jam(full) or unroll_count pragma.'
H83703E1D1FC8: '使用unroll_and_jam(full)或unroll_count pragma的循环展开的大小限制'
# 'Unspecified parameter.'
H12B0F3A3DD19: '未指定的参数。'
# 'Unspecified type.'
HEE55D6208E96: '未指定的类型。'
# 'Unwind library to use'
HAF3990494241: '使用的展开库'
# 'Uop Decomposition'
H84228E8F31C8: 'Uop分解'
# 'Update pseudo probe distribution factor'
H95A61EF626F6: '更新伪探测分布因子'
# 'Update total samples by accumulating all its body samples.'
H4ABB921FD931: '通过累积所有函数体样本更新总样本数。'
# 'Use #line in preprocessed output'
H61A0DD59549D: '在预处理输出中使用 #line'
# "Use 'mips.ccmov' instruction"
HDC01AC60098B: "使用 'mips.ccmov' 指令"
# 'Use -compile-command to define a command to compile the bitcode. Useful to avoid linking.'
H45B889E18E9F: '使用 -compile-command 定义用于编译比特码的命令。有助于避免链接。'
# 'Use -exec-command to define a command to execute the bitcode. Useful for cross-compilation.'
HBBC97C4993AA: '使用 -exec-command 定义执行比特码的命令。适用于交叉编译。'
# 'Use .ctors instead of .init_array.'
HEFD53B18D4A2: '使用 .ctors 而非 .init_array。'
# 'Use .ctors/.dtors instead of .init_array/.fini_array'
H89195E513795: '使用 .ctors/.dtors 而非 .init_array/.fini_array'
# 'Use .file directives with an explicit directory'
H9DEC86EE53C8: '使用带有显式目录的 .file 指令'
# 'Use 16-bit hardware multiplier'
HE39242B4C409: '使用 16 位硬件乘法器'
# 'Use 32-bit floating point registers (MIPS only)'
HE9E46E3267C7: '使用 32 位浮点寄存器（仅MIPS）'
# 'Use 32-bit hardware multiplier'
H48A0735D6EC9: '使用 32 位硬件乘法器'
# 'Use 32-bit pointers for accessing const/local/shared address spaces'
HEBB1FFB0999C: '使用 32 位指针访问const/local/shared地址空间'
# 'Use 32-bit pointers for accessing const/local/shared address spaces.'
H1C423A27FAD4: '使用 32 位指针访问 const/local/shared 地址空间。'
# 'Use 64-bit floating point registers (MIPS only)'
H4492AB59FFA0: '使用 64 位浮点寄存器（仅MIPS）'
# 'Use <dumpfpx> as a prefix to form auxiliary and dump file names'
H3DFDBA26A67C: '使用 <dumpfpx> 作为辅助和转储文件名的前缀'
# 'Use <suffix> as the suffix for module files (the default value is `.mod`)'
H0754CF14DB5E: '使用 <suffix> 作为模块文件的后缀（默认值为 `.mod`）'
# 'Use <value> as character line width in fixed mode'
HAF90606EAD0C: '在固定模式下使用 <value> 作为字符行宽'
# 'Use ANSI escape codes for diagnostics'
HF4E88E8746F8: '为诊断信息使用ANSI转义码'
# "Use Apple's kernel extensions ABI"
H707C74B2A986: '使用Apple的内核扩展ABI'
# 'Use CREL relocation format for ELF'
H01BA06F9BEE0: '为 ELF 使用 CREL 重定位格式'
# "Use ConstantFP's native fixed-length vector splat support."
H45D6CB612C50: '使用 ConstantFP 的原生固定长度向量展平支持。'
# "Use ConstantFP's native scalable vector splat support."
H019F3DB4B516: '使用 ConstantFP 的原生可扩展向量展平支持。'
# "Use ConstantInt's native fixed-length vector splat support."
HEE201C750BB5: '使用ConstantInt的原生固定长度向量扩展支持。'
# "Use ConstantInt's native scalable vector splat support."
H205BD3049DE6: '使用ConstantInt的原生可扩展向量扩展支持。'
# 'Use DLL debug run-time'
H09CE8A3B2FF2: '使用DLL调试运行时'
# 'Use DLL run-time'
HFFC5F85F16E2: '使用DLL运行时'
# 'Use DPP operations for scan'
HA25C31D46A88: '使用 DPP 操作进行扫描'
# 'Use DWARF base address selection entries in .debug_ranges'
H785682C5C939: '在.debug_ranges中使用DWARF基地址选择条目'
# 'Use DWARF style exceptions'
H37CB53594E9C: '使用DWARF风格异常'
# 'Use Decision Forest model to rank completion items'
H05DCA5EC7686: '使用决策森林模型对完成项进行排序'
# 'Use EH-safe code when synthesizing retains and releases in -fobjc-arc'
H36FC7089F28D: '在-fobjc-arc合成retain和release时使用异常处理安全代码'
# 'Use F5 series hardware multiplier'
H2733E473C4B3: '使用 F5 系列硬件乘法器'
# 'Use GC exclusively for Objective-C related memory management'
H2B28F501A8B5: '专用于Objective-C相关内存管理时仅使用GC'
# "Use GCC installation in the specified directory. The directory ends with path components like 'lib{,32,64}/gcc{,-cross}/$triple/$version'. Note: executables (e.g. ld) used by the compiler are not overridden by the selected GCC installation"
HA7E84A833041: "使用指定目录中的GCC安装。该目录包含类似 'lib{,32,64}/gcc{,-cross}/$triple/$version' 的路径组件。注意：编译器使用的可执行文件（例如ld）不会被选定的GCC安装覆盖"
# 'Use GCNDownwardRPTracker for GCNRegPressurePrinter pass'
HC666D46EACA0: '为GCNRegPressurePrinter pass使用GCNDownwardRPTracker'
# 'Use GOT indirection instead of PLT to make external function calls (x86 only)'
H813651BE1DF2: '使用GOT间接寻址代替PLT进行外部函数调用（仅x86）'
# 'Use GOT indirection to reference external data symbols'
H9C63E198FEC5: '使用GOT间接寻址引用外部数据符号'
# 'Use GP relative accesses for symbols known to be in a small data section (MIPS)'
H16E3D5EA2597: '使用GP相对寻址访问已知位于小数据区的符号（MIPS）'
# 'Use GPR indexing mode instead of movrel for vector indexing'
H65B8C362AD34: '使用GPR索引模式而非movrel进行向量索引'
# 'Use GlobalISel desired legality, rather than try to userules compatible with selection patterns'
HCD3F9F572B30: '使用GlobalISel的预期合法性，而非尝试使用与选择模式兼容的规则'
# 'Use HLFIR lowering (experimental)'
HBF33CE828D70: '使用HLFIR降级（实验性）'
# 'Use IEEE 754 quadruple-precision for long double'
H52864CA1A557: '使用IEEE 754 四倍精度表示long double'
# 'Use IEEE Compliant F32 div.rnd if available (default)'
H2BB28E9D2AB7: '使用可用的IEEE兼容F32 div.rnd（默认）'
# 'Use IEEE Compliant F32 div.rnd if available, no FTZ'
HBC0417BA3204: '使用可用的IEEE兼容F32 div.rnd（若存在），无FTZ'
# 'Use INTEGER(KIND=8) for the result type in size-related intrinsics'
H31BCF654D576: '在与尺寸相关的内建函数中使用INTEGER(KIND=8)作为结果类型'
# 'Use InstrItineraryData for latency lookup'
HE819C1D764CF: '使用InstrItineraryData进行延迟查找'
# 'Use Intel MCU ABI'
H047785ECB956: '使用Intel MCU ABI'
# 'Use Iterative approach for scan'
HB2B560B747FE: '使用迭代方法进行扫描'
# 'Use JSON as the output format.'
H22CC5D346911: '使用 JSON 作为输出格式。'
# 'Use LFENCE along each conditional edge to harden against speculative loads rather than conditional movs and poisoned pointers.'
H417B6B21B3DF: '在每个条件边中使用LFENCE来防御推测性加载，而非条件mov和中毒指针。'
# 'Use LLJITGenericIRPlatform'
H25BF0FFFB5D6: '使用 LLJITGenericIRPlatform'
# 'Use LLVM-IR names when deriving statement names'
H7614196F2CF1: '在推导语句名称时使用LLVM-IR名称'
# 'Use LLVM/Offload as portable offloading runtime.'
HE33C03962BCE: '使用LLVM/Offload作为可移植的offloading运行时。'
# 'Use MD5 for file checksums in debug info (default)'
H96424B977A6D: '在调试信息中使用MD5进行文件校验（默认）'
# 'Use ML.'
HFB1C0C51C398: '使用 ML。'
# 'Use NMake/Jom format for the depfile'
H2770540BA1FF: '在depfile中使用NMake/Jom格式'
# 'Use ORC runtime from given path'
H0B3C6C26BF5D: '使用给定路径的ORC运行时'
# 'Use SEH style exceptions'
HF73D39350799: '使用SEH风格的异常'
# 'Use SHA1 for file checksums in debug info'
H18018B318301: '在调试信息中使用SHA1进行文件校验和'
# 'Use SHA256 for file checksums in debug info'
HF98F43EAE9BB: '在调试信息中使用SHA256进行文件校验和'
# 'Use Section instead of __patchable_function_entries'
H2F6710F2BEEF: '使用Section代替__patchable_function_entries'
# 'Use SjLj style exceptions'
H44AA3EF8F7F8: '使用SjLj风格的异常处理'
# 'Use Stable Hashing for MIR VReg Renaming'
H093C21DF7C9E: '使用稳定哈希进行MIR虚拟寄存器重命名'
# 'Use Stack Safety analysis results'
HCE2D7641DBD9: '使用堆栈安全性分析结果'
# 'Use StructurizeCFG IR pass'
HA25675EEF575: '使用StructurizeCFG IR pass'
# 'Use TLS'
HF5C26334C370: '使用 TLS'
# 'Use TargetSchedModel for latency lookup'
HC9F59D7F1E0C: '使用TargetSchedModel进行延迟查找'
# 'Use TargetTransformInfo::getInstructionCost'
H4974E1B043EE: '使用 TargetTransformInfo::getInstructionCost'
# 'Use TargetTransformInfo::getIntrinsicInstrCost'
H85A8617C4E16: '使用 TargetTransformInfo::getIntrinsicInstrCost'
# 'Use VP intrinsics'
H7B0B6BAFD1AA: '使用 VP 内建函数'
# 'Use WebAssembly style exceptions'
H0F092371B645: '使用WebAssembly风格的异常处理'
# 'Use a best-case representation method for member pointers'
H7AE6BEFD1C8A: '使用成员指针的最佳情况表示方法'
# 'Use a const qualified type for string literals in C and ObjC'
HBFF97FAA6C53: '在C和ObjC中为字符串字面量使用const限定类型'
# 'Use a diagnostic handler to test the handler interface'
H3C822F398929: '使用诊断处理程序来测试处理程序接口'
# 'Use a fake address space map; OpenCL testing purposes only'
H9DCA916816C8: '使用假地址空间映射；仅用于OpenCL测试目的'
# 'Use a free form text output.'
HA312842C43C5: '使用自由格式文本输出。'
# 'Use a full speculation fence to harden both call and ret edges rather than a lighter weight mitigation.'
H600ECC7683CF: '使用完整的推测屏障来强化调用和返回边，而非更轻量级的缓解措施。'
# 'Use a most-general representation for member pointers'
H0E7635ED3666: '使用成员指针的最通用表示方法'
# 'Use a rematerializable pseudoinstruction for 2 instruction constant materialization'
H3A40020AE1F7: '使用可重新生成的伪指令进行 2 条指令常量生成'
# 'Use a signed type for wchar_t'
H48F702933B27: '为wchar_t使用有符号类型'
# 'Use a single TBAA tree for all functions and do not use the FIR alias tags pass'
HC642932368D3: '为所有函数使用单一TBAA树，并不使用FIR别名标签pass'
# 'Use absolute paths for invoking subcommands (default)'
HFDEA884CA19F: '使用绝对路径调用子命令（默认）'
# 'Use addrx+offset extension form for any address with a prior base address'
H5B85C96D3B22: '对于具有先前基地址的任何地址，使用 addrx+offset 扩展形式。'
# 'Use all available analyses'
H8DB3578A8858: '使用所有可用的分析'
# 'Use all discriminator bits (default)'
H568FAF6786A5: '使用所有判别位（默认）'
# 'Use an unsigned type for wchar_t'
HE6D72C7A4E59: '为wchar_t使用无符号类型'
# 'Use approximate transcendental functions'
HC80164348ADD: '使用近似超越函数'
# 'Use arc callee save/restore functions'
HDC1738B5E10F: '使用arc调用者保存/恢复函数'
# 'Use atexit or __cxa_atexit to register global destructors'
HD6A435F1A848: '使用atexit或__cxa_atexit来注册全局析构函数'
# 'Use atomic fetch add for first counter in a function (usually the entry counter)'
HE1A472AB0CD6: '使用原子获取并增加操作处理函数中的首个计数器（通常是入口计数器）'
# 'Use base address specifiers in debug_ranges'
H16F9B262870C: '在debug_ranges中使用基地址指定符'
# 'Use base and pass 1 discriminators'
HFD9F1E3E9AB6: '仅使用基判别器和第 1 阶段判别器'
# 'Use base and pass 1-2 discriminators'
H8235CCC718A7: '使用基判别器和第 1-2阶段判别器'
# 'Use base and pass 1-3 discriminators'
HF4182389B253: '使用基判别器和第 1-3阶段判别器'
# 'Use base discriminators only'
HF3EBCD1C0036: '仅使用基判别器'
# 'Use best guess'
H868B8A8130DA: '使用最佳猜测'
# 'Use binary to correlate'
H72FD9C9D9781: '使用二进制进行关联'
# 'Use block frequency info to find successors to sink'
H76D3FF42212F: '使用块频率信息查找要下沉的后续节点'
# 'Use cache manager to save/load modules'
HA5972065E561: '使用缓存管理器保存/加载模块'
# 'Use call site prioritized inlining for sample profile loader. Currently only CSSPGO is supported.'
H91095FED309C: '为样本配置文件加载器使用调用站点优先联编。目前仅支持CSSPGO。'
# 'Use callback for max stack depth tracing with minimum stack depth M'
H90D68B59D6FC: '使用回调进行最大堆栈深度追踪，最小堆栈深度为M'
# 'Use callbacks instead of inline instrumentation sequences.'
H3EC6C04656EA: '使用回调而不是内联插桩序列。'
# 'Use callee size priority.'
H959C69EC2106: '使用被调用者大小优先级。'
# 'Use case-insensitive matching'
HCBB3CB058AC9: '使用不区分大小写的匹配'
# 'Use codegen data read from default.cgdata to optimize the binary'
HEFC973859186: '使用从default.cgdata读取的代码生成数据来优化二进制文件'
# 'Use codegen data read from the specified <path>.'
HA873FDC06A7F: '使用从指定 <path> 读取的代码生成数据'
# 'Use colors in detailed AST output. If not set, colors\nwill be used if the terminal connected to\nstandard output supports colors.'
H3428909B1528: '在详细的AST输出中使用颜色。如果没有设置，则在标准输出连接的终端支持颜色时使用颜色。'
# 'Use colors in output (default=autodetect)'
H036C59DCDCFA: '在输出中使用颜色（默认=自动检测）'
# 'Use column-major layout'
H798E10981CB2: '使用列优先布局'
# 'Use compact approach for aligning functions'
H53E4E0949D55: '使用紧凑方法对齐函数'
# 'Use compact branches where appropriate (default).'
HE80CC6815708: '在适当的位置使用紧凑分支（默认）。'
# 'Use compressed jump tables in Thumb-1 by synthesizing an equivalent to the TBB/TBH instructions'
H2165E804582A: '通过合成等效于TBB/TBH指令的代码，在Thumb-1中使用压缩跳转表'
# 'Use constructor homing if we are using limited debug info already'
H62F93DEE0ADD: '如果已使用有限的调试信息，则使用构造函数定位'
# 'Use context'
H3D56A8B500FF: '使用上下文'
# 'Use context-sensitive byte size cost for preinliner decisions'
H7FD64165B9B4: '为预内联决策使用上下文相关的字节大小成本'
# 'Use cost-benefit ratio.'
H9D7EE37E6691: '使用效益比。'
# 'Use debug info or binary file to correlate profiles.'
H2E074CAAD7C0: '使用调试信息或二进制文件关联配置文件。'
# 'Use debug info to correlate'
HEC4020684722: '使用调试信息进行关联'
# 'Use debug info to correlate profiles. (Deprecated, use -profile-correlate=debug-info)'
H3760EBF147CB: '使用调试信息关联配置文件。（已弃用，请使用-profile-correlate=debug-info）'
# 'Use debug-info or binary correlation to correlate profiles with build id fetcher'
HE51EAC7876DD: '使用调试信息或二进制关联与构建ID获取器关联配置文件'
# 'Use debuginfod to look up object files from profile'
HF7500F4663E6: '使用debuginfod从配置文件查找对象文件'
# 'Use default code inlining logic for the address sanitizer'
HB70EC9805527: '为地址sanitizer使用默认内联逻辑'
# 'Use development mode (runtime-loadable model)'
H1078C08F764F: '使用开发模式（运行时可加载模型）'
# 'Use directory as the C++ standard library include path'
H323DACFD356C: '将目录设置为C++标准库包含路径'
# 'Use distinct LTO pipelines'
H5CC3AC1C99CE: '使用不同的LTO流水线'
# 'Use div.approx'
H83DB5654E52E: '使用div.approx'
# 'Use div.full'
H982A66A56BFC: '请使用div.full'
# 'Use div.w[u] and mod.w[u] instructions with input not sign-extended.'
HCBB92DFD904B: '使用输入未符号扩展的div.w[u]和mod.w[u]指令'
# 'Use dot format instead of plain text when dumping VPlans'
HE98D975C012B: '在转储VPlans时使用dot格式而非纯文本'
# 'Use dwarf for profile correlation even when binary contains pseudo probe.'
HB77EAFFEBB88: '即使二进制文件包含伪探测，也使用DWARF进行配置文件关联'
# 'Use dynamic alloca to represent stack variables'
H0BD8D88B6D44: '使用动态alloca表示栈变量'
# 'Use emulated TLS model'
H1BBC4DA9A238: '使用模拟的TLS模型'
# 'Use emutls functions to access thread_local variables'
HF38CD5C8C963: '使用emutls函数访问thread_local变量'
# 'Use experimental new value-tracking variable locations'
H5A1E1B70E9BC: '使用实验性的新值跟踪变量位置'
# 'Use exprloc addrx+offset expressions for any address with a prior base address'
H8B37A6DB17E6: '对于具有先前基地址的任何地址，使用exprloc addrx+offset表达式'
# 'Use ext-tsp for size-aware block placement.'
H6EBF1A8427C5: '使用 ext-tsp 进行基于大小的块放置。'
# 'Use external machine object code emitter.'
H863F828BD310: '使用外部机器目标码生成器。'
# 'Use fast short rep mov in memcpy lowering'
H51A6C031B64D: '在 memcpy 降级时使用快速短 rep mov 指令'
# 'Use filesystem locks for implicit modules builds to avoid duplicating work in competing clang invocations.'
H0BC43223C7F4: '使用文件系统锁进行隐式模块构建，以避免在竞争clang调用中重复工作。'
# 'Use first loadable segment address as base address for offsets in unsymbolized profile. By default first executable segment address is used'
H4F1992DBF3B6: '使用可加载段的第一个地址作为未符号化配置文件中偏移量的基准地址。默认情况下使用第一个可执行段的地址'
# 'Use full module build paths in the profile counter names for static functions.'
H8EE12193DAD1: '在静态函数的性能计数器名称中使用完整的模块构建路径。'
# 'Use full register names when printing assembly'
HCA77C0C5AF9C: '打印汇编时使用完整的寄存器名称'
# 'Use full register names when writing assembly output'
H3BE94F5363AA: '在输出汇编代码时使用完整寄存器名称'
# 'Use global'
HB9509FD003D3: '使用全局'
# 'Use global constructors'
HF07EDAA4A037: '使用全局构造函数'
# 'Use global destructors'
HDD719F630B29: '使用全局析构函数'
# 'Use hardened lowering for jump-table dispatch'
H7DCC0D09290B: '使用强化的跳转表分派降低步骤'
# 'Use heuristics to rank code completion items'
HDEA303833606: '使用启发式方法对代码补全项进行排序'
# 'Use if conversion pass'
HBFF84704F0B4: '使用条件转换优化'
# 'Use ifunc global'
H9FA2DD7E729C: '使用ifunc全局'
# 'Use indirect register addressing for divergent indexes'
HF60A83099C5E: '为发散索引使用间接寄存器寻址'
# 'Use inline cost priority.'
H496F98AFF787: '使用内联成本优先级。'
# 'Use inlined strings rather than string section.'
H7753024EA72C: '使用内联字符串而非字符串节。'
# 'Use instruction-ref based LiveDebugValues with normal DBG_VALUE inputs'
H2DC2FFE65115: '使用基于指令引用的 LiveDebugValues 并采用常规 DBG_VALUE 输入'
# 'Use instrumentation data for profile-guided optimization'
H9DC257CB2810: '使用插桩数据进行配置文件引导型优化'
# 'Use instrumentation data for profile-guided optimization. If pathname is a directory, it reads from <pathname>/default.profdata. Otherwise, it reads from file <pathname>.'
HDBC8B9085819: '使用插桩数据进行配置文件引导型优化。若路径名是目录则读取 <pathname>/default.profdata，否则读取文件 <pathname>'
# 'Use instrumented (context sensitive) profile to guide PGO.'
HF618D20FE941: '使用上下文敏感型插桩剖面引导PGO'
# 'Use instrumented profile to guide PGO.'
H479023987FBB: '使用插桩剖面引导PGO'
# 'Use internal machine object code emitter.'
H45C76DB103C3: '使用内部机器目标码生成器。'
# 'Use jump tables for lowering switches'
HFFDBCF7C79DB: '使用跳转表转换开关语句'
# 'Use large decoder table format. This uses 24 bits for offset\nin the table instead of the default 16 bits.'
H7EEE365A819D: '使用大型解码器表格式。该格式在表中使用 24 位偏移量（而非默认的 16 位）'
# 'Use large-integer access for consecutive bitfield runs.'
HAFC147F2F63A: '对连续位段序列使用寄存器大小访问'
# 'Use linker features to support dead code stripping of globals'
H25F0988FF38D: '使用链接器特性支持全局变量的死代码剥离'
# 'Use loop idiom recognition code size heuristics when compiling with -Os/-Oz'
H16B2DB694C4C: '在 -Os/-Oz 优化级别下使用循环惯用法识别的代码大小启发式策略'
# 'Use masked vector intrinsics'
HD66DB2015BA3: '使用掩码向量内建函数'
# 'Use md5 to represent function names in the output profile (only meaningful for -extbinary)'
HE791F5E32608: '在输出配置文件中使用 md5 表示函数名称（仅对 -extbinary 有意义）'
# 'Use memory profile for profile-guided memory optimization'
H5A1906ADE19C: '使用内存剖面进行配置文件引导型内存优化'
# 'Use more powerful methods of sharpening expression ranges. May be costly in terms of compile time'
HD0AB27E80870: '使用更强大的表达式范围锐化方法。可能导致编译时间增加'
# 'Use native PDB reader instead of DIA'
H9315B56556F2: '使用本机 PDB 读取器而非 DIA'
# 'Use new kernel launching API for HIP'
HB4F88B0BE07A: '为HIP使用新内核启动API'
# 'Use odr indicators to improve ODR reporting'
H74C4F000003D: '使用 ODR 标识符提升 ODR 报告准确性'
# 'Use old-style Thumb2 if-conversion heuristics'
H98BE9934D232: '使用旧式 Thumb2 条件转换启发式方法'
# 'Use one trap block per function'
HAC8964692418: '每个函数使用一个陷阱块'
# 'Use only doxygen-style comments to generate docs.'
H609A25655FBA: '仅使用 Doxygen 样式注释生成文档。'
# 'Use only register numbers when writing assembly output'
H3A4857A621C3: '在输出汇编代码时仅使用寄存器编号'
# "Use optimistic attributes describing 'as-if' properties of runtime calls."
H4E943E97F387: '使用描述运行时调用 "as-if" 属性的乐观属性。'
# 'Use packed stack layout (SystemZ only).'
HD83EA715FFB0: '使用紧凑堆栈布局（仅限SystemZ）。'
# 'Use page aliasing in HWASan'
H4A8E0010EDA7: '在 HWASan 中使用页地址映射'
# 'Use pipes between commands, when possible'
HE3D5879BAE89: '尽可能在命令间使用管道'
# 'Use post increment control-dependent ranges in IndVarSimplify'
H911B15838A45: '在IndVarSimplify中使用后增量控制相关范围'
# 'Use predicated EVL instructions for tail folding. If EVL is unsupported, fallback to data-without-lane-mask.'
HED0757D8A6A8: '使用预测的EVL指令进行尾部折叠。如果EVL不受支持，则回退到无通道掩码的数据。'
# 'Use preferred fixed label for all labels'
H89BB5704EA97: '为所有标签使用优选固定标签'
# 'Use prefix for memory intrinsics in KASAN mode'
HA3237877312E: '在KASAN模式下为内存本机函数使用前缀'
# 'Use private aliases for global variables'
H7796ADF97BE6: '为全局变量使用私有别名'
# 'Use profi to infer block and edge counts'
H65DAA2E87B9C: '使用profi推断块和边计数'
# 'Use profi to infer block and edge counts.'
H8CD455D93A81: '使用profi推断块和边的数量。'
# 'Use profile info to add section prefix for hot/cold functions'
HC0D88E37E898: '使用配置文件信息为热门/冷门函数添加段前缀'
# 'Use pseudo probes in profile generation'
H0886E88805AB: '在生成配置文件时使用伪探针'
# 'Use public LTO visibility for classes in std and stdext namespaces'
H0471C4CC8A6A: '为std和stdext命名空间中的类使用公共LTO可见性'
# 'Use raw weights for labels. Use percentages as default.'
H84E197A50BE8: '使用标签的原始权重。默认使用百分比。'
# 'Use register sized accesses to bit-fields, when possible.'
HEC8949CF52C8: '尽可能使用寄存器大小访问位段'
# 'Use relative paths for invoking subcommands'
HF3DBC88EA771: '使用相对路径调用子命令'
# 'Use release mode (AOT-compiled model)'
H3C1DD2917917: '使用发布模式（AOT编译模型）'
# 'Use ring buffer for stack allocations'
H1D67F21B8816: '使用环形缓冲区进行栈分配'
# 'Use rnglists for contiguous ranges if that allows using a pre-existing base address'
H0FA2B904A3EB: '如果可以使用预先存在的基地址，则为连续范围使用rnglists'
# 'Use round-robin distribution of functions to modules instead of the default name-hash-based one'
H2DC1323199D5: '使用循环分配函数到模块，而不是默认的基于名称哈希的方法'
# 'Use row-major layout'
HE68D3A295C31: '使用行优先布局'
# 'Use runtime alias checks to resolve possible aliasing.'
H74ED44C8AB6B: '使用运行时别名检查来解决可能的别名问题。'
# 'Use sampled profile to guide PGO.'
H83EE2F7AD7E3: '使用采样配置文件来引导PGO。'
# 'Use sections+offset as references rather than labels.'
HC0250DDB1574: '使用段+offset作为引用而不是标签。'
# 'Use segment set for the computation of the live ranges of physregs.'
H297ADEEDAC19: '在计算物理寄存器的活跃范围时使用段集。'
# 'Use segmented stack'
H45E75CED74E8: '使用分段堆栈'
# 'Use separate accesses for consecutive bitfield runs with legal widths and alignments.'
HDAEB15795B56: '为具有合法宽度和对齐的连续位段序列使用单独的访问'
# 'Use separate unique sections for named sections'
HBA19BDB53714: '为命名段使用独立的唯一段'
# 'Use separate unique sections for named sections (ELF Only)'
H966D46021E86: '为命名的段使用独立的唯一段（仅限ELF）'
# 'Use shared memory to transfer generated code and data'
H5DE48C3CC472: '使用共享内存传输生成的代码和数据'
# 'Use simple template names in DWARF, or include the full template name with a modified prefix for validation'
HCADD22C917E1: '在DWARF中使用简单模板名称，或包含带有修改前缀的完整模板名称以进行验证'
# 'Use smallest entry possible for jump tables'
H51B906CF7E2B: '为跳转表使用尽可能小的条目'
# 'Use software floating point'
HE54F4CA19BBF: '使用软件浮点'
# 'Use specified bytecode when generating output'
H6F1FA0ED25C1: '生成输出时使用指定的字节码'
# 'Use stack probes (default)'
HBB884418570D: '使用栈探测（默认）'
# 'Use static debug run-time'
HC2C965E8960E: '使用静态调试运行时库'
# 'Use static run-time'
H53E3F295A611: '使用静态运行时库'
# 'Use target platform default'
H1C5D924DE4CE: '使用目标平台默认设置'
# 'Use text-based completion if the parser is not ready'
H2FD4CB6E479F: '如果解析器未准备好，则使用基于文本的补全'
# 'Use the AMDGPU specific RPTrackers during scheduling'
HA779151F216B: '在调度时使用AMDGPU特定的RPTrackers'
# 'Use the AST -> LLVM pipeline to compile'
H4DBFD65A7D65: '使用AST到LLVM管线进行编译'
# 'Use the BLOCK_INFO from the given file'
HF8FF5F8C2E3C: '使用给定文件中的BLOCK_INFO'
# 'Use the ClangIR pipeline to compile'
H3E61FEC2858B: '使用ClangIR管线进行编译'
# 'Use the DFA based hazard recognizer.'
HB08DE21B4CC4: '使用基于DFA的危险识别器。'
# 'Use the FDPIC ABI'
HAD67F08A6522: '使用FDPIC ABI'
# 'Use the Greedy mode (best local mapping)'
H86402D6079EC: '使用贪婪模式（best local mapping）'
# 'Use the LLVM representation for assembler and object files'
H598F01E104A3: '为汇编和目标文件使用LLVM表示'
# 'Use the MVE code generator for software pipelining'
H07D34F141A55: '使用MVE代码生成器进行软件流水线处理'
# "Use the basic-block-sections profile to determine the text section prefix for hot functions. Functions with basic-block-sections profile will be placed in `.text.hot` regardless of their FDO profile info. Other functions won't be impacted, i.e., their prefixes will be decided by FDO/sampleFDO profiles."
H7751642AFC12: '使用基本块部分配置文件确定热函数的文本段前缀。具有基本块部分配置文件的函数将被放置在`.text.hot`中，无论其FDO配置文件信息如何。其他函数不受影响，即它们的前缀将由FDO/样本FDO配置文件决定。'
# 'Use the current working directory as the base directory of compiled module files.'
HC4A3722E1C1D: '使用当前工作目录作为已编译模块文件的基础目录'
# 'Use the current working directory as the home directory of module maps specified by -fmodule-map-file=<FILE>'
H8AE9B0359BD7: '使用当前工作目录作为通过-fmodule-map-file=<FILE> 指定的模块映射的主目录'
# 'Use the dependence analysis interface'
HDF3A2E881A47: '使用依赖性分析接口'
# 'Use the experimental C++ class ABI for classes with virtual tables'
HBFD90D3B3FDE: '为带有虚表的类使用实验性的C++类ABI'
# 'Use the experimental OpenMP-IR-Builder codegen path.'
H0A44AF245C92: '使用实验性的OpenMP-IR-Builder代码生成路径'
# 'Use the experimental peeling code generator for software pipelining'
H14186C9F73CB: '使用实验性的循环展开代码生成器进行软件流水线处理'
# 'Use the first input module as the merged module'
H8EEE69848E3D: '使用第一个输入模块作为合并后的模块'
# 'Use the full schema for serialization'
HFE88B8373E59: '使用完整的序列化模式'
# 'Use the given guard (global, tls) for addressing the stack-protector guard'
H1CBDB2D23600: '使用给定的保护类型（全局、tls）来定位栈保护器的保护地址'
# 'Use the given offset for addressing the stack-protector guard'
H5EC45CECD53A: '使用给定的偏移量来定位栈保护器的保护地址'
# 'Use the given reg for addressing the stack-protector guard'
H2907454E4058: '使用给定的寄存器来定位栈保护器的保护地址'
# 'Use the given symbol for addressing the stack-protector guard'
HB4E7196A5294: '使用给定的符号来定位栈保护器的保护地址'
# 'Use the given vector functions library'
H8A7DC0CD5F6E: '使用指定的向量函数库'
# 'Use the given vector functions library. Note: -fveclib={ArmPL,SLEEF} implies -fno-math-errno'
HB6448F1B4907: '使用指定的向量函数库。注意：-fveclib={ArmPL,SLEEF} 隐含 -fno-math-errno'
# 'Use the gnu89 inline semantics'
H86341C44D7F1: '使用gnu89内联语义'
# "Use the host's platform-specific path separator character when expanding the __FILE__ macro"
H19B5E5B63186: '在展开__FILE__宏时使用主机平台特定的路径分隔符字符'
# 'Use the implementation defaults'
H46CDBE8DC11A: '使用实现默认设置'
# 'Use the last modification time of <file> as the build session timestamp'
HC4A79FF67275: '使用 <file> 的最后修改时间作为构建会话时间戳'
# 'Use the llvm.experimental.noalias.scope.decl intrinsic during inlining.'
H9063D587CE9C: '在内联时使用llvm.experimental.noalias.scope.decl内建函数。'
# 'Use the named plugin action in addition to the default action'
H2C8F63F64ACF: '在默认操作外附加使用命名插件操作'
# 'Use the named plugin action instead of the default action (use "help" to list available options)'
HEB1C020DB399: '用命名插件操作替代默认操作（使用 "help" 列出可用选项）'
# 'Use the native __fp16 type for arguments and returns (and skip ABI-specific lowering)'
H638090B7484A: '使用__fp16参数和返回值的本机类型（并跳过与ABI相关的降级）'
# 'Use the native half type for __fp16 instead of promoting to float'
HF8914EF176E5: '使用本机half类型代替__fp16的float提升'
# 'Use the native platform for the executor.Requires -orc-runtime'
HA522D7482E1A: '为执行器使用本机平台。需要 -orc-runtime'
# 'Use the new driver for OpenMP offloading.'
H4FEA64EFDBD7: '使用OpenMP offloading的新驱动程序'
# 'Use the new driver for offloading compilation.'
H2C38A94F0FE6: '使用offloading编译的新驱动程序'
# 'Use the new method of lowering partial reductions.'
H67B6026FF0E7: '使用部分约简的新型转换方法。'
# 'Use the new offloading linker to perform the link job.'
HBE633D219689: '使用新的offloading链接器执行链接任务'
# 'Use the old (incorrect) instruction latency calculation'
H2E61A14D081C: '使用旧的（不正确的）指令延迟计算方法'
# 'Use the preinliner decisions stored in profile context.'
HD0A0D412FA60: '使用存储在配置文件上下文中的预内联决策。'
# 'Use the remappings described in <file> to match the profile data against names in the program'
HD47D317FB40F: '使用 <file> 中描述的重映射将分析数据与程序中的名称匹配'
# 'Use the scalar evolution interface'
HD228C1FFC83E: '使用标量进化接口'
# 'Use the specified contextual profile file'
H21441E080C2A: '使用指定的上下文配置文件文件'
# 'Use the static host OpenMP runtime while linking.'
H409015ECE8E9: '链接时使用静态主机OpenMP运行时'
# "Use the target's default scheduler choice."
HEF05D039293B: '使用目标的默认调度器选择。'
# "Use the target's platform-specific path separator character when expanding the __FILE__ macro"
H7C74BA846E17: '在展开__FILE__宏时使用目标平台特定的路径分隔符字符'
# 'Use the unified LTO pipeline'
H95AFD66F1EAB: '使用统一的LTO流水线'
# 'Use this option to enable basic block coverage instrumentation'
H0CDE08096A2C: '使用此选项启用基本块覆盖率插桩'
# 'Use this option to enable function entry coverage instrumentation.'
HD78AD2BC6F5D: '使用此选项启用函数入口覆盖率插桩。'
# 'Use this option to enable temporal instrumentation'
HAB3379855655: '使用此选项启用时间戳插桩'
# 'Use this option to turn off/on warnings about function with samples but without debug information to use those samples. '
H511084B41E5F: '使用此选项关闭/开启有关具有采样数据但缺少调试信息而无法使用这些采样的函数的警告。'
# 'Use this option to turn off/on warnings about profile cfg mismatch.'
H1D04CE0F6A8E: '使用此选项关闭/开启有关配置文件控制流图不匹配的警告。'
# 'Use this option to turn on/off SELECT instruction instrumentation. '
HDC5EDE7DE3E2: '使用此选项开启/关闭SELECT指令的插桩。'
# 'Use this option to turn on/off memory intrinsic size profiling.'
HF19744FEF2C8: '使用此选项开启/关闭内存内建函数大小的配置文件统计。'
# 'Use this option to turn on/off warnings about incorrect usage of llvm.expect intrinsics.'
H3723F53142CC: '使用此选项开启/关闭有关llvm.expect内建函数使用不当的警告。'
# 'Use this option to turn on/off warnings about missing profile data for functions.'
H78D4B914E121: '使用此选项开启/关闭有关函数缺少配置文件数据的警告。'
# 'Use this to override the target cache line size when specified by the user.'
H43C33F17EAA5: '当用户指定时，使用此选项覆盖目标缓存行大小。'
# "Use this to override the target's minimum page size."
HEA1997AE00E5: '覆盖目标的最小页面大小。'
# "Use this to override the target's predictable branch threshold (%)."
H9102D958180E: '覆盖目标的可预测分支阈值 (%)。'
# 'Use this to skip inserting cache invalidating instructions.'
HE32E1CC26F2E: '跳过插入缓存失效指令。'
# 'Use this to specify the default maximum number of instructions to scan backward from a given instruction, when searching for available loaded value'
H673F71583921: '指定在搜索可用已加载值时，从给定指令反向扫描的默认最大指令数。'
# 'Use this to specify the default trip count of a loop'
HEB778E135667: '指定循环的默认迭代次数。'
# 'Use this to specify the max. distance between array elements accessed in a loop so that the elements are classified to have temporal reuse'
HABE5835F827F: '指定循环中访问的数组元素之间的最大距离，使得这些元素被分类为具有时间复用性。'
# 'Use this unroll count for all loops including those with unroll_and_jam_count pragma values, for testing purposes'
HD799D9D7B870: '在测试目的下，为所有循环（包括带有unroll_and_jam_count pragma值的循环）使用此展开次数。'
# 'Use this unroll count for all loops including those with unroll_count pragma values, for testing purposes'
HEF3DD1B9175D: '在测试目的下，为所有循环（包括带有unroll_count pragma值的循环）使用此展开次数。'
# 'Use together with -emit-llvm to get pristine LLVM IR from the frontend by not running any LLVM passes at all'
H80E48E5F4285: '与-emit-llvm一起使用时，不运行任何LLVM passes来从前端获取原始LLVM IR'
# 'Use undef when generating programs.'
HD1F883A2CCED: '在生成程序时使用undef。'
# 'Use unified LTO piplines. Ignored unless -thinlto-bc is also specified.'
H84A36B27E595: '使用统一的LTO流水线。除非同时指定-thinlto-bc，否则将被忽略。'
# 'Use unique names for basic block sections (ELF Only)'
HDE45C38B60C6: '为基本块节使用唯一名称（仅限ELF）'
# 'Use verbose output'
H579A705CE0A4: '使用详细输出。'
# 'Use window algorithm after SMS algorithm fails.'
H29FAE7BBDC36: '在SMS算法失败后使用窗口算法。'
# 'Use window algorithm instead of SMS algorithm.'
H0091F49C954B: '使用窗口算法代替SMS算法。'
# 'Use with -ast-dump or -ast-print to dump/print only AST declaration nodes having a certain substring in a qualified name. Use -ast-list to list all filterable declaration node names.'
H03F2BB85517F: '与-ast-dump或-ast-print一起使用时，仅转储/打印具有特定限定名子字符串的AST声明节点。使用-ast-list列出所有可筛选的声明节点名称。'
# 'Use zlib'
H7267EE40AF01: '使用 zlib'
# 'Use zstd'
HADE0CBD533EE: '使用 zstd'
# 'Used for test purpuses'
H143A636D4E4C: '用于测试用途。'
# 'User directory for configuration files'
HD1D0604448D4: '配置文件的用户目录'
# 'User specified cold threshold for instr profile which will override the cold threshold got from profile summary. '
H921527455582: '用户指定的指令分析配置文件的冷阈值，将覆盖从分析摘要获取的冷阈值。'
# 'User supplied asset path to override the default css and js files for html output'
H11CFB81E3E7B: '用户提供的资源路径，用于覆盖HTML输出中的默认CSS和JS文件。'
# 'Uses the source file name instead of the Module hash. This requires that the source filename has a unique name / path to avoid name collisions.'
HEFB279BA9297: '使用源文件名而不是模块哈希。需要源文件名具有唯一名称/路径以避免名称冲突。'
# 'VALU instruction count threshold for adjusting wave priority'
H323BECA8255D: '调整波优先级的VALU指令计数阈值。'
# 'VE Assembly Printer'
H35AB8A791661: 'VE汇编打印器'
# 'VE DAG->DAG Pattern Instruction Selection'
H31A1129B2EDC: 'VE DAG->DAG模式指令选择'
# 'VLIW scheduler'
H04220C47ABF0: '超长指令字（VLIW）调度器'
# 'Validate PCH input files based on content if mtime differs'
H5B0B3696A2CD: '当mtime不同时根据内容验证PCH输入文件'
# 'Validate PCM input files based on content if mtime differs'
HE7966DE5A8B2: '当mtime不同时根据内容验证PCM输入文件'
# 'Validate that all vtables have type infos in LTO'
H66B413E67029: '验证LTO中所有虚表都有类型信息'
# 'Validate the system headers that a module depends on when loading the module'
HEE36D448D56F: '加载模块时验证模块所依赖的系统头文件'
# 'Value for __PIC__'
H760023C619A3: '__PIC__ 的值'
# 'Value to pass to hot/cold operator new for cold allocation'
H6DAF60C415A6: '传递给hot/cold operator new用于冷分配的值。'
# 'Value to pass to hot/cold operator new for hot allocation'
HD1597DC64127: '传递给hot/cold operator new用于热分配的值。'
# 'Value to pass to hot/cold operator new for notcold (warm) allocation'
HE0D30EC39F19: '传递给hot/cold operator new用于非冷（暖）分配的值。'
# 'Variable.'
H7236856976D0: '变量。'
# 'Vector functions library'
H22962FC6DC51: '向量函数库'
# 'Vectorization cost threshold.'
HCD21FCE9A5E0: '向量化成本阈值。'
# 'Vectorize if the invocation count is < than this. 0 disables vectorization.'
H282E25ADE422: '如果调用次数小于此值则进行向量化。0 表示禁用向量化。'
# 'Vectorize load and Store instructions'
HC110C6BBCB5B: '向量化加载和存储指令'
# 'Vectorize load and store instructions'
HBBECD678BBBC: '向量化加载和存储指令'
# 'Vectorize up to this many bundles.'
H5F30F00C03B7: '向量化最多到此数量的代码块。'
# 'Verbosity level of the contextual profile printer pass.'
H635358C62DFB: '上下文配置文件打印Pass的详细程度。'
# 'Verbosity of log messages written to stderr'
H2E24D6564DA8: '写入标准错误流的日志信息的详细程度'
# 'Verfiy VPlans after VPlan transforms.'
HE7FC42CC42C7: '在 VPlan 转换后验证 VPlan。'
# 'Verify AMDGPU HSA Metadata'
H65A2759AA257: '验证 AMDGPU HSA 元数据'
# 'Verify Call Frame Information instructions'
H027197CC37B3: '验证调用帧信息指令'
# 'Verify IR correctness when making sensitive SCEV queries (slow)'
H42A1AB630381: '在进行敏感的 SCEV 查询时验证 IR 的正确性（速度较慢）'
# 'Verify PredicateInfo in legacy printer pass.'
H799D5E295653: '在旧版打印Pass中验证谓词信息。'
# "Verify ScalarEvolution's backedge taken counts (slow)"
HA5864D8AB4F8: '验证 ScalarEvolution 的后边沿计数（速度较慢）'
# 'Verify after each transform'
H357D460E1502: '在每次转换后进行验证'
# 'Verify device memory post execution against the original output.'
HE16F0A0EAC54: '执行后将设备内存与原始输出进行验证。'
# 'Verify diagnostic output using comment directives that start with prefixes in the comma-separated sequence <prefixes>'
HC54A2E24270E: '使用以逗号分隔的前缀序列 <prefixes> 开头的注释指令验证诊断输出'
# 'Verify dominator info (time consuming)'
H7265FCA24E7A: '验证支配信息（耗时）'
# 'Verify domtree after unrolling'
H9FB6F655E747: '展开后验证支配树'
# 'Verify during register allocation'
HA235BE2313EF: '在寄存器分配期间进行验证'
# 'Verify generated machine code'
HAB7C952A6204: '验证生成的机器代码'
# 'Verify legalizations'
H442690F32499: '验证合法性'
# 'Verify legalizations and artifact combines'
H810B83C40C92: '验证合法性和工件组合'
# 'Verify loop info (time consuming)'
H7C86EDFCE360: '验证循环信息（耗时）'
# 'Verify loop lcssa form (time consuming)'
H0CAAF184E14A: '验证循环的 LCSSA 形式（耗时）'
# 'Verify loopinfo after unrolling'
H03E2A3EBA62D: '循环展开后验证循环信息'
# 'Verify loops generated Loop Idiom Vectorize Pass.'
H8FE13960BD12: '验证由Loop Idiom向量化Pass生成的循环'
# 'Verify machine code after expanding ARM pseudos'
H4928DCB0BD05: '在展开ARM伪指令后验证机器码'
# 'Verify machine dominator info (time consuming)'
H7DB30C69D5DA: '验证机器支配信息（耗时）'
# 'Verify machine instrs before and after machine scheduling'
H13FA77C833AC: '验证机器调度前后机器指令'
# 'Verify machine instrs before and after register coalescing'
HDD83DA18C7C7: '验证寄存器合并前后机器指令'
# 'Verify region info (time consuming)'
H9292DD1C4B56: '验证区域信息（耗时）'
# 'Verify sanity of PHI instructions during taildup'
H0D6EE6D76E64: '在尾部复制期间验证PHI指令的正确性'
# 'Verify that computeKnownBits() and SimplifyDemandedBits() are consistent'
HD464B311F8B5: '验证computeKnownBits()和SimplifyDemandedBits()的一致性'
# 'Verify that debug locations are handled'
H5157BEF03DC8: '验证调试位置处理'
# 'Verify that narrow int args are properly extended per the SystemZ ABI.'
H7B81C58E5DE9: '根据SystemZ ABI验证窄整数参数是否被正确扩展'
# 'Verify that the generated patterns are ordered by increasing latency'
HB35BF620F949: '验证生成的模式按递增延时排序'
# 'Verify the binary representation of debug output'
HD5EDEFE1C648: '验证调试输出的二进制表示形式'
# 'Verify the detected SCoPs after each transformation'
H577B4C82C33A: '验证每次变换后的检测SCoP'
# 'Verify the function generated by Polly'
H36FACBAA370A: '验证Polly生成的函数'
# 'Verify this pass produces no dead code'
HD157362652B5: '验证此Pass不会生成死代码'
# 'Version loops if flattened loop could overflow'
H2ED0232BC13B: '为可能溢出的展平循环添加版本化'
# 'View BFI after MIR loader'
H70176654BA61: '查看MIR加载器后的BFI'
# 'View BFI before MIR loader'
HD24CF0251C0D: '查看MIR加载器前的BFI'
# 'View Options'
HDA1AEDD5C0C0: '视图选项'
# 'View call graph'
HC3CF5708A682: '查看调用图'
# 'View dominance tree of function'
H8CAAE8FCD27E: '查看函数的支配树'
# 'View dominance tree of function (with no function bodies)'
HB12C18D29169: '查看函数的支配树（无函数体）'
# 'View postdominance tree of function'
H5144E7801A69: '查看函数的后支配树'
# 'View postdominance tree of function (with no function bodies)'
H6016FE3E7B20: '查看函数的后支配树（无函数体）'
# 'View regions of function'
HC65478A71B23: '查看函数的区域'
# 'View regions of function (with no function bodies)'
H5ECE0F8FFA1A: '查看函数的区域（无函数体）'
# 'View the CFG before DFA Jump Threading'
H7CED97AC3765: '查看DFA跳转合并前的控制流图'
# 'View the dependency graph.'
H4CD0E62026DC: '查看依赖关系图'
# 'Viewing options'
H4109B1BD7A45: '查看选项'
# 'Virtual Register Map'
HBAB873C35568: '虚寄存器映射'
# 'Virtual Register Rewriter'
H70230BEE99F4: '虚寄存器重写器'
# 'Volatile loads and stores have acquire and release semantics'
HA2D66EAC62AA: '易变的加载和存储具有 acquire 和 release 语义'
# 'Volatile loads and stores have standard semantics'
H3FC4BC9157CA: '易变的加载和存储具有标准语义'
# 'Volatile specifier.'
H5BCC57A6F6B7: 'volatile说明符。'
# 'Vreg distance cutoff for insert generation.'
HE65C5AFBE2C8: 'Vreg距离阈值用于插入生成。'
# 'Vreg# cutoff for insert generation.'
H69051D37244E: 'Vreg#阈值用于插入生成。'
# 'WARNING: This option will replace your input file with the reduced version!'
HA6B4706DBC98: '警告：此选项将用精简后的版本替换您的输入文件！'
# "WARNING: You're attempting to print out a bitcode file.\nThis is inadvisable as it may cause display problems. If\nyou REALLY want to taste LLVM bitcode first-hand, you\ncan force output with the `-f' option.\n\n"
HD29B4F840F03: "警告：您正在尝试打印输出一个比特码文件。\n这样做不建议，因为它可能导致显示问题。如果您真的想亲身体验LLVM比特码，可以使用 `-f' 选项强制输出。\n\n"
# 'Wait for user input before entering JITed code'
HE997D4A27F4E: '在进入JIT代码前等待用户输入'
# 'Wait until all forks of instrumented process will finish (use with instrumentation-sleep-time option)'
H29419FC27D66: '等待所有被监控的子进程完成（需配合instrumentation-sleep-time选项使用）'
# 'Warn for mismatching a signed and unsigned value'
H2A8E011548FA: '当有符号和无符号值类型不匹配时触发警告'
# 'Warn for missing parenthesis around predicate registers'
HE7943720E0D3: '当谓词寄存器缺少括号时触发警告'
# "Warn for register names that aren't contigious"
HFB31626439DD: '当寄存器名称不连续时触发警告'
# 'Warn if a function definition returns or accepts an object larger in bytes than a given value'
H8990A87A623D: '若函数定义返回或接受的字节数大于给定值的对象则发出警告'
# 'Warn in ARM, emit implicit ITs in Thumb'
HC57002E0EFBF: '在ARM中发出警告，在Thumb中生成隐式IT指令'
# 'Warn in ARM, reject in Thumb'
H4EFFA07355E3: '在ARM中发出警告，在Thumb中拒绝'
# 'Warn on equivalent symbols in the output symbol list'
H88E497B15A1B: '当输出符号表中存在等价符号时触发警告'
# 'Warn on input symbols missing from output symbol list'
HE4D0B0A892DF: '当输入符号未包含在输出符号表中时触发警告'
# 'Warn on language extensions'
HCCA103ACA6B2: '在语言扩展时发出警告'
# 'Warn on use'
HE0ABF7E28126: '在使用时发出警告'
# 'Warning Options'
HEA0EF30FD9BD: '警告选项'
# 'Warnings about individual formatting changes needed. Used only with --dry-run or -n'
HA24BD5E41E3E: '关于单个格式修改的警告提示。仅与--dry-run或-n选项配合使用'
# 'Warnings detected.'
H9BB1C52DB1D8: '检测到警告。'
# 'Warnings to generate.'
H0499BE5B2273: '需要生成的警告信息。'
# 'Weakly link in the blocks runtime'
H32E4B9C0D02B: '弱链接到 blocks 运行时'
# 'WebAssembly Assmebly Printer'
H618A8F3DD855: 'WebAssembly汇编打印器'
# 'WebAssembly Clean Code After Trap'
H5004FAB71B78: 'WebAssembly 陷阱后清理代码'
# 'WebAssembly Emscripten-style exception handling'
HB909CEF50795: 'WebAssembly Emscripten风格的异常处理'
# 'WebAssembly Emscripten-style setjmp/longjmp handling'
HB327E2AC0CF6: 'WebAssembly Emscripten风格的setjmp/longjmp处理'
# 'WebAssembly Exception Information'
HB914447C6B3D: 'WebAssembly 异常信息'
# 'WebAssembly Instruction Selection'
H6897B43BD95A: 'WebAssembly指令选择'
# 'WebAssembly Late Exception Preparation'
H2CE3575C6DB6: 'WebAssembly 异常处理后期准备'
# 'WebAssembly Lower Emscripten Exceptions / Setjmp / Longjmp'
HBA47203A675C: 'WebAssembly 将 Emscripten 异常 / setjmp / longjmp 转换为底层形式'
# 'WebAssembly Lower RefTypes Int-Ptr Conversions'
HFE0286340D39: 'WebAssembly 降低 RefTypes 整数-指针转换'
# 'WebAssembly Nullify DBG_VALUE_LISTs'
HA5294064B53B: 'WebAssembly 禁用 DBG_VALUE_LIST 列表'
# 'WebAssembly exception handling'
H886CFE14EC29: 'WebAssembly异常处理'
# 'WebAssembly exception handling (legacy)'
H7E31087C50F3: 'WebAssembly异常处理（旧版）'
# 'WebAssembly peephole optimizations'
H430AF441595E: 'WebAssembly 窥孔优化'
# 'WebAssembly reference type not allowed in exception specification'
H14B705277A94: 'WebAssembly引用类型不允许在异常说明中使用'
# 'WebAssembly setjmp/longjmp handling'
H9F0C3575883B: 'WebAssembly setjmp/longjmp处理'
# 'WebAssembly table cannot be declared within a function'
H085E37C320EB: 'WebAssembly表不能在函数内部声明'
# 'WebAssembly table must be static'
H23C0F2D20589: 'WebAssembly表必须是静态的'
# 'WebAssembly: Disable EH pad-first sort order. Testing purpose only.'
HBC8CFE10E3BC: 'WebAssembly：禁用EH的pad-first排序顺序。仅用于测试目的。'
# 'WebAssembly: Disable fallthrough-return optimizations.'
H8B46242EE529: 'WebAssembly：禁用fallthrough-return优化。'
# 'WebAssembly: output implicit locals in instruction output for test purposes only.'
HBD0CCB517ABD: 'WebAssembly：仅用于测试目的，在指令输出中显示隐式局部变量。'
# 'WebAssembly: output stack registers in instruction output for test purposes only.'
HCAF0317DF2F0: 'WebAssembly：仅在测试目的下，在指令输出中显示堆栈寄存器。'
# 'Weight for argument embeddings'
H6E245963349C: '参数嵌入的权重'
# 'Weight for opcode embeddings'
HAF6B081C42AD: '操作码嵌入的权重'
# 'Weight for type embeddings'
HAD8C8AF4F1BA: '类型嵌入的权重'
# 'Weight of the branch likely to be taken (default = 2000)'
H39B8B6D520C6: '可能被选中的分支的权重（默认值 = 2000）'
# 'Weight of the branch unlikely to be taken (default = 1)'
H2A04B39F2CCF: '不太可能被选中的分支的权重（默认值 = 1）'
# 'What is the maximal lookup depth when trying to check for viability of negation sinking.'
H7F1CA4DE1A48: '尝试检查否定下沈的可行性时，最大的查找深度是多少。'
# 'What length to truncate vertex labels to '
H3DED4F5FCF91: '截断顶点标签时的长度'
# 'What to do with the summary when running this pass'
H42E595F78536: '当运行此 pass 时，对摘要进行的操作'
# "When -frepack-arrays is in effect, 'whole' enables repacking for arrays that are non-contiguous in any dimension, 'innermost' enables repacking for arrays that are non-contiguous in the innermost dimension (the default)"
H20A445368AD8: "当启用-frepack-arrays时，'whole' 选项对任何维度非连续的数组进行打包，'innermost' 选项对最内层维度非连续的数组进行打包（默认）"
# 'When -fvisibility-inlines-hidden is enabled, static variables in inline C++ member functions will also be given hidden visibility by default'
HC9E644F8BF87: '当启用 -fvisibility-inlines-hidden 时，内联 C++ 成员函数中的静态变量也将默认具有隐藏可见性'
# 'When a diagnostic is emitted on an operation, also print the operation as an attached note'
H2ECC08973193: '当某个操作发生诊断时，也作为附加注释打印该操作'
# 'When a diagnostic is emitted, also print the stack trace as an attached note'
H76C424E9438C: '当发生诊断时，也作为附加注释打印堆栈跟踪'
# 'When creating a PCH, stop PCH generation after #pragma hdrstop.'
HD38248648BFF: '创建 PCH 时，在 #pragma hdrstop 后停止 PCH 生成'
# 'When dfsan-combine-offset-labels-on-gep and/or dfsan-combine-pointer-labels-on-load are false, this flag can be used to re-enable combining offset and/or pointer taint when loading specific constant global variables (i.e. lookup tables).'
H081A797A7BB7: '当 dfsan-combine-offset-labels-on-gep 和/或 dfsan-combine-pointer-labels-on-load 为 false 时，此标志可用于重新启用加载特定常量全局变量（例如查找表）时的偏移量和/或指针污点合并。'
# 'When discriminating instructions with memory operands, ignore prefetch instructions. This ensures the other memory operand instructions have the same identifiers after inserting prefetches, allowing for successive insertions.'
H7E4D0664626F: '在区分带有内存操作数的指令时，忽略预取指令。这确保在插入预取指令后，其他内存操作数指令具有相同的标识符，从而允许后续插入。'
# 'When displaying an injected source, display the file content'
H3DDBC39BBF92: '当显示注入的源代码时，显示文件内容'
# 'When dumping a SymIndexId, dump the full details of the corresponding record'
HE9EC08CB2E15: '当转储 SymIndexId 时，转储对应记录的完整详细信息'
# 'When dumping debug chunks, show a different section for each chunk'
HFD526CCFAF68: '转储调试块时，为每个块显示不同的部分'
# "When dumping type records for classes, unions, enums, and structs, don't try to resolve forward references"
HBD90D91A2AFF: '为类、联合体、枚举和结构体转储类型记录时，不要尝试解析前向引用'
# 'When epilogue vectorization is enabled, and a value greater than 1 is specified, forces the given VF for all applicable epilogue loops.'
H9B19DBFD9697: '当启用尾部向量化时，若指定了大于 1 的值，则强制所有适用的尾部循环使用给定的 VF。'
# 'When generating a crash reproducer, attempt to generated a reproducer with the smallest pipeline.'
H527701909117: '生成崩溃复现时，尝试生成包含最小流水线的复现。'
# 'When generating nested context-sensitive profiles, always generate extra base profile for function with all its context profiles merged into it.'
H4E82789DA6E1: '生成嵌套的上下文敏感配置文件时，始终为函数生成额外的基配置文件，将所有上下文配置文件合并到其中。'
# 'When merging conditional stores, do so even if the resultant basic blocks are unlikely to be if-converted as a result'
H33EB082F4E55: '合并条件存储时，即使合并后的基本块不太可能因合并而被转换为 if-converted 结构，也要进行合并。'
# 'When performing SCEV expansion only if it is cheap to do, this controls the budget that is considered cheap (default = 4)'
H6E8B9FA2EB34: '仅在进行廉价的 SCEV 展开时，控制认为廉价的预算（默认值 = 4）'
# 'When performing memory disambiguation checks at runtime do not generate more than this number of comparisons (default = 8).'
HBB48DD13984F: '在运行时执行内存别名检查时，不要生成超过该数量的比较（默认值 = 8）。'
# 'When printing IR for print-[before|after]{-all} always print a module IR'
HEE9A6FDE189D: '在打印print-[before|after]{-all}的IR时，始终打印模块IR'
# 'When printing IR for print-[before|after]{-all} for a loop pass, always print function IR'
HD8F4D915AAB6: '在为循环Pass的print-[before|after]{-all}打印IR时，始终打印函数IR'
# 'When printing IR for print-ir-[before|after]{-all} always print the top-level operation'
H58BBC34B4C5E: '在打印print-ir-[before|after]{-all}的IR时，始终打印顶层操作'
# 'When printing analysis, include information on every instruction'
H27AFC0602C62: '打印分析时，包含每条指令的信息'
# 'When printing machine IR, annotate instructions and blocks with SlotIndexes when available'
H8B62DF7E25E7: '打印机器IR时，当可用时用SlotIndexes注释指令和块'
# 'When printing the IR after a pass, only print if the IR changed'
H0B8C96DE116C: '在打印Pass后的IR时，仅在IR发生变化时打印'
# 'When printing the IR after a pass, only print if the pass failed'
H42128FB51A38: '在打印Pass后的IR时，仅在Pass运行失败时打印'
# 'When printing the IR before/after a pass, print file tree rooted at this directory. Use in conjunction with mlir-print-ir-* flags'
HC069026BC657: '在打印Pass前后的IR时，打印以该目录为根的文件树。需与mlir-print-ir-*标志联用'
# 'When set to true, const objects with relocatable address values are put into the RO data section.'
H66324957E3F0: '设为true时，具有可重定位地址值的常量对象将放入RO数据区段。'
# 'When stubbing functions, replace all uses will null'
HBC6C3A0A1E4B: '当存根函数时，将所有使用替换为null'
# 'When the basic block contains not more than this number of PHI nodes, perform a (faster!) exhaustive search instead of set-driven one.'
H95DC35D4BF29: '当基本块包含的PHI节点数量不超过此数值时，改用更快的穷举搜索而非集合驱动搜索。'
# 'When the option is false, if the target block is in a loop, the promotion will be disallowed unless the promoted counter  update can be further/iteratively promoted into an acyclic  region.'
HFCDA16D52A31: '当该选项为false时，若目标块在循环中，则除非提升的计数器更新可进一步迭代式地提升到无环区域，否则禁止进行提升。'
# 'When this option is on, the annotated branch probability will be emitted as optimization remarks: -{Rpass|pass-remarks}=pgo-instrumentation'
H5E55F3D7A2DD: '启用此选项时，将通过优化备注-{Rpass|pass-remarks}=pgo-instrumentation输出标注的分支概率。'
# 'When to emit DWARF unwind (EH frame) info'
H0DBCF1BE684C: '何时生成DWARF展开（EH帧）信息'
# 'When to use colors in diagnostics'
HBE3593F16E43: '在诊断信息中使用颜色的时机'
# 'When true, SLP vectorizer bypasses profitability checks based on heuristics and makes vectorization decision via cost modeling.'
H05B0C2731561: '设为true时，SLP向量化器将绕过基于启发式的盈利性检查，通过成本建模决定向量化。'
# 'When used with filetype=obj, emit an object file which can be used with an incremental linker'
HE96BEC53314D: '与filetype=obj联用时，生成可与增量链接器配合使用的对象文件'
# 'When used with filetype=obj, relax all fixups in the emitted object file'
H167CB844A0DE: '当与filetype=obj一起使用时，松弛在生成的目标文件中的所有修复项'
# 'When using -fxray-function-groups, select which group of functions to instrument. Valid range is 0 to fxray-function-groups - 1'
H763EF25FAB59: '使用 -fxray-function-groups 时，选择要插入探针的函数组。有效范围是 0 到 fxray-function-groups - 1'
# 'When using a PCH, skip tokens until after a #pragma hdrstop.'
H0A2ABCA96B55: '使用 PCH 时，跳过标记直到 #pragma hdrstop 之后'
# 'Where to run polly in the pass pipeline'
H9B2F95971D75: '在pass管线中运行Polly的位置'
# 'Whether has closed-world assumption at link time'
H99F1999EDDBD: '链接时是否具有封闭世界假设'
# 'Whether inline replay should be applied to the entire Module or just the Functions (default) that are present as callers in remarks during cgscc inlining.'
HD26538F942D7: '是否将内联重放应用于整个模块，而非默认仅对在cgscc内联期间备注中存在的调用者函数进行应用。'
# 'Whether inline replay should be applied to the entire Module or just the Functions (default) that are present as callers in remarks during sample profile inlining.'
H694D5B29DF1C: '是否将内联重放应用于整个模块还是仅默认的函数（在样本配置文件内联期间作为调用者的函数）。（默认值：仅函数）'
# 'Whether new header will depend on old header. If true, clang-move will add #include of old header to new header.'
HEAD603DC16D2: '新头文件是否依赖旧头文件。如果为真，clang-move会将旧头文件的#include添加到新头文件中。'
# 'Whether old header will depend on new header. If true, clang-move will add #include of new header to old header.'
H3B1BCC2BCADE: '旧头文件是否依赖新头文件。如果为真，clang-move会将新头文件的#include添加到旧头文件中。'
# 'Whether or not to compute detailed function properties.'
H665EA58EEFEB: '是否计算详细的函数属性。'
# 'Whether or not to enable features under development for the ML regalloc advisor'
HF0690434B74D: '是否启用ML寄存器分配顾问中的开发中功能'
# 'Whether or not we should insert assumes of conditions of predicated guards'
H825B30E48FC9: '是否为预测条件守卫的条件插入假设'
# 'Whether or not we should predicate guards expressed as widenable branches to deoptimize blocks'
H3D40391D0BD5: '是否将可扩展分支表示的守卫预测为退化块'
# 'Whether or not we should widen guards  expressed as branches by widenable conditions'
HFD8C2DB7CA08: '是否将由可扩展条件表示的分支守卫进行扩展'
# 'Whether to apply ext-tsp placement for instances w/o profile'
H77F1EF844B16: '是否对无配置文件的实例应用ext-tsp放置'
# 'Whether to build a relocatable precompiled header'
HB03E5614FB01: '是否构建可重定位的预编译头'
# 'Whether to distribute into a loop that may not be if-convertible by the loop vectorizer'
HB249A06C5F2F: '是否将分布到可能无法通过循环向量化进行if-转换的循环'
# 'Whether to emit DWARF EH frame entries.'
HDDECD32989A5: '是否生成DWARF异常处理框架条目。'
# 'Whether to generate default bounds for arrays.'
HA8699205DACC: '是否为数组生成默认边界。'
# 'Whether to include the lower dimensions extents in the stride.'
H4245438632CE: '是否在步长中包含低维范围'
# 'Whether to minimize added include paths'
HC7C82427C36C: '是否尽量减少添加的包含路径'
# 'Whether to perform binary concatenation'
H4B115FCD938B: '是否执行二进制连接'
# 'Whether to perform binary extraction'
H9D6252A4435A: '是否执行二进制提取'
# 'Whether to try to emit Compact Unwind for non canonical entries.'
H55500B1ACFA7: '是否尝试为非规范条目生成紧凑的展开信息。'
# 'Whether to use the address from fix.box in data clause operations.'
H17A5E7DCB500: '在数据子句操作中是否使用fix.box的地址。'
# 'Whether to use the bareptr calling convention on the host (warning this should be false until the GPU layering is fixed)'
HEF14896C6BC2: '主机是否使用bareptr调用约定（警告：在GPU分层修复前应设为false）'
# 'Whether to use the bareptr calling convention on the kernel (warning this should be false until the GPU layering is fixed)'
H99F227DA714B: '内核是否使用bareptr调用约定（警告：在GPU分层修复前应设为false）'
# 'Whether to use the cost heuristic to make choices as we traverse the search space using the exact solver. Defaulted to on, and if turned off, we will use the node order -- attempting to put the later nodes in the later sched groups. Experimentally, results are mixed, so this should be set on a case-by-case basis.'
HF1BAF3533D97: '在使用精确求解器遍历搜索空间时，是否使用成本启发式进行选择。默认启用，若关闭则使用节点顺序——尝试将较晚节点置于较晚调度组。实验表明结果不一，因此应根据具体情况启用。'
# 'Whether to use the exponential time solver to fit the instructions to the pipeline as closely as possible.'
H086A0DF8B27C: '是否使用指数时间求解器尽可能紧密地将指令与流水线匹配。'
# 'Whether we should inject new invariants and unswitch them to eliminate some existing (non-invariant) conditions.'
H3C32643D02A0: '是否应注入新不变量并取消切换它们以消除现有非不变条件。'
# 'Which DWARF linkage-name attributes to emit.'
H09FB4F2415AD: '要生成的DWARF链接名称属性类型。'
# 'Which dependence analysis should loop fusion use?'
HAD495CD6F62E: '循环融合应使用哪种依赖性分析？'
# "Which overload candidates to show when overload resolution fails. Defaults to 'all'"
H3E34CE4DE5D1: '当重载解析失败时显示哪些重载候选。默认为 "all"'
# 'Which thread-local storage dialect to use for dynamic accesses of TLS variables'
H811A2F4F5EAE: '动态访问 TLS 变量时使用的线程局部存储方言'
# 'Which unit to use for fp math'
HE5F83035EE94: '用于浮点运算的单位'
# 'Widen sub-dword constant address space loads in AMDGPUCodeGenPrepare'
HA61656982921: '在AMDGPUCodeGenPrepare中扩展子字节常量地址空间加载'
# 'Widen sub-dword constant address space loads in AMDGPULateCodeGenPrepare'
H16C37A921AE2: '在AMDGPULateCodeGenPrepare中扩展子字节常量地址空间加载'
# "Widen the loop induction variables, if possible, so overflow checks won't reject flattening"
HF84F6515DE2A: '尽可能扩展循环归纳变量，以便溢出检查不会拒绝展平'
# 'Widen uniform 16-bit instructions to 32-bit in AMDGPUCodeGenPrepare'
H46D2473C38FB: '在AMDGPUCodeGenPrepare中将统一的 16 位指令扩展为 32 位'
# 'Windows exception model'
H86EB91F51633: 'Windows 异常模型'
# 'With -globals, only dump globals whose name matches the given value'
H08E7C52DD63F: '与-globals选项配合使用时，仅转储名称与给定值匹配的全局变量'
# 'With PGO, include profile count in optimization remarks'
HA68492B41822: '在PGO模式下，将分析统计信息包含在优化备注中'
# 'Work around Cortex-A57 Erratum 1742098 (ARM only)'
H2CF5C8E79954: '绕过 Cortex-A57 Erratum 1742098（仅 ARM）'
# 'Work around Cortex-A72 Erratum 1655431 (ARM only)'
HB9954D8E1844: '规避Cortex-A72错误 1655431（仅ARM）'
# 'Work around VLLDM erratum CVE-2021-35465 (ARM only)'
H6484FD8B0341: '规避VLLDM错误CVE-2021-35465（仅ARM）'
# 'Work with `--skip-symbolization` or `--unsymbolized-profile` to write/read the offset instead of virtual address.'
H1CA65028F454: '使用 `--skip-symbolization` 或 `--unsymbolized-profile` 以写入/读取偏移量而非虚地址。'
# 'Workaround Cortex-A53 erratum 835769 (AArch64 only)'
H479486F0F64D: '规避Cortex-A53错误 835769（仅AArch64）'
# "Wouldn't use segmented stack"
HF45022A557BC: '不会使用分段栈'
# 'Write Bitcode'
H6EB243E1EECC: '生成比特码'
# 'Write a compilation database entry per input'
H69BE4C131EAE: '为每个输入生成编译数据库条目'
# 'Write a depfile containing user and system headers'
HDB1957B0249A: '生成包含用户和系统头文件的依赖文件'
# 'Write a depfile containing user headers'
H294C0D501665: '生成包含用户头文件的依赖文件'
# 'Write assembly to file for input to assemble jobs'
H7C079FE214C7: '将汇编代码写入文件以供汇编任务输入'
# 'Write current time into COFF output (default)'
HF98DECE931FC: '将当前时间写入COFF输出（默认）'
# 'Write depfile output from -MMD, -MD, -MM, or -M to <file>'
H7F1DEF2B183F: '将来自-MMD、-MD、-MM或-M的依赖文件输出写入 <file>'
# 'Write extracted files to a static archive'
H167164B5BAE5: '将提取的文件写入静态档案库'
# 'Write lazy-function executions to a CSV file as (JITDylib, function) pairs'
HEA5DEA15DFD8: '将以(JITDylib, function)对的形式将延迟函数执行写入CSV文件'
# 'Write linked LTO module to file before optimize'
HCE5CCE000DB8: '优化前将链接的LTO模块写入文件'
# 'Write merged LTO module to file before CodeGen'
HD65008F3EA67: '代码生成前将合并的LTO模块写入文件'
# 'Write minimized bitcode to <file> for the ThinLTO thin link only'
H675031C72335: '为ThinLTO薄链接仅将最小化比特码写入 <file>'
# 'Write out individual imports files via InProcessThinLTO. Has no effect unless specified with -thinlto-emit-indexes or -thinlto-distributed-indexes'
H19E7DA782B06: '通过InProcessThinLTO单独输出导入文件。需与-thinlto-emit-indexes或-thinlto-distributed-indexes选项配合使用才生效'
# 'Write out individual index and import files for the distributed backend case'
H2A414F2C0CA7: '为分布式后端场景单独输出索引和导入文件'
# 'Write out individual index files via InProcessThinLTO'
H04EFB23839D1: '通过InProcessThinLTO单独输出索引文件'
# 'Write output as LLVM assembly'
HC401168D9C72: '将输出写为LLVM汇编语言'
# 'Write output as ThinLTO-ready bitcode'
H81BE69D83D3F: '将输出写为ThinLTO准备的bitcode'
# 'Write output to <file>'
HCABB93CE5040: '将输出写入 <file>'
# 'Write output to <file>.'
HA5CAFFC7A76E: '将输出写入 <file>。'
# 'Write relative block frequency to function summary '
H61EDFA1BBE67: '将相对块频率写入函数摘要'
# 'Write summary to given YAML file after running pass'
H2786584E85AF: '在运行pass后将摘要写入指定的YAML文件'
# 'Write summary to given bitcode or YAML file after running pass. Output file format is deduced from extension: *.bc means writing bitcode, otherwise YAML'
HF422AA3A57C9: '在运行pass后将摘要写入指定的bitcode或YAML文件。输出文件格式根据扩展名推断：*.bc表示写入bitcode，否则为YAML'
# 'Write the previous version of indexed format, to enable some forward compatibility.'
H214BE48CC62F: '写入索引格式的旧版本，以实现部分前向兼容性。'
# 'Writes always set the type'
H90F97A092B90: '始终设置类型'
# 'X86 Assembly Printer'
HD5F043986D92: 'X86汇编打印器'
# 'X86 Call Frame Optimization'
H6C1AD91D1BC8: 'X86 调用帧优化'
# 'X86 DAG->DAG Instruction Selection'
H7AF1958AB670: 'X86 DAG->DAG指令选择'
# 'X86 Domain Reassignment Pass'
H208A2EDE1B82: 'X86 域重新分配Pass'
# 'X86 DynAlloca Expander'
H1CB6E843E202: 'X86 DynAlloca 展开器'
# 'X86 EFLAGS copy lowering'
H478602C51D49: 'X86 EFLAGS 复制降级'
# 'X86 Execution Domain Fix'
HB1A8033FDC96: 'X86执行域修复'
# 'X86 FP Stackifier'
HB70E458DAF08: 'X86 浮点栈转换器'
# 'X86 LVI load hardening'
HE886300056CC: 'X86 LVI 加载强化'
# 'X86 LVI ret hardener'
H7BB1121F99C0: 'X86 LVI 返回指令强化'
# 'X86 Partial Reduction'
H71421E3EAECA: 'X86 部分约简'
# 'X86 Return Thunks'
HB7A0BD877623: 'X86 返回 Thunks'
# 'X86 Speculative Execution Side Effect Suppression'
HAC95FD71C1F3: 'X86 投机执行副作用抑制'
# 'X86 Suppress APX features for relocation'
H1A67E3308F3A: 'X86重定位时抑制APX特性'
# 'X86 cmov Conversion'
H459397A41EF1: 'X86 cmov 转换'
# 'X86 optimize LEA pass'
HA2592D9DB191: 'X86优化LEA pass'
# 'X86 pseudo instruction expansion pass'
H90C7B8C811FD: 'X86伪指令扩展pass'
# 'X86 speculative load hardener'
H2A7987566821: 'X86 投机性加载强化'
# 'X86: Disable LEA optimizations.'
H9A76B9360F40: 'X86：禁用LEA优化。'
# 'X86: Disable Store Forwarding Blocks fixup.'
H182CD9732E25: 'X86：禁用存储转发块修复。'
# 'X86: Disable Virtual Register Reassignment.'
H12CE3299B81B: 'X86：禁用虚寄存器重分配。'
# 'X86: Number of instructions backward to inspect for store forwarding blocks.'
HEFF525BFF565: 'X86：向后检查存储转发块的指令数量。'
# 'X86: enable AMX scalarizition.'
HCECBA05C8A45: 'X86：启用AMX scalarizition。'
# 'XCore Assembly Printer'
H1AA113AD0A3E: 'XCore汇编打印器'
# 'XCore DAG->DAG Pattern Instruction Selection'
H581ED762EAE6: 'XCore DAG->DAG模式指令选择'
# 'XRay Tools\n\n  This program consolidates multiple XRay trace processing tools for convenient access.\n'
HFB113E3ACE56: 'XRay 工具集\n\n  该程序整合了多个 XRay 跟踪处理工具以便于访问。\n'
# 'Xtensa Assembly Printer'
H1172BF988F99: 'Xtensa汇编打印器'
# 'YAML'
HFFBCB202B09D: 'YAML'
# 'Yaml database created by find-all-symbols'
H338C17AD7D21: '由 find-all-symbols 创建的 Yaml 数据库'
# 'Yaml database, with fuzzy-matched names'
H858A2F00C528: '带有模糊匹配名称的 Yaml 数据库'
# 'Zero initialize globals without default initialization'
H16BF774B86E6: '对没有默认初始化的全局变量进行零初始化'
# 'Zero initialize globals without default initialization (default)'
H49398887AE1B: '不进行默认初始化时零初始化全局变量（默认）'
# 'Zero line numbers.'
HBDDF04B8DE1F: '行号为零。'
# 'Zero out the discriminator bits for the FS discrimiantor pass beyond this value. The enum values are defined in Support/Discriminator.h'
H86161643B09B: '将FS discrimiantor pass的鉴别位超出该值的部分清零。枚举值定义在Support/Discriminator.h中'
# '[<input file>,...] (deprecated)'
HBAF2C191067E: '[<input file>,...]（已弃用）'
# '[<offload kind>-<target triple>,...]'
HE5C00640F67F: '[<offload kind>-<target triple>,...]'
# '[<output file>,...] (deprecated)'
H701132FD6E40: '[<output file>,...]（已弃用）'
# '[@<file>] [<file> ...]'
HA0A725D8D937: '[@<file>] [<file> ...]'
# '[LICM & MemorySSA] When MSSA in LICM is disabled, this has no effect. When MSSA in LICM is enabled, then this is the maximum number of accesses allowed to be present in a loop in order to enable memory promotion.'
H15A8950FC7AE: '[LICM & MemorySSA] 当LICM中的MSSA被禁用时，此选项无效。当LICM中的MSSA启用时，这是允许循环中存在的最大访问次数以启用内存提升。'
# '[WIP] Tries to hide the latency of host to device memory transfers'
HC6732C3722E0: '[进行中] 尝试隐藏主机到设备内存传输的延迟'
# '[[]] attributes are a C++11 extension'
H8246F8EB1C38: '[[ ]]属性是C++11扩展'
# '[[]] attributes are a C23 extension'
H65C81736C143: '[[ ]]属性是C23扩展'
# '[[]] attributes are incompatible with C standards before C23'
HFCBAAA359BD9: '[[ ]]属性与C23之前的C标准不兼容'
# '[[]] attributes are incompatible with C++ standards before C++11'
H963EC793AF1E: '[[ ]]属性与C++11之前的C++标准不兼容'
# '[code to run]'
HBFD9181194E0: '[要运行的代码]'
# '[ignorelist file]'
H5547568B1A46: '[忽略列表文件]'
# '[input bitcode]...'
H8C715EEC26A7: '[输入比特码文件]...'
# '[no]neon is not accepted as modifier, please use [no]simd instead'
H34DCBA8F9AA1: '[no]neon不能作为修饰符使用，请改用[no]simd'
# '\\%0 used with no following hex digits'
H4ACD9688DA19: '\\%0 使用时未跟随十六进制数字'
# "\\%0 used with no following hex digits; treating as '\\' followed by identifier"
H34C9A007F8A0: "\\%0 使用时未跟随十六进制数字；将视为 '\\' 后跟标识符"
# '^^ is a reserved operator in OpenCL'
H0C0A23A57F10: '^^在OpenCL中是保留运算符'
# '_Atomic cannot be applied to %select{incomplete |array |function |reference |atomic |qualified |sizeless ||integer |}0type %1 %select{|||||||which is not trivially copyable||in C23}0'
H323CC2CB8E5D: '_Atomic不能应用于%select{不完整 |数组 |函数 |引用 |原子 |限定 |无尺寸 ||整数 |}0 类型 %1 %select{|||||||无法被简单复制||在C23中}0'
# '_GLOBAL_OFFSET_TABLE_'
HE310DB69A9CE: '_GLOBAL_OFFSET_TABLE_'
# '_Pragma takes a parenthesized string literal'
HC3D115F3D6CB: '_Pragma需要一个括号包围的字符串字面量'
# '__CUDA_ARCH'
H640861EF7CBB: '__CUDA_ARCH'
# '__DATA'
H6F22B9326AE7: '__DATA'
# '__LINKEDIT'
H1EA417FFF11E: '__LINKEDIT'
# '__VA_ARGS__ can only appear in the expansion of a C99 variadic macro'
HA5D98E4DA6FF: '__VA_ARGS__只能在C99可变参数宏的展开中出现'
# '__VA_OPT__ can only appear in the expansion of a variadic macro'
HCDC494FE863F: '__VA_OPT__只能在可变参数宏的展开中出现'
# '__VA_OPT__ cannot be nested within its own replacement tokens'
H7C3979F48311: '__VA_OPT__不能嵌套在其自身的替换标记中'
# '__arm_agnostic("sme_za_state") cannot share ZA state with its caller'
H3F5679E58734: '__arm_agnostic("sme_za_state")不能与其调用者共享ZA状态'
# '__arm_agnostic("sme_za_state") is not supported together with __arm_new("za") or __arm_new("zt0")'
H1551D9BB8B08: '__arm_agnostic("sme_za_state")不能与__arm_new("za")或__arm_new("zt0")一起使用'
# '__asm used with no assembly instructions'
H8FE87A3A5F53: '__asm在没有汇编指令的情况下使用'
# '__block attribute not allowed on declaration with a variably modified type'
H10FB78A8E9A5: '__block属性不允许在具有变长修改类型的声明中使用'
# '__block attribute not allowed, only allowed on local variables'
HE188099287CD: '__block属性不允许使用，仅允许在局部变量上使用'
# '__block variable %0 cannot be captured in a %select{lambda expression|captured statement}1'
HD7DB9752FAAD: '__block变量 %0 不能被捕获到 %select{lambda表达式|被捕获的语句}1中'
# '__builtin_btf_type_id argument %0 not a constant'
H48F1BECDC866: '__builtin_btf_type_id参数 %0 不是常量'
# '__builtin_get_vtable_pointer requires an argument of%select{| polymorphic}0 class pointer type, but %1 %select{was provided|has no virtual methods}0'
H6F5E8AE6B1DC: '__builtin_get_vtable_pointer需要一个 %select{|多态}0类指针类型的参数，但 %1%select{是不完整类型|没有虚函数}0'
# '__builtin_get_vtable_pointer requires an argument with a complete type, but %0 is incomplete'
HC06F79966A72: '__builtin_get_vtable_pointer需要完整的类型参数，但 %0 是不完整类型'
# '__builtin_longjmp is not supported for the current target'
H53A6EFDFCD17: '__builtin_longjmp不支持当前目标平台'
# "__builtin_mul_overflow does not support 'signed _BitInt' operands of more than %0 bits"
H24B9AB05270A: "__builtin_mul_overflow不支持超过 %0 位的 'signed _BitInt' 操作数"
# '__builtin_preserve_enum_value argument %0 invalid'
H341194DCABD7: '__builtin_preserve_enum_value参数 %0 无效'
# '__builtin_preserve_enum_value argument %0 not a constant'
HCADD1D27CE0B: '__builtin_preserve_enum_value参数 %0 不是常量'
# '__builtin_preserve_field_info argument %0 not a constant'
HA3DE67421A5E: '__builtin_preserve_field_info参数 %0 不是常量'
# '__builtin_preserve_field_info argument %0 not a field access'
H153927D1D427: '__builtin_preserve_field_info参数 %0 不是一个字段访问'
# '__builtin_preserve_type_info argument %0 invalid'
H92B5B29F2F9A: '__builtin_preserve_type_info参数 %0 无效'
# '__builtin_preserve_type_info argument %0 not a constant'
H57FE08B33075: '__builtin_preserve_type_info参数 %0 不是常量'
# '__builtin_setjmp is not supported for the current target'
H08E9B75B93D5: '__builtin_setjmp不支持当前目标平台'
# '__constant__, __device__, and __managed__ are not allowed on non-static local variables'
H4A2DC7998EB3: '不允许在非静态局部变量上使用__constant__、__device__和__managed__'
# '__constant__, __device__, and __shared__ variables must use default address space'
HE599218FA9CA: '__constant__、__device__和__shared__变量必须使用默认地址空间'
# '__declspec attribute %0 is not supported'
H4B7BDD3DADC0: '__declspec属性 %0 不受支持'
# '__declspec attributes must be an identifier or string literal'
HBBCBBEE3784E: '__declspec属性必须是标识符或字符串字面量'
# '__final is a GNU extension, consider using C++11 final'
H9019DE700CF0: '__final是GNU扩展，建议使用C++11的final'
# '__grid_constant__ is only allowed on const-qualified kernel parameters'
HDE081328BF07: '__grid_constant__仅允许在const限定的内核参数上使用'
# '__has_warning expected option name (e.g. "-Wundef")'
H96068DA3D4D1: '__has_warning期望选项名称（例如“-Wundef”）'
# '__shared__ local variables not allowed in %select{__device__|__global__|__host__|__host__ __device__}0 functions'
H0BA8A02BD0B3: '__shared__ 局部变量不允许在 %select{__device__|__global__|__host__|__host__ __device__}0 函数中使用'
# "__shared__ variable %0 cannot be 'extern'"
H76DC43AF246B: "__shared__ 变量 %0 不能是 'extern'"
# '__spirv_backend_service_fun'
HEC37DE49A8CD: '__spirv_backend_service_fun'
# '__sync builtin operation must have natural alignment (consider using __atomic)'
HFAE067F4A98D: '__sync 内建操作必须具有自然对齐（考虑使用 __atomic）'
# '__weak attribute cannot be specified on a field declaration'
HAD92983EAEB2: '__weak 属性不能指定在字段声明上'
# '__weak attribute cannot be specified on an automatic variable when ARC is not enabled'
HC15AE9021482: '__weak 属性在未启用 ARC 时不能指定在自动变量上'
# '`#pragma const_seg` for section %1 will not apply to %0 due to the presence of a %select{mutable field||non-trivial constructor|non-trivial destructor}2'
H8811D5F6122A: "'#pragma const_seg' 为 %1 节将不适用于 %0，因为存在%select{可变字段||非平凡构造函数|非平凡析构函数}2"
# '`interrupt_save_fp` only applies to targets that have a VFP unit enabled for this compilation; this will be treated as a regular `interrupt` attribute'
HB2C8A1373FD2: '`interrupt_save_fp`仅适用于启用VFP单元的编译目标；该属性将被视为普通`interrupt`属性'
# 'a %select{function|block}0 declaration without a prototype is deprecated %select{in all versions of C|}0'
HA427D7F1B8D9: '没有原型的 %select{函数|块}0 声明在所有 C 版本中已弃用 %select{ | 和在 C23 中不受支持}0'
# "a %select{pack indexing|'decltype'}0 specifier cannot be used in a declarative nested name specifier"
H505B17716528: '无法在声明式嵌套名称限定符中使用 %select{打包索引|decltype}0 规范符'
# 'a concept definition cannot refer to itself'
H3304727AB46C: '概念定义不能引用自身'
# 'a constant expression cannot modify an object that is visible outside that expression'
H91A285505D66: '常量表达式不能修改在该表达式外部可见的对象'
# 'a declarative nested name specifier cannot name an alias template'
H09803710CDAC: '声明式嵌套名称限定符不能命名别名模板'
# 'a firstprivate variable with incomplete type %0'
H893794AB5FB9: '具有不完整类型的 firstprivate 变量 %0'
# 'a friend declaration that befriends a template must contain exactly one type-specifier'
HDEE648B4A187: '友元声明若要 befriending 模板必须恰好包含一个类型说明符'
# 'a function %select{declaration|definition}0 without a prototype is deprecated in all versions of C %select{and is not supported in C23|and is treated as a zero-parameter prototype in C23, conflicting with a %select{previous|subsequent}2 %select{declaration|definition}3}1'
HB3E1938E8933: '没有原型的函数 %select{声明|定义}0 在所有 C 版本中已弃用 %select{ | 并在 C23 中被视为零参数原型}1，这会与 %select{之前的|后续的}2 %select{声明|定义}3 冲突'
# 'a function type is not allowed here'
HE650A35390C3: '此处不允许使用函数类型'
# 'a getter method is needed to perform a compound assignment on a property'
HEDE5FCF91532: '执行属性的复合赋值需要 getter 方法'
# 'a lambda expression cannot appear in this context'
H979A7AF92A65: 'lambda 表达式在此上下文中不允许'
# 'a lambda expression may not appear inside of a constant expression'
HB0755DD5F929: 'lambda 表达式不能出现在常量表达式内部'
# 'a lambda parameter cannot shadow an explicitly captured entity'
H65FE428CB516: 'lambda 参数不能隐藏显式捕获的实体'
# 'a lambda with an explicit object parameter cannot be mutable'
HF1252DDC6E4B: '具有显式对象参数的 lambda 不能是 mutable'
# 'a lastprivate variable with incomplete type %0'
H8324467E21DA: '类型不完整的lastprivate变量 %0'
# 'a linear variable with incomplete type %0'
HE61951ED0B99: '类型不完整的线性变量 %0'
# 'a module can only be re-exported as another top-level module'
H272C723A8726: '模块只能作为另一个顶层模块重新导出'
# 'a non-type template parameter cannot have type %0'
H4D4081CB8796: '非类型模板参数不能具有类型 %0'
# 'a non-type template parameter cannot have type %0 before C++20'
HEEE0AA3066FD: '在C++20之前，非类型模板参数不能具有类型 %0'
# 'a parameter list without types is only allowed in a function definition'
H52BB0DED62AC: '不带类型的参数列表仅允许在函数定义中使用'
# 'a parameter pack may not be accessed at an out of bounds index'
H3E85B76262B3: '参数包不能在越界索引处被访问'
# 'a private variable with incomplete type %0'
H0A7C86E8874A: '类型不完整的私有变量 %0'
# 'a randomized struct can only be initialized with a designated initializer'
H4615845B3A9F: '随机化结构体只能使用指定初始化器进行初始化'
# 'a reduction list item with incomplete type %0'
H06AA7BC953CB: '类型不完整的规约列表项 %0'
# 'a requires expression cannot have an explicit object parameter'
H86B74E3E67C6: 'requires表达式不能包含显式对象参数'
# 'a requires expression must contain at least one requirement'
HA35998709F70: 'requires表达式必须包含至少一个约束条件'
# "a space is required between a right angle bracket and an equals sign (use '> =')"
H9BFA1E21C4F4: '右尖括号和等号之间需要空格（使用 "> =")'
# "a space is required between consecutive right angle brackets (use '> >')"
H529B67153B9E: '连续的右尖括号之间需要空格（使用 "> >")'
# 'a static lambda cannot have any captures'
H2E5388A18076: '静态lambda不能有任何捕获'
# 'a static_assert declaration cannot be a template'
HA1124669302F: 'static_assert声明不能是模板'
# 'a template argument list is expected after a name prefixed by the template keyword'
HF4A21ADFAB4E: '模板关键字前缀的名称后面需要跟随模板参数列表'
# 'a type named %0 is hidden by a declaration in a different namespace'
H26CC1C864C4C: '名称 %0 的类型被其他命名空间的声明所隐藏'
# 'a type specifier is required for all declarations'
HA2239D7DA67E: '所有声明都需要指定类型说明符'
# 'a typedef cannot be a template'
H878607247E5C: 'typedef不能是模板'
# 'absolute value function %0 given an argument of type %1 but has parameter of type %2 which may cause truncation of value'
H2B4AC1EEC989: '绝对值函数 %0 的参数类型为 %2，但传入的实参类型为 %1，可能导致数值被截断'
# "abstract class is marked '%select{final|sealed}0'"
H9546D737D23E: "抽象类被标记为 '%select{final|sealed}0'"
# 'access declarations are deprecated; use using declarations instead'
H3431BA5113E5: '访问声明已弃用；请改用using声明'
# 'access qualifier %0 cannot be used for %1 %select{|prior to OpenCL C version 2.0 or in version 3.0 and without __opencl_c_read_write_images feature}2'
HC43552CB1BAC: '访问限定符 %0 不能用于 %1 %select{|prior to OpenCL C version 2.0 or in version 3.0 and without __opencl_c_read_write_images feature}2'
# 'access qualifier can only be used for pipe and image type'
HCF9598AD42BA: '访问限定符只能用于管道和图像类型'
# 'access specifier can only have annotation attributes'
H00A8BDFCED49: '访问说明符只能具有注解属性'
# 'access specifiers are a clang HLSL extension'
H23D01BBD184F: '访问说明符是clang的HLSL扩展'
# 'accessing a member of an atomic structure or union is undefined behavior'
H1C0790EC0EC6: '访问原子结构或联合的成员属于未定义行为'
# 'accessing inaccessible direct base %0 of %1 is a Microsoft extension'
H76AFA5796E64: '访问 %1 的不可访问直接基类 %0 是Microsoft的扩展'
# "acquiring %0 '%1' requires negative capability '%2'"
HC095E2CF1B84: "获取 %0 '%1' 需要负面能力 '%2'"
# "acquiring %0 '%1' that is already held"
H4DA573668147: "尝试获取已持有的 %0 '%1'"
# 'action %0 not compiled in'
HA82E8BAC3ED2: '未编译动作 %0'
# "active '%0' clause defined here"
H5264E053D9D8: "此处定义了活动 '%0' 子句"
# 'add \'__arm_preserves("za")\' to the callee if it preserves ZA'
HD939B5A83F36: '如果被调用函数保留ZA寄存器，请添加\'__arm_preserves("za")\''
# "add 'constexpr'"
H48500D7C1CF8: "添加 'constexpr'"
# "add 'export' here if this is intended to be a module interface unit"
H8499B2C3202C: "如果这是模块接口单元，请在此添加 'export'"
# "add 'module;' to the start of the file to introduce a global module fragment"
H1399A9153C66: "在文件开头添加 'module;' 以引入全局模块片段"
# "add 'typename' to treat this using declaration as a type"
H2514B140BEE5: "添加 'typename' 以将此using声明视为类型"
# "add 'u8' prefix to form a 'char8_t' string literal"
H8C73CF0B8333: "添加 'u8' 前缀以形成char8_t字符串字面量"
# "add 'void' to the parameter list to turn an old-style K&R function declaration into a prototype"
H460C61046151: "在参数列表中添加 'void' 将旧式K&R函数声明转换为原型"
# "add a '@synthesize' directive"
H11A117C94448: "添加 '@synthesize' 指令"
# 'add a deduction guide to suppress this warning'
H4B93D4018373: '添加一个推导指引以抑制此警告'
# 'add a deprecation attribute to the declaration to silence this warning'
HE29FCC14DCE0: '在声明中添加弃用属性以消除此警告'
# 'add a pair of parentheses to declare a variable'
H9B65CA134C28: '添加一对括号以声明变量'
# 'add a super class to fix this problem'
HD3A4A44147E8: '添加一个父类以修复此问题'
# 'add a variable name to declare a %0 initialized with %1'
HBF079F80BA92: '添加一个变量名以声明用 %1 初始化的 %0'
# "add an explicit capture of 'this' to capture '*this' by reference"
H44758706CE87: "添加对 'this' 的显式捕获以通过引用捕获 '*this'"
# 'add an explicit instantiation declaration to suppress this warning if %q0 is explicitly instantiated in another translation unit'
HA69020D4B8A0: '如果 %q0 在另一个翻译单元中显式实例化，则添加显式实例化声明以抑制此警告'
# 'add any string to tag this execution in the output binary via bolt info section'
HF4F001FFA024: '通过bolt信息部分在输出二进制文件中标记此执行的任意字符串'
# 'add basic block instructions as tool tips on nodes'
H4A2F65627544: '将基本块指令作为节点上的工具提示添加'
# 'add enclosing parentheses to perform a function-style cast'
H3C4C77285B3F: '添加外围括号以执行函数式类型转换'
# 'add explicit braces to avoid dangling else'
H912E67080844: '添加显式的大括号以避免悬垂 else'
# 'add masking cost for i1 vectors'
H3E72A2897B81: '为i1向量添加掩码成本'
# "add parentheses after the '!' to evaluate the %select{comparison|bitwise operator}0 first"
H7D8E708D64E0: '在 "!" 后添加括号以先计算 %select{比较运算符|位运算符}0'
# 'add parentheses around left hand side expression to silence this warning'
HB1B6850C2A11: '在左侧表达式周围添加括号以消除此警告'
# "add the %select{'require_constant_initialization' attribute|'constinit' specifier}0 to the initializing declaration here"
HFE1D4C8144BF: '在此初始化声明处添加 %select{ "require_constant_initialization" 属性|"constinit" 标识符}0'
# 'adding %0 to %1 might cause circular dependency in container'
H157957572465: '将 %0 添加到 %1 可能会在容器中引发循环依赖'
# 'adding %0 to a string does not append to the string'
H98175222693E: '将 %0 添加到字符串不会追加字符串'
# 'adding %0 to a string pointer does not append to the string'
HE53429791B46: '将 %0 添加到字符串指针不会追加字符串'
# 'addition of default argument on redeclaration makes this constructor a %select{default|copy|move}0 constructor'
H540EC7EBFA01: '重新声明中添加默认参数会使此构造函数成为 %select{默认|拷贝|移动}0 构造函数'
# 'address argument to %select{atomic|__sync}0 operation must be a pointer to a non address discriminated type (%1 invalid)'
H2613F565B379: '%select{原子|__sync}0 操作的地址参数必须是指向非地址判别类型的指针（%1 无效）'
# 'address argument to atomic builtin cannot be const-qualified (%0 invalid)'
H05DD72B70C0D: '原子内建函数的地址参数不能是 const 限定的 (%0 无效)'
# 'address argument to atomic builtin must be a pointer %select{|to a non-zero-sized object }1(%0 invalid)'
H25FC8322E786: '原子内建函数的地址参数必须是 %select{指向非零大小对象的|}1 指针 (%0 无效)'
# 'address argument to atomic builtin must be a pointer to 1,2,4,8 or 16 byte type (%0 invalid)'
H8F0926664FBC: '原子内建函数的地址参数必须是指向 1、2、4、8 或 16 字节类型的指针 (%0 无效)'
# 'address argument to atomic builtin must be a pointer to integer or pointer (%0 invalid)'
H05518FC9E223: '原子内建函数的地址参数必须是指向整型或指针的指针（%0 无效）'
# 'address argument to atomic builtin must be a pointer to integer, floating-point or pointer (%0 invalid)'
H4BE1CF542714: '原子内建函数的地址参数必须是指向整型、浮点型或指针的指针（%0 无效）'
# 'address argument to atomic operation must be a pointer to %select{|atomic }0integer (%1 invalid)'
H45F0D7833F1F: '原子操作的地址参数必须是指向 %select{|原子 }0整型的指针（%1 无效）'
# 'address argument to atomic operation must be a pointer to %select{|atomic }0integer or pointer (%1 invalid)'
HD792403A7931: '原子操作的地址参数必须是指向 %select{|原子 }0整型或指针的指针（%1 无效）'
# 'address argument to atomic operation must be a pointer to %select{|atomic }0integer or supported floating point type (%1 invalid)'
H645D002EEC1B: '原子操作的地址参数必须是指向 %select{|原子 }0整型或受支持的浮点类型的指针（%1 无效）'
# 'address argument to atomic operation must be a pointer to %select{|atomic }0integer, pointer or supported floating point type (%1 invalid)'
HF8B6B0144FE9: '原子操作的地址参数必须是指向 %select{|原子 }0整型、指针或受支持的浮点类型的指针（%1 无效）'
# 'address argument to atomic operation must be a pointer to _Atomic type (%0 invalid)'
HED971913A5AB: '原子操作的地址参数必须是指向_Atomic类型的指针（%0 无效）'
# 'address argument to atomic operation must be a pointer to a trivially-copyable type (%0 invalid)'
H0F2B276FBFF5: '原子操作的地址参数必须是指向平凡可复制类型的指针（%0 无效）'
# 'address argument to atomic operation must be a pointer to non-%select{const|constant}0 _Atomic type (%1 invalid)'
H77D9C30AD097: '原子操作的地址参数必须是指向非 %select{const|constant}0 _Atomic类型的指针（%1 无效）'
# 'address argument to atomic operation must be a pointer to non-const type (%0 invalid)'
HA961ACF648B8: '地址参数必须是指向非const类型的指针（%0 无效）'
# 'address argument to load or store exclusive builtin must be a pointer to 1,2,4 or 8 byte type (%0 invalid)'
H7473631C7DCE: '加载或存储内建函数的地址参数必须是指向 1、2、4或 8 字节类型的指针（%0 无效）'
# 'address argument to nontemporal builtin must be a pointer (%0 invalid)'
H15C0E2A98779: '非临时性内建函数的地址参数必须是指向指针（%0 无效）'
# 'address argument to nontemporal builtin must be a pointer to integer, float, pointer, or a vector of such types (%0 invalid)'
H411242986562: '非临时性内建函数的地址参数必须是指向整型、浮点型、指针或此类类型的向量的指针（%0 无效）'
# "address of %select{'%1'|function '%1'|array '%1'|lambda function pointer conversion operator}0 will always evaluate to 'true'"
H17F3EBE2635E: "%select{'%1' 函数|函数 '%1'|数组 '%1'|lambda函数指针转换运算符}0的地址始终会求值为 'true'"
# 'address of %select{bit-field|vector element|property expression|register variable|matrix element}0 requested'
HD8B1334D046A: '请求了%select{位段|向量元素|属性表达式|寄存器变量|矩阵元素}0的地址'
# "address of non-static constexpr variable %0 may differ on each invocation of the enclosing function; add 'static' to give it a constant address"
HE51DD27041F6: "非静态constexpr变量 %0 的地址在每次调用包含函数时可能不同；添加 'static' 使其具有常量地址"
# 'address of overloaded function %0 cannot be cast to type %1'
H358904EBF6FD: '重载函数 %0 的地址不能被转换为类型 %1'
# 'address of overloaded function %0 cannot be converted to type %1'
HCCA08BC04209: '重载函数 %0 的地址无法转换为类型 %1'
# 'address of overloaded function %0 cannot be static_cast to type %1'
HE4591559B0BB: '重载函数 %0 的地址不能被static_cast转换为类型 %1'
# 'address of overloaded function %0 does not match required type %1'
H11264D1F1C79: '重载函数 %0 的地址与所需类型 %1 不匹配'
# 'address of overloaded function %0 is ambiguous'
H33C49268724E: '重载函数 %0 的地址存在歧义'
# 'address space is larger than the maximum supported (%0)'
HFA6456E815BE: '地址空间大于最大支持值（%0）'
# 'address space is negative'
H7DA3DAA44B98: '地址空间为负数'
# 'address taken in non-type template argument for template parameter of reference type %0'
HD465BC48688F: '引用类型模板参数 %0 的非常量模板实参中获取了地址'
# 'address-of operator cannot be applied to a call to a function with unknown return type'
HA9D761CAF77E: '无法对返回类型未知的函数调用应用地址取用运算符（address-of operator）'
# 'adjust block counts based on outgoing branch counts'
H117EF7587146: '根据传出分支计数调整块计数'
# 'adjust function counts based on basic blocks execution count'
H14DEF224A29B: '根据基本块执行计数调整函数计数'
# 'adjust function profile after inlining'
HDCFC372259BA: '内联后调整函数概要'
# "after modifying system headers, please delete the module cache at '%0'"
H01FFB29D96B3: "修改系统头文件后，请删除位于 '%0' 的模块缓存"
# 'aggregate basic samples (without LBR info)'
H9B9419C851BC: '聚合基本样本（无LBR信息）'
# 'aggregate initialization of type %0 from a parenthesized list of values is a C++20 extension'
H6B5CF381E65A: '使用带括号的值列表对类型 %0 进行聚合初始化是C++20扩展'
# 'aggregate initialization of type %0 with user-declared constructors is incompatible with C++20'
HC24621DDDD5F: '具有用户声明构造函数的类型 %0 的聚合初始化与C++20不兼容'
# 'aggressive strategy'
H5CB7E66C0F79: '激进策略'
# 'aggressively inline everything'
HF506129362A1: '激进地内联所有内容'
# 'aggressively split jump tables section based on usage of the tables'
HF15D48A1547F: '根据跳转表的使用情况，激进地拆分跳转表节'
# 'algorithm used to reorder data sections'
H5E8D0AEA074C: '用于重新排列数据区的算法'
# 'alias declaration cannot be a pack expansion'
H7E12EB8475DC: '别名声明不能是模板参数包扩展'
# 'alias declaration in this context is a C++23 extension'
H91EDBE36B117: '此上下文中的别名声明是C++23扩展'
# 'alias declaration in this context is incompatible with C++ standards before C++23'
HC4280923DB99: '此上下文中的别名声明与C++23之前的语言标准不兼容'
# 'alias declarations are a C++11 extension'
HE9649A76CF28: '别名声明是C++11扩展'
# 'alias declarations are incompatible with C++98'
H47305448BB21: '别名声明与C++98标准不兼容'
# 'alias definition of %0 after tentative definition'
HBC2E292F4F78: '在尝试定义之后对 %0 进行别名声明'
# 'alias for --icp-jump-tables-targets'
H3295D8EF4BCC: '--icp-jump-tables-targets的别名'
# 'alias for --indirect-call-promotion-calls-topn'
H056F07540EAC: '--indirect-call-promotion-calls-topn的别名'
# 'alias for --indirect-call-promotion-jump-tables-topn'
H48FD0DD2A352: '--indirect-call-promotion-jump-tables-topn的别名'
# 'alias for --indirect-call-promotion-mispredict-threshold'
H69D659FF6417: '--indirect-call-promotion-mispredict-threshold的别名'
# 'alias for --indirect-call-promotion-topn'
H2CDF1F6846ED: '--indirect-call-promotion-topn的别名'
# 'alias for --indirect-call-promotion-use-mispredicts'
H6632963673FD: '--indirect-call-promotion-use-mispredicts的别名'
# 'alias for -aarch64-streaming-hazard-size'
H6DD0A61F8614: '-aarch64-streaming-hazard-size的别名'
# 'alias for -data'
H18AAC29B91E1: '-data的别名'
# 'alias for -instr_map'
H8C404A340D69: '-instr_map 的别名'
# 'alias for -perfdata'
H4AA3F61C654A: '-perfdata 的别名'
# 'alias for -symbolize'
HF105886B4E32: '-symbolize 的别名'
# 'alias to a variable in a common section is not allowed'
H93F6002973E0: '不允许引用常见段中的变量的别名'
# 'aliases are not supported on darwin'
H41CBE942EE33: 'Darwin系统不支持别名'
# 'align basic blocks'
H546676202A2D: '对齐基本块'
# 'align functions at a given value (relocation mode)'
HA06778A68136: '在给定值处对齐函数（重定位模式）'
# 'align only blocks with frequency larger than containing function execution frequency specified in percent. E.g. 1000 means aligning blocks that are 10 times more frequently executed than the containing function.'
H9CD01CD0B966: '仅对执行频率高于包含函数指定百分比的基本块进行对齐。例如，1000表示对齐那些执行频率是包含函数 10 倍的基本块。'
# "aligned %select{allocation|deallocation}0 function of type '%1' is %select{only|not}4 available on %2%select{ %3 or newer|}4"
H9703DDF7875E: '类型为 %1 的对齐%select{分配|释放}0函数在 %2%select{ %3 或更高版本|}4%select{仅|不}4可用'
# 'aligned clause will be ignored because the requested alignment is not a power of 2'
HC3A503B9038C: '将忽略对齐子句，因为请求的对齐值不是 2 的幂次'
# 'alignment (%0) of thread-local variable %1 is greater than the maximum supported alignment (%2) for a thread-local variable on this target'
H9951DC0F93CA: '目标平台上线程局部变量的最大支持对齐值为 %2，但线程局部变量 %1 的对齐值(%0)超过了该限制'
# "alignment is not a power of 2 in '%0'"
HB7B2FF437212: "在 '%0' 中对齐值不是 2 的幂次"
# 'alignment of .text section'
H7D89ABD80F0F: '.text 分区的对齐方式'
# 'alignment of 16 bytes for a struct member is not binary compatible with IBM XL C/C++ for AIX 16.1.0 or older'
H79A5A88D17D7: '结构体成员的 16 字节对齐方式与AIX 16.1.0或更早版本的IBM XL C/C++不兼容'
# 'alignof expressions are incompatible with C++98'
H5F21C338A420: 'alignof表达式与C++98不兼容'
# 'all paths through this function will call itself'
H40E0BDFB048F: '通过此函数的所有路径都将调用自身'
# "allocate directive specifies %select{default|'%1'}0 allocator while previously used %select{default|'%3'}2"
HC639234B285B: "分配指令指定了%select{默认|'%1'}0 分配器，而之前使用了%select{默认|'%3'}2"
# 'allocated size %0 is not a multiple of size %1 of element type %2'
H279696362CDE: '分配的大小 %0 不是元素类型 %2 大小 %1 的倍数'
# "allocated with 'new%select{[]|}0' here"
H1AA44259E5AA: "此处使用 'new%select{[]|}0' 分配"
# 'allocating an object of abstract class type %0'
H07CDBA71F9A5: '尝试分配抽象类类型 %0 的对象'
# 'allocation of %select{incomplete|sizeless}0 type %1'
HD40A80B2E772: '分配了%select{不完整|无大小}0类型 %1'
# 'allocation performed here was not deallocated%plural{0:|: (along with %0 other memory leak%s0)}0'
H04A2F923450C: '此处分配的内存未被释放 %plural{0:|:（以及 %0 其他内存泄漏%s0）}0'
# "allocator must be specified in the 'uses_allocators' clause"
H6A6EDC2E2834: "必须在 'uses_allocators' 子句中指定分配器"
# "allocator with the 'thread' trait access has unspecified behavior on '%0' directive"
HDC686C65C1AA: "'%0' 指令具有 'thread' 特性时分配器行为未定义"
# "allocators used in 'uses_allocators' clause cannot appear in other data-sharing or data-mapping attribute clauses"
H3D9F65EE1204: "'uses_allocators' 子句中使用的分配器不能出现在其他数据共享或数据映射属性子句中"
# 'allow processing of stripped binaries'
H7C4A1D362E89: '允许处理剥离的二进制文件'
# 'allow to snippet generator to generate at most that many configs'
H8A45202314E0: '允许代码片段生成器生成最多指定数量的配置'
# "allowable client missing from %0: '%1'"
H1792F22F4481: "%0 中缺少允许的客户端：'%1'"
# "allowable clients do not match: '%0' (provided) vs '%1' (found)"
H73C7C1046F8D: "允许的客户端不匹配：'%0'（提供）与 '%1'（找到）"
# "already inside '#pragma clang arc_cf_code_audited'"
H490BE327E34C: "已在 '#pragma clang arc_cf_code_audited' 作用域内"
# "already inside '#pragma clang assume_nonnull'"
H59F0A861C85D: "已在 '#pragma clang assume_nonnull' 作用域内"
# "already inside '#pragma unsafe_buffer_usage'"
H94EE60235FE3: "已在 '#pragma unsafe_buffer_usage' 作用域内"
# 'also accessed here'
H4EBEB7641C26: '此处也被访问'
# 'also found'
HAE6F7F952B68: '也找到'
# 'always apply unchecked-ld-st'
HA7AE478F69D8: '始终应用 unchecked-ld-st'
# 'always perform sctc'
H55817EEE47EB: '始终执行 sctc'
# 'always replace exit value whenever possible'
H0EF1BA8B58B0: '尽可能始终替换退出值'
# 'always use long jumps/nops for Linux kernel static keys'
H61DBDABC6D73: '始终为Linux内核静态键使用长跳转/空操作'
# 'always_inline function %0 has new za state'
H42D69F5E4613: 'always_inline 函数 %0 有了新的 za 状态'
# 'always_inline function %0 has new zt0 state'
HC0C33866F167: 'always_inline 函数 %0 有了新的 zt0 状态'
# 'always_inline function %1 and its caller %0 have mismatching %2 attributes'
H623539F9CF4D: 'always_inline 函数 %1 及其调用者 %0 的 %2 属性不匹配'
# 'always_inline function %1 and its caller %0 have mismatching %2 attributes, inlining may change runtime behaviour'
H784367C8E6F8: 'always_inline 函数 %1 及其调用者 %0 的 %2 属性不匹配，内联可能导致运行时行为变化'
# "always_inline function %1 requires target feature '%2', but would be inlined into function %0 that is compiled without support for '%2'"
H6E58755C709F: "always_inline 函数 %1 需要目标特性 '%2'，但会被内联到未支持 '%2' 的函数 %0 中"
# 'ambiguity is between a regular call to this operator and a call with the argument order reversed'
H5C4216FCB55D: '歧义存在于对该运算符的常规调用和参数顺序颠倒的调用之间'
# 'ambiguous candidate function with reversed arguments'
H1A80B7778D2B: '具有反转参数的歧义候选函数'
# 'ambiguous cast from base %0 to derived %1:%2'
H7F294DF4B6DC: '从基类 %0 到派生类 %1 的强制转换存在歧义：%2'
# 'ambiguous constructor call when %select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1'
H33854A224B06: '在%select{复制变量|复制参数|初始化模板参数|返回对象|初始化语句表达式结果|抛出对象|复制成员子对象|复制数组元素|分配对象|复制临时对象|初始化基类子对象|初始化向量元素|捕获值}0类型 %1 的情况下，构造函数调用存在歧义'
# 'ambiguous conversion for %select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2'
H1B069BDA73DD: '从 %1 到 %2 的 %select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 转换存在歧义'
# 'ambiguous conversion from derived class %0 to base class %1:%2'
H64259C430314: '从派生类 %0 到基类 %1 的强制转换存在歧义：%2'
# 'ambiguous conversion from pointer to member of %select{base|derived}0 class %1 to pointer to member of %select{derived|base}0 class %2:%3'
H3B96453BA992: '从%select{基|派生}0类 %1 的成员指针到%select{派生|基}0类 %2 的成员指针的强制转换存在歧义：%3'
# 'ambiguous conversion from type %0 to an integral or unscoped enumeration type'
H78D40490F0F2: '将类型 %0 转换为整数类型或未命名枚举类型的强制转换存在歧义'
# 'ambiguous conversion of array size expression of type %0 to an integral or enumeration type'
H568A4E6CFAC2: '数组大小表达式类型 %0 转换为整数或枚举类型的强制转换存在歧义'
# 'ambiguous conversion of delete expression of type %0 to a pointer'
HCF8DE9DD6D85: 'delete 表达式类型 %0 转换为指针的强制转换存在歧义'
# 'ambiguous deduction for template arguments of %0'
HE14C8899D7D7: '对 %0 的模板参数推导存在歧义'
# 'ambiguous expansion of macro %0'
H401A5AED8233: '宏 %0 的展开存在歧义'
# "ambiguous marker '%0' is defined here"
HF269BA6422ED: "歧义标记 '%0' 是在这里定义的"
# 'ambiguous member function specialization %q0 of %q1'
H6A3405722F76: '%q1 的成员函数特化 %q0 存在歧义'
# 'ambiguous partial specializations of %0'
HDEE2005B7D3C: '%0 的部分特化存在歧义'
# "ambiguous reference to placeholder '_', which is defined multiple times"
HBD26597B24D2: "对占位符 '_' 的引用存在歧义，该占位符被多次定义"
# 'ambiguous use of internal linkage declaration %0 defined in multiple modules'
HE31133550012: '在多个模块中定义的内部链接声明 %0 使用存在歧义'
# 'ambiguous vftable component for %0 introduced via covariant thunks; this is an inherent limitation of the ABI'
HB0361B37BEF3: '通过协变跳转引入的 %0 的虚函数表组件存在歧义；这是ABI的固有局限性'
# 'an array type is not allowed here'
HCA0201F3FA96: '此处不允许数组类型'
# 'an attribute list cannot appear here'
H49F3FA1B7ED5: '此处不能出现属性列表'
# 'an attribute specifier sequence attached to a structured binding declaration is a C++2c extension'
H9EBA62889A30: '附加到结构化绑定声明的属性说明符序列是C++2c扩展'
# 'an attribute specifier sequence attached to a structured binding declaration is incompatible with C++ standards before C++2c'
H3AB5357520EE: '附加到结构化绑定声明的属性说明符序列与C++2c之前的C++标准不兼容'
# 'an explicit object parameter can only appear as the first parameter of a member function'
HB251EBFE2CF5: '显式对象参数只能作为成员函数的第一个参数出现'
# 'an explicit object parameter can only appear as the first parameter of the %select{function|lambda}0'
H7FA58E3ABF3F: '显式对象参数只能作为%select{函数|lambda}0 的第一个参数出现'
# 'an explicit object parameter cannot appear in a %select{constructor|destructor}0'
H75A07B3C23F5: '显式对象参数不能出现在%select{构造函数|析构函数}0中'
# 'an explicit object parameter cannot appear in a %select{static|virtual|non-member}0 %select{function|lambda}1'
HF679F4DDA00F: '显式对象参数不能出现在%select{静态|虚|非成员}0 %select{函数|lambda}1 中'
# "an explicitly-defaulted %select{copy|move}0 assignment operator may not have 'const'%select{, 'constexpr'|}1 or 'volatile' qualifiers"
HC61798127DDC: "显式默认的%select{复制|移动}0赋值运算符不能带有 'const'%select{, 'constexpr'|}1 或 'volatile' 限定符"
# 'an explicitly-defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot be variadic'
HE8693CE23671: '显式默认的%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}0不能是可变参数'
# 'an explicitly-defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot have default arguments'
H41B0D6AF186A: '显式默认的%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}0不能有默认参数'
# 'an initializer for a delegating constructor must appear alone'
H5506BF1F155E: '委托构造函数的初始化器必须单独出现'
# 'an inline asm block cannot have an operand which is a bit-field'
HD4AB7ACF49E9: '内联汇编块不能有位字段操作数'
# 'an unevaluated string literal cannot be a user-defined literal'
H7294D821E112: '未求值的字符串字面量不能是用户自定义字面量'
# 'an unevaluated string literal cannot have an encoding prefix'
HFC8ECFF25368: '未求值的字符串字面量不能带有编码前缀'
# "analyzer constraint manager 'z3' is only available if LLVM was built with -DLLVM_ENABLE_Z3_SOLVER=ON"
H156EC948497C: "分析器约束管理器 'z3' 仅当LLVM用-DLLVM_ENABLE_Z3_SOLVER=ON编译时可用"
# "analyzer-config option '%0' has a key but no value"
H5FB74FAA9043: "分析器配置选项 '%0' 有键但无值"
# "analyzer-config option '%0' should contain only one '='"
HC4A2A9D28ED1: "'analyzer-config' 选项 '%0' 应该只包含一个 '='"
# 'angle brackets contain both a %select{type|protocol}0 (%1) and a %select{protocol|type}0 (%2)'
H6C951E1E776A: '尖括号同时包含了一个%select{类型|协议}0（%1）和一个%select{协议|类型}0（%2）'
# 'angle-bracketed include <%0> cannot be aliased to double-quoted include "%1"'
H6DC7B4C3CA94: '尖括号包含的头文件 <%0> 不能被别名为双引号包含的头文件“%1”'
# 'annotate %select{%1|anonymous %1}0 with an availability attribute to silence this warning'
H1B283AC48C5C: '为 %select{%1|匿名 %1}0 添加一个可用性属性以消除此警告'
# "annotating the 'if %select{constexpr|consteval}0' statement here"
HE2CC6E318B60: "在此处注释 'if %select{constexpr|consteval}0' 语句"
# 'annotating the infinite loop here'
H4CC614D1531D: '在此处注释无限循环'
# 'annotation-type remark to collect count for'
HF59035A1D641: '需要收集计数的注释类型提醒'
# 'anonymous %select{structs|structs and classes}0 must be %select{struct or union|class}0 members'
HFBD532892EC0: '匿名%select{结构体|结构体和类}0必须是%select{结构体或联合|类}0成员'
# 'anonymous %select{structs|unions}0 are a Microsoft extension'
HFF401250AB40: '匿名%select{结构体|联合}0是Microsoft扩展'
# 'anonymous %select{struct|union}0 can only contain non-static data members'
H31B46249C247: '匿名%select{结构体|联合}0只能包含非静态数据成员'
# "anonymous %select{struct|union}0 cannot be '%1'"
HF58A2EC09112: "匿名%select{结构体|联合}0不能是 '%1'"
# 'anonymous %select{struct|union}0 cannot contain a %select{private|protected}1 data member'
HA1E08BDB3E65: '匿名%select{结构体|联合}0不能包含%select{私有|受保护}1数据成员'
# 'anonymous bit-field cannot have a default member initializer'
H71090C776F50: '匿名位字段不能有默认成员初始化器'
# 'anonymous bit-field cannot have qualifiers'
H6D3AB87CE804: '匿名位字段不能有限定符'
# 'anonymous bit-field has negative width (%0)'
HFC2DC27C32DA: '匿名位字段具有负宽度（%0）'
# 'anonymous bit-field has non-integral type %0'
HCAEF6F6FBF6D: '匿名位字段具有非整数类型 %0'
# 'anonymous namespace begins here'
H131F22F8B917: '匿名命名空间在此处开始'
# 'anonymous namespaces cannot be exported'
HD9CECEFAA4C6: '匿名命名空间无法被导出'
# 'anonymous non-C-compatible type given name for linkage purposes by %select{typedef|alias}0 declaration after its linkage was computed; add a tag name here to establish linkage prior to definition'
H4E07DEF6B927: '匿名的非C兼容类型通过 %select{typedef|alias}0 声明为链接目的命名；在定义之前添加一个标签名此处以建立链接'
# 'anonymous non-C-compatible type given name for linkage purposes by %select{typedef|alias}0 declaration; add a tag name here'
H5233EEEB5041: '匿名的非C兼容类型通过 %select{typedef|alias}0 声明为链接目的命名；此处添加一个标签名'
# 'anonymous property is not supported'
HBEA1F99304A4: '匿名属性不受支持'
# 'anonymous structs are a C11 extension'
H1E3F733CCCB4: '匿名结构体是C11的扩展'
# 'anonymous structs are a GNU extension'
H006E53420443: '匿名结构体是GNU扩展'
# 'anonymous types declared in an anonymous %select{struct|union}0 are an extension'
H3F386C85263B: '匿名%select{结构体|联合}0中的匿名类型是扩展功能'
# 'anonymous union at class scope must not have a storage specifier'
H7518631D05B0: '类作用域中的匿名联合不能有存储说明符'
# 'anonymous unions are a C11 extension'
HDFE9E6E6FE09: '匿名联合是C11的扩展'
# "anonymous unions at namespace or global scope must be declared 'static'"
H3FE1C37A16FD: "命名空间或全局作用域中的匿名联合必须声明为 'static'"
# 'append PID to saved profile file name (default: false)'
HFDE8729E14B7: '将PID附加到保存的配置文件名称（默认：false）'
# "application of '%select{alignof|sizeof}1' to interface %0 is not supported on this architecture and platform"
H7F7758BA5771: "对接口 %0 应用 '%select{alignof|sizeof}1' 在此架构和平台上不受支持"
# 'apply additional analysis to remove stores (experimental)'
H0FDD6748AD67: '应用额外分析以移除存储（实验性）'
# 'apply unchecked-ld-st when the target is definitely within range'
H75826487B47E: '当目标肯定在范围内时应用 unchecked-ld-st'
# 'applying attribute %0 to a declaration is deprecated; apply it to the type instead'
H1F568760A093: '将属性 %0 应用于声明已被弃用；请将其应用于类型'
# "architecture '%0' does not support '%1' execution mode"
H341F2DD78603: "架构 '%0' 不支持执行模式 '%1'"
# "architectures do not match: '%0' (provided) vs '%1' (found)"
H1E0CF63FB0D6: "架构不匹配：'%0'（指定的架构）与 '%1'（检测到的架构）"
# 'architectures of the coverage mapping binaries'
HC4DF8B556ACB: '覆盖映射二进制文件的架构'
# 'argument %0 is not an unqualified class type'
H5DB23C0A38DF: '参数 %0 不是未限定的类类型'
# 'argument %0 must be constant integer 1 or -1'
H4812A4DC04E0: '参数 %0 必须是常量整数 1 或-1'
# 'argument %0 of type %1 with mismatched bound'
HDE368B7DDAF1: '类型 %1 的参数 %0 具有不匹配的边界'
# 'argument %0 to %1 must be a 2-bit unsigned literal (i.e. 0, 1, 2 or 3)'
HD2DEDD810BB8: '传递给 %1 的参数 %0 必须是 2 位无符号字面量（即 0、1、2或 3）'
# "argument %0 to 'preferred_name' attribute is not a typedef for a specialization of %1"
H873B3444BA19: "'preferred_name' 属性的参数 %0 不是 %1 的特化类型的typedef"
# 'argument %0 value should represent a contiguous bit field'
H004B84FF9E91: '参数 %0 的值应表示连续的位字段'
# "argument '%0' is deprecated%select{|, use '%2' instead}1"
H549CE16A2419: '参数‘%0’已弃用 %select{|，请改用‘%2’}1'
# "argument '%0' is deprecated, %1"
HFF8BB35E32E8: '参数‘%0’已弃用，%1'
# "argument '%0' requires profile-guided optimization information"
HE99C51820EC7: "参数 '%0' 需要配置文件引导型优化信息"
# "argument '%select{X|Y|Z}0' to numthreads attribute cannot exceed %1"
H50D13BA82E10: 'numthreads属性的参数 %select{X|Y|Z}0 不能超过 %1'
# "argument '-Ofast' is deprecated; use '-O3 -ffast-math -fstack-arrays' for the same behavior, or '-O3 -fstack-arrays' to enable only conforming optimizations"
HBBD3AEA705D1: "参数 '-Ofast' 已弃用；请改用 '-O3 -ffast-math -fstack-arrays' 实现相同行为，或使用 '-O3 -fstack-arrays' 仅启用符合标准的优化"
# "argument '-Ofast' is deprecated; use '-O3 -ffast-math' for the same behavior, or '-O3' to enable only conforming optimizations"
H9474F0404E53: "参数 '-Ofast' 已弃用；请改用 '-O3 -ffast-math' 实现相同行为，或使用 '-O3' 仅启用符合标准的优化"
# "argument may not have 'void' type"
HC935448BE70B: "参数不能使用 'void' 类型"
# 'argument must be a function'
H4B920E91F120: '参数必须是函数'
# 'argument must be a string literal%select{| of char type}0'
HE9E2C9450B76: '参数必须是字符串字面量 %select{|的char类型}0'
# "argument not in expected state; expected '%0', observed '%1'"
H081944E631B6: "参数不在期望状态；期望 '%0'，实际 '%1'"
# "argument of OpenMP clause '%0' must reference the same object in all threads"
HD18A730DC43E: "OpenMP 子句 '%0' 的参数在所有线程中必须引用同一对象"
# 'argument of a linear clause should be of integral or pointer type, not %0'
HDE23CDEBD40A: '线性子句的参数应为整数类型或指针类型，而非 %0'
# 'argument of a reduction clause of a %0 construct must not appear in a firstprivate clause on a task construct'
HE3DB6952581D: '%0 构造的 reduction 子句的参数不得出现在 task 构造的 firstprivate 子句中'
# 'argument of aligned clause should be array%select{ or pointer|, pointer, reference to array or reference to pointer}1, not %0'
H3A22487A8E2A: 'aligned 子句的参数应为数组%select{或指针|、指针、数组引用或指针引用}1，而非 %0'
# 'argument required after attribute'
HE013B38B3C7C: '属性后需要参数'
# 'argument sensitivity is %select{unspecified|private|public|sensitive}0, but it should be %select{unspecified|private|public|sensitive}1'
H086D890B37E5: '参数敏感性为 %select{未指定|私有|公共|敏感}0，但应为 %select{未指定|私有|公共|敏感}1'
# 'argument should be a multiple of %0'
H17E1DE63FD3F: '参数应为 %0 的倍数'
# 'argument should be a power of 2'
H41CDA1F42637: '参数应为 2 的幂'
# 'argument should be an 8-bit value shifted by a multiple of 8 bits'
H3C662F06BF97: '参数应为向右移动 8 位的 8 位值'
# 'argument should be an 8-bit value shifted by a multiple of 8 bits, or in the form 0x??FF'
H188AFDB4C91E: '参数应为向右移动 8 位的 8 位值，或格式为 0x??FF'
# 'argument should be the value 0, 90, 180 or 270'
H8AAE066502E7: '参数应为 0、90、180 或 270'
# 'argument should be the value 90 or 270'
HE33BB0F80B1B: '参数应为 90 或 270'
# 'argument to #pragma section is not valid for this target: %0'
HC2C201A8E9D6: '#pragma section 的参数对当前目标无效: %0'
# 'argument to %0 must be a constant integer'
H66325C1A3398: '%0 的参数必须是常量整数'
# "argument to %select{'code_seg'|'section'}1 attribute is not valid for this target: %0"
H35898B1EF5C2: "属性 %select{'code_seg'|'section'}1 的参数对当前目标无效： %0"
# "argument to '#pragma unroll' should not be in parentheses in CUDA C/C++"
HBE77A0717D85: "CUDA C/C++ 中 '#pragma unroll' 的参数不应加括号"
# "argument to '%0' clause must be a %select{non-negative|strictly positive}1 integer value"
H93740956E9C9: '%0 子句的参数必须是%select{非负|严格正}1整数值'
# "argument to '%0' clause requires a value that can be represented by a 64-bit"
H628A3A124E33: '“%0”子句的参数必须能用 64 位整数表示'
# "argument to '%0' is missing (expected %1 value%s1)"
HEA17C0D34C2C: '%0 的参数缺失（应为 %1 值%s1）'
# "argument to '__ptrauth' must be an integer constant expression"
H06E460DF36C3: '__ptrauth 的参数必须是整型常量表达式'
# "argument to 'gang' clause dimension must be %select{a constant expression|1, 2, or 3: evaluated to %1}0"
H970EFD35B5B1: "'gang' 子句的维度参数必须是%select{常量表达式|1、2或 3：计算得到 %1}0"
# "argument to 'operator<=>' %select{cannot be narrowed from type %1 to %2|evaluates to %1, which cannot be narrowed to type %2}0"
HAE154D16E74A: 'operator<=> 的参数%select{不能将类型 %1 转换为更窄的类型 %2|计算结果为类型 %1，不能转换为更窄的类型 %2}0'
# "argument to 'sizeof' in %0 call is the same pointer type %1 as the %select{destination|source}2; expected %3 or an explicit length"
H35BB4F2B1E83: '在 %0 调用中的sizeof参数与%select{目标|源}2的指针类型 %1 相同；期望 %3 或显式长度'
# 'argument to __builtin_longjmp must be a constant 1'
HE5F0C7B028D7: '__builtin_longjmp 的参数必须是常量 1'
# 'argument to __builtin_verbose_trap must %select{be a pointer to a constant string|not contain $}0'
HADE59279CC5F: '__builtin_verbose_trap 的参数必须%select{是指向常量字符串的指针|不包含$}0'
# "argument to atomic builtin of type '_BitInt' is not supported"
HB64B7DD3183B: '_BitInt 类型的原子内建函数参数不受支持'
# 'argument to ptrauth_sign_constant must refer to a global variable or function'
HC3F35A99F4A4: 'ptrauth_sign_constant 的参数必须引用全局变量或函数'
# "argument type %0 doesn't match specified %1 type tag %select{that requires %3|}2"
H3BF4CB740E62: '参数类型 %0 与指定的 %1 类型标签%select{需要 %3|}2 不匹配'
# 'argument type %0 is incomplete'
HAB2CACB541C5: '参数类型 %0 是不完整的'
# 'argument type %0 is not a real floating point type'
H00F62D550C19: '参数类型 %0 不是真实的浮点类型'
# "argument unused during compilation: '%0'"
HA1050D6985F0: "编译期间未使用的参数：'%0'"
# 'argument value %0 is outside the valid range [%1, %2]'
HB96DE207738E: '参数值 %0 超出有效范围[%1, %2]'
# 'argument value %0 will result in undefined behaviour'
H274A3E69FEAC: '参数值 %0 将导致未定义行为'
# 'arguments are of different types%diff{ ($ vs $)|}0,1'
HE1B214C1584C: '参数类型不同%diff{ ($ vs $)|}0,1'
# "arguments of '#pragma omp %0' cannot be of reference type %1"
HF10A8B7C87FB: '#pragma omp %0 的参数不能是引用类型 %1'
# "arguments of '#pragma omp %0' must have %select{global storage|static storage duration}1"
H6F3268D97079: '#pragma omp %0 的参数必须具有%select{全局存储|静态存储持续时间}1'
# "arguments of OpenMP clause '%0' for 'min' or 'max' must be of %select{scalar|arithmetic}1 type"
HCCCABB9B57BC: "'min' 或 'max' 的OpenMP子句 '%0' 的参数必须是%select{标量|算术}1类型"
# "arguments of OpenMP clause '%0' in '#pragma omp %2' directive cannot be of variably-modified type %1"
HCB3B0D762A59: "在 '#pragma omp %2' 指令中，OpenMP子句 '%0' 的参数不能是可变修改类型 %1"
# "arguments of OpenMP clause '%0' with bitwise operators cannot be of floating type"
H7CE92A7D3184: "带有位运算符的OpenMP子句 '%0' 的参数不能是浮点类型"
# 'arguments to __annotation must be wide string constants'
H123CD58AB412: '__annotation的参数必须是宽字符串常量'
# "arithmetic involving unrelated objects '%0' and '%1' has unspecified value"
H620CC2CD5C97: "涉及无关对象 '%0' 和 '%1' 的算术运算具有未指定的值"
# 'arithmetic on a null pointer treated as a cast from integer to pointer is a GNU extension'
HBFE8701B60FF: '将空指针视为整数到指针转换的算术运算是一个GNU扩展'
# 'arithmetic on a pointer to %select{an incomplete|sizeless}0 type %1'
H81F0120B9A69: '对%select{不完整|无大小}0类型 %1 的指针进行算术运算'
# 'arithmetic on addresses of potentially overlapping literals has unspecified value'
H84236342B8A2: '对可能重叠的字面量地址进行算术运算具有未指定的值'
# 'arithmetic on pointer to interface %0, which is not a constant size for this architecture and platform'
H9C9B045DAD4E: '对指针进行算术运算，该指针指向接口 %0，而该接口在此架构和平台上不是固定大小'
# 'arithmetic on%select{ a|}0 pointer%select{|s}0 to void'
H58D09A5B5E7F: '对%select{一个|}0 void%select{|s}0 指针进行算术运算'
# 'arithmetic on%select{ a|}0 pointer%select{|s}0 to void is a GNU extension'
HB4BACD25A732: '对%select{一个|}0 void%select{|s}0 指针进行算术运算是一个GNU扩展'
# 'arithmetic on%select{ a|}0 pointer%select{|s}0 to%select{ the|}2 function type%select{|s}2 %1%select{| and %3}2'
H1FD9A476B84E: '对%select{一个|}0 指向%select{该|}2 函数类型 %select{|s}2 %1%select{|和 %3}2 的 %select{|s}0 指针进行算术运算'
# 'arithmetic on%select{ a|}0 pointer%select{|s}0 to%select{ the|}2 function type%select{|s}2 %1%select{| and %3}2 is a GNU extension'
H94DE585BA344: '对%select{一个|}0 指向%select{该|}2 函数类型 %select{|s}2 %1%select{|和 %3}2 的 %select{|s}0 指针进行算术运算是一个GNU扩展'
# 'array %0 declared here'
HD94D934376D0: '此处声明的数组 %0'
# "array 'new' cannot have initialization arguments"
H5708CAC5AB7B: "数组 'new' 不能有初始化参数"
# 'array argument is too small; %select{contains %0 elements|is of size %0}2, callee requires at least %1'
H8A66ED6F9EE3: '数组参数太小；%select{包含 %0 个元素|大小为 %0}2，被调用者至少需要 %1'
# 'array backing %select{initializer list subobject of the allocated object|the allocated initializer list}0 will be destroyed at the end of the full-expression'
H7FC8ADC3508D: '%select{分配对象的已分配初始化列表|初始化列表子对象}0的数组后端将在完整表达式结束时被销毁'
# 'array bound cannot be deduced from a default member initializer'
H6E170EF5C23C: '无法从默认成员初始化器推导出数组边界'
# 'array designator cannot initialize non-array type %0'
H0BB48B48E929: '数组指定符无法初始化非数组类型 %0'
# 'array designator index (%0) exceeds array bounds (%1)'
HF8952A3F237D: '数组指定符索引(%0)超出数组边界(%1)'
# 'array designator range [%0, %1] is empty'
HFAC24EA6FC3D: '数组指定符范围 [%0, %1] 为空'
# "array designator value '%0' is negative"
H02A61A71BE5A: "数组指定符值 '%0' 为负数"
# 'array designators are a C99 extension'
H09604E6E8FF6: '数组指定符是C99的扩展'
# 'array has %select{incomplete|sizeless}0 element type %1'
H513D9739D1E9: '数组的元素类型 %1%select{不完整|无大小}0'
# 'array index %0 is before the beginning of the array'
HE66AD6A3EEDD: '数组索引 %0 在数组的起始位置之前'
# 'array index %0 is past the end of the array (that has type %1%select{|, cast to %3}2)'
HB32CD52AC2F7: '数组索引 %0 超出数组末尾（该数组类型为 %1%select{|，转换为 %3}2）'
# 'array index %0 refers past the last possible element for an array in %1-bit address space containing %2-bit (%3-byte) elements (max possible %4 element%s5)'
H8C89DC3E13D9: '地址空间 %1 位中的数组包含 %2 位（%3 字节）元素，索引 %0 超出最大 %4 元素%s5'
# 'array initializer must be an initializer list%select{| or string literal| or wide string literal}0'
H4C9486DBC430: '数组初始化器必须是初始化列表 %select{|或字符串字面量|或宽字符串字面量}0'
# 'array is too large (%0 elements)'
H898DDC47DE13: '数组过大（包含 %0 个元素）'
# 'array of %0 type is invalid in OpenCL'
H394630398D52: 'OpenCL中 %0 类型的数组无效'
# 'array of abstract class type %0'
HD205577BDFE7: '类型为 %0 的抽象类数组'
# 'array of interface %0 is invalid (probably should be an array of pointers)'
H26CB6BC11BB2: '接口 %0 的数组无效（可能应为指针数组）'
# 'array parameter is missing a nullability type specifier (_Nonnull, _Nullable, or _Null_unspecified)'
HF62708756DE6: '数组参数缺少空安全性类型说明符（_Nonnull、_Nullable 或 _Null_unspecified）'
# 'array section %select{lower bound|length}0 is not an integer'
H54C64A3BE980: '数组区间的%select{下界|长度}0不是整数'
# "array section %select{lower bound|length}0 is of type 'char'"
H553F40D88798: '数组区间的%select{下界|长度}0类型为 "char"'
# 'array section does not specify contiguous storage'
HD0B03CAA79AA: '数组区间未指定连续存储'
# 'array section does not specify length for outermost dimension'
HDEBFF7152057: '数组区间未指定最外层维度的长度'
# 'array section must be a subset of the original array'
H9DAB88506A15: '数组区间必须是原始数组的子集'
# 'array shaping dimension is evaluated to a non-positive value %0'
H6C186AF92991: '数组成形维度计算结果为非正值 %0'
# 'array shaping operation dimension is not an integer'
H521C171EF9F9: '数组成形操作的维度不是整数'
# 'array size expression has incomplete class type %0'
H48253C816CFD: '数组大小表达式具有不完全类类型 %0'
# 'array size expression must have integral or %select{|unscoped }0enumeration type, not %1'
H46181D36F61E: '数组大小表达式必须是整型或 %select{|未命名 }0枚举类型，而不是 %1'
# 'array size expression of type %0 requires explicit conversion to type %1'
H08A74EE986A3: '类型 %0 的数组大小表达式需要显式转换为类型 %1'
# 'array size is negative'
H2357C6CBC81F: '数组大小为负数'
# 'array size must be specified in new expression with no initializer'
HC377DBA39626: '在没有初始化的new表达式中必须指定数组大小'
# 'array subscript is not an integer'
HCA57C5D6E89C: '数组下标不是整数'
# "array subscript is of type 'char'"
HF94CCD2B1ECE: "数组下标是类型 'char'"
# 'array type %0 is not assignable'
H89C95FEC605F: '数组类型 %0 不可赋值'
# 'array types cannot be value-initialized'
HA2673E710254: '数组类型不能进行值初始化'
# 'array-to-pointer decay of array member without known bound is not supported'
HAB3F18D32404: '未知边界的数组成员的数组到指针衰减不受支持'
# "as specified in %select{'collapse'|'ordered'|'collapse' and 'ordered'}0 clause%select{||s}0"
H1ABDD2AD30EB: "如 %select{'collapse'|'ordered'|'collapse' 和 'ordered'}0 子句 %select{||s}0 中所述"
# 'ascending'
HF393CC9965C7: '升序'
# 'asm constraint has an unexpected number of alternatives: %0 vs %1'
HF38699D505AA: 'asm约束的替代数意外：%0 vs %1'
# 'asm operand has incomplete type %0'
HAA2952BA222F: 'asm操作数具有不完整类型 %0'
# 'asm operand name "%0" first referenced here'
H8FB938C946B0: 'asm-specifier的输入或输出变量名“%0”首次引用于此'
# 'asm-specifier for input or output variable conflicts with asm clobber list'
H99E324C19D00: 'asm-specifier与asm销毁列表冲突'
# 'assertion failed during evaluation of constant expression'
H0BDBA0DDBFCA: '常量表达式求值期间断言失败'
# 'assigning %select{array literal|dictionary literal|numeric literal|boxed expression|<should not happen>|block literal}0 to a weak %select{property|variable}1; object will be released after assignment'
H8FFA1E619C25: '将%select{数组字面量|字典字面量|数字字面量|包装表达式|<不应发生>|块字面量}0赋值给弱%select{属性|变量}1；对象将在赋值后被释放'
# 'assigning %select{field|instance variable}0 to itself'
H9230F521B121: '将%select{字段|实例变量}0赋值给自己'
# 'assigning retained object to %select{weak|unsafe_unretained}0 %select{property|variable}1; object will be released after assignment'
H250CD1E6F903: '将保留对象赋值给%select{弱|unsafe_unretained}0 %select{属性|变量}1；对象将在赋值后被释放'
# 'assigning retained object to unsafe property; object will be released after assignment'
H8135CA913359: '将保留对象赋值给不安全属性；对象将在赋值后被释放'
# "assigning to 'readonly' return result of an Objective-C message not allowed"
H87457323E0B9: '不允许将Objective-C消息的只读返回结果进行赋值'
# 'assigning value of preferred signed enum type %1 to unsigned bit-field %0; negative enumerators of enum %1 will be converted to positive values'
H20F4D35FCD03: '将优选的带符号枚举类型 %1 的值赋给无符号位字段 %0；枚举类型 %1 的负枚举值将被转换为正数'
# 'assigning value of signed enum type %1 to unsigned bit-field %0; negative enumerators of enum %1 will be converted to positive values'
H03B45829D6A4: '将有符号枚举类型 %1 的值赋给无符号位字段 %0；枚举类型 %1 的负枚举值将被转换为正数'
# 'assignment of a weak-unavailable object to a __weak object'
H270A68B29DDC: '将弱不可用对象赋值给__weak对象'
# "assignment to Objective-C's isa is deprecated in favor of object_setClass()"
H4989286009CB: '对Objective-C的isa赋值已弃用，建议改用object_setClass()'
# 'assignment to cast is illegal, lvalue casts are not supported'
HADC1B6BE18D9: '对强制转换的赋值是非法的，左值强制转换不被支持'
# 'assignment would change active union member during the initialization of a different member of the same union'
HE419D89C08F2: '在联合体的另一个成员初始化期间，赋值会改变该联合体的活动成员'
# 'assume the ABI is never violated'
H2875C70D4F37: '假设从未违反ABI'
# 'assumption evaluated to false'
H4B3BD75DFF9D: '假设条件被求值为假'
# 'assumption is ignored because it contains (potential) side-effects'
H2E58C9356572: '因包含（潜在的）副作用，假设条件被忽略'
# 'at least one argument of MTE builtin function must be a pointer (%0, %1 invalid)'
H9293CC0B9621: 'MTE内建函数至少有一个参数必须是指针（%0、%1 无效）'
# 'at most one defaultmap clause for each variable-category can appear on the directive'
H95E39CFC8758: '每个变量类别只能出现一个defaultmap子句'
# "at most one overload for a given name may lack the 'overloadable' attribute"
H9206D4731FC1: "给定名称最多有一个重载函数可以不带 'overloadable' 属性"
# "at most three expressions are allowed in '%0' clause in 'target teams ompx_bare' construct"
HC1194A65DC15: "在 'target teams ompx_bare' 构造中的 '%0' 子句最多允许三个表达式"
# 'atomic %select{load|store}0 requires runtime support that is not available for this target'
HD7BAEC48A8AF: '%select{加载|存储}0原子操作需要目标不支持的运行时支持'
# "atomic by default property %0 has a user defined %select{getter|setter}1 (property should be marked 'atomic' if this is intended)"
H5A9A236EC6A5: "默认原子属性 %0 有用户定义的%select{获取器|设置器}1（若需此行为，请将属性标记为 'atomic'）"
# "atomic constraint must be of type 'bool' (found %0)"
H69DAA34C1AB6: '原子约束必须是类型=bool（发现类型 %0）'
# 'atomic memory operand must have a power-of-two size'
HB13C6FA40316: '原子内存操作数必须具有 2 的幂次方大小'
# 'atomic property of reference type %0 cannot have non-trivial assignment operator'
HFC34A950A835: '引用类型 %0 的原子属性不能具有非平凡的赋值运算符'
# "atomic types are not supported in '%0'"
H97C63071B5D3: "原子类型不被支持在 '%0' 中使用"
# 'atomic variable can be %select{assigned|initialized}0 to a variable only in global address space'
HCB0951EAACB6: '原子变量只能在全局地址空间中%select{赋值|初始化}0到另一个变量'
# 'attempt to call %0 on non-heap %select{object %2|object: block expression|object: lambda-to-function-pointer conversion}1'
H6E5B5738458E: '尝试在非堆%select{对象 %2|对象：块表达式|对象：lambda到函数指针转换}1上调用 %0'
# 'attempt to specialize declaration here'
HF06CAF52936D: '尝试在此处特化声明'
# 'attempt to use a deleted function%select{|: %1}0'
HA9C947D267C4: '尝试使用已删除的函数 %select{|: %1}0'
# 'attempt to use a poisoned identifier'
H3643F70789A4: '尝试使用已被毒化的标识符'
# 'attempting to use the forward class %0 as superclass of %1'
H994AA508EDDF: '尝试将前向声明的类 %0 用作 %1 的超类'
# 'attribute %0 after definition is ignored'
H5CD4712D502F: '属性 %0 在定义之后被忽略'
# 'attribute %0 can be used only on HLSL intangible type %1'
HF8261011AFDE: '属性 %0 仅可用于 HLSL 无形类型 %1'
# 'attribute %0 can only be applied to @protocol definitions, not forward declarations'
H308DB757AA67: '属性 %0 仅可应用于 @protocol 定义，而非前向声明'
# 'attribute %0 can only be applied to an OpenCL kernel function'
HCB6BF3FC512F: '属性 %0 仅可应用于 OpenCL 内核函数'
# 'attribute %0 cannot appear more than once on a declaration'
HB715D0AA3201: '属性 %0 不能在一个声明中出现多次'
# 'attribute %0 cannot be applied to %1'
H3AE597187391: '属性 %0 无法应用于 %1'
# 'attribute %0 cannot be applied to %select{functions|Objective-C method}1 without return value'
H1C83B6EE306A: '属性 %0 无法应用于没有返回值的 %select{函数|Objective-C 方法}1'
# "attribute %0 cannot be applied to a 'void' parameter"
H6A5920736ACF: "属性 %0 无法应用于 'void' 类型的参数"
# 'attribute %0 cannot be used as an attribute pack'
HE6BA361D74BF: '属性 %0 不能作为属性包使用'
# 'attribute %0 cannot have an argument list'
HA4D8BF32DC8E: '属性 %0 不能带有参数列表'
# 'attribute %0 does not support argument pack expansion'
H09CC6A21F4B4: '属性 %0 不支持参数包展开'
# "attribute %0 has no effect when annotating an 'if %select{constexpr|consteval}1' statement"
H409C4714E4F9: "在标注 'if %select{constexpr|consteval}1' 语句时，属性 %0 无效"
# 'attribute %0 has no effect when annotating an infinite loop'
HB06D2414EAF4: '在标注无限循环时，属性 %0 无效'
# 'attribute %0 here'
HC3F98113517C: '此处的 %0 属性'
# 'attribute %0 ignored, because it cannot be applied to a type'
H5708F2759194: '属性 %0 被忽略，因为其不能应用于类型'
# 'attribute %0 ignored, because it cannot be applied to omitted return type'
H547B25BBFFDA: '属性 %0 被忽略，因为其不能应用于省略的返回类型'
# 'attribute %0 ignored, because it is not attached to a declaration'
H14902C950EC7: '属性 %0 被忽略，因为其未附加到任何声明'
# 'attribute %0 is already applied'
HC7BD790A19A9: '属性 %0 已经被应用过'
# 'attribute %0 is already applied with different arguments'
H11C03822A58E: '属性 %0 已经用不同的参数应用过'
# 'attribute %0 is ignored, place it after "%select{class|struct|interface|union|enum|enum class|enum struct}1" to apply attribute to type declaration'
HB89779883F0D: '属性 %0 被忽略，请将其放在 "%select{类|结构体|接口|联合体|枚举|枚举类|枚举结构体}1" 之后以应用到类型声明'
# "attribute %0 is not supported by '#pragma clang attribute'"
H38205446BD5C: "属性 %0 不受 '#pragma clang attribute' 支持"
# 'attribute %0 is supported in the OpenCL version %1%select{| onwards}2'
H50454061E7F3: '属性 %0 在 OpenCL 版本 %1%select{| 及以后}2 中受支持'
# "attribute %0 is unsupported in '%1' shaders, requires %select{|one of the following: }2%3"
HFE781A72AFCA: "属性 %0 在 '%1' 着色器中不受支持，需要 %select{|以下之一: }2%3"
# 'attribute %0 only applies to %1'
HC6318570485F: '属性 %0 仅适用于 %1'
# "attribute %0 only applies to a field or parameter of type '%1'"
H552F45F43B85: '属性 %0 仅适用于类型 "%1" 的字段或参数'
# 'attribute %0 requires shader model %1 or greater'
H06BEB9F659D8: '属性 %0 需要 shader 模型 %1 或更高版本'
# 'attribute %0 with %1 arguments requires shader model %2 or greater'
H51393292A866: '带有 %1 个参数的属性 %0 需要 shader 模型 %2 或更高版本'
# 'attribute %q0 cannot be applied to a deleted function'
HCB37B8A40CF9: '属性 %q0 不能应用于已删除的函数'
# 'attribute %q0 cannot be applied to member of %q1 class'
HFBD033ADD565: '属性 %q0 不能应用于 %q1 类的成员'
# "attribute '%0' on function does not match previous declaration"
HF59632E17268: "函数上的属性 '%0' 与之前的声明不匹配"
# "attribute '%0' on overriding function does not match base declaration"
H19F6EB5D2707: "覆盖函数上的属性 '%0' 与基类声明不匹配"
# "attribute '%0' should not be added via type conversion"
HD3474317FB81: "不应通过类型转换添加属性 '%0'"
# "attribute '%select{|target|cpu_specific|cpu_dispatch|target_clones|target_version}0' multiversioned functions do not yet support %select{function templates|virtual functions|deduced return types|constructors|destructors|deleted functions|defaulted functions|constexpr functions|consteval function|lambdas}1"
HF5E6CA9178D8: "属性 '%select{|目标|CPU特定|CPU分派|目标克隆|目标版本}0' 的多版本函数尚不支持 %select{函数模板|虚函数|推导的返回类型|构造函数|析构函数|已删除函数|默认函数|constexpr函数|consteval函数|lambda表达式}1"
# "attribute '%select{|target|cpu_specific|cpu_dispatch|target_clones|target_version}0' multiversioning cannot be combined with attribute %1"
HA264FE94729F: "属性 '%select{|目标|CPU特定|CPU分派|目标克隆|目标版本}0' 的多版本功能不能与属性 %1 结合使用"
# "attribute 'msvc::constexpr' cannot be applied to the %select{constexpr|consteval|virtual}0 function %1"
HAC0996F3C628: "属性 'msvc::constexpr' 不能应用于 %select{constexpr|consteval|虚}0 函数 %1"
# "attribute 'readonly' of property %0 restricts attribute 'readwrite' of property inherited from %1"
HEB32CB97F1A3: "属性 %0 的 'readonly' 属性限制了从 %1 继承的 'readwrite' 属性"
# 'attribute declaration must precede definition'
H83850ED606E9: '属性声明必须在定义之前'
# 'attribute is here'
HD14867328E83: '属性在此处'
# "attribute is ignored on this statement as it only applies to functions; use '%0' on statements"
H8C71964DA95C: "该属性被忽略，因为它仅适用于函数；请在语句上使用 '%0'"
# 'attribute only applies to output parameters'
H05F9B2ABFA42: '该属性仅适用于输出参数'
# 'attribute with scope specifier cannot follow default scope specifier'
HFC36C268C353: '带作用域说明符的属性不能跟随默认作用域说明符'
# 'attributes \'%0("%2")\' and \'%1("%2")\' are mutually exclusive'
H56F1BA7862B2: '属性\'%0("%2")\' 和\'%1("%2")\' 是互斥的'
# 'attributes cannot be specified on a nested namespace definition'
H4264DC0CBC46: '嵌套的命名空间定义不能指定属性'
# 'attributes cannot be specified on namespace alias'
H4F2E4C4430E8: '命名空间别名不能指定属性'
# 'attributes on %select{a namespace|an enumerator}0 declaration are a C++17 extension'
H034995816099: '在%select{命名空间|枚举值}0声明上使用属性是C++17扩展'
# 'attributes on %select{a namespace|an enumerator}0 declaration are incompatible with C++ standards before C++17'
H8BB41AEA1EC6: '在%select{命名空间|枚举值}0声明上使用属性与C++17之前的版本不兼容'
# 'authenticating a null pointer will almost certainly trap'
HB0AE642AC2E4: '验证空指针几乎肯定会引发陷阱'
# 'auto property synthesis is synthesizing property not explicitly synthesized'
H0B109C7F8F74: '自动属性综合正在综合未显式综合的属性'
# 'auto property synthesis will not synthesize property %0 because it cannot share an ivar with another synthesized property'
HB5E0DEB40CE6: '自动属性综合不会合成属性 %0，因为它无法与其他综合属性共享实例变量'
# "auto property synthesis will not synthesize property %0 because it is 'readwrite' but it will be synthesized 'readonly' via another property"
H2BD61AD864B9: '自动属性综合不会合成属性 %0，因为它被标记为 "readwrite"，但将通过另一个属性被综合为 "readonly"'
# 'auto property synthesis will not synthesize property %0 declared in protocol %1'
HA0C341D1A812: '自动属性综合不会合成在协议 %1 中声明的属性 %0'
# 'auto property synthesis will not synthesize property %0; it will be implemented by its superclass, use @dynamic to acknowledge intention'
H0457D53851AF: '自动属性综合不会合成属性 %0；它将由超类实现，请使用@dynamic声明此意图'
# 'automatic variable qualified with an%select{| invalid}0 address space'
H122ACAE25198: '自动变量使用 %select{|无效}0地址空间限定'
# 'autosynthesized property %0 will use %select{|synthesized}1 instance variable %2, not existing instance variable %3'
H4495EA68D322: '自动综合的属性 %0 将使用 %select{|综合的}1实例变量 %2，而非现有实例变量 %3'
# 'availability does not match previous declaration'
H583F2A1BC062: '可用性声明与之前的声明不匹配'
# 'available multilibs are:%0'
H0F052B7170DD: '可用的多库配置是：%0'
# "backend data layout '%0' does not match expected target description '%1'"
H82DEBC38BED7: "后端数据布局 '%0' 与目标描述 '%1' 的期望定义不匹配"
# 'backslash and newline separated by space'
HD4F9A252F950: '反斜杠和换行符被空格分隔'
# 'bad receiver type %0'
HE40F679E3605: '无效的接收器类型 %0'
# "base %0 is marked '%select{final|sealed}1'"
HE6BCB4D05CEC: "基类 %0 被标记为 '%select{final|sealed}1'"
# 'base class %0 has %select{private|protected}1 destructor'
HEB04CB913679: '基类 %0 的析构函数是 %select{私有|受保护}1 的'
# 'base class %0 has a flexible array member'
HD71C5E7037F5: '基类 %0 包含柔性数组成员'
# 'base class %0 is uninitialized when used here to access %q1'
H6E433F27AF21: '使用此处的未初始化基类 %0 访问 %q1'
# 'base class %0 specified here'
HE35763C73750: '此处指定的基类 %0'
# 'base class %0 specified more than once as a direct base class'
HC14516852948: '基类 %0 被多次直接指定'
# 'base class has incomplete type'
H4B76670DCEA2: '基类具有不完整类型'
# 'base class initializer %0 names both a direct base class and an inherited virtual base class'
HAE21C251743B: '基类初始化项 %0 同时指定了直接基类和继承的虚基类'
# 'base of member reference is a function; perhaps you meant to call it%select{| with no arguments}0?'
H224FA72A413F: '成员引用的基础是一个函数；或许您想调用它 %select{|无参数}0？'
# 'base specifier must name a class'
HBDBF7667EBAE: '基类说明符必须指定一个类'
# 'basic register allocator'
HFEA9765B5A50: '基础寄存器分配器'
# 'basic statistics'
HAA78894D50F2: '基本统计信息'
# 'because %select{base class of |field of |}0type %1 has a user-provided %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}2'
HA75BA84DF85B: '因为 %select{基类的|字段的|}0 类型 %1 包含用户提供的 %select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}2'
# 'because %select{base class of |field of |}0type %1 has no default constructor'
HC07ABEF26326: '因为 %select{基类的|字段的|}0 类型 %1 没有默认构造函数'
# 'because field %0 has an initializer'
H7DB53EF856A5: '因为字段 %0 有初始化器'
# 'because it %select{is a reference type|is const|is volatile|has an ARC lifetime qualifier|is a variably-modified type|has a virtual base %1|not %select{a|an array of objects of}1 scalar or class type|has a non-trivially-relocatable base %1|has a non-trivially-relocatable member %1 of type %2|has a non-replaceable base %1|has a non-replaceable member %1 of type %2|has a non-trivially-copyable base %1|has a non-trivially-copyable member %1 of type %2|has a %select{deleted|user-provided}1 destructor|has a user provided %select{copy|move}1 constructor|has a deleted %select{copy|move}1 constructor|has a user provided %select{copy|move}1 assignment operator|has a deleted %select{copy|move}1 assignment operator|is a union with a user-declared %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}1|is a function type|is a cv void type|is an incomplete array type}0'
HF88804C54D6A: '因为它%select{是引用类型|是const类型|是volatile类型|具有ARC生命周期限定符|是可变修改类型|有一个虚基类 %1|不是%select{对象的|对象数组的}1标量或类类型|有一个不可平凡重定位的基类 %1|有一个不可平凡重定位的成员 %1（类型为 %2）|有一个不可替换的基类 %1|有一个不可替换的成员 %1（类型为 %2）|有一个不可平凡复制的基类 %1|有一个不可平凡复制的成员 %1（类型为 %2）|具有%select{已删除的|用户自定义的}1析构函数|具有用户自定义的%select{拷贝|移动}1构造函数|具有已删除的%select{拷贝|移动}1构造函数|具有用户自定义的%select{拷贝|移动}1赋值运算符|具有已删除的%select{拷贝|移动}1赋值运算符|是包含用户声明的%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}1的联合体|是函数类型|是cv void类型|是不完整数组类型}0'
# 'because it has a default argument'
H4C6DC4DA1E45: '因为它具有默认实参'
# 'because it is a variadic function'
H640DA969741B: '因为它是一个可变参数函数'
# 'because its parameter is %diff{of type $, not $|of the wrong type}2,3'
H5CB13170AE2B: '因为其参数 %diff{类型为 $，而非 $|类型错误}2,3'
# 'because no %select{<<ERROR>>|constructor|constructor|assignment operator|assignment operator|<<ERROR>>}2 can be used to %select{<<ERROR>>|copy|move|copy|move|<<ERROR>>}2 %select{base class|field|an object}0 of type %3'
HD9E44C137738: '因为无法使用 %select{<<ERROR>>|构造函数|构造函数|赋值运算符|赋值运算符|<<ERROR>>}2 %select{<<ERROR>>|拷贝|移动|拷贝|移动|<<ERROR>>}2 %select{基类|字段|对象}0 类型 %3'
# 'because of ambiguity in conversion %diff{of $ to $|between types}0,1'
HB064B974A1C3: '因为转换 %diff{类型 $ 到 $|类型之间}0,1 存在歧义'
# 'because substituted constraint expression is ill-formed%0'
H708967A94C80: '因为替换后的约束表达式存在语法错误 %0'
# 'because the function selected to %select{construct|copy|move|copy|move|destroy}2 %select{base class|field}0 of type %1 is not trivial'
H1F152D129667: '因为选择用于%select{构造|复制|移动|复制|移动|销毁}2 %select{基类|字段}0 的类型 %1 的函数不是平凡的'
# 'because type %0 has a member with %select{no|no|__strong|__weak|__autoreleasing}1 ownership'
HE992EBFC669B: '因为类型 %0 有一个成员具有%select{无|无|__strong|__weak|__autoreleasing}1 所有权'
# 'because type %0 has a virtual %select{member function|base class}1'
H45351AACBEF7: '因为类型 %0 包含虚 %select{成员函数|基类}1'
# "befriending %1 without '%select{struct|interface|union|class|enum}0' keyword is incompatible with C++98"
HDE958FBB8995: "在没有 '%select{struct|interface|union|class|enum}0' 关键字的情况下友元声明 %1 与C++98不兼容"
# 'binary RIFF format'
H555066C6C2A6: '二进制 RIFF 格式'
# 'binary fold expression has unexpanded parameter packs in both operands'
HBE3AEFF67350: '二进制折叠表达式在两个操作数中都包含未展开的模板参数包'
# 'binary integer literals are a C++14 extension'
H12BBB01421DF: '二进制整数字面量是C++14扩展'
# 'binary integer literals are a C23 extension'
HC848A482B4CC: '二进制整数字面量是C23扩展'
# 'binary integer literals are incompatible with C standards before C23'
H60CB9502C648: '二进制整数字面量与C23之前的C标准不兼容'
# 'binary integer literals are incompatible with C++ standards before C++14'
H039AFCF983A6: '二进制整数字面量与C++14之前的C++标准不兼容'
# 'binary operator not supported, only +, *, -, /, &, ^, |, <<, or >> are permitted'
H947D153F3B10: '不支持的二进制运算符，仅允许使用+, *, -, /, &, ^, |, << 或 >>'
# 'binary with the instrumentation map, or a separate instrumentation map'
HC4FD0057C615: '带有instrumentation映射的二进制文件，或单独的graph instrumentation映射'
# 'binary with the instrumentation map, or a separate instrumentation map for graph'
H2CC2C500D553: '带有instrumentation映射的二进制文件，或单独的graph 1 instrumentation映射'
# 'binary with the instrumentation map, or a separate instrumentation map for graph 1'
HAEE5C542170E: '带有instrumentation映射的二进制文件，或单独的graph 2 instrumentation映射'
# 'binary with the instrumentation map, or a separate instrumentation map for graph 2'
HC231E43E4B06: '带有instrumentation映射的二进制文件，或单独的graph 2 instrumentation映射'
# 'binary with the instrumrntation map, or a separate instrumentation map'
H0A39B12683BE: '带有instrumrntation映射的二进制文件，或单独的instrumentation映射'
# 'binding %0 cannot appear in the initializer of its own decomposition declaration'
H672061929029: '绑定 %0 不能出现在其自身分解声明的初始化器中'
# 'binding dereferenced null pointer to reference has undefined behavior'
H95EC0F6A8A66: '将空指针解引用后绑定到引用具有未定义行为'
# 'binding reference %diff{of type $ to value of type $|to value}0,1 %select{drops %3 qualifier%plural{1:|2:|4:|:s}4|changes address space|not permitted due to incompatible qualifiers}2'
H55C0D80172E9: '绑定%diff{类型$到类型$的值|到值}0,1 %select{去除 %3 %plural{1:限定符|2:限定符|4:限定符|:s}4|更改地址空间|因不兼容的限定符无法绑定}2'
# 'binding reference member %0 to stack allocated %select{variable|parameter}2 %1'
H6CEDF6C3E571: '将引用成员 %0 绑定到栈分配的%select{变量|参数}2 %1'
# "binding type '%0' is invalid"
HD0FB3A3589D6: "绑定类型 '%0' 无效"
# "binding type '%select{t|u|b|s|c|i}0' cannot be applied more than once"
H9FC4B2C35AB9: "绑定类型 '%select{t|u|b|s|c|i}0' 不能重复使用"
# "binding type '%select{t|u|b|s|c}0' only applies to %select{SRV resources|UAV resources|constant buffer resources|sampler state|numeric variables in the global scope}0"
H9DB6D490A30A: "绑定类型 '%select{t|u|b|s|c}0' 仅适用于 %select{SRV资源|UAV资源|常量缓冲区资源|采样器状态|全局作用域中的数值变量}0"
# "binding type '%select{t|u|b|s|c}0' only applies to types containing %select{SRV resources|UAV resources|constant buffer resources|sampler state|numeric types}0"
H1CE73AE71EA5: "绑定类型 '%select{t|u|b|s|c}0' 仅适用于包含 %select{SRV资源|UAV资源|常量缓冲区资源|采样器状态|数值类型}0的类型"
# "binding type 'b' only applies to constant buffers. The 'bool constant' binding type is no longer supported"
HC83E5E495198: "绑定类型 'b' 仅适用于常量缓冲区。'bool constant' 绑定类型已不再支持"
# "binding type 'c' ignored in buffer declaration. Did you mean 'packoffset'?"
H937D8317B6A5: "绑定类型 'c' 在缓冲区声明中被忽略。您是指 'packoffset' 吗？"
# "binding type 'i' ignored. The 'integer constant' binding type is no longer supported"
H2F0190E0856D: "绑定类型 'i' 被忽略。'integer constant'（整型常量）绑定类型不再受支持"
# "bit fields cannot be used to specify storage in a '%0' clause"
H5C9BE7997F9C: "位字段不能用于在 '%0' 子句中指定存储"
# 'bit-field %0 has bit-width %1 here'
H38A912E965D9: '位域 %0 此处的位宽为 %1'
# 'bit-field %0 has negative width (%1)'
HA6B3D52AF212: '位字段 %0 的宽度为负数 (%1)'
# 'bit-field %0 has non-integral type %1'
H1F66B27F57D3: '位字段 %0 的类型 %1 不是整型'
# 'bit-field %0 is not wide enough to store all enumerators of %1'
H1E7885609E9C: '位字段 %0 的宽度不足以存储枚举类型 %1 的所有枚举值'
# 'bit-field %0 is not wide enough to store all enumerators of preferred type %1'
H0D56F6137EF8: '位字段 %0 的宽度不足以存储优选类型 %1 的所有枚举值'
# 'bit-field %0 of type %1 has a different storage size than the preceding bit-field (%2 vs %3 bytes) and will not be packed under the Microsoft ABI'
H9DAB2952ED10: '类型为 %1 的位域 %0 与前一个位域的存储大小不同（%2 与 %3 字节），在Microsoft ABI下将不会被紧密打包'
# 'bit-field is declared here'
HE5CFF566169E: '位字段在此处声明'
# 'bit-fields are not supported in OpenCL'
H752654865932: 'OpenCL 不支持位字段'
# 'bit_cast %select{from|to}0 a %select{|type with a }1%select{union|pointer|member pointer|volatile|reference}2 %select{type|member}1 is not allowed in a constant expression'
H0C9C7C0B5093: 'bit_cast %select{from|to}0 的 %select{|type with a }1%select{联合|指针|成员指针|volatile|引用}2 %select{类型|成员}1 不允许出现在常量表达式中'
# 'bit_cast involving type %0 is not allowed in a constant expression; element size %1 * element count %2 is not a multiple of the byte size %3'
H3BD534784507: '涉及类型 %0 的 bit_cast 操作不允许出现在常量表达式中；元素大小 %1 * 元素数量 %2 不是字节大小 %3 的倍数'
# "bitcode library '%0' does not exist"
H551B33870D5D: "比特码库 '%0' 不存在"
# 'bitmasking for introspection of Objective-C object pointers is strongly discouraged'
H7CE8DAA0A6CB: '强烈不建议使用位掩码来检查 Objective-C 对象指针的内部结构'
# 'bitwise comparison always evaluates to %select{false|true}0'
H8A4398170F46: '按位比较始终计算为 %select{false|true}0'
# "bitwise negation of a boolean expression%select{;| always evaluates to 'true';}0 did you mean logical negation?"
HE532D6128324: "布尔表达式的按位取反 %select{;|始终计算为 'true';}0 是否应改为逻辑非运算？"
# 'bitwise or with non-zero value always evaluates to true'
H6F8F36ACC41B: '与非零值进行按位或运算始终计算为 true'
# 'block cannot return %select{array|function}0 type %1'
H91AB8D594327: '块不能返回 %select{数组|函数}0 类型 %1'
# 'block captures an autoreleasing out-parameter, which may result in use-after-free bugs'
H835D51AA87F3: '块捕获了一个自动释放的传出参数，可能导致使用已释放内存的错误'
# "block could be declared with attribute 'noreturn'"
H9307EF042F77: "该块可以使用 'noreturn' 属性进行声明"
# "block implicitly retains 'self'; explicitly mention 'self' to indicate this is intended behavior"
H094C5FEF2D2A: "块会隐式保留 'self'；若这是预期行为，请显式提及 'self'"
# 'block pointer to non-function type is invalid'
H9EFC2777265D: '指向非函数类型的块指针无效'
# 'block pointer variable %0 is %select{uninitialized|null}1 when captured by block'
H5DFD2F29C16B: '被块捕获的块指针变量 %0 的值为 %select{未初始化|null}1'
# 'block type cannot be used as expression in ternary expression in OpenCL'
HE91DFBCBC336: '块类型不能用作OpenCL三元表达式中的表达式'
# 'block will be retained by %select{the captured object|an object strongly retained by the captured object}0'
H659E73E5BC81: '块将被%select{被捕获的对象|该对象强引用的对象}0所保留'
# 'blocks support disabled - compile with -fblocks or %select{pick a deployment target that supports them|for OpenCL C 2.0 or OpenCL C 3.0 with __opencl_c_device_enqueue feature}0'
H870F6FD76494: '块功能被禁用 - 编译时需添加-fblocks选项或%select{选择支持块功能的部署目标|使用支持__opencl_c_device_enqueue特性的OpenCL C 2.0或 3.0}0'
# "blocks used in enqueue_kernel call are expected to have parameters of type 'local void*'"
H5A1C0A69E254: "enqueue_kernel调用中的block参数期望具有类型 'local void*' 类型"
# 'blocks with parameters are not accepted in this prototype of enqueue_kernel call'
H6F73FE38020E: '此enqueue_kernel调用的原型不接受带有参数的块'
# 'body of cpu_dispatch function will be ignored'
H8CCA48E04008: 'cpu_dispatch函数的函数体将被忽略'
# "bool literal returned from 'main'"
H65A070E22BD6: "'main' 函数返回了布尔字面量"
# 'both arms of conditional operator are unable to produce a constant expression'
H42234192A750: '条件运算符的两个分支均无法生成常量表达式'
# 'boundary to use for alignment of basic blocks'
H8D491EEC35CA: '用于基本块对齐的边界'
# 'brace elision for designated initializer is a C99 extension'
H98B26CB02BEA: '指定初始化器的花括号省略是C99扩展'
# 'braces around %select{scalar |}0initializer'
H5FA1CA5D46EC: '初始化器周围的%select{标量 |}0 花括号'
# 'bracket nesting level exceeded maximum of %0'
HAE0DB07D013C: '超过最大嵌套层级 %0'
# 'brackets are not allowed here; to declare an array, place the brackets after the %select{identifier|name}0'
H9FD98F06E7EB: '此处不允许使用方括号；若要声明数组，请将方括号置于%select{标识符|名称}0之后'
# 'branch probability threshold in percentage to be considered very likely'
H4385A55B36C8: '被视为非常可能的分支概率阈值（百分比）'
# 'branch probability threshold in percentage to be considered very likely when profile is available'
H7FFFD5CE40B4: '当存在配置文件时被视为非常可能的分支概率阈值（百分比）'
# 'branch relax asm'
HC2E42E8DC7A2: '分支松弛汇编'
# "build a shadowed submodule '%0'"
H9D79CC95EF50: "构建被覆盖的子模块 '%0'"
# "building module '%0' as '%1'"
H765D28E7D6EF: "正在构建模块 '%0' 为 '%1'"
# 'built-in candidate %0'
H70FA60F84316: '内建候选 %0'
# 'builtin %0 is deprecated; use %1 instead'
H3145BB7C5706: '已弃用的内建函数 %0；请改用 %1'
# 'builtin call is not valid when calling from a function without active ZA state'
H7B974CCBB78F: '从无活动ZA状态的函数调用内建函数无效'
# 'builtin call is not valid when calling from a function without active ZT0 state'
H1B7C49833DEE: '从无活动ZT0状态的函数调用内建函数无效'
# 'builtin can only be called from a %0 function'
H2DDDDEB70C80: '该内建函数只能从 %0 类型的函数调用'
# 'builtin feature check macro requires a parenthesized identifier'
HA88BFEE47095: '内建特性检查宏需要带括号的标识符'
# 'builtin functions must be directly called'
HABBC844A5E58: '内建函数必须直接调用'
# 'builtin headers belong to system modules, and _Builtin_ modules are ignored for cstdlib headers'
HFC2F5B50372D: '内建头文件属于系统模块，且_Builtin_模块在处理cstdlib头文件时被忽略'
# 'builtin is not supported on this target'
H6C31A7E5443F: '此目标不支持内建函数'
# 'builtin requires %select{spirv|spirv32 or spirv64}0 target'
HB951F2F94853: '内建函数需要 %select{spirv|spirv32或spirv64}0 目标'
# 'builtin requires%select{| at least one of the following extensions}0: %1'
HBE3E35E72C33: '内建函数需要 %select{|以下至少一个扩展}0: %1'
# "but in %select{'%1'|definition here}0 found %select{%3 referenced %plural{1:protocol|:protocols}3|%ordinal3 referenced protocol with different name %4}2"
HD3683C05282A: "但在 %select{'%1'|此处的定义}0 发现 %select{引用了 %3 %plural{1:协议|:协议}3|%ordinal3 参考的协议名称不同 %4}2"
# "but in %select{'%1'|definition here}0 found %select{%select{method %4|constructor|destructor}3 that has %5 parameter%s5|%select{method %4|constructor|destructor}3 with %ordinal5 parameter of type %6%select{| decayed from %8}7|%select{method %4|constructor|destructor}3 with %ordinal5 parameter named %6}2"
HF69A42480F6D: "但在 %select{'%1'|此处定义}0 发现 %select{%select{方法 %4|构造函数|析构函数}3 具有 %5 参数%s5|%select{方法 %4|构造函数|析构函数}3 的第 %ordinal5 参数类型为 %6%select{| 从 %8 衰减而来}7|%select{方法 %4|构造函数|析构函数}3 的第 %ordinal5 参数名为 %6}2"
# "but in %select{'%1'|definition here}0 found %select{%select{no super class|super class with type %4}3|instance variable '%3' access control is %select{|@private|@protected|@public|@package}4}2"
H07A5F408116E: "但在 %select{'%1'|定义处}0 发现 %select{%select{无基类|基类类型为 %4}3|实例变量 '%3' 的访问控制为 %select{|@private|@protected|@public|@package}4}2"
# "but in %select{'%1'|definition here}0 found %select{end of class|public access specifier|private access specifier|protected access specifier|static assert|field|method|type alias|typedef|data member|friend declaration|function template|method|instance variable|property}2"
H901B5EFBD082: "但在 %select{'%1'|定义处}0 发现 %select{类结束|公共访问说明符|私有访问说明符|保护访问说明符|静态断言|数据成员|方法|类型别名|typedef|数据成员|友元声明|函数模板|方法|实例变量|属性}2"
# "but in %select{'%1'|definition here}0 found %select{field %3|field %3 with type %4|%select{non-|}4bit-field %3|bit-field %3 with different width expression|%select{non-|}4mutable field %3|field %3 with %select{no|an}4 initializer|field %3 with a different initializer}2"
H4C900A5437EA: "但在 %select{'%1'|定义处}0 发现 %select{字段 %3|类型为 %4 的字段 %3|%select{非-|}4 位域 %3|宽度表达式不同的位域 %3|%select{非-|}4mutable字段 %3|字段 %3 具有 %select{无|一个}4初始化器|字段 %3 具有不同的初始化器}2"
# "but in %select{'%1'|definition here}0 found %select{method %3 with different return type %4|method %3 as %select{class|instance}4 method|%select{no|'required'|'optional'}3 method control|method %3 with %select{no designated initializer|designated initializer}4|%select{regular|direct}4 method %3|different method %3}2"
H9C08666CA7C3: "但在 %select{'%1'|定义处}0 发现 %select{返回类型不同的方法 %3 %4|作为 %select{类|实例}4 方法的 %3 方法|%select{无|'required'|'optional'}3 方法控制|方法 %3 具有 %select{非指定初始化器|命名初始化器}4|%select{常规|直接}4方法 %3|不同的方法 %3}2"
# "but in %select{'%1'|definition here}0 found %select{property %3|property %3 with type %4|%select{no|'required'|'optional'}3 property control|property %3 with different '%select{none|readonly|getter|assign|readwrite|retain|copy|nonatomic|setter|atomic|weak|strong|unsafe_unretained|nullability|null_resettable|class|direct}4' attribute}2"
HFF656A371ACE: "但在 %select{'%1'|定义处}0 发现 %select{属性 %3|类型为 %4 的属性 %3|%select{无|'required'|'optional'}3 属性控制|属性 %3 具有不同 '%select{none|readonly|getter|assign|readwrite|retain|copy|nonatomic|setter|atomic|weak|strong|unsafe_unretained|nullability|null_resettable|class|direct}4' 属性}2"
# "but in %select{'%1'|definition here}0 found %select{||||different static assert|different field|different method|different type alias|different typedef|different data member|different friend declaration|different function template|different method|different instance variable|different property|another unexpected decl}2"
HF376197A4A03: "但在 %select{'%1'|定义处}0 发现 %select{||||不同的静态断言|不同的数据成员|不同的方法|不同的类型别名|不同的typedef|不同的数据成员|不同的友元声明|不同的函数模板|不同的方法|不同的实例变量|不同的属性|另一个意外声明}2"
# "but in '%0' found %select{%2 base %plural{1:class|:classes}2|%2 virtual base %plural{1:class|:classes}2|%ordinal2 base class with different type %3|%ordinal2 %select{non-virtual|virtual}3 base class %4|%ordinal2 base class %3 with %select{public|protected|private|no}4 access specifier}1"
H86407D9382F4: "但在 '%0' 发现 %select{%2 基 %plural{1:类|:类}2|%2 虚基 %plural{1:类|:类}2|%ordinal2 基类类型不同 %3|%ordinal2 %select{非虚|虚}3 基类 %4|%ordinal2 基类 %3 具有 %select{公有|保护|私有|无}4 访问说明符}1"
# "but in '%0' found %select{%select{typedef|type alias}2 name %3|%select{typedef|type alias}2 %3 with different underlying type %4}1"
H5285292325BC: "但在 '%0' 中发现 %select{%select{typedef|类型别名}2 名称 %3|%select{typedef|类型别名}2 %3 具有不同基础类型 %4}1"
# "but in '%0' found %select{data member with name %2|data member %2 with different type %3|data member %2 with%select{out|}3 an initializer|data member %2 with a different initializer|data member %2 %select{is constexpr|is not constexpr}3}1"
HB02EC39C6642: "但在 '%0' 中发现 %select{名称为 %2 的数据成员|类型为 %3 的数据成员 %2|%2 数据成员 %select{out|}3 具有初始化器|%2 数据成员具有不同初始化器|%2 数据成员%select{是constexpr|不是constexpr}3}1"
# "but in '%0' found %select{different return type %2|%ordinal2 parameter with name %3|%ordinal2 parameter with type %3%select{| decayed from %5}4|%ordinal2 parameter with%select{out|}3 a default argument|%ordinal2 parameter with a different default argument|a different body}1"
H926097C3EBA4: "但在 '%0' 中发现 %select{不同返回类型 %2|第 %ordinal2 参数名称 %3|第 %ordinal2 参数类型 %3%select{| 转换自 %5}4|第 %ordinal2 参数带%select{无|}3 默认参数|第 %ordinal2 参数默认参数不同|函数体不同}1"
# "but in '%0' found %select{enum that is %select{not scoped|scoped}2|enum scoped with keyword %select{struct|class}2|enum %select{without|with}2 specified type|enum with specified type %2|enum with %2 element%s2|%ordinal2 element has name %3|%ordinal2 element %3 %select{has|does not have}4 an initializer|%ordinal2 element %3 has different initializer|}1"
H44D066860BB7: "但在 '%0' 中发现%select{枚举类型是%select{非命名空间|命名空间}2|使用 %select{struct|class}2 关键字作用域的枚举|枚举%select{没有|有}2指定类型|具有指定类型 %2 的枚举|包含 %2 个元素%s2的枚举|第%ordinal2个元素名为 %3|第%ordinal2个元素 %3%select{有|没有}4初始值设定项|第%ordinal2个元素 %3 具有不同的初始值设定项|}1"
# "but in '%0' found %select{static assert with different condition|static assert with different message|static assert with %select{|no }2message|%select{method %3|constructor|destructor}2|%select{method %3|constructor|destructor}2 is %select{not deleted|deleted}4|%select{method %3|constructor|destructor}2 is %select{not defaulted|defaulted}4|%select{method %3|constructor|destructor}2 is %select{|pure }4%select{not virtual|virtual}5|%select{method %3|constructor|destructor}2 is %select{not static|static}4|%select{method %3|constructor|destructor}2 is %select{not volatile|volatile}4|%select{method %3|constructor|destructor}2 is %select{not const|const}4|%select{method %3|constructor|destructor}2 is %select{not inline|inline}4|%select{method %3|constructor|destructor}2 with %ordinal4 parameter with%select{out|}5 a default argument|%select{method %3|constructor|destructor}2 with %ordinal4 parameter with a different default argument|%select{method %3|constructor|destructor}2 with %select{no |}4template arguments|%select{method %3|constructor|destructor}2 with %4 template argument%s4|%select{method %3|constructor|destructor}2 with %4 for %ordinal5 template argument|%select{method %3|constructor|destructor}2 with %select{no body|body}4|%select{method %3|constructor|destructor}2 with different body|friend %select{class|function}2|friend %2|friend function %2|function template %2 with %3 template parameter%s3|function template %2 with %ordinal3 template paramter being a %select{type|non-type|template}4 template parameter|function template %2 with %ordinal3 template parameter %select{with no name|named %5}4|function template %2 with %ordinal3 template parameter with %select{no |}4default argument|function template %2 with %ordinal3 template parameter with default argument %4|function template %2 with %ordinal3 template parameter with different type|function template %2 with %ordinal3 template parameter %select{not |}4being a template parameter pack|}1"
H650FCD73F7BC: "但在 '%0' 中发现 %select{具有不同条件的静态断言|具有不同消息的静态断言|具有 %select{|无 }2消息的静态断言|%select{方法 %3|构造函数|析构函数}2|%select{方法 %3|构造函数|析构函数}2 是 %select{未删除|已删除}4|%select{方法 %3|构造函数|析构函数}2 是 %select{未默认|已默认}4|%select{方法 %3|构造函数|析构函数}2 是 %select{|纯 }4%select{非虚|虚}5|%select{方法 %3|构造函数|析构函数}2 是 %select{非静态|静态}4|%select{方法 %3|构造函数|析构函数}2 是 %select{非volatile|volatile}4|%select{方法 %3|构造函数|析构函数}2 是 %select{非const|const}4|%select{方法 %3|构造函数|析构函数}2 是 %select{非内联|内联}4|%select{方法 %3|构造函数|析构函数}2 的第 %ordinal4 参数带有%select{出|}5 默认参数|%select{方法 %3|构造函数|析构函数}2 的第 %ordinal4 参数具有不同默认参数|%select{方法 %3|构造函数|析构函数}2 具有%select{无|有}4模板参数|%select{方法 %3|构造函数|析构函数}2 具有 %4 模板参数%s4|%select{方法 %3|构造函数|析构函数}2 具有 %4 作为第 %ordinal5 模板参数|%select{方法 %3|构造函数|析构函数}2 具有%select{无|有}4函数体|%select{方法 %3|构造函数|析构函数}2 具有不同函数体|友元 %select{类|函数}2|友元 %2|友元函数 %2|函数模板 %2 具有 %3 模板参数%s3|函数模板 %2 具有第 %ordinal3 模板参数是 %select{类型|非类型|模板}4 模板参数|函数模板 %2 具有第 %ordinal3 模板参数%select{无名称|名称为 %5}4|函数模板 %2 具有第 %ordinal3 模板参数%select{无|}4 默认参数|函数模板 %2 具有第 %ordinal3 模板参数默认参数 %4|函数模板 %2 具有第 %ordinal3 模板参数类型不同|函数模板 %2 具有第 %ordinal3 模板参数%select{不|}4 是模板参数包|}1"
# "but in '%0' found %select{unnamed template parameter %2|template parameter %3|template parameter with %select{no |}2default argument|template parameter with different default argument}1"
HA18966A0FC1B: "但在 '%0' 中发现 %select{无名称模板参数 %2|模板参数 %3|模板参数%select{无 |}2 默认参数|模板参数具有不同默认参数}1"
# "by value capture of '*this' is incompatible with C++ standards before C++17"
H60BDFA125D23: "在C++17之前的C++标准中，通过值捕获 '*this' 是不兼容的"
# 'by-copy capture of value of abstract type %0'
H69470A21D7A2: '对抽象类型 %0 的值进行拷贝捕获'
# 'by-copy capture of variable %0 with %select{incomplete|sizeless}1 type %2'
H0B21D37A79AB: '通过复制捕获变量 %0，其类型 %2 是%select{不完整类型|零大小}1'
# 'cache-aware duplication strategy'
HF9F924A27610: '缓存感知复制策略'
# 'calculate and print various metrics for instruction cache'
HE98D77A3BA25: '计算并打印指令缓存的各种指标'
# 'call to %0 implicitly required by coroutine function here'
H58DB024E2029: '协程函数在此处隐式调用 %0'
# 'call to %0 is ambiguous'
HE4A087079576: '调用 %0 时存在歧义'
# 'call to %select{immediate|consteval}1 function %q0 is not a constant expression'
H00D075778CD9: '%select{立即|consteval}1 函数 %q0 的调用不是常量表达式'
# 'call to %select{non-static|explicit}0 member function without an object argument'
H63B47EF20C66: '调用%select{非静态|显式}0 成员函数时缺少对象参数'
# 'call to %select{placement|class-specific}0 %1'
H295DBDE7B5BD: '调用 %select{placement|类特异性}0 %1'
# "call to '%0' declared with 'error' attribute: %1"
HDBB58BF71CEC: "调用用 'error' 属性声明的 '%0' 函数： %1"
# "call to '%0' declared with 'warning' attribute: %1"
H3865B6C0D901: "调用用 'warning' 属性声明的 '%0' 函数： %1"
# "call to '%select{__builtin_operator_new|__builtin_operator_delete}0' selects non-usual %select{allocation|deallocation}0 function"
H676581AF4E96: "调用 '%select{__builtin_operator_new|__builtin_operator_delete}0' 选择了非常规%select{分配|释放}0函数"
# "call to '%select{initial_suspend|final_suspend}0' implicitly required by the %select{initial suspend point|final suspend point}0"
H1C6B1E5ADCED: '在%select{初始挂起点|最终挂起点}0处隐式调用 %select{initial_suspend|final_suspend}0'
# "call to 'await_transform' implicitly required by 'co_await' here"
HA0503466B398: "'co_await' 在此处隐式调用 'await_transform' 函数"
# "call to a function that shares state other than 'za' from a function that has live 'za' state requires a spill/fill of ZA, which is not yet implemented"
H8FF6C74595CF: "从具有活动ZA状态的函数调用共享ZA状态（非 'za'）的函数需要保存/恢复ZA状态，但该功能尚未实现"
# 'call to a shared ZA function requires the caller to have ZA state'
H755688EF43BB: '调用共享ZA函数需要调用方具有ZA状态'
# 'call to a shared ZT0 function requires the caller to have ZT0 state'
H89ACEBE543C2: '调用共享ZT0函数需要调用方具有ZT0状态'
# "call to a streaming function requires 'sme'"
H41309CFB27F8: "调用流式函数需要 'sme'"
# 'call to constructor of %0 is ambiguous'
H00A38B0315FF: '调用 %0 构造函数时存在歧义'
# 'call to deleted constructor of %0%select{|: %2}1'
HAA8E5FBCBA79: '调用已删除的 %0 构造函数 %select{|： %2}1'
# 'call to deleted function call operator in type %0%select{|: %2}1'
H8F857BEAC26F: '调用类型 %0 中的已删除函数调用运算符 %select{|： %2}1'
# 'call to deleted%select{| member}0 function %1%select{|: %3}2'
H6B002A51A7D4: '调用已删除 %select{|成员}0函数 %1%select{|： %3}2'
# 'call to function %0 that is neither visible in the template definition nor found by argument-dependent lookup'
H225588528963: '调用在模板定义中不可见且无法通过参数相关查找找到的函数 %0'
# 'call to global function %0 not configured'
HC08574A55FB5: '调用未配置的全局函数 %0'
# 'call to implicitly-deleted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|function}0 of %1'
H4C623CF7C837: '调用 %1 的隐式删除的%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数|函数}0'
# 'call to member function %0 is ambiguous'
H60EE3A6ABF6A: '调用成员函数 %0 时发生歧义'
# 'call to object of type %0 is ambiguous'
H3783B2A8DBDC: '调用类型 %0 的对象时发生歧义'
# "call to pointer to member function of type %0 drops '%1' qualifier%s2"
HC75C3E40313D: "调用类型 %0 的成员函数指针时丢失 '%1' 限定符%s2"
# 'call to pseudo-destructor cannot have any arguments'
H6ECE40631FC9: '伪析构函数调用不能带有任何参数'
# 'call to pure virtual member function %0 has undefined behavior; overrides of %0 in subclasses are not available in the %select{constructor|destructor}1 of %2'
HDC8AD43C5C1C: '调用纯虚成员函数 %0 会产生未定义行为；%2 的%select{构造函数|析构函数}1 中不可访问子类对 %0 的重载'
# 'call to subscript operator of type %0 is ambiguous'
H1E29AAB6AD84: '类型 %0 的下标运算符调用发生歧义'
# 'call to undeclared function %0; ISO C99 and later do not support implicit function declarations'
HEBF384E2E2A6: '调用未声明函数 %0；ISO C99及后续标准不支持隐式函数声明'
# "call to undeclared library function '%0' with type %1; ISO C99 and later do not support implicit function declarations"
HF288A58FA40B: "调用未声明的库函数 '%0'（类型 %1）；ISO C99及后续标准不支持隐式函数声明"
# 'call to unsupported expression with unknown type'
H239ACE39DA12: '调用类型未知的不受支持的表达式'
# 'called by %0'
HDC9A013B796D: '被 %0 调用'
# 'called object type %0 is not a function or function pointer'
H5E3F97BDB14E: '被调用对象类型 %0 不是函数或函数指针'
# 'callee declares array parameter as static here'
H80DA3F678F9A: '被调用函数在此处将数组参数声明为static'
# "calling %0 is a violation of trusted computing base '%1'"
HF890EA6739C7: "调用 %0 违反了可信计算基 '%1'"
# 'calling %0 with incomplete return type %1'
H218BBBD759BD: '调用具有不完整返回类型的 %0（返回类型 %1）'
# "calling '%0' with a nonzero argument is unsafe"
H373CF9276563: "调用 '%0' 时传入非零参数是不安全的"
# 'calling a %select{private|protected}0 constructor of class %2'
H1D7B9B5BEE0D: '调用类 %2 的%select{私有|受保护}0构造函数'
# 'calling a %select{private|protected}1 destructor of class %0'
H2870B0B82BD7: '调用类 %0 的%select{私有|受保护}1析构函数'
# "calling function %0 requires negative capability '%1'"
HB81388BC5C94: "调用函数 %0 需要负能力 '%1'"
# "calling function %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
HF6312AC18647: "调用函数 %1 需要持有 %0 %select{'%2'|'%2' 独占}3"
# 'calling function with incomplete return type %0'
H47066D05EDB3: '调用具有不完整返回类型的函数 %0'
# 'calls the given entry-point on a new thread (jit-kind=orc-lazy only)'
HD909298BB334: '在新线程上调用给定的入口点（仅jit-kind=orc-lazy适用）'
# 'calls to OpenMP runtime API are not allowed within a region that corresponds to a construct with an order clause that specifies concurrent'
HF0FE255D765C: '在对应具有并发指定order子句的构造体的区域内不允许调用OpenMP运行时API'
# 'can only access this member on an object of type %0'
H97DBB9710EB7: '只能在类型 %0 的对象上访问该成员'
# 'can only poison identifier tokens'
HBA757282B22F: '只能毒化标识符标记'
# 'can only provide an explicit specialization for a class template, function template, variable template, or a member function, static data member, %select{or member class|member class, or member enumeration}0 of a class template'
H705307E2F906: '只能为类模板、函数模板、变量模板或类模板的成员函数、静态数据成员%select{或成员类|成员类、或成员枚举}0提供显式特化'
# "can only use 'init_priority' attribute on file-scope definitions of objects of class type"
H2C248D12A320: "只能将 'init_priority' 属性用于类类型对象的文件作用域定义"
# 'candidate %select{constructor|template}0 ignored: inherited constructor cannot be used to %select{copy|move}1 object'
HA2E8E747932F: '候选%select{构造函数|模板}0被忽略：继承的构造函数不能用于%select{拷贝|移动}1对象'
# 'candidate %select{constructor|template}0 ignored: instantiation %select{takes|would take}0 its own class type by value'
H5F81F51806D8: '候选%select{构造函数|模板}0被忽略：实例化%select{需要|需要}0按值获取自身类类型'
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 has been %select{explicitly made unavailable|explicitly deleted|implicitly deleted}3"
HDF3920A3A1F2: "候选%select{函数|函数|参数顺序反转的函数|构造函数|类模板隐式默认构造函数|类模板隐式拷贝构造函数|类模板隐式移动构造函数|隐式拷贝赋值运算符|隐式移动赋值运算符|隐式 'operator==' 运算符|继承构造函数}0%select{|模板| %2}1 已被%select{显式禁用|显式删除|隐式删除}3"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %ordinal5 argument (%3) would lose %select{const|restrict|const and restrict|volatile|const and volatile|volatile and restrict|const, volatile, and restrict}4 qualifier%select{||s||s|s|s}4"
H95E4AEB3B23E: "候选%select{函数|函数|参数顺序反转的函数|构造函数|类模板隐式默认构造函数|类模板隐式拷贝构造函数|类模板隐式移动构造函数|隐式拷贝赋值运算符|隐式移动赋值运算符|隐式 'operator==' 运算符|继承构造函数}0%select{|模板| %2}1 不可行：第%ordinal5参数（%3）将丢失 %select{const|restrict|const和restrict|volatile|const和volatile|volatile和restrict|const、volatile和restrict}4 限定符 %select{||s||s|s|s}4"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %ordinal8 argument (%3) has %select{no '__ptrauth'|%5}4 qualifier, but parameter has %select{no '__ptrauth'|%7}6 qualifier"
HD856C23A94D5: "%select{候选函数|候选函数|候选函数（参数顺序相反）|构造函数|构造函数（隐式默认构造函数）|构造函数（隐式拷贝构造函数）|构造函数（隐式移动构造函数）|函数（隐式拷贝赋值运算符）|函数（隐式移动赋值运算符）|函数（隐式 'operator==' 用于此 'operator<=>'）|继承的构造函数}0%select{| 模板| %2}1 不可行：第 %ordinal8 个参数（%3）的类型%select{没有 '__ptrauth'|%5}4 限定符，但参数要求%select{没有 '__ptrauth'|%7}6 限定符"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %select{%ordinal7|'this'}6 argument (%3) has %select{no|__unsafe_unretained|__strong|__weak|__autoreleasing}4 ownership, but parameter has %select{no|__unsafe_unretained|__strong|__weak|__autoreleasing}5 ownership"
H8D414CDC2F4E: "候选%select{函数|函数|参数顺序反转的函数|构造函数|类模板隐式默认构造函数|类模板隐式拷贝构造函数|类模板隐式移动构造函数|隐式拷贝赋值运算符|隐式移动赋值运算符|隐式 'operator==' 运算符|继承构造函数}0%select{|模板| %2}1 不可行：%select{第%ordinal7|'this'}6 参数（%3）具有%select{无|__unsafe_unretained|__strong|__weak|__autoreleasing}4 所有权，但参数需要%select{无|__unsafe_unretained|__strong|__weak|__autoreleasing}5 所有权"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %select{%ordinal7|'this'}6 argument (%3) has %select{no|__weak|__strong}4 ownership, but parameter has %select{no|__weak|__strong}5 ownership"
HFD1E148AC849: "候选%select{函数|函数|参数顺序反转的函数|构造函数|类模板隐式默认构造函数|类模板隐式拷贝构造函数|类模板隐式移动构造函数|隐式拷贝赋值运算符|隐式移动赋值运算符|隐式 'operator==' 运算符|继承构造函数}0%select{|模板| %2}1 不可行：%select{第%ordinal7|'this'}6 参数（%3）具有%select{无|__weak|__strong}4 所有权，但参数需要%select{无|__weak|__strong}5 所有权"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %select{cannot convert initializer list|too few initializers in list|too many initializers in list}7 argument to %4"
H4C57102C9323: "候选%select{函数|函数|参数顺序反转的函数|构造函数|类模板隐式默认构造函数|类模板隐式拷贝构造函数|类模板隐式移动构造函数|隐式拷贝赋值运算符|隐式移动赋值运算符|隐式 'operator==' 运算符|继承构造函数}0%select{|模板| %2}1 不可行：%select{无法转换初始化列表|列表初始化器太少|列表初始化器过多}7参数到 %4"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %select{requires at least|allows at most single|requires single}3 %select{|non-object }6argument %4, but %plural{0:no|:%5}5 arguments were provided"
H8AD4B8B6097C: "候选 %select{函数|函数|参数顺序反转的函数|构造函数|隐式默认构造函数|隐式拷贝构造函数|隐式移动构造函数|隐式赋值运算符|隐式移动赋值运算符|隐式 'operator=='（对应三向比较运算符）|继承的构造函数}0%select{| 模板| %2}1 不可用：需要 %select{至少|最多一个|一个}3 %select{非对象|}6 参数 %4，但提供 %plural{0:0|:%5}5 个参数"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: 'this' argument has type %3, but method is not marked %select{const|restrict|const or restrict|volatile|const or volatile|volatile or restrict|const, volatile, or restrict}4"
HE6BBB39EEE68: "候选%select{函数|函数|参数顺序反转的函数|构造函数|类模板隐式默认构造函数|类模板隐式拷贝构造函数|类模板隐式移动构造函数|隐式拷贝赋值运算符|隐式移动赋值运算符|隐式 'operator==' 运算符|继承构造函数}0%select{|模板| %2}1 不可行：'this' 参数具有类型 %3，但方法未标记为 %select{const|restrict|const或restrict|volatile|const或volatile|volatile或restrict|const、volatile或restrict}4"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: 'this' object is in %3, but method expects object in %4"
H7EDBF536C9E0: "候选%select{函数|函数|参数顺序反转的函数|构造函数|类模板隐式默认构造函数|类模板隐式拷贝构造函数|类模板隐式移动构造函数|隐式拷贝赋值运算符|隐式移动赋值运算符|隐式 'operator==' 运算符|继承构造函数}0%select{|模板| %2}1 不可行：'this' 对象处于 %3 状态，但方法期望处于 %4 状态"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: call to %select{__device__|__global__|__host__|__host__ __device__|invalid}3 function from %select{__device__|__global__|__host__|__host__ __device__|invalid}4 function"
HB286FD7ADB16: "候选%select{函数|函数|参数顺序反转的函数|构造函数|类模板隐式默认构造函数|类模板隐式拷贝构造函数|类模板隐式移动构造函数|隐式拷贝赋值运算符|隐式移动赋值运算符|隐式 'operator==' 运算符|继承构造函数}0%select{|模板| %2}1 不可行：从 %select{__device__|__global__|__host__|__host__ __device__|无效}4函数调用 %select{__device__|__global__|__host__|__host__ __device__|无效}3函数"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: cannot %select{convert from|convert from|bind}3 %select{base class pointer|superclass|base class object of type}3 %4 to %select{derived class pointer|subclass|derived class reference}3 %5 for %ordinal6 argument"
H9EF538024430: "候选%select{函数|函数|参数顺序反转的函数|构造函数|类模板隐式默认构造函数|类模板隐式拷贝构造函数|类模板隐式移动构造函数|隐式拷贝赋值运算符|隐式移动赋值运算符|隐式 'operator==' 运算符|继承构造函数}0%select{|模板| %2}1 不可行：无法%select{将|将|绑定}3%select{基类指针|基类|基类对象}3 %4 转换为%select{派生类指针|派生类|派生类引用}3 %5 作为第%ordinal6参数"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: cannot %select{pass pointer to|bind reference in}5 %3 %select{as a pointer to|to object in}5 %4 in %ordinal6 argument"
HEE13EA6B12B0: "候选%select{函数|函数|参数顺序反转的函数|构造函数|类模板隐式默认构造函数|类模板隐式拷贝构造函数|类模板隐式移动构造函数|隐式拷贝赋值运算符|隐式移动赋值运算符|隐式 'operator==' 运算符|继承构造函数}0%select{|模板| %2}1 不可行：无法%select{将指针转换为|在引用中绑定}5 %3 %select{作为指向|到}5 %4 的%ordinal6参数"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: cannot convert argument of incomplete type %diff{$ to $|to parameter type}3,4 for %select{%ordinal6 argument|object argument}5%select{|; dereference the argument with *|; take the address of the argument with &|; remove *|; remove &}7"
H3F2CD3D64E80: "候选 %select{函数|函数|函数（参数顺序反转）|构造函数|构造函数（隐式默认构造函数）|构造函数（隐式拷贝构造函数）|构造函数（隐式移动构造函数）|函数（隐式拷贝赋值运算符）|函数（隐式移动赋值运算符）|函数（为此 'operator<=>' 隐式生成的 'operator=='）|继承的构造函数}0%select{|模板| %2}1 不可用：无法将不完整类型 %diff{的参数从 $ 转换为 $|的参数类型转换为参数类型}3,4 的 %select{%ordinal6 参数|对象参数}5%select{|; 通过 * 解引用参数|; 使用 & 获取参数的地址|; 移除 *|; 移除 &}7"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: cannot implicitly convert argument %diff{of type $ to $|type to parameter type}3,4 for %select{%ordinal6 argument|object argument}5 under ARC"
H2B5B49758162: "候选 %select{函数|函数|函数（参数顺序反转）|构造函数|构造函数（隐式默认构造函数）|构造函数（隐式拷贝构造函数）|构造函数（隐式移动构造函数）|函数（隐式拷贝赋值运算符）|函数（隐式移动赋值运算符）|函数（为此 'operator<=>' 隐式生成的 'operator=='）|继承的构造函数}0%select{|模板| %2}1 不可用：在 ARC 下无法隐式将类型 %diff{的参数从 $ 转换为 $|参数类型转换为目标类型}3,4 的 %select{%ordinal6 参数|对象参数}5"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: constraints not satisfied"
H01514E19EB13: "候选 %select{函数|函数|函数（参数顺序反转）|构造函数|构造函数（隐式默认构造函数）|构造函数（隐式拷贝构造函数）|构造函数（隐式移动构造函数）|函数（隐式拷贝赋值运算符）|函数（隐式移动赋值运算符）|函数（为此 'operator<=>' 隐式生成的 'operator=='）|继承的构造函数}0%select{|模板| %2}1 不可用：约束条件不满足"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: expects an %select{lvalue|rvalue}5 for %select{%ordinal4 argument|object argument}3"
H5778CD649B7A: "候选 %select{函数|函数|函数（参数顺序反转）|构造函数|构造函数（隐式默认构造函数）|构造函数（隐式拷贝构造函数）|构造函数（隐式移动构造函数）|函数（隐式拷贝赋值运算符）|函数（隐式移动赋值运算符）|函数（为此 'operator<=>' 隐式生成的 'operator=='）|继承的构造函数}0%select{|模板| %2}1 不可用：需要 %select{lvalue|rvalue}5 类型的 %select{%ordinal4 参数|对象参数}3"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: no known conversion %diff{from $ to $|from argument type to parameter type}3,4 for %select{%ordinal6 argument|object argument}5%select{|; dereference the argument with *|; take the address of the argument with &|; remove *|; remove &}7"
H2C02021665E8: "候选 %select{函数|函数|函数（参数顺序反转）|构造函数|构造函数（隐式默认构造函数）|构造函数（隐式拷贝构造函数）|构造函数（隐式移动构造函数）|函数（隐式拷贝赋值运算符）|函数（隐式移动赋值运算符）|函数（为此 'operator<=>' 隐式生成的 'operator=='）|继承的构造函数}0%select{|模板| %2}1 不可用：无法将 %diff{参数类型从 $ 转换为 $|参数类型转换为目标类型}3,4 的 %select{%ordinal6 参数|对象参数}5%select{|; 通过 * 解引用参数|; 使用 & 获取参数的地址|; 移除 *|; 移除 &}7"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: no overload of %4 matching %3 for %ordinal5 argument"
H327F9AFBF1B4: "候选 %select{函数|函数|函数（参数顺序反转）|构造函数|构造函数（隐式默认构造函数）|构造函数（隐式拷贝构造函数）|构造函数（隐式移动构造函数）|函数（隐式拷贝赋值运算符）|函数（隐式移动赋值运算符）|函数（为此 'operator<=>' 隐式生成的 'operator=='）|继承的构造函数}0%select{|模板| %2}1 不可用：%4 的 %3 不匹配 %ordinal5 参数的重载"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: requires%select{ at least| at most|}3 %4 %select{|non-object }6argument%s4, but %5 %plural{1:was|:were}5 provided"
HE70B20B055FA: "候选 %select{函数|函数|函数（参数顺序反转）|构造函数|构造函数（隐式默认构造函数）|构造函数（隐式拷贝构造函数）|构造函数（隐式移动构造函数）|函数（隐式拷贝赋值运算符）|函数（隐式移动赋值运算符）|函数（为此 'operator<=>' 隐式生成的 'operator=='）|继承的构造函数}0%select{|模板| %2}1 不可用：需要%select{ 至少| 至多|}3 %4 %select{|非对象 }6参数%s4，但提供了 %5 %plural{1:1个|:多个}5"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %3}1%select{| has different class%diff{ (expected $ but has $)|}5,6| has different number of parameters (expected %5 but has %6)| has type mismatch at %ordinal5 parameter%diff{ (expected $ but has $)|}6,7| has different return type%diff{ ($ expected but has $)|}5,6| has different qualifiers (expected %5 but found %6)| has different exception specification}4"
H8C85DA7348D1: "候选%select{函数|函数|参数顺序反转的函数|构造函数|隐式的默认构造函数|隐式的拷贝构造函数|隐式的移动构造函数|隐式的拷贝赋值运算符|隐式的移动赋值运算符|为该 'operator<=>' 隐式声明的'operator==|继承的构造函数}0%select{|模板| %3}1%select{| 类型不同%diff{（期望$ 但实际为$)|}5,6| 参数数量不同（期望 %5 但实际为 %6)| 第%ordinal5个参数类型不匹配%diff{（期望$ 但实际为$)|}6,7| 返回类型不同%diff{（$ 期望但实际为$)|}5,6| 返回类型修饰符不同（期望 %5 但实际为 %6)| 异常规格说明不同}4"
# 'candidate address cannot be taken because parameter %0 has pass_object_size attribute'
H9C284929AC5A: '无法获取候选地址，因为参数 %0 具有 pass_object_size 属性'
# 'candidate constructor ignored: cannot be used to construct an object in address space %0'
H02A4FA176268: '候选构造函数被忽略：无法用于创建地址空间 %0 的对象'
# 'candidate disabled: %0'
H7028C3991AD2: '候选被禁用： %0'
# 'candidate found by name lookup is %q0'
H25F5CFEAA3CA: '名称查找找到的候选为 %q0'
# 'candidate function made ineligible by enable_if'
HF67E18BC374D: '候选函数因 enable_if 被排除'
# 'candidate function with non-reversed arguments'
H8514B0198804: '候选函数（参数顺序未反转）'
# 'candidate ignored: %select{not a function template|not a member of the enclosing %select{class template|namespace; did you mean to explicitly qualify the specialization?}1}0'
H46E51FE9BF5C: '候选被忽略：%select{非函数模板|非外围 %select{类模板|命名空间的成员；是否需要显式限定特化？}1}0'
# 'candidate template ignored: cannot deduce a type for %0 that would make %2 equal %1'
H7E4350C35AB8: '候选模板被忽略：无法推导 %0 的类型以使 %2 等同于 %1'
# 'candidate template ignored: constraints not satisfied%0'
H6E9C2A6AF9DA: '候选模板被忽略：约束条件不满足 %0'
# 'candidate template ignored: could not match %diff{$ against $|types}0,1'
HBFC6A5130527: '候选模板被忽略：无法将 %diff{$ 与 $ 匹配|类型}0,1'
# 'candidate template ignored: could not match %q0 against %q1'
H95615A85BC94: '候选模板被忽略：无法将 %q0 与 %q1 匹配'
# "candidate template ignored: couldn't infer template argument %0"
H0865F809FC7F: '候选模板被忽略：无法推导模板参数 %0'
# 'candidate template ignored: deduced %select{conflicting types|conflicting values|conflicting templates|packs of different lengths}0 for parameter %1%diff{ ($ vs. $)|}2,3'
HC96827B6C1DA: '候选模板被忽略：推导出的%select{冲突的类型|冲突的值|冲突的模板|不同长度的包}0对于参数 %1%diff{ ($ vs. $)|}2,3'
# 'candidate template ignored: deduced too few arguments for expanded pack %0; no argument for %ordinal1 expanded parameter in deduced argument pack %2'
HCCA72493BB47: '候选模板被忽略：为展开的参数包 %0 推断出的参数过少；在推断出的参数包 %2 中没有为第%ordinal1 展开的参数提供参数'
# 'candidate template ignored: deduced type %diff{$ of %select{|element of }4%ordinal0 parameter does not match adjusted type $ of %select{|element of }4argument|of %select{|element of }4%ordinal0 parameter does not match adjusted type of %select{|element of }4argument}1,2%3'
HF6006A393B95: '候选模板被忽略：推导出的类型 %diff{$ of %select{|element of }4%ordinal0参数与调整后的类型$ of %select{|element of }4实参不匹配|of %select{|element of }4%ordinal0参数与调整后的 %select{|element of }4实参类型不匹配}1,2%3'
# 'candidate template ignored: deduced values %diff{of conflicting types for parameter %0 (%1 of type $ vs. %3 of type $)|%1 and %3 of conflicting types for parameter %0}2,4'
H300B96CC7A66: '模板候选被忽略：推导值 %diff{为参数 %0 的类型冲突（%1 类型 $ 与 %3 类型 $）|参数 %0 的 %1 和 %3 类型冲突}2,4'
# 'candidate template ignored: disabled by %0%1'
H0A4EC193E9D6: '候选模板被忽略：被 %0%1 禁用'
# 'candidate template ignored: failed template argument deduction'
HF2D6EBE56EA1: '候选模板被忽略：模板实参推导失败'
# 'candidate template ignored: invalid explicitly-specified argument for %ordinal0 template parameter'
H7C80ECA5E832: '候选模板被忽略：为第%ordinal0个模板参数显式指定的实参无效'
# 'candidate template ignored: invalid explicitly-specified argument for template parameter %0'
HEDC828688F33: '候选模板被忽略：为模板参数 %0 显式指定的实参无效'
# "candidate template ignored: requirement '%0' was not satisfied%1"
HB155E3417C9D: '候选模板被忽略：要求‘%0’未满足 %1'
# 'candidate template ignored: substitution exceeded maximum template instantiation depth'
H6065ACD0EE36: '候选模板被忽略：替换超过了模板实例化深度的最大值'
# 'candidate template ignored: substitution failure%0%1'
HF32FE861D856: '候选模板被忽略：替换失败 %0%1'
# 'candidate template ignored: target attributes do not match'
H8F2E4648A7AB: '候选模板被忽略：目标属性不匹配'
# "cannot %select{#include files|import headers}0 inside '#pragma clang arc_cf_code_audited'"
HE8C6864AFFBD: "无法在 '#pragma clang arc_cf_code_audited' 内%select{包含文件|导入头文件}0"
# "cannot %select{#include files|import headers}0 inside '#pragma clang assume_nonnull'"
H5A02E21DB221: "无法在 '#pragma clang assume_nonnull' 内%select{包含文件|导入头文件}0"
# 'cannot %select{access base class of|access derived class of|access field of|access array element of|ERROR|access real component of|access imaginary component of}0 pointer past the end of object'
HBEBB0813D273: '无法%select{访问超出对象结尾的基类指针|访问超出对象结尾的派生类指针|访问超出对象结尾的字段|访问超出对象结尾的数组元素|ERROR|访问超出对象结尾的实部指针|访问超出对象结尾的虚部指针}0'
# 'cannot %select{access base class of|access derived class of|access field of|access array element of|perform pointer arithmetic on|access real component of|access imaginary component of}0 null pointer'
H2E784B2C1B28: '无法%select{访问空指针的基类|访问空指针的派生类|访问空指针的字段|访问空指针的数组元素|对空指针执行指针运算|访问空指针的实部|访问空指针的虚部}0'
# "cannot %select{assign to %select{object|'%1'}2 with|pass argument to %select{parameter|parameter '%1'}2 with|return|convert to|%select{|implicitly }3initialize %select{object|'%1'}2 with|pass argument to parameter with|cast to|pass argument to parameter with}0 '%5' attributed type %4 because the pointee type %6 is incomplete"
H1CA72EC4A20B: "无法 %select{将%select{对象|'%1'}2 赋值给带有|将参数传递给%select{参数|参数 '%1'}2 带有|返回|转换为|初始化%select{对象|'%1'}2%select{ |隐式 }3为带有|将参数传递给参数带有|转换为|将参数传递给参数带有}0 '%5' 属性类型 %4，因为所指类型 %6 不完整"
# 'cannot %select{assign|return|throw|subscript}0 a WebAssembly table'
H1D574B1BA9C6: '无法%select{赋值|返回|抛出|下标访问}0 WebAssembly 表'
# 'cannot %select{capture|take address of}0 WebAssembly reference'
H1706BDA5F276: '无法%select{捕获|获取地址}0 WebAssembly 引用'
# 'cannot %select{decrement|increment}0 expression of enum type %1'
H9709AF91935B: '无法对枚举类型 %1 执行%select{递减|递增}0操作'
# 'cannot %select{decrement|increment}1 value of type %0'
H7C6ED23E2E9F: '无法对类型 %0 的%select{递减|递增}1值执行操作'
# 'cannot %select{throw|catch}0 a WebAssembly reference type'
H3CB66A7D1B81: '无法 %select{抛出|捕获}0 WebAssembly 引用类型'
# "cannot %select{use '%1' with '%4' attributed|call '%1' with '%4' attributed return}0 type %2 because the pointee type %3 is incomplete"
HF83C2ECBEF93: "无法 %select{使用 '%1' 的带有 '%4' 限定符的类型|调用带有 '%4' 限定符返回类型的 '%1'}0 %2，因为指针目标类型 %3 是不完整的"
# "cannot %select{use builtin operator '<=>'|default 'operator<=>'}1 because type '%0' was not found; include <compare>"
H40A5A6DFAC87: "无法 %select{使用内建运算符 '<=>'|默认 'operator<=>' }1，因为类型 '%0' 未找到；请包含 <compare>"
# 'cannot %select{use type %1 for a function/method parameter|use type %1 for function/method return|default-initialize an object of type %1|declare an automatic variable of type %1|copy-initialize an object of type %1|assign to a variable of type %1|construct an automatic compound literal of type %1|capture a variable of type %1|cannot use volatile type %1 where it causes an lvalue-to-rvalue conversion}3 since it %select{contains|is}2 a union that is non-trivial to %select{default-initialize|destruct|copy}0'
H72F7777296D1: '无法 %select{使用类型 %1 作为函数/方法参数|使用类型 %1 作为函数/方法返回类型|默认初始化类型 %1 的对象|声明类型 %1 的自动变量|拷贝初始化类型 %1 的对象|将变量赋值为类型 %1|构造类型 %1 的自动复合字面量|捕获类型 %1 的变量|使用会导致左值转右值的易失性类型 %1}3，因为它 %select{包含|是}2 一个难以 %select{默认初始化|销毁|复制}0 的联合类型'
# 'cannot %select{||reinterpret_cast||C-style cast||}0 from member pointer type %1 to member pointer type %2 of different size'
H4DC29F600065: '无法 %select{||reinterpret_cast||C-style cast||}0 将成员指针类型 %1 转换为不同大小的成员指针类型 %2'
# "cannot add 'abi_tag' attribute in a redeclaration"
H48F70104AB1E: '无法在重新声明中添加 "abi_tag" 属性'
# 'cannot add a default template argument to the definition of a member of a class template'
H770ED38EE4A2: '无法为类模板成员的定义添加默认模板实参'
# 'cannot allocate %select{function|reference}1 type %0 with new'
HA111D2195E5D: '无法使用 new 分配 %select{函数|引用}1 类型 %0'
# "cannot allocate array of 'auto'"
H63BE6FF3ACD1: "无法分配类型为 'auto' 的数组"
# "cannot allocate array; evaluated array bound %0 exceeds the limit (%1); use '-fconstexpr-steps' to increase this limit"
H786F30B07D61: "无法分配数组；计算得到的数组边界 %0 超过限制（%1）；使用 '-fconstexpr-steps' 增加该限制"
# 'cannot allocate array; evaluated array bound %0 is negative'
H5D0D0D0008CA: '无法分配数组；计算得到的数组边界 %0 为负数'
# 'cannot allocate array; evaluated array bound %0 is too large'
H7762F6A6D3EC: '无法分配数组；计算得到的数组边界 %0 过大'
# 'cannot allocate array; evaluated array bound %0 is too small to hold %1 explicitly initialized elements'
H33075FED0F6C: '无法分配数组；计算得到的数组边界 %0 过小，无法容纳 %1 显式初始化的元素'
# 'cannot allocate memory of %select{incomplete|function}0 type %1'
H1CE3476A2AA9: '无法分配 %select{不完整|函数}0 类型 %1 的内存'
# "cannot allocate untyped memory in a constant expression; use 'std::allocator<T>::allocate' to allocate memory of type 'T'"
H659085361859: "无法在常量表达式中分配未指定类型的内存；使用 'std::allocator<T>::allocate' 来分配类型 'T' 的内存"
# "cannot apply AST actions to LLVM IR file '%0'"
HB65858D558EB: '无法对 LLVM IR 文件 "%0" 应用 AST 操作'
# 'cannot apply asm label to %select{variable|function}0 after its first use'
H75A6849C042D: '无法在首次使用后为 %select{变量|函数}0 应用汇编标签'
# "cannot assign to 'self' in a class method"
HA56E4ED9D1F5: "无法在类方法中为 'self' 赋值"
# "cannot assign to 'self' outside of a method in the init family"
HC5091C795252: "无法在 init 方法族外为 'self' 赋值"
# 'cannot assign to a variable captured by copy in a non-mutable lambda'
H135A3A08A93B: '无法将复制捕获的变量赋值给非可变的 lambda 中的变量'
# 'cannot assign to class object (%0 invalid)'
H25AF70C115F7: '无法将类对象赋值（%0 无效）'
# "cannot assign to this %select{dictionary|array}1 because assigning method's 2nd parameter of type %0 is not an Objective-C pointer type"
H33D10E761543: '无法将 this %select{字典|数组}1 赋值，因为类型为 %0 的第二个参数不是 Objective-C 指针类型'
# 'cannot befriend target of using declaration'
H72752EB56616: '无法与 using 声明的目标建立友元关系'
# 'cannot bind non-lvalue argument %0 to %select{|in}1out paramemter'
HD7C1DD47E42B: '无法将非左值参数 %0 绑定到 %select{|in}1 out 参数'
# 'cannot build range expression with array function parameter %0 since parameter with array type %1 is treated as pointer type %2'
H882392B5B8E6: '无法使用数组类型参数 %1 的函数参数 %0 构建范围表达式，因为数组类型参数会被视为指针类型 %2'
# "cannot call function '%1' while %0 '%2' is held"
HE0B68C2EF3F0: '在持有 %0 %2 期间无法调用函数 %1'
# 'cannot call operator __uuidof on a type with multiple GUIDs'
H6DB6EE36C688: '无法对具有多个 GUID 的类型调用 __uuidof 运算符'
# 'cannot call operator __uuidof on a type with no GUID'
HCAE7CA56FF69: '无法对没有 GUID 的类型调用 __uuidof 运算符'
# 'cannot capture __autoreleasing variable in a %select{block|lambda by copy}0'
H9DA2D963C91D: '无法在 %select{block|lambda by copy}0 中捕获 __autoreleasing 变量'
# 'cannot cast %0 to %1 via virtual base %2'
H794ABE3B9398: '无法通过虚基类 %2 将 %0 转换为 %1'
# 'cannot cast %0 to its %select{private|protected}2 base class %1'
H7E4D1C189883: '无法将 %0 转换为其 %select{私有|保护}2 基类 %1'
# 'cannot cast %select{private|protected}2 base class %1 to %0'
HEB1FE12D1532: '无法将 %select{私有|保护}2 基类 %1 转换为 %0'
# 'cannot cast %select{to|from}0 a WebAssembly table'
H608D936A86AA: '无法将 %select{到|从}0 WebAssembly 表进行转换'
# "cannot cast 'super' (it isn't an expression)"
H77DA1D89D4EF: "无法转换 'super'（它不是一个表达式）"
# "cannot cast an object of type %select{'nullptr_t' to %1|%1 to 'nullptr_t'}0"
H379020AFC623: '无法将类型 %select{nullptr_t 转换为 %1|%1 转换为 nullptr_t}0'
# 'cannot cast from lvalue of type %1 to rvalue reference type %2; types are not compatible'
HD498E8671ADF: '无法将类型 %1 的左值转换为右值引用类型 %2；类型不兼容'
# 'cannot cast from rvalue of type %1 to rvalue reference type %2; types are not compatible'
H81F8D1E74E50: '无法将类型 %1 的右值转换为右值引用类型 %2；类型不兼容'
# 'cannot cast from type %1 to member pointer type %2'
HC0F42A4D9625: '无法将类型 %1 转换为成员指针类型 %2'
# 'cannot cast from type %1 to pointer type %2'
H1C20AF9781FF: '无法将类型 %1 转换为指针类型 %2'
# "cannot cast non-zero value '%0' to 'event_t'"
HB63F6FC3F823: "无法将非零值 '%0' 转换为 'event_t'"
# 'cannot cast object of dynamic type %0 to type %1'
H29A99B2195B9: '无法将动态类型为 %0 的对象转换为类型 %1'
# "cannot cast to '__ptrauth'-qualified type %0"
H6496D0FA4BB0: '无法将类型 %0 转换为带有 __ptrauth 限定符的类型'
# 'cannot catch %select{|reference to }0sizeless type %1'
HFDB51E9BFE05: '不能捕获 %select{|引用到}0大小不明确的类型 %1'
# 'cannot catch an Objective-C object by value'
HE53524ADBBC8: '不能按值捕获Objective-C对象'
# 'cannot catch an exception thrown with @throw in C++ in the non-unified exception model'
HA5FD18981E9C: '在非统一异常模型中，无法捕获通过C++中@throw抛出的异常'
# 'cannot catch exceptions by rvalue reference'
H5BF423F821AB: '不能通过右值引用捕获异常'
# 'cannot catch incomplete type %0'
H712DCF7BC1DF: '不能捕获不完整类型 %0'
# 'cannot catch pointer to incomplete type %0'
H555C8CE71019: '不能捕获指向不完整类型 %0 的指针'
# 'cannot catch reference to incomplete type %0'
HAB26C8BE4E6D: '不能捕获不完整类型 %0 的引用'
# 'cannot catch variably modified type %0'
H3E0D097A06D0: '不能捕获变长修饰类型 %0'
# 'cannot combine GNU and %select{SVE|RVV}0 vectors in expression, result is ambiguous (%1 and %2)'
H6D9DAA9A57DC: '无法在表达式中同时使用GNU和 %select{SVE|RVV}0 向量，结果不明确（%1 和 %2）'
# 'cannot combine fixed-length and sizeless %select{SVE|RVV}0 vectors in expression, result is ambiguous (%1 and %2)'
H3EDDFBE7A4DF: '无法在表达式中同时使用固定长度和大小不明确的 %select{SVE|RVV}0 向量，结果不明确（%1 和 %2）'
# "cannot combine with previous '%0' declaration specifier"
H4EE2F7A93C38: "无法与之前的 '%0' 声明说明符合并"
# "cannot combine with previous '%0' declaration specifier. '__vector' must be first"
H856686567DB2: "无法与之前的 '%0' 声明说明符合并。'__vector' 必须放在首位"
# 'cannot compile this %0 yet'
H395022428A23: '当前无法编译此 %0'
# 'cannot compress debug sections (%0 not enabled)'
HB2DFAB48BA84: '无法压缩调试部分（%0 未启用）'
# 'cannot compute offset of bit-field %0'
H55C2FB73C827: '无法计算位字段 %0 的偏移量'
# "cannot constant evaluate '%select{memcpy|memmove}0' between objects of incomplete type %1"
H474B41288CFB: '无法常量求值类型 %1 的不完全类型之间的 %select{memcpy|memmove}0 结果'
# "cannot constant evaluate '%select{memcpy|memmove}0' between objects of non-trivially-copyable type %1"
H4AA44A4233D2: '无法常量求值非平凡复制类型的 %1 之间的 %select{memcpy|memmove}0 结果'
# "cannot constant evaluate '%select{memcpy|memmove}0' from object of type %1 to object of type %2"
H6FAB8AA1F441: '无法常量求值从类型 %1 到类型 %2 的 %select{memcpy|memmove}0 结果'
# 'cannot constant evaluate the result of adjusting alignment to %0'
H8F0F0485C85D: '无法计算将对齐方式调整到 %0 后的结果'
# 'cannot constant evaluate whether run-time alignment is at least %0'
H8DC5B278E189: '无法在常量表达式中确定运行时对齐是否至少为 %0'
# 'cannot construct object of type %0 with virtual base class in a constant expression'
H7DD1FDBBEF06: '无法在常量表达式中构造包含虚基类的 %0 类型的对象'
# 'cannot convert %0 token to an identifier'
H18B9F6746EBF: '无法将 %0 标记转换为标识符'
# 'cannot convert %1 to %2 without a conversion operator'
H703415593D2A: '无法在没有转换运算符的情况下将 %1 转换为 %2'
# 'cannot convert between %select{scalar|vector}0 type %1 and vector type %2 as implicit conversion would cause truncation'
HF046F296A9B0: '无法在隐式转换会导致截断的情况下在%select{标量|向量}0类型 %1 和向量类型 %2 之间进行转换'
# 'cannot convert between vector and non-scalar values (%0 and %1)'
HD81F5D7E2B16: '无法在向量类型和非标量类型之间（%0 和 %1）进行转换'
# 'cannot convert between vector values of different size (%0 and %1)'
H8810EF643AA5: '无法在不同大小的向量值之间进行转换（%0 和 %1）'
# 'cannot create __weak reference because the current deployment target does not support weak references'
H54D605FEB00B: '无法创建__weak引用，因为当前部署目标不支持弱引用'
# 'cannot create __weak reference in file using manual reference counting'
H98AD8AE899EB: '无法在使用手动引用计数的文件中创建__weak引用'
# 'cannot create a non-constant pointer to member function'
H909CEC9754E8: '无法创建非常量的成员函数指针'
# 'cannot create includes file for module %0: %1'
H521EA5757B62: '无法为模块 %0 创建包含文件：%1'
# 'cannot create object of function type %0'
HB6BCDD252F4D: '无法声明无名称的类模板 %0'
# 'cannot declare a class template with no name'
H86275B9FD8C9: '无法在友元中声明显式特例化'
# 'cannot declare an explicit specialization in a friend'
H8E19851C2991: '不能在 friend 中声明显式特化'
# 'cannot declare class extension for %0 after class implementation'
H472ADAE23CEA: '类实现后不能为 %0 声明类扩展'
# "cannot declare implementation of a class declared with the 'objc_class_stub' attribute"
H831B35F688CB: '无法将命名空间 "std" 声明为内联'
# "cannot declare the namespace 'std' to be inline"
H1345EF64CB88: '无法在@interface或@protocol内声明变量'
# 'cannot declare variable inside @interface or @protocol'
H11D626BF5B37: '不能在 @interface 或 @protocol 中声明变量'
# 'cannot decompose %select{private|protected}0 member %1 of %3'
HAF5B2F15564E: '不能分解 %select{私有|受保护}0 成员 %1 的 %3'
# 'cannot decompose %select{union|non-class, non-array}1 type %2'
HD213477C2A3A: '无法分解%select{联合体|非类、非数组}1类型 %2'
# 'cannot decompose class type %0 because it has an anonymous %select{struct|union}1 member'
H687FA194A579: '无法分解类类型 %0，因为它包含匿名%select{结构体|联合体}1成员'
# 'cannot decompose class type %1: %select{its base classes %2 and|both it and its base class}0 %3 have non-static data members'
HBC0288C04290: '不能分解类类型 %1：%select{其基类 %2 和|该类及其基类}0 %3 有非静态数据成员'
# 'cannot decompose lambda closure type'
H3C6B1EAC26ED: '无法分解lambda闭包类型'
# 'cannot decompose members of ambiguous base class %1 of %0:%2'
HE08DBE349649: '无法分解 %0 的二义性基类 %1 的成员：%2'
# 'cannot decompose members of inaccessible base class %1 of %0'
HA6ED46C6B298: '无法分解 %0 的不可访问基类 %1 的成员'
# "cannot decompose this type; 'std::tuple_element<%0>::type' does not name a type"
H4AD140BFCF3D: "无法分解此类型；'std::tuple_element<%0>::type' 不是一个类型名称"
# "cannot decompose this type; 'std::tuple_size<%0>::value' is not a valid integral constant expression"
HE140F3EE6033: "无法分解此类型；'std::tuple_size<%0>::value' 不是一个有效的整数常量表达式"
# 'cannot decrement expression of type bool'
H9DABD4A4074A: '不能递减类型为bool的表达式'
# "cannot deduce 'decltype(auto)' from initializer list"
H0294CF60338E: "无法从初始化列表推导 'decltype(auto)' 类型"
# 'cannot deduce actual type for %1 from %select{parenthesized|nested}0 initializer list'
H1C99EC9B7047: '无法从%select{括号包围的|嵌套}0初始化列表推导 %1 的实际类型'
# 'cannot deduce actual type for variable %0 with type %1 from initializer list'
HA7FCCDD3352E: '无法从初始化列表推导变量 %0（类型 %1）的实际类型'
# 'cannot deduce implicit triple value for -Xopenmp-target, specify triple using -Xopenmp-target=<triple>'
HBB4FDAD01556: '无法推导-Xopenmp-target的隐式目标三元组值，请使用-Xopenmp-target=<triple> 指定三元组'
# 'cannot deduce lambda return type from initializer list'
HBF4499B07FAC: '无法从初始化列表推导lambda返回类型'
# 'cannot deduce return type %0 for function with no return statements'
H4A0B0541DA05: '无法为无return语句的函数推导返回类型 %0'
# 'cannot deduce return type %0 from omitted return expression'
HF76745F04CDD: '无法从省略的返回表达式推导返回类型 %0'
# 'cannot deduce return type %0 from returned value of type %1'
HFF6A0873771C: '无法从类型 %1 的返回值推导返回类型 %0'
# 'cannot deduce return type from initializer list'
HD33E533A8026: '无法从初始化列表推导返回类型'
# 'cannot deduce template arguments for %0 from %1'
H59FFC4EE513D: '无法为 %0 从 %1 推导模板参数'
# 'cannot deduce type for lambda capture %0 from initializer list'
HD1B46B897454: '无法从初始化列表推导lambda捕获 %0 的类型'
# 'cannot deduce type for lambda capture %0 from initializer of type %2'
H5BED86131FDB: '无法推导类型 %0 的lambda捕获类型，因为初始化器的类型为 %2'
# 'cannot deduce type for lambda capture %1 from %select{parenthesized|nested}0 initializer list'
HBAF719ACD121: '无法从%select{括号|嵌套}0初始化列表推导lambda捕获 %1 的类型'
# 'cannot deduce type for variable %1 with type %2 from %select{parenthesized|nested}0 initializer list'
HDBF6BFDD94D3: '无法从%select{括号|嵌套}0初始化列表推导类型 %2 的变量 %1'
# 'cannot deduce type of initializer list because std::initializer_list was not found; include <initializer_list>'
H61AB50323785: '无法推导初始化列表类型，因为未找到std::initializer_list；请包含 <initializer_list>'
# 'cannot define %select{category|class extension}0 for undefined class %1'
H075CA56C0949: '无法为未定义的类 %1 定义%select{分类|类扩展}0'
# 'cannot define a type in a friend declaration'
H90F602DED3B4: '无法在友元声明中定义类型'
# 'cannot define friend function %0 in a local class definition; did you mean %3?'
H40B3F3B5FBB1: '无法在本地类定义中声明友元函数 %0；是否应改为 %3？'
# 'cannot define friend function in a local class definition'
HB60D03F3A5C5: '无法在本地类定义中声明友元函数'
# 'cannot define non-inline dllimport template specialization'
HF67617A49B06: '无法定义非内联dllimport模板特化'
# 'cannot define or redeclare %0 here because namespace %1 does not enclose namespace %2'
HFA38E82744C2: '无法在此处定义或重新声明 %0，因为命名空间 %1 不包含命名空间 %2'
# 'cannot define the implicit copy assignment operator for %0, because non-static %select{reference|const}1 member %2 cannot use copy assignment operator'
H50812469123A: '无法为 %0 推导隐式拷贝赋值运算符，因为非静态%select{引用|const}1 成员 %2 无法使用拷贝赋值运算符'
# 'cannot delete expression of type %0'
H8F9B57A837EE: '无法删除类型 %0 的表达式'
# "cannot delete expression with pointer-to-'void' type %0"
HCCFA093E9DE2: "无法删除类型 %0 的指向 'void' 指针表达式"
# 'cannot delete pointer to incomplete type %0'
H7E32F7F5C2AD: '无法删除指向不完整类型 %0 的指针'
# "cannot determine %0 architecture: %1; consider passing it via '%2'; environment variable CLANG_TOOLCHAIN_PROGRAM_TIMEOUT specifies the tool timeout (integer secs, <=0 is infinite)"
H9E1578DA83DB: '无法确定 %0 架构：%1；建议通过参数 "%2" 传递；环境变量CLANG_TOOLCHAIN_PROGRAM_TIMEOUT指定工具超时时间（整数秒，≤0表示无限）'
# 'cannot determine allocated array size from initializer'
H3573086C6F39: '无法从初始化器确定分配数组的大小'
# 'cannot determine number of elements for sizeless vectors in a constant expression'
HAFC6AFA63009: '无法在常量表达式中确定无大小向量的元素数量'
# 'cannot determine underlying type of incomplete enumeration type %0'
H486DE8FE7D9E: '无法获取不完整枚举类型 %0 的底层类型'
# 'cannot emit module %0: %select{size|mtime}1 must be explicitly specified for missing header file "%2"'
H4AFEE6C7D624: '无法生成模块 %0：%select{大小|修改时间}1必须显式指定缺失头文件 "%2"'
# 'cannot evaluate call to virtual function in a constant expression in C++ standards before C++20'
HC06FC1196550: '无法在C++20之前的C++标准的常量表达式中求值虚函数调用'
# 'cannot evaluate this expression if rounding mode is dynamic'
HC673B661CF5A: '如果舍入模式是动态的，则无法求值此表达式'
# 'cannot export %0 as it is not at namespace scope'
H49EEB2061C19: '无法导出 %0，因为它不在命名空间作用域中'
# 'cannot export redeclaration %0 here since the previous declaration %select{is not exported|has internal linkage|has module linkage}1'
H805545AFF107: '由于之前的声明%select{未导出|具有内部链接性|具有模块链接性}1，因此无法在此处导出 %0 的重新声明'
# "cannot find CUDA installation; provide its path via '--cuda-path', or pass '-nocudainc' to build without CUDA includes"
H483DC86F4594: "无法找到CUDA安装路径；请通过 '--cuda-path' 提供其路径，或使用 '-nocudainc' 选项不包含CUDA头文件进行编译"
# "cannot find HIP Standard Parallelism Acceleration library; provide it via '--hipstdpar-path'"
H20ABDE201926: "无法找到HIP标准并行加速库；请通过 '--hipstdpar-path' 提供其路径"
# "cannot find HIP device library%select{| for %1}0; provide its path via '--hip-path' or '--hip-device-lib-path', or pass '-nogpulib' to build without HIP device library"
H74B6BE24033A: "无法找到HIP设备库 %select{|用于 %1}0；请通过 '--hip-path' 或 '--hip-device-lib-path' 提供其路径，或使用 '-nogpulib' 选项不链接HIP设备库进行编译"
# "cannot find HIP runtime; provide its path via '--rocm-path', or pass '-nogpuinc' to build without HIP runtime"
H11EBFA045BE3: "无法找到HIP运行时；请通过 '--rocm-path' 提供其路径，或使用 '-nogpuinc' 选项不包含HIP运行时进行编译"
# "cannot find ROCm device library%select{| for %1| for ABI version %1%select{|, which requires ROCm %3 or higher}2}0; provide its path via '--rocm-path' or '--rocm-device-lib-path', or pass '-nogpulib' to build without ROCm device library"
H66C4B1DCC978: "找不到 ROCm 设备库 %select{| 的 %1| 的 ABI 版本 %1%select{|，该版本需要 ROCm %3 或更高版本}2}0；可通过 '--rocm-path' 或 '--rocm-device-lib-path' 提供路径，或使用 '-nogpulib' 编译时不链接 ROCm 设备库"
# 'cannot find a valid user-defined mapper for type %0 with name %1'
H0907A5973C27: '未找到类型 %0 且名称为 %1 的有效用户自定义映射器'
# "cannot find end ('%1') of expected %0"
H53A2AE90D9C0: "无法找到期望 %0 的结束标记 '%1'"
# 'cannot find interface declaration for %0'
H7325D139C40F: '未找到 %0 的接口声明'
# 'cannot find interface declaration for %0, superclass of %1'
HDDF90FE7BE8F: '未找到 %0 的接口声明（%1 的基类）'
# 'cannot find interface declaration for %0, superclass of %1; did you mean %2?'
H691319D1E232: '未找到 %0 的接口声明（%1 的基类）；是否是指 %2？'
# 'cannot find interface declaration for %0; did you mean %1?'
H3FD5BD5869C6: '未找到 %0 的接口声明；是否是指 %1？'
# "cannot find libdevice for %0; provide path to different CUDA installation via '--cuda-path', or pass '-nocudalib' to build without linking with libdevice"
H9C8FBD27D916: "无法找到 %0 的libdevice；请通过 '--cuda-path' 提供其他CUDA安装路径，或使用 '-nocudalib' 选项不链接libdevice进行编译"
# 'cannot find protocol declaration for %0'
H8559765777E9: '未找到 %0 的协议声明'
# 'cannot find protocol declaration for %0; did you mean %1?'
H39967D7F0C23: '未找到 %0 的协议声明；是否是指 %1？'
# 'cannot find protocol definition for %0'
H30EC809C2E8C: '未找到 %0 的协议定义'
# "cannot find re-exported %select{framework|library}0: '%1'"
HFF74F7CAAAC8: "无法找到导出的%select{框架|库}0：'%1'"
# "cannot find rocPrim, which is required by the HIP Standard Parallelism Acceleration library; provide it via '--hipstdpar-prim-path'"
H7420A8DBF79F: "无法找到由HIP标准并行加速库所需的rocPrim；请通过 '--hipstdpar-prim-path' 提供其路径"
# "cannot find rocThrust, which is required by the HIP Standard Parallelism Acceleration library; provide it via '--hipstdpar-thrust-path'"
HF20DC196E1CB: "找不到rocThrust，这是HIP标准并行加速库所必需的；请通过 '--hipstdpar-thrust-path' 提供它"
# "cannot find start ('{{') of expected %0"
H727EB43115FC: "无法找到期望 %0 的起始标记 '{{'"
# "cannot find start of regex ('{{') in %0"
HD5BDA70A3617: "在 %0 中找不到正则表达式的起始符（'{{'）"
# 'cannot find suitable %select{getter|setter}0 for property %1'
H0F811370E791: '找不到适合属性 %1 的 %select{getter|setter}0'
# 'cannot form %select{pointer to|reference to|array of|function returning}0 deduced class template specialization type'
H0C20361BB556: '无法形成指向 %select{指针到|引用到|数组|返回函数}0 推导出的类模板特化类型的'
# "cannot form %select{pointer to|reference to|array of}0 'decltype(auto)'"
H7F41F0A9CCC7: "无法形成%select{指向|引用|数组}0 'decltype(auto)'"
# 'cannot form a %select{pointer|reference}0 to a WebAssembly table'
H3C39E76E28BC: '无法形成指向WebAssembly表的%select{指针|引用}0'
# 'cannot form a pointer-to-member to member %0 of reference type %1'
H45A1DB7A6AF3: '无法形成引用类型 %1 的成员 %0 的成员指针'
# "cannot form a reference to 'void'"
H6E82068C4FE4: "无法形成对 'void' 的引用"
# "cannot form member pointer of type %0 without '&' and class name"
HA98A1BC7CEC4: "无法在没有 '&' 和类名的情况下形成类型 %0 的成员指针"
# 'cannot generate code for reduction on %select{|array section, which requires a }0variable length array'
H328E15AAC013: '无法为 %select{|数组段，需要一个}0变长数组生成代码'
# 'cannot have both throw() and noexcept() clause on the same function'
H93A58AAAE480: '同一个函数不能同时使用throw()和noexcept()子句'
# 'cannot implement a category for class %0 that is only visible via the Objective-C runtime'
H93EA111FC5EC: '无法为仅通过Objective-C运行时可见的类 %0 实现类别'
# 'cannot implement subclass %0 of a superclass %1 that is only visible via the Objective-C runtime'
H0C79ADD5940E: '无法为仅通过Objective-C运行时可见的超类 %1 实现子类 %0'
# 'cannot import unsupported AST node %0'
H4E75F3A5019B: '无法导入不受支持的AST节点 %0'
# 'cannot initialize %select{a variable|a parameter|template parameter|return object|statement expression result|an exception object|a member subobject|an array element|a new value|a value|a base class|a constructor delegation|a vector element|a block element|a block element|a complex element|a lambda capture|a compound literal initializer|a related result|a parameter of CF audited function|a structured binding|a member subobject}0 %diff{of type $ with an %select{rvalue|lvalue}2 of type $|with an %select{rvalue|lvalue}2 of incompatible type}1,3%select{|: different classes%diff{ ($ vs $)|}5,6|: different number of parameters (%5 vs %6)|: type mismatch at %ordinal5 parameter%diff{ ($ vs $)|}6,7|: different return type%diff{ ($ vs $)|}5,6|: different qualifiers (%5 vs %6)|: different exception specifications}4'
H5225AD7ABD6B: '无法初始化 %select{变量|参数|模板参数|返回对象|表达式结果|异常对象|成员子对象|数组元素|新值|值|基类|构造函数委托|向量元素|块元素|块元素|复数元素|lambda 捕获|复合字面量初始化器|相关结果|CF 审计函数参数|结构化绑定|成员子对象}0 %diff{类型为 $ 的 %select{右值|左值}2 类型 $|与类型不兼容的 %select{右值|左值}2}1,3%select{|：不同类%diff{ ($ vs $)|}5,6|：参数数量不同（%5 vs %6）|：第 %ordinal5 参数类型不同%diff{ ($ vs $)|}6,7|：返回类型不同%diff{ ($ vs $)|}5,6|：限定符不同（%5 vs %6）|：异常说明不同}4'
# 'cannot initialize %select{non-class|reference}0 type %1 with a parenthesized initializer list'
HE63727C8C08B: '无法用括号括起的初始化列表初始化%select{非类|引用}0类型 %1'
# 'cannot initialize Objective-C class type %0'
HA709360A8ABC: '无法初始化Objective-C类类型 %0'
# 'cannot initialize array %diff{of type $ with array of type $|with different type of array}0,1'
HA759EFFA1CC7: '无法初始化数组 %diff{类型 $ 与类型 $ 的数组|数组类型不同}0,1'
# 'cannot initialize array %diff{of type $ with non-constant array of type $|with different type of array}0,1'
HAEED299DACD1: '不能用不同类型数组初始化 %diff{类型 $ 的数组与非常量数组类型 $|不同类型的数组}0,1'
# 'cannot initialize object parameter of type %0 with an expression of type %1'
H01F0C7FE2242: '无法用类型 %1 的表达式初始化类型 %0 的对象参数'
# 'cannot instantiate %0 yet'
H3C23130222AC: '无法实例化 %0'
# 'cannot jump from switch statement to this case label'
H0147E81C1C5E: '无法从switch语句跳转到此case标签'
# 'cannot jump from this %select{indirect|asm}0 goto statement to one of its possible targets'
HA7FDD21785F4: '无法从此%select{间接|汇编}0 goto语句跳转到其可能的目标之一'
# 'cannot jump from this continue statement to the loop increment; jump bypasses initialization of loop condition variable'
HF65BBB33CB19: '无法从此continue语句跳转到循环增量；跳转绕过了循环条件变量的初始化'
# 'cannot jump from this goto statement to its label'
HF7AC509BA0D6: '无法从此goto语句跳转到其标签'
# 'cannot jump from this goto statement to label %0 inside an inline assembly block'
HBD667F79ECB9: '无法从此goto语句跳转到内联汇编块内的标签 %0'
# "cannot link module '%0': %1"
H957779E89D24: "无法链接模块 '%0'：%1"
# 'cannot locate code-completion file %0'
H00AA0E96170A: '无法定位代码补全文件 %0'
# 'cannot mangle fixed point literals yet'
H175F8CE0FB1D: '无法对定点字面量进行名称修饰'
# 'cannot mangle this %0 %1 yet'
H50F33B0E4B4E: '无法对此 %0 %1 进行名称修饰'
# 'cannot mangle this %0 yet'
H1C98A95C714E: '无法对此 %0 进行名称修饰'
# 'cannot mangle this dependent fixed-length RVV vector type yet'
H01F50B3350B7: '无法对依赖的固定长度RVV向量类型进行名称修饰'
# 'cannot mangle this dependent fixed-length SVE vector type yet'
H53C22EA00769: '无法对依赖的固定长度SVE向量类型进行名称修饰'
# 'cannot mangle this dependent neon vector type yet'
H566B620CDB5E: '无法对依赖的NEON向量类型进行名称修饰'
# 'cannot mangle this requires-expression containing a substitution failure'
H9EEE8BF3FF53: '无法对包含替代失败的requires表达式进行名称修饰'
# 'cannot mangle this unnamed union NTTP yet'
HC67F1942B567: '无法对此未命名的联合NTTP进行名称修饰'
# 'cannot mix packoffset elements with nonpackoffset elements in a cbuffer'
H5F5AED65EDDB: 'cbuffer中不能混合packoffset元素与非packoffset元素'
# 'cannot mix positional and non-positional arguments in format string'
HC2203B0385F9: '格式字符串中不能同时使用位置参数和非位置参数'
# 'cannot mix vectors and extended vectors in a vector conditional'
H0C69F5DF40B4: '向量条件中不能同时使用向量和扩展向量'
# "cannot nest 'critical' regions having the same name %0"
HB0FDA4DB5B6B: "不能嵌套具有相同名称 %0 的 'critical' 区域"
# "cannot open file '%0': %1"
H7B318395BD4F: '无法打开文件“%0”：%1'
# "cannot overload a member function %select{without a ref-qualifier|with ref-qualifier '&'|with ref-qualifier '&&'}0 with a member function %select{without a ref-qualifier|with ref-qualifier '&'|with ref-qualifier '&&'}1"
H3E720DF8A96F: "不能用 %select{无 ref-qualifier 成员函数|具有 ref-qualifier '&' 的成员函数|具有 ref-qualifier '&&' 的成员函数}0 重载 %select{无 ref-qualifier 成员函数|具有 ref-qualifier '&' 的成员函数|具有 ref-qualifier '&&' 的成员函数}1"
# 'cannot override a method that is declared direct by a superclass'
H8D083337F734: '不能覆盖由超类直接声明的方法'
# 'cannot parenthesize the name of a method when forming a member pointer'
H733C76C89DE9: '不能在形成成员指针时对方法的名称加括号'
# 'cannot pass %select{expression of type %1|initializer list}0 to variadic %select{function|block|method|constructor}2'
H25763FEA732A: '不能将%select{类型 %1 的表达式|初始化列表}0传递给可变参数%select{函数|块|方法|构造函数}2'
# 'cannot pass %select{expression of type %1|initializer list}0 to variadic %select{function|block|method|constructor}2; expected type from format string was %3'
H6A81C62CC358: '无法将%select{类型 %1 的表达式|初始化列表}0传递给可变参数%select{函数|块|方法|构造函数}2；格式字符串期望的类型是 %3'
# 'cannot pass %select{non-POD|non-trivial}0 object of type %1 to variadic %select{function|block|method|constructor}2; expected type from format string was %3'
HB3C416B2C325: '无法将%select{非POD|非平凡}0类型 %1 的对象传递给可变参数%select{函数|块|方法|构造函数}2；格式字符串期望的类型是 %3'
# 'cannot pass a pointer-to-member through register-constrained inline assembly parameter'
H1A2FFC7DC3D0: '不能通过寄存器约束的内联汇编参数传递成员指针'
# 'cannot pass bit-field as __auto_type initializer in C'
HC2EE224C8229: '不能在C中将位域作为__auto_type初始化器'
# 'cannot pass non-trivial C object of type %0 by value to variadic %select{function|block|method|constructor}1'
H2C5461696894: '不能通过值传递非平凡C类型 %0 的对象给可变参数%select{函数|块|方法|构造函数}1'
# 'cannot pass object of %select{non-POD|non-trivial}0 type %1 through variadic %select{function|block|method|constructor}2; call will abort at runtime'
H03C685EEC43F: '不能将%select{非POD|非平凡}0类型 %1 对象传递给可变参数%select{函数|块|方法|构造函数}2；调用将在运行时终止'
# 'cannot pass object with interface type %0 by value through variadic %select{function|block|method|constructor}1'
HFFB4BE108833: '不能通过值传递具有接口类型 %0 的对象给可变参数%select{函数|块|方法|构造函数}1'
# 'cannot pass object with interface type %1 by value to variadic %select{function|block|method|constructor}2; expected type from format string was %3'
HFCF01B48F1C2: '无法将接口类型 %1 的对象按值传递给可变参数%select{函数|块|方法|构造函数}2；格式字符串期望的类型是 %3'
# "cannot pass undiscriminated type %0 to '__builtin_ptrauth_type_discriminator'"
HCF5D52D0F4BA: "无法将未区分的类型 %0 传递给 '__builtin_ptrauth_type_discriminator'"
# 'cannot perform a tail call %select{from|to}0 a %select{constructor|destructor}1'
H92D6BE5E0D10: '无法在%select{从|到}0%select{构造函数|析构函数}1执行尾调用'
# 'cannot perform a tail call from this return statement'
HD566EFBB0F10: '无法从此返回语句执行尾调用'
# 'cannot perform a tail call to function%select{| %1}0 because it uses an incompatible calling convention'
H32E425482ACE: '无法对 %select{| %1}0 函数执行尾调用，因为它使用了不兼容的调用约定'
# 'cannot perform a tail call to function%select{| %1}0 because its signature is incompatible with the calling function'
HB6791E3481C6: '无法对 %select{| %1}0 函数执行尾调用，因为其签名与调用函数不兼容'
# 'cannot perform atomic operation on a pointer to type %0: type has non-trivial ownership'
H33A9E57472E9: '无法对类型 %0 的指针执行原子操作：该类型具有非平凡所有权'
# "cannot read configuration file '%0': %1"
H0AF7279B0969: '无法读取配置文件“%0”：%1'
# "cannot read randomize layout seed file '%0'"
H97BBD89360BC: "无法读取随机化布局种子文件 '%0'"
# "cannot rebuild module '%0' as it is already finalized"
H80C2AA3A79E5: "无法重新构建模块 '%0'，因为它已被最终确定"
# 'cannot redeclare builtin function %0'
HC3E811B65243: '不能重新声明内建函数 %0'
# 'cannot refer to a block inside block'
HEC4D55F7E1FA: '不能在代码块内引用该代码块内部'
# 'cannot refer to a non-static member from the handler of a %select{constructor|destructor}0 function try block'
H7C221E1899F1: '不能在%select{构造函数|析构函数}0的try块处理程序中引用非静态成员'
# 'cannot refer to declaration of structure variable with flexible array member inside block'
H861E195F8EA8: '不能在代码块内引用带有可变长度数组成员的结构体变量的声明'
# 'cannot refer to declaration with a variably modified type inside block'
H3ACCC42BDE35: '不能在代码块内引用具有变长类型声明的变量'
# 'cannot refer to declaration with an array type inside block'
HBA9381EF3C23: '不能在代码块内引用具有数组类型的声明'
# 'cannot refer to element %0 of %select{array of %2 element%plural{1:|:s}2|non-array object}1 in a constant expression'
H97B7B294ED7C: '不能在常量表达式中引用%select{包含 %2 元素的数组 %plural{1:|:s}2|非数组对象}1的元素 %0'
# "cannot refer to member %0 in %1 with '%select{.|->}2'"
HF25CD96D4723: "无法使用 '%select{.|->}2' 在 %1 中引用成员 %0"
# "cannot refer to type member %0 in %1 with '%select{.|->}2'"
H982BCA02E9FD: "无法使用 '%select{.|->}2' 在 %1 中引用类型成员 %0"
# 'cannot reference member of primary template because deduced class template specialization %0 is %select{instantiated from a partial|an explicit}1 specialization'
HF04074EDD691: '无法引用主模板的成员，因为推导出的类模板特化 %0 是%select{部分特化|显式}1的特化'
# 'cannot resolve lock expression'
H9831838AB057: '无法解析锁表达式'
# 'cannot return from %0'
HDE7181BDC39D: '不能从 %0 返回'
# 'cannot set vtable pointer authentication on %0 which is a subclass of polymorphic type %1'
H8615F820D27E: '不能为多态类型 %1 的子类 %0 设置虚表指针认证'
# 'cannot set vtable pointer authentication on an incomplete type %0'
H50389542B8AD: '不能为不完全类型 %0 设置虚表指针认证'
# 'cannot set vtable pointer authentication on monomorphic type %0'
H365AD22227CA: '不能为单态类型 %0 设置虚表指针认证'
# "cannot specialize %select{|(with 'template<>') }0a member of an unspecialized template"
H21C951459621: "不能特化未特化的模板成员 %select{|(使用 'template<>' )}0"
# 'cannot specialize a %select{dependent template|template template parameter}0'
HC5BFF931F55D: '不能特化%select{依赖模板|模板模板参数}0'
# "cannot specify '%0%1' when compiling multiple source files"
HFD3172559132: "在编译多个源文件时不能指定 '%0%1'"
# "cannot specify '%1' along with '%0'"
H9F94923DAC7E: "不能同时指定 '%1' 和 '%0'"
# 'cannot specify -o when generating multiple output files'
HE249C344BFD2: '生成多个输出文件时不能指定 -o'
# 'cannot specify a default vtable pointer authentication %select{key|address discrimination mode|discriminator}0 with no default set'
H3A1B9264D760: '未设置默认值时无法指定默认 vtable 指针验证 %select{密钥|地址鉴别模式|鉴别符}0'
# "cannot specify any part of a return type in the declaration of a conversion function%select{; put the complete type after 'operator'|; use a typedef to declare a conversion to %1|; use an alias template to declare a conversion to %1|}0"
HAA40A3FFF9F4: "在转换函数声明中不能指定返回类型的任何部分 %select{; 在 'operator' 后面写出完整类型|; 使用 typedef 声明向 %1 的转换|; 使用别名模板声明向 %1 的转换|}0"
# 'cannot specify any part of a return type in the declaration of a deduction guide'
H390B6E7B14DB: '在推导指引的声明中不能指定返回类型的任何部分'
# 'cannot specify deduction guide for %select{<error>|function template|variable template|alias template|template template parameter|concept|dependent template name}0 %1'
H8A234F5E78B1: '无法为 %select{<error>|函数模板|变量模板|别名模板|模板模板参数|概念|依赖模板名称}0 %1 指定推导指引'
# "cannot specify parameter '%0' twice in the same '#embed' directive"
HD1DC8056B121: "不能在同一 '#embed' 指令中重复指定参数 '%0'"
# 'cannot store matrix to read-only pointer'
H425886F44B36: '无法将矩阵存储到只读指针'
# "cannot subclass a class that was declared with the 'objc_subclassing_restricted' attribute"
H5638A6FF93B7: "不能继承使用 'objc_subclassing_restricted' 属性声明的类"
# 'cannot synthesize property %0 with incomplete type %1'
H71A1173D4045: '无法合成具有不完整类型 %1 的属性 %0'
# 'cannot synthesize weak property because the current deployment target does not support weak references'
H38DCEFEFA216: '当前部署目标不支持弱引用，因此无法合成弱属性'
# 'cannot synthesize weak property in file using manual reference counting'
H0734CFB3421A: '在使用手动引用计数的文件中无法合成弱属性'
# 'cannot take address of %select{immediate|consteval}2 %select{function|call operator of}1 %0 outside of an immediate invocation'
H530D63A21A7A: '不能在非立即调用的上下文中获取 %select{立即|consteval}2 %select{函数|调用运算符的}1 %0 的地址'
# 'cannot take address of function %0 because it has one or more non-tautological enable_if conditions'
H23DB8FEDBD81: '不能获取具有一个或多个非同构 enable_if 条件的函数 %0 的地址'
# 'cannot take address of function %0 because its constraints are not satisfied'
H4014F85A3BA5: '由于其约束未满足，无法获取函数 %0 的地址'
# 'cannot take address of function %0 because parameter %1 has pass_object_size attribute'
H6872B0BADEA4: '由于参数 %1 具有 pass_object_size 属性，无法获取函数 %0 的地址'
# 'cannot take an address of a virtual member function if its return or argument types are incomplete'
HF3A5696A9EB7: '如果虚成员函数的返回或参数类型不完整，则不能获取其地址'
# 'cannot take the address of an rvalue of type %0'
H60F39E1B8F38: '无法获取类型 %0 的右值的地址'
# 'cannot template a using %select{directive|declaration}0'
H7E5220347031: '无法对 using %select{指令|声明}0 进行模板化'
# 'cannot throw an object of abstract type %0'
H1AA71488C1EF: '不能抛出抽象类型 %0 的对象'
# 'cannot throw object of incomplete type %0'
H5A0A40D72DE8: '不能抛出不完整类型 %0 的对象'
# 'cannot throw object of sizeless type %0'
HA8B5689740C7: '不能抛出无尺寸类型 %0 的对象'
# 'cannot throw object of type %0 with a potentially-throwing destructor'
HC355469628A0: '不能抛出具有可能抛出的析构函数的类型 %0 的对象'
# 'cannot throw pointer to object of incomplete type %0'
H079B08EA2D25: '不能抛出指向不完整类型 %0 对象的指针'
# 'cannot type cast @selector expression'
H485C835C56BA: '无法将 @selector 表达式进行类型转换'
# "cannot use %select{'auto'|<ERROR>|'__auto_type'}0 with %select{initializer list|array}1 in C"
HE2E4F9E6D620: "不能在 C 中将 %select{'auto'|<ERROR>|'__auto_type'}0 与 %select{初始化列表|数组}1 一起使用"
# "cannot use %select{C++ 'try'|Objective-C '@try'}0 in the same function as SEH '__try'"
H455974313E2A: "不能在同一函数中同时使用 %select{C++ 'try'|Objective-C '@try'}0 和SEH的 '__try'"
# 'cannot use %select{dot|arrow}0 operator on a type'
H546BD63E07E0: '不能对类型使用 %select{点|箭头}0 运算符'
# "cannot use %select{unicode|wide}0 string literal in 'asm'"
HD3FDC775E04A: "无法在 'asm' 中使用 %select{Unicode|宽}0 字符串字面量"
# "cannot use '%0' in %select{__device__|__global__|__host__|__host__ __device__}1 function"
H92A38A76E58C: "不能在 %select{__device__|__global__|__host__|__host__ __device__}1 函数中使用 '%0'"
# "cannot use '%0' output with multiple -arch options"
H1A59A50BBDD4: "不能在多个 -arch 选项中使用 '%0' 输出"
# "cannot use '%0' with '__vector bool'"
HB212313EEF9A: "不能将 '%0' 与 '__vector bool' 一起使用"
# "cannot use '%0' with Objective-C exceptions disabled"
H633899DC0353: "在禁用 Objective-C 异常时不能使用 '%0'"
# "cannot use '%0' with exceptions disabled"
H0F6B73A63960: "在禁用异常时不能使用 '%0'"
# "cannot use '_Complex' with '__vector'"
HCFEB59CAC054: "不能将 '_Complex' 与 '__vector' 一起使用"
# "cannot use 'float' with '__vector'"
H8772A8A87C32: "不能将 'float' 与 '__vector' 一起使用"
# "cannot use 'long double' with '__vector'"
HD41E42BADD92: "不能将 'long double' 与 '__vector' 一起使用"
# "cannot use 'long' with '__vector'"
H0DD309217BB4: "不能将 'long' 与 '__vector' 一起使用"
# "cannot use SEH '__try' in a coroutine when C++ exceptions are enabled"
H0484D634DF37: "在启用C++异常时，不能在协程中使用SEH的 '__try'"
# "cannot use SEH '__try' in blocks, captured regions, or Obj-C method decls"
HAED8CA9442A3: "不能在块、捕获区域或Objective-C方法声明中使用SEH的 '__try'"
# 'cannot use WebAssembly table as a function parameter'
H70C162E9FD41: '不能将WebAssembly表用作函数参数'
# 'cannot use a WebAssembly table within a branch of a conditional expression'
H4CC748CB0567: '不能在条件表达式的一个分支中使用WebAssembly表'
# "cannot use a protocol declared 'objc_non_runtime_protocol' in a @protocol expression"
H22D18CFED6B9: "不能在@protocol表达式中使用标记为 'objc_non_runtime_protocol' 的协议"
# "cannot use an empty string literal in 'asm'"
H9269C6D18FCF: "不能在 'asm' 中使用空字符串字面量"
# 'cannot use dynamic_cast to convert from %0 to %1'
H5749CC5204B8: '不能将dynamic_cast用于从 %0 到 %1 的转换'
# 'cannot use incomplete type %0 as a range'
H779605C5A805: '不能将不完整类型 %0 用作范围'
# 'cannot use initializer list at the beginning of a macro argument'
HFB12BDAF6D6F: '不能在宏参数开头使用初始化列表'
# 'cannot use type %0 as a range'
H9F644F56E9E3: '不能将类型 %0 用作范围'
# 'cannot use type %0 as an iterator'
H45599EAAF2D8: '不能将类型 %0 用作迭代器'
# "cannot use type '%0' within '#pragma clang fp eval_method'; type is set according to the default eval method for the translation unit"
HD91CCA267FD1: "不能在 '#pragma clang fp eval_method' 中使用类型 '%0'；该类型由翻译单元的默认求值方法决定"
# 'cannot use variable %1 in collapsed imperfectly-nested loop %select{init|condition|increment}0 statement'
H40887EDB8E4A: '无法在折叠的嵌套循环 %select{init|condition|increment}0 语句中使用变量 %1'
# 'cannot use variable-length arrays in %select{__device__|__global__|__host__|__host__ __device__}0 functions'
H33A7639314BD: '不能在 %select{__device__|__global__|__host__|__host__ __device__}0 函数中使用变长数组'
# "cannot write file '%0': %1"
H57D82DC5A945: '无法写入文件 "%0": %1'
# 'cannot yet @encode type %0'
H5CF1C5265DEE: '目前无法@encode类型 %0'
# 'cannot yet compile %0 in this ABI'
H7B123038B924: '当前ABI无法编译 %0'
# 'cannot yet mangle %0 expression'
HA255CBB16444: '目前无法对 %0 表达式进行名称修饰'
# 'cannot yet mangle OpenACC Asterisk Size expression'
H2D31700B7C49: '目前无法对OpenACC星号大小表达式进行名称修饰'
# 'cannot yet mangle expression type %0'
HF4D45A826D3A: '无法对表达式类型 %0 进行名称修饰'
# 'capture %0 by %select{value|reference}1'
HD0ACA3E1F2BB: '通过%select{值|引用}1捕获 %0'
# 'capture default must be first'
HBD6F708D5FEC: '捕获默认必须放在最前面'
# 'capture host side class data member by this pointer in device or host device lambda function may result in invalid memory access if this pointer is not accessible on device side'
HA00333F0A82E: '在设备或混合设备lambda函数中通过this指针捕获主机侧类的数据成员，如果该this指针在设备侧不可访问，可能导致无效内存访问'
# 'capture host variable %0 by reference in device or host device lambda function'
H4218AAE93F26: '在设备或混合设备lambda函数中按引用捕获主机变量 %0'
# "capture of '*this' by copy is a C++17 extension"
H9C3948693023: '按值捕获 "*this" 是C++17扩展'
# "capture of variable '%0' as type %1 calls %select{private|protected}3 %select{default |copy |move |*ERROR* |*ERROR* |*ERROR* |}2constructor"
H6489D0544330: '将变量 "%0" 作为类型 %1 捕获调用%select{私有|保护}3%select{默认 |拷贝 |移动 |*ERROR* |*ERROR* |*ERROR* |}2 构造函数'
# 'captured structured bindings are a C++20 extension'
HED60DD4C6A62: '捕获结构化绑定是C++20扩展'
# 'captured structured bindings are incompatible with C++ standards before C++20'
HA1967A579A6F: '捕获结构化绑定与C++20之前的C++标准不兼容'
# 'capturing %0 strongly in this block is likely to lead to a retain cycle'
H495EA167E92F: '在此块中强捕获 %0 可能会导致保留循环'
# 'capturing a structured binding is not yet supported in OpenMP'
H3DD2898A017E: 'OpenMP暂不支持捕获结构化绑定'
# 'case ranges are a C2y extension'
H022E1C3F4097: 'case范围是C2y扩展'
# 'case ranges are a GNU extension'
H0ADA830DF441: 'case范围是GNU扩展'
# 'case ranges are incompatible with C standards before C2y'
H94092A9759CB: 'case范围与C2y之前的C标准不兼容'
# 'case value not in enumerated type %0'
H4866E4105494: '枚举类型 %0 中不存在该case值'
# 'cast %diff{from $ to $ |}0,1converts to incompatible function type'
HAE54FE7B3C1C: '将%diff{从$转为$ |}0,1 转换为不兼容的函数类型'
# "cast between incompatible calling conventions '%0' and '%1'; calls through this pointer may abort at runtime"
HB4A395B83746: '在调用约定类型 "%0" 和 "%1" 之间进行转换；通过该指针调用可能在运行时中止'
# 'cast between pointer-to-function and pointer-to-object is an extension'
H276B46B48964: '函数指针和对象指针之间的转换是扩展'
# 'cast between pointer-to-function and pointer-to-object is incompatible with C++98'
HD37948261117: '函数指针和对象指针之间的转换与C++98不兼容'
# 'cast expression to void to silence warning'
H1D7499C23CFE: '将表达式强制转换为void以消除警告'
# 'cast from %0 is not allowed in a constant expression %select{in C++ standards before C++2c|because the pointed object type %2 is not similar to the target type %3}1'
H542ED6DEC45B: '%select{在 C++2c 之前的 C++ 标准中|因为指向对象类型 %2 不与目标类型 %3 兼容}1 不允许将 %0 转换为常量表达式'
# 'cast from %0 to %1 drops %select{const and volatile qualifiers|const qualifier|volatile qualifier}2'
HA3B03023258D: '从 %0 转换到 %1 会丢失 %select{const和volatile限定符|const限定符|volatile限定符}2'
# 'cast from %0 to %1 increases required alignment from %2 to %3'
H4A02BB23383F: '将 %0 转换为 %1 需要的对齐从 %2 增加到 %3'
# 'cast from %0 to %1 must have all intermediate pointers const qualified to be safe'
HB7DFA89AF07B: '从 %0 到 %1 的强制转换必须将所有中间指针用const限定以保证安全'
# 'cast from function call of type %0 to non-matching type %1'
H8CE3B0EB72DC: '将函数调用类型 %0 强制转换为不匹配的类型 %1'
# 'cast from pointer to smaller type %2 loses information'
H60D928000B5D: '将指向较小类型 %2 的指针强制转换会丢失信息'
# 'cast of %select{Objective-C|block|C}0 pointer type %1 to %select{Objective-C|block|C}2 pointer type %3 cannot use %select{__bridge|__bridge_transfer|__bridge_retained}4'
H2F5F45B60576: '将 %select{Objective-C|block|C}0 指针类型 %1 强制转换为 %select{Objective-C|block|C}2 指针类型 %3 时不能使用 %select{__bridge|__bridge_transfer|__bridge_retained}4'
# 'cast of type %0 to %1 is deprecated; use sel_getName instead'
HC7428E5162D0: '将类型 %0 转换为 %1 的强制转换已弃用；请改用sel_getName'
# 'cast one or both operands to int to silence this warning'
H49949EF0EEB5: '将其中一个或两个操作数强制转换为int以消除此警告'
# 'cast to %1 from smaller integer type %0'
HF29EC08A2098: '将较小的整型 %0 强制转换为 %1'
# 'cast to incomplete type %0'
HB29014F052FD: '将不完整类型 %0 进行强制转换'
# 'cast to smaller integer type %1 from %0'
H3EAB0F6AAF90: '将 %0 强制转换为较小的整型 %1'
# 'cast to union type from type %0 not present in union'
H26129A704E2A: '将类型 %0（该类型未在联合中定义）强制转换为联合类型'
# 'cast to union type is a GNU extension'
H07ADEAB6CDD8: '将联合类型进行强制转换是GNU扩展'
# 'casting from randomized structure pointer type %0 to %1'
H760D7A3D8C24: '将随机化结构体指针类型 %0 强制转换为 %1'
# "casting to dereferenceable pointer removes 'noderef' attribute"
H435CE65222D6: '将指针强制转换为可解引用指针会移除 "noderef" 属性'
# 'casting to type %0 is not allowed'
H05073823504A: '转换为类型 %0 是不允许的'
# 'catch-all handler must come last'
H18423565AC35: '默认异常处理程序必须放在最后'
# 'category is implementing a method which will also be implemented by its primary class'
H12CCDCE8A3DF: '分类正在实现一个方法，该方法也会由其主类实现'
# "chained comparison 'X %0 Y %1 Z' does not behave the same as a mathematical expression"
HF2403FB0CB87: '链式比较 "X %0 Y %1 Z" 的行为与数学表达式不同'
# 'change layout of basic blocks in a function'
HFA932943E87E: '更改函数中基本块的布局'
# "change return type to 'int'"
H2DD08C8E9ADD: '将返回类型更改为int'
# 'change size argument to be the size of the destination'
HC31A5632ABB1: '将大小参数更改为目标类型的大小'
# 'change the argument to be the free space in the destination buffer minus the terminating null byte'
H66702CDAA7E2: '将参数更改为目标缓冲区的可用空间减去终止空字节'
# "change this ',' to a ';' to call %0"
H5A1EAB3B7F87: "将此 ',' 改为 ';' 以调用 %0"
# "change type of %0 to '%select{std::span' to preserve bounds information|std::array' to label it for hardening|std::span::iterator' to preserve bounds information}1%select{|, and change %2 to '%select{std::span|std::array|std::span::iterator}1' to propagate bounds information between them}3"
H1123F3B73559: "将 %0 的类型更改为 '%select{std::span' 以保留边界信息|std::array'以标记为强化|std::span::iterator'以保留边界信息}1%select{|，并将 %2 更改为 '%select{std::span|std::array|std::span::iterator}1' 以在它们之间传播边界信息}3"
# "change type of %0 to '%select{std::span' to preserve bounds information|std::array' to label it for hardening|std::span::iterator' to preserve bounds information}1%select{|, and change %2 to safe types to make function %4 bounds-safe}3"
H9C76AEF6C221: "将 %0 的类型更改为 '%select{std::span' 以保留边界信息|std::array'以标记为强化|std::span::iterator'以保留边界信息}1%select{|，并将 %2 更改为安全类型以使函数 %4 具有边界安全性}3"
# 'char is signed'
H28989E053B4F: 'char是有符号类型'
# 'char is unsigned'
H2C9C5C4D7121: 'char是无符号类型'
# "character '%0' cannot be specified by a universal character name"
H9FDECB7636A6: "字符 '%0' 不能通过通用字符名指定"
# 'character <U+%0> not allowed %select{in|at the start of}1 an identifier'
H0604F74F1073: '字符 <U+%0> 不允许%select{在|在开头}1标识符中'
# 'character constant too long for its type'
H99E005D8F34A: '字符常量的长度超过其类型允许的范围'
# 'character literal with user-defined suffix cannot be used here'
HB73A18549E7B: '此处不能使用具有用户定义后缀的字符文字'
# 'character too large for enclosing character literal type'
HFC3FA51117BB: '字符过大，超出包含的字符类型范围'
# 'characters names in Unicode escape sequences are sensitive to case and whitespaces'
H6FEF0F08A2BB: 'Unicode转义序列中的字符名称对大小写和空白符敏感'
# 'charizing operator #@ is a Microsoft extension'
H374F252BD0E9: '字符化运算符#@是Microsoft扩展'
# 'check arguments and return values at function call boundaries'
H68B4A050C0B9: '在函数调用边界检查参数和返回值'
# "checker '%0' has no option called '%1'"
H473E877D384D: "检查器 '%0' 没有名为 '%1' 的选项"
# "checker cannot be enabled with analyzer option '%0' == %1"
H9705343670F8: "无法通过分析器选项 '%0' == %1 启用检查器"
# "checker plugin '%0' is not compatible with this version of the analyzer"
H6AAE762D0724: "检查器插件 '%0' 与此版本的分析器不兼容"
# 'chosen constructor is explicit in copy-initialization'
H0B94DB59D2D8: '在拷贝初始化中选择的构造函数是显式的'
# 'circular pointer delegation detected'
H16A98512E3BA: '检测到循环指针委托'
# 'clang LLVM compiler'
HFB02B9C0A298: 'clang LLVM编译器'
# 'clang-check options'
HEBD1BCAEB597: 'clang-check 选项'
# 'clang-diff options'
HC57563571B39: 'clang-diff 选项'
# 'clang-doc options'
H711FBA0260F1: 'clang 文档生成选项'
# 'clang-extdefmapgen options'
HD98304B7C5E5: 'clang 外部定义映射生成选项'
# 'clang-move options'
H51D1273C1656: 'clang 代码移动选项'
# 'clang-offload-bundler options'
H2BBBC154A925: 'clang 离线编译捆绑选项'
# 'clang-offload-packager options'
HBBA0DBA3D90F: 'clang 离线编译打包选项'
# 'clang-query options'
HEE4551CABF87: 'clang 查询选项'
# 'clang-rename could not find symbol %0'
H72B95322F623: 'clang-rename无法找到符号 %0'
# 'clang-rename could not find symbol (offset %0)'
H9B2484C454C5: 'clang-rename无法找到符号（偏移量 %0）'
# 'clang-reorder-fields options'
HB5EDCC7DF359: 'clang-reorder-fields选项'
# 'clang-tidy options'
H123FF2E74AC8: 'clang-tidy选项'
# 'clangd compilation flags options'
H9BB98137F26A: 'clangd编译标志选项'
# 'class %0 defined without specifying a base class'
H3A2FB228D84B: '类 %0 在未指定基类的情况下被定义'
# 'class %0 has incompatible superclasses'
HAE8DDB1E1535: '类 %0 具有不兼容的超类'
# 'class %0 previously declared with type parameters'
H5BCC48BDFD6B: '类 %0 之前使用类型参数声明过'
# "class already marked '%0'"
HCB141E8798E7: "类已标记为 '%0'"
# "class already marked '%select{trivially_relocatable_if_eligible|replaceable_if_eligible}0'"
H5024671CC38B: "该类已标记为 '%select{trivially_relocatable_if_eligible|replaceable_if_eligible}0'"
# 'class extension has no primary class'
H14396A81AB6D: '类扩展没有主类'
# 'class has %0 base %plural{1:class|:classes}0'
HD719F68B2E7D: '类具有 %0 基 %plural{1:类|:类}0'
# 'class has base type %0'
H55F5972959B4: '类的基类型为 %0'
# 'class implementation is declared here'
HFDD816FBE31D: '类实现在此处声明'
# 'class implementation may not have super class'
HF88305654764: '类实现不能有超类'
# 'class is declared here'
H1CB72009FE78: '类在此处声明'
# 'class is incompatible with __weak references'
H5D4A2732A59E: '该类与 __weak 引用不兼容'
# 'class member %0 cannot appear in capture list as it is not a variable'
HB01A6BF35CAF: '类成员 %0 不能出现在捕获列表中，因为它不是变量'
# "class member already marked '%0'"
H8651C68C3085: "类成员已标记为 '%0'"
# 'class member cannot be redeclared'
H011ED139495E: '类成员不能重新声明'
# "class method %objcclass0 not found (return type defaults to 'id')"
HA1F101EC915B: "未找到类方法 %objcclass0（返回类型默认为 'id'）"
# "class method %objcclass0 not found (return type defaults to 'id'); did you mean %objcclass2?"
H4EC4BD008AC8: "未找到类方法 %objcclass0（返回类型默认为 'id'）；是否是指 %objcclass2？"
# 'class property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this category'
H70F68CFFF089: '类属性 %0 需要定义方法 %1 —— 请使用 @dynamic 或在该分类中提供方法实现'
# 'class property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this class implementation'
HC6D0854C646B: '类属性 %0 需要定义方法 %1 —— 请使用 @dynamic 或在该类实现中提供方法实现'
# 'class template %0 was explicitly specialized here'
HAF7828F4534C: '类模板 %0 已在此处显式特化'
# 'class template %0 was instantiated here'
H67A993394D9A: '类模板 %0 已在此处实例化'
# 'class template argument deduction for %0 selected a deleted constructor'
H2F3153B3F0E2: '%0 的类模板参数推导选中了一个已删除的构造函数'
# 'class template argument deduction for %0 selected an explicit %select{constructor|deduction guide}1 for copy-list-initialization'
HC409A532BB3A: '%0 的类模板参数推导为复制列表初始化选中了一个显式的 %select{构造函数|推导指引}1'
# 'class template argument deduction for alias templates is a C++20 extension'
HDC66CA6F51E2: '别名模板的类模板参数推导是 C++20 扩展'
# 'class template argument deduction for alias templates is incompatible with C++ standards before C++20'
H0A109AC10809: '别名模板的类模板参数推导与 C++20 之前的 C++ 标准不兼容'
# 'class template argument deduction is incompatible with C++ standards before C++17%select{|; for compatibility, use explicit type name %1}0'
HCFEDA0AEF7C1: '类模板参数推导与C++17之前的C++标准不兼容 %select{|; 为兼容性，请显式指定类型名 %1}0'
# 'class template partial specialization %0 cannot be redeclared'
HD6C67286FA78: '类模板部分特化 %0 不能被重新声明'
# "class with destructor marked '%select{final|sealed}0' cannot be inherited from"
H8F6FAE53F32D: "带有被标记为 '%select{final|sealed}0' 的析构函数的类不能被继承"
# 'class with specified objc_requires_property_definitions attribute is declared here'
H42C6E2F16E82: '指定了 objc_requires_property_definitions 属性的类在此处声明'
# 'cmse is not compatible with %select{RWPI|ROPI}0'
HC391A16C0EBD: 'cmse 不兼容 %select{RWPI|ROPI}0'
# "code model '%0' is not supported on this target"
HCF39144044A7: "代码模型 '%0' 不受此目标平台支持"
# 'code snippets to measure'
HC114C78CBCD4: '要测量的代码片段'
# 'code will never be executed'
H2586D13FCD3D: '代码永远不会被执行'
# 'collect control flow for each function'
H88E591AFCC3E: '为每个函数收集控制流信息'
# 'collection element of type %0 is not an Objective-C object'
H8FFDEDA7A274: '集合元素类型 %0 不是Objective-C对象'
# 'collection expression type %0 is a forward declaration'
HDDCD4086A7F8: '集合表达式类型 %0 是前向声明'
# 'collection expression type %0 may not respond to %1'
H8F39224B1450: '集合表达式类型 %0 可能无法响应 %1'
# 'comma expressions are not allowed as indices in matrix subscript expressions'
H3F02FDCEC720: '矩阵下标表达式的索引中不允许使用逗号表达式'
# 'comma operator in operand of #if'
HDC042AF8F218: '#if 运算符的运算对象中包含逗号运算符'
# 'comma separating Objective-C messaging arguments'
HAB4747C7C927: 'Objective-C消息传递参数间的逗号分隔符'
# 'comma-separated list of OpenMP offloading triples'
HB9DA81E6157C: '以逗号分隔的OpenMP卸载三元组列表'
# 'comma-separated list of opcodes to measure, by name'
HC296D61A5AC3: '以逗号分隔的要测量的指令名称列表'
# 'comma-separated list of target architecture features'
H115643195B7E: '以逗号分隔的目标架构特性列表'
# 'command line argument'
H13C820D51A04: '命令行参数'
# 'commas at the end of enumerator lists are a C++11 extension'
H2EA69DF0ADB4: '枚举列表末尾的逗号是C++11扩展语法'
# 'commas at the end of enumerator lists are a C99-specific feature'
H1F877ED68177: '枚举列表末尾的逗号是C99特定特性'
# 'commas at the end of enumerator lists are incompatible with C++98'
H28609FC0503F: '枚举列表末尾的逗号与C++98标准不兼容'
# 'comparing a pointer to a null character constant; did you mean to compare to %select{NULL|(void *)0}0?'
H5D12051B65A0: '正在将指针与空字符常量进行比较；是否应比较 %select{NULL|(void *)0}0？'
# 'comparing floating point with == or != is unsafe'
H1DE5EF3912E1: '使用 == 或 != 比较浮点数是不安全的'
# "comparing values of different Unicode code unit types %0 and %1 compares unrelated code units '%2' and '%3'"
H8DCD3F2A59F0: "比较不同Unicode码元类型 %0 和 %1 时，将比较不相关的码元 '%2' 和 '%3'"
# 'comparing values of different Unicode code unit types %0 and %1 may compare different code points'
H29AC22B06621: '比较不同Unicode码元类型 %0 和 %1 的值可能会比较不同的码点'
# 'comparing with this %select{specifier|format string}0'
H0EA8BCD476F7: '与这个 %select{说明符|格式字符串}0 进行比较'
# "comparison against address of weak declaration '%0' can only be performed at runtime"
H3C6EE2D92685: "对弱声明 '%0' 的地址进行比较只能在运行时执行"
# "comparison against opaque constant address '%0' can only be performed at runtime"
HAC7288F66309: "对不透明常量地址 '%0' 的比较只能在运行时执行"
# "comparison against pointer '%0' that points past the end of a complete object has unspecified value"
H3D15A3D98DF0: "指向完整对象末尾之后的指针 '%0' 的比较具有未指定值"
# 'comparison against pointer to weak member %q0 can only be performed at runtime'
HFCA39B812783: '对弱成员 %q0 的指针进行比较只能在运行时执行'
# 'comparison between NULL and non-pointer %select{(%1 and NULL)|(NULL and %1)}0'
H20F85EBECAC2: 'NULL与非指针类型 %select{(%1 和 NULL)|(NULL 和 %1)}0 进行比较'
# 'comparison between pointer and integer (%0 and %1)'
H9205163E9BD4: '指针与整数 (%0 和 %1) 之间的比较'
# "comparison between pointers to unrelated objects '%0' and '%1' has unspecified value"
H722AC288816C: "指向无关对象 '%0' 和 '%1' 的指针之间的比较具有未指定值"
# "comparison between two arrays compare their addresses and will be deprecated in c++20; to compare array addresses, use unary '+' to decay operands to pointers"
H5D551E6212F9: "两个数组的比较会比较它们的地址，并将在C++20中弃用；要比较数组地址，请使用一元 '+' 运算符将操作数转换为指针"
# "comparison between two arrays is deprecated; to compare array addresses, use unary '+' to decay operands to pointers"
H4D3F55AAB37F: "两个数组的比较已被弃用；要比较数组地址，请使用一元 '+' 运算符将操作数转换为指针"
# "comparison between two arrays is ill-formed in C++26; to compare array addresses, use unary '+' to decay operands to pointers"
H20B4EE22A6C2: "在C++26中比较两个数组是不符合规范的；要比较数组地址，请使用一元 '+' 运算符将操作数转换为指针"
# "comparison in fold expression would evaluate to '(X %0 Y) %0 Z' which does not behave the same as a mathematical expression"
HEA2CC1542868: '折叠表达式中的比较将求值为 "(X %0 Y) %0 Z"，其行为与数学表达式不同'
# "comparison of %select{address of|function|array}0 '%1' %select{not |}2equal to a null pointer is always %select{true|false}2"
H61B7557646A7: "%select{地址的|函数|数组}0 '%1' 与空指针 %select{不 |}2 相等的比较始终为 %select{true|false}2"
# 'comparison of address of base class subobject %0 of class %1 to field %2 has unspecified value'
HCEA4BEB9DFF0: '对类 %1 的基类子对象 %0 的地址与字段 %2 进行比较具有未指定值'
# 'comparison of address of fields %0 and %2 of %4 with differing access specifiers (%1 vs %3) has unspecified value'
H30BB5DCF7738: '对 %4 中具有不同访问说明符（%1 与 %3）的字段 %0 和 %2 的地址进行比较具有未指定值'
# 'comparison of addresses of potentially overlapping literals has unspecified value'
H59EF9C14B9AF: '对可能重叠的字面量的地址进行比较具有未指定值'
# 'comparison of addresses of subobjects of different base classes has unspecified value'
HA10192E66EB6: '对不同基类的子对象的地址进行比较具有未指定值'
# 'comparison of different enumeration types in switch statement%diff{ ($ and $)|}0,1'
H820D2D4F7522: '在switch语句中比较不同的枚举类型%diff{ ($ 和 $)|}0,1'
# 'comparison of distinct block types%diff{ ($ and $)|}0,1'
HA2CFC62DE473: '比较不同块类型%diff{ ($ 和 $)|}0,1'
# 'comparison of distinct pointer types%diff{ ($ and $)|}0,1'
H1D24D97A54FF: '比较不同指针类型%diff{ ($ 和 $)|}0,1'
# 'comparison of integers of different signs: %0 and %1'
H8C3AA027FA1B: '不同符号的整数比较：%0 和 %1'
# "comparison of nonnull %select{function call|parameter}0 '%1' %select{not |}2equal to a null pointer is '%select{true|false}2' on first encounter"
H9EDFDB49F3E3: "对非空 %select{函数调用|参数}0 '%1' 与空指针 %select{不 |}2 相等的比较在首次遇到时为 '%select{true|false}2'"
# "comparison of numeric address '%0' with pointer '%1' can only be performed at runtime"
HFBF28443EB32: "对数值地址 '%0' 与指针 '%1' 的比较只能在运行时进行"
# 'comparison of pointer to virtual member function %0 has unspecified value'
HDF5F345093AE: '对虚成员函数 %0 的指针进行比较具有未指定的值'
# "comparison of pointers '%0' and '%1' to unrelated zero-sized objects"
H0C0F9C2F76E9: "无关零大小对象指针 '%0' 和 '%1' 的比较"
# 'comparison operator template cannot be defaulted'
HC75525ADCB07: '比较运算符模板不能默认'
# "compatibility_version does not match: '%0' (provided) vs '%1' (found)"
H96AD79FF790D: "兼容性版本不匹配：'%0'（已提供）与 '%1'（已找到）"
# 'compatible type %0 specified here'
HA0D702990A9A: '此处指定的兼容类型 %0'
# "compilation database '%0' could not be opened: %1"
H55D78247B7D8: "无法打开编译数据库 '%0'：%1"
# 'compile time floating point arithmetic suppressed in strict evaluation modes'
H1CBDE348A919: '严格求值模式下禁止编译时浮点运算'
# "compiled from '%0' and '%1'"
H27BB14892FCB: "从 '%0' 和 '%1' 编译而来"
# 'compiler has implicitly changed method %0 return type'
HA0BE2730FEEE: '编译器已隐式更改方法 %0 的返回类型'
# 'completion handler is called twice'
HA50FDB30A90B: '完成处理程序被调用了两次'
# 'completion handler is never %select{used|called}1 when %select{taking true branch|taking false branch|handling this case|none of the cases applies|entering the loop|skipping the loop|taking one of the branches}2'
HF3977C617098: '当%select{取真分支|取假分支|处理此情况|所有情况均不适用|进入循环|跳过循环|取其中一个分支}2时，完成处理程序从未%select{使用|调用}1'
# 'complex initialization specifying real and imaginary components is an extension'
H4D2B224EF174: '同时指定实部和虚部的复数初始化是一项扩展'
# 'complex integer types are a GNU extension'
H69724ED89FCA: '复数整数类型是GNU扩展'
# 'complex numbers are an extension in a freestanding C99 implementation'
HC53143A84579: '自由-standing C99实现中的复数类型是一项扩展'
# 'compound binary operator not supported, only +=, *=, -=, /=, &=, ^=, |=, <<=, or >>= are permitted'
H7DD0E2130464: '仅允许使用 +=, *=, -=, /=, &=, ^=, |=, <<= 或 >>=，不支持其他复合二进制运算符'
# 'compound literal cannot be of variable-length array type'
H35B29277CD5B: '复合字面量不能是可变长度数组类型'
# 'compound literal in function scope may not be qualified with an address space'
H5D92A895F54C: '函数作用域内的复合字面量不能用地址空间进行限定'
# 'compound literals are a C99-specific feature'
H89109EF1C578: '复合字面量是C99特定特性'
# 'concatenated NSString literal for an NSArray expression - possibly missing a comma'
H05B938722790: '用于NSArray表达式的连接NSString字面量 - 可能缺少逗号'
# 'concept cannot have associated constraints'
H2D3AA7366D73: '概念不能具有关联约束'
# 'concept declarations may only appear in global or namespace scope'
HC471DCAA93F1: '概念声明只能出现在全局或命名空间作用域中'
# 'concept named in type constraint is not a type concept'
H745ADE930837: '类型约束中命名的概念不是一个类型概念'
# 'concept template parameter list must have at least one parameter; explicit specialization of concepts is not allowed'
HBDA562F258A9: '概念模板参数列表必须至少包含一个参数；不允许显式特化概念'
# "condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', %select{or '>='|'>=', or '!='}0) of loop variable %1"
H8BF46A7D7B10: "OpenMP for循环的条件必须是循环变量 %1 的 relational 比较（'<'、'<=', '>', %select{或 '>='|'>=', 或 '!='}0）"
# 'conditional expression is ambiguous; %diff{$ and $|types}0,1 can be converted to several common types'
H9909B5566589: '条件表达式存在歧义；%diff{$ 和 $|类型}0,1 可以转换为多种公共类型'
# 'conditional expression is ambiguous; %diff{$ can be converted to $ and vice versa|types can be convert to each other}0,1'
HD6EF4047D3B6: '条件表达式存在歧义；%diff{$ 可以转换为 $ 并且反之|类型可以相互转换}0,1'
# "configuration file '%0' cannot be found"
HF43B1D62E529: "配置文件 '%0' 未找到"
# "configuration file '%0' cannot be opened: %1"
H91238BB29F2B: "无法打开配置文件 '%0'：%1"
# 'configuration macros are only allowed in top-level modules'
HC1EFBD1A6AB2: '配置宏仅允许在顶层模块中使用'
# 'conflicting %0 here'
H178724C0754B: '此处与 %0 冲突'
# 'conflicting __device__ function declared here'
H6D42767A98E2: '此处声明的 __device__ 函数存在冲突'
# 'conflicting address space qualifiers are provided between types %0 and %1'
HA444D7C677AE: '类型 %0 和 %1 之间提供的地址空间限定符存在冲突'
# 'conflicting asm label'
H08C5ACC499B8: '冲突的汇编标签'
# 'conflicting attribute is here'
HB210D5E7919C: '冲突的属性在此处'
# 'conflicting attributes %0 are ignored'
H43DE73EC415F: '冲突的属性 %0 被忽略'
# "conflicting attributes for state '%0'"
H30B7C9BA9F57: "状态 '%0' 的属性存在冲突"
# 'conflicting code segment specifiers'
HF81F9823233E: '冲突的代码段指定符'
# 'conflicting declaration'
H9D2B5D5AA66E: '冲突的声明'
# 'conflicting deduction %diff{$ against $|types}0,1 for parameter'
H0919F4EB4F97: '参数的类型推导与 %diff{$ 和 $|类型}0,1 存在冲突'
# "conflicting deployment targets, both '%0' and '%1' are present in environment"
H8F50D7638091: "部署目标存在冲突，环境同时包含 '%0' 和 '%1'"
# 'conflicting distributed object modifiers on parameter type in declaration of %0'
H4CB94BB5639A: '在 %0 的声明中参数类型存在冲突的分布式对象修饰符'
# 'conflicting distributed object modifiers on parameter type in implementation of %0'
HA9E88E86F6C2: '在 %0 的实现中参数类型存在冲突的分布式对象修饰符'
# 'conflicting distributed object modifiers on return type in declaration of %0'
HBE23CBB42FFE: '在 %0 的声明中返回类型存在冲突的分布式对象修饰符'
# 'conflicting distributed object modifiers on return type in implementation of %0'
HBB60CEE9C2B2: '在 %0 的实现中返回类型存在冲突的分布式对象修饰符'
# 'conflicting instance variable names: %0 vs %1'
H088E6A0E59D6: '冲突的实例变量名：%0 与 %1'
# 'conflicting loop attribute %0'
H69465530AFA7: '冲突的循环属性 %0'
# 'conflicting nullability specifier on parameter types, %0 conflicts with existing specifier %1'
H11AC0D03E320: '参数类型上的空值指定符冲突：%0 与现有指定符 %1 冲突'
# 'conflicting nullability specifier on return types, %0 conflicts with existing specifier %1'
H9D01BC58F478: '返回类型上的空值指定符冲突：%0 与现有指定符 %1 冲突'
# "conflicting option '-fcoro-aligned-allocation' and '-fno-aligned-allocation'"
HD53AB264ABE6: "选项 '-fcoro-aligned-allocation' 与 '-fno-aligned-allocation' 冲突"
# 'conflicting parameter qualifier %0 on parameter %1'
HC7B786535E39: '参数 %1 上存在冲突的参数限定符 %0'
# 'conflicting parameter types in declaration of %0%diff{: $ vs $|}1,2'
HCBD5D6ED758A: '在 %0 的声明中参数类型冲突 %diff{: $ vs $|}1,2'
# 'conflicting parameter types in declaration of %0: %1 vs %2'
HF405BA99A067: '在 %0 的声明中参数类型冲突：%1 与 %2'
# 'conflicting parameter types in implementation of %0%diff{: $ vs $|}1,2'
H64F50A39ECB1: '在 %0 的实现中参数类型冲突 %diff{: $ vs $|}1,2'
# 'conflicting parameter types in implementation of %0: %1 vs %2'
HC0C8356B7475: '在 %0 的实现中参数类型冲突：%1 与 %2'
# 'conflicting pass_object_size attributes on parameters'
H99CE421CA443: '参数上的 pass_object_size 属性冲突'
# 'conflicting prototype is here'
HF896EFD79698: '冲突的原型在此处'
# "conflicting re-export of module '%0' as '%1' or '%2'"
H8B0F3A29C0A1: "冲突的模块重导出：'%0' 作为 '%1' 或 '%2'"
# 'conflicting return type in declaration of %0%diff{: $ vs $|}1,2'
H2BB3153B6C50: '在 %0 的声明中返回类型冲突 %diff{: $ vs $|}1,2'
# 'conflicting return type in declaration of %0: %1 vs %2'
H5D783A189DCF: '在 %0 的声明中返回类型冲突：%1 与 %2'
# 'conflicting return type in implementation of %0%diff{: $ vs $|}1,2'
HEB354C372ED1: '在 %0 的实现中返回类型冲突 %diff{: $ vs $|}1,2'
# 'conflicting return type in implementation of %0: %1 vs %2'
H5C54E8625E6A: '在 %0 的实现中返回类型冲突：%1 与 %2'
# 'conflicting super class name %0'
HF493EF2E1E41: '父类名称 %0 冲突'
# 'conflicting types for %0'
H5E0475C2D7BC: '%0 的类型冲突'
# 'conflicting types for alias %0'
HCE7DAE70AA85: '别名 %0 的类型冲突'
# 'conflicting variadic declaration of method and its implementation'
H2A0A12EA2AF3: '方法及其实现的可变参数声明冲突'
# 'conformance of forward class %0 to protocol %1 cannot be confirmed'
H978A4E78BB8C: '无法确认前向类 %0 对协议 %1 的符合性'
# "consecutive right angle brackets are incompatible with C++98 (use '> >')"
H77515E521F08: "连续的右尖括号与C++98不兼容（请使用 '> >'）"
# 'conservative handling of inline assembly'
H316430B34522: '内联汇编的保守处理'
# "consider adding '%0' to the header search path"
HCE15ED850DE4: "考虑将 '%0' 添加到头文件搜索路径"
# "consider defining %0 with the '%1' calling convention"
H6A4F6FD30F2D: "考虑使用 '%1' 调用约定定义 %0"
# 'consider making the bit-field type %select{unsigned|signed}0'
HDAE81431A685: '考虑将位域类型设置为 %select{unsigned|signed}0'
# 'consider providing a complete definition for %0'
H2F6F79E2A183: '建议为 %0 提供完整的定义'
# "consider using '__sized_by%select{|_or_null}0' instead of '__counted_by%select{|_or_null}0'"
H40017362835A: "考虑改用 '__sized_by%select{|_or_null}0' 而非 '__counted_by%select{|_or_null}0'"
# "consider using __builtin_trap() or qualifying pointer with 'volatile'"
H002E765592F2: "考虑使用__builtin_trap()或用 'volatile' 修饰指针"
# 'consider using vld1_%0%1() to initialize a vector from memory, or vcreate_%0%1() to initialize from an integer constant'
H3E54619F1458: '考虑使用vld1_%0%1()从内存初始化向量，或使用vcreate_%0%1()从整数常量初始化'
# 'consider using vld1q_%0%1() to initialize a vector from memory, or vcombine_%0%1(vcreate_%0%1(), vcreate_%0%1()) to initialize from integer constants'
H0B91FFD90BE8: '考虑使用vld1q_%0%1()从内存初始化向量，或使用vcombine_%0%1(vcreate_%0%1(), vcreate_%0%1())从整数常量初始化'
# 'const variable cannot be emitted on device side due to dynamic initialization'
H2D4E40F2FA4A: '由于动态初始化，const变量无法在设备端生成'
# 'const-qualified list item cannot be %0'
HABDF81BBC813: 'const限定的列表项不能是 %0'
# 'const-qualified variable cannot be %0'
H02E8DDC8D310: 'const限定的变量不能是 %0'
# 'const-qualified variable without mutable fields cannot be %0'
HF38DA802B6DD: '没有可变字段的const限定变量不能是 %0'
# 'constant evaluation of %0 between arrays of types %1 and %2 is not supported; only arrays of narrow character types can be compared'
H42EAC15FC487: '在类型 %1 和 %2 的数组之间对 %0 进行常量求值不受支持；仅窄字符类型的数组可以比较'
# 'constant evaluation of %0 on array of type %1 is not supported; only arrays of narrow character types can be searched'
HCF9A8296188E: '在类型 %1 的数组上对 %0 进行常量求值不受支持；仅窄字符类型的数组可以搜索'
# 'constant expression evaluates to %0 which cannot be narrowed to type %1'
HE08100927247: '常量表达式求值为 %0，无法窄化为类型 %1'
# 'constant expression evaluates to %0 which cannot be narrowed to type %1 in C++11'
H3A70E9ED4BE6: '常量表达式计算结果为 %0，在C++11中无法转换为类型 %1'
# 'consteval function %0 cannot override a non-consteval function'
HD9788F98961F: 'consteval函数 %0 不能覆盖非consteval函数'
# 'consteval if is a C++23 extension'
H32DA4F52DDFE: 'consteval if是C++23的扩展'
# 'consteval if is always true in an %select{unevaluated|immediate}0 context'
HFA38139DBCC5: '在%select{未计算|立即}0上下文中，consteval if始终为真'
# 'consteval if is incompatible with C++ standards before C++23'
H3BF3B6976984: 'consteval if与C++23之前的版本不兼容'
# 'constexpr %select{member function|constructor}0 not allowed in %select{struct|interface|class}1 with virtual base %plural{1:class|:classes}2'
HA87030D3447E: 'constexpr %select{成员函数|构造函数}0 不允许出现在包含虚基 %plural{1:类|:类}2 的%select{结构体|接口|类}1 中'
# 'constexpr bit cast involving type %0 is not yet supported'
H93DC3AD734F6: '涉及类型 %0 的constexpr位转换尚不支持'
# 'constexpr bit_cast involving bit-field is not yet supported'
HCF05A23F6C40: '涉及位域的constexpr bit_cast尚不支持'
# 'constexpr constructor that does not initialize all members is a C++20 extension'
H6D6AAEF0CE01: '未初始化所有成员的constexpr构造函数是C++20的扩展'
# 'constexpr constructor that does not initialize all members is incompatible with C++ standards before C++20'
H6CD8A3688EC0: '未初始化所有成员的constexpr构造函数与C++20之前的版本不兼容'
# 'constexpr evaluation exceeded maximum depth of %0 calls'
H71A1AF77C8D7: 'constexpr求值超过 %0 层的最大深度'
# 'constexpr evaluation hit maximum call limit'
H2D336AD5FC66: 'constexpr求值达到最大调用限制'
# 'constexpr evaluation hit maximum heap allocation limit'
HEA6F0C77C92E: 'constexpr求值达到最大堆分配限制'
# 'constexpr evaluation hit maximum step limit; possible infinite loop?'
H3A9C6A5C602B: 'constexpr求值达到最大步数限制；可能存在无限循环？'
# 'constexpr function %0 without __host__ or __device__ attributes cannot overload __device__ function with the same signature; add a __host__ attribute, or build with -fno-cuda-host-device-constexpr'
HAF2225A9BAA0: '不带__host__或__device__属性的constexpr函数 %0 不能重载具有相同签名的__device__函数；添加__host__属性，或使用-fno-cuda-host-device-constexpr编译'
# 'constexpr function with no return statements is incompatible with C++ standards before C++14'
H60A27D48D081: '没有返回语句的constexpr函数与C++14之前的版本不兼容'
# 'constexpr if condition is not a constant expression'
H9AC357BF4F5E: 'constexpr if的条件不是一个常量表达式'
# 'constexpr if is a C++17 extension'
H8C78EE861C25: 'constexpr if是C++17的扩展'
# 'constexpr if is incompatible with C++ standards before C++17'
H518345725A13: 'constexpr if与C++17之前的版本不兼容'
# 'constexpr initializer evaluates to %0 which is not exactly representable in type %1'
HFD7668DF8CE8: 'constexpr初始化器计算结果为 %0，无法在类型 %1 中精确表示'
# 'constexpr initializer for type %0 is of type %1'
H57EA50C1B712: '类型 %0 的constexpr初始值为类型 %1'
# 'constexpr on lambda expressions is incompatible with C++ standards before C++17'
H2F64715F9E19: '在C++17之前的C++标准中，lambda表达式上的constexpr不兼容'
# 'constexpr pointer initializer is not null'
HA90F435C9DCD: 'constexpr指针初始值不是空值'
# 'constexpr union constructor that does not initialize any member is a C++20 extension'
HDA9656DF3125: '不初始化任何成员的constexpr联合构造函数是C++20扩展'
# 'constexpr union constructor that does not initialize any member is incompatible with C++ standards before C++20'
H42AB5A6736FE: '不初始化任何成员的constexpr联合构造函数与C++20之前的C++标准不兼容'
# 'constexpr variable %0 must be initialized by a constant expression'
H22D6867A6C46: 'constexpr变量 %0 必须由常量表达式初始化'
# 'constexpr variable %0 must have constant destruction'
H0CB1A9F457E9: 'constexpr变量 %0 必须具有常量销毁'
# 'constexpr variable cannot have non-literal type %0'
H8CA68B10BD1E: 'constexpr变量不能具有非字面类型 %0'
# 'constexpr variable cannot have type %0'
H9CBE3FDAF244: 'constexpr变量不能具有类型 %0'
# 'constexpr variable declaration must be a definition'
H28D5C206A058: 'constexpr变量声明必须是一个定义'
# 'constrained by %select{|implicitly }1%select{private|protected}0 inheritance here'
HA215ECA901D4: '受 %select{|隐式 }1%select{private|protected}0 继承的约束'
# "constrained placeholder types other than simple 'auto' on non-type template parameters not supported yet"
HA5CE432D2BF4: "非类型模板参数上的非简单 'auto' 约束占位类型尚未支持"
# "constraint '%0' is already present here"
HDBC0B5C441D3: "约束 '%0' 在此处已存在"
# 'constraint depends on a previously diagnosed expression'
HE3836E579C9B: '约束依赖于之前诊断过的表达式'
# 'constraints not satisfied for %select{class template|function template|variable template|alias template|template template parameter|template}0 %1%2'
H81A668F064ED: '约束条件未满足%select{类模板|函数模板|变量模板|别名模板|模板模板参数|模板}0 %1%2'
# "construct '%0' not allowed in a region associated with a directive with 'order' clause"
HC4C995E5BA30: "在与带有 'order' 子句的指令关联的区域中不允许构造 '%0'"
# 'construction of individual component of complex number is not yet supported in constant expressions'
H0E4CD910394F: '复数的各个分量的构造在常量表达式中尚未支持'
# 'constructor call from initializer list is incompatible with C++98'
HB192963D1DEE: '来自初始化列表的构造函数调用与C++98不兼容'
# "constructor cannot be declared '%0'"
HC6A3768462FF: "构造函数不能声明为 '%0'"
# 'constructor cannot be redeclared'
H55F24B0BC81F: '构造函数不能被重新声明'
# 'constructor cannot have a return type'
H859AAE558539: '构造函数不能有返回类型'
# 'constructor for %0 creates a delegation cycle'
H475456925F83: '%0 的构造函数创建了委托循环'
# 'constructor from base class %0 inherited here'
H1711561364CF: '从基类 %0 继承的构造函数'
# 'constructor inherited by %0 from base class %1 is implicitly deleted'
H97CFC0CC7D39: '%0 从基类 %1 继承的构造函数被隐式删除'
# 'constructor inherited from base class %0 cannot be used in a constant expression; derived class cannot be implicitly initialized'
HC12464115FAE: '从基类 %0 继承的构造函数不能用于常量表达式；派生类无法隐式初始化'
# 'constructor initializer %0 does not name a class'
HCFC849237163: '构造函数初始化项 %0 未命名一个类'
# 'constructor of %0 inherited from multiple base class subobjects'
HC9F4CC1EE50E: '%0 的构造函数从多个基类子对象继承'
# 'constructor of base class %0 is not called'
H3174F7100ABA: '基类 %0 的构造函数未被调用'
# 'constructor parameter %0 shadows the field %1 of %2'
H11CEF1CBDAF0: '构造函数参数 %0 遮蔽了 %2 的字段 %1'
# "constructs with the same name must have a 'hint' clause with the same value"
H0760234C4455: "具有相同名称的构造必须带有值相同的 'hint' 子句"
# "consumed analysis attribute is attached to member of class %0 which isn't marked as consumable"
H05C072713E0E: 'consumed分析属性附加到未标记为可消耗的类 %0 的成员'
# 'container access result unused - container access should not be used for side effects'
H8AF2586DAD21: '容器访问结果未被使用 - 容器访问不应用于副作用'
# 'context %select{set|selector|property}0 options are: %1'
H10E910F395AC: '上下文%select{设置|选择器|属性}0选项为：%1'
# 'continue even if build-ids in input binary and perf.data mismatch'
HF64C3EBD8AC2: '即使输入二进制文件和perf.data的build-ids不匹配也继续执行'
# 'control flows through the definition of a %select{static|thread_local}0 variable'
HBD024CE03438: '控制流经过一个 %select{static|thread_local}0 变量的定义'
# 'control reached end of constexpr function'
HE6815340E241: '控制到达constexpr函数的末尾'
# 'controlling expression type %0 compatible with %1 generic association types'
HB8A1ADD97071: '控制表达式类型 %0 与 %1 泛型关联类型兼容'
# 'controlling expression type %0 not compatible with any generic association type'
H55E9ACCD45B7: '控制表达式类型 %0 与任何泛型关联类型不兼容'
# "convenience initializer missing a 'self' call to another initializer"
HF14170AD5005: '便利初始化器缺少对另一个初始化器的self调用'
# "convenience initializer should not invoke an initializer on 'super'"
HA39139A75170: "便利初始化器不应在 'super' 上调用另一个初始化器"
# 'conversion %diff{from $ to $|between types}0,1 is ambiguous'
HDD7803D6F7A1: '转换 %diff{从 $ 到 $|在类型之间}0,1 是模棱两可的'
# 'conversion between fixed point and %0 is not yet supported'
HF68AF1DBEB64: '固定点与 %0 之间的转换尚未支持'
# 'conversion between matrix type %0 and incompatible type %1 is not allowed'
H499A22E2DD8F: '禁止将矩阵类型 %0 转换为不兼容类型 %1'
# 'conversion between matrix types%diff{ $ and $|}0,1 of different size is not allowed'
H82DF9F4CF265: '禁止将不同大小的矩阵类型%diff{ $ 和 $|}0,1 之间进行转换'
# 'conversion candidate %0 not viable: constraints not satisfied'
H1A87D3FA633E: '转换候选项 %0 不可行：约束条件不满足'
# 'conversion candidate of type %0'
H1704891C4D79: '类型 %0 的转换候选项'
# 'conversion from %0 to %1 in converted constant expression would bind reference to a temporary'
H22C174FA2D9C: '在转换后的常量表达式中将 %0 转换为 %1 会绑定临时对象到引用'
# 'conversion from %0 to %1 is not allowed in a converted constant expression'
H64DA1E381CAE: '在转换后的常量表达式中将 %0 转换为 %1 不被允许'
# 'conversion from pointer to member of class %0 to pointer to member of class %1 via virtual base %2 is not allowed'
HC6DC2FD11DE6: '通过虚基类 %2 将类 %0 的成员指针转换为类 %1 的成员指针是不被允许的'
# 'conversion from string literal to %0 is deprecated'
H1DEAC81E3C65: '将字符串字面量转换为 %0 是已弃用的'
# 'conversion function %diff{from $ to $|between types}0,1 invokes a deleted function%select{|: %3}2'
H302A0E48B3BA: '转换函数 %diff{从 $ 到 $|在类型之间}0,1 调用了被删除的函数 %select{|: %3}2'
# 'conversion function cannot be redeclared'
HA31D9D61E048: '转换函数不能被重新声明'
# 'conversion function cannot be variadic'
H28A6D9FD4C07: '转换函数不能是可变参数的'
# 'conversion function cannot convert to a function type'
H61F51031942B: '转换函数不能转换为函数类型'
# 'conversion function cannot convert to an array type'
H431E774C8920: '转换函数不能转换为数组类型'
# 'conversion function cannot have a return type'
H846A21D09489: '转换函数不能具有返回类型'
# 'conversion function cannot have any parameters'
H9E24A8535723: '转换函数不能有任何参数'
# 'conversion function converting %0 to %1 will never be used'
H960F42AADA51: '将 %0 转换为 %1 的转换函数将永远不会被使用'
# 'conversion function converting %0 to its base class %1 will never be used'
H1FE504FD028F: '将 %0 转换为其基类 %1 的转换函数将永远不会被使用'
# 'conversion function converting %0 to itself will never be used'
HC22DB2DAD0D5: '将 %0 转换为其自身的转换函数将永远不会被使用'
# 'conversion function must be a non-static member function'
HCACC98687D9A: '转换函数必须是非静态成员函数'
# 'conversion to %select{integral|enumeration}0 type %1'
H52D400CB1F4D: '转换为%select{整型|枚举}0类型 %1'
# 'conversion to %select{integral|enumeration}0 type %1 declared here'
H126F1D6252B2: '转换为%select{整型|枚举}0类型 %1，该类型在这里声明'
# 'conversion to pointer type %0'
H88631D898FE3: '转换为指针类型 %0'
# 'convert moves with rbp stack memory operand (unsafe, must be off for binaries compiled with -fomit-frame-pointer)'
H9F1E879B6ED5: '转换包含rbp栈内存操作数的移动指令（不安全，使用-fomit-frame-pointer编译的二进制文件必须关闭此选项）'
# 'convert moves with stack memory operand (potentially unsafe)'
HC5050FEB738B: '转换包含栈内存操作数的移动指令（可能不安全）'
# 'converting delete expression from type %0 to type %1 invokes an explicit conversion function'
HFA594BB552D0: '将类型 %0 的delete表达式转换为类型 %1 会调用显式转换函数'
# 'converting the enum constant to a boolean'
HC26D67935F61: '将枚举常量转换为布尔值'
# "converting the result of '<<' to a boolean always evaluates to %select{false|true}0"
H66F90B0804A0: "将运算符 '<<' 的结果转换为布尔值始终会计算为 %select{false|true}0"
# "converting the result of '<<' to a boolean; did you mean to compare with '0'?"
H2022F6B0CFBA: "将 '<<' 的结果转换为布尔值；是否应与 '0' 进行比较？"
# "converting the result of '?:' with integer constants to a boolean always evaluates to 'true'"
H0B52D2457927: "将带有整型常量的运算符 '?:' 的结果转换为布尔值始终会计算为 'true'"
# 'converting to boxing syntax requires casting %0 to %1'
HDE90319BAAF3: '转换为装箱语法需要将 %0 转换为 %1'
# 'coprocessor %0 must be configured as %select{GCP|CDE}1'
H4C456D50EC55: '协处理器 %0 必须配置为 %select{GCP|CDE}1'
# 'copy %select{constructor|assignment operator}0 is implicitly deleted because %1 has a user-declared move %select{constructor|assignment operator}2'
HBE99D1D6F119: '复制%select{构造函数|赋值运算符}0被隐式删除，因为 %1 声明了用户自定义的移动%select{构造函数|赋值运算符}2'
# 'copy constructor must pass its first argument by reference'
H3ABFF716FBF3: '复制构造函数必须通过引用传递其第一个参数'
# 'copy constructor of %0 is implicitly deleted because field %1 is of rvalue reference type %2'
H5B9C818EF5D6: '%0 的复制构造函数被隐式删除，因为字段 %1 是右值引用类型 %2'
# 'copying a temporary object of incomplete type %0'
H4C050E15C304: '复制不完整类型 %0 的临时对象'
# "coroutine %0 cannot be declared 'noreturn' as it always returns a coroutine handle"
H7F1772343EA2: '协程 %0 不能声明为noreturn，因为它始终返回协程句柄'
# "could not acquire lock file for module '%0': %1"
H0C3259D0CAD4: "无法为模块 '%0' 获取锁文件：%1"
# "could not build module '%0'"
H0F4C1C79774B: "无法构建模块 '%0'"
# "could not calculate number of iterations calling 'operator-' with upper and lower loop bounds"
H55F92FED58CA: '无法通过调用带有循环上下限的operator-计算迭代次数'
# 'could not determine the original source location for %0:%1:%2'
H596D1B547578: '无法确定 %0:%1:%2 的原始源代码位置'
# "could not find ';' after @import"
H808D2C4625A0: "在@import后找不到 ';'"
# 'could not find Objective-C class %0 to convert %1 to %2'
H8A434A2F54F7: '找不到Objective-C类 %0 来将 %1 转换为 %2'
# 'could not match %diff{$ against $|types}0,1'
HB17669DA1C41: '无法匹配 %diff{$ against $|types}0,1'
# "could not open '%0' for embedding"
HF452E067B4E2: "无法打开 '%0' 用于嵌入"
# "could not read %0 input list '%1': %2"
H67879BBD7E88: "无法读取 %0 输入列表 '%1'：%2"
# "could not read directory '%0': %1"
HBA8BA2C7E279: "无法读取目录 '%0'：%1"
# "could not remap file '%0' to the contents of file '%1'"
H154079BD4163: "无法将文件 '%0' 重映射为文件 '%1' 的内容"
# 'covariant thunk required by %0'
H96E8ACBA5464: '%0 需要协变thunk'
# "cpu '%0' does not support rv%select{32|64}1"
HB22CC79010F2: "CPU '%0' 不支持rv%select{32|64}1"
# 'create a static PC table'
HA9821FD0C9F2: '创建静态PC表'
# "current API version is '%0', but plugin was compiled with version '%1'"
H399ED19E4A74: "当前API版本是 '%0'，但插件是使用版本 '%1' 编译的"
# 'current file is older than dependency %0'
HCE89B30434E7: '当前文件比依赖项 %0 更旧'
# "current handling of vector bool and vector pixel types in this context are deprecated; the default behaviour will soon change to that implied by the '-altivec-compat=xl' option"
H2144886C992F: "在此上下文中处理向量布尔类型和向量像素类型的方式已弃用；默认行为将很快更改为由 '-altivec-compat=xl' 选项暗示的行为"
# "current_version does not match: '%0' (provided) vs '%1' (found)"
H84F45A8B13FB: "current_version不匹配：提供的 '%0' 与找到的 '%1'"
# "cycle in acquired_before/after dependencies, starting with '%0'"
HCB49175AA5FC: "在acquired_before/after依赖项中存在循环，起始于 '%0'"
# "cyclic dependency in module '%0': %1"
H2C783846485B: "模块 '%0' 中存在循环依赖：%1"
# 'd'
H3C363836CF4E: 'd'
# 'data argument not used by format string'
HB79E446EA7A1: '数据参数未被格式字符串使用'
# "data argument position '%0' exceeds the number of data arguments (%1)"
H3A25FAA1F4B4: "数据参数位置 '%0' 超过了数据参数的数量(%1)"
# 'data layout string to use'
HBFBB6DFFCFDF: '要使用的数据布局字符串'
# 'data member instantiated with function type %0'
HE2AF1A6B9D7C: '用函数类型 %0 实例化的数据成员'
# "data-sharing attribute '%0' in '%1' clause requires OpenMP version %2 or above"
H12FB4E840EF7: "'%1' 子句中的数据共享属性 '%0' 需要OpenMP版本 %2 或更高"
# 'dbx'
H362301DA6431: 'dbx'
# "dealloc return type must be correctly specified as 'void' under ARC, instead of %0"
HF5C8E84C253E: "在ARC下，dealloc的返回类型必须正确指定为 'void'，而不是 %0"
# 'debug'
H32FAAECAC742: '调试'
# "debug information option '%0' is not supported for target '%1'"
H53B68E933A49: '调试信息选项‘%0’不支持目标‘%1’'
# "debug information option '%0' is not supported; requires DWARF-%2 but target '%1' only provides DWARF-%3"
HBD9D2872B134: '调试信息选项‘%0’不支持；需要DWARF-%2，但目标‘%1’仅提供DWARF-%3'
# 'debug print callable symbols defined by materialization units'
H976885EE0BAB: '调试打印由实例化单元定义的可调用符号'
# 'debug print data symbols defined by materialization units'
H68EF51B0D840: '调试打印由实例化单元定义的数据符号'
# 'debug print hidden symbols defined by materialization units'
H29FF2691850E: '调试打印由实例化单元定义的隐藏符号'
# 'debug stack'
HF8D202225993: '调试堆栈'
# "declaration %0 attached to named module '%1' cannot be attached to other modules"
H238E4BEFC413: '已附加到命名模块‘%1’的声明 %0 无法附加到其他模块'
# "declaration %0 is detected to be defined in multiple module units, first is from '%1' and second is from '%2'; the compiler may not be good at merging the definitions. "
H96F07A99E632: '检测到声明 %0 在多个模块单元中定义，第一个来自‘%1’，第二个来自‘%2’；编译器可能无法有效合并这些定义。'
# "declaration '%0' is %select{weak defined|thread local}1, but symbol is not in dynamic library"
HFB32CBE0F1C5: '声明‘%0’是%select{弱定义|线程局部}1，但符号不在动态库中'
# "declaration '%0' is marked %select{available|unavailable}1, but symbol is %select{not |}2exported in dynamic library"
H01B92D3A7F34: '声明‘%0’被标记为%select{可用|不可用}1，但符号在动态库中%select{未|}2 导出'
# "declaration cannot be inferred '%0' because it has no definition in this translation unit"
HFACBBC5D211B: '无法推断声明‘%0’，因为它在此翻译单元中没有定义'
# 'declaration conflicts with target of using declaration already in scope'
HF0A04A0DD736: '声明未声明任何参数'
# 'declaration does not declare a parameter'
HAB6C8E5E5B42: '该声明未声明任何内容'
# 'declaration does not declare anything'
HCF31319302C2: '声明未声明任何内容'
# "declaration has external linkage, but dynamic library doesn't have symbol '%0'"
H867521795963: '该声明具有外部链接，但在动态库‘%0’中符号具有内部链接'
# "declaration has external linkage, but symbol has internal linkage in dynamic library '%0'"
H51741F52DD27: "声明具有外部链接，但在动态库 '%0' 中符号具有内部链接"
# 'declaration hides type'
HBEC56FF31D60: '接口中的声明'
# 'declaration in interface'
HA49C5D70160C: '接口中的声明'
# "declaration in interface is not in the '%select{alloc|copy|init|new}0' family because %select{its result type is not an object pointer|its result type is unrelated to its receiver type}1"
H135EF0608D60: "接口中的声明不属于 '%select{alloc|copy|init|new}0' 家族，因为 %select{其结果类型不是对象指针|其结果类型与接收类型无关}1"
# "declaration is marked with '%select{\\|@}0deprecated' command but does not have a deprecation attribute"
H7C7F3BB153A5: "带有 '%select{\\|@}0deprecated' 命令的声明缺少废弃属性"
# 'declaration is not declared in any declare target region'
H519107FB97C7: '声明在首次使用后被标记为声明目标，可能导致结果不正确'
# 'declaration marked as declare target after first use, it may lead to incorrect results'
HB5487BD38E68: '缺少‘[[carries_dependency]]’属性的声明在此处'
# "declaration missing '[[carries_dependency]]' attribute is here"
H0D046CE0EB0D: "未标记 '[[carries_dependency]]' 属性的声明在此处"
# 'declaration of %0 does not match'
H12CB12FACAA5: '%0 的声明不匹配'
# 'declaration of %0 has a different language linkage'
HB8AA7E6F59F0: '%0 的声明具有不同的语言链接性'
# 'declaration of %0 in %select{the global module|module %2}1 follows declaration in %select{the global module|module %4}3'
HCB7EF6CCFFAA: '%0 在 %select{全局模块|模块 %2}1 的声明跟随了 %select{全局模块|模块 %4}3 的声明'
# 'declaration of %0 is missing in %1 class'
HCE379B9B6B0B: '%1 类中缺少 %0 的声明'
# "declaration of %0 overrides a '%select{final|sealed}1' function"
H49FDD9D92060: "%0 的声明覆盖了一个 '%select{final|sealed}1' 函数"
# 'declaration of %0 shadows template parameter'
HB1AA8E00948E: '%0 的声明遮蔽了模板参数'
# 'declaration of %0 will not be visible outside of this function'
H1E299D7E36E1: '%0 的声明在函数外部不可见'
# 'declaration of %0 with internal linkage cannot be exported'
HB1BC44F22B13: '具有内部链接性的 %0 的声明无法导出'
# 'declaration of %1 %select{with C language linkage|in global scope}0 conflicts with declaration %select{in global scope|with C language linkage}0'
HADF36ADC7505: '%1 %select{具有C语言链接性|在全局作用域中}0 的声明与 %select{全局作用域中的|具有C语言链接性}0 的声明冲突'
# "declaration of a variadic function without a comma before '...' is deprecated"
HF12988516A95: "在 '...' 前缺少逗号的可变参数函数声明已弃用"
# 'declaration of anonymous %0 must be a definition'
H1EBFCC5461F9: '匿名 %0 的声明必须是一个定义'
# 'declaration of block scope identifier with linkage cannot have an initializer'
HDD3AC9280BE3: '具有链接性的块作用域标识符的声明不能具有初始化器'
# "declaration of built-in function '%0' requires the declaration of the 'jmp_buf' type, commonly provided in the header <setjmp.h>"
H8F1CDE7D22C0: "内建函数 '%0' 的声明需要声明 'jmp_buf' 类型，该类型通常在头文件 <setjmp.h> 中提供"
# "declaration of built-in function '%1' requires inclusion of the header <%0>"
H059DBCAF4C02: "内建函数 '%1' 的声明需要包含头文件 <%0>"
# 'declaration of constexpr static data member %0 requires an initializer'
HCFAE74ED9FCD: 'constexpr 静态数据成员 %0 的声明需要初始值设定项'
# 'declaration of instance variables in the interface is deprecated'
HF2C25CBD493E: "在 'for' 循环中声明了非局部变量"
# "declaration of non-local variable in 'for' loop"
HBFAC0B86B48E: "在 'for' 循环中声明非局部变量是C23扩展"
# "declaration of non-local variable in 'for' loop is a C23 extension"
H82E18D14C9A2: "在 'for' 循环中声明非局部变量与C23之前的标准不兼容"
# "declaration of non-local variable in 'for' loop is incompatible with C standards before C23"
H1C8715C3541C: "'for' 循环中的非局部变量声明与 C23 之前的 C 标准不兼容"
# 'declaration of reference variable %0 requires an initializer'
H8635EDA9A8C6: '引用变量 %0 的声明需要初始化器'
# 'declaration of type aware %0 in %1 must have matching type aware %2'
HC35A59FCABD4: '在 %1 中的类型感知 %0 声明必须具有匹配的类型感知 %2'
# 'declaration of variable %0 with deduced type %1 requires an initializer'
H737154EADE2A: '类型推导为 %1 的变量 %0 的声明需要初始化器'
# 'declaration requires a global constructor'
H55DC760EFFEA: '该声明需要全局构造函数'
# 'declaration requires a global destructor'
H7852FAA15ED5: '该声明需要全局析构函数'
# 'declaration requires an exit-time destructor'
H86CA276EEC00: '该声明需要退出时析构函数'
# 'declaration shadows a %select{local variable|variable in %2|static data member of %2|field of %2|typedef in %2|type alias in %2|structured binding}1'
H68CDFAD663DD: '该声明遮蔽了 %select{局部变量|%2 中的变量|%2 的静态数据成员|%2 的字段|%2 中的 typedef|%2 中的类型别名|结构化绑定}1'
# 'declaration uses __weak, but ARC is disabled'
H1C8188316ADE: '该声明使用了 __weak，但 ARC 已禁用'
# 'declaration uses __weak, which the current deployment target does not support'
HEB22F5D20508: '该声明使用了 __weak，而当前部署目标不支持'
# "declaration uses identifier '%0', which is %select{a reserved identifier|not a reserved identifier|reserved in the global namespace}1"
HCBB59D1E323D: "该声明使用标识符 '%0'，该标识符%select{是保留标识符|不是保留标识符|在全局命名空间中保留}1"
# 'declaration uses type that is ill-formed in ARC'
H522AD27CDFBF: '该声明使用了在 ARC 中格式错误的类型'
# 'declarator requires an identifier'
HB85D316E7D82: '声明符需要标识符'
# "declare 'static' if the %select{variable|function}0 is not intended to be used outside of this translation unit"
H5D50A42530DC: "如果 %select{变量|函数}0 不打算在本翻译单元外使用，请声明为 'static'"
# 'declare the parameter __strong or capture a __block __strong variable to keep values alive across autorelease pools'
H9B7134A463BB: '声明参数为 __strong 或捕获一个 __block __strong 变量，以在自动释放池间保持值的有效性'
# "declared %select{'returns_nonnull'|'nonnull'}0 here"
H9D136543BAF2: "此处声明 %select{'returns_nonnull'|'nonnull'}0"
# 'declared %select{in global scope|with C language linkage}0 here'
H3DB72872F2B8: '此处声明 %select{在全局作用域|具有 C 语言链接性}0'
# 'declared as a non-template here'
H65BA70C7322E: '此处声明为非模板'
# 'declared here'
HA1E35E29C81D: '此处声明'
# 'declared here with type %0'
H880F1F3D3828: '此处声明类型为 %0'
# "declared here%select{ in module '%1'|}0"
HD4C36AE9FEF2: "此处声明%select{ 在模块 '%1'|}0"
# 'declared with %0 attribute here'
H98D954FCA941: '此处用 %0 属性声明'
# "declared with class '%0' here"
HA2F652501D84: "此处用类 '%0' 声明"
# 'declared with index %0 here'
H29E8DAE209C5: '此处用索引 %0 声明'
# 'declaring function parameter of type %0 is not allowed%select{; did you forget * ?|}1'
H45BA30613376: '不允许声明类型为 %0 的函数参数 %select{; 是否忘记添加*？|}1'
# 'declaring function return value of type %0 is not allowed %select{; did you forget * ?|}1'
HC0F56D942DA5: '不允许声明类型为 %0 的函数返回值 %select{; 是否忘记添加*？|}1'
# "declaring overloaded %0 as 'static' is a C++23 extension"
H3416DF62F662: "将重载的 %0 声明为 'static' 是C++23扩展"
# "declaring overloaded %0 as 'static' is incompatible with C++ standards before C++23"
HE846DD4F137C: "将重载的 %0 声明为 'static' 与C++23之前的标准不兼容"
# 'declaring variable of type %0 is not allowed'
HCC1ADB51903E: '不允许声明类型为 %0 的变量'
# 'decode probes section from binary'
H61AE631A7106: '从二进制文件解码探针节'
# 'decomposition declaration %0 requires an initializer'
H745CF12AB2DC: '分解声明 %0 需要初始值设定项'
# 'decomposition declaration cannot be a template'
H12444CAF9EB2: '分解声明不能是模板'
# "decomposition declaration cannot be declared %plural{1:'%1'|:with '%1' specifiers}0"
HEDAF4E9407D4: "分解声明不能被声明 %plural{1:'%1'|:具有 '%1' 说明符}0"
# "decomposition declaration cannot be declared with constrained 'auto'"
H33CAEB57113F: "分解声明不能被声明为具有约束条件的 'auto'"
# 'decomposition declaration cannot be declared with parentheses'
H02314396E4F0: '分解声明不能用括号声明'
# "decomposition declaration cannot be declared with type %0; declared type must be 'auto' or reference to 'auto'"
H3DD0947995B7: "分解声明声明的类型 %0 无效；声明类型必须为 'auto' 或 'auto' 的引用"
# "decomposition declaration declared %plural{1:'%1'|:with '%1' specifiers}0 is a C++20 extension"
HED6397EE7170: "分解声明被声明 %plural{1:'%1'|:具有 '%1' 说明符}0是C++20扩展"
# "decomposition declaration declared %plural{1:'%1'|:with '%1' specifiers}0 is incompatible with C++ standards before C++20"
H3B1B7DD7D4A6: "分解声明被声明 %plural{1:'%1'|:具有 '%1' 说明符}0与C++20之前的标准不兼容"
# 'decomposition declaration must be the only declaration in its group'
H36F7861E46A5: '分解声明必须是其组中的唯一声明'
# 'decomposition declaration not permitted in this context'
HE332CBDAE8B6: '当前上下文中不允许分解声明'
# 'decomposition declarations are a C++17 extension'
H41B58BACEDBD: '分解声明是C++17扩展'
# 'decomposition declarations are incompatible with C++ standards before C++17'
H6F6939D7899C: '分解声明与C++17之前的标准不兼容'
# 'deduced conflicting types %diff{($ vs $) |}0,1for initializer list element type'
H41EB8FB5647B: '推导出冲突的类型 %diff{($ vs $)|}0,1 作为初始列表元素类型'
# 'deduced incomplete pack %0 for template parameter %1'
H03080CBC4C1A: '推导出模板参数 %1 的不完整包 %0'
# 'deduced non-type template argument does not have the same type as the corresponding template parameter%diff{ ($ vs $)|}0,1'
H6489085BE16C: '推导出的非类型模板实参与对应的模板参数类型不一致%diff{ ($ vs $)|}0,1'
# "deduced return type for defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator must be 'auto', not %1"
H209B0E7EFC40: "默认实现的 %select{<ERROR>|equality|three-way|equality|relational}0 比较运算符的推导返回类型必须为 'auto'，而非 %1"
# 'deduced return types are a C++14 extension'
HB07F9BCAC63A: '推导返回类型是C++14扩展'
# 'deduced type %0 does not satisfy %1'
H9431BF910A33: '推导出的类型 %0 不满足 %1'
# 'deduced type %1 of deduction guide is not %select{|written as }2a specialization of template %0'
H902D2FE80122: '推导指引的推导类型 %1 不是 %select{|以}2模板 %0 的特化形式'
# 'deduction guide cannot be %select{explicitly instantiated|explicitly specialized}0'
HA3A632F69A86: '推导指引不能%select{显式实例化|显式特化}0'
# "deduction guide cannot be declared '%0'"
HF6365CFA8B89: "推导指引不能被声明为 '%0'"
# 'deduction guide cannot have a function definition'
H7D3F7544A5EA: '推导指引不能有函数定义'
# 'deduction guide declaration without trailing return type'
H4EE056EE4349: '推导指引声明缺少尾随返回类型'
# 'deduction guide declared %0 by intervening access specifier'
HBCF8F59E9812: '推导指引被 %0 的访问说明符声明'
# 'deduction guide has different access from the corresponding member template'
H1030B70A50CA: '推导指引与对应的成员模板的访问权限不同'
# 'deduction guide must be declared in the same scope as template %q0'
H1F6362B2A695: '推导指引必须在与模板%q0相同的范围内声明'
# 'deduction guide template contains %select{a template parameter|template parameters}0 that cannot be deduced'
H9078590D8224: '推导指引模板包含%select{一个无法推导的模板参数|无法推导的模板参数}0'
# 'default %select{argument|non-type template argument}0 may not use a GNU statement expression'
HB2A0E2C3CEAE: '默认%select{参数|非类型模板参数}0不能使用GNU语句表达式'
# 'default alignment for functions'
HDB8C50704025: '函数的默认对齐方式'
# 'default argument declared here'
HDD61CA193DBE: '默认参数在这里声明'
# 'default argument not permitted on an explicit %select{instantiation|specialization}0 of function %1'
HA5116018194A: '显式%select{实例化|特化}0的函数 %1 不允许有默认参数'
# "default argument references 'this'"
H743C3B172B68: "默认参数引用了 'this'"
# 'default argument references local variable %0 of enclosing function'
HAA8CD5949FC3: '默认参数引用了外部函数的局部变量 %0'
# 'default argument references parameter %0'
H573EB7C93602: '默认参数引用了参数 %0'
# 'default argument used here'
H2C2A14271D90: '默认参数在此处使用'
# 'default arguments can only be specified for parameters in a function declaration'
H910FAD8C4EA4: '默认参数只能为函数声明中的参数指定'
# 'default arguments cannot be added to a function template that has already been declared'
H2AD8ADEE046B: '不能为已声明的函数模板添加默认参数'
# 'default arguments cannot be added to an out-of-line definition of a member of a %select{class template|class template partial specialization|nested class in a template}0'
H2A1897D12086: '不能为%select{类模板|类模板的部分特化|模板中的嵌套类}0的成员的外部定义添加默认参数'
# 'default arguments not allowed for parameters of a requires expression'
H8AAADF6A99AF: '不允许为requires表达式参数的默认参数'
# 'default assign attribute on property %0 which implements NSCopying protocol is not appropriate with -fobjc-gc[-only]'
H8248EDB07821: '实现了NSCopying协议的属性 %0 的默认assign属性与-fobjc-gc[-only]不兼容'
# 'default capture by %select{value|reference}0'
H472BB89BA278: '默认按%select{值|引用}0捕获'
# 'default constructed field %0 declared here'
H948E9DA6EBAF: '默认构造的字段 %0 在此处声明'
# 'default exception handling model'
H9659057B9931: '默认异常处理模型'
# 'default initialization of an object of const type %0%select{| without a user-provided default constructor}1'
H303212CBDF84: 'const类型 %0%select{|没有用户提供的默认构造函数}1的默认初始化'
# 'default initialization of an object of const type %0%select{| without a user-provided default constructor}1 is a Microsoft extension'
H48E5A1B64C89: 'const类型 %0%select{|没有用户提供的默认构造函数}1的默认初始化是Microsoft扩展'
# 'default initialization of an object of type %0 is incompatible with C++'
H6366610D5A2C: '类型 %0 对象的默认初始化与C++不兼容'
# 'default initialization of an object of type %0 leaves the object uninitialized%select{| and is incompatible with C++}1'
H925C796D0E64: '类型 %0 对象的默认初始化会留空未初始化的对象 %select{|且与C++不兼容}1'
# 'default initialization of an object of type %0 with const member is incompatible with C++'
H4DB5E81E949B: '包含const成员的类型 %0 对象的默认初始化与C++不兼容'
# 'default initialization of an object of type %0 with const member leaves the object uninitialized%select{| and is incompatible with C++}1'
H08A6BE1665E0: '包含const成员的类型 %0 对象的默认初始化会留空未初始化的对象 %select{|且与C++不兼容}1'
# 'default label in switch which covers all enumeration values'
HF1A67825B6F5: 'switch中的默认标签覆盖所有枚举值'
# 'default member initializer declared here'
H09B30FC3540B: '默认成员初始值设定项在此处声明'
# 'default member initializer for %0 uses itself'
H62A9561A4498: '成员 %0 的默认初始值设定项使用了自身'
# 'default member initializer for %1 needed within definition of enclosing class %0 outside of member functions'
HB4FBDC93A96D: '在外部类 %0 的成员函数外部定义时，需要为 %1 的默认成员初始值设定项'
# 'default member initializer for bit-field is a C++20 extension'
H960B2B591D79: '位字段的默认成员初始值设定项是C++20扩展'
# 'default member initializer for bit-field is incompatible with C++ standards before C++20'
H85717DD87366: '位字段的默认成员初始值设定项与C++20之前的C++标准不兼容'
# 'default member initializer for non-static data member is a C++11 extension'
HB1974A6508C8: '非静态数据成员的默认成员初始值设定项是C++11扩展'
# 'default member initializer for non-static data members is incompatible with C++98'
H75DECF5B5D30: '非静态数据成员的默认成员初始值设定项与C++98标准不兼容'
# "default property attribute 'assign' not appropriate for object"
HBAC11B3F8368: "对象的默认属性 'assign' 不适用"
# 'default scope specifier for attributes is a C++17 extension'
H9959B28B39FE: '属性的默认作用域限定符是C++17扩展'
# 'default scope specifier for attributes is incompatible with C++ standards before C++17'
HCB10ABA8102F: '属性的默认作用域限定符与C++17之前的C++标准不兼容'
# 'default template argument for a template template parameter must be a class template'
H3FA43EDB90ED: '模板模板参数的默认模板实参必须是一个类模板'
# 'default template argument in a class template partial specialization'
H57E58A1F67E6: '类模板的部分特化中不允许有默认模板实参'
# 'default template argument not permitted on a friend template'
H1B3D975772BB: '不允许在友元模板上使用默认模板实参'
# 'default template arguments for a function template are a C++11 extension'
H94B1EDF48980: '函数模板的默认模板实参是C++11扩展'
# 'default template arguments for a function template are incompatible with C++98'
H688888558286: '函数模板的默认模板实参与C++98不兼容'
# 'defaulted %0 is implicitly deleted because %2 is a %select{union-like class|union}1 with variant members'
HAADBD633A7F2: '默认的 %0 因隐式删除，因为 %2 是具有变体成员的%select{类似联合的类|联合}1'
# 'defaulted %0 is implicitly deleted because a builtin comparison function using this conversion would be the best match for the comparison'
H6F959181B71C: '默认的 %0 因隐式删除，因为使用该转换的内建比较函数会成为比较的最佳匹配'
# 'defaulted %0 is implicitly deleted because class %1 has a reference member'
HDDAEEF62F6DD: '默认的 %0 因隐式删除，因为类 %1 有引用成员'
# 'defaulted %0 is implicitly deleted because defaulted comparison of vector types is not supported'
H62937001BFCD: '默认生成的 %0 被隐式删除，因为不支持向量类型的默认比较'
# "defaulted %0 is implicitly deleted because implied %select{|'==' |'<' }1comparison %select{|for member %3 |for base class %3 }2is ambiguous"
H8204A4BEFE67: "默认的 %0 因隐式删除，因为隐含的 %select{|'==' |'<' }1比较 %select{|对于成员 %3 |对于基类 %3 }2是模棱两可的"
# 'defaulted %0 is implicitly deleted because it would invoke a %select{private|protected}3 %4%select{ member of %6| member of %6 to compare member %2| to compare base class %2}1'
HA2763C071EBA: '默认的 %0 因隐式删除，因为它会调用 %select{private|protected}3 %4%select{ 的 %6 成员|的 %6 成员来比较成员 %2|来比较基类 %2}1'
# 'defaulted %0 is implicitly deleted because it would invoke a deleted comparison function%select{| for member %2| for base class %2}1'
H73AE2279ECF2: '默认的 %0 被隐式删除，因为它会调用已删除的比较函数 %select{|的成员 %2|的基类 %2}1'
# "defaulted %0 is implicitly deleted because there is no viable %select{three-way comparison function|'operator=='}1 for %select{|member |base class }2%3"
HC9957DD8DD53: "默认的 %0 因隐式删除，因为 %select{|成员 |基类 }2%3 没有可用的%select{三向比较函数|'operator=='}1"
# 'defaulted %0 is implicitly deleted because this non-rewritten comparison function would be the best match for the comparison'
H5A66B2776E93: '默认的 %0 因隐式删除，因为此未重写的比较函数会成为比较的最佳匹配'
# 'defaulted comparison function must not be volatile'
H50500CCE550F: '默认的比较函数不能声明为volatile'
# 'defaulted comparison operators are a C++20 extension'
H17EA10D2ACC2: '默认比较运算符是C++20扩展'
# 'defaulted comparison operators are incompatible with C++ standards before C++20'
H38C2AF56B86F: '默认比较运算符与C++20之前的C++标准不兼容'
# "defaulted definition of %select{%select{<ERROR>|equality|three-way|equality|relational}1 comparison operator|three-way comparison operator}0 cannot be declared %select{constexpr|consteval}2 because %select{it|for which the corresponding implicit 'operator==' }0 invokes a non-constexpr comparison function"
HDA596C603C53: '默认的 %select{%select{<ERROR>|相等性|三向|相等性|关系性}1比较运算符|三向比较运算符}0不能声明为 %select{constexpr|consteval}2，因为%select{它|对应隐式operator==的}0调用了非constexpr比较函数'
# 'defaulted definition of %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot be marked %select{constexpr|consteval}1 before C++23'
H5C1B0C179374: '默认的%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}0在C++23之前不能标记为 %select{constexpr|consteval}1'
# 'defaulted member %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator must be const-qualified'
H8A22F945F946: '默认的 %select{<ERROR>|相等性|三向|相等性|关系性}0比较运算符必须有const限定符'
# 'defaulted move assignment operator of %0 will move assign virtual base class %1 multiple times'
HC302B71D801C: '类型 %0 的默认移动赋值运算符将多次移动赋值虚基类 %1'
# "defaulting %select{this %select{<ERROR>|equality|three-way|equality|relational}1 comparison operator|the corresponding implicit 'operator==' for this defaulted 'operator<=>'}0 would delete it after its first declaration"
HCBD1D13B7A08: "默认实现%select{这个 %select{<ERROR>|相等性|三向|相等性|关系}1 比较运算符|对应隐式 'operator==' 的这个默认 'operator<=>' }0 会删除其首次声明后的实现"
# 'defaulting this %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator is not allowed because it was already declared outside the class'
H21E3B4CFF46D: '默认实现这个 %select{<ERROR>|相等性|三向|相等性|关系}0 比较运算符是不允许的，因为它已在类外声明过'
# 'defaulting this %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 would delete it after its first declaration'
H7E7544692CE2: '默认实现这个 %select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}0 会删除其首次声明后的实现'
# 'defined as %0'
H95D82B9347CA: '定义为 %0'
# "defining a type within '%select{__builtin_offsetof|offsetof}0' is a C23 extension"
HB6CCA72E4AE1: "在 '%select{__builtin_offsetof|offsetof}0' 内定义类型是 C23 扩展"
# 'definition %0 cannot also be an %select{alias|ifunc}1'
HEAC49AC815B1: '%select{别名|ifunc}1 不能同时是 %0 的定义'
# 'definition has no member %0'
HF2870D3EBBD2: '定义中没有成员 %0'
# "definition in module '%0' is here"
HD03996A6AE5C: "模块 '%0' 中的定义在此处"
# "definition of %0 is not complete until the closing '}'"
H6A431AA48FA1: "%0 的定义在闭合的 '}' 之前未完成"
# 'definition of a %select{static|thread_local}1 variable in a constexpr %select{function|constructor}0 is a C++23 extension'
H398F375C6A6A: '在constexpr %select{函数|构造函数}0中定义一个%select{静态|thread_local}1 变量是C++23扩展'
# 'definition of a %select{static|thread_local}1 variable in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++23'
HE9C5585842AA: '在constexpr %select{function|constructor}0 中定义一个 %select{static|thread_local}1 变量与C++23之前的C++标准不兼容'
# 'definition of a variable of non-literal type in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++23'
H53017D331C6A: '在constexpr %select{函数|构造函数}0 中定义非字面量类型的变量与C++23之前的版本不兼容'
# 'definition of builtin function %0'
HC9CC697C220C: '内建函数 %0 的定义'
# 'definition of class %0 must be available to use Objective-C %select{array literals|dictionary literals|numeric literals|boxed expressions|string literals}1'
H852A8FF09E04: '为使用 Objective-C %select{数组字面量|字典字面量|数值字面量|装箱表达式|字符串字面量}1，类 %0 必须提供完整定义'
# 'definition of dllimport data'
HBDC4BCE4EB33: 'dllimport 数据的定义'
# 'definition of dllimport static field'
H64DF6CE31868: 'dllimport 静态字段的定义'
# 'definition of dllimport static field not allowed'
H8C1897964645: '不允许定义 dllimport 静态字段'
# 'definition of explicitly defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|function}0'
H1522F98BEB4D: '显式默认实现的 %select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数|函数}0'
# 'definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-declared copy %select{assignment operator|constructor}1'
H069CBC304A15: '%0 的隐式拷贝 %select{构造函数|赋值运算符}1 已弃用，因为其包含用户声明的拷贝 %select{赋值运算符|构造函数}1'
# 'definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-declared destructor'
H423281D39FA7: '%0 的隐式拷贝 %select{构造函数|赋值运算符}1 已弃用，因为其包含用户声明的析构函数'
# 'definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-provided copy %select{assignment operator|constructor}1'
H3C23BCA5B3D2: '%0 的隐式拷贝 %select{构造函数|赋值运算符}1 已弃用，因为其包含用户提供的拷贝 %select{赋值运算符|构造函数}1'
# 'definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-provided destructor'
H396EB4CE9202: '隐式拷贝的%select{构造函数|赋值运算符}1的定义对 %0 已被弃用，因为其提供了用户定义的析构函数'
# 'definition of implicitly declared %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|function}1'
H86596A04E020: '隐式声明的%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数|函数}1的定义'
# 'definition of macro %0 does not match definition in precompiled header'
H79B9B4BA8FFF: '宏 %0 的定义与预编译头中的定义不匹配'
# "definition of macro '%0' differs between the precompiled file '%3' ('%1') and the command line ('%2')"
HF4FF588C4EAE: "宏 '%0' 的定义在预编译文件 '%3'('%1')和命令行('%2')中存在差异"
# "definition of module '%0' is not available; use -fmodule-file= to specify path to precompiled module interface"
H1ED33479DE5D: "模块 '%0' 的定义不可用；请使用-fmodule-file=指定预编译模块接口的路径"
# 'definition of type %0 conflicts with %select{typedef|type alias}1 of the same name'
H5C3C4CCA94AB: '类型 %0 的定义与同名的 %select{typedef|类型别名}1冲突'
# 'definition of variable with array type needs an explicit size or an initializer'
H79E09A4784DB: '具有数组类型的变量定义需要显式指定大小或初始化器'
# 'definition or redeclaration of %0 cannot name the global scope'
H3AC58FC9EA5A: '%0 的定义或重新声明不允许出现在全局作用域'
# 'definition or redeclaration of %0 not allowed inside a block'
HD4328CF55600: '%0 的定义或重新声明不允许出现在块内部'
# 'definition or redeclaration of %0 not allowed inside a function'
H26DE3CAC54F0: '%0 的定义或重新声明不允许出现在函数内部'
# "definition with same mangled name '%0' as another definition"
H9CD626C8B999: "与另一个定义具有相同的装饰名称 '%0'"
# 'defsym must be of the form: sym=value: %0'
H633B95A139C3: 'defsym必须采用形式：sym=value: %0'
# 'delegating constructors are incompatible with C++98'
H57A554A5A2B8: '委派构造函数与C++98不兼容'
# 'delegating constructors are permitted only in C++11'
H859BD39058E0: '仅允许在C++11中使用委派构造函数'
# 'delete of object with dynamic type %1 through pointer to base class type %0 with non-virtual destructor'
H2817C3914B5E: '通过基类类型 %0 的指针删除动态类型为 %1 的对象，而该基类未声明虚析构函数'
# "delete of pointer '%0' that does not point to a heap-allocated object"
H8B4F3ED0F000: "删除指向非堆分配对象的指针 '%0'"
# 'delete of pointer that has already been deleted'
H42BC8DFBCECC: '删除已被释放的指针'
# "delete of pointer%select{ to subobject|}1 '%0' %select{|that does not point to complete object}1"
H4DFF941C0746: '删除%select{子对象|}1 的指针 %select{|不指向完整对象}1的指针 %0'
# 'deleted definition must be first declaration'
H0F602982588E: '被删除的定义必须是首次声明'
# 'deleted function %0 cannot override a non-deleted function'
H3FCDC44C217B: '被删除的函数 %0 不能覆盖非删除函数'
# 'deleting incomplete class type %0; no conversions to pointer type'
H9074591E0AF3: '删除不完整类类型 %0；无法转换为指针类型'
# 'deleting pointer to incomplete type %0 is incompatible with C++2c and may cause undefined behavior'
H0FC4BDC8CA1F: '删除指向不完整类型 %0 的指针与C++2c不兼容，可能导致未定义行为'
# 'delimited escape sequence cannot be empty'
H5E38AA141B13: '界定转义序列不能为空'
# 'delimited escape sequences are incompatible with C standards before C2y'
H21BCF42E1D91: '界定转义序列与C2y之前的C标准不兼容'
# 'delinearize'
HB90F234569ED: '去线性化'
# 'demangle symbols (default)'
H49846FF32EAF: '解码符号（默认）'
# 'denormals are flushed to positive zero'
H38FDA7EF72DB: '将亚正规数冲洗为正零'
# 'denormals have unknown treatment'
HBDD387FC03A4: '非正规数的处理方式未知'
# 'dense YAML representation'
HA97D8413D319: '密集的YAML表示形式'
# "depend modifier cannot be used with 'sink' or 'source' depend type"
H92A125FCC1F2: "depend修饰符不能与 'sink' 或 'source' depend类型一起使用"
# 'dependent %select{__if_not_exists|__if_exists}0 declarations are ignored'
H7E0205C30EB0: '依赖的 %select{__if_not_exists|__if_exists}0 声明被忽略'
# 'dependent nested name specifier %0 for friend class declaration is not supported; turning off access control for %1'
H6C7EBDCCA541: '依赖的嵌套名称指定符 %0 用于友元类声明不受支持；禁用 %1 的访问控制'
# 'dependent nested name specifier %0 for friend template declaration is not supported; ignoring this friend declaration'
H5BCC077F4A6E: '依赖的嵌套名称指定符 %0 用于友元模板声明不受支持；忽略此友元声明'
# "dependent using declaration resolved to type without 'typename'"
H9473A34B51B9: "依赖的using声明解析为不带 'typename' 的类型"
# 'dereference of pointer to incomplete type %0'
H2DF43C211998: '解引用指向不完整类型 %0 的指针'
# 'dereference of type %1 that was reinterpret_cast from type %0 has undefined behavior'
H90FCF362143A: '对类型 %0 经reinterpret_cast转换为类型 %1 后的解引用会导致未定义行为'
# 'dereferenced pointer past the end of %select{|subobject of }0%select{temporary|%2}1 is not a constant expression'
H22AD60D3A378: '解引用超出 %select{|子对象的 }0%select{临时对象|%2}1 末尾的指针不是一个常量表达式'
# "dereferencing %0; was declared with a 'noderef' type"
H77B30DE9BC36: "解引用 %0；该类型被声明为 'noderef'"
# 'dereferencing a __weak pointer is not allowed due to possible null value caused by race condition, assign it to strong variable first'
H69A87CE8BA55: '由于竞态条件可能导致空值，不允许解引用__weak指针，请先将其赋值给strong变量'
# "dereferencing expression marked as 'noderef'"
HB6D67B14D60F: "解引用标记为 'noderef' 的表达式"
# 'derived class must specify the same code segment as its base classes'
HF7C9EF85294D: '派生类必须指定与基类相同的代码段'
# 'descending'
H486093918FF3: '降序'
# 'designated initializer invoked a non-designated initializer'
H504DCC34F2E8: '命名初始化器调用了非命名初始化器'
# "designated initializer missing a 'super' call to a designated initializer of the super class"
H94AB45A96460: "命名初始化器缺少对超类命名初始化器的 'super' 调用"
# "designated initializer should only invoke a designated initializer on 'super'"
H2306DCB92F88: "命名初始化器应仅在 'super' 上调用命名初始化器"
# 'designated initializers are a C++20 extension'
H868FB6A7DCFA: '命名初始化器是C++20扩展'
# 'designated initializers are a C99 feature'
HCE690B2EFB92: '指定初始化器是C99的特性'
# 'designated initializers are incompatible with C++ standards before C++20'
HB212F1F17A19: '指定初始化器与C++20之前的C++标准不兼容'
# 'designator in initializer for %select{scalar|indivisible sizeless}0 type %1'
HDC0C952FB90A: '%select{标量|不可分割且无大小}0类型 %1 的初始化器中的指定符'
# 'designator into flexible array member subobject'
H596716C96072: '指定符进入柔性数组成员子对象'
# 'destroying delete is not permitted to be type aware'
HBF72010CD873: '不允许破坏性删除运算符是类型感知的'
# "destroying object '%0' whose lifetime has already ended"
H480FFC7A6CDF: "销毁生命周期已结束的对象 '%0'"
# 'destroying operator delete can have only an optional size and optional alignment parameter'
H05866AB32F25: '销毁用的operator delete只能有可选的大小和可选的对齐参数'
# 'destruction of individual component of complex number is not yet supported in constant expressions'
H6533BAA0653D: '复数的单个组件的销毁在常量表达式中尚未得到支持'
# 'destruction of object that is already being destroyed'
HBC86CD58BD53: '正在销毁已被销毁的对象'
# 'destructor cannot be declared %select{<ERROR>|constexpr|consteval|constinit}0'
H39B25D41B01F: '析构函数不能声明为 %select{<ERROR>|constexpr|consteval|constinit}0'
# 'destructor cannot be declared %select{<ERROR>|constexpr|consteval|constinit}0 because %select{data member %2|base class %3}1 does not have a constexpr destructor'
HEA62090F1654: '析构函数不能声明为 %select{<ERROR>|constexpr|consteval|constinit}0，因为%select{数据成员 %2|基类 %3}1 没有constexpr析构函数'
# "destructor cannot be declared '%0'"
H18788E54B072: "析构函数不能声明为 '%0'"
# 'destructor cannot be declared as a template'
H2A9016676C0B: '析构函数不能声明为模板'
# 'destructor cannot be declared using a %select{typedef|type alias}1 %0 of the class name'
HD2E86EDB043A: '不能使用类名的 %select{typedef|类型别名}1 %0 来声明析构函数'
# 'destructor cannot be redeclared'
H7C102E557BD9: '析构函数不能被重新声明'
# 'destructor cannot be variadic'
H3060C3D6CE56: '析构函数不能是可变参数的'
# 'destructor cannot have a return type'
HB61BE667BB0D: '析构函数不能有返回类型'
# 'destructor cannot have any parameters'
H27289F072FC5: '析构函数不能有任何参数'
# 'destructor for %0 is not trivial because it is virtual'
H695A7FB4C51A: '%0 的析构函数不是平凡的，因为它为虚析构函数'
# 'destructor must be a non-static member function'
HE5AA51DEFC74: '析构函数必须是一个非静态成员函数'
# 'destructor name %0 does not refer to a template'
H6A0A4776F7D0: '析构函数名 %0 不指向一个模板'
# 'destructor of class %0 is ambiguous'
H29DC1463BFE1: '类 %0 的析构函数存在二义性'
# 'destructor type %0 in object destruction expression does not match the type %1 of the object being destroyed'
HCA02CE698CF6: '对象销毁表达式中的析构函数类型 %0 与被销毁对象的类型 %1 不匹配'
# 'detect use after scope within function'
H76CE675503B0: '检测函数内作用域结束后使用'
# 'detected while default synthesizing properties in class implementation'
HDACD480D581B: '在类实现中默认合成属性时检测到'
# 'determine if lfence instruction should exist in the retpoline'
HC723EAB1C806: '确定retpoline中是否应存在lfence指令'
# 'determine the availability of r11 before indirect branches'
H095D2FB8BA79: '确定间接分支前r11寄存器的可用性'
# 'determines whether to demangle function name when symbolizing function ids from the input log'
H55938C1F7AEA: '确定是否在从输入日志符号化函数ID时解码函数名'
# 'determines whether to sort input log records by timestamp'
HF854EBCB0FF7: '确定是否按时间戳对输入日志记录进行排序'
# "device clause with ancestor device-modifier used without specifying 'requires reverse_offload'"
H7C03F0398F87: '在未指定 "requires reverse_offload" 的情况下使用带有祖先设备修饰符的设备子句'
# "device files are not yet supported by '#embed' directive"
H3E3F85E899CB: '#embed 指令目前不支持设备文件'
# 'diagnostic formatting in SARIF mode is currently unstable'
HADEECC0D1814: 'SARIF模式下的诊断信息格式目前还不稳定'
# 'diagnostic msg: %0'
H1318B5E4A90B: '诊断信息：%0'
# 'diagtool find-diagnostic-id options'
H0E16FA84CCEE: 'diagtool查找诊断ID选项'
# "did not expect %0 '%2' to be managed by '%1'"
H41E6876DEC05: "未期望 %0 '%2' 由 '%1' 管理"
# "did not find header '%0' in framework '%1' (loaded from '%2')"
H33EA4C9E31A5: '在框架 "%1"（从 "%2" 加载）中未找到头文件 "%0"'
# "did not specify mandatory parameter '%0'"
H3CB9D79D973B: '未指定必选参数 "%0"'
# "did you forget ';'?"
H5762CA5BE293: '是否漏掉了 ";"？'
# "did you intend to use '#pragma pack (pop)' instead of '#pragma pack()'?"
H38F2C3CF1911: '是否应使用 "#pragma pack(pop)" 而不是 "#pragma pack()"？'
# "did you mean %0 ('%2' U+%1)?"
H034E19BAF4DB: '是否是指 %0（"%2" U+%1）？'
# 'did you mean %0?'
H0AFE75F407BD: '是否是指 %0？'
# 'did you mean %select{struct|interface|class}0 here?'
H2F94B54CE3AD: '此处是否是指 %select{struct|interface|class}0？'
# "did you mean '%0'?"
HC2D29273BC0C: '是否是指 "%0"？'
# "did you mean 'using namespace'?"
H7384271A4FC4: '是否是指 "using namespace"？'
# "did you mean to %select{dereference the argument to 'sizeof' (and multiply it by the number of elements)|remove the addressof in the argument to 'sizeof' (and multiply it by the number of elements)|provide an explicit length}0?"
H206E38ACCE90: '是否应%select{对 "sizeof" 的参数进行解引用（并乘以元素数量）|移除 "sizeof" 参数中的取地址运算符（并乘以元素数量）|提供显式的长度}0？'
# 'did you mean to call the %0 method?'
H0FF3D4ADDC94: '是否应调用 %0 方法？'
# 'did you mean to compare the result of %0 instead?'
HA27A0B6056FB: '是否应比较 %0 的结果？'
# "did you mean to use '%0'?"
H18F66684E290: '是否应使用 "%0"？'
# "did you mean to use '.' instead?"
HE2F23CD42B59: '是否应使用 "."？'
# "did you mean to use '\\u'?"
H8EB1B38F64B3: '您是否想使用‘\\u’？'
# "did you mean to use 'typename'?"
HA177681AD789: "您是否想使用 'typename'？"
# 'did you mean to use __block %0?'
H6A59F85FFA80: '您是否想使用__block %0？'
# "differing user-defined suffixes ('%0' and '%1') in string literal concatenation"
HD69068F6D5EE: "字符串字面量连接时用户定义的后缀不同（'%0' 和 '%1'）"
# 'digit separator cannot appear at %select{start|end}0 of digit sequence'
HC90158811A8B: '数字分隔符不能出现在数字序列的%select{开始|结束}0处'
# 'digit separators are incompatible with C standards before C23'
H45FD89D6E3CC: '数字分隔符与C23之前的C标准不兼容'
# 'digit separators are incompatible with C++ standards before C++14'
H14907D30B29E: '数字分隔符与C++14之前的C++标准不兼容'
# 'dimension expression does not evaluate to a constant unsigned int'
H7ABEC48E09A3: '维度表达式未计算为常量无符号整数'
# "direct access to Objective-C's isa is deprecated in favor of object_getClass()"
H9F7CC297D241: '直接访问Objective-C的isa已弃用，建议使用object_getClass()'
# 'direct attribute on property %0 ignored (not implemented by this Objective-C runtime)'
H4EFEDE46DF56: '属性 %0 的direct属性被忽略（此Objective-C运行时未实现该功能）'
# 'direct base %0 is inaccessible due to ambiguity:%1'
HB8D80890A48E: '直接基类 %0 由于以下歧义不可访问：%1'
# 'direct comparison of %select{an array literal|a dictionary literal|a numeric literal|a boxed expression|}0 has undefined behavior'
HB492D0D3EB6E: '直接比较%select{数组字面量|字典字面量|数值字面量|包装表达式|}0 会导致未定义行为'
# 'direct comparison of a string literal has undefined behavior'
H32F54A871B25: '直接比较字符串字面量会导致未定义行为'
# 'direct member declared here'
H29E544F12128: '直接成员在此处声明'
# 'direct method %0 declared here'
HFC16D00B1613: '直接方法 %0 在此处声明'
# 'direct method implementation was previously declared not direct'
HD4855D6E8730: '直接方法实现之前声明为非直接'
# 'direct method was declared in %select{the primary interface|an extension|a category}0 but is implemented in %select{the primary interface|a category|a different category}1'
HE6AB93C50673: '在%select{主接口|扩展|分类}0中声明而在%select{主接口|分类|不同分类}1中实现'
# 'direct property cannot be @dynamic'
HE7907E55F6FD: '直接属性不能为@dynamic'
# "directive '#pragma omp %0' cannot contain more than one '%1' clause%select{| with '%3' name modifier| with 'source' dependence}2"
H4FF8713761CF: "指令 '#pragma omp %0' 不能包含超过一个 '%1' 子句 %select{|带有 '%3' 名称修饰符|带有 'source' 依赖}2"
# "directive '#pragma omp %0' cannot contain more than one 'seq_cst',%select{ 'relaxed',|}1 'acq_rel', 'acquire' or 'release' clause"
HAC63F783B13F: "指令 '#pragma omp %0' 不能包含超过一个 'seq_cst',%select{ 'relaxed',|}1 'acq_rel', 'acquire' 或 'release' 子句"
# "directive '#pragma omp %0' requires the '%1' clause"
H54115AA95D6F: "指令 '#pragma omp %0' 需要 '%1' 子句"
# "directive '#pragma omp atomic%select{ %0|}1' cannot be used with '%2' clause"
H007A29406786: "指令 '#pragma omp atomic%select{ %0|}1' 不能与 '%2' 子句一起使用"
# "directive '#pragma omp atomic' cannot contain more than one 'read', 'write', 'update', 'capture', or 'compare' clause"
HE9B44E8E263B: "指令 '#pragma omp atomic' 不能包含超过一个 'read'、'write'、'update'、'capture' 或 'compare' 子句"
# "directive '#pragma omp taskwait' cannot use 'nowait' clause without 'depend' clause"
H6E17817BFD4B: "指令 '#pragma omp taskwait' 在没有 'depend' 子句的情况下不能使用 'nowait' 子句"
# 'directive may only be specified in protocols only'
H164583DA86CB: '指令只能在协议中指定'
# 'directive must be at file or namespace scope'
H1C3ABA756D9B: '指令必须位于文件或命名空间作用域'
# "directive name modifier '%0' is not allowed for '#pragma omp %1'"
H92E146113514: "指令名称修饰符 '%0' 不允许用于 '#pragma omp %1'"
# 'directory to dump objects to'
HD09DDF1651F9: '要导出对象的目录'
# 'disable '
HEEBCA72FCF98: '禁用 '
# 'disable P10 store forward-friendly conversion'
HB86702B7FAD9: '禁用P10存储转发友好型转换'
# 'disable all inlining (overrides other inlining options)'
HFF8B88EEABDB: '禁用所有内联（覆盖其他内联选项）'
# 'disable attaching TBAA tags to memory accessing operations to override default Flang behavior'
H90AD861FB58A: '禁用在内存访问操作上附加TBAA标签以覆盖Flang的默认行为'
# 'disable attributor runs'
H6B93977370B5: '禁用attributor阶段的运行'
# 'disable automatically generated 32byte paired vector stores'
H37D64DB7E6AE: '禁用自动生成 32 字节配对向量存储'
# 'disable constant hoisting on PPC'
H653549C49999: '在PPC上禁用常量提升'
# 'disable debug output'
H9D7E26590F03: '禁用调试输出'
# 'disable generation of structured FIR'
H021ABE4FA052: '禁用结构化FIR的生成'
# 'disable instrumentation optimizations that sacrifice profile accuracy (for debugging, default: false)'
H2E999F6F69E3: '禁用会降低剖面准确性的插桩优化（调试用途，默认：false）'
# 'disable multithreading'
H29487A51C4F2: '禁用多线程'
# 'disable outlining indirect calls.'
H3A6314FB1E19: '禁用间接调用的外联'
# 'disable peepholes'
H199828204162: '禁用peephole优化'
# 'disable preincrement load/store generation on PPC'
H137DF3A43000: '在PPC架构上禁用预递增的加载/存储指令生成'
# 'disable setting the node scheduling preference to ILP on PPC'
H1F9B89B13D72: '在PPC架构上禁用将节点调度优先级设为ILP'
# 'disable sibling call optimization on ppc'
HCCF134132CAF: '在PPC架构上禁用兄弟调用优化'
# 'disable similarity matching, and outlining, across branches for debugging purposes.'
H62E4BE9FF57F: '禁用跨分支的相似性匹配和函数外联（用于调试）'
# 'disable the default synthesis of Objective-C properties'
H72E5F763EC4E: '禁用Objective-C属性的默认合成'
# 'disable the feature'
H89A827DA533D: '禁用该功能'
# 'disable unaligned load/store generation on PPC'
H6B2367F2761C: '在PPC架构上禁用未对齐的加载/存储指令生成'
# 'disable vector permute decomposition'
HB72EC10B2CEE: '禁用向量置换分解'
# 'disabled expansion of recursive macro'
H7E32A887A37D: '禁用递归宏的展开'
# 'disables externalization of functions whose addresses are taken'
HA22CB7ECC7FF: '禁用对外部引用地址的函数进行外部化处理'
# 'disables externalization of global variable with local linkage; may cause globals to be duplicated which increases binary size'
HFB10DDFC11CF: '禁用对具有局部链接性的全局变量进行外部化处理；可能导致全局变量重复，从而增加二进制文件大小'
# 'discriminator argument to ptrauth_sign_constant must be a constant integer, the address of the global variable where the result will be stored, or a blend of the two'
H24D055782EF6: 'ptrauth_sign_constant 的 discriminator 参数必须是一个常量整数、存储结果的全局变量的地址，或者是两者的结合'
# 'display a graph using the fractional block frequency representation.'
H0E0DF92DD5CF: '使用分块频率表示显示图表。'
# 'display a graph using the raw integer fractional block frequency representation.'
H48B34855A7C6: '使用原始整型分块频率表示显示图表。'
# 'display a graph using the real profile count if available.'
H40F8C199B975: '如有可用，使用实际配置文件计数显示图表。'
# 'display the encoded probes in binary section'
H2AB55984C4D7: '显示二进制部分中的编码探针'
# 'display the results in JSON format'
H181ED368406C: '以JSON格式显示结果'
# 'display the results in a list sorted by total time'
HD124AAE398C8: '按总时间排序的列表显示结果'
# 'display the results in a merged list sorted by pass name'
HD6270C003FAF: '按pass名称排序的合并列表显示结果'
# 'display the results in text format'
H5126F4AC6EE2: '以文本格式显示结果'
# 'display the results ina with a nested tree view'
H3B01C53C285F: '以嵌套树视图显示结果'
# 'display the results with a nested pipeline view'
HD3FB89799811: '以嵌套流水线视图显示结果'
# 'div and rem instructions on integers with more than <N> bits are expanded.'
H9085E8D323A2: '当整数位数超过 <N> 位时，展开div和rem指令'
# 'division by zero'
H3658877899CE: '除以零'
# 'division by zero in preprocessor expression'
H312B477ACFDB: '预处理器表达式中的除以零'
# 'dllexport/dllimport inline member functions of dllexport/import classes (default)'
H138D0C477A7F: '导出/导入使用dllexport/import类的内联成员函数（默认）'
# 'dllimport cannot be applied to non-inline function definition'
H1B629BAD5F55: 'dllimport 不能应用于非内联函数定义'
# 'do not apply'
HB502CD3A2C1B: '不应用'
# 'do not diff functions whose contents have not been changed from one binary to another'
H30A32C42CDF9: '不比较两个二进制文件中内容未发生变化的函数'
# 'do not display graphs.'
H0D6F782C8BD3: '不显示图表。'
# 'do not emit module ctors for global counters'
H4C00D7F83272: '不要为全局计数器生成模块构造函数'
# 'do not infer Objective-C related result type based on method family'
HA72282825A47: '不根据方法类别推断与Objective-C相关的结果类型'
# 'do not optimize PLT calls'
H790DE86EF643: '不优化PLT调用'
# 'do not optimize functions with jump tables'
HCB3EB74717E1: '不优化包含跳转表的函数'
# 'do not perform frame optimization'
HA057BC463383: '不执行帧优化'
# 'do not perform indirect call promotion'
H868459C436A1: '不执行间接调用提升'
# 'do not print merged data to stdout'
H7F153D59BE8A: '不将合并后的数据输出到标准输出'
# 'do not print objects/functions'
H6FEA94329728: '不打印对象/函数'
# 'do not reorder basic blocks'
HDB47587E0803: '不重新排序基本块'
# 'do not reorder functions'
H80129F5CF747: '不重新排序函数'
# 'do not scan cold functions for external references (may result in slower binary)'
H06D0BAB57AFF: '不扫描冷函数中的外部引用（可能导致二进制文件运行速度变慢）'
# 'do not show.'
H410E3DC30FB6: '不显示。'
# 'domain argument %0 does not point to an NSString or CFString constant'
H04276D1D8088: '域参数 %0 不指向 NSString 或 CFString 常量'
# 'domain argument %select{|%1 }0does not refer to global constant'
H427CD3AEDAC3: '域参数 %select{|%1 }0 不指向全局常量'
# "don't always align innermost loop to 32 bytes on ppc"
H8446540436C8: '在PPC架构上不对最内层循环始终进行 32 字节对齐'
# "don't demangle symbols"
HFD596F32C278: '不进行符号解码'
# "don't report bad accesses via pointers with this tag"
HC0582E9D5000: '不报告通过此标签指针的非法访问'
# "don't test for failure"
H2CD70DD9AB50: '不测试失败情况'
# 'double precision constant requires %select{cl_khr_fp64|cl_khr_fp64 and __opencl_c_fp64}0, casting to single precision'
H4D72ED1FA64B: '双精度常量需要 %select{cl_khr_fp64|cl_khr_fp64 和 __opencl_c_fp64}0，转换为单精度'
# 'double-quoted include "%0" cannot be aliased to angle-bracketed include <%1>'
H136E4A788F48: '双引号包含的 "%0" 不能别名为尖括号包含的 <%1>'
# 'double-quoted include "%0" in framework header, expected angle-bracketed instead'
H2D4306614026: '框架头文件中的双引号包含 "%0"，应使用尖括号包含'
# 'due to %0 being dllexported%select{|; try compiling in C++11 mode}1'
HB6A4EDE022F4: '由于 %0 被 dllexported%select{|; 尝试使用 C++11 模式编译}1'
# 'due to lvalue conversion of the controlling expression, association of type %0 will never be selected because it is %select{of array type|qualified}1'
HE4CE0D7DDF88: '由于控制表达式进行了左值转换，类型 %0 的关联永远不会被选中，因为它 %select{是数组类型|已限定}1'
# 'dump CFG of functions with unknown control flow'
HDBCCF42DD8E1: '转储具有未知控制流的函数的控制流图'
# 'dump CodeView symbol record raw bytes'
HAEF5CAE11C43: '转储CodeView符号记录的原始字节'
# 'dump CodeView type record raw bytes from IPI stream'
H689D664ADF5F: '转储IPI流中的CodeView类型记录原始字节'
# 'dump CodeView type record raw bytes from TPI stream'
H0FC07B9E3139: '转储TPI流中的CodeView类型记录原始字节'
# 'dump CodeView type records from IPI stream'
H7E10374C5E74: '转储IPI流中的CodeView类型记录'
# 'dump CodeView type records from TPI stream'
H4737840A6120: '转储TPI流中的CodeView类型记录'
# 'dump FPO records'
H341F7F9C33EE: '转储FPO记录'
# 'dump Globals hashes'
H39246A122E5B: '转储全局符号哈希'
# 'dump Globals symbol records'
H9634A6AB6723: '转储全局符号记录'
# 'dump Linux alternative instructions info'
H92A80825B346: '转储Linux内核替代指令信息'
# 'dump Linux kernel PCI fixup table'
H0391F2419EB1: '转储Linux内核PCI修正表'
# 'dump Linux kernel SMP locks'
HF372737C565A: '转储Linux内核SMP锁'
# 'dump Linux kernel exception table'
HD3701232B9AB: '转储Linux内核异常表'
# 'dump Linux kernel paravitual patch sites'
HAD29F02859C4: '转储Linux内核半虚拟化补丁点'
# 'dump Linux kernel static calls'
HBDFDCB9108E1: '转储Linux内核静态调用'
# 'dump Linux kernel static keys jump table'
HF51D39901B0D: '转储Linux内核静态键跳转表'
# 'dump PDB String Table'
H21DF5A80DD1F: '转储PDB字符串表'
# 'dump PDB String Table Details'
H5264906CCB27: '转储PDB字符串表详细信息'
# 'dump PDB named stream table'
HD3F8AEE8FAA4: '转储PDB命名流表'
# 'dump Publics hashes and address maps'
H982F0D86E5A4: '转储公共符号哈希和地址映射'
# 'dump Publics stream data'
H77C736E1764D: '转储公共符号流数据'
# 'dump all BAT tables'
H2473A7E7E1DA: '转储所有BAT表'
# 'dump backreferences'
H60EF9FD249CA: '转储反向引用'
# 'dump callgraph to the given file'
H3F328C977475: '将调用图转储到指定文件'
# 'dump compiland information'
H6229647CD528: '转储编译单元信息'
# 'dump cross module exports (DEBUG_S_CROSSSCOPEEXPORTS subsection)'
HBA659F46571B: '转储跨模块导出项（DEBUG_S_CROSSSCOPEEXPORTS子部分）'
# 'dump cross module imports (DEBUG_S_CROSSSCOPEIMPORTS subsection)'
H26F5B6DD5D0E: '转储跨模块导入项（DEBUG_S_CROSSSCOPEIMPORTS子部分）'
# 'dump file information'
HE35AD70400C4: '转储文件信息'
# 'dump file summary'
HBC127C99D732: '转储文件摘要'
# "dump function CFGs to graphviz format after each stage;enable '-print-loops' for color-coded blocks"
H790226C2A523: '在每个阶段之后将函数的CFG导出为graphviz格式；启用“-print-loops”以显示彩色编码的块'
# 'dump function into assembly'
H160A471B29E4: '转储函数为汇编代码'
# 'dump id hashes and index offsets'
H45ABCE63A690: '转储ID哈希和索引偏移'
# 'dump inlinee line information (DEBUG_S_INLINEELINES subsection)'
HD3FD0B06365E: '转储内联行信息（DEBUG_S_INLINEELINES子部分）'
# 'dump jitted objects'
HC6CCA4501C84: '转储即时编译对象'
# 'dump module symbols'
H1047966FD40D: '转储模块符号'
# 'dump parsed bolt data for debugging'
H1E6D3BB027F8: '转储用于调试的解析BOLT数据'
# 'dump public / global common record stream'
H582CCEB02839: '转储公共/全局通用记录流'
# 'dump raw ORC unwind information (sorted)'
H3C7746AFAC8F: '转储原始ORC异常展开信息（已排序）'
# 'dump section contributions'
HD1F222CEF84F: '转储节贡献信息'
# 'dump section map'
H3816E8108BF5: '转储节映射'
# 'dump source file/line information (DEBUG_S_LINES subsection)'
HD995BB7B3DC0: '转储源文件/行信息（DEBUG_S_LINES子部分）'
# 'dump statistics on the number and size of types transitively referenced by symbol records'
H63F7F6E11F53: '转储符号记录中递归引用的类型数量和大小的统计信息'
# "dump subsections from each module's debug stream"
HFC99948BE195: '转储每个模块调试流中的子部分'
# 'dump summary of the PDB streams'
H81F82DCB9C94: '转储PDB流的摘要'
# 'dump the Pre-FIR tree prior to FIR generation'
H1C6BBDF08715: '在生成FIR之前转储Pre-FIR树'
# 'dump the preprocessed tokens'
H80F7445EE14A: '转储预处理后的标记'
# 'dump the symbol table'
H8EF419A2DB2C: '转储符号表'
# "dump the symbols record's all children."
HB63145DD7309: '转储符号记录的所有子项。'
# "dump the symbols record's all parents."
H7B31FDBBCCB3: '转储符号记录的所有父项。'
# 'dump the syntax tree'
H63FBC9209EA6: '转储语法树'
# 'dump type hashes and index offsets'
H02D59206CDC4: '转储类型哈希和索引偏移'
# 'dumps the generated benchmark object to disk and prints a message to access it'
H7BC6D646456E: '将生成的基准测试对象写入磁盘并打印访问信息'
# "duplicate %0 clause in an 'external_source_symbol' attribute"
H3523FE9C404F: "在 'external_source_symbol' 属性中重复了 %0 子句"
# "duplicate '%0' declaration specifier"
HD8ED5E5CBF0B: "重复的 '%0' 声明说明符"
# "duplicate 'virtual' in base specifier"
HA0A16A07E97F: "基类说明符中重复的 'virtual'"
# "duplicate asm qualifier '%0'"
HE8EA4F072983: "重复的 asm 限定符 '%0'"
# "duplicate attribute subject matcher '%0'"
H1D5786B873EA: "重复的属性对象匹配器 '%0'"
# "duplicate case value '%0'"
H4BDEA82874BB: "重复的 case 值 '%0'"
# "duplicate case value: '%0' and '%1' both equal '%2'"
HCE899F8A3E5C: "重复的 case 值：'%0' 和 '%1' 均等于 '%2'"
# 'duplicate code segment specifiers'
HBEFD6978776A: '重复的代码段说明符'
# 'duplicate declaration of %0 is invalid in C++'
H3F3D9A6BB48A: '%0 的重复声明在C++中无效'
# 'duplicate declaration of method %0'
HA0EF6CBBD7AC: '方法 %0 的重复声明'
# 'duplicate default generic association'
H2C51601AE456: '重复的通用关联默认值'
# 'duplicate definition of category %1 on interface %0'
HECFD78DC0BC9: '接口 %0 上的分类 %1 的重复定义'
# 'duplicate explicit instantiation of %0'
HDBC529CD9977: '%0 的显式实例化重复'
# 'duplicate explicit instantiation of %0 ignored as a Microsoft extension'
HDA2A4AABFB51: '作为 Microsoft 扩展被忽略的 %0 显式实例化重复'
# 'duplicate interface definition for class %0'
H95CB7C0C6F7F: '类 %0 的重复接口定义'
# 'duplicate key in dictionary literal'
H048B82F688D2: '字典字面量中的重复键'
# 'duplicate macro parameter name %0'
H066136189F8C: '重复的宏参数名称 %0'
# 'duplicate member %0'
HC0ECCD41D310: '重复的成员 %0'
# "duplicate modifier '%0' in '%1' clause"
HF11C4EF9CA32: "在 '%1' 子句中重复的修饰符 '%0'"
# "duplicate module file extension block name '%0'"
HCCAD463A8663: "重复的模块文件扩展块名称 '%0'"
# 'duplicate nullability specifier %0'
HBA9CD0A409AC: '重复的空值限定符 %0'
# 'duplicate parameter modifier %0'
H6D49784340BA: '重复的参数修饰符 %0'
# 'duplicate protocol definition of %0 is ignored'
HD20F74839349: '%0 的重复协议定义将被忽略'
# 'duplicate unconditional branches that cross a cache line'
H33FDED0520CF: '复制跨越缓存行的无条件分支'
# 'duplicate use of asm operand name "%0"'
H3EAACD3C87CF: 'asm 操作数名称 "%0" 重复使用'
# "duplicated command '%select{\\|@}0%1'"
H76B78FD8FF48: "重复的命令 '%select{\\|@}0%1'"
# 'during field initialization in %select{this|the implicit default}0 constructor'
H865BE3842864: '在 %select{this|the implicit default}0 构造函数的字段初始化期间'
# 'during template argument deduction for %select{class|variable}0 template %select{partial specialization |}1%2 %3'
H7650D46B8E2E: '在推导 %select{类|变量}0 模板 %select{部分特化 |}1%2 %3 的模板参数时'
# 'dxc compatibility options.'
H3AF127D95E36: 'dxc 兼容性选项'
# 'dxv not found; resulting DXIL will not be validated or signed for use in release environment'
H6BC661D7D75A: '未找到 dxv；生成的 DXIL 将不会被验证或签名，无法在发布环境中使用'
# 'dynamic exception specifications are deprecated'
H37FC9EB13E92: '动态异常规范已被弃用'
# 'dynamic exception specifications with types are currently ignored in wasm'
H3D36CC52AFBF: '在 wasm 中带有类型的动态异常规范当前会被忽略'
# 'dynamic initialization is not supported for __device__, __constant__, __shared__, and __managed__ variables'
H6251875A88D3: '__device__、__constant__、__shared__ 和 __managed__ 变量不支持动态初始化'
# "dynamic library symbol '%0' is %select{weak defined|thread local}1, but its declaration is not"
H876356229227: "动态库符号 '%0' 是 %select{弱定义|线程本地}1，但其声明并非如此"
# 'dynamic memory allocation is not permitted in constant expressions until C++20'
H63A7F05406AD: '在 C++20 之前，常量表达式中不允许进行动态内存分配'
# 'dynamic property cannot have instance variable specification'
HD37DA789564D: '动态属性不能指定实例变量'
# 'dynamic_cast will not work since RTTI data is disabled by %select{-fno-rtti-data|/GR-}0'
HBD4085CEECCB: '由于 %select{-fno-rtti-data|/GR-}0 禁用了 RTTI 数据，dynamic_cast 将无法正常工作'
# 'e'
H58E6B3A414A1: 'e'
# 'editor placeholder in source file'
H8455BF28630F: '源文件中的编辑占位符'
# "effects conflict when merging declarations; kept '%0', discarded '%1'"
H73408A047417: '合并声明时效果冲突；保留“%0”，丢弃“%1”'
# 'elaborated enum specifier cannot be declared as a friend'
H7321A1B2921E: '详细枚举说明符不能声明为友元'
# 'element %0 also has value %1'
HFCF33BA58954: '元素 %0 还具有值 %1'
# 'element %0 has been implicitly assigned %1 which another element has been assigned'
H72D209AC7B7A: '元素 %0 被隐式赋值为 %1，而另一个元素已被赋予该值'
# 'eliminate unreachable code'
H5CECE35D9DC9: '消除不可达代码'
# 'ellipsis in pack %select{|init-}0capture must appear %select{after|before}0 the name of the capture'
H6C27D3CFC7C1: '在 pack %select{|init-}0capture 中的省略号必须出现在捕获名称的 %select{后|前}0'
# 'embedded and GOT-based position independence are incompatible'
H471F7EE0F065: '嵌入式和基于 GOT 的位置无关性不兼容'
# 'embedding a #%0 directive within macro arguments is not supported'
HB9B077BA7EC9: '在宏参数中嵌入 #%0 指令不受支持'
# 'embedding a directive within macro arguments has undefined behavior'
HD8530107105F: '在宏参数中嵌入指令具有未定义行为'
# 'emit JSON'
H65D5678CB372: '生成JSON格式'
# 'emit YAML'
H54F0FFD710F0: '生成YAML格式'
# 'emit normal text output (default)'
HED43B52325DA: '生成普通文本输出（默认）'
# 'emit warnings'
H020A72B2E05B: '生成警告'
# 'empty %0 cannot be composed with named ones'
HE7EB612973FC: '空的 %0 无法与命名项组合'
# 'empty %select{struct|union}0 is a GNU extension'
H758BF913FE7C: '空的 %select{结构|联合}0 是 GNU 扩展'
# 'empty case range specified'
H15C9A1C7CC9D: '指定了空的 case 范围'
# 'empty character constant'
H277FE12896EE: '空的字符常量'
# "empty delimited universal character name; treating as '\\' '%0' '{' '}'"
HF9BFC93E5104: "空的限定通用字符名称；将其视为 '\\' '%0' '{' '}'"
# "empty expression statement has no effect; remove unnecessary ';' to silence this warning"
HE7735A8B2ADE: "空的表达式语句没有效果；删除不必要的 ';' 以消除此警告"
# 'empty filename'
H1CC4DB7178D7: '空的文件名'
# "empty initialization statement of '%select{if|switch|range-based for}0' has no effect"
HCB0D32A02160: "在 '%select{if|switch|范围基于的 for}0' 中的空初始化语句没有效果"
# 'empty macro arguments are a C99 feature'
HD178344D06D5: '空的宏参数是 C99 特性'
# 'empty macro arguments are incompatible with C++98'
HE94FA0985A16: '空的宏参数与 C++98 不兼容'
# 'empty modifier-specification-list is not allowed'
HB0857A4C55BC: '空的 modifier-specification 列表是不允许的'
# "empty paragraph passed to '%select{\\|@}0%1' command"
H38E7CAD895AE: "传递到 '%select{\\|@}0%1' 命令的空段落"
# 'empty parentheses interpreted as a function declaration'
H058E44413EA1: '空的括号被解释为函数声明'
# 'empty symbolic operand name in inline assembly string'
H2DC9E2773A21: '内联汇编字符串中的空符号操作数名称'
# 'enable '
H15F13B12A39B: '启用 '
# 'enable CUDA Fortran'
H7782720B2BB2: '启用CUDA Fortran'
# 'enable PC Relative linker optimization'
HB16456951215: '启用PC Relative链接器优化'
# 'enable all attributor runs'
HDC600719482C: '启用所有属性分析器运行'
# 'enable all debugging printout'
H74F2F5BCE1B3: '启用所有调试打印'
# 'enable all peephole optimizations'
HDB0605F9FA2D: '启用所有窥孔优化'
# 'enable call graph SCC attributor runs'
H3201C4D45BA3: '启用调用图SCC属性分析器运行'
# 'enable coalescing of duplicate branches for PPC'
HF8CFF517B8BE: '启用PPC架构的重复分支合并'
# 'enable const and copy propagation after tail duplication'
H9919F0504195: '启用尾部复制后的const和复制传播'
# 'enable elimination of sign-extensions'
HF1685FA60FF7: '启用消除符号扩展'
# 'enable elimination of zero-extensions'
H64FB2468ED4F: '启用消除零扩展'
# 'enable extended encoding of block type signature'
HCB2363578F85: '启用 block type signature 的扩展编码'
# 'enable fixed form'
H94C246A27D7E: '启用固定格式'
# 'enable load elimination using memory profiling data when performing ICP'
HF69B8E887DB3: '在执行ICP时使用内存分析数据启用负载消除'
# "enable memory profile parsing if it's present in the input data, on by default unless `--itrace` is set."
H015F6FD662F3: '启用内存剖析解析（若输入数据中存在），除非设置`--itrace`否则默认启用'
# 'enable module-wide attributor runs'
H6A1678301319: '启用模块级属性分析器运行'
# 'enable openacc'
HCDE854697CA7: '启用OpenACC支持'
# 'enable openmp'
H1CFA464A8305: '启用OpenMP支持'
# 'enable openmp GPU target codegen'
HFFBCDE42BA97: '启用OpenMP GPU目标代码生成'
# 'enable openmp device compilation'
H87F22E3808C9: '启用OpenMP设备编译'
# 'enable optimization of conditional traps'
HE76CA42D1102: '启用OpenMP设备编译'
# 'enable peephole optimizations'
HCB5CF649C604: '启用窥孔优化'
# 'enable preservation of all attributes. even those that are unlikely to be useful'
H13B51E3CE008: '启用保留所有属性，即使那些不太可能有用的'
# 'enable preservation of attributes throughout code transformation'
H580FCE5CF0E9: '在代码转换过程中启用属性保留'
# 'enable register pressure reduce in machine combiner pass.'
H357058DB4C32: '在machine combiner pass中启用寄存器压力减少'
# 'enable safe stack coloring'
H95A282232AD0: '启用安全栈着色'
# 'enable safe stack layout'
HCB2AFC2C2D37: '启用安全栈布局'
# 'enable software prefetching on PPC'
H5C8D5DA8AA2D: '在PPC上启用软件预取'
# 'enable splitting of the restore block if possible'
HFB2E82BFA087: '如果可能则启用恢复块拆分'
# 'enable the feature when using profile data'
H983F48A83B4D: '在使用配置文件数据时启用该功能'
# 'enable the feature with/wo profile data'
HA9F0B8DA8301: '启用该功能时是否使用配置文件数据'
# 'enable the shrink-wrapping pass'
H7A4C304F5A12: '启用shrink-wrapping pass'
# 'enable use of redzone on AArch64'
H0CF57E62B75D: '在AArch64上启用红区使用'
# 'enable/disable all ARC Optimizations'
H0DFE6EE5AB14: '启用/禁用所有ARC优化'
# 'enclose %0 in %select{an @available|a __builtin_available}1 check to silence this warning'
HC0011ACD5CEF: '用 %select{@available|__builtin_available}1 检查包裹 %0 以消除此警告'
# 'encoding of %0 type is incomplete because %1 component has unknown encoding'
HE63ED9F43B42: '%0 类型的编码不完整，因为 %1 成分的编码未知'
# "encoding prefix '%0' on an unevaluated string literal has no effect%select{| and is incompatible with c++2c}1"
HFB264777D8F6: "未求值的字符串字面量上的编码前缀 '%0' 没有效果 %select{| 且与 c++2c 不兼容}1"
# 'end tag'
HE76165194C35: '结束标签'
# "entering module '%0' due to this pragma"
H00CF7F723C1C: "由于此pragma进入模块 '%0'"
# 'enum %0 was explicitly specialized here'
H888313DD02EB: '枚举 %0 在这里被显式特化'
# 'enumeration %0 is incomplete'
HACD4B99390E7: '枚举类型 %0 是不完整的'
# 'enumeration cannot be a template'
H0777CF5091AE: '枚举类型不能作为模板'
# 'enumeration previously declared as %select{un|}0scoped'
H979505490BD1: '枚举之前被声明为%select{非|}0 作用域'
# 'enumeration previously declared with %select{non|}0fixed underlying type'
H8C078F2C2E0F: '枚举之前被声明为带有%select{非|}0 固定底层类型'
# 'enumeration redeclared with different underlying type %0 (was %1)'
H67E555152513: '枚举被重新声明为不同的底层类型 %0（原为 %1）'
# 'enumeration type %0 is not allowed in a vector conditional'
H71F136014B3C: '枚举类型 %0 不允许在向量条件中使用'
# 'enumeration type in nested name specifier is incompatible with C++98'
HA088A8B3CD7F: '嵌套名称限定符中的枚举类型与C++98不兼容'
# 'enumeration types with a fixed underlying type are a C++11 extension'
HFFCCC841103E: '带有固定底层类型的枚举类型是C++11的扩展'
# 'enumeration types with a fixed underlying type are a C23 extension'
H463F9486C53D: '带有固定底层类型的枚举类型是C23的扩展'
# 'enumeration types with a fixed underlying type are a Microsoft extension'
H6BC03602C783: '带有固定底层类型的枚举类型是Microsoft扩展'
# 'enumeration types with a fixed underlying type are incompatible with C standards before C23'
H39FE50255F32: '带有固定底层类型的枚举类型与C23之前的C标准不兼容'
# 'enumeration types with a fixed underlying type are incompatible with C++98'
H73924A0CCAED: '带有固定底层类型的枚举类型与C++98不兼容'
# 'enumeration value %0 is out of range of flags in enumeration type %1'
H4F8DF0E727E1: '枚举值 %0 超出枚举类型 %1 的标志范围'
# 'enumeration values exceed range of largest integer'
HC084754F6A8B: '枚举值超出最大整数类型的范围'
# 'enumerations cannot be explicitly instantiated'
H997CA3993586: '枚举类型不能显式实例化'
# 'enumerator %0 does not exist in instantiation of %1'
H3D7F75D140F9: '枚举常量 %0 在实例化 %1 时不存在'
# 'enumerator %0 with value %1 here'
HD8CCFA398CFA: '此处枚举常量 %0 的值为 %1'
# 'enumerator value %0 is not representable in the underlying type %1'
HAB7EC95F417E: '枚举常量 %0 的值无法用底层类型 %1 表示'
# 'enumerator value is not representable in the underlying type %0'
H9CDAE4E68DA9: '枚举值无法用底层类型 %0 表示'
# 'enums in the Microsoft ABI are signed integers by default; consider giving the enum %0 an unsigned underlying type to make this code portable'
HB2071E0C6A67: 'Microsoft ABI中的枚举默认是带符号整数；请考虑为枚举 %0 指定无符号底层类型以增强代码的可移植性'
# "environment '%0' is not supported: '%1'"
H88874600742B: "不支持的环境 '%0'：'%1'"
# "environment variable 'SOURCE_DATE_EPOCH' ('%0') must be a non-negative decimal integer <= %1"
H4F81D6E33B46: "环境变量 'SOURCE_DATE_EPOCH' ('%0') 必须是小于等于 %1 的非负十进制整数"
# 'environment variable CC_PRINT_HEADERS_%select{FORMAT|FILTERING}0 has invalid value %1'
H69C68EA8FAC0: '环境变量 CC_PRINT_HEADERS_%select{FORMAT|FILTERING}0 的值 %1 无效'
# 'environment variable CC_PRINT_HEADERS_FORMAT=%0 requires a compatible value for CC_PRINT_HEADERS_FILTERING'
HFC634F31327F: '环境变量CC_PRINT_HEADERS_FORMAT=%0 需要为CC_PRINT_HEADERS_FILTERING指定兼容值'
# 'epsilon for benchmark point clustering'
HA3C9480C7F62: '基准点聚类的epsilon值'
# 'epsilon for detection of when the cluster is different from the LLVM schedule profile values'
HBE4394643CF5: '检测LLVM调度配置文件值差异的epsilon值'
# 'equality comparison between function pointer and void pointer (%0 and %1)'
HD61C2409F0EE: '函数指针与void指针之间的相等性比较（%0 和 %1）'
# 'equality comparison with extraneous parentheses'
H461F5EF9D3AE: '存在多余的括号的相等性比较'
# 'error in backend: %0'
H5E9564F574A6: '后端错误：%0'
# "error in loading module '%0' from prebuilt module path"
H9CB0C604EFA6: "从预构建模块路径加载模块 '%0' 时出错"
# "error opening '%0': %1"
H14F257DDD829: "打开 '%0' 时出错：%1"
# "error opening '%0': required by the CrossTU functionality"
HD1F59176156D: "打开 '%0' 时出错：该文件由跨翻译单元功能所需"
# "error opening file '%0': %1"
H36FA208EA1D0: "打开文件 '%0' 时出错：%1"
# "error parsing index file: '%0' line: %1 '<USR-Length>:<USR> <File-Path>' format expected"
HDAED7E913418: "索引文件解析错误：'%0' 第 %1 行应为 '<USR-Length>:<USR> <File-Path>' 格式"
# "error reading '%0': %1"
HB78815388E3E: "读取 '%0' 时出错：%1"
# 'error reading stdin: %0'
HFD3376140ADC: '读取标准输入时出错：%0'
# 'escaped newline between */ characters at block comment end'
H16A52D2449DE: '块注释末尾的*/字符之间存在转义换行符'
# 'exact handling of relational integer ICmp'
H083F931E8E9B: '关系整数ICmp的精确处理'
# "exactly one '%0' directive must appear in the loop body of an enclosing directive"
H3C9E45F0564B: "外围指令的循环体内必须出现恰好一个 '%0' 指令"
# "exactly one of 'depend', 'destroy', or 'update' clauses is expected"
H41134C7D7A6A: "必须且只能指定 'depend'、'destroy' 或 'update' 子句中的一个"
# "exactly one of 'inclusive' or 'exclusive' clauses is expected"
H43DE08BE23B9: "必须且只能指定 'inclusive' 或 'exclusive' 子句中的一个"
# 'exception declarator cannot be qualified'
H9E73B1CE7174: '异常声明符不能被限定'
# 'exception model'
HB1632BFA78F0: '异常模型'
# 'exception object of type %0 has %select{private|protected}1 destructor'
H45EFA39B1650: '类型为 %0 的异常对象具有%select{私有|受保护}1的析构函数'
# 'exception of type %0 will be caught by earlier handler'
H63736AC525A3: '类型为 %0 的异常将被更早的处理程序捕获'
# 'exception specification in declaration does not match previous declaration'
H02068091298F: '当前声明的异常规范与之前的声明不匹配'
# 'exception specification in explicit instantiation does not match instantiated one'
HB42947FF7AB7: '显式实例化中的异常规范与实例化后的规范不匹配'
# 'exception specification is not available until end of class definition'
HD568DD20B09E: '异常规范在类定义结束前不可用'
# 'exception specification needed for member of incomplete class %0'
H64C22CA14EC7: '不完整类 %0 的成员需要异常规范'
# 'exception specification of %0 uses itself'
H8B7B4ED4974B: '%0 的异常规范使用自身'
# "exception specification of '...' is a Microsoft extension"
H50C368DB8633: "'...' 的异常规范是Microsoft扩展"
# 'exception specification of overriding function is more lax than base version'
HBB63D54D7089: '覆盖函数的异常规范比基类版本更宽松'
# 'exception specifications are not allowed beyond a single level of indirection'
HB84B4B7EA104: '异常规范不允许超过单层间接引用'
# 'exception specifications are not allowed in %select{typedefs|type aliases}0'
HBAC9EC08A3E9: '异常规范不允许在 %select{typedefs|类型别名}0中使用'
# 'exception specifications of %select{return|argument}0 types differ'
H04931F9B5864: '%select{返回|参数}0类型的异常规范不同'
# 'excess elements in %select{array|vector|scalar|union|struct}0 initializer'
H6B059251CDF0: '%select{数组|向量|标量|联合|结构体}0初始化器存在多余元素'
# 'excess elements in char array initializer'
H65240A881DB2: '字符数组初始化器存在多余元素'
# 'excess elements in initializer for indivisible sizeless type %0'
HF6B0539A54ED: '不可分割无尺寸类型 %0 的初始化器存在多余元素'
# 'excess precision is requested but the target does not support excess precision which may result in observable differences in complex division behavior%select{|, additional uses where the requested higher precision cannot be honored were found but not diagnosed}0'
H46192DCC4FC7: '请求额外精度但目标架构不支持额外精度，可能导致复数除法行为差异 %select{|, 在其他需要更高精度的位置未诊断出无法满足的情况}0'
# 'exe called with module IR after each pass that changes it'
H9DCF33C92D4F: '在每次修改模块的pass后，执行带有该模块IR的exe'
# 'execute only is not supported for the %0 sub-architecture'
H355C6C44365F: '%0 子架构不支持执行仅模式'
# 'existing instance variable %1 for __weak property %0 must be __weak'
HBE1A4247ED95: '__weak属性 %0 的现有实例变量 %1 必须为__weak'
# 'existing instance variable %1 for property %0 with %select{unsafe_unretained|assign}2 attribute must be __unsafe_unretained'
H45768C1508E1: '属性 %0 的 %select{unsafe_unretained|assign}2 属性对应的实例变量 %1 必须为__unsafe_unretained'
# 'existing instance variable %1 for strong property %0 may not be %select{|__unsafe_unretained||__weak}2'
H98A6ABD1A54E: '强属性 %0 的现有实例变量 %1 不能为 %select{|__unsafe_unretained||__weak}2'
# 'existing instance variable %1 for strong property %0 may not be __weak'
HD554DEC7881B: '强属性 %0 的现有实例变量 %1 可能不能是 __weak'
# 'exit after writing aggregated data file'
H8BF29D13B0F2: '写入聚合数据文件后退出'
# 'expanding this definition of %0'
H5BA1B50B21D1: '展开 %0 的这个定义'
# 'expansion of date or time macro is not reproducible'
H816E771096AD: '日期或时间宏的展开结果不可重复'
# 'expansion of macro %0 requested here'
H97F2144252C9: '此处请求展开宏 %0'
# "expansion of predefined identifier '%0' to a string literal is a Microsoft extension"
H89888E84B8EB: "将预定义标识符 '%0' 扩展为字符串字面量是 Microsoft 扩展"
# 'expected "FILENAME" or <FILENAME>'
H6038B7E6D091: "期望 'FILENAME' 或 <FILENAME>"
# "expected #pragma pack parameter to be '1', '2', '4', '8', or '16'"
HA00C06644234: "#pragma pack参数应为 '1'、'2'、'4'、'8' 或 '16'"
# 'expected %0'
H1C2353E37609: '期望 %0'
# 'expected %0 at end of module'
H0F6B0905AE5F: '模块末尾期望 %0'
# "expected %0 in OpenMP clause '%1'"
HC79E103ACDFE: "在OpenMP子句 '%1' 中期望 %0"
# 'expected %0 or %1'
HC08F459555DA: '期望 %0 或 %1'
# 'expected %0 to denote end of parameters, or, another valid parameter of %1'
H05DB43940E29: '期望 %0 表示参数结束，或 %1 的另一个有效参数'
# 'expected %0; %1 is a keyword in Objective-C++'
H62A445966708: '期望 %0; %1 是Objective-C++中的关键字'
# 'expected %1 after %0'
H5879CE8F4818: '在 %0 之后期望 %1'
# "expected %select{'enable', 'disable', 'begin' or 'end'|'disable'}0 - ignoring"
H1B18CF6CA096: "期望 %select{'enable', 'disable', 'begin' 或 'end'|'disable'}0 - 忽略"
# "expected %select{'match'|'match', 'adjust_args', or 'append_args'}0 clause on 'omp declare variant' directive"
HED7B3D66D419: "期望 %select{'match'|'match', 'adjust_args' 或 'append_args'}0 子句在 'omp declare variant' 指令上"
# "expected %select{'val' modifier|one of 'ref', val' or 'uval' modifiers}0"
HCC26F8F297FB: "期望 %select{'val' 修饰符|'ref', 'val' 或 'uval' 修饰符之一}0"
# 'expected %select{assignment|assignment, compound assignment, increment, or decrement}0 expression'
H2BC7EE32B904: '期望%select{赋值|赋值、复合赋值、递增或递减}0表达式'
# "expected %select{identifier after '.' in |}0module name"
HF095089F6D4D: '期望 %select{.后的标识符|}0 模块名称'
# 'expected %select{identifier|unqualified-id}0'
HC1969BE019B7: '期望%select{标识符|未限定的标识符}0'
# 'expected %select{library|framework}0 name as a string'
H5FD987168935: '期望%select{库|框架}0名称作为字符串'
# "expected %select{module exclusion with 'exclude'|'export *'}0"
H4175E9BAE37D: "期望%select{带有 'exclude' 的模块排除|'export *'}0"
# "expected '#pragma omp end declare %select{target|variant}0'"
H7B3C6216417A: "期望 '#pragma omp end declare %select{target|variant}0'"
# "expected '#pragma omp end declare target' at end of file to match '#pragma omp %0'"
H25BEC71CAA92: "期望在文件末尾有 '#pragma omp end declare target' 来匹配 '#pragma omp %0'"
# "expected '#pragma unused' argument to be a variable name"
HE4429A749432: "'#pragma unused' 参数应为变量名"
# "expected '%0' after the %1; '%0' assumed"
HB08F71D9B939: "在 %1 之后期望 '%0'；假设了 '%0'"
# "expected '%0' clause with an argument on '#pragma omp %1' construct"
HA803E7993B4F: "在 '#pragma omp %1' 结构中期望带参数的 '%0' 子句"
# "expected '(' after '%0'"
HA365863454FD: "在 '%0' 后期望 '('"
# "expected '(' for function-style cast or type construction"
H95D0E6661AB2: "期望 '(' 用于函数式类型转换或类型构造"
# "expected ')' after '%0'"
H068274655B04: "在 '%0' 后期望 ')'"
# "expected ')' in preprocessor expression"
H9FA29BAED1EF: "预处理表达式中期望 ')'"
# "expected ')' or ',' after '%0'"
HD115318388CA: "在 '%0' 后期望 ')' 或 ','"
# "expected ')' or ',' in '#pragma %0'"
H97FBD869E75F: "在 '#pragma %0' 中期望 ')' 或 ','"
# "expected '+' or '-' operation"
H193C159A95C7: "期望 '+' 或 '-' 操作"
# "expected ',' after conflicting module name"
H307B5FE6EEA1: "在冲突模块名后期望 ','"
# "expected ',' after interop modifier"
HBE15766F267C: "在互操作修饰符后期望 ','"
# "expected ',' in '#pragma %0'"
H80B3D004C35A: "在 '#pragma %0' 中期望 ','"
# "expected ',' or ')' after iterator specifier"
H5B885E53A966: "在迭代器说明符后期望 ',' 或 ')'"
# "expected ',' or ')' at end of property accessor list"
H90761748BDB7: "在属性存取器列表末尾期望 ',' 或 ')'"
# "expected ',' or ')' in '%0' %select{clause|directive}1"
H27E43F9D4E4C: "在 '%0' %select{子句|指令}1中期望 ',' 或 ')'"
# "expected ',' or '>' in template-parameter-list"
HE6FA48C9A81A: "在模板参数列表中期望 ',' 或 '>'"
# "expected ',' or ']' in lambda capture list"
H01C14BB9E6E5: 'lambda捕获列表中期望 "," 或 "]"'
# "expected '->' before expression type requirement"
H25053402E92B: '在表达式类型要求前期望 "->"'
# "expected '.' after pragma attribute namespace %0"
H6D0DBF9112AD: '在pragma属性命名空间 %0 后期望 "."'
# "expected '::' after '__super'"
HFBD8EE4CC424: '在 "__super" 后期望 "::"'
# "expected ';' after %0 statement"
H26F61B7787AD: '"%0 语句后期望 ";"'
# "expected ';' after '%0'"
HC22BB7A01636: "期望在 '%0' 后有 ';'"
# "expected ';' after attribute list"
HC367299E9BFD: "期望在属性列表后有 ';'"
# "expected ';' after expression"
H26209FD52998: "期望在表达式后有 ';'"
# "expected ';' after method prototype"
H4DCD5C7E2BCB: "期望在方法原型后有 ';'"
# "expected ';' after module name"
H20B27913626E: "期望在模块名后有 ';'"
# "expected ';' after namespace name"
HAAD5C65924B6: "期望在命名空间名后有 ';'"
# "expected ';' after private module fragment declaration"
H868380AB5A37: "期望在私有模块片段声明后有 ';'"
# "expected ';' after top level declarator"
H3A247DA7CE56: "期望在顶层声明符后有 ';'"
# "expected ';' at end of declaration"
HA8E976B320DC: "期望在声明结尾处有 ';'"
# "expected ';' at end of declaration list"
HA684210D419F: "期望在声明列表结尾处有 ';'"
# "expected ';' at end of requirement"
HDCCCFEC70AB1: "期望在约束条件结尾处有 ';'"
# "expected ';' in 'for' statement specifier"
H2C47358FD75D: "期望在 'for' 语句说明符中有 ';'"
# "expected '<' after '%0'"
H1010291C9C7B: "期望在 '%0' 后有 '<'"
# "expected '= constant-expression' or end of enumerator definition"
H01AC9A3D13F6: "期望'= 常量表达式'或枚举器定义结束"
# "expected '=' after '%0'"
H46EA9025A033: "期望在 '%0' 后有 '='"
# "expected '=' after diagnostic option"
HEF7733E47109: "在诊断选项后期望 '=' 符号"
# "expected '=' following '#pragma %select{align|options align}0' - ignored"
HCE08A9B54E2F: "在 '#pragma %select{align|options align}0' 后期望 '=' 符号 - 已忽略"
# "expected '=' following '#pragma clang section %select{invalid|bss|data|rodata|text|relro}0'"
H5BC8FFE8057E: "在 '#pragma clang section %select{invalid|bss|data|rodata|text|relro}0' 后期望 '=' 符号"
# "expected '=' for Objective-C getter"
H60371309B60A: "Objective-C getter 需要 '=' 符号"
# "expected '=' for Objective-C setter"
H8ACB8C307A32: "Objective-C setter 需要 '=' 符号"
# "expected '=' in iterator specifier"
H160A5CC58E68: "迭代器说明符中期望 '=' 符号"
# "expected '=' or another designator"
H0EFFC0B249A7: "期望 '=' 或另一个说明符"
# "expected '==' operator for 'weak' clause"
H3CB2580D57FE: "'weak' 子句期望 '==' 操作符"
# "expected 'ON' or 'OFF' or 'DEFAULT' in pragma"
HE0167BADEC73: '在pragma中期望 "ON"、"OFF" 或 "DEFAULT"'
# "expected ']' to close attribute"
H21FBE19AC5CE: "期望 ']' 来关闭属性"
# "expected '__except' or '__finally' block"
HF5A94EBD6434: "期望 '__except' 或 '__finally' 块"
# "expected 'align' following '#pragma options' - ignored"
H851698FD662C: "在 '#pragma options' 后期望 'align' - 已忽略"
# "expected 'auto' or 'decltype(auto)' after concept name"
H0C6E25C16A3C: "在概念名称后期望 'auto' 或 'decltype(auto)'"
# "expected 'begin' or 'end'"
HE7122B95D2E3: "期望 'begin' 或 'end'"
# "expected 'bind' clause for 'loop' construct without an enclosing OpenMP construct"
H5C3B8520C88C: "期望在没有包含的OpenMP结构时，'loop' 结构使用 'bind' 子句"
# "expected 'case' keyword before expression"
H2E3235608C64: "在表达式前期望 'case' 关键字"
# "expected 'compare' clause with the '%0' modifier"
H19AACB74DA99: "期望带有 '%0' 修饰符的 'compare' 子句"
# "expected 'compiler', 'lib', 'user', or a string literal for the section name in '#pragma %0' - ignored"
H516A6D363B4D: "在 '#pragma %0' 的段名称中期望 'compiler'、'lib'、'user' 或字符串字面量 - 已忽略"
# "expected 'get' or 'put' in property declaration"
HB1588A447E94: "在属性声明中期望 'get' 或 'put'"
# "expected 'introduced', 'deprecated', or 'obsoleted'"
HA5AD3805D7B0: "期望 'introduced'、'deprecated' 或 'obsoleted'"
# "expected 'language', 'defined_in', 'generated_declaration', or 'USR'"
HC6089B1E2A7C: "期望 'language'、'defined_in'、'generated_declaration' 或 'USR'"
# "expected 'push', 'pop', or '(' after '#pragma clang attribute'"
H6F226585166A: "在 '#pragma clang attribute' 后期望 'push'、'pop' 或 '('"
# "expected 'reduction' clause with the 'inscan' modifier"
H2220AF809CD1: "带有 'inscan' 修饰符的 'reduction' 子句期望出现"
# "expected 'this' following '*' in lambda capture list"
HAD95524E40D1: "在 lambda 捕获列表中 '*' 后期望 'this'"
# "expected 'this' subscript expression on map clause to be 'this[0]'"
HC4A77B8603BE: "在 map 子句中的 'this' 下标表达式应为 'this[0]'"
# "expected 'volatile', 'inline', 'goto', or '('"
H4AA4A0DEF946: "期望 'volatile'、'inline'、'goto' 或 '('"
# "expected 'while' in do/while loop"
H93A6CFE12887: "在 do/while 循环中期望 'while'"
# "expected '{' after '\\%0' escape sequence"
H8BB332D21D67: "在 '\\%0' 转义序列后期望 '{'"
# "expected '{' after base class list"
HF135F437918B: "在基类列表后期望 '{'"
# "expected '{' in compound literal"
H19B6D0E23043: "复合字面量中期望 '{'"
# "expected '{' to start inferred submodule"
H195C51C6292B: "期望 '{' 开始推导的子模块"
# "expected '{' to start module '%0'"
H68A4A0E12840: "期望 '{' 开始模块 '%0'"
# "expected '}'"
HC6CF963022AD: "期望 '}'"
# 'expected HLSL Semantic identifier'
H26323C15C7D3: '期望 HLSL 语义标识符'
# 'expected OpenACC directive'
HC6E13DDCDF20: '期望 OpenACC 指令'
# "expected a 'float', 'double' or '__float128' for the first argument"
H4A7F993B766C: "第一个参数期望 'float'、'double' 或 '__float128'"
# 'expected a callable expression as %ordinal0 argument to %1, found %2'
H9D110F1CBE18: '期望 %1 的第 %ordinal0 个参数为可调用表达式，但找到 %2'
# 'expected a clang compiler command'
HFF7E5AC24A63: '期望 clang 编译命令'
# "expected a class method selector with single argument, e.g., 'colorWithCGColor:'"
H747F5E4807D4: "期望带有单个参数的类方法选择器，例如 'colorWithCGColor:'"
# "expected a class name after '~' to name a destructor"
H0B5DBF4FC4A5: "在 '~' 后期望类名以命名析构函数"
# 'expected a feature name'
H83F9EEF32768: '需要一个功能名称'
# "expected a field designator, such as '.field = 4'"
HE811DCDC9E5C: "期望一个字段指定符，例如 '.field = 4'"
# 'expected a foldable binary operator in fold expression'
H442801240371: '折叠表达式中需要一个可折叠的二元操作符'
# "expected a for, while, or do-while loop to follow '%0'"
H6905E348753C: "在 '%0' 之后需要跟随一个for、while 或 do-while 循环"
# "expected a header attribute name ('size' or 'mtime')"
H7FCC0389B837: "期望一个头文件属性名称（如 'size' 或 'mtime'）"
# "expected a header name after '%0'"
HC5548A9AEA32: "在 '%0' 之后需要指定一个头文件名称"
# 'expected a memory order clause'
H8A1509342CF4: '需要一个内存顺序子句'
# "expected a message describing the conflict with '%0'"
H3712B62CAC8D: "需要描述与 '%0' 冲突的说明信息"
# 'expected a module map file name'
H34A1748EFBBA: '需要一个模块映射文件名称'
# "expected a module name after '%select{module|import}0'"
H60B4E74C4DAA: "在 '%select{module|import}0' 之后期望一个模块名称"
# "expected a module name in '__building_module' expression"
H3E7D4309A80A: "在 '__building_module' 表达式中需要一个模块名称"
# "expected a module name or '*'"
HA872E74CF2C8: "需要一个模块名称或 '*'"
# 'expected a platform name here'
HB3E385166F04: '此处需要一个平台名称'
# "expected a platform name, e.g., 'macos'"
H451496142CA8: "期望一个平台名称，例如 'macos'"
# 'expected a property name in @synthesize'
HFCD01091BCD1: "'@synthesize' 中需要指定属性名称"
# "expected a qualified name after 'typename'"
H3D60DB7C4A2E: "在 'typename' 之后需要一个限定名称"
# "expected a reference to a parameter specified in a 'uniform' clause"
HE4C3AD103D8E: "期望 'uniform' 子句中指定的参数的引用"
# 'expected a reference to an integer-typed parameter'
HD574D7423FC7: '需要一个指向整型参数的引用'
# "expected a related Objective-C class name, e.g., 'NSColor'"
H1B15D42F8530: "期望一个相关的Objective-C类名，例如 'NSColor'"
# "expected a stack label or a string literal for the section name in '#pragma %0' - ignored"
HC98188AB663C: "在 '#pragma %0' 中期望一个栈标签或字符串字面量作为段名称 - 已忽略"
# "expected a string literal for the section name in '#pragma %0' - ignored"
HE785ABE9BD3E: "在 '#pragma %0' 中期望段名称的字符串字面量 - 已忽略"
# 'expected a type'
HBF18848DB5D9: '期望一个类型'
# "expected a version of the form 'major[.minor[.subminor]]'"
HD227DA64159B: "期望格式为 'major[.minor[.subminor]]' 的版本号"
# 'expected access to data field'
HB984B4DED1F3: '期望访问数据字段'
# "expected action or ')' in '#pragma %0' - ignored"
HA826DA8C7E15: "在 '#pragma %0' 中期望操作或 ')' - 已忽略"
# "expected addressable lvalue expression, array element%select{ or array section|, array section or array shaping expression}0%select{| of non 'omp_depend_t' type}1"
H064E98F2C05F: "期望可寻址的左值表达式%select{ 或数组切片|, 数组切片或数组成形表达式}0%select{|的非 'omp_depend_t' 类型}1"
# "expected addressable lvalue in '%0' clause"
H5CFFB735C83B: "'%0' 子句中需要可寻址的左值表达式"
# 'expected addressable reduction item for the task-based directives'
H317F6E6ED5F4: '任务导向指令需要可寻址的规约项'
# "expected an 'allocator' clause inside of the target region; provide an 'allocator' clause or use 'requires' directive with the 'dynamic_allocators' clause"
H22C155652414: "目标区域内部期望 'allocator' 子句；请提供 'allocator' 子句或在 'requires' 指令中使用 'dynamic_allocators' 子句"
# "expected an Objective-C directive after '@'"
H89CC9A1752F3: "在 '@' 后期望 Objective-C 指令"
# "expected an OpenMP 'directive' or 'sequence' attribute argument"
HB4C47A9C1389: "期望 OpenMP 'directive' 或 'sequence' 属性参数"
# 'expected an OpenMP directive'
H633B99B897DC: '期望 OpenMP 指令'
# "expected an allocator expression inside of the target region; provide an allocator expression or use 'requires' directive with the 'dynamic_allocators' clause"
H3E40EF451DD7: "目标区域内部期望分配器表达式；请提供分配器表达式或在 'requires' 指令中使用 'dynamic_allocators' 子句"
# "expected an attribute after '('"
H1D3F08841FED: "期望 '(' 后面的属性"
# 'expected an attribute name'
HD93294E62460: '期望属性名称'
# "expected an attribute that is specified using the GNU, C++11 or '__declspec' syntax"
H022D0FCF0401: "期望使用 GNU、C++11 或 '__declspec' 语法指定的属性"
# "expected an environment name, e.g., 'compute'"
HFC224EAC2A19: "期望环境名称，例如 'compute'"
# "expected an identifier or template-id after '::'"
H640FB5DADE2C: ':: 后期望标识符或模板标识符'
# "expected an identifier that corresponds to an attribute subject matcher sub-rule; '%0' matcher %select{does not support sub-rules|supports the following sub-rules: %2|}1"
H9C057C572CE2: "期望与属性对象匹配子规则对应的标识符；'%0' 匹配器 %select{不支持子规则|支持以下子规则: %2|}1"
# 'expected an identifier that corresponds to an attribute subject rule'
H294E4D252009: '期望与属性对象规则对应的标识符'
# "expected an integer argument in '#pragma %0'"
H8B88B2FBB6B4: "在 '#pragma %0' 中期望整数参数"
# "expected an integer or a pointer type of the outer loop counter '%0' for non-rectangular nests"
H7B769AB4785B: "在非矩形嵌套中，外层循环计数器 '%0' 的类型应为整数或指针类型"
# "expected at least one %0 clause for '#pragma omp %1'"
H7235197EF029: "在 '#pragma omp %1' 中期望至少一个 %0 子句"
# "expected at least one %select{'enter' or 'link'|'enter', 'link' or 'indirect'}0 clause"
H068B5F15FD0D: "期望至少一个 %select{'enter' 或 'link'|'enter', 'link' 或 'indirect'}0 子句"
# "expected at least one %select{'to' or 'link'|'to', 'link' or 'indirect'}0 clause"
HCCB831884601: "期望至少一个 %select{'to' 或 'link'|'to', 'link' 或 'indirect'}0 子句"
# "expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'"
HD1F834BB93F7: "在 '#pragma omp target update' 中需要指定至少一个 'to' 子句或 'from' 子句"
# "expected at least one clause on '#pragma omp %0' directive"
HF2F95AA7B57B: "在 '#pragma omp %0' 指令中需要至少一个子句"
# "expected attribute subject set specifier 'apply_to'"
H235FBF52B9D6: "期望属性对象设置说明符 'apply_to'"
# 'expected binary operation on right hand side of assignment operator'
H56333C6C1143: '期望赋值运算符右侧存在二元操作'
# 'expected body of lambda expression'
HD20C4511EEC4: '期望lambda表达式体'
# "expected canonical name for private module '%0'"
H1D8AC0E6D7DF: "期望私有模块 '%0' 的规范名称"
# 'expected catch'
H0CF63E912EE1: '期望catch'
# 'expected class member or base class name'
H3D5CC6CC3E58: '期望类成员或基类名称'
# 'expected class name'
HE76725D4157E: '期望类名'
# 'expected clause-list or newline in OpenACC directive'
H545847ADF7FD: '期望在OpenACC指令中指定子句列表或换行符'
# 'expected comma in macro parameter list'
HDA341FE611DA: '期望宏参数列表中的逗号'
# 'expected concept name with optional arguments'
H5D07B2CBA3F4: '期望带有可选参数的概念名称'
# "expected configuration macro name after ','"
HAB95DA27DF2F: '期望逗号后的配置宏名称'
# "expected constant sized array of 'omp_alloctrait_t' elements, not %0"
H05FAEDD71E4D: "期望 'omp_alloctrait_t' 元素的固定大小数组，而非 %0"
# "expected declarator on 'omp declare mapper' directive"
HB22F9750894D: "期望 'omp declare mapper' 指令中的说明符"
# 'expected depobj expression'
HE3D01E0D4DF5: '期望依赖对象表达式'
# 'expected end of directive in pragma'
HCC93595992BD: '在pragma中期望指令结束'
# 'expected end of line in preprocessor expression'
HD41DF7404CF0: '期望在预处理器表达式末尾换行'
# 'expected excluded module name'
H6CF70735EF8C: '期望排除的模块名称'
# 'expected expression'
HF6BF3F627CA1: '期望表达式'
# 'expected expression containing only member accesses and/or array sections based on named variables'
HB19E72D8D293: '期望仅包含基于命名变量的成员访问和/或数组切片的表达式'
# 'expected expression with a pointer to a complete type as a base of an array shaping operation'
HB89169C408E0: '期望作为数组塑形运算基础的指向完整类型的指针表达式'
# 'expected external declaration'
HC14A3D6A28C9: '期望外部声明'
# 'expected function body after function declarator'
HF961A21CDC61: '函数说明符后需跟函数主体'
# "expected function or lambda declaration for 'routine' construct"
H6E72FAB495F6: "期望为 'routine' 结构声明函数或lambda表达式"
# "expected identifier in '#pragma %0' - ignored"
H05B1FBF9EBC9: '在 "#pragma %0" 中期望标识符 - 被忽略'
# 'expected identifier in macro parameter list'
H94E463CD5EE5: '宏参数列表中期望标识符'
# "expected identifier or one of the following operators: '+', '-', '*', '&', '|', '^', '&&', or '||'"
H7E170CC2FF20: "期望标识符或以下运算符之一：'+', '-', '*', '&', '|', '^', '&&', 或 '||'"
# 'expected identifier or string literal describing a context %select{set|selector|property}0; %select{set|selector|property}0 skipped'
HE89AF4D1E70E: '期望描述上下文%select{集合|选择器|属性}0的标识符；%select{集合|选择器|属性}0被跳过'
# "expected identifier or string literal in OpenACC 'bind' clause"
H5985E2854824: "在OpenACC 'bind' 子句中期望标识符或字符串字面量"
# "expected identifier specifying the name of the 'omp critical' directive"
HDAF324FC0746: '期望OpenMP critical指令的名称标识符'
# 'expected identifier that represents an attribute name'
H4FF5B028471D: '期望表示属性名称的标识符'
# 'expected initializer'
HC06E564F6549: '期望初始化器'
# "expected integer between %0 and %1 inclusive in '#pragma %2' - ignored"
HD3B45551DCCD: '在 "#pragma %2" 中期望 %0 到 %1 之间的整数（含边界） - 被忽略'
# "expected integer literal as value for header attribute '%0'"
H664A6DF4E15C: "期望头属性 '%0' 的值为整数字面量"
# "expected integer or identifier in '#pragma pack' - ignored"
H76DF3F452A3B: '在 "#pragma pack" 中期望整数或标识符 - 被忽略'
# 'expected integral or pointer type as the iterator-type, not %0'
H630D7FF60D9F: '期望迭代器类型为整型或指针类型，而非 %0'
# "expected interop type: 'target' and/or 'targetsync'"
H4B471B15641F: "期望互操作类型：'target' 和/或 'targetsync'"
# 'expected iterator specification as depend modifier'
HDCFF4384248D: '期望将迭代器说明用作 depend 修饰符'
# 'expected iterator specification as map modifier'
H1207336B4021: '期望将迭代器说明用作 map 修饰符'
# "expected length on mapping of 'this' array section expression to be '1'"
HAB830A5B0BE8: "期望将 'this' 数组区域表达式的映射长度设置为 '1'"
# "expected list item of scalar type in 'lastprivate' clause with 'conditional' modifier"
HA9ADDE114CE9: "在带有 'conditional' 修饰符的 'lastprivate' 子句中，期望标量类型的列表项"
# 'expected loop invariant expression'
H5CDAE0534BDA: '期望循环不变表达式'
# "expected loop invariant expression or '<invariant1> * %0 + <invariant2>' kind of expression"
HB9C142C1B0A5: '期望循环不变表达式或类似 "<invariant1> * %0 + <invariant2>" 形式的表达式'
# "expected lower bound on mapping of 'this' array section expression to be '0' or not specified"
H191C7ACE16C2: "期望将 'this' 数组区域表达式的映射下界设为 '0' 或未指定"
# "expected lvalue expression%select{ of 'omp_depend_t' type, not %1|}0"
H766F59D547C6: "期望左值表达式%select{ 类型为 'omp_depend_t'，而非 %1|}0"
# "expected member name or ';' after declaration specifiers"
HB82CEE80D58C: "在声明说明符之后期望成员名称或 ';' "
# "expected member name or ';' after declaration specifiers; %0 is a keyword in Objective-C++"
H44CFB0200081: "在声明说明符之后期望成员名称或 ';' ；%0 是 Objective-C++ 中的关键字"
# 'expected method body'
HA77E865AEFEF: '期望方法体'
# 'expected method to %select{read|write}1 %select{dictionary|array}2 element not found on object of type %0'
H7AD9AA6CC51A: '在类型 %0 的对象上未找到用于 %select{读取|写入}1 %select{字典|数组}2 元素的方法'
# "expected modifier in '%0' clause"
HCD7B280DF3B2: "在 '%0' 子句中期望修饰符"
# 'expected module declaration'
H01C99835EAB8: '期望模块声明'
# 'expected module name'
H1C43BA17D195: '期望模块名称'
# 'expected name of accessor method'
HC25216EA2EAE: '期望访问器方法的名称'
# 'expected namespace name'
H4C29A4057DC9: '期望命名空间名称'
# "expected non-wide string literal in '#pragma %0'"
H47A50F5F135C: "在 '#pragma %0' 中期望非宽字符字面量字符串"
# "expected one of [bss|data|rodata|text|relro] section kind in '#pragma %0'"
HD85488A58A29: "在 '#pragma %0' 中期望以下之一的段类型：[bss|data|rodata|text|relro] section kind"
# "expected one of the predefined allocators for the variables with the static storage: 'omp_default_mem_alloc', 'omp_large_cap_mem_alloc', 'omp_const_mem_alloc', 'omp_high_bw_mem_alloc', 'omp_low_lat_mem_alloc', 'omp_cgroup_mem_alloc', 'omp_pteam_mem_alloc' or 'omp_thread_mem_alloc'"
H8611A8451129: "具有静态存储的变量期望预定义的分配器之一：'omp_default_mem_alloc', 'omp_large_cap_mem_alloc', 'omp_const_mem_alloc', 'omp_high_bw_mem_alloc', 'omp_low_lat_mem_alloc', 'omp_cgroup_mem_alloc', 'omp_pteam_mem_alloc' 或 'omp_thread_mem_alloc'"
# 'expected parameter declarator'
HE400FE627646: '期望参数声明符'
# 'expected parentheses around type name in %0 expression'
H29C3C3BEE053: '在 %0 表达式中期望类型名称周围的括号'
# "expected parenthesized parameter pack name in 'sizeof...' expression"
H872448706A49: "在 'sizeof...' 表达式中期望括号括起的参数包名称"
# "expected pointer in '%0' clause, type is %1"
HA28C1D2864FB: "在 '%0' 子句中期望指针，类型为 %1"
# "expected pointer or reference to pointer in 'use_device_ptr' clause"
H8CE170DA7DFD: "在 'use_device_ptr' 子句中期望指针或引用到指针"
# 'expected pointer to struct as %ordinal0 argument to %1, found %2'
H2E1D0CCC5B02: '期望 %1 的%ordinal0参数是指向结构的指针，但找到的是 %2'
# "expected pointer, array, reference to pointer, or reference to array in 'is_device_ptr clause'"
H529E9DB350DF: "在'is_device_ptr子句中期望指针、数组、指向指针的引用或指向数组的引用"
# 'expected property name'
H849B19CD5A49: '期望属性名称'
# "expected push, pop or a string literal for the section name in '#pragma %0' - ignored"
H4F1921BA3641: "在 '#pragma %0' 中期望push、pop或段名字符串字面量 - 忽略"
# 'expected quoted string after equals sign'
H2D60229D01D0: '在等号后面期望字符串字面量'
# "expected reference to one of the parameters of function %0%select{| or 'this'}1"
HD78611AD5D12: "期望函数 %0%select{|或 'this'}1 的参数之一的引用"
# 'expected selector for Objective-C %select{setter|getter}0'
HFB2F00048645: 'Objective-C %select{设置器|获取器}0期望选择器'
# 'expected selector for Objective-C method'
HC4CCDD47D676: 'Objective-C方法期望选择器'
# 'expected statement'
HFEEF58AA5565: '期望语句'
# "expected string literal %select{in %1|for diagnostic message in static_assert|for optional message in 'availability' attribute|for %select{language name|source container name|USR}1 in 'external_source_symbol' attribute|as argument of '%1' attribute}0"
HD61709E5D47F: "期望字符串字面量 %select{在 %1 中|在static_assert的诊断消息中|在 'availability' 属性的可选消息中|在 'external_source_symbol' 属性的%select{语言名称|源容器名称|USR}1 中|作为 '%1' 属性的参数}0"
# "expected string literal %select{or parenthesized constant expression |}0in 'asm'"
H87FD9C867F0C: "在 'asm' 中期望字符串字面量 %select{或括号内的常量表达式 |}0"
# "expected string literal in '#pragma %0' - ignoring"
H0A31A7BE2E40: "在 '#pragma %0' 中期望字符串字面量 - 忽略"
# "expected string literal in 'clause %0' - ignoring"
H25BCA649E0CB: "在 'clause %0' 子句中期望字符串字面量 - 忽略"
# 'expected template'
H15B15916EEBA: '期望模板'
# "expected template name after 'template' keyword in nested name specifier"
H49E8E5AAE6BB: "在嵌套名称限定符中的 'template' 关键字后期望模板名称"
# 'expected template parameter'
H112129FF4EB6: '期望模板参数'
# "expected the class name after '~' to name the enclosing class"
HD0B1F9262E8D: "期望在 '~' 之后给出封闭类的类名"
# 'expected the name of a parameter pack'
H259207509382: '期望参数包的名称'
# 'expected type parameter name'
H009E83554F48: '期望类型参数名称'
# 'expected umbrella, header, submodule, or module export'
H13F866613F7D: '表达式中期望值'
# 'expected valid context selector in %0'
HF9402AD88CE1: '在 %0 中期望有效的上下文选择器'
# 'expected value in expression'
HC052EF0BAA44: "期望变量名或 'this' 在lambda捕获列表中"
# 'expected variable name as a base of the array %select{subscript|section}0'
HBE410C345F41: '期望变量名 %select{|或当前类的数据成员}0'
# "expected variable name or 'this' in lambda capture list"
H9A94F049DF94: "在lambda捕获列表中期望变量名称或 'this'"
# 'expected variable name%select{| or data member of current class}0'
H829F4F463842: '期望变量名 %select{|或当前类的数据成员}0'
# 'expected variable name%select{|, data member of current class}0, array element or array section'
HEAE159C816D1: '期望变量名 %select{|、当前类的数据成员}0、数组元素或数组切片'
# 'expected variable of pointer type'
H396A94544855: '期望指针类型的变量'
# "expected variable of the '%0' type%select{|, not %2}1"
H3293A68C1535: "期望类型为 '%0' 的变量 %select{|，而非 %2}1"
# "expected variable%select{| or static data member|, static data member, or non-static data member of current class}0 of type '%1'"
H54FC8A6038F8: "期望类型为 '%1' 的变量 %select{|或静态数据成员|、静态数据成员或当前类的非静态数据成员}0"
# 'expected%select{| %1}0 loop iteration variable'
H9F489F0C181E: '期望 %select{| %1}0 循环迭代变量'
# "expected%select{| non-const}0 variable of type 'omp_interop_t'"
H7FA31289BDF2: '期望 %select{|非const}0 类型为 omp_interop_t 的变量'
# 'expected%select{| one of}0 %1 directive name modifier%select{|s}0'
HF9EF92E2746A: '期望 %select{|一个}0 %1 指令名称修饰符 %select{|s}0'
# "expecting %0 '%1' to be held at start of each loop%select{| with equal reentrancy depth}2"
HB151B2C16229: "期望 %0'%1' 在每次循环开始时被持有 %select{|且具有相同的重入深度}2"
# "expecting %0 '%1' to be held at the end of function"
H696ED076811B: "期望在函数结尾保持 %0 '%1'"
# 'expecting a pointer argument to the generic address space'
HA58F994AB425: '期望指向泛型地址空间的指针参数'
# 'explicit %select{constructor|conversion function|deduction guide}0 is not a candidate%select{| (explicit specifier evaluates to true)}1'
H1B61513FD8B6: '显式 %select{构造函数|转换函数|推导指引}0 不是候选 %select{|（显式说明符计算为true）}1'
# 'explicit %select{constructor|deduction guide}0 declared here'
H110462FEE829: '显式 %select{构造函数|推导指引}0 在此处声明'
# 'explicit %select{specialization|instantiation}0 of %select{non-|undeclared }3template %1 %2'
H3111D59957AC: '%select{非-|未声明 }3模板 %1 %2 的 %select{显式特化|实例化}0'
# 'explicit call to +initialize results in duplicate call to +initialize'
H39AD5352EF13: '显式调用 +initialize 将导致对 +initialize 的重复调用'
# 'explicit call to [super initialize] should only be in implementation of +initialize'
H9E99F53BFF8C: '显式调用 [super initialize] 应仅在 +initialize 的实现中使用'
# "explicit capture of 'this' with a capture default of '=' is a C++20 extension"
HAF0F203BEF2F: "在捕获默认值为 '=' 时显式捕获 'this' 是 C++20 扩展"
# "explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++20"
H671AAB21DB7A: "在捕获默认值为 '=' 时显式捕获 'this' 与 C++20 之前的 C++ 标准不兼容"
# 'explicit constructor calls are a Microsoft extension'
H07E486E825A8: '显式构造函数调用是 Microsoft 扩展'
# 'explicit conversion functions are a C++11 extension'
H6D402C6A81B4: '显式转换函数是 C++11 扩展'
# 'explicit conversion functions are incompatible with C++98'
H325DB8CE82A7: '显式转换函数与 C++98 不兼容'
# 'explicit data sharing attribute requested here'
HC278594BF276: '此处请求显式数据共享属性'
# 'explicit data sharing attribute, data mapping attribute, or is_device_ptr clause requested here'
H5EF926721360: '此处请求显式数据共享属性、数据映射属性或 is_device_ptr 子句'
# 'explicit initialization of field %1 will not be enforced in C++20 and later because %2 has a user-declared constructor, making the type no longer an aggregate'
HF3AC30340626: '在 C++20 及以后版本中，字段 %1 的显式初始化将不再被强制执行，因为 %2 具有用户声明的构造函数，使得该类型不再为聚合类型'
# 'explicit instantiation candidate function %q0 template here %1'
H23B5BDCD19CC: '显式实例化候选函数 %q0 模板定义在此处 %1'
# "explicit instantiation cannot be 'constexpr'"
H9A1E5AE786E4: "显式实例化不能为 'constexpr'"
# "explicit instantiation cannot be 'inline'"
HD5DCEA693BA1: "显式实例化不能为 'inline'"
# 'explicit instantiation cannot have a storage class'
H2C3AA857F69D: '显式实例化不能具有存储类'
# "explicit instantiation declaration (with 'extern') follows explicit instantiation definition (without 'extern')"
HB1AC2FFED2CF: "显式实例化声明（带有 'extern'）跟随显式实例化定义（不带 'extern'）"
# 'explicit instantiation declaration of %0 with internal linkage'
HF062EFD01A1B: '具有内部链接性的 %0 的显式实例化声明'
# 'explicit instantiation declaration requires a name'
HB6C2B5BBA7F4: '显式实例化声明需要一个名称'
# "explicit instantiation declaration should not be 'dllexport'"
H2015D0FC9EDD: "显式实例化声明不应是 'dllexport'"
# 'explicit instantiation definition is here'
H296BCB0F591A: '显式实例化定义在这里'
# 'explicit instantiation has dependent template arguments'
H0CCD42687978: '显式实例化的模板参数依赖于模板参数'
# 'explicit instantiation of %0 does not refer to a function template, variable template, member function, member class, or static data member'
H33CB49EB02C6: '%0 的显式实例化不指向一个函数模板、变量模板、成员函数、成员类或静态数据成员'
# 'explicit instantiation of %0 in class scope'
HC730DBDD7AE4: '%0 的显式实例化在类作用域内'
# 'explicit instantiation of %0 must occur at global scope'
H0F240F08C055: '%0 的显式实例化必须出现在全局作用域'
# 'explicit instantiation of %0 not in a namespace enclosing %1'
HE49D377AF72F: '%0 的显式实例化不在包含 %1 的命名空间中'
# 'explicit instantiation of %0 that occurs after an explicit specialization has no effect'
HB36244473793: '在显式特化之后出现的 %0 的显式实例化无效'
# 'explicit instantiation of %q0 must occur in namespace %1'
HB00768729F8E: '%q0的显式实例化必须出现在命名空间 %1'
# 'explicit instantiation of %q0 must specify a template argument list'
HE88FD9250BA0: '%q0的显式实例化必须指定模板参数列表'
# 'explicit instantiation of non-templated type %0'
H31C2727CC2AA: '%0 的显式实例化是一个非模板类型'
# 'explicit instantiation of typedef %0'
H2C42F0D827C6: '%0 类型的显式实例化是一个typedef'
# 'explicit instantiation of undefined %select{member class|member function|static data member}0 %1 of class template %2'
HCF3C5A632D34: '类模板 %2 中未定义的%select{成员类|成员函数|静态数据成员}0 %1 的显式实例化'
# 'explicit instantiation of undefined function template %0'
H5300C0092131: '未定义的函数模板 %0 的显式实例化'
# 'explicit instantiation of undefined variable template %q0'
H38D285C06249: '未定义的变量模板%q0的显式实例化'
# 'explicit instantiation refers here'
HBCDCC7E0C7EF: '显式实例化指向此处'
# 'explicit instantiation refers to member function %q0 that is not an instantiation'
H500C2DC642A9: '显式实例化指向非实例化的成员函数%q0'
# 'explicit instantiation refers to static data member %q0 that is not an instantiation'
H07ED3DC3915D: '显式实例化引用了非实例化的静态数据成员%q0'
# "explicit object parameter cannot have 'void' type"
H5DECA4F1B2FA: "显式对象参数不能具有 'void' 类型"
# 'explicit object parameters are incompatible with C++ standards before C++2b'
H32F147DF3434: '显式对象参数与C++2b之前的C++标准不兼容'
# 'explicit ownership qualifier on cast result has no effect'
H3D013C01B086: '显式拥有权限定符对转换结果没有影响'
# 'explicit qualification required to use member %0 from dependent base class'
H469187ADD22A: '使用来自依赖基类的成员 %0 需要显式限定符'
# 'explicit specialization cannot have a storage class'
HADDD65B5ED76: '显式特例化不能有存储类'
# 'explicit specialization of %0 after instantiation'
HDBBF37665EBE: '在实例化之后对 %0 的显式特例化'
# 'explicit specialization of %0 in function scope'
H4AB8E368275F: '在函数作用域内对 %0 的显式特例化'
# "explicit template instantiation cannot have a definition; if this definition is meant to be an explicit specialization, add '<>' after the 'template' keyword"
H88A1F449C08B: "显式模板实例化不能有定义；如果此定义本意是显式特例化，请在 'template' 关键字后添加 '<>'"
# 'explicit template parameter list for lambdas is a C++20 extension'
HF9AE6F1B9252: 'lambda表达式中的显式模板参数列表是C++20扩展'
# 'explicit template parameter list for lambdas is incompatible with C++ standards before C++20'
H57BCAF2B0340: 'lambda表达式中的显式模板参数列表与C++20之前的C++标准不兼容'
# 'explicit(bool) is a C++20 extension'
H07C70F747BCD: 'explicit(bool)是C++20扩展'
# 'explicit(bool) is incompatible with C++ standards before C++20'
H2A0E673F4AE0: 'explicit(bool)与C++20之前的C++标准不兼容'
# 'explicitly assigning value of variable of type %0 to itself%select{|; did you mean to assign to member %2?}1'
HB1C6DD04C662: '显式地将类型 %0 变量的值赋给自己 %select{|; 是否应将成员 %2 赋值？}1'
# "explicitly capture 'this'"
HCF140BF35536: "显式捕获 'this'"
# 'explicitly cast the argument to size_t to silence this warning'
HBB0D273571B1: '将参数显式转换为size_t以消除此警告'
# 'explicitly cast the pointer to silence this warning'
H8E24FB4D1062: '将指针显式转换以消除此警告'
# "explicitly declare getter %objcinstance0 with '%1' to return an 'unowned' object"
H4E2F7B8127D2: "使用 '%1' 显式声明返回 'unowned' 对象的getter %objcinstance0"
# 'explicitly defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator is implicitly deleted'
H811330B8F313: '显式默认的 %select{<ERROR>|相等|三向|相等|关系}0比较运算符被隐式删除'
# 'explicitly defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 is implicitly deleted'
H4A686915F9DC: '显式默认的%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}0被隐式删除'
# 'explicitly defaulted function was implicitly deleted here'
HF8EF8D3E0A6F: '显式默认的函数在此处被隐式删除'
# 'explicitly defaulting this %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 with a type different from the implicit type is incompatible with C++ standards before C++20'
H5E5EF3FDD4E3: '使用与隐式类型不同的类型显式默认%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}0与C++20之前的C++标准不兼容'
# 'explicitly moving variable of type %0 to itself%select{|; did you mean to move to member %2?}1'
H35CC5A2B002D: '显式将类型 %0 的变量移动到自身 %select{|; 是否应移动到成员 %2？}1'
# 'explicitly specialized declaration is here'
H0E01C428C014: '显式特化声明在此处'
# 'explicitly-defaulted %select{copy|move}0 assignment operator must return %1'
H36FB5B74F68A: '显式默认的%select{拷贝|移动}0赋值运算符必须返回 %1'
# 'exponent has no digits'
H17C521E1F810: '指数没有数字'
# 'export block begins here'
HBA4BC250A89B: '导出块从此处开始'
# 'export declaration appears within anonymous namespace'
H2CCBA9D1C7AA: '导出声明出现在匿名命名空间内'
# 'export declaration appears within another export declaration'
HECEB46AE53AF: '导出声明出现在另一个导出声明内部'
# 'export declaration can only be used on functions'
H2A1BE3778EEF: '导出声明仅可用于函数'
# 'export declaration can only be used within a module purview'
HA59173758635: '导出声明仅可在模块作用域内使用'
# 'export declaration cannot be empty'
H571FAB6A011E: '导出声明不能为空'
# 'export declaration cannot be used in a private module fragment'
H22322B0D3EA4: '导出声明不能用于私有模块片段'
# 'exported templates are unsupported'
H6166D4F14CA1: '导出模板不受支持'
# 'expose the ANDI glue bug on PPC'
HC579FD8E0F1D: '在PPC上暴露ANDI胶水漏洞'
# 'expression cannot be followed by a postfix %0 operator; add parentheses'
HBEECC801546A: '表达式不能后跟后缀 %0 操作符；请添加括号'
# 'expression does not compute the number of elements in this array; element type is %0, not %1'
H23C233069DBB: '表达式未计算该数组的元素数量；元素类型为 %0 而非 %1'
# "expression evaluates to '%0 %1 %2'"
H64BCD859D7BF: "表达式计算为 '%0 %1 %2'"
# 'expression has incomplete class type %0'
H58E1F9927C3B: '表达式具有不完整的类类型 %0'
# 'expression is not a string literal'
H3935D8B321FF: '表达式不是字符串字面量'
# 'expression is not an %select{integer|integral}0 constant expression'
H03AFF9CF4CF8: '表达式不是%select{整数|整型}0常量表达式'
# 'expression is not an %select{integer|integral}0 constant expression; folding it to a constant is a GNU extension'
H5CBB867EA1E8: '表达式不是一个 %select{integer|integral}0 常量表达式；将其折叠为常量是GNU扩展'
# 'expression is not assignable'
H5F8670A31719: '表达式不可赋值'
# 'expression must have integral or unscoped enumeration type, not %0'
H17B3769F086B: '表达式必须具有整型或未命名的枚举类型，而不是 %0'
# 'expression not permitted as operand of fold expression'
H291A77DD522F: '不允许在折叠表达式中使用该表达式作为操作数'
# 'expression requires explicit conversion from %0 to %1'
HB376E0297A16: '表达式需要显式地将 %0 转换为 %1'
# 'expression result unused'
HC432FEDE1001: '表达式结果未被使用'
# 'expression result unused; assign into a variable to force a volatile load'
HB7AF8EB968E8: '表达式结果未被使用；将其赋给一个变量以强制加载volatile变量'
# "expression result unused; should this cast be to 'void'?"
HBBF825FCCB8B: "表达式结果未被使用；是否应将此强制转换为 'void' 类型？"
# 'expression which evaluates to zero treated as a null pointer constant of type %0'
H0240527F1E90: '求值为零的表达式被当作类型 %0 的空指针常量处理'
# 'expression with side effects has no effect in an unevaluated context'
H186C82044D81: '具有副作用的表达式在未求值的上下文中没有效果'
# "expression with side effects will be evaluated despite being used as an operand to 'typeid'"
H9C60337CD3B8: "用于 'typeid' 操作数的具有副作用的表达式仍会被求值"
# 'extension used'
HD363255C0A95: '使用了扩展功能'
# 'extern "C" language linkage specification begins here'
H7A156727F19D: 'extern "C" 语言链接规范从此处开始'
# 'extern declaration of %0 follows non-extern declaration'
HD31A31C8A91F: '%0 的extern声明在非extern声明之后'
# 'extern templates are a C++11 extension'
H1884BE10DDD8: 'extern模板是C++11的扩展'
# 'extern templates are incompatible with C++98'
H1796556A5B60: 'extern模板与C++98不兼容'
# 'external function %0 declared with incompatible types in different translation units (%1 vs. %2)'
HE651F889FA02: '外部函数 %0 在不同翻译单元中声明的类型不兼容（%1 与 %2）'
# 'external variable %0 declared with incompatible types in different translation units (%1 vs. %2)'
H15B2E1B8C6FC: '外部变量 %0 在不同翻译单元中声明的类型不兼容（%1 与 %2）'
# 'external variable %0 defined in multiple translation units'
H1F8D107DE885: '外部变量 %0 在多个翻译单元中定义'
# "extra '&' taking address of overloaded function"
H9A83B3B4D92C: "额外的 '&' 操作符用于取重载函数的地址"
# "extra ';' %select{outside of a function|inside a %1|inside instance variable list|after member function definition}0"
HE280E1BDB8CF: "多余的 ';' %select{函数外|在 %1 内|在实例变量列表内|成员函数定义后}0"
# "extra ';' after member function definition"
H3CA5397D9B51: "在成员函数定义后多余的 ';'"
# "extra ';' outside of a function is a C++11 extension"
HEE30E6FFD401: "函数外多余的 ';' 是 C++11 扩展"
# "extra ';' outside of a function is incompatible with C++98"
HB50929FF19FE: "函数外多余的 ';' 与 C++98 不兼容"
# 'extra qualification on member %0'
HEB926F36FA1F: '成员 %0 的多余限定符'
# "extra tokens after attribute in a '#pragma clang attribute push'"
H0F837D0B4BE4: "在 '#pragma clang attribute push' 中属性后的多余标记"
# 'extra tokens at end of #%0 directive'
HBFAC5EAA75A7: "指令 '#%0' 结尾处的多余标记"
# "extra tokens at end of '#pragma %0' - ignored"
H2F08FDE9AD4F: "在 '#pragma %0' 结尾处的多余标记将被忽略"
# "extra tokens at the end of '#pragma omp %0' are ignored"
HA0D9244B087C: "在 '#pragma omp %0' 结尾处的多余标记将被忽略"
# "extraneous '%0' before ';'"
H8BD122A76CFA: "';' 前多余的 '%0'"
# "extraneous ')' after condition, expected a statement"
HFFE185AD544D: "条件后的多余的 ')', 期望一个语句"
# "extraneous 'template<>' in declaration of %0 %1"
HE8DEA9984DC2: "在 %0 %1 的声明中多余的 'template<>'"
# "extraneous 'template<>' in declaration of member %0"
H828C24444273: "在成员 %0 的声明中多余的 'template<>'"
# "extraneous 'template<>' in declaration of variable %0"
HFFC1753865A1: "在变量 %0 的声明中多余的 'template<>'"
# "extraneous closing brace ('}')"
H3D189A013717: "多余的闭合大括号 ('}')"
# 'extraneous template parameter list in alias template declaration'
HAA68A1EAD59F: '别名模板声明中的多余模板参数列表'
# 'extraneous template parameter list in concept definition'
HE58F30339D76: '概念定义中的多余模板参数列表'
# 'extraneous template parameter list in template specialization'
H37A5BAADFAAC: '模板特化中的多余模板参数列表'
# 'extraneous template parameter list in template specialization or out-of-line template definition'
HBFB0FFADD00D: '模板特化或模板外联定义中的多余模板参数列表'
# "failed requirement '%0'; 'enable_if' cannot be used to disable this declaration"
H6A26091751B1: "无法满足要求 '%0'; 'enable_if' 不能用于禁用此声明"
# "failed to deduce triple for target architecture '%0'; specify the triple using '-fopenmp-targets' and '-Xopenmp-target' instead"
HAEA08639936D: "无法推断目标架构 '%0' 的目标三元组；请改用 '-fopenmp-targets' 和 '-Xopenmp-target' 指定三元组"
# 'failed to expand response file: %0'
H14746831D212: '无法展开响应文件：%0'
# "failed to find module file for module '%0'"
H265A065BBB4D: "无法找到模块 '%0' 的模块文件"
# "failed to hash content for '%0' because memory buffer cannot be retrieved"
H13A2DD939D67: "无法为 '%0' 哈希内容，因为无法获取内存缓冲区"
# "failed to process suppression mapping file '%0': %1"
H61E7856A5801: "处理抑制映射文件 '%0' 时出错：%1"
# "failing because %select{environment variable 'FORCE_CLANG_DIAGNOSTICS_CRASH' is set|'-gen-reproducer' is used}0"
HE0DD8241D56F: '触发失败，因为 %select{环境变量 "FORCE_CLANG_DIAGNOSTICS_CRASH" 已设置|使用了 "-gen-reproducer" 选项}0'
# 'failure when lexing a character literal'
H36FAC94ACBBF: '解析字符字面量时发生错误'
# 'failure when lexing a numeric literal'
H514A5139F05F: '解析数字字面量时发生错误'
# 'failure when lexing a string literal'
H628F82057288: '解析字符串字面量时发生错误'
# 'fallthrough annotation does not directly precede switch label'
H0941315663A3: 'fallthrough 注解未直接位于 switch 标签之前'
# 'fallthrough annotation in unreachable code'
HF1B980EE596A: '不可达代码中的 fallthrough 注解'
# 'fallthrough annotation is outside switch statement'
H1D7245256264: 'switch 语句外部的 fallthrough 注解'
# 'fast enumeration variables cannot be modified in ARC by default; declare the variable __strong to allow this'
H0BD569725A75: '默认情况下 ARC 不允许修改快速枚举变量；请将变量声明为 __strong 以启用此操作'
# 'fast register allocator'
HD75005D5488A: '快速寄存器分配器'
# 'feature %0 requires support of %1 feature'
HA4C52697EC12: '特性 %0 需要 %1 特性支持'
# 'feature cannot be %select{introduced|deprecated|obsoleted}0 in %1 version %2 before it was %select{introduced|deprecated|obsoleted}3 in version %4; attribute ignored'
H18649406044A: '特性无法在 %1 版本 %2 中 %select{引入|弃用|淘汰}0，因为它在版本 %4 中 %select{尚未引入|未弃用|未淘汰}3；属性被忽略'
# "feature flag '%0' is ignored since the feature is read only"
H67D49FF0C7F8: "特性标志 '%0' 被忽略，因为该特性是只读的"
# "feature flag '%0' must start with either '+' to enable the feature or '-' to disable it; flag ignored"
HE0833D141647: "特性标志 '%0' 必须以 '+' 启用或 '-' 禁用特征；标志被忽略"
# 'field %0 can overwrite instance variable %1 with variable sized type %2 in superclass %3'
H6914F3D605AE: '字段 %0 可能用超类 %3 中的可变大小类型 %2 覆盖实例变量 %1'
# 'field %0 declared as a function'
HEA705CD2A4BF: '字段 %0 被声明为函数'
# 'field %0 declared here'
HBC2A949CCB44: '字段 %0 在此处声明'
# 'field %0 declared with incompatible types in different translation units (%1 vs. %2)'
H9B5B1B6B054E: '字段 %0 在不同的翻译单元中声明的类型不兼容（%1 与 %2）'
# 'field %0 has type %1 here'
H3B91A03ADD90: '字段 %0 在此处的类型为 %1'
# "field %0 in '%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}1' not inside structure"
H161B48990AE3: "字段 %0 在 '%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}1' 中未位于结构体内"
# 'field %0 is not a bit-field'
H28FDD2B05CEC: '字段 %0 不是位域'
# 'field %0 is uninitialized when used here'
H215FDF8256E9: '字段 %0 在此处使用时未初始化'
# 'field %0 with variable sized type %1 is not at the end of class'
H33E4FFCBD3EE: '具有可变大小类型的字段 %0（%1）未位于类的末尾'
# 'field %0 with variable sized type %1 is not visible to subclasses and can conflict with their instance variables'
HF18E29D99032: '具有可变大小类型的字段 %0（%1）对子类不可见，可能导致与其实例变量冲突'
# 'field %0 with variable sized type %1 not at the end of a struct or class is a GNU extension'
H4A43BA47311C: '结构体或类末尾未放置的具有可变大小类型的字段 %0（%1）是GNU扩展'
# 'field %1 within %0 is less aligned than %2 and is usually due to %0 being packed, which can lead to unaligned accesses'
HA45C4FF93B3E: '%0 中的字段 %1 的对齐方式比 %2 低，这通常是因为 %0 被压缩，可能导致未对齐的访问'
# 'field %select{%1|in %1}0 requires explicit initialization but is not explicitly initialized'
H84C1F3A9AA55: '字段 %select{%1|in %1}0 需要显式初始化但未显式初始化'
# 'field %select{width|precision}0 should have type %1, but argument has type %2'
H8AF459399447: '字段 %select{width|precision}0 的类型应为 %1，但参数类型为 %2'
# 'field designator %0 does not refer to a non-static data member'
HC04EA556E581: '字段指定符 %0 不指向非静态数据成员'
# 'field designator %0 does not refer to any field in type %1'
H2BAA71F8012E: '字段指定符 %0 不指向类型 %1 的任何字段'
# 'field designator %0 does not refer to any field in type %1; did you mean %2?'
HE8FCC93993E6: '字段指定符 %0 不指向类型 %1 的任何字段；您是否指 %2？'
# 'field designator cannot initialize a %select{non-struct, non-union|non-class}0 type %1'
H22AF1F955E3D: '字段指定符不能初始化 %select{non-struct, non-union|non-class}0 类型 %1'
# 'field designator refers here'
H4EC4B8573557: '字段指定符在此处引用'
# 'field has %select{incomplete|sizeless}0 type %1'
HAB06B0829266: '字段具有 %select{incomplete|sizeless}0 类型 %1'
# 'field has name %0 here'
H5D746560C0CD: '字段在此处的名称为 %0'
# 'field has non-trivial ownership qualification'
HC3F83642EF10: '字段具有非平凡的所有权限定符'
# 'field is non-trivial to %select{copy|default-initialize}0'
H1D2827B95FDF: '字段对 %select{copy|default-initialize}0 操作是非平凡的'
# 'field may not be qualified with an address space'
H8FECB3E29FF3: '字段不能用地址空间进行限定'
# 'field of illegal %select{type|pointer type}0 %1 declared here'
H7B96A2670B39: '非法的%select{类型|指针类型}0 %1 在此处声明'
# 'field of type %0 has %select{private|protected}2 %select{default |copy |move |*ERROR* |*ERROR* |*ERROR* |}1constructor'
H3E9701CFFDEE: '类型 %0 的字段具有%select{私有|保护}2 %select{默认|拷贝|移动|*ERROR*|*ERROR*|*ERROR*|}1 构造函数'
# 'field of type %1 has %select{private|protected}2 destructor'
H40B677C32C44: '类型 %1 的字段具有%select{私有|保护}2 析构函数'
# "fields must have a constant size: 'variable length array in structure' extension will never be supported"
H4D0FA4262CAB: '字段必须具有固定大小：结构体中的"可变长度数组"扩展将永远不会被支持'
# "file '%0' could not be located in expected %1"
H3AFCF68EDB4D: "在期望的 %1 中无法找到文件 '%0'"
# "file '%0' from the precompiled header has been overridden"
H0CD8B8C2C117: '来自预编译头的文件 "%0" 已被覆盖'
# "file '%0' has been modified since the %select{precompiled header|module file|precompiled file}1 '%2' was built: %select{size|mtime|content}3 changed%select{| (was %5, now %6)}4"
HA383582927C4: "文件 '%0' 在%select{预编译头文件|模块文件|预编译文件}1 '%2' 生成后已被修改：%select{大小|修改时间|内容}3发生改变 %select{|（原为 %5，现为 %6）}4"
# "file '%0' is not a module file"
H5DD90DFEF976: '文件 "%0" 不是模块文件'
# "file '%0' is too large for Clang to process"
H9AA7CD92D17E: '文件 "%0" 过大，Clang无法处理'
# "file '%0' modified since it was first processed"
H1DA05AEA2D52: '文件 "%0" 自首次处理后已被修改'
# "file '%0' specified by '--extract-api-ignores=' not found"
HC79263152CF4: '通过 "--extract-api-ignores=" 指定的文件 "%0" 未找到'
# "file '%0' specified by '-fmodules-embed-file=' not found"
HE609B0415A4D: '通过 "-fmodules-embed-file=" 指定的文件 "%0" 未找到'
# "file '%1' is not a valid %select{PCH|module|precompiled}0 file: %2"
H6C9F242B009C: "文件 '%1' 不是有效的 %select{PCH|模块|预编译}0文件：%2"
# 'file containing an ordered list of functions to use for function reordering'
HAA6E189FC7DA: '包含用于函数重排的有序函数列表的文件'
# 'file entered %0 time%s0 using %1B (%human1B) of space%plural{0:|: plus %2B (%human2B) for macro expansions}2'
H6D5FEB2AA58C: '文件被输入 %0 time%s0，使用 %1B (%human1B) 的空间 %plural{0:|: 加上 %2B (%human2B) 用于宏展开}2'
# 'file name for generated dot file'
H3426DAEC804D: '生成的dot文件的文件名'
# 'file name where instrumented profile will be saved (default: /tmp/prof.fdata)'
H3FCF6422DD03: '保存已配置的分析文件的文件名（默认：/tmp/prof.fdata）'
# 'file to dump the ordered list of functions to use for function reordering'
HA4F935C41DEC: '用于导出函数重排用的有序函数列表的文件'
# 'file with list of functions to frame optimize'
H9B6AF2961BE8: '包含需要框架优化函数列表的文件'
# 'file with list of functions to optimize'
HE0011E0AAAF5: '包含需要优化函数列表的文件'
# 'file with list of functions to optimize (non-regex)'
H03B4E7AB601D: '包含需要优化函数列表的文件（非正则表达式）'
# 'file with list of functions to skip'
HCF75D26C4EAE: '包含需要跳过函数列表的文件'
# 'filter expression has non-integral type %0'
H8F952076C959: '过滤表达式具有非整数类型 %0'
# 'final overrider of %q0 in %1'
H0C345A3BEA34: '%1 中的%q0最终重写者'
# 'find_all_symbols options'
H390ECCC2C1D8: '查找所有符号选项'
# "finished building module '%0'"
H243A4EC2890E: '已完成模块 "%0" 的构建'
# 'first argument in call to %0 is a pointer to non-trivially copyable type %1'
HD27C5E590173: '对 %0 的调用中的第一个参数是指向非平凡可拷贝类型 %1 的指针'
# 'first argument to %0 must be a pipe type'
H3249D08A7B4F: '对 %0 的调用中的第一个参数必须是管道类型'
# "first argument to 'swift_async' must be either 'none', 'swift_private', or 'not_swift_private'"
HF444E5B58050: "对 'swift_async' 的调用中的第一个参数必须是 'none'、'swift_private' 或 'not_swift_private'"
# "first argument to 'va_arg' is of type %0 and not 'va_list'"
H18598D04D35B: "'va_arg' 的第一个参数类型为 %0，而不是 'va_list'"
# 'first argument to __builtin_annotation must be an integer'
H2F65E4EF2060: '__builtin_annotation 的第一个参数必须是整数'
# 'first argument to __builtin_call_with_static_chain must be a non-member call expression'
HF21FFE70E0AD: '__builtin_call_with_static_chain 的第一个参数必须是非成员调用表达式'
# 'first argument to __builtin_call_with_static_chain must not be a block call'
HAAFE474DF4AA: '__builtin_call_with_static_chain 的第一个参数不能是块调用'
# 'first argument to __builtin_call_with_static_chain must not be a builtin call'
HF06ABEE7311C: '__builtin_call_with_static_chain 的第一个参数不能是内建函数调用'
# 'first argument to __builtin_call_with_static_chain must not be a pseudo-destructor call'
HFC90CCCE3212: '__builtin_call_with_static_chain 的第一个参数不能是伪析构函数调用'
# 'first argument to __builtin_convertvector must be a vector'
HF416CD096831: '__builtin_convertvector 的第一个参数必须是一个向量'
# 'first field of a transparent union cannot have %select{floating point|vector}0 type %1; transparent_union attribute ignored'
HCF8EE366AB6A: '透明联合的第一个字段不能具有 %select{浮点|向量}0 类型 %1；transparent_union 属性被忽略'
# 'first non-designated initializer is here'
H3AA2DBB89701: '第一个非指定初始化器在此处'
# 'first two arguments to __builtin_convertvector must have the same number of elements'
HF134017C1A48: '__builtin_convertvector 的前两个参数必须具有相同数量的元素'
# "first%select{||| and second}0 argument%select{|||s}0 to '__builtin_trivially_relocate' must be %select{a pointer|non-const|relocatable|of the same type}0"
H922BBD5C29FD: '__builtin_trivially_relocate的第一个 %select{|||和第二个}0参数 %select{|||s}0 必须是%select{指针|非const|可重定位|相同类型}0'
# "flag '%0' is ignored when flag '%1' is present"
H83C2C7BB9944: "当标志 '%1' 存在时，标志 '%0' 被忽略"
# "flag '%0' results in undefined behavior with '%1' conversion specifier"
H3E280AED1AE3: "标志 '%0' 与 '%1' 转换说明符会导致未定义行为"
# 'flag value is neither a literal 0 nor a named value'
HD5CDE1D3FA16: '标志值既不是字面量 0 也不是命名值'
# 'flat namespace libraries are not supported'
H5F018FAC5A55: '扁平命名空间库不受支持'
# 'flexible array initialization is a GNU extension'
H2B7FB7A2090E: '灵活数组初始化是 GNU 扩展'
# 'flexible array initialization is not yet supported'
H4465FD687CED: '灵活数组初始化尚未支持'
# 'flexible array member %0 in a union is a GNU extension'
H87BF69264D2B: '联合中的灵活数组成员 %0 是 GNU 扩展'
# 'flexible array member %0 in a union is a Microsoft extension'
HFF7472E02D1C: '联合中的灵活数组成员 %0 是 Microsoft 扩展'
# 'flexible array member %0 in otherwise empty %select{struct|interface|union|class|enum}1 is a GNU extension'
HADE10FBB32E9: '空的 %select{结构|接口|联合|类|枚举}1 中的灵活数组成员 %0 是 GNU 扩展'
# 'flexible array member %0 in otherwise empty %select{struct|interface|union|class|enum}1 is a Microsoft extension'
H9C2765356C50: '空的 %select{结构|接口|联合|类|枚举}1 中的灵活数组成员 %0 是 Microsoft 扩展'
# 'flexible array member %0 not allowed in %select{struct|interface|union|class|enum}1 which has a virtual base class'
HEF0666641494: '柔性数组成员 %0 不允许在具有虚基类的 %select{struct|interface|union|class|enum}1 中'
# 'flexible array member %0 of type %1 with non-trivial destruction'
H07E92B7CB701: '类型为 %1 且具有非平凡析构的柔性数组成员 %0'
# 'flexible array member %0 with type %1 is not at the end of %select{struct|interface|union|class|enum}2'
HC60DC08C387B: '类型为 %1 的柔性数组成员 %0 不在 %select{struct|interface|union|class|enum}2 的末尾'
# 'flexible array members are a C99 feature'
H04521DEE401E: '柔性数组成员是C99特性'
# 'flexible array requires brace-enclosed initializer'
H8CC54601E715: '柔性数组需要花括号包围的初始化器'
# "float ABI '%0' is not supported by current library"
H4A77B1741C96: "浮点ABI '%0' 不受当前库支持"
# 'float literal has a magnitude that is too small to be represented as a float type'
HFFD25AF4AD9F: '浮点字面量的量级过小，无法用float类型表示'
# 'floating point arithmetic produces %select{an infinity|a NaN}0'
HE17E4C75C5CF: '浮点运算产生%select{无穷大|NaN}0'
# 'floating point classification requires argument of floating point type (passed in %0)'
HD0C7777CBCB2: '浮点分类需要浮点类型的参数（传递了 %0）'
# 'floating point literal in preprocessor expression'
HB66AC9BD4411: '预处理表达式中的浮点字面量'
# 'floating-point comparison is always %select{true|false}0; constant cannot be represented exactly in type %1'
HCE8BE2CDB468: '浮点比较始终为 %select{true|false}0；常量无法在类型 %1 中精确表示'
# 'fold functions with identical code'
H57C9420813A5: '合并具有相同代码的函数'
# 'fold jcc+mov into cmov'
H1F495E977B3A: '将jcc+mov指令合并为cmov指令'
# 'for fuzzer data'
H8CC95526ECAB: '用于模糊测试数据'
# 'for jump tables, optimize indirect jmp targets instead of indices'
H4D3A2CC709AA: '对于跳转表，优化间接跳转目标而非索引'
# 'for loop has empty body'
HE73C4C3A1FCE: 'for循环具有空的循环体'
# 'for range declaration must declare a variable'
HCCF9CE851541: '范围for声明必须声明一个变量'
# 'for training'
H23FBBEB90B89: '用于训练'
# 'for type %0'
HE30274CCC76F: '对于类型 %0'
# 'force openmp unified shared memory mode'
H98550220A417: '强制使用OpenMP统一共享内存模式'
# 'force patching of original entry points to ensure execution follows only the new/optimized code.'
HAA8249C8D974: '强制修补原始入口点，以确保执行仅遵循新/优化后的代码。'
# 'force relocations to data sections to always be processed'
H790511D970BB: '强制处理数据段的重定位'
# 'force the body of a loop to execute at least once'
H6C72E59E822C: '强制循环体至少执行一次'
# 'force_cuda_host_device end pragma without matching force_cuda_host_device begin'
H8F7AF4F2F3B0: '缺少对应的force_cuda_host_device begin，使用了force_cuda_host_device end pragma'
# 'format argument is %select{a value|an indirect field width|an indirect precision|an auxiliary value}0, but it should be %select{a value|an indirect field width|an indirect precision|an auxiliary value}1'
H26324CE63C64: '格式参数是%select{一个值|一个间接字段宽度|一个间接精度|一个辅助值}0，但它应该是%select{一个值|一个间接字段宽度|一个间接精度|一个辅助值}1'
# 'format argument modifies specifier at position %0, but it should modify specifier at position %1'
HE2EBF92B2A88: '格式参数修改了位置 %0 的说明符，但它应该修改位置 %1 的说明符'
# 'format argument not a string type'
H84E99A867F54: '格式参数不是字符串类型'
# 'format attribute cannot specify the implicit this argument as the format string'
H6DFBB5CF7F53: '格式属性不能将隐式this参数指定为格式字符串'
# "format specifier '%0' is incompatible with '%1'"
H4D29848904BC: "格式说明符 '%0' 与 '%1' 不兼容"
# 'format specifies type %0 but the argument has %select{type|underlying type}2 %1'
H2B1918042742: '格式指定类型 %0，但参数具有%select{类型|底层类型}2 %1'
# "format string contains '\\0' within the string body"
H262604652293: "格式字符串在字符串正文中包含 '\\0'"
# 'format string is defined here'
H2D8041B9330A: '格式字符串在此处定义'
# 'format string is empty'
HCF4821840281: '格式字符串为空'
# 'format string is not a string literal'
HA31C16ADFE78: '格式字符串不是字符串字面量'
# 'format string is not a string literal (potentially insecure)'
HC6BB1E1C18C5: '格式字符串不是字符串字面量（潜在不安全）'
# 'format string is not null-terminated'
H1BFF49AB9B87: '格式字符串未以空字符结尾'
# 'format string missing'
HF57059BFF07F: '缺少格式字符串'
# 'format string should not be a wide string'
H5D46A69914C2: '格式字符串不应是宽字符串'
# 'format to dump profile output in aggregation mode, default is fdata'
H4B4189014528: '以聚合模式导出分析数据的格式，默认为fdata'
# 'forward declaration of %0'
H9E3BA9144F24: '%0 的前向声明'
# 'forward declaration of %0 cannot have a nested name specifier'
HED9D019594EF: '%0 的前向声明不能带有嵌套名称限定符'
# 'forward declaration of class here'
H169D8B5BC4E6: '类的前向声明在此处'
# 'forward declaration of non-parameterized class %0 cannot have type parameters'
H5EA8F1567F5D: '非参数化类 %0 的前向声明不能带有类型参数'
# 'forward declaration of template entity is here'
H61734FDBAB98: '模板实体的前向声明在此处'
# "forward references to 'enum' types are a Microsoft extension"
H747D15D3C5A0: '枚举类型的前向引用是Microsoft扩展'
# "found '<::' after a %select{template name|addrspace_cast|const_cast|dynamic_cast|reinterpret_cast|static_cast}0 which forms the digraph '<:' (aka '[') and a ':', did you mean '< ::'?"
HFDE68D3C1582: "在%select{模板名称|addrspace_cast|const_cast|dynamic_cast|reinterpret_cast|static_cast}0 之后发现了 '<::'，这形成了双字符符号 '<:'（即 '['）和一个 ':'，是否应为 '<::'？"
# "found near match '%0'"
HE96C9DD0F351: "找到近似匹配项 '%0'"
# 'fp convert instructions on integers with more than <N> bits are expanded.'
HBF7A8F526E5F: '对超过 <N> 位的整数进行浮点转换指令展开'
# "friend cannot be declared in an explicit instantiation; if this declaration is meant to be a friend declaration, remove the 'template' keyword"
H2CA4FF8AC2DD: "friend声明不能出现在显式实例化中；如果此声明本意是friend声明，请移除 'template' 关键字"
# 'friend declaration cannot be a concept'
HB24446765643: 'friend声明不能是一个概念'
# 'friend declaration cannot have a pure-specifier'
HC11ADC45D1D2: 'friend声明不能带有纯说明符'
# 'friend declaration expands pack %0 that is declared it its own template parameter list'
H7F18F2309FFC: '友元声明展开包 %0，该包在其自身的模板参数列表中声明'
# 'friend declaration naming a member of the declaring class is incompatible with C++98'
H785F5E24B496: '命名声明类成员的友元声明与C++98不兼容'
# 'friend declaration of %0 does not match any declaration in %1'
H31DFE021DF93: '%0 的友元声明与 %1 中的任何声明不匹配'
# 'friend declaration specifying a default argument must be a definition'
H55D4B490E76D: '指定默认参数的友元声明必须是一个定义'
# 'friend declaration specifying a default argument must be the only declaration'
H21926C78D225: '指定默认参数的友元声明必须是唯一的声明'
# 'friend declaration with a constraint that depends on an enclosing template parameter must be a definition'
HC3DC9462CF4B: '依赖于包含模板参数的约束的友元声明必须是一个定义'
# 'friend declared here'
H4C2593C39E2F: '此处声明的友元'
# 'friend function %0 retaining previous language linkage is an extension'
H45895F884047: '保留先前语言链接的友元函数 %0 是扩展'
# 'friend function %1 is a %select{private|protected}0 member of %3'
H559C2702128F: '友元函数 %1 是 %3 的%select{私有|受保护}0成员'
# 'friend function cannot be defined in a local class'
H01D22F1D90F1: '不能在局部类中定义友元函数'
# 'friend function definition cannot be qualified with %0'
H87D42EF13E75: '友元函数定义不能用 %0 限定'
# 'friend function specialization cannot be defined'
HE48A55696A0C: '不能定义友元函数特化'
# 'friend type templates must use an elaborated type'
H81BB485691B6: '友元类型模板必须使用扩展类型'
# 'friends can only be classes or functions'
HABE505726BE2: '友元只能是类或函数'
# 'friends cannot be members of the declaring class'
H0C1CF26733ED: '友元不能是声明类的成员'
# "from 'diagnose_if' attribute on %0:"
HB7602983E09F: '来自 %0 上的 "diagnose_if" 属性：'
# 'func1,func2,func3,...'
H6E12F3399F53: 'func1,func2,func3,...'
# "function %0 declared 'noreturn' should not return"
H05EC2FA28594: '声明为noreturn的函数 %0 不应返回'
# 'function %0 is unsafe'
H16AE74CB24AD: '函数 %0 不安全'
# 'function %0 with deduced return type cannot be used before it is defined'
H55B75567CEBA: '具有推导返回类型的函数 %0 在定义前不能使用'
# 'function %0 with unknown type must be given a function type'
H5580EE2709E6: '类型未知的函数 %0 必须指定函数类型'
# 'function by that name is mangled as "%0"'
HD8E36422062F: '该名称的函数被编码为 "%0"'
# 'function call counts'
HC411DF133023: '函数调用次数'
# 'function cannot return %select{array|function}0 type %1'
H00D7FE6EC486: '函数不能返回%select{数组|函数}0类型 %1'
# 'function cannot return qualified void type %0'
H6C0F9155F7F7: '函数不能返回修饰的void类型 %0'
# 'function declaration cannot become a multiversioned function after first usage'
HC4FCD39E4392: '函数声明在首次使用后不能成为多版本函数'
# 'function declaration cannot have variably modified type'
HC763DB755E39: '函数声明不能具有可变修改后的类型'
# "function declaration is expected after 'declare %select{simd|variant}0' directive"
HCE4F7AEAC2D0: '在声明 %select{simd|variant}0 指令后应有函数声明'
# "function declaration is missing %select{'target'|'cpu_specific' or 'cpu_dispatch'|'target_version'}0 attribute in a multiversioned function"
H3FE487F1B347: "在多版本函数中，函数声明缺少 %select{'target'|'cpu_specific' 或 'cpu_dispatch'|'target_version'}0 属性"
# 'function declared %0 was previously declared %1, which has different SME function attributes'
HF900531E932D: '函数声明 %0 之前被声明为 %1，其具有不同的SME函数属性'
# "function declared '%0' here was previously declared %select{'%2'|without calling convention}1"
H2073EFB350A2: "在此处声明的函数 '%0' 之前被声明为 %select{'%2'|无调用约定}1"
# "function declared in block scope cannot have 'static' storage class"
H60B5EC75E0B8: "块作用域内的函数声明不能具有 'static' 存储类"
# 'function declared non-throwing here'
H03F3D9700027: '函数在此处声明为不抛出异常'
# 'function declared with %0 attribute was previously declared without the %0 attribute'
H5B84619C2423: '带有 %0 属性的函数声明之前被声明为没有该 %0 属性'
# 'function declared with regparm(%0) attribute was previously declared %plural{0:without the regparm|:with the regparm(%1)}1 attribute'
HF6A7160FBDE6: '声明带有regparm(%0)属性的函数之前被声明为 %plural{0:无regparm|:带有regparm(%1)}1属性'
# "function definition declared 'typedef'"
H4E2B82F177E3: "此处的函数定义声明了 'typedef'"
# 'function definition does not declare parameters'
HD54A2FF99A28: '函数定义未声明参数'
# 'function definition inside an Objective-C container is deprecated'
HE7254FE08BD0: '在Objective-C容器内的函数定义已弃用'
# 'function definition is not allowed here'
HE3336279F815: '此处不允许函数定义'
# 'function definition with pure-specifier is a Microsoft extension'
HDD1E7812B50D: '带有pure-specifier的函数定义是Microsoft扩展'
# 'function does not return %0'
H7977746969A8: '函数未返回 %0'
# "function executed in streaming-SVE mode requires 'sme'"
H6F533435BD63: "在流式SVE模式下执行的函数需要 'sme'"
# 'function id'
H68D2D6A5A6D7: '函数ID'
# "function is a coroutine due to use of '%0' here"
H3E5959ADA928: '由于此处使用‘%0’，该函数是一个协程'
# 'function is implicitly deleted because its declared type does not match the type of an implicit %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0'
H2629CD02AC41: '函数因声明类型与隐含的%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}0类型不匹配而被隐式删除'
# 'function multiversioning caused by this declaration'
HF2D62F7767DB: '由该声明引发的函数多版本化'
# "function multiversioning doesn't support %select{feature|architecture}0 '%1'"
H9210168C8D12: '函数多版本化不支持%select{特性|架构}0 "%1"'
# 'function multiversioning is currently only supported on Linux'
H16DA1069458D: '函数多版本化目前仅在Linux系统上支持'
# 'function multiversioning is not supported on the current target'
H7E39D7302E01: '当前目标平台不支持函数多版本化'
# "function name is not allowed in 'link' clause"
H0E47E3134914: '函数名不允许出现在 "link" 子句中'
# 'function names'
HDC0A95620EA5: '函数名称'
# 'function parameter %0 with unknown value cannot be used in a constant expression'
H01EB1CAEE1FB: '具有未知值的函数参数 %0 不能用于常量表达式'
# 'function previously declared with an %select{explicit|implicit}0 exception specification redeclared with an %select{implicit|explicit}0 exception specification'
H74E61DFB1137: '函数先前使用%select{显式|隐式}0异常规范声明，但现使用%select{隐式|显式}0异常规范重新声明'
# 'function returns a type %0 marked with [[clang::coro_return_type]] but is neither a coroutine nor a coroutine wrapper; non-coroutines should be marked with [[clang::coro_wrapper]] to allow returning coroutine return type'
H6390B743719E: '函数返回带有[[clang::coro_return_type]]标记的类型 %0，但它既不是协程也不是协程包装器；非协程应使用[[clang::coro_wrapper]]标记以允许返回协程返回类型'
# 'function scope depth exceeded maximum of %0'
H7DB5DD972DEA: '函数作用域深度超过最大值 %0'
# "function static variables are not permitted in functions to which an OpenACC 'routine' directive applies"
HE3AED765A103: '应用OpenACC "routine" 指令的函数中不允许使用静态变量'
# 'function template %q0 matches specialization %1'
HA3A32C570475: '函数模板%q0与特化模板 %1 匹配'
# 'function template partial specialization is not allowed'
HA3F0ADD5EDBB: '不允许函数模板的部分特化'
# 'function template specialization %0 ambiguously refers to more than one function template; explicitly specify%select{| additional}1 template arguments to identify a particular function template'
H64BC13156614: '函数模板特化 %0 模棱两可地指向多个函数模板；请显式指定 %select{|附加}1模板参数以指定特定的函数模板'
# "function template with 'sycl_kernel' attribute must have a 'void' return type"
HE8E9EA85C4E9: '带有 "sycl_kernel" 属性的函数模板必须具有 "void" 返回类型'
# "function template with 'sycl_kernel' attribute must have a single parameter"
H852CD6495192: '带有 "sycl_kernel" 属性的函数模板必须具有单一参数'
# 'function try block in constexpr %select{function|constructor}0 is a C++20 extension'
H5EFE05C3D7E9: '函数constexpr %select{函数|构造函数}0中的try块是C++20扩展'
# 'function try block in constexpr %select{function|constructor}0 is incompatible with C++ standards before C++20'
HACF74D9C1B64: '函数constexpr %select{函数|构造函数}0中的try块与C++20之前的语言标准不兼容'
# 'function type may not be qualified with an address space'
H193B814022E3: '函数类型不能用地址空间进行限定'
# 'function type with %0 attribute must have C linkage'
H39A9B5046A90: '带有 %0 属性的函数类型必须具有C语言链接性'
# "function using ZA state requires 'sme'"
H355762BCE254: "使用 ZA 状态的函数需要 'sme'"
# "function using ZT0 state requires 'sme2'"
H00330EB861A8: "使用 ZT0 状态的函数需要 'sme2'"
# "function with '#pragma omp declare variant' has a different %select{calling convention|return type|constexpr specification|inline specification|storage class|linkage}0"
H77243261DC29: "带有 '#pragma omp declare variant' 指令的函数具有不同的 %select{调用约定|返回类型|constexpr 说明|内联说明|存储类别|链接性}0"
# "function with '#pragma omp declare variant' must have a prototype when 'append_args' is used"
H6A83415B36DA: "当使用 'append_args' 时，带有 '#pragma omp declare variant' 的函数必须有原型"
# "function with 'device_type(%0)' is not available on %select{device|host}1"
HB35512790F72: '设备类型（%0）的函数在 %select{设备|主机}1 上不可用'
# 'function with deduced return type cannot be virtual'
H4BED7E854F85: '具有推导返回类型的函数不能是 virtual'
# 'function with no prototype cannot use the %0 calling convention'
H83A590AC3D6C: '没有原型的函数不能使用 %0 调用约定'
# "function with trailing return type must specify return type 'auto', not %0"
HBA312AD67336: '具有尾随返回类型的函数必须指定返回类型为 auto，而不是 %0'
# 'function-like macro %0 is not defined'
H7F9F07CB89B9: '函数式宏 %0 未定义'
# 'function-style cast to a builtin type can only take one argument'
H5995CF0D518F: '向内建类型使用函数式转换只能接受一个参数'
# 'functional-style cast to %0 has incompatible initializer of type %1'
H0F52DA9B703F: '将 %0 的函数式转换具有不兼容的类型 %1 的初始化器'
# 'functions cannot be declared in an anonymous %select{struct|union}0'
H50EACF1C1B1C: '不能在匿名 %select{struct|union}0 中声明函数'
# "functions may not be declared with 'cmse_nonsecure_call' attribute"
H21052FB1BA63: '带有 cmse_nonsecure_call 属性的函数不能被声明'
# 'functions that differ only in their return type cannot be overloaded'
H24E04D8DAB80: '仅返回类型不同的函数不能被重载'
# 'gdb'
H8EAD6354003C: 'gdb'
# 'generalized initializer lists are a C++11 extension'
HA239925474B5: '通用初始化列表是 C++11 扩展'
# 'generalized initializer lists are incompatible with C++98'
HCEA06465013C: '通用初始化列表与 C++98 不兼容'
# 'generate a C++ source file containing the patterns for the input file'
H0E649CF6B515: '生成包含输入文件模式的C++源文件'
# 'generate a list of function sections in a format suitable for inclusion in a linker script'
H26853D1AF334: '生成一个函数段列表，格式适合包含在链接器脚本中'
# 'generate code for binaries <128MB on AArch64'
H5478C82F0746: '生成适用于AArch64架构下小于 128MB二进制文件的代码'
# 'generate loops for copy-in/copy-out of objects with descriptors'
HEE6A80E60F2B: '为带有描述符的对象生成复制输入/输出的循环'
# 'generate new tags with runtime library calls'
HE354D1286E8B: '生成带有运行时库调用的新标签'
# 'generate the AST for the input file'
H8D81796BB792: '生成输入文件的AST'
# 'generate the PDL MLIR for the input file'
H13DC370300BA: '生成输入文件的PDL MLIR'
# 'generated arguments #%0 in round-trip: %1'
H9232807EF50E: '往返中的生成参数 #%0：%1'
# 'generated arguments do not match in round-trip'
HDDB24B24E48C: '往返中的生成参数不匹配'
# 'generated arguments parse failed in round-trip'
HA646C4AED02A: '往返中的生成参数解析失败'
# 'generic lambdas are incompatible with C++11'
H0E2372801126: '通用 lambdas 与 C++11 不兼容'
# 'getter name mismatch between property redeclaration (%1) and its original declaration (%0)'
HCB66D133764C: '属性重声明（%1）和其原始声明（%0）的getter名称不匹配'
# 'given <sectname>,<filename>[@<sym>=<offset>,...]  add the content of <filename> to <sectname>'
HB3C96722F67D: '给定 <sectname>,<filename>[@<sym>=<offset>,...] 将 <filename> 的内容添加到 <sectname> 段'
# "glob '%0' did not match any header file"
H7F85F549D444: "glob '%0' 未匹配到任何头文件"
# 'global sampler requires a const or constant address space qualifier'
H418F4CC80105: '全局采样器需要const或constant地址空间限定符'
# 'granularity of memprof shadow mapping'
H3EDB20D758D1: 'memprof阴影映射的粒度'
# 'greedy register allocator'
H682B2DF6B406: '贪婪寄存器分配器'
# 'growRegion() does not scale with the number of BB edges, so limit its budget and bail out once we reach the limit.'
HA399861C464F: 'growRegion()的扩展性不随BB边的数量而变化，因此限制其预算，达到限制时退出'
# 'guarded_by declared here'
H0D3E968182E3: 'guarded_by 声明于此处'
# 'half precision constant requires cl_khr_fp16'
H4CC0B372F96B: '半精度常量需要cl_khr_fp16'
# 'hardware TLS register is not supported for the %0 sub-architecture'
HDE3B68F7C8A6: '%0 子架构不支持硬件TLS寄存器'
# "header attribute '%0' specified multiple times"
H7E7CB9EE75BF: "头文件属性 '%0' 被多次指定"
# "header file %0 (aka '%1') cannot be imported because it is not known to be a header unit"
H0A389CC3DB5F: "头文件 %0（别名 '%1'）无法导入，因为它未被识别为头单元"
# "header file '%0' input '%1' does not match the type of prior input in api extraction; use '-x %2' to override"
HCC1F871B655D: "头文件 '%0' 的输入 '%1' 与API提取中的先前输入类型不匹配；使用 '-x %2' 覆盖"
# "header file '%0' input type '%1' does not match type of prior input in module compilation; use '-x %2' to override"
H089F6388D5E8: "头文件 '%0' 的输入类型 '%1' 与模块编译中的先前输入类型不匹配；使用 '-x %2' 覆盖"
# 'heap allocation performed here'
H3CBBD5C4CC88: '此处执行堆分配'
# 'heatmap bucket size, optionally followed by zoom-out sizes for coarse-grained heatmaps (default 64B, 4K, 256K).'
H8DE740B4864F: '热力图存储桶大小，可选跟随粗粒度热力图的缩小尺寸（默认 64B, 4K, 256K）。'
# 'hexadecimal floating %select{constant|literal}0 requires %select{an exponent|a significand}1'
HEA69D9247DD1: '十六进制浮点%select{常量|字面量}0 需要%select{指数|有效数字}1'
# 'hexadecimal floating constants are a C99 feature'
H42D5F9E3F4DF: '十六进制浮点常量是C99特性'
# 'hexadecimal floating literals are a C++17 feature'
H37A919BEDE1E: '十六进制浮点字面量是C++17特性'
# 'hexadecimal floating literals are incompatible with C++ standards before C++17'
HDD6000DF6583: '十六进制浮点字面量与C++17之前的C++标准不兼容'
# 'hidden overloaded virtual function %q0 declared here%select{|: different classes%diff{ ($ vs $)|}2,3|: different number of parameters (%2 vs %3)|: type mismatch at %ordinal2 parameter%diff{ ($ vs $)|}3,4|: different return type%diff{ ($ vs $)|}2,3|: different qualifiers (%2 vs %3)|: different exception specifications}1'
HAF71C2F007E8: '被隐藏的重载虚函数 %q0 声明于此处 %select{|: 不同的类%diff{ ($ vs $)|}2,3|: 参数数量不同（%2 vs %3）|: 第%ordinal2参数类型不匹配%diff{ ($ vs $)|}3,4|: 返回类型不同%diff{ ($ vs $)|}2,3|: 限定符不同（%2 vs %3）|: 异常规格不同}1'
# "hidden visibility cannot be applied to 'dllexport' declaration"
HF663B246106D: "隐藏可见性不能应用于 'dllexport' 声明"
# 'higher order bits are zeroes after implicit conversion'
H69351DA797D5: '隐式转换后高位为零'
# 'hoist common instructions (default = false)'
HAA6396EA7649: '提升公共指令（默认=false）'
# 'host variable declared here'
H46B0F8E7BD93: '主机变量声明于此处'
# 'hot data symbols support (relocation mode)'
H654F967DBBD4: '热数据符号支持（重定位模式）'
# 'how to repeat the instruction snippet'
HA06BE48BF68E: '如何重复指令片段'
# 'hugify'
H4C1045D46DF7: 'hugify'
# 'human-readable YAML format'
HE74AE57FF6C4: '可读的YAML格式'
# "identifier %0 after '~' in destructor name does not name a type"
H83FECEE0EB8D: "析构函数名称中 '~' 后的标识符 %0 不是一个类型"
# 'identifier %0 conflicts with a C++ keyword'
HA06C7A563CB5: '标识符 %0 与C++关键字冲突'
# 'identifier %0 in object destruction expression does not name a type'
H9BF7AFAC2ABF: '对象销毁表达式中的标识符 %0 未命名一个类型'
# 'identifier %0 in object destruction expression does not name the type %1 of the object being destroyed'
H3AA5F97C4B64: '对象销毁表达式中的标识符 %0 不是正在销毁的对象类型 %1'
# "identifier %0 is reserved because %select{<ERROR>|it starts with '_' at global scope|it starts with '_' and has C language linkage|it starts with '__'|it starts with '_' followed by a capital letter|it contains '__'}1"
HB25A0B12A970: "标识符 %0 被保留，因为 %select{<ERROR>|它在全局作用域以 '_' 开头|它以 '_' 开头且具有C语言链接性|它以 '__' 开头|它以 '_' 后跟大写字母开头|它包含 '__'}1"
# 'identifier %0 preceded by whitespace in a literal operator declaration is deprecated'
H0DD590ABAF7E: '字面量运算符声明中标识符 %0 前有空格已被弃用'
# 'identifier after literal will be treated as a reserved user-defined literal suffix in C++11'
HC12CCB91962D: '字面量后的标识符在C++11中将被视为保留的用户定义字面量后缀'
# 'identifier after literal will be treated as a user-defined literal suffix in C++11'
HBE6CD4B6A8AE: '字面量后的标识符在C++11中将被视为用户定义字面量后缀'
# 'identifier contains Unicode character <U+%0> that is invisible in some environments'
H5D7B884070AB: '标识符包含在某些环境中不可见的Unicode字符 <U+%0>'
# "identifier followed by '<' indicates a class template specialization but %0 %select{does not refer to a template|refers to a function template|<unused>|refers to a variable template|<unused>|<unused>|refers to a concept}1"
HAF5607DFBCE7: "由 '<' 后缀标识的类模板特化但 %0 %select{不引用模板|引用函数模板|<未使用>|引用变量模板|<未使用>|<未使用>|引用概念}1"
# "if processing a memory profile, filter out stack or heap accesses that won't be useful for BOLT to reduce profile file size"
HECF8ECDF0776: '如果处理内存分析数据，过滤掉对BOLT无用的栈或堆访问以减小分析文件大小'
# 'if reorder-functions is used, order functions putting hottest last'
HD0E8BDE8B867: '若使用函数重排，按热度从高到低排列函数'
# 'if statement has empty body'
H1093D3B0523A: 'if语句有空的主体'
# 'if the caller is not cold'
H4C9CA904F4C7: '如果调用者不是冷调用路径'
# 'if the input is dwp file, parse .debug_info section and use it to populate DW_SECT_INFO contributions in cu-index. For DWARF5 it also populated TU Index.'
HEE68D0DE6C99: '如果输入是dwp文件，解析.debug_info节，并用它填充cu-index中的DW_SECT_INFO贡献。对于DWARF5，还会填充TU索引'
# 'if there is more than one benchmark for an opcode, said benchmarks may end up not being clustered into the same cluster if the measured performance characteristics are different. by default all such opcodes are filtered out. this flag will instead show only such unstable opcodes'
H1E3EED942083: '如果某个操作码有多个基准测试，若测量的性能特征不同，这些基准可能无法被归为同一簇。默认会过滤掉所有此类操作码，而此标志仅显示不稳定的操作码'
# 'if you see this diagnostic, a Clang developer has made a mistake'
H64B3C8B6BDD2: '如果您看到此诊断信息，说明某个Clang开发者犯了错误'
# 'if you supply your own aligned allocation functions, use -faligned-allocation to silence this diagnostic'
H71B886D5B0E4: '如果您提供了自己的对齐分配函数，请使用 -faligned-allocation 选项来抑制此诊断信息'
# 'ifunc resolver function must return a pointer'
H3E2AB07FAA23: 'ifunc解析函数必须返回一个指针'
# 'ignore failures to find derived type descriptors when translating FIR to LLVM'
H6805B42BCC88: '在将FIR转换为LLVM时，忽略找不到派生类型描述符的错误'
# 'ignore hash while reading function profile'
H414AB7A86B98: '读取函数分析数据时忽略哈希值'
# 'ignore instructions that do not define a sched class'
H4673E599AC01: '忽略未定义调度类的指令'
# 'ignore kernel interrupt LBR that happens asynchronously'
H65FF6B663DAF: '忽略异步发生的内核中断LBR'
# 'ignore lto_priv or const suffixes when matching functions'
H482A47671C74: '在匹配函数时忽略lto_priv或const后缀'
# 'ignore recursive calls when constructing the call graph'
H79AFD225957D: '在构建调用图时忽略递归调用'
# "ignored 'inline' attribute on kernel function %0"
HD7F59CCBC545: "内核函数 %0 上的 'inline' 属性被忽略"
# "ignored asm label '%0' on automatic variable"
H457253219067: "自动变量上的 asm 标签 '%0' 被忽略"
# 'ignored trigraph would end block comment'
HC0EDD32FEF14: '被忽略的三元组会导致块注释结束'
# 'ignoring %0 attribute because its argument is invalid'
H5CBA55A0FD5C: '忽略 %0 属性，因为其参数无效'
# 'ignoring %select{return value|temporary}0 of type %2 declared with %1 attribute%select{|: %4}3'
H18EB408CFE62: '忽略使用 %1 属性声明的类型 %2 的 %select{返回值|临时对象}0%select{|: %4}3'
# "ignoring '%0' as it conflicts with that implied by '%1' (%2)"
HB9837B039EA4: "忽略 '%0'，因为它与 '%1' 隐含的选项 (%2) 冲突"
# "ignoring '%0' option as it cannot be used with %select{implicit usage of|}1 -mabicalls and the N64 ABI"
H17CC723C2497: "忽略 '%0' 选项，因为它不能与 %select{隐式使用|}1 -mabicalls 和 N64 ABI 一起使用"
# "ignoring '%0' option as it is not currently supported for processor '%1'"
H14E6B917A2E6: "忽略 '%0' 选项，因为它当前不支持处理器 '%1'"
# "ignoring '%0' option as it is not currently supported for target '%1'"
H4AA39F54EF26: "忽略 '%0' 选项，因为它当前不支持目标 '%1'"
# "ignoring '%0' option for offload arch '%1' as it is not currently supported there. Use it with an offload arch containing '%2' instead"
H788152E08844: "忽略为offload架构 '%1' 指定的 '%0' 选项，因为当前不支持该选项。请改用包含 '%2' 的offload架构"
# "ignoring '%select{static|inline}0' keyword on explicit template instantiation"
H8A80FA7727CA: "忽略显式模板实例化中的 '%select{static|inline}0' 关键字"
# "ignoring '-f%select{no-|}0raw-string-literals', which is only valid for C and C++ standards before C++11"
H135D75731B01: "忽略 '-f%select{no-|}0raw-string-literals' 选项，该选项仅适用于C和C++11之前的版本"
# "ignoring '-mabs=2008' option because the '%0' architecture does not support it"
H5F88EE5F0A3D: "忽略 '-mabs=2008' 选项，因为 '%0' 架构不支持该选项"
# "ignoring '-mabs=legacy' option because the '%0' architecture does not support it"
HE0FE9F3B46CA: "忽略 '-mabs=legacy' 选项，因为 '%0' 架构不支持该选项"
# "ignoring '-mcompact-branches=' option because the '%0' architecture does not support it"
H60C9F0D89DB6: "忽略 '-mcompact-branches=' 选项，因为 '%0' 架构不支持该选项"
# "ignoring '-mgpopt' option as it cannot be used with %select{|the implicit usage of }0-mabicalls"
H2A6F793FDFBC: "忽略 '-mgpopt' 选项，因为其不能与 %select{|the implicit usage of }0-mabicalls同时使用"
# "ignoring '-mlong-calls' option as it is not currently supported with %select{|the implicit usage of }0-mabicalls"
HD076A9DC69A3: "忽略 '-mlong-calls' 选项，因为当前不支持与 %select{|the implicit usage of }0-mabicalls同时使用"
# "ignoring '-mnan=2008' option because the '%0' architecture does not support it"
H29C27F0049E3: "忽略 '-mnan=2008' 选项，因为 '%0' 架构不支持该选项"
# "ignoring '-mnan=legacy' option because the '%0' architecture does not support it"
HADAF322768AC: "忽略 '-mnan=legacy' 选项，因为 '%0' 架构不支持该选项"
# 'ignoring -fapple-kext which is valid for C++ and Objective-C++ only'
H88A745D4B73F: '忽略仅适用于C++和Objective-C++的-fapple-kext选项'
# 'ignoring -fdiscard-value-names for LLVM Bitcode'
HC86237F887FA: '忽略LLVM比特码中的-fdiscard-value-names选项'
# "ignoring -fverify-debuginfo-preserve-export=%0 because -fverify-debuginfo-preserve wasn't enabled"
H36FCA7FF86DB: '忽略-fverify-debuginfo-preserve-export=%0 选项，因为未启用-fverify-debuginfo-preserve'
# 'ignoring __declspec(allocator) because the function return type %0 is not a pointer or reference type'
H6AAEF2701683: '忽略__declspec(allocator)，因为函数返回类型 %0 不是指针或引用类型'
# "ignoring availability attribute %select{on '+load' method|with constructor attribute|with destructor attribute}0"
H24871179ED63: "忽略%select{在 '+load' 方法上的|带有构造函数属性的|带有析构函数属性的}0可用性属性"
# "ignoring extension '%0' because the '%1' architecture does not support it"
HD131D7C5772F: "忽略扩展 '%0'，因为 '%1' 架构不支持该扩展"
# "ignoring invalid -ftabstop value '%0', using default value %1"
H55F6E19B595A: "忽略无效的-ftabstop值 '%0'，使用默认值 %1"
# "ignoring invalid /arch: argument '%0'; for %select{64|32}1-bit expected one of %2"
HF5AE60D7E4BF: "忽略无效的/arch:参数 '%0'；在 %select{64|32}1 位模式下应指定 %2 中的一个"
# 'ignoring redefinition of Objective-C qualifier macro'
HE01ADCD1C19E: '忽略Objective-C限定符宏的重复定义'
# 'ignoring return value of function declared with %0 attribute'
H0B36C4D66510: '忽略使用 %0 属性声明的函数的返回值'
# 'ignoring return value of function declared with %0 attribute%select{|: %2}1'
H9DECD2C6A7A4: '忽略声明带有 %0 属性的函数的返回值 %select{|: %2}1'
# 'ignoring temporary created by a constructor declared with %0 attribute%select{|: %2}1'
H0FFFAF84F31C: '忽略由声明带有 %0 属性的构造函数创建的临时对象 %select{|: %2}1'
# "ignoring the 'branch-protection' attribute because the '%0' architecture does not support it"
HF5FC687425B2: "由于 '%0' 架构不支持该属性，忽略 'branch-protection' 属性"
# 'illegal OpenMP user-defined mapper identifier'
H4FE25A4B348F: '非法的OpenMP用户定义映射器标识符'
# 'illegal call to %0, expected %1 argument type'
H4DEE4185FC7F: '对 %0 的非法调用，期望 %1 参数类型'
# 'illegal call to enqueue_kernel, incorrect argument types'
H96AA6DCB3DCC: '对enqueue_kernel的非法调用，参数类型不正确'
# 'illegal call to enqueue_kernel, parameter needs to be specified as integer type'
H8F7144077DA2: '对enqueue_kernel的非法调用，参数需要指定为整数类型'
# 'illegal character encoding in character literal'
H44B6CA76305B: '字符字面量中的非法字符编码'
# 'illegal character encoding in string literal'
H2EE26865FBAD: '字符串字面量中的非法字符编码'
# 'illegal device builtin %select{surface|texture}0 reference class template %1 declared here'
H7BB2FD0ACCED: '非法的设备内建 %select{surface|texture}0 引用类模板 %1 在此处声明'
# 'illegal device builtin %select{surface|texture}0 reference type %1 declared here'
H1DEC140E0334: '非法的设备内建 %select{surface|texture}0 引用类型 %1 在此处声明'
# 'illegal initializer (only variables can be initialized)'
H371A1BFF13F4: '非法的初始化器（仅变量可以被初始化）'
# 'illegal initializer type %0'
H000E8C02D9A4: '非法的初始化器类型 %0'
# 'illegal interface qualifier'
H247C18DEFCA4: '非法的接口限定符'
# 'illegal operation on Objective-C container subscripting'
H1CDC7C944B48: 'Objective-C容器下标操作的非法操作'
# 'illegal qualifiers on @catch parameter'
H2C6EDFE337AA: '@catch参数上的非法限定符'
# "illegal redeclaration of 'readwrite' property in class extension %0 (perhaps you intended this to be a 'readwrite' redeclaration of a 'readonly' public property?)"
H77F956612F13: "在类扩展 %0 中非法重新声明 'readwrite' 属性（也许您本意是重新声明一个公开的 'readonly' 属性为 'readwrite'？）"
# "illegal redeclaration of property in class extension %0 (attribute must be 'readwrite', while its primary must be 'readonly')"
HA09E774D29B3: "在类扩展 %0 中非法重新声明属性（属性必须为 'readwrite'，而其主属性必须为 'readonly'）"
# 'illegal scalar extension cast on argument %0 to %select{|in}1out paramemter'
HF91E5CAEA96B: '参数 %0 到 %select{|in}1out参数的非法标量扩展转换'
# 'illegal storage class on file-scoped variable'
H601564466459: '文件作用域变量上的非法存储类'
# 'illegal storage class on function'
H930E494BEBBE: '函数上使用了非法的存储类'
# 'illegal type %0 used in a boxed expression'
H5782BEFABE5B: '在打包表达式中使用了非法类型 %0'
# 'illegal vector component name %0'
H6F3BE393AEDE: '非法的向量组件名称 %0'
# 'illegal visibility specification'
H39F781806C46: '非法的可见性说明'
# 'imaginary constants are a C2y extension'
HAF201E910158: '虚数常量是C2y扩展'
# 'imaginary constants are a GNU extension'
H539EC610843E: '虚数常量是GNU扩展'
# 'imaginary constants are incompatible with C standards before C2y'
H8F7EDEA31FE9: '虚数常量与C2y之前的C标准不兼容'
# 'imaginary types are not supported'
H8AEF701858F7: '不支持虚数类型'
# 'immediate function %0 used before it is defined'
H1A240E8F6E49: '立即函数 %0 在其定义之前被使用'
# 'implementing deprecated %select{method|class|category}0'
H9AA979884A67: '实现已弃用的%select{方法|类|分类}0'
# 'implementing unavailable method'
H0D7D4644123A: '实现不可用的方法'
# 'implicit %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 inferred target collision: call to both %select{__device__|__global__|__host__|__host__ __device__}1 and %select{__device__|__global__|__host__|__host__ __device__}2 members'
HDD95624FC57A: '隐式%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}0推断的目标冲突：同时调用了 %select{__device__|__global__|__host__|__host__ __device__}1 和 %select{__device__|__global__|__host__|__host__ __device__}2 成员'
# "implicit '0' return value from 'main' is a C99 extension"
HDE00C37DFBCC: "隐式返回 'main' 的 '0' 值是 C99 扩展"
# 'implicit boolean conversion of Objective-C object literal always evaluates to true'
HFAC6148E9355: 'Objective-C对象字面量的隐式布尔转换始终计算为true'
# "implicit capture of 'this' with a capture default of '=' is deprecated"
H7D01BFC1D4A1: '使用默认捕获方式 "=" 隐式捕获 "this" 已弃用'
# 'implicit capture of lambda object due to conversion to block pointer here'
H9CBFA98934C5: '由于此处转换为块指针，隐式捕获了lambda对象'
# 'implicit cast from type %0 to type %1 drops __unaligned qualifier'
HBCE299280FC0: '从类型 %0 到类型 %1 的隐式转换会丢失__unaligned限定符'
# 'implicit conversion between pointer-to-function and pointer-to-object is a Microsoft extension'
HE1B9297E3DCF: '函数指针与对象指针之间的隐式转换是Microsoft扩展'
# "implicit conversion between vector types ('%0' and '%1') is deprecated; in the future, the behavior implied by '-fno-lax-vector-conversions' will be the default"
HD9008DAA3AF0: '向量类型（"%0" 和 "%1"）之间的隐式转换已弃用；未来，"-fno-lax-vector-conversions" 选项指定的行为将成为默认'
# 'implicit conversion changes signedness: %0 to %1'
H2AEC008E19C8: '隐式转换改变了符号性：%0 到 %1'
# 'implicit conversion discards imaginary component: %0 to %1'
H5E6175D2FC4A: '隐式转换丢弃了虚数部分：%0 到 %1'
# 'implicit conversion from %0 cannot fit within the range of values for %1'
HC3B95ADC5255: '来自 %0 的隐式转换无法适应 %1 的取值范围'
# 'implicit conversion from %0 to %1 changes non-zero value from %2 to %3'
H5699AB9A4A11: '来自 %0 到 %1 的隐式转换将非零值从 %2 改变为 %3'
# "implicit conversion from %0 to %1 changes the meaning of the %select{code unit|code point}2 '%3'"
HB7C90A078D7A: "从 %0 到 %1 的隐式转换改变了%select{代码单元|代码点}2 '%3' 的含义"
# 'implicit conversion from %0 to %1 changes value from %2 to %3'
H3C62B43256C2: '来自 %0 到 %1 的隐式转换将值从 %2 改变为 %3'
# "implicit conversion from %0 to %1 discards 'cfi_unchecked_callee' attribute"
HA1DC9D474D83: "从 %0 到 %1 的隐式转换丢弃了 'cfi_unchecked_callee' 属性"
# 'implicit conversion from %0 to %1 is not permitted in C++'
HD43915D50111: '在 C++ 中不允许来自 %0 到 %1 的隐式转换'
# 'implicit conversion from %0 to %1 may change the meaning of the represented code unit'
H9A77784FE5D1: '从 %0 到 %1 的隐式转换可能改变所表示代码单元的含义'
# 'implicit conversion from %0 to %1 may lose precision'
H1D559B11094C: '来自 %0 到 %1 的隐式转换可能导致精度丢失'
# 'implicit conversion from %0 to %1 may lose precision and change the meaning of the represented code unit'
HA74C62CA22F2: '从 %0 到 %1 的隐式转换可能丢失精度并改变所表示代码单元的含义'
# 'implicit conversion from %0 to enumeration type %1 is invalid in C++'
H1F403D06A877: '从 %0 到枚举类型 %1 的隐式转换在C++中无效'
# 'implicit conversion from %2 to %3 changes value from %0 to %1'
H9616CD29DFC9: '来自 %2 到 %3 的隐式转换将值从 %0 改变为 %1'
# 'implicit conversion from array size expression of type %0 to %select{integral|enumeration}1 type %2 is a C++11 extension'
H1C73815D89AE: '来自类型为 %0 的数组大小表达式的隐式转换到 %select{integral|enumeration}1 类型 %2 是 C++11 的扩展'
# 'implicit conversion from array size expression of type %0 to %select{integral|enumeration}1 type %2 is incompatible with C++98'
HBA0FE5371598: '来自类型为 %0 的数组大小表达式的隐式转换到 %select{integral|enumeration}1 类型 %2 与 C++98 不兼容'
# "implicit conversion from constant value %0 to 'BOOL'; the only well defined values for 'BOOL' are YES and NO"
H9F3E57EE843E: "来自常量值 %0 到 'BOOL' 的隐式转换；'BOOL' 的唯一定义值是 YES 和 NO"
# 'implicit conversion from enumeration type %0 to different enumeration type %1'
HEE824DA3A047: '来自枚举类型 %0 到不同枚举类型 %1 的隐式转换'
# "implicit conversion from floating-point type %0 to 'BOOL'"
H4747E2EB6787: "来自浮点类型 %0 到 'BOOL' 的隐式转换"
# "implicit conversion from integral type %0 to 'BOOL'"
H2BF4B2ABD201: "来自整数类型 %0 到 'BOOL' 的隐式转换"
# 'implicit conversion from nullable pointer %0 to non-nullable pointer type %1'
H2C9C47D2B30E: '来自可为空指针 %0 到不可为空指针类型 %1 的隐式转换'
# 'implicit conversion increases floating-point precision: %0 to %1'
HA48CBAE7D71E: '隐式转换提升浮点精度：%0 到 %1'
# 'implicit conversion loses floating-point precision: %0 to %1'
H8151E8B82266: '隐式转换丢失浮点精度：%0 到 %1'
# 'implicit conversion loses integer precision: %0 to %1'
H7E75B58A91F6: '隐式转换丢失整数精度：%0 到 %1'
# 'implicit conversion loses integer precision: %0 to %1 on negation'
H166C8894D74F: '隐式转换丢失整数精度：%0 到 %1 在取反时'
# 'implicit conversion of %select{NULL|nullptr}0 constant to %1'
H81DB38ED2223: '%select{NULL|nullptr}0 常量到 %1 的隐式转换'
# 'implicit conversion of out of range value from %0 to %1 is undefined'
H60829B0B819C: '来自 %0 到 %1 的隐式转换超出范围的值是未定义的'
# 'implicit conversion truncates vector: %0 to %1'
H678147335701: '隐式转换截断向量：%0 到 %1'
# 'implicit conversion turns floating-point number into bool: %0 to %1'
HBD45EEBA1C30: '隐式转换将浮点数转为 bool：%0 到 %1'
# 'implicit conversion turns floating-point number into integer: %0 to %1'
H1859EAB52A1F: '隐式转换将浮点数转换为整数：%0 到 %1'
# 'implicit conversion turns string literal into bool: %0 to %1'
H0BABC92466FD: '隐式转换将字符串字面量转换为布尔值：%0 到 %1'
# 'implicit conversion turns vector to scalar: %0 to %1'
HB2E373F67C4B: '隐式转换将向量转换为标量：%0 到 %1'
# 'implicit conversion when %select{%diff{assigning to $ from type $|assigning to type from type}0,1|%diff{passing $ to parameter of type $|passing type to parameter of type}0,1|%diff{returning $ from a function with result type $|returning type from a function with result type}0,1|<CLANG BUG IF YOU SEE THIS>|%diff{initializing $ with an expression of type $|initializing type with an expression of type}0,1|%diff{sending $ to parameter of type $|sending type to parameter of type}0,1|<CLANG BUG IF YOU SEE THIS>}2 is not permitted in C++'
H0D8004D76948: '当 %select{%diff{将$赋值给类型为$的参数|将类型赋值给类型}1,0|%diff{将$传递给类型为$的参数|将类型传递给类型参数}1,0|%diff{从返回类型为$的函数返回$|从不同返回类型的函数返回}1,0|<CLANG BUG IF YOU SEE THIS>|%diff{用类型为$的表达式初始化$|用表达式类型初始化类型}1,0|%diff{将$发送到类型为$的参数|将类型发送到类型参数}1,0|<CLANG BUG IF YOU SEE THIS>}2 时不允许隐式转换（在C++中）'
# 'implicit conversion when assigning computation result loses floating-point precision: %0 to %1'
H063DB898AD67: '赋值时的隐式转换导致浮点精度丢失：%0 到 %1'
# 'implicit conversions between vector types (%0 and %1) are not permitted'
HDD25DAA03F93: '向量类型之间的隐式转换（%0 和 %1）不允许'
# 'implicit declaration introduced by elaborated type conflicts with a %select{non-struct type|non-class type|non-union type|non-enum type|typedef|type alias|template|type alias template|template template argument}0 of the same name'
H0AA0DBCCB1F5: '通过显式类型引入的隐式声明与同名的%select{非结构体类型|非类类型|非联合类型|非枚举类型|typedef|类型别名|模板|类型别名模板|模板模板参数}0冲突'
# 'implicit declaration of function %0'
H1E9139CA3E1D: '函数 %0 的隐式声明'
# "implicit deduction guide declared as '%0'"
H2EE915923496: "隐式推导指引声明为 '%0'"
# 'implicit default constructor suppressed by user-declared constructor'
H2B519469152F: '用户声明的构造函数抑制了隐式默认构造函数'
# 'implicit instantiation of undefined member %0'
H2427990A2EAB: '未定义成员 %0 的隐式实例化'
# 'implicit truncation from %2 to a one-bit wide bit-field changes value from %0 to %1'
H46C1BDEE4300: '从 %2 截断到 1 位宽的位域时，值从 %0 变为 %1'
# 'implicit truncation from %2 to bit-field changes value from %0 to %1'
HB32D8742297B: '从 %2 截断到位域时，值从 %0 变为 %1'
# 'implicit use of sequentially-consistent atomic may incur stronger memory barriers than necessary'
H162AB39C9F24: '隐式使用顺序一致的原子操作可能导致不必要的更强内存屏障'
# "implicitly declaring library function '%0' with type %1"
H452F7C0F821A: "隐式声明库函数 '%0' 的类型为 %1"
# 'implicitly determined as %0'
HD0131FA6D64A: '隐式确定为 %0'
# "implicitly disabling vptr sanitizer because rtti wasn't enabled"
HABA9C105D8F8: '隐式禁用 vptr sanitizer 因为未启用 rtti'
# "implicitly treating version as '%0'"
H5C5C4BA079A3: "隐式将版本视为 '%0'"
# 'import %select{module|name}0 (%1) does not match the import %select{module|name}0 (%2) of the previous declaration'
HE913E2E83F88: '导入的%select{模块|名称}0（%1）与先前声明的%select{模块|名称}0（%2）不匹配'
# 'import %select{module|name}0 cannot be applied to a function with a definition'
HB24CB23A8286: '无法将具有定义的函数应用%select{模块|名称}0导入'
# 'import of C++ module \'%0\' appears within extern "C" language linkage specification'
HDAEE51A4DB06: 'C++ 模块导入 \'%0\' 出现在 extern "C" 语言链接规范内'
# "import of module '%0' appears within %1"
H08448256C67A: "模块 '%0' 的导入出现在 %1 内"
# "import of module '%0' appears within its own %select{interface|implementation}1"
HBF7F549ECBD5: "模块 '%0' 的导入出现在其自身的 %select{接口|实现}1 中"
# "import of module '%0' appears within same top-level module '%1'"
H25D86D4DF122: "模块 '%0' 的导入出现在同一顶层模块 '%1' 内"
# "import of module '%0' imported non C++20 importable modules"
H861EDFB67C5B: "导入了被遮蔽的模块 '%0'"
# "import of shadowed module '%0'"
HECE190C4501D: "导入被遮蔽的模块 '%0'"
# "imported AST from '%0' had been generated for a different target, current: %1, imported: %2"
H30A99270FD50: "从 '%0' 导入的 AST 是为不同目标生成的，当前目标: %1，导入目标: %2"
# "imported by %select{|module '%2' in }1'%0'"
HBA6CF98B38A4: "通过%select{ |模块 '%2' 在}1'%0' 导入"
# 'importing an implementation partition unit in a module interface is not recommended. Names from %0 may not be reachable'
H4BCD18B5E018: '在模块接口中导入实现分区单元不被推荐。%0 中的名称可能无法访问'
# "importing module '%0'%select{| into '%3'}2 from '%1'"
HD074A7D9BA2D: "从 '%1'%select{ |到 '%3'}2 导入模块 '%0'"
# 'imports must immediately follow the module declaration'
H25C0CF982742: '导入必须紧跟模块声明之后'
# 'impossible constraint in asm: cannot store value into a register'
HEC9C616BA3F9: 'asm中不可能的约束：无法将值存储到寄存器'
# 'in %select{implicit|defaulted}0 %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}1 for %2 first required here'
H7F88B1ED021A: '在%select{隐式|默认}0 %select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}1为 %2 首次需要此处'
# "in call to '%0'"
H5F44B6591F5A: "在转储结构体时，调用带有参数 '(%0)' 的打印函数"
# "in call to printing function with arguments '(%0)' while dumping struct"
H5B10BE57CF69: "在转储结构时调用参数为 '(%0)' 的打印函数"
# 'in defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator for %1 first required here'
H41C2C013E2E2: '在 %1 的默认 %select{<ERROR>|相等|三向|相等|关系}0比较运算符中首次需要此处'
# 'in evaluating default argument here'
HA6EC671D8C49: '在此处求值默认参数'
# 'in evaluation of exception specification for %q0 needed here'
H94CE96486393: '在求值%q0所需的异常规范时'
# 'in first definition, possible difference is here'
HAF3474709EF4: '在首次定义中，可能的差异在此处'
# "in implicit call to 'operator%select{!=|*|++}0' for iterator of type %1"
HA1274A4A4765: "在类型 %1 的迭代器隐式调用 'operator%select{!=|*|++}0' 运算符时"
# 'in implicit initialization for inherited constructor of %0'
HE4CCA87F39AA: '在继承构造函数 %0 的隐式初始化中'
# 'in implicit initialization of %select{array element %1 with omitted initializer|field %1 with omitted initializer|trailing array elements in runtime-sized array new}0'
HD4BCA75D333B: '在隐式初始化%select{省略初始值的数组元素 %1|省略初始值的域 %1|运行时尺寸数组new的末尾数组元素}0时'
# 'in implicit initialization of binding declaration %0'
H6B3B1A4A0790: '在初始化此处需要的绑定声明 %0 时'
# 'in initialization of temporary of type %0 created to list-initialize this reference'
H5C5815C0F326: '在初始化为此引用进行列表初始化(type %0 类型)创建的临时对象时'
# "in instantiation of default argument for '%0' required here"
H920C89F748D0: '在实例化 %0 的默认参数时需要此处'
# "in instantiation of default function argument expression for '%0' required here"
H05CBF7F0C1EE: '在实例化 %0 的默认函数参数表达式时需要此处'
# 'in instantiation of default member initializer %q0 requested here'
HD2F44CDF38B1: '在实例化此处请求的默认成员初始化器%q0时'
# 'in instantiation of enumeration %q0 requested here'
H6EB646EE227A: '在实例化此处请求的枚举%q0时'
# 'in instantiation of exception specification for %0 requested here'
H3C01A542E6EB: '在实例化此处请求的 %0 异常说明时'
# 'in instantiation of function template specialization %q0 requested here'
HAEB9C4D2EE7B: '在实例化此处请求的函数模板特化%q0时'
# 'in instantiation of member class %q0 requested here'
H5CE23327E7F1: '在实例化此处请求的成员类%q0时'
# 'in instantiation of member function %q0 requested here'
H748A89FD0314: '在实例化此处请求的成员函数%q0时'
# 'in instantiation of requirement here'
HE12670012001: '在实例化此处的约束条件时'
# 'in instantiation of requirement parameters here'
HCD143B7FE64F: '在实例化此处的约束参数时'
# 'in instantiation of static data member %q0 requested here'
H0491530140D7: '在实例化此处请求的静态数据成员%q0时'
# 'in instantiation of template class %q0 requested here'
H65B85839EF55: '在实例化此处请求的模板类%q0时'
# 'in instantiation of template type alias %0 requested here'
HAECA7764FC0E: '在实例化此处请求的模板类型别名 %0 时'
# 'in instantiation of variable template specialization %q0 requested here'
H0FA1B781E861: '在实例化此处请求的变量模板特化%q0时'
# 'in lowering create ArrayCoorOp instead of CoordinateOp'
H38357B1F88DE: '在降级时创建ArrayCoorOp而非CoordinateOp'
# 'in non-LBR mode, guess edge counts using iterative technique'
H7372BDB68057: '在非LBR模式下，使用迭代技术推测边数'
# "in pattern '%1': %0"
H2F43FF1537BC: "在模式 '%1' 中：%0"
# 'in relocation mode trap upon entry to any function that uses AVX-512 instructions'
H082BA4E3D29F: '在重定位模式下，进入任何使用AVX-512指令的函数时触发陷阱'
# 'in second definition, possible difference is here'
HEC9D50C16660: '在第二个定义中，可能的差异在此处'
# 'in template expansion here'
H1E2D3625EAB4: '在模板展开时此处'
# 'in the default initializer of %0'
H6D9691DC0D28: '在 %0 的默认初始化器中'
# 'in value-initialization of type %0 here'
H74E349C94BB1: '在此处 %0 类型的值初始化中'
# 'in%select{| implicit}0 constructor here'
H24F20A5C047E: '在 %select{| 隐式}0构造函数中'
# 'in-class initializer for static data member is not a constant expression'
H9B69A27F211E: '类内静态数据成员的初始值设定项不是常量表达式'
# 'in-class initializer for static data member is not a constant expression; folding it to a constant is a GNU extension'
HA2848C2F37A8: '类内静态数据成员的初始值设定项不是常量表达式；将其折叠为常量是GNU扩展'
# 'in-class initializer for static data member of type %0 is a GNU extension'
H46A5C414A183: '类型 %0 的类内静态数据成员初始值设定项是GNU扩展'
# "in-class initializer for static data member of type %0 requires 'constexpr' specifier"
H7E9F22B76B86: '类型 %0 的类内静态数据成员需要添加constexpr限定符'
# 'in_reduction variable must have the same reduction operation as in a task_reduction clause'
H7647CFB2C410: '规约变量必须与任务规约条款中的规约操作一致'
# 'include a detailed record of preprocessing actions'
H4B25771F85AC: '包含预处理操作的详细记录'
# "include location '%0' is unsafe for cross-compilation"
H62F3D6400A8A: '交叉编译时，包含位置 %0 存在安全风险'
# 'include module search paths'
HFFA588262B00: '包含模块搜索路径'
# "include of non-modular header inside framework module '%0': '%1'"
H82B29FF5B7DD: '在框架模块 %0 内包含非模块化头文件：%1'
# "include of non-modular header inside module '%0': '%1'"
H747C5EDF3216: '在模块 %0 内包含非模块化头文件：%1'
# "include path for libstdc++ headers not found; pass '-stdlib=libc++' on the command line to use the libc++ standard library instead"
H45B1E0C04AB4: '未找到libstdc++头文件的包含路径；请通过命令行传递-stdlib=libc++以改用libc++标准库'
# 'include search path'
H43B868761DFC: '包含搜索路径'
# "include the header <%0> or explicitly provide a declaration for '%1'"
HBFC18315E2CB: '包含头文件 <%0> 或显式为 %1 提供声明'
# 'incompatible block pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2'
HA4D550DCCECE: '不兼容的块指针类型 %select{%diff{将$赋值给$|将不同类型赋值}0,1|%diff{将$传给类型$的参数|传给不同类型参数}0,1|%diff{从结果类型为$的函数返回$|从函数返回不同类型}1,0|%diff{将$转换为类型$|转换类型}0,1|%diff{用类型$的表达式初始化$|用不同类型的表达式初始化}0,1|%diff{将$发送给类型$的参数|发送给不同类型参数}0,1|%diff{将$转换为类型$|转换类型}0,1}2'
# 'incompatible constant for this __builtin_neon function'
H338324E39A33: '该__builtin_neon函数的常量参数类型不兼容'
# 'incompatible function pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3'
H803DA0209C00: '不兼容的函数指针类型 %select{%diff{将$赋值给$|将不同类型赋值}0,1|%diff{将$传给类型$的参数|传给不同类型参数}0,1|%diff{从结果类型为$的函数返回$|从函数返回不同类型}1,0|%diff{将$转换为类型$|转换类型}0,1|%diff{用类型$的表达式初始化$|用不同类型的表达式初始化}0,1|%diff{将$发送给类型$的参数|发送给不同类型参数}0,1|%diff{将$转换为类型$|转换类型}0,1}2%select{|; 使用*解引用|; 使用&取地址|; 移除*|; 移除&}3'
# 'incompatible integer to pointer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3'
H48B50F4A5A68: '不兼容的整数到指针转换 %select{%diff{将$赋值给$|将不同类型赋值}0,1|%diff{将$传给类型$的参数|传给不同类型参数}0,1|%diff{从结果类型为$的函数返回$|从函数返回不同类型}1,0|%diff{将$转换为类型$|转换类型}0,1|%diff{用类型$的表达式初始化$|用不同类型的表达式初始化}0,1|%diff{将$发送给类型$的参数|发送给不同类型参数}0,1|%diff{将$转换为类型$|转换类型}0,1}2%select{|; 使用*解引用|; 使用&取地址|; 移除*|; 移除&}3'
# 'incompatible operand types (%0 and %1)'
HCEE400E94353: '不兼容的操作数类型（%0 和 %1）'
# 'incompatible operand types%diff{ ($ and $)|}0,1'
H1FD3FD989888: '不兼容的操作数类型%diff{ ($和$)|}0,1'
# 'incompatible pointer to integer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3'
HFD878F5F2922: '不兼容的指针到整数转换 %select{%diff{将$赋值给$|将不同类型赋值}0,1|%diff{将$传给类型$的参数|传给不同类型参数}0,1|%diff{从结果类型为$的函数返回$|从函数返回不同类型}1,0|%diff{将$转换为类型$|转换类型}0,1|%diff{用类型$的表达式初始化$|用不同类型的表达式初始化}0,1|%diff{将$发送给类型$的参数|发送给不同类型参数}0,1|%diff{将$转换为类型$|转换类型}0,1}2%select{|; 使用*解引用|; 使用&取地址|; 移除*|; 移除&}3'
# 'incompatible pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3'
HBA7B4F7FCD76: '指针类型不兼容 %select{%diff{将$赋给$|将不同类型赋值}0,1|%diff{将$传给类型为$的参数|传给不同类型的参数}0,1|%diff{从结果类型为$的函数返回$|函数返回类型不匹配}1,0|%diff{将$转换为类型$|类型间转换}0,1|%diff{用类型$的表达式初始化$|用不同类型的表达式初始化}0,1|%diff{将$传给类型为$的参数|传给不同类型的参数}0,1|%diff{将$转换为类型$|类型间转换}0,1}2%select{|; 使用*解引用|; 取地址使用&|; 移除*|; 移除&}3'
# 'incompatible pointer types passing retainable parameter of type %0to a CF function expecting %1 type'
H85C3F4475A3D: '将类型 %0 的可保留参数传给期望类型 %1 的CF函数时指针类型不兼容'
# 'incompatible redeclaration of library function %0'
H4DCB8A7133E4: '库函数 %0 的不兼容重声明'
# 'incompatible types casting %0 to %1 with a %select{__bridge|__bridge_transfer|__bridge_retained}2 cast'
HA70D951974C7: '使用 %select{__bridge|__bridge_transfer|__bridge_retained}2 类型转换将 %0 转为 %1 时类型不兼容'
# 'incompatible vector types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2'
H349444057F6C: '向量类型不兼容 %select{%diff{将$赋给$|将不同类型赋值}0,1|%diff{将$传给类型为$的参数|传给不同类型的参数}0,1|%diff{从结果类型为$的函数返回$|函数返回类型不匹配}1,0|%diff{将$转换为类型$|类型间转换}0,1|%diff{用类型$的表达式初始化$|用不同类型的表达式初始化}0,1|%diff{将$传给类型为$的参数|传给不同类型的参数}0,1|%diff{将$转换为类型$|类型间转换}0,1}2'
# 'incomplete definition of type %0'
H74F733EC60E9: '类型 %0 的定义不完整'
# "incomplete delimited universal character name; treating as '\\' '%0' '{' identifier"
H45A3D640545C: "不完整的限定通用名称; 将视为 '\\' '%0' '{' 标识符"
# 'incomplete format specifier'
HC2682570C017: '格式说明符不完整'
# 'incomplete receiver type %0'
H6C117CF6E37A: '接收者类型 %0 不完整'
# 'incomplete result type %0 in function definition'
HA8E1F3068B20: '函数定义中结果类型 %0 不完整'
# 'incomplete result type %0 in lambda expression'
H69E2641DED85: 'lambda表达式中结果类型 %0 不完整'
# "incomplete type %0 in a '_Generic' association is a C2y extension"
H7D3852AE4A16: "'_Generic' 关联中的不完整类型 %0 是C2y扩展"
# 'incomplete type %0 is not a literal type'
H8AFDEC1F2348: '不完整类型 %0 不是字面类型'
# 'incomplete type %0 is not assignable'
HF862B3215822: '不完整类型 %0 不可赋值'
# 'incomplete type %0 named in nested name specifier'
HCA7665DF5910: '嵌套命名限定符中指定的不完整类型 %0'
# 'incomplete type %0 used in a boxed expression'
HF426C73BD83F: '在包装表达式中使用不完整类型 %0'
# 'incomplete type %0 used in type trait expression'
H4539C0CCBFB9: '在类型特征表达式中使用不完整类型 %0'
# 'incomplete type %0 where a complete type is required'
H95C11FF1D056: '在需要完整类型的位置使用不完整类型 %0'
# 'incomplete type in call to object of type %0'
HB57B0356D109: '调用类型 %0 的对象时使用了不完整类型'
# 'incomplete universal character name'
H0184822E59BB: '通用名称不完整'
# "incomplete universal character name; treating as '\\' followed by identifier"
H5B8C01DBAD90: "不完整的通用字符名；视为 '\\' 后跟标识符"
# 'inconsistent number of instance variables specified'
H7EB07F9DCA1E: '指定的实例变量数量不一致'
# "incorrect 'adjust_args' type, expected 'need_device_ptr'%select{|, 'need_device_addr',}0 or 'nothing'"
H1403BB6ED4C3: "不正确的 'adjust_args' 类型，期望 'need_device_ptr'%select{|, 'need_device_addr',}0 或 'nothing'"
# 'incorrect format for -preamble-bytes=N,END'
HD764A19076F3: '-preamble-bytes=N,END 的格式不正确'
# "incorrect map type modifier, expected one of: 'always', 'close', 'mapper'%select{|, 'present'|, 'present', 'iterator'}0%select{|, 'ompx_hold'}1%select{|, 'self'}2"
H6BCE6C4F91C6: "错误的映射类型修饰符，期望其中一个：'always', 'close', 'mapper'%select{|, 'present'|, 'present', 'iterator'}0%select{|, 'ompx_hold'}1%select{|, 'self'}2"
# "incorrect map type, expected one of 'to', 'from', 'tofrom', 'alloc', 'release', or 'delete'"
HFC0556B7E292: "错误的映射类型，期望其中一个：'to', 'from', 'tofrom', 'alloc', 'release' 或 'delete'"
# 'incorrect number of bits in integer (expected %0 bits, have %1)'
H39F86512F6F1: '整数中的位数不正确（期望 %0 位，但实际为 %1 位）'
# 'incorrect number of bits in vector operand (expected %select{|a multiple of}0 %1 bits, have %2)'
HDF4134C84931: '向量操作数位数不正确（期望%select{ |的倍数}0%1 位，实际 %2 位）'
# "incorrect reduction identifier, expected one of '+', '*', '&', '|', '^', '&&', '||', 'min' or 'max' or declare reduction for type %0"
HD90D2B65D413: "错误的规约标识符，期望其中一个：'+'、'*'、'max'、'min'、'&'、'|'、'^'、'&&'、'||' 或为类型 %0 声明规约"
# "incorrect reduction identifier, expected one of '+', '-', '*', '&', '|', '^', '&&', '||', 'min' or 'max' or declare reduction for type %0"
HC80B58A26C84: "错误的规约标识符，期望其中一个：'+'、'-'、'*'、'&'、'|'、'^'、'&&'、'||'、'min' 或 'max' 或为类型 %0 声明规约"
# 'incorrect use of #pragma clang force_cuda_host_device begin|end'
HB4E983FB1A7D: '错误使用 #pragma clang force_cuda_host_device begin|end'
# "incorrect use of '#pragma fenv_access (on|off)' - ignored"
HB0DD6B333D8B: '#pragma fenv_access (on|off) 的使用不正确 - 已忽略'
# "incorrect use of '#pragma ms_struct on|off' - ignored"
HB1C2DABF7753: '#pragma ms_struct on|off 的使用不正确 - 已忽略'
# 'increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable %0'
H1F62FE8343E9: 'OpenMP for循环的增量子句必须对循环变量 %0 执行简单的加法或减法'
# 'increment expression must cause %0 to %select{decrease|increase}1 on each iteration of OpenMP for loop'
H6AE9805023F0: '增量表达式必须在每次OpenMP for循环迭代中使 %0 %select{减少|增加}1'
# 'incremented enumerator value %0 is not representable in the largest integer type'
H33F55260A9EF: '递增的枚举值 %0 无法用最大的整数类型表示'
# 'incrementing expression of type bool is deprecated and incompatible with C++17'
HB438D9D07956: 'bool类型的递增表达式已弃用，并与C++17不兼容'
# 'increments 8-bit counter for every edge'
H286B107846BC: '为每条边递增 8 位计数器'
# "indeterminate value can only initialize an object of type 'unsigned char'%select{, 'char',|}1 or 'std::byte'; %0 is invalid"
H26C79B7B3090: "不确定的值只能初始化类型为 'unsigned char'%select{, 'char',|}1 或 'std::byte' 的对象；%0 无效"
# 'index %0 must appear exactly once in the permutation clause'
H907BCB3D7A64: '索引 %0 必须在排列子句中恰好出现一次'
# 'index for __builtin_shufflevector must be a constant integer'
H2AA72873C8D9: '__builtin_shufflevector的索引必须是常量整数'
# 'index for __builtin_shufflevector must be less than the total number of vector elements'
HDC5D16284BAC: '__builtin_shufflevector 的索引必须小于向量元素的总数'
# 'index for __builtin_shufflevector not within the bounds of the input vectors; index of -1 found at position %0 is not permitted in a constexpr context'
H0F3D61BA78F9: '__builtin_shufflevector 的索引超出输入向量的边界；在位置 %0 发现的 -1 索引在 constexpr 上下文中不允许'
# 'indexing expression is invalid because subscript type %0 has multiple type conversion functions'
H28D375C7CDB6: '下标表达式无效，因为下标类型 %0 具有多个类型转换函数'
# 'indexing expression is invalid because subscript type %0 is not an Objective-C pointer'
H76E63693A71C: '下标表达式无效，因为下标类型 %0 不是 Objective-C 指针'
# 'indexing expression is invalid because subscript type %0 is not an integral or Objective-C pointer type'
H5DB003FBDC67: '下标表达式无效，因为下标类型 %0 不是整型或 Objective-C 指针类型'
# 'indexing of array without known bound is not allowed in a constant expression'
HE2B8FD1CE633: '在常量表达式中不允许对未知边界的数组进行下标访问'
# 'indirect call promotion'
H63A9B36F7D0A: '间接调用提升'
# 'indirect goto in function with no address-of-label expressions'
H145FEAAFA432: '在没有标签地址表达式的函数中使用间接 goto'
# 'indirection not permitted on operand of type %0'
H2DF3DCAF7C13: '操作数类型 %0 不允许进行间接寻址'
# 'indirection of non-volatile null pointer will be deleted, not trap'
H016B5CE240D6: '对非易失性空指针的间接寻址将被删除，而非触发异常'
# 'indirection requires pointer operand (%0 invalid)'
H17A67BCCC65A: '间接寻址需要指针操作数 (%0 无效)'
# 'infer execution count for fall-through blocks'
H5D8BF838CEAA: '推断穿透块的执行次数'
# "inferred framework modules cannot be 'explicit'"
HAC0CEE5A9591: '推断的框架模块不能是 `explicit`'
# 'inferred submodule cannot be a framework submodule'
H3C9148B14284: '推断的子模块不能是框架子模块'
# 'inferred submodules require a module with an umbrella'
HB4F6C039EA5A: '推断的子模块需要一个具有顶层模块的模块'
# "inferring '_Nonnull' for pointer type within %select{array|reference}0 is deprecated"
H0BCF4D33599B: '在 %select{数组|引用}0 中为指针类型推断 `_Nonnull` 已弃用'
# 'inheritance model does not match %select{definition|previous declaration}0'
H6F4F77A5056C: '继承模型与 %select{定义|之前的声明}0 不匹配'
# 'inheritance model ignored on %select{primary template|partial specialization}0'
H5E5E4985C4D2: '在 %select{主模板|偏特化}0 上忽略继承模型'
# 'inherited from base class %0 here'
H942CB9135C88: '从此基类 %0 继承而来'
# 'inherited virtual base class %1 has %select{private|protected}2 destructor'
HC776172C0FE5: '继承的虚基类 %1 具有 %select{私有|保护}2 析构函数'
# 'inheriting constructors are incompatible with C++98'
H811CC4188AC3: '继承构造函数与 C++98 不兼容'
# 'inherits from superclass %0 here'
HFC19FC83A6FB: '从此父类 %0 继承'
# 'init method must return a type related to its receiver type'
HE0B5DF2EAC96: 'init方法必须返回与其接收器类型相关的类型'
# 'init methods must return a type related to the receiver type'
H77EF2E241D1F: 'init方法必须返回与接收器类型相关的类型'
# 'init methods must return an object pointer type, not %0'
HA49BF476668F: 'init方法必须返回对象指针类型，而非 %0'
# "initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')"
H55BD0EE327C7: 'OpenMP for循环的初始化子句不在规范形式（var = init 或 T var = init）'
# 'initialization is not supported for __shared__ variables'
H36A01643C5A6: '__shared__变量的初始化不受支持'
# 'initialization of %0 may run twice when built into a shared library: it has hidden visibility and external linkage'
H8FC0CAE3AC23: '具有隐藏可见性和外部链接性的 %0 初始化在构建为共享库时可能执行两次'
# "initialization of %select{|signed }0char array with UTF-8 string literal is not permitted by %select{'-fchar8_t'|C++20}1"
H2A8B3176C3CF: "使用 %select{'-fchar8_t'|C++20}1 时不允许用UTF-8字符串字面量初始化%select{有符号 |}0char数组"
# 'initialization of an array %diff{of type $ from a compound literal of type $|from a compound literal}0,1 is a GNU extension'
HA729653B7153: '从复合字面量类型$初始化数组%diff{类型$到|来自}0,1的扩展是GNU扩展'
# 'initialization of flexible array member is not allowed'
H080F42BFBE3B: '不允许初始化柔性数组成员'
# 'initialization of incomplete type %0'
H8382A60542C7: '初始化不完整类型 %0'
# 'initialization of initializer_list object is incompatible with C++98'
HB868A7DFE86A: 'initializer_list对象的初始化与C++98不兼容'
# 'initialization of non-aggregate type %0 with a designated initializer list'
HD9BEB3E28681: '使用指定初始化列表初始化非聚合类型 %0'
# 'initialization of non-aggregate type %0 with an initializer list'
HD61976EAB0C6: '使用初始化列表初始化非聚合类型 %0'
# 'initialization of pointer of type %0 to null from a constant boolean expression'
HF7B6BD10B980: '从常量布尔表达式将类型 %0 指针初始化为null'
# 'initialization statement is not supported when iterating over Objective-C collection'
H6990A52E0D21: '在遍历Objective-C集合时不支持初始化语句'
# 'initialize the variable %0 to silence this warning'
HFBFEA45EAD29: '初始化变量 %0 以消除此警告'
# 'initialized flexible array member %0 is here'
H040CBD4967B6: '此处初始化了柔性数组成员 %0'
# 'initialized here %0'
H6E543F660366: '此处初始化 %0'
# 'initialized lambda capture packs are incompatible with C++ standards before C++20'
H4508A321B7A7: '已初始化的lambda捕获包与C++20之前的标准不兼容'
# 'initialized lambda captures are a C++14 extension'
HE17291BEDE3D: '已初始化的lambda捕获是C++14扩展'
# 'initialized lambda captures are incompatible with C++ standards before C++14'
H4B4A5D06C778: 'C++14之前的C++标准不支持初始化的lambda捕获'
# 'initialized lambda pack captures are a C++20 extension'
H7BA4847E4BDF: '初始化的lambda包捕获是C++20扩展特性'
# 'initializer %0 does not name a non-static data member or base class; did you mean the %select{base class|member}1 %2?'
HBFA8CB0E43F8: '初始化器 %0 未命名非静态数据成员或基类；是否指%select{基类|成员}1%2？'
# 'initializer %select{partially |}0overrides prior initialization of this subobject'
H5DE4CB24B2D2: '初始化器%select{部分|}0 覆盖了此子对象的先前初始化'
# 'initializer element is not a compile-time constant'
H132D68BCCE73: '初始化器元素不是编译时常量'
# 'initializer for aggregate is not a compile-time constant'
H6A5ECCAF1E62: '聚合类型的初始化器不是编译时常量'
# 'initializer for aggregate with no elements requires explicit braces'
H2820D73AEF2F: '无元素的聚合类型初始化需要显式的大括号'
# 'initializer for functional-style cast to %0 contains multiple expressions'
H98881129A20C: '对 %0 的函数式类型转换初始化器包含多个表达式'
# 'initializer for functional-style cast to %0 is empty'
H4EA4C8E23F55: '对 %0 的函数式类型转换初始化器为空'
# 'initializer for lambda capture %0 contains multiple expressions'
H66A3A7273E8A: 'lambda捕获 %0 的初始化器包含多个表达式'
# 'initializer for sizeless type %0 cannot be empty'
H8FFA617F38FD: '无大小类型 %0 的初始化器不能为空'
# 'initializer for thread-local variable must be a constant expression'
HD7C0523C87D0: '线程局部变量的初始化器必须是常量表达式'
# 'initializer for variable %0 with type %1 contains multiple expressions'
HA7D83169E121: '变量 %0（类型 %1）的初始化器包含多个表达式'
# 'initializer for variable %0 with type %1 is empty'
HD6A61B62F49C: '变量 %0（类型 %1）的初始化器为空'
# 'initializer for virtual base class %0 of abstract class %1 will never be used'
H377D13F4BA4B: '抽象类 %1 的虚基类 %0 初始化器永远不会被使用'
# "initializer list cannot be used on the %select{left|right}0 hand side of operator '%1'"
H08A1BB46A564: '运算符 "%1" 的%select{左|右}0边不能使用初始化列表'
# 'initializer missing for lambda capture %0'
H362962332DA4: 'lambda捕获 %0 缺少初始化器'
# 'initializer of %0 is not a constant expression'
HF34500BAECA9: '%0 的初始化器不是常量表达式'
# 'initializer of %0 is unknown'
H4815D272C20B: '%0 的初始化器未知'
# 'initializer of weak variable %0 is not considered constant because it may be different at runtime'
HBD6BC73EA44F: '弱符号变量 %0 的初始化器在运行时可能不同，因此不被视为常量'
# 'initializer on function does not look like a pure-specifier'
H79A85F4AF5C7: '函数上的初始化器看起来不像纯说明符'
# 'initializer order does not match the declaration order'
HBA21FCA776B9: '初始化器顺序与声明顺序不匹配'
# 'initializer priorities are not supported in HLSL'
HFAA073E424F4: 'HLSL不支持初始化器优先级'
# 'initializer would partially override prior initialization of object of type %1 with non-trivial destruction'
H52C4E394B1C2: '初始化器将部分覆盖类型 %1 的先前初始化，该类型具有非平凡的析构函数'
# 'initializer-string for char array is too long'
HF948F6263A8D: '字符数组的初始化字符串太长'
# 'initializer-string for char array is too long, array size is %0 but initializer has size %1 (including the null terminating character)'
H17CD335B9F9F: '字符数组的初始化字符串太长，数组大小为 %0，但初始化器的大小为 %1（包括空终止字符）'
# 'initializer-string for character array is too long for C++, array size is %0 but initializer has size %1 (including the null terminating character)'
H1C3EADBC5750: '字符数组的初始化字符串长度过长（C++标准），数组大小为 %0 但初始化器大小为 %1（包含空终止符）'
# "initializer-string for character array is too long, array size is %0 but initializer has size %1 (including the null terminating character); did you mean to use the 'nonstring' attribute?"
H4D31F68C37C8: "字符数组的初始化字符串过长，数组大小为 %0，但初始化器大小为 %1（包含空终止符）；您是否想使用 'nonstring' 属性？"
# 'initializing %0 from an empty initializer list is incompatible with C++98'
H822723DC0E42: '从空初始化列表初始化 %0 与C++98不兼容'
# "initializing 'char8_t' array with plain string literal"
H1EA4AB240813: "使用普通字符串字面量初始化 'char8_t' 数组"
# 'initializing an array from a %0 predefined identifier is a Microsoft extension'
HF1EC87683FC5: '使用预定义标识符 %0 初始化数组是 Microsoft 扩展'
# 'initializing char array with wide string literal'
H698D73717CFB: '使用宽字符串字面量初始化字符数组'
# 'initializing field %0 with default member initializer'
HC1BC6A14F9CB: '使用默认成员初始化器初始化字段 %0'
# 'initializing multiple members of union'
HC7C97F10525A: '初始化联合的多个成员'
# 'initializing parameter %0 with default argument'
H20102CE039A6: '使用默认参数值初始化参数 %0'
# 'initializing pointer member %0 to point to a temporary object whose lifetime is shorter than the lifetime of the constructed object'
H705DCA77F9DC: '指针成员 %0 被初始化为指向构造对象生命周期较短的临时对象'
# 'initializing pointer member %0 with the stack address of %select{variable|parameter}2 %1'
HF09BD5727610: '指针成员 %0 被初始化为%select{变量|参数}2 %1 的栈地址'
# 'initializing wide char array with incompatible wide string literal'
HA0905D8F9102: '使用不兼容的宽字符串字面量初始化宽字符数组'
# 'initializing wide char array with non-wide string literal'
H708EA2B0EAB3: '使用非宽字符串字面量初始化宽字符数组'
# 'inline all checks'
HF0EA4880CACC: '内联所有检查'
# 'inline all functions'
HEE76F6E2509B: '内联所有函数'
# 'inline assembly label %0 declared here'
H1FAD9492270E: '此处声明了内联汇编标签 %0'
# 'inline declaration of %0 follows non-inline definition'
H9E262DCDBF26: '内联声明 %0 跟随非内联定义'
# 'inline declaration of %0 not allowed in block scope'
H0812ED282234: '块作用域中不允许内联声明 %0'
# 'inline function %q0 is not defined'
HC9FA92373F42: '内联函数 %q0 未定义'
# 'inline function not defined%select{| before the private module fragment}0'
H195EBE25939A: '内联函数未定义 %select{| 在私有模块片段之前}0'
# 'inline function performs a conversion which is forbidden in ARC'
H46AB09EDECD4: '内联函数执行了ARC中禁止的转换'
# 'inline functions based on how much of the function is a scop.'
H1DDDFC8B898C: '根据函数中属于该作用域的部分多少来inline函数'
# 'inline functions if increase in size is less than defined by -inline-small-functions-bytes'
HF2FBAE9C268E: '如果函数体积增加量小于-inline-small-functions-bytes定义的值，则内联函数'
# 'inline functions with CFI programs (can break exception handling)'
H6C3FCE1081BE: '内联带有CFI程序的函数（可能导致异常处理失效）'
# 'inline leaf functions with CFI programs (can break unwinding)'
H8B9275AE6FE3: '内联带有CFI程序的叶子函数（可能导致展开过程失效）'
# "inline memcpy using 'rep movsb' instruction (X86-only)"
H1E31B40E5C1D: "使用 'rep movsb' 指令内联memcpy（仅X86）"
# 'inline namespace reopened as a non-inline namespace'
H46A1E728D683: '内联命名空间以非内联命名空间重新打开'
# 'inline namespaces are a C++11 feature'
H39D356D1A5FD: '内联命名空间是C++11特性'
# 'inline namespaces are incompatible with C++98'
HFE4E3495E8EA: '内联命名空间与C++98不兼容'
# 'inline nested namespace definition is a C++20 extension'
HF12053D31358: '内联嵌套命名空间定义是C++20扩展'
# 'inline nested namespace definition is incompatible with C++ standards before C++20'
HDC23554C291A: '内联嵌套命名空间定义与C++20之前的C++标准不兼容'
# 'inline variable %q0 is not defined'
H2B60738BBC75: '内联变量 %q0 未定义'
# 'inline variables are a C++17 extension'
H427269D7064C: '内联变量是C++17扩展'
# 'inline variables are incompatible with C++ standards before C++17'
HCE89C300F33E: '内联变量与C++17之前的C++标准不兼容'
# "inner loops must be tightly nested inside a '%0' clause on a '%1' construct"
HE18366CA8367: "内部循环必须紧密嵌套在 '%0' 子句中的 '%1' 构造体内"
# 'input bitcode file which can override previously defined symbol(s)'
HDFE5316187C5: '可覆盖之前定义的符号的输入比特码文件'
# 'input conversion stopped due to an input byte that does not belong to the input codeset UTF-8'
HC2B0606B1239: '输入转换因不属于输入字符集 UTF-8 的输入字节而停止'
# 'input files'
H69B53967F9CE: '输入文件'
# "input is not a PCH file: '%0'"
H0BA9CA2C72E0: "输入不是PCH文件: '%0'"
# 'input objects'
H6ADBB11C54B0: '输入对象文件'
# "insert '%0;' to silence this warning"
H7C4DAFCB5A75: "插入 '%0;' 以静默此警告"
# "insert '%select{_Nonnull|_Nullable|_Null_unspecified}0' if the %select{pointer|block pointer|member pointer|array parameter}1 %select{should never be null|may be null|should not declare nullability}0"
H95F6AD57B128: "插入 '%select{_Nonnull|_Nullable|_Null_unspecified}0' 如果 %select{指针|块指针|成员指针|数组参数}1 %select{不应为null|可为null|不应声明空值}0"
# "insert ',' before '...' to silence this warning"
H84706E906BF0: "在 '...' 前插入 ',' 以静默此警告"
# "insert 'break;' to avoid fall-through"
H4EC7EA05AEDF: "插入 'break;' 以避免 fall-through"
# 'insert an explicit cast to silence this issue'
H21D74C2B0346: '显式插入强制转换以静默此问题'
# 'insert tail call traps'
H8C2E3910BD93: '插入尾调用陷阱'
# 'insert traps in old function bodies (relocation mode)'
H625478AB58CF: '在旧函数体中插入陷阱（重定位模式）'
# "install_name does not match: '%0' (provided) vs '%1' (found)"
H748B1AE34A35: "install_name 不匹配: '%0' (提供) vs '%1' (找到)"
# 'instance method %0 found instead of class method %1'
H1FCFE23050D1: '找到实例方法 %0 而非类方法 %1'
# "instance method %0 is being used on 'Class' which is not in the root class"
H214A12BD7783: "实例方法 %0 被用在 'Class' 类型上，而该类型不在根类层级中"
# "instance method %objcinstance0 not found (return type defaults to 'id')"
HAFE085EFCB1C: "未找到实例方法%objcinstance0（返回类型默认为 'id'）"
# "instance method %objcinstance0 not found (return type defaults to 'id'); did you mean %objcinstance2?"
H44E31EFE4C27: "未找到实例方法%objcinstance0（返回类型默认为 'id'）；您是否是指 %objcinstance2？"
# 'instance variable %0 accessed in class method'
H3EADF48ACA9A: '在类方法中直接访问实例变量 %0'
# 'instance variable %0 declared with incompatible types in different translation units (%1 vs. %2)'
HBFCDBA937742: '实例变量 %0 在不同翻译单元中被声明为不兼容的类型（%1 与 %2）'
# 'instance variable %0 has conflicting bit-field width'
H2B77404519CC: '实例变量 %0 的位段宽度冲突'
# 'instance variable %0 has conflicting type%diff{: $ vs $|}1,2'
H9D5CF719769D: '实例变量 %0 的类型冲突 %diff{: $ vs $|}1,2'
# 'instance variable %0 is being directly accessed'
H3F2D0ABA6990: '实例变量 %0 正在被直接访问'
# 'instance variable %0 is private'
HDB3564656CA2: '实例变量 %0 是私有成员'
# 'instance variable %0 is protected'
HD16F20CBE669: '实例变量 %0 是受保护成员'
# 'instance variable is already declared'
H801D25BC5C9A: '实例变量已在此处声明'
# 'instance variable is declared here'
H1FC75F163FBE: '实例变量在此处声明'
# 'instance variable of type %0 has %select{private|protected}1 destructor'
HA9F26F512B98: '类型为 %0 的实例变量具有%select{私有|受保护}1 析构函数'
# 'instance variables cannot be of reference type'
HCCF4E9A4856E: '实例变量不能是引用类型'
# 'instance variables may not be placed in %select{categories|class extension}0'
H0D800B785119: '不能在%select{分类|类扩展}0 中声明实例变量'
# 'instance variables must have a constant size'
H99AB003B5614: '实例变量必须具有固定大小'
# 'instantiated into assembly here'
H396FFF689BB5: '在此处实例化为汇编代码'
# 'instantiating fold expression with %0 arguments exceeded expression nesting limit of %1'
H467EDA4122CE: '使用 %0 个参数展开折叠表达式超过表达式嵌套限制（%1）'
# 'instantiation of %q0 is different in different modules'
H7179BAA1427A: '不同模块中的%q0 实例化结果不同'
# "instantiation of '%0' not supported yet"
H5578212F4DA3: "对 '%0' 的实例化尚未支持"
# 'instantiation of function %q0 required here, but no definition is available'
H88BC3AB38294: '此处需要函数 %q0 的实例化，但未找到定义'
# 'instantiation of variable %q0 required here, but no definition is available'
H4C7FC0EFFE4E: '此处需要变量 %q0 的实例化，但未找到定义'
# 'instrument atomic instructions (rmw, cmpxchg)'
H9BDE4655B194: '插入原子指令的监控代码（rmw、cmpxchg）'
# 'instrument byval arguments'
H6881238D18AA: '监控 byval 参数'
# 'instrument byval call arguments'
H6F6BC27C3374: '监控 byval 调用参数'
# 'instrument code to generate accurate profile data'
HE308C13DB62F: '插入监控代码以生成精准的性能数据'
# 'instrument dynamic allocas'
HBD70EB33F966: '监控动态 allocas'
# 'instrument landing pads'
HEB0B3F6EFDA4: '监控着陆垫（landing pads）'
# 'instrument memory intrinsics'
HA6D9147CFA12: '监控内存内联函数'
# 'instrument personality functions'
HD5594587E387: '监控 personality 函数'
# 'instrument read instructions'
H064E58E10C74: '监控读取指令'
# 'instrument reads and writes with callbacks'
H29E9BA5B8A64: '使用回调函数监控读写操作'
# 'instrument stack (allocas)'
HD0DD117BE7BA: '监控栈（allocas）'
# 'instrument write instructions'
HA31AFF85F744: '监控写入指令'
# 'instrumentation map used to identify function ids. Currently supports elf file instrumentation maps.'
HABD136211445: '用于标识函数ID的监控映射文件。当前支持ELF文件监控映射。'
# 'integer constant expression evaluates to value %0 that cannot be represented in a %1-bit %select{signed|unsigned}2 integer type'
HA689EA8A19CC: '整型常量表达式计算得到无法用 %1 位%select{有符号|无符号}2整型表示的值 %0'
# 'integer constant not in range of enumerated type %0'
H38F9A13FA923: '整型常量超出枚举类型 %0 的取值范围'
# 'integer literal is too large to be represented in a signed integer type, interpreting as unsigned'
H510046C2B2ED: '整型字面量过大，无法用有符号整型表示，将解释为无符号类型'
# 'integer literal is too large to be represented in any %select{signed |}0integer type'
H586D057CD6B8: '整型字面量过大，无法用任何%select{有符号 |}0 整型类型表示'
# "integer literal is too large to be represented in type 'long' and is subject to undefined behavior under C++98, interpreting as 'unsigned long'; this literal will %select{have type 'long long'|be ill-formed}0 in C++11 onwards"
H84C22AB83CDC: "整型字面量过大，无法用类型 'long' 表示，根据C++98的规范解释为 'unsigned long'；在C++11及以后，该字面量将%select{具有类型 'long long'|被视为非法}0"
# "integer literal is too large to be represented in type 'long', interpreting as 'unsigned long' per C++98; this literal will %select{have type 'long long'|be ill-formed}0 in C++11 onwards"
H4C2C8A72E536: "整型字面量过大，无法用类型 'long' 表示，根据C89的规范解释为 'unsigned long'；在C++11及以后，该字面量将%select{具有类型 'long long'|被视为非法}0"
# "integer literal is too large to be represented in type 'long', interpreting as 'unsigned long' per C89; this literal will %select{have type 'long long'|be ill-formed}0 in C99 onwards"
H58DBBF3A9BD1: "整型字面量过大，无法用类型 'long' 表示，根据C89的规范解释为 'unsigned long'；在C99及以后，该字面量将%select{具有类型 'long long'|被视为非法}0"
# 'integer overflow in preprocessor expression'
H24214C6EA913: '预处理表达式中的整数溢出'
# 'integer sequences must have integral element type'
H16392B2B25B5: '整数序列必须具有整型元素类型'
# 'integer sequences must have non-negative sequence length'
HC3DBF19F94A9: '整数序列必须具有非负长度'
# 'integer value %0 is outside the valid range of values [%1, %2] for the enumeration type %3'
HB6C02E17F94C: '整数值 %0 超出枚举类型 %3 的有效取值范围 [%1, %2]'
# 'integral constant expression has incomplete class type %0'
H52768B5A0D44: '整型常量表达式具有不完整的类类型 %0'
# 'integral constant expression requires explicit conversion from %0 to %1'
H482F498F126E: '整型常量表达式需要显式将 %0 转换为 %1'
# 'interface type %1 cannot be %select{returned|passed}0 by value; did you forget * in %1?'
H5F16699831A7: '接口类型 %1 不能%select{返回|传递}0按值；是否在 %1 中漏掉了 *？'
# 'interface type cannot be statically allocated'
HFB7A102C4547: '接口类型不能静态分配'
# 'interface type cannot inherit from %select{struct|non-public interface|class}0 %1'
HE603DB4B7CDD: '接口类型不能从%select{结构体|非公开接口|类}0 %1 继承'
# "interface types cannot specify '%select{private|protected}0' access"
H5BB34D1AC02B: "接口类型不能指定 '%select{私有|受保护}0' 访问权限"
# "interop type '%0' cannot be specified more than once"
H92EFF909211E: "互操作类型 '%0' 不能被指定超过一次"
# 'interop variable %0 used in multiple action clauses'
H6D1E048E9343: '互操作变量 %0 在多个动作子句中使用'
# "interop variable must be of type 'omp_interop_t'"
H4EE913CC5003: "互操作变量必须为类型 'omp_interop_t'"
# 'interrupt service routine cannot be called directly'
H0EEEBB03E095: '中断服务例程不能直接调用'
# "interrupt service routine with vfp enabled may clobber the interruptee's vfp state; consider using the `interrupt_save_fp` attribute to prevent this behavior"
HBC940BDF20A5: '启用 VFP 的中断服务例程可能会破坏被中断的 VFP 状态；建议使用 `interrupt_save_fp` 属性来避免此行为'
# 'interval between profile writes (default: 0 = write only at program end).  This is useful for service workloads when you want to dump profile every X minutes or if you are killing the program and the profile is not being dumped at the end.'
H3081FD16F975: '性能数据写入间隔（默认：0 = 仅在程序结束时写入）。此选项适用于服务型工作负载，当需要每X分钟导出性能数据时，或当程序被强制终止且无法在结束时导出性能数据时。'
# 'intrinsic module directory'
H68E291291712: '固有模块目录'
# 'intrinsic module search paths'
H9C8DEF0487D6: '固有模块搜索路径'
# 'introduce a module file extension for testing purposes. The argument is parsed as blockname:major:minor:hashed:user info'
HC4A3048AAD1F: '引入用于测试目的的模块文件扩展。参数会被解析为 blockname:major:minor:hashed:user info'
# 'introduce a parameter name to make %0 part of the selector'
HF88F126D64B8: '引入参数名称以将 %0 作为选择器的一部分'
# 'invalid #ident directive'
H33DD8376B05A: '无效的 #ident 指令'
# 'invalid %% escape in inline assembly string'
HDBE197B56289: '内联汇编字符串中无效的 %% 转义'
# "invalid %0 at end of declaration; did you mean '='?"
H6911F0CCF565: "声明结尾处的无效 %0；是否应为 '='？"
# "invalid %1 version '%0' in availability attribute"
HB3CB22885AD2: "可用性属性中 %1 版本 '%0' 无效"
# 'invalid %select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 %select{floating-point|enumeration}1 type %2 %plural{2:with|4:from|:and}0 %select{enumeration|floating-point}1 type %3'
H06A881D8D9FE: '无效的 %select{算术运算在|按位操作在|比较|条件表达式在|复合赋值}0 %select{浮点|枚举}1 类型 %2 %plural{2:与|4:从|:和}0 %select{枚举|浮点}1 类型 %3'
# 'invalid %select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2'
H796D4C8F35F6: '不同枚举类型之间的无效 %select{算术运算|按位操作|比较|条件表达式|复合赋值}0%diff{ ($ 和 $)|}1,2'
# 'invalid %select{branch|return|throw}0 %select{out of|into}1 OpenACC Compute/Combined Construct'
H898CA374F6B7: '无效的 %select{分支|返回|抛出}0 %select{跳出|进入}1 OpenACC 计算/组合构造'
# 'invalid %select{constructor|destructor}0 declaration'
HDEF8993ADCB9: '无效的 %select{构造函数|析构函数}0 声明'
# "invalid 'this' expression on 'map' clause"
H008D791665EC: "'map' 子句中对 'this' 表达式的无效使用"
# "invalid -Xopenmp-target argument: '%0', options requiring arguments are unsupported"
H705427655A77: "无效的 -Xopenmp-target 参数: '%0'，需要参数的选项不受支持"
# "invalid C++ ABI name '%0'"
H8F1C2E5DB890: "无效的 C++ ABI 名称 '%0'"
# "invalid CoreFoundation Runtime ABI '%0'; must be one of 'objc', 'standalone', 'swift', 'swift-5.0', 'swift-4.2', 'swift-4.1'"
H91493C3284DF: "无效的 CoreFoundation 运行时 ABI '%0'；必须为 'objc', 'standalone', 'swift', 'swift-5.0', 'swift-4.2', 'swift-4.1' 中的一个"
# 'invalid Darwin version number: %0'
HA0C57A49CA76: '无效的 Darwin 版本号: %0'
# 'invalid LLVM IR input: %0'
H196A3B80B48D: '无效的LLVM IR输入: %0'
# "invalid OS value '%0' in '%1'"
H00BD3F016742: "'%1' 中的无效操作系统值 '%0'"
# 'invalid OpenACC clause %0'
HA3099393E590: '无效的 OpenACC 子句 %0'
# "invalid OpenACC directive %select{%1|'%1 %2'}0"
H74A42ADBF419: "无效的OpenACC指令 %select{%1|'%1 %2'}0"
# 'invalid PCS type'
H696D824B4D2C: '无效的PCS类型'
# "invalid RVV vector size '%0', expected size is '%1' based on LMUL of type and '-mrvv-vector-bits'"
H96A03531A0AD: "无效的RVV向量大小 '%0'，基于类型LMUL和 '-mrvv-vector-bits' 参数，期望的大小应为 '%1'"
# "invalid SVE vector size '%0', must match value set by '-msve-vector-bits' ('%1')"
HF993CA8A3093: "无效的SVE向量大小 '%0'，必须与 '-msve-vector-bits' 设置的值 '%1' 一致"
# 'invalid UTF-8 in comment'
H58EB41DE8F48: '注释中的无效UTF-8编码'
# "invalid Xarch argument: '%0', not all driver options can be forwared via Xarch argument"
HA12658A01ACA: "无效的Xarch参数：'%0'，并非所有驱动选项都可通过Xarch参数传递"
# "invalid Xarch argument: '%0', options requiring arguments are unsupported"
H7917BEC4B42C: "无效的Xarch参数：'%0'，需要参数的选项不被支持"
# 'invalid __hlsl_resource_t type attributes'
H9A97FF7B54BE: '无效的__hlsl_resource_t类型属性'
# "invalid address discrimination flag '%0'; '__ptrauth' requires '0' or '1'"
H3802C33B9837: "无效的地址鉴别标志 '%0'；'__ptrauth' 需要 '0' 或 '1'"
# 'invalid address discrimination mode %0'
H1D217687F248: '无效的地址区分模式 %0'
# "invalid alignment option in '#pragma %select{align|options align}0' - ignored"
H410475644E70: "在 '#pragma %select{align|options align}0' 中指定了无效的对齐选项 - 已忽略"
# "invalid application of '%0' to %select{an incomplete|sizeless}1 type %2"
H3984632B643A: "将 '%0' 应用于%select{不完整|无大小}1类型 %2 是无效的"
# "invalid application of '%0' to WebAssembly table"
HA443432F106F: "将 '%0' 应用于WebAssembly表无效"
# "invalid application of '%0' to a function type"
HFD1A077F0D84: "将 '%0' 应用于函数类型无效"
# "invalid application of '%0' to a void type"
H3290D1C688B6: "将 '%0' 应用于void类型无效"
# "invalid application of '%select{sizeof|alignof|typeof|typeof_unqual}0' to bit-field"
H4D97635BE644: "将 '%select{sizeof|alignof|typeof|typeof_unqual}0' 应用于位域无效"
# "invalid application of '__builtin_omp_required_simd_align' to an expression, only type is allowed"
H0F35C466B34C: '__builtin_omp_required_simd_align只能用于类型，不能应用于表达式'
# "invalid application of 'alignof' to a field of a class still being defined"
H584C8A2541E4: "将 'alignof' 应用于仍在定义中的类的字段无效"
# "invalid application of 'offsetof' to a field of a virtual base"
H7E5DD90FD952: "将 'offsetof' 应用于虚基类的字段无效"
# "invalid arch name '%0'"
H053EB6DE40C8: "无效的架构名称 '%0'"
# "invalid arch name '%0', %1"
HAF3A77CFBCF8: "无效的架构名称 '%0'，%1"
# 'invalid argument %0 to function: %1, expecting a generic pointer argument'
H45B49DB90594: '函数 %1 的参数 %0 无效：期望一个通用指针参数'
# "invalid argument '%0' not allowed with '%1'"
H5F814EC912CC: "与 '%1' 不能同时使用的无效参数 '%0'"
# "invalid argument '%0' only allowed with '%1'"
HCD365CC8E5D4: "仅允许与 '%1' 一起使用的无效参数 '%0'"
# "invalid argument '%0' to -%1"
H8405E80D8137: "选项-%1 的无效参数 '%0'"
# "invalid argument '%0' to -malign-branch=; each element must be one of: %1"
H20657E1CDBBF: "选项-malign-branch=的无效参数 '%0'；每个元素必须是以下之一： %1"
# "invalid argument '%0' to -mfpu=; must be one of: 64, 32, none, 0 (alias for none)"
HF131652C4C29: "选项-mfpu=的无效参数 '%0'；必须为以下之一：64、32、none、0（等同于none）"
# "invalid argument '%0' to -msimd=; must be one of: none, lsx, lasx"
H2BA112BC46B6: "选项-msimd=的无效参数 '%0'；必须为以下之一：none、lsx、lasx"
# "invalid argument '%0' to atomic attribute; valid options are: 'remote_memory', 'fine_grained_memory', 'ignore_denormal_mode' (optionally prefixed with 'no_')"
H438B1A442EF4: "原子属性的无效参数 '%0'；有效选项包括：'remote_memory', 'fine_grained_memory', 'ignore_denormal_mode'（可选前缀 'no_'）"
# "invalid argument '-mno-amdgpu-ieee' only allowed with relaxed NaN handling"
H507F0448DDCC: "无效选项 '-mno-amdgpu-ieee' 仅在启用宽松NaN处理时允许"
# "invalid argument in '%0', only integer or 'auto' is supported"
H40210717B247: "在 '%0' 中参数无效，仅支持整数或 'auto'"
# "invalid argument in '%0', only integers are supported"
H7CC5EAE0927D: "在 '%0' 中参数无效，仅支持整数"
# 'invalid argument of type %0; expected an integer type'
HDC97D348BCF9: '类型 %0 的无效参数；期望一个整数类型'
# 'invalid argument to convert to character'
H035CE8B39D0F: '无法转换为字符类型的无效参数'
# 'invalid argument type %0 to unary expression'
HB7A2329B026C: '一元表达式参数类型 %0 无效'
# 'invalid argument type to function %0 (expecting %1 having %2)'
H740D8FB32D84: '函数 %0 的参数类型 %1 无效（应为 %2 类型）'
# 'invalid argument: symbol must be a device-side function or global variable'
HB29E0DD1BCB5: '无效参数：符号必须是设备端函数或全局变量'
# "invalid argument; expected 'disable'"
H14256C1A2363: "无效参数；期望 'disable'"
# "invalid argument; expected 'enable'%select{|, 'full'}0%select{|, 'assume_safety'}1 or 'disable'"
H369903756AB7: "无效参数；期望 'enable'%select{|, 'full'}0%select{|, 'assume_safety'}1 或 'disable'"
# 'invalid authentication key %0'
H1380B8ED725A: '无效的认证密钥 %0'
# 'invalid block pointer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2'
H1E4447440EDF: '块指针转换无效 %select{%diff{将$分配给$|不同类型的赋值}0,1|%diff{将$传递给类型$的参数|传递到不同类型参数}0,1|%diff{从返回类型$的函数返回$|函数返回类型不匹配}0,1|%diff{将$转换为类型$|不同类型的转换}0,1|%diff{用类型$的表达式初始化$|表达式类型与初始化类型不匹配}0,1|%diff{将$发送到类型$的参数|发送到不同类型参数}0,1|%diff{将$强制转换为类型$|不同类型的强制转换}0,1}2'
# 'invalid block variable declaration - must be %select{const qualified|initialized}0'
HF892D907A5A7: '无效的块变量声明 - 必须是 %select{const限定|已初始化}0'
# "invalid block variable declaration - using 'extern' storage class is disallowed"
H2029EAB9FA9A: "无效的块变量声明 - 不允许使用 'extern' 存储类"
# 'invalid branch into OpenACC Compute/Combined Construct'
HC49FDF0B5C89: '无效的进入OpenACC Compute/Combined Construct的分支'
# 'invalid branch out of OpenACC Compute/Combined Construct'
H921800904C81: '无效的退出OpenACC Compute/Combined Construct的分支'
# "invalid branch protection option '%0' in '%1'"
H69A222420F22: "在 '%1' 中的分支保护选项 '%0' 无效"
# "invalid case style for %0 '%1'"
H3DD07CA4DE69: "%0 '%1' 大小写风格错误"
# "invalid character '%0' in raw string delimiter; use PREFIX( )PREFIX to delimit raw string"
H82170E32D0E4: "原始字符串分隔符中的无效字符 '%0'；使用PREFIX( )PREFIX来分隔原始字符串"
# "invalid comparison flag %0; use 'layout_compatible' or 'must_be_null'"
H677EA1A68EB0: "无效的比较标志 %0；使用 'layout_compatible' 或 'must_be_null'"
# "invalid component '%0' used; expected 'x', 'y', 'z', or 'w'"
H32632D0CDE2F: "无效的组件 '%0'；应使用 'x'、'y'、'z' 或 'w'"
# 'invalid constructor from class in system header, should not be explicit'
HEFC602372E3E: '来自系统头文件的类的无效构造函数，不应显式声明'
# 'invalid conversion between ext-vector type %0 and %1'
H4E43BF77A891: '不同类型大小的向量类型 %0 和 %1 之间的无效转换'
# 'invalid conversion between vector type %0 and integer type %1 of different size'
HAD5A2EB8C76E: '不同类型大小的向量类型 %0 和整型类型 %1 之间的无效转换'
# 'invalid conversion between vector type %0 and scalar type %1'
H0E21BE8324C1: '向量类型 %0 和标量类型 %1 之间的无效转换'
# 'invalid conversion between vector type%diff{ $ and $|}0,1 of different size'
H62FB40425AFD: '不同大小的向量类型%diff{ $和$|}0,1 之间的无效转换'
# "invalid conversion specifier '%0'"
H36DE3CE25255: "无效的格式说明符 '%0'"
# 'invalid covariant return for virtual function: %1 is a %select{private|protected}2 base class of %0'
HB307942D226E: '虚函数的协变返回类型无效：%1 是 %0 的%select{私有|保护}2基类'
# 'invalid cpu feature string for builtin'
H63D2023D3150: '内建函数的无效CPU特性字符串'
# 'invalid cpu name for builtin'
HD2B5E0F427CF: '内建函数的无效CPU名称'
# 'invalid custom discrimination'
HBF55CC3D0D6C: '无效的自定义判别式'
# 'invalid declaration inside %select{tbuffer|cbuffer}0'
H75299BE36932: '在 %select{tbuffer|cbuffer}0 内部的无效声明'
# 'invalid declaration specifier in template non-type parameter'
HE0A0675789D7: '模板非类型参数中的无效声明说明符'
# 'invalid diagnostic type for \'diagnose_if\'; use "error" or "warning" instead'
HD2E5D476D869: '无效的诊断类型用于\'diagnose_if\'; 使用 "error" 或 "warning" 代替'
# "invalid digit '%0' in %select{decimal|octal|binary}1 constant"
H6F9BD80EC0BE: "无效的数字 '%0' 在%select{十进制|八进制|二进制}1常量中"
# "invalid digit '%0' in escape sequence"
HF729B18CD0D2: "无效的数字 '%0' 在转义序列中"
# "invalid escape sequence '%0' in an unevaluated string literal"
HF58F976119B7: "无效的转义序列 '%0' 在未求值的字符串字面量中"
# "invalid exception model '%select{none|sjlj|seh|dwarf|wasm}0' for target '%1'"
H00FCEE8853CC: "目标 '%1' 的无效异常模型 '%select{none|sjlj|seh|dwarf|wasm}0'"
# 'invalid expected %0: %1'
HE0DC8B702320: '无效的期望 %0：%1'
# 'invalid explicit object parameter type %0 in lambda with capture; the type must be the same as, or derived from, the lambda'
H98E01B807F8E: '具有捕获的lambda的显式对象参数类型 %0 无效; 类型必须与lambda相同或派生自lambda'
# 'invalid explicit object parameter type %0 in lambda with capture; the type must derive publicly from the lambda'
H607716F86E02: '具有捕获的lambda的显式对象参数类型 %0 无效; 类型必须公开派生自lambda'
# 'invalid extra discrimination selection %0'
HAC5AAEAB2B1D: '无效的额外判别选择 %0'
# "invalid extra discriminator flag '%0'; '__ptrauth' requires a value between '0' and '%1'"
HBC87DBE11994: "无效的额外鉴别符标志 '%0'；'__ptrauth' 需要介于 '0' 和 '%1' 之间的值"
# 'invalid feature combination: %0'
H53E34DDB7754: '无效的特性组合: %0'
# 'invalid field is here'
H6F033E1FBEC9: '无效的字段在此处'
# 'invalid filename for #line directive'
H5BFFCF48D855: '#line指令的无效文件名'
# 'invalid filename for line marker directive'
H6AF3C8643D27: '行标记指令的无效文件名'
# 'invalid flag line marker directive'
H5CC65A10A5E0: '无效的标志行标记指令'
# "invalid float ABI '%0'"
H606FAE3A11E2: "无效的浮点ABI '%0'"
# "invalid iOS deployment version '%0', iOS 10 is the maximum deployment target for 32-bit targets"
HD422F25540A2: "无效的iOS部署版本 '%0', iOS 10 是 32 位目标的最大部署目标"
# 'invalid index %0 for pack %1 of size %2'
H1627FB393F43: '大小为 %2 的参数包 %1 的无效索引 %0'
# "invalid input constraint '%0' in asm"
H09D927559067: "asm中无效的输入约束 '%0'"
# "invalid input for analyzer-config option '%0', that expects %1 value"
HB14EB9C7A93F: "分析器配置选项 '%0' 的无效输入，该选项需要 %1 值"
# "invalid input for checker option '%0', that expects %1"
H784B521FDFA9: "检查器选项 '%0' 的无效输入，该选项需要 %1"
# "invalid input size for constraint '%0'"
H8F6CDB6F0449: "约束 '%0' 的输入大小无效"
# "invalid integral value '%1' in '%0'"
H6E04ED0681B7: "在 '%0' 中，整数值 '%1' 无效"
# "invalid invocation of method '%0' on a temporary object while it is in the '%1' state"
H6C0DF8705FCA: "当临时对象处于 '%1' 状态时，对方法 '%0' 的调用无效"
# "invalid invocation of method '%0' on object '%1' while it is in the '%2' state"
HD38690B94C13: "当对象 '%1' 处于 '%2' 状态时，对方法 '%0' 的调用无效"
# "invalid library name in argument '%0'"
H64F3D932433A: "参数 '%0' 中的库名称无效"
# "invalid line marker flag '2': cannot pop empty include stack"
H37DFD44E19FB: "无效的行标记标志 '2': 无法弹出空的包含栈"
# "invalid linker name in argument '%0'"
HC2FCA31CF12C: "参数 '%0' 中的链接器名称无效"
# 'invalid literal operator parameter type %0, did you mean %1?'
H0C90111229B8: '字面运算符参数类型 %0 无效，是否应为 %1？'
# "invalid lvalue in asm input for constraint '%0'"
H2CA59C9EF59C: "约束 '%0' 的内联汇编输入中的左值无效"
# 'invalid lvalue in asm output'
HED6C7D31AA01: '内联汇编输出中的左值无效'
# 'invalid matrix element type %0'
H9CDCD6DAE3BE: '无效的矩阵元素类型 %0'
# 'invalid newline character in raw string delimiter; use PREFIX( )PREFIX to delimit raw string'
HF6C358E90110: '原始字符串定界符中的换行符无效；请使用 PREFIX( )PREFIX 来定界原始字符串'
# 'invalid number of arguments to function: %0'
H3D5EA8973A6F: '函数参数数量无效: %0'
# "invalid offload arch combinations: '%0' and '%1' (for a specific processor, a feature should either exist in all offload archs, or not exist in any offload archs)"
H92F337A26551: "无效的offload架构组合: '%0' 和 '%1'（对于特定处理器，特性应存在于所有offload架构中，或不存在于任何offload架构中）"
# 'invalid operand number in inline asm string'
H3DCCD1026997: '内联汇编字符串中的操作数编号无效'
# 'invalid operand of type %0 where %1 or a vector of such type is required'
HD52C15C02D70: '操作数类型 %0 无效，需要类型 %1 或该类型的向量'
# 'invalid operand of type %0 where floating, complex or a vector of such types is required'
HC1A341FFC462: '操作数类型 %0 无效，需要浮点、复数或该类型的向量'
# 'invalid operand of type %0%select{| where a scalar or vector is required}1'
H848780E5A063: '操作数类型 %0%select{|（需要标量或向量类型）}1 无效'
# 'invalid operands to binary expression (%0 and %1)'
HC5560B091967: '二进制表达式中的操作数类型无效 (%0 和 %1)'
# "invalid option '%0' for %select{cpu_specific|cpu_dispatch}1"
HEFAAB35E81AF: "选项 '%0' 无效，%select{cpu_specific|cpu_dispatch}1"
# "invalid option '%0' not of the form <from-file>;<to-file>"
HCB5BB85712F1: "无效的选项 '%0'，不符合 <from-file>;<to-file> 的格式"
# 'invalid option combination; LASX depends on LSX'
H7E946D645C29: '无效的选项组合；LASX依赖于LSX'
# "invalid or misplaced branch protection specification '%0'"
H9377B8FCDAC3: "无效或放置位置错误的分支保护规范 '%0'"
# "invalid or unsupported offload target: '%0'"
H4E7457AF1786: "无效或不受支持的offload目标: '%0'"
# "invalid or unsupported rounding mode in '#pragma STDC FENV_ROUND' - ignored"
HDB0B7F11E503: "在 '#pragma STDC FENV_ROUND' 中指定了无效或不受支持的舍入模式 - 已忽略"
# "invalid output constraint '%0' in asm"
H686C32E03A9D: "asm中的无效输出约束 '%0'"
# "invalid output size for constraint '%0'"
HA9017C3CAD23: "约束 '%0' 的输出大小无效"
# "invalid output type '%0' for use with gcc tool"
H1AE0ECD8B562: "与gcc工具一起使用时无效的输出类型 '%0'"
# "invalid parameter name: '%0' is a keyword"
HBA4C66D8A8AA: "无效的参数名称：'%0' 是一个关键字"
# 'invalid parameter type for defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator; found %1, expected %2%select{| or %4}3'
H1333988BA8FC: '默认的 %select{<ERROR>|相等|三向|相等|关系}0比较运算符的参数类型无效；找到 %1，期望 %2%select{|或 %4}3'
# 'invalid parameter type for non-member defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator; found %1, expected class or reference to a constant class'
HEB967961C960: '非成员默认的 %select{<ERROR>|相等|三向|相等|关系}0比较运算符的参数类型无效；找到 %1，期望类或常量类的引用'
# 'invalid pipe access modifier (expecting %0)'
HA4FFF117B821: '无效的管道访问修饰符（期望 %0）'
# 'invalid position specified for %select{field width|field precision}0'
H5DF564C1B18C: '为%select{字段宽度|字段精度}0指定的无效位置'
# "invalid preprocessing directive%select{|, did you mean '#%1'?}0"
H852ECDD7D2C3: '无效的预处理指令 %select{|，您是指 "#%1"?}0'
# 'invalid profile : %0'
H35AB0F2CB838: '无效的配置文件： %0'
# 'invalid protocol qualifiers on non-ObjC type'
H3723A726B37F: '非ObjC类型上的无效协议限定符'
# 'invalid prototype, variadic arguments are not allowed in OpenCL'
H5E1888FFA26E: '无效的原型，在OpenCL中不允许使用可变参数'
# "invalid range expression of type %0; did you mean to dereference it with '*'?"
H1FCBEB4D2213: '类型为 %0 的无效区间表达式；您是否打算用 "*" 进行解引用？'
# "invalid range expression of type %0; no viable '%select{begin|end}1' function available"
H76B630AFA57F: '类型为 %0 的无效区间表达式；没有可用的 "%select{begin|end}1" 函数'
# "invalid range following '-' in expected %0"
H99FD9B7E0352: "在期望的 %0 中 '-' 后的范围无效"
# "invalid reduction operator,  expected '+', '*', 'max', 'min', '&', '|', '^', '&&', or '||'"
H3407BE2F5E5D: "无效的规约运算符，期望的运算符之一为 '+'、'*'、'max'、'min'、'&'、'|'、'^'、'&&' 或 '||'"
# 'invalid reference to function %0: constraints not satisfied'
H9E6FAF3D6010: '对函数 %0 的无效引用：约束条件未满足'
# 'invalid reinterpretation: sizes of %0 and %1 must match'
HC6E0606A101D: '无效的重新解释：%0 和 %1 的大小必须匹配'
# "invalid resource class specifier '%0' for packoffset, expected 'c'"
H2B96C40BB1F0: "packoffset的无效资源类指定符 '%0'，期望为 'c'"
# 'invalid rounding argument'
HD77BD554C068: '无效的舍入参数'
# "invalid runtime library name in argument '%0'"
HCC4F20591ADF: "参数 '%0' 中无效的运行时库名称"
# 'invalid size value'
H41C03C7DB477: '无效的大小值'
# "invalid space specifier '%0' used; expected 'space' followed by an integer, like space1"
HB8CFB0AAB2CD: "无效的空格指定符 '%0'，期望类似 'space1' 的 'space' 后跟整数形式"
# 'invalid special register for builtin'
H26E533E2D360: '内建函数的无效特殊寄存器'
# 'invalid storage class specifier in function declarator'
HF2FD2E42B318: '函数说明符中的无效存储类说明符'
# "invalid string literal, ignoring final '\\'"
H550F921F116D: "无效的字符串文字，忽略末尾的 '\\'"
# "invalid suffix '%0' on %select{integer|floating|fixed-point}1 constant"
HFE61994BB7A3: "在%select{整型|浮点型|定点型}1常量上的无效后缀 '%0'"
# 'invalid suffix on literal; C++11 requires a space between literal and identifier'
H3AC3DC712C63: '文字的无效后缀；C++11要求文字和标识符之间有一个空格'
# "invalid tag %0 on '%1' %select{directive|clause}2"
HB6EF4B837656: "在 '%1' 的%select{指令|子句}2上的无效标签 %0"
# "invalid target ID '%0'; format is a processor name followed by an optional colon-delimited list of features followed by an enable/disable sign (e.g., 'gfx908:sramecc+:xnack-')"
HF2F065F66FFD: "无效的目标ID'%0'；格式为处理器名称后可接用冒号分隔的功能列表，再接启用/禁用符号（例如 'gfx908:sramecc+:xnack-'）"
# 'invalid target type %0 for dynamic_cast; target type must be a reference or pointer type to a defined class'
HFE4D2B7D8E06: 'dynamic_cast的无效目标类型 %0；目标类型必须是对已定义类的引用或指针类型'
# "invalid thread model '%0' in '%1' for this target"
HE75965380195: "在此目标的 '%1' 中的无效线程模型 '%0'"
# "invalid thread pointer reading mode '%0'"
H602D0823E0FB: "无效的线程指针读取模式 '%0'"
# 'invalid token at start of a preprocessor expression'
HAAFAB4DB043C: '预处理器表达式开头的无效标记'
# 'invalid token in macro parameter list'
HA6A8BDC08D89: '宏参数列表中的无效标记'
# 'invalid transaction abort code'
H75E4D8742736: '无效的事务中止代码'
# 'invalid type %0 as argument of iboutletcollection attribute'
HE41F37E3851B: 'iboutletcollection属性的参数类型 %0 无效'
# 'invalid type %0 in asm %select{input|output}1'
H2A71CC82E6A7: '汇编%select{输入|输出}1中的类型 %0 无效'
# "invalid type %0 in asm input for constraint '%1'"
H1E6A37C4D619: "汇编输入的约束 '%1' 中类型 %0 无效"
# 'invalid type %0 is a %select{member|base}1 of %2'
HB6D9D0DC110A: '无效类型 %0 是%select{成员|基类}1的 %2'
# 'invalid type %0 to %1 operator'
H4C8C1A65C2A4: '无效类型 %0 到 %1 运算符'
# 'invalid universal character'
H73C6676CA247: '无效通用字符'
# "invalid unwind library name in argument '%0'"
HD675186A50F6: "参数 '%0' 中的解扰库名称无效"
# "invalid use of '__funcref' keyword outside the WebAssembly triple"
H5B018C340841: "在WebAssembly架构外使用 '__funcref' 关键字的无效用法"
# "invalid use of '__super', %0 has no base classes"
HC8BFC8F3D816: '无效的__super用法，%0 没有基类'
# "invalid use of '__super', this keyword can only be used inside class or member function scope"
H02BB07D5882C: '无效的__super用法，此关键字只能在类或成员函数作用域内使用'
# "invalid use of 'this' %select{outside of a non-static member function|in a function with an explicit object parameter}0"
H9633100217CB: "在%select{非静态成员函数外部|带有显式对象参数的函数中}0使用 'this' 无效"
# 'invalid use of PPC MMA type'
H23BD562DB2DF: '在PPC上对MMA类型的无效使用'
# 'invalid use of a cast in an inline asm context requiring an lvalue'
H5D073F64410B: '在需要左值的内联汇编上下文中对强制类型转换的无效使用'
# 'invalid use of incomplete type %0'
H7FE8554F5009: '无效的不完全类型 %0 的用法'
# 'invalid use of member %0 in %select{static|explicit object}1 member function'
H50EBCD910232: '在%select{静态|显式对象}1成员函数中对成员 %0 的无效使用'
# 'invalid use of non-static data member %0'
H59D616D352F1: '非静态数据成员 %0 的无效使用'
# 'invalid use of pointer to member type after %select{.*|->*}0'
H48A2AD1643D5: '%select{.*|->*}0 之后的成员指针类型无效'
# 'invalid validator version : %0; format of validator version is "<major>.<minor>" (ex:"1.4")'
H4B1AA82F67A0: '无效的验证程序版本：%0；验证程序版本格式应为"<主版本>.<次版本>"（例如："1.4"）'
# 'invalid validator version : %0; if validator major version is 0, minor version must also be 0'
HD365448B0579: '无效的验证程序版本：%0；如果验证程序主版本号为 0，则次版本号也必须为 0'
# 'invalid validator version : %0; validator version must be less than or equal to current internal version'
HED613B352B91: '无效的验证器版本：%0；验证器版本必须小于或等于当前内部版本'
# "invalid value %0 in '%1' clause; valid values are %2"
H70463648CF58: "在 '%1' 子句中无效的值 %0；有效值为 %2"
# "invalid value '%1' in '%0'"
H7E000E39503F: "在 '%0' 中无效的值 '%1'"
# "invalid value '%1' in '%0', expected one of: %2"
H22924648CBBA: "在 '%0' 中无效的值 '%1'，期望其中一个：%2"
# "invalid value '%1' in '%0', value must be '%2' or greater"
H38383851595E: "在 '%0' 中无效的值 '%1'，值必须是 '%2' 或更大"
# "invalid value '%1' in '%0', value must be 'none' or a positive integer"
H9E8659EA6C7E: "在 '%0' 中无效的值 '%1'；对齐必须是 2 的幂次方"
# "invalid value '%1' in '%0'; alignment must be a power of 2"
H2DA82E98A2A4: "选项 '%0' 中无效值 '%1'；对齐必须为 2 的幂"
# 'invalid value for %select{storage class}0 argument'
H53A1EFEC052F: '%select{存储类}0参数的值无效'
# "invalid value for 'default' clause; expected 'present' or 'none'"
H8D0169FE239F: "'default' 子句的值无效；期望 'present' 或 'none'"
# 'invalid vector element type %0'
HEFB9A08F90A0: "在 '%0' 中无效的版本号"
# "invalid version number '%0' inferred from '%1'"
H04EAF3982B06: "从 '%1' 推断出的版本号 '%0' 无效"
# "invalid version number in '%0'"
H561E007CCA86: "无效的虚拟文件系统覆盖文件 '%0'"
# "invalid virtual filesystem overlay file '%0'"
HBFF79FC3240A: "无效的虚文件系统覆盖文件 '%0'"
# "invoking a pointer to a 'const &' member function on an rvalue is a C++20 extension"
HDCED919CDE9E: "对右值调用指向 'const &' 成员函数的指针与C++20之前的C++标准不兼容"
# "invoking a pointer to a 'const &' member function on an rvalue is incompatible with C++ standards before C++20"
H06659E61779A: "在C++20之前，对rvalue调用 'const &' 成员函数指针与C++标准冲突"
# "isa trait '%0' is not known to the current target; verify the spelling or consider restricting the context selector with the 'arch' selector further"
H0ED9A7F36C30: "目标架构未识别特性 '%0'；请检查拼写或通过 'arch' 选择器限制上下文"
# "it could also be property %select{of type %1|without attribute '%1'|with attribute '%1'|with getter %1|with setter %1}0 declared here"
H91A939A34A63: "它也可能是属性 %select{类型 %1|无 '%1' 属性|具有 '%1' 属性|具有 getter %1|具有 setter %1}0 在此处声明"
# 'it delegates to'
H01E41C702CFA: '其委托到'
# 'it is possible to stop the benchmarking process after some phase'
H3F4A63E67588: '可以在某些阶段后停止基准测试过程'
# 'iterator step expression %0 evaluates to 0'
H68A0F13C3B50: '迭代器步长表达式 %0 不是整型表达式'
# 'iterator step expression %0 is not the integral expression'
H5E0FE51F5C8D: '支撑该属性的实例变量 %0 未在此属性的访问器中被引用'
# "ivar %0 which backs the property is not referenced in this property's accessor"
HB68211D86C75: "连接参数期望附加值：'%0'"
# "joined argument expects additional value: '%0'"
H67B5A91D2948: "连接参数需要额外值：'%0'"
# "joined argument treated as '%0'; did you mean '%1'?"
HAC9E756384DA: "合并的参数被当作 '%0' 处理；您是指 '%1' 吗？"
# 'jump bypasses OpenMP structured block'
H38D141B68E15: '跳跃绕过了OpenMP结构化块'
# 'jump bypasses auto release push of @autoreleasepool block'
H673B2CE5E964: '跳跃绕过了@autoreleasepool块的自动释放推送'
# 'jump bypasses initialization of @catch block'
HBE63405914D4: '跳跃绕过了@catch块的初始化'
# 'jump bypasses initialization of @finally block'
HC258EB27DC7D: '跳跃绕过了@finally块的初始化'
# 'jump bypasses initialization of @synchronized block'
HB49518EF658F: '跳跃绕过了@synchronized块的初始化'
# 'jump bypasses initialization of @try block'
H4F2203657B83: '跳跃绕过了@try块的初始化'
# 'jump bypasses initialization of VLA type alias'
H06AE800C9022: '跳跃绕过了VLA类型别名的初始化'
# 'jump bypasses initialization of VLA typedef'
H539D32051794: '跳转绕过了 VLA typedef 的初始化'
# 'jump bypasses initialization of __except block'
H8945BA31631C: '跳跃绕过了__except块的初始化'
# 'jump bypasses initialization of __finally block'
HDC8606BFB8A0: '跳跃绕过了__finally块的初始化'
# 'jump bypasses initialization of __strong variable'
H4091D3DFA80B: '跳跃绕过了__strong变量的初始化'
# 'jump bypasses initialization of __try block'
H17A1FDC40633: '跳跃绕过了__try块的初始化'
# 'jump bypasses initialization of __weak variable'
H2D2E5414450F: '跳跃绕过了__weak变量的初始化'
# 'jump bypasses initialization of catch block'
H1AD4DA299533: '跳跃绕过了catch块的初始化'
# 'jump bypasses initialization of non-POD variable'
H7894E3C8480C: '跳跃绕过了非POD变量的初始化'
# 'jump bypasses initialization of try block'
H35C99F3D2CF6: '跳跃绕过了try块的初始化'
# 'jump bypasses initialization of variable length array'
HD2CC21B5B2B9: '跳跃绕过了可变长度数组的初始化'
# 'jump bypasses initialization of variable of non-trivial C struct type'
H8DC117DB27D9: '跳跃绕过了非平凡C结构体类型的变量初始化'
# 'jump bypasses initialization of variable with __attribute__((cleanup))'
H816408F197AB: '跳跃绕过了带有__attribute__((cleanup))属性的变量的初始化'
# 'jump bypasses setup of __block variable'
H8FF055D54D20: '跳转跳过了__block变量的设置'
# 'jump bypasses variable initialization'
HDE484302CFDD: '跳转跳过了变量初始化'
# 'jump bypasses variable with a non-trivial destructor'
H65EAD2757089: '跳转跳过了具有非平凡析构函数的变量'
# 'jump enters Objective-C fast enumeration loop'
H0B68A5227D3D: '跳转进入Objective-C快速枚举循环'
# 'jump enters a statement expression'
HAF0C1FFF2BB0: '跳转进入语句表达式'
# 'jump enters controlled statement of consteval if'
H9FCC3E0998D5: '跳转进入consteval if的控制语句'
# 'jump enters controlled statement of constexpr if'
H53B0DD3B4BCF: '跳转进入constexpr if的控制语句'
# 'jump enters controlled statement of if available'
H0D6B49E1C06A: '跳转进入if available的控制语句'
# 'jump enters lifetime of a compound literal that is non-trivial to destruct'
H84D2F4FDA1F2: '跳转进入复合字面量的生命周期，其析构过程非平凡'
# 'jump enters lifetime of block which captures a C struct that is non-trivial to destroy'
HB60961C86BE4: '跳转进入捕获了非平凡可销毁C结构的块的生命周期'
# 'jump enters lifetime of block which captures a destructible C++ object'
HFA59EFDF1B62: '跳转进入捕获了可销毁C++对象的块的生命周期'
# 'jump enters lifetime of block which strongly captures a variable'
H2E28FE1D13B9: '跳转进入强捕获变量的块的生命周期'
# 'jump enters lifetime of block which weakly captures a variable'
H8ED7B1ED0204: '跳转进入弱捕获变量的块的生命周期'
# 'jump exits @catch block'
H00823EBB1453: '跳转退出@catch块'
# 'jump exits @finally block'
HDE9FECD28D12: '跳转退出@finally块'
# 'jump exits @synchronized block'
H2C2C500585D3: '跳转退出@synchronized块'
# 'jump exits @try block'
H60631B3B104F: '跳转退出@try块'
# 'jump exits __except block'
HF0ECDC1D667A: '跳转退出__except块'
# 'jump exits __finally block'
HEF15A26AC2B4: '跳转退出__finally块'
# 'jump exits __try block'
HA371EC6EABEF: '跳转退出__try块'
# 'jump exits autoreleasepool block'
HFA1102E13121: 'jump exits autoreleasepool块'
# 'jump exits catch block'
HB15A540E97C0: 'jump exits catch块'
# 'jump exits lifetime of a compound literal that is non-trivial to destruct'
H581CCAF33BA1: 'jump exits 非平凡析构的复合字面量的生命周期'
# 'jump exits lifetime of block which captures a C struct that is non-trivial to destroy'
H145F09CDB728: 'jump exits 捕获了非平凡销毁C结构体的block的生命周期'
# 'jump exits lifetime of block which captures a destructible C++ object'
HFD90BDF2A71A: 'jump exits 捕获了可析构C++对象的block的生命周期'
# 'jump exits lifetime of block which strongly captures a variable'
H633C0158D8CE: 'jump exits 强捕获变量的block的生命周期'
# 'jump exits lifetime of block which weakly captures a variable'
H3C3B445ACF96: 'jump exits 弱捕获变量的block的生命周期'
# 'jump exits scope of OpenMP structured block'
H3960249ABF56: 'jump exits OpenMP结构化块的作用域'
# 'jump exits scope of __block variable'
HCAFFF794B0B7: 'jump exits __block变量的作用域'
# 'jump exits scope of __strong variable'
H09130C2189DF: 'jump exits __strong变量的作用域'
# 'jump exits scope of __weak variable'
H425A195D6F14: 'jump exits __weak变量的作用域'
# 'jump exits scope of lifetime-extended temporary with non-trivial destructor'
H18BAD42D7AAF: 'jump exits 非平凡析构的临时对象的生命周期'
# 'jump exits scope of variable with __attribute__((cleanup))'
H4BF0CCE50F51: 'jump exits __attribute__((cleanup))变量的作用域'
# 'jump exits scope of variable with non-trivial destructor'
HD66C6E5AB564: 'jump exits 非平凡析构函数的变量的作用域'
# 'jump exits try block'
HE15267C61E24: 'jump exits try块'
# 'jump from switch statement to this case label is incompatible with C++'
H65E63DA93A2A: '从switch语句跳转到此case标签与C++不兼容'
# 'jump from switch statement to this case label is incompatible with C++98'
HFD45DFD4341B: '从switch语句跳转到此case标签与C++98不兼容'
# 'jump from this %select{indirect|asm}0 goto statement to one of its possible targets is incompatible with C++'
HCA1B45FA0F11: '从此%select{间接|内联汇编}0 goto语句跳转到其可能的目标之一与C++不兼容'
# 'jump from this %select{indirect|asm}0 goto statement to one of its possible targets is incompatible with C++98'
H6B5196F09490: '从此 %select{indirect|asm}0 goto语句跳转到其可能目标与C++98不兼容'
# 'jump from this goto statement to its label is a Microsoft extension'
HF443D2C187C8: '从此goto语句跳转到其标签是Microsoft扩展'
# 'jump from this goto statement to its label is incompatible with C++'
HCF98C797091F: '从此goto语句跳转到其标签与C++不兼容'
# 'jump from this goto statement to its label is incompatible with C++98'
H91A60091F523: '从此goto语句跳转到其标签与C++98不兼容'
# 'jump out of __finally block has undefined behavior'
HC63318A29EFB: '从__finally块跳出具有未定义行为'
# 'jump tables support (default=basic)'
H004CDF2FB54A: '跳转表支持（默认=基础模式）'
# 'just the yaml representation of the profile'
H77CB9F525531: '仅显示配置文件的YAML表示'
# 'keep going after reporting a UMR'
H5D280A550689: '在报告UMR后继续处理'
# 'keep no-op instructions. By default they are removed.'
H5294B5B42559: '保留空操作指令。默认情况下它们会被移除'
# 'keep or generate .debug_aranges section if .gdb_index is written'
HF46D8AA36DF8: '如果生成.gdb_index节，则保留或生成.debug_aranges节'
# 'kernel call to non-global function %0'
HE2C1F06E4669: '内核调用非全局函数 %0'
# 'kernel function %0 is a member function; this may not be accepted by nvcc'
H6C2BA696CEAF: '内核函数 %0 是成员函数；这可能不被 nvcc 接受'
# 'kernel function %0 must be a free function or static member function'
H16FEF3B5D436: '内核函数 %0 必须是自由函数或静态成员函数'
# 'kernel function type %0 must have void return type'
H95AC5DFCBCA0: '内核函数类型 %0 必须具有 void 返回类型'
# 'kernel functions cannot be class members'
H49F7A4460E40: '内核函数不能是类成员'
# 'kernel functions cannot be declared static'
H4969597F9236: '内核函数不能被声明为 static'
# 'kernel functions cannot be used in a template declaration, instantiation or specialization'
HD5AD84DAA9C6: '内核函数不能在模板声明、实例化或特化中使用'
# 'kernel must have void return type'
H2245CF70F0F9: '内核必须具有 void 返回类型'
# 'kernel parameter cannot be declared as a pointer to a pointer'
HA03E5339986E: '内核参数不能被声明为指针到指针'
# "keyword '%0' will be made available as an identifier %select{here|for the remainder of the translation unit}1"
HB2136B9BC89D: "关键字 '%0' 将作为标识符 %select{此处|在翻译单元的剩余部分}1 提供"
# 'keyword is hidden by macro definition'
HB53596605CAF: '关键字被宏定义隐藏'
# 'kind mapping string to set kind precision'
HE046AE1AA112: '设置类型精度的映射字符串'
# "known but unsupported action '%1' for '#pragma %0' - ignored"
H07B6796F45BE: "已知但不受支持的 '#pragma %0' 操作 '%1' - 已忽略"
# "label '%0' is reserved: use a different label name for -X<label>"
H0A75EFF64B4C: "标签 '%0' 是保留的：为 -X<label> 使用不同的标签名称"
# 'label at end of compound statement is a C++23 extension'
H696C9202732B: '复合语句末尾的标签是 C++23 扩展'
# 'label at end of compound statement is a C23 extension'
H24E471EE8FE1: '复合语句末尾的标签是 C23 扩展'
# 'label at end of compound statement is incompatible with C standards before C23'
H8E280A51EBD5: '复合语句末尾的标签与 C23 之前的 C 标准不兼容'
# 'label at end of compound statement is incompatible with C++ standards before C++23'
H1F208E16CB25: '复合语句末尾的标签与 C++23 之前的 C++ 标准不兼容'
# 'label followed by a declaration is a C23 extension'
HE476C0C2BE2F: '后跟声明的标签是 C23 扩展'
# 'label followed by a declaration is incompatible with C standards before C23'
H8299673D895A: '后跟声明的标签与 C23 之前的 C 标准不兼容'
# 'lambda %0 is inaccessible due to ambiguity:%1'
H165915C96E61: 'Lambda %0 因歧义而不可访问:%1'
# 'lambda call operator should not be explicitly specialized or instantiated'
H3541695AB458: 'lambda调用运算符不应显式特化或实例化'
# 'lambda cannot be both mutable and static'
H057D935E257D: 'lambda不能同时是mutable和static'
# 'lambda cannot be declared %0'
H523BA4919111: 'lambda不能被声明为 %0'
# 'lambda capture %0 is not %select{used|required to be captured for this use}1'
HED12D4324492: 'lambda捕获 %0 未被%select{使用|为此用途要求捕获}1'
# 'lambda closure types are non-literal types before C++17'
H3BDD817E383F: '在C++17之前lambda闭包类型是非字面类型'
# 'lambda expression begins here'
H0582B6A6C9FD: 'lambda表达式始于此处'
# 'lambda expression in an unevaluated operand'
H2B5A38CCEDAB: '未求值的操作数中的lambda表达式'
# 'lambda expression in default argument cannot capture any entity'
H31423DFF8FC2: 'lambda表达式在默认参数中不能捕获任何实体'
# 'lambda expressions are incompatible with C++98'
HAE0AFEA72154: 'lambda表达式与C++98不兼容'
# 'lambda template parameter list cannot be empty'
H33C909CD1D80: 'lambda模板参数列表不能为空'
# 'lambda without a parameter clause is a C++23 extension'
HD70498A5F3EC: '无参数子句的lambda是C++23扩展'
# 'lambdas are a %select{C++11|clang HLSL}0 extension'
HD58884723190: 'lambda是 %select{C++11|clang HLSL}0 扩展'
# "language not recognized: '%0'"
H102C1DB9CB0E: "未识别的语言: '%0'"
# 'large atomic operation may incur significant performance penalty; the access size (%0 bytes) exceeds the max lock-free size (%1 bytes)'
H31655F77BD73: '大原子操作可能导致显著性能损失；访问大小（%0 字节）超过最大无锁大小（%1 字节）'
# 'layout blocks in reverse order'
H19EE0FFEC518: '以逆序排列块布局'
# 'lcov tracefile output'
HCE669C9CA888: 'lcov跟踪文件输出'
# 'left hand operand of type %0 to compound assignment cannot be truncated when used with right hand operand of type %1'
H00D9FE7F4F87: '类型为 %0 的左操作数在与类型 %1 的右操作数复合赋值时不能被截断'
# 'left hand operand to %0 must be a %select{|pointer to }1class compatible with the right hand operand, but is %2'
HE8A81161D486: '复合赋值运算符 %0 的左操作数必须与右操作数兼容的 %select{|指向}1类类型，但实际类型为 %2'
# 'left hand side of assignment operation(%0) must match one side of the sub-operation on the right hand side(%1 and %2)'
HEDD23F979FED: '赋值操作的左侧(%0)必须与右侧子操作的其中一侧(%1 或 %2)匹配'
# 'left operand of comma operator has no effect'
H1D36CC5E4D5A: '逗号运算符的左操作数无效果'
# 'left shift of negative value %0'
HF788BD55C118: '对负值 %0 进行左移操作'
# "length modifier '%0' results in undefined behavior or no effect with '%1' conversion specifier"
HDCB24BE7C9E8: "长度修饰符 '%0' 与 '%1' 转换说明符组合会导致未定义行为或无效果"
# 'libclc builtin preparation tool\n'
H8679FDE4DA62: 'libclc 内建准备工具\n'
# 'limit number of targets to consider when doing indirect call promotion on calls. 0 = no limit'
HD2EF861DC5DB: '限制间接调用提升时考虑的目标数量（针对函数调用）。0表示无限制'
# 'limit number of targets to consider when doing indirect call promotion on jump tables. 0 = no limit'
H039F79707FDF: '限制间接调用提升时考虑的目标数量（针对跳转表）。0表示无限制'
# 'limit number of targets to consider when doing indirect call promotion. 0 = no limit'
H5880E8C77FBD: '限制间接调用提升时考虑的目标数量。0表示无限制'
# 'limit optimizations to functions from the list'
HF1AAD3BC1D5B: '将优化限制为列表中的函数'
# 'limit optimizations to functions from the list (non-regex)'
H4820DAC9F83B: '将优化限制为非正则表达式列表中的函数'
# 'line marker directive requires a positive integer argument'
H8A0833C758AF: '行标记指令需要一个正整数参数'
# 'line splicing in Doxygen comments are not supported'
HD6510289D84D: 'Doxygen注释中的行拼接不受支持'
# "linking module '%0': %1"
H78786E2D2737: "链接模块 '%0' 时发生错误：%1"
# 'linking options'
H1E4F081C74A1: '链接选项'
# 'list item of type %0 is not valid for specified reduction operation: unable to provide default initialization value'
H5FEA755CA374: '类型为 %0 的列表项不适合指定的约简操作：无法提供默认初始化值'
# 'list of functions to always consider for inlining'
H00FB00D60661: '始终考虑内联的函数列表'
# 'list of functions to apply frame opts'
H723CBEBF937F: '应用帧优化的函数列表'
# 'list of functions to core dump on (debugging)'
HFF95EE476741: '核心转储触发的函数列表（调试用途）'
# 'list of functions to enable ICP for'
H4EBB92971A75: '启用ICP（调用成本提升）的函数列表'
# 'list of functions to never consider for inlining'
HE127B8F1CD43: '从不考虑内联的函数列表'
# 'list of functions to pad with amount of bytes'
H296C1F5DDCF1: '用指定字节数填充的函数列表'
# 'list of functions to print'
H1C3AE7A6EC95: '需要输出的函数列表'
# 'list of functions to skip'
HED4CB34A956C: '需要跳过的函数列表'
# 'list of functions with call sites for which to specialize memcpy() for size 1'
HD7F5B54EFF49: '为size参数为 1 时的memcpy调用位址进行专用优化的函数调用位置列表'
# "list of sections containing functions used for hugifying hot text. BOLT makes sure these functions are not placed on the same page as the hot text. (default='.stub,.mover')."
H07A4ADB5443D: "包含用于hugify热点代码的函数的节列表。BOLT会确保这些函数不会与热点代码放在同一页面（默认='.stub,.mover'）。"
# 'list of sections to reorder'
HE8B5B16B7FA7: '需要重新排序的节列表'
# 'list of symbol names that can be reordered'
H6F9EE9EC82ED: '可以重新排序的符号名称列表'
# 'list of symbol names that cannot be reordered'
H9016DB56BAB4: '不能重新排序的符号名称列表'
# 'literal construction method %0 has incompatible signature'
H9A98E6827407: '文字构造方法 %0 具有不兼容的函数签名'
# 'literal operator %0 must be in a namespace or global scope'
H6F0C93D8CF92: '文字操作符 %0 必须位于命名空间或全局作用域中'
# 'literal operator cannot have a default argument'
H2D253A373F0C: '文字操作符不能具有默认参数'
# 'literal operator must have C++ linkage'
HACF64718BD51: '文字操作符必须具有C++链接性'
# 'literal operator template cannot have any parameters'
HDB57FAFF64D9: '文字操作符模板不能有任何参数'
# 'literal operators are incompatible with C++98'
HC63AE1FBA425: '文字操作符与C++98不兼容'
# 'lldb'
H23F2598B46BF: 'lldb'
# 'llvm .bc -> .bc modular optimizer and analysis printer\n'
H5E0E5487AF50: 'llvm .bc -> .bc 模块化优化器及分析打印工具\n'
# 'llvm .bc -> .ll disassembler\n'
H6C7F6E9C06C4: 'llvm .bc -> .ll 反汇编器\n'
# 'llvm .ll -> .bc assembler\n'
HD4712D9BC53E: 'llvm .ll -> .bc 汇编器\n'
# 'llvm LTO linker\n'
H2892DC655E08: 'llvm LTO 链接器\n'
# 'llvm MC-JIT tool\n'
H06636F581609: 'llvm MC-JIT 工具\n'
# 'llvm SPGO profile generator\n'
H701BD947180F: 'llvm SPGO 剖析生成器\n'
# 'llvm codegen stress-tester\n'
HA26868605BE5: 'llvm 代码生成压力测试工具\n'
# 'llvm extractor\n'
HFF048809A3CA: 'llvm IR提取器\n'
# 'llvm host machine instruction characteristics measurment and analysis.\n'
HF3F3BF01E352: 'llvm 主机机器指令特性测量与分析。\n'
# 'llvm interpreter & dynamic compiler\n'
H0649CD7E70C5: 'llvm 解释器及动态编译器\n'
# 'llvm jit event listener test utility\n'
HC7AAB55CF667: 'llvm jit 事件监听器测试工具\n'
# 'llvm jitlink tool'
H2709B44451E8: 'llvm jitlink 工具'
# 'llvm linker\n'
HC9DC12DE7069: 'LLVM IR链接器\n'
# 'llvm machine code performance analyzer.\n'
H684FDD543DA3: 'LLVM机器码性能分析器。\n'
# 'llvm machine code playground\n'
H2F51084FBDF0: 'LLVM机器码实验场\n'
# 'llvm system compiler\n'
H8181CA7521BB: 'LLVM系统编译器'
# 'llvm tool to verify use-list order\n'
HAC60F05F36A9: '用于验证使用列表顺序的LLVM工具'
# 'llvm-as Options'
HCEBF82BEB0E9: 'llvm-as选项'
# 'llvm-bcanalyzer file analyzer\n'
HECC62C366128: 'LLVM BC文件分析器'
# 'llvm-boltdiff - BOLT binary diff tool\n\nEXAMPLE: llvm-boltdiff -data=a.fdata -data2=b.fdata exec1 exec2\n'
HB49452FEF405: 'llvm-boltdiff - BOLT 二进制差异工具\n\nEXAMPLE: llvm-boltdiff -data=a.fdata -data2=b.fdata exec1 exec2\n'
# 'llvm-cat Options'
H3A2E2CA997D5: 'llvm-cat选项'
# 'llvm-exegesis analysis options'
H89DF2607CBEA: 'llvm-exegesis分析选项'
# 'llvm-exegesis benchmark options'
HC43701CE0D82: 'llvm-exegesis基准测试选项'
# 'llvm-exegesis options'
HAF6D3F27C196: 'llvm-exegesis选项'
# 'llvm-extract Options'
H25F0C853A66B: 'llvm-extract选项'
# 'llvm-omp-kernel-replay Options'
H90111C7D3334: 'llvm-omp-kernel-replay选项'
# 'llvm-opt-report options'
HCF4237251086: 'llvm-opt-report选项'
# 'llvm-reduce options'
H9B15C3D059EC: 'llvm-reduce选项'
# 'load the input file as a Toy source.'
H8076D5B81C5F: '将输入文件加载为Toy源代码。'
# 'load the input file as an MLIR file'
HAC00602D295B: '将输入文件加载为MLIR文件'
# "loaded module file '%0' conflicts with imported file '%1'"
H758569B6F13F: "加载的模块文件 '%0' 与导入文件 '%1' 冲突"
# 'loader options'
HA2203CDD473C: '加载器选项'
# "loading modulemap '%0'"
HB01A5C3EDED8: "正在加载模块映射 '%0'"
# "loading parsed module '%0'"
H71E4776B6574: "正在加载解析后的模块 '%0'"
# 'local %select{struct|interface|union|class|enum}0 cannot be declared __module_private__'
H4E0562614A60: '局部%select{结构|接口|联合|类|枚举}0不能声明为__module_private__'
# 'local declaration nearly matches'
HA030BEFE649C: '局部声明几乎匹配'
# 'local declaration of %0 hides instance variable'
H09900D49A0E3: '局部声明的 %0 会隐藏实例变量'
# 'local type %0 as template argument is incompatible with C++98'
H6116FD3EFF04: '将局部类型 %0 作为模板参数与C++98不兼容'
# "local variable '%0' should not be used in 'declare target' directive;"
HF2D2B034481C: "局部变量 '%0' 不应在 'declare target' 指令中使用;"
# "local variable cannot be declared 'constinit'"
HE35DCF249418: "局部变量不能声明为 'constinit'"
# "locking '%0' to build module '%1'"
H36ABFAB03219: "锁定 '%0' 以构建模块 '%1'"
# 'logical expression with vector %select{type %1 and non-vector type %2|types %1 and %2}0 is only supported in C++'
H1200F428FBB0: '向量%select{类型 %1 与非向量类型 %2|类型 %1 和类型 %2}0 的逻辑表达式仅在C++中支持'
# 'logical not is only applied to the left hand side of this %select{comparison|bitwise operator}0'
H9E8ECD267F25: '逻辑非仅应用于此%select{比较运算符|位运算符}0的左操作数'
# 'lookup from the current scope refers here'
H9AFA3EAEA36F: '当前作用域的查找指向此处'
# 'lookup in the object type %0 refers here'
H3FD57FB46E2B: '在对象类型 %0 中的查找指向此处'
# 'lookup of %0 in member access expression is ambiguous'
H52F57D0BB44E: '成员访问表达式中的 %0 查找是模棱两可的'
# 'lookup of %0 in member access expression is ambiguous; using member of %1'
H632E112FD2AD: '成员访问表达式中的 %0 查找是模棱两可的；使用 %1 的成员'
# "loop iteration variable in the associated loop of 'omp %1' directive may not be %0, predetermined as %2"
H777624FA6F75: "与 'omp %1' 指令关联的循环迭代变量不能是 %0，已被预设为 %2"
# 'loop step is expected to be %select{negative|positive}0 due to this condition'
HF9B9B19EF744: '由于此条件，循环步长应为%select{负|正}0'
# 'loop to be fully unrolled must have a constant trip count'
HF58CAD452050: '要完全展开的循环必须具有常量迭代次数'
# 'loop variable %0 %diff{of type $ binds to a temporary constructed from type $|binds to a temporary constructed from a different type}1,2'
H8E540E772339: '循环变量 %0 %diff{类型$绑定到由类型$构造的临时对象|绑定到由不同类型构造的临时对象}1,2'
# 'loop variable %0 binds to a temporary value produced by a range of type %1'
HDD2F7E9780FE: '循环变量 %0 绑定到类型 %1 的范围生成的临时值'
# 'loop variable %0 creates a copy from type %1'
H0EB738A6DA64: '循环变量 %0 从类型 %1 创建副本'
# "loop variable %0 may not be declared %select{'extern'|'static'|'__private_extern__'|'auto'|'register'|'constexpr'|'thread_local'}1"
HD1C2B82FE9FA: "循环变量 %0 不能被声明为 %select{'extern'|'static'|'__private_extern__'|'auto'|'register'|'constexpr'|'thread_local'}1"
# "loop variable of loop associated with an OpenACC '%0' construct must be of integer, pointer, or random-access-iterator type (is %1)"
HDE685F11E1FA: "与OpenACC '%0' 结构关联的循环变量必须是整型、指针或随机访问迭代器类型（当前为 %1）"
# 'loop will run at most once (loop increment never executed)'
H41A7771F3080: '该循环最多执行一次（循环增量从未被执行）'
# "loop with a '%0' clause may not exist in the region of a '%1' clause%select{| on a '%3' construct}2"
H31D69B81DD7A: "带有 '%0' 子句的循环不能存在于 '%1' 子句 %select{|的 '%3' 结构}2区域中"
# 'lower transpose without using a runtime call'
H1DC7FFF629C0: '在不使用运行时调用的情况下转换转置'
# 'mac68k alignment pragma is not supported on this target'
H13A22B895D9E: '此目标不支持mac68k对齐pragma'
# 'macro %0 defined here'
H224BD0DEAAD4: '宏 %0 在此处定义'
# 'macro %0 has been marked as deprecated%select{|: %2}1'
HB9E9BBB38434: '宏 %0 已被标记为已弃用 %select{|: %2}1'
# 'macro %0 has been marked as final and should not be %select{undefined|redefined}1'
H416ADCAF4BDC: '宏 %0 已被标记为最终且不应%select{未定义|重新定义}1'
# 'macro %0 has been marked as unsafe for use in headers%select{|: %2}1'
H0BD2BA6647E5: '宏 %0 已被标记为在头文件中不安全 %select{|: %2}1'
# "macro '%0' contains embedded newline; text after the newline is ignored"
HCA29C3134207: "宏 '%0' 包含嵌入的换行符；换行符后的文本将被忽略"
# "macro '%0' was %select{defined|undef'd}1 in the precompiled file '%2' but %select{undef'd|defined}1 on the command line"
H4EEB08267D43: "宏 '%0' 在预编译文件 '%2' 中被%select{定义|取消定义}1，但在命令行中被%select{取消定义|定义}1"
# "macro expansion producing 'defined' has undefined behavior"
H6CE80CBEAD13: "生成 'defined' 的宏展开会导致未定义行为"
# 'macro is not used'
HB7A93ECCBE4F: '该宏未被使用'
# "macro marked '%select{deprecated|restrict_expansion|final}0' here"
H36EC3D2C5C8F: "此处标记的宏为'%select{已弃用|限制展开|最终版本}0'"
# 'macro name is a reserved identifier'
H75F2505E76F7: '宏名是保留的标识符'
# 'macro name missing'
H64036DCA4179: '缺少宏名'
# 'macro name must be an identifier'
HA83E076252EC: '宏名必须是标识符'
# "macro was %select{defined|#undef'd}0 here"
H90411BE5521B: '宏在此处%select{被定义|#undef}0'
# 'magnitude of floating-point constant too large for type %0; maximum is %1'
HC45BAE211EEF: '浮点常量的大小对类型 %0 来说过大；最大值为 %1'
# 'magnitude of floating-point constant too small for type %0; minimum is %1'
H77948F2AADFE: '浮点常量的大小对类型 %0 来说过小；最小值为 %1'
# 'main cannot be declared as a variable %select{in the global scope|with C language linkage}0'
HDFAAFDDA66C4: 'main不能声明为变量%select{在全局作用域中|具有C语言链接性}0'
# 'main file cannot be included recursively when building a preamble'
HFA8D0D05FC55: '构建预编译头时主文件不能递归包含'
# 'make jump tables size smaller at the cost of using more instructions at jump sites'
HFB74BDFA805D: '通过在跳转位置使用更多指令来减小跳转表的大小'
# 'make the interpreter print every volatile load and store'
H89B411120801: '使解释器打印每个易失性加载和存储操作'
# "malformed block record in PCH file: '%0'"
H89FF1C99B4CC: "PCH文件中的块记录格式错误: '%0'"
# "malformed or corrupted precompiled file: '%0'"
H32ACB7141453: "格式错误或损坏的预编译文件：'%0'"
# "malformed sanitizer coverage allowlist: '%0'"
HA08307F61916: "sanitizer coverage 允许列表格式错误: '%0'"
# "malformed sanitizer coverage ignorelist: '%0'"
HF4CE0A42147C: "sanitizer coverage 忽略列表格式错误: '%0'"
# "malformed sanitizer ignorelist: '%0'"
H98473149CB24: "sanitizer 忽略列表格式错误: '%0'"
# "malformed sanitizer metadata ignorelist: '%0'"
H7E49790904E8: "sanitizer 元数据忽略列表格式错误: '%0'"
# 'mangled name of %0 will change in C++17 due to non-throwing exception specification in function signature'
HC8027193700F: '由于函数签名中的非抛出异常规范，在C++17中 %0 的装饰名称将改变'
# "map type '%0' is previous specified here"
H3204C79CA043: '映射类型 "%0" 在此处之前已指定'
# 'map type is already specified'
HF4D36EA9229E: '映射类型已指定'
# "map type modifier '%0' is not allowed for '#pragma omp %1'"
H5A1E07271479: "映射类型修饰符 '%0' 不允许用于 '#pragma omp %1'"
# 'mapper type must be of struct, union or class type'
H3D3958379C94: '映射器类型必须为结构体、联合或类类型'
# 'mapping of union members is not allowed'
HD27CBEC61BC1: '联合成员的映射是不允许的'
# "mark %0 as '%select{final|sealed}1' to silence this warning"
HF7273FC85EE1: "将 %0 标记为 '%select{final|sealed}1' 以消除此警告"
# "mark 'operator==' as const or add a matching 'operator!=' to resolve the ambiguity"
H5A25A1F05320: "将 'operator==' 声明为const，或添加匹配的 'operator!=' 以解决歧义"
# "mark function boundaries with break instruction to make sure we accidentally don't cross them"
H5B830E6175D2: '使用断点指令标记函数边界，以确保我们不会意外跨过它们'
# 'marked %0 here'
HE33E97AC0225: '此处标记的 %0'
# "marked as 'declare variant' here"
H721AFFF82622: "此处标记为 'declare variant'"
# "marked as 'device_type(%0)' here"
HF283C800233B: "此处标记为 'device_type(%0)'"
# 'mask type size must be between 1-byte and 8-bytes'
HA5CB60FF0FBF: '掩码类型大小必须在 1 字节到 8 字节之间'
# 'match functions in binary 2 to binary 1 if they have the same hash of a function in binary 1'
HAF6822E35564: '如果二进制文件 2 中的函数与二进制文件 1 中的函数具有相同的哈希值，则将其匹配到二进制文件 1'
# "math errno enabled by '%0' after it was implicitly disabled by '%1', this may limit the utilization of the vector library"
HE93B3822306D: "'%0' 启用的数学errno在被 '%1' 隐式禁用后可能限制向量库的使用效率"
# 'mathematical notation character <U+%0> in an identifier is a Clang extension'
H0378BC9B5A74: '标识符中的数学符号 <U+%0> 是Clang扩展'
# 'matrix %select{row|column}0 index is not an integer'
H46FD8A206DB4: '矩阵%select{行|列}0索引不是整数类型'
# 'matrix %select{row|column}0 index is outside the allowed range [0, %1)'
H847B8076D2C2: '矩阵%select{行|列}0索引超出允许范围[0, %1)'
# 'matrix row and column subscripts cannot be separated by any expression'
H5ED6E19FD5C5: '矩阵的行和列下标不能被任何表达式分隔'
# 'matrix types extension is disabled. Pass -fenable-matrix to enable it'
H4F1847B4A9E6: '矩阵类型扩展处于禁用状态。请使用-fenable-matrix启用该功能'
# 'max depth when checking alias info in GatherAllAliases()'
HB91994902F54: '在GatherAllAliases()中检查别名信息时的最大深度'
# 'max number of bytes for the function to be considered small for inlining purposes'
H5D6C3AFD428B: '出于内联目的，函数被视为小的字节最大数量'
# 'max stack depth tracing'
H293E22C2DAE9: '最大堆栈深度跟踪'
# 'max stack depth tracing should use callback and only when stack depth more than specified'
HD415B8718378: '最大栈深度追踪应使用回调函数，且仅在栈深度超过指定值时启用'
# 'maxclusterrank requires sm_90 or higher, CUDA arch provided: %0, ignoring %1 attribute'
H49A2942ECE44: 'maxclusterrank需要sm_90或更高架构，当前CUDA架构为 %0，将忽略 %1 属性'
# 'maximal number of instructions to instrument in any given BB'
H65055BD64342: '在任意给定的基本块（BB）中要插入的指令最大数量'
# 'maximum address considered valid for heatmap (default 4GB)'
H617E4DDA7E48: '热图（heatmap）认为有效的最大地址（默认 4GB）'
# 'maximum function durations'
H6F70690AFB07: '函数最大持续时间'
# 'maximum number of bytes to reorder'
H584FBF1D94C1: '可重新排序的最大字节数'
# 'maximum number of bytes to use to align functions'
H20C9D30AEBA6: '用于对齐函数的最大字节数'
# 'maximum number of call sites to inline'
H4BA4C864A650: '内联的最大调用站点数量'
# 'maximum number of data relocations to process'
HD03C0F0EA38B: '要处理的最大数据重定位数量'
# 'maximum number of functions to print in top called functions section'
HB5333D52E6C6: '在最常调用函数部分中打印的最大函数数量'
# 'maximum number of functions to process'
H09D081159F9B: '要处理的最大函数数量'
# 'maximum number of hot basic blocks in a function for which to use a precise TSP solution while re-ordering basic blocks'
HA8A2B1281362: '在重新排序基本块时，使用精确的TSP解决方案所需函数中热基本块的最大数量'
# 'maximum number of inline iterations'
HF9B3A8E58122: '内联迭代的最大数量'
# 'maximum number of samples to read from LBR profile'
H39D9A5AFA87A: '从LBR配置文件中读取的最大样本数'
# 'maximum number of symbols to reorder'
HB1688A460BA8: '要重新排序的最大符号数'
# 'maximum percentage of stale functions to tolerate (default: 100)'
H9341327D8697: '可容忍的最大陈旧函数百分比（默认：100）'
# 'maximum search depth. 0 forces a greedy approach. warning: the algorithm is up to O(2^N), where N is the max depth.'
H61B898BD8A31: '最大搜索深度。0强制使用贪心算法。警告：该算法的复杂度最高可达O(2^N)，其中N是最大深度。'
# "meaningless '%0' on asm outside function"
H7C9CC9A0FF49: "在函数外部的asm语句中使用 '%0' 没有意义"
# 'median function durations'
H4412290B83EA: '函数中位持续时间'
# 'member %0 cannot have template arguments'
H7530E8235E69: '成员 %0 不能带有模板参数'
# "member %0 declared 'const' here"
H320C50D376E4: "成员 %0 在此处被声明为 'const'"
# 'member %0 declared here'
H523D63E160D3: '此处声明了成员 %0'
# 'member %0 first declared here'
H53F314C373D4: '成员 %0 首次声明于此'
# 'member %0 found in multiple base classes of different types'
HE96F2F88498F: '成员 %0 在不同类型的多个基类中找到'
# 'member %0 has the same name as its class'
HBDCB2F361AEB: '成员 %0 与其所属类具有相同的名称'
# 'member %0 of %1 is not a template; did you mean %select{|simply }2%3?'
H88F478FC5C17: '%1 的成员 %0 不是模板；是否应改为 %select{|直接}2%3？'
# 'member %0 used before its declaration'
H21EA4914C844: '在声明之前使用了成员 %0'
# 'member access into incomplete type %0'
H3F51F529F796: '尝试访问不完整类型 %0 的成员'
# 'member declaration does not match because it %select{is|is not}0 const qualified'
HB51C7FC5370B: '成员声明不匹配，因为其%select{是|不是}0 const限定符'
# 'member declaration nearly matches'
HA07B45D5B59A: '成员声明几乎匹配'
# 'member found by ambiguous name lookup'
H1816E255A34E: '通过模糊名称查找找到的成员'
# 'member function %0 is not needed and will not be emitted'
HC39E7B7627B2: '成员函数 %0 未被使用，将不会被生成'
# 'member function specialization matches %0'
HCDF99A0E6C9D: '成员函数特化与 %0 匹配'
# 'member initializer %0 does not name a non-static data member or base class'
H35E3E12D1C39: '成员初始化器 %0 未命名非静态数据成员或基类'
# 'member is declared here'
H08E5DDE7EA19: '成员在此处声明'
# "member is not a candidate because range type %0 has no '%select{end|begin}1' member"
HE822EBF784D6: '成员不是候选，因为范围类型 %0 没有‘%select{end|begin}1’成员'
# 'member not initialized by constructor'
H26EC51B7C7A4: '成员未由构造函数初始化'
# 'member of anonymous %select{struct|union}0 redeclares %1'
H9C0924E1182A: '匿名 %select{struct|union}0 的成员重新声明了 %1'
# 'member pointer has incomplete base type %0'
H9CA90CC9D193: '成员指针具有不完全基类型 %0'
# 'member pointer representation requires a complete class type for %0 to perform this expression'
HA14D1B995CD2: '成员指针的表示需要 %0 为完整类类型才能执行此表达式'
# 'member reference base type %0 is not a structure or union'
HDDC7E94D7C4D: '成员引用的基类型 %0 不是结构体或联合体'
# "member reference type %0 is %select{a|not a}1 pointer; did you mean to use '%select{->|.}1'?"
HCE4396C30D63: '成员引用类型 %0 是%select{一个|不是}1指针；是否应使用‘%select{->|.}1’？'
# 'member reference type %0 is not a pointer'
H1067A041C0C1: '成员引用类型 %0 不是指针'
# 'member template declared %0 here'
H81FEA7456BEB: '在此处声明的成员模板 %0'
# 'member type %0 found by ambiguous name lookup'
H1BDBA1C8E5BA: '通过模糊名称查找找到的成员类型 %0'
# 'member using declaration naming a non-member enumerator is incompatible with C++ standards before C++20'
HFDD47D4DEC61: '使用非成员枚举项的成员使用声明与 C++20 之前的 C++ 标准不兼容'
# "member using declaration naming non-class '%0' enumerator is incompatible with C++ standards before C++20"
H3AC79AC99394: "命名非类类型 '%0' 枚举项的成员使用声明与 C++20 之前的 C++ 标准不兼容"
# 'memory order argument to atomic operation is invalid'
H10A1EB7E5921: '原子操作的内存顺序参数无效'
# "memory order clause '%0' is specified here"
HEB7229373BDB: "此处指定了内存顺序子句 '%0'"
# 'merge multiple fdata into a single file'
H166CAC1CDA7E: '将多个fdata文件合并为一个文件'
# 'merge settag instruction in function epilog'
H69388C044859: '在函数尾迹中合并settag指令'
# 'merge stack variable initializers with tagging when possible'
H3914158550BF: '尽可能将栈变量初始化器与标记合并'
# 'merge-fdata options'
H84D7D36EDADD: '合并fdata选项'
# 'messages delimited by --- lines, with # comment support'
H35F2755289E5: '以---分隔的多条消息，支持#注释'
# 'messages delimited by `// -----` lines, with // comment support'
HFC97CA453D6E: '以`// -----`分隔的多条消息，支持//注释'
# 'messaging a Class with a method that is possibly direct'
H3E9374E93BAC: '通过可能为直接方法的类方法进行消息Pass'
# 'messaging super with a direct method'
H76B5A067ADF0: '通过直接方法向 super 发送消息'
# 'messaging unqualified id'
H25CF081972C3: '未限定标识符的消息Pass'
# 'messaging unqualified id with a method that is possibly direct'
H52C4ECCB3445: '通过可能为直接方法的未限定标识符进行消息Pass'
# 'method %0 declared here'
H0A29C282008D: '在此处声明的方法 %0'
# 'method %0 in protocol %1 not implemented'
H3B6F9A4CA03E: '协议 %1 中的方法 %0 未实现'
# 'method %0 is used for the forward class'
H9C1FB20B5554: '方法 %0 被用于前向类声明'
# 'method %0 that returns %1 declared here'
H81FA72B87C9D: '在此处声明返回 %1 的方法 %0'
# 'method definition for %0 not found'
H2A6463515852: '未找到 %0 方法的实现定义'
# 'method for accessing %select{dictionary|array}1 element must have Objective-C object return type instead of %0'
H2A6E5DD7828B: '访问 %select{字典|数组}1 元素的访问方法必须返回 Objective-C 对象类型而非 %0'
# "method has no return type specified; defaults to 'id'"
HD11D99B1C083: '方法未指定返回类型；默认返回类型为 `id`'
# 'method implementation does not match its declaration'
H2D5D386F5AFB: '方法实现与声明不匹配'
# 'method index parameter type %0 is not integral type'
H630B60C086B7: '方法索引参数类型 %0 不是整数类型'
# 'method is expected to return an instance of its class type %diff{$, but is declared to return $|, but is declared to return different type}0,1'
H4EBF90DD6088: '方法应返回其类类型实例%diff{（$ 期望但声明为返回$)|（$ 期望但声明为返回不同类型)}0,1'
# 'method key parameter type %0 is not object type'
H93D8788321DF: '方法键参数类型 %0 不是对象类型'
# 'method marked as designated initializer of the class here'
H6D873EC57BBB: '此处标记为类的指定初始化器的方法'
# "method name referenced in property setter attribute must end with ':'"
H48FC25BCA089: '在属性设置器属性中引用的方法名称必须以 ":" 结尾'
# 'method object parameter type %0 is not object type'
H7C5EC09F4D4E: '方法对象参数类型 %0 不是对象类型'
# 'method override for the designated initializer of the superclass %objcinstance0 not found'
H353D09FC8C8A: '未找到超类%objcinstance0的指定初始化器方法覆盖'
# 'method parameter of type %0 with no explicit ownership'
H012CAADA6E5A: '类型 %0 且没有显式所有权的方法参数'
# 'method parameter type %diff{$ does not match super class method parameter type $|does not match super class method parameter type}0,1'
H52F29D4B5323: '与超类方法参数类型 %diff{$ does not match super class method parameter type $|does not match super class method parameter type}0,1 不匹配'
# 'method possibly missing a [super %0] call'
HF2DE0E720AA4: '方法可能缺少对[super %0]的调用'
# 'method returns unexpected type %0 (should be an object type)'
HDA228B7E04A3: '方法返回意外类型 %0（应为对象类型）'
# "method type specifier must start with '-' or '+'"
H60683402DB43: '方法类型说明符必须以 "-" 或 "+" 开头'
# "method was declared as %select{an 'alloc'|a 'copy'|an 'init'|a 'new'}0 method, but its implementation doesn't match because %select{its result type is not an object pointer|its result type is unrelated to its receiver type}1"
H0332DF98668A: '该方法被声明为%select{一个 "alloc"|一个 "copy"|一个 "init"|一个 "new"}0 方法，但其实现不匹配，因为%select{其结果类型不是对象指针|其结果类型与其接收器类型无关}1'
# 'methods that %select{override superclass methods|implement protocol requirements}0 cannot be direct'
H10E1F7CDD559: '%select{覆盖超类方法|实现协议要求}0的方法不能是直接的'
# "micromips is not supported for target CPU '%0'"
H17AAF1CF7567: '目标CPU "%0" 不支持micromips'
# 'minimal size of the basic block that should be aligned'
H9310AFA3C7C1: '应对其齐的基本块的最小大小'
# 'minimum address considered valid for heatmap (default 0)'
HB0C898B37318: '热图视为有效的最小地址（默认 0）'
# 'minimum condition bias (pct) to perform a CMOV conversion, -1 to not account bias'
HF9B056CCAAE3: '执行CMOV转换的最小条件偏差（pct），-1表示不考虑偏差'
# 'minimum function durations'
H9FA9BE32CDEF: '函数最小持续时间'
# 'minimum misprediction rate (pct) to perform a CMOV conversion, -1 to not account misprediction rate'
H0816E5149451: '执行CMOV转换的最小预测错误率（pct），-1表示不考虑预测错误率'
# 'minimum number of points in an analysis cluster (dbscan only)'
H24AF23851D8A: '分析簇中的最小点数（仅DBSCAN）'
# 'minimum offset needed between block and successor to allow duplication'
H75F42A78BFD9: '允许复制块与其后继之间所需的最小偏移量'
# 'minimum vscale must be an unsigned integer greater than 0'
H97D216C9F9DC: '最小vscale必须是大于 0 的无符号整数'
# 'minus(-) operator for reductions is deprecated; use + or user defined reduction instead'
HB503599C3686: '归约操作的减法(-)运算符已弃用；请改用+或用户定义的归约'
# 'misaligned atomic operation may incur significant performance penalty; the expected alignment (%0 bytes) exceeds the actual alignment (%1 bytes)'
HB642C05FEFCE: '对齐不正确的原子操作可能导致显著性能损失；期望的对齐(%0 字节)超过实际对齐(%1 字节)'
# "misleading indentation; statement is not part of the previous '%select{if|else|for|while}0'"
H2D720E07A9B5: '误导性的缩进；该语句不属于前面的 "%select{if|else|for|while}0"'
# "mismatch between architecture and environment in target triple '%0'; did you mean '%1'?"
HFB1C45E0F3D8: '目标三元组 "%0" 中的架构和环境不匹配；您是指 "%1" 吗？'
# 'mismatch in number of block parameters and local size arguments passed'
H297CC009BE30: '传递的块参数数量与本地大小参数数量不匹配'
# 'misplaced %0; expected %0 here'
H6EEF8ABBCBBD: '"%0" 位置错误；此处应使用 %0'
# 'misplaced attributes; expected attributes here'
H71DF23AD8094: '位置不当的属性；此处应放置属性'
# 'misprediction threshold for skipping ICP on an indirect call'
H2799B1202BB8: '间接调用中跳过ICP的预测错误阈值'
# 'missing %1 after %0'
H71A0939C10D8: '在 %0 之后缺少 %1'
# "missing '(' after '#pragma %0' - ignoring"
H9BCF4D2D832C: "在#pragma %0 后缺少 '(' - 忽略"
# "missing '(' following __VA_OPT__"
HFEF64C94E397: "__VA_OPT__后缺少 '('"
# "missing ')' after '#pragma %0' - ignoring"
HD628B31A25D9: "在#pragma %0 后缺少 ')' - 忽略"
# "missing ')' in macro parameter list"
HBA1269832ABB: "宏参数列表中缺少 ')'"
# "missing '*' in type bound %0 for type parameter %1"
H0FC1C4510683: "在类型参数 %1 的类型边界 %0 中缺少 '*'"
# "missing ',' after %0"
H36D833E1BE2F: "在 %0 之后缺少 ','"
# "missing ',' between base or member initializers"
HC0E2DA10BD59: "基类或成员初始化器之间的初始化器缺少 ','"
# "missing ',' between enumerators"
H3BCFAD409136: "枚举项之间缺少 ','"
# "missing ':' after %0 - ignoring"
H6D49C0F56471: "在 %0 之后缺少 ':' - 忽略"
# "missing ':' after %0 modifier"
H1C42316D6361: "在 %0 修饰符之后缺少 ':'"
# "missing ':' in %0"
HB39748BAFE7C: "在 %0 中缺少 ':'"
# "missing ':' or ')' after %0 - ignoring"
HA24B4C500D05: "在 %0 之后缺少 ':' 或 ')' - 忽略"
# "missing '@end'"
H91CC5F3C7087: '缺少@end'
# "missing '[' at start of message send expression"
H352486DC1A63: "消息发送表达式开头缺少 '['"
# "missing 'export module' declaration in module interface unit"
H43BE56C41167: "在模块接口单元中缺少 'export module' 声明"
# "missing 'export' specifier in module declaration while building module interface"
H73E9D7F0EE4B: "构建模块接口时，在模块声明中缺少 'export' 指定符"
# "missing 'get=' or 'put='"
H5BBBF3CA84C4: "缺少 'get=' 或 'put='"
# "missing 'module' declaration at end of global module fragment introduced here"
HECF75AD1494B: "在此处引入的全局模块片段结尾缺少 'module' 声明"
# "missing 'template' keyword prior to dependent template name %0"
H6110BBE085CA: "缺少依赖模板名称 %0 之前的 'template' 关键字"
# "missing 'typename' prior to dependent type name %0"
H1584997CE5DB: "缺少依赖类型名称 %0 之前的 'typename'"
# "missing 'typename' prior to dependent type name %0 is a C++20 extension"
HA061A76A5828: "在依赖类型名 %0 前缺少 'typename'，这是C++20的扩展"
# "missing 'typename' prior to dependent type name %0 is incompatible with C++ standards before C++20"
HCDF9EEE90AEA: "在依赖类型名 %0 前缺少 'typename' 与C++20之前的C++标准不兼容"
# "missing 'typename' prior to dependent type template name %0"
HB65342C255DD: "缺少依赖类型模板名称 %0 之前的 'typename'"
# "missing '}' at end of definition of %q0"
HAF73F9C8E8E7: "在%q0定义末尾缺少 '}'"
# 'missing actual type specifier for pipe'
H369BCA42F29A: '管道缺少实际类型说明符'
# "missing argument to '#pragma %0'%select{|; expected %2}1"
H85D43DEA45AB: '#pragma %0 指令缺少参数 %select{|；期望 %2}1'
# "missing argument to '%0'"
H52AC6CD34BC9: "缺少 '%0' 的参数"
# "missing argument to debug command '%0'"
H68E5FEB79890: "调试命令 '%0' 缺少参数"
# "missing argument; expected %select{an integer value|'enable'%select{|, 'full'}1%select{|, 'assume_safety'}2 or 'disable'}0"
H6DC6E5CF70F4: "缺少参数；期望%select{整数值|'enable'%select{|, 'full'}1%select{|, 'assume_safety'}2 或 'disable'}0"
# 'missing context for method declaration'
HDB791FF5D00C: '方法声明缺少上下文'
# 'missing context for property implementation declaration'
HB2B46E5EAE97: '属性实现声明缺少上下文'
# 'missing custom discrimination'
H8E91DD601C8B: '缺少自定义判别式'
# 'missing debug command'
HC4112B242494: '缺少调试命令'
# 'missing default argument on parameter'
H8EC917CC5F93: '参数缺少默认参数'
# 'missing default argument on parameter %0'
H8F4C6F0521D4: '参数 %0 缺少默认参数'
# 'missing field %0 initializer'
HBCFF05CA88FD: '缺少字段 %0 初始化器'
# 'missing map type'
H4AA13FCA7666: '缺少映射类型'
# 'missing map type modifier'
H60251948404E: '缺少映射类型修饰符'
# 'missing numthreads attribute for %0 shader entry'
HFADE160C1BC1: "'%0' 着色器入口缺少numthreads属性"
# 'missing object format flag'
HD57D82290D05: '缺少对象格式标志'
# "missing or invalid line number following '@' in expected %0"
H296CBDA95848: '在期望的 %0 中@后缺少或无效的行号'
# 'missing parentheses around the size of parameter pack %0'
HA558CBB9F294: '参数包 %0 的大小周围缺少括号'
# 'missing plugin argument for plugin %0 in %1'
H8600AE8C89F9: '在 %1 中，插件 %0 缺少插件参数'
# 'missing plugin name in %0'
H4A2F8D6C22D3: '在 %0 中缺少插件名称'
# "missing reduction operator, expected '+', '*', 'max', 'min', '&', '|', '^', '&&', or '||', follwed by a ':'"
H9DF20C9098D2: "缺少规约运算符，期望 '+', '*', 'max', 'min', '&', '|', '^', '&&', 或 '||' 后跟一个 ':'"
# 'missing return type for function %0; did you mean the constructor name %1?'
H0096A8359309: '函数 %0 缺少返回类型；您是否指的是构造函数名称 %1？'
# "missing sanitizer ignorelist: '%0'"
HE7971DD1E969: "缺少 sanitizer 忽略列表：'%0'"
# 'missing sentinel in %select{function call|method dispatch|block call}0'
H10D39CEB9167: '在%select{函数调用|方法分派|块调用}0中缺少哨兵值'
# 'missing state for %0'
HCF224168FF82: '%0 缺少状态'
# "missing submodule '%0'"
H4FF2783EAA28: "缺少子模块 '%0'"
# 'missing symbol graph output directory, defaulting to working directory'
H1ACFD82E27C5: '缺少符号图输出目录，将默认使用当前工作目录'
# 'missing terminating %select{\'|\'"\'}0 character'
HC91AE5B6C664: '缺少终止字符%select{‘|’"’}0'
# "missing terminating ')' character"
H110B9B84BD50: "缺少终止的 ')' 字符"
# 'missing type bound %0 for type parameter %1 in %select{@interface|@class}2'
HCB937BA83DD0: '在 %select{@interface|@class}2 中的类型参数 %1 缺少类型边界 %0'
# "missing version number in '%0'"
H5280152B38E3: "'%0' 中缺少版本号"
# 'mixed CUDA and HIP compilation is not supported'
HDE7D3706C5B5: '混合 CUDA 和 HIP 编译不受支持'
# "mixing 'target_clones' specifier mechanisms is permitted for GCC compatibility; use a comma separated sequence of string literals, or a string literal containing a comma-separated list of versions"
H65625B3622E8: "为了兼容 GCC，允许混合使用 'target_clones' 规格说明机制；请使用逗号分隔的字符串字面量序列，或包含版本逗号分隔列表的字符串字面量"
# 'mixing declarations and code is a C99 extension'
H509E36ADC1D7: '混合声明和代码是 C99 的扩展'
# 'mixing declarations and code is incompatible with standards before C99'
HD580E194E35D: '混合声明和代码与 C99 之前的版本标准不兼容'
# 'mixture of designated and non-designated initializers in the same initializer list is a C99 extension'
H29C32AE72D18: '在同一个初始化程序列表中混合使用指定和未指定的初始化器是 C99 的扩展'
# 'mlir-query options'
HE19598DC2C40: 'mlir-query选项'
# 'mlir-reduce options'
H3CAB90C0AD8E: 'mlir-reduce 选项'
# 'mode %0 is not supported for enumeration types'
H9D1986A84BDA: '模式 %0 不支持枚举类型'
# 'mode attribute only supported for integer and floating-point types'
H759A20BD1268: 'mode属性仅支持整型和浮点类型'
# 'mode for simplify conditional tail calls'
H7E2CD8BDAB86: '简化条件尾调用的模式'
# 'moderate strategy'
H73892DAB539F: '适度策略'
# 'modification of object of const-qualified type %0 is not allowed in a constant expression'
H403821CE466D: '对const限定类型 %0 的对象进行修改在常量表达式中不允许'
# "modifier '%0' cannot be used along with modifier '%1'"
HDE467CEB2037: "修饰符 '%0' 不能与修饰符 '%1' 一起使用"
# 'modifying constructor parameter %0 that shadows a field of %1'
H1430708B59D6: '修改构造函数参数 %0，该参数覆盖了 %1 的字段'
# 'modularize.\n'
HA1E9FFD28E50: '模块化。\n'
# "module %0 does not depend on a module exporting '%1'"
H85DEF90A3AE0: '模块 %0 不依赖于导出 "%1" 的模块'
# "module %0 does not directly depend on a module exporting '%1', which is part of indirectly-used module %2"
H9D50309367F5: '模块 %0 不直接依赖于导出 "%1" 的模块，而该模块属于间接使用的模块 %2'
# "module '%0' %select{in|imported by}4 precompiled file '%1' found in a different module map file (%2) than when the importing precompiled file was built (%3)"
H9B94DD93868B: "模块 '%0'%select{在|被导入于}4预编译文件 '%1' 中发现于与导入预编译文件构建时不同的模块映射文件(%2)中(%3)"
# "module '%0' %select{is incompatible with|requires}1 feature '%2'"
H4440A0170E90: "模块 '%0' %select{与...不兼容|需要}1特性 '%2'"
# "module '%0' %select{uses|does not use}1 additional module map '%2'%select{| not}1 used when the module was built"
HAC53C3FABCDA: "模块 '%0' %select{使用|未使用}1附加模块映射 '%2'%select{|未}1在模块构建时使用"
# "module '%0' already re-exported as '%1'"
H6556B7A46703: "模块 '%0' 已作为 '%1' 重新导出"
# "module '%0' conflicts with already-imported module '%1': %2"
HED958876B86C: "模块 '%0' 与已导入的模块 '%1' 冲突：%2"
# "module '%0' in precompiled file '%1' %select{(imported by precompiled file '%2') |}4is not defined in any loaded module map file; maybe you need to load '%3'?"
HDC91DE6A026C: "预编译文件 '%1' 中的模块 '%0'%select{(被预编译文件 '%2' 导入) |}4 未在任何已加载的模块映射文件中定义；或许您需要加载 '%3'？"
# "module '%0' is defined in both '%1' and '%2'"
H9937FAC6E395: "模块 '%0' 在 '%1' 和 '%2' 中均有定义"
# "module '%0' is needed but has not been provided, and implicit use of module files is disabled"
H8C7DAF453831: "需要模块 '%0' 但未提供，并且模块文件的隐式使用已禁用"
# "module '%0' not found"
H55DF0ED78DC5: "未找到模块 '%0'"
# "module '%0' was built in directory '%1' but now resides in directory '%2'"
H38AD29640B23: "模块 '%0' 是在目录 '%1' 构建的，但现在位于目录 '%2'"
# "module compilation requires '-fmodules'"
H6A96D77D9F41: "模块编译需要 '-fmodules' 选项"
# 'module declaration can only appear at the top level'
HB03E6C215813: '模块声明只能出现在顶层'
# 'module declaration must occur at the start of the translation unit'
HA7783A63FE0B: '模块声明必须出现在翻译单元的开头'
# 'module defined here'
HDB50FF2BF5A8: '模块在此处定义'
# 'module file %0 cannot be loaded due to a configuration mismatch with the current compilation'
H469015AF9879: '模块文件 %0 由于与当前编译的配置不匹配而无法加载'
# "module file '%0' is missing its top-level submodule"
HFA537775278A: "模块文件 '%0' 缺少其顶层子模块"
# "module file '%0' was validated as a system module and is now being imported as a non-system module; any difference in diagnostic options will be ignored"
H13B637DDA3AA: "模块文件 '%0' 已被验证为系统模块，现在将作为非系统模块导入；任何诊断选项的差异将被忽略"
# 'module file suffix override'
H69E50E2734CF: '模块文件后缀覆盖'
# "module header file '%0' not found"
HDA48886085ED: "模块头文件 '%0' 未找到"
# 'module imported here'
HA3A8055B303E: '模块在此处导入'
# "module interface compilation requires '-std=c++20'"
HA34462B55274: "模块接口编译需要 '-std=c++20'"
# "module loaded from '%0'"
H07E2BBCF1C1E: "模块加载自 '%0'"
# "module map file '%0' not found"
HD693305F9871: "模块映射文件 '%0' 未找到"
# "module name '%0' specified on command line does not match name of module"
H0F48D36629AC: "命令行上指定的模块名称 '%0' 与当前模块名称不匹配"
# 'module output directory (default .)'
H445A6DEE34DF: '模块输出目录（默认 .）'
# 'module partition implementations cannot be exported'
HFE1B8CB7B1E9: '模块分区实现不能被导出'
# 'module partition imports must be within a module purview'
H99C430D138F5: '模块分区导入必须位于模块作用域内'
# 'module partitions are only supported for C++20 onwards'
HB98F31FF7B9A: '模块分区仅支持 C++20 及更高版本'
# 'module search directory'
H3FAA97FDA5D1: '模块搜索目录'
# 'module%select{| partition}0 imports cannot be in the %select{global|private}1 module fragment'
HE6F2588D0369: '模块 %select{|分区}0 导入不能位于 %select{全局|私有}1 模块片段中'
# "more '%%' conversions than data arguments"
H9766AC9D490A: "存在多于数据参数的 '%%' 转换"
# "more than one 'device_type' clause is specified"
H018E0AE39152: "指定了多个 'device_type' 子句"
# "more than one for-loop in a loop associated with OpenACC '%0' construct with a '%1' clause"
H30D49A113B6A: "与带有 '%1' 子句的 OpenACC '%0' 构造关联的循环中存在多个 for 循环"
# 'more than one framework/dynamic library found'
H611E8232270A: '找到多个框架/动态库'
# "more than one input constraint matches the same output '%0'"
H4D494A49ED15: "多个输入约束匹配相同的输出 '%0'"
# 'move jump tables to a separate section'
HC21B261E02F6: '将跳转表移动到单独的节'
# 'moving a local object in a return statement prevents copy elision'
H928AEBBA3589: '在返回语句中移动局部对象会阻止拷贝省略'
# 'moving a temporary object prevents copy elision'
H7FCDBDAE9C59: '移动临时对象会阻止复制省略'
# 'ms_struct may not produce Microsoft-compatible layouts for classes with base classes or virtual functions'
H0D36DB1654BA: 'ms_struct 可能无法为具有基类或虚函数的类生成与 Microsoft 兼容的布局'
# "ms_struct may not produce Microsoft-compatible layouts with fundamental data types with sizes that aren't a power of two"
H9013C05CB59B: 'ms_struct 可能无法为基本数据类型（其大小不是 2 的幂次）生成与 Microsoft 兼容的布局'
# 'mtriple'
H7584397F39BE: 'mtriple'
# 'multi-character character constant'
H8914BC0B6E30: '多字符字符常量'
# 'multi-dimensional arrays of WebAssembly references are not allowed'
HDC4921C402A6: '不允许使用 WebAssembly 引用的多维数组'
# 'multi-line // comment'
HC0A7D2EE8599: '多行 // 注释'
# 'multilib configuration error: %0'
H51BCFF1832A0: '多目标配置错误：%0'
# "multiple %0 architectures are detected: %1; only the first one is used for '%2'"
HF49114F051BF: "检测到多个 %0 架构： %1；仅使用第一个架构用于 '%2'"
# "multiple %select{'step size'|'linear modifier'}0 found in linear clause"
H6C58F45C9F56: "在线性子句中发现了多个 %select{'步长大小 '|' 线性修饰符'}0"
# "multiple 'callback' attributes specified"
H9EF4CEF4A9C0: "指定了多个 'callback' 属性"
# "multiple 'cpu_specific' functions cannot specify the same CPU: %0"
H3B8B7713681E: "指定相同 CPU 的多个 'cpu_specific' 函数不允许： %0"
# "multiple 'lifetime_capture' attributes specified"
H42096CECC49E: "指定了多个 'lifetime_capture' 属性"
# "multiple 'routine' directives with 'bind' clauses are not permitted to refer to the same function"
HDA1D710FAA21: "'bind' 子句的多个 'routine' 指令不允许指向同一函数"
# 'multiple access qualifiers'
HA0304D566382: '多个访问限定符'
# 'multiple address spaces specified for type'
H4075C38BB93B: '为类型指定了多个地址空间'
# 'multiple array elements associated with the same variable are not allowed in map clauses of the same construct'
H289BE95E22C4: '同一构造中的 map 子句不允许将同一变量关联到多个数组元素'
# 'multiple conversions from expression type %0 to an integral type'
H80B8D963ECA1: '表达式类型 %0 到整型的多个转换'
# 'multiple conversions from switch condition type %0 to an integral or enumeration type'
H23301D5B9A53: 'switch 条件类型 %0 到整型或枚举类型的多个转换'
# 'multiple declarations of method %0 found and ignored'
HA50D97FB9EC5: '找到并忽略方法 %0 的多个声明'
# 'multiple default labels in one switch'
H1F979F2765D2: '一个 switch 中有多个默认标签'
# 'multiple definitions are found for the same key in index '
HBED55B0B868B: '索引中为同一个键发现了多个定义'
# 'multiple ellipses in pack capture'
H2EAABC9D1825: '参数包捕获中包含多个省略号'
# 'multiple garbage collection attributes specified for type'
H8DF299790474: '为类型指定了多个垃圾回收属性'
# 'multiple identical address spaces specified for type'
H2A39AD934787: '为类型指定了多个相同的地址空间'
# 'multiple initializations given for base %0'
H6C502C93AC06: '为基类 %0 提供了多次初始化'
# 'multiple initializations given for non-static member %0'
HF2A12907FBDA: '为非静态成员 %0 提供了多次初始化'
# "multiple inputs are not valid for header units (first extra '%0')"
H85058EEFACAE: "存在多个无效的头单元输入（第一个额外输入 '%0')"
# 'multiple methods named %0 found'
H170992E437FC: '找到多个名为 %0 的方法'
# 'multiple methods named %0 found with mismatched result, parameter type or attributes'
HB7ACC94E443E: '找到多个名为 %0 的方法，其返回类型、参数类型或属性不匹配'
# 'multiple overloads of %0 instantiate to the same signature %1'
H3B92DD0A02C5: '重载的 %0 实例化为相同的签名 %1'
# 'multiple packs in structured binding declaration'
HFE5E55E2957C: '结构化绑定声明中包含多个参数包'
# 'multiple return statements in constexpr function is a C++14 extension'
H4582B1A35055: 'constexpr 函数中包含多个 return 语句是 C++14 扩展'
# 'multiple return statements in constexpr function is incompatible with C++ standards before C++14'
H4061EC95BBA4: 'constexpr 函数中包含多个 return 语句与 C++14 之前的版本标准不兼容'
# "multiple suitable %0 functions for %1; no 'operator delete' function will be invoked if initialization throws an exception"
HB304821CF54E: "为 %1 存在多个合适的 %0 函数；若初始化时抛出异常则不会调用 'operator delete' 函数"
# 'multiple suitable %0 functions in %1'
H04588097A2D5: '在 %1 中存在多个合适的 %0 函数'
# 'multiple unsequenced modifications to %0'
HBE9DFDF729B3: '对 %0 进行了多次无序列化的修改'
# 'multiple vtable pointer authentication policies on %0'
H64E76C32EB13: '%0 上指定了多个 vtable 指针认证策略'
# 'multiversioned function declaration has a different %select{calling convention|return type|constexpr specification|inline specification|linkage|language linkage}0'
H037AEBCE675B: '多版本函数声明的 %select{调用约定|返回类型|constexpr 标识|内联标识|链接性|语言链接性}0 不一致'
# 'multiversioned function must have a prototype'
HC2FE50BE244F: '多版本函数必须具有原型声明'
# 'multiversioned function redeclarations require identical target attributes'
H21088B0A235D: '多版本函数的重新声明需要具有相同的 target 属性'
# 'multiversioning attributes cannot be combined'
HB5E9464B0FCA: '多版本化属性不能组合使用'
# "must be declared with 'noexcept'"
H987DB13AD301: "必须用 'noexcept' 声明"
# 'must be specified at least once!'
H226887FCC25B: '必须至少指定一次！'
# 'must explicitly describe intended ownership of an object array parameter'
H94C16C029EFB: '必须明确描述对象数组参数的预期所有权'
# 'must explicitly qualify name of member function when taking its address'
H10EC7DC2756E: '在获取成员函数地址时必须显式限定其名称'
# "must handle potential future platforms with '*'"
H52CBF98EE88A: '必须处理未来平台中可能的 "*"'
# 'must name member using the type of the current context %0'
H0A063C055ADE: '必须使用当前上下文 %0 的类型命名该成员'
# "must pass in an explicit %0 gpu architecture to '%1'"
H748BF240D8AC: "必须向 '%1' 显式传递 %0 GPU架构"
# "must provide a symbol graph output directory using '--symbol-graph-dir=<directory>'"
H7FEC01DD8141: "必须使用'--symbol-graph-dir=<目录>'指定符号图输出目录"
# 'must qualify identifier to find this declaration in dependent base class'
HB8E730405435: '必须限定标识符才能在依赖基类中查找此声明'
# "must specify '-fmodule-name=%0' to enter %select{|submodule of }1this module%select{ (current module is %3)|}2"
HF0DE733FAF70: "必须指定 '-fmodule-name=%0' 以进入 %select{|该模块的子模块}1此模块%select{（当前模块为 %3）|}2"
# 'must specify system root with -isysroot when building a relocatable PCH file'
H530DD8BE4BB8: '构建可重定位的PCH文件时必须使用-isysroot指定系统根目录'
# "must use '%1' tag to refer to type %0%select{| in this scope}2"
H25B19F90B2A8: "必须使用 '%1' 标签引用类型 %0%select{|在此作用域内}2"
# 'my-tool options'
H6F25BE7781B0: 'my-tool 选项'
# 'n'
HD1854CAE891E: '否'
# 'name defined in alias declaration must be an identifier'
HF20E175DA10B: '别名声明中定义的名称必须是标识符'
# 'name defined in concept definition must be an identifier'
H9F376A6B25D8: '概念定义中定义的名称必须是标识符'
# 'named bit-field %0 has zero width'
HB27FCD740169: '命名的位段 %0 宽度为零'
# 'named variadic macros are a GNU extension'
H4A2738C3ADE2: '命名的可变参数宏是GNU扩展'
# 'namespace %0 defined here'
H6C2973533802: '命名空间 %0 在此处定义'
# 'namespace alias cannot be inline'
H69290D9B2469: '命名空间别名不能是内联的'
# 'namespace alias must be a single identifier'
HA11E2A62D886: '命名空间别名必须是一个标识符'
# "namespace can only apply to 'push' or 'pop' directives"
H6F30E709453F: '命名空间只能应用于 "push" 或 "pop" 指令'
# 'namespaces can only be defined in global or namespace scope'
HDB4E6C24AE7F: '命名空间只能在全局或命名空间作用域中定义'
# "negated attribute subject matcher sub-rule '%0' contradicts sub-rule '%1'"
H92B926B255DE: "否定的属性主题匹配子规则 '%0' 与子规则 '%1' 矛盾"
# 'negative shift count %0'
HC6E4102E7BA3: '负的移位次数 %0'
# "nested OpenMP context selector contains duplicated trait '%0' in selector '%1' and set '%2' with different score"
HC583359DCCE0: '嵌套的OpenMP上下文选择器在选择器 "%1" 和集合 "%2" 中包含重复的特征 "%0"，且评分不同'
# 'nested designators are a C99 extension'
H97E72072881F: '嵌套的设计说明符是C99扩展'
# 'nested name specifier %0 for declaration does not refer into a class, class template or class template partial specialization'
H326DE285E8C5: '声明的嵌套名称说明符 %0 不指向类、类模板或类模板的部分特化'
# 'nested name specifier for a declaration cannot depend on a template parameter'
H87A0C3C18BC3: '声明的嵌套名称说明符不能依赖于模板参数'
# "nested namespace definition cannot be 'inline'"
HB262A63F161A: '嵌套的命名空间定义不能是 "inline"'
# 'nested namespace definition is a C++17 extension; define each namespace separately'
HEFB4B9AD8E01: '嵌套的命名空间定义是C++17扩展；请分别定义每个命名空间'
# 'nested namespace definition is incompatible with C++ standards before C++17'
H0E35039F1D67: '嵌套的命名空间定义与C++17之前的C++标准不兼容'
# 'nested parentheses not permitted in %0'
H34953581058C: '在 %0 中不允许嵌套的括号'
# 'nested redefinition of %0'
H0AC10F45C385: '%0 的嵌套重新定义'
# 'nested teams construct here'
HF6BEE2475F61: '此处的嵌套teams构造'
# 'nested user conditions in OpenMP context selector not supported (yet)'
H4C0B107BB3D4: 'OpenMP上下文选择器中的嵌套用户条件尚未被支持'
# 'never apply unchecked-ld-st'
HBB179F0E1AB0: '从不应用未经检查的ld-st'
# 'never print'
H669835729B5F: '从不打印'
# 'never replace exit value'
H0750F0A2D157: '从不替换退出值'
# 'new expression for type %0 contains multiple constructor arguments'
H0D34CDEC5737: '类型 %0 的new表达式包含多个构造函数参数'
# 'new expression for type %0 has incompatible constructor argument of type %1'
H8E7FF8B53FFB: '类型 %0 的new表达式具有类型 %1 的不兼容构造函数参数'
# 'new expression for type %0 requires a constructor argument'
H55FA18FEEE0E: '类型 %0 的new表达式需要构造函数参数'
# 'next %select{instance variable declaration|synthesized instance variable}0 is here'
H6502100189C0: '下一个%select{实例变量声明|合成的实例变量}0在此处'
# 'next field declaration is here'
H589A37214DA3: '下一个字段声明在此处'
# 'no %select{getter|setter}0 defined for property %1'
HDA010EA6C052: '属性 %1 未定义 %select{getter|setter}0'
# 'no %select{struct|interface|union|class|enum}0 named %1 in %2'
HCA856DA687CE: '在 %2 中没有名为 %1 的 %select{struct|interface|union|class|enum}0'
# "no 'assign', 'retain', or 'copy' attribute is specified - 'assign' is assumed"
H5D9A45CF4470: "未指定 'assign'、'retain' 或 'copy' 属性，默认使用 'assign'"
# 'no @interface declaration found in class messaging of %0'
H39108401F4F8: '在 %0 的类消息中未找到@interface声明'
# "no MCU device specified, but '-mhwmult' is set to 'auto', assuming no hardware multiply; use '-mmcu' to specify an MSP430 device, or '-mhwmult' to set the hardware multiply type explicitly"
HF3E9B95BB7DD: "未指定MCU设备，但 '-mhwmult' 设置为 'auto'，假设没有硬件乘法；使用 '-mmcu' 指定MSP430设备，或使用 '-mhwmult' 显式设置硬件乘法类型"
# 'no PowerPC native vector element order.'
H49C9870074B0: '不使用PowerPC原生向量元素顺序。'
# "no analyzer checkers or packages are associated with '%0'"
H8B728EEF35B9: "没有与 '%0' 关联的分析检查器或包"
# 'no avr-libc installation can be found on the system, cannot link standard libraries'
H5206EA6489A5: '系统中未找到avr-libc安装，无法链接标准库'
# 'no candidate function template was found for dependent %select{member|friend}0 function template specialization'
HC620314BA8FA: '未找到与相关 %select{member|friend}0 函数模板特化对应的候选函数模板'
# "no case matching constant switch condition '%0'"
HBFE1788B232F: "没有与常量switch条件 '%0' 匹配的case"
# "no closing ']' for '%%[' in scanf format string"
H5E8D81CB9C26: "scanf格式字符串中的 '%%[' 缺少闭合的 ']'"
# 'no corresponding base class here'
HBBF529A4447F: '此处没有对应的基类'
# 'no corresponding enumerator here'
HCF6777617E14: '此处没有对应的枚举项'
# 'no corresponding field here'
H8BC5689EEC5A: '此处没有对应的字段'
# 'no corresponding friend here'
H0544B78403CC: '此处没有对应的friend'
# 'no corresponding superclass here'
HE11938993661: '此处没有对应的超类'
# "no declaration found for exported symbol '%0' in dynamic library"
H247D438751B2: "在动态库中未找到导出符号 '%0' 的声明"
# "no declaration was found for exported symbol '%0' in dynamic library"
H01E907352618: "在动态库中未找到导出符号 '%0' 的声明"
# "no expected directives found: consider use of '%0-no-diagnostics'"
H60C61DB5DCD2: "未找到期望的指令；考虑使用 '%0-no-diagnostics'"
# 'no function template matches function template specialization %0'
H783C344DF4FC: '没有函数模板与函数模板特化 %0 匹配'
# 'no getter method %1 for %select{increment|decrement}0 of property'
H27A03BEFDE9D: '属性的 %select{increment|decrement}0 操作没有对应的getter方法 %1'
# 'no getter method for read from property'
HC653B7766A2E: '读取属性时没有对应的getter方法'
# "no handler registered for module format '%0'"
H54F9399D659E: "未注册处理模块格式 '%0' 的处理器"
# 'no input files'
HFFB86B2450DC: '没有输入文件'
# 'no install name specified: add -install_name <path>'
H183DF472D6DF: '未指定安装名：添加 -install_name <路径>'
# 'no known %select{instance|class}1 method for selector %0'
H41C44394DC27: '未找到选择器 %0 的已知 %select{实例|类}1 方法'
# "no known method %select{%objcinstance1|%objcclass1}0; cast the message send to the method's return type"
HD141497E30B9: '未找到已知方法 %select{%objcinstance1|%objcclass1}0；请将消息发送转换为目标方法返回类型'
# "no library '%0' found in the default clang lib directory or in LIBRARY_PATH; use '--libomptarget-%1-bc-path' to specify %1 bitcode library"
H56082C491F7D: "在默认clang库目录或LIBRARY_PATH中未找到库 '%0'；使用 '--libomptarget-%1-bc-path' 指定 %1 比特码库"
# 'no macro named %0'
HDBF2015FF73B: '没有名为 %0 的宏'
# 'no matching %0 function for non-allocating placement new expression; include <new>'
H7020E0B0AF12: '非分配式placement new表达式没有匹配的 %0 函数；包含 <new>'
# "no matching '#pragma clang module begin' for this '#pragma clang module end'"
HCC39D351076F: "没有与此 '#pragma clang module end' 对应的 '#pragma clang module begin'"
# "no matching '#pragma clang module end' for this '#pragma clang module begin'"
H688037E203CF: "没有与此 '#pragma clang module begin' 对应的 '#pragma clang module end'"
# "no matching '#pragma clang module endbuild' for this '#pragma clang module build'"
H4D6A2C63F3F1: "没有与此 '#pragma clang module build' 对应的 '#pragma clang module endbuild'"
# 'no matching constructor for initialization of %0'
H60A16B350ED3: '初始化 %0 时没有匹配的构造函数'
# 'no matching conversion for %select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2'
HB6FD5E96FCBB: '无法将 %1 转换为 %2 的 %select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 转换'
# 'no matching function for call to %0'
HF7D6FEC7B803: '调用 %0 时没有匹配的函数'
# 'no matching function for call to object of type %0'
H4AB0B7C8D656: '调用类型 %0 的对象时没有匹配的函数'
# "no matching literal operator for call to %0%select{| with argument of type %2| with arguments of types %2 and %3}1%select{| or 'const char *'}4%select{|, and no matching literal operator template}5"
H1F7F02224823: "调用 %0%select{| 的参数类型为 %2| 的参数类型为 %2 和 %3}1%select{| 或 'const char *'}4%select{|，且没有匹配的字面量操作符模板}5 字面量操作符"
# 'no matching member function for call to %0'
HACEA313A920D: '调用 %0 时没有匹配的成员函数'
# "no matching target found for target variant '%0'"
H2CC48DEFF159: "未找到与目标变体 '%0' 对应的匹配目标"
# 'no member %0 in %1; it has not yet been instantiated'
H6800794A683C: '%1 中没有成员 %0；尚未实例化该成员'
# 'no member named %0 in %1'
H85214E062B3A: '%1 中没有名为 %0 的成员'
# 'no member named %0 in %1; did you mean %select{|simply }2%3?'
H5B97925635DE: '在 %1 中没有名为 %0 的成员；您是否是指 %select{|仅仅 }2%3？'
# "no member named %0 in %1; did you mean to use '->' instead of '.'?"
HBE0974E3EE78: "在 %1 中没有名为 %0 的成员；是否应该使用 '->' 而不是 '.'？"
# 'no method with selector %0 is implemented in this translation unit'
H0CDD4F98E18F: '在此翻译单元中未实现选择器 %0 对应的方法'
# 'no module map available for module %0'
HF688B8490C1B: '模块 %0 没有可用的模块映射'
# 'no module name provided; specify one with -fmodule-name='
H99A7BF8D2824: '未提供模块名称；请使用-fmodule-name=指定'
# "no module named '%0' %select{found|in '%2'}1, parent module must be defined before the submodule"
H86A38EF918F2: "未找到名为 '%0' 的模块 %select{找到|在 '%2' 中}1；父模块必须在子模块之前定义"
# "no module named '%0' declared in module map file '%1'"
HABF2F4633281: "模块映射文件 '%1' 中未声明名为 '%0' 的模块"
# "no module named '%0' in '%1'"
H658500ACD8C1: "在 '%1' 中没有名为 '%0' 的模块"
# "no module named '%0' visible from '%1'"
HA7094B5AEB21: "在 '%1' 中不可见名为 '%0' 的模块"
# "no more 'if' clause is allowed"
H8F7A1C6703AA: "不允许再有 'if' 子句"
# "no more than one option '--config' is allowed"
H3089388E4475: "选项 '--config' 最多允许指定一次"
# 'no multilib found matching flags: %0'
HCDE4340CFBD3: '未找到匹配标志 %0 的multilib'
# 'no namespace named %0 in %1; did you mean %select{|simply }2%3?'
HF6FEAE5E55D9: '在 %1 中没有名为 %0 的命名空间；您是否是指 %select{|仅仅 }2%3？'
# 'no namespace named %0; did you mean %1?'
H81CE4465B841: '没有名为 %0 的命名空间；您是否是指 %1？'
# 'no newline at end of file'
HC3F31DC1712E: '文件末尾没有换行符'
# 'no output file specified'
HA94EBB9ACB5A: '未指定输出文件'
# 'no previous extern declaration for non-static variable %0'
H8B284B72F880: '非静态变量 %0 没有之前的extern声明'
# 'no previous prototype for function %0'
H03B77D9B5049: '函数 %0 没有之前的原型声明'
# 'no profile data available for file "%0"'
H59152796471E: '文件 "%0" 没有可用的性能分析数据'
# 'no return statement in %select{constexpr|consteval}0 function'
H6CABFAB2482E: '在 %select{constexpr|consteval}0 函数中没有return语句'
# "no submodule named %0 in module '%1'"
H2B7BA310F788: "模块 '%1' 中没有名为 %0 的子模块"
# "no submodule named %0 in module '%1'; did you mean '%2'?"
H7D6A5E92FB55: "模块 '%1' 中没有名为 %0 的子模块；是否是指 '%2'？"
# "no submodule named %0 in module '%1'; using top level '%2'"
H5C502E1660AA: "模块 '%1' 中没有名为 %0 的子模块；使用顶层的 '%2'"
# "no such %select{public|private|project}1 header file: '%0'"
H6EFAEBB81765: "没有这样的%select{公开|私有|项目}1头文件：'%0'"
# "no such excluded %select{public|private}0 header file: '%1'"
HED06FD077272: "没有这样的排除%select{公开|私有}0头文件：'%1'"
# "no such file or directory: '%0'"
HE170FBCF53FC: "没有这样的文件或目录：'%0'"
# "no such file or directory: '%0'; did you mean '%1'?"
HE112F2418E57: "没有这样的文件或目录：'%0'；是否是指 '%1'？"
# "no such include directory: '%0'"
H7E37FF613F8F: "没有这样的包含目录：'%0'"
# "no such sysroot directory: '%0'"
H7EBC246FEEA8: "没有这样的sysroot目录：'%0'"
# 'no suitable member %0 in %1'
H3750344F18EF: '%1 中没有合适的成员 %0'
# "no suitable precompiled header file found in directory '%0'"
HC9D05A0684EB: "目录 '%0' 中未找到预编译头文件"
# 'no target microcontroller specified, please pass -mmcu=<mcu name>'
H861E68DCEBF9: '未指定目标微控制器，请通过-mmcu=<mcu名称>传递参数'
# 'no template named %0'
HFC0C70B06D89: '没有名为 %0 的模板'
# 'no template named %0 in %1'
H16DB7E6BC24D: '%1 中没有名为 %0 的模板'
# 'no template named %0 in %1; did you mean %select{|simply }2%3?'
HCDFE5581F7D6: '%1 中没有名为 %0 的模板；是否是指 %select{|简单}2%3？'
# 'no template named %0; did you mean %1?'
H32AFF6E21FDC: '没有名为 %0 的模板；是否是指 %1？'
# 'no type named %0 in %1'
H6E87E8CAFF42: '%1 中没有名为 %0 的类型'
# 'no type named %0 in %1; did you mean %select{|simply }2%3?'
H014C7B262D03: '%1 中没有名为 %0 的类型；是否是指 %select{|简单}2%3？'
# "no type named 'type' in %0; 'enable_if' cannot be used to disable this declaration"
H03B3775679FC: "%0 中没有名为 'type' 的类型；'enable_if' 无法用于禁用此声明"
# 'no type or protocol named %0'
HFF0D89AB2752: '没有名为 %0 的类型或协议'
# "no valid clauses specified in OpenACC 'declare' directive"
H136795D57206: "在OpenACC 'declare' 指令中未指定有效的子句"
# 'no variable template matches specialization; did you mean to use %0 as function template instead?'
H702E78FBEC31: '没有与特化匹配的变量模板；是否应将 %0 用作函数模板？'
# 'no variable template matches%select{| partial}0 specialization'
H0903C7695A91: '没有与 %select{| 部分}0 特化匹配的变量模板'
# 'no viable candidate for explicit instantiation of %0'
HAEBC7520AFB0: '显式实例化 %0 时没有可用的候选项'
# 'no viable constructor %select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1'
HC9B75808C9E9: '在类型 %1 的%select{复制变量|复制参数|初始化模板参数|返回对象|初始化语句表达式结果|抛出对象|复制成员子对象|复制数组元素|分配对象|复制临时对象|初始化基类子对象|初始化向量元素|捕获值}0时，没有可用的构造函数'
# 'no viable constructor %select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1; C++98 requires a copy constructor when binding a reference to a temporary'
HBD2DEF3D3EA1: '在类型 %1 的%select{复制变量|复制参数|初始化模板参数|返回对象|初始化语句表达式结果|抛出对象|复制成员子对象|复制数组元素|分配对象|复制临时对象|初始化基类子对象|初始化向量元素|捕获值}0时，没有可用的构造函数；C++98在绑定临时对象到引用时需要复制构造函数'
# 'no viable constructor or deduction guide for deduction of template arguments of %0'
HECA595B57B5C: '为 %0 的模板参数推导没有可用的构造函数或推导指引'
# 'no viable conversion%diff{ from $ to incomplete type $|}0,1'
H0DDC152C267D: '无法进行%diff{到不完整类型的转换|}0,1 有效转换'
# 'no viable conversion%select{%diff{ from $ to $|}1,2|%diff{ from returned value of type $ to function return type $|}1,2}0'
H742AD0829398: '无法进行 %select{%diff{从$到$|}1,2|%diff{从类型$的返回值到函数返回类型$|}1,2}0 有效转换'
# 'no viable destructor found for class %0'
HE8AA8B1D9E66: '未找到类 %0 的可用析构函数'
# "no viable overloaded '%0'"
H85F4D23A3BAD: "没有可用的重载 '%0'"
# 'no viable overloaded operator[] for type %0'
H2EF71DBEE631: '类型 %0 没有可用的重载operator[]'
# 'no visible @interface for %0 declares the selector %1'
HF35FE2A8D9B7: '@interface %0 未声明选择器 %1'
# 'noexcept expressions are incompatible with C++98'
H770DCD42AD88: 'noexcept表达式与C++98不兼容'
# 'noexcept specifications are incompatible with C++98'
HCDFCAD5EB464: 'noexcept说明与C++98不兼容'
# 'non-ASM statement in naked function is not supported'
H13FAFC759C77: '带有非ASM语句的裸函数不被支持'
# 'non-class friend type %0 is a C++11 extension'
HD60A5C8C49AC: '非类友元类型 %0 是C++11扩展'
# 'non-class friend type %0 is incompatible with C++98'
H4D0DB388513A: '非类友元类型 %0 与C++98不兼容'
# 'non-const static data member must be initialized out of line'
HFA5187DD3DCB: '非const静态数据成员必须在类外初始化'
# 'non-constant static local variable in inline function may be different in different files'
HDAC621E8867A: '内联函数中的非const静态局部变量在不同文件中可能不同'
# 'non-constant-expression cannot be narrowed from type %0 to %1 in initializer list'
H48217DABAA7D: '非常量表达式不能在初始化列表中将类型 %0 缩小为 %1'
# 'non-constant-expression cannot be narrowed from type %0 to %1 in initializer list in C++11'
H996365ACA997: '非常量表达式不能在C++11的初始化列表中将类型 %0 缩小为 %1'
# 'non-consteval function %0 cannot override a consteval function'
H3BE45C7BF2C1: '非consteval函数 %0 不能覆盖consteval函数'
# 'non-constexpr comparison function declared here'
H6CDFA8CCBBD8: '在此处声明的非constexpr比较函数'
# 'non-constexpr comparison function would be used to compare %select{|member %1|base class %1}0'
HFFB83E06B051: '非constexpr比较函数将用于比较 %select{|成员 %1|基类 %1}0'
# 'non-deducible template parameter %0'
HD419F387C770: '非推导的模板参数 %0'
# 'non-default #pragma pack value changes the alignment of struct or union members in the included file'
H2C52662649BE: '非默认的#pragma pack值会改变包含文件中结构体或联合体成员的对齐方式'
# "non-default visibility cannot be applied to 'dllimport' declaration"
H2A9EC7D43705: "'dllimport' 声明无法应用非默认可见性"
# 'non-defining declaration of enumeration with a fixed underlying type is only permitted as a standalone declaration%select{|; missing list of enumerators?}0'
H4D151B6B2BF9: '具有固定基础类型的枚举的非定义声明仅允许作为独立声明 %select{|; 缺少枚举列表？}0'
# 'non-deleted function %0 cannot override a deleted function'
H2F21A881D5B2: '非删除函数 %0 不能覆盖已删除的函数'
# 'non-extern declaration of %0 follows extern declaration'
H7E386503A2B6: '%0 的非extern声明跟在extern声明之后'
# 'non-friend class member %0 cannot have a qualified name'
H01BBFAF999D6: '非友元类成员 %0 不能有合格名称'
# 'non-inline external definitions are not permitted in C++ header units'
H0E67412E5EDC: '不允许在C++头单元中使用非内联外部定义'
# 'non-inline namespace cannot be reopened as inline'
H43CE8E47A824: '非内联命名空间不能作为内联重新打开'
# 'non-literal type %0 cannot be used in a constant expression'
HFCBBB3F7D771: '非字面类型 %0 不能用于常量表达式'
# 'non-local lambda expression cannot have a capture-default'
H2B075ACEF012: '非局部lambda表达式不能有捕获默认值'
# 'non-local variable with sizeless type %0'
H92600D86A0C5: '具有无大小类型 %0 的非局部变量'
# 'non-namespace scope %0 cannot have a literal operator member'
H266845A5FE4C: '非命名空间作用域 %0 不能有字面运算符成员'
# 'non-object type %0 is not assignable'
H8FB33F67F675: '非对象类型 %0 不可赋值'
# "non-pointer argument to '__builtin_assume_aligned' is not allowed"
HD960D71E3301: "传递给 '__builtin_assume_aligned' 的非指针参数不允许"
# 'non-pointer operand type %0 incompatible with %select{NULL|nullptr}1'
H90B6AFB986DF: '非指针操作数类型 %0 与 %select{NULL|nullptr}1 不兼容'
# "non-portable path to file '%0'; specified path differs in case from file name on disk"
H43FE55A52897: "文件 '%0' 的路径不可移植；指定的路径与磁盘上的文件名大小写不同"
# 'non-predefined allocator must have traits specified'
HFFB74BA64E52: '非预定义分配器必须指定其特性'
# 'non-static data member %0 cannot be declared as a template'
HEE38B2049618: '非静态数据成员 %0 不能声明为模板'
# 'non-static data member cannot be constexpr%select{; did you intend to make it %select{const|static}0?|}1'
H19D13A6885F4: '非静态数据成员不能声明为constexpr%select{；是否打算将其声明为 %select{const|static}0？|}1'
# 'non-static data member defined out-of-line'
HC4D58BAF82DF: '非静态数据成员在外部定义'
# 'non-static declaration of %0 follows static declaration'
H25169BF9CE09: '%0 的非静态声明跟在静态声明之后'
# 'non-static member %0 found in multiple base-class subobjects of type %1:%2'
H1D1EE8E2CCD9: '在类型 %1 的多个基类子对象中找到非静态成员 %0：%2'
# 'non-template declaration found by name lookup'
HF380F2D95EAA: '名称查找找到非模板声明'
# 'non-template friend declaration with a requires clause must be a definition'
H95DF301285CD: '带有requires子句的非模板友元声明必须是一个定义'
# 'non-template literal operator must have one or two parameters'
HAB8D25BD0598: '非模板字面量运算符必须有一个或两个参数'
# 'non-templated declaration is here'
H5E1276462F94: '非模板声明在此处'
# 'non-templated function cannot have a requires clause'
H82190871139C: '非模板函数不能带有requires子句'
# 'non-thread-local declaration of %0 follows thread-local declaration'
H015D893F1487: '%0 的非线程局部声明跟在线程局部声明之后'
# 'non-trivial destruction of lifetime-extended temporary with type %0 used in the result of a constant expression is not yet supported'
HD2339C077B90: '在常量表达式的结果中使用类型 %0 的生命周期扩展临时对象的非平凡析构尚未被支持'
# 'non-trivial destruction of type %0 in a constant expression is not supported'
HE2CD4D9E53E2: '类型 %0 在常量表达式中的非平凡析构不被支持'
# 'non-trivially copyable type %0 cannot be used in a boxed expression'
HB2216F42639D: '非平凡可复制的类型 %0 不能用于装箱表达式'
# 'non-type declaration found by destructor name lookup'
HB02DCE8A7FF1: '析构函数名称查找找到非类型声明'
# "non-type template argument '%0' is invalid"
H2399CD2B5610: "非类型模板实参 '%0' 无效"
# 'non-type template argument containing a dereference operation is a Microsoft extension'
HD4EF29A775AB: '包含解引用操作的非类型模板实参是微软扩展'
# 'non-type template argument does not refer to an object or function'
HE77C0A012513: '非类型模板实参不指向对象或函数'
# 'non-type template argument does not refer to any declaration'
HB25807F91411: '非类型模板实参未引用任何声明'
# 'non-type template argument for template parameter of pointer type %0 must have its address taken'
H8D4CDD97C49D: '指向类型 %0 的模板参数的非类型模板实参必须取其地址'
# 'non-type template argument is not a pointer to member constant'
HDC21F0C558EB: '非类型模板实参不是指向成员常量的指针'
# 'non-type template argument of reference type %0 is not an object'
H50574CDA0DAD: '引用类型 %0 的非类型模板实参不是对象'
# 'non-type template argument of type %0 cannot be converted to a value of type %1'
HDF1742D8033F: '类型 %0 的非类型模板实参无法转换为类型 %1 的值'
# 'non-type template argument of type %0 is not a constant expression'
H075FB8D7A63A: '类型 %0 的非类型模板实参不是常量表达式'
# 'non-type template argument of type %0 is not an integral constant expression'
HE2EA0C6B3858: '类型 %0 的非类型模板实参不是整型常量表达式'
# 'non-type template argument of type %0 must have an integral or enumeration type'
H06D35F5E0195: '类型 %0 的非类型模板实参必须具有整型或枚举类型'
# 'non-type template argument referring to %select{function|object}0 %1 with internal linkage is a C++11 extension'
HEFF3308ED7FE: '指向具有内部链接性的 %select{函数|对象}0 %1 的非类型模板实参是 C++11 扩展'
# 'non-type template argument referring to %select{function|object}0 %1 with internal linkage is incompatible with C++98'
H2F0100862103: '指向具有内部链接性的 %select{函数|对象}0 %1 的非类型模板实参与 C++98 不兼容'
# 'non-type template argument refers here'
HA953EF53E7DD: '非类型模板实参在此处引用'
# 'non-type template argument refers to %select{function|object}0 %1 that does not have linkage'
H600BCDFEE43D: '非类型模板实参引用未具有链接性的 %select{函数|对象}0 %1'
# 'non-type template argument refers to %select{function|object}0 here'
H9ED37B3451CC: '非类型模板实参在此处引用 %select{函数|对象}0'
# 'non-type template argument refers to non-static data member %0'
H2465AB2AA5B5: '非类型模板实参引用非静态数据成员 %0'
# 'non-type template argument refers to non-static member function %0'
H6A037F433017: '非类型模板实参引用非静态成员函数 %0'
# "non-type template argument refers to subobject '%0'"
HD30CEA1C7504: "非类型模板实参引用子对象 '%0'"
# 'non-type template argument refers to thread-local object'
H1DFBA6B66CEF: '非类型模板实参引用线程局部对象'
# 'non-type template argument specializes a template parameter with dependent type %0'
H77D31AA373EF: '非类型模板实参特化了类型为 %0 的依赖类型模板参数'
# "non-type template argument value '%0' truncated to '%1' for template parameter of type %2"
H5466021B086C: "类型为 %2 的模板参数的非类型模板实参值 '%0' 被截断为 '%1'"
# "non-type template argument with value '%0' converted to '%1' for unsigned template parameter of type %2"
H4635C03C8C36: "值为 '%0' 的非类型模板实参转换为类型 %2 的无符号模板参数的类型 '%1'"
# 'non-type template parameter %0 with type %1 has incompatible initializer of type %2'
H36B37E5D284B: '类型为 %1 的非类型模板参数 %0 具有类型 %2 的不兼容初始化器'
# 'non-type template parameter declared with incompatible types in different translation units (%0 vs. %1)'
H349C88186DB6: '在不同翻译单元中声明的非类型模板参数具有不兼容的类型（%0 对 %1）'
# 'non-type template parameter has incomplete type %0'
H67B9597CFD9A: '非类型模板参数具有不完全类型 %0'
# 'non-type template parameter has non-literal type %0'
H271C87C2E376: '非类型模板参数具有非字面量类型 %0'
# 'non-type template parameter has rvalue reference type %0'
H8258CBB4119D: '类型为 %0 的右值引用类型的非类型模板参数'
# 'non-type template parameter of reference type %diff{$ cannot bind to template argument of type $|cannot bind to template of incompatible argument type}0,1'
H4F089D7DCBD1: '引用类型非类型模板参数 %diff{$ 无法绑定到类型为 $|无法绑定到不兼容参数类型的模板}0,1'
# 'non-type template parameter of type %0 is incompatible with C++ standards before C++20'
H76F7D38734C2: '类型为 %0 的非类型模板参数与 C++20 之前的 C++ 标准不兼容'
# 'non-type template parameter of variably modified type %0'
HDB7696E83E21: '类型为 %0 的变长类型非类型模板参数'
# 'non-type template parameters declared with %0 are incompatible with C++ standards before C++17'
H4034BC5F4762: '使用 %0 声明的非类型模板参数与 C++17 之前的 C++ 标准不兼容'
# 'non-usual %0 declared here'
H9B44D0E82E0B: '非常规 %0 在此处声明'
# "non-variable declaration in 'for' loop"
HE2801E92B8D8: "'for' 循环中的非变量声明"
# "non-variable declaration in 'for' loop is a C23 extension"
H861D242B28D2: "'for' 循环中的非变量声明是 C23 扩展"
# "non-variable declaration in 'for' loop is incompatible with C standards before C23"
H1A5C6F3C6A58: "'for' 循环中的非变量声明与 C23 之前的 C 标准不兼容"
# "non-virtual member function marked '%0' hides virtual member %select{function|functions}1"
H6156F12DC3F9: "标记为 '%0' 的非虚成员函数隐藏了虚成员 %select{函数|函数}1"
# 'non-void %select{constexpr|consteval}1 function %0 should return a value'
HCF55E17BA989: '非 void %select{constexpr|consteval}1 函数 %0 应返回一个值'
# 'non-void %select{function|block|lambda|coroutine}0 does not return a value%select{| in all control paths}1'
H75EE618D1AA4: '非 void %select{函数|块|lambda|协程}0 未返回一个值 %select{|在所有控制路径中}1'
# 'non-void %select{function|method}1 %0 should return a value'
HEE95067001EB: '非 void %select{函数|方法}1 %0 应返回一个值'
# 'non-void block should return a value'
H66594B013217: '非 void 块应返回一个值'
# "nonnull %select{function call|parameter}0 '%1' will evaluate to 'true' on first encounter"
H925BCFBBE426: "非空 %select{函数调用|参数}0 '%1' 在首次遇到时将被求值为 'true'"
# 'not a Doxygen trailing comment'
HB02E938B9DEC: '不是Doxygen尾部注释'
# "not currently inside '#pragma clang arc_cf_code_audited'"
HD79C4D940185: "不在 '#pragma clang arc_cf_code_audited' 指令范围内"
# "not currently inside '#pragma clang assume_nonnull'"
HF77D5E6601B3: "不在 '#pragma clang assume_nonnull' 指令范围内"
# "not currently inside '#pragma unsafe_buffer_usage'"
H658512A345D7: "不在 '#pragma unsafe_buffer_usage' 指令范围内"
# 'not eliding copy on return'
H0FB30CAF71B6: '未执行返回时的拷贝省略'
# 'not enough variable arguments in %0 declaration to fit a sentinel'
H9930B56495BC: '%0 声明中的可变参数数量不足以容纳哨兵'
# 'not packing field %0 as it is non-POD for the purposes of layout'
H7FBA81FDAA18: '由于布局目的，字段 %0 不是POD类型，因此不会被压缩'
# 'not-yet-instantiated member is declared here'
HACFD1F41F676: '尚未实例化的成员在此处声明'
# 'null character ignored'
H6B4B3A47C8AC: '空字符被忽略'
# 'null character(s) preserved in %select{char|string}0 literal'
H062C86F6116B: '在%select{字符|字符串}0字面量中保留空字符'
# 'null non-type template argument must be cast to template parameter type %0'
HDDA635486EF3: '空的非类型模板参数必须转换为模板参数类型 %0'
# 'null non-type template argument of type %0 does not match template parameter of type %1'
HCF293B48A07C: '类型 %0 的空非类型模板参数与类型 %1 的模板参数不匹配'
# 'null passed to a callee that requires a non-null argument'
H5F7D096FCE08: '将空值传递给需要非空参数的调用方'
# 'null returned from %select{function|method}0 that requires a non-null return value'
HEA9F26CD4560: '从需要非空返回值的%select{函数|方法}0返回空值'
# 'nullability keyword %0 cannot be applied to multi-level pointer type %1'
H9F63F0EFF7CC: '空值限定符 %0 不能应用于多级指针类型 %1'
# 'nullability specifier %0 cannot be applied to non-pointer type %1'
HA1F5D87BE3DF: '空值限定符 %0 不能应用于非指针类型 %1'
# 'nullability specifier %0 cannot be applied to non-pointer type %1; did you mean to apply the specifier to the %select{pointer|block pointer|member pointer|function pointer|member function pointer}2?'
H3E269F064E84: '空值限定符 %0 不能应用于非指针类型 %1；是否应将限定符应用于%select{指针|块指针|成员指针|函数指针|成员函数指针}2？'
# 'nullability specifier %0 conflicts with existing specifier %1'
H4421DC48369F: '空值限定符 %0 与现有限定符 %1 冲突'
# 'number of elements must be either one or match the size of the vector'
H2A474F4275FA: '元素数量必须为 1 或与向量的大小匹配'
# 'number of entries per line (default 256)'
H7D63977C73C8: '每行条目数（默认 256）'
# 'number of functions to display when printing the top largest differences in function activity'
H4322F776E088: '显示函数活跃度差异最大的前N个函数数量'
# 'number of hottest functions to print aggregated profile quality stats of.'
H5B5E76B4AA88: '要输出其聚合分析质量统计的最热函数数量'
# 'number of tasks to be created per thread'
HE2569802814C: '每个线程要创建的任务数'
# 'number of threads'
HE591548912FE: '线程数'
# 'numeric literal with user-defined suffix cannot be used here'
H6D6640DAD12D: '此处不能使用带有用户自定义后缀的数值字面量'
# "nvcc does not allow '__%0__' to appear after the parameter list in lambdas"
H052A23E5C9DE: "nvcc不允许在lambda的参数列表后出现 '__%0__'"
# 'obj2yaml Options'
HDEB46CD09A6E: 'obj2yaml 选项'
# 'objc_precise_lifetime is not meaningful for %select{__unsafe_unretained|__autoreleasing}0 objects'
H3B4A7538E1D6: 'objc精准生命周期对 %select{__unsafe_unretained|__autoreleasing}0 对象没有意义'
# 'objc_precise_lifetime only applies to retainable types; type here is %0'
HCB888D9DBEF6: 'objc精准生命周期仅适用于可保留类型；此处类型为 %0'
# 'objc_root_class attribute may only be specified on a root class declaration'
H8B7E866F5F47: 'objc_root_class属性只能在根类声明中指定'
# 'object backing %select{|the pointer }0%1 will be destroyed at the end of the full-expression'
H4CCEF5B24A9C: '支撑 %select{|指针 }0%1 的对象将在完整表达式结束时被销毁'
# 'object backing the pointer %0 will be destroyed at the end of the full-expression'
H4314D747B320: '支撑指针 %0 的对象将在完整表达式结束时被销毁'
# 'object backing the pointer will be destroyed at the end of the full-expression'
HCBDFA4406EFB: '支撑指针的对象将在完整表达式结束时被销毁'
# 'object expression of non-scalar type %0 cannot be used in a pseudo-destructor expression'
H8E297F831414: '非标量类型 %0 的对象表达式不能用于伪析构表达式'
# "object format flags cannot be used with '%0' conversion specifier"
HAF558B2410E4: "对象格式标志不能与 '%0' 转换说明符一起使用"
# 'object of type %0 cannot be %select{constructed|copied|moved|assigned|assigned|destroyed}1 because its %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}1 is implicitly deleted'
H828A944AA309: '类型 %0 的对象无法%select{构造|拷贝|移动|赋值|赋值|销毁}1，因为其%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}1已被隐式删除'
# 'object of type %0 cannot be compared because its %1 is implicitly deleted'
H4465935A9154: '类型 %0 的对象无法进行比较，因为其 %1 已被隐式删除'
# 'object of type %0 cannot be placed in read-only memory'
HD27A532EA3C9: '类型 %0 的对象无法放置在只读内存中'
# 'object of type %0 is not compatible with %select{array element type|dictionary key type|dictionary value type}1 %2'
HBDF524B06F4F: '类型 %0 的对象与%select{数组元素类型|字典键类型|字典值类型}1 %2 不兼容'
# 'object whose reference is captured by %0 will be destroyed at the end of the full-expression'
H79F166A683BE: '被 %0 捕获引用的对象将在完整表达式结束时被销毁'
# 'object whose reference is captured will be destroyed at the end of the full-expression'
H04404B93E557: '被捕获引用的对象将在完整表达式结束时被销毁'
# 'octal integer literals are a C2y extension'
HCB95FC190C42: '八进制整数字面量是C2y扩展'
# 'octal integer literals are a Clang extension'
H0A7A0AD8FA23: '八进制整数字面量是Clang扩展'
# 'octal integer literals are incompatible with standards before C2y'
HFF58B98B1092: '八进制整数字面量与C2y之前的语言标准不兼容'
# "octal literals without a '0o' prefix are deprecated"
H297C91C7799F: "未带 '0o' 前缀的八进制字面量已被弃用"
# 'offload-arch options'
H7186B8C146CF: '卸载架构选项'
# 'offset of asan shadow mapping [EXPERIMENTAL]'
HB87160E3C269: 'asan shadow映射的偏移量[实验性]'
# 'offset-based plaintext format'
H4A173EEFA114: '基于偏移的明文格式'
# 'offsetof of incomplete type %0'
H01B4054FE86A: 'offsetof的参数 %0 是不完整类型'
# 'offsetof requires array type, %0 invalid'
H72E546984F9B: 'offsetof需要数组类型，%0 无效'
# 'offsetof requires struct, union, or class type, %0 invalid'
H1EED7971DB36: 'offsetof需要结构体、联合或类类型，%0 无效'
# "old syntax '%0' on '%1' clause was deprecated, use new syntax '%2'"
H62AFC50986BB: "'%1' 子句中的旧语法 '%0' 已弃用，请改用新语法 '%2'"
# 'omit the namespace to add attributes to the most-recently pushed attribute group'
H33451023019A: '省略命名空间以将属性添加到最近添加的属性组'
# 'omitting the parameter name in a function definition is a C23 extension'
H239CD59B1E97: '在函数定义中省略参数名是C23扩展'
# 'on M-profile architectures %0 attribute is not supported on targets missing %1; specify an appropriate -march= or -mcpu='
HF63DAE65A9BA: '在M架构上，%0 属性在缺少 %1 的目标上不受支持；请指定适当的-march=或-mcpu='
# 'one cluster per opcode'
H571A5AC320D2: '每个操作码一个簇'
# "one of 'for', 'parallel', 'sections' or 'taskgroup' is expected"
HA318D6E65846: "期望其中一个：'for', 'parallel', 'sections' 或 'taskgroup'"
# 'one possibility'
HF5AE3D1F7A2D: '一种可能'
# "only %select{'omp_priv' or 'omp_orig'|'omp_in' or 'omp_out'}0 variables are allowed in %select{initializer|combiner}0 expression"
HBFBFE733ACC9: "在 %select{initializer|combiner}0 表达式中，仅允许 %select{'omp_priv' 或 'omp_orig'|'omp_in' 或 'omp_out'}0 变量"
# "only '*' can be exported from an inferred submodule"
HB1E7869E1AA8: "只能从推导的子模块导出 '*'"
# "only 'device_type(any)' clause is allowed with indirect clause"
H60FE040D9778: "间接子句仅允许使用 'device_type(any)' 子句"
# "only 'unavailable' and 'deprecated' are supported for Swift availability"
H711C14834055: "Swift可用性仅支持 'unavailable' 和 'deprecated'"
# 'only a single match extension allowed per OpenMP context selector'
H54ED4E173E0C: '每个OpenMP上下文选择器仅允许一个匹配扩展'
# 'only allow matching call instructions if the name and type signature match.'
HA22B2A05D450: '仅当名称和类型签名匹配时才允许匹配调用指令'
# 'only apply branch boundary alignment in hot code'
H486A9C1A43ED: '仅在热点代码中应用分支边界对齐'
# 'only constructors take base initializers'
HDB605C258726: '只有构造函数可以使用基类初始化器'
# 'only dump ids with the specified hexadecimal type index'
H5475CDF64D0B: '仅转储具有指定十六进制类型索引的标识符'
# 'only dump symbol record with the specified symbol offset'
H990FE7E1637C: '仅转储具有指定符号偏移量的符号记录'
# 'only dump types with the specified hexadecimal type index'
HF6EF25D1A99D: '仅转储具有指定十六进制类型索引的类型'
# 'only enumeration types have underlying types'
H35007289C6D1: '仅枚举类型具有底层类型'
# 'only function and template parameters can be parameter packs'
HE058E90890AE: '仅函数和模板参数可以是参数包'
# 'only functions can have deleted definitions'
H0BDC0C1C20D8: '只有函数可以具有已删除的定义'
# 'only insert instrumentation on hot functions (needs profile, default: false)'
H6921A5326E9E: '仅在热点函数中插入分析代码（需要分析资料，默认：false）'
# "only loop iteration variables are allowed in 'lastprivate' clause in 'omp %0' directives"
H93109DDAC062: "在 'omp %0' 指令的 'lastprivate' 子句中仅允许循环迭代变量"
# "only loop iteration variables are allowed in 'linear' clause in distribute directives"
HB4FBF6AB0B0A: "在distribute指令的 'linear' 子句中仅允许循环迭代变量"
# 'only one %0 clause can appear on a requires directive in a single translation unit'
H67EC4B23D848: '在单个翻译单元中，requires子句只能出现一个 %0 子句'
# 'only one element declaration is allowed'
HB7E0C8F27CB5: '只能声明一个元素'
# "only one expression allowed in '%0' clause"
H200100A1AF70: "在 '%0' 子句中只能有一个表达式"
# 'only one offload target is supported'
H36578B307452: '仅支持一个卸载目标'
# "only one parameter on 'main' declaration"
H09469DD0E50E: "'main' 声明只能有一个参数"
# 'only perform sctc when branch direction is preserved'
HF40E26771C18: '仅在分支方向被保留时执行sctc'
# 'only promote call targets eligible for inlining'
H48B4D984BB43: '仅提升符合内联条件的调用目标'
# 'only recurse to a depth of N when displaying children of a symbol record.'
H9AF5A4C86831: '显示符号记录的子项时仅递归到N层深度'
# 'only recurse to a depth of N when displaying parents of a symbol record.'
HFD73DE6E2DEF: '显示符号记录的父项时仅递归到N层深度'
# 'only rename the instructions in the function'
H255C85A34C1B: '仅重命名函数中的指令'
# 'only replace exit value when it is an unused induction variable in the loop and has cheap replacement cost'
H4F514B4EF001: '仅当退出值是循环中的未使用归纳变量且替换成本低廉时替换退出值'
# 'only replace exit value when the cost is cheap'
H8C5F857AAD22: '仅当替换成本低廉时替换退出值'
# 'only replace exit values when loop def likely dead'
H1F90A0F5DC05: '仅当循环定义很可能已死时替换退出值'
# 'only show the top N results'
H31C65CA913F9: '仅显示前N项结果'
# 'only special member functions %select{|and comparison operators }0may be defaulted'
H7676F4E831FD: '只能默认特殊成员函数 %select{|和比较运算符}0'
# 'only submodules and framework modules may be inferred with wildcard syntax'
HB41F304027AC: '只能通过通配符语法推断子模块和框架模块'
# 'only the first dimension of an allocated array may have dynamic size'
HCC4AF93D4D25: '分配的数组只能在第一个维度具有动态大小'
# 'only top-level modules can be re-exported as public'
H35599F0992E5: '仅顶级模块可以作为公共模块重新导出'
# 'only use samples from process with specified PID'
HE4657121A5A3: '仅使用指定PID的进程的采样数据'
# "only variable %0 is allowed in map clauses of this 'omp declare mapper' directive"
HCD77D6699FCF: "在此 'omp declare mapper' 指令的map子句中，仅允许变量 %0"
# "only variables can be arguments to '#pragma unused'"
H454069F49B2C: "'#pragma unused' 的参数只能是变量"
# "only virtual member functions can be marked '%0'"
H88BCFFA5846F: '只有虚成员函数可以被标记为 "%0"'
# 'only zero-length WebAssembly tables are currently supported'
H834ECF2F9D5B: '当前仅支持零长度的WebAssembly表'
# 'opcode to measure, by index, or -1 to measure all opcodes'
H04C71CF551B6: '要测量的指令码，通过索引指定，或-1表示测量所有指令码'
# "operand argument to %select{overflow builtin|checked integer operation}0 must be an integer type %select{|other than plain 'char', 'bool', bit-precise, or an enumeration }0(%1 invalid)"
H232C02FD2560: '%select{溢出内建函数|带检查的整数运算}0的运算数参数必须为整数类型 %select{|，而非普通 "char"、"bool"、精确位宽或枚举类型}0（%1 无效）'
# 'operand of ? changes signedness: %0 to %1'
H034F94202BD7: '问号运算符的运算数改变了符号：%0 到 %1'
# 'operand of type %0 cannot be cast to a pointer type'
H39550A20AC28: '类型 %0 的运算数不能转换为指针类型'
# 'operand of type %0 where arithmetic or pointer type is required'
H73F559724DF8: '需要算术类型或指针类型的位置却使用了类型 %0 的运算数'
# 'operands to conditional of types%diff{ $ and $|}0,1 are incompatible in ARC mode'
HA7936DDDD636: '在ARC模式下，条件运算符的运算数类型%diff{ $和$ |}0,1 不兼容'
# "operator '%0' has lower precedence than '%1'; '%1' will be evaluated first"
H7655BF3550EE: '运算符 "%0" 的优先级低于 "%1"；"%1" 将先被计算'
# "operator '?:' has lower precedence than '%0'; '%0' will be evaluated first"
HFCE2B46187B8: '运算符 "?: " 的优先级低于 "%0"；"%0" 将先被计算'
# 'operators in fold expression must be the same'
H1479CC2CDE54: '折叠表达式中的运算符必须相同'
# 'opt-like flags'
H2AE16EED276B: '类似opt的标志'
# "optimization flag '%0' is not supported"
HED6E92EF31B3: "优化标志 '%0' 不受支持"
# "optimization flag '%0' is not supported for target '%1'"
H7BA15DDB49BE: "优化标志 '%0' 不适用于目标 '%1'"
# "optimization level '%0' is not supported; using '%1%2' instead"
H6D18AF90D4BB: "优化级别 '%0' 不受支持；将使用 '%1%2' 代替"
# 'optimize PLT calls (requires linking with -znow)'
H1C6C02B1FC92: '优化PLT调用（需要与-znow链接选项一起使用）'
# 'optimize all PLT calls'
H729D15249489: '优化所有PLT调用'
# 'optimize executed (hot) PLT calls'
HB328EE466E4E: '优化执行的（热点）PLT调用'
# 'optimize functions with jump tables'
H1F9747FD82E4: '优化带有跳转表的函数'
# 'optimize hottest calls until at least this percentage of all indirect calls frequency is covered. 0 = all callsites'
H770180548F4F: '优化最热调用，直到覆盖所有间接调用频率的至少该百分比。0=所有调用点'
# 'optimize stack frame accesses'
H72DEC23B9CC3: '优化栈帧访问'
# "option '%0' cannot be specified on this target"
H1BE1A4C28B5B: "选项 '%0' 不能在此目标上指定"
# "option '%0' cannot be specified with '%1'"
H70F63315B132: "选项 '%0' 不能与 '%1' 一起指定"
# "option '%0' cannot be specified with '%1' for the %2 sub-architecture"
HBBDD552F5F1A: "选项 '%0' 不能与 '%1' 一起指定用于 %2 子架构"
# "option '%0' cannot be specified without '%1'"
H583C3C9DA6E7: "选项 '%0' 必须与 '%1' 一起指定"
# "option '%0' requires input to be LLVM bitcode"
HA5B4E61775E4: "选项 '%0' 需要输入为LLVM比特码"
# "option '%0' was ignored by the %1 toolchain, using '-fPIC'"
H22B2E1051C0B: "选项 '%0' 被 %1 工具链忽略，使用 '-fPIC'"
# "option '-MG' requires '-M' or '-MM'"
HCCC4BA63CA80: "选项 '-MG' 需要与 '-M' 或 '-MM' 一起使用"
# "option '-ffine-grained-bitfield-accesses' cannot be enabled together with a sanitizer; flag ignored"
H4FD110105D82: "选项 '-ffine-grained-bitfield-accesses' 不能与 sanitizer 一起启用；标志被忽略"
# "option '-fmodule-output' cannot be used with multiple arch options"
H67AC45523A0C: "选项 '-fmodule-output' 不能与多个架构选项一起使用"
# "option '-fmodules-validate-once-per-build-session' requires '-fbuild-session-timestamp=<seconds since Epoch>' or '-fbuild-session-file=<file>'"
H5685B0FE4474: "选项 '-fmodules-validate-once-per-build-session' 需要 '-fbuild-session-timestamp=<自纪元秒数>' 或 '-fbuild-session-file=<文件>'"
# "option 'ffp-eval-method' cannot be used with option %select{'fapprox-func'|'mreassociate'|'freciprocal'}0"
H1D986A148023: "选项 'ffp-eval-method' 不能与选项 %select{'fapprox-func'|'mreassociate'|'freciprocal'}0 一起使用"
# 'options %0 and %1 are set to different values'
H15DAE6B37541: '选项 %0 和 %1 被设置为不同的值'
# 'or because setter is declared here, but no getter method %0 is found'
H9306685E39B6: '或因为设置器在此处声明，但未找到对应的获取方法 %0'
# "or insert whitespace before ':' to use %0 as parameter name and have an empty entry in the selector"
H09DF98AB0B6F: "或在 ':' 前插入空格，以将 %0 用作参数名称并在选择器中留空"
# 'order by execution count'
H7EA3A097FEC2: '按执行计数排序'
# 'ordered compare requires two args of floating point type%diff{ ($ and $)|}0,1'
HC6DBD7D802C7: '有序比较需要两个浮点类型的参数%diff{ ($ 和 $)|}0,1'
# 'ordered comparison between pointer and integer (%0 and %1)'
HCE8E7EA44A15: '指针与整数之间的有序比较（%0 和 %1）'
# 'ordered comparison between pointer and zero (%0 and %1)'
H08DE668CB79E: '指针和零之间的有序比较（%0 和 %1）'
# 'ordered comparison between pointer and zero (%0 and %1) is an extension'
HEFA21113E58A: '指针和零之间的有序比较（%0 和 %1）是一个扩展'
# 'ordered comparison of function pointers (%0 and %1)'
H6623D571A716: '函数指针之间的有序比较（%0 和 %1）'
# 'original arguments in round-trip: %0'
H88D576AD9392: '往返过程中的原始参数： %0'
# 'original arguments parse failed, then succeeded in round-trip'
H4354C394D0BE: '原始参数解析失败，但在往返过程中成功'
# 'original storage of expression in data environment is shared but data environment do not fully contain mapped expression storage'
H8588EE9D0D77: '数据环境中的表达式原始存储是共享的，但数据环境并未完全包含映射的表达式存储'
# "orphaned 'omp %0' directives are prohibited; perhaps you forget to enclose the directive into a %select{|||target |teams|for, simd, for simd, parallel for, or parallel for simd }1region?"
H09B89CE1DDFB: "未被包围的 'omp %0' 指令是禁止的；可能您忘记将指令包含在 %select{|||target |teams|for, simd, for simd, parallel for, 或 parallel for simd }1 区域中？"
# "os '%0' is not supported: '%1'"
HD285B7E47AB6: "操作系统 '%0' 不支持：'%1'"
# "os_log() '%%n' format specifier is not allowed"
HA308C5A1A678: "os_log() 不允许使用 '%%n' 格式说明符"
# 'os_log() argument %0 is too big (%1 bytes, max %2)'
H93B7553E2DE5: 'os_log() 参数 %0 过大（%1 字节，最大 %2）'
# 'os_log() format argument is not a string constant'
H6ABC3AD79FAA: 'os_log() 格式参数不是字符串常量'
# 'other definition of %0'
HFB23FE3FA4F8: '%0 的其他定义'
# 'out-of-line %select{declaration|definition}2 of %0 does not match any declaration in %1'
HC3CEC6EF88DD: '%0 的外部 %select{声明|定义}2 与 %1 中的任何声明不匹配'
# 'out-of-line %select{declaration|definition}2 of %0 does not match any declaration in %1; did you mean %3?'
H6724D4146D60: '%0 的外部 %select{声明|定义}2 与 %1 中的任何声明不匹配；您是指 %3 吗？'
# 'out-of-line constructor for %0 cannot have template arguments'
H33FE02CBF6A6: '%0 的外部构造函数不能有模板参数'
# 'out-of-line declaration of a member must be a definition'
HBCC796880D79: '成员的外部声明必须是一个定义'
# 'out-of-line definition of %0 from class %1 without definition'
H3397C2717560: '来自类 %1 的 %0 的外部定义没有定义'
# 'out-of-line definition of constexpr static data member is redundant in C++17 and is deprecated'
HF4242355CFAD: 'C++17 中外部 constexpr 静态数据成员的定义是多余的，并且已弃用'
# 'outline as many cold basic blocks as possible'
HA720A2B172BB: '尽可能提取尽可能多的冷基本块'
# "output data (.csv) for Stoke's use"
H566F7B66D7EF: '输出数据（.csv格式）供Stoke使用'
# 'output file to write out a summary of the partitions created for each module'
H9036C41EDFF6: '输出文件；用于写入为每个模块创建的分区摘要'
# 'output file to write out the dotgraph representation of the input module'
H491BF84F04E2: '输出文件；用于写入输入模块的dotgraph表示'
# "output file; use '-' for stdout"
H239A9905E956: '输出文件；使用 "-" 表示标准输出'
# 'output format'
H8D3CACC9A576: '输出格式'
# 'output in binary'
HF1C94F4E5F08: '输出二进制格式'
# 'output in yaml'
HFFA9E62F70D8: '输出YAML格式'
# 'output the AST dump'
HE5094C7EDA7B: '输出AST转储'
# 'output the LLVM IR dump'
H722A785E838D: '输出LLVM IR转储'
# 'output the MLIR dump'
H5AB21662EF6D: '输出MLIR转储'
# 'output the MLIR dump after affine lowering'
H412D35179012: '在仿射降级后输出MLIR转储'
# 'output the MLIR dump after llvm lowering'
H5560C4070D86: '输出LLVM下层转换后的MLIR转储'
# 'overflow converting case value to switch condition type (%0 to %1)'
HF36747707003: '将 case 值转换为 switch 条件类型时溢出（%0 到 %1）'
# 'overflow in expression; result is %0 with type %1'
H5FE3FC44898D: '表达式溢出；结果是 %0，类型为 %1'
# "overload resolution selected deleted operator '%0'%select{|: %2}1"
HB844E51E83EA: "重载决议选择了已删除的运算符 '%0'%select{|: %2}1"
# 'overloaded %0 cannot be a static member function'
HE25D37D77FD9: '重载的 %0 不能是静态成员函数'
# 'overloaded %0 cannot be variadic'
H49C83B8BBB4E: '重载的 %0 不能是可变参数的'
# 'overloaded %0 cannot have %select{no|a defaulted|more than one}1 parameter before C++23'
H1FC62986EC90: '在C++23之前，重载的 %0 不能拥有%select{无|一个默认的|超过一个}1参数'
# 'overloaded %0 must be a %select{unary|binary|unary or binary}2 operator (has %1 parameter%s1)'
HA142B5DEA04D: '重载 %0 必须是 %select{一元|二元|一元或二元}2 运算符（具有 %1 参数%s1）'
# 'overloaded %0 must be a non-static member function'
H359B48F5CEFF: '重载的 %0 必须是非静态成员函数'
# 'overloaded %0 must have at least one parameter of class or enumeration type'
H329B9199B7C8: '重载的 %0 必须至少有一个参数是类或枚举类型'
# 'overloaded %0 with %select{no|a defaulted|more than one}1 parameter is a C++23 extension'
H9DE4D96FF9C0: '带有%select{无|一个默认的|超过一个}1参数的重载 %0 是C++23的扩展'
# 'overloaded operator %select{>>|<<}0 has higher precedence than comparison operator'
H3D68DF30B083: '重载的 %select{>>|<<}0 运算符的优先级高于比较运算符'
# 'overridden method is here'
H33E209C67E48: '被覆盖的方法在此处'
# 'overridden method returns an instance of its class type'
HA983C03A495A: '被覆盖的方法返回其类类型的实例'
# 'overridden virtual function is here'
HFA2BCE5F4E2A: '被覆盖的虚函数在此处'
# 'override the name of the default PROGRAM entry (may be helpful for using other runtimes)'
HDBB3DF8CB32F: '覆盖默认的PROGRAM入口名称（可能有助于使用其他运行时）'
# 'overrides DW_AT_comp_dir, and provides an alternative base location, which is used with DW_AT_dwo_name to construct a path to *.dwo files.'
HB19702484022: '覆盖DW_AT_comp_dir，并提供一个替代基础位置，该位置与DW_AT_dwo_name一起用于构造*.dwo文件的路径。'
# "overriding '%0' option with '%1'"
H0BEA2CFA1C71: "用 '%1' 覆盖 '%0' 选项"
# 'overriding currently unsupported rounding mode on this target'
HE764C7911186: '覆盖当前目标上不支持的舍入模式'
# 'overriding currently unsupported use of floating point exceptions on this target'
H4E019EDC5E1E: '覆盖当前目标上不支持的浮点异常使用'
# "overriding deployment version from '%0' to '%1'"
H3B5CC52823D1: "将部署版本从 '%0' 覆盖为 '%1'"
# 'overriding method has mismatched ns_consumed attribute on its parameter'
H94209C3B1D29: '覆盖的方法与其参数的ns_consumed属性不匹配'
# 'overriding method has mismatched ns_returns_%select{not_retained|retained}0 attributes'
HFA26D6769DAD: '覆盖的方法与其ns_returns_%select{not_retained|retained}0 属性不匹配'
# 'overriding the module target triple with %0'
H7A3B62788722: '用 %0 覆盖模块的目标三元组'
# 'overriding virtual function must specify the same code segment as its overridden function'
HD38E3F8D7591: '覆盖的虚函数必须指定与被覆盖函数相同的代码段'
# 'p'
H516B9783FCA5: 'p'
# 'pac-ret: return address protection (subset of "pauth")'
H35B2314AE83E: 'pac-ret：返回地址保护（pauth子集）'
# 'pack declaration outside of template'
HDF7BB0B67932: '包声明位于模板外部'
# 'pack expansion contains parameter pack %0 that has a different length (%1 vs. %select{|at least }2%3) from outer parameter packs'
H41600DB01010: '包展开包含参数包 %0，其长度与外部参数包不同（%1 与 %select{|至少 }2%3）'
# 'pack expansion contains parameter pack %0 that has a different length (at least %1 vs. %2) from outer parameter packs'
H477211AA8361: '包展开包含参数包 %0，其长度与外部参数包不同（至少 %1 与 %2）'
# 'pack expansion contains parameter packs %0 and %1 that have different lengths (%2 vs. %select{|at least }3%4)'
H4F8FA8F98117: '包展开包含参数包 %0 和 %1，其长度不同（%2 与 %select{|至少 }3%4）'
# 'pack expansion does not contain any unexpanded parameter packs'
H8BAD94174D96: '包展开中不包含任何未展开的参数包'
# 'pack expansion for initialization of member %0'
HBD2872B50273: '成员 %0 的初始化所用的包展开'
# 'pack expansion of using declaration is a C++17 extension'
H1BE8FC7C5774: 'using声明的包展开是C++17扩展'
# 'pack expansion used as argument for non-pack parameter of %select{alias template|concept}0'
HBF85ED181091: '%select{别名模板|概念}0 的非包参数使用了包扩展参数'
# 'pack expansion using declaration is incompatible with C++ standards before C++17'
HFDB9F5A38038: '使用using声明的包展开与C++17之前的C++标准不兼容'
# 'pack fold expression is a C++17 extension'
H7820808CC9E4: '包折叠表达式是C++17扩展'
# 'pack fold expression is incompatible with C++ standards before C++17'
H2F52B697F3BE: '包折叠表达式与C++17之前的C++标准不兼容'
# 'pack indexing is a C++2c extension'
H1086B8F449EB: '包索引是C++2c扩展'
# 'pack indexing is incompatible with C++ standards before C++2c'
H9DAE09EBBEA1: '包索引与C++2c之前的C++标准不兼容'
# 'packed attribute is unnecessary for %0'
H08493DD022D1: '对于 %0，packed属性是不必要的'
# "packoffset at 'y' not match alignment %0 required by %1"
H1D68367EC4D7: "在 'y' 处的packoffset与 %1 要求的 %0 对齐不匹配"
# 'packoffset cannot cross register boundary'
HA00AFB61162C: 'packoffset不能跨越寄存器边界'
# 'packoffset overlap between %0, %1'
H8FBBA6B5715E: '%0 和 %1 之间的packoffset重叠'
# 'padding %select{struct|interface|class}0 %1 with %2 %select{byte|bit}3%s2 to align %4'
HB4806E10E325: '用 %2 %select{字节|位}3%s2填充%select{结构体|接口|类}0 %1 以对齐 %4'
# 'padding %select{struct|interface|class}0 %1 with %2 %select{byte|bit}3%s2 to align anonymous bit-field'
HE333A36DBC3C: '用 %2 %select{字节|位}3%s2填充%select{结构体|接口|类}0 %1 以对齐匿名位域'
# 'padding %select{struct|interface|class}0 %1 with %2 %select{byte|bit}3%s2 to align anonymous field'
H1B5890218438: '用 %2 %select{字节|位}3%s2填充%select{结构体|接口|类}0 %1 以对齐匿名成员'
# 'padding size of %0 with %1 %select{byte|bit}2%s1 to alignment boundary'
H5BCCA44B6E5B: '用 %1 %select{字节|位}2%s1填充 %0 到对齐边界所需的大小'
# 'parameter %0 must have a complete type to use function %1 with the %2 calling convention'
H35B9EA765265: '参数 %0 必须具有完整的类型才能使用具有 %2 调用约定的函数 %1'
# 'parameter %0 set but not used'
HB6BB1AF1B37E: '参数 %0 被设置但未使用'
# "parameter %0 was not declared, defaults to 'int'; ISO C99 and later do not support implicit int"
H41790618129F: "未声明参数 %0，默认为 'int'；ISO C99及后续版本不支持隐式int类型"
# "parameter '%0' is already documented"
HF9B7DF355428: '参数“%0”已被文档说明'
# "parameter '%0' not found in the function declaration"
HD7CC3BBE6634: '参数“%0”未在函数声明中找到'
# "parameter '%0' not in expected state when the function returns: expected '%1', observed '%2'"
H6EE5C60DD591: "函数返回时参数 '%0' 未处于期望状态：期望 '%1'，实际观察到 '%2'"
# "parameter cannot be named '%select{global|unknown}0' while using 'lifetime_capture_by(%select{global|unknown}0)'"
H56545E5909EB: "在使用 'lifetime_capture_by(%select{global|unknown}0)' 时，参数不能命名为 '%select{global|unknown}0'"
# 'parameter declarator cannot be qualified'
HEB6B080E8792: '参数声明符不能被限定'
# 'parameter kind mismatch; parameter is %select{not a|a}0 parameter pack'
H53E71EC45244: '参数类型不匹配；参数%select{不是|是}0参数包'
# 'parameter may not be qualified with an address space'
HFB13BD25F7E6: '参数不能使用地址空间进行限定'
# 'parameter name cannot have template arguments'
H4AE4E444760E: '参数名称不能带有模板实参'
# 'parameter named %0 is missing'
HE41EE5512047: '命名为 %0 的参数缺失'
# "parameter of %0 attribute must be 'id' when used on a typedef"
H95DFECC378EF: "当在typedef上使用 %0 属性时，其参数必须为 'id'"
# 'parameter of %0 attribute must be a single name of an Objective-C %select{class|protocol}1'
H6E3911EE67CF: '%0 属性的参数必须是Objective-C %select{类|协议}1的单一名字'
# 'parameter of %0 cannot have a default argument'
H9997206462BD: '%0 的参数不能有默认参数值'
# "parameter of literal operator must have type 'unsigned long long', 'long double', 'char', 'wchar_t', 'char16_t', 'char32_t', or 'const char *'"
H18EF0BD0BEB6: "字面量运算符的参数类型必须为 'unsigned long long'、'long double'、'char'、'wchar_t'、'char16_t'、'char32_t' 或 'const char *'"
# 'parameter of overloaded %0 cannot have a default argument'
H31033CF29CE2: '重载的 %0 参数不能有默认参数值'
# "parameter of overloaded post-%select{increment|decrement}1 operator must have type 'int' (not %0)"
H42A579D6B7B0: "重载的后置%select{递增|递减}1运算符的参数类型必须为 'int'（而非 %0）"
# 'parameter of overridden method is annotated with __attribute__((noescape))'
H1DC2A8B6BA41: '被覆盖的方法的参数被标记为__attribute__((noescape))'
# 'parameter of overriding method should be annotated with __attribute__((noescape))'
HD9E0E2EF69AC: '覆盖方法的参数应使用__attribute__((noescape))进行注解'
# "parameter of the 'collapse' clause"
H978C7D7597CF: "'collapse' 子句的参数"
# 'parameter of type %0 is declared here'
HB0D7D36BAAD5: '类型为 %0 的参数在此处声明'
# 'parameter pack %0 declared here'
HF649CEA110D0: '参数包 %0 在此处声明'
# 'parameter pack cannot have a default argument'
H220429408CBD: '参数包不能有默认参数'
# 'parameter references not allowed in naked functions'
HE9A90AF8CF8F: '在naked函数中不允许使用参数引用'
# "parameterized class %0 already conforms to the protocols listed; did you forget a '*'?"
H0F239CE68A40: '参数化类 %0 已经符合列出的协议；是否漏掉了 "*"?'
# 'parameters for defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator must have the same type%diff{ (found $ vs $)|}1,2'
H34C46A5FC53A: '默认的 %select{<ERROR>|相等|三向|相等|关系}0比较运算符的参数必须具有相同的类型 %diff{(发现$和$不同)|}1,2'
# "parent region for 'omp %select{cancellation point|cancel}0' construct cannot be nowait"
H10627ACFF3E1: "'omp %select{取消点|取消}0'结构的父区域不能是nowait"
# "parent region for 'omp %select{cancellation point|cancel}0' construct cannot be ordered"
H2F8AAD55F0CC: "'omp %select{取消点|取消}0'结构的父区域不能是ordered"
# "parent umbrella does not match: '%0' (provided) vs '%1' (found)"
H38C90C7CC02F: "父umbrella不匹配：提供的 '%0' 与发现的 '%1'"
# "parent umbrella missing from %0: '%1'"
HCD77F7184E7F: "父umbrella在 %0 中缺失：'%1'"
# 'parentheses are required around macro argument containing braced initializer list'
H41A73FF55953: '包含花括号初始化列表的宏参数周围需要括号'
# 'parentheses are required around this expression in a requires clause'
H8DF4B4E0E5BD: '在requires子句中，此表达式周围需要括号'
# 'parentheses around address non-type template argument are a C++11 extension'
H55DF42498A9B: '地址非类型模板实参周围的括号是C++11扩展'
# 'parentheses around address non-type template argument are incompatible with C++98'
H8ACABCA7F85D: '地址非类型模板实参周围的括号与C++98不兼容'
# "parentheses must be omitted if %0 attribute's argument list is empty"
H90F4FD29334C: '如果 %0 属性的参数列表为空，则必须省略括号'
# 'parentheses were disambiguated as a function declaration'
H329AE7B68E6C: '括号被解析为函数声明'
# 'parentheses were disambiguated as redundant parentheses around declaration of variable named %0'
H911B6F6318F6: '括号被解析为变量 %0 声明周围的冗余括号'
# 'parenthesize the second argument to silence'
HB3431A17CC77: '将第二个参数用括号括起来以消除歧义'
# 'parenthesized initialization of a member array is a GNU extension'
HD07F8AE496CA: '成员数组的括号初始化是GNU扩展'
# 'parse the input, create a PFT, dump it, and exit'
H8632144C8313: '解析输入，创建PFT，转储并退出'
# "parsing modulemap '%0'"
HAF9932C8E4DC: "正在解析模块映射文件 '%0'"
# 'partial ordering for explicit instantiation of %0 is ambiguous'
HE38D1382AB5B: '显式实例化 %0 的部分排序存在歧义'
# 'partial specialization cannot be declared as a friend'
HA147DDFF5AB9: '偏特化不能声明为友元'
# 'partial specialization matches %0'
HA30AC1C7D740: '偏特化与 %0 匹配'
# 'partial specialization of %0 does not use any of its template parameters'
H84CBC790F3FB: '%0 的偏特化未使用其任何模板参数'
# 'pass -fsafe-buffer-usage-suggestions to receive code hardening suggestions'
HB623B7D5D4C9: '使用 -fsafe-buffer-usage-suggestions 选项以接收代码强化建议'
# 'passing %0-byte aligned argument to %1-byte aligned parameter %2%select{| of %4}3 may result in an unaligned pointer access'
H8E7373BFAB19: '传递 %0 字节对齐的参数给 %1 字节对齐的参数 %2%select{| of %4}3 可能导致未对齐指针访问'
# 'passing %select{address of|reference to}0 local temporary object to musttail function'
H185CAE78405D: '将局部临时对象的%select{地址|引用}0传递给musttail函数'
# "passing %select{an object that undergoes default argument promotion|an object of reference type|a parameter declared with the 'register' keyword}0 to 'va_start' has undefined behavior"
H71043E0BAFE6: "将%select{经过默认参数提升的对象|引用类型对象|用 'register' 关键字声明的参数}0传递给 'va_start' 会导致未定义行为"
# "passing '%0' format string where '%1' format string is expected"
HB0DCC631BCB0: "在期望 '%1' 格式字符串的位置传递了 '%0' 格式字符串"
# "passing a type argument as the first operand to '_Generic' is a C2y extension"
H9B0C1A1B2AAD: '将类型参数作为_Generic的第一个操作数传递是C2y扩展'
# "passing a type argument as the first operand to '_Generic' is incompatible with C standards before C2y"
H0B03D58A8538: '将类型参数作为_Generic的第一个操作数传递与C2y之前的C标准不兼容'
# 'passing address of %select{non-local|non-scalar}0 object to __autoreleasing parameter for write-back'
H8F97A19F11B3: '将%select{非局部|非标量}0对象的地址传递给__autoreleasing参数用于写回'
# 'passing argument to parameter %0 here'
H30E4C5FD05FE: '此处传递参数给参数 %0'
# 'passing argument to parameter here'
HC7C3DD07B432: '此处传递参数给参数'
# 'passing arguments to %select{a function|%1}0 without a prototype is deprecated in all versions of C and is not supported in C23'
H192BBFFB4918: '向%select{函数|%1}0 传递参数而不使用原型在所有C版本中已弃用，并且C23不支持'
# 'passing byval argument %0 with potentially incompatible alignment here'
H730F797EFCA9: '此处传递的byval参数 %0 具有可能不兼容的对齐方式'
# "passing no argument for the '...' parameter of a variadic macro is a C++20 extension"
H6D5DB0C5BBB6: "为可变参数宏的 '...' 参数不传递参数是C++20扩展"
# "passing no argument for the '...' parameter of a variadic macro is a C23 extension"
H0F0C361742D6: "为可变参数宏的 '...' 参数不传递参数是C23扩展"
# "passing no argument for the '...' parameter of a variadic macro is incompatible with C standards before C23"
HCA1A72FB669A: "为可变参数宏的 '...' 参数不传递参数与C23之前的C标准不兼容"
# "passing no argument for the '...' parameter of a variadic macro is incompatible with C++ standards before C++20"
H2B8F35860B3B: "为可变参数宏的 '...' 参数不传递参数与C++20之前的C++标准不兼容"
# 'passing non-generic address space pointer to %0 may cause dynamic conversion affecting performance'
HAEF068C749A4: '将地址空间非通用指针传递给 %0 可能导致影响性能的动态转换'
# "passing object of class type %0 through variadic %select{function|block|method|constructor}1%select{|; did you mean to call '%3'?}2"
H39C1EFFB876B: "通过可变%select{函数|块|方法|构造函数}1传递类类型 %0 的对象 %select{|; 你是否想调用 '%3'?}2"
# 'passing object of trivial but non-POD type %0 through variadic %select{function|block|method|constructor}1 is incompatible with C++98'
HD5D2FE67C0FC: '通过可变%select{函数|块|方法|构造函数}1传递平凡但非POD类型 %0 的对象与C++98不兼容'
# "passing only one argument to 'va_start' is incompatible with C standards before C23"
H0DFF95F6ABB1: "在C23之前的C标准中，向 'va_start' 仅传递一个参数是不兼容的"
# "passing pointer %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
H9E268E19A549: "传递指针 %1 需要持有 %0 %select{'%2'|' 独占的 %2'}3"
# "passing pointer to variable %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
H0E1F82092409: "传递变量 %1 的指针需要持有 %0 %select{'%2'|' 独占的 %2'}3"
# "passing the value that %1 points to by reference requires holding %0 %select{'%2'|'%2' exclusively}3"
HFB2B4F9A02B6: "通过引用传递 %1 所指的值需要持有 %0 %select{'%2'|' 独占的 %2'}3"
# 'passing union across security boundary via %select{parameter %1|return value}0 may leak information'
HA1E50C08E561: '通过%select{参数 %1|返回值}0传递联合体跨安全边界可能会泄露信息'
# "passing variable %1 by reference requires holding %0 %select{'%2'|'%2' exclusively}3"
HB011E968C37B: "通过引用传递变量 %1 需要持有 %0 %select{'%2'|' 独占的 %2'}3"
# "pasting formed '%0', an invalid preprocessing token"
H17B929BA26C6: "连接形成无效预处理标记 '%0'"
# "pasting two '/' tokens into a '//' comment is a Microsoft extension"
HBFF0AAF786C4: "将两个 '/' 标记连接成 '//' 注释是微软扩展"
# 'path to a pass plugin for HIP to SPIR-V passes.'
HF42DFD9FA413: 'HIP 到 SPIR-V 转换的 Pass 插件路径。'
# 'path to instrumented binary in case if /proc/self/map_files is not accessible due to access restriction issues'
H9C547FEDA325: '在/proc/self/map_files不可用时使用的已插入探针的二进制文件路径'
# 'pc tracing with a guard'
H66AAE93ED197: '带有保护的PC跟踪'
# 'perf2bolt - BOLT data aggregator\n\nEXAMPLE: perf2bolt -p=perf.data executable -o data.fdata\n'
H64C11174A75F: 'perf2bolt - BOLT 数据聚合器\n\nEXAMPLE: perf2bolt -p=perf.data executable -o data.fdata\n'
# 'perform FOP on all functions'
H2A14A47C13E8: '对所有函数执行函数帧优化'
# 'perform FOP on hot functions'
H4C1838B87112: '对热函数执行函数帧优化'
# 'perform ICP on calls and jump tables'
H58DE93FE6F76: '对调用和跳转表执行间接调用提升优化'
# 'perform ICP on indirect calls'
HBCFC7E630187: '对间接调用执行提升优化'
# 'perform ICP on jump tables'
HF431F48B1DC7: '对跳转表执行间接调用提升优化'
# 'perform layout optimizing I-cache behavior'
H978D4EED4690: '根据指令缓存行为优化布局'
# 'perform optimal layout based on profile'
HC1766F39AC7E: '基于性能分析数据优化布局'
# 'perform optimal layout prioritizing I-cache behavior'
HBDF007516F2C: '优先指令缓存行为的优化布局'
# 'perform optimal layout prioritizing branch predictions'
HB3E593E231FA: '优先分支预测的优化布局'
# 'perform profiling accuracy-sensitive optimizations only if function execution count >= the threshold (default: 0)'
HFF64335273A6: '仅当函数执行次数 >= 阈值时执行精度敏感的优化（默认：0）'
# 'perform random layout of clusters'
H7C7C380E5354: '随机排列簇的布局'
# 'perform verification of LLVM instruction encoding/decoding. Every instruction in the input is decoded and re-encoded. If the resulting bytes do not match the input, a warning message is printed.'
H52D0672FF953: '执行LLVM指令编解码验证。输入中的每条指令都会被解码并重新编码。如果结果字节与输入不匹配，将打印警告信息。'
# 'performSelector may cause a leak because its selector is unknown'
H653C9447EE92: 'performSelector可能因选择器未知而导致内存泄漏'
# 'performSelector names a selector which retains the object'
HF51E4C8347B0: 'performSelector命名的会选择器会保留对象'
# 'performing pointer arithmetic on a null pointer has undefined behavior%select{| if the offset is nonzero}0'
HA288389E9F6A: '对空指针进行指针运算具有未定义行为 %select{|如果偏移量非零}0'
# 'performing pointer subtraction with a null pointer %select{has|may have}0 undefined behavior'
HB725A707608F: '使用空指针%select{具有|可能具有}0未定义行为的指针减法'
# 'performs disassembly sequentially'
HDD6DFBE032D2: '按顺序执行反汇编'
# 'permutation index must be at least 1 and at most %0'
H0297CCE3F38F: '排列索引必须至少为 1 且至多 %0'
# 'pick register allocator based on -O option'
H46CB03DD1B68: '基于 -O 选项选择寄存器分配器'
# 'pipes packet types cannot be of reference type'
H354A6AC50D78: '管道数据包类型不能是引用类型'
# "place '...' %select{immediately before declared identifier|here}0 to declare a function parameter pack"
HD82CBB258C12: "在%select{声明的标识符前直接|此处}0放置 '...' 以声明函数参数包"
# 'place all array allocations more than <size> elements on the heap'
H7583F9BA4C9F: '将元素数超过 <size> 的数组分配到堆上'
# 'place all array allocations of dynamic size on the heap'
H1E67C0E84EC2: '将动态大小的数组分配到堆上'
# 'place parentheses around comparison expression to evaluate it first'
H1021BF49A48F: '在比较表达式周围添加括号以优先计算它'
# 'place parentheses around the %0 expression to evaluate it first'
HD79F2195D659: "在 '%0' 表达式周围添加括号以优先计算它"
# 'place parentheses around the %quoted0 expression to silence this warning'
HFD7FB705EA72: '在%quoted0表达式周围添加括号以消除此警告'
# "place parentheses around the '?:' expression to evaluate it first"
H9605DB1A560A: "在 '?:' 表达式周围添加括号以先进行求值"
# 'place parentheses around the assignment to silence this warning'
HE705E4D071BD: '在赋值周围添加括号以消除此警告'
# 'place parentheses around the string literal to silence warning'
H876899527936: '在字符串字面量周围添加括号以消除警告'
# 'placeholder declared here'
H7E34AEC856E5: '占位符在此处声明'
# 'placeholder variables are a C++2c extension'
H4C0235C28642: '占位符变量是C++2c的扩展'
# 'placeholder variables are incompatible with C++ standards before C++2c'
H6BE10CEEDF1B: '占位符变量与C++2c之前的C++标准不兼容'
# 'placement new would change type of storage from %0 to %1'
H83FB1C107237: 'placement new会将存储类型从 %0 更改为 %1'
# "plain '_Complex' requires a type specifier; assuming '_Complex double'"
HBC4E2F0D8FF6: "普通的 '_Complex' 需要类型说明符；假设为 '_Complex double'"
# "platform does not match: '%0' (provided) vs '%1' (found)"
H5C64A2FB6312: "平台不匹配：提供的 '%0' 与检测到的 '%1'"
# "please rebuild precompiled file '%0'"
HC5036CB84980: "请重新构建预编译文件 '%0'"
# 'plt'
H8B8091C3AD1A: 'plt'
# 'pointer %0 declared here'
H22E4F3576FCE: '指针 %0 在此处声明'
# "pointer arguments to kernel functions must reside in '__global', '__constant' or '__local' address space"
HEE966568F6BF: "内核函数的指针参数必须位于 '__global'、'__constant' 或 '__local' 地址空间中"
# 'pointer cannot be cast to type %0'
H0546695B4A22: '指针不能转换为类型 %0'
# 'pointer cannot be mapped along with a section derived from itself'
HAF06E92DEBA3: '指针不能与其派生的部分同时映射'
# 'pointer comparisons before C11 need to be between two complete or two incomplete types; %0 is %select{|in}2complete and %1 is %select{|in}3complete'
H4DB22EDB67C8: 'C11之前的指针比较需要在两种完整类型或两种不完整类型之间；%0 是 %select{|in}2complete，%1 是 %select{|in}3complete'
# "pointer to function type %0 may not be 'restrict' qualified"
H909D3E85FCFF: "指向函数类型 %0 的指针可能不能被 'restrict' 限定"
# 'pointer to type %0 is invalid in OpenCL'
HEF9B07C9C640: '类型 %0 的指针在OpenCL中无效'
# 'pointer type mismatch%diff{ ($ and $)|}0,1'
H8EAA8DFC686A: '指针类型不匹配%diff{ ($和$)|}0,1'
# 'pointer-to-member function type %0 can only be called on an %select{rvalue|lvalue}1'
H08EA28E0562A: '成员函数类型 %0 只能在%select{右值|左值}1上调用'
# 'pointer/integer type mismatch in conditional expression%diff{ ($ and $)|}0,1'
HC15C6EF198BF: '条件表达式中的指针/整数类型不匹配%diff{ ($和$)|}0,1'
# 'poison on failure'
HE44AF8732393: '失败时注入毒药值'
# 'poison undef temps'
H7A7B675BE411: '污染未定义的临时变量'
# 'poison uninitialized stack variables'
H47518342CB8C: '污染未初始化的栈变量'
# 'poison uninitialized stack variables with a call'
H429653491DDF: '用调用毒化未初始化的栈变量'
# 'poison uninitialized stack variables with the given pattern'
H338B60F2873D: '用给定的模式毒化未初始化的栈变量'
# 'poisoning existing macro'
HDD8F2D4A6FAB: '毒化现有宏'
# 'position arguments in format strings start counting at 1 (not 0)'
HC64922328C30: '格式字符串中的位置参数从 1（而非 0）开始计数'
# "position-independent code requires '-mabicalls'"
H69FA922C5B49: "位置无关代码需要选项 '-mabicalls'"
# 'positional arguments are not supported by ISO C'
HE496161E3DDA: 'ISO C 不支持位置参数'
# 'possible misuse of comma operator here'
H0A8E98669706: '此处可能错误使用了逗号运算符'
# 'possible target for call'
H16BA315A6C23: '可能的调用目标'
# 'possible target of %select{indirect|asm}0 goto statement'
H03DE80F51E17: '%select{间接|asm}0 goto 语句的可能目标'
# 'postfix attributes are not allowed on Objective-C directives'
HA57AC12B1C85: '后缀属性不允许用于 Objective-C 指令'
# "postfix attributes are not allowed on Objective-C directives, place them in front of '%select{@interface|@protocol}0'"
H83C11CD38B50: "后缀属性不允许用于 Objective-C 指令，应将其置于 '%select{@interface|@protocol}0' 之前"
# 'potential performance regression from use of __builtin_expect(): annotation was correct on %0 of profiled executions'
HD6474E353C24: '使用 __builtin_expect() 可能导致性能倒退：在 %0 个已分析执行中，注解是正确的'
# 'pp-trace options'
H87829B6B5E89: 'pp-trace 选项'
# 'pragma %0 requires a parenthesized string'
H25DF715FB71D: 'pragma %0 需要带括号的字符串'
# 'pragma %select{message|warning|error}0 requires parenthesized string'
H58AE415DBC7A: 'pragma %select{message|warning|error}0 需要带括号的字符串'
# 'pragma STDC FENV_ROUND is not supported'
HF7A928CE98B4: '不支持 pragma STDC FENV_ROUND'
# 'pragma comment requires parenthesized identifier and optional string'
HD6BA08D64805: 'pragma comment 需要带括号的标识符和可选字符串'
# 'pragma detect_mismatch is malformed; it requires two comma-separated string literals'
H82A7E617FBD6: 'pragma detect_mismatch 格式错误；需要两个用逗号分隔的字符串字面量'
# "pragma diagnostic expected 'error', 'warning', 'ignored', 'fatal', 'push', or 'pop'"
HD2286608AABA: "pragma diagnostic 期望的参数是 'error'、'warning'、'ignored'、'fatal'、'push' 或 'pop'"
# 'pragma diagnostic expected option name (e.g. "-Wundef")'
HF5C6654FAE5F: 'pragma diagnostic 期望选项名称（例如 "-Wundef"）'
# 'pragma diagnostic pop could not pop, no matching push'
H6F8E683545E5: 'pragma diagnostic pop 无法弹出，因为没有对应的 push'
# "pragma float_control is malformed; use 'float_control({push|pop})' or 'float_control({precise|except}, {on|off} [,push])'"
HDD83603CAD05: "pragma float_control 格式错误；请使用 'float_control({push|pop})' 或 'float_control({precise|except}, {on|off} [,push])'"
# "pragma include_alias expected '%0'"
H01DD8237CC21: "pragma include_alias 期望的是 '%0'"
# 'pragma include_alias expected include filename'
H08BDBEAABFC9: 'pragma include_alias 期望包含的文件名'
# "pragma pop_macro could not pop '%0', no matching push_macro"
HF67398D54EBA: 'pragma pop_macro无法弹出 "%0"，因为没有对应的push_macro指令'
# "preceding '...' declares a function parameter pack"
HB271FF2CAE5F: "前面的 '...' 声明了一个函数参数包"
# 'preceding bit-field %0 declared here with type %1'
H8E483BDFCE6F: '前置位域 %0 在此处以类型 %1 声明'
# 'precompiled'
H5B5680CDE56B: '预编译'
# "precompiled file '%0' was compiled for the %1 '%2' but the current translation unit is being compiled for target '%3'"
H1980F89A839A: "预编译文件 '%0' 是为 %1 '%2' 编译的，但当前翻译单元正在为目标 '%3' 进行编译"
# "precompiled file '%0' was not built as a module"
H45336ACA964E: "预编译文件 '%0' 未作为模块构建"
# "precompiled file '%2' was compiled with module cache path '%0', but the path is currently '%1'"
HD917C02B86F6: "预编译文件 '%2' 使用模块缓存路径 '%0' 编译，但当前路径为 '%1'"
# "precompiled header '%0' was ignored because '%1' is not first '-include'"
H47051C658E08: "预编译头 '%0' 被忽略，因为 '%1' 不是第一个 '-include'"
# "precompiled header '%0' was ignored because it is not a clang PCH file"
HC110D52BBD02: "预编译头文件 '%0' 被忽略，因为它不是clang PCH文件"
# "precompiled header directory '%0' was ignored because it contains no clang PCH files"
H3E91139CDF42: "预编译头目录 '%0' 被忽略，因为它不包含任何clang PCH文件"
# 'predefined allocator cannot have traits specified'
H8666F51519BE: '预定义分配器不能指定特性'
# 'predefined identifier is only valid inside function'
HF82196FF10EA: '预定义标识符仅在函数内部有效'
# "predefined trait '%0' used here"
H55566D31A8B9: "此处使用了预定义特性 '%0'"
# 'predetermined as a firstprivate in a task construct here'
H405D7D760401: '在此任务构造中被预设为 firstprivate'
# 'prefer tail-folding, create scalar epilogue if tail folding fails.'
HD0E4E0A8CB08: '优先尾折叠，若尾折叠失败则创建标量尾部处理。'
# 'prefer update form when ds form is also a update form'
HEA9A1D5F496C: '当ds形式也是更新形式时，优先使用更新形式'
# 'prefer_list item must be a string literal or constant integral expression'
HCAFE9C287B6C: 'prefer_list 项必须是字符串字面量或常量整型表达式'
# 'preferred type for bit-field %0 specified here'
H89CF4480AE9D: '此处指定的位段 %0 的期望类型'
# "prefers tail-folding, don't attempt vectorization if tail-folding fails."
H12E0DCDDA093: '优先尾折叠，若尾折叠失败则不尝试向量化。'
# 'prefix attribute must be followed by an interface, protocol, or implementation'
H129BA69DE7F2: '前缀属性必须后跟接口、协议或实现'
# 'prefix with the address-of operator to silence this warning'
H51278B3A983C: '使用地址取值运算符前缀以消除此警告'
# 'prepare update form when the load/store increment is a loop invariant non-const value.'
H7F0464394BFE: '当加载/存储增量是一个循环不变的非常量值时准备更新形式'
# 'preserve intermediate .o file'
HBCF9A92B45C8: '保留中间.o文件'
# 'pretty-print DWARF debug information in object files and debug info archives.\n'
HFF4E6027BC6C: '以美观格式打印对象文件和调试信息存档中的DWARF调试信息。\n'
# 'previous %select{template type|non-type template|template template}0 parameter%select{| pack}1 declared here'
HEDFC0D57E1AE: '之前的 %select{模板类型|非类型模板|模板模板}0 参数 %select{| 包}1 在此处声明'
# 'previous %select{unmarked |}0overload of function is here'
HAE3E66A916BE: '之前的 %select{未标记 |}0 函数重载在此处'
# "previous '#pragma pack' directive that modifies alignment is here"
H39F3F82E0571: "修改对齐的前一个 '#pragma pack' 指令在此处"
# "previous '%0' clause is here"
HDC66D6DA5D75: "前一个 '%0' 子句在此处"
# "previous '%0' directive used here"
HE7A8B08DD5DE: "前一个 '%0' 指令在此处使用"
# "previous 'critical' region starts here"
H3FBC82C6CFEF: "前一个 'critical' 区域从此处开始"
# 'previous allocator is specified here'
H065261987D15: '前一个分配器在此处指定'
# 'previous attribute is here'
H6E32F6609895: '前一个属性在此处'
# 'previous binding pack specified here'
H720F62C2E50B: '之前在这里指定的绑定包'
# 'previous call is here%select{; set to nil to indicate it cannot be called afterwards|}0'
HE8A56E8F5AF3: '之前的调用在这里 %select{; 设置为nil以指示之后无法调用|}0'
# 'previous case defined here'
H67B17B33B89D: '之前在这里定义的case'
# 'previous clause with directive name modifier specified here'
H59743B40EF38: '之前在这里指定的带有指令名称修饰符的子句'
# "previous command '%select{\\|@}0%1' (an alias of '\\%2') here"
HE969B475A653: '之前的命令“%select{\\|@}0%1”（别名“\\%2”的别名）在这里'
# "previous command '%select{\\|@}0%1' here"
H5B43AF8F451D: '之前的命令“%select{\\|@}0%1”在这里'
# 'previous declaration is here'
H9CAB5B6B1715: '之前的声明在这里'
# 'previous declaration of class template partial specialization %0 is here'
H8EF5BDE072C8: '类模板的部分特化 %0 的之前声明在这里'
# 'previous declaration of variable template partial specialization is here'
H5A936ED6E7F5: '变量模板的部分特化的之前声明在这里'
# 'previous default generic association is here'
H5A119A508D2B: '之前的默认通用关联在这里'
# 'previous default template argument defined here'
H828BBDD8C7F9: '之前在这里定义的默认模板参数'
# 'previous default template argument defined in module %0'
H2F92B57F5F02: '之前在模块 %0 中定义的默认模板参数'
# 'previous definition is here'
H0AC845A11A85: '之前的定义在这里'
# 'previous documentation'
H8053B03861AE: '之前的文档说明'
# 'previous equal key is here'
H916F7D758598: '之前在这里的等效键'
# 'previous explicit instantiation is here'
HCA86CACA9800: '之前的显式实例化在这里'
# 'previous expression is here'
H72EA4DC42083: '之前的表达式在这里'
# 'previous implicit declaration is here'
H2F8B22E01C4A: '之前的隐式声明在这里'
# 'previous inheritance model specified here'
HDD10F14D9687: '之前在这里指定的继承模型'
# 'previous initialization %select{|with side effects }0is here%select{| (side effects will not occur at run time)}0'
HFE059F4FA2A1: '之前的初始化 %select{|带有副作用 }0在这里 %select{|（副作用在运行时不会发生）}0'
# 'previous initialization for field %0 is here'
HEF0E98EA391B: '字段 %0 的先前初始化在这里'
# 'previous module declaration is here'
HD052ACC784A7: '之前的模块声明在这里'
# 'previous non-type template parameter with type %0 is here'
H5A88D83E2220: '类型为 %0 的先前非类型模板参数在这里'
# 'previous reference is here'
HEFAE6804D795: '之前的引用在这里'
# 'previous return statement is here'
H147041BC8FB0: '之前的返回语句在这里'
# 'previous statement is here'
H94AB14DFE365: '之前的语句在这里'
# 'previous template %select{declaration|template parameter}0 is here'
H94CA97347769: '之前的模板%select{声明|模板参数}0在这里'
# 'previous template specialization is here'
H0FDA24AE451B: '之前的模板特化在这里'
# 'previous use is here'
H39A31F8B143F: '之前的使用在这里'
# 'previous uuid specified here'
H8206D7044433: '之前指定的UUID在这里'
# "previously declared '%0' here"
H4ECE9D2CF70E: "之前在这里声明的 '%0'"
# "previously declared '%1' here"
H6BFF38DE7EEF: "之前在这里声明的 '%1'"
# 'previously declared as %0 here'
HEA5BCF07D9E2: '之前在这里被声明为 %0'
# 'previously defined as an alias for %0'
HC8CE8DE52E3E: '之前被定义为 %0 的别名'
# 'previously defined here'
H0787B53F4571: '之前在这里定义'
# 'previously marked as task_reduction with different reduction operation'
HFE3CA309C947: '之前被标记为task_reduction但使用了不同的约简操作'
# 'previously referenced here'
H8ADE478F0E44: '之前在这里被引用'
# 'primary property declaration is implicitly strong while redeclaration in class extension is weak'
H331A66416F47: '主属性声明隐式为strong，而类扩展中的重新声明为weak'
# 'print ORC unwind information for instructions'
H4E31B5E474E7: '打印指令的ORC展开信息'
# 'print aliases when printing objects'
HF92219983E87: '打印对象时显示别名'
# 'print all SDT markers'
H98709AE1B551: '打印所有SDT标记'
# 'print all proposals received and whether they were rejected or accepted'
H04A22263A041: '打印所有收到的提议及其是否被拒绝或接受'
# 'print all registered sections'
H8FAB43011447: '打印所有已注册的段'
# 'print clusters'
H9B37594EE600: '打印簇'
# 'print debug info when printing functions'
HFF8256E364B3: '打印函数时显示调试信息'
# 'print dyno stats after each stage'
H9275B8D7E627: '在每个阶段后打印dyno统计信息'
# 'print everything - most verbose'
H1BEA0BEF5E2F: '打印所有内容 - 最详细模式'
# 'print exception handling data'
H8F7DF5B5AC2D: '打印异常处理数据'
# 'print execution info based on profile'
H93C84C9D44B9: '根据配置文件打印执行信息'
# 'print function after CFG is finalized'
H87F7D6E5ADA5: '在控制流图最终确定后打印函数'
# 'print function after disassembly'
H6524D80C8BFA: '反汇编后打印函数'
# 'print function after edge counts are set for no-LBR profile'
H3061E9C9E191: '在设置无LBR配置文件的边计数后打印函数'
# 'print function after fixing local branches'
H1402AC66D1C0: '修复本地分支后打印函数'
# 'print function after instruction lowering'
H612727DB3C18: '指令下沉后打印函数'
# 'print function after jt-footprint-reduction pass'
HDF747925B28E: '在jt-footprint-reduction pass之后打印函数。'
# 'print functions after ADR Relaxation pass'
H380909F95FC6: '在ADR Relaxation pass之后打印函数。'
# 'print functions after CFG construction'
HCF99E2AF5C10: '在CFG构建阶段之后打印函数'
# 'print functions after CFG is normalized'
H52A0761BF0A3: '在CFG标准化阶段之后打印函数'
# 'print functions after ICF optimization'
H0BC917F969E4: '在ICF优化阶段之后打印函数'
# 'print functions after PLT optimization'
HF2CB032C6433: '在PLT优化阶段之后打印函数'
# 'print functions after attaching profile'
HD8A5C41FAD15: '在附加配置文件阶段之后打印函数'
# 'print functions after bodyless optimization'
HBA38B0532A13: '在无函数体优化阶段之后打印函数'
# 'print functions after clustering'
H867D3C181C5B: '在聚类阶段之后打印函数'
# 'print functions after code splitting'
HFFE83E7C36B6: '在代码分割阶段之后打印函数'
# 'print functions after conditional tail call simplification'
H0EFD18F8B1CE: '在条件尾调用简化阶段之后打印函数'
# 'print functions after each stage'
H6F2DBD4C3BE5: '在每个阶段之后打印函数'
# 'print functions after fix RISCV calls pass'
HA11DE9F7CABB: '在修复RISCV调用的pass之后打印函数。'
# 'print functions after fix relaxations pass'
H9A6C75CABE6B: '在修复relaxations的pass之后打印函数。'
# 'print functions after frame optimizer pass'
H37293007159E: '在frame optimizer pass之后打印函数。'
# 'print functions after indirect call promotion'
H6777ED6D8688: '在间接调用提升阶段之后打印函数'
# 'print functions after inlining optimization'
H849DB929CE9A: '在内联优化阶段之后打印函数'
# 'print functions after layout optimization'
H1EAABA34176F: '在布局优化阶段之后打印函数'
# 'print functions after longjmp pass'
H2C02F65E2B10: '在longjmp pass之后打印函数。'
# 'print functions after peephole optimization'
HF6F27EE243F4: '在窥孔优化阶段之后打印函数'
# 'print functions after regreassign pass'
H205E59625248: '在regreassign pass之后打印函数。'
# 'print functions after retpoline insertion pass'
H348587451657: '在retpoline插入pass之后打印函数。'
# 'print functions after simplification of RO data loads'
HA796FD5DA60B: '简化 RO 数据加载优化阶段后打印函数'
# 'print functions after stoke analysis'
H090E8674EC1A: 'Stoke 分析后打印函数'
# 'print functions after unreachable code elimination'
HC31930E74334: '消除不可达代码优化阶段后打印函数'
# 'print functions after veneer elimination pass'
HD9F864AE57D7: '在veneer消除pass之后打印函数。'
# 'print functions of binary 2 that were not matched to any function in binary 1'
H74494F9D492B: '打印二进制 2 中未与二进制 1 的任何函数匹配的函数'
# 'print functions sorted by execution count'
HB0992E5F3DD7: '按执行次数排序打印函数'
# 'print functions sorted by order of dyno stats'
H0A27E3FA15F0: '按 dyno 统计信息顺序排序后打印函数'
# 'print functions sorted by total branch count'
H58EE9BACA77C: '按总分支数排序打印函数'
# 'print functions that could not be overwritten due to excessive size'
H64A4A3141F70: '因尺寸过大而无法覆盖的函数'
# 'print functions that have profile in binary 1 but do not in binary 2'
H8FB878E6408D: '打印二进制 1 中存在但二进制 2 中不存在的函数的性能分析数据'
# 'print global symbols after disassembly'
H6F71EE919FF4: '反汇编后打印全局符号'
# 'print heatmap to a given file'
HF4CFE90F13C4: '将热点图输出到指定文件'
# 'print jump tables'
HE7814FCDE82F: '打印跳转表'
# 'print loop related information'
H1CC87F1B29B5: '打印循环相关信息'
# 'print mappings in the legend, between characters/blocks and text sections (default false)'
HAB49FA127C23: '在图例中打印字符/块与文本段之间的映射关系（默认 false）'
# 'print memory data annotations when printing functions'
HE37470A2DD9C: '打印函数时显示内存数据注释'
# 'print names of functions with unknown control flow'
H02687E68D720: '打印具有未知控制流的函数名称'
# 'print no details'
HE1459B6CBBDF: '不打印任何细节'
# 'print out instructions with default strict semantics i.e.,check that all the inputs are fully initialized, and mark the output as fully initialized. These semantics are applied to instructions that could not be handled explicitly nor heuristically.'
H49408DBFABD2: '按默认严格语义输出指令，即检查所有输入是否完全初始化，并将输出标记为完全初始化。这些语义应用于无法显式或启发式处理的指令'
# 'print output address range for each basic block in the function whenBinaryFunction::print is called'
H4D2F05339EF5: '当调用 BinaryFunction::print 时，打印函数中每个基本块的输出地址范围'
# "print pass arguments to pass to 'opt'"
H6E943315CBC7: "打印传递给 'opt' 的pass参数"
# 'print pass details when it is executed'
H76B02F3EE5E5: '在pass执行时打印详细信息'
# 'print pass name before it is executed'
H741AF7A7B7D4: '在pass执行前打印其名称'
# 'print pass structure before run()'
HF0D6992C747F: '在run()前打印pass结构'
# 'print per instruction opcode dyno stats and the functionnames:BB offsets of the nth highest execution counts'
HED6C36296EF9: '按每条指令的 opcode dyno 统计信息打印前 n 高执行次数的函数名及其基本块偏移量'
# 'print profile quality/bias analysis'
H2BA901542885: '打印性能分析质量/偏差分析结果'
# 'print pseudo probe info'
H497835ACD698: '打印伪探测信息'
# 'print regions in detail with block_iterator'
HC53F268C8D37: '使用block_iterator详细打印区域'
# 'print regions in detail with element_iterator'
HEED2CD6BB906: '使用element_iterator详细打印区域'
# 'print register usage details collected for analysis.'
H852E76ABE034: '打印为分析收集的寄存器使用详情。'
# 'print relocations when printing functions/objects'
HC7882ECBD016: '在打印函数/对象时显示重定位信息'
# 'print section contents after reordering'
HBFCEFB46E060: '打印重新排序后的段内容'
# 'print statistics about basic block ordering'
HD0B0C3B01A36: '打印基本块排序的统计信息'
# 'print the CFG of important functions that changed in binary 2'
H50C9F66DBC43: '打印在二进制 2 中发生变化的重要函数的控制流图'
# 'print the basic blocks showed in top differences'
H1DA154B840C3: '打印在顶部差异中显示的基本块'
# 'print the list of functions with stale profile'
HE912214BA092: '打印带有过时配置文件的函数列表'
# 'print the list of objects with count to stderr'
H2C756772AFAF: '将带有计数的对象列表打印到标准错误输出'
# 'print time spent constructing binary functions'
H5978E6E15455: '打印构建二进制函数所花费的时间'
# 'print time spent in each optimization'
H0BBB239D4108: '打印每个优化所花费的时间'
# 'print time spent in rewriting passes'
H40857EC64F6B: '打印重写passes所花费的时间。'
# 'print top <uint> functions with suboptimal code layout on input'
HBFD8DED23E2E: '打印输入中具有次优代码布局的前 <uint> 个函数'
# 'printing of statistics for each inlined function'
HCEA14F1643A5: '为每个内联函数打印统计信息'
# 'prints out offsets for abbrev and debug_info of Skeleton CUs that get patched.'
H71912C66C3FC: '输出被修补的骨架编译单元的abbrev和debug_info的偏移量。'
# 'prioritize low virtual register numbers for test and debug'
H0A6C1C201BCE: '优先使用低虚寄存器号用于测试和调试'
# "private API notes file for module '%0' should be named '%0_private.apinotes', not '%1'"
HB68113D2F79A: "模块 '%0' 的私有API注释文件应命名为 '%0_private.apinotes'，而非 '%1'"
# 'private field %0 is not used'
H3584A3B50C2A: '私有字段 %0 未被使用'
# 'private module fragment begins here'
H3A617A73B3A6: '私有模块片段从这里开始'
# 'private module fragment declaration with no preceding module declaration'
H1202B7565A2E: '没有前置模块声明的私有模块片段声明'
# 'private module fragment in module implementation unit'
H48CE0D8A14BD: '模块实现单元中的私有模块片段'
# 'private module fragment redefined'
H1427CFAECC58: '私有模块片段被重新定义'
# "private submodule '%0' in private module map, expected top-level module"
HCB6CC643EA83: "私有模块映射中的私有子模块 '%0'，期望顶层模块"
# 'probability argument to __builtin_expect_with_probability is outside the range [0.0, 1.0]'
HFB32BCF3AB99: '传递给 __builtin_expect_with_probability 的概率参数超出 [0.0, 1.0] 范围'
# 'probability argument to __builtin_expect_with_probability must be constant floating-point expression'
H828E266CB5B1: '传递给 __builtin_expect_with_probability 的概率参数必须是常量浮点数表达式'
# 'process functions with stack pointer arithmetic'
H56D80573022C: '处理使用栈指针算术的函数'
# 'profile data may be incomplete: of %0 function%s0, %1 %plural{1:has|:have}1 no data'
H8ACA9571B75F: '性能数据可能不完整：在 %0 个函数%s0 中，%1 %plural{1:没有|:没有}1 数据'
# 'profile data may be out of date: of %0 function%s0, %1 %plural{1:has|:have}1 mismatched data that will be ignored'
HBED3698588C8: '性能数据可能已过时：%0 个函数%s0 中有 %1 %plural{1:|:}1 不匹配的数据将被忽略'
# 'propagate shadow through ICmpEQ and ICmpNE'
HB09C108C7674: '通过ICmpEQ和ICmpNE传播shadow'
# 'propagating dll attribute to %select{already instantiated|explicitly specialized}0 base class template without dll attribute is not supported'
H6A4E6175A865: '将dll属性传播到没有dll属性的基类模板%select{已实例化|显式特化}0不受支持'
# 'property %0 attempting to use instance variable %1 declared in super class %2'
HDDED40707D8D: '属性 %0 正在尝试使用在超类 %2 中声明的实例变量 %1'
# 'property %0 cannot be found in forward class object %1'
H503270AA1975: '在前向类对象 %1 中找不到属性 %0'
# 'property %0 declared with incompatible types in different translation units (%1 vs. %2)'
H2F559B93D7CB: '属性 %0 在不同的翻译单元中声明的类型不兼容（%1 与 %2）'
# 'property %0 found on object of type %1; did you mean to access it with the "." operator?'
H0A371D1A94C3: '在类型 %1 的对象上找到属性 %0；是否应使用“.”运算符访问它？'
# 'property %0 has a variably modified type'
H81C9932A69B3: '属性 %0 具有可变修改的类型'
# "property %0 is a class property; did you mean to access it with class '%1'?"
HFC5FD97AFD4C: '属性 %0 是类属性；是否应使用类 "%1" 访问它？'
# 'property %0 is already implemented'
H4ECC248CA95F: '属性 %0 已被实现'
# 'property %0 is declared %select{deprecated|unavailable|partial}1 here'
HC2D276377832: '属性 %0 在此处被声明为%select{已弃用|不可用|部分}1'
# 'property %0 is implemented with %select{@synthesize|@dynamic}1 here'
H43FFE47B4C6F: '属性 %0 在此处使用 %select{@synthesize|@dynamic}1 实现'
# 'property %0 is implemented with %select{@synthesize|@dynamic}1 in one translation but %select{@dynamic|@synthesize}1 in another translation unit'
H7C85E91BA02D: '属性 %0 在一个翻译单元中使用 %select{@synthesize|@dynamic}1 实现，但在另一个翻译单元中使用 %select{@dynamic|@synthesize}1'
# 'property %0 is synthesized to different ivars in different translation units (%1 vs. %2)'
HE49921A78EC2: '属性 %0 在不同的翻译单元中合成到不同的实例变量（%1 与 %2）'
# 'property %0 not found on object of type %1'
H2822C5946CF1: '类型 %1 的对象中未找到属性 %0'
# 'property %0 not found on object of type %1; did you mean %2?'
HBDBDE3E27B96: '类型 %1 的对象中未找到属性 %0；您是否是指 %2？'
# 'property %0 not found on object of type %1; did you mean to access instance variable %2?'
H8C5C6406F710: '类型 %1 的对象中未找到属性 %0；是否应访问实例变量 %2？'
# 'property %0 not found on object of type %1; did you mean to access property %2?'
H9C85D93EEE02: '类型 %1 的对象中未找到属性 %0；是否应访问属性 %2？'
# 'property %0 refers to an incomplete Objective-C class %1 (with no @interface available)'
H5BDCDB941EFA: '属性 %0 引用了一个不完整的 Objective-C 类 %1（没有可用的 @interface）'
# 'property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this category'
HD9354003F0AB: '属性 %0 需要定义方法 %1 — 使用 @dynamic 或在此类别中提供方法实现'
# 'property %0 requires method %1 to be defined - use @synthesize, @dynamic or provide a method implementation in this class implementation'
HD343415F7FA6: '属性 %0 需要定义方法 %1 — 使用 @synthesize、@dynamic 或在此类实现中提供方法实现'
# "property %select{of type %1|with attribute '%1'|without attribute '%1'|with getter %1|with setter %1}0 was selected for synthesis"
HAD70544BC938: "选择了 %select{类型 %1 的属性|带有属性 '%1' 的属性|没有属性 '%1' 的属性|带有 getter %1 的属性|带有 setter %1 的属性}0 进行合成"
# 'property access is using %0 method which is deprecated'
HC446F861F2EE: '属性访问使用已弃用的 %0 方法'
# 'property access is using %0 method which is unavailable'
H61B587B99038: '属性访问使用不可用的 %0 方法'
# 'property access result unused - getters should not be used for side effects'
H1D3B4CAFB27A: '属性访问结果未使用 — 获取器不应用于副作用'
# 'property attribute in class extension does not match the primary class'
H928CE0C5C480: '类扩展中的属性属性与主类不匹配'
# "property attributes '%0' and '%1' are mutually exclusive"
H4A7BE0C59F5F: "属性属性 '%0' 和 '%1' 是互斥的"
# 'property cannot have array or function type %0'
HE68B6C09E364: '属性不能具有数组或函数类型 %0'
# 'property declaration cannot have a default member initializer'
H5272D8E5D57E: '属性声明不能有默认成员初始化器'
# "property declaration specifies '%0' accessor twice"
H0E68E4E4BA05: "属性声明指定了 '%0' 访问器两次"
# 'property declared as returning non-retained objects; getter returning retained objects'
H53034807D818: '该属性声明为返回非保留对象；获取器返回保留对象'
# 'property declared here'
H69D70856EBD1: '属性在此处声明'
# 'property declared in category %0 cannot be implemented in class implementation'
H04FE1B1065E1: '在类别 %0 中声明的属性不能在类实现中实现'
# 'property does not specify a getter or a putter'
HD0F5818FB6C8: '属性未指定getter或setter'
# "property follows Cocoa naming convention for returning 'owned' objects"
HEBB6CB98CE86: "属性遵循返回'拥有'对象的Cocoa命名约定"
# 'property has a previous declaration'
H28BB0E9D9F7A: '属性已有之前的声明'
# 'property implementation in a category with no category declaration'
HF42022DEA14A: '在无类别声明的类别中实现属性'
# 'property implementation must be in a class or category implementation'
HD59CD2B75162: '属性实现必须在类或类别实现中'
# 'property implementation must have its declaration in interface %0 or one of its extensions'
HFCF842D4EB86: '属性实现必须在其接口 %0 或其扩展之一中声明'
# 'property implementation must have its declaration in the category %0'
H761B0BB38838: '属性实现必须在其类别 %0 中声明'
# 'property is assumed atomic by default'
H2882A0CD4FD8: '属性默认假设为原子性'
# 'property is assumed atomic when auto-synthesizing the property'
HC5E58A6AB217: '在自动合成属性时，默认假设属性为原子性'
# 'property is synthesized to ivar %0 here'
H7E91E310D399: '属性在此处被合成到实例变量 %0'
# 'property name cannot be a bit-field'
H8E1C0549C2E5: '属性名称不能是位字段'
# 'property requires fields to be named'
H9C4AAD2700BB: '属性需要命名字段'
# 'property should be changed to be readwrite'
H32DF2D479322: '属性应改为readwrite'
# 'property synthesized here'
H0BB379E6C96C: '属性在此处被合成'
# 'property type %0 is incompatible with type %1 inherited from %2'
HDE3695134102: '属性类型 %0 与从 %2 继承的类型 %1 不兼容'
# "property with '%0' attribute must be of object type"
H44EF18C35C26: '具有 "%0" 属性的属性必须是对象类型'
# 'protected %select{constructor|destructor}0 can only be used to %select{construct|destroy}0 a base class subobject'
H8490EFD629C0: '受保护的%select{构造函数|析构函数}0只能用于%select{构造|销毁}0基类子对象'
# 'protocol %0 has no definition'
H3F201B2D647A: '协议 %0 没有定义'
# 'protocol has circular dependency'
HBFCB55FB9C5B: '协议存在循环依赖'
# "protocol has no object type specified; defaults to qualified 'id'"
H79AE64D3788F: "协议未指定对象类型；默认使用限定的 'id'"
# 'protocol is declared here'
H63C66770E070: '协议在此处声明'
# 'protocol method is expected to return an instance of the implementing class, but is declared to return %0'
HCECBCE2ED619: '协议方法应返回实现类的实例，但声明返回 %0'
# 'protocol method is here'
H850DBE7D30DB: '协议方法在此处'
# 'protocol qualifiers must precede type arguments'
HE1585F9267E6: '协议限定符必须在类型参数之前'
# "provided host compiler IR file '%0' is required to generate code for OpenMP target regions but cannot be found"
H4ECB10C5BABB: "提供的主机编译器IR文件 '%0' 用于生成OpenMP目标区域代码，但未找到"
# 'pseudo-destructor call is not permitted in constant expressions until C++20'
HFC660C022DFD: '在C++20之前不允许在常量表达式中使用伪析构函数调用'
# 'pseudo-destructor destroys object of type %0 with inconsistently-qualified type %1'
HFC3306882505: '伪析构函数以不一致限定的类型 %1 销毁类型 %0 的对象'
# 'pseudo-destructors on type void are a Microsoft extension'
H6C76EC18D3A0: 'void类型的伪析构函数是Microsoft扩展'
# "public framework header includes private framework header '%0'"
H7F0AEF01704E: "公共框架头文件包含私有框架头文件 '%0'"
# 'pure virtual function %q0 called'
H3187DE144A64: '调用了纯虚函数 %q0'
# 'put the semicolon on a separate line to silence this warning'
HD2A85AED0A2F: '将分号放在单独的一行以消除此警告'
# "putter for property must be specified as 'put', not 'set'"
H65FA70517FA4: "属性的设置器必须指定为 'put'，而不是 'set'"
# 'qualified call to %0::%1 is treated as a virtual call to %1 due to -fapple-kext'
HAEBB9D60FCD1: '由于 -fapple-kext，对 %0::%1 的限定调用被视为对 %1 的虚函数调用'
# 'qualified destructor name only found in lexical scope; omit the qualifier to find this type name by unqualified lookup'
H95040EDE1833: '限定的析构函数名称仅在词法作用域中找到；省略限定符以通过非限定查找查找该类型名称'
# 'qualified member access refers to a member in %0'
H69C8244E4885: '限定的成员访问引用 %0 中的成员'
# 'qualified module name can only be used to define modules at the top level'
HCDFABF1A81DD: '限定的模块名称只能用于在顶层定义模块'
# 'qualified name refers into a specialization of %select{function|variable}0 template %1'
H4C7D694E4A70: '限定的名称引用 %select{函数|变量}0模板 %1 的特化'
# 'qualified reference to %0 is a constructor name rather than a %select{template name|type}1 in this context'
H08AE31B94F15: '在此上下文中，对 %0 的限定引用是构造函数名称而非 %select{模板名称|类型}1'
# "qualifier 'const' is needed for variables in address space '%0'"
HADB69D493623: "地址空间 '%0' 中的变量需要 'const' 限定符"
# 'qualifier in explicit instantiation of %q0 requires a template-id (a typedef is not permitted)'
HB21409C3C5FB: '显式实例化%q0中的限定符需要模板标识符（不允许使用typedef）'
# 'qualifiers after comma in declarator list are ignored'
H09D49C9D12E0: '声明符列表中的逗号后限定符将被忽略'
# 'qualify call to silence this warning'
HDB3D8B807347: '使用限定调用以消除此警告'
# 'r11 available before calls and jumps'
H69431C8A884E: '调用和跳转前可用r11'
# 'r11 available before calls but not before jumps'
HAF3B1E936CB4: '调用前可用r11，但跳转前不可用'
# 'r11 not available'
HD51A31809CB5: 'r11不可用'
# "range-based 'for' statement uses ':', not '='"
HC53E3757D97C: "基于范围的 'for' 语句使用 ':' 而非 '='"
# 'range-based for loop has empty body'
H2C4FFAA3CE47: '基于范围的for循环具有空主体'
# 'range-based for loop initialization statements are a C++20 extension'
H77FF5523C4B8: '基于范围的for循环初始化语句是C++20扩展'
# 'range-based for loop initialization statements are incompatible with C++ standards before C++20'
H529EE263FDB4: '基于范围的for循环初始化语句与C++20之前的C++标准不兼容'
# 'range-based for loop is a C++11 extension'
HE56D92957A6D: '基于范围的for循环是C++11扩展'
# 'range-based for loop is incompatible with C++98'
H2229A30F511E: '基于范围的for循环与C++98不兼容'
# 'range-based for loop requires type for loop variable'
H07E32C6E46BC: '基于范围的for循环需要为循环变量指定类型'
# 'raw string delimiter longer than 16 characters; use PREFIX( )PREFIX to delimit raw string'
H00B2DC6A7B32: '原始字符串分隔符超过 16 个字符；请使用PREFIX( )PREFIX限定原始字符串'
# 'raw string literals are incompatible with C++98'
H1C93D8A83CA2: '原始字符串文字与C++98不兼容'
# 'raw string missing terminating delimiter )%0"'
H7FD087037BE3: '缺少原始字符串的终止分隔符)%0"'
# "re-exported libraries do not match: '%0' (provided) vs '%1' (found)"
H6C320DEC171A: "重新导出的库不匹配：'%0'（提供）与 '%1'（找到）"
# "re-exported library missing from %0: '%1'"
H552D4BA598A3: "'%1' 未包含在 %0 的重新导出库中"
# 're-use space in old .text if possible (relocation mode)'
H05BFF380B5E6: '如果可能，在重定位模式下重用旧.text段中的空间'
# 'read of incomplete type %0 is not allowed in a constant expression'
HCA641211FEEB: '不完全类型 %0 的读取操作不允许出现在常量表达式中'
# 'read of non-const variable %0 is not allowed in a constant expression'
HD99D6E4F37A4: '非常量变量 %0 的读取操作不允许出现在常量表达式中'
# 'read of non-constexpr variable %0 is not allowed in a constant expression'
HF3D92222C519: '非constexpr变量 %0 的读取操作不允许出现在常量表达式中'
# 'read of variable %0 of non-integral, non-enumeration type %1 is not allowed in a constant expression'
H33BFBE7CF01D: '非整型、非枚举类型 %1 的变量 %0 的读取操作不允许出现在常量表达式中'
# "readonly IBOutlet property %0 when auto-synthesized may not work correctly with 'nib' loader"
H582EA0DF024A: "自动合成时只读IBOutlet属性 %0 可能无法与 'nib' 加载器正确配合工作"
# 'reassign registers so as to avoid using REX prefixes in hot code'
HE2FFC9EC6F02: '重新分配寄存器以避免在热点代码中使用REX前缀'
# 'received warning after diagnostic serialization teardown was underway: %0'
H60ECB032353D: '在诊断序列化拆卸过程中收到警告：%0'
# 'receiver %0 for class message is a forward declaration'
HAE87B957CEBD: '类消息的接收者 %0 是一个前向声明'
# 'receiver %0 is a forward class and corresponding @interface may not exist'
H2EFCADD231BF: '接收者 %0 是一个前向类，对应的@interface可能不存在'
# 'receiver expression is here'
H16AA23E5E187: '接收者表达式在此处'
# 'receiver is instance of class declared here'
H063C50E49E8E: '接收者是此处声明的类的实例'
# "receiver is treated with 'id' type for purpose of method lookup"
H23B037191711: "接收者在方法查找时被当作 'id' 类型处理"
# 'receiver type %0 for instance message is a forward declaration'
H4107B7B01A42: '实例消息的接收者类型 %0 是一个前向声明'
# "receiver type %0 is not 'id' or interface pointer, consider casting it to 'id'"
HC44380DEE815: "接收者类型 %0 不是 'id' 或接口指针，建议将其转换为 'id'"
# 'receiver type %0 is not an Objective-C class'
HDF1E1AF5B7B2: '接收者类型 %0 不是Objective-C类'
# 'record profile for inter-function control flow activity (default: true)'
HB3410F96E4B8: '记录函数间控制流活动的配置文件（默认：true）'
# 'recursive evaluation of default argument'
H9D22EE24805A: '默认参数的递归求值'
# 'recursive template instantiation exceeded maximum depth of %0'
H9F7DB4D308D0: '递归模板实例化超过最大深度 %0'
# "redeclaration cannot add 'loader_uninitialized' attribute"
H70EFB9FBF448: "重新声明不能添加 'loader_uninitialized' 属性"
# 'redeclaration has different alignment requirement (%1 vs %0)'
H2965974DE860: '重新声明的对齐要求不同（%1 vs %0）'
# "redeclaration of %0 must %select{not |}1have the 'overloadable' attribute"
H9C609286F3D1: "%0 的重新声明必须%select{不具有|}1'overloadable' 属性"
# 'redeclaration of %0 with a different type%diff{: $ vs $|}1,2'
HEB05B74B4F52: '%0 的重新声明具有不同类型%diff{：$ vs $|}1,2'
# 'redeclaration of %q0 cannot add %q1 attribute'
H437273BF8230: '%q0的重新声明不能添加%q1属性'
# 'redeclaration of %q0 should not add %q1 attribute'
HBC3EEF68F79F: '%q0的重新声明不应添加%q1属性'
# "redeclaration of C++ built-in type 'bool'"
H4DE1B64751F8: "C++内建类型 'bool' 的重新声明"
# 'redeclaration of already-defined enum %0 is a GNU extension'
H3B72AE37DEEE: '已定义的枚举 %0 的重新声明是GNU扩展'
# 'redeclaration of deduction guide'
H6C137FDA5914: '推导指引的重新声明'
# 'redeclaration of method parameter %0'
H0D9F6CE9B2EA: '方法参数 %0 的重复声明'
# 'redeclaration of type parameter %0'
HC29DAC039CAB: '类型参数 %0 的重复声明'
# 'redeclaration of using declaration'
H96E43918A485: 'using声明的重复声明'
# 'redeclaration of using-enum declaration'
H7EA3B309B6C8: 'using-enum声明的重复声明'
# 'redeclaring non-static %0 as static is a Microsoft extension'
H853738CC6C0D: '将非静态 %0 作为静态重新声明是Microsoft扩展'
# 'redefining builtin macro'
H6021415EA4BB: '重定义内建宏'
# 'redefinition of %0'
HB70C986DD184: '%0 的重新定义'
# 'redefinition of %0 as an alias for a different namespace'
H97345A757B2F: '将 %0 重新定义为不同命名空间的别名'
# 'redefinition of %0 as different kind of symbol'
H9380CBD04275: '将 %0 重新定义为不同类型符号'
# 'redefinition of %0 will not be visible outside of this function'
H6605A7137B7E: '%0 的重新定义在函数外部不可见'
# 'redefinition of %0 with a different type%diff{: $ vs $|}1,2'
HB1C0A119B95E: '使用不同的类型 %diff{: $ vs $|}1,2 重新定义 %0'
# 'redefinition of %select{typedef|type alias}0 for variably-modified type %1'
HB599B51A5F4D: '为可变修改类型 %1 重定义 %select{typedef|类型别名}0'
# "redefinition of a 'extern inline' function %0 is not supported in %select{C99 mode|C++}1"
HF158368144B8: "在 %select{C99模式|C++}1 中不支持对 %0 的 'extern inline' 函数的重新定义"
# 'redefinition of concept %0 with different template parameters or requirements'
H4C4283523181: '使用不同的模板参数或要求重新定义概念 %0'
# 'redefinition of default argument'
H6507C3F7227D: '默认参数的重新定义'
# 'redefinition of enumerator %0'
H1EE462BB5E46: '枚举项 %0 的重新定义'
# 'redefinition of forward class %0 of a typedef name of an object type is ignored'
H06040CF8C316: '将对象类型typedef名称的前向类 %0 重新定义被忽略'
# 'redefinition of inferred submodule'
H43BB40E423BF: '推断子模块的重新定义'
# 'redefinition of label %0'
HD4F4A928D72C: '标签 %0 的重新定义'
# 'redefinition of method parameter %0'
HE18AEF27C9A1: '方法参数 %0 的重新定义'
# "redefinition of module '%0'"
H6249FB58D003: "模块 '%0' 的重新定义"
# 'redefinition of parameter %0'
H88BE534E3F7A: '参数 %0 的重新定义'
# 'redefinition of typedef %0 is a C11 feature'
H8B88EC5F6F5C: 'typedef %0 的重新定义是 C11 特性'
# 'redefinition of user-defined mapper for type %0 with name %1'
HADE614C371DA: '类型 %0 具有名称 %1 的用户自定义映射器的重新定义'
# 'redefinition of user-defined reduction for type %0'
H4B307482E8CD: '类型 %0 的用户自定义规约的重新定义'
# 'redirect journaling to a file instead of stdout/stderr'
H5FEA9D013494: '将日志重定向到文件而不是标准输出/标准错误'
# "reduction type cannot be %select{qualified with 'const', 'volatile' or 'restrict'|a function|a reference|an array}0 type"
H2D2C74F27FDF: "规约类型不能是 %select{带有 'const'、'volatile' 或 'restrict' 限定符|函数|引用|数组}0 类型"
# 'reduction variables may not be accessed in an explicit task'
H233496630504: '显式任务中不能访问规约变量'
# "redundant #include of module '%0' appears within %1"
H3B45950DD3A3: "模块 '%0' 的冗余 #include 出现在 %1 内部"
# 'redundant %0 availability change; only the last specified change will be used'
HE2065BD86C26: '冗余的 %0 可用性更改；仅使用最后指定的更改'
# "redundant 'sycl_kernel_entry_point' attribute"
H89B952CF4093: "冗余的 'sycl_kernel_entry_point' 属性"
# "redundant attribute subject matcher sub-rule '%0'; '%1' already matches those declarations"
HE12FF717092C: "冗余的属性主题匹配子规则 '%0'；'%1' 已经匹配这些声明"
# 'redundant move in return statement'
HC34A9F2066D1: '返回语句中的冗余移动'
# 'redundant parentheses surrounding declarator'
H47E8307AF60E: '声明符周围的冗余括号'
# "ref-qualifier '%select{&&|&}0' is not allowed on a constructor"
H5FB2827C1F13: "引用限定符 '%select{&&|&}0' 不允许用于构造函数"
# "ref-qualifier '%select{&&|&}0' is not allowed on a destructor"
H0C7698A4B274: "引用限定符 '%select{&&|&}0' 不允许用于析构函数"
# "ref-qualifier '&&' is not allowed on a defaulted comparison operator"
HE95322EAF78E: "默认的比较运算符不允许使用右值引用限定符 '&&'"
# 'refactoring action cannot be initiated without a selection'
H24ED847BB22A: '在没有选择的情况下无法启动重构操作'
# 'reference %0 is not yet bound to a value when used here'
HF3E8D22129FD: '此处使用的引用 %0 尚未绑定到值'
# 'reference %0 is not yet bound to a value when used within its own initialization'
HB4996BB1A27E: '在自身初始化中使用时，引用 %0 尚未绑定到值'
# 'reference %diff{to %select{type|incomplete type}1 $ could not bind to an %select{rvalue|lvalue}2 of type $|could not bind to %select{rvalue|lvalue}2 of incompatible type}0,3'
HFAC2C332E9F4: '引用 %diff{到 %select{类型|不完整类型}1 $ 无法绑定到 %select{右值|左值}2 类型的 $|无法绑定到类型不兼容的 %select{右值|左值}2}0,3'
# 'reference binding of non-type template parameter %diff{of type $ to template argument of type $|to template argument}0,1 ignores qualifiers'
H093001BBE364: '非类型模板参数 %diff{类型 $ 到模板实参类型 $ 的引用绑定|到模板实参}0,1 忽略了限定符'
# 'reference cannot be bound to dereferenced null pointer in well-defined C++ code; comparison may be assumed to always evaluate to %select{true|false}0'
H136F139EE8E6: '在符合C++标准的代码中，无法将引用绑定到空指针的解引用结果；比较可能被假定始终求值为 %select{true|false}0'
# 'reference cannot be bound to dereferenced null pointer in well-defined C++ code; pointer may be assumed to always convert to true'
H5320A7915E7F: '在符合C++标准的代码中，无法将引用绑定到空指针的解引用结果；该指针可能被假定始终转换为 true'
# 'reference cannot be initialized with multiple values'
HE7DB5FCEC436: '引用无法用多个值初始化'
# 'reference cannot bind to bit-field in converted constant expression'
HF5063530D4A6: '引用无法绑定到已转换常量表达式中的位域'
# 'reference dynamic_cast failed: %select{static type %1 of operand is a non-public base class of dynamic type %2|dynamic type %2 of operand does not have a base class of type %3|%3 is an ambiguous base class of dynamic type %2 of operand|%3 is a non-public base class of dynamic type %2 of operand}0'
H4859449FAD67: '引用 dynamic_cast 失败: %select{操作数的静态类型 %1 是动态类型 %2 的非公开基类|操作数的动态类型 %2 没有类型 %3 的基类|%3 是操作数动态类型 %2 的含混基类|%3 是操作数动态类型 %2 的非公开基类}0'
# 'reference initialization of type %0 with initializer of type %1 is ambiguous'
HB988A3E86777: '类型 %0 的引用初始化与类型 %1 的初始化器存在歧义'
# 'reference initialized from initializer list is incompatible with C++98'
HCD4C182EF998: '用初始化列表初始化的引用与C++98不兼容'
# 'reference member of type %0 uninitialized'
HC2805DCE0AFC: '类型 %0 的引用成员未初始化'
# 'reference of type %0 cannot bind to a temporary object because of address space mismatch'
HF0C3B633C49A: '由于地址空间不匹配，类型 %0 的引用无法绑定到临时对象'
# 'reference qualifiers on functions are a C++11 extension'
H41B9EC19F32B: '函数上的引用限定符是C++11扩展'
# 'reference qualifiers on functions are incompatible with C++98'
HF044E58F9C25: '函数上的引用限定符与C++98不兼容'
# 'reference to %0 is ambiguous'
H97A6825DEB56: '对 %0 的引用存在歧义'
# 'reference to %select{__device__|__global__|__host__|__host__ __device__}0 %select{function|variable}1 %2 in %select{__device__|__global__|__host__|__host__ __device__}3 function'
H43094BC1789F: '在 %select{__device__|__global__|__host__|__host__ __device__}3 函数中引用 %select{__device__|__global__|__host__|__host__ __device__}0 %select{函数|变量}1 %2'
# 'reference to %select{__device__|__global__|__host__|__host__ __device__}0 function %1 in global initializer'
H76762B8F478F: '在全局初始化器中引用 %select{__device__|__global__|__host__|__host__ __device__}0 函数 %1'
# 'reference to %select{destructor|pseudo-destructor}0 must be called%select{|; did you mean to call it with no arguments?}1'
H3484C551C20A: '必须调用 %select{析构函数|伪析构函数}0%select{|；是否需要以无参数形式调用？}1'
# 'reference to %select{overloaded|multiversioned}1 function could not be resolved; did you mean to call it%select{| with no arguments}0?'
HA7DE06C12730: '无法解析对 %select{重载|多版本}1 函数的引用；是否需要 %select{|以无参数形式}0调用它？'
# "reference to a %select{bit-field|vector element|global register variable}0 in asm %select{input|output}1 with a memory constraint '%2'"
HCCFE4F550EEB: "在asm %select{输入|输出}1 约束 '%2' 中引用 %select{位域|向量元素|全局寄存器变量}0"
# "reference to enumeration must use 'enum' not 'enum %select{struct|class}0'"
HDC33545DFD9E: "枚举引用必须使用 'enum' 而非 'enum %select{struct|class}0'"
# 'reference to local %select{variable|binding}1 %0 declared in enclosing %select{%3|block literal|lambda expression|context}2'
H9B72122A433C: '对局部 %select{变量|绑定项}1 %0 的引用，该变量在包含的 %select{%3|块字面量|lambda表达式|上下文}2 中声明'
# "reference to marker '%0' is ambiguous"
HD452BD6D3FB0: "对标记 '%0' 的引用存在歧义"
# 'reference to non-static member function must be called%select{|; did you mean to call it with no arguments?}0'
H472EE5EB17CD: '对非静态成员函数的引用必须调用 %select{|; 是否应以无参数调用？}0'
# 'reference to type %0 cannot bind to an initializer list'
H9194F3CD2BD5: '类型 %0 的引用无法绑定到初始化列表'
# 'reference to type %0 requires an initializer'
HD97076E9024C: '类型 %0 的引用需要初始化'
# 'reference to unresolved using declaration'
H4256A6DE4B09: '未解析的 using 声明引用'
# 'referenced %0 is declared here'
HE1EBB7B8DBAD: '被引用的 %0 在此处声明'
# 'referenced member %0 is declared here'
H8DB9210452D3: '被引用的成员 %0 在此处声明'
# "referring to 'main' within an expression is a Clang extension"
H5EC3F4017EE7: "'main' 在表达式中被引用是 Clang 扩展特性"
# "region cannot be%select{| closely}0 nested inside '%1' region%select{|; perhaps you forget to enclose 'omp %3' directive into a parallel region?|; perhaps you forget to enclose 'omp %3' directive into a for or a parallel for region with 'ordered' clause?|; perhaps you forget to enclose 'omp %3' directive into a target region?|; perhaps you forget to enclose 'omp %3' directive into a teams region?|; perhaps you forget to enclose 'omp %3' directive into a for, simd, for simd, parallel for, or parallel for simd region?}2"
H9F4A9870BA07: "区域不能 %select{|紧密}0 嵌套在 '%1' 区域内 %select{|; 是否忘记将 'omp %3' 指令包含在并行区域中？|; 是否忘记将 'omp %3' 指令包含在带有 'ordered' 子句的 for 或并行 for 区域中？|; 是否忘记将 'omp %3' 指令包含在目标区域中？|; 是否忘记将 'omp %3' 指令包含在 teams 区域中？|; 是否忘记将 'omp %3' 指令包含在 for、simd、for simd、并行 for 或并行 for simd 区域中？}2"
# "register '%0' unsuitable for global register variables on this target"
HAC3AEFE8413B: "寄存器 '%0' 不适用于此目标的全局寄存器变量"
# 'register number should be an integer'
H932EE02D1B8E: '寄存器编号必须是整数'
# 'register pressure factor for the transformations.'
H44776CA40899: '变换的寄存器压力系数。'
# 'register space cannot be specified on global constants'
H7D24E3150A81: '全局常量不能指定寄存器空间'
# 'reimplementation of category %1 for class %0'
H30BD90819E63: '为类 %0 重新实现类别 %1'
# 'reimplementation of class %0'
HD4142B86FCD9: '重新实现类 %0'
# 'reinterpret_cast cannot resolve overloaded function %0 to type %1'
H60D5F589023C: 'reinterpret_cast 无法将重载函数 %0 转换为类型 %1'
# 'reinterpret_cast from %0 to %1 has undefined behavior'
H1A1328A6B1E4: '将 %0 转换为 %1 的 reinterpret_cast 具有未定义行为'
# 'reinterpret_cast of a %0 to %1 needs its address, which is not allowed'
H8633F993884D: '将 %0 转换为 %1 的 reinterpret_cast 需要其地址，但这是不允许的'
# "releasing %0 '%1' that was not held"
HD16686A7FEA7: "释放未持有的 %0 '%1'"
# "releasing %0 '%1' using %select{shared|exclusive}2 access, expected %select{shared|exclusive}3 access"
H2106963D41B0: "使用%select{共享|独占}2访问释放 %0 '%1'，期望使用%select{共享|独占}3访问"
# 'remainder by zero in preprocessor expression'
HE098B5222CAD: '预处理表达式中的除零余数'
# 'remaining %0 candidate%s0 omitted; pass -fshow-overloads=all to show them'
HD0784BB8E50F: '剩余 %0 个候选%s0 被省略；添加 -fshow-overloads=all 参数可显示所有'
# 'remap file source paths <old> to <new> in coverage mapping. If there are multiple options, prefix replacement is applied in reverse order starting from the last one'
HD493DCAA04BC: '在覆盖映射中将源文件路径 <old> 重映射为 <new>。如果有多个选项，替换操作会从最后一个开始，按逆序应用前缀替换'
# 'remap file source paths in debug info, coverage mapping, predefined preprocessor macros and __builtin_FILE(). Implies -ffile-reproducible.'
HD15C7DEA6A6F: '在调试信息、覆盖映射、预定义预处理宏和 __builtin_FILE() 中重映射源文件路径。隐含启用 -ffile-reproducible。'
# 'remap file source paths in predefined preprocessor macros and __builtin_FILE(). Implies -ffile-reproducible.'
H6FA3D7D85AF9: '在预定义预处理宏和 __builtin_FILE() 中重映射源文件路径。隐含启用 -ffile-reproducible。'
# 'remarks_a'
H1F5563CE509E: 'remarks_a'
# 'remarks_b'
H40EB09D856D2: 'remarks_b'
# "remove '_Noreturn'"
H4CD6C2426BE8: '移除 "_Noreturn"'
# "remove 'enum%select{| struct| class}0' to befriend an enum"
H9CF5F9198489: '移除 "enum%select{| struct| class}0" 以与枚举建立友元关系'
# "remove 'u8' prefix to avoid a change of behavior; Clang encodes unprefixed narrow string literals as UTF-8"
H40BFCE51D12C: '移除 "u8" 前缀以避免行为变化；Clang 将无前缀窄字符串字面量编码为 UTF-8'
# 'remove call to max function and unsigned zero argument'
H746EE2CAAC37: '移除对 max 函数的调用和无符号零参数'
# 'remove constant to silence this warning'
H8233E14B9765: '移除常量以消除此警告'
# 'remove double jumps when able'
H144AFE550114: '在可能时移除双重跳转'
# 'remove extraneous parentheses around the comparison to silence this warning'
H7C576B6A85C7: '移除外层比较中的冗余括号以消除此警告'
# 'remove parentheses to declare a variable'
H29AB7F8F0D04: '移除括号以声明变量'
# 'remove parentheses to silence this warning'
HBB1C1AF59745: '移除括号以消除此警告'
# 'remove std::move call here'
H87B3A4171A2A: '移除此处的 std::move 调用'
# "remove the %select{'%1' if its condition|condition if it}0 is always %select{false|true}2"
HE5C66C3841AD: '移除 %select{"%1" 如果其条件|条件如果它}0 始终为 %select{false|true}2'
# "remove the call to '%0' since unsigned values cannot be negative"
H3BE7257796E7: '移除对 "%0" 的调用，因为无符号值无法为负'
# 'remove the kernel-info pass at the end of the full LTO pipeline'
HE9CC6C17C11E: '在完整的LTO管线末尾移除kernel-info pass。'
# 'remove useless conditional branches'
H7F773F483924: '移除无用的条件分支'
# "rename '%0' to ensure it can be found by name"
H730151DC5720: '将 "%0" 重命名为确保可以通过名称找到'
# 'reorder and cluster functions (works only with relocations)'
HB96EDA278BFF: '重新排序和聚类函数（仅与重定位一起使用）'
# 'reorder data sections in place'
HCACEBAE7CFC3: '原地重新排序数据段'
# 'reorder functions randomly'
HA61C4AF88653: '随机重新排序函数'
# 'reorder three way branches'
HF6331B33926D: '重新排序三向分支'
# 'reorder unconditional jump instructions in loops optimization'
H61D641F1F0CA: '在循环优化中重新排序无条件跳转指令'
# "repeated RISC-V 'interrupt' attribute"
HE9564BE7AF0F: '重复的 RISC-V "interrupt" 属性'
# "repeated RISC-V 'interrupt' attribute is here"
H2C65B1A1835B: '重复的 RISC-V "interrupt" 属性在此处'
# 'repeated evaluation of the same literal expression can produce different objects'
H816EF14DCA64: '同一字面量表达式的重复求值可能导致不同对象'
# "replace 'default' with 'delete'"
H6143A5F8A323: '将 "default" 替换为 "delete"'
# "replace expression with '%0' %select{|or use 'xor' instead of '^' }1to silence this warning"
H8BD6D24EAB4A: '将表达式替换为 "%0" %select{|或使用 "xor" 而不是 "^" }1以消除此警告'
# 'replace parentheses with an initializer to declare a variable'
H1CB1AEAC6164: '移除括号并使用初始化器以声明变量'
# "replacement function %0 cannot be declared 'inline'"
H8E774898376D: "替换函数 %0 不能声明为 'inline'"
# 'report accesses through a pointer which has poisoned shadow'
HDB29EEB5BF15: '报告通过具有中毒阴影的指针的访问'
# 'report stats in csv'
H4FBFD3CEA227: '以CSV格式报告统计信息'
# 'report stats in text'
HDFF33DBA8938: '以文本格式报告统计信息'
# "requested 'init_priority' %0 is reserved for internal use"
H2E025E570ED5: "请求的 'init_priority' %0 保留用于内部使用"
# 'requested alignment %0 is not a positive power of two'
H9C01C430B004: '请求的对齐值 %0 不是正的 2 的幂次方'
# 'requested alignment is dependent but declaration is not dependent'
H9D546DA38E42: '请求的对齐依赖于模板参数，但声明本身不依赖于模板参数'
# 'requested alignment is less than minimum alignment of %1 for type %0'
H9E0857E89F1F: '请求的对齐值小于类型 %0 的最小对齐值 %1'
# 'requested alignment is not a power of 2'
HC6B6240D895B: '请求的对齐值不是 2 的幂次方'
# 'requested alignment must be %0 bytes or smaller'
H7B9D334BA24B: '请求的对齐值必须为 %0 字节或更小'
# 'requested alignment must be %0 bytes or smaller; maximum alignment assumed'
HCDB68D900AC4: '请求的对齐值必须为 %0 字节或更小；假设最大对齐'
# 'requested alignment must be %0 or greater'
H097A66E5C9B7: '请求的对齐值必须为 %0 或更大'
# 'requested alignment must be %0 or less for type %1; %2 is invalid'
H6B97FB634040: '类型 %1 的请求对齐值必须为 %0 或更小；%2 无效'
# 'requested alignment must be %0 or smaller'
HEC3786C66ADB: '请求的对齐值必须为 %0 或更小'
# 'requested shift is a vector of type %0 but the first operand is not a vector (%1)'
H149741EFCCA5: '请求的移位是一个类型为 %0 的向量，但第一个操作数不是向量（%1）'
# 'required alignment of type %0 (%1 bytes) is larger than the supported alignment of C++ exception objects on this target (%2 bytes)'
HFFCA5AAB79EE: '类型 %0 的必需对齐值（%1 字节）大于此目标支持的C++异常对象的最大对齐值（%2 字节）'
# "required by %select{'require_constant_initialization' attribute|'constinit' specifier}0 here"
H669C2D015B6E: '由 %select{require_constant_initialization属性|constinit说明符}0在此处要求'
# 'requires clause differs in template redeclaration'
H3C91EEDA34FA: '模板重新声明中的requires子句不同'
# "requires expression in requirement body; did you intend to place it in a nested requirement? (add another 'requires' before the expression)"
H818E1323CB5B: "在要求体中使用requires表达式；是否应将其置于嵌套要求中？（在表达式前添加另一个 'requires'）"
# "reserved locator 'omp_all_memory' cannot be specified more than once"
HBB5542941955: "保留的定位符 'omp_all_memory' 不能指定多次"
# "reserved locator 'omp_all_memory' requires 'out' or 'inout' dependency types"
H98614BF4F5B5: "保留的定位符 'omp_all_memory' 需要依赖类型为 'out' 或 'inout'"
# 'resolve all otherwise unresolved externals to null'
H0D8FB57C5D95: '将所有其他未解析的外部符号解析为null'
# 'resource has implicit register binding'
H2038E0629D14: '资源具有隐式寄存器绑定'
# 'respect alignment requirements provided by input IR'
H3C9B5ECCDE76: '遵守输入IR提供的对齐要求'
# 'restrict requires a pointer or reference'
H044B0871CB3F: 'restrict需要指针或引用'
# 'restrict requires a pointer or reference (%0 is invalid)'
HB4AA3977DC42: 'restrict需要指针或引用（%0 无效）'
# "result argument to %select{overflow builtin|checked integer operation}0 must be a pointer to a non-const integer type %select{|other than plain 'char', 'bool', bit-precise, or an enumeration }0(%1 invalid)"
HD81ECBB4661A: "传给%select{溢出内建函数|有符号整数运算}0的result参数必须是指向非const整数类型的指针 %select{|而不是普通的 'char'、'bool'、精确位数或枚举类型}0（%1 无效）"
# "result of '%0' is %1; did you mean '%2' (%3)?"
H369683737B3D: "'%0' 的结果是 %1；是否是指 '%2' (%3)？"
# "result of '%0' is %1; did you mean '%2'?"
H1B6516041439: "'%0' 的结果是 %1；是否是指 '%2'？"
# "result of '%0' is %1; did you mean exponentiation?"
H6BDF285BA0FF: "'%0' 的结果是 %1；是否是指指数运算？"
# 'result of comparison %select{%3|%1}0 %2 %select{%1|%3}0 is always %4'
H3D76D2CD2831: '%select{%3|%1}0 %2 %select{%1|%3}0 的比较结果始终为 %4'
# 'result of comparison against %select{a string literal|@encode}0 is unspecified (use an explicit string comparison function instead)'
H42F5B6822163: '与%select{字符串字面量|@encode}0 的比较结果未指定（请改用显式字符串比较函数）'
# 'result of comparison of %select{%3|char expression}0 %2 %select{char expression|%3}0 is always %4, since char is interpreted as unsigned'
H2652DE195D69: '比较 %select{%3|字符表达式}0 %2 %select{字符表达式|%3}0 的结果始终为 %4，因为char被视为无符号类型'
# 'result of comparison of %select{%3|unsigned enum expression}0 %2 %select{unsigned enum expression|%3}0 is always %4'
H86DA5A0E3154: '比较 %select{%3|无符号枚举表达式}0 %2 %select{无符号枚举表达式|%3}0 的结果始终为 %4'
# 'result of comparison of %select{%3|unsigned expression}0 %2 %select{unsigned expression|%3}0 is always %4'
HABA37A2C23DF: '比较 %select{%3|无符号表达式}0 %2 %select{无符号表达式|%3}0 的结果始终为 %4'
# 'result of comparison of %select{%4|%1-bit %select{signed|unsigned}2 value}0 %3 %select{%1-bit %select{signed|unsigned}2 value|%4}0 is always %5'
H3E54DBA92461: '比较 %select{%4|%1 位%select{有符号|无符号}2类型值}0 %3 和 %select{%1 位%select{有符号|无符号}2类型值|%4}0 的结果始终为 %5'
# 'result of comparison of %select{constant %0|true|false}1 with %select{expression of type %2|boolean expression}3 is always %4'
H0604EEA5685E: '将%select{常量 %0|true|false}1 与%select{类型 %2 的表达式|布尔表达式}3比较的结果始终为 %4'
# "result of comparison of constant %0 with expression of type 'BOOL' is always %1, as the only well defined values for 'BOOL' are YES and NO"
H641A75823917: "与类型 'BOOL' 的表达式比较的常量 %0 结果始终为 %1，因为 'BOOL' 的唯一定义值是YES和NO"
# "retain'ed block property does not copy the block - use copy attribute instead"
HD7F1D5C5B0F0: "'retain' 的块属性不会复制该块 - 请改用copy属性"
# 'return in the catch of a function try block of a constructor is illegal'
HBC7FDA21A80E: '构造函数的函数try块catch子句中的return语句是非法的'
# "return state set for an unconsumable type '%0'"
H2753EF9C9B3B: "为不可消耗类型 '%0' 设置了返回状态"
# "return statement not allowed in coroutine; did you mean 'co_return'?"
HD15AAC2A320B: "协程中不允许使用return语句；是否应使用 'co_return'？"
# "return type %0 of selected 'operator==' function for rewritten '%1' comparison is not 'bool'"
HC9853B2276CB: "为重写 '%1' 比较的选定 'operator==' 函数，其返回类型 %0 不是 'bool'"
# 'return type cannot be qualified with address space'
H90249355EB7F: '返回类型不能用地址空间修饰'
# 'return type deduction is incompatible with C++ standards before C++14'
HB4A5F5EFADA6: '返回类型推导与C++14之前的C++标准不兼容'
# "return type for defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator must be 'bool', not %1"
H2EF639AB940D: "默认实现的 %select{<ERROR>|相等|三向|相等|关系}0比较运算符的返回类型必须是 'bool' 而非 %1"
# "return type of 'await_ready' is required to be contextually convertible to 'bool'"
H043CECD8EB91: "'await_ready' 的返回类型必须能上下文转换为 'bool'"
# "return type of 'await_suspend' is required to be 'void' or 'bool' (have %0)"
H64AB2C323A61: "'await_suspend' 的返回类型必须是 'void' 或 'bool'（当前为 %0）"
# "return type of 'coroutine_handle<>::address should be 'void*' (have %0) in order to get capability with existing async C API"
HA713CB41D910: "'coroutine_handle<>::address' 的返回类型应为 'void*'（当前为 %0），以便通过现有异步C API获取功能"
# "return type of 'main' is not 'int'"
HFBAC240E8034: "'main' 的返回类型不是 'int'"
# "return type of defaulted 'operator<=>' cannot be deduced because return type %2 of three-way comparison for %select{|member|base class}0 %1 is not a standard comparison category type"
H424FC8A53CC9: "默认的 'operator<=>' 的返回类型无法推导，因为 %select{|member|base class}0 %1 的三向比较返回类型 %2 不是标准比较类别类型"
# "return type of defaulted 'operator<=>' cannot be deduced because three-way comparison for %select{|member|base class}0 %1 has a deduced return type and is not yet defined"
H0105A22E2A8D: "默认的 'operator<=>' 的返回类型无法推导，因为 %select{|member|base class}0 %1 的三向比较具有推导出的返回类型且尚未定义"
# 'return type of out-of-line definition of %q0 differs from that in the declaration'
H469315680A98: '%q0的外部定义的返回类型与声明中的不同'
# 'return type of virtual function %0 is not covariant with the return type of the function it overrides (%1 has different qualifiers than %2)'
H00BA4129869D: '虚函数 %0 的返回类型与它覆盖的函数的返回类型不协变（%1 的限定符与 %2 不同）'
# 'return type of virtual function %0 is not covariant with the return type of the function it overrides (%1 is incomplete)'
HE8582E3BF357: '虚函数 %0 的返回类型与它覆盖的函数的返回类型不协变（%1 是不完全类型）'
# 'return type of virtual function %0 is not covariant with the return type of the function it overrides (%1 is not derived from %2)'
H5A21B37900C4: '虚函数 %0 的返回类型与它覆盖的函数的返回类型不协变（%1 不是 %2 的派生类）'
# 'return type of virtual function %0 is not covariant with the return type of the function it overrides (class type %1 does not have the same cv-qualification as or less cv-qualification than class type %2)'
H2AB9EE663373: '虚函数 %0 的返回类型与它覆盖的函数的返回类型不协变（类类型 %1 的cv限定符资格与类类型 %2 不同或更严格）'
# 'return type of virtual function %3 is not covariant with the return type of the function it overrides (ambiguous conversion from derived class %0 to base class %1:%2)'
H94F1AF985110: '虚函数 %3 的返回类型与它覆盖的函数的返回类型不协变（从派生类 %0 到基类 %1 的转换存在歧义：%2）'
# "return value not in expected state; expected '%0', observed '%1'"
H8EF54209E2EA: "返回值不在期望状态；期望 '%0'，实际观察到 '%1'"
# 'return value of %0 is a large (%1 bytes) pass-by-value object; pass it by reference instead ?'
HA1B074D05D38: '%0 的返回值是一个较大的（%1 字节）按值传递对象；建议改为引用传递？'
# 'returning %select{address of|reference to}0 local temporary object'
H0D9CD7C30605: '返回%select{地址的|引用的}0局部临时对象'
# 'returning address of label, which is local'
H7C6FDC7A79CE: '返回局部标签的地址，该标签是局部作用域内的'
# 'returning block that lives on the local stack'
HFB5C6DCAD180: '返回存活在局部栈上的代码块'
# "returning pointer %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
H524B3D4E5221: "返回指针 %1 需要持有 %0 %select{'%2'|' 排他性 %2'}3"
# "returning pointer to variable %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
HC47B423E80E3: "返回变量 %1 的指针需要持有 %0 %select{'%2'|' 排他性 %2'}3"
# 'returning reference to local temporary object'
H3C7B38DADD40: '返回局部临时对象的引用'
# "returning the value that %1 points to by reference requires holding %0 %select{'%2'|'%2' exclusively}3"
HDFB7294684C5: "通过引用来返回 %1 指向的值需要持有 %0 %select{'%2'|'%2' 独占}3"
# "returning variable %1 by reference requires holding %0 %select{'%2'|'%2' exclusively}3"
H5E5D0E85F387: "通过引用来返回变量 %1 需要持有 %0 %select{'%2'|'%2' 独占}3"
# "rewriter doesn't support user-specified control flow semantics for @try/@finally (code may not execute properly)"
H9C522D3EEF6D: '@try/@finally的用户指定控制流语义rewriter不支持（代码可能无法正确执行）'
# 'rewriting block literal declared in global scope is not implemented'
HC8DC37202696: '全局作用域中声明的块字面量重写未实现'
# 'rewriting sub-expression within a macro (may not be correct)'
H72B7281F7712: '宏内的子表达式重写（可能不准确）'
# 'right hand operand to %0 has non-pointer-to-member type %1'
H53A963FA3084: '%0 的右操作数具有非成员指针类型 %1'
# "right shifting a 'bool' implicitly converts it to 'int'"
HEDBEE20D2831: "隐式右移 'bool' 会将其转换为 'int'"
# 'rocPrim path, required by the HIP Standard Parallel Algorithm Acceleration library, used to implicitly include the rocPrim library'
HD40BA7FFEFEE: 'rocPrim 路径，由 HIP 标准并行算法加速库所需，用于隐式包含 rocPrim 库'
# 'rocThrust path, required by the HIP Standard Parallel Algorithm Acceleration library, used to implicitly include the rocThrust library'
H2F4B1626A7F1: 'rocThrust 路径，由 HIP 标准并行算法加速库所需，用于隐式包含 rocThrust 库'
# 'run retpoline insertion pass'
H57D5B6539CD2: '运行retpoline插入Pass'
# 'run veneer elimination pass'
HC2BE3F62417A: '运行veneer消除Pass'
# "runpath search paths do not match: '%0' (provided) vs '%1' (found)"
H2CB428691FF3: "运行路径搜索路径不匹配：'%0'（提供的）与 '%1'（检测到的）"
# "runpath search paths missing from %0: '%1'"
H427437B03484: "%0 中缺少运行路径搜索路径：'%1'"
# 'rvalue reference %diff{to type $ cannot bind to lvalue of type $|cannot bind to incompatible lvalue}0,1'
H5D62614FC181: '右值引用%diff{到类型$不能绑定到类型$的左值|无法绑定到不兼容的左值}0,1'
# 'rvalue reference type %0 is not allowed in exception specification'
H63B188C37A7C: '异常规范中不允许使用右值引用类型 %0'
# 'rvalue references are a C++11 extension'
HE6F99D294F8D: '右值引用是C++11扩展'
# 'rvalue references are incompatible with C++98'
HBB045EE53C13: '右值引用与C++98不兼容'
# 's'
HA0F1490A20D0: 's'
# 'safe buffers debug: %0'
H6B8774B1FDA7: '安全缓冲区调试：%0'
# 'safety buffer size'
H48F48464759C: '安全缓冲区大小'
# 'same map type modifier has been specified more than once'
HE40C50BE338F: '同一映射类型修饰符被多次指定'
# 'same motion modifier has been specified more than once'
H855EE2722E18: '同一移动修饰符被多次指定'
# 'same pointer dereferenced in multiple different ways in map clause expressions'
H176F03468FDB: '映射子句表达式中同一指针被以不同方式解引用'
# 'sampler initializer has invalid %0 bits'
H18D45D49E7B9: '采样器初始化器具有无效的 %0 位'
# 'sampler type cannot be used with the __local and __global address space qualifiers'
H2695DF30EE8D: '采样器类型不能与__local和__global地址空间限定符一起使用'
# 'sampler_t initialization requires 32-bit integer, not %0'
HB7C873D08ECC: 'sampler_t初始化需要 32 位整数，而非 %0'
# 'sampler_t variable required - got %0'
H54F7785F9F3D: '需要sampler_t变量 - 实际得到 %0'
# 'sanstats Options'
H8526EFD0A943: 'sanstats 选项'
# 'satisfaction of constraint %0 depends on itself'
H172A48B0FE13: '约束 %0 的满足情况依赖于自身'
# 'save recorded profile to a file'
H0DD7B7A894BB: '将记录的配置文件保存到文件中'
# 'scalar initialized from empty initializer list is incompatible with C++98'
H4040E7512491: '标量变量由空初始化列表初始化与C++98不兼容'
# 'scalar initializer cannot be empty'
HD3067EEE76AC: '标量初始化器不能为空'
# 'scalar operand type has greater rank than the type of the vector element. (%0 and %1)'
H2C50DCFF8689: '标量操作数类型比向量元素类型的秩更高. (%0 和 %1)'
# 'scale argument must be 1, 2, 4, or 8'
H325DB8FF3A78: 'scale参数必须为 1、2、4或 8'
# 'scale factor for the latch probability. Value should be greater than 1. Lower values are ignored'
HAACE1BBE5003: 'latch概率的缩放因子。值应大于 1。较小的值将被忽略'
# 'scale of asan shadow mapping'
H538257B2498C: 'ASan阴影映射的缩放比例'
# 'scale of memprof shadow mapping'
H256DA014D3E2: 'MemProf阴影映射的缩放比例'
# 'scale to be applied while reporting dyno stats'
H9327CA23C998: '在报告dyno统计信息时应用的缩放比例'
# 'scoped enumeration requires a name'
H38F857947248: '作用域枚举需要一个名称'
# 'scoped enumerations are a C++11 extension'
H880FA70730D4: '作用域枚举是C++11扩展'
# 'scoped enumerations are incompatible with C++98'
H8FFFE671E01D: '作用域枚举与C++98不兼容'
# 'score expressions in the OpenMP context selector need to be constant; %0 is not and will be ignored'
HBAE673BA4B11: 'OpenMP上下文选择器中的评分表达式需要是常量;%0 不是常量且将被忽略'
# "search path used: '%0'"
H5005F53FE066: "使用的搜索路径为: '%0'"
# "second argument to 'va_arg' is of ARC ownership-qualified type %0"
H5B02CB112F2F: 'va_arg的第二个参数是ARC所有权限定类型 %0'
# "second argument to 'va_arg' is of abstract type %0"
HB0CBA3C6712C: 'va_arg的第二个参数是抽象类型 %0'
# "second argument to 'va_arg' is of array type %0; this va_arg has undefined behavior because arguments will never be compatible with array type"
H0271D72D02D0: 'va_arg的第二个参数是数组类型 %0;此va_arg行为未定义，因为参数永远不会与数组类型兼容'
# "second argument to 'va_arg' is of incomplete type %0"
HBAB6DD203AC7: 'va_arg的第二个参数是不完全类型 %0'
# "second argument to 'va_arg' is of non-POD type %0"
H6E23523199DB: 'va_arg的第二个参数是非POD类型 %0'
# "second argument to 'va_arg' is of promotable type %0; this va_arg has undefined behavior because arguments will be promoted to %1"
HD77AAC429CAF: 'va_arg的第二个参数是可提升类型 %0;此va_arg行为未定义，因为参数将被提升为 %1 类型'
# "second argument to 'va_start' is not the last non-variadic parameter"
H37CA82AB0144: '__builtin_alloca_with_align的第二个参数应以比特为单位'
# 'second argument to __builtin_alloca_with_align is supposed to be in bits'
HF3ADBC91450B: 'va_start的第二个参数不是最后一个非可变参数'
# 'second argument to __builtin_annotation must be a non-wide string constant'
HB28F8D41E677: '__builtin_annotation的第二个参数必须是非宽字符串常量'
# 'second argument to __builtin_call_with_static_chain must be of pointer type'
H9D3B291ADD1F: '__builtin_call_with_static_chain 的第二个参数必须是指针类型'
# "section argument to 'patchable_function_entry' attribute is not valid for this target: %0"
HBEBC9A622C36: "'patchable_function_entry' 属性的section参数对当前目标无效：%0"
# 'section attribute is specified on redeclared variable'
H4BE9B9505588: 'section 属性被指定在重新声明的变量上'
# 'section length is evaluated to a negative value %0'
HDAA24A68E89D: 'section 长度计算为负值 %0'
# 'section length is unspecified and cannot be inferred because subscripted value is %select{not an array|an array of unknown bound}0'
HD324F8149A40: 'section 长度未指定且无法推断，因为下标值为 %select{非数组|未知长度的数组}0'
# 'section of pointer to function type %0'
HDFC73840E7DC: '指向函数类型 %0 的指针的 section'
# 'section of pointer to incomplete type %0'
HFA4996C0EBB1: '指向不完整类型 %0 的指针的 section'
# 'section stride is evaluated to a non-positive value %0'
H2C7B2A05B911: 'section 步长计算为非正数值 %0'
# 'see attribute on parameter here'
HDD0675B1BF06: '查看此处参数上的属性'
# 'seed for randomization'
HD63DCBC599F4: '随机化的种子'
# "selected '%select{begin|end}0' %select{function|template }1%2 with iterator type %3"
H752B6650220E: "选择 '%select{begin|end}0' %select{函数|模板 }1%2，其迭代器类型为 %3"
# "selected 'operator<=>' for %select{|member|base class}0 %1 declared here"
H810A0D73AD55: "为 %select{|成员|基类}0 %1 声明的 'operator<=>' 被选中"
# 'selector element is not a valid lvalue'
H0BFE26B0616A: '选择器元素不是有效的左值'
# 'selector element of type %0 cannot be a constant lvalue expression'
H9F3EFE55FA69: '类型为 %0 的选择器元素不能是常量左值表达式'
# 'selector element type %0 is not a valid object'
HED5168FB3348: '选择器元素类型 %0 不是有效的对象'
# 'semantic annotations must be present for all parameters of an entry function or patch constant function'
H8F1EA44B7AC0: '入口函数或修补常量函数的所有参数都必须包含语义注解'
# 'semicolon before method body is ignored'
H600E31190711: '方法体前的分号被忽略'
# 'semicolon terminating header import declaration cannot be produced by a macro'
HD5CFDD7201E4: '由宏生成的导入声明终止分号无效'
# 'set format in which header info is emitted'
H2BE1FC27A3B2: '设置头文件信息的输出格式'
# 'set the flag that enables filtering header information'
H433BB7B2C953: '设置启用过滤头文件信息的标志'
# 'set the incremental array construction buffer size (default=32)'
H062EDCFEADF9: '设置增量数组构建缓冲区的大小（默认值=32）'
# 'set verbosity level for diagnostic output'
HA7F31A34A582: '设置诊断输出的详细程度'
# 'sets a boolean flag for every edge'
H5B3492ACEF7D: '为每个边设置布尔标志'
# 'setter and getter must both be synthesized, or both be user defined, or the property must be nonatomic'
H13B288111B84: 'setter 和 getter 必须同时自动生成，或同时用户自定义，或者属性必须声明为 nonatomic'
# 'setter cannot be specified for a readonly property'
H0B75386E5DBF: '只读属性不能指定 setter'
# 'setting the floating point evaluation method to `source` on a target without SSE is not supported'
H3CBE26190DE7: '在不支持 SSE 的目标上，将浮点运算方法设置为 `source` 是不支持的'
# 'several methods with selector %0 of mismatched types are found for the @selector expression'
H992F0A773FBB: '为 @selector 表达式找到多个具有不匹配类型的选择器 %0'
# 'share stubs across functions'
H4D76BB47577B: '跨函数共享存根'
# 'shift count %0 >= width of type %1 (%2 bit%s2)'
HF6F9C4B1183E: '位移计数 %0 >= 类型 %1 的宽度 (%2 bit%s2)'
# 'shift count >= width of type'
H64BC6739BC0B: '移位计数大于等于类型的位宽'
# 'shift count is negative'
H49401E14D24E: '移位计数是负数'
# 'shifting a negative signed value is undefined'
H08F0D0D67884: '对负的有符号值进行移位操作是未定义的'
# 'shorten instructions'
H31FAC4015C01: '缩短指令'
# 'show a graph.'
HDBFEE5F65752: '显示图形。'
# 'show execution count of functions in binary 2 as a ratio of the total samples in binary 1 - make sure both profiles have equal collection time and sampling rate for this to make sense'
H7302A3496B1D: '以二进制文件 1 的总采样数为基准，显示二进制文件 2 中函数的执行次数比率——请确保两个配置文件的采集时间和采样率相同，否则此结果可能无意义'
# 'show in text.'
H8201270E0209: '以文本显示。'
# 'show profile density details'
HA588BE6E194B: '显示配置文件密度详细信息'
# 'show section contents after fixups have been applied'
HF6C65D702470: '显示应用修复后的段内容'
# 'signed bit-field %0 needs an extra bit to represent the largest positive enumerators of %1'
HE118008121A9: '有符号位段 %0 需要额外一位来表示枚举类型 %1 的最大正枚举值'
# 'signed bit-field %0 needs an extra bit to represent the largest positive enumerators of preferred type %1'
H16B76E9FE00B: '有符号位段 %0 需要额外一位来表示期望类型 %1 的最大正枚举值'
# 'signed left shift discards bits'
HD469BF80AF3C: '有符号左移会丢弃高位'
# 'signed shift result (%0) requires %1 bits to represent, but %2 only has %3 bits'
HC5B9F5083ED5: '有符号移位结果（%0）需要 %1 位来表示，但类型 %2 只有 %3 位'
# "signed shift result (%0) sets the sign bit of the shift expression's type (%1) and becomes negative"
H95CD10E060D8: '有符号移位结果（%0）设置了移位表达式类型 %1 的符号位并变为负数'
# "signedness of format specifier '%0' is incompatible with '%1'"
H0E3D0B14B46F: "格式说明符 '%0' 的符号性与 '%1' 不兼容"
# 'signing a null pointer will yield a non-null pointer'
H25C3D501EB46: '将空指针进行符号转换会得到非空指针'
# 'silence by adding parentheses to mark code as explicitly dead'
H99754744B060: '通过添加括号将代码标记为显式无效来消除警告'
# 'similar constraint expression here'
HC25A9009F181: '此处存在类似的约束表达式'
# 'similar constraint expressions not considered equivalent; constraint expressions cannot be considered equivalent unless they originate from the same concept'
H671259A4BAC3: '类似的约束表达式不被视为等效；除非源自同一概念，否则约束表达式不被视为等效'
# "similar to '-lite-threshold-pct' but specify threshold using absolute function call count. I.e. limit processing to functions executed at least the specified number of times."
HAE7D7FD96C23: '与 "-lite-threshold-pct" 类似，但使用绝对函数调用次数指定阈值。即仅处理执行次数至少达到指定次数的函数。'
# 'simple ddg dot graph'
H18F32B7E23D9: '简单的DDG DOT图'
# 'simple-rename options'
H99366DD6F3BD: 'simple-rename 选项'
# 'simplify conditional tail calls by removing unnecessary jumps'
H041707E8A1C3: '通过移除不必要的跳转来简化条件尾调用'
# 'simplify loads from read-only sections by replacing the memory operand with the constant found in the corresponding section'
H05E90663FB35: '通过用对应段中的常量替换内存操作数，简化只读段的加载操作'
# "single declaration is expected after 'declare %select{simd|variant}0' directive"
H178440D95E1D: "'declare %select{simd|variant}0' 指令后应跟单一声明"
# 'single subscript expressions are not allowed for matrix values'
H6751A19F6DB9: '矩阵值不允许单一下标表达式'
# 'size argument in %0 call appears to be size of the source; expected the size of the destination'
HA69933A2CC96: '在 %0 调用中的 size 参数看起来是源的大小，应使用目标的大小'
# 'size argument in %0 call is a comparison'
HAC4E42C8E89B: '%0 调用中的 size 参数是一个比较表达式'
# "size argument in 'strncat' call appears to be size of the source"
HBE6DF8480F3A: "'strncat' 调用中的 size 参数看起来是源的大小"
# 'size must be %select{1, 2, or 4|1, 2, 4, 12 or 16}0'
H5666676F632D: '大小必须是 %select{1、2 或 4|1、2、4、12 或 16}'
# "size of '__builtin_bit_cast' source type %0 does not match destination type %1 (%2 vs %3 bytes)"
HE2800B62712B: "'__builtin_bit_cast' 的源类型 %0 的大小与目标类型 %1 不匹配（%2 字节 vs %3 字节）"
# "size of array element of type %0 (%1 bytes) isn't a multiple of its alignment (%2 bytes)"
H64B3D7C6AA54: '类型 %0 的数组元素的大小（%1 字节）不是其对齐值（%2 字节）的倍数'
# 'size of array has non-integer type %0'
HE09F852059B1: '数组的大小具有非整数类型 %0'
# 'size of feature field in .altinstructions'
H2B6C1D1A943E: '.altinstructions段中特征字段的大小'
# "size of register '%0' does not match variable size"
HECA9BDA68860: "寄存器 '%0' 的大小与变量大小不匹配"
# 'sizeof on array function parameter will return size of %0 instead of %1'
HFA0A8C5A6400: '对数组函数参数使用 sizeof 将返回 %0 的大小而非 %1'
# 'sizeof on pointer operation will return size of %0 instead of %1'
H23C83EADD90C: '对指针操作使用 sizeof 将返回 %0 的大小而非 %1'
# 'skip access specifiers'
HB22E60CB51DB: '跳过访问说明符'
# 'skip calling convention'
HA89A2E2093C7: '跳过调用约定'
# 'skip member types'
HE3F86CF4D54B: '跳过成员类型'
# 'skip non-simple functions in reporting'
H7F9F6F20766F: '在报告中跳过非简单函数'
# 'skip perf and read data from a pre-aggregated file format'
H38F758DFB377: '跳过perf数据，从预聚合的文件格式中读取数据'
# 'skip perf event collection by supplying a perf-script output in a textual format'
HD6505A3AF86B: '通过提供perf-script的文本格式输出来跳过性能事件收集'
# 'skip processing of cold functions'
H2FAB1AD4A339: '跳过冷函数的处理'
# 'skip return types'
H3988159D97D2: '跳过返回类型'
# 'skip variable types'
H1C4CB11B7B2B: '跳过变量类型'
# "skipping '%0' because module declaration of '%1' lacks the 'framework' qualifier"
H07A078D1E04E: "跳过 '%0'，因为模块声明 '%1' 缺少 'framework' 限定符"
# 'skipping stray token'
HF5D19BFCA4A8: '跳过孤立的标记'
# 'sort hot data by hot function usage and count'
H35D38C633287: '按热门函数使用情况和计数排序热门数据'
# 'sort hot data by read counts'
HC3E7276E6170: '按读取计数排序热门数据'
# 'sort ordering'
HE318259881C5: '排序顺序'
# 'sort output by this field'
H610F666D308E: '按此字段排序输出'
# 'sort stack allocations'
HB4DFBCC44FE6: '排序堆栈分配'
# 'sorted by all names'
H8915B99CE6ED: '按所有名称排序'
# 'source file is not valid UTF-8'
HDC95C446AFAD: '源文件不是有效的 UTF-8 编码'
# 'source manager location address space usage:'
H7D02F3625956: '源管理器位置地址空间使用情况：'
# 'specialization of member %q0 does not specialize an instantiated member'
H7EB7CDEAD3CD: '成员 %q0 的特化并未特化已实例化的成员'
# 'specified %0 type tag requires a null pointer'
HEFCCEFE3C17F: '指定的 %0 类型标签需要一个空指针'
# "specified the same parameter '%0' multiple times"
HA300C97F904A: "多次指定了相同参数 '%0'"
# 'specifies thread count for the multithreading for updating DWO debug info'
H230218760941: '指定用于更新DWO调试信息的多线程线程数'
# 'specify a target CPU'
H6DAAF9946704: '指定目标CPU'
# 'specify a target triple'
H91E21A4D2F5C: '指定目标三元组'
# 'specify a tune CPU'
H484461AF94A8: '指定优化目标CPU'
# 'specify path of the runtime hugify library'
H05DF4B0878FF: '指定运行时hugify库的路径'
# 'specify path of the runtime instrumentation library'
HC0D79561313D: '指定运行时插桩库的路径'
# 'specify that .altinstructions has padlen field'
H09DED786C540: '指定.altinstructions段包含padlen字段'
# 'specify the target features'
H68C8195F1EB5: '指定目标功能'
# "specifying 'uuid' as an ATL attribute is deprecated; use __declspec instead"
H12B975086F19: "将 'uuid' 作为 ATL 属性指定已弃用；请改用 __declspec"
# 'specifying OpenMP directives with [[]] is an OpenMP 5.1 extension'
H4B0556017370: '使用 [[]] 指定 OpenMP 指令是 OpenMP 5.1 的扩展'
# 'specifying OpenMP directives with [[]] is incompatible with OpenMP standards before OpenMP 5.1'
H8022C700FE36: '使用 [[]] 指定 OpenMP 指令与 OpenMP 5.1 之前的版本标准不兼容'
# 'specifying an identifier within `#pragma pack` is not supported on this target'
H6F2B8F9FE9C4: '在 `#pragma pack` 内指定标识符在此目标上不受支持'
# "specifying both a name and alignment to 'pop' is undefined"
HC71C880E8806: "同时为 'pop' 指定名称和对齐方式是未定义的"
# "specifying character '%0' with a universal character name is incompatible with C standards before C23"
H9E4A97D8B259: "使用通用字符名指定字符 '%0' 与 C23 之前的 C 标准不兼容"
# "specifying character '%0' with a universal character name is incompatible with C++98"
H2678BC1F681E: "使用通用字符名指定字符 '%0' 与 C++98 不兼容"
# "specifying vector types with the 'mode' attribute is deprecated; use the 'vector_size' attribute instead"
H29212F917029: "使用 'mode' 属性指定向量类型已弃用；请改用 'vector_size' 属性"
# 'speculative load hardening does not protect functions with asm goto'
H95EDE5332D8C: '推测性加载强化无法保护带有 asm goto 的函数'
# 'spirv.$TypedPointerType'
HDE833BFC0A0D: 'spirv.类型化指针类型'
# 'split C++ exception handling code'
H77F537E188DE: '拆分C++异常处理代码'
# 'split all basic blocks of each function into fragments such that each fragment contains exactly a single basic block'
H4736D758A4A7: '将每个函数的所有基本块分割为片段，使得每个片段恰好包含一个基本块'
# 'split each function into N fragments at a randomly chosen split points (ignoring any available profiling information)'
H5EA52FAFF0B6: '将每个函数在随机选择的分割点分割成N个片段（忽略任何可用的分析信息）'
# 'split each function into a hot and cold fragment at a randomly chosen split point (ignoring any available profiling information)'
H2575993535E9: '在随机选择的分割点将每个函数分割为一个热门片段和冷门片段（忽略任何可用的分析信息）'
# 'split each function into a hot and cold fragment using profiling information'
H6FB4CEE61F8E: '使用分析信息将每个函数拆分为热和冷碎片'
# 'split each function into a hot, warm, and cold fragment using profiling information'
H39753BA1C3E6: '使用分析信息将每个函数拆分为热、温、冷碎片'
# 'split function only if its main size is reduced by more than given amount of bytes. Default value: 0, i.e. split iff the size is reduced. Note that on some architectures the size can increase after splitting.'
H80577181729E: '仅当函数的主要大小减少超过给定的字节数时才拆分函数。默认值：0，即仅在大小减少时拆分。注意：在某些架构上，拆分后大小可能会增加。'
# 'split functions into fragments'
HE833096B1246: '将函数拆分为片段'
# 'split jump tables section into hot and cold based on function execution frequency'
H593FAF497273: '根据函数执行频率将跳转表节段拆分为热和冷部分'
# 'split-file Options'
HDBFADA679092: 'split-file 选项'
# "stack frame size (%0) exceeds limit (%1) in '%2'"
HCF0AF62F4A65: "栈帧大小（%0）超过限制（%1）在 '%2' 中"
# 'stack nearly exhausted; compilation time may suffer, and crashes due to stack overflow are likely'
HD310C1B31961: '栈几乎耗尽；编译时间可能受到影响，并且可能发生因栈溢出导致的崩溃'
# "standard library implementation of %0 is not supported; %select{member '%2' does not have expected form|member '%2' is missing|the type is not trivially copyable|the type does not have the expected form}1"
H8A51A30A514F: '%0 的标准库实现不被支持；%select{成员 "%2" 不符合期望形式|缺少成员 "%2"|类型非平凡可复制|类型不符合期望形式}1'
# 'standard library not linked and so no interrupt vector table or compiler runtime routines will be linked'
H3B6E22A7AD97: '未链接标准库，因此不会链接中断向量表或编译器运行时例程'
# 'star modifier used outside of function prototype'
HA2B9806ED1A1: '在函数原型之外使用星号修饰符'
# "state of variable '%0' must match at the entry and exit of loop"
H7D285ABC5B72: "变量 '%0' 在循环入口和出口处的状态必须一致"
# "statement after '#pragma omp dispatch' must be a direct call to a target function or an assignment to one"
H172FE1A4272E: "在 '#pragma omp dispatch' 之后的语句必须是直接调用目标函数或将其赋值"
# "statement associated with OpenACC 'atomic%select{| %1}0' directive is invalid"
H42056AC9B64A: "与OpenACC 'atomic%select{| %1}0' 指令关联的语句无效"
# "statement attribute %0 has higher precedence than function attribute '%select{always_inline|flatten|noinline}1'"
H0AF92FCED836: "语句属性 %0 的优先级高于函数属性 '%select{always_inline|flatten|noinline}1'"
# 'statement expression not allowed at file scope'
HB4FE90B7D7C8: '文件作用域内不允许使用语句表达式'
# "statement in 'omp %0' directive must be enclosed into a section region"
H69791FF123D5: "在 'omp %0' 指令中的语句必须包含在section区域中"
# 'statement not allowed in %select{constexpr|consteval}1 %select{function|constructor}0'
HD56C75E5841E: '在 %select{constexpr|consteval}1 %select{函数|构造函数}0中不允许使用该语句'
# 'statement requires expression of integer type (%0 invalid)'
H752828F0ECD0: '该语句需要整型表达式（%0 无效）'
# 'statement requires expression of scalar type (%0 invalid)'
HFBBF3A578FA4: '该语句需要标量类型表达式（%0 无效）'
# 'static %0 runtime is not supported on darwin'
H52FFB37B4DFA: '在Darwin系统上不支持static %0 运行时'
# 'static %select{function|variable}0 %1 is used in an inline function with external linkage'
HBAA29A669BB7: '静态%select{函数|变量}0 %1 被用于具有外部链接的内联函数中'
# 'static and non-static member functions with the same parameter types cannot be overloaded'
H455410FE204F: '具有相同参数类型的静态和非静态成员函数不能重载'
# 'static assertion expression is not an integral constant expression'
H4896ABC370E3: '静态断言表达式不是整型常量表达式'
# "static assertion failed due to requirement '%0'%select{: %2|}1"
H3D43CA56F16F: "静态断言失败，因为要求 '%0'%select{：%2|}1"
# 'static assertion failed%select{: %1|}0'
H4F7EABF6B0DD: '静态断言失败%select{：%1|}0'
# 'static const volatile data member must be initialized out of line'
H407C919E04E8: '具有static const volatile类型的成员数据必须在外部初始化'
# 'static data member %0 already has an initializer'
H6ACB0F956377: '静态数据成员 %0 已经有一个初始化器'
# 'static data member %0 in union is a C++11 extension'
HA330F37BE63B: '联合中的静态数据成员 %0 是C++11扩展'
# 'static data member %0 in union is incompatible with C++98'
HEBF9EACD8366: '联合中的静态数据成员 %0 与C++98标准不兼容'
# 'static data member %0 not allowed in anonymous %select{struct|interface|union|class|enum}1'
HC964FFEFDD87: '不允许在匿名 %select{struct|interface|union|class|enum}1 中的静态数据成员 %0'
# 'static data member %0 not allowed in local %select{struct|interface|union|class|enum}2 %1'
HA56CE2DF143E: '不允许在局部 %select{struct|interface|union|class|enum}2 %1 中的静态数据成员 %0'
# 'static data member definition cannot specify a storage class'
HF3222609AACF: '静态数据成员的定义不能指定存储类别'
# 'static data member of type %0 must be initialized out of line'
H4598A36D5110: '类型为 %0 的静态数据成员必须在外部初始化'
# 'static declaration of %0 follows non-static declaration'
H2C721D0B8C3C: '%0 的静态声明跟随了非静态声明'
# 'static lambdas are a C++23 extension'
H0728106ADDA2: '静态lambda表达式是C++23扩展'
# 'static lambdas are incompatible with C++ standards before C++23'
H81C85F6C724E: '静态lambda表达式与C++23之前的C++标准不兼容'
# 'static member %0 cannot be a bit-field'
HDFCBA261B7FE: '静态成员 %0 不能是位域'
# 'static members cannot be declared in an anonymous %select{struct|union}0'
HF2CC0A1A3C82: '不允许在匿名 %select{struct|union}0 中声明静态成员'
# 'static variable %0 is suspiciously used within its own initialization'
H1CCD7A0167D8: '静态变量 %0 在其自身初始化中被可疑地使用'
# 'static_cast between pointer-to-function and pointer-to-object is a Microsoft extension'
H747267A37B70: '在函数指针和对象指针之间使用static_cast是微软扩展'
# 'std::%0 must be a class template with a single type parameter'
HAA8558BD9D00: 'std::%0 必须是一个具有单一类型参数的类模板'
# "std::coroutine_handle isn't a class template"
H20FD07579F32: 'std::coroutine_handle不是类模板'
# "std::coroutine_handle must have a member named '%0'"
HC01B7EC5D8D7: "std::coroutine_handle必须有一个名为 '%0' 的成员"
# "std::coroutine_traits isn't a class template"
H3D3F8F520E5F: 'std::coroutine_traits不是类模板'
# 'std::nothrow must be a valid variable declaration'
H81985EEDEA6B: 'std::nothrow必须是一个有效的变量声明'
# 'std::nothrow was not found; include <new> before defining a coroutine which uses get_return_object_on_allocation_failure()'
H553185766FEB: '未找到std::nothrow；在定义使用get_return_object_on_allocation_failure()的协程之前，请包含 <new> 头文件'
# "step simple modifier is exclusive and cannot be use with 'val', 'uval' or 'ref' modifier"
H61FE9B0F27A0: "step简单修饰符是互斥的，不能与 'val'、'uval' 或 'ref' 修饰符一起使用"
# 'still within definition of %q0 here'
HE0627D20A1B5: '仍在%q0的定义范围内'
# 'stop processing once we have enough to compare two binaries'
H5E734E25A522: '一旦收集到足够的信息可用于比较两个二进制文件时停止处理'
# 'storage class specified for a member declaration'
HE2F76CA3682F: '成员声明中指定了存储类'
# 'store PCHs in memory'
HAE2E8E366E23: '将PCHs存储在内存中'
# 'store PCHs on disk'
HB5252992D5B4: '将PCHs存储在磁盘上'
# 'strategy used to partition blocks into fragments'
H892362B1790A: '用于将基本块划分为片段的策略'
# 'stress rotate selection in aggressive ppc isel for bit permutations'
HAC5B66207D31: '在激进的PPC指令选择中强制进行旋转选择以处理位排列'
# 'strftime format attribute requires 3rd parameter to be 0'
H48F53118805C: 'strftime格式属性要求第三个参数为 0'
# 'stride must be greater or equal to the number of rows'
H8F8F20EB9F60: 'stride必须大于或等于行数'
# 'string is ill-formed as UTF-8 and will become a null %0 when boxed'
H978281414E51: '该字符串作为UTF-8格式不合法，打包后将成为空 %0'
# "string literal after 'operator' cannot have an encoding prefix"
HE2D46EB90348: "'operator' 之后的字符串字面量不能带有编码前缀"
# 'string literal after \'operator\' must be \'""\''
HB2C541BB7B81: "'operator' 之后的字符串字面量必须是''"
# 'string literal of length %0 exceeds maximum length %1 that %select{C90|ISO C99|C++}2 compilers are required to support'
H446F1FE51F67: '长度为 %0 的字符串字面量超过了 %select{C90|ISO C99|C++}2 编译器必须支持的最大长度 %1'
# 'string literal operator templates are a GNU extension'
HC7C4AAEBD81D: '字符串字面量操作符模板是GNU扩展'
# 'string literal with user-defined suffix cannot be used here'
H0A403620271A: '带有用户定义后缀的字符串字面量不能在此处使用'
# 'string literals that exceed this length will use a hash value as their symbol name'
HA27BA101BC94: '超过此长度的字符串字面量将使用哈希值作为其符号名称'
# 'string to set default kind values'
H7121B365791A: '设置默认类型值的字符串'
# "strip 'repz' prefix from 'repz retq' sequence (on by default)"
H5E0A0D55638D: "从 'repz retq' 序列中剥离 'repz' 前缀（默认启用）"
# 'structured binding declaration in a condition is a C++2c extension'
H7AF1E5D1A2D0: '条件中的结构化绑定声明是C++2c扩展'
# 'structured binding declaration in a condition is incompatible with C++ standards before C++2c'
HD456E18D0B36: '条件中的结构化绑定声明与C++2c之前的C++标准不兼容'
# 'structured binding packs are a C++2c extension '
H041F82FB15BE: '结构化绑定包是C++2c扩展'
# 'structured binding packs are incompatible with C++ standards before C++2c'
HD48DDFF6186B: '结构化绑定包与C++2c之前的C++标准不兼容'
# 'structurize SPIRV'
H886FBF76EA85: '结构化 SPIRV'
# 'style of printing regions'
H063C50F12566: '打印区域的样式'
# 'subcommand'
H146947FFD26E: '子命令'
# 'subexpression not valid in a constant expression'
H9779A11486AE: '子表达式在常量表达式中无效'
# 'submodule %0.%1 not declared in module map'
H1DA53EDBF661: '模块映射中未声明子模块 %0.%1'
# "submodule of top-level module '%0' implicitly imported here"
HDAE6F5126C46: "顶级模块 '%0' 的子模块在此处被隐式导入"
# 'subobject %select{of type |}0%1 is not initialized'
HF2C7BC6C2C0D: '子对象 %select{of type |}0%1 未初始化'
# 'subobject declared here'
H554F161157BC: '子对象在此处声明'
# 'subscript of a pointer to void is a GNU extension'
H3CC7AA95FFD8: '对void类型的指针进行下标操作是GNU扩展'
# 'subscript of pointer to %select{incomplete|sizeless}0 type %1'
H1AFEC4E5E6B6: '对类型%select{不完整|零大小}0的 %1 的指针进行下标操作'
# 'subscript of pointer to function type %0'
H768DEE928692: '对函数类型 %0 的指针进行下标操作'
# 'subscript of svbool_t is not allowed'
H8F54745267C0: 'svbool_t的下标操作不被允许'
# 'subscript requires size of interface %0, which is not constant for this architecture and platform'
H10B94DBD4388: '接口 %0 的大小不是该架构和平台的常量，无法进行下标操作'
# 'subscripted value is not an array or pointer'
HFC1E308C6B30: '下标操作的值不是数组或指针'
# 'subscripted value is not an array, pointer, or vector'
H1F892D50B541: '下标操作的值不是数组、指针或向量'
# 'substitution failure due to access control is incompatible with C++98'
H09899E5F733A: '由于访问控制导致的替换失败与C++98不兼容'
# 'substitution into constraint expression resulted in a non-constant expression'
H0CC3DD33E92E: '约束表达式替换后得到非常量表达式'
# 'subtracted pointers are not elements of the same array'
HBF5BC0994673: '相减的指针不是同一数组的元素'
# 'subtraction of pointers to type %0 of zero size'
HAE88E507C99F: '对大小为零的类型 %0 的指针进行相减'
# 'subtraction of pointers to type %0 of zero size has undefined behavior'
H238100FAEBF4: '对大小为零的类型 %0 的指针进行相减具有未定义行为'
# 'suffix with parentheses to turn this into a function call'
HBA5C36C9B0F9: '使用带括号的后缀将其转换为函数调用'
# 'suggest braces around initialization of subobject'
H122DA545D844: '建议在子对象的初始化周围使用花括号'
# 'sum of call durations'
H97819C630794: '调用持续时间之和'
# "support for '/Yc' and '/Yu' with different filenames not implemented yet; flags ignored"
HC924164CBDE2: "对不同文件名的 '/Yc' 和 '/Yu' 支持尚未实现；忽略该标志"
# "support for '/Yc' with more than one source file not implemented yet; flag ignored"
H7450874B7BA1: "对多个源文件的 '/Yc' 支持尚未实现；忽略该标志"
# 'support for HLSL language version %0 is incomplete, recommend using %1 instead'
H68BB4F93A02C: '对HLSL语言版本 %0 的支持不完整，建议改用 %1'
# "support for linking stdlibs for microcontroller '%0' is not implemented"
H8995E8434A04: "对微控制器 '%0' 的stdlib链接支持尚未实现"
# "support for passing the data section address to the linker for microcontroller '%0' is not implemented"
H870D8231D796: "对微控制器 '%0' 向链接器传递数据段地址的支持尚未实现"
# 'surrounding namespace with visibility attribute ends here'
H4297D0DA8CEA: '带有可见性属性的外围命名空间在此结束'
# 'surrounding namespace with visibility attribute starts here'
HA543A7B12EEA: '带有可见性属性的外围命名空间在此开始'
# 'suspicious concatenation of string literals in an array initialization; did you mean to separate the elements with a comma?'
HE00F78FF32CA: '在数组初始化中可疑地连接字符串字面量；您是否想用逗号分隔元素？'
# 'switch condition has boolean value'
HA563E9019204: 'switch条件具有布尔值'
# 'switch condition has incomplete class type %0'
HD68BA6071310: 'switch条件具有不完整的类类型 %0'
# 'switch condition type %0 requires explicit conversion to %1'
HF719378BC596: 'switch条件类型 %0 需要显式转换为 %1'
# 'switch statement has empty body'
HD379C27E8554: 'switch语句具有空的主体'
# "symbol exported in dynamic library, but marked hidden in declaration '%0'"
H493627372D47: '在动态库中导出的符号在声明“%0”中标记为隐藏'
# 'symbol sort order'
H13E171348CDC: '符号排序顺序'
# 'symbolize function ids from the input log'
HBDC90FB5E310: '从输入日志中符号化解析函数ID'
# 'symbolize functions'
H4B741D643A7C: '符号化解析函数'
# 'synchronization scope argument to atomic operation is invalid'
HE1E237FB50C9: '原子操作的同步作用域参数无效'
# 'synthesized properties %0 and %1 both claim instance variable %2'
H9EA52B48540E: '合成属性 %0 和 %1 均声明实例变量 %2'
# 'synthesized properties %0 and %1 both claim setter %2 - use of this setter will cause unexpected behavior'
HA9255CAB38EC: '合成属性 %0 和 %1 均声明setter%2 — 使用此setter会导致意外行为'
# 'synthesized property %0 must either be named the same as a compatible instance variable or must explicitly name an instance variable'
HC10D22B3B816: '合成属性 %0 必须与兼容的实例变量同名，或者必须显式指定实例变量'
# 'synthesized property with variable size type %0 requires an existing instance variable'
H594CC555D195: '类型 %0 的可变大小合成属性需要已有的实例变量'
# 'synthesized setter %0 for null_resettable property %1 does not handle nil'
H95960177BFF3: 'null_resettable属性 %1 的合成setter%0 无法处理nil'
# 'synthesizing __weak instance variable of type %0, which does not support weak references'
H1E4EBACF7211: '合成类型 %0 的__weak实例变量，而该类型不支持弱引用'
# 'system diff used by change reporters'
HBA4E429740F6: '变更报告程序使用的系统diff'
# 'system dot used by change reporters'
H9A7274B114C8: '变更报告程序使用的系统dot'
# 'tail blocks whose size (in bytes) exceeds the value are never duplicated'
HDC606CA00EBA: '大小（以字节为单位）超过该值的尾块永远不会被复制'
# 'tail blocks with size (in bytes) not exceeding the value are always duplicated'
H2F3A5FED8EF0: '大小（以字节为单位）不超过该值的尾块始终会被复制'
# 'tail call required by %0 attribute here'
H9FB91CA4B73B: '此处 %0 属性要求尾调用'
# 'tail call requires that the return value, all parameters, and any temporaries created by the expression are trivially destructible'
HE303C40B04A3: '尾调用要求返回值、所有参数以及表达式创建的任何临时对象都可简单销毁'
# 'taking address of a capture is not allowed'
H35418F9DEF58: '不允许获取捕获变量的地址'
# 'taking address of function is not allowed'
H4A30B839C6AB: '不允许获取函数的地址'
# 'taking address of non-addressable standard library function'
H3ACD682CFC45: '不允许获取标准库中不可寻址函数的地址'
# 'taking address of non-addressable standard library function is incompatible with C++20'
H888C6C415192: '获取不可取址的标准库函数的地址与C++20不兼容'
# 'taking address of packed member %0 of class or structure %q1 may result in an unaligned pointer value'
HD700C27ED0FC: '获取类或结构体%q1的已压缩成员 %0 的地址可能导致未对齐的指针值'
# 'taking the absolute value of %select{pointer|function|array}0 type %1 is suspicious'
HDEB21F2512CF: '对%select{指针|函数|数组}0类型 %1 取绝对值存在可疑之处'
# 'taking the absolute value of unsigned type %0 has no effect'
H8F6DAEC8BECD: '对无符号类型 %0 取绝对值不会有影响'
# 'taking the address of a destructor'
H7B853F7C78AC: '获取析构函数的地址'
# 'taking the address of a temporary object of type %0'
HD39DC5626A0A: '获取类型 %0 的临时对象的地址'
# 'taking the max of %select{a value and unsigned zero|unsigned zero and a value}0 is always equal to the other value'
H75EF0725015B: '对%select{一个值和无符号零|无符号零和一个值}0取最大值始终等于另一个值'
# 'target %select{constructor|destructor}0 is declared here'
HD59E728E618B: '目标%select{构造函数|析构函数}0在这里声明'
# "target '%0' does not support exception handling; 'catch' block is ignored"
H06DD0F5375FE: "目标 '%0' 不支持异常处理；'catch' 代码块将被忽略"
# "target '%0' does not support exception handling; 'throw' is assumed to be never reached"
H29FDCCFA5847: "目标 '%0' 不支持异常处理；'throw' 将被认为不可达"
# "target '%0' is not a supported OpenMP host target"
H6B6204612E53: "目标 '%0' 不是支持的OpenMP主机目标"
# "target '%0' is unsupported by -fsanitize-kcfi-arity"
HCFEF0540C5A0: "目标 '%0' 不受-fsanitize-kcfi-arity支持"
# 'target construct with nested teams region contains statements outside of the teams construct'
HB05FDB001094: '目标构造中的嵌套团队区域包含位于团队构造外部的语句'
# "target does not support 'protected' visibility; using 'default'"
H9354CE031F68: "目标不支持 'protected' 可见性；使用 'default'"
# 'target exception specification is not superset of source'
H14AD31786EFD: '目标异常规范不是源的超集'
# 'target function %select{is a member of different class%diff{ (expected $ but has $)|}1,2|has different number of parameters (expected %1 but has %2)|has type mismatch at %ordinal3 parameter%diff{ (expected $ but has $)|}1,2|has different return type%diff{ ($ expected but has $)|}1,2}0'
HFEFD6F95E799: '目标函数%select{属于不同类%diff{（期望$ 但实际为$)|}1,2|参数数量不同（期望 %1 但实际为 %2)|第%ordinal3个参数类型不匹配%diff{（期望$ 但实际为$)|}1,2|返回类型不同%diff{（$ 期望但实际为$)|}1,2}0'
# 'target function has calling convention %1 (expected %0)'
HE7D037C49FE5: '目标函数的调用约定为 %1（期望 %0）'
# 'target of using declaration'
HCB1C9C62D72D: 'using声明的目标'
# 'target of using declaration conflicts with declaration already in scope'
H5C1974A3FA23: 'using声明的目标与作用域内已有的声明冲突'
# 'target profile option (-T) is missing'
HD96117F3AEE8: '目标配置文件选项（-T）缺失'
# 'target-attribute based function overloads are not supported by NVCC and will be treated as a function redeclaration:new declaration is %select{__device__|__global__|__host__|__host__ __device__}0 function, old declaration is %select{__device__|__global__|__host__|__host__ __device__}1 function'
H48B3A7876AE7: '基于target-attribute的函数重载不被NVCC支持，将被视为函数重新声明：新声明是 %select{__device__|__global__|__host__|__host__ __device__}0 函数，旧声明是 %select{__device__|__global__|__host__|__host__ __device__}1 函数'
# 'tbd'
H1D9C8AC0B205: 'tbd'
# 'template %0 has no definition and no %select{|viable }1deduction guides for deduction of template arguments'
H39A2D17F6485: '模板 %0 没有定义，也没有 %select{|可行的 }1推导指南来推导模板参数'
# 'template argument / label address difference / what did you expect?'
H4022196FB5B0: '模板参数/标签地址差异/您期望的是什么？'
# 'template argument does not refer to a class or alias template, or template template parameter'
H10B27B45B43C: '模板参数不引用类或别名模板，或模板模板参数'
# 'template argument for non-type template parameter is treated as function type %0'
HF7C463216541: '非类型模板参数的模板参数被解释为函数类型 %0'
# 'template argument for non-type template parameter must be an expression'
HA6F518CB9F6F: '非类型模板参数的模板参数必须是一个表达式'
# 'template argument for template template parameter must be a class template%select{| or type alias template}0'
H4605CB1853A3: '模板模板参数的模板参数必须是一个类模板 %select{|或类型别名模板}0'
# 'template argument for template type parameter must be a type'
H9FFBB255FD4F: '模板类型参数的模板参数必须是一个类型'
# "template argument for template type parameter must be a type; did you forget 'typename'?"
H477EE50BCF4B: "模板类型参数的模板参数必须是一个类型；是否漏掉了 'typename'？"
# "template argument for template type parameter must be a type; omitted 'typename' is a Microsoft extension"
H0CC2569F4810: "模板类型参数的模板参数必须是一个类型；省略 'typename' 是Microsoft扩展"
# 'template argument is the type of an unresolved overloaded function'
H1DDFBAF8CEBB: '模板参数是未解析的重载函数类型'
# 'template argument refers to function template %0, here'
H59E0A4B6EEC0: '模板参数引用函数模板 %0，此处'
# 'template argument uses local type %0'
H8CFAA5F55F9C: '模板参数使用局部类型 %0'
# 'template argument uses unnamed type'
H1A9FF29A8094: '模板参数使用未命名类型'
# 'template declaration from hidden source: %0'
H607A13711E91: '来自隐藏源的模板声明：%0'
# 'template is declared here'
H8B583108C6ED: '模板在此处声明'
# 'template name refers to non-type template %0'
HD8E4D2A7EC89: '模板名称引用非类型模板 %0'
# 'template non-type parameter has a different type %0 in template %select{|template parameter }1redeclaration'
H29D49A380D2B: '模板 %select{|模板参数 }1重新声明中，模板非类型参数具有不同类型 %0'
# 'template non-type parameter has a different type %0 in template argument'
H83C8844C296B: '模板参数中的非类型参数具有不同类型 %0'
# "template parameter '%0' is already documented"
H4188A9C61053: "模板参数 '%0' 已被文档记录"
# "template parameter '%0' not found in the template declaration"
H1A80B68DAC8D: "模板参数 '%0' 未在模板声明中找到"
# 'template parameter declared here'
HC6CFA91EE1C1: '模板参数在此处声明'
# 'template parameter default argument is inconsistent with previous definition'
H6440E4D1834B: '模板参数默认参数与之前的定义不一致'
# 'template parameter from hidden source: %0'
HE652270F3F6D: '来自隐藏源的模板参数：%0'
# 'template parameter has a different kind in template %select{|template parameter }0redeclaration'
HBF82CEEA37C8: '模板参数在模板 %select{|模板参数 }0重新声明中的类型不同'
# 'template parameter has a different kind in template argument'
H8F8F50E907A1: '模板参数在模板实参中的类型不同'
# 'template parameter has different kinds in different translation units'
H8BA5D6787AFF: '模板参数在不同翻译单元中的类型不同'
# 'template parameter is declared here'
H6B3C8DC0FA6A: '模板参数在此处声明'
# 'template parameter is used in default argument declared here'
HF0F9ED98885D: '模板参数在此处声明的默认参数中使用'
# 'template parameter list also declared here'
H1F8E29374B19: '模板参数列表也在此处声明'
# "template parameter list for literal operator must be either 'char...' or 'typename T, T...'"
H409CCC2DB745: "字面量运算符的模板参数列表必须为 'char...' 或 'typename T, T...'"
# "template parameter list matching the non-templated nested type %0 should be empty ('template<>')"
HE4D93F6B6699: "与非模板嵌套类型 %0 匹配的模板参数列表应为空 ('template<>)'"
# 'template parameter lists have a different number of parameters (%0 vs %1)'
HB5785F1417CF: '模板参数列表的参数数量不同（%0 对比 %1）'
# 'template parameter missing a default argument'
H5BFE290A5AC0: '模板参数缺少默认参数'
# "template parameter of a function template with the 'sycl_kernel' attribute cannot be a non-type template parameter"
H7625BE567F07: "带有 'sycl_kernel' 属性的函数模板的模板参数不能是非类型模板参数"
# 'template parameter pack cannot have a default argument'
HD1F9E9063EB7: '模板参数包不能具有默认参数'
# 'template parameter pack must be the last template parameter'
HD5749F5C7756: '模板参数包必须是最后一个模板参数'
# 'template parameter redefines default argument'
H8C66CF577C62: '模板参数重新定义了默认参数'
# 'template specialization declaration cannot be a friend'
HA8ECAC04AF8C: '模板特化声明不能是友元'
# 'template specialization or definition requires a template parameter list corresponding to the nested type %0'
HC868EA3957FF: '模板特化或定义需要与嵌套类型 %0 对应的模板参数列表'
# "template specialization requires 'template<>'"
H1ADEE7A736DF: "模板特化需要使用 'template<>'"
# 'template template argument %0 is more constrained than template template parameter %1'
HE3F8D9BFA908: '模板模板实参 %0 比模板模板参数 %1 更具约束性'
# 'template template argument has different template parameters than its corresponding template template parameter'
HB7542BD3C1FF: '模板模板实参的模板参数与其对应的模板模板参数不同'
# 'template template parameter must have its own template parameters'
H2E8B286B021F: '模板模板参数必须有自己的模板参数'
# "template template parameter requires 'class'%select{| or 'typename'}0 after the parameter list"
HC7B5002008B5: "模板模板参数在参数列表后需要 'class'%select{|或 'typename'}0"
# "template template parameter using 'typename' is a C++17 extension"
HD13D228AA386: "使用 'typename' 的模板模板参数是C++17的扩展"
# "template template parameter using 'typename' is incompatible with C++ standards before C++17"
H2724DAD0662B: "使用 'typename' 的模板模板参数与C++17之前的C++标准不兼容"
# 'templates can only be declared in namespace or class scope'
H549BBF1A776B: '模板只能在命名空间或类作用域中声明'
# 'templates cannot be declared inside of a local class'
H9817A58D9951: '模板不能在局部类内部声明'
# 'templates must have C++ linkage'
H7DA4A8DB6A41: '模板必须具有C++链接性'
# 'temporary bound to reference member of allocated object will be destroyed at the end of the full-expression'
H013054578BC3: '与分配对象的引用成员绑定的临时对象将在完整表达式结束时被销毁'
# 'temporary created here'
H6CF924D32FF7: '临时对象在此处创建'
# 'temporary of type %0 has %select{private|protected}1 destructor'
HA776568AF253: '类型为 %0 的临时对象具有%select{私有|受保护}1的析构函数'
# 'tentative array definition assumed to have one element'
H1578DBDB8944: '暂定数组定义假定有一个元素'
# 'tentative definition has type %0 that is never completed'
H2533423DBC92: '暂定定义具有未完成的类型 %0'
# 'tentative definition of variable with internal linkage has incomplete %select{non-array|array}0 type %1'
H23883C0A0522: '具有内部链接性的变量的暂定定义具有不完整%select{非数组|数组}0类型 %1'
# 'tenths of percents of main entry frequency to use as a threshold when evaluating whether a basic block is cold (0 means it is only considered cold if the block has zero samples). Default: 0 '
HB4A505AFFDA6: '在求值基本块是否为冷块时，用作阈值的百分比十分之一。0 表示仅当块的采样数为零时才视为冷块。默认值：0'
# "test module file extension '%0' has different version (%1.%2) than expected (%3.%4)"
HD419260C8BE7: "测试模块文件扩展名 '%0' 的版本(%1.%2)与期望版本(%3.%4)不匹配"
# 'the #__include_macros directive is only for internal use by -imacros'
H1FBDC6FD510E: '#__include_macros 指令仅用于 -imacros 的内部使用'
# 'the %0 sub-architecture does not support unaligned accesses'
H8EEF78B6F581: '%0 子架构不支持非对齐访问'
# 'the %0 type cannot be used to declare a program scope variable'
HCC2A02E45E01: '类型 %0 不能用于声明程序作用域变量'
# 'the %0 type cannot be used to declare a structure or union field'
H3AA824360E4A: '类型 %0 不能用于声明结构体或联合体的字段'
# 'the %select{1st|2nd|3rd}1 template parameter of %0 needs to be %select{a type|an integer or enum value}2'
HC15D25E5BA46: '模板 %0 的第 %select{1位|2位|3位}1个模板参数需要是%select{一个类型|一个整数或枚举值}2'
# 'the %select{function or variable|function}0 specified in an %select{alias|ifunc}1 must refer to its mangled name'
H2A963C3F164E: '在%select{别名|ifunc}1 中指定的%select{函数或变量|函数}0必须引用其mangled名称'
# "the %select{message|string}0 object in %select{this static assertion|this asm operand}0 is missing %select{a 'size()' member function|a 'data()' member function|'data()' and 'size()' member functions}1"
HF8EFF7FCD3A1: "在%select{此静态断言|此asm操作数}0中的%select{消息|string}0 对象缺少 %select{'size()' 成员函数|'data()' 成员函数|'data()' 和 'size()' 成员函数}1"
# "the '%0' unit is not supported with this instruction set"
H66612647AED8: "单元 '%0' 不受当前指令集支持"
# "the '%select{&|*|->}0' operator is unsupported in HLSL"
H831B25ED6E8C: "操作符 '%select{&|*|->}0' 在HLSL中不受支持"
# "the '[[_Noreturn]]' attribute spelling is deprecated in C23; use '[[noreturn]]' instead"
H584C1C164ECE: "在C23中，'[[Noreturn]]' 属性拼写已弃用；请改用 '[[noreturn]]'"
# "the 'copyprivate' clause must not be used with the 'nowait' clause"
H026F61D558F6: "'copyprivate' 子句不能与 'nowait' 子句一起使用"
# "the 'static' modifier for the array size is not legal in new expressions"
H285525BB6E11: "在new表达式中，不允许使用 'static' 修饰符来指定数组大小"
# "the ApplicationExtensionSafe flag does not match: '%0' (provided) vs '%1' (found)"
H74ECAC68920E: "ApplicationExtensionSafe标志不匹配：提供的 '%0' 与找到的 '%1'"
# 'the GNU address of label extension is not allowed in coroutines'
HEE9FFF3C021C: '协程中不允许使用GNU的标签地址扩展'
# "the NotForDyldSharedCache flag does not match: '%0' (provided) vs '%1' (found)"
HAD9256F7D2F3: "NotForDyldSharedCache标志不匹配：提供的 '%0' 与找到的 '%1'"
# 'the __block storage type is not permitted'
H2951C6144658: '__block存储类型不允许使用'
# 'the address of a declaration with unknown type can only be cast to a pointer type'
H6D4B76B01E9C: '未知类型的声明的地址只能转换为指针类型'
# "the argument '%0' is not supported for option '%1'. Mapping to '%1%2'"
HA4EFCA49DC99: "选项 '%1' 不支持参数 '%0'。映射到 '%1%2'"
# 'the argument to vk::Literal must be a vk::integral_constant'
HAA2FE1B1AE05: 'vk::Literal 的参数必须为 vk::integral_constant'
# "the clang compiler does not support '%0'"
HCB0DF6FD34A3: "clang编译器不支持 '%0'"
# "the clang compiler does not support '%0' for C++ on Darwin/i386"
HAB9E0C38E134: "clang编译器在Darwin/i386的C++中不支持 '%0'"
# "the clang compiler does not support '%0', %1"
H70791B1776AF: "clang编译器不支持 '%0'，%1"
# 'the clang compiler does not support -pg option on %select{Darwin|versions of OS X 10.9 and later}0'
HEC221F97986E: 'clang编译器在 %select{Darwin|OS X 10.9及更高版本}0上不支持-pg选项'
# 'the clustering algorithm to use'
HEE034B797939: '要使用的聚类算法'
# "the combination of '%0' and '%1' is incompatible"
H04D1D2EB3A72: "'%0' 和 '%1' 的组合不兼容"
# "the context %select{set|selector|property}0 '%1' was used already in the same 'omp declare variant' directive; %select{set|selector|property}0 ignored"
H6268D8504255: "在同一个 'omp declare variant' 指令中已经使用了上下文 %select{set|selector|property}0 '%1'；忽略该 %select{set|selector|property}0"
# "the context property '%0' can be nested in the context selector '%1' which is nested in the context set '%2'; try 'match(%2={%1(%0)})'"
HAA758F7206BE: "上下文属性 '%0' 可以嵌套在上下文选择器 '%1' 中，而该选择器又嵌套在上下文集 '%2' 中；尝试使用 'match(%2={%1(%0)})'"
# "the context property '%0' is not valid for the context selector '%1' and the context set '%2'; property ignored"
H88A5B848CED9: "上下文属性 '%0' 对于上下文选择器 '%1' 和上下文集 '%2' 无效；忽略该属性"
# "the context selector '%0' can be nested in the context set '%1'; try 'match(%1={%0%select{|(property)}2})'"
HDD6FFFA1FE6E: "上下文选择器 '%0' 可以嵌套在上下文集 '%1' 中；尝试使用 'match(%1={%0%select{|(property)}2})'"
# "the context selector '%0' in context set '%1' requires a context property defined in parentheses; selector ignored"
H4359A48C4F70: "上下文集 '%1' 中的上下文选择器 '%0' 需要在括号中定义上下文属性；忽略该选择器"
# "the context selector '%0' in the context set '%1' cannot have a score (%quoted2); score ignored"
H3FAFFF7C5EF8: "上下文集合 '%1' 中的上下文选择器 '%0' 不能带有分数(%quoted2)；分数被忽略"
# "the context selector '%0' is not valid for the context set '%1'; selector ignored"
HDF7A50F1E9D4: "上下文集 '%1' 中的上下文选择器 '%0' 无效；忽略该选择器"
# "the coroutine promise type %0 declares both 'return_value' and 'return_void'"
H089B386C28E8: "协程承诺类型 %0 同时声明了 'return_value' 和 'return_void'"
# 'the current #pragma pack alignment value is modified in the included file'
H1259B6694648: '包含的文件修改了当前 #pragma pack 对齐值'
# 'the event_t type can only be used with __private address space qualifier'
HF7753CC750DA: 'event_t 类型只能与 __private 地址空间限定符一起使用'
# 'the experimental clang interpreter failed to evaluate an expression'
H0E50C442ED03: '实验性的 clang 解释器无法求值表达式'
# 'the explicit object parameter cannot be a function parameter pack'
HAC332D9FE6A2: '显式对象参数不能是函数参数包'
# 'the explicit object parameter cannot have a default argument'
HEF646D36FD87: '显式对象参数不能有默认参数'
# "the expression 'co_await __promise.final_suspend()' is required to be non-throwing"
HBE8E0E1AD063: "表达式 'co_await __promise.final_suspend()' 需要为不抛出类型"
# "the flag '%0' has been deprecated and will be ignored"
H97F3754670BE: "标志 '%0' 已弃用并将被忽略"
# "the form '-fmodule-file=<BMI-path>' is deprecated for standard C++ named modules; consider to use '-fmodule-file=<module-name>=<BMI-path>' instead"
H9E11832D49AD: "形式 '-fmodule-file=<BMI-path>' 对标准 C++ 命名模块已弃用；建议改用 '-fmodule-file=<module-name>=<BMI-path>'"
# "the given MCU does not support hardware multiply, but '-mhwmult' is set to %0"
HBC73BCBB2AD5: "所指定的 MCU 不支持硬件乘法，但 '-mhwmult' 设置为 %0"
# "the given MCU supports %0 hardware multiply, but '-mhwmult' is set to %1"
H33683D593A85: "所指定的 MCU 支持 %0 硬件乘法，但 '-mhwmult' 设置为 %1"
# 'the host cannot update a declare target variable that is not externally visible'
H626F4DD8E816: '主机无法更新不可外部访问的 declare target 变量'
# 'the ignored %select{set|selector|property}0 spans until here'
H78F2F2873540: '被忽略的 %select{set|selector|property}0 延伸到这里'
# 'the ignored tokens spans until here'
HE724FD8D9E24: '被忽略的标记一直延续到此处'
# 'the implementation of header units is in an experimental phase'
H822B183C153E: '头单元的实现尚处于实验阶段'
# "the implicit output of reduced BMI may be overrided by the output file specified by '--precompile'. please consider use '-fmodule-output=' to specify the output file for reduced BMI explicitly"
HC77BA90C9A9E: "简化的BMI的隐式输出可能被 '--precompile' 指定的输出文件覆盖。建议使用 '-fmodule-output=' 显式指定简化的BMI的输出文件"
# "the inscan reduction list item must appear as a list item in an 'inclusive' or 'exclusive' clause on an inner 'omp scan' directive"
H5A6903CB5B88: "inscan缩减列表项必须出现在内部 'omp scan' 指令的 'inclusive' 或 'exclusive' 子句的列表项中"
# "the last '/TC' or '/TP' option takes precedence over earlier instances"
H1D4C07143ED6: "最后一个 '/TC' 或 '/TP' 选项覆盖前面的实例"
# "the library '%0=%1' is not supported, OpenMP will not be enabled"
H8332E220148A: "库 '%0=%1' 不受支持，OpenMP将不会启用"
# "the list item must appear in 'reduction' clause with the 'inscan' modifier of the parent directive"
H331559E5A96C: "列表项必须出现在父指令的 'reduction' 子句中带有 'inscan' 修饰符的位置"
# 'the loop %select{initializer|condition}0 expression depends on the current loop control variable'
H092C392BA41E: '循环 %select{initializer|condition}0 表达式依赖于当前循环控制变量'
# 'the maximum number of instructions analyzed for may throw during attribute inference in inlined body'
HDB567B6559C9: '在内联体的属性推断期间，对may throw进行分析时要分析的最大指令数'
# 'the mode to run'
H1067F4A3FF41: '要运行的模式'
# 'the name of the PDB file to write'
H3B634F1D4C6F: '要写入的PDB文件的名称'
# "the name of the construct must be specified in presence of 'hint' clause"
HF664729B6FC3: "在存在 'hint' 子句的情况下，必须指定构造名称"
# 'the number of preprocessor source tokens (%0) exceeds this token limit (%1)'
H205DE1F2F79F: '预处理器源标记的数量（%0）超过此限制（%1）'
# 'the object size sanitizer has no effect at -O0, but is explicitly enabled: %0'
H314C428C1C64: '对象大小检查器在-O0时无效，但被显式启用：%0'
# "the option '-flto=thin' is a work in progress"
H5F57C367214A: "选项 '-flto=thin' 尚在开发中"
# "the other acquisition of %0 '%1' is here"
HF9475FC44959: "另一个对 %0 '%1' 的获取在此处"
# 'the parameter for an explicitly-defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 may not be volatile'
HEAA7EB9FB2E0: '显式默认的%select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}0的参数不能是volatile类型'
# 'the parameter for an explicitly-defaulted copy assignment operator must be an lvalue reference type'
H7CAB648A4737: '显式默认的拷贝赋值运算符的参数必须是左值引用类型'
# 'the parameter for an explicitly-defaulted move %select{constructor|assignment operator}0 may not be const'
H34E3C1F201FC: '显式默认的移动%select{构造函数|赋值运算符}0的参数不能是const类型'
# 'the parameter for this explicitly-defaulted copy %select{constructor|assignment operator}0 is const, but a member or base requires it to be non-const'
H7307965D0004: '此显式默认的拷贝%select{构造函数|赋值运算符}0的参数是const，但某个成员或基类要求其为非const'
# "the parameter of the 'ordered' clause must be greater than or equal to the parameter of the 'collapse' clause"
H21ACD6E7D4C2: "'ordered' 子句的参数必须大于或等于 'collapse' 子句的参数"
# 'the pointee of the 2nd argument must match the element type of the 1st argument (%0 != %1)'
H13AC040EDF7B: '第二个参数的被指类型必须与第一个参数的元素类型一致（%0 != %1）'
# 'the pointer decremented by %0 refers before the beginning of the array'
H9FD5D86B7BD7: '减去 %0 后的指针指向数组的起始位置之前'
# 'the pointer incremented by %0 refers past the end of the array (that has type %1)'
H2098AEB20194: '指针增加 %0 后指向的地址超出了类型为 %1 的数组末尾'
# 'the pointer incremented by %0 refers past the last possible element for an array in %1-bit address space containing %2-bit (%3-byte) elements (max possible %4 element%s5)'
H85FE07542C80: '在 %1 位地址空间中，包含 %2 位（%3 字节）元素的数组的最后一个元素后，指针增加 %0 的结果越界（最大可能元素数 %4 element%s5）'
# "the previous context %select{set|selector|property}0 '%1' used here"
H995F32331A92: "之前使用的上下文%select{设置|选择器|属性}0 '%1' 在此处"
# 'the provided selection does not overlap with the AST nodes of interest'
H10756E8D2178: '提供的选择与感兴趣的AST节点没有重叠'
# 'the referenced item is not found in any private clause on the same directive'
HBDA357C86E91: '在同一个指令中的任何私有子句中都未找到引用项'
# "the result of a delegate init call must be immediately returned or assigned to 'self'"
HA6A6824B2746: "委托初始化调用的结果必须立即返回或赋值给 'self'"
# 'the resulting value is always non-negative after implicit conversion'
H9908ECBF3885: '隐式转换后的结果始终为非负值'
# "the second argument of '-fpatchable-function-entry' must be smaller than the first argument"
HEC0EC1D581E8: "参数 '-fpatchable-function-entry' 的第二个参数必须小于第一个参数"
# "the selected code is not a part of a function's / method's body"
H09129ED39DF9: '所选代码不属于某个函数/方法的主体部分'
# 'the selected expression cannot be extracted'
HC3B7DF91CF84: '无法提取所选表达式'
# 'the selected expression is too simple to extract'
HEFB1186DBBA0: '所选表达式过于简单无法提取'
# 'the semantics of this intrinsic changed with GCC version 4.4 - the newer semantics are provided here'
H1D55F6813757: '该内建函数的语义在GCC版本 4.4后有所变化 - 这里提供的是新版本的语义'
# 'the sign of a  flushed-to-zero number is preserved in the sign of 0'
HE7436E3F21CE: '被冲刷到零的数的符号保留在 0 的符号中'
# 'the specified comparator type does not provide a viable const call operator'
H327A107A2A90: '指定的比较器类型未提供有效的const调用运算符'
# 'the specified hash functor does not provide a viable const call operator'
H7B4F603F77A3: '指定的哈希函数对象未提供有效的const调用运算符'
# "the statement for '#pragma omp %0' must be a compound statement"
H8597FC2B3D8A: "'#pragma omp %0' 的语句必须是复合语句"
# "the statement for 'atomic capture' must be a compound statement of form '{v = x; x binop= expr;}', '{x binop= expr; v = x;}', '{v = x; x = x binop expr;}', '{v = x; x = expr binop x;}', '{x = x binop expr; v = x;}', '{x = expr binop x; v = x;}' or '{v = x; x = expr;}', '{v = x; x++;}', '{v = x; ++x;}', '{++x; v = x;}', '{x++; v = x;}', '{v = x; x--;}', '{v = x; --x;}', '{--x; v = x;}', '{x--; v = x;}' where x is an lvalue expression with scalar type"
H0E1E5BD56218: "'atomic capture' 的语句必须是以下形式的复合语句：'{v = x; x binop= expr;}'、'{x binop= expr; v = x;}'、'{v = x; x = x binop expr;}'、'{v = x; x = expr binop x;}'、'{x = x binop expr; v = x;}'、'{x = expr binop x; v = x;}' 或 '{v = x; x = expr;}'、'{v = x; x++;}'、'{v = x; ++x;}'、'{++x; v = x;}'、'{x++; v = x;}'、'{v = x; x--;}'、'{v = x; --x;}'、'{--x; v = x;}'、'{x--; v = x;}'，其中 x 是标量类型左值表达式"
# "the statement for 'atomic capture' must be an expression statement of form 'v = ++x;', 'v = --x;', 'v = x++;', 'v = x--;', 'v = x binop= expr;', 'v = x = x binop expr' or 'v = x = expr binop x', where x and v are both lvalue expressions with scalar type"
H47D428195CE9: "'atomic capture' 的语句必须是以下形式的表达式语句：'v = ++x;'、'v = --x;'、'v = x++;'、'v = x--;'、'v = x binop= expr;'、'v = x = x binop expr' 或 'v = x = expr binop x'，其中 x 和 v 均为标量类型左值表达式"
# "the statement for 'atomic compare capture' must be a compound statement of form '{v = x; cond-up-stmt}', ''{cond-up-stmt v = x;}', '{if(x == e) {x = d;} else {v = x;}}', '{r = x == e; if(r) {x = d;}}', or '{r = x == e; if(r) {x = d;} else {v = x;}}', where 'cond-update-stmt' can have one of the following forms: 'if(expr ordop x) {x = expr;}', 'if(x ordop expr) {x = expr;}', 'if(x == e) {x = d;}', or 'if(e == x) {x = d;}' where 'x', 'r', and 'v' are lvalue expressions with scalar type, 'expr', 'e', and 'd' are expressions with scalar type, and 'ordop' is one of '<' or '>'"
H09C6A6DB560B: "'atomic compare capture' 的语句必须是以下形式的复合语句：'{v = x; cond-up-stmt}'、'{cond-up-stmt v = x;}'、'{if(x == e) {x = d;} else {v = x;}}'、'{r = x == e; if(r) {x = d;}}' 或 '{r = x == e; if(r) {x = d;} else {v = x;}}'，其中 'cond-update-stmt' 可以是以下形式之一：'if(expr ordop x) {x = expr;}'、'if(x ordop expr) {x = expr;}'、'if(x == e) {x = d;}' 或 'if(e == x) {x = d;}'，其中 'x'、'r'、'v' 是标量类型左值表达式，'expr'、'e'、'd' 是标量类型表达式，'ordop' 是 '<' 或 '>' 中的一个"
# "the statement for 'atomic compare' must be a compound statement of form '{x = expr ordop x ? expr : x;}', '{x = x ordop expr? expr : x;}', '{x = x == e ? d : x;}', '{x = e == x ? d : x;}', or 'if(expr ordop x) {x = expr;}', 'if(x ordop expr) {x = expr;}', 'if(x == e) {x = d;}', 'if(e == x) {x = d;}' where 'x' is an lvalue expression with scalar type, 'expr', 'e', and 'd' are expressions with scalar type, and 'ordop' is one of '<' or '>'"
H4091D9BED6D2: "'atomic compare' 的语句必须是以下形式的复合语句：'{x = expr ordop x ? expr : x;}'、'{x = x ordop expr ? expr : x;}'、'{x = x == e ? d : x;}'、'{x = e == x ? d : x;}' 或 'if(expr ordop x) {x = expr;}'、'if(x ordop expr) {x = expr;}'、'if(x == e) {x = d;}'、'if(e == x) {x = d;}'，其中 'x' 是标量类型左值表达式，'expr'、'e'、'd' 是标量类型表达式，'ordop' 是 '<' 或 '>' 中的一个"
# "the statement for 'atomic read' must be an expression statement of form 'v = x;', where v and x are both lvalue expressions with scalar type"
HDAD21CA5AD66: "'atomic update' 的语句必须是形式为 '++x;' 等的表达式语句"
# "the statement for 'atomic update' must be an expression statement of form '++x;', '--x;', 'x++;', 'x--;', 'x binop= expr;', 'x = x binop expr' or 'x = expr binop x', where x is an lvalue expression with scalar type"
H106E8810ABCE: "'atomic write' 的语句必须是形式为 'x = expr;' 的表达式语句"
# "the statement for 'atomic write' must be an expression statement of form 'x = expr;', where x is a lvalue expression with scalar type"
HAEE051C701D8: "用于 'atomic write' 的语句必须是形式为 'x = expr;' 的表达式语句，其中x是标量类型的左值表达式"
# "the statement for 'atomic' must be an expression statement of form '++x;', '--x;', 'x++;', 'x--;', 'x binop= expr;', 'x = x binop expr' or 'x = expr binop x', where x is an lvalue expression with scalar type"
H182C909CFBBD: "用于 'atomic' 的语句必须是形式为 '++x;'、'--x;'、'x++;'、'x--;'、'x binop= expr;'、'x = x binop expr' 或 'x = expr binop x' 的表达式语句，其中x是标量类型的左值表达式"
# "the target architecture '%0' is not supported by the target '%1'"
H9EB5284C09D2: "目标架构 '%0' 不受目标 '%1' 支持"
# 'the total number of preprocessor source tokens (%0) exceeds the token limit (%1)'
H8A02325A6920: '预处理器源代码标记总数(%0)超过了标记限制(%1)'
# 'the two-parameter std::span construction is unsafe as it can introduce mismatch between buffer size and the bound information'
HB6B2C19333E2: '两个参数的std::span构造可能因缓冲区大小和边界信息不匹配而存在风险'
# 'the type %0 is already explicitly ownership-qualified'
H462F56962031: '类型 %0 已经显式具有所有权限定符'
# 'the type %0 is not a pointer to a fast-enumerable object'
HF043D197C95F: '类型 %0 不是指向快速可枚举对象的指针'
# 'the type of object expression %diff{($) does not match the type being destroyed ($)|does not match the type being destroyed}0,1 in pseudo-destructor expression'
HF8245CD4DD36: '对象表达式 %diff{($)的类型与伪析构表达式中正在销毁的类型($)|不匹配}0,1'
# 'the type of the explicit object parameter of an explicitly-defaulted %select{copy|move}0 assignment operator should be reference to %1'
H48B3F2D609BF: '显式默认的%select{拷贝|移动}0赋值运算符的显式对象参数类型应为 %1 的引用'
# 'the type of variable template specialization %0 declared with deduced type %1 depends on itself'
HA37293515585: '使用推导类型 %1 声明的变量模板特化 %0 的类型依赖于自身'
# 'the user condition in the OpenMP context selector needs to be constant; %0 is not'
H518CAE3CEA63: 'OpenMP上下文选择器中的用户条件需要是常量；%0 不是'
# "the value of 'simdlen' parameter must be less than or equal to the value of the 'safelen' parameter"
H05F684C1DEC1: "'simdlen' 参数的值必须小于或等于 'safelen' 参数的值"
# "the value of the size argument in 'strncat' is too large, might lead to a buffer overflow"
H7CBEE5BA8363: "'strncat' 的size参数值过大，可能导致缓冲区溢出"
# "the value of the size argument to 'strncat' is wrong"
H10EE22A40549: "'strncat' 的size参数值有误"
# 'the vecreturn attribute can only be used on a POD (plain old data) class or structure (i.e. no virtual functions)'
HB24B6E1BF839: 'vecreturn属性只能用于POD（普通旧数据）类或结构体（即没有虚函数）'
# 'the vecreturn attribute can only be used on a class or structure with one member, which must be a vector'
H91431B029CC5: 'vecreturn属性只能用于包含一个成员的类或结构体，该成员必须是向量类型'
# "the warning option '-%0' is not supported"
H961C96696067: "警告选项 '-%0' 不受支持"
# 'there is no external assembler that can be used on this platform'
H36CA569B9742: '当前平台没有可用的外部汇编器'
# 'there is no symbol at the given location'
H99C4AECFC4C8: '在给定位置没有找到符号'
# 'this builtin is available only on AIX 7.2 and later operating systems'
H6E604B084F43: '该内建函数仅适用于AIX 7.2及更高版本操作系统'
# 'this builtin is only available on 32-bit targets'
H56D31FAC556E: '该内建函数仅支持 32 位目标平台'
# 'this builtin is only available on 64-bit targets'
HC0C706B2D8E7: '此内建函数仅在 64 位目标平台上可用'
# 'this builtin is only available on x86-64 and aarch64 targets'
H81BF150D8949: '此内建函数仅在x86-64和aarch64目标平台上可用'
# "this builtin requires 'dsp r2' ASE, please use -mdspr2"
HF59F7FBACC6E: "此内建函数需要 'dsp r2' ASE，请使用-mdspr2选项"
# "this builtin requires 'dsp' ASE, please use -mdsp"
H2B317AB4FDC4: "此内建函数需要 'dsp' ASE，请使用-mdsp选项"
# "this builtin requires 'msa' ASE, please use -mmsa"
H25EA8026E312: "此内建函数需要 'msa' ASE，请使用-mmsa选项"
# 'this builtin requires ABI -mabi=%0'
H6643558E97E9: '此内建函数需要ABI -mabi=%0'
# 'this coroutine may be split into pieces; not every piece is guaranteed to be inlined'
HEF5E3EA3F783: '此协程可能被拆分为多个部分；并非每个部分都能保证被内联'
# "this declaration is not a prototype; add %select{'void'|parameter declarations}0 to make it %select{a prototype for a zero-parameter function|one}0"
HDD90A70940A7: '此声明不是函数原型；请添加 %select{void|参数声明}0使其成为%select{一个无参数函数的原型|一个}0'
# 'this expression will be parsed as explicit(bool) in C++20'
HE2974A48FA92: '在C++20中，此表达式将被视为显式(bool)转换'
# 'this function cannot be a coroutine: %0 is an incomplete type'
HEB887A198DFF: '此函数不能是协程：%0 是一个不完整类型'
# 'this function cannot be a coroutine: %0 is not a class'
HF896DD5CD9DB: '此函数不能是协程：%0 不是一个类'
# "this function cannot be a coroutine: %q0 has no member named 'promise_type'"
HAD42B5488901: '此函数不能是协程：%q0 没有名为 "promise_type" 的成员'
# 'this function cannot be a coroutine: missing definition of specialization %0'
HFC5D41C5C0FA: '此函数不能是协程：缺少特化定义 %0'
# 'this placement new expression is not supported in constant expressions %select{|before C++2c}0'
HFED2CB8F9A5D: '在常量表达式中不支持此placement new表达式 %select{|在C++2c之前}0'
# 'this pragma cannot appear in %0 declaration'
HCE58A657A4E9: '此pragma不能出现在 %0 声明中'
# 'this style of line directive is a GNU extension'
H0B9D785486F6: '这种形式的行指令是GNU扩展'
# 'this target does not support pointer authentication'
HB298CA51FDBD: '此目标平台不支持指针认证'
# 'this type tag was not designed to be used with this function'
H6E259EADA90E: '此类型标签未设计为此函数使用'
# 'this use of statement expressions is not supported in a constant expression'
H15F3A7193C9C: '在常量表达式中不支持这种语句表达式用法'
# 'this value is too large for this fixed point type'
HC641D92F0E57: '该值对这种固定点类型来说过大'
# 'this warning is no longer in use and will be removed in the next release'
H0EF268B5B2F9: '此警告已不再使用，将在下一版本中移除'
# 'thread safety beta warning'
HB0419777F950: '线程安全Beta警告'
# 'thread safety verbose warning'
H313BE85969C3: '线程安全详细警告'
# 'thread warning in function %0'
H36B44B602302: '函数 %0 中的线程警告'
# 'thread-local declaration of %0 follows non-thread-local declaration'
HEFF70126975B: '%0 的线程局部声明紧跟非线程局部声明'
# 'thread-local declaration of %0 with %select{static|dynamic}1 initialization follows declaration with %select{dynamic|static}1 initialization'
H912C45CDB374: '%0 的线程局部声明带有%select{静态|动态}1初始化，而之前的声明使用的是%select{动态|静态}1初始化'
# 'thread-local storage is not supported for the current target'
H98D675ADC45A: '当前目标平台不支持线程局部存储'
# 'thread-local variable has non-trivial ownership: type is %0'
H6F11C930F55E: '线程局部变量具有非平凡的所有权：类型为 %0'
# 'threadprivate variable with incomplete type %0'
HCB733257A55A: '线程私有变量具有不完整类型 %0'
# "threadprivate variables are not allowed in '%0' clause"
HEEB356882606: "'%0' 子句中不允许使用线程私有变量"
# 'threadprivate variables cannot be used in target constructs'
HB21F31B22998: '线程私有变量不能在目标构造中使用'
# 'three-way comparison between pointer and zero'
HD3520571E10A: '指针与零的三向比较'
# 'three-way comparison between vectors is not supported'
H00B5B249986A: '向量之间的三向比较不被支持'
# "three-way comparison cannot be synthesized because there is no viable function for %select{'=='|'<'}0 comparison"
H6263B6389D1C: '无法合成三向比较，因为没有可用的%select{等于|小于}0比较函数'
# 'threshold (in percent) for selecting functions to process in lite mode. Higher threshold means fewer functions to process. E.g threshold of 90 means only top 10 percent of functions with profile will be processed.'
HC3919B9CBB6D: '阈值（百分比）用于在轻量级模式下选择要处理的函数。阈值越高，需要处理的函数越少。例如，阈值设为 90 表示仅处理具有profile的前 10%的函数。'
# 'tile arguments must refer to different tiles'
HC74F5110780C: '瓦片参数必须引用不同的瓦片'
# 'time BOLT aggregator'
H034122EC1DF6: '统计BOLT聚合器的时间'
# 'time frame analysis steps'
H18422D3F506F: '统计分析步骤的时间范围'
# 'time icf steps'
H17EA53E3423A: '记录ICF步骤的时间'
# "timed out waiting to acquire lock file for module '%0'"
HD7ADFA168199: "等待获取模块 '%0' 的锁文件超时"
# 'tls_model must be "global-dynamic", "local-dynamic", "initial-exec" or "local-exec"'
H2BCDC88FA47E: 'tls_model必须是 "global-dynamic"、"local-dynamic"、"initial-exec" 或 "local-exec"'
# 'to match this %0'
HDA13A5D2D868: '与这个 %0 匹配'
# "to match this ']'"
HEF9A1EC0D665: "与这个 ']' 匹配"
# "to match this '{'"
H013B6E508561: "以匹配这个 '{'"
# 'token is not a valid binary operator in a preprocessor subexpression'
H93EB0C533EDF: '该标记不是预处理子表达式中的有效二元运算符'
# "token pasting of ',' and __VA_ARGS__ is a GNU extension"
H13889DCFA50D: "用 ',' 和 __VA_ARGS__ 进行标记粘贴是GNU扩展"
# 'too %select{few|many}0 arguments in call to %1'
H55C9E37AE906: '调用 %1 时参数%select{太少|太多}0'
# 'too %select{few|many}0 initializers in list for type %1 (expected %2 but found %3)'
HD545C2517E80: '类型 %1 的列表中初始化器%select{太少|太多}0（期望 %2 但找到 %3）'
# 'too %select{few|many}0 parameters in the signature specified by the %1 attribute (expected %2; got %3)'
H6F4276FDBDF1: '由 %1 属性指定的签名中参数%select{太少|太多}0（期望 %2；找到 %3）'
# 'too %select{many|few}0 type arguments for class %1 (have %2, expected %3)'
H35A08DFD5F2A: '类 %1 的类型参数%select{太多|太少}0（已有 %2，期望 %3）'
# 'too few %select{|||execution configuration }0%select{|non-object }2arguments to %select{function|block|method|kernel function}0 call, at least argument %1 must be specified'
HF6BA10037D33: '调用 %select{函数|代码块|方法|内核函数}0 时，%select{|||执行配置 }0%select{|非对象 }2参数不足，至少必须指定参数 %1'
# 'too few %select{|||execution configuration }0%select{|non-object }2arguments to %select{function|block|method|kernel function}0 call, single argument %1 was not specified'
H9CA8A408A5C7: '调用 %select{函数|代码块|方法|内核函数}0 时，%select{|||执行配置 }0%select{|非对象 }2参数不足，单个参数 %1 未指定'
# 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2'
H5939FAB31ED6: '调用%select{函数|块|方法|内核函数}0时 %select{|||执行配置 }0%select{|非对象 }3参数太少，期望 %1，实际 %2'
# 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2; did you mean %4?'
HF20F679C52F2: '调用%select{函数|块|方法|内核函数}0时 %select{|||执行配置 }0%select{|非对象 }3参数太少，期望 %1，实际 %2；您是否是指 %4？'
# 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at least %1, have %2'
HD24171A04B0B: '调用%select{函数|块|方法|内核函数}0时 %select{|||执行配置 }0%select{|非对象 }3参数太少，期望至少 %1，实际 %2'
# 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at least %1, have %2; did you mean %4?'
HD3BBC6D9EFC0: '调用%select{函数|块|方法|内核函数}0时 %select{|||执行配置 }0%select{|非对象 }3参数太少，期望至少 %1，实际 %2；您是否是指 %4？'
# 'too few arguments provided to function-like macro invocation'
H1E346A7B8B3C: '函数式宏调用提供的参数太少'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2'
H90F884ECB318: '对 %select{函数|代码块|方法|内核函数}0 的调用参数过多，%select{|||执行配置 }0%select{|非对象 }3参数，期望 %1 个，实际有 %2 个'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2; did you mean %4?'
HCA745DFE1FDF: '对 %select{函数|代码块|方法|内核函数}0 的调用参数过多，%select{|||执行配置 }0%select{|非对象 }3参数，期望 %1 个，实际有 %2 个；是否应改为 %4？'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at most %1, have %2'
H94A2619722A2: '对 %select{函数|代码块|方法|内核函数}0 的调用参数过多，%select{|||执行配置 }0%select{|非对象 }3参数，期望最多 %1 个，实际有 %2 个'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at most %1, have %2; did you mean %4?'
HE9A38EF19888: '对 %select{函数|代码块|方法|内核函数}0 的调用参数过多，%select{|||执行配置 }0%select{|非对象 }3参数，期望最多 %1 个，实际有 %2 个；是否应改为 %4？'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected single argument %1, have %2 arguments'
HDBD2C1E2CE61: '对 %select{函数|代码块|方法|内核函数}0 的调用参数过多，%select{|||执行配置 }0%select{|非对象 }3参数，期望单个参数 %1，实际有 %2 个参数'
# 'too many %select{|||execution configuration }0arguments to %select{function|block|method|kernel function}0 call, expected at most single %select{|non-object }3argument %1, have %2%select{|non-object}3 arguments'
HDAC13624D426: '对 %select{函数|代码块|方法|内核函数}0 的调用参数过多，%select{|||执行配置 }0参数，期望最多单个 %select{|非对象 }3参数 %1，实际有 %2%select{|非对象}3 参数'
# 'too many arguments provided to function-like macro invocation'
HBB5E8EFBFD08: '提供给函数式宏调用的参数过多'
# 'too many braces around %select{scalar |}0initializer'
H5C95D607138A: '在%select{标量 |}0 初始化器周围有过多的花括号'
# 'too many errors emitted, stopping now'
H208E3BCCF078: '报告了过多的错误，现在停止'
# 'too many function parameters; subsequent parameters will be ignored'
H803517A338E0: '函数参数过多；后续参数将被忽略'
# "too many parameters (%0) for 'main': must be 0, 2, or 3"
H39E16B39631F: "'main' 函数的参数过多（%0）：必须为 0、2或 3"
# 'tool-template options'
HBCF3F3069BB4: 'tool-template 选项'
# 'top-level comma expression in array subscript is deprecated in C++20 and unsupported in C++23'
HE89EE6B0F334: '数组下标中的顶层逗号表达式在C++20中已弃用，并在C++23中不受支持'
# 'total number of threads cannot exceed %0'
H1884DB567221: '线程总数不能超过 %0'
# 'total token limit set here'
HC6BF74A3FD57: '此处设置的总标记限制'
# 'toy compiler\n'
H2EDD43662B08: '玩具编译器\n'
# 'trailing requires clause can only be used when declaring a function'
H084306C3877A: '尾随requires子句只能在声明函数时使用'
# 'trailing requires clause should be placed outside parentheses'
H548F58E8723A: '尾随requires子句应放在括号之外'
# 'trailing return type may not be nested within parentheses'
HC76578BE367C: '尾随返回类型不能嵌套在括号内'
# 'trailing return type must appear before trailing requires clause'
HA5D12CC5013B: '尾随返回类型必须出现在尾随requires子句之前'
# 'trailing return types are incompatible with C++98'
H32DC951D7875: '尾随返回类型与C++98不兼容'
# 'translate addresses using BAT'
HDDEE1DC9B85A: '使用BAT转换地址'
# 'translation unit contains multiple module declarations'
HF895A4F45EF2: '翻译单元包含多个模块声明'
# 'translation unit is too large for Clang to process: ran out of source locations'
H8B3695BCDB65: '翻译单元太大，Clang无法处理：源位置已用尽'
# 'transparent union definition must contain at least one field; transparent_union attribute ignored'
H140F1B74DF83: '透明联合体定义必须包含至少一个字段；transparent_union属性被忽略'
# 'transparent_union attribute can only be applied to a union definition; attribute ignored'
HD786E3576B74: 'transparent_union属性只能应用于联合定义；属性被忽略'
# 'trap on failure'
H4518B36E2611: '失败时触发陷阱'
# 'treat the string as an argument to avoid this'
H276A4BE7C44E: '将字符串视为参数以避免此错误'
# "treating #%select{include|import|include_next|__include_macros}0 as an import of module '%1'"
HCF878B660176: "将#%select{include|import|include_next|__include_macros}0 视为模块 '%1' 的导入"
# "treating '%0' input as '%1' when in C++ mode, this behavior is deprecated"
H0FA024F7C782: "在C++模式下将 '%0' 输入视为 '%1'，此行为已弃用"
# 'treating Ctrl-Z as end-of-file is a Microsoft extension'
H2B9F3B693225: '将Ctrl-Z视为文件结束符是Microsoft扩展'
# "treating Unicode character <U+%0> as an identifier character rather than as '%1' symbol"
H50914464E633: "将Unicode字符 <U+%0> 视为标识符字符而不是 '%1' 符号"
# 'treating Unicode character as whitespace'
HF7B2E2527DE4: '将Unicode字符视为空白符'
# "trigraph converted to '%0' character"
HED476D72F781: "三元组转换为 '%0' 字符"
# 'trigraph ends block comment'
H52594FE74E90: '三元组结束块注释'
# 'trigraph ignored'
H1C535A7D3139: '忽略三元组'
# 'trust the input to be from a well-formed source'
H9D6FAC2CFAB6: '信任输入来自格式正确的源'
# "try 'match(%0={%1%2})'"
H766B462800CF: "尝试 'match(%0={%1%2})'"
# 'try to preserve basic block alignment'
H8B07C548FF85: '尽量保留基本块的对齐'
# 'trying to recursively use %0 as superclass of %1'
H22C1DF007CBE: '尝试递归使用 %0 作为 %1 的超类'
# 'turn on the stoke analysis'
H0C2490B9B2A0: '启用Stoke分析'
# 'type %0 can only be used as a function parameter in OpenCL'
H43CCACC05DF1: '类型 %0 只能在OpenCL中用作函数参数'
# 'type %0 cannot be decomposed'
HAD575CEF4CDD: '类型 %0 无法分解'
# 'type %0 cannot be narrowed to %1 in initializer list'
HA66630D471E5: '类型 %0 在初始化列表中无法缩小为 %1'
# 'type %0 cannot be narrowed to %1 in initializer list in C++11'
H121C0CF66257: '类型 %0 在C++11的初始化列表中无法缩小为 %1'
# "type %0 cannot be used prior to '::' because it has no members"
HB29A2AE6A5EB: "类型 %0 在 '::' 之前无法使用，因为它没有成员"
# 'type %0 decomposes into %3 %plural{1:element|:elements}2, but %select{%plural{0:no|:only %1}1|%1}4 %plural{1:name was|:names were}1 provided'
HF59CA2FD696F: '类型 %0 分解为 %3 %plural{1:元素|:元素}2，但 %select{%plural{0:没有提供|:只提供 %1}1|%1}4 %plural{1:名字|:名字}1'
# 'type %0 does not provide a %select{subscript|call}1 operator'
HCAF6714D32F7: '类型 %0 未提供 %select{subscript|call}1 运算符'
# 'type %0 found by destructor name lookup'
H35BD375D3364: '通过析构函数名称查找找到类型 %0'
# 'type %0 has %select{an attribute|a member with an attribute}1 which currently causes the types to be treated as though they are incompatible'
HAC4DA8103F8D: '类型 %0 具有%select{属性|带有属性的成员}1，这目前导致这些类型被视为不兼容'
# 'type %0 has incompatible definitions%select{| in different translation units}1'
HF1AFD0FA558D: '类型 %0 具有不兼容的定义%select{ |在不同翻译单元中}1'
# 'type %0 has unexpected layout'
H8C8909F11F0A: '类型 %0 具有意外的布局'
# 'type %0 in generic association compatible with previously specified type %1'
H1178A958ED5C: '通用关联中的类型 %0 与之前指定的类型 %1 兼容'
# 'type %0 in generic association is a variably modified type'
HCA8F3A82743E: '通用关联中的类型 %0 是一个variably modified type'
# 'type %0 in generic association not an object type'
H9CBDAFFFD0D2: '类型 %0 在泛型关联中不是对象类型'
# "type %0 is already '__ptrauth'-qualified"
H046D04C84060: "类型 %0 已带有 '__ptrauth' 限定符"
# 'type %0 is incomplete'
H68C687943CFB: '类型 %0 是不完整的'
# 'type %0 is not a direct or virtual base of %1'
HA6EFF9DEE3C5: '类型 %0 不是 %1 的直接或虚基类'
# 'type %0 is not trivially copyable and not guaranteed to be mapped correctly'
HA6A4CD2AE815: '类型 %0 不是平凡可复制的，且无法保证正确映射'
# 'type %0 of function parameter pack does not contain any unexpanded parameter packs'
H5D64B61067E5: '函数参数包 %0 中不包含未展开的参数包'
# 'type %0 of non-type template parameter is not a structural type'
H546F4F02218C: '非类型模板参数的类型 %0 不是结构性类型'
# 'type %0 requires %1 bytes of alignment and the default allocator only guarantees %2 bytes'
H82A5F7C1A758: '类型 %0 需要 %1 字节的对齐，而默认分配器仅保证 %2 字节'
# 'type %2 of %select{explicit instantiation|explicit specialization|partial specialization|redeclaration}0 of %1 does not match expected type %3'
H34154FB5D28F: '类型 %2 的%select{显式实例化|显式特化|部分特化|重新声明}0 %1 与期望类型 %3 不匹配'
# "type argument %0 cannot be qualified with '%1'"
HF21B2C8937B4: '类型参数 %0 不能用 "%1" 进行限定'
# 'type argument %0 cannot explicitly specify nullability'
H1330164CF91E: '类型参数 %0 不能显式指定空安全性'
# 'type argument %0 does not satisfy the bound (%1) of type parameter %2'
H3669CF5C9A7D: '类型参数 %0 不满足类型参数 %2 的边界（%1）'
# 'type argument %0 is neither an Objective-C object nor a block type'
HC89732C094A1: '类型参数 %0 既不是 Objective-C 对象，也不是块类型'
# "type argument %0 must be a pointer (requires a '*')"
HF674997DE917: '类型参数 %0 必须是指针（需要一个 "*"）'
# 'type argument of iboutletcollection attribute cannot be a builtin type'
H26C24AC03DB8: 'iboutletcollection 属性的类型参数不能是内建类型'
# 'type arguments cannot be applied to already-specialized class type %0'
H67EB09767F26: '无法将类型参数应用于已特化的类类型 %0'
# 'type arguments cannot be applied to non-class type %0'
H41CCF55FF38B: '无法将类型参数应用于非类类型 %0'
# 'type arguments cannot be applied to non-parameterized class %0'
HC40C2F44A862: '无法将类型参数应用于非参数化类 %0'
# 'type aware %0 requires a matching type aware %select{|placement }1%2 to be declared in the same scope'
H9C477E0B6856: '类型感知的 %0 需要在相同作用域内声明与之匹配的类型感知 %select{|放置 }1%2'
# 'type aware %0 will not be used for coroutine allocation'
H5B38A9DE0EAE: '类型感知型 %0 将不会用于协程分配'
# 'type aware allocators are a C++2c extension'
H55565F6468B1: '类型感知型分配器是C++2c扩展'
# 'type aware allocators are incompatible with C++ standards before C++2c'
H25EF1B0FAFC1: '类型感知型分配器与C++2c之前的C++标准不兼容'
# 'type bound %0 for type parameter %1 conflicts with %select{implicit|previous}2 bound %3%select{for type parameter %5|}4'
H7F10FC1165B9: '类型参数 %1 的类型边界 %0 与 %select{隐式|之前的}2 边界 %3%select{对类型参数 %5|}4 冲突'
# 'type bound %0 for type parameter %1 is not an Objective-C pointer type'
H80B67C4F94CD: '类型参数 %1 的类型边界 %0 不是 Objective-C 指针类型'
# "type bound %1 for type parameter %0 cannot be qualified with '%2'"
H3CC7E562DE4D: '类型参数 %0 的类型边界 %1 不能用 "%2" 进行限定'
# 'type constraint differs in template redeclaration'
HA94E71A6CC7A: '模板重新声明中类型约束不同'
# 'type conversion function declared here'
H7B0CCA1F5818: '类型转换函数在此处声明'
# 'type declaration hidden'
H161A31411076: '类型声明被隐藏'
# 'type definition in a constexpr %select{function|constructor}0 is a C++14 extension'
HB61A32D40D4A: 'constexpr %select{函数|构造函数}0 中的类型定义是C++14扩展'
# 'type definition in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14'
H51291DDF6B58: 'constexpr %select{函数|构造函数}0 中的类型定义与C++14之前的版本不兼容'
# 'type inference of a declaration other than a plain identifier with optional trailing attributes is a Clang extension'
HB4EF9FC7F52F: '非普通标识符（可带尾置属性）的类型推导是Clang扩展'
# 'type is given name %0 for linkage purposes by this %select{typedef|alias}1 declaration'
HFEABA5A13E20: '此 %select{typedef|别名}1声明为链接目的将类型命名为 %0'
# 'type is not C-compatible due to this %select{base class|default member initializer|lambda expression|friend declaration|member declaration}0'
H8BEB926AC2A7: '由于以下%select{基类|默认成员初始化器|lambda表达式|友元声明|成员声明}0，类型不兼容C兼容'
# 'type name does not allow %select{<ERROR>|constexpr|consteval|constinit}0 specifier to be specified'
H2BAC4BD9B411: '类型名称不允许指定 %select{<ERROR>|constexpr|consteval|constinit}0 说明符'
# 'type name does not allow function specifier to be specified'
H63933758FA41: '类型名称不允许指定函数说明符'
# 'type name does not allow storage class to be specified'
HD221C2943356: '类型名称不允许指定存储类'
# 'type name requires a specifier or qualifier'
H9BCBB335F47F: '类型名称需要指定说明符或限定符'
# 'type nullability specifier %0 is a Clang extension'
HFDBD8198839C: '类型空值限定符 %0 是Clang扩展'
# 'type of %ordinal0 parameter of local declaration does not match definition%diff{ ($ vs $)|}1,2'
HC35F751A0E20: '本地声明第%ordinal0参数的类型与定义不匹配%diff{ ($ vs $)|}1,2'
# 'type of %ordinal0 parameter of member declaration does not match definition%diff{ ($ vs $)|}1,2'
H6D265791AD7D: '成员声明第%ordinal0参数的类型与定义不匹配%diff{ ($ vs $)|}1,2'
# 'type of UTF-8 string literal will change from array of char to array of char8_t in C23'
HDD96729D3F80: '在C23中，UTF-8字符串字面量的类型将从char数组变为char8_t数组'
# 'type of UTF-8 string literal will change from array of const char to array of const char8_t in C++20'
H2FF4EC88FBDF: '在C++20中，UTF-8字符串字面量的类型将从const char数组变为const char8_t数组'
# 'type of machine mode does not match type of base type'
HCC37C6223BD0: '机器模式类型与基类型类型不匹配'
# 'type of machine mode does not support base vector types'
HC82FE5FB775E: '机器模式类型不支持基础向量类型'
# 'type of property %0 (%1) does not match type of accessor %2 (%3)'
H588E7AE2B664: '属性 %0 (%1)的类型与访问器 %2 (%3)的类型不匹配'
# 'type of property %0 (%1) does not match type of instance variable %2 (%3)'
H73BAE4F8734B: '属性 %0 (%1) 的类型与实例变量 %2 (%3) 的类型不匹配'
# 'type of property %0 does not match type of accessor %1'
H270F876040C0: '属性 %0 的类型与访问器 %1 的类型不匹配'
# 'type of property %0 in class extension does not match property type in primary class'
H132F7594C298: '类扩展中的属性 %0 类型与主类中的属性类型不匹配'
# 'type of setter must be void'
HD41AE4C60492: '设置器的类型必须为 void'
# 'type of specialized non-type template argument depends on a template parameter of the partial specialization'
HBDE8FF32FC3A: '部分特化模板参数的非类型模板实参类型依赖于该部分特化的模板参数'
# 'type of thread-local variable has non-trivial destruction'
H8E6776B80F65: '线程局部变量的类型具有非平凡析构'
# "type operand %0 of 'typeid' cannot have '%1' qualifier"
HBE87B8BABE8E: "运算符 'typeid' 的类型操作数 %0 不能带有 '%1' 限定符"
# 'type parameter %0 bound %1 cannot explicitly specify nullability'
H73C9FD2AB78B: '类型参数 %0 的绑定 %1 不能显式指定空安全属性'
# 'type parameter %0 declared here'
HFF5B8C2A68FC: '类型参数 %0 在此处声明'
# "type specifier missing, defaults to 'int'"
H4B268E82A57A: "缺少类型说明符，缺省为 'int'"
# "type specifier missing, defaults to 'int'; ISO C99 and later do not support implicit int"
H8CEE1B0F6CB9: "缺少类型说明符，缺省为 'int'; ISO C99 及后续标准不支持隐式 int"
# 'type trait requires %0%select{| or more}1 argument%select{|s}2; have %3 argument%s3'
H5F2DEBC2DD6F: '类型特征需要 %0%select{|或更多}1 参数 %select{|s}2；但提供了 %3 参数%s3'
# 'type was declared read-only here'
HAFE8C580C1C1: '类型在此处被声明为只读'
# 'type-id cannot have a name'
H0F4A38BF6BC0: '类型标识符不能有名称'
# 'type-less parameter names in function declaration'
H4275A67CD2BD: '函数声明中存在无类型参数名称'
# 'typedef declarator cannot be qualified'
H13CBEB4EC130: 'typedef 声明符不能有限定符'
# 'typedef member %0 cannot be a bit-field'
HF1C17DDE556A: 'typedef 成员 %0 不能是位域'
# 'typedef name must be an identifier'
H0FF9C8135AE0: 'typedef 名称必须是标识符'
# 'typedef requires a name'
HD4A732841C3B: 'typedef 需要一个名称'
# 'typeid applied to expression of polymorphic type %0 is not allowed in a constant expression in C++ standards before C++20'
H56E5AEAEB4DB: '在 C++20 之前的 C++ 标准中，对多态类型 %0 的表达式应用 typeid 不允许出现在常量表达式中'
# 'typeid will not work since RTTI data is disabled by %select{-fno-rtti-data|/GR-}0'
H44DAF1F1B628: 'typeid 无法工作，因为 RTTI 数据被 %select{-fno-rtti-data|/GR-}0 禁用'
# 'typename is allowed for identifiers only'
HEE2C4836DC27: 'typename 仅允许用于标识符'
# 'typename specifier refers to %select{class template|function template|variable template|alias template|template template parameter|template}0 member in %1; argument deduction not allowed here'
H15F65651B175: 'typename 指定符引用 %select{类模板|函数模板|变量模板|别名模板|模板模板参数|模板}0 的成员 %1；此处不允许参数推导'
# 'typename specifier refers to %select{class template|function template|variable template|alias template|template template parameter|template}0; argument deduction not allowed here'
HDDA5FA8262A7: 'typename 指定符引用 %select{类模板|函数模板|变量模板|别名模板|模板模板参数|模板}0；此处不允许参数推导'
# 'typename specifier refers to a dependent using declaration for a value %0 in %1'
HA4640204C28B: 'typename 指定符引用一个依赖的 using 声明的值 %0 在 %1 中'
# 'typename specifier refers to a non-type template'
HDA01E7DE1981: 'typename 指定符引用非类型模板'
# 'typename specifier refers to non-type %0'
H68FFAB15F6B4: 'typename 指定符引用非类型 %0'
# 'typename specifier refers to non-type member %0 in %1'
HAD3AB5D3DF5D: 'typename 指定符引用 %1 中的非类型成员 %0'
# 'types cannot be declared in an anonymous %select{struct|union}0'
HB8A6E3596B04: '类型不能在匿名 %select{struct|union}0 中声明'
# 'types declared in an anonymous %select{struct|union}0 are a Microsoft extension'
H10CD33288972: '匿名 %select{struct|union}0 中声明的类型是 Microsoft 扩展'
# 'types may not be defined in a for range declaration'
HA0579AB1E4A8: 'for 范围声明中不能定义类型'
# "types with 'sycl_special_class' attribute must have one and only one '__init' method defined"
H49F85977919C: "具有 'sycl_special_class' 属性的类型必须定义且仅定义一个 '__init' 方法"
# "umbrella directory '%0' not found"
H7F60E99942C1: "umbrella 目录 '%0' 未找到"
# "umbrella for module '%0' already covers this directory"
HAE8DEE1E4013: "模块 '%0' 的 umbrella 已覆盖此目录"
# "umbrella header for module '%0' does not include header '%1'"
H803B3F536D5A: "模块 '%0' 的 umbrella 头文件未包含头文件 '%1'"
# "unable to create target: '%0'"
H48D73D54C838: '无法创建目标："%0"'
# 'unable to execute command: %0'
H1274C3267D8B: '无法执行命令：%0'
# "unable to find %0 directory, expected to be in '%1' found via %2"
HFA08DE02A86A: "无法找到 %0 目录，期望位于 '%1'，通过 %2 找到的位置"
# "unable to find %select{'::operator new(size_t, nothrow_t)'|'::operator new(size_t, align_val_t, nothrow_t)'}1 for %0"
HD53B43D38AB3: "无法为 %0 找到 %select{'::operator new(size_t, nothrow_t)'|'::operator new(size_t, align_val_t, nothrow_t)'}1"
# 'unable to find a Visual Studio installation; try running Clang from a developer command prompt'
HD5A60BEBFC34: '未找到 Visual Studio 安装；尝试从开发者命令提示符运行 Clang'
# "unable to find module '%0'"
H4F4B8FBAA599: '无法找到模块“%0”'
# "unable to find plugin '%0'"
H694242203542: '无法找到插件“%0”'
# "unable to handle compilation, expected exactly one compiler job in '%0'"
H0ED90FBA3001: '无法处理编译，期望在“%0”中恰好有一个编译任务'
# 'unable to interface with target machine'
H48913BEFE8AE: '无法与目标机器建立接口'
# 'unable to load PCH file'
H0C8F5802F259: '无法加载PCH文件'
# "unable to load basic block sections function list: '%0'"
H3C61D53F0989: '无法加载基本块节函数列表：“%0”'
# "unable to load plugin '%0': '%1'"
HEABDF34863F0: '无法加载插件“%0”：“%1”'
# 'unable to make temporary file: %0'
HB69A4D68B994: '无法创建临时文件：%0'
# "unable to merge a subprocess's serialized diagnostics"
H0736A846C8D2: '无法合并子进程的序列化诊断信息'
# 'unable to open CC_LOG_DIAGNOSTICS file: %0 (using stderr)'
H5386FA1E767C: '无法打开CC_LOG_DIAGNOSTICS文件：%0（使用标准错误输出）'
# 'unable to open CC_PRINT_HEADERS file: %0 (using stderr)'
H9ABA30151CEC: '无法打开CC_PRINT_HEADERS文件：%0（使用标准错误输出）'
# 'unable to open CC_PRINT_OPTIONS file: %0'
HEA741366E890: '无法打开CC_PRINT_OPTIONS文件：%0'
# 'unable to open file %0 for serializing diagnostics (%1)'
HD09A684B5E47: '无法打开文件 %0 用于序列化诊断信息（%1）'
# "unable to open output file '%0': '%1'"
H1FD155FFBE98: '无法打开输出文件“%0”：“%1”'
# "unable to open statistics output file '%0': '%1'"
HDC9884A86150: '无法打开统计信息输出文件“%0”：“%1”'
# 'unable to overwrite file %0: %1'
HF040F371E4DB: '无法覆盖文件 %0：%1'
# 'unable to protect inline asm that clobbers stack pointer against stack clash'
H57F37138A9DF: '无法保护破坏堆栈指针的内联汇编以防止堆栈冲突'
# "unable to read PCH file %0: '%1'"
H53BCE7FDE626: '无法读取PCH文件 %0：“%1”'
# 'unable to remove file: %0'
HA87F741C0BFD: '无法删除文件：%0'
# "unable to rename temporary '%0' to output file '%1': '%2'"
H621AA5D0DBAB: '无法将临时文件“%0”重命名为输出文件“%1”：“%2”'
# 'unable to resolve declare reduction construct for type %0'
H4CBC0B2EAEEC: '无法解析类型 %0 的声明式规约构造'
# 'unable to set working directory: %0'
H1915AC32A7BB: '无法设置工作目录：%0'
# 'unannotated fall-through between switch labels'
HD2F0C0FDF581: 'switch标签间的未注释穿透'
# 'unannotated fall-through between switch labels in partly-annotated function'
H8BA6FF77BB8B: '部分注释的函数中switch标签间的未注释穿透'
# "unary fold expression has empty expansion for operator '%0' with no fallback value"
HE62A3703EA3A: "一元折叠表达式为操作符 '%0' 的展开为空且无备用值"
# 'unary operator not supported, only increment and decrement operations permitted'
HCFDDCEAA7D4F: '不支持的一元运算符，仅允许增量和减量操作'
# 'undeclared identifier %0 in destructor name'
H9E161BF60045: '析构函数名称中未声明的标识符 %0'
# 'undeclared selector %0'
H76DFE4FB888F: '未声明的选择器 %0'
# 'undeclared selector %0; did you mean %1?'
HFF50CB7951F9: '未声明的选择器 %0；是否是指 %1？'
# "undeclared variable %0 used as an argument for '#pragma unused'"
H1A926D40EA78: "未声明的变量 %0 被用作 '#pragma unused' 的参数"
# 'undef all system defines'
H5E817AACEB7A: '取消定义所有系统宏定义'
# 'undefining builtin macro'
H855B9F8C6AE6: '试图取消定义内建宏'
# 'under -fcoro-aligned-allocation, the non-aligned allocation function for the promise type %0 has higher precedence than the global aligned allocation function'
H677A6074184D: '在-fcoro-aligned-allocation下，承诺类型 %0 的非对齐分配函数比全局对齐分配函数具有更高的优先级'
# 'underaligned exception object thrown'
H67F3421C41BE: '抛出未对齐的异常对象'
# "unelaborated friend declaration is a C++11 extension; specify '%select{struct|interface|union|class|enum}0' to befriend %1"
H85486A35A143: "未详细声明的友元声明是C++11扩展；请指定 '%select{struct|interface|union|class|enum}0' 来与 %1 建立友元关系"
# 'unexpected %0 in function call; perhaps remove the %0?'
HF91D5DDAC941: '函数调用中出现意外的 %0；是否需要移除 %0？'
# "unexpected %0, expected to see one of %select{|'best_case', 'full_generality', }1'single_inheritance', 'multiple_inheritance', or 'virtual_inheritance'"
H715E4C7A8362: "意外的 %0，期望看到 %select{|'best_case', 'full_generality', }1'single_inheritance', 'multiple_inheritance' 或 'virtual_inheritance' 之一"
# "unexpected '#pragma acc ...' in program"
H1E1E01704393: "程序中出现意外的 '#pragma acc ...'"
# "unexpected '#pragma omp ...' in program"
H46D7021997C2: "程序中出现意外的 '#pragma omp ...'"
# "unexpected '%0' clause, '%1' is specified already"
H5B200478E6AE: "意外的 '%0' 子句，'%1' 已被指定"
# "unexpected '%0' clause, only %select{'device_type'|'enter' or 'link'|'enter', 'link' or 'device_type'|'device_type', 'indirect'|'enter', 'link', 'device_type' or 'indirect'}1 clauses expected"
H3763BE9D9C9F: "意外的 '%0' 子句，仅允许 %select{'device_type'|'enter' 或 'link'|'enter', 'link' 或 'device_type'|'device_type', 'indirect'|'enter', 'link', 'device_type' 或 'indirect'}1 子句"
# "unexpected '%0' clause, only %select{'device_type'|'to' or 'link'|'to', 'link' or 'device_type'|'device_type', 'indirect'|'to', 'link', 'device_type' or 'indirect'}1 clauses expected"
H1A9F6651CC12: "意外的 '%0' 子句，仅期望 %select{'device_type'|'to' 或 'link'|'to', 'link' 或 'device_type'|'device_type', 'indirect'|'to', 'link', 'device_type' 或 'indirect'}1 子句"
# "unexpected '(', only 'to', 'link' or 'device_type' clauses expected for 'begin declare target' directive"
H5361030EF185: "在 'begin declare target' 指令中，'(' 意外，仅期望 'to'、'link' 或 'device_type' 子句"
# "unexpected ':' in nested name specifier; did you mean '::'?"
HC8B611B07937: "嵌套名称限定符中的意外 ':'，您是否想输入 '::'？"
# "unexpected ';' before %0"
H257D20769B88: "%0 之前的意外 ';'"
# "unexpected '@' in member specification"
HFD6F988E847A: "成员说明中的意外 '@'"
# "unexpected '@' in program"
H0E6C2D976254: "程序中的意外 '@'"
# "unexpected 'enter' clause, use 'to' instead"
H005905027939: "意外的 'enter' 子句，应使用 'to'"
# "unexpected 'execution' modifier in non-executable context"
HA6BB9CA468FA: "在非可执行上下文中意外的 'execution' 修饰符"
# "unexpected 'to' clause, use 'enter' instead"
H48CD21AE4031: "意外的 'to' 子句，应使用 'enter'"
# "unexpected OpenACC directive %select{|'#pragma acc %1'}0"
H996256861627: "意外的 OpenACC 指令 %select{|'#pragma acc %1'}0"
# "unexpected OpenMP clause '%0' in directive '#pragma omp %1'"
H1C5752C27ACF: "在指令 '#pragma omp %1' 中，OpenMP 子句 '%0' 意外"
# "unexpected OpenMP directive %select{|'#pragma omp %1'}0"
HEF8086A19118: "意外的 OpenMP 指令 %select{|'#pragma omp %1'}0"
# "unexpected argument '%0' to '#pragma %1'%select{|; expected %3}2"
HB8C385DE07A5: "对 '#pragma %1' 的意外参数 '%0'%select{|；期望 %3}"
# "unexpected argument '%0' to '#pragma clang attribute'; expected 'push' or 'pop'"
H3133E5143B09: "对 '#pragma clang attribute' 的意外参数 '%0'；期望 'push' 或 'pop'"
# "unexpected argument '%0' to '#pragma clang fp %1'; expected %select{'fast' or 'on' or 'off'|'on' or 'off'|'on' or 'off'|'ignore', 'maytrap' or 'strict'|'source', 'double' or 'extended'}2"
H371571C43BD4: "对 '#pragma clang fp %1' 的意外参数 '%0'；期望 %select{'fast' 或 'on' 或 'off'|'on' 或 'off'|'on' 或 'off'|'ignore', 'maytrap' 或 'strict'|'source', 'double' 或 'extended'}2"
# "unexpected argument '%0' to '#pragma clang optimize'; expected 'on' or 'off'"
H1485FAA86056: "对 '#pragma clang optimize' 的意外参数 '%0'；期望 'on' 或 'off'"
# 'unexpected argument to debug command'
H3827CC068DE1: '调试命令的意外参数'
# 'unexpected character <U+%0>'
H5B9099D7894E: '意外字符 <U+%0>'
# "unexpected clause after an implicit 'enter' clause"
H3710E8F80D5B: "隐式 'enter' 子句之后的意外子句"
# "unexpected clause after an implicit 'to' clause"
H2010F6D7C809: "隐式 'to' 子句之后的意外子句"
# "unexpected debug command '%0'"
H8054F9A13F94: "意外的调试命令 '%0'"
# 'unexpected end of default argument expression'
H2637B90369AC: '默认参数表达式意外结束'
# 'unexpected end of exception specification'
HE58D2A2E3875: '异常说明意外结束'
# 'unexpected expression: number of expressions is larger than the number of associated loops'
H7A04530C8247: '意外的表达式：表达式数量大于关联的循环数量'
# "unexpected extra argument '%0' to '#pragma clang optimize'"
HD169A0238D64: "#pragma clang optimize 指令意外多出参数 '%0'"
# 'unexpected extra tokens at end of @import declaration'
HC94D2D8555A6: '@import声明末尾存在意外的额外标记'
# 'unexpected interface name %0: expected expression'
HD34771026F11: '意外的接口名称 %0：期望表达式'
# 'unexpected namespace name %0: expected expression'
HD2F7F8269F1D: '意外的命名空间名称 %0：期望表达式'
# 'unexpected namespace scope prior to decltype'
H276642EE3F52: '在decltype之前存在意外的命名空间作用域'
# "unexpected operation specified in 'append_args' clause, expected 'interop'"
H7343FC2DA837: "'append_args' 子句中指定了意外操作，期望 'interop'"
# "unexpected output symbol graph '%1'; please provide '--symbol-graph-dir=<directory>' instead"
H16E9C665ACBA: "意外的输出符号图 '%1'；请改为提供 '--symbol-graph-dir=<directory>'"
# "unexpected parameter '%0' in availability attribute, not permitted in %select{HLSL|C/C++}1"
H3A2F294B2383: "在可用性属性中遇到意外参数 '%0'，%select{HLSL|C/C++}1 中不允许"
# 'unexpected token after Objective-C string'
H279452517A7B: 'Objective-C字符串之后存在意外的标记'
# 'unexpected token in pragma diagnostic'
HF7F8BD94B55D: '在pragma diagnostic中遇到意外标记'
# 'unexpected type name %0: expected expression'
H5096D6005D2D: '意外的类型名称 %0：期望表达式'
# 'unexpected type name %0: expected identifier'
HECE4BA85049C: '意外的类型名称 %0：期望标识符'
# "unexpected value; use 'true' or 'false'"
HBC54A5A54D19: "意外的值；请使用 'true' 或 'false'"
# 'unguarded header; consider using #ifdef guards or #pragma once'
H1B291D4D56CA: '未受保护的头文件；建议使用#ifdef保护或#pragma once'
# 'unicode literals are incompatible with C standards before C23'
H7CE9D5273D56: 'Unicode字面量与C23之前的C标准不兼容'
# 'unicode literals are incompatible with C++ standards before C++17'
H41D963C4F029: 'Unicode字面量与C++17之前的C++标准不兼容'
# 'unicode literals are incompatible with C++98'
H63FE9D503E73: 'Unicode字面量与C++98不兼容'
# 'unicode literals are incompatible with C99'
H413288F05A72: 'Unicode字面量与C99不兼容'
# 'unimplemented constexpr lambda feature: %0 (coming soon!)'
H49A46ED86D09: '未实现的constexpr lambda特性: %0 (即将推出!)'
# 'unimplemented pure virtual method %0 in %1'
H6BCBAEFB56A1: '%1 中的纯虚方法 %0 未实现'
# 'uninitialized reference member is here'
HD2F77230D93D: '未初始化的引用成员在此处'
# 'uninitialized variable in a constexpr %select{function|constructor}0 is a C++20 extension'
HD0E4F93C0D47: 'constexpr %select{函数|构造函数}0中的未初始化变量是C++20扩展'
# 'uninitialized variable in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++20'
HB023F58DC7FA: 'constexpr %select{函数|构造函数}0中的未初始化变量与C++20前的标准不兼容'
# 'union member %0 has reference type %1'
H0725C5FA90A3: '联合体成员 %0 具有引用类型 %1'
# 'union member %0 has reference type %1, which is a Microsoft extension'
H717E84EDF789: '联合体成员 %0 具有引用类型 %1，这是Microsoft扩展'
# 'unions cannot be base classes'
H3537D21C3F62: '联合体不能作为基类'
# 'unions cannot have base classes'
HC69C8BA7958A: '联合体不能有基类'
# 'unions cannot have virtual functions'
HE6462B703CAB: '联合体不能有虚函数'
# 'universal character name referring to a control character is incompatible with C standards before C23'
H443795B4C160: '引用控制字符的通用字符名与C23之前的C标准不兼容'
# 'universal character name referring to a control character is incompatible with C++98'
H441444D5A2FF: '引用控制字符的通用字符名与C++98不兼容'
# 'universal character name refers to a control character'
H0A302EE7A7D5: '通用字符名引用了控制字符'
# 'universal character name refers to a surrogate character'
H38343641D115: '通用字符名引用了代理字符'
# 'universal character names are only valid in C99 or C++'
H6C064E2FEAA1: '通用字符名仅在C99或C++中有效'
# "universal character names are only valid in C99 or C++; treating as '\\' followed by identifier"
H57AF83D90AE3: "通用字符名仅在C99或C++中有效；将其视为反斜杠 '\\' 后接标识符"
# "unknown %0 warning specifier: '%1'"
HE021FCA9FD45: "未知的 %0 警告说明符: '%1'"
# 'unknown %select{type|class}1 name %0; did you mean %2?'
H3C8376ED6B78: '未知的%select{类型|类}1名称 %0；您是否指 %2？'
# "unknown %select{warning|remark}0 option '%1'%select{|; did you mean '%3'?}2"
HE86784D7A808: "未知的 %select{警告|备注}0 选项 '%1'%select{|; 你是否是指 '%3'?}2"
# "unknown '-mindirect-jump=' option '%0'"
H632D52B85B4D: "未知的 '-mindirect-jump=' 选项 '%0'"
# "unknown FP unit '%0'"
HC0D93947CA5F: "未知的浮点单元 '%0'"
# 'unknown HLSL semantic %0'
H173D19A6AD63: '未知的 HLSL 语义 %0'
# "unknown action '%1' for '#pragma %0' - ignored"
HD5134EB4614C: "未知的 '#pragma %0' 动作 '%1' - 已忽略"
# "unknown action for '#pragma %0' - ignored"
HC6ADA3F7938E: "未知的 '#pragma %0' 动作 - 已忽略"
# "unknown analyzer-config '%0'"
H50FE6AD53FF0: "未知的 analyzer-config '%0'"
# "unknown argument '%0'; did you mean '%1'?"
HBDB4C2710C85: "未知的参数 '%0'; 你是否是指 '%1'?"
# "unknown argument ignored in clang-cl '%0'; did you mean '%1'?"
HFC74C4C6226A: "未知的 clang-cl 参数 '%0' 被忽略; 你是否是指 '%1'?"
# "unknown argument ignored in clang-cl: '%0'"
HC759BFBE35F6: "未知的 clang-cl 参数被忽略: '%0'"
# "unknown argument: '%0'"
HA16D3B1BF1E9: "未知的参数: '%0'"
# "unknown assumption string '%0' may be misspelled; attribute is potentially ignored, did you mean '%1'?"
H50CF8A7A4EC4: "未知的假设字符串 '%0' 可能拼写错误; 属性可能被忽略，你是否是指 '%1'?"
# "unknown assumption string '%0'; attribute is potentially ignored"
H585A62063A9D: "未知的假设字符串 '%0'; 属性可能被忽略"
# 'unknown attribute %0 ignored'
H2C00F439265B: '未知的属性 %0 被忽略'
# "unknown attribute %0 ignored; did you mean '%1'?"
H582EB59A2C0E: "未知属性 %0 被忽略；您是否是指 '%1'？"
# "unknown attribute '%0'"
HB9EC0CD4D3F9: "未知的属性 '%0'"
# "unknown attribute subject rule '%0'"
H3D3386816A55: "未知的属性主题规则 '%0'"
# 'unknown cast annotation __bridge_retain; did you mean __bridge_retained?'
H99CA4EEB19EE: '未知的类型转换注释 __bridge_retain; 你是否是指 __bridge_retained?'
# 'unknown command tag name'
H11BCD33A99AD: '未知的命令标签名称'
# "unknown command tag name '%0'; did you mean '%1'?"
H7FD2FDFA8A87: "未知的命令标签名称 '%0'; 你是否是指 '%1'?"
# 'unknown diagnostic option'
HB8C73037AA51: '未知的诊断选项'
# 'unknown environment %0 in availability macro'
HAEC8AEED3CAD: '在可用性宏中未知的环境 %0'
# "unknown escape sequence '\\%0'"
H4849F8435E28: "未知的转义序列 '\\%0'"
# 'unknown kind of pragma comment'
HA06D4573713E: '未知类型的pragma comment'
# 'unknown linkage language'
H6501D0DE4EA8: '未知的链接语言'
# "unknown module '%0'"
H99985C296846: "未知的模块 '%0'"
# "unknown or ill-formed Objective-C runtime '%0'"
HDD07911A4A21: "未知或格式错误的Objective-C运行时 '%0'"
# 'unknown platform %0 in availability macro'
HD5C8076C5089: '在可用性宏中未知的平台 %0'
# 'unknown platform, assuming -mfloat-abi=%0'
HE055695902FF: '未知的平台，假设为 -mfloat-abi=%0'
# 'unknown pragma ignored'
H2A263E84EA76: '未知的pragma被忽略'
# 'unknown pragma in STDC namespace'
HB8BAEB9D2633: 'STDC命名空间中的未知pragma'
# 'unknown property attribute %0'
HA552B52A5631: '未知的属性 %0'
# 'unknown receiver %0; did you mean %1?'
HF53B2435A683: '未知的接收者 %0；您是否是指 %1？'
# "unknown register name '%0' in asm"
H0A30B49D2F93: "内联汇编中的未知寄存器名称 '%0'"
# "unknown remark serializer format: '%0'"
H4745BF37BA54: "未知的备注序列化格式: '%0'"
# "unknown sanitizer '%0' ignored"
H7A7513A62BEF: "未知的sanitizer '%0' 被忽略"
# "unknown state '%0'"
HBCA6965044DA: "未知的状态 '%0'"
# 'unknown symbolic operand name in inline assembly string'
HA556FD6AA91E: '内联汇编字符串中的未知符号操作数名称'
# "unknown target ABI '%0'"
HCA5838C6F428: "未知的目标ABI '%0'"
# "unknown target CPU '%0'"
H70DCB9C1156C: "未知的目标CPU '%0'"
# "unknown target triple '%0'"
HF45924A5A477: "未知的目标三元组 '%0'"
# 'unknown template name %0'
HF6FA1BD9E3B7: '未知模板名称 %0'
# 'unknown type name %0'
HE3210F6A77D6: '未知类型名称 %0'
# 'unknown type name %0; did you mean %1?'
H2AA39E457B1F: '未知类型名称 %0；是否是指 %1？'
# 'unknown visibility %0'
HD580631FB230: '未知可见性 %0'
# "unknown warning group '%0'"
H8B8A3DBA2D6F: "未知的警告组 '%0'"
# "unknown warning group '%0', ignored"
H9E42BAF52A2D: "未知的警告组 '%0'，已忽略"
# "unknown%select{ | embed}0 preprocessor parameter '%1'"
HD697EE356FF3: "未知%select{ | embed}0 预处理器参数 '%1'"
# 'unmatched type aware %0 declared here'
HD5E243D80237: '此处声明的未匹配类型感知型 %0'
# 'unnamed enumeration must be a definition'
H4B9605BBAC49: '未命名的枚举必须是一个定义'
# 'unnamed type as template argument is incompatible with C++98'
HCF539CBCF367: '未命名类型作为模板参数与C++98不兼容'
# 'unnamed type used in template argument was declared here'
H766AB8914B51: '模板参数中使用的未命名类型是在此处声明的'
# 'unnamed variable cannot be implicitly captured in a lambda expression'
HC2AE531DDA32: '未命名的变量不能在lambda表达式中被隐式捕获'
# 'unparsed tokens following type'
H64EC0A0DBA9B: '类型之后存在未解析的标记'
# 'unqualified base initializer of class templates is a Microsoft extension'
H18E0D4547A36: '类模板的未限定基类初始化器是Microsoft扩展'
# "unqualified call to '%0'"
HA083B268F3B3: '对 "%0" 的未限定调用'
# 'unqualified friend declaration referring to type outside of the nearest enclosing namespace is a Microsoft extension; add a nested name specifier'
H99771505062C: '指向最近包含命名空间之外类型的未限定友元声明是Microsoft扩展；请添加嵌套名称限定符'
# 'unreachable declaration of template entity is here'
H8957FB46EC11: '模板实体的不可达声明在此处'
# "unrecognized parameter passing direction, valid directions are '[in]', '[out]' and '[in,out]'"
H451D99C06285: '未识别的参数传递方向，有效方向是 "[in]"、"[out]" 和 "[in,out]"'
# 'unrecognized platform name %0'
H3352495501E4: '未识别的平台名称 %0'
# 'unsequenced modification and access to %0'
HF69B798309CF: '对 %0 的未序列化修改和访问'
# 'unsupported %0 gpu architecture: %1'
HFE203A3E528C: '不受支持的 %0 GPU 架构： %1'
# "unsupported '%0' value '%1'; use 'ios-macabi' instead"
H4B7365627CB3: "不支持的 '%0' 值 '%1'；请改用 'ios-macabi'"
# 'unsupported CUDA gpu architecture: %0'
HBDA907ABC960: '不支持的CUDA GPU架构: %0'
# 'unsupported MC/DC boolean expression; contains an operation with a nested boolean expression. Expression will not be covered'
H0E188D9916C4: '不支持的MC/DC布尔表达式；包含带有嵌套布尔表达式操作。该表达式将不会被覆盖'
# 'unsupported MC/DC boolean expression; number of conditions (%0) exceeds max (%1). Expression will not be covered'
H97B49477D381: '不支持的MC/DC布尔表达式；条件数量（%0）超过最大值（%1）。该表达式将不会被覆盖'
# 'unsupported MC/DC boolean expression; number of test vectors (%0) exceeds max (%1). Expression will not be covered'
HA1952652ED2D: '不支持的MC/DC布尔表达式；测试向量数量（%0）超过最大值（%1）。该表达式将不会被覆盖'
# 'unsupported OpenACC extension clause %0'
H6EE2042EA6AA: '不支持的 OpenACC 扩展子句 %0'
# 'unsupported OpenCL extension %0 - ignoring'
H90715CF4E48F: '不支持的OpenCL扩展 %0 - 忽略'
# "unsupported architecture '%0' for MS-style inline assembly"
H4CDA8CDAE447: "不支持的架构 '%0' 用于MS风格的内联汇编"
# "unsupported architecture '%0' for host compilation"
HF6B9D10A3CB2: "不支持的架构 '%0' 用于主机编译"
# "unsupported argument '%1' to option '%0'"
HF8679865943E: "选项 '%0' 的不支持参数 '%1'"
# "unsupported argument '%1' to option '%0' for target '%2'"
H4C786BC0FD2F: "目标 '%2' 的选项 '%0' 不支持参数 '%1'"
# "unsupported branch protection specification '%0'"
H2A7469D4D5C2: "不支持的分支保护规范 '%0'"
# 'unsupported combination: -header-include-format=%0 and -header-include-filtering=%1'
HDE5448E6CD09: '不支持的组合：-header-include-format=%0 和 -header-include-filtering=%1'
# 'unsupported combination: CC_PRINT_HEADERS_FORMAT=%0 and CC_PRINT_HEADERS_FILTERING=%1'
H2798CD78D9FC: '不支持的组合：CC_PRINT_HEADERS_FORMAT=%0 和 CC_PRINT_HEADERS_FILTERING=%1'
# 'unsupported expression with unknown type'
H3F334416D50C: '包含未知类型的表达式'
# 'unsupported inline asm: input with type %diff{$ matching output with type $|}0,1'
HA68AF7F61C41: '不支持的内联汇编：类型 %diff{$与输出类型匹配的$|}0,1 输入'
# 'unsupported non-standard concatenation of string literals'
H5B7E63184569: '不支持的非标准字符串字面量连接'
# "unsupported option '%0'"
H76DA0BF83FA2: "不支持的选项 '%0'"
# "unsupported option '%0' for language mode '%1'"
HFB2A15C316AA: "语言模式 '%1' 的不支持选项 '%0'"
# "unsupported option '%0' for target '%1'"
H3BBDE17AAC2A: "目标 '%1' 的不支持选项 '%0'"
# "unsupported option '%0'; did you mean '%1'?"
H4AD874895A11: "不支持的选项 '%0'；是否是指 '%1'？"
# "unsupported runtime library '%0' for platform '%1'"
HE43F5A0809F2: "平台 '%1' 不支持的运行时库 '%0'"
# 'unsupported signature for %q0'
H15BCEB35CA2A: '%q0 的签名不支持'
# "unsupported standard library implementation: 'std::%0' is not a class template"
HA2971F6C2CFB: "不支持的标准库实现：'std::%0' 不是一个类模板"
# 'unsupported type for named register variable'
H1A238AEF63D8: '命名寄存器变量的类型不支持'
# "unsupported unwind library '%0' for platform '%1'"
H36E9F0E6CE47: "平台 '%1' 不支持的展开库 '%0'"
# 'unsupported vector cast from %0 to %1 in a constant expression'
H0EB0D2450B52: '常量表达式中不支持将 %0 转换为 %1 的向量转换'
# 'unsupported: anonymous type given name for linkage purposes by %select{typedef|alias}0 declaration after its linkage was computed; add a tag name here to establish linkage prior to definition'
H912212F218D9: '不支持：在计算链接属性后，%select{typedef|alias}0 声明为链接目的给匿名类型命名；请在此处添加标签名以在定义前建立链接'
# "unterminated '#pragma clang attribute push' at end of file"
HAA76B77750A8: "文件末尾未终止的 '#pragma clang attribute push'"
# "unterminated '#pragma pack (push, ...)' at end of file"
H95BE59428151: "文件末尾未终止的 '#pragma pack (push, ...)'"
# 'unterminated /* comment'
H43A167D7F07E: '未终止的 /* 注释'
# 'unterminated conditional directive'
H9448FAFF2F9A: '未终止的条件指令'
# 'unterminated function-like macro invocation'
HD9DD62FCE328: '未终止的宏函数调用'
# 'unterminated symbolic operand name in inline assembly string'
HBE23072A59B4: '内联汇编字符串中未终止的符号操作数名称'
# 'unused %select{function|variable}0 template %1'
H1A13AD1AD99E: '未使用的 %select{function|variable}0 模板 %1'
# 'unused %select{typedef|type alias}0 %1'
HF81285298D17: '未使用的 %select{typedef|type alias}0 %1'
# "unused attribute %0 in '#pragma clang attribute push' region"
HE033EC53FB54: "在 '#pragma clang attribute push' 区域中未使用的属性 %0"
# 'unused exception parameter %0'
H53C55F431BFF: '未使用的异常参数 %0'
# 'unused function %0'
H452452A2578C: '未使用的函数 %0'
# 'unused label %0'
H876AC9FC8066: '未使用的标签 %0'
# 'unused member function %0'
HCD85BCD73655: '未使用的成员函数 %0'
# 'unused parameter %0'
HA3441FCB7F5E: '未使用的参数 %0'
# 'unused variable %0'
HC6697F7C70D3: '未使用的变量 %0'
# 'unwind clobber cannot be used with asm goto'
HF66EC6AC58F5: '无法与asm goto一起使用unwind clobber'
# 'update DWARF debug sections of the executable'
HED8DED50ECC0: '更新可执行文件中的DWARF调试部分'
# 'update address2ProbesMap with output block address'
H5AFCEC7A601F: '使用输出块地址更新address2ProbesMap'
# 'use %select{__bridge_retained|CFBridgingRetain call}1 to make an ARC object available as a +1 %0'
H2F547772958A: '使用 %select{__bridge_retained|CFBridgingRetain 调用}1 将ARC对象作为+1 %0 可用'
# 'use %select{__bridge_transfer|CFBridgingRelease call}1 to transfer ownership of a +1 %0 into ARC'
HF8A351DB4284: '使用 %select{__bridge_transfer|CFBridgingRelease 调用}1 将+1 %0 的所有权转移到ARC'
# 'use %select{an alias declaration|a typedef declaration|a reference|a const variable|a constexpr variable}0 instead'
H31FA52067035: '改用 %select{别名声明|typedef声明|引用|const变量|constexpr变量}0'
# "use '!=' to turn this compound assignment into an inequality comparison"
HFF11B4D027A3: "使用 '!=' 将此复合赋值转换为不等比较"
# "use '%0' for a bitwise operation"
HC5B930A30B61: "使用 '%0' 进行按位运算"
# "use '%0' instead"
H3E25F181DE0F: "改为使用 '%0'"
# "use '%0'%select{| or '%3'|, '%3', or '%4'|, '%3', '%4', or '%5'}2 for '%1' standard"
H8EF0F3BAA8D4: "为 '%1' 标准使用 '%0'%select{| 或 '%3'|，'%3'，或 '%4'|，'%3'，'%4'，或 '%5'}2"
# "use '--' to treat subsequent arguments as filenames"
H6A626367FC6F: "使用 '--' 将后续参数视为文件名"
# "use '=' to turn this equality comparison into an assignment"
H59DEE49ECF0A: "使用 '=' 将此相等比较转换为赋值"
# "use '==' to turn this assignment into an equality comparison"
H00083B312DD9: "使用 '==' 将此赋值转换为相等比较"
# "use 'framework module' to declare module '%0'"
H4A41FDAB21BC: "使用 'framework module' 声明模块 '%0'"
# "use 'isEqual:' instead"
H4DB59E9DD438: "改为使用 'isEqual:'"
# "use 'static' to give inline function %0 internal linkage"
HFF537B0E0104: "使用 'static' 为内联函数 %0 提供内部链接"
# "use 'static_cast' to adjust the pointer correctly while %select{upcasting|downcasting}0"
H11DA11C5BD86: "在%select{向上转换|向下转换}0时，使用 'static_cast' 正确调整指针"
# "use 'template' keyword to treat '%0' as a dependent template name"
H7991087B2538: "使用 'template' 关键字将 '%0' 视为相关模板名称"
# "use 'thread_local' to allow this"
H797BF646E244: "使用 'thread_local' 允许这"
# "use '|=' to turn this inequality comparison into an or-assignment"
H080693EB5666: "使用 '|=' 将此不等比较转换为或赋值"
# 'use -analyzer-disable-all-checks to disable all static analyzer checkers'
H352E7076CB09: '使用 -analyzer-disable-all-checks 禁用所有静态分析器检查器'
# 'use -fbracket-depth=N to increase maximum nesting level'
H336E5F530373: '使用 -fbracket-depth=N 增加最大嵌套级别'
# "use -foperator-arrow-depth=N to increase 'operator->' limit"
HF5AE9E6C2AED: "使用 -foperator-arrow-depth=N 增加 'operator->' 限制"
# 'use -ftemplate-depth=N to increase recursive template instantiation depth'
HB6D1F29D249C: '使用 -ftemplate-depth=N 增加递归模板实例化深度'
# 'use /Tc or /Tp to set input type for standard input'
HA357D9386AFC: '使用 /Tc 或 /Tp 为标准输入设置输入类型'
# 'use DBSCAN/OPTICS algorithm'
HD85FBF4157B0: '使用DBSCAN/OPTICS算法'
# 'use DFS order for YAML profile'
H3B1260947C69: '在YAML配置文件中使用DFS顺序'
# 'use DFS ordering when using -icf option'
HBAAC1CA2D23D: '在使用-icf选项时使用DFS顺序'
# 'use GNU_STACK program header for new segment (workaround for issues with strip/objcopy)'
H43641118D1BF: '为新段使用GNU_STACK程序头（解决与strip/objcopy相关的问题）'
# 'use Machine Branch Probability Info'
H2ADCBE6C2DCD: '使用机器分支概率信息'
# 'use Pettis-Hansen algorithm'
H5F85980D861E: '使用Pettis-Hansen算法'
# 'use __attribute__((visibility("hidden"))) attribute instead'
H69E62EF34DBF: '改用 __attribute__((visibility("hidden"))) 属性'
# 'use __bridge to convert directly (no change in ownership)'
HF999F719DC1E: '使用 __bridge 进行直接转换（不改变所有权）'
# 'use __bridge with C-style cast to convert directly (no change in ownership)'
H25381B224554: '使用 __bridge 结合 C 风格强制转换进行直接转换（不改变所有权）'
# 'use __bridge_retained with C-style cast to make an ARC object available as a +1 %0'
H89038B186CBF: '使用 __bridge_retained 结合 C 风格强制转换，使+1 %0 在ARC中可用'
# 'use __bridge_transfer with C-style cast to transfer ownership of a +1 %0 into ARC'
H0BF38DCCAF48: '使用 __bridge_transfer 结合 C 风格强制转换，将+1 %0 的所有权转移给ARC'
# "use a custom address at which new code will be put, bypassing BOLT's logic to detect where to put code"
H8BE27E21C6B2: '使用一个自定义地址，新代码将被放置于此地址，绕过BOLT的检测逻辑来决定代码放置位置'
# "use a function's hot size when doing clustering"
H10032CBF870F: '在进行聚类时使用函数的热点大小'
# 'use a lock file so only one process in the system can run this pass at once. useful to avoid mangled debug output in multithreaded environments.'
H7CB74F0F7BF5: '使用锁文件，以便系统中仅一个进程可以同时运行此pass。用于避免多线程环境中调试输出被破坏的情况。'
# 'use a modified clustering algorithm geared towards minimizing branches'
HFDD79DC87D1A: '使用一种经过修改的、旨在减少分支的聚类算法'
# 'use absolute jump tables on ppc'
H88706E2F52B2: '在PPC上使用绝对跳转表'
# 'use aggressive ppc isel for bit permutations'
H99649C2F1B01: '在PPC上使用激进的isel指令选择进行位置换'
# 'use array indexing to silence this warning'
H85B32746AF01: '使用数组索引消除此警告'
# 'use ascending or descending order when printing functions ordered by dyno stats'
HF0A78325BB17: '按dyno统计信息排序时，打印函数时使用升序或降序'
# 'use branch prediction data to control sctc'
H2D5E124AB149: '使用分支预测数据控制sctc'
# 'use cache-directed sort'
H993E2A52F48B: '使用缓存导向排序'
# 'use constraint modifier "%0"'
H96B4F36A2D84: '使用约束修饰符“%0”'
# 'use declarations are only allowed in top-level modules'
HB528050B8967: '使用声明仅允许在顶层模块中'
# 'use edge count data when doing clustering'
H6F3C614822A7: '在进行聚类时使用边计数数据'
# 'use fast runtime behavior'
H2D5F50DA24D3: '使用快速运行时行为'
# "use function '%0' instead"
H30EA9A5A15F6: '改用函数‘%0’'
# 'use function order specified by -function-order'
H517260D51513: '使用由-function-order指定的函数顺序'
# 'use hfsort algorithm'
H6D5DE1F47100: '使用hfsort算法'
# 'use hot/cold data on basic blocks to determine hot sizes for call graph functions'
H898A061653FE: '使用基本块的热点/冷点数据来确定调用图函数的热点大小'
# 'use instrumentation with slow path for all accesses'
H244914CD834D: '对所有访问使用带有慢路径的插桩'
# 'use misprediction frequency for determining whether or not ICP should be applied at a callsite.  The -indirect-call-promotion-mispredict-threshold value will be used by this heuristic'
H3115132EB120: '使用间接调用处的误预测频率来决定是否应用ICP。-indirect-call-promotion-mispredict-threshold值将由该启发式方法使用'
# 'use non-reference type %0'
HE4A5CE8520B2: '使用非引用类型 %0'
# 'use non-reference type %0 to make construction explicit or type %1 to prevent copying'
HAB8A2938766C: '使用非引用类型 %0 显式构造，或使用类型 %1 防止复制'
# 'use nullability type specifier %0 to affect the innermost pointer type of %1'
HA9A4302606C7: '使用空值类型说明符 %0 影响 %1 的最内层指针类型'
# 'use of %0 with tag type that does not match previous declaration'
H4AAB2FCDDAB1: '使用与之前声明不匹配的标签类型 %0'
# 'use of %select{class template|function template|variable template|alias template|template template parameter|concept|template}0 %1 requires template arguments'
H8F99144D2E34: '使用%select{类模板|函数模板|变量模板|别名模板|模板模板参数|概念|模板}0 %1 需要模板实参'
# 'use of %select{infinity|NaN}0%select{| via a macro}1 is undefined behavior due to the currently enabled floating-point options'
H18AE2A8F681F: '使用%select{无穷大|NaN}0%select{|通过宏}1由于当前启用的浮点选项导致未定义行为'
# 'use of %select{type|declaration}0 %1 requires %2 support'
H39DB55887936: '使用 %select{类型|声明}0 %1 需要 %2 支持'
# "use of '@import' in framework header is discouraged, including this header requires -fmodules"
H455C5312D820: "在框架头文件中使用 '@import' 不被推荐，包含此头文件需要启用 -fmodules"
# "use of '@import' when modules are disabled"
HE80AA99C30B1: "禁用模块时使用 '@import'"
# "use of '__int128' with '__vector bool' requires VSX support enabled (on POWER10 or later)"
HBB36DE187BFD: "使用 '__int128' 与 '__vector bool' 需要启用 VSX 支持（适用于 POWER10 或更高版本）"
# "use of '__int128' with '__vector' requires extended Altivec support (available on POWER8 or later)"
H02493A6B8143: "使用 '__int128' 与 '__vector' 需要扩展的 Altivec 支持（适用于 POWER8 或更高版本）"
# "use of '__super' inside a lambda is unsupported"
H5812045C24A5: "在 lambda 内使用 '__super' 是不受支持的"
# "use of 'double' with '__vector' requires VSX support to be enabled (available on POWER7 or later)"
HFF794EBE240D: "使用 'double' 与 '__vector' 需要启用 VSX 支持（适用于 POWER7 或更高版本）"
# "use of 'long long' with '__vector' requires VSX support (available on POWER7 or later) to be enabled"
HEDE074D6F05D: "使用 'long long' 与 '__vector' 需要启用 VSX 支持（适用于 POWER7 或更高版本）"
# "use of 'long' with '__vector' is deprecated"
H194F4A31DAD4: "使用 'long' 与 '__vector' 是已弃用的"
# "use of 'operator->' on type %0 would invoke a sequence of more than %1 'operator->' calls"
HE55B12BF8DE6: "使用类型 %0 的 'operator->' 会触发超过 %1 次 'operator->' 调用序列"
# "use of 'static_assert' without inclusion of <assert.h> is a Microsoft extension"
HFC681B3993FC: "未包含 <assert.h> 时使用 'static_assert' 是 Microsoft 扩展"
# "use of 'template' keyword outside of a template is incompatible with C++98"
HADE615C257C6: "在模板外使用 'template' 关键字与 C++98 不兼容"
# 'use of @defs is not supported on this architecture and platform'
HA2315B23A421: '在此架构和平台上不支持使用 @defs'
# 'use of C-style parameters in Objective-C method declarations is deprecated'
H124575A24936: '在 Objective-C 方法声明中使用 C 风格参数已弃用'
# "use of GNU 'missing =' extension in designator"
HE3037B23921A: '使用 GNU 缺失 "=" 扩展在设计符中'
# 'use of GNU ?: conditional expression extension, omitting middle operand'
H0DE762B90B0D: '使用 GNU ?: 条件表达式扩展，省略中间操作数'
# 'use of GNU address-of-label extension'
HA7B26095AD53: '使用 GNU address-of-label 扩展'
# 'use of GNU array range extension'
H678FC3DF1C6F: '使用 GNU 数组范围扩展'
# 'use of GNU indirect-goto extension'
H3D429B23EFAC: '使用 GNU 间接 goto 扩展'
# 'use of GNU old-style field designator extension'
H85575BE49C11: '使用 GNU 旧式字段指定符扩展'
# 'use of GNU statement expression extension'
HD7924EDC2399: '使用 GNU 语句表达式扩展'
# 'use of GNU statement expression extension from macro expansion'
HDFF296407839: '通过宏展开使用 GNU 语句表达式扩展'
# 'use of NULL in arithmetic operation'
H72A441293B63: '在算术运算中使用 NULL'
# 'use of Objective-C property in function nested in Objective-C container not supported, move function outside its container'
H1B2603FEAF82: '在 Objective-C 容器嵌套的函数中使用 Objective-C 属性不被支持，需将函数移至容器外部'
# 'use of __private_extern__ on a declaration may not produce external symbol private to the linkage unit and is deprecated'
HC7A56E0EB4D2: '在声明中使用 __private_extern__ 可能无法生成链接单元私有外部符号，并已弃用'
# "use of a '#%select{<BUG IF SEEN>|elifdef|elifndef}0' directive is a C++23 extension"
H6A5DD5BE1302: '使用 "#%select{<BUG IF SEEN>|elifdef|elifndef}0" 指令是 C++23 扩展'
# "use of a '#%select{<BUG IF SEEN>|elifdef|elifndef}0' directive is a C23 extension"
H0BF82439932C: '使用 "#%select{<BUG IF SEEN>|elifdef|elifndef}0" 指令是 C23 扩展'
# "use of a '#%select{<BUG IF SEEN>|elifdef|elifndef}0' directive is incompatible with C standards before C23"
HDFCC088F181F: '使用 "#%select{<BUG IF SEEN>|elifdef|elifndef}0" 指令与 C23 之前的标准不兼容'
# "use of a '#%select{<BUG IF SEEN>|elifdef|elifndef}0' directive is incompatible with C++ standards before C++23"
H16A663A66375: '使用 "#%select{<BUG IF SEEN>|elifdef|elifndef}0" 指令与 C++23 之前的标准不兼容'
# 'use of address-of-label extension outside of a function body'
HEBDAFDF05EDA: '在函数体外使用地址-标签扩展'
# 'use of an empty initializer is a C23 extension'
HD0F8B4BA3FB2: '使用空初始化器是 C23 扩展'
# 'use of an empty initializer is incompatible with C standards before C23'
H28862631C8FD: '使用空初始化器与 C23 之前的标准不兼容'
# "use of bitwise '%0' with boolean operands"
H3DCD98477290: '对布尔操作数使用按位 "%0" 运算符'
# 'use of default argument to function %0 that is declared later in class %1'
HBEFC6E561806: '使用在类 %1 后续声明的函数 %0 的默认参数'
# 'use of dynamic_cast requires -frtti'
HE86B35BE234A: '使用 dynamic_cast 需要 -frtti 选项'
# 'use of empty enum'
H0A3EEAE0C204: '使用空枚举'
# 'use of enumeration in a nested name specifier is a C++11 extension'
H9F1C227C8017: '在嵌套名称说明符中使用枚举是 C++11 扩展'
# 'use of function %0 is discouraged; there is no way to check for failure but failure may still occur, resulting in a possibly exploitable security vulnerability'
H123B46BAB412: '使用函数 %0 不被推荐；该函数可能出现无法检测的失败，从而导致可被利用的安全漏洞'
# 'use of function template name with no prior declaration in function call with explicit template arguments is a C++20 extension'
H17E19DFB3C7C: '在显式模板参数的函数调用中使用未声明的函数模板名称是 C++20 扩展'
# 'use of function template name with no prior declaration in function call with explicit template arguments is incompatible with C++ standards before C++20'
H640DD80A631A: '在显式模板实参的函数调用中使用未预先声明的函数模板名称与C++20之前的版本不兼容'
# "use of incomplete type %0 in a '_Generic' association is incompatible with C standards before C2y"
H805F57844181: "在 '_Generic' 关联中使用不完整类型 %0 不符合 C2y 之前的 C 标准"
# "use of logical '%0' with constant operand"
H91174008E58D: '在常量操作数中使用逻辑运算符 "%0"'
# 'use of member %0 before its declaration is a Microsoft extension'
HF1849841B9E7: '在声明前使用成员 %0 是 Microsoft 扩展'
# 'use of member %0 found via unqualified lookup into dependent bases of class templates is a Microsoft extension'
H8CD447C8CC3A: '通过非限定查找访问类模板的依赖基类中的成员 %0 是 Microsoft 扩展'
# 'use of multiple declarators in a single using declaration is a C++17 extension'
H82698382734A: '在单个 using 声明中使用多个声明符是 C++17 扩展'
# 'use of multiple declarators in a single using declaration is incompatible with C++ standards before C++17'
HF5A1B33A1986: '在单个 using 声明中使用多个声明符不符合 C++17 之前的 C++ 标准'
# "use of non-standard escape character '\\%0'"
H8F21313E1DFF: "使用非标准转义字符 '\\%0'"
# 'use of non-static data member %0 in an unevaluated context is incompatible with C++98'
H47868E15CED8: '在未求值上下文中使用非静态数据成员 %0 不符合 C++98 标准'
# 'use of null pointer as non-type template argument is incompatible with C++98'
H6944D3B803C2: '将空指针用作非类型模板实参不符合 C++98 标准'
# 'use of old-style cast'
H0C8605CE0E58: '使用旧式类型转换'
# 'use of out-of-scope declaration of %0%select{| whose type is not compatible with that of an implicit declaration}1'
H9DFA1FDF94B0: '使用超出作用域的声明 %0%select{| 其类型与隐式声明的类型不兼容}1'
# "use of overloaded operator '%0' is ambiguous (operand type %1)"
H4300BB2DDBA6: "重载运算符 '%0' 的使用存在歧义（操作数类型 %1）"
# "use of overloaded operator '%0' is ambiguous (with operand types %1 and %2)"
H792DBC228D1F: "重载运算符 '%0' 的使用存在歧义（操作数类型 %1 和 %2）"
# 'use of placement new requires explicit declaration'
H992499F64501: '使用 placement new 需要显式声明'
# "use of private header from outside its module: '%0'"
H4B3CFE33871D: "从其模块外部使用私有头文件: '%0'"
# 'use of reference outside its lifetime is not allowed in a constant expression'
H2C7D8C6358B3: '在常量表达式中使用超出生命周期的引用是不允许的'
# 'use of result of assignment to object of volatile-qualified type %0 is deprecated'
H0FD6FA3111E8: '使用 volatile 限定类型 %0 的赋值结果属于已弃用用法'
# "use of right-shift operator ('>>') in template argument will require parentheses in C++11"
H4B1C2F8BF668: "在 C++11 中模板实参中使用右移运算符 ('>>') 需要显式添加括号"
# 'use of the %0 attribute is a C++14 extension'
HD7333826DEB8: '使用 %0 属性是C++14的扩展'
# 'use of the %0 attribute is a C++17 extension'
H9D6E9F75124A: '使用 %0 属性是C++17的扩展'
# 'use of the %0 attribute is a C++20 extension'
H85EE1317CADA: '使用 %0 属性是C++20的扩展'
# 'use of the %0 attribute is a C++23 extension'
H3769FB94DD63: '使用 %0 属性是C++23的扩展'
# 'use of this expression in an %0 attribute requires parentheses'
H4B6BF2EAA0DF: '在 %0 属性中使用此表达式需要括号'
# 'use of this statement in a constexpr %select{function|constructor}0 is a C++14 extension'
H009816A3B264: '在constexpr %select{函数|构造函数}0中使用此语句是C++14的扩展'
# 'use of this statement in a constexpr %select{function|constructor}0 is a C++20 extension'
H383EABB05A34: '在constexpr %select{函数|构造函数}0中使用此语句是C++20的扩展'
# 'use of this statement in a constexpr %select{function|constructor}0 is a C++23 extension'
H3CD433F9DEED: '在constexpr %select{函数|构造函数}0中使用此语句是C++23的扩展'
# 'use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14'
HDB9F101C6FD8: '在constexpr %select{函数|构造函数}0中使用此语句与C++14之前的C++标准不兼容'
# 'use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++20'
H10E657C568DA: '在constexpr %select{函数|构造函数}0中使用此语句与C++20之前的C++标准不兼容'
# 'use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++23'
HBB6862211968: '在constexpr %select{函数|构造函数}0中使用此语句与C++23之前的C++标准不兼容'
# 'use of typeid requires -frtti'
H6516CAF74372: '使用typeid需要-frtti选项'
# 'use of unary operator that may be intended as compound assignment (%0=)'
H52686183E946: '使用可能意图作为复合赋值运算符（%0=）的一元运算符'
# 'use of undeclared %0'
H4249B6D3D66A: '使用未声明的 %0'
# 'use of undeclared %0; did you mean %1?'
H152AECD0CF73: '使用未声明的 %0；是否是指 %1？'
# 'use of undeclared identifier %0'
H2DA2A4EF5956: '使用未声明的标识符 %0'
# 'use of undeclared identifier %0; did you mean %1?'
H448AE4CE2F58: '使用未声明的标识符 %0；是否是指 %1？'
# 'use of undeclared identifier %0; unqualified lookup into dependent bases of class template %1 is a Microsoft extension'
HB6A34859F540: '使用未声明的标识符 %0；类模板 %1 的依赖基类中未限定查找是Microsoft扩展'
# 'use of undeclared label %0'
H685C1928674B: '使用未声明的标签 %0'
# "use of undefined marker '%0'"
HAEC3C6045C74: "使用未定义的标记 '%0'"
# 'use of unknown builtin %0'
HBFCE16721923: '使用未知的内建函数 %0'
# 'use old code sequence for promoted calls'
H27311E45E8D5: '为提升的调用使用旧代码序列'
# 'use perf data directly when constructing the call graph for stale functions'
H9C843E88A00A: '在构建过时函数的调用图时直接使用perf数据'
# 'use precise runtime behavior'
H864CB2EB7B9A: '使用精确的运行时行为'
# 'use reference type %0 to prevent copying'
H96F12D2BC3F2: '使用引用类型 %0 以防止拷贝'
# 'use register liveness analysis to try to find more opportunities for -reg-reassign optimization'
H7BCD305B01BE: '使用寄存器存活分析尝试为-reg-reassign优化寻找更多机会'
# 'use regular size pages for code alignment'
H041AAF5448A5: '使用标准大小的页对齐代码'
# 'use relaxed runtime behavior'
H386C9EF15D8D: '使用宽松的运行时行为'
# 'use relocations in the binary (default=autodetect)'
HA2145EBF1AF4: '在二进制中使用重定位信息（默认=自动检测）'
# 'use same count for BBs that should have equivalent count (used in non-LBR and shrink wrapping)'
H2FCA1FC45D12: '为应具有等效计数的BB块使用相同计数（用于非LBR和收缩包装场景）'
# "use same version number separators '_' or '.'; as in 'major[.minor[.subminor]]'"
H152CFF6748B3: "请使用相同的版本号分隔符 '_' 或 '.'，例如 'major[.minor[.subminor]]'"
# 'use short granules in allocas and outlined checks'
H1D7871DD27F1: '在allocas和分离检查中使用短粒度'
# 'use strict dwarf'
HD69F3507E82F: '使用严格DWARF'
# 'use stricter verifier for FIR operations with volatile types'
H2542C8B1617A: '对带有volatile类型的FIR操作使用更严格的验证器'
# 'use stricter verifier for HLFIR intrinsic operations'
H7296989D6AE9: '为HLFIR内建操作使用更严格的验证器'
# "use the GNU '__attribute__' syntax"
H7DBF5BB23C34: "使用GNU的 '__attribute__' 语法"
# 'used here'
H1359FF249380: '在此处使用'
# 'used in initialization here'
H9614905D4DE2: '在此初始化中使用'
# 'used type %0 where __hlsl_resource_t is required'
HB0299AD4C891: '此处使用类型 %0，但需要__hlsl_resource_t类型'
# 'used type %0 where arithmetic or pointer type is required'
HEF054774D419: '此处使用类型 %0，但需要算术类型或指针类型'
# 'used type %0 where floating point type is not allowed'
HF095E0FB08EE: '此处使用类型 %0，但不允许使用浮点类型'
# 'used type %0 where integer is required'
HCD053F3A5F86: '此处使用类型 %0，但需要整数类型'
# 'used type %0 where integer or floating point type is required'
H46DF1623ED73: '此处使用类型 %0，但需要整数或浮点类型'
# 'used%select{| in pointer arithmetic| in buffer access}0 here'
H2D0FA9F859F9: '此处%select{使用|在指针运算中使用|在缓冲区访问中使用}0'
# "user-defined literal suffixes %select{<ERROR>|not starting with '_'|containing '__'}0 are reserved%select{; no literal will invoke this operator|}1"
H414028466FC2: '用户定义的字面量后缀 %select{<ERROR>|不以 "_" 开头|包含 "__"}0 是保留的%select{；没有字面量会调用此运算符|}1'
# 'using'
H92BD75EBD8FD: '使用'
# 'using %0 directive in %select{NSString|CFString}1 which is being passed as a formatting argument to the formatting %select{method|CFfunction}2'
HFA21A8452E12: '在 %select{NSString|CFString}1 中使用 %0 指令，该指令作为格式参数传递给格式%select{方法|CF函数}2'
# 'using %0 with a literal is redundant'
HA26F40AA0176: '与字面量一起使用 %0 是多余的'
# 'using %select{integer|floating point|complex}1 absolute value function %0 when argument is of %select{integer|floating point|complex}2 type'
H2A1C61EF88A1: '当参数为%select{整数|浮点|复数}2类型时，使用%select{整数|浮点|复数}1类型的绝对值函数 %0'
# "using '%%P' format specifier with an Objective-C pointer results in dumping runtime object structure, not object value"
H513C1ECC12E7: '在Objective-C指针中使用 "%%P" 格式说明符会导致转储运行时对象结构，而不是对象值'
# "using '%%P' format specifier without precision"
HE89A56274479: '未指定精度时使用 "%%P" 格式说明符'
# "using '%0' format specifier annotation outside of os_log()/os_trace()"
H2CE6DDE79E74: '在os_log()/os_trace()之外使用 "%0" 格式说明符注释'
# "using '%0' format specifier, but argument has boolean value"
HDDBB822724E7: "使用 '%0' 格式说明符，但参数具有布尔值"
# "using declaration annotated with 'using_if_exists' here"
HDB8ACBC0FBF5: "此处使用标注有 'using_if_exists' 的声明"
# 'using declaration cannot refer to a constructor'
HF62840A086D5: 'using声明不能引用构造函数'
# 'using declaration cannot refer to a destructor'
HE836ECBAB540: 'using声明不能引用析构函数'
# 'using declaration cannot refer to a namespace'
H0DDDFEE0D0FD: 'using声明不能引用命名空间'
# 'using declaration cannot refer to a template specialization'
H99346E56FD07: 'using声明不能引用模板特化'
# 'using declaration cannot refer to class member'
H667DB55E8D61: 'using声明不能引用类成员'
# 'using declaration in class refers into %0, which is not a class'
H703FE2D02B05: '类中的 using 声明引用到 %0，但该类型不是类'
# 'using declaration naming a scoped enumerator is a C++20 extension'
H5CF0B64CDA35: 'using声明引用作用域枚举是C++20扩展'
# 'using declaration naming a scoped enumerator is incompatible with C++ standards before C++20'
H52802307DDAC: 'using声明引用作用域枚举与C++20之前的标准不兼容'
# 'using declaration pack expansion at block scope produces multiple values'
HFC5BC61E58BC: '块作用域中的using声明包展开会产生多个值'
# 'using declaration referring to %1 with %select{internal|module|unknown}0 linkage cannot be exported'
HFDD1D0A3610E: '引用具有%select{内部|模块|未知}0链接的 %1 的using声明无法导出'
# "using declaration referring to inaccessible member '%0' (which refers to accessible member '%1') is a Microsoft compatibility extension"
HA7AB89787DCC: "引用不可访问成员 '%0'（其指向可访问成员 '%1'）是Microsoft兼容扩展"
# 'using declaration refers into %0, which is not a base class of %1'
HE8EC9FE5FD16: 'using 声明引用到 %0，但该类型不是 %1 的基类'
# 'using declaration refers to its own class'
H435B6D84F0D6: 'using声明引用其自身类'
# 'using declaration requires a qualified name'
H9CE75E7C4CF5: 'using声明需要限定名称'
# "using directive refers to implicitly-defined namespace 'std'"
H5C8831D062A8: 'using指令引用隐式定义的命名空间 "std"'
# 'using enum %select{requires an enum or typedef name|does not permit an elaborated enum specifier}0'
H07DCC7345590: '使用枚举%select{需要枚举或typedef名称|不允许使用扩展的枚举说明符}0'
# 'using enum declaration is a C++20 extension'
H30E94CBBC49F: 'using enum声明是C++20扩展'
# 'using enum declaration is incompatible with C++ standards before C++20'
HA6B3DF063338: 'using enum声明与C++20之前的标准不兼容'
# "using length modifier '%0' with conversion specifier '%1' is not supported by ISO C"
HCAD96DA2A48D: "使用长度修饰符 '%0' 与转换说明符 '%1' 不受ISO C支持"
# 'using namespace directive in global context in header'
HDFF3F4F00DD3: '头文件全局作用域中使用using命名空间指令'
# "using sysroot for '%0' but targeting '%1'"
H23CBFE9436FA: "使用 '%0' 的sysroot，但目标平台是 '%1'"
# 'using the result of an assignment as a condition without parentheses'
HD808A1E3A9FB: '将赋值表达式的结果用作条件时未使用括号'
# 'using the undeclared type %0 as a default template argument is a Microsoft extension'
H9BAAEE7535FA: '将未声明的类型 %0 作为默认模板参数是Microsoft扩展'
# 'using unversioned Android target directory %0 for target %1; unversioned directories will not be used in Clang 19 -- provide a versioned directory for the target version or lower instead'
H120D3110B47A: '为目标 %1 使用未版本化的Android目标目录 %0；Clang 19 将不再使用未版本化的目录——请为对应版本提供版本化的目录或使用更低版本'
# 'using-enum cannot name a dependent type'
H3DC57F2168E8: 'using-enum不能命名一个相关依赖类型'
# 'usual LSP protocol'
H562B11D542B5: '常规LSP协议'
# 'uuid attribute contains a malformed GUID'
H1FAF5254B686: 'uuid属性包含格式错误的GUID'
# 'uuid does not match previous declaration'
H1E8E115FA4D8: 'uuid与之前的声明不匹配'
# 'valid %0 clauses start with %1; %select{token|tokens}2 will be ignored'
HA977999237FF: '有效的 %0 子句以 %1 开头；%select{token|tokens}2 将被忽略'
# 'valid target CPU values are: %0'
HB573A028A656: '有效的目标CPU值为：%0'
# 'value %0 is outside the range of representable values of type %1'
H76B206381D68: '值 %0 超出类型 %1 可表示的范围'
# 'value %1 cannot be represented in type %0'
H0FCCEC09B538: '值 %1 无法用类型 %0 表示'
# "value '%0' out of range for constraint '%1'"
H2964C78586A1: "值 '%0' 超出约束 '%1' 的范围"
# 'value is not an integer: %0'
HDF6724275715: '值不是整数：%0'
# 'value of #pragma pack(show) == %0'
H78F0B6172824: '#pragma pack(show)的值为 %0'
# 'value of the aligned pointer (%0) is not a multiple of the asserted %1 %plural{1:byte|:bytes}1'
HCBC69FE1B218: '对齐指针的值(%0)不是声明的 %1 %plural{1:字节|:字节}1的倍数'
# "value of type %0 is not contextually convertible to 'bool'"
H8D6D08CCD77E: "类型 %0 的值无法上下文转换为 'bool'"
# 'value of type %0 is not implicitly convertible to %1'
H7F07136EE80D: '类型 %0 的值无法隐式转换为 %1'
# "value returned by '__builtin_counted_by_ref' cannot be %select{assigned to a variable|passed into a function|returned from a function}0"
H0D53FCA7346F: "由 '__builtin_counted_by_ref' 返回的值不能%select{被赋值给变量|被传递给函数|从函数返回}0"
# "value returned by '__builtin_counted_by_ref' cannot be used in %select{an array subscript|a binary}0 expression"
H4F263548602C: "'__builtin_counted_by_ref' 返回的值不能用于%select{数组下标|二进制}0表达式"
# 'value size does not match register size specified by the constraint and modifier'
H45E5585EA0B2: '值大小与约束和修饰符指定的寄存器大小不匹配'
# 'varargs not allowed in requires expression'
H65BA20F3C0FC: 'requires表达式中不允许使用可变参数'
# "variable %0 cannot be declared both 'extern' and with the 'loader_uninitialized' attribute"
H66B3CD6187EF: "变量 %0 不能同时声明为 'extern' 和带有 'loader_uninitialized' 属性"
# 'variable %0 cannot be implicitly captured in a lambda with no capture-default specified'
H17BA614E3EF4: '在未指定捕获默认方式的lambda中不允许隐式捕获变量 %0'
# 'variable %0 cannot be threadprivate because it is %select{thread-local|a global named register variable}1'
HF72C764C6D1B: '变量 %0 不能是线程私有变量，因为它%select{是线程局部变量|是命名寄存器全局变量}1'
# 'variable %0 is %select{decremented|incremented}1 both in the loop header and in the loop body'
H5880C36D679C: '变量 %0 在循环头和循环体中均被%select{递减|递增}1'
# "variable %0 is %select{used|captured}1 uninitialized whenever %select{'%3' condition is %select{true|false}4|'%3' loop %select{is entered|exits because its condition is false}4|'%3' loop %select{condition is true|exits because its condition is false}4|switch %3 is taken|its declaration is reached|%3 is called}2"
H5B3E786190C7: "当 %select{'%3' 条件%select{为真|为假}4|'%3' 循环%select{被进入|因条件为假退出}4|'%3' 循环%select{条件为真|因条件为假退出}4|switch %3 被选中|其声明被访问|%3 被调用}2时，变量 %0 在%select{使用|被捕获}1时未初始化"
# 'variable %0 is declared here'
H9C1D29CE922D: '变量 %0 在此处声明'
# 'variable %0 is uninitialized when %select{used here|captured by block}1'
HC11F7DAD1A0E: '变量 %0 在%select{此处使用时|被捕获到块中时}1时未初始化'
# 'variable %0 is uninitialized when passed as a const reference argument here'
H12F79B618200: '变量 %0 在作为常量引用参数传递时未初始化'
# 'variable %0 is uninitialized when used within its own initialization'
H9B3210B51205: '变量 %0 在自身初始化过程中使用时未初始化'
# 'variable %0 is%select{| explicitly}1 captured here'
HC5A87C36FF05: '变量 %0%select{被显式|}1 在此处捕获'
# 'variable %0 may be uninitialized when %select{used here|captured by block}1'
HC0A7D9F9078D: '变量 %0 可能在%select{此处使用时|被捕获到块中时}1时未初始化'
# 'variable %0 must have explicitly specified data sharing attributes'
H9EFAEC625413: '变量 %0 必须显式指定数据共享属性'
# 'variable %0 must have explicitly specified data sharing attributes, data mapping attributes, or in an is_device_ptr clause'
H577354E45CD4: '变量 %0 必须显式指定数据共享属性、数据映射属性，或出现在is_device_ptr子句中'
# 'variable %0 set but not used'
H9EEEA592434A: '变量 %0 被赋值但未使用'
# 'variable %0 with flexible array member cannot be captured in a lambda expression'
HEE231707A80F: '具有柔性数组成员的变量 %0 不能被捕获到lambda表达式中'
# 'variable %0 with type %1 has incompatible initializer of type %2'
HECE6754B3154: '类型为 %1 的变量 %0 具有类型 %2 的不兼容初始值'
# 'variable %0 with unknown type cannot be given a function type'
HBD6B0E34602F: '类型未知的变量 %0 不能被赋予函数类型'
# 'variable %select{|in unary expression|on right hand side of assignment|on left hand side of assignment|on left hand side of compound assignment|on left hand side of assignment}2(%3) must match variable used %select{|in unary expression|on right hand side of assignment|<not possible>|on left hand side of compound assignment|on left hand side of assignment}0(%1) from the first statement'
HA70BF8F524C0: '在 %select{|一元表达式中|赋值表达式的右操作数|赋值表达式的左操作数|复合赋值的左操作数|赋值表达式的左操作数}2中使用的变量 %3 必须与在 %select{|一元表达式中|赋值表达式的右操作数|<不可能>|复合赋值的左操作数|赋值表达式的左操作数}0中使用的变量 %1（第一条语句）保持一致'
# 'variable already marked as mapped in current construct'
HA15930719644: '变量已在当前上下文中被标记为映射'
# "variable appearing in '%0' clause of OpenACC 'declare' directive must be in the same scope as the directive"
H32CD6FB44C7B: "在OpenACC 'declare' 指令的 '%0' 子句中出现的变量必须与指令处于同一作用域"
# "variable can appear only once in OpenMP '%0' clause"
H084B181F0F6F: "OpenMP '%0' 子句中的变量只能出现一次"
# "variable can appear only once in OpenMP 'target update' construct"
H78D2AF4A7A62: "OpenMP 'target update' 构造中的变量只能出现一次"
# 'variable captured in declare target region must appear in a to clause'
H2004C3E36B6D: '在declare target区域捕获的变量必须出现在to子句中'
# 'variable declaration in a constexpr %select{function|constructor}0 is a C++14 extension'
H953C3A7294B8: '在constexpr %select{函数|构造函数}0中的变量声明是C++14扩展'
# 'variable declaration in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14'
H5037F674FC7B: '在constexpr %select{函数|构造函数}0中的变量声明与C++14之前的版本不兼容'
# 'variable declaration in condition cannot have a parenthesized initializer'
HA7027EDD1E14: '条件中的变量声明不能带有括号初始化器'
# 'variable declaration in condition must have an initializer'
H031DEC12DA47: '条件中的变量声明必须具有初始化器'
# 'variable declaration in for loop is a C99-specific feature'
HCED2B7B23919: '在for循环中声明的变量是C99特有功能'
# 'variable declared constinit here'
HBD9CCEC96BCC: '此处声明的constinit变量'
# "variable declared with 'objc_externally_retained' cannot be modified in ARC"
H47C52BC3E77D: "'objc_externally_retained' 声明的变量在ARC中不可修改"
# 'variable does not have a constant initializer'
HB267A973AA07: '变量没有常量初始化器'
# 'variable has incomplete type %0'
HF07B48579A53: '变量具有不完整类型 %0'
# 'variable in constant address space must be initialized'
H66FDD0998C58: '常量地址空间中的变量必须被初始化'
# 'variable is not assignable (missing __block type specifier)'
HAA0B269B98F3: '变量不可分配（缺少__block类型说明符）'
# 'variable length array cannot be formed during template argument deduction'
HF26A880CF088: '模板参数推导期间无法形成变量长度数组'
# "variable length array declaration cannot have 'extern' linkage"
H2436B28C5991: "变量长度数组声明不能具有 'extern' 链接"
# "variable length array declaration cannot have 'static' storage duration"
H9C9D3E1402A9: "可变长数组声明不能具有 'static' 存储持续期"
# 'variable length array declaration not allowed at file scope'
H01CDB7349FFD: '在文件作用域中不允许声明可变长数组'
# 'variable length array folded to constant array as an extension'
H861F6896A4A9: '作为扩展，将可变长数组折叠为常量数组'
# 'variable length array must be bound in function definition'
HACDD33225FC5: '可变长数组必须在函数定义中确定大小'
# 'variable length array used'
HFCB17814F664: '使用了可变长数组'
# 'variable length arrays are a C99 feature'
H82A7E9913A2F: '可变长数组是C99特性'
# "variable length arrays are not supported %select{for the current target|in '%1'}0"
H5707BCACEAC8: '可变长数组%select{当前目标不支持|在 "%1" 中不支持}0'
# 'variable length arrays are not supported for the current target'
H50B2A4B545B7: '当前目标不支持可变长数组'
# 'variable length arrays are not supported in OpenCL'
H201996231D1A: 'OpenCL中不支持可变长数组'
# "variable length arrays are not supported in OpenMP tasking regions with 'untied' clause"
H20FB8AB94029: '在带有 "untied" 子句的OpenMP任务区域中不支持可变长数组'
# 'variable length arrays in C++ are a Clang extension'
HCD7C2CD01723: 'C++中的可变长数组是Clang扩展'
# "variable length arrays in C++ are a Clang extension; did you mean to use 'static_assert'?"
H53E1EE683577: "C++中的可变长数组是Clang扩展；是否想使用 'static_assert'？"
# 'variable length arrays in a coroutine are not supported'
HD279E72346CE: '协程中的可变长数组不被支持'
# 'variable must be of integer or %select{pointer|random access iterator}0 type'
H4F34EF5C94E2: '变量必须为整数或%select{指针|随机访问迭代器}0类型'
# "variable named 'main' with external linkage has undefined behavior"
H38BA25ED2BA1: "具有外部链接的名为 'main' 的变量具有未定义行为"
# 'variable of non-literal type %1 cannot be defined in a constexpr %select{function|constructor}0 before C++23'
H5F89C6201D7E: '非字面类型 %1 的变量在C++23之前不能在constexpr %select{函数|构造函数}0中定义'
# "variable of non-reference type %0 can be used only with 'val' modifier, but used with '%1'"
HFF57CDDBE63D: '非引用类型 %0 的变量只能与 "val" 修饰符一起使用，但实际使用了 "%1"'
# 'variable of type %1 has %select{private|protected}2 destructor'
H8BC8C9632B1A: '类型 %1 的变量具有 %select{private|protected}2 访问权限的析构函数'
# "variable referenced by 'link' clause not in global or namespace scope must be marked 'extern'"
HF7968BA9CE92: "'link' 子句引用的不在全局或命名空间作用域中的变量必须标记为 'extern'"
# "variable referenced in '%0' clause of OpenACC 'declare' directive was already referenced"
H8FFABBD53A56: "在OpenACC 'declare' 指令的 '%0' 子句中引用的变量已被先前引用过"
# 'variable template partial specialization %0 cannot be redefined'
HB5621CB8D5D4: '变量模板的部分特化 %0 不能被重新定义'
# 'variable templates are a C++14 extension'
H031A6133F773: '变量模板是C++14的扩展功能'
# 'variable templates are incompatible with C++ standards before C++14'
HC36BFC632A54: '变量模板与C++14之前的C++标准不兼容'
# "variable with 'loader_uninitialized' attribute cannot have an initializer"
H9908D11CFEF9: "具有 'loader_uninitialized' 属性的变量不能有初始化器"
# "variable with 'loader_uninitialized' attribute must have a trivial default constructor"
H30559420B01D: "具有 'loader_uninitialized' 属性的变量必须具有平凡的默认构造函数"
# 'variable with local storage in initial value of threadprivate variable'
H06BE1F004442: '线程私有变量的初始值中包含具有局部存储的变量'
# 'variable%select{s| %1|s %1 and %2|s %1, %2, and %3|s %1, %2, %3, and %4}0 used in loop condition not modified in loop body'
H78CB81888F63: '变量 %select{s| %1|s %1 和 %2|s %1、%2 和 %3|s %1、%2、%3 和 %4}0 在循环条件中使用，但在循环体内未被修改'
# 'variable-sized object may not be initialized'
HF22D786D9F31: '可变大小的对象不能被初始化'
# 'variables in function scope cannot be declared static'
H588D8DBF6957: '函数作用域内的变量不能声明为static'
# 'variables in the %0 address space can only be declared in the outermost scope of a kernel function'
H077534025BE2: '位于 %0 地址空间的变量只能在核函数的最外层作用域中声明'
# 'variably modified type %0 cannot be used as a template argument'
H43ADD4446C3D: '可变修改类型 %0 不能用作模板参数'
# "variably modified type declaration cannot have 'extern' linkage"
H31174A21A725: '可变修改类型的声明不能具有extern链接性'
# 'variably modified type declaration not allowed at file scope'
H0326E5892284: '不允许在文件作用域中声明可变修改类型'
# 'variably-modified type %0 cannot be used in a constexpr %select{function|constructor}1'
HA78DFABA86CF: '可变修改类型 %0 不能在constexpr %select{函数|构造函数}1中使用'
# "variadic 'friend' declarations are a C++2c extension"
H3D2FFF66A145: '可变参数的 "friend" 声明是C++2c的扩展'
# "variadic 'friend' declarations are incompatible with C++ standards before C++2c"
H365CB532BF3E: '可变参数的 "friend" 声明与C++2c之前的C++标准不兼容'
# 'variadic function cannot use %0 calling convention'
HEC894E082768: '可变参数函数不能使用 %0 调用约定'
# 'variadic macros are a C99 feature'
H6AA48F3D31FE: '可变参数宏是C99的特性'
# 'variadic macros are a Clang extension in OpenCL'
H1CAB7A29DC4C: '在OpenCL中，可变参数宏是Clang的扩展'
# 'variadic macros are incompatible with C++98'
H4BD20CD6A5E1: '可变参数宏与C++98不兼容'
# 'variadic templates are a C++11 extension'
H499FA3A280B8: '可变参数模板是C++11的扩展'
# 'variadic templates are incompatible with C++98'
H4B7B3608CF46: '可变参数模板与C++98不兼容'
# "variant function in '#pragma omp declare variant' is itself marked as '#pragma omp declare variant'"
H82A01F59E7E3: '在#pragma omp declare variant中声明的变体函数本身也被标记为#pragma omp declare variant'
# "variant in '#pragma omp declare variant' is the same as the base function"
HEC73C56687BA: '在#pragma omp declare variant中的变体与基函数类型相同'
# "variant in '#pragma omp declare variant' with type %0 is incompatible with type %1%select{| with appended arguments}2"
H443E0ACFD62A: '在#pragma omp declare variant中的变体类型 %0 与类型 %1%select{|附加参数}2不兼容'
# 'vector component access exceeds type %0'
HA6E77B2F0A3C: '向量组件访问超过类型 %0'
# 'vector component access has invalid length %0; supported lengths are: 1,2,3,4,8,16'
HCB71F9B8CFBC: '向量组件访问具有无效长度 %0；支持的长度为：1,2,3,4,8,16'
# "vector component name '%0' is a feature from OpenCL version 3.0 onwards"
H6B53729D7A1D: "向量组件名称 '%0' 是OpenCL 3.0及更高版本中的特性"
# 'vector condition type %0 and result type %1 do not have elements of the same size'
H9FFA8360C1AF: '向量条件类型 %0 和结果类型 %1 的元素大小不一致'
# 'vector condition type %0 and result type %1 do not have the same number of elements'
H48693917C57D: '向量条件类型 %0 和结果类型 %1 的元素数量不一致'
# 'vector initializers are not compatible with NEON intrinsics in big endian mode'
H20E090504D21: '向量初始化器与大端模式下的NEON内建函数不兼容'
# 'vector is not assignable (contains duplicate components)'
HA13B723E09E4: '该向量不可分配（包含重复的组件）'
# 'vector operands do not have the same elements sizes (%0 and %1)'
H20CF2F14B1AB: '向量操作数的元素大小不一致（%0 和 %1）'
# 'vector operands do not have the same number of elements (%0 and %1)'
H02E2D0489C4C: '向量操作数的元素数量不一致（%0 和 %1）'
# 'vector operands to the vector conditional must be the same type %diff{($ and $)|}0,1}'
HBD47DE4A7313: '向量条件运算符的向量操作数必须是相同类型 %diff{($和$)|}0,1}'
# 'vector size not an integral multiple of component size'
H77E12186A8E0: '向量大小不是组件大小的整数倍'
# "vectorize_width loop hint malformed; use vectorize_width(X, fixed) or vectorize_width(X, scalable) where X is an integer, or vectorize_width('fixed' or 'scalable')"
H52976DB4C3C0: "向量化宽度循环提示格式错误；请使用vectorize_width(X, fixed)或vectorize_width(X, scalable)，其中X为整数，或vectorize_width('fixed' 或 'scalable')"
# "vendor '%0' is not supported: '%1'"
HEF7F8EFDE1D2: "供应商 '%0' 不受支持：'%1'"
# 'verbose'
H3F73A838273F: 'verbose'
# 'verify structure of the log'
HA2B07D4BBAB9: '验证日志结构'
# 'verify the CFG after every pass'
H94E54A437791: '在每次转换后验证控制流图'
# 'verify-uselistorder Options'
HBF754C1F763D: 'verify-uselistorder 选项'
# "version '%0' in target triple '%1' is invalid"
H638A2A1C27BA: "目标三元组 '%1' 中的版本 '%0' 无效"
# 'version 1'
H58A74A7AA4A0: '版本 1'
# 'version 2'
H85DE840F8B53: '版本 2'
# 'version 3'
HA54E81A648CA: '版本 3'
# 'version 4'
H6BCF2142DE82: '版本 4'
# 'version control conflict marker in file'
H58D6C666A33F: '文件中存在版本控制冲突标记'
# "version for '%0' already specified"
HD1955B4EAF6D: "版本号 '%0' 已经被指定"
# 'version list contains duplicate entries'
HDC1A5F99BC1B: '版本列表包含重复项'
# "version list contains entries that don't impact code generation"
H346B24B0B01F: '版本列表包含不影响代码生成的条目'
# 'version number must have non-zero major, minor, or sub-minor version'
H32D5C8ECFF2D: '版本号必须包含非零的主版本、次版本或修订版本'
# 'violations found for %0'
HC357EBB7E4D0: '在 %0 中发现违规'
# 'virtual base class declared here'
H2738AB0FED80: '虚基类在此处声明'
# 'virtual constexpr functions are incompatible with C++ standards before C++20'
H0CA73C06B6D5: '虚constexpr函数与C++20之前的C++标准不兼容'
# "virtual destructor requires an unambiguous, accessible 'operator delete'"
H23281750E023: '虚析构函数需要明确且可访问的 "operator delete"'
# "virtual filesystem overlay file '%0' not found"
H26F74FB8B8C2: '未找到虚文件系统覆盖文件 "%0"'
# 'virtual function %0 has a different return type %diff{($) than the function it overrides (which has return type $)|than the function it overrides}1,2'
HD8B18D2DDADC: '虚函数 %0 的返回类型 %diff{($) 与它覆盖的函数（其返回类型为 $）不同|与它覆盖的函数不同}1,2'
# 'virtual function %0 has different attributes %diff{($) than the function it overrides (which has $)|than the function it overrides}1,2'
H105CB368BBFA: '虚函数 %0 的属性 %diff{($) 与它覆盖的函数（其属性为 $）不同|与它覆盖的函数不同}1,2'
# 'virtual function %0 has different calling convention attributes %diff{($) than the function it overrides (which has calling convention $)|than the function it overrides}1,2'
HB03FA37606B1: '虚函数 %0 的调用约定属性 %diff{($) 与它覆盖的函数（其调用约定为 $）不同|与它覆盖的函数不同}1,2'
# 'virtual function %q0 has more than one final overrider in %1'
H80394FC58D1D: '虚函数 %q0 在 %1 中有多个最终覆盖者'
# 'virtual function cannot be constexpr'
H01635D482A33: '虚函数不能是constexpr'
# 'virtual function cannot have a requires clause'
H138054D4510B: '虚函数不能带有requires子句'
# 'virtual functions are not supported in C++ for OpenCL'
H820F01CD9896: 'OpenCL中的C++不支持虚函数'
# 'virtual functions are unsupported in HLSL'
H207695B65E04: 'HLSL中不支持虚函数'
# 'virtual inheritance is unsupported in HLSL'
H8C2B278220B7: 'HLSL中不支持虚继承'
# "virtual method %0 is inside a 'final' class and can never be overridden"
HAC30D95A1570: '虚方法 %0 位于 "final" 类中，无法被覆盖'
# 'visibility does not match previous declaration'
H17040BB5EC03: '可见性与之前的声明不匹配'
# 'void %select{function|method|block}1 %0 should not return void expression'
HCA9EAB88160F: 'void %select{function|method|block}1 %0 不应返回 void 表达式'
# 'void block should not return a value'
H1C0762ECEC55: 'void block 不应返回值'
# 'volatile %select{temporary created|object declared|member declared}0 here'
HBA1E3AEA8BE2: 'volatile %select{临时创建的|声明的对象|声明的成员}0 此处'
# 'volatile qualifier in structured binding declaration is deprecated'
H8119BA6E8068: '在结构化绑定声明中使用 volatile 限定符已弃用'
# 'volatile-qualified parameter type %0 is deprecated'
H9F774F8B8E15: 'volatile 限定的参数类型 %0 已弃用'
# 'volatile-qualified return type %0 is deprecated'
H34762436C2FA: 'volatile 限定的返回类型 %0 已弃用'
# 'warn on trailing characters'
H82F663F8D48C: '对尾随字符发出警告'
# 'warnings are errors'
HB9FCBCA0C7DE: '将警告视为错误'
# 'was searched for in the directory: %0'
H4B8949005850: '在目录中搜索过： %0'
# 'wave good bye'
H29B5647E64A4: '挥手告别'
# 'weak %select{variable|property|implicit property|instance variable}0 %1 is accessed multiple times in this %select{function|method|block|lambda}2 but may be unpredictably set to nil; assign to a strong variable to keep the object alive'
H7F2B64A607B2: '在该 %select{函数|方法|块|lambda}2 中多次访问 weak %select{变量|属性|隐式属性|实例变量}0 %1，但可能不可预测地被设为 nil；将其赋值给 strong 变量以保持对象存活'
# 'weak %select{variable|property|implicit property|instance variable}0 %1 may be accessed multiple times in this %select{function|method|block|lambda}2 and may be unpredictably set to nil; assign to a strong variable to keep the object alive'
H301C12832949: '在该 %select{函数|方法|块|lambda}2 中多次访问 weak %select{变量|属性|隐式属性|实例变量}0 %1，可能被不可预测地设为 nil；将其赋值给 strong 变量以保持对象存活'
# 'weak attribute declared on a __strong type property in GC mode'
H088D436307D2: '在GC模式下，对 __strong 类型属性声明了 weak 属性'
# 'weak declaration cannot have internal linkage'
HC1895405FFA7: 'weak 声明不能具有内部链接性'
# 'weak identifier %0 never declared'
H22A978739C8D: 'weak 标识符 %0 从未被声明'
# 'weakref declaration must have internal linkage'
H8016E3683340: 'weakref 声明必须具有内部链接性'
# 'weakref declaration of %0 must also have an alias attribute'
H101799E65B31: '%0 的 weakref 声明还必须具有别名属性'
# 'weakref declaration of %0 must be in a global context'
HDA1EB6DAD24A: '%0 的 weakref 声明必须处于全局上下文中'
# 'webassembly: disables the fix  irreducible control flow optimization pass'
HA0B81E145B1D: 'webassembly: 禁用修复不可约控制流优化pass'
# 'when a function is considered for merging into a partition that already contains some of its callees, do the merge if at least n% of the code it can reach is already present inside the partition; e.g. 0.7 means only merge >70%'
HB679EAE1AA06: '当考虑将函数合并到已包含其部分被调函数的分区时，如果该函数能访问的代码中至少有n%已存在于分区中，则执行合并；例如 0.7表示仅合并>70%的情况'
# 'when applied to this declaration'
HA6DB04448955: '当应用于该声明时'
# 'when deciding to split a function, apply this alignment while doing the size comparison (see -split-threshold). Default value: 2.'
HD6693F2AB0CA: '在进行大小比较时（见-split-threshold选项），分割函数时应用此对齐值。默认值：2。'
# 'when emitting large string tables, prefer string literals over comma-separated char literals. This can be a readability and compile-time performance win, but upsets some compilers'
H2D23BA9375B5: '在生成大型字符串表时，优先使用字符串字面量而非逗号分隔的字符字面量。这可能提升可读性和编译性能，但某些编译器可能不兼容'
# 'when implemented by class %0'
H9F7ED2DB900A: '当由类 %0 实现时'
# "when looking up '%select{begin|end}0' function for range expression of type %1"
HC4C870329421: '在查找类型 %1 的范围表达式对应的 `%select{begin|end}0` 函数时'
# 'when max depth is reached and we can no longer branch out, this value determines if a function is worth merging into an already existing partition to reduce code duplication. This is a factor of the ideal partition size, e.g. 2.0 means we consider the function for merging if its cost (including its callees) is 2x the size of an ideal partition.'
HC50D6FBB78F2: '当达到最大深度且无法继续分支时，此值决定函数是否值得合并到现有分区以减少代码重复。这是理想分区大小的倍数因子，例如 2.0表示当函数的代价（包含其被调用函数）是理想分区大小的两倍时，才会考虑合并。'
# 'when possible, poison scoped variables at the beginning of the scope (slower, but more precise)'
H00AA44541919: '可能的话，在作用域开头毒化作用域变量（速度较慢，但更精确）'
# 'when repeating the instruction snippet by looping over it, duplicate the snippet until the loop body contains at least this many instruction'
HED512258C903: '通过循环重复指令片段时，重复该片段直到循环体包含至少指定数量的指令'
# 'when type is in parentheses, array cannot have dynamic size'
HBDE59C8D782B: '当类型在括号中时，数组不能具有动态大小'
# 'which delegates to'
H90C5BED46FE0: '其委托给'
# 'which gadget scanners to run'
HF9F26A96F310: '要运行的gadget扫描器'
# 'while building implicit deduction guide first needed here'
HD4658CE20D59: '在构建隐式推导指南时首次需要此处'
# 'while calculating associated constraint of template %0 here'
HD4CBA036E98A: '在计算模板 %0 的关联约束时需要此处'
# 'while checking a default template argument used here'
H7E4F64D4A848: '在检查此处使用的默认模板参数时'
# "while checking constraint satisfaction for class template partial specialization '%0' required here"
H190F26B4DB43: "在检查类模板偏特化 '%0' 的约束满足要求时需要此处"
# "while checking constraint satisfaction for function '%0' required here"
H1A3A707B1D73: "在检查函数 '%0' 的约束满足要求时需要此处"
# "while checking constraint satisfaction for template '%0' required here"
H19BE8EB0741D: "在检查模板 '%0' 的约束满足要求时需要此处"
# "while checking constraint satisfaction for variable template partial specialization '%0' required here"
HD73CEE0E62DB: "在检查变量模板偏特化 '%0' 的约束满足要求时需要此处"
# "while checking implicit 'delete this' for virtual destructor"
H738DE49AA679: '在检查虚析构函数的隐式 "delete this" 时'
# "while checking the satisfaction of concept '%0' requested here"
HE2FF74B26A28: '在检查此处请求的概念 "%0" 的满足要求时'
# 'while checking the satisfaction of nested requirement requested here'
HE3D634694184: '在检查此处请求的嵌套要求满足时'
# "while declaring the corresponding implicit 'operator==' for this defaulted 'operator<=>'"
H332A7297AC58: '在为此默认的 "operator<=>" 声明对应的隐式 "operator==" 时'
# 'while declaring the implicit %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}1 for %0'
HAC5877F575DC: '在为此 %0 声明隐式 %select{默认构造函数|拷贝构造函数|移动构造函数|拷贝赋值运算符|移动赋值运算符|析构函数}1 时'
# 'while loop has empty body'
H374FEF617D4F: 'while循环的循环体为空'
# 'while loop outside of a function'
HAB96332E82A6: '函数外的 while 循环'
# 'while printing functions output dyno-stats and skip instructions'
HF414286E0A36: '在输出函数时打印dyno-stats统计信息并跳过指令'
# "while rewriting comparison as call to 'operator<=>' declared here"
H9A478A9E2AA1: '在将比较重写为此处声明的 "operator<=>" 调用时'
# 'while substituting deduced template arguments into function template %0 %1'
H4E16912522F9: '在将推导出的模板参数代入函数模板 %0 %1 时'
# 'while substituting explicitly-specified template arguments into function template %0 %1'
H862C7E7129FA: '在将显式指定的模板参数代入函数模板 %0 %1 时'
# 'while substituting into a lambda expression here'
H154EA9F3EDC1: '在将此处的 lambda 表达式代入时'
# 'while substituting into concept arguments here; substitution failures not allowed in concept arguments'
HAC706623FF86: '在将概念参数此处代入时；概念参数不允许替换失败'
# 'while substituting prior template arguments into %select{non-type|template}0 template parameter%1 %2'
HF0EDCF82D09D: '在将先前模板参数代入 %select{非类型|模板}0 模板参数 %1 %2 时'
# 'while substituting template arguments into constraint expression here'
H19C71987DC07: '在替换模板参数到此处的约束表达式时'
# 'whitespace is not allowed in parameter passing direction'
H82BD58AB277F: '参数传递方向中不允许有空白字符'
# 'whitespace recommended after macro name'
H47F8347E0371: '建议在宏名后添加空白字符'
# 'whitespace required after macro name'
H2F43B2E26F3A: '必须在宏名后添加空白字符'
# 'widen this field to %0 bits to store all values of %1'
HD1698255B212: '将此字段的宽度扩展为 %0 位以存储 %1 的所有值'
# 'width of bit-field %0 (%1 bits) exceeds the width of its type; value will be truncated to %2 bit%s2'
H8896C13CC6D9: '位字段 %0 (%1 位) 的宽度超过其类型宽度；值将被截断至 %2 bit%s2'
# 'width of%select{ anonymous|}0 bit-field%select{| %1}0 (%2 bits) exceeds the %select{width|size}3 of its type (%4 bit%s4)'
H02B50746D7D1: '位字段%select{匿名|}0 的宽度 %select{| %1}0 (%2 位) 超过其类型的%select{宽度|大小}3 (%4 bit%s4)'
# 'with jt-footprint-reduction, only process PIC jumptables and turn off other transformations that increase code size'
H3BB007DE5DDB: '启用jt-footprint-reduction时，仅处理PIC跳转表并关闭其他增大代码体积的转换'
# 'within field of type %0 declared here'
HEC6FDC220283: '在类型 %0 的字段中，该字段在此处声明'
# 'writable atomic property %0 cannot pair a synthesized %select{getter|setter}1 with a user defined %select{getter|setter}2'
HA65A16D8E26B: '可写原子属性 %0 不能将合成的 %select{getter|setter}1 与用户定义的 %select{getter|setter}2 配对'
# 'write BOLT Address Translation tables'
H1540FEF77408: '写入BOLT地址翻译表'
# 'write bolt info section in the output binary'
H5BC44776C33F: '在输出二进制文件中写入bolt信息节'
# 'wrong argument format for hlsl attribute, use %0 instead'
H514518256D51: 'HLSL属性的参数格式错误，应使用 %0'
# 'wrong fpu width; %select{LSX|LASX}0 depends on 64-bit FPU'
H65FC5C473561: 'FPU宽度错误；%select{LSX|LASX}0 依赖于 64 位FPU'
# 'yaml2obj Options'
H095AAC30EBC3: 'yaml2obj 选项'
# "you need to include <typeinfo> before using the 'typeid' operator"
H64B8C0D4E612: "在使用 'typeid' 运算符前需要包含 <typeinfo>"
# 'z/OS target level "%0" is discontinued'
HB5BA348592D3: 'z/OS目标级别 "%0" 已弃用'
# 'z/OS target level "%0" is invalid'
H0080755EFA11: 'z/OS目标级别 "%0" 无效'
# 'zero %0 size'
HF7816CFF7955: '%0 的大小为零'
# 'zero as null pointer constant'
H824A61FB1C48: '使用零作为空指针常量'
# 'zero field width in scanf format string is unused'
H122ACCFBBD62: 'scanf格式字符串中的零字段宽度未被使用'
# 'zero linear step (%0 %select{|and other variables in clause }1should probably be const)'
HDA0E059C273A: '零线性步长（%0 %select{|和子句中的其他变量}1应声明为const）'
# 'zero size arrays are an extension'
H49512BBF0CE4: '零长度数组是扩展特性'
# "zero-length array section is not allowed in 'depend' clause"
HC5FAF4CE6159: "在 'depend' 子句中不允许使用零长度数组"
# 'zero-length arrays are not permitted in %select{C++|SYCL device code|HIP device code}0'
H2F083F032372: '在 %select{C++|SYCL device code|HIP device code}0 中不允许使用零长度数组'
