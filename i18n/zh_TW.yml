# '\n********************\n\nPLEASE ATTACH THE FOLLOWING FILES TO THE BUG REPORT:\nPreprocessed source(s) and associated run script(s) are located at:'
H8F8E0E346199: '\n********************\n\n請將以下檔案附加至錯誤報告：\n預處理的來源檔與相關執行腳本位於：'
# '\nDirectory where processed files are stored.\nLinks to definition locations will only be\ngenerated if the file is in this dir.'
H71324B3824F3: '\n存放處理後檔案的目錄。\n定義位置的連結僅會在\n此目錄下的檔案生成。'
# '\nThe directory for merging symbols.'
H41BC7E2887B5: '\n合併符號的目錄。'
# '\nThe output directory for saving the results.'
H9976AAF7AB83: '\n儲存結果的輸出目錄。'
# '\nURL of repository that hosts code.\nUsed for links to definition locations.'
HC00AE5E38B4C: '代碼存放的倉儲URL。\n用於生成定義位置的連結。'
# '  Type "'
H1DFDE84EB693: '  輸入「'
# " '%0 %select{sink:|source:}1' must be with '%select{omp_cur_iteration - 1|omp_cur_iteration}1'"
HCB22E641D2E6: " '%0 %select{sink:|source:}1' 必須與 '%select{omp_cur_iteration - 1|omp_cur_iteration}1' 一同使用"
# " '%0' in a raw string literal delimiter is a C++2c extension"
H03B242298EB9: " 原始字串字面量分隔符中的 '%0' 是 C++2c 的擴充功能"
# " '%0' in a raw string literal delimiter is incompatible with standards before C++2c"
HFCBE1727461C: " 原始字串字面量分隔符中的 '%0' 在 C++2c 之前版本不相容"
# ' (default: '
H6248B40D9879: ' （預設： '
# ' <subcommand> --help" to get more help on a specific subcommand'
H386881D1E849: ' <子命令> --help" 以取得特定子命令的更多說明'
# ' BrainF compiler\n'
H25D59DE4A1CF: ' BrainF 編譯器\n'
# ' [options]'
HE3EDA38172DD: ' [選項]'
# ' [subcommand]'
HEBFEA7B72C8E: ' [子命令]'
# ' positional argument'
HB552499219D4: ' 位置參數'
# ' positional arguments: See: '
H847D7E575852: ' 位置參數：詳細說明請參閱： '
# '#else after #else'
H73FE4A6784FB: '#else 在 #else 之後'
# '#else without #if'
HF8F50363B288: '#else 沒有對應的 #if'
# '#embed is a %select{C23|Clang}0 extension'
H799E9AA4840E: '#embed 是 %select{C23|Clang}0 的擴充功能'
# '#embed is incompatible with C standards before C23'
H1AF95A3E3444: '#embed 在 C23 之前版本不相容'
# '#endif without #if'
H56B14C401F16: '缺少 #if 的 #endif'
# '#ident is a language extension'
H45C329EC97BC: '#ident 是語言擴充'
# '#import is a language extension'
H8768B3DA6294: '#import 是語言擴充'
# '#import of type library is an unsupported Microsoft feature'
H1CFAB9C94AB6: '類型為 library 的 #import 是 Microsoft 不支援的功能'
# '#include nested too deeply'
H21908EF6D74E: '#include 嵌套層級過深'
# "#include of '%0' not seen while attempting to %select{create|use}1 precompiled header"
H05355AF7456A: "嘗試 %select{建立|使用}1 預編譯標頭時未找到 #include '%0'"
# '#include resolved using non-portable Microsoft search rules as: %0'
HE0D8871EA3B6: '#include 依非移植性的 Microsoft 搜尋規則解析為： %0'
# '#include_next in file found relative to primary source file or found by absolute path; will search from start of include path'
H92850FB4B236: '在相對主要來源檔案或絕對路徑找到的 #include_next；將從包含路徑開頭重新搜尋'
# '#include_next in primary source file; will search from start of include path'
HA1F5AE68D4B4: '主要來源檔案中的 #include_next；將從包含路徑開頭重新搜尋'
# '#include_next is a language extension'
H924C2DCE9AC7: '#include_next 是語言擴充'
# '#line directive requires a positive integer argument'
H2EB091899FF1: '#line 指令需要一個正整數參數'
# '#line directive with zero argument is a GNU extension'
H05235496C826: '#line 指令使用零參數是 GNU 擴充'
# '#line number greater than 32767 is incompatible with C++98'
HF9B195DC3866: '#line 行號超過 32767 會與 C++98 不相容'
# '#pragma %0(".drectve") has undefined behavior, use #pragma comment(linker, ...) instead'
H6CC89C517043: '#pragma %0(".drectve") 具有未定義行為，請改用 #pragma comment(linker, ...) '
# '#pragma %0(pop, ...) failed: %1'
H1F44FB9E690A: '#pragma %0(pop, ...) 失敗： %1'
# '#pragma align(packed) may not be compatible with objects generated with AIX XL C/C++'
H19CC6269DA45: '#pragma align(packed) 可能與 AIX XL C/C++ 產生的物件不相容'
# '#pragma entered here'
H4EB06A1F820E: '此處進入 #pragma'
# "#pragma execution_character_set expected '%0'"
H3700F774625D: "#pragma execution_character_set 期望 '%0'"
# "#pragma execution_character_set expected 'push' or 'pop'"
HF944C9D4F311: "#pragma execution_character_set 期望 'push' 或 'pop'"
# "#pragma execution_character_set invalid value '%0', only 'UTF-8' is supported"
HF7B9B86DDFE7: "#pragma execution_character_set 無效值 '%0'，僅支援 'UTF-8'"
# '#pragma hdrstop filename not supported, /Fp can be used to specify precompiled header filename'
HB20EE88D126A: '#pragma hdrstop 檔案名稱不受支援，可使用 /Fp 指定預編譯標頭檔案名稱'
# '#pragma hdrstop not seen while attempting to use precompiled header'
H482D12372789: '在嘗試使用預編譯標頭時未找到 #pragma hdrstop'
# '#pragma once in main file'
H9D36B8727C26: '主檔案中使用 #pragma once'
# '#pragma options align=reset failed: %0'
H3024180A558C: '#pragma options align=reset 失敗: %0'
# '#pragma redefine_extname is applicable to external C declarations only; not applied to %select{function|variable}0 %1'
HAF6CFAD80C5F: '#pragma redefine_extname 只適用於外部C宣告；未套用於 %select{函數|變數}0 %1'
# '#pragma system_header ignored in main file'
HE58DA574E5C2: '在主檔案中忽略 #pragma system_header'
# '#pragma visibility pop with no matching #pragma visibility push'
H3EDA32C5E985: '#pragma visibility pop 在無對應的 #pragma visibility push 時被呼叫'
# '#pragma visibility push with no matching #pragma visibility pop'
HB15E579A68AB: '#pragma visibility push 在無對應的 #pragma visibility pop 時被呼叫'
# "#pragma warning expected '%0'"
HE762E253E06E: "#pragma warning 期望 '%0'"
# "#pragma warning expected 'push', 'pop', 'default', 'disable', 'error', 'once', 'suppress', 1, 2, 3, or 4"
HBCB4550F177A: "#pragma warning 期望 'push'、'pop'、'default'、'disable'、'error'、'once'、'suppress'、1、2、3 或 4"
# '#pragma warning expected a warning number'
HB9A465F10016: '#pragma warning 期望一個警告編號'
# '#pragma warning(push, level) requires a level between 0 and 4'
H99A37FD4A6D8: '#pragma warning(push, level) 需要 level 在 0 到 4 之間'
# '#warning is a %select{C23|C++23}0 extension'
H0F157EC51CD6: '#warning 是 %select{C23|C++23}0 的擴充功能'
# '#warning is incompatible with C standards before C23'
H447994BFEB83: '#warning 不相容於 C23 之前的 C 標準'
# '#warning is incompatible with C++ standards before C++23'
H42FA898C6606: '#warning 不相容於 C++23 之前的 C++ 標準'
# '%0 %select{parameter|return}1 type is unsupported; support for vector types for this target is introduced in %2'
HDC6BFCFF388E: '%0 的 %select{參數|傳回}1 類型不受支援；此目標的向量類型支援在 %2 中引入'
# "%0 '%1' is acquired exclusively and shared in the same scope"
H7390A9DF88C0: "%0 '%1' 在同一作用域中被獨佔取得和共用"
# "%0 '%1' is not held on every path through here"
H6674AA570899: "%0 '%1' 在此處的每條執行路徑中均未被持有"
# "%0 '%1' is still held at the end of function"
HC378A7D8C58E: "%0 '%1' 在函數結束時仍被持有"
# "%0 '%1' must be acquired before '%2'"
H1AA537616F4E: "%0 '%1' 必須在 '%2' 之前取得"
# "%0 '%2' not managed by '%1'"
H7EC62D1C1AF9: "%0 '%2' 未被 '%1' 管理"
# "%0 (%1) exceeds limit (%2) in '%3'"
HE73AA4C10244: "%0 (%1) 在 '%3' 中超過限制 (%2)"
# '%0 acquired here'
HEA3E3310E736: '%0 在此處取得'
# '%0 additional files entered using a total of %1B (%human1B) of space'
HBB08F5A2D9D4: '%0 個額外的檔案使用了 %1B (%human1B) 的空間'
# '%0 and %1%select{ attributes|}2 are not compatible'
H3E0737276230: '%0 和 %1%select{ 屬性|}2 不相容'
# '%0 appears multiple times in clauses on the same declare target directive'
H71D418F6E9B9: '%0 在同一 declare 目標指令的子句中出現多次'
# '%0 applied to an expression is a GNU extension'
HE4B8DDF4E86C: '%0 應用於運算式是 GNU 延伸功能'
# '%0 argument must be a constant unsigned integer expression'
HD9AE42B82C9D: '%0 參數必須是常數無符號整數運算式'
# '%0 argument of MTE builtin function must be a null or a pointer (%1 invalid)'
H1FAF65C9963B: '%0 MTE 內建函數的參數必須是空值或指標 (%1 無效)'
# '%0 argument of MTE builtin function must be a pointer (%1 invalid)'
H0BF1182D2AC8: '%0 MTE 內建函數的參數必須是指標 (%1 無效)'
# '%0 argument of MTE builtin function must be an integer type (%1 invalid)'
H2B10B0C97CC4: '%0 MTE 內建函數的參數必須是整數類型 (%1 無效)'
# '%0 argument to %1 must be of vector type'
H61B90BC8950E: '%0 傳遞至 %1 的參數必須為向量類型'
# '%0 attribute %plural{0:takes no arguments|1:takes one argument|:requires exactly %1 arguments}1'
H8625FD5B48BC: '%0 屬性 %plural{0:不接受任何參數|1:需要一個參數|:需要恰好 %1 個參數}1'
# '%0 attribute applied to non-RVV type %1'
H49243AEFBCDB: '%0 屬性套用至非 RVV 類型 %1'
# '%0 attribute applied to non-SVE type %1'
H7CA8225CCF33: '%0 屬性套用至非 SVE 類型 %1'
# "%0 attribute applies to function parameters only if their type is a reference to a 'scoped_lockable'-annotated type"
H8F04340A3021: "%0 屬性僅適用於函式參數，若其類型是對 'scoped_lockable' 標記類型的參考"
# "%0 attribute argument '%1' not supported on a global variable"
H12B4D27D7798: "%0 屬性參數 '%1' 不支援於全域變數"
# '%0 attribute argument is invalid: %select{max must be 0 since min is 0|min must not be greater than max}1'
HD3E478873102: '%0 屬性參數無效：%select{因 min 為 0，max 必須為 0|min 必須不大於 max}1'
# '%0 attribute argument may only refer to a function parameter of integer type'
H05E563701DF2: '%0 屬性參數只能引用整數型別的函數參數'
# '%0 attribute argument must be a string literal specifying a Swift function name'
H056A97564B83: '%0 屬性參數必須是指定 Swift 函數名稱的字串常量'
# '%0 attribute argument not supported: %1'
HB519160711B1: '%0 屬性參數不受支援：%1'
# "%0 attribute can only be applied in a context annotated with 'capability' attribute"
H9411040D8420: "%0 屬性只能用在標註有 'capability' 屬性的上下文中"
# '%0 attribute can only be applied once per parameter'
H3C2BAB720741: '%0 屬性每個參數只能應用一次'
# '%0 attribute can only be applied to a %select{function|method}1 with an error parameter'
H5477D07BA320: '%0 屬性只能用於%select{函數|方法}1且具有錯誤參數的類型'
# '%0 attribute can only be applied to a ARM, HLSL or RISC-V builtin'
H63E9059C2A3F: '%0 屬性只能用於 ARM、HLSL 或 RISC-V 內建函數'
# '%0 attribute can only be applied to instance variables or properties'
H30E90B5958C9: '%0 屬性只能用於實例變數或屬性'
# "%0 attribute cannot be applied to %select{a function parameter|a variable with 'register' storage class|a 'catch' variable|a bit-field|an enumeration}1"
HD202D2E58321: "%0 屬性不能用於%select{函數參數|具有 'register' 存儲類別的變數|'catch' 變數|位段|枚舉}1"
# '%0 attribute cannot be applied to %select{methods in protocols|dealloc}1'
HC18046C82752: '%0 屬性不能用於%select{協定中的方法|dealloc}1'
# '%0 attribute cannot be applied to a %select{function|method}1 with no parameters'
H9F395B21D226: '%0 屬性不能用於無參數的%select{函數|方法}1'
# '%0 attribute cannot be applied to a module'
H6CF918E64873: '%0 屬性不能用於模組'
# '%0 attribute cannot be applied to a module import'
H3AD0DE140148: '%0 屬性不能用於模組導入'
# '%0 attribute cannot be applied to non-static member functions'
HCA6FA0E6C0E4: '%0 屬性不能用於非靜態成員函數'
# '%0 attribute cannot be applied to sizeless type %1'
H60D82BB85EBA: '%0 屬性不能用於無大小型別 %1'
# '%0 attribute cannot be applied to this declaration'
H1A106E97EE94: '%0 屬性不能用於此宣告'
# '%0 attribute cannot be repeated'
H1FB2864F8926: '%0 屬性不能重複使用'
# '%0 attribute cannot be used from %select{a block|an Objective-C function|this context}1'
HFCD2CCA9A22B: '%0 屬性不能從%select{區塊|Objective-C 函數|此上下文}1使用'
# '%0 attribute cannot be used with pointers to members'
H828AE7C76F14: '%0 屬性不能與成員指標一起使用'
# "%0 attribute cannot specify more than one 'self:' parameter"
HC2B60D257432: "%0 屬性不能指定超過一個 'self:' 參數"
# '%0 attribute does not appear on the first declaration'
HE84901B6BFC0: '%0 屬性未出現在第一個宣告中'
# '%0 attribute expression never produces a constant expression'
H6DB854C2324C: '%0 屬性運算式始終不會產生常量運算式'
# "%0 attribute for 'subscript' getter cannot have a 'newValue:' parameter"
HEBB5613EEF15: "%0 屬性用於 'subscript' 的 getter 時不能具有 'newValue:' 參數"
# "%0 attribute for 'subscript' must %select{be a getter or setter|have at least one parameter|have a 'self:' parameter}1"
H445CA4D5B31B: "%0 屬性用於 'subscript' 時必須 %select{是 getter 或 setter|至少有一個參數|具有 'self:' 參數}1"
# "%0 attribute for 'subscript' setter cannot have multiple 'newValue:' parameters"
H2C95053B8BED: "%0 屬性用於 'subscript' 的 setter 時不能具有多個 'newValue:' 參數"
# "%0 attribute for 'subscript' setter must have a 'newValue:' parameter"
HD3A5819D09C5: "%0 屬性用於 'subscript' 的 setter 時必須具有 'newValue:' 參數"
# "%0 attribute for getter must not have any parameters besides 'self:'"
HA628A2E87201: "%0 屬性用於 getter 時除了 'self:' 以外不能有其他參數"
# '%0 attribute for setter must have one parameter for new value'
H349FB00769DE: '%0 屬性用於 setter 時必須有一個參數用於新值'
# '%0 attribute has invalid identifier for the %select{base|context|parameter}1 name'
HC37D287D1C6D: '%0 屬性具有 %select{基|上下文|參數}1 名稱的無效識別符'
# '%0 attribute has no effect on defaulted or deleted functions'
HDFBEF81FB2EF: '%0 屬性對預設化或已刪除的函數無效'
# '%0 attribute ignored'
HCD3BE326728C: '%0 屬性被忽略'
# '%0 attribute ignored because Clang does not yet support this attribute signature'
HB0B12C0AB26E: '%0 屬性被忽略，因為 Clang 尚未支援此屬性簽章'
# '%0 attribute ignored for field of type %1'
HBE46E60BBC6F: '%0 屬性被忽略，因為 %1 類型的成員變數'
# '%0 attribute ignored on a non-definition declaration'
H208A7E24C5FA: '%0 屬性在非定義宣告上被忽略'
# '%0 attribute ignored on inline function'
H96102C6ED34D: '%0 屬性在內聯函數上被忽略'
# '%0 attribute ignored on local class%select{| member}1'
HFF01D57072C2: '%0 屬性在本地類別 %select{| 成員}1 上被忽略'
# '%0 attribute ignored when parsing type'
HD37333D19CA5: '%0 屬性在解析類型時被忽略'
# '%0 attribute is deprecated and ignored in %1'
HEFE3D7F726A1: '%0 屬性在 %1 中已棄用並被忽略'
# '%0 attribute is ignored because %1 is not a function pointer'
H4475E1120012: '%0 屬性被忽略，因為 %1 不是函數指標'
# '%0 attribute is ignored because there exists no call expression inside the statement'
H7E65A2DFE3B4: '%0 屬性被忽略，因為該語句內部不存在呼叫運算式'
# '%0 attribute is ignored in non-aggregate type %1'
HDDFDF4BAA343: '%0 屬性在非聚合類型 %1 中被忽略'
# '%0 attribute is invalid for the implicit this argument'
H2D89A7CAF8E9: '%0 屬性不適用於隱含的 this 參數'
# '%0 attribute is missing parameter label clause'
HD08320D115DE: '%0 屬性缺少參數標籤子句'
# '%0 attribute is not supported in %select{C|C++|Objective-C}1'
H40645DEA04DB: '%0 屬性不支援 %select{C|C++|Objective-C}1'
# "%0 attribute is not supported on '%1'"
H46128D024C15: "%0 屬性不適用於 '%1'"
# '%0 attribute is not supported on targets missing %1; specify an appropriate -march= or -mcpu='
H8B26915B3400: '%0 屬性在目標缺少 %1 時不受支援；請指定合適的 -march= 或 -mcpu='
# '%0 attribute is not yet supported on AIX'
H09BE0575B2ED: '%0 屬性尚未支援 AIX 系統'
# '%0 attribute is only allowed on empty statements'
H523B4DCA9F57: '%0 屬性僅允許用於空語句'
# '%0 attribute is permitted on definitions only'
H7BE8228ED388: '%0 屬性僅允許用於定義'
# "%0 attribute isn't implemented by this Objective-C runtime"
H4540FD7320B4: '此 Objective-C 執行階段不實作 %0 屬性'
# '%0 attribute may not be used with no-return-attribute functions'
H9936965C5605: '%0 屬性不可與無返回屬性函數併用'
# '%0 attribute may not be used with variadic functions'
HC4348E6FE2CB: '%0 屬性不可與可變參數函數併用'
# '%0 attribute minimum and maximum arguments are equal'
HCEAC369F8447: '%0 屬性的最小值與最大值相等'
# "%0 attribute must be applied to a %select{function|method}1 annotated with non-'none' attribute 'swift_async'"
H1EED532B31A7: "%0 屬性必須套用於以非 'none' 屬性 'swift_async' 標註的 %select{函數|方法}1"
# '%0 attribute must be greater than 0'
H2544E0569FB3: '%0 屬性必須大於 0'
# '%0 attribute on entry function does not match the target profile'
H789CC95F4AD2: '入口函數的 %0 屬性與目標剖面不符合'
# '%0 attribute only applies to %select{Objective-C object|pointer|pointer-to-CF-pointer|pointer/reference-to-OSObject-pointer}1 parameters'
H5089073C0897: '%0 屬性僅適用於 %select{Objective-C 物件|指標|指向 CF 指標|指向 OSObject 指標的 C++ 參考}1 參數'
# '%0 attribute only applies to %select{Objective-C object|pointer|pointer-to-CF-pointer}1 parameters'
HF1529765C253: '%0 屬性僅適用於 %select{Objective-C 物件|指標|指向 CF 指標}1 參數'
# '%0 attribute only applies to %select{functions|methods|properties}1 that return %select{an Objective-C object|a pointer|a non-retainable pointer}2'
H0AEFAD59CD2C: '%0 屬性僅適用於返回 %select{an Objective-C object|a pointer|a non-retainable pointer}2 的 %select{函數|方法|屬性}1'
# '%0 attribute only applies to %select{pointer|integer}1 arguments'
H3971FB6B9374: '%0 屬性僅適用於 %select{指標|整數}1 參數'
# '%0 attribute only applies to a pointer or reference (%1 is invalid)'
HC8C4E00A6BE4: '%0 屬性僅適用於指標或引用（%1 無效）'
# '%0 attribute only applies to return values that are pointers'
H83B4DE3C5663: '%0 屬性僅適用於返回值為指標的返回值'
# '%0 attribute only applies to return values that are pointers or references'
HA603B89762A9: '%0 屬性僅適用於返回值為指標或引用的返回值'
# '%0 attribute only applies to%select{| constant}1 pointer arguments'
H1E90BC4B3746: '%0 屬性僅適用於 %select{|常數}1指標參數'
# '%0 attribute parameter %1 is negative and will be ignored'
HB94334A9F06D: '%0 屬性參數 %1 為負數且將被忽略'
# '%0 attribute parameter %1 is out of bounds'
H9C7D1C19F9DB: '%0 屬性參數 %1 超出範圍'
# '%0 attribute parameter %1 is out of bounds: %plural{0:no parameters to index into|1:can only be 1, since there is one parameter|:must be between 1 and %2}2'
HF05125794562: '%0 屬性參數 %1 超出範圍：%plural{0:無參數可供索引|1:只能是 1，因為只有一個參數|:必須介於 1 和 %2 之間}2'
# '%0 attribute parameter types do not match: parameter %1 of function %2 has type %3, but parameter %4 of function %5 has type %6'
H4FBE5E81E84C: '%0 屬性參數類型不匹配：函數 %2 的第 %1 個參數類型為 %3，但函數 %5 的第 %4 個參數類型為 %6'
# '%0 attribute parameters do not match the previous declaration'
HBB1E6D667EEA: '%0 屬性參數與先前宣告不符'
# '%0 attribute references function %1, which %plural{0:takes no arguments|1:takes one argument|:takes exactly %2 arguments}2'
HC6916839EF90: '%0 屬性引用函數 %1，該函數 %plural{0:沒有參數|1:有一個參數|:恰好有 %2 個參數}2'
# '%0 attribute references parameter %1, but the function %2 has only %3 parameters'
H95C6EBBF3D05: '%0 屬性引用參數 %1，但函數 %2 僅有 %3 個參數'
# '%0 attribute requires %select{int or bool|an integer constant|a string|an identifier}1'
H4D660FD4970F: '%0 屬性需要%select{整數或布林值|整數常數|字串|識別符}1'
# '%0 attribute requires a %select{positive|non-negative}1 integral compile time constant expression'
H88B2A4A1C6F1: '%0 屬性需要%select{正|非負}1整數編譯時常數運算式'
# '%0 attribute requires an integer argument which is a constant power of two between %1 and %2 inclusive; provided argument was %3'
HBE3281153430: '%0 屬性需要介於 %1 和 %2（含）之間的整數常數次方；提供的參數為 %3'
# "%0 attribute requires arguments whose type is annotated with 'capability' attribute; type here is %1"
H6A637254187D: "%0 屬性需要類型標註為 'capability' 屬性的類型；這裡的類型是 %1"
# '%0 attribute requires integer constant between %1 and %2 inclusive'
HEAC447E72E0E: '%0 属性需要介於 %1 和 %2（含）之間的整數常數'
# '%0 attribute requires parameter %1 to be %select{int or bool|an integer constant|a string|an identifier|a constant expression|a builtin function}2'
H410FC41452B2: '%0 屬性需要參數 %1 為%select{整數或布林值|整數常數|字串|識別符|常數運算式|內建函數}2'
# '%0 attribute requires that both caller and callee functions have a prototype'
H16EEA1808E57: '%0 屬性需要呼叫端與被呼叫函數都具有原型宣告'
# '%0 attribute requires that the return value is the result of a function call'
H374EE3F9FB1E: '%0 屬性需要返回值是函數呼叫的結果'
# '%0 attribute takes at least %1 argument%s1'
HADEF6E200C29: '%0 屬性至少需要 %1 個參數%s1'
# '%0 attribute takes no more than %1 argument%s1'
H19CAD7127F59: '%0 屬性最多只能有 %1 個參數%s1'
# "%0 attribute with '%1' convention can only be applied to a %select{function|method}2 returning %select{an integral type|a pointer}3"
HD834E8E626F3: "%0 具有 '%1' 約定的屬性只能用於%select{函式|方法}2，其返回類型為%select{整數類型|指標}3"
# "%0 attribute with '%1' convention must have an integral-typed parameter in completion handler at index %2, type here is %3"
HA510BC647385: "%0 具有 '%1' 約定的屬性在完成處理器的索引 %2 需要整數類型參數，這裡的類型為 %3"
# "%0 attribute with 'nonnull_error' convention can only be applied to a %select{function|method}1 with a completion handler with an error parameter"
HB02ECE112485: "%0 具有 'nonnull_error' 約定的屬性只能用於帶有錯誤參數的完成處理器的%select{函式|方法}1"
# '%0 attribute without capability arguments can only be applied to non-static methods of a class'
H1A6503974C19: '%0 沒有指定能力參數的屬性只能用於類別的非靜態方法'
# "%0 attribute without capability arguments refers to 'this', but %1 isn't annotated with 'capability' or 'scoped_lockable' attribute"
H4FEFB6A31DD8: "%0 沒有指定能力參數的屬性引用 'this'，但 %1 未標註 'capability' 或 'scoped_lockable' 屬性"
# "%0 availability is ignored without a valid 'SDKSettings.json' in the SDK"
H44C1644AD110: "%0 的可用性在 SDK 中缺少有效的 'SDKSettings.json' 時將被忽略"
# '%0 begins here'
H3AEE48765E33: '%0 開始於此處'
# '%0 bridges to %1, not %2'
HF3302ECAA235: '%0 橋接至 %1，而非 %2'
# "%0 byte order mark detected in '%1', but encoding is not supported"
H4406B8F3C975: "%0 在 '%1' 中偵測到 Byte Order Mark，但編碼不支援"
# '%0 calling convention is not supported %select{for this target|on variadic function|on constructor/destructor|on builtin function}1'
HEDD5B64E1439: '%0 的呼叫約定不受支援 %select{在此目標平台|在可變參數函式|在建構函式/析構函式|在內建函式}1'
# '%0 can appear only once in a capture list'
H17CCB4C13684: '%0 不能在同一個捕獲清單中出現多次'
# "%0 cannot appear before '::' because it is not a class%select{ or namespace|, namespace, or enumeration}1; did you mean ':'?"
H95866D5EB8E3: "%0 無法出現在 '::' 之前，因為它不是類別%select{ 或命名空間|、命名空間或列舉}1；是否要使用 ':'？"
# '%0 cannot appear here'
H7B57CA319863: '%0 無法在此處出現'
# '%0 cannot appear here, place it after "%select{class|struct|interface|union|enum}1" to apply it to the type declaration'
H2B1210C2EB9F: '%0 必須放在 "%select{類別|結構|介面|共用體|列舉}1" 之後才能套用於類型宣告'
# '%0 cannot be a template'
H09B919FC579B: '%0 不能是模板'
# '%0 cannot be applied to a module'
HED10CE4A1D68: '%0 不能用於模塊'
# '%0 cannot be applied to a module import'
HE5DD1D7C816C: '%0 不能用於模塊導入'
# '%0 cannot be captured because it does not have automatic storage duration'
HBA5ABB384993: '%0 無法被捕獲，因為它不具有動態存儲期'
# "%0 cannot be declared 'weak_import' because its definition has been provided"
HE0A69210AAA7: "%0 不可宣告為 'weak_import'，因其已提供定義"
# '%0 cannot be declared consteval'
H16F780D20CBE: '%0 不可宣告為 consteval'
# '%0 cannot be declared inside a namespace'
H52C308DDDEAD: '%0 不可宣告於命名空間內部'
# '%0 cannot be declared static in global scope'
HE95F0FB30315: '%0 不可在全域範圍宣告為 static'
# '%0 cannot be defined in a condition'
H4D213A54365F: '%0 不可在條件中定義'
# '%0 cannot be defined in a parameter type'
H73A9723882B3: '%0 不可在參數類型中定義'
# '%0 cannot be defined in a type alias template'
H481A328DC270: '%0 不可在類型別名範本中定義'
# '%0 cannot be defined in a type specifier'
H66CFEB606651: '%0 不可在類型指定詞中定義'
# '%0 cannot be defined in an enumeration'
H9015777D8EDA: '%0 不可在枚舉中定義'
# '%0 cannot be defined in the result type of a function'
HBCF321DF1229: '%0 不可在函數的傳回類型中定義'
# '%0 cannot be specialized%select{|: %2}1'
H2F24480223D6: '%0 不可被特化 %select{|: %2}1'
# '%0 cannot be the name of a parameter'
H86909FCB5AFA: '%0 不可用作參數名稱'
# '%0 cannot be the name of a variable or data member'
H97536A002E4D: '%0 不可用作變數或資料成員名稱'
# '%0 cannot be used as the type of a kernel parameter'
H4649232301DD: '%0 不可用作核心參數的類型'
# '%0 cannot bridge to %1'
H223FE9046675: '%0 無法轉換至 %1'
# '%0 cannot have a dependent return type; use %1 instead'
H622C863D5758: '%0 不可具有依賴傳回類型；請改用 %1'
# '%0 cannot take a dependent type as first parameter; use %1 instead'
HA474A1ABAD69: '%0 不可將依賴類型作為第一個參數；請改用 %1'
# '%0 cannot take a dependent type as first parameter; use size_t (%1) instead'
H54AA7CDA647F: '%0 不可將依賴類型作為第一個參數；請改用 size_t (%1)'
# "%0 cannot use 'super' because it is a root class"
HCB7FBC7D0FE7: "%0 無法使用 'super'，因其是根類別"
# '%0 causes a section type conflict with %1'
HC2A4EF19BEEF: '%0 與 %1 造成區段類型衝突'
# '%0 clause previously used here'
HB8E770744C3C: '%0 子句在此處先前已使用過'
# '%0 clause should not be followed by arguments; tokens will be ignored'
HC180595F601D: '%0 子句不應跟隨參數；這些標記將被忽略'
# '%0 command failed due to signal (use -v to see invocation)'
H6D5905ABD1C8: '%0 命令因信號而失敗（使用 -v 可查看調用命令）'
# '%0 command failed with exit code %1 (use -v to see invocation)'
H4949FF66B370: '%0 命令以退出代碼 %1 結束（使用 -v 可查看調用命令）'
# '%0 currently has no effect on a using declaration'
HF72F1D74D1D1: '%0 目前對 using 宣告無效'
# '%0 declared as a reference to a reference'
H6B7D1478B098: '%0 被宣告為對參考的參考'
# '%0 declared here'
HF5B76F9106FA: '%0 在此宣告'
# '%0 defined here'
HAF9360C4877D: '%0 在此定義'
# "%0 differs in AST file '%1' vs. current file"
H2B8E15EA63E3: "%0 在AST檔案 '%1' 與目前檔案中的定義不同"
# '%0 dimension is outside the allowed range [1, %1]'
H082ED204EAD0: '%0 維度超出允許範圍 [1, %1]'
# '%0 does not have a member named %1'
H9A87A68C56D5: '%0 沒有被命名為 %1 的成員'
# '%0 does not have a member named %1; did you mean %2?'
HB35AA56437F0: '%0 沒有被命名為 %1 的成員；您是否指的是 %2？'
# '%0 does not identify a valid pointer authentication key for the current target'
H788DB99BF41E: '%0 未能指定當前目標有效的指標認證金鑰'
# '%0 does not name a template but is followed by template arguments'
H33B12988518D: '%0 不是模板名稱，但後面跟隨了模板參數'
# '%0 does not name a template but is followed by template arguments; did you mean %1?'
H4461F93F60D6: '%0 不是模板名稱，但後面跟隨了模板參數；您是否指的是 %1？'
# '%0 does not point into a class'
H54F4142F16BD: '%0 沒有指向一個類別'
# '%0 does not refer to a type name in pseudo-destructor expression; expected the name of type %1'
H439E7BF75B12: '%0 在假構析構表達式中未指向類型名稱；期望 %1 類型的名稱'
# '%0 does not refer to a value'
H21D124F292F8: '%0 未指定一個值'
# '%0 does not refer to the name of a parameter pack'
H84CFFC360255: '%0 未指定參數包的名稱'
# '%0 does not refer to the name of a parameter pack; did you mean %1?'
H833E3DFEF469: '%0 未指定參數包的名稱；您是否指的是 %1？'
# "%0 does not support the '%1' %select{type qualifier|storage class specifier}2"
H0775C84F5711: "%0 不支援 '%1' %select{類型修飾詞|存儲類別指定符}2"
# "%0 does not support the option '%1'"
HCC61DEFC8375: "%0 不支援選項 '%1'"
# '%0 has C-linkage specified, but returns incomplete type %1 which could be incompatible with C'
H36CF04C5AD21: '%0 指定了 C 連結規格，但返回不完整類型 %1，這可能與 C 不兼容'
# '%0 has C-linkage specified, but returns user-defined type %1 which is incompatible with C'
H33D15C91E278: '%0 指定了 C 連結規格，但返回使用者定義類型 %1，這與 C 不兼容'
# '%0 has a non-throwing exception specification but can still throw'
H115C08CCD253: '%0 具有不拋出例外規格，但可能仍會拋出例外'
# '%0 has been explicitly marked %select{unavailable|deleted|deprecated}1 here'
H8BC49D6916A0: '%0 已在此處明確標記為 %select{不可用|已刪除|已棄用}1'
# '%0 has been marked as being introduced in %1 %2 %select{|in %5 environment }4here, but the deployment target is %1 %3%select{| %6 environment }4'
H0D47117119FF: '%0 已被標記為在 %1 %2 %select{|%5 環境中 }4 引入，但部署目標為 %1 %3%select{|%6 環境 }4'
# "%0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%select{no super class|super class with type %5}4|instance variable '%4' access control is %select{|@private|@protected|@public|@package}5}3"
H8AC2F2F00B17: "%0 在不同模組中具有不同定義；第一個差異是 %select{模組 '%2' 中的定義|在此處定義}1 發現 %select{%select{無超類|超類具有類型 %5}4|實例變數 '%4' 的存取控制為 %select{|@private|@protected|@public|@package}5}3"
# '%0 has lower precedence than %1; %1 will be evaluated first'
HFFF20BD3A51A: '%0 的優先順序低於 %1；%1 將會先被評估'
# '%0 has no out-of-line virtual method definitions; its vtable will be emitted in every translation unit'
HF80DD309C805: '%0 沒有外部虛函數定義；其 vtable 將會在每個翻譯單位中被發射'
# '%0 has unknown return type; cast the call to its declared return type'
H98622C79AEFA: '%0 的返回類型不明；將呼叫轉換為其宣告的返回類型'
# '%0 has unknown type, which is not supported for this kind of declaration'
H62292154D971: '%0 具有未知類型，而此類別別不支援未知類型'
# '%0 has unknown type; cast it to its declared type to use it'
HB47BA1F1A811: '%0 的類型不明；將其轉換為宣告的類型後才能使用'
# '%0 has virtual functions but non-virtual destructor'
HE7971ACC4D33: '%0 具有虛函數但沒有虛析構函數'
# '%0 in capture list does not name a variable'
HDBFB52EAD640: '%0 在捕獲清單中未指定變數名稱'
# '%0 is a %select{struct|interface|union|class|enum}1 here'
H03376E721EF2: '%0 在此處是 %select{結構|介面|聯合|類別|列舉}1'
# '%0 is a builtin with type %1'
HF5D497B12074: '%0 是具有類型 %1 的內建類型'
# '%0 is a core feature in %select{OpenCL C|C++ for OpenCL}1 version %2 but not supported on this target'
HB2B1D8E45B2F: '%0 是 %select{OpenCL C|OpenCL 的 C++}1 版本 %2 中的核心功能，但此目標平台不支援'
# '%0 is a large (%1 bytes) pass-by-value argument; pass it by reference instead ?'
H3328D1D6C300: '%0 是一個大型（%1 位元組）傳值參數；建議改用傳參考方式傳遞？'
# '%0 is a reserved attribute identifier'
HA23BACAA2167: '%0 是保留的屬性識別符'
# '%0 is a reserved name for a module'
H539795173149: '%0 是模組的保留名稱'
# '%0 is an %select{unsafe pointer used for buffer access|unsafe buffer that does not perform bounds checks}1'
HD2DA3F5D5287: '%0 是 %select{用於緩衝區存取的不安全指標|未執行界限檢查的不安全緩衝區}1'
# '%0 is an immediate %select{function|constructor}5 because %select{its body|the%select{| default}7 initializer of %8}6 %select{evaluates the address of %select{an immediate|a consteval}2 function %1|contains a call to %select{an immediate|a consteval}2 %select{function|constructor}4 %1 and that call is not a constant expression}3'
H2D11120EB0CD: '%0 是立即 %select{函式|建構函式}5，因為 %select{其本體|the%select{| 預設}7 初始化器 of %8}6 %select{評估 %select{立即|consteval}2 函式 %1 的地址|包含對 %select{立即|consteval}2 %select{函式|建構函式}4 %1 的呼叫，而該呼叫並非常數運算式}3'
# '%0 is an implicit parameter'
H18B31C3BE2ED: '%0 是隱式參數'
# '%0 is an incomplete type'
H23B2652D4493: '%0 是不完整類型'
# '%0 is an invalid name for a module'
H04BC4C58E825: '%0 是模組的無效名稱'
# "%0 is currently enabled, but was not in the AST file '%1'"
H4A72404ECC3D: "%0 目前已啟用，但 AST 檔案 '%1' 中未啟用"
# '%0 is defined here; did you mean %1?'
H3B788FE6A551: '%0 在此處定義；您是否指的是 %1？'
# '%0 is deprecated'
HFB3435CCEF09: '%0 已過時'
# '%0 is deprecated: %1'
HBBBFE1910250: '%0 已過時： %1'
# '%0 is expected to be a non-type template, but instantiated to a %select{class|type alias}1 template'
H0D2CA33F6096: '%0 被期望為一個非類型模板，但實體化為 %select{類別|類型別名}1 模板'
# '%0 is incompatible with selectors that return a %select{struct|union|vector}1 type'
HF29FF6DC9511: '%0 與傳回 %select{結構|共用體|向量}1 類型的選擇器不相容'
# '%0 is incomplete'
HE1EB0B2A5FDF: '%0 是不完整'
# "%0 is missing exception specification '%1'"
HFEFEB7B90D08: "%0 缺少例外規格 '%1'"
# '%0 is no longer a pack expansion but a pack indexing type; add a name to specify a pack expansion'
H52ECBB1B9A17: '%0 已不再為包展開，而是包索引類型；添加名稱以指定包展開'
# '%0 is not a class type'
H5598919CD04A: '%0 不是類別類型'
# '%0 is not a class%select{ or namespace|, namespace, or enumeration}1'
H6791F56D81BD: '%0 不是類別%select{或命名空間|、命名空間或列舉}1'
# '%0 is not a direct base of %1, cannot inherit constructors'
H9090F9B02C3F: '%0 不是 %1 的直接基類，無法繼承建構函式'
# '%0 is not a global variable, static local variable or static data member'
HC570BF566E38: '%0 非全域變數、靜態區域變數或靜態資料成員'
# '%0 is not a global variable, static local variable or static data member; did you mean %1'
H32A3026BA924: '%0 不是全域變數、靜態局部變數或靜態資料成員；你是否指的是 %1'
# '%0 is not a recognized builtin%select{|; consider including <intrin.h> to access non-builtin intrinsics}1'
HB8FF0E17F733: '%0 不是識別的內建函數 %select{|；建議包含 <intrin.h> 以存取非內建內在函數}1'
# '%0 is not a structural type because it has a %select{non-static data member|base class}1 of non-structural type %2'
HF393BE38CC50: '%0 不是結構型類型，因為它有一個 %select{非靜態資料成員|基類}1 的非結構型類型 %2'
# '%0 is not a structural type because it has a %select{non-static data member|base class}1 that is not public'
H7772D2C2337B: '%0 不是結構型類型，因為它有一個 %select{非靜態資料成員|基類}1 未公開'
# '%0 is not a structural type because it has a mutable non-static data member'
HF8F430793986: '%0 不是結構型類型，因為它有可變的非靜態資料成員'
# '%0 is not a structural type because it has a non-static data member of rvalue reference type'
H3FC432618326: '%0 不是結構型類型，因為它有一個右值引用類型的非靜態資料成員'
# '%0 is not a valid SYCL kernel name type; a non-union class type is required'
H0BC00170201E: '%0 不是有效的 SYCL 核名類型；需要非聯合類型'
# '%0 is not a valid literal type for NSNumber'
H994AF662B0D5: '%0 不是有效的 NSNumber 字面類型'
# '%0 is not a valid property name (accessing an object of type %1)'
HA0D8AFF85380: '%0 不是有效的屬性名稱（存取 %1 類型的物件）'
# "%0 is not an availability stage; use 'introduced', 'deprecated', or 'obsoleted'"
H5FED6488A0D9: "%0 不是可用性階段；請使用 'introduced'、'deprecated' 或 'obsoleted'"
# '%0 is not an enumerated type'
H7F1BAB170C64: '%0 不是列舉類型'
# '%0 is not defined, but forward declared here; conversion would be valid if it was derived from %1'
H176B6CEA9A74: '%0 未定義，但在此前向宣告；如果它繼承自 %1，轉換將有效'
# '%0 is not defined, evaluates to 0'
HBDB44DE505CF: '%0 未定義，評估為 0'
# '%0 is not literal because it has a non-trivial destructor'
HC9535B0A1692: '%0 不是字面類型，因為它有非平凡的析構函數'
# '%0 is not literal because it has a user-provided destructor'
H35BFFB66B4EF: '%0 不是字面類型，因為它有使用者提供的析構函數'
# '%0 is not literal because it has base class %1 of non-literal type'
H41CFD9851FA8: '%0 不是字面類型，因為它的基類 %1 是非字面類型'
# '%0 is not literal because it has data member %1 of %select{non-literal|volatile}3 type %2'
H39754ECC239F: '%0 不是字面類型，因為它有 %1 的 %select{非字面|volatile}3 類型 %2 資料成員'
# '%0 is not literal because it is not an aggregate and has no constexpr constructors other than copy or move constructors'
HD7160BA9A570: '%0 不是字面類型，因為它不是聚合類型，且除了複製或移動建構函數外，沒有 constexpr 建構函數'
# '%0 is not literal because its destructor is not constexpr'
HEAC0F5C26B7E: '%0 不是字面類型，因為其析構函數不是 constexpr'
# '%0 is not polymorphic'
H67C71DB95F18: '%0 不是多態類'
# '%0 is not supported on HVX %1'
H7927AD732A30: '%0 在 HVX %1 上不受支援'
# '%0 is not supported on this target'
H331CCFBB5DA0: '%0 在此目標平台上不受支援'
# '%0 is not supported with -fembed-bitcode'
H580226EF44DA: '%0 不支援 -fembed-bitcode 選項'
# '%0 is not virtual and cannot be declared pure'
HFCE20933CC31: '%0 不是虛函數，因此無法宣告為純虛函數'
# '%0 is only available %select{|in %4 environment }3on %1 %2 or newer'
H1926B8ADA9BD: '%0 僅在 %1 %2 或更新版本 %select{|的 %4 環境 }3中可用'
# '%0 is only supported when \'-mrvv-vector-bits=<bits>\' is specified with a value of "zvl" or a power 2 in the range [64,65536]'
H714177E08C3D: '%0 僅在指定 -mrvv-vector-bits=<bits> 的值為 "zvl" 或 64 到 65536 之間的 2 的冪次時才受支援'
# "%0 is only supported when '-msve-vector-bits=<bits>' is specified with a value of 128, 256, 512, 1024 or 2048"
H5256E220BB0F: '%0 僅在指定 -msve-vector-bits=<bits> 的值為 128、256、512、1024 或 2048 時才受支援'
# "%0 is required to declare the member 'unhandled_exception()'"
H72F7248FC774: "%0 需要宣告成員函數 'unhandled_exception()'"
# "%0 is required to declare the member 'unhandled_exception()' when exceptions are enabled"
HA2F4C1A14DF7: "%0 需要宣告成員函數 'unhandled_exception()' 當例外處理啟用時"
# "%0 is required to have a non-throwing noexcept specification when the promise type declares 'get_return_object_on_allocation_failure()'"
H267685A6E8FC: "%0 需要具有非拋出型的 noexcept 指定，當承諾類型宣告 'get_return_object_on_allocation_failure()' 時"
# '%0 is unavailable'
HD9DCE040D90B: '%0 不可用'
# '%0 is unavailable in ARC'
H5A0EF77D1311: '%0 在 ARC 環境中不可用'
# '%0 is unavailable: %1'
H3F1A4B4C46AF: '%0 不可用：%1'
# '%0 is unsupported with LoongArch linker relaxation (-mrelax)'
H711EE6DE37A1: '%0 不支援與 LoongArch 連結器鬆弛優化 (-mrelax) 一起使用'
# '%0 is unsupported with RISC-V linker relaxation (-mrelax)'
H7184497D9FBD: '%0 不支援與 RISC-V 連結器鬆弛優化 (-mrelax) 一起使用'
# '%0 is used as a header guard here, followed by #define of a different macro'
HD1F7F8F6EEEE: '%0 此處被用作標頭守護，接著 #define 了另一個宏'
# "%0 layout not recognized. Must be a non-polymorphic class type with no bases and two fields: a 'const E *' and either another 'const E *' or a 'std::size_t'"
HED28B381356F: "%0 布局未被識別。必須是無基類且非多態的類型，並包含兩個成員：一個 'const E *' 和另一個 'const E *' 或 'std::size_t'"
# '%0 macro redefined'
H137240D8643E: '%0 宏已被重新定義'
# "%0 managed by '%1' is '%3' instead of '%2'"
H2BF1BAAD2D9C: "%0 由 '%1' 管理，其值為 '%3' 而非 '%2'"
# "%0 marked 'override' but does not override any member functions"
H4E355023D40F: "%0 標記為 'override' 但未覆寫任何成員函數"
# '%0 may be deprecated because the receiver type is unknown'
H33FCAE6FB142: '%0 可能因接收者類型未知而被棄用'
# '%0 may be duplicated when built into a shared library: it is mutable, has hidden visibility, and external linkage'
H5AAA1A09F587: '%0 可能在構建為共享函式庫時被重複定義：它為可變、具有隱藏可見性，且具有外部連結性'
# '%0 may be unavailable because the receiver type is unknown'
H5F639AF749BC: '%0 可能因彈性陣列成員而無法嵌套在結構體中'
# '%0 may not be nested in a struct due to flexible array member'
H56A636FEC1E0: '%0 可能因彈性陣列成員而無法用作陣列元素'
# '%0 may not be used as an array element due to flexible array member'
H4CE3DAD3A8F2: '%0 可能未打算支援類模板參數推導'
# '%0 may not intend to support class template argument deduction'
H3F1AA6022CE0: '%0 可能未打算支援類模板參數推導'
# '%0 may not respond to %1'
HE863B7C4E09E: '%0 可能不支援 %1'
# '%0 must be explicitly converted to %1; use %select{%objcclass2|%objcinstance2}3 method for this conversion'
H7B5D141884DB: '%0 必須明確轉換為 %1；使用 %select{%objcclass2|%objcinstance2}3 方法進行此轉換'
# '%0 must be name of an Objective-C class to be able to convert %1 to %2'
HF9706A398326: '%0 必須是 Objective-C 類別的名稱，才能將 %1 轉換為 %2'
# '%0 must be specified on definition if it is specified on any declaration'
H593384CDC4FD: '%0 必須在預處理指令內使用'
# '%0 must be used within a preprocessing directive'
HAA08D126AF16: '%0 必須至少有一個參數'
# '%0 must have at least one parameter'
H2488FE597801: '%0 不得同時出現在 "to" 和 "link" 子句中'
# "%0 must not appear in both clauses 'to' and 'link'"
HC3403F617C92: "%0 不得同時出現在 'to' 和 'link' 子句中"
# '%0 must return type %1'
H561F31EBFB23: '%0 需要目標功能 %1'
# '%0 needs target feature %1'
H5236119E54CB: '%0 需要目標功能 %1'
# '%0 needs to be instantiated from a class template with proper template arguments'
H6CDDF6DD374E: '%0 需要從具有正確模板參數的類模板實例化'
# '%0 needs to have exactly %1 template parameters'
HD0C675913338: '%0 必須有正好 %1 個模板參數'
# '%0 only allowed in __except block or filter expression'
H5D665A901228: '%0 只允許在 __except 區塊或篩選表達式中使用'
# '%0 only allowed in __except filter expression'
H6152837B25ED: '%0 只允許在 __except 篩選表達式中使用'
# '%0 only allowed in __finally block'
H4B415A24C89A: '%0 只允許在 __finally 區塊中使用'
# '%0 only applies to pointer types; type here is %1'
HAB4FE8662D8D: '%0 只適用於指標類型；這裡的類型是 %1'
# "%0 overrides a destructor but is not marked 'override'"
HEE01F5122D86: "%0 覆寫了析構函數，但未標示 'override'"
# "%0 overrides a member function but is not marked 'override'"
H7449F9821D96: "%0 覆寫了成員函數，但未標示 'override'"
# "%0 parameter marked 'called_once' is called twice"
H9B0F1F204498: "%0 標示 'called_once' 的參數被調用兩次"
# "%0 parameter marked 'called_once' is never %select{used|called}1 when %select{taking true branch|taking false branch|handling this case|none of the cases applies|entering the loop|skipping the loop|taking one of the branches}2"
HBB87206669E4: "%0 標示 'called_once' 的參數在 %select{取真分支|取假分支|處理此案例|所有案例皆不適用|進入迴圈|跳過迴圈|取其中一個分支}2 時從未 %select{使用|調用}1"
# "%0 redeclared with '%1' access"
H6D05457F8E04: "%0 以 '%1' 存取權重新宣告"
# '%0 released here'
H2E4FF4BE13D1: '%0 在這裡釋放'
# "%0 requires %1 type support, but ABI '%2' does not support it"
H03B0999A3C3B: "%0 需要 %1 類型支援，但 ABI '%2' 不支援"
# "%0 requires %select{|%2 bit size}1 %3 %select{|return }4type support, but target '%5' does not support it"
HE937C1210F37: "%0 需要 %select{|%2 位元大小}1 %3 %select{|返回 }4 類型支援，但目標 '%5' 不支援"
# '%0 requires HVX, use -mhvx/-mhvx= to enable it'
H9F7369C63134: '%0 需要 HVX，使用 -mhvx/-mhvx= 開啟它'
# "%0 requires debug info. Use %1 or debug options that enable debugger's stepping function; option ignored"
H985F4F582A8C: '%0 需要除錯資訊。使用 %1 或啟用除錯器單步執行功能的除錯選項；選項被忽略'
# '%0 requires more than 1 template argument; provide the remaining arguments explicitly to use it here'
H33A930D763B0: '%0 需要超過 1 個模板參數；在此處使用時需明確提供剩餘的參數'
# '%0 returns a reference'
H81B0F21DCC91: '%0 返回一個引用'
# '%0 should be declared prior to the call site%select{| or in %2| or in an associated namespace of one of its arguments}1'
H80A1DB32BBA2: '%0 應在呼叫位置 %select{| 或 %2| 或其參數之一的關聯命名空間中}1 提前宣告'
# "%0 should not return a null pointer unless it is declared 'throw()'%select{| or 'noexcept'}1"
HD6330A6C968B: "%0 不應返回空指標，除非它被宣告為 'throw()'%select{| 或 'noexcept'}1"
# '%0 size too large'
HC155B92BBDDE: '%0 大小過大'
# '%0 specified here'
H2793186BA8E0: '%0 在此處指定'
# '%0 takes type size_t (%1) as first parameter'
H994A3A678C5B: '%0 的第一個參數型別需為 size_t (%1)'
# '%0 template must have at least two parameters'
HC33714C2985B: '%0 模板必須至少有兩個參數'
# '%0 type %1 not found; include the base header with -finclude-default-header'
HB4775AA2AD70: '%0 類型 %1 未找到；使用 -finclude-default-header 包含基礎標頭'
# '%0 type was not found; include <coroutine> before defining a coroutine'
H89DE99125E80: '%0 類型未找到；在定義協程前包含 <coroutine>'
# '%0 used as the name of the previous parameter rather than as part of the selector'
HAA86630AF908: '%0 被用作前一個參數的名稱，而非選擇器的一部分'
# '%0 used in array declarator outside of function prototype'
H667299EFB745: '%0 在函數原型外的陣列宣告器中使用'
# '%0 used in declare target directive is not a variable or a function name'
H56AD7716F4DF: '%0 在宣告目標指令中使用時並非變數或函數名稱'
# '%0 used in non-outermost array type derivation'
H7D46A3E1139D: '%0 在非最外層陣列類型推導中使用'
# '%0 variable cannot be %1'
H88684475A953: '%0 變數無法是 %1'
# "%0 variable cannot be in a %1 clause in '#pragma omp %2' directive"
HF56ADE356ADE: '%0 變數不能出現在 "#pragma omp %2" 指令的 %1 子句中'
# '%0 variable must be %1'
H2457271DFCB0: '%0 變數必須是 %1'
# "%0 was %select{disabled|enabled}1 in AST file '%3' but is currently %select{disabled|enabled}2"
HC0632CD5FF96: "%0 在 AST 檔案 '%3' 中 %select{停用|啟用}1，但目前 %select{停用|啟用}2"
# '%0 was deserialized'
H39D399F5AEF8: '%0 已反序列化'
# '%0 was marked unused but was used'
H40B831F8FB51: '%0 被標記為未使用但實際被使用'
# '%0%select{ attribute|}1 cannot be applied to a base specifier'
H11035A3B905C: '%0%select{ 屬性|}1 不能應用於基本類別規範'
# '%0%select{ attribute|}1 cannot be applied to a declaration'
H127063747A92: '%0%select{ 屬性|}1 不能應用於宣告'
# '%0%select{ attribute|}1 cannot be applied to a statement'
H1C3F2544F25A: '%0%select{ 屬性|}1 不能應用於語句'
# '%0%select{ attribute|}1 cannot be applied to types'
H96D80DF95948: '%0%select{ 屬性|}1 不能應用於類型'
# '%0%select{ attribute|}1 only applies to %2'
H45C12381C633: '%0%select{ 屬性|}1 僅適用於 %2'
# '%0%select{ attribute|}1 only applies to %select{functions|unions|variables and functions|functions and methods|functions, methods and blocks|functions, methods, and parameters|variables|variables and fields|variables, data members and tag types|types and namespaces|variables, functions and classes|kernel functions|non-K&R-style functions|for loop statements|virtual functions|parameters and implicit object parameters|non-member functions|functions, classes, or enumerations|classes|typedefs}2'
H9D37840D3CB2: '%0%select{ 屬性|}1 只能套用於 %select{函數|聯合|變數與函數|函數與方法|函數、方法與區塊|函數、方法和參數|變數|變數與成員|變數、資料成員與標記類型|類型與命名空間|變數、函數與類別|核心函數|非K&R式函數|for迴圈陳述式|虛函數|參數與隱含物件參數|非成員函數|函數、類別或列舉|類別|typedef}2'
# "%0%select{| following the 'template' keyword}1 cannot refer to a dependent template"
HA18DA36B7236: "%0%select{| 在 'template' 關鍵字後面}1 不能引用依賴型模板"
# "%0%select{| following the 'template' keyword}1 does not refer to a template"
HCADF8F759262: "%0%select{| 在 'template' 關鍵字後面}1 不是模板"
# "%0: '%1' input unused in cpp mode"
HF14789F9D841: "%0: '%1' 輸入在cpp模式下未被使用"
# "%0: '%1' input unused%select{ when '%3' is present|}2"
HA6B5E8785AC8: "%0: '%1' 輸入未被使用%select{ 當存在 '%3' 時|}2"
# "%0: 'get_return_object_on_allocation_failure()' must be a static member function"
HB26892211ABD: "%0: 'get_return_object_on_allocation_failure()' 必須是靜態成員函數"
# "%0: previously preprocessed input%select{ unused when '%2' is present|}1"
H1EB52EB9DA3B: "%0: 之前預處理的輸入%select{ 當存在 '%2' 時未被使用|}1"
# "%0; allow reordering by specifying '#pragma clang loop vectorize(enable)' before the loop or by providing the compiler option '-ffast-math'"
H50F1AE498158: "%0; 允許重新排序可透過在迴圈前指定 '#pragma clang loop vectorize(enable)' 或提供編譯器選項 '-ffast-math'"
# "%0; allow reordering by specifying '#pragma clang loop vectorize(enable)' before the loop; if the arrays will always be independent, specify '#pragma clang loop vectorize(assume_safety)' before the loop or provide the '__restrict__' qualifier with the independent array arguments -- erroneous results will occur if these options are incorrectly applied"
H696063533F0E: "%0; 允許重新排序可透過在迴圈前指定 '#pragma clang loop vectorize(enable)'；若陣列始終獨立，可指定 '#pragma clang loop vectorize(assume_safety)' 或在獨立陣列參數上使用 '__restrict__' 限定詞 -- 若錯誤套用這些選項將導致結果錯誤"
# '%0B (%human0B) in local locations, %1B (%human1B) in locations loaded from AST files, for a total of %2B (%human2B) (%3%% of available space)'
H9B3C5907D274: '%0B（%human0B）在本地位置，%1B（%human1B）在從AST文件載入的位置，總共 %2B（%human2B）（佔用可用空間的 %3%%）'
# '%1 %0 is hidden by a non-type declaration of %0 here'
HC05432050C69: '%1 %0 被非類型宣告的 %0 隱藏在此處'
# '%1 is a %select{private|protected}0 member of %3'
H4162E2E8D4C1: '%1 是 %3 的%select{私有|受保護}0 成員'
# '%2 defined as %select{a struct|an interface|a class}0%select{| template}1 here but previously declared as %select{a struct|an interface|a class}3%select{| template}1; this is valid, but may result in linker errors under the Microsoft C++ ABI'
H65DDB76661CA: '%2 被定義為%select{結構|介面|類別}0%select{|模板}1，但先前宣告為%select{結構|介面|類別}3%select{|模板}1；此符合語法，但可能在Microsoft C++ ABI下導致連結器錯誤'
# '%diff{$ and $ are not pointers to compatible types|pointers to incompatible types}0,1'
HE4DF3395C0FE: '%diff{ $和$不是兼容類型的指標 | 指向不兼容類型的指標 }0,1'
# '%diff{promoted type $ of K&R function parameter is not compatible with the parameter type $|promoted type of K&R function parameter is not compatible with parameter type}0,1 declared in a previous prototype'
HBE91EA4F0CCD: '%diff{ K&R函數參數的提升類型$與參數類型$不兼容 | K&R函數參數的提升類型與參數類型不兼容 }0,1 在先前的原型中宣告'
# '%diff{return type $ must match previous return type $|return type must match previous return type}0,1 when %select{block literal|lambda expression}2 has unspecified explicit return type'
H503B0717AF47: '%diff{返回類型 $ 必須與先前的返回類型 $ 一致|返回類型必須與先前的返回類型一致}1,0 當 %select{區塊iteral|lambda運算式}2 具有未指定的明確返回類型時'
# "%ordinal0 argument must be a %select{|scalar|vector|matrix|vector of|scalar or vector of}1%plural{[2,3]:%plural{0:|:%plural{0:|:,}2}3|:}1%plural{0:|: }1%select{|integer|signed integer|unsigned integer|'int'|pointer to a valid matrix element}2%plural{0:|: }2%plural{0:|:%plural{0:|:or }2}3%select{|floating-point}3%plural{0:|: }3%plural{[0,3]:type|:types}1 (was %4)"
HEE73BAE75429: '%ordinal0參數必須是 %select{|純量|向量|矩陣|向量的|純量或向量的}1%plural{[2,3]:%plural{0:|:%plural{0:|:,}2}3|:}1%plural{0:|: }1%select{|整數|帶符號整數|無符號整數|int類型|指向有效矩陣元素的指標}2%plural{0:|: }2%plural{0:|:%plural{0:|:或 }2}3%select{|浮點數}3%plural{0:|: }3%plural{[0,3]:類型|:類型}1（實際是 %4）'
# '%ordinal0 argument must be a WebAssembly table'
HF0E3AF42C5DD: '%ordinal0參數必須是WebAssembly表'
# '%ordinal0 argument must be an integer'
HB74677AB0CCF: '%ordinal0參數必須是整數'
# '%ordinal0 argument must match the element type of the WebAssembly table in the %ordinal1 argument'
HCC6BF06B970F: '%ordinal0參數必須與%ordinal1參數中的WebAssembly表的元素類型相符'
# '%plural{1:enumeration value %1 not explicitly handled in switch|2:enumeration values %1 and %2 not explicitly handled in switch|3:enumeration values %1, %2, and %3 not explicitly handled in switch|:%0 enumeration values not explicitly handled in switch: %1, %2, %3...}0'
HE8DAC9A52D87: '%plural{1:列舉值 %1 在switch中未明確處理|2:列舉值 %1 和 %2 在switch中未明確處理|3:列舉值 %1、%2 和 %3 在switch中未明確處理|:%0 列舉值在switch中未明確處理：%1、%2、%3...}0'
# '%plural{1:enumeration value %1 not handled in switch|2:enumeration values %1 and %2 not handled in switch|3:enumeration values %1, %2, and %3 not handled in switch|:%0 enumeration values not handled in switch: %1, %2, %3...}0'
H0E3F79F6C010: '%plural{1:列舉值 %1 在switch中未處理|2:列舉值 %1 和 %2 在switch中未處理|3:列舉值 %1、%2 和 %3 在switch中未處理|:%0 列舉值在switch中未處理：%1、%2、%3...}0'
# "%plural{2:'delete' used to delete pointer to object allocated with 'std::allocator<...>::allocate'|:%select{non-array delete|array delete|'std::allocator<...>::deallocate'}0 used to delete pointer to %select{array object of type %2|non-array object of type %2|object allocated with 'new'}0}1"
H1294E54BD6EF: "%plural{2:'delete' 用於刪除以 'std::allocator<...>::allocate' 分配的物件指標|:%select{非陣列delete|陣列delete|'std::allocator<...>::deallocate'}0 用於刪除%select{陣列物件類型 %2|非陣列物件類型 %2|以 'new' 分配的物件}0}1"
# '%plural{[0,2]:must use a qualified name when declaring|3:cannot declare}0 a %select{constructor|destructor|conversion operator|deduction guide}0 as a friend'
H180E877A4B1E: '%plural{[0,2]:宣告時必須使用合格名稱|3:無法宣告}0 %select{建構函數|解構函數|轉換運算子|推論指引}0 作為友元'
# "%q0 %select{with definition in module '%2'|defined here}1 has different definitions in different modules; first difference is this %select{||||static assert|field|method|type alias|typedef|data member|friend declaration|function template|method|instance variable|property|unexpected decl}3"
HC2ECA20D4E80: "%q0 %select{在模組 '%2' 中有定義|定義在此處}1 在不同模組中有不同的定義；第一個差異是此 %select{||||static assert|成員變數|方法|類型別名|typedef|資料成員|友元宣告|函數模板|方法|實體變數|屬性|未知宣告}3"
# '%q0 cannot be thread local when declared %q1'
H1F0205F4AD29: '%q0 當宣告為%q1 時不能是線程局部'
# "%q0 from module '%1' is not present in definition of %q2%select{ in module '%4'| provided earlier}3"
H9DF776E318FF: "%q0 來自模組 '%1' 的內容未出現在 %q2%select{ 模組 '%4' 的定義中|先前的定義中}3"
# "%q0 has different definitions in different modules; %select{definition in module '%2' is here|defined here}1"
HB3D6EB7685C3: "%q0 在不同模組中有不同的定義；%select{模組 '%2' 中的定義在此|在此處定義}1"
# "%q0 has different definitions in different modules; %select{definition in module '%2'|defined here}1 first difference is %select{enum that is %select{not scoped|scoped}4|enum scoped with keyword %select{struct|class}4|enum %select{without|with}4 specified type|enum with specified type %4|enum with %4 element%s4|%ordinal4 element has name %5|%ordinal4 element %5 %select{has|does not have}6 an initializer|%ordinal4 element %5 has an initializer|}3"
H39CEC8B6DBEB: "%q0 在不同模組中有不同的定義；%select{模組 '%2' 中的定義在此|在此處定義}1 第一個差異是%select{列舉%select{未指定為作用域|指定為作用域}4|列舉以關鍵字 %select{struct|class}4 指定為作用域|列舉%select{無|有}4指定類型|列舉具有指定類型 %4|列舉具有 %4 個元素|%ordinal4個元素名稱為 %5|%ordinal4個元素 %5 %select{有|沒有}6 初始值|%ordinal4個元素 %5 有初始值|}3"
# "%q0 has different definitions in different modules; %select{definition in module '%2'|defined here}1 first difference is %select{return type is %4|%ordinal4 parameter with name %5|%ordinal4 parameter with type %5%select{| decayed from %7}6|%ordinal4 parameter with%select{out|}5 a default argument|%ordinal4 parameter with a default argument|function body}3"
H68AA8A549FAA: "%q0 在不同模組中具有不同的定義；%select{模組 '%2' 中的定義|在此處定義}1 第一個差異是 %select{返回類型為 %4|%ordinal4 參數具有名稱 %5|%ordinal4 參數具有類型 %5%select{| 退化自 %7}6|%ordinal4 參數具有 %select{out|}5 預設參數|%ordinal4 參數具有預設參數|函數主體}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%4 base %plural{1:class|:classes}4|%4 virtual base %plural{1:class|:classes}4|%ordinal4 base class with type %5|%ordinal4 %select{non-virtual|virtual}5 base class %6|%ordinal4 base class %5 with %select{public|protected|private|no}6 access specifier}3"
HC4303FABC437: "%q0 在不同模組中具有不同的定義；第一個差異是 %select{模組 '%2' 中的定義|在此處定義}1 發現 %select{%4 基底 %plural{1:類別|:類別}4|%4 虛基底 %plural{1:類別|:類別}4|%ordinal4 基底類別具有類型 %5|%ordinal4 %select{非虛|虛}5 基底類別 %6|%ordinal4 基底類別 %5 具有 %select{公開|受保護|私有|無}6 存取修飾符}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%4 referenced %plural{1:protocol|:protocols}4|%ordinal4 referenced protocol with name %5}3"
HC9695A16C965: "%q0 在不同模組中有不同的定義；第一個差異是 %select{模組 '%2' 中的定義|定義在此處}1 發現 %select{%4 參考 %plural{1:協定|:協定們}4|%ordinal4 參考名稱為 %5 的協定}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%select{method %5|constructor|destructor}4 that has %6 parameter%s6|%select{method %5|constructor|destructor}4 with %ordinal6 parameter of type %7%select{| decayed from %9}8|%select{method %5|constructor|destructor}4 with %ordinal6 parameter named %7}3"
HA17814A91726: "%q0 在不同模組中具有不同的定義；第一個差異是 %select{模組 '%2' 中的定義|在此處定義}1 發現 %select{%select{方法 %5|建構函數|析構函數}4 具有 %6 參數%s6|%select{方法 %5|建構函數|析構函數}4 具有第 %ordinal6 參數類型 %7%select{| 退化自 %9}8|%select{方法 %5|建構函數|析構函數}4 具有第 %ordinal6 參數名稱 %7}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%select{typedef|type alias}4 name %5|%select{typedef|type alias}4 %5 with underlying type %6}3"
H290AB6198D53: "%q0 在不同模組中具有不同的定義；第一個差異是 %select{模組 '%2' 中的定義|在此處定義}1 發現 %select{%select{類型別名|typedef}4 名稱 %5|%select{類型別名|typedef}4 %5 具有基礎類型 %6}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{data member with name %4|data member %4 with type %5|data member %4 with%select{out|}5 an initializer|data member %4 with an initializer|data member %4 %select{is constexpr|is not constexpr}5}3"
H3C6A067820A4: "%q0 在不同模組中具有不同的定義；第一個差異是 %select{模組 '%2' 中的定義|在此處定義}1 發現 %select{資料成員名稱 %4|資料成員 %4 具有類型 %5|資料成員 %4 具有 %select{out|}5 初始化式|資料成員 %4 具有初始化式|資料成員 %4 %select{是 constexpr|不是 constexpr}5}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{end of class|public access specifier|private access specifier|protected access specifier|static assert|field|method|type alias|typedef|data member|friend declaration|function template|method|instance variable|property}3"
HC7FCD2470FA2: "%q0 在不同模組中具有不同的定義；第一個差異是 %select{模組 '%2' 中的定義|在此處定義}1 發現 %select{類別結束|公開存取修飾符|私有存取修飾符|受保護存取修飾符|static assert|資料成員|方法|類型別名|typedef|資料成員|朋友宣告|函數範本|方法|實體變數|屬性}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{field %4|field %4 with type %5|%select{non-|}5bit-field %4|bit-field %4 with one width expression|%select{non-|}5mutable field %4|field %4 with %select{no|an}5 initializer|field %4 with an initializer}3"
H60D85DC0E685: "%q0 在不同模組中具有不同的定義；第一個差異是 %select{模組 '%2' 中的定義|在此處定義}1 發現 %select{成員 %4|成員 %4 具有類型 %5|%select{非-|}5 位元域 %4|位元域 %4 具有一個寬度運算式|%select{非-|}5mutable 成員 %4|成員 %4 具有%select{無|}5 初始化式|成員 %4 具有初始化式}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{method %4 with return type %5|%select{class|instance}5 method %4|%select{no|'required'|'optional'}4 method control|method %4 with %select{no designated initializer|designated initializer}5|%select{regular|direct}5 method %4|method %4}3"
H5AECB1226BDE: "%q0 在不同模組中有不同的定義；第一個差異在 %select{模組 '%2' 的定義中|在此處定義}1 發現 %select{返回類型為 %5 的方法 %4|%select{類別|實體}5 方法 %4|%select{未指定|'required'|'optional'}4 方法控制|具有 %select{非指定初始化程式|指定初始化程式}5 的方法 %4|%select{一般|直接}5 方法 %4|方法 %4}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{property %4|property %4 with type %5|%select{no|'required'|'optional'}4 property control|property %4 with %select{default |}6'%select{none|readonly|getter|assign|readwrite|retain|copy|nonatomic|setter|atomic|weak|strong|unsafe_unretained|nullability|null_resettable|class|direct}5' attribute}3"
H47E62251068F: "%q0 在不同模組中具有不同的定義；第一個差異是 %select{模組 '%2' 中的定義|在此處定義}1 發現 %select{屬性 %4|屬性 %4 具有類型 %5|%select{無|'required'|'optional'}4 屬性控制|屬性 %4 具有 %select{default |}6'%select{none|readonly|getter|assign|readwrite|retain|copy|nonatomic|setter|atomic|weak|strong|unsafe_unretained|nullability|null_resettable|class|direct}5' 屬性}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{static assert with condition|static assert with message|static assert with %select{|no }4message|%select{method %5|constructor|destructor}4|%select{method %5|constructor|destructor}4 is %select{not deleted|deleted}6|%select{method %5|constructor|destructor}4 is %select{not defaulted|defaulted}6|%select{method %5|constructor|destructor}4 is %select{|pure }6%select{not virtual|virtual}7|%select{method %5|constructor|destructor}4 is %select{not static|static}6|%select{method %5|constructor|destructor}4 is %select{not volatile|volatile}6|%select{method %5|constructor|destructor}4 is %select{not const|const}6|%select{method %5|constructor|destructor}4 is %select{not inline|inline}6|%select{method %5|constructor|destructor}4 with %ordinal6 parameter with%select{out|}7 a default argument|%select{method %5|constructor|destructor}4 with %ordinal6 parameter with a default argument|%select{method %5|constructor|destructor}4 with %select{no |}6template arguments|%select{method %5|constructor|destructor}4 with %6 template argument%s6|%select{method %5|constructor|destructor}4 with %6 for %ordinal7 template argument|%select{method %5|constructor|destructor}4 with %select{no body|body}6|%select{method %5|constructor|destructor}4 with body|friend %select{class|function}4|friend %4|friend function %4|function template %4 with %5 template parameter%s5|function template %4 with %ordinal5 template parameter being a %select{type|non-type|template}6 template parameter|function template %4 with %ordinal5 template parameter %select{with no name|named %7}6|function template %4 with %ordinal5 template parameter with %select{no |}6default argument|function template %4 with %ordinal5 template parameter with default argument %6|function template %4 with %ordinal5 template parameter with one type|function template %4 with %ordinal5 template parameter %select{not |}6being a template parameter pack|}3"
HCEB41952ED68: "%q0 在不同模組中有不同的定義；第一處差異是 %select{模組 '%2' 中的定義|在此處定義}1 發現 %select{條件為的 static assert|訊息為的 static assert|條件%select{無訊息|}4 的 static assert|%select{方法 %5|建構函數|析構函數}4|%select{方法 %5|建構函數|析構函數}4 %select{未標記為 deleted|已被標記為 deleted}6|%select{方法 %5|建構函數|析構函數}4 %select{未標記為 defaulted|已被標記為 defaulted}6|%select{方法 %5|建構函數|析構函數}4 是%select{非虛|虛}6%select{非虛函數|虛函數}7|%select{方法 %5|建構函數|析構函數}4 %select{未標記為 static|已被標記為 static}6|%select{方法 %5|建構函數|析構函數}4 %select{未標記為 volatile|已被標記為 volatile}6|%select{方法 %5|建構函數|析構函數}4 %select{未標記為 const|已被標記為 const}6|%select{方法 %5|建構函數|析構函數}4 %select{未標記為 inline|已被標記為 inline}6|%select{方法 %5|建構函數|析構函數}4 具有第 %ordinal6 個參數%select{無|}7 預設值|%select{方法 %5|建構函數|析構函數}4 具有第 %ordinal6 個預設值參數|%select{方法 %5|建構函數|析構函數}4 %select{無|}6 模板參數|%select{方法 %5|建構函數|析構函數}4 具有 %6 個模板參數%s6|%select{方法 %5|建構函數|析構函數}4 具有第 %ordinal7 個模板參數 %6|%select{方法 %5|建構函數|析構函數}4 %select{無函數體|有函數體}6|%select{方法 %5|建構函數|析構函數}4 有函數體|friend %select{類別|函數}4|friend %4|friend 函數 %4|函數模板 %4 具有 %5 個模板參數%s5|函數模板 %4 的第 %ordinal5 個模板參數為 %select{類型|非類型|模板}6 參數類型|函數模板 %4 的第 %ordinal5 個模板參數%select{未命名|命名為 %7}6|函數模板 %4 的第 %ordinal5 個模板參數%select{無|}6 預設值|函數模板 %4 的第 %ordinal5 個模板參數預設值為 %6|函數模板 %4 的第 %ordinal5 個模板參數為單一類型|函數模板 %4 的第 %ordinal5 個模板參數%select{非|}6 為模板參數包|}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{unnamed template parameter|template parameter %5|template parameter with %select{no |}4default argument|template parameter with default argument}3"
HA9E92FE31082: "%q0 在不同模組中具有不同的定義；第一個差異是 %select{模組 '%2' 中的定義|在此處定義}1 發現 %select{無名稱範本參數|範本參數 %5|範本參數具有%select{無 |}4 預設參數|範本參數具有預設參數}3"
# '%q0 hides overloaded virtual %select{function|functions}1'
H2FDDD909C4BF: '%q0 隱藏了重載的虛函數 %select{函數|函數}1'
# '%q0 is not a member of class %1'
H76BB7974AA85: '%q0 不是類別 %1 的成員'
# '%q0 must have external linkage when declared %q1'
HEEACDE119817: '%q0 在宣告 %q1 時必須具有外部連結性'
# '%q0 redeclared inline; %1 attribute ignored'
HE698B2D72430: '%q0 重新宣告為 inline；%1 屬性被忽略'
# '%q0 redeclared without %1 attribute: previous %1 ignored'
HD8FE54A130EE: '%q0 重新宣告時未指定 %1 屬性：先前 %1 被忽略'
# "%q0 redeclared without 'dllimport' attribute: 'dllexport' attribute added"
H6D76D4BE2232: "%q0 重新宣告時未指定 'dllimport' 屬性：'dllexport' 屬性被新增"
# '%select{#elif|#elifdef|#elifndef}0 after #else'
H66B8B159F15D: '%select{#elif|#elifdef|#elifndef}0 在 #else 後面'
# '%select{#elif|#elifdef|#elifndef}0 without #if'
HF4D335F3B905: '%select{#elif|#elifdef|#elifndef}0 沒有 #if 陳述式'
# '%select{#line|GNU line marker}0 directive interprets number as decimal, not octal'
HDF9BCDB36B4E: '%select{#line|GNU line marker}0 指令將數字解讀為十進位而非八進位'
# '%select{#line|GNU line marker}0 directive requires a simple digit sequence'
H065F2C4ACA47: '%select{#line|GNU line marker}0 指令需要純數字序列'
# '%select{%1 and |}0%2 tokens %select{introducing statement expression|terminating statement expression|introducing attribute|terminating attribute|forming pointer to member type}3 appear in different macro expansion contexts'
H64A1AC254D6A: '%select{%1 和 |}0%2 符號 %select{引進陳述式運算式|結束陳述式運算式|引進屬性|結束屬性|形成成員指標類型}3 出現在不同的宏展開環境中'
# '%select{%1 and |}0%2 tokens %select{introducing statement expression|terminating statement expression|introducing attribute|terminating attribute|forming pointer to member type}3 are separated by whitespace'
H9C7F5E5CC536: '%select{%1 和 |}0%2 符號 %select{引進陳述式運算式|結束陳述式運算式|引進屬性|結束屬性|形成成員指標類型}3 被空白分隔'
# '%select{%1 is a virtual base class of base class %2 declared here|virtual base class %1 declared here}0'
H0907DB13630C: '%select{%2 的基類 %1 此處宣告為虛基類|虛基類 %1 此處宣告}0'
# '%select{%2 has subobjects that are|%3 has type %2 that is}0 non-trivial to %select{default-initialize|destruct|copy}1'
H48AF719C5841: '%select{第 %2 個子物件|%3 具有類型 %2 的物件}0 無法被 %select{預設建構|析構|複製}1'
# '%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes address space of nested pointer'
H229282294F90: '%select{%diff{將 $ 賦值給 $|賦值給不同類型}1,0|%diff{將 $ 傳遞給類型為 $ 的參數|傳遞給不同類型參數}0,1|%diff{從具有結果類型 $ 的函式返回 $|從不同返回類型函式返回}0,1|%diff{轉換 $ 為類型 $|轉換不同類型}0,1|%diff{以類型 $ 的運算式初始化 $|以不同類型運算式初始化}0,1|%diff{將 $ 傳遞給類型為 $ 的參數|傳遞給不同類型參數}0,1|%diff{將 $ 轉換為類型 $|轉換不同類型}0,1}2 變更巢狀指標的記憶體空間'
# '%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes address space of pointer'
H34858D5559B9: '%select{%diff{將 $ 賦值給 $|賦值給不同類型}1,0|%diff{將 $ 傳遞給類型為 $ 的參數|傳遞給不同類型參數}0,1|%diff{從具有結果類型 $ 的函式返回 $|從不同返回類型函式返回}0,1|%diff{轉換 $ 為類型 $|轉換不同類型}0,1|%diff{以類型 $ 的運算式初始化 $|以不同類型運算式初始化}0,1|%diff{將 $ 傳遞給類型為 $ 的參數|傳遞給不同類型參數}0,1|%diff{將 $ 轉換為類型 $|轉換不同類型}0,1}2 變更指標的記憶體空間'
# '%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes retain/release properties of pointer'
HCD0B002FCAD8: '%select{%diff{將 $ 賦值給 $|賦值給不同類型}1,0|%diff{將 $ 傳遞給類型為 $ 的參數|傳遞給不同類型參數}0,1|%diff{從具有結果類型 $ 的函式返回 $|從不同返回類型函式返回}0,1|%diff{轉換 $ 為類型 $|轉換不同類型}0,1|%diff{以類型 $ 的運算式初始化 $|以不同類型運算式初始化}0,1|%diff{將 $ 傳遞給類型為 $ 的參數|傳遞給不同類型參數}0,1|%diff{將 $ 轉換為類型 $|轉換不同類型}0,1}2 變更指標的retain/release屬性'
# "%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 converts between pointers to integer types %select{with different sign|where one is of the unique plain 'char' type and the other is not}3"
H1F24CCDCD587: "%select{%diff{將 $ 賦值給 $|賦值給不同類型}1,0|%diff{將 $ 傳遞給類型為 $ 的參數|傳遞給不同類型參數}0,1|%diff{從具有結果類型 $ 的函式返回 $|從不同返回類型函式返回}0,1|%diff{轉換 $ 為類型 $|轉換不同類型}0,1|%diff{以類型 $ 的運算式初始化 $|以不同類型運算式初始化}0,1|%diff{將 $ 傳遞給類型為 $ 的參數|傳遞給不同類型參數}0,1|%diff{將 $ 轉換為類型 $|轉換不同類型}0,1}2 在整數類型指標間轉換%select{具有不同符號|其中一個為唯一普通 'char' 類型而另一個不是}3"
# '%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 converts between void pointer and function pointer'
HA7C5AA745059: '%select{%diff{將 $ 賦值給 $|賦值給不同類型}1,0|%diff{將 $ 傳遞給類型為 $ 的參數|傳遞給不同類型參數}0,1|%diff{從具有結果類型 $ 的函式返回 $|從不同返回類型函式返回}0,1|%diff{轉換 $ 為類型 $|轉換不同類型}0,1|%diff{以類型 $ 的運算式初始化 $|以不同類型運算式初始化}0,1|%diff{將 $ 傳遞給類型為 $ 的參數|傳遞給不同類型參數}0,1|%diff{將 $ 轉換為類型 $|轉換不同類型}0,1}2 在void指標與函式指標間轉換'
# '%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers'
H7F0C4095C720: '%select{%diff{將 $ 賦值給 $|將不同類型賦值}1,0|%diff{將 $ 傳遞給 $ 類型的參數|將參數傳遞給不同類型}1,0|%diff{從具有返回類型 $ 的函數返回 $|從函數返回不同類型}1,0|%diff{將 $ 轉換為 $ 類型|轉換不同類型}1,0|%diff{用 $ 類型的運算式初始化 $|用不同類型運算式初始化}1,0|%diff{將 $ 傳遞給 $ 類型的參數|將參數傳遞給不同類型}1,0|%diff{將 $ 轉換為 $ 類型|轉換不同類型}1,0}2 丟棄了修飾符'
# '%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers in nested pointer types'
HA6738ACC7EBA: '%select{%diff{將 $ 賦值給 $|將不同類型賦值}1,0|%diff{將 $ 傳遞給 $ 類型的參數|將參數傳遞給不同類型}1,0|%diff{從具有返回類型 $ 的函數返回 $|從函數返回不同類型}1,0|%diff{將 $ 轉換為 $ 類型|轉換不同類型}1,0|%diff{用 $ 類型的運算式初始化 $|用不同類型運算式初始化}1,0|%diff{將 $ 傳遞給 $ 類型的參數|將參數傳遞給不同類型}1,0|%diff{將 $ 轉換為 $ 類型|轉換不同類型}1,0}2 丟棄了巢狀指標類型的修飾符'
# '%select{%diff{assigning to $ from incompatible type $|assigning to type from incompatible type}0,1|%diff{passing $ to parameter of incompatible type $|passing type to parameter of incompatible type}0,1|%diff{returning $ from a function with incompatible result type $|returning type from a function with incompatible result type}0,1|%diff{converting $ to incompatible type $|converting type to incompatible type}0,1|%diff{initializing $ with an expression of incompatible type $|initializing type with an expression of incompatible type}0,1|%diff{sending $ to parameter of incompatible type $|sending type to parameter of incompatible type}0,1|%diff{casting $ to incompatible type $|casting type to incompatible type}0,1}2'
HCAB9D3041C51: '%select{%diff{將 $ 賦值給不相容類型 $|將類型賦值給不相容類型}1,0|%diff{將 $ 傳遞給不相容類型 $ 的參數|將類型傳遞給不相容參數類型}1,0|%diff{從具有不相容返回類型 $ 的函數返回 $|從函數返回不相容類型}1,0|%diff{將 $ 轉換為不相容類型 $|將類型轉換為不相容類型}1,0|%diff{用 $ 類型的運算式初始化 $|用不相容類型運算式初始化}1,0|%diff{將 $ 傳遞給不相容類型 $ 的參數|將類型傳遞給不相容參數類型}1,0|%diff{將 $ 轉換為不相容類型 $|將類型轉換為不相容類型}1,0}2'
# '%select{%diff{assigning to $ from incompatible type $|assigning to type from incompatible type}0,1|%diff{passing $ to parameter of incompatible type $|passing type to parameter of incompatible type}0,1|%diff{returning $ from a function with incompatible result type $|returning type from a function with incompatible result type}0,1|%diff{converting $ to incompatible type $|converting type to incompatible type}0,1|%diff{initializing $ with an expression of incompatible type $|initializing type with an expression of incompatible type}0,1|%diff{sending $ to parameter of incompatible type $|sending type to parameter of incompatible type}0,1|%diff{casting $ to incompatible type $|casting type to incompatible type}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3%select{|: different classes%diff{ ($ vs $)|}5,6|: different number of parameters (%5 vs %6)|: type mismatch at %ordinal5 parameter%diff{ ($ vs $)|}6,7|: different return type%diff{ ($ vs $)|}5,6|: different qualifiers (%5 vs %6)|: different exception specifications}4'
H5631F8DA82CD: '%select{%diff{將 $ 賦值給不相容類型 $|將類型賦值給不相容類型}1,0|%diff{將 $ 傳遞給不相容類型 $ 的參數|將類型傳遞給不相容參數類型}1,0|%diff{從具有不相容返回類型 $ 的函數返回 $|從函數返回不相容類型}1,0|%diff{將 $ 轉換為不相容類型 $|將類型轉換為不相容類型}1,0|%diff{用 $ 類型的運算式初始化 $|用不相容類型運算式初始化}1,0|%diff{將 $ 傳遞給不相容類型 $ 的參數|將類型傳遞給不相容參數類型}1,0|%diff{將 $ 轉換為不相容類型 $|將類型轉換為不相容類型}1,0}2%select{|；使用 * 解引用|；取得位址 &|；移除 *|；移除 &}3%select{|：不同類別%diff{ ($ vs $)|}5,6|：參數數量不同 (%5 vs %6)|：第 %ordinal5 個參數類型不匹配%diff{ ($ vs $)|}6,7|：返回類型不同%diff{ ($ vs $)|}5,6|：修飾符不同 (%5 vs %6)|：例外規格不同}4'
# '%select{%select{increment|decrement}1 of readonly property|no setter method %2 for %select{increment|decrement}1 of property}0'
HAF55C5B7D9CC: '%select{%select{遞增|遞減}1 唯讀屬性|無設定器方法 %2 對 %select{遞增|遞減}1 屬性}0'
# "%select{%select{reference|'std::initializer_list'}0 member|member with %select{reference|'std::initializer_list'}0 subobject}1 declared here"
H1B5CDFE7B6DA: "%select{具有 %select{參考|'std::initializer_list'}0 子物件的成員|具有 %select{參考|'std::initializer_list'}0 的成員}1 在此處宣告"
# "%select{'#pragma clang fp eval_method'|option 'ffp-eval-method'}0 cannot be used with %select{option 'fapprox-func'|option 'mreassociate'|option 'freciprocal'|option 'ffp-eval-method'|'#pragma clang fp reassociate'|'#pragma clang fp reciprocal'}1"
HD4A3AC42422A: "%select{'#pragma clang fp eval_method'|選項 'ffp-eval-method'}0 不能與 %select{選項 'fapprox-func'|選項 'mreassociate'|選項 'freciprocal'|選項 'ffp-eval-method'|'#pragma clang fp reassociate'|'#pragma clang fp reciprocal'}1 併用"
# "%select{'auto'|'decltype(auto)'|'__auto_type'|template arguments}0 deduced as %1 in declaration of %2 and deduced as %3 in declaration of %4"
H11DB7A31A7DA: "%select{'auto'|'decltype(auto)'|'__auto_type'|模板參數}0 在 %2 的宣告中推論為 %1，但在 %4 的宣告中推論為 %3"
# "%select{'auto'|'decltype(auto)'|'__auto_type'|use of %select{class template|function template|variable template|alias template|template template parameter|concept|template}2 %3 requires template arguments; argument deduction}0 not allowed %select{in function prototype|in non-static struct member|in struct member|in non-static union member|in union member|in non-static class member|in interface member|in exception declaration|in template parameter until C++17|in block literal|in template argument|in typedef|in type alias|in function return type|in conversion function type|here|in lambda parameter|in type allocated by 'new'|in K&R-style function parameter|in template parameter|in friend declaration|in function prototype that is not a function declaration|in requires expression parameter|in array declaration|in declaration of conversion function template|in lambda parameter before C++14}1"
H7226E87E7B56: "%select{'auto'|'decltype(auto)'|'__auto_type'|使用 %select{類別模板|函數模板|變數模板|別名模板|模板模板參數|概念|模板}2 %3 需要模板參數；參數推導}0 不允許 %select{在函數原型|在非靜態結構成員|在結構成員|在非靜態共用體成員|在共用體成員|在非靜態類別成員|在介面成員|在例外宣告|在 C++17 前的模板參數|在區塊字面值|在模板參數|在 typedef|在類型別名|在函數返回類型|在轉換函數類型|在此處|在 lambda 參數|在 'new' 分配的類型|在 K&R 風格函數參數|在模板參數|在 friend 宣告|在非函數宣告的函數原型|在 requires 表達式參數|在陣列宣告|在轉換函數模板宣告|在 lambda 參數前 C++14}1"
# "%select{'mutable'|'static'|'constexpr'|'consteval'}0 cannot appear multiple times in a lambda declarator"
HA9F29290F39F: "%select{'mutable'|'static'|'constexpr'|'consteval'}0 不能在 lambda 声明器中出現多次"
# "%select{'size' argument to memset is '0'|setting buffer to a 'sizeof' expression}0; did you mean to transpose the last two arguments?"
HBE450D9F2F6C: "%select{ memset 的 'size' 參數為 '0'|將緩衝區設定為 sizeof 表達式}0；是否要交換最後兩個參數？"
# '%select{<ERROR>|constexpr|consteval|constinit}0 can only be used in %select{|variable and function|function|variable}0 declarations'
H8ABC77B14403: '%select{<ERROR>|constexpr|consteval|constinit}0 只能用於 %select{|變數和函數|函數|變數}0 宣告'
# '%select{<ERROR>|equality|three-way|equality|relational}0 comparison operator is not a friend of %select{|incomplete class }1%2'
HFE0AE74FD7A7: '%select{<error>|相等|三向|相等|關係}0 運算子不是 %select{|不完整類別 }1%2 的友元'
# '%select{<error>|function template|variable template|alias template|template template parameter|concept|template}0 %1 requires template arguments; argument deduction only allowed for class templates or alias templates'
HDE23AA7C6E82: '%select{<error>|函數範本|變數範本|別名範本|模板模板參數|概念|模板}0 %1 需要模板參數；類型推論僅允許用於類別範本或別名範本'
# '%select{@available|__builtin_available}0 does not guard availability here; use if (%select{@available|__builtin_available}0) instead'
HBA44F219FD20: '%select{@available|__builtin_available}0 不在此處保護可用性；請改用 if (%select{@available|__builtin_available}0) 的條件'
# "%select{AST file '%1' was|current translation unit is}0 compiled with the target feature '%2' but the %select{current translation unit is|AST file '%1' was}0 not"
H5C12AF216CA3: "%select{AST 檔案 '%1' 已|當前翻譯單位是}0 以目標特徵 '%2' 編譯，但 %select{當前翻譯單位是|AST 檔案 '%1' 已}0 未啟用"
# "%select{MIPS|MSP430|RISC-V|AVR}0 '%select{interrupt|signal}1' attribute only applies to functions that have %select{no parameters|a 'void' return type}2"
HC530D462FB18: "%select{MIPS|MSP430|RISC-V|AVR}0 '%select{interrupt|signal}1' 屬性僅適用於 %select{無參數|返回類型為 'void'}2 的函數"
# "%select{OpenACC '%3' construct|while loop|do loop}0 cannot appear in intervening code of a '%1' with a '%2' clause"
HB2C5F39C46C3: "%select{OpenACC '%3' 構造式|while 迴圈|do 迴圈}0 不可出現在 '%1' 具有 '%2' 子句的中間代碼區塊"
# "%select{OpenACC 'gang' clause with a 'dim' value greater than 1|OpenACC 'reduction' clause}0 cannot appear on the same '%1' construct as a %select{'reduction' clause|'gang' clause with a 'dim' value greater than 1}0"
H3449F0200ABB: "%select{OpenACC 'gang' 建構項的 dim 值大於 1|OpenACC 'reduction' 建構項}0 不能與 '%1' 建構項的 %select{'reduction' 子句|'gang' 子句（dim>1）}0 同時存在"
# '%select{OpenACC sub-array|OpenMP array section}0 is not allowed here'
H8129F6E36883: '%select{OpenACC 子陣列|OpenMP 陣列切片}0 此處不被允許'
# '%select{PCH|current translation unit}0 has no VFS overlays'
H1F8E7EA59762: '%select{PCH|當前翻譯單位}0 無虛擬文件系統覆蓋層'
# '%select{PCH|current translation unit}0 has the following VFS overlays:\n%1'
HF3357458F7A1: '%select{PCH|當前翻譯單位}0 的虛擬文件系統覆蓋層如下：\n%1'
# "%select{PCH|module|AST}0 file '%1' built from a different branch (%2) than the compiler (%3)"
H47225B26A402: "%select{PCH|模組|AST}0 檔案 '%1' 編譯自不同分支 (%2)，而編譯器分支為 (%3)"
# "%select{PCH|module|AST}0 file '%1' contains compiler errors"
H70FD1E0F0771: "%select{PCH|模組|AST}0 檔案 '%1' 包含編譯錯誤"
# "%select{PCH|module|AST}0 file '%1' is out of date and needs to be rebuilt%select{|: %3}2"
H1F11095B483F: "%select{PCH|模組|AST}0 檔案 '%1' 已過期需重新建置 %select{|： %3}2"
# "%select{PCH|module|AST}0 file '%1' not found%select{|: %3}2"
HA37A363A734E: "%select{PCH|模組|AST}0 檔案 '%1' 未找到 %select{|： %3}2"
# "%select{PCH|module|AST}0 file '%1' uses a newer format that cannot be read"
H80665252BAE8: "%select{PCH|模組|AST}0 檔案 '%1' 使用較新的格式無法讀取"
# "%select{PCH|module|AST}0 file '%1' uses an older format that is no longer supported"
HB4B0734241D0: "%select{PCH|模組|AST}0 檔案 '%1' 使用已不支援的舊版格式"
# '%select{__block variables|global variables|fields|instance variables}0 cannot have __autoreleasing ownership'
H8459C5DA92C1: '%select{__block 變數|全域變數|成員|實體變數}0 無法具有 __autoreleasing 所有權'
# '%select{__device__|__global__|__host__|__host__ __device__}0 function %1 cannot overload %select{__device__|__global__|__host__|__host__ __device__}2 function %3'
HD56CBB05D1A2: '%select{__device__|__global__|__host__|__host__ __device__}0 函數 %1 無法與 %select{__device__|__global__|__host__|__host__ __device__}2 函數 %3 進行多載'
# '%select{a reference type|an array type|a non-vector or non-vectorizable scalar type}0 is an invalid argument to attribute %1'
H9A7D97DDD421: '%select{參考類型|陣列類型|非向量或非向量化純量類型}0 是屬性 %1 的無效參數'
# "%select{a variable|a parameter|'this'}0 cannot appear in more than one %1 clause"
HE09D18DCA51A: "%select{變數|參數|'this'}0 不可出現在超過一個 %1 子句"
# '%select{address of|reference to}0 stack memory associated with %select{local variable|parameter|compound literal}2 %1 %select{returned|passed to musttail function}3'
HDE8352A90808: '%select{取得|引用}0 堆疊記憶體與 %select{局部變數|參數|複合字面量}2 %1 %select{返回|傳遞至 musttail 函數}3'
# '%select{alias|ifunc}0 definition is part of a cycle'
H75F8799A172C: '%select{別名|ifunc}0 定義是循環的一部分'
# '%select{alias|ifunc}0 must point to a defined %select{variable or |}1function'
HA8FBD807C04A: '%select{別名|ifunc}0 必須指向已定義的 %select{變數或 |}1 函數'
# "%select{alias|ifunc}1 will not be in section '%0' but in the same section as the %select{aliasee|resolver}2"
H14919DB80F8A: "%select{別名|ifunc}1 不會出現在區段 '%0'，而是與 %select{被引用物件|解析器}2 同區段"
# '%select{alias|ifunc}2 will always resolve to %0 even if weak definition of %1 is overridden'
H739E4FBA0F0D: '%select{別名|ifunc}2 始終會解析為 %0 即使 %1 的弱定義被覆寫'
# '%select{aligning a value|the result of checking whether a value is aligned}0 to 1 byte is %select{a no-op|always true}0'
H6A34843E702F: '%select{對齊值|檢查值是否對齊的結果}0 至 1 個位元組是 %select{無效操作|永遠為真}0'
# '%select{alignment of|offset of the aligned pointer from}0 the base pointee object (%1 %plural{1:byte|:bytes}1) is %select{less than|not a multiple of}0 the asserted %2 %plural{1:byte|:bytes}2'
H473934A0D013: '%select{對齊值|基底物件指標與基底物件的偏移量}0 (%1 %plural{1:位元組|:位元組}1) %select{小於|非倍數}0 斷言的 %2 %plural{1:位元組|:位元組}2'
# '%select{alignment|size}0 of field %1 (%2 bits) does not match the %select{alignment|size}0 of the first field in transparent union; transparent_union attribute ignored'
HF5A022BDF3DB: '%select{對齊值|大小}0 的成員 %1 (%2 位元) 與透明聯結體第一個成員的 %select{對齊值|大小}0 不一致；transparent_union 屬性被忽略'
# '%select{alignment|size}0 of first field is %1 bits'
H996CEE2D3252: '%select{對齊值|大小}0 的第一個成員是 %1 位元'
# '%select{all|second and third}0 arguments to %1 must be of scalar or vector type with matching scalar element type%diff{: $ vs $|}2,3'
HE09C48EB126A: '%select{所有|第二及第三}0 參數至 %1 必須為純量或向量類型，且具有相同純量元素類型 %diff{: $ vs $|}2,3'
# '%select{an attribute specifier sequence|%0}1 in this position is a C++23 extension'
H561F9F6DB91B: '%select{屬性指定序列|%0}1 在此位置是 C++23 的擴充功能'
# '%select{an attribute specifier sequence|%1}0 in this position is incompatible with C++ standards before C++23'
HEF130F97BB12: '%select{屬性指定序列|%1}0 在此位置與 C++23 之前的標準不符'
# '%select{and|because}0 %1 does not satisfy %2'
H1152B396A251: '%select{且|因為}0 %1 不符合 %2'
# '%select{and|because}0 %1 does not satisfy %2:'
H7FDA8323151A: '%select{且|因為}0 %1 不符合 %2:'
# "%select{and|because}0 '%1' (%2 %3 %4) evaluated to false"
H5A2EAB383E7A: "%select{且|因為}0 '%1' (%2 %3 %4) 評估為 false"
# "%select{and|because}0 '%1' evaluated to false"
HD9EC26C0E6B0: "%select{且|因為}0 '%1' 評估為 false"
# "%select{and|because}0 '%1' may throw an exception"
HA87D7335D9EB: "%select{且|因為}0 '%1' 可能擲出例外"
# "%select{and|because}0 '%1' would be invalid"
HAD3CC48247E5: "%select{且|因為}0 '%1' 會無效"
# "%select{and|because}0 '%1' would be invalid%2"
HEF46AC24BE27: "%select{且|因為}0 '%1' 會無效 %2"
# "%select{and|because}0 '%1' would be invalid: %2"
HD3831227C190: "%select{且|因為}0 '%1' 會無效: %2"
# "%select{and|because}0 type constraint '%1' was not satisfied:"
HD561B1DB876A: "%select{且|因為}0 類型限制 '%1' 未被滿足:"
# '%select{anonymous struct|union}0 member %1 has a non-trivial %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}2'
H443C398B6494: '%select{匿名結構體|共用體}0 成員 %1 有非平凡的 %select{預設建構函式|複製建構函式|移動建構函式|複製指派運算子|移動指派運算子|析構函式}2'
# '%select{anonymous struct|union}0 member %1 with a non-trivial %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}2 is incompatible with C++98'
HE6728E1CAD49: '%select{匿名結構體|共用體}0 成員 %1 具有非平凡的 %select{預設建構函式|複製建構函式|移動建構函式|複製指派運算子|移動指派運算子|析構函式}2 與 C++98 不相容'
# '%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 %select{floating-point|enumeration}1 type %2 %plural{2:with|4:from|:and}0 %select{enumeration|floating-point}1 type %3'
H510A2D2A82E0: '%select{之間的算術運算|之間的位元運算|比較|條件運算式之間|複合指派}0 %select{浮點|枚舉}1 類型 %2 %plural{2:與|4:從|:和}0 %select{枚舉|浮點}1 類型 %3'
# '%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 %select{floating-point|enumeration}1 type %2 %plural{2:with|4:from|:and}0 %select{enumeration|floating-point}1 type %3 is deprecated'
H08C01E0FFD79: '%select{%.2 型與 %.3 型之間的%.0 算術運算|%.2 型與 %.3 型之間的%.0 位元運算|%.2 型與 %.3 型之間的%.0 比較|%.2 型與 %.3 型之間的%.0 條件運算式|%.2 型與 %.3 型之間的%.0 複合指派運算}0 %select{浮點數|列舉}1 型 %2 %plural{2:的|4:的|:和}0 %select{列舉|浮點數}1 型 %3 窄化轉換已廢除'
# '%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2'
H15481858FE39: '%select{之間的算術運算|之間的位元運算|比較|條件運算式之間|複合指派}0 不同枚舉類型%diff{ ($和$)|}1,2'
# '%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2 is deprecated'
HB2E74DC62C72: '%select{之間的算術運算|之間的位元運算|比較|條件運算式之間|複合指派}0 不同枚舉類型%diff{ ($和$)|}1,2 已棄用'
# '%select{assignment to readonly property|no setter method %1 for assignment to property}0'
H7FB56A6FE5D6: '%select{將值賦予唯讀屬性|無設定器方法 %1 對屬性賦值}0'
# '%select{base class|inherited virtual base class}0 %1 has %select{private|protected}3 %select{default |copy |move |*ERROR* |*ERROR* |*ERROR*|}2constructor'
H3EE5604475F7: '%select{基底類別|繼承的虛基類}0 %1 具有 %select{私有|受保護}3 %select{預設 |複製 |移動 |*ERROR* |*ERROR* |*ERROR*|}2 建構函式'
# '%select{bit-field %1|anonymous bit-field}0 is too wide (%2 bits)'
H4CB82469419C: '%select{位段 %1|匿名位段}0 過寬 (%2 位元)'
# "%select{block pointer|pointer|reference}0 to function type %select{%2 |}1cannot have '%3' qualifier"
H0BABB964A63A: "%select{函數指標|函數區塊指標|C 函數指標}0 類型 %select{%2 |}1 不能具有 '%3' 限定符"
# '%select{call to non-static member function|use of non-static data member}0 %2 of %1 from nested type %3'
H4DA493B4F5FF: '%select{調用非靜態成員函數|使用非靜態資料成員}0 %2 的 %1 來自嵌套類型 %3'
# '%select{cannot assign to return value because function %1 returns a const value|cannot assign to variable %1 with const-qualified type %2|cannot assign to %select{non-|}1static data member %2 with const-qualified type %3|cannot assign to non-static data member within const member function %1|cannot assign to %select{variable %2|non-static data member %2|lvalue}1 with %select{|nested }3const-qualified data member %4|read-only variable is not assignable}0'
H957C121C1C4E: '%select{無法對返回值進行賦值，因為函數 %1 返回了 const 值|無法對 const 限定類型 %2 的變數 %1 進行賦值|無法對 %select{非-|}1 靜態資料成員 %2 具有 const 限定類型 %3 進行賦值|無法在 const 成員函數 %1 內對非靜態資料成員進行賦值|無法對 %select{變數 %2|非靜態資料成員 %2|左值}1 具有 %select{|嵌套 }3const 限定資料成員 %4 進行賦值|唯讀變數無法進行賦值}0'
# "%select{case value|enumerator value|non-type template argument|non-type parameter of template template parameter|array size|explicit specifier argument|noexcept specifier argument|call to 'size()'|call to 'data()'}0 %select{cannot be narrowed from type %2 to %3|evaluates to %2, which cannot be narrowed to type %3}1"
HECF4733C9DA0: "%select{case值|枚舉值|非類型模板參數|匿名聯結體成員|陣列大小|顯式指定參數|noexcept指定參數|調用 'size()'|調用 'data()'}0 %select{不能從類型 %2 窄化為 %3|評估為 %2，這不能窄化為類型 %3}1"
# "%select{case value|enumerator value|non-type template argument|non-type parameter of template template parameter|array size|explicit specifier argument|noexcept specifier argument|call to 'size()'|call to 'data()'}0 is not a constant expression"
HFB41B693F137: "%select{case 值|枚舉值|非類型模板參數|非類型參數的模板模板參數|陣列大小|顯示指定參數|noexcept 指定參數|調用 'size()'|調用 'data()'}0 不是常量表達式"
# '%select{cast|implicit conversion}0 of %select{Objective-C|block|C}1 pointer type %2 to %select{Objective-C|block|C}3 pointer type %4 requires a bridged cast'
H312933E2115D: '%select{轉換|隱式轉換}0 %select{Objective-C|區塊|C}1 指標類型 %2 至 %select{Objective-C|區塊|C}3 指標類型 %4 需要橋接轉換'
# '%select{category %1|class extension}0 cannot conform to protocol %2 because of direct members declared in interface %3'
H86E18740A145: '%select{類別 %1|類別擴充}0 無法符合協議 %2，因為接口 %3 中聲明了直接成員'
# '%select{category|class extension}0 conforms to protocol %1 which defines method %2'
H1219B6B58D30: '%select{類別擴充|類別分類}0 符合協議 %1，其定義了方法 %2'
# '%select{character|integer}0 literal with user-defined suffix cannot be used in preprocessor constant expression'
HF3B4B5DEEBAB: '%select{具用戶定義後綴的 Objective-C|具用戶定義後綴的 C}1 字面量不能用於預處理常量表達式'
# '%select{class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration}0 specialization of %1 must occur at global scope'
HB1B7C78CE71E: '%select{類別模板|類別模板部分|變數模板|變數模板部分|函數模板|成員函數|靜態資料成員|成員類別|成員列舉}0 特化 %1 必須在全局作用域中出現'
# '%select{class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration}0 specialization of %1 not in %select{a namespace enclosing %2|class %2 or an enclosing namespace}3'
HFB74AB926D65: '%select{類別模板|類別模板部分|變數模板|變數模板部分|函數模板|成員函數|靜態資料成員|成員類別|成員列舉}0 特化 %1 不在 %select{包圍 %2 的命名空間|類別 %2 或包圍的命名空間}3 中'
# '%select{class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration}0 specialization of %1 not in %select{a namespace enclosing %2|class %2 or an enclosing namespace}3 is a Microsoft extension'
H61AEC4FCDF68: '%select{類別模板|類別模板部分|變數模板|變數模板部分|函數模板|成員函數|靜態資料成員|成員類別|成員列舉}0 特化 %1 不在 %select{包圍 %2 的命名空間|類別 %2 或包圍的命名空間}3 中是 Microsoft 延伸語法'
# '%select{class|instance}0 method %1 also declared here'
H40D03C99413F: '%select{類別|實例}0 方法 %1 也在此處宣告'
# '%select{class|instance}0 method %1 has a different number of parameters in different translation units (%2 vs. %3)'
H1C2BED5A5D12: '%select{類別|實例}0 方法 %1 在不同翻譯單位中具有不同參數數量 (%2 vs. %3)'
# '%select{class|instance}0 method %1 has a parameter with a different types in different translation units (%2 vs. %3)'
H27FF7F628706: '%select{類別|實例}0 方法 %1 在不同翻譯單位中具有不同類型的參數 (%2 vs. %3)'
# '%select{class|instance}0 method %1 has incompatible result types in different translation units (%2 vs. %3)'
H81568F1228D2: '%select{類別|實例}0 方法 %1 在不同翻譯單位中具有不相容的返回類型 (%2 vs. %3)'
# '%select{class|instance}0 method %1 is assumed to return an instance of its receiver type (%2)'
H57512855C27C: '%select{類別|實例}0 方法 %1 假定返回接收類型的實例 (%2)'
# '%select{class|instance}0 method %1 is variadic in one translation unit and not variadic in another'
HF51A27778394: '%select{類別|實例}0 方法 %1 在某個翻譯單位中是可變參數，而在另一個則否'
# '%select{class|protocol|category|class extension|implementation|category implementation}0 started here'
HB972B56B97CE: '%select{類別|協定|分類|類別擴展|實作|分類實作}0 開始於此處'
# '%select{class|struct|interface|union|enum|enum class|enum struct}0 cannot be marked %select{<ERROR>|constexpr|consteval|constinit}1'
H6CC4F10FF6EF: '%select{類別|結構|介面|共用體|列舉|enum class|enum struct}0 不能標記為 %select{<ERROR>|constexpr|consteval|constinit}1'
# '%select{class|type alias}0 template declared here'
HC92E96CB1535: '%select{類別|類型別名}0 模板在此處宣告'
# '%select{class|variable}0 template partial specialization contains %select{a template parameter|template parameters}1 that cannot be deduced; this partial specialization will never be used'
H8F8D0B49DE65: '%select{類別|變數}0 模板的部分專門化包含 %select{無法推論的模板參數|無法推論的模板參數}1；此部分專門化永遠不會被使用'
# '%select{class|variable}0 template partial specialization does not specialize any template argument; to %select{declare|define}1 the primary template, remove the template argument list'
HC805ED783ADF: '%select{類別|變數}0 模板的部分專門化未指定任何模板參數；要 %select{宣告|定義}1 原始模板，請移除模板參數列表'
# '%select{class|variable}0 template partial specialization is not more specialized than the primary template'
HD6682742D913: '%select{類別|變數}0 模板的部分專門化並未比原始模板更專門化'
# '%select{codeseg|section}0 does not match previous declaration'
H9AFE01E1A06A: '%select{codeseg|section}0 與先前宣告不符'
# "%select{command line contains|AST file '%1' was built with}0 '-detailed-preprocessing-record' but %select{AST file '%1' was not built with it|it is not present on the command line}0"
H668E0E039D43: "%select{命令列包含|AST 檔案 '%1' 以}0 '-detailed-preprocessing-record' 編譯，但 %select{AST 檔案 '%1' 未以該選項編譯|命令列未指定該選項}0"
# "%select{command line contains|AST file '%1' was built with}0 '-undef' but %select{AST file '%1' was not built with it|it is not present on the command line}0"
H8E60AF265E55: "%select{命令列包含|AST 檔案 '%1' 以}0 '-undef' 編譯，但 %select{AST 檔案 '%1' 未以該選項編譯|命令列未指定該選項}0"
# '%select{comparison between %diff{ ($ and $)|}0,1|arithmetic operation with operands of type %diff{ ($ and $)|}0,1|conditional operator with the second and third operands of type %diff{ ($ and $)|}0,1}2 which are pointers to non-overlapping address spaces'
H47A4B5F7D5D9: '%select{具有類型 %diff{ ($ 和 $)|}0,1 的指標運算|具有類型 %diff{ ($ 和 $)|}0,1 的運算元操作|條件運算元具有第二和第三操作元類型 %diff{ ($ 和 $)|}0,1}2 這些指標指向非重疊地址空間'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 from %1 to %2 converts between mismatching address spaces'
HB50BD1C6F363: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 從 %1 到 %2 轉換地址空間不匹配'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 from %1 to %2 is not allowed'
H0994EC770949: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 從 %1 到 %2 不被允許'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 from rvalue to reference type %2'
H79F10447DC2A: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 從右值轉換為引用類型 %2'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2 casts away qualifiers'
H56EB9B5EABD1: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 從 %1 到 %2 移除了限定符'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2, which are not related by inheritance, is not allowed'
HC3DB71EF3442: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 從 %1 到 %2 不具繼承關係，不被允許'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from bit-field lvalue to reference type %2'
H1DAD5B4DA5AC: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|函數式cast|}0 將位段左值轉換為引用類型 %2'
# '%select{const_cast||||C-style cast|functional-style cast|}0 to %2, which is not a reference, pointer-to-object, or pointer-to-data-member'
H2773305E9004: '%select{const_cast||||C-style cast|functional-style cast|}0 從位段左值轉換為引用類型 %2'
# "%select{constexpr|consteval}0 function's return type %1 is not a literal type"
H8C05F94E8F5F: '%select{constexpr|consteval}0 函數的傳回類型 %1 不是字面類型'
# '%select{constexpr|consteval}1 %select{function|constructor}0 never produces a constant expression'
H022CBA14DE42: '%select{constexpr|consteval}1 %select{函數|建構函式}0 永不產生常量運算式'
# "%select{constexpr|consteval}2 %select{function|constructor}1's %ordinal0 parameter type %3 is not a literal type"
H6B5DAAD976BB: '%select{constexpr|consteval}2 %select{函數|建構函式}1 的第 %ordinal0 個參數類型 %3 非字面類型'
# '%select{constructor for %1 must explicitly initialize the|implicit default constructor for %1 must explicitly initialize the|cannot use constructor inherited from base class %4;}0 %select{base class|member}2 %3 %select{which|which|of %1}0 does not have a default constructor'
HE93B407A4DE4: '%select{類別 %1 的建構函式必須明確初始化|隱式預設建構函式對 %1 必須明確初始化|無法使用從基底類別 %4 繼承的建構函式；}0 %select{基底類別|成員}2 %3 %select{未|未|的 %1}0 具有預設建構函式'
# '%select{constructor for %1|implicit default constructor for %1|cannot use constructor inherited from %1:}0 must explicitly initialize the %select{reference|const}2 member %3'
H5DD624CAFF41: '%select{類別 %1 的建構函式|隱式預設建構函式對 %1|無法使用從 %1 繼承的建構函式：}0 必須明確初始化 %select{引用|const}2 成員 %3'
# '%select{constructor|destructor}1 %0 must not return void expression'
H76E14738E327: '%select{建構函式|析構函式}1 %0 不得返回 void 表達式'
# '%select{const|reference}0 member %1 will never be initialized'
H67E2118A2E7C: '%select{const|引用}0 成員 %1 將永遠不會被初始化'
# '%select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1 invokes deleted constructor'
HE9CE7E623BF3: '%select{複製變數|複製參數|初始化模板參數|傳回物件|初始化語句運算式結果|拋出物件|複製成員子物件|複製陣列元素|分配物件|複製暫存物件|初始化基底子物件|初始化向量元素|捕獲值}0 的類型 %1 會呼叫已刪除的建構函式'
# '%select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}1 of type %2 when binding a reference to a temporary would %select{invoke an inaccessible constructor|find no viable constructor|find ambiguous constructors|invoke a deleted constructor}0 in C++98'
H29AE4DB3DE15: '%select{複製變數|複製參數|初始化模板參數|傳回物件|初始化語句運算式結果|拋出物件|複製成員子物件|複製陣列元素|分配物件|複製暫存物件|初始化基底子物件|初始化向量元素|捕獲值}1 的類型 %2 在 C++98 綁定臨時物件引用時會 %select{呼叫無法存取的建構函式|找不到可行的建構函式|找到多個歧義建構函式|呼叫已刪除的建構函式}0'
# '%select{copy|move}0 assignment operator of %1 is implicitly deleted because field %2 is of %select{reference|const-qualified}4 type %3'
HA5E40C813D22: '%select{複製|移動}0 賦值運算子對 %1 被隱式標記為已刪除，因為成員 %2 的類型 %3 是 %select{引用|const-限定}4 類型'
# '%select{data member %1|base class %2}0 declared here'
HC9ED4A45B57E: '%select{成員 %1|基底類別 %2}0 這裡宣告'
# '%select{data member |non-public member function |static member function |user-declared constructor|user-declared destructor|operator |nested class }0%1 is not permitted within an interface type'
H9EC34E188C56: '%select{資料成員 |非公開成員函數 |靜態成員函數 |使用者宣告的建構函數|使用者宣告的析構函數|operator |嵌套類別 }0%1 不允許出現在介面類型中'
# '%select{declaration|definition|default argument declared|explicit specialization declared|partial specialization declared}0 here is not %select{visible|reachable|reachable|reachable|reachable|reachable}0'
H804351062C9E: '%select{宣告|定義|預設參數宣告|明確專案宣告|部分專案宣告}0 這裡未 %select{可見|可達|可達|可達|可達|可達}0'
# "%select{declaration|definition|default argument|explicit specialization|partial specialization}0 of %1 must be imported from module '%2' before it is required"
HC491502A3888: "%select{宣告|定義|預設參數|明確專案|部分專案}0 的 %1 必須從模組 '%2' 引入後才可使用"
# '%select{declaration|definition|default argument|explicit specialization|partial specialization}0 of %1 must be imported from one of the following modules before it is required:%2'
HA8E1DF60359B: '%select{宣告|定義|預設參數|明確專案|部分專案}0 的 %1 必須從以下模組之一引入後才可使用：%2'
# '%select{declaration|definition}0 of %select{struct|interface|union|class|enum}1 in a dependent scope'
H690477FDDE60: '%select{宣告|定義}0 的 %select{struct|interface|union|class|enum}1 在依賴作用域中'
# '%select{decremented|incremented}0 here'
HD8461A402F1F: '%select{遞減|遞增}0 此處'
# '%select{decrement|increment}0 of object of volatile-qualified type %1 is deprecated'
H57C759966E48: '%select{遞減|遞增}0 %1 型態的volatile修飾物件是已棄用的'
# '%select{default construction|assignment}0 of lambda is incompatible with C++ standards before C++20'
H3C92D92BB26F: '%select{預設建構|指派}0 lambda與C++20之前的C++標準不相容'
# '%select{default constructor of|constructor inherited by}0 %1 is implicitly deleted because all %select{data members|data members of an anonymous union member}2 are const-qualified'
HF80E1E94C448: '%select{物件的預設建構函數|由物件繼承的建構函數}0 %1 被隱式刪除，因為所有%select{資料成員|匿名聯集成員的資料成員}2 均為const限定'
# '%select{default constructor of|constructor inherited by}0 %1 is implicitly deleted because field %2 of %select{reference|const-qualified}4 type %3 would not be initialized'
H3F45472DFCD6: '%select{具有|由...繼承的}0 %1 類別的預設建構函式被隱式刪除，因為其成員 %2 的 %select{引用|const限定}4 類型 %3 未被初始化'
# '%select{default constructor of|copy constructor of|move constructor of|copy assignment operator of|move assignment operator of|destructor of|constructor inherited by}0 %1 is implicitly deleted because %select{base class %3|%select{||||variant }4field %3}2 %select{has %select{no|a deleted|multiple|an inaccessible|a non-trivial}4 %select{%select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|%select{default|corresponding|default|default|default}4 constructor}0|destructor}5%select{||s||}4|is an ObjC pointer}6'
H1BB10C6BA0EA: '%select{物件的預設建構函數|物件的複製建構函數|物件的移動建構函數|物件的複製賦值運算子|物件的移動賦值運算子|物件的解構函數|物件的繼承建構函數}0 %1 被隱式刪除，因為%select{基類 %3|%select{||||variant }4成員 %3}2 %select{有%select{無|被刪除|多個|無法存取|非平凡}4 %select{%select{預設建構函數|複製建構函數|移動建構函數|複製賦值運算子|移動賦值運算子|解構函數|%select{預設|對應|預設|預設|預設}4 建構函數}0|解構函數}5%select{||s||}4|是ObjC指標}6'
# "%select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot be 'constexpr' in a class with virtual base class"
HAA0AD1F4C5AC: "%select{預設建構函數|複製建構函數|移動建構函數|複製指派運算子|移動指派運算子|析構函數}0 在具有虛基類的類別中不能是 'constexpr'"
# '%select{defaulted|deleted}0 function definitions are a C++11 extension'
H2588FE2C83FF: '%select{預設|刪除}0 函數定義是C++11擴展'
# '%select{defaulted|deleted}0 function definitions are incompatible with C++98'
HE7CB963644EA: '%select{預設|刪除}0 函數定義與C++98不相容'
# "%select{definition|#undef}0 of configuration macro '%1' has no effect on the import of '%2'; pass '%select{-D%1=...|-U%1}0' on the command line to configure the module"
H20DEB068BA86: "%select{定義|#undef}0 配置巨集 '%1' 對 '%2' 的匯入無效；使用 '%select{-D%1=...|-U%1}0' 指令列參數進行配置"
# '%select{delete|destructor}0 called on %1 that is abstract but has non-virtual destructor'
HD3B2B405330A: '%select{delete|析構函數}0 被呼叫於具有虛基類但非虛析構函數的abstract類別 %1'
# '%select{delete|destructor}0 called on non-final %1 that has virtual functions but non-virtual destructor'
HD186820BFF8C: '%select{delete|析構函數}0 被呼叫於非final的 %1，該類別具有虛函數但無虛析構函數'
# '%select{delimited|named}0 escape sequences are a %select{C++23|C2y|Clang}1 extension'
HDBE05BE4D14B: '%select{限定|命名}0 轉義序列是 %select{C++23|C2y|Clang}1 擴展'
# '%select{delimited|named}0 escape sequences are incompatible with C++ standards before C++23'
HFB62920439FF: '%select{限定|命名}0 轉義序列與C++23之前的標準不相容'
# '%select{destination for|source of|first operand of|second operand of}0 this %1 call is a pointer to %select{|class containing a }2dynamic class %3; vtable pointer will be %select{overwritten|copied|moved|compared}4'
H63A8D05F544B: '%select{此調用的目標是|此調用的來源是|此調用的第一個操作數是|此調用的第二個操作數是}0 %1 的指標指向 %select{|包含動態類別的類別}2 動態類別 %3；虛函數表指標將會被 %select{覆寫|複製|移動|比較}4'
# '%select{destination for|source of|first operand of|second operand of}0 this %1 call is a pointer to record %2 that is not trivial to %select{primitive-default-initialize|primitive-copy}3'
HB6A0DAA8C1C8: '%select{此調用的目標是|此調用的來源是|此調用的第一個操作數是|此調用的第二個操作數是}0 %1 的指標指向未對 %select{原始默認初始化|原始複製}3 成為 trivial 的紀錄 %2'
# '%select{destination for|source of}0 this %1 call is a pointer to ownership-qualified type %2'
HEE4DB03498AC: '%select{此調用的目標是|此調用的來源是}0 %1 的指標指向具有所有權限定符的類型 %2'
# '%select{destructor|deallocator}0 has a %select{non-throwing|implicit non-throwing}1 exception specification'
H78E56ACB6245: '%select{析構函數|deallocators}0 具有%select{不拋出例外|隱式不拋出例外}1例外規格'
# '%select{dictionary|array}1 subscript base type %0 is not an Objective-C object'
HE2828D54BB1B: '%select{字典|陣列}1 索引運算基底類型 %0 非Objective-C物件'
# '%select{equality|inequality|relational|three-way}0 comparison result unused'
H69C6598EFBD9: '%select{等同|不等|關係|三向}0 比較結果未被使用'
# '%select{expected an expression statement|expected built-in assignment operator|expected expression of scalar type|expected lvalue expression}0'
H7F94DE3BA105: '%select{期望表達式陳述式|期望內建賦值運算子|期望純量類型的表達式|期望左值表達式}0'
# "%select{expected an expression statement|expected built-in binary or unary operator|expected unary decrement/increment operation|expected expression of scalar type|expected assignment expression|expected built-in binary operator|expected one of '+', '*', '-', '/', '&', '^', '%|', '<<', or '>>' built-in operations|expected in right hand side of expression}0"
H13014A5049BE: "%select{期望表達式陳述式|期望內建一元或二元運算子|期望一元遞增/遞減運算|期望純量類型的表達式|期望賦值表達式|期望內建二元運算子|期望 '+'、'*'、'-'、'/'、'&'、'^'、'%'、'|'、'<<' 或 '>>' 運算|期望右邊的表達式}0"
# '%select{expected assignment expression|expected compound statement|expected exactly two expression statements|expected in right hand side of the first expression}0'
H71EE048AAB44: '%select{期望賦值表達式|期望複合陳述式|期望兩個表達式陳述式|期望第一個表達式的右邊}0'
# "%select{expected compound statement|expected exactly one expression statement|expected assignment statement|expected conditional operator|expect result value to be at false expression|expect binary operator in conditional expression|expect '<', '>' or '==' as order operator|expect comparison in a form of 'x == e', 'e == x', 'x ordop expr', or 'expr ordop x'|expect lvalue for result value|expect scalar value|expect integer value|unexpected 'else' statement|expect '==' operator|expect an assignment statement 'v = x'|expect a 'if' statement|expect no more than two statements|expect a compound statement|expect 'else' statement|expect a form 'r = x == e; if (r) ...'}0"
H2BEDF1CDD9ED: "%select{期望複合陳述式|期望單一表達式陳述式|期望賦值陳述式|期望條件運算子|期望false表達式有結果值|期望條件運算子中的二元運算|期望 '<'、'>' 或 '==' 為比較運算|期望 'x == e'、'e == x'、'x 順序運算子 表達式'或'表達式 順序運算子 x'的比較形式|期望結果值為左值|期望純量值|期望整數值|不期望else陳述式|期望 '==' 運算子|期望 'v = x' 的賦值陳述式|期望if陳述式|期望不超過兩個陳述式|期望複合陳述式|期望else陳述式|期望形式 'r = x == e; if (r) ...'}0"
# '%select{explicit|friend}0 specialization cannot have a trailing requires clause unless it declares a function template'
H4B8C1F1CA2BB: '%select{明確|友元}0 專屬化除非宣告函數模板，否則不可具有尾隨requires子句'
# '%select{expression|base type|declaration type|data member type|bit-field size|static assertion|fixed underlying type|enumerator value|using declaration|friend declaration|qualifier|initializer|default argument|non-type template parameter type|exception type|explicit specialization|partial specialization|__if_exists name|__if_not_exists name|lambda|block|type constraint|requirement|requires clause}0 contains%plural{0: an|:}1 unexpanded parameter pack%plural{0:|1: %2|2:s %2 and %3|:s %2, %3, ...}1'
HE9A8E0B2E8F5: '%select{表達式|基礎類型|宣告類型|資料成員類型|位段大小|static assertion|固定基礎類型|枚舉值|using 宣告|friend 宣告|限定詞|初始值設定|預設參數值|非類型模板參數類型|例外類型|明確特化|部分特化|__if_exists 名稱|__if_not_exists 名稱|lambda|block|類型約束|需求|requires 子句}0 包含 %plural{0: 一個|:}1 未展開的參數包 %plural{0:|1: %2|2:s %2 和 %3|:s %2, %3, ...}1'
# '%select{extension|category}0 of non-parameterized class %1 cannot have type parameters'
H6F4F8CBFDF9B: '%select{擴充類別|類別分類}0 的非參數化類別 %1 不能具有模板參數'
# '%select{fewer|more}0 specifiers in format string than expected'
H294968301C0D: '%select{比期望的少|比期望的多}0 個格式字串指定符'
# "%select{field width|precision}0 used with '%1' conversion specifier, resulting in undefined behavior"
H2CF9930D6217: "%select{欄位寬度|精確度}0 用於 '%1' 轉換修飾詞，導致未定義行為"
# '%select{field|base class}0 %1 will be initialized after %select{field|base}2 %3'
HE92BDD84B944: '%select{成員|基底類別}0 %1 將在 %select{成員|基底}2 %3 初始化後被初始化'
# '%select{first two|all}1 arguments to %0 must be vectors'
HF5292D19FFBC: '%select{前兩個|所有}1 個參數至 %0 必須為向量'
# '%select{first two|all}1 arguments to %0 must have the same type'
H648C1151AF74: '%select{前兩個|所有}1 個參數至 %0 必須具有相同類型'
# "%select{first|second|third|fourth}0 parameter of 'main' (%select{argument count|argument array|environment|platform-specific data}0) must be of type %1"
HF5B9D5CD8E73: "%select{第一個|第二個|環境|平台特定資料}0 個 'main' 參數 (%select{參數計數|參數陣列|環境|平台特定資料}0) 必須為 %1 類型"
# '%select{first|second|third}0 parameter has unexpected type %1 (should be %2)'
HB94305DC6AD8: '%select{第一個|第二個|第三個}0 個參數具有不正確的類型 %1（應為 %2）'
# '%select{first|second}0 operand was implicitly converted to type %1'
HBF77ADC8F095: '%select{第一|第二}0 運算元隱式轉換為類型 %1'
# '%select{forward class declaration|class definition|category|extension}0 has too %select{few|many}1 type parameters (expected %2, have %3)'
HF027D432E158: '%select{類別前向宣告|類別定義|分類|擴充}0 的類型參數數目 %select{過少|過多}1（期望 %2，目前 %3）'
# '%select{function %1 which returns const-qualified type %2 declared here|variable %1 declared const here|%select{non-|}1static data member %2 declared const here|member function %q1 is declared const here|%select{|nested }1data member %2 declared const here}0'
HA9209A7005BD: '%select{返回const限定類型 %2 的函數 %1 宣告在此處|在此處宣告的const變數 %1|%select{非-|}1 靜態資料成員 %2 在此處宣告為const|此成員函數%q1在此處宣告為const|%select{|巢狀 }1資料成員 %2 在此處宣告為const}0'
# '%select{function parameter|typedef}0 cannot be %select{<ERROR>|constexpr|consteval|constinit}1'
H86C3A8B0C257: '%select{函數參數|typedef宣告}0 無法是 %select{<ERROR>|constexpr|consteval|constinit}1'
# '%select{function template|class template|variable template|type alias template|template template parameter}0 %1 declared here'
H91E08CCD64B6: '%select{範型函數|範型類別|範型變數|型別別名範型|範型型別參數}0 %1 宣告在此處'
# '%select{function with deduced return type|declaration with trailing return type}0 must be the only declaration in its group'
HA1CB6C2DD073: '%select{具有推論傳回型別的函數|具有尾端傳回型別的宣告}0 必須是其群組中唯一的宣告'
# "%select{function|block|lambda|coroutine}0 declared 'noreturn' should not return"
HBB674CBF2E79: '%select{函數|區塊|lambda|coroutine}0 被宣告為noreturn，不應返回值'
# "%select{function|class|variable}0 cannot be defined in an explicit instantiation; if this declaration is meant to be a %select{function|class|variable}0 definition, remove the 'template' keyword"
HF2F19E25243A: "%select{函數|類別|變數}0 不能在顯式實體化中定義；若此宣告是%select{函數|類別|變數}0 的定義，請移除 'template' 關鍵字"
# "%select{function|constructor|destructor|lambda|block|member initializer of constructor}0 with '%1' attribute must not %select{allocate or deallocate memory|throw or catch exceptions|have static local variables|use thread-local variables|access ObjC methods or properties}2"
H8DE43E9D40B0: "%select{函數|建構函數|析構函數|lambda|block|建構函數的成員初始值設定}0 具有 '%1' 屬性不得 %select{分配或釋放記憶體|擲出或捕捉例外|具有靜態局部變數|使用執行緒局部變數|存取_ObjC 方法或屬性}2"
# "%select{function|constructor|destructor|lambda|block|member initializer of constructor}0 with '%1' attribute must not call non-'%1' %select{function|constructor|destructor|lambda|block}2 '%3'"
HD57CFC80D164: "%select{函數|建構函數|析構函數|lambda|block|建構函數的成員初始值設定}0 具有 '%1' 屬性不得呼叫非 '%1' %select{函數|建構函數|析構函數|lambda|block}2 '%3'"
# "%select{function|constructor|destructor|lambda|block|member initializer of constructor}0 with '%1' attribute must not call non-'%1' expression"
H5BD0868978EA: "%select{函數|建構函數|析構函數|lambda|block|建構函數的成員初始值設定}0 具有 '%1' 屬性不得呼叫非 '%1' 表達式"
# "%select{function|constructor|destructor|lambda|block|member initializer}0 cannot be inferred '%1' because it %select{allocates or deallocates memory|throws or catches exceptions|has a static local variable|uses a thread-local variable|accesses an ObjC method or property}2"
H2867CEC6E928: "%select{函數|建構函數|析構函數|lambda|block|成員初始值設定}0 無法推論 '%1' 屬性因它 %select{分配或釋放記憶體|擲出或捕捉例外|具有靜態局部變數|使用執行緒局部變數|存取_ObjC 方法或屬性}2"
# "%select{function|constructor|destructor|lambda|block|member initializer}0 cannot be inferred '%1' because it calls non-'%1' %select{function|constructor|destructor|lambda|block}2 '%3'"
H314F30794920: "%select{函數|建構函數|析構函數|lambda|block|成員初始值設定}0 無法推論 '%1' 屬性因它呼叫非 '%1' %select{函數|建構函數|析構函數|lambda|block}2 '%3'"
# "%select{function|constructor|destructor|lambda|block}0 does not permit inference of '%1' because it is declared '%2'"
HB9A03E541F67: "%select{函數|建構函數|析構函數|lambda|block}0 因被宣告為 '%2' 而無法推論 '%1' 屬性"
# "%select{function|constructor|destructor|lambda|block}0 with '%1' attribute should be declared noexcept"
HB030E37D6AD6: "%select{函數|建構函數|析構函數|lambda|block}0 具有 '%1' 屬性時應宣告為 noexcept"
# "%select{function|kernel}0 cannot be called 'main'"
H12368C59A019: "%select{函數|核心}0 不可命名為 'main'"
# '%select{function|method|block}0 has been explicitly marked sentinel here'
H02C89F36F346: '%select{函數|方法|block}0 已在此處明確標記為 sentinel'
# "%select{function|method}0 %1 could be declared with attribute 'noreturn'"
H2A06C5AB5A01: "%select{函數|方法}0 %1 可宣告具有 'noreturn' 屬性"
# "%select{function|parameter}0 declared '[[carries_dependency]]' after its first declaration"
HA7BEBD006826: "%select{函數|參數}0 被宣告具有 '[[carries_dependency]]' 屬性，但此屬性應在首次宣告時指定"
# '%select{function|variable}0 %1 is not needed and will not be emitted'
HF8ADE574A433: '%select{函數|變數}0 %1 未被使用且將不會被產生'
# '%select{function|variable}0 %q1 has internal linkage but is not defined'
H45C099CD2E21: '%select{函數|變數}0 %q1 具有內部連結性但未被定義'
# '%select{function|variable}0 %q1 is used but not defined in this translation unit, and cannot be defined in any other translation unit because its type does not have linkage'
H4CCCEB729733: '%select{函數|變數}0 %q1 在此翻譯單位中未被定義，且無法在其他翻譯單位中定義，因其類型無連結性'
# '%select{global|private}0 module fragment cannot be exported'
H32D31F303DCC: '%select{全域|私有}0 模組片段無法被匯出'
# '%select{hex|octal}0 escape sequence out of range'
HD900722CD654: '%select{十六進位|八進位}0 逃逸序列超出範圍'
# '%select{if|switch}0 initialization statements are incompatible with C++ standards before C++17'
H48F2A35749E7: '%select{if|switch}0 初始化語句與C++17之前的標準不相容'
# '%select{implicit conversion|cast}0 of %select{%2|a non-Objective-C pointer type %2|a block pointer|an Objective-C pointer|an indirect pointer to an Objective-C pointer}1 to %3 is disallowed with ARC'
H2BE56E173B04: '%select{隱式轉換|型別轉換}0 將 %select{%2|非Objective-C指標類型 %2|block指標|Objective-C指標|間接指向Objective-C指標的指標}1 轉換為 %3 在ARC中被禁止'
# '%select{implicit conversion|cast}0 of weak-unavailable object of type %1 to a __weak object of type %2'
H5E0A61E4DC2C: '%select{隱式轉換|型別轉換}0 將無法存取的弱引用物件 %1 轉換為__weak物件 %2'
# '%select{implicitly |}2captured%select{| by reference}3%select{%select{ due to use|}2 here| via initialization of lambda capture %0}1'
H0BA3D7D599E5: '%select{隱式|}2 捕獲 %select{|通過引用}3%select{%select{ 由於此處的使用|}2 |通過lambda捕獲 %0 的初始化}1'
# '%select{implicit|explicit}0 instantiation first required here'
HB12903FE55DA: '%select{隱式|明確}0 實體化首次在此需要'
# '%select{implicit|explicit}0 instantiation of template %1 within its own definition'
H0FEA9F8C421A: '%select{隱式|明確}0 實體化模板 %1 時在其自身定義中使用'
# '%select{implicit|explicit}0 instantiation of undefined template %1'
H04E01542E9F2: '%select{隱式|明確}0 實體化未定義的模板 %1'
# "%select{incompatible|duplicate}0 directives '%1' and '%2'"
HEFD5CC9864D7: "'%1' 和 '%2' %select{不相容|重複}0 指令"
# '%select{instance variable|property}2 with %0 attribute must be an object type (invalid %1)'
HFD8E12A874BC: '具有 %0 屬性的%select{實體變數|屬性}2 必須是物件類型（無效的 %1）'
# '%select{instance|class}1 method %0 not found ; did you mean %2?'
H113C6B0985AF: '%select{實例|類}1 方法 %0 未找到；是否指 %2？'
# '%select{integer|integral}1 constant expression must have %select{integer|integral or unscoped enumeration}1 type, not %0'
H07847569345A: '%select{整數|整數或無作用域列舉}1 常數運算式必須具有 %select{整數|整數或無作用域列舉}1 類型，而非 %0'
# "%select{interrupt service routine|function with attribute 'no_caller_saved_registers'}0 should only call a function with attribute 'no_caller_saved_registers' or be compiled with '-mgeneral-regs-only'"
HE2C243372C8E: "%select{中斷服務常式|具有 'no_caller_saved_registers' 屬性的函數}0 應僅呼叫具有 'no_caller_saved_registers' 屬性的函數，或使用 '-mgeneral-regs-only' 編譯"
# "%select{invalid use of|unknown}2 attribute subject matcher sub-rule '%0'; '%1' matcher %select{does not support sub-rules|supports the following sub-rules: %3}2"
H8BFF482F0D6A: "%select{無效的|%s}2 屬性主體匹配規則子規則 '%0'；'%1' 匹配器 %select{不支援子規則|支援以下子規則：%3}2"
# "%select{invalid value '%0'; must be positive|value '%0' is too large}1"
HEC3DA4A69943: "%select{無效值 '%0'；必須為正數|值 '%0' 過大}1"
# "%select{invalid|missing}0 option%select{ %1|}0; expected 'contract', 'reassociate', 'reciprocal', or 'exceptions'"
H280D64C6E2E8: "%select{無效|缺少}0 選項%select{ %1|}0; %expect 'contract', 'reassociate', 'reciprocal', 或 'exceptions'"
# '%select{invalid|missing}0 option%select{ %1|}0; expected vectorize, vectorize_width, interleave, interleave_count, unroll, unroll_count, pipeline, pipeline_initiation_interval, vectorize_predicate, or distribute'
HC3AB036EF44A: '%select{無效|缺少}0 選項%select{ %1|}0; %expect vectorize, vectorize_width, interleave, interleave_count, unroll, unroll_count, pipeline, pipeline_initiation_interval, vectorize_predicate, 或 distribute'
# '%select{in|co|contra}0variant type parameter %1 conflicts with previous %select{in|co|contra}2variant type parameter %3'
H893590D91D8F: '%select{左|右|}0 邊異變型參數 %1 與先前的 %select{左|右|}2 邊異變型參數 %3 冲突'
# '%select{left |right |}0operand to %select{assignment|compound assignment|increment|decrement}1 expression must be %select{an l-value|of scalar type (was %3)}2'
H115469577E3D: '%select{左邊 |右邊 |}0 運算元至 %select{指派|複合指派|遞增|遞減}1 運算式必須為 %select{左值|純量類型（實際為 %3）}2'
# '%select{left|right}0 side of operator converted from negative value to unsigned: %1'
H1DC6B6DA95C3: '%select{左邊|右邊}0 邊運算元因將負值轉換為無符號值而被轉換：%1'
# '%select{left|right}1 operand to ? is void, but %select{right|left}1 operand is of type %0'
H8125EE82CC5A: '%select{左|右}1 邊操作數到 ? 運算元為 void，但%select{右|左}1 邊操作數的類型為 %0'
# '%select{loading directly from|assigning directly to}0 pointer to type %1 requires cl_khr_fp16. Use vector data %select{load|store}0 builtin functions instead'
H66CF7FCAA26B: '%select{從|寫入}指向類型 %1 的指標需要 cl_khr_fp16 建構。應改用 vector data %select{load|store}0 內建函式'
# '%select{local variable|parameter|typedef}0 %1 cannot be declared __module_private__'
H1DE6DC0BF8C5: '%select{局部變數|參數|typedef}0 %1 不能宣告為__module_private__'
# "%select{map type '%1' is not allowed|map type must be specified}0 for '#pragma omp %2'"
HA49CE3340880: "%select{map類型 '%1' 不允許|必須指定map類型}0 用於 '#pragma omp %2'"
# "%select{missing '#include'|missing '#include %3'}2; %select{||default argument of |explicit specialization of |partial specialization of }0%1 must be %select{declared|defined|defined|declared|declared}0 before it is used"
H0EC06C773CD9: "%select{缺少 '#include'|缺少 '#include %3'}2；%select{||預設參數的 |明確專屬化的 |部分專屬化的 }0%1 必須%select{宣告|定義|定義|宣告|宣告}0 在使用前"
# '%select{no_destroy|always_destroy}0 attribute can only be applied to a variable with static or thread storage duration'
H7D17D7EDA6B0: '%select{no_destroy|always_destroy}0 屬性只能套用於具有靜態或執行緒儲存期的變數'
# '%select{non-constexpr|constexpr|consteval}1 declaration of %0 follows %select{non-constexpr|constexpr|consteval}2 declaration'
H2DCC831B3932: '%select{非constexpr|constexpr|consteval}1 宣告的 %0 跟隨 %select{非constexpr|constexpr|consteval}2 宣告'
# '%select{non-constexpr|undefined}0 %select{function|constructor}1 %2 cannot be used in a constant expression'
H338EAA31FD42: '%select{非constexpr|未定義}0 %select{函式|建構函式}1 %2 不可在常數運算式中使用'
# '%select{non-const|volatile}0 lvalue reference %diff{to type $ cannot bind to a temporary of type $|cannot bind to incompatible temporary}1,2'
HD89DCBC20587: '%select{非const|volatile}0 左值引用 %diff{至類型$無法綁定到類型$的暫時物件|無法綁定到不相容的暫時物件}1,0'
# '%select{non-const|volatile}0 lvalue reference %diff{to type $ cannot bind to a value of unrelated type $|cannot bind to a value of unrelated type}1,2'
H1777D1633EE8: '%select{非const|volatile}0 左值引用 %diff{至類型$無法綁定到無關類型$的值|無法綁定到無關類型的值}1,0'
# '%select{non-const|volatile}0 lvalue reference to type %1 cannot bind to an initializer list temporary'
H3CF62E12AA3E: '%select{非const|volatile}0 左值引用至類型 %1 無法綁定到矩陣初始清單暫時物件'
# '%select{non-const|volatile}0 reference cannot bind to bit-field%select{| %1}2'
H8AF09902E67B: '%select{非const|volatile}0 參考無法綁定到成員位段 %select{| %1}2'
# '%select{non-const|volatile}0 reference cannot bind to matrix element'
HA82833F246FF: '%select{非const|volatile}0 參考無法綁定到矩陣元素'
# '%select{non-const|volatile}0 reference cannot bind to vector element'
H6E26FD01A944: '%select{非const|volatile}0 參考無法綁定到向量元素'
# '%select{non-integral type %0|%0}1 is an invalid underlying type'
HAB3E494D65F5: '%select{非整數類型 %0|%0}1 是無效的基礎類型'
# '%select{non-kernel function|function scope}0 variable cannot be declared in %1 address space'
H0866366952CF: '%select{非kernel函式|函式範疇}0 變數不可在 %1 位址空間宣告'
# "%select{non-member function|static member function|explicit object member function|deduction guide}0 %select{of type %2 |}1cannot have '%3' qualifier"
HFB817CBCD184: "%select{非成員函式|靜態成員函式|明確物件成員函式|推論指引}0 %select{類型 %2 的|}1 不可具有 '%3' 限定符"
# '%select{non-member|member}0 %select{<ERROR>|equality|three-way|equality|relational}1 comparison operator must have %select{2|1}0 parameters'
HB5C9D99264DA: '%select{非成員|成員}0 %select{<ERROR>|等式|三向|等式|關係}1 比較運算子必須有 %select{2|1}0 個參數'
# '%select{non-member|static member|non-static member}0 function cannot perform a tail call to %select{non-member|static member|non-static member|pointer-to-member}1 function%select{| %3}2'
HE869F55E570F: '%select{非成員|靜態成員|非靜態成員}0 函數無法對 %select{非成員|靜態成員|非靜態成員|成員指針}1 函數 %select{| %3}2 進行尾調用'
# "%select{non-pointer|function pointer|void pointer}0 argument to '__builtin_launder' is not allowed"
H5F5CB4F84C85: '__builtin_launder 的 %select{非指標|函數指標|void指標}0 參數不被允許'
# "%select{non-struct type|non-class type|non-union type|non-enum type|typedef|type alias|template|alias template|template template argument}1 %0 cannot be referenced with the '%select{struct|interface|union|class|enum}2' specifier"
HA353FC8D883A: "%select{非結構類型|非類別類型|非聯合類型|非列舉類型|typedef類型|類型別名|模板|別名模板|模板模板參數}1 %0 不可用 '%select{struct|interface|union|class|enum}2' 限定符參考"
# '%select{non-virtual|virtual}0 derivation here'
H7895E4BCBED9: '%select{非虛|虛}0 派生在此處'
# "%select{non-|function }0pointer argument to '__builtin_is_within_lifetime' is not allowed"
HEC6E2A0FBA29: '__builtin_is_within_lifetime 的 %select{非指標|函數指標}0 參數不被允許'
# "%select{no|too many}0 integer expression arguments provided to OpenACC 'num_gangs' %select{|clause: '%1' directive expects maximum of %2, %3 were provided}0"
HDF54FE517944: "%select{未提供|超出}0 整數表達式參數給 OpenACC 'num_gangs' %select{|子句: '%1' 指令最多接受 %2，但提供了 %3}0"
# "%select{orphaned 'omp section' directives are prohibited, it|'omp section' directive}0 must be closely nested to a sections region%select{|, not a %1 region}0"
HF07F4A64D372: "%select{孤兒 'omp section' 指令不被允許，它|'omp section' 指令}0 必須緊密巢狀在 sections 區域 %select{|，而非 %1 區域}0"
# "%select{overridden|current}0 method is explicitly declared 'instancetype'%select{| and is expected to return an instance of its class type}0"
HB89C11914779: "%select{覆寫|目前}0 方法明確宣告為 'instancetype'%select{|，並期望返回其類別的實例}0"
# "%select{overridden|current}0 method is part of the '%select{|alloc|copy|init|mutableCopy|new|autorelease|dealloc|finalize|release|retain|retainCount|self}1' method family%select{| and is expected to return an instance of its class type}0"
HB76B1E081BAA: "%select{覆寫|目前}0 方法是 '%select{|alloc|copy|init|mutableCopy|new|autorelease|dealloc|finalize|release|retain|retainCount|self}1' 方法家族的成員 %select{|，並期望返回其類別的實例}0"
# '%select{parameters|function return value}0 cannot have __fp16 type; did you forget * ?'
H3BDED28AD784: '%select{參數|函數傳回值}0 不可具有 __fp16 類型；是否遺漏 *？'
# '%select{parameter|non-static data member}3 %0 %select{|of %1 }3shadows member inherited from type %2'
H35412B47BBE2: '%select{參數|非靜態資料成員}3 %0 %select{|的 %1 }3遮蔽繼承自類別 %2 的成員'
# '%select{parameter|parameter pack}0 declared here'
H2699C14A1A0C: '%select{參數|參數包}0 這裡宣告'
# "%select{parenthesize the third argument|cast the second argument to 'int'}0 to silence"
H798E3A404637: '%select{將第三個參數括號化|將第二個參數轉型為「int」}0 以消除'
# '%select{partial specialization|explicit specialization|explicit instantiation}0 of alias templates is not permitted'
H336DD87FEE99: '%select{部分專門化|明確專門化|明確實體化}0 別名模板不被允許'
# '%select{pointers|references}0 are unsupported in HLSL'
H134DDEB0FD66: '%select{指標|引用}0 在 HLSL 中未被支援'
# '%select{pointers|references}0 to functions are not allowed'
H30519C3FCFC8: '%select{指標|引用}0 至函數不被允許'
# '%select{pointer|block pointer|member pointer}0 is missing a nullability type specifier (_Nonnull, _Nullable, or _Null_unspecified)'
HF29961D95705: '%select{指標|區塊指標|成員指標}0 缺少空值型別規範符 (_Nonnull, _Nullable 或 _Null_unspecified)'
# '%select{pointer|reference}0 to %select{|subobject of }1%select{temporary|%3}2 is not a constant expression'
H7F2DE7357BB3: '%select{指標|參考}0 至 %select{|子物件的 }1%select{臨時物件|%3}2 不是常數運算式'
# "%select{pointer|reference}0 to %select{|subobject of }1%select{type_info object|string literal|temporary object|predefined '%3' variable}2 is not allowed in a template argument"
HD8CE51EB9A3E: "%select{指標|參考}0 至 %select{|子物件的 }1%select{type_info 物件|字串文字|臨時物件|預定義的 '%3' 變數}2 無法用於範型參數"
# '%select{pointer|reference}0 to %select{|subobject of }1heap-allocated object is not a constant expression'
H9D1E7F5B4FD5: '%select{指標|參考}0 至 %select{|子物件的 }1堆上分配的物件不是常數運算式'
# '%select{pointer|reference}0 to WebAssembly reference type is not allowed'
HECDCB166B532: '%select{指標|引用}0 至 WebAssembly 參考型別不允許使用'
# '%select{pointer|reference}0 to a consteval declaration is not a constant expression'
H8FC8E4B28636: '%select{指標|引用}0 至 consteval 声明不是常數運算式'
# '%select{pointer|reference}1 to non-const type %0 with no explicit ownership'
H0FF342784C44: '%select{指標|引用}1 至非const型別 %0 且未指定所有權'
# '%select{precompiled header|module}0 uses __DATE__ or __TIME__'
H2637E05CCFD6: '%select{預編譯標頭|模組}0 使用 __DATE__ 或 __TIME__'
# '%select{program scope|static local|extern}0 variable must reside in %1 address space'
H8250A4383E97: '%select{程式作用域|靜態局部|extern}0 變數必須位於 %1 位址空間'
# '%select{property|instance variable}0 access cannot be qualified with %1'
H8153C2BE3904: '%select{屬性|實體變數}0 存取不能用 %1 修飾'
# "%select{public|private|project}1 umbrella header file not found in input: '%0'"
HFB4B45B92460: "%select{公開|私人|專案}1 umbrella 頭文件未在輸入中找到: '%0'"
# "%select{qualifier in |static |}0array size %select{||'[*] '}0is a C99 feature"
H5561702CDE0D: "%select{修飾符在 |static |}0 陣列大小 %select{||'[*] '}0 是 C99 的功能"
# "%select{qualifier in |static |}0array size %select{||'[*] '}0is a C99 feature, not permitted in C++"
HD9EDD0C87400: "%select{修飾符在 |static |}0 陣列大小 %select{||'[*] '}0 是 C99 的功能，不允許在 C++ 中使用"
# '%select{read of|read of|assignment to|increment of|decrement of|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>}0 volatile %select{temporary|object %2|member %2}1 is not allowed in a constant expression'
H88BF34501395: '%select{讀取|讀取|指派給|遞增|遞減|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>}0 volatile %select{暫時物件|%2 的物件|%2 成員}1 不允許在常數運算式中使用'
# '%select{read of|read of|assignment to|increment of|decrement of|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>}0 volatile-qualified type %1 is not allowed in a constant expression'
HFA8AACB1DC9D: '%select{讀取|讀取|指派給|遞增|遞減|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>}0 volatile-qualified 型別 %1 不允許在常數運算式中使用'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of subobject of|destruction of|read of}0 %select{object outside its lifetime|uninitialized object}1 is not allowed in a constant expression'
H030F1EA383B2: '%select{讀取|讀取|指派給|遞增|遞減|成員呼叫|dynamic_cast|typeid 應用於|子物件建立|物件銷毀|讀取}0 %select{物件在其生命周期外|未初始化物件}1 不允許在常數運算式中使用'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of subobject of|destruction of|read of}0 member %1 of union with %select{active member %3|no active member}2 is not allowed in a constant expression'
HAA36C87281CE: '%select{讀取|讀取|指派給|遞增|遞減|成員呼叫|dynamic_cast|typeid 應用於|子物件建立|物件銷毀|讀取}0 成員 %1 的聯結 union 具有 %select{活躍成員 %3|無活躍成員}2 不允許在常數運算式中使用'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 %select{temporary|variable}1 whose %plural{8:storage duration|:lifetime}0 has ended'
H1E2EE7FC7CDC: '%select{讀取|讀取|指派給|遞增|遞減|成員呼叫|dynamic_cast|typeid 應用於|物件建立|物件銷毀|讀取}0 %select{暫時|變數}1 其 %plural{8:儲存期間|:生命周期}0 已結束'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 dereferenced null pointer is not allowed in a constant expression'
H22FE9FDFDD6D: '%select{讀取|讀取|賦值給|遞增|遞減|成員呼叫|dynamic_cast|對...應用typeid|建構|銷毀|讀取}0 解析後的空指標是非法的常數運算式'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 dereferenced one-past-the-end pointer is not allowed in a constant expression'
H0D344CA7C10F: '%select{讀取|讀取|賦值給|遞增|遞減|成員呼叫|dynamic_cast|對...應用typeid|建構|銷毀|讀取}0 解析後的越界指標是非法的常數運算式'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 element of array without known bound is not allowed in a constant expression'
H5DD079C28614: '%select{讀取|讀取|賦值給|遞增|遞減|成員呼叫|dynamic_cast|對...應用typeid|建構|銷毀|讀取}0 界限未知陣列的元素在常數運算式中非法'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 heap allocated object that has been deleted'
H0F4326DA1EA9: '%select{讀取|讀取|賦值給|遞增|遞減|成員呼叫|dynamic_cast|對...應用typeid|建構|銷毀|讀取}0 已經被delete的堆上物件'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 mutable member %1 is not allowed in a constant expression'
H08EBC2661AFA: '%select{讀取|讀取|賦值給|遞增|遞減|成員呼叫|dynamic_cast|對...應用typeid|建構|銷毀|讀取}0 可變更成員 %1 在常數運算式中非法'
# "%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 object '%1' whose value is not known"
H2547ED9973E0: "%select{讀取|讀取|賦值給|遞增|遞減|成員呼叫|dynamic_cast|對...應用typeid|建構|銷毀|讀取}0 值未知的物件 '%1'"
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 temporary is not allowed in a constant expression outside the expression that created the temporary'
H1A04D5C0C6D4: '%select{讀取|讀取|賦值給|遞增|遞減|成員呼叫|dynamic_cast|對...應用typeid|建構|銷毀|讀取}0 非創建運算式中的臨時物件在常數運算式中非法'
# '%select{reading|writing}1 the value pointed to by %0 requires holding %select{any mutex|any mutex exclusively}1'
H20B2C79559EA: '%select{讀取|寫入}1 指標 %0 所指向的值需要持有%select{任何鎖定|獨佔鎖定}1'
# '%select{reading|writing}1 variable %0 requires holding %select{any mutex|any mutex exclusively}1'
HAB41C50F5547: '%select{讀取|寫入}1 變數 %0 需要持有%select{任何鎖定|獨佔鎖定}1'
# "%select{reading|writing}3 the value pointed to by %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
HA3CF53D5D321: "%select{讀取|寫入}3 由 %1 指向的值需要持有 %0 %select{'%2'|'%2' 獨佔地}3"
# "%select{reading|writing}3 variable %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
HBF61FE4FFCA3: "%select{讀取|寫入}3 變數 %1 需要持有 %0 %select{'%2'|'%2' 獨佔地}3"
# "%select{reference|backing array for 'std::initializer_list'}2 %select{|subobject of }1member %0 %select{binds to|is}2 a temporary object whose lifetime is shorter than the lifetime of the constructed object"
H31A36503387B: '%select{參考|std::initializer_list的基礎陣列}2 %select{|子物件的 }1成員 %0 %select{綁定到|是}2 寿命短於建構物件的臨時物件'
# "%select{reference|backing array for 'std::initializer_list'}2 %select{|subobject of }1member %0 %select{binds to|is}2 a temporary object whose lifetime would be shorter than the lifetime of the constructed object"
H54C5751F42B3: '%select{參考|std::initializer_list的基礎陣列}2 %select{|子物件的 }1成員 %0 %select{綁定到|是}2 寿命會短於建構物件的臨時物件'
# '%select{reference|pointer}0 member declared here'
H8AC5A0A64CFD: '%select{參考|指標}0 成員在此處宣告'
# '%select{reinterpret_cast|C-style cast}0 from %1 to %2 changes address space of nested pointers'
HDAB148B74E30: '%select{reinterpret_cast|C型式轉換}0 從 %1 到 %2 改變巢狀指標的地址空間'
# '%select{reinterpret_cast|dynamic_cast|%select{this conversion|cast that performs the conversions of a reinterpret_cast}1|cast from %1}0 is not allowed in a constant expression%select{| in C++ standards before C++20||}0'
H1688ED0E5178: '%select{reinterpret_cast|dynamic_cast|%select{this conversion|cast that performs the conversions of a reinterpret_cast}1|cast from %1}0 不允許在常數運算式中使用 %select{|在C++20之前的C++標準中||}0'
# '%select{remainder|division}0 by zero is undefined'
HDDF6DBF3AFB2: '%select{餘數|除法}0 除以零是未定義的行為'
# '%select{returning|passing}0 a VL-dependent argument %select{from|to}0 a function with a different streaming-mode is undefined behaviour when the streaming and non-streaming vector lengths are different at runtime'
HD835E99E7B94: '%select{返回|傳遞}0 一個 VL 依賴型參數 %select{從|到}0 具有不同流模式的函數，當流和非流向量長度在執行時不同時，會產生未定義行為'
# '%select{returning|passing}0 a VL-dependent argument %select{from|to}0 a locally streaming function is undefined behaviour when the streaming and non-streaming vector lengths are different at runtime'
H78DE8F398FA2: '%select{返回|傳遞}0 一個 VL 依賴型參數 %select{從|到}0 具有局部流模式的函數，當流和非流向量長度在執行時不同時，會產生未定義行為'
# '%select{return|parameter|variable|field|instance variable|synthesized instance variable}0 type %1 is an abstract class'
H83DAE33A1A29: '%select{return|parameter|variable|field|instance variable|synthesized instance variable}0 類型 %1 是一個抽象類別'
# "%select{self-|array |pointer }0comparison always evaluates to %select{a constant|true|false|'std::strong_ordering::equal'}1"
H25C7EE9B164E: "%select{self-|array |pointer }0比較始終評估為 %select{常數|true|false|'std::strong_ordering::equal'}1"
# "%select{shader model|Vulkan environment|shader stage}0 '%1' in target '%2' is invalid for HLSL code generation"
H559D5EF03AE6: "%select{著色器模型|Vulkan 環境|著色器階段}0 '%1' 在目標 '%2' 中對 HLSL 程式碼生成無效"
# "%select{shader model|Vulkan environment|shader stage}0 is required as %select{OS|environment}1 in target '%2' for HLSL code generation"
H2955A7AC1204: "%select{著色器模型|Vulkan 環境|著色器階段}0 需要作為 %select{作業系統|環境}1 在目標 '%2' 中用於 HLSL 程式碼生成"
# '%select{signed value|extra discriminator|blended pointer|blended integer}0 must have %select{pointer|integer|pointer or integer}1 type; type here is %2'
HA4822404707C: '%select{有符號值|額外區別項|混合指標|混合整數}0 必須具有 %select{指標|整數|指標或整數}1 類型；這裡的類型是 %2'
# "%select{signed |}0'size_t' literal is out of range of possible %select{signed |}0'size_t' values"
HADACA5CF45B7: "%select{有符號 |}0'size_t' 字面量超出可能 %select{有符號 |}0'size_t' 值的範圍"
# '%select{signed|unsigned}0 _BitInt must have a bit size of at least %select{2|1}0'
H866585566251: '%select{有符號|無符號}0 _BitInt 必須具有至少 %select{2|1}0 位的大小'
# '%select{signed|unsigned}0 _BitInt of bit sizes greater than %1 not supported'
HB66515AEE2F3: '%select{有符號|無符號}0 _BitInt 的位數大於 %1 的未被支援'
# "%select{source|destination}2 of '%select{%select{memcpy|wmemcpy}1|%select{memmove|wmemmove}1}0' is %3"
H752C91AB4DE4: "%select{來源|目標}2 的 '%select{%select{memcpy|wmemcpy}1|%select{memmove|wmemmove}1}0' 是 %3"
# "%select{statement after '#pragma omp %1' must be a for loop|expected %2 for loops after '#pragma omp %1'%select{|, but found only %4}3}0"
H5AE78EDFB051: "%select{在 '#pragma omp %1' 之後的語句必須是for迴圈|期望在 '#pragma omp %1' 之後有 %2 個for迴圈 %select{|，但僅找到 %4}3}0"
# '%select{statement|directive}0 outside teams construct here'
HCEC20E30EFC9: '%select{語句|指令}0 在這裡的 teams 結構外部'
# "%select{static data member is predetermined as shared|variable with static storage duration is predetermined as shared|loop iteration variable is predetermined as private|loop iteration variable is predetermined as linear|loop iteration variable is predetermined as lastprivate|constant variable is predetermined as shared|global variable is predetermined as shared|non-shared variable in a task construct is predetermined as firstprivate|variable with automatic storage duration is predetermined as private}0%select{|; perhaps you forget to enclose 'omp %2' directive into a parallel or another task region?}1"
HF1446F769957: "%select{靜態資料成員預先指定為共享|具有靜態存儲持續期間的變數預先指定為共享|迴圈迭代變數預先指定為私有|迴圈迭代變數預先指定為線性|迴圈迭代變數預先指定為 lastprivate|常數變數預先指定為共享|全域變數預先指定為共享|task 結構內非共享變數預先指定為 firstprivate|具有自動存儲持續期間的變數預先指定為私有}0%select{|；可能您忘記將 'omp %2' 指令包裝在 parallel 或其他 task 區域中？}1"
# "%select{string|character|boolean|numeric}0 literal must be prefixed by '@' in a collection"
H437BC3E10750: '%select{字串|字元|布林|數值}0 字面量必須在集合中以 @ 開頭'
# "%select{string|numeric}0 literal must be prefixed by '@'"
HE32E641B2BF1: '%select{字串|數值}0 字面量必須以 @ 開頭'
# '%select{struct|interface|class}0 with virtual base %plural{1:class|:classes}1 is not a literal type'
H74349A7BD7CA: '%select{struct|interface|class}0 具有虛基 %plural{1:類別|:類別}1 不是字面類型'
# '%select{struct|interface|class}0%select{| template}1 %2 was previously declared as a %select{struct|interface|class}3%select{| template}1; this is valid, but may result in linker errors under the Microsoft C++ ABI'
H2D10AD8D0564: '%select{struct|interface|class}0%select{| template}1 %2 過去被宣告為 %select{struct|interface|class}3%select{| template}1；此行為合法，但可能在Microsoft C++ ABI下導致連結器錯誤'
# '%select{struct|interface|union|class|enum}0 %1 does not declare any constructor to initialize its non-modifiable members'
HAB227F7E6966: '%select{結構|介面|聯合|類別|列舉}0 %1 未宣告任何建構函式來初始化其不可修改的成員'
# '%select{struct|union}0 kernel parameters may not contain pointers'
H1723C50B8752: '%select{struct|union}0 核心參數不得包含指標'
# '%select{struct|union}0 without named members is a GNU extension'
HBECD0A183C46: '%select{struct|union}0 若沒有命名成員則是GNU擴充'
# '%select{subtraction|addition}0 of address-of-label expressions is not supported with ptrauth indirect gotos'
H131327EB0D0D: '%select{減法|加法}0 的地址標籤運算式不支援 ptrauth 間接 goto'
# '%select{template type|non-type template|template template}0 parameter%select{| pack}1 conflicts with previous %select{template type|non-type template|template template}0 parameter%select{ pack|}1'
HACD51B91D6D5: '%select{template type|non-type template|template template}0 參數 %select{| pack}1 與先前的 %select{template type|non-type template|template template}0 參數%select{ pack|}1 產生衝突'
# '%select{template type|non-type template|template template}0 parameter%select{| pack}1 does not match %select{template type|non-type template|template template}0 parameter%select{ pack|}1 in template argument'
H42D8D01F5E06: '%select{template type|non-type template|template template}0 參數 %select{| pack}1 在模板參數中與 %select{template type|non-type template|template template}0 參數%select{ pack|}1 不符合'
# '%select{template|partial|member}0 specialization cannot be declared __module_private__'
H0A90D5264D30: '%select{template|partial|member}0 專門化不能宣告為__module_private__'
# '%select{temporary %select{whose address is used as value of|%select{|implicitly }2bound to}4 %select{%select{|reference }4member of local variable|local %select{variable|reference}4}1|array backing %select{initializer list subobject of local variable|local initializer list}1}0 %select{%3 |}2will be destroyed at the end of the full-expression'
H1685FEE7827D: '%select{臨時物件 %select{其地址被用作值|%select{ | 隱含 }2綁定到}4 %select{%select{ | 參考 }4的成員是局部變數|局部 %select{變數|參考}4}1 |陣列後備 %select{局部變數的初始清單子物件|局部初始清單}1}0 %select{%3 |}2 將在完整表達式的結尾被銷毀'
# "%select{the message|the expression}0 in %select{a static assertion|this asm operand}0 must be a string literal or an object with 'data()' and 'size()' member functions"
H320EEB9B1530: "%select{訊息|運算式}0 在 %select{static assertion|這個asm運算元}0 中必須是字串常數或具有 'data()' 和 'size()' 成員函數的物件"
# '%select{the message|the expression}0 in %select{a static assertion|this asm operand}0 must be produced by a constant expression'
H9571480E2335: '%select{訊息|運算式}0 在 %select{static assertion|這個asm運算元}0 中必須由常數運算式產生'
# "%select{the message|the expression}0 in %select{a static assertion|this asm operand}0 must have a '%select{size|data}1()' member function returning an object convertible to '%select{std::size_t|const char *}1'"
HE077A8EBD022: "%select{訊息|運算式}0 在 %select{static assertion|這個asm運算元}0 中必須具有回傳可轉換為 '%select{std::size_t|const char *}1' 的 '%select{size|data}1()' 成員函數"
# '%select{the message|the expression}0 in %select{this static assertion|this asm operand}0 is not a constant expression'
H1136016D414E: '%select{訊息|運算式}0 在 %select{此static assertion|這個asm運算元}0 中不是常數運算式'
# '%select{too few|too many}0 template arguments for %select{class template|function template|variable template|alias template|template template parameter|concept|template}1 %2'
HA3BFC0466346: '%select{模板參數過少|模板參數過多}0 對於%select{類別模板|函式模板|變數模板|別名模板|模板模板參數|概念|模板}1 %2'
# '%select{too few|too many}0 template parameters in template %select{|template parameter }1redeclaration'
H2FC8E4427754: '%select{模板參數過少|模板參數過多}0 在模板 %select{|模板參數 }1重宣告中'
# '%select{too few|too many}0 template parameters in template template argument'
HEDDF73011D6C: '%select{模板參數過少|模板參數過多}0 在模板模板參數中'
# '%select{too many|too few}0 elements in vector %select{initialization|operand}3 (expected %1 elements, have %2)'
HEB48F48C2E39: '%select{過多|過少}0個元素在向量%select{初始化|運算元}3中（期望 %1 個，有 %2 個）'
# '%select{type tag|argument}0 index %1 is greater than the number of arguments specified'
H7C0418F179E9: '%select{類型標籤|參數}0索引 %1 大於指定的參數個數'
# '%select{typedef|type alias|type alias template}0 redefinition with different types%diff{ ($ vs $)|}1,2'
H7F72DD3ED811: '%select{typedef|type alias|type alias template}0 重新定義時類型不同%diff{（$與$不同）|}1,2'
# '%select{uninitialized use occurs|variable is captured by block}0 here'
H80571A54148A: '%select{未初始化的使用發生於|變數被區塊捕獲}0此處'
# '%select{unknown|unsupported}0 machine mode %1'
HB579643BB1CB: '%select{未知|不支援}0機器模式 %1'
# '%select{unsafe pointer operation|unsafe pointer arithmetic|unsafe buffer access|function introduces unsafe buffer manipulation|unsafe invocation of %1|field %1 prone to unsafe buffer manipulation}0'
HD969AD0BDB13: '%select{不安全的指標操作|不安全的指標運算|不安全的緩衝區存取|函數引入不安全的緩衝區操作|對 %1 的不安全呼叫|成員 %1 易受不安全緩衝區操作影響}0'
# "%select{unsupported|duplicate|unknown}0%select{| CPU| tune CPU}1 '%2' in the '%select{target|target_clones|target_version}3' attribute string;"
H8412993B41A2: "%select{不支援|重複|未知}0%select{| CPU| 調整後CPU}1 '%2' 在 '%select{目標|目標複製|目標版本}3' 屬性字串中;"
# "%select{unsupported|duplicate|unknown}0%select{| CPU| tune CPU}1 '%2' in the '%select{target|target_clones|target_version}3' attribute string; '%select{target|target_clones|target_version}3' attribute ignored"
H952DC46C8259: "%select{不支援|重複|未知}0%select{| CPU| 調整後CPU}1 '%2' 在 '%select{目標|目標複製|目標版本}3' 屬性字串中；%select{目標|目標複製|目標版本}3屬性被忽略"
# '%select{using this character in an identifier|starting an identifier with this character}0 is incompatible with C99'
H2BC4F8FF7FD4: '%select{在識別符中使用此字元|以這個字元開頭的識別符}0與C99不相容'
# "%select{values of type|enum values with underlying type}2 '%0' should not be used as format arguments; add an explicit cast to %1 instead"
H74FA7B9CE6BC: "%select{型別值|具有基礎型別的枚舉值}2 '%0' 不應作為格式參數使用；應明確轉換為 %1"
# '%select{value|type}0-dependent expression passed as an argument to debug command'
HF8F02B43BB62: '%select{值|類型}0依賴的運算式被傳遞給除錯命令的引數'
# '%select{variable|static data member}0 instantiated with function type %1'
HE6193A7D74C4: '%select{變數|靜態資料成員}0以函式類型 %1 實體化'
# '%select{via initialization of|binding reference}0 variable %select{%2 |}1here'
HB0440A5001E5: '%select{透過初始化|綁定參考}0 變數 %select{%2 |}1 在此處'
# "%select{virtual method|function pointer}0 cannot be inferred '%1'"
H57712FD11644: "%select{虛方法|函式指標}0無法推斷 '%1'"
# '%select{void function|void method|constructor|destructor}1 %0 must not return a value'
HE90DDC8579B5: '%select{void函式|void方法|建構子|析構子}1 %0 必須不可傳回值'
# '%select{void function|void method|constructor|destructor}1 %0 should not return a value'
H917D4EA3DC61: '%select{void函式|void方法|建構子|析構子}1 %0 應不可傳回值'
# '%select{wide|Unicode}0 character literals may not contain multiple characters'
HEBA1B65B6166: '%select{wide|Unicode}0 字元字面值不能包含多個字元'
# "%select{x86|x86-64}0 'interrupt' attribute only applies to functions that have %select{a 'void' return type|only a pointer parameter optionally followed by an integer parameter|a pointer as the first parameter|a %2 type as the second parameter}1"
H6EAE552C7EA8: "%select{x86|x86-64}0 'interrupt' 屬性僅適用於返回類型%select{為 'void'|具有可選後跟整數參數的指標參數|以指標作為第一個參數|%2 類型作為第二個參數}1的函數"
# "%select{|'%1-%2' }0diagnostics %select{with '%2' severity |}0%select{expected|seen}3 but not %select{seen|expected}3: %4"
H6E1DC1644300: "%select{|'%1-%2' }0診斷%select{具有 '%2' 嚴重性 |}0%select{期望|檢測到}3 但未%select{檢測到|期望}3：%4"
# '%select{|a template declaration|an explicit template specialization|an explicit template instantiation}0 can only %select{|declare|declare|instantiate}0 a single entity'
HCEE3630F178B: '%select{|模板宣告|明確模板特化|明確模板實體化}0 只能 %select{|宣告|宣告|實體化}0 單一實體'
# "%select{|captured }1%0 parameter marked 'called_once' is never called"
H5EDD8753404F: "%select{|捕獲的 }1%0 標記為 'called_once' 的參數從未被調用"
# '%select{|captured }1completion handler is never called'
H31A1FA39F285: '%select{|被捕獲的 }1完成處理器從未被呼叫'
# "%select{|change to 'snprintf' for explicit bounds checking | buffer pointer and size may not match|string argument is not guaranteed to be null-terminated|'va_list' is unsafe}0"
H071DEF637982: "%select{|改為使用 'snprintf' 進行明確邊界檢查 |緩衝區指標和大小可能不匹配|字串參數不保證以空終結|'va_list' 是不安全}0"
# '%select{|direct }0%select{method|property}1 declaration conflicts with previous %select{|direct }2declaration of %select{method|property}1 %3'
H1D02391D3A58: '%select{|直接 }0%select{方法|屬性}1 宣告與先前 %select{|直接 }2宣告的%select{方法|屬性}1 %3 冲突'
# '%select{|empty }0%select{struct|union}1 has size 0 in C, %select{size 1|non-zero size}2 in C++'
HEA8D8C4B49F9: '%select{|空的 }0%select{struct|union}1 在C中大小為 0，在C++中%select{大小為 1|非零大小}2'
# "%select{|implicit }0use of 'this' pointer is only allowed within the evaluation of a call to a 'constexpr' member function"
HE1347141F3D2: "%select{|隱式 }0使用 'this' 指標僅允許在評估 'constexpr' 成員函數調用時使用"
# '%select{|implicitly }1declared %select{private|protected}0 here'
H8D12655CD9C3: '%select{|隱式宣告的}%select{private|protected}0 在這裡'
# "%select{|incremented }0enumerator value which exceeds the range of 'int' is a C23 extension (%1 is too %select{small|large}2)"
H7317CEFA834D: "%select{|遞增的 }0枚舉值超出 'int' 的範圍是C23擴展（%1 過%select{小|大}2）"
# "%select{|incremented }0enumerator value which exceeds the range of 'int' is incompatible with C standards before C23 (%1 is too %select{small|large}2)"
H02CD4F5E389B: "%select{|遞增的 }0枚舉值超出 'int' 的範圍與C23之前的標準不相容（%1 過%select{小|大}2）"
# '%select{|member|base class}0 %1 declared here'
H83331E20A1A3: '%select{|成員|基類}0 %1 此處宣告'
# '%select{|member}0 using declaration %1 instantiates to an empty pack'
H03EFD19ED92A: '%select{|成員}0 使用宣告 %1 實例化為空包'
# '%select{|non-aggregate }0type %1 cannot be initialized with an initializer list'
H94A9DAA06E2F: '%select{|非聚合 }0類型 %1 不能用初始值列表初始化'
# '%select{|overriding }1method cannot be unavailable on %0 when %select{the protocol method it implements|its overridden method}1 is available'
H11BFB9C90008: '%select{|覆寫 }1方法當實作協定的方法 %select{|或被覆寫的方法}1 在 %0 可用時不可標示為不可用'
# '%select{|overriding }4method %select{introduced after|deprecated before|obsoleted before}0 %select{the protocol method it implements|overridden method}4 on %1 (%2 vs. %3)'
H3102E4185799: '%select{|覆寫 }4方法 %select{在...後引入|在...前已棄用|在...前已廢止}0 %select{它實作的協定方法|覆寫的方法}4 在 %1 上 (%2 對 %3)'
# '%select{|pointer to |reference to }0incomplete type %1 is not allowed in exception specification'
HBD4554E2864A: '%select{|指向|對應}0 不完整類型 %1 不允許出現在例外規格中'
# "%select{|previous }0'hint' clause with value '%1'"
HBBFA3E1A9C6B: "%select{|先前的 }0'hint' 子句指定值 '%1'"
# "%select{|previous }0directive with no 'hint' clause specified"
H8CE1C8734C39: "%select{|先前的 }0未指定 'hint' 子句的指示"
# '%select{|previous }0using declaration'
H5AE3701DBB92: '%select{|先前的 }0使用宣告'
# '%select{|previous }0using-enum declaration'
H5BC63E8C8F5E: '%select{|先前的 }0使用-列舉宣告'
# '%select{|reference to }0sizeless type %1 is not allowed in exception specification'
H3E89611A15B6: '%select{|引用 }0無大小類型 %1 不允許出現在例外規格中'
# '%select{|second }0%1 token is here'
H00E98F1D44F7: '%select{|第二個 }0%1 令牌在此處'
# '%select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2 uses deleted function%select{|: %4}3'
HD806C936F5D9: '%select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|函式樣式 cast|}0 從 %1 轉換到 %2 使用了已被刪除的函數 %select{|: %4}3'
# '%select{|success |failure }0memory order argument to atomic operation is invalid'
HFAC869D2863E: '%select{|成功 |失敗 }0原子運算的記憶體順序參數無效'
# "%select{|umbrella }0header '%1' not found"
H3FDB64D57A92: "%select{|總綱 }0標頭 '%1' 未找到"
# '%select{|unsafe_unretained|strong|weak}1 property %0 may not also be declared %select{|__unsafe_unretained|__strong|__weak|__autoreleasing}2'
HC9D6BEED9F9F: '%select{|nonretained|強制保留|弱引用}1 屬性 %0 不可同時宣告為 %select{|__nonretained|__強制保留|__弱引用|__自動釋放}2'
# '%select{||reinterpret_cast||C-style cast||}0 from scalar %1 to vector %2 of different size'
HFF11D1B4EA50: '%select{||reinterpret_cast||C型式轉換||}0 從標量 %1 到不同大小的向量 %2 的轉換'
# '%select{||reinterpret_cast||C-style cast||}0 from vector %1 to scalar %2 of different size'
H4BC2B3E593E1: '%select{||reinterpret_cast||C型式轉換||}0 從向量 %1 到不同大小的標量 %2 的轉換'
# '%select{||reinterpret_cast||C-style cast||}0 from vector %1 to vector %2 of different size'
H855233AE0D42: '%select{||reinterpret_cast||C型式轉換||}0 從向量 %1 到不同大小的向量 %2 的轉換'
# "%select{|||||virtual function called on|dynamic_cast applied to|typeid applied to|construction of|destruction of}0 object '%1' whose dynamic type is not constant"
H292A692F3948: "%select{|||||呼叫虛函數於|dynamic_cast套用於|typeid套用於|建立|銷毀}0物件 '%1'，其動態類型並非固定"
# "'##' cannot appear at end of __VA_OPT__ argument"
H2B78B6D67ACA: "'##' 無法出現在 __VA_OPT__ 參數的結尾處"
# "'##' cannot appear at end of macro expansion"
H0D880CABAC3F: "'##' 無法出現在預處理宏展開的結尾處"
# "'##' cannot appear at start of __VA_OPT__ argument"
H2F2411264E60: "'##' 無法出現在 __VA_OPT__ 參數的開頭處"
# "'##' cannot appear at start of macro expansion"
H49669D0F3359: "'##' 無法出現在預處理宏展開的開頭處"
# "'#include <filename>' attaches the declarations to the named module '%0', which is not usually intended; consider moving that directive before the module declaration"
HE8759FB5FF70: "'#include <filename>' 會將宣告附屬到命名模組 '%0'，這通常非預期行為；建議將此指令移至模組宣告之前"
# "'#pragma %0' can only appear at file scope"
HCE0F9341D433: "'#pragma %0' 只能出現在檔案作用域中"
# "'#pragma %0' can only appear at file scope or at the start of a compound statement"
HD3947EF6D864: "'#pragma %0' 只能出現在檔案作用域或複合語句的開頭處"
# "'#pragma %0' is not supported on this target - ignored"
H10F342B08150: "'#pragma %0' 在此目標上不受支援 - 已忽略"
# "'#pragma STDC FENV_ACCESS ON' is illegal when precise is disabled"
H17CE846EF8B0: "'#pragma STDC FENV_ACCESS ON' 無法在精確模式關閉時使用"
# "'#pragma alloc_text' is applicable only to functions"
H29BA150C71BF: "'#pragma alloc_text' 只適用於函數"
# "'#pragma alloc_text' is applicable only to functions with C linkage"
H8053A181B977: "'#pragma alloc_text' 只適用於具有C連結的函數"
# "'#pragma clang arc_cf_code_audited' was not ended within this file"
H3175433AA2FB: "'#pragma clang assume_nonnull' 在此檔案中未結束"
# "'#pragma clang assume_nonnull' was not ended within this file"
H344021929D5B: "'#pragma clang assume_nonnull' 未在此檔案中結束"
# "'#pragma clang attribute %select{%1.|}0pop' with no matching '#pragma clang attribute %select{%1.|}0push'"
H170B16ACF46E: "'#pragma clang attribute %select{%1.|}0pop' 沒有對應的 '#pragma clang attribute %select{%1.|}0push'"
# "'#pragma clang attribute push' regions ends here"
HF6A5F5655AB0: "'#pragma clang attribute push' 區塊在此結束"
# "'#pragma clang attribute' attribute with no matching '#pragma clang attribute push'"
HAAE6327E2566: "'#pragma clang attribute' 屬性沒有對應的 '#pragma clang attribute push'"
# "'#pragma comment %0' ignored"
HEB14674C1594: "'#pragma comment %0' 被忽略"
# "'#pragma float_control push/pop' can only appear at file or namespace scope or within a language linkage specification"
H053264F8F924: "'#pragma float_control(except, on)' 在 precise 關閉時非法"
# "'#pragma float_control(except, on)' is illegal when precise is disabled"
H28022D025F51: "'#pragma float_control(precise, off)' 在 except 啟用時非法"
# "'#pragma float_control(precise, off)' is illegal when except is enabled"
H922887ACFECE: "'#pragma float_control(precise, off)' 在 fenv_access 啟用時非法"
# "'#pragma float_control(precise, off)' is illegal when fenv_access is enabled"
HAFA440F76585: "'#pragma init_seg' 只在目標為 Microsoft 環境時支援"
# "'#pragma init_seg' is only supported when targeting a Microsoft environment"
H4E91F2EF3757: "'#pragma init_seg' 僅在針對Microsoft環境時支援"
# "'#pragma omp %0' %select{|with '%2' clause }1cannot be an immediate substatement"
HA805BCE4C312: "'#pragma omp %0' %select{|帶有 '%2' 子句 }1不能是立即子語句"
# "'#pragma omp %0' directive must appear only in file scope"
H3C04CBDE708E: "'#pragma omp %0' 指令必須出現在檔案作用域"
# "'#pragma omp %0' must appear in the scope of the %q1 variable declaration"
HCD521713958F: "'#pragma omp %0' 必須在 %q1 變數的所有引用前出現"
# "'#pragma omp %0' must precede all references to variable %q1"
HA982E769431D: "'#pragma omp %0' 必須出現在變數%q1的所有引用之前"
# "'#pragma omp declare %select{simd|variant}0' can only be applied to functions"
HC2DB961C6B39: "'#pragma omp declare %select{simd|variant}0' 只能套用於函數"
# "'#pragma omp declare variant' cannot be applied for function after first usage; the original function might be used"
H504957D176C7: "'#pragma omp declare variant' 無法套用在函數首次使用後；原函數可能已被使用"
# "'#pragma omp declare variant' cannot be applied to the function that was defined already; the original function might be used"
HB5A7CD5EEB6F: "'#pragma omp declare variant' 無法套用在已定義的函數；原函數可能已被使用"
# "'#pragma omp declare variant' does not support %select{function templates|virtual functions|deduced return types|constructors|destructors|deleted functions|defaulted functions|constexpr functions|consteval function}0"
H240B964685D1: "'#pragma omp declare variant' 不支援%select{函數範型|虛函數|推論傳回類型|建構函數|解構函數|已刪除函數|預設函數|constexpr函數|consteval函數}0"
# "'#pragma omp declare variant' is not compatible with any target-specific attributes"
HDFFC2CD6FA69: "'#pragma omp declare variant' 與任何目標特定屬性不相容"
# "'#pragma omp end assumes' with no matching '#pragma omp begin assumes'"
HAF63C041427E: "'#pragma omp end assumes' 沒有對應的 '#pragma omp begin assumes'"
# "'#pragma omp end declare variant' with no matching '#pragma omp begin declare variant'"
HD60959180819: "'#pragma omp end declare variant' 沒有對應的 '#pragma omp begin declare variant'"
# "'#pragma unsafe_buffer_usage' was not ended"
H8FB2F039CC57: "'#pragma unsafe_buffer_usage' 未結束"
# "'$' in identifier"
HB5654708DC14: "'$' 在識別符中"
# "'%%n' specifier not supported on this platform"
HC8B8AD4E064B: "'%%n' 指定項在此平台上不受支援"
# "'%0' %select{length modifier|conversion specifier}1 is not supported by ISO C"
H5FE655A569EF: "'%0' %select{長度修飾符|轉換指定項}1 不符合 ISO C 標準"
# "'%0' ABI is not supported with FPU"
H0E4CA678D6B9: "'%0' 介面不支援 FPU"
# "'%0' action ignored; '%1' action specified previously"
H140C3ABC4AE4: "'%0' 參數被忽略；之前已指定 '%1' 參數"
# "'%0' and '%1' clause are mutually exclusive and may not appear on the same directive"
H124967FEEE58: "'%0' 與 '%1' 子句互斥，不可在同一指令中同時出現"
# "'%0' argument on '%1' clause is not permitted on a%select{|n orphaned}2 '%3' construct%select{| associated with a '%5' compute construct}4"
H43AC213E21A0: "'%0' 參數不可用於 %select{|孤兒}2 '%3' 結構 %select{|與 '%5' 計算構造相關聯}4 的 '%1' 子句上"
# "'%0' argument to '%1' clause not allowed on a '%2' construct%select{| associated with a '%4' construct}3 that has a '%5' clause"
H08457CF75CEB: "'%0' 子句的 '%1' 參數在與具有 '%5' 子句的 '%2'%select{|與 '%4' 結構相關}3 結構不被允許"
# "'%0' as a module map name is deprecated, rename it to %select{module.modulemap|module.private.modulemap}1%select{| in the 'Modules' directory of the framework}2"
H871445ACDF0B: "'%0' 模組映射名稱已棄用，請重新命名為 %select{module.modulemap|module.private.modulemap}1%select{|在框架的 'Modules' 資料夾中}2"
# "'%0' attribute cannot be specified on a definition"
H3887172CED45: "'%0' 屬性不可指定於定義上"
# "'%0' call operates on objects of type %1 while the size is based on a different type %2"
H9E506A66F2D3: "'%0' 作用於類型 %1 的物件時，其大小基於不同類型 %2"
# "'%0' can only be used if the target supports the mfhc1 and mthc1 instructions"
HD98657B082CC: "'%0' 僅可在目標支援 mfhc1 和 mthc1 指令時使用"
# "'%0' can only be used with the '%1' ABI"
HAC173E806F23: "'%0' 僅可搭配 '%1' 介面使用"
# "'%0' cannot be a part of nested name specifier; did you mean ':'?"
H6E2E8EF01102: "'%0' 不能作為嵌套名稱指定符；是否應使用 ':'？"
# "'%0' cannot be called with %select{a null pointer|a one-past-the-end pointer|a pointer to an object whose lifetime has not yet begun}1"
H9E6A8072EAD3: "'%0' 不能用於 %select{空指標|超出物件末端的指標|尚未開始存續期的物件的指標}1"
# "'%0' cannot be signed or unsigned"
HE82DC08D960E: "'%0' 不能指定為有符號或無符號"
# "'%0' cannot be used in an unevaluated context"
HACCAB0092430: "'%0' 不能用於未評估的語境中"
# "'%0' cannot be used in the handler of a try block"
HCC6C7DE7C0DC: "'%0' 不可在 try 區塊的處理程序中使用"
# "'%0' cannot be used outside a function"
HF038C50615EF: "'%0' 不可在函數外使用"
# "'%0' casts have no effect when not using ARC"
H0985DFE3C8AA: "'%0' 的轉換在未使用 ARC 時無效"
# "'%0' clause is specified here"
H573F42F97FF4: "'%0' 子句在此處指定"
# "'%0' clause not allowed on a 'kernels loop' construct that has a '%1' clause with a%select{n| 'num'}2 argument"
HA63B4E6AC69A: "具有 %select{n| 'num'}2 參數的 '%1' 子句的 'kernels loop' 構造不可指定 '%0' 子句"
# "'%0' clause requires 'dispatch' context selector"
H94FAB67C930A: "'%0' 子句需要 'dispatch' 環境選擇器"
# "'%0' clause specifies a loop count greater than the number of available loops"
H13BED1AA5B60: "'%0' 子句指定的迴圈計數超過可用迴圈數量"
# "'%0' clause used here"
HC259BC00C8FD: "'%0' 子句在此處使用"
# "'%0' clause with '%1' modifier cannot be specified if an 'ordered' clause is specified"
HFFE6A9A75740: "若指定 'ordered' 子句，則不可指定帶有 '%1' 修飾符的 '%0' 子句"
# "'%0' clauses cannot be mixed with '%1' clause"
H0A2484D8EEB5: "'%0' 子句不可與 '%1' 子句同時使用"
# "'%0' construct is here"
H4E6A1EF91E1B: "'%0' 構造在此處"
# "'%0' declared as a member pointer to a reference of type %1"
HF4FF87D5007C: "'%0' 被宣告為指向型別 %1 的參考的成員指標"
# "'%0' declared as a member pointer to void"
HB8704C365E55: "'%0' 被宣告為指向 void 的成員指標"
# "'%0' declared as a pointer to a reference of type %1"
H95E780665FDE: "'%0' 被宣告為指向型別 %1 的參考指標"
# "'%0' declared as an array with a negative size"
H44D9A6FDB5F3: "'%0' 被宣告為具有負長度的陣列"
# "'%0' declared as array of functions of type %1"
HF167BCD9180C: "'%0' 被宣告為型別 %1 的函數陣列"
# "'%0' declared as array of references of type %1"
H07B7977DE9AC: "'%0' 被宣告為型別 %1 的參考陣列"
# "'%0' directive cannot follow %select{'%2' directive|other expected directives}1"
H81459AA5C045: "'%0' 指令不能跟隨 %select{'%2' 指令|其他期望指令}1"
# "'%0' directive found here"
H689CAA47B15F: "'%0' 指令在此處發現"
# "'%0' does not contain a GCC installation"
H5EA2B901E3DD: "'%0' 不包含GCC安裝"
# "'%0' does not support '-%1'; flag ignored"
H5F193B6442A3: "'%0' 不支援 '-%1'；旗標被忽略"
# "'%0' does not support '-moutline'; flag ignored"
H8FCF49E8EFFE: "'%0' 不支援 '-moutline'；旗標被忽略"
# "'%0' evaluates to a null function pointer"
HC166C9B46BC9: "'%0' 評估為空函數指標"
# "'%0' file not found"
HE40852833202: "'%0' 檔案未找到"
# '\'%0\' file not found with <angled> %select{include|import}1; use "quotes" instead'
HB65E7D8C29D0: "'%0' 檔案未使用<尖括號> %select{包含|匯入}1找到；請改用「雙引號」"
# "'%0' file not found, did you mean '%1'?"
HA3BAEA90173D: "'%0' 檔案未找到，是否意指 '%1'？"
# "'%0' function must have a prototype"
H161348B5A00F: "'%0' 函數必須具有原型"
# "'%0' ignored on this declaration"
H3A73EC6937F0: "'%0' 在此宣告中被忽略"
# "'%0' included multiple times, additional include site here"
H67346CC37DF8: "'%0' 被多次包含，額外包含位置在此處"
# "'%0' included multiple times, additional include site in header from module '%1'"
HC2226976DFB3: "'%0' 被多次包含，額外包含位置在模組 '%1' 的標頭檔中"
# "'%0' invalid for input of type %1"
H0F254F5D0DEC: "'%0' 無法轉換為類型 %1 的輸入"
# "'%0' is a C11 extension"
HACD9CD0EB9B2: "'%0' 是C11擴充"
# "'%0' is a C2y extension"
H46F684F39EE1: "'%0' 是C2y擴充"
# "'%0' is a C99 extension"
H553903351EEE: "'%0' 是C99擴充"
# "'%0' is a context %select{set|selector|property}1 not a context %select{set|selector|property}2"
H0E6818DF21E4: "'%0' 是語境 %select{集合|選擇器|屬性}1 而非語境 %select{集合|選擇器|屬性}2"
# "'%0' is a keyword in C++11"
H6E1B6EF2D90A: "'%0' 是 C++11 的關鍵字"
# "'%0' is a keyword in C++20"
HED77874B7FB4: "'%0' 是 C++20 的關鍵字"
# "'%0' is a keyword in C23"
H55337290EE76: "'%0' 是 C23 的關鍵字"
# "'%0' is a keyword in C99"
H305C2462E219: "'%0' 是 C99 的關鍵字"
# "'%0' is bound to current loop, GCC binds it to the enclosing loop"
H6C2FAF9A98CF: "'%0' 綁定到當前迴圈，GCC 會將其綁定到外層迴圈"
# "'%0' is ignored since it is only supported for HIP"
HAF6605CCA46F: "'%0' 未被採用，因它僅支援 HIP"
# "'%0' is incompatible with C standards before C11"
H0DA1AA64E023: "'%0' 與 C11 之前的所有 C 標準不相容"
# "'%0' is incompatible with C standards before C23"
HDD86BE78B3D0: "'%0' 與 C23 之前的所有 C 標準不相容"
# "'%0' is incompatible with C standards before C2y"
H1CC83438FCCD: "'%0' 與 C2y 之前的所有 C 標準不相容"
# "'%0' is invalid in friend declarations"
H3D161449A142: "'%0' 在友元宣告中無效"
# "'%0' is not a valid Unicode character name"
H469DC75B6244: "'%0' 不是有效的 Unicode 字元名稱"
# "'%0' is not a valid builtin name for %1"
H4BF3E4DBB43C: "'%0' 不是 %1 的有效內建名稱"
# "'%0' is not a valid context property for the context selector '%1' and the context set '%2'; property ignored"
HEB6F750CA90C: "'%0' 不是對語境選擇器 '%1' 和語境集合 '%2' 有效的語境屬性；屬性將被忽略"
# "'%0' is not a valid context selector for the context set '%1'; selector ignored"
H6CA470A4E352: "'%0' 不是語境集合 '%1' 的有效選擇器；選擇器將被忽略"
# "'%0' is not a valid context set in a `declare variant`; set ignored"
HA1E62D28111D: "'%0' 不是 `declare variant` 中有效的語境集合；集合將被忽略"
# "'%0' is not a valid object format flag"
H0558CE31CE90: "'%0' 不是有效的物件格式旗標"
# "'%0' is not permitted on a declaration of a type"
H43ABF8D7D74B: "'%0' 不允許用於類型宣告"
# "'%0' is not supported in C++ for OpenCL"
HDCEA34FAF8C7: "'%0' 在支援OpenCL的C++中未實作"
# "'%0' is only allowed on variable declarations"
H6BFADFD542E9: "'%0' 只允許用於變數宣告"
# "'%0' is only available in %1"
H468F8034CF09: "'%0' 僅在 %1 中提供"
# "'%0' is used without '-mstack-protector-guard-offset', and there is no default"
H8812B24333D0: "'%0' 使用時未指定 '-mstack-protector-guard-offset'，且無預設值"
# "'%0' keyword is a C++11 extension"
H23175F3671E1: "'%0' 關鍵字是C++11擴充功能"
# "'%0' keyword is incompatible with C++98"
HCFDB7E16EAB8: "'%0' 關鍵字與C++98不相容"
# "'%0' keyword not permitted with interface types"
HFAA4A308281C: "'%0' 無法用於介面類型"
# "'%0' may overflow; destination buffer in argument %1 has size %2, but the corresponding specifier may require size %3"
H45D6462C38BC: "'%0' 可能溢位；第 %1 個參數的目標緩衝區大小為 %2，但對應格式說明可能需要 %3 大小"
# "'%0' not supported, please use -iquote instead"
HD03640F49183: "'%0' 未支援，請改用 -iquote"
# "'%0' only applies to %select{function|pointer|Objective-C object or block pointer}1 types; type here is %2"
H76B771A1DA3E: "'%0' 只適用於%select{函數|指標|Objective-C物件或區塊指標}1類型；目前類型為 %2"
# "'%0' only applies to medium and large code models"
H2B43B16BADDB: "'%0' 選項僅適用於中等與大型程式碼模型"
# "'%0' option requires target HLSL Version >= 2018%select{| and shader model >= 6.2}1, but HLSL Version is '%2'%select{| and shader model is '%3'}1"
H73FD169C1664: "'%0' 選項需要HLSL版本≥2018%select{|且著色器模型≥6.2}1，但目前HLSL版本為 '%2'%select{|且著色器模型為 '%3'}1"
# "'%0' parameter can only be used with swiftcall%select{ or swiftasynccall|}1 calling convention%select{|s}1"
H7F6C0A7A9011: "'%0' 參數只能與swiftcall%select{或swiftasynccall|}1 呼叫約定%select{搭配使用|}1"
# "'%0' parameter must have pointer%select{| to unqualified pointer}1 type; type here is %2"
HA49C073BB7A8: "'%0' 參數必須是%select{未限定指標|指標}1類型；目前類型為 %2"
# "'%0' previously encountered here"
HC082D10D967F: "'%0' 此處先前已出現"
# "'%0' qualifier is not allowed on a constructor"
HD3C37F48AA10: "'%0' 修飾詞不得用於建構子"
# "'%0' qualifier is not allowed on a destructor"
H63A821EC7A98: "'%0' 修飾詞不得用於解構子"
# "'%0' qualifier may not appear after the virtual specifier '%1'"
HC82C66448381: "'%0' 限定詞不能出現在虛函數指定符 '%1' 之後"
# "'%0' qualifier may not be applied to a reference"
H39DF4A724F57: "'%0' 限定詞不能應用在參考類型上"
# "'%0' qualifier on function type %1 has no effect"
HCA4F5C288E32: "函式類型 %1 上的 '%0' 限定詞無效"
# "'%0' qualifier on function type %1 has no effect and is a Clang extension"
HA82B1E90695B: "函式類型 %1 上的 '%0' 限定詞無效（此為Clang擴充功能）"
# "'%0' qualifier on omitted return type %1 has no effect"
H226C520C0A5C: "省略的返回類型 %1 上的 '%0' 限定詞無效"
# "'%0' qualifier on reference type %1 has no effect"
H9D5F7EA85F79: "參考類型 %1 上的 '%0' 限定詞無效"
# "'%0' qualifier%s1 on base class type %2 %plural{1:has|:have}1 no effect"
HB4BF74C2E9A3: "基底類別類型 %2 上的 '%0' 限定詞%s1%plural{1:無效|:無效}1"
# "'%0' region encountered before requires directive with '%1' clause"
HAC48A5EE380D: "'%0' 區塊在具有 '%1' 子句的requires指令之前出現"
# "'%0' required by '%1'"
H149191A7D780: "'%0' 被 '%1' 所要求"
# "'%0' required for precompiled header not found"
HBDA853057C16: "所需的 '%0' 預編譯標頭未找到"
# "'%0' size argument is too large; destination buffer has size %1, but size argument is %2"
H1B04445BBECB: "'%0' 長度參數過大；目標緩衝區大小為 %1，但指定長度為 %2"
# "'%0' specifier is not allowed outside a class definition"
H496E8612120E: "'%0' 限定詞不能出現在類別定義之外"
# "'%0' statement cannot be used in OpenMP for loop"
HB1E296AE95BC: "OpenMP for 迴圈中不能使用 '%0' 語句"
# "'%0' statement cannot be used in OpenMP simd region"
H1C587C7353B1: "OpenMP simd 區塊中不能使用 '%0' 語句"
# "'%0' type not found; include <omp.h>"
H4CF50F4E769F: "未找到 '%0' 類型；請包含 <omp.h>"
# "'%0' type qualifier%s1 on return type %plural{1:has|:have}1 no effect"
H065A9C128711: "'%0' 在回傳類型上的類型修飾符%s1%plural{1:對回傳類型無效|:對回傳類型無效}1"
# "'%0' type specifier is incompatible with C++98"
HB674C3599FA0: "'%0' 類型指定符與C++98不相容"
# "'%0' variables must have global storage"
H08EBA7A5907F: "'%0' 變數必須具有全域儲存"
# "'%0' will always be truncated; specified size is %1, but format string expands to at least %2"
H0AA6DDAAABA2: "'%0' 會永遠被截斷；指定大小為 %1，但格式字串展開後至少需要 %2"
# "'%0' will always evaluate to 'true' in a manifestly constant-evaluated expression"
H75D7A83FFEC6: "'%0' 在明確的常量運算表達式中永遠會評估為 'true'"
# "'%0' will always overflow; destination buffer has size %1, but format string expands to at least %2"
H6C8DA523F6B3: "'%0' 會永遠溢位；目的緩衝區大小為 %1，但格式字串展開後至少需要 %2"
# "'%0' will always overflow; destination buffer has size %1, but size argument is %2"
H6A8E065AE173: "'%0' 會永遠溢位；目的緩衝區大小為 %1，但大小參數是 %2"
# "'%0' will always overflow; destination buffer has size %1, but the source string has length %2 (including NUL byte)"
H4E1F13141ECB: "'%0' 會永遠溢位；目的緩衝區大小為 %1，但來源字串長度為 %2（包含NUL字元）"
# "'%0' will return the size of the pointer, not the array itself"
H10D34141626D: "'%0' 將傳回指標的大小，而非陣列本身"
# "'%0' within '%1'"
HFD060F45F3E4: "'%0' 在 '%1' 內"
# "'%0': selected processor lacks floating point registers"
H5E83058CA4FE: "'%0': 選擇的處理器缺乏浮點運算寄存器"
# "'%0': unable to pass LLVM bit-code files to linker"
H5B7DB64DAEE9: "'%0': 無法將LLVM位元碼檔案傳遞給連結器"
# "'%0': unable to use AST files with this tool"
HEA339F2E046F: "'%0': 無法在此工具中使用AST檔案"
# "'%0': unable to use module files with this tool"
H25C074B573CF: "'%0': 無法在此工具中使用模組檔案"
# "'%0(%select{source|sink:vec}1)' clause%select{|s}1 cannot be mixed with '%0(%select{sink:vec|source}1)' clause%select{s|}1"
H081C849E3FF9: "'%0(%select{source|sink:vec}1)' 子句 %select{|s}1 無法與 '%0(%select{sink:vec|source}1)' 子句 %select{s|}1 混合使用"
# "'%1' attribute on property %0 does not match the property inherited from %2"
H0392738DA622: "'%1' 屬性在屬性 %0 與從 %2 繼承的屬性不相符"
# "'%1' cannot be used in %select{a constructor|a destructor|the 'main' function|a constexpr function|a function with a deduced return type|a varargs function|a consteval function}0"
HB2DCA2D92D0E: "'%select{建構函數|析構函數|'main' 函數|constexpr函數|具有推論回傳類型的函數|可變參數函數|consteval函數}0'中不能使用 '%1'"
# "'%select{#|#@}0' is not followed by a macro parameter"
HFFC615C42B6A: "'%select{#|#@}0' 後未跟隨宏參數"
# "'%select{%select{memcpy|wmemcpy}1|%select{memmove|wmemmove}1}0' not supported: %select{size to copy (%4) is not a multiple of size of element type %3 (%5)|source is not a contiguous array of at least %4 elements of type %3|destination is not a contiguous array of at least %4 elements of type %3}2"
HEE3F2A4E1A36: "'%select{%select{memcpy|wmemcpy}1|%select{memmove|wmemmove}1}0' 未支援：%select{要複製的大小（%4）不是元素類型 %3（%5）的倍數|來源不是至少 %4 個元素的類型 %3 連續陣列|目的不是至少 %4 個元素的類型 %3 連續陣列}2"
# "'%select{*|.*}0' specified field %select{width|precision}0 is missing a matching 'int' argument"
H0D1F0E4F63B2: "'%select{*|.*}0' 指定的欄位%select{寬度|精確度}0 缺少對應的 'int' 參數"
# "'%select{--|++}0' on an object of complex type is a C2y extension"
HDA93C21904C8: "'%select{--|++}0' 運算子作用於複數類型物件是C2y擴展"
# "'%select{--|++}0' on an object of complex type is incompatible with C standards before C2y"
H20E81B85B020: "'%select{--|++}0' 運算子作用於複雜類型物件與C2y之前C標準不相容"
# "'%select{\\|@}0%1' command does not terminate a verbatim text block"
H42F81A2BAA36: "'%select{\\|@}0%1' 指令未結束直譯文字區塊"
# "'%select{\\|@}0%1' command has %plural{0:no|:%2}2 word argument%s2, expected %3"
HBEDC67E6720C: "'%select{\\|@}0%1' 命令具有 %plural{0:無|:%2}2 個單字參數，期望 %3"
# "'%select{\\|@}0%1' command used in a comment that is attached to a %select{function returning void|constructor|destructor|method returning void}2"
HFBFA65D15A47: "'%select{\\|@}0%1' 指令用於附加至%select{回傳void類型的函數|建構函數|析構函數|回傳void類型的方法}2的註解中"
# "'%select{\\|@}0%1' command used in a comment that is not attached to a function or method declaration"
H9A9CB5F0CECC: "'%select{\\|@}0%1' 指令用於未附加至函數或方法宣告的註解中"
# "'%select{\\|@}0%select{classdesign|coclass|dependency|helper|helperclass|helps|instancesize|ownership|performance|security|superclass}1' command should not be used in a comment attached to a non-container declaration"
H63CA64568B3F: "'%select{\\|@}0%select{classdesign|coclass|dependency|helper|helperclass|helps|instancesize|ownership|performance|security|superclass}1' 指令不應用於附加至非容器宣告的註解中"
# "'%select{\\|@}0%select{class|interface|protocol|struct|union}1' command should not be used in a comment attached to a non-%select{class|interface|protocol|struct|union}2 declaration"
H2B2D23C85C31: "'%select{\\|@}0%select{class|interface|protocol|struct|union}1' 指令不應用於附加至非 %select{class|interface|protocol|struct|union}2 宣告的註解中"
# "'%select{\\|@}0%select{function|functiongroup|method|methodgroup|callback}1' command should be used in a comment attached to %select{a function|a function|an Objective-C method|an Objective-C method|a pointer to function}2 declaration"
H30965075CCD3: "'%select{\\|@}0%select{function|functiongroup|method|methodgroup|callback}1' 指令應用於附加至%select{函數|函數|Objective-C方法|Objective-C方法|函數指標}2宣告的註解中"
# "'%select{\\|@}0param' command used in a comment that is not attached to a function declaration"
HA6D99227D713: "'%select{\\|@}0param' 指令用於未附加至函數宣告的註解中"
# "'%select{\\|@}0tparam' command used in a comment that is not attached to a template declaration"
H78D96F6B0A65: "'%select{\\|@}0tparam' 指令用於未附加至範型宣告的註解中"
# "'%select{auto|decltype(auto)}0' in return type deduced as %1 here but deduced as %2 in earlier return statement"
HDFEF08FDDF8E: "'%select{auto|decltype(auto)}0' 在回傳類型中 %1 在此處被推論，但與先前的return語句中推論為 %2 產生衝突"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' argument cannot refer to a union member"
HF50BCD9CECE6: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' 參數不能引用共用體成員"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' argument must be a simple declaration reference"
HF6AC15305460: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' 參數必須是簡單宣告引用"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' cannot be applied to a union member"
H01022C27C2BB: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' 不能應用於共用體成員"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' only applies to pointers%select{ or C99 flexible array members|||}0%select{|; did you mean to use 'counted_by'?}1"
H077E0A5BF4C4: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' 只能用於指標%select{或C99彈性陣列成員|||}0%select{; 是否應使用 'counted_by'?|}1"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' requires a non-boolean integer type argument"
H69D52A4DAF87: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' 需要非布林整數類型參數"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}1' field %0 isn't within the same struct as the annotated %select{pointer|flexible array}2"
HBD3F5637D173: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}1' 標記的 %0 欄位與被註解的%select{指標|彈性陣列}2不在同一結構體中"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}4' %select{cannot|should not}3 be applied to %select{a pointer with pointee|an array with element}0 of unknown size because %1 is %select{an incomplete type|a sizeless type|a function type|a struct type with a flexible array member%select{|. This will be an error in a future compiler version}3}2"
HEFA740A9E276: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}4' %select{不能|不應}3 應用於 %select{指標所指向的|陣列元素}0 無法確定大小的類型，因為 %1 是 %select{不完整類型|無大小類型|函數類型|包含可調節長度陣列的結構類型 %select{|。此處將在未來版本編譯器中成為錯誤}3}2"
# "'%select{if|switch}0' initialization statements are a C++17 extension"
HBFF569602D2E: "'%select{if|switch}0' 初始化語句是 C++17 擴充"
# "'%select{make_unsigned|make_signed}0' is only compatible with non-%select{bool|_BitInt(1)}1 integers and enum types, but was given %2%select{| whose underlying type is %4}3"
H89BC3FB5059E: "'%select{make_unsigned|make_signed}0' 只與非 %select{bool|_BitInt(1)}1 整數及列舉類型兼容，但給定 %2%select{| 其底層類型是 %4}3"
# "'%select{memcpy|wmemcpy}0' between overlapping memory regions"
HF4936F4E6501: "'%select{memcpy|wmemcpy}0' 在重疊記憶體區域之間複製"
# "'%select{pure|const}0' attribute on function returning 'void'; attribute ignored"
H219A6665B476: "'%select{pure|const}0' 屬性用於返回 'void' 的函數；屬性被忽略"
# "'%select{|short|long|long long}0 %1' is invalid"
H4742130B5F6C: "'%select{|short|long|long long}0 %1' 是無效的類型指定"
# "'&&' of a value and its negation always evaluates to false"
H35E9DA987909: "'&&' 運算子的兩邊值與其反值進行邏輯運算始終為 false"
# "'&&' within '||'"
H8790A025A3C5: "'&&' 用於 '||' 運算式內部"
# "'&' cannot precede a capture when the capture default is '&'"
HA416D7E37193: "'&' 不能出現在 ' &' 預設捕獲模式的單一變數捕獲前"
# "'&' must precede a capture when the capture default is '='"
HC2B64117C04B: "'&' 必須出現在 '=' 預設捕獲模式的單一變數捕獲前"
# "'*' query has already been specified"
H24FF63F5C6A0: "'*' 查詢參數已被指定"
# "'--hip-path' must be specified when offloading to SPIR-V unless '-nogpuinc' is given"
HF39C24E57C93: "'--hip-path' 需在 SPIR-V 離線編譯時指定，除非使用 '-nogpuinc'"
# "'->' applied to return value of the operator->() declared here"
H2D7F207160DF: "'->' 運算子應用於 operator->() 的傳回值"
# "'-fopenmp-targets' must be used in conjunction with a '-fopenmp' option compatible with offloading; e.g., '-fopenmp=libomp' or '-fopenmp=libiomp5'"
HECE3FA60C323: "'-fopenmp-targets' 必須與支援離線編譯的 '-fopenmp' 選項搭配使用；例如 '-fopenmp=libomp' 或 '-fopenmp=libiomp5'"
# "'-fsanitize=memtag-stack' requires hardware support (+memtag). For Armv8 or Armv9, try compiling with -march=armv8a+memtag or -march=armv9a+memtag"
H3869C74238EE: "'-fsanitize=memtag-stack' 需硬體支援 (+memtag)。對 Armv8 或 Armv9，可嘗試使用 -march=armv8a+memtag 或 -march=armv9a+memtag"
# "'-ftrivial-auto-var-init-max-size=*' is used without '-ftrivial-auto-var-init=zero' or '-ftrivial-auto-var-init=pattern'"
H85D7452F85FC: "'-ftrivial-auto-var-init-max-size=*' 需搭配 '-ftrivial-auto-var-init=zero' 或 '-ftrivial-auto-var-init=pattern'"
# "'-ftrivial-auto-var-init-max-size=*' only accepts positive integers (in bytes)"
H15368DD22E8B: "'-ftrivial-auto-var-init-max-size=*' 只接受正整數（以位元組為單位）"
# "'-ftrivial-auto-var-init-stop-after=*' is used without '-ftrivial-auto-var-init=zero' or '-ftrivial-auto-var-init=pattern'"
HA64F3C5CF11D: "'-ftrivial-auto-var-init-stop-after=*' 需搭配 '-ftrivial-auto-var-init=zero' 或 '-ftrivial-auto-var-init=pattern'"
# "'-ftrivial-auto-var-init-stop-after=*' only accepts positive integers"
H964D5FF3D330: "'-ftrivial-auto-var-init-stop-after=*' 只接受正整數"
# "'-fuse-ld=' taking a path is deprecated; use '--ld-path=' instead"
H24009BC2E029: "'-fuse-ld=' 接收路徑已棄用；請改用 '--ld-path='"
# "'-mbranch-protection=' option is incompatible with the '%0' architecture"
H4CC02B48C139: "'-mbranch-protection=' 選項與 '%0' 架構不相容"
# "'-mindirect-jump=%0' is unsupported with the '%1' architecture"
HA019BCF52E06: "'-mindirect-jump=%0' 不支援 '%1' 架構"
# "'-x %0' after last input file has no effect"
H37D74D222DAD: "'-x %0' 在最後一個輸入檔之後無效"
# "'.  Try: '"
H3E571CE448AB: "'.  請嘗試: '"
# "'...' as the only parameter of a function is incompatible with C standards before C23"
H0778011D458B: "在 C23 之前的 C 標準中，函式唯一參數為 '...' 是不被支援的"
# "'...' in this location creates a C-style varargs function%select{, not a function parameter pack|}0"
HDE7D8371A836: "此位置的 '...' 創建 C 風格可變參數函式%select{，而非函式參數包|}0"
# "'...' must %select{immediately precede declared identifier|be innermost component of anonymous pack declaration}0"
H636262C7094A: "'...' 必須 %select{直接位於宣告的識別符之前|在匿名包宣告中作為最內層組成部分}0"
# "'/*' within block comment"
HF2D384BEFA1C: "'/*' 在區塊註解內部"
# "'/U%0' treated as the '/U' option"
HE813F64217D5: "'/U%0' 被視為 '/U' 選項"
# "':' without preceding '?'"
H8AFE0C8D8DEE: "未跟隨 '?' 的 ':'"
# "'<::' is treated as digraph '<:' (aka '[') followed by ':' in C++98"
H79B7386C3992: "'<::' 在 C++98 中被視為 digraph '<:' (即 '[') 後接 ':'"
# "'<=>' is a single token in C++20; add a space to avoid a change in behavior"
HA94282EE55ED: "'<=>' 是 C++20 中的單一語法單元；添加空格以避免行為改變"
# "'<=>' operator is incompatible with C++ standards before C++20"
H95F1D52E2E7F: "'<=>' 運算子與 C++20 之前的標準不相容"
# "'= %select{default|delete}0' is a function definition and must occur in a standalone declaration"
H500D10ACAD58: "'= %select{default|delete}0' 是函式定義，必須出現在獨立宣告中"
# "'= delete' with a message is a C++2c extension"
H31210BBF787E: "帶有訊息的 '= delete' 是 C++2c 擴展"
# "'= delete' with a message is incompatible with C++ standards before C++2c"
HF4121BB98E1E: "帶有訊息的 '= delete' 與 C++2c 之前的標準不相容"
# "'@encode' of incomplete type %0"
H26BBB8B07598: "'@encode' 的不完整類型 %0"
# "'@end' appears where closing brace '}' is expected"
H0D104C2A47DE: "'@end' 出現在期望有閉合大括號 '}' 的位置"
# "'@end' must appear in an Objective-C context"
H53F73799BBFE: "'@end' 必須出現在 Objective-C 環境中"
# "'NSObject' attribute is for pointer types only"
HB79535A35025: "'NSObject' 屬性僅適用於指標類型"
# "'NSObject' attribute may be put on a typedef only; attribute is ignored"
H5749529C7AA1: "'NSObject' 屬性只能用於 typedef；屬性被忽略"
# "'[[%select{nodiscard|gnu::warn_unused_result}0]]' attribute ignored when applied to a typedef; consider using '__attribute__((warn_unused_result))' or '[[clang::warn_unused_result]]' instead"
HC050BA19FE21: "'[[%select{nodiscard|gnu::warn_unused_result}0]]' 屬性無法用於 typedef；建議改用 '__attribute__((warn_unused_result))' 或 '[[clang::warn_unused_result]]'"
# "'[[carries_dependency]]' attribute only allowed on parameter in a function declaration or lambda"
HA6D310EC7345: "'[[carries_dependency]]' 屬性只能用於函數宣告或lambda的參數"
# "'[]' after delete interpreted as 'delete[]'; add parentheses to treat this as a lambda-expression"
H9FAF75D55EEF: "delete 後的 '[]' 被解譯為 'delete[]'; 如需視為lambda運算式，請加上括號"
# "'_BitInt' %select{vector|matrix}0 element width must be %select{a power of 2|at least as wide as 'CHAR_BIT'}1"
H0C14DAF989FF: "'_BitInt' %select{向量|矩陣}0 元素寬度必須為 %select{2的冪次|至少與CHAR_BIT相同}1"
# "'_BitInt' in %select{C17 and earlier|C++}0 is a Clang extension"
HDE7EEC66FEFB: "'_BitInt' 在 %select{C17 及更早版本|C++}0 是 Clang 延伸語法"
# "'_BitInt' suffix for literals is a C23 extension"
HA6733F109D23: "'_BitInt' 文字後綴是 C23 延伸語法"
# "'_BitInt' suffix for literals is a Clang extension"
HE33869F03EE8: "'_BitInt' 文字後綴是 Clang 延伸語法"
# "'_BitInt' suffix for literals is incompatible with C standards before C23"
H8F9C2C09F088: "'_BitInt' 文字後綴與 C23 之前標準不相容"
# "'_Complex %0' is invalid"
HF4E888A73841: "'_Complex %0' 無效"
# "'_Countof' requires an argument of array type; %0 invalid"
H8DD99C0DA777: "'_Countof' 需要陣列型別參數；%0 無效"
# "'_ExtInt' is deprecated; use '_BitInt' instead"
H6A2C7F4FE8E7: "'_ExtInt' 已棄用；建議改用 '_BitInt'"
# "'_Noreturn' can only appear on functions"
H8C4082088BE9: "'_Noreturn' 只能用於函數"
# "'_Noreturn' keyword must precede function declarator"
HC448318DE5F1: "'_Noreturn' 關鍵字必須出現在函數宣告符號之前"
# "'_Sat' specifier is only valid on '_Fract' or '_Accum', not '%0'"
H43A3B4233E86: "'_Sat' 指定符只能用於 '_Fract' 或 '_Accum'，而非 '%0'"
# "'_Static_assert' with no message is a C23 extension"
H1BCF5D7E02AE: "未指定訊息的 '_Static_assert' 是 C23 延伸語法"
# "'_Static_assert' with no message is incompatible with C standards before C23"
H977D55CE0649: 'C23之前的标准不支援未指定訊息的_Statics_assert'
# "'__FLT_EVAL_METHOD__' cannot be expanded inside a scope containing '#pragma clang fp eval_method'"
H2CAB7A2D4110: '在包含‘#pragma clang fp eval_method’指令的範圍內無法展開‘__FLT_EVAL_METHOD__’'
# "'__auto_type' is a GNU extension"
H2094509BC6E5: '‘__auto_type’是GNU擴充功能'
# "'__builtin_bit_cast' %select{source|destination}0 type must be trivially copyable"
H90D0B71921CD: '‘__builtin_bit_cast’%select{來源|目標}0類型必須是可簡單複製的'
# "'__builtin_choose_expr' requires a constant expression"
H090BF417F6DF: '‘__builtin_choose_expr’需要一個常數運算式'
# "'__builtin_counted_by_ref' argument cannot have side-effects"
HD566565DD11F: '‘__builtin_counted_by_ref’參數不能有副作用'
# "'__builtin_counted_by_ref' argument must reference a flexible array member"
HABF270462F6F: '‘__builtin_counted_by_ref’參數必須引用柔性陣列成員'
# "'__builtin_ms_va_start' used in System V ABI function"
H007690BB92E1: '在System V ABI函數中使用‘__builtin_ms_va_start’'
# "'__clang__' is a predefined macro name, not an attribute scope specifier; did you mean '_Clang' instead?"
HE8F991CDE8C6: '‘__clang__’是預定義的宏名稱，而非屬性範圍指定符；您是否想使用‘_Clang’？'
# "'__clang_arm_builtin_alias' attribute can only be applied to an ARM builtin"
H79EABB0EF1E5: '‘__clang_arm_builtin_alias’屬性只能套用到ARM內建函數'
# "'__clang_arm_mve_strict_polymorphism' attribute can only be applied to an MVE/NEON vector type"
H202E8786A308: '‘__clang_arm_mve_strict_polymorphism’屬性只能套用到MVE/NEON向量類型'
# "'__declspec' attributes are not enabled; use '-fdeclspec' or '-fms-extensions' to enable support for __declspec attributes"
H465DF3E43560: '‘__declspec’屬性未啟用；使用‘-fdeclspec’或‘-fms-extensions’來啟用對__declspec屬性的支援'
# "'__declspec(dllexport)' cannot be applied to more than one default constructor in %0"
HB67031034443: '‘__declspec(dllexport)’無法套用到 %0 的超過一個預設建構函數'
# "'__declspec(thread)' applied to variable that already has a thread-local storage specifier"
HFE6629E646D9: '將‘__declspec(thread)’套用到已經有線程局部存儲指定符的變數'
# "'__funcref' attribute can only be applied to a function pointer type"
H5101424932DE: '‘__funcref’屬性只能套用到函數指標類型'
# "'__kindof' specifier cannot be applied to non-object type %0"
HBB66D4C1FC38: '‘__kindof’指定符無法套用到非物件類型 %0'
# "'__kindof' type specifier must precede the declarator"
H111C48694838: '必須在宣告符之前指定__kindof類型'
# "'__leave' statement not in __try block"
HA19FB1CE432F: '‘__leave’語句未處於__try區塊中'
# "'__local' variable cannot have an initializer"
H0B1BBFD1CDEA: "'__local' 變數不能有初始值設定項"
# "'__pixel' must be preceded by '__vector'.  '%0' declaration specifier not allowed here"
H88B3B9C40157: "'__pixel' 必須由 '__vector' 領先。 '%0' 声明說明符在此處不允許"
# "'__super' cannot be used with a using declaration"
HE7865E9E15F7: "'__super' 不能與 using 声明一起使用"
# "'__thread' before '%0'"
H4E940DC3AE07: "'__thread' 用在 '%0' 前面"
# "'abi_tag' %0 missing in original declaration"
H1628165A1258: "'abi_tag' %0 在原始宣告中缺少"
# "'abi_tag' attribute on %select{non-inline|anonymous}0 namespace ignored"
HDBC2CCB057F1: "'abi_tag' 屬性在 %select{非內嵌|匿名}0 命名空間被忽略"
# "'abstract' keyword is a Microsoft extension"
HA16E3E3ED791: "'abstract' 關鍵字是 Microsoft 扩展"
# "'adjust_arg' argument %0 used in multiple clauses"
H05E9C9F203D8: "'adjust_arg' 參數 %0 被用在多個子句中"
# "'align_value' attribute requires integer constant"
H6853424EF803: "'align_value' 屬性需要整數常數"
# "'alignas' is incompatible with C++98"
H0BBFE28F35BF: "'alignas' 與 C++98 不兼容"
# "'aligned' attribute requires integer constant"
H1ADA356A8681: "'aligned' 屬性需要整數常數"
# "'alignof' on an incomplete array type is a C2y extension"
HFD6D41C433A2: "'alignof' 在不完整陣列類型是 C2y 扩展"
# "'alignof' on an incomplete array type is incompatible with C standards before C2y"
HF644B202EC9A: "'alignof' 在不完整陣列類型與 C2y 之前標準不兼容"
# "'append_args' is not allowed with varargs functions"
H99449471B7D4: "'append_args' 不允許用在可變參數函數"
# "'assign' property of object type may become a dangling reference; consider using 'unsafe_unretained'"
H7256F2B86929: "'assign' 屬性物件類型可能變成懸垂參考；考慮使用 'unsafe_unretained'"
# "'atomic capture' with a compound statement only supports two statements"
H0E46970C2D96: "'atomic capture' 使用複合語句僅支援兩個語句"
# "'auto' as a functional-style cast is incompatible with C++ standards before C++23"
HD4DCD08E6C51: "'auto' 作為函式風格轉換與 C++23 之前標準不兼容"
# "'auto' deduced as 'id' in declaration of %0"
HD22AA217F352: "'auto' 推導為 'id' 在 %0 宣告中"
# "'auto' return without trailing return type; deduced return types are a C++14 extension"
H2CC514506858: "'auto' 回傳時未指定尾隨返回類型；推論的返回類型是 C++14 擴充功能"
# "'auto' storage class specifier is not permitted in C++11, and will not be supported in future releases"
H51939B968318: "'auto' 存儲類別說明符在 C++11 中不被允許，未來版本也不會支援"
# "'auto' storage class specifier is redundant and incompatible with C++11"
HFAD8EB4C5407: "'auto' 存儲類別說明符是冗餘且與 C++11 不相容"
# "'auto' type specifier is a %select{C++11|HLSL 202y}0 extension"
H96C499C3C66C: "'auto' 類型說明符是 %select{C++11|HLSL 202y}0 擴充功能"
# "'auto' type specifier is incompatible with C++98"
HA4F3AA6BB021: "'auto' 類型說明符與 C++98 不相容"
# "'auto' variable template instantiation is not allowed"
H7677E31876EE: "無法實體化 'auto' 變量模板"
# "'begin' and 'end' returning different types (%0 and %1) is a C++17 extension"
H440F964925D8: "'begin' 和 'end' 返回不同類型 (%0 和 %1) 是 C++17 擴充功能"
# "'begin' and 'end' returning different types (%0 and %1) is incompatible with C++ standards before C++17"
HCE5BB9C433E6: "'begin' 和 'end' 返回不同類型 (%0 和 %1) 與 C++17 之前標準不相容"
# "'break' is bound to loop, GCC binds it to switch"
HB56827FEFDD0: "'break' 與迴圈綁定，GCC 與 switch 綁定"
# "'break' statement not in loop or switch statement"
HD351562F6355: "'break' 語句不在迴圈或 switch 語句中"
# "'break' will never be executed"
H6E907B3877AE: "'break' 將永遠不會執行"
# "'callback' argument at position %0 references unavailable implicit 'this'"
HFC4B047896FC: "位置 %0 的 'callback' 參數引用不可用的隱含 'this'"
# "'callback' attribute argument %0 is not a known function parameter"
H5112D2E8FE1B: "'callback' 屬性參數 %0 不是已知的函數參數"
# "'callback' attribute callee does not have function type"
H11C2E7DC48A0: "'callback' 屬性調用方不具有函數類型"
# "'callback' attribute callee may not be variadic"
H5339D3799089: "'callback' 屬性調用方不可使用可變參數"
# "'callback' attribute specifies invalid callback callee"
HAE51B1A6C397: "'callback' 屬性指定無效的回呼調用方"
# "'callback' attribute specifies no callback callee"
HC67CEF8B86D2: "'callback' 屬性未指定回呼調用方"
# "'called_once' attribute only applies to function-like parameters"
HFCB51789AAF0: "'called_once' 屬性僅適用於函數類型參數"
# "'case' statement not in switch statement"
H3C29CC73E754: "'case' 語句不在 switch 語句中"
# "'char8_t' type specifier is incompatible with C++ standards before C++20"
H6EF68EF28349: "'char8_t' 類型規格與 C++20 之前的标准不相容"
# "'cleanup' argument %select{|%1 |%1 }0is not a %select{||single }0function"
HF9B0713C400E: "'cleanup' 參數 %select{|%1 |%1 }0 不是 %select{||單一 }0 函數"
# "'cleanup' function %0 must take 1 parameter"
H70C0FCE6BEDE: "'cleanup' 函數 %0 必須接受 1 個參數"
# "'cleanup' function %0 parameter has %diff{type $ which is incompatible with type $|incompatible type}1,2"
H24491DE4E886: "'cleanup' 函數 %0 參數具有 %diff{與類型 $ 不相容的類型 $|不相容的類型}1,2"
# "'cmse_nonsecure_entry' cannot be applied to functions with internal linkage"
H36BD2CDFCAC5: "'cmse_nonsecure_entry' 不能套用到具有內部連結性的函數"
# "'co_await' modifier can only be applied to range-based for loop"
H23B6AEBD1B5B: "'co_await' 修飾詞只能用於基於範圍的 for 迴圈"
# "'const' attribute imposes more restrictions; 'pure' attribute ignored"
HAC8EEAA61CD9: "'const' 屬性施加更多限制；'pure' 屬性被忽略"
# "'consteval' specifier is incompatible with C++ standards before C++20"
HFAB40415D777: "'consteval' 修飾詞與 C++20 之前的標準不相容"
# "'constexpr' can only be used in variable declarations"
HCCD21640DBE9: "'constexpr' 只能用於變數宣告"
# "'constexpr' non-static member function will not be implicitly 'const' in C++14; add 'const' to avoid a change in behavior"
H23AE1DDB6BF2: "'constexpr' 非靜態成員函數在 C++14 中不會隱式為 'const'；加入 'const' 以避免行為變更"
# "'constexpr' on lambda expressions is a C++17 extension"
H99E246301B16: "'constexpr' 在 lambda 表達式是 C++17 擴充功能"
# "'constexpr' specifier is incompatible with C++98"
H26D17B863D82: "'constexpr' 修飾詞與 C++98 不相容"
# "'constinit' specifier added after initialization of variable"
H941EB6451F6C: "'constinit' 修飾詞在變數初始化後才宣告"
# "'constinit' specifier is incompatible with C++ standards before C++20"
HA94D78D91751: "'constinit' 修飾詞與 C++20 之前的標準不相容"
# "'constinit' specifier missing on initializing declaration of %0"
H55C3572EEC7C: "'constinit' 修飾詞在 %0 初始化宣告時未指定"
# "'continue' statement not in loop statement"
HCD539EA88B8F: "'continue' 陳述式不在迴圈陳述式中"
# "'copy' attribute must be specified for the block property when -fobjc-gc-only is specified"
H87791A0AEA62: "當指定 -fobjc-gc-only 時，'copy' 屬性必須為區塊屬性指定"
# "'counted_by' cannot refer to the flexible array member %0"
H5B04880F56A4: "'counted_by' 無法引用可調整陣列成員 %0"
# "'counted_by' on arrays only applies to C99 flexible array members"
HB17E489D7021: "'counted_by' 在陣列中僅適用於 C99 可調整陣列成員"
# "'cpu_dispatch' function redeclared with different CPUs"
HCA2FB0047F16: "'cpu_dispatch' 函數被重新宣告為不同的 CPU"
# "'decltype' type specifier is incompatible with C++98"
H06E59DDEED89: "'decltype' 類型指定符與 C++98 不相容"
# "'decltype(auto)' can only be used as a return type in a function declaration"
H5356DF2FE6D3: "'decltype(auto)' 只能用於函數宣告的返回類型"
# "'decltype(auto)' cannot be combined with other type specifiers"
H139F443827AC: "'decltype(auto)' 不可與其他類型指定符結合"
# "'decltype(auto)' not allowed here"
HA795F2923798: "'decltype(auto)' 類型指定符在此處不可用"
# "'decltype(auto)' type specifier is a C++14 extension"
H7E1DB4CB833F: "'decltype(auto)' 類型指定符是 C++14 擴充功能"
# "'decltype(auto)' type specifier is incompatible with C++ standards before C++14"
HA38CAC8829B9: "'decltype(auto)' 類型指定符與 C++14 之前的標準不相容"
# "'default' statement not in switch statement"
H1133498536DD: "'default' 陳述式不在 switch 陳述式內"
# "'defined' cannot appear within this context"
HDAE80537A1D3: "'defined' 無法在此語境中使用"
# "'defined' cannot be used as a macro name"
HB4BA3900B80E: "'defined' 不能作為巨集名稱使用"
# "'delete%select{|[]}0' applied to a pointer that was allocated with 'new%select{[]|}0'; did you mean 'delete%select{[]|}0'?"
H84CC0C534191: "'delete%select{|[]}0' 應用於以 'new%select{[]|}0' 分配的指標；您是否想使用 'delete%select{[]|}0'？"
# "'delete' applied to a pointer-to-array type %0 treated as 'delete[]'"
H011BFAE8BB84: "'delete' 應用於指標至陣列類型 %0 且視為 'delete[]'"
# "'delete' cannot delete objects of type %0 in address space '%1'"
H7E66A4AF7B26: "在位址空間 '%1' 中無法刪除類型 %0 的物件"
# "'depend' clause for 'ordered' is deprecated; use 'doacross' instead"
HB07DCDAB27B1: "'depend' 子句在 'ordered' 上已被棄用；請改用 'doacross'"
# "'depend' clause requires the 'targetsync' interop type"
H2DD7E54EBF24: "'depend' 子句需要 'targetsync' 交換類型"
# "'deprecated' attribute on anonymous namespace ignored"
HE49B32CE23AF: "匿名命名空間上的 'deprecated' 屬性被忽略"
# "'device_type(%0)' does not match previously specified 'device_type(%1)' for the same declaration"
HDE923438E688: "'device_type(%0)' 與同一宣告先前指定的 'device_type(%1)' 不符"
# "'diagnose_if' is a clang extension"
H6ABE610AE6BE: "'diagnose_if' 是 clang 擴充功能"
# "'dllexport' attribute ignored on explicit instantiation definition"
H5570C9EC211D: "匿名命名空間上的 'dllexport' 屬性被忽略"
# "'enable_if' is a clang extension"
HF8D51A54A3FE: "'enable_if' 是 clang 的擴充功能"
# "'explicit' can only appear on non-static member functions"
H4ED84C1B6695: "'explicit' 只能出現在非靜態成員函數上"
# "'explicit' can only be applied to a constructor or conversion function"
H31AF261810E7: "'explicit' 只能套用於建構函數或轉換函數"
# "'explicit' can only be specified inside the class definition"
H4954093357D9: "'explicit' 只能在類別定義內指定"
# "'explicit' is not permitted on top-level modules"
HDAE06689A152: "'explicit' 不允許用於頂層模組"
# "'extern' variable has an initializer"
HB91B40E25B4C: "'extern' 變數具有初始化式"
# "'extern' variable may not be referenced by '%0' clause on an OpenACC 'declare' directive"
H270234BE5B42: "'extern' 變數不能在 OpenACC 'declare' 指令的 '%0' 子句中被引用"
# "'flush' directive with memory order clause '%0' cannot have the list"
HC2158D6851BB: "具有記憶體順序子句 '%0' 的 'flush' 指令不能包含清單"
# "'for co_await' belongs to CoroutineTS instead of C++20, which is deprecated"
H6DA54D0F5428: "'for co_await' 屬於 CoroutineTS 而非 C++20，此已棄用"
# "'friend' must appear first in a non-function declaration"
HEBE4422274B2: "'friend' 必須出現在非函數宣告的最前面"
# "'friend' used outside of class"
HABD952B07FCB: "在類別外部使用 'friend'"
# "'gnu_inline' attribute requires function to be marked 'inline', attribute ignored"
HEDCF2C7F36F0: "'gnu_inline' 屬性需要函數標記為 'inline'，屬性被忽略"
# "'gnu_inline' attribute without 'extern' in C++ treated as externally available, this changed in Clang 10"
H021467CD0886: "C++ 中未指定 'extern' 的 'gnu_inline' 屬性會被視為外部可用，此行為在 Clang 10 中有所變更"
# "'hybrid_patchable' is ignored on functions without external linkage"
H0ADF7398ED3A: "'hybrid_patchable' 會被忽略於無外部連結性的函數"
# "'inline' can only appear on functions%select{| and non-local variables}0"
H89E78E1738F9: "'inline' 只能出現在函數 %select{| 和非局部變數}0 上"
# "'inscan' modifier can be used only in 'omp for', 'omp simd', 'omp for simd', 'omp parallel for', or 'omp parallel for simd' directive"
HD994FA838907: "'inscan' 修飾詞只能用在 'omp for'、'omp simd'、'omp for simd'、'omp parallel for' 或 'omp parallel for simd' 指令中"
# "'internal_linkage' attribute on a non-static local variable is ignored"
H66A8BF53EA8F: "在非靜態局部變數上使用的 'internal_linkage' 屬性被忽略"
# "'lifetime_capture_by' argument references itself"
H3627CC1FAD24: "'lifetime_capture_by' 參數引用自身"
# "'lifetime_capture_by' argument references unavailable implicit 'this'"
HCCCF5641FC93: "'lifetime_capture_by' 參數引用不可用的隱式 'this'"
# "'lifetime_capture_by' attribute argument %0 is not a known function parameter; must be a function parameter, 'this', 'global' or 'unknown'"
H3A8F776F3ADB: "'lifetime_capture_by' 屬性參數 %0 不是已知的函式參數；必須是函式參數、'this'、'global' 或 'unknown'"
# "'lifetime_capture_by' attribute specifies no capturing entity"
HA61E4C8D2E68: "'lifetimebound' 屬性未指定任何捕獲實體"
# "'lifetimebound' attribute cannot be applied to a %select{constructor|destructor}0"
H67DD72C3F644: "'lifetimebound' 屬性不能套用在 %select{建構函式|析構函式}0"
# "'lifetimebound' attribute cannot be applied to a parameter of a function that returns void; did you mean 'lifetime_capture_by(X)'"
H7AF0F9960FBE: "'lifetimebound' 屬性不能套用在傳回 void 的函式參數；是否要改為 'lifetime_capture_by(X)'"
# "'lifetimebound' attribute cannot be applied to an implicit object parameter of a function that returns void; did you mean 'lifetime_capture_by(X)'"
H246C1F79D057: "'lifetimebound' 屬性不能套用在傳回 void 的隱含物件參數；是否要改為 'lifetime_capture_by(X)'"
# "'lifetimebound' attribute cannot be applied; %select{non-|static |explicit object }0member function has no implicit object parameter"
H4EDB6AB20113: "'lifetimebound' 屬性無法套用；%select{非成員|靜態|明確物件 }0 成員函式沒有隱含物件參數"
# "'linear' clause cannot be specified along with 'ordered' clause with a parameter"
H20416EEA599F: "'linear' 子句不能與帶參數的 'ordered' 子句共同指定"
# "'long long' is a C++11 extension"
HC63DB1FBE144: "'long long' 是 C++11 的擴充功能"
# "'long long' is an extension when C99 mode is not enabled"
H90F12D1B1D4D: "'long long' 在未啟用 C99 模式時是擴充功能"
# "'long long' is incompatible with C++98"
H0DAB29466D2C: "'long long' 與 C++98 不相容"
# "'main' cannot be a multiversioned function"
HAFF8B40A53DE: "'main' 不能是多版本函式"
# "'main' is not allowed to be declared %select{constexpr|consteval}0"
H13F25D825A17: "'main' 不允許被宣告為 %select{constexpr|consteval}0"
# "'main' is not allowed to be declared _Noreturn"
HE455B9A59591: "'main' 不允許被宣告為 _Noreturn"
# "'main' is not allowed to be declared inline"
HBC0A4A59C65E: "'main' 不允許被宣告為 inline"
# "'main' is not allowed to be declared static"
HB1B95BDA01B7: "'main' 不允許被宣告為 static"
# "'main' is not allowed to be declared variadic"
HD3EE247E6A72: "'main' 不允許被宣告為可變參數函式"
# "'main' is not allowed to be deleted"
HB0C6AFB93EDB: "'main' 不允許被刪除"
# "'main' must return 'int'"
HD54CCE2AF684: "'main' 必須傳回 'int'"
# '\'main\' should not be \'extern "%select{C|C++}0"\''
H19102C631788: '\'main\' 不應被宣告為 \'extern "%select{C|C++}0"\''
# "'main' should not be declared static"
H9A6B59304912: "'main' 不應被宣告為 static"
# "'malloc' argument %0 must take a pointer type as its first argument"
HEF17CC57A675: "'malloc' 的第 %0 個參數必須接受指標類型作為第一個參數"
# "'malloc' argument %select{for deallocator |%1 |%1 }0is not a %select{||single }0function"
HC684E8204794: "'malloc' %select{deallocater 的參數|第 %1 個參數|第 %1 個參數}0 不是 %select{||單一 }0 函數"
# "'malloc' argument '%0' refers to non-pointer type %1 of %2"
HFD06C554D4E6: "'malloc' 的參數 '%0' 指向 %2 的非指標類型 %1"
# "'mig_server_routine' attribute only applies to routines that return a kern_return_t"
HF1C5C16FC7E6: "'mig_server_routine' 屬性僅適用於返回 kern_return_t 類型的函數"
# "'module' declaration found while building header unit"
HA86B9DC6C734: "在建構標頭單元時發現 'module' 宣告"
# "'module' declaration found while building module from module map"
H880BB7F53078: "在根據模組地圖建構模組時發現 'module' 宣告"
# "'module;' introducing a global module fragment can appear only at the start of the translation unit"
H617DC2BE71CE: "引進全域模組片段的 'module;' 只能出現在翻譯單位的開頭"
# "'musttail' attribute for this call is impossible because %select{long calls cannot be tail called on PPC|indirect calls cannot be tail called on PPC|external calls cannot be tail called on PPC}0"
H14240DA28AAD: "'musttail' 屬性在此呼叫中無法使用，因為 %select{PPC架構上無法對長呼叫進行tail called|PPC架構上無法對間接呼叫進行tail called|PPC架構上無法對外部呼叫進行tail called}0"
# "'musttail' attribute is not supported on AIX"
H92717FE13CEF: "'musttail' 屬性在 AIX 上不受支援"
# "'mutable' and 'const' cannot be mixed"
H6CE01BCA1797: "'mutable' 和 'const' 不能混合使用"
# "'mutable' can only be applied to member variables"
HC1CD8F78BDE1: "'mutable' 只能用於成員變數"
# "'mutable' cannot be applied to functions"
H9B6452717014: "'mutable' 不能用於函數"
# "'mutable' cannot be applied to references"
H7CCDA0B2596A: "'mutable' 不能用於引用"
# "'mutable' on a reference type is a Microsoft extension"
H6E975C04AF4E: "在引用類型上使用 'mutable' 是 Microsoft 扩展"
# "'mutexinoutset' modifier not allowed in 'depend' clause on 'taskwait' directive"
H54D9DFD0A59D: "'mutexinoutset' 修飾符在 'taskwait' 指令的 'depend' 子句中不可用"
# "'new' cannot allocate an array of %0 with no explicit ownership"
H01CEEA4215DD: "'new' 不能分配一個不具顯式所有權的 %0 類型陣列"
# "'new' cannot allocate object of variably modified type %0"
HB68377C1CB34: "'new' 不能分配變數長度類型 %0 的物件"
# "'new' cannot allocate objects of type %0 in address space '%1'"
H8F2EE8209986: "'new' 無法分配地址空間 '%1' 中的類型 %0"
# "'new' expression with placement arguments refers to non-placement 'operator delete'"
H9A938FDFCB36: '帶有置位參數的new運算式引用了非置位的operator delete'
# "'nocf_check' attribute ignored; use -fcf-protection to enable the attribute"
HCD98AFA044EC: "'nocf_check' 屬性被忽略；請使用-fcf-protection來啟用該屬性"
# "'noderef' can only be used on an array or pointer type"
H265BDBEEC1EC: "'noderef' 只能用於陣列或指標類型"
# "'noexcept' can only be used in a compound requirement (with '{' '}' around the expression)"
H88CA64B4E3F6: "'noexcept' 只能在複合需求中使用（需用{}包圍表達式）"
# "'nonmonotonic' modifier can only be specified with 'dynamic' or 'guided' schedule kind"
H60F2BCD19874: "'nonmonotonic' 修飾符只能與 'dynamic' 或 'guided' 類型的schedule一起使用"
# "'nonnull' attribute applied to function with no pointer arguments"
H0D4CBB499E30: "'nonnull' 屬性應用於無指標參數的函數"
# "'nonnull' attribute when used on parameters takes no arguments"
H8544A5398585: "在參數上使用的 'nonnull' 屬性不需要參數"
# "'nothrow' attribute conflicts with exception specification; attribute ignored"
HA43C7748DBD1: "'nothrow' 屬性與例外規格衝突；屬性被忽略"
# "'nowait' clause is here"
H4C9748BD1A0B: "'nowait' 子句在此處"
# "'nullptr' is a C23 extension"
H0CCA94E13259: "'nullptr' 是C23的擴充功能"
# "'nullptr' is incompatible with C++98"
HA3F1CF3D3055: "'nullptr' 與C++98不相容"
# "'objc_bridge(id)' is only allowed on structs and typedefs of void pointers"
H19339C3149E3: "'objc_bridge(id)' 只能用於void指標的結構或typedef"
# "'objc_class_stub' attribute cannot be specified on a class that does not have the 'objc_subclassing_restricted' attribute"
H131E98846FD9: "'objc_class_stub' 屬性只能用於具有 'objc_subclassing_restricted' 屬性的類別"
# "'objc_designated_initializer' attribute only applies to init methods of interface or class extension declarations"
H0C4330D28BB6: "'objc_designated_initializer' 屬性僅適用於界面或類別擴展宣告的init方法"
# "'objc_direct' attribute cannot be applied to %select{methods|properties}0 declared in an Objective-C protocol"
H0E0D013ED449: "'objc_direct' 屬性不能應用於在Objective-C協定中宣告的%select{方法|屬性}0"
# "'objc_externally_retained' can only be applied to local variables %select{of retainable type|with strong ownership}0"
H863E7A12B731: "屬性 'objc_externally_retained' 只能用於%select{可保留類型的|具有強所有權的}0本地變數"
# "'objc_independent_class' attribute may be put on Objective-C object pointer type only; attribute is ignored"
H917C3A1684AC: "'objc_independent_class' 屬性只能用於Objective-C物件指標類型；屬性被忽略"
# "'objc_independent_class' attribute may be put on a typedef only; attribute is ignored"
HCF5FB9401D67: "屬性 'objc_independent_class' 只能放在 typedef 上；屬性被忽略"
# "'omp_interop_t' must be defined when 'append_args' clause is used; include <omp.h>"
H584E24086261: "使用 'append_args' 子句時，必須定義 'omp_interop_t'；包含 <omp.h>"
# "'ompx_attribute' clause only allows 'amdgpu_flat_work_group_size', 'amdgpu_waves_per_eu', and 'launch_bounds'; %0 is ignored"
H15379B8D06F4: "'ompx_attribute' 子句僅允許 'amdgpu_flat_work_group_size'、'amdgpu_waves_per_eu' 和 'launch_bounds'；%0 被忽略"
# "'ompx_bare' clauses requires explicit grid size via 'num_teams' and 'thread_limit' clauses"
HC78DCADADB1C: "'omp_bare' 子句需要通過 'num_teams' 和 'thread_limit' 子句明確指定網格大小"
# "'operator new' provided by %0 is not usable with the function signature of %1"
HC75862C47BD1: "由 %0 提供的 'operator new' 無法與 %1 的函數簽章相容"
# "'operator->' declared here produces an object of type %0"
HC1D7E6DA4A9D: "在此處宣告的 'operator->' 會產生類型為 %0 的物件"
# "'ordered' clause with a parameter cannot be specified in '#pragma omp %0' directive"
HE291A06801DB: "在 '#pragma omp %0' 指令中，不能指定帶有參數的 'ordered' 子句"
# "'ordered' clause%select{| with specified parameter}0"
H337028DA61A4: "'ordered' 子句 %select{| 帶有指定參數}0"
# "'ordered' directive %select{without any clauses|with 'threads' clause}0 cannot be closely nested inside ordered region with specified parameter"
HB16FD1003ED0: "'ordered' 指令 %select{未指定任何子句|具有 'threads' 子句}0 不能緊密嵌套在帶有指定參數的 ordered 區域內"
# "'ordered' directive with '%0' clause cannot be closely nested inside ordered region without specified parameter"
H1845D44BB3DE: "帶有 '%0' 子句的 'ordered' 指令不能緊密嵌套在未指定參數的 ordered 區域內"
# "'overloadable' function %0 must have a prototype"
HA041210B9619: '重載函數 %0 必須有原型宣告'
# "'ownership_returns' attribute index does not match; here it is %0"
H1C0451B398DB: "'ownership_returns' 屬性索引不匹配；這裡是 %0"
# "'ownership_returns' attribute only applies to functions that return a pointer"
HE96B6120100D: "'ownership_returns' 屬性僅適用於返回指標的函數"
# "'ownership_takes' attribute class does not match; here it is '%0'"
H2E44647C4A59: "'ownership_takes' 屬性類別不匹配；這裡是 '%0'"
# "'packed' attribute was ignored on bit-fields with single-byte alignment in older versions of GCC and Clang"
H8DB05E11AD0A: "在舊版 GCC 和 Clang 中，若位域的對齊為單一字節，則 'packed' 屬性會被忽略"
# "'reduction' clause cannot be used with 'nogroup' clause"
H186A32581806: "'reduction' 子句不能與 'nogroup' 子句一起使用"
# "'reduction' clause not allowed with '#pragma omp loop bind(teams)'"
H4981CB6A6643: "'reduction' 子句不允許與 '#pragma omp loop bind(teams)' 一同使用"
# "'reduction' clause with 'inscan' modifier is used here"
HE04EBCC11985: "'reduction' 子句在此處使用帶有 'inscan' 修飾符"
# "'reduction' clause with 'task' modifier allowed only on non-simd parallel or worksharing constructs"
HD0FEE7231060: "'reduction' 子句加上 'task' 修飾詞只能用在非simd平行或工作共享結構中"
# "'register' storage class specifier is deprecated and incompatible with C++17"
HDBC08F071224: "'register' 存儲類別指定詞已棄用且與C++17不相容"
# "'register' storage specifier on @catch parameter will be ignored"
H4232960B8CCE: "@catch參數上的 'register' 存儲指定詞將被忽略"
# "'regparm' is not valid on this platform"
H1E534F14C852: "'regparm' 在此平台上無效"
# "'regparm' parameter must be between 0 and %0 inclusive"
H63349C70781C: "'regparm' 參數必須介於 0 與 %0 之間"
# "'reinterpret_cast' %select{from|to}3 class %0 %select{to|from}3 its %select{virtual base|base at non-zero offset}2 %1 behaves differently from 'static_cast'"
HF87527FE7FBB: "'reinterpret_cast' %select{從|到}3類 %0 %select{到|從}3其%select{虛基|非零偏移基類}2 %1 的行為與 'static_cast' 不同"
# "'require_constant_initialization' attribute added after initialization of variable"
HCCF005312D01: "在變數初始化後新增 'require_constant_initialization' 屬性"
# "'restrict' qualifier on an array of pointers is a C23 extension"
H831A2BF01322: "指標陣列上的 'restrict' 限定詞是C23擴展"
# "'restrict' qualifier on an array of pointers is incompatible with C standards before C23"
H7AB582A89AF4: "指標陣列上的 'restrict' 限定詞與C23前的標準不相容"
# "'return' will never be executed"
HF9D8B2478204: "'return' 將永遠不會執行"
# "'sealed' keyword is a Microsoft extension"
H2371564F3064: "'sealed' 關鍵字是Microsoft擴展"
# "'selectany' can only be applied to data items with external linkage"
H0D95115281D5: "'selectany' 只能套用在具有外部連結的資料項目"
# "'sentinel' attribute only supported for variadic %select{functions|blocks}0"
H0C7CDE5CC83E: "'sentinel' 屬性僅支援可變參數%select{函數|區塊}0"
# "'sentinel' attribute requires named arguments"
HB4DB8DB54C63: "'sentinel' 屬性需要命名參數"
# "'sentinel' parameter 1 less than zero"
HE854964454A6: "'sentinel' 參數 1 小於零"
# "'sentinel' parameter 2 not 0 or 1"
H99541E948450: "'sentinel' 參數 2 不是 0 或 1"
# "'size' argument to bzero is '0'"
H50A840FAEA15: "bzero的 'size' 參數為 '0'"
# "'size_t' suffix for literals is a C++23 extension"
HE55B1E186F37: "'size_t' 字尾符號是C++23擴展"
# "'size_t' suffix for literals is a C++23 feature"
HFE4E8B889F8C: "'size_t' 字尾符號是C++23功能"
# "'size_t' suffix for literals is incompatible with C++ standards before C++23"
H01C26A9D5D7B: "'size_t' 字面值的後綴與C++23之前的標準不相容"
# "'static' can only be specified inside the class definition"
HC2C3574A2AC5: "'static' 只能在類定義內部指定"
# "'static' function %0 declared in header file should be declared 'static inline'"
HAC6B8325923D: "在標頭檔中宣告的靜態函數 %0 應宣告為 'static inline'"
# "'static' may not be used with an unspecified variable length array size"
H8C886B8B17D3: "未指定的可變長度陣列大小不能與 'static' 一起使用"
# "'static' may not be used without an array size"
H3CD973765C05: "使用 'static' 時必須指定陣列大小"
# "'static' member function %0 overrides a virtual function in a base class"
H917973A36E2C: '靜態成員函數 %0 覆寫基類中的虛函數'
# "'static_assert' declarations are incompatible with C++98"
HEBCFD6945359: "'static_assert' 宣告與C++98不相容"
# "'static_assert' with a user-generated message is a C++26 extension"
HFCA41F0C6554: "帶有使用者產生的訊息的 'static_assert' 是C++26的擴充功能"
# "'static_assert' with a user-generated message is incompatible with C++ standards before C++26"
H71F257CCE8FF: "帶有使用者產生的訊息的 'static_assert' 與C++26之前的標準不相容"
# "'static_assert' with no message is a C++17 extension"
H89070CD2F991: "無訊息的 'static_assert' 是C++17的擴充功能"
# "'static_assert' with no message is incompatible with C++ standards before C++17"
HFE8F37E6AE5C: "無訊息的 'static_assert' 與C++17之前的標準不相容"
# "'std::allocator<...>::deallocate' used to delete a null pointer"
HF2B279909DBC: "使用 'std::allocator<...>::deallocate' 刪除空指標"
# "'std::source_location::__impl' must be standard-layout and have only two 'const char *' fields '_M_file_name' and '_M_function_name', and two integral fields '_M_line' and '_M_column'"
HCA27D3915F0B: "'std::source_location::__impl' 必須是標準佈局類別，且僅有兩個 'const char *' 型別的欄位 '_M_file_name' 和 '_M_function_name'，以及兩個整數型別的欄位 '_M_line' 和 '_M_column'"
# "'std::source_location::__impl' was not found; it must be defined before '__builtin_source_location' is called"
HD0F806FB73A8: "未找到 'std::source_location::__impl'；它必須在呼叫 '__builtin_source_location' 之前被定義"
# "'super' is only valid in a method body"
HB06D73D4C0E7: "'super' 只能在方法主體中使用"
# "'swift_async' completion handler parameter must have block type returning 'void', type here is %0"
H9874890FB098: "'swift_async' 完成處理器參數必須是回傳 'type' 的區塊類型，這裡的類型是 %0"
# "'swift_error_result' parameter must follow 'swift_context' parameter"
HFA5F4F66F83B: "'swift_error_result' 參數必須跟在 'swift_context' 參數之後"
# "'swift_indirect_result' parameters must be first parameters of function"
H624EF03C7676: "'swift_indirect_result' 參數必須是函數的第一個參數"
# "'switch' missing 'default' label"
H855B85E209CE: "'switch' 缺少 'default' 標籤"
# "'sycl_kernel' attribute only applies to a function template with at least two template parameters"
H5AFFA7408711: "'sycl_kernel' 屬性只能套用在具有至少兩個模板參數的函數模板上"
# "'sycl_kernel_entry_point' attribute cannot be added to a function after the function is defined"
H018E12D5A5B2: "在函數定義後不能為其添加 'sycl_kernel_entry_point' 屬性"
# "'sycl_kernel_entry_point' attribute cannot be applied to a %select{non-static member function|variadic function|deleted function|defaulted function|constexpr function|consteval function|function declared with the 'noreturn' attribute|coroutine|function defined with a function try block}0"
H86CAEB999295: "'sycl_kernel_entry_point' 屬性不能套用在%select{非靜態成員函數|可變參數函數|已刪除函數|預設函數|constexpr函數|consteval函數|以 'noreturn' 屬性宣告的函數|協程|使用函數試擲區塊定義的函數}0"
# "'sycl_kernel_entry_point' attribute only applies to functions with a 'void' return type"
H99CA3F9B2DC2: "'sycl_kernel_entry_point' 屬性只能套用在回傳類型為 'void' 的函數"
# "'sycl_kernel_entry_point' attribute only applies to functions with a non-deduced 'void' return type"
H14251E8B39CA: "'sycl_kernel_entry_point' 屬性只能套用在具有非推導 'void' 回傳類型的函數"
# "'sycl_kernel_entry_point' kernel name argument conflicts with a previous declaration"
HFAE6DB6B8BBB: "'sycl_kernel_entry_point' 核心名稱參數與先前宣告衝突"
# "'sycl_kernel_entry_point' kernel name argument does not match prior declaration%diff{: $ vs $|}0,1"
H6714A3237372: "'sycl_kernel_entry_point' 核心名稱參數與先前宣告不一致%diff{： $ 對 $|}1,0"
# "'target_clones' attribute does not match previous declaration"
HBD2CF88C376B: "'target_clones' 屬性與先前宣告不符"
# "'target_clones' multiversioning requires a default target"
HCC23909A82CE: "'target_clones' 多版本化需要預設目標"
# "'template' cannot be used after a declarative nested name specifier"
H7173607CA62C: "'template' 不能用在聲明式嵌套名稱指定符之後"
# "'template' keyword not permitted after 'using' keyword"
H026D09D01933: "'template' 關鍵字不能出現在 'using' 關鍵字後面"
# "'template' keyword not permitted here"
HF55CDE212145: "'template' 關鍵字在此處不允許"
# "'template' keyword not permitted in destructor name"
H67CEB40C2F65: "'template' 關鍵字不能出現在析構函數名稱中"
# "'template' keyword outside of a template"
H5580CDE2DB12: "'template' 關鍵字不在模板上下文中"
# "'template<>' header not required for explicitly-specialized class %0 declared here"
H3FF5BAF37ECE: "在此處顯式專門化的類別 %0 已宣告，不需要 'template<>' 頭部"
# "'this' argument to member function %0 has type %1, but function is not marked %select{const|restrict|const or restrict|volatile|const or volatile|volatile or restrict|const, volatile, or restrict}2"
HB5D291C13072: "成員函數 %0 的 'this' 參數類型為 %1，但該函數未標示 %select{const|restrict|const 或 restrict|volatile|const 或 volatile|volatile 或 restrict|const、volatile 或 restrict}2"
# "'this' argument to member function %0 is an %select{lvalue|rvalue}1, but function has %select{non-const lvalue|rvalue}2 ref-qualifier"
H0AF4BFFD004C: "成員函數 %0 的 'this' 參數是 %select{lvalue|rvalue}1，但函數具有%select{非 const lvalue|rvalue}2 型別限定符"
# "'this' cannot be %select{implicitly |}0captured in this context"
H0697D44E3441: "'this' 在此語境中無法%select{隱式 |}0 被捕獲"
# "'this' cannot be captured by reference"
H13B6762030CD: "'this' 不能以引用形式被捕獲"
# "'this' cannot be%select{| implicitly}0 used in a static member function declaration"
H4C9AC15A6831: "'this' 指標不能在靜態成員函數宣告中 %select{| 隱式}0使用"
# "'this' pointer cannot be null in well-defined C++ code; comparison may be assumed to always evaluate to %select{true|false}0"
HC979F6DEC864: "'this' 指標在符合C++語法的程式中不能為空；比較可能被假設始終評估為 %select{true|false}0"
# "'this' pointer cannot be null in well-defined C++ code; pointer may be assumed to always convert to true"
HE4633A40CE28: "'this' 指標在符合C++語法的程式中不能為空；指標可能被假設始終轉換為 true"
# "'this' pointer references not allowed in naked functions"
H95FED6FF2C73: "在裸函數（naked functions）中不允许引用 'this' 指標"
# "'trivial_abi' cannot be applied to %0"
H39CEA0BB8E5A: "'trivial_abi' 無法應用於 %0"
# "'trivial_abi' is disallowed on %0 because %select{its copy constructors and move constructors are all deleted|it is polymorphic|it has a base of a non-trivial class type|it has a virtual base|it has a __weak field|it has a field of a non-trivial class type}1"
HD222FF73C208: "'trivial_abi' 因以下原因不允許用於 %0：%select{其拷貝建構函數和移動建構函數都被刪除|它是多態類|它有非純粹類型的基類|它有虛基類|它有__weak成員|它有非純粹類型的成員}1"
# "'true' is not defined, evaluates to 0"
HEC6C8880A6A3: "'true' 未定義，評估為 0"
# "'type_tag_for_datatype' attribute requires the initializer to be an %select{integer|integral}0 constant expression"
H2191B1B324E8: "'type_tag_for_datatype' 屬性需要初始值為 %select{整數|integral}0 常數運算式"
# "'type_tag_for_datatype' attribute requires the initializer to be an %select{integer|integral}0 constant expression that can be represented by a 64 bit integer"
HD8F7C3D572F8: "'type_tag_for_datatype' 屬性需要初始值為 %select{整數|integral}0 常數運算式，該運算式可用 64 位整數表示"
# "'typeid' of incomplete type %0"
H9D618623D4E9: "不完整型別 %0 的 'typeid'"
# "'typeid' of variably modified type %0"
HB7FBFC93B3FA: "可變長度型別 %0 的 'typeid'"
# "'typename' is redundant; base classes are implicitly types"
HD8EB6D904937: "'typename' 是冗餘的；基類默認為型別"
# "'typename' keyword used on a non-type"
HEFF0F4A3C4F6: "'typename' 關鍵字用於非型別"
# "'typename' outside of a template is a C++11 extension"
H2C5188CF8D58: "在模板外使用 'typename' 是 C++11 的擴充功能"
# "'typename' outside of a template is incompatible with C++98"
H89322C630BA2: "在模板外使用 'typename' 與 C++98 不相容"
# "'unavailable' availability overrides all other availability information"
H321E5EA6571D: "'unavailable' 可用性覆寫所有其他可用性資訊"
# "'using namespace' is not allowed in classes"
H133BFD711C94: "在類別中不允许使用 'using namespace'"
# "'using_if_exists' attribute cannot be applied to an inheriting constructor"
H551D8C76B087: "'using_if_exists' 屬性不能應用於繼承建構函數"
# "'va_start' cannot be used in a captured statement"
H7AC0FC921988: "在捕獲語句中不能使用 '%va_start'"
# "'va_start' cannot be used outside a function"
HFCBDF5268E7D: "'va_start' 只能在函數內部使用"
# "'va_start' used in %select{System V|Win64}0 ABI function"
HCA2FE8C64692: "'va_start' 在 %select{System V|Win64}0 ABI 函數中使用"
# "'va_start' used in function with fixed args"
HDCEB40407EDC: "'va_start' 在固定參數函數中使用"
# "'vec_step' requires built-in scalar or vector type, %0 invalid"
H2D0A081561E0: "'vec_step' 需要內建純量或向量類型，%0 無效"
# "'virtual' can only appear on non-static member functions"
HB1449ED6BD56: "'virtual' 只能出現在非靜態成員函數上"
# "'virtual' can only be specified inside the class definition"
HC2C042A27D12: "'virtual' 只能指定在類別定義內部"
# "'virtual' cannot be specified on member function templates"
H345B16C9EDA3: "'virtual' 不能用在成員函數模板上"
# "'void' as parameter must not have type qualifiers"
H3B7FE1A42F0E: "'void' 作為參數時不能有類型修飾符"
# "'void' must be the first and only parameter if specified"
H7DDAB71DFE28: "'void' 指定時必須是第一個也是唯一的參數"
# "'||' of a value and its negation always evaluates to true"
H067D990351EF: "'||' 運算子的值與其反運算結果總為true"
# "'~' in destructor name should be after nested name specifier"
H85ED3FE9838A: "析構函數名稱中的 '~' 應位於嵌套名稱限定符之後"
# "(Deprecated) Controls whether '-Winvalid-gnu-asm-cast' defaults to an error or a warning"
HBE7A04BC29B9: "(已棄用) 控制 '-Winvalid-gnu-asm-cast' 預設是否為錯誤或警告"
# "(For new pass manager) 'per-pass': one report for each pass; 'per-pass-run': one report for each pass invocation"
H0C49717D08C4: "(新管線管理器) 'per-pass'：每個Pass一則報告；'per-pass-run'：每次Pass執行一則報告"
# '(integrated-as) Emit an object file which can be used with an incremental linker'
HC13894BE0052: '(integrated-as) 產生可與增量連結器搭配使用的物件檔'
# '(integrated-as) Emit an object file which cannot be used with an incremental linker'
H902BD058678C: '(integrated-as) 產生不可與增量連結器搭配使用的物件檔'
# '(integrated-as) Relax all machine instructions'
H523BAD847EDC: '(integrated-as) 對所有機器指令進行鬆弛優化'
# "(skipping %0 'operator->'%s0 in backtrace)"
H3980AA6C4367: "(跳過 %0 'operator->'%s0 在回溯路徑)"
# '(skipping %0 call%s0 in backtrace; use -fconstexpr-backtrace-limit=0 to see all)'
HD7D8BC5DDF54: '(略過 %0 個回溯呼叫%s0；使用 -fconstexpr-backtrace-limit=0 顯示所有)'
# '(skipping %0 context%s0 in backtrace; use -ftemplate-backtrace-limit=0 to see all)'
H1BB10F671BF7: '(略過 %0 個範型回溯上下文%s0；使用 -ftemplate-backtrace-limit=0 顯示所有)'
# '*no default*'
H01EF8BE8DE07: '*無預設值*'
# '--rtlib=libgcc requires --unwindlib=libgcc'
HED8A5F89C398: '--rtlib=libgcc 需搭配 --unwindlib=libgcc'
# '-E or -x required when input is from standard input'
H5AC04D68943E: '輸入來自標準輸入時必須指定 -E 或 -x'
# '-O4 is equivalent to -O3'
H0B5239D5C711: '-O4 等同於 -O3'
# '-Wa,--allow-experimental-crel must be specified to use -Wa,--crel. CREL is experimental and uses a non-standard section type code'
HB2A451FA1760: '-Wa,--allow-experimental-crel 必須搭配使用才能使用 -Wa,--crel。CREL 為實驗性功能且使用非常規段類型代碼'
# '-dealloc is being overridden in a category'
H75DBC0C062A1: '-dealloc 方法在分類中被覆寫'
# '-dependency-file requires at least one -MT or -MQ option'
HF99E1B6F31F8: '-dependency-file 需至少指定一個 -MT 或 -MQ 選項'
# '-emit-llvm cannot be used when linking'
H8745DC614FEB: '連結階段無法使用 -emit-llvm'
# '-fdelayed-template-parsing is deprecated after C++20'
HD52CE72E55C9: '-fdelayed-template-parsing 已在 C++20 後棄用'
# '-fembed-bitcode is not supported on versions of iOS prior to 6.0'
HD9B9277DB1F5: '-fembed-bitcode 不支援 iOS 6.0 之前的版本'
# '-fexperimental-omit-vtable-rtti call only be used with -fno-rtti'
H27AC8E91BEE0: '-fexperimental-omit-vtable-rtti 需搭配 -fno-rtti 使用'
# "-fglobal-isel support for the '%0' architecture is incomplete"
HB8576FBD6C6A: "--fglobal-isel 對 '%0' 架構支援不完整"
# '-fglobal-isel support is incomplete for this architecture at the current optimization level'
HD08F381A1C6F: '-fglobal-isel 對此架構在目前優化等級的支援不完整'
# '-fjmc works only for ELF; option ignored'
H862E3BB749F5: '-fjmc 僅適用於 ELF；此選項將被忽略'
# '-fobjc-arc is not supported on platforms using the legacy runtime'
HE6B9338AE9F6: '-fobjc-arc 不支援使用舊型運行時的平台'
# '-fobjc-arc is not supported on versions of OS X prior to 10.6'
H0AF526E18958: '-fobjc-arc 不支援 macOS 10.6 之前的版本'
# '-fobjc-weak is not supported in Objective-C garbage collection'
H7AD62E69E380: '-fobjc-weak 不支援 Objective-C 垃圾回收機制'
# '-fobjc-weak is not supported on the current deployment target'
H062C1F6DCD65: '-fobjc-weak 在目前的部署目標上不受支援'
# '-fsanitize-address-field-padding applied to %0'
H3C21F4C44A7E: '已對 %0 應用 -fsanitize-address-field-padding'
# '-fsanitize-address-field-padding ignored for %0 because it %select{is not C++|is packed|is a union|is trivially copyable|has trivial destructor|is standard layout|is in a ignorelisted file|is ignorelisted}1'
H6C62B9F141CF: '因 %0 %select{不是 C++|已封裝|是共用體|是簡單可複製的|具有簡單析構函數|是標準佈局|在忽略清單中的文件|被忽略}1，故忽略 -fsanitize-address-field-padding'
# "-ftest-module-file-extension argument '%0' is not of the required form 'blockname:major:minor:hashed:user info'"
HA7F31D279886: "-ftest-module-file-extension 參數 '%0' 需符合 'blockname:major:minor:hashed:user info' 格式"
# '-ftrivial-auto-var-init-stop-after=%0 has been enabled to limit the number of times ftrivial-auto-var-init=%1 gets applied.'
HA5103A32F2CB: '已啟用 -ftest-module-file-extension=%0 以限制 ftrivial-auto-var-init=%1 的應用次數。'
# '-mcmse is not supported for %0'
HBC9BABD34806: '%0 不支援 -mcmse'
# '-mharden-sls is only supported on armv7-a or later'
H370C2A9E9085: '-mharden-sls 僅支援 armv7-a 或更新版本'
# '-mtocdata option is ignored for %0 because %1'
HFF374450D777: '因 %1，故 %0 的 -mtocdata 選項被忽略'
# '-mxcoff-roptr is not supported with -shared'
H6DCDD2D9C271: '-mxcoff-roptr 不可與 -shared 一起使用'
# '-mxcoff-roptr is supported only with -fdata-sections'
H64F8AE7E83F9: '-mxcoff-roptr 僅支援與 -fdata-sections 一同使用'
# '-verify prefixes must start with a letter and contain only alphanumeric characters, hyphens, and underscores'
H52220FBA1BD4: '-verify 前綴需以字母開頭，且只能包含字母數字、連接號及底線'
# '.dwo output filename'
HEF051A2EFA9C: '.dwo 輸出檔名'
# '// comments are not allowed in this language'
HC63D7ED8A253: '// 備註在此語言中不可用'
# '/arm64EC has been overridden by specified target: %0; option ignored'
HD52B23C67DCF: '/arm64EC 已被指定目標 %0 覆寫；此選項被忽略'
# '32-bit targets are not supported when building for Mac Catalyst'
H2B5ECA150DDF: '為 Mac Catalyst 建置時，32 位元目標不受支援'
# '90th percentile durations'
HCFF900413C06: '90 个百分位持續時間'
# '99th percentile durations'
H401BE67F4D43: '99 个百分位持續時間'
# ": Did you mean '"
HF9464896A916: ': 您是不是要輸入 "'
# ': Not enough positional command line arguments specified!\n'
H41F31955D402: ': 未指定足夠的命令列位置參數！\n'
# ': See: '
HAF76FB12E339: ': 參考：'
# ': Too many positional arguments specified!\n'
H166421801500: ': 指定的位址參數過多！\n'
# ': Unknown '
H62CC89B124B8: ': 無效的 '
# '<INDEX FILE>'
HA21BDF8C3F73: '<索引檔>'
# '<Line Number>'
H6986C655554D: '<行號>'
# '<Line Number>.<Discriminator>'
H9B952BEB1010: '<行號.辨識碼>'
# '<Line Number>:<Column Number>'
H3D8D3ACA02BF: '<行號>:<欄位號>'
# '<Line Number>:<Column Number>.<Discriminator> (default)'
HF63B70CCE643: '<行號>:<欄位號>.<辨識碼>（預設）'
# '<PROJECT ROOT>'
H49C3DE6F4DBC: '<專案根目錄>'
# '<Search Root Directory>'
H6D7091309552: '<搜尋根目錄>'
# '<Source file>'
H6EC586CC52E3: '<來源檔案>'
# '<Source files>'
H3C1CECBB7A05: '<來源檔案列表>'
# '<arguments to be passed to front end>...'
H60720E11CCAF: '<要傳遞給前端的引數>...'
# '<base profile file>'
H8C88CD489F08: '<基本剖析檔案>'
# '<check-file>'
HAFAA29ACBEA3: '<檢查檔>'
# '<data file>'
HF37127A33D60: '<資料檔>'
# '<demangler-path>|<demangler-option>'
H7D9510852764: '<demangler路徑>|<demangler選項>'
# '<destination>'
H10F397C9B9E7: '<目標位置>'
# '<diagnostic-name>'
H48ABA509B551: '<診斷名稱>'
# '<executable>'
H194C8BA9DC59: '<可執行檔>'
# '<fdata1> [<fdata2>]...'
H31B7871CCFAC: '<fdata1> [<fdata2>]...'
# '<filename...>'
HFE7069E9DD18: '<檔案名...>'
# '<filename>'
HB80C8D77FF58: '<檔案名>'
# '<first file>'
H701B2C95DDEA: '<第一個檔案>'
# '<from>,<to> Map coverage data paths to local source file paths'
HA29C275A5689: '<來源路徑對應> 用來將覆蓋資料路徑映射到本地來源檔案路徑'
# '<gcc-tool arguments>...'
H14ED68F16708: '<gcc 工具參數>...'
# '<globals to compare>'
HDCFEFCD16186: '<要比較的全域變數>'
# '<gpu executable>'
HE3D4861759AD: '<GPU 可執行檔>'
# '<high>,<low> value indicate thresholds for high and lowcoverage watermark'
HEAFB910E7206: '<高>,<低> 值表示高和低覆蓋水印的門限'
# '<input .ll file>'
HBDCA7FE10EAC: '<輸入 .ll 檔案>'
# '<input IR file>'
H7E82294FE4BC: '<輸入 IR 檔案>'
# '<input PDB file>'
H709A48456EF7: '<輸入 PDB 檔案>'
# '<input PDB files>'
H126A4B67EBAB: '<輸入 PDB 檔案>'
# '<input YAML file>'
H7A7A324B78FC: '<輸入 YAML 檔案>'
# '<input bitcode file>'
H0498EDBECDA2: '<輸入位元碼檔案>'
# '<input bitcode files>'
H18F82A53F250: '<輸入位元碼檔案>'
# '<input bitcode>'
HC1462E145577: '<輸入位元碼>'
# '<input brainf>'
H925565A9DFB3: '<輸入 Brainf 檔案>'
# '<input file #1>'
H8FA0EC745E89: '<輸入檔案 #1>'
# '<input file #2>'
H09D1580255E0: '<輸入檔案 #2>'
# '<input file>'
HC2587AA6902C: '<輸入檔案>'
# '<input files>'
H9415F263685E: '<輸入檔案>'
# '<input kernel json file>'
HF85B67BC3727: '<輸入核心 JSON 檔案>'
# '<input llvm ll/bc file>'
HC39181A9A624: '<輸入 LLVM ll/bc 檔案>'
# '<input llvm ll/bc files>'
H41A5FA014705: '<輸入 LLVM ll/bc 檔案>'
# '<input object files or .dSYM bundles>'
HDA6B96681ECA: '<輸入物件檔或 .dSYM 套件>'
# '<input object files>'
HD219B490846E: '<輸入物件檔>'
# '<input symbols>'
H45D1386EF577: '<輸入符號>'
# '<input toy file>'
H84A385940941: '<輸入玩具檔>'
# '<input>'
H89C4EB09495F: '<輸入>'
# '<list of one or more header list files>'
H27C475BB767E: '<一個或多個標頭清單檔案的清單>'
# '<maxsize>'
H327F70512C50: '<maxsize>'
# '<module summary index>'
HC647DB885E7B: '<模組摘要索引>'
# '<opt arguments>...'
HCE37C5C87525: '<opt 參數>...'
# '<output file>'
H44B468338EC5: '<輸出檔案>'
# '<path to index file | remote:server.address>'
H55C1FC4669FC: '<索引檔的路徑 | 遠端伺服器地址>'
# '<profdata-file>'
H83762F3A8AFE: '<剖析資料檔>'
# '<program arguments>...'
H9648B06044BF: '<程式引數>...'
# '<program to run>'
H9127819F0F1D: '<要執行的程式>'
# '<safe-tool arguments>...'
H5EABB33684C4: '<安全工具引數>...'
# '<second file>'
H59A18696A728: '<第二個檔案>'
# '<source0> [... <sourceN>]'
H4D671F64A81C: '<來源 0> [... <來源N>]'
# '<source>'
HE6634DF59D09: '<來源>'
# "<start line>:<end line> - format a range of\nlines (both 1-based).\nMultiple ranges can be formatted by specifying\nseveral -lines arguments.\nCan't be used with -offset and -length.\nCan only be used with one input file."
HDEA3B9BD2A49: '<起始列>:<結束列> - 格式化一列範圍的列（兩者均以 1 為起始）。\n可指定多個 -lines 參數來格式化多個區間。\n不能與 -offset 和 -length 一同使用。\n只能用於單一輸入檔案。'
# '<symbol-file>'
H6E5CDBA6FB29: '<符號檔>'
# '<test profile file>'
H11468CAF4D7F: '<測試剖析檔>'
# '<tool arguments>...'
HF6F458922E63: '<工具引數>...'
# '<topdown|bottomup>'
H9180E4B0E8C6: '<自頂向下|自底向上>'
# '<weight>,<filename>'
HCEE927C66E78: '<權重>,<檔名>'
# '<xray fdr mode log>'
H4907FD73C66B: '<XRay FDR 模式紀錄檔>'
# '<xray log file 1>'
HB4D281AAED36: '<XRay 紀錄檔 1>'
# '<xray log file 2>'
H1C142C095FCF: '<XRay 紀錄檔 2>'
# '<xray log file>'
HE9A7E93A5C35: '<XRay 紀錄檔>'
# '<xray trace>'
HA7901FE618F5: '<XRay 追蹤>'
# '= *cannot print option value*\n'
HE274379BF9C1: '= *無法顯示選項值*\n'
# '= *unknown option value*\n'
H164C5812BA3B: '= *未知選項值*\n'
# '?: operator with omitted middle operand cannot be mangled'
H3E44EE9DABB8: '?: 運算子若省略中間操作元則無法進行函數名稱修飾'
# '@%0 must be followed by a number to form an NSNumber object'
HDF1E414372F2: '@%0 必須接著一個數字以形成 NSNumber 物件'
# "@catch parameter cannot have storage specifier '%0'"
HAEB289D52AD8: "@catch 參數不能具有儲存說明符 '%0'"
# '@catch parameter declarator cannot be qualified'
H9BAC8F95B81C: '@catch 參數宣告符不能被限定'
# '@catch parameter is not a pointer to an interface type'
HE87FCFF30D0A: '@catch 參數不是指向介面類型的指標'
# '@defs is not supported in Objective-C++'
H64B526C3172C: '@defs 不支援於 Objective-C++'
# '@implementation cannot have type parameters'
HA936A031AC88: '@implementation 不能有類型參數'
# '@implementation declaration cannot be protocol qualified'
H4CA986D1E0F8: '@implementation 宣告不能被協定限定'
# "@import of module '%0' in implementation of '%1'; use #import"
H16AC87FD7968: "在 '%1' 的實作中匯入模組 '%0'；請改用 #import"
# '@protocol is using a forward protocol declaration of %0'
H0D6847EE9BAD: '@protocol 使用了 %0 的前向協定宣告'
# '@selector expression formed with direct selector %0'
HB5C475EA47ED: '@selector 表達式以直接選擇子 %0 建構'
# '@selector expression formed with potentially direct selector %0'
H7FC0DE89B5F4: '@selector 表達式以可能為直接選擇子的 %0 建構'
# '@synchronized requires an Objective-C object type (%0 invalid)'
H4E94A0FBFD2A: '@synchronized 需要 Objective-C 物件類型（%0 無效）'
# "@synthesize not allowed in a category's implementation"
HAD49CB90931E: '@synthesize 不允許在分類的實作中使用'
# '@synthesize not allowed on a class property %0'
H37538A67AC33: '@synthesize 不允許用於類屬性 %0'
# '@throw (rethrow) used outside of a @catch block'
HAB2C03614B94: '@throw (重新拋出) 用在 @catch 區塊之外'
# '@throw requires an Objective-C object type (%0 invalid)'
HF85FCC60471E: '@throw 需要 Objective-C 物件類型（%0 無效）'
# '@try statement without a @catch and @finally clause'
H0097E9BE678E: '@try 語句缺少 @catch 和 @finally 子句'
# 'A CSV file containing (JITDylib, Function) pairs tospeculatively look up'
H27E7912AA129: '包含 (JITDylib, 函數) 對的 CSV 檔案，用於預測性查詢'
# 'A No-Op Barrier Pass'
H189EA9AAB8E2: '無操作屏障 Pass'
# 'A boolean option to show CFG dag or text with block profile counts and branch probabilities right after PGO profile annotation step. The profile counts are computed using branch probabilities from the runtime profile data and block frequency propagation algorithm. To view the raw counts from the profile, use option -pgo-view-raw-counts instead. To limit graph display to only one function, use filtering option -view-bfi-func-name.'
H1F6AD91CDAD1: '一個布林選項，用於在PGO剖面註釋步驟後顯示包含區塊剖面計數和分支概率的CFG dag或文本。這些剖面計數是通過執行階段剖面資料中的分支概率及區塊頻率傳播演算法計算得出的。若要查看剖面中的原始計數，請改用選項-pgo-view-raw-counts。若要將圖形顯示限制為僅一個函數，請使用過濾選項-view-bfi-func-name。'
# 'A boolean option to show CFG dag or text with raw profile counts from profile data. See also option -pgo-view-counts. To limit graph display to only one function, use filtering option -view-bfi-func-name.'
H84462D2AF2CA: '一個布林選項，用於顯示由剖面資料中取得原始剖面計數的CFG dag或文本。另請參閱選項-pgo-view-counts。若要將圖形顯示限制為僅一個函數，請使用過滤選項-view-bfi-func-name。'
# 'A comma-separated list of regexes to match against suffix of a header, and disable analysis if matched.'
HC652CCDF0460: '以逗號分隔的正規表示式清單，用於與標頭結尾匹配，若匹配則禁用分析。'
# 'A comma-separated list of regexes to match against suffix of a header. Only headers that match will be analyzed.'
H98978B75D13A: '以逗號分隔的正規表示式清單，用於與標頭結尾匹配。只有符合的標頭才會被分析。'
# 'A count is cold if it is below the minimum count to reach this percentile of total counts.'
H2339A8FDD5A8: '若計數低於總計數百分位所達成的最小計數，則該計數為冷計數。'
# 'A count is hot if it exceeds the minimum count to reach this percentile of total counts.'
H7D01FE9FC1EB: '若計數超過總計數百分位所達成的最小計數，則該計數為熱計數。'
# 'A debug option to add additional penalty to the computed one.'
H2D6A17BDE0D3: '調試選項，用於向計算值額外增加懲罰值。'
# 'A file containing a list of files to process, one per line.'
H3723DB39ACD6: '包含要處理的文件清單的文件，每行一個文件。'
# 'A file containing list of basic blocks to extract'
HBF68C649BA33: '包含要提取的基本區塊清單的文件'
# 'A file containing list of symbol names to preserve'
HCBA362E0A436: '包含要保留的符號名稱清單的文件'
# 'A file containing regexes of symbol names that are not expected to be updated when changing namespaces around them.'
HE689FDC11988: '包含符號名稱正規表示式清單的文件，這些符號名稱在周圍命名空間變更時不被期望更新。'
# 'A file in which to write minimized bitcode for the thin link only'
HC50A535724B5: '用於寫入薄鏈接專用最小化位元碼的文件'
# 'A fixed cold count that overrides the count derived from profile-summary-cutoff-cold'
H6BD0A927E583: '覆寫由profile-summary-cutoff-cold導出的計數的固定冷計數'
# 'A fixed hot count that overrides the count derived from profile-summary-cutoff-hot'
HDDA22CC4FF28: '覆寫由profile-summary-cutoff-hot導出的計數的固定熱計數'
# "A flag that overrides the target's expected cost for an instruction to a single constant value. Mostly useful for getting consistent testing."
HB9C94533EB20: '覆寫目標期望的指令成本為單一固定值的旗標。大多數情況下用於確保測試一致性。'
# "A flag that overrides the target's max interleave factor for scalar loops."
H8C8153E64ADB: '覆寫目標純量循環最大交織因子的旗標。'
# "A flag that overrides the target's max interleave factor for vectorized loops."
H3505D260BD96: '覆寫目標向量化循環最大交織因子的旗標。'
# "A flag that overrides the target's number of scalar registers."
HFF8F958A02D3: '覆寫目標純量寄存器數量的旗標。'
# "A flag that overrides the target's number of vector registers."
HEC99B1D21B33: '覆寫目標向量寄存器數量的旗標。'
# "A flag that overrides the target's preferred addressing mode."
H7B1AA7CE93D4: '覆寫目標最佳化存取模式的旗標。'
# 'A function is considered hot for staleness error check if its total sample count is above the specified percentile'
H652DA545BF0D: '若其總樣本數量超過指定的百分位數，則該函數將被視為陳舊性錯誤檢查中的熱函數'
# 'A function name, assumed to be global, which will be treated as the root of an interesting graph, which will be profiled independently from other similar graphs.'
H3FD0C1E415AD: '假設為全域的函數名稱，將被視為一個有趣圖的根節點，並獨立於其他類似圖形進行剖面分析。'
# 'A huge scheduling region will have maps reduced by this many nodes at a time. Defaults to HugeRegion / 2.'
HAEEA6B54FAD5: '巨大的調度區域每次將減少這麼多節點的映射。預設值為 HugeRegion / 2。'
# 'A lexical block (Function, Class, etc.).'
HC41EB530ACBA: '詞法區塊（函數、類等）。'
# "A list of mangled vtable type info names. Classes specified by the type info names and their derived ones will not be vtable-ICP'ed. Useful when the profiled types and actual types in the optimized binary could be different due to profiling limitations. Type info names are those string literals used in LLVM type metadata"
HB3A60F3783C6: '被mangled的vtable類型資訊名稱列表。由類型資訊名稱指定的類別及其衍生類別將不會被vtable-ICP化。當由於剖面限制導致剖面類型與優化後二進位檔中的實際類型不一致時，這很有用。類型資訊名稱是LLVM類型元資料中使用的字串文字'
# 'A list of symbol names to preserve'
HC033F70F7A4D: '要保留的符號名稱列表'
# "A multiplier on top of cycle savings to decide whether the savings won't justify the cost"
H6A89F885E7F6: '用以決定節省的週期是否不值得成本的週期節省乘數'
# "A string that'll be prepended to all log statements. Useful when running multiple instances on same host."
HE0B8D8E429AE: '將附加到所有日誌陳述式的字串。在相同主機上執行多個實例時很有用。'
# 'A textual description of the alias analysis pipeline for handling managed aliasing queries'
H4D54EF8DEC89: '處理托管別名查詢的別名分析管線的文本描述'
# 'A textual description of the cgscc pass pipeline inserted at the CGSCCOptimizerLate extension point into default pipelines'
HFA3CF56CCD45: '在CGSCCOptimizerLate擴展點插入到預設管線中的cgscc pass管線的文本描述'
# 'A textual description of the function pass pipeline inserted at the Peephole extension points into default pipelines'
H1744F3F7F9B4: '在Peephole擴展點插入到預設管線中的函數pass管線的文本描述'
# 'A textual description of the function pass pipeline inserted at the ScalarOptimizerLate extension point into default pipelines'
HA2E18C3D97E7: '在ScalarOptimizerLate擴展點插入到預設管線中的函數pass管線的文本描述'
# 'A textual description of the function pass pipeline inserted at the VectorizerEnd extension point into default pipelines'
HD2BE547AE303: '在VectorizerEnd擴展點插入到預設管線中的函數pass管線的文本描述'
# 'A textual description of the function pass pipeline inserted at the VectorizerStart extension point into default pipelines'
HA843C3B1B6F5: '在VectorizerStart擴展點插入到預設管線中的函數pass管線的文本描述'
# 'A textual description of the loop pass pipeline inserted at the LateLoopOptimizations extension point into default pipelines'
H081E56CD31AA: '在LateLoopOptimizations擴展點插入到預設管線中的迴圈pass管線的文本描述'
# 'A textual description of the loop pass pipeline inserted at the LoopOptimizerEnd extension point into default pipelines'
HFDB774C5E68A: '在LoopOptimizerEnd擴展點插入到預設管線中的迴圈pass管線的文本描述'
# 'A textual description of the module pass pipeline inserted at the EarlySimplification extension point into default pipelines'
HADF08723EA0B: '在EarlySimplification擴展點插入到預設管線中的module pass管線的文本描述'
# 'A textual description of the module pass pipeline inserted at the FullLinkTimeOptimizationEarly extension point into default pipelines'
HBAAC4BEB26E7: '在FullLinkTimeOptimizationEarly擴展點插入到預設管線中的module pass管線的文本描述'
# 'A textual description of the module pass pipeline inserted at the FullLinkTimeOptimizationLast extension point into default pipelines'
HC7A2BAD76212: '在FullLinkTimeOptimizationLast擴展點插入到預設管線中的module pass管線的文本描述'
# 'A textual description of the module pass pipeline inserted at the OptimizerEarly extension point into default pipelines'
H556744FF114A: '插入預設管線 OptimizerEarly 擴展點的模組 pass 管線的文字描述'
# 'A textual description of the module pass pipeline inserted at the OptimizerLast extension point into default pipelines'
H97AB14D6A40C: '插入預設管線 OptimizerLast 擴展點的模組 pass 管線的文字描述'
# 'A textual description of the module pass pipeline inserted at the PipelineStart extension point into default pipelines'
H5D27DE009EB3: '插入預設管線 PipelineStart 擴展點的模組 pass 管線的文字描述'
# 'A textual description of the pass pipeline for testing'
H07C815591653: '用於測試的 pass 管線的文字描述'
# "A textual description of the pass pipeline, same as what's passed to `opt -passes`."
HAD654D568007: 'pass 管線的文字描述，與傳遞給 `opt -passes` 的內容相同。'
# 'A textual description of the pass pipeline. To have analysis passes available before a certain pass, add "require<foo-analysis>".'
H799364B80DF3: 'pass 管線的文字描述。在某個 pass 之前需要分析 pass 時，請加入 "require<foo-analysis>"。'
# "A textual description of the pass pipeline. To have analysis passes available before a certain pass, add 'require<foo-analysis>'."
HB92573A0FB9B: "pass 管線的文字描述。在某個 pass 之前需要分析 pass 時，請加入 'require<foo-analysis>'。"
# "A textual description of the pass pipeline. To have analysis passes available before a certain pass, add 'require<foo-analysis>'. '-passes' overrides the pass pipeline (but not all effects) from specifying '--opt-level=O?' (O2 is the default) to clang-linker-wrapper.  Be sure to include the corresponding 'default<O?>' in '-passes'."
H4608F37A5D56: "pass 管線的文字描述。在某個 pass 之前需要分析 pass 時，請加入 'require<foo-analysis>'。'-passes' 覆蓋 clang-linker-wrapper 中指定 --opt-level=O?（預設 O2）的 pass 管線（但並非所有效果）。請確保在 '-passes' 中包含對應的 'default<O?>'。"
# 'A threshold controls whether an indirect call will be specialized'
HE03B79F00E10: '控制是否對間接呼叫進行特化的閾值'
# 'A threshold of live range size which may cause high compile time cost in global splitting.'
H1C364B861BCF: '可能導致全域分割編譯時間成本過高的活範圍大小閾值'
# 'A throughput of the processor floating-point arithmetic units expressed in the number of vector fused multiply-add instructions per clock cycle.'
H419471CCE4DF: '處理器浮點運算單元的吞吐量，以每時脈週期向量融合乘加指令數量表示。'
# 'A tile size for each loop dimension, filled with --polly-default-tile-size'
H104573A3D1B6: '每個迴圈維度的切割大小，填入 --polly-default-tile-size'
# 'A tile size for each loop dimension, filled with --polly-register-tile-size'
H8DEB87E7711B: '每個迴圈維度的切割大小，填入 --polly-register-tile-size'
# 'A tool to bundle several input files of the specified type <type> \nreferring to the same source file but different targets into a single \none. The resulting file can also be unbundled into different files by \nthis tool if -unbundle is provided.\n'
HD409DEDBF7C5: '將同一來源檔案但不同目標的多個輸入檔案 <type> 捆绑成單一檔案的工具。\n產生的檔案也可透過此工具加上 -unbundle 參數解捆為不同檔案。\n'
# 'A tool to detect the presence of AMDGPU devices on the system. \n\nThe tool will output each detected GPU architecture separated by a\nnewline character. If multiple GPUs of the same architecture are found\na string will be printed for each\n'
H8EA7CFE7591E: '用於檢測系統上存在的 AMDGPU 裝置的工具。\n\n此工具會輸出每個檢測到的 GPU 架構，以換行符分隔。若發現相同架構的多個 GPU，會為每個裝置輸出字串。\n'
# 'A tool to detect the presence of NVIDIA devices on the system. \n\nThe tool will output each detected GPU architecture separated by a\nnewline character. If multiple GPUs of the same architecture are found\na string will be printed for each\n'
H813C62D59D1D: '用於檢測系統上存在的 NVIDIA 裝置的工具。\n\n此工具會輸出每個檢測到的 GPU 架構，以換行符分隔。若發現相同架構的多個 GPU，會為每個裝置輸出字串。\n'
# 'A tool to format C/C++/Java/JavaScript/JSON/Objective-C/Protobuf/C# code.\n\nIf no arguments are specified, it formats the code from standard input\nand writes the result to the standard output.\nIf <file>s are given, it reformats the files. If -i is specified\ntogether with <file>s, the files are edited in-place. Otherwise, the\nresult is written to the standard output.\n'
HBD33E3D62435: '用於格式化 C/C++/Java/JavaScript/JSON/Objective-C/Protobuf/C# 程式碼的工具。\n\n若未指定參數，會從標準輸入讀取程式碼並輸出至標準輸出。\n若指定 <file>，則重新格式化這些檔案。若同時指定 -i 和 <file>，則直接修改原檔；否則輸出至標準輸出。\n'
# 'A tool to generate an optimization report from YAML optimization record files.\n'
HACA86A981224: '用於從 YAML 優化記錄檔生成優化報告的工具。\n'
# 'A utility for bundling several object files into a single binary.\nThe output binary can then be embedded into the host section table\nto create a fatbinary containing offloading code.\n'
H87DB5533D231: '將多個物件檔打包成單一二進位檔的工具。\n輸出的二進位檔可嵌入到主機區段表中，以建立包含卸載程式碼的 fatbinary。\n'
# 'A utility used to launch unit tests built for a GPU target. This is\nintended to provide an intrface simular to cross-compiling emulators\n'
H43DC1BE6F67F: '用於執行針對 GPU 目標建置的單元測試的工具。此工具旨在提供類似交叉編譯模擬器的介面\n'
# 'AArch64 A57 FP Load-Balancing'
H89C796F20C61: 'AArch64 A57 浮點載入平衡'
# 'AArch64 Branch Targets'
H9304B7C9D5D8: 'AArch64 分支目標'
# 'AArch64 CCMP Pass'
HD86F88A4A107: 'AArch64 CCMP Pass'
# 'AArch64 CondOpt Pass'
H57677EA713E0: 'AArch64 CondOpt Pass'
# 'AArch64 Conditional Branch Tuning'
H22AFD058BC38: 'AArch64 條件式分支調整'
# 'AArch64 Dead register definitions'
HDD34EEF0A0FD: 'AArch64 死暫存器定義'
# 'AArch64 Instruction Selection'
H5E1BF7DD5E18: 'AArch64 指令選擇'
# 'AArch64 Local Dynamic TLS Access Clean-up'
H60D83F556D1C: 'AArch64 本地動態 TLS 存取清理'
# 'AArch64 MI Peephole Optimization'
H5CB8022D53B1: 'AArch64 MI 小孔優化'
# 'AArch64 Pointer Authentication'
H3B42C021D00A: 'AArch64 指標驗證'
# 'AArch64 Post Coalescer Pass'
H06C95CD832E0: 'AArch64 Post Coalescer Pass'
# 'AArch64 Promote Constant Pass'
H70B4D04F132C: 'AArch64 提升常數 Pass'
# 'AArch64 SIMD instructions optimization pass'
H407FCE4191EB: 'AArch64 SIMD 指令最佳化 pass'
# 'AArch64 Stack Tagging'
HE4582C5513D0: 'AArch64 堆疊標記'
# 'AArch64 Stack Tagging PreRA Pass'
H576B6E1D60C6: 'AArch64 堆疊標記 PreRA Pass'
# 'AArch64 Store Pair Suppression'
HD68B4FD8992D: 'AArch64 存儲對抑制'
# 'AArch64 compress jump tables pass'
HB1CD15516755: 'AArch64 壓縮跳轉表 pass'
# 'AArch64 fix for A53 erratum 835769'
HBBD9D2E5295C: 'AArch64 處理 A53 異常 835769 的修復'
# 'AArch64 homogeneous prolog/epilog lowering pass'
H2B5E843A360C: 'AArch64 同質 prolog/epilog 降階 pass'
# 'AArch64 load / store optimization pass'
HC1E1B5661C2B: 'AArch64 載入/存儲最佳化 pass'
# 'AArch64 pseudo instruction expansion pass'
H39C8B02C1D58: 'AArch64 伪指令展開 pass'
# 'AArch64 redundant copy elimination pass'
HAEB13D1AFB9C: 'AArch64 冗餘拷貝消除 pass'
# 'AArch64 sls hardening pass'
H988D224CDB63: 'AArch64 sls 強化 pass'
# 'AArch64 speculation hardening pass'
H7D2AB26196EE: 'AArch64 預測強化 pass'
# 'AArch64Arm64ECCallLowering'
H73581D76FB10: 'AArch64Arm64ECCallLowering'
# "ABI '%0' is not supported for '%1'"
H7FF392C86EBF: "ABI '%0' 不支援 '%1'"
# "ABI '%0' is not supported on CPU '%1'"
H1189F24D3D62: "ABI '%0' 不支援在 CPU '%1' 上"
# 'AMD vector math library'
HA177FC4B0F5A: 'AMD 向量數學函式庫'
# 'AMDGPU Address space based Alias Analysis'
HEE464CD5CFF9: 'AMDGPU 基於記憶體區塊的別名分析'
# 'AMDGPU Address space based Alias Analysis Wrapper'
HA70F43663430: 'AMDGPU 基於記憶體區塊的別名分析封裝'
# 'AMDGPU Attributor'
HB96C03301054: 'AMDGPU Attributor'
# 'AMDGPU CFG Structurizer'
HFAE00DA66175: 'AMDGPU 控制流圖結構化'
# 'AMDGPU DAG->DAG Pattern Instruction Selection'
H1C6011A1E507: 'AMDGPU DAG→DAG 模式指令選擇'
# 'AMDGPU GlobalISel divergence lowering'
H60A2AE965388: 'AMDGPU GlobalISel 分歧降低'
# 'AMDGPU IR late optimizations'
H2A662801978F: 'AMDGPU IR 後期優化'
# 'AMDGPU IR optimizations'
H6CEDA43B5424: 'AMDGPU IR 優化'
# 'AMDGPU Image Intrinsic Optimizer'
H28FFA260019F: 'AMDGPU 影像內建函數優化器'
# 'AMDGPU Inline All Functions'
HFBEEFEAD43D4: 'AMDGPU 内嵌所有函數'
# 'AMDGPU Insert Delay ALU'
HD712301B82FE: 'AMDGPU 插入延遲 ALU'
# 'AMDGPU Insert waits for SGPR read hazards'
H3CE801DC5FBE: 'AMDGPU 插入等待以處理 SGPR 讀取風險'
# 'AMDGPU Kernel Attributes'
H5B736779332B: 'AMDGPU 核心屬性'
# 'AMDGPU Lower Kernel Arguments'
H345C5C7C45FB: 'AMDGPU 轉換核心參數為低階表示'
# 'AMDGPU Mark last scratch load'
H570A9C93F411: 'AMDGPU 標記最後的暫存器載入'
# 'AMDGPU Pre-RA Long Branch Reg'
HF352DB9ED395: 'AMDGPU 預寄存器分配長分支寄存器'
# 'AMDGPU Pre-RA optimizations'
HB1D166D82990: 'AMDGPU 預寄存器分配優化'
# 'AMDGPU Preload Kernel Arguments Prolog'
HA4C7048C1EF3: 'AMDGPU 預載入核心參數前序'
# 'AMDGPU Printf lowering'
H9F0BCA780CE7: 'AMDGPU Printf 轉換'
# 'AMDGPU Promote Kernel Arguments'
HAD6BF4A8858C: 'AMDGPU 提升核心參數'
# 'AMDGPU Register Bank Legalize'
HD913B83CEA2C: 'AMDGPU 寄存器組合法化'
# 'AMDGPU Register Bank Select'
H910A7C3E575C: 'AMDGPU 寄存器組選擇'
# 'AMDGPU Remove Incompatible Functions'
H697AE5C583A4: 'AMDGPU 移除不相容函數'
# 'AMDGPU Reserve WWM Registers'
H9CD9A7466F8D: 'AMDGPU 保留WWM寄存器'
# 'AMDGPU Rewrite Out Arguments'
H1EE5CA590389: 'AMDGPU 重寫輸出參數'
# 'AMDGPU Software lowering of LDS'
H06C3E98E4BA5: 'AMDGPU 軟體轉換LDS'
# 'AMDGPU atomic optimizations'
HD4C4B30A81C8: 'AMDGPU 原子優化'
# 'AMDGPU promote alloca to vector'
H76A58E341CF5: 'AMDGPU 將alloca提升為向量'
# 'AMDGPU promote alloca to vector or LDS'
H505D453A0AB0: 'AMDGPU 將alloca提升為向量或LDS'
# 'ANALYSIS'
HB0D5F3D274BF: '分析'
# 'ANALYSIS_ALIASING'
H652422606A7D: '別名分析'
# 'ANALYSIS_FP_COMMUTE'
H5B6E5D0BD096: '浮點運算交換性分析'
# 'API notes replacement type %0 has a different size from original type %1'
HB87A25B6CDE7: 'API 註記替換類型 %0 的大小與原始類型 %1 不同'
# 'ARC %select{unused|__unsafe_unretained|__strong|__weak|__autoreleasing}0 lifetime qualifier on return type is ignored'
H4E4E8ED8984D: 'ARC 在返回類型上指定的 %select{未使用|__unsafe_unretained|__strong|__weak|__autoreleasing}0 生命周期修飾符被忽略'
# 'ARC DAG->DAG Pattern Instruction Selection'
H40C54AF1B605: 'ARC DAG→DAG 模式指令選擇'
# 'ARC finalize branches'
H275EE97FB8AE: 'ARC 最終化分支'
# 'ARC forbids %select{implementation|synthesis}0 of %1'
HC91D535AD424: 'ARC 禁止 %select{實作|合成}0 的 %1'
# 'ARC forbids explicit message send of %0'
H35558B925DCC: 'ARC 禁止顯式發送 %0 的消息'
# 'ARC forbids flexible array members with retainable object type'
HBA6CEB1E81A4: 'ARC 禁止使用可保留對象類型的可調節陣列成員'
# 'ARC forbids synthesizing a property of an Objective-C object with unspecified ownership or storage attribute'
H8E9C79FD3192: 'ARC 禁止合成一個 Objective-C 物件屬性，當其未指定所有權或儲存屬性時'
# 'ARC forbids use of %0 in a @selector'
H9E100CA24C33: 'ARC 禁止在 @selector 中使用 %0'
# 'ARM Branch Targets'
H320FDCF5D874: 'ARM 分支目標'
# 'ARM EHABI exceptions'
HF924BFE7B7BB: 'ARM 例外處理ABI 異常'
# 'ARM Execution Domain Fix'
H8BB9925360D9: 'ARM 執行域修正'
# 'ARM Instruction Selection'
HD4C5D9A9956F: 'ARM 指令選擇'
# 'ARM Low Overhead Loops pass'
HF8B8270CD0E0: 'ARM 低開銷循環 pass'
# 'ARM MVE TailPred and VPT Optimisations pass'
HE6A4A21F0251: 'ARM MVE TailPred 和 VPT 優化 pass'
# 'ARM MVE VPT block pass'
HE579D00C5557: 'ARM MVE VPT 區塊 pass'
# 'ARM block placement'
HE7AFE256FA69: 'ARM 程式區塊置放'
# 'ARM constant island placement and branch shortening pass'
H12503A372FDC: 'ARM 常數島置放與分支縮短 pass'
# 'ARM fix for Cortex-A57 AES Erratum 1742098'
HFB722C2D2741: 'ARM 處理 Cortex-A57 AES 處理器瑕疵 1742098 的修正'
# 'ARM load / store optimization pass'
HFAD45B23E308: 'ARM 載入/儲存優化 pass'
# 'ARM pre- register allocation load / store optimization pass'
HAF68B491BF25: 'ARM 預寄存器分配載入/儲存優化 pass'
# 'ARM pseudo instruction expansion pass'
H77670EF47A4C: 'ARM 類指令展開 pass'
# 'ARM sls hardening pass'
H7DDE5DF1D5E8: 'ARM SLS 加固 pass'
# 'AST and IR generation'
H9BC428E8F3F3: 'AST 和 IR 生成'
# "AST file '%0' was compiled for the %1 '%2' but the current translation unit is being compiled for target '%3'"
HCADF9CC20080: "AST 檔案 '%0' 是以 %1 '%2' 編譯的，但目前的翻譯單元正在以目標 '%3' 編譯"
# "AST file '%0' was not built as a module"
HF2D0BB327E40: "AST 檔案 '%0' 未以模組方式建立"
# "AST file '%2' was compiled with module cache path '%0', but the path is currently '%1'"
H5B70E03C1FF3: "AST 檔案 '%2' 編譯時使用的模組快取路徑為 '%0'，但目前的路徑是 '%1'"
# 'AVR DAG->DAG Instruction Selection'
H8D3BB39761E3: 'AVR DAG→DAG 指令選擇'
# 'AVR Shift Expansion'
HB0A514A46417: 'AVR 移位展開'
# 'AVR pseudo instruction expansion pass'
H957B71DEFB30: 'AVR 類指令展開 pass'
# "AVX vector %select{return|argument}0 of type %1 without '%2' enabled changes the ABI"
HA1797A0B7AA1: 'AVX 向量 %select{傳回值|引數}0 的類型為 %1，若未啟用 "%2" 將改變 ABI'
# 'Abbreviation for -input-style=delimited -pretty -log=verbose. Intended to simplify lit tests'
H80629E8FC6D8: '縮寫形式為 -input-style=delimited -pretty -log=verbose。用於簡化 lit 測試'
# 'Abort if an isl error is encountered'
HA9BB62CCA982: '若遇到 isl 錯誤則中止'
# 'Abort if any reduction results in invalid IR'
HE190E2B8E3A2: '若任何簡化導致無效 IR 則中止'
# 'Abort when the max iterations for devirtualization CGSCC repeat pass is reached'
H625080B5E512: '當虛函數解除虛化 CGSCC 重複 pass 的最大迭代次數達成時中止'
# 'Absolute error tolerated'
H0DDBDDDD2804: '可容許的絕對誤差'
# 'Abstract subprograms'
HE11B4671C4D0: '抽象子程序'
# 'Accelerate framework'
HC4987E7BA17F: '加速框架'
# 'Accept a PCH file that was created with a different modules cache path'
H30FC52342749: '接受由不同模組快取路徑所建立的 PCH 檔案'
# 'Accept a PCH file that was created with compiler errors'
H3D9D9492A95B: '接受由含有編譯器錯誤的建置所產生的 PCH 檔案'
# 'Accept a PCM file that was created with compiler errors'
H491D98E75DB9: '接受由編譯器錯誤所建立的 PCM 檔案'
# 'Accept in ARM, reject in Thumb'
H947CDAFC2217: 'ARM 結構下接受，Thumb 結構下拒絕'
# 'Accept in both ISAs, emit implicit ITs in Thumb'
H1A576FCAF9D9: '兩種 ISA 結構下均接受，在 Thumb 結構下產生隱式 IT 指令'
# 'Accept non-standard constructs supported by the Borland compiler'
HA22BD3681EC1: '接受由 Borland 編譯器支援的非標準語法結構'
# 'Accept some non-standard constructs supported by the Microsoft compiler'
HECEF41C80814: '接受由 Microsoft 編譯器支援的非標準語法結構'
# 'Accept some non-standard constructs supported by the z/OS compiler'
H043675240BDC: '接受由 z/OS 編譯器支援的非標準語法結構'
# 'Access dynamic shadow through an ifunc global on platforms that support this'
HB6225A3E2790: '在支援的平台上，透過 ifunc 全局變數存取動態 shadow'
# 'Act like old LiveDebugValues did'
HFD5F11157A46: '行為如同舊版 LiveDebugValues'
# 'Action to perform on deprecated def'
H5D2AEBD499B4: '對已棄用的定義執行的動作'
# 'Action to perform:'
H0985CD6D5E8B: '要執行的動作：'
# 'Add !range metadata to NVVM intrinsics.'
H210E13100D6D: '將 !range 元資料添加至 NVVM 內在函數。'
# 'Add -rpath with architecture-specific resource directory to the linker flags. When --hip-link is specified, also add -rpath with HIP runtime library directory to the linker flags'
H0E7215A9DCD3: '將具有特定架構資源目錄的 -rpath 旗標添加至連結器參數。當指定 --hip-link 時，也會將具有 HIP 執行階段函式庫目錄的 -rpath 旗標添加至連結器參數'
# 'Add .note.gnu.property with BTI to assembly files'
HD58C1F70322E: '將包含 BTI 的 .note.gnu.property 添加至組裝檔'
# 'Add .note.gnu.property with BTI to assembly files (AArch64 only)'
H497BB320D249: '將包含 BTI 的 .note.gnu.property 添加至組裝檔（僅限 AArch64）'
# 'Add <dir> to system include search path, as if in %INCLUDE%'
H8CB70533A0CD: '將 <dir> 加入系統包含路徑搜尋清單，如同位於 %INCLUDE% 環境變數中'
# 'Add AMDGPU function attributes'
H4A9EBA76009C: '添加 AMDGPU 函式屬性'
# 'Add AMDGPU uniform metadata'
HE950C74F7CBF: '添加 AMDGPU 均勻元資料'
# 'Add C++ implicit destructors to CFGs for all analyses'
H7BE6C1575B4A: '將 C++ 隱式解構函式加入所有分析的 CFGs'
# 'Add Contextual/Debug comments to all C++ predicates'
H23C6808D6E2D: '為所有 C++ 預測式添加語境/調試註解'
# 'Add DW_AT_linkage_name to function declaration DIEs referenced by DW_AT_call_origin attributes. Enabled by default for -gsce debugger tuning.'
H71407E50301C: '為由 DW_AT_call_origin 屬性引用的函式宣告 DIE 添加 DW_AT_linkage_name。預設已啟用 -gsce 除錯器調校。'
# 'Add MIR Flow Sensitive Discriminators'
H2C6CDC724E3F: '添加 MIR 流程敏感的區別器'
# 'Add OpenCL builtin function declarations (experimental)'
HC7FA758DA63E: '添加 OpenCL 內建函式宣告（實驗性）'
# 'Add TBAA tags to direct variables'
HAAED7844B106: '為直接變數添加 TBAA 標籤'
# 'Add TBAA tags to dummy arguments'
H3C7A729C0FA0: '為虛構引數添加 TBAA 標籤'
# 'Add TBAA tags to global variables'
HE3F5E682DA95: '為全域變數添加 TBAA 標籤'
# 'Add TBAA tags to local allocations. UNSAFE.'
H91FE178A4638: '為區域分配添加 TBAA 標籤。 UNSAFE.'
# 'Add __emutls_[vt]. variables for emultated TLS model'
H0F84398949DD: '為模擬的 TLS 模型添加 __emutls_[vt]. 變數'
# 'Add a call to __hwasan_add_frame_record for storing into the stack ring buffer'
H42AEFE2097E5: '為儲存至堆疊環狀緩衝區添加 __hwasan_add_frame_record 呼叫'
# 'Add a note for each bug report to denote their analysis entry points'
H540B9CECB600: '為每個錯誤報告添加註記以標示其分析入口點'
# "Add a preheader to a hardware loop if one doesn't exist"
H90D8EF6E5EFA: '若不存在，為硬體迴圈添加 preheader'
# "Add an attribute to a function. This can be a pair of 'function-name:attribute-name', to apply an attribute to a specific function. For example -force-attribute=foo:noinline. Specifying only an attribute will apply the attribute to every function in the module. This option can be specified multiple times."
H025869CF3D3D: '將屬性套用到函式。這可以是「函式名稱:屬性名稱」的組合，以將屬性套用到特定函式。例如 -force-attribute=foo:noinline。僅指定屬性將套用到模組內所有函式。此選項可多次指定。'
# 'Add an implicit negative check with this pattern to every\npositive check. This can be used to ensure that no instances of\nthis pattern occur which are not matched by a positive pattern'
H9C46F681BD1E: '以此模式的隱含負面檢查搭配每個正面檢查。可用來確保此模式的未被正面模式匹配的實例不會出現'
# 'Add block information to the output of -streams'
H31B10635B121: '在 -streams 輸出中添加區塊資訊'
# 'Add comments to directives.'
HB60639F27CEA: '為指令添加註解。'
# 'Add cs prefix to call and jmp to indirect thunk'
HF4B763BF676A: '在間接 thunk 的 call 和 jmp 指令前添加 CS 段前綴'
# 'Add debug loc information when generating tables for '
HFC939A7BE90F: '生成表格時添加除錯位置資訊'
# 'Add dependent library'
H340E932EB390: '添加依賴函式庫'
# 'Add dir to the list of library search paths'
HAF0260DD25B2: '將目錄加入函式庫搜尋路徑清單'
# 'Add directory to AFTER include search path'
HC2FABF8EF08B: '將目錄添加至包含路徑搜尋順序的後面'
# 'Add directory to QUOTE include search path'
H24E806E38760: '將目錄加入QUOTE包含路徑搜索目錄'
# 'Add directory to SYSTEM framework search path'
H8A929D35C6A7: '將目錄加入SYSTEM框架搜索路徑'
# 'Add directory to SYSTEM framework search path, absolute paths are relative to -isysroot'
H690B2B7E95FE: '將目錄加入SYSTEM框架搜索路徑，絕對路徑相對於-isysroot參數計算'
# 'Add directory to SYSTEM include search path'
H87F8A546FC28: '將目錄加入SYSTEM包含路徑搜索目錄'
# 'Add directory to SYSTEM include search path, absolute paths are relative to -isysroot'
HCAEDF5228592: '將目錄加入SYSTEM包含路徑搜索目錄，絕對路徑相對於-isysroot參數計算'
# 'Add directory to embed search path'
H6605669711E5: '將目錄加入嵌入式搜尋路徑'
# 'Add directory to end of the SYSTEM include search path'
HD7B48A7E62C9: '將目錄加入SYSTEM包含路徑搜索目錄列表末端'
# 'Add directory to framework include search path'
H18A8E8D0F71C: '將目錄加入框架包含路徑搜索目錄'
# 'Add directory to include search path'
H8E2DBDC224AD: '將目錄加入包含路徑搜索目錄'
# 'Add directory to include search path with warnings suppressed'
H3D1B9139D392: '將目錄加入包含路徑搜索目錄並抑制警告'
# 'Add directory to library search path'
H7382A4AE54AB: '將目錄加入函式庫搜索路徑'
# 'Add directory to the API notes search path referenced by module name'
H15347B13D121: '將目錄加入模組名稱指定的API備註搜索路徑'
# 'Add directory to the C SYSTEM include search path'
H04DB229B7703: '將目錄加入C語言SYSTEM包含路徑搜索目錄'
# 'Add directory to the C++ SYSTEM include search path'
H99AF1D3B47BB: '將目錄加入C++語言SYSTEM包含路徑搜索目錄'
# 'Add directory to the ObjC SYSTEM include search path'
H4AD0218E28C9: '將目錄加入ObjC語言SYSTEM包含路徑搜索目錄'
# 'Add directory to the ObjC++ SYSTEM include search path'
H4E8397371575: '將目錄加入ObjC++語言SYSTEM包含路徑搜索目錄'
# 'Add directory to the end of the list of include search paths'
HA9C01D5A6394: '將目錄加入包含路徑搜索目錄列表末端'
# 'Add directory to the internal system include search path with implicit extern "C" semantics; these are assumed to not be user-provided and are used to model system and standard headers\' paths.'
HA6F738C6C497: '將目錄加入內部系統包含路徑搜索目錄，並隱含extern "C" 語意；這些目錄假設非使用者提供，用於模擬系統與標準標頭路徑'
# "Add directory to the internal system include search path; these are assumed to not be user-provided and are used to model system and standard headers' paths."
H76AF34D02BE9: '將目錄加入內部系統包含路徑搜索目錄；這些目錄假設非使用者提供，用於模擬系統與標準標頭路徑'
# 'Add dirs in env var <var> to include search path with warnings suppressed'
HFB17BE810349: '將環境變數 <var> 中的目錄加入包含路徑搜索目錄並抑制警告'
# 'Add extra TOC register dependencies'
HB5EA8815333D: '新增額外的TOC寄存器依賴關係'
# 'Add informational comments to the .ll file'
H1430FC8452EC: '在.ll檔案中加入說明性註解'
# 'Add instruction count to a LSR cost model'
H35835E4FFD3B: '將指令計數加入LSR成本模型'
# 'Add library.'
H87317E57D7DD: '新增程式庫。'
# 'Add linker option'
HEB1AFB3AB781: '新增連結器選項'
# 'Add missing headers to depfile'
H874052E89FC5: '將缺失的標頭檔加入依賴檔'
# 'Add no-alias annotation for instructions that are disambiguated by memchecks'
H7736CFB59CC2: '為透過記憶體檢查區分的指令加入無別名註解'
# 'Add printf calls that print the statement being executed'
H09CC61D8FD2B: '新增用於列印正在執行陳述式的printf呼叫'
# 'Add printf calls that print the values of all scalar values used in a statement. Requires -polly-codegen-trace-stmts.'
H955E9733D080: '新增列印陳述式中所有標量值的printf呼叫。需啟用-polly-codegen-trace-stmts。'
# 'Add printf calls that show the values loaded/stored.'
H7361CFCA90ED: '新增顯示載入/儲存值的printf呼叫'
# 'Add prototypes to prototypes-less functions'
H129252A67396: '為缺少原型的函數新增原型'
# 'Add relocations to function pointers to the current function'
HC90D5751B49C: '將當前函數的函數指標添加執行階段重新定位'
# 'Add run-time performance monitoring'
H67AB397B08D2: '新增執行階段效能監控'
# 'Add system library paths to library search paths'
H444464D6D9E2: '將系統程式庫路徑加入搜尋路徑'
# 'Add the view as compare context.'
H9E4AA9613AAE: '將檢視加入比較上下文'
# 'Additional IR scalar types (always includes i1, i8, i16, i32, i64, float and double)'
H0A5D563266B6: '額外的IR標量類型（始終包括i1、i8、i16、i32、i64、float和double）'
# 'Additional argument to append to the compiler command line'
HEBA0B777F61D: '附加要追加到編譯器命令列的引數'
# 'Additional argument to prepend to the compiler command line'
H6170CF05A381: '附加要插入到編譯器命令列開頭的引數'
# "Additional arguments to forward to LLVM's option processing"
HF5FFCDFCC6A2: '傳遞給LLVM選項處理的額外參數'
# "Additional arguments to forward to MLIR's option processing"
HF4553A1AE254: '傳遞給MLIR選項處理的額外參數'
# 'Additional arguments to pass to the linker'
H4F377C1D9775: '傳遞給連結器的額外參數'
# 'Additional shared objects to load into executing programs'
HE9D3E5D77A09: '載入到執行中的程式中的額外共用物件'
# 'Address of the invoked server.'
H6E702787A95D: '調用的伺服器位址。'
# 'Address of the invoked server. Defaults to 0.0.0.0:50051'
H54519DAF9B40: '調用的伺服器位址。預設為 0.0.0.0:50051'
# 'Address sinking in CGP using GEPs.'
HC7C32F638F6D: '使用GEP進行CGP中的地址下沈。'
# "AddressSanitizer doesn't support linking with debug runtime libraries yet"
H46222370DDE7: 'AddressSanitizer 目前尚不支援與除錯執行階段庫連結'
# 'Adjust basic block layout to better use TB[BH]'
HB4BC97D1857E: '調整基本區塊佈局以更好地使用TB[BH]'
# 'Adjust wave priority'
HBA116352E062: '調整wave的優先順序'
# 'AdvSIMD Scalar Operation Optimization'
H45225A2C5722: 'AdvSIMD純量運算最佳化'
# 'Advanced attributes alias.'
HA39A91E5AAD4: '進階屬性別名。'
# 'Aggregate arguments to code-extracted functions'
H328995968B2E: '聚合傳遞給程式碼提取函數的參數'
# 'Aggregate stack times across threads'
H5CF510D1EBBA: '跨執行緒彙總堆疊使用時間'
# 'Aggressive extension optimization'
HA4AE7C7FBB62: '積極的擴展最佳化'
# 'Aggressively try to fuse everything'
H9E616808E7EC: '積極嘗試融合所有內容'
# 'Algorithm to use for splitting basic blocks into multiple statements'
H077B22383231: '用於將基本區塊分割為多個語句的演算法'
# 'Alias Analysis Pipeline'
HE33821D525F2: '別名分析管線'
# 'Alias for --'
HA3FB2C7B610D: '--的別名'
# 'Alias for --blocks-x'
H57C6A0E441DA: '--blocks-x的別名'
# 'Alias for --demangled-names'
HE840FF95BF7A: '--demangled-names的別名'
# 'Alias for --dry-run'
H0FA96A999664: '--dry-run的別名'
# 'Alias for --help'
HF39AA3CC9361: '等同於--help'
# 'Alias for --indirect-call-promotion'
HDBD75B583A13: '等同於--indirect-call-promotion'
# 'Alias for --input-files'
HDFC325842CEB: '等同於--input-files'
# 'Alias for --intermediate-format'
HD7D86B4F5A3A: '等同於--intermediate-format'
# 'Alias for --no-warn'
H6C7B7F57DEA7: '等同於--no-warn'
# 'Alias for --num-threads'
HE9977CCA0811: '等同於--num-threads'
# 'Alias for --output'
HA7011D865212: '等同於--output'
# 'Alias for --output-dir'
HC51012922C34: '等同於--output-dir'
# 'Alias for --perfdata'
H136FC40E1E00: '等同於--perfdata'
# 'Alias for --perfscript'
H3EE8965681A7: '等同於--perfscript'
# 'Alias for --remapping-file'
H24A193959D48: '等同於--remapping-file'
# 'Alias for --save-temps=cwd'
HB0770869E271: '等同於--save-temps=cwd'
# 'Alias for --threads-x'
H2B37E4881B6D: '等同於--threads-x'
# 'Alias for --unsymbolized-profile'
HAAA114F8EC1E: '等同於--unsymbolized-profile'
# 'Alias for -Xclang'
HCD7F2ECE0041: '等同於-Xclang'
# 'Alias for -all-stacks'
HBF7B049FB306: '等同於-all-stacks'
# 'Alias for -check-prefix permitting multiple comma separated values'
HD103BAE71227: '等同於-check-prefix（允許多個以逗號分隔的值）'
# 'Alias for -color-edges'
HC19B12CB2430: '等同於-color-edges'
# 'Alias for -deduce-sibling-calls'
H2E10ADB53A0A: '等同於-deduce-sibling-calls'
# 'Alias for -deduce-sibling-calls-1'
HF24D573B4E93: '等同於-deduce-sibling-calls-1'
# 'Alias for -deduce-sibling-calls-2'
H4800F023F658: '-deduce-sibling-calls-2 的別名'
# 'Alias for -deduce_sibling_calls'
HFE68AA381CCA: '-deduce_sibling_calls 的別名'
# 'Alias for -edge-color'
H5FEAD1AEB73F: '-edge-color 的別名'
# 'Alias for -edge-label'
HAFADF6FC17E1: '-edge-label 的別名'
# 'Alias for -fextend-variable-liveness=all.'
H2B2334ED3B9F: '-fextend-variable-liveness=all. 的別名'
# 'Alias for -fsanitize-ignorelist='
H6624562D7869: '-fsanitize-ignorelist= 的別名'
# 'Alias for -help'
HEA697AFD46B7: '-help 的別名'
# 'Alias for -instr-map'
HB57A8B70724F: '-instr-map 的別名'
# 'Alias for -instr-map-1'
H6F2C86FF53ED: '-instr-map-1 的別名'
# 'Alias for -instr-map-2'
HD9A737CB2F17: '-instr-map-2 的別名'
# 'Alias for -instr_map'
H13EC2B696DE5: '-instr_map 的別名'
# 'Alias for -keep-going'
HC2FBFBC9B1BF: '-keep-going 的別名'
# 'Alias for -keep-going-1'
HFC1713D60AC5: '-keep-going-1 的別名'
# 'Alias for -keep-going-2'
HB73DA9252C0A: '-keep-going-2 的別名'
# 'Alias for -keep_going'
H25546D53A1D1: '-keep_going 的別名'
# 'Alias for -mllvm'
HE5CF0AF34303: '-mllvm 的別名'
# 'Alias for -output'
H11E85BC44369: '-output 的別名'
# 'Alias for -output-format'
HCE5EA67FACF7: '-output-format 的別名'
# 'Alias for -passes'
HAC9042256B8B: '-passes 的別名'
# 'Alias for -sort'
H439A5386F45B: '-sort 的別名'
# 'Alias for -sortorder'
H29F0D261B98A: '-sortorder 的別名'
# 'Alias for -symbolize'
HD9D9FFEE4D20: '-symbolize 的別名'
# 'Alias for -top'
H0697652EC65F: '-top 的別名'
# 'Alias for -version'
HD2E0461080FA: '-version 的別名'
# 'Alias for -vertex-color'
HB336A9FE055A: '-vertex-color 的別名'
# 'Alias for -vertex-label'
HB5305BD11A1C: '-vertex-label 的別名'
# 'Alias for -vertex-label-trun'
HBB4740B7076F: '-vertex-label-trun 的別名'
# 'Alias of -format'
HD5F8D2C37C5D: '-format 的別名'
# 'Align ARM NEON spills in prolog and epilog'
HA6EB49748CD3: '在函數的前序和後序對齊ARM NEON的spills'
# 'Align branches within 32-byte boundaries to mitigate the performance impact of the Intel JCC erratum.'
H5A28F46326DE: '在 32 字節邊界內對齊分支以緩解Intel JCC 處理缺陷的性能影響。'
# 'Align constant islands in code'
H461BA6D2D6E3: '在程式碼中對齊常數島'
# 'Align doubles to two words in structs (x86 only)'
HEDC15B5DDF59: '在結構中將雙精度浮點數對齊為兩個字元（僅限x86）'
# 'Align selected branches (fused, jcc, jmp) within 32-byte boundary'
H61C864267E04: '在 32 字節邊界內對齊選擇的分支（融合、jcc、jmp）'
# "Align selected instructions to mitigate negative performance impact of Intel's micro code update for errata skx102.  May break assumptions about labels corresponding to particular instructions, and should be used with caution."
H4F2747860017: '對齊選擇的指令以緩解Intel因skx102缺陷更新微代碼所導致的負面性能影響。可能破壞標籤與特定指令對應的假設，應謹慎使用。'
# 'Aligned allocation/deallocation functions are unavailable'
H93CADD3D554F: '對齊的分配/釋放函數不可用'
# 'Alignment of bundle for binary files'
H746C20CFEB90: '二進位檔的封裝對齊'
# "All compile commands come from LSP and 'compile_commands.json' files are ignored"
H35E96D7E99B1: '所有編譯命令均來自LSP，忽略compile_commands.json檔'
# "All compile commands come from the 'compile_commands.json' files"
H2E03660ADBFF: '所有編譯命令均來自compile_commands.json檔'
# 'All decisions not in replay are inlined'
H9B15B2C90AE0: '所有不在重播中的決策均進行內聯'
# 'All decisions not in replay are not inlined'
H1838D4DFB9C1: '所有不在重播中的決策均不進行內聯'
# 'All decisions not in replay send to original advisor (default)'
H8494FD0B179D: '不在重放中的所有決策都會發送到原始建議者（預設）'
# 'All edges.'
HA0232E12FF85: '所有邊。'
# 'All elements.'
HD1FF88F0C212: '所有元素。'
# 'All input lines'
HAA2659CBF3BE: '所有輸入行'
# 'All known subsections'
H605028076261: '所有已知子區段'
# 'All non-critical edges.'
H4DF2A4AF93D9: '所有非關鍵邊。'
# 'All of the above and take the minimum of measurements'
H8D49782EBA5E: '上述所有內容，並取測量值的最小值'
# 'All outputs.'
HA29C21D07A12: '所有輸出。'
# 'All possible int comparisons in GPRs.'
H166898BCED35: 'GPR 中所有可能的整數比較。'
# 'All suitable variables will have the TOC data transformation applied'
H5309722D6033: '所有合適的變數將應用 TOC 數據轉換'
# 'All vtables have type infos'
H69D2DF6DECC5: '所有虛函數表都包含類型資訊'
# 'All warnings.'
H294EA62DA621: '所有警告。'
# 'Allocate all arrays of unknown size and temporary arrays in stack memory'
H3AE89D60479D: '將未知大小的陣列和臨時陣列分配到堆疊記憶體中'
# 'Allocate array temporaries on the heap (default)'
HF192F6B25D6C: '在堆上分配陣列臨時變數（預設）'
# 'Allocate from a slab of the given size (allowable suffixes: Kb, Mb, Gb. default = Kb)'
H8D1230E33C0D: '從給定大小的 slab 分配（允許的後綴：Kb、Mb、Gb。預設為 Kb）'
# 'Allocate memory upfront rather than on-demand'
H067B160BE7A4: '提前分配記憶體而不是按需分配'
# 'Allocate to an enum type only as many bytes as it needs for the declared range of possible values'
H5482421F99A5: '為枚舉類型分配的記憶體僅足夠存儲其宣告的可能值範圍所需的位元組'
# "Allow '$' in identifiers"
H6DB82DC47410: '允許識別符中使用 "$"'
# 'Allow (may be subject to certain conditions) conversion of memcpy to TP loop.'
HF0E5B5A536C5: '允許（可能受某些條件限制）將 memcpy 轉換為 TP 迴圈'
# 'Allow AArch64 Local Dynamic TLS code generation'
H307A55AE7B7F: '允許 AArch64 本地動態 TLS 程式碼生成'
# 'Allow DSE to optimize memory accesses.'
H6047B03BEC73: '允許DSE優化記憶體存取。'
# 'Allow GNU-extension keywords regardless of language standard'
H2947F99E638F: '允許使用GNU擴展關鍵字，不論語言標準'
# 'Allow G_INSERT to be considered an artifact. Hack around AMDGPU test infinite loops.'
H8D40AAA978F4: '允許將G_INSERT視為一種工件。用以解決AMDGPU測試無限循環的問題。'
# 'Allow JumpThreading to thread across loop headers, for testing'
H0966C1037306: '允許JumpThreading在迴圈標頭進行跳轉，僅供測試'
# 'Allow Objective-C array and dictionary subscripting in legacy runtime'
HCDF0596C06B7: '允許在舊版執行階段中使用Objective-C陣列和字典的索引語法'
# 'Allow SimplifyCFG to merge invokes together when appropriate'
H6D05BDC01566: '允許SimplifyCFG在適當時將invokes進行合併'
# 'Allow __declspec as a keyword'
HCB246A7067C5: '允許將__declspec視為關鍵字'
# 'Allow aggressive, lossy floating-point optimizations'
H0FAF2AF8BF00: '允許執行損失精度的激進浮點運算優化'
# 'Allow atomic operations to ignore denormal mode'
HCF502E940887: '允許原子運算忽略次正规模式'
# 'Allow calls to the specified functions in SCoPs even if their side-effects are unknown. This can be used to do debug output in Polly-transformed code.'
H1410ADCFCAA7: '允許在SCoPs中呼叫指定函數，即使其副作用未知。此選項可用於 Polly 轉換程式碼中的除錯輸出。'
# 'Allow certain math function calls to be replaced with an approximately equivalent calculation'
H7E6336F3B5B7: '允許將特定數學函數呼叫取代為近似等效的運算式'
# 'Allow cloning of callsites involved in recursive cycles'
HF572EEE2B09E: '允許複製涉及遞迴循環的呼叫位置'
# 'Allow cloning of contexts having recursive cycles'
H599BF96DBCB9: '允許複製具有遞迴循環的執行環境'
# 'Allow cloning of contexts through recursive cycles'
HB9EECACDCD85: '允許通過遞迴循環複製執行環境'
# 'Allow combining of BaseGV field in Address sinking.'
H2D77F4CB6201: '允許在Address sinking中合併BaseGV欄位'
# 'Allow combining of BaseOffs field in Address sinking.'
HF852DDC4F55A: '允許在Address sinking中合併BaseOffs欄位'
# 'Allow combining of BaseReg field in Address sinking.'
H26B9669FA2AC: '允許在Address sinking中合併BaseReg欄位'
# 'Allow combining of ScaledReg field in Address sinking.'
HDEF3EE554628: '允許在Address sinking中合併ScaledReg欄位'
# 'Allow compiler to merge handlers for all sanitizers'
H5230AC99F094: '允許編譯器合併所有檢查器的處理程序'
# 'Allow compiler to merge handlers for specified sanitizers'
HD4BB34899488: '允許編譯器合併指定檢查器的處理程序'
# 'Allow conditional instructions outside of an IT block'
H08E49F0EFDBF: '允許在IT區塊外使用條件指令'
# 'Allow counter promotion across the whole loop nest.'
HD6A96DE259B4: '允許在整个循环巢式中进行計數器提升。'
# 'Allow creation of Phis in Address sinking.'
HE9D1F49BEE6D: '允許在地址下沈中建立Phi節點。'
# 'Allow creation of selects in Address sinking.'
HF3DF8C2D011E: '允許在地址下沈中建立選擇指令。'
# 'Allow device side init function in HIP (experimental)'
HBC635735388C: '允許在HIP中使用裝置端初始化函數（實驗性）'
# 'Allow different element types for array accesses'
HE3FBA82C5731: '允許陣列存取使用不同的元素類型'
# 'Allow division operations to be reassociated'
HAD0D8D2448AD: '允許在向量化期間啟用循環提示以重新排序浮點運算。'
# 'Allow enabling loop hints to reorder FP operations during vectorization.'
HD2BC949EEEE2: '允許恰好一個昂貴指令被推测執行'
# 'Allow exactly one expensive instruction to be speculatively executed'
H2182F06086EB: '允許假設參數和結果不會是NaN或±∞的浮點優化。此選項定義了__FINITE_MATH_ONLY__預處理宏。'
# 'Allow floating-point optimizations that assume arguments and results are not NaNs or +-inf. This defines the \\_\\_FINITE\\_MATH\\_ONLY\\_\\_ preprocessor macro.'
H49916D802745: '允許假設參數和結果不是NaN或±∞的浮點最佳化。這定義了\\_\\_FINITE\\_MATH\\_ONLY\\_\\_預處理器宏。'
# 'Allow for a mixture of Mips16 and Mips32 code in a single output file'
H85A1B3521C3C: '允許具有已知修改/引用行為的函數'
# 'Allow functions with known modref behavior'
HE8FEED2897E6: '允許在展開循環時生成循環余量（額外迭代）'
# 'Allow generation of a loop remainder (extra iterations) when unrolling a loop.'
HA9A95BA27CAD: '允許生成複雜的IT區塊。'
# 'Allow generation of complex IT blocks.'
H0C587C47350A: '允許生成複雜的IT區塊。'
# 'Allow generation of data access to code sections (AArch64/ARM only)'
H4E803F81C9B5: '允許生成對程式碼段的資料存取（僅AArch64/ARM）'
# 'Allow header insertions'
H94D83C00667E: '允許移除標頭'
# 'Allow header removals'
H47A033C84B47: '允許以最佳努力方式使用不完整IR（對未知元數據的引用將被移除）'
# 'Allow incomplete IR on a best effort basis (references to unknown metadata will be dropped)'
H05F1B598EC8B: '允許在呼叫端具有被呼叫端nobuiltin屬性超集時進行內聯'
# "Allow inlining when caller has a superset of callee's nobuiltin attributes."
H21EB86A2A3AB: '允許多次旋轉循環以達到更好的latch出口'
# 'Allow loop rotation multiple times in order to reach a better latch exit'
HE5B48E5AC62B: '允許多次迴圈旋轉以達到更優的latch退出點'
# 'Allow mapping symbol at section beginning to be implicit, lowering number of mapping symbols at the expense of some portability. Recommended for projects that can build all their object files using this option'
HE30942163DF4: '允許將區段開頭的映射符號隱式化，以減少映射符號數量，但可能損失部分可移植性。建議用於所有物件檔均可使用此選項編譯的專案'
# 'Allow memory accesses to be unaligned (AArch32/MIPSr6 only)'
H4DACD884827E: '允許非對齊記憶體存取（僅AArch32/MIPSr6）'
# 'Allow memory accesses to be unaligned (AArch64/LoongArch/RISC-V only)'
H075169115FA2: '允許非對齊記憶體存取（僅AArch64/LoongArch/RISC-V）'
# 'Allow mergefunc to create aliases'
H96D31DA83FB1: '允許mergefunc建立別名'
# 'Allow merging of constants'
H7B7B2A69B6A1: '允許合併常數'
# 'Allow non affine access functions in arrays'
H1B750054F6AE: '允許陣列中使用非仿射存取函數'
# 'Allow non affine conditions for branches'
H02FFF4B1AF5A: '允許分支使用非仿射條件'
# 'Allow non affine conditions for loops'
H7C67DD81E47E: '允許迴圈使用非仿射條件'
# 'Allow non-power-of-2 vectorization.'
HA2D0D7F2C7BF: '允許非 2 的冪次向量化。'
# 'Allow non-solo packetization of volatile memory references'
H5792B0D4B6CC: '允許將易失性記憶體引用進行非單獨封包化'
# 'Allow operation with no registered dialects'
H7A999A69E320: '允許在未註冊方言的情況下進行運算'
# 'Allow operation with no registered dialects (discouraged: testing only!)'
HF9B2D65D3FE4: '允許在未註冊方言的情況下進行運算（不建議：僅限測試！）'
# 'Allow operations coming from an unregistered dialect'
HC8673F2EA652: '允許使用來自未註冊方言的運算'
# 'Allow optimization to assume there are no NaNs.'
H4027A2790C01: '允許優化假設不存在NaN值。'
# 'Allow optimization to assume there are no infinities.'
H2F8AEF326E4D: '允許優化假設不存在無窮大值。'
# 'Allow optimizations that ignore the sign of floating point zeros'
H74EA3796D9B9: '允許忽略浮點零值符號的優化'
# 'Allow partial writes'
H36F20305E82F: '允許部分寫入'
# 'Allow passing GC Pointer arguments in callee saved registers'
HAAA2F5C160B0: '允許將GC指標參數傳遞到callee保存的寄存器'
# 'Allow placing main program variables on the stack (default)'
HFA7AA687FA70: '允許將主程式變數放置在堆疊中（預設值）'
# 'Allow prefixes to be specified but not appear in the test.'
HE9A068B65F59: '允許指定前綴但不在測試中顯示。'
# 'Allow reassociation transformations for floating-point instructions'
H69FAD124BA17: '允許浮點指令的重新關聯轉換'
# 'Allow relaxed uniform region checks'
HECAF51D715EB: '允許鬆弛的均勻區域檢查'
# 'Allow reordering across at most this many instructions when hoisting'
H03C130FA1582: '在提升時，允許跨最多此數量的指令重新排序'
# 'Allow runtime unroll for AMDGPU if local memory used in a loop'
H6AD964FBACC9: '如果循環中使用了本地記憶體，允許在AMDGPU上進行運行時展開'
# 'Allow runtime unrolled loops to be unrolled with epilog instead of prolog.'
H402D9BD954E3: '允許在生成epilog時，以epilog而非prolog的方式展開運行時未展開的循環'
# 'Allow runtime unrolling for loops with multiple exits, when epilog is generated'
H612B7424A810: '允許在生成epilog時，對具有多個退出點的循環進行運行時展開'
# 'Allow sample loader inliner to inline recursive calls.'
HA6530F6AAC71: '允許sample載入器內聯器內聯遞迴呼叫。'
# 'Allow scalar memory accesses to be unaligned (RISC-V only)'
HFC86196CBA64: '允許標量記憶體存取不對齊（僅限RISC-V）'
# 'Allow slot1 store and slot0 load'
H7437ACC71E24: '允許slot1儲存和slot0載入'
# 'Allow speculation of preheader instructions'
H363DA7F8452D: '允許對preheader指令進行假設執行'
# 'Allow spill in spill slot of greater size than register size'
H9CD29F6A2A53: '允許在大於寄存器大小的spill區中進行spill'
# 'Allow static variables in .sdata'
H770981D5F907: '允許在.sdata中使用靜態變數'
# 'Allow the Attributor to create shallow wrappers for non-exact definitions.'
HB6DC09C0C648: '允許Attributor為非精確定義創建淺層封裝器。'
# 'Allow the Attributor to do call site specific analysis'
H2595BA1E26D0: '允許Attributor進行呼叫位置特定分析'
# 'Allow the Attributor to use IP information derived from non-exact functions via cloning'
H0E8CFBCDE797: '允許Attributor通過複製非精確函數來使用由此衍生的IP資訊'
# 'Allow the detection of full functions'
H6DD82ED565A3: '允許檢測完整函數'
# 'Allow the formation of VW_W operations (e.g., VWADD_W) with splat constants'
H845C6DF92D8C: '允許使用播撒常數形成VW_W操作（例如VWADD_W）'
# 'Allow the input file to be empty. This is useful when making\nchecks that some error message does not occur, for example.'
H658BEA7D8D36: '允許輸入檔案為空。這在進行檢查時很有用，例如確認某些錯誤訊息不會出現。'
# 'Allow the loop remainder to be unrolled.'
H54EBCBE4781C: '允許展開循環餘數'
# 'Allow the use of FMAs if available and profitable. This may result in different results, due to less rounding error.'
H996DA0DE6CCE: '允許使用FMAs（如果可用且有利可圖）。這可能會導致結果不同，因四捨五入的誤差較小。'
# 'Allow to search for module maps in subdirectories of search paths'
H4C313304A657: '允許在搜尋路徑的子目錄中搜尋模組地圖'
# "Allow to speculate on the execution of 'error blocks'."
H88DB79B94D55: '允許對「錯誤區塊」的執行進行推测'
# 'Allow unsafe floating-point math optimizations which may decrease precision'
H67E450B90F32: '允許可能降低精確度的不安全浮點數最佳化'
# 'Allow unsigned operations such as comparisons or zero-extends.'
H33CDECA8CBA8: '允許無符號操作，例如比較或零擴充'
# 'Allow use of CMSE (Armv8-M Security Extensions)'
H21EADF8CC690: '允許使用CMSE（Armv8-M安全擴充）'
# 'Allow use of CRC instructions (ARM/Mips only)'
H0928C2372DB2: '允許使用CRC指令（僅限ARM/Mips）'
# 'Allow using blocks with parameters of more specific type than the type system guarantees when a parameter is qualified id'
HEADAE3890D46: '當參數為已修飾的識別符時，允許使用參數類型比型別系統保證的更具體的區塊'
# 'Allow using registers for gc pointer in landing pad'
H6D19D992878A: '允許在例外處理的着陸墊中使用寄存器存放gc指標'
# 'Allow using registers for non pointer deopt args'
HD185DF4F0E95: '允許使用寄存器存放非指標deopt參數'
# 'Allow variadic functions in CUDA device code.'
H918161EF13F5: '允許在CUDA裝置程式碼中使用可變參數函數'
# 'Allow vector memory accesses to be unaligned (RISC-V only)'
HB7E7D4EF733A: '允許向量記憶體存取不對齊（僅限RISC-V）'
# 'Allow widening of indvars to eliminate s/zext'
HC582FEBF6EC9: '允許擴展索引變數以消除s/zext'
# 'Allowed symbol scopes (comma-separated list)'
H09C539E5B693: '允許的符號範圍（逗號分隔清單）'
# 'Allows assuming by-value parameters do not alias any other value. Has no effect on non-trivially-copyable classes in C++.'
HA18120EB5360: '允許假設按值傳遞的參數不會與其他值有別名。在C++中對非可輕易複製的類別無效。'
# 'Allows control over excess precision on targets where native support for BFloat16 precision types is not available. By default, excess precision is used to calculate intermediate results following the rules specified in ISO C99.'
HBB6845887CAC: '在未提供原生支援BFloat16精度類型的目標平台上，控制過度精確度。預設情況下，會根據ISO C99規則使用過度精確度計算中間結果。'
# 'Allows control over excess precision on targets where native support for Float16 precision types is not available. By default, excess precision is used to calculate intermediate results following the rules specified in ISO C99.'
HC49D9EDA0518: '允許在原生不支援Float16精度類型的目標平台上控制額外精度。預設情況下，額外精度會根據ISO C99的規則用來計算中間結果'
# 'Allows control over excess precision on targets where native support for the precision types is not available. By default, excess precision is used to calculate intermediate results following the rules specified in ISO C99.'
HF60814E6692A: '允許在原生不支援特定精度類型的目標平台上控制額外精度。預設情況下，額外精度會根據ISO C99的規則用來計算中間結果'
# 'Allows loop nests to be peeled.'
HFE032116CB53: '允許剝離循環巢狀結構'
# 'Allows loops to be partially unrolled until -unroll-threshold loop size is reached.'
HAAF79FCD3521: '允許部分展開循環，直到達到-unroll-threshold循環大小'
# 'Allows loops to be peeled when the dynamic trip count is known to be low.'
HE4D86D272F84: '當動態次數已知較低時，允許剝離循環'
# 'Allows loops to be unroll-and-jammed.'
H08E5D5835443: '允許循環進行unroll-and-jammed操作'
# 'Allows to add additional results to private functions to return ownership of returned memrefs to callers. This can avoid spurious buffer clones in the callee.'
H2478745EEA16: '允許在私有函數中添加額外的結果，以將返回的memrefs的所有權歸還給調用者。這可以避免在被調用者中產生不必要的緩衝區複製'
# 'Allows using features specific to Hugo'
H5D750A78EC0D: '允許使用Hugo的特定功能'
# 'Also show functions without any scops'
H8AA7DD878BF3: '也顯示沒有任何scops的函數'
# 'Also write profiles with all-zero counters. Intended for testing/debugging.'
HC00EF438F6CF: '也寫入所有計數器為零的剖析資料。用於測試/除錯'
# 'Always Step Into.'
H2D9E73855459: '始終步進進入'
# 'Always convert memcpy to TP loop.'
H43BC365E404A: '始終將memcpy轉換為TP循環'
# 'Always detect stack use after return.'
HAA3BC6D7C687: '始終檢測堆疊在返回後的使用'
# 'Always dump input'
HA3473C53D75A: '始終傾印輸入'
# 'Always emit EH frame entries'
HDDDD83A3567E: '始終發射例外處理框架條目'
# 'Always emit __xray_customevent(...) calls even if the containing function is not always instrumented'
H3096C16CDC52: '始終發射__xray_customevent(...)調用，即使包含的函數未被總是插樁'
# 'Always emit __xray_typedevent(...) calls even if the containing function is not always instrumented'
H2E61DC30BF81: '始終發射__xray_typedevent(...)調用，即使包含的函數未被總是插樁'
# 'Always emit a debug frame section'
HB80937D1780A: '始終發射一個除錯框架區段'
# 'Always emit a debug frame section.'
H23A9192A38F7: '始終發射一個除錯框架區段'
# 'Always exclude wrong side overloads in overloading resolution for CUDA/HIP'
HA5AB629FB85E: '在CUDA/HIP的重載解決中始終排除錯誤側的重載'
# 'Always generate function calls for address sanitizer instrumentation'
HA25586514168: '始終為地址清理插樁生成函數調用'
# 'Always modify dest registers regardless of color'
H58E66AB0CF8C: '無論寄存器著色如何，始終修改目標寄存器'
# 'Always set the bit'
H9287AFC9334D: '始終設置該位元'
# 'Always track the overflow bit.'
H577F71683BBC: '始終追蹤溢位位元。'
# 'Always use $gp as the global base register.'
HC4090BE1945A: '始終使用$gp作為全域基底寄存器。'
# 'Always use DW_AT_ranges in DWARFv5 whenever it could allow more address pool entry sharing to reduce relocations/object size'
H5C1DD29350B5: '只要允許更多的地址池條目共用以減少重新定位/物件大小，DWARFv5中始終使用DW_AT_ranges'
# 'Always use compact branches if possible.'
H9248BC8A7969: '只要可能始終使用緊湊跳轉'
# 'Always use descriptors for POINTER and ALLOCATABLE'
H088038A3E688: '始終為POINTER和ALLOCATABLE使用描述符'
# 'Always used text-based completion'
H186681547B61: '始終使用文字基礎的完成'
# 'Always write temporary files as bitcode instead of textual IR'
H1C24DC778992: '始終將暫存檔寫入位元碼而非文字型IR'
# 'An ID for compilation unit, which should be the same for the same compilation unit but different for different compilation units. It is used to externalize device-side static variables for single source offloading languages CUDA and HIP so that they can be accessed by the host code of the same compilation unit.'
HEAEE5FF78DA6: '編譯單元的ID，相同的編譯單元應具有相同的ID，而不同的編譯單元則不同。它用於將CUDA和HIP單一來源外掛語言的裝置端靜態變數外部化，以便同一編譯單元的主機代碼可以存取它們。'
# 'An additional cost threshold that must be exceeded for merging to be considered beneficial.'
H80CD60A8D728: '合併需被視為有益時必須超過的額外成本門檻。'
# 'An allocatable left-hand side of an intrinsic assignment is assumed to be allocated and match the shape/type of the right-hand side'
H80F5410F8454: '內建指派的可分配左邊操作數假定已分配，並與右邊操作數的形狀/類型匹配'
# 'An integer in percent used to specify the hot blocks/edges to be displayed in red: a block or edge whose frequency is no less than the max frequency of the function multiplied by this percent.'
H785F9B56BA61: '以紅色顯示函數中熱區區塊/邊的百分比閾值：其頻率不小於函數最大頻率乘以此百分比的區塊或邊。'
# 'Analysis'
H62C7FCF46E27: '分析'
# 'Analysis containing CSE Info'
H844D68401590: '包含共用子表達式資訊的分析'
# 'Analysis for ComputingKnownBits'
H7CC4A0AB7F2C: '計算已知位元的分析'
# 'Analysis if a function is memory bound'
H4D110E7E06DE: '分析函數是否為記憶體瓶頸的分析'
# 'Analyze Machine Code For Garbage Collection'
H9DF9D8E23EF5: '分析機器代碼以進行垃圾回收'
# 'Analyze array contents for load forwarding'
H400B26D98EF4: '分析陣列內容以進行載入前向'
# 'Annotate LTO phase (prelink / postlink), or main (no LTO) for sample-profile inline pass name.'
HE2E0B6955283: '標註LTO階段（prelink/postlink），或是主階段（無LTO）以供樣本剖析內聯pass名稱。'
# 'Annotate SI Control Flow'
H917E9747DC24: '標註SI控制流程'
# 'Annotate call sites of function declarations.'
H117120C6D4F8: '標註函式宣告的呼叫位置。'
# 'Annotate table jump instruction to correlate it with the jump table.'
H49774B77C4AA: '標註表格跳轉指令以與跳轉表進行關聯。'
# 'Any subsection not covered by another option'
HE0257BE6772D: '未被其他選項涵蓋的子區塊'
# 'Append function hash to the name of COMDAT function to avoid function hash mismatch due to the preinliner'
HFFA3462002F7: '將函式哈希值附加到COMDAT函式名稱，以避免因預展開器導致的函式哈希值不匹配。'
# "Append the exit code to the output so it gets diff'd too"
H9E3A9D6959C1: '將退出代碼附加到輸出，以便也能進行diff比對。'
# 'Append vectorize enable/disable metadata from polly'
H9E5D3061A26C: '從Polly附加向量化啟用/停用的元資料。'
# 'Appends one trailing underscore to external names'
HD2751F46D9D1: '在外部名稱後附加一個尾部底線符（_）'
# 'Apple'
H476432A3E85A: 'Apple'
# 'Applies path clonings for the -basic-block-sections=list option'
H2424A194F26C: '為-basic-block-sections=list選項套用路徑複製。'
# 'Apply CHR for all functions'
H577A52B0B7CC: '為所有函式套用CHR。'
# 'Apply an iterative post-processing to infer correct BFI counts'
H66ADFA49B9E1: '套用反覆的後處理以推斷正確的BFI計數。'
# 'Apply edits to analyzed source files'
HFDE3C74EED4D: '套用修改至已分析的原始檔。'
# 'Apply first slot optimization for stack tagging (eliminate ADDG Rt, Rn, 0, 0).'
H2ADE0B593B04: '套用首槽優化於堆疊標記（消除ADDG Rt, Rn, 0, 0 指令）。'
# 'Apply fix-it advice creating a file with the given suffix'
H2BD66E062CA1: '套用修正建議以建立具有指定副檔名的檔案。'
# 'Apply fix-it advice even in the presence of unfixable errors'
H011FCA2E909C: '即使存在無法修正的錯誤，仍套用修正建議。'
# 'Apply fix-it advice only for warnings, not errors'
H6ED66F770BAD: '僅針對警告（非錯誤）套用修正建議。'
# 'Apply fix-it advice to the input source'
HFFEDA0075E38: '將修正建議套用至輸入原始碼。'
# 'Apply fix-it changes and recompile'
H6D9BFB4F5F51: '套用修正變更並重新編譯。'
# 'Apply fix-it changes to temporary files'
HF35652D64499: '將修正建議應用到臨時文件'
# 'Apply given attribute to all functions'
H0A840E827150: '將指定的屬性套用至所有函數'
# 'Apply global symbol visibility to external declarations without an explicit visibility'
HB6DB5D64D7AE: '將全域符號可見性套用至未明確指定可見性的外部宣告'
# 'Apply no_sanitize to the whole file'
H1820034AB28F: '將 no_sanitize 應用至整個檔案'
# 'Apply post-rescheduling optimizations such as tiling (requires -polly-reschedule)'
HD42F33B0AD22: '套用如平鋪等重新調度後的優化（需要 -polly-reschedule 選項）'
# 'Apply the profile guided size optimizations only if the working set size is large (except for cold code.)'
HCAA14E2BEA3D: '僅當工作集大小較大時（冷代碼除外），套用配置文件引導型尺寸優化'
# 'Apply the profile guided size optimizations only to cold code under instrumentation PGO.'
H88E35D1AFA04: '在插樁 PGO 下，僅對冷代碼套用配置文件引導型尺寸優化'
# 'Apply the profile guided size optimizations only to cold code under partial-profile sample PGO.'
HA712F1C73153: '在部分剖面樣本 PGO 下，僅對冷代碼套用配置文件引導型尺寸優化'
# 'Apply the profile guided size optimizations only to cold code under sample PGO.'
H15AF6FCF8AC2: '在樣本 PGO 下，僅對冷代碼套用配置文件引導型尺寸優化'
# 'Apply the profile guided size optimizations only to cold code.'
HFC7E2CE1D9BB: '僅對冷代碼套用配置文件引導型尺寸優化'
# 'Apply the terminal rule'
HE81B9410B1C9: '套用終端規則'
# 'Apply user-directed transformation from metadata'
HC2B25CDB2B7C: '根據元數據套用使用者指定的轉換'
# 'Approximately limit number of return registers for replacing out arguments'
H004F37FECEE5: '約束用於取代传出參數的返回寄存器數量'
# 'Architecture to generate code for (see --version)'
H3DBAAEAEDF16: '要生成程式碼的架構（參閱 --version）'
# 'Argument Register Usage Information Storage'
H5FFD7A67FE89: '參數寄存器使用資訊儲存'
# 'Argument Stack Rebase'
HAB61ED834BD0: '參數堆疊基址重定位'
# 'Argument to pass to the CompilerInvocation'
H3D79343D82D3: '要傳遞給 CompilerInvocation 的參數'
# 'Arguments passed onto the interesting-ness test'
H2C80A4DD32DD: '傳遞到 interesting-ness 測試的參數'
# 'Arm Performance Libraries'
H044D40FECAA8: 'Arm效能函式庫'
# 'Array subrange.'
HC09EA244D244: '陣列子範圍'
# 'Array.'
H75555184EF20: '陣列。'
# 'As secure log file name'
H1E6AE7BB635A: '作為安全日志文件名'
# 'As we import functions called from hot callsite, multiply the `import-instr-limit` threshold by this factor before processing newly imported functions'
HFC6F5302C981: '因為我們要導入熱呼叫位址調用的函數，因此在處理新導入的函數之前，將 `import-instr-limit` 閾值乘以此因子'
# 'As we import functions, multiply the `import-instr-limit` threshold by this factor before processing newly imported functions'
H807021E7830C: '在處理新導入的函數之前，將 `import-instr-limit` 閾值乘以此因子。因為我們導入函數時'
# 'Asm comments indentation'
HA72479C6AB4B: '組合語言註解縮排'
# 'Assemble a .s file (default)'
H6369F207FAFB: '組合 .s 檔案（預設）'
# 'Assembler instructions.'
H66538D7A1ED5: '組合語言指令。'
# 'Assembler line.'
H85B24622E0B1: '組合語言行。'
# 'Assert no nested parallel regions in the GPU'
H418AEEF6FF3F: '確保GPU中沒有嵌套的並行區域'
# 'Assert no thread in a parallel region modifies an ICV'
HBA986658A86D: '確保並行區域中的任何執行緒不會修改ICV（內部控制變數）'
# 'Assert that the compilation takes place in a freestanding environment'
H511BD8C1C674: '確保編譯在自由-standing環境中進行'
# 'Assign reference type allocas to local address space'
H59903DB020B4: '將引用類型的alloca指派給本地位址空間'
# 'Assign register bank of generic virtual registers'
H2974E89C9B08: '分配通用虛擬寄存器的寄存器庫'
# 'Assign valid PTX names to globals'
HB126730FBD94: '為全域變數分配有效的PTX名稱'
# 'Assignment Tracking Analysis'
H52ADB4784DA7: '賦值追蹤分析'
# 'Assigns WebAssembly register numbers for virtual registers'
H3989AF635266: '為虛擬寄存器分配WebAssembly寄存器號碼'
# 'Assume SVE vector registers are at least this big, with zero meaning no minimum size is assumed.'
H2E16603634C1: '假設SVE向量寄存器至少為此大小，零表示不假設最小大小。'
# 'Assume SVE vector registers are at most this big, with zero meaning no maximum size is assumed.'
H9D138AF1C883: '假設SVE向量寄存器至多為此大小，零表示不假設最大大小。'
# 'Assume V extension vector registers are at least this big, with zero meaning no minimum size is assumed. A value of -1 means use Zvl*b extension. This is primarily used to enable autovectorization with fixed width vectors.'
HD680D88BB0DC: '假設V擴展向量寄存器至少為此大小，零表示不假設最小大小。值為-1表示使用Zvl*b擴展。這主要用於啟用固定寬度向量的自動向量化。'
# 'Assume V extension vector registers are at most this big, with zero meaning no maximum size is assumed.'
H72E88FB1B9F8: '假設V擴展向量寄存器的最大大小為此值，0表示不假設有最大大小。'
# 'Assume all functions may be convergent.'
H4C995A5519E7: '假設所有函數可能是收斂函數。'
# 'Assume all functions with C linkage do not unwind'
H687362EE1CE8: '假設所有具有C連結的函數不會展開（unwind）'
# 'Assume all non-trivial loops are finite.'
HE8DEA9F53022: '假設所有非平凡迴圈是有限的。'
# 'Assume data segments are relative to text segment'
HDE84E251972D: '假設資料段相對於文本段是相對的'
# 'Assume distributed loops do not have more iterations than participating teams.'
H40EE5717199D: '假設分佈式迴圈的迭代次數不會超過參與的團隊數量。'
# 'Assume no atomic operations on fine-grained memory'
H63C989F614F3: '假設不會在細粒度記憶體上執行原子操作'
# 'Assume no atomic operations on remote memory'
H0DEE4D7E8196: '假設不會在遠端記憶體上執行原子操作'
# "Assume that exception objects' destructors are non-throwing"
HA13DECB16694: '假設例外物件的析構函數不會拋出例外'
# 'Assume that execution stops at trap instruction'
HFD7E94900060: '假設在trap指令處會終止執行'
# 'Assume that externally defined data is in the small data if it meets the -G <size> threshold (MIPS)'
H79ED681B6E82: '假設外部定義的資料如果符合-G<size> 閾值（MIPS），則位於小資料段中'
# 'Assume that kernels are launched with uniform block sizes (default true for CUDA/HIP and false otherwise)'
HA763A763DA9A: '假設核函數是以統一區塊大小啟動（預設CUDA/HIP為true，其他為false）'
# 'Assume that no thread in a parallel region will encounter a parallel region.'
HCB2AEFAC7594: '假設平行區域中的所有執行緒不會遇到平行區域。'
# 'Assume that no thread in a parallel region will modify an ICV.'
HF1302F78B04D: '假設平行區域中的所有執行緒不會修改ICV（執行時環境變數）。'
# 'Assume that overflowing float-to-int casts are undefined (default)'
HCD9EDFDB1A53: '假設溢出的浮點轉整數轉換是未定義行為（預設）'
# 'Assume that the precompiled header is a precompiled preamble covering the first N bytes of the main file'
H9D4E9ACCBF56: '假設預編譯的前置（preamble）覆蓋主檔的前N個字節'
# 'Assume that the product of the two iteration trip counts will never overflow'
HE37E63049A0E: '假設兩個迭代次數乘積不會溢出'
# 'Assume that top byte of an address is ignored'
H9BFCB8929B9A: '假設位址的最高位元會被忽略'
# 'Assume the input has already undergone ThinLTO function importing and the other pre-optimization pipeline changes.'
H2CA2E2C1C103: '假設輸入已經完成ThinLTO函數導入，並經歷其他預優化管線變更。'
# 'Assume the module is loaded at the specified address'
H85B7A3226995: '假設模組加載在指定地址'
# 'Assume the non latch exit block to be predictable'
HEBCC8B6F378D: '假設非Latch退出區塊為可預測的'
# 'Assume thread-local variables are defined in the executable'
H9F2FA53E0530: '假設執行個體變數定義在執行檔中'
# 'Assume work-shared loops do not have more iterations than participating threads.'
HF6F555EC0542: '假設共享工作迴圈的迭代次數不會超過參與的執行緒數。'
# 'Assumed aligned memory accesses.'
H1F99EB0F5177: '假設記憶體存取已對齊。'
# 'Assumed extra stack use if there are any variable sized objects (in bytes)'
HC8C97CA4569F: '如果存在可變大小物件，假設額外的堆疊使用量（以位元組為單位）'
# 'Assumed stack use of any external call (in bytes)'
H4EA740EFEAD0: '假設任何外部呼叫的堆疊使用量（以位元組為單位）'
# 'Assumption Cache Tracker'
HD200FE62329F: '假設快取追蹤器'
# 'At top of block or after label'
H305A8BE31E6D: '在區塊頂端或標籤之後'
# 'Attach debug info to a function'
H08A666FD7289: '將除錯資訊附加到函數'
# 'Attach debug info to everything'
HED658EC60D0F: '將除錯資訊附加到所有內容'
# 'Attempt coalescing during PBQP register allocation.'
H7648F369F9C7: '在PBQP暫存器配置期間嘗試合併。'
# 'Attempt to allocate array temporaries on the stack, no matter their size'
H1898E5AD9AA7: '無論大小如何，嘗試將陣列暫存器配置在堆疊上'
# 'Attempt to drop solution if it is less profitable'
H339D061FB39B: '如果解決方案獲利較低，則嘗試放棄'
# 'Attempt to match the ABI of Clang <version>'
H0603A0819A4F: '嘗試符合Clang <version> 的ABI'
# 'Attempt to vectorize for this register size in bits'
HC4E22D3921AE: '嘗試根據暫存器大小（以位元為單位）進行向量化'
# 'Attempt to vectorize horizontal reductions'
H7D29B593C54B: '嘗試向量化水平歸約'
# 'Attempt to vectorize horizontal reductions feeding into a store'
H86C2FB57AC78: '嘗試向量化輸入儲存的水平歸約'
# 'Attribute Options'
H80A446F5E125: '屬性選項'
# "Attribute all functions' range with zero count even it's not hit by any samples."
H6A8CFBBE8142: '即使未被任何樣本命中，仍將所有函數的範圍標記為零次數。'
# 'Auto-generates preprocessed source files and a reproduction script'
H2B36EB61E3F1: '自動產生預處理來源檔和重現腳本'
# 'Automatically put hot code on 2MB page(s) (hugify) at runtime. No manual call to hugify is needed in the binary (which is what --hot-text relies on).'
H0155A65DE424: '在執行階段自動將熱代碼置於 2MB頁面（hugify）。在可執行檔中不需要手動呼叫hugify（這是--hot-text所依賴的）。'
# 'Auxiliary target triple.'
H7C66B9F24C8E: '輔助目標三元組。'
# 'Average inst/cycle when no target itinerary exists.'
HAC1A1866B355: '當目標行程表不存在時的平均inst/cycle。'
# 'Avoid FPU mode dependent operations when used with the O32 ABI'
HFD29595F0062: '在使用O32 ABI時避免依賴FPU模式的操作'
# 'Avoid logging potentially-sensitive request details'
H7AE408773694: '避免記錄可能敏感的請求細節'
# 'Avoid optimizing x86 call frames for size'
HEAFF156A02EB: '避免針對x86調用框架進行大小優化'
# 'Avoid translating the elements of DICompositeTypes during the LLVM IR import (discouraged: testing only!)'
H92E0AEF9C7F0: '在LLVM IR導入期間避免轉譯DICompositeTypes的元素（不建議：僅供測試！）'
# 'Avoid using scaled registers with vscale-relative addressing'
H9CD1A0FBC370: '避免使用帶有vscale相對位址的縮放寄存器'
# 'BAT dump options'
HE7548A5409DC: 'BAT傾印選項'
# 'BC Analyzer Options'
H4B23BE663585: 'BC分析器選項'
# 'BOLT - Binary Optimization and Layout Tool\n'
H01223DC88456: 'BOLT - 可執行檔優化與佈局工具\n'
# 'BOLT generic options'
H833927334F93: 'BOLT通用選項'
# 'BOLT instrumentation options'
H236274761B58: 'BOLT插樁選項'
# 'BOLT optimization options'
HF7FB7C2D71C6: 'BOLT優化選項'
# 'BOLT options in relocation mode'
H72F40B1DAEF4: 'BOLT在重定位模式下的選項'
# 'BOLTDIFF generic options'
HBCE6535FC79B: 'BOLTDIFF通用選項'
# 'BPF Check And Adjust IR'
H4D7204899754: 'BPF 檢查並調整IR'
# 'BPF DAG->DAG Pattern Instruction Selection'
H7C44CC075E35: 'BPF DAG→DAG 模式指令選擇'
# 'BPF MachineSSA Peephole Optimization For ZEXT Eliminate'
H1FCC7FDAD7BB: 'BPF MachineSSA 小孔優化以消除ZEXT'
# 'BPF PreEmit Checking'
H9D3E8CD483F5: 'BPF 預發射檢查'
# 'BPF PreEmit Peephole Optimization'
H9917446E38FB: 'BPF 預發射窥孔最佳化'
# 'BPF PreEmit SimplifyPatchable'
HD1C3DD579B0E: 'BPF 預發射簡化可修補'
# 'BPF: Disable Avoiding Speculative Code Motion.'
HA01C55FDDABF: 'BPF: 禁用避免猜測式程式移動。'
# 'BPF: Disable Serializing ICMP insns.'
H688F09F03EC9: 'BPF: 禁用序列化ICMP指令。'
# 'Bail out on unprofitable SCoPs before rescheduling'
HD7D2870382BF: '在重新排程前放棄無效益的SCoPs'
# 'Base Directory for generated documentation.\nURLs will be rooted at this directory for HTML links.'
HD430D315BE29: '生成文件的基本目錄。\nURL將以該目錄作為HTML連結的根目錄。'
# 'Base Type (int, bool, etc.).'
H7F681232E46A: '基本類型（int、bool等）。'
# 'Base cost of vector insert/extract element'
HA29AACEEF76F: '向量插入/提取元素的基本成本'
# 'Base file path for the interactive mode. The incoming filename should have the name <inliner-interactive-channel-base>.in, while the outgoing name should be <inliner-interactive-channel-base>.out'
HED13A1932932: '互動模式的基本檔案路徑。輸入檔名應為 <inliner-interactive-channel-base>.in，輸出檔名則為 <inliner-interactive-channel-base>.out'
# 'Base file path for the interactive mode. The incoming filename should have the name <regalloc-evict-interactive-channel-base>.in, while the outgoing name should be <regalloc-evict-interactive-channel-base>.out'
HEEBA85373FA8: '互動模式的基本檔案路徑。輸入檔名應為 <regalloc-evict-interactive-channel-base>.in，輸出檔名則為 <regalloc-evict-interactive-channel-base>.out'
# 'Base file path for the interactive mode. The incoming filename should have the name <regalloc-priority-interactive-channel-base>.in, while the outgoing name should be <regalloc-priority-interactive-channel-base>.out'
H9411EE803DAA: '互動模式的基本檔案路徑。輸入檔名應為 <regalloc-priority-interactive-channel-base>.in，輸出檔名則為 <regalloc-priority-interactive-channel-base>.out'
# 'Base penalty for splitting cold code (as a multiple of TCC_Basic)'
H9A157E9C325A: '分割冷代碼的基本懲罰值（TCC_Basic的倍數）'
# 'Base types (int, bool, etc.).'
H6DA8FED6F2CE: '基本類型（int、bool等）。'
# 'Basic Alias Analysis (stateless AA impl)'
H5B13D0BE4C70: '基本別名分析（無狀態AA實作）'
# 'Basic Block Frequency'
H288285DDFDA1: '基本區塊執行頻率'
# 'Basic Block Placement Stats'
H907EA5CFB1D6: '基本區塊置放統計'
# 'Basic Register Allocator'
H79DC6E995B15: '基本寄存器配置器'
# 'Basic algebraic expansions of complex arithmetic operations involving are disabled.'
HDF7A39346B61: '涉及複數算術運算的基本代數展開已禁用。'
# 'Basic algebraic expansions of complex arithmetic operations involving are enabled.'
H262F35B467F4: '涉及複數算術運算的基本代數展開已啟用。'
# 'Basic attributes alias.'
HE45CB3A77EAA: '基本屬性別名。'
# 'Basic block limit for a function for RDF optimizations'
H4FCE83C0EE11: 'RDF 優化中函數的基本區塊限制'
# 'Basic block.'
H0E36AB3035D5: '基本區塊。'
# 'Basic register allocator'
HAA9EC9D57F33: '基本寄存器配置器'
# 'Be more conservative in ARM load/store opt'
HDDB9289EB602: '在ARM載入/儲存優化中更保守'
# 'Before everything'
HD2BEA8D1D530: '在所有之前'
# 'Best scheduler for the target'
H5C9427319FEA: '目標的最佳排程器'
# 'Binary encoding'
H2B45E735D11B: '二進位編碼'
# 'Binary encoding (default)'
H75E6792272B3: '二進位編碼（預設）'
# 'BinaryAnalysis\n'
HC08403F87EF1: '二進位分析\n'
# 'BinaryAnalysis options'
H0030C9E3CDAC: '二進位分析選項'
# 'Bit simplification'
HD2769EDD49F1: '位元簡化'
# 'Bit size of immediate TLS offsets'
HE94155328C5F: '立即TLS偏移量的位元大小'
# 'Bitstream'
HA8A9704FB47E: '位元流'
# 'Bitwidth of the index type for the host (warning this should be 64 until the GPU layering is fixed)'
H1A2F700B75FE: '主機的索引類型位元寬度（警告：在GPU層次結構修復前應設為 64）'
# 'Block Frequency Analysis'
H0F710FC006A0: '區塊頻率分析'
# 'Block frequency percentage a loop exit block needs over the original exit to be considered the new exit.'
H1B72423F0425: '迴圈退出區塊的頻率百分比需超過原始退出區塊，才視為新退出區塊。'
# 'Block until the parser can be used'
H1C8FDBE8C1C0: '阻塞直到解析器可以使用'
# 'Bottom-up register pressure aware list scheduling which tries to balance ILP and register pressure'
H9D996A6F7F40: '自底向上、考量寄存器壓力的清單排程，嘗試平衡ILP與寄存器壓力'
# 'Bottom-up register pressure aware list scheduling which tries to balance latency and register pressure'
H394C581D41AA: '自底向上、考量寄存器壓力的清單排程，嘗試平衡延遲與寄存器壓力'
# 'Bottom-up register reduction list scheduling'
H669DA6589497: '自底向上、減少寄存器使用的清單排程'
# 'Bound on stack depth while inlining (4 by default)'
H517AFAFA9D42: '內聯時堆疊深度的限制（預設為 4）'
# 'Bound the dependence analysis by a maximal amount of computational steps (0 means no bound)'
H649A261EB1B0: '依存性分析的計算步驟上限（0 表示無限制）'
# 'Bound the scheduler by maximal amountof computational steps. '
H51E6C0F8C158: '調度器的計算步驟上限。'
# 'Bound the scop analysis by a maximal amount of computational steps (0 means no bound)'
H82EB650E9442: 'SCOPO分析的計算步驟上限（0 表示無限制）'
# 'Branch Coalescing'
H2DBEA167A999: '分支合併'
# 'Branch Probability'
HC336B7481E8C: '分支機率'
# 'Branch Probability Analysis'
HE38E9B0A525A: '分支機率分析'
# 'Branch Probability Basic Block Placement'
H87FA8A5489AA: '基於分支機率的基本區塊配置'
# 'Branch relaxation pass'
H6AFFC7671D8D: '分支鬆弛優化pass'
# 'Break backedge through symbolic execution of 1st iteration attempting to prove that the backedge is never taken'
HE2539A780F40: '透過第一輪迭代的符號執行來切斷後跳邊，嘗試證明此後跳邊從未被執行'
# 'Break critical edges in CFG'
HD9D1E732D541: '切斷控制流圖中的關鍵邊'
# 'Break large PHI nodes for DAGISel'
HCF5413A8839F: '為DAGISel分解大型 PHI 節點'
# 'Break post-RA scheduling anti-dependencies: "critical", "all", or "none"'
H75472E865DE3: '分解後排列期的反依賴關係：「critical」、「all」或「none」'
# 'BreakFalseDeps'
H5FF559A5250F: 'BreakFalseDeps'
# 'Breakdown the count by function name taking into consideration the filepath info from the DebugLoc of the remark.'
HC1EFEB5BC743: '根據函數名稱分解計數，並根據DebugLoc的文件路徑資訊進行區分'
# 'Breakdown the count by function name.'
H55D8DD7267D8: '根據函數名稱分解計數。'
# 'Bucket number per loop for PPC loop chain common'
H095EE2A27794: 'PPC迴圈鏈接公用的每個迴圈桶數'
# 'Buffer the last N characters of debug output until program termination. [default 0 -- immediate print-out]'
HEA243B6BB971: '緩衝程式終止前的最後N個除錯輸出字元。[預設值 0 — 立即輸出]'
# "BugPoint Test Pass - Intentionally 'misoptimize' CallInsts"
H89AAE42B7AE6: 'BugPoint測試pass — 故意「誤優化」CallInsts'
# 'BugPoint Test Pass - Intentionally crash on CallInsts'
HDE32B6B83F4F: 'BugPoint測試pass — 故意在CallInsts處崩潰'
# 'BugPoint Test Pass - Intentionally crash on declared functions'
H42F2EE82DA8D: 'BugPoint 測試 Pass - 故意在宣告的函數上崩潰'
# 'BugPoint Test Pass - Intentionally crash on fabs calls with fpmath metadata and an fadd as argument'
H1E926C1BB889: 'BugPoint 測試 Pass - 故意在具有 fpmath 元數據且參數為 fadd 的 fabs 呼叫時崩潰'
# "BugPoint Test Pass - Intentionally crash on function attribute 'bugpoint-crash'"
H05C0FF4CFB70: "BugPoint 測試 Pass - 故意在函數屬性 'bugpoint-crash' 上崩潰"
# 'BugPoint Test Pass - Intentionally crash on too many CUs'
H8C6E2ED6A47E: 'BugPoint 測試 Pass - 故意在過多的 CUs 時崩潰'
# 'Build ASTs and convert to LLVM, discarding output'
HFD98A9A1FB1A: '建立 ASTs 並轉換為 LLVM，丟棄輸出'
# 'Build ASTs and print the list of declaration node qualified names'
HCB31A5A33A8E: '建立 ASTs 並印出宣告節點的限定名稱清單'
# 'Build ASTs and then debug dump their name lookup tables'
HB898C7F894F2: '建立 ASTs 並然後進行除錯傾印其名稱查找表'
# 'Build ASTs and then debug dump them'
H7902F2D13330: '建立 ASTs 並然後進行除錯傾印它們'
# 'Build ASTs and then debug dump them in the specified format, forcing deserialization. Supported formats include: default, json'
HE96A00FC958F: '建立 ASTs 並然後以指定格式進行除錯傾印，強制進行反序列化。支援的格式包括：default、json'
# 'Build ASTs and then debug dump them in the specified format. Supported formats include: default, json'
H92BA7F1490EF: '建立 ASTs 並然後以指定格式進行除錯傾印。支援的格式包括：default、json'
# 'Build ASTs and then debug dump them, forcing deserialization'
HEE028C067F24: '建立 ASTs 並然後進行除錯傾印，強制進行反序列化'
# 'Build ASTs and then lower to ClangIR'
HDF4F258BFB65: '建立 ASTs 並然後轉換為 ClangIR'
# 'Build ASTs and then pretty-print them'
H9599366C5CC9: '建立 ASTs 並然後美觀印出它們'
# 'Build ASTs and view them with GraphViz'
H03B49E6509AA: '建立 ASTs 並用 GraphViz 檢視它們'
# 'Build ASTs then convert to LLVM, emit .bc file'
H3D999491C902: '建立 ASTs 再轉換為 LLVM，產生 .bc 檔案'
# 'Build VPlan for every supported loop nest in the function and bail out right after the build (stress test the VPlan H-CFG construction in the VPlan-native vectorization path).'
HE361DC02BCE3: '為函數中每個支援的循環巢狀結構建立 VPlan，並在建構後立即退出（用於測試 VPlan-native 向量化管線中的 VPlan H-CFG 建構的壓力測試）。'
# 'Build a C++20 Header Unit from a header'
H9A493A45835C: '從標頭建立 C++20 標頭單元'
# 'Build a C++20 Header Unit from a header that should be found in the user (fmodule-header=user) or system (fmodule-header=system) search path.'
H0DC1129B500A: '建立一個 C++20 標頭單元，其標頭應位於使用者（fmodule-header=user）或系統（fmodule-header=system）搜尋路徑中。'
# 'Build for HVX v60'
H5F194250AE06: '針對 HVX v60 進行建置'
# 'Build for HVX v62'
HAFED34899A8C: '針對 HVX v62 進行建置'
# 'Build for HVX v65'
H207B9B2D5225: '構建HVX v65版本'
# 'Build for HVX v66'
HEA3895BB213D: '構建HVX v66版本'
# 'Build for HVX v67'
H42B647301419: '構建HVX v67版本'
# 'Build for HVX v68'
H77FF21179BCC: '構建HVX v68版本'
# 'Build for HVX v69'
H905F9940179D: '構建HVX v69版本'
# 'Build for HVX v71'
H165F94AD0A42: '構建HVX v71版本'
# 'Build for HVX v73'
H67E019A7BE26: '構建HVX v73版本'
# 'Build for HVX v75'
HEB883439B283: '構建HVX v75版本'
# 'Build for HVX v79'
H231DD2C4D603: '構建HVX v79版本'
# 'Build for Hexagon V5'
H1C71E9B94F5C: '構建Hexagon V5版本'
# 'Build for Hexagon V55'
H58046BC87A11: '構建Hexagon V55版本'
# 'Build for Hexagon V60'
H05D6BD8DE043: '構建Hexagon V60版本'
# 'Build for Hexagon V62'
H397E863A80C2: '構建Hexagon V62版本'
# 'Build for Hexagon V65'
HD1EC00E09426: '構建Hexagon V65版本'
# 'Build for Hexagon V66'
HE5554963D68F: '構建Hexagon V66版本'
# 'Build for Hexagon V67'
H87AB7CC8B603: '構建Hexagon V67版本'
# 'Build for Hexagon V67T'
HB3C7C60D0839: '構建Hexagon V67T版本'
# 'Build for Hexagon V68'
H712B082469B0: '構建Hexagon V68版本'
# 'Build for Hexagon V69'
H33FDB62409F4: '構建Hexagon V69版本'
# 'Build for Hexagon V71'
HF8AB85CAF9EB: '構建Hexagon V71版本'
# 'Build for Hexagon V71T'
H6AC6FBE66236: '為Hexagon V71T構建'
# 'Build for Hexagon V73'
H7840346BDBBB: '為Hexagon V73構建'
# 'Build for Hexagon V75'
HB923BD289BC7: '為Hexagon V75構建'
# 'Build for Hexagon V79'
H860D9669E777: '為Hexagon V79構建'
# 'Build path'
H51B665BD227F: '構建路徑'
# 'Build the parse tree, then lower it to FIR'
H5AA5D4111927: '構建解析樹，然後轉換為FIR'
# 'Build the parse tree, then lower it to HLFIR'
H209B3028A0CD: '構建解析樹，然後轉換為HLFIR'
# 'Build this module as a system module. Only used with -emit-module'
HF896829DCA95: '將此模塊構建為系統模塊。僅與-emit-module一起使用'
# 'Bundle Machine CFG Edges'
H7815BA6F9789: '捆綁機器控制流圖邊'
# 'Bundle output files of HIP device compilation'
HCA7306204A95: '捆綁HIP裝置編譯的輸出文件'
# 'Burnside Bridge Compiler\n'
H5B149431AA40: 'Burnside Bridge 編譯器\n'
# 'By default, we analyze the benchmarks for the triple/CPU they were measured for, but if you want to analyze them for some other combination (specified via -mtriple/-mcpu), you can pass this flag.'
H76350EEAD124: '預設情況下，我們會分析基準測試所針對的triple/CPU組合，但如果您想分析其他組合（透過-mtriple/-mcpu指定），可以使用此選項。'
# 'Bypass the profitability model of load slicing'
H3E3A7818BD1C: '旁路載入分割的收益模型'
# 'C does not support default arguments'
H9634D9BB0DF6: 'C語言不支援預設參數'
# 'C requires #line number to be less than %0, allowed as extension'
H2FF7FD761591: 'C語言要求#line行號必須小於 %0，但作為擴展允許'
# 'C requires a comma prior to the ellipsis in a variadic function type'
HF2B9DE1954B1: 'C語言要求在可變參數函數類型中的省略號前要有逗號'
# "C++ ABI '%0' is not supported on target triple '%1'"
H00336F051C87: "C++ ABI '%0' 不支援目標triple '%1'"
# 'C++ ABI to use. This will override the target C++ ABI.'
H9B471B29FD3A: '要使用的C++ ABI。這將覆蓋目標C++ ABI。'
# 'C++ implementation file name'
HE4F416D1C66F: 'C++實作檔名稱'
# 'C++ operator %0 (aka %1) used as a macro name'
H2A2A24E029F0: 'C++運算子 %0（即 %1）被用作預處理宏名稱'
# 'C++ standard library to use'
HEE4D104DB34B: '使用的C++標準程式庫'
# 'C++11 only allows consecutive left square brackets when introducing an attribute'
H2040F8CA0C12: 'C++11僅允許在引入屬性時使用連續的左方括號'
# 'C++98 requires an accessible copy constructor for class %2 when binding a reference to a temporary; was %select{private|protected}0'
H89F3A4330FF6: 'C++98在將暫時物件綁定為引用時，要求類別 %2 具有可存取的複製建構函式；目前為%select{私有|受保護}0'
# 'C99 forbids casting nonscalar type %0 to the same type'
H26E6559D43AC: 'C99禁止將非純量類型 %0 轉換為相同的類型'
# 'C99 forbids conditional expressions with only one void side'
HD3A412BC601A: 'C99禁止條件運算式僅有一邊為void類型'
# 'CF object of type %0 is bridged to %1, which is not an Objective-C class'
H41EE49AD057C: '類型 %0 的 CF 物件被橋接至 %1，但此並非 Objective-C 類別'
# 'CFGuard'
H6826B8A9825A: 'CFGuard'
# 'CFI Verify Options'
H72E6B238AC79: 'CFI驗證選項'
# 'CFString literal is not a string constant'
H89C093890935: 'CFString文字不是字串常數'
# 'CHR considers a branch bias greater than this ratio as biased'
HDF87AB6569F2: 'CHR將大於此比率的分支偏置視為有偏'
# 'CHR merges a group of N branches/selects where N >= this value'
H5C657F973B2B: 'CHR合併N個分支/選擇子，其中N大於或等於此值'
# 'CIR module verification error before running CIR-to-CIR passes'
H045DC8C3B34D: '執行CIR-to-CIR pass前的CIR模組驗證錯誤'
# 'CIR-to-CIR transformation failed'
H9F8DAC16F05E: 'CIR-to-CIR轉換失敗'
# 'CL.EXE COMPATIBILITY OPTIONS'
H505EEFB93C8E: 'CL.EXE相容選項'
# 'COFF Symbol RVAs (DEBUG_S_COFF_SYMBOL_RVA subsection)'
HFE26A86E5CFD: 'COFF符號RVAs（DEBUG_S_COFF_SYMBOL_RVA子區段）'
# "CPU '%0' does not support '%1' execution mode"
H489FB3B6F514: "CPU '%0' 不支援 '%1' 執行模式"
# 'CPU list contains duplicate entries; attribute ignored'
H40F374760829: 'CPU清單包含重複項目；屬性被忽略'
# 'CSKY DAG->DAG Pattern Instruction Selection'
H21AAA3835725: 'CSKY DAG→DAG模式指令選擇'
# 'CSKY constant island placement and branch shortening pass'
H1AC93DA4EF44: 'CSKY常數島配置與分支縮短pass'
# 'CSS stylesheets to extend the default styles.'
H9DE4F76128DB: '用於擴展預設樣式的CSS樣式表。'
# 'CUDA device code does not support va_arg'
H3A59FE235409: 'CUDA 裝置代碼不支援 va_arg'
# 'CUDA device code does not support variadic functions'
H218B98CDADDE: 'CUDA 裝置代碼不支援可變參數函數'
# 'CUDA does not support global %0 for __device__ functions'
H8DC2F94408E4: 'CUDA 不支援 __device__ 函數的全域 %0'
# 'CUDA installation path'
H42DE34B3E373: 'CUDA 安裝路徑'
# 'CUDA offload target is supported only along with --emit-llvm'
H1424A8C5858B: 'CUDA 卸載目標僅在搭配 --emit-llvm 時支援'
# 'CUDA older than 10.0 does not support .alias'
H4BD47BC9C21A: '版本小於 10.0 的 CUDA 不支援 .alias'
# "CUDA special function '%0' must have scalar return type"
H4386F29D7C1C: "CUDA 特殊函數 '%0' 必須具有純量返回類型"
# 'CUDA version %0 is only partially supported'
HABB5F3AD45B9: 'CUDA 版本 %0 僅部分支援'
# 'CUDA version%0 is newer than the latest%select{| partially}1 supported version %2'
HC8470F3A3C10: 'CUDA 版本 %0 比最新 %select{| 部分}1支援的版本 %2 更新'
# 'CXX Dump Options'
HEC70FF6EBB76: 'CXX 輸出選項'
# 'CXX Map Options'
H4ACF6390C9B8: 'CXX 映射選項'
# 'Cache Directory'
HBD7A05972161: '快取目錄'
# 'Calculate the intrinsic cost based only on argument types'
H204B60BE4CD1: '僅根據參數類型計算內在成本'
# 'Call nonlazybind functions via direct GOT load for Mach-O'
H734541906E0F: '透過直接 GOT 載入呼叫 nonlazybind 函數（適用於 Mach-O）'
# 'Call penalty that is applied per callsite when inlining'
HF8A8A3618DB8: '內嵌時每呼叫位址所套用的處罰值'
# 'Call score power (when --split-strategy=cdsplit)'
H657B2E4D7127: '呼叫分數次方（當 --split-strategy=cdsplit 時）'
# 'Call score scale coefficient (when --split-strategy=cdsplit)'
H3C68D9A52C2C: '呼叫分數比例係數（當 --split-strategy=cdsplit 時）'
# 'Call site block.'
H1A44C6CE10A5: '呼叫位址區塊。'
# 'Call site parameter.'
H13AFDEB70D71: '呼叫位址參數。'
# 'CallGraph Construction'
H59F475A8E976: '呼叫圖建構'
# 'Can specify at most '
H04A2B40FE103: '最多可指定 '
# 'Canonicalize Freeze Instructions in Loops'
HA0687B0F1DED: '在迴圈中規範化 Freeze 指令'
# 'Canonicalize natural loops'
H36CFB482F86F: '規範化自然迴圈'
# 'Capture the number of times a stack was invoked. In flamegraph mode, this count also includes invocations of all callees.'
HC70FACC6E899: '捕獲堆疊被調用的次數。在火焰圖模式下，此計數還包括所有被調用函數的調用次數。'
# 'Capture the total time spent in an all invocations of a stack.'
H44E274E610C2: '捕獲所有堆疊調用所消耗的總時間'
# 'Causes the backend to crash instead of generating a nop VSX copy'
H3232545B99E1: '若後端無法生成 nop VSX 複製指令，則強制中斷'
# 'Change byte and word instructions to larger sizes'
HEF144CF00477: '將位元組與單字指令改為更大的尺寸'
# 'Change diagnostic formatting to match IDE and command line tools'
H8A6273359475: '調整診斷格式以符合 IDE 和命令列工具的顯示'
# 'Change indirect jump instructions to inhibit speculation'
H3608CF11CF48: '修改間接跳轉指令以抑制預測執行'
# 'Change namespace.'
H43653D361A25: '變更命名空間。'
# 'Change the C++ ABI to returning `this` pointer from constructors and non-deleting destructors. (No effect on Microsoft ABI)'
H33EEEB0B1310: '變更 C++ ABI 使建構子與非刪除式析構子回傳 `this` 指標。（對 Microsoft ABI 無效）'
# "Change the greedy register allocator's live range priority calculation to make the AllocationPriority of the register class more important then whether the range is global"
H8D990FD681E2: '調整贪婪寄存器配置器的存活範圍權重計算，使寄存器類別的權重優先於全域範圍屬性'
# 'Change variadic calling convention'
HD4EADD7ABB24: '變更可變參數呼叫約定'
# 'Check CFA info and insert CFI instructions if needed'
HB1FAB917FF49: '檢查 CFA 資訊並依需求插入 CFI 指令'
# 'Check debug info from -debugify'
H8AF6D59AB27A: '檢查 -debugify 產生的除錯資訊'
# 'Check debug info from -debugify-function'
HE67C041D8BED: '檢查來自 -debugify-function 的除錯資訊'
# 'Check elements integrity.'
HEA4B7C7680A0: '檢查元素完整性。'
# 'Check floating-point load'
H7623BFCEEC52: '檢查浮點數載入'
# 'Check floating-point return values'
H59EBDCF68E8C: '檢查浮點數傳回值'
# 'Check floating-point stores'
H27184F67D1D6: '檢查浮點數儲存'
# 'Check for parallel loops'
H86C1DC29F0D4: '檢查平行迴圈'
# 'Check for vectorizable loops'
H3CD8604AF754: '檢查可向量化迴圈'
# 'Check if block frequency is queried for an unknown block for debugging missed BFI updates'
H105B69431A40: '檢查是否在除錯時未更新BFI的未知區塊查詢區塊頻率'
# 'Check if input heterogeneous archive is valid in terms of TargetID rules.\n'
HA0A80D536062: '檢查輸入異質存檔是否符合TargetID規則。\n'
# 'Check module hash using the argument as a string table'
H43F3CCEA9F64: '使用字串表格檢查模組雜湊'
# 'Check pointer authentication auth/resign failures'
HBEEB7E32E077: '選擇DWARF調試區段的壓縮方式:'
# 'Check stack-use-after-scope'
H899C3D082FBF: '選擇輸出檔案類型:'
# 'Check that emitted diagnostics match expected-* lines on the corresponding line'
H0CFA18038D08: '選擇輸出檔案類型:'
# 'Check the input source files from C++20 modules explicitly'
HA2774E416A4F: '選擇分析器要停用的檢查器'
# 'Chip to use to serialize to cubin.'
H07B7361E60E0: '選擇分析器要啟用的檢查器'
# 'Choose DWARF debug sections compression:'
H2B65135A807B: '選擇分析器要啟用的選項'
# 'Choose a file type (not all types are supported by all targets):'
HAA6114F47F11: '選擇程式碼模型'
# 'Choose an output file type:'
H92BDEF215C75: '選擇浮點ABI類型'
# 'Choose analyzer checkers to disable'
H77983530DA75: '檢查指標驗證認證/重新簽署失敗'
# 'Choose analyzer checkers to enable'
H41B48112BDF6: '檢查堆疊作用域後使用'
# 'Choose analyzer options to enable'
HCB7427D52FDE: '確認發出的診斷訊息與對應行的expected-*內容相符'
# 'Choose code model'
HA2B6154EBE1C: '明確從C++20模組輸入原始程式碼檔'
# 'Choose float ABI type'
HA37D38E85873: '用於序列化到cubin的晶片。'
# 'Choose large data threshold for x86_64 medium code model'
HE1DFA96AAF80: '選擇 x86_64 medium code model 的大數據閾值'
# 'Choose level of diagnostic information'
HD8EA761DDF80: '選擇診斷資訊的等級'
# 'Choose relocation model'
HD54EDB40A370: '選擇重定位模型'
# 'Choose speculation scheme'
HCB6C8E99AC45: '選擇推测方案'
# 'Choose style of NEON code to emit from AArch64 backend:'
H2D6E1D10E2D8: '選擇由AArch64後端產生的NEON代碼風格：'
# 'Choose the OpenMP library to use:'
HE50F5292F771: '選擇要使用的OpenMP函式庫：'
# 'Choose the dynamic linker/loader.'
H10D084FE139A: '選擇動態連結器/載入器。'
# 'Choose the number of compile threads (jit-kind=orc-lazy only)'
H098814BE3E37: '選擇編譯線程的數量（僅限jit-kind=orc-lazy）'
# 'Choose the priority mode to use in module inline'
H3DB5A6B44603: '選擇模組內聯時使用的优先模式'
# 'Choose the report output format:'
HAA84783D1EFB: '選擇報告輸出格式：'
# 'Choose the strategy to replace exit value in IndVarSimplify'
H3B106241E759: '選擇在IndVarSimplify中取代exit值的策略'
# 'Choose threading model'
HC20B03302377: '選擇線程模型'
# 'Choose to use MD5 to represent string in name table (only meaningful for -extbinary)'
H2AF20046DB81: '選擇在名稱表中使用MD5來表示字串（僅對-extbinary有意義）'
# 'Choose underlying JIT kind.'
HCA7AB9E73E1E: '選擇基礎的JIT類型。'
# 'Chunksize to use by the OpenMP runtime calls'
H9BE7E3A1146E: 'OpenMP執行時期呼叫使用的區塊大小'
# "Clang permits use of type 'double' regardless pragma if 'cl_khr_fp64' is supported"
H36E837B04A86: '若支援 "cl_khr_fp64"，Clang允許在無視pragma的情況下使用 "double" 類型'
# 'Clang-format options'
H5807AFA36D8E: 'Clang格式選項'
# 'ClangIR code gen Not Yet Implemented: %0'
HC54E3E6A2065: 'ClangIR代碼生成尚未實作：%0'
# 'ClangIR code gen Not Yet Implemented: %0: %1'
H56E1FD5A9575: 'ClangIR代碼生成尚未實作：%0：%1'
# 'ClangIR: Disable MLIR module verifier'
H751870E4D956: 'ClangIR：禁用MLIR模組驗證器'
# 'Class definition format'
HDB879BF08A12: '類別定義格式'
# 'Class recursion depth (0=no limit)'
HB9C55ABE5CC8: '類別遞迴深度（0=無限制）'
# 'Class sort order'
H85CBA379BBF6: '類別排序順序'
# 'Class, Structure or Union.'
H496FA9D4B718: '類別、結構或共用體。'
# 'Class.'
H148765CD0A8E: '類別。'
# 'Cleanup of TFRs/COPYs'
H9B2D2779E91B: '清理TFRs/COPYs'
# 'Clear call-used registers upon function return (AArch64/x86 only)'
H477A7A2C3A31: '在函數返回時清除被呼叫使用的寄存器（僅適用於AArch64/x86）'
# 'Clear the Clang AST before running backend code generation'
H25C2CBF7F396: '在執行後端程式碼生成前清除Clang AST'
# 'Clearance between two register writes for inserting XOR to avoid partial register update'
H72C3AC434C02: '在兩個寄存器寫入之間插入XOR以避免部分寄存器更新所需的間隔'
# 'Clone multicolor basic blocks but do not demote cross scopes'
H6C8216BC2E37: '複製多顏色基本區塊，但不降低跨作用域的層級'
# 'Coalesce copies (default=true)'
H8F39652946C0: '合併複製（預設=true）'
# 'Coalesce copies by rescheduling (default=true)'
H0B50CD5328B9: '透過重新排程合併複製（預設=true）'
# 'Coalesce copies on split edges (default=subtarget)'
H9B11258186AA: '在分離邊合併複製（預設=subtarget）'
# 'Coalesce copies that span blocks (default=subtarget)'
H60E87F9D68CA: '合併跨區塊的複製（預設=subtarget）'
# 'Code and read-only data relocatable, accessed PC-relative'
H7787A55DE1DB: '程式碼和唯讀資料可重新定位，以PC相對方式存取'
# 'Code growth limit for address mode optimization'
H68CE7F106A6D: '地址模式最佳化之程式碼增長限制'
# 'Code sinking'
H7049DF5F2CFA: '程式碼下沉'
# 'Code size'
H555486354DDF: '程式碼大小'
# 'Code size and latency'
H66FA420C1EB1: '程式碼大小與延遲'
# 'CodeGen (expected to match llc)'
HD2FDC55840F0: '程式碼生成（期望與llc相符）'
# "Codegen optimization level (0, 1, 2 or 3, default = '2')"
H0604F43896B4: "程式碼生成優化等級（0、1、2 或 3，預設值 = '2'）"
# 'Collect access count histograms'
HEFDB6DB25681: '收集存取次數直方圖'
# 'Collect control flow of function'
HECF6D002A2F5: '收集函數的控制流'
# 'Collect probability-driven block placement stats'
H3B3A74A7C1CA: '收集概率驅動的區塊放置統計資料'
# "Collect these seeds. Use empty for none or a comma-separated list of '"
H6FDC6608AD13: "收集這些種子。若無則留空，或使用逗號分隔的列表 '"
# 'Collects information ahead of time for MC lowering'
H247A53130B24: '提前收集MC降階前的資訊'
# 'Color Options'
HF1A7AFA23440: '顏色選項'
# 'Color for dot-cfg after elements'
HE6BC004D0C08: 'dot-cfg後方元素顏色'
# 'Color for dot-cfg before elements'
HCBAF257C085C: 'dot-cfg前方元素顏色'
# 'Color for dot-cfg common elements'
H49F473D0D7F3: 'dot-cfg通用元素顏色'
# 'Colored disassembly of strings of hex bytes'
H4E6D0548B4D8: '十六進位字節字符串的彩色反組裝'
# 'Combination of ropi and rwpi'
HFA6236DECFF7: 'ropi和rwpi的組合'
# 'Combine AArch64 MachineInstrs after legalization'
HD7E343321E16: 'AArch64機器指令在法規化後的合併'
# 'Combine AArch64 machine instrs before legalization'
H4D22AAB36024: '在法規化前合併AArch64機器指令'
# 'Combine AMDGPU machine instrs after legalization'
H2FD87CC8B39B: '法規化後合併AMDGPU機器指令'
# 'Combine AMDGPU machine instrs after regbankselect'
H372E81B03355: '在regbankselect後合併AMDGPU機器指令'
# 'Combine AMDGPU machine instrs before legalization'
H6682D3768EA0: '在法規化前合併AMDGPU機器指令'
# 'Combine Mips machine instrs after legalization'
HA03CAB5DCA3D: '在合法化後合併Mips機器指令'
# 'Combine Mips machine instrs before legalization'
H7EFE7A48A439: '在合法化前合併Mips機器指令'
# 'Combine RISC-V MachineInstrs after legalization'
H4BDB10B3DC9C: '法規化後合併RISC-V機器指令'
# 'Combine RISC-V machine instrs before legalization'
H358426A68073: '在合法化前合併RISC-V機器指令'
# 'Combine SPIRV machine instrs before legalization'
H7E2252FE6075: '在合法化前合併SPIRV機器指令'
# 'Combine ext and trunc to TBL'
H8DCB8DB3D191: '將擴展和截斷合併為TBL指令'
# 'Combine extends of AArch64 masked gather intrinsics'
HF9B54CB5AC6B: '合併AArch64被遮罩的gather內建函數的擴展'
# 'Combine interleaved loads into wide loads and shufflevector instructions'
HC7C7ED4923BB: '將交錯載入合併為寬載入和shufflevector指令'
# 'Combine redundant instructions'
H6A7B591C5F01: '合併冗餘指令'
# 'Combine the label of the offset with the label of the pointer when doing pointer arithmetic.'
HB7BD5BAE0A94: '在進行指標運算時，將偏移量的標籤與指標的標籤合併。'
# 'Combine the label of the pointer with the label of the data when loading from memory.'
H4B6E43BF4FF7: '從記憶體載入時，將指標的標籤與資料的標籤合併。'
# 'Combine the label of the pointer with the label of the data when storing in memory.'
H66A9D747B5EF: '儲存至記憶體時，將指標的標籤與資料的標籤合併。'
# 'Comma separated list of attribute names that are allowed to be seeded.'
H725610B9DAC4: '允許被初始化的屬性名稱的逗號分隔清單。'
# 'Comma separated list of debug counter skip and count'
H9FAFDA93ACE1: '調試計數器跳過和計數的逗號分隔清單。'
# 'Comma separated list of debug counter skip and count arguments'
H6FCA88B30FCF: '調試計數器跳過和計數參數的逗號分隔清單。'
# 'Comma separated list of files containing a new line separated list of API symbols to ignore when extracting API information.'
H4521BA006280: '包含需忽略的API符號清單（以新行分隔）的文件的逗號分隔清單，這些符號在提取API資訊時將被忽略。'
# 'Comma separated list of function names that are allowed to be seeded.'
HD18F456FDFD5: '允許被初始化的函數名稱的逗號分隔清單。'
# 'Comma separated list of functions to replace with native, or all'
HFF9C64BB9821: '要替換為本機函數的函數名稱的逗號分隔清單，或指定「全部」。'
# 'Comma separated list of globs for white-listing gcc-compatible drivers that are safe to execute. Drivers matching any of these globs will be used to extract system includes. e.g. /usr/bin/**/clang-*,/path/to/repo/**/g++-*'
H454E7FBEF67B: '用於白名單gcc相容且安全執行的驅動程式的通配符清單，符合其中任何一項的驅動程式將被用來提取系統包含路徑。例如：/usr/bin/**/clang-*,/path/to/repo/**/g++-*'
# 'Comma separated list of locations to filter actions from logging'
H089CBD249A00: '用於過濾日誌中動作的來源位置的逗號分隔清單。'
# "Comma-separated list of comment prefixes to use from check file\n(defaults to 'COM,RUN'). Please avoid using this feature in\nLLVM's LIT-based test suites, which should be easier to\nmaintain if they all follow a consistent comment style. This\nfeature is meant for non-LIT test suites using FileCheck."
H40AA0BE08629: '從檢查檔案使用的註解前綴的逗號分隔清單（預設為「COM,RUN」）。\n請避免在LLVM的LIT基礎測試套件中使用此功能，若所有套件均遵循一致的註解風格，將更易於維護。\n此功能主要針對使用FileCheck而非LIT的測試套件。'
# "Comma-separated list of globs describing the list of callbacks to output. Globs are processed in order of appearance. Globs with the '-' prefix remove callbacks from the set. e.g. '*,-Macro*'."
HB2EA0F3C4C38: "以逗號分隔的通配模式清單，描述要輸出的回呼。通配模式按出現順序處理。以 '-' 前綴的通配模式將從集合中移除回呼。例如：'*,-Macro*'。"
# 'Comma-separated list of vectorizer passes. If not set we run the predefined pipeline.'
H5F9267E8F02A: '向量化器pass的列表。若未設定則執行預定義的管線。'
# 'Command line options to pass to the downstream compiler.'
H24FC3F9175A2: '傳遞給下遊編譯器的命令列選項。'
# 'Command to compile the bitcode (use with -compile-custom) (default: llc)'
H3748E1E74688: '編譯位元碼的命令（與-compile-custom一起使用）（預設：llc）'
# 'Command to execute and then exit.'
H9D395E8BC35F: '執行並退出的命令。'
# 'Command to execute the bitcode (use with -run-custom) (default: simulate)'
H8B8E553AB463: '執行位元碼的命令（與-run-custom一起使用）（預設：simulate）'
# 'CommonOptionsParser: failed to parse command-line arguments. '
H6D048D13358D: 'CommonOptionsParser：無法解析命令列參數。'
# 'Compare Options'
H10812CD37717: '比較選項'
# 'Compare all elements.'
HD1160DBAE7C6: '比較所有元素。'
# 'Compare bits 62 and 61 of address (TBI should be disabled)'
HC1881DEFBF5A: '比較地址的第 62 和 61 位元（TBI應被禁用）'
# 'Compare with the result of XPAC (requires Armv8.3-a)'
HBA5A269FECBF: '與XPAC的結果進行比較（需要Armv8.3-a）'
# 'Compare with the result of XPACLRI'
HAAF036306B3E: '與XPACLRI的結果進行比較'
# 'Compilation YAML databases containing additional compilation information for .pdll files'
HE9807E72350C: '包含.pdll檔案額外編譯資訊的Compilation YAML資料庫'
# 'Compilation YAML databases containing additional compilation information for .td files'
HFBD096AE492B: '包含.td檔案額外編譯資訊的Compilation YAML資料庫'
# 'Compilation format to use to serialize to cubin.'
HB1FF55993026: '用於序列化到cubin的編譯格式。'
# 'Compile CUDA code for both host and device (default). Has no effect on non-CUDA compilations.'
H77D43CB7BF77: '編譯CUDA代碼給主機和裝置（預設）。對非CUDA編譯無影響。'
# 'Compile CUDA code for device only'
H15DCB9A13744: '僅編譯CUDA代碼給裝置'
# 'Compile CUDA code for host only. Has no effect on non-CUDA compilations.'
H0F42A4E8A53F: '僅編譯CUDA代碼給主機。對非CUDA編譯無影響。'
# 'Compile HIP source to relocatable'
HDC4174A29E78: '將HIP來源編譯為可重新定位的'
# 'Compile SYCL code for device only'
HC13E70999744: '僅編譯SYCL代碼給裝置'
# 'Compile SYCL code for host only. Has no effect on non-SYCL compilations'
HEB697C17E8BD: '僅編譯 SYCL 程式碼到主機。對非 SYCL 編譯無效'
# "Compile all functions that don't use floating point as Mips 16"
H5CC84DC9C7B5: '將未使用浮點數的所有函數編譯為Mips 16'
# 'Compile common globals like normal definitions'
HD71FBB30E436: '將常見全域變數編譯為一般定義'
# 'Compile for both the offloading host and device (default).'
H9A1D25E1163E: '編譯為外接主機和設備兩種模式（預設）。'
# 'Compile only'
H8E8E6B258925: '僅編譯'
# 'Compile unit.'
HD0B9CF45B690: '編譯單元。'
# 'Compile with LLC'
H0F009B4F1879: '使用 LLC 編譯'
# 'Compile with LLC with integrated assembler'
HEC7B02DFBAC4: '使用 LLC 並結合內嵌組譯器進行編譯'
# 'Compiler generated elements.'
HCD76E8AFE5EE: '編譯器產生的元素。'
# 'Compiler runtime library to use'
H8A88FADF9B7C: '要使用的編譯器執行階段函式庫'
# 'Complex Deinterleaving'
H7404ACD7E023: '複雜交错'
# 'Compress all sections when writing the profile (only meaningful for -extbinary)'
HCB671C4254BD: '寫入剖析資料時壓縮所有區段（僅在使用 -extbinary 時有效）'
# 'Compress offload device binaries (HIP only)'
H500BC9AF0B40: '壓縮外接裝置的二進位檔（僅適用 HIP）'
# 'Compress output file when bundling.\n'
HFEA3EDE7947A: '打包時壓縮輸出檔。\n'
# 'Compressing recursion by deduplicating adjacent frame sequences up to the specified size. -1 means no size limit.'
H30029AFB7F05: '通過去重相鄰的框架序列來壓縮遞迴，直到指定大小。-1 表示無大小限制。'
# 'Compression level for offload device binaries (HIP only)'
HAD420748A1D9: '外接裝置二進位檔的壓縮層級（僅適用 HIP）'
# 'Compute and report stale profile statistical metrics.'
H8415583C1A20: '計算並報告過期的剖析統計指標。'
# "Compute and store the hash of input files used to build an AST. Files with mismatching mtime's are considered valid if both contents is identical"
H9585117CC641: '計算並儲存用於建立抽象語法樹（AST）的輸入檔案雜湊值。若兩檔案的 mtime 不匹配但內容相同，則視為有效'
# 'Compute dead symbols'
H06FD59310A4C: '計算未使用的符號'
# 'Compute known content of array elements'
HF867A4592891: '計算陣列元素的已知內容'
# 'Compute mean of all readings'
H8282EDF1CC14: '計算所有測量值的平均值'
# 'Compute stale profile statistical metrics and write it into the native object file(.llvm_stats section).'
H2211EA0D1BE2: '計算過期的剖析統計指標並將其寫入本機物件文件（.llvm_stats 區段）'
# 'Compute the full inline cost of a call site even when the cost exceeds the threshold.'
HF635A2D8BE0B: '即使成本超過閾值，也要計算呼叫位置的完整內联成本'
# 'Conditions to use when printing elements.'
H57BD843032A5: '列印元素時使用的條件'
# 'Configure the polly loop optimizer'
H40019CBBC00E: '配置 Polly 迴圈最佳化器'
# 'Connect to an out-of-process executor through a TCP socket'
H89D591EB992E: '通過TCP套接字連接到外部執行程序'
# 'Connect to an out-of-process executor via TCP'
H84FC6B32A5A3: '透過TCP連接到外部執行程序'
# 'Consider R1 caller preserved so stack saves of caller preserved registers can be LICM candidates'
H7A2CC0A44257: '考慮R1調用者保留，以便將調用者保留寄存器的堆疊儲存作為LICM候選'
# 'Consider a profile matches a function if the similarity of their callee sequences is above the specified percentile.'
HE02A66F58798: '如果被呼叫函數序列的相似性超過指定的百分位數，則視為剖面符合函數'
# 'Consider all leaf descendants of internal nodes of the suffix tree as candidates for outlining (if false, only leaf children are considered)'
HCFBF788CDF8F: '考慮後綴樹內部節點的所有葉子後代為外殼化候選（如果為false，僅考慮葉子子節點）'
# 'Consider calls to be predicable'
HF4AE01562CCA: '將呼叫視為可預測'
# 'Constant Hoisting'
HA20E9E7B7D12: '常數提升'
# 'Constant specifier.'
H27C86387B88E: '常數指定項'
# 'Constant.'
H69328F1434C8: '常數'
# 'Context sensitive profile file path'
H6AAD89B511B3: '上下文敏感的剖面檔案路徑'
# 'Contiguously Lay Out Funclets'
H35F4CF635E0B: '連續排列Funclets'
# 'Continue if files are not mapped correctly.'
H0AB9362D475E: '如果檔案未正確映射則繼續'
# 'Control Flow Optimizer'
H072A594766A3: '控制流程最佳化器'
# 'Control conversion of memcpy to Tail predicated loops (WLSTP)'
HE778B3B33793: '控制將memcpy轉換為尾條件循環（WLSTP）'
# 'Control emission of Swift async extended frame info'
H02D3442EBA23: '控制Swift異步擴展框架資訊的發射'
# "Control how the assembler should align branches with NOP. If the boundary's size is not 0, it should be a power of 2 and no less than 32. Branches will be aligned to prevent from being across or against the boundary of specified size. The default value 0 does not align branches."
H8B5A4A325A23: '控制匯集器如何使用NOP對齊分支。若邊界的大小不為 0，則必須是 2 的冪次且至少為 32。分支將被對齊以避免跨過或逆向指定大小的邊界。預設值 0 不會對齊分支。'
# 'Control jump table emission on Hexagon target'
H6602FAB1D723: '控制Hexagon目標的跳轉表發射'
# 'Control lookup table emission on Hexagon target'
HAAA735B3BA36: '控制Hexagon目標的查找表發射'
# 'Control the CR-bit tracking feature on PowerPC. ``-mcrbits`` (the enablement of CR-bit tracking support) is the default for POWER8 and above, as well as for all other CPUs when optimization is applied (-O2 and above).'
H81C5A0E206B5: '控制PowerPC的CR位跟蹤功能。當使用POWER8及更高版本，或是其他CPU且啟用優化(-O2及以上)時，預設啟用「-mcrbits」(CR位跟蹤支援)。'
# 'Control the amount of inlining in pre-instrumentation inliner (default = 75)'
H601514BCD01B: '控制預插樁內聯器的內聯量（預設值=75）'
# 'Control the amount of inlining to perform (default = 225)'
H54F72241070E: '控制內聯的執行量（預設值=225）'
# 'Control the amount of phi node folding to perform (default = 2)'
H27887A938BFF: '控制要執行的phi節點折疊量（預設值=2）'
# 'Control the maximal conditional load/store that we are willing to speculatively execute to eliminate conditional branch (default = 6)'
HEA5F4A80FEFE: '控制願意預測執行的最大條件式載入/儲存指令數以消除條件式跳轉（預設值=6）'
# 'Control the maximal total instruction cost that we are willing to speculatively execute to fold a 2-entry PHI node into a select (default = 4)'
H57D2DDD9FD2C: '控制願意預測執行的最大總指令成本以將 2 項phi節點折疊為選擇式（預設值=4）'
# 'Control the number of bonus instructions (default = 1)'
H7BC9F590620F: '控制獎勵指令的數量（預設值=1）'
# 'Control the rules which are enabled. These options all take a comma separated list of rules to disable and may be specified by number or number range (e.g. 1-10).'
H7704451C821B: '控制啟用的規則。這些選項接受以逗號分隔的要禁用規則清單，並可透過數字或數字範圍指定（例如 1-10）。'
# 'Control the use of vectorisation using tail-folding for SVE where the option is specified in the form (Initial)[+(Flag1|Flag2|...)]:\ndisabled      (Initial) No loop types will vectorize using tail-folding\ndefault       (Initial) Uses the default tail-folding settings for the target CPU\nall           (Initial) All legal loop types will vectorize using tail-folding\nsimple        (Initial) Use tail-folding for simple loops (not reductions or recurrences)\nreductions    Use tail-folding for loops containing reductions\nnoreductions  Inverse of above\nrecurrences   Use tail-folding for loops containing fixed order recurrences\nnorecurrences Inverse of above\nreverse       Use tail-folding for loops requiring reversed predicates\nnoreverse     Inverse of above'
H48B9B6BA5047: '控制SVE向量化時使用尾部折疊的規則，其格式為(初始)[+(Flag1|Flag2|...)]:\ndisabled      (初始) 不會使用尾部折疊向量化任何迴圈類型\ndefault       (初始) 使用目標CPU的預設尾部折疊設定\nall           (初始) 所有合法迴圈類型將使用尾部折疊向量化\nsimple        (初始) 對簡單迴圈(不含約束或遞迴)使用尾部折疊\nreductions    對含約束的迴圈使用尾部折疊\nnoreductions  反向設定\nrecurrences   對含固定順序遞迴的迴圈使用尾部折疊\nnorecurrences 反向設定\nreverse       對需要反向述詞的迴圈使用尾部折疊\nnoreverse     反向設定'
# "Control use of approximate reciprocal and reciprocal square root instructions followed by <n> iterations of Newton-Raphson refinement. <value> = ( ['!'] ['vec-'] ('rcp'|'sqrt') [('h'|'s'|'d')] [':'<n>] ) | 'all' | 'default' | 'none'"
HC7E65C6B3833: "控制近似倒數及平方根倒數指令後跟 <n> 次牛頓-拉弗森修訂。<value> = ( ['!'] ['vec-'] ('rcp'|'sqrt') [('h'|'s'|'d')] [':'<n>] ) | 'all' | 'default' | 'none'"
# 'Control vtordisp placement'
HE1318392829D: '控制vtordisp的放置位置'
# 'Control vtordisp placement on win32 targets'
H1B28D470DA9E: '控制win32目標的vtordisp放置位置'
# "Control where files for distributed backends are created. Expects 'oldprefix;newprefix' and if path prefix of output file is oldprefix it will be replaced with newprefix."
HC0263D605A37: "控制分散後端的檔案建立位置。期望值為 'oldprefix;newprefix'，如果輸出檔案的路徑前綴為oldprefix，則會被替換為newprefix。"
# 'Control whether the compiler can use scalable vectors to vectorize a loop'
H6A90BC2050A3: '控制編譯器是否可以使用可擴展向量來向量化一個迴圈'
# 'Control whether unstable and experimental library features are enabled. This option enables various library features that are either experimental (also known as TSes), or have been but are not stable yet in the selected Standard Library implementation. It is not recommended to use this option in production code, since neither ABI nor API stability are guaranteed. This is intended to provide a preview of features that will ship in the future for experimentation purposes'
H292802AB79DD: '控制是否啟用不穩定和實驗性的函式庫功能。此選項將啟用多種實驗性(即技術_specification)或尚未在所選標準函式庫實作中穩定的功能。不建議在生產程式中使用此選項，因ABI及API的穩定性無法保證。此選項主要提供即將發佈功能的預覽，供實驗使用'
# 'Controls Negator transformations in InstCombine pass'
H08542ADEE520: '控制InstCombine pass中的Negator轉換'
# 'Controls how scalar integer arguments are extended in calls to unprototyped and varargs functions'
H7A8FE1AC1071: '控制在呼叫未原型化及可變參數函數時，純量整數參數的擴展方式。'
# 'Controls the backend parallelism of -flto=thin (default of 0 means the number of threads will be derived from the number of CPUs detected)'
H6966D13FD63C: '控制-flto=thin的後端並行處理（預設值為 0 表示執行緒數量將根據偵測到的CPU數量決定）。'
# 'Controls the semantics of floating-point calculations.'
H71E38C97DF72: '控制浮點運算的語義。'
# 'Controls transformations in div-rem-pairs pass'
HECF2FCF96025: '控制div-rem-pairs pass的轉換。'
# 'Controls transformations in partially-inline-libcalls'
HD0E8FE10DABD: '控制部分內聯函數呼叫的轉換。'
# 'Controls whether PPC per opcode peephole is performed on a MI'
HE5F923C4F31C: '控制是否在MI上執行PPC每條指令的局部最佳化。'
# 'Controls whether PPC reg+reg to reg+imm peephole is performed on a MI'
HE845FFE9D736: '控制是否在MI上執行PPC寄存器+寄存器轉換為寄存器+立即數的局部最佳化。'
# 'Controls whether a DAG combine is performed for a node'
H093B59DCA1FC: '控制是否對節點執行DAG合併。'
# 'Controls whether rewriteCandidateWithBasis is executed.'
H07C470C4B05C: '控制是否執行rewriteCandidateWithBasis函數。'
# 'Controls whether to select function with GlobalISel'
HBD7BF3862B9C: '控制是否使用GlobalISel選取函數。'
# 'Controls which MemoryDefs are eliminated.'
H791CB4538D1F: '控制要消除的記憶體定義。'
# 'Controls which SLP graphs should be vectorized.'
H3651F2112EDB: '控制要向量化SLP圖形。'
# 'Controls which assumes gets created'
HC60E96036F48: '控制要建立的假設。'
# 'Controls which checks to insert'
H85AB8C69F0A9: '控制要插入的檢查。'
# 'Controls which conditions are eliminated'
HCCAC8F989163: '控制要消除的條件。'
# 'Controls which instruction to instrument'
HC782D790D691: '控制要插樁的指令。'
# 'Controls which instructions are eliminated'
H11684921476B: '控制要消除的指令。'
# 'Controls which instructions are removed'
HAA6FE4D6ECC8: '控制要移除的指令。'
# 'Controls which instructions are value numbered'
HB785D2555BC9: '控制要進行值編號的指令。'
# 'Controls which instructions are visited'
H636F2545BF3D: '控制要訪問的指令'
# 'Controls which instructions we create phi of ops for'
HE27BA11ED3BE: '控制我們要為哪些操作建立phi節點'
# 'Controls which pairs are considered for renaming'
HD4F491A48E58: '控制哪些配對要考慮重新命名'
# 'Controls which register COPYs are forwarded'
H3AAE7A42C897: '控制哪些寄存器COPY操作要前傳'
# 'Controls which tag collisions are avoided'
H425F30EA7D35: '控制要避免哪些標籤衝突'
# 'Controls which variables C++ static destructors are registered for'
HBD9C8A005FBD: '控制哪些變數的C++靜態析構函數要註冊'
# 'Controls which variables are renamed with predicateinfo'
H64B5B42BA3C1: '控制要使用predicatesinfo重新命名的變數'
# 'Conventional ABI instrumentation for sanitizer runtime. Default: Conventional'
HAE6876018E56: '傳統ABI插樁用於sanitizer執行時期。預設：傳統'
# 'Convert align attributes to assumptions during inlining.'
H3BBD1D4AD52A: '在內聯期間將align屬性轉換為假設'
# 'Convert all cmovs to branches.'
HC3FD80CE54EF: '將所有cmov轉換為跳轉指令'
# 'Convert available_externally into locals, renaming them to avoid link-time clashes.'
H719EAE04A8AC: '將available_externally轉換為局部變數，並重新命名以避免連結時期的衝突'
# 'Convert cmovs to branches whenever they have memory operands.'
HF77C545DF219: '當cmovs有記憶體操作數時，將其轉換為跳轉指令'
# 'Convert eligible reg+reg instructions to reg+imm'
HC9D049FFF42E: '將符合條件的reg+reg指令轉換為reg+imm'
# 'Convert i1 constants to i32/i64 if they are returned'
HB5295C482B89: '如果返回值為i1常數，則轉換為i32/i64'
# 'Convert irreducible control-flow into natural loops'
HE7DC2EC0D50F: '將不可約化控制流轉換為自然循環'
# 'Convert noalias attributes to metadata during inlining.'
H693AF480BD18: '在內聯期間將noalias屬性轉換為metadata'
# 'Convert registers to WebAssembly locals'
H42DF7CAF4C71: '將寄存器轉換為WebAssembly局部變數'
# 'Convert switches into an integer range comparison (default = false)'
HDCDA8562FA9F: '將switch轉換為整數範圍比較（預設=false）'
# 'Convert switches to lookup tables (default = false)'
H5FE1320AA9A1: '將switch轉換為查找表（預設=false）'
# 'Convert the generated profile to a profile with a new layout'
H7167152F0FAC: '將生成的分析配置文件轉換為具有新佈局的配置文件'
# 'Cost for first time use of callee-saved register.'
H378B86E985E0: '首次使用被呼叫者保存的寄存器的成本。'
# 'Cost multiplier to multiply onto inlined call sites where the new call was previously an intra-SCC call (not relevant when the original call was already intra-SCC). This can accumulate over multiple inlinings (e.g. if a call site already had a cost multiplier and one of its inlined calls was also subject to this, the inlined call would have the original multiplier multiplied by intra-scc-cost-multiplier). This is to prevent tons of inlining through a child SCC which can cause terrible compile times'
H698CAA7A18F5: '對原本是SCC內呼叫的內聯呼叫位置的乘數成本（原呼叫已為SCC內時不適用）。此成本可累積多層內聯（例如若呼叫位置已有成本乘數且其內聯的其中一個呼叫也受此影響，則該內聯呼叫會將原乘數與SCC內成本乘數相乘）。此設定用以避免透過子SCC進行大量內聯導致編譯時間劇增。'
# 'Cost of a single instruction when inlining'
H036B559D08B8: '內聯單條指令的成本'
# 'Cost of alloca argument'
HC1E9D60217AE: 'alloca參數的成本'
# 'Cost of jump instructions.'
H7ED2E2DD5641: '跳轉指令的成本'
# 'Cost of load/store instruction when inlining'
H4C8BA9CE961B: '內聯期間load/store指令的成本'
# 'Cost penalty for blocks that can avoid breaking CFG by copying. Copying can increase fallthrough, but it also increases icache pressure. This parameter controls the penalty to account for that. Percent as integer.'
HC9F72F77D39D: '複製區塊時避免破壞CFG的風險成本。複製會增加fallthrough機率但同時增加指令快取壓力。此參數用以調整此風險的損失值。百分比（整數）形式輸入。'
# 'Cost that models the probabilistic risk of an instruction misfetch due to a jump comparing to falling through, whose cost is zero.'
H84CCB8356D8E: '跳轉指令與直接執行相比的指令未命中風險概率模型成本。後者的成本為零。'
# 'Costing strategy for intrinsic instructions'
H8D22576D5E28: '內置指令的成本策略'
# 'Count statements with scalar accesses as not optimizable'
H20E33614C70B: '將具有標量存取的語句計為無法優化'
# 'Count the induction variable only once when interleaving'
HDCB004AC534E: '交錯時僅計算迴圈變數一次'
# 'Counts based on the value each specified argument has. The argument has to have a number value to be considered.'
HE174F4DEB8D5: '根據每個指定參數的值進行計數。該參數必須有數值型態才能被考慮。'
# 'Counts individual remarks based on how many of the remark exists.'
H16283CDE8F40: '根據存在的註解數量對個別註解進行計數。'
# 'Coverage executable or object file'
H2B8E5F52400C: '覆蓋可執行檔或物件檔'
# 'Covered executable or object file.'
H20476C00EDC5: '被覆蓋的可執行檔或物件檔'
# 'Create DLL'
H8F2F15C96BC4: '建立DLL'
# 'Create Garbage Collector Module Metadata'
H7493F37F2CB6: '建立垃圾收集模塊元數據'
# 'Create a copy of byval function arguments early.'
HFD4F400F3DC5: '在早期建立byval函數參數的副本。'
# 'Create a dot file of CFGs with block coverage inference information'
HEAFA159C65C9: '建立包含區塊覆蓋推論資訊的CFG點文件'
# 'Create a table of coverage-instrumented PCs'
HE002CE3DC7B7: '建立已插樁PC的覆蓋表'
# 'Create a website with graphical changes'
H01E9364CFCA0: '建立帶有圖形變更的網站'
# 'Create a website with graphical changes in quiet mode'
H70CA1F4FAB9C: '在安靜模式下建立帶有圖形變更的網站'
# 'Create cfi directives that assume the code might be more than 2gb away'
H558862C2332B: '建立假設代碼可能超過 2GB的CFI指令'
# 'Create debug DLL'
H983B4E5552B9: '建立除錯DLL'
# 'Create empty files if bundles are missing when unbundling.\n'
H57F1E8EF31C0: '解包時如果缺少捆綁包，則建立空文件。\n'
# 'Create hotpatchable image'
HA0C5E8AB1DC6: '建立可熱修的映像'
# 'Create lane mask for data only, using active.lane.mask intrinsic'
HFF5BD5C1DCB1: '使用active.lane.mask本機函數僅建立資料的lane mask'
# 'Create lane mask using active.lane.mask intrinsic, and use it for both data and control flow'
H1B146FBA9B46: '使用active.lane.mask本機函數建立lane mask，並同時用於資料和控制流程'
# 'Create lane mask with compare/stepvector'
HE51056AA8ABD: '使用compare/stepvector建立lane mask'
# 'Create phony target for each dependency (other than main file)'
H49C550B30EC3: '為每個依賴（主文件除外）建立虛擬目標'
# 'Create pi-block nodes.'
H3DDF1DCDF3C3: '建立pi-block節點。'
# 'Create redzones for byval arguments (extra copy required)'
HF6B190018549: '為byval參數建立redzones（需要額外複製）'
# 'Create unit-strided versions of loops'
H1EF207263F28: '建立迴圈的單位步進版本'
# "Creates .debug_names section, if the input binary doesn't have it already, for DWARF5 CU/TUs."
HFA262F88083F: '如果輸入的二進位檔沒有，則為DWARF5 CU/TUs建立.debug_names區段'
# 'Cross module exports (DEBUG_S_CROSSSCOPEEXPORTS subsection)'
HE827878921EC: '跨模組導出（DEBUG_S_CROSSSCOPEEXPORTS子區段）'
# 'Cross module imports (DEBUG_S_CROSSSCOPEIMPORTS subsection)'
HE6104A2735AD: '跨模組導入（DEBUG_S_CROSSSCOPEIMPORTS子區段）'
# 'Cull hazards on function boundaries'
HD35403A45243: '在函式邊界消除危害'
# 'Cull hazards on memory waits'
HF9A83C7746B5: '在記憶體等待時消除危害'
# 'Cutoff for generating "extract" instructions'
HF67D76A2F279: '生成「extract」指令的閾值'
# 'Cutoff percentages (times 10000) for generating detailed summary'
HF12B62925337: '生成詳細摘要的閾值百分比（乘以 10000）'
# 'Cutoff value about how many symbols in profile symbol list will be used. This is very useful for performance debugging'
H866011BDFA50: '剖析符號清單中使用的符號數量的截止值。這對性能除錯非常有用'
# 'Cycle Info Analysis'
HD7B2CE61522D: '循環資訊分析'
# 'DAG combiner enable load/<replace bytes>/store with a narrower store'
H7A381CB1EB04: '啟用使用較窄的存儲將load/<取代位元組>/store組合在一起'
# 'DAG combiner enable merging multiple stores into a wider store'
H9B98909FAA22: '啟用將多個存儲合併為較寬的存儲'
# 'DAG combiner enable reducing the width of load/op/store sequence'
H56650D4975A5: '啟用減少load/op/store序列的寬度'
# 'DAG combiner force override the narrowing profitable check when reducing the width of load/op/store sequences'
HA751CC58B87A: '在減少load/op/store序列的寬度時，強制覆蓋窄化的獲利檢查'
# 'DAG combiner limit number of steps when searching DAG for predecessor nodes'
HEF62B0854706: '限制在DAG中搜索前驅節點時的步驟數量'
# 'DAG combiner may split indexing from loads'
HFB4258B46B3C: '可能拆分載入的索引'
# 'DEBUG/DEVELOPMENT OPTIONS'
H43B5FBE6C89C: '除錯/開發選項'
# "DEPRECATED: Filename defining the whitelist for imbuing the 'always instrument' XRay attribute."
HC9A9C6768A2E: '已棄用：定義用於賦予‘始終插樁’XRay屬性的白名單的檔案名稱。'
# "DEPRECATED: Filename defining the whitelist for imbuing the 'never instrument' XRay attribute."
H640211D9F2F8: '已棄用：定義用於賦予‘從不插樁’XRay屬性的白名單的檔案名稱。'
# 'DRIVER OPTIONS'
H8F860C8326CF: '驅動程式選項'
# 'DWARF'
HDD71DBDFB287: 'DWARF'
# 'DWARF debug sections compression type'
H91FF9BE5328B: 'DWARF調試區段壓縮類型'
# 'DWARF-like CFI based exception handling'
HC32F13DA0A07: '基於DWARF類似CFI的例外處理'
# 'DWO output filename'
H6E851EAFE0D8: 'DWO輸出檔名'
# 'DXContainer Global Emitter'
H7800E8E1E097: 'DXContainer全域發射器'
# 'DXIL Array Flattener'
H8F82D482C158: 'DXIL陣列展平器'
# 'DXIL Data Scalarization'
H8CA416EED877: 'DXIL資料純量化'
# 'DXIL Finalize Linkage'
H674F973B6F8F: 'DXIL最終連結修訂'
# 'DXIL Intrinsic Expansion'
H92F9B358ADE0: 'DXIL 內置函數展開'
# 'DXIL Legalizer'
HB4D0483DF9F7: 'DXIL 合法化'
# 'DXIL Metadata Pretty Printer'
HF96947D33548: 'DXIL 元資料美觀列印器'
# 'DXIL Module Metadata analysis'
HA9F2740D603A: 'DXIL 模組元資料分析'
# 'DXIL Op Lowering'
HEEFF9D70DBBF: 'DXIL 作業降低'
# 'DXIL Prepare Module'
HF62B7360E273: 'DXIL 準備模組'
# 'DXIL Resource Access'
HF5E458A33121: 'DXIL 資源存取'
# 'DXIL Resource Binding Analysis'
HC92CD4D22E79: 'DXIL 資源綁定分析'
# 'DXIL Resource Type Analysis'
HF10ABCFBFE52: 'DXIL 資源類型分析'
# 'DXIL Root Signature Analysis'
HBF76A637272F: 'DXIL 根簽名分析'
# 'DXIL Shader Flag Analysis'
H7A214ED13A39: 'DXIL 着色器旗標分析'
# 'DXIL Translate Metadata'
HF4C419C952DF: 'DXIL 轉換元資料'
# 'DXIL validator installation path'
H9657CC613141: 'DXIL 驗證器安裝路徑'
# 'Darwin libsystem_m'
H91DFA86D618A: 'Darwin libsystem_m'
# 'Data aggregation options'
H2670869C509A: '資料聚合選項'
# 'Dbi Stream Options'
HD27A954F7342: 'Dbi 流選項'
# 'Dead Argument Elimination'
HA9265D7501D4: '死引數消除'
# 'Dead Argument Hacking (BUGPOINT USE ONLY; DO NOT USE)'
HDA7D75078335: '死引數篡改（僅限 BUGPOINT 使用；請勿使用）'
# 'Dead Code Elimination'
HF23F9DE62329: '死程式碼消除'
# 'Debug Variable Analysis'
H4B43DA399B8A: '除錯變數分析'
# 'Debug control MBBs that are scheduled'
HFA489B3CE974: '調試控制已排程的MBB'
# 'Debug control for aggressive anti-dep breaker'
HDCDB4687E0FE: '調試控制強制打破反依賴'
# 'Debug dumping for the orc-lazy JIT.'
HB541A1485401: 'orc-lazy JIT調試輸出。'
# 'Debug func'
H4ECA9A2353F4: '調試函數'
# 'Debug information offset.'
H34EB3EE5B41D: '除錯資訊偏移量。'
# 'Debug information tags.'
H2591856B760C: '除錯資訊標籤。'
# 'Debug line.'
HC0773DFAAF93: '除錯行。'
# 'Debug lines that are zero.'
H28A0CEC425F6: '除錯零長度的行。'
# 'Debug location ranges.'
H40716F5089BC: '除錯位置範圍。'
# 'Debug max inst'
H8671ED460AD3: '調試最大指令數'
# 'Debug min inst'
H10F353058E6B: '調試最小指令數'
# 'Debug option to outline greedily, without restriction that calculated benefit outweighs cost'
H173943EFDB58: '調試選項無限制地外掛，不檢查收益是否超過成本'
# 'Debugify MIR before and Strip debug after each pass except those known to be unsafe when debug info is present'
H0F54403815FA: '在除錯資訊存在時，對所有已知安全的pass執行前先將MIR除錯資訊Debugify，執行後移除，除了已知不安全的pass'
# 'Debugify MIR before, by checking and stripping the debug info after, each pass except those known to be unsafe when debug info is present'
HC24A7BC34E88: '在除錯資訊存在時，對所有已知安全的pass執行前先檢查並Debugify MIR，執行後移除除錯資訊，除了已知不安全的pass'
# 'Decided the kind of output desired'
H734A5ED4813F: '決定所需的輸出類型'
# 'Declare callbacks extern weak, and only call if non-null.'
H2C4EDA19C0CD: '宣告回呼函數為extern weak，僅在非空時調用。'
# 'Declare variables at top when emitting C/C++'
HB43A4E22EF20: '在產生C/C++時將變數宣告於頂端'
# "Decreases 'x86-br-merging-base-cost' in cases that it is unlikely that all conditionals will be executed. For example for merging the conditionals (a == b && c > d), if its known that a == b is unlikely, then it is unlikely that if the conditionals are split both sides will be executed, so it may be desirable to decrease the instruction cost threshold. Set to -1 to never merge unlikely branches."
H63754944E6A3: '在不太可能執行所有條件分支的情況下降低「x86-br-merging-base-cost」。例如在合併條件式 (a == b && c > d) 時，若已知a == b 不太可能成立，則條件分支分割後兩邊執行的機率可能降低，因此可降低指令成本門檻。設定為-1以永遠不合併低機率分支。'
# 'Deduce sibling calls when unrolling function call stacks'
HDD364524269F: '在展開函數呼叫堆疊時推斷兄弟呼叫'
# 'Default (no attribute)'
H2C9C1DE32DAB: '預設（無屬性）'
# 'Default DWARF version to use, if a -g option caused DWARF debug info to be produced'
HFF353DB7A2F1: '使用預設的DWARF版本，如果-g選項導致生成DWARF除錯資訊'
# 'Default address minimization strategy'
H1000E773EFCF: '預設的地址最小化策略'
# 'Default alignment for loops'
HFA44E84983F7: '迴圈預設對齊值'
# 'Default amount of inlining to perform'
H05B97F3AF721: '內聯操作的預設執行程度'
# 'Default for platform'
H91B018E0FAE2: '平台預設值'
# 'Default for platform and JIT-kind'
H0675076F20CF: '平台和JIT類型預設值'
# 'Default max threads per block for kernel launch bounds for HIP'
HDE6E6DE6B0D5: 'HIP核函數啟動邊界中每個區塊的最大執行緒數預設值'
# 'Default mispredict rate (initialized to 25%).'
HA90859109DC8: '預設誤測率（初始值設為 25%）'
# 'Default register allocator'
HF2112AFDE4A0: '預設的記憶體寄存器分配器'
# 'Default threshold (max size of unrolled loop), used in all but O3 optimizations'
H450E3D6B5565: '在非-O3優化中使用的展開循環最大尺寸閾值預設值'
# 'Default type visibility'
H7E06B3502FFA: '預設類型可見性'
# 'Defer host/device related diagnostic messages for CUDA/HIP'
HD7B0D94624F9: '延遲CUDA/HIP主機/裝置相關的診斷訊息'
# "Define '__STDC__' to '1' in MSVC Compatibility mode"
HE12E4DC30513: "在MSVC相容模式下將 '__STDC__' 定義為 '1'"
# 'Define <macro> to <value> (or 1 if <value> omitted)'
HC9C0FAB29C48: '將 <macro> 定義為 <value>（若省略 <value> 則定義為 1）'
# 'Define __STDC__'
H403D03CBAA5E: '定義__STDC__'
# 'Define a value for a symbol'
HF0BE0602E7DD: '為符號設定值'
# 'Define a variable to be used in capture patterns.'
H430D1D820ECC: '定義在捕獲模式中使用的變數。'
# 'Define custom MSan AndMask'
H293D08EE84D2: '定義自訂MSan AndMask'
# 'Define custom MSan OriginBase'
H8FF05FDD24B0: '定義自訂MSan OriginBase'
# 'Define custom MSan ShadowBase'
H936AD234A7BD: '定義自訂MSan ShadowBase'
# 'Define custom MSan XorMask'
HE0448D308359: '定義自訂的 MSan XorMask'
# 'Define macro'
H1A169BE8E69A: '定義宏'
# 'Define threshold for number of checks per debug location to force origin update.'
H97F94F0D6F64: '設定每個調適位置的檢查次數門檻值，以強制更新來源位置。'
# 'Define where potential integer overflows in generated expressions should be tracked.'
H76CDAC079D12: '定義在生成的運算式中哪些潛在的整數溢出需要追蹤。'
# 'Defined the specified macros to their specified definition. The syntax is <macro>=<definition>'
H8B59655A675D: '定義指定的宏及其定義。語法為 <macro>=<definition>'
# 'Defines a symbol to be an integer constant'
H876930F92D82: '定義符號為整數常數'
# 'Defines the __DEPRECATED macro'
H49D43A572A26: '定義 __DEPRECATED 宏'
# 'Delete specified Globals from Module'
HB4A9BA47E594: '從模組中刪除指定的Globals'
# 'Delinearize array access functions'
HA9C6C1714FE6: '將陣列存取函數去線性化'
# 'Delta passes to not run, separated by commas. By default, run all delta passes.'
H76B8D7EFA5BE: '要停用的 Delta passes，以逗號分隔。預設是執行所有 Delta passes。'
# 'Delta passes to run, separated by commas. By default, run all delta passes.'
H192F0FF37D50: '要執行的 Delta passes，以逗號分隔。預設是執行所有 Delta passes。'
# 'Demangle function names'
H0F5F6B77621B: '轉換函數名稱的編碼'
# 'Demote catchswitch BBs only (for wasm EH)'
H0707EDF1B004: '僅降級 catchswitch BBs（適用於 wasm EH）'
# 'Dependence Analysis'
H1CE69C87EFED: '依賴分析'
# 'Dependences should be simplified (yes/no)'
HFE9403DC8E00: '是否要簡化依賴關係（yes/no）'
# 'Dependency filename'
H48F0BFFD012C: '依賴檔名'
# 'Deprecated (like /Og /Oi /Ot /Oy /Ob2); use /O2'
HC8F13BE3A9B1: '已棄用（類似 /Og /Oi /Ot /Oy /Ob2）；請改用 /O2'
# 'Deprecated (like not passing /EH)'
HB203EF80F1D6: '已棄用（相當於未指定 /EH）'
# 'Deprecated (set output file name); use /Fe or /Fe'
H43E83CDF9C2D: '已棄用（設定輸出檔名）；請改用 /Fe 或 /Fe'
# "Deprecated; use '-O3 -ffast-math -fstack-arrays' for the same behavior, or '-O3 -fstack-arrays' to enable only conforming optimizations"
H894A29167B0A: "已棄用；請使用 '-O3 -ffast-math -fstack-arrays' 以達成相同效果，或使用 '-O3 -fstack-arrays' 以啟用僅符合標準的優化"
# "Deprecated; use '-O3 -ffast-math' for the same behavior, or '-O3' to enable only conforming optimizations"
H68FB98DB67B0: "已棄用；使用 '-O3 -ffast-math' 以獲得相同行為，或使用 '-O3' 以啟用僅符合標準的優化"
# 'Deprecated; use /EHsc'
H0521F1C5E495: '已棄用；使用 /EHsc'
# 'Depth limit for finding address space through traversal'
HD8946F32E697: '通過遍歷查找地址空間的深度限制'
# 'Depth limit when simplifying vector instructions and their operands'
H77D06B036D51: '簡化向量指令及其操作數時的深度限制'
# 'Deref attributes and metadata infer facts at definition only'
HA8F233351C69: 'Deref 屬性和元數據僅在定義時推斷事實'
# 'Details for each and every function'
HC3D59D83E7DB: '每個函數的詳細資訊'
# 'Detect Dead Lanes'
H72FCA4FFA4F4: '檢測無效通道'
# 'Detect and exploit reductions'
HE6789AB23B98: '檢測並利用約簡'
# 'Detect parallelism'
H2FE6FC8C4E2A: '檢測並行性'
# 'Detect single entry single exit regions'
H9F71476F6AF4: '檢測單入口單出口區域'
# "Detect stack use after return if binary flag 'ASAN_OPTIONS=detect_stack_use_after_return' is set."
H52A7D51EA3C5: "如果二進位旗標 'ASAN_OPTIONS=detect_stack_use_after_return' 被設定，則檢測返回後的堆疊使用。"
# 'Determine based on deployment target'
H73C787FF3B61: '根據部署目標決定'
# 'Determine what attributes are manifested in the IR'
H535B6DB54DEC: '確定在IR中表現的屬性'
# 'Determine when the Swift async frame pointer should be set'
H0BCAA17B1F0F: '確定在何時設定 Swift 非同步框架指標'
# 'Determines whether the optimizer honors parentheses when floating-point expressions are evaluated'
HD46386982C52: '決定在評估浮點運算式時，優化器是否尊重括號'
# 'Diagnostic ID mapping utility'
HC6CDFACE6E9C: '診斷ID映射工具'
# 'Diff Options'
H28F8A773273E: '差異選項'
# 'Directly create compilation output files. This may lead to incorrect incremental builds if the compiler crashes'
H2C3E48B98787: '直接建立編譯輸出檔案。如果編譯器當機，可能會導致增量建置不正確。'
# 'Directories referenced in the debug information.'
HA9318D60737D: '在除錯資訊中引用的目錄。'
# 'Directories to search for object files by build ID'
HC9E3A565BEEA: '根據建置ID搜尋物件檔案的目錄'
# 'Directory for crash diagnostic files.'
H168FC0AAB4F7: '用於崩溃診斷文件的目錄。'
# 'Directory for outputting generated files.'
H8BAEDDCD56DA: '用於輸出生成文件的目錄。'
# 'Directory in which coverage information is written out'
HE36AE6B0A9D2: '寫入覆蓋率資訊的目錄。'
# 'Directory in which to emit symbol graphs.'
HD25DF8577F21: '用於發射符號圖的目錄。'
# 'Directory of include files'
H4769C553D95E: '包含文件的目錄。'
# 'Directory to dump module dependencies to'
H34B714818DA5: '用於傾印模組依存關係的目錄。'
# "Directory to output dSYM's (if any) to"
H6E5284514F1A: '用於輸出 dSYM（如有）的目錄。'
# 'Directory to store cached object files (must be user writable)'
HF3C59BF42111: '用於存儲緩存的物件文件的目錄（必須可寫入）'
# 'Directory used as a base for relative coverage mapping paths'
H60985D18A905: '用作相對覆蓋率映射路徑基準的目錄。'
# 'Disable BPF_ST (immediate store) insn'
HD28C63C4DB63: '禁用 BPF_ST（立即存儲）指令。'
# 'Disable C++ access control'
H88EE329A1455: '禁用 C++ 存取控制。'
# 'Disable C++ builtin type char8_t'
HE8005A3ED4D9: '禁用 C++ 內置類型 char8_t。'
# 'Disable C++ builtin type wchar_t'
H2F081FBCFFCE: '禁用 C++ 內置類型 wchar_t。'
# 'Disable C++ copy constructor elision'
H7BE31CDC2832: '禁用 C++ 副本建構函數省略。'
# 'Disable C++ static destructor registration'
H2B2B7EA1E24C: '禁用 C++ 靜態析構函數登記。'
# 'Disable C++14 sized global deallocation functions'
H31DC24E25DC3: '禁用 C++14 大小指定的全域釋放函數。'
# 'Disable C++17 aligned allocation functions'
H45EDF7CE8D2D: '禁用 C++17 對齊分配函數。'
# 'Disable CHR for all functions'
HE1BB044E9400: '禁用所有函數的 CHR。'
# 'Disable CIR transformations pipeline'
H0D1EAB308F4D: '禁用 CIR 轉換管線。'
# 'Disable CTR loops for PPC'
HFB1BF72E3D56: '禁用 PPC 的 CTR 迴圈。'
# 'Disable Codegen Prepare'
H9DF18DE3903B: '停用程式碼生成準備'
# 'Disable ConstantHoisting'
HA432AE659D39: '停用常數提升 (ConstantHoisting) pass'
# 'Disable Copy Propagation pass'
H6FAF844B65AE: '停用複製傳播 pass'
# 'Disable Dealloc Return for Hexagon target'
HC23D9F3300FD: '停用Hexagon目標的Dealloc Return'
# 'Disable Early If-conversion'
H0D9C330086F8: '停用早期If轉換'
# 'Disable GC optimizations in CodeGenPrepare'
HFD8A99D7BFCD: '停用CodegenPrepare中的GC優化'
# 'Disable GNU style inline asm'
H1CF933954FC2: '停用GNU風格的內聯組裝語言'
# 'Disable Hardware Loops for Hexagon target'
H783975C3C5DB: '停用Hexagon目標的硬體迴圈'
# 'Disable Hexagon Addressing Mode Optimization'
H071B2E4C0FD8: '停用Hexagon位址模式最佳化'
# 'Disable Hexagon CFG Optimization'
HEF36B4E6BB85: '停用Hexagon控制流圖最佳化'
# 'Disable Hexagon HVX IEEE floating-point'
H506C4D61FBA6: '停用Hexagon HVX IEEE浮點數'
# 'Disable Hexagon HVX QFloat instructions'
HF256A44FD3F5: '停用Hexagon HVX QFloat指令'
# 'Disable Hexagon MI Scheduling'
HA39B5931FB8D: '停用Hexagon MI調度'
# 'Disable Hexagon Vector eXtensions'
HDECA543F8233: '停用Hexagon向量擴充'
# 'Disable Hexagon constant propagation'
HED97EBD49929: '停用Hexagon常數傳播'
# 'Disable Hexagon instruction shuffling'
HC9709908CDDF: '停用Hexagon指令重排'
# 'Disable Hexagon loop alignment pass'
HCE964D02A0A9: '停用Hexagon迴圈對齊 pass'
# 'Disable Hexagon packetizer pass'
HCB5AE1AB8542: '停用Hexagon packetizer pass'
# 'Disable Hexagon specific Mask generation pass'
H8E1C9C7C8EC3: '停用Hexagon特定遮罩生成 pass'
# 'Disable JIT lazy compilation'
H24C8D24310DC: '停用JIT惰性編譯'
# 'Disable LTO mode (default)'
H508DDA148F38: '停用LTO模式（預設值）'
# 'Disable LTO mode (default) for offload compilation'
H7985601FAE0D: '停用LTO模式（預設值）用於卸載編譯'
# 'Disable Linear Function Test Replace optimization'
HA3DA3179BF69: '停用Linear Function Test Replace優化'
# 'Disable Loongson Advanced SIMD Extension (LASX).'
HEC68A6D43B64: '停用龍芯先進SIMD延伸指令集（LASX）'
# 'Disable Loongson SIMD Extension (LSX).'
H51EB682DB218: '停用龍芯SIMD延伸指令集（LSX）'
# 'Disable Loop Idiom Vectorize Pass.'
HCD6AF30D16E4: '停用Loop Idiom Vectorize Pass'
# 'Disable Loop Strength Reduction Pass'
HFDE52CD02ECB: '停用Loop Strength Reduction Pass'
# 'Disable MC/DC coverage criteria'
H5A71DE0EA17B: '停用MC/DC覆蓋率準則'
# 'Disable MIRProfileLoader before BlockPlacement'
H7119CF48A829: '在BlockPlacement前停用MIRProfileLoader'
# 'Disable MIRProfileLoader before RegAlloc'
HCEBEE56EAD41: '在RegAlloc前停用MIRProfileLoader'
# 'Disable MSA ASE (MIPS only)'
H771BF5C8F84F: '停用MSA ASE（MIPS專用）'
# 'Disable MT ASE (MIPS only)'
H1B6CF37939E2: '停用MT ASE（MIPS專用）'
# 'Disable Machine Common Subexpression Elimination'
H600985BEDBBF: '停用機器公共子表達式消除'
# 'Disable Machine Dead Code Elimination'
H436919B5DD6D: '停用機器無效程式碼消除'
# 'Disable Machine LICM'
HCA4B000FCB0F: '停用Machine LICM'
# 'Disable Machine Sinking'
H84436D44017D: '停用Machine Sinking'
# 'Disable MergeICmps Pass'
H127BD98A6338: '停用MergeICmps Pass'
# 'Disable New Value Jumps'
H3397AA24247F: '停用新值跳轉'
# 'Disable ODR indicator globals'
H2F9A01FFB645: '停用ODR指示符全域變數'
# 'Disable OpenMP optimizations involving SPMD-ization.'
HAF8239BD178C: '停用涉及SPMD-ization的OpenMP優化'
# 'Disable OpenMP optimizations involving deglobalization.'
H74B4ADA2F47B: '禁用涉及去全域化的OpenMP優化。'
# 'Disable OpenMP optimizations involving folding.'
HBD10CEF55EEF: '禁用涉及摺疊的OpenMP優化。'
# 'Disable OpenMP optimizations that eliminate barriers.'
H5C4E1057F8BD: '禁用消除屏障的OpenMP優化。'
# 'Disable OpenMP optimizations that replace the state machine.'
HC78F7C4114D3: '禁用替換狀態機的OpenMP優化。'
# 'Disable OpenMP specific optimizations.'
HA40A50850068: '禁用特定於OpenMP的優化。'
# 'Disable OpenMP support'
HFCB159BB2AD0: '禁用OpenMP支援'
# 'Disable Optimization of PNotP'
HE9DF380BE58C: '禁用PNotP的優化'
# 'Disable Optimization of Sign/Zero Extends'
H821C42065D98: '禁用符號/零擴展的優化'
# 'Disable Optimization of extensions to i64.'
HD38C1BE50891: '禁用擴展到i64的優化'
# 'Disable PPC loop instr form prep'
H8547684E746B: '禁用PPC迴圈指令格式準備'
# 'Disable Partial Libcall Inlining'
HDD48CA4D7B3E: '禁用部分函式呼叫內嵌'
# 'Disable Peephole Optimization'
H6E6615A7A740: '禁用小孔優化'
# 'Disable Post Regalloc Scheduler'
HD739F0016551: '禁用寄存器分配後的排程器'
# 'Disable PostRA Machine Sinking'
HBB5CB09CF7E3: '禁用寄存器分配後的機器沉入'
# 'Disable SVR4-style position-independent code (Mips only)'
HA6D44538AD07: '禁用SVR4風格的位置獨立代碼（僅Mips）'
# 'Disable SYCL C++ extensions'
H66EB15B22DDA: '禁用SYCL C++擴充功能'
# 'Disable Sparc leaf procedure optimization.'
H4EAE17DB87E5: '禁用Sparc葉程序優化。'
# 'Disable Stack Slot Coloring'
HC67B1F734851: '禁用堆疊槽位著色。'
# 'Disable V8+ mode'
HF617D77F2415: '禁用V8+模式'
# 'Disable VSX FMA instruction mutation'
HEA8BD8C0F7FD: '禁用VSX FMA指令變異'
# 'Disable VSX Swap Removal for PPC'
H5BF6CF30BC27: '停用PPC的VSX交換移除'
# 'Disable Value Profiling'
H0CA8694E7036: '停用值剖析'
# 'Disable XMM8-XMM15 register usage'
H1FBE9270DAE0: '停用XMM8-XMM15寄存器的使用'
# 'Disable adding the optnone attribute to functions at O0'
H7B7D0B68A353: '停用在O0時向函數添加optnone屬性'
# 'Disable advance peeling. Issues for convergent targets (D134803).'
H96D4946929C2: '停用進階循環剝離。針對收斂目標的問題（D134803）。'
# 'Disable advanced copy optimization'
H450999EB2A6C: '停用進階複製優化'
# 'Disable aliasing mode in HWAddressSanitizer'
HDA55D81C7ABD: '停用HWAddressSanitizer中的別名模式'
# 'Disable all Clang extensions for OpenMP directives and clauses'
HAECEE0FE6723: '停用OpenMP指令和子句的所有Clang擴充功能'
# 'Disable all options'
H2FCF77933240: '停用所有選項'
# 'Disable all outlining'
H452D85B48206: '停用所有外lining'
# 'Disable all rules in the '
H96795369E1EA: '停用中的所有規則'
# 'Disable all static analyzer checks'
H8DC2486B7F10: '停用所有靜態分析器檢查'
# 'Disable all vector combine transforms'
H63388692148E: '停用所有向量結合轉換'
# 'Disable all warnings'
H113C54A4E2E2: '停用所有警告'
# 'Disable amcas[_db].{b/h/w/d}'
H4094C4B64BFB: '停用amcas[_db].{b/h/w/d}'
# 'Disable amswap[_db].{b/h} and amadd[_db].{b/h}'
HF02B3FF824A2: '停用amswap[_db].{b/h}和amadd[_db].{b/h}'
# 'Disable analysis for CTR loops'
H4E1A550B8424: '停用CTR循環的分析'
# 'Disable analyzing function argument and return types for mandatory definedness'
H035F5FA49F38: '停用對函數參數和返回類型的強制定義性分析'
# 'Disable annotate table jump instruction to correlate it with the jump table.'
HE3C86797416A: '停用對跳轉表指令進行註解以與跳轉表相關聯'
# 'Disable any #pragma clang __debug that can lead to crashing behavior. This is meant for testing.'
H22EE3114285C: '停用任何可能導致程式崩潰的#pragma clang __debug。此功能用於測試。'
# 'Disable atomic operations instrumentation in ThreadSanitizer'
H436F5749CCF4: '停用ThreadSanitizer中的原子運算插樁'
# 'Disable atomic optimizer'
H91DDEC6A5CA5: '停用原子優化器'
# 'Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash'
HCBAE420C8090: '停用在clang崩潰時自动生成預處理來源文件與重現腳本'
# 'Disable automatic bitcode upgrade for version mismatch'
H5A3DEE200EB5: '停用版本不符時的bitcode自動升級'
# 'Disable autoupgrade of debug info'
HC2D0BCF7F57C: '停用調試信息的自動升級'
# 'Disable backend optimizations'
HB773D8B41328: '停用後端優化'
# 'Disable binop extract to shuffle transforms'
H6FB234E00070: '停用二元運算符轉換為shuffle指令的轉換'
# 'Disable block signature string)'
H0B1A3707BF42: '停用區塊簽名字串)'
# 'Disable both standard system #include directories and builtin #include directories'
H7E21F38033ED: '停用標準系統#include目錄與內建#include目錄'
# 'Disable branch folding'
HF6094945EF27: '停用分支合併優化'
# 'Disable branch optimizations in CodeGenPrepare'
H9E934B1894F9: '停用CodeGenPrepare中的分支優化'
# 'Disable bswap insns'
HEC30AD38E748: '停用bswap指令'
# 'Disable buffer security check'
H8BA30D52B9A7: '停用緩衝區安全檢查'
# 'Disable builtin #include directories only'
HF9A61F76A5C0: '僅停用內建#include目錄'
# 'Disable calling convention lowering pass'
H9858ACECE04B: '停用呼叫約定降階pass'
# 'Disable caret diagnostics but keep column info'
H597AC3D9E291: '停用插入符診斷但保留欄位資訊'
# 'Disable char8_t from c++2a'
H5E206E934042: '停用C++2a中的char8_t'
# 'Disable checking of constexpr function bodies for validity within a constant expression context'
H6ABC0DD0EC14: '停用在常量表達式上下文中檢查constexpr函數主體的有效性'
# 'Disable checks that try to statically verify validity of delinearized subscripts. Enabling this option may result in incorrect dependence vectors for languages that allow the subscript of one dimension to underflow or overflow into another dimension.'
H5CACAB20797B: '停用靜態驗證去線性化下標有效性的檢查。啟用此選項可能导致依賴向量在允許某一維度下標溢出/下溢到另一維度的語言中產生錯誤結果。'
# 'Disable clustered low occupancy rescheduling for ILP scheduling stage.'
HA583E3ADAB6E: '停用ILP排程階段的低佔有率集群重新排程。'
# 'Disable code coverage analysis'
H7E958EA264B1: '停用程式碼覆蓋率分析'
# "Disable codegen and compile-time checks for C++23's [[assume]] attribute"
H8CC8CAFE3A4B: '停用程式生成和編譯時檢查C++23的[[assume]]屬性'
# 'Disable codegen data for function merging. Local merging is still enabled within a module.'
HA6F585942D4A: '停用模組間的函數合併資料。同一模組內部的局部合併仍啟用。'
# 'Disable colors in diagnostics'
HDC4DB95966A6: '停用診斷中的顏色'
# 'Disable column and caret diagnostics'
H66ABD4DABB22: '停用列和插入符診斷'
# 'Disable combining of interleaved loads'
HDC89DC5720AF: '停用交錯載入的結合'
# 'Disable command line arguments round-trip.'
H529251337527: '停用命令列引數的 round-trip 傳輸'
# 'Disable compare instruction optimization'
HCA46CE080B75: '停用比較指令最佳化'
# 'Disable control flow integrity (CFI) checks for cross-DSO calls.'
HBA298571E50D: '停用跨 DSO 呼叫的控制流完整性 (CFI) 檢查'
# 'Disable control-flow mitigations for Load Value Injection (LVI)'
HC84915AF941B: '停用用於載入值注入 (LVI) 的控制流緩解措施'
# 'Disable convert to D suffix'
HEE0A84D95394: '停用轉換為 D 修飾符'
# 'Disable coverage pruning (i.e. instrument all blocks/edges)'
HF9991A3D9D32: '停用覆蓋率剪枝（即插樿所有區塊/邊）'
# 'Disable creation of CodeFoundation-type constant strings'
H8A3AF608A73D: '停用建立 CodeFoundation 類型的常數字串'
# 'Disable critical edge splitting during PHI elimination'
HF87FC46C993D: '停用 PHI 除去期間的關鍵邊分割'
# 'Disable critical path priority in sched=list-ilp'
H2CD6F07C5299: '停用 sched=list-ilp 管線中的關鍵路徑优先權'
# 'Disable custom behaviour (use the default class which does nothing).'
HDD6103F48106: '停用自訂行為（使用預設類別，其不進行任何操作）'
# 'Disable cycle-level precision during preRA scheduling'
HF9826B2C9560: '停用 preRA 管線調度中的 cycle 級精確度'
# 'Disable delayed template parsing'
H78E92B7DA979: '停用延遲模板解析'
# 'Disable detection of uninitialized parameters and return values'
H58D5476F7351: '停用未初始化的參數和傳回值之檢測'
# 'Disable diagnostic notes.'
HC94928475428: '停用診斷提示。'
# 'Disable direct TLS access through segment registers'
H458A3D5DF9C8: '停用透過段寄存器進行直接TLS存取'
# 'Disable elimination of dead PHI nodes.'
HC1471E3BABD6: '停用消除無效PHI節點'
# 'Disable emission .debug_ranges section.'
H8261A262490A: '停用產生.debug_ranges區段'
# 'Disable emission of core files if possible'
H5CA16DE0180D: '若可能則停用產生核心檔案'
# 'Disable emission of the extended flags in .loc directives.'
HC16B51206891: '停用在.loc指令中發射擴展標誌'
# 'Disable emitting complete constructors and destructors as aliases when possible'
H4E4DBEA88413: '若可能則停用將完整建構函數與解構函數發射為別名'
# 'Disable emitting metadata for binary analysis sanitizers'
H9438B3F5F3E7: '停用為二進位分析Sanitizers發射元數據'
# 'Disable experimental bounds safety extension for C'
H949767942150: '停用C語言的實驗性界限安全擴展'
# 'Disable experimental late parsing of attributes'
HAEA82819E6DD: '停用屬性的延遲解析實驗功能'
# 'Disable ext(promotable(ld)) -> promoted(ext(ld)) optimization in CodeGenPrepare'
HFA8DE3453A19: '停用CodeGenPrepare中的ext(promotable(ld)) → promoted(ext(ld))優化'
# 'Disable external API notes support'
H4877A26CE44B: '停用外部API註解支援'
# 'Disable fat LTO object support'
HECD714B1BF31: '停用膨脹型LTO物件支援'
# 'Disable features of APX'
H69A07C7EF30D: '停用APX功能'
# 'Disable features of coverage instrumentation for Sanitizers'
H0B74A3F5C9BC: '停用Sanitizers覆蓋率插樿功能'
# 'Disable fixed point types'
H9D07DD6F2288: '停用定點類型'
# 'Disable fixing up resolved relocations for Hexagon'
H2F59DE7595A3: '停用Hexagon已解析重定位的修復功能'
# 'Disable frame pointer elimination'
H163B87ED062D: '停用框架指標消除'
# 'Disable frame pointer elimination for non-leaf frame'
HAF65627719BE: '停用非葉框架的框架指標消除'
# 'Disable frame pointer omission (x86 only, default)'
H1E0AE27D951E: '停用框架指標省略（x86專用，預設啟用）'
# 'Disable frecipe.{s/d} and frsqrte.{s/d}'
H62E54664CC80: '停用frecipe.{s/d}與frsqrte.{s/d}'
# 'Disable freeing of memory on exit'
HF1F277AF14E7: '禁用退出時的內存釋放'
# 'Disable function entry/exit instrumentation in ThreadSanitizer'
H1351B571C7D6: '禁用ThreadSanitizer中的函數入口/出口插樁'
# 'Disable function inlining'
H5A7ECCE87EED: '禁用函數內聯'
# 'Disable function internalization.'
H8C418ABB3A74: '禁用函數內部化。'
# 'Disable function multiversioning'
H1ECFC327C1B3: '禁用函數多版本化'
# 'Disable function outlining (AArch64 only)'
H3491F6797D9A: '禁用函數外置化（AArch64僅限）'
# 'Disable fusing of spill code into instructions'
H7DEB69686DC1: '禁用將溢出代碼融合到指令中'
# 'Disable generation of RTTI data'
H41B72E945CBF: '禁用生成RTTI資料'
# 'Disable generation of const64'
HE3959EA50320: '禁用生成const64'
# 'Disable generation of discriminator information.'
HC17557FCC17F: '禁用生成區別信息。'
# 'Disable generation of gather instructions in auto-vectorization(x86 only)'
H983AEC35DB6E: '禁用在自動向量化中生成gather指令（僅限x86）'
# 'Disable generation of instruction packets'
H1BEE193809E5: '禁用生成指令封包'
# 'Disable generation of linker directives for automatic library linking'
HD9086365BC76: '禁用生成用於自動庫連結的連結器指令'
# 'Disable generation of memcpy in loop idiom recognition'
H75B5FDDE583A: '禁用在循環語法辨識中生成memcpy'
# 'Disable generation of memmove in loop idiom recognition'
HBDF5135E8486: '禁用在循環語法辨識中生成memmove'
# 'Disable generation of memop instructions'
H58306072EDD8: '禁用生成memop指令'
# 'Disable generation of new-value jumps'
H7CFC8831E9E7: '禁用生成新值跳轉'
# 'Disable generation of new-value stores'
HD912422CF388: '禁用生成新值存儲'
# 'Disable generation of profile instrumentation.'
H91EE299476D4: '禁用生成剖析插樁資訊。'
# 'Disable generation of rtti information'
HD27D5DABC1FC: '禁用生成RTTI資訊'
# 'Disable generation of scatter instructions in auto-vectorization(x86 only)'
HE3E5F2C6BEE2: '禁用在自動向量化中生成 scatter 指令（僅限 x86）'
# 'Disable global outlining only by ignoring the codegen data generation or use'
H9030F85E3C32: '禁用僅僅通過忽略程式碼生成資料生成或使用來進行全域程式外顯'
# 'Disable gotol insn'
HA056175A68C0: '禁用 gotol 指令'
# 'Disable hazard detection during preRA scheduling'
H42E4A02F5152: '禁用在 preRA 管線調度期間的危險檢測'
# 'Disable heap memory profiling'
HD2AF1D7462E3: '禁用堆內存剖析'
# 'Disable hoisting instructions to hotter blocks'
HECAA5605738C: '禁用將指令提升至較熱的區塊'
# 'Disable identical code folding (default)'
H2724011BEF3B: '禁用相同程式碼摺疊（預設）'
# 'Disable implicit addition of a top-level module op during parsing'
H38ED3CECF1BE: '禁用在解析期間隱含添加頂層模組操作'
# 'Disable implicit builtin knowledge of a specific function'
H72774275D87A: '禁用對特定函數的隱含內建知識'
# 'Disable implicit builtin knowledge of functions'
H4AC3CF326B03: '禁用對函數的隱含內建知識'
# 'Disable implicit builtin knowledge of math functions'
H19E24A418BA8: '禁用對數學函數的隱含內建知識'
# 'Disable inclusion of timestamp in precompiled headers'
H0CF0F2D88326: '禁用在預編譯標頭中包含時間戳'
# 'Disable indirect call promotion'
HEA9F9E3D24D2: '禁用間接呼叫提升'
# 'Disable instrumentation manager (use the default class which ignores instruments.).'
HFBC374870D12: '禁用插樁管理器（使用忽略插樁的預設類別）。'
# 'Disable integer(KIND=16) from TargetCharacteristics'
H1BFDF2763387: '禁用從 TargetCharacteristics 中的整數（KIND=16）'
# 'Disable integer(KIND=2) from TargetCharacteristics'
HBBF18B435116: '禁用從 TargetCharacteristics 中的整數（KIND=2）'
# 'Disable integrated assembler'
HA16408310A5F: '禁用整合式組譯器'
# 'Disable isel of shifter-op'
H7D5BCC95A13C: '禁用 shifter-op 的 isel'
# 'Disable just-my-code debugging (default)'
H32F1427A6837: '禁用僅我的程式碼除錯（預設）'
# 'Disable keeping all variables that have a persistent storage duration, including global, static and thread-local variables, to guarantee that they can be directly addressed'
H49BC5C7A9B8E: '禁用保留所有具有永久性存儲期間的變數（包括全域、靜態及執行緒局部變數），以確保它們可以被直接位址存取'
# 'Disable last run tracking'
HC4C7223E1ECA: '停用最後一次執行追蹤'
# 'Disable late function splitting using profile information (x86 and aarch64 ELF)'
HE4A96F3E3F80: '停用使用剖析資訊的晚期函數分割 (x86 和 aarch64 ELF)'
# 'Disable lazy module loading'
HEF9F9437498A: '停用延遲模組載入'
# 'Disable ldsx insns'
H5394D7A0EA62: '停用 ldsx 指令'
# 'Disable lifetime-markers emission even when optimizations are enabled'
HBD15CF06A54D: '即使啟用優化仍停用 lifetime-markers 的發射'
# 'Disable linemarker output and preprocess to stdout'
HA445684726D8: '停用列標記輸出並將預處理結果輸出到標準輸出'
# 'Disable linemarker output in -E mode'
HF1226A7F981C: '在 -E 模式下停用列標記輸出'
# 'Disable linker dead stripping of globals in AddressSanitizer'
H529E513B965C: '在 AddressSanitizer 中停用鏈接器對全域物件的無效程式碼刪除'
# 'Disable linker relaxation'
H1AC503411592: '停用鏈接器鬆弛優化'
# 'Disable live use priority in sched=list-ilp'
H265D7EB1A110: '在 sched=list-ilp 管線中停用活用優先級'
# 'Disable load widening'
HE007529C1391: '停用載入展寬'
# 'Disable load-acquire and store-release insns'
HC50A5A53467A: '停用 load-acquire 和 store-release 指令'
# 'Disable load/store vectorizer'
H0E242722155F: '停用載入/儲存向量化'
# 'Disable loading default configuration files'
H3C44B12DD359: '停用載入預設配置檔'
# 'Disable looking for compound instructions for Hexagon'
HD818D391C2CA: '停用在 Hexagon 中尋找複合指令'
# 'Disable looking for duplex instructions for Hexagon'
H3BEF6EB4C76F: '停用在 Hexagon 中尋找雙工指令'
# 'Disable loop unrolling in all relevant passes'
H8679BDFD2EE8: '在所有相關 pass 中停用迴圈展開'
# 'Disable loop-level heuristics.'
H3756953B43F4: '停用迴圈層級的启发式演算法'
# 'Disable machine peepholes for BPF'
H195E092FC1CB: '停用 BPF 的機器 peepholes'
# 'Disable machine peepholes for PPC'
HD0AFF1F89154: '停用 PPC 的機器 peepholes'
# 'Disable memory access instrumentation in ThreadSanitizer'
H29829654F38C: '停用ThreadSanitizer中的記憶體存取插樁'
# 'Disable memory promotion in LICM pass'
HFD9EDE137232: '停用LICM pass中的記憶體提升'
# 'Disable merging into combines'
H1147057C0FDD: '停用合併至combine中'
# 'Disable merging of globals'
H0911384E3022: '停用全域變數的合併'
# 'Disable minimum alignment of 1 for arguments passed by value on stack'
HAF9C1AF67E2F: '停用以堆疊傳遞的值參數的 1 最小對齊'
# 'Disable mitigations for Load Value Injection (LVI)'
HE89F1385E864: '停用對Load Value Injection (LVI)的緩解措施'
# 'Disable module-based external API notes support'
H8FEB52AFA393: '停用以模組為基礎的外部API註釋支援'
# 'Disable modules for C++'
H95B7103D9331: '停用C++的模組'
# 'Disable movsx insns'
H904B978BABF1: '停用movsx指令'
# 'Disable multi-region partial inlining'
H11B004AA7429: '停用多區域部分內聯'
# 'Disable multi-threading within MLIR, overrides any further call to MLIRContext::enableMultiThreading()'
HE606F0AD2719: '停用MLIR中的多執行緒，覆寫任何對MLIRContext::enableMultiThreading()的後續呼叫'
# 'Disable multiplicative reductions'
H68023B4BA449: '停用乘法簡化'
# 'Disable no-stall priority in sched=list-ilp'
H41669C812FF9: '停用在sched=list-ilp中的無等待優先權'
# 'Disable non conforming code from compiling (default)'
HC27C523454B5: '停用非符合程式碼的編譯（預設）'
# 'Disable non-allocatable physical register copy optimization'
H9F6E8121BA35: '停用不可分配的物理寄存器複製優化'
# 'Disable odd single-precision floating point registers'
HC69012E33908: '停用奇數單精準度浮點寄存器'
# "Disable omitting 'dls lr, lr' instructions"
HBB8A633ECC4C: "停用省略 'dls lr, lr' 指令"
# 'Disable on-demand initialization of thread-local variables'
HD53AA5AC4AC6: '停用按需初始化的執行緒局部變數'
# 'Disable one or more combiner rules temporarily in '
HD45ADA00F46A: '暫時停用中的 1 或多個組合規則'
# 'Disable optimization'
HD31C9965E766: '停用優化'
# 'Disable optimizations based on strict aliasing rules'
H0CE3F6B4E092: '禁用基於嚴格別名規則的優化'
# 'Disable optimizations based on vtable pointer identity'
HB754D32A5739: '禁用基於vtable指標同一性的優化'
# 'Disable optimize'
H7A717771741E: '禁用優化'
# 'Disable optimized frm insertion.'
HC173F38AB5E6: '禁用優化FRM插入'
# 'Disable origins tracking in MemorySanitizer'
H6CD4173EEC53: '禁用記憶體檢查器中的源跡追蹤'
# 'Disable output'
H10D88D0CF0F6: '禁用輸出'
# 'Disable partial inlining'
H928A39907BEB: '禁用部分內聯'
# 'Disable physreg def-use affinity'
HC8A2DB30E27A: '禁用物理寄存器定義-使用親和性'
# 'Disable platform support explicitly'
H0A0D6D39B390: '明確禁用平台支援'
# 'Disable poisoning array cookies when using custom operator new[] in AddressSanitizer'
H04ADC5D02283: '在AddressSanitizer中使用自定義operator new[]時禁用污染陣列cookie'
# 'Disable polly legality check'
H4B855C14E497: '禁用Polly合法性檢查'
# 'Disable pre-instrumentation inliner'
H6AAEA4B38739: '禁用預插樁內聯'
# 'Disable pre-register allocation tail duplication'
H74925BF6B59C: '禁用預寄存器分配尾部複製'
# 'Disable precise memory mode (AMDGPU only)'
H638CDA8718C5: '禁用精確記憶體模式（僅AMDGPU）'
# 'Disable precompiled headers, overrides /Yc and /Yu'
HA85F69F96408: '禁用預定義和命令列預編譯器宏'
# 'Disable predefined and command line preprocessor macros'
HB44C3311DC89: '禁用預定義目標作業系統宏'
# 'Disable predefined target OS macros'
H55CEC6079E93: "禁用顯示 'ready' 提示"
# "Disable printing the 'ready' prompt"
H60B484C23636: '禁用機率驅動的區塊放置'
# 'Disable probability-driven block placement'
H99FD887473AA: '禁用將alloca提升至LDS'
# 'Disable promote alloca to LDS'
H12640892E5F6: '禁用將alloca提升至LDS'
# 'Disable promote alloca to vector'
H58F548447B08: '禁用將alloca轉換為向量'
# 'Disable protection against removing loop preheaders'
H11458F88A73B: '禁用防止移除循環預頭的保護機制'
# 'Disable raw string literals'
H5372647D5F22: '禁用原始字串文字'
# 'Disable real(KIND=10) from TargetCharacteristics'
H7AB18BD04A08: '禁用從TargetCharacteristics來的real(KIND=10)類型'
# 'Disable real(KIND=3) from TargetCharacteristics'
H184DC371A7A3: '禁用從TargetCharacteristics來的real(KIND=3)類型'
# 'Disable recovery for specified sanitizers'
HA007863682E4: '禁用指定檢查工具的恢復功能'
# 'Disable regpressure priority in sched=list-ilp'
HF6314D19EB9F: '禁用在sched=list-ilp中寄存器壓力的优先級'
# 'Disable removal of sext.w'
HB0977BC6B970: '禁用移除sext.w指令'
# 'Disable removal of sign-extend insn'
H484EAB4F216F: '禁用移除符號擴展指令'
# 'Disable replace with vector math call pass'
HC8A504A99877: '禁用替換為向量數學調用的pass'
# "Disable retain SubstTemplateTypeParmType nodes in the AST's representation of alias template specializations"
H7BAFBB14B677: '禁用在別名模板特化AST表示中保留SubstTemplateTypeParmType節點'
# 'Disable sanitizer coverage instrumentation for modules and functions that match the provided special case list, even the allowed ones'
H8AE573AF38D9: '即使允許的模組和函數，也禁用根據提供的特殊情況清單匹配的模組和函數的檢查工具覆蓋插樁'
# 'Disable sanitizer metadata for modules and functions that match the provided special case list'
H09C17F700040: '根據提供的特殊情況清單，禁用匹配模組和函數的檢查工具元數據'
# 'Disable sanitizer statistics gathering.'
HFB69298094E2: '禁用檢查工具統計數據的收集'
# 'Disable sc.q instruction.'
H283A06DB04BD: '禁用sc.q指令'
# 'Disable schedule adjustment for new value stores.'
H391300C49ACE: '禁用新值存儲的調度調整'
# 'Disable scheduled-height priority in sched=list-ilp'
H9402AC53BA7A: '禁用在sched=list-ilp中的調度高度优先級'
# "Disable scheduler's two-address hack"
HE3E8E40A1932: '禁用調度器的雙地址 HACK'
# 'Disable scheduling addi instruction beforeload for ppc'
H06295571D2AE: '禁用在PPC中將addi指令調度在beforeload之前'
# 'Disable sdiv/smod insns'
HE1C6E99EA2FD: '停用sdiv/smod指令'
# 'Disable select to branch conversion.'
H3543CDE71CB9: '停用select轉分支轉換'
# 'Disable sharing the FileManager when building a module implicitly'
H8B60BD26410A: '停用在隱含建立模組時共用FileManager'
# 'Disable simplify-libcalls'
H49E652857C1A: '停用simplify-libcalls'
# 'Disable small data sections sorting'
H8333FC4754B0: '停用小型資料區段排序'
# 'Disable specific target library builtin function'
HC0FDBC3C7F0C: '停用特定目標程式庫內建函數'
# 'Disable speculative execution side effect suppression (SESES)'
HC1901080B0A5: '停用推测執行副作用抑制（SESES）'
# 'Disable spell-checking'
HF73309AEBDCA: '停用拼字檢查'
# 'Disable splitting double registers'
H5E3AECE38535: '停用拆分雙寄存器'
# 'Disable stack clash protection'
H8811AFD259AC: '停用堆疊衝突保護'
# 'Disable stack coloring'
HC094CB265B68: '停用堆疊著色'
# 'Disable stack probes which are enabled by default'
H7F863834E502: '停用預設啟用的堆疊探測'
# 'Disable standard #include directories for the C++ standard library'
HED953CC1E7C1: '停用C++標準程式庫的標準#include目錄'
# 'Disable standard system #include directories'
HAB8A8040E467: '停用標準系統#include目錄'
# 'Disable standard system #include directories only'
HA5DB077BC490: '僅停用標準系統#include目錄'
# 'Disable store widening'
H4BB106975BD7: '停用存儲寬化'
# 'Disable store(extract) optimizations in CodeGenPrepare'
HD78BB1861BFD: '停用CodeGenPrepare中的store(extract)優化'
# 'Disable string pooling'
HC733A3918F74: '停用字串池'
# 'Disable strip W suffix'
HF34CE2AC1BA4: '停用去除W後綴'
# 'Disable support for K&R C function declarations'
HEA32A58B7196: '停用對K&R C函式宣告的支援'
# 'Disable support for exception handling'
HAC5AC768AAF8: '停用例外處理（EH）支援'
# 'Disable support for int128_t type'
H064E25645BF2: '停用int128_t類型支援'
# 'Disable symbolizing crash backtraces.'
HA299A2AEAED6: '停用核心轉儲的符號化解析'
# 'Disable tail call optimization, keeping the call stack accurate'
H8EF83315B758: '停用尾調用優化，以保持呼叫堆疊的準確性'
# 'Disable tail duplication'
HACA1C01DCC7A: '停用尾部重複'
# 'Disable tail folding'
HA81C7EA6791A: '停用尾部摺疊'
# 'Disable tail-predication in the ARM LowOverheadLoop pass'
HF132A6CB93FD: '停用ARM LowOverheadLoop pass中的尾部預測（tail-predication）'
# 'Disable that single precision floating-point divide and sqrt used in '
H475D4ABE9D62: '停用在...中使用單精準度浮點除法和平方根運算'
# 'Disable the ARM Parallel DSP pass'
H8178C8159BC2: '停用ARM Parallel DSP pass'
# 'Disable the CFI fixup pass'
H170DD55153F0: '停用CFI修復pass'
# 'Disable the Sparc delay slot filler.'
HDE8C0A85D477: '停用Sparc延遲插槽填充值'
# 'Disable the abort'
H9CB580C2DD7C: '停用abort函式'
# 'Disable the abort but emit a diagnostic on failure'
H84A7D406A5F3: '停用abort函式，但在失敗時發出診斷訊息'
# 'Disable the emission of assembler pseudo instructions'
H9E100408BFFF: '停用發射組件器偽指令'
# 'Disable the expand reduction intrinsics pass from running'
H040AA8C3CBF5: '停用執行展開reduction intrinsic的pass'
# 'Disable the generation of 4-operand madd.s, madd.d and related instructions.'
HB91438C02652: '停用生成 4 個操作元的madd.s、madd.d及相關指令'
# 'Disable the generation of low-overhead loops'
H1104A5C142EF: '停用生成低開銷循環'
# 'Disable the integrated assembler'
H779AD38A6D36: '停用整合式組件器'
# 'Disable the loop interchange pass'
H8A139F798C85: '停用循環交換pass'
# 'Disable the loop vectorization passes'
H55BB6EBCE09F: '停用循環向量化pass'
# 'Disable the module hash'
H7FE90FAE4F03: '停用模組雜湊值'
# 'Disable the parsing of an implicit top-level module op'
HF5D65FFCFADF: '停用隱含頂層模組指令的解析'
# 'Disable the pass entirely'
HA841AC9C39A5: '完全停用此pass'
# 'Disable the peephole optimizer'
H5AEFA90F7A64: '停用精簡優化器'
# 'Disable the select-optimization pass from running'
H0DA28C5C19DF: '停用select-optimization pass的執行'
# 'Disable the usage of LEB128 directives, and generate .byte instead.'
HFFB7D99931FD: '停用LEB128指令，並改用.byte指令生成。'
# 'Disable the use of non-volatile CR register fields'
H01F2C9F9FECF: '停用非揮發性CR寄存器字段的使用'
# 'Disable the use of stack protectors'
HCC816F874533: '停用堆疊保護機制'
# 'Disable the vector mask scheduling mutation'
H6FF8BC95F625: '停用向量遮罩排程的變更'
# 'Disable the verifier on parsing (very unsafe)'
H314B68416CA8: '在解析時停用驗證程序（極其不安全）'
# 'Disable the wasm-opt optimizer'
H214565A17764: '停用wasm-opt優化器'
# 'Disable thread-safe initialization of static variables'
H9A6053E9675B: '停用靜態變數的執行緒安全初始化'
# 'Disable threadgroup split execution mode (AMDGPU only)'
HFE9B2C98E16A: '停用執行緒群組分割執行模式（僅限AMDGPU）'
# 'Disable trapping for all sanitizers'
H434CA7F72650: '停用所有sanitizer的陷阱生成'
# 'Disable trapping for specified sanitizers'
H8374BC4644FA: '停用指定sanitizer的陷阱生成'
# 'Disable treating throwing global C++ operator new as always returning valid memory (annotates with __attribute__((returns_nonnull)) and throw()). This is detectable in source.'
H1293614D97E9: '停用將拋出異常的全域C++運算子new視為始終返回有效記憶體（使用__attribute__((returns_nonnull))和throw()進行註解）。此行為在原始程式碼中可被偵測到。'
# 'Disable trigraphs (default)'
H739A08E7CEDE: '停用三字符序列（預設）'
# 'Disable two address hints for register allocation'
H82ADA80F88F5: '停用記憶體配置的兩個位址提示'
# 'Disable two-phase name lookup in templates (default)'
HB877DF6B6337: '停用模板中的兩階段名稱搜尋（預設）'
# 'Disable type promotion pass'
HE0F6634D8D16: '停用類型提升pass'
# 'Disable unclustered high register pressure reduction scheduling stage.'
HAE3C6A80BF96: '停用未分群的高寄存器壓力降低調度階段。'
# 'Disable unused template argument warnings.'
H8A2178DF0ED5: '停用未使用模板參數警告。'
# 'Disable use of DFA during scheduling'
HFCEBEB8744EF: '停用調度期間的DFA使用。'
# 'Disable use of LD/ST pairs for SME2 or SVE2p1'
H886738D62F05: '停用SME2或SVE2p1的LD/ST配對使用。'
# 'Disable use of builtin functions'
H6011A85599FF: '停用內建函數的使用。'
# 'Disable use-after-destroy detection in MemorySanitizer'
H76DBA1F549C7: '停用MemorySanitizer的物件銷毀後使用偵測。'
# 'Disable use-after-scope detection in AddressSanitizer'
HDEA7FE9A7621: '停用AddressSanitizer的作業範圍結束後使用偵測。'
# 'Disable using constant pool for large integers.'
H8489E618879C: '停用大整數的常數池使用。'
# 'Disable using instrumentation data for profile-guided optimization'
H0DABDB711ED0: '停用配置文件引導型優化的插樁資料使用。'
# 'Disable using library calls for save and restore'
HABD1CF6BBA21: '停用保存和恢復的函式庫呼叫使用。'
# 'Disable validation'
H26FB09D2AB0A: '停用驗證。'
# 'Disable validation of precompiled headers'
H2DA6E28812C6: '停用預編譯標頭的驗證。'
# 'Disable validation of the diagnostic options when loading the module'
HE4C65ABEFA0D: '停用載入模組時診斷選項的驗證。'
# 'Disable vector double new-value-stores'
H46E40B609BEA: '停用向量雙精度新值存儲。'
# 'Disable verification of LLVM IR'
H1AB74862104E: '停用LLVM IR的驗證。'
# 'Disable virtual register cycle interference checks'
H2BA1419A0C46: '停用虛擬寄存器週期干擾檢查。'
# 'Disable whole program visibility (overrides enabling options)'
H1D60C5E310B2: '停用整個程式的可見性（覆蓋啟用選項）。'
# 'Disable writing diagnostic options'
H37E0E37A8998: '停用診斷選項的寫入。'
# 'Disable writing header search paths'
HCFD8074000E3: '停用標頭檔搜尋路徑的寫入。'
# 'Disable x86 relax relocations'
HB7F95908656B: '停用x86鬆弛重定位。'
# 'Disabled.'
HBC2D62F7229F: '已停用。'
# 'Disables -fvisibility-inlines-hidden-static-local-var (this is the default on non-darwin targets)'
H2552506748D2: '停用 -fvisibility-inlines-hidden-static-local-var（此為非Darwin目標的預設選項）'
# 'Disables combining addressing modes with different parts in optimizeMemoryInst.'
H1A57049BF682: '停用在optimizeMemoryInst中結合不同部分的位址模式'
# 'Disables debug printing for the new pass manager'
H92F40F826D39: '停用新管線管理器的除錯列印'
# 'Disables evaluation of GetElementPtr with constant operands'
H5A42772B82EF: '停用具有常數操作數的GetElementPtr運算式評估'
# 'Disables inttoptr/ptrtoint roundtrip optimization'
H03E816B33DC1: '停用inttoptr/ptrtoint往返優化'
# 'Disables potentially expensive checks in the transform interpreter, providing more speed at the expense of potential memory problems and silent corruptions'
H8C53B2F32644: '停用轉換解譯器中的高耗資源檢查，以速度優先但可能導致記憶體問題及靜默損壞'
# 'Disables the global instruction selector'
HD7298FC773DA: '停用全域指令選擇器'
# "Disallow '$' in identifiers"
HEC529DE7E6EB: "禁止識別符中使用 '$'"
# 'Disallow MIPS delay filler to search backward.'
H93B2211830F9: '禁止MIPS延遲插槽填充向後搜尋。'
# 'Disallow MIPS delay filler to search forward.'
H0A7403D7CADA: '禁止MIPS延遲插槽填充向前搜尋。'
# 'Disallow MIPS delay filler to search successor basic blocks.'
H806FD91060E7: '禁止MIPS延遲插槽填充搜尋後續基本區塊。'
# 'Disallow __declspec as a keyword'
HC17ADE50EB84: '禁止將__declspec視為保留字'
# "Disallow alternative token representations '<:', ':>', '<%', '%>', '%:', '%:%:'"
HF519C51A2110: "禁止替代運算子表示法 '<:', ':>', '<%', '%>', '%:', '%:%:'"
# 'Disallow atomic operations to ignore denormal mode'
HE8CD8EB9071A: '禁止原子運算忽略非規格化模式'
# 'Disallow complex IT blocks'
H020AA42EE64B: '禁止複雜IT區塊'
# 'Disallow converting instructions with negative immediates to their negation or inversion.'
H4A70CE206CB7: '禁止將具有負立即數的指令轉換為其反轉或反相形式。'
# 'Disallow generation of complex IT blocks. It is off by default.'
HB67D63CAAB67: '禁止生成複雜IT區塊。此選項預設為停用狀態。'
# 'Disallow generation of data access to code sections (AArch64/ARM only)'
HF9C8C76A5FB2: '禁止在程式碼區段存取資料（僅限AArch64/ARM）'
# 'Disallow merging of constants'
H70C4FD1FC35B: '禁止合併常數'
# 'Disallow use of CRC instructions (ARM only)'
HB840DEC2FEB5: '禁止使用CRC指令（ARM only）'
# 'Disallow use of CRC instructions (Mips only)'
H9E92A4FAF94C: '禁止使用CRC指令（Mips only）'
# 'Disallow use of movt/movw pairs (ARM only)'
H1C82DB59E408: '禁止使用movt/movw pairs（ARM only）'
# 'Disassemble strings of hex bytes'
H613CDE699EC0: '分解十六進位字節字符串'
# 'Disassembler Options'
H4DCD7C09D805: '分解器選項'
# 'Disassembler options'
H44D3EF88EF05: '分解器選項'
# 'Discard names from Value (other than GlobalValue).'
H742AC63D224D: '丢棄Value（GlobalValue以外）的名称。'
# 'Discard value names in LLVM IR'
HCD7AD84832F7: '丢棄LLVM IR中的值名稱'
# 'Discarded elements by the linker.'
HD3934CD11684: '連結器鬆弛優化所丢棄的元素。'
# 'Discriminator.'
H206A9AC4C507: '判別器。'
# 'Discriminators for inlined function instances.'
HCFDAECEFD17E: '内联函数实例的判別器。'
# "Display PDB's MS system elements."
H9055330B7E79: '顯示PDB的MS系統元素。'
# 'Display all available options'
H4F3544FDA0B5: '顯示所有可用選項'
# 'Display all basic blocks'
H75BB63BE80F7: '顯示所有基本區塊'
# 'Display all class members including data, constants, typedefs, functions, etc'
HCA18E04B4029: '顯示所有類別成員，包括資料、常數、typedefs、函數等'
# 'Display all symbols (default)'
H809598610BD8: '顯示所有符號（預設）'
# 'Display all types (implies -classes, -enums, -typedefs)'
H5D20AC3AE6F6: '顯示所有類型（隱含 -classes, -enums, -typedefs）'
# 'Display any symbol or type with the specified exact name'
H2B91D0A39EC5: '顯示任何具有指定精確名稱的符號或類型'
# 'Display arrays'
HDC2B25BF5710: '顯示arrays'
# 'Display available options'
H46A7DC1788BB: '顯示可用選項'
# 'Display available options (--help-hidden for more)'
HB2294B093626: '顯示可用選項（使用 --help-hidden 可查看隱藏選項）'
# 'Display branch counts instead of percentages (requires -b)'
HE5D58860A9A5: '顯示分支次數而非百分比（需搭配 -b 選項）'
# 'Display branch probabilities'
H1A848099A8E1: '顯示分支概率'
# 'Display class types'
H4B4B15B36D12: '顯示類型別'
# 'Display compilands'
H98204E2FD2A3: '顯示可編譯單元'
# 'Display data symbols'
HE0831CC1C7E5: '顯示資料符號'
# 'Display each error as well as a summary. [default]'
HB4E9ED4A232D: '顯示每個錯誤以及摘要。[預設]'
# 'Display each error in detail but no summary.'
H84BA445E865B: '詳細顯示每個錯誤，但不顯示摘要。'
# 'Display enum types'
H7D0238663B0A: '顯示列舉類型'
# 'Display execution times'
HA3302D5C387F: '顯示執行時間'
# 'Display exploded graph using GraphViz'
H57BD4170B555: '使用 GraphViz 顯示爆炸圖'
# 'Display function signatures'
H616CCB32163A: '顯示函數簽名'
# 'Display function symbols'
H2496573880E0: '顯示函數符號'
# 'Display help for hidden options'
H64D149DE5706: '顯示隱藏選項的說明'
# 'Display include stacks for diagnostic notes'
HBF49F525A9C8: '顯示診斷註釋的包含堆疊'
# 'Display injected sources'
H615D1D35669F: '顯示注入的來源碼'
# 'Display list of all available options'
HC3085F81E368: '顯示所有可用選項的列表'
# 'Display list of available options (--help-list-hidden for more)'
H6C69B229E72D: '顯示可用選項的列表（使用 --help-list-hidden 可查看更多）'
# "Display lists of good files (no compile errors), problem files, and a combined list with problem files preceded by a '#'."
HC6E030BB5330: '顯示無編譯錯誤的檔案清單、問題檔案清單，以及以 "#" 開頭的問題檔案組合清單。'
# 'Display method for pass statistics'
H93E064D4A3FD: '顯示Pass的統計資料方法'
# 'Display method for timing data'
H6D05268C903F: '顯示時間統計資料'
# 'Display more information when dumping selection DAG nodes.'
H7335ABA75176: '在輸出選擇式DAG節點時顯示更多詳細資訊。'
# 'Display only a summary of the errors found.'
HD9988E75DBC1: '僅顯示發現錯誤的摘要。'
# 'Display patch-like changes'
H944897EBC1CF: '以類似程式碼修改格式顯示變更'
# 'Display patch-like changes in quiet mode'
H1874C26C00E8: '以靜默模式顯示類似程式碼修改格式的變更'
# 'Display patch-like changes in quiet mode with color'
HDA3927492A7C: '以帶顏色的靜默模式顯示類似程式碼修改格式的變更'
# 'Display patch-like changes with color'
HC5827DF84A7E: '以帶顏色的格式顯示類似程式碼修改格式的變更'
# 'Display pointer types'
H5EE2D9F1E113: '顯示指標類型'
# 'Display statistics as json data'
H332F68176CB1: '以JSON格式顯示統計資料'
# 'Display suggestions to update code associated with -Wunsafe-buffer-usage warnings'
H5B046555524E: '顯示與-Wunsafe-buffer-usage警告相關的程式碼更新建議'
# 'Display symbols for each compiland'
H087A1D8A2407: '為每個編譯單元顯示符號'
# 'Display the SLP trees with Graphviz'
H5A01A170758F: '使用Graphviz顯示SLP樹狀結構'
# "Display the compiler's target processor"
HFDA3133B76AB: '顯示編譯器的目標處理器'
# 'Display the count broken down by the filepath of each remark emitted. Requires remarks to have DebugLoc information.'
HDD5492CA6C68: '顯示每個發出的註記所對應的來源檔案路徑的計數分解。需要註記具有DebugLoc資訊。'
# 'Display the list of -analyzer-config options. These are meant for development purposes only!'
HEEAD9A5EE121: '顯示所有的-analyzer-config選項列表。這些選項僅供開發用途！'
# 'Display the list of analyzer checkers that are available'
H74EADAEE0F8E: '顯示可用的分析器檢查器列表'
# 'Display the list of checker and package options'
H9FD261E9343C: '顯示檢查器和套件的選項列表'
# 'Display the list of checker and package options meant for development purposes only'
H99D575B08548: '顯示僅供開發用途的檢查器和套件選項列表'
# 'Display the list of developer-only checkers such as modeling and debug checkers'
H5D875C21A22A: '顯示僅限開發者的檢查器清單（例如建模和除錯檢查器）'
# 'Display the list of enabled analyzer checkers'
HDD1AC8873D07: '顯示已啟用的分析器檢查器清單'
# 'Display the list of in development analyzer checkers. These are NOT considered safe, they are unstable and will emit incorrect reports. Enable ONLY FOR DEVELOPMENT purposes'
H9701D9AE6717: '顯示開發中的分析器檢查器清單。這些尚未考慮安全性，可能不穩定且會產生錯誤報告。僅允許在開發階段啟用'
# 'Display the list of in development checker and package options. These are NOT considered safe, they are unstable and will emit incorrect reports. Enable ONLY FOR DEVELOPMENT purposes'
H44975E30827B: '顯示開發中的檢查器及套件選項清單。這些尚未考慮安全性，可能不穩定且會產生錯誤報告。僅允許在開發階段啟用'
# 'Display the statistics of each pass'
HC9CD9384324F: '顯示每個pass的統計數據'
# 'Display the version of the compiler'
H5C279623CA4C: '顯示編譯器版本'
# 'Display the version of this program'
H5228B6ADFC09: '顯示本程序的版本'
# 'Display thunk symbols'
H60D32CD26A79: '顯示thunk符號'
# 'Display typedef types'
H80D29E660696: '顯示typedef類型'
# 'Display unconditional branch info (requires -b)'
H860C02BEA720: '顯示無條件跳轉資訊（需指定 -b）'
# 'Display vftable shapes'
H0BAEA6CF044D: '顯示vftable形狀'
# 'Displays only those classes which have at least the specified amount of immediate padding, ignoring padding internal to bases and aggregates.'
H4365E41B0200: '僅顯示立即填充量至少為指定值的類別（不考慮基類和聚合類型內部的填充）'
# 'Displays only those classes which have at least the specified amount of padding.'
HC457A02E6744: '僅顯示填充量至少為指定值的類別'
# 'Displays only those types which are greater than or equal to the specified size.'
H939E231DB942: '僅顯示大小大於或等於指定值的類型'
# 'Divisor of cold branch probability.BranchProbability = 1/ColdBranchProbDenom'
HFEB48317469C: '冷跳轉機率的除數。BranchProbability = 1/ColdBranchProbDenom'
# 'Do PGO instrumentation sampling'
H20E4EAC6B490: '執行PGO插樁採樣'
# 'Do counter register promotion'
H9B115D4FE5B7: '執行計數器寄存器提升'
# 'Do counter update using atomic fetch add  for promoted counters only'
H7767713DC2D0: '僅對提升的計數器使用原子fetch add進行更新'
# 'Do more PHI writes than necessary in order to avoid partial accesses'
HE1D29CA7DAB8: '進行比必要更多的PHI寫入以避免部分存取'
# 'Do not accept non-standard constructs supported by the z/OS compiler'
HD8F703A83AED: '不接受z/OS編譯器支援的非標準語法結構'
# 'Do not add %INCLUDE% to include search path'
H7E3445F24099: '不將%INCLUDE%加入包含路徑搜尋清單'
# 'Do not add -rpath with architecture-specific resource directory to the linker flags. When --hip-link is specified, do not add -rpath with HIP runtime library directory to the linker flags'
H98822B20FC31: '不將與特定架構資源目錄相關的-rpath加入連結器旗標。當指定--hip-link時，不將與HIP執行階段函式庫目錄相關的-rpath加入連結器旗標'
# 'Do not add a BTI instruction after a setjmp or other return-twice construct (Arm/AArch64 only)'
H97946DA95B7B: '不對setjmp或其他可返回兩次的結構後添加BTI指令（僅限Arm/AArch64）'
# 'Do not add include paths for CUDA/HIP and do not include the default CUDA/HIP wrapper headers'
HCB5DBE4305C2: '不加入CUDA/HIP的包含路徑，也不包含預設的CUDA/HIP包裝標頭'
# 'Do not add instruction count to lsr cost model'
HE7651E5EC0B1: '不將指令計數加入lsr成本模型'
# 'Do not add parameter bounds and do no gist simplify sets accordingly'
HC6FB1327B189: '不加入參數界限，也不根據此進行gist簡化集合'
# 'Do not align and prefetch loops'
HFA5D85E291BA: '不對迴圈進行對齊與預取'
# 'Do not allocate the LR register for general purpose usage, only for calls. (AArch64 only)'
H80E0CE8F43D2: '不將LR寄存器用作一般用途，僅限呼叫使用（僅限AArch64）'
# 'Do not allow compiler to merge handlers for any sanitizers'
HC4FB93EDAFBC: '禁止編譯器合併任何sanitizers的handlers'
# 'Do not allow compiler to merge handlers for specified sanitizers'
H14D0727FA9D4: '禁止編譯器合併指定sanitizers的handlers'
# 'Do not assume C++ operator new may not return NULL'
H1F6F59A37FC5: '不假設C++運算子new不會傳回NULL'
# 'Do not assume that any loop is finite.'
H5580E1E87EBF: '不假設任何迴圈都是有限的'
# 'Do not assume that externally defined data is in the small data if it meets the -G <size> threshold (MIPS)'
HAD54547B8D0E: '不將符合-G<size> 門檻的外部定義資料視為小資料（MIPS）'
# 'Do not automatically generate or update the global module index'
H6DB4D9D7E3EF: '不自動產生或更新全域模組索引'
# 'Do not automatically import modules for error recovery'
H8260A94CB46D: '不為錯誤恢復自動匯入模組'
# 'Do not build run-time checks to proof absence of integer wrapping'
H067730FFEE80: '不建立執行階段檢查以驗證無整數溢位'
# 'Do not bundle output files of HIP device compilation'
H3591F62084D9: '不包裝HIP裝置編譯的輸出檔案'
# 'Do not check authenticated address'
H0709C5934F02: '不檢查驗證位址'
# 'Do not color Edges'
HAA019B0E453C: '不著色邊'
# 'Do not color Vertices'
HCD93BE0D4AC9: '不要著色頂點'
# 'Do not color vertices'
H1FA039A4B956: '不要著色頂點'
# 'Do not combine ALU and memory operators'
H22D1C7806EDC: '不要合併ALU和記憶體運算子'
# 'Do not consider inline-asm a scheduling/packetization boundary.'
H930DAD5CB7A3: '不要將內聯組裝視為調度/分組邊界。'
# 'Do not convert branches that may exit the loop'
H912C8CC5220C: '不要轉換可能退出迴圈的分支'
# 'Do not convert find-first-byte loop(s).'
H586B9EEE9F17: '不要轉換尋找第一個字節的迴圈。'
# 'Do not create a host fallback if offloading to the device fails.'
HFCABEED29F02: '如果裝置卸載失敗，不要建立主機回退。'
# 'Do not create extra branches to split comparison logic.'
H67D6951DD9C2: '不要創建額外的分支來分割比較邏輯。'
# 'Do not create unit-strided loops (default)'
HA7BFEC1D48BB: '不要創建單一間距的迴圈（預設）'
# 'Do not discard comments when preprocessing'
HF9B5FA45AABB: '預處理時不要忽略註解'
# 'Do not discard value names in LLVM IR'
H4D77D8B34317: '不要在LLVM IR中忽略值名稱'
# 'Do not dllexport/dllimport inline member functions of dllexport/import classes'
H178235CEFFFB: '不要對dllexport/import類別的內聯成員函數進行dllexport/dllimport'
# 'Do not drop any type tests'
H0426A41590E9: '不要刪除任何類型檢查'
# 'Do not dump MSF file headers'
H5B5B36671D5C: '不要傾印MSF檔標頭'
# 'Do not elide types when printing diagnostics'
HAAA41F99F968: '在列印診斷資訊時不要省略類型'
# 'Do not eliminate read instrumentation for read-before-writes'
HFAB29E5FAAB8: '不要消除讀取之前的寫入插樁'
# 'Do not embed'
H58D31A15C486: '不要嵌入'
# 'Do not emit  debug info for defined but unused types'
HB04F2AC6377B: '不要為已定義但未使用的類型發出除錯資訊'
# 'Do not emit RTTI data'
H0669AFF65C8F: '不要發出RTTI資料'
# "Do not emit a trap instruction for 'unreachable' IR instructions after noreturn calls, even if --trap-unreachable is set."
HB71318F0BBDA: "即使設定了--trap-unreachable，也不要對noreturn呼叫後的 'unreachable' IR指令發出陷阱指令。"
# 'Do not emit code that uses the red zone.'
H4923C3F307F8: '不產生使用紅區的程式碼。'
# 'Do not emit code to make initialization of local statics thread safe'
HB028FFDC42D1: '不產生確保本地靜態變數初始化為執行緒安全的程式碼'
# 'Do not emit code to perform on-demand initialization of thread-local variables'
HC624E884FFD9: '不產生執行緒局部變數的按需初始化程式碼'
# 'Do not emit macro debug information'
H8F91A57AE16C: '不產生巨集除錯資訊'
# 'Do not emit metadata containing compiler name and version'
HAB66E1C6275C: '不產生包含編譯器名稱和版本的元數據'
# 'Do not emit pseudo probes for sample profiling'
H98592A339F09: '不產生範例剖析用的偽探針'
# 'Do not emit remarks about assumptions that are known'
H0F5A09E813C1: '不列印已知假設的假設資訊'
# 'Do not enforce -fmodules-decluse and private header restrictions for textual headers. This flag will be removed in a future Clang release.'
H0CAD9E73AF57: '不強制執行-fmodules-decluse和私有標頭對文字標頭的限制。此旗標將在未來的Clang版本中移除。'
# 'Do not error on use of NSAllocateCollectable/NSReallocateCollectable'
HFB2D301661F8: '不因使用NSAllocateCollectable/NSReallocateCollectable而出錯'
# 'Do not execute loaded code'
HAC6A8BA715B2: '不執行已載入的程式碼'
# 'Do not extend the -G behaviour to object local data (MIPS)'
HE38064F00B03: '不擴展-G行為以涵蓋物件本地資料（MIPS）'
# 'Do not fail and just print warnings.'
H194F6AFAEB48: '不因錯誤而終止，僅列印警告訊息。'
# 'Do not fail on the first error.'
H09A7570CEE99: '不因第一個錯誤而終止。'
# 'Do not follow the AAPCS standard requirement stating that volatile bit-field width is dictated by the field container type. (ARM only).'
H33C6AFA87C27: '不遵循AAPCS標準要求：volatile位段寬度由字段容器類型決定（僅限ARM）。'
# 'Do not generate code for uses of this PCH that assumes an explicit object file will be built for the PCH'
H882EA3DF4A8E: '不為此PCH的假設其顯式物件檔將被建立的使用生成程式碼'
# 'Do not generate comments'
H64C7ECF357DC: '不產生註解'
# 'Do not generate debug info for types in an object file built from this PCH and do not generate them elsewhere'
H4C63A76D37C7: '不為從此PCH建立的物件檔生成類型的除錯資訊，也不在其他地方生成'
# 'Do not generate load-load barrier instructions (dbar 0x700)'
H2C61D7A4E1E5: '不產生載入-載入屏障指令（dbar 0x700）'
# 'Do not globally set the denormals-are-zero (DAZ) and flush-to-zero (FTZ) bits in the floating-point control register on program startup'
H792FD67CD9D7: '不全局設置浮點控制寄存器中的denormals-are-zero (DAZ)和flush-to-zero (FTZ)位元'
# 'Do not hoist instructions if targetblock is N times hotter than the source.'
HFE3581AD2058: '如果目標區塊比來源熱N倍，則不提升指令。'
# "Do not include PTX for the following GPU architecture (e.g. sm_35) or 'all'. May be specified more than once."
H3358F862A98F: "不要包含下列GPU架構（例如sm_35）或'全部'的PTX。可指定多於一次。"
# 'Do not include column number on diagnostics'
H6BC5ADEE7CCD: '不要在診斷中包含列號'
# 'Do not include declarations inside namespaces (incl. global namespace) in the code-completion results.'
HB945B735ADE9: '在代碼補完結果中不要包含命名空間（包含全域命名空間）內部的宣告。'
# 'Do not include fixit information in diagnostics'
H9F028B9AB9A0: '在診斷中不要包含修正資訊。'
# 'Do not include global declarations in code-completion results.'
H5184034D4282: '在代碼補完結果中不要包含全域宣告。'
# 'Do not include source location information with diagnostics'
HC43E127B525B: '在診斷中不要包含來源位置資訊。'
# 'Do not include the default HIP wrapper headers and include paths'
HF033C0F0A8BE: '不要包含預設的HIP包裹標頭檔和包含路徑'
# 'Do not inline functions with a stack size that exceeds the specified limit'
HF6E40440F4E2: '不要內聯堆疊大小超過指定限制的函數'
# 'Do not inline recursive functions with a stack size that exceeds the specified limit'
HE8D9228D38D0: '不要內聯堆疊大小超過指定限制的遞迴函數'
# 'Do not instrument callsites to functions in this list. Intended for testing.'
HEEE67A6ADD3A: '不要插樿此清單中函數的調用位置。用於測試。'
# 'Do not instrument functions smaller than this threshold.'
H0676C97A079B: '不要插樿小於此門檻的函數。'
# 'Do not instrument functions with the number of critical edges  greater than this threshold.'
HAC5F841AADEE: '不要插樿具有大於此門檻的關鍵邊數的函數。'
# 'Do not instrument promotable allocas'
HFE692DA83BC2: '不要插樿可提升的allocas'
# 'Do not label Edges'
H02B067792434: '不要標記邊'
# 'Do not label Vertices'
HF8CF06D59C0D: '不要標記頂點'
# 'Do not let object file auto-link default libraries'
H77A1B6D3EF99: '不要讓物件檔自動連結預設函式庫'
# 'Do not link against HIP runtime libraries'
H29FEC2BA3B74: '不要連結HIP執行階段函式庫'
# 'Do not link device library for CUDA/HIP device compilation'
HEC768FBA7D56: '在CUDA/HIP裝置編譯時不要連結裝置函式庫'
# 'Do not make the jump table addresses canonical in the symbol table'
H6138F7A3816E: '不要在符號表中將跳轉表位址規範化'
# 'Do not modify integer comparisons.'
H85B2E33EE3E8: '不要修改整數比較。'
# 'Do not omit the RTTI component from virtual tables'
H29D8FAD7370D: '不省略虛函數表中的RTTI成分'
# 'Do not optimize lifetime zones that are broken'
HDB8A084545A8: '不優化已損壞的生命周期區域'
# 'Do not output any .gcov files'
H5B1E0C37199B: '不輸出任何.gcov文件'
# 'Do not override toolchain to compile HIP source to relocatable'
H67099DA33091: '不覆寫工具鏈以將HIP來源編譯為可重新定位的'
# 'Do not place constants in the .rodata section instead of the .sdata if they meet the -G <size> threshold (MIPS)'
H21A91E9ACB5C: '如果符合 -G <size> 門檻，則不將常數置於 .rodata 區段而非 .sdata 區段（MIPS）'
# 'Do not preserve comments in inline assembly'
H942DAB64A211: '不保留內聯組裝語法中的註釋'
# 'Do not prevent DecoderTable duplications caused by HwModes'
H38CABD41B4CC: '不阻止由HwModes引發的DecoderTable重複'
# 'Do not print instruction tables'
HF7003F2ECEFB: '不列印指令表'
# 'Do not print per-code histogram'
HC08155C4172C: '不列印按代碼的直方圖'
# 'Do not print the name of each compiled file (default)'
H5DF4E1712DEF: '不列印每個已編譯檔的名稱（預設）'
# 'Do not process trigraph sequences'
H0D43C57804DE: '不處理三元符號序列'
# 'Do not produce relaxation hints for linkers to try optimizing PIC call sequences into direct calls (MIPS only)'
HCE5BC5F9BE43: '不產生連結器鬆弛優化的提示以嘗試將PIC呼叫序列優化為直接呼叫（僅限MIPS）'
# 'Do not prune non-affecting module map files when writing module files'
H5ABD84685A1F: '在寫入模組檔時，不修剪無效的模組地圖檔'
# 'Do not put each data item in its own section (default)'
HF88D281A3FD5: '不將每個資料項目置於其獨立的區段（預設）'
# 'Do not put each function in its own section (default)'
HCE20256E9133: '不將每個函數置於其獨立的區段（預設）'
# 'Do not re-analyze paths leading to exhausted nodes with a different strategy (may decrease code coverage)'
HDFE0F346053C: '不以不同的策略重新分析導致耗盡節點的路徑（可能降低程式碼覆蓋率）'
# 'Do not read real performance counters, use dummy values (for testing)'
H85D51A611E68: '不讀取真實的效能計數器，改用虛值（用於測試）'
# 'Do not rebase if number of dependent constants of a Base is less than this number.'
H5F4C154B55E1: '如果基底的依賴常數數量小於此數值，則不重新基底'
# 'Do not record stack ring history'
HFF15CDD011A3: '不記錄堆疊環狀歷史紀錄'
# 'Do not remove finalize method in gc mode'
H986F722192B5: '不在gc模式中移除finalize方法'
# 'Do not remove function attributes'
HAF5DC7041092: '不要移除函式屬性'
# 'Do not remove global named metadata'
H8C721AA4D60E: '不要移除全域命名的元資料'
# 'Do not remove global variables'
H715B487CBBAD: '不要移除全域變數'
# 'Do not remove implausible terminators or other similar cleanups'
HFBFADCCB2615: '不要移除不合理的終止節點或其他類似的清理操作'
# 'Do not report an error for non-bitcode files in archives'
H656A3544880E: '不要因存檔中的非bitcode檔案而報告錯誤'
# 'Do not require member pointer base types to be complete if they would be significant under the Microsoft ABI'
H7A0FDA03C4CD: '如果在Microsoft ABI下這些基類型會被視為重要，則不要要求它們是完整的'
# "Do not resolve lli process symbols in JIT'd code"
HF4ADB638CB76: '不要在JIT代碼中解析lli進程符號'
# 'Do not resolve to llvm-jitlink process symbols'
H0C15A19D6DA3: '不要解析至llvm-jitlink進程符號'
# 'Do not run the verifier'
H227D5D3081B9: '不要執行驗證器'
# 'Do not run the verifier during the optimization pipeline'
H812C7F5AE104: '在優化管線期間不要執行驗證器'
# 'Do not run verifier on input LLVM (dangerous!)'
H91033F23321D: '不要在輸入LLVM中執行驗證器（危險！）'
# 'Do not separate the constant offset from a GEP instruction'
H1A5B4ED53276: '不要將GEP指令中的常數偏移量分離'
# 'Do not set the default structure layout to be compatible with the Microsoft compiler standard'
H9523EC62FA32: '不要將預設結構布局設定為與Microsoft編譯器標準相容'
# 'Do not sink instructions that have too many uses.'
H7989366B848B: '不要下沈具有太多使用處的指令'
# 'Do not sink instructions that require cloning unless they execute less than this percent of the time.'
HFCE852F940A6: '不要下沈需要複製的指令，除非它們的執行次數低於此百分比'
# 'Do not split loads or stores'
H5C77F77F7EDB: '不要分割載入或儲存'
# 'Do not strip debug info metadata'
H72442AB7AE2C: '不要移除除錯資訊元資料'
# 'Do not strip debug type info metadata'
H773E596FDA32: '不要移除除錯類型資訊元資料'
# 'Do not take inbounds assumptions at all'
H3B09FD23C9A9: '完全不要採用inbounds假設'
# 'Do not treat C++ operator name keywords as synonyms for operators'
HF45D733F49BB: '不要將C++運算符名稱關鍵字視為運算符的同義詞'
# 'Do not treat all horizontal whitespace as equivalent'
H821E9671833B: '不要將所有水平空白視為等效'
# 'Do not treat usage of null pointers as undefined behavior'
H81D67D4AE33E: '不要將空指標的使用視為未定義行為'
# 'Do not treat warnings as errors (default)'
H9D2EBEBFE5AF: '不要將警告視為錯誤（預設值）'
# 'Do not try to find alias store for a load if the block number in the straight line is higher than this threshold.'
HA9F23FA6536D: '如果直線執行路徑中的區塊號大於此閾值，則不嘗試為該載入操作尋找別名存儲'
# 'Do not try to find alias store for a load if there is a in-path block whose instruction number is higher than this threshold.'
H9F8822A4702E: '如果存在路徑中的區塊，其指令編號大於此閾值，則不嘗試為該載入操作尋找別名存儲'
# 'Do not use CSPGO.'
HF15B70CBCC17: '不要使用CSPGO.'
# 'Do not use GP relative accesses for symbols known to be in a small data section (MIPS)'
HD0753F3CDAB8: '不要為已知位於小型數據段的符號使用GP相對存取（MIPS）'
# 'Do not use HLFIR lowering (deprecated)'
HE332EA8EB38E: '不要使用HLFIR降階（已棄用）'
# 'Do not use PGO.'
H19DC80776155: '不要使用PGO.'
# 'Do not use an early exit if isLiveOutPastPHIs returns true.'
HA74DFEC29B52: '如果isLiveOutPastPHIs返回true，則不提前退出'
# 'Do not use compact branches if possible.'
H541C69D3E8C0: '若可能，則不使用緊湊分支'
# 'Do not use div.w[u] and mod.w[u] instructions with input not sign-extended.'
H5B65DD1D4E29: '不要使用輸入未符號延展的div.w[u]和mod.w[u]指令'
# 'Do not use hardware multiplier'
H2D984261D820: '不要使用硬體乘法器'
# 'Do not use jump tables for lowering switches'
H553BE5736ED7: '不要在降階切換時使用跳轉表'
# 'Do not use more megabytes of memory'
HABD5A40DFA1B: '不要使用更多MB的記憶體'
# 'Do not use the -dce pass to reduce testcases'
HAA57D41E6E51: '不要使用-dce pass來縮減測試案例'
# 'Do not use the -simplifycfg pass to reduce testcases'
H29CCC0670DF0: '不要使用-simplifycfg pass來縮減測試案例'
# 'Do not use the analyzed objects when unparsing'
H83CE402540D9: '在反解析時不要使用已分析的物件'
# 'Do not use the experimental C++ class ABI for classes with virtual tables'
H6D985C46C06C: '不要為具有虛函數表的C++類使用實驗性類ABI'
# 'Do not validate testcase is interesting after counting chunks (may speed up reduction)'
HA696CDBE3AE6: '在計算碎片後不驗證測試案例是否有趣（可能加快縮減）'
# 'Do not verify input module'
H39AA36F540E0: '不驗證輸入模組'
# 'Do not warn about individual formatting changes needed. Used only with --dry-run or -n'
H754226DD39F9: '不針對需要的格式更改發出警告。僅與 --dry-run 或 -n 一起使用'
# 'Do not write current time into COFF output (breaks link.exe /incremental)'
HBABC5A49FA79: '不將當前時間寫入COFF輸出（會中斷link.exe /incremental）'
# 'Do not write result bitcode file'
H22D616F37560: '不寫入結果位元碼檔案'
# 'Do not zero initialize globals without default initialization'
HECF1970A8089: '不對未經預設初始化的全域變量進行零初始化'
# 'Do nothing'
HD268BA5209C4: '什麼都不做'
# 'Do profile annotation and inlining for functions in top-down order of call graph during sample profile loading. It only works for new pass manager. '
HF43D143A0C90: '在載入範例剖析資料時，按照調用圖的自頂向下順序對函數進行剖析註釋和內嵌處理。此功能僅適用於新式 Pass 管理器。 '
# 'Do pseudo probe verification'
HC942827254CC: '執行偽探針驗證'
# 'Do static counter allocation for value profiler'
H465B564B215B: '為值剖析器進行靜態計數器配置'
# 'Document only public declarations.'
HAA6808E72416: '僅記錄公用宣告。'
# 'Documentation in HTML format.'
H35BAD16C1698: '以HTML格式輸出文件。'
# 'Documentation in MD format.'
HA974194AB003: '以MD格式輸出文件。'
# 'Documentation in YAML format.'
H5814855B30B7: '以YAML格式輸出文件。'
# 'Dominance Frontier Construction'
H0D043E29B031: '優勢邊界建構'
# 'Dominator Tree Construction'
HD7B4E93722B4: '優勢樹建構'
# "Don't Use the new driver for offloading compilation."
H348818D3A16A: '不要使用新的驅動程式進行卸載編譯。'
# "Don't allow device side init function in HIP (experimental)"
H8D56505F6239: '在HIP中不允許裝置端初始化函數（實驗性）'
# "Don't allow loop unrolling to simulate more than this number of iterations when checking full unroll profitability"
HA88E0E56432E: '在檢查完全展開的效益時，禁止將迴圈展開模擬超過此數量的迭代次數'
# "Don't assume assembly file starts in the text section"
HFEF6F05E02CF: '不假設組合語言檔案從文字區段開始'
# "Don't assume data segments are relative to text segment"
H1D0D36BE1FD6: '不假設資料區段相對於文字區段'
# "Don't assume that C++'s global operator new can't alias any pointer"
HC32AE2553730: '不要假設C++的全域operator new不會與任何指標重疊'
# "Don't assume that kernels are launched with uniform block sizes (default true for CUDA/HIP and false otherwise)"
H328B84E6AEC0: '不要假設核函數是以統一區塊大小啟動（預設CUDA/HIP為true，其他為false）'
# "Don't automatically start assembly file with a text section"
HB573B3460C18: '不要自動在組合語言檔案開頭添加文字段'
# "Don't clear counters across dumps (use with instrumentation-sleep-time option)"
HFB41C45D3123: '不要在剖面資料傾印時清除計數器（需配合插樿-sleep-time選項使用）'
# "Don't clear the Clang AST before running backend code generation"
H438A0AAAB7E0: '在執行後端程式碼產生前不清除Clang AST'
# "Don't convert memcpy to TP loop."
H4B53144272CD: '不要將memcpy轉換為TP迴圈。'
# "Don't defer host/device related diagnostic messages for CUDA/HIP"
H9AB401869BF7: '不要延遲CUDA/HIP的主機/裝置相關診斷訊息'
# "Don't demangle function names"
H618F1A05266D: '不要轉換函數名稱的符號'
# "Don't disable block signature string)"
HD22256B8D923: '不要禁用區塊簽名字串)'
# "Don't disable features used for crash debugging (crash reports, llvm-symbolizer and core dumps)"
HA02320B35AF6: '不要禁用用於程式崩潰除錯的功能（崩潰報告、llvm-symbolizer 和核心記憶體傾印）'
# "Don't discard temporary labels"
H59AD35796471: '不要捨棄暫存標籤'
# "Don't display class definitions"
HF6C8FDDA5009: '不要顯示類別定義'
# "Don't display full enum definitions"
HB5A6C783A07D: '不要顯示完整的列舉型別定義'
# "Don't do the coverage check."
H193F8F133737: '不要執行覆蓋率檢查。'
# "Don't dump anything."
HA287D365311B: '什麼都不傾印。'
# "Don't emit an address-significance table"
H7A772E673769: '不要發出地址重要性表'
# "Don't emit anything (for timing purposes)"
H097B7300276D: '什麼都不發出（用於效能測試）'
# "Don't emit compiler path and command line into CodeView debug information"
H76DE26A5896D: '不要將編譯器路徑和命令行資訊發出至CodeView除錯資訊'
# "Don't emit errors on invalid analyzer-config inputs"
H344F10286BA2: '不要對無效的分析器配置輸入發出錯誤'
# "Don't emit inline line tables."
H18C272BB702A: '不要發出內嵌行表。'
# "Don't emit warning for unused driver arguments"
HCD60E199F7C0: '不要發出未使用的驅動程式參數的警告'
# "Don't emit warnings about unused arguments for the following arguments"
H2C209A90E709: '不要發出以下參數的未使用參數警告'
# "Don't error out if the detected version of the CUDA install is too low for the requested CUDA gpu architecture."
H16AC4195802C: '如果偵測到的CUDA安裝版本低於請求的CUDA GPU架構要求，則不顯示錯誤'
# "Don't expand conditional move related pseudos for Mips 16"
H68A3ACC276BC: '不展開Mips 16 相關的條件移動偽指令'
# "Don't export branch data (LCOV)"
H15B1E91EF10C: '不匯出分支資料（LCOV）'
# "Don't export expanded source regions"
H4609EDADC332: '不匯出展開的原始程式區域'
# "Don't export per-function data"
H2769FE377EEE: '不匯出每個函數的資料'
# "Don't extract blocks when searching for miscompilations"
H82D476F902A7: '在搜尋編譯錯誤時，不提取區塊'
# "Don't extract loops when searching for miscompilations"
H9384DB503321: '在搜尋編譯錯誤時，不提取迴圈'
# "Don't generate implicit floating point or vector instructions"
H54B5124D5D1B: '不產生隱式浮點或向量指令'
# "Don't generate local calls to out-of-line atomic operations"
H96F508547438: '不產生對行外原子運算的本地呼叫'
# "Don't include vectorization factors, etc."
HB5557A169D42: '不包含向量化因素等'
# "Don't instrument functions with loops unless they also meet the minimum function size"
H574C69576F45: '如果函數的大小未達最低要求，則不對包含迴圈的函數進行插樁'
# "Don't instrument scalar globals"
H6894CA3DD417: '不對純量全域變數進行插樁'
# "Don't instrument scalar stack variables"
H87D069F48ECC: '不對純量堆疊變數進行插樁'
# "Don't keep static const variables even if unused"
H286AB8A3B099: '即使未使用，也不保留靜態常數變數'
# "Don't match or outline intrinsics"
H34D78D938C2B: '不匹配或列舉內建函數'
# "Don't mutate strict-float node to a legalize node"
H6DCCA4AAE41B: '不將嚴格浮點節點轉換為合法化節點'
# "Don't output the .ll file"
H1B261E3A62B3: '不輸出.ll檔'
# "Don't perform type checking of the assembly code (wasm only)"
HDF197C4FAB89: '不對組合語言程式碼執行類型檢查（僅限wasm）'
# "Don't place zero initialized data in BSS"
H2108D326FE0B: '不要將零初始化的資料放在BSS段'
# "Don't place zero-initialized symbols into bss section"
H6FEBA18EB379: '不要將零初始化的符號放入bss段'
# "Don't prefer any addressing mode"
H8ABFDD32EA98: '不偏好任何地址模式'
# "Don't preserve line numbers (default)"
H9468F0C93544: '不要保留行號（預設值）'
# "Don't preserve order of LLVM use-lists when serializing"
HC0EBF389C575: '在序列化時，不要保留LLVM使用清單的順序'
# "Don't propagate function-attrs in thinLTO"
HA4C570976962: '不要在thinLTO中傳播函數屬性'
# "Don't relax loads to long loads - for testing purposes"
H30C29761BE41: '不要進行鬆弛優化將負載轉換為long loads - 為測試目的'
# "Don't run the LLVM IR verifier pass"
H5E9DB83319CA: '不要執行LLVM IR驗證pass'
# "Don't run the LLVM verifier during the optimization pipeline"
HBB1839A83C81: '在優化管線期間不要執行LLVM驗證器'
# "Don't show any SymIndexId fields (overrides -hierarchy)"
H9033D913589F: '不要顯示任何SymIndexId欄位（覆寫-hierarchy選項）'
# "Don't show compiler generated types and symbols"
H6CE8BA80D4D4: '不要顯示編譯器生成的類型和符號'
# "Don't show symbols from system libraries"
H1D2970DB0285: '不要顯示來自系統函式庫的符號'
# "Don't specialize functions that have less than this number of instructions"
H6394C9853CC0: '不要特殊化具有少於此數量指令的函數'
# "Don't specify that kernel argument names are preserved (HIP only)"
H682A59EE1E8F: '不要指定保留核心參數名稱（僅限HIP）'
# "Don't specify that single precision floating-point divide and sqrt used in the program source are correctly rounded (HIP device compilation only)"
HAC5422C51310: '不要指定程式來源中使用的單精度浮點除法和平方根運算是否正確捨入（僅限HIP裝置編譯）'
# "Don't tail-predicate loops"
H2D6501929AEC: '不要對迴圈進行尾部條件判斷優化'
# "Don't tail-predicate loops, create scalar epilogue"
H9B8DA5043D54: '不要對迴圈進行尾部條件判斷優化，建立純量後綴'
# "Don't treat conditional branches as disclosure gadgets. This may improve performance, at the cost of security."
H9B8D554F070F: '不要將條件分支視為資訊洩漏組件。這樣可能會提升效能，但會降低安全性。'
# "Don't treat control flow paths that fall off the end of a non-void function as unreachable"
H5D4780A60912: '不要將非void函數末尾掉出的控制流路徑視為無法到達'
# "Don't treat unattributed constexpr functions as __host__ __device__."
HE736239C2F73: '不要將未標記的constexpr函數視為__host__ __device__'
# "Don't try to avoid heapifying local blocks"
HA0E5E1480194: '不要試圖避免將局部區塊堆積化'
# "Don't use GOT indirection to reference external data symbols"
H446ED22B127C: '不要使用GOT間接引用外部資料符號'
# "Don't use LLVM/Offload as portable offloading runtime."
H993CF148793E: '不要將LLVM/Offload用作可攜式卸載執行階段。'
# "Don't use __cxa_atexit for calling destructors"
HB9FAC41CF208: '不要使用__cxa_atexit來調用解構函數'
# "Don't use a const qualified type for string literals in C and ObjC"
H45BD6EFBF0D7: '不要在C和ObjC中為字串字面量使用const限定類型'
# "Don't use a uniquing type map for debug info"
HD459DA46855B: '不要為除錯資訊使用唯一化類型映射'
# "Don't use approximate transcendental functions"
H0ED50C803EDB: '不要使用近似超越函數'
# "Don't use atexit or __cxa_atexit to register global destructors"
HC46180126A88: '不要使用atexit或__cxa_atexit來註冊全域解構函數'
# "Don't use constructor homing for debug info"
HD49F3B3625FB: '不要為除錯資訊使用建構器定位'
# "Don't use ignorelist file for sanitizers"
HFDCDF48F9121: '不要為檢查器使用忽略清單檔案'
# "Don't use new kernel launching API for HIP"
HFB5E65669ABA: '不要為HIP使用新的核心啟動API'
# "Don't use the new driver for OpenMP offloading."
H301CA6785230: '不要為OpenMP卸載使用新驅動程式'
# "Don't use unique names for text and data sections"
H8E78A20B661E: '不要為文字和資料區段使用唯一名稱'
# "Don't verify input files for the modules if the module has been successfully validated or loaded during this build session"
HE1A69C7730A8: '如果模組在本次建置階段已成功驗證或載入，則不要驗證模組的輸入檔'
# "Don't verify that MIR is fully legal between GlobalISel passes"
H2547A49B1E5F: '不要驗證GlobalISel passes之間的MIR是否完全合法'
# "Don't work around Cortex-A57 Erratum 1742098 (ARM only)"
H3E4B9BDEA672: '不要應對Cortex-A57錯誤修正 1742098（僅限ARM）'
# "Don't work around Cortex-A72 Erratum 1655431 (ARM only)"
HBBA28409C8FE: '不要應對Cortex-A72錯誤修正 1655431（僅限ARM）'
# "Don't work around VLLDM erratum CVE-2021-35465 (ARM only)"
H2D48982037C5: '不要應對VLLDM錯誤修正CVE-2021-35465（僅限ARM）'
# "Don't workaround Cortex-A53 erratum 835769 (AArch64 only)"
H674F1B2934BD: '不要應對Cortex-A53錯誤修正 835769（僅限AArch64）'
# "Don't write fields with default values"
HDC62F7F06017: '不要寫入具有預設值的欄位'
# "Dot-separated value representing the Microsoft compiler version number to report in _MSC_VER (0 = don't define it (default))"
H3158063BCCC4: '以點分隔的值，表示要報告在 _MSC_VER 中的 Microsoft 編譯器版本號（0 = 不定義（預設值））'
# 'Dr. Watson Assassin.\n'
H2FDABEFA9036: '沃森博士刺客。\n'
# 'Drop all type test sequences'
HA428B8584F95: '移除所有類型測試序列'
# 'Drop the profile symbol list when merging AutoFDO profiles (only meaningful for -sample)'
HF313BEF9935A: '在合併 AutoFDO 剖析資料時移除剖析符號列表（僅對 -sample 選項有意義）'
# 'Drop type test assume sequences'
HB2138C89F2F0: '移除類型測試假設序列'
# 'DummyCGSCCPass'
H4B94DA391D3F: '虛設CGSCCPass'
# 'Dump AMDGPU HSA Metadata'
HAD21DA71DA94: '輸出AMDGPU HSA元資料'
# 'Dump C11 CodeView debug chunks'
HE18236D9F17D: '輸出C11 CodeView除錯區塊'
# 'Dump C13 CodeView debug chunk subsection'
H0E6AB0F1E2CC: '輸出C13 CodeView除錯區塊子區段'
# 'Dump CallingContextGraph to stdout after each stage.'
HE2FF79E701CA: '在每個階段後將CallingContextGraph輸出到標準輸出。'
# 'Dump IR after transformation happens'
H27451FBBE078: '在轉換後輸出IR'
# 'Dump IR from modules to stderr on shutdown'
H16357A60101D: '在關閉時將模組中的IR輸出到標準錯誤'
# 'Dump IR to reproduce successful transformations.'
H30BFC03DFD55: '輸出IR以重現成功的轉換'
# 'Dump JITted-compiled object to file <input file>.o'
HCEEB046B9401: '將JIT編譯的物件輸出到檔案 <input file>.o'
# 'Dump JITted-compiled object to file specified with -object-filename (<input file>.o by default).'
HF39EA47FD712: '將JIT編譯的物件輸出到由 -object-filename 指定的檔案（預設為 <input file>.o）。'
# 'Dump MIR with SPIR-V dependencies info'
H3C877ECA1BED: '輸出包含SPIR-V依賴資訊的MIR'
# 'Dump __jit_debug_descriptor contents to stdout'
HEDC251CD7F96: '將__jit_debug_descriptor的內容輸出到標準輸出'
# 'Dump __jit_debug_descriptor in-memory debug objects as tool output'
HEFEA598ED348: '將__jit_debug_descriptor的記憶體內除錯物件輸出為工具輸出'
# 'Dump a detailed breakdown of IPI types usage/size'
HE1625844BBC6: '輸出IPI類型使用量/大小的詳細分解'
# 'Dump a detailed breakdown of S_UDT record usage / stats'
HFAECE5B8125B: '輸出S_UDT紀錄使用量/統計的詳細分解'
# 'Dump a detailed breakdown of symbol usage/size for each module'
HC9A6B5A07738: '列印每個模組的符號使用量/大小的詳細分解'
# 'Dump a detailed breakdown of type usage/size'
H55DC9D5447F4: '列印類型使用量/大小的詳細分解'
# "Dump all declarations in old header (JSON format) to stdout. If the option is specified, other command options will be ignored. An empty JSON will be returned if old header isn't specified."
H716B07B285CE: '列印舊的標頭中所有宣告（JSON格式）到標準輸出。若指定此選項，其他命令選項將被忽略。若未指定舊標頭，則會返回空的JSON。'
# 'Dump all records as machine-readable JSON'
HC8D3646E5507: '將所有記錄以機器可讀的JSON格式列印'
# 'Dump all substituted intrs'
H17F291CCDE2E: '列印所有取代的內建函數'
# 'Dump array types'
H49086B41135B: '列印陣列類型'
# 'Dump binary data from specified range of blocks.'
H84E1DDB15414: '列印指定區塊範圍的二進位資料'
# 'Dump binary data from specified range of bytes'
H8032C8C6B89F: '列印指定位元組範圍的二進位資料'
# 'Dump binary data from specified streams.  Format is SN[:Start][@Size]'
H025773DC5489: '列印指定資料流的二進位資料。格式為SN[:Start][@Size]'
# 'Dump bytes of PDB Name Map'
HEA0DA34178F3: '列印PDB名稱映射的位元組'
# 'Dump code-completion information at a location'
HAD967F4C2789: '在指定位置列印程式碼補充資訊'
# 'Dump compiland information'
HC4F8C0431CDD: '列印編譯單元資訊'
# 'Dump configuration options to stdout and exit.\nCan be used with -style option.'
HC24D568EFEC0: '將配置選項列印到標準輸出並退出。\n可與-style選項一起使用。'
# 'Dump declarations that are deserialized from PCH, for testing'
HE581DC659FD7: '列印從PCH反序列化而來的宣告（供測試使用）'
# 'Dump dropped debug variables stats'
H85E673327785: '列印被遺棄的調適變數統計資訊'
# 'Dump dropped debug variables stats for MIR passes'
HEA66796E7964: '為MIR pass列印被遺棄的調適變數統計資訊'
# "Dump each stream's block map (implies -stream-metadata)"
H5165BD588D74: '列印每個資料流的區塊映射（隱含-stream-metadata選項）'
# 'Dump edit and continue map'
HBCE09E7C4018: '列印編輯與繼續映射'
# 'Dump enum types'
HB104D7EA4F5F: '列印列舉類型'
# 'Dump everything we know how to dump.'
H37AD9BC8A78E: '列印所有我們能列印的資訊。'
# 'Dump exploded graph to the specified file'
H77D296A430F7: '將爆炸圖形傾印至指定的檔案'
# 'Dump external symbols'
HA768DB613A32: '傾印外部符號'
# 'Dump free page map'
HE90F56D21A38: '傾印自由頁面映射表'
# 'Dump function names to stdout.'
H13D3781376F8: '將函數名稱輸出至標準輸出。'
# 'Dump function signature information'
H1625F7D7A62D: '傾印函數簽名資訊'
# 'Dump global symbols'
H4E004D714E1B: '傾印全域符號'
# 'Dump graphs for each function/round in the compilation unit.'
H2EA9EDCA4026: '為編譯單元中的每個函數/輪次傾印圖形。'
# 'Dump image section headers'
H01B54D632FED: '傾印映像區段標頭'
# 'Dump input on failure'
H6F31E933D50C: '在失敗時傾印輸入'
# "Dump input to stderr, adding annotations representing\ncurrently enabled diagnostics.  When there are multiple\noccurrences of this option, the <value> that appears earliest\nin the list below has precedence.  The default is 'fail'.\n"
H768FAF2A8E36: '將輸入傾印至標準錯誤輸出，並附加代表目前啟用診斷的註解。當此選項出現多次時，清單中最先出現的 <value> 優先。預設值為「fail」。\n'
# 'Dump list of actions to perform'
HD3BA4698DD33: '傾印要執行的動作清單'
# 'Dump low level bitcode trace'
H1754A9E4C373: '傾印低階位元碼追蹤'
# 'Dump module after Polly transformations into a file suffixed with "-after"'
HDF35672E1E22: '將 Polly 轉換後的模組傾印至附加「-after」後綴的檔案'
# 'Dump module after Polly transformations to the given file'
HFE02E969722D: '將 Polly 轉換後的模組傾印至指定的檔案'
# 'Dump module before Polly transformations into a file suffixed with "-before"'
HF0A6CA5B945A: '將 Polly 轉換前的模組傾印至附加「-before」後綴的檔案'
# 'Dump module before Polly transformations to the given file'
H3D5A0282D19D: '將 Polly 轉換前的模組傾印至指定的檔案'
# 'Dump module info'
H35667204516C: '傾印模組資訊'
# 'Dump modules to stdout.'
HAFE4570AAD96: '將模組輸出至標準輸出。'
# 'Dump modules to the current working directory. (WARNING: will overwrite existing files).'
H5DEA08F3B824: '將模組傾印至目前工作目錄。 (警告：將覆寫現有檔案)'
# 'Dump new file contents in YAML, if specified.'
H0F661C11A2F3: '若指定，則以 YAML 格式傾印新檔案內容'
# 'Dump provenance'
H0B7FC19C4E7C: '傾印資料來源'
# 'Dump record layout information'
H1A9181305386: '傾印紀錄布局資訊'
# 'Dump record layout information for all complete types'
HFF3CB6AA485A: '傾印所有完整類型的紀錄布局資訊'
# 'Dump record layout information in a simple form used for testing'
HEC89F4D9A445: '以用於測試的簡化形式傾印紀錄布局資訊'
# 'Dump record layout information with canonical field types'
H371339BFDE60: '傾印帶有標準化欄位類型的紀錄布局資訊'
# 'Dump register information to help debugging'
HA4313634E698: '傾印用於除錯的寄存器資訊'
# 'Dump resource usage at schedule boundary.'
H8B22EBFC198A: '傾印排程邊界的資源使用總和。'
# 'Dump results in JSON format to stdout.'
H76D763966BEB: '以JSON格式輸出結果資訊。'
# 'Dump section contributions'
HDC1D19FADC7C: '傾印區段貢獻資訊'
# 'Dump section map'
HBED8393F6931: '傾印區段地圖'
# 'Dump source file info'
H9D1B330F5346: '傾印來源檔案資訊'
# 'Dump sum of timings for all stacks. By default separates stacks per-thread.'
H39EFC1DB7865: '傾印所有堆疊的時間總和。預設會根據執行緒分開統計。'
# 'Dump symbol record substream'
H254B4E85A075: '傾印符號紀錄子串流'
# 'Dump symbols after the semantic analysis'
HDA7B67B72F4C: '語法分析後傾印符號'
# 'Dump symbols and the parse tree after the semantic checks'
H8BBAF59A717D: '語法檢查後傾印符號及解析樹'
# 'Dump symbols and their source code locations'
H8E456C399A58: '傾印符號及其原始程式碼位置'
# 'Dump templight information to stdout'
H1AD586FAA55A: '將 Templight 資訊傾印至標準輸出'
# 'Dump the DBI Stream Headers (Stream 2)'
H129FA94CBB86: '傾印 DBI 串流標頭（串流 2）'
# 'Dump the FIR created by lowering and exit'
H91B777999917: '傾印由降階產生的 FIR 結構並退出'
# 'Dump the HLFIR created by lowering and exit'
H2BFC1CB7ACAA: '傾印由降階產生的 HLFIR 結構並退出'
# 'Dump the IPI Stream (Stream 5)'
H0EC59D4B528C: '傾印IPI資料流（資料流 5）'
# 'Dump the PDB Stream (Stream 1)'
H4577B257A885: '傾印PDB資料流（資料流 1）'
# 'Dump the PDB String Table'
H46D5A974F1C3: '傾印PDB字串表'
# 'Dump the Publics Stream'
H9A8FF0F8500C: '傾印Publics資料流'
# "Dump the SCCs in the ThinLTO index's callgraph"
H05F63DC7879B: '傾印ThinLTO索引調用圖中的強連通組成分'
# 'Dump the TPI Stream (Stream 3)'
H838873B9AC8D: '傾印TPI資料流（資料流 3）'
# 'Dump the compiler configuration options'
H3D1A24CE8D0E: '傾印編譯器配置選項'
# 'Dump the cooked character stream in -E mode'
H7DB9E0B6C82A: '在-E模式下傾印處理過的字元流'
# 'Dump the coverage mapping records, for testing'
H95CDC790B673: '傾印覆蓋映射記錄（供測試使用）'
# 'Dump the dependency graph to dot files.'
HF4BCFC89AF2D: '將依存關係圖輸出為dot檔案。'
# 'Dump the gcov file to stderr'
H58322A4E2763: '將gcov檔案傾印到標準錯誤輸出'
# 'Dump the id record with the given type index'
H759F0D055070: '根據給定的類型索引傾印ID記錄'
# 'Dump the layouts of all vtables that will be emitted in a translation unit'
H5286BCB58A1F: '傾印翻譯單元中將要產生的所有虛函數表佈局'
# 'Dump the list of input files and their weights, then exit'
HFD20CED5CA14: '傾印輸入檔案列表及其權重，然後退出'
# "Dump the number of streams and each stream's size"
HD36F7FCDEEBC: '傾印資料流數量及各資料流的大小'
# 'Dump the parse tree'
H64405164E18C: '傾印解析樹'
# 'Dump the parse tree (skips the semantic checks)'
H65A5DE3C84CD: '傾印解析樹（跳過語法檢查）'
# 'Dump the pre-FIR tree'
H313B5A95699E: '傾印FIR前的樹狀結構'
# 'Dump the pre-fir parse tree'
HA7DC87D10265: '傾印pre-fir解析樹'
# "Dump the source files that contribute to each module's."
H804482274E2A: '傾印對每個模組有貢獻的原始程式檔'
# 'Dump the type record with the given type index'
H8A9E9857BE0A: '以給定的類型索引輸出類型記錄'
# 'Dump the unsymbolized profile to the output file. It will show unwinder output for CS profile generation.'
H9822074C616B: '將未符號化解析的剖析輸出至輸出檔案。這將顯示用於CS剖析生成的unwinder輸出。'
# 'Dump type server map'
HA60CB6E2EBD6: '輸出類型伺服器映射'
# 'Dump typedefs'
HB4499E4CA24E: '輸出typedefs'
# 'Dump udt types'
H4EEAE7678976: '輸出UDT類型'
# 'Dump virtual table shapes'
H94754C1D9BD7: '輸出虛擬表形狀'
# 'Duplicate the snippet'
HB2CC4A27F6FB: '複製程式碼片段'
# 'During rematerialization for a copy, if the def instruction has many other copy uses to be rematerialized, delay the multiple separate live interval update work and do them all at once after all those rematerialization are done. It will save a lot of repeated work. '
H2B948F8A8B8A: '在複製的重新生成期間，若定義指令有大量其他複製使用需要重新生成，則延遲多個分開的存活區間更新工作，並在所有重新生成完成後一次執行。這將大幅減少重複工作。'
# 'Dwarf version'
H5862F01F0C5E: 'DWARF版本'
# 'Dynamic libraries to load before linking'
H926C9AA42A23: '連結前要載入的動態函式庫'
# 'Dynamic scheduling'
H762ACA0C3351: '動態調度'
# 'Dynamically link the sanitizer runtime'
HE0360B0DDF0D: '動態連結sanitizer執行階段程式庫'
# 'EABI GNU'
H7E2A3B789B36: 'EABI GNU版本'
# 'EABI version 4'
H3C615C59EEA1: 'EABI版本 4'
# 'EABI version 5'
HDD2C36FB7B3F: 'EABI版本 5'
# 'Eagerly compute live intervals for all physreg units.'
H8BDCB87E4D2E: '積極計算所有實體寄存器單元的存活區間。'
# 'Eagerly invalidate more analyses in default pipelines'
HC29BAEFB7500: '在預設管線中積極無效更多分析'
# 'Early CSE'
H7995F9E82B8F: '早期CSE'
# 'Early CSE w/ MemorySSA'
HA097BFA29921: '搭配MemorySSA的早期CSE'
# 'Early If Converter'
HEACD98DB3CB0: '早期If轉換器'
# 'Early If Predicator'
H3899A5E56B26: '早期If預判器'
# 'Early Machine Loop Invariant Code Motion'
H93B90001D05A: '早期機器循環不變式代碼移動'
# 'Early Tail Duplication'
H9F05343E7731: '早期尾部複製'
# 'Early expansion of MUX'
HC9BB5C4937A3: '早期MUX展開'
# 'Element attributes.'
HA3DEA8BD288F: '元素屬性。'
# 'Element debug location.'
HDDAB4BDAA546: '元素除錯位置。'
# 'Element declaration and definition references.'
HF82FBA3D05B2: '元素宣告與定義引用。'
# 'Element referenced across Compile Units.'
H6E34E57CF7C6: '元素在編譯單元間被引用。'
# 'Element referenced only in the Compile Unit.'
HB0C2FAF86940: '元素僅在編譯單元內被引用。'
# 'Element to print.'
H1150FC4D6BB7: '要列印的元素。'
# 'Elements to compare.'
H7D8A91E768C7: '要比較的元素。'
# 'Elide ElementsAttrs with "..." that have more elements than the given upper limit'
HE475543A5C00: '省略具有「...」且元素數量超過指定上限的ElementsAttrs'
# 'Elide printing value of resources if string is too long in chars.'
H89DF7B30813D: '若字元字串過長，則省略資源值的列印。'
# 'Elide resources when generating bytecode'
HE18501EFA3FF: '產生位元組碼時省略資源'
# 'Eliminate PHI nodes for register allocation'
H951E7DE45FDF: '消除寄存器分配的PHI節點'
# 'Eliminate scalar loop carried dependences'
H57EB486234E9: '消除標量循環攜帶的依賴關係'
# 'Embed DXIL'
H07B28C451A5A: '嵌入DXIL'
# 'Embed LLVM IR bitcode as data'
H595F481498B5: '將LLVM IR位元碼嵌入為資料'
# 'Embed LLVM bitcode'
H4AADB26DC12B: '嵌入LLVM位元碼'
# 'Embed LLVM bitcode in object files produced by LTO'
H16F1861B6BE7: '在LTO產生的物件檔案中嵌入LLVM位元碼'
# 'Embed Offloading device-side binary into host object file as a section.'
H5475B2E44660: '將卸載的裝置端二進位檔嵌入主機物件檔作為一個區段。'
# 'Embed PDB in shader container (ignored)'
HEF26692F47BE: '將PDB嵌入著色器容器（忽略）'
# 'Embed after all optimization passes'
HD4E0BFB5C58B: '在所有最佳化pass之後嵌入'
# 'Embed function arity information into the KCFI patchable function prefix'
H9B1AB0019717: '將函數形參數個數資訊嵌入KCFI可修補函數前綴'
# 'Embed placeholder LLVM IR data as a marker'
HCFCB6093DA4B: '將LLVM IR資料的占位符嵌入為標記'
# 'Embed post merge, but before optimizations'
HEA0EFEB4A060: '在合併後但最佳化前嵌入'
# 'Embed source text in DWARF debug sections'
HC2C8736B7263: '將原始碼文字嵌入DWARF除錯區段'
# 'Embed the contents of all files read by this compilation into the produced module file.'
HECD9878DE365: '將此編譯所讀取的所有檔案內容嵌入產生的模組檔中。'
# 'Embed the contents of the specified file into the module file being compiled.'
H5C7A5481DBF2: '將指定檔案的內容嵌入正在編譯的模組檔中。'
# 'Emit  debug info for defined but unused types'
H4259F2A07B2E: '為已定義但未使用的類型產生除錯資訊'
# 'Emit (experimental) loops (with sparse.iterate).'
H6558C2381246: '發射（實驗性）迴圈（使用sparse.iterate）。'
# 'Emit .secure_log_unique directives to this filename.'
HA73462D861E9: '將.secure_log_unique指示輸出至此檔案名稱。'
# 'Emit .su file containing information on function stack sizes'
H17B887378AAE: '產生包含函數堆疊大小資訊的.su檔'
# 'Emit AT&T-style assembly'
HED9E24C24759: '產生AT&T風格的組合語言'
# 'Emit Apple-style NEON assembly'
H45694CDA7EC7: '產生Apple風格的NEON組合語言'
# 'Emit Clang AST files for source inputs'
H2EA489E49444: '產生Clang AST檔供原始碼輸入使用'
# 'Emit CodeGen Data into custom sections'
H363A7576BA25: '將程式碼生成資料輸出至自訂區段'
# 'Emit GNU Assembly Syntax on z/OS.'
H56A1FC66D6EC: '在z/OS上產生GNU組合語言語法。'
# 'Emit GOTPCRELX/REX_GOTPCRELX/CODE_4_GOTPCRELX instead of GOTPCREL on x86-64 ELF'
HA621D70D3E80: '在x86-64 ELF上發射GOTPCRELX/REX_GOTPCRELX/CODE_4_GOTPCRELX而非GOTPCREL'
# 'Emit IR to support LTO unit features (CFI, whole program vtable opt)'
H1C0C26CCDFE7: '發射支援LTO单元功能的IR（CFI、全域程式vtable最佳化）'
# 'Emit Import Call sections on supported targets that can be used by the Windows kernel to enable import call optimization'
HD73224065892: '在受支持的目標上發出導入調用區段，以便Windows核心啟用導入調用優化'
# 'Emit Intel-style assembly'
HD0D98D71E373: '發出Intel風格的組裝語言'
# 'Emit JSON-formatted debug info quality metrics.'
HE95341B061E7: '發出以JSON格式表示的除錯資訊品質指標'
# 'Emit LLVM textual assembly'
H5687C7B339C1: '發出LLVM文字組裝語言'
# 'Emit OpenMP code only for SIMD-based constructs.'
H566FF0EF84C2: '僅為基於SIMD的結構發出OpenMP程式碼'
# 'Emit PCs for atomic operations used by binary analysis sanitizers'
H1D074F0F258F: '發出由二進制分析驗證程序使用的原子操作的程式計數器'
# 'Emit PCs for atomic operations.'
H62316BF0E45F: '發出原子操作的程式計數器'
# 'Emit PCs for code covered with binary analysis sanitizers'
H3D28246BA2B9: '發出被二進制分析驗證程序覆蓋的程式碼的程式計數器'
# 'Emit PCs for covered functions.'
H831FD59B3528: '發出被覆蓋的函數的程式計數器'
# 'Emit PCs for start of functions that are subject for use-after-return checking'
H797088C91ACC: '發出受use-after-return檢查影響的函數起始處的程式計數器'
# 'Emit PCs for start of functions that are subject for use-after-return checking.'
HEC66708B7812: '發出受use-after-return檢查影響的函數起始處的程式計數器。'
# 'Emit RTTI data (default)'
H28F26C2AAAEF: '發出RTTI資料（預設）'
# 'Emit R_RISCV_SET_ULEB128/E_RISCV_SUB_ULEB128 if appropriate'
H2DC3F5A68E91: '在適合時發出R_RISCV_SET_ULEB128/E_RISCV_SUB_ULEB128'
# 'Emit SPIR-V NonSemantic.Shader.DebugInfo.100 instructions'
H3620039F4736: '發出SPIR-V NonSemantic.Shader.DebugInfo.100指令'
# 'Emit VPU instructions for VE'
H336AA1A757FD: '為VE發出VPU指令'
# 'Emit Windows Control Flow Guard tables and checks'
H2B3A6CDD77E1: '發出Windows控制流守衛表和檢查'
# 'Emit Windows Control Flow Guard tables only (no checks)'
H12EF1A548A1C: '僅發出Windows控制流守衛表（無檢查）'
# 'Emit Windows EH Continuation Guard tables'
H7CFD101BE344: '發出Windows例外處理繼續守衛表'
# 'Emit `[first]private` variables as clauses on the MLIR ops.'
HDAD278A55FD1: '將[first]private變數作為MLIR操作中的條款發出'
# 'Emit a call to trap function rather than a trap instruction'
H7926ECB4152F: '發出對陷阱函數的呼叫，而非陷阱指令'
# 'Emit a compilation database fragment to the specified directory'
HBAB9D592240A: '將編譯資料庫片段輸出到指定目錄'
# 'Emit a diagnostic when "fast" instruction selection falls back to SelectionDAG.'
H88EB0DEF1034: '當「快速」指令選擇回退到SelectionDAG時發出診斷。'
# 'Emit a fatal error if format parsing fails'
H0EBAF7E7ADAA: '若格式解析失敗則發出致命錯誤'
# "Emit a native object ('.o') file"
HAE97C70DDD39: "輸出本機物件檔（'.o'）"
# 'Emit a section containing jump table addresses and sizes'
H0281F291EFBA: '輸出包含跳轉表位址及大小的區段'
# 'Emit a section containing remark diagnostics metadata. By default, this is enabled for the following formats: yaml-strtab, bitstream.'
H75D67E9CFF88: '輸出包含備註診斷元資料的區段。預設情況下，此選項啟用於以下格式：yaml-strtab、bitstream。'
# 'Emit a section containing stack size metadata'
H698AD84DCB32: '輸出包含堆疊大小元資料的區段'
# 'Emit a warning if less than N% of records in the input profile are matched to the IR.'
HB962CC606D2C: '若輸入剖析檔中少於N%的紀錄與IR對應時發出警告。'
# 'Emit a warning if less than N% of samples in the input profile are matched to the IR.'
HED39F9DCFD05: '若輸入剖析檔中少於N%的樣本與IR對應時發出警告。'
# 'Emit all declarations, even if unused'
HF5BC1521C99D: '輸出所有宣告，即使未使用'
# 'Emit an address-significance table'
H378504D13B46: '輸出位址重要性表'
# "Emit an assembly ('.s') file"
H34226183B99D: "輸出組譯檔（'.s'）"
# 'Emit an error if a C++ static local initializer would need a guard variable'
HA81110278BFB: '若C++靜態局部初始化器需要守護變數時發出錯誤'
# 'Emit analyzer results as errors rather than warnings'
H3B5E1411AD19: '將分析器結果作為錯誤而非警告輸出'
# 'Emit basic blocks into separate sections'
H67EB14D9E7DC: '將基本區塊分為不同區段'
# 'Emit bytecode when generating output'
H6A294EDCD1D8: '產生中間程式碼（bytecode）'
# 'Emit call site debug information, if debug information is enabled.'
H4DFAA1C6FE5A: '若啟用調試資訊，則輸出呼叫位置調試資訊。'
# 'Emit code that can be JIT compiled for OpenMP offloading. Implies -foffload-lto=full'
HCB19BAB5F044: '產生可由OpenMP卸載即時（JIT）編譯的程式碼。隱含-foffload-lto=full'
# 'Emit code that prints the runtime check result dynamically.'
H83A96897A283: '產生動態輸出執行階段檢查結果的程式碼。'
# 'Emit codegen data into the object file. LLD for MachO (currently) merges them into default.cgdata.'
HE5A9DF802056: '將程式碼生成資料輸入物件檔。MachO的LLD（目前）將它們合併到預設的cgdata中。'
# 'Emit codegen data into the object file. LLD for MachO (currently) merges them into the specified <path>.'
HB514733CE70A: '將程式碼生成資料發射至物件檔中。LLD for MachO（目前）將其合併至指定的<路徑>中。'
# 'Emit colored output (default=autodetect)'
H1C348B34C157: '輸出彩色輸出（預設=自動偵測）'
# 'Emit compiler path and command line into CodeView debug information'
H252107FF70F1: '將編譯器路徑和命令列輸入至CodeView除錯資訊中'
# 'Emit complete descriptions of template parameters in forward declarations'
H73932760DABC: '在前向宣告中發射模板參數的完整描述'
# 'Emit data into separate sections'
HF75AE625B842: '將資料發射到獨立的區段'
# 'Emit debug info that places array-bounds instrumentation in an inline function called __ubsan_check_array_bounds.'
HCA08BC9E900F: '發射除錯資訊，將陣列邊界插樁置於名為__ubsan_check_array_bounds的內聯函數中。'
# 'Emit debug line info directives only'
HE3308044AB2D: '僅發射除錯行資訊指令'
# 'Emit debug line number tables only'
H8174B5298FE7: '僅發射除錯行號表'
# 'Emit emitc.file ops with matching id'
H236B850BC868: '發射具有匹配ID的emitc.file操作'
# 'Emit emptylines and comment lines as skipped regions (only disable it on test)'
H7D7A380200FE: '將空行和註解行發射為被跳過的區域（僅在測試時禁用）'
# 'Emit error if a specific declaration is deserialized from PCH, for testing'
H2CD80B3DD8B2: '若特定宣告來自PCH的反序列化，則發射錯誤（用於測試）'
# 'Emit expensive warnings during LLVM IR import (discouraged: testing only!)'
H04DDF8C7828C: '在導入LLVM IR期間發射昂貴的警告（不建議：僅用於測試！）'
# 'Emit extra debug info to make sample profile more accurate'
H367D707A9507: '發射額外的除錯資訊以提高樣本剖析的準確性'
# 'Emit final result as bitcode instead of text IR'
H7F4BFD221CF3: '以位元碼而非文本IR格式發射最終結果'
# 'Emit full debug info for all types used by the program'
H30220D4F255D: '為程式所使用的所有類型發射完整的除錯資訊'
# 'Emit functional code (with scf.for/while).'
HB278CDF9ABA9: '發射函式型代碼（使用scf.for/while）。'
# 'Emit functional code or interfaces (to debug) for sparse loops'
HBDA72C0CBE39: '發射函式型或介面（用於除錯）以處理稀疏迴圈'
# 'Emit functions into separate sections'
H09C9B71236EA: '將函數發射到獨立的區段'
# 'Emit generic NEON assembly'
H39274034DB2D: '發射通用NEON組裝語言'
# 'Emit hermetic module files (no nested USE association)'
HD5D99550F319: '發射隔離的模組檔案（無嵌套USE關聯）'
# 'Emit hexagon jump tables in function section'
HEE6DA2F43CCC: '在函數區段內生成hexagon jump tables'
# 'Emit hexagon lookup tables in function section'
H100801A51219: '在函數區段內生成hexagon 查找表'
# 'Emit homogeneous prologue and epilogue for the size optimization (default = off)'
H835061FF9BD7: '為大小優化發射同質的前綴和後綴（預設為關閉）'
# 'Emit imports files for distributed backends.'
H99F865E8CA6D: '生成用於分散後端的進口檔'
# 'Emit information about accumulator register spills and copies'
H99CD32F2A0A4: '生成累加器寄存器溢出和複製的資訊'
# 'Emit internal instruction representation to assembly file'
H61E38F521500: '將內部指令表示寫入組裝檔'
# 'Emit kernels to call ctor/dtor globals.'
HF3F0CC8F9DC0: '生成用於調用建構函數/解構函數全域變數的核心代碼'
# 'Emit limited coverage mapping information (experimental)'
H42E2BE163D31: '生成有限的覆蓋映射資訊（實驗性）'
# 'Emit log of dataflow analysis. With no arg, writes textual log to stderr. With an arg, writes HTML logs under the specified directory (one per analyzed function).'
HFAAFE42FF67A: '生成資料流分析的日誌。若無參數，將文字日誌寫入標準錯誤。若有參數，則在指定目錄下寫入HTML日誌（每個分析函數一個）'
# 'Emit macro debug information'
H5AADCC833ADB: '生成巨集除錯資訊'
# 'Emit metadata containing compiler name and version'
H02D252B322FC: '生成包含編譯器名稱和版本的元資料'
# 'Emit module hash'
H8D92949B5594: '生成模組雜湊值'
# 'Emit module summary index'
H81A5D22F1814: '生成模組摘要索引'
# 'Emit native object files'
HD1D98EAD4C67: '生成本機物件檔'
# 'Emit non-functional but easy-to-read interfaces to debug.'
HFB7CBF2DAD9A: '生成無法運作但易於閱讀的介面以進行除錯'
# 'Emit nothing, for performance testing'
H59E0020EF2FE: '不生成任何輸出，用於效能測試'
# 'Emit numeric info in dump even if symbolic info is available'
H44DA13315AA2: '即使有符號資訊，仍於轉存中顯示數值資訊'
# 'Emit output in the selected format if supported'
HDFDB7BBE51F4: '若支援，則以所選格式輸出'
# 'Emit pretty printed symbol graphs'
H9D5251957AE9: '生成格式化的符號圖表'
# 'Emit pristine LLVM IR from the frontend by not running any LLVM passes at all.Same as -S + -emit-llvm + -disable-llvm-passes.'
H4945F63ADF72: '通過完全不執行任何LLVM Pass，從前端生成原始LLVM IR。等同於 -S + -emit-llvm + -disable-llvm-passes'
# 'Emit pseudo probes for sample profiling'
HEE6673E22F38: '為樣本分析發射虛擬探針'
# 'Emit pseudo probes to enable PGO profile generation.'
H68FBB431D14A: '發射虛擬探針以啟用配置文件引導型優化。'
# 'Emit reproducer on (option: off, crash (default), error, always)'
HA45B571A7690: '在以下情況下發射重現腳本（選項：關閉、崩潰（預設）、錯誤、始終）'
# 'Emit section containing metadata on function stack sizes'
H55BB0296572C: '發射XCOFF回溯表區段'
# 'Emit special compound instrumentation for reads-before-writes'
H7C94AB6DD4CB: '發射用於啟用配置文件引導型優化的特殊調試資訊。'
# 'Emit special debug info to enable PGO profile generation.'
H92226FB5F865: '發射基本區塊地址地圖區段'
# 'Emit special instrumentation for accesses to volatiles'
H807EB1BCE795: '發射用於易失性（volatile）存取的特殊插樁'
# 'Emit the GNU .debug_macro format with DWARF <5'
H05986F777FFF: '在DWARF <5中以GNU .debug_macro格式發射類型記錄哈希'
# 'Emit the XCOFF traceback table'
H2AD67289821E: '發射XCOFF回溯表區段'
# 'Emit the basic block address map section'
HE67CB0846DD5: '發射基本區塊地址地圖區段'
# 'Emit the basic block address map section.'
HD66B24BE91BF: '發射基本區塊地址地圖區段。'
# 'Emit the specified combiners'
HD6132B919401: '發射指定的combiners'
# 'Emit type record hashes in a .debug$H section'
HE5D98DDE9AE9: '在.debug$H區段中發射類型記錄哈希'
# "Emit verbose output about the analyzer's progress"
HF03ADA31D285: '發射分析器（analyzer）進度的詳細輸出'
# 'Emit xray_fn_idx section'
HCE1B25AEB13C: '發射xray_fn_idx區段'
# 'Emits more virtual tables to improve devirtualization'
HEF76217E9284: '發射更多虛表（virtual tables）以改善虛函數解析'
# 'Emulate weak link against library X. Must resolve to a TextAPI file, and all symbols in the interface will resolve to null.'
H1586C40C45A2: '模擬與庫X的弱連結。X必須指向TextAPI文件，且介面中的所有符號將解析為空。'
# 'Emulate weak link against library X. X must point to a TextAPI file, and all symbols in the interface will resolve to null'
HDE0D8058522D: '模擬與庫X的弱連結。X必須指向TextAPI文件，且介面中的所有符號將解析為空'
# 'Enable -Wall'
HFE182F701ACC: '啟用 -Wall'
# 'Enable -Wall and -Wextra'
HCCDF3CF2B538: '啟用 -Wall 和 -Wextra'
# 'Enable -Weverything'
H85639A20AE92: '啟用 -Weverything'
# 'Enable -Wsystem-headers'
HCF6CBF83669C: '啟用 -Wsystem-headers'
# 'Enable -Wsystem-headers when building <module>'
H7BD118FCCA2F: '建立 <module> 時啟用 -Wsystem-headers'
# 'Enable -time-passes memory tracking (this may be slow)'
HCD77711AC848: '啟用 -time-passes 記憶體追蹤（這可能會變慢）'
# 'Enable .XOR. as a synonym of .NEQV.'
H26B24A90CE2E: '將 .XOR. 作為 .NEQV. 的同義詞'
# 'Enable / disable ARM interworking (for debugging only)'
H0E7C6271B7D5: '啟用 / 禁用 ARM 相互运作（僅供除錯使用）'
# 'Enable / disable SVE scalable vectors in Global ISel'
H2EC78B18E661: '在 Global ISel 中啟用 / 禁用可擴展向量（SVE）'
# 'Enable / disable promotion of unnamed_addr constants into constant pools'
HFAE28EE53BD3: '啟用 / 禁用將無名址常量提升至常量池'
# 'Enable 16-bit types and disable min precision types.Available in HLSL 2018 and shader model 6.2.'
HAAC77E9561C2: '啟用 16 位元類型並禁用最小精度類型。適用於HLSL 2018 和著色器模型 6.2。'
# 'Enable <feature> in module map requires declarations'
H5C8DA92AFFD8: '在 module map 的 requires 宣告中啟用 <feature>'
# 'Enable AArch64 SME memory operations to lower to librt functions'
H2DE7C9221C4E: '將 AArch64 SME 記憶體運算降低為 librt 函數'
# 'Enable AArch64 logical imm instruction optimization'
H3E7D3BE3C68D: '啟用 AArch64 邏輯立即數指令最佳化'
# 'Enable AMDGPU Alias Analysis'
H6232FED85C51: '啟用 AMDGPU 別名分析'
# 'Enable AMDGPU function call support'
HA046043EEDCA: '啟用 AMDGPU 函數呼叫支援'
# 'Enable AMDGPUAttributorPass'
H9BDDE4ABB4D1: '啟用 AMDGPUAttributorPass'
# 'Enable ARC-style weak references in Objective-C'
H9B793CE9E824: '在 Objective-C 中啟用 ARC 樣式的弱引用'
# 'Enable ARM 2-addr to 3-addr conv'
HFA9A2110C825: '啟用ARM 2-地址到 3-地址轉換'
# 'Enable ARM load/store optimization pass'
HF1C1057F91DB: '啟用ARM載入/儲存優化pass'
# 'Enable AddressSanitizer'
H10A93E69F908: '啟用AddressSanitizer'
# 'Enable AltiVec vector initializer syntax'
H39CF1AD1DDBB: '啟用AltiVec向量初始化語法'
# 'Enable Apple gcc-compatible #pragma pack handling'
HF6255EFF4697: '啟用與Apple gcc相容的#pragma pack處理'
# 'Enable BFI update verification for CodeGenPrepare.'
HDEF1BBE64E03: '啟用CodeGenPrepare中的BFI更新驗證'
# 'Enable C++ builtin type char8_t'
HB51A1047EAD1: '啟用C++內建類型char8_t'
# 'Enable C++ builtin type wchar_t (default)'
H2E6A98E0A8E9: '啟用C++內建類型wchar_t（預設值）'
# 'Enable C++ exceptions'
HD8120A0570B1: '啟用C++例外處理'
# 'Enable C++14 sized global deallocation functions'
HA9B36C7CDED1: '啟用C++14大小全局解配置函數'
# 'Enable C++17 aligned allocation functions'
H3A997E1CD1C0: '啟用C++17對齊配置函數'
# 'Enable C-SKY asm compressed instruction'
HE6033CE9D615: '啟用C-SKY組合語言壓縮指令'
# 'Enable CABAC instructions'
HCAFDAD7AAC69: '啟用CABAC指令'
# 'Enable CREL relocation format (ELF only)'
H0C82A363E7CF: '啟用CREL重定位格式（僅限ELF）'
# 'Enable CodeView debug information in object files'
H190F12E62C0D: '在物件檔中啟用CodeView除錯資訊'
# 'Enable Control Flow Guard with /guard:cf, or only the table with /guard:cf,nochecks. Enable EH Continuation Guard with /guard:ehcont'
H0DCA490E39F9: '使用/guard:cf啟用控制流保護，或僅使用/guard:cf,nochecks啟用表部分。使用/guard:ehcont啟用例外處理延續保護'
# 'Enable CopyToPhi DAG Mutation'
H795903E75A63: '啟用CopyToPhi DAG突變'
# "Enable DAG combiner's use of IR alias analysis"
HEFB2E9C4316E: '啟用DAG組合器的IR別名分析使用'
# "Enable DAG combiner's use of TBAA"
HC13D2DED69A7: '啟用DAG合併器對TBAA的使用'
# 'Enable DFA jump threading'
HDA1B9DF0576D: '啟用DFA跳轉線程'
# 'Enable DPP combiner'
H1C2845754879: '啟用DPP合併器'
# 'Enable Debug Info Metadata preservation testing in optimizations.'
H261A5A2FD07D: '在優化中啟用調試資訊元資料保存測試'
# 'Enable Debugger hook for debugging MLIR Actions'
H7236F64CF290: '啟用用於除錯MLIR動作的除錯器掛鉤'
# 'Enable EH Asynchronous exceptions'
H2CA5CA1CFDC6: '啟用例外處理異步例外'
# 'Enable FP math optimizations that assume approx func'
HA55AFA6BF75B: '啟用假設近似函數的浮點運算優化'
# 'Enable FP math optimizations that assume no +-Infs'
H3B25285FD614: '啟用假設不存在正負無窮的浮點運算優化'
# 'Enable FP math optimizations that assume no NaNs'
H9640D97F95AD: '啟用假設不存在NaN的浮點運算優化'
# 'Enable FP math optimizations that assume the sign of 0 is insignificant'
HE827F0FDD8E0: '啟用假設零的符號無關緊要的浮點運算優化'
# 'Enable Fast Math processing'
H2F61C44B4052: '啟用快速數學運算處理'
# 'Enable Freestanding (disable builtins / TLI) during LTO'
H4C62FBB216B5: '在LTO期間啟用自由-standing模式（禁用內建函數/TLI）'
# 'Enable GPU Mode managed|unified'
H1342A6457C14: '啟用GPU模式 managed|unified'
# 'Enable Global-ISel Big Endian Lowering'
H51843BE1AC18: '啟用Global-ISel的大端模式轉換'
# 'Enable GlobalISel at or below an opt level (-1 to disable)'
HD97724CE8B7C: '在等級-1（禁用）或更低的優化等級中啟用GlobalISel'
# "Enable GlobalISel's post-legalizer load/store optimization pass"
H6BA2F1588338: '啟用GlobalISel的後法規化load/store優化pass'
# "Enable GlobalISel's pre-legalizer load/store optimization pass"
H7E199DBC971A: '啟用GlobalISel的前法規化load/store優化pass'
# 'Enable HIP Standard Parallelism Offload support'
H1C99F32D38F4: '啟用HIP標準平行化卸載支援'
# 'Enable HIP acceleration for standard parallel algorithms'
H03CDA0DFF566: '為標準並行演算法啟用HIP加速'
# 'Enable HVX IEEE floating point extensions'
HEDB94BF0B878: '啟用HVX IEEE浮點擴充功能'
# 'Enable HVX vector combining'
HDFF35C9FE78C: '啟用HVX向量組合'
# 'Enable Hexagon HVX IEEE floating-point'
HB190E3ACA8B9: '啟用Hexagon HVX IEEE浮點'
# 'Enable Hexagon HVX QFloat instructions'
HD10ED4BFBA4F: '啟用Hexagon HVX QFloat指令'
# 'Enable Hexagon SDNode scheduling'
H421486189A34: '啟用Hexagon SDNode排程'
# 'Enable Hexagon Vector eXtensions'
H849D45B20815: '啟用Hexagon向量擴展'
# 'Enable Hexagon Vector print instr pass'
HF6F3126A4402: '啟用Hexagon向量列印指令pass'
# 'Enable Hexagon constant-extender optimization'
HB232046E41EF: '啟用Hexagon常數擴展優化'
# 'Enable Hexagon copy hoisting'
H52502969FA5F: '啟用Hexagon copy提升'
# 'Enable Hexagon-specific memcpy for volatile destination.'
H37F33A534B6A: '啟用Hexagon特定的memcpy用於volatile目的地'
# 'Enable IBM XL #pragma pack handling'
H56C08FC94B0D: '啟用IBM XL #pragma pack處理'
# 'Enable ICMP_EQ to ICMP_S(L|G)T conversion.'
H50B860EE6750: '啟用ICMP_EQ轉換為ICMP_S(L|G)T'
# 'Enable JumpTableToSwitch pass (default = off)'
H595911A42177: '啟用JumpTableToSwitch pass（預設 = 關閉）'
# 'Enable KernelAddressSanitizer instrumentation'
HDC17AF33380B: '啟用KernelAddressSanitizer插樿'
# 'Enable KernelHWAddressSanitizer instrumentation'
HE6892C669196: '啟用KernelHWAddressSanitizer插樿'
# 'Enable KernelMemorySanitizer instrumentation'
H98BCB50602AD: '啟用KernelMemorySanitizer插樿'
# 'Enable LSR phi elimination'
H6F6B88180DCF: '啟用LSR phi消除'
# "Enable LTO in 'full' mode"
HDE2B72E90D39: "以 'full' 模式啟用LTO"
# "Enable LTO in 'full' mode for offload compilation"
H1AD130930D3D: "為卸載編譯以 'full' 模式啟用LTO"
# 'Enable Loongson Advanced SIMD Extension (LASX).'
H8708BF686447: '啟用Loongson Advanced SIMD Extension (LASX).'
# 'Enable Loongson SIMD Extension (LSX).'
H9319CC082DD4: '啟用Loongson SIMD Extension (LSX).'
# 'Enable MASM-style hex float initializers (3F800000r)'
H44F2E6A19192: '啟用MASM風格的十六進制浮點初始化器（3F800000r）'
# 'Enable MC/DC criteria when generating code coverage'
HDDD25377703C: '當生成代碼覆蓋率時啟用MC/DC準則'
# 'Enable ML policy for inliner. Currently trained for -Oz only'
H4BD737EDDE37: '啟用內聯器的ML策略。目前僅針對-Oz進行訓練'
# 'Enable MSA ASE (MIPS only)'
HF57FBC9A1C49: '啟用MSA ASE（僅MIPS）'
# 'Enable MT ASE (MIPS only)'
H4037C7D0B0DC: '啟用MT ASE（僅MIPS）'
# 'Enable Machine Pipeliner for AArch64'
HC2A6D688CFC7: '為AArch64啟用機器管線器'
# 'Enable Machine Pipeliner for PPC'
H533D989E39D2: '啟用PPC的機器管線'
# 'Enable Machine Pipeliner for RISC-V'
H06DAB50244BB: '為RISC-V啟用機器管線器'
# 'Enable MemProf context disambiguation'
H31287310FC75: '啟用MemProf上下文區分'
# 'Enable MemProf support for summarizing and cloning indirect calls'
H467E2FD95CC9: '啟用MemProf對間接呼叫的摘要與複製支援'
# 'Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size'
H305D879EAD05: '啟用ODR指示符全域變數以避免在部分清理程式中產生錯誤的ODR違規報告，但會導致二進位檔大小增加'
# 'Enable Objective-C Ivar layout bitmap print trace'
H8E7C0A4EC106: '啟用Objective-C Ivar布局位元組印跡追蹤'
# 'Enable Objective-C exceptions'
HC28B4C97C29D: '啟用Objective-C例外'
# 'Enable Objective-C garbage collection'
HC3AA6362E4C5: '啟用Objective-C垃圾收集'
# 'Enable OpenACC'
HFA0D5CED023C: '啟用OpenACC'
# 'Enable OpenMP support'
HBFD2A2659227: '啟用OpenMP支援'
# 'Enable OpenMP support with experimental SIMD support'
H3F6D5F2001FE: '啟用OpenMP支援（含實驗性SIMD支援）'
# 'Enable PC tracing in sanitizer coverage'
H63A67D8CBA77: '在sanitizer覆蓋範圍中啟用程序計數器追蹤'
# 'Enable PC tracing with guard in sanitizer coverage'
HF28D97CE20BD: '在sanitizer覆蓋範圍中啟用帶有保護的程序計數器追蹤'
# 'Enable PGO instrumentation'
H275AC31A4E6B: '啟用PGO插樁'
# 'Enable Passing SSP Canary info in Trackback on AIX'
HF2D40BF85363: '在AIX上啟用在Tracback中傳遞SSP守護值資訊'
# 'Enable PatchPoint Liveness Analysis Pass'
HC23201EA3F30: '啟用PatchPoint存活分析Pass'
# 'Enable PostRA load and store clustering in the machine scheduler'
H7DBDA92CD831: '啟用機器調度器中的PostRA載入和存儲聚類'
# 'Enable Pre-RA optimizations pass'
HBF2BE955A63C: '啟用Pre-RA優化Pass'
# 'Enable RDF-based optimizations'
HB93D1CE5916C: '啟用基於RDF的優化'
# 'Enable SDWA peepholer'
HAA3AA4CDEBA5: '啟用SDWA窥孔優化器'
# 'Enable SVE intrinsic opts'
HC49B4494813B: '啟用SVE內在函數優化'
# 'Enable SVR4-style position-independent code (Mips only)'
H39A5D03E5D80: '啟用SVR4風格的位置獨立代碼（僅Mips）'
# 'Enable SWP at Os.'
HE7BF8843A5BE: '在Os級別啟用SWP'
# 'Enable SYCL C++ extensions'
HB66B108F597C: '啟用SYCL C++擴充功能'
# 'Enable Software Pipelining'
H701BBA1060C2: '啟用軟體管線'
# 'Enable System z vector language extension'
H0ADCFE4F5EB1: '啟用System z向量語言擴充功能'
# 'Enable ThinLTO caching.'
H4E40230CBB89: '啟用ThinLTO快取機制。'
# 'Enable Unroll And Jam Pass'
HC78C6B520033: '啟用Unroll And Jam Pass'
# 'Enable V8+ mode, allowing use of 64-bit V9 instructions in 32-bit code'
H51CF3B974577: '啟用V8+模式，允許在 32 位程式碼中使用 64 位V9指令'
# 'Enable VGPR liverange optimizations for if-else structure'
H7A56B298E40B: '啟用VGPR活範圍優化，針對if-else結構'
# 'Enable VOPD, dual issue of VALU in wave32'
H89877353D212: '啟用VOPD，在wave32中雙發射VALU'
# 'Enable VPlan-native vectorization path with support for outer loop vectorization.'
H5546DBF9A313: '啟用支援外層循環向量化的VPlan本機向量化路徑。'
# 'Enable X86 indirect branch tracking pass.'
H9D4BDB5AD7B9: '啟用X86間接跳轉追蹤Pass。'
# 'Enable a 2nd level loop of loop tiling'
HCA8FDA365AE9: '啟用第二層循環分塊循環'
# 'Enable a specific type of debug output (comma separated list of types)'
H3151AFA58B61: '指定特定類型的除錯輸出（以逗號分隔的類型清單）'
# 'Enable abort calls when "fast" instruction selection fails to lower an instruction: 0 disable the abort, 1 will abort but for args, calls and terminators, 2 will also abort for argument lowering, and 3 will never fallback to SelectionDAG.'
H1EC44B72B380: '當「快速」指令選擇無法降低指令時啟用中止呼叫：0禁用中止，1將中止但對參數、調用和終結器除外，2也會對參數降低中止，3將從不回退到SelectionDAG。'
# 'Enable abort calls when "global" instruction selection fails to lower/select an instruction'
HC411401F6CE3: '當全域指令選擇無法降低/選擇指令時啟用中止呼叫'
# 'Enable adding flow sensitive discriminators'
H127CCD0CABA6: '啟用添加資料流敏感的判別器'
# 'Enable adding inline-remark attribute to callsites processed by inliner but decided to be not inlined'
HFF28D2651FAF: '在內聯器處理但未內聯的呼叫點添加inline-remark屬性'
# 'Enable additional debug output'
HBEA92C1C802B: '啟用額外除錯輸出'
# 'Enable address discrimination of function pointers in init/fini arrays'
H45A216E54E14: '啟用初始/終止陣列中函數指標的地址鑑別'
# 'Enable address discrimination of vtable pointers'
H248ADBB468B0: '啟用虛函數表指標的地址鑑別'
# 'Enable aggressive formation of fused FP ops'
HD91A957036F5: '啟用融合浮點運算的積極形成'
# 'Enable aliasing mode in HWAddressSanitizer'
HFC48EEE3F6A8: '在硬體位址偵測工具中啟用別名模式'
# 'Enable all Clang extensions for OpenMP directives and clauses'
H1D7ED18ACD09: '啟用所有OpenMP指令和子句的Clang擴充功能'
# 'Enable all mitigations for Load Value Injection (LVI)'
H62EE869ADC27: '啟用所有負載值注入（LVI）的緩解措施'
# 'Enable all options'
HEE8F72CD2211: '啟用所有選項'
# 'Enable all traces.'
H57C177E41601: '啟用所有追蹤。'
# "Enable alternative token representations '<:', ':>', '<%', '%>', '%:', '%:%:' (default)"
H4DF4837FAB61: "啟用替代符號表示法 '<:', ':>', '<%', '%>', '%:', '%:%:'（預設）"
# 'Enable amcas[_db].{b/h/w/d}'
H63806DAD9D8C: '啟用amcas[_db].{b/h/w/d}'
# 'Enable amdgpu library simplifications'
HECCE410BA86E: '啟用amdgpu函式庫簡化措施'
# 'Enable amswap[_db].{b/h} and amadd[_db].{b/h}'
H8299FC02710F: '啟用amswap[_db].{b/h} 和 amadd[_db].{b/h}'
# 'Enable analysis of vscale-relative immediates in LSR'
H82C5A0E019DD: '啟用LSR中vscale相對立即數的分析'
# 'Enable analyzing function argument and return types for mandatory definedness'
HF2001822C16A: '啟用分析函數參數和返回類型的強制定義性'
# 'Enable annotate table jump instruction to correlate it with the jump table.'
HFDE9D12C2ECD: '啟用註釋跳轉表指令以與跳轉表關聯'
# 'Enable array bounds checking'
HD533CAFCE917: '啟用陣列邊界檢查'
# 'Enable assumed rank lowering'
H38B9CF78153E: '啟用假設階數降階處理'
# 'Enable atomic operations instrumentation in ThreadSanitizer (default)'
H28E05B9D8B0A: '在執行緒偵測工具中啟用原子運算的插樁（預設）'
# 'Enable authentication of pointers from GOT (ELF only)'
HEE1192FA1CBD: '啟用從GOT驗證指標（僅限ELF）'
# 'Enable auto-vectorization of floatint point types on v68.'
H407986FED01C: '在v68上啟用floatint點類型的自動向量化'
# 'Enable basic block tracing in sanitizer coverage'
HB288E3CF4716: '在sanitizer覆蓋分析中啟用基本區塊追蹤'
# 'Enable binary and hex Motorola integers (%110 and $ABC)'
H929D942FA2B2: '啟用二進位和十六進位Motorola整數（%110 和 $ABC）'
# 'Enable binary and hex masm integers (0b110 and 0ABCh)'
H299555A297D6: '啟用二進位和十六進位masm整數（0b110 和 0ABCh）'
# 'Enable binary output on terminals'
HB1EFC8602261: '在終端機上啟用二進位輸出'
# 'Enable bottleneck analysis (disabled by default)'
H0EF8CE1914F9: '啟用瓶頸分析（預設為禁用）'
# 'Enable branch hint.'
HA68C6AA0EC92: '啟用分支提示。'
# 'Enable branch prediction'
HA09824F26C29: '啟用分支預測'
# 'Enable branch probability info'
HACC86396C5DC: '啟用分支概率資訊'
# 'Enable buffer security check (default)'
HC4E83D1F5690: '啟用緩衝區安全性檢查（預設）'
# 'Enable builtin #include directories even when -nostdinc is used before or after -ibuiltininc. Using -nobuiltininc after the option disables it'
H03545481E610: '即使在使用 -nostdinc 之前或之後，仍啟用內建 #include 目錄。在選項後使用 -nobuiltininc 會禁用它'
# 'Enable caret and column diagnostics (default)'
HB9B531DB1BD2: '啟用-caret和列診斷（預設）'
# 'Enable casting unknown expression results to id'
H1BB41E97517E: '將未知運算式結果轉換為id時啟用類型轉換'
# "Enable cf-protection in 'full' mode"
HB3ADE4BC6E10: "以 'full' 模式啟用cf保護"
# 'Enable chain commoning in PPC loop prepare pass.'
HA72C1C0CBB48: '在PPC迴圈準備pass中啟用鏈結共用'
# 'Enable char8_t from C++2a'
HE9352E073F40: '從C++2a啟用char8_t'
# 'Enable checking for cache bank conflicts'
HD40C33D97687: '啟用快取組衝突檢查'
# "Enable checking of SDNode's single-use status"
H2C3A08FCCF0D: '啟用SDNode的單一使用狀態檢查'
# 'Enable checking of constexpr function bodies for validity within a constant expression context'
HD3707040DC7C: '在常數運算式上下文中啟用檢查constexpr函數主體的有效性'
# 'Enable cmp instruction tracing in sanitizer coverage'
H903963183CE2: '在清查覆蓋範圍中啟用cmp指令追蹤'
# 'Enable code sinking'
HC9AEC37E0425: '啟用代碼下沈'
# 'Enable cold function only instrumentation.'
H103EC2AD6CD5: '啟用僅對冷函數進行插樁'
# 'Enable collecting coverage from system headers'
H14D681672737: '啟用從系統標頭收集覆蓋範圍'
# 'Enable colors in diagnostics'
H2602C065FC54: '在診斷中啟用顏色'
# 'Enable command line arguments round-trip.'
H0FC588FEB00A: '啟用命令列參數往返功能'
# 'Enable commoning of GEP instructions'
H21E18391E092: '啟用共用GEP指令'
# 'Enable communicating debuginfo positions through iterators, eliminating intrinsics. Has no effect if --preserve-input-debuginfo-format=true.'
H99F0E8039EFB: '啟用通過迭代器傳遞除錯資訊位置，並消除內建函數。如果 --preserve-input-debuginfo-format=true，則此選項無效。'
# 'Enable conflict detection in loop-access analysis'
H9866609C7AAA: '在迴圈存取分析中啟用衝突檢測'
# 'Enable consecutive memop optimization in AArch64PostLegalizerCombiner'
H8A9AB4FF7791: '在AArch64PostLegalizerCombiner中啟用連續記憶體操作優化'
# 'Enable continuous instrumentation profiling mode'
HCFE5EA586D23: '啟用持續插樁分析模式'
# 'Enable control flow (and PHI) hoisting in LICM'
H655AACCB94AB: '在LICM中啟用控制流（及PHI）提升'
# 'Enable control flow integrity (CFI) checks for cross-DSO calls.'
H65983BF9B362: '為跨DSO調用啟用控制流完整性（CFI）檢查'
# 'Enable control height reduction optimization (CHR)'
H0F0478FE42AF: '啟用控制高度縮減優化（CHR）'
# 'Enable conversion of arithmetic operations to predicate instructions'
H0A4B03E5BC23: '啟用將算術運算轉換為預測指令'
# 'Enable converting conditional transfers into MUX instructions'
HC372E511555B: '啟用將條件轉移轉換為MUX指令'
# 'Enable converting phi types in CodeGenPrepare'
H646E9AD5179B: '在CodeGenPrepare中啟用轉換Phi類型'
# 'Enable crash diagnostic reporting (default)'
H57A29C53DDA2: '啟用崩潰診斷報告（預設）'
# 'Enable cross-cu references in DWO files'
H371A16C91C53: '在DWO文件中啟用跨CU引用'
# 'Enable cyclic critical path analysis.'
HF81A62B6A5A8: '啟用週期性關鍵路徑分析'
# 'Enable debug info for the debug entry values.'
H62773C4101CF: '啟用調試入口值的調試資訊'
# 'Enable debug messages while writing module files'
H8923A1076553: '寫入模組檔時啟用調試訊息'
# 'Enable debug output'
H8FF327476155: '啟用調試輸出'
# 'Enable debug output for only polly passes.'
HBDB1EA3DBD28: '僅為Polly pass啟用調試輸出'
# 'Enable debugger suppport (default = !-noexec)'
H835D3E853677: '啟用除錯器支援（預設=!-noexec）'
# 'Enable debugging in the OpenMP offloading device RTL'
H333C6CC1A821: '在OpenMP卸載裝置RTL中啟用調試'
# 'Enable debuginfod'
H6FC46DBD1099: '啟用debuginfod'
# 'Enable deferred inlining'
H2F93ACD0E23A: '啟用延遲內嵌'
# 'Enable dense outer loop sparse parallelization.'
H9C0E69F4C10C: '啟用密集外部迴圈稀疏並行化'
# 'Enable dense parallelization for any loop.'
H966B38C95DEA: '對任何迴圈啟用密集並行化'
# 'Enable detailed timing of insert generation'
H2B4DFBE7DA6E: '啟用插入生成的詳細計時'
# 'Enable detection of uninitialized parameters and return values'
H37967C89985E: '啟用對未初始化參數和傳回值的偵測'
# 'Enable device-side debug info generation. Disables ptxas optimizations.'
HBE33969C4B31: '啟用裝置端調試資訊生成。禁用ptxas優化。'
# 'Enable direct TLS access through segment registers (default)'
H6B41286A3288: '通過段寄存器直接存取TLS（預設）'
# 'Enable div instruction tracing in sanitizer coverage'
H70F6EE4DB4D3: '啟用sanitizer覆蓋中的div指令追蹤'
# 'Enable early if-conversion'
HCD88FA9972DA: '啟用早期if轉換'
# 'Enable early if-conversion on X86'
H54EA1744EB53: '啟用X86上的早期if轉換'
# 'Enable elimination of non-kernel functions and unused globals'
H565DB5148508: '啟用消除非核心函數和未使用的全域變數'
# 'Enable emitting RISC-V ELF attributes for ABI features'
HEE2BA9740DE2: '啟用為ABI功能發射RISC-V ELF屬性'
# 'Enable emitting complete constructors and destructors as aliases when possible'
HD806A5232009: '當可能時，啟用將完整的建構函數和解構函數作為別名發射'
# 'Enable enhanced struct-path aware Type Based Alias Analysis'
HB0D34B7D8979: '啟用增強的結構路徑感知型別基於別名分析'
# 'Enable experimental bounds safety extension for C'
H19BF4377E02E: '啟用C語言的實驗性邊界安全擴展'
# 'Enable experimental late parsing of attributes'
H9BF048F97F63: '啟用屬性的實驗性延遲解析'
# 'Enable extended information within the SHT_LLVM_BB_ADDR_MAP that is extracted from PGO related analysis.'
H90477C1DC52F: '啟用從PGO相關分析中提取的SHT_LLVM_BB_ADDR_MAP內的擴展資訊'
# 'Enable external API notes support'
H5E8A30586330: '啟用外部API備註支援'
# 'Enable fat LTO object support'
H21F1B6309F52: '啟用Fat LTO物件支援'
# 'Enable features of APX'
HD328EFFFB9A0: '啟用APX的特性'
# 'Enable fixed point types'
H0490DFC8424C: '啟用固定點類型'
# 'Enable formatting of code changed by applying replacements.\nUse -style to choose formatting style.\n'
H8F0F987DA270: '啟用套用修訂後的程式碼格式化。\n使用-style選項選擇格式化風格。\n'
# 'Enable frame pointer elimination'
HAEAFB8EDDF71: '啟用框架指標消除'
# 'Enable frame pointer elimination, but reserve the frame pointer register'
HE8BA912638EF: '啟用框架指標消除，但保留框架指標寄存器'
# 'Enable frame pointer omission (x86 only)'
H4DBA3F274530: '啟用框架指標省略（僅限x86）'
# 'Enable frecipe.{s/d} and frsqrte.{s/d}'
H3977CB98EF0D: '啟用frecipe.{s/d}和frsqrte.{s/d}'
# 'Enable frequency counters in sanitizer coverage'
H5B9962B0B423: '在sanitizer覆蓋中啟用頻率計數器'
# 'Enable full Microsoft Visual C++ compatibility'
H12B2EDEE6E67: '啟用完整的Microsoft Visual C++相容性'
# 'Enable function entry/exit instrumentation in ThreadSanitizer (default)'
H852113DDBCFA: '在ThreadSanitizer中啟用函數入口/出口插樁（預設）'
# 'Enable function merging as part of the optimization pipeline'
H3BF73DD457C7: '啟用優化管線中的函數合併'
# 'Enable function outlining (AArch64 only)'
H15FFCDCECD61: '啟用函數外提（僅限AArch64）'
# 'Enable function specialization on the address of global values'
H46D83DE2E772: '根據全域值的地址啟用函數特化'
# 'Enable garbage-collecting empty basic blocks'
H82096BB5EF83: '啟用垃圾收集空的基本區塊'
# 'Enable generating trap for unreachable'
HA93A4015EC75: '啟用為不可達代碼生成中斷'
# 'Enable generation of complex instructions'
HD949F4B874C3: '啟用生成複雜指令'
# 'Enable generation of instruction packets'
H9270F92493EE: '啟用生成指令封包'
# 'Enable generation of memop instructions'
HA7AE5A0F239A: '啟用生成memop指令'
# 'Enable generation of new-value jumps'
H88666002BB2B: '啟用生成新值跳轉指令'
# 'Enable generation of new-value stores'
HE01CC1564066: '啟用生成新值儲存指令'
# 'Enable gep instruction tracing in sanitizer coverage'
H24F638FE5491: '在sanitizer覆蓋範圍中啟用gep指令追蹤'
# 'Enable global load scalarization'
HEACC856F3BB8: '啟用全域載入標量化'
# 'Enable global merge functions that are based on hash function'
H5280CEF67BB7: '根據雜湊函數啟用全域合併函數'
# 'Enable global merge pass on constants'
H16452CA5347D: '啟用常數的全域合併pass'
# 'Enable global merge pass on external linkage'
HB636A98A47D2: '啟用外部連結的全域合併pass'
# 'Enable global value internalization in LTO'
HD751EE9A7CD2: '在LTO中啟用全域值內部化'
# 'Enable gp-relative addressing of mips small data items'
H4B029B95E3C4: '啟用mips小數據項的gp相對位址'
# 'Enable hashing of all compiler options that could impact the semantics of a module in an implicit build'
H3D8DF6DE718C: '啟用雜湊所有可能影響模組語法的隱式建置編譯器選項'
# 'Enable hashing the content of a module file'
H181E6C00680E: '啟用雜湊模組檔案的內容'
# 'Enable heap memory profiling'
H80510263BC9C: '啟用堆記憶體剖析'
# 'Enable heap memory profiling and dump results into <directory>'
H29A449A8CDB1: '啟用堆記憶體剖析並將結果存入 <目錄>'
# 'Enable hexagon-qdsp6 backward compatibility'
HC33E9FDD1F01: '啟用hexagon-qdsp6的向後兼容性'
# 'Enable hot-cold splitting pass'
H303E669D24AE: '啟用 hot-cold 分割 pass'
# 'Enable hot/cold operator new library calls'
HC2E3EA90629E: '啟用 hot/cold operator new 庫函數呼叫'
# 'Enable identical code folding'
H28BAA680F117: '啟用相同代碼合併'
# 'Enable if predication of stores during vectorization.'
HA5E79DD1344A: '啟用向量化期間的儲存器 if 預測'
# 'Enable if-conversion during vectorization.'
H0446E14EDCAC: '啟用向量化期間的 if 轉換'
# 'Enable image intrinsic optimizer pass'
H97E756CD1450: '啟用影像內置函數最佳化 pass'
# 'Enable implicit vector bit-casts'
HEB80538424B3: '啟用隱式向量位元轉換'
# "Enable import metadata like 'thinlto_src_module' and 'thinlto_src_file'"
H2A8113D65BE4: "啟用導入元資料，例如 'thinlto_src_module' 和 'thinlto_src_file'"
# 'Enable imprecision in EarlyCSE in pathological cases, in exchange for faster compile. Caps the MemorySSA clobbering calls.'
HAA73048B5B86: '在病態情況下允許 EarlyCSE 的不精確性，以換取更快的編譯速度。限制 MemorySSA 破壞呼叫。'
# 'Enable imprecision in LICM in pathological cases, in exchange for faster compile. Caps the MemorySSA clobbering calls.'
H636968D53932: '在病態情況下允許 LICM 的不精確性，以換取更快的編譯速度。限制 MemorySSA 破壞呼叫。'
# 'Enable incremental processing extensions such as processing statements on the global scope.'
H6BA53F1C325A: '啟用增量處理擴充功能，例如處理全域作用域中的語句。'
# 'Enable inline 8-bit counters in sanitizer coverage'
H519F01E8620F: '啟用清理器覆蓋中的內嵌 8 位計數器。'
# 'Enable inline bool flag in sanitizer coverage'
HC8EAB045EC47: '啟用清理器覆蓋中的內嵌布林旗標。'
# 'Enable inline deferral during PGO'
H66E4DB2AD29F: '在配置文件引導型優化期間啟用內聯延遲。'
# 'Enable inliner stats for imported functions'
H0D332728E36F: '啟用導入函數的內聯器統計資料。'
# 'Enable instsimplify'
HB39E8D05245E: '啟用 instsimplify'
# 'Enable inter-procedural analyses'
H528C6719D608: '啟用跨函數分析'
# 'Enable interleave MVE vector operation lowering'
H8E26ADE70A0E: '啟用 MVE 向量運算的交錯降階'
# 'Enable interprocedural register allocation to reduce load/store at procedure calls.'
H6F0CA76DA224: '啟用程序間記憶體寄存器配置以減少程序呼叫時的載入/儲存操作'
# 'Enable ir outliner pass'
H06C93577A2B7: '啟用 IR outline pass'
# 'Enable just-my-code debugging'
H59918B7E8599: '啟用僅我的程式碼除錯'
# 'Enable keeping all variables that have a persistent storage duration, including global, static and thread-local variables, to guarantee that they can be directly addressed'
H04E5C2AB8675: '啟用保留所有具有持久儲存期間的變數，包括全域、靜態和執行緒局部變數，以確保它們可以直接被存取'
# 'Enable late function splitting using profile information (x86 and aarch64 ELF)'
H4664498771BF: '使用配置文件資訊啟用延遲函數分割（x86 和 aarch64 ELF）'
# 'Enable lazy compilation when using the MCJIT engine'
H1A4A6063E46C: '在使用 MCJIT 執行引擎時啟用懶惰編譯'
# 'Enable linker dead stripping of globals in AddressSanitizer'
H9E8C5D19A202: '啟用 AddressSanitizer 中連結器對全域變數的未使用程式碼刪除'
# 'Enable linker job to emit a static library.'
H1300A9593E8D: '啟用連結器工作以產生靜態函式庫'
# 'Enable linker relaxation'
H4AD9A11300BE: '啟用連結器鬆弛優化'
# 'Enable load and store clustering in the machine scheduler'
H9A7A3DC7E082: '在機器排程器中啟用載入與儲存的群組化'
# 'Enable load store vectorizer'
H6C9482FFD1BF: '啟用載入儲存向量化'
# 'Enable logical abbreviations'
H0D1D59444F4E: '啟用邏輯縮寫'
# 'Enable long calls for save-restore stubs.'
H12EA9151A98D: '啟用保存-恢復存根的長距離呼叫'
# 'Enable loop data prefetch on AMDGPU'
H4B4F5CE87A14: '在 AMDGPU 上啟用迴圈資料預取'
# 'Enable loop data prefetch on Hexagon'
H90194BED7184: '在 Hexagon 上啟用迴圈資料預取'
# 'Enable loop header duplication at any optimization level'
H88A7D3561B15: '在任何優化層級啟用迴圈標頭複製'
# 'Enable loop interleaving in Loop vectorization passes'
H437D1745A932: '在 Loop 向量化 pass 中啟用迴圈交錯'
# 'Enable loop iv regalloc heuristic'
H2FAF4EF1BAC2: '啟用迴圈iv寄存器分配的啟發式方法'
# 'Enable loop tiling'
HF3F1904F445C: '啟用迴圈切片'
# 'Enable loop vectorizer for HVX'
H0E3AC61CFA2F: '啟用HVX的迴圈向量化'
# 'Enable lower module lds pass'
H5FAE08416AEA: '啟用降低模組lds pass'
# 'Enable lowering interleaved accesses to intrinsics'
H848C570E6895: '啟用將交錯存取轉換為內在函數'
# 'Enable lowering math functions to their corresponding MASS (scalar) entries'
H87849497C3F3: '啟用將數學函數轉換為對應的MASS（純量）條目'
# 'Enable lowering of lds to global memory pass and asan instrument resulting IR.'
H778C2CAE9787: '啟用lds到全域記憶體的pass轉換，並對結果IR進行asan插樁'
# 'Enable lowering of the matrix intrinsics'
HFC73281BE936: '啟用矩陣內在函數的轉換'
# 'Enable machine DCE inside regalloc'
H59DAE158F032: '啟用寄存器分配中的機器DCE'
# 'Enable machine block placement based on the ext-tsp model, optimizing I-cache utilization.'
HE6CB65616359: '根據ext-tsp模型啟用機器區塊配置，以優化I-cache使用率'
# 'Enable masked loads/stores for HVX'
H9199C5705B41: '啟用HVX的遮罩載入/儲存'
# 'Enable matrix data type and related builtin functions'
H43FB20CC8C7B: '啟用矩陣資料類型及相關內建函數'
# 'Enable max stack depth tracing'
H509FC7F703A3: '啟用最大堆疊深度追蹤'
# 'Enable mcount instrumentation'
H29618381AE6B: '啟用mcount插樁'
# 'Enable mcount instrumentation with prof'
H0C1503D1A868: '啟用搭配prof的mcount插樁'
# 'Enable memcpyopt even when libcalls are disabled'
HF4D685F00134: '即使禁用libcalls仍啟用MemcpyOpt'
# 'Enable memop clustering.'
H4CE08B6CBECC: '啟用記憶體操作群集'
# 'Enable memory access instrumentation in ThreadSanitizer (default)'
H40FD5983A03D: '在ThreadSanitizer中啟用記憶體存取插樁（預設）'
# 'Enable merging Loop End and Dec instructions.'
H2EA5947F6FF8: '啟用合併Loop End和Dec指令'
# 'Enable merging of globals'
H626AD7B90529: '啟用合併全域變數'
# 'Enable merging of redundant sexts when one is dominating the other.'
H1BD2BF0E8B4D: '當其中一個占優勢時，啟用合併冗餘的 sext操作'
# 'Enable mips16 constant islands.'
HC33E1B95CA7C: '啟用mips16常量島。'
# 'Enable mips16 hard float.'
H077B35DE76F5: '啟用mips16硬體浮點運算。'
# 'Enable missed optimization remarks from passes whose name match the given regular expression'
H5892F9670CED: '啟用名稱符合指定正則表達式的pass所產生的未捕捉到的優化建議'
# 'Enable mode register pass'
H1263C2240107: '啟用模式寄存器pass'
# 'Enable module inliner'
H809D724384CF: '啟用模組內聯器'
# 'Enable module-based external API notes support'
HAD6C2BA49C14: '啟用基於模組的外部API註釋支援'
# 'Enable modules for C++'
HBB0113F4D937: '啟用C++的模組'
# 'Enable name/filename string compression'
H9667A6AB14A5: '啟用名稱/檔案名字串壓縮'
# 'Enable non legal immediates (for testing purposes only)'
H2DA699F30B71: '啟用非法定的立即數（僅供測試使用）'
# 'Enable odd single-precision floating point registers'
H6A9DE1E88E0D: '啟用奇數單精度浮點寄存器'
# 'Enable on-demand initialization of thread-local variables'
H7700944705A7: '啟用按需初始化執行緒局部變數'
# 'Enable only control-flow mitigations for Load Value Injection (LVI)'
HF9542EDE9001: '僅啟用用於負載值注入(LVI)的控制流程緩解措施'
# 'Enable operand tree forwarding'
HB93EA483D9C3: '啟用操作數樹轉送'
# 'Enable optimization analysis remarks from passes whose name match the given regular expression'
H2B83EB5BDF40: '啟用名稱符合指定正則表達式的pass所產生的優化分析建議'
# 'Enable optimization of existing hot/cold operator new library calls'
H7F82E9E27CD9: '啟用對現有熱/冷operator new函式庫呼叫的優化'
# 'Enable optimization remarks from passes whose name match the given regular expression'
H2198D7418FE6: '啟用名稱與給定正則表達式匹配的pass所產生的最佳化提示'
# 'Enable optimizations'
H5D736AD67AD6: '啟用最佳化'
# 'Enable optimizations based on strict aliasing rules'
HCF0A62237B7C: '根據嚴格別名規則啟用最佳化'
# "Enable optimizations based on the strict definition of an enum's value range"
H186F36BCDB9E: '根據enum值範圍的嚴格定義啟用最佳化'
# 'Enable optimizations based on the strict definition of flexible arrays'
HA59BB0439AAE: '根據彈性陣列的嚴格定義啟用最佳化'
# 'Enable optimizations based on the strict rules for overwriting polymorphic C++ objects'
H13CA0465139C: '根據覆寫多態性C++物件的嚴格規則啟用最佳化'
# 'Enable optimizations on complex GEPs'
H50EEF415122A: '對複雜的GEP啟用最佳化'
# 'Enable optimizations that may decrease FP precision'
H67D78B43979D: '啟用可能減少浮點精度的最佳化'
# 'Enable optimized register allocation compilation path.'
H0059F32A3970: '啟用優化寄存器分配的編譯路徑'
# 'Enable or disable Control Flow Guard checks and guard tables emission'
H20C0331A083C: '啟用或禁用控制流Guard檢查和guard表格的發射'
# 'Enable origins tracking in MemorySanitizer'
H2743C4FAB786: '在MemorySanitizer中啟用起源追蹤'
# 'Enable overlapping among matches in a group of consecutive\nCHECK-DAG directives.  This option is deprecated and is only\nprovided for convenience as old tests are migrated to the new\nnon-overlapping CHECK-DAG implementation.\n'
HA5495662EA0A: '在連續CHECK-DAG指令群組的匹配中啟用重疊。此選項已棄用，僅供在舊測試遷移至新非重疊CHECK-DAG實現時方便使用。\n'
# 'Enable parser support for the __unknown_anytype type; for testing purposes only'
H4226A11EC54A: '為__unknown_anytype類型啟用解析器支援；僅供測試使用'
# 'Enable partial store merging in DSE'
HEF8E935B1092: '在DSE中啟用部分儲存合併'
# 'Enable partial-overwrite tracking in DSE'
H4283D5D63662: '在DSE中啟用部分覆寫追蹤'
# 'Enable pass to eliminate conditions based on linear constraints'
H59888AB6AA6D: '啟用基於線性約束的條件消除pass'
# 'Enable perf profiling support'
H6FDDBD2502B8: '啟用性能剖析支援'
# 'Enable phi-translation of add instructions'
H2871DDB08B81: '啟用加法指令的 phi-translation'
# 'Enable placement of extracted cold functions into a separate section after hot-cold splitting.'
HC9DB0E175EB1: '在熱/冷分割後，將提取的冷函數置於獨立區段中'
# 'Enable pointer authentication intrinsics'
H367806655729: '啟用指標驗證內建函數'
# 'Enable poisoning array cookies when using custom operator new[] in AddressSanitizer'
HC79D664C6E42: '在 AddressSanitizer 中使用自訂 operator new[] 時毒化陣列 cookies'
# 'Enable pre-link mode optimizations'
H20BCBBC300E0: '啟用預連結模式最佳化'
# 'Enable precise memory mode (AMDGPU only)'
HE9548687DBB5: '啟用精確記憶體模式（僅 AMDGPU）'
# 'Enable predefined and command line preprocessor macros'
H69A47E977056: '啟用預定義及命令列預編譯器巨集'
# 'Enable predefined target OS macros'
H9D44D77675A5: '啟用預定義目標作業系統巨集'
# 'Enable profile hotness information in diagnostic line'
H6ECB1E31250D: '在診斷行啟用剖析熱點資訊'
# 'Enable profile instrumentation sampling (default = off)'
H16EB6D513222: '啟用剖析插樁採樣（預設=關閉）'
# 'Enable promoting aligned anyext load to wider load'
H1CA89F41F132: '啟用將對齊的 anyext 載入提升為更寬的載入'
# 'Enable promotion of flat kernel pointer arguments to global'
H4206A6231E2E: '啟用將平面核心指標參數提升為全域'
# 'Enable quadword atomics ABI on AIX (AIX PPC64 only). Uses lqarx/stqcx. instructions.'
H01E0F762B340: '在 AIX 上啟用四字元原子操作 ABI（僅 AIX PPC64）。使用 lqarx/stqcx 指令。'
# 'Enable raw string literals'
H8C8B44AEB3E9: '啟用原始字串字面量'
# 'Enable reassociation of accumulation chains'
H35D68C90E430: '啟用累加鏈的重新結合'
# 'Enable reciprocal sqrt optimization'
H6556F5DE61D3: '啟用平方根倒數最佳化'
# 'Enable recognition of non-constant strided pointer induction variables.'
H95B2F8C1B69F: '啟用對非常數間隔指標歸納變數的辨識。'
# 'Enable recovery for specified sanitizers'
H2A20F3F3EA12: '為指定的清理程式啟用恢復功能'
# 'Enable recovery mode (continue-after-error).'
HBD337CDF104A: '啟用恢復模式（錯誤後繼續）。'
# 'Enable regalloc advisor mode'
H7AE29F2A8C3F: '啟用寄存器分配建議模式'
# 'Enable register pressure scheduling.'
HC0DF1D86F80E: '啟用寄存器壓力排程。'
# 'Enable register reassign optimizations on gfx10+'
H2EA748D732DD: '在 GFX10+ 處理器上啟用寄存器重新分配最佳化'
# 'Enable register tiling'
H02ACF2158ECD: '啟用寄存器分塊'
# 'Enable relocating counters at runtime.'
H1C98545F997D: '啟用執行階段重新定位計數器。'
# 'Enable removal of functions when theyuse features not supported by the target GPU'
HA60D39957FD6: '當函式使用目標 GPU 不支援的特性時，啟用移除該函式'
# 'Enable required s_wait_alu on SGPR hazards'
H5931DB0CC40E: '啟用在 SGPR 威脅時所需的 s_wait_alu 指令'
# "Enable retain SubstTemplateTypeParmType nodes in the AST's representation of alias template specializations"
HB02FA0B87AE4: '在別名模板特化表示中保留 SubstTemplateTypeParmType 節點'
# 'Enable rewrite partial reg uses pass'
HC2E09FB1800A: '啟用重寫部分寄存器使用之 pass'
# 'Enable runtime checks for stack overflow.'
H20B19FA46C02: '啟用堆疊溢位的執行階段檢查。'
# 'Enable runtime interleaving until load/store ports are saturated'
H83E188A2297B: '啟用執行階段交錯直到載入/儲存埠飽和'
# 'Enable s_delay_alu insertion'
H8A9476D62164: '啟用 s_delay_alu 插入'
# 'Enable safe identical code folding'
H31D3779CB68C: '啟用安全的相同代碼摺疊'
# 'Enable sample-based profile guided optimizations'
H96541402ED68: '啟用基於樣本的配置文件引導型優化'
# 'Enable sanitizer coverage for indirect calls'
HB591DDDA07BD: '啟用間接呼叫的檢查工具覆蓋'
# 'Enable sanitizer for supported offloading devices'
HFDA0060284A3: '為支援的卸載裝置啟用檢查工具'
# 'Enable sanitizer statistics gathering.'
HC1E74A5D06CE: '啟用檢查工具的統計資料收集。'
# 'Enable sc.q instruction.'
H657B7BD0EB9D: '啟用sc.q指令。'
# 'Enable scalar IR passes'
HD2045AE5F150: '啟用純量IR pass'
# 'Enable scheduling addi instruction as earlyas possible post ra'
H3324B351B51A: '在ra後盡可能早地排程addi指令'
# 'Enable scheduling after register allocation'
H142271112BA0: '啟用寄存器分配後的排程'
# 'Enable scheduling for macro fusion.'
H3396D13A8F30: '啟用宏融合的排程。'
# 'Enable select to branch optimizations'
H7DB0FCE3CF68: '啟用選擇到跳轉的優化'
# 'Enable setting constant bits to reduce size of mask immediates'
HD06E3ECAB947: '啟用設定常數位以減少遮罩立即數的大小'
# 'Enable setting lr as a predicate in tail predication regions.'
H5D3D99EE631D: '在尾端預測區域中啟用將lr設為預測條件。'
# 'Enable setting the FP exceptions build attribute not to use exceptions'
H29262DC5BE27: '設定FP例外建置屬性以不使用例外處理'
# 'Enable shared library instrumentation with XRay'
HBB7CC7BAF352: '使用XRay對共用函式庫進行插樁'
# 'Enable signing and authentication of all indirect calls'
H85AEAA3DF7E2: '啟用所有間接呼叫的簽名和驗證'
# 'Enable signing and authentication of indirect goto targets'
H7778174B9D56: '啟用間接goto目標的簽署與驗證'
# 'Enable signing and authentication of return addresses'
HB69C655EC5B4: '啟用回傳地址的簽署與驗證'
# 'Enable signing of function pointers in init/fini arrays'
HF447A017CA1C: '啟用在init/fini arrays中的函數指標簽署'
# 'Enable simple copy propagation during register reloading'
HB0CCABAD4B9C: '在寄存器重新加載期間啟用簡單的拷貝傳播'
# 'Enable single byte coverage'
HCE6038C8EF64: '啟用單字節覆蓋'
# 'Enable sinking and folding of instruction copies'
HAFBBC2D2907E: '啟用指令拷貝的下沉與合併'
# 'Enable sinking and/cmp into branches.'
HC2C79127C7B6: '啟用將cmp指令下沉到分支中'
# 'Enable some non conforming code to compile'
H97500F6CC226: '啟用某些不符合標準的程式碼編譯'
# 'Enable some traditional CPP emulation'
H86897CE40B49: '啟用傳統C預處理器（CPP）模擬'
# 'Enable sparse parallelization for any storage and loop.'
H86D1CE3B297F: '啟用任何存儲和迴圈的稀疏並行化'
# 'Enable sparse parallelization regardless of storage for the outer loop.'
HD78181DC6B92: '無論存儲類型如何，啟用外層迴圈的稀疏並行化'
# 'Enable special debugger support behavior'
H526152B74AA2: '啟用特殊除錯器支援行為'
# 'Enable special debugger support for Objective-C subscripting and literals'
H40F60E7DDF05: '為Objective-C的索引運算子和文字提供特殊除錯器支援'
# 'Enable specialization of functions that take a literal constant as an argument'
H8CB997684347: '啟用以字面常數作為參數的函數特化'
# 'Enable specifying registers without the % prefix'
H4FA626EAB19A: '啟用不使用%前綴指定寄存器'
# 'Enable speculative execution side effect suppression (SESES). Includes LVI control flow integrity mitigations'
H8F91025B1797: '啟用推测執行副作用抑制（SESES）。包含LVI控制流完整性緩解措施'
# 'Enable spilling SGPRs to VGPRs'
HBC64889F75D9: '啟用將SGPRs溢出到VGPRs'
# 'Enable spilling VGPRs to AGPRs'
HCAAEDB0207AA: '啟用將VGPRs溢出到AGPRs'
# 'Enable spills from gpr to vsr rather than stack'
H93A49F7D7A81: '將GPR溢出到VSR而非堆棧'
# 'Enable spills in prologue to vector registers.'
H14C00957A630: '在函數序曲中啟用向向量寄存器的溢出'
# 'Enable splitting large offset of GEP.'
HC17E8C448D7B: '啟用分割GEP的大偏移量'
# 'Enable splitting of a ThinLTO LTOUnit'
HD2FEBF5117B2: '啟用分割ThinLTO LTOUnit'
# 'Enable stack clash protection'
HD6B8B4D2B61B: '啟用堆疊衝突保護'
# 'Enable stack frame shrink wrapping'
H96A0AAD52568: '啟用堆疊框架緊湊包裝'
# 'Enable stack probes'
H2C8F59EB6B80: '啟用堆疊探針'
# 'Enable stack protectors'
H92CD4261F56E: '啟用堆疊保護器'
# 'Enable stack protectors for all functions'
H4AAD4C1AF839: '為所有函數啟用堆疊保護器'
# 'Enable stack protectors for some functions vulnerable to stack smashing. Compared to -fstack-protector, this uses a stronger heuristic that includes functions containing arrays of any size (and any type), as well as any calls to alloca or the taking of an address from a local variable'
H01F993B30A66: '為部分易受堆疊溢位攻擊的函數啟用堆疊保護器。與-fstack-protector相比，此選項採用更嚴格的_heuristic_，包含所有包含任意大小（或任意類型）陣列的函數，以及任何呼叫alloca或取得局部變數位址的函數'
# "Enable stack protectors for some functions vulnerable to stack smashing. This uses a loose heuristic which considers functions vulnerable if they contain a char (or 8bit integer) array or constant sized calls to alloca , which are of greater size than ssp-buffer-size (default: 8 bytes). All variable sized calls to alloca are considered vulnerable. A function with a stack protector has a guard value added to the stack frame that is checked on function exit. The guard value must be positioned in the stack frame such that a buffer overflow from a vulnerable variable will overwrite the guard value before overwriting the function's return address. The reference stack guard value is stored in a global variable."
H216044E73536: '為部分易受堆疊溢位攻擊的函數啟用堆疊保護器。此選項使用寬鬆_heuristic_，若函數包含大小超過_ssp-buffer-size_（預設：8字節）的_char_（或 8 位元整數）陣列，或固定大小的alloca呼叫，則視為有風險。所有變數大小的alloca呼叫均視為有風險。具有堆疊保護器的函數會在堆疊框架中新增檢查值，該值在函數結束時會被驗證。檢查值必須位於堆疊框架中，使得易受攻擊的變數的緩衝區溢位會先覆寫檢查值，而非函數的返回位址。參考堆疊檢查值存放在全域變數中。'
# 'Enable static hinting of branches on ppc'
H1318D7CF750E: '在ppc上啟用分支的靜態提示'
# 'Enable statistics output from program (available with Asserts)'
H7E1E434B51DE: '啟用程式統計輸出（需搭配Asserts）'
# 'Enable stress test of coldcc by adding calling conv to all internal functions.'
H864C98F93D8C: '透過將呼叫約定新增至所有內部函數來進行coldcc的壓力測試'
# 'Enable stricter verification with -verify-scev is passed'
HA0BAD2CA5C13: '當傳入-verify-scev時啟用更嚴格的驗證'
# 'Enable string pooling (default)'
H01420F7F4ED8: '啟用字串池化（預設）'
# 'Enable subreg liveness tracking'
H59D79C24D746: '啟用子寄存器存活追蹤'
# 'Enable subregister liveness tracking for SystemZ (experimental)'
H278D5FB962A3: '為SystemZ啟用實驗性的子寄存器存活追蹤'
# 'Enable subregister liveness tracking.'
HA8D796B2328B: '啟用子寄存器存活追蹤'
# 'Enable support for exception handling'
HFB1350CAA576: '啟用例外處理支援'
# 'Enable support for ignoring exception handling constructs'
H1F7624DB7FC3: '啟用忽略例外處理語法的支援'
# 'Enable support for int128_t type'
H8EC6E7CC318F: '啟用int128_t類型的支援'
# 'Enable support for the C++ Coroutines'
H7925EA35B0A4: '啟用C++協程的支援'
# 'Enable symbolic stride memory access versioning'
H614C3C8C780E: '啟用符號化步幅記憶體存取版本控制'
# 'Enable tail-predication, but not for reduction loops'
H7759A373B899: '啟用尾部預測，但不包括約簡迴圈'
# 'Enable tail-predication, but not for reduction loops, and force this which might be unsafe'
HEC8679DD9C06: '啟用尾部預測，但不包括約簡迴圈，並強制使用此功能（可能不安全）'
# 'Enable tail-predication, including reduction loops'
H9E0011DEC062: '啟用尾部預測，包括約簡迴圈'
# 'Enable tail-predication, including reduction loops, and force this which might be unsafe'
H65CA4B853D34: '啟用尾部預測，包括約簡迴圈，並強制使用此功能（可能不安全）'
# 'Enable that single precision floating-point divide and sqrt used in '
H40916D94286B: '啟用在 中使用的單精確度浮點除法和平方根運算'
# 'Enable the "fast" instruction selector'
HB827608C6F32: '啟用"快速"指令選擇器'
# 'Enable the "global" instruction selector'
HC28B60B42675: '啟用"全域"指令選擇器'
# "Enable the 'blocks' language feature"
H8A0F69B5F85C: "啟用 'blocks' 語言功能"
# "Enable the 'modules' language feature"
H047278B48AFB: "啟用 'modules' 語言功能"
# 'Enable the AArch64 branch target pass'
H288D5F3BECED: '啟用AArch64分支目標pass'
# 'Enable the AIX Extended Altivec ABI.'
H2F5C4C6F1979: '啟用AIX擴展Altivec ABI。'
# 'Enable the CCMP formation pass'
HD0F0CA1649A7: '啟用CCMP形成pass'
# 'Enable the GVN hoisting pass (default = off)'
HEAFC22E87450: '啟用GVN提升pass（預設=關閉）'
# 'Enable the GVN sinking pass (default = off)'
H58E31BED29F9: '啟用GVN下沉pass（預設=關閉）'
# 'Enable the IR outliner on linkonceodr functions'
H040BEC05F858: '在linkonceodr函式上啟用IR外聯器'
# 'Enable the LoopFlatten Pass'
HAC22881851DD: '啟用LoopFlatten Pass'
# 'Enable the LoopInterchange Pass'
HDD03023B6FBB: '啟用 LoopInterchange Pass'
# 'Enable the OpenMP region merging optimization.'
HE96DB2508A4B: '啟用 OpenMP 區域合併優化。'
# 'Enable the Polly DOT printer in -O3'
H4E0A173B05AF: '在 -O3 中啟用 Polly DOT 打印器'
# 'Enable the Polly DOT printer in -O3 (no BB content)'
HEAA8FA2DC249: '在 -O3 中啟用 Polly DOT 打印器（不含 BB 內容）'
# 'Enable the RISC-V VL Optimizer pass'
HC773BD141E4D: '啟用 RISC-V VL 优化器 Pass'
# 'Enable the VR4300 mulmul bug fix.'
HF647968864FA: '啟用 VR4300 mulmul 的錯誤修正。'
# 'Enable the X86 cmov-to-branch optimization.'
HA57709995537: '啟用 X86 cmov 轉分支優化。'
# 'Enable the abort'
HF630F0E0D97E: '啟用 abort'
# 'Enable the attributor inter-procedural deduction pass'
HC3A4293C13B2: '啟用 attributor 跨程序分析推斷 Pass'
# 'Enable the condition optimizer pass'
H9D8DD66B429A: '啟用條件優化 Pass'
# 'Enable the conditional branch tuning pass'
H08843D4DB1BA: '啟用條件分支調整 Pass'
# 'Enable the copy propagation with AArch64 copy instr'
H7A7BF4C2FF44: '使用 AArch64 複製指令的傳播'
# 'Enable the copy propagation with RISC-V copy instr'
H8FDD7DCFE43D: '使用 RISC-V 複製指令的傳播'
# 'Enable the cost-benefit analysis for the inliner'
H4A32DF87AC31: '為內聯器啟用效益分析'
# 'Enable the early if converter pass'
HC1AB5BB544BB: '啟用早期 if 轉換器 Pass'
# 'Enable the experimental Loop Versioning LICM pass'
HAC7286F63BD3: '啟用實驗性 Loop 版本化 LICM Pass'
# 'Enable the experimental new constant interpreter'
HA94181FC4D28: '啟用實驗性新常量解釋器'
# 'Enable the extended Altivec ABI on AIX. Use volatile and nonvolatile vector registers'
H6369C2DE5BEE: '在 AIX 上啟用擴展的 Altivec ABI。使用 volatile 和 nonvolatile 向量寄存器'
# 'Enable the generation of 4-operand madd.s, madd.d and related instructions.'
H2954D704DCA6: '啟用生成 4-操作數的 madd.s、madd.d 及相關指令。'
# 'Enable the generation of WLS loops'
HB0BD6C355304: '啟用生成 WLS 迴圈'
# 'Enable the generation of masked gathers and scatters'
H69417D79F86A: '啟用遮罩gather和scatter的產生'
# 'Enable the generation of masked loads and stores'
H8811F179AC8C: '啟用遮罩載入和存儲的產生'
# 'Enable the global merge pass'
HF3A16D1A310B: '啟用全域合併pass'
# 'Enable the initializes attr improvement in DSE'
H2C13638D3B7A: '啟用DSE中的initializes屬性改進'
# 'Enable the integrated assembler'
H6897999B76AE: '啟用整合式組譯器'
# 'Enable the legacy pass manager. This is strictly for bugpoint due to it not working with the new PM, please do not use otherwise.'
H4ACF17F9F060: '啟用舊版pass管理器。此選項僅供bugpoint使用，因其不與新PM兼容，請勿用於其他情況。'
# 'Enable the live debug variables pass'
H97C40BB61A18: '啟用活躍除錯變數pass'
# 'Enable the load/store pair optimization pass'
HAF961AA83173: '啟用載入/存儲配對優化pass'
# 'Enable the loop data prefetch pass'
H1F5F62A8C420: '啟用迴圈資料預取pass'
# 'Enable the loop interchange pass'
HACD3CEF0E137: '啟用迴圈交換pass'
# 'Enable the loop vectorization passes'
HD80457B01B02: '啟用迴圈向量化passes'
# 'Enable the machine combiner pass'
H6170C8360FA8: '啟用機器指令組合pass'
# 'Enable the machine instruction scheduling pass.'
H5ED9F17A2AD8: '啟用機器指令排程pass。'
# 'Enable the machine outliner'
H6AA5708D3CBD: '啟用機器外線化'
# 'Enable the machine outliner on linkonceodr functions'
HC9ED1CD426C7: '在linkonceodr函數上啟用機器外線化'
# 'Enable the new pass manager'
H93E040EA4A3C: '啟用新版pass管理器'
# 'Enable the new, experimental LoopDistribution Pass'
H349A804BD347: '啟用新的實驗性LoopDistribution Pass'
# 'Enable the old style PARAMETER statement'
H17563270F079: '啟用舊式PARAMETER語法'
# 'Enable the pass that emits the linker optimization hints (LOH)'
HA4C27576F1AF: '啟用產生連結器優化提示（LOH）的pass'
# 'Enable the pass that removes dead definitions and replaces stores to them with stores to the zero register'
HB91327722E91: '啟用移除無效定義並將其存儲轉向零寄存器的pass'
# 'Enable the pass that removes dead definitions and replaces stores to them with stores to x0'
H3F4AC3AD0D0C: '啟用移除未使用定義的pass，並將存入它們的存儲操作替換為存入x0的存儲操作'
# 'Enable the pass that removes dead definitons and replaces stores to them with stores to r0'
H8430D489B8AD: '啟用移除未使用定義的pass，並將存入它們的存儲操作替換為存入r0的存儲操作'
# 'Enable the polly optimizer (with -O1, -O2 or -O3)'
H2F44BA5CB43F: '啟用Polly優化器（需搭配-O1、-O2 或 -O3）'
# 'Enable the post-ra machine instruction scheduling pass.'
H81A625E2EDC2: '啟用後RA機器指令排程pass。'
# 'Enable the profile guided size optimizations. '
HD0F54569CD57: '啟用配置文件引導型大小優化。'
# 'Enable the promote constant pass'
H39117666C528: '啟用提升常數pass'
# 'Enable the redundant copy elimination pass'
HCC7E809780AA: '啟用冗餘複本消除pass'
# 'Enable the scheduler to generate .cur'
H9F36FFDB648E: '啟用排程器以生成.cur'
# 'Enable the specified remark'
HF163370BA2BE: '啟用指定的remark'
# 'Enable the specified warning'
HB465ABA562BF: '啟用指定的警告'
# 'Enable the superword-level parallelism vectorization passes'
H03A53AF6091A: '啟用超字元級並行向量化passes'
# 'Enable the tile register allocation pass'
H8BFDE65405FB: '啟用區塊寄存器配置pass'
# 'Enable the use of AA during codegen.'
H330FE8DFBA44: '啟用程式生成期間的別名分析（AA）使用'
# 'Enable the use of TLS Descriptors'
HC87014CCBA07: '啟用TLS描述符使用'
# 'Enable the use of the block frequency analysis to access PGO heuristics minimizing code growth in cold regions and being more aggressive in hot regions.'
H6383E4E8CC05: '啟用區塊頻率分析來存取PGO启发式方法，在冷門區域最小化程式碼增長，並在熱門區域更積極優化。'
# 'Enable the use of the block frequency analysis to reduce the chance to execute const materialization more frequently than without hoisting.'
H05FE62E1BC2A: '啟用區塊頻率分析以減少提升後執行常數產生的頻率。'
# 'Enable the vectorisation of loops with in-order (strict) FP reductions'
HC23A0D871AA8: '啟用按順序（嚴格）浮點約簡的迴圈向量化'
# 'Enable the wasm-opt optimizer (default)'
H66A2CFFFDC43: '啟用wasm-opt優化器（預設）'
# 'Enable the widening of global strings to alignment boundaries'
HEA83816331AB: '啟用將全域字串擴展至對齊邊界'
# 'Enable the workaround for OCL name mangling mismatch.'
H76DA67C39D2D: '啟用解決OCL命名規則不匹配的補丁。'
# 'Enable thread-safe initialization of static variables'
H50C0425B9069: '啟用靜態變數的執行緒安全初始化'
# 'Enable threadgroup split execution mode (AMDGPU only)'
H94C846ABEAAC: '啟用執行緒群組分割執行模式（僅 AMDGPU）'
# 'Enable timing class latency'
H68F7539AA86E: '啟用計時類別延遲'
# 'Enable timing of insert generation'
HF299FBD7AEA4: '啟用插入生成的計時'
# 'Enable tls optimization peephole'
H5607F3078246: '啟用TLS最佳化小孔優化'
# 'Enable tracing of loads'
HFCB6983FD21E: '啟用載入追蹤'
# 'Enable tracing of stores'
HE51956EA02F1: '啟用儲存追蹤'
# 'Enable trapping for all sanitizers'
H797FF784214D: '啟用所有檢查器的陷阱'
# 'Enable trapping for specified sanitizers'
H8D7750937E63: '啟用指定檢查器的陷阱'
# 'Enable traps on authentication failures'
HB1958D1E9CCE: '在驗證失敗時啟用陷阱'
# 'Enable treating throwing global C++ operator new as always returning valid memory (annotates with __attribute__((returns_nonnull)) and throw()). This is detectable in source.'
H98A09520B600: '將會拋出例外的全域C++運算子new視為始終返回有效的記憶體（使用__attribute__((returns_nonnull))和throw()進行註解）。這在原始碼中是可偵測的。'
# 'Enable trigraphs'
HD29B31F12F2E: '啟用三元字元'
# 'Enable two-phase name lookup in templates'
H808ED9B492E8: '在範本中啟用兩階段名稱查找'
# 'Enable two-round ThinLTO code generation. The first round emits codegen data, while the second round uses the emitted codegen data for further optimizations.'
H4183BCD4B48B: '啟用ThinLTO兩輪程式碼產生。第一輪發出程式碼產生資料，而第二輪使用發出的程式碼產生資料進行進一步最佳化。'
# 'Enable type and address discrimination of vtable pointer of std::type_info'
H10834C3F61A6: '啟用std::type_info的vtable指標的類型和位址區分'
# 'Enable type discrimination of vtable pointers'
H5E406CE94798: '啟用vtable指標的類型區分'
# 'Enable type discrimination on C function pointers'
HB262A3E07E79: '在C函式指標上啟用類型區分'
# 'Enable unsafe double to float shrinking for math lib calls'
HADD895A7C263: '啟用數學函式庫呼叫時不安全的double到float縮減'
# 'Enable unswitch cost multiplier that prohibits exponential explosion in nontrivial unswitch.'
H05E336233C05: '啟用禁止在非平凡unswitch中指數爆炸的unswitch成本乘數'
# 'Enable use of AA during MI DAG construction'
H13EA04236348: '在MI DAG建構期間啟用AA的使用'
# 'Enable use of AdvSIMD scalar integer instructions'
H2C1BB8E0F766: '啟用AdvSIMD純量整數指令的使用'
# 'Enable use of GPR32 in inline assembly for APX'
HD4DD583F3412: '在APX的內嵌組裝語言中啟用GPR32的使用'
# 'Enable use of TBAA during MI DAG construction'
H8EF1EE9B884D: '在MI DAG構建期間啟用TBAA的使用'
# 'Enable use of a base pointer for complex stack frames'
H6F6CB09044A3: '為複雜堆疊框架啟用基底指標的使用'
# 'Enable use of builtin functions'
H6E647497900D: '啟用內建函數的使用'
# 'Enable use of experimental RISC-V extensions.'
H16ED2241C9C1: '啟用實驗性RISC-V擴充功能'
# 'Enable use of hot hints (only supported for unambigously hot allocations)'
H80EB4017A5F5: '啟用熱提示的使用（僅支援明確的熱分配）'
# 'Enable use of the DWARFv5 DW_OP_convert operator'
H68201FB3FEC3: '啟用DWARFv5 DW_OP_convert操作符的使用'
# 'Enable use of the MCJIT object caching'
H8DEBC9578EBC: '啟用MCJIT物件快取的使用'
# 'Enable use-after-destroy detection in MemorySanitizer'
H9D193DAF1144: '在MemorySanitizer中啟用使用已銷毀物件的偵測'
# 'Enable use-after-scope detection in AddressSanitizer'
H57E5EACCD6DF: '在AddressSanitizer中啟用超出作用域後的使用偵測'
# 'Enable using coldcc calling conv for cold internal functions'
H2D564DBF6E20: '為冷內部函數啟用使用coldcc調用約定'
# 'Enable using library calls for save and restore'
H5D8D6E37F3DB: '啟用使用函式庫調用進行保存和恢復'
# 'Enable value profiling'
HC22D05737DD8: '啟用值剖面分析'
# 'Enable vec acc forwarding'
H5E7B35E50AEB: '啟用向量累加器轉送'
# 'Enable vec alu forwarding'
HB58D78835B76: '啟用向量ALU轉送'
# 'Enable vectorization for wider vector utilization'
HA93E4FD1B769: '為更廣泛的向量使用啟用向量化'
# 'Enable vectorization of early exit loops with uncountable exits.'
H5BAE1D5D430F: '啟用具有無法計數退出的早期退出循環的向量化'
# 'Enable vectorization of epilogue loops.'
H633875436202: '啟用尾部循環的向量化'
# 'Enable vectorization on interleaved memory accesses in a loop'
HAC5648620E31: '在循環中的交错記憶體存取上啟用向量化'
# 'Enable vectorization on masked interleaved memory accesses in a loop'
H043FDB797D48: '啟用循環中的遮罩交錯記憶體存取向量化'
# 'Enable verbose debugging for Loop Fusion'
H0D6210EADA30: '啟用循環融合的詳細除錯輸出'
# 'Enable verbose output'
H11B3BB594E91: '啟用詳細輸出'
# 'Enable verbose output (results, IR, etc.) to stderr'
HCCA7B2AA9E71: '將詳細輸出（結果、IR 等）輸送到 stderr'
# 'Enable verification of LLVM IR'
H21971438C1F9: '啟用LLVM IR 驗證'
# 'Enable verification of MemorySSA.'
H0C498CC2C452: '啟用MemorySSA 驗證'
# 'Enable verification of assumption cache'
HA1CDE46C471E: '啟用假設快取驗證'
# 'Enable vextract optimization'
HEA51F4DB759E: '啟用vextract最佳化'
# 'Enable virtual function elimination'
HB0B4C26F8F08: '啟用虛函數消除'
# 'Enable vtune profiling support'
H19C598762536: '啟用vtune 剖析支援'
# 'Enable warnings for deprecated constructs and define __DEPRECATED'
H141A6A5BBE2F: '啟用對已棄用結構的警告並定義 __DEPRECATED'
# 'Enable warnings for undefined macros with a prefix in the comma separated list <arg>'
HCD611C0CC9C3: '為帶有逗號分隔清單 <arg> 中前綴的未定義宏啟用警告'
# 'Enable whole program visibility'
HED7D14DA2E46: '啟用整體程式能見度'
# 'Enable whole program visibility during LTO'
H467630D788B8: '在LTO期間啟用整體程式能見度'
# 'Enable workarounds for GR712RC errata'
H12F1DF5F1AA6: '啟用GR712RC錯誤修正的解決方案'
# 'Enable workarounds for UT700 errata'
HEED588686E0F: '啟用UT700錯誤修正的解決方案'
# 'Enable/disable fusing matrix instructions.'
HCF6BF736057E: '啟用/停用矩陣指令融合'
# 'Enable/disable matrix shape verification.'
HBF4777571623: '啟用/停用矩陣形狀驗證'
# 'Enables DWARF32 format for ELF binaries, if debug information emission is enabled.'
HC14824860E5E: '如果啟用除錯資訊發射，則為ELF二進位檔啟用DWARF32格式'
# 'Enables DWARF64 format for ELF binaries, if debug information emission is enabled.'
H636F6BB5F153: '如果啟用除錯資訊發射，則為ELF二進位檔啟用DWARF64格式'
# 'Enables UNSIGNED type'
H12352306E73A: '啟用 UNSIGNED 類型'
# 'Enables autovectorization of some loops containing histograms'
HC9BA8F6B64F6: '啟用包含直方圖的某些迴圈的自動向量化'
# 'Enables dead virtual function elimination optimization. Requires -flto=full'
HF54593F712BA: '啟用虛函數消去優化。需要 -flto=full'
# 'Enables more verbose remarks.'
H247202E5D41C: '顯示更詳細的說明。'
# "Enables scope for regex variables. Variables with names that\ndo not start with '$' will be reset at the beginning of\neach CHECK-LABEL block."
H1C0B00C976AB: '啟用正則表達式變數的作用域。變數名稱不以「$」開頭者將在每個 CHECK-LABEL 區塊開始時重置。'
# 'Enables spilling/reloading SVE predicates as data vectors (ZPRs)'
H7E00B4776D94: '啟用將SVE預測元（ZPRs）作為數據向量溢出/重新載入'
# 'Enables splitting of the LTO unit'
H14642BDE0542: '啟用分割LTO unit'
# 'Enables strict availability diagnostic mode for HLSL built-in functions.'
H68650E3ED1FE: '啟用HLSL內建函數的嚴格可用性診斷模式。'
# 'Enables the global instruction selector'
H6762200C8D35: '啟用全局指令選擇器'
# 'Enables the use of non-default rounding modes and non-default exception handling on targets that are not currently ready.'
H405A02EF316C: '啟用非預設捨入模式和非預設例外處理（EH）功能。此功能目前尚未在目標平台完成準備。'
# 'Enables tracing of vector stores'
H5763CA739FFE: '追蹤向量存儲操作'
# 'Enables whole-program vtable optimization. Requires -flto'
H251D67CF92D1: '啟用全程序虛函數表優化。需要 -flto'
# 'End sequence.'
H06B975DED7C7: '結束序列。'
# 'Enforce name visibility rules across submodules of the same top-level module.'
H3A526080F9BF: '強制在相同頂層模塊的子模塊間遵循名稱可見性規則。'
# 'Enforce targets of indirect branches and function returns'
H01AC3BBC07B8: '強制間接跳轉目標和函數返回目標'
# "Enqueue and re-visit child loops in the loop PM after unrolling. This shouldn't typically be needed as child loops (or their clones) were already visited."
H26C9D96CFA95: '在循環PM中排程並重新訪問未展開的子循環。通常不需要此選項，因為子循環（或其副本）已遭訪問過。'
# 'Ensure that all functions can be hotpatched at runtime'
H2573A45755AF: '確保所有函數可在運行時進行熱修補'
# 'Ensure that llvm.experimental.noalias.scope.decl for identical scopes are not dominating'
H529A91904E5D: '確保相同作用域的llvm.experimental.noalias.scope.decl不會形成支配關係'
# 'Ensure that the global variables are in the global address space'
HE46C47C5C88F: '確保全域變數位於全域地址空間'
# "Ensures debug_value's that have been stackified become stack relative"
H7ED7A97DC8DC: '確保已轉換為堆疊的debug_value變數採用堆疊相對位址'
# 'Entry point name'
H289D7303E351: '入口點名稱'
# 'Entry point name for hlsl'
HE591D017B2D3: 'hlsl的入口點名稱'
# 'Enumerate different FRM and VXRM'
H01FEC6A04D14: '列舉不同的FRM和VXRM'
# 'Enumeration.'
H14D4DDE07BE9: '枚舉。'
# 'Enumerator.'
H1BB8B827F47C: '枚舉項。'
# 'Epilogue begin.'
HAB658397C42F: '尾序開始。'
# "Equivalent to '-mrecip=all'"
H732521E2A55F: "等同於 '-mrecip=all'"
# 'Equivalent to -march=mips1'
H7FC3E35D9090: '等同於 -march=mips1'
# 'Equivalent to -march=mips2'
HE867B04F1EDA: '等同於 -march=mips2'
# 'Equivalent to -march=mips3'
H2E91BF8C7F63: '等同於 -march=mips3'
# 'Equivalent to -march=mips32'
HD42FF697CA84: '等同於 -march=mips32'
# 'Equivalent to -march=mips32r2'
H1346CAA8E004: '等同於 -march=mips32r2'
# 'Equivalent to -march=mips32r3'
H1F78C0BD4227: '等同於 -march=mips32r3'
# 'Equivalent to -march=mips32r5'
H46694C52E140: '等同於 -march=mips32r5'
# 'Equivalent to -march=mips32r6'
H7EF21D815E8D: '等同於 -march=mips32r6'
# 'Equivalent to -march=mips4'
H28139C7F49F1: '等同於 -march=mips4'
# 'Equivalent to -march=mips5'
H677B666B87C9: '等同於 -march=mips5'
# 'Equivalent to -march=mips64'
H4A78C54743DE: '等同於 -march=mips64'
# 'Equivalent to -march=mips64r2'
HAA2577781717: '等同於 -march=mips64r2'
# 'Equivalent to -march=mips64r3'
H5285D4DA9B3F: '等同於 -march=mips64r3'
# 'Equivalent to -march=mips64r5'
H271253ED3AFA: '等同於 -march=mips64r5'
# 'Equivalent to -march=mips64r6'
H9AB4B9314716: '等同於 -march=mips64r6'
# 'Equivalent to -verify=expected'
H8E09CC7EDD92: '等同於 -verify=期望'
# 'Erase GP Operand'
HB8F1F7E9AA26: '錯誤說明解決方案 pass'
# 'Erase the existing functions'
H8F328C294A4D: '移除已存在的函數'
# 'Errata workaround pass'
H882D2A8DC3F5: '錯誤說明解決方案 pass'
# 'Error collecting HIP undefined fatbin symbols: %0'
H8A6EDE3371D0: '收集 HIP 未定義 fatbin 符號時發生錯誤：%0'
# 'Error for missing parenthesis around predicate registers'
H227937134E2E: '缺少謂詞寄存器周圍括號的錯誤'
# "Error for register names that aren't contigious"
H8D6DA19266F4: '寄存器名稱不連續的錯誤'
# 'Error in reading profile %0: %1'
H431D01FCD538: '讀取剖析 %0 時發生錯誤：%1'
# 'Error messages only'
H0A7E083717DD: '僅顯示錯誤訊息'
# 'Error on use'
HD221DA4D89E6: '使用時錯誤'
# 'Errors and warnings'
H2848EBF5EBC2: '錯誤與警告'
# 'Errors only'
H970D9ABE25E2: '僅錯誤'
# 'Errors, warnings and remarks'
HF85336965841: '錯誤、警告與建議'
# 'Evenly re-distribute flow among unknown subgraphs.'
H5604C90F2BE4: '在未知子圖間均勻重新分配流程。'
# 'Exact dependences without transitive dependences'
HA1B7947727A7: '不含傳遞依賴的精確依賴關係'
# 'Exception catch block.'
H6264B2F9B33C: '例外捕捉區塊。'
# 'Exception try block.'
H5C51BB50B6C6: '例外嘗試區塊。'
# 'Exclude compilands by regular expression'
HE55B6BA9D8DC: '透過正則表達式排除編譯單元'
# 'Exclude functions matching the filter from the output.'
H1D0BAA0AC132: '排除符合篩選條件的函數輸出。'
# 'Exclude sanitization for the top hottest code responsible for the given fraction of PGO counters (0.0 [default] = skip none; 1.0 = skip all). Argument format: <sanitizer1>=<value1>,<sanitizer2>=<value2>,...'
H7D028CB3230B: '根據給定的PGO計數器百分比，排除配置文件引導型優化(PGO)中最高熱點代碼的檢查(0.0[預設]=不跳過；1.0=跳過全部)。參數格式：<檢查器 1>=<值 1>,<檢查器 2>=<值 2>,...'
# 'Exclude symbols by regular expression'
H599455B9067B: '排除符合正則表達式之符號'
# 'Exclude types by regular expression'
H40334405F17A: '排除符合正則表達式之類型'
# 'Exclude wrong side overloads only if there are same side overloads in overloading resolution for CUDA/HIP'
H5AA1CC8C618A: '在CUDA/HIP重載解析時，若存在同一側重載則僅排除錯誤側重載'
# "Execute MCJIT'ed code in a separate process."
HC2E4E9BA2FB9: '在獨立進程中執行MCJIT化的程式碼。'
# 'Execute graph viewer in the background. Creates tmp file litter.'
HA7075AF10C7F: '在背景執行圖形查看器。會產生暫存檔碎片。'
# 'Execute with JIT'
HE5464053A6D4: '使用JIT執行'
# 'Execute with the interpreter'
HEC3165B8EAB3: '使用解譯器執行'
# 'Executes the snippets within the same process'
H22C3FC000703: '在同一進程中執行片段程式碼'
# 'Execution model (WebAssembly only)'
H41BAD8F12174: '執行模型（僅WebAssembly）'
# 'Exhaustive Search for registers bypassing the depth and interference cutoffs of last chance recoloring'
H3536DA79C20E: '透過最後機會重新著色的深度和干擾截止，進行繞過寄存器的详盡搜尋'
# 'Exit early if an unpredictable value come from the same loop'
H1F5EDB8C4566: '當不可預測的值來自同一迴圈時提前終止'
# 'Exit with an error when an instruction is unsupported for any reason (default)'
HDA0C7DD7EA63: '當任何原因導致指令不支援時以錯誤終止（預設）'
# 'Expand 64-bit division in AMDGPUCodeGenPrepare'
HEA34070476C9: '在AMDGPUCodeGenPrepare中展開 64 位元除法'
# 'Expand Atomic instructions'
H30D3E9ACF190: '展開原子指令'
# 'Expand certain fp instructions'
H98876AA7B147: '展開特定浮點運算指令'
# 'Expand constant expressions to instructions for testing purposes'
H9BED0D03A404: '為測試目的將常數運算式展開為指令'
# 'Expand double precision loads and stores to their single precision counterparts'
H09525D3EC7B4: '將雙精確度載入與儲存指令展開為對應的單精確度指令'
# 'Expand eligible cr-logical binary ops to branches'
H785023B9F185: '將合適的cr-邏輯二元運算子展開為分支'
# 'Expand fp'
H2ACDE0C56583: '展開 fp'
# 'Expand hlfir.matmul as elemental operation'
HB8FB6378B2A3: '將 hlfir.matmul 作為元素運算展開'
# 'Expand indirectbr instructions'
H0645EC041241: '展開 indirectbr 指令'
# 'Expand large div/rem'
H6BA324BB9D05: '展開大型 div/rem 運算'
# 'Expand macros without full preprocessing'
H13AAEB743C7B: '在完整預處理前展開宏'
# 'Expand memcmp() to load/stores'
H44E3E46EDFEB: '將 memcmp() 展開為 load/stores'
# 'Expand memcpy into load/store pairs in order'
H9B1207BABDAD: '依序將 memcpy 轉換為 load/store 配對'
# "Expand operand's MIOperandInfo DAG into suboperands"
H0AED692FCB12: '將操作元的 MIOperandInfo DAG 展開為子操作元'
# 'Expand out of range branch instructions and fix forbidden slot hazards'
HB54E4CE04809: '展開超出範圍的分支指令並修正禁止插槽的 hazard'
# 'Expand out of range branches'
H08752DCA250D: '展開超出範圍的分支指令'
# 'Expand reduction intrinsics'
H9287AE31FDD0: '展開約簡內建函數'
# 'Expand variadic functions'
HC0CCC1B4F1F9: '展開可變參數函數'
# 'Expect external char-aligned symbols to be without ABI alignment (SystemZ only)'
HEE285623EE10: 'Expect 外部以字元對齊的符號不具有 ABI 對齊（SystemZ 獨家功能）'
# 'Experimental pc tracing'
H45FAF05767D2: '實驗性程式計數器追蹤'
# 'Explain input dump and quit'
HB398CAAA9E7D: '說明輸入轉存並退出'
# 'Explain why a node was skipped (default=true)'
H51DC101E0A71: '說明為何節點被跳過（預設=true）'
# 'Explain why a pattern was skipped for inclusion in the GlobalISel selector'
HAC0A3B68049F: '說明為何某模式未被納入 GlobalISel 選取器'
# 'Exploit reductions in dependence analysis'
H76A87C10B6BB: '在依賴分析中利用約簡'
# 'Export debug info (by testing original Debug Info) failures into specified (JSON) file (should be abs path as we use append mode to insert new JSON objects).'
H632F15D60721: '將（通過測試原始除錯資訊）失敗的除錯資訊輸出到指定 JSON 檔案（應為絕對路徑，因我們使用追加模式插入新 JSON 物件）。'
# 'Export debug info preservation failures into specified (JSON) file (should be abs path as we use append mode to insert new JSON objects)'
HD135A5123609: '將除錯資訊保存失敗輸出到指定 JSON 檔案（應為絕對路徑，因我們使用追加模式插入新 JSON 物件）'
# 'Export full callsite graph'
H8538ECACAB5E: '輸出完整的呼叫點圖形'
# 'Export graph to dot files.'
H314220D2E444: '將圖形輸出為dot檔案。'
# 'Export only nodes with contexts feeding given -memprof-dot-alloc-id'
H11F3042B06F8: '僅輸出給定 -memprof-dot-alloc-id 所提供的上下文的節點'
# 'Export only nodes with given -memprof-dot-context-id'
H910BF34B1ED8: '僅輸出具有給定 -memprof-dot-context-id 的節點'
# 'Export only summary information for each source file'
HD9DCC346A6DB: '為每個來源檔案輸出摘要資訊'
# 'Export per-pass debugify statistics to this file'
H798BCDB12E0E: '將每個pass的debugify統計資料輸出至此檔案'
# 'Export the polyhedral description of the detected Scops'
H517A4767D0DE: '輸出檢測到的Scops的多面體描述'
# 'Export typeid resolutions to summary and globals'
H705A17261B58: '將typeid解析結果輸出至摘要和全域資料'
# 'Exporting options'
HA28E86F82A20: '輸出選項'
# 'Extend the -G behaviour to object local data (MIPS)'
H807C41A2617A: '將-G行為擴展至物件局部資料（MIPS）'
# 'Extend the liveness of user variables through optimizations to prevent stale or optimized-out variable values when debugging.'
HE9566864B09C: '在最佳化中延長使用者變數的有效性，以防止除錯時出現陳舊或被最佳化移除的變數值。'
# 'Extensible binary encoding'
H16E285BD9929: '可擴展的二進位編碼'
# 'Extensible binary encoding (default)'
HBCE99B0D176C: '可擴展的二進位編碼（預設）'
# 'External Alias Analysis'
H99D45183AADE: '外部別名分析'
# 'Externalize enqueued block runtime handles'
HD158E9A6F40A: '外部化已排入佇列的區塊執行階段句柄'
# 'Extra archive files to be loaded'
HD60827C100DD: '額外的存檔檔案要載入'
# 'Extra directory of include files'
H401E9781A70C: '額外的包含檔目錄'
# 'Extra modules to be loaded'
H4905A00383B5: '額外要載入的模組'
# 'Extra object files to be loaded'
HFBB158EB888B: '額外要載入的物件檔'
# 'Extract API information'
HAD16D93996E0: '提取API資訊'
# 'Extract HwModes-specific instructions into new DecoderTables, significantly reducing Table Duplications'
HF76D682A9D15: '將HwModes特定指令提取至新的DecoderTables，大幅減少表格重複'
# 'Extract at most one loop into a new function'
H2D39B07FBC4D: '最多將一個迴圈提取至新函數'
# 'Extract from <file>.'
H4A68D5BEAE14: '從 <file> 中提取。'
# 'Extract loops into new functions'
H053EB2868DBF: '將迴圈提取至新函數'
# 'FAILURE'
HF9C22E097EEB: '失敗'
# 'FILECHECK_OPTS'
H2A422AA39933: 'FILECHECK_OPTS'
# 'FIX-IT applied suggested code changes'
H19B769DF31D9: 'FIX-IT已套用建議的程式碼變更'
# 'FIX-IT detected an error it cannot fix'
HD809189A8863: 'FIX-IT偵測到一個無法修復的錯誤'
# 'FIX-IT detected errors it could not fix; no output will be generated'
HEE3E7F0F9BA0: 'FIX-IT偵測到無法修復的錯誤；不會產生輸出'
# 'FIX-IT unable to apply suggested code changes'
H2B4E9FB21753: 'FIX-IT無法套用建議的程式碼變更'
# 'FIX-IT unable to apply suggested code changes in a macro'
H3E3C2FB702A6: 'FIX-IT在宏中無法套用建議的程式碼變更'
# 'Factor for the unroll threshold to account for code simplifications still taking place'
HBD6D5665E545: '用於考慮仍在進行的程式碼簡化的展開閾值因素'
# 'Factor to apply to what qualifies as a long branch to reserve a pair of scalar registers. If this value is 0 the long branch registers are never reserved. As this value grows the greater chance the branch distance will fall within the threshold and the registers will be marked to be reserved. We lean towards always reserving a register for  long jumps'
H106A273943F9: '用於判斷何種長跳轉分支需要保留一對標量寄存器的係數。若此值為 0，則長跳轉寄存器永遠不會被保留。當此值增加時，跳轉距離落入閾值範圍內的機率越高，寄存器將被標記為保留。我們傾向於始終保留一個寄存器用於長跳轉'
# "Fail if an object couldn't be found for a binary ID in the profile"
H4235E7E596D5: '若剖析中的二進位ID無法找到對應物件時失敗'
# 'Fail if any profile is invalid.'
HFB8AB051E56E: '若任何剖析無效時失敗'
# 'Fail only if all profiles are invalid.'
HF5E080277997: '僅當所有剖析均無效時失敗'
# 'Failure mode:'
H1A58BCEE2CF5: '失敗模式:'
# 'Falkor HW Prefetch Fix'
H323CD584CC0F: 'Falkor硬體預取修正'
# 'Falkor HW Prefetch Fix Late Phase'
H682A690E57FE: 'Falkor硬體預取修正後期階段'
# 'Fallback style for reformatting after inserting new\nheaders if there is no clang-format config file found.'
H581E7F83176F: '若未找到clang-format設定檔，插入新標頭後重新格式化時的備用風格'
# 'Fallback to indirect when incorrect'
HD59C4BCB012E: '當不正確時切換為間接呼叫'
# 'Fast Register Allocator'
H749535234AA8: '快速暫存器配置器'
# 'Fast Tile Register Configure'
HE2B5F0EAEB3A: '快速磚塊暫存器配置'
# 'Fast Tile Register Preconfigure'
H049C9C8DDC88: '快速磚塊暫存器預配置'
# 'Fast register allocator'
H0FB6B67552E0: '快速暫存器配置器'
# 'Fast suboptimal list scheduling'
HE44BDB59069E: '快速次佳清單排程'
# 'Features to use to serialize to cubin.'
H480406601DAF: '用於序列化到cubin的特性。'
# 'File checksums (DEBUG_S_CHECKSUMS subsection)'
H0341151319EC: '檔案校驗和（DEBUG_S_CHECKSUMS子區段）'
# 'File containing RuntimeDyld verifier checks.'
H91AFD2697B81: '包含RuntimeDyld驗證器檢查的檔案。'
# 'File containing diagnostic suppression mappings. See user manual for file format.'
H65FE3D35314C: '包含診斷抑制對應的檔案。請參閱使用者手冊以了解檔案格式。'
# 'File containing entry point of the transform script, if different from the input file'
H6B64668AC58F: '如果與輸入檔案不同，則包含轉換腳本入口點的檔案'
# 'File containing verifier checks'
H4CA0F6F72C6E: '包含驗證器檢查的檔案'
# "File doesn't need an exec stack"
H9CC2858800DD: '此檔案不需要執行堆疊'
# 'File for serializing diagnostics in a binary format'
H94768CE895D7: '以二進位格式序列化診斷資訊的檔案'
# 'File holding the seed used by the randomize structure layout feature'
HE8D1A6EACA51: '保存用於隨機化結構布局功能的種子值的檔案'
# 'File is for a position independent executable'
HC6398B79E913: '此檔案是用於位置獨立可執行檔'
# 'File listing native ABI functions and how the pass treats them'
H779A21941187: '列出本機ABI函數及其在Pass中處理方式的檔案'
# 'File name to use for YAML optimization record output'
HDFBB63F1AC25: '用於YAML優化紀錄輸出的檔案名稱'
# 'File name to use for split dwarf debug info output'
H6FBC3D7AD088: '用於分割DWARF除錯資訊輸出的檔案名稱'
# 'File path for cold function only instrumentation(requires use with --pgo-instrument-cold-function-only)'
H833BBD566D2F: '僅對冷函數進行插樁的檔案路徑（需與--pgo-instrument-cold-function-only參數一同使用）'
# 'File path to where .cgdata file is read'
HD25E7479AD77: '要讀取 .cgdata 檔案的檔案路徑'
# 'File to append -stats and -timer output to'
H8C0548CC1115: '附加 -stats 和 -timer 輸出的檔案'
# 'File to check (defaults to stdin)'
H44D35D906559: '要檢查的檔案（預設為標準輸入）'
# 'File to emit dot graph of new summary into'
HB22275C53F6F: '要輸出新摘要的 dot 圖形檔案'
# 'File to read (analysis mode) or write (latency/uops/inverse_throughput modes) benchmark results. “-” uses stdin/stdout.'
H44970F94DF2D: '要讀取（分析模式）或寫入（延遲/uops/逆向吞吐量模式）的效能測試結果檔案。使用“-”表示使用標準輸入/輸出。'
# 'File to record the coroutines got elided'
H175805F86595: '記錄被省略的協程的檔案'
# 'File with the profile data obtained after an instrumented run'
HD4AF1660449E: '包含插樁執行後取得的剖析資料的檔案'
# 'File(s) containing definitions of additional transform script symbols'
HF1DBCA863288: '包含額外轉換腳本符號定義的檔案（可指定多個）'
# 'Filename (or -) to log diagnostics to'
HDACB45AABD12: 'Filename (或 -) 用於記錄診斷訊息'
# 'Filename (or -) to write dependency output to'
H8BC9F30BC52B: 'Filename ( 或 -) 用於輸出依賴關係'
# 'Filename (or -) to write header include output to'
H5BF600319EF5: 'Filename ( 或 -) 用於輸出標頭包含資訊'
# 'Filename (or -) to write stack usage output to'
H3BC188E55BBD: 'Filename ( 或 -) 用於輸出堆疊使用情況'
# 'Filename defining the list of functions/files to instrument. The file uses the sanitizer special case list format.'
HC15DFAEF876C: '定義要插樁的函數/檔案清單的檔案。此檔案使用 sanitizer 特殊案例清單格式。'
# 'Filename defining the list of functions/types for imbuing XRay attributes.'
H59E8B9411DF9: '定義要賦予 XRay 屬性的函數/類型清單的檔案'
# 'Filename to pipe in as stdin (default: /dev/null)'
HBE65800DDA37: '用作標準輸入的管道來源檔案（預設：/dev/null）'
# 'Filename to write DOT-formatted header dependencies to'
HA2996F065595: '輸出以 DOT 格式編寫的標頭依賴關係的檔案名稱'
# 'Filename to write statistics to'
HE239C00D43A5: '輸出統計資料的檔案名稱'
# 'Filename where the element is defined.'
H1FDF8DE162D7: '定義該元素的檔案名稱'
# 'Files referenced in the debug information.'
HBAB8680F7972: '在除錯資訊中引用的檔案'
# 'Fill Lanai delay slots with NOPs.'
H5DF685F1DB1E: '以 NOP 指令填滿 Lanai 延遲插槽'
# 'Fill a percentage of the latency between neighboring MFMA with s_nops.'
H17E41E561253: '以 s_nops 填補鄰近 MFMA 間的延遲百分比。'
# 'Fill all delay slots with NOPs.'
HDA6B69446833: '以 NOP 填滿所有延遲插槽。'
# 'Fill delay slot for MIPS'
HAFAF170DC965: '為 MIPS 延遲插槽填補'
# 'Filter all non-error diagnostics (discouraged: testing only!)'
H9EF0422D020C: '過濾所有非錯誤診斷訊息（不建議：僅限測試！）'
# 'Filter the benchmarks before analysing them'
H30E98BA4CBDB: '在分析之前篩選測試案例'
# 'Filtering and Sorting Options'
HAE5C92A1E57B: '篩選與排序選項'
# 'Finalize ISel and expand pseudo-instructions'
HAC66FC917CAA: '最終化 ISel 並展開偽指令'
# 'Finalize machine instruction bundles'
H54F93CB22051: '最終化機器指令包'
# 'Find methods that overrides a virtual method.'
H26E803BD2E38: '尋找覆寫虛函數的方法。'
# "Find objects in DIR or based on FILE's path"
H4D2FE19AC654: '根據目錄 DIR 或檔案路徑 FILE 進行物件搜尋'
# 'Find subclasses of a class.'
HC1D51E00B82D: '尋找某類別的子類別。'
# 'Fix copies between 32 and 16 bit registers by extending to 32 bit'
H2E54AD53EEA9: '透過延伸至 32 位元來修正 32 位元與 16 位元寄存器間的複製'
# 'Fix function entry count in profile use.'
H99125FC0562C: '修正剖析使用中的函數入口計數。'
# 'Fix mismatching bitcasts for WebAssembly'
H6D3A5F07020F: '修正 WebAssembly 的不匹配位轉換'
# 'Fixup Statepoint Caller Saved'
H2BF0C8053839: '修復 Statepoint 呼叫保存'
# 'Fixup each natural loop to have a single exit block'
H866DA2E73BC2: '修復每個自然迴圈使其具有單一退出區塊'
# 'Flatten the CFG'
H68BF16D61F64: '展平控制流圖（CFG）'
# 'Flow Sensitive profile file name.'
HD4BF3081650C: '資料流敏感剖析檔名稱。'
# 'Flow Sensitive profile remapping file name.'
H21713A45D881: '資料流敏感剖析重新映射檔名稱。'
# 'Flush denormal floating point values to zero in CUDA/HIP device mode.'
HF25D292D7C52: '在 CUDA/HIP 裝置模式下將非規格化浮點值強制轉換為零。'
# 'Fold memory accesses to model more possible delinearizations (does not scale well)'
HC5006CA24C2C: '合併記憶體存取以模擬更多可能的解除線性化（無法有效擴展）'
# 'Fold null checks into faulting memory operations'
HC5500C22FC68: '將空值檢查合併到導致錯誤的記憶體運算中'
# 'Folder name for view splitting.'
HE1AD57EFF1BD: '用於視圖分割的合併器名稱'
# 'Folds all regular instructions (including pre-outputs)'
HB765A3FB1AB5: '合併所有常規指令（包括預輸出）'
# 'Follow Fortran 2003 rules for (re)allocating the LHS of the intrinsic assignment'
H1CD29CD7E654: '遵循Fortran 2003 規則來（重新）分配內建賦值的左操作數（LHS）'
# 'Follow the AAPCS standard requirement stating that volatile bit-field width is dictated by the field container type. (ARM only).'
H318AB39D2C02: '遵循AAPCS標準要求，即volatile位段的寬度由該位段的容器類型決定。（僅限ARM）'
# 'Follows the AAPCS standard that all volatile bit-field write generates at least one load. (ARM only).'
HBE2099993756: '遵循AAPCS標準，所有volatile位段寫入操作至少會產生一次載入操作。（僅限ARM）'
# 'For -verify only: Inject a symbol into the extern symbol table.'
H691B584BF08D: '僅供-verify使用：將符號注入外部符號表'
# 'For -verify only: Map a section to a specific address.'
H943A8FBB7A51: '僅供-verify使用：將區段映射到特定位址'
# 'For -verify only: Separation between sections in phony target address space.'
HFFEB26CFD553: '僅供-verify使用：虛擬目標位址空間中區段間的分隔'
# 'For -verify only: end of phony target address range.'
H2C3EAFFA8499: '僅供-verify使用：虛擬目標位址範圍的結尾'
# 'For -verify only: start of phony target address range.'
H1B0A5AC1E801: '僅供-verify使用：虛擬目標位址範圍的起始'
# 'For MachO, disable atexit()-based global destructor lowering'
HFC5FF11ED2AC: '對MachO，禁用基於atexit()的全域析構函數降級處理'
# 'For a large interval, if it is coalesced with other live intervals many times more than the threshold, stop its coalescing to control the compile time. '
H31454C2664AA: '若某大區間與其他活躍區間的合併次數超過閾值多倍，則停止其合併以控制編譯時間'
# "For a list of available CPUs for the target use '-mcpu=help'"
HFB257544DEA1: "如需列出目標支援的CPU清單，請使用 '-mcpu=help'"
# "For a list of available architectures for the target use '-mcpu=help'"
HCFFD910F1E45: "如需列出目標支援的架構清單，請使用 '-mcpu=help'"
# 'For all options that iterate over modules, ignore modules from system libraries'
HF30AFF2F9F8C: '對所有需遍歷模組的選項，忽略系統函式庫的模組'
# 'For all options that iterate over modules, limit to the specified module'
H076A99AD2B76: '對所有需遍歷模組的選項，僅限指定的模組'
# 'For cold function instrumentation, skip instrumenting functions whose entry count is above the given value.'
HE6D6C775176E: '對冷函數插樿時，跳過那些入口計數超過指定值的函數'
# 'For cold function instrumentation, treat count unknown(e.g. unprofiled) functions as cold.'
H063B03A52387: '對冷函數插樿時，將計數未知（例如未被剖析）的函數視為冷函數'
# 'For context sensitive PGO counts. Does not work with CSSPGO.'
HBBB3E8C601A8: '用於上下文敏感的配置文件引導型優化計數。不支援與 CSSPGO 一同使用。'
# 'For each function, emit a dot graph depicting potential LVI gadgets'
H57E599CB6769: '對每個函數，產生顯示潛在 LVI 設備的 dot 圖表'
# 'For each function, emit a dot graph depicting potential LVI gadgets, and do not insert any fences'
HAC353EF77E07: '對每個函數，產生顯示潛在 LVI 設備的 dot 圖表，並不會插入任何屏障指令'
# 'For each function, emit a dot graph to stdout depicting potential LVI gadgets, used for testing purposes only'
H3C8BB209ABDE: '對每個函數，將顯示潛在 LVI 設備的 dot 圖表輸出至標準輸出，僅用於測試目的'
# 'For merge, use the provided unstripped binary to correlate the raw profile.'
H5C641C769774: '在合併時，使用提供的未裁剪二進位檔來關聯原始剖析資料。'
# 'For partially supported constructs, emit `[first]private` variables as clauses on the MLIR ops.'
H6182FD8E07DA: '對部分支援的語法結構，將 `[first]private` 變數作為 MLIR 運算子的子句發出。'
# 'For paths in debug info, remap directory <old> to <new>. If multiple options match a path, the last option wins'
H3D3679C30C18: '對調試資訊中的路徑，將目錄 <old> 重新映射為 <new>。若多個選項匹配同一個路徑，則最後一個選項優先'
# 'For sample profiles, list function names (with calling context for csspgo) for overlapped functions with similarities below the cutoff (percentage times 10000).'
H463D2852BF2F: '對樣本剖析資料，列出重疊函數中相似度低於閾值（百分比乘以 10000）的函數名稱（包含 CSSPGO 的呼叫上下文）'
# 'For shared library loaded with the main program, change local-dynamic access(es) to initial-exec access(es) at the function level (AIX 64-bit only).'
HD94E43E648D1: '對與主程式一同加載的共用函式庫，在函數層級將本地動態存取轉換為初始執行存取（僅限 AIX 64 位元）'
# 'For show, read and extract profile metadata from debug info and show the functions it found. For merge, use the provided debug info to correlate the raw profile.'
H3F78033E8267: '在顯示模式下，讀取並提取調試資訊中的剖析元資料並顯示找到的函數。在合併模式下，使用提供的調試資訊來關聯原始剖析資料'
# 'For symbols in profile symbol list, regard their profiles to be accurate. It may be overridden by profile-sample-accurate. '
H960468D026B4: '對剖析符號清單中的符號，視其剖析資料為精確的。此設定可能被 profile-sample-accurate 覆蓋。'
# "For test - keep the ML Inline advisor's FunctionPropertiesInfo cache"
H68E3D966BDA0: '用於測試 - 保留 ML Inline Advisor 的 FunctionPropertiesInfo 快取'
# "For testing purposes, always break large PHIs even if it isn't profitable."
H0BECF527CC8D: '用於測試目的，即使無利可圖時也強制拆解大型 PHI 鐵桿'
# 'For the function which is cold in instr profile but hot in sample profile, if the ratio of the number of zero counters divided by the total number of counters is above the threshold, the profile of the function will be regarded as being harmful for performance and will be dropped.'
H326030B813BD: '若函數在插樁剖析中為冷卻狀態但在樣本剖析中熱門，且零計數器數量與總計數器數量的比率超過閾值，則此函數的剖析資料將被視為對效能有害而被捨棄'
# 'For the module ID for the file to process, useful to match what is in the index.'
HB6A96C6D31C3: '用於匹配索引中內容的檔案處理模組識別碼'
# 'For use with /winsysroot, defaults to newest found'
H9FFDA74D3CE8: '與 /winsysroot 一同使用，預設採用最新找到的版本'
# 'Force a peel count regardless of profiling information.'
H6BA57EBF2817: '不論剖析資訊如何，強制指定迴圈展開次數。'
# 'Force a specific generic_v<N> flag to be added. For testing purposes only.'
H12597D7C787F: '強制添加特定 generic_v<N> 標誌。僅用於測試目的。'
# 'Force align the stack to the minimum alignment'
H6ABD893EDD1A: '強制將堆疊對齊至最小對齊值'
# 'Force all edges in the function summary to cold'
HF7516A69CF5A: '將函數摘要中的所有邊設為冷卻狀態'
# 'Force all functions to be noinline'
HB0A34849A65E: '強制所有函數為noinline'
# 'Force all indexed operations to be legal for the GlobalISel combiner'
H8B4D9E88A547: '強制所有索引運算在GlobalISel組合器中合法'
# 'Force all memory accesses to be aligned (AArch32/MIPSr6 only)'
HB9DB3E9A0275: '強制所有記憶體存取對齊（僅限AArch32/MIPSr6）'
# 'Force all memory accesses to be aligned (AArch64/LoongArch/RISC-V only)'
H592DBE5D5A8A: '強制所有記憶體存取對齊（僅限AArch64/LoongArch/RISC-V）'
# 'Force all scalar memory accesses to be aligned (RISC-V only)'
H47C5C3723D44: '強制所有標量記憶體存取對齊（僅限RISC-V）'
# 'Force all vector memory accesses to be aligned (RISC-V only)'
H8477BA8471BC: '強制所有向量記憶體存取對齊（僅限RISC-V）'
# 'Force all waitcnt instrs to be emitted as s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)'
H687C328A88F2: '強制所有waitcnt指令發出為s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)'
# 'Force all waitcnt load counters to wait until 0'
H896788DC2080: '強制所有waitcnt載入計數器等待至 0'
# 'Force allowance of nested hardware loops'
HAD8E45F66910: '強制允許巢狀硬體迴圈'
# 'Force analysis to continue in the presence of unsupported instructions'
H0386966E38DA: '強制在存在不受支援指令時繼續分析'
# 'Force behavior as if the user specified pragma omp requires unified_shared_memory.'
H0D0C1138BD58: '強制行為如同使用者指定pragma omp requires unified_shared_memory'
# 'Force bidirectional post reg-alloc list scheduling'
H2AB733A479DE: '強制使用寄存器分配後的雙向清單排程'
# 'Force bidirectional pre reg-alloc list scheduling'
H9527EDFB6708: '強制使用寄存器分配前的雙向清單排程'
# 'Force bottom-up post reg-alloc list scheduling'
HC9A155CC7DD9: '強制使用寄存器分配後的自底向上清單排程'
# 'Force bottom-up pre reg-alloc list scheduling'
HD5FFAD3EC478: '強制使用寄存器分配前的自底向上清單排程'
# 'Force codegen to assume rounding mode can change dynamically'
H5694C07468F1: '強制codegen假設捨入模式可能動態改變'
# 'Force disable the lazy-loading on-demand of metadata when loading bitcode for importing.'
H2329A45D867C: '強制禁用載入用於匯入的bitcode時的metadata惰性載入'
# 'Force double to be <n> bits'
H6A3CAE57D5DB: '強制將double設為 <n> 位元'
# 'Force each unsigned fixed point type to have an extra bit of padding to align their scales with those of signed fixed point types'
H2DB086248971: '強制每個無符號固定點類型額外有一個填充位元以使其尺度與有符號固定點類型對齊'
# 'Force emit s_waitcnt expcnt(0) instrs'
H88E5FE04F072: '強制發出s_waitcnt expcnt(0)指令'
# 'Force emit s_waitcnt lgkmcnt(0) instrs'
HE8A3AAF43D8E: '強制發射 s_waitcnt lgkmcnt(0) 指令'
# 'Force emit s_waitcnt vmcnt(0) instrs'
H38DB94C17996: '強制發射 s_waitcnt vmcnt(0) 指令'
# 'Force enable speculative execution side effect suppression. (Note: User must pass -mlvi-cfi in order to mitigate indirect branches and returns.)'
H5C45F8896F6A: '強制啟用預測執行副作用抑制。（注意：使用者必須傳遞 -mlvi-cfi 參數以緩解間接跳轉和返回。）'
# 'Force enable speculative load hardening'
HE35AC46B0548: '強制啟用預測載入強化'
# 'Force function reduction to keep main'
H0BB63C069108: '強制減少函數以保留main函數'
# 'Force function specialization for every call site with a constant argument'
H16827AFD0E0F: '強制針對每個具有常數參數的呼叫位置進行函數專門化'
# 'Force function to be mips32'
H47CC37388F1A: '強制函數使用mips32架構'
# 'Force generation of loop guard intrinsic'
H660425C561DD: '強制生成迴圈守護內建函數'
# 'Force generation of thread parallel code ignoring any cost model'
HD5652803169B: '強制生成忽略任何成本模型的執行緒平行程式碼'
# 'Force hardware loop counter to be updated through a phi'
H6034A18A690A: '強制透過phi節點更新硬體迴圈計數器'
# 'Force hardware loops intrinsics to be inserted'
H526108F8C3D0: '強制插入硬體迴圈內建函數'
# 'Force interpretation: disable JIT'
HE0B08266ED91: '強制使用解釋模式：停用JIT'
# 'Force linking the clang builtins runtime library'
H602A2DB51D2C: '強制連結clang內建執行時期函式庫'
# 'Force long double to be 128 bits'
HF5330D6B0F62: '強制long double為 128 位元'
# 'Force long double to be 64 bits'
HF1CEF43473D8: '強制long double為 64 位元'
# 'Force long double to be 80 bits, padded to 128 bits for storage'
H2FBC78A0A1C7: '強制long double為 80 位元，並填充至 128 位元以進行儲存'
# 'Force machine combiner to use a specific strategy for machine trace metrics evaluation.'
H8D7274D95AD0: '強制機器組合器使用特定策略進行機器跡象指標評估。'
# 'Force matrix instruction fusion even if not profitable.'
HABD067814D75: '即使不利，仍強制融合矩陣指令。'
# 'Force optimization experiment (for testing)'
H23001FDFF697: '強制啟用最佳化實驗（僅供測試）'
# 'Force outline regions with live exits'
H13A02DD93B7D: '強制外提具有活躍出口的區域'
# 'Force outlining cold blocks from loops.'
H04711024D9E9: '強制從循環中提取冷區塊。'
# 'Force pipeliner to use specified II.'
H17E89A49B48C: '強制管線使用指定的II。'
# 'Force pipeliner to use specified issue width.'
HA8DD64472E32: '強制管線使用指定的發行寬度。'
# 'Force realign the stack at entry to every function'
H31A8B99D0D70: '強制在每個函數的進入點重新對齊堆疊'
# 'Force store splitting no matter what the target query says.'
H7A397BF735D5: '無論目標查詢結果如何，強制進行存儲分割。'
# 'Force the (profiled-guided) size optimizations. '
HA4B424DB2FF9: '強制執行（配置文件引導型）大小優化。'
# 'Force the alignment of all blocks in the function in log2 format (e.g 4 means align on 16B boundaries).'
HB1C496FAEC2F: '以log2格式強制對齊函數內的所有區塊（例如 4 表示對齊到 16B邊界）。'
# "Force the alignment of all blocks that have no fall-through predecessors (i.e. don't add nops that are executed). In log2 format (e.g 4 means align on 16B boundaries)."
HEC173CEDA264: '強制對齊所有沒有跳轉前驅節點的區塊（即不添加執行時的nops）。以log2格式（例如 4 表示對齊到 16B邊界）。'
# 'Force the alignment of all functions in log2 format (e.g. 4 means align on 16B boundaries).'
HAC694582BD7C: '以log2格式強制對齊所有函數（例如 4 表示對齊到 16B邊界）。'
# 'Force the interpretation of -stream as a string, even if it is a valid integer'
HD1DE45392158: '即使-stream是有效的整數，也強制將其解析為字串。'
# 'Force the static analyzer to analyze functions defined in header files'
HAB6B5ACFD382: '強制靜態分析器分析在頭檔中定義的函數'
# 'Force the tail folding style'
HA1C7FE88ED1D: '強制使用尾端摺疊風格。'
# 'Force the use of a base pointer in every function'
HBE1018F652C4: '強制在每個函數中使用基底指標。'
# 'Force the use of precise cost loop rotation strategy.'
HEC5F52CCB084: '強制使用精確成本的循環旋轉策略。'
# 'Force the use of resource intervals in the schedule model'
HC146F04B90B5: '強制在排程模型中使用資源區間。'
# 'Force the use of streaming code for all functions'
H9D121C14481F: '強制所有函數使用串流代碼。'
# 'Force the use of streaming-compatible code for all functions'
H3939F502979A: '強制所有函數使用與串流相容的代碼。'
# 'Force thread model single in LICM pass'
H95CEFB645311: '在LICM pass中強制使用單一執行緒模型。'
# 'Force to instrument function entry basicblock.'
HCB64281E774F: '強制對函數進入的基本區塊進行插樁。'
# 'Force to instrument loop entries.'
H3FF84C8727C9: '強制對循環進入點進行插樁。'
# 'Force top-down post reg-alloc list scheduling'
H624C5BFC69FE: '强制在寄存器分配後使用自頂向下列表排程'
# 'Force top-down pre reg-alloc list scheduling'
HF7823207CF83: '强制在寄存器分配前使用自頂向下列表排程'
# 'Force use of AdvSIMD scalar instructions everywhere'
H5BE24FD8EC8D: '强制在所有地方使用AdvSIMD純量指令'
# 'Force using MLIR complex operations instead of libm complex operations'
HE874B9895802: '强制使用MLIR複雜運算而非libm的複雜運算'
# 'Force wchar_t to be a short unsigned int'
H344B5212E317: '强制將wchar_t定義為unsigned short int'
# 'Force wchar_t to be an unsigned int'
H43342C927949: '强制將wchar_t定義為unsigned int'
# 'Force whether the StructurizeCFG pass skips uniform regions'
H1E4EFD3EA072: '强制StructurizeCFG pass是否跳過均勻區域'
# 'Forces the maximum bytes allowed to be emitted when padding for alignment'
H3B4D326FCA22: '强制設定對齊填充時允許發射的最大位元組數'
# 'Forcibly enables non-trivial loop unswitching rather than following the configuration passed into the pass.'
H2E9D92A16FC3: '强制啟用非平凡的迴圈拆分，而不是遵循傳遞給pass的配置。'
# 'Forget everything in SCEV when doing LoopUnroll, instead of just the current top-most loop. This is sometimes preferred to reduce compile time.'
HDBEAD86F6F49: '在進行LoopUnroll時，遺忘SCEV中的所有資訊，而不仅仅是目前最外層的迴圈。這有時能減少編譯時間。'
# 'Form fused FP ops (e.g. FMAs)'
H88EF5D85058D: '建立融合浮點運算（例如FMAs）'
# 'Format a range of this length (in bytes).\nMultiple ranges can be formatted by specifying\nseveral -offset and -length pairs.\nWhen only a single -offset is specified without\n-length, clang-format will format up to the end\nof the file.\nCan only be used with one input file.'
H93D871018723: '格式化此長度（以位元組為單位）的範圍。\n可指定多個-offset和-length參數來格式化多個範圍。\n若只指定單一-offset而未指定-length，clang-format將格式化至檔案結尾。\n僅能用於單一輸入檔案。'
# 'Format a range starting at this byte offset.\nMultiple ranges can be formatted by specifying\nseveral -offset and -length pairs.\nCan only be used with one input file.'
H28E3CD62FED9: '從此位元組偏移量開始格式化。\n可指定多個-offset和-length參數來格式化多個範圍。\n僅能用於單一輸入檔案。'
# "Format consumable by Brendan Gregg's FlameGraph tool. Only valid with -all-stacks."
HE769F9BDFBAB: 'Brendan Gregg FlameGraph工具可解析的格式。僅與-all-stacks參數併用時有效。'
# 'Format for outputted docs.'
HC5A8B725033A: '輸出文件的格式'
# 'Format message diagnostics so that they fit within N columns'
H5F2F2FEC74C8: '格式化診斷訊息使其適配N欄寬度'
# 'Format of index export'
H9AED5C1C80E8: '索引匯出的格式'
# 'Format of output profile'
HAE3C92A81F31: '輸出剖析的格式'
# 'Format of the index to be written'
H036107DC230C: '要寫入的索引格式'
# 'Formatting Options'
H7C2DC2E6B392: '格式化選項'
# 'Forward options to the linker'
H0E5969703D2A: '將選項轉送給鏈接器'
# 'Forward switch condition to phi ops (default = false)'
HB7C76B2E6FA2: '轉送switch條件到phi操作（預設值=false）'
# 'Four-byte version string for gcov files.'
H32782AC0D44C: 'gcov檔案的 4 字節版本字串。'
# 'Frame Data (DEBUG_S_FRAMEDATA subsection)'
H4EACA6AC6ABA: '框架資料（DEBUG_S_FRAMEDATA子區段）'
# 'Fuchsia API Level prohibits specifying a minor or sub-minor version'
H73A16BC6357D: 'Fuchsia API等級禁止指定次版本或次次版本'
# 'Full version of the Windows SDK, defaults to newest found'
HD00F6CBB0217: 'Windows SDK的完整版本（預設為找到的最新版本）'
# 'Fully encode c++ class template specialization'
H83B6D3243278: '完整編碼C++類模板特化'
# 'Fully expand the memory accesses of the detected Scops'
H41926418D084: '完整展開檢測到的Scops的記憶體存取'
# 'Fully relocatable, position independent code'
H2EE1300E53E0: '完全可重新定位，位置獨立代碼'
# 'Function Alias Analysis Results'
H5E305706D9B2: '函式別名分析結果'
# 'Function Entry Count'
HF80E7DCD1642: '函式入口計數'
# 'Function attribute to apply to cold functions as determined by PGO'
H345451AD326B: '根據PGO決定的冷函式所套用的函式屬性'
# 'Function entry point.'
HAD67FD8DA947: '函式入口點。'
# 'Function filtering options'
H71383E432CB7: '函式篩選選項'
# 'Function level overlap information for every function (with calling context for csspgo) in test profile with max count value greater than the parameter value'
H66ADA33E3E20: '在測試剖面中，每個函式（具有csspgo的呼叫上下文）的函式層級覆疊資訊，其最大計數值大於參數值'
# 'Function mem bound threshold in %'
HC48D6911C0B3: '函式記憶體限制閾值（百分比）'
# 'Function names that are public.'
H1CBBD51F21AA: '公開的函式名稱。'
# 'Function number to canonicalize.'
H14E5011F4FDD: '要規範化的函式編號。'
# 'Function register usage analysis'
HC45FBE8F1495: '函式寄存器使用分析'
# 'Function to call as entry point.'
H9A688E8595B8: '用作入口點的函式。'
# 'Function type.'
HC8800532CD60: '函數類型。'
# 'Function.'
H7375AFF85987: '函數。'
# 'Fuse FP ops whenever profitable'
H9F1BE3BC2E20: '在有利時融合浮點運算'
# 'GC Lowering'
HB5C53C8FC4DB: 'GC 降階'
# 'GCC does not allow %0 attribute in this position on a function definition'
H6258B157AA4F: 'GCC 不允許在函數定義的此位置使用 %0 屬性'
# 'GCC does not allow an attribute in this position on a function declaration'
H6328F86D9296: 'GCC 不允許在函數宣告的此位置使用屬性'
# 'GCC does not allow the %0 attribute to be written on a type'
HAF18361FDD0D: 'GCC 不允許將 %0 屬性寫在類型上'
# "GCC does not allow the 'cleanup' attribute argument to be anything other than a simple identifier"
HB0EE895D3D5D: "GCC 不允許 'cleanup' 屬性參數為非簡單識別符"
# 'GCC does not allow variable declarations in for loop initializers before C99'
HD212EAC451BD: '在 C99 之前，GCC 不允許在 for 迴圈初始值設定中宣告變數'
# 'GCC encoding (only meaningful for -sample)'
H893D2EDBC511: 'GCC 編碼（僅在使用 -sample 時有意義）'
# 'GCC requires a function with the %0 attribute to be variadic'
H4044A123EF83: 'GCC 需要具有 %0 屬性的函數為可變參數函數'
# 'GCN Create VOPD Instructions'
HD50B13295BAC: 'GCN 建立 VOPD 指令'
# 'GCN DPP Combine'
H19E8A5665832: 'GCN DPP 組合'
# 'GCN NSA Reassign'
H506D8BF350C1: 'GCN NSA 重新指定'
# 'GLIBC Vector Math library'
HFDA2A482B5C5: 'GLIBC 向量數學函式庫'
# 'GNU OpenMP'
H7F5648C19468: 'GNU OpenMP'
# 'GNU decimal type extension not supported'
HE1719E002830: '未支援 GNU 十進位類型擴充'
# 'GNU vector conditional operand cannot be %select{void|a throw expression}0'
H5DF13110207F: 'GNU 向量條件式運算元不能是 %select{void|throw 表達式}0'
# 'GNU-style inline assembly is disabled'
H2E56E6455BF0: '已停用 GNU 程式碼內嵌組合語言'
# 'GNUstep Objective-C runtime version %0 incompatible with target binary format'
HBFB3FAB065B9: 'GNUstep Objective-C 執行階段版本 %0 不相容於目標二進位格式'
# "GPU arch %0 is supported by CUDA versions between %1 and %2 (inclusive), but installation at %3 is %4; use '--cuda-path' to specify a different CUDA install, pass a different GPU arch with '--cuda-gpu-arch', or pass '--no-cuda-version-check'"
HA444373A0822: "CUDA 版本 %1 到 %2（含）支援 GPU 架構 %0，但安裝路徑 %3 為 %4；請使用 '--cuda-path' 指定不同的 CUDA 安裝位置，或通過 '--cuda-gpu-arch' 指定其他 GPU 架構，或傳遞 '--no-cuda-version-check'"
# 'Gang up loads and stores generated by inlining of memcpy'
HE535C0271E93: '由 memcpy 內联生成的合併載入和儲存指令'
# 'Gate the invocation of the tracing callbacks on a global variable. Currently only supported for trace-pc-guard and trace-cmp.'
HE7375E04E4A1: '根據全域變數啟用追蹤回呼函數的調用。目前僅支援 trace-pc-guard 和 trace-cmp。'
# 'Generalize pointers in CFI indirect call type signature checks'
H05CAF1DC1C80: '在 CFI 間接呼叫類型簽章檢查中泛化指標'
# 'Generate "extract" instructions'
HC571F6794268: '生成「extract」指令'
# 'Generate "insert" instructions'
H783E8CF7431F: '生成「insert」指令'
# 'Generate ARM CDE builtin code-generator for clang'
H5A5EC1A5B6C3: '為 clang 生成 ARM CDE 內建程式碼生成器'
# 'Generate ARM CDE builtin definitions for clang'
H4D955CE0B09F: '為 clang 生成 ARM CDE 內建定義'
# 'Generate ARM CDE builtin sema checks for clang'
H322C3CB145B5: '為 clang 生成 ARM CDE 內建語法檢查'
# 'Generate ARM MVE builtin code-generator for clang'
H51464E4006BA: '為 clang 生成 ARM MVE 內建程式碼生成器'
# 'Generate ARM MVE builtin definitions for clang'
HB30829C9D62F: '為 clang 生成 ARM MVE 內建定義'
# 'Generate ARM MVE builtin sema checks for clang'
H9EB24BD38363: '為 clang 生成 ARM MVE 內建語法檢查'
# 'Generate ARM NEON sema support for clang'
HB47F65A392BE: '為 clang 生成 ARM NEON 語法支援'
# 'Generate ARM NEON tests for clang'
HB3324D2A49FC: '為 clang 生成 ARM NEON 測試案例'
# 'Generate AST expressions for unmodified and modified accesses'
H729F2BA5C5BE: '生成未修飾與已修飾存取的 AST 表達式'
# 'Generate C++20 header units from header files'
H8199E8EA3A2D: '從頭檔檔案生成 C++20 頭檔單元'
# 'Generate CXX11 attributes info'
H008C47C9924C: '生成 C++11 屬性資訊'
# 'Generate Clang AST comment nodes'
H1A2137DB81DD: '生成 Clang AST 註解節點'
# 'Generate Clang AST declaration nodes'
H0D831097F249: '生成 Clang AST 宣告節點'
# 'Generate Clang AST statement nodes'
H9DA2A7F822D1: '生成 Clang AST 語句節點'
# 'Generate Clang AST type nodes'
H6C40DA5710E5: '產生 Clang AST 類型節點'
# 'Generate Clang AbstractTypeReader class'
H0B517D2DC9BE: '產生 Clang AbstractTypeReader 類別'
# 'Generate Clang AbstractTypeWriter class'
H3C1A155F700F: '產生 Clang AbstractTypeWriter 類別'
# 'Generate Clang BasicReader classes'
HCAC9D912FD7C: '產生 Clang BasicReader 類別'
# 'Generate Clang BasicWriter classes'
H7777A854222B: '產生 Clang BasicWriter 類別'
# 'Generate Clang Static Analyzer checkers'
HAF44CF1570A7: '產生 Clang 靜態分析器檢查器'
# 'Generate Clang constexpr interpreter opcodes'
HCE00FBA3D9DA: '產生 Clang constexpr 解譯器操作碼'
# 'Generate Clang diagnostic enums for selects'
HFF484ABCD39B: '為選擇項產生 Clang 診斷枚舉值'
# 'Generate Clang diagnostic groups'
HD491E8E3F838: '產生 Clang 診斷群組'
# 'Generate Clang diagnostic name index'
H26D83AD60FA3: '產生 Clang 診斷名稱索引'
# 'Generate Clang diagnostics definitions'
H42FB0D88C678: '產生 Clang 診斷定義'
# 'Generate CodeView debug information'
H5E04C2FAE7DA: '產生 CodeView 調試資訊'
# 'Generate DWARF4 type units.'
H93A2FEDB326C: '產生 DWARF4 類型單位。'
# 'Generate Extract API information as a side effect of compilation.'
H35927234EEF2: '在編譯的副作用中提取 API 資訊。'
# 'Generate IR involving scalable vector types'
HBFD721B3719E: '產生涉及可擴展向量類型的 IR'
# 'Generate Interface Stub Files, emit merged text not binary.'
H48D6D551365C: '產生介面存根文件，發出合併的文本而非二進位檔。'
# 'Generate Interface Stub Files.'
H93E694C37FB8: '產生介面存根文件。'
# 'Generate LBR info with perf itrace argument'
H63A1CBFF2B95: '使用 perf itrace 參數產生 LBR 資訊'
# 'Generate M NOPs before function entry'
H411052747AED: '在函數入口前產生 M 個 NOP 指令'
# 'Generate M NOPs before function entry and N-M NOPs after function entry'
HCAAC0B0CBF62: '在函數入口前產生 M 個 NOP 指令，以及入口後產生 N-M 個 NOP 指令'
# 'Generate Metal library'
H30181B8F806A: '產生Metal函式庫'
# 'Generate Offload API header contents'
H228CB18FCD9A: '產生Offload API標頭內容'
# 'Generate Offload API print header'
HDB1F685BA2FE: '產生Offload API列印標頭'
# 'Generate Offload API wrapper function definitions'
HE6C5D6F8A8FB: '產生Offload API包裹函數定義'
# 'Generate OpenCL builtin declaration handlers'
HA18DDE5AEDF3: '產生OpenCL內建宣告處理器'
# 'Generate OpenCL builtin declaration tests'
H5DAE86CEEBCA: '產生OpenCL內建宣告測試'
# 'Generate OpenCL builtin header'
H2590CD761606: '產生OpenCL內建標頭'
# 'Generate SPIR-V code'
HC1B38B428E45: '產生SPIR-V程式碼'
# 'Generate Scalar MASS entries'
H428973D80E2B: '產生Scalar MASS條目'
# 'Generate XRay instrumentation sleds on function entry and exit'
H3016D234FBA9: '在函數進入和退出時生成XRay插樁滑橇'
# 'Generate a .mlir reproducer file at the given output path if the pass manager crashes or fails'
HBC83C0234127: '如果Pass管理員當機或失敗，則在指定的輸出路徑產生.mlir重現檔'
# 'Generate a YAML optimization record file'
H1942B716CF27: '產生YAML最佳化紀錄檔'
# 'Generate a __mcount_loc section entry for each __fentry__ call.'
HE460D06CF31F: '為每個__fentry__呼叫產生__mcount_loc區段條目。'
# 'Generate a clang attribute list'
H89A583ECD8F5: '生成clang屬性清單'
# 'Generate a clang attribute spelling index'
HE19534D90FCA: '生成clang屬性拼寫索引'
# 'Generate a clang attribute spelling list'
H4F8740D65FE7: '生成clang屬性拼寫清單'
# 'Generate a clang attribute subject match rule list'
HC95A81873DA9: '生成clang屬性主題匹配規則清單'
# 'Generate a clang parsed attribute kinds'
H78888371BD55: '生成clang已解析的屬性類型'
# 'Generate a clang parsed attribute list'
HD97B596A50F3: '生成clang已解析的屬性清單'
# 'Generate a clang template instantiate code'
H961D4AD666CA: '生成clang範本實體化程式碼'
# 'Generate a list of all Offload API function names'
H3DB190C217E7: '生成所有Offload API函數名稱清單'
# 'Generate a list of attributes supported by #pragma clang attribute for testing purposes'
HE3D52A2C4CA9: '生成由#pragma clang attribute支援的測試用途屬性清單'
# 'Generate a list of regular keyword attributes with info about their arguments'
H86F657FC95B7: '生成包含參數資訊的常規關鍵字屬性清單'
# 'Generate a partial profile (only meaningful for -extbinary)'
H8B3C403992F1: '生成部分剖析（僅對-extbinary有意義）'
# 'Generate a pch file for all code up to and including <filename>'
H3A6818A5EE16: '生成包含所有程式碼直至指定 <filename> 的pch檔案'
# 'Generate a recursive AST visitor for clang attributes'
HD2CD27931B90: '生成clang屬性遞迴AST訪問器'
# 'Generate a sparse profile (only meaningful for -instr)'
H2390B2DEB1A2: '生成稀疏剖析（僅對-instr有意義）'
# 'Generate a table of attribute documentation'
H4075E225B4D0: '生成屬性文件說明表格'
# 'Generate absolute set instructions'
HD09B902A76CD: '生成絕對設置指令'
# 'Generate additional symbol graphs for extended modules.'
H621EAE5CB426: '為擴展模組生成額外符號圖'
# 'Generate all instruction with TC'
HCB4E103EFF3E: '生成所有TC指令'
# 'Generate all parser-related attribute string switches'
HBC7D18EAD0C4: '生成所有與解析器相關的屬性字串切換'
# 'Generate all parser-related attribute subject match rulestring switches'
H3DDA6CE234B8: '生成所有與解析器相關的屬性主題匹配規則字串切換'
# 'Generate all reports.'
H56F361794B7A: '產生所有報告。'
# 'Generate an mlir reproducer at the provided filename (no crash required)'
HEF652CF84C8A: '在指定的檔案名稱處生成mlir重現檔（無需程式崩潰）'
# 'Generate an optimization record file in a specific format'
H93DDC23AE075: '以特定格式生成優化記錄檔'
# 'Generate an optimized version of the match table'
HB99621634FE9: '產生優化過的匹配表版本'
# 'Generate any type of IT block'
H3521C624C6E3: '生成任何類型的IT區塊'
# 'Generate arm_bf16.h for clang'
H4049A4CCEEB2: '為clang生成arm_bf16.h'
# 'Generate arm_cde.h for clang'
H20C9AE949999: '為clang生成arm_cde.h'
# 'Generate arm_fp16.h for clang'
HA003409EA627: '為clang生成arm_fp16.h'
# 'Generate arm_immcheck_types.inc (immediate range check types) for clang'
H3E399A3BC5ED: '為clang生成arm_immcheck_types.inc（立即數範圍檢查類型）'
# 'Generate arm_mve.h for clang'
H9B02FDBF61FE: '為clang生成arm_mve.h'
# 'Generate arm_neon.h for clang'
HBC7A4B2C0607: '為clang生成arm_neon.h'
# 'Generate arm_sme.h for clang'
HE4D6EF6670EF: '為clang生成arm_sme.h'
# 'Generate arm_sme_builtin_cg_map.inc for clang'
H9942231BE658: '為clang生成arm_sme_builtin_cg_map.inc'
# 'Generate arm_sme_builtins.inc for clang'
HB5A0445595D2: '為clang生成arm_sme_builtins.inc'
# 'Generate arm_sme_builtins_za_state.inc for clang'
H1A92D0667981: '為clang生成arm_sme_builtins_za_state.inc'
# 'Generate arm_sme_sema_rangechecks.inc for clang'
H934D5C9C551E: '為clang生成arm_sme_sema_rangechecks.inc'
# 'Generate arm_sme_streaming_attrs.inc for clang'
HB0ACDD97739D: '為clang生成arm_sme_streaming_attrs.inc'
# 'Generate arm_sve.h for clang'
HA4A04F03FE49: '為clang生成arm_sve.h'
# 'Generate arm_sve_builtin_cg_map.inc for clang'
H85004239686F: '為clang生成arm_sve_builtin_cg_map.inc'
# 'Generate arm_sve_builtins.inc for clang'
H521827D71962: '為clang生成arm_sve_builtins.inc'
# 'Generate arm_sve_sema_rangechecks.inc for clang'
H7845A0DBDBD3: '產生arm_sve_sema_rangechecks.inc檔供clang使用'
# 'Generate arm_sve_streaming_attrs.inc for clang'
H0E1FDBC6C09B: '產生arm_sve_streaming_attrs.inc檔供clang使用'
# 'Generate arm_sve_typeflags.inc for clang'
HACE26ADDC9C9: '產生arm_sve_typeflags.inc檔供clang使用'
# 'Generate arm_vector_types.h for clang'
H7C1E9F56F891: '產生arm_vector_types.h檔供clang使用'
# 'Generate attribute documentation'
H5EECEC688125: '產生屬性說明文件'
# 'Generate attributes for this dialect'
HE3FD9C3103CA: '為此方言產生屬性'
# 'Generate bitsplit instructions'
HE0B4AD43ABB0: '產生bitsplit指令'
# 'Generate branches with extended addressability, usually via indirect jumps.'
H84AA69F9BF2B: '產生具有延伸位址能力的分支，通常透過間接跳轉。'
# 'Generate calls to instrument function entry and exit'
HFC18B10AD85D: '產生對函數入口和出口進行插樁的調用'
# 'Generate clang PCH attribute reader'
HACB0FB3DEE14: '產生clang PCH屬性讀取器'
# 'Generate clang PCH attribute writer'
H0829BFECBA6A: '產生clang PCH屬性寫入器'
# 'Generate clang attribute clases'
HCAA1C36C6E17: '產生clang屬性類別'
# 'Generate clang attribute implementations'
H58D8D7EF6BF7: '產生clang屬性實作'
# 'Generate clang attribute text node dumper'
H7B79A1565130: '產生clang屬性文字節點轉譯器'
# 'Generate clang attribute traverser'
H82452D8DFFBB: '產生clang屬性遍歷器'
# 'Generate clang builtins list'
H7DD3DD5CD09E: '產生clang內建函數列表'
# 'Generate code for CUDA device'
H28657BCC831E: '為CUDA裝置產生程式碼'
# 'Generate code for SYCL device.'
HFDECAC3EE76F: '為SYCL裝置產生程式碼。'
# 'Generate code for an additional runtime variant of the deployment target'
HC009196F06DE: '為部署目標的額外執行階段變體產生程式碼'
# 'Generate code for statically linking libclosure (BlocksRuntime)'
H655EBC8C95D8: '為靜態連結libclosure（BlocksRuntime）產生程式碼'
# 'Generate code for the given target'
H978948BBCF74: '為指定目標生成代碼'
# 'Generate code for uses of this PCH that assumes an explicit object file will be built for the PCH'
H73D5D7524BBC: '為假設會為此預編譯標頭（PCH）建構明確物件檔的PCH使用情況生成代碼'
# 'Generate code for uses of this module that assumes an explicit object file will be built for the module'
H0A914343419E: '為假設會為此模組建構明確物件檔的模組使用情況生成代碼'
# 'Generate code only for an OpenMP target device.'
H22275002B232: '僅為OpenMP目標裝置生成代碼'
# 'Generate code which only uses the general purpose registers (AArch64/x86 only)'
HE13BDFDB4618: '僅使用通用目的寄存器生成代碼（僅限AArch64/x86）'
# 'Generate command properties for commands that are used in documentation comments'
HDF34DF8FD98C: '為用於文件注釋中的指令生成指令屬性'
# 'Generate coverage instrumentation for GlobalISel'
H98DAD8E8562B: '為GlobalISel生成覆蓋率插樁'
# 'Generate coverage mapping to enable code coverage analysis'
H3FA8EAFBA329: '生成覆蓋率映射以啟用程式碼覆蓋率分析'
# 'Generate data collectors for AST nodes'
HB676E426CC9E: '為AST節點生成資料收集器'
# 'Generate debug info for types in an object file built from this PCH and do not generate them elsewhere'
H2C592F95A21D: '為從此PCH建構的物件檔中的類型生成除錯資訊，並在其他地方不生成它們'
# 'Generate debug info for types in an object file built from this module and do not generate them elsewhere'
HE7EB6B773956: '為從此模組建構的物件檔中的類型生成除錯資訊，並在其他地方不生成它們'
# 'Generate debug info with external references to clang modules or precompiled headers'
HAD4093E5621B: '為包含clang模組或預編譯標頭的外部引用生成除錯資訊'
# 'Generate debugging info in the 64-bit DWARF format'
H70C04792FFA2: '以 64 位元DWARF格式生成除錯資訊'
# 'Generate declarations for Offload API implementation functions'
H36074FE5A628: '為Offload API實作函數生成宣告'
# 'Generate definitions of Clang Syntax Tree node clasess'
H83004344D792: '生成Clang語法樹節點類別的定義'
# 'Generate diagnostic documentation'
H376A46B39692: '生成診斷文件'
# 'Generate directives for this dialect'
HF8CA4ECC7825: '為此語法產生指示'
# 'Generate dot files into specified directory for changed IRs'
HD4CB202E81D5: '將變更後的IR對應的dot檔案生成至指定目錄'
# 'Generate dwarf aranges'
H6F048344D108: '生成DWARF aranges'
# 'Generate dwarf debugging info for assembly source files'
H5645E7139B8A: '為組譯檔來源檔案生成DWARF除錯資訊'
# 'Generate efficient matchers for HTML tag names that are used in documentation comments'
H20BDF8097FEE: '生成在文件註解中使用的HTML標記名稱的有效匹配器'
# 'Generate efficient matchers for HTML tag properties'
H7F720B1F0148: '生成HTML標記屬性的有效匹配器'
# 'Generate explicit import from anonymous namespace to containing scope'
HAFE44C2C60BD: '從匿名命名空間生成到包含作用域的明確匯入'
# 'Generate export file for the Offload library'
H1A8F89282970: '為Offload庫生成輸出文件'
# 'Generate extract instructions'
HABD4DCD38172: '生成提取指令'
# 'Generate function to translate named character references to UTF-8 sequences'
H2212027837CC: '生成將命名字符參考轉換為UTF-8序列的函數'
# 'Generate hot text symbols. Apply this option to a precompiled binary that manually calls into hugify, such that at runtime hugify call will put hot code into 2M pages. This requires relocation.'
HE07FCEA6613B: '生成熱文本符號。將此選項用於手動調用hugify的預編譯二進位檔，以便在執行階段hugify調用將熱代碼放入 2M頁面。此需要重新定位。'
# 'Generate instrumented code to collect context sensitive execution counts into <directory>/default.profraw (overridden by LLVM_PROFILE_FILE env var)'
H10A2DF54F49A: '生成插樁代碼以收集上下文敏感執行計數到目錄/<directory>/default.profraw（可被LLVM_PROFILE_FILE環境變數覆寫）'
# 'Generate instrumented code to collect context sensitive execution counts into default.profraw (overridden by LLVM_PROFILE_FILE env var)'
HCBAB6F9C9B4D: '生成插樁代碼以收集上下文敏感執行計數到default.profraw（可被LLVM_PROFILE_FILE環境變數覆寫）'
# 'Generate instrumented code to collect coverage info for cold functions into <directory>/default.profraw (overridden by LLVM_PROFILE_FILE env var)'
H389023BECF0C: '生成插樁代碼以收集冷函數的覆蓋資訊到目錄/<directory>/default.profraw（可被LLVM_PROFILE_FILE環境變數覆寫）'
# "Generate instrumented code to collect coverage info for cold functions into default.profraw file (overridden by '=' form of option or LLVM_PROFILE_FILE env var)"
H40F8D1777D6C: '生成插樁代碼以收集冷函數的覆蓋資訊到default.profraw檔（可被選項的「＝」形式或LLVM_PROFILE_FILE環境變數覆寫）'
# 'Generate instrumented code to collect execution counts into <directory>/default.profraw (overridden by LLVM_PROFILE_FILE env var)'
H884AE4DB8A23: '生成插樁代碼以收集執行計數到目錄/<directory>/default.profraw（可被LLVM_PROFILE_FILE環境變數覆寫）'
# 'Generate instrumented code to collect execution counts into <file> (overridden by LLVM_PROFILE_FILE env var)'
HF1CDB71BC3BA: '生成插樁代碼以收集執行計數到 <file>（可被LLVM_PROFILE_FILE環境變數覆寫）'
# 'Generate instrumented code to collect execution counts into default.profraw (overridden by LLVM_PROFILE_FILE env var)'
HEDA64E6D9E58: '生成插樁代碼以收集執行計數到default.profraw（可被LLVM_PROFILE_FILE環境變數覆寫）'
# "Generate instrumented code to collect execution counts into default.profraw file (overridden by '=' form of option or LLVM_PROFILE_FILE env var)"
HCED0768BDFD7: '生成插樁代碼以收集執行計數到default.profraw檔（可被選項的「＝」形式或LLVM_PROFILE_FILE環境變數覆寫）'
# 'Generate instrumented code to collect temporal information'
H454449192474: '生成用於收集時序資訊的插樁代碼'
# 'Generate intrinsics with this target prefix'
H5CEC7C3808CA: '使用此目標前綴生成內建函數'
# 'Generate invalid output'
H668CF0E474FA: '生成無效輸出'
# 'Generate list of Clang Syntax Tree node types'
H3A9E31163210: '生成Clang語法樹節點類型列表'
# 'Generate list of commands that are used in documentation comments'
H55166381B0A4: '生成文件註解中使用的指令列表'
# 'Generate list of valid ARM CDE builtin aliases for clang'
H1E92420752F1: '生成 clang 的有效 ARM CDE 內建別名列表'
# 'Generate list of valid ARM MVE builtin aliases for clang'
H18CC5313A2F6: '生成 clang 的有效 ARM MVE 內建別名列表'
# 'Generate lldb option definitions'
HF07E69C59A11: '生成 lldb 選項定義'
# 'Generate lldb property definitions'
HBD76019A4518: '生成 lldb 屬性定義'
# 'Generate lldb property enum definitions'
H4D3EB8680DC4: '生成 lldb 屬性列舉定義'
# 'Generate load-load barrier instructions (dbar 0x700)'
HB092D2DF4B79: '生成 load-load 隔離指令（dbar 0x700）'
# 'Generate local calls to out-of-line atomic operations'
H160B36160D89: '生成對行外原子運算的本地呼叫'
# 'Generate loop nest for tiling.'
H40BB5343F902: '生成用於分塊的迴圈巢狀結構'
# 'Generate low-precision inline sequences for some float libcalls'
HA2542185A00F: '為部分浮點函式庫呼叫產生低精確度內聯序列'
# 'Generate machine code, but discard output'
HA74064264324: '生成機器碼，但丟棄輸出'
# 'Generate mcount/__fentry__ calls as nops. To activate they need to be patched in.'
HE3A927985452: '將 mcount/__fentry__ 呼叫生成為 nop。要啟用需先修補這些指令'
# 'Generate nested function profiles for CSSPGO'
H267DA13728E4: '為 CSSPGO 生成巢狀函式剖析資料'
# 'Generate option documentation'
HF1C9A7ED3825: '生成選項文件'
# 'Generate output compatible with the standard GNU Objective-C runtime'
H0A3E1D413F6F: '生成與標準 GNU Objective-C 執行時期相容的輸出'
# 'Generate pre-compiled header file'
H6076A415050D: '生成預編譯標頭檔'
# 'Generate pre-compiled module file from a module map'
H32E4ACE09217: '根據模組地圖生成預編譯模組檔'
# 'Generate pre-compiled module file from a standard C++ module interface unit'
H332BF5CFA1C0: '根據標準 C++ 模組介面單元生成預編譯模組檔'
# 'Generate random hotness values'
H5B6B1D07D43D: '生成隨機熱度值'
# 'Generate read-only position independent code (ARM only)'
H8619C4BF8421: '生成唯讀位置獨立程式碼（僅 ARM）'
# 'Generate read-write position independent code (ARM only)'
H49DE9A8DC6D7: '生成可讀寫位置獨立程式碼（僅 ARM）'
# 'Generate reduced prebuilt module interface from a standard C++ module interface unit'
HBCD3850127B9: '從標準C++模組介面單元生成精簡預建模模組介面'
# 'Generate relocatable device code, also known as separate compilation mode'
H2AB415613F7B: '生成可重定位裝置代碼，又稱分離編譯模式'
# 'Generate riscv_sifive_vector_builtin_cg.inc for clang'
H2F882B6DED2D: '為clang生成riscv_sifive_vector_builtin_cg.inc'
# 'Generate riscv_sifive_vector_builtin_sema.inc for clang'
HD872420A09E4: '為clang生成riscv_sifive_vector_builtin_sema.inc'
# 'Generate riscv_sifive_vector_builtins.inc for clang'
HD182FA023D72: '為clang生成riscv_sifive_vector_builtins.inc'
# 'Generate riscv_vector.h for clang'
HECE8F71BFB56: '為clang生成riscv_vector.h'
# 'Generate riscv_vector_builtin_cg.inc for clang'
H5A79CE9F1F74: '為clang生成riscv_vector_builtin_cg.inc'
# 'Generate riscv_vector_builtin_sema.inc for clang'
HA3230378A26C: '為clang生成riscv_vector_builtin_sema.inc'
# 'Generate riscv_vector_builtins.inc for clang'
H5D02D25DD210: '為clang生成riscv_vector_builtins.inc'
# 'Generate software floating point library calls'
H05167BC54E72: '生成軟體浮點庫調用'
# 'Generate source-level debug information'
HAEF3BF8D74CD: '生成來源層級除錯資訊'
# 'Generate source-level debug information with dwarf version 2'
HD2B80CB88FC9: '使用DWARF版本 2 生成來源層級除錯資訊'
# 'Generate source-level debug information with dwarf version 3'
HA4075062488F: '使用DWARF版本 3 生成來源層級除錯資訊'
# 'Generate source-level debug information with dwarf version 4'
H248AE385BE0D: '使用DWARF版本 4 生成來源層級除錯資訊'
# 'Generate source-level debug information with dwarf version 5'
HE4BA3B14D0D7: '使用DWARF版本 5 生成來源層級除錯資訊'
# 'Generate source-level debug information with the default dwarf version'
H938AF5B9960A: '使用預設的DWARF版本生成來源層級除錯資訊'
# 'Generate the clang parsed attribute helpers'
HFA9E86870CB2: '生成clang解析的屬性輔助程式'
# 'Generate the profile for Linux kernel binary.'
HB596668CB82B: '為Linux核心二進位檔生成剖析配置文件'
# 'Generate the reduced BMI'
HED698C3C66EE: '生成精簡的BMI'
# 'Generate thread parallel code (isl codegen only)'
H34625E399986: '生成執行緒平行程式碼（僅isl程式產生器）'
# 'Generate types for this dialect'
H62C541A61A79: '為此語法生成類型'
# 'Generate unique debug info for each instruction with a memory operand. Should be enabled for profile-driven cache prefetching, both in the build of the binary being profiled, as well as in the build of the binary consuming the profile.'
H337DAB1315D8: '為每個具有記憶體操作數的指令生成唯一的除錯資訊。應在構建被剖析的二進位以及構建使用剖析資料的二進位時啟用，以支援剖析驅動的快取預取。'
# 'Generate unoptimized CFGs for all analyses'
HA85B8A701BAB: '為所有分析生成未優化之CFG'
# 'Generate unwinding tables for all functions'
HF1490D883AAC: '為所有函數生成解包表'
# 'Generate verbose assembly output'
H0B7F9E41E63B: '生成詳細的組裝語言輸出'
# 'Generated inlined abstract references.'
H21A52BEF39EC: '生成內聯抽象引用。'
# 'Generates tables to help identify patterns matched'
HD3439779FA7F: '產生表格以協助識別匹配的模式'
# 'Generator to run'
H9B18D7EC4146: '要執行的產生器'
# 'Generic Options'
H5EEF255AAE70: '通用選項'
# 'Generic memory optimizations'
H800F1622EB9A: '通用記憶體最佳化'
# 'Get the symbol definition from <line> <start-column> <end-column>'
H9C96E5C80114: '從 <line> <start-column> <end-column> 取得符號定義'
# 'Give each function an independent TBAA tree (default)'
H7A952E99A7FC: '為每個函數提供獨立的TBAA樹（預設值）'
# 'Give global C++ operator new and delete declarations hidden visibility'
HAD504B33021E: '為全域C++運算式new和delete宣告指定隱藏可見性'
# "Give global types 'default' visibility and global functions and variables 'hidden' visibility by default"
H095BFBCE25DF: "預設為全域類型指定 'default' 可見性，以及全域函數和變數指定 'hidden' 可見性"
# 'Give inline C++ member functions hidden visibility by default'
HAF1CF839FC8A: '預設為內聯C++成員函數指定隱藏可見性'
# 'Give the maximum number of instructions that we will use for creating a floating-point immediate value'
HB7780EA795D5: '指定用於建立浮點數立即數的最大指令數'
# 'Give the maximum size (in number of nodes) of the web of instructions that we will consider for VW expansion'
H6AD97D209EFA: '指定我們考慮用於VW展開的指令網絡的最大大小（以節點數為單位）'
# 'Give unique names to every basic block section'
HE9E6E34AE2B8: '為每個基本區塊區段指定唯一名稱'
# 'Give unique names to every section'
HAE1CB86AEAE6: '為每個區段指定唯一名稱'
# 'Global Pointer Addressing Size.  The default size is 8.'
H7DA66DD4C059: '全域指標位址大小。預設值為 8。'
# 'Global Value Numbering'
H7BB46D78F883: '全域值編號'
# 'Global merge function pass'
H22AF90C7A55F: '全域合併函數pass'
# 'GlobalISel Combiner'
H204136E4EB5C: 'GlobalISel 組合器'
# 'Globally set the denormals-are-zero (DAZ) and flush-to-zero (FTZ) bits in the floating-point control register on program startup'
H3BA6F3373251: '在程式啟動時將次正规數等於零（DAZ）和清空至零（FTZ）位元設為全域值，在浮點數控制寄存器中'
# 'Globals Alias Analysis'
H9A682873774C: '全域變數別名分析'
# 'Good Bye World Pass'
H6716A126CB42: 'Good Bye World pass'
# 'Gradient gain threshold (%).'
H28D3EF05A6AB: '梯度增益閾值（%）。'
# 'Greedy Register Allocator'
HB8463656EACF: '貪婪暫存器配置器'
# 'Greedy register allocator'
HE2214CA75FBC: '貪婪暫存器配置器'
# 'Guard UBSAN checks with `llvm.allow.ubsan.check()`.'
H368DFFFB3230: '使用 `llvm.allow.ubsan.check()` 來保護UBSAN檢查。'
# 'Guard against compiler/runtime version mismatch.'
HA3897596A344: '防範編譯器/執行階段版本不一致。'
# 'Guided scheduling'
H4B9648519786: '指引式排程'
# 'HIP Standard Parallel Algorithm Acceleration library path, used for finding and implicitly including the library header'
H8403B00ECFB8: 'HIP標準並行演算法加速庫路徑，用於尋找和隱式包含該庫的標頭檔'
# 'HIP device library'
H14BC304940A6: 'HIP裝置函式庫'
# 'HIP does not support OpenMP target directives; directive has been ignored'
H0DF90C6E349C: 'HIP不支援OpenMP目標指令；該指令已被忽略'
# 'HIP runtime installation path, used for finding HIP version and adding HIP include path.'
HD2A8F00A760F: 'HIP執行階段安裝路徑，用於尋找HIP版本並添加HIP包含路徑。'
# 'HIP version in the format of major.minor.patch'
H4C1B608415FC: '以主要.次要.修正版格式表示的HIP版本'
# 'HLSL Version'
HB3FA8D10C87C: 'HLSL版本'
# "HLSL code generation is unsupported for target '%0'"
HE92A9C826849: "HLSL程式碼產生不支援目標 '%0'"
# 'HLSL only. Disables all standard includes containing non-native compiler types and functions.'
H1F13E0FA5ECA: '僅HLSL。停用所有包含非本機編譯器類型和函數的標準包含檔。'
# 'HLSL resource needs to have [[hlsl::resource_class()]] attribute'
HAC100FF02618: 'HLSL 資源需要具有 [[hlsl::resource_class()]] 屬性'
# "HTML end tag '%0' is forbidden"
H685A0F5F60EA: "HTML 結束標籤 '%0' 被禁止"
# 'HTML end tag does not match any start tag'
H04F1BAAABD62: 'HTML 結束標籤未與任何開始標籤匹配'
# 'HTML output'
H9222F90CA7BE: 'HTML 輸出'
# "HTML start tag '%0' closed by '%1'"
H5D28040DFF0A: "HTML 開始標籤 '%0' 被 '%1' 關閉"
# "HTML start tag prematurely ended, expected attribute name or '>'"
HB396911AC86C: "HTML 開始標籤過早結束，期望屬性名稱或 '>'"
# "HTML tag '%0' requires an end tag"
HC3A525011E51: "HTML 標籤 '%0' 預期屬性名稱或 '>'，但過早結束"
# 'HTML tag started here'
H3CB5C9051AF3: 'HTML 標籤在此處開始'
# 'HWASan shadow mapping dynamic offset location'
H0D34082EDF7B: 'HWASan shadow mapping dynamic offset 位置'
# 'HWASan shadow mapping offset [EXPERIMENTAL]'
H2991A813E596: 'HWASn shadow mapping offset [實驗性]'
# 'Handle <= and >= in finite loops'
H5AA1FAB9586D: '處理有限迴圈中的 <= 和 >='
# 'Handle C++ exceptions (insert cleanup blocks for unwinding)'
H250354C717B0: '處理 C++ 例外（在異常傳遞期間插入清理區塊）'
# 'Handle C++ initializer order'
HC63CC32922AA: '處理 C++ 初始化順序'
# 'Handle global objects'
H5D8738E4497F: '處理全域物件'
# 'Handle stack memory'
H9B9B06338F2E: '處理堆疊記憶體'
# 'Hard float ABI (uses FP registers)'
HEEAB4CE3F0BA: '硬式浮點ABI（使用浮點數寄存器）'
# 'Hard-coded mapping'
H6EC79E37D2B2: '硬編碼的對應關係'
# 'Harden indirect calls and jumps against using speculatively stored attacker controlled addresses. This is designed to mitigate Spectre v1.2 style attacks.'
H64FF4BC73D36: '強化可能遭受 Load Value Injection (LVI) 攻擊的內聯組裝程式碼。此功能為實驗性。'
# 'Harden inline assembly code that may be vulnerable to Load Value Injection (LVI). This feature is experimental.'
H9EF1510D3F11: '跨程序間通過在函數高位元堆疊指標中傳遞狀態，強化間接跳轉與呼叫的安全性以防止利用預測性寫入的攻擊者控制位址。此設計旨在緩解 Spectre v1.2 類型攻擊。'
# 'Harden interprocedurally by passing our state in and out of functions in the high bits of the stack pointer.'
HD67DA497275B: '跨程序間通過在函數高位元堆疊指標中傳遞狀態，強化間接跳轉與呼叫的安全性以防止利用預測性寫入的攻擊者控制位址。此設計旨在緩解 Spectre v1.2 類型攻擊。'
# 'Harden the value loaded *after* it is loaded by flushing the loaded bits to 1. This is hard to do in general but can be done easily for GPRs.'
HC7A0E024F604: '強化載入後的值（在載入後）通過將載入的位元設置為 1。這在一般情況下很難做到，但對GPRs來說很容易。'
# 'Hardware Loop Insertion'
HD9C10B054698: '硬體迴圈插入'
# 'Hardware multiplier use mode for MSP430'
HE8A05395F9BD: 'MSP430 的硬體乘法器使用模式'
# 'Hash long pathnames'
H2984D386D5E0: '哈希長路徑名稱'
# 'Hazard size for streaming mode memory accesses. 0 = disabled.'
H4C73818D60FE: '流式模式記憶體存取的危機尺寸。0 = 禁用。'
# 'Heatmap options'
H6D36D04383CD: '熱圖選項'
# 'Helps find bugs by verifying the IR whenever we emit new instructions (*very* expensive).'
H92F16AA997F0: '透過每次發出新指令時驗證IR來幫助查找錯誤（*非常* 占用資源）。'
# 'Heuristics-based inliner version'
H91CCDBD88F85: '基於啟發式規則的內聯版本'
# 'Hexagon Branch Relaxation'
HE56E26D71726: 'Hexagon 分支鬆弛優化'
# 'Hexagon CFG Optimizer'
HADEAF8F4224F: 'Hexagon CFG 優化器'
# 'Hexagon Common GEP'
H7416FD0F0215: 'Hexagon 共用 GEP'
# 'Hexagon Constant Propagation'
H4545D96F56E6: 'Hexagon 常數傳播'
# 'Hexagon Copy-To-Combine Pass'
HA9D6C5272766: 'Hexagon Copy-To-Combine Pass'
# 'Hexagon DAG->DAG Pattern Instruction Selection'
H8C61F3028012: 'Hexagon DAG→DAG 模式指令選擇'
# 'Hexagon Expand Condsets'
H77C9EE5ECE10: 'Hexagon 展開 Condsets'
# 'Hexagon Generate Load/Store Set Absolute Address Instruction'
HDCC2529025E3: 'Hexagon 產生設置絕對地址的載入/儲存指令'
# 'Hexagon Hardware Loops'
H430E0FA91788: 'Hexagon 硬體迴圈'
# 'Hexagon Hardware Loops Fixup'
HEBB89CCF449D: 'Hexagon 硬體迴圈修復'
# 'Hexagon Load Widening'
H629EAC297715: 'Hexagon 載入擴展'
# 'Hexagon Loop Rescheduling'
H9B5F9E54FF64: 'Hexagon 循環重新調度'
# 'Hexagon LoopAlign pass'
H079823890488: 'Hexagon LoopAlign pass'
# 'Hexagon NewValueJump'
HD050A64FD350: 'Hexagon 新值跳轉'
# 'Hexagon Packetizer'
HD80045280EC2: 'Hexagon 指令打包'
# 'Hexagon Peephole'
H96F1818D0A76: 'Hexagon 窥孔優化'
# 'Hexagon RDF optimizations'
H0E48883DC0AC: 'Hexagon RDF 優化'
# 'Hexagon Split Const32s and Const64s'
HE37A260C9D82: 'Hexagon 拆分Const32和Const64'
# 'Hexagon Split Double Registers'
H6CA85CE5559C: 'Hexagon 拆分雙寄存器'
# 'Hexagon Store Widening'
H23CE261CD27B: 'Hexagon 存儲展寬'
# 'Hexagon TFR Cleanup'
H6ECA189DB2DB: 'Hexagon TFR 清理'
# 'Hexagon Vector Combine'
H9F8DB4B385EA: 'Hexagon 向量合併'
# 'Hexagon VectorPrint pass'
H540A5ECB5448: 'Hexagon 向量列印 pass'
# 'Hexagon bit simplification'
HF73F7F5D57C5: 'Hexagon 位簡化'
# 'Hexagon call frame information'
H93CA35321D07: 'Hexagon 呼叫框架資訊'
# 'Hexagon constant-extender optimization'
H1C0F5065601C: 'Hexagon 常數擴展優化'
# 'Hexagon early if conversion'
H5C9514E28A85: 'Hexagon 提早if轉換'
# 'Hexagon generate "extract" instructions'
H7636CC8F55F3: 'Hexagon 生成 "extract" 指令'
# 'Hexagon generate "insert" instructions'
H3778EAC02853: 'Hexagon 生成 "insert" 指令'
# 'Hexagon generate mux instructions'
H5C45CA2F85F2: 'Hexagon 生成多路選擇指令'
# 'Hexagon generate predicate operations'
H40F613387EB4: 'Hexagon 生成謂詞運算'
# 'Hexagon mask'
HEEBCEB3469AC: 'Hexagon遮罩'
# 'Hexagon move phi copy'
HDCDB2AA0AED1: 'Hexagon移動Phi節點複製'
# 'Hexagon optimize vextract'
H278043636EF5: 'Hexagon優化vextract'
# 'Hexagon-specific predictive commoning for HVX vectors'
H536F10F1AEBD: '針對HVX向量的Hexagon特定預測性共用'
# 'Hide blocks with relative frequency below the given value'
H3675151E5C00: '隱藏相對頻率低於指定值的區塊'
# 'Hide nodes with more predecessor/successor than cutoff'
HBFFDABE2C9B6: '隱藏前驅/後驅數量超過閾值的節點'
# 'High level execution tracing'
HEC0DB93568EB: '高階執行追蹤'
# 'High level qualifier for z/OS C++RT side deck datasets'
HAA6C6806CE9D: 'z/OS C++RT側面數據集的高階限定符'
# 'High level qualifier for z/OS CSSLIB dataset'
H3CB003A4AC08: 'z/OS CSSLIB數據集的高階限定符'
# 'High level qualifier for z/OS Language Environment datasets'
HF68A673FB7E5: 'z/OS語言環境數據集的高階限定符'
# 'High register pressure threhold.'
H72FE4FE03B96: '高寄存器壓力閾值。'
# 'Highlight the code regions that will be optimized in a (CFG BBs and LLVM-IR instructions)'
H011F5431A825: '突出顯示將在其中進行優化的代碼區域（CFG基本區塊和LLVM-IR指令）'
# 'Highlight the code regions that will be optimized in a (CFG only BBs)'
H8868F2ACA588: '僅突出顯示CFG基本區塊中的將被優化的代碼區域'
# 'Hoist common instructions up to the parent block'
H626E78174BD3: '將公共指令提升至父區塊'
# 'Hoist conditional stores even if an unconditional store does not precede - hoist multiple conditional stores into a single predicated store'
HAF676B43A7DA: '即使無條件存儲不存在，仍提升條件存儲—將多個條件存儲合併為單一條件式存儲'
# 'Hoist conditional stores if an unconditional store precedes'
H051D0419768A: '如果存在無條件存儲，則提升條件存儲'
# 'Hoist inner loop runtime memory checks to outer loop if possible'
H1896B47EDC00: '如果可能，將內層循環的執行階段記憶體檢查提升至外層循環'
# 'Hoist instructions from the beginning of the BB up to the maximum specified depth (default = 100, unlimited = -1)'
H19FF88ADEF86: '從BB的開始處提升指令，最多到指定深度（預設值=100，無限制=-1）'
# 'Hoist invariant loads'
H04F2E5FA708B: '提升不變載入指令'
# 'Hoist invariant loads.'
HFD3073FAF6A0: '提升不變載入指令。'
# 'Hoist invariant stores'
H37B16BDD134A: '提升不變的存儲操作'
# 'Hoist loads if the target supports conditional faulting'
HFE6E57FFE11D: '若目標支援條件性錯誤，則提升載入操作'
# 'Hoist loads/stores if the target supports conditional faulting (default = false)'
H360599A9B4F2: '若目標支援條件性錯誤，則提升載入/存儲操作（預設 = false）'
# 'Hoist stores if the target supports conditional faulting'
HD60C7781C619: '若目標支援條件性錯誤，則提升存儲操作'
# 'Hoisting alloca instructions in non-entry blocks to the entry block'
H1611B6B7938C: '將非入口區塊中的 alloca 指令提升到入口區塊'
# 'Hot callsite threshold for proirity-based sample profile loader inlining.'
HF203067F3822: '基於優先級的樣本剖析載入器內聯中，熱調用點閾值。'
# 'Hot percentile cutoff.'
HCEE9FC61C4DD: '熱百分比閾值。'
# 'How cgscc inline replay file is formatted'
HD50D41502699: 'cgscc 內聯重播檔案的格式'
# "How cgscc inline replay treats sites that don't come from the replay. Original: defers to original advisor, AlwaysInline: inline all sites not in replay, NeverInline: inline no sites not in replay"
H6F8523C009E8: 'cgscc 內聯重播對未來自重播的位址如何處理。 Original: 依賴原始決策器，AlwaysInline: 內聯所有不在重播中的位址，NeverInline: 不內聯所有不在重播中的位址'
# "How many functions in a module could be used for MergeFunctions to pass a basic correctness check. '0' disables this check. Works only with '-debug' key."
H65C2FF1A291C: "模組中可用於 MergeFunctions 通過基本正確性檢查的函數數量。 '0' 禁用此檢查。需搭配 '-debug' 鍵使用。"
# 'How many idle instructions we would like before certain undef register reads'
HAF5EEC679340: '我們希望在特定未定義寄存器讀取前有多少閒置指令'
# 'How many kernel arguments to preload onto SGPRs'
H2C2BF298A146: '預載到 SGPR 中的核函數參數數量'
# 'How many lifetime ends to handle for a single alloca.'
H1A9776E5D001: '單個 alloca 要處理的 lifetime ends 數量'
# 'How much code-generation to perform'
HB6C2FA93092D: '執行多少代碼生成'
# 'How sample profile inline replay file is formatted'
H7CB1B737EC5A: '樣本剖析內聯重播檔案的格式'
# "How sample profile inline replay treats sites that don't come from the replay. Original: defers to original advisor, AlwaysInline: inline all sites not in replay, NeverInline: inline no sites not in replay"
H023EFDA855FF: '樣本剖析內聯重播對未來自重播的位址如何處理。 Original: 依賴原始決策器，AlwaysInline: 內聯所有不在重播中的位址，NeverInline: 不內聯所有不在重播中的位址'
# 'How to aggregate multi-values result'
HE0FCAEDB7A77: '如何聚合多重值結果'
# 'How wide an instruction window to bypass looking for another guard'
H190528E1E0D0: '要跳過的指令窗口寬度，以尋找另一個 guard'
# 'HowToUseLLJIT'
H56EB31810445: '如何使用LLJIT'
# 'Human readable output. Only valid without -all-stacks.'
H1D2D4ECF9DBD: '人類可讀的輸出格式。僅在無 -all-stacks 時有效。'
# 'Human-readable format'
H5B717FB38D2F: '可讀性格式'
# 'IBM MASS vector library'
HC5A8A1BFD3A5: 'IBM MASS 向量函式庫'
# 'IBOutletCollection properties should be copy/strong and not assign'
H91B04B0AEDF0: 'IBOutletCollection 屬性應設定為 copy/strong，而非 assign'
# 'IEEE 754 denormal numbers'
HB645808304FA: 'IEEE 754 次正規數'
# 'IRDL file to register before processing the input'
H9ADEB68395C9: '在處理輸入前要註冊的 IRDL 檔案'
# 'IRTranslator LLVM IR -> MI'
HA8BDC735DCBC: 'IRTranslator LLVM 中間語言 -> 目標機器指令'
# 'ISO C does not allow indirection on operand of type %0'
HC4C25916B558: 'ISO C 不允許對類型 %0 的操作數進行間接存取'
# "ISO C does not support '~' for complex conjugation of %0"
H592FB210723A: "ISO C 不支援使用 '~' 進行 %0 的複數共軛"
# "ISO C forbids forward references to 'enum' types"
H3A2E43246AF1: "ISO C 禁止向前引用 'enum' 類型"
# "ISO C forbids taking the address of an expression of type 'void'"
H5DC6DC421D10: "ISO C 禁止對類型 'void' 的運算式取址"
# "ISO C requires a named parameter before '...'"
HAAD7320B82D0: "ISO C 要求在 '...' 前面有一個命名參數"
# 'ISO C requires a translation unit to contain at least one declaration'
HD453AE5DFC44: 'ISO C 要求翻譯單位中至少包含一個宣告'
# 'ISO C++ considers this destructor name lookup to be ambiguous'
H51664244F36F: 'ISO C++ 認為此析構函數的名稱搜尋是模稜兩可的'
# 'ISO C++ does not allow %select{an attribute list|%0}1 to appear here'
H6EEF885F4392: 'ISO C++ 不允許在此處出現 %select{屬性清單|%0}1'
# 'ISO C++ does not allow %select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2 because it casts away qualifiers, even though the source and destination types are unrelated'
HA24736A782D5: 'ISO C++ 不允許 %select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 從 %1 轉換到 %2，因為它會忽略類型修飾符，即使來源和目標類型無關'
# "ISO C++ does not permit the 'bool' keyword after 'concept'"
HED15AAEA01CD: "ISO C++ 不允許在 'concept' 之後使用 'bool' 關鍵字"
# "ISO C++ forbids forward references to 'enum' types"
H565E6A76B7E7: "ISO C++ 禁止向前引用 'enum' 類型"
# "ISO C++ only allows ':' in member enumeration declaration to introduce a fixed underlying type, not an anonymous bit-field"
HD765E30339DE: "ISO C++ 只允許在成員枚舉宣告中使用 ':' 來指定固定基礎類型，而非匿名位段"
# 'ISO C++ requires a definition in this translation unit for %select{function|variable}0 %q1 because its type does not have linkage'
HCF564C1243BB: 'ISO C++ 要求在此翻譯單位中定義 %select{函數|變數}0 %q1，因其類型無連結性'
# 'ISO C++ requires field designators to be specified in declaration order; field %1 will be initialized after field %0'
HF7272CADD93F: 'ISO C++ 要求字段指定符需按宣告順序指定；字段 %1 將在字段 %0 後初始化'
# "ISO C++ requires the name after '::~' to be found in the same scope as the name before '::~'"
H1B12535D9EA0: "ISO C++ 要求 '::~' 後的名稱必須與 '::~' 前的名稱位於同一範圍內"
# "ISO C++ specifies that qualified reference to %0 is a constructor name rather than a %select{template name|type}1 in this context, despite preceding %select{'typename'|'template'}2 keyword"
H0AEAB31369D3: "ISO C++ 指定在此語境中 %0 的限定引用是建構函數名稱而非 %select{範本名稱|類型}1，即使存在前導 %select{'typename'|'template'}2 關鍵字"
# 'ISO C++ standards before C++17 do not allow new expression for type %0 to use list-initialization'
H36A45BAF91C7: 'C++17 之前的 ISO C++ 標準不允許對類型 %0 使用列表初始化的 new 表達式'
# 'ISO C++11 does not allow access declarations; use using declarations instead'
H949947FDD999: 'ISO C++11 不允許存取宣告；請改用 using 宣告'
# 'ISO C++11 does not allow conversion from string literal to %0'
HDCEA926F7FF8: 'ISO C++11 不允許將字串文字轉換為 %0'
# 'ISO C++11 requires a parenthesized pack declaration to have a name'
H70DD46DED2FB: 'ISO C++11 要求帶括號的參數包宣告必須有名稱'
# "ISO C++17 does not allow 'register' storage class specifier"
HFBD7E25436E2: "ISO C++17 不允許 'register' 儲存類別指定詞"
# 'ISO C++17 does not allow a decomposition group to be empty'
H38C9A47FB6B4: 'ISO C++17 不允許空的分解群組'
# 'ISO C++17 does not allow dynamic exception specifications'
HDA1158B635F1: 'ISO C++17 不允許動態例外規格'
# 'ISO C++17 does not allow incrementing expression of type bool'
H8CE1E8E6EA54: 'ISO C++17 不允許遞增布林類型的運算式'
# "ISO C++20 considers use of overloaded operator '%0' (with operand types %1 and %2) to be ambiguous despite there being a unique best viable function%select{ with non-reversed arguments|}3"
HE2B331A9C128: "ISO C++20 覺得使用超載運算子 '%0'（參數類型為 %1 和 %2）會產生歧義，即使存在唯一的最佳可行函數%select{（參數順序反轉）|}3"
# "ISO C++20 requires return type of selected 'operator==' function for rewritten '%1' comparison to be 'bool', not %0"
H96DD21560E53: "ISO C++20 要求用來重寫 '%1' 比較的選擇 'operator==' 函數的傳回類型必須是 'bool'，而非 %0"
# 'ISO C90 does not allow subscripting non-lvalue array'
HB75A7925DCA5: 'ISO C90 不允許對非常量左值陣列進行索引'
# 'ISO C99 requires whitespace after the macro name'
HDC593F4C1475: 'ISO C99 要求宏名稱後面要有空白'
# 'IT block support'
H110A8754A4BC: 'IT 區塊支援'
# 'Id of alloc to export if -memprof-dot-scope=alloc or to highlight if -memprof-dot-scope=all'
HB6A8CDFE5726: '若 -memprof-dot-scope=alloc 則指定要輸出的分配 id，若為 -memprof-dot-scope=all 則指定要標記的 id'
# 'Id of context to export if -memprof-dot-scope=context or to highlight otherwise'
H0412058D0B19: '若 -memprof-dot-scope=context 則指定要輸出的環境 id，否則指定要標記的 id'
# "Identifies whether Control Flow Integrity protects all indirect control flow instructions in the provided object file, DSO or binary.\nNote: Anything statically linked into the provided file *must* be compiled with '-g'. This can be relaxed through the '--ignore-dwarf' flag."
H7027E6C59DD5: "判斷提供的物件檔案、DSO 或二進位檔是否受控制流完整性（CFI）保護所有間接控制流指令。\n注意：任何靜態連結至該檔案的內容 *必須* 以 '-g' 編譯。此限制可透過 '--ignore-dwarf' 標籤放寬。"
# 'If Converter'
H8621034DF5DA: 'If 轉換器'
# "If ThinLTO and WPD is enabled and this option is true, vtable profiles will be used by ICP pass for more efficient indirect call sequence. If false, type profiles won't be used."
H97A5D327A1D2: '若啟用 ThinLTO 和 WPD，且此選項為 true，vtable 剖析資料將被 ICP pass 使用以提升間接呼叫序列效率。若為 false，類型剖析資料將不會被使用。'
# 'If a personality routine is marked uninstrumented from the ABI list, do not create a wrapper for it.'
H830E42B2D102: '如果ABI列表中标記了某個personality routine為未插樿，則不為其建立包裝函數。'
# 'If an allocatable left-hand side of an intrinsic assignment is unallocated or its shape/type does not match the right-hand side, then it is automatically (re)allocated'
HFF2E7612E3B3: '如果可分配的內在指派左側運算元未分配，或其形狀/類型與右側不匹配，則會自動（重新）分配'
# 'If enabled, drop make.implicit metadata in unswitched implicit null checks to save time analyzing if we can keep it.'
H84A812339ADF: '若啟用，則在未切換隱含空指標檢查時，會刪除make.implicit元數據以節省分析能否保留的時間'
# 'If enabled, simple loop unswitching will also consider llvm.experimental.guard intrinsics as unswitch candidates.'
H0DECF1F15908: '若啟用，簡單的循環切分將也會將llvm.experimental.guard插樿函數視為切分候選。'
# 'If enabled, the freeze instruction will be added to condition of loop unswitch to prevent miscompilation.'
H29F9314FFE86: '若啟用，則會在循環切分條件中加入freeze指令以防止誤編譯。'
# 'If present, forces/disables the use of long calls'
H244BD3DDA186: '如果存在，強制使用/禁用長調用（long calls）'
# 'If present, stops packetizing after N instructions'
HC908BB95C55F: '如果存在，則在處理N條指令後停止封包化'
# 'If profile count information is used in tail duplication cost model, the gained fall through number from tail duplication should be at least this percent of hot count.'
H4BE057670DD8: '如果在尾部複製成本模型中使用了剖析計數資訊，則尾部複製所獲得的直接跳轉數量應至少為熱點計數的此百分比。'
# 'If set to true, IRCE may eliminate wide range checks in loops with narrow latch condition.'
HC7CC2CE2097F: '若設為true，IRCE可能消除迴圈中具有狹窄循環條件的廣泛範圍檢查。'
# 'If set, and on a color-capable terminal controls whether or not to print diagnostics in color'
H22D7A9441E62: '若設置且在支援顏色的終端機上，會控制是否以顏色顯示診斷信息'
# 'If set, assume that loads and stores do not alias'
H938298BEB1B1: '若設置，則假設載入與儲存操作不會別名'
# 'If set, benchmark all sizes from sweep-min-size to sweep-max-size'
H918C41E05E1C: '若設置，則會對所有從sweep-min-size到sweep-max-size的尺寸進行效能測試'
# 'If set, changes formatting warnings to errors'
HF6B939F6D70E: '若設置，則將格式化警告轉換為錯誤'
# 'If set, do not actually make the formatting changes'
H11412975A779: '若設置，則不會實際進行格式化修改'
# "If set, don't error out on the specified warning type."
H94EED0D743F6: '若設置，則對指定的警告類型不會導致錯誤終止'
# 'If set, fail with exit code 1 on incomplete format.'
H3940587B501D: '若設置，則在格式不完整時終止並返回錯誤代碼 1。'
# 'If set, overrides the include sorting behavior\ndetermined by the SortIncludes style flag'
HA0F9A020C51D: '若設置，則覆蓋由SortIncludes格式旗標決定的include排序行為'
# 'If set, overrides the qualifier alignment style\ndetermined by the QualifierAlignment style flag'
H7D8374F39C0A: '若設置，則覆蓋由QualifierAlignment格式旗標決定的修飾符對齊樣式'
# 'If set, shows the list of processed files'
HB1247E3D1FC1: '若設置，則會顯示已處理的檔案清單'
# 'If set, unknown format options are only warned about.\nThis can be used to enable formatting, even if the\nconfiguration contains unknown (newer) options.\nUse with caution, as this might lead to dramatically\ndiffering format depending on an option being\nsupported or not.'
HB78C3D57EF8C: '若設置，則未知的格式選項僅顯示警告。\n此功能可用於即使配置檔包含未知（新版本）選項時仍啟用格式化功能。\n使用時需謹慎，因為這可能會導致格式因選項是否被支援而有劇烈差異。'
# 'If specified, IR printed using the -print-[before|after]{-all} options will be dumped into files in this directory rather than written to stderr'
HC6C4D32713B0: '如果指定此選項，使用 -print-[before|after]{-all} 選項輸出的IR將被寫入該目錄下的文件，而非stderr'
# 'If stats should be appended to stats-file instead of overwriting it'
H7B41C07F5D40: '如果需要將統計資料追加到 stats-file 文件，而非覆蓋原有內容'
# 'If the function being instrumented contains more than this number of memory accesses, use callbacks instead of inline checks (-1 means never use callbacks).'
HD30970E83223: '若正在插樁的函數包含超過此數值的記憶體存取次數，則改用回呼函數而非內聯檢查（-1 表示從不使用回呼函數）。'
# 'If the function being instrumented requires more than this number of checks and origin stores, use callbacks instead of inline checks (-1 means never use callbacks).'
H5B3AA5D69CF8: '若正在插樁的函數需要的檢查點與原始存儲超過此數值，則改用回呼函數而非內聯檢查（-1 表示從不使用回呼函數）。'
# 'If the function being instrumented requires more than this number of origin stores, use callbacks instead of inline checks (-1 means never use callbacks).'
H3A18D04548FF: '若正在插樁的函數需要的原始存儲超過此數值，則改用回呼函數而非內聯檢查（-1 表示從不使用回呼函數）。'
# 'If the profile density is below the given threshold, it will be suggested to increase the sampling rate.'
HDF4D3E04985A: '如果剖析的密度低於指定閾值，則建議提高採樣率。'
# 'If the runtime tripcount for the loop is lower than the threshold, the loop is considered as flat and will be less aggressively unrolled.'
HAC4BCB57FDE7: '如果迴圈的執行時的迭代次數低於閾值，則該迴圈將被視為平坦迴圈，並進行較少的積極展開。'
# 'If the sample profile is accurate, we will mark all un-sampled branches and calls as having 0 samples. Otherwise, treat them conservatively as unknown. '
H815D8C5F471D: '若樣本剖析準確，則將所有未被採樣的分支和呼叫標記為 0 取樣次數。否則將其保守地視為未知。'
# 'If the sample profile is accurate, we will mark all un-sampled callsite and function as having 0 samples. Otherwise, treat un-sampled callsites and functions conservatively as unknown. '
H196C3B85DE70: '若樣本剖析準確，則將所有未被採樣的呼叫位置和函數標記為 0 取樣次數。否則將未被採樣的呼叫位置和函數保守地視為未知。'
# "If the size of a function is smaller than the threshold, assume it can be inlined by PGO early inliner and it won't be adjusted based on sample profile."
HE6D98DD47634: '如果函數大小小於閾值，則假設它可被 PGO 預早內聯優化器內聯，且不會根據樣本剖析進行調整。'
# 'If the total count of context profile is smaller than the threshold, it will be merged into context-less base profile.'
H78D9F132106C: '如果上下文剖析的總計次數低於閾值，則將其合併到無上下文的基礎剖析中。'
# 'If the total count of the profile is smaller than threshold, it will be trimmed.'
H29DFE55539B7: '如果剖析的總計次數低於閾值，則將其修剪。'
# 'If the valnos size of an interval is larger than the threshold, it is regarded as a large interval. '
H65099468E23D: '如果區間的 valnos 大小超過閾值，則該區間將被視為大型區間。'
# 'If true, annotate inline advisor remarks with LTO and pass information.'
HBCBB7977FE78: '若啟用，內聯建議註解將附加 LTO 過程和 pass 相關資訊。'
# 'If true, artificially skip inline transformation in sample-loader pass, and merge (or scale) profiles (as configured by --sample-profile-merge-inlinee).'
HB64A7E1DFEB3: '若啟用，將跳過 sample-loader 過程中的內聯轉換，並根據 --sample-profile-merge-inlinee 配置合併（或調整）剖析。'
# 'If true, basic blocks are re-numbered before MBP layout is printed into a dot graph. Only used when a function is being printed.'
HBEE86CE05AA8: '若啟用，在輸出 dot 圖形的 MBP 布局前重新編號基本區塊。僅在輸出函數時使用。'
# 'If true, import function declaration as fallback if the function definition is not imported.'
HD7D070FB023F: '若啟用，若函數定義未被匯入，則將函數宣告作為備用方案匯入。'
# 'If true, keep the vtable symbols in indexed profiles'
H52D48DA006BE: '若啟用，將在索引剖析中保留虛函數表符號'
# 'If true, scale the working set size of the partial sample profile by the partial profile ratio to reflect the size of the program being compiled.'
HBDDA0894BE03: '若啟用，將根據部分剖析比率調整部分樣本剖析的工作集大小，以反映正在編譯程式的規模。'
# 'If true, the virtual table address will be instrumented to know the types of a C++ pointer. The information is used in indirect call promotion to do selective vtable-based comparison.'
H3E8FA9464A37: '若啟用，將插樁虛函數表位址以了解 C++ 指標的類型。此資訊將用於非直接呼叫提升，以執行選擇性虛函數表比較。'
# 'If using a contextual profile in this module, and an indirect call target is marked as alwaysinline, perform indirect call promotion for that target. If multiple targets for an indirect call site fit this description, they are all promoted.'
H51C56F762F1D: '如果在此模塊中使用了上下文剖析，且間接呼叫目標被標記為alwaysinline，則對該目標執行間接呼叫提升。如果某間接呼叫點的多個目標符合此描述，則所有目標都會被提升。'
# 'Ignore #line directives when displaying diagnostic locations'
HD98F069577E5: '顯示診斷位置時忽略#line 指令'
# 'Ignore RecMII'
H2050B14C1C4D: '忽略RecMII'
# 'Ignore TTI attributes compatibility check between callee/caller during inline cost calculation'
H6DBD3A9D0CF3: '在內聯成本計算期間忽略呼叫者與被呼叫者之間的TTI屬性相容性檢查'
# "Ignore all DWARF data. This relaxes the requirements for all statically linked libraries to have been compiled with '-g', but will result in false positives for 'CFI unprotected' instructions."
H39BB8E06FB84: "忽略所有DWARF資料。這會鬆弛所有靜態連結函式庫必須使用 '-g' 編譯的要求，但會導致'CFI未受保護'指令出現誤判。"
# 'Ignore attribute objc_direct so that direct methods can be tested'
HCF66187C2621: '忽略objc_direct屬性以測試直接方法'
# 'Ignore balance information, always return (1: Even, 2: Odd).'
HFC882D591A40: '忽略平衡資訊，始終返回（1：Even，2：Odd）。'
# 'Ignore bit-field types when aligning structures'
H37A6736DD441: '對結構進行對齊時忽略位域類型'
# 'Ignore call stack samples for hybrid samples and produce context-insensitive profile.'
H7E47B7D4BE2D: '忽略混合樣本的呼叫堆疊樣本，並產生上下文不敏感剖析。'
# 'Ignore case distinctions when searching.'
H17840E450A3A: '搜索時忽略大小寫區分。'
# 'Ignore element line number.'
H68F79AF97A49: '忽略元素行號。'
# 'Ignore environment variables to detect CUDA installation'
HAC9812BECEE3: '忽略環境變數以偵測CUDA安裝'
# 'Ignore existing branch weights on IR and always overwrite.'
HB7CA4D0B2FB1: '忽略IR中的現有分支權重，並始終覆蓋。'
# 'Ignore functions that match a regex. Multiple regexes can be comma separated. Scop detection will ignore all functions that match ANY of the regexes provided.'
HDF7F5F41C8A9: '忽略符合正則表達式的函數。多個正則表達式可用逗號分隔。Scop偵測將忽略所有符合提供之任何正則表達式的函數。'
# 'Ignore insert conflict and keep running to fix.'
HABB3F2EDAFC7: '忽略插入衝突並繼續運行以修復。'
# 'Ignore possible aliasing of the array bases'
H64EE4A3BEF1A: '忽略陣列基址的可能別名'
# 'Ignore redundant instrumentation'
H4E0E4A3BF250: '忽略冗餘插樁'
# 'Ignore the definition of the given macro when building and loading modules'
H7770258C460D: '在建立和載入模組時忽略指定宏的定義'
# 'Ignore the whitespace from the input file when emitting preprocessor output. It will only contain whitespace when necessary, e.g. to keep two minus signs from merging into to an increment operator. Useful with the -P option to normalize whitespace such that two files with only formatting changes are equal.\n\nOnly valid with -E on C-like inputs and incompatible with -traditional-cpp.'
HD37ED8478D7E: '在發出預處理輸出時忽略輸入檔中的空白。僅在必要時（例如防止兩個減號合併為遞增運算子）才保留空白。與-P選項結合使用時，可將空白格式化為標準，使只有格式差異的兩個檔內容相同。\n\n僅適用於C類語言的-E選項，且與-traditional-cpp不相容。'
# 'Ignore unexpected diagnostic messages'
H81B938CFE11E: '忽略意外診斷訊息'
# 'Ignore warnings from system headers (default)'
H7D4D3672A31D: '忽略系統標頭的警告（預設）'
# "Implement the 'patchable-function' attribute"
H53EFAEE072B9: "實作 '可修改函數' 屬性"
# 'Implicit null checks'
H40CAC5790CAC: '隱含空值檢查'
# 'Implicitly search the file system for module map files.'
HA09A2D8486F2: '隱含地在檔案系統中搜尋模組映射文件。'
# "Implies all other options in 'Symbol Types' category"
HA831AAE57383: '啟用符號類型類別中的所有其他選項'
# 'Implies most other options.'
H6CE9D8EF9C43: '啟用大多數其他選項。'
# 'Implies the SAVE attribute for non-automatic local objects in subprograms unless RECURSIVE'
H4C9AEE72AB8A: '除非是 RECURSIVE，否則對子程序中非自動本地物件隱含指定 SAVE 屬性'
# 'Import all external functions in index.'
H6AA576FCF40F: '匯入索引中的所有外部函數。'
# 'Import constant global variables with references'
H2A392B0AB0D3: '匯入具有引用的常數全域變數'
# 'Import declaration.'
H4A43ED2EE433: '匯入宣告。'
# 'Import full type definitions for ThinLTO.'
HC44C755DA4C3: '為 ThinLTO 匯入完整的類型定義'
# 'Import functions with noinline attribute'
HD198F1298814: '匯入具有 noinline 屬性的函數'
# 'Import module.'
H6E01604A8D9D: '匯入模組。'
# 'Import summary to use for testing the ThinLTO backend via opt'
HED7EEF5C6F9E: '匯入摘要以用於透過 opt 測試 ThinLTO 後端'
# 'Import the polyhedral description of the detected Scops'
H5D0606A7CB94: '匯入所偵測 Scops 的多面體描述'
# 'Import typeid resolutions from summary and globals'
HC32DC5EADEE2: '從摘要和全域物件匯入 typeid 解析結果'
# 'Import.'
H0E5CF36B48DC: '匯入。'
# 'Improve global merge pass to ignore globals only used alone'
H26A9763EC62A: '改進全域合併 pass，使其忽略僅單獨使用的全域變數'
# 'Improve global merge pass to look at uses'
HA9CE9E94603C: '改進全域合併 pass，使其分析使用情況'
# 'Improve the code quality by splitting alternate instructions'
H103FED3C5FE8: '透過分割替代指令來提升程式碼品質'
# 'In all cases'
HCC1A697CD02F: '在所有情況下'
# 'In conjunection with -type-index and -id-index, dumps the entire dependency graph for the specified index instead of just the single record with the specified index'
H835459E7E97D: '與-type-index和-id-index一同使用時，會傾印指定索引的完整依賴關係圖，而非僅傾印具有指定索引的單一紀錄'
# "In profiling mode like sampleFDO, if a function doesn't have profile, we cannot tell the function is cold for sure because it may be a function newly added without ever being sampled. With the flag enabled, compiler can put such profile unknown functions into a special section, so runtime system can choose to handle it in a different way than .text section, to save RAM for example. "
H4571B587B651: '在sampleFDO等剖析模式下，若函數沒有剖析資料，我們無法確定該函數一定是冷函數（可能為未被採樣的新增函數）。啟用此選項後，編譯器會將這些剖析資訊未知的函數放入特殊區段，讓執行階段系統能以與.text區段不同的方式處理，例如節省記憶體。'
# 'In the Lint pass, abort on errors.'
H4B98027DD134: '在Lint pass中，遇到錯誤時終止。'
# 'In the OpenMP data clauses treat `a(N)` as `a(N:N)`.'
H1CA9E31B3F5D: '在OpenMP資料子句中，將`a(N)`視為`a(N:N)`處理。'
# 'In the dump requested by -dump-input, print <N> input lines\nbefore and <N> input lines after any lines specified by\n-dump-input-filter.  When there are multiple occurrences of\nthis option, the largest specified <N> has precedence.  The\ndefault is 5.\n'
HEB48ED43B50E: '在由-dump-input請求的傾印中，為任何被-dump-input-filter指定的行列前後各輸出 <N> 行輸入內容。若此選項被多次指定，則取最大的 <N> 值為優先。預設值為 5。\n'
# "In the dump requested by -dump-input, print only input lines of\nkind <value> plus any context specified by -dump-input-context.\nWhen there are multiple occurrences of this option, the <value>\nthat appears earliest in the list below has precedence.  The\ndefault is 'error' when -dump-input=fail, and it's 'all' when\n-dump-input=always.\n"
H9104E1DEC417: '在由-dump-input請求的傾印中，僅輸出指定類型 <value> 的行，以及由-dump-input-context指定的上下文內容。若此選項被多次指定，則列表中最早出現的 <value> 值為優先。當-dump-input=fail時預設值為 "error"，而-dump-input=always時預設值為 "all"。\n'
# 'In the report, sort the timers in each group in wall clock time order'
H2F13A69F022D: '在報告中，按牆面時間順序對每個計時器組的計時器進行排序'
# 'Include BLOCKINFO details in low level dump'
H27C5E3DE841C: '在低階傾印中包含BLOCKINFO詳細資料'
# "Include PTX for the following GPU architecture (e.g. sm_35) or 'all'. May be specified more than once."
H2031AC36E8FB: '為下列GPU架構（如sm_35）包含PTX，或指定 "all"。此選項可指定多於一次。'
# 'Include Parameters in templates.'
H8654E7CEAC51: '包含模板中的參數。'
# 'Include all attributes.'
H5307C43E1D9E: '包含所有屬性。'
# 'Include and chain a header file after turning it into PCH'
HBFEBA9B95050: '包含並連接轉換為PCH後的標頭檔'
# 'Include brief documentation comments in code-completion results.'
H235F6D6F7048: '在程式碼補充結果中包含宏內部的簡短文件註解。'
# 'Include code completion results which require small fix-its.'
HFB6D833443A2: '在程式碼補充結果中包含需要小修正的結果。'
# 'Include code patterns in code-completion results'
H22A7B204F988: '在程式碼補充結果中包含程式碼模式'
# 'Include comments from within macros in preprocessed output'
H6B3D5AD18D24: '在預處理輸出中包含宏內部的註解'
# 'Include comments in preprocessed output'
H5CEC03939D7C: '在預處理輸出中包含註解'
# 'Include declaration types in AST dumps'
H327A3B852BC1: '在AST傾印中包含宣告類型'
# 'Include default header file for OpenCL and HLSL'
H5BEB3A92485B: '為OpenCL和HLSL包含預設標頭檔'
# 'Include file before parsing'
H9043E8EF9CD8: '解析前包含文件'
# "Include line table offset in function's debug info and emit end sequence after each function's line data."
H98EA6A67A95E: '將函數的除錯資訊中包含行表偏移，並在每個函數的行資料後發送結束序列。'
# 'Include macros from file before parsing'
H36D4DE65DD21: '在程式碼補完結果中包含來自文件的宏'
# 'Include macros in code-completion results'
H3EC7A0C589B9: '在程式碼補完結果中包含宏'
# 'Include module files in dependency output'
H1900641C3AE2: '在依賴項輸出中包含模組文件'
# 'Include only compilands those which match a regular expression'
H077919CD113F: '僅包含符合正規表示式的編譯單元'
# 'Include only symbols which match a regular expression'
HC57ED85CA0C0: '僅包含符合正規表示式的符號'
# 'Include only types which match a regular expression'
HF1FE163F1EFB: '僅包含符合正規表示式的類型'
# 'Include path for coverage check.'
HCF44564AEDD8: '覆蓋檢查的路徑'
# 'Include precompiled header file'
HCCC9D73787DC: '包含預編譯標頭文件'
# 'Include system headers in dependency output'
HA0C79FE37C8B: '在依賴項輸出中包含系統標頭'
# 'Include what you use. Insert the owning header for top-level symbols, unless the header is already directly included or the symbol is forward-declared'
H8E18AB6F55BF: '包含您所使用的。為頂層符號插入所有權標頭，除非該標頭已直接包含或該符號已被前置宣告'
# 'Incorporate CUDA device-side binary into host object file.'
HC64F11374476: '將CUDA裝置端二進位碼整合至主物件文件中。'
# 'Increase alignment of LDS if it is not on align boundary'
H6B6D9E0BE911: '若未對齊，則增加LDS的對齊值'
# "Increases 'x86-br-merging-base-cost' in cases that it is likely that all conditionals will be executed. For example for merging the conditionals (a == b && c > d), if its known that a == b is likely, then it is likely that if the conditionals are split both sides will be executed, so it may be desirable to increase the instruction cost threshold. Set to -1 to never merge likely branches."
H9238554A10FA: "在所有條件式可能都會執行的情況下，增加 'x86-br-merging-base-cost' 的值。例如在合併條件式 (a == b && c > d) 時，若已知 a == b 是高機率執行，則條件式若被分割成兩邊執行時，可能需要提高指令成本閾值。設為-1將永遠不合併高機率分支。"
# "Increases 'x86-br-merging-base-cost' in cases that the target supports conditional compare instructions."
H0EFC5555FAAB: "在目標支援條件式比較指令時，增加 'x86-br-merging-base-cost' 的值。"
# 'Incremental depth computation will be used for basic blocks with more instructions.'
HE1566572AE0C: '對指令數量較多的基本區塊，使用遞增深度計算。'
# 'Index of module to extract'
H61BCB37228FB: '要提取的模組索引'
# 'Indicate the sample profile being used is flattened, i.e., no inline hierarchy exists in the profile'
H8CEB9B04AD89: '指示使用的樣本剖析已展平，即剖析中不存在內聯層級結構'
# 'Indirect access memory instruction weight'
H4459013C64C1: '間接存取記憶體指令權重'
# 'Induction Variable Users'
HCAD9EC424CF6: '歸納變數使用者'
# 'Infer address spaces'
H384231A2B40A: '推論地址空間'
# 'Infer counts from stale profile data.'
H68A503AAE479: '根據過時的剖析資料推論計數。'
# 'Infer missing call frames due to compiler tail call elimination.'
H3DAC7DFCC466: '由於編譯器尾呼叫消除而推論缺失的呼叫框架。'
# 'Infer nuw/nsw flags using context where suitable'
H6B2FAC7DF345: '在適合的上下文中使用nuw/nsw旗標進行推論。'
# 'Inheritance.'
H21B03FF2F5DB: '繼承。'
# 'Inhibit optimization of S->D register accesses on A15'
H9EE07FA9B2FD: '抑制A15上S->D寄存器存取的優化'
# 'Init Undef Pass'
HA592C8476F8C: '初始化Undef Pass'
# "Initialize trivial automatic stack variables. Defaults to 'uninitialized'"
H413F6C855E54: "初始化簡單的自動堆疊變數。預設值為 'uninitialized'"
# 'Inject absolute symbol definitions (syntax: <name>=<addr>)'
HD553F9022403: '注入絕對符號定義（語法：<name>=<addr>）'
# 'Inject symbol aliases (syntax: <alias-name>=<aliasee>)'
H4CF0C6E38779: '注入符號別名（語法：<alias-name>=<aliasee>）'
# 'Inline all applicable functions on the device.'
H843E2B29FDA6: '內聯裝置上所有適用的函數。'
# 'Inline all functions early'
HBFFBF85B1F6E: '提前內聯所有函數'
# "Inline cold call sites in profile loader if it's beneficial for code size."
H86BDD048441C: '如果對程式碼大小有益，則在剖析載入器中內聯冷呼叫位址。'
# 'Inline functions as deemed beneficial by the compiler'
H648E731FB641: '內聯編譯器認為有益的函數'
# 'Inline functions which are (explicitly or implicitly) marked inline'
H8CD71C20FEE1: '內聯明確或隱式標記為內聯的函數'
# 'Inline shadow poisoning for blocks up to the given size in bytes.'
HD3284F467146: '對給定大小（以位元組為單位）的區塊進行陰影毒化內聯。'
# 'Inline suitable functions'
H8AADDFE804BD: '內聯合適的函數'
# 'Inline threshold for device compilation for CUDA/HIP'
H94D1EB14515E: 'CUDA/HIP裝置編譯的內聯閾值'
# 'Inlined function.'
H5766708CD3DD: '已內聯的函數。'
# 'Inlinee lines (DEBUG_S_INLINEELINES subsection)'
H605540E4F837: '內聯函數的行（DEBUG_S_INLINEELINES 子區段）'
# 'Inliner for always_inline functions'
H228DE039DDE2: '總是內聯函數的內聯器'
# 'Inner loop block size threshold to analyze in unroll for AMDGPU'
H2139A958B6DF: 'AMDGPU在展開時分析的內層迴圈區塊大小閾值'
# 'Inplace edit <file>s'
H1E18B41D725B: '原地編輯 <file> 檔案'
# 'Inplace edit <file>s, if specified.'
H469713E2DE1D: '原地編輯 <file> 檔案，若指定的話。'
# 'Input JSON stream encoding'
HDA67A1195E8E: '輸入 JSON 流編碼'
# 'Input file. Can be specified multiple times for multiple input files.'
H5D0C7337A0AA: '輸入檔案。可指定多次以指定多個輸入檔案。'
# "Input file. The format is an array of contexts.\nEach context is a dictionary with the following keys:\n'Guid', mandatory. The value is a 64-bit integer.\n'Counters', mandatory. An array of 32-bit ints. These are the counter values.\n'Contexts', optional. An array containing arrays of contexts. The context array at a position 'i' is the set of callees at that callsite index. Use an empty array to indicate no callees."
H53610FB0F715: "輸入檔案。格式為上下文的陣列。\n每個上下文是一個包含以下鍵的字典：\n'Guid'，強制指定。值為 64 位元整數。\n'Counters'，強制指定。32 位元整數的陣列。這些是計數器值。\n'Contexts'，選擇性指定。包含陣列的陣列。位置 'i' 的上下文陣列表示該調用位址索引的被呼叫者集合。使用空陣列表示無被呼叫者。"
# "Input language ('ir' or 'mir')"
HAAA3662FD097: '輸入語言（"ir" 或 "mir"）'
# 'Input lines with annotations'
H7B5B0A60C876: '帶註解的輸入行'
# 'Input lines with starting points of annotations'
H2C5EEFB1318C: '註解起始點的輸入行'
# 'Input lines with starting points of error annotations'
H738B96DDE138: '錯誤註解起始點的輸入行'
# 'Input remark format to parse'
H719353F24FE9: '要解析的註記輸入格式'
# 'Insert BLOCK/LOOP/TRY/TRY_TABLE markers for WebAssembly scopes'
H7D3A208C7E5E: '在 WebAssembly 作用域中插入 BLOCK/LOOP/TRY/TRY_TABLE 標記'
# 'Insert CFI remember/restore state instructions'
H6E95A98450BA: '插入 CFI 記憶/恢復狀態指令'
# 'Insert KCFI indirect call checks'
H9190E8521B57: '插入 KCFI 間接呼叫檢查'
# 'Insert XRay ops'
HB3BFBF584BC3: '插入 XRay 操作'
# 'Insert a break point on the last enabled count of a chunks list'
H14F2710F0183: '在 chunks 列表的最後一個啟用計數處插入中斷點'
# 'Insert a specific header. This should run with STDIN mode.\nThe result is written to stdout. It is currently used for\neditor integration. Support YAML/JSON format:\n  -insert-header="{\n     FilePath: "/path/to/foo.cc",\n     QuerySymbolInfos: [\n       {RawIdentifier: foo,\n        Range: {Offset: 0, Length: 3}}\n     ],\n     HeaderInfos: [ {Headers: "\\"foo_a.h\\"",\n                     QualifiedName: "a::foo"} ]}"'
HAF484669F973: '插入特定標頭。此選項應與 STDIN 模式一起使用。\n結果寫入標準輸出。目前用於編輯器整合。支援 YAML/JSON 格式：\n  -insert-header="{\n     FilePath: "/path/to/foo.cc",\n     QuerySymbolInfos: [\n       {RawIdentifier: foo,\n        Range: {Offset: 0, Length: 3}}\n     ],\n     HeaderInfos: [ {Headers: "\\"foo_a.h\\"",\n                     QualifiedName: "a::foo"} ]}"'
# 'Insert calls to __dfsan_*_callback functions on data events.'
HBF62B008B7B5: '在資料事件上插入對 __dfsan_*_callback 函數的呼叫。'
# 'Insert calls to __dfsan_nonzero_label on observing a parameter, load or return with a nonzero label'
HCF1838FEBC0F: '在觀察到帶有非零標籤的參數、載入或返回時插入__dfsan_nonzero_label調用'
# 'Insert calls to callback functions on conditionals.'
H462621715E94: '在條件式上插入回呼函數的調用'
# 'Insert calls to callback functions on data reaching a function.'
H874EB16726E7: '在資料到達函數時插入回呼函數的調用'
# 'Insert calls to fentry at function entry (x86/SystemZ only)'
H5602F1E7FC9F: '在函數入口處插入fentry調用（僅限x86/SystemZ）'
# 'Insert checks for constant shadow values'
HEF594A46B3BD: '插入對常數陰影值的檢查'
# 'Insert fentry calls'
HCD006A416E6E: '插入fentry調用'
# 'Insert instructions into the prologue for storing into the stack ring buffer'
H46F958F6D7F3: '在函數序論中插入指令以將資料存入堆疊環狀緩衝區'
# 'Insert instructions into the prologue for storing into the stack ring buffer directly'
H31D52AECD84E: '在函數序論中直接插入指令以將資料存入堆疊環狀緩衝區'
# 'Insert pseudo probe annotations for value profiling'
H219A8D7D9F81: '插入值剖析用的pseudo probe註解'
# 'Insert required mode register values'
HA0E87197EB1B: '插入必要的模式寄存器值'
# 'Insert sanitizers on OptimizerEarlyEP.'
HC54CCA49CF20: '在OptimizerEarlyEP插入sanitizer。'
# 'Insert stack protectors'
H2189E21FAD58: '插入堆疊保護器'
# 'Insert stores for EH state numbers'
HAFD53ADD3CBA: '插入存儲例外處理（EH）狀態編號'
# 'Insert symbols at valid longjmp targets for /guard:cf'
H36BD6FBCD02B: '在/guard:cf的有效longjmp目標處插入符號'
# 'Insert symbols at valid targets for /guard:ehcont'
H071F81C54D78: '在/guard:ehcont的有效目標處插入符號'
# 'Insert the experimental `assertalign` node.'
H893CAC606686: '插入實驗性的`assertalign`節點。'
# 'Insert vsetvlis before vmvNr.vs to ensure vtype is valid and vill is cleared'
H0091B7D0D6C7: '在vmvNr.vs之前插入vsetvlis指令以確保vtype有效並清除vill'
# 'Instantiate templates already while building a PCH'
H9EE0E3239942: '在建立PCH時提前實例化模板'
# 'Instead of emitting the pipelined code, annotate instructions with the generated schedule for feeding into the -modulo-schedule-test pass'
HD7DD1AFC4508: '代替生成管線程式碼，用產生的排程註解指令，以便供-modulo-schedule-test pass使用'
# 'Instead of expanding system headers when emitting preprocessor output, preserve the #include directive. Useful when producing preprocessed output for test case reduction. May produce incorrect output if preprocessor symbols that control the included content (e.g. _XOPEN_SOURCE) are defined in the including source file. The portability of the resulting source to other compilation environments is not guaranteed.\n\nOnly valid with -E.'
H2BDDF0355665: '在產生預處理輸出時，保留#include指令而非展開系統標頭。此功能在產生測試案例簡化用的預處理輸出時有用。如果包含內容控制的預處理符號（例如_XOPEN_SOURCE）在包含的來源檔案中已定義，可能會產生不正確的輸出。生成的源碼在其他編譯環境中的可移植性無法保證。\n\n僅在-E模式下有效。'
# 'Instead of running LTO, list the dependent libraries in each IR file'
H03C32E83B1C7: '而不是執行LTO，列出每個IR文件中的依賴函式庫'
# 'Instead of running LTO, list the symbols in each IR file'
HA0AFB51F310C: '而不是執行LTO，列出每個IR文件中的符號'
# 'Instead of running LTO, print the mach-o cpu in each IR file'
HE9DA1147E6B8: '而不是執行LTO，印出每個IR文件中的mach-o cpu'
# 'Instead of spilling a variable right away, defer the actual code insertion to the end of the allocation. That way the allocator might still find a suitable coloring for this variable because of other evicted variables.'
HFC03D1ABDED7: '延遲將變數溢出到記憶體，而非馬上執行。實際代碼插入將延後到記憶體配置的末尾。這樣分配器可能仍能為此變數找到合適的著色，因其他被驅逐的變數可能釋出空間'
# 'Instruction Inverse Throughput'
H08AC91953156: '指令反向吞吐量'
# 'Instruction Latency'
HFD97D6973432: '指令延遲'
# "Instruction cutoff for aggressive tail duplication during layout. Used at -O3. Tail merging during layout is forced to have a threshold that won't conflict."
H0BFD5BDD2709: '佈局期間激進尾部複製的指令閾值。用於-O3優化級別。佈局期間的尾部合併將被強制設定不會衝突的閾值'
# "Instruction cutoff for tail duplication during layout. Tail merging during layout is forced to have a threshold that won't conflict."
HCFA67B310DAB: '佈局期間尾部複製的指令閾值。佈局期間的尾部合併將被強制設定不會衝突的閾值'
# 'Instruction latency'
H6CD53FB2E731: '指令延遲'
# 'Instruction schedulers available (before register allocation):'
H4C7D1036B846: '可用的指令排程器（在記憶體配置前）:'
# 'Instructions, lines, scopes, symbols and types.'
HD37C6649C311: '指令、行、作用域、符號和類型。'
# 'Instrument (context sensitive) the IR to generate profile.'
HAAB0AE0AE781: '對IR進行（上下文敏感的）插樁以產生剖析資料'
# 'Instrument - operations with pointer operands'
HDBC71D3E6754: '插樁帶指標操作數的運算'
# 'Instrument <, <=, >, >= with pointer operands'
H6DA2CC308CCE: '插樁帶指標操作數的 <, <=, >, >='
# 'Instrument <, <=, >, >=, - with pointer operands'
H012240D9415C: '插樁帶指標操作數的 <, <=, >, >=, -'
# 'Instrument atomics'
HBB3D2F3D5275: '插樁原子操作'
# 'Instrument code to produce gcov data files (*.gcda)'
HFE3A9A25C96C: '插桩產生gcov資料檔（*.gcda）'
# 'Instrument control-flow architecture protection'
H2142469CBC51: '插樁控制流架構保護機制'
# 'Instrument device library for HIP, which is a LLVM bitcode containing __cyg_profile_func_enter and __cyg_profile_func_exit'
H24C9537239C3: '對HIP的裝置函式庫進行插樁，此LLVM位元組碼包含__cyg_profile_func_enter和__cyg_profile_func_exit'
# 'Instrument floating-point comparisons'
HFB5DAE0497FE: '插樁浮點數比較運算'
# 'Instrument function entry and exit'
H744C2AF9F0F5: '插樁函數的進入和退出'
# 'Instrument function entry only, after inlining, without arguments to the instrumentation call'
H10B2DF0B7A61: '僅插樁內嵌後函數的進入，且不帶插樁呼叫的引數'
# 'Instrument function entry with call to __CheckForDebuggerJustMyCode'
H38C50073F978: '插樁函數的進入，並呼叫 __CheckForDebuggerJustMyCode'
# 'Instrument function entry/exit with calls to e.g. mcount() (post inlining)'
H41E9F3846338: '插桩函數，並呼叫例如 mcount()（在內嵌後）'
# 'Instrument functions with a call to __CheckForDebuggerJustMyCode'
H179F36D1CDA5: '插樍函數，並呼叫 __CheckForDebuggerJustMyCode'
# 'Instrument globals'
HF9B96A5EACA6: '插樁全域變數'
# 'Instrument memintrinsics (memset/memcpy/memmove)'
HE6033F8FFDF9: '插樁記憶體內建函數（memset/memcpy/memmove）'
# 'Instrument memory accesses'
H9382264E0AFD: '插樁記憶體存取'
# "Instrument only functions from files where names don't match all the regexes separated by a semi-colon"
HD8259B6217C3: '僅插樁來自檔名不符合所有以分號分隔之正規表示式之函數'
# 'Instrument only functions from files where names match any regex separated by a semi-colon'
H261C37210502: '僅插樁來自檔名符合任一以分號分隔之正規表示式之函數'
# 'Instrument scalar stack variables'
HC15A017384F6: '插樁標量堆疊變數'
# 'Instrument the IR to generate profile.'
H5521F08582E8: '插樁IR以產生剖析資料'
# 'Instrument the same temp just once'
H47FE01195CE1: '同一臨時值僅插樁一次'
# 'Instrumentation profile (default)'
H8B8FBAF3F224: '插樁剖析（預設值）'
# 'Intel SVML library'
H43C24287102B: 'Intel SVML 函式庫'
# 'Interchange if you gain more than this number'
H1A5217DD30CE: '當獲利超過此數值時進行交換'
# 'Internal Options'
HE6B42A71FEB4: '內部選項'
# 'Internal and debugging options'
H1AFE239C87EF: '內部與除錯選項'
# 'Internal traces and extra debugging code.'
HFC2113D2B3C3: '內部追蹤及額外除錯程式碼'
# 'Internalize linked symbols'
H4254AEAF9E4E: '內部化已連結的符號'
# 'Intrinsics Generator Options'
H4BD784F50D5F: '內在函數產生器選項'
# 'Introduce mul24 intrinsics in AMDGPUCodeGenPrepare'
H3C667C2E6C53: '在AMDGPUCodeGenPrepare中引進mul24內在函數'
# 'Invalid code ranges.'
H1F42CA5A3D9B: '無效的代碼範圍。'
# 'Invalid symbol coverages values.'
H3E269D60065B: '無效的符號覆蓋值。'
# 'Invalid symbol locations.'
H5E97A467E1AD: '無效的符號位置。'
# 'Issue call to specified function rather than a trap instruction'
HA69FCF5CDF0A: '呼叫指定函數而非trap指令'
# 'Iterate to a fixed point when attempting to convert reg-reg instructions to reg-imm'
HD223D51415E6: '嘗試將寄存器-寄存器指令轉換為寄存器-立即數時，迭代到固定點'
# 'Iterative inference: delta convergence precision; smaller values typically lead to better results at the cost of worsen runtime'
H1328F2EA33BA: '反覆推理：delta收斂精度；較小的值通常能獲得更好的結果，但會以增加執行時間為代價'
# 'Iterative inference: maximum number of update iterations per block'
H5F6BCC565010: '反覆推理：每個區塊的最大更新迭代次數'
# 'JIT the code and run it by invoking the main function'
HC922A3A5E7D1: '將代碼 JIT 化並透過調用 main 函數執行它'
# 'JITLink Options'
H759F3B87058B: 'JITLink選項'
# 'JSON format'
H5766BFD5841D: 'JSON格式'
# 'Join isolated components having positive flow.'
HA5D28D00BB60: '連接具有正向流程的隔離元件。'
# 'Jump score power (when --split-strategy=cdsplit)'
H4F864F9914B4: '跳轉評分次方（當--split-strategy=cdsplit時）'
# 'Just print the preprocessed file'
H19C52BC87B22: '僅列印預處理後的檔案'
# 'Just run preprocessor, no output (for timings)'
HA774A3EF0AA6: '僅執行預處理器，不輸出（用於計時）'
# 'Kaleidoscope example program\n'
HCF3536F4FAAB: 'Kaleidoscope範例程式\n'
# 'Keep all benchmarks (default)'
HD3F623D56EDC: '保留所有基準測試（預設）'
# 'Keep all non-cold contexts (increases cloning overheads)'
H4544ED3678BF: '保留所有非冷卻的上下文（會增加複製開銷）'
# 'Keep aside the last <num-test-traces> traces in the profile when computing the function order and instead use them to evaluate that order'
H77D85A9D26A6: '在計算函數順序時，將分析中的最後 <num-test-traces> 個追蹤資料保留一旁，並改用它們來評估該順序'
# 'Keep copies of symbols in LTO indexing'
HB94AF3670BCE: '在 LTO 索引中保留符號的複本'
# 'Keep going on errors encountered'
H418BF6CA6A97: '在遇到錯誤時繼續'
# 'Keep going on errors encountered in trace 1'
H99638570EFA7: '在第一個跡蹟遇到錯誤時繼續'
# 'Keep going on errors encountered in trace 2'
HCFE6CEB4DFCA: '在第二個跡蹟遇到錯誤時繼續'
# 'Keep initializers of constants'
H36ACE3809A61: '保留常數的初始化器'
# 'Keep max reading'
H5A60CCC0248E: '保留最大讀數'
# 'Keep min reading'
H6EAFD9A719C6: '保留最小讀數'
# 'Keep only the benchmarks that *DO* involve memory'
HF9706AF3813D: '只保留涉及記憶體的基準測試'
# 'Keep only those benchmarks that do *NOT* involve memory'
H135A99676AA8: '只保留不涉及記憶體的基準測試'
# 'Keep readings set with min-variance'
H09D9C8B784B4: '保留具有最小方差的讀數'
# 'Keep static const variables even if unused'
H6813EA88BF1D: '即使未使用，也保留 static const 變數'
# 'Keep the last K contexts while merging cold profile. 1 means the context-less base profile'
H3B3B98C36252: '在合併冷剖面時保留最後 K 個上下文。1 表示無上下文的基礎剖面'
# 'Keep the last K contexts while merging profile. -1 means no depth limit.'
HE51374D52FCC: '在合併剖面時保留最後 K 個上下文。-1 表示無深度限制'
# 'Keep the last K contexts while merging unsymbolized profile. -1 means no depth limit.'
HCA7356B0D5FB: '在合併無符號剖面時保留最後 K 個上下文。-1 表示無深度限制'
# 'Keep the last K frames while merging cold profile. 1 means the context-less base profile'
H4AC5A2FF5CAD: '在合併冷剖面時保留最後 K 個框架。1 表示無上下文的基礎剖面'
# 'Kernel code model'
H99C64FCE935F: '核心代碼模型'
# 'Kernel limit wave threshold in %'
H670F8AEC39A0: '以百分比表示的核心限波閾值'
# 'Kind of debug info to add'
HBD02ACC04B34: '要添加的除錯資訊類型'
# 'LCSSA Verifier'
HF121CA5D89C7: 'LCSSA 驗證器'
# 'LLDB Instrumentation Generator'
H3C61B845C07E: 'LLDB 插樁產生器'
# 'LLJITDumpObjects'
H6958140CABBB: 'LLJIT 物件傾印工具'
# 'LLJITWithCustomObjectLinkingLayer'
H632B9B1CBCE5: 'LLJIT 帯有自訂物件連結層'
# 'LLJITWithGDBRegistrationListener'
HB6D370668767: 'LLJIT 帯有GDB註冊監聽器'
# 'LLJITWithInitializers'
HACE516CC94B0: 'LLJIT 帯有初始值設定'
# 'LLJITWithLazyReexports'
H3A104CF605C4: 'LLJIT 帯有懶惰重導出'
# 'LLJITWithObjectCache'
H71A8C9D07573: 'LLJIT 帯有物件快取'
# 'LLJITWithObjectLinkingLayerPlugin'
H748539F4EA26: 'LLJIT 帯有物件連結層外掛'
# 'LLJITWithRemoteDebugging'
H3A8FDD7C38FF: 'LLJIT 帯有遠端除錯'
# 'LLJITWithThinLTOSummaries'
HE8A81BB7479F: 'LLJIT 帯有ThinLTO摘要'
# 'LLVM C++ ABI Data Dumper\n'
HEF94C326E777: 'LLVM C++ ABI 資料傾印工具\n'
# 'LLVM C++ mangled name remapper\n'
H374D96C0B2FD: 'LLVM C++ 裝飾名稱重新映射器\n'
# 'LLVM Contextual Profile Utils\n'
H96B79F1155FF: 'LLVM 情境剖析工具\n'
# 'LLVM IR Similarity Visualizer\n'
H1B7F78E6F996: 'LLVM IR 相似性視覺化工具\n'
# 'LLVM OpenMP'
H6A5AC73C091C: 'LLVM OpenMP'
# 'LLVM PDB Dumper\n'
HD0867800CD16: 'LLVM PDB 傾印工具\n'
# 'LLVM automatic testcase reducer.\n'
HF2C9C9289AA4: 'LLVM 自動測試案例簡化器。\n'
# 'LLVM automatic testcase reducer. See\nhttp://llvm.org/cmds/bugpoint.html for more information.\n'
H28E8E607A645: 'LLVM 自動測試案例簡化器。更多資訊請參閱 http://llvm.org/cmds/bugpoint.html\n'
# 'LLVM code coverage tool\n'
HB94353E136F7: 'LLVM 程式碼覆蓋率工具\n'
# 'LLVM module splitter\n'
H99370B462DED: 'LLVM 模組分割器\n'
# 'LLVM profile data\n'
H799B04E164DC: 'LLVM 剖析資料\n'
# 'LMUL argument must be in the range [0,3] or [5,7]'
H3949F7728682: 'LMUL 參數必須在範圍 [0,3] 或 [5,7]'
# 'LSR search space complexity limit'
H6C951DA0F280: 'LSR 搜尋空間複雜度限制'
# 'LTO Options'
H45ADD610F25F: 'LTO 選項'
# 'LTO requires -fuse-ld=lld'
H1F6F6CBC7560: 'LTO 需要 -fuse-ld=lld'
# 'Label.'
H213B873A2E3C: '標籤。'
# 'Lanai DAG->DAG Pattern Instruction Selection'
HF0BD56FB7903: 'Lanai DAG→DAG 模式選取指令'
# 'Lanai memory ALU combiner pass'
H6ECAF3A1B377: 'Lanai 記憶體 ALU 組合器 pass'
# 'Language standard to compile for'
HC9609252D3B1: '編譯目標的語言標準'
# 'Large code model'
H6118BEDCF561: '大型程式碼模型'
# 'Large stride memory access threshold'
H0DDCC23DCFC1: '大型步幅記憶體存取閾值'
# 'Large stride memory access weight'
HD5651F61773D: '大型步幅記憶體存取權重'
# 'Last chance recoloring max depth'
HF4F4F97F3F0A: '最後機會重新著色最大深度'
# 'Last chance recoloring maximum number of considered interference at a time'
HB5BF2EA66D0A: '最後機會重新著色每次考慮干擾的最大數量'
# 'Launch an out-of-process executor to run code'
HB7F275AE5070: '啟動外部進程執行器來執行代碼'
# 'Lazy Block Frequency Analysis'
HAEAE6F9C4ECD: '惰性區塊頻率分析'
# 'Lazy Branch Probability Analysis'
H0F9273E7A928: '惰性分支概率分析'
# 'Lazy Machine Block Frequency Analysis'
H58403538D0D3: '惰性機器區塊頻率分析'
# 'Lazy Value Information Analysis'
HD066D1FABC77: '惰性值資訊分析'
# 'Least BB number of huge function.'
H5201BDD0F5FF: '大型函數的基本區塊最少數量。'
# 'Leave out unnecessary information when printing MIR'
HEE7C41A11713: '列印MIR時省略不必要的資訊'
# "Legalize the Machine IR a function's Machine IR"
H082594DE8633: '使函數的Machine IR符合規範的Machine IR'
# 'Level of field padding for AddressSanitizer'
H02387EE95AC8: 'AddressSanitizer的欄位填充等級'
# 'Lex file in raw mode and dump raw tokens'
H9BBDD925BA53: '以原始模式詞法分析文件並輸出原始記號'
# 'Lex tokens from a .s file'
H4216F66AFBE5: '從.s文件中詞法分析記號'
# 'Lexical block.'
HDAAEFA6A8637: '詞法區塊。'
# 'Lexical scope level (File=0, Compile Unit=1).'
H7F636BA87B45: '詞法作用域層級（File=0，Compile Unit=1）。'
# 'Libraries to link dynamically'
H9E0097DC803F: '動態連結的程式庫'
# "Like 'ExecutorNative' if ORC runtime provided, otherwise like 'GenericIR'"
H4792AD158E44: '若提供ORC執行階段則類似 "ExecutorNative"，否則類似 "GenericIR"'
# 'Like -MD, but also implies -E and writes to stdout by default'
H09E4A86636C3: '類似-MD，但同時隱含-E，並預設寫入stdout'
# 'Like -MMD, but also implies -E and writes to stdout by default'
H3264A1580B97: '類似-MMD，但同時隱含-E，並預設寫入stdout'
# 'Like -O2 but optimize for code size above all else. Similar to clang -Oz. Same as -passes="default<Oz>"'
H2F3FC31B4B90: '類似-O2，但優先考慮程式碼大小。類似clang -Oz。等同於-passes="default<Oz>"'
# 'Like -O2 but size-conscious. Similar to clang -Os. Same as -passes="default<Os>"'
H17C4D6C7AE33: '類似-O2，但注重大小。類似clang -Os。等同於-passes="default<Os>"'
# 'Like -finstrument-functions, but insert the calls after inlining'
H71DE1A83F0E0: '類似-finstrument-functions，但將函數呼叫插入在內聯後'
# 'Like -fmodules-decluse but requires all headers to be in modules'
H9B04279148C1: '類似-fmodules-decluse，但要求所有標頭檔均在模組中'
# "Like -fno-semantic-interposition but don't use local aliases"
H1E8DA2527D1D: '類似-fno-semantic-interposition，但不使用本地別名'
# 'Like -printlineinfo but does not load the object first'
H4419DBB99339: '類似-printlineinfo，但不會先載入物件檔'
# 'Like /Z7'
H4FD8854D9F4E: '類似/Z7'
# 'Like /showIncludes but omit system headers'
H688724C80945: '類似/showIncludes，但省略系統標頭檔'
# 'Limit all regclasses to N registers'
H63DA69AD987D: '將所有regclasses限制為N個寄存器'
# 'Limit block size to analyze in load/store widening pass'
H7ECB2D63C850: '限制在 load/store widening pass 中分析的區塊大小'
# 'Limit cases to analyze when converting a switch to select'
H4850FF8E3DC7: '限制在將 switch 轉換為 select 時分析的案例數量'
# 'Limit debug information produced to reduce size of debug binary'
H538935517F09: '限制產生的除錯資訊以減少除錯二進位檔的大小'
# 'Limit float precision to the given value'
HF96C59869298: '限制浮點數精確度至指定值'
# 'Limit maximum recursion depth when calculating costs of speculatively executed instructions'
H66110CD9CA1F: '計算預測執行指令的代價時限制最大遞迴深度'
# 'Limit on instruction search range in frame index elimination'
HBC1B1C08E702: '在 frame index elimination 中限制指令搜尋範圍'
# 'Limit on the cost of instructions that can be repeated due to loop flattening'
HD92D80EEAC82: '因迴圈展平可重複執行的指令代價限制'
# 'Limit on the number of reused registers in frame index elimination'
H607E68347FE8: '在 frame index elimination 中限制重複使用的暫存器數量'
# 'Limit options in the Modules category to the specified module index'
HB070B9863405: '將模組類別中的選項限制為指定的模組索引'
# 'Limit ready list to N instructions'
H5F2D4380F5BB: '限制就緒清單為 N 指令'
# 'Limit register pressure of scheduled loop'
H7D5776BBBD61: '限制已排程迴圈的暫存器壓力'
# 'Limit the length of PHI chains to lookup'
H44DF903D7B74: '限制要查詢的 PHI 鏈長度'
# 'Limit the number of collected seeds groups in a BB to cap compilation time.'
HCB093C287DF8: '限制一個 BB 中收集的 seeds 群組數量以控制編譯時間。'
# 'Limit the number of instructions to process (0 for no limit)'
H0F105AAF8005: '限制要處理的指令數量（0 表示無限制）'
# 'Limit the number of loads analysed'
H27294DA00A2A: '限制分析的 loads 數量'
# 'Limit the number of operands to inline for Token Factors'
HEA9F8176A261: '限制 Token Factors 的内联運算元數量'
# 'Limit the number of registers available for integer arguments'
HD3D75863FAEB: '限制可用於整數參數的暫存器數量'
# 'Limit the number of times for the same StoreNode and RootNode to bail out in store merging dependence check'
H611EA77C379A: '在儲存合併依存檢查時，限制相同 StoreNode 和 RootNode 的退出次數'
# 'Limit the recursion depth when building a vectorizable tree'
HAF7BB4678550: '在建立向量化樹時限制遞迴深度'
# 'Limit the size of the SLP scheduling region per block'
HEAF5A10A6293: '每區塊限制 SLP 排程區域的大小'
# 'Limit the size of the seed bundle to cap compilation time.'
H4DFB40A73CC1: '限制種子包的大小以限制編譯時間。'
# 'Limits the range of tokens in -check file on which various features are tested. Example --check-lines=3-7 restricts testing to lines 3 to 7 (inclusive) or --check-lines=5 to restrict to one line. Default is testing entire file.'
H2A6188976AA0: '限制在-check文件中測試各項功能的token範圍。例如--check-lines=3-7將測試範圍限制在第 3 到 7 行（包含），或--check-lines=5限制到單一行。預設是測試整個檔案。'
# 'Linalg ODS Gen from YAML'
H78D204B7569D: '從YAML生成Linalg ODS'
# 'Line kind to use when printing lines.'
H1ECE7CAA5A71: '列印行時使用的行類型。'
# 'Line qualifiers (Newstatement, BasicBlock, etc.).'
H20226D797BE3: '行修飾符（Newstatement、BasicBlock等）。'
# 'Line tables'
H4C16BA3AF07D: '行表格'
# 'Linearize DAG, no scheduling'
HD1B44C093366: '線性化DAG，不排程'
# 'Lines (DEBUG_S_LINES subsection)'
H916009E842F5: '行（DEBUG_S_LINES子區段）'
# 'Lines referenced in the debug information.'
H59B1C9901129: '在除錯資訊中引用的行。'
# 'Lines.'
HC7986E72D11E: '行。'
# 'Link Options'
HCC3832473F0F: '連結選項'
# 'Link XRay runtime library when -fxray-instrument is specified (default)'
H3CD4BCB6EB07: '當指定-fxray-instrument時連結XRay執行階段函式庫（預設）'
# 'Link against library X in the library search paths'
HCEDA0BA2279F: '連結搜尋路徑中的函式庫X'
# 'Link against library X in the library search paths with hidden visibility'
H0C1A37003713: '以隱藏可見性連結搜尋路徑中的函式庫X'
# 'Link against library X with hidden visibility'
H7FCFC84F1391: '以隱藏可見性連結函式庫X'
# 'Link and internalize needed symbols from the given bitcode file before performing optimizations.'
H592432E99C1A: '連結並內部化給定位元碼檔中需要的符號，再執行優化。'
# 'Link as a hybrid ARM64X image'
H741A1167C632: '以混合ARM64X影像連結'
# 'Link builtin bitcodes after the optimization pipeline'
HA396158ACBD5: '優化管線後連結內建的位元碼'
# 'Link clang-offload-bundler bundles for HIP'
HB7831777CE51: '為HIP連結clang-offload-bundler封包'
# 'Link device libraries for GPU device compilation'
H585B50C49350: '連結裝置函式庫以進行GPU裝置編譯'
# 'Link only needed symbols'
H7CCE9D08A2A1: '僅連結必要的符號'
# 'Link stack frames through backchain on System Z'
H0C4B76743142: '在System Z通過後鏈接堆疊框架'
# 'Link the LLVM C Library for GPUs'
HD105C9964C21: '為GPU連結LLVM C程式庫'
# 'Link the following file lazily'
HB68406E1D5AC: '遲延連結以下的檔案'
# 'Link the given bitcode file before performing optimizations.'
H1729D1922ED4: '在執行優化之前連結指定的位元碼檔案。'
# 'Link two nested MLIR modules into a single LLVM IR module. Useful if both the host and device code can be run on the same CPU, as in SPIR-V CPU Runner tests.'
HF4FD097D1426: '將兩個嵌套的MLIR模組連結為單一LLVM IR模組。如果主機和裝置代碼可以在同一CPU上執行（例如SPIR-V CPU Runner測試）時很有用。'
# 'Linkage name.'
HC775F1647BB7: '連結名稱。'
# 'Linking with hot/cold operator new interfaces'
H1970EBF2160A: '與熱/冷操作new介面進行連結'
# 'List bundle IDs in the bundled file.\n'
H3D67FC934FB6: '列出封裝檔案中的封裝ID。\n'
# 'List each file/graph name if/when it is linked'
H0D70E4352A2A: '列出在連結時/時的每個檔案/圖形名稱'
# 'List ignored files.'
H1A394A6B07E1: '列出被忽略的檔案。'
# 'List of files with compilation or modularization problems for assistant mode.  This will be excluded.'
H7F26F6260A72: '用於輔助模式的編譯或模組化問題的檔案清單。這些將被排除。'
# 'List of functions to print disassembly for. Accept demangled names only. Only work with show-disassembly-only'
H3054F37FF6EE: '需要列印反組譯的函數清單。僅接受解裝飾名稱。僅與show-disassembly-only一起使用'
# "List of key and value arguments. Required keywords are 'file' and 'triple'."
H45A6C5D3DB8C: "關鍵字和值參數清單。必要關鍵字為 'file' 和 'triple'。"
# 'List of modes to link in by default into XRay instrumented binaries.'
HA0397880FB9D: '預設連結到XRay插樁二進位檔的模式清單。'
# 'List of symbols to export from the resulting object file'
H1BA25E23CBFD: '從產生的物件檔中導出的符號清單'
# 'Live DEBUG_VALUE analysis'
H61CCF64E7BF9: '執行中DEBUG_VALUE分析'
# 'Live Interval Analysis'
H1E8AD554BB44: '活間隔分析'
# 'Live Range Shrink Pass'
H1774992DE87F: '活範圍縮小Pass'
# 'Live Register Matrix'
H01100D0853E2: '活寄存器矩陣'
# 'Live Stack Slot Analysis'
H2C770BB0409B: '活躍堆疊儲存區分析'
# 'Live Variable Analysis'
HDDDE0A8181A8: '活躍變數分析'
# 'Load MIR Sample Profile'
HE68192F483EE: '載入 MIR 範例剖析'
# 'Load a pch file and use it instead of all code up to and including <filename>'
H2B4B69D546AF: '載入 pch 檔案並以其取代所有代碼直至且包含 <filename>'
# 'Load all members of static archives'
H37DC6D24F9AF: '載入靜態函式庫的所有成員'
# 'Load all members of static archives that implement Objective-C classes or categories, or Swift structs, classes or extensions'
HCC377DE628E7: '載入靜態函式庫中實作 Objective-C 類別或分類，或 Swift 結構、類別或擴充的成員'
# 'Load and verify that a pre-compiled header file is not stale'
H71047E98C4FB: '載入並驗證預編譯標頭檔未過期'
# 'Load bitcode directly into the new debug info format (regardless of input format)'
H5768E297180F: '載入 bitcode 直接到新的除錯資訊格式（不論輸入格式）'
# 'Load dialects from plugin library'
H4452CA7D250C: '從套件程式庫載入語法'
# 'Load module without materializing metadata, then materialize only the metadata'
H43A90C52B97C: '載入模組但不實體化元資料，然後僅實體化元資料'
# 'Load pass plugin from a dynamic shared object file (only with new pass manager).'
HDC805E376CE5: '載入 pass 套件程式（僅適用於新式 pass 管線）'
# 'Load passes from plugin library'
H8D748D07CDD6: '從套件程式庫載入 pass'
# 'Load shadow address into a local variable for each function'
HFDF300DF287B: '為每個函數將陰影位址載入本地變數'
# 'Load target address from GOT'
H9E377C7D35D0: '從 GOT 載入目標位址'
# 'Load the clang builtins module map file.'
H593B89CC5BB8: '載入 clang 內建模組地圖檔。'
# 'Load the named plugin (dynamic shared object)'
HB2664DBBD1D2: '載入指定的套件程式（動態共用物件）'
# 'Load the specified plugin'
H92708A3C1B95: '載入指定的套件程式'
# 'Load this module map file'
HF58B1913A1B8: '載入最初被剖析讀取器跳過的頂層剖析（僅適用於擴展的二進位格式）'
# 'Load top-level profiles that the sample reader initially skipped for the call-graph matching (only meaningful for extended binary format)'
H98AEC89E8CA3: '載入、連結並驗證結果記憶體映像。'
# 'Load, link and verify the resulting memory image.'
H9DA1560B06F8: '載入、連結並驗證結果的記憶體映像。'
# 'Load, link, and execute the inputs.'
H33C79A8E17E5: '載入、連結並執行輸入。'
# 'Load, link, and print line information for each function using the debug object'
HD0FE71B40225: '載入、連結，並使用除錯物件為每個函數列印行資訊。'
# 'Load, link, and print line information for each function.'
HD0F8E4BC3426: '載入、連結，並為每個函數列印行資訊。'
# 'Local Stack Slot Allocation'
H9064C8611F98: '本地堆疊槽位配置'
# 'Local reassignment can yield better allocation decisions, but may be compile time intensive'
HDA7A0257A39E: '本地重新分配可能產生更好的配置決策，但可能需要較多的編譯時間'
# 'Local strategy.'
H69F9DACD1EB4: '本地策略。'
# 'Locations and Variables'
HAAA0526E734E: '位置與變數'
# 'Locations only'
H997812E5B96A: '僅位置'
# "Log action execution to a file, or stderr if  '-' is passed"
H7DDDF7706229: "將動作執行記錄到檔案中，若傳入 '-' 則輸出到標準錯誤"
# 'Look up implicit modules in the prebuilt module path'
H7389FC31B294: '在預建模組路徑中查找隱含模組'
# 'LoongArch DAG->DAG Pattern Instruction Selection'
HCE16825D2625: 'LoongArch DAG→DAG 模式指令選擇管線'
# 'LoongArch Dead register definitions'
HAC29789F40DC: 'LoongArch 未使用的寄存器定義'
# 'LoongArch Merge Base Offset'
H4ADCE551F44A: 'LoongArch 合併基底偏移量'
# 'LoongArch Optimize W Instructions'
HE6925B9D5E46: 'LoongArch 優化W指令'
# 'LoongArch Pre-RA pseudo instruction expansion pass'
HABF2FA12711A: 'LoongArch 預RA 伪指令展開 pass'
# 'LoongArch atomic pseudo instruction expansion pass'
H9277CF038FA3: 'LoongArch 原子伪指令展開 pass'
# 'Loop Data Prefetch'
H4A7486BE5EE1: '迴圈資料預取'
# 'Loop Invariant Code Motion'
H1F7B4F47808C: '迴圈不變程式移動'
# 'Loop Strength Reduction'
HD2B0D185F01F: '迴圈強度削減'
# 'Loop Terminator Folding'
HA587F9DFACE9: '循環終止符摺疊'
# 'Loop over the snippet'
H8CE72D20104F: '循環遍歷程式碼片段'
# 'Loop rescheduling'
H3C5B4019E9D4: '循環重新調度'
# 'Loop-Closed SSA Form Pass'
HA93B03345334: '循環閉合SSA形態Pass'
# "LoopVersioningLICM's minimum allowed percentage of possible invariant instructions per loop"
H9A2539A9680F: 'LoopVersioningLICM每個循環允許的最小可能不變指令百分比'
# "LoopVersioningLICM's threshold for maximum allowed loop nest/depth"
H17B01644371B: 'LoopVersioningLICM對最大允許循環嵌套/深度的閾值'
# 'Loops with a constant trip count smaller than this value will not use the count register.'
H9C4270A71595: '次數小於此值的常數次數循環將不會使用計數寄存器。'
# 'Loops with a constant trip count that is smaller than this value are vectorized only if no scalar iteration overheads are incurred.'
HEB5EC35573F1: '次數小於此值的常數次數循環僅在不會產生標量迭代開銷時才會向量化。'
# 'Low level details'
H736A60384473: '低階細節'
# 'Lower @llvm.global_dtors via `__cxa_atexit`'
H38BCAF8DE61E: '透過__cxa_atexit轉換@llvm.global_dtors'
# 'Lower AArch64 MachineInstrs after legalization'
HAA249D8E7311: '在合法化後轉換AArch64機器指令'
# 'Lower Alloca'
H607A1E54E99B: '轉換Alloca'
# 'Lower GPU ctor / dtors to globals on the device.'
HAFC608781787: '將GPU的建構函數/析構函數轉換為裝置上的全域變數。'
# 'Lower MASSV entries'
HA1CC2E7E8DB7: '轉換MASSV項目'
# "Lower SwitchInst's to branches"
H254491D92394: '轉換SwitchInst為分支'
# 'Lower Unreachable'
H28B0408D99E5: '轉換Unreachable'
# 'Lower aggregate copies, and llvm.mem* intrinsics into loops'
HF50CBF4651A2: '轉換聚合體複製及llvm.mem*內建函數為循環。'
# 'Lower all intrinsic procedure implementation in their own functions'
H898AB0478AF6: '將所有內建程序的實現在各自的函數中轉換。'
# 'Lower allocations to fortran runtime calls'
H567EFB84A4D9: '將分配轉換為Fortran執行階段呼叫。'
# 'Lower arguments (NVPTX)'
H0BEAE5323F8F: '轉換參數（NVPTX）'
# 'Lower atomic intrinsics to non-atomic form'
H691AF9D6E735: '轉換原子內在函數為非原子形式'
# 'Lower atomics of local memory to simple load/stores'
H26EEFC4DB3B1: '轉換本地記憶體的原子操作為基本載入/儲存指令'
# 'Lower bound for a buffer to be considered for stack protection'
HD34EE96BB584: '考慮堆疊保護的緩衝區最小閾值（以位元組為單位）'
# 'Lower ctors and dtors for AMDGPU'
HF7F8D40F075B: '轉換AMDGPU的建構函數和解構函數'
# 'Lower ctors and dtors for NVPTX'
HFEBDC177145F: '轉換NVPTX的建構函數和解構函數'
# 'Lower interleaved memory accesses to target specific intrinsics'
H47470ECDFD4E: '轉換交錯記憶體存取為目標特定內在函數'
# 'Lower invoke and unwind, for unwindless code generators'
H0DB5191C7AE1: '轉換invoke和unwind，適用於無unwind的程式碼產生器'
# 'Lower kernel argument loads in IR pass'
H46087569AE6A: '轉換IR pass中的核準參數載入'
# 'Lower thread local variables'
HCFB0F36689FE: '轉換線程局部變數'
# 'Lower threshold (in bytes) for widening to HVX vectors'
H2F815B7CEA99: '廣展至HVX向量的最小閾值（以位元組為單位）'
# 'Lower to high level FIR'
H5AA0AFC0202E: '轉換為高階FIR'
# 'Lower uses of LDS variables from non-kernel functions'
H08631E6900A9: '轉換非核準函數中對LDS變數的使用'
# 'Lower variables reachable from one kernel, otherwise abort'
H53F0B2E74B9F: '轉換單一核準可達變數，否則中斷'
# 'Lower via HLFIR transformational intrinsic operations such as hlfir.sum'
H6FB7E3DD0B99: '轉換HLFIR轉換內在運算（如hlfir.sum）'
# 'Lower via mixture of above strategies'
HC2846B7FC01C: '轉換為上述策略的組合'
# 'Lower via module struct'
HA8D215D9A1DE: '轉換為模組結構'
# 'Lower via table lookup'
HDC139AA56721: '轉換為表格查詢'
# 'Lowers br_unless into inverted br_if'
H7B5FDAFDDAB0: '將br_unless轉換為反轉的br_if'
# 'M68k DAG->DAG Pattern Instruction Selection'
H81D40D6EAF4E: 'M68k DAG→DAG模式指令選擇'
# 'M68k MOVEM collapser pass'
H0AB275B2A2C5: 'M68k MOVEM合併器pass'
# 'M68k PIC Global Base Reg Initialization'
HD01B16D18C62: 'M68k 位置獨立程式碼全域基寄存器初始化'
# 'M68k pseudo instruction expansion pass'
H8C1C2FF3E960: 'M68k 伪指令展開 pass'
# 'MC Options'
HF844BA7E67B9: 'MC 選項'
# 'MCJIT'
H06F256016480: 'MCJIT'
# 'MIPS DAG->DAG Pattern Instruction Selection'
H4A85ADA9A35B: 'MIPS DAG→DAG 模式指令選擇'
# 'MIPS Specific: Compact branch policy.'
HDB7172F0C6EB: 'MIPS 特定：緊湊分支策略。'
# "MIPS: Don't trap on integer division by zero."
H3C2E18133FF5: 'MIPS：整數除以零時不觸發異常。'
# 'MIPS: Emit R_{MICRO}MIPS_JALR relocation with jalr'
HED32A15E03DE: 'MIPS：在 jalr 指令中發射 R_{MICRO}MIPS_JALR 重新定位。'
# 'MIPS: Expand all branches to long format.'
H441E04A7504F: 'MIPS：將所有分支展開為長格式。'
# 'MIPS: Skip branch expansion pass.'
HDA9370733E14: 'MIPS：跳過分支展開 pass。'
# 'MIPS: Try to allocate variables in the following sections if possible: .rodata, .sdata, .data .'
HE9B7319D8937: 'MIPS：若可能，嘗試將變量分配到以下段中：.rodata、.sdata、.data。'
# 'MIPS: Use gp_rel for data that is not defined by the current object.'
HD75E517CA71E: 'MIPS：對當前物件未定義的數據使用 gp_rel。'
# 'MIPS: Use gp_rel for object-local data.'
H545674F997F2: 'MIPS：對物件局部數據使用 gp_rel。'
# 'MIPS: permit tail calls.'
H0C7FED214ED3: 'MIPS：允許尾調用。'
# 'MIR Printer'
H94EFB069787F: 'MIR 打印機'
# 'MISSED'
HD46F0E6CE802: 'MISSED'
# 'MLIR CPU execution driver\n'
H6CE30C11490B: 'MLIR CPU 執行驅動\n'
# 'MLIR LSP Language Server'
HC4C223FFD5B8: 'MLIR LSP 語言伺服器'
# 'MLIR test case query tool.\n'
H55F5673383F5: 'MLIR 測試案例查詢工具。\n'
# 'MLIR test case reduction tool.\n'
H51C59AF94F1B: 'MLIR 測試案例縮減工具。\n'
# 'MS-style inline assembly is not available: %0'
H730B2A8B0BD8: 'MS風格的內聯組裝語言不可用： %0'
# 'MSF Container Options'
H3C329400C4C7: 'MSF容器選項'
# 'MSF File Options'
H4EFCF40C1C07: 'MSF檔案選項'
# 'MSP430 DAG->DAG Pattern Instruction Selection'
H9B855DBB6F56: 'MSP430 DAG→DAG模式指令選擇'
# 'MVE gather/scattering lowering pass'
HEFE04D3A4063: 'MVE gather/scattering 降階 pass'
# 'MVE lane interleaving'
H439E688DEBCA: 'MVE通道交錯'
# 'MVE tail-predication pass options'
H401525ED37E3: 'MVE尾端預測 pass 選項'
# 'Mach-O: dump the raw contents of the listed segments instead of parsing them:'
HD2ADEEA8E714: 'Mach-O：列印指定段的原始內容而非解析它們：'
# 'Machine Block Frequency Analysis'
H7E1FF2D34591: '機器程式區塊頻率分析'
# 'Machine Branch Probability Analysis'
HDAEAA64E78E7: '機器程式分支概率分析'
# 'Machine CFG Printer Pass'
HEFF257D542EC: '機器程式控制流圖印表機 pass'
# 'Machine Check Debug Module'
H5340142C3573: '機器程式除錯模組檢查'
# 'Machine Common Subexpression Elimination'
H4C5AC03D0280: '機器程式共同子表示式消去'
# 'Machine Copy Propagation Pass'
H4162739F0E51: '機器程式複製傳播 pass'
# 'Machine Cycle Info Analysis'
H573F9920FA64: '機器程式週期資訊分析'
# 'Machine Debugify Module'
H1918B0E46C7D: '機器程式除錯模組轉換'
# 'Machine Dominance Frontier Construction'
HACFFF417BF5C: '機器程式支配邊界建構'
# 'Machine Function Outliner'
HEAF804C2398F: '機器程式函數外提'
# 'Machine Function Printer'
H5377EFCC5465: '機器程式函數印表機'
# 'Machine InstCombiner'
H33E9EB463E41: '機器程式 InstCombiner'
# 'Machine Instruction Scheduler'
H83994F7A225C: '機器指令調度器'
# 'Machine Late Instructions Cleanup Pass'
H85C102FDCCD8: '機器後期指令清理Pass'
# 'Machine Loop Invariant Code Motion'
H4BBB4B53869D: '機器循環不變式程式移動'
# 'Machine Module Information'
HD424C5585BBC: '機器模組資訊'
# 'Machine Natural Loop Construction'
H18E1BBE724BC: '機器自然循環建構'
# 'Machine Sanitizer Binary Metadata'
H981195858AEF: '機器除錯器二進位元元資料'
# 'Machine Strip Debug Module'
HC906EF4D8D67: '機器去除除錯模組'
# 'Machine Trace Metrics'
HD6F5807E2725: '機器追蹤指標'
# 'Machine Uniformity Info Analysis'
HF8ED9A64EFA7: '機器均勻性資訊分析'
# 'Machine code sinking'
H8D9C4D604139: '機器代碼下沉'
# 'Machine instruction scheduler to use'
H6D20879B4B16: '要使用的機器指令調度器'
# 'MachineDominator Tree Construction'
H0EB86F56D320: 'MachineDominator樹建構'
# 'MachineLICM should avoid speculation'
HA9CBAFDEBFAA: 'MachineLICM應避免猜測'
# 'MachineLICM should hoist even cheap instructions'
H98697F2D8341: 'MachineLICM應提升甚至廉價指令'
# 'MachinePostDominator Tree Construction'
H556CF668A622: 'MachinePostDominator樹建構'
# 'Main file name to use for debug info and source if missing'
H28B54D392A83: '若缺少時用於除錯資訊和來源的主要檔案名稱'
# 'Make -gen-asm-parser emit assembly parser #N'
HE5BFEAE0A31B: '要產生組譯器解析器 #N 的 -gen-asm-parser'
# 'Make -gen-asm-writer emit assembly writer #N'
H1EC4E0DFB493: '將StdCall呼叫約定設為預設'
# 'Make StdCall calling convention the default'
H597E577C2DF9: '讓所有剖面計數器更新為原子操作（僅供測試）'
# 'Make all profile counter updates atomic (for testing only)'
HF170445DE3AF: '將StdCall呼叫約定設為預設'
# 'Make an absence of debug location information explicit.'
H9B828535ADE5: '明確指定調試位置資訊的缺失'
# 'Make assembler not emit warnings'
HE1F052382E9E: '禁止組件器發出警告'
# 'Make assembler warnings fatal'
HE5A6B0140C8A: '將組件器警告視為嚴重錯誤'
# 'Make char type unsigned'
H0811C60DAE54: '將char類型視為無符號型別'
# 'Make counter updates atomic'
HF0DF6FDD3F46: '使計數器更新為原子操作'
# 'Make small offsets be this amount for testing purposes'
HA8D9F86D01B4: '設定小偏移量為此值（僅供測試用）'
# 'Make the jump table addresses canonical in the symbol table'
H96E8C8D2BE5D: '在符號表中將跳轉表位址標準化'
# 'Make the x10 register call-saved (AArch64 only)'
HBF2D2B8AB5A7: '將x10寄存器設為呼叫後保留（僅限AArch64）'
# 'Make the x11 register call-saved (AArch64 only)'
H361FBEA409F7: '將x11寄存器設為呼叫後保留（僅限AArch64）'
# 'Make the x12 register call-saved (AArch64 only)'
HC22300ADD634: '將x12寄存器設為呼叫後保留（僅限AArch64）'
# 'Make the x13 register call-saved (AArch64 only)'
H115B747B671D: '將x13寄存器設為呼叫後保留（僅限AArch64）'
# 'Make the x14 register call-saved (AArch64 only)'
H3E53A0765B94: '將x14寄存器設為呼叫後保留（僅限AArch64）'
# 'Make the x15 register call-saved (AArch64 only)'
HBD1C266220AD: '將x15寄存器設為呼叫後保留（僅限AArch64）'
# 'Make the x18 register call-saved (AArch64 only)'
HFB92CC39C02E: '將x18寄存器設為呼叫後保留（僅限AArch64）'
# 'Make the x8 register call-saved (AArch64 only)'
H346589ED29E7: '將x8寄存器設為呼叫後保留（僅限AArch64）'
# 'Make the x9 register call-saved (AArch64 only)'
H2A86BF8B5845: '將x9寄存器設為呼叫後保留（僅限AArch64）'
# 'Make time trace capture verbose event details (e.g. source filenames). This can increase the size of the output by 2-3 times'
HAFFB278A14B8: '在時間追蹤捕獲中包含詳細事件資訊（例如原始檔名稱）。這可能會使輸出大小增加 2-3倍'
# 'Mangling number exceeds limit (65535)'
HB23269E224B2: '裝飾符號編號超過限制（65535）'
# 'Manifest Attributor internal string attributes.'
H94BF7FE1AB16: '顯示Attributor內部的字串屬性'
# 'Manually specify the CUDA feature to use'
HDDA17BF1758B: '手動指定要使用的CUDA功能'
# 'Map file source paths in debug info'
H1AD32AEEC75F: '在除錯資訊中映射檔案來源路徑'
# 'Mapping between default visibility and export'
H9B100E19B599: '默認可見性與export的對應關係'
# 'Margin representing the unused percentage of the register pressure limit'
HC98A7EB598BA: '表示寄存器壓力限制中未使用百分比的邊際'
# 'Mark code section jump table data regions.'
H820E75B4A88C: '標記代碼段跳躍表資料區域。'
# 'Mark cold functions with minsize.'
H17C76AA34906: '以minsize標記冷函數。'
# 'Mark cold functions with optnone.'
H16FE57B8D4DF: '以optnone標記冷函數。'
# 'Mark cold functions with optsize.'
H10A3EEBA4167: '以optsize標記冷函數。'
# 'Mark intrinsics that match the specified regexp as taking alias.scopes, noalias, and tbaa metadata'
H2D0DBCB8116B: '將符合指定正則表達式之內建函數標記為使用alias.scopes、noalias及tbaa元資料'
# 'Mark intrinsics that match the specified regexp as taking an access group metadata'
HFCB2F343E2E0: '將符合指定正則表達式之內建函數標記為使用存取群組元資料'
# 'Mark outline function calls with ColdCC'
H4A447EEA400F: '以ColdCC標記外掛函數呼叫'
# 'Mark some metadata features uncovered in functions with associated no_sanitize attributes.'
H04B3B3707DAA: '將函數中與no_sanitize屬性相關的未使用的部分元資料功能標記。'
# 'Mark the file as not needing an executable stack'
H4B702846F054: '將檔案標記為無需可執行堆疊'
# 'Marked up disassembly of strings of hex bytes'
HEACC40B7D059: '標記過的十六進位字串反組譯'
# 'Match allocation profiles onto existing hot/cold operator new calls'
H6EADDFEDDECF: '將分配配置文件匹配至現有的熱/冷operator new呼叫'
# 'Match functions using namespace and edit distance'
HE4F3BAC888AB: '使用命名空間和編輯距離匹配函數'
# 'Match functions with call graph'
HBB25B5D67EE6: '使用呼叫圖匹配函數'
# 'Match profile with function hash'
H34EA8794C102: '以函數雜湊值匹配配置文件'
# 'Match string for rename'
HFCC0109CD543: '匹配重新命名的字串'
# 'Max #stores to inline memcpy'
HD503383C20D0: '內聯memcpy的最多#儲存數'
# 'Max #stores to inline memmove'
HBA55FF5D30C1: '內聯memmove的最多#儲存數'
# 'Max #stores to inline memset'
H2710D6276878: '最大內聯 memset 的存儲次數'
# 'Max PHIs in BB to duplicate for jump threading'
H877E847520D6: '為跳轉縫合可複製的基本區塊中最大 PHIs 數量'
# 'Max average trip count which will cause loop peeling.'
HF3BB048901AF: '導致迴圈剝皮的最大平均迭代次數'
# 'Max block size to duplicate for jump threading'
HBFBAF7D2C906: '為跳轉縫合可複製的區塊最大大小'
# 'Max coefficients in AddRec during evolving'
H3496AC43AF41: '在演化期間 AddRec 中的最大係數數量'
# 'Max count of stack frame shrink-wraps'
H837664B5CADB: '通過尾調用遞迴搜尋缺失框架的最大深度'
# 'Max depth to recursively search for missing frames through tail calls.'
HF33980EA2977: '在 float2int 中考慮的最大整數位寬（預設=64）'
# 'Max integer bitwidth to consider in float2int(default=64)'
H564282CBC7AC: '整波寄存器配置時的最大 VGPR 數量'
# 'Max num VGPRs for whole-wave register allocation.'
H7B8CA4EA95B5: '使用不變起始值識別迴圈中的載入不變性時，訪問的最大使用次數（預設 = 8）'
# 'Max num uses visited for identifying load invariance in loop using invariant start (default = 8)'
H482EC7115683: '每迴圈最大計數器提升數量以避免過度增加寄存器壓力'
# 'Max number counter promotions per loop to avoid increasing register pressure too much'
H57369D9DCC7A: '可探測的區塊數量以進行可達性分析'
# 'Max number of BBs to explore for reachability analysis'
H59AE85966A2A: '允許在 VRegs 中傳遞 GC 指標元參數的最大數量'
# 'Max number of VRegs allowed to pass GC pointer meta args in'
HFCD4D70A5FD8: '要檢查的地址使用者最大數量'
# 'Max number of address users to look at'
H5E86D74534B7: '允許的最大計數器提升數量'
# 'Max number of allowed counter promotions'
H870A811CD7E4: '單一間接呼叫呼叫點的最大註釋數量'
# 'Max number of annotations for a single indirect call callsite'
HEA902A4CD336: '在提升位置之間的路徑上的基本區塊最大數量（預設 = 4，無限 = -1）'
# 'Max number of basic blocks on the path between hoisting locations (default = 4, unlimited = -1)'
H48EFC5F46396: '搜尋尋找縫合路徑的最大區塊數量'
# 'Max number of blocks searched to find a threading path'
HF1261B57416B: '可部分內聯的最大區塊數量'
# 'Max number of blocks to be partially inlined'
H7AAFBCD2FD5C: '在枚舉切換周圍的路徑時，訪問的最大區塊數量'
# 'Max number of blocks visited while enumerating paths around a switch'
H3917E93C3F69: '在枚舉開關周圍的路徑時，所訪問的區塊最大數量'
# "Max number of blocks we're willing to speculate on (and recurse into) when deducing if a value is fully available or not in GVN (default = 600)"
HCC0B004EA3EE: '在GVN中推斷值是否完全可用時，願意推測（並遞迴進入）的區塊最大數量（預設值=600）'
# 'Max number of dependences to attempt Load PRE (default = 100)'
HAEF9EFC0D587: '嘗試Load PRE時的依存關係最大數量（預設值=100）'
# 'Max number of devirtualizations for devirt module pass'
H37CF7FA70B53: 'devirt模組pass的虛函數化解最大數量'
# 'Max number of duplications by CHR for a region'
HB5C21E0295E9: 'CHR為某一區域進行複製的最大數量'
# 'Max number of instructions to hoist (default unlimited = -1)'
H1E95E88763B1: '可提升的指令最大數量（預設無限大=-1）'
# 'Max number of instructions to scan for aggressive instcombine.'
H5E9EDAFCAA29: '積極instcombine時掃描的指令最大數量'
# 'Max number of instructions to scan for vector combining.'
H596CAD742579: '向量組合時掃描的指令最大數量'
# 'Max number of instructions to scan in each basic block in GVN (default = 100)'
H8FA4F608C594: 'GVN中每個基本區塊掃描的指令最大數量（預設值=100）'
# 'Max number of iterations to be peeled from a loop, such that fusion can take place'
HA1B7957932D5: '循環可剝離的迭代次數最大值，以便進行融合'
# 'Max number of iterations to prefetch ahead'
H74DE81E5BEDC: '提前預取的迭代次數最大值'
# 'Max number of memchecks allowed per eliminated load on average'
H929763545CE5: '平均每個已消除的載入允許的記憶體檢查次數最大值'
# 'Max number of memory uses to explore during partial unswitching analysis'
H5E2B4A7FE9D0: '部分unswitch分析期間探查的記憶體使用次數最大值'
# 'Max number of mux expansions'
H413CD17EDBFC: 'mux展開的最大次數'
# 'Max number of partial inlining. The default is unlimited'
HEF03ECFDE4EE: '部分內嵌的最大次數（預設無限大）'
# 'Max number of paths enumerated around a switch'
H733A7744C96C: '在開關周圍枚舉的路徑數量最大值'
# 'Max number of precise value annotations for a single memopintrinsic'
H43400B846308: '單一memopintrinsic的精確值註釋最大數量'
# 'Max number of predecessors to consider tail merging'
H077931C4B5A6: '考慮尾端合併的前驅節點最大數量'
# 'Max number of promotions for a single indirect call callsite'
H1160EEB59410: '單一間接呼叫調用點的提升次數最大值'
# 'Max number of promotions for a single indirect call callsite in sample profile loader'
H05F78FEA2FAF: '在樣本剖析載入器中，單一間接呼叫調用點的提升次數最大值'
# 'Max number of promotions for this compilation'
HBE53E07F67D3: '本次編譯的變數提升最大數量'
# 'Max number of segment coalescings'
H76831528316D: '段合併的最大數量'
# 'Max number of statepoints allowed to pass GC Ptrs in registers'
HBF13380980F5: '允許在寄存器中傳遞GC指標的狀態點最大數量'
# 'Max number of stores to be predicated behind an if.'
HC838F9655113: '在if條件後被預測的存儲操作最大數量'
# 'Max number of visited instructions when trying to find dominating value of select dependency (default = 100)'
H9E6FEA476B9C: '嘗試查找選擇依賴項的支配值時所訪問的指令最大數量（預設值=100）'
# 'Max number of vtables annotated for a vtable load instruction.'
H1F81EEE11A92: '虛函數表載入指令可標註的虛函數表最大數量'
# 'Max results to display'
HB76D3DEE4518: '顯示結果的最大數量'
# 'Max size of a block which is still considered small enough to thread through'
H36A8554A7A20: '仍視為足夠小而可穿透過的區塊最大大小'
# 'Max total number of preprocessed tokens for -Wmax-tokens.'
HC95A06179FBD: '-Wmax-tokens選項使用的預處理語法單元最大數量'
# 'Maximal number of attributor iterations.'
HD46DDBA87859: '屬性推導器的最大迭代次數'
# 'Maximal number of callees specialized for a call base'
HA4B29DB6599A: '呼叫位址可被特殊化的最大數量'
# 'Maximal number of chained initializations (to avoid stack overflows)'
H907C6E291577: '避免堆疊溢出的鏈式初始化最大層數'
# 'Maximal number of fixpoint iterations.'
HD4791B6062DE: '固定點迭代的最大次數'
# 'Maximal number of uses to explore.'
H3B80E7F90921: '要探索的使用節點最大數量'
# 'Maximize bandwidth when selecting vectorization factor which will be determined by the smallest type in loop.'
H1FD207584DE2: '選擇向量化因子時最大化帶寬，該因子由迴圈中最小類型決定'
# 'Maximize the band depth (yes/no)'
H16AE46F8C5D0: '最大帶深（yes/no）'
# 'Maximum SLP vectorization factor (0=unlimited)'
HFDC1B422DFB3: 'SLP向量化因子的最大值（0=無限制）'
# 'Maximum alloca size to use for inline cost'
H85D97309D239: '用於內聯成本計算的alloca最大大小'
# 'Maximum allowed iterations to unroll under pragma unroll full.'
H369A26E92574: 'pragma unroll full指令下的最大展開次數'
# 'Maximum amount of memory to use. 0 disables check. Defaults to 400MB (800MB under valgrind, 0 with sanitizers).'
HD9F29E050069: '最大可用記憶體容量。0表示禁用檢查。預設值為 400MB（valgrind環境下為 800MB，使用檢查器時設為 0）。'
# 'Maximum amount of nodes to process while searching SCEVUnknown Phi strongly connected components'
H733D2DA20417: '在搜尋SCEVUnknown Phi強連通分量時要處理的最大節點數'
# 'Maximum amount of shared memory to use.'
H87E40E4A881F: '要使用的共享記憶體最大容量'
# 'Maximum array size considered when doing a combine'
HA910C2785634: '進行combine時考慮的最大陣列大小'
# "Maximum block frequency, expressed as a percentage of caller's entry frequency, for a call site to be considered cold for enabling coldcc"
H39E2E109FC72: '以呼叫函數入口頻率的百分比表示，當呼叫位址的區塊頻率低於此值時，將啟用coldcc優化的配置文件引導型優化'
# "Maximum block frequency, expressed as a percentage of caller's entry frequency, for a callsite to be cold in the absence of profile information."
HDD8AD6EFCAAB: '在缺乏剖析資料時，若呼叫位址的區塊頻率低於此值（以呼叫函數入口頻率的百分比表示），則視為冷呼叫'
# 'Maximum byte size to consider promote alloca to vector'
HDC8E89EF71AD: '要考慮將alloca提升為向量的最大位元組大小'
# 'Maximum codesize growth allowed per function'
H78609FC7BCF8: '允許的每函數代碼大小增長上限'
# 'Maximum cost accepted for the transformation'
H83731968FC73: '轉換可接受的最大成本'
# 'Maximum cost multiplier of TCC_expensive for the dependence slice of a cold operand to be considered inexpensive.'
H6DFC35CF6D50: '冷操作數的依賴切片成本若低於此TCC_expensive倍數，將視為 inexpensive'
# 'Maximum cost of combining conditions when folding branches'
H781B5E7517C1: '摺疊分支時結合條件的最大成本'
# 'Maximum depth allowed for the recursive algorithm used to explore MIV direction vectors.'
H1A8D3D915439: '用於探索MIV方向向量的遞迴演算法允許的最大深度'
# 'Maximum depth for recursive loop guard collection'
H30DB13FC6626: '遞迴收集迴圈守護條件允許的最大深度'
# 'Maximum depth of loop nest considered for the transform'
HB49D9378BE58: '進行轉換時考慮的最大迴圈嵌套深度'
# 'Maximum depth of recursive SCEV complexity comparisons'
H91C70931DE15: '遞迴SCEV複雜度比較允許的最大深度'
# 'Maximum depth of recursive SCEV operations implication analysis'
H11D5122A9F0A: '遞迴分析SCEV運算符含意的條件比較最大深度'
# 'Maximum depth of recursive SExt/ZExt/Trunc'
HC985D30DDFD4: '遞迴SExt/ZExt/Trunc運算允許的最大深度'
# 'Maximum depth of recursive arithmetics'
HAE0E4B668E3D: '遞迴算術運算允許的最大深度'
# 'Maximum depth of recursive constant evolving'
H729F236B8A12: '遞迴常數演變允許的最大深度'
# 'Maximum depth of recursive value complexity comparisons'
HF2B077915503: '遞迴值複雜度比較允許的最大深度'
# 'Maximum distance between a tfr feeding a store we consider the store still to be newifiable'
HA3A3AE754AA0: '在tfr餵入儲存指令後，仍視為可重新分配的最大距離'
# 'Maximum distance of loop carried dependences that are handled'
HC5B916D346C8: '處理的循環攜帶依賴的最大距離'
# 'Maximum factor by which expected native size may increase before blocking any further inlining.'
H1A06B982376C: '在阻止進一步內聯之前，期望的本地大小可能增加的最大倍數。'
# 'Maximum factor for an interleaved access group (default = 8)'
HCB89C86317C6: '交錯存取群組的最大倍數（預設值 = 8）'
# 'Maximum frequency of path for an operand to be considered cold.'
H229E4B064589: '將操作元視為冷門路徑的最大頻率。'
# 'Maximum global merge offset'
HDC72CED70E8A: '全局合併偏移量的最大值'
# 'Maximum input DBG_VALUE insts supported by debug range extension'
H5626CEECD47D: '由除錯範圍擴展支持的輸入DBG_VALUE指令最大數量'
# 'Maximum input basic blocks before DBG_VALUE limit applies'
H05C4A13D67D8: '在應用DBG_VALUE限制之前的基本區塊最大輸入數量'
# 'Maximum instructions to analyze per moved initialization'
H28DB4399F2D2: '每移動初始化分析的最大指令數'
# 'Maximum instructions to consider tail duplicating'
H4A94E8A5FC9B: '考慮尾部複製的最大指令數'
# 'Maximum instructions to consider tail duplicating blocks that end with indirect branches.'
H24A02DE8C7F1: '考慮尾部複製以間接分支結尾的區塊的最大指令數'
# 'Maximum interleave factor for MVE VLDn to generate.'
H213FF805CEF2: '生成MVE VLDn的交錯倍數最大值'
# 'Maximum length of a memory clause, instructions'
H7D54283EC716: '記憶體條款的長度最大值（以指令為單位）'
# 'Maximum length of dependent chains to hoist (default = 10, unlimited = -1)'
HC4AAAE7F5958: '要提升的依賴鏈的最大長度（預設值 = 10，無限 = -1）'
# 'Maximum length of recurrence chain when evaluating the benefit of commuting operands'
H84087A27148D: '在評估交換操作元的效益時，遞迴鏈的最大長度'
# 'Maximum nesting level for parentheses, brackets, and braces'
H62138B784DC3: '括號、方括號和大括號的最大嵌套層級'
# 'Maximum num basic blocks before debug info dropped'
HF7FD1D6C6637: '在除錯資訊被刪除前的基本區塊最大數量'
# "Maximum number of 'operator->'s to call for a member access"
H2363B77A7D06: '用於成員存取的operator->呼叫次數最大值'
# 'Maximum number of BBs allowed in a function after inlining (compile time constraint)'
H02A0499B6C90: '內嵌後函數中允許的基本區塊最大數量（編譯時間限制）'
# 'Maximum number of ISL operations to invest for known analysis; 0=no limit'
H1E380A641D89: '已知分析中投資ISL運算的最大次數；0=無限制'
# 'Maximum number of base-updates to check generating postindex.'
HA9EAB9913B99: '檢查生成postindex時的基底更新次數最大值'
# 'Maximum number of basic blocks in a function to run ext-TSP block placement.'
HEAD0A5AFAB52: '函數中執行擴展-TSP區塊放置的最大基本區塊數量。'
# 'Maximum number of branches in the accumulator tree'
HE163718A2F82: '累加器樹中的最大分支數量'
# 'Maximum number of call targets per call site to enable branch funnels'
H2188104092EB: '啟用分支漏斗的每個呼叫位置的最大呼叫目標數量'
# 'Maximum number of comparisons done when trying to merge runtime memory checks. (default = 100)'
H9FAF3F7149E1: '嘗試合併執行階段記憶體檢查時執行的比較次數最大值。（預設值 = 100）'
# 'Maximum number of conditions in MC/DC coverage'
H6395D2BBFABE: 'MC/DC 覆蓋率中的最大條件數量'
# 'Maximum number of cycles in the timeline view, or 0 for unlimited. Defaults to 80 cycles'
H17E412044F75: '時間軸檢視中的最大週期數，或 0 表示無限。預設值為 80 個週期'
# 'Maximum number of dataflow edges to traverse when evaluating the benefit of commuting operands'
H635DA15AA164: '在評估交換運算元的效益時要遍歷的資料流邊數量最大值'
# 'Maximum number of dependences collected by loop-access analysis (default = 100)'
H498CAFF81EAD: '迴圈存取分析（預設值 = 100）所收集的依賴關係最大數量'
# 'Maximum number of instruction to generate when lowering constant multiplication instead of calling library function [default=14]'
HA8EBACF52A9C: '將常數乘法轉換為函式庫函式呼叫之前生成的指令最大數量 [預設值=14]'
# 'Maximum number of instructions for ObjectSizeOffsetVisitor to look at'
H87E9B845C1F1: '物件大小偏移訪問器要查看的最大指令數'
# 'Maximum number of instructions per speculated block.'
H9257791CBCD4: '每個推测區塊可處理的最大指令數。'
# 'Maximum number of isl operations to invest for lifetime analysis; 0=no limit'
HEF3BE03FC67D: '用於生命周期分析的 isl 運算操作的最大數量；0 表示無限'
# 'Maximum number of iterations SCEV will symbolically execute a constant derived loop'
H2F35B8D580F6: 'SCEV 將符號執行常數導出的迴圈的最大次數'
# 'Maximum number of iterations to go through when propagating sample block/edge weights through the CFG.'
H76A911EDD837: '在程式流程圖中傳播樣本區塊/邊權重時要遍歷的最大次數。'
# 'Maximum number of iterations to print in timeline view'
H61122E3872D7: '在時間軸檢視中要列印的迴圈次數最大值'
# 'Maximum number of iterations we keep dismantling potential values.'
HACE4628A8A6D: '我們保留拆解可能值的最大次數。'
# 'Maximum number of load-store instructions that should be handled in the dependency matrix. Higher value may lead to more interchanges at the cost of compile-time'
HC041FD354820: '依賴矩陣中應處理的載入-儲存指令最大數量。更高的值可能導致更多交換，但會增加編譯時間'
# 'Maximum number of parameters for a split function'
H21349A957046: '分割函數的參數最大數量'
# 'Maximum number of physical registers which can be used for register mappings'
HDA7C27C95D63: '可用於寄存器映射的物理寄存器最大數量'
# 'Maximum number of potential values to be tracked for each position.'
H955218AAB793: '每個位置要追蹤的潛在值最大數量。'
# 'Maximum number of predicated jumps to be converted to New Value Jump'
HF3F6203AD570: '可轉換為 New Value Jump 的 predicated jumps 最大數量'
# 'Maximum number of prefixes to use for padding'
H7458F00CCA26: '用於填充的前綴最大數量'
# 'Maximum number of ptr states the optimizer keeps track of'
HB7E5E43FBE1D: '優化器追蹤的指標狀態最大數量'
# 'Maximum number of replacements'
H6F2E3DB8E40F: '替換次數最大值'
# "Maximum number of results to stream as a response to single request. Limit is to keep the server from being DOS'd. Defaults to 10000."
H8CFDD20881AA: '單一請求的響應中串流傳輸的結果最大數量。此限制用於防止伺服器受到 DOS 攻擊。預設值為 10000。'
# 'Maximum number of rows to keep in constraint system'
H99BCC72F0CE0: '在約束系統中保留的列數最大值'
# 'Maximum number of simplification steps in HLIR'
H8BBD18037D20: 'HLIR 中的簡化步驟最大數量'
# 'Maximum number of split partitions'
HFE60C6DE65ED: '分割區塊的最大數量'
# 'Maximum number of test vectors in MC/DC coverage'
HAFD4B8816F42: 'MC/DC 覆蓋中的測試向量最大數量'
# 'Maximum number of threads (for emulation thread-local storage)'
H0870E5A4F08E: '線程數（用於模擬執行緒局部儲存）'
# 'Maximum number of threads to use to process chunks. Set to 1 to disable parallelism.'
H35B2504140C1: '用於處理區塊的線程最大數量。設為 1 可禁用並行處理。'
# 'Maximum number of times to run the full set of delta passes (default=5)'
H2DC8A9AE4C6B: '執行完整的 delta pass 集合的次數最大值（預設值=5）'
# 'Maximum number of undroppable users for instruction sinking'
H51772496A3DD: '指令沉澱（instruction sinking）中不可移除的使用者最大數量'
# 'Maximum number phis to handle in intptr/ptrint folding'
H8EB042BFB02C: '在 intptr/ptrint 折疊中處理的 phi 節點最大數量'
# 'Maximum of xors'
H1D5D83FA6AD6: 'XOR 運算的最大數量'
# 'Maximum optimization to perform'
HE99B191AFFD1: '要執行的最優化等級最大值'
# 'Maximum predecessors (maximum successors at the same time) to consider tail duplicating blocks.'
HEA56889501D6: '考慮尾部複製區塊時，前驅節點（與後驅節點同時）的最大數量'
# 'Maximum recursion depth when finding forked SCEVs (default = 5)'
H0BFBD51E5518: '在查找分支 SCEV 時的最大遞迴深度（預設值 = 5）'
# 'Maximum recursion level'
HE3B9BD0F99EA: '最大遞迴層級'
# 'Maximum search distance for definition of CR bit spill on ppc'
H3E64147E3DA7: '在 PPC 上 CR 位溢出定義的最大搜尋距離'
# 'Maximum size for the name of non-global values.'
HD0F170A76DAC: '非全域值的名稱最大長度'
# 'Maximum size of ALL constants to promote into a constant pool'
H601F886CFD14: '所有要提升到常數池的常數的最大大小'
# 'Maximum size of IFMap'
H36B1B6A77B2F: 'IFMap 的最大大小'
# 'Maximum size of OrderedRegisterList'
H272C7A54D906: 'OrderedRegisterList 的最大大小'
# 'Maximum size of constant to promote into a constant pool'
H64D76AF05D3E: '要提升到常數池的常數的最大大小'
# "Maximum size of range check type for which can be produced runtime overflow check of its limit's computation"
H186E992A3695: '可產生其極限計算運算式之執行階段溢位檢查的範圍檢查類型最大大小'
# 'Maximum stages allowed in the generated scheduled.'
H48FD271D1F26: '生成排程中允許的最大階段數'
# 'Maximum successors (maximum predecessors at the same time) to consider tail duplicating blocks.'
H43B65927F125: '考慮尾部複製區塊時的最大後繼節點（同時也是最大前驅節點）數量'
# 'Maximum throughput from the decoders (instructions per cycle)'
H7563F8838724: '解碼器（每週期指令數）的最高吞吐量'
# 'Maximum time a channel may stay idle until server closes the connection, in seconds. Defaults to 480.'
HAA88BB6FEBEE: '通道在伺服器關閉連接前保持空閒的最大時間（秒）。預設值為 480'
# 'Maximum users to visit in copy from constant transform'
H0BCD40F173F6: '常數轉換複製時要訪問的最大使用者數量'
# 'Maximum vector size (in 32b registers) to use when promoting alloca'
HBBF17E62FD6E: '提升 alloca 時使用的向量大小最大值（以 32 位元寄存器為單位）'
# 'May have atomic operations on fine-grained memory'
HADF7ECC58A34: '可能在細粒度記憶體上執行原子操作'
# 'May have atomic operations on remote memory'
H32B8F16B1079: '可能在遠端記憶體上執行原子操作'
# 'Measure the parse tree'
HCE9EAC149D17: '測量解析樹'
# 'Medium code model'
H72290D3E5AED: '中等程式碼模型'
# 'MemProf memory access profile'
H1BF9427AF0C9: 'MemProf 記憶體存取剖析'
# 'Member.'
H2A50D724340B: '成員。'
# 'Memory Dependence Analysis'
H4CBD5FC4ABBF: '記憶體依存性分析'
# 'Memory SSA'
H3A3FEB09FB66: '記憶體 SSA'
# 'Memory reference level analysis that distinguish access instructions in the same statement'
H0AE95D83B775: '記憶體存取層級分析，區分同一語句中的存取指令'
# 'Memory reference level analysis that distinguish accessed references in the same statement'
H4E1E23E6B24B: '記憶體存取層級分析，區分同一語句中被存取的記憶體引用'
# 'Merge all const globals without looking at uses'
H6449013A03CB: '不檢查使用情形下合併所有 const 全域變數'
# 'Merge and hoist M0 initializations'
H2D268DBDEF86: '合併並提升 M0 初始化'
# 'Merge context profiles before calculating thresholds.'
H1C9DF3097EF8: '在計算閾值前合併上下文剖析'
# 'Merge context sample profiles whose count is below cold threshold'
HC6C3845D54A1: '合併計數低於冷門閾值的 sample 剖析'
# 'Merge contiguous icmps into a memcmp'
H7D045C95D910: '合併連續的 icmp 為 memcmp'
# 'Merge disjoint stack slots'
HC48D29B2D11A: '合併不相連的堆疊槽位'
# 'Merge global variables'
HBC9C437F360A: '合併全域變數'
# "Merge past inlinee's profile to outline version if sample profile loader decided not to inline a call site. It will only be enabled when top-down order of profile loading is enabled. "
H647C9F0ED977: '當剖析載入程式決定不內嵌呼叫位置時，將過去內嵌函數的剖析合併到外部化版本。僅在啟用剖析載入的自頂向下順序時啟用。'
# 'Merge the given AST file into the translation unit being compiled.'
H044732F67319: '將指定的 AST 檔案合併至正在編譯的翻譯單元。'
# "Method to generate ID's for compilation units for single source offloading languages CUDA and HIP: 'hash' (ID's generated by hashing file path and command line options) | 'random' (ID's generated as random numbers) | 'none' (disabled). Default is 'hash'. This option will be overridden by option '-cuid=[ID]' if it is specified."
HF56CB8DC51CB: "為 CUDA 和 HIP 的單來源外部化語言生成編譯單元 ID 的方法：'hash'（基於檔案路徑及指令列選項雜湊生成 ID） | 'random'（隨機生成 ID） | 'none'（禁用）。預設為 'hash'。此選項將被 '-cuid=[ID]' 選項指定時覆寫。"
# 'MicroMips instruction size reduce pass'
H43AA98943979: 'MicroMips 指令大小縮減 Pass'
# "Microsoft compiler version number to report in _MSC_VER (0 = don't define it (default))"
H84908CA49591: '指定 _MSC_VER 宏報告的 Microsoft 編譯器版本號（0 = 不定義（預設））'
# 'Middle half duplicate mode'
H18C80D21224E: '中間半段重複模式'
# 'Middle half loop mode'
H43135A085735: '中間半段迴圈模式'
# 'Min number of instructions to consider tail merging'
HCFE1247214B4: '考慮尾端合併的最小指令數'
# 'Min percent of cold bytes matched to hint allocation cold'
HF5A0792EF995: '匹配冷門位元元組的最小百分比以提示分配為冷門'
# 'Min percent of cold bytes to hint alloc cold during cloning'
H30A19A7158C7: '複製期間提示分配為冷門的冷門位元元組最小百分比'
# 'Min stride to add prefetches'
H9E2620BA9D60: '添加預取的最小步進'
# 'MinGW specific. Disable support for automatic dllimport in code generation and linking'
H3256426D82B0: 'MinGW 專屬。禁用程式碼生成和連結中的自動 dllimport 支援'
# 'MinGW specific. Enable code generation support for automatic dllimport, and enable support for it in the linker. Enabled by default.'
H2BCAB89FF663: 'MinGW 專屬。啟用程式碼生成對自動 dllimport 的支援，並在連結器中啟用相應支援。預設已啟用。'
# 'MinInstrCount strategy.'
H611D13E20CE8: '最小指令數策略。'
# 'Minimal Transform dialect driver\n'
H4CF75EEC17A9: '最小轉換語法驅動程式\n'
# 'Minimal common base load/store instructions triggering DS/DQ form preparation'
H0EEF17599CF6: '觸發 DS/DQ 格式準備的最小共同基礎載入/儲存指令'
# 'Minimal common base load/store instructions triggering chain commoning preparation. Must be not smaller than 4'
H8810625AE483: '觸發鏈結共同化準備的最小共同基礎載入/儲存指令。必須不小於 4'
# 'Minimize AVX to SSE transition penalty'
H8DBDD3BC94CA: '最小化 AVX 轉換至 SSE 的轉換損失'
# 'Minimize number of registers used'
H4957842A8433: '最小化使用中的寄存器數量'
# 'Minimum BranchProbability to consider a region cold.'
HD5C5EDF501D8: '視為某區域為冷區所需的最小 BranchProbability'
# 'Minimum block executions to consider its BranchProbabilityInfo valid'
HC699EC9E0880: '視為 BranchProbabilityInfo 有效的區塊執行次數最小值'
# "Minimum block frequency, expressed as a multiple of caller's entry frequency, for a callsite to be hot in the absence of profile information."
H7B3632E358D5: '在沒有分析資料的情況下，呼叫位址要被視為熱點所需的最小區塊頻率（以呼叫者進入頻率的倍數表示）'
# 'Minimum density for building a jump table in a normal function'
H0D43760047E0: '在一般函數中建立跳轉表所需的最小密度'
# 'Minimum density for building a jump table in an optsize function'
H6EFB80EE1C35: '在 optsize 函數中建立跳轉表所需的最小密度'
# 'Minimum depth of loop nest considered for the transform'
H277B1F275C2D: '轉換時考慮的迴圈巢狀層級最小深度'
# 'Minimum distance between predicate definition and farther of the two predicated uses'
HBAA80BA0F268: '預測子定義與兩個受其影響的使用中較遠者間的最小距離'
# 'Minimum gain per loop (in cycles) threshold.'
H563FE7251C8B: '每個迴圈（以週期計算）的最小獲益閾值。'
# 'Minimum length of accumulator chains required for the optimization to kick in'
HE6E58DA8C268: '觸發此最佳化的累加器鏈的最小長度'
# 'Minimum number of extenders to trigger replacement'
HA7EB99ED5DCC: '觸發取代所需的最小擴充元件數量'
# 'Minimum number of similar functions with the same hash required for merging.'
H332DB9D9B554: '合併所需相同雜湊值的相似函數的最小數量'
# 'Minimum number of times a block must be executed to be retained.'
H78B91828296F: '要保留區塊所需的最小執行次數。'
# "Minimum priority, runs on idle CPUs. May leave 'performance' cores unused."
H2308F82368EA: '最低優先級，運行於空閒的CPU。可能導致『效能』核心閒置。'
# "Minimum profile count required for an optimization remark to be output. Use 'auto' to apply the threshold from profile summary"
H3D2B4D99467F: "需要輸出優化註記的最小剖析計數。使用 'auto' 以從剖析摘要應用門檻值。"
# "Minimum profile count required for an optimization remark to be output. Use 'auto' to apply the threshold from profile summary."
H05750FA1DE8F: "需要輸出優化註記的最小剖析計數。使用 'auto' 以從剖析摘要應用門檻值。"
# 'Minimum ratio comparing relative sizes of each outline candidate and original function'
H4C5E36FE2F68: '比較每個提綱候選與原始函數相對大小的最小比率。'
# 'Minimum relative gain per loop threshold (1/X). Defaults to 12.5%'
H2DECB545864A: '每個迴圈的最小相對增益閾值（1/X）。預設為 12.5%。'
# 'Minimum time granularity (in microseconds) traced by time profiler'
H82ABB54FDFA0: '時間剖析器追蹤的最小時間粒度（以微秒為單位）。'
# 'Minimum type size in bits for breaking large PHI nodes'
HB05B1AF899B8: '分解大型PHI節點所需的型別大小最小位數。'
# 'Mips VR4300 mulmul bugfix'
HBC6DCC9857CF: 'Mips VR4300 mulmul 除錯修正'
# 'Miscellaneous Options'
HE9A41E28CF82: '其他選項'
# 'Missing debug location (gaps).'
HCFAF9A1705D6: '缺少除錯位置（間隙）。'
# 'Mode for reading thread pointer'
H56EB4841FF26: '讀取執行緒指標的模式。'
# 'Mode of the RegBankSelect pass'
HC6D74CC5D13F: 'RegBankSelect pass的模式。'
# 'Model read-only scalar values in the scop description'
HEF37BBE0A859: '在 scop 描述中建模只讀純量值。'
# 'Model the cost of loop rotation more precisely by using profile data.'
H5615ACF94C6A: '使用剖析資料更精確地建模迴圈旋轉的成本。'
# 'Modextract Options'
H29E9EFFE5231: 'Modextract 選項'
# 'Module & File Options'
HDFC5298823CB: '模組與檔案選項'
# 'Module Options'
H15D7561EF70B: '模組選項'
# 'Module Summary Analysis'
H35F5D0BFCE0A: '模組摘要分析'
# 'Module Verifier'
HB268B018B769: '模組驗證器'
# 'Module concatenation'
H521219EE1D9E: '模組串接'
# 'Module extractor'
HDE0289089F3A: '模組萃取器'
# 'Module summary index filename'
H3224F1E17512: '模組摘要索引檔名稱'
# 'Module summary info'
HCFDC7E39A72C: '模組摘要資訊'
# 'Modulo Schedule test pass'
H9F5185006F74: '模數排程測試Pass'
# 'Modulo Software Pipelining'
HC40B97D6B9FA: '模數軟體管線'
# 'Move ARGUMENT instructions for WebAssembly'
H688758DE208F: '為WebAssembly移動ARGUMENT指令'
# 'Move/duplicate certain instructions close to their use'
HD38286726698: '將某些指令移動/複製到離其使用處較近的位置'
# 'Multiplier to apply to threshold when determining whether or not to fold branch to common destination when vector operations are present'
HC6051096B6ED: '在向量運算存在時，用於決定是否將分支摺疊到共同目標時，套用到閾值的乘數'
# 'Multiplier to bump up callsite threshold for previous inlining.'
H80636EF6462B: '用於提高前一次內聯的呼叫位址閾值的乘數'
# 'Multiplier to multiply cycle savings by during inlining'
H1D068428F9A5: '內聯期間用於乘以週期節省量的乘數'
# 'Multiply the `import-instr-limit` threshold for cold callsites'
HC6AF6BE5F0E1: '呼叫冷門呼叫位址時，乘以`import-instr-limit`閾值'
# 'Multiply the `import-instr-limit` threshold for critical callsites'
HA6A6A6EE28A9: '呼叫關鍵呼叫位址時，乘以`import-instr-limit`閾值'
# 'Multiply the `import-instr-limit` threshold for hot callsites'
H4850606E5CF1: '呼叫熱門呼叫位址時，乘以`import-instr-limit`閾值'
# 'Must specify at least '
HEC0DF6B1AD3C: '必須指定至少 '
# 'My Pass Name'
H68A400666676: '我的Pass名稱'
# 'N must be a power of two. Align loops to the boundary'
H2A7AB317ED00: 'N必須是 2 的冪次方。將迴圈對齊到邊界'
# 'NVPTX Address space based Alias Analysis'
H9D1213E22820: 'NVPTX基於位址空間的別名分析'
# 'NVPTX Address space based Alias Analysis Wrapper'
HB227AE568CB7: 'NVPTX基於位址空間的別名分析封裝'
# 'NVPTX DAG->DAG Pattern Instruction Selection'
HB23F4D978D1F: 'NVPTX DAG到DAG模式指令選擇'
# 'NVPTX Forward Params'
H3B9CC422F869: 'NVPTX 前置參數'
# 'NVPTX Peephole'
H5BF795D76A44: 'NVPTX 微觀優化'
# 'NVPTX ProxyReg Erasure'
HDFA70554F191: 'NVPTX 代理寄存器消除'
# 'NVPTX Specific: 0 use sqrt.approx, 1 use sqrt.rn.'
H11B08A79FA4D: 'NVPTX 特定選項：0 使用 sqrt.approx，1 使用 sqrt.rn。'
# 'NVPTX Specific: Disable generation of f16 math ops.'
HDAF968D22832: 'NVPTX 特定選項：禁用 f16 數學運算的生成。'
# "NVPTX Specific: FMA contraction (0: don't do it 1: do it  2: do it aggressively"
HD36FDD8676CA: 'NVPTX 特定選項：FMA 收縮（0：不執行，1：執行，2：積極執行）'
# 'NVPTX Specific: force 4-byte minimal alignment for byval params of device functions.'
H40664A3C3B0F: 'NVPTX 特定選項：強制為裝置函數的 byval 參數設置 4 字節的最小對齊。'
# 'NVPTX Specific: schedule for register pressue'
H0940771EECAF: 'NVPTX 特定選項：針對寄存器壓力的調度。'
# 'NVPTX Specific: whether to use lg2.approx for log2'
HDC539A3BEBE1: 'NVPTX 特定選項：是否使用 lg2.approx 來進行 log2 計算。'
# 'NVPTX Specifies: 0 use div.approx, 1 use div.full, 2 use IEEE Compliant F32 div.rnd if available.'
HADD307B6A067: 'NVPTX 特定選項：0 使用 div.approx，1 使用 div.full，2 若可用則使用符合 IEEE 的 F32 div.rnd。'
# 'NVPTX target requires CUDA 9.2 or above; CUDA %0 detected'
HC81CA29CBF97: 'NVPTX 目標需要 CUDA 9.2 或以上版本；已偵測到 CUDA %0。'
# 'NVVM reflection, enabled by default'
H0FD65ACF0E14: 'NVVM 反射，預設已啟用'
# 'Name for native GCC compiler'
H0AD88C41A101: '本機 GCC 編譯器的名稱'
# 'Name for the section containing cold functions extracted by hot-cold splitting.'
H350954655BC3: '熱/冷函數分割時，包含冷函數的區段名稱'
# 'Name of checks to match against'
HAD04C40729DF: '要匹配的檢查項目名稱'
# 'Name of op to match on'
H9F76B5F57ED0: '要匹配的操作名稱'
# 'Name of project.'
HD47E84631ECF: '專案名稱。'
# 'Name of the entry point transform symbol'
H9FE29477F41B: '入口點轉換符號的名稱'
# 'Name of the interesting-ness test to be run'
H01AA1C566B65: '要執行的興趣度測試名稱'
# 'Name of the macro to be defined'
H74E9FD90F24A: '要定義的巨集名稱'
# 'Name of the macro to be defined -- ignored by mlir-pdll'
H03D44F059B30: '要定義的宏名稱 -- 被 mlir-pdll 忽略'
# 'Name of the macro to be defined -- ignored by mlir-src-sharder'
H3F90161CF695: '要定義的宏名稱 -- 被 mlir-src-sharder 忽略'
# 'Name of the split dwarf debug info file to encode in the object file'
HCFEFDA365E00: '要編碼到物件檔案中的拆分 dwarf 调試資訊檔名'
# 'Namespace.'
HD451EBBFFEAD: '命名空間。'
# 'Narrow LSR complex solution using expectation of registers number'
H13DBBF2C516C: '使用寄存器數量期望值的窄化 LSR 複雜解法'
# 'Narrow LSR search space by filtering non-optimal formulae with the same ScaledReg and Scale'
HBD4BDD760DFA: '透過過濾具有相同 ScaledReg 和 Scale 的非優化公式來窄化 LSR 搜尋空間'
# 'Nary reassociation'
HAC5287C54D8E: 'N-元重新組合'
# 'Natural Loop Information'
HB731CE00868C: '自然循環資訊'
# 'Neon vector size must be 64 or 128 bits'
H97DBFE49CD6B: 'Neon 向量大小必須為 64 或 128 位元'
# 'Nested profile, the input should be CS flat profile'
HA55917D514EC: '巢狀剖析，輸入應為 CS 平面剖析檔'
# 'Never'
H80C3052D33CC: '從不'
# 'Never Step Into.'
HA04C48D1B790: '從不進入步進。'
# 'Never detect stack use after return.'
HC4D92AB5F1A8: '從不偵測返回後的堆疊使用。'
# 'Never dump input'
H182384737343: '從不輸出輸入'
# 'Never emit tail calls'
H295822EA6C7C: '從不發射尾調用'
# 'Never insert #include directives as part of code completion'
H6893E7F599D8: '在程式碼補全時絕不插入 #include 指令'
# 'Never set the bit'
H77A3923DD75B: '永遠不設置該位元'
# 'Never track the overflow bit.'
HF22B430EF914: '從不追蹤溢位位元。'
# 'New FS discriminators encoding (incompatible with the original encoding)'
H525B7044D16E: '新的 FS 分歧編碼（與原始編碼不相容）'
# 'New namespace.'
H7E03703F3B39: '新的命名空間。'
# 'New statement.'
HBA1639E60F46: '新的語句。'
# 'No Vectorization'
H1F3B2817613C: '無向量化'
# 'No action'
HF34AC77F7E82: '無動作'
# 'No checking'
H4F955C5DB2D5: '無檢查'
# 'No code generation'
H3AC7DD01B6EE: '無程式碼生成'
# 'No compression'
HB3E344B2C4BB: '無壓縮'
# 'No constructors'
HAD09B30D8B5D: '無建構函式'
# 'No destructors'
H24AE7DC3B6A4: '無解構函式'
# 'No effect'
H7ED12CB7B709: '無效'
# 'No extract instruction with offset 0'
HEB2933468549: '無位移為 0 的extract指令'
# 'No implicit externals allowed'
H6CDA41F7B635: '禁止隱式外部符號'
# 'No implicit typing allowed unless overridden by IMPLICIT statements'
HA46325FCDDD6: '除非被IMPLICIT語句覆寫，否則禁止隱式類型推論'
# 'No offloading entry generated while offloading is mandatory.'
H4E35CC32EE7C: '強制卸載時未生成卸載入口。'
# 'No optimizer'
HF1ED527BC3E1: '無優化器'
# 'No profile correlation'
H7B0904A6A54F: '無剖析相關'
# 'No speculation'
H4F7A24022364: '無預測執行'
# 'No vector functions library'
H42FA0B1EA03D: '無向量函式庫'
# 'No verification'
H41C637F6055E: '無驗證'
# 'Non-relocatable code'
H9A85EA682847: '不可重定位的程式碼'
# 'None.'
H9A9707BE07DA: '無。'
# 'Normalize integers in CFI indirect call type signature checks'
H47F05B50721C: '在CFI間接呼叫類型簽章檢查中標準化整數'
# "Not emit the visibility attribute for asm in AIX OS or give all symbols 'unspecified' visibility in XCOFF object file"
H98251062C447: '在AIX作業系統中不發出asm的可見性屬性，或在XCOFF物件檔中將所有符號的可見性設為 "unspecified"'
# 'Number limit for gluing ld/st of memcpy.'
HD8077326B9B0: 'memcpy的ld/st連接數量上限'
# 'Number of addresses from which to enable MIMG NSA.'
HCE8A8E1997D3: '用以啟用MIMG NSA的位址數量'
# 'Number of backend threads'
HE56514D09150: '後端執行緒數量'
# "Number of blocks in the 'x' dimension"
H76CD51A21746: '在x維度中的區塊數量'
# "Number of blocks in the 'y' dimension"
H6D16D2BE9F69: '在y維度中的區塊數量'
# "Number of blocks in the 'z' dimension"
H2E857E7750A0: '在z維度中的區塊數量'
# 'Number of compile threads'
H083DE0C34AB1: '編譯執行緒數量'
# 'Number of cycles to assume for a call instruction'
H48B171D665C7: '假設一個呼叫指令的週期數量'
# 'Number of entries in the micro-op queue'
H6A848E9631B1: '微操作佇列中的條目數量'
# 'Number of instructions to allow ahead of the critical path in sched=list-ilp'
H6B314605368E: '在sched=list-ilp中允許關鍵路徑之前有若干指令'
# 'Number of instructions to prefetch ahead'
HF2FFA16038B4: '預取的指令數量'
# 'Number of interferences after which we declare an interference unevictable and bail out. This is a compilation cost-saving consideration. To disable, pass a very large number.'
H7D7A199C7C69: '在宣告干擾不可驅逐並退出前的干擾次數。這是出於節省編譯成本的考量。若要禁用，請指定一個非常大的數字'
# 'Number of intervals to track'
HB4B7D2AC3D9C: '要追蹤的區間數量'
# 'Number of iterations to run'
HE50757CD0D43: '要執行的迭代次數'
# 'Number of materialization threads to use'
H7A97C7DA89FF: '要使用的具現化執行緒數量'
# 'Number of merge threads to use (default: autodetect)'
H2EA5A0F7B460: '要使用的合併執行緒數量（預設：自動偵測）'
# 'Number of metadatas above which we emit an index to enable lazy-loading'
H4896D21A9235: '當元數據數量超過此值時，發出索引以啟用惰性加載'
# 'Number of output files'
H5DDB526BD36F: '輸出檔案數量'
# 'Number of partitions to use for parallel full LTO codegen, ld.lld only.'
HEC293753B227: '要使用的平行完整LTO程式碼生成分割數，僅限ld.lld。'
# 'Number of registers to limit to when printing regmask operands in IR dumps. unlimited = -1'
H0373C047E939: '在IR轉儲時列印regmask操作數所限制的寄存器數量。無限 = -1'
# 'Number of seconds program is allowed to run before it is killed (default is 300s), 0 disables timeout'
HE6EB2161F536: '允許程式執行的秒數，在此之後程序將被終止（預設值為 300 秒），0 表示禁用超時'
# "Number of threads in the 'x' dimension"
H07DD57A90CC5: "'x' 維度的執行緒數量"
# "Number of threads in the 'y' dimension"
H986B3D9F34E9: "'y' 維度的執行緒數量"
# "Number of threads in the 'z' dimension"
HFC9646CFE097: "'z' 維度的執行緒數量"
# 'Number of threads to use (0 = auto)'
H9A06154F2AD2: '要使用的執行緒數量（0 = 自動）'
# 'Number of times to divide chunks prior to first test'
H4AB8A9674250: '在第一次測試前分割區塊的次數'
# 'Number of times to rerun the outliner after the initial outline'
H45429D789C93: '在初始外線後重新運行outliner的次數'
# 'Number of times to shuffle and verify use-lists'
HEBDA566F30F3: '打亂並驗證使用清單的次數'
# 'Number of tracked SGPRs before initiating hazard cull on memory wait'
H34DB613CB239: '在記憶體等待時啟動危害篩選前追蹤的SGPR數量'
# "Number of triangle-shaped-CFG's that need to be in a row for the triangle tail duplication heuristic to kick in. 0 to disable."
HAF152F5B6E3F: '需要連續的三角形形狀控制流圖數量，以便啟動三角形尾部複製的启发式演算法。設 0 可禁用。'
# 'Number of unswitch candidates that are ignored when calculating cost multiplier.'
H4873CA41A98E: '在計算成本倍數時被忽略的unswitch候選項數量'
# 'Number of uses of a base pointer to check before it is no longer considered for post-indexing.'
H02421600E168: '在不再將基址指標考慮進後索引前，要檢查的基址指標使用次數'
# 'OBJECT_MODE setting %0 is not recognized and is not a valid setting'
HEC8A063EC23B: 'OBJECT_MODE設定 %0 未被識別且不是有效設定'
# 'ODS output filename'
H1E3A5BE01485: 'ODS輸出檔名'
# 'OPTIONS:\n'
H90A71B46515B: '選項：\n'
# 'OVERVIEW: '
H41828FCAB87A: '概述：'
# 'ObjC ARC contraction'
H3B8218111844: 'ObjC ARC收縮'
# 'Object file format name.'
H116E706BF6D9: '物件檔格式名稱。'
# 'Objective-C GC does not allow weak variables on the stack'
H501EF197353A: 'Objective-C GC 不允許在堆疊上使用 weak 變數'
# 'Objective-C declarations may only appear in global scope'
HBE7743C7A3D5: 'Objective-C 声明只能出現在全域作用域中'
# 'Objective-C dispatch method to use'
H71CD5643C8D8: 'Objective-C 要使用的轉送方法'
# 'Objective-C index expression has incomplete class type %0'
H3BF9CC2B38D9: 'Objective-C 索引運算式的類型 %0 是不完整的'
# 'Objective-C message has incomplete result type %0'
HA58AB6CD0922: 'Objective-C 訊息的結果類型 %0 是不完整的'
# 'Objective-C methods as coroutines are not yet supported'
H197AF4BB9670: 'Objective-C 方法作為協程尚未支援'
# 'Objective-C object of type %0 is bridged to %1, which is not valid CF object'
HC21532E95928: 'Objective-C 物件類型 %0 轉換為 %1，但後者不是有效的 CF 物件'
# 'Objective-C++ Automatic Reference Counting standard library kind'
HBD2739B5128E: 'Objective-C++ 自動引用計數標準函式庫類型'
# 'Offloading entry for declare target variable %0 is incorrect: the address is invalid.'
H44B1C3BF0A67: '宣告目標變數 %0 的卸載條目不正確：地址無效。'
# 'Offloading entry for declare target variable is incorrect: the address is invalid.'
H3668F9F00CF1: '宣告目標變數的卸載條目不正確：地址無效。'
# 'Offloading entry for target region in %0 is incorrect: either the address or the ID is invalid.'
HB922AD26B2CB: '%0 中的目標區域卸載條目不正確：地址或 ID 其中一個無效。'
# 'Offset element to print.'
HCA7A2283660F: '要列印的偏移元素。'
# 'Offsets are in UTF-16 code units'
H3B426E622CC8: '偏移量以 UTF-16 代碼單位為單位'
# 'Offsets are in UTF-8 bytes'
HB9A6C5C455E1: '偏移量以 UTF-8 原始字元為單位'
# 'Offsets are in unicode codepoints'
H0151FBB5A950: '偏移量以 unicode 代碼點為單位'
# 'Old namespace.'
HC6DBF56DB427: '舊命名空間。'
# 'Omit all lfences before branch instructions.'
H64285876BCDE: '省略所有分支指令前的 lfences。'
# 'Omit all lfences other than the first to be placed in a basic block.'
HF3797EC0A201: '除了第一個被放置在基本區塊的 lfence 之外，省略其他所有 lfences。'
# 'Omit frame pointer setup for leaf functions'
HE755622424D0: '省略葉函數的框架指標設定'
# 'Omit function index section at the expense of single-function patching performance'
HE5E5A5FAB8F1: '省略函數索引區段，以犧牲單一函數修补效能為代價'
# 'Omit the RTTI component from virtual tables'
H4D1372C43A35: '從虛基類表中省略RTTI組件'
# "Omit the frame pointer from functions that don't need it. Some stack unwinding cases, such as profilers and sanitizers, may prefer specifying -fno-omit-frame-pointer. On many targets, -O1 and higher omit the frame pointer by default. -m[no-]omit-leaf-frame-pointer takes precedence for leaf functions"
H40ED6B28D90F: '從不需要的函數中省略框架指標。部分堆疊解開案例（如剖面工具與檢查工具）可能偏好指定-fno-omit-frame-pointer。在多數目標平台上，-O1與更高優化等級預設會省略框架指標。-m[no-]omit-leaf-frame-pointer 對葉函數具有優先權'
# 'On AIX, request creation of a build-id string, "0xHEXSTRING", in the string table of the loader section inside the linked binary'
H9CC108588817: '在AIX系統中，要求在連結二進制檔載入器區段的字串表中建立「0xHEXSTRING」形式的建立ID字串'
# 'On Windows, do not emit /defaultlib: directives to link compiler-rt libraries'
H9E62CED5E13B: '在Windows系統中，不發出連結compiler-rt函式庫的/defaultlib:指令'
# 'On Windows, emit /defaultlib: directives to link compiler-rt libraries (default)'
H84415BE98E65: '在Windows系統中，發出連結compiler-rt函式庫的/defaultlib:指令（預設）'
# 'One completion item for each semantically distinct completion, with full type information'
HE890AD8AA9F7: '每個語義上不同的補充項目各提供一個完整類型資訊的補充項目'
# 'One shadow type id for each of `float`, `double`, `long double`. `d`,`l`,`q`,`e` mean double, x86_fp80, fp128 (quad) and ppc_fp128 (extended double) respectively. The default is to shadow `float` as `double`, and `double` and `x86_fp80` as `fp128`'
H95084AA4612D: 'float、double、long double各對應一個陰影類型識別碼。d、l、q、e分別代表double、x86_fp80、fp128（quad）和ppc_fp128（延伸雙精度）。預設將float陰影為double，而double和x86_fp80陰影為fp128'
# 'One statement per basic block'
HD6EC7448F7DB: '每個基本區塊（basic block）對應一個語句'
# 'Only AST generation'
HCF69EA2C9F2B: '僅產生AST'
# 'Only a certain kind of dependences (all/raw)'
HDDC1270FFF46: '僅特定類型的依賴項（all/raw）'
# 'Only allow instructions before a call, if their cost is below DuplicationThreshold'
HF553DB6BFC41: '僅允許呼叫前成本低於DuplicationThreshold的指令'
# 'Only check if the module has objective-C defined in it'
H77EBD1C814CB: '僅輸入無需[sz]ext的比較操作'
# "Only comparisons where inputs don't need [sz]ext."
HF4DF79025CD9: '僅具有sext結果的比較操作'
# 'Only comparisons with sext result.'
H4718DE1FE775: '僅具有zext結果的比較操作'
# 'Only comparisons with zext result.'
H13645F5A29D7: '僅具有zext結果的比較操作'
# 'Only compile for the offloading device.'
H215BF96D8531: '僅為卸載裝置進行編譯'
# 'Only compile for the offloading host.'
H064D887D36F7: '僅為卸載主機進行編譯'
# 'Only consider IR changes for passes whose names match the specified value. No-op without -print-changed'
HEBE7550E221C: '僅為名稱符合指定值的passes追蹤IR變更。需搭配-print-changed使用'
# 'Only count the calls that are recursive'
H531F12291A31: '僅統計遞迴呼叫次數'
# 'Only display members that contribute to class size.'
HAA83522F47FE: '僅顯示影響類別大小的成員'
# 'Only display the basic block whose name matches this for all view-*-dags options'
HB71A82047A43: '僅顯示所有 view-*-dags 選項中名稱相符的基本區塊'
# 'Only display whether errors occurred.'
HDB4BCEB24DBE: '僅顯示是否有錯誤發生。'
# 'Only do the coverage check.'
HD8B2B9D841CB: '僅執行覆蓋率檢查。'
# 'Only dump files with relative paths or absolute paths with the prefix specified by -s'
HD834488625EB: '僅傾印具有相對路徑或以 -s 指定前綴的絕對路徑的檔案。'
# 'Only emit EH frame entries when compact unwind is not available'
HBF3C0E4970CD: '僅在沒有 compact unwind 時發射例外處理框架條目。'
# 'Only emit checks for arguments of functions whose names match the given regular expression'
HA389B7E0BDB5: '僅為名稱符合指定正則表達式的函數參數發射檢查。'
# 'Only enable generating memmove in non-nested loops'
H29441902D683: '僅允許在非巢狀迴圈中生成 memmove。'
# 'Only enumerate VLMAX for VL operand'
H6E315308AF5A: '僅枚舉 VL 運算元的 VLMAX。'
# 'Only execute frontend initialization'
H918B5DDB51E1: '僅執行前端初始化。'
# 'Only functions matching the filter are shown in the output. For overlapping CSSPGO, this takes a function name with calling context.'
H189EF6F2A967: '僅在輸出中顯示符合過濾條件的函數。對於重疊的 CSSPGO，此處接受帶有調用上下文的函數名稱。'
# "Only fuse 'blessed' FP ops."
H7765353506F0: "僅融合 'blessed' 的 FP 運算。"
# "Only fuse FP ops when the result won't be affected."
HDA090F75D8FD: '僅在結果不受影響時融合 FP 運算。'
# 'Only generate the minimal instruction sequence'
H0CBFA1B64E41: '僅生成最簡指令序列'
# 'Only has an effect when specified with -print-pipeline-passes. Disables verifying that the textual pipeline generated by -print-pipeline-passes can be used to create a pipeline.'
HD2EDB018C926: '僅在與 -print-pipeline-passes 一起指定時生效。禁用驗證由 -print-pipeline-passes 生成的文本管線是否可用於建立管線。'
# 'Only i32 comparisons in GPRs.'
HC06CC3A659A2: '僅在 GPR 中執行 i32 比較。'
# 'Only i32 comparisons with sext result.'
HAF411A709509: '僅具有 sext 結果的 i32 比較。'
# 'Only i32 comparisons with zext result.'
HF0A9D937090A: '僅具有 zext 結果的 i32 比較。'
# 'Only i64 comparisons in GPRs.'
HD8F85598F6F1: '僅在 GPR 中執行 i64 比較。'
# 'Only i64 comparisons with sext result.'
H43DD157FC439: '僅具有 sext 結果的 i64 比較。'
# 'Only i64 comparisons with zext result.'
H32746962EC6F: '僅具有 zext 結果的 i64 比較。'
# 'Only import first N functions if N>=0 (default -1)'
H22AE4A1BA0B0: '若N >= 0 則僅匯入前N個函數（預設值 -1）'
# 'Only import functions with less than N instructions'
HFF880FC2904D: '僅匯入包含少於N條指令的函數'
# 'Only include passes which match a specified regular expression in the generated optimization record (by default, include all passes)'
H8C18E65FDB94: '僅包含在生成的最佳化紀錄中符合指定正則表達式的pass（預設包含所有pass）'
# 'Only inline functions explicitly or implicitly marked inline'
H4FB05EC4AB48: '僅內聯明確或隱式標記為inline的函數'
# 'Only instrument 1 of N groups'
HE6DD6434319A: '僅對N組中的 1 組進行插樁'
# 'Only keep the intrinsics with the specified substring in their record name'
HCC2CC4639600: '僅保留其名稱中包含指定子字串的內建函數'
# 'Only lfence before groups of terminators where at least one branch instruction has an input to the addressing mode that is a register other than %rip.'
H7E6136B9D7D9: '僅在符合以下條件的終止指令群組前插入lfence：其中至少有一條分支指令的位址模式輸入為非%rip寄存器'
# 'Only loops with vectorization factor equal to or larger than the specified value are considered for epilogue vectorization.'
H4A61EE8AECF1: '僅考慮向量化因子等於或大於指定值的迴圈進行尾端向量化'
# 'Only match instructions with the given prefix'
H83B563F0FFD8: '僅匹配具有指定前綴的指令'
# 'Only output names of functions whose max count values are below the cutoff value'
HC54ECBB9C757: '僅輸出其最大計數值低於閾值的函數名稱'
# 'Only precompile the input'
H8B49F001F9E2: '僅預編譯輸入'
# 'Only print IR for functions whose name match this for all print-[before|after][-all] options'
HBF4D64D1868D: '僅對所有print-[before|after][-all]選項中名稱匹配的函數輸出IR'
# 'Only print to a depth of N elements.'
HFC218BA7E9C0: '僅輸出至N個元素的深度'
# 'Only process files that match this filter. This flag only applies to all-TUs.'
H9C7DF00BB84A: '僅處理符合此過濾條件的檔案。此選項僅適用於所有翻譯單元（all-TUs）'
# 'Only read thinlto index and print the index as LLVM assembly.'
H4D1BB8D241C8: '僅讀取thinlto索引並將其以LLVM組合語言格式輸出'
# 'Only record optimization remarks from passes whose names match the given regular expression'
HB7A5156C3AD3: '僅記錄名稱符合指定正則表達式的pass所產生的最佳化註記'
# 'Only record remark information for passes whose names match the given regular expression'
H53791F3D3835: '僅記錄名稱符合指定正則表達式的pass的註記資訊'
# 'Only rename namespaces in files that match the given pattern.'
H3FFAEADCD3A9: '僅在展開共同子表達式（CSE）機會時重新排序基本區塊內的表達式'
# 'Only reorder expressions within a basic block when exposing CSE opportunities'
HEC96777F89E9: '僅在特定區域執行（提供的識別符必須出現在該區域入口區塊的名稱中）'
# "Only run on certain regions (The provided identifier must appear in the name of the region's entry block"
H88F1D2665F48: '僅在特定區塊執行（提供的識別符必須出現在該區塊入口區塊的名稱中）'
# 'Only run on functions that match a regex. Multiple regexes can be comma separated. Scop detection will run on all functions that match ANY of the regexes provided.'
H1DBFD722220A: '僅執行符合正則表達式的函數。可提供多個以逗號分隔的正則表達式。Scop偵測將執行於符合任一正則表達式的函數。'
# 'Only run ordered assignment scheduling with no codegen'
HD5721C8545D7: '僅執行有序分配排程（不執行程式碼生成）'
# 'Only run preprocess and compilation steps'
HF940D137E364: '僅執行預處理和編譯步驟'
# 'Only run preprocess, compile, and assemble steps'
H81C1E28BCD95: '僅執行預處理、編譯和組裝步驟'
# 'Only run scop detection, but no other optimizations'
HBD3276584517: '僅執行Scop偵測，但不執行其他優化'
# 'Only run the driver.'
H11F300F88E2D: '僅執行驅動程式。'
# 'Only run the preprocessor'
HCB8008C01361: '僅執行預處理器'
# 'Only schedule this MBB#'
HAAC66E179615: '僅排程此MBB#'
# 'Only schedule this function'
HDDB8FF491938: '僅排程此函數'
# 'Only show debug message if the branch probability is greater than this value (in percentage).'
H364FCDA181C3: '僅當分支概率大於此值（以百分比為單位）時才顯示除錯訊息。'
# 'Only show debug message if the source branch weight is greater  than this value.'
HAD26C2C5503B: '僅當來源分支權重大於此值時才顯示除錯訊息。'
# 'Only show error-related paths in the analysis graph'
HA2114E4FC51E: '分析圖中僅顯示與錯誤相關的路徑'
# 'Only split jump tables containing functions whose sizes are less or equal than this threshold.'
H115A29858DAD: '僅分割包含函數大小小於或等於此閾值的跳躍表。'
# 'Only split jump tables with size less or equal than JumpTableSizeThreshold.'
H159246FC6C6B: '僅分割大小小於或等於JumpTableSizeThreshold的跳躍表。'
# 'Only supported on AArch64, PowerPC, RISC-V, SPARC, SystemZ, and X86'
H6BC9222A7886: '僅支援AArch64、PowerPC、RISC-V、SPARC、SystemZ和X86架構'
# 'Only try to inject loop invariant conditions and unswitch on them to eliminate branches that are not-taken 1/<this option> times or less.'
H93BBEDA4C81E: '僅嘗試注入迴圈不變條件，並對其進行unswitch以消除未被採取次數小於或等於 1/<此選項>次的分支。'
# 'Only use DAG-combiner alias analysis in this function'
H9A1CF1A6CF3A: '僅在此函數中使用DAG-combiner別名分析'
# 'Only use warnings from specified component'
H87D3AEA990F7: '僅使用指定元件的警告'
# 'Only vectorize if you gain more than this number '
H4BBF18444D60: '僅在獲得超過此數值的增益時才執行向量化'
# 'Only vectorize small trees if they are fully vectorizable'
H374794964C3E: '僅在完全可向量化時向量化小樹'
# 'Only view functions that match this pattern'
H0D8068A91934: '僅視為符合此模式的函數'
# 'Only warn if #include directives are inside extern or namespace blocks if the included header is in the header list.'
H9AF148F3DBE5: '僅在包含的標頭位於標頭列表中時，若 #include 指令位於 extern 或命名空間區塊內才發出警告'
# 'Only write combined global index for ThinLTO backends'
HDCE16F222238: '僅為 ThinLTO 後端寫入組合全域索引'
# 'Only write output if it changed'
H89C2A6721B4D: '僅在輸出有變動時寫入'
# 'Only write to the output file if it changed'
H82DD0380BC4C: '僅在輸出有變動時寫入輸出檔案'
# "OpenACC %select{clause '%1'|directive '%2'|sub-array bound}0 requires expression of integer type (%3 invalid)"
H24F0AB7B1FF3: "OpenACC %select{子句 '%1'|指令 '%2'|子陣列邊界}0 需要整數類型的運算式（%3 無效）"
# "OpenACC '%0' clause cannot appear on the same '%2' construct as a '%1' clause %select{inside a compute construct with a|and a}3 'num_gangs' clause with more than one argument"
H86F6667DC7E5: "OpenACC '%0' 子句不能與 '%2' 結構中的 '%1' 子句 %select{內含 compute 結構的|以及}3 'num_gangs' 子句（參數超過一個）同時存在"
# "OpenACC '%0' clause on a 'declare' directive is not allowed at global or namespace scope"
H0D95AB23A6A9: "OpenACC 'declare' 指令上的 '%0' 子句不允许在全域或命名空間範圍使用"
# "OpenACC '%0' construct can only be applied to a 'for' loop"
H7F39DD2F9D48: "OpenACC '%0' 結構只能應用於 'for' 迴圈"
# "OpenACC '%0' construct must have a terminating condition"
HA5F584B3696E: "OpenACC '%0' 結構必須有終止條件"
# "OpenACC '%0' construct must have at least one %1 clause"
H5108FA0063F8: "OpenACC '%0' 結構必須至少有一個 %1 子句"
# "OpenACC '%0' construct must have initialization clause in canonical form ('var = init' or 'T var = init')"
HB6396996D535: "OpenACC '%0' 結構的初始化子句必須採用標準形式（'var = init' 或 'T var = init'）"
# "OpenACC '%0' variable must monotonically increase or decrease ('++', '--', or compound assignment)"
H4842B31AA1BD: "OpenACC '%0' 變數必須單調遞增或遞減（'++'、'--' 或複合賦值運算子）"
# "OpenACC '%1' clause %select{|with more than 1 argument }0may not appear on a '%2' construct with a '%3' clause%select{ with more than 1 argument|}0"
HE77D7FA4A4F6: "OpenACC '%1' 子句 %select{|參數超過一個}0 不可與 '%2' 結構中的 '%3' 子句%select{參數超過一個|}0 併存"
# "OpenACC '%1' clause cannot appear more than once on a '%0' directive"
H22BA6A918DDE: "OpenACC '%1' 子句在 '%0' 指令上不可出現超過一次"
# "OpenACC '%1' clause is not valid on '%0' directive"
H226495157F78: "OpenACC '%1' 子句在 '%0' 指令上無效"
# "OpenACC 'bind' clause on a declaration must bind to the same name as previous bind clauses"
H9E597FA760BB: "宣告上的 OpenACC 'bind' 子句必須綁定與先前 bind 子句相同的名稱"
# "OpenACC 'collapse' clause loop count must be a %select{constant expression|positive integer value, evaluated to %1}0"
HF187F732137C: "OpenACC 'collapse' 子句迴圈計數必須是 %select{常數運算式|正整數值，評估為 %1}0"
# "OpenACC 'gang' clause may have at most one %select{unnamed or 'num'|'dim'|'static'}0 argument"
HC064C4557CFE: "OpenACC 'gang' 子句最多只能有一個 %select{未命名或 'num'|'dim'|'static'}0 參數"
# "OpenACC 'reduction' composite variable must not have non-scalar field"
H9A717A5BB65E: "OpenACC 'reduction' 複合變數不能有非純量成員"
# "OpenACC 'reduction' variable must be a composite of scalar types; %1 %select{is not a class or struct|is incomplete|is not an aggregate}0"
HD35F9CAD567D: "OpenACC 'reduction' 變數必須是純量類型的複合結構；%1 %select{不是類別或結構|不完整|不是聚合類型}0"
# "OpenACC 'reduction' variable must be of scalar type, sub-array, or a composite of scalar types;%select{| sub-array base}1 type is %0"
HEC7D1B479B8F: "OpenACC 'reduction' 變數必須是純量類型、子陣列或純量類型的複合結構；%select{|子陣列基底}1 類型為 %0"
# "OpenACC 'reduction' variable must have the same operator in all nested constructs (%0 vs %1)"
H28C388119D4E: "OpenACC 'reduction' 變數的所有嵌套結構必須使用相同的運算子 (%0 與 %1)"
# "OpenACC 'routine' directive with a name refers to a function with the same name as the function on the following line; this may be unintended"
H18CDEE7EFD75: "OpenACC 'routine' 指令若指定函數名稱，將指向與下一行函數同名的函數；此行為可能非預期"
# "OpenACC 'tile' clause size expression must be %select{an asterisk or a constant expression|positive integer value, evaluated to %1}0"
HA638C30812B2: "OpenACC 'tile' 子句尺寸運算式必須是%select{星號或常量運算式|評估為 %1 的正整數值}0"
# "OpenACC 'update' construct may not appear in place of the statement following a%select{n if statement| while statement| do statement| switch statement| label statement}0"
H3E931AFE1E4E: "OpenACC 'update' 建構不能出現在 %select{if 陳述式|while 陳述式|do 陳述式|switch 陳述式|label 陳述式}0 之後的陳述式位置"
# "OpenACC clause '%0' may not appear on the same construct as a '%1' clause on a '%2' construct"
HFD5E5BF152EC: "OpenACC '%2' 建構中不可同時出現 '%0' 與 '%1' 子句"
# "OpenACC clause '%0' may not follow a '%1' clause in a '%2' construct"
H3810BDC5F66B: "OpenACC '%2' 建構中 '%0' 子句不可出現在 '%1' 子句之後"
# "OpenACC clause '%0' on '%1' construct conflicts with previous data dependence clause"
HD0EC8D82D89C: "OpenACC '%1' 建構的 '%0' 子句與先前的資料依賴子句衝突"
# "OpenACC clause name '%0' is a deprecated clause name and is now an alias for '%1'"
H0277741A1F9D: "OpenACC 子句名稱 '%0' 是已棄用的子句別名，現與 '%1' 等效"
# "OpenACC construct '%0' cannot be used here; it can only be used in a statement context"
HCF6F4162FC42: "OpenACC 建構 '%0' 不可在此處使用；此建構只能用於語法陳述式上下文"
# "OpenACC construct 'routine' with implicit function not yet implemented, pragma ignored"
H861502AB5841: "OpenACC 'routine' 建構的隱式函數尚未實作，pragma 無效"
# "OpenACC construct 'self' has no effect when an 'if' clause evaluates to true"
H4B8F857AB30C: "OpenACC 'self' 子句在 'if' 子句評估為 true 時無效"
# 'OpenACC integer expression has incomplete class type %0'
H5F66C1830606: 'OpenACC 整數運算式具有不完整的類別類型 %0'
# 'OpenACC integer expression requires explicit conversion from %0 to %1'
H20507033806F: 'OpenACC 整數運算式需要將 %0 明確轉換為 %1'
# "OpenACC routine name '%0' does not name a function"
H5802CAE72248: "OpenACC 函數名稱 '%0' 未命名函數"
# "OpenACC routine name '%0' names a set of overloads"
HEC7D774C632B: "OpenACC 函數名稱 '%0' 指代一組重載函數"
# 'OpenACC sub-array %select{lower bound|length}0 evaluated to a value (%1) that would be out of the range of the subscripted array size of %2'
HD993EBC2FF56: 'OpenACC 子陣列 %select{下界|長度}0 評估值 (%1) 超出基底陣列的 %2 維度範圍'
# 'OpenACC sub-array %select{lower bound|length}0 evaluated to negative value %1'
H9C42001B0E35: 'OpenACC 子陣列 %select{下界|長度}0 評估為負值 %1'
# 'OpenACC sub-array base is of incomplete type %0'
H568C42694CA4: 'OpenACC 子陣列基底為不完整類型 %0'
# 'OpenACC sub-array cannot be of function type %0'
H1F4C209C1D7A: 'OpenACC 子陣列不能是函數類型 %0'
# 'OpenACC sub-array length is unspecified and cannot be inferred because the subscripted value is %select{not an array|an array of unknown bound}0'
H3D8516DAE66C: 'OpenACC 子陣列長度未指定且無法推論，因為索引值是 %select{非陣列|未知維度的陣列}0'
# 'OpenACC sub-array specified range [%0:%1] would be out of the range of the subscripted array size of %2'
H7C8F28679BDB: 'OpenACC 子陣列指定範圍 [%0:%1] 將超出被索引陣列大小 %2 的範圍'
# 'OpenACC sub-array subscripted value is not an array or pointer'
H64A7517C6764: 'OpenACC 子陣列的索引值不是陣列或指標'
# "OpenACC variable %select{in 'use_device' clause|on 'declare' construct}0 is not a valid variable name or array name"
H5FFA8811F2EF: "OpenACC 變數 %select{在 'use_device' 子句中|在 'declare' 建構中}0 不是有效的變數名稱或陣列名稱"
# 'OpenACC variable in cache directive is not a valid sub-array or array element'
H0DEC3018E66D: 'OpenACC cache 指令中的變數不是有效的子陣列或陣列元素'
# 'OpenACC variable is not a valid variable name, sub-array, array element,%select{| member of a composite variable,}0 or composite variable member'
HA8B26141C7C6: 'OpenACC變數不是有效的變數名稱、子陣列、陣列元素 %select{|合成變數的成員，}0，或是合成變數的成員'
# 'OpenCL extension %0 is core feature or supported optional core feature - ignoring'
H1E2DAA7C8DD9: 'OpenCL 擴展 %0 是核心功能或支援的選擇性核心功能 - 無視'
# 'OpenCL extension %0 unknown or does not require pragma - ignoring'
HB7D9C7E097C0: 'OpenCL 擴展 %0 無效或無需 pragma - 無視'
# 'OpenCL language standard to compile for.'
H165955277EF6: '要編譯的 OpenCL 語言標準。'
# 'OpenCL only. Allow denormals to be flushed to zero.'
H8AAB3F5FE401: 'OpenCL 專用。允許將次正规數（denormals）置零。'
# 'OpenCL only. Allow floating-point optimizations that assume arguments and results are not NaNs or +-Inf.'
HD11F5701CC10: 'OpenCL 專用。允許假設參數和結果不是 NaN 或 ±無窮大的浮點優化。'
# 'OpenCL only. Allow unsafe floating-point optimizations.  Also implies -cl-no-signed-zeros and -cl-mad-enable.'
HF643B16A83F5: 'OpenCL 專用。允許不安全的浮點優化。這也隱含了 -cl-no-signed-zeros 和 -cl-mad-enable。'
# 'OpenCL only. Allow use of less precise MAD computations in the generated binary.'
H9C454BE02287: 'OpenCL 專用。允許在生成的二進位中使用精度較低的 MAD 計算。'
# 'OpenCL only. Allow use of less precise no signed zeros computations in the generated binary.'
H8DE8DC71375B: 'OpenCL 專用。允許在生成的二進位中使用精度較低且無符號零的計算。'
# 'OpenCL only. Defines that the global work-size be a multiple of the work-group size specified to clEnqueueNDRangeKernel'
H3AFC0A3E3E23: 'OpenCL 專用。定義全域工作大小必須是傳遞給 clEnqueueNDRangeKernel 的工作群組大小的倍數'
# 'OpenCL only. Disables all standard includes containing non-native compiler types and functions.'
H89344E39C234: 'OpenCL 專用。禁用包含非本機編譯器類型和函數的所有標準包含頭檔。'
# "OpenCL only. Enable or disable OpenCL extensions/optional features. The argument is a comma-separated sequence of one or more extension names, each prefixed by '+' or '-'."
H2870B3BCDE72: 'OpenCL 專用。啟用或禁用 OpenCL 擴展/可選功能。參數是用逗號分隔的一個或多個擴展名稱序列，每個名稱前需以 "+" 或 "-" 頭。'
# 'OpenCL only. Generate kernel argument metadata.'
HD27868AF8559: 'OpenCL 專用。產生核心參數元資料。'
# 'OpenCL only. Sets -cl-finite-math-only and -cl-unsafe-math-optimizations, and defines __FAST_RELAXED_MATH__.'
HA1D24030C687: 'OpenCL 專用。設置 -cl-finite-math-only 和 -cl-unsafe-math-optimizations，並定義 __FAST_RELAXED_MATH__。'
# 'OpenCL only. Specify that single precision floating-point divide and sqrt used in the program source are correctly rounded.'
H2DD948248943: 'OpenCL 專用。指定程式來源中使用的單精度浮點除法和平方根運算必須正確捨入。'
# 'OpenCL only. This option disables all optimizations. By default optimizations are enabled.'
HB24BF4359851: 'OpenCL 專用。此選項禁用所有優化。預設情況下優化是啟用的。'
# 'OpenCL only. This option is added for compatibility with OpenCL 1.0.'
HEF34F847970F: 'OpenCL 專用。此選項為與 OpenCL 1.0 相容而加入。'
# 'OpenCL only. Treat double precision floating-point constant as single precision constant.'
H9F9807A3E0E7: 'OpenCL 專用。將雙精度浮點常數視為單精度常數。'
# 'OpenMP array shaping operation is not allowed here'
H6B78DAFB84E5: 'OpenMP 陣列形狀運算在此處不被允許'
# 'OpenMP captured regions are not yet supported in %select{streaming functions|functions with ZA state|functions with ZT0 state}0'
HBFAEB31DF5F3: 'OpenMP 捕獲區域尚未支援 %select{流式函數|具有 ZA 狀態的函數|具有 ZT0 狀態的函數}0'
# "OpenMP clause '%0' is only available as extension, use '-fopenmp-extensions'"
H7D732B734761: "OpenMP 子句 '%0' 是擴展功能，請使用 '-fopenmp-extensions'"
# 'OpenMP constructs may not be nested inside a simd region%select{| except for ordered simd, simd, scan, or atomic directive}0'
HC65424272817: 'OpenMP 結構不得嵌套在 simd 區域內 %select{|，但 ordered simd、simd、scan 或 atomic 指令除外}0'
# 'OpenMP constructs may not be nested inside an atomic region'
HE2C47884F9E6: 'OpenMP 結構不得嵌套在 atomic 區域內'
# "OpenMP extension clause '%0' only allowed with '#pragma omp %1'"
HB7695EC8B674: "OpenMP 擴展子句 '%0' 只允許與 '#pragma omp %1' 一同使用"
# 'OpenMP iterator is not allowed here'
HB9668BC52F3C: 'OpenMP 迭代器在此處不被允許'
# 'OpenMP loop iteration variable cannot have more than 64 bits size and will be narrowed'
H85A842BD8107: 'OpenMP 迭代變數大小不能超過 64 位元，將被縮窄'
# "OpenMP offloading target '%0' is similar to target '%1' already specified; will be ignored"
H66F93F9F54F1: 'OpenMP 進行目標 "%0" 與已指定的目標 "%1" 相似；將被忽略'
# 'OpenMP only allows an ordered construct with the simd clause nested in a simd construct'
H52C83AA3C087: 'OpenMP 僅允許在 simd 結構中嵌套具有 simd 子句的 ordered 結構'
# 'OpenMP standard version'
HA403864CFA0F: 'OpenMP 標準版本'
# 'OpenMP support in flang is still experimental'
HA42DEF114A36: 'flang 中的 OpenMP 支援目前仍處於實驗階段'
# "OpenMP target architecture '%0' pointer size is incompatible with host '%1'"
HF18160FDA94C: "OpenMP 目標架構 '%0' 的指標大小與主機 '%1' 不相容"
# "OpenMP target is invalid: '%0'"
H6461D2D7A8F6: "OpenMP 目標無效: '%0'"
# 'Optimise without changing ABI'
H19D2D13E9ED7: '在不改變ABI的情況下進行優化'
# 'Optimization level 0. Similar to clang -O0. Same as -passes="default<O0>"'
H809F6417B5CD: '優化級別 0。與clang -O0類似。與-passes="default<O0>" 相同'
# 'Optimization level 1. Similar to clang -O1. Same as -passes="default<O1>"'
H563E0780E60E: '優化級別 1。與clang -O1類似。與-passes="default<O1>" 相同'
# 'Optimization level 2. Similar to clang -O2. Same as -passes="default<O2>"'
H71099B09BC66: '優化級別 2。與clang -O2類似。與-passes="default<O2>" 相同'
# 'Optimization level 3. Similar to clang -O3. Same as -passes="default<O3>"'
H73EA61C4E41D: '優化級別 3。與clang -O3類似。與-passes="default<O3>" 相同'
# 'Optimization level for NVVM compilation'
HA23F3D2204EA: 'NVVM編譯的優化級別'
# "Optimization level. [-O0, -O1, -O2, or -O3] (default = '-O2')"
H8F5A63304993: "優化級別。[-O0、-O1、-O2 或 -O3]（預設值 = '-O2'）"
# 'Optimization remarks file containing inline remarks to be replayed by cgscc inlining.'
HEFDDA07D8CA1: '包含由cgscc內聯重播的內聯註解的優化註解文件。'
# 'Optimization remarks file containing inline remarks to be replayed by inlining from sample profile loader.'
H7FC66DD3A1D4: '包含由樣本剖面載入器的內聯進行重播的內聯註解的優化註解文件。'
# 'Optimizations available (use "-passes=" for the new pass manager)'
H61E922DB15A6: '可用的優化（使用 "-passes=" 以使用新的pass管理器）'
# 'Optimize AArch64 selected instructions'
HC4CE467B7223: '優化AArch64選取的指令'
# 'Optimize LiveIntervals for WebAssembly'
H18D7A3DF4B0B: '為WebAssembly優化LiveIntervals'
# 'Optimize SCoPs using ISL'
HCB9C725F1344: '使用ISL優化SCoPs'
# 'Optimize addressing mode'
HD2F645235970: '優化位址模式'
# 'Optimize callbacks'
H4FA5D57DC24A: '優化回呼函數'
# 'Optimize calls with "returned" attributes for WebAssembly'
H77D4D84768F4: '為WebAssembly優化帶有 "returned" 屬性的呼叫'
# 'Optimize for code generation'
HB09B7FAA4243: '優化程式碼生成'
# 'Optimize for size'
H36D83A6CA81E: '優化大小（以最小化程式碼大小為目標）'
# 'Optimize for size  (like /Og     /Os /Oy /Ob2 /GF /Gy)'
H45F672EE3075: '優化大小（例如 /Og /Os /Oy /Ob2 /GF /Gy）'
# 'Optimize for size (like clang -Os)'
HFB8E68DF5FCB: '針對大小進行最佳化（類似 clang -Os）'
# 'Optimize for speed'
H56E47BC17587: '針對速度進行最佳化'
# 'Optimize for speed (like /Og /Oi /Ot /Oy /Ob2 /GF /Gy)'
HC5F6A322D605: '針對速度進行最佳化（類似 /Og /Oi /Ot /Oy /Ob2 /GF /Gy）'
# 'Optimize for speed (like clang -O3)'
HA3959EB2D045: '針對速度進行最佳化（類似 clang -O3）'
# 'Optimize instrumentation'
H4C86894C9330: '針對插樁進行最佳化'
# 'Optimize machine instruction PHIs'
H86D600E2A81C: '針對機器指令 PHIs 進行最佳化'
# 'Optimize memory intrinsic result values for WebAssembly'
HFC7D2A9B2DB2: '針對 WebAssembly 的記憶體內建函數結果值進行最佳化'
# 'Optimize selects'
H2F525E20DF58: '針對選擇進行最佳化'
# 'Optimize spill slots'
HE31BB3136FBC: '針對溢出儲存區進行最佳化'
# 'Optimize the memop size <= this value'
HD160B7A51C58: '設定記憶體操作大小的最大值（<=此值）'
# 'Optimizer Pipeline'
H226573EDB1C0: '最佳化管線'
# 'Option passed to ISL'
HA7C0FFCC5B20: '傳遞給 ISL 的選項'
# 'Optional remark arg to filter collection by (accepts regular expressions).'
H3E0D571E2D16: '用於根據正則表達式篩選集合的可選註記引數。'
# 'Optional remark arg to filter collection by.'
H4BB3B1D09826: '用於篩選集合的可選註記引數。'
# 'Optional remark name to filter collection by (accepts regular expressions).'
H1C5E04FF9D98: '用於根據正則表達式篩選集合的可選註記名稱。'
# 'Optional remark name to filter collection by.'
H660F0832C261: '用於篩選集合的可選註記名稱。'
# 'Optional remark pass name to filter collection by (accepts regular expressions).'
H2B175B559D90: '用於根據正則表達式篩選集合的可選 pass 名稱。'
# 'Optional remark pass name to filter collection by.'
H4733818447B2: '用於篩選集合的可選 pass 名稱。'
# 'Optional remark type to filter collection by.'
HA70FC86A45D5: '用於篩選集合的可選註記類型。'
# 'Options for -gen-(attrdef|typedef|enum|op|dialect)-doc'
H639716290785: '用於 -gen-(attrdef|typedef|enum|op|dialect)-doc 的選項'
# 'Options for -gen-asm-matcher'
H01AF394D0C16: '-gen-asm-matcher 的選項'
# 'Options for -gen-asm-parser'
H9ACA7721D57A: '-gen-asm-parser 的選項'
# 'Options for -gen-asm-writer'
HC2084E3135D4: '-gen-asm-writer 的選項'
# 'Options for -gen-attrdef-*'
H904334F41DE4: '-gen-attrdef-* 的選項'
# 'Options for -gen-bytecode'
H6F6AAAD1A1D2: '-gen-bytecode 的選項'
# 'Options for -gen-dag-isel'
H28817938BEA9: '-gen-dag-isel 的選項'
# 'Options for -gen-dialect-*'
HA2A748C26694: '-gen-dialect-* 的選項'
# 'Options for -gen-disassembler'
H7B14D2A69B34: '-gen-disassembler 的選項'
# 'Options for -gen-global-isel'
HAE024C7C3B27: '-gen-global-isel 的選項'
# 'Options for -gen-global-isel-combiner'
H4132B3D1DEF9: '-gen-global-isel-combiner 的選項'
# 'Options for -gen-instr-info'
H0D7A354B88C3: '-gen-instr-info 的選項'
# 'Options for -gen-intrinsic-enums'
H65B201D59766: '-gen-intrinsic-enums 的選項'
# 'Options for -gen-irdl-dialect'
HAAF45CF21F4C: '-gen-irdl-dialect 的選項'
# 'Options for -gen-pass-capi-header and -gen-pass-capi-impl'
H849A90D3FA97: '-gen-pass-capi-header 和 -gen-pass-capi-impl 的選項'
# 'Options for -gen-pass-decls'
HD4DF70DE63FF: '-gen-pass-decls 的選項'
# 'Options for -gen-python-op-bindings'
HFFB2EE013BDE: '-gen-python-op-bindings 的選項'
# 'Options for -gen-register-info'
H1593471B9CB0: '-gen-register-info 的選項'
# 'Options for -gen-sdnode-info'
H1CDBACD50609: '-gen-sdnode-info 的選項'
# 'Options for -gen-typedef-*'
H9F13AB96225A: '-gen-typedef-* 的選項'
# 'Options for -print-enums'
HCC367BFA06F6: '-print-enums 的選項'
# 'Options for gen-directive-decl'
HB3B2620C73DD: 'gen-directive-decl選項的設定'
# 'Options for op definition generators'
H563831A68B15: '運算子定義生成器的選項'
# 'Options to disable Loop Idiom Recognize Pass.'
HEC1AFA3F201E: '停用Loop Idiom Recognize Pass的選項。'
# 'Options to pass to the fuzzer'
H35D63FFBE491: '傳遞給模糊測試器的選項'
# 'Options: <empty>'
H86F57A40CF46: '選項: <空>'
# 'Options: <empty>|Legal|Discard|Convert. If non-empty, ignore TargetTransformInfo and always use this transformation for the %evl parameter (Used in testing).'
H04319FFE1FD4: '選項: <空>|合規|棄用|轉換。如果非空，忽略TargetTransformInfo並始終使用此轉換參數%evl（測試用）。'
# 'Orc JIT'
H76C72319C493: 'Orc JIT'
# 'Orc-based lazy JIT.'
H732AA2A7BDF4: '基於 Orc 的惰性 JIT。'
# 'Orc-specific linker'
HCE705FE1F603: 'Orc專用連結器'
# 'Order local stack symbols.'
H1D5554EC3474: '排序本地堆疊符號。'
# 'Other Options'
H9CB6F2FB01DF: '其他選項'
# 'Outline loop blocks from loop chain if (frequency of loop) / (frequency of block) is greater than this ratio'
HB57131BBFAC5: '如果迴圈頻率除以區塊頻率大於此比例，則從迴圈鏈中提取迴圈區塊'
# 'Output'
H4BED336194A9: '輸出'
# 'Output .gcov in intermediate text format'
HF37052F8B66C: '以中間文字格式輸出.gcov'
# 'Output Filename'
H253060EBAB8E: '輸出檔名'
# 'Output Options'
HFCD12607F17F: '輸出選項'
# 'Output a side-by-side diff in HTML.'
H57654452ACF4: '以HTML格式輸出並排比較的差異。'
# 'Output assembly code file during compilation'
H6310B853EF5F: '編譯期間輸出組譯程式碼檔'
# 'Output assembly listing file'
H1DE8B74129C4: '輸出組譯程式列表檔'
# 'Output dwarf accelerator tables.'
H13E79CD2B348: '輸出DWARF加速表。'
# 'Output file'
HB6AEEF874B66: '輸出文件'
# 'Output file for export'
HF9225788216E: '輸出用於匯出的文件'
# 'Output file. Can be specified multiple times for multiple output files.'
HEE2A7A1E3079: '可多次指定以生成多個輸出文件。'
# 'Output filename'
H85DF5E35434C: '輸出檔名'
# 'Output filename for pass remarks'
HB92A0E8D19B1: 'Pass 備註的輸出檔名'
# 'Output filename for the reduced test case'
HD417AF7888E3: '簡化測試案例的輸出檔名'
# 'Output format for line-based coverage reports'
H556FF7AB0CB0: '行基底覆蓋率報告的輸出格式'
# 'Output format for timing data'
H55AABD7334B6: '時間數據格式'
# 'Output graphs with edge colors determined by this field'
H794FD3A570E0: '根據此字段確定邊顏色的圖形輸出'
# 'Output graphs with edges colored by this field'
HF746FFB4D465: '根據此字段對邊著色的圖形輸出'
# 'Output graphs with edges labeled with this field'
H24D87E28CEB2: '根據此字段對邊標記的圖形輸出'
# 'Output graphs with vertex colors determined by this field'
H074479A80832: '根據此字段確定頂點顏色的圖形輸出'
# 'Output graphs with vertices colored by this field'
H2DF9C4C8C65F: '根據此字段對頂點著色的圖形輸出'
# 'Output graphs with vertices labeled with this field'
HE53D4D1DCDFD: '根據此字段對頂點標記的圖形輸出'
# "Output in chrome's trace event format. May be visualized with the Catapult trace viewer."
H9A05A1436798: '以 Chrome 的追蹤事件格式輸出。可使用 Catapult 追蹤檢視器進行可視化。'
# 'Output input source as HTML'
HE9E58C4AFE0A: '將輸入來源輸出為 HTML'
# 'Output instructions per ScopStmt'
H0963CFA695BF: '輸出 ScopStmt 的指令'
# 'Output object file'
H427E379BB7CB: '輸出物件檔'
# 'Output options'
HCA4409BA27DC: '輸出選項'
# 'Output profile file'
H3C5CF3CF6071: '輸出剖析檔案'
# 'Output replacements as XML.'
H1724D4877353: '以XML格式輸出取代內容。'
# 'Output resource usage of launched kernels'
H76E82EB3BAF1: '輸出啟動核心的資源使用情況'
# 'Output the total number corresponding to the count for the provided input file.'
H8049C03B1803: '輸出與提供的輸入檔案計數對應的總數。'
# "Output trace to the given file name or '-' for stdout."
H8DCBEA863061: "將追蹤輸出到指定的檔案名稱或使用 '-' 表示標準輸出。"
# 'Outputs for view.'
H377C2CC892EF: '用於顯示的輸出。'
# 'Overapproximation of dependences'
HEFB667282405: '依賴關係的上近似值'
# 'Overlay the virtual filesystem described by file over the real file system'
H291889337D71: '將文件描述的虛擬檔案系統覆疊至實際檔案系統'
# 'Overlay the virtual filesystem described by file over the real file system. Additionally, pass this overlay file to the linker if it supports it'
HAFADC554CE4B: '將文件描述的虛擬檔案系統覆疊至實際檔案系統。若連結器支援，則將此覆疊檔傳遞給連結器'
# 'Override cost based safe divisor widening for div/rem instructions'
H81D91B0A076D: '覆寫基於成本的除法/取餘指令安全除數擴展'
# 'Override default dump names'
H7A6C6DC9BBC4: '覆寫預設的傾印名稱'
# 'Override host target triple'
HF3CC7F9CE700: '覆寫主機目標三元組'
# 'Override inferred gcda file'
H68DED86E4EE4: '覆寫推斷的gcda檔案'
# 'Override inferred gcno file'
H756521C312EE: '覆寫推斷的gcno檔案'
# 'Override optimization level for codegen hooks, legacy PM only'
HCB07980F5249: '覆寫程式碼生成鉤子的優化等級，僅適用於舊版程序管理器'
# 'Override output filename'
HAFF5159DAF01: '覆寫輸出檔名'
# 'Override record layouts with those in the given file'
H3D9B83089303: '使用給定檔案中的結構布局覆寫'
# "Override source file's content (in the overlaying\nvirtual file system) with input from <stdin> and run\nthe tool on the new content with the compilation\noptions of the source file. This mode is currently\nused for editor integration."
H9F6FADB4D508: '覆寫虛擬檔案系統中的來源檔內容，以標準輸入的輸入覆寫，並使用來源檔的編譯選項對新內容執行此工具。此模式目前用於編輯器整合。'
# 'Override target triple detection'
H3331B75D4B40: '覆寫目標三元組偵測'
# 'Override target triple for module'
HAD133DEC039A: '覆寫模組的目標三元組'
# "Override the 'argv[0]' value passed into the executing program"
HD3C4FA0CA7DA: "覆寫傳遞給執行程式中的 'argv[0]' 值"
# 'Override the behaviour of '
H053262A576A2: '覆寫 的行為'
# 'Override the behaviour of expand-variadics'
H8E4D335E1CAD: '覆寫展開可變參數的行為'
# 'Override the default ABI to return all structs on the stack'
H796683BA46B0: '覆寫預設的ABI，將所有結構體返回到堆疊上'
# 'Override the default ABI to return small structs in registers'
H14D9E95511EF: '覆寫預設的ABI，將小結構體返回到寄存器中'
# 'Override the path to the output spec json file. See -ml-inliner-model-under-training documentation for the specification of that file.'
HA0B2BFC5945E: '覆寫輸出規格JSON文件的路徑。請參閱 -ml-inliner-model-under-training 文件以獲取該文件的規格說明。'
# 'Override the processor dispatch width'
HBBE12C3A519F: '覆寫處理器的分派寬度'
# 'Override the profitability heuristics for Machine CSE'
H05022840BC44: '覆寫機器CSE的效益启发式算法'
# 'Override the variant of check applied to authenticated LR during tail call'
H929544275FD6: '覆寫尾調用期間對驗證的LR套用的檢查類型'
# 'Override the vector register size in bits, which is otherwise found by querying TTI.'
H8FCFAFF95563: '覆寫向量寄存器的位數（否則透過查詢TTI取得）'
# 'Override the visibility of globals based on their final DLL storage class.'
HB70286716DCC: '根據最終DLL存儲類別覆寫全域變數的可見性'
# 'Override unique ID of ctor/dtor globals.'
HA514528D025F: '覆寫構造函數/析構函數全域變數的唯一ID'
# 'Override use of color (default = isatty)'
HFB4A1E45D51F: '覆寫顏色使用（預設=isatty）'
# 'Override validator version for module. Format: <major.minor>;Default: DXIL.dll version or current internal version'
H29DBA8820EEB: '覆寫模組的驗證器版本。格式：<主版本.次版本>；預設：DXIL.dll版本或目前內部版本'
# 'Overrides result used for getMaximumVF query which is used exclusively by SLP vectorizer.'
H790D0193AFF1: '覆寫由SLP向量化器專用的getMaximumVF查詢所使用的結果'
# 'Overrides the _OPENACC macro value for experimental testing during OpenACC support development'
H1F6C8876A478: '覆寫_OpenACC宏值，用於OpenACC支援開發期間的實驗測試'
# 'Overwrite edited files.'
HA46F1C96B7DC: '覆寫已編輯的檔案'
# 'PASSED'
H75168D9452E2: 'PASSED'
# 'PBQP register allocator'
HC52F58BD0440: 'PBQP寄存器分配器'
# 'PCH was compiled with different VFS overlay files than are currently in use'
H6654F3AEB3F7: 'PCH 編譯時使用的虛擬文件系統覆蓋文件與目前使用的不同'
# 'PDB Stream Options'
HE58091817322: 'PDB 流選項'
# 'PDLL Frontend'
H667EECC1B90F: 'PDLL 前端'
# 'PDLL LSP Language Server'
HCB7860D44409: 'PDLL LSP 語言伺服器'
# 'PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace, preprocessed source, and associated run script.\n'
H3E1C9F287454: '請提交錯誤報告至 https://github.com/llvm/llvm-project/issues/，並包含崩潰的堆疊追蹤、預處理後的原始碼和相關執行腳本。\n'
# 'PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\n'
H0DE59CCB7CD2: '請提交錯誤報告至 https://github.com/llvm/llvm-project/issues/，並包含崩潰的堆疊追蹤。\n'
# 'POSIX thread model'
HAAFA3F8D71A1: 'POSIX 線程模型'
# 'Pack non-contiguous assummed shape arrays into contiguous memory'
H3E0440CD78CB: '將非連續的假設形狀陣列封裝到連續記憶體中'
# 'Pad previous instructions to implement align directives'
H461F83B5992B: '填充之前的指令以實踐對齊指示'
# 'Pad previous instructions to implement branch alignment'
H9A3FD2CE91B3: '填充之前的指令以實踐分支對齊'
# 'Pair of function name and filename, where function should be imported from bitcode in filename'
H0856646593E7: '函數名稱與檔案名稱的配對，其中函數應從指定的bitcode檔案中導入'
# 'Parameter.'
H78B17095F0E6: '參數。'
# 'Parse OpenMP pragmas and generate parallel code.'
H203F2D0AAEA4: '解析OpenMP pragma並生成平行程式碼。'
# 'Parse and pretty-print the input'
HE106679F4FE4: '解析並美觀列印輸入'
# 'Parse templated function definitions at the end of the translation unit'
H187BB681FD43: '在翻譯單位末尾解析模板函數定義'
# 'Partially inline calls to library functions'
HD08FDB669104: '部分內聯庫函數的呼叫'
# 'Partition data sections using profile information.'
HBDB4D3B42575: '使用剖面資訊分割資料區段。'
# 'Partition functions into N groups and select only functions in group i to be instrumented using -fprofile-selected-function-group'
H245EBE517AA5: '將函數分為N個群組，並僅選擇第i群組的函數進行插樿，使用-fprofile-selected-function-group選項'
# 'Partition functions into N groups using -fprofile-function-groups and select only functions in group i to be instrumented. The valid range is 0 to N-1 inclusive'
HE1BA0DFA9946: '使用-fprofile-function-groups將函數分為N個群組，並僅選擇第i群組的函數進行插樿。有效範圍為 0 到N-1（包含端點）'
# 'Pascal string is too long'
HDF5B602956C9: 'Pascal字串過長'
# 'Pass -b <arg> to the linker on AIX'
HC027AB59908D: '在AIX上將 -b <arg> 傳遞給連結器'
# 'Pass -z <arg> to the linker'
HC96FADA8EF05: '將 -z <arg> 傳遞給連結器'
# 'Pass <arg> to clang -cc1'
H7056B37839B2: '將 <arg> 傳遞給 clang -cc1'
# 'Pass <arg> to fatbinary invocation'
HE6E06CC967E5: '將 <arg> 傳遞給 fatbinary 呼叫'
# 'Pass <arg> to plugin <name>'
H194FFD6DEF4E: '將 <arg> 傳遞給插件 <name>'
# 'Pass <arg> to the CUDA/HIP device compilation'
H6E93CAC5A2A4: '將 <arg> 傳遞給 CUDA/HIP 裝置編譯'
# 'Pass <arg> to the CUDA/HIP host compilation'
HBD5864C8EAAC: '將 <arg> 傳遞給 CUDA/HIP 主機編譯'
# 'Pass <arg> to the assembler'
H260454350861: '將 <arg> 傳遞給組譯器'
# 'Pass <arg> to the clang driver'
H0BA43F60ADF1: '將 <arg> 傳遞給 clang 驅動程式'
# 'Pass <arg> to the compilation if the target matches <arch>'
H28A6957698C7: '如果目標與 <arch> 匹配，則將 <arg> 傳遞給編譯'
# 'Pass <arg> to the flang compiler'
HA8F1AD31AB5E: '將 <arg> 傳遞給 flang 編譯器'
# 'Pass <arg> to the linker'
H47C4E471D4CC: '將 <arg> 傳遞給連結器'
# 'Pass <arg> to the offload linkers or the ones identified by -<triple>'
HF43CE14F52D9: '將 <arg> 傳遞給 offload 連結器或由 -<triple> 指定的連結器'
# 'Pass <arg> to the preprocessor'
HECFF1F09AA70: '將 <arg> 傳遞給預處理器'
# 'Pass <arg> to the ptxas assembler'
HDA10BB61A91B: '將 <arg> 傳遞給 ptxas 組譯器'
# 'Pass <arg> to the static analyzer'
H665CD83A1EA3: '將 <arg> 傳遞給靜態分析工具'
# 'Pass <arg> to the target offloading toolchain identified by <triple>.'
HD393E82FA340: '將 <arg> 傳遞給由 <triple> 指定的目標 offload 工具鏈。'
# 'Pass <arg> to the target offloading toolchain.'
H786E5FF9D985: '將 <arg> 傳遞給目標 offload 工具鏈。'
# 'Pass a workload definition. This is a file containing a JSON dictionary. The keys are root functions, the values are lists of functions to import in the module defining the root. It is assumed -funique-internal-linkage-names was used, to ensure local linkage functions have unique names. For example: \n{\n  "rootFunction_1": ["function_to_import_1", "function_to_import_2"], \n  "rootFunction_2": ["function_to_import_3", "function_to_import_4"] \n}'
H8F2A17B54334: '傳遞一個工作負載定義。此為包含 JSON 字典的檔案。鍵為根函數，值為要導入至根函數模組的函數清單。假設已使用 -funique-internal-linkage-names 以確保內部連結函數具有唯一名稱。例如：\n{\n  "rootFunction_1": ["function_to_import_1", "function_to_import_2"], \n  "rootFunction_2": ["function_to_import_3", "function_to_import_4"] \n}'
# 'Pass all reduction arguments by reference'
H1F6E6E7DA880: '以引用方式傳遞所有約束參數'
# 'Pass the comma separated arguments in <arg> to the assembler'
H0BB4ECAE0BD9: '<arg> 中以逗號分隔的參數傳遞給組譯器'
# 'Pass the comma separated arguments in <arg> to the linker'
H01CAEC128AC9: '<arg> 中以逗號分隔的參數傳遞給連結器'
# 'Pass the comma separated arguments in <arg> to the preprocessor'
H596C87A5B391: '<arg> 中以逗號分隔的參數傳遞給預編譯器'
# 'Passes available:'
H13989372E812: '可用的Passes：'
# 'Path and name to DWP file.'
H6E3C7CBCF218: 'DWP文件的路徑和名稱。'
# 'Path of .dwp file. When not specified, it will be <binary>.dwp in the same directory as the main binary.'
H743B0B321E91: '包含.dwp文件的路徑。若未指定，將在主二進位檔的同一目錄下使用 <binary>.dwp。'
# 'Path of debug info binary, llvm-profgen will load the DWARF info from it instead of the executable binary.'
H7CB4490678CE: '除錯資訊二進位檔的路徑。llvm-profgen將從此處載入DWARF資訊，而非可執行檔。'
# 'Path of perf-script trace created by Linux perf tool with `script` command(the raw perf.data should be profiled with -b)'
H3DEF1722D3DA: 'Linux perf工具使用`script`命令產生的perf-script追蹤檔路徑（原始perf.data需以-b參數分析）'
# 'Path of profiled executable binary.'
H3B42E7676CEA: '已分析的可執行二進位檔的路徑。'
# 'Path of raw perf data created by Linux perf tool (it should be profiled with -b)'
HFDF5B6ACDEB6: 'Linux perf工具產生的原始perf數據文件路徑（需以-b參數分析）'
# 'Path of the LLVM sample profile'
H33F3BE9ADD2D: 'LLVM樣本分析檔的路徑'
# 'Path of the unsymbolized profile created by `llvm-profgen` with `--skip-symbolization`'
H946923D050AC: '使用`--skip-symbolization`參數生成的未符號化分析檔路徑'
# 'Path to CSV file containing lines of function names and attributes to add to them in the form of `f1,attr1` or `f2,attr2=str`.'
HAA93B63D725F: '包含以逗號分隔的函數名稱和屬性清單的CSV文件路徑，格式為`f1,attr1`或`f2,attr2=str`。'
# 'Path to SavedModel from the previous training iteration.\nThe directory is also expected to contain a JSON specification of the \noutputs expected to be logged, where the first entry must be the \ninlining decision. The file containing the specification should be \ncalled output_spec.json. The expected JSON value is an array of \ndictionaries. Each dictionary should have 2 keys: \n\n- "tensor_spec, followed by the TensorSpec description of the\noutput; and \n- "logging_name", a string indicating the name to use when\nlogging the output values. \n\nExample:\n[\n  {\n    "logging_name" : "some_name", \n    "tensor_spec" : { \n      "name" : "model_name", \n      "port" : 0,\n      "shape" : [2, 3],\n      "type" : "float"\n      }\n  }\n]\n\nThe first value must always correspond to the decision.'
H9AB7FF7DDB14: '前一次訓練迭代的SavedModel路徑。\n目錄中應包含JSON格式的輸出規格說明文件，第一項必須是內聯決策。規格說明文件應命名為output_spec.json，其JSON結構為字典陣列，每個字典需包含 2 個鍵：\n\n- "tensor_spec"，後接輸出的TensorSpec描述；\n- "logging_name"，用於記錄輸出值的字符串名稱。\n\n範例：\n[\n  {\n    "logging_name" : "some_name", \n    "tensor_spec" : { \n      "name" : "model_name", \n      "port" : 0,\n      "shape" : [2, 3],\n      "type" : "float"\n      }\n  }\n]\n\n第一個值必須始終對應決策結果。'
# 'Path to a directory containing a .clang-format file\ndescribing a formatting style to use for formatting\ncode when -style=file.\n'
H1C68FD05289D: '包含.clang-format格式設定檔的目錄路徑\n當使用-style=file格式時，用於代碼格式化的樣式描述文件。\n'
# 'Path to a system assembler, picked up on AIX only'
HD76EB0189931: '僅在AIX系統上使用的系統組譯器路徑'
# 'Path to binary from which the profile was collected.'
HDF7F0FA583A9: '分析資料來源二進位檔的路徑。'
# 'Path to file containing newline-separated [<weight>,]<filename> entries'
H39AF8CCE2C18: '包含以新行分隔的[<權重>,]<filename> 條目的文件路徑'
# 'Path to file containing the list of function symbols used to populate profile symbol list'
H85546B6474C7: '用於建立分析符號清單的函數符號列表文件路徑'
# 'Path to ignorelist file for sanitizers'
H685EED5F185D: '檢查工具的忽略清單文件路徑'
# 'Path to libomptarget-amdgcn bitcode library'
H409595E6068A: '路徑至 libomptarget-amdgcn 位元碼函式庫'
# 'Path to libomptarget-nvptx bitcode library'
H1DFEDD2BDCE9: '路徑至 libomptarget-nvptx 位元碼函式庫'
# 'Path to libomptarget-spirv bitcode library'
H17C48C664B7B: '路徑至 libomptarget-spirv 位元碼函式庫'
# "Path to opt. (default: search path for 'opt'.)"
H87E2E1DC35F9: "路徑至 opt。 （預設值：搜尋 'opt' 的路徑。）"
# 'Path to ptxas (used for compiling CUDA code)'
H902CF64E7382: '路徑至 ptxas（用於編譯 CUDA 程式碼）'
# 'Path to saved model evaluating native size from IR.'
H90E4D367F618: '路徑至評估本機大小的保存模型。'
# 'Path to system headers on z/OS'
H858924F171F6: '路徑至 z/OS 的系統標頭檔'
# 'Path to system ignorelist file for sanitizers'
H6EB010D2085A: '路徑至檢查程式系統忽略清單檔'
# 'Path to the DIA SDK'
HEE09636C6E6A: '路徑至 DIA SDK'
# 'Path to the IR file produced by the frontend for the host.'
H6108420B0DC9: '路徑至前端為主機產生的 IR 檔案'
# 'Path to the VCToolChain'
H5C43C23950E7: '路徑至 VCToolChain'
# 'Path to the Windows SDK'
H6252659C1D52: '路徑至 Windows SDK'
# 'Path to the YAML configuration file to be used for multilib selection'
H370257D7FAE7: '路徑至用於選擇 multilib 的 YAML 設定檔'
# 'Path to the file where tracer logs will be stored'
HB84166BE320D: '路徑至存放追蹤器記錄的檔案'
# 'Path to the instrumented context sensitive profile.'
H374A91784042: '路徑至插樁的上下文相關剖析檔。'
# 'Path to the memory profile.'
H0F3D8AAD8CB7: '路徑至記憶體剖析檔。'
# 'Path to the prefetch hints profile. See also -x86-discriminate-memops'
HC95B0BC0D2ED: '路徑至預取提示剖析檔。另請參閱 -x86-discriminate-memops'
# 'Path to the profile remapping file.'
H16575118DC15: '路徑至剖析重新映射檔。'
# 'Path to the profile.'
H327691C6666D: '路徑至剖析檔。'
# 'Path to the project. Required when connecting using remote index.'
HD4FC494735F6: '路徑至專案。使用遠端索引連線時需要。'
# 'Path to where .dwo files will be written out to.'
H41452088F682: '要寫入.dwo文件的路徑。'
# 'Path where the development - mode inlining log is saved.'
H72974DF4C8AA: '保存開發模式內聯日志的路徑。'
# 'Pathname where the element is defined.'
H33A4EFF1B837: '元素定義的路徑名稱。'
# 'Peephole Optimizations'
H6FFA8D4ADC02: '小孔優化'
# 'Penalty of calling a function that requires a change to PSTATE.SM'
H135B935B6400: '呼叫需要更改PSTATE.SM函數的處罰值'
# 'Penalty of inlining a call that requires a change to PSTATE.SM'
HF8B0216049CB: '內聯需要更改PSTATE.SM函數的處罰值'
# 'Percentage of prologue execution count to use as threshold when evaluating whether a block is cold enough to be profitable to move eligible spills there'
HB814EF09C393: '使用函數prologue的執行計數百分比作為閾值，用以評估是否將符合條件的溢出移動到冷區塊是否值得'
# 'Percentage threshold for splitting single-instruction critical edge. If the branch threshold is higher than this threshold, we allow speculative execution of up to 1 instruction to avoid branching to splitted critical edge'
HF3E418A57D78: '分支閾值高於此閾值時，允許預測執行最多 1 條指令以避免分支到分割的關鍵邊'
# 'Percentage threshold of matched basic blocks at which stale profile inference is executed.'
H38AE58F6A0A2: '當匹配的基本區塊百分比閾值達到時執行過時剖面推斷。'
# 'Percentile of profile quality distributions over hottest functions to report.'
H5CD854B0BEDF: '要報告的最熱函數剖面品質分佈的百分位數。'
# 'Percentile profile summary cutoff used to determine cold blocks. Unused if set to zero.'
H3E03792B2D91: '用於確定冷區塊的剖面摘要切割百分位數。若設置為零則不使用。'
# 'Perform ODR checks for decls in the global module fragment.'
H69A7B0ED61B4: '對全局模組片段中的decls執行ODR檢查。'
# 'Perform SME peephole optimization'
HCDB7263D2CEF: '執行SME小孔優化'
# 'Perform ThinLTO end-to-end'
H303BC754B9A0: '執行ThinLTO端到端優化'
# 'Perform ThinLTO importing using provided function summary index'
HC1B8CB3D2919: '使用提供的函數摘要索引執行ThinLTO導入'
# 'Perform ThinLTO optimizations.'
H801619F35DAD: '執行ThinLTO優化。'
# 'Perform a single ThinLTO stage:'
H6083E399B9A6: '執行單一ThinLTO階段：'
# 'Perform both promotion and cross-module importing (requires -thinlto-index).'
H625E880C0440: '同時執行提升和跨模組導入（需要-thinlto-index）。'
# 'Perform branch folding during placement. Reduces code size.'
HC83634EE199F: '在放置期間執行分支摺疊。可減少代碼大小。'
# 'Perform context sensitive PGO instrumentation'
H9FA2FCAD28BD: '執行上下文敏感的PGO插樁'
# 'Perform dummy load from authenticated address'
H53EA500A8E1C: '從驗證地址執行虛設載入'
# 'Perform expensive assert validation on every query to Instruction Precedence Tracking'
HB66C9831C0D5: '在每次查詢指令優先順序追蹤時執行昂貴的斷言驗證'
# "Perform extra assertion checking to verify that PHINodes's hash function is well-behaved w.r.t. its isEqual predicate"
HC9E8890BCE7F: '執行額外的斷言檢查，以驗證PHINodes的雜湊函數在相對於其isEqual判斷式時行為良好'
# "Perform extra assertion checking to verify that SimpleValue's hash function is well-behaved w.r.t. its isEqual predicate"
H56A34E9BD071: '執行額外的斷言檢查，以驗證SimpleValue的雜湊函數在相對於其isEqual判斷式時行為良好'
# 'Perform frequent verification checks on nodes.'
H17FE3747FAAC: '對節點執行頻繁的驗證檢查'
# 'Perform internalization driven by -exported-symbol (requires -thinlto-index).'
H1934C0B7F9D0: '根據-exported-symbol參數驅動的內部化（需要-thinlto-index）'
# 'Perform link through clang-sycl-linker via the target offloading toolchain.'
H3D0FA081F298: '透過目標卸載工具鏈使用clang-sycl-linker進行連結'
# 'Perform mandatory inlinings module-wide, before performing inlining'
HBFA39AA6F76F: '在進行內聯之前，模組範圍內執行強制內聯'
# 'Perform optimizations based on pattern matching'
H48981223D558: '基於模式匹配進行優化'
# 'Perform optimizations of matrix multiplications based on pattern matching'
H175644A4FF20: '基於模式匹配優化矩陣乘法'
# 'Perform optimizations of tensor contractions based on pattern matching'
H07134EDA2398: '基於模式匹配優化張量收縮'
# 'Perform pre-import promotion (requires -thinlto-index).'
HD57DCDC50753: '執行預導入提升（需要-thinlto-index）'
# 'Perform tail duplication during placement. Creates more fallthrough opportunities in outline branches.'
HF926F65659FB: '在放置期間執行尾部複製。在綱要分支中產生更多穿透機會'
# 'Perform verification checks on CallingContextGraph.'
H0D2194DF6309: '對CallingContextGraph執行驗證檢查'
# 'Performs lazy compilation on whole module boundaries rather than individual functions'
H0286F9E0FE8F: '在模組邊界執行惰性編譯，而不是單獨函數'
# 'Permit merging of identical functions when optimizing.'
H3F2353AD4C4D: '優化期間允許合併相同的函數'
# 'Phi Values Analysis'
H4E3B42E3B884: 'Phi值分析'
# 'Place ASan constructors in comdat sections'
H88C0022D413C: '將ASan建構函數放置在comdat區段'
# 'Place Backedge Safepoints'
H8C4883CA47B7: '放置後邊緣安全點'
# 'Place MSan constructors in comdat sections'
H3E7B76D6C9CA: '將MSan建構函數放置在comdat區段'
# 'Place all main program variables in static memory (otherwise scalars may be placed on the stack)'
HC378DD7FF55D: '將所有主程式變數放在靜態記憶體中（否則純量可能被放置在堆疊上）'
# 'Place constant objects with relocatable address values in the RO data section and add -bforceimprw to the linker flags (AIX only)'
HD2C46719D2EF: '將可重新定位地址值的常數物件放置在RO資料區段，並在連結器參數中添加-bforceimprw（僅限AIX）'
# 'Place constants in the .rodata section instead of the .sdata section even if they meet the -G <size> threshold (MIPS)'
H509FF0828C91: '即使符合-G <size> 門檻值，仍將常數放置在.rodata區段而非.sdata區段（MIPS專用）'
# 'Place debug types in their own section (ELF Only)'
H73B21ADBA4FE: '將除錯類型放置在它們自己的區段（僅限ELF）'
# 'Place each data in its own section'
H7C2A5E2E04CE: '將每個資料放置在各自的區段中'
# 'Place each function in its own section'
H9BBADC5A5281: '將每個函數放置在各自的區段中'
# "Place each function's basic blocks in unique sections (ELF Only)"
H517D3F2B0E57: '將每個函數的基本區塊放置在唯一的區段中（僅限ELF）'
# 'Place uninitialized global variables in a common block'
H97F2AD11B476: '將未初始化的全域變數放置在共同區塊中'
# 'Platform to use with LLJIT'
HAEF32BE4B3F4: '與LLJIT一起使用的平台'
# 'Pointer to member.'
HDE1D650C630F: '成員指標。'
# 'Pointer.'
H2EBACB6EF9AE: '指標。'
# 'Polly - Calculate dependences'
H6CAD158D9763: 'Polly - 計算依賴關係'
# 'Polly - Calculate dependences for all the SCoPs of a function'
H32F2275306BF: 'Polly - 計算函數所有SCoPs的依賴關係'
# 'Polly - Create LLVM-IR from SCoPs'
H64A957DE1EE7: 'Polly - 從SCoPs建立LLVM-IR'
# 'Polly - Create polyhedral description of Scops'
HFD5B7E2064CE: 'Polly - 建立Scops的多面體描述'
# 'Polly - Create polyhedral description of all Scops of a function'
H3225EA9E728D: 'Polly - 建立函數所有Scops的多面體描述'
# 'Polly - DeLICM/DePRE'
H209DA16A8BB4: 'Polly - DeLICM/DePRE'
# 'Polly - Detect static control parts (SCoPs)'
HFF16BBB95B79: 'Polly - 檢測靜態控制部分（SCoPs）'
# 'Polly - Dump Function'
HF98ECB8A4F3A: 'Polly - 輸出函數'
# 'Polly - Dump Module'
H406314AC52B6: 'Polly - 輸出模組'
# 'Polly - Dump polyhedral description of Scops optimized with the isl scheduling optimizer and the set of post-scheduling transformations is applied on the schedule tree'
H29D7996B3B49: 'Polly - 輸出經isl排程優化器優化後的Scops的多面體描述，並在排程樹上應用後排程轉換集'
# 'Polly - Export Scops as JSON (Writes a .jscop file for each Scop)'
H20651143EB75: 'Polly - 將Scops以JSON格式輸出（為每個Scop生成.jscop檔案）'
# 'Polly - Flatten schedule'
HB1962B7EDBD9: 'Polly - 平坦化排程'
# 'Polly - Forward operand tree'
HBFECA734FD00: 'Polly - 轉向運算元樹'
# 'Polly - Generate an AST from the SCoP (isl)'
HDBF9CF6A0C48: 'Polly - 從SCoP生成AST（使用isl）'
# 'Polly - Generate an AST of the SCoP (isl)'
H12CE909F63DA: 'Polly - 生成SCoP的AST（使用isl）'
# 'Polly - Import Scops from JSON (Reads a .jscop file for each Scop)'
H16E203839258: 'Polly - 從JSON輸入Scops（讀取每個Scop的.jscop檔案）'
# 'Polly - Interface to polyhedral analysis engine'
HEE4D2D43660E: 'Polly - 與多面體分析引擎的介面'
# 'Polly - Maximal static expansion of SCoP'
H0CA779A2D7D3: 'Polly - SCoP的最大靜態展開'
# 'Polly - Optimize schedule of SCoP'
H377579EA76A0: 'Polly - 優化SCoP的排程'
# 'Polly - Prepare code for polly'
HA31E0A502467: 'Polly - 為Polly準備程式碼'
# 'Polly - Print DeLICM/DePRE'
HE392A0315DF8: 'Polly - 印出DeLICM/DePRE'
# 'Polly - Print Scop import result'
H4A167D1D4274: 'Polly - 輸出Scop匯入結果'
# 'Polly - Print Scops of function'
H31ABAE6ABC4E: 'Polly - 輸出函數的Scops'
# 'Polly - Print Scops of function (with no function bodies)'
HF9B4E2CB9C70: 'Polly - 輸出函數的Scops（不含函數主體）'
# 'Polly - Print Simplify actions'
H5741448BF9F8: 'Polly - 輸出簡化動作'
# 'Polly - Print dependences'
HD5CEBA14DA9B: 'Polly - 輸出依賴關係'
# 'Polly - Print dependences for all the SCoPs of a function'
HD7464B6EDE01: 'Polly - 輸出函數所有SCoPs的依賴關係'
# 'Polly - Print flattened schedule'
H33EAB5733200: 'Polly - 輸出平坦化排程'
# 'Polly - Print forward operand tree result'
H7CD855EC5084: 'Polly - 輸出前向運算元樹結果'
# 'Polly - Print interface to polyhedral analysis engine analysis'
HF7F243A50BCB: 'Polly - 列印多面體分析引擎介面的分析結果'
# 'Polly - Print optimizer schedule of SCoP'
HB4511056F80D: 'Polly - 列印SCoP的優化排程'
# 'Polly - Print polyhedral description of Scops'
HE3A4EE9454B0: 'Polly - 列印Scops的多面體描述'
# 'Polly - Print polyhedral description of all Scops of a function'
H23C591077544: 'Polly - 列印函數中所有Scops的多面體描述'
# 'Polly - Print static control parts (SCoPs)'
H2CB7C4BBD709: 'Polly - 列印靜態控制部分（SCoPs）'
# 'Polly - Print the AST from a SCoP (isl)'
H984A4B6D2819: 'Polly - 從SCoP列印AST（使用isl）'
# 'Polly - Prune unprofitable SCoPs'
HB8C0844D69B4: 'Polly - 剪除無利可圖的SCoPs'
# 'Polly - Remove dead iterations'
H67A46F65DA9E: 'Polly - 移除死循環'
# 'Polly - Run canonicalization passes'
H0C8C62952E1F: 'Polly - 執行正規化Pass'
# 'Polly - Simplify'
HE98E9DE36187: 'Polly - 簡化'
# 'Polly - View Scops of function'
HD3BFFB69003F: 'Polly - 查看函數的Scops'
# 'Polly - View Scops of function (with no function bodies)'
H8C7475C4A4E8: 'Polly - 查看函數的Scops（不含函數主體）'
# 'Polly Options'
H4116368BA8CD: 'Polly選項'
# 'Pop up a window to show MISched dags after they are processed'
HAAFE046654B3: '顯示處理後的MISched dags的視窗'
# 'Pop up a window to show SUnit dags after they are processed'
HDD5439EA4C3E: '顯示處理後的SUnit dags的視窗'
# 'Pop up a window to show a dag displaying MBP layout and associated block frequencies of the CFG.'
HBC76A8873486: '顯示一個顯示MBP佈局和CFG中相關區塊頻率的dag的視窗'
# 'Pop up a window to show a dag displaying how block frequencies propagation through the CFG.'
H5017224EFFF8: '顯示一個顯示區塊頻率如何在CFG中傳播的dag的視窗'
# 'Pop up a window to show a dag displaying how machine block frequencies propagate through the CFG.'
H06EB3103BBDD: '顯示一個顯示機器區塊頻率如何在CFG中傳播的dag的視窗'
# 'Pop up a window to show dags before legalize'
HCEEBF08E9304: '顯示legalize之前的dags的視窗'
# 'Pop up a window to show dags before legalize types'
H7DF81922AFEE: '顯示legalize類型之前的dags的視窗'
# 'Pop up a window to show dags before the first dag combine pass'
HD6B32ED73930: '在第一個 dag combine pass 之前顯示 DAG 時彈出視窗'
# 'Pop up a window to show dags before the post legalize types dag combine pass'
H411955B7261A: '在 post legalize types dag combine pass 之前顯示 DAG 時彈出視窗'
# 'Pop up a window to show dags before the second dag combine pass'
HC7BCA3632D13: '在第二個 dag combine pass 之前顯示 DAG 時彈出視窗'
# 'Pop up a window to show edge bundle graphs'
H5831F520A8FB: '顯示邊束圖時彈出視窗'
# 'Pop up a window to show isel dags as they are selected'
HA52C2A41472F: '在選擇 isel DAG 時彈出視窗'
# 'Pop up a window to show sched dags as they are processed'
H1FD861E7E0A4: '在處理 sched DAG 時彈出視窗'
# 'Populate profile symbol list (only meaningful for -extbinary)'
HB40FFCA64E8B: '填充剖析符號清單（僅對 -extbinary 有意義）'
# 'Position independent'
H3F7792F17E68: '位置獨立'
# 'Post RA hazard recognizer'
H03992384B25F: 'RA 後的危機辨識器'
# 'Post RA top-down list latency scheduler'
H59EA1D628EE5: 'RA 後自頂向下清單延遲排程器'
# 'Post reg-alloc list scheduling direction'
H4071BC55C6A4: '寄存器分配後的清單排程方向'
# 'Post-Dominator Tree Construction'
HEC3645FCF915: '後支配樹建構'
# 'Post-RA pseudo instruction expansion pass'
H3AEF4966A271: 'PostRA 偽指令展開 pass'
# 'PostRA Machine Instruction Scheduler'
H0087D700C0B6: 'PostRA 設備指令排程器'
# 'PostRA Machine Sink'
H2B8A5A72B764: 'PostRA 設備 Sink'
# 'Postfix to append to the import .jsop files.'
H00F609EA3C78: '附加到導入的 .jsop 檔案的後綴'
# 'Potential PHI threshold per loop for PPC loop prep of DQ form'
HD78EEEDE2049: '針對 PPC 迴圈預處理的 DQ 形式的每個迴圈潛在 PHI 閾值'
# 'Potential PHI threshold per loop for PPC loop prep of DS form'
H88F3C7B998C1: '針對 PPC 迴圈預處理的 DS 形式的每個迴圈潛在 PHI 閾值'
# 'Potential PHI threshold per loop for PPC loop prep of update form'
HFA306C3E0204: '針對 PPC 迴圈預處理的更新形式的每個迴圈潛在 PHI 閾值'
# 'Potential common base number threshold per function for PPC loop prep'
H1CB6AA07DE6F: '針對 PPC 迴圈預處理的每個函數潛在共同基數閾值'
# 'PowerPC Branch Selector'
H9BA07427B81D: 'PowerPC 分支選擇器'
# 'PowerPC CTR Loops Verify'
H6280529F23F2: 'PowerPC CTR 循環驗證'
# 'PowerPC CTR loops generation'
HFCFC8E19EA44: 'PowerPC CTR 循環生成'
# 'PowerPC DAG->DAG Pattern Instruction Selection'
H52FD8AB73B79: 'PowerPC DAG→DAG 模式指令選擇'
# 'PowerPC Early-Return Creation'
HFB276D43768D: 'PowerPC 提早返回創建'
# 'PowerPC Expand Atomic'
HE518E2C5903E: 'PowerPC 展開原子操作'
# 'PowerPC MI Peephole Optimization'
HD03B52E2308F: 'PowerPC MI 窥孔優化'
# 'PowerPC Pre-Emit Peephole'
H690293F011C6: 'PowerPC 預發射窥孔'
# 'PowerPC Reduce CR logical Operation'
H604BA96457F7: 'PowerPC 減少 CR 邏輯運算'
# 'PowerPC TLS Dynamic Call Fixup'
H754F83D11B51: 'PowerPC TLS 動態調用修復'
# 'PowerPC TOC Register Dependencies'
HBE3F61F91CCA: 'PowerPC TOC 寄存器依賴'
# 'PowerPC VSX Copy Legalization'
HCE743C058611: 'PowerPC VSX 複製合法化'
# 'PowerPC VSX FMA Mutation'
H934573D30FC1: 'PowerPC VSX FMA 轉換'
# 'PowerPC VSX Swap Removal'
H61E16EA71951: 'PowerPC VSX 交換移除'
# 'Pre reg-alloc list scheduling direction'
HBAA66F24441A: '寄存器分配前列表調度方向'
# 'Pre-ISel Intrinsic Lowering'
H2F5309EAAE70: '指令選擇前內在函數降低'
# 'Pre-RA optimizations'
H81B4ED48A8E1: '寄存器分配前優化'
# 'Pre-load dynamic libraries (e.g. language runtimes required by the ORC runtime)'
HDF44F8CD7956: '預先載入動態庫（例如 ORC 執行階段所需的語言執行階段）'
# 'Predicate conditions in read only loops'
H0D01A5F11CC3: '只讀循環中的謂詞條件'
# 'Prefer add+cnt over addvl/inc/dec'
H791228095B74: '優先使用 add+cnt 而非 addvl/inc/dec'
# 'Prefer aligned allocation for C++ Coroutines'
HF3DEE91EAA7A: '偏好為C++協程使用對齊的配置'
# 'Prefer hex format for immediate values'
H5AF7A8CAAB05: '偏好以十六進制格式表示立即數'
# 'Prefer hex format when printing immediate values'
H641A692609DF: '輸出立即數時偏好以十六進制格式表示'
# 'Prefer in-loop vector reductions, overriding the targets preference.'
HC3384EBFEDE5: '偏好在循環內執行向量約簡，覆蓋目標的預設選擇。'
# 'Prefer post-indexed addressing mode'
HFA137A1FDE64: '偏好使用後索引位址模式'
# 'Prefer pre-indexed addressing mode'
HCF74AFA989EA: '偏好使用前索引位址模式'
# 'Prefer predicated Move to CSEL'
H29D20CBEE6CD: '偏好使用條件移動指令而非CSEL指令'
# 'Prefer predicating a reduction operation over an after loop select.'
HE552FE7410D6: '偏好對約簡操作進行條件判斷，而非在循環後使用選擇操作。'
# 'Prefer translating all intrinsics into llvm.call_intrinsic instead of using dialect supported intrinsics'
H35AE35D12C89: '偏好將所有內置函數轉譯為llvm.call_intrinsic，而非使用特定語法支援的內置函數'
# 'Prefer whole register move for vector registers.'
HD64DE7AD7D41: '偏好對向量寄存器使用完整寄存器移動。'
# 'Prefetch write addresses'
HD84230748C7F: '預先取得寫入位址'
# 'Prefix filenames with the main file'
HFC5DC735C294: '在檔名前加上主檔的前綴'
# 'Prefix for feature names.'
H2B0C0B21A30C: '功能名稱的前綴。'
# 'Prefix for memory access callbacks'
H4F526B73B916: '記憶體存取回調函數的前綴。'
# 'Prefix of line code for repository.'
H1C11371CF193: '儲存庫的行代碼前綴。'
# "Prefix to use for outputs (default: 'bugpoint')"
H51241093AFDE: "輸出使用的前綴（預設：'bugpoint'）"
# "Prefix to use from check file (defaults to 'CHECK')"
HC4A6D5922731: "從檢查檔中使用的前綴（預設為 'CHECK'）"
# "Prefixes for aliases that don't need to be renamed, separated by a comma"
H93C76DC96906: '不需要重新命名的別名前綴，以逗號分隔。'
# "Prefixes for functions that don't need to be renamed, separated by a comma"
H8D84AAE61D99: '不需要重新命名的函數前綴，以逗號分隔。'
# "Prefixes for global values that don't need to be renamed, separated by a comma"
H25F3716C6D6C: '不需要重新命名的全域值前綴，以逗號分隔。'
# "Prefixes for structs that don't need to be renamed, separated by a comma"
HFF2FE350C63E: '不需要重新命名的結構體前綴，以逗號分隔'
# 'Preload commands from file and start interactive mode'
HF342699558DE: '從檔案載入命令並啟動互動模式'
# "Prepare '-aux-triple' only without populating '-aux-target-cpu' and '-aux-target-feature'."
H5F5A3F872C66: "僅準備 '-aux-triple'，而不填入 '-aux-target-cpu' 和 '-aux-target-feature'."
# 'Prepare DWARF exceptions'
H95C39A5915AA: '準備 DWARF 例外處理'
# 'Prepare SjLj exceptions'
HCA47286F067B: '準備 SjLj 例外處理'
# 'Prepare WebAssembly exceptions'
H90B1A43A5B08: '準備 WebAssembly 例外處理'
# 'Prepare Windows exceptions'
H09ADD0F6BE1B: '準備 Windows 例外處理'
# 'Prepare callbr'
H28D8A749A5F8: '準備 callbr'
# 'Prepares for basic block sections, by splitting functions into clusters of basic blocks.'
H6AFC803DF7AB: '為基本區塊區段做準備，將函數分割為基本區塊群組。'
# 'Prepend header file paths with this prefix. If not specified, the files are considered to be relative to the header list file.'
HB8A4FB692FE7: '在標頭檔路徑前加上此前綴。若未指定，則將檔案視為相對於標頭檔清單檔案。'
# 'Preprocess to file'
HADD296905BBE: '預處理到指定檔案'
# 'Preprocess to stdout'
HB9E8D78ECAA1: '預處理到標準輸出'
# 'Preserve Comments in outputted assembly'
H6543E9060512: '保留輸出組裝碼中的註解'
# 'Preserve canonical loop structure (default = true)'
H9226DB4F030F: '保留規範迴圈結構（預設值 = true）'
# 'Preserve debug info in thunk when mergefunc transformations are made.'
HC15D6215FF01: '在 mergefunc 轉換時保留 thunk 中的除錯資訊'
# 'Preserve expressions in AST rather than dropping them when encountering semantic errors'
H606CF076FD66: '在AST中保留運算式而非在遇到語法錯誤時捨棄它們'
# 'Preserve line numbers'
HF7C338130FB4: '保留列號'
# 'Preserve order of LLVM use-lists when serializing'
HE297D90494BB: '序列化時保留 LLVM 使用清單的順序'
# 'Preserve path components'
HA8274603DA36: '保留路徑元件'
# 'Preserve subregisters in tied operands'
HB16CD82DFFE2: '保留綁定操作數中的子寄存器'
# 'Preserve the type for recovery expressions when possible'
HB104FC8C2A4B: '在可能時保留恢復運算式的類型'
# 'Preserve use-list order when writing LLVM assembly.'
HA8838E5FAEE3: '寫入LLVM組裝語言時保留使用清單的順序'
# 'Preserve use-list order when writing LLVM bitcode.'
HED82044E4F6B: '寫入LLVM位碼時保留使用清單的順序'
# 'Preserves original instruction order'
H08B5F35B74C3: '保留原始指令順序'
# 'Pretend that scalable vectors are supported, even if the target does not support them. This flag should only be used for testing.'
HE0B0560A96EA: '假設目標支援可擴展向量，即使實際上不支援。此旗標僅供測試使用。'
# 'Pretty print debug locations of instructions when dumping'
HFD520C9CFE2C: '在傾印時漂亮列印指令的除錯位置'
# 'Pretty print perf data (branch weights, etc) when dumping'
H25D67F8F93BF: '在傾印時漂亮列印效能數據（分支權重等）'
# 'Pretty-print JSON'
HED0E5D700CC6: '漂亮列印JSON'
# 'Pretty-print JSON output'
HF19F323787A0: '漂亮列印JSON輸出'
# 'Pretty-print JSON output in the trace'
HE76D2162F789: '在追蹤中漂亮列印JSON輸出'
# 'Prevent expanding floating point division in AMDGPUCodeGenPrepare'
H5221E44BB247: '防止在AMDGPUCodeGenPrepare中展開浮點數除法'
# 'Prevent expanding integer division in AMDGPUCodeGenPrepare'
HA00F77EDC803: '防止在AMDGPUCodeGenPrepare中展開整數除法'
# 'Prevent function(s) from being devirtualized'
HF36ABB428107: '防止函數被虛擬化解析'
# 'Prevent misexpect diagnostics from being output if the profile counts are within N% of the expected. '
HAB811F421D71: '如果剖析計數在期望值的N%範圍內，則阻止輸出不匹配的診斷訊息。'
# "Prevent optimization remarks from being output if they do not have at least this profile count. Use 'auto' to apply the threshold from profile summary"
H80EFE9F96F6F: "若其剖析計數小於此數值，則阻止輸出優化提示。使用 'auto' 從剖析摘要套用閾值"
# 'Prevents emitting diagnostics when profile counts are within N% of the threshold..'
H77AE0CC1048E: '若剖析計數在閾值的N%範圍內，則阻止發出診斷資訊。'
# 'Primary key when ordering logical view (default: line).'
H7BB0C9861C88: '邏輯檢視排序時的主要鍵（預設：行）。'
# 'Print (but do not run) the commands to run for this compilation'
HCEF688AF1304: '列印（但不執行）此次編譯要執行的命令'
# "Print Attributor's internal call graph"
H256F97E689ED: '列印Attributor的內部呼叫圖'
# 'Print DenseElementsAttrs with a hex string that have more elements than the given upper limit (use -1 to disable)'
H4B4EB65A8AF9: '若元素數量超過指定上限時，以十六進位字串列印DenseElementsAttrs（使用-1禁用）'
# 'Print Enum list for this class'
HB3042274A9F1: '列印此類別的枚舉清單'
# 'Print ExecutionSession state after resolving entry point'
HA2AA771729BC: '在解析入口點後列印 ExecutionSession 狀態'
# 'Print ExecutionSession state before resolving entry point'
H66A839FE6545: '在解析入口點前列印 ExecutionSession 狀態'
# 'Print IR after each pass'
HA5EFB8CE8B9F: '在每個 pass 後列印 IR'
# 'Print IR after specified passes'
H3D9D708F1675: '在指定的 pass 後列印 IR'
# 'Print IR after the pass with this number as reported by print-pass-numbers'
HB20A8CE7B1FD: '在由 print-pass-numbers 報告的此編號 pass 後列印 IR'
# 'Print IR before each pass'
HDA98FFA60DB4: '在每個 pass 前列印 IR'
# 'Print IR before specified passes'
H328B86DC8BAB: '在指定的 pass 前列印 IR'
# 'Print IR before the pass with this number as reported by print-pass-numbers'
H67F2CC34678A: '在由 print-pass-numbers 報告的此編號 pass 前列印 IR'
# 'Print IR to path when opt-bisect-limit is reached'
H1CC46248A49A: '當 opt-bisect-limit 達到時將 IR 印至路徑'
# 'Print LLVM IR input to isel pass'
HB1E12014CD83: '列印傳遞至 isel pass 的 LLVM IR 輸入'
# 'Print MIR debug-locations'
H23CF1A75AA16: '列印 MIR 的除錯位置'
# 'Print Machine Cycle Info Analysis'
H9577B97D25AE: '列印 Machine Cycle Info 分析'
# 'Print Machine Uniformity Info Analysis'
HFCF3D928DF44: '列印 Machine Uniformity Info 分析'
# 'Print Options'
H183A70DB44AF: '列印選項'
# 'Print SSA IDs using NameLocs as prefixes'
H17EB8F4CEEED: '使用 NameLocs 作為前綴來列印 SSA IDs'
# "Print a '-passes' compatible string describing the pipeline (best-effort only)."
H4C4CBF86A7C9: "列印與 '-passes' 兼容的字串，描述管線（僅最佳努力）。"
# 'Print a template comparison tree for differing templates'
H94B203D5EC04: '列印不同範本的範本比較樹狀結構'
# 'Print absolute paths in diagnostics'
H3475474B9AF0: '在診斷資訊中列印絕對路徑'
# 'Print addresses of MachineInstrs when dumping'
H3F08CE170EBB: '在傾印時列印MachineInstr的地址'
# 'Print addresses of instructions when dumping'
HF2156C7D4A91: '在傾印時列印指令的地址'
# 'Print all cost kinds'
HCAA4E47DE719: '列印所有成本類型'
# 'Print all hardware statistics'
H14BBD9376F77: '列印所有硬體統計資料'
# "Print all of Clang's warning options"
HF45E26CFBC96: '列印Clang的所有警告選項'
# 'Print all option values after command line parsing'
HB0F721DC4298: '命令列解析後列印所有選項值'
# 'Print all records to stdout (default)'
H8BF745CB973A: '將所有記錄列印到標準輸出（預設）'
# 'Print all results from files matching this regular expression.'
H37B62E065C22: '列印符合此正規表示式的檔案的所有結果'
# 'Print all views including hardware statistics'
H8A87BEED0121: '列印所有視圖（包含硬體統計資料）'
# 'Print allocation requests made to the memory manager by RuntimeDyld'
H36E2ACD7E011: '列印RuntimeDyld向記憶體管理器提出的記憶體分配請求'
# 'Print any external commands that are to be executed instead of actually executing them - for testing purposes.\n'
HF77F09852A60: '列印所有要執行的外部命令而非實際執行它們（僅供測試使用）\n'
# 'Print architectural register names rather than the ABI names (such as r14 instead of sp)'
H9E57937A3E1F: '列印架構寄存器名稱而非ABI名稱（例如r14而非sp）'
# 'Print assembly as linked'
HF50C5F3BF962: '列印已連結的組合語言'
# 'Print assembly as parsed'
H75C25DD05B7B: '列印已解析的組合語言'
# 'Print attribute dependencies'
HDE5247667B07: '列印屬性依賴關係'
# 'Print available passes that can be specified in -passes=foo and exit'
HE05D65950FB2: '列印可在-passes=foo中指定的所有可用pass，並退出'
# 'Print before passes that change them'
HAEB698616AF4: '在改變它們的pass之前列印'
# 'Print binary blobs using hex escapes'
H0160E60E08F5: '使用十六進位轉義列印二進位資料塊'
# 'Print binary load events.'
H2F65BD41A1E8: '列印二進位載入事件。'
# "Print call graph to 'dot' file"
H699252A05887: '將調用圖印出至「dot」檔案'
# 'Print canonical function name.'
H39DE0BCE8940: '印出標準函數名稱。'
# 'Print changed IRs'
HB7CE030FBB95: '印出修改過的IR'
# 'Print cl.exe style /showIncludes to stdout'
H84DEF3CD15ED: '以cl.exe風格印出/showIncludes至標準輸出'
# 'Print command line.'
H1C5C42AF6D29: '顯示命令列。'
# 'Print critical path length to stdout'
H8F78BF714145: '顯示關鍵路徑長度至標準輸出'
# 'Print debug info in MLIR output'
H6859C4B3FF46: '在MLIR輸出中顯示除錯資訊'
# 'Print debug information.\n'
HB8A507E6D179: '顯示除錯資訊。\n'
# 'Print demangled function name'
HC4B0C0E810C3: '印出解除符號修飾的函數名稱'
# 'Print detailed output about what is being run to stderr.'
HE984DCC7A8C4: '將正在執行的詳細輸出顯示至標準錯誤。'
# 'Print diagnostic category'
HCF5E624088CE: '顯示診斷類別'
# 'Print directive pattern matches, or add them to the input dump\nif enabled.\n'
H928F89E57268: '顯示指令模式匹配結果，或在啟用時將其加入輸入轉存\n'
# 'Print disassembled code.'
HDACEC7EBFD41: '顯示反組譯代碼。'
# 'Print dispatch statistics'
H2DF0F56E2112: '顯示分派統計數據'
# "Print dominance tree of function to 'dot' file"
HFDEAF60A0F86: '將函數的優勢樹印出至「dot」檔案'
# "Print dominance tree of function to 'dot' file (with no function bodies)"
H255806455D28: '將函數的優勢樹印出至「dot」檔案（不含函數主體）'
# 'Print embed directives in -E mode in addition to normal output'
HA988C571D048: '除了正常輸出外，在-E模式下印出嵌入指令'
# 'Print encoding information in the instruction info view'
HDDF771C744F8: '在指令資訊檢視中顯示編碼資訊'
# 'Print extra debugging information'
HFF9ED81B933D: '顯示額外除錯資訊'
# 'Print extra information about adaptors and pass managers'
H8E608CF10762: '列印關於適配器和pass管理器的額外資訊'
# 'Print final code'
H91C18F74D9CF: '列印最終代碼'
# 'Print fix-its in machine parseable form'
H8FDA449E8857: '以機器可解析格式列印修復建議'
# 'Print function to stderr'
H4E08D51481D2: '將函數輸出到stderr'
# 'Print graphs around indirect CF instructions in DOT format.'
HF75F04A7E3C5: '以DOT格式列印間接控制流指令周圍的圖形'
# 'Print imported functions'
H3746D79A84CE: '列印導入的函數'
# 'Print include directives in -E mode in addition to normal output'
HD07C75D32665: '在-E模式下除正常輸出外，同時列印include指令'
# 'Print index-based devirtualization messages'
HBF58405294ED: '列印基於索引的虛函數消解消息'
# 'Print info about included files to stderr'
H622C6A0F6DB5: '將包含的文件資訊輸出到stderr'
# 'Print information about actions taken'
H1ED18B4AD272: '列印所執行動作的相關資訊'
# 'Print information about the activities of Polly'
HCF30D81D0973: '列印Polly活動的相關資訊'
# 'Print information for functions rejected for importing'
HBD21C28A83D7: '列印被拒絕導入的函數資訊'
# 'Print information helpful in diagnosing internal FileCheck\nissues, or add it to the input dump if enabled.  Implies\n-v.\n'
H651EBEE00CDE: '列印有助於診斷FileCheck內部問題的資訊，或在啟用時將其添加到輸入轉存中。隱含-v選項。\n'
# 'Print instruction latencies as verbose asm comments'
HD27FB6BC6036: '以詳細的組合語言註解形式列印指令延遲'
# 'Print instruction tables'
H2620BE69E6DD: '列印指令表'
# 'Print instruction tables with additional information: bypass latency, LLVM opcode, used resources'
HFB383E77CA64: '列印包含額外資訊的指令表：旁路延遲、LLVM操作碼、已使用資源'
# "Print instructions that the allocator wants to fuse, but the X86 backend currently can't"
HE530C7C7214A: '列印分配器欲融合但X86後端目前無法處理的指令'
# 'Print internal analyzer statistics.'
HAE4856542BC1: '列印內部分析器的統計數據'
# 'Print legacy PassManager debugging information'
HDFED9BD864B2: '列印舊版PassManager除錯資訊'
# 'Print list of delta passes, passable to --delta-passes as a comma separated list'
H93E693FB4735: '列印delta pass清單，可作為逗號分隔清單傳遞給--delta-passes'
# 'Print machine instrs after ISel'
H555E49FB33C1: '列印ISel後的機器指令'
# 'Print machine verifier errors on invalid reduction attempts triple'
HE100DF904ED4: '列印在無效簡化嘗試三元組上的機器驗證錯誤'
# 'Print macro definitions in -E mode in addition to normal output'
H0486B7210917: '在-E模式下列印宏定義，以及正常輸出'
# 'Print macro definitions in -E mode instead of normal output'
HB1EFD9100CC5: '在-E模式下列印宏定義，而不是正常輸出'
# "Print matching stats for each allocation context in this module's profiles"
H8ED3695B4B5D: '列印此模組剖析中每個分配環境的匹配統計'
# 'Print memory access functions'
H2D490B90F012: '列印記憶體存取函數'
# 'Print memory barrier information in the instruction info view'
H565E0827BDFD: '在指令資訊檢視中列印記憶體屏障資訊'
# 'Print module to stderr'
HFFEB1D6642AE: '將模組列印到stderr'
# 'Print name of local stack variable'
H5190847365AF: '列印局部堆疊變數名稱'
# 'Print non-default options after command line parsing'
HEA27B7232530: '在命令列解析後列印非預設選項'
# 'Print numeric register names rather than the ABI names (such as $r0 instead of $zero)'
H165530C50853: '列印數值型寄存器名稱而非ABI名稱（例如$r0而非$zero）'
# 'Print only the CFG without blocks body'
H75782D2B7733: '僅列印不含區塊主體的控制流圖（CFG）'
# 'Print option name with mappable diagnostics'
H158CBF9FD24C: '與可映射診斷一起列印選項名稱'
# 'Print out debug counter info after all counters accumulated'
H2CE0455E9D85: '在累積所有計數器後列印除錯計數器資訊'
# 'Print out debug counter information after all counters have been accumulated'
H94A5B1103F3F: '在所有計數器累積後列印除錯計數器資訊'
# 'Print out mismatched BFI counts after setting profile metadata The print is enabled under -Rpass-analysis=pgo, or internal option -pass-remarks-analysis=pgo.'
H3025AA257D2E: '在設定剖析元資料後列印不匹配的BFI計數。此列印在-Rpass-analysis=pgo或內部選項-pass-remarks-analysis=pgo下啟用。'
# 'Print out the non-match BFI count if a hot raw profile count becomes non-hot, or a cold raw profile count becomes hot. The print is enabled under -Rpass-analysis=pgo, or internal option -pass-remarks-analysis=pgo.'
HDD8F14466662: '如果熱原始剖析計數變為非熱，或冷原始剖析計數變為熱時，列印不匹配的BFI計數。此列印在-Rpass-analysis=pgo或內部選項-pass-remarks-analysis=pgo下啟用。'
# 'Print out the parsed ODS information from the input file'
H863FE61CF758: '列印輸入檔案中已解析的ODS資訊'
# 'Print pass management debugging information'
H639A1D9CCF1A: '顯示pass管理除錯資訊'
# 'Print pass names and their ordinals'
H333E30843F56: '顯示pass名稱及其序號'
# 'Print performance metrics and statistics'
HE4EAA5755D11: '顯示效能指標與統計數據'
# "Print postdominance tree of function to 'dot' file"
HB29C66E944CC: "將函數的後支配樹輸出至 'dot' 檔案"
# "Print postdominance tree of function to 'dot' file (with no function bodies)"
HD6176265DDFA: "將函數的後支配樹（不含函數主體）輸出至 'dot' 檔案"
# 'Print pretty debug info in MLIR output'
H1D9ED83CA568: '在MLIR輸出中顯示格式化的除錯資訊'
# 'Print pseudo probe section and disassembled info.'
H32640273947C: '顯示虛擬探針區段與反組譯資訊。'
# "Print regions of function to 'dot' file"
HA2F7AC936E9B: "將函數的區塊結構輸出至 'dot' 檔案"
# "Print regions of function to 'dot' file (with no function bodies)"
HB4D8B8B65FF0: "將函數的區塊結構（不含函數主體）輸出至 'dot' 檔案"
# 'Print register file statistics'
HD3E0FCA5570D: '顯示記憶體寄存器統計數據'
# 'Print registered symbol, section, got and stub addresses'
H4788FF394730: '顯示已註冊符號、區段、got及stub位址'
# 'Print retire control unit statistics'
HD5CFA03245CF: '顯示記憶體回收控制單元統計數據'
# 'Print schedule DAGs'
HCD1F3A6E0736: '顯示排程DAG結構'
# 'Print scheduler statistics'
HEAC85495C43E: '顯示調度器統計數據'
# 'Print setting flow sensitive branch probabilities'
H93BFBD2C1FA2: '顯示設定流程敏感的分支機率'
# 'Print source locations.'
H1D581A019738: '顯示來源位置。'
# 'Print source range spans in numeric form'
H6EBB5160F7AF: '以數值形式顯示源範圍跨度'
# 'Print statistic for the index in every input files'
H269BBBFD3979: '顯示輸入檔案索引的統計數據'
# 'Print subprocess statistics'
HFA43D801ECBB: '顯示子程序統計數據'
# 'Print summary view (enabled by default)'
HC78BAF3172BC: '顯示摘要檢視（預設啟用）'
# 'Print supported -march extensions (RISC-V, AArch64 and ARM only)'
HFE614E88285A: '顯示支援的 -march 擴充功能（僅 RISC-V、AArch64 和 ARM）'
# 'Print supported cpu models for the given target (if target is not specified,it will print the supported cpus for the default target)'
H83F7E7816369: '顯示指定目標的可用 CPU 型號（若未指定目標，則顯示預設目標的支援 CPU）'
# 'Print symbolic changes'
HEBF2FA11F574: '顯示符號化修改'
# 'Print the "preamble" of a file, which is a candidate for implicit precompiled headers.'
H70A29FD77B18: '顯示檔案的「開場」部分，此部分是用於隱式預編譯標頭的候選。'
# 'Print the blame context (if possible) for BAD instructions. This specifies the number of lines of context to include, where zero disables this feature.'
HBD7D1281AF22: '為 BAD 指令顯示歸因上下文（如有可能）。此選項指定要包含的上下文行數，設為零會停用此功能。'
# 'Print the block frequency info.'
HC5D2B22203B4: '顯示區塊執行頻率資訊。'
# 'Print the branch probability info.'
H9D987607E791: '顯示分支機率資訊。'
# 'Print the canonical YAML for this file.'
HE1A3AA010C12: '以標準 YAML 格式顯示此檔案內容。'
# 'Print the compiler version'
HB74950BD8E88: '顯示編譯器版本'
# 'Print the current module after OpenMP optimizations.'
HF02AEAC96CD7: '顯示 OpenMP 優化後的目前模組。'
# 'Print the current module before OpenMP optimizations.'
H8661FCFF114F: '顯示 OpenMP 優化前的目前模組。'
# "Print the directory pathname containing Clang's runtime libraries"
HCF6BD300D146: '顯示 Clang 執行階段程式庫所在的目錄路徑'
# 'Print the effective target triple'
H651D58C4EE40: '顯示有效的目標三元組'
# 'Print the extensions enabled by the given target and -march/-mcpu options. (AArch64 and RISC-V only)'
HBF8F8BB9DED1: '顯示指定目標與 -march/-mcpu 選項啟用的擴充功能（僅限 AArch64 和 RISC-V）'
# 'Print the flags used for selecting multilibs (experimental)'
H99D8793DE319: '顯示選擇多型庫時使用的旗標（實驗性功能）'
# 'Print the full library path of <file>'
H996FD2BF6EA4: '顯示 <file> 的完整程式庫路徑'
# 'Print the full program path of <name>'
H6425BA00826B: '顯示程式名稱 <name> 的完整執行路徑'
# 'Print the generic op form'
H393E4B90F6FC: '顯示通用運算元表達式形式'
# 'Print the global id for each value when reading the module summary'
H017C8976AB50: '讀取模塊摘要時，列印每個值的全局ID'
# 'Print the instruction info view (enabled by default)'
HFDE24D0249FD: '列印指令資訊檢視（預設啟用）'
# 'Print the internal representation of the AST as JSON.'
H4463E0E4D8B4: '以JSON格式列印AST的內部表示。'
# 'Print the internal representation of the AST.'
H034FD53E1499: '列印AST的內部表示。'
# 'Print the last form of the IR before crash (use -print-on-crash-path to dump to a file)'
H05148AD74D0F: '列印崩潰前的IR最後形式（使用-print-on-crash-path選項將其輸出到文件）'
# 'Print the last form of the IR before crash to a file'
H41B3ECBC245F: '列印崩潰前的IR最後形式到文件'
# 'Print the library path for the currently used compiler runtime library ("libgcc.a" or "libclang_rt.builtins.*.a")'
H1C5056AC3308: '列印目前使用的編譯器運行時庫的路徑（例如libgcc.a或libclang_rt.builtins.*.a）'
# 'Print the list of headers to insert and remove'
H9F64205F2D86: '列印要插入和移除的標頭清單'
# 'Print the list of registered dialects and exit'
H8D48045AF8B2: '列印已註冊的方言清單並退出'
# 'Print the list of registered passes and exit'
HC59B7DDDC5DA: '列印已註冊的pass清單並退出'
# 'Print the machine block frequency info.'
HD84FA75ACBC1: '列印機器區塊頻率資訊。'
# 'Print the matched nodes.'
H4BB21D1928B8: '列印匹配的節點。'
# 'Print the name of each compiled file'
HDCE85FDCBE9D: '列印每個已編譯的文件名稱'
# 'Print the normalized target triple'
H96ECE7DAB2DE: '列印標準化的目標三元組'
# 'Print the output in json format'
H7346664F1361: '以JSON格式輸出'
# 'Print the output of crashing program'
H8E49BCDD2D2A: '列印崩潰程式之輸出'
# 'Print the output of the dependency directives source minimizer'
HF8EAF7DCE928: '列印依賴指示源最小化器的輸出'
# 'Print the overhead of checks matching this glob'
HC2F8104B88AF: '列印與此模式匹配的檢查開銷'
# 'Print the path for the C++ Standard library module manifest'
H8EDB3804EDF6: '列印C++標準函式庫模塊說明文件的路徑'
# 'Print the paths used for finding ROCm installation'
H5DE6FB91D815: '印出用於尋找ROCm安裝路徑的路徑'
# 'Print the paths used for finding libraries and programs'
H88A6C4296147: '印出用於尋找程式庫和程式的路徑'
# 'Print the pipeline that will be run'
HB9A00F6CD048: '印出要執行的管線'
# 'Print the registered targets'
H0D2C6AE9215B: '印出已註冊的目標'
# 'Print the resource directory pathname'
HA37C029422E4: '印出資源目錄的路徑名稱'
# 'Print the resource directory pathname that contains lib and include directories with the runtime libraries and MODULE files.'
HA7ED2E95EC04: '印出包含lib和include目錄的資源目錄路徑名稱，其中包含執行階段程式庫和MODULE檔案。'
# 'Print the resource pressure view (enabled by default)'
HEECE83A65DB5: '印出資源壓力視圖（預設已啟用）'
# 'Print the summary only.'
H174D6B098765: '僅印出摘要。'
# 'Print the symbol being queried and all its relevant headers in\nJSON format to stdout:\n  {\n    "FilePath": "/path/to/foo.cc",\n    "QuerySymbolInfos": [\n       {"RawIdentifier": "foo",\n        "Range": {"Offset": 0, "Length": 3}}\n    ],\n    "HeaderInfos": [ {"Header": "\\"foo_a.h\\"",\n                      "QualifiedName": "a::foo"} ]\n  }'
H5CB3BBFB3D04: '以JSON格式印出所查詢的符號及其相關標頭的內容至標準輸出：\n  {\n    "FilePath": "/路徑/to/foo.cc",\n    "QuerySymbolInfos": [\n       {"RawIdentifier": "foo",\n        "Range": {"Offset": 0, "Length": 3}}\n    ],\n    "HeaderInfos": [ {"Header": "\\"foo_a.h\\"",\n                      "QualifiedName": "a::foo"} ]\n  }'
# 'Print the timeline view'
H7E4B03837F1C: '印出時間軸視圖'
# 'Print the tokenization of the file.'
H0F40582164F4: '印出檔案的詞元化結果。'
# 'Print to stdout'
H002EC692CF47: '印出到標準輸出'
# 'Print type inference debug logs'
H97D56E58C1ED: '印出類型推論除錯日誌'
# 'Print unique SSA ID numbers for values, block arguments and naming conflicts across all regions'
H3CF739160E73: '印出所有區域中值、區塊參數和命名衝突的唯一SSA編號'
# 'Print unique element ID'
H4EAB338925EE: '印出唯一元素ID'
# 'Print users of operation results and block arguments as a comment'
HFE8B9CDAE8D0: '將運算結果和區塊參數的使用者列印為註解'
# 'Print version information'
H2471C1D1E728: '印出版本資訊'
# 'Print warnings as well as errors'
H5031BC87FCBE: '印出警告以及錯誤訊息'
# 'Print with local scope and inline information (eliding aliases for attributes, types, and locations)'
H7DD376461997: '以本地範圍和內嵌資訊印出（省略屬性、類型和位置的別名）'
# 'Printing a logical representation of low-level debug information.\n'
HC0290F8303A5: '列印低階除錯資訊的邏輯表示形式。\n'
# "Prints 'unknown' intrinsics that were handled heuristically. Use -msan-dump-strict-instructions to print intrinsics that could not be handled exactly nor heuristically."
HE08944C3B0E2: "列印那些通過启发式處理的'未知'內建函數。使用 -msan-dump-strict-instructions 參數來列印那些無法被精確或启发式處理的內建函數。"
# 'Prints comments for instruction based on inline cost analysis'
H8F93FDBF8523: '根據內聯成本分析的指令列印註解'
# 'Prints debug information for the new pass manager'
H2612FCB765F4: '列印新 pass 管理器的除錯資訊'
# 'Prints full register names with percent'
HE6A6B46C9FA7: '使用百分比符號列印完整的寄存器名稱'
# 'Prints full register names with vs{31-63} as v{0-31}'
HBBE64D4048A6: '將 vs{31-63} 轉換為 v{0-31} 來列印完整的寄存器名稱'
# 'Prints the blame context (if possible) for ALL instructions. This specifies the number of lines of context for non-BAD instructions (see --blame-context). If --blame-context is unspecified, it prints this number of contextual lines for BAD instructions as well.'
H1C7BC51D6E48: '列印所有指令的歸責上下文（如果可能）。此參數指定非 BAD 指令的上下文行數（請參閱 --blame-context）。如果未指定 --blame-context，則會為 BAD 指令也列印此數量的上下文行數。'
# 'Prints the combined library module before the output'
HF27FB27BCDA7: '列印輸出前的組合函式庫模組'
# 'Prints the pass pipeline and returns.'
HB0A215EA899E: '列印 pass 管線並返回。'
# 'Prioritize increasing vectorization opportunity over cache cost when determining profitability'
H3BBA969790D8: '在判斷盈利能力時，優先增加向量化機會而非緩存成本'
# 'Probability value in the range [0.0, 1.0] of unconditional pseudo-random checks.'
HE60D8EB808AB: '機率值範圍 [0.0, 1.0] 的無條件偽隨機檢查。'
# 'Probability value in the range [0.0, 1.0] to keep instrumentation of a function. Note: instrumentation can be skipped randomly OR because of the hot percentile cutoff, if both are supplied.'
H055D3EE8123A: '機率值範圍 [0.0, 1.0] 用於保留函數的插樁。注意：若同時提供此參數和熱百分位數閾值，插樁可能因隨機跳過 OR 因熱百分位數閾值而被跳過。'
# 'Proceed with Loop Idiom Vectorize Pass, but do not convert byte-compare loop(s).'
H5DD9E25ED00B: '繼續執行 Loop Idiom Vectorize Pass，但不轉換字節比較迴圈。'
# 'Proceed with loop idiom recognize pass, but do not convert loop(s) to memcpy.'
H0FF75025AEC2: '繼續執行 loop idiom recognize pass，但不轉換迴圈到 memcpy。'
# 'Proceed with loop idiom recognize pass, but do not convert loop(s) to memset.'
H5ED765213633: '繼續執行 loop idiom recognize pass，但不轉換迴圈到 memset。'
# 'Proceed with loop idiom recognize pass, but do not convert loop(s) to strlen.'
HF94C8F5C3643: '繼續執行 loop idiom recognize pass，但不轉換迴圈到 strlen。'
# 'Proceed with loop idiom recognize pass, enable conversion of loop(s) to wcslen.'
H3D374F7E71F0: '啟用 loop idiom recognize pass，將迴圈轉換為 wcslen。'
# 'Process Id for the profiled executable binary.'
HEAA24D9E11FE: '被分析可執行二進位檔的進程編號。'
# 'Process Implicit Definitions'
H436E5B2FC994: '處理隱含定義'
# 'Process functions in a top-down order defined by the profiled call graph when -sample-profile-top-down-load is on.'
HCCB8730D9A20: '在啟用 -sample-profile-top-down-load 時，根據分析後的呼叫圖定義的自頂向下順序處理函數。'
# 'Process scops that are unlikely to benefit from Polly optimizations.'
H97882415014C: '處理不太可能從 Polly 優化中受益的 scops。'
# 'Process source files in fixed form'
H83D6F8A6F254: '以固定格式處理來源檔'
# 'Process source files in free form'
H00F60A25C21E: '以自由格式處理來源檔'
# 'Process trigraph sequences'
HE92D60C3DD89: '處理三字符序列'
# 'Processor register names.'
H69E6140DD062: '處理器寄存器名稱。'
# 'Produce a faster access sequence for local-dynamic TLS variables where the offset from the TLS base is encoded as an immediate operand (AIX 64-bit only). This access sequence is not used for variables larger than 32KB.'
H96608A9C1D3A: '為本地動態 TLS 變數產生更快的存取序列，其 TLS 基底的偏移量以立即數操作數編碼（僅 AIX 64-bit）。此存取序列不會用於大於 32KB 的變數。'
# 'Produce a faster access sequence for local-exec TLS variables where the offset from the TLS base is encoded as an immediate operand (AIX 64-bit only). This access sequence is not used for variables larger than 32KB.'
HDB020B6BCE8A: '為本地執行 TLS 變數產生更快的存取序列，其 TLS 基底的偏移量以立即數操作數編碼（僅 AIX 64-bit）。此存取序列不會用於大於 32KB 的變數。'
# 'Produce gcov notes files (*.gcno)'
HA873BCAA45B3: '產生 gcov 紀錄檔 (*.gcno)'
# 'Produce progress indicator when performing measurements'
H2B5CD09D6FEE: '執行測量時顯示進度指示'
# 'Produce relaxation hints for linkers to try optimizing PIC call sequences into direct calls (MIPS only)'
HA18E999EA6E6: '產生供連結器進行鬆弛優化的提示，試圖將 PIC 呼叫序列優化為直接呼叫（僅 MIPS）'
# "Produced object files can use all ELF features supported by this binutils version and newer. If -fno-integrated-as is specified, the generated assembly will consider GNU as support. 'none' means that all ELF features can be used, regardless of binutils support. Defaults to 2.26."
H0EBB90A612ED: "產生的物件檔可使用此 binutils 版本及更新版本支援的所有 ELF 功能。若指定 -fno-integrated-as，產生的組譯檔將考慮 GNU 組譯器支援。'none' 表示可使用所有 ELF 功能，不論 binutils 支援情況。預設值為 2.26。"
# "Produced object files can use all ELF features supported by this binutils version and newer.If -no-integrated-as is specified, the generated assembly will consider GNU as support.'none' means that all ELF features can be used, regardless of binutils support"
H1E14DD582B2D: "產生的物件檔可使用此 binutils 版本及更新版本支援的所有 ELF 功能。若指定 -no-integrated-as，產生的組譯檔將考慮 GNU 組譯器支援。'none' 表示可使用所有 ELF 功能，不論 binutils 支援情況"
# 'Produces individual indexes for distributed backends.'
H3927BD641AFE: '為分散式後端產生個別索引。'
# 'ProfGen Options'
HA88661D355E6: 'ProfGen 選項'
# "Profile action execution to a file, or stderr if  '-' is passed"
HF893EEFBCD55: '將剖析動作執行結果輸出至檔案，或若傳入 "-" 則輸出至 stderr'
# 'Profile file loaded by -sample-profile'
HD83B6219FC6C: '由 -sample-profile 載入的剖析檔'
# 'Profile kind supported by show:'
H1EF9A7F6A57E: '支援 show: 的剖析類型'
# 'Profile kind:'
H8083370A6330: '剖析類型：'
# 'Profile remapping file loaded by -sample-profile'
H0C4B9EDC4542: '由 -sample-profile 載入的剖析重新映射檔'
# 'Profile summary info'
H60C73C1F9C77: '剖析摘要資訊'
# 'Profile uses flow sensitive discriminators'
H238CF0A82CE7: '剖析功能使用流程敏感的判別器'
# 'Profile with nested inlinee flatten out'
HDCD21980624B: '剖析功能將嵌套內聯函數展平'
# 'Prologue end.'
HCA56411EA86A: '函數序曲部分結束。'
# 'Prologue/Epilogue Insertion'
H8D5DD8D22319: '插入序曲/收尾'
# 'Prologue/Epilogue Insertion & Frame Finalization'
HA5A6E86B1573: '插入序曲/收尾及框架最終化'
# 'Promote Memory to Register'
H8DCCB244621C: '將記憶體提升到寄存器'
# 'Promote all vector constants'
HC242F7743ACD: '將所有向量常數提升'
# 'Propagate attributes in index'
HA59CB2A030BF: '傳播索引中的屬性'
# 'Propagate labels from condition values of select instructions to results.'
H2CDE89FF2376: '將select指令條件值的標籤傳播至結果。'
# 'Propagate non floating-point const stores as floating point values.For debugging purposes only'
HE1F8858006F6: '將非浮點常數存儲傳播為浮點值。僅供除錯使用'
# 'Provide additional constraints on the context parameters'
H7259373CFB29: '對上下文參數施加額外限制條件'
# 'Provide information about a particular module file'
HA7807B5E312C: '提供特定模組檔的相關資訊'
# 'Provide minimal debug info in the object/executable to facilitate online symbolication/stack traces in the absence of .dwo/.dwp files when using Split DWARF'
HD5C39FAF7423: '在使用分離式DWARF時，若缺少.dwo/.dwp檔案，可於物件/執行檔中提供最小的除錯資訊，以便利線上符號解析/堆疊追蹤'
# 'Provide the index produced by a ThinLink, required to perform the promotion and/or importing.'
HF72EED5DEBD8: '提供ThinLink產生的索引，用於執行提升和/或匯入作業時必須使用'
# 'Prune dependences between unrelated Phi nodes.'
HF00163550893: '修剪無關Phi節點間的依賴關係'
# 'Prune loop carried order dependences.'
H49F00DC5D681: '修剪迴圈攜帶的順序依賴關係'
# 'Put MODULE files in <dir>'
HEED5CC89CC67: '將MODULE檔放入 <dir>'
# 'Put crash-report files in <dir>'
H837FCDFF092D: '將當機報告檔放入 <dir>'
# 'Put each data item in its own section'
HF905C168CBCB: '將每個資料項目置於獨立區段'
# 'Put each function in its own section'
H169F18C51BFF: '將每個函數置於獨立區段'
# 'Put global and static data smaller than the limit into a special section'
H7B737FFA3469: '將小於限制值的全域和靜態資料放入特殊區段'
# 'Put objects of at most <size> bytes into small data section (MIPS / Hexagon)'
HB5EE66FF14A5: '將最多 <size> 個位元組的物件放入小型資料區段（MIPS/Hexagon）'
# 'Putting Jump Table in function section'
H0F2B2856EA39: '將跳轉表置於函數區段中'
# 'Qualified name of the symbol being queried.'
H4AFFA7C26BA4: '被查詢符號的限定名稱。'
# 'Qualified name to look up.'
H93CF54DB05CD: '要查詢的限定名稱。'
# 'Queries LTOModule::hasCtorDtor() on each IR file'
HDD169C16F456: '對每個IR檔查詢LTOModule::hasCtorDtor()'
# 'Query a given symbol (e.g. "a::b::foo") in\ndatabase directly without parsing the file.'
H8F2B84E16EA3: '直接在資料庫中查詢指定的符號（例如「a::b::foo」），而不解析該檔案。'
# 'Query string to be fuzzy-matched'
HA5E343EDC113: '要進行模糊匹配的查詢字串'
# 'Quotient that is obtained by dividing Nc, the parameter of themacro-kernel, by Nr, the parameter of the micro-kernel'
HFC3149B97C2A: '由宏核心的參數Nc除以微核心的參數Nr所得的商數'
# 'R600 Clause Merge'
HFCF9C3C3445E: 'R600 子句合併'
# 'R600 Control Flow Finalizer'
H19DB6E58B0FB: 'R600 控制流程最終處理器'
# 'R600 Emit Clause Markers'
H668E900B8AFA: 'R600 發射子句標記'
# 'R600 Expand Special Instrs'
H12D8DBCC740A: 'R600 展開特殊指令'
# 'R600 Packetizer'
H38622892495A: 'R600 封包化'
# 'R600 Vector Reg Merger'
H9C6C89BC6C1D: 'R600 向量寄存器合併'
# 'R600ExpandSpecialInstrs'
HD068997DE698: 'R600展開特殊指令'
# 'RISC-V CodeGenPrepare'
H405FA7A845BC: 'RISC-V 代碼生成準備'
# 'RISC-V DAG->DAG Pattern Instruction Selection'
H1C9181DFD79E: 'RISC-V DAG→DAG模式指令選擇'
# 'RISC-V Dead register definitions'
HC73090960463: 'RISC-V 死寄存器定義'
# 'RISC-V Fold Masks'
H0F357F81783D: 'RISC-V 摺疊遮罩'
# 'RISC-V Fold Memory Offset'
HBC0E6B2D64FC: 'RISC-V摺疊記憶體偏移'
# 'RISC-V Insert Read/Write CSR Pass'
H05452489D81B: 'RISC-V插入讀取/寫入CSR管線'
# 'RISC-V Insert VSETVLI pass'
H38C90053B8F4: 'RISC-V插入VSETVLI pass'
# 'RISC-V Insert Write VXRM Pass'
H73DBEFBC725F: 'RISC-V插入寫入VXRM管線'
# 'RISC-V Landing Pad Setup'
HAD75D026A39E: 'RISC-V例外處理區設置'
# 'RISC-V Late Branch Optimisation Pass'
HED8417E9F658: 'RISC-V晚期分支優化管線'
# 'RISC-V Load / Store Optimizer'
H10B62FA90EDD: 'RISC-V載入/儲存優化器'
# 'RISC-V Make Compressible'
H0497794478D9: 'RISC-V生成可壓縮指令'
# 'RISC-V Merge Base Offset'
HA38F1E005B04: 'RISC-V合併基礎偏移'
# 'RISC-V Optimize W Instructions'
H2B91D1998005: 'RISC-V優化W指令'
# 'RISC-V Redundant Copy Elimination'
HD915B17CC89F: 'RISC-V冗餘複製消除'
# 'RISC-V VL Optimizer'
H811C35753CA5: 'RISC-V VL優化器'
# 'RISC-V VMV0 Elimination'
H474A6943E72F: 'RISC-V VMV0消除'
# 'RISC-V Zacas ABI fix'
HF1D5344F95CB: 'RISC-V Zacas ABI修復'
# 'RISC-V Zcmp Push/Pop optimization pass'
HD89E7CCB5461: 'RISC-V Zcmp推/彈優化管線'
# 'RISC-V Zcmp move merging pass'
H9FBA8B3D1AEE: 'RISC-V Zcmp移動合併管線'
# 'RISC-V atomic pseudo instruction expansion pass'
H3692DAF330DE: 'RISC-V原子假指令展開pass'
# 'RISC-V gather/scatter lowering pass'
H05AC68772FF6: 'RISC-V gather/scatter降階pass'
# "RISC-V interrupt attribute '%0' requires extension '%1'"
H6CFF2777C071: "RISC-V中斷屬性 '%0' 需要擴展 '%1'"
# 'RISC-V post-regalloc pseudo instruction expansion pass'
H7D576AB43EFF: 'RISC-V寄存器分配後假指令展開pass'
# 'RISC-V pseudo instruction expansion pass'
H0A43861EEE99: 'RISC-V虛指令展開Pass'
# "RISC-V type %0 requires the '%1' extension"
HD2DE400562E4: "RISC-V類型 %0 需要 '%1' 擴展"
# 'ROCm device library path. Alternative to rocm-path.'
H671F96D79AC7: 'ROCm裝置庫路徑。rocm-path的替代選項。'
# 'ROCm installation path, used for finding and automatically linking required bitcode libraries.'
HF802D566C208: 'ROCm安裝路徑，用於尋找並自動連結所需的位元碼庫。'
# 'ROPI is not compatible with c++'
HF729D02F7368: 'ROPI不兼容C++'
# 'RTDyld Options'
HE939F729D84E: 'RTDyld選項'
# 'Random hotness seed to use (0 to generate new seed)'
H8A5B93398F3C: '用於隨機熱度的種子（0 表示生成新種子）'
# 'Range reduction is disabled for complex arithmetic operations'
H2F5A5383A90A: '複雜運算的範圍縮減已被禁用'
# 'Range reduction is enabled for complex arithmetic operations.'
H9F0817B3FD56: '複雜運算的範圍縮減已啟用'
# 'Range to search for II'
HFC1D9F881BD5: '尋找II的範圍'
# 'Ratio of VGPRs to budget for promoting alloca to vectors'
H825278A853D1: '將alloca提升為向量時，VGPRs與預算的比率'
# 'Re-materialize load from stub in PIC mode'
H3683BABDE7E9: '在PIC模式下重新生成存取器的stub載入'
# 'ReachingDefAnalysis'
H10A4CB1F102D: 'ReachingDefAnalysis'
# 'Read commands from file'
HDC06C8ECE255: '從檔案讀取命令'
# 'Read specified document from input (default = 1)'
H289DB22297D5: '從輸入讀取指定的文件（預設值=1）'
# 'Read summary from given YAML file before running pass'
HA5D8047CC861: '在執行Pass前讀取並解析給定的YAML檔案中的摘要'
# 'Read summary from given bitcode or YAML file before running pass'
HF2C570D041A3: '在執行Pass前讀取並解析給定位元碼或YAML檔案中的摘要'
# 'Read-write data relocatable, accessed relative to static base'
HDB933E15EC9A: '可重新定位的讀寫資料，相對於靜態基址存取'
# 'Reads and parses a basic block sections profile.'
HB98EF81EB7F2: '讀取並解析基本區塊區段的剖析資料。'
# 'Realign stack to the value of this flag (power of two)'
H85DCE488EFC2: '將堆疊重新對齊至此旗標的值（2的冪次）'
# 'Reassociate expressions'
H525BB5A9D397: '重新結合運算式'
# 'Rebalance address calculation trees to improve instruction selection'
HD14562B4E0A1: '重新平衡地址計算樹以改進指令選擇'
# 'Rebalance address tree only if it is imbalanced'
HB25FBDDE88D4: '僅當地址樹不平衡時才重新平衡'
# 'Rebalance address tree only if this allows optimizations'
H15A2B09D172E: '僅當重新平衡地址樹可進行優化時才執行'
# 'Reciprocal throughput'
H5BE31D7872D9: '倒數吞吐量'
# 'Recognize Hexagon-specific loop idioms'
H0CB87B633349: '辨識Hexagon特定的循環慣用語'
# 'Recognize and construct Pascal-style string literals'
HA6AC1DFB5663: '辨識並構建Pascal風格的字串字面字'
# 'Recognize reduction patterns.'
H8EBBA21EF01B: '辨識約簡模式'
# 'Record GlobalISel rule coverage files of this prefix if instrumentation was generated'
HB262A353ECFE: '如果已生成插樁，則記錄此前綴的GlobalISel規則覆蓋文件'
# 'Record stack frames with tagged allocations in a thread-local ring buffer'
H1B5FE744704A: '在執行緒局部的環狀緩衝區中記錄帶標記分配的堆疊框架'
# 'Record time trace'
H572EF7DA605F: '記錄時間追蹤'
# 'Recursively extract all called functions'
H04C195C76643: '遞迴提取所有被呼叫的函數'
# 'Redirect output to the specified file.'
H7E10ABCF17E8: '將輸出重導向到指定的文件'
# 'Reduce named metadata without taking its type into account'
H057F6A50F385: '不考慮類型的情況下簡化命名元數據'
# 'Reduce terminal output'
H77FB68186DA4: '減少終端輸出'
# 'Reduce the number of instrumented blocks'
HCA859F9847BF: '減少被插樁的區塊數量'
# 'Reduced priority compared to interactive work.'
H7591B998C026: '與互動式工作相比，其優先級降低'
# 'Refactoring options'
HF98C4D962B99: '重构選項'
# 'Reference type.'
HECBDD73B4748: '參考類型'
# 'Refrain from using FP whenever possible'
H567347A5F936: '盡量避免使用浮點運算'
# 'Regalloc eviction policy'
HF2E6FE69E8A8: '記憶體配置驅逐策略'
# 'Regalloc priority policy'
H20E1A4B298F4: '記憶體配置優先順序策略'
# 'Regard unreachable functions as possible devirtualize targets.'
HC7FBD9EBE035: '將不可達函數視為可能的虛函數化解目標。'
# "Regex of name of op's to exclude (no filter if empty)"
HA7F3D7BB58EA: '要排除的運算子名稱正則表示式（若留空則不過濾）'
# "Regex of name of op's to include (no filter if empty)"
H5284DD90C012: '要包含的運算子名稱正則表示式（若留空則不過濾）'
# 'Register Allocation Scoring Pass'
H4ED04651AE8B: '記憶體配置評分 Pass'
# 'Register Coalescer'
HAC4DFBDFBBCC: '記憶體配置合併器'
# 'Register Usage Information Collector'
HE69ABB0B3B23: '記憶體配置使用資訊收集器'
# 'Register Usage Information Propagation'
H3B0328B5CFCB: '記憶體配置使用資訊傳播'
# 'Register Usage Information Storage'
H9CFCD5C04174: '記憶體配置使用資訊儲存'
# 'Register allocator to use'
H01245B8A9746: '使用的記憶體配置器'
# 'Register allocator to use for RVV register.'
H16A5AC5915C9: 'RVV 記憶體配置器'
# 'Register allocator to use for SGPRs'
H14FE52F5159B: 'SGPR 記憶體配置器'
# 'Register allocator to use for VGPRs'
HB6E601BA3FB0: 'VGPR 記憶體配置器'
# 'Register allocator to use for WWM registers'
H2FF0F90865DC: 'WWM 記憶體配置器'
# 'Register allocator to use for new pass manager'
H2F824F849DFC: '新管線管理器使用的記憶體配置器'
# 'Reject specializations whose codesize savings are less than this much percent of the original function size'
H6EAED91C8037: '拒絕那些程式碼大小節省不足原始函數大小此百分比的特殊化'
# 'Reject specializations whose inlining bonus is less than this much percent of the original function size'
H6A8C88532B88: '拒絕那些內聯獎勵不足原始函數大小此百分比的特殊化'
# 'Reject specializations whose latency savings are less than this much percent of the original function size'
H289ADC17A173: '拒絕那些延遲節省不足原始函數大小此百分比的特殊化'
# 'Reject the profile if the mismatch percent is higher than the given number.'
H8455CF01EC30: '若差異百分比超過指定數值，則拒絕該剖析。'
# 'Relation kind for the predicate.'
HA372CC9D1BF6: '述詞的關係類型'
# 'Relative error tolerated'
HA4C6C4674C77: '可容忍的相對誤差'
# 'Relative frequency of outline region to the entry block'
H22B3E2A06E70: '輪廓區域相對於入口區塊的相對頻率'
# 'Relative hotness percentage threshold for indirect call promotion in proirity-based sample profile loader inlining.'
H046C25DB3427: '基於優先級的樣本剖析載入器內聯時，用於間接呼叫提升的相對熱度百分比閾值。'
# 'Relax checks of new-value validity'
H6708AC4FB40C: '鬆弛新值有效性的檢查'
# "Relax language rules and try to match the behavior of the target's native float-to-int conversion instructions"
HC867ACE28A09: '放寬語言規則，並嘗試匹配目標端原生浮點轉整數指令的行為'
# 'Relax occupancy targets for kernels which are memory bound (amdgpu-membound-threshold), or Wave Limited (amdgpu-limit-wave-threshold).'
HF2EE3E994ED5: '對記憶體綁定（amdgpu-membound-threshold）或波長受限（amdgpu-limit-wave-threshold）的核函數放寬佔用目標。'
# 'Relax out of range conditional branches'
H0294D6B1AD74: '鬆弛超出範圍的條件跳轉'
# 'Relocatable external references, non-relocatable code'
H5C17064AB794: '可重定位的外部引用，不可重定位的程式碼'
# 'Remapping file'
H3732B171A6F4: '重新映射檔'
# 'Remark file utilities\n'
HF16F906278C7: '遠端執行（rsh/ssh）額外選項'
# 'Remote execution (rsh/ssh) extra options'
H866585C76383: '遠端執行（rsh/ssh）主機'
# 'Remote execution (rsh/ssh) host'
HBAFCAFBDA09E: '遠端執行（rsh/ssh）埠'
# 'Remote execution (rsh/ssh) port'
HF897190244A2: '遠端執行（rsh/ssh）使用者識別碼'
# 'Remote execution (rsh/ssh) user id'
H34FEDDEF1D08: '遠端執行客戶端（rsh/ssh）'
# 'Remote execution client (rsh/ssh)'
H9FB0D35F3462: '移除.symtab區段'
# 'Remove .symtab section'
HDFF82FC1A75B: "從要編譯的裝置列表中移除CUDA/HIP卸載裝置架構（例如sm_35、gfx906）。'all' 會將列表重置為預設值。"
# "Remove CUDA/HIP offloading device architecture (e.g. sm_35, gfx906) from the list of devices to compile for. 'all' resets the list to its default value."
HC1BC07C832AB: '移除載入至偽用法'
# 'Remove Loads Into Fake Uses'
H633E035AD42E: '移除偽用處的載入'
# 'Remove Redundant DEBUG_VALUE analysis'
H9B54876630EC: '移除多餘的DEBUG_VALUE分析'
# 'Remove Sign and Zero Extends for Args'
H7F0FDF466871: '移除參數的符號擴展與零擴展'
# "Remove an attribute from a function. This can be a pair of 'function-name:attribute-name' to remove an attribute from a specific function. For example -force-remove-attribute=foo:noinline. Specifying only an attribute will remove the attribute from all functions in the module. This option can be specified multiple times."
HC96183D47DE8: '從函數移除屬性。這可以是「函數名稱:屬性名稱」的組合，以移除特定函數的屬性。例如 -force-remove-attribute=foo:noinline。僅指定屬性名稱會從模組中所有函數移除該屬性。此選項可指定多次。'
# 'Remove dead machine instructions'
H849DB0ECAC7B: '移除無效的機器指令'
# 'Remove duplicate DecoderTable entries generated due to HwModes'
HA7463EA0ACB3: '移除因HwModes生成的重複DecoderTable條目'
# 'Remove pseudo-probe after sample profile annotation.'
H6C8C4BABBDBA: '在剖析標註後移除偽探針。'
# 'Remove redundant Address-Size override prefix'
H8CDB6DE4DE72: '移除多餘的Address-Size覆寫前綴'
# 'Remove redundant instructions'
HC432DEAE7361: '移除多餘的指令'
# 'Remove the change description files regardless of successful\nmerging/replacing.'
HE8F5AA354FF8: '不論合併或取代是否成功，均移除變更描述檔。'
# 'Remove unreachable blocks from the CFG'
H71C9E890BAC6: '從控制流圖中移除無法達成的區塊'
# 'Remove unreachable machine basic blocks'
H6EBEC50FE707: '移除無法達成的機器基本區塊'
# 'Removes debug compile units which reference to non-existing global constants'
HEC2FF74E6087: '移除引用不存在全域常數的除錯編譯單位'
# 'Removes empty basic blocks and redirects their uses to their fallthrough blocks.'
H1E3948BB5559: '移除空的基本區塊，並將其使用重導至其穿透區塊'
# 'Removes irreducible control flow'
HD2920C925B96: '移除不可約化控制流'
# 'Removes range checks and sets br_table default targets'
H2B9F2567CD82: '移除範圍檢查並設定br_table預設目標'
# 'Rename Independent Subregisters'
HE4B797E90A33: '重新命名獨立子暫存器'
# 'Rename Register Operands'
H1AB17AA29EA4: '重新命名暫存器操作數'
# 'Rename Register Operands Canonically'
H9BD8A9C1263B: '依標準規範重新命名暫存器操作數'
# 'Rename counter variable of a comdat function based on cfg hash'
HB71CC1C2B75A: '根據cfg雜湊重新命名comdat函數的計數器變數'
# 'Renames all instructions (including user-named)'
H357FB4296AFA: '重新命名所有指令（包括使用者命名的）'
# 'Reorder instructions to use the WebAssembly value stack'
H6D195AC096F5: '重新排列指令以使用WebAssembly值堆疊'
# 'Reorders blocks in topological order'
H903DAE6FC729: '以拓墣順序重新排列區塊'
# 'Repack arrays that are non-contiguous in any dimension. If set to false, only the arrays non-contiguous in the leading dimension will be repacked'
H16B0416B17A1: '重新打包所有在任何維度上非連續的陣列。若設為false，僅重新打包在主維度上非連續的陣列'
# 'Repeat compilation N times for timing'
HD8053595EBB4: '重複編譯N次以測量時間'
# "Replace 'mul x, Const' with more effective instructions like SHIFT, LEA, etc."
HC54A5626311D: "將 'mul x, Const' 替換為更有效的指令，如SHIFT、LEA等"
# 'Replace ARM non-local ADR instructions with ADRP'
H4558533FD5F3: '將ARM的非局部ADR指令替換為ADRP'
# 'Replace PHIs by their incoming values'
H49377A409B02: '將PHI節點替換為其傳入值'
# 'Replace all memory allocation / deallocation calls with hipManagedMalloc / hipFree equivalents'
HC778D804F89A: '將所有記憶體分配/釋放呼叫替換為hipManagedMalloc/hipFree對應函數'
# 'Replace intrinsics with calls to vector library'
H4BF82E4A463A: '將內建函數替換為向量函式庫的呼叫'
# 'Replace narrow shifts with wider shifts.'
HF4525F5A5F2E: '將窄位移運算替換為更寬的位移運算'
# 'Replace occurrences of __nvvm_reflect() calls with 0/1'
H9A0C0F0562E0: '將__nvvm_reflect()呼叫的所有出現位置替換為 0/1'
# 'Replace physical registers with virtual registers'
H2480E837105C: '將實體寄存器替換為虛擬寄存器'
# 'Replace pointer out arguments with struct returns for non-private address space'
H8307543C4AE7: '在非私有位址空間中，將指標輸出參數替換為結構回傳'
# 'Replace returns with jumps to ``__x86_return_thunk`` (x86 only, error otherwise)'
H59B021D12978: '將傳回語法替換為跳轉至``__x86_return_thunk``（僅適用x86，否則錯誤）'
# 'Replace string for rename'
H722DD7E4F6B2: '用於重新命名的字串替換'
# 'Replace target triples in input files with this triple'
H1FCD419A56EC: '將輸入檔中的目標三元組替換为此三元組'
# 'Replace the contents of the <from> file with the contents of the <to> file'
H96ECB37ACA86: '將 <from> 檔案的內容替換為 <to> 檔案的內容'
# 'Replace unspecified target triples in input files with this triple'
H1555B263A14F: '將輸入檔中未指定的目標三元組替換为此三元組'
# 'Replacement Options'
H70C1BA182651: '取代選項'
# 'Replay on functions that have remarks associated with them (default)'
H318EBF2AE0C8: '在與其相關的註釋函數上重播（預設）'
# 'Replay on the entire module'
H7E3D6FBCD48C: '在整個模組上重播'
# 'Replay previous inlining and adjust context profile accordingly'
HC992566EB323: '重播先前的內聯並調整相應的上下文剖面'
# 'Report Options'
HB03D5D95141E: '報告選項'
# 'Report host JIT support'
HD82BFA66FA55: '報告主機JIT支援'
# 'Report missed transformations by optimization passes whose name matches the given POSIX regular expression'
H38AEDA823701: '報告與指定POSIX正則表達式匹配名稱的優化pass錯過的轉換'
# 'Report top stacks within each thread id'
H9AC494BD87C5: '報告每個執行緒ID內的頂部堆疊'
# 'Report top/bottom cycles when dumping SUnit instances'
H06A96EFDD1F5: '在轉儲SUnit實例時報告頂部/底部循環'
# 'Report total allocation sizes of hinted allocations'
H900F23D3261D: '報告提示分配的總分配大小'
# 'Report transformation analysis from optimization passes whose name matches the given POSIX regular expression'
HB0E9E547E094: '報告與指定POSIX正則表達式匹配名稱的優化pass的轉換分析'
# 'Report transformations performed by optimization passes whose name matches the given POSIX regular expression'
H815014839294: '報告與指定POSIX正則表達式匹配名稱的優化pass執行的轉換'
# 'Reports layout used for print, compare and select.'
HF32D32507443: '報告用於列印、比較和選擇的佈局。'
# 'Require & in extract patterns'
H9F971AAB4945: '在提取模式中需要 &'
# 'Require all positive matches to cover an entire input line.\nAllows leading and trailing whitespace if --strict-whitespace\nis not also passed.'
HA9004341F6EF: '要求所有正向匹配覆蓋整個輸入列。\n若未指定--strict-whitespace，則允許前後空白字元。'
# 'Require declaration of modules used within a module'
HE82DE2BF2262: '需要聲明模組內使用的模組'
# 'Require math functions to indicate errors by setting errno'
HE643AF2E91DD: '需要數學函數透過設定errno來表示錯誤'
# 'Require member pointer base types to be complete if they would be significant under the Microsoft ABI'
HF98EE3CAFBC8: '如果在Microsoft ABI下重要，則需要成員指標基類型為完整'
# 'Require target function definition when promoting indirect calls'
H559562EE460E: '在提升間接調用時需要目標函數定義'
# 'Reserve application registers (%g2-%g4)'
H9C435D2EFFB6: '保留應用程式寄存器 (%g2-%g4)'
# "Reserve physical registers, so they can't be used by register allocator. Should only be used for testing register allocator."
HB426310B498F: '保留物理寄存器，因此它們無法被寄存器分配器使用。僅用於測試寄存器分配器。'
# 'Reserve register r19 (Hexagon only)'
HDD745592B167: '保留r19寄存器（僅限Hexagon）'
# 'Reserve the G1 register (SPARC only)'
H20A9F2798EED: '保留G1寄存器（僅限SPARC）'
# 'Reserve the G2 register (SPARC only)'
HF2BF8B6A9338: '保留G2寄存器（僅限SPARC）'
# 'Reserve the G3 register (SPARC only)'
HEFD5459112F2: '保留G3寄存器（僅限SPARC）'
# 'Reserve the G4 register (SPARC only)'
HED0501965935: '保留G4寄存器（僅限SPARC）'
# 'Reserve the G5 register (SPARC only)'
H484BE92A9AAA: '保留G5寄存器（僅限SPARC）'
# 'Reserve the G6 register (SPARC only)'
H3E53244E7E33: '保留G6寄存器（僅限SPARC）'
# 'Reserve the G7 register (SPARC only)'
H8A30A1691BA0: '保留G7寄存器（僅限SPARC）'
# 'Reserve the I0 register (SPARC only)'
H42D22EDC8263: '保留I0寄存器（僅限SPARC）'
# 'Reserve the I1 register (SPARC only)'
HDC1C8763F288: '保留I1寄存器（僅限SPARC）'
# 'Reserve the I2 register (SPARC only)'
HF4C9D78BA277: '保留I2寄存器（僅限SPARC）'
# 'Reserve the I3 register (SPARC only)'
H6F74928ECDE5: '保留I3寄存器（僅限SPARC）'
# 'Reserve the I4 register (SPARC only)'
H96A8F3461A2B: '保留I4寄存器（僅限SPARC）'
# 'Reserve the I5 register (SPARC only)'
H2CC0E7760C25: '保留I5寄存器（僅限SPARC）'
# 'Reserve the L0 register (SPARC only)'
HE5E9B59351B3: '保留L0寄存器（僅限SPARC）'
# 'Reserve the L1 register (SPARC only)'
HC7B2711CCD38: '保留L1寄存器（僅限SPARC）'
# 'Reserve the L2 register (SPARC only)'
HE3E6D3620DCE: '保留L2寄存器（僅限SPARC）'
# 'Reserve the L3 register (SPARC only)'
H2079C316B58D: '保留L3寄存器（僅限SPARC）'
# 'Reserve the L4 register (SPARC only)'
HFDCEA5E83E9A: '保留L4寄存器（僅限SPARC）'
# 'Reserve the L5 register (SPARC only)'
H0DAAEFB046EA: '保留L5寄存器（僅限SPARC）'
# 'Reserve the L6 register (SPARC only)'
HA3AB8DC9562A: '保留L6寄存器（僅限SPARC架構）'
# 'Reserve the L7 register (SPARC only)'
HCB368E5B3769: '保留L7寄存器（僅限SPARC架構）'
# 'Reserve the O0 register (SPARC only)'
H23D89F231DEE: '保留O0寄存器（僅限SPARC架構）'
# 'Reserve the O1 register (SPARC only)'
H565A40459A05: '保留O1寄存器（僅限SPARC架構）'
# 'Reserve the O2 register (SPARC only)'
H36A0BD878A7A: '保留O2寄存器（僅限SPARC架構）'
# 'Reserve the O3 register (SPARC only)'
H254E112FF4DF: '保留O3寄存器（僅限SPARC架構）'
# 'Reserve the O4 register (SPARC only)'
H1284739ABBC2: '保留O4寄存器（僅限SPARC架構）'
# 'Reserve the O5 register (SPARC only)'
H855A27DC8B76: '保留O5寄存器（僅限SPARC架構）'
# 'Reserve the a0 register (M68k only)'
HC6CC635B6FFE: '保留a0寄存器（僅限M68k架構）'
# 'Reserve the a1 register (M68k only)'
H1017DAEE99AB: '保留a1寄存器（僅限M68k架構）'
# 'Reserve the a2 register (M68k only)'
H7621CB376F01: '保留a2寄存器（僅限M68k架構）'
# 'Reserve the a3 register (M68k only)'
HE22C009182A1: '保留a3寄存器（僅限M68k架構）'
# 'Reserve the a4 register (M68k only)'
H3178F7022236: '保留a4寄存器（僅限M68k架構）'
# 'Reserve the a5 register (M68k only)'
HA629301B0BC6: '保留a5寄存器（僅限M68k架構）'
# 'Reserve the a6 register (M68k only)'
H94D9B1D39C5A: '保留a6寄存器（僅限M68k架構）'
# 'Reserve the d0 register (M68k only)'
H9890925E1B8B: '保留d0寄存器（僅限M68k架構）'
# 'Reserve the d1 register (M68k only)'
H9D44B760CA90: '保留d1寄存器（僅限M68k架構）'
# 'Reserve the d2 register (M68k only)'
H7A1C1C89C2E5: '保留d2寄存器（僅限M68k架構）'
# 'Reserve the d3 register (M68k only)'
H2D88664BB126: '保留d3寄存器（僅限M68k架構）'
# 'Reserve the d4 register (M68k only)'
HA604540B0E07: '保留d4寄存器（僅限M68k架構）'
# 'Reserve the d5 register (M68k only)'
H90F714B743C6: '保留d5寄存器（僅M68k）'
# 'Reserve the d6 register (M68k only)'
H39C48EDA520F: '保留d6寄存器（僅M68k）'
# 'Reserve the d7 register (M68k only)'
H02BEF5875762: '保留d7寄存器（僅M68k）'
# 'Reserve the r9 register (ARM only)'
H32BC76F3A5B8: '保留r9寄存器（僅ARM）'
# 'Reserve the x1 register (AArch64/RISC-V only)'
H017A3C6C7049: '保留x1寄存器（僅AArch64/RISC-V）'
# 'Reserve the x10 register (AArch64/RISC-V only)'
H2D00D0C6D8F6: '保留x10寄存器（僅AArch64/RISC-V）'
# 'Reserve the x11 register (AArch64/RISC-V only)'
H22733F8F5483: '保留x11寄存器（僅AArch64/RISC-V）'
# 'Reserve the x12 register (AArch64/RISC-V only)'
HAA70056FA5B7: '保留x12寄存器（僅AArch64/RISC-V）'
# 'Reserve the x13 register (AArch64/RISC-V only)'
H50BB54A67F09: '保留x13寄存器（僅AArch64/RISC-V）'
# 'Reserve the x14 register (AArch64/RISC-V only)'
HE826489CFC34: '保留x14寄存器（僅AArch64/RISC-V）'
# 'Reserve the x15 register (AArch64/RISC-V only)'
HC23E86C037A9: '保留x15寄存器（僅AArch64/RISC-V）'
# 'Reserve the x16 register (AArch64/RISC-V only)'
H86953DAD10E7: '保留x16寄存器（僅AArch64/RISC-V）'
# 'Reserve the x17 register (AArch64/RISC-V only)'
HE02356B0C142: '保留x17寄存器（僅AArch64/RISC-V）'
# 'Reserve the x18 register (AArch64/RISC-V only)'
HF2317F641E49: '保留x18寄存器（僅AArch64/RISC-V）'
# 'Reserve the x19 register (AArch64/RISC-V only)'
H8F6A7020EC68: '保留x19寄存器（僅AArch64/RISC-V）'
# 'Reserve the x2 register (AArch64/RISC-V only)'
HDEC6D50548DB: '保留x2寄存器（僅AArch64/RISC-V）'
# 'Reserve the x20 register (AArch64/RISC-V only)'
H45338EFD5444: '保留x20寄存器（僅AArch64/RISC-V）'
# 'Reserve the x21 register (AArch64/RISC-V only)'
HA93990937323: '保留x21寄存器（僅AArch64/RISC-V）'
# 'Reserve the x22 register (AArch64/RISC-V only)'
H26B62228E618: '保留x22寄存器（僅AArch64/RISC-V）'
# 'Reserve the x23 register (AArch64/RISC-V only)'
HF22114CBFC6D: '保留x23寄存器（僅AArch64/RISC-V）'
# 'Reserve the x24 register (AArch64/RISC-V only)'
H83F65EC51004: '保留x24寄存器（僅限AArch64/RISC-V）'
# 'Reserve the x25 register (AArch64/RISC-V only)'
H2B3946E5495E: '保留x25寄存器（僅限AArch64/RISC-V）'
# 'Reserve the x26 register (AArch64/RISC-V only)'
H094A3CECAC3C: '保留x26寄存器（僅限AArch64/RISC-V）'
# 'Reserve the x27 register (AArch64/RISC-V only)'
H061585C0784C: '保留x27寄存器（僅限AArch64/RISC-V）'
# 'Reserve the x28 register (AArch64/RISC-V only)'
H1DF10547E904: '保留x28寄存器（僅限AArch64/RISC-V）'
# 'Reserve the x29 register (AArch64/RISC-V only)'
H87F78D168B6D: '保留x29寄存器（僅限AArch64/RISC-V）'
# 'Reserve the x3 register (AArch64/RISC-V only)'
H725FF72DC894: '保留x3寄存器（僅限AArch64/RISC-V）'
# 'Reserve the x30 register (AArch64/RISC-V only)'
H59143D663AD6: '保留x30寄存器（僅限AArch64/RISC-V）'
# 'Reserve the x31 register (AArch64/RISC-V only)'
HFFDF93DA3671: '保留x31寄存器（僅限AArch64/RISC-V）'
# 'Reserve the x4 register (AArch64/RISC-V only)'
H9F239EBCD413: '保留x4寄存器（僅限AArch64/RISC-V）'
# 'Reserve the x5 register (AArch64/RISC-V only)'
H2EA831621531: '保留x5寄存器（僅限AArch64/RISC-V）'
# 'Reserve the x6 register (AArch64/RISC-V only)'
HCE48DE527FE3: '保留x6寄存器（僅限AArch64/RISC-V）'
# 'Reserve the x7 register (AArch64/RISC-V only)'
HD802526DCF57: '保留x7寄存器（僅限AArch64/RISC-V）'
# 'Reserve the x8 register (AArch64/RISC-V only)'
H37CBBA5AD749: '保留x8寄存器（僅限AArch64/RISC-V）'
# 'Reserve the x9 register (AArch64/RISC-V only)'
H0CB86AACC5EE: '保留x9寄存器（僅限AArch64/RISC-V）'
# 'Reset machine function if ISel failed'
H7A45CC070EB3: '如果ISel失敗則重置機器函式'
# 'Resolution-based LTO test harness'
HFC41C14199C7: '基於解析的LTO測試架構'
# 'Resolve file paths relative to the specified directory'
HB397A2AE991E: '將檔案路徑解析為指定目錄的相對路徑'
# 'Restore original linkage of globals prior to CodeGen'
H30AC23ACCA7B: '在程式碼生成之前恢復全域變數的原始連結屬性'
# 'Restore the default behavior of not embedding source text in DWARF debug sections'
H98E5316CC560: '恢復預設行為，不在DWARF調試區段中嵌入原始碼文字'
# 'Restore the default behaviour of not generating long calls'
H49E0BF0F6145: '恢復預設行為，不產生長跳轉指令'
# 'Restrict DWARF features to those defined in the specified version, avoiding features from later versions.'
H3EFE36E674FA: '將DWARF功能限制為指定版本中定義的內容，避免使用後續版本的特徵'
# 'Restrict all prior -I flags to double-quoted inclusion and remove current directory from include path'
H3D88078880FD: '將所有先前的-I參數限制為雙引號包含，並從包含路徑中移除當前目錄'
# 'Restrict code to those available for App Extensions'
H187919D11FCC: '將程式碼限制為應用程式延伸模組可用的範圍'
# 'Restrict range of B instructions (DEBUG)'
HC083C6F4C8EE: '限制B指令的範圍（除錯）'
# 'Restrict range of BPcc/FBPfcc instructions (DEBUG)'
H85B5CACDDD43: '限制BPcc/FBPfcc指令的範圍（除錯）'
# 'Restrict range of BPr instructions (DEBUG)'
H0FAB44C44A31: '限制BPr指令的範圍（除錯）'
# 'Restrict range of Bcc instructions (DEBUG)'
H400749DA0205: '限制Bcc指令的範圍（除錯）'
# 'Restrict range of CB instructions (DEBUG)'
HE052E990A1F8: '限制CB指令的範圍（除錯）'
# 'Restrict range of CB[N]Z instructions (DEBUG)'
HCAA4E790CDDA: '限制CB[N]Z指令的範圍（除錯）'
# 'Restrict range of TB[N]Z instructions (DEBUG)'
H8319D33A4041: '限制TB[N]Z指令的範圍（除錯）'
# 'Restrict range of branch instructions (DEBUG)'
H80C66F8F6D0A: '限制分支指令的範圍（除錯）'
# 'Restrict range of loopN instructions (testing only)'
HDC7B8D8739B5: '限制loopN指令的範圍（僅供測試）'
# 'Restrict remat for statepoint operands'
H915A155B8538: '限制狀態點Operand的重新分配'
# 'Restrict sanitizer coverage instrumentation exclusively to modules and functions that match the provided special case list, except the blocked ones'
HF665154F84D1: '僅對符合特殊案例清單（排除被封鎖的）的模組和函式，執行剖析覆蓋範圍插樁'
# 'Restrict specifier.'
H0429709567D5: '限制指定項。'
# 'Resume compilation after a specific pass'
H0C491338806A: '在特定pass後恢復編譯'
# 'Resume compilation before a specific pass'
H1BE82678A264: '在特定pass前恢復編譯'
# 'Retain macro definitions in /E mode'
HED02F9B02911: '在/E模式中保留宏定義'
# 'Return all structs in memory (PPC32 only)'
H1FA38C42BEE4: '在記憶體中傳回所有structs（僅PPC32）'
# 'Return small structs in registers (PPC32 only)'
H2418E605C08F: '在寄存器中傳回小型結構體 (僅限PPC32)'
# 'Reverse allocation order of local live ranges, such that shorter local live ranges will tend to be allocated first'
HB6873693AAD6: '反轉局部活躍範圍的分配順序，使得較短的局部活躍範圍傾向於被優先分配'
# 'Rewrite Legacy Objective-C source to C++'
H756144AF61D7: '將舊版 Objective-C 來源改寫為 C++'
# 'Rewrite Objective-C source to C++'
H97D2AC714B44: '將 Objective-C 來源改寫為 C++'
# 'Rewrite Partial Register Uses'
HCE6FCECEDA90: '改寫部分寄存器使用'
# 'Rewrite unaligned loads as a pair of aligned loads'
HB7B2CD3A9808: '將未對齊的載入操作改寫為成對的對齊載入操作'
# 'Rewrite undef for PHI'
HD99A47BCF5A8: '為 PHI 節點改寫未定義值'
# 'Rewriter playground'
HE6E28450C65C: '改寫器測試環境'
# 'Rewriter to run'
HD27186628DE0: '要執行的改寫器'
# 'Right before the vectorizer'
HE1F20E3A6191: '在向量化之前'
# 'Root for relative input paths'
H44AB7F76C38B: '相對輸入路徑的根目錄'
# 'Root.'
H81747C7D336A: '根目錄。'
# "Roughly estimate the number of cycles that 'long latency' instructions take for targets with no itinerary"
HEEDD34050A74: '粗略估計無行程表目標的「長延遲」指令所需週期數'
# 'Round section sizes up to the section alignment'
HE0CCC8143863: '將區段大小向上取整至區段對齊值'
# 'Round-trip the IR after parsing and ensure it succeeds'
HB85D02D3E83D: '在解析後反向轉換 IR 並確保成功'
# 'Run GCN iterative scheduler for ILP scheduling (experimental)'
H1C7DB026D127: '執行 GCN 迭代排程器進行 ILP 排程（實驗性）'
# 'Run GCN iterative scheduler for minimal register usage (experimental)'
HEE1CE35E76A1: '執行 GCN 迭代排程器以最小化寄存器使用量（實驗性）'
# 'Run GCN scheduler to maximize ilp'
HFF1542675A34: '執行 GCN 排程器以最大化 ILP'
# 'Run GCN scheduler to maximize memory clause'
H7E5277DF8B56: '執行 GCN 排程器以最大化記憶體條款'
# 'Run GCN scheduler to maximize occupancy'
H55CABD9DC534: '執行 GCN 排程器以最大化佔用率'
# 'Run GCN scheduler to maximize occupancy (experimental)'
H2546364E49BB: '執行GCN調度器以最大化佔用率（實驗性）'
# "Run Hexagon's custom scheduler"
HD930CA19D3B9: '執行Hexagon的自定義調度器'
# 'Run MachineScheduler post regalloc (independent of preRA sched)'
H2FBC06B95112: '在寄存器分配後執行MachineScheduler（獨立於preRA調度器）'
# 'Run PGO context sensitive IR instrumentation'
HF2D51A482F76: '執行PGO（配置文件引導型優化）上下文敏感的IR插樁'
# 'Run Partial inlining pass'
H67505263F683: '執行Partial inlining pass'
# 'Run PowerPC PostRA specific scheduler'
H78B21F1324B5: '執行PowerPC PostRA特定的調度器'
# 'Run PowerPC PreRA specific scheduler'
H394DF3D974FB: '執行PowerPC PreRA特定的調度器'
# "Run R600's custom scheduler"
H72CC1BA879B5: '執行R600的自定義調度器'
# "Run SI's custom scheduler"
HD076B4B4194B: '執行SI的自定義調度器'
# 'Run SimplifyCFG after expanding atomic operations to make use of cmpxchg flow-based information'
H0C90ACC17582: '在展開原子操作後執行SimplifyCFG，以便使用cmpxchg基於流程的資訊'
# 'Run a global pre-inliner to merge context profile based on estimated global top-down inline decisions'
H5BFD65B47642: '執行全域預內聯以根據預估的全域自頂向下內聯決策合併上下文剖面'
# 'Run a quick verification useful for regression testing'
H47645E615F6C: '執行快速驗證，用於回歸測試'
# 'Run all passes twice, re-using the same pass manager (legacy PM only).'
HD061B5F25379: '執行所有passes兩次，重用相同的pass manager（僅限舊版PM）'
# 'Run amdgpu-regbankselect and amdgpu-regbanklegalize instead of regbankselect'
H5E9AEFE2CEF6: '執行amdgpu-regbankselect和amdgpu-regbanklegalize而不是regbankselect'
# 'Run an early inliner pass before Polly'
H54AEF889D7EF: '在Polly之前執行early inliner pass'
# 'Run analysis on specific function (for C++ include parameters in name)'
H3C6F4C08F518: '對特定函數執行分析（適用於C++包含參數在名稱中）'
# 'Run asan instrumentation on LDS instructions lowered to global memory'
H9EB47AECF813: '在已降級到全域記憶體的LDS指令上執行asan插樁'
# 'Run cc1 in-process'
H9A5B5F4BB70B: '在進程中執行cc1'
# 'Run cleanup optimization passes after vectorization'
HD6645D1D40DA: '在向量化後執行清理優化passes'
# 'Run code-completion at each point (slow)'
HF356338EEEA8: '在每個點執行代碼補全（緩慢）'
# 'Run compiler only for specified passes (comma separated list)'
H08D41AC776F1: '僅執行指定的pass（以逗號分隔的列表）'
# 'Run early if-conversion'
H7D7CDDBB010E: '提前執行if轉換'
# 'Run everything twice, re-using the same pass manager and verify the result is the same.'
H7032E14A02BE: '將所有內容執行兩次，並重用相同的pass管理器，確認結果相同。'
# 'Run in quiet mode'
HE4D4F6750673: '以安靜模式執行'
# 'Run indirect-call promotion for call instructions only'
H8967C75A35F7: '僅對call指令執行間接呼叫提升'
# 'Run indirect-call promotion for invoke instruction only'
H4BE6E5960D01: '僅對invoke指令執行間接呼叫提升'
# 'Run indirect-call promotion in LTO mode'
HD86948C0B3ED: '在LTO模式下執行間接呼叫提升'
# 'Run indirect-call promotion in SamplePGO mode'
HFD50D337E7CB: '在SamplePGO模式下執行間接呼叫提升'
# 'Run instrumented parse and dump the parsing log'
HB71F9FFCCF1A: '執行插樁分析並傾印語法分析日誌'
# 'Run live interval analysis earlier in the pipeline'
H35280A9E9FE7: '在管線中更早執行活躍區間分析'
# 'Run loop-rotation in the prepare-for-lto stage. This option should be used for testing only.'
HF3A983596CA9: '在prepare-for-lto階段執行迴圈旋轉。此選項僅供測試使用。'
# 'Run many different optimization sequences on program to find bugs'
H612ED68363A4: '對程式執行多種不同的優化序列以尋找錯誤'
# 'Run on all functions guaranteed to be beneficial'
HE1FEAE7130C4: '執行所有保證有益的函數'
# 'Run only CodeGen passes and translate FIR to LLVM IR'
H1A5B7B8CBB9C: '僅執行CodeGen pass並將FIR轉譯為LLVM IR'
# 'Run opt passes and codegen at O0'
H81E08FD2A09C: '在O0優化級別執行opt pass和程式碼產生'
# 'Run opt passes and codegen at O1'
H474C4A7BA297: '在O1優化級別執行opt pass和程式碼產生'
# 'Run opt passes and codegen at O2'
H3F347B539B5D: '在O2優化級別執行opt pass和程式碼產生'
# 'Run opt passes and codegen at O3'
H59E1D82AC2DB: '在O3優化級別執行opt pass和程式碼產生'
# 'Run optimizations through valgrind'
HE1CE530E789B: '透過valgrind執行優化'
# 'Run pre-RA exec mask optimizations'
H3C26C74A3208: '執行RA前的執行遮罩優化'
# 'Run pre-emit peephole optimizations.'
H4E182C271921: '執行發射前的窥孔優化。'
# 'Run preprocessor, dump internal rep of tokens'
H45922516F2A2: '執行預處理器，傾印符號的內部表示'
# 'Run program Just-In-Time'
H7E1CCE7CE553: '即時執行程式'
# 'Run static analysis engine'
H84EF43F50B25: '執行靜態分析引擎'
# 'Run the Fast mode (default mapping)'
HFFDBC5733152: '執行快速模式（預設映射）'
# 'Run the InputOuputTest action. Use for development and testing only.'
H0B55FCB86E0F: '執行InputOuputTest動作。僅供開發和測試使用。'
# 'Run the LLVM verifier after every LLVM pass'
H136DF2CC2C10: '在每次LLVM pass後執行LLVM驗證器'
# 'Run the Loop vectorization passes'
H593612B18031: '執行Loop向量化passes'
# 'Run the NewGVN pass'
HB971140FD767: '執行NewGVN pass'
# 'Run the SLP vectorization passes'
H568F60BAF50F: '執行SLP向量化passes'
# 'Run the dead code elimination'
H072ED3EF8554: '執行無效程式碼消除'
# 'Run the loop rotation transformation after PGO instrumentation'
H99F728F7A8D4: '在PGO插樿後執行loop rotation轉換'
# 'Run the pipeline stored in the reproducer'
HE376D46CB8F5: '執行存儲在重現器中的管線'
# 'Run the preprocessor, parser and semantic analysis stages'
HC4E9B82FB80F: '執行預處理器、解析器及語法分析階段'
# 'Run the static analyzer'
H12842C536C2E: '執行靜態分析器'
# "Run the vectorizer only on file paths that match any in the list of comma-separated regex's."
H4461671734B6: '僅在符合逗號分隔正則表達式清單中任一項的檔案路徑上執行向量化器。'
# 'Run the verifier after each transformation pass'
H1D9EDA842E47: '在每次轉換pass後執行驗證器'
# 'Runs certain features (e.g. hover) at each point in the file. Somewhat slow.'
H5799AB4D2B8E: '在文件的每個位置執行特定功能（例如hover）。速度較慢。'
# 'Runtime determined (OMP_SCHEDULE)'
H89C96D1C59A0: '由執行階段決定（OMP_SCHEDULE）'
# 'RuntimeDyld'
HB046756B987A: 'RuntimeDyld'
# 'Rvalue reference.'
H1006B6835AD7: '右值引用。'
# 'SCE targets (e.g. PS4)'
H24C3BD16186C: 'SCE 目標（例如 PS4）'
# "SDK does not contain 'libarclite' at the path '%0'; try increasing the minimum deployment target"
HBB626BB3124D: "SDK 路徑 '%0' 中未包含 'libarclite'；請嘗試提高最低部署目標"
# "SDK settings were ignored as 'SDKSettings.json' could not be parsed"
HF609237E0BEB: "因無法解析 'SDKSettings.json'，因此忽略 SDK 設定"
# "SEH '__try' is not supported on this target"
H06D89FCA39AA: 'SEH "__try" 不支援此目標平台'
# 'SI Fix SGPR copies'
HDB9A9026CAAF: 'SI 修復 SGPR 副本'
# 'SI Fix VGPR copies'
H0BCE6618F46C: 'SI 修復 VGPR 副本'
# 'SI Fold Operands'
H2A817B2075A4: 'SI 合併操作數'
# 'SI Form memory clauses'
H4B75CB116FD5: 'SI 建立記憶體條款'
# 'SI Insert Hard Clauses'
H0DD59BBBCDBF: 'SI 插入硬條款'
# 'SI Insert Waitcnts'
HE04885DD4D00: 'SI 插入 Waitcnts'
# 'SI Load Store Optimizer'
H267BF961C532: 'SI 載入儲存最佳化器'
# 'SI Lower WWM Copies'
HEE5F5720909B: 'SI 降級 WWM 副本'
# 'SI Lower i1 Copies'
H5A7C0C9EA184: 'SI 降級 i1 副本'
# 'SI Memory Legalizer'
H0FE7146D147C: 'SI 記憶體法規符合器'
# 'SI Optimize VGPR LiveRange'
H8E8730AB73D6: 'SI 最適化 VGPR 存活範圍'
# 'SI Peephole SDWA'
H2175B3F2C8E1: 'SI SDWA 小孔最佳化'
# 'SI Pre-allocate WWM Registers'
H4206E704E134: 'SI 預分配 WWM 記憶體'
# 'SI Shrink Instructions'
HBAF7A342AB3A: 'SI 縮減指令'
# 'SI Whole Quad Mode'
HFFEC46D8FF13: 'SI 整個 Quad 模式'
# 'SI insert s_cbranch_execz instructions'
HDC4FDC149030: 'SI 插入 s_cbranch_execz 指令'
# 'SI lower SGPR spill instructions'
H3F5058866166: 'SI 轉換 SGPR 堆疊存儲指令'
# 'SI lower control flow'
H9237847AA8B8: 'SI 轉換控制流程'
# 'SI optimize exec mask operations'
H3185D5441AB0: 'SI 優化 exec 遮罩運算'
# 'SI optimize exec mask operations pre-RA'
H08D9A111CF96: 'SI pre-RA 階段優化 exec 遮罩運算'
# 'SI peephole optimizations'
H1E6ED6F3445E: 'SI 窥孔優化'
# 'SI post-RA bundler'
H6FF7F01FEB53: 'SI post-RA 指令打包器'
# 'SIMD Library for Evaluating Elementary Functions'
H4F65620685F5: 'SIMD 計算基本函數函式庫'
# 'SME Peephole Optimization'
HB6505176089D: 'SME 窥孔優化'
# 'SOURCEFILE'
H4695CE0F3CCA: 'SOURCEFILE'
# 'SPARC DAG->DAG Pattern Instruction Selection'
HEB1F489D0073: 'SPARC DAG→DAG 模式指令選擇'
# 'SPIR-V Regularizer'
HA3F8831A4FED: 'SPIR-V 常規化處理'
# 'SPIR-V Shader capability'
H3F602E05A4A8: 'SPIR-V 着色器功能'
# 'SPIR-V Translator compatibility mode'
HF7AF8DE76675: 'SPIR-V 翻譯器相容模式'
# 'SPIR-V capabilities to avoid if there are other options enabling a feature'
H9E1D87EB2349: '當其他選項啟用某功能時需要避免的 SPIR-V 功能'
# 'SPIRV NonSemantic.Shader.DebugInfo.100 emitter'
H16A3D5391B31: 'SPIRV 非語意.Shader.調試資訊.100 產生器'
# 'SPIRV convergence regions analysis'
HB13555632C11: 'SPIRV 收斂區域分析'
# 'SPIRV emit intrinsics'
H98E5DCAE36C2: 'SPIRV 產生內建函數'
# 'SPIRV legalize bitcast pass'
H9940486F0CC0: 'SPIRV 位元轉換法化 pass'
# 'SPIRV module analysis'
HD4BE1FB1BEF1: 'SPIRV 模組分析'
# 'SPIRV post legalizer'
HF7EB3FED68B9: 'SPIRV 合法化後處理'
# 'SPIRV pre legalizer'
HD74E28A77753: 'SPIRV 合法化前處理'
# 'SPIRV prepare functions'
H17164FF97DDE: 'SPIRV 函數準備處理'
# 'SPIRV split region exit blocks'
H2A782FAE48E8: 'SPIRV 分割區域退出區塊'
# 'SPIRV strip convergent intrinsics'
HDA93080C3642: 'SPIRV 移除收斂內建函數'
# 'STOKE pass options'
H4008C64D6703: 'STOKE pass 選項'
# "SUBCOMMAND '"
H49B0CF838F29: "子命令 '"
# 'SUBCOMMANDS:\n\n'
H5B04A2FD12F5: '子命令：\n\n'
# 'SVE vector type %0 cannot be used in a non-streaming function'
H9A5DD8A133CA: 'SVE 向量類型 %0 不能用於非流式函數'
# 'SVE vector type %0 cannot be used in a target without sve'
H9A595E01748A: 'SVE 向量類型 %0 不能用於不支援SVE的目標平台'
# 'SYCL host compilation'
H61E19C960525: 'SYCL 主機編譯'
# 'SYCL language standard to compile for.'
HD9004BF51D18: '編譯用的SYCL語言標準。'
# 'Safe Stack instrumentation pass'
H90200C1EBE5D: 'Safe Stack 插樁 pass'
# 'Safepoint IR Verifier'
H55862F19A9A2: '安全點IR驗證器'
# 'Salvage stale MemProf profile'
H99E23DAB6376: '復用過期的MemProf剖析資料'
# 'Salvage stale profile by fuzzy matching and use the remapped location for sample profile query.'
H5090826C05A6: '透過模糊匹配復用過期的剖析資料，並使用重新映射的位置進行樣本剖析查詢。'
# 'Salvage unused profile by matching with new functions on call graph.'
H21FAAE36AF70: '透過呼叫圖與新函數匹配來復用未使用的剖析資料。'
# 'Same as "/diasdkdir <dir>/DIA SDK" /vctoolsdir <dir>/VC/Tools/MSVC/<vctoolsversion> "/winsdkdir <dir>/Windows Kits/10"'
HEB5E99FA660E: '等同於指定/diasdkdir <dir>/DIA SDK、/vctoolsdir <dir>/VC/Tools/MSVC/<vctoolsversion> 和/winsdkdir <dir>/Windows Kits/10'
# 'Same as /Ob2'
H8A3F940C0EB5: '等同於/Ob2'
# 'Same as prepare-and-assemble-snippet, but also creates the full sequence that can be dumped to a file using --dump-object-to-disk'
H77B67B5A93B5: '等同於prepare-and-assemble-snippet，但也能生成完整序列，並使用--dump-object-to-disk參數將其存檔至檔案。'
# 'Same as prepare-measured-code, but also runs the measurement (default)'
H1BADD228E79D: '與 prepare-measured-code 相同，但也會執行測量（預設）'
# 'Same as prepare-snippet, but also dumps an excerpt of the sequence (hex encoded)'
H329F8CE6355E: '與 prepare-snippet 相同，但也會轉儲序列的片段（十六進位編碼）'
# 'Same priority as other clangd work.'
H91A607AFE9B7: '與其他 clangd 工作具有相同優先順序。'
# 'Sample profile'
H06DF786C2443: '剖析範本'
# 'Sanitize loads from memory.'
H0BDA70010B81: '檢查記憶體中的載入。'
# 'Sanitize loads from memory. When disable, no significant security is provided.'
H6827B410126B: '檢查記憶體中的載入。當禁用時，不會提供顯著的安全性保護。'
# 'Sanitizer Coverage. 0: none, 1: entry block, 2: all blocks, 3: all blocks and critical edges'
H6153504BE2F9: '檢查工具覆蓋範圍。0: 無，1: 入口區塊，2: 所有區塊，3: 所有區塊及關鍵邊'
# 'Sanitizer Statistics Processing Tool'
H8F91AACBD96D: '檢查工具統計處理工具'
# 'Sanitizer coverage type'
HB92F228F8C30: '檢查工具覆蓋類型'
# 'Save ThinLTO generated object files using filenames created in the given directory.'
HC53E73C90B26: '使用在指定目錄下生成的檔名儲存 ThinLTO 產生的物件檔。'
# 'Save ThinLTO temp files using filenames created by adding suffixes to the given file path prefix.'
H2E31524DF75E: '使用在給定檔案路徑前綴後添加後綴生成的檔名，儲存 ThinLTO 暫存檔。'
# 'Save arguments passed by registers to ABI-defined stack positions'
H9D88220945B3: '將通過寄存器傳遞的參數儲存到 ABI 定義的堆疊位置'
# "Save intermediate compilation results. <arg> can be set to 'cwd' for current working directory, or 'obj' which will save temporary files in the same directory as the final output file"
H353A183FAD67: '儲存中間編譯結果。參數 <arg> 可設為 "cwd" 以使用當前工作目錄，或設為 "obj" 將暫存檔儲存至與最終輸出檔相同的目錄'
# 'Save intermediate module file results when compiling a standard C++ module unit.'
HC4664B3AE862: '編譯標準 C++ 模組單元時，儲存中間模組檔結果。'
# 'Save llvm statistics.'
H5CC2FF1F8C02: '儲存 llvm 統計資料。'
# 'Save selected temporary files. Cannot be specified together with -save-temps'
H9B274443882B: '儲存選取的暫存檔。不能與 -save-temps 一同指定'
# 'Save statistics to the specified file'
H869C572478B5: '將統計資料儲存至指定檔案'
# 'Save subprocess statistics to the given file'
HBB6AB7F311A5: '將子程序統計資料儲存至指定檔案'
# 'Save temp files'
H4A37FEDB9D14: '儲存暫存檔'
# 'Save temporary files'
H57B3E4133626: '儲存暫存檔'
# "Save temporary labels in the symbol table. Note this may change .s semantics and shouldn't generally be used on compiler-generated code."
H93DB00E1BEA2: '在符號表中保存暫時標籤。注意這可能會改變 .s 語意，通常不應在編譯器生成的代碼上使用。'
# 'Save the IR before running optimizations'
H4A2342002AC8: '在執行優化之前保存IR'
# 'Save the device memory output of the replayed kernel execution.'
H6C85C6C553C1: '保存重播核心執行的裝置記憶體輸出。'
# 'Scalable vectorization is available and favored when the cost is inconclusive.'
H66BDF3C7947B: '可擴展向量化在成本不明確時可用且被優先選擇。'
# 'Scalable vectorization is disabled.'
HEDA81875966D: '可擴展向量化已禁用。'
# 'Scalar Evolution Analysis'
H8691C6809389: '標量演進分析'
# 'Scalar Replacement Of Aggregates'
HC922609C7C15: '聚合體的標量替代'
# 'Scalar independence heuristic'
H6DBF46490571: '標量獨立啟發式規則'
# 'ScalarEvolution-based Alias Analysis'
HB1C967D70FE5: '基於標量演進的別名分析'
# 'Scalarize unsupported masked memory intrinsics'
H4C20D577FF69: '將不受支援的遮罩記憶體內建函數轉換為標量操作'
# 'Scalarize vector operations'
H31C547703795: '將向量運算轉換為標量操作'
# 'Scale the memop size counts using the basic  block count value'
H77E1E3932329: '使用基本區塊計數值調整memop大小的統計數值'
# 'Scale to limit the cost of inline deferral'
HEB04CD55185A: '調整以限制-inline延期-的成本'
# 'Scavenge virtual registers inside basic blocks'
HDFF735ACD536: '在基本區塊內回收虛擬寄存器'
# 'Schedule VSX FMA instruction mutation early'
HCC0329BA7D34: '提前安排VSX FMA指令的轉換'
# 'Schedule bottom-up for max ILP'
HD1699FACAF31: '以最大化指令級並行（ILP）為目標的自底向上排程'
# 'Schedule bottom-up for min ILP'
H10AC8BD5ECDA: '以最小化指令級並行（ILP）為目標的自底向上排程'
# 'Scheduling type of parallel OpenMP for loops'
H999BCCD4C603: 'OpenMP並行for循環的排程類型'
# 'Scope contributions to the debug information.'
H9BF0B0DDBE12: '除錯資訊的作用域貢獻'
# 'Scope kind to use when printing scopes.'
H494C78291AB2: '列印作用域時使用的範圍類型'
# 'Scope of graph to export to dot'
H9536D6B1D873: '要匯出至dot的圖形作用域'
# 'Scoped NoAlias Alias Analysis'
HB6BD5D72C4B3: '作用域化的NoAlias別名分析'
# 'Scopes.'
H4E6EE0359B5C: '作用域。'
# 'Search $prefix$file for executables, libraries, and data files. If $prefix is a directory, search $prefix/$file'
H6DC87438E4A7: '在$prefix$file中搜尋可執行檔、庫和資料檔。如果$prefix是目錄，則搜尋$prefix/$file'
# 'Search elements matching the given pattern.'
H98914CD94E9A: '搜尋符合指定模式的元素。'
# 'Search even non-imported modules to resolve references'
H1FD982ACF76B: '即使未導入模組，也進行參考解析的搜尋'
# 'Search for the GCC installation with the specified triple.'
H74F06477D6B9: '搜尋指定triple的GCC安裝路徑'
# 'Section-specific Dump Options'
H9E36553E678B: '區段特定的Dump選項'
# 'Seed for the random number generator'
H9C3EECBF2BE5: '隨機數生成器的種子'
# 'Seed used for randomness'
H228A43C8FFBC: '用於隨機性的種子'
# 'Select DPP or Iterative strategy for scan'
HE53499864EE5: '選擇scan的DPP或反覆運算策略'
# 'Select Options'
HD84BE9DE2F9E: '選擇選項'
# 'Select Windows run-time library'
HAC106D381AC2: '選擇Windows執行階段函式庫'
# 'Select custom AMDGPU scheduling strategy.'
H64E4378BB72D: '選擇自訂的AMDGPU排程策略。'
# 'Select label scheme for branch control-flow architecture protection'
H7B3CA40CA6B3: '選擇用於分支控制流程架構保護的標籤方案'
# "Select math operations' runtime behavior:"
HBD0952A00DD6: '選擇數學運算的runtime行為:'
# 'Select return address signing scope'
H4F99B374ECF5: '選擇返回位址簽署作用域'
# 'Select straight-line speculation hardening scope (ARM/AArch64/X86 only). <arg> must be: all, none, retbr(ARM/AArch64), blr(ARM/AArch64), comdat(ARM/AArch64), nocomdat(ARM/AArch64), return(X86), indirect-jmp(X86)'
H7FE74692FDC9: '選擇直線式預測強化作用域（僅限ARM/AArch64/X86）。<arg> 必須是：all、none、retbr(ARM/AArch64)、blr(ARM/AArch64)、comdat(ARM/AArch64)、nocomdat(ARM/AArch64)、return(X86)、indirect-jmp(X86)'
# 'Select target instructions out of generic instructions'
H687BF304766B: '從通用指令中選擇目標指令'
# 'Select the HWAddressSanitizer ABI to target (interceptor or platform, default interceptor). This option is currently unused.'
H2E53C4CE5E14: '選擇目標HWAddressSanitizer的ABI（中繼器或平台，預設為中繼器）。此選項目前未使用。'
# "Select the SIMD extension(s) to be enabled in LoongArch either 'none', 'lsx', 'lasx'."
H58773894FD9F: "選擇要在LoongArch中啟用的SIMD擴展，選項為 'none'、'lsx'、'lasx'。"
# 'Select the asm variant (integer) to use for output (3: unspecified)'
H269BE00B3354: '選擇輸出使用的整數型asm變體（3：未指定）'
# 'Select the assembly style for input'
HC379BD26B358: '選擇輸入的組裝語言格式'
# "Select the container format for clang modules and PCH. Supported options are 'raw' and 'obj'."
H35A81EACF6D7: "選擇clang模組和預編譯標頭（PCH）的容器格式。支援選項為 'raw' 和 'obj'。"
# 'Select the frame chain model used to emit frame records (Arm only).'
H6E15DFB39F91: '選擇用於發射frame記錄的frame chain模型（僅Arm）。'
# 'Select the kind of output desired'
H4B7026DCAB45: '選擇所需的輸出類型'
# 'Select the mode of detecting stack use-after-return in AddressSanitizer'
H18AC10CFE63E: '選擇AddressSanitizer中用於檢測堆疊use-after-return的模式'
# 'Select the scheduling optimizer'
HF3643F4F750F: '選擇排程優化器'
# 'Select the vectorization strategy'
HF0DE7753D578: '選擇向量化策略'
# 'Select tutorial version'
HA1F9E472551C: '選擇教程版本'
# 'Select underlying type for wchar_t'
H871CFB3D3DBF: '設定wchar_t的底層類型'
# "Select which XRay instrumentation points to emit. Options: all, none, function-entry, function-exit, function, custom. Default is 'all'.  'function' includes both 'function-entry' and 'function-exit'."
HF1CF9325D610: "選擇要發射的XRay插樁點類型。選項：all、none、function-entry、function-exit、function、custom。預設為 'all'。 'function' 包含 'function-entry' 和 'function-exit'。"
# 'Select which denormal numbers the code is permitted to require'
H2AC882EF26F4: '設定程式允許要求的非規格化數值類型'
# 'Select which denormal numbers the code is permitted to require for float'
HE697FDB681DE: '設定程式允許要求的float類型非規格化數值'
# 'Selected elements are displayed in a tabular format.'
HEA919FEE4B68: '選擇的項目以表格格式顯示。'
# 'Selected elements are displayed in a tree view (Include children)'
H177003785A78: '選擇的項目以樹狀視圖顯示（包含子項目）'
# 'Selected elements are displayed in a tree view. (Include parents)'
HDF9A5F80B1E1: '選擇的項目以樹狀視圖顯示。（包含父項目）'
# 'Selects the execution mode to use for running snippets'
HD1AD171EDC3B: '選擇執行程式片段所使用的執行模式'
# 'Serialize compiler diagnostics to a file'
HDAE0DE265E80: '將編譯器診斷資訊序列化至檔案'
# 'Set CPU for optimization without affecting instruction set'
H4812860590FE: '設定優化用的CPU，但不影響指令集'
# 'Set DWARF fission mode'
HA6B185D6C1A5: '設定DWARF分離模式'
# 'Set EABI type (default depends on triple):'
HE8D11354B2F8: '設定EABI類型（預設值取決於目標三元組）：'
# 'Set EABI type. Default depends on triple)'
H10E2EAF33A04: '設定EABI類型。預設值取決於目標三元組)'
# 'Set Fuchsia API level'
H6549E92FCDF2: '設定Fuchsia API層級'
# 'Set Hexagon Vector Length'
H7AAC4AA29051: '設定Hexagon向量長度'
# 'Set LTO mode'
HC407FF843F6C: '設定LTO模式'
# 'Set LTO mode for offload compilation'
HAFC85CCA6F44: '設定用於卸載編譯的LTO模式'
# 'Set OpenMP version (e.g. 45 for OpenMP 4.5, 51 for OpenMP 5.1). Default value is 11 for Flang'
HB4B241AD39C3: '設定OpenMP版本（例如 45 對應OpenMP 4.5，51對應OpenMP 5.1）。預設值為Flang的 11'
# 'Set OpenMP version (e.g. 45 for OpenMP 4.5, 51 for OpenMP 5.1). Default value is 51 for Clang'
H81EB65FB7662: '設定OpenMP版本（例如 45 對應OpenMP 4.5，51對應OpenMP 5.1）。預設值為Clang的 51'
# 'Set ThinLTO cache entry expiration time.'
HAC92585FAE36: '設定ThinLTO快取條目過期時間。'
# 'Set ThinLTO cache pruning directory maximum number of files.'
H5D4AE530977A: '設定ThinLTO快取修剪目錄的最大檔案數量。'
# 'Set ThinLTO cache pruning directory maximum size in bytes.'
H28BB199174A5: '設定ThinLTO快取修剪目錄的最大大小（以位元組為單位）。'
# 'Set ThinLTO cache pruning interval.'
H4990BDC788D5: '設定ThinLTO快取修剪間隔。'
# 'Set __cdecl as a default calling convention'
H0DA21BF93B54: '設定__cdecl為預設調用約定'
# 'Set __fastcall as a default calling convention'
H407DDA0187F9: '設定__fastcall為預設調用約定'
# 'Set __regcall as a default calling convention'
HBA376537ABE7: '設定__regcall為預設調用約定'
# 'Set __regcall4 as a default calling convention to respect __regcall ABI v.4'
H58F2490637FE: '設定__regcall4為預設調用約定以符合__regcall ABI版本 4'
# 'Set __stdcall as a default calling convention'
HE1D6B80E6229: '設定__stdcall為預設調用約定'
# 'Set __vectorcall as a default calling convention'
H37C4705F7696: '設定__vectorcall為預設調用約定'
# 'Set architecture for code generation'
HAC7DFD303E5D: '設定程式碼產生的架構'
# 'Set assembly output file name (with /FA)'
H342E214704DE: '設定組裝輸出檔名（使用 /FA）'
# 'Set build target to arm64ec'
H05FB1FB7BA76: '設定建置目標為 arm64ec'
# 'Set default AMDHSA Code Object Version (module flag or asm directive still take priority if present)'
H146533C17448: '設定預設 AMDHSA 代碼物件版本（模組旗標或組件指令仍優先）'
# "Set default MTE mode to 'sync' (default) or 'async'"
H20B84E4CC1C3: '將預設 MTE 模式設為 "sync"（預設）或 "async"'
# 'Set default calling convention'
HDE29EF09B114: '設定預設呼叫約定'
# 'Set default maximum struct packing alignment'
HB9DF8419AE20: '設定預設最大結構對齊'
# 'Set default maximum struct packing alignment to 1'
H4F682E117F17: '將預設最大結構對齊設為 1'
# 'Set directory to SYSTEM include search path with prefix'
H68EB156B894F: '以指定前綴將目錄加入系統包含路徑搜尋清單'
# 'Set directory to include search path with prefix'
H949A45EF9093: '以指定前綴將目錄加入包含路徑搜尋清單'
# 'Set endian conversion of data for unformatted files'
H5882EA320C88: '設定未格式化檔案資料的字節順序轉換'
# 'Set exception handling model'
HBE5ECEAC70BC: '設定例外處理模型'
# 'Set filename used to determine the language and to find\n.clang-format file.\nOnly used when reading from stdin.\nIf this is not passed, the .clang-format file is searched\nrelative to the current working directory when reading stdin.\nUnrecognized filenames are treated as C++.\nsupported:\n  CSharp: .cs\n  Java: .java\n  JavaScript: .js .mjs .cjs .ts\n  Json: .json\n  Objective-C: .m .mm\n  Proto: .proto .protodevel\n  TableGen: .td\n  TextProto: .txtpb .textpb .pb.txt .textproto .asciipb\n  Verilog: .sv .svh .v .vh'
H76F2B4A51C95: '設定用於確定語言並搜尋.clang-format檔案的檔名。\n當從標準輸入讀取時使用。\n如果未傳遞此參數，.clang-format檔案將根據目前工作目錄搜尋。\n未辨識的檔名會視為C++。\n支援的格式：\n  C#：.cs\n  Java：.java\n  JavaScript：.js .mjs .cjs .ts\n  JSON：.json\n  Objective-C：.m .mm\n  Proto：.proto .protodevel\n  TableGen：.td\n  文字PROTO：.txtpb .textpb .pb.txt .textproto .asciipb\n  Verilog：.sv .svh .v .vh'
# 'Set hexagon hvx loop upper bound align limit'
HE4A380690C61: '設定hexagon hvx迴圈上界對齊限制'
# 'Set hexagon loop align bundle limit'
H16F9FCEB4FD8: '設定hexagon迴圈對齊捆綁限制'
# 'Set hexagon loop align edge threshold'
HB0E799C9958F: '設定hexagon迴圈邊界對齊閾值'
# 'Set hexagon loop lower bound align limit'
H191108F43D31: '設定hexagon迴圈下界對齊限制'
# 'Set hexagon loop upper bound align limit'
HAC06445A5323: '設定hexagon迴圈上界對齊限制'
# 'Set hexagon tiny-core loop align bundle limit'
HC2C9248FD7B4: '設定hexagon tiny-core迴圈對齊捆綁限制'
# 'Set hexagon tiny-core loop upper bound align limit'
HB3D8449C583E: '設定hexagon tiny-core迴圈上界對齊限制'
# 'Set how to use window scheduling algorithm.'
H38DFCE09E411: '設定使用視窗排程演算法的方式。'
# 'Set iOS deployment target'
HF07609B74103: '設定iOS部署目標'
# 'Set inclusive limit count of TLS local-dynamic access(es) in a function to use initial-exec'
H219EA990A3B9: '設定函數中使用initial-exec的TLS local-dynamic存取的包含式限制計數'
# 'Set language version (c++14,c++17,c++20,c++23preview,c++latest,c11,c17)'
H7E89784949AD: '設定語言版本（c++14,c++17,c++20,c++23preview,c++latest,c11,c17）'
# 'Set lazy loading to pretend to import a module'
H618CB094A526: '設定惰性加載以模擬導入模組'
# 'Set level of crash diagnostic reporting, (option: off, compiler, all)'
HCE18F9865CAD: '設定當機診斷報告等級（選項：off, compiler, all）'
# 'Set macOS deployment target'
H19A10025F765: '設定macOS部署目標'
# 'Set max number of processed functions per pass.'
HEC89F562858B: '設定每Pass處理的最大函數數。'
# 'Set maximum number of loads used in expanded memcmp'
HB5230B1550BF: '設定展開memcmp所使用的最大載入數量'
# 'Set maximum number of loads used in expanded memcmp for -Os/Oz'
H8B44477BDB6F: '設定-Os/Oz優化模式下展開memcmp所使用的最大載入數量'
# 'Set maximum offset for global merge pass'
HC56716718D87: '設定全域合併Pass的最大偏移量'
# 'Set maximum runtime in seconds. Defaults to infinite.'
HF2324CC71F76: '設定最大執行時間（秒）。預設為無限。'
# 'Set maximum size of jump tables.'
H8A331A3A6A26: '設定跳轉表的最大大小。'
# 'Set minimum jump tables'
H5B26E9EE289B: '設定最小跳轉表數量'
# 'Set minimum mem intrinsic size to expand in IR'
H0E2DA83065C4: '設定IR中展開內存內置函數的最小尺寸'
# 'Set minimum number of entries to use a jump table on AArch64'
H5D2DDCBDE91E: '設定AArch64使用跳轉表所需的最小條目數'
# 'Set minimum number of entries to use a jump table on PPC'
H695C03675C01: '設定PPC使用跳轉表所需的最小條目數'
# 'Set minimum number of entries to use a jump table on RISCV'
H747561D1A3EA: '設定RISCV使用跳轉表所需的最小條目數'
# 'Set minimum number of entries to use a jump table.'
HB0CDB46F3718: '設定使用跳轉表所需的最小條目數'
# "Set multiple /O flags at once; e.g. '/O2y-' for '/O2 /Oy-'"
HEBA0D85CE2CB: "一次設置多個/O選項；例如 '/O2y-' 代表 '/O2 /Oy-'"
# 'Set output executable file name'
H82C970101BA4: '設定輸出可執行檔名稱'
# 'Set output object file (with /c)'
HBAF5373A221F: '設定輸出物件檔名稱（需與/c一起使用）'
# 'Set page size for slab (requires -slab-allocate and -noexec)'
H674467BA0F71: '設定slab的頁面大小（需配合-slab-allocate和-noexec）'
# 'Set pch file name (with /Yc and /Yu)'
H0833DDB5ABF7: '設定預編譯標頭檔案名稱（與/Yc和/Yu一起使用）'
# 'Set preprocess output file name (with /P)'
H13AACC04AA24: '設定預處理輸出檔名稱（需與/P一起使用）'
# 'Set project title for the coverage report'
HBA2F951324E5: '設定覆蓋報告的專案標題'
# 'Set runtime encoding, supports only UTF-8'
HE66D162F5CCB: '設定執行階段編碼，僅支援UTF-8'
# 'Set slab target address (requires -slab-allocate and -noexec)'
H20F55BE4E6F3: '設定 slab 目標位址（需要 -slab-allocate 和 -noexec）'
# 'Set source and runtime encoding to UTF-8 (default)'
H652EEA8353CA: '將來源和執行階段編碼設置為 UTF-8（預設值）'
# 'Set source encoding, supports only UTF-8'
H3F8729E6E52F: '設定來源編碼，僅支援 UTF-8'
# 'Set stack probe size (default 4096)'
HD0B9F95D20C7: '設定堆疊探測大小（預設值 4096）'
# 'Set tab expansion size for html coverage reports (default = 2)'
H020BCDC65A3D: '設定 HTML 覆蓋報告的 Tab 鎖定擴展大小（預設值 = 2）'
# 'Set target profile'
H5E78CA7AD76D: '設定目標剖析配置文件'
# 'Set the -iwithprefix/-iwithprefixbefore prefix'
HE253558596E6: '設定 -iwithprefix/-iwithprefixbefore 前綴'
# 'Set the Data Stream Control Register.'
H13FF9AB8D2D0: '設定資料流控制寄存器。'
# 'Set the case probability threshold for peeling the case from a switch statement. A value greater than 100 will void this optimization'
H4CFCB81E6294: '設定從 switch 陳述式剝離 case 的機率閾值。大於 100 的值將會使此優化失效'
# 'Set the count value cutoff. Functions with the maximum count less than this value will not be printed out. (Default is 0)'
H314CB3F4FF30: '設定計數值閾值。最大計數小於此值的函數將不會被輸出。（預設值為 0）'
# 'Set the default double precision kind to an 8 byte wide type'
H826E52CBA80A: '將預設雙精度類型設置為 8 字節寬的類型'
# 'Set the default integer and logical kind to an 8 byte wide type'
HBB03F45115A1: '將預設整數和邏輯類型設置為 8 字節寬的類型'
# 'Set the default most-general representation to multiple inheritance'
H4BB3649A0500: '將預設最通用的表示方式設定為多重繼承'
# 'Set the default most-general representation to single inheritance'
HD5A0F69F41ED: '設定預設最通用的表示方式為單一繼承'
# 'Set the default most-general representation to virtual inheritance'
H106974060665: '設定預設最通用的表示方式為虛基類繼承'
# 'Set the default real kind to an 8 byte wide type'
H7B0DABF8B0EB: '設定預設實數類型為 8 字節寬的類型'
# 'Set the default structure layout to be compatible with the Microsoft compiler standard'
H10F147D00248: '設定結構布局與Microsoft編譯器標準相容'
# 'Set the default symbol visibility for all global definitions'
HFCD98D3F8272: '設定所有全域定義的預設符號可見性'
# 'Set the deployment target to be the specified OS and OS version'
H814D918A5F74: '設定部署目標為指定的作業系統及其版本'
# 'Set the device id.'
H4C967743D4CC: '設定裝置ID。'
# "Set the driver mode to either 'gcc', 'g++', 'cpp', 'cl' or 'flang'"
HD0838A0BABB3: "設定驅動程式模式為 'gcc'、'g++'、'cpp'、'cl' 或 'flang'"
# 'Set the kind of module destructors emitted by AddressSanitizer instrumentation. These destructors are emitted to unregister instrumented global variables when code is unloaded (e.g. via `dlclose()`).'
H83083E1D2A16: '設定AddressSanitizer插樁所發出的模組析構函式的類型。這些析構函式用於在代碼被卸載時（例如透過`dlclose()`）取消註冊被插樁的全域變數。'
# 'Set the loop counter bitwidth'
H9F5F138BD1EC: '設定迴圈計數器位寬'
# 'Set the loop decrement value'
H5680DA5C48FB: '設定迴圈遞減值'
# 'Set the lower bound of a trip count to decide on vectorization while tail-folding.'
H098C7B4E7AF1: '設定在尾部摺疊向量化時用以判斷迭代次數下界的值。'
# 'Set the max unroll count for full unrolling, for testing purposes'
HF7A0139ED19B: '為測試目的設定全展開的最⼤展開次數'
# 'Set the max unroll count for partial and runtime unrolling, fortesting purposes'
H9B56B49168A1: '設定部分展開和執行階段展開的最大展開次數（僅供測試用途）'
# 'Set the maximum bitwidth for _BitInt (this option is expected to be removed in the future)'
HA5D88B68C72D: '設定_BitInt的最大位元寬度（此選項預計未來將移除）'
# 'Set the maximum depth of recursive constexpr function calls'
HBB90EC0111F9: '設定遞迴constexpr函數呼叫的最大深度'
# 'Set the maximum depth of recursive template instantiation'
H80FAEB4CB009: '設定遞迴模板實體化調用的最大深度'
# 'Set the maximum number of clang-format errors to emit\nbefore stopping (0 = no limit).\nUsed only with --dry-run or -n'
HCC14B05C0F0B: '設定clang-format錯誤訊息的最大顯示數量（達限後停止）（0=無限）。\n僅與--dry-run或-n選項一起使用'
# 'Set the maximum number of entries to print in a constexpr evaluation backtrace (0 = no limit)'
H894E58266D5D: '設定在constexpr評估回溯中顯示條目的最大數量（0=無限）'
# 'Set the maximum number of entries to print in a macro expansion backtrace (0 = no limit)'
H41EB48896694: '設定在宏展開回溯中顯示條目的最大數量（0=無限）'
# 'Set the maximum number of entries to print in a template instantiation backtrace (0 = no limit)'
H0B1001101AD7: '設定在模板實體化回溯中顯示條目的最大數量（0=無限）'
# 'Set the maximum number of errors to emit before stopping (0 = no limit).'
H4B9FB4A77BFC: '設定在停止前要顯示的錯誤訊息最大數量（0=無限）'
# 'Set the maximum number of outgoing blocks for using a boolean value to record the exiting block in the ControlFlowHub.'
H72D58573A0FE: '設定ControlFlowHub中使用布林值記錄退出區塊時的最大輸出區塊數量'
# 'Set the maximum number of source lines to show in a caret diagnostic (0 = no limit).'
H501810E09B46: '設定在-caret診斷中顯示來源程式碼行數的最大數量（0=無限）'
# 'Set the maximum number of steps in constexpr function evaluation'
H220ED2A089D9: '設定constexpr函數評估中的最大步數'
# 'Set the maximum number of times to perform spell checking on unrecognized identifiers (0 = no limit)'
HAFFC709D0C08: '設定對未識別識別符進行拼字檢查的最大次數（0=無限）'
# 'Set the maximum path length when checking whether a basic block is followed by a block that either has a terminating deoptimizing call or is terminated with an unreachable'
H332DCFF60584: '設定在檢查基本區塊是否被跟隨一個區塊（該區塊或包含終止的去優化呼叫，或以無法達成狀態終止）時的最大路徑長度'
# 'Set the minimum number of repetitions of a divisor to allow transformation to multiplications by the reciprocal'
HC1FEBC49F8C7: '設定允許將除數轉換為倒數乘法所需的最小重複次數'
# 'Set the mode for address space map based mangling; OpenCL testing purposes only'
HD09BAE7AD91C: '設定基於位址空間地圖的符號修飾模式；僅供OpenCL測試使用'
# 'Set the number of scavenger slots'
H180660FD5B55: '設定清除槽位數量'
# 'Set the number of teams.'
H7688CE2C3ADF: '設定團隊數量'
# 'Set the number of threads.'
H6EBBEB07E8B0: '設定執行緒數量'
# 'Set the out-of-process executor'
HAF02B074B342: '設定外部處理執行器'
# 'Set the output <file> for debug infos'
HA5E541919277: '設定調適資訊的輸出 <file>'
# 'Set the p2align operands for WebAssembly loads and stores'
H7736F9C56939: '設定WebAssembly載入和儲存的p2align操作數'
# 'Set the parallelization strategy'
HF0A794612D46: '設定並行化策略'
# "Set the profile instrumentation burst duration, which can range from 1 to the value of 'sampled-instr-period' (0 is invalid). This number of samples will be recorded for each 'sampled-instr-period' count update. Setting to 1 enables simple sampling, in which case it is recommended to set 'sampled-instr-period' to a prime number."
H5CA10C80C24A: "設定配置文件插樁的突发持續時間，其範圍從 1 到 'sampled-instr-period' 的值（0無效）。每個 'sampled-instr-period' 計數更新將記錄此數量的樣本。設置為 1 可啟用簡易採樣，此時建議將 'sampled-instr-period' 設置為質數。"
# "Set the profile instrumentation sample period. A sample period of 0 is invalid. For each sample period, a fixed number of consecutive samples will be recorded. The number is controlled by 'sampled-instr-burst-duration' flag. The default sample period of 65536 is optimized for generating efficient code that leverages unsigned short integer wrapping in overflow, but this is disabled under simple sampling (burst duration = 1)."
HC029DE20A3E1: "設定配置文件插樸的採樣週期。0的採樣週期無效。每個採樣週期將記錄固定數量的連續樣本。此數量由 'sampled-instr-burst-duration' 旗標控制。預設的 65536 採樣週期經過最佳化，可生成有效使用無符號短整數溢位的程式碼，但在簡易採樣（burst duration=1）時此功能被禁用。"
# "Set the rsp quoting to either 'posix', or 'windows'"
HFF7A11383873: "設定rsp引號格式為 'posix' 或 'windows'"
# 'Set the stack alignment'
HAAE3F7EC9ADE: '設定堆疊對齊方式'
# 'Set the stack probe size'
H188751A74B18: '設定堆疊探測大小'
# 'Set the system root directory (usually /)'
H9329C47A6507: '設定系統根目錄（通常為 /）'
# 'Set the tab stop distance.'
HC9DBC229821F: '設定制表符間距。'
# 'Set the target triple'
H886553395ADD: '設定目標三元組'
# 'Set the threshold for pgo-verify-bfi:  only print out mismatched BFI if the difference percentage is greater than this value (in percentage).'
H467C6DAEB903: '設定 pgo-verify-bfi 的閾值：僅當差異百分比大於此值時才列印不匹配的 BFI（以百分比為單位）。'
# 'Set the threshold for pgo-verify-bfi: skip the counts whose profile count value is below.'
HCF37C352FCE6: '設定 pgo-verify-bfi 的閾值：跳過剖析計數值低於此閾值的計數。'
# 'Set the unroll peeling count, for testing purposes'
H00413175E081: '設定展開剝皮次數（僅供測試使用）'
# 'Set the z/OS release of the runtime environment'
HD212DAE31048: '設定執行階段環境的 z/OS 版本'
# 'Set up preprocessor for static analyzer (done automatically when static analyzer is run).'
HE7E0E6B1AE87: '設定靜態分析器的預處理器（在執行靜態分析器時會自動完成）'
# 'Set update method of profile counters'
HA14B65C6D0B2: '設定剖析計數器的更新方法'
# 'Set upper limit for the number of transformations performed during a single round of hoisting the reassociated expressions.'
HC739332F82AA: '設定在單次提升重新關聯運算式時的轉換次數上限'
# 'Set wave priority'
HBB7FE34C07C2: '設定 wave 優先順序'
# 'Set width of the columns showing resource booking.'
HC849BD248519: '設定顯示資源預訂的欄位寬度'
# 'Set width of the columns with the resources and schedule units'
H67C4E5790866: '設定包含資源和排程單位的欄位寬度'
# 'Sets the ASan constructor kind'
H7243B87BA43D: '設定 ASan 建構函數類型'
# 'Sets the ASan destructor kind. The default is to use the value provided to the pass constructor'
H3151987CC244: '設定 ASan 析構函數類型。預設會使用傳遞給 pass 建構函數的值'
# 'Sets the IEEE bit in the expected default floating point  mode register. Floating point opcodes that support exception flag gathering quiet and propagate signaling NaN inputs per IEEE 754-2008. This option changes the ABI. (AMDGPU only)'
H40BE9F55402A: '設定預設浮點運算模式寄存器的 IEEE 位元。支援例外標記收集，根據 IEEE 754-2008 標準對無號 NaN 和信號 NaN 輸入進行例外旗標收集的浮點指令。此選項會改變 ABI。(僅 AMDGPU)'
# 'Sets the SIMD width. Zero is autoselect.'
HA8F45CFC1E01: '設定 SIMD 寬度。零表示自動選擇。'
# 'Sets the bias which adds weight to occupancy vs latency. Set it to 100 to chase the occupancy only.'
HDE531962A442: '設定偏向佔用率而非延遲的偏差。設為 100 則僅追蹤佔用率。'
# 'Sets the cost threshold for when multiple conditionals will be merged into one branch versus be split in multiple branches. Merging conditionals saves branches at the cost of additional instructions. This value sets the instruction cost limit, below which conditionals will be merged, and above which conditionals will be split. Set to -1 to never merge branches.'
H908B80F5C5DD: '設定多個條件式合併為單一分支或分離為多分支的指令成本閾值。合併條件式會減少分支數量，但會增加額外指令。此值設定指令成本上限，低於此閾值時條件式將被合併，高於此閾值時則被分離。設為 -1 表示永不進行分支合併。'
# 'Sets the default matrix layout'
HB552288B1A94: '設定預設矩陣布局'
# 'Sets the maximum allowed output size (0 means no limit) [ELF only]'
H7FE764745013: '設定最大允許的輸出大小（0 表示無限制）[僅 ELF]'
# 'Sets the minimum function size to instrument with XRay'
HF47DF90C1776: '設定使用 XRay 插樁的最小函數大小'
# 'Sets the mode of detection for stack-use-after-return.'
H3FEDDC9474EF: '設定堆疊使用後返回的檢測模式。'
# 'Sets the preferable loop alignment for experiments (as log2 bytes) for innermost loops only. If specified, this option overrides alignment set by x86-experimental-pref-loop-alignment.'
H0A768F10FB45: '設定內層循環實驗性預設的循環對齊（以 log2 字節為單位）。若指定，此選項將覆寫由 x86-experimental-pref-loop-alignment 設定的對齊值。'
# 'Sets the vectorization interleave count. Zero is autoselect.'
H0275ABE673BB: '設定向量化交織計數。零表示自動選擇。'
# 'Sets various macros to claim compatibility with the given GCC version (default is 4.2.1)'
HF256B239FB01: '設定宏以聲稱與指定 GCC 版本的相容性（預設為 4.2.1）'
# 'Shadow Stack GC Lowering'
H04B76D4FEDB5: 'Shadow Stack GC 降低處理'
# 'Should __STATIC__ be defined'
H46691D14FB8F: '是否定義 __STATIC__'
# 'Should a closed world be assumed, or not. Default if not set.'
H5AB58A4464B6: '是否假設封閉世界環境。未設置時採用預設值。'
# 'Should enable CSE in Legalizer'
H77887DE8DF92: '是否在 Legalizer 中啟用 CSE'
# 'Should enable CSE in irtranslator'
H91C4D8FE802C: '是否在 irtranslator 中啟用 CSE'
# 'Should mir-strip-debug only strip debug info from debugified modules by default'
H3DC291F161A1: '是否僅從已調試化的模組中剔除除錯資訊（預設行為）'
# 'Should we attempt to sink negations?'
HA914A0DB2603: '是否嘗試下沈否定操作？'
# 'Show FailedToMaterialize errors'
HE9058727A1A0: '顯示 FailedToMaterialize 錯誤'
# 'Show MCDC statistics in summary table'
HC702D8A97A6E: '在摘要表中顯示 MCDC 統計資料'
# 'Show True/False counts'
HFE8C8190B143: '顯示 True/False 數量'
# 'Show True/False percent'
H07C8D556E1B3: '顯示 True/False 比例'
# 'Show binary counters (1/0) in lines and branches instead of integer execution counts'
HB45D3670503F: '在程式碼行和分支中顯示二進位計數器（1/0）而非整數執行次數'
# 'Show binary ids in the profile. '
HB609CBDF46B1: '在剖析中顯示二進位識別碼。 '
# 'Show bindings of tools to actions'
H25DE8385EB09: '顯示工具與動作的綁定關係'
# 'Show branch condition statistics in summary table'
H231A08B7A99F: '在摘要表格中顯示分支條件統計數據'
# 'Show call-multigraph (do not remove parallel edges)'
HCC8B57A6B12A: '顯示呼叫多重圖（不移除平行邊）'
# 'Show code coverage only for functions listed in the given file'
H0D504442CF50: '僅顯示指定檔案中列出函數的程式碼覆蓋率'
# 'Show code coverage only for functions that match the given regular expression'
H6E2F7500DDDA: '僅顯示與指定正則表達式匹配函數的程式碼覆蓋率'
# 'Show code coverage only for functions with line coverage greater than the given threshold'
H6945238A4869: '僅顯示程式行覆蓋率大於指定閾值函數的程式碼覆蓋率'
# 'Show code coverage only for functions with line coverage less than the given threshold'
H1A772B15E654: '僅顯示程式行覆蓋率小於指定閾值函數的程式碼覆蓋率'
# 'Show code coverage only for functions with region coverage greater than the given threshold'
HF06D994C900A: '僅顯示程式區塊覆蓋率大於指定閾值函數的程式碼覆蓋率'
# 'Show code coverage only for functions with region coverage less than the given threshold'
H4FA285578577: '僅顯示程式區塊覆蓋率小於指定閾值函數的程式碼覆蓋率'
# 'Show code coverage only for functions with the given name'
H9786810746F0: '僅顯示指定名稱函數的程式碼覆蓋率'
# 'Show commands to run and use verbose output'
HE1D432762909: '顯示執行命令並使用詳細輸出'
# 'Show context sensitive counts'
HE2280C2DDA17: '顯示與上下文相關的計數'
# 'Show counter values for shown functions'
H129F56F5FD53: '顯示顯示函數的計數器值'
# 'Show coverage for branch conditions'
HC96F564B6A82: '顯示分支條件的程式碼覆蓋率'
# 'Show coverage for each function'
H3CCABA0A8100: '顯示每個函數的程式碼覆蓋率'
# 'Show coverage summaries for each function'
HBAF14E467A0F: '顯示每個函數的覆蓋率摘要'
# 'Show created time for each page.'
H321E973C4182: '顯示每個頁面的建立時間。'
# 'Show detailed profile summary'
HEDDF2BF2C691: '顯示詳細的剖析摘要'
# 'Show detailed warning message.'
H9E7102D900DA: '顯示詳細的警告訊息。'
# 'Show details of invoking getNextResoufceCycle.'
HA4F0023B8FF3: '顯示調用getNextResoufceCycle的詳細資訊。'
# 'Show directory coverage'
H83933D919BBD: '顯示目錄覆蓋範圍'
# 'Show edges labeled with weights'
H376FB60A851E: '顯示標有權重的邊'
# 'Show encoding in .s output'
HB528C74F2189: '顯示.s輸出中的編碼方式'
# 'Show expanded source regions'
H387D478FCAFF: '顯示展開的源代碼區域'
# 'Show function instantiations'
HCFC0922F8DE2: '顯示函數實體化'
# 'Show header includes and nesting depth'
HFC379692A313: '顯示頭文件包含及嵌套深度'
# 'Show heat colors in CFG'
HF38DE9931AB9: '顯示控制流圖（CFG）中的熱度顏色'
# 'Show heat colors in call-graph'
HDDDF3F1C338F: '顯示呼叫圖中的熱度顏色'
# 'Show indirect call site target values for shown functions'
H4D99B80D7C36: '顯示已顯示函數中間接呼叫位置的目標值'
# 'Show instantiation statistics in summary table'
HAD4D78E39FA9: '在總結表格中顯示實體化統計資訊'
# 'Show instr profile data in text dump format'
HE77B1EB739B5: '以文本轉存格式顯示插樁剖面資料'
# 'Show instruction encoding information in transliterate mode'
H15214D90288C: '在轉寫模式下顯示指令編碼資訊'
# 'Show instruction encodings'
H76A361C43AC1: '顯示指令編碼'
# 'Show instructions operands as parsed'
HE4EAD3961196: '顯示按解析結果顯示的指令操作數'
# 'Show internal debug dump'
H79FC9F317159: '顯示內部除錯轉存'
# 'Show internal instruction representation'
H969E08C4B063: '顯示內部指令表示方式'
# 'Show internal instruction representation in transliterate mode'
HCF07E4857D2B: '在轉寫模式下顯示內部指令表示方式'
# 'Show lexical and class parents'
H2CD760A9C080: '顯示詞法和類別父項'
# 'Show line numbers in diagnostic code snippets'
H08938EFDB15B: '在診斷代碼片段中顯示行號'
# 'Show only simple regions in the graphviz viewer'
H09E6F5F4BBB1: '僅在graphviz檢視器中顯示簡單區域'
# 'Show only the configs matching this regex'
H2BD050A28852: '僅顯示與此正規表示式相符的設定'
# 'Show only the functions that have been executed.'
HD6154133C806: '僅顯示已被執行的函數。'
# 'Show profile summary of a list of hot functions'
H0361C5298777: '顯示熱函數清單的剖析摘要'
# 'Show profile symbol list if it exists in the profile. '
HC84B87BCF81B: '若剖析中存在符號清單，則顯示之。 '
# 'Show profile version. '
HD8D6C82AA426: '顯示剖析版本。 '
# 'Show region statistics in summary table'
H3D65F3DC6E98: '在摘要表中顯示區域統計資料'
# 'Show sample profile data in the JSON format (deprecated, please use --show-format=json)'
H828A9B7D7ACC: '以JSON格式顯示樣本剖析資料（已棄用，請改用--show-format=json）'
# 'Show skipped includes in -H output.'
H2CB52D019FEC: '在-H輸出中顯示被跳過的包含頭文件。'
# 'Show temporal profile traces in the profile.'
H72096941B959: '在剖析中顯示時序剖析痕跡。'
# 'Show the MCDC Coverage for each applicable boolean expression'
HD1B4BD4AF9D7: '顯示每個適用布林運算式的MCDC覆蓋率'
# 'Show the Polly CFG right after code generation'
H029F6C967468: '在代碼生成後立即顯示Polly控制流圖'
# 'Show the collected coverage object files'
H31D89D92BF30: '顯示已收集的覆蓋物件檔'
# 'Show the collected paths to source files'
H26A34004C8C4: '顯示已收集的原始檔路徑'
# 'Show the execution counts for each line'
HBDA134A1E3B8: '顯示每行的執行次數'
# 'Show the execution counts for each line, or the execution counts for each region on lines that have multiple regions'
H9AF77074F9BE: '顯示每行的執行次數，或對具有多個區域的行顯示各區域的執行次數'
# 'Show the execution counts for each region'
HE82C34C08B90: '顯示各區域的執行次數'
# 'Show the information of each section in the sample profile. The flag is only usable when the sample profile is in extbinary format'
HF5346C9B396B: '顯示樣本剖析中各段落的資訊。此選項僅在樣本剖析為extbinary格式時可用'
# 'Show the list of functions with the largest internal counts'
HDB413363F895: '顯示內部計數最大的函數清單'
# 'Show the profiled sizes of the memory intrinsic calls for shown functions'
HEACDF1B2720A: '顯示已顯示函數中記憶體內建函數調用的剖析大小'
# 'Show the sizes of all debug sections, expressed in bytes.'
H78A0DAA47053: '顯示所有調試區段的大小，以位元組為單位。'
# 'Show the sources across all compilation units.'
H9382C23DCF90: '顯示所有編譯單元中的原始程式碼。'
# 'Show times for llvm-jitlink phases'
HD3302520BB6D: '顯示llvm-jitlink各階段的時間'
# 'Show times for llvm-rtdyld phases'
HB7BC3C6A17C2: '顯示llvm-rtdyld各階段的時間'
# 'Show verbose output when opt-bisect-limit is set'
H8536EE8B8C8C: '當設置opt-bisect-limit時顯示詳細輸出'
# 'Show vtable names for shown functions'
H79407841F063: '顯示已顯示函數的虛函數表名稱'
# 'Shrink Wrap Pass'
HE4743C131F02: 'Shrink Wrap Pass'
# 'Shuffle machine instructions alternating directions'
H3D7E0E8AF77B: '混排機器指令並交替方向'
# 'Silence ObjC rewriting warnings'
HDDBF5BEB68D8: '靜默ObjC重寫警告'
# 'Similar completion items (e.g. function overloads) are combined. Type information shown where possible'
H1DEA188ACC34: '相似的補齊項目（例如函數重載）會被合併。盡可能顯示類型資訊'
# 'Similar to -ftime-trace. Specify the JSON file or a directory which will contain the JSON file'
H53211B2FCAB2: '類似於-ftimetrace。指定JSON文件或將包含JSON文件的目錄'
# 'Similar to data-and-control, but remove the runtime check'
HDAE5253998D0: '類似於data-and-control，但移除執行階段檢查'
# 'Similar to list-burr but schedules in source order when possible'
H322EBF2ED613: '類似於list-burr，但在可能的情況下按原始程式碼順序排程'
# 'Simple speculation'
H736302864F3E: '簡單預測'
# 'Simplify DDG by merging nodes that have less interesting edges.'
H140319D98680: '通過合併具有較少重要邊的節點來簡化DDG。'
# 'Simplify SCoP after optimizations'
H9435BBE6A7ED: '優化後簡化SCoP'
# 'Simplify the CFG'
H3F01631183F4: '簡化控制流圖'
# 'Simplify the CFG after atomic expansion pass'
H4B39E0A8393B: '在atomic expansion pass後簡化控制流圖'
# 'Simply drop type test sequences'
H6F563FE46789: '直接刪除類型測試序列'
# 'Simulate installation in the given directory'
H2E8832D0BC0E: '模擬在指定的目錄中安裝'
# 'Single thread model'
H0A1A3414EA60: '單執行緒模型'
# 'Sink common instructions (default = false)'
H458310DD7CCF: '沉積常見指令（預設 = false）'
# 'Sink common instructions down to the end block'
HB6833655C393: '將常見指令沉至終端區塊'
# 'Sink instructions into cycles to avoid register spills'
HA19B07EB7A73: '將指令沉入循環以避免寄存器溢出'
# 'Size limit for the MII.'
HFE4E64539F6A: 'MII 的大小限制。'
# 'Size limit in Hexagon early if-conversion'
HEE45F9DDA387: 'Hexagon 預處理 if-conversion 的大小限制'
# 'Size of the expression which is considered huge'
H4AAD9C3152F7: '視為龐大的運算式大小'
# 'Size of the load queue'
H51731E4081C2: '載入佇列的大小'
# 'Size of the store queue'
H7CD5021D4D3E: '儲存佇列的大小'
# 'Size-specialize memcmp and bcmp calls'
H4D487410E126: '對指定大小的 memcmp 和 bcmp 呼叫進行專門化'
# 'SjLj exception handling'
HA2DEA63BE575: 'SjLj 例外處理'
# 'Skip 64-bit divide for dynamic 32-bit values'
HBC981EB66354: '跳過對動態 32 位元值的 64 位元除法'
# 'Skip Callsite up to this number for this compilation'
HD2D3E00B6C18: '在此編譯中跳過至多此數量的Callsite'
# 'Skip Cost Analysis'
HEBC9E235FCC3: '跳過成本分析'
# 'Skip ODR checks for decls in the global module fragment.'
H3261F074F5AE: '跳過全域模組片段中宣告的ODR檢查'
# 'Skip checks for relocated modules when loading PCM files'
HD81AE42FB9F0: '跳過載入PCM檔案時重新定位模組的檢查'
# "Skip emitting basic block entries in the SHT_LLVM_BB_ADDR_MAP section. It's used to save binary size when BB entries are unnecessary for some PGOAnalysisMap features."
H71707934B534: '跳過在SHT_LLVM_BB_ADDR_MAP區段中發射基本區塊的入口。它用來在某些PGOAnalysisMap功能不需要基本區塊入口時節省二進位大小。'
# 'Skip function bodies when possible'
HC6384E72882E: '當可能時跳過函數主體'
# 'Skip instructions on input which lack scheduling information'
H0CA4A6B1674E: '跳過輸入中缺乏排程資訊的指令'
# 'Skip instructions or lines on input which are unsupported for any reason'
H66EA3C6B0D85: '跳過輸入中因任何原因不受支援的指令或行'
# 'Skip lines on the input which fail to parse for any reason'
HF1FE9D6E74D2: '跳過輸入中因任何原因無法解析的行'
# 'Skip merging empty blocks if (frequency of empty block) / (frequency of destination block) is greater than this ratio'
HD3ACA543F291: '若（空區塊的頻率）/（目標區塊的頻率）大於此比例，則跳過合併空區塊'
# 'Skip merging functions with no parameters.'
H4C33F6695ED3: '跳過合併無參數的函數。'
# 'Skip op verification when using custom printers'
HE99716DCF0A6: '使用自訂列印器時跳過操作驗證'
# 'Skip pass list reduction steps'
H94E9DA2F7021: '跳過 pass 清單的縮減步驟'
# 'Skip printing info about analyses'
H89B96A0AA8C3: '跳過列印分析的相關資訊'
# 'Skip regions when printing ops.'
HE9909BB5AB83: '列印操作時跳過區域'
# 'Skip relative hotness check for ICP up to given number of targets.'
H1CF24D29FE78: '跳過ICP對給定目標數量以內的相對熱度檢查'
# 'Skip setting up RAX register when passing variable arguments (x86 only)'
H88536767AEC5: '傳遞可變參數時跳過設定RAX寄存器（僅限x86）'
# 'Skip source code files with file paths that match the given regular expression'
HF5248544A184: '跳過符合指定正則表達式的來源程式碼路徑對應的檔案'
# 'Skip the check if the number of hot functions is smaller than the specified number.'
HC72D43FB0410: '若熱函數的數量小於指定數量，則跳過檢查'
# 'Skip the dependency check for pragma-based transformations'
H9266BB52380C: '跳過基於pragma的轉換的依賴性檢查'
# 'Slot index numbering'
H25CDF44B807D: '插槽索引編號'
# 'Small code model'
HDBB10FAFE07D: '小型程式碼模型'
# 'Small data and bss section threshold size (default=0)'
HCE054C60032A: '小型資料和BSS段閾值大小（預設=0）'
# 'Small data and bss section threshold size (default=8)'
HD23849593CCC: '小型資料和BSS段閾值大小（預設=8）'
# 'Soft float ABI (implied by -soft-float)'
HC0C86A6BE8AC: '軟體浮點ABI（由-soft-float隱含指定）'
# 'Sort by element kind.'
H873DE05DDF9E: '依元素類型排序'
# 'Sort by element line number.'
HE0D755567860: '依元素行號排序'
# 'Sort by element name.'
H0C2C0BB04670: '按元素名稱排序。'
# 'Sort by element offset.'
HAEFFB6AFF193: '按元素偏移量排序。'
# 'Sort classes by amount of immediate padding'
HC0D1B98A168E: '按類別中立即填充的數量排序'
# 'Sort classes by amount of padding'
H6740525F2A73: '按類別中填充的數量排序'
# 'Sort classes by name'
H525546C671ED: '按類別名稱排序'
# 'Sort classes by percentage of space consumed by immediate padding'
H807712AAABEC: '按類別中所佔空間中立即填充的百分比排序'
# 'Sort classes by percentage of space consumed by padding'
H2970C3CE6488: '按類別中所佔空間中填充的百分比排序'
# 'Sort classes by size'
H4175309835B2: '按類別大小排序'
# 'Sort profiled recursion by edge weights.'
HDC0AFFCFAE60: '根據邊權重對剖面過的遞迴進行排序'
# 'Sort symbols by name'
HEF9C9A551533: '按符號名稱排序'
# 'Sort symbols by size'
H194BBF71E1B6: '按符號大小排序'
# 'Sort the resources printed in the dump trace'
H66B4BBE5718F: '排序並重新排列轉存追蹤中印出的資源'
# 'Sorts and reorders operands in commutative instructions'
H74BB35674C4A: '對可交換指令中的操作數進行排序和重新排列'
# 'Source Code Analysis - Dead Symbol Removal Frequency'
H658C75F7C985: '源代碼分析 - 未引用符號移除頻率'
# 'Source Code Analysis - Output Options'
H418F37A89230: '源代碼分析 - 輸出選項'
# 'Source Code Analysis - Symbolic Constraint Engines'
HD8341B8B44B5: '源代碼分析 - 符號約束引擎'
# 'Source prefix to elide'
HF556E14613B2: '要省略的來源前綴'
# "Source-level compatibility for Altivec vectors (for PowerPC targets). This includes results of vector comparison (scalar for 'xl', vector for 'gcc') as well as behavior when initializing with a scalar (splatting for 'xl', element zero only for 'gcc'). For 'mixed', the compatibility is as 'gcc' for 'vector bool/vector pixel' and as 'xl' for other types. Current default is 'mixed'."
HCF923B012626: '源代碼層級的Altivec向量兼容性（針對PowerPC目標）。這包括向量比較的結果（xl為標量、gcc為向量）以及用純量初始化時的行為（xl進行展開、gcc僅保留第一個元素）。設定mixed時，vector bool/vector pixel類型採用gcc兼容性，而其他類型則使用xl。目前預設為mixed。'
# 'SourceLocation in file %0 at offset %1 is invalid'
H2A6519004798: '文件 %0 中偏移量 %1 的來源位置無效'
# 'Spawn a separate process for each cc1'
H4079AEA987DF: '為每個cc1啟動獨立的處理程序'
# 'Spawns a subprocess for each snippet execution, allows for the use of memory annotations'
HB0B29965076D: '為每個程式碼片段執行啟動子程序，允許使用記憶體註解'
# 'Specifies PowerPC native vector element order (default)'
HE6ABC638069C: '指定PowerPC本機向量元素順序（預設值）'
# 'Specifies PowerPC non-native vector element order'
H1D9287995DAC: '指定PowerPC非本機向量元素順序'
# 'Specifies a list of variables to be exempt from the TOC data transformation.'
HAF01AE884575: '指定一組不受TOC資料轉換影響的變數。'
# 'Specifies a list of variables to which the TOC data transformation will be applied.'
H33958769FAEF: '指定一組要應用TOC資料轉換的變數。'
# "Specifies preferred vector width for auto-vectorization. Defaults to 'none' which allows target specific decisions."
H30D4DB622AB0: "指定自動向量化時的偏好向量寬度。預設值為 'none'，允許目標平台自行決定。"
# 'Specifies that the sample profile is accurate'
H3A3F53CE7955: '指定剖面樣本是準確的'
# 'Specifies the JITDylib to be used for any subsequent -extra-module arguments.'
HFDCED35F4977: '指定用於後續 -extra-module 參數的JITDylib。'
# 'Specifies the JITDylib to be used for any subsequent input file, -L<seacrh-path>, and -l<library> arguments'
H72683DE0AF39: '指定用於後續輸入檔、-L<搜尋路徑> 和 -l<函式庫> 參數的JITDylib。'
# "Specifies the debug info's compilation dir"
H64EB79AAF220: '指定除錯資訊的編譯目錄'
# 'Specifies the evaluation method to use for floating-point arithmetic.'
HB1694AF39E4A: '指定用於浮點運算的評估方法。'
# 'Specifies the exception behavior of floating-point operations.'
HF7A17A05FFEE: '指定浮點運算的例外處理行為。'
# "Specifies the largest alignment guaranteed by '::operator new(size_t)'"
H7C74E7BEFD7B: '指定 ::operator new(size_t) 所保證的最大對齊值'
# 'Specifies the name we should consider the input file'
H048BF6366B06: '指定我們應視為輸入檔名稱的名稱'
# 'Specifies the size of batches for processing CUs. Higher number has better performance, but more memory usage. Default value is 1.'
HE1BE8B43F7F0: '指定處理CU時的批次大小。數值越大，效能越好，但記憶體使用量越高。預設值為 1。'
# 'Specify "safe" i.e. known-good backend:'
H8A9DA72ACD37: '指定「安全」（即已知良好）的後端：'
# 'Specify <function, basic block1[;basic block2...]> pairs to extract.\nEach pair will create a function.\nIf multiple basic blocks are specified in one pair,\nthe first block in the sequence should dominate the rest.\neg:\n  --bb=f:bb1;bb2 will extract one function with both bb1 and bb2;\n  --bb=f:bb1 --bb=f:bb2 will extract two functions, one with bb1, one with bb2.'
H849E2CD57584: '指定要提取的 <函式, 基本區塊 1[;基本區塊 2...]> 結對。\n每對會建立一個函式。\n若一對中指定多個基本區塊，\n該序列中的第一個區塊應支配其餘區塊。\n例如：\n  --bb=f:bb1;bb2 將提取一個包含bb1和bb2的函式；\n  --bb=f:bb1 --bb=f:bb2 將提取兩個函式，一個有bb1，另一個有bb2。'
# 'Specify <script> as linker script'
HE790F52CC3F0: '指定 <腳本> 為連結腳本'
# 'Specify CU wavefront execution mode (AMDGPU only)'
H0AC391ACF1B8: '指定CU wavefront執行模式（僅限AMDGPU）'
# 'Specify O2(not Os) spill func threshold'
HEC690666E75E: '指定O2（非Os）的spill函式閾值'
# 'Specify Os spill func threshold'
H2796D0A3FC8E: '指定Os溢出函數閾值'
# 'Specify WGP wavefront execution mode (AMDGPU only)'
H1A9B58D9172E: '指定WGP wavefront執行模式（僅AMDGPU）'
# 'Specify a SamplePGO profile file'
H5B1BF8C410B3: '指定SamplePGO剖析檔檔案'
# 'Specify a context sensitive PGO profile file'
H6CD3C27C7374: '指定具有上下文敏感性的PGO剖析檔檔案'
# "Specify a default target triple when it's not available in the module"
H8905580ACB2D: '當模組中未提供目標三元組時指定預設目標三元組'
# "Specify a directory where Clang can find 'include' and 'lib{,32,64}/gcc{,-cross}/$triple/$version'. Clang will use the GCC installation with the largest version"
H5F9EC5F91118: '指定Clang搜尋「include」和「lib{,32,64}/gcc{,-cross}/$triple/$version」的目錄。Clang會選擇版本最大的GCC安裝'
# "Specify a directory where Flang can find 'lib{,32,64}/gcc{,-cross}/$triple/$version'. Flang will use the GCC installation with the largest version"
H59AA0290DBA6: '指定Flang搜尋「lib{,32,64}/gcc{,-cross}/$triple/$version」的目錄。Flang會選擇版本最大的GCC安裝'
# 'Specify a plugin to optimize LFENCE insertion'
H749CB0E11874: '指定用於優化LFENCE插入的插件'
# 'Specify a reference program output (for miscompilation detection)'
H7D6525B849BF: '指定參考程式輸出（用於編譯錯誤偵測）'
# 'Specify a symbol resolution: filename,symbolname,resolution\nwhere "resolution" is a sequence (which may be empty) of the\nfollowing characters:\n p - prevailing: the linker has chosen this definition of the\n     symbol\n l - local: the definition of this symbol is unpreemptable at\n     runtime and is known to be in this linkage unit\n x - externally visible: the definition of this symbol is\n     visible outside of the LTO unit\nA resolution for each symbol must be specified'
HFA08A87A55A4: '指定符號解析方式：檔名,符號名稱,解析結果\n其中「解析結果」是下列字元的序列（可能為空）：\n p - 優先：連結器選擇此符號定義\n l - 本地：此符號的定義在執行階段不可取代且位於當前連結單元\n x - 外部可見：此符號的定義在LTO單元外可見\n每個符號都必須指定解析結果'
# 'Specify alias to extract'
H4D5920CD11AC: '指定要提取的別名'
# 'Specify alias(es) to extract using a regular expression'
H5A885E78EEAE: '使用正規表示式指定要提取的別名（可指定多個）'
# "Specify an offloading device architecture for CUDA, HIP, or OpenMP. (e.g. sm_35). If 'native' is used the compiler will detect locally installed architectures. For HIP offloading, the device architecture can be followed by target ID features delimited by a colon (e.g. gfx908:xnack+:sramecc-). May be specified more than once."
H03D163E89A58: '指定CUDA、HIP或OpenMP的卸載裝置架構（如sm_35）。若使用「native」，編譯器將偵測本機安裝的架構。對HIP卸載而言，裝置架構後可追加以冒號分隔的目標ID特徵（如gfx908:xnack+:sramecc-）。此選項可重複指定。'
# 'Specify an output filename for an HTML report. This describes both recommendations and reasons for changes.'
H8B1F64A00015: '指定HTML報告的輸出檔名。此報告將描述變更建議及原因'
# 'Specify bit size of immediate TLS offsets (AArch64 ELF only): 12 (for 4KB) | 24 (for 16MB, default) | 32 (for 4GB) | 48 (for 256TB, needs -mcmodel=large)'
H26411589DDDC: '指定即時TLS偏移量位元大小（僅AArch64 ELF）：12（4KB） | 24（預設 16MB） | 32（4GB） | 48（256TB，需配合-mcmodel=large）'
# 'Specify code object ABI version. Defaults to 6. (AMDGPU only)'
HA8698B7A4F07: '指定程式碼物件ABI版本。預設值為 6（僅AMDGPU）'
# 'Specify comma-separated list of offloading target triples (CUDA and HIP only)'
H4646687E209A: '以逗號分隔的卸載目標三元組清單（僅CUDA和HIP）'
# 'Specify comma-separated list of triples OpenMP offloading targets to be supported'
H3568A2B2B198: '以逗號分隔的OpenMP卸載目標三元組清單'
# 'Specify command to run'
H1E332E02D801: '指定要執行的命令'
# 'Specify configuration file'
HF189739D324B: '指定配置檔'
# "Specify default stream. The default value is 'legacy'. (CUDA/HIP only)"
H9CAF3E629210: "指定預設流。預設值為 'legacy'。 (CUDA/HIP 限定)"
# 'Specify file to retrieve coverage information from'
HF677E8D618FB: '指定用於取得覆蓋資訊的檔案'
# 'Specify file to retrieve the list of functions to apply CHR to'
H43EA914C6AE3: '指定用於取得要套用CHR的函數清單的檔案'
# 'Specify file to retrieve the list of modules to apply CHR to'
HB6D52312D695: '指定用於取得要套用CHR的模組清單的檔案'
# 'Specify frame pointer elimination optimization'
HCB5E3F71D5CB: '指定框架指標消除最佳化'
# 'Specify function to extract'
H6994C514E482: '指定要提取的函數'
# 'Specify function(s) to extract using a regular expression'
H807560CFE84D: '指定要使用正則表達式提取的函數'
# 'Specify global to extract'
HDBAFDC1CCA62: '指定要提取的全域變數'
# 'Specify global(s) to extract using a regular expression'
H3D4D2BF99055: '指定要使用正則表達式提取的全域變數'
# 'Specify gotol lower bound'
H0CEAACB24E44: '指定gotol的下限值'
# 'Specify how to interpret the input file'
H8145E9D12D4E: '指定如何解讀輸入檔案'
# 'Specify input format'
H2E3E293CB7F2: '指定輸入格式'
# 'Specify list of enabled SPIR-V extensions'
H3D0774E8209D: '指定已啟用的SPIR-V擴充功能清單'
# 'Specify lowering strategy for function LDS access:'
H5D945C2F2C1F: '指定函數LDS存取的降階策略：'
# 'Specify maximum number of prefixes to use for padding'
H3374CFFFC8CB: '指定用於填充的最大前綴數量'
# 'Specify name of main file output in depfile'
HA7D009581C27: '指定depfile中主輸出檔的名稱'
# 'Specify name of main file output to quote in depfile'
H50F02814EC9E: '指定在depfile中引用的主輸出檔名稱'
# 'Specify output filename'
H1761FE158718: '指定輸出檔名'
# 'Specify remark argument/s to count (accepts regular expressions).'
H822EAE5D54AB: '指定要計數的註釋參數（接受正則表達式）。'
# 'Specify remark argument/s to count by.'
HAEE8EE4F6186: '指定用以計數的註釋參數。'
# 'Specify target SDNode namespace (default=<Target>ISD)'
H929FE737DC80: '指定目標 SDNode 命名空間（預設值=<Target>ISD）'
# 'Specify target triple (e.g. i686-apple-darwin9)'
HB87754B01AFD: '指定目標三元組（例如：i686-apple-darwin9）'
# 'Specify that backslash in string introduces an escape character'
H5D6C9DDA7494: '指定字串中的反斜杠表示轉義字元'
# 'Specify that floating-point optimizations are not allowed that assume arguments and results are not +-inf.'
H8BEEB06E6F67: '指定禁止進行假設參數和結果不包含正負無限大的浮點優化'
# 'Specify that floating-point optimizations are not allowed that assume arguments and results are not NANs.'
H8FA0A762F433: '指定禁止進行假設參數和結果不包含NAN的浮點優化'
# 'Specify that kernel argument names are preserved (HIP only)'
H623A10E0D7BD: '指定保留核函數的參數名稱（僅適用HIP）'
# 'Specify that single precision floating-point divide and sqrt used in the program source are correctly rounded (HIP device compilation only)'
H6D7A7AAF7A65: '指定程式來源中使用的單精確度浮點除法和平方根運算需要正確四捨五入（僅適用HIP裝置編譯）'
# 'Specify that the assembler should encode SSE instructions with VEX prefix'
HE1B00D0701B9: '指定組譯器應使用VEX前綴編碼SSE指令'
# 'Specify the "test" i.e. suspect back-end:'
HECCC4473972C: '指定「測試」即可疑的後端：'
# 'Specify the BPF stack size limit'
HDC6898D3AB44: '指定BPF堆疊大小上限'
# 'Specify the Swift version to use when filtering API notes'
HC09727464228: '指定過濾API註釋時使用的Swift版本'
# "Specify the boundary's size to align branches"
H7FCB2E0E7262: '指定用於分支對齊的邊界大小'
# 'Specify the class to use for constant Objective-C string objects.'
H3B4E080AFF98: '指定用於常量Objective-C字串物件的類別'
# 'Specify the compression level (integer)'
HA372218D9884: '指定壓縮層級（整數）'
# 'Specify the current profile is used as a partial profile.'
H3B5AA73241EA: '指定當前的剖析資料用作部分剖析'
# 'Specify the darwin target variant triple'
H1C214E10868A: '指定Darwin目標變體三元組'
# 'Specify the default character set for source files'
H23A2C73FDF8A: '指定來源檔案的預設字元集'
# 'Specify the default maximum struct packing alignment'
HA57D1AA26D37: '指定結構體對齊的最大預設值'
# "Specify the entry function (default = 'main') of the executable"
H95F6DBF9D7B0: "指定可執行檔的入口函數（預設值='main'）"
# 'Specify the filename of the process to launch for remote MCJIT execution.  If none is specified,\n\tremote execution will be simulated in-process.'
HB6260E716DE3: '指定用於遠端MCJIT執行的執行程序檔案名稱。若未指定，則在處理序內模擬遠端執行。'
# 'Specify the function selection heuristic used during inlining'
H700459284955: '指定內聯期間用於函數選擇的啟發式演算法'
# 'Specify the function to be called on overflow'
H514658550A0D: '指定在溢出時要呼叫的函數'
# 'Specify the interval (in seconds) after which a module file will be considered unused'
H7EDAFDC5BFCC: '指定模組檔案被視為未使用前的間隔時間（以秒為單位）'
# 'Specify the interval (in seconds) between attempts to prune the module cache'
HC07FD162EBA7: '指定嘗試修剪模組快取之間的間隔時間（以秒為單位）'
# 'Specify the mapping of module name to precompiled module file, or load a module file if name is omitted.'
H9433E5C683C8: '指定將模組名稱映射到預編譯的模組檔，若未指定名稱則載入模組檔'
# 'Specify the maximum alignment to enforce on pointers lacking an explicit alignment'
H46AC799A7735: '指定對未明確指定對齊的指標強制執行的最大對齊值'
# 'Specify the maximum amount of instructions to inspect when searching for a conditional branch from an indirect control flow.'
H6CFBC17F5A5D: '指定在從間接控制流搜尋條件分支時要檢查的指令最大數量'
# 'Specify the maximum amount of instructions to inspect when searching for an undefined instruction from a conditional branch.'
HBCCACE2ACD35: '指定在從條件分支搜尋未定義指令時要檢查的指令最大數量'
# 'Specify the module cache path'
H2FE40A911909: '指定模組快取路徑'
# 'Specify the module user build path'
HE6E81535FDBA: '指定模組使用者建置路徑'
# 'Specify the name of an IR file to load for function definitions'
H66FD8DF154C5: '指定用於函數定義的IR檔名稱'
# 'Specify the name of the .dwo file to encode in the DWARF output'
HFD25A07F8173: '指定要編碼到DWARF輸出中的.dwo檔名稱'
# 'Specify the name of the module to build'
HC274D886E608: '指定要建置的模組名稱'
# 'Specify the name of the root module.'
H385C12B5E6FA: '指定根模組的名稱'
# "Specify the output file type ('asm', 'null', or 'obj')"
H908E78C67406: "指定輸出檔類型（'asm'、'null' 或 'obj'）"
# 'Specify the output file. default: reduced.ll|.bc|.mir'
HDB7BE70A48BF: '指定輸出檔。預設：reduced.ll|.bc|.mir'
# 'Specify the output filename'
H3C3BD1616514: '指定輸出檔名'
# 'Specify the output name of the file containing the optimization remarks. Implies -fsave-optimization-record. On Darwin platforms, this cannot be used with multiple -arch <arch> options.'
HD73FD36131DB: '指定包含最佳化註記的檔的輸出名稱。隱含 -fsave-optimization-record。在Darwin平台上，此選項不能與多個 -arch <arch> 選項一起使用'
# 'Specify the overflow patterns to exclude from arithmetic sanitizer instrumentation'
H317E2D4E0BC0: '指定要排除在算術檢查器插樁之外的溢出模式'
# 'Specify the path of profile data file. This is mainly for test purpose.'
HE901E0A55767: '指定剖析資料檔的路徑。此選項主要用於測試目的'
# 'Specify the path of profile remapping file. This is mainly for test purpose.'
H853E5B17061C: '指定剖析重新映射檔的路徑。此選項主要用於測試目的。'
# 'Specify the path prefix of the MemProf dot files.'
H5392A6A236E7: '指定MemProf點文件的路徑前綴。'
# 'Specify the path to the "safe" backend program'
HD696058226F4: '指定「安全」後端程式的路徑'
# 'Specify the prebuilt module path'
H3FAB39F2C50D: '指定預建模組路徑'
# 'Specify the printf lowering scheme (AMDGPU only), allowed values are "hostcall"(printing happens during kernel execution, this scheme relies on hostcalls which require system to support pcie atomics) and "buffered"(printing happens after all kernel threads exit, this uses a printf buffer and does not rely on pcie atomic support)'
H36B6C5D95ECD: '指定printf降低方案（僅AMDGPU），允許的值為 "hostcall"（列印在kernel執行期間進行，此方案依賴hostcall，需要系統支援pcie atomics）和 "buffered"（列印在所有kernel執行緒結束後進行，此使用printf緩衝區且不依賴pcie原子支援）'
# 'Specify the profile path in PGO use compilation'
H383968EDB0F3: '在PGO使用編譯時指定剖析路徑'
# 'Specify the property to collect remarks by.'
H8278427A48F9: '指定用以收集註記的屬性。'
# 'Specify the property to group remarks by.'
HE59A5BD76AE3: '指定用以分組註記的屬性。'
# 'Specify the size in bits of an RVV vector register'
H0AB4126F0C29: '指定RVV向量寄存器的位元大小'
# 'Specify the size in bits of an SVE vector register. Defaults to the vector length agnostic value of "scalable". (AArch64 only)'
H2F3DFF504736: '指定SVE向量寄存器的位元大小。預設值為向量長度無關的「可擴展」值（僅限AArch64）。'
# 'Specify the stackmap encoding version (default = 3)'
H7CF270813613: '指定堆疊映射編碼版本（預設=3）'
# 'Specify the target Objective-C runtime kind and version'
HFE1F1D7E8E7B: '指定目標環境'
# 'Specify the target environment'
H62189CA73425: '指定目標Objective-C執行階段類型與版本'
# 'Specify the type of coverage instrumentation for Sanitizers'
HCCE91ECD2AD5: '指定Sanitizers的覆蓋插樁類型'
# 'Specify the type of metadata to emit for binary analysis sanitizers'
HCEF5AB90855A: '指定要發出的二進位分析Sanitizers元資料類型'
# 'Specify the types of comparisons to emit GPR-only code for.'
HDBA609305F00: '指定要發出僅使用一般暫存器(GPR)的比對類型代碼。'
# 'Specify the version of the memprof format to use'
H1B82817FBBA6: '指定要使用的memprof格式版本'
# 'Specify the vscale maximum. Defaults to the vector length agnostic value of "0". (AArch64/RISC-V only)'
HA66591A80BFB: '指定vscale最大值。預設為向量長度無關的「0」值（僅限AArch64/RISC-V）。'
# 'Specify the vscale minimum. Defaults to "1". (AArch64/RISC-V only)'
H0C205532C01D: '指定vscale最小值。預設值為「1」（僅限AArch64/RISC-V）。'
# 'Specify time trace file destination'
HC99CB0CDDE38: '指定時間追蹤檔的目標路徑'
# 'Specify types of branches to align'
H8693C7688390: '指定要對齊的分支類型'
# 'Specify types of branches to align (plus separated list of types):\njcc      indicates conditional jumps\nfused    indicates fused conditional jumps\njmp      indicates direct unconditional jumps\ncall     indicates direct and indirect calls\nret      indicates rets\nindirect indicates indirect unconditional jumps'
H3D330EC77559: '指定要對齊的分支類型（以+號分隔的類型列表）:\njcc      指示條件式跳轉\nfused    指示融合式條件式跳轉\njmp      指示直接無條件跳轉\ncall     指示直接和間接呼叫\nret      指示rets\nindirect 指示間接無條件跳轉'
# 'Specify wavefront size 32 mode (AMDGPU only)'
HA9AC5ACEB8A1: '指定wavefront size 32 模式（僅AMDGPU）'
# 'Specify wavefront size 64 mode (AMDGPU only)'
H33E655B3FFCB: '指定wavefront size 64 模式（僅AMDGPU）'
# 'Specify where to find the compiled intrinsic modules'
H60F443A1A2B8: '指定搜尋編譯後的內置模組的路徑'
# 'Specify which frame pointers to retain.'
H899F4C930DBE: '指定要保留的框架指標類型'
# 'Speculate that non-constant strides are unit in LAA'
HD4B90FE88764: '假設非常量步幅在LAA中為單位步幅'
# 'Speculate unpredictable branches (default = false)'
HBDC5587A6F17: '預測不可預測的分支（預設=false）'
# 'Speculative execution is applied only to targets with divergent branches, even if the pass was configured to apply only to all targets.'
HA74AC4F303A4: '預測執行僅套用於具有分歧分支的目標，即使pass被設定為僅套用於所有目標。'
# 'Speculative execution is not applied to basic blocks where the cost of the instructions to speculatively execute exceeds this limit.'
HE2B4F7F554AA: '若要預測執行的指令成本超過此限額，則不會對基本區塊套用預測執行。'
# 'Speculative execution is not applied to basic blocks where the number of instructions that would not be speculatively executed exceeds this limit.'
H9EB9A3987580: '若不會被預測執行的指令數量超過此限額，則不會對基本區塊套用預測執行。'
# 'SpeculativeJIT'
H6F038D1D3644: 'SpeculativeJIT'
# 'Speculatively execute instructions'
HF1EBCFA9992F: '進行預測執行指令'
# 'Spill Code Placement Analysis'
HC707A69CEDE9: '溢位程式碼位置分析'
# 'Spill mode for splitting live ranges'
H33C680059059: '分割活躍範圍的溢位模式'
# 'Split GEPs to a variadic base and a constant offset for better CSE'
HCB9C6A238522: '將GEPs分割為可變長基礎和常數偏移量以改善CSE'
# 'Split Options'
H33A61DDF11E4: '分割選項'
# 'Split all critical edges during PHI elimination'
H4A2C55331EC3: '在PHI消除期間分割所有關鍵邊'
# 'Split all partitions'
H2671573A0660: '分割所有區塊'
# 'Split critical edges during machine sinking'
H4AC49C950879: '在機器下沉期間分割臨界邊'
# 'Split machine functions using profile information'
HD03C9F1F9730: '使用剖析資訊分割機器函數'
# 'Split marker to use for merging the ouput'
H5ED0DBD3456A: '用於合併輸出的分割標記符'
# 'Split out cold basic blocks from machine functions based on profile information'
H1074CBD18EC9: '根據剖析資訊將機器函數中的冷基本區塊分割出來'
# 'Split out cold blocks from machine functions based on profile information.'
H59A610956F3E: '根據剖析資訊將機器函數中的冷區塊分割出來。'
# 'Split static data'
HAD68510283FA: '分割靜態資料'
# 'Split static data sections into hot and cold sections using profile information'
H0855E4DC6A4D: '使用剖析資訊將靜態資料區段分割為熱區段和冷區段'
# 'Split the input file into chunks using the given or default marker and process each chunk independently'
H630FB595F295: '使用指定或預設的標記符將輸入檔分割為多個區塊，並獨立處理每個區塊'
# 'Split the output by Compile Units.'
H6C6E1FDA7719: '根據編譯單位分割輸出'
# 'Split the profile to two sections with one containing sample profiles with inlined functions and the other without (only meaningful for -extbinary)'
H4FBB422A3FD9: '將剖面分割為兩個區段，其中一個包含內聯函數的範例剖面，另一個不含（僅對-extbinary有意義'
# 'Split without externalizing locals'
H8A331352F2E7: '不外部分割局部變數'
# "Splits all EH code and it's descendants by default."
HA93F604541F1: '預設分割所有例外處理代碼及其子代。'
# 'Stable  ABI instrumentation for sanitizer runtime. Default: Conventional'
H1B5D3202D1AE: '為sanitizer執行階段提供穩定ABI插樿。預設：常規'
# 'Stack Frame Layout'
H33A25E80B45A: '堆疊框架佈局'
# 'Stack Slot Coloring'
H85960DF4AF9A: '堆疊區塊著色'
# 'StackMap Liveness Analysis'
H6CCE8B66D5C3: '堆疊地圖存活性分析'
# 'Standard converging scheduler.'
HA7AD7FEE5D0B: '標準收斂排程器。'
# 'Start each pass with collecting and end it with checking of debug info preservation.'
H3F51E578F392: '在每個pass開始時執行收集，並在結束時檢查除錯資訊的保留情況'
# 'Start each pass with debugify and end it with check-debugify'
H2D5ADDBBEEF2: '在每個pass開始時執行debugify，並在結束時執行check-debugify'
# 'Start emitting warnings for unused driver arguments'
HE346B2A53C42: '開始發出未使用驅動程式參數的警告'
# 'Start the pipeline with collecting and end it with checking of debug info preservation.'
HE5F5305CC00C: '以收集開始管線，並以檢查調試資訊的保留結束。'
# 'Start the pipeline with debugify and end it with check-debugify'
H0175081FA86E: '以debugify開始管線，並以check-debugify結束'
# 'Statement-level analysis'
H08A2201C3BBE: '語句層級分析'
# 'Static Data Annotator'
H8F3F11306A56: '靜態資料註釋器'
# 'Static Data Profile Info'
H42C5E08B9C8C: '靜態資料剖析資訊'
# 'Static analyzer report output format (html|plist|plist-multi-file|plist-html|sarif|sarif-html|text).'
HA5BB1BCA30A0: '靜態分析器報告輸出格式（html|plist|plist-multi-file|plist-html|sarif|sarif-html|text）。'
# 'Static scheduling'
H9688287692D9: '靜態排程'
# 'Statically link the sanitizer runtime (Not supported for ASan, TSan or UBSan on darwin)'
H5D51614B7830: '靜態連結sanitizer執行階段（在darwin上不支援ASan、TSan或UBSan）'
# 'Statically resolve calls to versioned functions from non-versioned callers.'
HDACBD3DAB33D: '靜態解析非版本化調用者對版本化函數的呼叫。'
# 'Stop PCH generation after including this file.  When using a PCH, skip tokens until after this file is included.'
HEE422676F0B0: '在包含此檔案後停止PCH生成。當使用PCH時，跳過代碼直到此檔案被包含後。'
# 'Stop compilation after a specific pass'
HD6BD4366BCBC: '在特定pass後停止編譯'
# 'Stop compilation before a specific pass'
H50FA55AE29C2: '在特定pass前停止編譯'
# 'Stop inferring nofree attribute during function-attrs pass'
HAF941AF0C8A5: '在function-attrs pass期間停止推論nofree屬性'
# 'Stop inferring nounwind attribute during function-attrs pass'
H8B6C2FE67EDE: '在function-attrs pass期間停止推論nounwind屬性'
# 'Stop initializing trivial automatic stack variables after the specified number of instances'
H023CB238F8AC: '在指定實例數量後停止初始化簡單自動堆疊變數'
# 'Stop initializing trivial automatic stack variables if var size exceeds the specified number of instances (in bytes)'
HFF75ED2CDFB4: '如果變數大小超過指定的實例數量（以位元組為單位），則停止初始化簡單自動堆疊變數'
# 'Stop processing after parsing rules and dump state'
HC94659F6E6B6: '在解析規則後停止處理並傾印狀態'
# 'Stop removing an empty block if removing it will introduce more than this number of phi entries in its successor'
H9A65443D39E6: '如果移除空區塊將在後續區塊中引入超過指定數量的phi條目，則停止移除該區塊'
# 'Stop scheduling after N instructions'
H9C405DA9723C: '在N條指令後停止排程'
# 'Store string literals as writable data'
HAB4FC207616D: '將字串文字存儲為可寫入資料'
# 'Store-level granularity'
H6039083A6A50: '儲存層級粒度'
# 'Straight line strength reduction'
H31FF5C722167: '直線強度削減'
# 'Stress Options'
HB2B1AD1DE1DF: '壓力測試選項'
# 'Stress test LSR IV chains'
H1CC9D49F4B69: '壓力測試LSR IV鏈'
# 'Stress test ext(promotable(ld)) -> promoted(ext(ld)) optimization in CodeGenPrepare'
HB72AD83333E7: '在CodeGenPrepare中壓力測試ext(promotable(ld)) -> promoted(ext(ld))優化'
# 'Stress test instruction scheduling'
HA55B8E05F17D: '壓力測試指令排程'
# 'Stress test store(extract) optimizations in CodeGenPrepare'
HBA93839DF706: '在CodeGenPrepare中壓力測試store(extract)優化'
# 'String Table (DEBUG_S_STRINGTABLE subsection) (not typically present in PDB file)'
H346701412AE3: '字串表（DEBUG_S_STRINGTABLE子區段）（通常不會出現在PDB檔案中）'
# 'String to initialize the database'
H3CBC3A337427: '初始化資料庫的字串'
# 'Strip (or keep only, if negative) a given number of path components when emitting check metadata.'
H95EB3AD2C385: '發射檢查元數據時，剝除（若為負數則僅保留）指定數量的路徑元件。'
# 'Strip debugger symbol info from translation unit'
HE92E5C253ED7: '剝除翻譯单元的調適器符號信息'
# 'Strip module-level named metadata'
HDD827ABBE60A: '剝除模塊層級命名元數據'
# 'Strip names from Value during LTO (other than GlobalValue).'
HC04AE0DCC2F5: '在LTO中剝除Value的名稱（GlobalValue除外）'
# 'Strip prefix of the fully qualified names'
HC496A1D3FAD4: '剝除完整限定名稱的前綴'
# 'Strip specified level of directory name from source path in the profile counter name for static functions.'
HB9A6EFA2E4BB: '對靜態函數的剖面計數器名稱來源路徑，剝除指定層級的目錄名稱。'
# 'Strip-mine outer loops for the loop-vectorizer to trigger'
HA84FED7AAA88: '對loop-vectorizer觸發的外層迴圈進行切帶'
# 'Structure.'
H12CCB9A83FCE: '結構。'
# 'Structurize the CFG'
H86D5CD019397: '結構化CFG'
# 'Stuff'
H226D042D922D: '填充'
# 'Subprogram.'
H5A13F062C508: '子程序。'
# 'Subrange encoding information for arrays.'
H9B8612490EAE: '陣列的子範圍編碼資訊。'
# 'Summary of elements missing/added/matched/printed.'
HE867CEA332FA: '缺少/新增/匹配/已列印元素的總結。'
# 'Supplement an instr profile with sample profile, to correct the profile unrepresentativeness issue. The sample profile is the input of the flag. Output will be in instr format (The flag only works with -instr)'
HB26399824318: '以樣本剖析補充插樁剖析，以修正其代表性不足的問題。樣本剖析為旗標的輸入，輸出格式為插樍剖析格式（此旗標僅與-instr併用）'
# 'Support POSIX threads in generated code'
H519A7A85C373: '在產生的程式碼中支援POSIX執行緒'
# 'Suppress STP for AArch64'
H0D98334CA140: '抑制AArch64的STP指令'
# 'Suppress all deprecated warnings'
HE5E64D48AF93: '抑制所有已棄用的警告'
# 'Suppress all linking warnings'
H012398BE48C2: '抑制所有連結警告'
# 'Suppress all warnings'
HE2E5B3B89DBD: '抑制所有警告'
# 'Suppress counter promotion if exit blocks contain ret.'
H69AEA135B910: '若退出區塊包含ret指令，則抑制計數器提升'
# 'Suppress duplication of instrs into per-HwMode decoder tables'
HC365469D96E4: '抑制將指令複製到各HwMode解碼表中'
# 'Suppress inlining of functions whose stack size exceeds the given value'
H25336627EFCB: '抑制堆疊大小超過指定值的函數的內嵌'
# 'Suppress output of running passes (both stdout and stderr)'
H777CD18B4BD8: '抑制執行pass時的輸出（包括標準輸出和標準錯誤）'
# 'Suppress rematerialization of dynamic shadow address by passing it through inline asm in prologue.'
H9476840CC1D4: '透過在序言中通過內聯組合語言傳遞，抑制動態陰影地址的重新生成'
# 'Suppress slot sharing during stack coloring'
H734CB119B295: '在堆疊著色期間抑制槽位共用'
# 'Suppress type errors (Wasm)'
H63BEE3B3DE32: '抑制類型錯誤（Wasm）'
# 'Suppress verbose debugify output'
H650FEBD3E6CA: '抑制詳細的debugify輸出'
# 'Swap target blocks of a conditional branch for MVE expander'
H6042CB5BEBAE: '為MVE展開器交換條件分支的目標區塊'
# 'Switch to fast cluster algorithm with the lost of some fusion opportunities'
H3997C1BEC2C0: '切換至快速聚類演算法，但會損失部分融合機會'
# 'Symbol ID of the symbol being queried (hex).'
H06F2A7E436A9: '被查詢符號的符號ID（十六進位）。'
# 'Symbol ID to look up (hex)'
H98F75068720A: '要查詢的符號ID（十六進位）'
# 'Symbol Options'
HBFC1F4F0A88E: '符號選項'
# 'Symbol Rewrite Map'
H1CDA542441BA: '符號重寫映射'
# 'Symbol Type Options'
H035FC129AB6C: '符號類型選項'
# 'Symbol kind to use when printing symbols.'
HB4C2F9BD84AD: '列印符號時使用的符號類型。'
# 'Symbol location coverage.'
H80C30D273074: '符號位置覆蓋範圍。'
# 'Symbol remapping file'
H3423735D2CB7: '符號重新映射文件'
# 'Symbol to call as main entry point'
H39AD275C387D: '用作主要入口點的符號'
# 'Symbol to put in the symtab in the resulting dso'
HFB4EE7AEFE5C: '在結果dso的symtab中放入的符號'
# 'Symbols (DEBUG_S_SYMBOLS subsection) (not typically present in PDB file)'
HDB1B5EBB0319: '符號（DEBUG_S_SYMBOLS子節）（通常不出現在PDB文件中）'
# 'Symbols (Variable, Members, etc.).'
HE394D83CA76F: '符號（變數、成員等）。'
# 'Symbols.'
H73E0811A7FD7: '符號。'
# 'Syntax variant to use for output printing'
HDCC1F5EAEC7B: '用於輸出列印的語法變體'
# 'Synthesize retain and release calls for Objective-C pointers'
H40E12820EB61: '為Objective-C指標合成retain和release調用'
# 'System directory for configuration files'
H2B1CA8129B49: '配置文件的系統目錄'
# 'SystemZ Comparison Elimination'
HA6D4515C513E: 'SystemZ 比較消除'
# 'SystemZ Copy Physregs'
HBF6729EB5D82: 'SystemZ 複製物理寄存器'
# 'SystemZ DAG->DAG Pattern Instruction Selection'
H66AEC705D460: 'SystemZ DAG→DAG 指令選擇模式'
# 'SystemZ Instruction Shortening'
H75E7D5BFB7B2: 'SystemZ 指令縮短'
# 'SystemZ Local Dynamic TLS Access Clean-up'
H860F0223FC41: 'SystemZ 本地動態TLS存取清理'
# 'SystemZ Long Branch'
H20A34CC2B958: 'SystemZ 長跳轉'
# 'SystemZ Post Rewrite pass'
H26F388ADE65D: 'SystemZ 重寫後的 pass'
# 'SystemZ Test Data Class optimization'
H7C47CE39188C: 'SystemZ 測試資料類別最佳化'
# 'TableGen LSP Language Server'
H927DAB993B40: 'TableGen LSP 語言伺服器'
# 'Tail Call Elimination'
H783C2FABF530: '尾調用消除'
# 'Tail Duplication'
H71C746D731D5: '尾複製'
# 'Tail-folding and predication preferences over creating a scalar epilogue loop.'
HC5BDD1DF7A2D: '偏好尾摺疊與預測，而非創建純量尾跡循環。'
# 'Take more precise inbounds assumptions (do not scale well)'
H08762D9FA006: '採用更精確的索引範圍假設（擴展性不佳）'
# 'Take raw hexadecimal bytes as input for disassembly. Whitespace is ignored'
H21819087D66E: '使用原始十六進位字元作為反組譯輸入。空白字符將被忽略'
# 'Takes a posix regex and prints the link graphs of all files matching that regex after fixups have been applied'
HB3F945A20F78: '接受POSIX正規表示式，並在修復後顯示所有符合該正規表示式的檔案的連結圖形'
# 'Target CPU, ignored if --mtriple is not used'
H9C0D15DCF3BD: '目標CPU（若未使用 --mtriple 則忽略）'
# 'Target Library Information'
H5C80DD9524F8: '目標函式庫資訊'
# 'Target Pass Configuration'
HE8EFE346FCF6: '目標 pass 設定'
# 'Target Transform Information'
H381DDCC824B8: '目標轉換資訊'
# 'Target a particular ABI type'
H8CB1D450BB9C: '指定特定的ABI類型'
# 'Target a specific auxiliary cpu type'
HC63DF9647BBE: '指定特定的輔助CPU類型'
# 'Target a specific cpu type'
HA6E72D889CDB: '指定特定的CPU類型'
# 'Target a specific cpu type (-mcpu=help for details)'
HB995589A2608: '指定特定的CPU類型（使用 -mcpu=help 查看詳細資訊）'
# 'Target arch to assemble for, see -version for available targets'
H6A0D4D1161C4: '指定組譯目標指令集架構，使用 -version 可查看可用目標'
# 'Target architecture. See -version for available targets'
HDD6FE0D72BD5: '指令集架構目標。使用 -version 查看可用目標'
# 'Target cost kind'
HDAD667E32250: '目標成本類型'
# 'Target default float ABI type'
HEAFE690D5657: '目標預設的浮點ABI類型'
# 'Target linker version'
H57EDF14C8F4F: '目標連結器版本'
# 'Target specific attributes'
H8E47E4436FE2: '目標特定屬性'
# 'Target specific attributes (-mattr=help for details)'
HAB90F22130BF: '目標特定屬性（使用 -mattr=help 查看詳細資訊）'
# 'Target specific auxiliary attributes'
H2BA14C72345A: '目標特定輔助屬性'
# 'Target triple for disassembler'
H83C90E391152: '反組譯器的目標三元組'
# 'Target triple to assemble for, see -version for available targets'
HC643C7A09170: '組譯目標的目標三元組。查看 -version 以獲取可用目標'
# 'Target triple. See -version for available targets'
H3857DE6DE1E0: '目標三元組。查看 -version 以獲取可用目標'
# 'Target triple. When present, a TargetMachine is created and TargetMachine::splitModule is used instead of the common SplitModule logic.'
H2B7CF41128A9: '目標三元組。存在時，會建立 TargetMachine 並使用 TargetMachine::splitModule，而非通用的 SplitModule 邏輯'
# 'Template Parameter.'
HF63F96014E9F: '模板參數。'
# 'Template alias.'
H3C8CFAE8AE20: '模板別名。'
# 'Template arguments encoded in the template name.'
H1C3D42D15648: '編碼在模板名稱中的模板參數。'
# 'Template functions or specializations without host, device and global attributes have implicit host device attributes (CUDA/HIP only)'
HA4C9090C9925: '沒有主機、裝置和全域屬性的模板函數或特化會隱含主機裝置屬性（僅適用於CUDA/HIP）'
# 'Template pack.'
HA1E3326A0AE4: '模板包。'
# 'Template parameters replaced by its arguments.'
H2B376AF57DB4: '已被其參數取代的模板參數。'
# 'Template template parameter.'
HB1F99591F368: '模板模板參數。'
# 'Template type parameter.'
H16F66C4F3D61: '模板類型參數。'
# 'Template value parameter.'
H128B1A19518C: '模板值參數。'
# 'Template.'
H0518E81F03C2: '模板。'
# 'Temporary development switch used to gradually uplift SimplifyCFG into preserving DomTree,'
HBE52749BCFE7: '暫時開發切換開關，用於逐漸將SimplifyCFG改進為保留DomTree，'
# 'Terminate process if it loads user32.dll.'
H3BC023827DF8: '若程序載入user32.dll，則終止程序。'
# 'Test harness files'
HA4814F3A55AD: '測試架構檔'
# 'Text encoding'
H104683D616E5: '文字編碼'
# 'Text output'
H722885D8D390: '文字輸出'
# 'Textual description of the function type to be called'
HFA8DBC9DB008: '要呼叫的函式類型的文本描述'
# 'Textual description of the pass pipeline to run'
HE98FE702D92A: '要執行的pass管線的文本描述'
# 'The CPU number that the benchmarking process should executon on'
H67AECA2CBAEE: '要執行基准測試的處理器核心編號'
# 'The InteractiveModelRunner will echo back to stderr the data received from the host (for debugging purposes).'
HA27F90224438: 'InteractiveModelRunner將主機傳來的資料回傳到stderr（用於除錯）。'
# 'The LMUL to use for getRegisterBitWidth queries. Affects LMUL used by autovectorized code. Fractional LMULs are not supported.'
H065EFBB6A92E: '用於getRegisterBitWidth查詢的LMUL。會影響自動向量化代碼使用的LMUL。不支援分數LMUL。'
# 'The OOO window for processor resources during scheduling.'
H7F8CE8011253: '排程期間處理器資源的非順序視窗大小（Out-of-Order window）。'
# 'The alignment to use when accessing the buffers\nDefault is unaligned\nUse 0 to disable address randomization'
H9D92202DC06A: '存取緩衝區時使用的對齊方式\n預設為未對齊\n使用 0 來停用位址隨機化'
# 'The amount of branches that we are willing to explore withthe exact algorithm before giving up.'
H46BDE8E006FD: '願意用精確演算法探索的分支數量，超過後會放棄。'
# 'The associativity of the first cache level.'
H091472E28B2B: '第一層快取的關聯性（associativity）。'
# 'The associativity of the second cache level.'
HEE9D38673E97: '第二層快取的關聯性（associativity）。'
# 'The average lifetime (s) for an allocation to be considered cold'
H31CAA2FC4467: '被視為冷資料的配置文件分配平均生命週期（秒）'
# 'The average number of profile counters allocated per value profiling site.'
H3EFF8568FB96: '每個值剖面分析點（value profiling site）分配的平均剖面計數器數量。'
# 'The base class for the ops in the dialect we are planning to emit'
HA507EEDE87C4: '計劃要發射的語法（dialect）中ops的基底類別（base class）'
# 'The bonus weight of users of allocas within loop when sorting profitable allocas'
HBDF3A84E4987: '排序有利可圖的allocas時，循環內allocas使用者的加權值（bonus weight）'
# 'The clause simdlen must fit the %0-bit lanes in the architectural constraints for SVE (min is 128-bit, max is 2048-bit, by steps of 128-bit)'
H637FD9B0F74C: '在SVE架構約束下，simdlen子句必須符合 %0 位lane長度（最小 128 位元，最大 2048 位元，以 128 位元為步進）'
# 'The clause simdlen(1) has no effect when targeting aarch64.'
H28E8D9873AFA: '在指定aarch64目標時，指定simdlen(1)不會有作用。'
# 'The code working set size is considered huge if the number of blocks required to reach the -profile-summary-cutoff-hot percentile exceeds this count.'
H1D058B3A0D64: '如果要達到 -profile-summary-cutoff-hot 百分位數所需的區塊數超過此計數，則程式碼工作集大小被視為龐大。'
# 'The code working set size is considered large if the number of blocks required to reach the -profile-summary-cutoff-hot percentile exceeds this count.'
H0799198BEFDB: '如果要達到 -profile-summary-cutoff-hot 百分位數所需的區塊數超過此計數，則程式碼工作集大小被視為大型。'
# 'The coefficient used when initializing II in the window algorithm.'
H8ABBDA1465FF: '在窗口演算法初始化 II 時使用的係數。'
# 'The compilation directory to embed in the coverage mapping.'
HC40AB6D0A1C3: '要嵌入到覆蓋映射中的編譯目錄。'
# 'The compilation directory to embed in the debug info'
H7AE615281122: '要嵌入到除錯資訊中的編譯目錄。'
# 'The compilation directory to embed in the debug info and coverage mapping.'
HAD4DB13A434F: '要嵌入到除錯資訊和覆蓋映射中的編譯目錄。'
# 'The cost of a histcnt instruction'
HC55AE2001899: 'histcnt 指令的成本。'
# "The cost of a loop that is considered 'small' by the interleaver."
HF5F932DA0017: '交错器（interleaver）認定為「小型」的迴圈成本。'
# 'The cost of a step in a different basic block than the killing MemoryDef(default = 5)'
H38215D7CEF6B: '與殺死 MemoryDef 所在基本區塊不同的基本區塊中的步驟成本（預設值 = 5）'
# 'The cost of a step in the same basic block as the killing MemoryDef(default = 1)'
HA3C397AE67B6: '與殺死 MemoryDef 所在相同基本區塊的步驟成本（預設值 = 1）'
# 'The cost of decreasing a block count by one.'
HBA666F36C915: '減少區塊計數一次的成本。'
# "The cost of decreasing a block's count by one."
H9FCF3A04FBC3: '減少某區塊的計數一次的成本。'
# 'The cost of decreasing a jump count by one.'
H01994AC78D25: '減少跳躍計數一次的成本。'
# "The cost of decreasing the entry block's count by one."
HCE46A7F305CE: '減少入口區塊的計數一次的成本。'
# 'The cost of increasing a block count by one.'
HAE44BF594D73: '增加區塊計數一次的成本。'
# "The cost of increasing a block's count by one."
H35BD66941EB2: '增加某區塊的計數一次的成本。'
# 'The cost of increasing a count of zero-weight block by one.'
H15D3659B2D6D: '增加零權重區塊的計數一次的成本。'
# 'The cost of increasing a jump count by one.'
HBEF3551C10D0: '增加跳躍計數一次的成本。'
# 'The cost of increasing an unknown block count by one.'
H70FD1895A2F3: '增加未知區塊的計數一次的成本。'
# "The cost of increasing an unknown block's count by one."
H058C9FB6BA79: '增加未知區塊的計數一次的成本。'
# 'The cost of increasing an unknown fall-through jump count by one.'
H8E3789B6B289: '增加未知穿透跳轉次數的代價。'
# 'The cost of increasing an unknown jump count by one.'
H08B8AF9F180A: '增加未知跳轉次數的代價。'
# "The cost of increasing the entry block's count by one."
H199FDB30E747: '增加入口區塊次數的代價。'
# 'The cost threshold for call sites that get inlined without the cost-benefit analysis'
HBDFEA6BEED2A: '未經成本效益分析而內聯的呼叫位置之成本門檻'
# 'The cost threshold for loop unrolling'
H4E87362F1A39: '迴圈展開的成本門檻'
# 'The cost threshold for loop unrolling when optimizing for size'
H3ADA25107614: '優化大小時迴圈展開的成本門檻'
# 'The cost threshold for partial loop unrolling'
H467DE32D1CDF: '部分迴圈展開的成本門檻'
# 'The cost threshold for unswitching a loop.'
HEDD158AF26CA: '迴圈分離的成本門檻'
# 'The current shard index'
H876C17A38CA1: '目前的分片索引'
# 'The default 2nd-level tile size (if not enough were provided by --polly-2nd-level-tile-sizes)'
H1853EDCB107B: '（若未經--polly-2nd-level-tile-sizes提供足夠值時）預設的第二級磁磚大小'
# 'The default address space is assumed as the flat address space. This is mainly for test purpose.'
HE348DDF306A6: '預設的位址空間假設為平坦位址空間。此設定主要用於測試目的。'
# 'The default associativity of the first cache level (if not enough were provided by the TargetTransformInfo).'
HCCD8A81B4765: '（若未經TargetTransformInfo提供足夠值時）第一層快取的預設關聯性'
# 'The default associativity of the second cache level (if not enough were provided by the TargetTransformInfo).'
HEEAD0D6C75FB: '（若未經TargetTransformInfo提供足夠值時）第二層快取的預設關聯性'
# 'The default maximum header size for automatic loop rotation'
HF0260F4FDAA5: '自動迴圈轉置的預設最大標頭大小'
# 'The default memprof options'
H38DAB40B2AAC: '預設的memprof選項'
# 'The default register tile size (if not enough were provided by --polly-register-tile-sizes)'
H64576F36AC63: '（若未經--polly-register-tile-sizes提供足夠值時）預設的記憶體磁磚大小'
# 'The default size of the first cache level specified in bytes (if not enough were provided by the TargetTransformInfo).'
H868C869C4E16: '（若未經TargetTransformInfo提供足夠值時）以位元組為單位的第一層快取預設大小'
# 'The default size of the second cache level specified in bytes (if not enough were provided by the TargetTransformInfo).'
HD12A54581382: '（若未經TargetTransformInfo提供足夠值時）以位元組為單位的第二層快取預設大小'
# 'The default tile size (if not enough were provided by --polly-tile-sizes)'
HE4A483AAF938: '（若未經--polly-tile-sizes提供足夠值時）預設的磁磚大小'
# 'The desired fields order.'
HFD5615C7395D: '所需的欄位順序。'
# 'The dialect to gen for'
H28E806FCDC03: '要生成的方言'
# 'The dialect to run the generator for'
H6FB81B13F4F4: '要執行生成器的方言'
# 'The directory to import the .jscop files from.'
H46C31664F90D: '要導入.jscop文件的目錄。'
# 'The directory which holds the compiler resource files'
HD211B444AC1B: '存放編譯器資源文件的目錄'
# 'The element type include parents in its name.'
H2A080E537B74: '元素類型的名稱包含父類。'
# 'The estimated size of the generated function (# of instrs)'
HF9641D0FB6D1: '生成函數的預估大小（指令數量）'
# 'The exception model'
HE9B3D391FF5A: '例外模型（EH）'
# 'The file offset to explain'
HBBF973A12DBA: '要說明的文件偏移量'
# 'The file to write the stream to'
HCE306C17C319: '要寫入串流的文件'
# 'The float ABI to use'
HD1594C861A1C: '要使用的浮點ABI'
# 'The format of the remarks.'
H4E4CD6B16734: '註記的格式。'
# 'The format that output stacks should be output in. Only applies with all-stacks.'
H212557A1C0DC: '輸出堆疊時應使用的格式。僅適用於 all-stacks 模式。'
# 'The format used for serializing remarks (default: YAML)'
H5541A330FC11: '序列化註記所使用的格式（預設：YAML）'
# 'The function to be called'
H3E644E558FC4: '要呼叫的函數'
# 'The gcc binary to use.'
H0F09D1C4ABDE: '要使用的gcc二進位檔。'
# 'The index or name of the stream whose contents to export'
H516360D4E007: '要匯出內容的串流索引或名稱'
# 'The isl scheduling optimizer'
H0188CDF20DCD: 'The isl scheduling optimizer'
# 'The kind of context sensitive profile guided optimization'
H057E88E7BF63: '上下文相關的配置文件引導型優化類型'
# 'The kind of dependence analysis to use'
HAC9C6B2E0446: '要使用的依賴性分析類型'
# 'The kind of profile guided optimization'
H930EACDC046E: '配置文件引導型優化的類型'
# 'The level of dependence analysis'
HDB7D1F3D8221: '依存性分析的層級'
# 'The limit on recursion depth for LSRs setup cost'
H429ADCFB8F2B: 'LSR設定成本遞迴深度的上限'
# 'The limit to use while constructing the DAG prior to scheduling, at which point a trade-off is made to avoid excessive compile time.'
H7C463E6FF16B: '在調度前建立DAG時的上限，超過此限制時會進行權衡以避免過度的編譯時間。'
# 'The list of function names in which Emscripten-style exception handling is enabled (see emscripten EMSCRIPTEN_CATCHING_ALLOWED options)'
H0AFF9B181379: '啟用Emscripten-style例外處理的函數名稱清單（參閱emscripten EMSCRIPTEN_CATCHING_ALLOWED選項）'
# 'The list of the names of classes being moved, e.g. "Foo,a::Foo,b::Foo".'
HC13468BE141E: '被移動的類別名稱清單，例如「Foo,a::Foo,b::Foo」。'
# 'The lower bound of size growth limit for proirity-based sample profile loader inlining.'
HA4426ABB67AB: '基於優先順序的樣本剖析載入器內嵌時，大小增長下限。'
# 'The lower limit of the difference between best II and base II in the window algorithm. If the difference is smaller than this lower limit, window scheduling will not be performed.'
H2D09F1B7EEED: '視窗演算法中最佳II與基底II之間的最小差異值。若差異小於此下限，則不會執行視窗調度。'
# 'The lower limit of the scheduling region in the window algorithm.'
H40693E0BEF44: '視窗演算法中調度區塊的最小長度。'
# 'The max number of exiting blocks of a loop to allow  speculative counter promotion'
H126EBD7EDF69: '允許假設性計數器提升的迴圈退出區塊最大數量'
# 'The max number of instructions to consider hoisting loads over (the algorithm is quadratic over this number)'
HB921741F8462: '考慮提升載入操作的指令最大數量（此演算法的時間複雜度與此數值平方成正比）'
# 'The max number of iteration for converge'
HD528CDF78026: '收斂的最大迭代次數'
# 'The max of trip count upper bound that is considered in unrolling'
HD5BFA5564179: '在展開時考慮的迭代次數上限最大值'
# 'The max version for the optimized memory  intrinsic calls'
H2E88F9E75F60: '優化記憶體內建呼叫的最大版本編號'
# 'The maximal coefficient allowed (-1 is unlimited)'
H09B28C36A559: '允許的最大係數（-1表示無限）'
# 'The maximal constant term allowed (-1 is unlimited)'
HF9153E8F373E: '允許的最大常數項（-1表示無限）'
# 'The maximal number of arrays to compare in each alias group.'
HE46CCE04E50E: '每個別名群組中可比較的陣列最大數量。'
# 'The maximal number of disjunts allowed in memory accesses to to build RTCs.'
H810D09DBDCF0: '建立RTC時，記憶體存取中允許的分離條件最大數量。'
# 'The maximal number of parameters allowed in RTCs.'
HD93322BFBD09: '在RTC中允許的最大參數數量。'
# "The maximum 'boost' (represented as a percentage >= 100) applied to the threshold when aggressively unrolling a loop due to the dynamic cost savings. If completely unrolling a loop will reduce the total runtime from X to Y, we boost the loop unroll threshold to DefaultThreshold*std::min(MaxPercentThresholdBoost, X/Y). This limit avoids excessive code bloat."
H02A5B75E496D: '當積極展開迴圈因動態成本節省而提高閾值時，所應用的最大「增幅」（以大於等於 100 的百分比表示）。若完全展開迴圈將使總執行時間從X縮減至Y，則會將展開閾值調整為DefaultThreshold*std::min(MaxPercentThresholdBoost, X/Y)。此限制可避免代碼膨脹過度。'
# 'The maximum LMUL value to use for fixed length vectors. Fractional LMUL values are not supported.'
H8B177E0FA80A: '固定長度向量所使用的最大LMUL值。不支援分數LMUL值。'
# 'The maximum allowed number of runtime memory checks'
HF580EDA4AA2E: '允許的最大執行階段記憶體檢查數量'
# 'The maximum cost used for building integers.'
H61DA215B1301: '用於建構整數時的最大成本值。'
# 'The maximum distance (in bytes) of a backward jump for ExtTSP'
H1AADC32AA7A5: 'ExtTSP向後跳轉的最大距離（以位元組為單位）'
# 'The maximum distance (in bytes) of a forward jump for ExtTSP'
H8BF30ACF7ADE: 'ExtTSP向前跳轉的最大距離（以位元組為單位）'
# 'The maximum distance (in bytes) of backward jumps for ExtTSP value'
H7CD48ED835E9: 'ExtTSP值的向後跳轉最大距離（以位元組為單位）'
# 'The maximum interleave count to use when interleaving a scalar reduction in a nested loop.'
H672121274D43: '在巢狀迴圈中交錯標量約簡時使用的最大交錯次數。'
# 'The maximum length of a constant string for a builtin string cmp call eligible for inlining. The default value is 3.'
H6551F5EAB050: '符合內嵌條件的內建字串cmp呼叫所使用的常數字串最大長度。預設值為 3。'
# 'The maximum length of a constant string to inline a memchr call.'
HAAA048CEEC02: '內嵌memchr呼叫時可內嵌的常數字串最大長度。'
# 'The maximum length of a single temporal profile trace (default: 10000)'
HFAF4CED9A0E5: '單一時間剖析追蹤的最大長度（預設值：10000）'
# 'The maximum levels the DFS-based missing frame search should go with'
H45092EF73D81: '基於深度優先搜索的缺失框架搜尋應深入的最大層級'
# 'The maximum look-ahead depth for operand reordering scores'
H3909DC008995: '操作元重新排序評分的最大前瞻深度'
# 'The maximum look-ahead depth for searching best rooting option'
H23AE19C8EFE0: '尋找最佳根節點選項的最大前瞻深度'
# 'The maximum nesting depth allowed for assembly macros.'
H59D58A80D82C: '允許的組合語言宏最大嵌套深度。'
# 'The maximum number candidates that only partially overwrite the killing MemoryDef to consider (default = 5)'
HF74C3F17FA82: '僅部分覆蓋killing MemoryDef的候選項目最大數量（預設值=5）'
# 'The maximum number of SCEV checks allowed for Loop Distribution'
H6ED62802FFA5: 'Loop Distribution允許的最大SCEV檢查數量'
# 'The maximum number of SCEV checks allowed for Loop Distribution for loop marked with #pragma clang loop distribute(enable)'
H4DE7DF87A45B: '在以#pragma clang loop distribute(enable)標記的迴圈中，Loop Distribution允許的最大SCEV檢查數量'
# 'The maximum number of SCEV checks allowed for Loop Load Elimination'
H7F641B62EEBD: 'Loop Load Elimination允許的最大SCEV檢查數量'
# 'The maximum number of SCEV checks allowed with a vectorize(enable) pragma'
H4BEEB9147A41: '使用vectorize(enable) pragma時允許的最大SCEV檢查數量'
# 'The maximum number of SCEV checks allowed.'
HAB10FFD86827: '允許的最大SCEV檢查數量。'
# 'The maximum number of blocks to check when trying to prove that all paths to an exit go through a killing block (default = 50)'
HE588309A8379: '嘗試證明所有退出路徑均通過殺戮區塊時要檢查的最大區塊數（預設值 = 50）'
# 'The maximum number of callsites in a function, above which stale profile matching will be skipped.'
H22730C5AA352: '函數中調用點的最大數量，超過後將跳過過時剖析比對。'
# 'The maximum number of clones allowed for a single function specialization'
H9DEE4E0B8275: '單一函數專業化允許的最大複本數量'
# 'The maximum number of functions to track per lattice value'
HCD37A486700C: '每個格值可追蹤的函數最大數量'
# 'The maximum number of heap allocations to consider in one function before skipping (to save compilation time). Set to 0 for no limit.'
H9E920C5F07AD: '在函數中要考慮的堆分配次數上限（超過後將跳過，以節省編譯時間）。設為 0 表示無限。'
# 'The maximum number of incoming values a PHI node can have to be considered during the specialization bonus estimation'
H03E2B05D3E4E: '在專業化獎勵估計期間，PHI節點可考慮的最大傳入值數量'
# 'The maximum number of instructions considered for cycle sinking.'
HEC82079C9F71: '可考慮用於循環下沈的最大指令數量'
# 'The maximum number of iterations allowed when searching for transitive phis'
H0F558354650E: '尋找傳遞性PHI時允許的最大迭代次數'
# 'The maximum number of iterations function specialization is run'
H8854F37807C4: '執行函數專業化的最大次數'
# 'The maximum number of parameters allowed when merging functions.'
H24D089F01734: '合併函數時允許的最大參數數量'
# 'The maximum number of predecessors a basic block can have to be considered during the estimation of dead code'
HFD5552B5CF15: '在估算死程式碼期間，可考慮的基本區塊最大前驅數量'
# 'The maximum number of scheduling group conflicts which we attempt to solve with the exponential time exact solver. Problem sizes greater than this willbe solved by the less accurate greedy algorithm. Selecting solver by size is superseded by manually selecting the solver (e.g. by amdgpu-igrouplp-exact-solver'
H071D666725DB: '我們嘗試用指數時間精確求解器解決的排程組衝突最大數量。大於此問題規模將由較不精確的貪婪演算法解決。根據問題規模選擇求解器會被手動選擇的求解器取代（例如透過amdgpu-igrouplp-exact-solver選項）'
# 'The maximum number of steps while walking upwards to find MemoryDefs that may be killed (default = 90)'
HA207F5C7ADD1: '向上遍歷查找可能被殺死的MemoryDefs時的最大步數（預設值 = 90）'
# 'The maximum number of stored temporal profile traces (default: 100)'
H6A4CCB113506: '可儲存的時間剖面軌跡最大數量（預設：100）'
# 'The maximum number of stores/phis MemorySSAwill consider trying to walk past (default = 100)'
H0C4FBDD67710: 'MemorySSA在嘗試跳過時要考慮的最大儲存/PHI數量（預設值 = 100）'
# 'The maximum number of times a live range can be evicted before preventing it from being evicted'
HEF28AF0C80C6: '活範圍被驅逐的次數達上限後將禁止再次驅逐'
# 'The maximum number of times the analyzer will go through a loop'
H82DC4EFFB765: '分析器遍歷迴圈的最大次數'
# 'The maximum number of vtable for the last candidate.'
H839DD45E9E74: '最後一個候選的vtable最大數量。'
# 'The maximum number of warnings to emit when correlating profile from debug info (0 = no limit)'
H710123CD3CA7: '根據調試資訊關聯剖析時要發出的警告最大數量（0 = 無限）'
# 'The maximum ratio between densities of two chains for merging'
H459D99ED8D7D: '兩條鏈合併時的密度比最大值'
# "The maximum size of a callee that get's inlined without sufficient cycle savings"
H37B172BFF744: '在週期節省不足時，可內聯被調用函數的最大大小'
# 'The maximum size of a chain to apply splitting'
H74E01FDFE4C4: '應用分割時的鏈最大長度'
# 'The maximum size of a chain to create'
H29DFAD1C81AC: '創建時的鏈最大長度'
# 'The maximum size of a function to consider for inference.'
HEC9218936482: '進行推論時函數的最大大小'
# 'The maximum size of an object in the sdata section'
HE9CFD8856EDF: 'sdata段中物件的最大大小'
# 'The maximum size to use in sweep-mode'
HC4DABE2321EB: '使用掃描模式時的最大值'
# 'The maximum stride, considered to be profitable.'
H091F45C95DD9: '在別名集降級前，可包含的記憶體位置總數最低門檻'
# 'The maximum total number of memory locations alias sets may contain before degradation'
H926FBF01198C: '向量融合乘加指令之間兩個依賴連續指令的最小週期數'
# 'The minimal number of cycles between issuing two dependent consecutive vector fused multiply-add instructions.'
H4AA5B2DBB66A: '單一循環區塊的每循環指令數低於此值時，才視為可行'
# 'The minimal number of per-loop instructions before a single loop region is considered profitable'
H4CE0D632999A: '分配被視為熱分配的總存取密度與分配次數比值最低門檻'
# 'The minimum TotalLifetimeAccessDensity / AllocCount for an allocation to be considered hot'
HA94E6199F898: '優化記憶體內建函數調用的最小次數'
# 'The minimum count to optimize memory intrinsic calls'
HEF63EC815D8B: '合併函數所需的最小指令數'
# 'The minimum instruction count required when merging functions.'
HB052AF91D102: '函數調用必須具備的參數數量閾值，超過後才視為參數數量多'
# 'The minimum number of arguments a function call must have before it is considered having many arguments.'
H384F6CF79650: '函數需要執行過期配置文件調用圖匹配所需的最小基本區塊數'
# 'The minimum number of basic blocks required for a function to run stale profile call graph matching.'
H6DFC7FF9B6F4: '函數需要執行過期配置文件調用圖匹配所需的最小調用錨點數'
# 'The minimum number of call anchors required for a function to run stale profile call graph matching.'
HA0900373C45C: '被視為大基本區塊所需的最小指令數'
# 'The minimum number of instructions a basic block should contain before being considered big.'
H35A15684714E: '被視為中等大小基本區塊所需的最小指令數'
# 'The minimum number of instructions a basic block should contain before being considered medium-sized.'
HE3CFEDACCE84: '從框架輔助函數中提煉的最少指令數（預設值=2）'
# 'The minimum number of instructions that are outlined in a frame helper (default = 2)'
HDCE9324580BB: '片段中應包含的最小指令數'
# 'The minimum number of instructions that should be included in the snippet'
HD8B3E130AB22: '片段中應包含的最小指令數量'
# 'The minimum number of loads, which should be considered strided, if the stride is > 1 or is runtime value'
HA691E257E6C6: '如果步長大於 1 或為執行階段值，則需視為具有步長載入的最小載入數量'
# 'The minimum size in bytes before an outlining candidate is accepted'
H382DFDE541E3: '在接納函數外提候選前的最小尺寸（以位元組為單位）'
# 'The minimum size in bytes of each global that should considered in merging.'
HAE0FA4D9E816: '在合併時，每個全域變數應考慮的最小尺寸（以位元組為單位）'
# 'The minimum size to use in sweep-mode'
HA2F6EC5B505C: '在掃描模式下使用的最小尺寸'
# 'The model being trained for register allocation eviction'
H7FEA0D631D24: '用於寄存器分配驅逐的訓練模型'
# 'The model being trained for register allocation priority'
H417CF14D5A6E: '用於寄存器分配優先順序的訓練模型'
# 'The name for this study'
H400FDCCEAC14: '此實驗的名稱'
# 'The name of a function (or its substring) whose CFG is viewed/printed.'
HD3E3246593FE: '要查看或列印其控制流圖的函數（或其子字串）的名稱'
# 'The name of a validation counter to run concurrently with the main counter to validate benchmarking assumptions'
HABCFB9B683CF: '與主計數器並行執行的驗證計數器名稱，用於驗證效能測試假設'
# 'The name of the ABI to be targeted from the backend.'
H3EC72F95FC35: '後端目標的應用二進位介面（ABI）名稱'
# 'The name of the distribution to use'
HF09A01C5BE8E: '要使用的版本名稱'
# 'The name of the executor to use.'
H9A67A8D34CB5: '要使用的執行器名稱'
# "The name of the predefined style used as a\nfallback in case clang-format is invoked with\n-style=file, but can not find the .clang-format\nfile to use. Defaults to 'LLVM'.\nUse -fallback-style=none to skip formatting."
H605E77115F2D: "當以-style=file參數呼叫clang-format但找不到要使用的.clang-format檔案時，用作備用的預定義格式樣式名稱。預設為 'LLVM'。\n使用-fallback-style=none可跳過格式化。"
# 'The name of the struct/class.'
HA728CE8CB2EB: '結構/類別的名稱。'
# 'The name of this group of passes'
HE53A929D4575: '此組Pass的名稱'
# 'The number of MemoryDefs we consider as candidates to eliminated other stores per basic block (default = 5000)'
HB4E81F98BD76: '在每個基本區塊中，我們視為可消除其他存儲的記憶體定義數量（預設值=5000）'
# 'The number of benchmarks run to perform'
H643296C3A4C1: '執行的效能測試次數'
# 'The number of blocks to scan during memory dependency analysis (default = 200)'
HD2242DBDE5D7: '在記憶體依賴性分析期間掃描的區塊數量（預設值=200）'
# 'The number of instructions to scan in a block in memory dependency analysis (default = 100)'
H2BC6010D3D27: '在記憶體依賴性分析期間，每個區塊中掃描的指令數量（預設值=100）'
# 'The number of instructions to search for a redundant dmb'
HD7126DC70D5E: '要搜尋的冗余dmb指令數量'
# 'The number of loads per basic block for inline expansion of memcmp that is only being compared against zero.'
HE7402F9BFD73: '要內聯展開與零比較的memcmp時，每個基本區塊的載入指令數量'
# 'The number of loop iterations to strip-mine for pre-vectorization'
H73D394A3273E: '預向量化時要分割礦採的循環迭代次數'
# 'The number of memory instructions to scan for dead store elimination (default = 150)'
H0D792B752EF6: '要掃描的死記憶體存取消除涉及的記憶體指令數量（預設值 = 150）'
# 'The number of precise steps between two approximating iterations. (A value of -1 schedules another approximation stage before the actual dead code elimination.'
H795458185A22: '兩次近似迭代之間的精確步驟數量。（若值為-1，則在實際的死碼消除前安排另一個近似階段。）'
# 'The number of predecessors to search for a stronger condition to use to thread over a weaker condition'
H7527D41A84C6: '要搜尋用更強條件跨越較弱條件的前驅節點數量'
# 'The number of searches per loop in the window algorithm. 0 means no search number limit.'
H1DDD94D0908A: '在窗口算法中每個循環的搜尋次數。0表示不限制搜尋次數。'
# 'The number of shards into which the op classes will be divided'
H2AD8480DFFBC: '將操作類別分割的分片數量'
# 'The number of threads used to process all files in parallel. Set to 0 for hardware concurrency. This flag only applies to all-TUs.'
H14270C0E6B74: '用以並行處理所有檔案的執行緒數量。設為 0 以使用硬件並發。此選項僅適用於所有翻譯單位。'
# 'The number of times to repeat measurements on the benchmark k before aggregating the results'
HEB3E720640C3: '在聚合結果前，對基准k進行測試時的重複次數'
# 'The option is used to turn on/off warnings about hash mismatch for comdat or weak functions.'
HB9E7F6492359: '此選項用於開啟或關閉COMDAT或弱函數的哈希不匹配警告。'
# 'The option to specify the name of the function whose CFG will be displayed.'
H14BF30CA9694: '指定要顯示其控制流圖的函數名稱。'
# 'The option to specify the name of the function whose block frequency info is printed.'
H669D97AE9C69: '指定要列印其區塊頻率資訊的函數名稱。'
# 'The option to specify the name of the function whose branch probability info is printed.'
H64FA83ADF33F: '指定要列印其分支機率資訊的函數名稱。'
# 'The option to specify the name of the functions to verify.'
H99F22C3FC88F: '指定要驗證的函數名稱。'
# 'The overhead cost associated with each function call when merging functions.'
HFC522517EF09: '合併函數時，每個函數呼叫的相關開銷成本。'
# 'The overhead cost associated with each instruction when lowering to machine instruction.'
H77BF5CB5FA41: '降階為機器指令時，每個指令的相關開銷成本。'
# 'The overhead cost associated with each parameter when merging functions.'
H1DB7993015A4: '合併函數時，每個參數的相關開銷成本。'
# 'The page size of the target in bytes'
H1B53A7D2781D: '目標的頁面大小以位元組為單位'
# 'The percentage threshold against remaining unpromoted indirect call count for the promotion'
HE86B36D2F491: '間接呼叫提升時，剩餘未提升的間接呼叫計數百分比閾值'
# 'The percentage threshold against remaining unpromoted indirect call count for the promotion for calls'
H781076CED89A: '用於間接呼叫的提升的剩餘未提升間接呼叫次數的百分比閾值'
# 'The percentage threshold against remaining unpromoted indirect call count for the promotion for jump tables'
H136B41571D6C: '用於跳轉表的提升的剩餘未提升間接呼叫次數的百分比閾值'
# 'The percentage threshold against total count for the promotion'
H6676D5E1FF86: '用於提升的總次數百分比閾值'
# 'The percentage threshold against total count for the promotion for calls'
H48EACF9E7526: '用於間接呼叫的提升的總次數百分比閾值'
# 'The percentage threshold against total count for the promotion for jump tables'
HA1920C4CE7DC: '用於跳轉表的提升的總次數百分比閾值'
# 'The percentage threshold for the memory intrinsic calls optimization'
HED02E6485AF5: '記憶體內在函數呼叫最佳化的百分比閾值'
# 'The percentage threshold of vtable-count / function-count for cost-benefit analysis.'
H65D337CD6C45: 'vtable計數 / 函式計數的比率閾值，用於成本效益分析。'
# 'The position of the cursor when invoking\nclang-format from an editor integration'
H2456492C399B: '從編輯器整合調用\nclang-format 時游標的位置'
# 'The power exponent for the distance-based locality'
HE2E30EB8297B: '基於距離的局部性權重指數'
# 'The prefix of the dialect extension'
HB374D232EB61: '此組 pass 的前綴。形式將為 mlirCreate<prefix><passname>，此前綴可用於避免不同程式庫的衝突。'
# 'The prefix to use for this group of passes. The form will be mlirCreate<prefix><passname>, the prefix can avoid conflicts across libraries.'
HDCE2477640BC: '控制流圖 (CFG) DOT 檔名的前綴。'
# 'The prefix used for the CFG dot file names.'
H3299C4982B02: '呼叫圖 (CallGraph) DOT 檔名的前綴。'
# 'The prefix used for the CallGraph dot file names.'
HAC819E10CA1B: '資料依賴圖 (DDG) DOT 檔名的前綴。'
# 'The prefix used for the DDG dot file names.'
HF593C1E1F184: '機器控制流圖 (Machine CFG) DOT 檔名的前綴。'
# 'The prefix used for the Machine CFG dot file names.'
H54988740C957: '假設 guard 失效的機率是此值的倒數（預設值 = 1 << 20）'
# 'The probability of a guard failing is assumed to be the reciprocal of this value (default = 1 << 20)'
H54F7AFA0E05B: '啟用分支提示的機率閾值'
# 'The probability threshold of enabling branch hint.'
HDA416C9E705B: '配置文件引導型大小優化的剖析資料摘要截斷值（用於插樿剖析）'
# 'The profile guided size optimization profile summary cutoff for instrumentation profile.'
H416C25DD1085: '配置文件引導型大小優化的剖析資料摘要截斷值（用於抽樣剖析）'
# 'The profile guided size optimization profile summary cutoff for sample profile.'
H7CFAC61196B3: '窗口演算法中每迴圈的搜尋比率。100 表示在迴圈中搜尋所有位置，而 0 表示不進行任何搜尋。'
# 'The ratio of searches per loop in the window algorithm. 100 means search all positions in the loop, while 0 means not performing any search.'
H69F36D760102: '視窗演算法中每次迴圈的搜尋次數比例。100 表示搜尋迴圈中所有位置，而 0 表示不進行任何搜尋。'
# 'The relative/absolute file path of new cc.'
HE0F45871CC31: '新.cc 檔案的相對/絕對檔案路徑'
# 'The relative/absolute file path of new header.'
H4D4C2CCB6DC7: '新標頭檔的相對/絕對檔案路徑'
# 'The relative/absolute file path of old cc.'
H9627E5223A5E: '舊.cc 檔案的相對/絕對檔案路徑'
# 'The relative/absolute file path of old header.'
H13E40B3B27E1: '舊標頭檔的相對/絕對檔案路徑'
# 'The relocation model to use'
H8DE955C1B327: '要使用的重新定位模型'
# 'The sample period (nbranches/sample), used for LBR sampling'
H61D3CFB88363: 'LBR 選取採樣使用的採樣週期（nbranches/採樣）'
# 'The scale factor for the frequency-based locality'
H4C2907D8364D: '基於頻率的局部性縮放因子'
# 'The scale factor used to scale the working set size of the partial sample profile along with the partial profile ratio. This includes the factor of the profile counter per block and the factor to scale the working set size to use the same shared thresholds as PGO.'
H7BF4A788068D: '用來縮放部分樣本剖面的工作集大小的縮放因子，包含每個區塊的剖面計數器因子，以及縮放部分樣本比率以使用與 PGO 相同共享閾值的因子。此設定同時包含部分樣本剖面的工作集大小縮放。'
# 'The seed used by the randomize structure layout feature'
H3D8BA8E60ECF: '隨機化結構布局功能所使用的種子'
# 'The selected source range in which the refactoring should be initiated (<file>:<line>:<column>-<line>:<column> or <file>:<line>:<column>)'
H9B806B9A88F2: '在其中啟動重构的已選取來源範圍（格式為<檔案>:<列>:<欄>-<列>:<欄> 或 <檔案>:<列>:<欄>）'
# 'The size growth ratio limit for proirity-based sample profile loader inlining.'
H93A8BBE0A03D: '基於優先順序的樣本剖面載入器內嵌的大小增長比率限制'
# "The size in bits of a vector register (if not set, this information is taken from LLVM's target information."
H4457D4EEB097: '向量寄存器的位元大小（如果未設定，則從 LLVM 的目標資訊中取得）'
# 'The size of a line in the cache'
H3FC377B654FB: '快取記憶體列大小（以位元組為單位）'
# 'The size of the cache'
H1AFA9403E784: '快取記憶體大小（以位元組為單位）'
# 'The size of the first cache level specified in bytes.'
H79C5863504EE: '以位元組為單位指定的第一層快取大小。'
# 'The size of the first level cache line size specified in bytes.'
H0A19D3F7EF60: '以位元組為單位指定的第一層快取列大小。'
# 'The size of the second level specified in bytes.'
HE64C9129467C: '以位元組為單位指定的第二層快取大小。'
# 'The string to embed in the .LLVM.command.line section.'
H96651B0831DF: '要嵌入到 .LLVM.command.line 區段中的字串'
# 'The string to embed in the Dwarf debug AT_producer record.'
H309333DFFAC0: '要嵌入到 Dwarf 除錯 AT_producer 紀錄中的字串'
# 'The string to embed in the Dwarf debug flags record.'
H8A887C2C292E: '要嵌入到Dwarf調試標誌記錄中的字串。'
# 'The style name used for reformatting.'
H6C1DBF661954: '用於重新格式化的樣式名稱。'
# 'The style name used for reformatting. Default is "llvm"'
H6E46319C3C34: '用於重新格式化的樣式名稱。預設值為「llvm」'
# 'The summary file to use for function importing.'
H956C0535484D: '用於函數導入的摘要檔。'
# 'The target Objective-C runtime supports ARC weak operations'
HDFF376EEF6B3: '目標Objective-C執行階段支援ARC弱運算'
# 'The text prefix to use for cold basic block clusters'
H9A41E3E09F36: '用於冷基本區塊群集的文字前綴'
# "The thread model to use. Defaults to 'posix')"
HBBA4CDE4A320: '要使用的執行緒模型。預設值為「posix」'
# 'The threshold (unit M) for flushing LLVM bitcode.'
H38AA697B02D6: '用於刷新LLVM位元碼的門檻值（單位M）。'
# 'The threshold for fast cluster'
HC068F875B090: '快速群集的門檻值。'
# 'The threshold for splitting a virtual register with a hint, in percentage'
H722FAD4D0C5E: '根據提示分割虛擬寄存器的門檻值（百分比）。'
# 'The threshold the lifetime access density (accesses per byte per lifetime sec) must be under to consider an allocation cold'
HDA979A1E26A3: '若要將分配視為冷門，存取密度（每字節每生命周期秒的存取次數）必須低於此門檻值。'
# 'The type of aggregation to do on call stacks.'
H148D7C9D6F12: '在呼叫堆疊上要執行的聚合類型。'
# 'The type of output desired'
HD9FFCDBCB5F5: '所需的輸出類型。'
# 'The upper bound of size growth limit for proirity-based sample profile loader inlining.'
H4AEDA738C805: '基於優先級的樣本剖面載入器內嵌的大小增長上限。'
# 'The upper limit of II in the window algorithm.'
H6259F5DF8819: '在窗口演算法中的II上限制。'
# 'The value specified in simdlen must be a power of 2 when targeting Advanced SIMD.'
HAAC03787F717: '在針對Advanced SIMD目標時，simdlen指定的值必須是 2 的冪次。'
# 'The vectorization factor for byte-compare patterns.'
H892AED0C291C: '位元組比較模式的向量化係數。'
# 'The vectorization style for loop idiom transform.'
HEB4892D4C0B2: '迴圈語法轉換的向量化風格。'
# 'The version of darwin target variant SDK used for compilation'
H11C241DE938D: '用於編譯的darwin目標變體SDK版本。'
# 'The version of target SDK used for compilation'
H4C1FC7BD91CD: '用於編譯的目標SDK版本。'
# 'The visibility for definitions without an explicit DLL storage class. If Keep is specified the visibility is not adjusted [-fvisibility-from-dllstorageclass]'
H5B42685299F4: '未指定明確DLL儲存類別的定義之可見性。若指定Keep，則不會調整可見性 [-fvisibility-from-dllstorageclass]'
# 'The visibility for dllexport definitions. If Keep is specified the visibility is not adjusted [-fvisibility-from-dllstorageclass]'
H89FA30D717F3: 'dllexport定義的可見性。若指定Keep，則不會調整可見性 [-fvisibility-from-dllstorageclass]'
# 'The visibility for dllimport external declarations. If Keep is specified the visibility is not adjusted [-fvisibility-from-dllstorageclass]'
H67F478EEEC59: 'dllimport外部宣告的可見性。若指定Keep，則不會調整可見性 [-fvisibility-from-dllstorageclass]'
# 'The visibility for external declarations without an explicit DLL storage class. If Keep is specified the visibility is not adjusted [-fvisibility-from-dllstorageclass]'
H64D964A1CD05: '未指定明確DLL儲存類別的外部宣告之可見性。若指定Keep，則不會調整可見性 [-fvisibility-from-dllstorageclass]'
# "The visibility for global C++ operator new and delete declarations. If 'source' is specified the visibility is not adjusted"
H9A7A28615088: '全域C++運算符new和delete宣告的可見性。若指定「source」，則不會調整可見性'
# 'The weight of backward jumps for ExtTSP value'
H0E7F2365F191: 'ExtTSP值中後向跳轉的權重'
# 'The weight of conditional backward jumps for ExtTSP value'
H1A51FA791B5C: 'ExtTSP值中條件式後向跳轉的權重'
# 'The weight of conditional fallthrough jumps for ExtTSP value'
H17243DA21A4A: 'ExtTSP值中條件式穿透式跳轉的權重'
# 'The weight of conditional forward jumps for ExtTSP value'
H37AE1F715474: 'ExtTSP值中條件式前向跳轉的權重'
# 'The weight of unconditional backward jumps for ExtTSP value'
HF65A2E202044: 'ExtTSP值中無條件後向跳轉的權重'
# 'The weight of unconditional fallthrough jumps for ExtTSP value'
HAE55A03F6662: 'ExtTSP值中無條件穿透式跳轉的權重'
# 'The weight of unconditional forward jumps for ExtTSP value'
HAB44DC9D2D01: 'ExtTSP值中無條件前向跳轉的權重'
# 'These control extra attributes that are added when the element is printed.'
HB2159F65700A: '這些控制在列印元素時新增的額外屬性。'
# 'These control how the elements are printed.'
H28147009F248: '這些控制元素的列印方式。'
# 'These control the generated warnings.'
H7F9E68DBF772: '這些控制生成的警告訊息。'
# 'These control the output generated.'
HFE9BA932DCA9: '這些控制產生的輸出。'
# 'These control the view comparison.'
H014A13BA2172: '這些控制視圖比較的方式。'
# 'These control which elements are printed.'
H47E80A7E5CE7: '這些控制要列印的元素。'
# 'These control which elements are selected.'
H093D8C9A169D: '這些控制要選取的元素。'
# 'These control which sections are dumped. Where applicable these parameters take an optional =<offset> argument to dump only the entry at the specified offset.'
H4A05AC913F89: '這些控制要轉儲的區段。在適用的情況下，這些參數可選用= <offset> 參數以僅轉儲指定偏移量處的條目。'
# 'ThinLink: produces the index by linking only the summaries.'
H0F627A52D002: 'ThinLink：僅連結摘要以產生索引。'
# "This appends the content hash to the globally outlined function name. It's beneficial for enhancing the precision of the stable hash and for ordering the outlined functions."
H53B60C3E684B: '此選項會將內容雜湊附加到全域展開函數的名稱。這有助於提高穩定雜湊的精確度，並對展開函數進行排序。'
# 'This argument does not take a value.\n\tInstead, it consumes any positional arguments until the next recognized option.'
H3C3E5BFE7ADE: '此參數不接受值。\n\t相反，它會消耗所有位置參數直到下一個已識別選項。'
# 'This checks if there is a fdo instr. profile hash mismatch for this function'
HFBA287CE45D4: '此選項用於檢查此函數是否存在fdo插樁剖析雜湊不匹配。'
# 'This compilation is part of building a PCH with corresponding object file.'
H26F9EC33106E: '此編譯是建立具有對應物件檔的PCH的一部分。'
# 'This flag controls the behaviour of fcmp equality comparisons.For equality comparisons such as `x == 0.0f`, we can perform the '
HF143A3F023BD: '此旗標控制fcmp等值比較的行為。對於等值比較（例如`x == 0.0f`），我們可以執行'
# 'This is the default. TOC data transformation is not applied to any variables. Only variables specified explicitly in -mtocdata= will have the TOC data transformation.'
HEF7B686F6202: '此為預設。TOC資料轉換不會套用至任何變數。只有明確指定在- mtocdata=中的變數會進行TOC資料轉換。'
# 'This option is for testing purposes only. It forces BOLT to convert low_pc/high_pc to ranges always.'
H46D236F6D0BE: '此選項僅用於測試。它會強制BOLT始終將low_pc/high_pc轉換為區間。'
# "Thread pointer access method. For AArch32: 'soft' uses a function call, or 'tpidrurw', 'tpidruro' or 'tpidrprw' use the three CP15 registers. 'cp15' is an alias for 'tpidruro'. For AArch64: 'tpidr_el0', 'tpidr_el1', 'tpidr_el2', 'tpidr_el3' or 'tpidrro_el0' use the five system registers. 'elN' is an alias for 'tpidr_elN'."
H7A1A2BC28705: "線程指標存取方式。對於AArch32：'soft' 使用函式呼叫，而 'tpidrurw'、'tpidruro' 或 'tpidrprw' 使用三個CP15寄存器。'cp15' 是 'tpidruro' 的別名。對於AArch64：'tpidr_el0'、'tpidr_el1'、'tpidr_el2'、'tpidr_el3' 或 'tpidrro_el0' 使用五個系統寄存器。'elN' 是 'tpidr_elN' 的別名。"
# 'Threshold (in bytes) for the runtime check guarding the memmove.'
HD35FCD3FC79E: '運行階段檢查用以保護memmove的閾值（以位元組為單位）。'
# 'Threshold (in bytes) to perform the transformation, if the runtime loop count (mem transfer size) is known at compile-time.'
H1AD5098411FA: '若運行階段迴圈計數（記憶體傳輸大小）在編譯階段已知，則執行轉換的閾值（以位元組為單位）。'
# 'Threshold (max size of unrolled loop) to use in aggressive (O3) optimizations'
H18A6C6D55082: '在激進（O3）優化中使用的循環展開閾值（最大未展開循環大小）。'
# 'Threshold for hot callsites '
H362D13EBB118: '熱呼叫點的閾值'
# 'Threshold for inlining addition operands into a SCEV'
HB303871617D0: '內聯至SCEV加法操作元的閾值'
# 'Threshold for inlining cold callsites'
H250BE680BE10: '內聯冷呼叫點的閾值'
# 'Threshold for inlining functions with cold attribute'
H574FD1578D90: '內聯具有冷屬性的函數的閾值'
# 'Threshold for inlining functions with inline hint'
H393692A6F6FF: '內聯具有內聯提示的函數的閾值'
# 'Threshold for inlining multiplication operands into a SCEV'
H07C5BF953E30: '內聯至SCEV乘法操作元的閾值'
# 'Threshold for locally hot callsites '
H1A9D72E0CF73: '局部熱呼叫點的閾值'
# 'Threshold for partial unrolling'
H6543FABE0767: '部分展開的閾值'
# 'Threshold for switching to iteratively computing SCEV ranges'
H887AD3A95DC6: '切換為迭代計算SCEV範圍的閾值'
# 'Threshold for the size of CSUses'
H30C9036D7937: 'CSUses大小的閾值'
# 'Threshold for triggering vextract replacement'
HF1A005DB3C4F: '觸發vextract取代的閾值'
# 'Threshold to use for inner loop when doing unroll and jam.'
HE4FFB8758E97: '執行unroll and jam時內層迴圈使用的閾值'
# 'Thumb IT blocks insertion pass'
HD5E87C90A3F2: 'Thumb IT區塊插入管線'
# 'Thumb2 instruction size reduce pass'
HDFB1F7BB57C2: 'Thumb2指令大小縮減管線'
# 'Tile Copy Lowering'
HD512AA776C9C: 'Tile複製降階'
# 'Tile Register Configure'
HE55B620CE39A: 'Tile記憶體配置'
# 'Tile Register Pre-configure'
H093374BD2768: 'Tile記憶體預配置'
# 'Tile size for matrix instruction fusion using square-shaped tiles.'
H77BEE628E9E0: '使用方形tile進行矩陣指令融合的tile大小。'
# 'Tilikum Crossing Optimizer\n'
H56081A939218: 'Tilikum Crossing優化器\n'
# 'Time each pass run, printing elapsed time for each run on exit'
H9DEAE5CE8A5D: '計時每個pass的執行時間，退出時列印各次執行的耗時'
# 'Time each pass, printing elapsed time for each on exit'
H6752B4F3ED5A: '計時每個pass，退出時列印各個的耗時'
# 'Time individual commands'
H84A9CD566359: '計時個別指令'
# 'Time phases of parser and backend'
HC89B41C0C2D0: '計時解析器和後端的階段'
# 'Time to be used in __DATE__, __TIME__, and __TIMESTAMP__ macros'
H972ECB48D75B: '在__DATE__、__TIME__和__TIMESTAMP__宏中使用的時間'
# 'Time when the current build session started'
H702F4D424F4D: '當前編譯會話開始的時間'
# 'Tiny code model'
H84F95E67A022: '小型程式模型'
# 'Tool Options'
HCB6E15CE20D4: '工具選項'
# 'Tool options'
H6AA40067A445: '工具選項'
# 'Tool used for detecting AMD GPU arch in the system.'
HF986F57FE389: '用於在系統中偵測AMD GPU架構的工具。'
# 'Tool used for detecting NVIDIA GPU arch in the system.'
H3CE78A0FD186: '用於在系統中偵測NVIDIA GPU架構的工具。'
# 'Toolchain identification name.'
H577F665D266E: '工具鏈識別名稱。'
# 'Toplevel siblings divisor for cost multiplier.'
H47B1D12D6302: '頂層兄弟的除數用於成本乘數。'
# 'Total samples cutoff for functions used to calculate profile density.'
H4F0CF57C68FB: '用於計算剖析密度的函數總樣本截止值。'
# 'Total size of all blocks (including zero-fill) in all graphs (post-fixup)'
HA9F2ACABE207: '(後處理修正) 所有圖形中所有區塊(包含零填充)的總大小'
# 'Total size of all blocks (including zero-fill) in all graphs (pre-pruning)'
H33F7C5E01044: '(預修剪) 所有圖形中所有區塊(包含零填充)的總大小'
# 'Trace global value placement'
H3F11F16F204E: '追蹤全域值的配置'
# 'Trace the hash of the function with this name.'
H2FA3F2871F69: '追蹤具有此名稱函數的雜湊值。'
# 'Traces to enable.'
H5DD3783FD8E4: '要啟用的追蹤。'
# 'Tracing of CMP and similar instructions'
H46B2C1DD8A24: '追蹤CMP和其他類似指令'
# 'Tracing of DIV instructions'
H6C4B7FBBDB1C: '追蹤DIV指令'
# 'Tracing of GEP instructions'
H9495E0A41197: '追蹤GEP指令'
# 'Tracing of load instructions'
H9296E34AACB7: '追蹤載入指令'
# 'Tracing of store instructions'
HD37453D2BD66: '追蹤儲存指令'
# 'Track failure strings in detecting scop regions'
HA2AAD146A60C: '追蹤偵測 scop 區域時的失敗字串。'
# 'Track origins (allocation sites) of poisoned memory'
H3D9C4DED10A1: '追蹤中毒記憶體的來源（分配位置）'
# 'Track origins of labels'
H6DEEA7E74FFD: '追蹤標籤的來源'
# 'Track reg pressure and switch priority to in-depth'
HD40E656EBBE9: '追蹤寄存器壓力並將優先級切換為深入'
# 'Track the overflow bit if requested.'
H6AA670469C83: '如果請求，則追蹤溢位位元。'
# 'Training log for the register allocator eviction model'
H6E2B0424977E: '寄存器分配器驅逐模型的訓練日誌'
# 'Training log for the register allocator priority model'
HDBA649A1B080: '寄存器分配器優先順序模型的訓練日誌'
# 'Transform functions to use DSP intrinsics'
H926BA6FE32A4: '將函數轉換為使用DSP內在函數'
# "Transitional flag to turn off NVPTX's requirement on preserving structured CFG. The requirement should be disabled only when unexpected regressions happen."
H280C497E1DC8: '轉換期標誌，用於關閉NVPTX對保留結構化控制流程圖（CFG）的要求。此要求僅在出現意外回退時才應禁用。'
# 'Translations to perform'
HD6F4D5A5B7BD: '要執行的轉換'
# 'Trap on integer division by zero.'
HDD1ADB807B39: '當整數除以零時觸發陷阱'
# 'Trap on integer overflow'
H912BF1C6F685: '當整數溢出時觸發陷阱'
# 'Trap when incorrect'
H9EC2646A38E0: '當錯誤時觸發陷阱'
# 'Treat <file> as C source file'
H5AAFC1A35AEE: '將 <file> 視為C源文件'
# 'Treat <file> as C++ source file'
H467B7FCAE3B7: '將 <file> 視為C++源文件'
# 'Treat INCLUDE lines like #include directives in -E mode'
H8BB5A80B42A6: '在-E模式下將INCLUDE行視為#include指令'
# 'Treat all #include paths starting with <prefix> as including a system header.'
H4CD79E350724: '將所有以 <prefix> 開頭的#include路徑視為包含系統標頭。'
# 'Treat all #include paths starting with <prefix> as not including a system header.'
H7FC347478B10: '將所有以 <prefix> 開頭的#include路徑視為不包含系統標頭。'
# 'Treat all parameters to functions that are pointers as dereferencible. This is useful for invariant load hoisting, since we can generate less runtime checks. This is only valid if all pointers to functions are always initialized, so that Polly can choose to hoist their loads. '
H01E314D59C27: '將所有函數的指標參數視為可解引用的。這對不變負載提升很有用，因為可以減少執行階段檢查。此選項僅在所有函數指標始終已初始化的情況下有效，這樣Polly可以選擇提升這些載入。'
# 'Treat all source files as C'
H55FA85BDA2A5: '將所有源文件視為C'
# 'Treat all source files as C++'
H7EEC5BB50052: '將所有源文件視為C++'
# 'Treat any <pattern> strings as regular expressions when selecting instead of just as an exact string match.'
HB8CFB19C5C18: '選擇時將任何 <pattern> 字串視為正則表達式，而非精確字串匹配'
# 'Treat each comma separated argument in <arg> as a documentation comment block command'
HCB49DF1FFB5A: '將 <arg> 中的每個逗號分隔參數視為文檔註釋區塊命令'
# 'Treat editor placeholders as valid source code'
H5F226C718000: '將編輯器佔位符視為有效源代碼'
# "Treat fixed form lines with 'd' or 'D' in the first column as blank."
HADC0D4FE88CA: "將固定格式中第一列為 'd' 或 'D' 的行視為空白行。"
# "Treat fixed form lines with 'd' or 'D' in the first column as comments."
H3F2B7A8C2293: "將第一個字符為 'd' 或 'D' 的固定格式行視為註解。"
# 'Treat hip and hipv4 offload kinds as compatible with openmp kind, and vice versa.\n'
HC9954ACD9B9E: '將hip和hipv4卸載類型視為與openmp類型兼容，反之亦然。\n'
# 'Treat input as a PDB file (default)'
H24602D862E82: '將輸入視為PDB文件（預設）'
# 'Treat input as raw contents of /names named stream'
H2F74766FAAE9: '將輸入視為/names命名流的原始內容'
# 'Treat input as raw contents of DBI stream'
H56798B0B0190: '將輸入視為DBI流的原始內容'
# 'Treat input as raw contents of PDB stream'
H6E74D779FAE8: '將輸入視為PDB流的原始內容'
# 'Treat input as raw contents of a module stream'
H720BDBA3C128: '將輸入視為模塊流的原始內容'
# 'Treat issues where a fixed-width property is requested from a scalable type as a warning, instead of an error'
HE3ED92F98BA0: '將從可伸縮類型中請求固定寬度屬性所引發的問題視為警告，而非錯誤'
# "Treat pointer overflow as two's complement"
HF00886F33282: '將指針溢出視為二補數'
# "Treat signed integer overflow as two's complement"
H1BAF0BBFDBF6: '將有符號整數溢出視為二補數'
# 'Treat source input files as Objective-C inputs'
H10D7DE6018B0: '將來源輸入文件視為Objective-C輸入'
# 'Treat source input files as Objective-C++ inputs'
HF4443D8F9187: '將來源輸入文件視為Objective-C++輸入'
# 'Treat stack lifetimes as starting on first use, not on START marker.'
H1D5DFE08E7A8: '將堆疊生命周期的起始點視為首次使用時，而非START標記處'
# 'Treat string literals as const'
H79E1F4486D77: '將字串字面量視為const'
# 'Treat subsequent input files as having type <language>'
HC2DB15026570: '將後續輸入文件視為具有 <language> 類型'
# 'Treat usage of null pointers as undefined behavior (default)'
HEF76E5F5F913: '將空指標的使用視為未定義行為（預設）'
# 'Treat warnings as errors'
H518C417B2786: '將警告視為錯誤'
# 'Trim cold functions until profile size is below specified limit in bytes. This uses a heursitic and functions may be excessively trimmed'
H9C86C77C9C88: '修剪冷函數，直到剖析大小小於指定的字節限制。此操作使用启发式方法，函數可能被過度修剪'
# 'Trim context sample profiles whose count is below cold threshold'
HD98B893B0D67: '修剪計數低於冷閾值的上下文樣本剖析'
# 'Triple default EABI version'
H929ED20C3916: 'Triple 預設的 EABI 版本'
# 'Triple to use to serialize to cubin.'
HCE48A7F9471E: '用於序列化至 cubin 的 Triple'
# 'Try emitting Compact-Unwind for non-canonical entries. Maybe overridden by other constraints'
H3E74499232A9: '嘗試為非標準條目發射 Compact-Unwind。可能被其他限制覆寫'
# 'Try hoisting constant gep expressions'
HEBF48C3AF674: '嘗試提升常數 gep 表達式'
# 'Try to avoid heapifying local blocks'
HD9B64861AC5A: '嘗試避免將本地區塊堆化'
# 'Try to avoid reuse of byte array addresses using aliases'
HD4627CAE2B4C: '嘗試使用別名避免重用字元串地址'
# 'Try to construct schedules where the outer member of each band satisfies the coincidence constraints (yes/no)'
H60DF39720CB5: '嘗試構建每個帶的外層成員滿足巧合約束的排程（是/否）'
# 'Try to delinearize array references.'
H2EA0163561FB: '嘗試將陣列引用去線性化'
# 'Try to evenly distribute flow when there are multiple equally likely options.'
HAEBC34FD2276: '當有多個可能性相等的選項時，嘗試均勻分配流程'
# 'Try to propagate nonnull argument attributes from callsites to caller functions.'
H020E4D562B19: '嘗試將呼叫點的 nonnull 參數屬性傳播到呼叫函數'
# 'Try to simplify all loads.'
HBDC33CA86746: '嘗試簡化所有 loads'
# 'Try to vectorize with non-power-of-2 number of elements.'
H0125A5F09D1C: '嘗試以非 2 的冪次數元素進行向量化'
# 'Try wider VFs if they enable the use of vector variants'
H26EA4E292B56: '如果更寬的 VFs 可以使用向量變體，則嘗試使用'
# 'Tune debug info for a particular debugger'
H77BC7AA0BB02: '調整特定除錯器的除錯資訊'
# 'Tune for a specific cpu type'
H3345FF3520DA: '針對特定 CPU 類型進行調整'
# 'Turn all knobs to 11'
H1AC91DEDAC4E: '將所有控制項調至最大（11）'
# 'Turn fastcc calls into tail calls by (potentially) changing ABI.'
HF62148DE9C4D: '通過可能更改 ABI 的方式，將 fastcc 呼叫轉換為尾端呼叫'
# 'Turn off Type Based Alias Analysis'
H63440B325F63: '關閉基於類型的別名分析（TBAA）'
# 'Turn off loop unroller'
H0C19FC5B8215: '關閉循環展開（Loop Unroller）'
# 'Turn off sparse parallelization.'
H32757C1F23A6: '關閉稀疏並行化'
# 'Turn off struct-path aware Type Based Alias Analysis'
H8E0ED82C6CEB: '關閉結構路徑感知的類型基於別名分析'
# 'Turn off window algorithm.'
H6D475479FF1D: '關閉視窗演算法。'
# 'Turn on DominatorTree and LoopInfo verification after Loop Distribution'
H14C9F8E485D6: '開啟循環分佈後的支配樹和循環資訊驗證'
# 'Turn on loop unroller'
H189401528396: '開啟循環展開器'
# 'Turn on module map output and specify output path or file name. If no path is specified and if prefix option is specified, use prefix for file path.'
H6B0988247E72: '開啟模組地圖輸出，並指定輸出路徑或檔名。若未指定路徑且已指定prefix選項，則使用prefix作為檔路徑。'
# 'Turn on runtime checks for various forms of undefined or suspicious behavior. See user manual for available checks'
H44BD445B1D2C: '開啟對未定義或可疑行為的多種執行階段檢查。參閱使用者手冊以了解可用檢查'
# 'Turn on time profiler. Generates JSON file based on output filename.'
H605BD513ED60: '開啟時間分析器。根據輸出檔名產生JSON檔案。'
# 'Turns on stale matching with block pseudo probes.'
HFFCF05795EA6: '啟用區塊虛擬探針的陳舊匹配。'
# 'Two-Address instruction pass'
HD8164AEBCCB3: '兩地址指令pass'
# 'Type Options'
H7C8D98E334E0: '類型選項'
# 'Type Promotion'
H4F87D1DD8D47: '類型提升'
# 'Type Record Options'
H979D586C9237: '類型紀錄選項'
# 'Type definition.'
H37A26D2D1A2C: '類型定義。'
# 'Type kind to use when printing types.'
H3F4786926275: '印刷類型時使用的類型類別'
# 'Type of checking for incorrect devirtualizations'
HB2F8536F04B5: '檢查不正確虛擬化解析的類型'
# 'Type of symbols to dump (default all)'
HDEE9A9BDCFC8: '要傾印的符號類型（預設全部）'
# 'Type of the files to be bundled/unbundled.\nCurrent supported types are:\n  i    - cpp-output\n  ii   - c++-cpp-output\n  cui  - cuda-cpp-output\n  hipi - hip-cpp-output\n  d    - dependency\n  ll   - llvm\n  bc   - llvm-bc\n  s    - assembler\n  o    - object\n  a    - archive of objects\n  gch  - precompiled-header\n  ast  - clang AST file'
H23DE32DB4F4F: '要封裝或解封的文件類型。\n目前支援的類型包括：\n  i    - cpp輸出\n  ii   - c++-cpp輸出\n  cui  - cuda-cpp輸出\n  hipi - hip-cpp輸出\n  d    - 依賴\n  ll   - llvm\n  bc   - llvm-bc\n  s    - 組合語言\n  o    - 物件\n  a    - 物件庫\n  gch  - 預編譯標頭\n  ast  - clang AST 檔案'
# 'Type-Based Alias Analysis'
H432902366273: '類型基於別名分析'
# 'Types (Pointer, Reference, etc.).'
H09ADEF8BEED1: '類型（指標、參照等）。'
# 'Types.'
H1145E1A9F2E2: '類型。'
# 'UNKOWN'
HD91DF451ADF1: '未知'
# 'USAGE: '
H4060E2625813: '用法： '
# 'Unbundle bundled file into several output files.\n'
H1DD69F0F0D6F: '解包捆綁文件為多個輸出文件。\n'
# 'Unconditionally apply unchecked-ld-st optimization (even for large stack frames, or in the presence of variable sized allocas).'
H26BF316F7B25: '無條件應用未經檢查的unchecked-ld-st優化（即使對大堆棧框架，或存在可變大小的alloca時）'
# 'UndName Options'
H2ACB6A59624D: 'UndName 選項'
# 'Undefine macro'
H85ECFBA229C4: '取消定義宏'
# 'Undefine macro <macro>'
HE9FB0C5A98C8: '取消定義宏 <macro>'
# 'Undefined / no particular sort order'
H2DF8FA5D8D5C: '未定義/無特定排序順序'
# 'Undefines the __DEPRECATED macro'
HFAB714AB2388: '取消定義 __DEPRECATED 宏'
# 'Underlying type for type definitions.'
HE810C104AEFC: '類型定義的基礎類型。'
# 'Unexpected vftable component type %0 for component number %1'
H40151C08E668: '元件編號 %1 的虛函數表元件類型 %0 不正確'
# 'Uniformity Analysis'
H18CD82918982: '均勻性分析'
# 'Unify divergent function exit nodes'
H8B72079558B4: '統一不同函數出口節點'
# 'Unify multiple OpenCL metadata due to linking'
H1E880963D2AC: '因連結而統一多個OpenCL元數據'
# 'Union.'
H8AC81596AB6F: '聯結體。'
# 'Uniqueify Internal Linkage Symbol Names by appending the MD5 hash of the module path'
HE20B29760EEF: '透過追加模組路徑的MD5雜湊值來唯一化內部連結符號名稱'
# 'Unpack machine instruction bundles'
H6975BC91D598: '解包機器指令捆綁'
# 'Unparse and stop (skips the semantic checks)'
HB65257706E07: '反解析並停止（跳過語法檢查）'
# 'Unparse and stop.'
H8A6570E46B2D: '反解析並停止。'
# 'Unparse with dependent modules and stop.'
HDFEBDFAE4C78: '與相關模組一起反解析並停止。'
# 'Unparse with symbols and stop.'
H0D9F89477381: '以符號反解析並停止。'
# 'Unroll factor (affecting 4x32-bit operations) to use for memory operations when lowering memcpy as a loop'
HE43C43B147A4: '將 memcpy 轉換為循環時記憶體作業的展開因子（影響 4x32 位元運算）'
# 'Unroll loops'
H14907BD20FBA: '展開迴圈'
# 'Unroll loops with run-time trip counts'
H094122EA378B: '展開具有執行階段迴圈次數的迴圈'
# 'Unroll threshold for AMDGPU if local memory used in a loop'
H9E766FE7E2B8: '若循環中使用本地記憶體，AMDGPU 的展開閾值'
# 'Unroll threshold for AMDGPU if private memory used in a loop'
HAC396B9BAD8B: '若循環中使用私有記憶體，AMDGPU 的展開閾值'
# 'Unroll threshold increment for AMDGPU for each if statement inside loop'
H93579CFAA697: '<AMDGPU 範疇> 當循環內部有條件語句時的展開閾值增量'
# 'Unrolled size limit for loops with an unroll(full) or unroll_count pragma.'
H455348AAE5AE: '具有unroll(full)或unroll_count pragma的循環的展開大小限制。'
# 'Unrolled size limit for loops with an unroll_and_jam(full) or unroll_count pragma.'
H83703E1D1FC8: '具有unroll_and_jam(full)或unroll_count pragma的循環的展開大小限制。'
# 'Unspecified parameter.'
H12B0F3A3DD19: '未指定的參數。'
# 'Unspecified type.'
HEE55D6208E96: '未指定的類型。'
# 'Unwind library to use'
HAF3990494241: '要使用的堆疊展開函式庫'
# 'Uop Decomposition'
H84228E8F31C8: 'Uop 分解'
# 'Update pseudo probe distribution factor'
H95A61EF626F6: '更新偽探針分佈係數'
# 'Update total samples by accumulating all its body samples.'
H4ABB921FD931: '透過累加所有內部樣本來更新總樣本數。'
# 'Use #line in preprocessed output'
H61A0DD59549D: '在預處理輸出中使用 #line'
# "Use 'mips.ccmov' instruction"
HDC01AC60098B: '使用 "mips.ccmov" 指令'
# 'Use -compile-command to define a command to compile the bitcode. Useful to avoid linking.'
H45B889E18E9F: '使用 -compile-command 定義用於編譯位元碼的指令。用於避免連結。'
# 'Use -exec-command to define a command to execute the bitcode. Useful for cross-compilation.'
HBBC97C4993AA: '使用 -exec-command 定義用於執行位元碼的指令。適用於交叉編譯。'
# 'Use .ctors instead of .init_array.'
HEFD53B18D4A2: '使用.ctors代替.init_array。'
# 'Use .ctors/.dtors instead of .init_array/.fini_array'
H89195E513795: '使用.ctors/.dtors代替.init_array/.fini_array'
# 'Use .file directives with an explicit directory'
H9DEC86EE53C8: '使用帶有明確目錄的.file指令'
# 'Use 16-bit hardware multiplier'
HE39242B4C409: '使用 16 位元硬體乘法器'
# 'Use 32-bit floating point registers (MIPS only)'
HE9E46E3267C7: '使用 32 位元浮點寄存器（僅MIPS）'
# 'Use 32-bit hardware multiplier'
H48A0735D6EC9: '使用 32 位元硬體乘法器'
# 'Use 32-bit pointers for accessing const/local/shared address spaces'
HEBB1FFB0999C: '使用 32 位元指標存取const/local/shared地址空間'
# 'Use 32-bit pointers for accessing const/local/shared address spaces.'
H1C423A27FAD4: '使用 32 位元指標存取const/local/shared地址空間。'
# 'Use 64-bit floating point registers (MIPS only)'
H4492AB59FFA0: '使用 64 位元浮點寄存器（僅MIPS）'
# 'Use <dumpfpx> as a prefix to form auxiliary and dump file names'
H3DFDBA26A67C: '使用 <dumpfpx> 作為前綴來形成輔助和dump文件名稱'
# 'Use <suffix> as the suffix for module files (the default value is `.mod`)'
H0754CF14DB5E: '使用 <suffix> 作為模組文件的後綴（預設值為`.mod`）'
# 'Use <value> as character line width in fixed mode'
HAF90606EAD0C: '在固定模式下使用 <value> 作為字符行寬'
# 'Use ANSI escape codes for diagnostics'
HF4E88E8746F8: '使用ANSI轉義碼進行診斷'
# "Use Apple's kernel extensions ABI"
H707C74B2A986: '使用Apple的kernel extensions ABI'
# 'Use CREL relocation format for ELF'
H01BA06F9BEE0: '使用CREL重新定位格式於ELF'
# "Use ConstantFP's native fixed-length vector splat support."
H45D6CB612C50: '使用ConstantFP的本機固定長度向量展開支援。'
# "Use ConstantFP's native scalable vector splat support."
H019F3DB4B516: '使用ConstantFP的本機可伸縮向量展開支援。'
# "Use ConstantInt's native fixed-length vector splat support."
HEE201C750BB5: '使用ConstantInt的本機固定長度向量展開支援。'
# "Use ConstantInt's native scalable vector splat support."
H205BD3049DE6: '使用ConstantInt的原生可擴展向量展開支援'
# 'Use DLL debug run-time'
H09CE8A3B2FF2: '使用DLL除錯執行階段庫'
# 'Use DLL run-time'
HFFC5F85F16E2: '使用DLL執行階段庫'
# 'Use DPP operations for scan'
HA25C31D46A88: '使用DPP運算進行掃描'
# 'Use DWARF base address selection entries in .debug_ranges'
H785682C5C939: '在.debug_ranges中使用DWARF基礎地址選擇條目'
# 'Use DWARF style exceptions'
H37CB53594E9C: '使用DWARF風格的例外處理'
# 'Use Decision Forest model to rank completion items'
H05DCA5EC7686: '使用決策森林模型來排序完成項目'
# 'Use EH-safe code when synthesizing retains and releases in -fobjc-arc'
H36FC7089F28D: '在-fobjc-arc中合成保留和釋放時使用EH安全代碼'
# 'Use F5 series hardware multiplier'
H2733E473C4B3: '使用F5系列硬體乘法器'
# 'Use GC exclusively for Objective-C related memory management'
H2B28F501A8B5: '專用垃圾回收進行Objective-C相關記憶體管理'
# "Use GCC installation in the specified directory. The directory ends with path components like 'lib{,32,64}/gcc{,-cross}/$triple/$version'. Note: executables (e.g. ld) used by the compiler are not overridden by the selected GCC installation"
HA7E84A833041: "使用指定目錄中的GCC安裝。目錄的路徑結尾可能包含類似 'lib{,32,64}/gcc{,-cross}/$triple/$version' 的組件。注意：編譯器使用的可執行檔（例如ld）不會被選定的GCC安裝覆寫"
# 'Use GCNDownwardRPTracker for GCNRegPressurePrinter pass'
HC666D46EACA0: '為GCNRegPressurePrinter pass使用GCNDownwardRPTracker'
# 'Use GOT indirection instead of PLT to make external function calls (x86 only)'
H813651BE1DF2: '使用GOT間接跳轉代替PLT來呼叫外部函式（僅限x86）'
# 'Use GOT indirection to reference external data symbols'
H9C63E198FEC5: '使用GOT間接跳轉來引用外部資料符號'
# 'Use GP relative accesses for symbols known to be in a small data section (MIPS)'
H16E3D5EA2597: '使用GP相對存取方式存取已知在小型資料段的符號（MIPS）'
# 'Use GPR indexing mode instead of movrel for vector indexing'
H65B8C362AD34: '使用GPR索引模式而非movrel進行向量索引'
# 'Use GlobalISel desired legality, rather than try to userules compatible with selection patterns'
HCD3F9F572B30: '使用GlobalISel所需的合法性規則，而非嘗試使用與選擇模式相容的userules'
# 'Use HLFIR lowering (experimental)'
HBF33CE828D70: '使用HLFIR降階（實驗性）'
# 'Use IEEE 754 quadruple-precision for long double'
H52864CA1A557: '使用IEEE 754 四重精確度表示long double'
# 'Use INTEGER(KIND=8) for the result type in size-related intrinsics'
H31BCF654D576: '在與大小相關的內建函數中使用INTEGER(KIND=8)作為結果類型'
# 'Use InstrItineraryData for latency lookup'
HE819C1D764CF: '使用InstrItineraryData進行延遲查詢'
# 'Use Intel MCU ABI'
H047785ECB956: '使用Intel MCU ABI'
# 'Use Iterative approach for scan'
HB2B560B747FE: '使用迭代方式進行掃描'
# 'Use JSON as the output format.'
H22CC5D346911: '使用JSON作為輸出格式。'
# 'Use LFENCE along each conditional edge to harden against speculative loads rather than conditional movs and poisoned pointers.'
H417B6B21B3DF: '在每個條件分支邊緣使用LFENCE指令以防止預測載入，而非條件移動和中毒指標。'
# 'Use LLJITGenericIRPlatform'
H25BF0FFFB5D6: '使用LLJITGenericIRPlatform'
# 'Use LLVM-IR names when deriving statement names'
H7614196F2CF1: '在導出語句名稱時使用LLVM-IR名稱'
# 'Use LLVM/Offload as portable offloading runtime.'
HE33C03962BCE: '使用LLVM/Offload作為可移植的卸載運行時。'
# 'Use MD5 for file checksums in debug info (default)'
H96424B977A6D: '在除錯資訊中使用MD5進行檔案校驗和（預設）'
# 'Use ML.'
HFB1C0C51C398: '使用ML。'
# 'Use NMake/Jom format for the depfile'
H2770540BA1FF: '使用NMake/Jom格式的依賴檔'
# 'Use ORC runtime from given path'
H0B3C6C26BF5D: '使用指定路徑中的ORC運行時'
# 'Use SEH style exceptions'
HF73D39350799: '使用SEH風格的例外處理'
# 'Use SHA1 for file checksums in debug info'
H18018B318301: '在除錯資訊中使用SHA1進行檔案校驗和'
# 'Use SHA256 for file checksums in debug info'
HF98F43EAE9BB: '在除錯資訊中使用SHA256進行檔案校驗和'
# 'Use SjLj style exceptions'
H44AA3EF8F7F8: '使用SjLj風格的例外處理'
# 'Use Stable Hashing for MIR VReg Renaming'
H093C21DF7C9E: '使用穩定雜湊進行MIR虛擬寄存器重新命名'
# 'Use Stack Safety analysis results'
HCE2D7641DBD9: '使用堆疊安全分析結果'
# 'Use StructurizeCFG IR pass'
HA25675EEF575: '使用StructurizeCFG IR pass'
# 'Use TLS'
HF5C26334C370: '使用TLS'
# 'Use TargetSchedModel for latency lookup'
HC9F59D7F1E0C: '使用TargetSchedModel進行延遲查詢'
# 'Use TargetTransformInfo::getInstructionCost'
H4974E1B043EE: '使用TargetTransformInfo::getInstructionCost方法'
# 'Use TargetTransformInfo::getIntrinsicInstrCost'
H85A8617C4E16: '使用TargetTransformInfo::getIntrinsicInstrCost方法'
# 'Use VP intrinsics'
H7B0B6BAFD1AA: '使用VP intrinsic函數'
# 'Use WebAssembly style exceptions'
H0F092371B645: '使用WebAssembly風格的例外處理'
# 'Use a best-case representation method for member pointers'
H7AE6BEFD1C8A: '在C和ObjC中為字串文字使用const修飾的類型'
# 'Use a const qualified type for string literals in C and ObjC'
HBFF97FAA6C53: '使用診斷處理程序來測試處理程序介面'
# 'Use a diagnostic handler to test the handler interface'
H3C822F398929: '使用虛假的地址空間地圖；僅用於OpenCL測試'
# 'Use a fake address space map; OpenCL testing purposes only'
H9DCA916816C8: '使用自由格式的文字輸出。'
# 'Use a free form text output.'
HA312842C43C5: '使用完整的猜測屏障來強化呼叫和返回邊，而非較輕量的緩解措施'
# 'Use a full speculation fence to harden both call and ret edges rather than a lighter weight mitigation.'
H600ECC7683CF: '使用最通用的成員指標表示法'
# 'Use a most-general representation for member pointers'
H0E7635ED3666: '使用可重新生成的偽指令進行 2 指令常數材質化'
# 'Use a rematerializable pseudoinstruction for 2 instruction constant materialization'
H3A40020AE1F7: '對wchar_t使用有符號類型'
# 'Use a signed type for wchar_t'
H48F702933B27: '對所有函數使用單一TBAA樹且不使用FIR別名標籤pass'
# 'Use a single TBAA tree for all functions and do not use the FIR alias tags pass'
HC642932368D3: '使用絕對路徑來呼叫子命令（預設）'
# 'Use absolute paths for invoking subcommands (default)'
HFDEA884CA19F: '對任何具有先前基地址的地址使用addrx+offset擴展形式'
# 'Use addrx+offset extension form for any address with a prior base address'
H5B85C96D3B22: '使用所有可用的分析'
# 'Use all available analyses'
H8DB3578A8858: '使用所有區別位元（預設）'
# 'Use all discriminator bits (default)'
H568FAF6786A5: '對wchar_t使用無符號類型'
# 'Use an unsigned type for wchar_t'
HE6D72C7A4E59: '使用無符號類型表示wchar_t'
# 'Use approximate transcendental functions'
HC80164348ADD: '使用近似超越函數'
# 'Use arc callee save/restore functions'
HDC1738B5E10F: '使用ARC被調用者保存/恢復函數'
# 'Use atexit or __cxa_atexit to register global destructors'
HD6A435F1A848: '使用atexit或__cxa_atexit來註冊全域析構函數'
# 'Use atomic fetch add for first counter in a function (usually the entry counter)'
HE1A472AB0CD6: '對函數中的第一個計數器（通常是入口計數器）使用原子取後加操作'
# 'Use base address specifiers in debug_ranges'
H16F9B262870C: '在debug_ranges中使用基址指定符'
# 'Use base and pass 1 discriminators'
HFD9F1E3E9AB6: '使用基址和pass 1 判別值'
# 'Use base and pass 1-2 discriminators'
H8235CCC718A7: '使用基址和pass 1-2判別值'
# 'Use base and pass 1-3 discriminators'
HF4182389B253: '使用基址和pass 1-3判別值'
# 'Use base discriminators only'
HF3EBCD1C0036: '僅使用基址判別值'
# 'Use best guess'
H868B8A8130DA: '使用最佳猜測'
# 'Use binary to correlate'
H72FD9C9D9781: '使用二進位來進行關聯'
# 'Use block frequency info to find successors to sink'
H76D3FF42212F: '使用區塊頻率資訊來尋找要沉底的後繼節點'
# 'Use cache manager to save/load modules'
HA5972065E561: '使用快取管理器來儲存/載入模組'
# 'Use call site prioritized inlining for sample profile loader. Currently only CSSPGO is supported.'
H91095FED309C: '在樣本剖析載入器中使用呼叫部位的內聯優先級。目前僅支援CSSPGO。'
# 'Use callbacks instead of inline instrumentation sequences.'
H3EC6C04656EA: '改用回呼函數而不是內嵌插樁序列。'
# 'Use callee size priority.'
H959C69EC2106: '使用被調用者大小优先級。'
# 'Use case-insensitive matching'
HCBB3CB058AC9: '使用大小寫不敏感的匹配'
# 'Use codegen data read from default.cgdata to optimize the binary'
HEFC973859186: '使用從預設的cgdata讀取的程式碼生成資料來優化二進位'
# 'Use codegen data read from the specified <path>.'
HA873FDC06A7F: '使用從指定的 <path> 讀取的程式碼生成資料。'
# 'Use colors in detailed AST output. If not set, colors\nwill be used if the terminal connected to\nstandard output supports colors.'
H3428909B1528: '在詳細AST輸出中使用顏色。若未設定，則若標準輸出連接的終端機支援顏色，將使用顏色。'
# 'Use colors in output (default=autodetect)'
H036C59DCDCFA: '在輸出中使用顏色（預設=自動偵測）'
# 'Use column-major layout'
H798E10981CB2: '使用列優先布局'
# 'Use compact approach for aligning functions'
H53E4E0949D55: '使用緊湊方法對齊函數'
# 'Use compact branches where appropriate (default).'
HE80CC6815708: '在合適處使用緊湊分支（預設）。'
# 'Use compressed jump tables in Thumb-1 by synthesizing an equivalent to the TBB/TBH instructions'
H2165E804582A: '在Thumb-1中透過合成等效於TBB/TBH指令的壓縮跳轉表'
# 'Use constructor homing if we are using limited debug info already'
H62F93DEE0ADD: '如果已使用受限的除錯資訊，則使用建構函數定位'
# 'Use context'
H3D56A8B500FF: '使用上下文'
# 'Use context-sensitive byte size cost for preinliner decisions'
H7FD64165B9B4: '在preinliner決策中使用上下文敏感的字節大小成本'
# 'Use cost-benefit ratio.'
H9D7EE37E6691: '使用成本效益比。'
# 'Use debug info or binary file to correlate profiles.'
H2E074CAAD7C0: '使用除錯資訊或二進位檔來關聯剖面。'
# 'Use debug info to correlate'
HEC4020684722: '使用除錯資訊關聯'
# 'Use debug info to correlate profiles. (Deprecated, use -profile-correlate=debug-info)'
H3760EBF147CB: '使用除錯資訊關聯剖面。（已棄用，請改用-profile-correlate=debug-info）'
# 'Use debug-info or binary correlation to correlate profiles with build id fetcher'
HE51EAC7876DD: '使用debuginfod從剖面查詢物件檔'
# 'Use debuginfod to look up object files from profile'
HF7500F4663E6: '使用debuginfod查詢物件檔來源'
# 'Use default code inlining logic for the address sanitizer'
HB70EC9805527: '為位址檢查器使用預設的內嵌邏輯'
# 'Use development mode (runtime-loadable model)'
H1078C08F764F: '使用開發模式（執行階段可載入模型）'
# 'Use directory as the C++ standard library include path'
H323DACFD356C: '將目錄用作C++標準程式庫包含路徑'
# 'Use distinct LTO pipelines'
H5CC3AC1C99CE: '使用獨立的LTO管線'
# 'Use div.w[u] and mod.w[u] instructions with input not sign-extended.'
HCBB92DFD904B: '使用輸入未符號延展的div.w[u]和mod.w[u]指令'
# 'Use dot format instead of plain text when dumping VPlans'
HE98D975C012B: '在導出VPlans時使用點格式而非純文字'
# 'Use dwarf for profile correlation even when binary contains pseudo probe.'
HB77EAFFEBB88: '即使二進位檔包含偽插樍，仍使用DWARF進行剖析關聯'
# 'Use dynamic alloca to represent stack variables'
H0BD8D88B6D44: '使用動態alloca來表示堆疊變數'
# 'Use emulated TLS model'
H1BBC4DA9A238: '使用模擬TLS模式'
# 'Use emutls functions to access thread_local variables'
HF38CD5C8C963: '使用emutls函數來存取thread_local變數'
# 'Use experimental new value-tracking variable locations'
H5A1E1B70E9BC: '使用實驗性新值追蹤變數位置'
# 'Use exprloc addrx+offset expressions for any address with a prior base address'
H8B37A6DB17E6: '使用exprloc addrx+offset表達式來處理任何具有先前基址的地址'
# 'Use ext-tsp for size-aware block placement.'
H6EBF1A8427C5: '使用ext-tsp進行尺寸感知區塊配置'
# 'Use external machine object code emitter.'
H863F828BD310: '使用外部機器物件代碼發射器'
# 'Use fast short rep mov in memcpy lowering'
H51A6C031B64D: '在memcpy的lowering時使用快速短rep mov指令'
# 'Use filesystem locks for implicit modules builds to avoid duplicating work in competing clang invocations.'
H0BC43223C7F4: '使用檔案系統鎖定來進行隱式模組建置，以避免在競爭的clang調用中重複工作'
# 'Use first loadable segment address as base address for offsets in unsymbolized profile. By default first executable segment address is used'
H4F1992DBF3B6: '在未符號化的剖析中，將第一個可加載段的地址用作偏移量的基地址。預設情況下使用第一個可執行段的地址'
# 'Use full module build paths in the profile counter names for static functions.'
H8EE12193DAD1: '在靜態函數的剖析計數器名稱中使用完整的模組建置路徑'
# 'Use full register names when printing assembly'
HCA77C0C5AF9C: '列印組裝時使用完整寄存器名稱'
# 'Use full register names when writing assembly output'
H3BE94F5363AA: '寫入組裝輸出時使用完整寄存器名稱'
# 'Use global'
HB9509FD003D3: '使用全域'
# 'Use global constructors'
HF07EDAA4A037: '使用全域建構函數'
# 'Use global destructors'
HDD719F630B29: '使用全域分解函數'
# 'Use hardened lowering for jump-table dispatch'
H7DCC0D09290B: '使用強化lowering進行跳轉表分派'
# 'Use heuristics to rank code completion items'
HDEA303833606: '使用启发式方法對程式碼補充項目進行排序'
# 'Use if conversion pass'
HBFF84704F0B4: '使用if轉換pass'
# 'Use ifunc global'
H9FA2DD7E729C: '使用ifunc全域變數'
# 'Use indirect register addressing for divergent indexes'
HF60A83099C5E: '為分歧索引使用間接寄存器寻址'
# 'Use inline cost priority.'
H496F98AFF787: '使用-inline成本优先級。'
# 'Use inlined strings rather than string section.'
H7753024EA72C: '使用內嵌字串而非字串區段。'
# 'Use instruction-ref based LiveDebugValues with normal DBG_VALUE inputs'
H2DC2FFE65115: '使用基於instruction-ref的LiveDebugValues以及標準DBG_VALUE輸入'
# 'Use instrumentation data for profile-guided optimization'
H9DC257CB2810: '使用插樁資料進行配置文件引導型優化'
# 'Use instrumentation data for profile-guided optimization. If pathname is a directory, it reads from <pathname>/default.profdata. Otherwise, it reads from file <pathname>.'
HDBC8B9085819: '使用插樁資料進行配置文件引導型優化。如果路徑名為目錄，則讀取 <pathname>/default.profdata。否則，從檔案 <pathname> 讀取。'
# 'Use instrumented (context sensitive) profile to guide PGO.'
HF618D20FE941: '使用插樁（具上下文感知）的剖面來引導PGO。'
# 'Use instrumented profile to guide PGO.'
H479023987FBB: '使用插樁剖面來引導PGO。'
# 'Use internal machine object code emitter.'
H45C76DB103C3: '使用內部機器物件程式碼發射器。'
# 'Use jump tables for lowering switches'
HFFDBCF7C79DB: '使用跳轉表來降級switch語句'
# 'Use large-integer access for consecutive bitfield runs.'
HAFC147F2F63A: '對連續位段運行使用大整數存取。'
# 'Use linker features to support dead code stripping of globals'
H25F0988FF38D: '使用連結器功能來支援全域變數的死亡代碼剷除'
# 'Use loop idiom recognition code size heuristics when compiling with -Os/-Oz'
H16B2DB694C4C: '在使用-Os/-Oz編譯時，使用迴圈語法辨識的程式碼大小启发式算法'
# 'Use masked vector intrinsics'
HD66DB2015BA3: '使用遮罩向量內建函數'
# 'Use md5 to represent function names in the output profile (only meaningful for -extbinary)'
HE791F5E32608: '在輸出剖面中使用MD5表示函數名稱（僅對-extbinary有意義）'
# 'Use memory profile for profile-guided memory optimization'
H5A1906ADE19C: '使用記憶體剖面進行配置文件引導型記憶體優化'
# 'Use more powerful methods of sharpening expression ranges. May be costly in terms of compile time'
HD0AB27E80870: '使用更強大的方法來精化表達式範圍。可能會增加編譯時間成本'
# 'Use native PDB reader instead of DIA'
H9315B56556F2: '使用本機PDB讀取器而非DIA'
# 'Use new kernel launching API for HIP'
HB4F88B0BE07A: '使用HIP的新核心啟動API'
# 'Use odr indicators to improve ODR reporting'
H74C4F000003D: '使用ODR指示符來改進ODR報告'
# 'Use old-style Thumb2 if-conversion heuristics'
H98BE9934D232: '使用舊式Thumb2 if轉換的启发式方法'
# 'Use one trap block per function'
HAC8964692418: '每個函數使用單一trap區塊'
# 'Use only doxygen-style comments to generate docs.'
H609A25655FBA: '僅使用Doxygen樣式註解來生成文件。'
# 'Use only register numbers when writing assembly output'
H3A4857A621C3: '在寫入組裝輸出時僅使用寄存器編號'
# "Use optimistic attributes describing 'as-if' properties of runtime calls."
H4E943E97F387: "使用描述執行時間調用 'as-if' 屬性的樂觀屬性。"
# 'Use packed stack layout (SystemZ only).'
HD83EA715FFB0: '使用緊湊堆疊佈局（僅SystemZ）。'
# 'Use page aliasing in HWASan'
H4A8E0010EDA7: '在HWASan中使用頁面別名'
# 'Use pipes between commands, when possible'
HE3D5879BAE89: '盡可能在指令間使用管道傳輸'
# 'Use post increment control-dependent ranges in IndVarSimplify'
H911B15838A45: '在IndVarSimplify中使用後置遞增控制依賴範圍'
# 'Use predicated EVL instructions for tail folding. If EVL is unsupported, fallback to data-without-lane-mask.'
HED0757D8A6A8: '使用predicated EVL指令進行尾部展開。如果EVL不受支援，則回退到無通道遮罩的資料。'
# 'Use preferred fixed label for all labels'
H89BB5704EA97: '為所有標籤使用指定的固定標籤'
# 'Use prefix for memory intrinsics in KASAN mode'
HA3237877312E: '在KASAN模式下為記憶體內置函數添加前綴'
# 'Use private aliases for global variables'
H7796ADF97BE6: '為全域變數使用私有別名'
# 'Use profi to infer block and edge counts'
H65DAA2E87B9C: '使用profi來推斷區塊和邊緣計數'
# 'Use profi to infer block and edge counts.'
H8CD455D93A81: '使用profi來推斷區塊和邊緣計數。'
# 'Use profile info to add section prefix for hot/cold functions'
HC0D88E37E898: '使用剖析資訊為熱/冷函數添加區段前綴'
# 'Use pseudo probes in profile generation'
H0886E88805AB: '在剖析生成中使用偽探針'
# 'Use public LTO visibility for classes in std and stdext namespaces'
H0471C4CC8A6A: '為std和stdext命名空間中的類使用public LTO可見性'
# 'Use raw weights for labels. Use percentages as default.'
H84E197A50BE8: '使用原始權重對應標籤。以百分比為預設值。'
# 'Use register sized accesses to bit-fields, when possible.'
HEC8949CF52C8: '在可能的情況下，使用與寄存器大小相同的位段存取。'
# 'Use relative paths for invoking subcommands'
HF3DBC88EA771: '使用相對路徑來呼叫子命令'
# 'Use release mode (AOT-compiled model)'
H3C1DD2917917: '使用AOT編譯模式的發布版本（AOT-編譯模型）'
# 'Use ring buffer for stack allocations'
H1D67F21B8816: '使用環狀緩衝區進行堆疊分配'
# 'Use rnglists for contiguous ranges if that allows using a pre-existing base address'
H0FA2B904A3EB: '如果可以使用現有的基底地址，則為連續範圍使用rnglists'
# 'Use round-robin distribution of functions to modules instead of the default name-hash-based one'
H2DC1323199D5: '改用round-robin分配函數到模組，而非預設的名稱哈希基礎分配'
# 'Use row-major layout'
HE68D3A295C31: '使用行優先布局'
# 'Use runtime alias checks to resolve possible aliasing.'
H74ED44C8AB6B: '使用執行階段別名檢查來解決可能的別名問題。'
# 'Use sampled profile to guide PGO.'
H83EE2F7AD7E3: '使用抽樣分析結果來引導配置文件引導型優化（PGO）。'
# 'Use sections+offset as references rather than labels.'
HC0250DDB1574: '使用sections+offset作為參考，而非標籤。'
# 'Use segment set for the computation of the live ranges of physregs.'
H297ADEEDAC19: '在計算physregs的存活範圍時使用segment set。'
# 'Use segmented stack'
H45E75CED74E8: '使用分段堆疊'
# 'Use separate accesses for consecutive bitfield runs with legal widths and alignments.'
HDAEB15795B56: '為具有合法寬度和對齊的連續位段運行使用分開的存取。'
# 'Use separate unique sections for named sections'
HBA19BDB53714: '為命名區段使用獨立且唯一的區段'
# 'Use separate unique sections for named sections (ELF Only)'
H966D46021E86: '為命名區段使用獨立且唯一的區段（僅限ELF）'
# 'Use shared memory to transfer generated code and data'
H5DE48C3CC472: '使用共享記憶體來傳輸生成的程式碼和資料'
# 'Use simple template names in DWARF, or include the full template name with a modified prefix for validation'
HCADD22C917E1: '在DWARF中使用簡單的模板名稱，或在驗證時以修改過的前綴包含完整的模板名稱'
# 'Use smallest entry possible for jump tables'
H51B906CF7E2B: '為跳轉表使用可能的最小條目。'
# 'Use software floating point'
HE54F4CA19BBF: '使用軟體浮點運算'
# 'Use specified bytecode when generating output'
H6F1FA0ED25C1: '使用指定的位元組碼生成輸出'
# 'Use stack probes (default)'
HBB884418570D: '使用堆疊探針（預設）'
# 'Use static debug run-time'
HC2C965E8960E: '使用靜態除錯執行階段庫'
# 'Use static run-time'
H53E3F295A611: '使用靜態執行階段庫'
# 'Use target platform default'
H1C5D924DE4CE: '使用目標平台預設'
# 'Use text-based completion if the parser is not ready'
H2FD4CB6E479F: '若解析器尚未就緒，則使用文字基礎的補充'
# 'Use the AMDGPU specific RPTrackers during scheduling'
HA779151F216B: '在排程期間使用AMDGPU特定的RPTrackers'
# 'Use the AST -> LLVM pipeline to compile'
H4DBFD65A7D65: '使用AST -> LLVM管線進行編譯'
# 'Use the BLOCK_INFO from the given file'
HF8FF5F8C2E3C: '使用給定檔案中的BLOCK_INFO'
# 'Use the ClangIR pipeline to compile'
H3E61FEC2858B: '使用ClangIR管線進行編譯'
# 'Use the DFA based hazard recognizer.'
HB08DE21B4CC4: '使用基於DFA的風險識別器。'
# 'Use the FDPIC ABI'
HAD67F08A6522: '使用FDPIC ABI'
# 'Use the Greedy mode (best local mapping)'
H86402D6079EC: '使用貪婪模式（最佳局部映射）'
# 'Use the LLVM representation for assembler and object files'
H598F01E104A3: '使用LLVM表示法處理組譯器和物件檔'
# 'Use the MVE code generator for software pipelining'
H07D34F141A55: '使用MVE程式碼生成器進行軟體管線化'
# "Use the basic-block-sections profile to determine the text section prefix for hot functions. Functions with basic-block-sections profile will be placed in `.text.hot` regardless of their FDO profile info. Other functions won't be impacted, i.e., their prefixes will be decided by FDO/sampleFDO profiles."
H7751642AFC12: '使用basic-block-sections剖析來決定熱函數的text區段前綴。具有basic-block-sections剖析的函數將被放置在`.text.hot`中，不論其FDO剖析資訊如何。其他函數不受影響，即它們的前綴將由FDO/sampleFDO剖析決定。'
# 'Use the current working directory as the base directory of compiled module files.'
HC4A3722E1C1D: '將目前工作目錄用作已編譯模組檔的基底目錄。'
# 'Use the current working directory as the home directory of module maps specified by -fmodule-map-file=<FILE>'
H8AE9B0359BD7: '將目前工作目錄用作由-fmodule-map-file=<FILE> 指定的模組地圖的主目錄。'
# 'Use the dependence analysis interface'
HDF3A2E881A47: '使用依賴性分析介面'
# 'Use the experimental C++ class ABI for classes with virtual tables'
HBFD90D3B3FDE: '對具有虛函數表的C++類別使用實驗性類別ABI。'
# 'Use the experimental OpenMP-IR-Builder codegen path.'
H0A44AF245C92: '使用實驗性的OpenMP-IR-Builder程式碼生成路徑。'
# 'Use the experimental peeling code generator for software pipelining'
H14186C9F73CB: '使用實驗性的分離程式碼生成器進行軟體管線化'
# 'Use the first input module as the merged module'
H8EEE69848E3D: '使用第一個輸入模組作為合併的模組'
# 'Use the full schema for serialization'
HFE88B8373E59: '使用完整的序列化模式'
# 'Use the given guard (global, tls) for addressing the stack-protector guard'
H1CBDB2D23600: '使用指定的保護機制（global, tls）來尋址堆疊保護器'
# 'Use the given offset for addressing the stack-protector guard'
H5EC45CECD53A: '使用指定的偏移量來尋址堆疊保護器'
# 'Use the given reg for addressing the stack-protector guard'
H2907454E4058: '使用指定的寄存器來尋址堆疊保護器'
# 'Use the given symbol for addressing the stack-protector guard'
HB4E7196A5294: '使用指定的符號來尋址堆疊保護器'
# 'Use the given vector functions library'
H8A7DC0CD5F6E: '使用指定的向量函式庫'
# 'Use the given vector functions library. Note: -fveclib={ArmPL,SLEEF} implies -fno-math-errno'
HB6448F1B4907: '使用指定的向量函式庫。注意：-fveclib={ArmPL,SLEEF} 會隱含 -fno-math-errno'
# 'Use the gnu89 inline semantics'
H86341C44D7F1: '使用gnu89內聯語法'
# "Use the host's platform-specific path separator character when expanding the __FILE__ macro"
H19B5E5B63186: '在展開__FILE__宏時，使用主機平台特定的路徑分隔符字元'
# 'Use the implementation defaults'
H46CDBE8DC11A: '使用實作預設值'
# 'Use the last modification time of <file> as the build session timestamp'
HC4A79FF67275: '使用 <file> 的最後修改時間作為建置階段的時間戳'
# 'Use the llvm.experimental.noalias.scope.decl intrinsic during inlining.'
H9063D587CE9C: '在內聯期間使用llvm.experimental.noalias.scope.decl內建函數。'
# 'Use the named plugin action in addition to the default action'
H2C8F63F64ACF: '在預設動作之外使用指定的插件動作'
# 'Use the named plugin action instead of the default action (use "help" to list available options)'
HEB1C020DB399: '以指定的插件動作取代預設動作（使用「help」列出可用選項）'
# 'Use the native __fp16 type for arguments and returns (and skip ABI-specific lowering)'
H638090B7484A: '使用本機的__fp16類型處理引數和傳回值（並跳過ABI特定的降階）'
# 'Use the native half type for __fp16 instead of promoting to float'
HF8914EF176E5: '使用本機的half類型處理__fp16，而非提升為float'
# 'Use the native platform for the executor.Requires -orc-runtime'
HA522D7482E1A: '使用本機平台的執行器。需要-orc-runtime'
# 'Use the new driver for OpenMP offloading.'
H4FEA64EFDBD7: '使用新的驅動程式進行OpenMP卸載。'
# 'Use the new driver for offloading compilation.'
H2C38A94F0FE6: '使用新的驅動程式進行卸載編譯。'
# 'Use the new method of lowering partial reductions.'
H67B6026FF0E7: '使用新的部分約簡轉換方法。'
# 'Use the new offloading linker to perform the link job.'
HBE633D219689: '使用新的卸載連結器來執行連結作業。'
# 'Use the old (incorrect) instruction latency calculation'
H2E61A14D081C: '使用舊的（錯誤的）指令延遲計算方式'
# 'Use the preinliner decisions stored in profile context.'
HD0A0D412FA60: '使用在剖面上下文中儲存的預內聯決策。'
# 'Use the remappings described in <file> to match the profile data against names in the program'
HD47D317FB40F: '使用 <file> 中描述的重映射規則，將剖面資料與程式中的名稱對應'
# 'Use the scalar evolution interface'
HD228C1FFC83E: '使用標量演進介面'
# 'Use the specified contextual profile file'
H21441E080C2A: '使用指定的上下文剖面檔案'
# 'Use the static host OpenMP runtime while linking.'
H409015ECE8E9: '連結時使用靜態主機OpenMP執行時期函式庫。'
# "Use the target's default scheduler choice."
HEF05D039293B: '使用目標預設的排程選擇。'
# "Use the target's platform-specific path separator character when expanding the __FILE__ macro"
H7C74BA846E17: '展開__FILE__宏時使用目標平台特定的路徑分隔符號字符'
# 'Use the unified LTO pipeline'
H95AFD66F1EAB: '使用統一的LTO管線'
# 'Use this option to enable basic block coverage instrumentation'
H0CDE08096A2C: '使用此選項啟用基本區塊覆蓋率插樁'
# 'Use this option to enable function entry coverage instrumentation.'
HD78AD2BC6F5D: '使用此選項啟用函數入口覆蓋率插樁。'
# 'Use this option to enable temporal instrumentation'
HAB3379855655: '使用此選項啟用時間插樁'
# 'Use this option to turn off/on warnings about function with samples but without debug information to use those samples. '
H511084B41E5F: '使用此選項來關閉/開啟有關具有資料採樣但缺少除錯資訊的函數的警告。 '
# 'Use this option to turn off/on warnings about profile cfg mismatch.'
H1D04CE0F6A8E: '使用此選項來關閉/開啟有關剖面CFG不匹配的警告。'
# 'Use this option to turn on/off SELECT instruction instrumentation. '
HDC5EDE7DE3E2: '使用此選項來啟用/停用SELECT指令的插樁。 '
# 'Use this option to turn on/off memory intrinsic size profiling.'
HF19744FEF2C8: '使用此選項來啟用/停用記憶體內建函數大小的分析。'
# 'Use this option to turn on/off warnings about incorrect usage of llvm.expect intrinsics.'
H3723F53142CC: '使用此選項來開啓/關閉llvm.expect內置函數使用不正確的警告。'
# 'Use this option to turn on/off warnings about missing profile data for functions.'
H78D4B914E121: '使用此選項來開啓/關閉函數缺少剖析資料的警告。'
# 'Use this to override the target cache line size when specified by the user.'
H43C33F17EAA5: '使用此選項覆寫目標的快取線大小（當由使用者指定時）。'
# "Use this to override the target's minimum page size."
HEA1997AE00E5: '使用此選項覆寫目標的最小頁面大小。'
# "Use this to override the target's predictable branch threshold (%)."
H9102D958180E: '使用此選項覆寫目標的可預測分支閾值（%）。'
# 'Use this to skip inserting cache invalidating instructions.'
HE32E1CC26F2E: '使用此選項跳過插入快取失效指令。'
# 'Use this to specify the default maximum number of instructions to scan backward from a given instruction, when searching for available loaded value'
H673F71583921: '使用此選項指定預設的最大反向掃描指令數，從指定指令開始，當搜尋可用的已載入值時。'
# 'Use this to specify the default trip count of a loop'
HEB778E135667: '使用此選項指定迴圈的預設迭代次數。'
# 'Use this to specify the max. distance between array elements accessed in a loop so that the elements are classified to have temporal reuse'
HABE5835F827F: '使用此選項指定迴圈中存取陣列元素間的最大距離，使得這些元素被分類為具有時間重用性。'
# 'Use this unroll count for all loops including those with unroll_and_jam_count pragma values, for testing purposes'
HD799D9D7B870: '測試用：使用此展開計數來處理所有迴圈，包括具有unroll_and_jam_count pragma值的迴圈。'
# 'Use this unroll count for all loops including those with unroll_count pragma values, for testing purposes'
HEF3DD1B9175D: '測試用：使用此展開計數來處理所有迴圈，包括具有unroll_count pragma值的迴圈。'
# 'Use together with -emit-llvm to get pristine LLVM IR from the frontend by not running any LLVM passes at all'
H80E48E5F4285: '與-emit-llvm一起使用，通過不執行任何LLVM passes的方式從前端獲得未修改的LLVM IR。'
# 'Use undef when generating programs.'
HD1F883A2CCED: '在生成程式時使用未定義值（undef）。'
# 'Use unified LTO piplines. Ignored unless -thinlto-bc is also specified.'
H84A36B27E595: '使用統一LTO管線。除非同時指定-thinlto-bc，否則將被忽略。'
# 'Use unique names for basic block sections (ELF Only)'
HDE45C38B60C6: '為基本區塊區段使用唯一名稱（僅限ELF）。'
# 'Use verbose output'
H579A705CE0A4: '使用詳細輸出。'
# 'Use window algorithm after SMS algorithm fails.'
H29FAE7BBDC36: '在SMS演算法失敗後使用窗口演算法。'
# 'Use window algorithm instead of SMS algorithm.'
H0091F49C954B: '改用窗口演算法取代SMS演算法。'
# 'Use with -ast-dump or -ast-print to dump/print only AST declaration nodes having a certain substring in a qualified name. Use -ast-list to list all filterable declaration node names.'
H03F2BB85517F: '與-ast-dump或-ast-print一起使用，僅轉存/列印具有特定限定名稱子字串的AST宣告節點。使用-ast-list列舉所有可過濾的宣告節點名稱。'
# 'Use zlib'
H7267EE40AF01: '使用zlib壓縮庫。'
# 'Use zstd'
HADE0CBD533EE: '使用 zstd'
# 'Used for test purpuses'
H143A636D4E4C: '用於測試目的'
# 'User directory for configuration files'
HD1D0604448D4: '用於配置文件的使用者目錄'
# 'User specified cold threshold for instr profile which will override the cold threshold got from profile summary. '
H921527455582: '使用者指定的插樁剖析冷閾值，將覆蓋從剖析摘要獲得的冷閾值'
# 'User supplied asset path to override the default css and js files for html output'
H11CFB81E3E7B: '用於覆蓋 HTML 輸出預設 css 和 js 檔案的使用者提供的資產路徑'
# 'Uses the source file name instead of the Module hash. This requires that the source filename has a unique name / path to avoid name collisions.'
HEFB279BA9297: '使用來源檔名稱而非模組雜湊值。這需要來源檔名稱具有唯一名稱/路徑以避免名稱衝突'
# 'VALU instruction count threshold for adjusting wave priority'
H323BECA8255D: '調整 wave 優先權的 VALU 指令計數閾值'
# 'VE DAG->DAG Pattern Instruction Selection'
H31A1129B2EDC: 'VE DAG→DAG 模式指令選擇'
# 'VLIW scheduler'
H04220C47ABF0: 'VLIW 調度器'
# 'Validate PCH input files based on content if mtime differs'
H5B0B3696A2CD: '如果修改時間不同，則根據內容驗證 PCH 輸入檔案'
# 'Validate PCM input files based on content if mtime differs'
HE7966DE5A8B2: '如果修改時間不同，則根據內容驗證 PCM 輸入檔案'
# 'Validate that all vtables have type infos in LTO'
H66B413E67029: '驗證所有虛函數表在 LTO 中具有類型資訊'
# 'Validate the system headers that a module depends on when loading the module'
HEE36D448D56F: '載入模組時驗證該模組依賴的系統標頭'
# 'Value for __PIC__'
H760023C619A3: '__PIC__ 的值'
# 'Value to pass to hot/cold operator new for cold allocation'
H6DAF60C415A6: '傳遞給 hot/cold operator new 用於冷分配的值'
# 'Value to pass to hot/cold operator new for hot allocation'
HD1597DC64127: '傳遞給 hot/cold operator new 用於熱分配的值'
# 'Value to pass to hot/cold operator new for notcold (warm) allocation'
HE0D30EC39F19: '傳遞給 hot/cold operator new 用於非冷（溫）分配的值'
# 'Variable.'
H7236856976D0: '變數。'
# 'Vector functions library'
H22962FC6DC51: '向量函數庫'
# 'Vectorization cost threshold.'
HCD21FCE9A5E0: '向量化成本閾值。'
# 'Vectorize if the invocation count is < than this. 0 disables vectorization.'
H282E25ADE422: '如果調用次數小於此值，則進行向量化。0禁用向量化。'
# 'Vectorize load and Store instructions'
HC110C6BBCB5B: '向量化載入與儲存指令'
# 'Vectorize load and store instructions'
HBBECD678BBBC: '向量化載入與儲存指令'
# 'Vectorize up to this many bundles.'
H5F30F00C03B7: '向量化最多打包此數量。'
# 'Verbosity level of the contextual profile printer pass.'
H635358C62DFB: '上下文剖面打印pass的詳細程度等級。'
# 'Verbosity of log messages written to stderr'
H2E24D6564DA8: '寫入stderr的記錄信息的詳細程度'
# 'Verfiy VPlans after VPlan transforms.'
HE7FC42CC42C7: '在VPlan轉換後驗證VPlans。'
# 'Verify AMDGPU HSA Metadata'
H65A2759AA257: '驗證AMDGPU HSA元數據'
# 'Verify Call Frame Information instructions'
H027197CC37B3: '驗證調用框架信息指令'
# 'Verify IR correctness when making sensitive SCEV queries (slow)'
H42A1AB630381: '在進行敏感SCEV查詢時驗證IR正確性（速度慢）'
# 'Verify PredicateInfo in legacy printer pass.'
H799D5E295653: '在舊版打印pass中驗證PredicateInfo。'
# "Verify ScalarEvolution's backedge taken counts (slow)"
HA5864D8AB4F8: '驗證標量演化的循環後邊沿計數（速度慢）'
# 'Verify after each transform'
H357D460E1502: '每次轉換後驗證'
# 'Verify device memory post execution against the original output.'
HE16F0A0EAC54: '與原始輸出對比驗證設備記憶體執行後的結果。'
# 'Verify diagnostic output using comment directives that start with prefixes in the comma-separated sequence <prefixes>'
HC54A2E24270E: '使用以逗號分隔序列 <prefixes> 中指定的前綴開頭的註釋指令來驗證診斷輸出。'
# 'Verify dominator info (time consuming)'
H7265FCA24E7A: '驗證支配信息（耗時）'
# 'Verify domtree after unrolling'
H9FB6F655E747: '展開後驗證domtree'
# 'Verify during register allocation'
HA235BE2313EF: '在記憶體寄存器分配期間驗證'
# 'Verify generated machine code'
HAB7C952A6204: '驗證生成的機器碼'
# 'Verify legalizations'
H442690F32499: '驗證合法化步驟'
# 'Verify legalizations and artifact combines'
H810B83C40C92: '驗證法規化與工件組合'
# 'Verify loop info (time consuming)'
H7C86EDFCE360: '驗證循環資訊（耗時）'
# 'Verify loop lcssa form (time consuming)'
H0CAAF184E14A: '驗證循環 lcssa 形式（耗時）'
# 'Verify loopinfo after unrolling'
H03E2A3EBA62D: '展開循環後驗證循環資訊'
# 'Verify loops generated Loop Idiom Vectorize Pass.'
H8FE13960BD12: '驗證由 Loop Idiom Vectorize Pass 生成的循環。'
# 'Verify machine code after expanding ARM pseudos'
H4928DCB0BD05: '展開ARM偽指令後驗證機器碼'
# 'Verify machine dominator info (time consuming)'
H7DB30C69D5DA: '驗證機器支配資訊（耗時）'
# 'Verify machine instrs before and after machine scheduling'
H13FA77C833AC: '驗證機器調度前後的機器指令'
# 'Verify machine instrs before and after register coalescing'
HDD83DA18C7C7: '驗證寄存器合併前後的機器指令'
# 'Verify region info (time consuming)'
H9292DD1C4B56: '驗證區域資訊（耗時）'
# 'Verify sanity of PHI instructions during taildup'
H0D6EE6D76E64: '在 taildup 期間驗證 PHI 指令的正確性'
# 'Verify that computeKnownBits() and SimplifyDemandedBits() are consistent'
HD464B311F8B5: '驗證 computeKnownBits() 和 SimplifyDemandedBits() 的一致性'
# 'Verify that debug locations are handled'
H5157BEF03DC8: '驗證已處理除錯位置'
# 'Verify that narrow int args are properly extended per the SystemZ ABI.'
H7B81C58E5DE9: '驗證窄整數參數是否符合 SystemZ ABI 進行正確擴展。'
# 'Verify that the generated patterns are ordered by increasing latency'
HB35BF620F949: '驗證生成的模式是否按遞增延遲排序'
# 'Verify the binary representation of debug output'
HD5EDEFE1C648: '驗證除錯輸出的二進位表示'
# 'Verify the detected SCoPs after each transformation'
H577B4C82C33A: '驗證每次轉換後檢測到的 SCoPs'
# 'Verify the function generated by Polly'
H36FACBAA370A: '驗證 Polly 生成的函數'
# 'Verify this pass produces no dead code'
HD157362652B5: '驗證此 pass 不會產生死程式碼'
# 'Version loops if flattened loop could overflow'
H2ED0232BC13B: '如果扁平化循環可能溢出，則版本化循環'
# 'View BFI after MIR loader'
H70176654BA61: '載入MIR後顯示BFI'
# 'View BFI before MIR loader'
HD24CF0251C0D: '載入MIR前顯示BFI'
# 'View Options'
HDA1AEDD5C0C0: '顯示選項'
# 'View call graph'
HC3CF5708A682: '顯示呼叫圖'
# 'View dominance tree of function'
H8CAAE8FCD27E: '顯示函數的支配樹'
# 'View dominance tree of function (with no function bodies)'
HB12C18D29169: '顯示函數的支配樹（不含函數本體）'
# 'View postdominance tree of function'
H5144E7801A69: '顯示函數的後置支配樹'
# 'View postdominance tree of function (with no function bodies)'
H6016FE3E7B20: '顯示函數的後置支配樹（不含函數本體）'
# 'View regions of function'
HC65478A71B23: '顯示函數的區域'
# 'View regions of function (with no function bodies)'
H5ECE0F8FFA1A: '顯示函數的區域（不含函數本體）'
# 'View the CFG before DFA Jump Threading'
H7CED97AC3765: '在DFA Jump Threading前顯示控制流圖（CFG）'
# 'View the dependency graph.'
H4CD0E62026DC: '顯示依賴關係圖。'
# 'Viewing options'
H4109B1BD7A45: '顯示選項'
# 'Virtual Register Map'
HBAB873C35568: '虛擬寄存器映射'
# 'Virtual Register Rewriter'
H70230BEE99F4: '虛擬寄存器重寫器'
# 'Volatile loads and stores have acquire and release semantics'
HA2D66EAC62AA: 'Volatile載入和儲存具有取得與釋出語意'
# 'Volatile loads and stores have standard semantics'
H3FC4BC9157CA: 'Volatile載入和儲存具有標準語意'
# 'Volatile specifier.'
H5BCC57A6F6B7: 'Volatile指定詞。'
# 'Vreg distance cutoff for insert generation.'
HE65C5AFBE2C8: '插入產生的Vreg距離門檻值。'
# 'Vreg# cutoff for insert generation.'
H69051D37244E: '插入產生的Vreg編號門檻值。'
# 'WARNING: This option will replace your input file with the reduced version!'
HA6B4706DBC98: '警告：此選項將用簡化版本替換您的輸入文件！'
# "WARNING: You're attempting to print out a bitcode file.\nThis is inadvisable as it may cause display problems. If\nyou REALLY want to taste LLVM bitcode first-hand, you\ncan force output with the `-f' option.\n\n"
HD29B4F840F03: "警告：您正在嘗試列印位元碼文件。\n這不被建議，因為可能會導致顯示問題。如果您\n真的想親自體驗 LLVM 位元碼，可以使用 `-f' 選項強制輸出。\n\n"
# 'Wait for user input before entering JITed code'
HE997D4A27F4E: '在進入JIT代碼之前等待使用者輸入'
# 'Wait until all forks of instrumented process will finish (use with instrumentation-sleep-time option)'
H29419FC27D66: '等待所有插樁進程的分支完成（需與 instrumentation-sleep-time 選項一起使用）'
# 'Warn for mismatching a signed and unsigned value'
H2A8E011548FA: '警告：有符號和無符號值不匹配的情況'
# 'Warn for missing parenthesis around predicate registers'
HE7943720E0D3: '警告：在預測寄存器周圍缺少括號'
# "Warn for register names that aren't contigious"
HFB31626439DD: '警告：非連續的寄存器名稱'
# 'Warn if a function definition returns or accepts an object larger in bytes than a given value'
H8990A87A623D: '如果函數定義返回或接受的物件大於指定值的位元組數，則發出警告'
# 'Warn in ARM, emit implicit ITs in Thumb'
HC57002E0EFBF: '在ARM中，於Thumb模式下發出隱式IT指令'
# 'Warn in ARM, reject in Thumb'
H4EFFA07355E3: '在ARM中，於Thumb模式下拒絕'
# 'Warn on equivalent symbols in the output symbol list'
H88E497B15A1B: '在輸出符號列表中的等效符號時發出警告'
# 'Warn on input symbols missing from output symbol list'
HE4D0B0A892DF: '在輸入符號未出現在輸出符號列表中時發出警告'
# 'Warn on language extensions'
HCCA103ACA6B2: '對語言擴充功能發出警告'
# 'Warn on use'
HE0ABF7E28126: '在使用時發出警告'
# 'Warning Options'
HEA0EF30FD9BD: '警告選項'
# 'Warnings about individual formatting changes needed. Used only with --dry-run or -n'
HA24BD5E41E3E: '需要個別格式變更的警告。僅與 --dry-run 或 -n 一起使用時有效'
# 'Warnings detected.'
H9BB1C52DB1D8: '已檢測到警告。'
# 'Warnings to generate.'
H0499BE5B2273: '要生成的警告。'
# 'Weakly link in the blocks runtime'
H32E4B9C0D02B: '弱連結區塊執行時間'
# 'WebAssembly Clean Code After Trap'
H5004FAB71B78: 'WebAssembly 遭遇陷阱後清除非必要程式碼'
# 'WebAssembly Emscripten-style exception handling'
HB909CEF50795: 'WebAssembly Emscripten風格例外處理'
# 'WebAssembly Emscripten-style setjmp/longjmp handling'
HB327E2AC0CF6: 'WebAssembly Emscripten風格setjmp/longjmp處理'
# 'WebAssembly Exception Information'
HB914447C6B3D: 'WebAssembly例外資訊'
# 'WebAssembly Instruction Selection'
H6897B43BD95A: 'WebAssembly指令選擇'
# 'WebAssembly Late Exception Preparation'
H2CE3575C6DB6: 'WebAssembly後期例外準備'
# 'WebAssembly Lower Emscripten Exceptions / Setjmp / Longjmp'
HBA47203A675C: 'WebAssembly轉換Emscripten例外/SETJMP/LONGJMP'
# 'WebAssembly Lower RefTypes Int-Ptr Conversions'
HFE0286340D39: 'WebAssembly轉換RefTypes整數-指標轉換'
# 'WebAssembly Nullify DBG_VALUE_LISTs'
HA5294064B53B: 'WebAssembly清除DBG_VALUE_LIST'
# 'WebAssembly exception handling'
H886CFE14EC29: 'WebAssembly例外處理'
# 'WebAssembly exception handling (legacy)'
H7E31087C50F3: 'WebAssembly例外處理（舊版）'
# 'WebAssembly peephole optimizations'
H430AF441595E: 'WebAssembly小孔優化'
# 'WebAssembly reference type not allowed in exception specification'
H14B705277A94: 'WebAssembly參考類型不可用在例外規範中'
# 'WebAssembly setjmp/longjmp handling'
H9F0C3575883B: 'WebAssembly setjmp/longjmp處理'
# 'WebAssembly table cannot be declared within a function'
H085E37C320EB: 'WebAssembly表格不能在函數內宣告'
# 'WebAssembly table must be static'
H23C0F2D20589: 'WebAssembly表格必須為靜態'
# 'WebAssembly: Disable EH pad-first sort order. Testing purpose only.'
HBC8CFE10E3BC: 'WebAssembly：禁用EH的pad-first排序順序。僅供測試使用。'
# 'WebAssembly: Disable fallthrough-return optimizations.'
H8B46242EE529: 'WebAssembly：停用fallthrough-return優化。'
# 'WebAssembly: output implicit locals in instruction output for test purposes only.'
HBD0CCB517ABD: 'WebAssembly：僅為測試目的在指令輸出中顯示隱式局部變數。'
# 'WebAssembly: output stack registers in instruction output for test purposes only.'
HCAF0317DF2F0: 'WebAssembly：僅為測試目的在指令輸出中顯示堆疊寄存器。'
# 'Weight of the branch likely to be taken (default = 2000)'
H39B8B6D520C6: '可能被選擇的分支權重（預設值 = 2000）'
# 'Weight of the branch unlikely to be taken (default = 1)'
H2A04B39F2CCF: '未取用分支的權重（預設值 = 1）'
# 'What is the maximal lookup depth when trying to check for viability of negation sinking.'
H7F1CA4DE1A48: '嘗試檢查否定下沈可行性時的最大查找深度'
# 'What length to truncate vertex labels to '
H3DED4F5FCF91: '指定要截斷頂點標籤的長度'
# 'What to do with the summary when running this pass'
H42E595F78536: '執行此 pass 時對摘要的處理方式'
# 'When -fvisibility-inlines-hidden is enabled, static variables in inline C++ member functions will also be given hidden visibility by default'
HC9E644F8BF87: '在啟用 -fvisibility-inlines-hidden 時，內聯 C++ 成員函數中的 static 變數預設也會被賦予隱藏可見性'
# 'When a diagnostic is emitted on an operation, also print the operation as an attached note'
H2ECC08973193: '在運算上發出診斷時，也會將該運算列為附加註記'
# 'When a diagnostic is emitted, also print the stack trace as an attached note'
H76C424E9438C: '在發出診斷時，也會將堆疊追蹤列為附加註記'
# 'When creating a PCH, stop PCH generation after #pragma hdrstop.'
HD38248648BFF: '在建立 PCH 時，於 #pragma hdrstop 後停止 PCH 生成'
# 'When dfsan-combine-offset-labels-on-gep and/or dfsan-combine-pointer-labels-on-load are false, this flag can be used to re-enable combining offset and/or pointer taint when loading specific constant global variables (i.e. lookup tables).'
H081A797A7BB7: '當 dfsan-combine-offset-labels-on-gep 和/或 dfsan-combine-pointer-labels-on-load 為 false 時，此旗標可用來重新啟用讀取特定常量全域變數（例如查找表）時的偏移量和/或指標汙染合併'
# 'When discriminating instructions with memory operands, ignore prefetch instructions. This ensures the other memory operand instructions have the same identifiers after inserting prefetches, allowing for successive insertions.'
H7E4D0664626F: '在區分具有記憶體操作數的指令時忽略 prefetch 指令。這確保插入 prefetches 後其他記憶體操作數指令具有相同的識別符，允許後續插入'
# 'When displaying an injected source, display the file content'
H3DDBC39BBF92: '顯示注入的源碼時，顯示檔案內容'
# 'When dumping a SymIndexId, dump the full details of the corresponding record'
HE9EC08CB2E15: '傾印 SymIndexId 時，傾印對應記錄的完整細節'
# 'When dumping debug chunks, show a different section for each chunk'
HFD526CCFAF68: '傾印調試區塊時，為每個區塊顯示獨立區段'
# "When dumping type records for classes, unions, enums, and structs, don't try to resolve forward references"
HBD90D91A2AFF: '在傾印類別、聯合、列舉及結構的類型記錄時，不要嘗試解析前向引用'
# 'When epilogue vectorization is enabled, and a value greater than 1 is specified, forces the given VF for all applicable epilogue loops.'
H9B19DBFD9697: '當啟用尾部向量化時，若指定大於 1 的值，則對所有適用的尾部迴圈強制使用指定的 VF'
# 'When generating a crash reproducer, attempt to generated a reproducer with the smallest pipeline.'
H527701909117: '產生崩溃重現時，嘗試產生具有最小管線的重現'
# 'When generating nested context-sensitive profiles, always generate extra base profile for function with all its context profiles merged into it.'
H4E82789DA6E1: '產生嵌套上下文敏感剖析時，始終為函數產生額外基底剖析，將所有上下文剖析合併到其中'
# 'When merging conditional stores, do so even if the resultant basic blocks are unlikely to be if-converted as a result'
H33EB082F4E55: '即使合併條件存取後導致基本區塊若轉換可能性降低，仍執行條件存取的合併'
# 'When performing SCEV expansion only if it is cheap to do, this controls the budget that is considered cheap (default = 4)'
H6E8B9FA2EB34: '執行 SCEV 展開時僅在成本低廉時進行，此選項控制何謂低廉的預算（預設值 = 4）'
# 'When performing memory disambiguation checks at runtime do not generate more than this number of comparisons (default = 8).'
HBB48DD13984F: '執行即時記憶體歧異檢查時，不要產生超過此數量的比較（預設值 = 8）'
# 'When printing IR for print-[before|after]{-all} always print a module IR'
HEE9A6FDE189D: '印出IR時，若為print-[before|after]{-all}，始終印出模組IR'
# 'When printing IR for print-[before|after]{-all} for a loop pass, always print function IR'
HD8F4D915AAB6: '印出IR時，若為循環pass的print-[before|after]{-all}，始終印出函式IR'
# 'When printing IR for print-ir-[before|after]{-all} always print the top-level operation'
H58BBC34B4C5E: '印出IR時，若為print-ir-[before|after]{-all}，始終印出頂層運算式IR'
# 'When printing analysis, include information on every instruction'
H27AFC0602C62: '印出分析時，包含每一條指令的資訊'
# 'When printing machine IR, annotate instructions and blocks with SlotIndexes when available'
H8B62DF7E25E7: '印出機器IR時，若SlotIndexes可用，則為指令和區塊添加註記'
# 'When printing the IR after a pass, only print if the IR changed'
H0B8C96DE116C: '在印出pass之後的IR時，僅在IR改變時印出'
# 'When printing the IR after a pass, only print if the pass failed'
H42128FB51A38: '在印出pass之後的IR時，僅在pass失敗時印出'
# 'When printing the IR before/after a pass, print file tree rooted at this directory. Use in conjunction with mlir-print-ir-* flags'
HC069026BC657: '在印出pass前後的IR時，印出以該目錄為根的檔案樹。需與mlir-print-ir-*旗標搭配使用'
# 'When set to true, IR files will be processed and printed in their current debug info format, regardless of default behaviour or other flags passed. Has no effect if input IR does not contain debug records or intrinsics. Ignored in llvm-link, llvm-lto, and llvm-lto2.'
H75C824D62FD2: '若設定為true，IR檔案將會以目前的除錯資訊格式進行處理和印出，不論預設行為或其他旗標。若輸入的IR不包含除錯記錄或內建函式，則無效。在llvm-link、llvm-lto和llvm-lto2中被忽略。'
# 'When set to true, const objects with relocatable address values are put into the RO data section.'
H66324957E3F0: '若設定為true，具有可重新定位地址值的const物件將被置入RO資料區段。'
# 'When stubbing functions, replace all uses will null'
HBC6C3A0A1E4B: '在建立函數存根時，將所有使用替換為null'
# 'When the basic block contains not more than this number of PHI nodes, perform a (faster!) exhaustive search instead of set-driven one.'
H95DC35D4BF29: '當基本區塊的PHI節點數不超過此數值時，改為執行（更快！）的完整搜尋，而非集合驅動的搜尋。'
# 'When the option is false, if the target block is in a loop, the promotion will be disallowed unless the promoted counter  update can be further/iteratively promoted into an acyclic  region.'
HFCDA16D52A31: '若此選項為false，若目標區塊在循環中，則除非提升的計數器更新能進一步/迭代地被提升至無環區域，否則禁止進行提升。'
# 'When this option is on, the annotated branch probability will be emitted as optimization remarks: -{Rpass|pass-remarks}=pgo-instrumentation'
H5E55F3D7A2DD: '若此選項啟用，註記的分支機率將會以優化註記發出：-{Rpass|pass-remarks}=pgo-插樁'
# 'When to emit DWARF unwind (EH frame) info'
H0DBCF1BE684C: '發出DWARF例外處理（EH frame）資訊的時機'
# 'When to use colors in diagnostics'
HBE3593F16E43: '在診斷資訊中使用顏色的時機'
# 'When true, SLP vectorizer bypasses profitability checks based on heuristics and makes vectorization decision via cost modeling.'
H05B0C2731561: '若為true，SLP向量化器將跳過基於啟發法的效益檢查，並透過成本建模來進行向量化決策。'
# 'When used with filetype=obj, emit an object file which can be used with an incremental linker'
HE96BEC53314D: '與filetype=obj搭配使用時，產生可與增量連結器搭配使用的物件檔'
# 'When used with filetype=obj, relax all fixups in the emitted object file'
H167CB844A0DE: '與filetype=obj搭配使用時，鬆弛優化所產生物件檔中的所有修補'
# 'When using -fxray-function-groups, select which group of functions to instrument. Valid range is 0 to fxray-function-groups - 1'
H763EF25FAB59: '使用-fxray-function-groups時，選擇要插樿的函數群組。有效範圍為 0 到fxray-function-groups-1'
# 'When using a PCH, skip tokens until after a #pragma hdrstop.'
H0A2ABCA96B55: '使用 PCH 時，跳過語彙直到 #pragma hdrstop 之後。'
# 'Where to run polly in the pass pipeline'
H9B2F95971D75: '在 pass 管線中執行 Polly 的位置'
# 'Whether has closed-world assumption at link time'
H99F1999EDDBD: '是否在連結階段時使用閉世界假設'
# 'Whether inline replay should be applied to the entire Module or just the Functions (default) that are present as callers in remarks during cgscc inlining.'
HD26538F942D7: '是否將內聯重放套用至整個 Module，而非預設僅套用至在 cgscc 內聯期間備註中作為呼叫者的函數。'
# 'Whether inline replay should be applied to the entire Module or just the Functions (default) that are present as callers in remarks during sample profile inlining.'
H694D5B29DF1C: '是否將內聯重放套用至整個 Module，而非預設僅套用至在樣本剖析內聯期間備註中作為呼叫者的函數。'
# 'Whether new header will depend on old header. If true, clang-move will add #include of old header to new header.'
HEAD603DC16D2: '新頭文件是否依賴舊頭文件。若為 true，clang-move 會在新頭文件中加入舊頭文件的 #include。'
# 'Whether old header will depend on new header. If true, clang-move will add #include of new header to old header.'
H3B1BCC2BCADE: '舊頭文件是否依賴新頭文件。若為 true，clang-move 會在舊頭文件中加入新頭文件的 #include。'
# 'Whether or not to compute detailed function properties.'
H665EA58EEFEB: '是否計算詳細的函數屬性。'
# 'Whether or not to enable features under development for the ML regalloc advisor'
HF0690434B74D: '是否啟用機器學習寄存器分配建議器的開發中功能'
# 'Whether or not we should insert assumes of conditions of predicated guards'
H825B30E48FC9: '是否插入條件的假設，這些條件來自於條件式守衛。'
# 'Whether or not we should predicate guards expressed as widenable branches to deoptimize blocks'
H3D40391D0BD5: '是否將以可擴展分支表示的條件式守衛轉換為去優化區塊。'
# 'Whether or not we should widen guards  expressed as branches by widenable conditions'
HFD8C2DB7CA08: '是否將以分支表示且由可擴展條件所構成的守衛進行擴展。'
# 'Whether to apply ext-tsp placement for instances w/o profile'
H77F1EF844B16: '是否對無剖析資訊的實例套用 ext-tsp 位置安排。'
# 'Whether to build a relocatable precompiled header'
HB03E5614FB01: '是否建立可重新定位的預編譯頭文件'
# 'Whether to distribute into a loop that may not be if-convertible by the loop vectorizer'
HB249A06C5F2F: '是否將循環分配到可能無法被循環向量化器轉換的 if-convertible 環境中。'
# 'Whether to emit DWARF EH frame entries.'
HDDECD32989A5: '是否產生 DWARF EH 框架條目。'
# 'Whether to generate default bounds for arrays.'
HA8699205DACC: '是否為陣列生成預設邊界。'
# 'Whether to minimize added include paths'
HC7C82427C36C: '是否最小化新增的包含路徑'
# 'Whether to perform binary concatenation'
H4B115FCD938B: '是否執行二進位連接'
# 'Whether to perform binary extraction'
H9D6252A4435A: '是否執行二進位提取'
# 'Whether to try to emit Compact Unwind for non canonical entries.'
H55500B1ACFA7: '是否嘗試為非標準條目發出 Compact Unwind。'
# 'Whether to use the address from fix.box in data clause operations.'
H17A5E7DCB500: '是否使用在資料子句運算中 fix.box 的位址。'
# 'Whether to use the bareptr calling convention on the host (warning this should be false until the GPU layering is fixed)'
HEF14896C6BC2: '是否在主機使用 bareptr 呼叫約定（警告：在 GPU 層次結構修復前應設為 false）'
# 'Whether to use the bareptr calling convention on the kernel (warning this should be false until the GPU layering is fixed)'
H99F227DA714B: '是否在核心使用 bareptr 呼叫約定（警告：在 GPU 層次結構修復前應設為 false）'
# 'Whether to use the cost heuristic to make choices as we traverse the search space using the exact solver. Defaulted to on, and if turned off, we will use the node order -- attempting to put the later nodes in the later sched groups. Experimentally, results are mixed, so this should be set on a case-by-case basis.'
HF1BAF3533D97: '是否使用精確解算器在搜索空間中進行遍歷時，採用成本启发法進行選擇。默認開啟，若關閉則改用節點順序——嘗試將較後的節點安排在較後的排程群組中。實驗結果不一，因此應根據個案情況設置。'
# 'Whether to use the exponential time solver to fit the instructions to the pipeline as closely as possible.'
H086A0DF8B27C: '是否使用指數時間解算器將指令盡可能緊密地適配到管線中。'
# 'Whether we should inject new invariants and unswitch them to eliminate some existing (non-invariant) conditions.'
H3C32643D02A0: '是否注入新不變量並反向切換它們以消除部分現有（非不變）條件。'
# 'Which DWARF linkage-name attributes to emit.'
H09FB4F2415AD: '要發出的 DWARF 鏈接名稱屬性。'
# 'Which dependence analysis should loop fusion use?'
HAD495CD6F62E: '循環融合應使用哪種依存關係分析？'
# "Which overload candidates to show when overload resolution fails. Defaults to 'all'"
H3E34CE4DE5D1: "當重載解析失敗時，顯示哪些重載候選項？默認為 'all'"
# 'Which thread-local storage dialect to use for dynamic accesses of TLS variables'
H811A2F4F5EAE: '動態訪問 TLS 變數時使用的執行緒局部存儲語法'
# 'Which unit to use for fp math'
HE5F83035EE94: '使用哪種單位進行浮點運算'
# 'Widen sub-dword constant address space loads in AMDGPUCodeGenPrepare'
HA61656982921: '在 AMDGPUCodeGenPrepare 中擴展子字節（sub-dword）常數位址空間載入'
# 'Widen sub-dword constant address space loads in AMDGPULateCodeGenPrepare'
H16C37A921AE2: '在 AMDGPULateCodeGenPrepare 中擴展子字節（sub-dword）常數位址空間載入'
# "Widen the loop induction variables, if possible, so overflow checks won't reject flattening"
HF84F6515DE2A: '若可能，擴展迴圈誘導變量，以便溢位檢查不會拒絕平坦化'
# 'Widen uniform 16-bit instructions to 32-bit in AMDGPUCodeGenPrepare'
H46D2473C38FB: '在 AMDGPUCodeGenPrepare 中將均勻的 16 位指令擴展為 32 位'
# 'Windows exception model'
H86EB91F51633: 'Windows 例外處理模型'
# 'With -globals, only dump globals whose name matches the given value'
H08E7C52DD63F: '若使用 -globals，僅傾印名稱與給定值匹配的全域變數'
# 'With PGO, include profile count in optimization remarks'
HA68492B41822: '與 PGO 一起，在優化備註中包含剖面計數'
# 'Work around Cortex-A57 Erratum 1742098 (ARM only)'
H2CF5C8E79954: '針對 Cortex-A57 異常 1742098 進行工作週旋（僅限 ARM）'
# 'Work around Cortex-A72 Erratum 1655431 (ARM only)'
HB9954D8E1844: '回避Cortex-A72錯誤 1655431（僅ARM）'
# 'Work around VLLDM erratum CVE-2021-35465 (ARM only)'
H6484FD8B0341: '回避VLLDM錯誤CVE-2021-35465（僅ARM）'
# 'Work with `--skip-symbolization` or `--unsymbolized-profile` to write/read the offset instead of virtual address.'
H1CA65028F454: '與`--skip-symbolization`或`--unsymbolized-profile`一起使用，以寫入/讀取偏移量而非虛擬地址。'
# 'Workaround Cortex-A53 erratum 835769 (AArch64 only)'
H479486F0F64D: '回避Cortex-A53錯誤 835769（僅AArch64）'
# "Wouldn't use segmented stack"
HF45022A557BC: '不會使用分段堆疊'
# 'Write Bitcode'
H6EB243E1EECC: '寫入位碼'
# 'Write a compilation database entry per input'
H69BE4C131EAE: '為每個輸入寫入編譯數據庫條目'
# 'Write a depfile containing user and system headers'
HDB1957B0249A: '寫入包含用戶和系統頭文件的依賴文件'
# 'Write a depfile containing user headers'
H294C0D501665: '寫入包含用戶頭文件的依賴文件'
# 'Write assembly to file for input to assemble jobs'
H7C079FE214C7: '將輸入的組件工作寫入組裝檔案'
# 'Write current time into COFF output (default)'
HF98DECE931FC: '將當前時間寫入COFF輸出（預設）'
# 'Write debug info in the new non-intrinsic format. Has no effect if --preserve-input-debuginfo-format=true.'
H438D54E25242: '以新的非本徵格式寫入除錯資訊。若指定了--preserve-input-debuginfo-format=true則無效。'
# 'Write depfile output from -MMD, -MD, -MM, or -M to <file>'
H7F1DEF2B183F: '將-MD、-MMD、-MM或-M的依賴文件輸出寫入 <file>'
# 'Write extracted files to a static archive'
H167164B5BAE5: '將提取的文件寫入靜態庫'
# 'Write lazy-function executions to a CSV file as (JITDylib, function) pairs'
HEA5DEA15DFD8: '將懶執行函數寫入CSV文件，格式為（JITDylib，函數）對'
# 'Write linked LTO module to file before optimize'
HCE5CCE000DB8: '在優化前將連結的LTO模組寫入檔案'
# 'Write merged LTO module to file before CodeGen'
HD65008F3EA67: '在程式碼生成前將合併的LTO模組寫入檔案'
# 'Write minimized bitcode to <file> for the ThinLTO thin link only'
H675031C72335: '將精簡後的位碼寫入 <file> 供ThinLTO精簡連結使用'
# 'Write out individual imports files via InProcessThinLTO. Has no effect unless specified with -thinlto-emit-indexes or -thinlto-distributed-indexes'
H19E7DA782B06: '透過InProcessThinLTO輸出個別的導入文件。除非與-thinlto-emit-indexes或-thinlto-distributed-indexes一起指定，否則無效。'
# 'Write out individual index and import files for the distributed backend case'
H2A414F2C0CA7: '在分佈式後端情況下輸出個別的索引和導入文件'
# 'Write out individual index files via InProcessThinLTO'
H04EFB23839D1: '通過InProcessThinLTO輸出個別索引文件'
# 'Write output as LLVM assembly'
HC401168D9C72: '以LLVM組裝語言輸出'
# 'Write output as ThinLTO-ready bitcode'
H81BE69D83D3F: '輸出為ThinLTO準備好的位元碼'
# 'Write output to <file>'
HCABB93CE5040: '將輸出寫入 <file>'
# 'Write output to <file>.'
HA5CAFFC7A76E: '將輸出寫入 <file>。'
# 'Write relative block frequency to function summary '
H61EDFA1BBE67: '將相對區塊頻率寫入函數摘要 '
# 'Write summary to given YAML file after running pass'
H2786584E85AF: '在執行Pass後將摘要寫入指定的YAML文件'
# 'Write summary to given bitcode or YAML file after running pass. Output file format is deduced from extension: *.bc means writing bitcode, otherwise YAML'
HF422AA3A57C9: '在執行Pass後將摘要寫入指定的位元碼或YAML文件。輸出文件格式根據擴展名推斷：*.bc表示輸出位元碼，否則為YAML'
# 'Write the previous version of indexed format, to enable some forward compatibility.'
H214BE48CC62F: '寫入索引格式的前一版本，以實現部分向前兼容性。'
# 'Writes always set the type'
H90F97A092B90: '寫入操作始終設定類型'
# 'X86 Call Frame Optimization'
H6C1AD91D1BC8: 'X86調用框架優化'
# 'X86 DAG->DAG Instruction Selection'
H7AF1958AB670: 'X86 DAG→DAG指令選擇'
# 'X86 Domain Reassignment Pass'
H208A2EDE1B82: 'X86領域重新分配Pass'
# 'X86 DynAlloca Expander'
H1CB6E843E202: 'X86 DynAlloca展開器'
# 'X86 EFLAGS copy lowering'
H478602C51D49: 'X86 EFLAGS複製降級'
# 'X86 Execution Domain Fix'
HB1A8033FDC96: 'X86執行領域修正'
# 'X86 FP Stackifier'
HB70E458DAF08: 'X86浮點堆疊器'
# 'X86 LVI load hardening'
HE886300056CC: 'X86 LVI載入強化'
# 'X86 LVI ret hardener'
H7BB1121F99C0: 'X86 LVI返回強化'
# 'X86 Partial Reduction'
H71421E3EAECA: 'X86部分簡化'
# 'X86 Return Thunks'
HB7A0BD877623: 'X86 回傳存根函數'
# 'X86 Speculative Execution Side Effect Suppression'
HAC95FD71C1F3: 'X86 推測執行副作用抑制'
# 'X86 cmov Conversion'
H459397A41EF1: 'X86 cmov 轉換'
# 'X86 optimize LEA pass'
HA2592D9DB191: 'X86 optimize LEA pass'
# 'X86 pseudo instruction expansion pass'
H90C7B8C811FD: 'X86 pseudo instruction展開 pass'
# 'X86 speculative load hardener'
H2A7987566821: 'X86 推測載入強化'
# 'X86: Disable LEA optimizations.'
H9A76B9360F40: 'X86: 禁用 LEA 優化。'
# 'X86: Disable Store Forwarding Blocks fixup.'
H182CD9732E25: 'X86: 禁用 Store Forwarding Blocks 修正。'
# 'X86: Disable Virtual Register Reassignment.'
H12CE3299B81B: 'X86: 禁用虛擬寄存器重新分配。'
# 'X86: Number of instructions backward to inspect for store forwarding blocks.'
HEFF525BFF565: 'X86: 用於檢查 Store Forwarding Blocks 的反向指令數量。'
# 'X86: enable AMX scalarizition.'
HCECBA05C8A45: 'X86: 啟用 AMX 標量化。'
# 'XCore DAG->DAG Pattern Instruction Selection'
H581ED762EAE6: 'XCore DAG->DAG 模式指令選擇'
# 'XRay Tools\n\n  This program consolidates multiple XRay trace processing tools for convenient access.\n'
HFB113E3ACE56: 'XRay 工具\n\n  這個程式整合多個 XRay 追蹤處理工具以方便存取。\n'
# 'YAML'
HFFBCB202B09D: 'YAML'
# 'Yaml database created by find-all-symbols'
H338C17AD7D21: 'YAML 資料庫（由 find-all-symbols 創建）'
# 'Yaml database, with fuzzy-matched names'
H858A2F00C528: 'YAML 資料庫（包含模糊匹配的名稱）'
# 'Zero initialize globals without default initialization'
H16BF774B86E6: '將未經預設初始化的全域變數初始化為零'
# 'Zero initialize globals without default initialization (default)'
H49398887AE1B: '將未經預設初始化的全域變數初始化為零（預設）'
# 'Zero line numbers.'
HBDDF04B8DE1F: '將行號設為零。'
# 'Zero out the discriminator bits for the FS discrimiantor pass beyond this value. The enum values are defined in Support/Discriminator.h'
H86161643B09B: '將 FS discriminator pass 中超過此值的 discriminator 比特設為零。枚舉值定義在 Support/Discriminator.h 中'
# '[<input file>,...] (deprecated)'
HBAF2C191067E: '[<輸入檔案>,...] (已棄用)'
# '[<offload kind>-<target triple>,...]'
HE5C00640F67F: '[<卸載類型-目標三元組>,...]'
# '[<output file>,...] (deprecated)'
H701132FD6E40: '[<輸出檔案>,...] (已棄用)'
# '[@<file>] [<file> ...]'
HA0A725D8D937: '[@<檔案>] [<檔案> ...]'
# '[LICM & MemorySSA] When MSSA in LICM is disabled, this has no effect. When MSSA in LICM is enabled, then this is the maximum number of accesses allowed to be present in a loop in order to enable memory promotion.'
H15A8950FC7AE: '[LICM & MemorySSA] 當 LICM 中的 MemorySSA 無效時，此選項無效。當 LICM 中啟用 MemorySSA 時，此為允許在迴圈中存在記憶體提升的存取數量上限。'
# '[WIP] Tries to hide the latency of host to device memory transfers'
HC6732C3722E0: '[WIP] 嘗試隱藏主機到設備記憶體傳輸的延遲'
# '[[]] attributes are a C++11 extension'
H8246F8EB1C38: '[[]] 屬性是 C++11 的擴充'
# '[[]] attributes are a C23 extension'
H65C81736C143: '[[]] 屬性是 C23 的擴充'
# '[[]] attributes are incompatible with C standards before C23'
HFCBAAA359BD9: '[[]] 屬性與 C23 之前的所有 C 標準相容性'
# '[[]] attributes are incompatible with C++ standards before C++11'
H963EC793AF1E: '[[]] 屬性與 C++11 之前的所有 C++ 標準相容性'
# '[code to run]'
HBFD9181194E0: '[要執行的程式碼]'
# '[ignorelist file]'
H5547568B1A46: '[忽略清單檔案]'
# '[input bitcode]...'
H8C715EEC26A7: '[輸入位元碼]...'
# '[no]neon is not accepted as modifier, please use [no]simd instead'
H34DCBA8F9AA1: '[no]neon 不是有效的修飾符，請改用 [no]simd'
# '\\%0 used with no following hex digits'
H4ACD9688DA19: '\\%0 使用時後面未跟十六進位數字'
# "\\%0 used with no following hex digits; treating as '\\' followed by identifier"
H34C9A007F8A0: "\\%0 使用時後面未跟十六進位數字；將其視為 '\\' 後接的識別符"
# '^^ is a reserved operator in OpenCL'
H0C0A23A57F10: '^^ 是 OpenCL 中的保留運算符'
# '_Atomic cannot be applied to %select{incomplete |array |function |reference |atomic |qualified |sizeless ||integer |}0type %1 %select{|||||||which is not trivially copyable||in C23}0'
H323CC2CB8E5D: '_Atomic 無法套用到 %select{不完整 |陣列 |函數 |引用 |原子 |已修飾 |無大小 ||整數 |}0 類型 %1 %select{|||||||其不是可輕鬆複製的類型||在 C23 中}0'
# '_GLOBAL_OFFSET_TABLE_'
HE310DB69A9CE: '_GLOBAL_OFFSET_TABLE_'
# '_Pragma takes a parenthesized string literal'
HC3D115F3D6CB: '_Pragma 需要括號包圍的字串文字'
# '__DATA'
H6F22B9326AE7: '__DATA'
# '__LINKEDIT'
H1EA417FFF11E: '__LINKEDIT'
# '__VA_ARGS__ can only appear in the expansion of a C99 variadic macro'
HA5D98E4DA6FF: '__VA_ARGS__ 只能在C99可變參數宏的展開中出現'
# '__VA_OPT__ can only appear in the expansion of a variadic macro'
HCDC494FE863F: '__VA_OPT__ 只能在可變參數宏的展開中出現'
# '__VA_OPT__ cannot be nested within its own replacement tokens'
H7C3979F48311: '__VA_OPT__ 不可嵌套在自身取代的語法中'
# '__arm_agnostic("sme_za_state") cannot share ZA state with its caller'
H3F5679E58734: '__arm_agnostic("sme_za_state") 與呼叫者無法共享 ZA 狀態'
# '__arm_agnostic("sme_za_state") is not supported together with __arm_new("za") or __arm_new("zt0")'
H1551D9BB8B08: '__arm_agnostic("sme_za_state") 不支援與 __arm_new("za") 或 __arm_new("zt0") 同時使用'
# '__asm used with no assembly instructions'
H8FE87A3A5F53: '__asm 用於沒有組裝指令的語境中'
# '__block attribute not allowed on declaration with a variably modified type'
H10FB78A8E9A5: '可變長度類型的宣告不可使用 __block 屬性'
# '__block attribute not allowed, only allowed on local variables'
HE188099287CD: '__block 屬性不被允許，僅允許用於局部變數'
# '__block variable %0 cannot be captured in a %select{lambda expression|captured statement}1'
HD7DB9752FAAD: '__block 變數 %0 無法在 %select{lambda 表達式|被捕獲的語句}1 中被捕獲'
# '__builtin_btf_type_id argument %0 not a constant'
H48F1BECDC866: '__builtin_btf_type_id 參數 %0 非常數值'
# '__builtin_longjmp is not supported for the current target'
H53A6EFDFCD17: '__builtin_longjmp 不支援目前的目標平台'
# "__builtin_mul_overflow does not support 'signed _BitInt' operands of more than %0 bits"
H24B9AB05270A: '__builtin_mul_overflow 不支援超過 %0 位元的 signed _BitInt 運算元'
# '__builtin_preserve_enum_value argument %0 invalid'
H341194DCABD7: '__builtin_preserve_enum_value 參數 %0 無效'
# '__builtin_preserve_enum_value argument %0 not a constant'
HCADD1D27CE0B: '__builtin_preserve_enum_value 參數 %0 非非常數值'
# '__builtin_preserve_field_info argument %0 not a constant'
HA3DE67421A5E: '__builtin_preserve_field_info 參數 %0 非非常數值'
# '__builtin_preserve_field_info argument %0 not a field access'
H153927D1D427: '__builtin_preserve_field_info 參數 %0 不是欄位存取'
# '__builtin_preserve_type_info argument %0 invalid'
H92B5B29F2F9A: '__builtin_preserve_type_info 參數 %0 無效'
# '__builtin_preserve_type_info argument %0 not a constant'
H57FE08B33075: '__builtin_preserve_type_info 參數 %0 非非常數值'
# '__builtin_setjmp is not supported for the current target'
H08E9B75B93D5: '__builtin_setjmp 當前目標不支援'
# '__constant__, __device__, and __managed__ are not allowed on non-static local variables'
H4A2DC7998EB3: '__constant__、__device__ 和 __managed__ 不能用在非靜態的局部變數上'
# '__declspec attribute %0 is not supported'
H4B7BDD3DADC0: '__declspec 屬性 %0 不受支援'
# '__declspec attributes must be an identifier or string literal'
HBBCBBEE3784E: '__declspec 屬性必須是識別符或字串文字'
# '__final is a GNU extension, consider using C++11 final'
H9019DE700CF0: '__final 是 GNU 延伸功能，建議使用 C++11 的 final'
# '__grid_constant__ is only allowed on const-qualified kernel parameters'
HDE081328BF07: '__grid_constant__ 只能用在 const 修飾的核函數參數上'
# '__has_warning expected option name (e.g. "-Wundef")'
H96068DA3D4D1: '__has_warning 需要選項名稱（例如："-Wundef"）'
# '__shared__ local variables not allowed in %select{__device__|__global__|__host__|__host__ __device__}0 functions'
H0BA8A02BD0B3: '__shared__ 本地變數不能用在 %select{__device__|__global__|__host__|__host__ __device__}0 函數中'
# "__shared__ variable %0 cannot be 'extern'"
H76DC43AF246B: "__shared__ 變數 %0 不能被宣告為 'extern'"
# '__spirv_backend_service_fun'
HEC37DE49A8CD: '__spirv_backend_service_fun'
# '__sync builtin operation must have natural alignment (consider using __atomic)'
HFAE067F4A98D: '__sync 內建運算必須使用自然對齊（建議改用 __atomic）'
# '__weak attribute cannot be specified on a field declaration'
HAD92983EAEB2: '__weak 屬性不能用在成員宣告上'
# '__weak attribute cannot be specified on an automatic variable when ARC is not enabled'
HC15AE9021482: '__weak 屬性在未啟用 ARC 時不能用在自動變數上'
# '`#pragma const_seg` for section %1 will not apply to %0 due to the presence of a %select{mutable field||non-trivial constructor|non-trivial destructor}2'
H8811D5F6122A: '`#pragma const_seg` 對區段 %1 將不會套用到 %0，因為存在 %select{可變更的成員||非平凡建構函數|非平凡析構函數}2'
# 'a %select{function|block}0 declaration without a prototype is deprecated %select{in all versions of C|}0'
HA427D7F1B8D9: '一個沒有原型的%select{函數|區塊}0宣告在C的各個版本中已棄用 %select{|}0'
# "a %select{pack indexing|'decltype'}0 specifier cannot be used in a declarative nested name specifier"
H505B17716528: "%select{封包索引|'decltype'}0 指定項不能用在宣告式巢狀名稱指定項中"
# 'a concept definition cannot refer to itself'
H3304727AB46C: '概念定義不可引用自身'
# 'a constant expression cannot modify an object that is visible outside that expression'
H91A285505D66: '常數運算式不能修改在運算式外可見的物件'
# 'a declarative nested name specifier cannot name an alias template'
H09803710CDAC: '宣告式巢狀名稱指定項不能指定別名模板'
# 'a firstprivate variable with incomplete type %0'
H893794AB5FB9: '具有不完整類型 %0 的 firstprivate 變數'
# 'a friend declaration that befriends a template must contain exactly one type-specifier'
HDEE648B4A187: '與模板建立友元關係的友元宣告必須包含恰好一個類型說明符'
# 'a function %select{declaration|definition}0 without a prototype is deprecated in all versions of C %select{and is not supported in C23|and is treated as a zero-parameter prototype in C23, conflicting with a %select{previous|subsequent}2 %select{declaration|definition}3}1'
HB3E1938E8933: '一個沒有原型的%select{宣告|定義}0在C的各個版本中已棄用%select{且在C23中不受支援|且在C23中被視為零參數原型，與%select{先前|後續}2 %select{宣告|定義}3衝突}1'
# 'a function type is not allowed here'
HE650A35390C3: '這裡不允許使用函數類型'
# 'a getter method is needed to perform a compound assignment on a property'
HEDE5FCF91532: '需要一個getter方法才能對屬性執行複合指派'
# 'a lambda expression cannot appear in this context'
H979A7AF92A65: '在此語境中不能出現lambda表達式'
# 'a lambda expression may not appear inside of a constant expression'
HB0755DD5F929: 'lambda表達式不能出現在常數運算式內'
# 'a lambda parameter cannot shadow an explicitly captured entity'
H65FE428CB516: 'lambda參數不能遮蔽明確捕獲的實體'
# 'a lambda with an explicit object parameter cannot be mutable'
HF1252DDC6E4B: '具有顯式物件參數的lambda不能為可變'
# 'a lastprivate variable with incomplete type %0'
H8324467E21DA: '具有不完整類型 %0 的lastprivate變數'
# 'a linear variable with incomplete type %0'
HE61951ED0B99: '具有不完整類型 %0 的linear變數'
# 'a module can only be re-exported as another top-level module'
H272C723A8726: '只能將模組重新導出為另一個頂層模組'
# 'a non-type template parameter cannot have type %0'
H4D4081CB8796: '非類型模板參數不能具有類型 %0'
# 'a non-type template parameter cannot have type %0 before C++20'
HEEE0AA3066FD: '在C++20之前非類型模板參數不能具有類型 %0'
# 'a parameter list without types is only allowed in a function definition'
H52BB0DED62AC: '只有函數定義允許省略參數類型清單'
# 'a parameter pack may not be accessed at an out of bounds index'
H3E85B76262B3: '不能在超出邊界的索引位置存取參數包'
# 'a private variable with incomplete type %0'
H0A7C86E8874A: '具有不完整類型 %0 的私有變數'
# 'a randomized struct can only be initialized with a designated initializer'
H4615845B3A9F: '隨機化結構必須使用指定初始化式進行初始化'
# 'a reduction list item with incomplete type %0'
H06AA7BC953CB: '具有不完整類型 %0 的reduction清單項目'
# 'a requires expression cannot have an explicit object parameter'
H86B74E3E67C6: 'requires表達式不能具有顯式物件參數'
# 'a requires expression must contain at least one requirement'
HA35998709F70: 'requires表達式必須至少包含一個需求'
# "a space is required between a right angle bracket and an equals sign (use '> =')"
H9BFA1E21C4F4: '在右尖括號和等號之間需要一個空格（使用 "> =")'
# "a space is required between consecutive right angle brackets (use '> >')"
H529B67153B9E: '在連續的右尖括號之間需要一個空格（使用 "> >")'
# 'a static lambda cannot have any captures'
H2E5388A18076: '靜態lambda不能有任何捕獲'
# 'a static_assert declaration cannot be a template'
HA1124669302F: 'static_assert宣告不能是模板'
# 'a template argument list is expected after a name prefixed by the template keyword'
HF4A21ADFAB4E: '以 template 關鍵字為前綴的名稱後面需要跟模板參數列表'
# 'a type named %0 is hidden by a declaration in a different namespace'
H26CC1C864C4C: '名為 %0 的類型被另一個命名空間中的宣告所隱藏'
# 'a type specifier is required for all declarations'
HA2239D7DA67E: '所有宣告都需要類型說明符'
# 'a typedef cannot be a template'
H878607247E5C: 'typedef不能是模板'
# 'absolute value function %0 given an argument of type %1 but has parameter of type %2 which may cause truncation of value'
H2B4AC1EEC989: '絕對值函數 %0 被傳遞了一個類型為 %1 的參數，但其參數類型為 %2，這可能會導致值被截斷'
# "abstract class is marked '%select{final|sealed}0'"
H9546D737D23E: '抽象類被標記為 "%select{final|sealed}0"'
# 'access declarations are deprecated; use using declarations instead'
H3431BA5113E5: '訪問宣告已被棄用；請改用using宣告'
# 'access qualifier %0 cannot be used for %1 %select{|prior to OpenCL C version 2.0 or in version 3.0 and without __opencl_c_read_write_images feature}2'
HC43552CB1BAC: '訪問限定符 %0 不能用於 %1 %select{|在OpenCL C版本 2.0之前或在版本 3.0且沒有__opencl_c_read_write_images功能時}2'
# 'access qualifier can only be used for pipe and image type'
HCF9598AD42BA: '訪問限定符只能用於pipe和image類型'
# 'access specifier can only have annotation attributes'
H00A8BDFCED49: '訪問說明符只能具有註解屬性'
# 'access specifiers are a clang HLSL extension'
H23D01BBD184F: '訪問說明符是clang HLSL擴充功能'
# 'accessing a member of an atomic structure or union is undefined behavior'
H1C0790EC0EC6: '訪問原子結構或共用體的成員是未定義行為'
# 'accessing inaccessible direct base %0 of %1 is a Microsoft extension'
H76AFA5796E64: '訪問 %1 的不可訪問直接基類 %0 是Microsoft擴充功能'
# "acquiring %0 '%1' requires negative capability '%2'"
HC095E2CF1B84: '獲取 %0 "%1" 需要否定能力 "%2"'
# "acquiring %0 '%1' that is already held"
H4DA573668147: '獲取已經持有的 %0 "%1"'
# 'action %0 not compiled in'
HA82E8BAC3ED2: '未編譯進動作 %0'
# "active '%0' clause defined here"
H5264E053D9D8: "在此處定義的活躍 '%0' 子句"
# 'add \'__arm_preserves("za")\' to the callee if it preserves ZA'
HD939B5A83F36: '如果被呼叫函數保留 ZA，則在其上添加 \'__arm_preserves("za")\''
# "add 'constexpr'"
H48500D7C1CF8: "添加 'constexpr'"
# "add 'export' here if this is intended to be a module interface unit"
H8499B2C3202C: "如果此處意圖為模組介面單元，則在此處添加 'export'"
# "add 'module;' to the start of the file to introduce a global module fragment"
H1399A9153C66: "在檔頭添加 'module;' 以引進全域模組片段"
# "add 'typename' to treat this using declaration as a type"
H2514B140BEE5: "添加 'typename' 以將此使用宣告視為類型"
# "add 'u8' prefix to form a 'char8_t' string literal"
H8C73CF0B8333: "添加 'u8' 前綴以形成 'char8_t' 字元串字面量"
# "add 'void' to the parameter list to turn an old-style K&R function declaration into a prototype"
H460C61046151: "向參數列表添加 'void' 以將舊式 K&R 函數宣告轉換為原型"
# "add a '@synthesize' directive"
H11A117C94448: "添加 '@synthesize' 指令"
# 'add a deduction guide to suppress this warning'
H4B93D4018373: '添加一個推導指引以抑制此警告'
# 'add a deprecation attribute to the declaration to silence this warning'
HE29FCC14DCE0: '在宣告中添加一個棄用屬性以抑制此警告'
# 'add a pair of parentheses to declare a variable'
H9B65CA134C28: '添加一對括號以宣告變數'
# 'add a super class to fix this problem'
HD3A4A44147E8: '添加一個父類別以修復此問題'
# 'add a variable name to declare a %0 initialized with %1'
HBF079F80BA92: '添加一個變數名稱以宣告一個使用 %1 初始化的 %0'
# "add an explicit capture of 'this' to capture '*this' by reference"
H44758706CE87: "添加對 'this' 的明確擕帶以通過引用擕帶 '*this'"
# 'add an explicit instantiation declaration to suppress this warning if %q0 is explicitly instantiated in another translation unit'
HA69020D4B8A0: '如果 %q0 在其他翻譯單位中被明確實例化，則添加明確實例化宣告以抑制此警告'
# 'add any string to tag this execution in the output binary via bolt info section'
HF4F001FFA024: '通過 bolt 資訊區段在輸出二進位檔中添加任何字串以標記此執行'
# 'add basic block instructions as tool tips on nodes'
H4A2F65627544: '在節點上將基本區塊指令添加為工具提示'
# 'add enclosing parentheses to perform a function-style cast'
H3C4C77285B3F: '添加括號以執行函數式轉型'
# 'add explicit braces to avoid dangling else'
H912E67080844: '添加顯式大括號以避免懸垂else問題'
# 'add masking cost for i1 vectors'
H3E72A2897B81: '為i1向量添加遮罩成本'
# "add parentheses after the '!' to evaluate the %select{comparison|bitwise operator}0 first"
H7D8E708D64E0: '在 "!" 後添加括號以優先評估%select{比較運算式|位元運算子}0'
# 'add parentheses around left hand side expression to silence this warning'
HB1B6850C2A11: '在左邊運算式外添加括號以消除此警告'
# "add the %select{'require_constant_initialization' attribute|'constinit' specifier}0 to the initializing declaration here"
HFE1D4C8144BF: '在此初始化宣告處添加 %select{require_constant_initialization 屬性|constinit 指定詞}0'
# 'adding %0 to %1 might cause circular dependency in container'
H157957572465: '將 %0 加入 %1 可能在容器中造成循環依賴'
# 'adding %0 to a string does not append to the string'
H98175222693E: '將 %0 加到字串不會追加字串內容'
# 'adding %0 to a string pointer does not append to the string'
HE53429791B46: '將 %0 加到字串指標不會追加字串內容'
# 'addition of default argument on redeclaration makes this constructor a %select{default|copy|move}0 constructor'
H540EC7EBFA01: '重新宣告時添加預設參數將使此建構函式成為%select{預設|複製|移動}0建構函式'
# 'address argument to atomic builtin cannot be const-qualified (%0 invalid)'
H05DD72B70C0D: '原子內建函數的地址參數不能是const限定 (%0 錯誤)'
# 'address argument to atomic builtin must be a pointer %select{|to a non-zero-sized object }1(%0 invalid)'
H25FC8322E786: '原子內建函數的地址參數必須是 %select{|指向非零大小物件的 }1指標 (%0 錯誤)'
# 'address argument to atomic builtin must be a pointer to 1,2,4,8 or 16 byte type (%0 invalid)'
H8F0926664FBC: '原子內建函數的地址參數必須是指向 1、2、4、8或 16 位元組型別的指標 (%0 錯誤)'
# 'address argument to atomic builtin must be a pointer to integer or pointer (%0 invalid)'
H05518FC9E223: '原子內建函數的地址參數必須是指向整數或指標型別的指標 (%0 錯誤)'
# 'address argument to atomic builtin must be a pointer to integer, floating-point or pointer (%0 invalid)'
H4BE1CF542714: '原子內建函數的地址參數必須是指向整數、浮點數或指標型別的指標 (%0 錯誤)'
# 'address argument to atomic operation must be a pointer to %select{|atomic }0integer (%1 invalid)'
H45F0D7833F1F: '原子運算的地址參數必須是指向 %select{|原子 }0整數型別的指標 (%1 錯誤)'
# 'address argument to atomic operation must be a pointer to %select{|atomic }0integer or pointer (%1 invalid)'
HD792403A7931: '原子運算的地址參數必須是指向 %select{|原子 }0整數或指標型別的指標 (%1 錯誤)'
# 'address argument to atomic operation must be a pointer to %select{|atomic }0integer or supported floating point type (%1 invalid)'
H645D002EEC1B: '原子運算的地址參數必須是指向 %select{|原子 }0整數或支援的浮點數型別的指標 (%1 錯誤)'
# 'address argument to atomic operation must be a pointer to %select{|atomic }0integer, pointer or supported floating point type (%1 invalid)'
HF8B6B0144FE9: '原子運算的地址參數必須是指向 %select{|原子 }0整數、指標或支援的浮點數型別的指標 (%1 錯誤)'
# 'address argument to atomic operation must be a pointer to _Atomic type (%0 invalid)'
HED971913A5AB: '原子運算的地址參數必須是指向 _Atomic 類型的指標（%0 適用）'
# 'address argument to atomic operation must be a pointer to a trivially-copyable type (%0 invalid)'
H0F2B276FBFF5: '原子運算的地址參數必須是指向可簡單複製（trivially-copyable）類型的指標（%0 適用）'
# 'address argument to atomic operation must be a pointer to non-%select{const|constant}0 _Atomic type (%1 invalid)'
H77D9C30AD097: '原子運算的地址參數必須是指向非 %select{const|constant}0 _Atomic 類型的指標（%1 適用）'
# 'address argument to atomic operation must be a pointer to non-const type (%0 invalid)'
HA961ACF648B8: '原子運算的地址參數必須是指向非const類型的指標（%0 適用）'
# 'address argument to load or store exclusive builtin must be a pointer to 1,2,4 or 8 byte type (%0 invalid)'
H7473631C7DCE: '排程或存取排他內建函數的地址參數必須是指向 1、2、4 或 8 字節類型的指標（%0 適用）'
# 'address argument to nontemporal builtin must be a pointer (%0 invalid)'
H15C0E2A98779: '非暫存內建函數的地址參數必須是指向指標（%0 適用）'
# 'address argument to nontemporal builtin must be a pointer to integer, float, pointer, or a vector of such types (%0 invalid)'
H411242986562: '非暫存內建函數的地址參數必須是指向整數、浮點數、指標或這些類型的向量的指標（%0 適用）'
# "address of %select{'%1'|function '%1'|array '%1'|lambda function pointer conversion operator}0 will always evaluate to 'true'"
H17F3EBE2635E: "「%select{地址為 %1|函數「%1」的地址|陣列「%1」的地址|lambda函數指標轉換運算子}0」的地址將始終評估為 'true'"
# 'address of %select{bit-field|vector element|property expression|register variable|matrix element}0 requested'
HD8B1334D046A: '請求%select{位域|向量元素|屬性運算式|登錄變數|矩陣元素}0 的地址'
# "address of non-static constexpr variable %0 may differ on each invocation of the enclosing function; add 'static' to give it a constant address"
HE51DD27041F6: "非靜態 constexpr 變數 %0 的地址在封裝函數的每次調用中可能不同；添加 'static' 以使其具有常數地址"
# 'address of overloaded function %0 cannot be cast to type %1'
H358904EBF6FD: '無法將重載函數 %0 的地址轉換為類型 %1'
# 'address of overloaded function %0 cannot be converted to type %1'
HCCA08BC04209: '無法將重載函數 %0 的地址轉換為類型 %1'
# 'address of overloaded function %0 cannot be static_cast to type %1'
HE4591559B0BB: '無法將重載函數 %0 的地址 static_cast 轉換為類型 %1'
# 'address of overloaded function %0 does not match required type %1'
H11264D1F1C79: '重載函數 %0 的地址不匹配所需類型 %1'
# 'address of overloaded function %0 is ambiguous'
H33C49268724E: '重載函數 %0 的地址轉換存在歧義'
# 'address space is larger than the maximum supported (%0)'
HFA6456E815BE: '地址空間大於最大支援值（%0）'
# 'address space is negative'
H7DA3DAA44B98: '地址空間為負數'
# 'address taken in non-type template argument for template parameter of reference type %0'
HD465BC48688F: '為參考類型範型參數 %0 的非型態參數取得地址'
# 'address-of operator cannot be applied to a call to a function with unknown return type'
HA9D761CAF77E: '無法對具有未知返回類型的函數調用使用取址運算子'
# 'adjust block counts based on outgoing branch counts'
H117EF7587146: '根據出站分支計數調整區塊計數'
# 'adjust function counts based on basic blocks execution count'
H14DEF224A29B: '根據基本區塊的執行次數調整函數計數'
# 'adjust function profile after inlining'
HDCFC372259BA: '內聯後調整函數剖面'
# "after modifying system headers, please delete the module cache at '%0'"
H01FFB29D96B3: '修改系統標頭後，請刪除位於「%0」的模組快取'
# 'aggregate basic samples (without LBR info)'
H9B9419C851BC: '聚合基本樣本（無LBR資訊）'
# 'aggregate initialization of type %0 from a parenthesized list of values is a C++20 extension'
H6B5CF381E65A: '從值的括號列表初始化類型 %0 的聚合結構是C++20擴展'
# 'aggregate initialization of type %0 with user-declared constructors is incompatible with C++20'
HC24621DDDD5F: '具有用戶宣告建構函數的類型 %0 的聚合初始化與C++20不相容'
# 'aggressive strategy'
H5CB7E66C0F79: '激進策略'
# 'aggressively inline everything'
HF506129362A1: '激進內聯所有內容'
# 'aggressively split jump tables section based on usage of the tables'
HF15D48A1547F: '根據表格使用情況激進分割jump tables區段'
# 'algorithm used to reorder data sections'
H5E8D0AEA074C: '用於重新排列資料段的演算法'
# 'alias declaration cannot be a pack expansion'
H7E12EB8475DC: '別名宣告不能是包擴展'
# 'alias declaration in this context is a C++23 extension'
H91EDBE36B117: '此語境中的別名宣告是C++23擴展'
# 'alias declaration in this context is incompatible with C++ standards before C++23'
HC4280923DB99: '此語境中的別名宣告與C++23之前的C++標準不相容'
# 'alias declarations are a C++11 extension'
HE9649A76CF28: '別名宣告是C++11擴展'
# 'alias declarations are incompatible with C++98'
H47305448BB21: '別名宣告與C++98不相容'
# 'alias definition of %0 after tentative definition'
HBC2E292F4F78: '%0 的別名定義在暫時性宣告之後'
# 'alias for --icp-jump-tables-targets'
H3295D8EF4BCC: '--icp-jump-tables-targets的別名'
# 'alias for --indirect-call-promotion-calls-topn'
H056F07540EAC: '--indirect-call-promotion-calls-topn的別名'
# 'alias for --indirect-call-promotion-jump-tables-topn'
H48FD0DD2A352: '--indirect-call-promotion-jump-tables-topn的別名'
# 'alias for --indirect-call-promotion-mispredict-threshold'
H69D659FF6417: '--indirect-call-promotion-mispredict-threshold 的別名'
# 'alias for --indirect-call-promotion-topn'
H2CDF1F6846ED: '--indirect-call-promotion-topn 的別名'
# 'alias for --indirect-call-promotion-use-mispredicts'
H6632963673FD: '--indirect-call-promotion-use-mispredicts 的別名'
# 'alias for -aarch64-streaming-hazard-size'
H6DD0A61F8614: '-aarch64-streaming-hazard-size 的別名'
# 'alias for -data'
H18AAC29B91E1: '-data 的別名'
# 'alias for -instr_map'
H8C404A340D69: '-instr_map 的別名'
# 'alias for -perfdata'
H4AA3F61C654A: '-perfdata 的別名'
# 'alias for -symbolize'
HF105886B4E32: '-symbolize 的別名'
# 'alias to a variable in a common section is not allowed'
H93F6002973E0: '指向 common section 中變數的別名是不被允許的'
# 'aliases are not supported on darwin'
H41CBE942EE33: '在 Darwin 平台上不支援別名'
# 'align basic blocks'
H546676202A2D: '對齊基本區塊'
# 'align functions at a given value (relocation mode)'
HA06778A68136: '以指定值對齊函數（重新定位模式）'
# 'align only blocks with frequency larger than containing function execution frequency specified in percent. E.g. 1000 means aligning blocks that are 10 times more frequently executed than the containing function.'
H9CD01CD0B966: '僅對那些執行頻率高於所屬函數執行頻率指定百分比的基本區塊進行對齊。例如，1000 表示對執行次數為所屬函數的 10 倍以上的區塊進行對齊。'
# "aligned %select{allocation|deallocation}0 function of type '%1' is %select{only|not}4 available on %2%select{ %3 or newer|}4"
H9703DDF7875E: "類型 '%1' 的 %select{分配|釋放}0 函數在 %2%select{ %3 或更新版本|}4%select{ 僅|不}4 可用"
# 'aligned clause will be ignored because the requested alignment is not a power of 2'
HC3A503B9038C: 'aligned 子句將被忽略，因為請求的對齊值不是 2 的冪次'
# 'alignment (%0) of thread-local variable %1 is greater than the maximum supported alignment (%2) for a thread-local variable on this target'
H9951DC0F93CA: '執行緒局部變數 %1 的對齊值 (%0) 高於此目標對執行緒局部變數支援的最大對齊值 (%2)'
# "alignment is not a power of 2 in '%0'"
HB7B2FF437212: "在 '%0' 中，對齊值不是 2 的冪次"
# 'alignment of .text section'
H7D89ABD80F0F: '.text 區段的對齊'
# 'alignment of 16 bytes for a struct member is not binary compatible with IBM XL C/C++ for AIX 16.1.0 or older'
H79A5A88D17D7: '16 字節對齊的結構成員與 IBM XL C/C++ for AIX 16.1.0 或更早版本的二進位相容性不一致'
# 'alignof expressions are incompatible with C++98'
H5F21C338A420: 'alignof 表達式與 C++98 不相容'
# 'all paths through this function will call itself'
H40E0BDFB048F: '此函數的所有路徑都會調用自身'
# "allocate directive specifies %select{default|'%1'}0 allocator while previously used %select{default|'%3'}2"
HC639234B285B: "allocate指令指定%select{預設|'%1'}0 配置器，而之前使用的是%select{預設|'%3'}2"
# 'allocated size %0 is not a multiple of size %1 of element type %2'
H279696362CDE: '分配的大小 %0 不是元素類型 %2 大小 %1 的倍數'
# "allocated with 'new%select{[]|}0' here"
H1AA44259E5AA: "在此處使用 'new%select{[]|}0' 分配"
# 'allocating an object of abstract class type %0'
H07CDBA71F9A5: '分配抽象類別類型 %0 的物件'
# 'allocation of %select{incomplete|sizeless}0 type %1'
HD40A80B2E772: '分配%select{不完整|無大小}0類型 %1'
# 'allocation performed here was not deallocated%plural{0:|: (along with %0 other memory leak%s0)}0'
H04A2F923450C: '此處的分配未被釋放 %plural{0:|:（連同 %0 其他記憶體泄漏%s0）}0'
# "allocator must be specified in the 'uses_allocators' clause"
H6A6EDC2E2834: "'uses_allocators' 子句必須指定配置器"
# "allocator with the 'thread' trait access has unspecified behavior on '%0' directive"
HDC686C65C1AA: "具有 'thread' 特性的配置器在 '%0' 指令上的存取行為未定義"
# "allocators used in 'uses_allocators' clause cannot appear in other data-sharing or data-mapping attribute clauses"
H3D9F65EE1204: "'uses_allocators' 子句中的配置器不得出現在其他資料共享或資料映射屬性子句中"
# 'allow processing of stripped binaries'
H7C4A1D362E89: '允許處理已剥离的二進位檔'
# 'allow to snippet generator to generate at most that many configs'
H8A45202314E0: '允許片段產生器產生最多該數量的配置'
# "allowable client missing from %0: '%1'"
H1792F22F4481: '%0 缺少允許的客戶端："%1"'
# "allowable clients do not match: '%0' (provided) vs '%1' (found)"
H73C7C1046F8D: '允許的客戶端不匹配："提供的 %0" vs " 找到的 %1"'
# "already inside '#pragma clang arc_cf_code_audited'"
H490BE327E34C: "已經在 '#pragma clang arc_cf_code_audited' 範圍內"
# "already inside '#pragma clang assume_nonnull'"
H59F0A861C85D: "已經在 '#pragma clang assume_nonnull' 範圍內"
# "already inside '#pragma unsafe_buffer_usage'"
H94EE60235FE3: "已經在 '#pragma unsafe_buffer_usage' 範圍內"
# 'also accessed here'
H4EBEB7641C26: '在此處也被存取'
# 'also found'
HAE6F7F952B68: '也找到'
# 'always apply unchecked-ld-st'
HA7AE478F69D8: '始終套用未檢查的載入-儲存指令'
# 'always perform sctc'
H55817EEE47EB: '始終執行 sctc'
# 'always replace exit value whenever possible'
H0EF1BA8B58B0: '始終在可能時替換 exit value'
# 'always use long jumps/nops for Linux kernel static keys'
H61DBDABC6D73: '始終使用 long jumps/nops 來處理 Linux 核心的 static keys'
# 'always_inline function %0 has new za state'
H42D69F5E4613: '函數 %0 的 always_inline 屬性具有新的 za 狀態'
# 'always_inline function %0 has new zt0 state'
HC0C33866F167: '函數 %0 的 always_inline 屬性具有新的 zt0 狀態'
# 'always_inline function %1 and its caller %0 have mismatching %2 attributes'
H623539F9CF4D: '函數 %1 及其呼叫者 %0 的 %2 屬性不匹配'
# 'always_inline function %1 and its caller %0 have mismatching %2 attributes, inlining may change runtime behaviour'
H784367C8E6F8: '函數 %1 及其呼叫者 %0 的 %2 屬性不匹配，內嵌可能改變執行階段行為'
# "always_inline function %1 requires target feature '%2', but would be inlined into function %0 that is compiled without support for '%2'"
H6E58755C709F: "函數 %1 需要目標功能 '%2'，但會被內嵌到未支援 '%2' 的函數 %0 中"
# 'ambiguity is between a regular call to this operator and a call with the argument order reversed'
H5C4216FCB55D: '此操作的常規呼叫與參數順序顛倒的呼叫之間存在歧義'
# 'ambiguous candidate function with reversed arguments'
H1A80B7778D2B: '有歧義的函數候選（參數順序顛倒）'
# 'ambiguous cast from base %0 to derived %1:%2'
H7F294DF4B6DC: '從基類 %0 轉換到派生類 %1 的 cast 過程存在歧義：%2'
# 'ambiguous constructor call when %select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1'
H33854A224B06: '當 %select{複製變數|複製參數|初始化範型參數|傳回物件|初始化語句運算式結果|拋出物件|複製成員子物件|複製陣列元素|分配物件|複製暫存物件|初始化基底子物件|初始化向量元素|捕獲值}0 的類型為 %1 時，構造函數呼叫存在歧義'
# 'ambiguous conversion for %select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2'
H1B069BDA73DD: '%select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 從 %1 轉換為 %2 的型別轉換存在歧義'
# 'ambiguous conversion from derived class %0 to base class %1:%2'
H64259C430314: '從派生類 %0 轉換到基底類 %1 的型別轉換存在歧義：%2'
# 'ambiguous conversion from pointer to member of %select{base|derived}0 class %1 to pointer to member of %select{derived|base}0 class %2:%3'
H3B96453BA992: '將 %select{基底|派生}0 類別 %1 的成員指標轉換為 %select{派生|基底}0 類別 %2 的成員指標時存在歧義：%3'
# 'ambiguous conversion from type %0 to an integral or unscoped enumeration type'
H78D40490F0F2: '將型別 %0 轉換為整數型別或未指定作用域的列舉型別時存在歧義'
# 'ambiguous conversion of array size expression of type %0 to an integral or enumeration type'
H568A4E6CFAC2: '將陣列大小運算式類型 %0 轉換為整數或列舉型別時存在歧義'
# 'ambiguous conversion of delete expression of type %0 to a pointer'
HCF8DE9DD6D85: '將 delete 运算式類型 %0 轉換為指標時存在歧義'
# 'ambiguous deduction for template arguments of %0'
HE14C8899D7D7: '對 %0 的範型參數推論存在歧義'
# 'ambiguous expansion of macro %0'
H401A5AED8233: '宏 %0 的展開存在歧義'
# "ambiguous marker '%0' is defined here"
HF269BA6422ED: "含糊的標記 '%0' 在這裡定義"
# 'ambiguous member function specialization %q0 of %q1'
H6A3405722F76: '成員函數特化 %q0 的 %q1 存在歧義'
# 'ambiguous partial specializations of %0'
HDEE2005B7D3C: '對 %0 的部分特化存在歧義'
# "ambiguous reference to placeholder '_', which is defined multiple times"
HBD26597B24D2: '對佔位符 "_" 的參考存在歧義，因為它被多次定義'
# 'ambiguous use of internal linkage declaration %0 defined in multiple modules'
HE31133550012: '內部連結宣告 %0 在多個模組中被定義，導致使用時產生歧義'
# 'ambiguous vftable component for %0 introduced via covariant thunks; this is an inherent limitation of the ABI'
HB0361B37BEF3: '通過協變Thunk引入的 %0 的vftable組件存在歧義；這是ABI的固有局限性'
# 'amdgpu-arch options'
HA34A9F0AE01E: 'amdgpu-arch 選項'
# 'an array type is not allowed here'
HCA0201F3FA96: '這裡不允许使用陣列類型'
# 'an attribute list cannot appear here'
H49F3FA1B7ED5: '這裡不能出現屬性列表'
# 'an attribute specifier sequence attached to a structured binding declaration is a C++2c extension'
H9EBA62889A30: '附加到結構化綁定宣告的屬性規範序列是C++2c擴展'
# 'an attribute specifier sequence attached to a structured binding declaration is incompatible with C++ standards before C++2c'
H3AB5357520EE: '附加到結構化綁定宣告的屬性規範序列與C++2c之前的所有標準不相容'
# 'an explicit object parameter can only appear as the first parameter of a member function'
HB251EBFE2CF5: '顯式物件參數只能出現在成員函數的第一個參數'
# 'an explicit object parameter can only appear as the first parameter of the %select{function|lambda}0'
H7FA58E3ABF3F: '顯式物件參數只能出現在%select{函數|lambda}0 的第一個參數'
# 'an explicit object parameter cannot appear in a %select{constructor|destructor}0'
H75A07B3C23F5: '顯式物件參數不能出現在%select{構造函數|析構函數}0中'
# 'an explicit object parameter cannot appear in a %select{static|virtual|non-member}0 %select{function|lambda}1'
HF679F4DDA00F: '顯式物件參數不能出現在%select{靜態|虛函數|非成員}0 %select{函數|lambda}1 中'
# "an explicitly-defaulted %select{copy|move}0 assignment operator may not have 'const'%select{, 'constexpr'|}1 or 'volatile' qualifiers"
HC61798127DDC: "明確預設的%select{複製|移動}0指定運算子不可具有 'const'%select{, 'constexpr'|}1 或 'volatile' 限定符"
# 'an explicitly-defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot be variadic'
HE8693CE23671: '明確預設的%select{預設構造函數|複製構造函數|移動構造函數|複製指定運算子|移動指定運算子|析構函數}0不能是可變參'
# 'an explicitly-defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot have default arguments'
H41B0D6AF186A: '明確預設的%select{預設構造函數|複製構造函數|移動構造函數|複製指定運算子|移動指定運算子|析構函數}0不能具有預設參數'
# 'an initializer for a delegating constructor must appear alone'
H5506BF1F155E: '委派構造函數的初始值設定項必須單獨存在'
# 'an inline asm block cannot have an operand which is a bit-field'
HD4AB7ACF49E9: '內嵌組件塊不能具有位段類型的操作數'
# 'an unevaluated string literal cannot be a user-defined literal'
H7294D821E112: '未評估的字串文字不能是使用者定義的文字'
# 'an unevaluated string literal cannot have an encoding prefix'
HFC8ECFF25368: '未評估的字串文字不能有編碼前綴'
# "analyzer constraint manager 'z3' is only available if LLVM was built with -DLLVM_ENABLE_Z3_SOLVER=ON"
H156EC948497C: "分析程式約束管理員 'z3' 只有在LLVM以-DLLVM_ENABLE_Z3_SOLVER=ON編譯時才可用"
# "analyzer-config option '%0' has a key but no value"
H5FB74FAA9043: "分析程式配置選項 '%0' 有鍵但無值"
# "analyzer-config option '%0' should contain only one '='"
HC4A2A9D28ED1: "分析程式配置選項 '%0' 應只包含一個 '='"
# 'angle brackets contain both a %select{type|protocol}0 (%1) and a %select{protocol|type}0 (%2)'
H6C951E1E776A: '尖括號同時包含了一個%select{類型|協定}0 (%1)和一個%select{協定|類型}0 (%2)'
# 'angle-bracketed include <%0> cannot be aliased to double-quoted include "%1"'
H6DC7B4C3CA94: '尖括號包含 <%0> 無法別名為雙引號包含 "%1"'
# 'annotate %select{%1|anonymous %1}0 with an availability attribute to silence this warning'
H1B283AC48C5C: '用可用性屬性註解 %select{%1|匿名 %1}0 以消除此警告'
# "annotating the 'if %select{constexpr|consteval}0' statement here"
HE2CC6E318B60: '在此處註解「if %select{constexpr|consteval}0」陳述式'
# 'annotating the infinite loop here'
H4CC614D1531D: '在此處註解無限迴圈'
# 'annotation-type remark to collect count for'
HF59035A1D641: '用於收集計數的註解類型註解'
# 'anonymous %select{structs|structs and classes}0 must be %select{struct or union|class}0 members'
HFBD532892EC0: '匿名%select{結構|結構與類別}0 必須為 %select{struct或union|class}0 成員'
# 'anonymous %select{structs|unions}0 are a Microsoft extension'
HFF401250AB40: '匿名%select{結構|共用體}0 是Microsoft擴充功能'
# 'anonymous %select{struct|union}0 can only contain non-static data members'
H31B46249C247: '匿名%select{結構|共用體}0 只能包含非靜態資料成員'
# "anonymous %select{struct|union}0 cannot be '%1'"
HF58A2EC09112: '匿名%select{結構|共用體}0 不能是「%1」'
# 'anonymous %select{struct|union}0 cannot contain a %select{private|protected}1 data member'
HA1E08BDB3E65: '匿名%select{結構|共用體}0 不能包含 %select{private|protected}1 資料成員'
# 'anonymous bit-field cannot have a default member initializer'
H71090C776F50: '匿名位段不能有預設成員初始值設定式'
# 'anonymous bit-field cannot have qualifiers'
H6D3AB87CE804: '匿名位段不能有修飾符'
# 'anonymous bit-field has negative width (%0)'
HFC2DC27C32DA: '匿名位段寬度為負數 (%0)'
# 'anonymous bit-field has non-integral type %0'
HCAEF6F6FBF6D: '匿名位段具有非整數型別 %0'
# 'anonymous namespace begins here'
H131F22F8B917: '匿名命名空間在此處開始'
# 'anonymous namespaces cannot be exported'
HD9CECEFAA4C6: '匿名命名空間無法導出'
# 'anonymous non-C-compatible type given name for linkage purposes by %select{typedef|alias}0 declaration after its linkage was computed; add a tag name here to establish linkage prior to definition'
H4E07DEF6B927: '不相容C的匿名類型由 %select{typedef|別名}0宣告在計算其連結性之後命名以供連結用途；請在此添加標記名稱以在定義前建立連結性'
# 'anonymous non-C-compatible type given name for linkage purposes by %select{typedef|alias}0 declaration; add a tag name here'
H5233EEEB5041: '不相容C的匿名類型由 %select{typedef|別名}0宣告命名以供連結用途；請在此添加標記名稱'
# 'anonymous property is not supported'
HBEA1F99304A4: '匿名屬性不受支援'
# 'anonymous structs are a C11 extension'
H1E3F733CCCB4: '匿名結構是C11的擴充功能'
# 'anonymous structs are a GNU extension'
H006E53420443: '匿名結構是GNU的擴充功能'
# 'anonymous types declared in an anonymous %select{struct|union}0 are an extension'
H3F386C85263B: '在匿名 %select{struct|union}0 中宣告的匿名類型是擴充功能'
# 'anonymous union at class scope must not have a storage specifier'
H7518631D05B0: '類別作用域中的匿名共用體不得具有儲存說明符'
# 'anonymous unions are a C11 extension'
HDFE9E6E6FE09: '匿名共用體是C11的擴充功能'
# "anonymous unions at namespace or global scope must be declared 'static'"
H3FE1C37A16FD: "命名空間或全域作用域中的匿名共用體必須宣告為 'static'"
# 'append PID to saved profile file name (default: false)'
HFDE8729E14B7: '將PID附加到儲存的剖析檔檔名（預設：false）'
# "application of '%select{alignof|sizeof}1' to interface %0 is not supported on this architecture and platform"
H7F7758BA5771: "對介面 %0 應用 '%select{alignof|sizeof}1' 在此架構和平台上不受支援"
# 'apply additional analysis to remove stores (experimental)'
H0FDD6748AD67: '套用額外分析以移除存儲（實驗性）'
# 'apply unchecked-ld-st when the target is definitely within range'
H75826487B47E: '當目標絕對在範圍內時套用未檢查的ld-st'
# 'applying attribute %0 to a declaration is deprecated; apply it to the type instead'
H1F568760A093: '將屬性 %0 套用到宣告是已棄用的；請改為套用到類型'
# "architecture '%0' does not support '%1' execution mode"
H341F2DD78603: "架構 '%0' 不支援 '%1' 執行模式"
# "architectures do not match: '%0' (provided) vs '%1' (found)"
H1E0CF63FB0D6: "架構不符：'%0'（提供的）與 '%1'（找到的）"
# 'architectures of the coverage mapping binaries'
HC4DF8B556ACB: '涵蓋映射二進位檔的架構'
# 'argument %0 is not an unqualified class type'
H5DB23C0A38DF: '引數 %0 不是未限定的類別類型'
# 'argument %0 must be constant integer 1 or -1'
H4812A4DC04E0: '參數 %0 必須是常數整數 1 或 -1'
# 'argument %0 of type %1 with mismatched bound'
HDE368B7DDAF1: '參數 %0（類型 %1）的邊界不匹配'
# 'argument %0 to %1 must be a 2-bit unsigned literal (i.e. 0, 1, 2 or 3)'
HD2DEDD810BB8: '傳遞給 %1 的參數 %0 必須是 2 位無符號字面量（即 0、1、2 或 3）'
# "argument %0 to 'preferred_name' attribute is not a typedef for a specialization of %1"
H873B3444BA19: "'preferred_name' 屬性的參數 %0 不是 %1 的特化類型的 typedef"
# 'argument %0 value should represent a contiguous bit field'
H004B84FF9E91: '參數 %0 的值應表示連續的位段'
# "argument '%0' is deprecated%select{|, use '%2' instead}1"
H549CE16A2419: "參數 '%0' 已棄用 %select{|，請改用 '%2'}1"
# "argument '%0' is deprecated, %1"
HFF8BB35E32E8: "參數 '%0' 已棄用，%1"
# "argument '%0' requires profile-guided optimization information"
HE99C51820EC7: "參數 '%0' 需要配置文件引導型優化資訊"
# "argument '%select{X|Y|Z}0' to numthreads attribute cannot exceed %1"
H50D13BA82E10: "numthreads 屬性中 '%select{X|Y|Z}0' 參數不可超過 %1"
# "argument '-Ofast' is deprecated; use '-O3 -ffast-math -fstack-arrays' for the same behavior, or '-O3 -fstack-arrays' to enable only conforming optimizations"
HBBD3AEA705D1: "argument '-Ofast' is deprecated; use '-O3 -ffast-math -fstack-arrays' for the same behavior, or '-O3 -fstack-arrays' to enable only conforming optimizations"
# "argument '-Ofast' is deprecated; use '-O3 -ffast-math' for the same behavior, or '-O3' to enable only conforming optimizations"
H9474F0404E53: "argument '-Ofast' is deprecated; use '-O3 -ffast-math' for the same behavior, or '-O3' to enable only conforming optimizations"
# "argument may not have 'void' type"
HC935448BE70B: "參數不得具有 'void' 類型"
# 'argument must be a function'
H4B920E91F120: '參數必須是函數'
# 'argument must be a string literal%select{| of char type}0'
HE9E2C9450B76: '參數必須是字串文字 %select{|的 char 類型}0'
# "argument not in expected state; expected '%0', observed '%1'"
H081944E631B6: "參數未處於期望狀態；期望 '%0'，但觀察到 '%1'"
# "argument of OpenMP clause '%0' must reference the same object in all threads"
HD18A730DC43E: "OpenMP 子句 '%0' 的參數必須在所有執行緒中引用同一物件"
# 'argument of a linear clause should be of integral or pointer type, not %0'
HDE23CDEBD40A: 'linear 子句的參數型別應為整數或指標，而非 %0'
# 'argument of a reduction clause of a %0 construct must not appear in a firstprivate clause on a task construct'
HE3DB6952581D: '%0 結構的 reduction 子句參數不得出現在 task 結構的 firstprivate 子句中'
# 'argument of aligned clause should be array%select{ or pointer|, pointer, reference to array or reference to pointer}1, not %0'
H3A22487A8E2A: 'aligned 子句的參數應為陣列%select{或指標|、指標、指向陣列或指向指標的參考}1，而非 %0'
# 'argument required after attribute'
HE013B38B3C7C: '屬性後需指定參數'
# 'argument sensitivity is %select{unspecified|private|public|sensitive}0, but it should be %select{unspecified|private|public|sensitive}1'
H086D890B37E5: '參數的敏感性是 %select{unspecified|private|public|sensitive}0，但應為 %select{unspecified|private|public|sensitive}1'
# 'argument should be a multiple of %0'
H17E1DE63FD3F: '參數應為 %0 的倍數'
# 'argument should be a power of 2'
H41CDA1F42637: '參數應為 2 的冪次方'
# 'argument should be an 8-bit value shifted by a multiple of 8 bits'
H3C662F06BF97: '參數應為 8 位元值向右移位 8 位的倍數'
# 'argument should be an 8-bit value shifted by a multiple of 8 bits, or in the form 0x??FF'
H188AFDB4C91E: '參數應為 8 位元值向右移位 8 位的倍數，或是 0x??FF 的形式'
# 'argument should be the value 0, 90, 180 or 270'
H8AAE066502E7: '參數應為 0、90、180 或 270 之一'
# 'argument should be the value 90 or 270'
HE33BB0F80B1B: '參數應為 90 或 270'
# 'argument to #pragma section is not valid for this target: %0'
HC2C201A8E9D6: '#pragma section 的參數對此目標無效：%0'
# 'argument to %0 must be a constant integer'
H66325C1A3398: '對 %0 的參數必須為常數整數'
# "argument to %select{'code_seg'|'section'}1 attribute is not valid for this target: %0"
H35898B1EF5C2: "對 %select{'code_seg'|'section'}1 屬性參數對此目標無效：%0"
# "argument to '#pragma unroll' should not be in parentheses in CUDA C/C++"
HBE77A0717D85: '在 CUDA C/C++ 中，#pragma unroll 的參數不應使用括號'
# "argument to '%0' clause must be a %select{non-negative|strictly positive}1 integer value"
H93740956E9C9: "對 '%0' 子句的參數必須為 %select{非負數|嚴格正數}1 整數值"
# "argument to '%0' is missing (expected %1 value%s1)"
HEA17C0D34C2C: "對 '%0' 的參數缺失（期望 %1 值%s1）"
# "argument to 'gang' clause dimension must be %select{a constant expression|1, 2, or 3: evaluated to %1}0"
H970EFD35B5B1: "對 'gang' 子句維度的參數必須為 %select{常數運算式|1、2 或 3：評估為 %1}0"
# "argument to 'operator<=>' %select{cannot be narrowed from type %1 to %2|evaluates to %1, which cannot be narrowed to type %2}0"
HAE154D16E74A: "對 'operator<=>' 的參數 %select{無法從類型 %1 縮窄至 %2|評估為 %1，無法縮窄至類型 %2}0"
# "argument to 'sizeof' in %0 call is the same pointer type %1 as the %select{destination|source}2; expected %3 or an explicit length"
H35BB4F2B1E83: "在 %0 調用中的 'sizeof' 參數與%select{目標|來源}2的指標類型 %1 相同；期望 %3 或明確的長度"
# 'argument to __builtin_longjmp must be a constant 1'
HE5F0C7B028D7: '__builtin_longjmp 的參數必須為常數 1'
# 'argument to __builtin_verbose_trap must %select{be a pointer to a constant string|not contain $}0'
HADE59279CC5F: '__builtin_verbose_trap 的參數必須 %select{指向一個常數字串|不包含 $}0'
# "argument to atomic builtin of type '_BitInt' is not supported"
HB64B7DD3183B: "型別 '_BitInt' 的原子內建函數不被支援"
# 'argument to ptrauth_sign_constant must refer to a global variable or function'
HC3F35A99F4A4: 'ptrauth_sign_constant 的引數必須指向全域變數或函數'
# "argument type %0 doesn't match specified %1 type tag %select{that requires %3|}2"
H3BF4CB740E62: '引數型別 %0 與指定的 %1 類型標籤 %select{需要 %3|}2 不相符'
# 'argument type %0 is incomplete'
HAB2CACB541C5: '引數型別 %0 是不完整的型別'
# 'argument type %0 is not a real floating point type'
H00F62D550C19: '引數型別 %0 不是真正的浮點型別'
# "argument unused during compilation: '%0'"
HA1050D6985F0: "編譯期間未使用的引數：'%0'"
# 'argument value %0 is outside the valid range [%1, %2]'
HB96DE207738E: '引數值 %0 當前超出有效範圍 [%1, %2]'
# 'argument value %0 will result in undefined behaviour'
H274A3E69FEAC: '引數值 %0 將導致未定行為'
# 'arguments are of different types%diff{ ($ vs $)|}0,1'
HE1B214C1584C: '引數型別不同%diff{（$ 與 $）|}1,0'
# "arguments of '#pragma omp %0' cannot be of reference type %1"
HF10A8B7C87FB: "'#pragma omp %0' 的引數不能是引用型別 %1"
# "arguments of '#pragma omp %0' must have %select{global storage|static storage duration}1"
H6F3268D97079: "'#pragma omp %0' 的引數必須具有 %select{全域儲存|靜態儲存期間}1"
# "arguments of OpenMP clause '%0' for 'min' or 'max' must be of %select{scalar|arithmetic}1 type"
HCCCABB9B57BC: "OpenMP 子句 '%0' 的 'min' 或 'max' 參數必須為 %select{純量|算術}1 型別"
# "arguments of OpenMP clause '%0' in '#pragma omp %2' directive cannot be of variably-modified type %1"
HCB3B0D762A59: "在 '#pragma omp %2' 指令中的 OpenMP 子句 '%0' 的引數不能為可變修飾型別 %1"
# "arguments of OpenMP clause '%0' with bitwise operators cannot be of floating type"
H7CE92A7D3184: "使用位元運算子的 OpenMP 子句 '%0' 的參數不能為浮點型別"
# 'arguments to __annotation must be wide string constants'
H123CD58AB412: '__annotation 的引數必須為寬字元字串常數'
# "arithmetic involving unrelated objects '%0' and '%1' has unspecified value"
H620CC2CD5C97: "對無關物件 '%0' 和 '%1' 進行算術運算的結果未定"
# 'arithmetic on a null pointer treated as a cast from integer to pointer is a GNU extension'
HBFE8701B60FF: '將空指標進行算術運算視為整數轉指標的延伸是 GNU 延伸功能'
# 'arithmetic on a pointer to %select{an incomplete|sizeless}0 type %1'
H81F0120B9A69: '對 %select{不完整型別|無大小型別}0 %1 的指標進行算術運算是未定行為'
# 'arithmetic on addresses of potentially overlapping literals has unspecified value'
H84236342B8A2: '對可能重疊字面值的位址進行算術運算的結果未定'
# 'arithmetic on pointer to interface %0, which is not a constant size for this architecture and platform'
H9C9B045DAD4E: '在無法為此架構和平台提供固定大小的介面 %0 的指標進行算術運算'
# 'arithmetic on%select{ a|}0 pointer%select{|s}0 to void'
H58D09A5B5E7F: '在%select{ a|}0 指標 %select{|s}0 到void類型進行算術運算'
# 'arithmetic on%select{ a|}0 pointer%select{|s}0 to void is a GNU extension'
HB4BACD25A732: '在%select{ a|}0 指標 %select{|s}0 到void類型進行算術運算是GNU擴展'
# 'arithmetic on%select{ a|}0 pointer%select{|s}0 to%select{ the|}2 function type%select{|s}2 %1%select{| and %3}2'
H1FD9A476B84E: '在%select{ a|}0 指標 %select{|s}0 到%select{ the|}2 函數類型 %select{|s}2 %1%select{|和 %3}2 進行算術運算'
# 'arithmetic on%select{ a|}0 pointer%select{|s}0 to%select{ the|}2 function type%select{|s}2 %1%select{| and %3}2 is a GNU extension'
H94DE585BA344: '在%select{ a|}0 指標 %select{|s}0 到%select{ the|}2 函數類型 %select{|s}2 %1%select{|和 %3}2 進行算術運算是GNU擴展'
# 'array %0 declared here'
HD94D934376D0: '在此處宣告的陣列 %0'
# "array 'new' cannot have initialization arguments"
H5708CAC5AB7B: "'new' 陣列不能有初始化參數"
# 'array argument is too small; %select{contains %0 elements|is of size %0}2, callee requires at least %1'
H8A66ED6F9EE3: '陣列參數過小；%select{包含 %0 個元素|大小為 %0}2，被調用方至少需要 %1'
# 'array backing %select{initializer list subobject of the allocated object|the allocated initializer list}0 will be destroyed at the end of the full-expression'
H7FC8ADC3508D: '分配物件%select{初始化清單子物件|的初始化清單}0的陣列支撐結構將在完整表達式結束時被銷毀'
# 'array bound cannot be deduced from a default member initializer'
H6E170EF5C23C: '無法從預設成員初始化式推導陣列邊界'
# 'array designator cannot initialize non-array type %0'
H0BB48B48E929: '陣列指定項不能初始化非陣列類型 %0'
# 'array designator index (%0) exceeds array bounds (%1)'
HF8952A3F237D: '陣列指定項索引(%0)超出陣列邊界(%1)'
# 'array designator range [%0, %1] is empty'
HFAC24EA6FC3D: '陣列指定項範圍[%0, %1]為空'
# "array designator value '%0' is negative"
H02A61A71BE5A: "陣列指定項值 '%0' 為負數"
# 'array designators are a C99 extension'
H09604E6E8FF6: '陣列指定項是C99擴展'
# 'array has %select{incomplete|sizeless}0 element type %1'
H513D9739D1E9: '陣列元素類型 %1%select{不完整|無大小}0'
# 'array index %0 is before the beginning of the array'
HE66AD6A3EEDD: '陣列索引 %0 位於陣列起始位置之前'
# 'array index %0 is past the end of the array (that has type %1%select{|, cast to %3}2)'
HB32CD52AC2F7: '陣列索引 %0 超出陣列末端（該陣列類型為 %1%select{|轉型為 %3}2）'
# 'array index %0 refers past the last possible element for an array in %1-bit address space containing %2-bit (%3-byte) elements (max possible %4 element%s5)'
H8C89DC3E13D9: '陣列索引 %0 指向超過 %1-bit 位址空間中包含 %2-bit (%3-byte) 元素 (最大可能 %4 元素%s5) 的陣列末尾元素'
# 'array initializer must be an initializer list%select{| or string literal| or wide string literal}0'
H4C9486DBC430: '陣列初始值設定必須是初始化列表 %select{|或字串文字|或寬字元字串文字}0'
# 'array is too large (%0 elements)'
H898DDC47DE13: '陣列過大 (%0 個元素)'
# 'array of %0 type is invalid in OpenCL'
H394630398D52: 'OpenCL 中不支援 %0 類型的陣列'
# 'array of abstract class type %0'
HD205577BDFE7: '%0 抽象類別型態的陣列無效'
# 'array of interface %0 is invalid (probably should be an array of pointers)'
H26CB6BC11BB2: '介面 %0 的陣列無效（可能應使用指標的陣列）'
# 'array parameter is missing a nullability type specifier (_Nonnull, _Nullable, or _Null_unspecified)'
HF62708756DE6: '陣列參數缺少空值型別指定項（_Nonnull、_Nullable 或 _Null_unspecified）'
# 'array section %select{lower bound|length}0 is not an integer'
H54C64A3BE980: '陣列區段%select{下界|長度}0 非整數'
# "array section %select{lower bound|length}0 is of type 'char'"
H553F40D88798: '陣列區段%select{下界|長度}0 的型別為「char」'
# 'array section does not specify contiguous storage'
HD0B03CAA79AA: '陣列區段未指定連續記憶體儲存'
# 'array section does not specify length for outermost dimension'
HDEBFF7152057: '最外層維度的陣列區段未指定長度'
# 'array section must be a subset of the original array'
H9DAB88506A15: '陣列區段必須是原始陣列的子集'
# 'array shaping dimension is evaluated to a non-positive value %0'
H6C186AF92991: '陣列形狀維度計算為非正數值 %0'
# 'array shaping operation dimension is not an integer'
H521C171EF9F9: '陣列形狀運算的維度非整數'
# 'array size expression has incomplete class type %0'
H48253C816CFD: '陣列大小運算式具有不完整類別類型 %0'
# 'array size expression must have integral or %select{|unscoped }0enumeration type, not %1'
H46181D36F61E: '陣列大小運算式必須為整數或 %select{|未指定作用域 }0枚舉型別，而非 %1'
# 'array size expression of type %0 requires explicit conversion to type %1'
H08A74EE986A3: '陣列大小運算式型別 %0 需明確轉換為 %1 型別'
# 'array size is negative'
H2357C6CBC81F: '陣列大小為負數'
# 'array size must be specified in new expression with no initializer'
HC377DBA39626: '在沒有初始值的new運算式中必須指定陣列大小'
# 'array subscript is not an integer'
HCA57C5D6E89C: '陣列下標不是整數'
# "array subscript is of type 'char'"
HF94CCD2B1ECE: "陣列下標為類型 'char'"
# 'array type %0 is not assignable'
H89C95FEC605F: '陣列類型 %0 不可指派'
# 'array types cannot be value-initialized'
HA2673E710254: '陣列類型無法進行值初始化'
# 'array-to-pointer decay of array member without known bound is not supported'
HAB3F18D32404: '無已知邊界的陣列成員的陣列指標衰減未被支援'
# "as specified in %select{'collapse'|'ordered'|'collapse' and 'ordered'}0 clause%select{||s}0"
H1ABDD2AD30EB: '如在 %select{Collapse|Ordered|Collapse 和 Ordered}0 子句 %select{||s}0 中指定'
# 'ascending'
HF393CC9965C7: '遞增'
# 'asm constraint has an unexpected number of alternatives: %0 vs %1'
HF38699D505AA: 'asm 限制項的替代數量意外：%0 vs %1'
# 'asm operand has incomplete type %0'
HAA2952BA222F: '組合語言參數具有不完整類型 %0'
# 'asm operand name "%0" first referenced here'
H8FB938C946B0: '組合語言標籤「%0」首次在此處引用'
# 'asm-specifier for input or output variable conflicts with asm clobber list'
H99E324C19D00: '輸入或輸出變數的組合語言指定符與組合語言破壞清單衝突'
# 'assigning %select{array literal|dictionary literal|numeric literal|boxed expression|<should not happen>|block literal}0 to a weak %select{property|variable}1; object will be released after assignment'
H8FFA1E619C25: '將%select{陣列字面量|字典字面量|數值字面量|包裝運算式|<不應發生的情況>|區塊字面量}0 賦值給弱%select{屬性|變數}1；物件將於指派後被釋放'
# 'assigning %select{field|instance variable}0 to itself'
H9230F521B121: '將%select{欄位|執行個體變數}0 賦值給自身'
# 'assigning retained object to %select{weak|unsafe_unretained}0 %select{property|variable}1; object will be released after assignment'
H250CD1E6F903: '將已保留物件賦值給%select{弱|unsafe_unretained}0 %select{屬性|變數}1；物件將於指派後被釋放'
# 'assigning retained object to unsafe property; object will be released after assignment'
H8135CA913359: '將已保留物件賦值給非保留屬性；物件將於指派後被釋放'
# "assigning to 'readonly' return result of an Objective-C message not allowed"
H87457323E0B9: '不允許對Objective-C訊息的「readonly」傳回結果進行指派'
# 'assigning value of signed enum type %1 to unsigned bit-field %0; negative enumerators of enum %1 will be converted to positive values'
H03B45829D6A4: '將帶符號列舉類型 %1 賦值給無符號位元區段 %0；列舉 %1 的負值枚舉常數將轉換為正數'
# 'assignment of a weak-unavailable object to a __weak object'
H270A68B29DDC: '將弱不可用物件指派給__weak物件'
# "assignment to Objective-C's isa is deprecated in favor of object_setClass()"
H4989286009CB: 'Objective-C的isa指派已棄用，請改用object_setClass()'
# 'assignment to cast is illegal, lvalue casts are not supported'
HADC1B6BE18D9: '對 cast 的賦值是非法的，不支援 lvalue casts'
# 'assignment would change active union member during the initialization of a different member of the same union'
HE419D89C08F2: '在共用體的其他成員初始化期間，將共用體的另一成員重新賦值'
# 'assume the ABI is never violated'
H2875C70D4F37: '假設未違反 ABI'
# 'assumption evaluated to false'
H4B3BD75DFF9D: '假設條件評估為 false'
# 'assumption is ignored because it contains (potential) side-effects'
H2E58C9356572: '因包含（潛在）副作用而忽略假設條件'
# 'at least one argument of MTE builtin function must be a pointer (%0, %1 invalid)'
H9293CC0B9621: 'MTE 內建函數至少需要一個指標參數（%0、%1 無效）'
# 'at most one defaultmap clause for each variable-category can appear on the directive'
H95E39CFC8758: '每類變數類別的 defaultmap 子句最多只能出現一次'
# "at most one overload for a given name may lack the 'overloadable' attribute"
H9206D4731FC1: '同一名称的重載函數最多只能有一個未標註 "overloadable" 屬性的重載'
# "at most three expressions are allowed in '%0' clause in 'target teams ompx_bare' construct"
HC1194A65DC15: "'target teams ompx_bare' 建構式中的 '%0' 子句最多允許三個運算式"
# 'atomic %select{load|store}0 requires runtime support that is not available for this target'
HD7BAEC48A8AF: '原子 %select{load|store}0 需要此目標不支援的執行階段支援'
# "atomic by default property %0 has a user defined %select{getter|setter}1 (property should be marked 'atomic' if this is intended)"
H5A9A236EC6A5: '預設原子屬性 %0 有自定義 %select{getter|setter}1（若有意圖請標註 "atomic" 屬性）'
# "atomic constraint must be of type 'bool' (found %0)"
H69DAA34C1AB6: '原子限制項必須是 "bool" 類型（找到 %0）'
# 'atomic memory operand must have a power-of-two size'
HB13C6FA40316: '原子記憶體運算式必須具有 2 的冪次方大小'
# 'atomic property of reference type %0 cannot have non-trivial assignment operator'
HFC34A950A835: '引用類型 %0 的原子屬性不能有非平凡的賦值運算子'
# "atomic types are not supported in '%0'"
H97C63071B5D3: '不支援在 "%0" 中使用原子類型'
# 'atomic variable can be %select{assigned|initialized}0 to a variable only in global address space'
HCB0951EAACB6: '原子變數只能在全域位址空間中 %select{賦值|初始化}0 到變數'
# 'attempt to call %0 on non-heap %select{object %2|object: block expression|object: lambda-to-function-pointer conversion}1'
H6E5B5738458E: '嘗試在非堆疊%select{物件 %2|物件：區塊運算式|物件：lambda到函數指標轉換}1上呼叫 %0'
# 'attempt to specialize declaration here'
HF06CAF52936D: '嘗試在此處專門化宣告'
# 'attempt to use a deleted function%select{|: %1}0'
HA9C947D267C4: '嘗試使用已刪除的函數 %select{|: %1}0'
# 'attempt to use a poisoned identifier'
H3643F70789A4: '嘗試使用被毒化的識別符'
# 'attempting to use the forward class %0 as superclass of %1'
H994AA508EDDF: '嘗試將前向類別 %0 用作超類別 %1'
# 'attribute %0 after definition is ignored'
H5CD4712D502F: '定義後的屬性 %0 將被忽略'
# 'attribute %0 can be used only on HLSL intangible type %1'
HF8261011AFDE: '屬性 %0 只能用於 HLSL 不可觸類型 %1'
# 'attribute %0 can only be applied to @protocol definitions, not forward declarations'
H308DB757AA67: '屬性 %0 只能套用於 @protocol 定義，而非前向宣告'
# 'attribute %0 can only be applied to an OpenCL kernel function'
HCB6BF3FC512F: '屬性 %0 只能套用到 OpenCL 核心函數'
# 'attribute %0 cannot appear more than once on a declaration'
HB715D0AA3201: '宣告上無法重複出現屬性 %0'
# 'attribute %0 cannot be applied to %1'
H3AE597187391: '無法將屬性 %0 套用到 %1'
# 'attribute %0 cannot be applied to %select{functions|Objective-C method}1 without return value'
H1C83B6EE306A: '屬性 %0 無法套用到無傳回值的 %select{函數|Objective-C 方法}1'
# "attribute %0 cannot be applied to a 'void' parameter"
H6A5920736ACF: "無法將屬性 %0 套用到 'void' 型別參數"
# 'attribute %0 cannot be used as an attribute pack'
HE6BA361D74BF: '屬性 %0 無法作為屬性包裝使用'
# 'attribute %0 cannot have an argument list'
HA4D8BF32DC8E: '屬性 %0 不得帶有引數清單'
# 'attribute %0 does not support argument pack expansion'
H09CC6A21F4B4: '屬性 %0 不支援引數包裝展開'
# "attribute %0 has no effect when annotating an 'if %select{constexpr|consteval}1' statement"
H409C4714E4F9: "當標註一個 'if %select{constexpr|consteval}1' 語句時，屬性 %0 無效"
# 'attribute %0 has no effect when annotating an infinite loop'
HB06D2414EAF4: '標註無限迴圈時，屬性 %0 無效'
# 'attribute %0 ignored, because it cannot be applied to a type'
H5708F2759194: '屬性 %0 被忽略，因無法套用到類型上'
# 'attribute %0 ignored, because it cannot be applied to omitted return type'
H547B25BBFFDA: '屬性 %0 被忽略，因無法套用到省略的傳回類型'
# 'attribute %0 ignored, because it is not attached to a declaration'
H14902C950EC7: '屬性 %0 被忽略，因為它未附加到宣告'
# 'attribute %0 is already applied'
HC7BD790A19A9: '屬性 %0 已經套用'
# 'attribute %0 is already applied with different arguments'
H11C03822A58E: '屬性 %0 已經以不同參數套用'
# 'attribute %0 is ignored, place it after "%select{class|struct|interface|union|enum|enum class|enum struct}1" to apply attribute to type declaration'
HB89779883F0D: '屬性 %0 被忽略，請將其放置在「%select{class|struct|interface|union|enum|enum class|enum struct}1」之後以套用屬性到類型宣告'
# "attribute %0 is not supported by '#pragma clang attribute'"
H38205446BD5C: "屬性 %0 不受 '#pragma clang attribute' 支援"
# 'attribute %0 is supported in the OpenCL version %1%select{| onwards}2'
H50454061E7F3: '屬性 %0 支援於 OpenCL 版本 %1%select{| 起}2'
# "attribute %0 is unsupported in '%1' shaders, requires %select{|one of the following: }2%3"
HFE781A72AFCA: "屬性 %0 在 '%1' 著色器中不受支援，需要 %select{|以下其中一個: }2%3"
# 'attribute %0 only applies to %1'
HC6318570485F: '屬性 %0 僅套用於 %1'
# "attribute %0 only applies to a field or parameter of type '%1'"
H552F45F43B85: "屬性 %0 僅套用於類型 '%1' 的成員變數或參數"
# 'attribute %0 requires shader model %1 or greater'
H06BEB9F659D8: '屬性 %0 需要著色器模型 %1 或更新版本'
# 'attribute %0 with %1 arguments requires shader model %2 or greater'
H51393292A866: '帶有 %1 個參數的屬性 %0 需要著色器模型 %2 或更新版本'
# 'attribute %q0 cannot be applied to a deleted function'
HCB37B8A40CF9: '屬性 %q0 無法套用至已刪除的函式'
# 'attribute %q0 cannot be applied to member of %q1 class'
HFBD033ADD565: '屬性 %q0 無法套用至 %q1 類別的成員'
# "attribute '%0' on function does not match previous declaration"
HF59632E17268: "函式的屬性 '%0' 與先前宣告不符"
# "attribute '%0' on overriding function does not match base declaration"
H19F6EB5D2707: "覆寫函式的屬性 '%0' 與基底宣告不符"
# "attribute '%0' should not be added via type conversion"
HD3474317FB81: "屬性 '%0' 不應透過類型轉換新增"
# "attribute '%select{|target|cpu_specific|cpu_dispatch|target_clones|target_version}0' multiversioned functions do not yet support %select{function templates|virtual functions|deduced return types|constructors|destructors|deleted functions|defaulted functions|constexpr functions|consteval function|lambdas}1"
HF5E6CA9178D8: "屬性 '%select{|target|cpu_specific|cpu_dispatch|target_clones|target_version}0' 的多版本化函式目前不支援 %select{函式範型|虛函式|推論傳回類型|建構子|解構子|已刪除函式|預設函式|constexpr 函式|consteval 函式|lambda}1"
# "attribute '%select{|target|cpu_specific|cpu_dispatch|target_clones|target_version}0' multiversioning cannot be combined with attribute %1"
HA264FE94729F: "屬性 '%select{|target|cpu_specific|cpu_dispatch|target_clones|target_version}0' 的多版本化無法與屬性 %1 併用"
# "attribute 'msvc::constexpr' cannot be applied to the %select{constexpr|consteval|virtual}0 function %1"
HAC0996F3C628: "屬性 'msvc::constexpr' 無法套用至 %select{constexpr|consteval|虛}0 函式 %1"
# "attribute 'readonly' of property %0 restricts attribute 'readwrite' of property inherited from %1"
HEB32CB97F1A3: "屬性 'readonly' 的屬性 %0 限制了繼承自 %1 的 'readwrite' 屬性"
# 'attribute declaration must precede definition'
H83850ED606E9: '屬性宣告必須位於定義之前'
# 'attribute is here'
HD14867328E83: '屬性在此處'
# "attribute is ignored on this statement as it only applies to functions; use '%0' on statements"
H8C71964DA95C: "此語句的屬性被忽略，因其僅適用於函數；語句上請使用 '%0'"
# 'attribute only applies to output parameters'
H05F9B2ABFA42: '屬性僅適用於輸出參數'
# 'attribute with scope specifier cannot follow default scope specifier'
HFC36C268C353: '帶有作用域指定符的屬性不能跟隨預設作用域指定符'
# 'attributes \'%0("%2")\' and \'%1("%2")\' are mutually exclusive'
H56F1BA7862B2: "屬性 '%0('%2')' 和 '%1('%2')' 互斥"
# 'attributes cannot be specified on a nested namespace definition'
H4264DC0CBC46: '無法在嵌套的命名空間定義上指定屬性'
# 'attributes cannot be specified on namespace alias'
H4F2E4C4430E8: '無法在命名空間別名上指定屬性'
# 'attributes on %select{a namespace|an enumerator}0 declaration are a C++17 extension'
H034995816099: '在%select{命名空間|枚舉常數}0宣告上使用屬性是C++17的擴充功能'
# 'attributes on %select{a namespace|an enumerator}0 declaration are incompatible with C++ standards before C++17'
H8BB41AEA1EC6: '在%select{命名空間|枚舉常數}0宣告上使用屬性與C++17之前的標準不相容'
# 'authenticating a null pointer will almost certainly trap'
HB0AE642AC2E4: '驗證空指標幾乎肯定會觸發陷阱'
# 'auto property synthesis is synthesizing property not explicitly synthesized'
H0B109C7F8F74: '自動屬性合成正在合成未明確宣告的屬性'
# 'auto property synthesis will not synthesize property %0 because it cannot share an ivar with another synthesized property'
HB5E0DEB40CE6: '自動屬性合成不會合成屬性 %0，因其無法與其他合成屬性共用實例變數'
# "auto property synthesis will not synthesize property %0 because it is 'readwrite' but it will be synthesized 'readonly' via another property"
H2BD61AD864B9: '自動屬性合成不會合成屬性 %0，因其標記為 "readwrite"，但將透過另一屬性以 "readonly" 進行合成'
# 'auto property synthesis will not synthesize property %0 declared in protocol %1'
HA0C341D1A812: '自動屬性合成不會合成在協定 %1 中宣告的屬性 %0'
# 'auto property synthesis will not synthesize property %0; it will be implemented by its superclass, use @dynamic to acknowledge intention'
H0457D53851AF: '自動屬性合成不會合成屬性 %0，因其將由超類實作，請使用 @dynamic 以明確表示意圖'
# 'automatic variable qualified with an%select{| invalid}0 address space'
H122ACAE25198: '帶有 %select{|無效}0地址空間的自動變數'
# 'autosynthesized property %0 will use %select{|synthesized}1 instance variable %2, not existing instance variable %3'
H4495EA68D322: '自動合成的屬性 %0 將使用 %select{|合成的}1實例變數 %2，而非現有的實例變數 %3'
# 'availability does not match previous declaration'
H583F2A1BC062: '可用性宣告與先前宣告不一致'
# 'available multilibs are:%0'
H0F052B7170DD: '可用的多庫配置為:%0'
# "backend data layout '%0' does not match expected target description '%1'"
H82DEBC38BED7: "後端資料佈局 '%0' 與期望的目標描述 '%1' 不相符"
# 'backslash and newline separated by space'
HD4F9A252F950: '反斜線和換行符被空白分隔'
# 'bad receiver type %0'
HE40F679E3605: '無效的接收者類型 %0'
# "base %0 is marked '%select{final|sealed}1'"
HE6BCB4D05CEC: "基類 %0 被標記為 '%select{final|sealed}1'"
# 'base class %0 has %select{private|protected}1 destructor'
HEB04CB913679: '基類 %0 具有%select{私有|受保護}1 析構函數'
# 'base class %0 has a flexible array member'
HD71C5E7037F5: '基類 %0 具有可伸展陣列成員'
# 'base class %0 is uninitialized when used here to access %q1'
H6E433F27AF21: '此處用作存取 %q1 時，基類 %0 未初始化'
# 'base class %0 specified here'
HE35763C73750: '於此處指定的基類 %0'
# 'base class %0 specified more than once as a direct base class'
HC14516852948: '基類 %0 被重複指定為直接基類'
# 'base class has incomplete type'
H4B76670DCEA2: '基類具有不完整類型'
# 'base class initializer %0 names both a direct base class and an inherited virtual base class'
HAE21C251743B: '基類初始化器 %0 同時指定直接基類和繼承的虛基類'
# 'base of member reference is a function; perhaps you meant to call it%select{| with no arguments}0?'
H224FA72A413F: '成員引用的基類是函數；可能您想呼叫它 %select{|不帶引數}0？'
# 'base specifier must name a class'
HBDBF7667EBAE: '基類規格必須指定一個類別'
# 'basic register allocator'
HFEA9765B5A50: '基本寄存器分配器'
# 'basic statistics'
HAA78894D50F2: '基本統計資訊'
# 'because %select{base class of |field of |}0type %1 has a user-provided %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}2'
HA75BA84DF85B: '因為 %select{類別的基類 |類別的成員 |}0 型別 %1 具有使用者提供的 %select{預設建構函數|複製建構函數|移動建構函數|複製賦值運算子|移動賦值運算子|析構函數}2'
# 'because %select{base class of |field of |}0type %1 has no default constructor'
HC07ABEF26326: '因為 %select{類別的基類 |類別的成員 |}0 型別 %1 沒有預設建構函數'
# 'because field %0 has an initializer'
H7DB53EF856A5: '因為成員 %0 具有初始值設定式'
# 'because it has a default argument'
H4C6DC4DA1E45: '因為它具有預設引數'
# 'because it is a variadic function'
H640DA969741B: '因為它是多型函數'
# 'because its parameter is %diff{of type $, not $|of the wrong type}2,3'
H5CB13170AE2B: '因其參數%diff{的類型為$，而不是$|類型錯誤}2,3'
# 'because no %select{<<ERROR>>|constructor|constructor|assignment operator|assignment operator|<<ERROR>>}2 can be used to %select{<<ERROR>>|copy|move|copy|move|<<ERROR>>}2 %select{base class|field|an object}0 of type %3'
HD9E44C137738: '因為沒有 %select{<<ERROR>>|建構函數|建構函數|賦值運算子|賦值運算子|<<ERROR>>}2 可用於 %select{<<ERROR>>|複製|移轉|複製|移轉|<<ERROR>>}2 %select{基類|成員變數|物件}0 類型 %3'
# 'because of ambiguity in conversion %diff{of $ to $|between types}0,1'
HB064B974A1C3: '因轉換%diff{從 $ 至 $ 的不相容|兩種類型間的不相容}0,1 產生歧義'
# 'because substituted constraint expression is ill-formed%0'
H708967A94C80: '因取代後的約束運算式存在語法錯誤 %0'
# 'because the function selected to %select{construct|copy|move|copy|move|destroy}2 %select{base class|field}0 of type %1 is not trivial'
H1F152D129667: '因%select{建構|複製|移動|複製|移動|銷毀}2 %select{基類|成員}0 類型 %1 的函式非 trivial'
# 'because type %0 has a member with %select{no|no|__strong|__weak|__autoreleasing}1 ownership'
HE992EBFC669B: '因類型 %0 包含%select{無|無|__strong|__weak|__autoreleasing}1 權限的成員'
# 'because type %0 has a virtual %select{member function|base class}1'
H45351AACBEF7: '因類型 %0 包含虛%select{成員函數|基類}1'
# "befriending %1 without '%select{struct|interface|union|class|enum}0' keyword is incompatible with C++98"
HDE958FBB8995: "未使用 '%select{struct|interface|union|class|enum}0' 關鍵字宣告友元 %1，與 C++98 不相容"
# 'binary RIFF format'
H555066C6C2A6: '二進位 RIFF 格式'
# 'binary fold expression has unexpanded parameter packs in both operands'
HBE3AEFF67350: '二元摺疊運算式兩邊操作數皆存在未展開的參數包'
# 'binary integer literals are a C++14 extension'
H12BBB01421DF: '二進位整數文字是 C++14 的擴充功能'
# 'binary integer literals are a C23 extension'
HC848A482B4CC: '二進位整數文字是 C23 的擴充功能'
# 'binary integer literals are incompatible with C standards before C23'
H60CB9502C648: '二進位整數文字與 C23 之前的所有 C 標準不相容'
# 'binary integer literals are incompatible with C++ standards before C++14'
H039AFCF983A6: '二進位整數文字與 C++14 之前的 C++ 標準不相容'
# 'binary operator not supported, only +, *, -, /, &, ^, |, <<, or >> are permitted'
H947D153F3B10: '不支援的二元運算子，僅允許使用 +, *, -, /, &, ^, |, << 或 >>'
# 'binary with the instrumentation map, or a separate instrumentation map'
HC4FD0057C615: '與插樁圖結合的二進位，或獨立的插樁圖'
# 'binary with the instrumentation map, or a separate instrumentation map for graph'
H2CC2C500D553: '與插樸圖結合的二進位，或獨立的圖形插樁圖'
# 'binary with the instrumentation map, or a separate instrumentation map for graph 1'
HAEE5C542170E: '與插樁圖結合的二進位，或圖形 1 的獨立插樁圖'
# 'binary with the instrumentation map, or a separate instrumentation map for graph 2'
HC231E43E4B06: '與插樸圖結合的二進位，或圖形 2 的獨立插樁圖'
# 'binary with the instrumrntation map, or a separate instrumentation map'
H0A39B12683BE: '含插樿地圖的二進位檔，或單獨的插樿地圖'
# 'binding %0 cannot appear in the initializer of its own decomposition declaration'
H672061929029: '綁定 %0 不得出現在其自身分解宣告的初始值設定中'
# 'binding dereferenced null pointer to reference has undefined behavior'
H95EC0F6A8A66: '將解引用空指標綁定至引用具有未定義行為'
# 'binding reference %diff{of type $ to value of type $|to value}0,1 %select{drops %3 qualifier%plural{1:|2:|4:|:s}4|changes address space|not permitted due to incompatible qualifiers}2'
H55C0D80172E9: 'binding reference %diff{類型為 $ 的引用綁定到類型為 $ 的值 | 綁定到值}0,1 %select{丟失 %3 修飾符 %plural{1:|2:|4:|:s}4|改變位元組空間|因不相容修飾符而禁止}2'
# 'binding reference member %0 to stack allocated %select{variable|parameter}2 %1'
H6CEDF6C3E571: '將引用成員 %0 綁定至堆疊分配的 %select{變數|參數}2 %1'
# "binding type '%0' is invalid"
HD0FB3A3589D6: "綁定類型 '%0' 無效"
# "binding type '%select{t|u|b|s|c|i}0' cannot be applied more than once"
H9FC4B2C35AB9: "綁定類型 '%select{t|u|b|s|c|i}0' 不得重複套用"
# "binding type '%select{t|u|b|s|c}0' only applies to %select{SRV resources|UAV resources|constant buffer resources|sampler state|numeric variables in the global scope}0"
H9DB6D490A30A: "綁定類型 '%select{t|u|b|s|c}0' 只能套用於 %select{SRV 資源|UAV 資源|常數緩衝區資源|取樣器狀態|全域作用域中的數值類型}0"
# "binding type '%select{t|u|b|s|c}0' only applies to types containing %select{SRV resources|UAV resources|constant buffer resources|sampler state|numeric types}0"
H1CE73AE71EA5: "綁定類型 '%select{t|u|b|s|c}0' 只能套用於包含 %select{SRV 資源|UAV 資源|常數緩衝區資源|取樣器狀態|數值類型}0 的類型"
# "binding type 'b' only applies to constant buffers. The 'bool constant' binding type is no longer supported"
HC83E5E495198: "綁定類型 'b' 只能套用於常數緩衝區。'bool constant' 綁定類型不再支援"
# "binding type 'c' ignored in buffer declaration. Did you mean 'packoffset'?"
H937D8317B6A5: "緩衝宣告中的綁定類型 'c' 被忽略。是否應使用 'packoffset'？"
# "binding type 'i' ignored. The 'integer constant' binding type is no longer supported"
H2F0190E0856D: "綁定類型 'i' 被忽略。'integer constant' 綁定類型不再支援"
# "bit fields cannot be used to specify storage in a '%0' clause"
H5C9BE7997F9C: "'%0' 子句無法使用位域宣告指定儲存"
# 'bit-field %0 has negative width (%1)'
HA6B3D52AF212: '位域 %0 具有負寬度 (%1)'
# 'bit-field %0 has non-integral type %1'
H1F66B27F57D3: '位域 %0 的類型 %1 非整數型別'
# 'bit-field %0 is not wide enough to store all enumerators of %1'
H1E7885609E9C: '位域 %0 寬度不足，無法儲存枚舉 %1 的所有枚舉值'
# 'bit-field is declared here'
HE5CFF566169E: '位域在此處宣告'
# 'bit-fields are not supported in OpenCL'
H752654865932: '位元域在OpenCL中不受支援'
# 'bit_cast %select{from|to}0 a %select{|type with a }1%select{union|pointer|member pointer|volatile|reference}2 %select{type|member}1 is not allowed in a constant expression'
H0C9C7C0B5093: 'bit_cast %select{從|到}0 %select{|型別具有 }1%select{聯合型|指標|成員指標|volatile|參考}2 %select{型別|成員}1 在常數運算式中不被允許'
# 'bit_cast involving type %0 is not allowed in a constant expression; element size %1 * element count %2 is not a multiple of the byte size %3'
H3BD534784507: '涉及型別 %0 的bit_cast 在常數運算式中不被允許；元素大小 %1 * 元素數量 %2 不是位元組大小 %3 的倍數'
# "bitcode library '%0' does not exist"
H551B33870D5D: "bitcode函式庫 '%0' 不存在"
# 'bitmasking for introspection of Objective-C object pointers is strongly discouraged'
H7CE8DAA0A6CB: '對Objective-C物件指標進行內部檢查的位遮罩操作強烈不建議使用'
# 'bitwise comparison always evaluates to %select{false|true}0'
H8A4398170F46: '位元比較始終評估為 %select{false|true}0'
# "bitwise negation of a boolean expression%select{;| always evaluates to 'true';}0 did you mean logical negation?"
HE532D6128324: "布林運算式的位元非運算 %select{;| 始終評估為 'true';}0 你是否想要邏輯非運算？"
# 'bitwise or with non-zero value always evaluates to true'
H6F8F36ACC41B: '與非零值的位元或運算始終評估為 true'
# 'block cannot return %select{array|function}0 type %1'
H91AB8D594327: '區塊不得返回 %select{陣列|函數}0 型別 %1'
# 'block captures an autoreleasing out-parameter, which may result in use-after-free bugs'
H835D51AA87F3: '區塊捕獲了自動釋放的輸出參數，可能導致使用已釋放記憶體的錯誤'
# "block could be declared with attribute 'noreturn'"
H9307EF042F77: "該區塊可宣告具備 'noreturn' 屬性"
# "block implicitly retains 'self'; explicitly mention 'self' to indicate this is intended behavior"
H094C5FEF2D2A: "區塊隱式保留 'self'；若此行為有意圖，請明確提及 'self'"
# 'block pointer to non-function type is invalid'
H9EFC2777265D: '非函數型別的區塊指標無效'
# 'block pointer variable %0 is %select{uninitialized|null}1 when captured by block'
H5DFD2F29C16B: '區塊指標變數 %0 在被捕獲時處於 %select{未初始化|null}1 狀態'
# 'block type cannot be used as expression in ternary expression in OpenCL'
HE91DFBCBC336: 'OpenCL中無法將區塊型別用作三元運算式中的運算元'
# 'block will be retained by %select{the captured object|an object strongly retained by the captured object}0'
H659E73E5BC81: '區塊將被 %select{捕獲物件|被捕獲物件強制保留的物件}0 保留'
# 'blocks support disabled - compile with -fblocks or %select{pick a deployment target that supports them|for OpenCL C 2.0 or OpenCL C 3.0 with __opencl_c_device_enqueue feature}0'
H870F6FD76494: '區塊支援已停用 - 編譯時需指定 -fblocks 或 %select{選擇支援區塊的部署目標|OpenCL C 2.0 或 OpenCL C 3.0 且具備 __opencl_c_device_enqueue 功能}0'
# "blocks used in enqueue_kernel call are expected to have parameters of type 'local void*'"
H5A1C0A69E254: "enqueue_kernel 呼叫中使用的區塊期望具有 'local void*' 類型的參數"
# 'blocks with parameters are not accepted in this prototype of enqueue_kernel call'
H6F73FE38020E: '此 enqueue_kernel 呼叫原型不接受帶有參數的區塊'
# 'body of cpu_dispatch function will be ignored'
H8CCA48E04008: 'cpu_dispatch 函數的主體將被忽略'
# "bool literal returned from 'main'"
H65A070E22BD6: "從 'main' 返回布林文字"
# 'both arms of conditional operator are unable to produce a constant expression'
H42234192A750: '條件運算子的兩邊均無法產生常數運算式'
# 'boundary to use for alignment of basic blocks'
H8D491EEC35CA: '用於基本區塊對齊的邊界值'
# 'brace elision for designated initializer is a C99 extension'
H98B26CB02BEA: '為指定初始化器省略大括號是 C99 的擴充功能'
# 'braces around %select{scalar |}0initializer'
H5FA1CA5D46EC: '%select{純量 |}0 初始化式周圍的大括號'
# 'bracket nesting level exceeded maximum of %0'
HAE0DB07D013C: '括號嵌套層級超過最大值 %0'
# 'brackets are not allowed here; to declare an array, place the brackets after the %select{identifier|name}0'
H9FD98F06E7EB: '這裡不允許使用括號；若要宣告陣列，請將括號放在 %select{識別符|名稱}0 之後'
# 'branch probability threshold in percentage to be considered very likely'
H4385A55B36C8: '視為非常可能的分支機率閾值（百分比）'
# 'branch probability threshold in percentage to be considered very likely when profile is available'
H7FFFD5CE40B4: '當有剖面資料時，視為非常可能的分支機率閾值（百分比）'
# 'branch relax asm'
HC2E42E8DC7A2: '分支鬆弛 asm'
# "build a shadowed submodule '%0'"
H9D79CC95EF50: "建立陰影子模組 '%0'"
# "building module '%0' as '%1'"
H765D28E7D6EF: "將模組 '%0' 建立為 '%1'"
# 'built-in candidate %0'
H70FA60F84316: '內建候選 %0'
# 'builtin %0 is deprecated; use %1 instead'
H3145BB7C5706: '內建函數 %0 已棄用；請改用 %1'
# 'builtin call is not valid when calling from a function without active ZA state'
H7B974CCBB78F: '在呼叫未處於有效 ZA 狀態的函數時，內建函數呼叫無效'
# 'builtin call is not valid when calling from a function without active ZT0 state'
H1B7C49833DEE: '在呼叫未處於有效 ZT0 狀態的函數時，內建函數呼叫無效'
# 'builtin can only be called from a %0 function'
H2DDDDEB70C80: '內建函數只能從 %0 函式中呼叫'
# 'builtin feature check macro requires a parenthesized identifier'
HA88BFEE47095: '內建功能檢查宏需要括號包圍的識別項'
# 'builtin functions must be directly called'
HABBC844A5E58: '內建函數必須直接呼叫'
# 'builtin headers belong to system modules, and _Builtin_ modules are ignored for cstdlib headers'
HFC2F5B50372D: '內建標頭屬於系統模組，且_Builtin_ 模組會被忽略用於 cstdlib 標頭'
# 'builtin is not supported on this target'
H6C31A7E5443F: '此目標不支援此內建功能'
# 'builtin requires%select{| at least one of the following extensions}0: %1'
HBE3E35E72C33: '內建功能需要 %select{|至少開啟下列其中一個擴充功能}0: %1'
# "but in %select{'%1'|definition here}0 found %select{%3 referenced %plural{1:protocol|:protocols}3|%ordinal3 referenced protocol with different name %4}2"
HD3683C05282A: "但在 %select{'%1'|定義在此處}0 發現 %select{%3 參考 %plural{1:協定|:協定}3|%ordinal3 參考名稱不同的協定 %4}2"
# "but in %select{'%1'|definition here}0 found %select{%select{method %4|constructor|destructor}3 that has %5 parameter%s5|%select{method %4|constructor|destructor}3 with %ordinal5 parameter of type %6%select{| decayed from %8}7|%select{method %4|constructor|destructor}3 with %ordinal5 parameter named %6}2"
HF69A42480F6D: "但在 %select{'%1'|定義在此處}0 發現 %select{%select{方法 %4|建構函數|析構函數}3 具有 %5 參數%s5|%select{方法 %4|建構函數|析構函數}3 的第 %ordinal5 個參數類型為 %6%select{| 來自 %8 的衰減}7|%select{方法 %4|建構函數|析構函數}3 的第 %ordinal5 個參數名稱為 %6}2"
# "but in %select{'%1'|definition here}0 found %select{%select{no super class|super class with type %4}3|instance variable '%3' access control is %select{|@private|@protected|@public|@package}4}2"
H07A5F408116E: "但在 %select{'%1'|定義處}0 發現 %select{%select{無超類|超類型 %4}3|實體變數 '%3' 存取控制為 %select{|@private|@protected|@public|@package}4}2"
# "but in %select{'%1'|definition here}0 found %select{end of class|public access specifier|private access specifier|protected access specifier|static assert|field|method|type alias|typedef|data member|friend declaration|function template|method|instance variable|property}2"
H901B5EFBD082: "但在 %select{'%1'|定義處}0 發現 %select{類別結束|公開存取規格|私有存取規格|受保護存取規格|靜態斷言|成員變數|方法|類型別名|typedef|資料成員|友元宣告|函式模板|方法|實體變數|屬性}2"
# "but in %select{'%1'|definition here}0 found %select{field %3|field %3 with type %4|%select{non-|}4bit-field %3|bit-field %3 with different width expression|%select{non-|}4mutable field %3|field %3 with %select{no|an}4 initializer|field %3 with a different initializer}2"
H4C900A5437EA: "但在 %select{'%1'|定義處}0 發現 %select{名為 %3 的成員|型別為 %4 的成員 %3|%select{非-|}4 位元域 %3|寬度表達式不同的位元域 %3|%select{非-|}4 可變更成員 %3|初始化式不同的成員 %3|%select{無|有}4 初始化式的成員 %3}2"
# "but in %select{'%1'|definition here}0 found %select{method %3 with different return type %4|method %3 as %select{class|instance}4 method|%select{no|'required'|'optional'}3 method control|method %3 with %select{no designated initializer|designated initializer}4|%select{regular|direct}4 method %3|different method %3}2"
H9C08666CA7C3: "但在 %select{'%1'|定義處}0 發現 %select{回傳型別為 %4 的 %3 方法|%3 方法為 %select{類別|實例}4 方法|%select{無|必要|選擇性}3 方法控制|%select{無預設參數|有預設參數}4 的 %3 方法|%select{一般|直接}4 %3 方法|不同的 %3 方法}2"
# "but in %select{'%1'|definition here}0 found %select{property %3|property %3 with type %4|%select{no|'required'|'optional'}3 property control|property %3 with different '%select{none|readonly|getter|assign|readwrite|retain|copy|nonatomic|setter|atomic|weak|strong|unsafe_unretained|nullability|null_resettable|class|direct}4' attribute}2"
HFF656A371ACE: "但在 %select{'%1'|定義處}0 發現 %select{屬性 %3|類型 %4 的屬性 %3|%select{無|'required'|'optional'}3 屬性控制|屬性 %3 具有不同的 '%select{none|readonly|getter|assign|readwrite|retain|copy|nonatomic|setter|atomic|weak|strong|unsafe_unretained|nullability|null_resettable|class|direct}4' 屬性}2"
# "but in %select{'%1'|definition here}0 found %select{||||different static assert|different field|different method|different type alias|different typedef|different data member|different friend declaration|different function template|different method|different instance variable|different property|another unexpected decl}2"
HF376197A4A03: "但在 %select{'%1'|定義在此處}0 發現 %select{||||不同的 static assert|不同的成員變數|不同的方法|不同的類型別名|不同的 typedef|不同的資料成員|不同的 friend 宣告|不同的函數範本|不同的方法|不同的實體變數|不同的屬性|另一個意外宣告}2"
# "but in '%0' found %select{%2 base %plural{1:class|:classes}2|%2 virtual base %plural{1:class|:classes}2|%ordinal2 base class with different type %3|%ordinal2 %select{non-virtual|virtual}3 base class %4|%ordinal2 base class %3 with %select{public|protected|private|no}4 access specifier}1"
H86407D9382F4: "但在 '%0' 發現 %select{具有 %plural{1:基礎類別|:基礎類別}%2|%plural{1:虛基礎類別|:虛基礎類別}%2|%ordinal2 基礎類別型別為 %3|%ordinal2 %select{非虛|虛}3 基礎類別 %4|%ordinal2 基礎類別 %3 具有 %select{public|protected|private|無}4 存取修飾詞}1"
# "but in '%0' found %select{%select{typedef|type alias}2 name %3|%select{typedef|type alias}2 %3 with different underlying type %4}1"
H5285292325BC: "但在 '%0' 發現 %select{%select{typedef|類型別名}2 名稱 %3|%select{typedef|類型別名}2 %3 具有不同的底層類型 %4}1"
# "but in '%0' found %select{data member with name %2|data member %2 with different type %3|data member %2 with%select{out|}3 an initializer|data member %2 with a different initializer|data member %2 %select{is constexpr|is not constexpr}3}1"
HB02EC39C6642: "但在 '%0' 中找到 %select{具有名稱 %2 的資料成員|具有不同類型 %3 的資料成員 %2|具有名稱 %2 的資料成員%select{未初始化|}3|具有名稱 %2 的資料成員具有不同初始化式|具有名稱 %2 的資料成員%select{為 constexpr|非 constexpr}3}1"
# "but in '%0' found %select{different return type %2|%ordinal2 parameter with name %3|%ordinal2 parameter with type %3%select{| decayed from %5}4|%ordinal2 parameter with%select{out|}3 a default argument|%ordinal2 parameter with a different default argument|a different body}1"
H926097C3EBA4: "但在 '%0' 中找到 %select{不同的返回類型 %2|%ordinal2 參數具有名稱 %3|%ordinal2 參數具有類型 %3%select{| 由 %5 衰減而來}4|%ordinal2 參數%select{未指定|}3 預設參數|%ordinal2 參數具有不同預設參數|不同的函數本體}1"
# "but in '%0' found %select{enum that is %select{not scoped|scoped}2|enum scoped with keyword %select{struct|class}2|enum %select{without|with}2 specified type|enum with specified type %2|enum with %2 element%s2|%ordinal2 element has name %3|%ordinal2 element %3 %select{has|does not have}4 an initializer|%ordinal2 element %3 has different initializer|}1"
H44D066860BB7: "但在 '%0' 中找到 %select{類型%select{非命名空間|命名空間}2 的 enum|enum 命名空間使用關鍵字 %select{struct|class}2|enum%select{未指定|指定}2 類型|enum 具有指定類型 %2|enum 具有 %2 成員%s2|%ordinal2 成員具有名稱 %3|%ordinal2 成員 %3 %select{具有|未指定}4 初始化式|%ordinal2 成員 %3 具有不同初始化式|}1"
# "but in '%0' found %select{static assert with different condition|static assert with different message|static assert with %select{|no }2message|%select{method %3|constructor|destructor}2|%select{method %3|constructor|destructor}2 is %select{not deleted|deleted}4|%select{method %3|constructor|destructor}2 is %select{not defaulted|defaulted}4|%select{method %3|constructor|destructor}2 is %select{|pure }4%select{not virtual|virtual}5|%select{method %3|constructor|destructor}2 is %select{not static|static}4|%select{method %3|constructor|destructor}2 is %select{not volatile|volatile}4|%select{method %3|constructor|destructor}2 is %select{not const|const}4|%select{method %3|constructor|destructor}2 is %select{not inline|inline}4|%select{method %3|constructor|destructor}2 with %ordinal4 parameter with%select{out|}5 a default argument|%select{method %3|constructor|destructor}2 with %ordinal4 parameter with a different default argument|%select{method %3|constructor|destructor}2 with %select{no |}4template arguments|%select{method %3|constructor|destructor}2 with %4 template argument%s4|%select{method %3|constructor|destructor}2 with %4 for %ordinal5 template argument|%select{method %3|constructor|destructor}2 with %select{no body|body}4|%select{method %3|constructor|destructor}2 with different body|friend %select{class|function}2|friend %2|friend function %2|function template %2 with %3 template parameter%s3|function template %2 with %ordinal3 template paramter being a %select{type|non-type|template}4 template parameter|function template %2 with %ordinal3 template parameter %select{with no name|named %5}4|function template %2 with %ordinal3 template parameter with %select{no |}4default argument|function template %2 with %ordinal3 template parameter with default argument %4|function template %2 with %ordinal3 template parameter with different type|function template %2 with %ordinal3 template parameter %select{not |}4being a template parameter pack|}1"
H650FCD73F7BC: "但在 '%0' 中發現 %select{具有不同條件的 static assert|具有不同訊息的 static assert|static assert 無 %select{|}2 訊息|%select{方法 %3|建構函式|析構函式}2|%select{方法 %3|建構函式|析構函式}2 是%select{未刪除|已刪除}4|%select{方法 %3|建構函式|析構函式}2 是%select{未預設|已預設}4|%select{方法 %3|建構函式|析構函式}2 是 %select{|純 }4%select{非虛|虛}5|%select{方法 %3|建構函式|析構函式}2 是%select{非靜態|靜態}4|%select{方法 %3|建構函式|析構函式}2 是%select{非揮發|揮發}4|%select{方法 %3|建構函式|析構函式}2 是%select{非常數|常數}4|%select{方法 %3|建構函式|析構函式}2 是%select{非內嵌|內嵌}4|%select{方法 %3|建構函式|析構函式}2 的第 %ordinal4 個參數%select{有|}5 預設參數|%select{方法 %3|建構函式|析構函式}2 的第 %ordinal4 個參數具有不同預設參數|%select{方法 %3|建構函式|析構函式}2%select{無|}4 模板參數|%select{方法 %3|建構函式|析構函式}2 具有 %4 個模板參數|%select{方法 %3|建構函式|析構函式}2 的第 %ordinal5 個模板參數為 %4|%select{方法 %3|建構函式|析構函式}2%select{無|}4 函式主體|%select{方法 %3|建構函式|析構函式}2 具有不同函式主體|友元%select{類別|函式}2|友元 %2|友元函式 %2|函式模板 %2 具有 %3 個模板參數|函式模板 %2 的第 %ordinal3 個模板參數為 %select{類型|非類型|模板}4 模板參數|函式模板 %2 的第 %ordinal3 個模板參數%select{無名稱|稱為 %5}4|函式模板 %2 的第 %ordinal3 個模板參數%select{無|}4 預設參數|函式模板 %2 的第 %ordinal3 個模板參數具有預設參數 %4|函式模板 %2 的第 %ordinal3 個模板參數具有不同類型|函式模板 %2 的第 %ordinal3 個模板參數%select{非|}4 為模板參數包|}1"
# "but in '%0' found %select{unnamed template parameter %2|template parameter %3|template parameter with %select{no |}2default argument|template parameter with different default argument}1"
HA18966A0FC1B: "但在 '%0' 中找到 %select{未命名的第 %2 個模板參數|模板參數 %3|模板參數%select{未指定|}2 預設參數|模板參數具有不同預設參數}1"
# "by value capture of '*this' is incompatible with C++ standards before C++17"
H60BDFA125D23: "C++17 以前的 C++ 標準不支援 '*this' 的按值捕獲"
# 'by-copy capture of value of abstract type %0'
H69470A21D7A2: '抽象類型 %0 的按值捕獲'
# 'by-copy capture of variable %0 with %select{incomplete|sizeless}1 type %2'
H0B21D37A79AB: '具有 %select{不完整|無大小}1 類型 %2 的變數 %0 的複製捕獲'
# 'cache-aware duplication strategy'
HF9F924A27610: '具快取意識的複製策略'
# 'calculate and print various metrics for instruction cache'
HE98D77A3BA25: '計算並列印指令快取相關的各項指標'
# 'call to %0 implicitly required by coroutine function here'
H58DB024E2029: '此協程函數處所隱含需要 %0 呼叫'
# 'call to %0 is ambiguous'
HE4A087079576: '對 %0 的呼叫存在歧義'
# 'call to %select{immediate|consteval}1 function %q0 is not a constant expression'
H00D075778CD9: '%select{立即|consteval}1 函數 %q0 的呼叫不是常數運算式'
# 'call to %select{non-static|explicit}0 member function without an object argument'
H63B47EF20C66: '對 %select{非靜態|明確}0 成員函數進行無物件參數的呼叫'
# 'call to %select{placement|class-specific}0 %1'
H295DBDE7B5BD: '對 %select{置位|類別特定}0 %1 的呼叫'
# "call to '%0' declared with 'error' attribute: %1"
HDBB58BF71CEC: "呼叫帶有 'error' 屬性宣告的 '%0'：%1"
# "call to '%0' declared with 'warning' attribute: %1"
H3865B6C0D901: "呼叫帶有 'warning' 屬性宣告的 '%0'：%1"
# "call to '%select{__builtin_operator_new|__builtin_operator_delete}0' selects non-usual %select{allocation|deallocation}0 function"
H676581AF4E96: "呼叫 '%select{__builtin_operator_new|__builtin_operator_delete}0' 選取非常規的 %select{分配|釋放}0 函數"
# "call to '%select{initial_suspend|final_suspend}0' implicitly required by the %select{initial suspend point|final suspend point}0"
H1C6B1E5ADCED: '由 %select{初始暫停點|最終暫停點}0 隱式需要的 %select{initial_suspend|final_suspend}0 呼叫'
# "call to 'await_transform' implicitly required by 'co_await' here"
HA0503466B398: "此 'co_await' 隱式需要 'await_transform' 呼叫"
# "call to a function that shares state other than 'za' from a function that has live 'za' state requires a spill/fill of ZA, which is not yet implemented"
H8FF6C74595CF: "從具有活躍 ZA 狀態的函數呼叫具有非 'za' 狀態的函數需要 ZA 的spill/fill，但尚未實作"
# 'call to a shared ZA function requires the caller to have ZA state'
H755688EF43BB: '呼叫共用 ZA 函數需要呼叫者具有 ZA 狀態'
# 'call to a shared ZT0 function requires the caller to have ZT0 state'
H89ACEBE543C2: '呼叫共用 ZT0 函數需要呼叫者具有 ZT0 狀態'
# "call to a streaming function requires 'sme'"
H41309CFB27F8: "呼叫串流函數需要 'sme'"
# 'call to constructor of %0 is ambiguous'
H00A38B0315FF: '對 %0 的建構函數呼叫存在歧義'
# 'call to deleted constructor of %0%select{|: %2}1'
HAA8E5FBCBA79: '呼叫已刪除的 %0 建構函數 %select{|: %2}1'
# 'call to deleted function call operator in type %0%select{|: %2}1'
H8F857BEAC26F: '呼叫類別 %0 中已刪除的呼叫運算子 %select{|: %2}1'
# 'call to deleted%select{| member}0 function %1%select{|: %3}2'
H6B002A51A7D4: '呼叫已刪除 %select{| 成員}0 函數 %1%select{|: %3}2'
# 'call to function %0 that is neither visible in the template definition nor found by argument-dependent lookup'
H225588528963: '呼叫在模板定義中不可見且未經引數依賴查找找到的全域函數 %0'
# 'call to global function %0 not configured'
HC08574A55FB5: '呼叫全域函數 %0 未配置'
# 'call to implicitly-deleted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|function}0 of %1'
H4C623CF7C837: '呼叫隱式刪除的 %select{預設建構函數|複製建構函數|移動建構函數|複製賦值運算子|移動賦值運算子|析構函數|函數}0 的 %1'
# 'call to member function %0 is ambiguous'
H60EE3A6ABF6A: '對成員函數 %0 的呼叫存在歧義'
# 'call to object of type %0 is ambiguous'
H3783B2A8DBDC: '呼叫類型 %0 的物件存在二義性'
# "call to pointer to member function of type %0 drops '%1' qualifier%s2"
HC75C3E40313D: "呼叫 %0 類型的成員函數指標時遺漏了 '%1' 修飾符%s2"
# 'call to pseudo-destructor cannot have any arguments'
H6ECE40631FC9: '對偽析構函數的呼叫不能有任何參數'
# 'call to pure virtual member function %0 has undefined behavior; overrides of %0 in subclasses are not available in the %select{constructor|destructor}1 of %2'
HDC8AD43C5C1C: '呼叫純虛成員函數 %0 具有未定義行為；%0 的子類別覆寫在 %2 的%select{建構函數|析構函數}1 中不可用'
# 'call to subscript operator of type %0 is ambiguous'
H1E29AAB6AD84: '呼叫類型 %0 的索引運算子存在二義性'
# 'call to undeclared function %0; ISO C99 and later do not support implicit function declarations'
HEBF384E2E2A6: '呼叫未宣告函數 %0；ISO C99 及後續版本不支援隱式函數宣告'
# "call to undeclared library function '%0' with type %1; ISO C99 and later do not support implicit function declarations"
HF288A58FA40B: "呼叫未宣告的函式庫函數 '%0' 類型 %1；ISO C99 及後續版本不支援隱式函數宣告"
# 'call to unsupported expression with unknown type'
H239ACE39DA12: '呼叫具有未知類型的不受支援運算式'
# 'called by %0'
HDC9A013B796D: '被 %0 呼叫'
# 'called object type %0 is not a function or function pointer'
H5E3F97BDB14E: '被呼叫物件類型 %0 非函數或函數指標'
# 'callee declares array parameter as static here'
H80DA3F678F9A: '被呼叫方在此處將陣列參數宣告為 static'
# "calling %0 is a violation of trusted computing base '%1'"
HF890EA6739C7: "呼叫 %0 違反受信任的運算基礎 '%1'"
# 'calling %0 with incomplete return type %1'
H218BBBD759BD: '呼叫 %0 時使用不完整返回類型 %1'
# "calling '%0' with a nonzero argument is unsafe"
H373CF9276563: "呼叫 '%0' 時帶有非零參數是不安全的"
# 'calling a %select{private|protected}0 constructor of class %2'
H1D7B9B5BEE0D: '呼叫類別 %2 的%select{私有|受保護的}0 建構函數'
# 'calling a %select{private|protected}1 destructor of class %0'
H2870B0B82BD7: '呼叫類別 %0 的%select{私有|受保護的}1 析構函數'
# "calling function %0 requires negative capability '%1'"
HB81388BC5C94: "呼叫函數 %0 需要負向能力 '%1'"
# "calling function %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
HF6312AC18647: "呼叫函數 %1 需要持有 %0%select{'%2'|' 排他性 %2'}3"
# 'calling function with incomplete return type %0'
H47066D05EDB3: '呼叫具有不完整返回類型 %0 的函式'
# 'calls the given entry-point on a new thread (jit-kind=orc-lazy only)'
HD909298BB334: '在新執行緒上呼叫給定的入口點（僅限jit-kind=orc-lazy）'
# 'calls to OpenMP runtime API are not allowed within a region that corresponds to a construct with an order clause that specifies concurrent'
HF0FE255D765C: '在對應於具有指定concurrent子句的構造的區域內，不得呼叫OpenMP運行時API'
# 'can only access this member on an object of type %0'
H97DBB9710EB7: '只能在類型 %0 的物件上存取此成員'
# 'can only poison identifier tokens'
HBA757282B22F: '只能毒化識別符號字元'
# 'can only provide an explicit specialization for a class template, function template, variable template, or a member function, static data member, %select{or member class|member class, or member enumeration}0 of a class template'
H705307E2F906: '只能為類別範本、函數範本、變數範本，或類別範本的成員函數、靜態資料成員%select{、或成員類別|、成員類別或成員列舉}0提供顯式專案'
# "can only use 'init_priority' attribute on file-scope definitions of objects of class type"
H2C248D12A320: "'init_priority' 屬性只能用在類別型物件的文件作用域定義上"
# 'candidate %select{constructor|template}0 ignored: inherited constructor cannot be used to %select{copy|move}1 object'
HA2E8E747932F: '候選%select{建構函數|範本}0被忽略：繼承而來的建構函數無法用於%select{複製|移動}1物件'
# 'candidate %select{constructor|template}0 ignored: instantiation %select{takes|would take}0 its own class type by value'
H5F81F51806D8: '候選%select{建構函數|範本}0被忽略：實例化%select{需要|將需要}0以值形式接受自身類別型態'
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 has been %select{explicitly made unavailable|explicitly deleted|implicitly deleted}3"
HDF3920A3A1F2: "候選%select{函數|函數|函數（參數順序反轉）|建構函數|預設建構函數（隱式）|複製建構函數（隱式）|移動建構函數（隱式）|複製指定運算子（隱式）|移動指定運算子（隱式）|為此 'operator<=>' 隱式產生的 'operator=='|繼承而來的建構函數}0%select{|範本| %2}1 已被%select{明確標記不可用|明確刪除|隱式刪除}3"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %ordinal5 argument (%3) would lose %select{const|restrict|const and restrict|volatile|const and volatile|volatile and restrict|const, volatile, and restrict}4 qualifier%select{||s||s|s|s}4"
H95E4AEB3B23E: "候選%select{函數|函數|函數（參數順序反轉）|建構函數|預設建構函數（隱式）|複製建構函數（隱式）|移動建構函數（隱式）|複製指定運算子（隱式）|移動指定運算子（隱式）|為此 'operator<=>' 隱式產生的 'operator=='|繼承而來的建構函數}0%select{|範本| %2}1 不可行：%ordinal5個參數（%3）將失去 %select{const|restrict|const和restrict|volatile|const和volatile|volatile和restrict|const、volatile和restrict}4 資格 %select{||s||s|s|s}4"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %select{%ordinal7|'this'}6 argument (%3) has %select{no|__unsafe_unretained|__strong|__weak|__autoreleasing}4 ownership, but parameter has %select{no|__unsafe_unretained|__strong|__weak|__autoreleasing}5 ownership"
H8D414CDC2F4E: "候選%select{函數|函數|函數（參數順序反轉）|建構函數|預設建構函數（隱式）|複製建構函數（隱式）|移動建構函數（隱式）|複製指定運算子（隱式）|移動指定運算子（隱式）|為此 'operator<=>' 隱式產生的 'operator=='|繼承而來的建構函數}0%select{|範本| %2}1 不可行：%select{%ordinal7|'this'}6 個參數（%3）具有%select{無|__unsafe_unretained|__strong|__weak|__autoreleasing}4 所有權，但參數需要%select{無|__unsafe_unretained|__strong|__weak|__autoreleasing}5 所有權"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %select{%ordinal7|'this'}6 argument (%3) has %select{no|__weak|__strong}4 ownership, but parameter has %select{no|__weak|__strong}5 ownership"
HFD1E148AC849: "候選%select{函數|函數|函數（參數順序反轉）|建構函數|預設建構函數（隱式）|複製建構函數（隱式）|移動建構函數（隱式）|複製指定運算子（隱式）|移動指定運算子（隱式）|為此 'operator<=>' 隱式產生的 'operator=='|繼承而來的建構函數}0%select{|範本| %2}1 不可行：%select{%ordinal7|'this'}6 個參數（%3）具有%select{無|__weak|__strong}4 所有權，但參數需要%select{無|__weak|__strong}5 所有權"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %select{cannot convert initializer list|too few initializers in list|too many initializers in list}7 argument to %4"
H4C57102C9323: "候選%select{函數|函數|函數（參數順序反轉）|建構函數|預設建構函數（隱式）|複製建構函數（隱式）|移動建構函數（隱式）|複製指定運算子（隱式）|移動指定運算子（隱式）|為此 'operator<=>' 隱式產生的 'operator=='|繼承而來的建構函數}0%select{|範本| %2}1 不可行：%select{初始化清單無法轉換|初始化清單項目過少|初始化清單項目過多}7個參數轉換至 %4"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %select{requires at least|allows at most single|requires single}3 %select{|non-object }6argument %4, but %plural{0:no|:%5}5 arguments were provided"
H8AD4B8B6097C: "候選%select{函數|函數|函數（參數順序反轉）|建構函數|預設建構函數（隱式）|複製建構函數（隱式）|移動建構函數（隱式）|複製指定運算子（隱式）|移動指定運算子（隱式）|為此 'operator<=>' 隱式產生的 'operator=='|繼承而來的建構函數}0%select{|範本| %2}1 不可行：%select{至少需要|最多僅允許單一|需要單一}3 %select{|非物件 }6參數 %4，但 %plural{0:無|:%5}5 個參數被提供"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: 'this' argument has type %3, but method is not marked %select{const|restrict|const or restrict|volatile|const or volatile|volatile or restrict|const, volatile, or restrict}4"
HE6BBB39EEE68: "候選%select{函數|函數|參數順序相反的函數|建構函數|預設隱含建構函數|複製隱含建構函數|移動隱含建構函數|複製隱含指定運算子函數|移動隱含指定運算子函數|此 'operator<=>' 的隱含 'operator==' 函數|繼承建構函數}0%select{| 範型| %2}1 不適用：'this' 參數的類型為 %3，但方法未標記 %select{const|restrict|const 或 restrict|volatile|const 或 volatile|volatile 或 restrict|const、volatile 或 restrict}4"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: 'this' object is in %3, but method expects object in %4"
H7EDBF536C9E0: "候選%select{函數|函數|參數順序顛倒的函數|建構函數|隱含預設建構函數|隱含複製建構函數|隱含移動建構函數|隱含複製指定運算子函數|隱含移動指定運算子函數|為此 'operator<=>' 隱含的 'operator==' 函數|繼承的建構函數}0%select{|範本| %2}1 不適用：此物件位於 %3，但方法需要物件位於 %4"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: call to %select{__device__|__global__|__host__|__host__ __device__|invalid}3 function from %select{__device__|__global__|__host__|__host__ __device__|invalid}4 function"
HB286FD7ADB16: "候選%select{函數|函數|參數順序相反的函數|建構函數|預設隱含建構函數|複製隱含建構函數|移動隱含建構函數|複製隱含指定運算子函數|移動隱含指定運算子函數|此 'operator<=>' 的隱含 'operator==' 函數|繼承建構函數}0%select{| 範型| %2}1 不適用：從 %select{__device__|__global__|__host__|__host__ __device__|無效}4 函數呼叫 %select{__device__|__global__|__host__|__host__ __device__|無效}3 函數"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: cannot %select{convert from|convert from|bind}3 %select{base class pointer|superclass|base class object of type}3 %4 to %select{derived class pointer|subclass|derived class reference}3 %5 for %ordinal6 argument"
H9EF538024430: "候選 %select{函式|函式|參數順序相反的函式|建構函式|隱含預設建構函式|隱含複製建構函式|隱含移動建構函式|隱含複製指定運算子的函式|隱含移動指定運算子的函式|隱含此 'operator<=>' 的 'operator==' 的函式|繼承的建構函式}0%select{| 範本| %2}1 不合適：無法 %select{將|將|綁定}3 %select{基底類別指標|超類別|基底類別物件的類型}3 %4 轉換為 %select{派生類別指標|子類別|派生類別參考}3 %5 作為 %ordinal6 個參數"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: cannot %select{pass pointer to|bind reference in}5 %3 %select{as a pointer to|to object in}5 %4 in %ordinal6 argument"
HEE13EA6B12B0: "候選%select{函數|函數|參數順序相反的函數|建構函數|預設隱含建構函數|複製隱含建構函數|移動隱含建構函數|複製隱含指定運算子函數|移動隱含指定運算子函數|此 'operator<=>' 的隱含 'operator==' 函數|繼承建構函數}0%select{| 範型| %2}1 不適用：無法 %select{傳遞指標到|在}5 %3 %select{作為指標到|到物件位於}5 %4 在第 %ordinal6 個參數"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: cannot convert argument of incomplete type %diff{$ to $|to parameter type}3,4 for %select{%ordinal6 argument|object argument}5%select{|; dereference the argument with *|; take the address of the argument with &|; remove *|; remove &}7"
H3F2CD3D64E80: "候選%select{函數|函數|參數順序相反的函數|建構函數|預設隱含建構函數|複製隱含建構函數|移動隱含建構函數|複製隱含指定運算子函數|移動隱含指定運算子函數|此 'operator<=>' 的隱含 'operator==' 函數|繼承建構函數}0%select{| 範型| %2}1 不適用：無法將不完整類型 %diff{$ 轉換為 $|參數類型}3,4 轉換 %select{第 %ordinal6 個參數|物件參數}5%select{|；用 * 解引用參數|；用 & 取得參數位址|；移除 *|；移除 &}7"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: cannot implicitly convert argument %diff{of type $ to $|type to parameter type}3,4 for %select{%ordinal6 argument|object argument}5 under ARC"
H2B5B49758162: "候選%select{函數|函數|參數順序相反的函數|建構函數|預設隱含建構函數|複製隱含建構函數|移動隱含建構函數|複製隱含指定運算子函數|移動隱含指定運算子函數|此 'operator<=>' 的隱含 'operator==' 函數|繼承建構函數}0%select{| 範型| %2}1 不適用：在 ARC 下無法隱式轉換第 %diff{類型 $ 到 $|參數類型}3,4 的第 %select{%ordinal6 個參數|物件參數}5"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: constraints not satisfied"
H01514E19EB13: "候選%select{函數|函數|參數順序相反的函數|建構函數|預設隱含建構函數|複製隱含建構函數|移動隱含建構函數|複製隱含指定運算子函數|移動隱含指定運算子函數|此 'operator<=>' 的隱含 'operator==' 函數|繼承建構函數}0%select{| 範型| %2}1 不適用：約束條件不符合"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: expects an %select{lvalue|rvalue}5 for %select{%ordinal4 argument|object argument}3"
H5778CD649B7A: "候選 %select{函數|函數|參數順序相反的函數|建構函數|預設隱含建構函數|複製隱含建構函數|移動隱含建構函數|隱含複製賦值運算子函數|隱含移動賦值運算子函數|為此 'operator<=>' 隱含的 'operator==' 函數|繼承的建構函數}0%select{| 範型| %2}1 不適用：期望 %select{lvalue|rvalue}5 為 %select{%ordinal4 參數|物件參數}3"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: no known conversion %diff{from $ to $|from argument type to parameter type}3,4 for %select{%ordinal6 argument|object argument}5%select{|; dereference the argument with *|; take the address of the argument with &|; remove *|; remove &}7"
H2C02021665E8: "候選%select{函數|函數|參數順序相反的函數|建構函數|預設隱含建構函數|複製隱含建構函數|移動隱含建構函數|複製隱含指定運算子函數|移動隱含指定運算子函數|此 'operator<=>' 的隱含 'operator==' 函數|繼承建構函數}0%select{| 範型| %2}1 不適用：無已知轉換 %diff{從 $ 到 $|參數類型到參數類型}3,4 %select{第 %ordinal6 個參數|物件參數}5%select{|；用 * 解引用參數|；用 & 取得參數位址|；移除 *|；移除 &}7"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: no overload of %4 matching %3 for %ordinal5 argument"
H327F9AFBF1B4: "候選%select{函數|函數|參數順序相反的函數|建構函數|預設隱含建構函數|複製隱含建構函數|移動隱含建構函數|複製隱含指定運算子函數|移動隱含指定運算子函數|此 'operator<=>' 的隱含 'operator==' 函數|繼承建構函數}0%select{| 範型| %2}1 不適用：無符合 %3 的 %4 重載版本在第 %ordinal5 個參數"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: requires%select{ at least| at most|}3 %4 %select{|non-object }6argument%s4, but %5 %plural{1:was|:were}5 provided"
HE70B20B055FA: "候選%select{函數|函數|參數順序相反的函數|建構函數|預設隱含建構函數|複製隱含建構函數|移動隱含建構函數|複製隱含指定運算子函數|移動隱含指定運算子函數|此 'operator<=>' 的隱含 'operator==' 函數|繼承建構函數}0%select{| 範型| %2}1 不適用：需要%select{至少| 最多|}3 %4 %select{|非物件 }6參數%s4，但 %5 %plural{1:有|:有}5 被提供"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %3}1%select{| has different class%diff{ (expected $ but has $)|}5,6| has different number of parameters (expected %5 but has %6)| has type mismatch at %ordinal5 parameter%diff{ (expected $ but has $)|}6,7| has different return type%diff{ ($ expected but has $)|}5,6| has different qualifiers (expected %5 but found %6)| has different exception specification}4"
H8C85DA7348D1: "候選%select{函數|函數|參數順序反轉的函數|建構函數|隱含預設建構函數|隱含複製建構函數|隱含移動建構函數|隱含複製賦值運算子|隱含移動賦值運算子|隱含 'operator==' 的三向比較運算子)|繼承建構函數}0%select{|函式模板| %3}1%select{| 具有不同的類別%diff{（期望$但具有$）|}5,6| 參數數量不同（期望 %5 但具有 %6）| 第%ordinal5個參數類型不匹配%diff{（期望$但具有$）|}6,7| 回傳類型不同%diff{（期望$但具有$）|}5,6| 具有不同的修飾詞（期望 %5 但發現 %6）| 具有不同的例外規格}4"
# 'candidate address cannot be taken because parameter %0 has pass_object_size attribute'
H9C284929AC5A: '無法取得候選地址，因為參數 %0 具有 pass_object_size 屬性'
# 'candidate constructor ignored: cannot be used to construct an object in address space %0'
H02A4FA176268: '忽略候選建構函式：無法用來在地址空間 %0 建構物件'
# 'candidate disabled: %0'
H7028C3991AD2: '候選被禁用：%0'
# 'candidate found by name lookup is %q0'
H25F5CFEAA3CA: '名稱搜尋找到的候選函數為 %q0'
# 'candidate function made ineligible by enable_if'
HF67E18BC374D: '因 enable_if 而無效的候選函數'
# 'candidate function with non-reversed arguments'
H8514B0198804: '參數順序未反轉的候選函數'
# 'candidate ignored: %select{not a function template|not a member of the enclosing %select{class template|namespace; did you mean to explicitly qualify the specialization?}1}0'
H46E51FE9BF5C: '候選被忽略：%select{非函數範型|非封裝 %select{類模板|命名空間的成員；是否要明確指定特殊化？}1}0'
# 'candidate template ignored: cannot deduce a type for %0 that would make %2 equal %1'
H7E4350C35AB8: '候選範本被忽略：無法推導 %0 的類型使其 %2 等於 %1'
# 'candidate template ignored: constraints not satisfied%0'
H6E9C2A6AF9DA: '候選範本被忽略：約束條件未滿足 %0'
# 'candidate template ignored: could not match %diff{$ against $|types}0,1'
HBFC6A5130527: '候選範本被忽略：無法將 %diff{$ 與 $ 匹配|類型}0,1'
# 'candidate template ignored: could not match %q0 against %q1'
H95615A85BC94: '候選範本被忽略：無法將 %q0 與 %q1 匹配'
# "candidate template ignored: couldn't infer template argument %0"
H0865F809FC7F: '候選範本被忽略：無法推導範本參數 %0'
# 'candidate template ignored: deduced %select{conflicting types|conflicting values|conflicting templates|packs of different lengths}0 for parameter %1%diff{ ($ vs. $)|}2,3'
HC96827B6C1DA: '候選範本被忽略：推導出參數 %1 的 %select{衝突類型|衝突值|衝突範本|長度不同之包}0%diff{（$ 與 $）|}2,3'
# 'candidate template ignored: deduced too few arguments for expanded pack %0; no argument for %ordinal1 expanded parameter in deduced argument pack %2'
HCCA72493BB47: '候選範本被忽略：推導出的擴展包 %0 參數過少；在推導參數包 %2 中，缺少 %ordinal1 個擴展參數的參數'
# 'candidate template ignored: deduced type %diff{$ of %select{|element of }4%ordinal0 parameter does not match adjusted type $ of %select{|element of }4argument|of %select{|element of }4%ordinal0 parameter does not match adjusted type of %select{|element of }4argument}1,2%3'
HF6006A393B95: '候選範本被忽略：推導類型 %diff{第 %ordinal0 個參數的 $（%select{|元素 }4）與參數的調整類型 $（%select{|元素 }4）不相符|第 %ordinal0 個參數的 %select{|元素 }4與參數的調整類型 %select{|元素 }4不相符}1,2%3'
# 'candidate template ignored: deduced values %diff{of conflicting types for parameter %0 (%1 of type $ vs. %3 of type $)|%1 and %3 of conflicting types for parameter %0}2,4'
H300B96CC7A66: '候選範本被忽略：推導出參數 %0 的值 %diff{具有衝突類型（%1 為類型 $ 對應 %3 為類型 $）|%1 和 %3 具有參數 %0 的衝突類型}2,4'
# 'candidate template ignored: disabled by %0%1'
H0A4EC193E9D6: '候選範本被忽略：被 %0%1 禁用'
# 'candidate template ignored: failed template argument deduction'
HF2D6EBE56EA1: '候選範本被忽略：範本參數推導失敗'
# 'candidate template ignored: invalid explicitly-specified argument for %ordinal0 template parameter'
H7C80ECA5E832: '候選範本被忽略：為第 %ordinal0 個範本參數指定的明確參數無效'
# 'candidate template ignored: invalid explicitly-specified argument for template parameter %0'
HEDC828688F33: '候選範本被忽略：為範本參數 %0 指定的明確參數無效'
# "candidate template ignored: requirement '%0' was not satisfied%1"
HB155E3417C9D: "候選範本被忽略：需求 '%0' 未滿足 %1"
# 'candidate template ignored: substitution exceeded maximum template instantiation depth'
H6065ACD0EE36: '候選模板被忽略：替代超過最大模板實體化深度'
# 'candidate template ignored: substitution failure%0%1'
HF32FE861D856: '候選模板被忽略：替代失敗 %0%1'
# 'candidate template ignored: target attributes do not match'
H8F2E4648A7AB: '候選模板被忽略：目標屬性不符合'
# "cannot %select{#include files|import headers}0 inside '#pragma clang arc_cf_code_audited'"
HE8C6864AFFBD: "無法在 '#pragma clang arc_cf_code_audited' 內 %select{#include 檔案|import headers}0"
# "cannot %select{#include files|import headers}0 inside '#pragma clang assume_nonnull'"
H5A02E21DB221: "無法在 '#pragma clang assume_nonnull' 內 %select{#include 檔案|import headers}0"
# 'cannot %select{access base class of|access derived class of|access field of|access array element of|ERROR|access real component of|access imaginary component of}0 pointer past the end of object'
HBEBB0813D273: '無法對超出物件結尾的指標 %select{存取基類|存取衍生類|存取成員|存取陣列元素|ERROR|存取實數部分|存取虛數部分}0'
# 'cannot %select{access base class of|access derived class of|access field of|access array element of|perform pointer arithmetic on|access real component of|access imaginary component of}0 null pointer'
H2E784B2C1B28: '無法對空指標 %select{存取基類|存取衍生類|存取成員|存取陣列元素|執行指標運算|存取實數部分|存取虛數部分}0'
# 'cannot %select{assign|return|throw|subscript}0 a WebAssembly table'
H1D574B1BA9C6: '無法對 WebAssembly 表進行 %select{指派|回傳|拋出|索引}0'
# 'cannot %select{capture|take address of}0 WebAssembly reference'
H1706BDA5F276: '無法取得 WebAssembly 參考的 %select{捕獲|位址}0'
# 'cannot %select{decrement|increment}0 expression of enum type %1'
H9709AF91935B: '無法 %select{遞減|遞增}0 枚舉類型 %1 的運算式'
# 'cannot %select{decrement|increment}1 value of type %0'
H7C6ED23E2E9F: '無法 %select{遞減|遞增}1 類型 %0 的值'
# 'cannot %select{form pointer to|form reference to|form array of|form function returning|use parentheses when declaring variable with}0 deduced class template specialization type'
HAF4CF818160D: '無法對推論的類模板專屬化類型 %select{形成指標|形成參考|形成陣列|形成函數回傳|在宣告變數時使用括號}0'
# 'cannot %select{throw|catch}0 a WebAssembly reference type'
H3CB66A7D1B81: '無法對 WebAssembly 參考類型 %select{拋出|捕獲}0'
# "cannot %select{use builtin operator '<=>'|default 'operator<=>'}1 because type '%0' was not found; include <compare>"
H40A5A6DFAC87: "無法%select{使用內建運算子 '<=>'|預設 'operator<=>' }1，因為類型 '%0' 未找到；請包含 <compare>"
# 'cannot %select{use type %1 for a function/method parameter|use type %1 for function/method return|default-initialize an object of type %1|declare an automatic variable of type %1|copy-initialize an object of type %1|assign to a variable of type %1|construct an automatic compound literal of type %1|capture a variable of type %1|cannot use volatile type %1 where it causes an lvalue-to-rvalue conversion}3 since it %select{contains|is}2 a union that is non-trivial to %select{default-initialize|destruct|copy}0'
H72F7777296D1: '無法 %select{使用類型 %1 做為函數/方法參數|使用類型 %1 做為函數/方法回傳類型|預設初始化類型 %1 的物件|宣告類型 %1 的自動變數|複製初始化類型 %1 的物件|指派給類型 %1 的變數|宣告類型 %1 的自動複合字面值|捕獲類型 %1 的變數|在需要 lvalue-to-rvalue 轉換時使用類型 %1}3，因為它 %select{包含|是}2 一個在 %select{預設初始化|析構|複製}0 時非平凡的聯合類型'
# 'cannot %select{||reinterpret_cast||C-style cast||}0 from member pointer type %1 to member pointer type %2 of different size'
H4DC29F600065: '無法 %select{||reinterpret_cast||C-style cast||}0 從成員指標類型 %1 轉換為不同大小的成員指標類型 %2'
# "cannot add 'abi_tag' attribute in a redeclaration"
H48F70104AB1E: "無法在重新宣告中新增 'abi_tag' 屬性"
# 'cannot add a default template argument to the definition of a member of a class template'
H770ED38EE4A2: '無法為類模板成員的定義新增預設範本參數'
# 'cannot allocate %select{function|reference}1 type %0 with new'
HA111D2195E5D: '無法使用 new 建立 %select{函數|引用}1 類型 %0 的記憶體'
# "cannot allocate array of 'auto'"
H63BE6FF3ACD1: "無法建立 'auto' 類型的陣列"
# "cannot allocate array; evaluated array bound %0 exceeds the limit (%1); use '-fconstexpr-steps' to increase this limit"
H786F30B07D61: "無法建立陣列；評估的陣列大小 %0 超過限制（%1）；使用 '-fconstexpr-steps' 參數提高此限制"
# 'cannot allocate array; evaluated array bound %0 is negative'
H5D0D0D0008CA: '無法建立陣列；評估的陣列大小 %0 為負數'
# 'cannot allocate array; evaluated array bound %0 is too large'
H7762F6A6D3EC: '無法建立陣列；評估的陣列大小 %0 過大'
# 'cannot allocate array; evaluated array bound %0 is too small to hold %1 explicitly initialized elements'
H33075FED0F6C: '無法建立陣列；評估的陣列大小 %0 過小，無法存放 %1 個明確初始化的元素'
# 'cannot allocate memory of %select{incomplete|function}0 type %1'
H1CE3476A2AA9: '無法建立 %select{不完整|函數}0 類型 %1 的記憶體'
# "cannot allocate untyped memory in a constant expression; use 'std::allocator<T>::allocate' to allocate memory of type 'T'"
H659085361859: "無法在常數運算式中分配無型別記憶體；使用 'std::allocator<T>::allocate' 來分配類型 'T' 的記憶體"
# "cannot apply AST actions to LLVM IR file '%0'"
HB65858D558EB: "無法將 AST 動作套用至 LLVM IR 檔案 '%0'"
# 'cannot apply asm label to %select{variable|function}0 after its first use'
H75A6849C042D: '無法在第一次使用後為 %select{變數|函數}0 套用組裝語言標籤'
# "cannot assign to 'self' in a class method"
HA56E4ED9D1F5: "無法在類別方法中對 'self' 進行指派"
# "cannot assign to 'self' outside of a method in the init family"
HC5091C795252: "不能在 init 系列方法之外將 'self' 賦值"
# 'cannot assign to a variable captured by copy in a non-mutable lambda'
H135A3A08A93B: '不能在非可變lambda中將透過複製捕獲的變數進行賦值'
# 'cannot assign to class object (%0 invalid)'
H25AF70C115F7: '無法將類別物件 (%0 錯誤) 賦值'
# "cannot assign to this %select{dictionary|array}1 because assigning method's 2nd parameter of type %0 is not an Objective-C pointer type"
H33D10E761543: '無法將此 %select{字典|陣列}1 賦值，因為指定方法的第二個參數型別 %0 不是 Objective-C 指標型別'
# 'cannot befriend target of using declaration'
H72752EB56616: '無法與using宣告的目標建立友元關係'
# 'cannot bind non-lvalue argument %0 to %select{|in}1out paramemter'
HD7C1DD47E42B: '無法將非左值參數 %0 綁定到 %select{|}1 out 參數'
# 'cannot build range expression with array function parameter %0 since parameter with array type %1 is treated as pointer type %2'
H882392B5B8E6: '無法建立陣列函式參數 %0 的區間運算式，因為陣列型別 %1 的參數會被視為指標型別 %2'
# "cannot call function '%1' while %0 '%2' is held"
HE0B68C2EF3F0: '持有 %0 %2 時無法呼叫函式 %1'
# 'cannot call operator __uuidof on a type with multiple GUIDs'
H6DB6EE36C688: '無法對具有多個GUID的類型呼叫__uuidof運算子'
# 'cannot call operator __uuidof on a type with no GUID'
HCAE7CA56FF69: '無法對無GUID的類型呼叫__uuidof運算子'
# 'cannot capture __autoreleasing variable in a %select{block|lambda by copy}0'
H9DA2D963C91D: '無法將__autoreleasing變數捕獲到 %select{區塊|複製方式的lambda}0'
# 'cannot cast %0 to %1 via virtual base %2'
H794ABE3B9398: '無法經由虛基類別 %2 將 %0 轉換為 %1'
# 'cannot cast %0 to its %select{private|protected}2 base class %1'
H7E4D1C189883: '無法將 %0 轉換為其 %select{私有|受保護}2 基類 %1'
# 'cannot cast %select{private|protected}2 base class %1 to %0'
HEB1FE12D1532: '無法將 %select{私有|受保護}2 基類 %1 轉換為 %0'
# 'cannot cast %select{to|from}0 a WebAssembly table'
H608D936A86AA: '無法將 %select{轉換至|從}0 WebAssembly table 轉換'
# "cannot cast 'super' (it isn't an expression)"
H77DA1D89D4EF: "無法轉換 'super'（它不是運算式）"
# "cannot cast an object of type %select{'nullptr_t' to %1|%1 to 'nullptr_t'}0"
H379020AFC623: "無法將類型 %select{'nullptr_t' 轉換為 %1|%1 轉換為 'nullptr_t'}0 的物件轉換"
# 'cannot cast from lvalue of type %1 to rvalue reference type %2; types are not compatible'
HD498E8671ADF: '無法將類型 %1 的 lvalue 轉換為類型 %2 的 rvalue 參考；類型不相容'
# 'cannot cast from rvalue of type %1 to rvalue reference type %2; types are not compatible'
H81F8D1E74E50: '無法將類型 %1 的 rvalue 轉換為類型 %2 的 rvalue 參考；類型不相容'
# 'cannot cast from type %1 to member pointer type %2'
HC0F42A4D9625: '無法將類型 %1 轉換為成員指標類型 %2'
# 'cannot cast from type %1 to pointer type %2'
H1C20AF9781FF: '無法將類型 %1 的物件轉換為指標類型 %2'
# "cannot cast non-zero value '%0' to 'event_t'"
HB63F6FC3F823: "無法將非零值 '%0' 轉換為 'event_t'"
# 'cannot cast object of dynamic type %0 to type %1'
H29A99B2195B9: '無法將動態類型 %0 的物件轉換為類型 %1'
# 'cannot catch %select{|reference to }0sizeless type %1'
HFDB51E9BFE05: '無法捕捉 %select{|引用 }0 未定義大小的類型 %1'
# 'cannot catch an Objective-C object by value'
HE53524ADBBC8: '無法按值捕捉 Objective-C 物件'
# 'cannot catch an exception thrown with @throw in C++ in the non-unified exception model'
HA5FD18981E9C: '無法在非統一例外處理模型中捕捉使用 @throw 在 C++ 中拋出的例外'
# 'cannot catch exceptions by rvalue reference'
H5BF423F821AB: '無法按 rvalue 參考捕捉例外'
# 'cannot catch incomplete type %0'
H712DCF7BC1DF: '無法捕獲不完整類型 %0'
# 'cannot catch pointer to incomplete type %0'
H555C8CE71019: '無法捕獲不完整類型 %0 的指標'
# 'cannot catch reference to incomplete type %0'
HAB26C8BE4E6D: '無法捕獲不完整類型 %0 的參考'
# 'cannot catch variably modified type %0'
H3E0D097A06D0: '無法捕捉變數長度修改的類型 %0'
# 'cannot combine GNU and %select{SVE|RVV}0 vectors in expression, result is ambiguous (%1 and %2)'
H6D9DAA9A57DC: '無法在表達式中混合 GNU 和 %select{SVE|RVV}0 向量，結果含糊 (%1 和 %2)'
# 'cannot combine fixed-length and sizeless %select{SVE|RVV}0 vectors in expression, result is ambiguous (%1 and %2)'
H3EDDFBE7A4DF: '無法在運算式中將固定長度和無大小的 %select{SVE|RVV}0 向量結合，結果含糊 (%1 和 %2)'
# "cannot combine with previous '%0' declaration specifier"
H4EE2F7A93C38: "無法與之前的 '%0' 声明说明符結合"
# "cannot combine with previous '%0' declaration specifier. '__vector' must be first"
H856686567DB2: "無法與之前的 '%0' 声明说明符結合。 '__vector' 必須放在最前面"
# 'cannot compile this %0 yet'
H395022428A23: '目前無法編譯此 %0'
# 'cannot compress debug sections (%0 not enabled)'
HB2DFAB48BA84: '無法壓縮除錯區段 (%0 未啟用)'
# 'cannot compute offset of bit-field %0'
H55C2FB73C827: '無法計算位段 %0 的偏移量'
# "cannot constant evaluate '%select{memcpy|memmove}0' between objects of incomplete type %1"
H474B41288CFB: "無法在不完整類型 %1 的物件之間進行 '%select{memcpy|memmove}0' 的常量評估"
# "cannot constant evaluate '%select{memcpy|memmove}0' between objects of non-trivially-copyable type %1"
H4AA44A4233D2: "無法在非純粹可複製類型 %1 的物件之間進行 '%select{memcpy|memmove}0' 的常量評估"
# "cannot constant evaluate '%select{memcpy|memmove}0' from object of type %1 to object of type %2"
H6FAB8AA1F441: "無法在類型 %1 的物件和類型 %2 的物件之間進行 '%select{memcpy|memmove}0' 的常量評估"
# 'cannot constant evaluate the result of adjusting alignment to %0'
H8F0F0485C85D: '無法評估調整對齊至 %0 的結果'
# 'cannot constant evaluate whether run-time alignment is at least %0'
H8DC5B278E189: '無法評估執行階段對齊是否至少為 %0'
# 'cannot construct object of type %0 with virtual base class in a constant expression'
H7DD1FDBBEF06: '無法在常量運算式中建立具有虛基類 %0 的物件'
# 'cannot convert %0 token to an identifier'
H18B9F6746EBF: '無法將 %0 令牌轉換為識別符'
# 'cannot convert %1 to %2 without a conversion operator'
H703415593D2A: '無法在沒有轉換運算子的情況下將 %1 轉換為 %2'
# 'cannot convert between %select{scalar|vector}0 type %1 and vector type %2 as implicit conversion would cause truncation'
HF046F296A9B0: '無法在隱式轉換時將 %select{純量|向量}0 類型 %1 和向量類型 %2 相互轉換，因截斷會導致資料遺失'
# 'cannot convert between vector and non-scalar values (%0 and %1)'
HD81F5D7E2B16: '無法在沒有明確轉換的情況下轉換不同類型的值 (%0 和 %1)'
# 'cannot convert between vector values of different size (%0 and %1)'
H8810EF643AA5: '無法轉換不同大小的向量值 (%0 和 %1)'
# 'cannot create __weak reference because the current deployment target does not support weak references'
H54D605FEB00B: '__weak 參考無法建立，因目前部署目標不支援弱參考'
# 'cannot create __weak reference in file using manual reference counting'
H98AD8AE899EB: '__weak 參考無法在使用手動引用計數的檔案中建立'
# 'cannot create a non-constant pointer to member function'
H909CEC9754E8: '無法建立非常量的成員函數指標'
# 'cannot create includes file for module %0: %1'
H521EA5757B62: '無法為模組 %0 建立包含檔： %1'
# 'cannot create object of function type %0'
HB6BCDD252F4D: '無法建立函數類型 %0 的物件'
# 'cannot declare a class template with no name'
H86275B9FD8C9: '無法宣告未命名的類別範型'
# 'cannot declare an explicit specialization in a friend'
H8E19851C2991: '無法在 friend 節點中宣告明確的特殊化'
# 'cannot declare class extension for %0 after class implementation'
H472ADAE23CEA: '無法在類別實作之後宣告 %0 的類別擴充'
# "cannot declare implementation of a class declared with the 'objc_class_stub' attribute"
H831B35F688CB: "無法宣告使用 'objc_class_stub' 屬性的類別實作"
# "cannot declare the namespace 'std' to be inline"
H1345EF64CB88: "無法宣告命名空間 'std' 為 inline"
# 'cannot declare variable inside @interface or @protocol'
H11D626BF5B37: '@interface 或 @protocol 內無法宣告變數'
# 'cannot decompose %select{private|protected}0 member %1 of %3'
HAF5B2F15564E: '無法分解 %select{私人|保護}0 成員 %1 的 %3'
# 'cannot decompose %select{union|non-class, non-array}1 type %2'
HD213477C2A3A: '無法分解 %select{聯合|非類別、非陣列}1 類型 %2'
# 'cannot decompose class type %0 because it has an anonymous %select{struct|union}1 member'
H687FA194A579: '無法分解類別型別 %0，因其具有匿名 %select{結構|聯合}1 成員'
# 'cannot decompose class type %1: %select{its base classes %2 and|both it and its base class}0 %3 have non-static data members'
HBC0288C04290: '無法分解類別型別 %1：%select{基類 %2 和|基類與自身}0 %3 具有非靜態資料成員'
# 'cannot decompose lambda closure type'
H3C6B1EAC26ED: '無法分解 lambda 關閉型別'
# 'cannot decompose members of ambiguous base class %1 of %0:%2'
HE08DBE349649: '無法分解基類 %1 在 %0:%2 的模稜兩可成員'
# 'cannot decompose members of inaccessible base class %1 of %0'
HA6ED46C6B298: '無法分解基類 %1 在 %0 的無法存取成員'
# "cannot decompose this type; 'std::tuple_element<%0>::type' does not name a type"
H4AD140BFCF3D: "無法分解此類型；'std::tuple_element<%0>::type' 並非有效型別"
# "cannot decompose this type; 'std::tuple_size<%0>::value' is not a valid integral constant expression"
HE140F3EE6033: "無法分解此類型；'std::tuple_size<%0>::value' 非有效整數常量運算式"
# 'cannot decrement expression of type bool'
H9DABD4A4074A: '無法遞減型別為 bool 的運算式'
# "cannot deduce 'decltype(auto)' from initializer list"
H0294CF60338E: "無法從初始化清單推導 'decltype(auto)'"
# 'cannot deduce actual type for %1 from %select{parenthesized|nested}0 initializer list'
H1C99EC9B7047: '無法從 %select{括號包圍|嵌套}0 初始化清單推導 %1 的實際類型'
# 'cannot deduce actual type for variable %0 with type %1 from initializer list'
HA7FCCDD3352E: '無法從初始化清單推導變數 %0 的實際型別 %1'
# 'cannot deduce implicit triple value for -Xopenmp-target, specify triple using -Xopenmp-target=<triple>'
HBB4FDAD01556: '無法推導 -Xopenmp-target 的隱含 triple 值，請使用 -Xopenmp-target=<triple> 指定 triple'
# 'cannot deduce lambda return type from initializer list'
HBF4499B07FAC: '無法從初始化清單推導 lambda 回傳型別'
# 'cannot deduce return type %0 for function with no return statements'
H4A0B0541DA05: '無法推導未包含回傳語句的函式回傳型別 %0'
# 'cannot deduce return type %0 from omitted return expression'
HF76745F04CDD: '無法從省略的回傳運算式推導回傳型別 %0'
# 'cannot deduce return type %0 from returned value of type %1'
HFF6A0873771C: '無法從回傳值類型 %1 推導回傳類型 %0'
# 'cannot deduce return type from initializer list'
HD33E533A8026: '無法從初始化清單推導回傳類型'
# 'cannot deduce template arguments for %0 from %1'
H59FFC4EE513D: '無法從 %1 推導 %0 的範型參數'
# 'cannot deduce type for lambda capture %0 from initializer list'
HD1B46B897454: '無法從初始化清單推導 lambda 捕獲 %0 的類型'
# 'cannot deduce type for lambda capture %0 from initializer of type %2'
H5BED86131FDB: '無法從類型 %2 的初始化式推導 lambda 捕獲 %0 的類型'
# 'cannot deduce type for lambda capture %1 from %select{parenthesized|nested}0 initializer list'
HBAF719ACD121: '無法從 %select{括號包圍|嵌套}0 初始化清單推導 lambda 捕獲 %1 的類型'
# 'cannot deduce type for variable %1 with type %2 from %select{parenthesized|nested}0 initializer list'
HDBF6BFDD94D3: '無法從 %select{括號包圍|嵌套}0 初始化清單推導變數 %1 的類型 %2'
# 'cannot deduce type of initializer list because std::initializer_list was not found; include <initializer_list>'
H61AB50323785: '無法推導初始化清單類型，因未找到 std::initializer_list；請包含 <initializer_list>'
# 'cannot define %select{category|class extension}0 for undefined class %1'
H075CA56C0949: '無法為未定義類別 %1 定義 %select{分類|類別擴充}0'
# 'cannot define a type in a friend declaration'
H90F602DED3B4: '無法在友元宣告中定義類型'
# 'cannot define friend function %0 in a local class definition; did you mean %3?'
H40B3F3B5FBB1: '無法在局部類別定義中宣告友元函數 %0；是否應使用 %3？'
# 'cannot define friend function in a local class definition'
HB60D03F3A5C5: '無法在局部類別定義中宣告友元函數'
# 'cannot define non-inline dllimport template specialization'
HF67617A49B06: '無法定義非內聯 dllimport 範型特殊化'
# 'cannot define or redeclare %0 here because namespace %1 does not enclose namespace %2'
HFA38E82744C2: '無法在此處定義 %0，因為命名空間 %1 不包含命名空間 %2'
# 'cannot define the implicit copy assignment operator for %0, because non-static %select{reference|const}1 member %2 cannot use copy assignment operator'
H50812469123A: '無法為 %0 定義隱含的複製賦值運算子，因為非靜態 %select{參考|const}1 成員 %2 無法使用複製賦值運算子'
# 'cannot delete expression of type %0'
H8F9B57A837EE: '無法刪除類型 %0 的運算式'
# "cannot delete expression with pointer-to-'void' type %0"
HCCFA093E9DE2: "無法刪除指標至 'void' 類型的運算式 %0"
# 'cannot delete pointer to incomplete type %0'
H7E32F7F5C2AD: '無法刪除指向不完整類型 %0 的指標'
# "cannot determine %0 architecture: %1; consider passing it via '%2'; environment variable CLANG_TOOLCHAIN_PROGRAM_TIMEOUT specifies the tool timeout (integer secs, <=0 is infinite)"
H9E1578DA83DB: "無法決定 %0 架構：%1；建議透過 '%2' 傳遞；環境變數 CLANG_TOOLCHAIN_PROGRAM_TIMEOUT 指定工具超時時間（整數秒，<=0 表示無限）"
# 'cannot determine allocated array size from initializer'
H3573086C6F39: '無法從初始化式推導已分配陣列大小'
# 'cannot determine number of elements for sizeless vectors in a constant expression'
HAFC6AFA63009: '無法在常量運算式中決定無大小向量的元素數量'
# 'cannot determine underlying type of incomplete enumeration type %0'
H486DE8FE7D9E: '無法取得不完整列舉類型 %0 的底層類型'
# 'cannot emit module %0: %select{size|mtime}1 must be explicitly specified for missing header file "%2"'
H4AFEE6C7D624: '無法發送模組 %0：%select{大小|修改時間}1 須明確指定遺失的標頭檔 "%2"'
# 'cannot evaluate call to virtual function in a constant expression in C++ standards before C++20'
HC06FC1196550: '無法在 C++20 之前標準中評估常量運算式中的虛函數呼叫'
# 'cannot evaluate this expression if rounding mode is dynamic'
HC673B661CF5A: '若舍入模式為動態時，無法評估此運算式'
# 'cannot export %0 as it is not at namespace scope'
H49EEB2061C19: '無法導出位於命名空間範圍外的 %0'
# 'cannot export redeclaration %0 here since the previous declaration %select{is not exported|has internal linkage|has module linkage}1'
H805545AFF107: '無法在此處重新導出 %0，因先前宣告%select{未被導出|具有內部連結|具有模組連結}1'
# "cannot find CUDA installation; provide its path via '--cuda-path', or pass '-nocudainc' to build without CUDA includes"
H483DC86F4594: "無法找到 CUDA 安裝路徑；請透過 '--cuda-path' 提供路徑，或透過 '-nocudainc' 參數跳過 CUDA 標頭檔"
# "cannot find HIP Standard Parallelism Acceleration library; provide it via '--hipstdpar-path'"
H20ABDE201926: "無法找到 HIP 並行加速函式庫；請透過 '--hipstdpar-path' 提供路徑"
# "cannot find HIP device library%select{| for %1}0; provide its path via '--hip-path' or '--hip-device-lib-path', or pass '-nogpulib' to build without HIP device library"
H74B6BE24033A: "無法找到HIP裝置函式庫 %select{| 的 %1}0；透過 '--hip-path' 或 '--hip-device-lib-path' 提供其路徑，或傳遞 '-nogpulib' 以不使用HIP裝置函式庫進行建置"
# "cannot find HIP runtime; provide its path via '--rocm-path', or pass '-nogpuinc' to build without HIP runtime"
H11EBFA045BE3: "無法找到 HIP 執行時間；請透過 '--rocm-path' 提供路徑，或透過 '-nogpuinc' 參數跳過 HIP 執行時間"
# "cannot find ROCm device library%select{| for %1| for ABI version %1}0; provide its path via '--rocm-path' or '--rocm-device-lib-path', or pass '-nogpulib' to build without ROCm device library"
H7B7F4A357272: "無法找到 ROCm 裝置函式庫 %select{| %1 的| ABI 版本 %1 的}0；請透過 '--rocm-path' 或 '--rocm-device-lib-path' 提供路徑，或透過 '-nogpulib' 參數跳過 ROCm 裝置函式庫"
# 'cannot find a valid user-defined mapper for type %0 with name %1'
H0907A5973C27: '無法為類型 %0 找到名稱 %1 的有效使用者定義映射器'
# "cannot find end ('%1') of expected %0"
H53A2AE90D9C0: "無法找到 %0 的結束符號 ('%1')"
# 'cannot find interface declaration for %0'
H7325D139C40F: '無法找到 %0 的介面宣告'
# 'cannot find interface declaration for %0, superclass of %1'
HDDF90FE7BE8F: '無法找到 %0（%1 的父類別）的介面宣告'
# 'cannot find interface declaration for %0, superclass of %1; did you mean %2?'
H691319D1E232: '無法找到 %0（%1 的父類別）的介面宣告；您是指 %2 吗？'
# 'cannot find interface declaration for %0; did you mean %1?'
H3FD5BD5869C6: '無法找到 %0 的介面宣告；您是指 %1 吗？'
# "cannot find libdevice for %0; provide path to different CUDA installation via '--cuda-path', or pass '-nocudalib' to build without linking with libdevice"
H9C8FBD27D916: "無法找到 %0 的 libdevice；透過 '--cuda-path' 提供其他 CUDA 安裝路徑，或傳遞 '-nocudalib' 以不連結 libdevice"
# 'cannot find protocol declaration for %0'
H8559765777E9: '無法找到 %0 的協定宣告'
# 'cannot find protocol declaration for %0; did you mean %1?'
H39967D7F0C23: '無法找到 %0 的協定宣告；您是指 %1 吗？'
# 'cannot find protocol definition for %0'
H30EC809C2E8C: '無法找到 %0 的協定定義'
# "cannot find re-exported %select{framework|library}0: '%1'"
HFF74F7CAAAC8: "無法找到重新轉 xuất的 %select{框架|函式庫}0：'%1'"
# "cannot find rocPrim, which is required by the HIP Standard Parallelism Acceleration library; provide it via '--hipstdpar-prim-path'"
H7420A8DBF79F: "無法找到由HIP標準平行化加速函式庫所需的 rocPrim；透過 '--hipstdpar-prim-path' 提供其路徑"
# "cannot find rocThrust, which is required by the HIP Standard Parallelism Acceleration library; provide it via '--hipstdpar-thrust-path'"
HF20DC196E1CB: "無法找到由HIP標準平行化加速函式庫所需的 rocThrust；透過 '--hipstdpar-thrust-path' 提供其路徑"
# "cannot find start ('{{') of expected %0"
H727EB43115FC: "無法找到 %0 的起始符號 ('{{')"
# "cannot find start of regex ('{{') in %0"
HD5BDA70A3617: "在 %0 中未找到 regex 起始符號 '{{'"
# 'cannot find suitable %select{getter|setter}0 for property %1'
H0F811370E791: '無法找到屬性 %1 的合適 %select{取得器|設定器}0'
# "cannot form %select{pointer to|reference to|array of}0 'decltype(auto)'"
H7F41F0A9CCC7: "無法形成 %select{指向|引用|陣列}0 'decltype(auto)'"
# 'cannot form a %select{pointer|reference}0 to a WebAssembly table'
H3C39E76E28BC: '無法建立 WebAssembly table 的 %select{指標|參考}0'
# 'cannot form a pointer-to-member to member %0 of reference type %1'
H45A1DB7A6AF3: '無法建立 %1 類別型別成員 %0 的指標'
# "cannot form a reference to 'void'"
H6E82068C4FE4: "無法建立 'void' 的參考"
# "cannot form member pointer of type %0 without '&' and class name"
HA98A1BC7CEC4: "無法建立類別名稱缺失且無 '&' 修飾的 %0 成員指標類型"
# 'cannot generate code for reduction on %select{|array section, which requires a }0variable length array'
H328E15AAC013: '無法為 %select{|陣列區段，需要使用 }0長度可變陣列進行約簡運算'
# 'cannot have both throw() and noexcept() clause on the same function'
H93A58AAAE480: '無法在同一個函數同時指定 throw() 和 noexcept() 子句'
# 'cannot implement a category for class %0 that is only visible via the Objective-C runtime'
H93EA111FC5EC: '無法為只能透過 Objective-C 執行階段存取的類別 %0 實現分類'
# 'cannot implement subclass %0 of a superclass %1 that is only visible via the Objective-C runtime'
H0C79ADD5940E: '無法為只能透過 Objective-C 執行階段存取的超類別 %1 實現子類別 %0'
# 'cannot import unsupported AST node %0'
H4E75F3A5019B: '無法匯入不受支援的 AST 節點 %0'
# 'cannot initialize %select{a variable|a parameter|template parameter|return object|statement expression result|an exception object|a member subobject|an array element|a new value|a value|a base class|a constructor delegation|a vector element|a block element|a block element|a complex element|a lambda capture|a compound literal initializer|a related result|a parameter of CF audited function|a structured binding|a member subobject}0 %diff{of type $ with an %select{rvalue|lvalue}2 of type $|with an %select{rvalue|lvalue}2 of incompatible type}1,3%select{|: different classes%diff{ ($ vs $)|}5,6|: different number of parameters (%5 vs %6)|: type mismatch at %ordinal5 parameter%diff{ ($ vs $)|}6,7|: different return type%diff{ ($ vs $)|}5,6|: different qualifiers (%5 vs %6)|: different exception specifications}4'
H5225AD7ABD6B: '無法將 %select{變數|參數|範型參數|回傳物件|語句運算式結果|例外物件|成員子物件|陣列元素|新值|值|基類|建構函數委派|向量元素|區塊元素|區塊元素|複數元素|lambda 捕獲|複合字面量初始化|相關結果|CF 認證函數的參數|結構化綁定|成員子物件}0 %diff{的類型 $ 初始化為 %select{rvalue|lvalue}2 類型 $|使用不相容類型的 %select{rvalue|lvalue}2 初始化}1,3%select{|: 不同類別%diff{ ($ vs $)|}5,6|: 參數個數不同 (%5 vs %6)|: 第 %ordinal5 個參數類型不同%diff{ ($ vs $)|}6,7|: 回傳類型不同%diff{ ($ vs $)|}5,6|: 存取修飾符不同 (%5 vs %6)|: 异常規範不同}4'
# 'cannot initialize %select{non-class|reference}0 type %1 with a parenthesized initializer list'
HE63727C8C08B: '無法用括號包裝的初始值清單初始化 %select{非類別|參考}0 類型 %1'
# 'cannot initialize Objective-C class type %0'
HA709360A8ABC: '無法初始化 Objective-C 類別型別 %0'
# 'cannot initialize array %diff{of type $ with array of type $|with different type of array}0,1'
HA759EFFA1CC7: '無法初始化陣列 %diff{以 $ 類型初始化 $ 類型陣列|陣列類型不同}0,1'
# 'cannot initialize array %diff{of type $ with non-constant array of type $|with different type of array}0,1'
HAEED299DACD1: '無法初始化陣列 %diff{以非固定 $ 類型初始化 $ 類型陣列|陣列類型不同}0,1'
# 'cannot initialize object parameter of type %0 with an expression of type %1'
H01F0C7FE2242: '無法將類型 %1 的運算式初始化類型 %0 的物件參數'
# 'cannot instantiate %0 yet'
H3C23130222AC: '目前無法實例化 %0'
# 'cannot jump from switch statement to this case label'
H0147E81C1C5E: '無法從 switch 語句跳轉至此 case 標籤'
# 'cannot jump from this %select{indirect|asm}0 goto statement to one of its possible targets'
HA7FDD21785F4: '無法從此 %select{間接|組合語言}0 goto 語句跳轉至其可能目標之一'
# 'cannot jump from this continue statement to the loop increment; jump bypasses initialization of loop condition variable'
HF65BBB33CB19: '此 continue 語句無法跳轉至迴圈增量部分；跳轉避開了迴圈條件變數的初始化'
# 'cannot jump from this goto statement to its label'
HF7AC509BA0D6: '此 goto 語句無法跳轉至其標籤'
# 'cannot jump from this goto statement to label %0 inside an inline assembly block'
HBD667F79ECB9: '此 goto 語句無法跳轉至內嵌組合語言區塊中的標籤 %0'
# "cannot link module '%0': %1"
H957779E89D24: "無法連結模組 '%0'： %1"
# 'cannot locate code-completion file %0'
H00AA0E96170A: '無法載入程式碼完成檔案 %0'
# 'cannot mangle fixed point literals yet'
H175F8CE0FB1D: '目前無法轉換固定點字面值的符號'
# 'cannot mangle this %0 %1 yet'
H50F33B0E4B4E: '目前無法轉換此 %0 %1'
# 'cannot mangle this %0 yet'
H1C98A95C714E: '目前無法轉換此 %0'
# 'cannot mangle this dependent fixed-length RVV vector type yet'
H01F50B3350B7: '目前無法轉換此依賴型固定長度 RVV 向量類型'
# 'cannot mangle this dependent fixed-length SVE vector type yet'
H53C22EA00769: '目前無法轉換此依賴型固定長度 SVE 向量類型'
# 'cannot mangle this dependent neon vector type yet'
H566B620CDB5E: '目前無法處理此依賴型 NEON 向量類型'
# 'cannot mangle this requires-expression containing a substitution failure'
H9EEE8BF3FF53: '無法處理此包含替代失敗的 requires 表達式'
# 'cannot mangle this unnamed union NTTP yet'
HC67F1942B567: '無法處理此未命名聯合的 NTTP'
# 'cannot mix packoffset elements with nonpackoffset elements in a cbuffer'
H5F5AED65EDDB: 'cbuffer 中不能混合 packoffset 元素與非 packoffset 元素'
# 'cannot mix positional and non-positional arguments in format string'
HC2203B0385F9: '格式字串中不能混合位置參數與非位置參數'
# 'cannot mix vectors and extended vectors in a vector conditional'
H0C69F5DF40B4: '向量條件運算式中不能同時使用向量與延伸向量'
# "cannot nest 'critical' regions having the same name %0"
HB0FDA4DB5B6B: "不能嵌套具有相同名稱 %0 的 'critical' 區域"
# "cannot open file '%0': %1"
H7B318395BD4F: "無法開啟檔案 '%0': %1"
# "cannot overload a member function %select{without a ref-qualifier|with ref-qualifier '&'|with ref-qualifier '&&'}0 with a member function %select{without a ref-qualifier|with ref-qualifier '&'|with ref-qualifier '&&'}1"
H3E720DF8A96F: "不能將具有 %select{未指定 ref-qualifier|指定 ref-qualifier '&'|指定 ref-qualifier '&&'}0 的成員函數與具有 %select{未指定 ref-qualifier|指定 ref-qualifier '&'|指定 ref-qualifier '&&'}1 的成員函數重載"
# 'cannot override a method that is declared direct by a superclass'
H8D083337F734: '不能覆寫由超類直接宣告的方法'
# 'cannot parenthesize the name of a method when forming a member pointer'
H733C76C89DE9: '形成成員指標時不能對方法名稱使用括號'
# 'cannot pass %select{expression of type %1|initializer list}0 to variadic %select{function|block|method|constructor}2'
H25763FEA732A: '無法將 %select{類型 %1 的運算式|初始化清單}0 傳遞至可變參數 %select{函數|區塊|方法|建構函數}2'
# 'cannot pass %select{expression of type %1|initializer list}0 to variadic %select{function|block|method|constructor}2; expected type from format string was %3'
H6A81C62CC358: '無法將%select{類型 %1 的運算式|初始值列表}0 傳遞給多態參數的%select{函數|區塊|方法|建構函數}2；格式字串的期望類型為 %3'
# 'cannot pass %select{non-POD|non-trivial}0 object of type %1 to variadic %select{function|block|method|constructor}2; expected type from format string was %3'
HB3C416B2C325: '無法將%select{非POD|非平凡}0 類型 %1 的物件傳遞給多態參數的%select{函數|區塊|方法|建構函數}2；格式字串的期望類型為 %3'
# 'cannot pass a pointer-to-member through register-constrained inline assembly parameter'
H1A2FFC7DC3D0: '無法透過受寄存器限制的內嵌組合語言參數傳遞成員指標'
# 'cannot pass bit-field as __auto_type initializer in C'
HC2EE224C8229: '在 C 語言中無法將位域用作 __auto_type 初始化式'
# 'cannot pass non-trivial C object of type %0 by value to variadic %select{function|block|method|constructor}1'
H2C5461696894: '無法將非平凡的C物件 %0 以值傳遞方式傳遞到可變長%select{函數|區塊|方法|建構函數}1'
# 'cannot pass object of %select{non-POD|non-trivial}0 type %1 through variadic %select{function|block|method|constructor}2; call will abort at runtime'
H03C685EEC43F: '無法將%select{非POD|非平凡}0類型 %1 的物件傳遞到可變長%select{函數|區塊|方法|建構函數}2；呼叫將在運行時中斷'
# 'cannot pass object with interface type %0 by value through variadic %select{function|block|method|constructor}1'
HFFB4BE108833: '無法將具有介面類型 %0 的物件以值傳遞方式傳遞到可變長%select{函數|區塊|方法|建構函數}1'
# 'cannot pass object with interface type %1 by value to variadic %select{function|block|method|constructor}2; expected type from format string was %3'
HFCF01B48F1C2: '無法以值方式將介面類型 %1 的物件傳遞給多態參數的%select{函數|區塊|方法|建構函數}2；格式字串的期望類型為 %3'
# "cannot pass undiscriminated type %0 to '__builtin_ptrauth_type_discriminator'"
HCF5D52D0F4BA: "無法將未指定類型 %0 傳遞到 '__builtin_ptrauth_type_discriminator'"
# 'cannot perform a tail call %select{from|to}0 a %select{constructor|destructor}1'
H92D6BE5E0D10: '無法對%select{從|到}0%select{建構函數|解構函數}1執行尾調用'
# 'cannot perform a tail call from this return statement'
HD566EFBB0F10: '無法從這個return語句執行尾調用'
# 'cannot perform a tail call to function%select{| %1}0 because it uses an incompatible calling convention'
H32E425482ACE: '無法對函數 %select{| %1}0 執行尾調用，因為它使用了不相容的呼叫約定'
# 'cannot perform a tail call to function%select{| %1}0 because its signature is incompatible with the calling function'
HB6791E3481C6: '無法對函數 %select{| %1}0 執行尾調用，因為其簽章與呼叫函數不相容'
# 'cannot perform atomic operation on a pointer to type %0: type has non-trivial ownership'
H33A9E57472E9: '無法對具有非平凡擁有權的 %0 類型指標執行原子操作'
# "cannot read configuration file '%0': %1"
H0AF7279B0969: "無法讀取配置文件 '%0'： %1"
# "cannot read randomize layout seed file '%0'"
H97BBD89360BC: "無法讀取隨機化佈局種子文件 '%0'"
# "cannot rebuild module '%0' as it is already finalized"
H80C2AA3A79E5: "無法重建已最終化的模組 '%0'"
# 'cannot redeclare builtin function %0'
HC3E811B65243: '無法重新宣告內建函數 %0'
# 'cannot refer to a block inside block'
HEC4D55F7E1FA: '無法在區塊內部引用另一個區塊'
# 'cannot refer to a non-static member from the handler of a %select{constructor|destructor}0 function try block'
H7C221E1899F1: '無法在%select{建構函數|解構函數}0的函數try區塊處理程序中引用非靜態成員'
# 'cannot refer to declaration of structure variable with flexible array member inside block'
H861E195F8EA8: '無法在區塊內引用具有彈性陣列成員的結構變數宣告'
# 'cannot refer to declaration with a variably modified type inside block'
H3ACCC42BDE35: '無法在區塊內引用具有可變長度類型的宣告'
# 'cannot refer to declaration with an array type inside block'
HBA9381EF3C23: '無法在區塊內引用具有陣列型別的宣告'
# 'cannot refer to element %0 of %select{array of %2 element%plural{1:|:s}2|non-array object}1 in a constant expression'
H97B7B294ED7C: '無法在常數運算式中引用%select{具有 %2 個元素的陣列 %plural{1:|s}2|非陣列物件}1的第 %0 項'
# "cannot refer to member %0 in %1 with '%select{.|->}2'"
HF25CD96D4723: "無法使用 '%select{.|->}2' 存取 %1 的成員 %0"
# "cannot refer to type member %0 in %1 with '%select{.|->}2'"
H982BCA02E9FD: "無法使用 '%select{.|->}2' 存取 %1 的類型成員 %0"
# 'cannot reference member of primary template because deduced class template specialization %0 is %select{instantiated from a partial|an explicit}1 specialization'
HF04074EDD691: '無法解析主要模板的成員，因為推導出的類模板特化 %0 是%select{部分特化|顯式}1特化'
# 'cannot resolve lock expression'
H9831838AB057: '無法解析鎖定運算式'
# 'cannot return from %0'
HDE7181BDC39D: '無法從 %0 返回'
# 'cannot set vtable pointer authentication on %0 which is a subclass of polymorphic type %1'
H8615F820D27E: '無法為多型類別 %1 的子類別 %0 啟用vtable指標驗證'
# 'cannot set vtable pointer authentication on an incomplete type %0'
H50389542B8AD: '無法設定不完整類型 %0 的虛函數表指標驗證'
# 'cannot set vtable pointer authentication on monomorphic type %0'
H365AD22227CA: '無法為單態類別 %0 啟用vtable指標驗證'
# "cannot specialize %select{|(with 'template<>') }0a member of an unspecialized template"
H21C951459621: "無法 %select{|(使用 'template<>') }0特化未特化的模板成員"
# 'cannot specialize a %select{dependent template|template template parameter}0'
HC5BFF931F55D: '無法特化 %select{依賴範本|範本範本參數}0'
# "cannot specify '%0%1' when compiling multiple source files"
HFD3172559132: "無法在編譯多個來源檔時指定 '%0%1'"
# "cannot specify '%1' along with '%0'"
H9F94923DAC7E: "無法同時指定 '%1' 與 '%0'"
# 'cannot specify -o when generating multiple output files'
HE249C344BFD2: '產生多個輸出檔時無法指定 -o 選項'
# 'cannot specify a default vtable pointer authentication %select{key|address discrimination mode|discriminator}0 with no default set'
H3A1B9264D760: '無法指定未設預設值的虛函數表指標驗證 %select{金鑰|位址區分模式|區分識別碼}0 預設值'
# "cannot specify any part of a return type in the declaration of a conversion function%select{; put the complete type after 'operator'|; use a typedef to declare a conversion to %1|; use an alias template to declare a conversion to %1|}0"
HAA40A3FFF9F4: '無法在轉換函數的宣告中指定返回類型的部分%select{；將完整的類型放在 operator 後面|；使用 typedef 宣告轉換至 %1|；使用 alias 範本宣告轉換至 %1|}0'
# 'cannot specify any part of a return type in the declaration of a deduction guide'
H390B6E7B14DB: '無法在推導指引的宣告中指定返回類型的部分'
# 'cannot specify deduction guide for %select{<error>|function template|variable template|alias template|template template parameter|concept|dependent template name}0 %1'
H8A234F5E78B1: '無法為 %select{<error>|函數範本|變數範本|別名範本|範本範本參數|概念|依賴範本名稱}0 %1 建立推導指引'
# "cannot specify parameter '%0' twice in the same '#embed' directive"
HD1DC8056B121: "無法在同一個 '#embed' 指令中重複指定參數 '%0'"
# 'cannot store matrix to read-only pointer'
H425886F44B36: '無法將矩陣存入唯讀指標'
# "cannot subclass a class that was declared with the 'objc_subclassing_restricted' attribute"
H5638A6FF93B7: "無法子類別化以 'objc_subclassing_restricted' 屬性宣告的類別"
# 'cannot synthesize property %0 with incomplete type %1'
H71A1173D4045: '無法合成具有不完整類型 %1 的屬性 %0'
# 'cannot synthesize weak property because the current deployment target does not support weak references'
H38DCEFEFA216: '無法合成虛弱屬性，因為目前的部署目標不支援虛弱引用'
# 'cannot synthesize weak property in file using manual reference counting'
H0734CFB3421A: '無法在使用手動引用計數的檔案中合成弱屬性'
# 'cannot take address of %select{immediate|consteval}2 %select{function|call operator of}1 %0 outside of an immediate invocation'
H530D63A21A7A: '無法在非立即調用外部取得 %select{立即|consteval}2 %select{函數|的呼叫運算子}1 %0 的地址'
# 'cannot take address of function %0 because it has one or more non-tautological enable_if conditions'
H23DB8FEDBD81: '無法取得具有非同義 enable_if 條件的函數 %0 的地址'
# 'cannot take address of function %0 because its constraints are not satisfied'
H4014F85A3BA5: '無法取得因約束未被滿足而無法解析的函數 %0 的地址'
# 'cannot take address of function %0 because parameter %1 has pass_object_size attribute'
H6872B0BADEA4: '無法取得具有 pass_object_size 屬性的函數 %0 的地址（參數 %1）'
# 'cannot take an address of a virtual member function if its return or argument types are incomplete'
HF3A5696A9EB7: '若虛成員函數的返回或參數類型為不完整類型，則無法取得其地址'
# 'cannot take the address of an rvalue of type %0'
H60F39E1B8F38: '無法取得類型 %0 的右值的地址'
# 'cannot template a using %select{directive|declaration}0'
H7E5220347031: '無法對 using %select{指令|宣告}0 進行模板化'
# 'cannot throw an object of abstract type %0'
H1AA71488C1EF: '無法拋出抽象類型 %0 的物件'
# 'cannot throw object of incomplete type %0'
H5A0A40D72DE8: '無法拋出不完整類型 %0 的物件'
# 'cannot throw object of sizeless type %0'
HA8B5689740C7: '無法拋出無大小類型 %0 的物件'
# 'cannot throw object of type %0 with a potentially-throwing destructor'
HC355469628A0: '無法拋出具有可能拋出例外的析構函數的類型 %0 的物件'
# 'cannot throw pointer to object of incomplete type %0'
H079B08EA2D25: '無法拋出指向不完整類型 %0 物件的指標'
# 'cannot type cast @selector expression'
H485C835C56BA: '無法對 @selector 表達式進行類型轉換'
# "cannot use %select{'auto'|<ERROR>|'__auto_type'}0 with %select{initializer list|array}1 in C"
HE2E4F9E6D620: "無法在C語言中將 %select{'auto'|<ERROR>|'__auto_type'}0 與%select{初始化列表|陣列}1一起使用"
# "cannot use %select{C++ 'try'|Objective-C '@try'}0 in the same function as SEH '__try'"
H455974313E2A: "無法在同一函數中同時使用 %select{C++ 'try'|Objective-C '@try'}0 和SEH '__try'"
# 'cannot use %select{dot|arrow}0 operator on a type'
H546BD63E07E0: '無法對類型使用%select{點|箭號}0運算符'
# "cannot use %select{unicode|wide}0 string literal in 'asm'"
HD3FDC775E04A: "無法在 'asm' 中使用 %select{Unicode|寬字符}0字元串字面量"
# "cannot use '%0' in %select{__device__|__global__|__host__|__host__ __device__}1 function"
H92A38A76E58C: "無法在 %select{__device__|__global__|__host__|__host__ __device__}1 函數中使用 '%0'"
# "cannot use '%0' output with multiple -arch options"
H1A59A50BBDD4: "無法在多個-arch選項下使用 '%0' 輸出"
# "cannot use '%0' with '__vector bool'"
HB212313EEF9A: "無法將 '%0' 與 '__vector bool' 一起使用"
# "cannot use '%0' with Objective-C exceptions disabled"
H633899DC0353: "在停用Objective-C例外時無法使用 '%0'"
# "cannot use '%0' with exceptions disabled"
H0F6B73A63960: "在停用例外處理時無法使用 '%0'"
# "cannot use '_Complex' with '__vector'"
HCFEB59CAC054: "'_Complex' 無法與 '__vector' 一起使用"
# "cannot use 'float' with '__vector'"
H8772A8A87C32: "'float' 無法與 '__vector' 一起使用"
# "cannot use 'long double' with '__vector'"
HD41E42BADD92: "'long double' 無法與 '__vector' 一起使用"
# "cannot use 'long' with '__vector'"
H0DD309217BB4: "'long' 無法與 '__vector' 一起使用"
# "cannot use SEH '__try' in a coroutine when C++ exceptions are enabled"
H0484D634DF37: "當C++例外啟用時，協程中無法使用SEH '__try'"
# "cannot use SEH '__try' in blocks, captured regions, or Obj-C method decls"
HAED8CA9442A3: "無法在區塊、捕獲範圍或Obj-C方法宣告中使用SEH '__try'"
# 'cannot use WebAssembly table as a function parameter'
H70C162E9FD41: '無法將WebAssembly表作為函式參數使用'
# 'cannot use a WebAssembly table within a branch of a conditional expression'
H4CC748CB0567: '無法在條件運算式中將WebAssembly表用於分支的其中一個選項'
# "cannot use a protocol declared 'objc_non_runtime_protocol' in a @protocol expression"
H22D18CFED6B9: "無法在@protocol表達式中使用宣告為 'objc_non_runtime_protocol' 的協定"
# "cannot use an empty string literal in 'asm'"
H9269C6D18FCF: "無法在 'asm' 中使用空字串字面量"
# 'cannot use dynamic_cast to convert from %0 to %1'
H5749CC5204B8: '無法使用dynamic_cast將 %0 轉換為 %1'
# 'cannot use incomplete type %0 as a range'
H779605C5A805: '無法使用不完整類型 %0 作為範圍'
# 'cannot use initializer list at the beginning of a macro argument'
HFB12BDAF6D6F: '無法在巨集參數開頭處使用初始化清單'
# 'cannot use type %0 as a range'
H9F644F56E9E3: '無法將類型 %0 用作範圍'
# 'cannot use type %0 as an iterator'
H45599EAAF2D8: '無法將類型 %0 用作迭代器'
# "cannot use type '%0' within '#pragma clang fp eval_method'; type is set according to the default eval method for the translation unit"
HD91CCA267FD1: "無法在 '#pragma clang fp eval_method' 中使用類型 '%0'；該類型根據翻譯單元的預設評估方法設定"
# 'cannot use variable %1 in collapsed imperfectly-nested loop %select{init|condition|increment}0 statement'
H40887EDB8E4A: '無法在塌陷的不完全嵌套迴圈%select{初始化|條件|遞增}0語句中使用變數 %1'
# 'cannot use variable-length arrays in %select{__device__|__global__|__host__|__host__ __device__}0 functions'
H33A7639314BD: '無法在 %select{__device__|__global__|__host__|__host__ __device__}0 函式中使用可變長度陣列'
# "cannot write file '%0': %1"
H57D82DC5A945: "無法寫入檔案 '%0'： %1"
# 'cannot yet @encode type %0'
H5CF1C5265DEE: '無法對此ABI編譯 %0'
# 'cannot yet compile %0 in this ABI'
H7B123038B924: '尚無法@encode類型 %0'
# 'cannot yet mangle %0 expression'
HA255CBB16444: '目前無法轉換符號名稱為 %0 的運算式'
# 'cannot yet mangle OpenACC Asterisk Size expression'
H2D31700B7C49: '目前無法轉換符號名稱為 OpenACC Asterisk Size 運算式'
# 'cannot yet mangle expression type %0'
HF4D45A826D3A: '目前無法轉換符號名稱為類型 %0 的運算式'
# 'capture %0 by %select{value|reference}1'
HD0ACA3E1F2BB: '以%select{值|引用}1方式捕獲 %0'
# 'capture default must be first'
HBD6F708D5FEC: '捕獲預設必須為第一個'
# 'capture host side class data member by this pointer in device or host device lambda function may result in invalid memory access if this pointer is not accessible on device side'
HA00333F0A82E: '在裝置或混合裝置lambda運算式中，透過this指標捕獲主機側類別資料成員可能导致裝置側無法存取this指標時發生記憶體存取異常'
# 'capture host variable %0 by reference in device or host device lambda function'
H4218AAE93F26: '在裝置或混合裝置lambda運算式中，以引用方式捕獲主機變數 %0'
# "capture of '*this' by copy is a C++17 extension"
H9C3948693023: '以值方式捕獲*this 是C++17擴充語法'
# "capture of variable '%0' as type %1 calls %select{private|protected}3 %select{default |copy |move |*ERROR* |*ERROR* |*ERROR* |}2constructor"
H6489D0544330: "以類型 %1 捕獲變數 '%0' 調用%select{私有|受保護}3 %select{預設 |複製 |移動 |*ERROR* |*ERROR* |*ERROR* |}2 建構函數"
# 'captured structured bindings are a C++20 extension'
HED60DD4C6A62: '捕獲結構化綁定是C++20擴充語法'
# 'captured structured bindings are incompatible with C++ standards before C++20'
HA1967A579A6F: '結構化綁定捕獲在C++20之前標準中不相容'
# 'capturing %0 strongly in this block is likely to lead to a retain cycle'
H495EA167E92F: '在此區塊中強制捕獲 %0 可能導致保留週期'
# 'capturing a structured binding is not yet supported in OpenMP'
H3DD2898A017E: 'OpenMP尚不支援捕獲結構化綁定'
# 'case ranges are a C2y extension'
H022E1C3F4097: 'case區間是C2y擴充語法'
# 'case ranges are a GNU extension'
H0ADA830DF441: 'case區間是GNU擴充語法'
# 'case ranges are incompatible with C standards before C2y'
H94092A9759CB: 'case範圍與C2y標準之前版本不相容'
# 'case value not in enumerated type %0'
H4866E4105494: '枚舉類型 %0 中不存在該case值'
# 'cast %diff{from $ to $ |}0,1converts to incompatible function type'
HAE54FE7B3C1C: '將%diff{從 $ 轉換為 $ |}0,1 轉換為不相容的函數類型'
# "cast between incompatible calling conventions '%0' and '%1'; calls through this pointer may abort at runtime"
HB4A395B83746: "在 '%0' 和 '%1' 間進行呼叫約定轉換；通過此指標的呼叫可能在執行階段中斷"
# 'cast between pointer-to-function and pointer-to-object is an extension'
H276B46B48964: '函數指標與物件指標轉換是擴展功能'
# 'cast between pointer-to-function and pointer-to-object is incompatible with C++98'
HD37948261117: '函數指標與物件指標轉換與C++98不相容'
# 'cast expression to void to silence warning'
H1D7499C23CFE: '將運算式轉換為void以消除警告'
# 'cast from %0 is not allowed in a constant expression %select{in C++ standards before C++2c|because the pointed object type %2 is not similar to the target type %3}1'
H542ED6DEC45B: '在C++標準C++2c之前%select{不允許在常量運算式中從 %0 轉換|因為所指物件類型 %2 與目標類型 %3 不相似}1'
# 'cast from %0 to %1 drops %select{const and volatile qualifiers|const qualifier|volatile qualifier}2'
HA3B03023258D: '從 %0 轉換為 %1 會丟失 %select{const和volatile修飾符|const修飾符|volatile修飾符}2'
# 'cast from %0 to %1 increases required alignment from %2 to %3'
H4A02BB23383F: '從 %0 轉換為 %1 會將必要對齊值從 %2 提升至 %3'
# 'cast from %0 to %1 must have all intermediate pointers const qualified to be safe'
HB7DFA89AF07B: '從 %0 轉換為 %1 必須使所有中間指標具有const修飾符才能確保安全'
# 'cast from function call of type %0 to non-matching type %1'
H8CE3B0EB72DC: '將類型 %0 的函數呼叫轉換為不匹配的類型 %1'
# 'cast from pointer to smaller type %2 loses information'
H60D928000B5D: '將指標轉換為較小的類型 %2 會導致資料遺失'
# 'cast of %select{Objective-C|block|C}0 pointer type %1 to %select{Objective-C|block|C}2 pointer type %3 cannot use %select{__bridge|__bridge_transfer|__bridge_retained}4'
H2F5F45B60576: '%select{Objective-C|區塊|C}0 指標類型 %1 轉換為 %select{Objective-C|區塊|C}2 指標類型 %3 不能使用 %select{__bridge|__bridge_transfer|__bridge_retained}4'
# 'cast of type %0 to %1 is deprecated; use sel_getName instead'
HC7428E5162D0: '將類型 %0 轉換為 %1 已被棄用；請改用sel_getName'
# 'cast one or both operands to int to silence this warning'
H49949EF0EEB5: '將一個或兩個運算元轉換為 int 以消除此警告'
# 'cast to %1 from smaller integer type %0'
HF29EC08A2098: '將較小整數類型 %0 轉換為 %1'
# 'cast to incomplete type %0'
HB29014F052FD: '轉換為不完整類型 %0'
# 'cast to smaller integer type %1 from %0'
H3EAB0F6AAF90: '將 %0 轉換為較小整數類型 %1'
# 'cast to union type from type %0 not present in union'
H26129A704E2A: '將未包含在共用體中的類型 %0 轉換為共用體類型'
# 'cast to union type is a GNU extension'
H07ADEAB6CDD8: '將共用體類型轉換為其他類型是 GNU 擴充功能'
# 'casting from randomized structure pointer type %0 to %1'
H760D7A3D8C24: '從隨機化結構指標類型 %0 轉換為 %1'
# "casting to dereferenceable pointer removes 'noderef' attribute"
H435CE65222D6: "將指標轉換為可解引用指標會移除 'noderef' 屬性"
# 'casting to type %0 is not allowed'
H05073823504A: '轉換為類型 %0 是不允許的'
# 'catch-all handler must come last'
H18423565AC35: '通用 catch 子句必須放在最後'
# 'category is implementing a method which will also be implemented by its primary class'
H12CCDCE8A3DF: '分類正在實作一個方法，該方法也將由其主類別實作'
# "chained comparison 'X %0 Y %1 Z' does not behave the same as a mathematical expression"
HF2403FB0CB87: "連鎖比較 'X %0 Y %1 Z' 的行為與數學運算式不同"
# 'change layout of basic blocks in a function'
HFA932943E87E: '改變函數中基本區塊的佈局'
# "change return type to 'int'"
H2DD08C8E9ADD: "將傳回類型改為 'int'"
# 'change size argument to be the size of the destination'
HC31A5632ABB1: '將大小參數改為目標的大小'
# 'change the argument to be the free space in the destination buffer minus the terminating null byte'
H66702CDAA7E2: '將引數改為目的地緩衝區的可用空間減去終結空字元'
# "change this ',' to a ';' to call %0"
H5A1EAB3B7F87: "將此 ',' 改為 ';' 以呼叫 %0"
# "change type of %0 to '%select{std::span' to preserve bounds information|std::array' to label it for hardening|std::span::iterator' to preserve bounds information}1%select{|, and change %2 to '%select{std::span|std::array|std::span::iterator}1' to propagate bounds information between them}3"
H1123F3B73559: "將 %0 的類型改為 '%select{std::span' 以保留界限資訊|std::array' 以標記為強化類型|std::span::iterator' 以保留界限資訊}1%select{|，並將 %2 改為 '%select{std::span|std::array|std::span::iterator}1' 以在它們之間傳遞界限資訊}3"
# "change type of %0 to '%select{std::span' to preserve bounds information|std::array' to label it for hardening|std::span::iterator' to preserve bounds information}1%select{|, and change %2 to safe types to make function %4 bounds-safe}3"
H9C76AEF6C221: "將 %0 的類型改為 '%select{std::span' 以保留界限資訊|std::array' 以標記為強化類型|std::span::iterator' 以保留界限資訊}1%select{|，並將 %2 改為安全類型以使函數 %4 具有界限安全}3"
# 'char is signed'
H28989E053B4F: 'char 是有符號的'
# 'char is unsigned'
H2C9C5C4D7121: 'char 是無符號的'
# "character '%0' cannot be specified by a universal character name"
H9FDECB7636A6: '通用字元名稱無法指定字元 "%0"'
# 'character <U+%0> not allowed %select{in|at the start of}1 an identifier'
H0604F74F1073: 'Unicode字元 <U+%0> %select{在|位於識別子開頭}1 不允許'
# 'character constant too long for its type'
H99E005D8F34A: '字元常數的長度超出其類型限制'
# 'character literal with user-defined suffix cannot be used here'
HB73A18549E7B: '具有自訂後綴的字元常數在此無法使用'
# 'character too large for enclosing character literal type'
HFC3FA51117BB: '字元過大而超出包圍字元常數類型的容量'
# 'characters names in Unicode escape sequences are sensitive to case and whitespaces'
H6FEF0F08A2BB: 'Unicode轉義序列中的字元名稱會區分大小寫且受空白影響'
# 'charizing operator #@ is a Microsoft extension'
H374F252BD0E9: '字元化運算子 #@ 是Microsoft擴充功能'
# 'check arguments and return values at function call boundaries'
H68B4A050C0B9: '在函數呼叫邊界處檢查引數與傳回值'
# "checker '%0' has no option called '%1'"
H473E877D384D: "檢查器 '%0' 沒有名為 '%1' 的選項"
# "checker cannot be enabled with analyzer option '%0' == %1"
H9705343670F8: "檢查器無法在分析器選項 '%0' == %1 下啟用"
# "checker plugin '%0' is not compatible with this version of the analyzer"
H6AAE762D0724: "檢查器插件 '%0' 不相容於本版分析器"
# 'chosen constructor is explicit in copy-initialization'
H0B94DB59D2D8: '選擇的建構子在複製初始化中是顯式宣告的'
# 'circular pointer delegation detected'
H16A98512E3BA: '偵測到循環指標委派'
# 'clang LLVM compiler'
HFB02B9C0A298: 'clang LLVM編譯器'
# 'clang-check options'
HEBD1BCAEB597: 'clang-check 選項'
# 'clang-diff options'
HC57563571B39: 'clang-diff 選項'
# 'clang-doc options'
H711FBA0260F1: 'clang-doc 選項'
# 'clang-extdefmapgen options'
HD98304B7C5E5: 'clang-extdefmapgen 選項'
# 'clang-move options'
H51D1273C1656: 'clang-move 選項'
# 'clang-offload-bundler options'
H2BBBC154A925: 'clang-offload-bundler 選項'
# 'clang-offload-packager options'
HBBA0DBA3D90F: 'clang-offload-packager 選項'
# 'clang-query options'
HEE4551CABF87: 'clang-query 選項'
# 'clang-rename could not find symbol %0'
H72B95322F623: 'clang-rename 無法找到符號 %0'
# 'clang-rename could not find symbol (offset %0)'
H9B2484C454C5: 'clang-rename 無法找到符號（偏移 %0）'
# 'clang-reorder-fields options'
HB5EDCC7DF359: 'clang-reorder-fields 選項'
# 'clang-tidy options'
H123FF2E74AC8: 'clang-tidy 選項'
# 'clangd compilation flags options'
H9BB98137F26A: 'clangd 編譯旗標選項'
# 'class %0 defined without specifying a base class'
H3A2FB228D84B: '類別 %0 在定義時未指定基底類別'
# 'class %0 has incompatible superclasses'
HAE8DDB1E1535: '類別 %0 具有不相容的超類別'
# 'class %0 previously declared with type parameters'
H5BCC48BDFD6B: '類別 %0 前次宣告時已指定類型參數'
# "class already marked '%0'"
HCB141E8798E7: '類別已標記為 "%0"'
# 'class extension has no primary class'
H14396A81AB6D: '類別擴充宣告未指定主要類別'
# 'class has %0 base %plural{1:class|:classes}0'
HD719F68B2E7D: '類別有 %0 個基底 %plural{1:類別|:類別}0'
# 'class has base type %0'
H55F5972959B4: '類別具有基底類別類型 %0'
# 'class implementation is declared here'
HFDD816FBE31D: '類別實作在此處宣告'
# 'class implementation may not have super class'
HF88305654764: '類別實作不可指定超類別'
# 'class is declared here'
H1CB72009FE78: '類別在此處宣告'
# 'class is incompatible with __weak references'
H5D4A2732A59E: '此類別與__weak 參考不相容'
# 'class member %0 cannot appear in capture list as it is not a variable'
HB01A6BF35CAF: '類別成員 %0 不能出現在捕獲清單中，因為它不是變數'
# "class member already marked '%0'"
H8651C68C3085: "類別成員已標記為 '%0'"
# 'class member cannot be redeclared'
H011ED139495E: '類別成員不能重新宣告'
# "class method %objcclass0 not found (return type defaults to 'id')"
HA1F101EC915B: "找不到 Objective-C 類別方法 %objcclass0（傳回類型預設為 'id'）"
# "class method %objcclass0 not found (return type defaults to 'id'); did you mean %objcclass2?"
H4EC4BD008AC8: "找不到 Objective-C 類別方法 %objcclass0（傳回類型預設為 'id'）；是否意指 %objcclass2？"
# 'class property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this category'
H70F68CFFF089: '類別屬性 %0 需要定義方法 %1 - 請使用 @dynamic 或在此分類中提供方法實作'
# 'class property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this class implementation'
HC6D0854C646B: '類別屬性 %0 需要定義方法 %1 - 請使用 @dynamic 或在此類別實作中提供方法實作'
# 'class template %0 was explicitly specialized here'
HAF7828F4534C: '類別模板 %0 已明確特化在此處'
# 'class template %0 was instantiated here'
H67A993394D9A: '類別模板 %0 已在此處實例化'
# 'class template argument deduction for %0 selected a deleted constructor'
H2F3153B3F0E2: '類別模板參數推導為 %0 選擇了已刪除的建構函數'
# 'class template argument deduction for %0 selected an explicit %select{constructor|deduction guide}1 for copy-list-initialization'
HC409A532BB3A: '類別模板參數推導為 %0 選擇了明確的 %select{建構函數|推導指引}1 供初始化清單初始化使用'
# 'class template argument deduction for alias templates is incompatible with C++ standards before C++20'
H0A109AC10809: '對別名模板進行類別模板參數推導與 C++20 之前的標準不相容'
# 'class template argument deduction is incompatible with C++ standards before C++17%select{|; for compatibility, use explicit type name %1}0'
HCFEDA0AEF7C1: '類別模板參數推導與 C++17 之前的標準不相容 %select{|；為保持相容性，請使用明確類型名稱 %1}0'
# 'class template partial specialization %0 cannot be redeclared'
HD6C67286FA78: '類別模板的部分特化 %0 不能重新宣告'
# "class with destructor marked '%select{final|sealed}0' cannot be inherited from"
H8F6FAE53F32D: "標記 '%select{final|sealed}0' 的具有析構函數之類別無法被繼承"
# 'class with specified objc_requires_property_definitions attribute is declared here'
H42C6E2F16E82: '指定 objc_requires_property_definitions 屬性的類別在此處宣告'
# 'cmse is not compatible with %select{RWPI|ROPI}0'
HC391A16C0EBD: 'cmse 不相容於 %select{RWPI|ROPI}0'
# "code model '%0' is not supported on this target"
HCF39144044A7: "代碼模型 '%0' 在此目標上不受支援"
# 'code snippets to measure'
HC114C78CBCD4: '要測量的程式碼片段'
# 'code will never be executed'
H2586D13FCD3D: '程式碼永遠不會執行'
# 'collect control flow for each function'
H88E591AFCC3E: '收集每個函數的控制流程'
# 'collection element of type %0 is not an Objective-C object'
H8FFDEDA7A274: '集合元素類型 %0 不是 Objective-C 物件'
# 'collection expression type %0 is a forward declaration'
HDDCD4086A7F8: '集合運算式類型 %0 是向前宣告'
# 'collection expression type %0 may not respond to %1'
H8F39224B1450: '集合運算式類型 %0 可能無法回應 %1'
# 'comma expressions are not allowed as indices in matrix subscript expressions'
H3F02FDCEC720: '矩陣索引運算式中的索引不允許使用逗號運算式'
# 'comma operator in operand of #if'
HDC042AF8F218: '在 #if 的操作數中使用逗號運算子'
# 'comma separating Objective-C messaging arguments'
HAB4747C7C927: 'Objective-C 消息參數中的逗號分隔符'
# 'comma-separated list of OpenMP offloading triples'
HB9DA81E6157C: '以逗號分隔的 OpenMP 離線載入 triples 清單'
# 'comma-separated list of opcodes to measure, by name'
HC296D61A5AC3: '以逗號分隔的要測量的機器碼名稱清單'
# 'comma-separated list of target architecture features'
H115643195B7E: '以逗號分隔的目標架構功能清單'
# 'command line argument'
H13C820D51A04: '命令列參數'
# 'commas at the end of enumerator lists are a C++11 extension'
H2EA69DF0ADB4: '枚舉清單結尾的逗號是C++11擴充功能'
# 'commas at the end of enumerator lists are a C99-specific feature'
H1F877ED68177: '枚舉清單結尾的逗號是C99特定功能'
# 'commas at the end of enumerator lists are incompatible with C++98'
H28609FC0503F: '枚舉清單結尾的逗號與C++98不相容'
# 'comparing a pointer to a null character constant; did you mean to compare to %select{NULL|(void *)0}0?'
H5D12051B65A0: '與空值字元常數指標比較；是否應比較 %select{NULL|(void *)0}0？'
# 'comparing floating point with == or != is unsafe'
H1DE5EF3912E1: '使用 == 或 != 與浮點數進行比較是不安全的'
# 'comparing with this %select{specifier|format string}0'
H0EA8BCD476F7: '與此 %select{指定項|格式字串}0 進行比較'
# "comparison against address of weak declaration '%0' can only be performed at runtime"
H3C6EE2D92685: "與弱宣告 '%0' 的位址進行比較只能在執行階段進行"
# "comparison against opaque constant address '%0' can only be performed at runtime"
HAC7288F66309: "與不明確常數位址 '%0' 的比較只能在執行階段進行"
# "comparison against pointer '%0' that points past the end of a complete object has unspecified value"
H3D15A3D98DF0: "與指向完整物件末尾後的指標 '%0' 進行比較會產生未指定值"
# 'comparison against pointer to weak member %q0 can only be performed at runtime'
HFCA39B812783: '與指向弱成員 %q0 的指標進行比較只能在執行階段進行'
# 'comparison between NULL and non-pointer %select{(%1 and NULL)|(NULL and %1)}0'
H20F85EBECAC2: 'NULL與非指標類型進行比較 (%select{(NULL 和 %1)|(%1 和 NULL)}0)'
# 'comparison between pointer and integer (%0 and %1)'
H9205163E9BD4: '指標與整數（%0 和 %1）之間的比較'
# "comparison between pointers to unrelated objects '%0' and '%1' has unspecified value"
H722AC288816C: "未相關物件的指標 '%0' 與 '%1' 之間的比較結果未指定"
# "comparison between two arrays compare their addresses and will be deprecated in c++20; to compare array addresses, use unary '+' to decay operands to pointers"
H5D551E6212F9: "兩個陣列的比較會比較其位址，並將在C++20中被棄用；如需比較陣列位址，請使用一元 '+' 運算子使操作數衰減為指標"
# "comparison between two arrays is deprecated; to compare array addresses, use unary '+' to decay operands to pointers"
H4D3F55AAB37F: "兩個陣列的比較已被棄用；如需比較陣列位址，請使用一元 '+' 運算子使操作數衰減為指標"
# "comparison between two arrays is ill-formed in C++26; to compare array addresses, use unary '+' to decay operands to pointers"
H20B4EE22A6C2: "C++26中兩個陣列的比較不符合語法規範；如需比較陣列位址，請使用一元 '+' 運算子使操作數衰減為指標"
# "comparison of %select{address of|function|array}0 '%1' %select{not |}2equal to a null pointer is always %select{true|false}2"
H61B7557646A7: "與空指標的 %select{地址的|函數的|陣列的}0 '%1' %select{不|}2 比較始終為 %select{true|false}2"
# 'comparison of address of base class subobject %0 of class %1 to field %2 has unspecified value'
HCEA4BEB9DFF0: '基類子物件 %0（類別 %1）與成員 %2 的地址比較值未指定'
# 'comparison of address of fields %0 and %2 of %4 with differing access specifiers (%1 vs %3) has unspecified value'
H30BB5DCF7738: '具有不同存取修飾符（%1 vs %3）的 %4 的成員 %0 和 %2 地址比較結果未指定'
# 'comparison of addresses of potentially overlapping literals has unspecified value'
H59EF9C14B9AF: '重疊文字的地址比較結果未指定'
# 'comparison of addresses of subobjects of different base classes has unspecified value'
HA10192E66EB6: '不同基類子物件的地址比較結果未指定'
# 'comparison of different enumeration types in switch statement%diff{ ($ and $)|}0,1'
H820D2D4F7522: 'switch 陳述式中的不同列舉型別比較%diff{（$ 和 $）|}0,1'
# 'comparison of distinct block types%diff{ ($ and $)|}0,1'
HA2CFC62DE473: '不同類型的區塊比較%diff{（$ 和 $）|}0,1'
# 'comparison of distinct pointer types%diff{ ($ and $)|}0,1'
H1D24D97A54FF: '不同類型的指標比較%diff{（$ 和 $）|}0,1'
# 'comparison of integers of different signs: %0 and %1'
H8C3AA027FA1B: '不同符號類型的整數比較：%0 和 %1'
# "comparison of nonnull %select{function call|parameter}0 '%1' %select{not |}2equal to a null pointer is '%select{true|false}2' on first encounter"
H9EDFDB49F3E3: "非空 %select{函數呼叫|參數}0 '%1' %select{不|}2 與空指標的比較值在首次執行時為 %select{true|false}2"
# "comparison of numeric address '%0' with pointer '%1' can only be performed at runtime"
HFBF28443EB32: '數值地址 %0 與指標 %1 的比較只能在執行階段進行'
# 'comparison of pointer to virtual member function %0 has unspecified value'
HDF5F345093AE: '虛成員函數 %0 的指標比較值未指定'
# "comparison of pointers '%0' and '%1' to unrelated zero-sized objects"
H0C0F9C2F76E9: '無關零大小物件的指標 %0 和 %1 比較'
# 'comparison operator template cannot be defaulted'
HC75525ADCB07: '比較運算符模板無法預設'
# "compatibility_version does not match: '%0' (provided) vs '%1' (found)"
H96AD79FF790D: "相容性版本不一致：'%0'（指定值）與 '%1'（實際值）"
# 'compatible type %0 specified here'
HA0D702990A9A: '兼容類型 %0 已在此處指定'
# "compilation database '%0' could not be opened: %1"
H55D78247B7D8: "無法開啟編譯資料庫 '%0'：%1"
# 'compile time floating point arithmetic suppressed in strict evaluation modes'
H1CBDE348A919: '嚴格求值模式下會抑制編譯時間浮點運算'
# 'compiler has implicitly changed method %0 return type'
HA0BE2730FEEE: '編譯器已隱式更改方法 %0 的返回類型'
# 'completion handler is called twice'
HA50FDB30A90B: '完成處理程序被調用兩次'
# 'completion handler is never %select{used|called}1 when %select{taking true branch|taking false branch|handling this case|none of the cases applies|entering the loop|skipping the loop|taking one of the branches}2'
HF3977C617098: '完成處理程序在%select{執行真分支時|執行假分支時|處理此情況時|所有情況皆不適用時|進入迴圈時|跳過迴圈時|執行其中一個分支時}2%select{未被使用|未被調用}1'
# 'complex initialization specifying real and imaginary components is an extension'
H4D2B224EF174: '指定實數與虛數分量的複數初始化是擴充功能'
# 'complex integer types are a GNU extension'
H69724ED89FCA: '複數整數類型是 GNU 擴充功能'
# 'complex numbers are an extension in a freestanding C99 implementation'
HC53143A84579: '在自由-standing C99 實作中複數是擴充功能'
# 'compound binary operator not supported, only +=, *=, -=, /=, &=, ^=, |=, <<=, or >>= are permitted'
H7DD0E2130464: '複合二元運算子未被支援，僅允許 +=, *=, -=, /=, &=, ^=, |=, <<= 或 >>='
# 'compound literal cannot be of variable-length array type'
H35B29277CD5B: '複合字面量不能是變數長度陣列類型'
# 'compound literal in function scope may not be qualified with an address space'
H5D92A895F54C: '函式作用域中的複合字面量不能以位址空間修飾符標示'
# 'compound literals are a C99-specific feature'
H89109EF1C578: '複合字面量是 C99 特定功能'
# 'concatenated NSString literal for an NSArray expression - possibly missing a comma'
H05B938722790: 'NSArray 表達式中的 NSString 字面量串接 - 可能遺漏逗號'
# 'concept cannot have associated constraints'
H2D3AA7366D73: '概念不可具有關聯限制'
# 'concept declarations may only appear in global or namespace scope'
HC471DCAA93F1: '概念宣告只能出現在全域或命名空間作用域'
# 'concept named in type constraint is not a type concept'
H745ADE930837: '類型限制中命名的觀念不是類型概念'
# 'concept template parameter list must have at least one parameter; explicit specialization of concepts is not allowed'
HBDA562F258A9: '概念範型參數清單必須至少有一個參數；顯式特殊化觀念不被允許'
# "condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', %select{or '>='|'>=', or '!='}0) of loop variable %1"
H8BF46A7D7B10: "OpenMP for 迴圈條件必須是循環變數 %1 的關係比較 ('<', '<=', '>', %select{或 '>='|'>=', 或 '!='}0)"
# 'conditional expression is ambiguous; %diff{$ and $|types}0,1 can be converted to several common types'
H9909B5566589: '條件運算式的類型含糊；%diff{$ 和 $|類型}0,1 可轉換為多個共同類型'
# 'conditional expression is ambiguous; %diff{$ can be converted to $ and vice versa|types can be convert to each other}0,1'
HD6EF4047D3B6: '條件運算式的類型含糊；%diff{$ 可轉換為 $ 且反向亦然|類型可互相轉換}0,1'
# "configuration file '%0' cannot be found"
HF43B1D62E529: "無法找到設定檔 '%0'"
# "configuration file '%0' cannot be opened: %1"
H91238BB29F2B: "無法開啟設定檔 '%0'：%1"
# 'configuration macros are only allowed in top-level modules'
HC1EFBD1A6AB2: '設定宏僅允許在頂層模組中使用'
# 'conflicting %0 here'
H178724C0754B: '這裡有衝突的 %0'
# 'conflicting __device__ function declared here'
H6D42767A98E2: '這裡宣告了衝突的 __device__ 函數'
# 'conflicting address space qualifiers are provided between types %0 and %1'
HA444D7C677AE: '類型 %0 和 %1 提供了衝突的位址空間限定詞'
# 'conflicting asm label'
H08C5ACC499B8: '衝突的-inline 汇編標籤'
# 'conflicting attribute is here'
HB210D5E7919C: '衝突的屬性在此處'
# 'conflicting attributes %0 are ignored'
H43DE73EC415F: '衝突的屬性 %0 會被忽略'
# "conflicting attributes for state '%0'"
H30B7C9BA9F57: "狀態 '%0' 有衝突的屬性"
# 'conflicting code segment specifiers'
HF81F9823233E: '衝突的程式區段指定項'
# 'conflicting declaration'
H9D2B5D5AA66E: '衝突的宣告'
# 'conflicting deduction %diff{$ against $|types}0,1 for parameter'
H0919F4EB4F97: '參數的推論結果%diff{ $ 和 $ 相互衝突|類型}0,1 有衝突'
# "conflicting deployment targets, both '%0' and '%1' are present in environment"
H8F50D7638091: "衝突的部署目標，環境中同時存在 '%0' 和 '%1'"
# 'conflicting distributed object modifiers on parameter type in declaration of %0'
H4CB94BB5639A: '宣告 %0 的參數類型上具有衝突的分散物件修飾符'
# 'conflicting distributed object modifiers on parameter type in implementation of %0'
HA9E88E86F6C2: '實作 %0 的參數類型上具有衝突的分散物件修飾符'
# 'conflicting distributed object modifiers on return type in declaration of %0'
HBE23CBB42FFE: '宣告 %0 的回傳類型上具有衝突的分散物件修飾符'
# 'conflicting distributed object modifiers on return type in implementation of %0'
HBB60CEE9C2B2: '實作 %0 的回傳類型上具有衝突的分散物件修飾符'
# 'conflicting instance variable names: %0 vs %1'
H088E6A0E59D6: '衝突的實體變數名稱：%0 與 %1'
# 'conflicting loop attribute %0'
H69465530AFA7: '衝突的迴圈屬性 %0'
# 'conflicting nullability specifier on parameter types, %0 conflicts with existing specifier %1'
H11AC0D03E320: '參數類型上的空指標性質衝突：%0 與現有規範 %1 互相衝突'
# 'conflicting nullability specifier on return types, %0 conflicts with existing specifier %1'
H9D01BC58F478: '回傳類型上的空指標性質衝突：%0 與現有規範 %1 互相衝突'
# "conflicting option '-fcoro-aligned-allocation' and '-fno-aligned-allocation'"
HD53AB264ABE6: "選項衝突 '-fcoro-aligned-allocation' 與 '-fno-aligned-allocation'"
# 'conflicting parameter qualifier %0 on parameter %1'
HC7B786535E39: '參數 %1 上具有衝突的資格規範 %0'
# 'conflicting parameter types in declaration of %0%diff{: $ vs $|}1,2'
HCBD5D6ED758A: '宣告 %0 的參數類型衝突%diff{：$ 與 $|}1,2'
# 'conflicting parameter types in declaration of %0: %1 vs %2'
HF405BA99A067: '宣告 %0 的參數類型衝突：%1 與 %2'
# 'conflicting parameter types in implementation of %0%diff{: $ vs $|}1,2'
H64F50A39ECB1: '實作 %0 的參數類型衝突%diff{：$ 與 $|}1,2'
# 'conflicting parameter types in implementation of %0: %1 vs %2'
HC0C8356B7475: '實作 %0 的參數類型衝突：%1 與 %2'
# 'conflicting pass_object_size attributes on parameters'
H99CE421CA443: '參數上的 pass_object_size 屬性相衝突'
# 'conflicting prototype is here'
HF896EFD79698: '相衝突的原型在此處'
# "conflicting re-export of module '%0' as '%1' or '%2'"
H8B0F3A29C0A1: "模組 '%0' 的重新導出名稱衝突（'%1' 或 '%2'）"
# 'conflicting return type in declaration of %0%diff{: $ vs $|}1,2'
H2BB3153B6C50: '函數 %0 的宣告返回類型衝突%diff{：$ vs $|}1,2'
# 'conflicting return type in declaration of %0: %1 vs %2'
H5D783A189DCF: '函數 %0 的宣告返回類型衝突：%1 vs %2'
# 'conflicting return type in implementation of %0%diff{: $ vs $|}1,2'
HEB354C372ED1: '函數 %0 實作的返回類型衝突%diff{：$ vs $|}1,2'
# 'conflicting return type in implementation of %0: %1 vs %2'
H5C54E8625E6A: '函數 %0 實作的返回類型衝突：%1 vs %2'
# 'conflicting super class name %0'
HF493EF2E1E41: '超類別名稱 %0 重複定義'
# 'conflicting types for %0'
H5E0475C2D7BC: '符號 %0 的類型定義衝突'
# 'conflicting types for alias %0'
HCE7DAE70AA85: '符號 %0 的別名類型定義衝突'
# 'conflicting variadic declaration of method and its implementation'
H2A0A12EA2AF3: '方法的可變參數宣告與實作不一致'
# 'conformance of forward class %0 to protocol %1 cannot be confirmed'
H978A4E78BB8C: '前向類別 %0 對協定 %1 的符合無法驗證'
# "consecutive right angle brackets are incompatible with C++98 (use '> >')"
H77515E521F08: "連續右尖括號不符合C++98語法（請使用 '> >'）"
# 'conservative handling of inline assembly'
H316430B34522: '-inline assembly- 的保守處理'
# "consider adding '%0' to the header search path"
HCE15ED850DE4: "建議將 '%0' 加入包含路徑"
# "consider defining %0 with the '%1' calling convention"
H6A4F6FD30F2D: "建議以 '%1' 呼叫約定定義 %0"
# 'consider making the bit-field type %select{unsigned|signed}0'
HDAE81431A685: '建議將位段類型定義為%select{無符號|有符號}0'
# "consider using __builtin_trap() or qualifying pointer with 'volatile'"
H002E765592F2: '建議使用 __builtin_trap() 或以 volatile 修飾指標'
# 'consider using vld1_%0%1() to initialize a vector from memory, or vcreate_%0%1() to initialize from an integer constant'
H3E54619F1458: '建議使用 vld1_%0%1() 從記憶體初始化向量，或使用 vcreate_%0%1() 從整數常數初始化'
# 'consider using vld1q_%0%1() to initialize a vector from memory, or vcombine_%0%1(vcreate_%0%1(), vcreate_%0%1()) to initialize from integer constants'
H0B91FFD90BE8: '建議使用 vld1q_%0%1() 從記憶體初始化向量，或使用 vcombine_%0%1(vcreate_%0%1(), vcreate_%0%1()) 從整數常數初始化'
# 'const variable cannot be emitted on device side due to dynamic initialization'
H2D4E40F2FA4A: '因動態初始化，const 變數無法在裝置側發射'
# 'const-qualified list item cannot be %0'
HABDF81BBC813: 'const限定的清單項目無法 %0'
# 'const-qualified variable cannot be %0'
H02E8DDC8D310: 'const限定的變數無法 %0'
# 'const-qualified variable without mutable fields cannot be %0'
HF38DA802B6DD: '無可變字段的const限定變數無法 %0'
# 'constant evaluation of %0 between arrays of types %1 and %2 is not supported; only arrays of narrow character types can be compared'
H42EAC15FC487: '類型 %1 和 %2 的陣列間 %0 的常數運算式評估不支援；僅支援窄字符類型陣列的比較'
# 'constant evaluation of %0 on array of type %1 is not supported; only arrays of narrow character types can be searched'
HCF9A8296188E: '類型 %1 的陣列上 %0 的常數運算式評估不支援；僅支援窄字符類型陣列的搜尋'
# 'constant expression evaluates to %0 which cannot be narrowed to type %1'
HE08100927247: '常數運算式評估結果 %0 無法窄化為類型 %1'
# 'constant expression evaluates to %0 which cannot be narrowed to type %1 in C++11'
H3A70E9ED4BE6: 'C++11 中常數運算式評估結果 %0 無法窄化為類型 %1'
# 'consteval function %0 cannot override a non-consteval function'
HD9788F98961F: 'consteval 函數 %0 無法覆寫非 consteval 函數'
# 'consteval if is a C++23 extension'
H32DA4F52DDFE: 'consteval if 是 C++23 的擴充功能'
# 'consteval if is always true in an %select{unevaluated|immediate}0 context'
HFA38139DBCC5: 'consteval if 在 %select{未求值|立即}0 上下文中始終為 true'
# 'consteval if is incompatible with C++ standards before C++23'
H3BF3B6976984: 'consteval if 不相容於 C++23 之前的標準'
# 'constexpr %select{member function|constructor}0 not allowed in %select{struct|interface|class}1 with virtual base %plural{1:class|:classes}2'
HA87030D3447E: '含虛基 %plural{1:類別|:類別}2 的 %select{struct|interface|class}1 不允許 constexpr %select{成員函式|建構子}0'
# 'constexpr bit cast involving type %0 is not yet supported'
H93DC3AD734F6: '涉及類型 %0 的 constexpr 位元轉換尚未支援'
# 'constexpr bit_cast involving bit-field is not yet supported'
HCF05A23F6C40: '涉及位域的 constexpr bit_cast 尚未支援'
# 'constexpr constructor that does not initialize all members is a C++20 extension'
H6D6AAEF0CE01: '未初始化所有成員的 constexpr 建構子是 C++20 擴展'
# 'constexpr constructor that does not initialize all members is incompatible with C++ standards before C++20'
H6CD8A3688EC0: '未初始化所有成員的 constexpr 建構子不相容於 C++20 之前的標準'
# 'constexpr evaluation exceeded maximum depth of %0 calls'
H71A1AF77C8D7: 'constexpr 評估超過 %0 呼叫層級的上限'
# 'constexpr evaluation hit maximum call limit'
H2D336AD5FC66: 'constexpr 評估觸及呼叫次數上限'
# 'constexpr evaluation hit maximum heap allocation limit'
HEA6F0C77C92E: 'constexpr 評估觸及堆積分配上限'
# 'constexpr evaluation hit maximum step limit; possible infinite loop?'
H3A9C6A5C602B: 'constexpr 評估觸及執行步數上限；可能為無限迴圈？'
# 'constexpr function %0 without __host__ or __device__ attributes cannot overload __device__ function with the same signature; add a __host__ attribute, or build with -fno-cuda-host-device-constexpr'
HAF2225A9BAA0: '無 __host__ 或 __device__ 屬性的 constexpr 函式 %0 無法與相同簽章的 __device__ 函式重載；請新增 __host__ 屬性，或以 -fno-cuda-host-device-constexpr 編譯'
# 'constexpr function with no return statements is incompatible with C++ standards before C++14'
H60A27D48D081: '無回傳語句的 constexpr 函式不相容於 C++14 之前的標準'
# 'constexpr if condition is not a constant expression'
H9AC357BF4F5E: 'constexpr if 條件非常量運算式'
# 'constexpr if is a C++17 extension'
H8C78EE861C25: 'constexpr if 是 C++17 擴展'
# 'constexpr if is incompatible with C++ standards before C++17'
H518345725A13: "'constexpr if' 與C++17之前版本標準不相容"
# 'constexpr initializer evaluates to %0 which is not exactly representable in type %1'
HFD7668DF8CE8: "'constexpr' 初始化運算式結果為 %0，無法精確表示為類型 %1"
# 'constexpr initializer for type %0 is of type %1'
H57EA50C1B712: "類型 %0 的 'constexpr' 初始化運算式具有類型 %1"
# 'constexpr on lambda expressions is incompatible with C++ standards before C++17'
H2F64715F9E19: "lambda運算式的 'constexpr' 與C++17之前版本標準不相容"
# 'constexpr pointer initializer is not null'
HA90F435C9DCD: "'constexpr' 指標初始化式不是null"
# 'constexpr union constructor that does not initialize any member is a C++20 extension'
HDA9656DF3125: "C++20擴充功能：未初始化任何成員的'union constexpr建構函數'"
# 'constexpr union constructor that does not initialize any member is incompatible with C++ standards before C++20'
H42AB5A6736FE: "未初始化任何成員的'union constexpr建構函數' 與C++20之前版本標準不相容"
# 'constexpr variable %0 must be initialized by a constant expression'
H22D6867A6C46: "'constexpr' 變數 %0 必須以常數運算式初始化"
# 'constexpr variable %0 must have constant destruction'
H0CB1A9F457E9: "'constexpr' 變數 %0 必須具有常數銷毀性"
# 'constexpr variable cannot have non-literal type %0'
H8CA68B10BD1E: "具非文字類型 %0 的 'constexpr' 變數無效"
# 'constexpr variable cannot have type %0'
H9CBE3FDAF244: "具類型 %0 的 'constexpr' 變數無效"
# 'constexpr variable declaration must be a definition'
H28D5C206A058: "'constexpr' 變數宣告必須為定義"
# 'constrained by %select{|implicitly }1%select{private|protected}0 inheritance here'
HA215ECA901D4: '因 %select{|隱式 }1%select{私有|受保護}0繼承在此處受限制'
# "constrained placeholder types other than simple 'auto' on non-type template parameters not supported yet"
HA5CE432D2BF4: "非類型範型參數上除簡單 'auto' 以外的佔位符類型尚未支援"
# "constraint '%0' is already present here"
HDBC0B5C441D3: "限制條件 '%0' 已在此處存在"
# 'constraint depends on a previously diagnosed expression'
HE3836E579C9B: '約束依賴於先前已診斷的運算式'
# 'constraint variable %0 cannot be used in an evaluated context'
H553F40E512D9: '約束變數 %0 不可在評估環境中使用'
# 'constraints not satisfied for %select{class template|function template|variable template|alias template|template template parameter|template}0 %1%2'
H81A668F064ED: '%select{類別範型|函式範型|變數範型|別名範型|範型範型參數|範型}0 %1%2 的約束未被滿足'
# "construct '%0' not allowed in a region associated with a directive with 'order' clause"
HC4C995E5BA30: "與帶 'order' 子句的指示相關的區域中不允許使用 '%0' 結構"
# 'construction of individual component of complex number is not yet supported in constant expressions'
H0E4CD910394F: '複數類型個別元件的建構尚未支援在常量運算式中使用'
# 'constructor call from initializer list is incompatible with C++98'
HB192963D1DEE: '初始化清單的建構函式呼叫與 C++98 不相容'
# "constructor cannot be declared '%0'"
HC6A3768462FF: '建構函式不能被宣告為 "%0"'
# 'constructor cannot be redeclared'
H55F24B0BC81F: '建構函式不可重新宣告'
# 'constructor cannot have a return type'
H859AAE558539: '建構函式不可指定返回類型'
# 'constructor for %0 creates a delegation cycle'
H475456925F83: '%0 的建構函式會導致委派週期'
# 'constructor from base class %0 inherited here'
H1711561364CF: '從基底類別 %0 繼承的建構函式'
# 'constructor inherited by %0 from base class %1 is implicitly deleted'
H97CFC0CC7D39: '%0 從基底類別 %1 繼承的建構函式已被隱式刪除'
# 'constructor inherited from base class %0 cannot be used in a constant expression; derived class cannot be implicitly initialized'
HC12464115FAE: '從基底類別 %0 繼承的建構函式不可在常量運算式中使用; 衍生類別無法隱式初始化'
# 'constructor initializer %0 does not name a class'
HCFC849237163: '建構函式初始化項 %0 未指定類別'
# 'constructor of %0 inherited from multiple base class subobjects'
HC9F4CC1EE50E: '%0 的建構函式從多個基底類別實體繼承'
# 'constructor of base class %0 is not called'
H3174F7100ABA: '基類 %0 的建構函數未被調用'
# 'constructor parameter %0 shadows the field %1 of %2'
H11CEF1CBDAF0: '建構函數參數 %0 遮蔽 %2 的成員變數 %1'
# "constructs with the same name must have a 'hint' clause with the same value"
H0760234C4455: "相同名稱的建構選項必須具有相同值的 'hint' 子句"
# "consumed analysis attribute is attached to member of class %0 which isn't marked as consumable"
H05C072713E0E: '已消耗分析屬性附加到未標記為可消耗的類別 %0 成員'
# 'container access result unused - container access should not be used for side effects'
H8AF2586DAD21: '容器存取結果未被使用 - 容器存取不應用於副作用'
# 'context %select{set|selector|property}0 options are: %1'
H10E910F395AC: '上下文 %select{設定|選擇器|屬性}0 選項為：%1'
# 'continue even if build-ids in input binary and perf.data mismatch'
HF64C3EBD8AC2: '即使輸入二進位檔與 perf.data 的 build-ids 不匹配仍繼續執行'
# 'control flows through the definition of a %select{static|thread_local}0 variable'
HBD024CE03438: '控制流程通過 %select{靜態|thread_local}0 變數的定義'
# 'control reached end of constexpr function'
HE6815340E241: 'constexpr 函數的控制流程到達函數結尾'
# 'controlling expression type %0 compatible with %1 generic association types'
HB8A1ADD97071: '控制運算式類型 %0 與 %1 個泛型關聯類型相容'
# 'controlling expression type %0 not compatible with any generic association type'
H55E9ACCD45B7: '控制運算式類型 %0 與任何泛型關聯類型皆不相容'
# "convenience initializer missing a 'self' call to another initializer"
HF14170AD5005: "便利初始化器缺少對其他初始化器的 'self' 調用"
# "convenience initializer should not invoke an initializer on 'super'"
HA39139A75170: "便利初始化器不應調用 'super' 的初始化器"
# 'conversion %diff{from $ to $|between types}0,1 is ambiguous'
HDD7803D6F7A1: '轉換 %diff{從 $ 到 $|在類型間}0,1 含糊不清'
# 'conversion between fixed point and %0 is not yet supported'
HF68AF1DBEB64: '固定點與 %0 之間的轉換尚未支援'
# 'conversion between matrix type %0 and incompatible type %1 is not allowed'
H499A22E2DD8F: '不允許在不相容類型 %0 與 %1 的矩陣類型之間轉換'
# 'conversion between matrix types%diff{ $ and $|}0,1 of different size is not allowed'
H82DF9F4CF265: '不允許不同大小的矩陣類型%diff{ $和$|}0,1 之間轉換'
# 'conversion candidate %0 not viable: constraints not satisfied'
H1A87D3FA633E: '轉換候選 %0 不可行：約束條件不符合'
# 'conversion candidate of type %0'
H1704891C4D79: '轉換為類型 %0 的轉換函式'
# 'conversion from %0 to %1 in converted constant expression would bind reference to a temporary'
H22C174FA2D9C: '從 %0 轉換為 %1 的轉換常數表達式會將引用綁定到暫時物件'
# 'conversion from %0 to %1 is not allowed in a converted constant expression'
H64DA1E381CAE: '在轉換常數表達式中從 %0 轉換為 %1 不被允許'
# 'conversion from pointer to member of class %0 to pointer to member of class %1 via virtual base %2 is not allowed'
HC6DC2FD11DE6: '不允許通過虛基類 %2 將類 %0 的成員指標轉換為類 %1 的成員指標'
# 'conversion from string literal to %0 is deprecated'
H1DEAC81E3C65: '將字串字面量轉換為 %0 已被棄用'
# 'conversion function %diff{from $ to $|between types}0,1 invokes a deleted function%select{|: %3}2'
H302A0E48B3BA: '轉換函數%diff{從$到$的轉換|類型之間的轉換}0,1 調用了已刪除的函數 %select{|: %3}2'
# 'conversion function cannot be redeclared'
HA31D9D61E048: '轉換函式不可重新宣告'
# 'conversion function cannot be variadic'
H28A6D9FD4C07: '轉換函式不可為可變參數'
# 'conversion function cannot convert to a function type'
H61F51031942B: '轉換函式不可轉換為函式類型'
# 'conversion function cannot convert to an array type'
H431E774C8920: '轉換函式不可轉換為陣列類型'
# 'conversion function cannot have a return type'
H846A21D09489: '轉換函式不可具有回傳類型'
# 'conversion function cannot have any parameters'
H9E24A8535723: '轉換函式不可有任何參數'
# 'conversion function converting %0 to %1 will never be used'
H960F42AADA51: '將 %0 轉換為 %1 的轉換函數永遠不會被使用'
# 'conversion function converting %0 to its base class %1 will never be used'
H1FE504FD028F: '將 %0 轉換為其基類 %1 的轉換函數永遠不會被使用'
# 'conversion function converting %0 to itself will never be used'
HC22DB2DAD0D5: '將 %0 轉換為自身的轉換函數永遠不會被使用'
# 'conversion function must be a non-static member function'
HCACC98687D9A: '轉換函數必須是成員函數且非靜態'
# 'conversion to %select{integral|enumeration}0 type %1'
H52D400CB1F4D: '轉換為%select{積數|列舉}0型別 %1'
# 'conversion to %select{integral|enumeration}0 type %1 declared here'
H126F1D6252B2: '轉換為%select{積數|列舉}0型別 %1 在此宣告'
# 'conversion to pointer type %0'
H88631D898FE3: '轉換為指標型別 %0'
# 'convert moves with rbp stack memory operand (unsafe, must be off for binaries compiled with -fomit-frame-pointer)'
H9F1E879B6ED5: '轉換使用rbp堆疊記憶體操作數的移動（不安全，針對使用-fomit-frame-pointer編譯的二進位檔必須關閉）'
# 'convert moves with stack memory operand (potentially unsafe)'
HC5050FEB738B: '轉換使用堆疊記憶體操作數的移動（可能不安全）'
# 'converting delete expression from type %0 to type %1 invokes an explicit conversion function'
HFA594BB552D0: '將類型 %0 的delete運算式轉換為類型 %1 時調用了明確的轉換函數'
# 'converting the enum constant to a boolean'
HC26D67935F61: '將列舉常數轉換為布林值'
# "converting the result of '<<' to a boolean always evaluates to %select{false|true}0"
H66F90B0804A0: '將「<<」運算結果轉換為布林值始終評估為 %select{false|true}0'
# "converting the result of '<<' to a boolean; did you mean '(%0) != 0'?"
HB5F0E9F35B11: '將「<<」的運算結果轉換為布林值；是否意為「(%0) != 0」？'
# "converting the result of '?:' with integer constants to a boolean always evaluates to 'true'"
H0B52D2457927: '將「?:」運算結果（包含整數常數）轉換為布林值始終評估為「true」'
# 'converting to boxing syntax requires casting %0 to %1'
HDE90319BAAF3: '轉換至封裝語法需要將 %0 型別轉換為 %1'
# 'coprocessor %0 must be configured as %select{GCP|CDE}1'
H4C456D50EC55: '輔助處理器 %0 必須設定為 %select{GCP|CDE}1'
# 'copy %select{constructor|assignment operator}0 is implicitly deleted because %1 has a user-declared move %select{constructor|assignment operator}2'
HBE99D1D6F119: '%select{複製建構函數|賦值運算子}0 因 %1 宣告了使用者定義的移動 %select{建構函數|賦值運算子}2 而隱式刪除'
# 'copy constructor must pass its first argument by reference'
H3ABFF716FBF3: '複製建構函數必須以引用傳遞其第一個參數'
# 'copy constructor of %0 is implicitly deleted because field %1 is of rvalue reference type %2'
H5B9C818EF5D6: '%0 的複製建構函數因成員 %1 的類型 %2 為右值引用型別而隱式刪除'
# 'copying a temporary object of incomplete type %0'
H4C050E15C304: '複製不完整型別 %0 的暫存物件'
# "coroutine %0 cannot be declared 'noreturn' as it always returns a coroutine handle"
H7F1772343EA2: "協程 %0 無法被宣告為 'noreturn'，因為它始終會返回一個協程句柄"
# "could not acquire lock file for module '%0': %1"
H0C3259D0CAD4: "無法取得模組 '%0' 的鎖定檔： %1"
# "could not build module '%0'"
H0F4C1C79774B: "無法建構模組 '%0'"
# "could not calculate number of iterations calling 'operator-' with upper and lower loop bounds"
H55F92FED58CA: "無法計算透過 'operator-' 調用上下限迴圈界限的迭代次數"
# 'could not determine the original source location for %0:%1:%2'
H596D1B547578: '無法為 %0:%1:%2 確定原始原始碼位置'
# "could not find ';' after @import"
H808D2C4625A0: "無法在 @import 後找到 ';' 符號"
# 'could not find Objective-C class %0 to convert %1 to %2'
H8A434A2F54F7: '無法將 %1 轉換為 %2 因為找不到 Objective-C 類別 %0'
# 'could not match %diff{$ against $|types}0,1'
HB17669DA1C41: '無法將 %diff{ $ 匹配 $ |類型}1,0 進行對應'
# "could not open '%0' for embedding"
HF452E067B4E2: "無法開啟 '%0' 進行嵌入"
# "could not read %0 input list '%1': %2"
H67879BBD7E88: "無法讀取 %0 輸入清單 '%1'：%2"
# "could not read directory '%0': %1"
HBA8BA2C7E279: "無法讀取目錄 '%0'：%1"
# "could not remap file '%0' to the contents of file '%1'"
H154079BD4163: "無法將檔案 '%0' 重新映射為檔案 '%1' 的內容"
# 'covariant thunk required by %0'
H96E8ACBA5464: '%0 所需的協變 thunk'
# "cpu '%0' does not support rv%select{32|64}1"
HB22CC79010F2: "CPU '%0' 不支援rv%select{32|64}1"
# 'create a static PC table'
HA9821FD0C9F2: '建立靜態程序計數器表'
# "current API version is '%0', but plugin was compiled with version '%1'"
H399ED19E4A74: "目前API版本為 '%0'，但插件編譯時使用版本為 '%1'"
# 'current file is older than dependency %0'
HCE89B30434E7: '目前檔案比依賴項 %0 舊'
# "current handling of vector bool and vector pixel types in this context are deprecated; the default behaviour will soon change to that implied by the '-altivec-compat=xl' option"
H2144886C992F: "當前向量布林值和向量像素類型在此語境中的處理方式已棄用；預設行為將很快變更為 '-altivec-compat=xl' 選項所暗示的行為"
# "current_version does not match: '%0' (provided) vs '%1' (found)"
H84F45A8B13FB: "版本不相符：提供的 '%0' 對比找到的 '%1'"
# "cycle in acquired_before/after dependencies, starting with '%0'"
HCB49175AA5FC: "取得.acquire_before/.after依賴項循環，起始於 '%0'"
# "cyclic dependency in module '%0': %1"
H2C783846485B: "模組 '%0' 中存在循環依賴：%1"
# 'data argument not used by format string'
HB79E446EA7A1: '格式字串未使用資料參數'
# "data argument position '%0' exceeds the number of data arguments (%1)"
H3A25FAA1F4B4: "資料參數位置 '%0' 超過資料參數總數(%1)"
# 'data layout string to use'
HBFBB6DFFCFDF: '要使用的資料布局字串'
# 'data member instantiated with function type %0'
HE2AF1A6B9D7C: '以函式類型 %0 實體化的資料成員'
# "data-sharing attribute '%0' in '%1' clause requires OpenMP version %2 or above"
H12FB4E840EF7: "'%0' 資料共用屬性在 '%1' 子句中需要OpenMP版本 %2 或更高版本"
# 'dbx'
H362301DA6431: 'dbx'
# "dealloc return type must be correctly specified as 'void' under ARC, instead of %0"
HF5C8E84C253E: "在ARC下dealloc傳回類型必須正 xác指定為 'void'，而非 %0"
# 'debug'
H32FAAECAC742: 'debug'
# "debug information option '%0' is not supported for target '%1'"
H53B68E933A49: "調試資訊選項 '%0' 不支援目標 '%1'"
# "debug information option '%0' is not supported; requires DWARF-%2 but target '%1' only provides DWARF-%3"
HBD9D2872B134: "調試資訊選項 '%0' 不支援；需要DWARF-%2，但目標 '%1' 只提供DWARF-%3"
# 'debug print callable symbols defined by materialization units'
H976885EE0BAB: '列印由實體化單元定義的可呼叫符號'
# 'debug print data symbols defined by materialization units'
H68EF51B0D840: '列印由實體化單元定義的資料符號'
# 'debug print hidden symbols defined by materialization units'
H29FF2691850E: '列印由實體化單元定義的隱藏符號'
# 'debug stack'
HF8D202225993: '列印堆疊調試資訊'
# "declaration %0 attached to named module '%1' cannot be attached to other modules"
H238E4BEFC413: "附加到命名模組 '%1' 的宣告 %0 無法附加到其他模組"
# "declaration %0 is detected to be defined in multiple module units, first is from '%1' and second is from '%2'; the compiler may not be good at merging the definitions. "
H96F07A99E632: "宣告 %0 被發現定義在多個模組單元中，第一個來自 '%1'，第二個來自 '%2'；編譯器可能無法正確合併這些定義。"
# "declaration '%0' is %select{weak defined|thread local}1, but symbol is not in dynamic library"
HFB32CBE0F1C5: "宣告 '%0' 是%select{弱定義|執行緒局部}1，但符號不在動態函式庫中"
# "declaration '%0' is marked %select{available|unavailable}1, but symbol is %select{not |}2exported in dynamic library"
H01B92D3A7F34: "宣告 '%0' 標記%select{可用|不可用}1，但符號%select{未 |}2 在動態函式庫中匯出"
# "declaration cannot be inferred '%0' because it has no definition in this translation unit"
HFACBBC5D211B: "無法推斷宣告 '%0'，因為在此翻譯單元中沒有定義它"
# 'declaration conflicts with target of using declaration already in scope'
HF0A04A0DD736: '宣告與範疇中已存在的 using 宣告目標衝突'
# 'declaration does not declare a parameter'
HAB6C8E5E5B42: '宣告未宣告參數'
# 'declaration does not declare anything'
HCF31319302C2: '宣告未宣告任何事物'
# "declaration has external linkage, but dynamic library doesn't have symbol '%0'"
H867521795963: "宣告具有外部連結，但動態函式庫中未包含符號 '%0'"
# "declaration has external linkage, but symbol has internal linkage in dynamic library '%0'"
H51741F52DD27: "宣告具有外部連結，但符號在動態函式庫 '%0' 中具有內部連結"
# 'declaration hides type'
HBEC56FF31D60: '宣告隱藏類別型別'
# 'declaration in interface'
HA49C5D70160C: '宣告在介面'
# "declaration in interface is not in the '%select{alloc|copy|init|new}0' family because %select{its result type is not an object pointer|its result type is unrelated to its receiver type}1"
H135EF0608D60: "介面中的宣告不在 '%select{alloc|copy|init|new}0' 系列，因為 %select{其傳回類型不是物件指標|其傳回類型與接收者類型無關}1"
# "declaration is marked with '%select{\\|@}0deprecated' command but does not have a deprecation attribute"
H7C7F3BB153A5: "宣告以 '%select{\\|@}0deprecated' 指令標記，但未指定停用屬性"
# 'declaration is not declared in any declare target region'
H519107FB97C7: '宣告未在任何 declare target 區域中宣告'
# 'declaration marked as declare target after first use, it may lead to incorrect results'
HB5487BD38E68: '宣告在首次使用後才標記 declare target，可能导致不正確的結果'
# "declaration missing '[[carries_dependency]]' attribute is here"
H0D046CE0EB0D: "缺少 '[[carries_dependency]]' 屬性的宣告在此處"
# 'declaration of %0 does not match'
H12CB12FACAA5: '%0 的宣告不匹配'
# 'declaration of %0 has a different language linkage'
HB8AA7E6F59F0: '%0 的宣告具有不同的語言連結屬性'
# 'declaration of %0 in %select{the global module|module %2}1 follows declaration in %select{the global module|module %4}3'
HCB7EF6CCFFAA: '%0 的宣告在 %select{全域模組|模組 %2}1 出現在 %select{全域模組|模組 %4}3 的宣告之後'
# 'declaration of %0 is missing in %1 class'
HCE379B9B6B0B: '%1 類別中缺少 %0 的宣告'
# "declaration of %0 overrides a '%select{final|sealed}1' function"
H49FDD9D92060: "%0 的宣告覆寫了 '%select{最終|密封}1' 函數"
# 'declaration of %0 shadows template parameter'
HB1AA8E00948E: '%0 的宣告遮蔽了模板參數'
# 'declaration of %0 will not be visible outside of this function'
H1E299D7E36E1: '%0 的宣告在這個函數外部將不可見'
# 'declaration of %0 with internal linkage cannot be exported'
HB1BC44F22B13: '具有內部連結的 %0 宣告無法被匯出'
# 'declaration of %1 %select{with C language linkage|in global scope}0 conflicts with declaration %select{in global scope|with C language linkage}0'
HADF36ADC7505: '%select{具有C語言例外處理|在全域範圍}0 的 %1 宣告與 %select{全域範圍|具有C語言例外處理}0 的宣告衝突'
# "declaration of a variadic function without a comma before '...' is deprecated"
HF12988516A95: "未在 '...' 前使用逗號宣告多態函數已被棄用"
# 'declaration of anonymous %0 must be a definition'
H1EBFCC5461F9: '匿名 %0 的宣告必須是定義'
# 'declaration of block scope identifier with linkage cannot have an initializer'
HDD3AC9280BE3: '具有連結性的區塊作用域識別符無法具有初始值設定'
# "declaration of built-in function '%0' requires the declaration of the 'jmp_buf' type, commonly provided in the header <setjmp.h>"
H8F1CDE7D22C0: "宣告內建函數 '%0' 需要 'jmp_buf' 類型宣告，通常在標頭 <setjmp.h> 提供"
# "declaration of built-in function '%1' requires inclusion of the header <%0>"
H059DBCAF4C02: "宣告內建函數 '%1' 需要包含標頭 <%0>"
# 'declaration of constexpr static data member %0 requires an initializer'
HCFAE74ED9FCD: 'constexpr 靜態資料成員 %0 需要初始值設定'
# 'declaration of instance variables in the interface is deprecated'
HF2C25CBD493E: '在介面中宣告實例變數已被棄用'
# "declaration of non-local variable in 'for' loop"
HBFAC0B86B48E: "在 'for' 迴圈中宣告非局部變數"
# "declaration of non-local variable in 'for' loop is a C23 extension"
H82E18D14C9A2: "'for' 迴圈中非局部變數的宣告是 C23 的擴充功能"
# "declaration of non-local variable in 'for' loop is incompatible with C standards before C23"
H1C8715C3541C: "'for' 迴圈中非局部變數的宣告與 C23 之前標準不相容"
# 'declaration of reference variable %0 requires an initializer'
H8635EDA9A8C6: '需要初始值設定才能宣告引用變數 %0'
# 'declaration of variable %0 with deduced type %1 requires an initializer'
H737154EADE2A: '需要初始值設定才能宣告型別已推論的變數 %0（推論型別為 %1）'
# 'declaration requires a global constructor'
H55DC760EFFEA: '宣告需要全域建構函數'
# 'declaration requires a global destructor'
H7852FAA15ED5: '宣告需要全域析構函數'
# 'declaration requires an exit-time destructor'
H86CA276EEC00: '宣告需要退出時析構函數'
# 'declaration shadows a %select{local variable|variable in %2|static data member of %2|field of %2|typedef in %2|type alias in %2|structured binding}1'
H68CDFAD663DD: '此宣告遮蔽了 %select{區域變數|%2 中的變數|%2 的靜態資料成員|%2 的成員|%2 中的typedef|%2 中的類型別名|結構化綁定}1'
# 'declaration uses __weak, but ARC is disabled'
H1C8188316ADE: '__weak 用法與 ARC 未啟用衝突'
# 'declaration uses __weak, which the current deployment target does not support'
HEB22F5D20508: '部署目標不支援此 __weak 用法'
# 'declaration uses type that is ill-formed in ARC'
H522AD27CDFBF: '宣告使用了 ARC 環境下非法的型別'
# 'declarator requires an identifier'
HB85D316E7D82: '宣告符號需要識別子'
# "declare 'static' if the %select{variable|function}0 is not intended to be used outside of this translation unit"
H5D50A42530DC: "若%select{變數|函數}0不打算在本翻譯單位外使用，請宣告為 'static'"
# 'declare the parameter __strong or capture a __block __strong variable to keep values alive across autorelease pools'
H9B7134A463BB: '宣告參數為 __strong 或捕獲 __block __strong 變數，以確保值在autorelease 池間存續'
# "declared %select{'returns_nonnull'|'nonnull'}0 here"
H9D136543BAF2: "在此處宣告 %select{'returns_nonnull'|'nonnull'}0 属性"
# 'declared %select{in global scope|with C language linkage}0 here'
H3DB72872F2B8: '這裡在 %select{全域範圍|C語言連結}0 中宣告過'
# 'declared as a non-template here'
H65BA70C7322E: '這裡宣告為非模板'
# 'declared here'
HA1E35E29C81D: '這裡已宣告'
# 'declared here with type %0'
H880F1F3D3828: '這裡以類型 %0 宣告過'
# "declared here%select{ in module '%1'|}0"
HD4C36AE9FEF2: "這裡在%select{模組 '%1'|}0 宣告過"
# 'declared with %0 attribute here'
H98D954FCA941: '這裡以 %0 屬性宣告過'
# "declared with class '%0' here"
HA2F652501D84: "這裡以類別 '%0' 宣告過"
# 'declared with index %0 here'
H29E8DAE209C5: '這裡以索引 %0 宣告過'
# 'declaring function parameter of type %0 is not allowed%select{; did you forget * ?|}1'
H45BA30613376: '不允許宣告類型為 %0 的函數參數%select{；是否遺漏了 * ?|}1'
# 'declaring function return value of type %0 is not allowed %select{; did you forget * ?|}1'
HC0F56D942DA5: '不允許宣告回傳值類型為 %0 的函數%select{；是否遺漏了 * ?|}1'
# "declaring overloaded %0 as 'static' is a C++23 extension"
H3416DF62F662: "將重載的 %0 宣告為 'static' 是 C++23 的擴充功能"
# "declaring overloaded %0 as 'static' is incompatible with C++ standards before C++23"
HE846DD4F137C: "將重載的 %0 宣告為 'static' 與 C++23 之前的標準不相容"
# 'declaring variable of type %0 is not allowed'
HCC1ADB51903E: '不允許宣告類型為 %0 的變數'
# 'decode probes section from binary'
H61AE631A7106: '從二進位檔解碼插樁區段'
# 'decomposition declaration %0 requires an initializer'
H745CF12AB2DC: '分解宣告 %0 需要初始化式'
# 'decomposition declaration cannot be a template'
H12444CAF9EB2: '分解宣告不能是範型'
# "decomposition declaration cannot be declared %plural{1:'%1'|:with '%1' specifiers}0"
HEDAF4E9407D4: "分解宣告不能宣告 %plural{1:'%1'|:具有 '%1' 指定符}0"
# "decomposition declaration cannot be declared with constrained 'auto'"
H33CAEB57113F: "分解宣告不能宣告受限的 'auto'"
# 'decomposition declaration cannot be declared with parentheses'
H02314396E4F0: '分解宣告不能以括號宣告類型'
# "decomposition declaration cannot be declared with type %0; declared type must be 'auto' or reference to 'auto'"
H3DD0947995B7: "分解宣告不能宣告類型 %0；宣告類型必須為 'auto' 或 'auto' 的引用"
# "decomposition declaration declared %plural{1:'%1'|:with '%1' specifiers}0 is a C++20 extension"
HED6397EE7170: "分解宣告宣告 %plural{1:'%1'|:具有 '%1' 指定符}0 是 C++20 扩展"
# "decomposition declaration declared %plural{1:'%1'|:with '%1' specifiers}0 is incompatible with C++ standards before C++20"
H3B1B7DD7D4A6: "分解宣告宣告 %plural{1:'%1'|:具有 '%1' 指定符}0 與 C++20 之前標準不相容"
# 'decomposition declaration must be the only declaration in its group'
H36F7861E46A5: '分解宣告必須是其宣告群組中的唯一宣告'
# 'decomposition declaration not permitted in this context'
HE332CBDAE8B6: '此語境中不允許分解宣告'
# 'decomposition declarations are a C++17 extension'
H41B58BACEDBD: '分解宣告是 C++17 扩展'
# 'decomposition declarations are incompatible with C++ standards before C++17'
H6F6939D7899C: '分解宣告與 C++17 之前標準不相容'
# 'deduced conflicting types %diff{($ vs $) |}0,1for initializer list element type'
H41EB8FB5647B: '推導出初始化清單元素類型的衝突類型 %diff{( $ 與 $ ) |}0,1'
# 'deduced incomplete pack %0 for template parameter %1'
H03080CBC4C1A: '推導出模板參數 %1 的不完整包 %0'
# 'deduced non-type template argument does not have the same type as the corresponding template parameter%diff{ ($ vs $)|}0,1'
H6489085BE16C: '推導出的非類型模板參數與對應模板參數類型不同 %diff{( $ 與 $ ) |}0,1'
# "deduced return type for defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator must be 'auto', not %1"
H209B0E7EFC40: "預設的 %select{<ERROR>|相等性|三向|相等性|關係}0 比較運算子的推導傳回類型必須為 'auto'，而不是 %1"
# 'deduced return types are a C++14 extension'
HB07F9BCAC63A: '推導傳回類型是 C++14 的擴充功能'
# 'deduced type %0 does not satisfy %1'
H9431BF910A33: '推導類型 %0 不符合 %1'
# 'deduced type %1 of deduction guide is not %select{|written as }2a specialization of template %0'
H902D2FE80122: '推導指引的推導類型 %1 不是 %select{|寫成}2 模板 %0 的特化版本'
# 'deduction guide cannot be %select{explicitly instantiated|explicitly specialized}0'
HA3A632F69A86: '推導指引不能 %select{明確實例化|明確特化}0'
# "deduction guide cannot be declared '%0'"
HF6365CFA8B89: "推導指引不能宣告為 '%0'"
# 'deduction guide cannot have a function definition'
H7D3F7544A5EA: '推導指引宣告不能具有函式定義'
# 'deduction guide declaration without trailing return type'
H4EE056EE4349: '推導指引宣告缺少尾隨傳回類型'
# 'deduction guide declared %0 by intervening access specifier'
HBCF8F59E9812: '推導指引在 %0 被中間的存取規格符號遮蔽'
# 'deduction guide has different access from the corresponding member template'
H1030B70A50CA: '推導指引的存取權限與對應成員範本不同'
# 'deduction guide must be declared in the same scope as template %q0'
H1F6362B2A695: '推導指引必須在模板 %q0 的相同作用域中宣告'
# 'deduction guide template contains %select{a template parameter|template parameters}0 that cannot be deduced'
H9078590D8224: '推導指引範本包含 %select{無法推導的模板參數|無法推導的模板參數}0'
# 'default %select{argument|non-type template argument}0 may not use a GNU statement expression'
HB2A0E2C3CEAE: '預設 %select{參數|非類型模板參數}0 不可使用 GNU 陳述式運算子'
# 'default alignment for functions'
HDB8C50704025: '函式預設對齊設定'
# 'default argument declared here'
HDD61CA193DBE: '這裡宣告預設參數'
# 'default argument not permitted on an explicit %select{instantiation|specialization}0 of function %1'
HA5116018194A: '無法在函數 %1 的顯示%select{實體化|特化}0上指定預設參數'
# "default argument references 'this'"
H743C3B172B68: "預設參數引用 'this'"
# 'default argument references local variable %0 of enclosing function'
HAA8CD5949FC3: '預設參數引用外部函數的局部變數 %0'
# 'default argument references parameter %0'
H573EB7C93602: '預設參數引用參數 %0'
# 'default argument used here'
H2C2A14271D90: '此處使用預設參數'
# 'default arguments can only be specified for parameters in a function declaration'
H910FAD8C4EA4: '只能在函數宣告的參數上指定預設參數'
# 'default arguments cannot be added to a function template that has already been declared'
H2AD8ADEE046B: '無法為已宣告的函數範本新增預設參數'
# 'default arguments cannot be added to an out-of-line definition of a member of a %select{class template|class template partial specialization|nested class in a template}0'
H2A1897D12086: '無法在%select{類別範本|類別範本的部分特化|模板內嵌類別}0成員的外部定義中新增預設參數'
# 'default arguments not allowed for parameters of a requires expression'
H8AAADF6A99AF: 'requires 表達式的參數禁止指定預設參數'
# 'default assign attribute on property %0 which implements NSCopying protocol is not appropriate with -fobjc-gc[-only]'
H8248EDB07821: '實作 NSCopying 協定的屬性 %0 指定預設指派屬性與 -fobjc-gc[-only] 不相容'
# 'default capture by %select{value|reference}0'
H472BB89BA278: '預設採用%select{值|參考}0'
# 'default constructed field %0 declared here'
H948E9DA6EBAF: '預設建構的欄位 %0 此處宣告'
# 'default exception handling model'
H9659057B9931: '預設例外處理模型'
# 'default initialization of an object of const type %0%select{| without a user-provided default constructor}1'
H303212CBDF84: '以預設初始化方式初始化 const 類型 %0%select{| 物件卻未提供使用者定義的預設建構函數}1'
# 'default initialization of an object of const type %0%select{| without a user-provided default constructor}1 is a Microsoft extension'
H48E5A1B64C89: '以預設初始化方式初始化 const 類型 %0%select{| 物件卻未提供使用者定義的預設建構函數}1 是 Microsoft 延伸語法'
# 'default label in switch which covers all enumeration values'
HF1A67825B6F5: 'switch 中的預設標籤涵蓋了所有列舉值'
# 'default member initializer declared here'
H09B30FC3540B: '在此處宣告的成員預設初始化式'
# 'default member initializer for %0 uses itself'
H62A9561A4498: '成員 %0 的預設初始化式使用自身'
# 'default member initializer for %1 needed within definition of enclosing class %0 outside of member functions'
HB4FBDC93A96D: '封裝類別 %0 的定義外，需在非成員函數中為 %1 的成員提供預設初始化式'
# 'default member initializer for bit-field is a C++20 extension'
H960B2B591D79: '位域成員的預設初始化式是 C++20 的擴充功能'
# 'default member initializer for bit-field is incompatible with C++ standards before C++20'
H85717DD87366: '位域成員的預設初始化式與 C++20 之前標準不相容'
# 'default member initializer for non-static data member is a C++11 extension'
HB1974A6508C8: '非靜態資料成員的預設初始化式是 C++11 的擴充功能'
# 'default member initializer for non-static data members is incompatible with C++98'
H75DECF5B5D30: '非靜態資料成員的預設初始化式與 C++98 標準不相容'
# "default property attribute 'assign' not appropriate for object"
HBAC11B3F8368: "預設屬性屬性 'assign' 不適合物件"
# 'default scope specifier for attributes is a C++17 extension'
H9959B28B39FE: '屬性的預設作用域指定是 C++17 的擴充功能'
# 'default scope specifier for attributes is incompatible with C++ standards before C++17'
HCB10ABA8102F: '屬性的預設作用域指定與 C++17 之前標準不相容'
# 'default template argument for a template template parameter must be a class template'
H3FA43EDB90ED: '模板模板參數的預設模板實參必須是類模板'
# 'default template argument in a class template partial specialization'
H57E58A1F67E6: '類模板部分特殊化中的預設模板實參'
# 'default template argument not permitted on a friend template'
H1B3D975772BB: '友元模板上不可指定預設模板實參'
# 'default template arguments for a function template are a C++11 extension'
H94B1EDF48980: '函數模板的預設模板實參是 C++11 的擴充功能'
# 'default template arguments for a function template are incompatible with C++98'
H688888558286: '函數範型的預設模板參數與 C++98 不相容'
# 'defaulted %0 is implicitly deleted because %2 is a %select{union-like class|union}1 with variant members'
HAADBD633A7F2: '預設的 %0 因 %2 是具有可變成員的 %select{類似聯結的類|聯結}1 而被隱式刪除'
# 'defaulted %0 is implicitly deleted because a builtin comparison function using this conversion would be the best match for the comparison'
H6F959181B71C: '預設的 %0 因其內建比較函數使用此轉換時將成為最佳匹配而被隱式刪除'
# 'defaulted %0 is implicitly deleted because class %1 has a reference member'
HDDAEEF62F6DD: '預設的 %0 因類別 %1 具有參考成員而被隱式刪除'
# "defaulted %0 is implicitly deleted because implied %select{|'==' |'<' }1comparison %select{|for member %3 |for base class %3 }2is ambiguous"
H8204A4BEFE67: "預設的 %0 因其隱含的 %select{|'==' |'<' }1 比較 %select{|針對成員 %3 |針對基底類別 %3 }2 存在歧義而被隱式刪除"
# 'defaulted %0 is implicitly deleted because it would invoke a %select{private|protected}3 %4%select{ member of %6| member of %6 to compare member %2| to compare base class %2}1'
HA2763C071EBA: '預設的 %0 因其會調用 %select{私有|受保護}3 %4%select{ 的 %6 成員| 的 %6 成員用於比較成員 %2| 用於比較基底類別 %2 }1 而被隱式刪除'
# 'defaulted %0 is implicitly deleted because it would invoke a deleted comparison function%select{| for member %2| for base class %2}1'
H73AE2279ECF2: '預設的 %0 因其會調用被刪除的比較函數 %select{| 針對成員 %2| 針對基底類別 %2 }1 而被隱式刪除'
# "defaulted %0 is implicitly deleted because there is no viable %select{three-way comparison function|'operator=='}1 for %select{|member |base class }2%3"
HC9957DD8DD53: "預設的 %0 因 %select{三向比較函數|'operator=='}1 對 %select{|成員 |基底類別 }2%3 無有效實作而被隱式刪除"
# 'defaulted %0 is implicitly deleted because this non-rewritten comparison function would be the best match for the comparison'
H5A66B2776E93: '預設的 %0 因此未修訂的比較函數將是比較的最佳匹配而被隱式刪除'
# 'defaulted comparison function must not be volatile'
H50500CCE550F: '預設的比較函數不可標示為 volatile'
# 'defaulted comparison operators are a C++20 extension'
H17EA10D2ACC2: '預設的比較運算子是 C++20 擴展'
# 'defaulted comparison operators are incompatible with C++ standards before C++20'
H38C2AF56B86F: '預設的比較運算子與 C++20 之前標準不相容'
# "defaulted definition of %select{%select{<ERROR>|equality|three-way|equality|relational}1 comparison operator|three-way comparison operator}0 cannot be declared %select{constexpr|consteval}2 because %select{it|for which the corresponding implicit 'operator==' }0 invokes a non-constexpr comparison function"
HDA596C603C53: "預設的 %select{%select{<ERROR>|等值|三向|等值|關係}1 比較運算子|三向比較運算子}0 不可標示為 %select{constexpr|consteval}2，因 %select{其|對應隱式 'operator==' }0 會調用非 constexpr 比較函數"
# 'defaulted definition of %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot be marked %select{constexpr|consteval}1 before C++23'
H5C1B0C179374: '預設的 %select{預設建構函數|複製建構函數|移動建構函數|複製指派運算子|移動指派運算子|析構函數}0 在 C++23 之前無法標示為 %select{constexpr|consteval}1'
# 'defaulted member %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator must be const-qualified'
H8A22F945F946: '預設的 %select{<ERROR>|等值|三向|等值|關係}0 比較運算子必須具有 const 資格'
# 'defaulted move assignment operator of %0 will move assign virtual base class %1 multiple times'
HC302B71D801C: '%0 的預設移動指派運算符會對虛基類 %1 進行多次移動指派'
# "defaulting %select{this %select{<ERROR>|equality|three-way|equality|relational}1 comparison operator|the corresponding implicit 'operator==' for this defaulted 'operator<=>'}0 would delete it after its first declaration"
HCBD1D13B7A08: "預設 %select{此 %select{<ERROR>|等號|三向比較|等號|關係}1 運算符|對應於此預設 'operator<=>' 的隱式 'operator==' 運算符}0 會在第一次宣告後刪除它"
# 'defaulting this %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator is not allowed because it was already declared outside the class'
H21E3B4CFF46D: '預設此 %select{<ERROR>|等號|三向比較|等號|關係}0 運算符因已在類別外宣告過而被禁止'
# 'defaulting this %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 would delete it after its first declaration'
H7E7544692CE2: '預設此 %select{預設建構函數|複製建構函數|移動建構函數|複製指派運算符|移動指派運算符|析構函數}0 會在第一次宣告後刪除它'
# 'defined as %0'
H95D82B9347CA: '定義為 %0'
# "defining a type within '%select{__builtin_offsetof|offsetof}0' is a C23 extension"
HB6CCA72E4AE1: "在 '%select{__builtin_offsetof|offsetof}0' 中定義類型是 C23 擴展"
# 'definition %0 cannot also be an %select{alias|ifunc}1'
HEAC49AC815B1: '定義 %0 不能同時是 %select{別名|ifunc}1'
# 'definition has no member %0'
HF2870D3EBBD2: '此定義沒有成員 %0'
# "definition in module '%0' is here"
HD03996A6AE5C: '此模組 "%0" 的定義在此處'
# "definition of %0 is not complete until the closing '}'"
H6A431AA48FA1: '%0 的定義直到關閉 "}" 才會完整'
# 'definition of a %select{static|thread_local}1 variable in a constexpr %select{function|constructor}0 is a C++23 extension'
H398F375C6A6A: '在 constexpr %select{函數|建構函式}0 內定義 %select{static|thread_local}1 變數是 C++23 擴充功能'
# 'definition of a %select{static|thread_local}1 variable in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++23'
HE9C5585842AA: '在 constexpr %select{函數|建構函式}0 內定義 %select{static|thread_local}1 變數與 C++23 之前標準不相容'
# 'definition of a variable of non-literal type in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++23'
H53017D331C6A: '在 constexpr %select{函數|建構函數}0 中定義非字面類型變數與 C++23 之前標準不相容'
# 'definition of builtin function %0'
HC9CC697C220C: '內建函數 %0 的定義'
# 'definition of class %0 must be available to use Objective-C %select{array literals|dictionary literals|numeric literals|boxed expressions|string literals}1'
H852A8FF09E04: '使用 Objective-C %select{陣列字面量|字典字面量|數值字面量|封裝運算式|字串字面量}1 時必須能存取類別 %0 的完整定義'
# 'definition of dllimport data'
HBDC4BCE4EB33: 'dllimport 資料的定義'
# 'definition of dllimport static field'
H64DF6CE31868: 'dllimport 靜態成員的定義'
# 'definition of dllimport static field not allowed'
H8C1897964645: '禁止定義 dllimport 靜態成員'
# 'definition of explicitly defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|function}0'
H1522F98BEB4D: '明確預設 %select{預設建構函式|複製建構函式|移動建構函式|複製指派運算子|移動指派運算子|析構函式|函數}0 的定義'
# 'definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-declared copy %select{assignment operator|constructor}1'
H069CBC304A15: '%0 的隱含複製 %select{建構函式|指派運算子}1 因宣告了使用者定義的複製 %select{指派運算子|建構函式}1 而已棄用'
# 'definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-declared destructor'
H423281D39FA7: '%0 的隱含複製 %select{建構函式|指派運算子}1 因宣告了使用者定義的析構函式而已棄用'
# 'definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-provided copy %select{assignment operator|constructor}1'
H3C23BCA5B3D2: '%0 的隱含複製 %select{建構函式|指派運算子}1 因宣告了使用者提供的複製 %select{指派運算子|建構函式}1 而已棄用'
# 'definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-provided destructor'
H396EB4CE9202: '%0 的隱含複製 %select{建構函式|指派運算子}1 因宣告了使用者提供的析構函式而已棄用'
# 'definition of implicitly declared %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|function}1'
H86596A04E020: '隱含宣告的 %select{預設建構函式|複製建構函式|移動建構函式|複製指派運算子|移動指派運算子|析構函式|函數}1 的定義'
# 'definition of macro %0 does not match definition in precompiled header'
H79B9B4BA8FFF: '宏 %0 的定義與預編譯標頭不符'
# "definition of macro '%0' differs between the AST file '%3' ('%1') and the command line ('%2')"
H40BB23B29C3F: "宏 '%0' 在 AST 檔案 '%3' ('%1') 與命令列 ('%2') 中的定義不同"
# "definition of module '%0' is not available; use -fmodule-file= to specify path to precompiled module interface"
H1ED33479DE5D: "模組 '%0' 的定義不可用；使用 -fmodule-file= 指定預編譯模組介面的路徑"
# 'definition of type %0 conflicts with %select{typedef|type alias}1 of the same name'
H5C3C4CCA94AB: '類型 %0 的定義與同名的 %select{typedef|類型別名}1產生衝突'
# 'definition of variable with array type needs an explicit size or an initializer'
H79E09A4784DB: '陣列類型的變數定義需要明確指定大小或提供初始化值'
# 'definition or redeclaration of %0 cannot name the global scope'
H3AC58FC9EA5A: '%0 的定義或重新宣告不能指定全域作用域'
# 'definition or redeclaration of %0 not allowed inside a block'
HD4328CF55600: '%0 的定義或重新宣告不允許出現在區塊內部'
# 'definition or redeclaration of %0 not allowed inside a function'
H26DE3CAC54F0: '%0 的定義或重新宣告不允許出現在函數內部'
# "definition with same mangled name '%0' as another definition"
H9CD626C8B999: "定義與另一個定義具有相同的雜湊名稱 '%0'"
# 'defsym must be of the form: sym=value: %0'
H633B95A139C3: 'defsym必須以形如 sym=value 的形式指定：%0'
# 'delegating constructors are incompatible with C++98'
H57A554A5A2B8: '委派建構函數與 C++98 不相容'
# 'delegating constructors are permitted only in C++11'
H859BD39058E0: '僅允許在 C++11 中使用委派建構函數'
# 'delete of object with dynamic type %1 through pointer to base class type %0 with non-virtual destructor'
H2817C3914B5E: '通過基類 %0 的指標刪除動態類型為 %1 的物件，而基類未宣告虛函數析構函數'
# "delete of pointer '%0' that does not point to a heap-allocated object"
H8B4F3ED0F000: "刪除未指向堆上物件的指標 '%0'"
# 'delete of pointer that has already been deleted'
H42BC8DFBCECC: '刪除已經被刪除的指標'
# "delete of pointer%select{ to subobject|}1 '%0' %select{|that does not point to complete object}1"
H4DFF941C0746: '刪除%select{指向子物件的 | }1指標 %0%select{ | 其不指向完整物件}1'
# 'deleted definition must be first declaration'
H0F602982588E: '已刪除的函數定義必須為首次宣告'
# 'deleted function %0 cannot override a non-deleted function'
H3FCDC44C217B: '已刪除的函數 %0 無法覆寫未被刪除的函數'
# 'deleting incomplete class type %0; no conversions to pointer type'
H9074591E0AF3: '刪除不完整類型 %0 的指標；無法轉換為指標類型'
# 'deleting pointer to incomplete type %0 is incompatible with C++2c and may cause undefined behavior'
H0FC4BDC8CA1F: '刪除指向不完整類型 %0 的指標與 C++2c 不相容，可能導致未定義行為'
# 'delimited escape sequence cannot be empty'
H5E38AA141B13: '分隔的轉義序列不能為空'
# 'delimited escape sequences are incompatible with C standards before C2y'
H21BCF42E1D91: '分隔的轉義序列與 C2y 之前的 C 標準不相容'
# 'delinearize'
HB90F234569ED: '解除線性化'
# 'demangle symbols (default)'
H49846FF32EAF: '解除符號裝飾 (預設)'
# 'denormals are flushed to positive zero'
H38FDA7EF72DB: '次範圍值被沖刷為正零'
# 'denormals have unknown treatment'
HBDD387FC03A4: '次範圍值的處理方式未知'
# 'dense YAML representation'
HA97D8413D319: '密集的 YAML 表示法'
# "depend modifier cannot be used with 'sink' or 'source' depend type"
H92A125FCC1F2: '依賴修飾符不能與 "sink" 或 "source" 依賴類型一起使用'
# 'dependent %select{__if_not_exists|__if_exists}0 declarations are ignored'
H7E0205C30EB0: '依賴的 %select{__if_not_exists|__if_exists}0 声明被忽略'
# 'dependent nested name specifier %0 for friend class declaration is not supported; turning off access control for %1'
H6C7EBDCCA541: '對 friend 類別宣告使用的依賴巢狀名稱指定符 %0 未被支援；關閉 %1 的存取控制'
# 'dependent nested name specifier %0 for friend template declaration is not supported; ignoring this friend declaration'
H5BCC077F4A6E: '對 friend 範型宣告使用的依賴巢狀名稱指定符 %0 未被支援；忽略此 friend 宣告'
# "dependent using declaration resolved to type without 'typename'"
H9473A34B51B9: '依賴的 using 宣告解析到未指定 "typename" 的類型'
# 'dereference of pointer to incomplete type %0'
H2DF43C211998: '對不完整類型 %0 的指標進行解引用'
# 'dereference of type %1 that was reinterpret_cast from type %0 has undefined behavior'
H90FCF362143A: '將類型 %0 透過 reinterpret_cast 轉換為類型 %1 的解引用行為未定義'
# 'dereferenced pointer past the end of %select{|subobject of }0%select{temporary|%2}1 is not a constant expression'
H22AD60D3A378: '超出 %select{ |子物件的 }0%select{暫存物件|%2}1 末尾的指標解引用並非常數運算式'
# "dereferencing %0; was declared with a 'noderef' type"
H77B30DE9BC36: "解引用 %0；其宣告具有 'noderef' 類型"
# 'dereferencing a __weak pointer is not allowed due to possible null value caused by race condition, assign it to strong variable first'
H69A87CE8BA55: '解引用 __weak 指標可能因競賽條件導致空值，請先將其指派給強變數'
# "dereferencing expression marked as 'noderef'"
HB6D67B14D60F: "解引用標記為 'noderef' 的運算式"
# 'derived class must specify the same code segment as its base classes'
HF7C9EF85294D: '衍生類別必須指定與其基類相同的程式碼區段'
# 'descending'
H486093918FF3: '遞減'
# 'designated initializer invoked a non-designated initializer'
H504DCC34F2E8: '指定初始值設定項調用了非指定初始值設定項'
# "designated initializer missing a 'super' call to a designated initializer of the super class"
H94AB45A96460: "指定初始值設定項缺少對超類指定初始值設定項的 'super' 呼叫"
# "designated initializer should only invoke a designated initializer on 'super'"
H2306DCB92F88: "指定初始值設定項只能對 'super' 呼叫指定初始值設定項"
# 'designated initializers are a C++20 extension'
H868FB6A7DCFA: '指定初始值設定項是 C++20 的擴充功能'
# 'designated initializers are a C99 feature'
HCE690B2EFB92: '指定初始值設定項是 C99 的功能'
# 'designated initializers are incompatible with C++ standards before C++20'
HB212F1F17A19: '指定初始值設定項與 C++20 之前的 C++ 標準不相容'
# 'designator in initializer for %select{scalar|indivisible sizeless}0 type %1'
HDC0C952FB90A: '在 %select{純量|不可分割且無大小}0 類型 %1 的初始值設定項中使用指定符'
# 'designator into flexible array member subobject'
H596716C96072: '在彈性陣列成員子物件中使用指定符'
# "destroying object '%0' whose lifetime has already ended"
H480FFC7A6CDF: "銷毀已結束生命週期的物件 '%0'"
# 'destroying operator delete can have only an optional size and optional alignment parameter'
H05866AB32F25: '銷毀用的 operator delete 只能具有可選的大小參數和可選的對齊參數'
# 'destruction of individual component of complex number is not yet supported in constant expressions'
H6533BAA0653D: '複數的個別組成元件的銷毀在常數運算式中尚未支援'
# 'destruction of object that is already being destroyed'
HBC86CD58BD53: '正在銷毀已經處於銷毀中的物件'
# 'destructor cannot be declared %select{<ERROR>|constexpr|consteval|constinit}0'
H39B25D41B01F: '銷毀子不能宣告為 %select{<ERROR>|constexpr|consteval|constinit}0'
# 'destructor cannot be declared %select{<ERROR>|constexpr|consteval|constinit}0 because %select{data member %2|base class %3}1 does not have a constexpr destructor'
HEA62090F1654: '銷毀子不能宣告為 %select{<ERROR>|constexpr|consteval|constinit}0，因為%select{資料成員 %2|基類 %3}1 沒有 constexpr 的銷毀子'
# "destructor cannot be declared '%0'"
H18788E54B072: "銷毀子不能宣告為 '%0'"
# 'destructor cannot be declared as a template'
H2A9016676C0B: '銷毀子不能宣告為模板'
# 'destructor cannot be declared using a %select{typedef|type alias}1 %0 of the class name'
HD2E86EDB043A: '銷毀子不能使用類別名稱的 %select{typedef|類型別名}1 %0 來宣告'
# 'destructor cannot be redeclared'
H7C102E557BD9: '銷毀子不能重新宣告'
# 'destructor cannot be variadic'
H3060C3D6CE56: '銷毀子不能是可變參數函數'
# 'destructor cannot have a return type'
HB61BE667BB0D: '銷毀子不能有傳回類型'
# 'destructor cannot have any parameters'
H27289F072FC5: '銷毀子不能有任可參數'
# 'destructor for %0 is not trivial because it is virtual'
H695A7FB4C51A: '%0 的銷毀子並非ivial，因為它是虛函數'
# 'destructor must be a non-static member function'
HE5AA51DEFC74: '銷毀子必須是非靜態成員函數'
# 'destructor name %0 does not refer to a template'
H6A0A4776F7D0: '銷毀子名稱 %0 不指向任何模板'
# 'destructor of class %0 is ambiguous'
H29DC1463BFE1: '類別 %0 的銷毀子存在歧義'
# 'destructor type %0 in object destruction expression does not match the type %1 of the object being destroyed'
HCA02CE698CF6: '物件銷毀運算式中的析構函數類型 %0 與正在銷毀的物件類型 %1 不符'
# 'detect use after scope within function'
H76CE675503B0: '在函數內偵測作用域後使用'
# 'detected while default synthesizing properties in class implementation'
HDACD480D581B: '在類別實作中預設合成屬性時被偵測到'
# 'determine if lfence instruction should exist in the retpoline'
HC723EAB1C806: '判斷 retpoline 中是否應存在 lfence 指令'
# 'determine the availability of r11 before indirect branches'
H095D2FB8BA79: '判斷在間接跳轉前 r11 的可用性'
# 'determines whether to demangle function name when symbolizing function ids from the input log'
H55938C1F7AEA: '決定在從輸入日誌符號化函數識別碼時是否解除符號修飾函數名稱'
# 'determines whether to sort input log records by timestamp'
HF854EBCB0FF7: '決定是否按時間戳排序輸入日誌記錄'
# "device clause with ancestor device-modifier used without specifying 'requires reverse_offload'"
H7C03F0398F87: "在未指定 'requires reverse_offload' 時使用具有祖先裝置修飾項的裝置子句"
# 'diagnostic formatting in SARIF mode is currently unstable'
HADEECC0D1814: 'SARIF 模式下的診斷格式目前不穩定'
# 'diagnostic msg: %0'
H1318B5E4A90B: '診斷訊息： %0'
# 'diagtool find-diagnostic-id options'
H0E16FA84CCEE: 'diagtool find-diagnostic-id 選項'
# "did not expect %0 '%2' to be managed by '%1'"
H41E6876DEC05: "不期望 '%2' %0 由 '%1' 管理"
# "did not find header '%0' in framework '%1' (loaded from '%2')"
H33EA4C9E31A5: "在框架 '%1' 中未找到標頭 '%0'（從 '%2' 載入）"
# "did you forget ';'?"
H5762CA5BE293: "是否遺漏了 ';'?"
# "did you intend to use '#pragma pack (pop)' instead of '#pragma pack()'?"
H38F2C3CF1911: "是否想要使用 '#pragma pack(pop)' 而非 '#pragma pack()'?"
# "did you mean %0 ('%2' U+%1)?"
H034E19BAF4DB: "是否是指 %0 ('%2' U+%1)?"
# 'did you mean %0?'
H0AFE75F407BD: '是否意指 %0？'
# 'did you mean %select{struct|interface|class}0 here?'
H2F94B54CE3AD: '是否意指在此處使用 %select{struct|interface|class}0？'
# "did you mean '%0'?"
HC2D29273BC0C: "是否意指 '%0'？"
# "did you mean 'using namespace'?"
H7384271A4FC4: "是否意指使用 'using namespace'？"
# "did you mean to %select{dereference the argument to 'sizeof' (and multiply it by the number of elements)|remove the addressof in the argument to 'sizeof' (and multiply it by the number of elements)|provide an explicit length}0?"
H206E38ACCE90: '是否意圖%select{對sizeof參數取解引用並乘以元素數量|移除sizeof參數的地址運算子並乘以元素數量|明確提供長度}0？'
# 'did you mean to call the %0 method?'
H0FF3D4ADDC94: '是否意圖呼叫 %0 方法？'
# 'did you mean to compare the result of %0 instead?'
HA27A0B6056FB: '是否意圖比較 %0 的結果？'
# "did you mean to use '%0'?"
H18F66684E290: "是否意圖使用 '%0'？"
# "did you mean to use '.' instead?"
HE2F23CD42B59: "是否意圖使用 '.' 進行成員存取？"
# "did you mean to use '\\u'?"
H8EB1B38F64B3: "是否意圖使用 '\\u' 轉義序列表示Unicode代碼點？"
# "did you mean to use 'typename'?"
HA177681AD789: "是否意圖使用 'typename' 關鍵字？"
# 'did you mean to use __block %0?'
H6A59F85FFA80: '是否意圖使用__block修飾符宣告 %0？'
# "differing user-defined suffixes ('%0' and '%1') in string literal concatenation"
HD69068F6D5EE: "字串文字連接時的使用者定義後綴不一致（'%0' 和 '%1'）"
# 'digit separator cannot appear at %select{start|end}0 of digit sequence'
HC90158811A8B: '數字分隔符無法出現在數字序列的%select{開頭|結尾}0位置'
# 'digit separators are incompatible with C standards before C23'
H45FD89D6E3CC: '數字分隔符在C23之前的C標準規格中不相容'
# 'digit separators are incompatible with C++ standards before C++14'
H14907D30B29E: '數字分隔符不相容於C++14之前的標準'
# 'dimension expression does not evaluate to a constant unsigned int'
H7ABEC48E09A3: '維度運算式未評估為常數無符號整數'
# "direct access to Objective-C's isa is deprecated in favor of object_getClass()"
H9F7CC297D241: '直接訪問Objective-C的isa已棄用，請改用object_getClass()'
# 'direct attribute on property %0 ignored (not implemented by this Objective-C runtime)'
H4EFEDE46DF56: '屬性 %0 的direct修飾符被忽略（此Objective-C執行階段未實作）'
# 'direct base %0 is inaccessible due to ambiguity:%1'
HB8D80890A48E: '直接基類 %0 因歧義無法存取：%1'
# 'direct comparison of %select{an array literal|a dictionary literal|a numeric literal|a boxed expression|}0 has undefined behavior'
HB492D0D3EB6E: '直接比較%select{陣列字面量|字典字面量|數值字面量|封裝運算式|}0 具有未定義行為'
# 'direct comparison of a string literal has undefined behavior'
H32F54A871B25: '直接比較字串字面量具有未定義行為'
# 'direct member declared here'
H29E544F12128: '直接宣告的成員在此處宣告'
# 'direct method %0 declared here'
HFC16D00B1613: '直接宣告的方法 %0 在此處宣告'
# 'direct method implementation was previously declared not direct'
HD4855D6E8730: '直接宣告的方法實作先前被宣告為非直接'
# 'direct method was declared in %select{the primary interface|an extension|a category}0 but is implemented in %select{the primary interface|a category|a different category}1'
HE6AB93C50673: '%select{主要介面|擴充宣告|分類}0 中宣告的直接方法，在%select{主要介面|分類|不同分類}1 中實作'
# 'direct property cannot be @dynamic'
HE7907E55F6FD: '直接屬性不能為@dynamic'
# "directive '#pragma omp %0' cannot contain more than one '%1' clause%select{| with '%3' name modifier| with 'source' dependence}2"
H4FF8713761CF: "指令 '#pragma omp %0' 不可包含超過一個 '%1' 子句 %select{| 具有 '%3' 名稱修飾符| 具有 'source' 依賴性}2"
# "directive '#pragma omp %0' cannot contain more than one 'seq_cst',%select{ 'relaxed',|}1 'acq_rel', 'acquire' or 'release' clause"
HAC63F783B13F: "指令 '#pragma omp %0' 不可包含超過一個 'seq_cst'，%select{ 'relaxed'，|}1 'acq_rel'、'acquire' 或 'release' 子句"
# "directive '#pragma omp %0' requires the '%1' clause"
H54115AA95D6F: "指令 '#pragma omp %0' 需要 '%1' 子句"
# "directive '#pragma omp atomic%select{ %0|}1' cannot be used with '%2' clause"
H007A29406786: "#pragma omp atomic%select{ %0|}1 指令不能與 '%2' 子句併用"
# "directive '#pragma omp atomic' cannot contain more than one 'read', 'write', 'update', 'capture', or 'compare' clause"
HE9B44E8E263B: "#pragma omp atomic 指令不能同時包含超過一個 'read'、'write'、'update'、'capture' 或 'compare' 子句"
# "directive '#pragma omp taskwait' cannot use 'nowait' clause without 'depend' clause"
H6E17817BFD4B: "#pragma omp taskwait 指令若使用 'nowait' 子句必須搭配 'depend' 子句"
# 'directive may only be specified in protocols only'
H164583DA86CB: '該指令僅能在協議中指定'
# 'directive must be at file or namespace scope'
H1C3ABA756D9B: '該指令必須位於檔案或命名空間作用域'
# "directive name modifier '%0' is not allowed for '#pragma omp %1'"
H92E146113514: "#pragma omp %1 指令不允许使用 '%0' 修饰符"
# 'directory to dump objects to'
HD09DDF1651F9: '要輸出物件的目錄'
# 'disable '
HEEBCA72FCF98: '停用 '
# 'disable P10 store forward-friendly conversion'
HB86702B7FAD9: '停用 P10 儲存轉換（符合向前兼容）'
# 'disable all inlining (overrides other inlining options)'
HFF8B88EEABDB: '完全禁用內聯（覆蓋其他內聯選項）'
# 'disable attaching TBAA tags to memory accessing operations to override default Flang behavior'
H90AD861FB58A: '停用將TBAA標籤附加到記憶體存取操作，以覆蓋Flang預設行為'
# 'disable attributor runs'
H6B93977370B5: '停用attributor passes'
# 'disable automatically generated 32byte paired vector stores'
H37D64DB7E6AE: '停用自動生成 32 字節配對向量儲存指令'
# 'disable constant hoisting on PPC'
H653549C49999: '停用在PPC架構上的常數提升優化'
# 'disable debug output'
H9D7E26590F03: '停用除錯輸出'
# 'disable generation of structured FIR'
H021ABE4FA052: '停用結構化FIR的產生'
# 'disable instrumentation optimizations that sacrifice profile accuracy (for debugging, default: false)'
H2E999F6F69E3: '停用會犧牲剖析準確性的插樍優化（用於除錯，預設：false）'
# 'disable multithreading'
H29487A51C4F2: '停用多執行緒'
# 'disable outlining indirect calls.'
H3A6314FB1E19: '停用間接呼叫的外觀化。'
# 'disable peepholes'
H199828204162: '停用Peephole優化'
# 'disable preincrement load/store generation on PPC'
H137DF3A43000: '在PPC上禁用增量載入/儲存產生'
# 'disable setting the node scheduling preference to ILP on PPC'
H1F9B89B13D72: '在PPC上禁用將節點排程偏好設定為ILP'
# 'disable sibling call optimization on ppc'
HCCF134132CAF: '在ppc上禁用兄弟函數優化'
# 'disable similarity matching, and outlining, across branches for debugging purposes.'
H62E4BE9FF57F: '為除錯目的，停用跨分支的相似性匹配及外觀化'
# 'disable the default synthesis of Objective-C properties'
H72E5F763EC4E: '停用Objective-C屬性的預設合成'
# 'disable the feature'
H89A827DA533D: '停用此功能'
# 'disable unaligned load/store generation on PPC'
H6B2367F2761C: '在PPC上禁用未對齊的載入/儲存產生'
# 'disable vector permute decomposition'
HB72EC10B2CEE: '停用向量排列分解'
# 'disabled expansion of recursive macro'
H7E32A887A37D: '已停用遞迴巨集的展開'
# 'disables externalization of functions whose addresses are taken'
HA22CB7ECC7FF: '禁用對其位址被取用之函數的外部化'
# 'disables externalization of global variable with local linkage; may cause globals to be duplicated which increases binary size'
HFB10DDFC11CF: '禁用對具有本地連結性的全域變數的外部化；可能導致全域變數被複製，從而增加二進位檔大小'
# 'discriminator argument to ptrauth_sign_constant must be a constant integer, the address of the global variable where the result will be stored, or a blend of the two'
H24D055782EF6: 'ptrauth_sign_constant的參數必須是常數整數、存放結果的全域變數位址，或是兩者的混合'
# 'display a graph using the fractional block frequency representation.'
H0E0DF92DD5CF: '使用分數區塊頻率表示法顯示圖形。'
# 'display a graph using the raw integer fractional block frequency representation.'
H48B34855A7C6: '使用原始整數分數區塊頻率表示法顯示圖形。'
# 'display a graph using the real profile count if available.'
H40F8C199B975: '若有可用的剖析計數，則使用該剖析計數顯示圖形。'
# 'display the encoded probes in binary section'
H2AB55984C4D7: '顯示二進位區段中的編碼探針'
# 'display the results in JSON format'
H181ED368406C: '以JSON格式顯示結果'
# 'display the results in a list sorted by total time'
HD124AAE398C8: '以總時間排序的列表顯示結果'
# 'display the results in a merged list sorted by pass name'
HD6270C003FAF: '以pass名稱排序的合併列表顯示結果'
# 'display the results in text format'
H5126F4AC6EE2: '以文字格式顯示結果'
# 'display the results ina with a nested tree view'
H3B01C53C285F: '以巢狀樹狀檢視顯示結果'
# 'display the results with a nested pipeline view'
HD3FB89799811: '以巢狀管線檢視顯示結果'
# 'div and rem instructions on integers with more than <N> bits are expanded.'
H9085E8D323A2: '超過 <N> 位元的整數除法和取餘指令會被展開。'
# 'division by zero'
H3658877899CE: '除以零'
# 'division by zero in preprocessor expression'
H312B477ACFDB: '預處理運算式中除以零'
# 'dllexport/dllimport inline member functions of dllexport/import classes (default)'
H138D0C477A7F: 'dllexport/dllimport 類別的內聯成員函數 (預設)'
# 'dllimport cannot be applied to non-inline function definition'
H1B629BAD5F55: 'dllimport 不可應用於非內聯函數定義'
# 'do not apply'
HB502CD3A2C1B: '不套用'
# 'do not diff functions whose contents have not been changed from one binary to another'
H30A32C42CDF9: '不比對在不同二進位中內容未變更的函數'
# 'do not display graphs.'
H0D6F782C8BD3: '不顯示圖形。'
# 'do not infer Objective-C related result type based on method family'
HA72282825A47: '不根據方法類別推論 Objective-C 相關的傳回類型'
# 'do not optimize PLT calls'
H790DE86EF643: '不優化 PLT 呼叫'
# 'do not optimize functions with jump tables'
HCB3EB74717E1: '不優化包含跳躍表的函數'
# 'do not perform frame optimization'
HA057BC463383: '不執行框架優化'
# 'do not perform indirect call promotion'
H868459C436A1: '不執行間接呼叫提升'
# 'do not print merged data to stdout'
H7F153D59BE8A: '不將合併後的資料輸出至stdout'
# 'do not print objects/functions'
H6FEA94329728: '不顯示物件/函數'
# 'do not reorder basic blocks'
HDB47587E0803: '不重新排列基本區塊'
# 'do not reorder functions'
H80129F5CF747: '不重新排列函數'
# 'do not scan cold functions for external references (may result in slower binary)'
H06D0BAB57AFF: '不掃描冷函數的外部引用（可能導致二進位執行速度較慢）'
# 'do not show.'
H410E3DC30FB6: '不顯示。'
# 'domain argument %0 does not point to an NSString or CFString constant'
H04276D1D8088: 'domain引數 %0 不指向前NSString或CFString常數'
# 'domain argument %select{|%1 }0does not refer to global constant'
H427CD3AEDAC3: 'domain引數 %select{|%1 }0未引用全域常數'
# "don't always align innermost loop to 32 bytes on ppc"
H8446540436C8: '不總是將最內層迴圈對齊至 32 位元組（在ppc上）'
# "don't demangle symbols"
HFD596F32C278: '不轉換符號名稱'
# "don't report bad accesses via pointers with this tag"
HC0582E9D5000: '不報告此標籤指標的非法存取'
# "don't test for failure"
H2CD70DD9AB50: '不測試失敗'
# 'double precision constant requires %select{cl_khr_fp64|cl_khr_fp64 and __opencl_c_fp64}0, casting to single precision'
H4D72ED1FA64B: '雙精度常數需要 %select{cl_khr_fp64|cl_khr_fp64和__opencl_c_fp64}0，轉換為單精度'
# 'double-quoted include "%0" cannot be aliased to angle-bracketed include <%1>'
H136E4A788F48: '雙引號包含路徑 "%0" 無法轉為尖括號包含路徑 <%1>'
# 'double-quoted include "%0" in framework header, expected angle-bracketed instead'
H2D4306614026: '框架標頭中使用雙引號包含的 "%0"，應改用尖括號包含'
# 'due to %0 being dllexported%select{|; try compiling in C++11 mode}1'
HB6A4EDE022F4: '由於 %0 被 dllexport 標記 %select{|；嘗試以C++11模式編譯}1'
# 'due to lvalue conversion of the controlling expression, association of type %0 will never be selected because it is %select{of array type|qualified}1'
HE4CE0D7DDF88: '由於控制運算式的左值轉換，類型 %0 的關聯將永遠不會被選取，因為其%select{是陣列類型|已修飾}1'
# 'dump CFG of functions with unknown control flow'
HDBCCF42DD8E1: '匯出具有未知控制流程函數的CFG'
# 'dump CodeView symbol record raw bytes'
HAEF5CAE11C43: '匯出 CodeView 符號記錄的原始位元組'
# 'dump CodeView type record raw bytes from IPI stream'
H689D664ADF5F: '從 IPI 流匯出 CodeView 類型記錄的原始位元組'
# 'dump CodeView type record raw bytes from TPI stream'
H0FC07B9E3139: '從 TPI 流匯出 CodeView 類型記錄的原始位元組'
# 'dump CodeView type records from IPI stream'
H7E10374C5E74: '從 IPI 流匯出 CodeView 類型記錄'
# 'dump CodeView type records from TPI stream'
H4737840A6120: '從 TPI 流匯出 CodeView 類型記錄'
# 'dump FPO records'
H341F7F9C33EE: '匯出 FPO 記錄'
# 'dump Globals hashes'
H39246A122E5B: '匯出全域變數雜湊值'
# 'dump Globals symbol records'
H9634A6AB6723: '匯出全域符號記錄'
# 'dump Linux alternative instructions info'
H92A80825B346: '匯出 Linux 替換指令資訊'
# 'dump Linux kernel PCI fixup table'
H0391F2419EB1: '匯出 Linux 核心 PCI 修正表'
# 'dump Linux kernel SMP locks'
HF372737C565A: '匯出 Linux 核心 SMP 鎖定'
# 'dump Linux kernel exception table'
HD3701232B9AB: '匯出 Linux 核心例外表'
# 'dump Linux kernel paravitual patch sites'
HAD29F02859C4: '傾印 Linux 核心 paravitual 补丁位置'
# 'dump Linux kernel static calls'
HBDFDCB9108E1: '傾印 Linux 核心靜態調用'
# 'dump Linux kernel static keys jump table'
HF51D39901B0D: '傾印 Linux 核心靜態鍵跳轉表'
# 'dump PDB String Table'
H21DF5A80DD1F: '傾印 PDB 字串表'
# 'dump PDB String Table Details'
H5264906CCB27: '傾印 PDB 字串表詳細資料'
# 'dump PDB named stream table'
HD3F8AEE8FAA4: '傾印 PDB 命名流表'
# 'dump Publics hashes and address maps'
H982F0D86E5A4: '傾印 Publics 哈希和地址映射'
# 'dump Publics stream data'
H77C736E1764D: '傾印 Publics 流資料'
# 'dump all BAT tables'
H2473A7E7E1DA: '傾印所有 BAT 表'
# 'dump backreferences'
H60EF9FD249CA: '傾印反向引用'
# 'dump callgraph to the given file'
H3F328C977475: '將呼叫圖傾印至指定的檔案'
# 'dump compiland information'
H6229647CD528: '傾印編譯單元資訊'
# 'dump cross module exports (DEBUG_S_CROSSSCOPEEXPORTS subsection)'
HBA659F46571B: '傾印跨模組導出（DEBUG_S_CROSSSCOPEEXPORTS 子區段）'
# 'dump cross module imports (DEBUG_S_CROSSSCOPEIMPORTS subsection)'
H26F5B6DD5D0E: '傾印跨模組導入（DEBUG_S_CROSSSCOPEIMPORTS 子區段）'
# 'dump file information'
HE35AD70400C4: '傾印檔案資訊'
# 'dump file summary'
HBC127C99D732: '傾印檔案摘要'
# "dump function CFGs to graphviz format after each stage;enable '-print-loops' for color-coded blocks"
H790226C2A523: "在每個階段後將函數控制流圖（CFG）轉存為Graphviz格式；啟用 '-print-loops' 以顯示彩色區塊"
# 'dump function into assembly'
H160A471B29E4: '將函數轉存為組裝語言'
# 'dump id hashes and index offsets'
H45ABCE63A690: '轉存ID雜湊與索引偏移量'
# 'dump inlinee line information (DEBUG_S_INLINEELINES subsection)'
HD3FD0B06365E: '轉存內聯函數行資訊（DEBUG_S_INLINEELINES子區段）'
# 'dump jitted objects'
HC6CCA4501C84: '轉存即時編譯物件'
# 'dump module symbols'
H1047966FD40D: '轉存模組符號'
# 'dump parsed bolt data for debugging'
H1E6D3BB027F8: '轉存已解析的bolt資料以供除錯'
# 'dump public / global common record stream'
H582CCEB02839: '轉存公開/全域共用記錄串流'
# 'dump raw ORC unwind information (sorted)'
H3C7746AFAC8F: '轉存原始ORC解堆疊資訊（已排序）'
# 'dump section contributions'
HD1F222CEF84F: '轉存區段貢獻資訊'
# 'dump section map'
H3816E8108BF5: '轉存區段映射'
# 'dump source file/line information (DEBUG_S_LINES subsection)'
HD995BB7B3DC0: '轉存原始檔/行資訊（DEBUG_S_LINES子區段）'
# 'dump statistics on the number and size of types transitively referenced by symbol records'
H63F7F6E11F53: '轉存符號記錄中間接引用的類型數量與大小的統計資料'
# "dump subsections from each module's debug stream"
HFC99948BE195: '轉存每個模組除錯串流的子區段'
# 'dump summary of the PDB streams'
H81F82DCB9C94: '轉存PDB串流的摘要'
# 'dump the Pre-FIR tree prior to FIR generation'
H1C6BBDF08715: '在生成FIR之前轉存Pre-FIR樹結構'
# 'dump the preprocessed tokens'
H80F7445EE14A: '傾印預處理過的記號'
# 'dump the symbol table'
H8EF419A2DB2C: '傾印符號表'
# "dump the symbols record's all children."
HB63145DD7309: '傾印符號記錄的所有子項目。'
# "dump the symbols record's all parents."
H7B31FDBBCCB3: '傾印符號記錄的所有父項目。'
# 'dump the syntax tree'
H63FBC9209EA6: '傾印語法樹'
# 'dump type hashes and index offsets'
H02D59206CDC4: '傾印類型雜湊值與索引偏移量'
# 'dumps the generated benchmark object to disk and prints a message to access it'
H7BC6D646456E: '將產生的效能測試物件寫入磁碟並印出訊息以存取它'
# "duplicate %0 clause in an 'external_source_symbol' attribute"
H3523FE9C404F: "在 'external_source_symbol' 屬性中重複的 %0 子句"
# "duplicate '%0' declaration specifier"
HD8ED5E5CBF0B: "重複的宣告指定詞 '%0'"
# "duplicate 'virtual' in base specifier"
HA0A16A07E97F: "基類指定中的重複'虛基類'"
# "duplicate asm qualifier '%0'"
HE8EA4F072983: "重複的asm限定詞 '%0'"
# "duplicate attribute subject matcher '%0'"
H1D5786B873EA: "重複的屬性主體匹配器 '%0'"
# "duplicate case value '%0'"
H4BDEA82874BB: "重複的case值 '%0'"
# "duplicate case value: '%0' and '%1' both equal '%2'"
HCE899F8A3E5C: "重複的case值：'%0' 和 '%1' 都等於 '%2'"
# 'duplicate code segment specifiers'
HBEFD6978776A: '重複的程式碼段指定項'
# 'duplicate declaration of method %0'
HA0EF6CBBD7AC: '方法 %0 的重複宣告'
# 'duplicate default generic association'
H2C51601AE456: '重複的預設泛型關聯'
# 'duplicate definition of category %1 on interface %0'
HECFD78DC0BC9: '介面 %0 上的類別 %1 的重複定義'
# 'duplicate explicit instantiation of %0'
HDBC529CD9977: '%0 的明確實體化的重複宣告'
# 'duplicate explicit instantiation of %0 ignored as a Microsoft extension'
HDA2A4AABFB51: '忽略明確實例化 %0 的重複宣告，因Microsoft擴展規則'
# 'duplicate interface definition for class %0'
H95CB7C0C6F7F: '類 %0 的介面定義重複'
# 'duplicate key in dictionary literal'
H048B82F688D2: '字典文字中重複的鍵'
# 'duplicate macro parameter name %0'
H066136189F8C: '重複的宏參數名稱 %0'
# 'duplicate member %0'
HC0ECCD41D310: '重複的成員 %0'
# "duplicate modifier '%0' in '%1' clause"
HF11C4EF9CA32: "在 '%1' 子句中重複的修飾符 '%0'"
# "duplicate module file extension block name '%0'"
HCCAD463A8663: "重複的模組檔案擴展區塊名稱 '%0'"
# 'duplicate nullability specifier %0'
HBA9CD0A409AC: '重複的nullability指定符 %0'
# 'duplicate parameter modifier %0'
H6D49784340BA: '重複的參數修飾符 %0'
# 'duplicate protocol definition of %0 is ignored'
HD20F74839349: '忽略 %0 的重複協定定義'
# 'duplicate unconditional branches that cross a cache line'
H33FDED0520CF: '跨越快取線的無條件分支重複出現'
# 'duplicate use of asm operand name "%0"'
H3EAACD3C87CF: '重複使用asm運算子名稱 "%0"'
# "duplicated command '%select{\\|@}0%1'"
H76B78FD8FF48: "重複的命令 '%select{\\|@}0%1'"
# 'during field initialization in %select{this|the implicit default}0 constructor'
H865BE3842864: '在%select{這個|隱式預設}0建構函式中進行成員變數初始化時'
# 'during template argument deduction for %select{class|variable}0 template %select{partial specialization |}1%2 %3'
H7650D46B8E2E: '在%select{類別|變數}0模板%select{部分特化 |}1%2 %3 的參數推導期間'
# 'dxc compatibility options.'
H3AF127D95E36: 'Dxc相容選項。'
# 'dxv not found; resulting DXIL will not be validated or signed for use in release environment'
H6BC661D7D75A: 'dxv未找到；生成的DXIL將無法被驗證或簽署以供發布環境使用'
# 'dynamic exception specifications are deprecated'
H37FC9EB13E92: '動態例外說明已被棄用'
# 'dynamic exception specifications with types are currently ignored in wasm'
H3D36CC52AFBF: '在wasm中目前會忽略帶有類型的動態例外說明'
# 'dynamic initialization is not supported for __device__, __constant__, __shared__, and __managed__ variables'
H6251875A88D3: '__device__、__constant__、__shared__ 和 __managed__ 變數不支援動態初始化'
# "dynamic library symbol '%0' is %select{weak defined|thread local}1, but its declaration is not"
H876356229227: "動態庫符號 '%0' 是%select{弱定義|執行緒局部}1，但其宣告並非如此"
# 'dynamic memory allocation is not permitted in constant expressions until C++20'
H63A7F05406AD: '動態記憶體配置在 C++20 之前不允許用於常數運算式'
# 'dynamic property cannot have instance variable specification'
HD37DA789564D: '動態屬性不能指定實體變數規格'
# 'dynamic_cast will not work since RTTI data is disabled by %select{-fno-rtti-data|/GR-}0'
HBD4085CEECCB: 'dynamic_cast 將無法運作，因為 RTTI 資料被 %select{-fno-rtti-data|/GR-}0 禁用'
# 'editor placeholder in source file'
H8455BF28630F: '來源檔案中的編輯器占位符'
# "effects conflict when merging declarations; kept '%0', discarded '%1'"
H73408A047417: "合併宣告時效果衝突；保留 '%0'，棄用 '%1'"
# 'elaborated enum specifier cannot be declared as a friend'
H7321A1B2921E: '枚舉擴充說明無法宣告為朋友'
# 'element %0 also has value %1'
HFCF33BA58954: '元素 %0 也具有值 %1'
# 'element %0 has been implicitly assigned %1 which another element has been assigned'
H72D209AC7B7A: '元素 %0 已隱式指定 %1，而另一元素已指定相同值'
# 'eliminate unreachable code'
H5CECE35D9DC9: '移除無法達成的程式碼'
# 'ellipsis in pack %select{|init-}0capture must appear %select{after|before}0 the name of the capture'
H6C27D3CFC7C1: '封包 %select{|init-}0 捕獲中的省略號必須出現在捕獲名稱%select{之後|之前}0'
# 'embedded and GOT-based position independence are incompatible'
H471F7EE0F065: '嵌入式與 GOT 基底的位元元位置獨立性不相容'
# 'embedding a #%0 directive within macro arguments is not supported'
HB9B077BA7EC9: '在宏參數內嵌入 #%0 指令不受支援'
# 'embedding a directive within macro arguments has undefined behavior'
HD8530107105F: '在宏參數內嵌入指令具有未定義行為'
# 'emit JSON'
H65D5678CB372: '產生 JSON'
# 'emit YAML'
H54F0FFD710F0: '產生 YAML'
# 'emit normal text output (default)'
HED43B52325DA: '產生一般文字輸出（預設）'
# 'emit warnings'
H020A72B2E05B: '發出警告'
# 'empty %0 cannot be composed with named ones'
HE7EB612973FC: '空的 %0 無法與已命名的結合'
# 'empty %select{struct|union}0 is a GNU extension'
H758BF913FE7C: '空的 %select{struct|union}0 是 GNU 擴充功能'
# 'empty case range specified'
H15C9A1C7CC9D: '指定了空的 case 範圍'
# 'empty character constant'
H277FE12896EE: '空的字元常數'
# "empty delimited universal character name; treating as '\\' '%0' '{' '}'"
HF9BFC93E5104: "界定的通用字元名稱為空；將其視為 '\\' '%0' '{' '}'"
# "empty expression statement has no effect; remove unnecessary ';' to silence this warning"
HE7735A8B2ADE: "空的運算式陳述式沒有效果；移除不必要的 ';' 以消除此警告"
# 'empty filename'
H1CC4DB7178D7: '空的檔案名稱'
# "empty initialization statement of '%select{if|switch|range-based for}0' has no effect"
HCB0D32A02160: "'%select{if|switch|range-based for}0' 的空初始化陳述式沒有效果"
# 'empty macro arguments are a C99 feature'
HD178344D06D5: '空的宏參數是 C99 的功能'
# 'empty macro arguments are incompatible with C++98'
HE94FA0985A16: '空的宏參數與 C++98 不相容'
# 'empty modifier-specification-list is not allowed'
HB0857A4C55BC: '空的修飾規格清單是不允許的'
# "empty paragraph passed to '%select{\\|@}0%1' command"
H38E7CAD895AE: "傳遞給 '%select{\\|@}0%1' 命令的空段落"
# 'empty parentheses interpreted as a function declaration'
H058E44413EA1: '將空的括號解讀為函數宣告'
# 'empty symbolic operand name in inline assembly string'
H2DC9E2773A21: '行內組合語言字串中的空符號操作數名稱'
# 'enable '
H15F13B12A39B: '啟用 '
# 'enable CUDA Fortran'
H7782720B2BB2: '啟用 CUDA Fortran'
# 'enable PC Relative linker optimization'
HB16456951215: '啟用 PC 相對位址連結器鬆弛優化'
# 'enable all attributor runs'
HDC600719482C: '啟用所有 attributor 執行階段'
# 'enable all debugging printout'
H74F2F5BCE1B3: '啟用所有除錯列印輸出'
# 'enable all peephole optimizations'
HDB0605F9FA2D: '啟用所有小孔優化'
# 'enable call graph SCC attributor runs'
H3201C4D45BA3: '啟用調用圖 SCC 屬性分析器運行'
# 'enable coalescing of duplicate branches for PPC'
HF8CFF517B8BE: '啟用 PPC 的重複分支合併'
# 'enable const and copy propagation after tail duplication'
H9919F0504195: '在尾部複製後啟用 const 和拷貝傳播的優化'
# 'enable elimination of sign-extensions'
HF1685FA60FF7: '啟用消除符號擴展'
# 'enable elimination of zero-extensions'
H64FB2468ED4F: '啟用消除零擴展'
# 'enable extended encoding of block type signature'
HCB2363578F85: '啟用區塊類型簽名的擴展編碼'
# 'enable fixed form'
H94C246A27D7E: '啟用固定格式'
# 'enable load elimination using memory profiling data when performing ICP'
HF69B8E887DB3: '在執行 ICP 時使用記憶體剖析資料進行載入消除'
# 'enable module-wide attributor runs'
H6A1678301319: '啟用模組級別的屬性分析器運行'
# 'enable openacc'
HCDE854697CA7: '啟用 OpenACC'
# 'enable openmp'
H1CFA464A8305: '啟用 OpenMP'
# 'enable openmp GPU target codegen'
HFFBCDE42BA97: '啟用 OpenMP GPU 目標程式碼生成'
# 'enable openmp device compilation'
H87F22E3808C9: '啟用 OpenMP 裝置端編譯'
# 'enable optimization of conditional traps'
HE76CA42D1102: '啟用條件陷阱優化'
# 'enable peephole optimizations'
HCB5CF649C604: '啟用小孔優化'
# 'enable preservation of all attributes. even those that are unlikely to be useful'
H13B51E3CE008: '保留所有屬性，即使這些屬性可能沒有用'
# 'enable preservation of attributes throughout code transformation'
H580FCE5CF0E9: '啟用程式碼轉換過程中的屬性保留'
# 'enable register pressure reduce in machine combiner pass.'
H357058DB4C32: '啟用機器combiner pass中的寄存器壓力降低'
# 'enable safe stack coloring'
H95A282232AD0: '啟用安全堆疊著色'
# 'enable safe stack layout'
HCB2AFC2C2D37: '啟用安全堆疊佈局'
# 'enable software prefetching on PPC'
H5C8D5DA8AA2D: '在PPC上啟用軟體預取'
# 'enable splitting of the restore block if possible'
HFB2E82BFA087: '若可能，啟用restore區塊的分割'
# 'enable the feature when using profile data'
H983F48A83B4D: '在使用剖析資料時啟用此功能'
# 'enable the feature with/wo profile data'
HA9F0B8DA8301: '有或無剖析資料時啟用此功能'
# 'enable the shrink-wrapping pass'
H7A4C304F5A12: '啟用shrink-wrapping pass'
# 'enable use of redzone on AArch64'
H0CF57E62B75D: '在AArch64上啟用redzone的使用'
# 'enable/disable all ARC Optimizations'
H0DFE6EE5AB14: '啟用/停用所有ARC優化'
# 'enclose %0 in %select{an @available|a __builtin_available}1 check to silence this warning'
HC0011ACD5CEF: '將 %0 包裝在 %select{@available的檢查|__builtin_available的檢查}1中以消除此警告'
# 'encoding of %0 type is incomplete because %1 component has unknown encoding'
HE63ED9F43B42: '%0 類型的編碼不完整，因為 %1 組成部分具有未知的編碼'
# "encoding prefix '%0' on an unevaluated string literal has no effect%select{| and is incompatible with c++2c}1"
HFB264777D8F6: "在未計算的字串字面值上使用編碼前綴 '%0' 無效 %select{|且與c++2c不相容}1"
# 'end tag'
HE76165194C35: '結束標籤'
# "entering module '%0' due to this pragma"
H00CF7F723C1C: "因這個pragma進入模組 '%0'"
# 'enum %0 was explicitly specialized here'
H888313DD02EB: '枚舉 %0 在此處被明確專門化'
# 'enumeration %0 is incomplete'
HACD4B99390E7: '枚舉 %0 不完整'
# 'enumeration cannot be a template'
H0777CF5091AE: '枚舉不能是範本'
# 'enumeration previously declared as %select{un|}0scoped'
H979505490BD1: '枚舉先前已宣告為%select{未作用域|}0 作用域枚舉'
# 'enumeration previously declared with %select{non|}0fixed underlying type'
H8C078F2C2E0F: '枚舉先前已宣告具有%select{非|}0 固定基礎類型'
# 'enumeration redeclared with different underlying type %0 (was %1)'
H67E555152513: '枚舉重新宣告時使用不同的基礎類型 %0（原為 %1）'
# 'enumeration type %0 is not allowed in a vector conditional'
H71F136014B3C: '在向量條件中不允许使用枚舉類型 %0'
# 'enumeration type in nested name specifier is incompatible with C++98'
HA088A8B3CD7F: '嵌套名稱指定符中的枚舉類型與 C++98 不兼容'
# 'enumeration types with a fixed underlying type are a C++11 extension'
HFFCCC841103E: '具有固定基礎類型的枚舉類型是 C++11 的擴充功能'
# 'enumeration types with a fixed underlying type are a C23 extension'
H463F9486C53D: '具有固定基礎類型的枚舉類型是 C23 的擴充功能'
# 'enumeration types with a fixed underlying type are a Microsoft extension'
H6BC03602C783: '具有固定基礎類型的枚舉類型是 Microsoft 的擴充功能'
# 'enumeration types with a fixed underlying type are incompatible with C standards before C23'
H39FE50255F32: '具有固定基礎類型的枚舉類型與 C23 之前的所有 C 標準不兼容'
# 'enumeration types with a fixed underlying type are incompatible with C++98'
H73924A0CCAED: '具有固定基礎類型的枚舉類型與 C++98 不兼容'
# 'enumeration value %0 is out of range of flags in enumeration type %1'
H4F8DF0E727E1: '枚舉值 %0 超出枚舉類型 %1 中標記的範圍'
# 'enumeration values exceed range of largest integer'
HC084754F6A8B: '枚舉值超出最大整數類型的範圍'
# 'enumerations cannot be explicitly instantiated'
H997CA3993586: '枚舉無法被明確實體化'
# 'enumerator %0 does not exist in instantiation of %1'
H3D7F75D140F9: '在 %1 的實體化中不存在枚舉符 %0'
# 'enumerator %0 with value %1 here'
HD8CCFA398CFA: '此處的枚舉符 %0 具有值 %1'
# 'enumerator value %0 is not representable in the underlying type %1'
HAB7EC95F417E: '枚舉符值 %0 無法表示為基礎類型 %1'
# 'enumerator value is not representable in the underlying type %0'
H9CDAE4E68DA9: '枚舉符值無法表示為基礎類型 %0'
# 'enums in the Microsoft ABI are signed integers by default; consider giving the enum %0 an unsigned underlying type to make this code portable'
HB2071E0C6A67: 'Microsoft ABI 中的枚舉預設為有符號整數；如需提高代碼的可移植性，建議將枚舉 %0 的基礎類型指定為無符號'
# "environment '%0' is not supported: '%1'"
H88874600742B: "環境 '%0' 不受支援：'%1'"
# "environment variable 'SOURCE_DATE_EPOCH' ('%0') must be a non-negative decimal integer <= %1"
H4F81D6E33B46: "環境變數 'SOURCE_DATE_EPOCH' ('%0') 必須是小於或等於 %1 的非負十進位整數"
# 'environment variable CC_PRINT_HEADERS_%select{FORMAT|FILTERING}0 has invalid value %1'
H69C68EA8FAC0: '環境變數 CC_PRINT_HEADERS_%select{FORMAT|FILTERING}0 具有無效值 %1'
# 'epsilon for benchmark point clustering'
HA3C9480C7F62: '基準點聚類的精確度閾值'
# 'epsilon for detection of when the cluster is different from the LLVM schedule profile values'
HBE4394643CF5: '判斷群集與LLVM調度剖析值不同的精確度閾值'
# 'equality comparison between function pointer and void pointer (%0 and %1)'
HD61C2409F0EE: '函數指標與void指標 (%0 和 %1) 之間的等值比較'
# 'equality comparison with extraneous parentheses'
H461F5EF9D3AE: '與多餘括號的等值比較'
# 'error in backend: %0'
H5E9564F574A6: '後端錯誤：%0'
# "error in loading module '%0' from prebuilt module path"
H9CB0C604EFA6: "無法載入預建模模組路徑中的模組 '%0'"
# "error opening '%0': %1"
H14F257DDD829: "無法開啟 '%0': %1"
# "error opening '%0': required by the CrossTU functionality"
HD1F59176156D: "無法開啟 '%0': 此功能為CrossTU功能所需"
# "error opening file '%0': %1"
H36FA208EA1D0: "無法開啟檔案 '%0': %1"
# "error parsing index file: '%0' line: %1 '<USR-Length>:<USR> <File-Path>' format expected"
HDAED7E913418: "索引檔解析失敗: '%0' 第 %1 行 期望 '<USR-Length>:<USR> <File-Path>' 格式"
# "error reading '%0': %1"
HB78815388E3E: "無法讀取 '%0': %1"
# 'error reading stdin: %0'
HFD3376140ADC: '讀取標準輸入時發生錯誤: %0'
# 'escaped newline between */ characters at block comment end'
H16A52D2449DE: '在區塊註解末尾的*/字符間發現轉義換行符'
# 'exact handling of relational integer ICmp'
H083F931E8E9B: '精確處理整數關係式ICmp'
# "exactly one '%0' directive must appear in the loop body of an enclosing directive"
H3C9E45F0564B: "在封裝指令的迴圈主體中，'%0' 指令必須恰好出現一次"
# "exactly one of 'depend', 'destroy', or 'update' clauses is expected"
H41134C7D7A6A: "期望恰好有一個 'depend'、'destroy' 或 'update' 子句"
# "exactly one of 'inclusive' or 'exclusive' clauses is expected"
H43DE08BE23B9: "期望恰好有一個 'inclusive' 或 'exclusive' 子句"
# 'exception declarator cannot be qualified'
H9E73B1CE7174: '不能對異常聲明符進行限定'
# 'exception model'
HB1632BFA78F0: '例外模型'
# 'exception object of type %0 has %select{private|protected}1 destructor'
H45EFA39B1650: '類型為 %0 的例外物件具有 %select{私有|受保護}1 的析構函數'
# 'exception of type %0 will be caught by earlier handler'
H63736AC525A3: '類型 %0 的例外將被較早的處理程序捕獲'
# 'exception specification in declaration does not match previous declaration'
H02068091298F: '宣告中的例外說明與之前的宣告不一致'
# 'exception specification in explicit instantiation does not match instantiated one'
HB42947FF7AB7: '顯式實例化中的例外說明與實例化版本不符'
# 'exception specification is not available until end of class definition'
HD568DD20B09E: '在類別定義結束前無法使用例外說明'
# 'exception specification needed for member of incomplete class %0'
H64C22CA14EC7: '不完整類別 %0 的成員需要例外說明'
# 'exception specification of %0 uses itself'
H8B7B4ED4974B: '%0 的例外說明使用自身'
# "exception specification of '...' is a Microsoft extension"
H50C368DB8633: "'...' 的例外說明是 Microsoft 扩展"
# 'exception specification of overriding function is more lax than base version'
HBB63D54D7089: '覆寫函數的例外說明比基底版本更寬鬆'
# 'exception specifications are not allowed beyond a single level of indirection'
HB84B4B7EA104: '例外說明不允許超過單層間接層級'
# 'exception specifications are not allowed in %select{typedefs|type aliases}0'
HBAC9EC08A3E9: '%select{typedefs|type aliases}0 中不允許例外規格說明'
# 'exception specifications of %select{return|argument}0 types differ'
H04931F9B5864: '%select{傳回|引數}0 類型的例外說明不同'
# 'excess elements in %select{array|vector|scalar|union|struct}0 initializer'
H6B059251CDF0: '在%select{陣列|向量|純量|聯合|結構}0 的初始化器中有過多元素'
# 'excess elements in char array initializer'
H65240A881DB2: '在字符陣列初始化器中有過多元素'
# 'excess elements in initializer for indivisible sizeless type %0'
HF6B0539A54ED: '在不可分割且無大小類型 %0 的初始化器中有過多元素'
# 'excess precision is requested but the target does not support excess precision which may result in observable differences in complex division behavior%select{|, additional uses where the requested higher precision cannot be honored were found but not diagnosed}0'
H46192DCC4FC7: '要求過度精確，但目標不支援過度精確，這可能導致複雜除法行為的可觀測差異 %select{|, 發現無法滿足的更高精確度要求的其他用例但未診斷}0'
# 'exe called with module IR after each pass that changes it'
H9DCF33C92D4F: '在每個修改模組的 pass 後，將模組 IR 傳遞給 exe'
# 'execute only is not supported for the %0 sub-architecture'
H355C6C44365F: '%0 子架構不支援執行僅模式'
# 'existing instance variable %1 for __weak property %0 must be __weak'
HBE1A4247ED95: '__weak屬性 %0 的現有實例變數 %1 必須為__weak'
# 'existing instance variable %1 for property %0 with %select{unsafe_unretained|assign}2 attribute must be __unsafe_unretained'
H45768C1508E1: '具有 %select{unsafe_unretained|assign}2 屬性的屬性 %0 的現有實例變數 %1 必須為__unsafe_unretained'
# 'existing instance variable %1 for strong property %0 may not be %select{|__unsafe_unretained||__weak}2'
H98A6ABD1A54E: '強屬性 %0 的現有實例變數 %1 不可為 %select{|__unsafe_unretained||__weak}2'
# 'existing instance variable %1 for strong property %0 may not be __weak'
HD554DEC7881B: '強屬性 %0 的現有實例變數 %1 不可為__weak'
# 'exit after writing aggregated data file'
H8BF29D13B0F2: '寫入聚合資料檔後退出'
# 'expanding this definition of %0'
H5BA1B50B21D1: '展開 %0 的此定義'
# 'expansion of date or time macro is not reproducible'
H816E771096AD: '日期或時間宏的展開不可重複產生'
# 'expansion of macro %0 requested here'
H97F2144252C9: '這裡請求展開宏 %0'
# "expansion of predefined identifier '%0' to a string literal is a Microsoft extension"
H89888E84B8EB: "將預定義識別項 '%0' 展開為字串文字是Microsoft擴充"
# 'expected "FILENAME" or <FILENAME>'
H6038B7E6D091: '期望 "FILENAME" 或 <FILENAME>'
# "expected #pragma pack parameter to be '1', '2', '4', '8', or '16'"
HA00C06644234: '#pragma pack 參數應指定為「1」「2」「4」「8」或「16」'
# 'expected %0'
H1C2353E37609: '期望 %0'
# 'expected %0 at end of module'
H0F6B0905AE5F: '在模組結尾處期望 %0'
# "expected %0 in OpenMP clause '%1'"
HC79E103ACDFE: "在 OpenMP 子句 '%1' 中期望 %0"
# 'expected %0 or %1'
HC08F459555DA: '期望 %0 或 %1'
# 'expected %0; %1 is a keyword in Objective-C++'
H62A445966708: '期望 %0; %1 是 Objective-C++ 的關鍵字'
# 'expected %1 after %0'
H5879CE8F4818: '在 %0 後期望 %1'
# "expected %select{'enable', 'disable', 'begin' or 'end'|'disable'}0 - ignoring"
H1B18CF6CA096: "期望 %select{'enable', 'disable', 'begin' 或 'end'|'disable'}0 - 忽略"
# "expected %select{'match'|'match', 'adjust_args', or 'append_args'}0 clause on 'omp declare variant' directive"
HED7B3D66D419: "在 'omp declare variant' 指令上期望 %select{'match'|'match', 'adjust_args', 或 'append_args'}0 子句"
# "expected %select{'val' modifier|one of 'ref', val' or 'uval' modifiers}0"
HCC26F8F297FB: "期望 %select{val 修飾符|'ref'、val' 或 'uval' 修飾符之一}0"
# 'expected %select{assignment|assignment, compound assignment, increment, or decrement}0 expression'
H2BC7EE32B904: '期望 %select{賦值|賦值、複合賦值、遞增或遞減}0 表達式'
# "expected %select{identifier after '.' in |}0module name"
HF095089F6D4D: "在 '.' 後期望 %select{識別符|}0 模組名稱"
# 'expected %select{identifier|unqualified-id}0'
HC1969BE019B7: '期望 %select{識別符|unqualified-id}0'
# 'expected %select{library|framework}0 name as a string'
H5FD987168935: '期望以字串形式指定 %select{函式庫|框架}0 名稱'
# "expected %select{module exclusion with 'exclude'|'export *'}0"
H4175E9BAE37D: "期望 %select{使用 'exclude' 排除模組|'export *'}0"
# "expected '#pragma omp end declare %select{target|variant}0'"
H7B3C6216417A: "期望 '#pragma omp end declare %select{target|variant}0'"
# "expected '#pragma omp end declare target' at end of file to match '#pragma omp %0'"
H25BEC71CAA92: "在檔案結尾處期望 '#pragma omp end declare target' 以匹配 '#pragma omp %0'"
# "expected '#pragma unused' argument to be a variable name"
HE4429A749432: "期望 '#pragma unused' 參數為變數名稱"
# "expected '%0' after the %1; '%0' assumed"
HB08F71D9B939: "在 %1 後期望 '%0'；假設 '%0'"
# "expected '%0' clause with an argument on '#pragma omp %1' construct"
HA803E7993B4F: "在 '#pragma omp %1' 建構中，%0 子句期望帶有參數"
# "expected '(' after '%0'"
HA365863454FD: "在 '%0' 後期望 '('"
# "expected '(' for function-style cast or type construction"
H95D0E6661AB2: "因為函數式轉換或類型建構，期望 '('"
# "expected ')' after '%0'"
H068274655B04: "在 '%0' 後期望 ')'"
# "expected ')' in preprocessor expression"
H9FA29BAED1EF: "在預處理器表達式中期望 ')'"
# "expected ')' or ',' after '%0'"
HD115318388CA: "在 '%0' 後期望 ')' 或 ','"
# "expected ')' or ',' in '#pragma %0'"
H97FBD869E75F: "在 '#pragma %0' 中期望 ',' 或 ')'"
# "expected '+' or '-' operation"
H193C159A95C7: "期望 '+' 或 '-' 運算"
# "expected ',' after conflicting module name"
H307B5FE6EEA1: "在衝突模組名稱後期望 ','"
# "expected ',' after interop modifier"
HBE15766F267C: "在interop修飾符後期望 ','"
# "expected ',' in '#pragma %0'"
H80B3D004C35A: "在 '#pragma %0' 中期望 ','"
# "expected ',' or ')' after iterator specifier"
H5B885E53A966: "在迭代器規範後期望 ',' 或 ')'"
# "expected ',' or ')' at end of property accessor list"
H90761748BDB7: "在屬性存取器清單末尾期望 ',' 或 ')'"
# "expected ',' or ')' in '%0' %select{clause|directive}1"
H27E43F9D4E4C: "在 '%0' %select{子句|指令}1 中期望 ',' 或 ')'"
# "expected ',' or '>' in template-parameter-list"
HE6FA48C9A81A: "在模板參數清單中期望 ',' 或 '>'"
# "expected ',' or ']' in lambda capture list"
H01C14BB9E6E5: "在lambda捕獲清單中期望 ',' 或 ']'"
# "expected '->' before expression type requirement"
H25053402E92B: "在表達式類型要求之前期望 '->'"
# "expected '.' after pragma attribute namespace %0"
H6D0DBF9112AD: "在 pragma 屬性命名空間 %0 後期望 '.'"
# "expected '::' after '__super'"
HFBD8EE4CC424: "在 '__super' 後期望 '::'"
# "expected ';' after %0 statement"
H26F61B7787AD: "在 %0 語句後期望 ';'"
# "expected ';' after '%0'"
HC22BB7A01636: "在 '%0' 後期望 ';'"
# "expected ';' after attribute list"
HC367299E9BFD: "在屬性清單後期望 ';'"
# "expected ';' after expression"
H26209FD52998: "在運算式後期望 ';'"
# "expected ';' after method prototype"
H4DCD5C7E2BCB: "在方法原型後期望 ';'"
# "expected ';' after module name"
H20B27913626E: "在模組名稱後期望 ';'"
# "expected ';' after namespace name"
HAAD5C65924B6: "在命名空間名稱後期望 ';'"
# "expected ';' after private module fragment declaration"
H868380AB5A37: "在私有模組片段宣告後期望 ';'"
# "expected ';' after top level declarator"
H3A247DA7CE56: "在頂層宣告符後期望 ';'"
# "expected ';' at end of declaration"
HA8E976B320DC: "在宣告結尾處期望 ';'"
# "expected ';' at end of declaration list"
HA684210D419F: "在宣告清單結尾處期望 ';'"
# "expected ';' at end of requirement"
HDCCCFEC70AB1: "在需求結尾處期望 ';'"
# "expected ';' in 'for' statement specifier"
H2C47358FD75D: "在 'for' 語句指定項中期望 ';'"
# "expected '<' after '%0'"
H1010291C9C7B: "在 '%0' 後期望 '<'"
# "expected '= constant-expression' or end of enumerator definition"
H01AC9A3D13F6: "期望 '= constant-expression' 或列舉定義結尾"
# "expected '=' after '%0'"
H46EA9025A033: "在 '%0' 後期望 '='"
# "expected '=' after diagnostic option"
HEF7733E47109: "在診斷選項後期望 '='"
# "expected '=' following '#pragma %select{align|options align}0' - ignored"
HCE08A9B54E2F: "在 '#pragma %select{align|options align}0' 後期望 '=' 符號 - 已忽略"
# "expected '=' following '#pragma clang section %select{invalid|bss|data|rodata|text|relro}0'"
H5BC8FFE8057E: "在 '#pragma clang section %select{invalid|bss|data|rodata|text|relro}0' 後期望 '=' 符號"
# "expected '=' for Objective-C getter"
H60371309B60A: "在 Objective-C getter 後期望 '=' 符號"
# "expected '=' for Objective-C setter"
H8ACB8C307A32: "在 Objective-C setter 後期望 '=' 符號"
# "expected '=' in iterator specifier"
H160A5CC58E68: "在迭代器指定項後期望 '=' 符號"
# "expected '=' or another designator"
H0EFFC0B249A7: "期望 '=' 運算子或另一個設計符"
# "expected '==' operator for 'weak' clause"
H3CB2580D57FE: "在 'weak' 子句中期望 '==' 運算子"
# "expected 'ON' or 'OFF' or 'DEFAULT' in pragma"
HE0167BADEC73: "在 pragma 中期望 'ON'、'OFF' 或 'DEFAULT' - 已忽略"
# "expected ']' to close attribute"
H21FBE19AC5CE: "期望以 ']' 來關閉屬性"
# "expected '__except' or '__finally' block"
HF5A94EBD6434: "期望 '__except' 或 '__finally' 區塊"
# "expected 'align' following '#pragma options' - ignored"
H851698FD662C: "在 '#pragma options' 後期望 'align' - 已忽略"
# "expected 'auto' or 'decltype(auto)' after concept name"
H0C6E25C16A3C: "在概念名稱後期望 'auto' 或 'decltype(auto)'"
# "expected 'begin' or 'end'"
HE7122B95D2E3: "期望 'begin' 或 'end'"
# "expected 'bind' clause for 'loop' construct without an enclosing OpenMP construct"
H5C3B8520C88C: "在未被 OpenMP 結構包圍的 'loop' 結構中，期望 'bind' 子句"
# "expected 'case' keyword before expression"
H2E3235608C64: "在表達式前期望 'case' 關鍵字"
# "expected 'compare' clause with the '%0' modifier"
H19AACB74DA99: "期望具有 '%0' 修飾符的 'compare' 子句"
# "expected 'compiler', 'lib', 'user', or a string literal for the section name in '#pragma %0' - ignored"
H516A6D363B4D: "在 '#pragma %0' 的區塊名稱中期望 'compiler'、'lib'、'user' 或字串常數 - 已忽略"
# "expected 'get' or 'put' in property declaration"
HB1588A447E94: "在屬性宣告中期望 'get' 或 'put'"
# "expected 'introduced', 'deprecated', or 'obsoleted'"
HA5AD3805D7B0: "期望 'introduced'、'deprecated' 或 'obsoleted'"
# "expected 'language', 'defined_in', 'generated_declaration', or 'USR'"
HC6089B1E2A7C: "期望 'language'、'defined_in'、'generated_declaration' 或 'USR'"
# "expected 'push', 'pop', or '(' after '#pragma clang attribute'"
H6F226585166A: "在 '#pragma clang attribute' 後面期望 'push'、'pop' 或 '('"
# "expected 'reduction' clause with the 'inscan' modifier"
H2220AF809CD1: "期望帶有 'inscan' 修飾符的 'reduction' 子句"
# "expected 'this' following '*' in lambda capture list"
HAD95524E40D1: "在 lambda 捕獲清單中的 '*' 後期望 'this'"
# "expected 'this' subscript expression on map clause to be 'this[0]'"
HC4A77B8603BE: "在 map 子句中的 'this' 下標運算式應為 'this[0]'"
# "expected 'volatile', 'inline', 'goto', or '('"
H4AA4A0DEF946: "期望 'volatile'、'inline'、'goto' 或 '('"
# "expected 'while' in do/while loop"
H93A6CFE12887: "在 do/while 迴圈中期望 'while'"
# "expected '{' after '\\%0' escape sequence"
H8BB332D21D67: "在 '\\%0' 轉義序列後期望 '{'"
# "expected '{' after base class list"
HF135F437918B: "在基類清單後期望 '{'"
# "expected '{' in compound literal"
H19B6D0E23043: "在複合字面量中期望 '{'"
# "expected '{' to start inferred submodule"
H195C51C6292B: "期望以 '{' 開始推論的子模組"
# "expected '{' to start module '%0'"
H68A4A0E12840: "期望以 '{' 開始模組 '%0'"
# "expected '}'"
HC6CF963022AD: "期望 '}'"
# 'expected HLSL Semantic identifier'
H26323C15C7D3: '期望 HLSL 語法識別符'
# 'expected OpenACC directive'
HC6E13DDCDF20: '期望 OpenACC 指令'
# "expected a 'float', 'double' or '__float128' for the first argument"
H4A7F993B766C: "第一個參數期望為 'float'、'double' 或 '__float128'"
# 'expected a callable expression as %ordinal0 argument to %1, found %2'
H9D110F1CBE18: '期望 %1 的第 %ordinal0 個參數為可調用運算式，但找到 %2'
# 'expected a clang compiler command'
HFF7E5AC24A63: '期望 clang 編譯器命令'
# "expected a class method selector with single argument, e.g., 'colorWithCGColor:'"
H747F5E4807D4: "期望帶有單一參數的類方法選擇器，例如 'colorWithCGColor:'"
# "expected a class name after '~' to name a destructor"
H0B5DBF4FC4A5: "在 '~' 之後期望指定一個類名來命名析構函數"
# 'expected a feature name'
H83F9EEF32768: '期望指定一個功能名稱'
# "expected a field designator, such as '.field = 4'"
HE811DCDC9E5C: "期望指定一個成員變量設計標，例如 '.field = 4'"
# 'expected a foldable binary operator in fold expression'
H442801240371: '在展開表達式中期望指定一個可展開的二元運算子'
# "expected a for, while, or do-while loop to follow '%0'"
H6905E348753C: "期望在 '%0' 後面出現 for、while 或 do-while 迴圈"
# "expected a header attribute name ('size' or 'mtime')"
H7FCC0389B837: "期望指定標頭屬性名稱（'size' 或 'mtime'）"
# "expected a header name after '%0'"
HC5548A9AEA32: "在 '%0' 之後期望指定標頭名稱"
# 'expected a memory order clause'
H8A1509342CF4: '期望指定記憶體順序子句'
# "expected a message describing the conflict with '%0'"
H3712B62CAC8D: "期望描述與 '%0' 的衝突的訊息"
# 'expected a module map file name'
H34A1748EFBBA: '期望指定模組映射檔名稱'
# "expected a module name after '%select{module|import}0'"
H60B4E74C4DAA: "在 '%select{module|import}0' 後面期望指定一個模組名稱"
# "expected a module name in '__building_module' expression"
H3E7D4309A80A: "在 '__building_module' 表達式中期望指定一個模組名稱"
# "expected a module name or '*'"
HA872E74CF2C8: "期望指定一個模組名稱或 '*'"
# 'expected a platform name here'
HB3E385166F04: '在此處期望指定平台名稱'
# "expected a platform name, e.g., 'macos'"
H451496142CA8: "期望指定平台名稱，例如 'macos'"
# 'expected a property name in @synthesize'
HFCD01091BCD1: '在 @synthesize 中期望指定屬性名稱'
# "expected a qualified name after 'typename'"
H3D60DB7C4A2E: "在 'typename' 後面期望指定一個合格名稱"
# "expected a reference to a parameter specified in a 'uniform' clause"
HE4C3AD103D8E: "期望指定在 'uniform' 子句中指定的參數的引用"
# 'expected a reference to an integer-typed parameter'
HD574D7423FC7: '期望一個對整數型態參數的引用'
# "expected a related Objective-C class name, e.g., 'NSColor'"
H1B15D42F8530: "期望一個相關的 Objective-C 類名，例如 'NSColor'"
# "expected a stack label or a string literal for the section name in '#pragma %0' - ignored"
HC98188AB663C: "在 '#pragma %0' 中期望一個區段名稱為堆疊標籤或字面量字符串 - 已忽略"
# "expected a string literal for the section name in '#pragma %0' - ignored"
HE785ABE9BD3E: "在 '#pragma %0' 中期望一個區段名稱為字面量字符串 - 已忽略"
# 'expected a type'
HBF18848DB5D9: '期望一個類型'
# "expected a version of the form 'major[.minor[.subminor]]'"
HD227DA64159B: '期望以 "主要[.次要[.子次要]]" 形式的版本'
# 'expected access to data field'
HB984B4DED1F3: '期望存取資料欄位'
# "expected action or ')' in '#pragma %0' - ignored"
HA826DA8C7E15: "在 '#pragma %0' 中期望操作或 ')' - 已忽略"
# "expected addressable lvalue expression, array element%select{ or array section|, array section or array shaping expression}0%select{| of non 'omp_depend_t' type}1"
H064E98F2C05F: "期望可位址的左值運算式、陣列元素%select{或陣列區段|、陣列區段或陣列形狀運算式}0%select{|的類型非 'omp_depend_t'}1"
# "expected addressable lvalue in '%0' clause"
H5CFFB735C83B: "在 '%0' 子句中期望可位址的左值"
# 'expected addressable reduction item for the task-based directives'
H317F6E6ED5F4: "在目標區域內期望一個 'allocator' 子句；提供 'allocator' 子句或使用具有 'dynamic_allocators' 子句的 'requires' 指令"
# "expected an 'allocator' clause inside of the target region; provide an 'allocator' clause or use 'requires' directive with the 'dynamic_allocators' clause"
H22C155652414: "在 '@' 後面期望一個 Objective-C 指令"
# "expected an Objective-C directive after '@'"
H89CC9A1752F3: "期望 OpenMP 'directive' 或 'sequence' 屬性參數"
# "expected an OpenMP 'directive' or 'sequence' attribute argument"
HB4C47A9C1389: '期望 OpenMP 指令'
# 'expected an OpenMP directive'
H633B99B897DC: "在目標區域內期望一個 'allocator' 運算式；提供 'allocator' 運算式或使用具有 'dynamic_allocators' 子句的 'requires' 指令"
# "expected an allocator expression inside of the target region; provide an allocator expression or use 'requires' directive with the 'dynamic_allocators' clause"
H3E40EF451DD7: "期望 '(' 後面跟一個屬性"
# "expected an attribute after '('"
H1D3F08841FED: '期望一個屬性名稱'
# 'expected an attribute name'
HD93294E62460: '期望屬性名稱'
# "expected an attribute that is specified using the GNU, C++11 or '__declspec' syntax"
H022D0FCF0401: '期望使用 GNU、C++11 或 "__declspec" 語法指定的屬性'
# "expected an environment name, e.g., 'compute'"
HFC224EAC2A19: '期望環境名稱，例如 "compute"'
# "expected an identifier or template-id after '::'"
H640FB5DADE2C: '在 "::" 後期望識別符或 template-id'
# "expected an identifier that corresponds to an attribute subject matcher sub-rule; '%0' matcher %select{does not support sub-rules|supports the following sub-rules: %2|}1"
H9C057C572CE2: "期望對應屬性主體匹配子規則的識別符；'%0' 匹配器 %select{不支援子規則|支援以下子規則： %2|}1"
# 'expected an identifier that corresponds to an attribute subject rule'
H294E4D252009: '期望對應屬性主體規則的識別符'
# "expected an integer argument in '#pragma %0'"
H8B88B2FBB6B4: "在 '#pragma %0' 中期望整數參數"
# "expected an integer or a pointer type of the outer loop counter '%0' for non-rectangular nests"
H7B769AB4785B: "非矩形巢狀結構 '%0' 外層循環計數器需要整數或指標型別"
# "expected at least one %0 clause for '#pragma omp %1'"
H7235197EF029: "'#pragma omp %1' 指令至少需要一個 %0 子句"
# "expected at least one %select{'enter' or 'link'|'enter', 'link' or 'indirect'}0 clause"
H068B5F15FD0D: "需要至少一個 %select{'enter' 或 'link'|'enter'、'link' 或 'indirect'}0 子句"
# "expected at least one %select{'to' or 'link'|'to', 'link' or 'indirect'}0 clause"
HCCB831884601: "需要至少一個 %select{'to' 或 'link'|'to'、'link' 或 'indirect'}0 子句"
# "expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'"
HD1F834BB93F7: "'#pragma omp target update' 需要指定至少一個 'to' 子句或 'from' 子句"
# "expected at least one clause on '#pragma omp %0' directive"
HF2F95AA7B57B: "'#pragma omp %0' 指令需要至少一個子句"
# "expected attribute subject set specifier 'apply_to'"
H235FBF52B9D6: "期望屬性主體集指定符 'apply_to'"
# 'expected binary operation on right hand side of assignment operator'
H56333C6C1143: '在賦值運算子的右邊運算式中期望二元運算'
# 'expected body of lambda expression'
HD20C4511EEC4: '期望 lambda 運算式的主體'
# "expected canonical name for private module '%0'"
H1D8AC0E6D7DF: "私有模組 '%0' 需要指定標準名稱"
# 'expected catch'
H0CF63E912EE1: '期望 catch'
# 'expected class member or base class name'
H3D5CC6CC3E58: '期望類別成員或基底類別名稱'
# 'expected class name'
HE76725D4157E: '期望類別名稱'
# 'expected clause-list or newline in OpenACC directive'
H545847ADF7FD: '在 OpenACC 指令中期望子句列表或新行'
# 'expected comma in macro parameter list'
HDA341FE611DA: '在宏參數列表中期望有逗號'
# 'expected concept name with optional arguments'
H5D07B2CBA3F4: '期望帶有可選參數的概念名稱'
# "expected configuration macro name after ','"
HAB95DA27DF2F: '在逗號後期望配置宏名稱'
# "expected constant sized array of 'omp_alloctrait_t' elements, not %0"
H05FAEDD71E4D: "期望固定大小的 'omp_alloctrait_t' 元素陣列，而不是 %0"
# "expected declarator on 'omp declare mapper' directive"
HB22F9750894D: "在 'omp declare mapper' 指令中期望宣告符"
# 'expected depobj expression'
HE3D01E0D4DF5: '期望depobj表示式'
# 'expected end of directive in pragma'
HCC93595992BD: '在 #pragma 中期望指令的結尾'
# 'expected end of line in preprocessor expression'
HD41DF7404CF0: '在預處理表示式中期望行尾'
# 'expected excluded module name'
H6CF70735EF8C: '期望排除的模組名稱'
# 'expected expression'
HF6BF3F627CA1: '期望表示式'
# 'expected expression containing only member accesses and/or array sections based on named variables'
HB19E72D8D293: '期望僅包含基於命名變數的成員存取和/或陣列區段的表示式'
# 'expected expression with a pointer to a complete type as a base of an array shaping operation'
HB89169C408E0: '期望以指向完整類型的指標為基底的陣列形狀運算表示式'
# 'expected external declaration'
HC14A3D6A28C9: '期望外部宣告'
# 'expected function body after function declarator'
HF961A21CDC61: '在函數宣告符後期望函數主體'
# "expected function or lambda declaration for 'routine' construct"
H6E72FAB495F6: "在 'routine' 結構中期望函數或lambda宣告"
# "expected identifier in '#pragma %0' - ignored"
H05B1FBF9EBC9: '在 "#pragma %0" 中期望識別符 - 已忽略'
# 'expected identifier in macro parameter list'
H94E463CD5EE5: '在宏參數列表中期望識別符'
# "expected identifier or one of the following operators: '+', '-', '*', '&', '|', '^', '&&', or '||'"
H7E170CC2FF20: '期望識別符或下列運算子之一："+", "-", "*", "&", "|", "^", "&&"，或 "||"'
# 'expected identifier or string literal'
H0AF1E0FEC1A8: '期望識別符或字串字面量'
# 'expected identifier or string literal describing a context %select{set|selector|property}0; %select{set|selector|property}0 skipped'
HE89AF4D1E70E: '期望識別符或字串字面量描述的上下文%select{設定|選擇器|屬性}0；%select{設定|選擇器|屬性}0 被跳過'
# "expected identifier specifying the name of the 'omp critical' directive"
HDAF324FC0746: "期望指定 'omp critical' 指令名稱的識別符"
# 'expected identifier that represents an attribute name'
H4FF5B028471D: '期望代表屬性名稱的識別符'
# 'expected initializer'
HC06E564F6549: '期望初始化器'
# "expected integer between %0 and %1 inclusive in '#pragma %2' - ignored"
HD3B45551DCCD: "在 '#pragma %2' 中期望 %0 到 %1 之間的整數（包含邊界） - 被忽略"
# "expected integer literal as value for header attribute '%0'"
H664A6DF4E15C: "期望標題屬性 '%0' 的整數字面量值"
# "expected integer or identifier in '#pragma pack' - ignored"
H76DF3F452A3B: "在 '#pragma pack' 中期望整數或識別符 - 被忽略"
# 'expected integral or pointer type as the iterator-type, not %0'
H630D7FF60D9F: '期望整數型別或指標型別作為迭代器型別，而非 %0'
# "expected interop type: 'target' and/or 'targetsync'"
H4B471B15641F: "期望交譲類型：'target' 和/或 'targetsync'"
# 'expected iterator specification as depend modifier'
HDCFF4384248D: '期望depend修飾符中的迭代器說明'
# 'expected iterator specification as map modifier'
H1207336B4021: '期望map修飾符中的迭代器說明'
# "expected length on mapping of 'this' array section expression to be '1'"
HAB830A5B0BE8: "在 'this' 陣列區段表達式的映射中，期望長度為 '1'"
# "expected list item of scalar type in 'lastprivate' clause with 'conditional' modifier"
HA9ADDE114CE9: "在具有 'conditional' 修飾符的 'lastprivate' 子句中，期望標量類型的清單項目"
# 'expected loop invariant expression'
H5CDAE0534BDA: '期望循環不變式表達式'
# "expected loop invariant expression or '<invariant1> * %0 + <invariant2>' kind of expression"
HB9C142C1B0A5: "期望循環不變式表達式或類似 '<invariant1> * %0 + <invariant2>' 的表達式"
# "expected lower bound on mapping of 'this' array section expression to be '0' or not specified"
H191C7ACE16C2: "在 'this' 陣列區段表達式的映射中，期望下界為 '0' 或未指定"
# "expected lvalue expression%select{ of 'omp_depend_t' type, not %1|}0"
H766F59D547C6: "期望%select{類型為 'omp_depend_t' 的左值表達式，而非 %1|}0"
# "expected member name or ';' after declaration specifiers"
HB82CEE80D58C: "期望成員名稱或 ';' 作為宣告指定符的結尾"
# "expected member name or ';' after declaration specifiers; %0 is a keyword in Objective-C++"
H44CFB0200081: "期望成員名稱或 ';' 作為宣告指定符的結尾；%0 是 Objective-C++ 中的關鍵字"
# 'expected method body'
HA77E865AEFEF: '期望的方法主體'
# 'expected method to %select{read|write}1 %select{dictionary|array}2 element not found on object of type %0'
H7AD9AA6CC51A: '期望在類型 %0 的物件上找不到 %select{讀取|寫入}1 %select{字典|陣列}2 元素'
# "expected modifier in '%0' clause"
HCD7B280DF3B2: "在 '%0' 子句中期望修飾符"
# 'expected module declaration'
H01C99835EAB8: '期望模組宣告'
# 'expected module name'
H1C43BA17D195: '期望模組名稱'
# 'expected name of accessor method'
HC25216EA2EAE: '期望存取器方法名稱'
# 'expected namespace name'
H4C29A4057DC9: '期望命名空間名稱'
# "expected non-wide string literal in '#pragma %0'"
H47A50F5F135C: "在 '#pragma %0' 中期望非寬字元字面量字串"
# "expected one of [bss|data|rodata|text|relro] section kind in '#pragma %0'"
HD85488A58A29: "在 '#pragma %0' 中期望其中一個區段類型：[bss|data|rodata|text|relro]"
# "expected one of the predefined allocators for the variables with the static storage: 'omp_default_mem_alloc', 'omp_large_cap_mem_alloc', 'omp_const_mem_alloc', 'omp_high_bw_mem_alloc', 'omp_low_lat_mem_alloc', 'omp_cgroup_mem_alloc', 'omp_pteam_mem_alloc' or 'omp_thread_mem_alloc'"
H8611A8451129: "在具有靜態存儲的變數中期望預定義的分配器之一：'omp_default_mem_alloc', 'omp_large_cap_mem_alloc', 'omp_const_mem_alloc', 'omp_high_bw_mem_alloc', 'omp_low_lat_mem_alloc', 'omp_cgroup_mem_alloc', 'omp_pteam_mem_alloc' 或 'omp_thread_mem_alloc'"
# 'expected parameter declarator'
HE400FE627646: '期望參數宣告器'
# 'expected parentheses around type name in %0 expression'
H29C3C3BEE053: '在 %0 表達式中類型名稱周圍期望括號'
# "expected parenthesized parameter pack name in 'sizeof...' expression"
H872448706A49: "在 'sizeof...' 表達式中期望帶括號的參數包名稱"
# "expected pointer in '%0' clause, type is %1"
HA28C1D2864FB: "在 '%0' 子句中期望指標，類型是 %1"
# "expected pointer or reference to pointer in 'use_device_ptr' clause"
H8CE170DA7DFD: "在 'use_device_ptr' 子句中期望指標或指向指標的引用"
# 'expected pointer to struct as %ordinal0 argument to %1, found %2'
H2E1D0CCC5B02: '期望將指向結構的指標作為 %1 的第 %ordinal0 個參數，但找到 %2'
# "expected pointer, array, reference to pointer, or reference to array in 'is_device_ptr clause'"
H529E9DB350DF: "在 'is_device_ptr' 子句中期望指標、陣列、指向指標的引用或指向陣列的引用"
# 'expected property name'
H849B19CD5A49: '期望屬性名稱'
# "expected push, pop or a string literal for the section name in '#pragma %0' - ignored"
H4F1921BA3641: "在 '#pragma %0' 中期望 push、pop 或區段名稱的字面量字串，但被忽略"
# 'expected quoted string after equals sign'
H2D60229D01D0: '等號後期望引號包圍的字串'
# "expected reference to one of the parameters of function %0%select{| or 'this'}1"
HD78611AD5D12: "期望引用函數 %0%select{| 或 'this'}1 的其中一個參數"
# 'expected selector for Objective-C %select{setter|getter}0'
HFB2F00048645: '期望 Objective-C %select{設定器|取得器}0 的選擇器'
# 'expected selector for Objective-C method'
HC4CCDD47D676: '期望 Objective-C 方法的選擇器'
# 'expected statement'
HFEEF58AA5565: '期望語句'
# "expected string literal %select{in %1|for diagnostic message in static_assert|for optional message in 'availability' attribute|for %select{language name|source container name|USR}1 in 'external_source_symbol' attribute|as argument of '%1' attribute}0"
HD61709E5D47F: "期望字串字面量 %select{在 %1|在 static_assert 的診斷訊息中|在 'availability' 屬性中的可選訊息|在 'external_source_symbol' 屬性的 %select{語言名稱|來源容器名稱|USR}1 中|作為 '%1' 屬性的參數}0"
# "expected string literal %select{or parenthesized constant expression |}0in 'asm'"
H87FD9C867F0C: "期望字串字面量 %select{或括號包圍的常量運算式 |}0 在 'asm'"
# "expected string literal in '#pragma %0' - ignoring"
H0A31A7BE2E40: "在 '#pragma %0' 中期望字串字面量 - 忽略"
# "expected string literal in 'clause %0' - ignoring"
H25BCA649E0CB: "在 'clause %0' 分句中期望字串字面量 - 忽略"
# 'expected template'
H15B15916EEBA: '期望範本'
# "expected template name after 'template' keyword in nested name specifier"
H49E8E5AAE6BB: "巢狀名稱指定符中的 'template' 關鍵字後期望範本名稱"
# 'expected template parameter'
H112129FF4EB6: '期望範本參數'
# "expected the class name after '~' to name the enclosing class"
HD0B1F9262E8D: "期望在 '~' 後面的類別名稱指定封裝類別"
# 'expected the name of a parameter pack'
H259207509382: '期望參數包的名稱'
# 'expected type parameter name'
H009E83554F48: '期望類型參數名稱'
# 'expected umbrella, header, submodule, or module export'
H13F866613F7D: '期望 umbrella、header、submodule 或 module export'
# 'expected valid context selector in %0'
HF9402AD88CE1: '在 %0 中期望有效的內容選擇器'
# 'expected value in expression'
HC052EF0BAA44: '期望運算式中的值'
# 'expected variable name as a base of the array %select{subscript|section}0'
HBE410C345F41: '期望陣列 %select{下標|區段}0 的基底變數名稱'
# "expected variable name or 'this' in lambda capture list"
H9A94F049DF94: "在lambda捕獲清單中期望變數名稱或 'this'"
# 'expected variable name%select{| or data member of current class}0'
H829F4F463842: '期望變數名稱 %select{|或當前類別的資料成員}0'
# 'expected variable name%select{|, data member of current class}0, array element or array section'
HEAE159C816D1: '期望變數名稱 %select{|、當前類別的資料成員}0、陣列元素或陣列區段'
# 'expected variable of pointer type'
H396A94544855: '期望指標型別的變數'
# "expected variable of the '%0' type%select{|, not %2}1"
H3293A68C1535: "期望型別為 '%0' 的變數 %select{|，而非 %2}1"
# "expected variable%select{| or static data member|, static data member, or non-static data member of current class}0 of type '%1'"
H54FC8A6038F8: "期望型別為 '%1'%select{|或靜態資料成員|、靜態資料成員或當前類別的非靜態資料成員}0的變數"
# 'expected%select{| %1}0 loop iteration variable'
H9F489F0C181E: '期望 %select{| %1}0 迴圈迭代變數'
# "expected%select{| non-const}0 variable of type 'omp_interop_t'"
H7FA31289BDF2: "期望 %select{|非const}0 型別為 'omp_interop_t' 的變數"
# 'expected%select{| one of}0 %1 directive name modifier%select{|s}0'
HF9EF92E2746A: '期望 %select{|其中一個}0 %1 指令名稱修飾詞 %select{|s}0'
# "expecting %0 '%1' to be held at start of each loop"
HFDC07BD9FDE6: "期望迴圈起始處持有 %0 '%1'"
# "expecting %0 '%1' to be held at the end of function"
H696ED076811B: "期望函式結尾處持有 %0 '%1'"
# 'explicit %select{constructor|conversion function|deduction guide}0 is not a candidate%select{| (explicit specifier evaluates to true)}1'
H1B61513FD8B6: '顯式%select{建構函數|轉換函數|推導指引}0 不是候選 %select{| (顯式指定符評估為true)}1'
# 'explicit %select{constructor|deduction guide}0 declared here'
H110462FEE829: '在此處宣告顯式%select{建構函數|推導指引}0'
# 'explicit %select{specialization|instantiation}0 of %select{non-|undeclared }3template %1 %2'
H3111D59957AC: '顯式%select{特化|實例化}0 %select{非宣告|未宣告 }3範本 %1 %2'
# 'explicit call to +initialize results in duplicate call to +initialize'
H39AD5352EF13: '顯式呼叫+initialize 會導致+initialize 的重複呼叫'
# 'explicit call to [super initialize] should only be in implementation of +initialize'
H9E99F53BFF8C: '對[super initialize]的顯式呼叫只能出現在+initialize 實作中'
# "explicit capture of 'this' with a capture default of '=' is a C++20 extension"
HAF0F203BEF2F: "使用 '=' 捕獲預設值時顯式捕獲 'this' 是C++20擴充"
# "explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++20"
H671AAB21DB7A: "使用 '=' 捕獲預設值時顯式捕獲 'this' 與C++20之前標準不相容"
# 'explicit constructor calls are a Microsoft extension'
H07E486E825A8: '顯式建構函數呼叫是Microsoft擴充'
# 'explicit conversion functions are a C++11 extension'
H6D402C6A81B4: '顯式轉換函數是C++11的擴充功能'
# 'explicit conversion functions are incompatible with C++98'
H325DB8CE82A7: '顯式轉換函數與C++98不相容'
# 'explicit data sharing attribute requested here'
HC278594BF276: '在此處要求顯式資料共用屬性'
# 'explicit data sharing attribute, data mapping attribute, or is_device_ptr clause requested here'
H5EF926721360: '在此處要求顯式資料共用屬性、資料映射屬性，或是is_device_ptr子句'
# 'explicit initialization of field %1 will not be enforced in C++20 and later because %2 has a user-declared constructor, making the type no longer an aggregate'
HF3AC30340626: 'C++20及之後版本將不再強制執行此欄位 %1 的顯式初始化，因為 %2 具有使用者宣告的建構函數，使得類型不再是聚合體'
# 'explicit instantiation candidate function %q0 template here %1'
H23B5BDCD19CC: '顯式實體化候選函數模板%q0在此處定義 %1'
# "explicit instantiation cannot be 'constexpr'"
H9A1E5AE786E4: "顯式實體化不能是 'constexpr'"
# "explicit instantiation cannot be 'inline'"
HD5DCEA693BA1: "顯式實體化不能是 'inline'"
# 'explicit instantiation cannot have a storage class'
H2C3AA857F69D: '顯式實體化不能具有儲存類別'
# "explicit instantiation declaration (with 'extern') follows explicit instantiation definition (without 'extern')"
HB1AC2FFED2CF: "帶有 'extern' 的顯式實體化宣告跟隨不帶 'extern' 的顯式實體化定義"
# 'explicit instantiation declaration of %0 with internal linkage'
HF062EFD01A1B: '顯式實體化宣告 %0 具有內部連結性'
# 'explicit instantiation declaration requires a name'
HB6C2B5BBA7F4: '顯式實體化宣告需要名稱'
# "explicit instantiation declaration should not be 'dllexport'"
H2015D0FC9EDD: "顯式實體化宣告不应是 'dllexport'"
# 'explicit instantiation definition is here'
H296BCB0F591A: '顯式實體化定義在此處'
# 'explicit instantiation has dependent template arguments'
H0CCD42687978: '顯式實體化具有依賴式範型參數'
# 'explicit instantiation of %0 does not refer to a function template, variable template, member function, member class, or static data member'
H33CB49EB02C6: '顯式實體化 %0 未引用函數範型、變數範型、成員函數、成員類別或靜態資料成員'
# 'explicit instantiation of %0 in class scope'
HC730DBDD7AE4: '顯式實體化 %0 在類別作用域中'
# 'explicit instantiation of %0 must occur at global scope'
H0F240F08C055: '顯式實體化 %0 必須出現在全域作用域'
# 'explicit instantiation of %0 not in a namespace enclosing %1'
HE49D377AF72F: '顯式實體化 %0 未出現在包裝 %1 的命名空間中'
# 'explicit instantiation of %0 that occurs after an explicit specialization has no effect'
HB36244473793: '在顯式專門化之後的 %0 之顯式實體化無效'
# 'explicit instantiation of %q0 must occur in namespace %1'
HB00768729F8E: '%q0的顯式實體化必須發生在命名空間 %1 中'
# 'explicit instantiation of %q0 must specify a template argument list'
HE88FD9250BA0: '%q0的顯式實體化必須指定模板參數列表'
# 'explicit instantiation of non-templated type %0'
H31C2727CC2AA: '%0（非模板類型）的顯式實體化'
# 'explicit instantiation of typedef %0'
H2C42F0D827C6: '%0（typedef）的顯式實體化'
# 'explicit instantiation of undefined %select{member class|member function|static data member}0 %1 of class template %2'
HCF3C5A632D34: '類模板 %2 的未定義%select{成員類別|成員函數|靜態資料成員}0 %1 的顯式實體化'
# 'explicit instantiation of undefined function template %0'
H5300C0092131: '未定義的函數模板 %0 的顯式實體化'
# 'explicit instantiation of undefined variable template %q0'
H38D285C06249: '未定義的變數模板%q0的顯式實體化'
# 'explicit instantiation refers here'
HBCDCC7E0C7EF: '顯式實體化指向這裡'
# 'explicit instantiation refers to member function %q0 that is not an instantiation'
H500C2DC642A9: '顯式實體化指向非實體化的成員函數%q0'
# 'explicit instantiation refers to static data member %q0 that is not an instantiation'
H07ED3DC3915D: '顯式實體化指向非實體化的靜態資料成員%q0'
# "explicit object parameter cannot have 'void' type"
H5DECA4F1B2FA: "顯式物件參數不能具有 'void' 類型"
# 'explicit object parameters are incompatible with C++ standards before C++2b'
H32F147DF3434: '顯式物件參數與C++2b之前的標準不相容'
# 'explicit ownership qualifier on cast result has no effect'
H3D013C01B086: '轉型結果的顯式所有權修飾符無效'
# 'explicit qualification required to use member %0 from dependent base class'
H469187ADD22A: '使用依賴基類的成員 %0 時需要顯式修飾'
# 'explicit specialization cannot have a storage class'
HADDD65B5ED76: '顯式專門化不能具有儲存類別'
# 'explicit specialization of %0 after instantiation'
HDBBF37665EBE: '%0 的顯式專門化在實體化之後'
# 'explicit specialization of %0 in function scope'
H4AB8E368275F: '函數作用域中的 %0 之顯式專門化'
# "explicit template instantiation cannot have a definition; if this definition is meant to be an explicit specialization, add '<>' after the 'template' keyword"
H88A1F449C08B: "顯式模板實體化不能有定義；如果此定義意圖為顯式專門化，請在 'template' 關鍵字後添加 '<>'"
# 'explicit template parameter list for lambdas is a C++20 extension'
HF9AE6F1B9252: 'lambda的顯式模板參數列表是C++20擴充功能'
# 'explicit template parameter list for lambdas is incompatible with C++ standards before C++20'
H57BCAF2B0340: 'lambda的顯式模板參數列表與C++20之前的C++標準不相容'
# 'explicit(bool) is a C++20 extension'
H07C70F747BCD: 'explicit(bool) 是C++20擴充功能'
# 'explicit(bool) is incompatible with C++ standards before C++20'
H2A0E673F4AE0: 'explicit(bool) 與C++20之前的C++標準不相容'
# 'explicitly assigning value of variable of type %0 to itself%select{|; did you mean to assign to member %2?}1'
HB1C6DD04C662: '將類型 %0 的變數值明確地賦值給自身 %select{|; 是否想賦值給成員 %2？}1'
# "explicitly capture 'this'"
HCF140BF35536: "明確捕獲 'this'"
# 'explicitly cast the argument to size_t to silence this warning'
HBB0D273571B1: '將引數明確轉換為size_t以消除此警告'
# 'explicitly cast the pointer to silence this warning'
H8E24FB4D1062: '將指標明確轉換以消除此警告'
# "explicitly declare getter %objcinstance0 with '%1' to return an 'unowned' object"
H4E2F7B8127D2: "明確宣告getter %objcinstance0 使用 '%1' 以傳回 'unowned' 物件"
# 'explicitly defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator is implicitly deleted'
H811330B8F313: '明確預設的 %select{<ERROR>|等同|三路|等同|關係}0比較運算子被隱式刪除'
# 'explicitly defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 is implicitly deleted'
H4A686915F9DC: '明確預設的%select{預設建構子|複製建構子|移動建構子|複製分配運算子|移動分配運算子|析構子}0被隱式刪除'
# 'explicitly defaulted function was implicitly deleted here'
HF8EF8D3E0A6F: '此明確預設的函數在此處被隱式刪除'
# 'explicitly defaulting this %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 with a type different from the implicit type is incompatible with C++ standards before C++20'
H5E5EF3FDD4E3: '使用與隱式類型不同的類型明確預設此%select{預設建構子|複製建構子|移動建構子|複製分配運算子|移動分配運算子|析構子}0，與C++20之前的C++標準不相容'
# 'explicitly moving variable of type %0 to itself%select{|; did you mean to move to member %2?}1'
H35CC5A2B002D: '明確地將類型 %0 的變數移動到自身 %select{|; 是否想移動到成員 %2？}1'
# 'explicitly specialized declaration is here'
H0E01C428C014: '明確特殊化的宣告在此處'
# 'explicitly-defaulted %select{copy|move}0 assignment operator must return %1'
H36FB5B74F68A: '明確預設的%select{複製|移動}0分配運算子必須傳回 %1'
# 'exponent has no digits'
H17C521E1F810: '指數無數位'
# 'export block begins here'
HBA4BC250A89B: 'export區塊在此處開始'
# 'export declaration appears within anonymous namespace'
H2CCBA9D1C7AA: 'export宣告出現在匿名命名空間內'
# 'export declaration appears within another export declaration'
HECEB46AE53AF: 'export 声明出現在另一個 export 声明內部'
# 'export declaration can only be used on functions'
H2A1BE3778EEF: 'export 声明只能用在函數上'
# 'export declaration can only be used within a module purview'
HA59173758635: 'export 声明只能用在模組的範圍內'
# 'export declaration cannot be empty'
H571FAB6A011E: 'export 声明不能為空'
# 'export declaration cannot be used in a private module fragment'
H22322B0D3EA4: 'export 声明不能用在私有模組片段中'
# 'exported templates are unsupported'
H6166D4F14CA1: '導出的模板不被支援'
# 'expose the ANDI glue bug on PPC'
HC579FD8E0F1D: '暴露 PPC 上的 ANDI 粘合程式 Bug'
# 'expression cannot be followed by a postfix %0 operator; add parentheses'
HBEECC801546A: '表達式不能跟隨後置 %0 運算子；請加上括號'
# 'expression does not compute the number of elements in this array; element type is %0, not %1'
H23C233069DBB: '該表達式不計算此陣列的元素數量；元素類型是 %0，而非 %1'
# "expression evaluates to '%0 %1 %2'"
H64BCD859D7BF: '該表達式評估為 "%0 %1 %2"'
# 'expression has incomplete class type %0'
H58E1F9927C3B: '該表達式具有不完整的類型 %0'
# 'expression is not a string literal'
H3935D8B321FF: '該表達式不是字串文字'
# 'expression is not an %select{integer|integral}0 constant expression'
H03AFF9CF4CF8: '該表達式不是%select{整數|積分}0常量表達式'
# 'expression is not an %select{integer|integral}0 constant expression; folding it to a constant is a GNU extension'
H5CBB867EA1E8: '該表達式不是%select{整數|積分}0常量表達式；將其摺疊為常量是 GNU 擴充功能'
# 'expression is not assignable'
H5F8670A31719: '該表達式不可被賦值'
# 'expression must have integral or unscoped enumeration type, not %0'
H17B3769F086B: '該表達式必須具有整數或未指定範圍的列舉類型，而非 %0'
# 'expression not permitted as operand of fold expression'
H291A77DD522F: '該表達式不得用作摺疊表達式的操作數'
# 'expression requires explicit conversion from %0 to %1'
HB376E0297A16: '該表達式需要從 %0 到 %1 的明確轉換'
# 'expression result unused'
HC432FEDE1001: '該表達式結果未被使用'
# 'expression result unused; assign into a variable to force a volatile load'
HB7AF8EB968E8: '表達式結果未被使用；將結果賦予變數以強制執行 volatile 讀取'
# "expression result unused; should this cast be to 'void'?"
HBBF825FCCB8B: "表達式結果未被使用；是否此轉換應為 'void' 型別？"
# 'expression which evaluates to zero treated as a null pointer constant of type %0'
H0240527F1E90: '評估為零的表達式被視為類型 %0 的空指標常數'
# 'expression with side effects has no effect in an unevaluated context'
H186C82044D81: '具有副作用的表達式在未評估的語境中不會產生任何效果'
# "expression with side effects will be evaluated despite being used as an operand to 'typeid'"
H9C60337CD3B8: "用作 'typeid' 運算元的操作數時，具有副作用的表達式仍會被評估"
# 'extension used'
HD363255C0A95: '使用了擴充語法'
# 'extern "C" language linkage specification begins here'
H7A156727F19D: '在此處開始 extern "C" 語言連結規格'
# 'extern declaration of %0 follows non-extern declaration'
HD31A31C8A91F: '%0 的 extern 宣告跟在非 extern 宣告之後'
# 'extern templates are a C++11 extension'
H1884BE10DDD8: 'extern templates 是 C++11 擴充語法'
# 'extern templates are incompatible with C++98'
H1796556A5B60: 'extern templates 與 C++98 不相容'
# 'external function %0 declared with incompatible types in different translation units (%1 vs. %2)'
HE651F889FA02: '外部函數 %0 在不同翻譯單位中宣告的類型不相容 (%1 vs. %2)'
# 'external variable %0 declared with incompatible types in different translation units (%1 vs. %2)'
H15B2E1B8C6FC: '外部變數 %0 在不同翻譯單位中宣告的類型不相容 (%1 vs. %2)'
# 'external variable %0 defined in multiple translation units'
H1F8D107DE885: '外部變數 %0 在多個翻譯單位中均有定義'
# "extra '&' taking address of overloaded function"
H9A83B3B4D92C: "取得重載函數的地址時多餘的 '&'"
# "extra ';' %select{outside of a function|inside a %1|inside instance variable list|after member function definition}0"
HE280E1BDB8CF: "多餘的 ';' %select{在函數外|在 %1 內|在成員變數清單內|在成員函數定義後}0"
# "extra ';' after member function definition"
H3CA5397D9B51: "在成員函數定義後有多餘的 ';'"
# "extra ';' outside of a function is a C++11 extension"
HEE30E6FFD401: "在函數外使用多餘的 ';' 是 C++11 擴充語法"
# "extra ';' outside of a function is incompatible with C++98"
HB50929FF19FE: "在函數外使用多餘的 ';' 與 C++98 不相容"
# 'extra qualification on member %0'
HEB926F36FA1F: '成員 %0 的多餘資格修飾'
# "extra tokens after attribute in a '#pragma clang attribute push'"
H0F837D0B4BE4: "在 '#pragma clang attribute push' 中屬性後面有多餘的語法元素"
# 'extra tokens at end of #%0 directive'
HBFAC5EAA75A7: '在 #%0 指令末尾有多餘的語法元素'
# "extra tokens at end of '#pragma %0' - ignored"
H2F08FDE9AD4F: "在 '#pragma %0' 末尾有多餘的語法元素 - 已忽略"
# "extra tokens at the end of '#pragma omp %0' are ignored"
HA0D9244B087C: "在 '#pragma omp %0' 末尾有多餘的語法元素已被忽略"
# "extraneous '%0' before ';'"
H8BD122A76CFA: "在 ';' 之前有多餘的 '%0'"
# "extraneous ')' after condition, expected a statement"
HFFE185AD544D: "條件後有多餘的 ')', 期望一個語句"
# "extraneous 'template<>' in declaration of %0 %1"
HE8DEA9984DC2: "在 %0 %1 的宣告中有多餘的 'template<>'"
# "extraneous 'template<>' in declaration of member %0"
H828C24444273: "在成員 %0 的宣告中有多餘的 'template<>'"
# "extraneous 'template<>' in declaration of variable %0"
HFFC1753865A1: "在變數 %0 的宣告中有多餘的 'template<>'"
# "extraneous closing brace ('}')"
H3D189A013717: "多餘的右大括號 ('}')"
# 'extraneous template parameter list in alias template declaration'
HAA68A1EAD59F: '別名模板宣告中有多餘的模板參數清單'
# 'extraneous template parameter list in concept definition'
HE58F30339D76: '概念定義中有多餘的模板參數清單'
# 'extraneous template parameter list in template specialization'
H37A5BAADFAAC: '模板專門化中有多餘的模板參數清單'
# 'extraneous template parameter list in template specialization or out-of-line template definition'
HBFB0FFADD00D: '模板專門化或模板外聯機定義中有多餘的模板參數清單'
# "failed requirement '%0'; 'enable_if' cannot be used to disable this declaration"
H6A26091751B1: "無法滿足要求 '%0'；'enable_if' 無法禁用此宣告"
# "failed to deduce triple for target architecture '%0'; specify the triple using '-fopenmp-targets' and '-Xopenmp-target' instead"
HAEA08639936D: "無法推導目標架構 '%0' 的 triple；請改用 '-fopenmp-targets' 和 '-Xopenmp-target' 指定 triple"
# 'failed to expand response file: %0'
H14746831D212: '無法展開回應檔: %0'
# "failed to find module file for module '%0'"
H265A065BBB4D: "無法找到模組 '%0' 的模組檔"
# "failed to hash content for '%0' because memory buffer cannot be retrieved"
H13A2DD939D67: "無法取得記憶體緩衝區，因此無法為 '%0' 計算雜湊值"
# "failed to process suppression mapping file '%0': %1"
H61E7856A5801: "無法處理抑制映射文件 '%0': %1"
# "failing because %select{environment variable 'FORCE_CLANG_DIAGNOSTICS_CRASH' is set|'-gen-reproducer' is used}0"
HE0DD8241D56F: "失敗原因是 %select{環境變數 'FORCE_CLANG_DIAGNOSTICS_CRASH' 已設置|使用了 '-gen-reproducer' 指令}0"
# 'failure when lexing a character literal'
H36FAC94ACBBF: '在詞法分析字元字面量時失敗'
# 'failure when lexing a numeric literal'
H514A5139F05F: '在詞法分析數值字面量時失敗'
# 'failure when lexing a string literal'
H628F82057288: '在詞法分析字串字面量時失敗'
# 'fallthrough annotation does not directly precede switch label'
H0941315663A3: 'fallthrough 注解未直接位於 switch 標籤之前'
# 'fallthrough annotation in unreachable code'
HF1B980EE596A: '在不可達程式碼中使用 fallthrough 注解'
# 'fallthrough annotation is outside switch statement'
H1D7245256264: 'fallthrough 注解位於 switch 語句外'
# 'fast enumeration variables cannot be modified in ARC by default; declare the variable __strong to allow this'
H0BD569725A75: '快速列舉變數在 ARC 中預設無法修改；宣告變數為 __strong 可允許此操作'
# 'fast register allocator'
HD75005D5488A: '快速寄存器分配器'
# 'feature %0 requires support of %1 feature'
HA4C52697EC12: '功能 %0 需要支援 %1 功能'
# 'feature cannot be %select{introduced|deprecated|obsoleted}0 in %1 version %2 before it was %select{introduced|deprecated|obsoleted}3 in version %4; attribute ignored'
H18649406044A: '功能無法在 %1 版本 %2 %select{引入|棄用|廢棄}0 之前 %select{引入|棄用|廢棄}3 在版本 %4 中；屬性被忽略'
# "feature flag '%0' is ignored since the feature is read only"
H67D49FF0C7F8: "功能旗標 '%0' 被忽略，因該功能為唯讀"
# "feature flag '%0' must start with either '+' to enable the feature or '-' to disable it; flag ignored"
HE0833D141647: "功能旗標 '%0' 必須以 '+' 開頭以啟用該功能，或以 '-' 開頭以停用；旗標被忽略"
# 'field %0 can overwrite instance variable %1 with variable sized type %2 in superclass %3'
H6914F3D605AE: '欄位 %0 可覆寫超類 %3 中型別 %2 （可變長度類型）的實例變數 %1'
# 'field %0 declared as a function'
HEA705CD2A4BF: '欄位 %0 被宣告為函式'
# 'field %0 declared here'
HBC2A949CCB44: '欄位 %0 在此宣告'
# 'field %0 declared with incompatible types in different translation units (%1 vs. %2)'
H9B5B1B6B054E: '欄位 %0 在不同翻譯單元中宣告類型不相容 (%1 對 %2)'
# 'field %0 has type %1 here'
H3B91A03ADD90: '成員變數 %0 在此處的類型為 %1'
# "field %0 in '%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}1' not inside structure"
H161B48990AE3: "在 '%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}1' 中的成員變數 %0 不在結構體內"
# 'field %0 is uninitialized when used here'
H215FDF8256E9: '成員變數 %0 在此處使用時未初始化'
# 'field %0 with variable sized type %1 is not at the end of class'
H33E4FFCBD3EE: '具有可變長度類型 %1 的成員變數 %0 未位於類別末尾'
# 'field %0 with variable sized type %1 is not visible to subclasses and can conflict with their instance variables'
HF18E29D99032: '具有可變長度類型 %1 的成員變數 %0 未對子類別可見，可能與其執行個體變數衝突'
# 'field %0 with variable sized type %1 not at the end of a struct or class is a GNU extension'
H4A43BA47311C: '結構體或類別末尾以外的可變長度類型 %1 成員變數 %0 是 GNU 擴充功能'
# 'field %1 within %0 is less aligned than %2 and is usually due to %0 being packed, which can lead to unaligned accesses'
HA45C4FF93B3E: '在 %0 中的 %1 成員變數對齊度低於 %2，通常是因為 %0 被壓縮，這可能導致未對齊的存取'
# 'field %select{%1|in %1}0 requires explicit initialization but is not explicitly initialized'
H84C1F3A9AA55: '%select{在 %1 中的|%1}0 成員變數需要顯式初始化但未被顯式初始化'
# 'field %select{width|precision}0 should have type %1, but argument has type %2'
H8AF459399447: '成員變數 %select{width|precision}0 的類型應為 %1，但參數的類型是 %2'
# 'field designator %0 does not refer to a non-static data member'
HC04EA556E581: '成員設計器 %0 未指向非靜態資料成員'
# 'field designator %0 does not refer to any field in type %1'
H2BAA71F8012E: '成員設計器 %0 在類型 %1 中未找到對應的成員'
# 'field designator %0 does not refer to any field in type %1; did you mean %2?'
HE8FCC93993E6: '成員設計器 %0 在類型 %1 中未找到對應的成員；您是否指 %2？'
# 'field designator cannot initialize a %select{non-struct, non-union|non-class}0 type %1'
H22AF1F955E3D: '成員設計器不能初始化 %select{非結構、非共用體|非類別}0 類型 %1'
# 'field designator refers here'
H4EC4B8573557: '成員設計器指向此處'
# 'field has %select{incomplete|sizeless}0 type %1'
HAB06B0829266: '此成員變數具有%select{不完整|無大小}0類型 %1'
# 'field has name %0 here'
H5D746560C0CD: '此成員變數在此處的名稱為 %0'
# 'field has non-trivial ownership qualification'
HC3F83642EF10: '此成員具有非平凡的擁有權修飾'
# 'field is non-trivial to %select{copy|default-initialize}0'
H1D2827B95FDF: '此成員變數在%select{複製|預設初始化}0時具有非平凡行為'
# 'field may not be qualified with an address space'
H8FECB3E29FF3: '成員不可用位址空間修飾'
# 'field of illegal %select{type|pointer type}0 %1 declared here'
H7B96A2670B39: '宣告了非法的 %select{類型|指標類型}0 %1 成員變數'
# 'field of type %0 has %select{private|protected}2 %select{default |copy |move |*ERROR* |*ERROR* |*ERROR* |}1constructor'
H3E9701CFFDEE: '類型 %0 的成員變數具有 %select{private|protected}2 %select{預設 |複製 |移動 |*ERROR* |*ERROR* |*ERROR* |}1 建構函數'
# 'field of type %1 has %select{private|protected}2 destructor'
H40B677C32C44: '類型 %1 的成員變數具有 %select{private|protected}2 析構函數'
# "fields must have a constant size: 'variable length array in structure' extension will never be supported"
H4D0FA4262CAB: '成員變數必須具有固定大小：結構中的可變長度陣列擴充功能永遠不會被支援'
# "file '%0' could not be located in expected %1"
H3AFCF68EDB4D: "無法在期望的 %1 中找到檔案 '%0'"
# "file '%0' from the precompiled header has been overridden"
H0CD8B8C2C117: "來自預編譯標頭的文件 '%0' 已被覆寫"
# "file '%0' has been modified since the %select{precompiled header|module file|AST file}1 '%2' was built: %select{size|mtime|content}3 changed%select{| (was %5, now %6)}4"
H031EEE30BF07: "自建立 %select{預編譯標頭|模組檔|AST 檔}1 '%2' 後，文件 '%0' 已被修改：%select{大小|mtime|內容}3 變更 %select{| (原為 %5，現為 %6)}4"
# "file '%0' is not a module file"
H5DD90DFEF976: "文件 '%0' 不是模組檔"
# "file '%0' is too large for Clang to process"
H9AA7CD92D17E: "文件 '%0' 過於龐大，Clang 無法處理"
# "file '%0' modified since it was first processed"
H1DA05AEA2D52: "自首次處理後，文件 '%0' 已被修改"
# "file '%0' specified by '--extract-api-ignores=' not found"
HC79263152CF4: "由 '--extract-api-ignores=' 指定的文件 '%0' 未找到"
# "file '%0' specified by '-fmodules-embed-file=' not found"
HE609B0415A4D: "由 '-fmodules-embed-file=' 指定的文件 '%0' 未找到"
# "file '%1' is not a valid precompiled %select{PCH|module|AST}0 file: %2"
H208E3D0A2BB0: "文件 '%1' 不是有效的預編譯 %select{PCH|module|AST}0 檔： %2"
# 'file containing an ordered list of functions to use for function reordering'
HAA6E189FC7DA: '包含用於函數重新排序的有序函數列表的文件'
# 'file entered %0 time%s0 using %1B (%human1B) of space%plural{0:|: plus %2B (%human2B) for macro expansions}2'
H6D5FEB2AA58C: '該文件以 %1B（%human1B）的空間 %plural{0:|: 加上 %2B（%human2B）用於宏展開}2 被 %0 time%s0存取過'
# 'file name for generated dot file'
H3426DAEC804D: '生成的 DOT 檔案名稱'
# 'file name where instrumented profile will be saved (default: /tmp/prof.fdata)'
H3FCF6422DD03: '儲存插樁分析的檔案名稱（預設：/tmp/prof.fdata）'
# 'file to dump the ordered list of functions to use for function reordering'
HA4F935C41DEC: '用於輸出用於函數重新排序的有序函數列表的文件'
# 'file with list of functions to frame optimize'
H9B6AF2961BE8: '包含要進行框架優化的函數列表的文件'
# 'file with list of functions to optimize'
HE0011E0AAAF5: '要優化的函數清單檔案'
# 'file with list of functions to optimize (non-regex)'
H03B4E7AB601D: '要優化的函數清單（非正則表達式）檔案'
# 'file with list of functions to skip'
HCF75D26C4EAE: '要跳過的函數清單檔案'
# 'filter expression has non-integral type %0'
H8F952076C959: '__builtin_expect 的參數必須是整數類型，但得到 %0'
# 'final overrider of %q0 in %1'
H0C345A3BEA34: '%q0 在 %1 中的最終覆寫實作'
# 'find_all_symbols options'
H390ECCC2C1D8: 'find_all_symbols 選項'
# "finished building module '%0'"
H243A4EC2890E: "完成建置模組 '%0'"
# 'first argument in call to %0 is a pointer to non-trivially copyable type %1'
HD27C5E590173: '呼叫 %0 時的第一個參數是不可複製類型 %1 的指標'
# 'first argument to %0 must be a pipe type'
H3249D08A7B4F: '%0 的第一個參數必須是管道類型'
# "first argument to 'swift_async' must be either 'none', 'swift_private', or 'not_swift_private'"
HF444E5B58050: "'swift_async' 的第一個參數必須是 'none'、'swift_private' 或 'not_swift_private'"
# "first argument to 'va_arg' is of type %0 and not 'va_list'"
H18598D04D35B: "'va_arg' 的第一個參數類型為 %0，而非 'va_list'"
# 'first argument to __builtin_annotation must be an integer'
H2F65E4EF2060: '__builtin_annotation 的第一個參數必須是整數'
# 'first argument to __builtin_call_with_static_chain must be a non-member call expression'
HF21FFE70E0AD: '__builtin_call_with_static_chain 的第一個參數必須是非成員呼叫表達式'
# 'first argument to __builtin_call_with_static_chain must not be a block call'
HAAFE474DF4AA: '__builtin_call_with_static_chain 的第一個參數不能是區塊呼叫'
# 'first argument to __builtin_call_with_static_chain must not be a builtin call'
HF06ABEE7311C: '__builtin_call_with_static_chain 的第一個參數不能是內建函數呼叫'
# 'first argument to __builtin_call_with_static_chain must not be a pseudo-destructor call'
HFC90CCCE3212: '__builtin_call_with_static_chain 的第一個參數不能是偽析構函數呼叫'
# 'first argument to __builtin_convertvector must be a vector'
HF416CD096831: '__builtin_convertvector 的第一個參數必須是向量'
# 'first field of a transparent union cannot have %select{floating point|vector}0 type %1; transparent_union attribute ignored'
HCF8EE366AB6A: '透明聯盟的第一個字段不能是 %select{浮點數|向量}0 類型 %1；transparent_union 屬性被忽略'
# 'first non-designated initializer is here'
H3AA2DBB89701: '第一個未指定標記的初始值設定項在此處'
# 'first parameter of %0 must have type %1'
HE845E4B59857: '%0 的第一個參數必須具有類型 %1'
# 'first two arguments to __builtin_convertvector must have the same number of elements'
HF134017C1A48: '__builtin_convertvector 的前兩個參數必須具有相同數量的元素'
# "flag '%0' is ignored when flag '%1' is present"
H83C2C7BB9944: "旗標 '%0' 在旗標 '%1' 存在時被忽略"
# "flag '%0' results in undefined behavior with '%1' conversion specifier"
H3E280AED1AE3: "旗標 '%0' 在使用 '%1' 轉換指定符時會導致未定義行為"
# 'flat namespace libraries are not supported'
H5F018FAC5A55: '平坦命名空間程式庫不受支援'
# 'flexible array initialization is a GNU extension'
H2B7FB7A2090E: '彈性陣列初始化是GNU擴展'
# 'flexible array initialization is not yet supported'
H4465FD687CED: '彈性陣列初始化尚未支援'
# 'flexible array member %0 in a union is a GNU extension'
H87BF69264D2B: '聯合中的彈性陣列成員 %0 是GNU擴展'
# 'flexible array member %0 in a union is a Microsoft extension'
HFF7472E02D1C: '聯合中的彈性陣列成員 %0 是Microsoft擴展'
# 'flexible array member %0 in otherwise empty %select{struct|interface|union|class|enum}1 is a GNU extension'
HADE10FBB32E9: '空的%select{結構|介面|聯合|類別|列舉}1中的彈性陣列成員 %0 是GNU擴展'
# 'flexible array member %0 in otherwise empty %select{struct|interface|union|class|enum}1 is a Microsoft extension'
H9C2765356C50: '空的%select{結構|介面|聯合|類別|列舉}1中的彈性陣列成員 %0 是Microsoft擴展'
# 'flexible array member %0 not allowed in %select{struct|interface|union|class|enum}1 which has a virtual base class'
HEF0666641494: '彈性陣列成員 %0 不允許在具有虛基類的%select{結構|介面|聯合|類別|列舉}1中'
# 'flexible array member %0 of type %1 with non-trivial destruction'
H07E92B7CB701: '具有非平凡析構的彈性陣列成員 %0 的類型 %1'
# 'flexible array member %0 with type %1 is not at the end of %select{struct|interface|union|class|enum}2'
HC60DC08C387B: '彈性陣列成員 %0 的類型 %1 未位於%select{結構|介面|聯合|類別|列舉}2的末尾'
# 'flexible array members are a C99 feature'
H04521DEE401E: '彈性陣列成員是C99的特性'
# 'flexible array requires brace-enclosed initializer'
H8CC54601E715: '彈性陣列需要使用大括號包圍的初始值設定項'
# "float ABI '%0' is not supported by current library"
H4A77B1741C96: "浮點ABI '%0' 當前程式庫不支援"
# 'floating point arithmetic produces %select{an infinity|a NaN}0'
HE17E4C75C5CF: '浮點運算產生%select{無限大值|NaN}0'
# 'floating point classification requires argument of floating point type (passed in %0)'
HD0C7777CBCB2: '浮點分類需要傳遞浮點型別的引數（傳遞的是 %0）'
# 'floating point literal in preprocessor expression'
HB66AC9BD4411: '預處理器表達式中出現浮點字面量'
# 'floating-point comparison is always %select{true|false}0; constant cannot be represented exactly in type %1'
HCE8BE2CDB468: '浮點運算的結果始終為 %select{true|false}0；常數無法在類型 %1 中精確表示'
# 'fold functions with identical code'
H57C9420813A5: '合併具有相同程式碼的函數'
# 'fold jcc+mov into cmov'
H1F495E977B3A: '將jcc+mov合併為cmov指令'
# 'for fuzzer data'
H8CC95526ECAB: '為模糊測試資料'
# 'for jump tables, optimize indirect jmp targets instead of indices'
H4D3A2CC709AA: '針對跳轉表優化：優化非直接跳轉目標而非索引'
# 'for loop has empty body'
HE73C4C3A1FCE: 'for迴圈的程式體為空'
# 'for range declaration must declare a variable'
HCCF9CE851541: 'for範圍宣告必須宣告變數'
# 'for training'
H23FBBEB90B89: '為訓練'
# 'for type %0'
HE30274CCC76F: '針對類型 %0'
# 'force openmp unified shared memory mode'
H98550220A417: '強制啟用OpenMP統一共享記憶體模式'
# 'force patching of original entry points to ensure execution follows only the new/optimized code.'
HAA8249C8D974: '修補原始入口點以確保執行流程僅遵循新/優化過的程式碼'
# 'force relocations to data sections to always be processed'
H790511D970BB: '強制處理所有資料區段的重新定位'
# 'force the body of a loop to execute at least once'
H6C72E59E822C: '強制迴圈至少執行一次'
# 'force_cuda_host_device end pragma without matching force_cuda_host_device begin'
H8F7AF4F2F3B0: '沒有對應 force_cuda_host_device begin 的 force_cuda_host_device end pragma'
# 'format argument is %select{a value|an indirect field width|an indirect precision|an auxiliary value}0, but it should be %select{a value|an indirect field width|an indirect precision|an auxiliary value}1'
H26324CE63C64: '格式引數應為%select{一個值|間接欄位寬度|間接精確度|輔助值}1，但實際是%select{一個值|間接欄位寬度|間接精確度|輔助值}0'
# 'format argument modifies specifier at position %0, but it should modify specifier at position %1'
HE2EBF92B2A88: '格式引數修改了位置 %0 的指定符，但應修改位置 %1 的指定符'
# 'format argument not a string type'
H84E99A867F54: '格式引數不是字串類型'
# 'format attribute cannot specify the implicit this argument as the format string'
H6DFBB5CF7F53: '格式屬性無法將隱含的this引數指定為格式字串'
# "format specifier '%0' is incompatible with '%1'"
H4D29848904BC: "格式指定符 '%0' 與 '%1' 不相容"
# 'format specifies type %0 but the argument has %select{type|underlying type}2 %1'
H2B1918042742: '格式指定符指定類型 %0，但引數具有 %select{type|underlying type}2 %1'
# "format string contains '\\0' within the string body"
H262604652293: "格式字串在字串本體中包含 '\\0'"
# 'format string is defined here'
H2D8041B9330A: '格式字串定義在此處'
# 'format string is empty'
HCF4821840281: '格式字串為空'
# 'format string is not a string literal'
HA31C16ADFE78: '格式字串不是字面字串'
# 'format string is not a string literal (potentially insecure)'
HC6BB1E1C18C5: '格式字串不是字面字串（可能不安全）'
# 'format string is not null-terminated'
H1BFF49AB9B87: '格式字串未以null結尾'
# 'format string missing'
HF57059BFF07F: '缺少格式字串'
# 'format string should not be a wide string'
H5D46A69914C2: '格式字串不應為寬字串'
# 'format to dump profile output in aggregation mode, default is fdata'
H4B4189014528: '以聚合模式輸出剖析資料的格式，預設值為fdata'
# 'forward declaration of %0'
H9E3BA9144F24: '%0 的前向宣告'
# 'forward declaration of %0 cannot have a nested name specifier'
HED9D019594EF: '%0 的前向宣告不能具有嵌套名稱限定詞'
# 'forward declaration of class here'
H169D8B5BC4E6: '類別的前向宣告在此處'
# 'forward declaration of non-parameterized class %0 cannot have type parameters'
H5EA8F1567F5D: '非參數化類別 %0 的前向宣告不能具有類型參數'
# 'forward declaration of template entity is here'
H61734FDBAB98: '模板實體的前向宣告在此處'
# "forward references to 'enum' types are a Microsoft extension"
H747D15D3C5A0: '枚舉類型的前向引用是Microsoft擴充功能'
# "found '<::' after a %select{template name|addrspace_cast|const_cast|dynamic_cast|reinterpret_cast|static_cast}0 which forms the digraph '<:' (aka '[') and a ':', did you mean '< ::'?"
HFDE68D3C1582: "在%select{模板名稱|addrspace_cast|const_cast|dynamic_cast|reinterpret_cast|static_cast}0 後發現 '<::'，這會形成二元符號 '<:' (即 '[') 和 ':'，您是否想要 '< ::'？"
# "found near match '%0'"
HE96C9DD0F351: "找到近似匹配 '%0'"
# 'fp convert instructions on integers with more than <N> bits are expanded.'
HBF7A8F526E5F: '對超過 <N> 位的整數執行浮點轉換指令時會被展開。'
# "friend cannot be declared in an explicit instantiation; if this declaration is meant to be a friend declaration, remove the 'template' keyword"
H2CA4FF8AC2DD: '無法在顯式實體化中宣告 friend；如果此宣告是 friend 宣告，請移除「template」關鍵字'
# 'friend declaration cannot be a concept'
HB24446765643: 'friend 宣告不能是概念'
# 'friend declaration cannot have a pure-specifier'
HC11ADC45D1D2: 'friend 宣告不能有 pure-specifier'
# 'friend declaration expands pack %0 that is declared it its own template parameter list'
H7F18F2309FFC: 'friend 宣告擴展了其自身模板參數列表中宣告的參數包 %0'
# 'friend declaration naming a member of the declaring class is incompatible with C++98'
H785F5E24B496: '在宣告類別中命名成員的 friend 宣告與 C++98 不相容'
# 'friend declaration of %0 does not match any declaration in %1'
H31DFE021DF93: 'friend 宣告 %0 與 %1 中的任何宣告皆不相符'
# 'friend declaration specifying a default argument must be a definition'
H55D4B490E76D: '指定預設引數的 friend 宣告必須是定義'
# 'friend declaration specifying a default argument must be the only declaration'
H21926C78D225: '指定預設引數的 friend 宣告必須是唯一的宣告'
# 'friend declaration with a constraint that depends on an enclosing template parameter must be a definition'
HC3DC9462CF4B: '依賴包圍模板參數的 friend 宣告限制條件必須是定義'
# 'friend declared here'
H4C2593C39E2F: 'friend 在此處宣告'
# 'friend function %0 retaining previous language linkage is an extension'
H45895F884047: '保留先前語言連結的 friend 函數 %0 是擴充功能'
# 'friend function %1 is a %select{private|protected}0 member of %3'
H559C2702128F: '%3 的%select{私有|受保護}0 成員函數 %1 是 friend 函數'
# 'friend function cannot be defined in a local class'
H01D22F1D90F1: '無法在局部類別中定義 friend 函數'
# 'friend function definition cannot be qualified with %0'
H87D42EF13E75: 'friend 函數定義不能以 %0 進行修飾'
# 'friend function specialization cannot be defined'
HE48A55696A0C: '無法定義 friend 函數特化型態'
# 'friend type templates must use an elaborated type'
H81BB485691B6: 'friend 類型模板必須使用完整類型表示法'
# 'friends can only be classes or functions'
HABE505726BE2: '友元只能是類或函數'
# 'friends cannot be members of the declaring class'
H0C1CF26733ED: '友元不能是宣告類的成員'
# "from 'diagnose_if' attribute on %0:"
HB7602983E09F: '來自 %0 上的 "diagnose_if" 屬性：'
# 'func1,func2,func3,...'
H6E12F3399F53: 'func1,func2,func3,...'
# "function %0 declared 'noreturn' should not return"
H05EC2FA28594: '宣告為 "noreturn" 的函數 %0 不應返回'
# 'function %0 is unsafe'
H16AE74CB24AD: '函數 %0 不安全'
# 'function %0 with deduced return type cannot be used before it is defined'
H55B75567CEBA: '具有推導返回類型的函數 %0 在定義前不可使用'
# 'function %0 with unknown type must be given a function type'
H5580EE2709E6: '具有未知類型的函數 %0 必須指定函數類型'
# 'function by that name is mangled as "%0"'
HD8E36422062F: '該函數名稱的符號名為 "%0"'
# 'function call counts'
HC411DF133023: '函數調用次數'
# 'function cannot return %select{array|function}0 type %1'
H00D7FE6EC486: '函數不能返回 %select{陣列|函數}0 類型 %1'
# 'function cannot return qualified void type %0'
H6C0F9155F7F7: '函數不能返回帶修飾的 void 類型 %0'
# 'function declaration cannot become a multiversioned function after first usage'
HC4FCD39E4392: '函數宣告在首次使用後不能轉為多版本函數'
# 'function declaration cannot have variably modified type'
HC763DB755E39: '函數宣告不能具有可變長度的類型'
# "function declaration is expected after 'declare %select{simd|variant}0' directive"
HCE4F7AEAC2D0: '在 "declare %select{simd|variant}0" 指令後需跟函數宣告'
# "function declaration is missing %select{'target'|'cpu_specific' or 'cpu_dispatch'|'target_version'}0 attribute in a multiversioned function"
H3FE487F1B347: '多版本函數中缺少 %select{ "target" | "cpu_specific" 或 "cpu_dispatch" | "target_version" }0 屬性'
# 'function declared %0 was previously declared %1, which has different SME function attributes'
HF900531E932D: '宣告為 %0 的函數先前已宣告為 %1，而它們具有不同的 SME 函數屬性'
# "function declared '%0' here was previously declared %select{'%2'|without calling convention}1"
H2073EFB350A2: '在此處宣告的 "%0" 函數先前被宣告為 %select{"%2"|無呼叫約定}1'
# "function declared in block scope cannot have 'static' storage class"
H60B5EC75E0B8: '在區塊作用域中宣告的函數不能具有 "static" 儲存類別'
# 'function declared non-throwing here'
H03F3D9700027: '此處宣告的函數為不拋出異常'
# 'function declared with %0 attribute was previously declared without the %0 attribute'
H5B84619C2423: '具有 %0 屬性的函數先前被宣告為不帶 %0 屬性'
# 'function declared with regparm(%0) attribute was previously declared %plural{0:without the regparm|:with the regparm(%1)}1 attribute'
HF6A7160FBDE6: '宣告為 regparm(%0) 屬性的函數先前 %plural{0:未宣告具 regparm 屬性|:宣告具 regparm(%1) 屬性}1'
# "function definition declared 'typedef'"
H4E2B82F177E3: "函數定義被宣告為 'typedef'"
# 'function definition does not declare parameters'
HD54A2FF99A28: '函數定義未宣告參數'
# 'function definition inside an Objective-C container is deprecated'
HE7254FE08BD0: 'Objective-C 容器內的函數定義已被棄用'
# 'function definition is not allowed here'
HE3336279F815: '在此處進行函數定義是不被允許的'
# 'function definition with pure-specifier is a Microsoft extension'
HDD1E7812B50D: '帶有 pure-specifier 的函數定義是 Microsoft 的擴充功能'
# 'function does not return %0'
H7977746969A8: '函數未返回 %0'
# "function executed in streaming-SVE mode requires 'sme'"
H6F533435BD63: "在串流-SVE模式下執行的函數需要 'sme'"
# 'function id'
H68D2D6A5A6D7: '函數 id'
# "function is a coroutine due to use of '%0' here"
H3E5959ADA928: '因在此處使用「%0」，此函數為協程'
# 'function is implicitly deleted because its declared type does not match the type of an implicit %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0'
H2629CD02AC41: '因宣告類型與隱含的 %select{預設建構函數|複製建構函數|移動建構函數|複製指定運算子|移動指定運算子|析構函數}0 類型不匹配，此函數被隱式刪除'
# 'function multiversioning caused by this declaration'
HF2D62F7767DB: '此宣告引發的函數多版本化'
# "function multiversioning doesn't support %select{feature|architecture}0 '%1'"
H9210168C8D12: "函數多版本化不支援 %select{功能|架構}0 '%1'"
# 'function multiversioning is currently only supported on Linux'
H16DA1069458D: '函數多版本化目前僅支援 Linux 平台'
# 'function multiversioning is not supported on the current target'
H7E39D7302E01: '當前目標平台不支援函數多版本化'
# "function name is not allowed in 'link' clause"
H0E47E3134914: "'link' 子句中不允许使用函數名稱"
# 'function names'
HDC0A95620EA5: '函數名稱'
# 'function parameter %0 with unknown value cannot be used in a constant expression'
H01EB1CAEE1FB: '未知值的函數參數 %0 不可出現在常量表達式中'
# 'function previously declared with an %select{explicit|implicit}0 exception specification redeclared with an %select{implicit|explicit}0 exception specification'
H74E61DFB1137: '先前以%select{顯式|隱式}0例外規格說明宣告的函數，現以%select{隱式|顯式}0例外規格說明重新宣告'
# 'function returns a type %0 marked with [[clang::coro_return_type]] but is neither a coroutine nor a coroutine wrapper; non-coroutines should be marked with [[clang::coro_wrapper]] to allow returning coroutine return type'
H6390B743719E: '標記有 [[clang::coro_return_type]] 的函數返回類型 %0 既非協程也非協程包裝器；非協程應標記 [[clang::coro_wrapper]] 以便返回協程返回類型'
# 'function scope depth exceeded maximum of %0'
H7DB5DD972DEA: '函數作用域深度超出最大值 %0'
# "function static variables are not permitted in functions to which an OpenACC 'routine' directive applies"
HE3AED765A103: '套用 OpenACC「routine」指令的函數中不得使用靜態變數'
# 'function template %q0 matches specialization %1'
HA3A32C570475: '函數模板 %q0 與特化版本 %1 適配'
# 'function template partial specialization is not allowed'
HA3F0ADD5EDBB: '函數模板的部分特化是不被允許的'
# 'function template specialization %0 ambiguously refers to more than one function template; explicitly specify%select{| additional}1 template arguments to identify a particular function template'
H64BC13156614: '函數模板特化 %0 模糊指向多於一個的函數模板；請 %select{|額外}1指定模板參數以明確指定特定函數模板'
# "function template with 'sycl_kernel' attribute must have a 'void' return type"
HE8E9EA85C4E9: '標記有「sycl_kernel」屬性的函數模板必須具有「void」返回類型'
# "function template with 'sycl_kernel' attribute must have a single parameter"
H852CD6495192: '標記有「sycl_kernel」屬性的函數模板必須只有一個參數'
# 'function try block in constexpr %select{function|constructor}0 is a C++20 extension'
H5EFE05C3D7E9: 'constexpr %select{函數|建構函數}0 中的函數試塊是 C++20 延伸功能'
# 'function try block in constexpr %select{function|constructor}0 is incompatible with C++ standards before C++20'
HACF74D9C1B64: 'constexpr %select{函數|建構函數}0 中的函數試塊與 C++20 之前的標準不相容'
# 'function type may not be qualified with an address space'
H193B814022E3: '函數類型不可用地址空間修飾'
# 'function type with %0 attribute must have C linkage'
H39A9B5046A90: '具有 %0 屬性的函數類型必須具備 C 連結規格'
# "function using ZA state requires 'sme'"
H355762BCE254: '使用 ZA 狀態的函數需要「sme」'
# "function using ZT0 state requires 'sme2'"
H00330EB861A8: '使用 ZT0 狀態的函數需要「sme2」'
# "function with '#pragma omp declare variant' has a different %select{calling convention|return type|constexpr specification|inline specification|storage class|linkage}0"
H77243261DC29: '套用「#pragma omp declare variant」的函數具有不同的%select{呼叫約定|返回類型|constexpr 指定|內聯指定|儲存類別|連結規格}0'
# "function with '#pragma omp declare variant' must have a prototype when 'append_args' is used"
H6A83415B36DA: '當使用「append_args」時，套用「#pragma omp declare variant」的函數必須具有原型'
# "function with 'device_type(%0)' is not available on %select{device|host}1"
HB35512790F72: "具有 'device_type(%0)' 的函數在%select{裝置|主機}1上不可用"
# 'function with deduced return type cannot be virtual'
H4BED7E854F85: '具有推導返回類型的函數不能是虛函數'
# 'function with no prototype cannot use the %0 calling convention'
H83A590AC3D6C: '無原型的函數不能使用 %0 呼叫約定'
# "function with trailing return type must specify return type 'auto', not %0"
HBA312AD67336: '具有後置返回類型的函數必須指定返回類型為 "auto"，而非 %0'
# 'function-like macro %0 is not defined'
H7F9F07CB89B9: '類函數巨集 %0 未定義'
# 'function-style cast to a builtin type can only take one argument'
H5995CF0D518F: '對內置類型的函數式轉型只能接受一個參數'
# 'functional-style cast to %0 has incompatible initializer of type %1'
H0F52DA9B703F: '將 %0 進行函數式轉型時具有不相容的初始值類型 %1'
# 'functions cannot be declared in an anonymous %select{struct|union}0'
H50EACF1C1B1C: '不能在匿名 %select{struct|union}0 中宣告函數'
# "functions may not be declared with 'cmse_nonsecure_call' attribute"
H21052FB1BA63: '具有 "cmse_nonsecure_call" 屬性的函數不可宣告'
# 'functions that differ only in their return type cannot be overloaded'
H24E04D8DAB80: '僅返回類型不同的函數不能被重載'
# 'gdb'
H8EAD6354003C: 'gdb'
# 'generalized initializer lists are a C++11 extension'
HA239925474B5: '泛化初始值清單是C++11的擴充功能'
# 'generalized initializer lists are incompatible with C++98'
HCEA06465013C: '泛化初始值清單與C++98不相容'
# 'generate a C++ source file containing the patterns for the input file'
H0E649CF6B515: '為輸入檔案產生包含模式的C++來源檔'
# 'generate a list of function sections in a format suitable for inclusion in a linker script'
H26853D1AF334: '產生適合包含在連結器腳本中的函數區段列表'
# 'generate code for binaries <128MB on AArch64'
H5478C82F0746: '在AArch64上產生小於 128MB的二進位檔代碼'
# 'generate loops for copy-in/copy-out of objects with descriptors'
HEE6A80E60F2B: '產生用描述符複製物件的copy-in/copy-out循環'
# 'generate new tags with runtime library calls'
HE354D1286E8B: '使用執行階段函式庫呼叫產生新的標記'
# 'generate the AST for the input file'
H8D81796BB792: '為輸入檔案產生AST'
# 'generate the PDL MLIR for the input file'
H13DC370300BA: '為輸入檔案生成PDL MLIR'
# 'generated arguments #%0 in round-trip: %1'
H9232807EF50E: '在往返中生成的參數 #%0：%1'
# 'generated arguments do not match in round-trip'
HDDB24B24E48C: '生成的參數在往返中不匹配'
# 'generated arguments parse failed in round-trip'
HA646C4AED02A: '在往返中解析生成的參數失敗'
# 'generic lambdas are incompatible with C++11'
H0E2372801126: '泛型lambda與C++11不相容'
# 'getter name mismatch between property redeclaration (%1) and its original declaration (%0)'
HCB66D133764C: '屬性重宣告（%1）與其原始宣告（%0）的getter名稱不匹配'
# 'given <sectname>,<filename>[@<sym>=<offset>,...]  add the content of <filename> to <sectname>'
HB3C96722F67D: '將 <filename> 的內容添加到 <sectname> 部分'
# "glob '%0' did not match any header file"
H7F85F549D444: "glob '%0' 未匹配任何標頭檔"
# 'global sampler requires a const or constant address space qualifier'
H418F4CC80105: '全域取樣器需要const或constant地址空間修飾符'
# 'granularity of memprof shadow mapping'
H3EDB20D758D1: 'memprof陰影映射的粒度'
# 'greedy register allocator'
H682B2DF6B406: '貪婪寄存器分配器'
# 'growRegion() does not scale with the number of BB edges, so limit its budget and bail out once we reach the limit.'
HA399861C464F: 'growRegion()的擴展與BB邊數不成比例，因此限制其預算，達到極限時中止。'
# 'guarded_by declared here'
H0D3E968182E3: 'guarded_by在此處宣告'
# 'half precision constant requires cl_khr_fp16'
H4CC0B372F96B: '半精度常數需要cl_khr_fp16'
# 'hardware TLS register is not supported for the %0 sub-architecture'
HDE3B68F7C8A6: '硬體TLS寄存器不支援 %0 子架構'
# "header attribute '%0' specified multiple times"
H7E7CB9EE75BF: "標頭屬性 '%0' 被多次指定"
# "header file %0 (aka '%1') cannot be imported because it is not known to be a header unit"
H0A389CC3DB5F: "無法導入標頭檔 %0（即 '%1'），因為它未被識別為標頭單元"
# "header file '%0' input '%1' does not match the type of prior input in api extraction; use '-x %2' to override"
HCC1F871B655D: "在API提取期間，標頭檔 '%0' 的輸入 '%1' 與先前輸入類型不符；使用 '-x %2' 覆蓋"
# "header file '%0' input type '%1' does not match type of prior input in module compilation; use '-x %2' to override"
H089F6388D5E8: "在模組編譯期間，標頭檔 '%0' 的輸入類型 '%1' 與先前輸入類型不符；使用 '-x %2' 覆蓋"
# 'heap allocation performed here'
H3CBBD5C4CC88: '此处進行堆分配'
# 'hexadecimal floating %select{constant|literal}0 requires %select{an exponent|a significand}1'
HEA69D9247DD1: '十六進制浮點%select{常數|文字}0 需要%select{指數|有效數字}1'
# 'hexadecimal floating constants are a C99 feature'
H42D5F9E3F4DF: '十六進制浮點常數是C99的特性'
# 'hexadecimal floating literals are a C++17 feature'
H37A919BEDE1E: '十六進制浮點文字是C++17的特性'
# 'hexadecimal floating literals are incompatible with C++ standards before C++17'
HDD6000DF6583: '十六進制浮點文字與C++17之前的標準不相容'
# 'hidden overloaded virtual function %q0 declared here%select{|: different classes%diff{ ($ vs $)|}2,3|: different number of parameters (%2 vs %3)|: type mismatch at %ordinal2 parameter%diff{ ($ vs $)|}3,4|: different return type%diff{ ($ vs $)|}2,3|: different qualifiers (%2 vs %3)|: different exception specifications}1'
HAF71C2F007E8: '隱藏的重載虛函數%q0 在此宣告 %select{|：不同類別%diff{ ($ vs $)|}2,3|：參數數量不同 (%2 vs %3)|：第%ordinal2 個參數類型不同%diff{ ($ vs $)|}3,4|：傳回類型不同%diff{ ($ vs $)|}2,3|：修飾符不同 (%2 vs %3)|：例外規格不同}1'
# "hidden visibility cannot be applied to 'dllexport' declaration"
HF663B246106D: "'dllexport' 声明不能應用隱藏可視性"
# 'higher order bits are zeroes after implicit conversion'
H69351DA797D5: '隱含轉換後的高位元為零'
# 'hoist common instructions (default = false)'
HAA6396EA7649: '提昇共同指令 (預設值 = false)'
# 'host variable declared here'
H46B0F8E7BD93: '主機變數在此宣告'
# 'hot data symbols support (relocation mode)'
H654F967DBBD4: '熱數據符號支援 (重定位模式)'
# 'how to repeat the instruction snippet'
HA06BE48BF68E: '如何重現指令片段'
# 'hugify'
H4C1045D46DF7: 'hugify'
# 'human-readable YAML format'
HE74AE57FF6C4: '人類可讀的YAML格式'
# "identifier %0 after '~' in destructor name does not name a type"
H83FECEE0EB8D: "'~' 之後的識別碼 %0 在析構函數名稱中未指定類型"
# 'identifier %0 in object destruction expression does not name a type'
H9BF7AFAC2ABF: '物件銷毀運算式中的識別碼 %0 未指定類型'
# 'identifier %0 in object destruction expression does not name the type %1 of the object being destroyed'
H3AA5F97C4B64: '物件銷毀運算式中的識別碼 %0 未指定正在銷毀物件的類型 %1'
# "identifier %0 is reserved because %select{<ERROR>|it starts with '_' at global scope|it starts with '_' and has C language linkage|it starts with '__'|it starts with '_' followed by a capital letter|it contains '__'}1"
HB25A0B12A970: '識別碼 %0 被保留因為 %select{<ERROR>|它在全域作用域以 "_" 開頭|它以 "_" 開頭且具有C語言連結|它包含 "__"|它以 "_" 後接大寫字母開頭|它包含 "__"}1'
# 'identifier %0 preceded by whitespace in a literal operator declaration is deprecated'
H0DD590ABAF7E: '字元串前有空白的字元串運算子宣告中的 %0 已棄用'
# 'identifier after literal will be treated as a reserved user-defined literal suffix in C++11'
HC12CCB91962D: '字元串後的識別碼在C++11中將被視為保留的用戶定義文字後綴'
# 'identifier after literal will be treated as a user-defined literal suffix in C++11'
HBE6CD4B6A8AE: '字元串後的識別碼在C++11中將被視為用戶定義文字後綴'
# 'identifier contains Unicode character <U+%0> that is invisible in some environments'
H5D7B884070AB: '識別項包含在部分環境中不可見的Unicode字元 <U+%0>'
# "identifier followed by '<' indicates a class template specialization but %0 %select{does not refer to a template|refers to a function template|<unused>|refers to a variable template|<unused>|<unused>|refers to a concept}1"
HAF5607DFBCE7: "接續 '<' 的識別項表示類模板特化，但 %0 %select{未引用模板|引用函式模板|<unused>|引用變數模板|<unused>|<unused>|引用概念}1"
# "if processing a memory profile, filter out stack or heap accesses that won't be useful for BOLT to reduce profile file size"
HECF8ECDF0776: '若處理記憶體剖析，過濾對BOLT無用的堆疊或堆存取以減少剖析檔大小'
# 'if reorder-functions is used, order functions putting hottest last'
HD0E8BDE8B867: '若使用reorder-functions，排列函式使最熱的函式放在最後'
# 'if statement has empty body'
H1093D3B0523A: 'if陳述式具有空的程式體'
# 'if the caller is not cold'
H4C9CA904F4C7: '若呼叫者不是冷函式'
# 'if the input is dwp file, parse .debug_info section and use it to populate DW_SECT_INFO contributions in cu-index. For DWARF5 it also populated TU Index.'
HEE68D0DE6C99: '若輸入是dwp檔，解析.debug_info區段，並用它來填充cu-index的DW_SECT_INFO貢獻。對DWARF5來說，它也會填充TU Index。'
# 'if there is more than one benchmark for an opcode, said benchmarks may end up not being clustered into the same cluster if the measured performance characteristics are different. by default all such opcodes are filtered out. this flag will instead show only such unstable opcodes'
H1E3EED942083: '若某opcode有多個效能測試結果，其測試結果可能因效能特性不同而無法分到同一群組。預設會過濾所有此類opcode。此旗標將僅顯示不穩定的opcode'
# 'if you supply your own aligned allocation functions, use -faligned-allocation to silence this diagnostic'
H71B886D5B0E4: '若提供自己的對齊分配函式，使用-faligned-allocation來抑制此診斷'
# 'ifunc resolver function must return a pointer'
H3E2AB07FAA23: 'ifunc解譯函式必須傳回指標'
# 'ignore failures to find derived type descriptors when translating FIR to LLVM'
H6805B42BCC88: '轉換FIR至LLVM時忽略找不到派生類型描述項的錯誤'
# 'ignore hash while reading function profile'
H414AB7A86B98: '讀取函式剖析時忽略雜湊值'
# 'ignore instructions that do not define a sched class'
H4673E599AC01: '忽略未定義排程類別的指令'
# 'ignore kernel interrupt LBR that happens asynchronously'
H65FF6B663DAF: '忽略異步發生的核心中斷LBR'
# 'ignore lto_priv or const suffixes when matching functions'
H482A47671C74: '匹配函式時忽略lto_priv或const後綴'
# 'ignore recursive calls when constructing the call graph'
H79AFD225957D: '建立呼叫圖時忽略遞迴呼叫'
# "ignored 'inline' attribute on kernel function %0"
HD7F59CCBC545: "忽略核心函式 %0 的 'inline' 屬性"
# "ignored asm label '%0' on automatic variable"
H457253219067: "忽略自動變數上的組合語言標籤 '%0'"
# 'ignored trigraph would end block comment'
HC0EDD32FEF14: '被忽略的三字元會結束區塊註解'
# 'ignoring %0 attribute because its argument is invalid'
H5CBA55A0FD5C: '因參數無效而忽略屬性 %0'
# 'ignoring %select{return value|temporary}0 of type %2 declared with %1 attribute%select{|: %4}3'
H18EB408CFE62: '忽略宣告具有 %1 屬性的類型 %2 的%select{返回值|臨時物件}0%select{|：%4}3'
# "ignoring '%0' as it conflicts with that implied by '%1' (%2)"
HB9837B039EA4: "忽略 '%0'，因為它與 '%1' 所暗示的 %2 相衝突"
# "ignoring '%0' option as it cannot be used with %select{implicit usage of|}1 -mabicalls and the N64 ABI"
H17CC723C2497: "忽略 '%0' 選項，因為它無法與%select{默認使用|}1 -mabicalls及N64 ABI一起使用"
# "ignoring '%0' option as it is not currently supported for processor '%1'"
H14E6B917A2E6: "忽略 '%0' 選項，因為它目前不支援處理器 '%1'"
# "ignoring '%0' option as it is not currently supported for target '%1'"
H4AA39F54EF26: "忽略 '%0' 選項，因為它目前不支援目標平台 '%1'"
# "ignoring '%0' option for offload arch '%1' as it is not currently supported there. Use it with an offload arch containing '%2' instead"
H788152E08844: "忽略在卸載架構 '%1' 中的 '%0' 選項，因為該處目前不支援。請改用包含 '%2' 的卸載架構"
# "ignoring '%select{static|inline}0' keyword on explicit template instantiation"
H8A80FA7727CA: '忽略在顯式模板實例化上的 %select{static|inline}0 關鍵字'
# "ignoring '-f%select{no-|}0raw-string-literals', which is only valid for C and C++ standards before C++11"
H135D75731B01: "忽略 '-f%select{no-|}0raw-string-literals'，因為它僅對C++11之前的C和C++標準有效"
# "ignoring '-mabs=2008' option because the '%0' architecture does not support it"
H5F88EE5F0A3D: "忽略 '-mabs=2008' 選項，因為 '%0' 架構不支援"
# "ignoring '-mabs=legacy' option because the '%0' architecture does not support it"
HE0FE9F3B46CA: "忽略 '-mabs=legacy' 選項，因為 '%0' 架構不支援"
# "ignoring '-mcompact-branches=' option because the '%0' architecture does not support it"
H60C9F0D89DB6: "忽略 '-mcompact-branches=' 選項，因為 '%0' 架構不支援"
# "ignoring '-mgpopt' option as it cannot be used with %select{|the implicit usage of }0-mabicalls"
H2A6F793FDFBC: "忽略 '-mgpopt' 選項，因為它無法與%select{ |默認使用 }0-mabicalls一起使用"
# "ignoring '-mlong-calls' option as it is not currently supported with %select{|the implicit usage of }0-mabicalls"
HD076A9DC69A3: "忽略 '-mlong-calls' 選項，因為它目前無法與%select{ |默認使用 }0-mabicalls一起使用"
# "ignoring '-mnan=2008' option because the '%0' architecture does not support it"
H29C27F0049E3: "忽略 '-mnan=2008' 選項，因為 '%0' 架構不支援"
# "ignoring '-mnan=legacy' option because the '%0' architecture does not support it"
HADAF322768AC: "忽略 '-mnan=legacy' 選項，因為 '%0' 架構不支援"
# 'ignoring -fapple-kext which is valid for C++ and Objective-C++ only'
H88A745D4B73F: '忽略專門用於C++和Objective-C++的-fapple-kext'
# 'ignoring -fdiscard-value-names for LLVM Bitcode'
HC86237F887FA: '忽略LLVM位元碼中的-fdiscard-value-names'
# "ignoring -fverify-debuginfo-preserve-export=%0 because -fverify-debuginfo-preserve wasn't enabled"
H36FCA7FF86DB: '忽略-fverify-debuginfo-preserve-export=%0，因為-fverify-debuginfo-preserve未被啟用'
# 'ignoring __declspec(allocator) because the function return type %0 is not a pointer or reference type'
H6AAEF2701683: '忽略__declspec(allocator)，因為該函數返回類型 %0 不是指標或引用類型'
# "ignoring availability attribute %select{on '+load' method|with constructor attribute|with destructor attribute}0"
H24871179ED63: "忽略在 %select{'+load' 方法上|具有構造函數屬性|具有析構函數屬性}0的可用性屬性"
# "ignoring extension '%0' because the '%1' architecture does not support it"
HD131D7C5772F: "忽略擴展 '%0'，因為架構 '%1' 不支援它"
# "ignoring invalid -ftabstop value '%0', using default value %1"
H55F6E19B595A: "忽略無效的 -ftabstop 值 '%0'，使用預設值 %1"
# "ignoring invalid /arch: argument '%0'; for %select{64|32}1-bit expected one of %2"
HF5AE60D7E4BF: "忽略無效的/arch: 參數 '%0'；對 %select{64|32}1 位期望其中一個 %2"
# 'ignoring redefinition of Objective-C qualifier macro'
HE01ADCD1C19E: '忽略重新定義的 Objective-C 修飾符宏'
# 'ignoring return value of function declared with %0 attribute'
H0B36C4D66510: '忽略宣告具有 %0 屬性的函數的傳回值'
# 'ignoring return value of function declared with %0 attribute%select{|: %2}1'
H9DECD2C6A7A4: '忽略宣告具有 %0 屬性的函數的傳回值 %select{|： %2}1'
# 'ignoring temporary created by a constructor declared with %0 attribute%select{|: %2}1'
H0FFFAF84F31C: '忽略由宣告具有 %0 屬性的建構子所創建的臨時物件 %select{|： %2}1'
# "ignoring the 'branch-protection' attribute because the '%0' architecture does not support it"
HF5FC687425B2: "忽略 'branch-protection' 屬性，因為架構 '%0' 不支援它"
# 'illegal OpenMP user-defined mapper identifier'
H4FE25A4B348F: '非法的 OpenMP 使用者定義映射器識別碼'
# 'illegal call to %0, expected %1 argument type'
H4DEE4185FC7F: '對 %0 的非法呼叫，期望 %1 參數類型'
# 'illegal call to enqueue_kernel, incorrect argument types'
H96AA6DCB3DCC: '對 enqueue_kernel 發生非法呼叫，引數型別錯誤'
# 'illegal call to enqueue_kernel, parameter needs to be specified as integer type'
H8F7144077DA2: '對 enqueue_kernel 發生非法呼叫，參數需要指定為整數型別'
# 'illegal character encoding in character literal'
H44B6CA76305B: '字元字面量中的非法字元編碼'
# 'illegal character encoding in string literal'
H2EE26865FBAD: '字串字面量中的非法字元編碼'
# 'illegal device builtin %select{surface|texture}0 reference class template %1 declared here'
H7BB2FD0ACCED: '非法的裝置內建 %select{surface|texture}0 參考類別模板 %1 在此處宣告'
# 'illegal device builtin %select{surface|texture}0 reference type %1 declared here'
H1DEC140E0334: '非法的裝置內建 %select{surface|texture}0 參考型別 %1 在此處宣告'
# 'illegal initializer (only variables can be initialized)'
H371A1BFF13F4: '非法的初始化式（只有變數可以被初始化）'
# 'illegal initializer type %0'
H000E8C02D9A4: '非法的初始化式型別 %0'
# 'illegal interface qualifier'
H247C18DEFCA4: '非法的介面修飾符'
# 'illegal operation on Objective-C container subscripting'
H1CDC7C944B48: '對 Objective-C 容器索引存取的非法運算'
# 'illegal qualifiers on @catch parameter'
H2C6EDFE337AA: '@catch參數上的非法限定符'
# "illegal redeclaration of 'readwrite' property in class extension %0 (perhaps you intended this to be a 'readwrite' redeclaration of a 'readonly' public property?)"
H77F956612F13: "在類別擴展 %0 中對 'readwrite' 屬性的非法重新宣告（也許您想將此宣告為 'readonly' 公開屬性的 'readwrite' 重新宣告？）"
# "illegal redeclaration of property in class extension %0 (attribute must be 'readwrite', while its primary must be 'readonly')"
HA09E774D29B3: "在類別擴展 %0 中對屬性的非法重新宣告（屬性必須是 'readwrite'，而其主要宣告必須是 'readonly'）"
# 'illegal scalar extension cast on argument %0 to %select{|in}1out paramemter'
HF91E5CAEA96B: '在參數 %0 到 %select{|in}1out參數上進行非法標量擴展轉換'
# 'illegal storage class on file-scoped variable'
H601564466459: '文件作用域變數上的非法存儲類別'
# 'illegal storage class on function'
H930E494BEBBE: '函數上的非法存儲類別'
# 'illegal type %0 used in a boxed expression'
H5782BEFABE5B: '在裝箱運算式中使用非法類型 %0'
# 'illegal vector component name %0'
H6F3BE393AEDE: '非法的向量元件名稱 %0'
# 'illegal visibility specification'
H39F781806C46: '非法的可見性規範'
# 'imaginary constants are a C2y extension'
HAF201E910158: '虛數常量是C2y擴展'
# 'imaginary constants are a GNU extension'
H539EC610843E: '虛數常量是GNU擴展'
# 'imaginary constants are incompatible with C standards before C2y'
H8F7EDEA31FE9: '虛數常量與C2y之前的C標準不相容'
# 'imaginary types are not supported'
H8AEF701858F7: '不支援虛數類型'
# 'immediate function %0 used before it is defined'
H1A240E8F6E49: '在定義前使用立即函數 %0'
# 'implementing deprecated %select{method|class|category}0'
H9AA979884A67: '實作已棄用的%select{方法|類別|類別別名}0'
# 'implementing unavailable method'
H0D7D4644123A: '實作不可用的方法'
# 'implicit %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 inferred target collision: call to both %select{__device__|__global__|__host__|__host__ __device__}1 and %select{__device__|__global__|__host__|__host__ __device__}2 members'
HDD95624FC57A: '隱式%select{預設建構函數|複製建構函數|移動建構函數|複製賦值運算子|移動賦值運算子|析構函數}0推斷目標衝突：同時呼叫 %select{__device__|__global__|__host__|__host__ __device__}1 和 %select{__device__|__global__|__host__|__host__ __device__}2 成員'
# 'implicit boolean conversion of Objective-C object literal always evaluates to true'
HFAC6148E9355: 'Objective-C物件字面量的隱式布林轉換始終評估為true'
# "implicit capture of 'this' with a capture default of '=' is deprecated"
H7D01BFC1D4A1: "隐含使用默认值 '=' 捕获 'this' 是已弃用的"
# 'implicit capture of lambda object due to conversion to block pointer here'
H9CBFA98934C5: '隐含將 lambda 物件轉換為 block 指標時的捕獲'
# 'implicit cast from type %0 to type %1 drops __unaligned qualifier'
HBCE299280FC0: '隐含將類型 %0 轉換為類型 %1 時去除 __unaligned 限定符'
# 'implicit conversion between pointer-to-function and pointer-to-object is a Microsoft extension'
HE1B9297E3DCF: '函數指標與物件指標之間的隐含轉換是 Microsoft 扩展'
# "implicit conversion between vector types ('%0' and '%1') is deprecated; in the future, the behavior implied by '-fno-lax-vector-conversions' will be the default"
HD9008DAA3AF0: '向量類型 (%0 和 %1) 之間的隐含轉換已弃用；未來，-fno-lax-vector-conversions 選項所指定的行為將成為預設'
# 'implicit conversion changes signedness: %0 to %1'
H2AEC008E19C8: '隱式轉換改變符號性質：%0 至 %1'
# 'implicit conversion discards imaginary component: %0 to %1'
H5E6175D2FC4A: '隐含將複數類型 %0 轉換為 %1 時會丟棄虛數部分'
# 'implicit conversion from %0 cannot fit within the range of values for %1'
HC3B95ADC5255: '從 %0 的隱式轉換無法適配到 %1 的值範圍'
# 'implicit conversion from %0 to %1 changes non-zero value from %2 to %3'
H5699AB9A4A11: '隐含將 %0 轉換為 %1 時，非零值從 %2 變為 %3'
# 'implicit conversion from %0 to %1 changes value from %2 to %3'
H3C62B43256C2: '隐含將 %0 轉換為 %1 時，其值從 %2 變為 %3'
# 'implicit conversion from %0 to %1 is not permitted in C++'
HD43915D50111: '隐含將 %0 轉換為 %1 在 C++ 中是不允许的'
# 'implicit conversion from %0 to %1 may lose precision'
H1D559B11094C: '隐含將 %0 轉換為 %1 可能會導致精度損失'
# 'implicit conversion from %2 to %3 changes value from %0 to %1'
H9616CD29DFC9: '隐含將 %2 轉換為 %3 時，其值從 %0 變為 %1'
# 'implicit conversion from array size expression of type %0 to %select{integral|enumeration}1 type %2 is a C++11 extension'
H1C73815D89AE: '隐含將陣列大小運算式類型 %0 轉換為 %select{整數|枚舉}1 類型 %2 是 C++11 的擴充功能'
# 'implicit conversion from array size expression of type %0 to %select{integral|enumeration}1 type %2 is incompatible with C++98'
HBA0FE5371598: '隐含將陣列大小運算式類型 %0 轉換為 %select{整數|枚舉}1 類型 %2 不符合 C++98 標準'
# "implicit conversion from constant value %0 to 'BOOL'; the only well defined values for 'BOOL' are YES and NO"
H9F3E57EE843E: "隐含將常數值 %0 轉換為 'BOOL'；'BOOL' 型態僅定義 YES 和 NO 為有效值"
# 'implicit conversion from enumeration type %0 to different enumeration type %1'
HEE824DA3A047: '隐含將枚舉類型 %0 轉換為不同枚舉類型 %1'
# "implicit conversion from floating-point type %0 to 'BOOL'"
H4747E2EB6787: "隐含將浮點型態 %0 轉換為 'BOOL'"
# "implicit conversion from integral type %0 to 'BOOL'"
H2BF4B2ABD201: "隐含將整數型態 %0 轉換為 'BOOL'"
# 'implicit conversion from nullable pointer %0 to non-nullable pointer type %1'
H2C9C47D2B30E: '隐含將可為空指標 %0 轉換為不可為空指標型態 %1'
# 'implicit conversion increases floating-point precision: %0 to %1'
HA48CBAE7D71E: '隱式轉換提升浮點精確度：%0 至 %1'
# 'implicit conversion loses floating-point precision: %0 to %1'
H8151E8B82266: '隱式轉換降低浮點精確度：%0 至 %1'
# 'implicit conversion loses integer precision: %0 to %1'
H7E75B58A91F6: '隱式轉換降低整數精確度：%0 至 %1'
# 'implicit conversion of %select{NULL|nullptr}0 constant to %1'
H81DB38ED2223: '將 %select{NULL|nullptr}0 常數隱式轉換為 %1'
# 'implicit conversion of out of range value from %0 to %1 is undefined'
H60829B0B819C: '將超出範圍的值從 %0 轉換為 %1 的隱式轉換無法定義'
# 'implicit conversion truncates vector: %0 to %1'
H678147335701: '隱式轉換截斷向量：%0 至 %1'
# 'implicit conversion turns floating-point number into bool: %0 to %1'
HBD45EEBA1C30: '將浮點數轉換為布林值：%0 至 %1'
# 'implicit conversion turns floating-point number into integer: %0 to %1'
H1859EAB52A1F: '將浮點數轉換為整數：%0 至 %1'
# 'implicit conversion turns string literal into bool: %0 to %1'
H0BABC92466FD: '將字串文字轉換為布林值：%0 至 %1'
# 'implicit conversion turns vector to scalar: %0 to %1'
HB2E373F67C4B: '將向量轉換為純量：%0 至 %1'
# 'implicit conversion when assigning computation result loses floating-point precision: %0 to %1'
H063DB898AD67: '指派運算結果時的隱式轉換會降低浮點精確度：%0 至 %1'
# 'implicit conversions between vector types (%0 and %1) are not permitted'
HDD25DAA03F93: '向量類型 (%0 和 %1) 間的隱式轉換不被允許'
# 'implicit declaration introduced by elaborated type conflicts with a %select{non-struct type|non-class type|non-union type|non-enum type|typedef|type alias|template|type alias template|template template argument}0 of the same name'
H0AA0DBCCB1F5: '由精確類型引發的隱式宣告與同名的%select{非結構類型|非類型|非共用體類型|非列舉類型|typedef|類型別名|模板|類型別名模板|模板模板參數}0產生衝突'
# 'implicit declaration of function %0'
H1E9139CA3E1D: '函式 %0 的隱式宣告'
# "implicit deduction guide declared as '%0'"
H2EE915923496: '宣告的隱式推導指引為 %0'
# 'implicit default constructor suppressed by user-declared constructor'
H2B519469152F: '因使用者宣告的建構函式，隱式預設建構函式被抑制'
# 'implicit instantiation of undefined member %0'
H2427990A2EAB: '未定義成員 %0 的隱式實例化'
# 'implicit truncation from %2 to a one-bit wide bit-field changes value from %0 to %1'
H46C1BDEE4300: '將 %2 的值從 %0 改變為 %1，存入一位寬的位段'
# 'implicit truncation from %2 to bit-field changes value from %0 to %1'
HB32D8742297B: '從 %2 到 bit-field 的隱式截斷將值從 %0 改為 %1'
# 'implicit use of sequentially-consistent atomic may incur stronger memory barriers than necessary'
H162AB39C9F24: '使用順序一致的原子可能導致不必要的強記憶體屏障'
# "implicitly declaring library function '%0' with type %1"
H452F7C0F821A: "隱式宣告函式庫函式 '%0' 具有類型 %1"
# 'implicitly determined as %0'
HD0131FA6D64A: '隱式判定為 %0'
# "implicitly disabling vptr sanitizer because rtti wasn't enabled"
HABA9C105D8F8: '隱式停用 vptr 除錯工具 因為 rtti 未啟用'
# 'import %select{module|name}0 (%1) does not match the import %select{module|name}0 (%2) of the previous declaration'
HE913E2E83F88: 'import %select{模組|名稱}0 (%1) 與先前宣告的 import %select{模組|名稱}0 (%2) 不匹配'
# 'import %select{module|name}0 cannot be applied to a function with a definition'
HB24CB23A8286: '無法將 import %select{模組|名稱}0 套用到具有定義的函數'
# 'import of C++ module \'%0\' appears within extern "C" language linkage specification'
HDAEE51A4DB06: 'C++ 模組 \'%0\' 的 import 出現在 extern "C" 語言連結規範內'
# "import of module '%0' appears within %1"
H08448256C67A: "模組 '%0' 的 import 出現在 %1 內"
# "import of module '%0' appears within its own %select{interface|implementation}1"
HBF7F549ECBD5: "模組 '%0' 的 import 出現在其自身的 %select{介面|實作}1"
# "import of module '%0' appears within same top-level module '%1'"
H25D86D4DF122: "模組 '%0' 的 import 出現在同一頂層模組 '%1'"
# "import of module '%0' imported non C++20 importable modules"
H861EDFB67C5B: "模組 '%0' 的 import 導入了非C++20可導入模組"
# "import of shadowed module '%0'"
HECE190C4501D: "被遮蔽的模組 '%0' 的 import"
# "imported AST from '%0' had been generated for a different target, current: %1, imported: %2"
H30A99270FD50: "從 '%0' 導入的 AST 是為不同目標生成的，目前目標: %1，導入目標: %2"
# "imported by %select{|module '%2' in }1'%0'"
HBA6CF98B38A4: "被 %select{|模組 '%2' 在 }1'%0' 所導入"
# 'importing an implementation partition unit in a module interface is not recommended. Names from %0 may not be reachable'
H4BCD18B5E018: '在模組介面中導入實現區段單元並不可取。%0 中的名稱可能無法存取'
# "importing module '%0'%select{| into '%3'}2 from '%1'"
HD074A7D9BA2D: "從 '%1' 導入模組 '%0'%select{| 到 '%3'}2"
# 'imports must immediately follow the module declaration'
H25C0CF982742: 'import 必須直接跟隨模組宣告'
# 'impossible constraint in asm: cannot store value into a register'
HEC9C616BA3F9: 'asm 中的不可能約束：無法將值存入寄存器'
# 'in %select{implicit|defaulted}0 %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}1 for %2 first required here'
H7F88B1ED021A: '在%select{隱式|已預設的}0%select{預設建構函式|複製建構函式|移動建構函式|複製指派運算子|移動指派運算子|析構函式}1的 %2 中，首次需要在此處'
# "in call to '%0'"
H5F44B6591F5A: "在調用 '%0' 時"
# "in call to printing function with arguments '(%0)' while dumping struct"
H5B10BE57CF69: "在列印函式調用時，以參數 '(%0)' 傾印結構"
# 'in defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator for %1 first required here'
H41C2C013E2E2: '在 %1 的預設 %select{<ERROR>|等式|三向|等式|關聯}0比較運算子中，首次需要在此處'
# 'in evaluating default argument here'
HA6EC671D8C49: '在評估此處的預設參數時'
# 'in evaluation of exception specification for %q0 needed here'
H94CE96486393: '在評估%q0所需的例外規格時'
# 'in first definition, possible difference is here'
HAF3474709EF4: '在首次定義中，可能的差異在此處'
# "in implicit call to 'operator%select{!=|*|++}0' for iterator of type %1"
HA1274A4A4765: "在 %1 類型的迭代器隱式調用 'operator%select{!=|*|++}0' 時"
# 'in implicit initialization for inherited constructor of %0'
HE4CCA87F39AA: '在 %0 的繼承建構函式的隱式初始化時'
# 'in implicit initialization of %select{array element %1 with omitted initializer|field %1 with omitted initializer|trailing array elements in runtime-sized array new}0'
HD4BCA75D333B: '在%select{省略初始值設定的陣列元素 %1|省略初始值設定的成員 %1|執行階段尺寸陣列new的尾隨陣列元素}0的隱式初始化時'
# 'in implicit initialization of binding declaration %0'
H6B3B1A4A0790: '在 %0 綁定宣告的隱式初始化時'
# 'in initialization of temporary of type %0 created to list-initialize this reference'
H5C5815C0F326: '在初始化用於列表初始化此引用所建立的 %0 類型暫存時'
# "in instantiation of default argument for '%0' required here"
H920C89F748D0: '在 %0 的預設參數實體化所需時'
# "in instantiation of default function argument expression for '%0' required here"
H05CBF7F0C1EE: '在 %0 的預設函式參數表達式實體化所需時'
# 'in instantiation of default member initializer %q0 requested here'
HD2F44CDF38B1: '在%q0的預設成員初始值設定實體化請求時'
# 'in instantiation of enumeration %q0 requested here'
H6EB646EE227A: '在%q0列舉實體化請求時'
# 'in instantiation of exception specification for %0 requested here'
H3C01A542E6EB: '在 %0 的例外規格實體化請求時'
# 'in instantiation of function template specialization %q0 requested here'
HAEB9C4D2EE7B: '在%q0函式模板實體化請求時'
# 'in instantiation of member class %q0 requested here'
H5CE23327E7F1: '在%q0成員類別實體化請求時'
# 'in instantiation of member function %q0 requested here'
H748A89FD0314: '在成員函數 %q0 的實體化中被要求這裡'
# 'in instantiation of requirement here'
HE12670012001: '在此處實體化需求'
# 'in instantiation of requirement parameters here'
HCD143B7FE64F: '在此處實體化需求參數'
# 'in instantiation of static data member %q0 requested here'
H0491530140D7: '在靜態資料成員 %q0 的實體化中被要求這裡'
# 'in instantiation of template class %q0 requested here'
H65B85839EF55: '在模板類 %q0 的實體化中被要求這裡'
# 'in instantiation of template type alias %0 requested here'
HAECA7764FC0E: '在類型別名 %0 的實體化中被要求這裡'
# 'in instantiation of variable template specialization %q0 requested here'
H0FA1B781E861: '在變數模板特化 %q0 的實體化中被要求這裡'
# 'in lowering create ArrayCoorOp instead of CoordinateOp'
H38357B1F88DE: '在降級時創建 ArrayCoorOp 而非 CoordinateOp'
# 'in non-LBR mode, guess edge counts using iterative technique'
H7372BDB68057: '在非LBR模式下，使用迭代技術猜測邊數量'
# "in pattern '%1': %0"
H2F43FF1537BC: "在模式 '%1' 中：%0"
# 'in relocation mode trap upon entry to any function that uses AVX-512 instructions'
H082BA4E3D29F: '在重定位模式下，進入任何使用AVX-512指令的函數時觸發陷阱'
# 'in second definition, possible difference is here'
HEC9D50C16660: '在第二次定義中，可能的差異在此處'
# 'in template expansion here'
H1E2D3625EAB4: '在此處模板展開'
# 'in the default initializer of %0'
H6D9691DC0D28: '在 %0 的預設初始化式中'
# 'in value-initialization of type %0 here'
H74E349C94BB1: '在此處對類型 %0 進行值初始化'
# 'in%select{| implicit}0 constructor here'
H24F20A5C047E: '在 %select{| 隱含}0 建構函數中這裡'
# 'in-class initializer for static data member is not a constant expression'
H9B69A27F211E: '類別內靜態資料成員的初始化式並非常數運算式'
# 'in-class initializer for static data member is not a constant expression; folding it to a constant is a GNU extension'
HA2848C2F37A8: '類別內靜態資料成員的初始化式並非常數運算式；將其摺疊為常數是GNU擴充功能'
# 'in-class initializer for static data member of type %0 is a GNU extension'
H46A5C414A183: '類別內類型 %0 的靜態資料成員的初始化式是GNU擴充功能'
# "in-class initializer for static data member of type %0 requires 'constexpr' specifier"
H7E9F22B76B86: "類別內類型 %0 的靜態資料成員的初始化式需要 'constexpr' 修飾詞"
# 'in_reduction variable must have the same reduction operation as in a task_reduction clause'
H7647CFB2C410: 'in_reduction 變數必須與 task_reduction 子句中具有相同的約束運算'
# 'include a detailed record of preprocessing actions'
H4B25771F85AC: '包含預處理動作的詳細紀錄'
# "include location '%0' is unsafe for cross-compilation"
H62F3D6400A8A: "包含位置 '%0' 在交叉編譯時不安全"
# 'include module search paths'
HFFA588262B00: '包含模組搜尋路徑'
# "include of non-modular header inside framework module '%0': '%1'"
H82B29FF5B7DD: "在框架模組 '%0' 中包含非模組化標頭：'%1'"
# "include of non-modular header inside module '%0': '%1'"
H747C5EDF3216: "在模組 '%0' 中包含非模組化標頭：'%1'"
# "include path for libstdc++ headers not found; pass '-stdlib=libc++' on the command line to use the libc++ standard library instead"
H45B1E0C04AB4: "libstdc++ 標頭的包含路徑未找到；請在命令列中傳遞 '-stdlib=libc++' 以改用 libc++ 標準函式庫"
# 'include search path'
H43B868761DFC: '包含路徑搜尋'
# "include the header <%0> or explicitly provide a declaration for '%1'"
HBFC18315E2CB: "包含標頭 <%0> 或明確提供 '%1' 的宣告"
# 'incompatible block pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2'
HA4D550DCCECE: '不相容的區塊指標類型 %select{%diff{將$指派給$|指派給不同類型}1,0|%diff{將$傳遞給類型為$的參數|傳遞給不同類型的參數}0,1|%diff{從返回類型為$的函數返回$|從不同返回類型的函數返回}1,0|%diff{將$轉換為類型$|轉換不同類型}0,1|%diff{用類型$的運算式初始化$|用不同類型的運算式初始化}1,0|%diff{將$傳遞給類型為$的參數|傳遞給不同類型的參數}0,1|%diff{將$轉換為類型$|轉換不同類型}0,1}2'
# 'incompatible constant for this __builtin_neon function'
H338324E39A33: '此__builtin_neon函數的常數不相容'
# 'incompatible function pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3'
H803DA0209C00: '不相容的函式指標類型 %select{%diff{將$指派給$|指派給不同類型}1,0|%diff{將$傳遞給類型為$的參數|傳遞給不同類型的參數}0,1|%diff{從返回類型為$的函數返回$|從不同返回類型的函數返回}1,0|%diff{將$轉換為類型$|轉換不同類型}0,1|%diff{用類型$的運算式初始化$|用不同類型的運算式初始化}1,0|%diff{將$傳遞給類型為$的參數|傳遞給不同類型的參數}0,1|%diff{將$轉換為類型$|轉換不同類型}0,1}2%select{|; 使用*解引用|; 取得位址 &|; 移除 *|; 移除 &}3'
# 'incompatible integer to pointer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3'
H48B50F4A5A68: '不相容的整數到指標轉換 %select{%diff{將$指派給$|指派給不同類型}1,0|%diff{將$傳遞給類型為$的參數|傳遞給不同類型的參數}0,1|%diff{從返回類型為$的函數返回$|從不同返回類型的函數返回}1,0|%diff{將$轉換為類型$|轉換不同類型}0,1|%diff{用類型$的運算式初始化$|用不同類型的運算式初始化}1,0|%diff{將$傳遞給類型為$的參數|傳遞給不同類型的參數}0,1|%diff{將$轉換為類型$|轉換不同類型}0,1}2%select{|; 使用*解引用|; 取得位址 &|; 移除 *|; 移除 &}3'
# 'incompatible operand types (%0 and %1)'
HCEE400E94353: '不相容的運算元類型 (%0 和 %1)'
# 'incompatible operand types%diff{ ($ and $)|}0,1'
H1FD3FD989888: '不相容的運算元類型%diff{ ($與$)|}0,1'
# 'incompatible pointer to integer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3'
HFD878F5F2922: '不相容的指標到整數轉換 %select{%diff{將$指派給$|指派給不同類型}1,0|%diff{將$傳遞給類型為$的參數|傳遞給不同類型的參數}0,1|%diff{從返回類型為$的函數返回$|從不同返回類型的函數返回}1,0|%diff{將$轉換為類型$|轉換不同類型}0,1|%diff{用類型$的運算式初始化$|用不同類型的運算式初始化}1,0|%diff{將$傳遞給類型為$的參數|傳遞給不同類型的參數}0,1|%diff{將$轉換為類型$|轉換不同類型}0,1}2%select{|; 使用*解引用|; 取得位址 &|; 移除 *|; 移除 &}3'
# 'incompatible pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3'
HBA7B4F7FCD76: '不相容的指標類型 %select{%diff{將$指派給$|指派給不同類型}1,0|%diff{將$傳遞給類型為$的參數|傳遞給不同類型的參數}0,1|%diff{從返回類型為$的函數返回$|從不同返回類型的函數返回}1,0|%diff{將$轉換為類型$|轉換不同類型}0,1|%diff{用類型$的運算式初始化$|用不同類型的運算式初始化}1,0|%diff{將$傳遞給類型為$的參數|傳遞給不同類型的參數}0,1|%diff{將$轉換為類型$|轉換不同類型}0,1}2%select{|; 使用*解引用|; 取得位址 &|; 移除 *|; 移除 &}3'
# 'incompatible pointer types passing retainable parameter of type %0to a CF function expecting %1 type'
H85C3F4475A3D: '不兼容的指標類型：將型別為 %0 的可保留參數傳遞給期望 %1 型別的Core Foundation函數'
# 'incompatible redeclaration of library function %0'
H4DCB8A7133E4: '函式庫函數 %0 的重新宣告類型不相容'
# 'incompatible types casting %0 to %1 with a %select{__bridge|__bridge_transfer|__bridge_retained}2 cast'
HA70D951974C7: '使用 %select{__bridge|__bridge_transfer|__bridge_retained}2 cast 將 %0 轉換為 %1 時類型不相容'
# 'incompatible vector types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2'
H349444057F6C: '%select{%diff{將$指派給$型別 | 指派不同型別}1,0|%diff{將$傳遞給型別為$的參數 | 傳遞給不同型別的參數}0,1|%diff{從結果型別為$的函數返回$ | 從不同返回型別的函數返回}1,0|%diff{將$轉換為$型別 | 轉換不同型別}0,1|%diff{用型別$的運算式初始化$ | 用不同型別的運算式初始化}1,0|%diff{將$傳遞給型別為$的參數 | 傳遞給不同型別的參數}0,1|%diff{將$轉換為$型別 | 轉換不同型別}0,1}2'
# 'incomplete definition of type %0'
H74F733EC60E9: '不完整的型別 %0 定義'
# "incomplete delimited universal character name; treating as '\\' '%0' '{' identifier"
H45A3D640545C: "不完整的界定通用字符名称；視為 '\\' '%0' '{' 标識符"
# 'incomplete format specifier'
HC2682570C017: '格式指定項不完整'
# 'incomplete receiver type %0'
H6C117CF6E37A: '不完整的接收者型別 %0'
# 'incomplete result type %0 in function definition'
HA8E1F3068B20: '函數定義中的結果型別 %0 不完整'
# 'incomplete result type %0 in lambda expression'
H69E2641DED85: 'lambda運算式中的結果型別 %0 不完整'
# "incomplete type %0 in a '_Generic' association is a C2y extension"
H7D3852AE4A16: "'_Generic' 關聯中的不完整型別 %0 是C2y擴充功能"
# 'incomplete type %0 is not a literal type'
H8AFDEC1F2348: '不完整型別 %0 不是文字型別'
# 'incomplete type %0 is not assignable'
HF862B3215822: '不完整型別 %0 無法指派'
# 'incomplete type %0 named in nested name specifier'
HCA7665DF5910: '在嵌套名稱指定項中命名的不完整型別 %0'
# 'incomplete type %0 used in a boxed expression'
HF426C73BD83F: '在boxed運算式中使用不完整型別 %0'
# 'incomplete type %0 used in type trait expression'
H4539C0CCBFB9: '在型別特性運算式中使用不完整型別 %0'
# 'incomplete type %0 where a complete type is required'
H95C11FF1D056: '在需要完整型別的位置使用不完整型別 %0'
# 'incomplete type in call to object of type %0'
HB57B0356D109: '型別 %0 的物件呼叫中使用不完整型別'
# 'incomplete universal character name'
H0184822E59BB: '不完整的通用字符名稱'
# "incomplete universal character name; treating as '\\' followed by identifier"
H5B8C01DBAD90: "不完整的通用字符名称；視為 '\\' 後接标识符"
# 'inconsistent number of instance variables specified'
H7EB07F9DCA1E: '規定的實例變數數量不一致'
# "incorrect adjust_args type, expected 'need_device_ptr' or 'nothing'"
H34BB37A9E639: "不正確的 adjust_args 類型，期望 'need_device_ptr' 或 'nothing'"
# 'incorrect format for -preamble-bytes=N,END'
HD764A19076F3: '-preamble-bytes=N,END 格式不正確'
# "incorrect map type modifier, expected one of: 'always', 'close', 'mapper'%select{|, 'present'|, 'present', 'iterator'}0%select{|, 'ompx_hold'}1%select{|, 'self'}2"
H6BCE6C4F91C6: "不正確的映射類型修飾符，期望其中一個：'always', 'close', 'mapper'%select{|, 'present'|, 'present', 'iterator'}0%select{|, 'ompx_hold'}1%select{|, 'self'}2"
# "incorrect map type, expected one of 'to', 'from', 'tofrom', 'alloc', 'release', or 'delete'"
HFC0556B7E292: "不正確的映射類型，應為 'to', 'from', 'tofrom', 'alloc', 'release' 或 'delete' 其中之一"
# 'incorrect number of bits in integer (expected %0 bits, have %1)'
H39F86512F6F1: '整数位数不正确（期望 %0 位，但有 %1 位）'
# 'incorrect number of bits in vector operand (expected %select{|a multiple of}0 %1 bits, have %2)'
HDF4134C84931: '向量操作數的位數不正確（期望 %select{|的倍數}0 %1 位，但有 %2 位）'
# "incorrect reduction identifier, expected one of '+', '*', '&', '|', '^', '&&', '||', 'min' or 'max' or declare reduction for type %0"
HD90D2B65D413: "約束標識符不正確，期望其中一個 '+', '-', '*', '&', '|', '^', '&&', '||', 'min' 或 'max'，或為類型 %0 宣告約束"
# "incorrect reduction identifier, expected one of '+', '-', '*', '&', '|', '^', '&&', '||', 'min' or 'max' or declare reduction for type %0"
HC80B58A26C84: "約束標識符不正確，期望其中一個 '+', '*', '&', '|', '^', '&&', '||', 'min' 或 'max'，或為類型 %0 宣告約束"
# 'incorrect use of #pragma clang force_cuda_host_device begin|end'
HB4E983FB1A7D: '不正確使用 #pragma clang force_cuda_host_device begin|end'
# "incorrect use of '#pragma fenv_access (on|off)' - ignored"
HB0DD6B333D8B: "不正確使用 '#pragma fenv_access (on|off)' - 被忽略"
# "incorrect use of '#pragma ms_struct on|off' - ignored"
HB1C2DABF7753: "不正確使用 '#pragma ms_struct on|off' - 被忽略"
# 'increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable %0'
H1F62FE8343E9: 'OpenMP for 迴圈的 increment 子句必須對循環變量 %0 執行簡單的加減運算'
# 'increment expression must cause %0 to %select{decrease|increase}1 on each iteration of OpenMP for loop'
H6AE9805023F0: 'OpenMP for 迴圈的每次迭代必須導致 %0 %select{減少|增加}1'
# 'incremented enumerator value %0 is not representable in the largest integer type'
H33F55260A9EF: '遞增的枚舉值 %0 超出最大整數型態的表示範圍'
# 'incrementing expression of type bool is deprecated and incompatible with C++17'
HB438D9D07956: '使用 bool 型態的增量運算式已棄用，且與 C++17 不兼容'
# 'increments 8-bit counter for every edge'
H286B107846BC: '每邊緣遞增 8 位計數器'
# "indeterminate value can only initialize an object of type 'unsigned char'%select{, 'char',|}1 or 'std::byte'; %0 is invalid"
H26C79B7B3090: "不確定值只能初始化 %select{|、'char'、}1 'unsigned char' 或 'std::byte' 類型的物件；%0 無效"
# 'index %0 must appear exactly once in the permutation clause'
H907BCB3D7A64: '索引 %0 必須在排列子句中恰好出現一次'
# 'index for __builtin_shufflevector must be a constant integer'
H2AA72873C8D9: '__builtin_shufflevector的索引必須是常數整數'
# 'index for __builtin_shufflevector must be less than the total number of vector elements'
HDC5D16284BAC: '__builtin_shufflevector的索引必須小於向量元素的總數'
# 'index for __builtin_shufflevector not within the bounds of the input vectors; index of -1 found at position %0 is not permitted in a constexpr context'
H0F3D61BA78F9: '在constexpr上下文中，輸入向量的索引超出範圍；在位置 %0 發現的-1索引是不允許的'
# 'indexing expression is invalid because subscript type %0 has multiple type conversion functions'
H28D375C7CDB6: '索引運算式無效，因為下標類型 %0 具有多個類型轉換函數'
# 'indexing expression is invalid because subscript type %0 is not an Objective-C pointer'
H76E63693A71C: '索引運算式無效，因為下標類型 %0 不是 Objective-C 指標'
# 'indexing expression is invalid because subscript type %0 is not an integral or Objective-C pointer type'
H5DB003FBDC67: '索引運算式無效，因為下標類型 %0 不是整數或 Objective-C 指標類型'
# 'indexing of array without known bound is not allowed in a constant expression'
HE2B8FD1CE633: '在已知邊界前對陣列進行索引在常數運算式中是不允許的'
# 'indirect call promotion'
H63A9B36F7D0A: '間接呼叫提升'
# 'indirect goto in function with no address-of-label expressions'
H145FEAAFA432: '在未使用標籤地址的函數中使用間接 goto'
# 'indirection not permitted on operand of type %0'
H2DF3DCAF7C13: '類型 %0 的操作元不允許進行間接存取'
# 'indirection of non-volatile null pointer will be deleted, not trap'
H016B5CE240D6: '非揮發性空指標的間接存取將被刪除而非觸發異常'
# 'indirection requires pointer operand (%0 invalid)'
H17A67BCCC65A: '間接存取需要指標運算式（%0 無效）'
# 'infer execution count for fall-through blocks'
H5D8BF838CEAA: '推論跳躍塊的執行次數'
# "inferred framework modules cannot be 'explicit'"
HAC0CEE5A9591: "推論的框架模組不能標示為 'explicit'"
# 'inferred submodule cannot be a framework submodule'
H3C9148B14284: '推論的子模組不能是框架子模組'
# 'inferred submodules require a module with an umbrella'
HB4F6C039EA5A: '帶有umbrella模組的推論子模組才有效'
# "inferring '_Nonnull' for pointer type within %select{array|reference}0 is deprecated"
H0BCF4D33599B: "在%select{陣列|參考}0中的指標類型推論 '_Nonnull' 已棄用"
# 'inheritance model does not match %select{definition|previous declaration}0'
H6F4F77A5056C: '繼承模型與%select{定義|先前宣告}0不符'
# 'inheritance model ignored on %select{primary template|partial specialization}0'
H5E5E4985C4D2: '在%select{主要範本|部分特化}0上忽略繼承模型設定'
# 'inherited from base class %0 here'
H942CB9135C88: '從基底類別 %0 繼承至此'
# 'inherited virtual base class %1 has %select{private|protected}2 destructor'
HC776172C0FE5: '虛基類別 %1 的 %select{private|protected}2 析構函數'
# 'inheriting constructors are incompatible with C++98'
H811CC4188AC3: '虛構函數與C++98不相容'
# 'inherits from superclass %0 here'
HFC19FC83A6FB: '從超類別 %0 繼承至此'
# 'init method must return a type related to its receiver type'
HE0B5DF2EAC96: '初始化方法必須返回與接收器類型相關的類型'
# 'init methods must return a type related to the receiver type'
H77EF2E241D1F: '所有初始化方法必須返回與接收器類型相關的類型'
# 'init methods must return an object pointer type, not %0'
HA49BF476668F: '初始化方法必須返回物件指標類型，而非 %0'
# "initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')"
H55BD0EE327C7: 'OpenMP for迴圈的初始化子句必須為標準形式（"var = init" 或 "T var = init"）'
# 'initialization is not supported for __shared__ variables'
H36A01643C5A6: '__shared__變數不支援初始化'
# 'initialization of %0 may run twice when built into a shared library: it has hidden visibility and external linkage'
H8FC0CAE3AC23: '初始化 %0 可能在建置為共享函式庫時執行兩次：其可見性為隱藏但具有外部連結性'
# "initialization of %select{|signed }0char array with UTF-8 string literal is not permitted by %select{'-fchar8_t'|C++20}1"
H2A8B3176C3CF: "使用 UTF-8 字符串文字初始化 %select{|有符號 }0char 陣列不被 %select{'-fchar8_t'|C++20}1 所允許"
# 'initialization of an array %diff{of type $ from a compound literal of type $|from a compound literal}0,1 is a GNU extension'
HA729653B7153: '以複合字面值初始化陣列%diff{類型$的$|從複合字面值}1,0是GNU擴充功能'
# 'initialization of flexible array member is not allowed'
H080F42BFBE3B: '無法初始化柔性陣列成員'
# 'initialization of incomplete type %0'
H8382A60542C7: '初始化不完整類型 %0'
# 'initialization of initializer_list object is incompatible with C++98'
HB868A7DFE86A: 'initializer_list 物件的初始化與 C++98 不相容'
# 'initialization of non-aggregate type %0 with a designated initializer list'
HD9BEB3E28681: '使用命名初始化器清單初始化非聚合類型 %0'
# 'initialization of non-aggregate type %0 with an initializer list'
HD61976EAB0C6: '使用初始化器清單初始化非聚合類型 %0'
# 'initialization of pointer of type %0 to null from a constant boolean expression'
HF7B6BD10B980: '%0 類型的指標初始化為來自常數布林運算式的空值'
# 'initialization statement is not supported when iterating over Objective-C collection'
H6990A52E0D21: '在迭代 Objective-C 集合時，初始化語句不受支援'
# 'initialize the variable %0 to silence this warning'
HFBFEA45EAD29: '初始化變數 %0 以消除此警告'
# 'initialized flexible array member %0 is here'
H040CBD4967B6: '已初始化的彈性陣列成員 %0 在此處'
# 'initialized here %0'
H6E543F660366: '在此處初始化 %0'
# 'initialized lambda capture packs are incompatible with C++ standards before C++20'
H4508A321B7A7: '初始化的 lambda 捕獲封包與 C++20 之前的標準不相容'
# 'initialized lambda captures are a C++14 extension'
HE17291BEDE3D: '初始化的 lambda 捕獲是 C++14 的擴充功能'
# 'initialized lambda captures are incompatible with C++ standards before C++14'
H4B4A5D06C778: '初始化的 lambda 捕獲與 C++14 之前的標準不相容'
# 'initialized lambda pack captures are a C++20 extension'
H7BA4847E4BDF: '初始化的 lambda 封包捕獲是 C++20 的擴充功能'
# 'initializer %0 does not name a non-static data member or base class; did you mean the %select{base class|member}1 %2?'
HBFA8CB0E43F8: '初始化器 %0 未指定非靜態資料成員或基類；您是否指的是 %select{基類|成員}1 %2？'
# 'initializer %select{partially |}0overrides prior initialization of this subobject'
H5DE4CB24B2D2: '初始化器 %select{部分覆蓋|}0 先前對此子物件的初始化'
# 'initializer element is not a compile-time constant'
H132D68BCCE73: '初始化器元素並非編譯期間常數'
# 'initializer for aggregate is not a compile-time constant'
H6A5ECCAF1E62: '聚合的初始化器並非編譯期間常數'
# 'initializer for aggregate with no elements requires explicit braces'
H2820D73AEF2F: '無元素的聚合初始化器需要明確的大括號'
# 'initializer for functional-style cast to %0 contains multiple expressions'
H98881129A20C: '對 %0 進行函數式轉型的初始化器包含多個運算式'
# 'initializer for functional-style cast to %0 is empty'
H4EA4C8E23F55: '以 %0 進行函數式類型轉換的初始值設定為空值'
# 'initializer for lambda capture %0 contains multiple expressions'
H66A3A7273E8A: 'lambda傳遞清單 %0 的初始值設定包含多個運算式'
# 'initializer for sizeless type %0 cannot be empty'
H8FFA617F38FD: '無大小型 %0 的初始值設定不能為空'
# 'initializer for thread-local variable must be a constant expression'
HD7C0523C87D0: '執行緒局部變數的初始值設定必須是常數運算式'
# 'initializer for variable %0 with type %1 contains multiple expressions'
HA7D83169E121: '型別 %1 的變數 %0 初始值設定包含多個運算式'
# 'initializer for variable %0 with type %1 is empty'
HD6A61B62F49C: '型別 %1 的變數 %0 初始值設定為空'
# 'initializer for virtual base class %0 of abstract class %1 will never be used'
H377D13F4BA4B: '抽象類別 %1 的虛基類 %0 的初始值設定器永遠不會被使用'
# "initializer list cannot be used on the %select{left|right}0 hand side of operator '%1'"
H08A1BB46A564: "初始化清單無法用於運算子 '%1' 的%select{左|右}0邊側"
# 'initializer missing for lambda capture %0'
H362962332DA4: 'lambda傳遞清單 %0 缺少初始值設定'
# 'initializer of %0 is not a constant expression'
HF34500BAECA9: '%0 的初始值設定並非常數運算式'
# 'initializer of %0 is unknown'
H4815D272C20B: '%0 的初始值設定未定義'
# 'initializer of weak variable %0 is not considered constant because it may be different at runtime'
HBD6BC73EA44F: '弱變數 %0 的初始值設定器未被視為常數，因為它在執行階段可能不同'
# 'initializer on function does not look like a pure-specifier'
H79A85F4AF5C7: '函數的初始值設定器看起來不像是純規格指定'
# 'initializer order does not match the declaration order'
HBA21FCA776B9: '初始值設定器的順序與宣告的順序不匹配'
# 'initializer priorities are not supported in HLSL'
HFAA073E424F4: '初始化器的優先權在HLSL中不被支援'
# 'initializer would partially override prior initialization of object of type %1 with non-trivial destruction'
H52C4E394B1C2: '初始值設定器會部分覆寫先前對型別 %1 物件的初始化（該物件具有非平凡銷毀特性）'
# 'initializer-string for char array is too long'
HF948F6263A8D: '字元陣列的初始值字串過長'
# 'initializer-string for char array is too long, array size is %0 but initializer has size %1 (including the null terminating character)'
H17CD335B9F9F: '字元陣列的初始值字串過長，陣列大小為 %0 但初始值設定的大小為 %1（包含空終止字元）'
# 'initializing %0 from an empty initializer list is incompatible with C++98'
H822723DC0E42: '從空初始值清單初始化 %0 與C++98不相容'
# "initializing 'char8_t' array with plain string literal"
H1EA4AB240813: "使用純字面字串初始化 'char8_t' 陣列"
# "initializing an array from a '%0' predefined identifier is a Microsoft extension"
H8573434E16CF: "從 '%0' 預定義識別符初始化陣列是Microsoft擴充"
# 'initializing char array with wide string literal'
H698D73717CFB: '使用寬字元字面值初始化char陣列'
# 'initializing field %0 with default member initializer'
HC1BC6A14F9CB: '使用成員預設初始化器初始化成員 %0'
# 'initializing multiple members of union'
HC7C97F10525A: '初始化聯盟中的多個成員'
# 'initializing parameter %0 with default argument'
H20102CE039A6: '使用預設參數初始化參數 %0'
# 'initializing pointer member %0 to point to a temporary object whose lifetime is shorter than the lifetime of the constructed object'
H705DCA77F9DC: '將指標成員 %0 初始化為指向生存期短於所建構物件的臨時物件'
# 'initializing pointer member %0 with the stack address of %select{variable|parameter}2 %1'
HF09BD5727610: '將指標成員 %0 初始化為%select{變數|參數}2 %1 的堆疊位址'
# 'initializing wide char array with incompatible wide string literal'
HA0905D8F9102: '使用與寬字元陣列不相容的寬字元字面值初始化寬字元陣列'
# 'initializing wide char array with non-wide string literal'
H708EA2B0EAB3: '使用非寬字元字面值初始化寬字元陣列'
# 'inline all checks'
HF0EA4880CACC: '內联所有檢查'
# 'inline all functions'
HEE76F6E2509B: '內联所有函數'
# 'inline assembly label %0 declared here'
H1FAD9492270E: '此處宣告內联組件標籤 %0'
# 'inline declaration of %0 follows non-inline definition'
H9E262DCDBF26: '非內联定義後跟隨的 %0 內联宣告'
# 'inline declaration of %0 not allowed in block scope'
H0812ED282234: '區塊作用域中不允许 %0 的內联宣告'
# 'inline function %q0 is not defined'
HC9FA92373F42: '內联函數%q0未定義'
# 'inline function not defined%select{| before the private module fragment}0'
H195EBE25939A: '內联函數未定義 %select{|前的私人模組片段}0'
# 'inline function performs a conversion which is forbidden in ARC'
H46AB09EDECD4: '內联函數在ARC中執行了被禁止的轉換'
# 'inline functions based on how much of the function is a scop.'
H1DDDFC8B898C: '根據函數作用域範圍的大小來選擇內联函數'
# 'inline functions if increase in size is less than defined by -inline-small-functions-bytes'
HF2FBAE9C268E: '若程式碼大小增加量小於-inline-small-functions-bytes參數定義的值時內联函數'
# 'inline functions with CFI programs (can break exception handling)'
H6C3FCE1081BE: '使用CFI程式內联函數（可能導致例外處理失效）'
# 'inline leaf functions with CFI programs (can break unwinding)'
H8B9275AE6FE3: '內聯葉函數與CFI程式（可能導致回溯中斷）'
# "inline memcpy using 'rep movsb' instruction (X86-only)"
H1E31B40E5C1D: "使用 'rep movsb' 指令內联 memcpy (X86 专用)"
# 'inline namespace reopened as a non-inline namespace'
H46A1E728D683: '內聯命名空間被重新開放為非內聯命名空間'
# 'inline namespaces are a C++11 feature'
H39D356D1A5FD: '內聯命名空間是C++11的功能'
# 'inline namespaces are incompatible with C++98'
HFE4E3495E8EA: '內聯命名空間與C++98不相容'
# 'inline nested namespace definition is a C++20 extension'
HF12053D31358: '內聯嵌套命名空間定義是C++20擴充'
# 'inline nested namespace definition is incompatible with C++ standards before C++20'
HDC23554C291A: '內聯嵌套命名空間定義與C++20之前的標準不相容'
# 'inline variable %q0 is not defined'
H2B60738BBC75: '內聯變數%q0未定義'
# 'inline variables are a C++17 extension'
H427269D7064C: '內聯變數是C++17擴充'
# 'inline variables are incompatible with C++ standards before C++17'
HCE89C300F33E: '內聯變數與C++17之前的標準不相容'
# "inner loops must be tightly nested inside a '%0' clause on a '%1' construct"
HE18366CA8367: "'%1' 結構中的 '%0' 子句必須將內部迴圈緊密嵌套於其內"
# 'input bitcode file which can override previously defined symbol(s)'
HDFE5316187C5: '可覆寫先前定義符號的輸入位元碼檔案'
# 'input conversion stopped due to an input byte that does not belong to the input codeset UTF-8'
HC2B0606B1239: '輸入轉換因輸入字元集UTF-8以外的位元而終止'
# 'input files'
H69B53967F9CE: '輸入檔案'
# "input is not a PCH file: '%0'"
H0BA9CA2C72E0: "輸入不是PCH檔案：'%0'"
# 'input objects'
H6ADBB11C54B0: '輸入物件'
# "insert '%0;' to silence this warning"
H7C4DAFCB5A75: "插入 '%0;' 以消除此警告"
# "insert '%select{_Nonnull|_Nullable|_Null_unspecified}0' if the %select{pointer|block pointer|member pointer|array parameter}1 %select{should never be null|may be null|should not declare nullability}0"
H95F6AD57B128: "若%select{指標|區塊指標|成員指標|陣列參數}1%select{永遠不會為空|可能為空|應不宣告空值}0，請插入 '%select{_Nonnull|_Nullable|_Null_unspecified}0'"
# "insert ',' before '...' to silence this warning"
H84706E906BF0: '在 "..." 前插入 "," 以消除此警告'
# "insert 'break;' to avoid fall-through"
H4EC7EA05AEDF: '插入 "break;" 以避免穿透'
# 'insert an explicit cast to silence this issue'
H21D74C2B0346: '插入明確轉換以抑制此問題'
# 'insert tail call traps'
H8C2E3910BD93: '插入尾調用陷阱'
# 'insert traps in old function bodies (relocation mode)'
H625478AB58CF: '(重新定位模式) 在舊函數本體中插入陷阱'
# "install_name does not match: '%0' (provided) vs '%1' (found)"
H748B1AE34A35: "install_name 不符合：'%0'（提供的）與 '%1'（找到的）"
# 'instance method %0 found instead of class method %1'
H1FCFE23050D1: '找到實例方法 %0 而非類方法 %1'
# "instance method %0 is being used on 'Class' which is not in the root class"
H214A12BD7783: "在非根類別的 'Class' 上使用實例方法 %0"
# "instance method %objcinstance0 not found (return type defaults to 'id')"
HAFE085EFCB1C: "未找到實例方法 %objcinstance0（返回類型預設為 'id'）"
# "instance method %objcinstance0 not found (return type defaults to 'id'); did you mean %objcinstance2?"
H44E31EFE4C27: "未找到實例方法 %objcinstance0（返回類型預設為 'id'）；您是否想要 %objcinstance2？"
# 'instance variable %0 accessed in class method'
H3EADF48ACA9A: '在類方法中存取實例變數 %0'
# 'instance variable %0 declared with incompatible types in different translation units (%1 vs. %2)'
HBFCDBA937742: '不同翻譯單元中實例變數 %0 的類型不相容 (%1 vs. %2)'
# 'instance variable %0 has conflicting bit-field width'
H2B77404519CC: '實例變數 %0 的 bit-field 寬度衝突'
# 'instance variable %0 has conflicting type%diff{: $ vs $|}1,2'
H9D5CF719769D: '實例變數 %0 的類型%diff{衝突：$ 與 $|}0,1'
# 'instance variable %0 is being directly accessed'
H3F2D0ABA6990: '正在直接存取實例變數 %0'
# 'instance variable %0 is private'
HDB3564656CA2: '實例變數 %0 是私有'
# 'instance variable %0 is protected'
HD16F20CBE669: '實例變數 %0 是受保護'
# 'instance variable is already declared'
H801D25BC5C9A: '實例變數已宣告過'
# 'instance variable is declared here'
H1FC75F163FBE: '實例變數在此宣告'
# 'instance variable of type %0 has %select{private|protected}1 destructor'
HA9F26F512B98: '類型 %0 的實例變數具有%select{私有|受保護}1 析構函數'
# 'instance variables cannot be of reference type'
HCCF4E9A4856E: '實例變數不能是參考類型'
# 'instance variables may not be placed in %select{categories|class extension}0'
H0D800B785119: '實例變數不得放置在%select{分類|類別擴展}0中'
# 'instance variables must have a constant size'
H99AB003B5614: '實例變數必須具有固定大小'
# 'instantiated into assembly here'
H396FFF689BB5: '在此處轉換為組合語言'
# 'instantiating fold expression with %0 arguments exceeded expression nesting limit of %1'
H467EDA4122CE: '使用 %0 個參數實例化摺疊運算式時超過了 %1 層的運算式嵌套限制'
# 'instantiation of %q0 is different in different modules'
H7179BAA1427A: '%q0在不同模組中的實例化不同'
# "instantiation of '%0' not supported yet"
H5578212F4DA3: "尚未支援 '%0' 的實例化"
# 'instantiation of function %q0 required here, but no definition is available'
H88BC3AB38294: '在此處需要實例化函數%q0，但未提供定義'
# 'instantiation of variable %q0 required here, but no definition is available'
H4C7FC0EFFE4E: '在此處需要實例化變數%q0，但未提供定義'
# 'instrument atomic instructions (rmw, cmpxchg)'
H9BDE4655B194: '插樁原子指令（rmw、cmpxchg）'
# 'instrument byval arguments'
H6881238D18AA: '插樁byval參數'
# 'instrument byval call arguments'
H6F6BC27C3374: '插樁呼叫的byval參數'
# 'instrument code to generate accurate profile data'
HE308C13DB62F: '插樁程式碼以產生精確的剖析資料'
# 'instrument dynamic allocas'
HBD70EB33F966: '插樁動態allocas'
# 'instrument landing pads'
HEB0B3F6EFDA4: '插樁着陸墊'
# 'instrument memory intrinsics'
HA6D9147CFA12: '插樁記憶體內建函數'
# 'instrument personality functions'
HD5594587E387: '插樁人格函數'
# 'instrument read instructions'
H064E58E10C74: '插樁讀取指令'
# 'instrument reads and writes with callbacks'
H29E9BA5B8A64: '以回呼函數插樁讀取和寫入'
# 'instrument stack (allocas)'
HD0DD117BE7BA: '插樁堆疊（allocas）'
# 'instrument write instructions'
HA31AFF85F744: '插樁寫入指令'
# 'instrumentation map used to identify function ids. Currently supports elf file instrumentation maps.'
HABD136211445: '用於識別函數ID的插樁地圖。目前支援ELF檔案插樁地圖。'
# 'integer constant expression evaluates to value %0 that cannot be represented in a %1-bit %select{signed|unsigned}2 integer type'
HA689EA8A19CC: '%select{有符號|無符號}2整數類型的 %1 位中無法表示整數常量運算式求值的值 %0'
# 'integer constant not in range of enumerated type %0'
H38F9A13FA923: '枚舉類型 %0 的整數常量超出範圍'
# 'integer literal is too large to be represented in a signed integer type, interpreting as unsigned'
H510046C2B2ED: '整數字面量無法用有符號整數類型表示，將解釋為無符號類型'
# 'integer literal is too large to be represented in any %select{signed |}0integer type'
H586D057CD6B8: '整數字面量無法在%select{有符號 |}0 整數類型中表示'
# "integer literal is too large to be represented in type 'long' and is subject to undefined behavior under C++98, interpreting as 'unsigned long'; this literal will %select{have type 'long long'|be ill-formed}0 in C++11 onwards"
H84C22AB83CDC: "此字面量在C++11及之後版本將%select{具有 'long long' 類型|不符合語法}0。因無法在 'long' 類型中表示，根據C++98將解釋為 'unsigned long'"
# "integer literal is too large to be represented in type 'long', interpreting as 'unsigned long' per C++98; this literal will %select{have type 'long long'|be ill-formed}0 in C++11 onwards"
H4C2C8A72E536: "此字面量在C++11及之後版本將%select{具有 'long long' 類型|不符合語法}0。因無法在 'long' 類型中表示，根據C89將解釋為 'unsigned long'"
# "integer literal is too large to be represented in type 'long', interpreting as 'unsigned long' per C89; this literal will %select{have type 'long long'|be ill-formed}0 in C99 onwards"
H58DBBF3A9BD1: "此字面量在C99及之後版本將%select{具有 'long long' 類型|不符合語法}0。因無法在 'long' 類型中表示，根據C89將解釋為 'unsigned long'"
# 'integer overflow in preprocessor expression'
H24214C6EA913: '預處理器運算式中發生整數溢位'
# 'integer sequences must have integral element type'
H16392B2B25B5: '整數序列必須具有整數型別元素'
# 'integer sequences must have non-negative sequence length'
HC3DBF19F94A9: '整數序列必須具有非負長度'
# 'integer value %0 is outside the valid range of values [%1, %2] for the enumeration type %3'
HB6C02E17F94C: '枚舉類型 %3 的有效值範圍[%1, %2]外的整數值 %0'
# 'integral constant expression has incomplete class type %0'
H52768B5A0D44: '具有不完整類別類型 %0 的整數常量運算式'
# 'integral constant expression requires explicit conversion from %0 to %1'
H482F498F126E: '需要明確轉換 %0 至 %1 才能形成整數常量運算式'
# 'interface type %1 cannot be %select{returned|passed}0 by value; did you forget * in %1?'
H5F16699831A7: '%select{傳回|傳遞}0介面類型 %1 時必須使用指標；是否在 %1 中遺漏了*？'
# 'interface type cannot be statically allocated'
HFB7A102C4547: '無法以靜態儲存類別宣告介面類型'
# 'interface type cannot inherit from %select{struct|non-public interface|class}0 %1'
HE603DB4B7CDD: '介面類型無法繼承%select{結構|非公開介面|類別}0 %1'
# "interface types cannot specify '%select{private|protected}0' access"
H5BB34D1AC02B: "介面類型無法指定'%select{私有|受保護}0'存取修飾符"
# "interop type '%0' cannot be specified more than once"
H92EFF909211E: "互通類型 '%0' 只能指定一次"
# 'interop variable %0 used in multiple action clauses'
H6D1E048E9343: '互通變數 %0 用於多個動作子句中'
# "interop variable must be of type 'omp_interop_t'"
H4EE913CC5003: "interop變數必須為類型 'omp_interop_t'"
# 'interrupt service routine cannot be called directly'
H0EEEBB03E095: '中斷服務常式不可直接呼叫'
# "interrupt service routine with vfp enabled may clobber the interruptee's vfp state"
H55034798B0BD: '啟用vfp的中斷服務常式可能會破壞被中斷的函數的vfp狀態'
# 'interval between profile writes (default: 0 = write only at program end).  This is useful for service workloads when you want to dump profile every X minutes or if you are killing the program and the profile is not being dumped at the end.'
H3081FD16F975: '剖析寫入間隔（預設值：0 = 程式結束時寫入）。此選項對服務負載有幫助，當您希望每X分鐘輸出剖析資料，或在終止程式時剖析資料未被輸出的情況下使用'
# 'intrinsic module directory'
H68E291291712: '內在模組目錄'
# 'intrinsic module search paths'
H9C8DEF0487D6: '內在模組搜尋路徑'
# 'introduce a module file extension for testing purposes. The argument is parsed as blockname:major:minor:hashed:user info'
HC4A3048AAD1F: '為測試目的新增模組檔擴充項。參數會被解析為 blockname:major:minor:hashed:user info 的格式'
# 'introduce a parameter name to make %0 part of the selector'
HF88F126D64B8: '引介參數名稱以將 %0 納入選擇器（selector）'
# 'invalid #ident directive'
H33DD8376B05A: '無效的#ident指示項'
# 'invalid %% escape in inline assembly string'
HDBE197B56289: '內嵌組裝字串中無效的%%轉義'
# "invalid %0 at end of declaration; did you mean '='?"
H6911F0CCF565: '宣告末尾的 %0 無效；您是否想要使用 "="？'
# 'invalid %select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 %select{floating-point|enumeration}1 type %2 %plural{2:with|4:from|:and}0 %select{enumeration|floating-point}1 type %3'
H06A881D8D9FE: '無效的%select{浮點數/列舉型別間的算術運算|浮點數/列舉型別間的位元運算|浮點數/列舉型別的比較|浮點數/列舉型別間的條件運算式|浮點數/列舉型別的複合指派}0 %select{浮點數|列舉}1 類型 %2 %plural{2:與|4:從|:和}0 %select{列舉|浮點數}1 類型 %3'
# 'invalid %select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2'
H796D4C8F35F6: '不同列舉型別的%select{算術運算|位元運算|比較|條件運算式|複合指派}0 無效%diff{（$和$）|}0,1'
# 'invalid %select{branch|return|throw}0 %select{out of|into}1 OpenACC Compute/Combined Construct'
H898CA374F6B7: '無效的%select{分支|返回|拋出}0 %select{超出|進入}1 OpenACC Compute/Combined 架構'
# 'invalid %select{constructor|destructor}0 declaration'
HDEF8993ADCB9: '無效的%select{建構函數|析構函數}0 宣告'
# "invalid 'this' expression on 'map' clause"
H008D791665EC: "在 'map' 子句中的 'this' 運算式無效"
# "invalid -Xopenmp-target argument: '%0', options requiring arguments are unsupported"
H705427655A77: "無效的-Xopenmp-target 參數：'%0'，需要參數的選項不受支援"
# "invalid C++ ABI name '%0'"
H8F1C2E5DB890: "無效的C++ ABI名稱 '%0'"
# "invalid CoreFoundation Runtime ABI '%0'; must be one of 'objc', 'standalone', 'swift', 'swift-5.0', 'swift-4.2', 'swift-4.1'"
H91493C3284DF: "無效的CoreFoundation執行階段ABI '%0'；必須是以下其中一個：'objc', 'standalone', 'swift', 'swift-5.0', 'swift-4.2', 'swift-4.1'"
# 'invalid Darwin version number: %0'
HA0C57A49CA76: '無效的Darwin版本號：%0'
# "invalid OS value '%0' in '%1'"
H00BD3F016742: "無效的作業系統值 '%0' 在 '%1' 中"
# 'invalid OpenACC clause %0'
HA3099393E590: '無效的OpenACC子句 %0'
# "invalid OpenACC directive %select{%1|'%1 %2'}0"
H74A42ADBF419: "無效的OpenACC指令 %select{%1|'%1 %2'}0"
# 'invalid PCS type'
H696D824B4D2C: '無效的PCS類型'
# "invalid RVV vector size '%0', expected size is '%1' based on LMUL of type and '-mrvv-vector-bits'"
H96A03531A0AD: "無效的RVV向量大小 '%0'，根據類型的LMUL和 '-mrvv-vector-bits'，期望的大小為 '%1'"
# "invalid SVE vector size '%0', must match value set by '-msve-vector-bits' ('%1')"
HF993CA8A3093: "無效的SVE向量大小 '%0'，必須與 '-msve-vector-bits' 設置的值（'%1'）一致"
# 'invalid UTF-8 in comment'
H58EB41DE8F48: '注釋中的無效UTF-8'
# "invalid Xarch argument: '%0', not all driver options can be forwared via Xarch argument"
HA12658A01ACA: "無效的Xarch參數：'%0'，並非所有驅動程式選項均可通過Xarch參數轉發"
# "invalid Xarch argument: '%0', options requiring arguments are unsupported"
H7917BEC4B42C: "無效的Xarch參數：'%0'，需要參數的選項未被支援"
# 'invalid __hlsl_resource_t type attributes'
H9A97FF7B54BE: '無效的__hlsl_resource_t類型屬性'
# 'invalid address discrimination mode %0'
H1D217687F248: '無效的地址區分模式 %0'
# "invalid alignment option in '#pragma %select{align|options align}0' - ignored"
H410475644E70: "在 '#pragma %select{align|options align}0' 中發現無效的對齊選項 - 已忽略"
# "invalid application of '%0' to %select{an incomplete|sizeless}1 type %2"
H3984632B643A: "對%select{不完整|無尺寸}1類型 %2 不恰當地應用 '%0'"
# "invalid application of '%0' to WebAssembly table"
HA443432F106F: "對WebAssembly表格不恰當地應用 '%0'"
# "invalid application of '%0' to a function type"
HFD1A077F0D84: "對函數類型不恰當地應用 '%0'"
# "invalid application of '%0' to a void type"
H3290D1C688B6: "對void類型不恰當地應用 '%0'"
# "invalid application of '%select{sizeof|alignof|typeof|typeof_unqual}0' to bit-field"
H4D97635BE644: "不恰當地對位域使用 '%select{sizeof|alignof|typeof|typeof_unqual}0'"
# "invalid application of '__builtin_omp_required_simd_align' to an expression, only type is allowed"
H0F35C466B34C: "對表達式不恰當地使用 '__builtin_omp_required_simd_align'，只能用於類型"
# "invalid application of 'alignof' to a field of a class still being defined"
H584C8A2541E4: "對仍在定義中的類別的成員不恰當地使用 'alignof'"
# "invalid application of 'offsetof' to a field of a virtual base"
H7E5DD90FD952: "對虛基類的成員不恰當地使用 'offsetof'"
# "invalid arch name '%0'"
H053EB6DE40C8: "無效的CPU名稱 '%0'"
# "invalid arch name '%0', %1"
HAF3A77CFBCF8: "無效的CPU名稱 '%0'，%1"
# 'invalid argument %0 to function: %1, expecting a generic pointer argument'
H45B49DB90594: '函數 %0 的無效參數類型：%1，期望一個通用指標參數'
# "invalid argument '%0' not allowed with '%1'"
H5F814EC912CC: "與 '%1' 一起使用時，'%0' 參數無效"
# "invalid argument '%0' only allowed with '%1'"
HCD365CC8E5D4: "只有與 '%1' 一起使用時才允許 '%0' 參數"
# "invalid argument '%0' to -%1"
H8405E80D8137: "對-%1 使用無效參數 '%0'"
# "invalid argument '%0' to -malign-branch=; each element must be one of: %1"
H20657E1CDBBF: "對-malign-branch=使用無效參數 '%0'；每個元素必須是以下之一：%1"
# "invalid argument '%0' to -mfpu=; must be one of: 64, 32, none, 0 (alias for none)"
HF131652C4C29: "對-mfpu=使用無效參數 '%0'；必須是以下之一：64、32、none、0（none的別名）"
# "invalid argument '%0' to -msimd=; must be one of: none, lsx, lasx"
H2BA112BC46B6: "對-msimd=使用無效參數 '%0'；必須是以下之一：none、lsx、lasx"
# "invalid argument '%0' to atomic attribute; valid options are: 'remote_memory', 'fine_grained_memory', 'ignore_denormal_mode' (optionally prefixed with 'no_')"
H438B1A442EF4: "原子屬性無效參數 '%0'；有效選項包括：'remote_memory'、'fine_grained_memory'、'ignore_denormal_mode'（可選擇在前面加上 'no_'）"
# "invalid argument '-mno-amdgpu-ieee' only allowed with relaxed NaN handling"
H507F0448DDCC: '對-mno-amdgpu-ieee使用無效參數，僅允許在鬆弛NaN處理時使用'
# "invalid argument in '%0', only integer or 'auto' is supported"
H40210717B247: "在 '%0' 中使用無效參數，僅支持整數或 'auto'"
# "invalid argument in '%0', only integers are supported"
H7CC5EAE0927D: "在 '%0' 中使用無效參數，僅支持整數"
# 'invalid argument of type %0; expected an integer type'
HDC97D348BCF9: '類型 %0 的無效引數；期望整數類型'
# 'invalid argument to convert to character'
H035CE8B39D0F: '無法轉換為字符的無效參數類型'
# 'invalid argument type %0 to unary expression'
HB7A2329B026C: '一元表達式無效的參數類型 %0'
# 'invalid argument type to function %0 (expecting %1 having %2)'
H740D8FB32D84: '函數 %0 的參數類型無效（期望 %1 具有 %2）'
# 'invalid argument: symbol must be a device-side function or global variable'
HB29E0DD1BCB5: '無效的參數；符號必須是裝置端函數或全域變數'
# "invalid argument; expected 'disable'"
H14256C1A2363: "無效引數；期望 'disable'"
# "invalid argument; expected 'enable'%select{|, 'full'}0%select{|, 'assume_safety'}1 or 'disable'"
H369903756AB7: "無效引數；期望 'enable'%select{|, 'full'}0%select{|, 'assume_safety'}1 或 'disable'"
# 'invalid authentication key %0'
H1380B8ED725A: '無效的驗證金鑰 %0'
# 'invalid block pointer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2'
H1E4447440EDF: '無效的區塊指標轉換 %select{%diff{將$指派給$|指派給不同類型}1,0|%diff{將$傳遞給類型$的參數|傳遞到不同類型的參數}1,0|%diff{從返回類型為$的函數返回$|從不同返回類型的函數返回}1,0|%diff{將$轉換為類型$|在類型之間轉換}1,0|%diff{用類型$的運算式初始化$|用不同類型的運算式初始化}1,0|%diff{將$傳送到類型$的參數|傳送到不同類型的參數}1,0|%diff{將$轉換為類型$|在類型之間轉換}1,0}2'
# 'invalid block variable declaration - must be %select{const qualified|initialized}0'
HF892D907A5A7: '無效的區塊變數宣告 - 必須%select{具const修飾|已初始化}0'
# "invalid block variable declaration - using 'extern' storage class is disallowed"
H2029EAB9FA9A: "無效的區塊變數宣告 - 禁止使用 'extern' 儲存類別"
# 'invalid branch into OpenACC Compute/Combined Construct'
HC49FDF0B5C89: '非法分支到OpenACC Compute/Combined Construct內部'
# 'invalid branch out of OpenACC Compute/Combined Construct'
H921800904C81: '非法從OpenACC Compute/Combined Construct分支出去'
# "invalid branch protection option '%0' in '%1'"
H69A222420F22: "在 '%1' 中無效的分支保護選項 '%0'"
# "invalid character '%0' in raw string delimiter; use PREFIX( )PREFIX to delimit raw string"
H82170E32D0E4: "原始字串分隔符中的無效字元 '%0'；使用PREFIX( )PREFIX來界定原始字串"
# "invalid comparison flag %0; use 'layout_compatible' or 'must_be_null'"
H677EA1A68EB0: "無效的比較旗標 %0；使用 'layout_compatible' 或 'must_be_null'"
# "invalid component '%0' used; expected 'x', 'y', 'z', or 'w'"
H32632D0CDE2F: "使用了無效的元件 '%0'；期望的元件為 'x'、'y'、'z' 或 'w'"
# 'invalid constructor from class in system header, should not be explicit'
HEFC602372E3E: '系統標頭中的類別構造器不應為顯式'
# 'invalid conversion between ext-vector type %0 and %1'
H4E43BF77A891: '擴展向量類型 %0 與 %1 之間的轉換無效'
# 'invalid conversion between vector type %0 and integer type %1 of different size'
HAD5A2EB8C76E: '與不同大小的整數類型 %1 之間的向量類型 %0 轉換無效'
# 'invalid conversion between vector type %0 and scalar type %1'
H0E21BE8324C1: '與純量類型 %1 之間的向量類型 %0 轉換無效'
# 'invalid conversion between vector type%diff{ $ and $|}0,1 of different size'
H62FB40425AFD: '與%diff{ $ 和 $|}1,0 不同大小的向量類型轉換無效'
# "invalid conversion specifier '%0'"
H36DE3CE25255: "無效的格式指定符 '%0'"
# 'invalid covariant return for virtual function: %1 is a %select{private|protected}2 base class of %0'
HB307942D226E: '虛函數的協变返回類型無效：%1 是 %0 的 %select{私有|受保護}2 基類'
# 'invalid cpu feature string for builtin'
H63D2023D3150: '内置函數的無效 CPU 特性字串'
# 'invalid cpu name for builtin'
HD2B5E0F427CF: '内置函數的無效 CPU 名稱'
# 'invalid custom discrimination'
HBF55CC3D0D6C: '無效的自訂 discrimination'
# 'invalid declaration inside %select{tbuffer|cbuffer}0'
H75299BE36932: '%select{tbuffer|cbuffer}0 內的無效宣告'
# 'invalid declaration specifier in template non-type parameter'
HE0A0675789D7: '模板非類型參數中的無效宣告規範'
# 'invalid diagnostic type for \'diagnose_if\'; use "error" or "warning" instead'
HD2E5D476D869: 'diagnose_if 的無效診斷類型；請改用 "error" 或 "warning"'
# "invalid digit '%0' in %select{decimal|octal|binary}1 constant"
H6F9BD80EC0BE: "在 %select{十進位|八進位|二進位}1 常量中發現無效數字 '%0'"
# "invalid digit '%0' in escape sequence"
HF729B18CD0D2: "轉義序列中的無效數字 '%0'"
# "invalid escape sequence '%0' in an unevaluated string literal"
HF58F976119B7: "在未評估的字串字面量中發現無效的轉義序列 '%0'"
# "invalid exception model '%select{none|sjlj|seh|dwarf|wasm}0' for target '%1'"
H00FCEE8853CC: "目標 '%1' 的無效例外處理模型 '%select{none|sjlj|seh|dwarf|wasm}0'"
# 'invalid expected %0: %1'
HE0DC8B702320: '無效的期望 %0: %1'
# 'invalid explicit object parameter type %0 in lambda with capture; the type must be the same as, or derived from, the lambda'
H98E01B807F8E: '捕獲的 lambda 中的無效顯式物件參數類型 %0；類型必須與 lambda 相同，或從 lambda 派生'
# 'invalid explicit object parameter type %0 in lambda with capture; the type must derive publicly from the lambda'
H607716F86E02: '捕獲的 lambda 中的無效顯式物件參數類型 %0；類型必須公開從 lambda 派生'
# 'invalid extra discrimination selection %0'
HAC5AAEAB2B1D: '無效的額外 discrimination 選擇 %0'
# 'invalid feature combination: %0'
H53E34DDB7754: '無效的特性組合：%0'
# 'invalid field is here'
H6F033E1FBEC9: '無效的欄位在此處'
# 'invalid filename for #line directive'
H5BFFCF48D855: '#line 指令的無效的檔案名稱'
# 'invalid filename for line marker directive'
H6AF3C8643D27: '線標記指令的無效檔案名稱'
# 'invalid flag line marker directive'
H5CC65A10A5E0: '無效的旗標線標記指令'
# "invalid float ABI '%0'"
H606FAE3A11E2: "無效的浮點 ABI '%0'"
# "invalid iOS deployment version '%0', iOS 10 is the maximum deployment target for 32-bit targets"
HD422F25540A2: "無效的 iOS 部署版本 '%0'，32 位目標的最高部署目標為 iOS 10"
# 'invalid index %0 for pack %1 of size %2'
H1627FB393F43: '大小為 %2 的封包 %1 的無效索引 %0'
# "invalid input constraint '%0' in asm"
H09D927559067: "組合語言中的無效輸入限制 '%0'"
# "invalid input for analyzer-config option '%0', that expects %1 value"
HB14EB9C7A93F: "分析器配置選項 '%0' 的輸入無效，該選項期望 %1 值"
# "invalid input for checker option '%0', that expects %1"
H784B521FDFA9: "檢查器選項 '%0' 的輸入無效，該選項期望 %1"
# "invalid input size for constraint '%0'"
H8F6CDB6F0449: "限制 '%0' 的無效輸入大小"
# "invalid integral value '%1' in '%0'"
H6E04ED0681B7: "在 '%0' 中無效的整數值 '%1'"
# "invalid invocation of method '%0' on a temporary object while it is in the '%1' state"
H6C0DF8705FCA: "在 '%1' 狀態下對臨時物件調用 '%0' 方法無效"
# "invalid invocation of method '%0' on object '%1' while it is in the '%2' state"
HD38690B94C13: "在 '%2' 狀態下對物件 '%1' 調用 '%0' 方法無效"
# "invalid library name in argument '%0'"
H64F3D932433A: "參數 '%0' 中的無效函式庫名稱"
# "invalid line marker flag '2': cannot pop empty include stack"
H37DFD44E19FB: "無效的線標記旗標 '2'：無法彈出空的包含堆疊"
# "invalid linker name in argument '%0'"
HC2FCA31CF12C: "參數 '%0' 中的無效連結器名稱"
# 'invalid literal operator parameter type %0, did you mean %1?'
H0C90111229B8: '文字運算子的無效參數類型 %0，是否是指 %1？'
# "invalid lvalue in asm input for constraint '%0'"
H2CA59C9EF59C: "限制 '%0' 的組合語言輸入中的無效左值"
# 'invalid lvalue in asm output'
HED6C7D31AA01: '組合語言輸出中的無效左值'
# 'invalid matrix element type %0'
H9CDCD6DAE3BE: '無效的矩陣元素類型 %0'
# 'invalid newline character in raw string delimiter; use PREFIX( )PREFIX to delimit raw string'
HF6C358E90110: '原始字串分隔符中包含無效的換行字符；請使用PREFIX( )PREFIX來分隔原始字串'
# 'invalid number of arguments to function: %0'
H3D5EA8973A6F: '函數的參數數量無效：%0'
# "invalid offload arch combinations: '%0' and '%1' (for a specific processor, a feature should either exist in all offload archs, or not exist in any offload archs)"
H92F337A26551: "無效的卸載架構組合：'%0' 和 '%1'（針對特定處理器，某個功能應同時存在於所有卸載架構，或完全不存在於任何卸載架構）"
# 'invalid operand number in inline asm string'
H3DCCD1026997: '內聯組合語言字串中的操作數編號無效'
# 'invalid operand of type %0 where %1 or a vector of such type is required'
HD52C15C02D70: '類型 %0 的操作數無效，此處需要 %1 類型或該類型的向量'
# 'invalid operand of type %0 where floating, complex or a vector of such types is required'
HC1A341FFC462: '類型 %0 的操作數無效，此處需要浮點、複數或該類型的向量'
# 'invalid operand of type %0%select{| where a scalar or vector is required}1'
H848780E5A063: '類型 %0 的操作數無效 %select{|，此處需要純量或向量}1'
# 'invalid operands to binary expression (%0 and %1)'
HC5560B091967: '二元運算式中的操作數無效（%0 和 %1）'
# "invalid option '%0' for %select{cpu_specific|cpu_dispatch}1"
HEFAAB35E81AF: "%select{cpu_specific|cpu_dispatch}1 的選項 '%0' 無效"
# "invalid option '%0' not of the form <from-file>;<to-file>"
HCB5BB85712F1: "選項 '%0' 無效，非 <from-file>;<to-file> 格式"
# 'invalid option combination; LASX depends on LSX'
H7E946D645C29: '無效的選項組合；LASX依賴於LSX'
# "invalid or misplaced branch protection specification '%0'"
H9377B8FCDAC3: "無效或位置錯誤的分支保護規格 '%0'"
# "invalid or unsupported offload target: '%0'"
H4E7457AF1786: "無效或不受支援的卸載目標：'%0'"
# "invalid or unsupported rounding mode in '#pragma STDC FENV_ROUND' - ignored"
HDB0B7F11E503: "在 '#pragma STDC FENV_ROUND' 中指定的無效或不受支援的捨入模式 - 已忽略"
# "invalid output constraint '%0' in asm"
H686C32E03A9D: "組合語言中的輸出約束 '%0' 無效"
# "invalid output size for constraint '%0'"
HA9017C3CAD23: "限制 '%0' 的輸出大小無效"
# "invalid output type '%0' for use with gcc tool"
H1AE0ECD8B562: "與gcc工具一起使用時，輸出類型 '%0' 無效"
# "invalid parameter name: '%0' is a keyword"
HBA4C66D8A8AA: "無效的參數名稱：'%0' 是保留字"
# 'invalid parameter type for defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator; found %1, expected %2%select{| or %4}3'
H1333988BA8FC: '預設的 %select{<ERROR>|等同性|三向|等同性|關係}0比較運算子的參數類型無效；發現 %1，期望 %2%select{|或 %4}3'
# 'invalid parameter type for non-member defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator; found %1, expected class or reference to a constant class'
HEB967961C960: '非成員預設的 %select{<ERROR>|等同性|三向|等同性|關係}0比較運算子的參數類型無效；發現 %1，期望類別或對常量類別的引用'
# 'invalid pipe access modifier (expecting %0)'
HA4FFF117B821: '無效的管道存取修飾符（期望 %0）'
# 'invalid position specified for %select{field width|field precision}0'
H5DF564C1B18C: '指定的%select{字段寬度|字段精確度}0位置無效'
# "invalid preprocessing directive%select{|, did you mean '#%1'?}0"
H852ECDD7D2C3: '無效的預處理指令 %select{|，您是否想輸入 "#%1"？}0'
# 'invalid profile : %0'
H35AB0F2CB838: '無效的剖析： %0'
# 'invalid protocol qualifiers on non-ObjC type'
H3723A726B37F: '非ObjC類型上的協定修飾符無效'
# 'invalid prototype, variadic arguments are not allowed in OpenCL'
H5E1888FFA26E: '無效的原型，OpenCL中不允許使用可變參數'
# "invalid range expression of type %0; did you mean to dereference it with '*'?"
H1FCBEB4D2213: '類型 %0 的範圍運算式無效；是否想用 "*" 解引用它？'
# "invalid range expression of type %0; no viable '%select{begin|end}1' function available"
H76B630AFA57F: '類型 %0 的範圍運算式無效；沒有可用的 "%select{begin|end}1" 函數'
# "invalid range following '-' in expected %0"
H99FD9B7E0352: '在期望的 %0 後面的範圍無效'
# "invalid reduction operator,  expected '+', '*', 'max', 'min', '&', '|', '^', '&&', or '||'"
H3407BE2F5E5D: '無效的約簡運算子，期望 "+", "*", "max", "min", "&", "|", "^", "&&", 或 "||"'
# 'invalid reference to function %0: constraints not satisfied'
H9E6FAF3D6010: '對函數 %0 的引用無效：約束條件未滿足'
# 'invalid reinterpretation: sizes of %0 and %1 must match'
HC6E0606A101D: '無效的重新詮釋：%0 和 %1 的大小必須匹配'
# "invalid resource class specifier '%0' for packoffset, expected 'c'"
H2B96C40BB1F0: "packoffset的無效資源類別指定符 '%0'，期望為 'c'"
# 'invalid rounding argument'
HD77BD554C068: '無效的捨入參數'
# "invalid runtime library name in argument '%0'"
HCC4F20591ADF: "參數 '%0' 中的無效執行階段程式庫名稱"
# 'invalid size value'
H41C03C7DB477: '無效的大小值'
# "invalid space specifier '%0' used; expected 'space' followed by an integer, like space1"
HB8CFB0AAB2CD: "使用了無效的間隔指定符 '%0'；期望以 'space' 後跟整數，例如space1"
# 'invalid special register for builtin'
H26E533E2D360: '無效的內建特殊寄存器'
# 'invalid storage class specifier in function declarator'
HF2FD2E42B318: '函數宣告中的無效存儲類別指定符'
# "invalid string literal, ignoring final '\\'"
H550F921F116D: "無效的字串文字，忽略最後的 '\\'"
# "invalid suffix '%0' on %select{integer|floating|fixed-point}1 constant"
HFE61994BB7A3: "%select{integer|floating|fixed-point}1 常數的無效後綴 '%0'"
# 'invalid suffix on literal; C++11 requires a space between literal and identifier'
H3AC3DC712C63: '字面值的無效後綴；C++11要求字面值和識別符之間有空格'
# "invalid tag %0 on '%1' %select{directive|clause}2"
HB6EF4B837656: "在 '%1' 的%select{指令|子句}2上使用無效標籤 %0"
# "invalid target ID '%0'; format is a processor name followed by an optional colon-delimited list of features followed by an enable/disable sign (e.g., 'gfx908:sramecc+:xnack-')"
HF2F065F66FFD: "無效的目標ID '%0'；格式為處理器名稱後跟可選的以冒號分隔的功能清單，再後跟啟用/禁用符號（例如 'gfx908:sramecc+:xnack-'）"
# 'invalid target type %0 for dynamic_cast; target type must be a reference or pointer type to a defined class'
HFE4D2B7D8E06: 'dynamic_cast的無效目標類型 %0；目標類型必須是已定義類別的引用或指標類型'
# "invalid thread model '%0' in '%1' for this target"
HE75965380195: "此目標在 '%1' 中的無效執行緒模型 '%0'"
# "invalid thread pointer reading mode '%0'"
H602D0823E0FB: "無效的執行緒指標讀取模式 '%0'"
# 'invalid token at start of a preprocessor expression'
HAAFAB4DB043C: '預處理器表達式開頭處的無效記號'
# 'invalid token in macro parameter list'
HA6A8BDC08D89: '巨集參數列表中的無效記號'
# 'invalid transaction abort code'
H75E4D8742736: '無效的交易中斷代碼'
# 'invalid type %0 as argument of iboutletcollection attribute'
HE41F37E3851B: '在iboutletcollection屬性的引數中，類型 %0 無效'
# 'invalid type %0 in asm %select{input|output}1'
H2A71CC82E6A7: '在asm的%select{輸入|輸出}1中包含無效類型 %0'
# "invalid type %0 in asm input for constraint '%1'"
H1E6A37C4D619: "在asm輸入中類型 %0 不符合約束 '%1'"
# 'invalid type %0 is a %select{member|base}1 of %2'
HB6D9D0DC110A: '無效的類型 %0 是 %2 的%select{成員|基底}1'
# 'invalid type %0 to %1 operator'
H4C8C1A65C2A4: '無效的類型 %0 轉換為 %1 運算子'
# 'invalid universal character'
H73C6676CA247: '無效的通用字元'
# "invalid unwind library name in argument '%0'"
HD675186A50F6: "在引數 '%0' 中包含無效的unwind函式庫名稱"
# "invalid use of '__funcref' keyword outside the WebAssembly triple"
H5B018C340841: '在非WebAssembly三元組中使用__funcref關鍵字無效'
# "invalid use of '__super', %0 has no base classes"
HC8BFC8F3D816: '使用__super無效，%0 沒有基類'
# "invalid use of '__super', this keyword can only be used inside class or member function scope"
H02BB07D5882C: '使用__super無效，此關鍵字只能在類別或成員函數作用域內使用'
# "invalid use of 'this' %select{outside of a non-static member function|in a function with an explicit object parameter}0"
H9633100217CB: '在%select{非靜態成員函數以外|具有顯式物件參數的函數中}0使用this無效'
# 'invalid use of PPC MMA type'
H23BD562DB2DF: '使用PPC MMA類型無效'
# 'invalid use of a cast in an inline asm context requiring an lvalue'
H5D073F64410B: '在需要左值的-inline asm上下文中使用轉型無效'
# 'invalid use of incomplete type %0'
H7FE8554F5009: '使用不完整類型 %0 無效'
# 'invalid use of member %0 in %select{static|explicit object}1 member function'
H50EBCD910232: '在%select{靜態|顯式物件}1成員函數中使用成員 %0 無效'
# 'invalid use of non-static data member %0'
H59D616D352F1: '使用非靜態資料成員 %0 無效'
# 'invalid use of pointer to member type after %select{.*|->*}0'
H48A2AD1643D5: '在 %select{.*|->*}0 之後使用成員類型指標無效'
# 'invalid validator version : %0; format of validator version is "<major>.<minor>" (ex:"1.4")'
H4B1AA82F67A0: '無效的驗證器版本：%0；驗證器版本格式為"<主要>.<次要>"（例如："1.4"）'
# 'invalid validator version : %0; if validator major version is 0, minor version must also be 0'
HD365448B0579: '無效的驗證器版本：%0；如果驗證器的主要版本為 0，次要版本也必須為 0'
# 'invalid validator version : %0; validator version must be less than or equal to current internal version'
HED613B352B91: '無效的驗證器版本：%0；驗證器版本必須小於或等於當前內部版本'
# "invalid value '%1' in '%0'"
H7E000E39503F: "無效值 '%1' 在 '%0'"
# "invalid value '%1' in '%0', expected one of: %2"
H22924648CBBA: "無效值 '%1' 在 '%0'，期望以下其中一個： %2"
# "invalid value '%1' in '%0', value must be '%2' or greater"
H38383851595E: "無效值 '%1' 在 '%0'，值必須為 '%2' 或更大"
# "invalid value '%1' in '%0', value must be 'none' or a positive integer"
H9E8659EA6C7E: "無效值 '%1' 在 '%0'，值必須為 'none' 或正整數"
# "invalid value '%1' in '%0'; alignment must be a power of 2"
H2DA82E98A2A4: "無效值 '%1' 在 '%0'；對齊必須是 2 的冪"
# "invalid value for 'default' clause; expected 'present' or 'none'"
H8D0169FE239F: "'default' 子句的無效值；期望 'present' 或 'none'"
# 'invalid vector element type %0'
HEFB9A08F90A0: '無效的向量元素類型 %0'
# "invalid version number in '%0'"
H561E007CCA86: "在 '%0' 中發現無效的版本號"
# "invalid virtual filesystem overlay file '%0'"
HBFF79FC3240A: "無效的虛擬文件系統覆蓋檔 '%0'"
# "invoking a pointer to a 'const &' member function on an rvalue is a C++20 extension"
HDCED919CDE9E: "在右值上调用指向 'const &' 成員函數的指標是 C++20 的擴展"
# "invoking a pointer to a 'const &' member function on an rvalue is incompatible with C++ standards before C++20"
H06659E61779A: "在右值上调用指向 'const &' 成員函數的指標與 C++20 之前標準不相容"
# "isa trait '%0' is not known to the current target; verify the spelling or consider restricting the context selector with the 'arch' selector further"
H0ED9A7F36C30: "isa 特性 '%0' 未被當前目標所知；請確認拼寫或考慮使用 'arch' 選項進一步限制上下文選擇器"
# "it could also be property %select{of type %1|without attribute '%1'|with attribute '%1'|with getter %1|with setter %1}0 declared here"
H91A939A34A63: '它可能是此屬性的支援變數 %select{類型 %1|無屬性 "%1"|有屬性 "%1"|有存取器 %1|有設定器 %1}0 在此處宣告'
# 'it delegates to'
H01E41C702CFA: '它轉發給'
# 'it is possible to stop the benchmarking process after some phase'
H3F4A63E67588: '您可以在某個 pass 階段後停止測試程序'
# 'iterator step expression %0 evaluates to 0'
H68A0F13C3B50: '迭代器步進運算式 %0 評估為 0'
# 'iterator step expression %0 is not the integral expression'
H5E0FE51F5C8D: '迭代器步進運算式 %0 非整數運算式'
# "ivar %0 which backs the property is not referenced in this property's accessor"
HB68211D86C75: '支援此屬性的成員變數 %0 未在該屬性的存取器中被引用'
# "joined argument expects additional value: '%0'"
H67B5A91D2948: "joined 參數期望額外值：'%0'"
# "joined argument treated as '%0'; did you mean '%1'?"
HAC9E756384DA: "結合的參數被視為 '%0'；您是指 '%1' 吗？"
# 'jump bypasses OpenMP structured block'
H38D141B68E15: '跳躍繞過了OpenMP結構化區塊'
# 'jump bypasses auto release push of @autoreleasepool block'
H673B2CE5E964: '跳躍繞過了@autoreleasepool區塊的自動釋放推入'
# 'jump bypasses initialization of @catch block'
HBE63405914D4: '跳躍繞過了@catch區塊的初始化'
# 'jump bypasses initialization of @finally block'
HC258EB27DC7D: '跳躍繞過了@finally區塊的初始化'
# 'jump bypasses initialization of @synchronized block'
HB49518EF658F: '跳躍繞過了@synchronized區塊的初始化'
# 'jump bypasses initialization of @try block'
H4F2203657B83: '跳躍繞過了@try區塊的初始化'
# 'jump bypasses initialization of VLA type alias'
H06AE800C9022: '跳躍繞過了VLA類型別名的初始化'
# 'jump bypasses initialization of VLA typedef'
H539D32051794: '跳轉跳過VLA typedef的初始化'
# 'jump bypasses initialization of __except block'
H8945BA31631C: '跳躍繞過了__except區塊的初始化'
# 'jump bypasses initialization of __finally block'
HDC8606BFB8A0: '跳躍繞過了__finally區塊的初始化'
# 'jump bypasses initialization of __strong variable'
H4091D3DFA80B: '跳躍繞過了__strong變數的初始化'
# 'jump bypasses initialization of __try block'
H17A1FDC40633: '跳躍繞過了__try區塊的初始化'
# 'jump bypasses initialization of __weak variable'
H2D2E5414450F: '跳躍繞過了__weak變數的初始化'
# 'jump bypasses initialization of catch block'
H1AD4DA299533: '跳躍繞過了catch區塊的初始化'
# 'jump bypasses initialization of non-POD variable'
H7894E3C8480C: '跳躍繞過了非POD變數的初始化'
# 'jump bypasses initialization of try block'
H35C99F3D2CF6: '跳躍繞過了try區塊的初始化'
# 'jump bypasses initialization of variable length array'
HD2CC21B5B2B9: '跳躍繞過了可變長度陣列變數的初始化'
# 'jump bypasses initialization of variable of non-trivial C struct type'
H8DC117DB27D9: '跳躍繞過了非平凡C結構類型變數的初始化'
# 'jump bypasses initialization of variable with __attribute__((cleanup))'
H816408F197AB: '跳躍繞過了具有__attribute__((cleanup))屬性的變數的初始化'
# 'jump bypasses setup of __block variable'
H8FF055D54D20: '跳躍跳過區塊變數的設定'
# 'jump bypasses variable initialization'
HDE484302CFDD: '跳躍跳過變數初始化'
# 'jump bypasses variable with a non-trivial destructor'
H65EAD2757089: '跳躍跳過具有複雜析構函數的變數'
# 'jump enters Objective-C fast enumeration loop'
H0B68A5227D3D: '跳躍進入 Objective-C 快速枚舉迴圈'
# 'jump enters a statement expression'
HAF0C1FFF2BB0: '跳躍進入語句表達式'
# 'jump enters controlled statement of consteval if'
H9FCC3E0998D5: '跳躍進入 consteval if 的控制語句'
# 'jump enters controlled statement of constexpr if'
H53B0DD3B4BCF: '跳躍進入 constexpr if 的控制語句'
# 'jump enters controlled statement of if available'
H0D6B49E1C06A: '跳躍進入 if available 的控制語句'
# 'jump enters lifetime of a compound literal that is non-trivial to destruct'
H84D2F4FDA1F2: '跳躍進入析構複雜的複合文字的生命周期'
# 'jump enters lifetime of block which captures a C struct that is non-trivial to destroy'
HB60961C86BE4: '跳躍進入捕獲銷毀複雜 C 結構體的區塊的生命周期'
# 'jump enters lifetime of block which captures a destructible C++ object'
HFA59EFDF1B62: '跳躍進入捕獲可銷毀 C++ 物件的區塊的生命周期'
# 'jump enters lifetime of block which strongly captures a variable'
H2E28FE1D13B9: '跳躍進入強捕獲變數的區塊的生命周期'
# 'jump enters lifetime of block which weakly captures a variable'
H8ED7B1ED0204: '跳躍進入弱捕獲變數的區塊的生命周期'
# 'jump exits @catch block'
H00823EBB1453: '跳躍離開 @catch 區塊'
# 'jump exits @finally block'
HDE9FECD28D12: '跳躍離開 @finally 區塊'
# 'jump exits @synchronized block'
H2C2C500585D3: '跳躍離開 @synchronized 區塊'
# 'jump exits @try block'
H60631B3B104F: '跳躍離開 @try 區塊'
# 'jump exits __except block'
HF0ECDC1D667A: '跳躍離開 __except 區塊'
# 'jump exits __finally block'
HEF15A26AC2B4: '跳躍離開 __finally 區塊'
# 'jump exits __try block'
HA371EC6EABEF: '跳轉退出__try區塊'
# 'jump exits autoreleasepool block'
HFA1102E13121: '跳轉退出autoreleasepool區塊'
# 'jump exits catch block'
HB15A540E97C0: '跳轉退出catch區塊'
# 'jump exits lifetime of a compound literal that is non-trivial to destruct'
H581CCAF33BA1: '跳轉退出無法輕易析構的複合文字的生存期'
# 'jump exits lifetime of block which captures a C struct that is non-trivial to destroy'
H145F09CDB728: '跳轉退出捕獲無法輕易銷毀C結構的區塊的生存期'
# 'jump exits lifetime of block which captures a destructible C++ object'
HFD90BDF2A71A: '跳轉退出捕獲可銷毀C++物件的區塊的生存期'
# 'jump exits lifetime of block which strongly captures a variable'
H633C0158D8CE: '跳轉退出強引用變數的區塊的生存期'
# 'jump exits lifetime of block which weakly captures a variable'
H3C3B445ACF96: '跳轉退出弱引用變數的區塊的生存期'
# 'jump exits scope of OpenMP structured block'
H3960249ABF56: '跳轉退出OpenMP結構化區塊的作用域'
# 'jump exits scope of __block variable'
HCAFFF794B0B7: '跳轉退出__block變數的作用域'
# 'jump exits scope of __strong variable'
H09130C2189DF: '跳轉退出__strong變數的作用域'
# 'jump exits scope of __weak variable'
H425A195D6F14: '跳轉退出__weak變數的作用域'
# 'jump exits scope of lifetime-extended temporary with non-trivial destructor'
H18BAD42D7AAF: '跳轉退出具有非平凡析構函數的延長生存期臨時物件的作用域'
# 'jump exits scope of variable with __attribute__((cleanup))'
H4BF0CCE50F51: '跳轉退出帶有__attribute__((cleanup))屬性的變數的作用域'
# 'jump exits scope of variable with non-trivial destructor'
HD66C6E5AB564: '跳轉退出具有非平凡析構函數的變數的作用域'
# 'jump exits try block'
HE15267C61E24: '跳轉退出try區塊'
# 'jump from switch statement to this case label is incompatible with C++98'
HFD45DFD4341B: '此switch語句跳轉到此case標籤與C++98標準不相容'
# 'jump from this %select{indirect|asm}0 goto statement to one of its possible targets is incompatible with C++98'
H6B5196F09490: '此%select{間接|asm}0 goto語句跳轉到其可能目標之一與C++98標準不相容'
# 'jump from this goto statement to its label is a Microsoft extension'
HF443D2C187C8: '此goto語句跳轉到其標籤是Microsoft擴充'
# 'jump from this goto statement to its label is incompatible with C++98'
H91A60091F523: '此 goto 陳述式到其標籤的跳轉與 C++98 不兼容'
# 'jump out of __finally block has undefined behavior'
HC63318A29EFB: '從 __finally 區塊跳出具有未定義行為'
# 'jump tables support (default=basic)'
H004CDF2FB54A: '跳轉表支援（預設值=basic）'
# 'just the yaml representation of the profile'
H77CB9F525531: '僅顯示剖析的 yaml 表示形式'
# 'keep going after reporting a UMR'
H5D280A550689: '在報告 UMR 後繼續執行'
# 'keep no-op instructions. By default they are removed.'
H5294B5B42559: '保留無操作指令。預設會移除這些指令。'
# 'keep or generate .debug_aranges section if .gdb_index is written'
HF46D8AA36DF8: '如果寫入了 .gdb_index 時，控制是否保留或生成 .debug_aranges 區段'
# 'kernel call to non-global function %0'
HE2C1F06E4669: '內核呼叫非全域函數 %0'
# 'kernel function %0 is a member function; this may not be accepted by nvcc'
H6C2BA696CEAF: '內核函數 %0 是成員函數；這可能無法被 nvcc 接受'
# 'kernel function %0 must be a free function or static member function'
H16FEF3B5D436: '內核函數 %0 必須是自由函數或靜態成員函數'
# 'kernel function type %0 must have void return type'
H95AC5DFCBCA0: '內核函數類型 %0 必須具有 void 返回類型'
# 'kernel functions cannot be class members'
H49F7A4460E40: '內核函數不可為類別成員'
# 'kernel functions cannot be declared static'
H4969597F9236: '內核函數不可宣告為 static'
# 'kernel functions cannot be used in a template declaration, instantiation or specialization'
HD5AD84DAA9C6: '內核函數不可用於範本宣告、實例化或特化'
# 'kernel must have void return type'
H2245CF70F0F9: '內核必須具有 void 返回類型'
# 'kernel parameter cannot be declared as a pointer to a pointer'
HA03E5339986E: '內核參數不可宣告為指標至指標'
# "keyword '%0' will be made available as an identifier %select{here|for the remainder of the translation unit}1"
HB2136B9BC89D: "關鍵字 '%0' 將被視為識別符 %select{這裡|在本翻譯單位的剩餘部分}1"
# 'keyword is hidden by macro definition'
HB53596605CAF: '關鍵字被宏定義隱藏'
# 'kind mapping string to set kind precision'
HE046AE1AA112: '設定類型精確度的類型對應字串'
# "known but unsupported action '%1' for '#pragma %0' - ignored"
H07B6796F45BE: "已知但不受支援的 '#pragma %0' 動作 '%1' - 已忽略"
# "label '%0' is reserved: use a different label name for -X<label>"
H0A75EFF64B4C: "標籤 '%0' 已被保留：使用不同的標籤名稱供 -X<label> 使用"
# 'label at end of compound statement is a C++23 extension'
H696C9202732B: '複合語句末尾的標籤是C++23擴展'
# 'label at end of compound statement is a C23 extension'
H24E471EE8FE1: '複合語句末尾的標籤是C23擴展'
# 'label at end of compound statement is incompatible with C standards before C23'
H8E280A51EBD5: '複合語句末尾的標籤與C23之前的标准不兼容'
# 'label at end of compound statement is incompatible with C++ standards before C++23'
H1F208E16CB25: '複合語句末尾的標籤與C++23之前的标准不兼容'
# 'label followed by a declaration is a C23 extension'
HE476C0C2BE2F: '標籤後跟宣告是C23擴展'
# 'label followed by a declaration is incompatible with C standards before C23'
H8299673D895A: '標籤後跟宣告與C23之前的标准不兼容'
# 'lambda %0 is inaccessible due to ambiguity:%1'
H165915C96E61: 'lambda %0 因歧義而無法存取：%1'
# 'lambda call operator should not be explicitly specialized or instantiated'
H3541695AB458: 'lambda調用運算子不應明確特化或實例化'
# 'lambda cannot be both mutable and static'
H057D935E257D: 'lambda無法同時為mutable和static'
# 'lambda cannot be declared %0'
H523BA4919111: 'lambda不能被宣告為 %0'
# 'lambda capture %0 is not %select{used|required to be captured for this use}1'
HED12D4324492: 'lambda捕獲 %0 %select{未被使用|需要被捕獲才能用於此處}1'
# 'lambda closure types are non-literal types before C++17'
H3BDD817E383F: 'lambda閉包類型在C++17之前是非文字類型'
# 'lambda expression begins here'
H0582B6A6C9FD: 'lambda運算式始於此處'
# 'lambda expression in an unevaluated operand'
H2B5A38CCEDAB: 'lambda運算式在未計算的運算元中'
# 'lambda expression in default argument cannot capture any entity'
H31423DFF8FC2: 'lambda運算式與C++98不相容'
# 'lambda expressions are incompatible with C++98'
HAE0AFEA72154: 'lambda的範本參數清單不能為空'
# 'lambda template parameter list cannot be empty'
H33C909CD1D80: '無參數項的lambda是C++23擴展'
# 'lambda without a parameter clause is a C++23 extension'
HD70498A5F3EC: 'lambda表達式未指定參數子句是C++23的擴充功能'
# 'lambdas are a %select{C++11|clang HLSL}0 extension'
HD58884723190: 'lambda表達式是 %select{C++11|clang HLSL}0 的擴充功能'
# "language not recognized: '%0'"
H102C1DB9CB0E: "未識別的語言：'%0'"
# 'large atomic operation may incur significant performance penalty; the access size (%0 bytes) exceeds the max lock-free size (%1 bytes)'
H31655F77BD73: '大原子操作可能導致顯著的效能損失；存取大小（%0 字節）超過最大無鎖大小（%1 字節）'
# 'layout blocks in reverse order'
H19EE0FFEC518: '布局區塊按反向順序排列'
# 'lcov tracefile output'
HCE669C9CA888: 'lcov 追蹤檔輸出'
# 'left hand operand of type %0 to compound assignment cannot be truncated when used with right hand operand of type %1'
H00D9FE7F4F87: '左操作元的類型 %0 在複合指派時，與右操作元的類型 %1 混合時不能被截斷'
# 'left hand operand to %0 must be a %select{|pointer to }1class compatible with the right hand operand, but is %2'
HE8A81161D486: '%0 的左操作元必須與右操作元兼容的 %select{|指標到 }1類別，但實際是 %2'
# "left hand side of assignment operation('%0') must match one side of the sub-operation on the right hand side('%1' and '%2')"
HA99FEEFA45D5: "指派運算的左邊（'%0'）必須與右邊的子運算（'%1' 和 '%2'）其中一邊的類型一致"
# 'left operand of comma operator has no effect'
H1D36CC5E4D5A: '逗號運算子的左操作元無效'
# 'left shift of negative value %0'
HF788BD55C118: '對負值 %0 進行左移位操作'
# "length modifier '%0' results in undefined behavior or no effect with '%1' conversion specifier"
HDCB24BE7C9E8: "長度修飾符 '%0' 與 '%1' 轉換說明符一起使用時會導致未定義行為或無效"
# 'libclc builtin preparation tool\n'
H8679FDE4DA62: 'libclc內建準備工具\n'
# 'limit number of targets to consider when doing indirect call promotion on calls. 0 = no limit'
HD2EF861DC5DB: '限制間接呼叫提升在呼叫時考慮的目標數量。0 = 無限制'
# 'limit number of targets to consider when doing indirect call promotion on jump tables. 0 = no limit'
H039F79707FDF: '限制間接呼叫提升在跳轉表時考慮的目標數量。0 = 無限制'
# 'limit number of targets to consider when doing indirect call promotion. 0 = no limit'
H5880E8C77FBD: '限制間接呼叫提升時考慮的目標數量。0 = 無限制'
# 'limit optimizations to functions from the list'
HF1AAD3BC1D5B: '將優化限制在清單中的函數'
# 'limit optimizations to functions from the list (non-regex)'
H4820DAC9F83B: '將優化限制在清單中的函數（非正規表示式）'
# 'line marker directive requires a positive integer argument'
H8A0833C758AF: '行標記指令需要一個正整數參數'
# 'line splicing in Doxygen comments are not supported'
HD6510289D84D: 'Doxygen註解中的行拼接不被支援'
# "linking module '%0': %1"
H78786E2D2737: "連結模組 '%0': %1"
# 'linking options'
H1E4F081C74A1: '連結選項'
# 'list item of type %0 is not valid for specified reduction operation: unable to provide default initialization value'
H5FEA755CA374: '類型為 %0 的清單項目不適用於指定的約簡運算：無法提供預設初始值'
# 'list of functions to always consider for inlining'
H00FB00D60661: '要始終考慮內聯的函數清單'
# 'list of functions to apply frame opts'
H723CBEBF937F: '要套用框架最佳化的函數清單'
# 'list of functions to core dump on (debugging)'
HFF95EE476741: '要核心轉存的函數清單（調試用）'
# 'list of functions to enable ICP for'
H4EBB92971A75: '要啟用ICP的函數清單'
# 'list of functions to never consider for inlining'
HE127B8F1CD43: '要永遠排除在內聯考量外的函數清單'
# 'list of functions to pad with amount of bytes'
H296C1F5DDCF1: '要以指定位元元組數填充的函數清單'
# 'list of functions to print'
H1C3AE7A6EC95: '要印出的函數清單'
# 'list of functions to skip'
HED4CB34A956C: '要跳過的函數清單'
# 'list of functions with call sites for which to specialize memcpy() for size 1'
HD7F5B54EFF49: '要針對大小 1 進行memcpy()特殊化的呼叫位址所屬函數清單'
# "list of sections containing functions used for hugifying hot text. BOLT makes sure these functions are not placed on the same page as the hot text. (default='.stub,.mover')."
H07A4ADB5443D: '包含用於hugifying熱文本的函數的區段清單。BOLT確保這些函數不會與熱文本放在同一頁面上。（預設值為 ".stub,.mover"）'
# 'list of sections to reorder'
HE8B5B16B7FA7: '要重新排序的區段清單'
# 'list of symbol names that can be reordered'
H6F9EE9EC82ED: '可重新排序的符號名稱清單'
# 'list of symbol names that cannot be reordered'
H9016DB56BAB4: '不可重新排序的符號名稱清單'
# 'literal construction method %0 has incompatible signature'
H9A98E6827407: '字面建構方法 %0 的簽名不相容'
# 'literal operator %0 must be in a namespace or global scope'
H6F0C93D8CF92: '字面運算子 %0 必須位於命名空間或全域作用域中'
# 'literal operator cannot have a default argument'
H2D253A373F0C: '字面運算子不能有預設引數'
# 'literal operator must have C++ linkage'
HACF64718BD51: '字面運算子必須具有C++連結性'
# 'literal operator template cannot have any parameters'
HDB57FAFF64D9: '字面運算子模板不能有任何參數'
# 'literal operators are incompatible with C++98'
HC63AE1FBA425: '字面運算子與C++98不相容'
# 'lldb'
H23F2598B46BF: 'lldb'
# 'llvm .bc -> .bc modular optimizer and analysis printer\n'
H5E0E5487AF50: 'llvm .bc -> .bc 模組優化器及分析列印工具\n'
# 'llvm .bc -> .ll disassembler\n'
H6C7F6E9C06C4: 'llvm .bc -> .ll 反組譯器\n'
# 'llvm .ll -> .bc assembler\n'
HD4712D9BC53E: 'llvm .ll -> .bc 組譯器\n'
# 'llvm LTO linker\n'
H2892DC655E08: 'llvm 連結時優化連結器'
# 'llvm MC-JIT tool\n'
H06636F581609: 'llvm MC-JIT 工具'
# 'llvm SPGO profile generator\n'
H701BD947180F: 'llvm SPGO 剖析產生器'
# 'llvm codegen stress-tester\n'
HA26868605BE5: 'llvm 程式碼生成壓力測試工具'
# 'llvm extractor\n'
HFF048809A3CA: 'llvm 程式碼提取工具'
# 'llvm host machine instruction characteristics measurment and analysis.\n'
HF3F3BF01E352: 'llvm 主機機器指令特性測量與分析。\n'
# 'llvm interpreter & dynamic compiler\n'
H0649CD7E70C5: 'llvm 解譯器與動態編譯器'
# 'llvm jit event listener test utility\n'
HC7AAB55CF667: 'llvm jit 事件監聽器測試工具\n'
# 'llvm jitlink tool'
H2709B44451E8: 'LLVM jitlink 工具'
# 'llvm linker\n'
HC9DC12DE7069: 'llvm 連結器'
# 'llvm machine code performance analyzer.\n'
H684FDD543DA3: 'llvm 機器碼效能分析工具。\n'
# 'llvm machine code playground\n'
H2F51084FBDF0: 'llvm 機器碼實驗場'
# 'llvm system compiler\n'
H8181CA7521BB: 'llvm 系統編譯器'
# 'llvm tool to verify use-list order\n'
HAC60F05F36A9: 'llvm 用以驗證使用清單順序的工具'
# 'llvm-as Options'
HCEBF82BEB0E9: 'llvm-as 選項'
# 'llvm-bcanalyzer file analyzer\n'
HECC62C366128: 'llvm-bcanalyzer 檔案分析器\n'
# 'llvm-boltdiff - BOLT binary diff tool\n\nEXAMPLE: llvm-boltdiff -data=a.fdata -data2=b.fdata exec1 exec2\n'
HB49452FEF405: 'llvm-boltdiff - BOLT 二進制差異工具\n\n範例：llvm-boltdiff -data=a.fdata -data2=b.fdata exec1 exec2\n'
# 'llvm-cat Options'
H3A2E2CA997D5: 'llvm-cat 選項'
# 'llvm-exegesis analysis options'
H89DF2607CBEA: 'llvm-exegesis 分析選項'
# 'llvm-exegesis benchmark options'
HC43701CE0D82: 'llvm-exegesis 基準測試選項'
# 'llvm-exegesis options'
HAF6D3F27C196: 'llvm-exegesis 選項'
# 'llvm-extract Options'
H25F0C853A66B: 'llvm-extract 選項'
# 'llvm-omp-kernel-replay Options'
H90111C7D3334: 'llvm-omp-kernel-replay 選項'
# 'llvm-opt-report options'
HCF4237251086: 'llvm-opt-report 選項'
# 'llvm-reduce options'
H9B15C3D059EC: 'llvm-reduce 選項'
# 'load the input file as a Toy source.'
H8076D5B81C5F: '將輸入檔載入為 Toy 來源。'
# 'load the input file as an MLIR file'
HAC00602D295B: '將輸入檔載入為 MLIR 檔'
# 'loader options'
HA2203CDD473C: '載入器選項'
# 'local %select{struct|interface|union|class|enum}0 cannot be declared __module_private__'
H4E0562614A60: '在本地 %select{struct|interface|union|class|enum}0 不可以宣告為 __module_private__'
# 'local declaration nearly matches'
HA030BEFE649C: '本地宣告與 nearly matches'
# 'local declaration of %0 hides instance variable'
H09900D49A0E3: '%0 的本地宣告遮蔽了實例變數'
# 'local type %0 as template argument is incompatible with C++98'
H6116FD3EFF04: '在 C++98 中，將本地類型 %0 作為模板參數是不相容的。'
# "local variable '%0' should not be used in 'declare target' directive;"
HF2D2B034481C: "在 'declare target' 指令中不应使用本地變數 '%0'；"
# "local variable cannot be declared 'constinit'"
HE35DCF249418: "本地變數不能被聲明為 'constinit'"
# "locking '%0' to build module '%1'"
H36ABFAB03219: "將 '%0' 鎖定以建立模組 '%1'"
# 'logical expression with vector %select{type %1 and non-vector type %2|types %1 and %2}0 is only supported in C++'
H1200F428FBB0: '帶有向量%select{類型 %1 和非向量類型 %2|類型 %1 和 %2}0 的邏輯運算式僅在C++中受支援'
# 'logical not is only applied to the left hand side of this %select{comparison|bitwise operator}0'
H9E8ECD267F25: '邏輯非僅應用於此%select{比較運算子|位元運算子}0的左邊操作數'
# 'lookup from the current scope refers here'
H9AFA3EAEA36F: '從當前作用域的查找指向此處'
# 'lookup in the object type %0 refers here'
H3FD57FB46E2B: '在物件類型 %0 的查找指向此處'
# 'lookup of %0 in member access expression is ambiguous'
H52F57D0BB44E: '在成員存取運算式中查找 %0 存在歧義'
# 'lookup of %0 in member access expression is ambiguous; using member of %1'
H632E112FD2AD: '在成員存取運算式中查找 %0 存在歧義；使用 %1 的成員'
# "loop iteration variable in the associated loop of 'omp %1' directive may not be %0, predetermined as %2"
H777624FA6F75: "與 'omp %1' 指令相關的循環迭代變數不能是 %0，其已被預先確定為 %2"
# 'loop step is expected to be %select{negative|positive}0 due to this condition'
HF9B9B19EF744: '期望因這個條件，迴圈步長為%select{負數|正數}0'
# 'loop to be fully unrolled must have a constant trip count'
HF58CAD452050: '要完全展開的循環必須具有常數次數'
# 'loop variable %0 %diff{of type $ binds to a temporary constructed from type $|binds to a temporary constructed from a different type}1,2'
H8E540E772339: '%0 迴圈變數 %diff{類型為$的變數與從類型$建立的臨時物件綁定|與不同類型的臨時物件綁定}1,2'
# 'loop variable %0 binds to a temporary value produced by a range of type %1'
HDD2F7E9780FE: '循環變數 %0 綁定到由類型 %1 的範圍產生的臨時值'
# 'loop variable %0 creates a copy from type %1'
H0EB738A6DA64: '循環變數 %0 從類型 %1 創建副本'
# "loop variable %0 may not be declared %select{'extern'|'static'|'__private_extern__'|'auto'|'register'|'constexpr'|'thread_local'}1"
HD1C2B82FE9FA: "循環變數 %0 不能被聲明為 %select{'extern'|'static'|'__private_extern__'|'auto'|'register'|'constexpr'|'thread_local'}1"
# "loop variable of loop associated with an OpenACC '%0' construct must be of integer, pointer, or random-access-iterator type (is %1)"
HDE685F11E1FA: "與OpenACC '%0' 結構相關的循環變數必須是整數、指標或隨機存取迭代器類型（目前為 %1）"
# 'loop will run at most once (loop increment never executed)'
H41A7771F3080: '此循環最多執行一次（循環增量從未執行）'
# "loop with a '%0' clause may not exist in the region of a '%1' clause%select{| on a '%3' construct}2"
H31D69B81DD7A: "在 '%1' 子句的區域 %select{|在 '%3' 結構上}2中，可能不存在具有 '%0' 子句的迴圈"
# 'lower transpose without using a runtime call'
H1DC7FFF629C0: '不使用執行階段調用進行轉置'
# 'mac68k alignment pragma is not supported on this target'
H13A22B895D9E: '此目標不支援mac68k對齊pragma'
# 'macro %0 defined here'
H224BD0DEAAD4: '在此處定義的宏 %0'
# 'macro %0 has been marked as deprecated%select{|: %2}1'
HB9E9BBB38434: '宏 %0 已被標記為已棄用 %select{|： %2}1'
# 'macro %0 has been marked as final and should not be %select{undefined|redefined}1'
H416ADCAF4BDC: '宏 %0 已被標記為最終且不得%select{未定義|重新定義}1'
# 'macro %0 has been marked as unsafe for use in headers%select{|: %2}1'
H0BD2BA6647E5: '此宏 %0 不應在標頭中使用 %select{|： %2}1'
# "macro '%0' contains embedded newline; text after the newline is ignored"
HCA29C3134207: "宏 '%0' 包含嵌入式換行符；換行符後的文本將被忽略"
# "macro '%0' was %select{defined|undef'd}1 in the AST file '%2' but %select{undef'd|defined}1 on the command line"
HEF8B87D78B88: "AST 檔案 '%2' 中的宏 '%0' 被%select{定義|#undef'd}0，但命令列中 %select{#undef'd|定義}0"
# "macro expansion producing 'defined' has undefined behavior"
H6CE80CBEAD13: "產生 'defined' 的宏展開具有未定義行為"
# 'macro is not used'
HB7A93ECCBE4F: '此宏未被使用'
# "macro marked '%select{deprecated|restrict_expansion|final}0' here"
H36EC3D2C5C8F: '在此處標記宏%select{已棄用|限制擴展|最終}0'
# 'macro name is a reserved identifier'
H75F2505E76F7: '宏名稱為保留識別符'
# 'macro name missing'
H64036DCA4179: '缺少宏名稱'
# 'macro name must be an identifier'
HA83E076252EC: '宏名稱必須是識別符'
# "macro was %select{defined|#undef'd}0 here"
H90411BE5521B: "此處宏%select{被定義|#undef'd}0"
# 'magnitude of floating-point constant too large for type %0; maximum is %1'
HC45BAE211EEF: '%0 類型的浮點常數數值過大；最大值為 %1'
# 'magnitude of floating-point constant too small for type %0; minimum is %1'
H77948F2AADFE: '浮點常數的數值範圍小於類型 %0 的最小值；最小值為 %1'
# 'main cannot be declared as a variable %select{in the global scope|with C language linkage}0'
HDFAAFDDA66C4: 'main 不能在全域作用域中或具有C語言綁定的情況下宣告為變數 %select{在全域作用域中|具有C語言綁定}0'
# 'main file cannot be included recursively when building a preamble'
HFA8D0D05FC55: '建立前置宣告時，主檔案不能遞歸包含'
# 'make jump tables size smaller at the cost of using more instructions at jump sites'
HFB74BDFA805D: '減少跳轉表大小，但會增加跳轉位置的指令數量'
# 'make the interpreter print every volatile load and store'
H89B411120801: '讓解譯器列印所有 volatile 讀取和寫入'
# "malformed block record in PCH file: '%0'"
H89FF1C99B4CC: "PCH 檔案中的區塊記錄格式錯誤：'%0'"
# "malformed or corrupted AST file: '%0'"
HCB00083D669D: "AST 檔案格式錯誤或已損壞：'%0'"
# "malformed sanitizer coverage allowlist: '%0'"
HA08307F61916: "格式錯誤的 sanitizer 覆蓋允許清單：'%0'"
# "malformed sanitizer coverage ignorelist: '%0'"
HF4CE0A42147C: "格式錯誤的 sanitizer 覆蓋忽略清單：'%0'"
# "malformed sanitizer ignorelist: '%0'"
H98473149CB24: "格式錯誤的 sanitizer 忽略清單：'%0'"
# "malformed sanitizer metadata ignorelist: '%0'"
H7E49790904E8: "格式錯誤的 sanitizer 元資料忽略清單：'%0'"
# 'mangled name of %0 will change in C++17 due to non-throwing exception specification in function signature'
HC8027193700F: '%0 的編譯器生成名稱在 C++17 中將因函式簽名中的不拋出例外規格而改變'
# "map type '%0' is previous specified here"
H3204C79CA043: "map 類型 '%0' 已在此處指定過"
# 'map type is already specified'
HF4D36EA9229E: 'map 類型已指定過'
# "map type modifier '%0' is not allowed for '#pragma omp %1'"
H5A1E07271479: "'%0' 是 #pragma omp %1 不允許的 map 類型修飾符"
# 'mapper type must be of struct, union or class type'
H3D3958379C94: 'mapper 類型必須為結構、共用體或類別類型'
# 'mapping of union members is not allowed'
HD27CBEC61BC1: '共用體成員的對應是不被允許的'
# "mark %0 as '%select{final|sealed}1' to silence this warning"
HF7273FC85EE1: "將 %0 標記為 '%select{final|sealed}1' 以抑制此警告"
# "mark 'operator==' as const or add a matching 'operator!=' to resolve the ambiguity"
H5A25A1F05320: "將 'operator==' 宣告為 const，或新增相容的 'operator!=' 以解決歧義"
# "mark function boundaries with break instruction to make sure we accidentally don't cross them"
H5B830E6175D2: '使用 break 指令標記函數邊界，以確保不會意外跨越它們'
# 'marked %0 here'
HE33E97AC0225: '在此處標記 %0'
# "marked as 'declare variant' here"
H721AFFF82622: "在此處標記為 'declare 版本'"
# "marked as 'device_type(%0)' here"
HF283C800233B: "在此處標記為 'device_type(%0)'"
# 'mask type size must be between 1-byte and 8-bytes'
HA5CB60FF0FBF: '遮罩類型大小必須在 1 字節到 8 字節之間'
# 'match functions in binary 2 to binary 1 if they have the same hash of a function in binary 1'
HAF6822E35564: '如果二進位 2 中的函數與二進位 1 中的函數具有相同的雜湊值，則將它們匹配到二進位 1'
# "math errno enabled by '%0' after it was implicitly disabled by '%1', this may limit the utilization of the vector library"
HE93B3822306D: "'%0' 启用的 math errno 已在被 '%1' 隱式禁用後重新啟用，這可能會限制向量函式庫的使用"
# 'mathematical notation character <U+%0> in an identifier is a Clang extension'
H0378BC9B5A74: '識別符中使用數學符號字符 <U+%0> 是 Clang 的擴充功能'
# 'matrix %select{row|column}0 index is not an integer'
H46FD8A206DB4: '矩陣 %select{row|column}0 索引不是整數'
# 'matrix %select{row|column}0 index is outside the allowed range [0, %1)'
H847B8076D2C2: '矩陣 %select{row|column}0 索引超出允許範圍 [0, %1)'
# 'matrix row and column subscripts cannot be separated by any expression'
H5ED6E19FD5C5: '矩陣的列和行下標不能被任何表達式分隔'
# 'matrix types extension is disabled. Pass -fenable-matrix to enable it'
H4F1847B4A9E6: '矩陣類型擴充功能未啟用。傳遞 -fenable-matrix 參數以啟用'
# 'max depth when checking alias info in GatherAllAliases()'
HB91994902F54: '在 GatherAllAliases() 中檢查別名資訊時的最大深度'
# 'max number of bytes for the function to be considered small for inlining purposes'
H5D6C3AFD428B: '用於內嵌考量時，函數視為小函數的最大位元組數'
# 'max stack depth tracing'
H293E22C2DAE9: '最大堆疊深度追蹤'
# 'maxclusterrank requires sm_90 or higher, CUDA arch provided: %0, ignoring %1 attribute'
H49A2942ECE44: 'maxclusterrank 需要 sm_90 或更高版本，提供的 CUDA 指令集架構為 %0，忽略 %1 屬性'
# 'maximal number of instructions to instrument in any given BB'
H65055BD64342: '在任何給定的基本區塊 (BB) 中插樁的最大指令數'
# 'maximum address considered valid for heatmap (default 4GB)'
H617E4DDA7E48: '熱圖中視為有效的最大位址（預設 4GB）'
# 'maximum function durations'
H6F70690AFB07: '最大函式執行時間'
# 'maximum number of bytes to reorder'
H584FBF1D94C1: '要重新排序的最⼤位元組數'
# 'maximum number of bytes to use to align functions'
H20C9D30AEBA6: '用於對齊函式的最⼤位元組數'
# 'maximum number of call sites to inline'
H4BA4C864A650: '要內嵌的調⽤位置最⼤數量'
# 'maximum number of data relocations to process'
HD03C0F0EA38B: '要處理的資料重新定位最⼤數量'
# 'maximum number of functions to print in top called functions section'
HB5333D52E6C6: '頂端被調⽤函式區段要印出的函式最⼤數量'
# 'maximum number of functions to process'
H09D081159F9B: '要處理的函式最⼤數量'
# 'maximum number of hot basic blocks in a function for which to use a precise TSP solution while re-ordering basic blocks'
HA8A2B1281362: '重新排序基本區塊時，若函式的基本區塊數⼩於此值則使⽤精確 TSP 解決⽅案'
# 'maximum number of inline iterations'
HF9B3A8E58122: '內嵌的最⼤迭代次數'
# 'maximum number of samples to read from LBR profile'
H39D9A5AFA87A: '從 LBR 剖析中讀取的樣本最⼤數量'
# 'maximum number of symbols to reorder'
HB1688A460BA8: '要重新排序的最⼤符號數量'
# 'maximum percentage of stale functions to tolerate (default: 100)'
H9341327D8697: '可容忍的陳舊函式最⼤百分⽐（預設值：100）'
# 'maximum search depth. 0 forces a greedy approach. warning: the algorithm is up to O(2^N), where N is the max depth.'
H61B898BD8A31: '最大搜尋深度。0 個深度會強制使用貪婪演算法。警告：此演算法的時間複雜度為 O(2^N)，其中 N 為最大深度。'
# "meaningless '%0' on asm outside function"
H7C9CC9A0FF49: '函式外部的組合語言中無效的 "%0"'
# 'median function durations'
H4412290B83EA: '中位函式持續時間'
# 'member %0 cannot have template arguments'
H7530E8235E69: '成員 %0 不可具有模板參數'
# 'member %0 declared here'
H523D63E160D3: '此處宣告成員 %0'
# 'member %0 first declared here'
H53F314C373D4: '成員 %0 最初在此處宣告'
# 'member %0 found in multiple base classes of different types'
HE96F2F88498F: '成員 %0 在不同類型的多個基底類別中找到'
# 'member %0 has the same name as its class'
HBDCB2F361AEB: '成員 %0 的名稱與其類別相同'
# 'member %0 of %1 is not a template; did you mean %select{|simply }2%3?'
H88F478FC5C17: '成員 %0 的 %1 不是模板；你是指 %select{|直接 }2%3？'
# 'member %0 used before its declaration'
H21EA4914C844: '成員 %0 在宣告前使用'
# 'member access into incomplete type %0'
H3F51F529F796: '存取不完整類型 %0 的成員'
# 'member declaration does not match because it %select{is|is not}0 const qualified'
HB51C7FC5370B: '成員宣告不符合，因為它%select{是|不是}0 標記為 const'
# 'member declaration nearly matches'
HA07B45D5B59A: '成員宣告幾乎匹配'
# 'member found by ambiguous name lookup'
H1816E255A34E: '透過含糊的名稱搜尋找到成員'
# 'member function %0 is not needed and will not be emitted'
HC39E7B7627B2: '成員函數 %0 不需要，因此不會被發出'
# 'member function specialization matches %0'
HCDF99A0E6C9D: '成員函數特化符合 %0'
# 'member initializer %0 does not name a non-static data member or base class'
H35E3E12D1C39: '成員初始值設定項 %0 未指定非靜態資料成員或基底類別'
# 'member is declared here'
H08E5DDE7EA19: '成員在此宣告'
# "member is not a candidate because range type %0 has no '%select{end|begin}1' member"
HE822EBF784D6: '成員不是候選，因為區間類型 %0 沒有 "%select{end|begin}1" 成員'
# 'member not initialized by constructor'
H26EC51B7C7A4: '成員未經建構函數初始化'
# 'member of anonymous %select{struct|union}0 redeclares %1'
H9C0924E1182A: '匿名 %select{struct|union}0 的成員重新宣告 %1'
# 'member pointer has incomplete base type %0'
H9CA90CC9D193: '成員指標的基底類型 %0 不完整'
# 'member pointer representation requires a complete class type for %0 to perform this expression'
HA14D1B995CD2: '成員指標表示需要完整的類別類型 %0 來執行此運算式'
# 'member reference base type %0 is not a structure or union'
HDDC7E94D7C4D: '成員引用的基底類型 %0 不是結構或共用體'
# "member reference type %0 is %select{a|not a}1 pointer; did you mean to use '%select{->|.}1'?"
HCE4396C30D63: '成員引用類型 %0 是%select{一個|不是}1 指標；你是否想要使用 "%select{->|.}1"？'
# 'member reference type %0 is not a pointer'
H1067A041C0C1: '成員引用類型 %0 不是指標'
# 'member template declared %0 here'
H81FEA7456BEB: '成員模板在此宣告 %0'
# 'member type %0 found by ambiguous name lookup'
H1BDBA1C8E5BA: '在模稜兩可的名稱查找中找到成員類型 %0'
# 'member using declaration naming a non-member enumerator is incompatible with C++ standards before C++20'
HFDD47D4DEC61: '命名非成員枚舉符的成員使用宣告與 C++20 之前的標準不相容'
# "member using declaration naming non-class '%0' enumerator is incompatible with C++ standards before C++20"
H3AC79AC99394: "命名非類別 '%0' 枚舉符的成員使用宣告與 C++20 之前的標準不相容"
# 'memory order argument to atomic operation is invalid'
H10A1EB7E5921: '原子運算的記憶體順序參數無效'
# "memory order clause '%0' is specified here"
HEB7229373BDB: "這裡指定了記憶體順序子句 '%0'"
# 'merge multiple fdata into a single file'
H166CAC1CDA7E: '合併多個 fdata 至單一檔案'
# 'merge settag instruction in function epilog'
H69388C044859: '在函數末尾合併 settag 指令'
# 'merge stack variable initializers with tagging when possible'
H3914158550BF: '在可能時將堆疊變數初始值設定項與標記合併'
# 'merge-fdata options'
H84D7D36EDADD: 'merge-fdata 選項'
# 'messages delimited by --- lines, with # comment support'
H35F2755289E5: '以 --- 分隔的訊息，支援 # 註解'
# 'messages delimited by `// -----` lines, with // comment support'
HFC97CA453D6E: '以 `// -----` 分隔的訊息，支援 // 註解'
# 'messaging a Class with a method that is possibly direct'
H3E9374E93BAC: '向具有可能為直接方法的類別發送訊息'
# 'messaging super with a direct method'
H76B5A067ADF0: '以直接方法向超類別發送訊息'
# 'messaging unqualified id'
H25CF081972C3: '向未限定識別發送訊息'
# 'messaging unqualified id with a method that is possibly direct'
H52C4ECCB3445: '向未限定識別發送訊息，其方法可能為直接方法'
# 'method %0 declared here'
H0A29C282008D: '方法 %0 這裡宣告'
# 'method %0 in protocol %1 not implemented'
H3B6F9A4CA03E: '協定 %1 中的方法 %0 未實作'
# 'method %0 is used for the forward class'
H9C1FB20B5554: '方法 %0 用於前置類別宣告'
# 'method %0 that returns %1 declared here'
H81FA72B87C9D: '這裡宣告返回 %1 的方法 %0'
# 'method definition for %0 not found'
H2A6463515852: '找不到 %0 的方法定義'
# 'method for accessing %select{dictionary|array}1 element must have Objective-C object return type instead of %0'
H2A6E5DD7828B: '存取 %select{dictionary|array}1 元素的方法必須回傳Objective-C物件類型，而不是 %0'
# "method has no return type specified; defaults to 'id'"
HD11D99B1C083: "方法未指定回傳類型；預設為 'id'"
# 'method implementation does not match its declaration'
H2D5D386F5AFB: '方法實作與宣告不相符'
# 'method index parameter type %0 is not integral type'
H630B60C086B7: '方法索引參數類型 %0 不是整數型別'
# 'method is expected to return an instance of its class type %diff{$, but is declared to return $|, but is declared to return different type}0,1'
H4EBF90DD6088: '%diff{此方法應返回類型$，但宣告為返回$|，但宣告為返回不同類型}0,1'
# 'method key parameter type %0 is not object type'
H93D8788321DF: '方法鍵參數類型 %0 不是物件類型'
# 'method marked as designated initializer of the class here'
H6D873EC57BBB: '此方法被標記為類別的指定初始值設定項'
# "method name referenced in property setter attribute must end with ':'"
H48FC25BCA089: "屬性設定方法屬性中引用的方法名稱必須以 ':' 結尾"
# 'method object parameter type %0 is not object type'
H7C5EC09F4D4E: '方法物件參數類型 %0 不是物件類型'
# 'method override for the designated initializer of the superclass %objcinstance0 not found'
H353D09FC8C8A: '未找到超類%objcinstance0指定初始值設定項的方法覆寫'
# 'method parameter of type %0 with no explicit ownership'
H012CAADA6E5A: '類型 %0 的方法參數未明確指定所有權'
# 'method parameter type %diff{$ does not match super class method parameter type $|does not match super class method parameter type}0,1'
H52F29D4B5323: '%diff{方法參數類型$與超類方法參數類型$不相符|與超類方法參數類型不相符}0,1'
# 'method possibly missing a [super %0] call'
HF2DE0E720AA4: '此方法可能缺少[super %0]調用'
# 'method returns unexpected type %0 (should be an object type)'
HDA228B7E04A3: '方法返回了意外類型 %0（應為物件類型）'
# "method type specifier must start with '-' or '+'"
H60683402DB43: "方法類型指定符必須以 '-' 或 '+' 開頭"
# "method was declared as %select{an 'alloc'|a 'copy'|an 'init'|a 'new'}0 method, but its implementation doesn't match because %select{its result type is not an object pointer|its result type is unrelated to its receiver type}1"
H0332DF98668A: "此方法被宣告為%select{一個 'alloc'|一個 'copy'|一個 'init'|一個 'new'}0 方法，但其實作不符，因為%select{其回傳類型並非物件指標|其回傳類型與接收者類型無關}1"
# 'methods that %select{override superclass methods|implement protocol requirements}0 cannot be direct'
H10E1F7CDD559: '%select{覆寫超類方法|實作協定需求}0的方法不能直接呼叫'
# "micromips is not supported for target CPU '%0'"
H17AAF1CF7567: "目標CPU '%0' 不支援micromips"
# 'minimal size of the basic block that should be aligned'
H9310AFA3C7C1: '應對齊的基本區塊的最小大小'
# 'minimum address considered valid for heatmap (default 0)'
HB0C898B37318: '熱圖中視為有效的最小地址（預設值為 0）'
# 'minimum condition bias (pct) to perform a CMOV conversion, -1 to not account bias'
HF9B056CCAAE3: '執行CMOV轉換的最小條件偏移率（%），-1表示忽略偏移'
# 'minimum function durations'
H9FA9BE32CDEF: '函數的最小執行時間'
# 'minimum misprediction rate (pct) to perform a CMOV conversion, -1 to not account misprediction rate'
H0816E5149451: '執行CMOV轉換的最小預測錯誤率（%），-1表示忽略預測錯誤率'
# 'minimum number of points in an analysis cluster (dbscan only)'
H24AF23851D8A: '分析群集中的最小資料點數（僅限DBSCAN）'
# 'minimum offset needed between block and successor to allow duplication'
H75F42A78BFD9: '允許複製前後區塊與後繼區塊所需的最小偏移量'
# 'minimum vscale must be an unsigned integer greater than 0'
H97D216C9F9DC: '最小vscale必須是大於 0 的無符號整數'
# 'minus(-) operator for reductions is deprecated; use + or user defined reduction instead'
HB503599C3686: '約簡運算中使用減法（-）運算子已被棄用；建議改用+或使用者定義的約簡'
# 'misaligned atomic operation may incur significant performance penalty; the expected alignment (%0 bytes) exceeds the actual alignment (%1 bytes)'
HB642C05FEFCE: '未對齊的原子操作可能會導致顯著的效能損失；期望的對齊度（%0 個位元組）超過實際對齊度（%1 個位元組）'
# "misleading indentation; statement is not part of the previous '%select{if|else|for|while}0'"
H2D720E07A9B5: "誤導性的縮排；此語句並非前一個 '%select{if|else|for|while}0' 的部分"
# "mismatch between architecture and environment in target triple '%0'; did you mean '%1'?"
HFB1C45E0F3D8: "目標三元組 '%0' 中的架構與環境不符；是否應指定為 '%1'？"
# 'mismatch in number of block parameters and local size arguments passed'
H297CC009BE30: '區塊參數數量與傳遞的本地大小引數數量不匹配'
# 'misplaced %0; expected %0 here'
H6EEF8ABBCBBD: '此處出現不正確的 %0；應在此處使用 %0'
# 'misplaced attributes; expected attributes here'
H71DF23AD8094: '屬性放置位置錯誤；應在此處指定屬性'
# 'misprediction threshold for skipping ICP on an indirect call'
H2799B1202BB8: '跳過間接呼叫ICP的預測錯誤閾值'
# 'missing %1 after %0'
H71A0939C10D8: '缺少 %0 後面的 %1'
# "missing '(' after '#pragma %0' - ignoring"
H9BCF4D2D832C: "在 '#pragma %0' 後缺少 '(' - 忽略"
# "missing '(' following __VA_OPT__"
HFEF64C94E397: "在__VA_OPT__後缺少 '('"
# "missing ')' after '#pragma %0' - ignoring"
HD628B31A25D9: "在 '#pragma %0' 後缺少 ')' - 忽略"
# "missing ')' in macro parameter list"
HBA1269832ABB: "宏參數清單中缺少 ')'"
# "missing '*' in type bound %0 for type parameter %1"
H0FC1C4510683: "在類型參數 %1 的類型界限 %0 中缺少 '*'"
# "missing ',' after %0"
H36D833E1BE2F: "在 %0 後缺少 ','"
# "missing ',' between base or member initializers"
HC0E2DA10BD59: "基類或成員初始化器之間缺少 ','"
# "missing ',' between enumerators"
H3BCFAD409136: "列舉值之間缺少 ','"
# "missing ':' after %0 - ignoring"
H6D49C0F56471: "在 %0 修飾符後缺少 ':' - 忽略"
# "missing ':' after %0 modifier"
H1C42316D6361: "在 %0 修飾符後缺少 ':'"
# "missing ':' in %0"
HB39748BAFE7C: "在 %0 中缺少 ':'"
# "missing ':' or ')' after %0 - ignoring"
HA24B4C500D05: "在 %0 後缺少 ':' 或 ')' - 忽略"
# "missing '@end'"
H91CC5F3C7087: "缺少 '@end'"
# "missing '[' at start of message send expression"
H352486DC1A63: "在訊息傳送運算式的開頭缺少 '['"
# "missing 'export module' declaration in module interface unit"
H43BE56C41167: "缺少 'export module' 宣告在模組介面單元中"
# "missing 'export' specifier in module declaration while building module interface"
H73E9D7F0EE4B: "在建立模組介面時，模組宣告中缺少 'export' 修飾詞"
# "missing 'get=' or 'put='"
H5BBBF3CA84C4: "缺少 'get=' 或 'put='"
# "missing 'module' declaration at end of global module fragment introduced here"
HECF75AD1494B: "在這裡引進的全域模組片段末尾缺少 'module' 宣告"
# "missing 'template' keyword prior to dependent template name %0"
H6110BBE085CA: "依賴的範本名稱 %0 前缺少 'template' 關鍵字"
# "missing 'typename' prior to dependent type name %0"
H1584997CE5DB: "依賴型類別名稱 %0 前缺少 'typename'"
# "missing 'typename' prior to dependent type name %0; implicit 'typename' is a C++20 extension"
H15976F1154C9: "依賴型類別名稱 %0 前缺少 'typename'；隱含 'typename' 是 C++20 擴充功能"
# "missing 'typename' prior to dependent type template name %0"
HB65342C255DD: "依賴型類別模板名稱 %0 前缺少 'typename'"
# "missing '}' at end of definition of %q0"
HAF73F9C8E8E7: "在 %q0 的定義末尾缺少 '}'"
# 'missing actual type specifier for pipe'
H369BCA42F29A: '缺少管道的實際類型規格'
# "missing argument to '#pragma %0'%select{|; expected %2}1"
H85D43DEA45AB: '#pragma %0 缺少參數 %select{|；期望 %2}1'
# "missing argument to '%0'"
H52AC6CD34BC9: "'%0' 缺少參數"
# "missing argument to debug command '%0'"
H68E5FEB79890: "調適指令 '%0' 缺少參數"
# "missing argument; expected %select{an integer value|'enable'%select{|, 'full'}1%select{|, 'assume_safety'}2 or 'disable'}0"
H6DC6E5CF70F4: "缺少參數；期望 %select{整數值|'enable'%select{|, 'full'}1%select{|, 'assume_safety'}2 或 'disable'}0"
# 'missing context for method declaration'
HDB791FF5D00C: '缺少方法宣告的上下文'
# 'missing context for property implementation declaration'
HB2B46E5EAE97: '缺少屬性實作宣告的上下文'
# 'missing custom discrimination'
H8E91DD601C8B: '缺少自訂區別條件'
# 'missing debug command'
HC4112B242494: '缺少調適指令'
# 'missing default argument on parameter'
H8EC917CC5F93: '參數缺少預設參數值'
# 'missing default argument on parameter %0'
H8F4C6F0521D4: '參數 %0 缺少預設參數值'
# 'missing field %0 initializer'
HBCFF05CA88FD: '缺少成員 %0 的初始值設定'
# 'missing map type'
H4AA13FCA7666: '缺少映射類型'
# 'missing map type modifier'
H60251948404E: '缺少映射類型修飾詞'
# 'missing numthreads attribute for %0 shader entry'
HFADE160C1BC1: '%0 着色器入口缺少 numthreads 屬性'
# 'missing object format flag'
HD57D82290D05: '缺少物件格式旗標'
# "missing or invalid line number following '@' in expected %0"
H296CBDA95848: "在期望的 %0 中，'@' 後面缺少或無效的行號"
# 'missing parentheses around the size of parameter pack %0'
HA558CBB9F294: '參數套件 %0 的大小缺少括號'
# 'missing plugin argument for plugin %0 in %1'
H8600AE8C89F9: '%1 中的插件 %0 缺少插件參數'
# 'missing plugin name in %0'
H4A2F8D6C22D3: '%0 中缺少插件名稱'
# "missing reduction operator, expected '+', '*', 'max', 'min', '&', '|', '^', '&&', or '||', follwed by a ':'"
H9DF20C9098D2: "缺少減少運算子，期望 '+', '*', 'max', 'min', '&', '|', '^', '&&', 或 '||'，後跟一個 ':'"
# 'missing return type for function %0; did you mean the constructor name %1?'
H0096A8359309: '函數 %0 缺少返回型別；您是否指構造函式名稱 %1？'
# "missing sanitizer ignorelist: '%0'"
HE7971DD1E969: "缺少分析器忽略清單：'%0'"
# 'missing sentinel in %select{function call|method dispatch|block call}0'
H10D39CEB9167: '缺少 %select{函數呼叫|方法調度|區塊呼叫}0 的哨兵值'
# 'missing state for %0'
HCF224168FF82: '%0 缺少狀態'
# "missing submodule '%0'"
H4FF2783EAA28: "缺少子模組 '%0'"
# 'missing symbol graph output directory, defaulting to working directory'
H1ACFD82E27C5: '缺少符號圖輸出目錄，預設使用工作目錄'
# 'missing terminating %select{\'|\'"\'}0 character'
HC91AE5B6C664: '缺少終結 %select{\'|\'"\'}0 字元'
# "missing terminating ')' character"
H110B9B84BD50: "缺少終結的 ')' 字元"
# 'missing type bound %0 for type parameter %1 in %select{@interface|@class}2'
HCB937BA83DD0: '%select{@interface|@class}2 中的類型參數 %1 缺少型別限制 %0'
# 'mixed CUDA and HIP compilation is not supported'
HDE7D3706C5B5: 'CUDA 和 HIP 混合編譯不受支援'
# "mixing 'target_clones' specifier mechanisms is permitted for GCC compatibility; use a comma separated sequence of string literals, or a string literal containing a comma-separated list of versions"
H65625B3622E8: '為符合 GCC 兼容性，允許混合使用 target_clones 指定項機制；請使用逗號分隔的字元串清單，或單一包含逗號分隔版本清單的字元串'
# 'mixing declarations and code is a C99 extension'
H509E36ADC1D7: '混合宣告與程式碼是 C99 的擴充功能'
# 'mixing declarations and code is incompatible with standards before C99'
HD580E194E35D: '在 C99 之前的標準中，混合宣告與程式碼是不相容的'
# 'mixture of designated and non-designated initializers in the same initializer list is a C99 extension'
H29C32AE72D18: '在同一初始化清單中混合指定和非指定初始化器是C99擴展'
# 'mlir-query options'
HE19598DC2C40: 'mlir-query 選項'
# 'mlir-reduce options'
H3CAB90C0AD8E: 'mlir-reduce 選項'
# 'mode %0 is not supported for enumeration types'
H9D1986A84BDA: '模式 %0 不支援枚舉類型'
# 'mode attribute only supported for integer and floating-point types'
H759A20BD1268: 'mode 屬性僅支援整數和浮點數類型'
# 'mode for simplify conditional tail calls'
H7E2CD8BDAB86: '簡化條件尾呼叫的模式'
# 'moderate strategy'
H73892DAB539F: '中等策略'
# 'modification of object of const-qualified type %0 is not allowed in a constant expression'
H403821CE466D: '修改const限定類型 %0 的物件在常數運算式中是不被允許的'
# "modifier '%0' cannot be used along with modifier '%1'"
HDE467CEB2037: "修飾符 '%0' 不能與修飾符 '%1' 一起使用"
# 'modifying constructor parameter %0 that shadows a field of %1'
H1430708B59D6: '修改構造函數參數 %0，該參數遮蔽了 %1 的成員'
# 'modularize.\n'
HA1E9FFD28E50: '模組化.\n'
# "module %0 does not depend on a module exporting '%1'"
H85DEF90A3AE0: "模組 %0 不依賴導出 '%1' 的模組"
# "module %0 does not directly depend on a module exporting '%1', which is part of indirectly-used module %2"
H9D50309367F5: "模組 %0 不直接依賴導出 '%1' 的模組，該模組是間接使用的模組 %2 的一部分"
# "module '%0' %select{in|imported by}4 AST file '%1' found in a different module map file (%2) than when the importing AST file was built (%3)"
H7F407C161851: "在AST檔案 '%1' 的模組 '%0' %select{in|被}4 引入時，其所在的模組地圖檔案 (%2) 與建立導入AST檔案時所用 (%3) 不同"
# "module '%0' %select{is incompatible with|requires}1 feature '%2'"
H4440A0170E90: "模組 '%0' %select{與|需要}1 功能 '%2' 不相容"
# "module '%0' %select{uses|does not use}1 additional module map '%2'%select{| not}1 used when the module was built"
HAC53C3FABCDA: "模組 '%0' %select{使用|未使用}1 額外的模組地圖 '%2'%select{|未}1 在建立模組時使用"
# "module '%0' already re-exported as '%1'"
H6556B7A46703: "模組 '%0' 已經以 '%1' 的名稱重新導出"
# "module '%0' conflicts with already-imported module '%1': %2"
HED958876B86C: "模組 '%0' 與已導入的模組 '%1' 冲突：%2"
# "module '%0' in AST file '%1' %select{(imported by AST file '%2') |}4is not defined in any loaded module map file; maybe you need to load '%3'?"
H951252F32734: "AST 檔案 '%1' 中的模組 '%0' %select{(由 AST 檔案 '%2' 引入) |}4 未在任何已載入的模組地圖檔中定義；可能需要載入 '%3'？"
# "module '%0' is defined in both '%1' and '%2'"
H9937FAC6E395: "模組 '%0' 同時在 '%1' 和 '%2' 中定義"
# "module '%0' is needed but has not been provided, and implicit use of module files is disabled"
H8C7DAF453831: "模組 '%0' 無法提供且隱式使用模組檔的功能已停用"
# "module '%0' not found"
H55DF0ED78DC5: "未找到模組 '%0'"
# "module '%0' was built in directory '%1' but now resides in directory '%2'"
H38AD29640B23: "模組 '%0' 最初建置於目錄 '%1'，但現位於目錄 '%2'"
# "module compilation requires '-fmodules'"
H6A96D77D9F41: "模組編譯需要指定 '-fmodules'"
# 'module declaration can only appear at the top level'
HB03E6C215813: '模組宣告只能出現在頂級作用域'
# 'module declaration must occur at the start of the translation unit'
HA7783A63FE0B: '模組宣告必須位於翻譯单元的開頭'
# 'module defined here'
HDB50FF2BF5A8: '模組在此處定義'
# 'module file %0 cannot be loaded due to a configuration mismatch with the current compilation'
H469015AF9879: '模組檔案 %0 無法載入，因為其配置與當前編譯不相符'
# "module file '%0' is missing its top-level submodule"
HFA537775278A: "模組檔案 '%0' 缺少頂級子模組"
# "module file '%0' was validated as a system module and is now being imported as a non-system module; any difference in diagnostic options will be ignored"
H13B637DDA3AA: "模組檔案 '%0' 經驗證為系統模組但現以非系統模組導入；任何診斷選項的差異將被忽略"
# 'module file suffix override'
H69E50E2734CF: '模組檔案副檔名覆寫'
# "module header file '%0' not found"
HDA48886085ED: "模組標頭檔 '%0' 未找到"
# 'module imported here'
HA3A8055B303E: '在此處導入模組'
# "module interface compilation requires '-std=c++20'"
HA34462B55274: '模組介面編譯需要 "-std=c++20"'
# "module loaded from '%0'"
H07E2BBCF1C1E: "從 '%0' 載入模組"
# "module map file '%0' not found"
HD693305F9871: "找不到模組地圖檔案 '%0'"
# "module name '%0' specified on command line does not match name of module"
H0F48D36629AC: "命令列指定的模組名稱 '%0' 與模組名稱不相符"
# 'module output directory (default .)'
H445A6DEE34DF: '模組輸出目錄（預設為當前目錄）'
# 'module partition implementations cannot be exported'
HFE1B8CB7B1E9: '模組分割的實作無法被匯出'
# 'module partition imports must be within a module purview'
H99C430D138F5: '模組分割的導入必須在模組作用域內'
# 'module partitions are only supported for C++20 onwards'
HB98F31FF7B9A: '模組分割僅支援 C++20 及更新版本'
# 'module search directory'
H3FAA97FDA5D1: '模組搜尋目錄'
# 'module%select{| partition}0 imports cannot be in the %select{global|private}1 module fragment'
HE6F2588D0369: '模組 %select{| 分割}0 的導入不得位於 %select{全域|私人}1 模組片段中'
# "more '%%' conversions than data arguments"
H9766AC9D490A: "'%%' 轉換數多於資料參數"
# "more than one 'device_type' clause is specified"
H018E0AE39152: "指定了多個 'device_type' 子句"
# "more than one for-loop in a loop associated with OpenACC '%0' construct with a '%1' clause"
H30D49A113B6A: "與 OpenACC '%0' 建構具有 '%1' 子句相關聯的迴圈中存在多個 for 迴圈"
# 'more than one framework/dynamic library found'
H611E8232270A: '找到多個框架/動態函式庫'
# "more than one input constraint matches the same output '%0'"
H4D494A49ED15: "多個輸入限制條件與相同的輸出 '%0' 匹配"
# 'move jump tables to a separate section'
HC21B261E02F6: '將跳轉表移至獨立區段'
# 'moving a local object in a return statement prevents copy elision'
H928AEBBA3589: '在 return 陳述式中移動局部物件會阻止複製省略'
# 'moving a temporary object prevents copy elision'
H7FCDBDAE9C59: '移動暫時物件會阻止複製省略'
# 'ms_struct may not produce Microsoft-compatible layouts for classes with base classes or virtual functions'
H0D36DB1654BA: 'ms_struct 可能無法為具有基底類別或虛函數的類別產生與 Microsoft 相容的佈局'
# "ms_struct may not produce Microsoft-compatible layouts with fundamental data types with sizes that aren't a power of two"
H9013C05CB59B: 'ms_struct 可能無法與大小非為 2 的冪次方的基本資料類型一起產生與 Microsoft 相容的佈局'
# 'mtriple'
H7584397F39BE: 'mtriple'
# 'multi-character character constant'
H8914BC0B6E30: '多字元字元常量'
# 'multi-dimensional arrays of WebAssembly references are not allowed'
HDC4921C402A6: 'WebAssembly 參考的多維陣列不予允許'
# 'multi-line // comment'
HC0A7D2EE8599: '多行 // 註解'
# 'multilib configuration error: %0'
H51BCFF1832A0: 'multilib 設定錯誤: %0'
# "multiple %0 architectures are detected: %1; only the first one is used for '%2'"
HF49114F051BF: "檢測到多個 %0 指令集: %1; 僅使用第一個用於 '%2'"
# "multiple %select{'step size'|'linear modifier'}0 found in linear clause"
H6C58F45C9F56: "在線性子句中找到多個 %select{'step size'|'linear modifier'}0"
# "multiple 'callback' attributes specified"
H9EF4CEF4A9C0: "指定了多個 'callback' 屬性"
# "multiple 'cpu_specific' functions cannot specify the same CPU: %0"
H3B8B7713681E: "多個 'cpu_specific' 函數不能指定相同的 CPU: %0"
# "multiple 'lifetime_capture' attributes specified"
H42096CECC49E: "指定了多個 'lifetime_capture' 屬性"
# "multiple 'routine' directives with 'bind' clauses are not permitted to refer to the same function"
HDA1D710FAA21: "具有 'bind' 子句的多個 'routine' 指令不得引用同一個函數"
# 'multiple access qualifiers'
HA0304D566382: '多個存取修飾符'
# 'multiple address spaces specified for type'
H4075C38BB93B: '為類型指定多個位址空間'
# 'multiple array elements associated with the same variable are not allowed in map clauses of the same construct'
H289BE95E22C4: '同一構造中的 map 子句中不允許同一個變數關聯多個陣列元素'
# 'multiple conversions from expression type %0 to an integral type'
H80B8D963ECA1: '從運算式類型 %0 轉換為整數類型的多種轉換'
# 'multiple conversions from switch condition type %0 to an integral or enumeration type'
H23301D5B9A53: '從 switch 條件類型 %0 轉換為整數或列舉類型的多種轉換'
# 'multiple declarations of method %0 found and ignored'
HA50D97FB9EC5: '找到多個方法 %0 的宣告並忽略'
# 'multiple default labels in one switch'
H1F979F2765D2: '同一個 switch 中有多个 default 標籤'
# 'multiple definitions are found for the same key in index '
HBED55B0B868B: '索引中找到同一個鍵的多個定義'
# 'multiple ellipses in pack capture'
H2EAABC9D1825: '封包捕獲中有多個省略號'
# 'multiple garbage collection attributes specified for type'
H8DF299790474: '為類型指定多個垃圾回收屬性'
# 'multiple identical address spaces specified for type'
H2A39AD934787: '為類型指定多個相同的地址空間'
# 'multiple initializations given for base %0'
H6C502C93AC06: '基類 %0 給出了多個初始化'
# 'multiple initializations given for non-static member %0'
HF2A12907FBDA: '非靜態成員 %0 給出了多個初始化'
# "multiple inputs are not valid for header units (first extra '%0')"
H85058EEFACAE: "多個輸入不符合頭單元的格式（第一個多餘的 '%0'）"
# 'multiple methods named %0 found'
H170992E437FC: '找到多個名為 %0 的方法'
# 'multiple methods named %0 found with mismatched result, parameter type or attributes'
HB7ACC94E443E: '找到多個名為 %0 的方法，其結果類型、參數類型或屬性不匹配'
# 'multiple overloads of %0 instantiate to the same signature %1'
H3B92DD0A02C5: '%0 的多個重載會實例化為相同的簽名 %1'
# 'multiple packs in structured binding declaration'
HFE5E55E2957C: '結構化綁定宣告中有多個封包'
# 'multiple return statements in constexpr function is a C++14 extension'
H4582B1A35055: 'constexpr 函數中有多個 return 語句是 C++14 的擴充'
# 'multiple return statements in constexpr function is incompatible with C++ standards before C++14'
H4061EC95BBA4: 'constexpr 函數中有多個 return 語句與 C++14 之前的標準不相容'
# "multiple suitable %0 functions for %1; no 'operator delete' function will be invoked if initialization throws an exception"
HB304821CF54E: "%1 的多個適合 %0 函數；若初始化引發例外，不會調用 'operator delete' 函數"
# 'multiple suitable %0 functions in %1'
H04588097A2D5: '在 %1 中有多个適合的 %0 函數'
# 'multiple unsequenced modifications to %0'
HBE9DFDF729B3: '%0 的多次未順序修改'
# 'multiple vtable pointer authentication policies on %0'
H64E76C32EB13: '%0 上有多個 vtable 指標驗證策略'
# 'multiversioned function declaration has a different %select{calling convention|return type|constexpr specification|inline specification|linkage|language linkage}0'
H037AEBCE675B: '多版本函數宣告具有不同的 %select{呼叫約定|傳回類型|constexpr 指定|inline 指定|連結性|語言連結}0'
# 'multiversioned function must have a prototype'
HC2FE50BE244F: '多版本函數必須具有原型'
# 'multiversioned function redeclarations require identical target attributes'
H21088B0A235D: '多版本函數的重新宣告需要相同的目標屬性'
# 'multiversioning attributes cannot be combined'
HB5E9464B0FCA: '多版本屬性無法組合使用'
# "must be declared with 'noexcept'"
H987DB13AD301: "必須使用 'noexcept' 進行聲明"
# 'must be specified at least once!'
H226887FCC25B: '必須至少指定一次！'
# 'must explicitly describe intended ownership of an object array parameter'
H94C16C029EFB: '必須明確描述物件陣列參數的擁有權'
# 'must explicitly qualify name of member function when taking its address'
H10EC7DC2756E: '取得成員函數位址時必須明確限定其名稱'
# "must handle potential future platforms with '*'"
H52CBF98EE88A: "必須處理可能包含 '*' 的未來平台"
# 'must name member using the type of the current context %0'
H0A063C055ADE: '必須使用當前作用域 %0 的類型來命名成員'
# "must pass in an explicit %0 gpu architecture to '%1'"
H748BF240D8AC: "必須在 '%1' 中明確指定 %0 GPU 架構"
# "must provide a symbol graph output directory using '--symbol-graph-dir=<directory>'"
H7FEC01DD8141: '建立可重定位的 PCH 檔案時，必須使用 -isysroot 指定系統根目錄'
# 'must qualify identifier to find this declaration in dependent base class'
HB8E730405435: "必須指定符號圖輸出目錄使用 '--symbol-graph-dir=<目錄>'"
# "must specify '-fmodule-name=%0' to enter %select{|submodule of }1this module%select{ (current module is %3)|}2"
HF0DE733FAF70: "必須指定 '-fmodule-name=%0' 以進入 %select{|子模組的 }1此模組%select{（目前模組為 %3）|}2"
# 'must specify system root with -isysroot when building a relocatable PCH file'
H530DD8BE4BB8: '建立可重新定位的PCH檔案時，必須使用-isysroot指定系統根目錄'
# "must use '%1' tag to refer to type %0%select{| in this scope}2"
H25B19F90B2A8: '必須在這個作用域中使用 "%1" tag 來引用類型 %0%select{|}2'
# 'my-tool options'
H6F25BE7781B0: 'my-tool 選項'
# 'name defined in alias declaration must be an identifier'
HF20E175DA10B: '別名宣告中定義的名稱必須是識別符'
# 'name defined in concept definition must be an identifier'
H9F376A6B25D8: '概念定義中定義的名稱必須是識別符'
# 'named bit-field %0 has zero width'
HB27FCD740169: '命名的位段 %0 具有零位寬度'
# 'named variadic macros are a GNU extension'
H4A2738C3ADE2: '命名的可變參數宏是 GNU 擴展'
# 'namespace %0 defined here'
H6C2973533802: '命名空間 %0 在此處定義'
# 'namespace alias cannot be inline'
H69290D9B2469: '命名空間別名不能是內聯的'
# 'namespace alias must be a single identifier'
HA11E2A62D886: '命名空間別名必須是單一識別符'
# "namespace can only apply to 'push' or 'pop' directives"
H6F30E709453F: "命名空間只能套用在 'push' 或 'pop' 指令上"
# 'namespaces can only be defined in global or namespace scope'
HDB4E6C24AE7F: '命名空間只能在全域或命名空間範疇中定義'
# "negated attribute subject matcher sub-rule '%0' contradicts sub-rule '%1'"
H92B926B255DE: "否定的屬性主體匹配子規則 '%0' 與子規則 '%1' 相矛盾"
# 'negative shift count %0'
HC6E4102E7BA3: '負數移位次數 %0'
# "nested OpenMP context selector contains duplicated trait '%0' in selector '%1' and set '%2' with different score"
HC583359DCCE0: "巢狀OpenMP上下文選擇器在選擇器 '%1' 和集合 '%2' 中具有不同的分數時，重複了特性 '%0'"
# 'nested designators are a C99 extension'
H97E72072881F: '巢狀設計者是C99擴展'
# 'nested name specifier %0 for declaration does not refer into a class, class template or class template partial specialization'
H326DE285E8C5: '宣告的巢狀命名空間指定項 %0 不指向類別、類別範型或類別範型部分特殊化'
# 'nested name specifier for a declaration cannot depend on a template parameter'
H87A0C3C18BC3: '宣告的巢狀命名空間指定項不能依賴範型參數'
# "nested namespace definition cannot be 'inline'"
HB262A63F161A: "巢狀命名空間定義不能標示為 'inline'"
# 'nested namespace definition is a C++17 extension; define each namespace separately'
HEFB4B9AD8E01: '巢狀命名空間定義是C++17擴展；請分開定義每個命名空間'
# 'nested namespace definition is incompatible with C++ standards before C++17'
H0E35039F1D67: '巢狀命名空間定義與C++17之前的標準不相容'
# 'nested parentheses not permitted in %0'
H34953581058C: '在 %0 中不允許嵌套括號'
# 'nested redefinition of %0'
H0AC10F45C385: '%0 的巢狀重新定義'
# 'nested teams construct here'
HF6BEE2475F61: '這裡的巢狀團隊構造'
# 'nested user conditions in OpenMP context selector not supported (yet)'
H4C0B107BB3D4: 'OpenMP上下文選擇器不支援巢狀使用者條件（暫時）'
# 'never apply unchecked-ld-st'
HBB179F0E1AB0: '永不套用未檢查的載入/存儲操作'
# 'never print'
H669835729B5F: '永不列印'
# 'never replace exit value'
H0750F0A2D157: '永不取代退出值'
# 'new expression for type %0 contains multiple constructor arguments'
H0D34CDEC5737: '類型 %0 的 new 表達式包含多個建構函數參數'
# 'new expression for type %0 has incompatible constructor argument of type %1'
H8E7FF8B53FFB: '類型 %0 的 new 表達式具有類型 %1 的不相容建構函數參數'
# 'new expression for type %0 requires a constructor argument'
H55FA18FEEE0E: '類型 %0 的 new 表達式需要一個建構函數參數'
# 'next %select{instance variable declaration|synthesized instance variable}0 is here'
H6502100189C0: '接下來的 %select{實例變數宣告|合成的實例變數}0 在此處'
# 'next field declaration is here'
H589A37214DA3: '接下來的欄位宣告在此處'
# 'no %select{getter|setter}0 defined for property %1'
HDA010EA6C052: '屬性 %1 未定義 %select{getter|setter}0'
# 'no %select{struct|interface|union|class|enum}0 named %1 in %2'
HCA856DA687CE: '在 %2 中未找到名為 %1 的 %select{結構|接口|聯合|類|枚舉}0'
# "no 'assign', 'retain', or 'copy' attribute is specified - 'assign' is assumed"
H5D9A45CF4470: "未指定 'assign', 'retain' 或 'copy' 屬性，假設為 'assign'"
# 'no @interface declaration found in class messaging of %0'
H39108401F4F8: '在 %0 的類別訊息中未找到 @interface 宣告'
# "no MCU device specified, but '-mhwmult' is set to 'auto', assuming no hardware multiply; use '-mmcu' to specify an MSP430 device, or '-mhwmult' to set the hardware multiply type explicitly"
HF3E9B95BB7DD: "未指定 MCU 裝置，但 '-mhwmult' 設定為 'auto'，假設無硬體乘法；使用 '-mmcu' 指定一個 MSP430 裝置，或使用 '-mhwmult' 明確設定硬體乘法類型"
# 'no PowerPC native vector element order.'
H49C9870074B0: '未指定 PowerPC 原生向量元素順序。'
# "no analyzer checkers or packages are associated with '%0'"
H8B728EEF35B9: "與 '%0' 關聯的分析器檢查器或套件不存在"
# 'no avr-libc installation can be found on the system, cannot link standard libraries'
H5206EA6489A5: '系統中未找到 avr-libc 安裝，無法連結標準函式庫'
# 'no candidate function template was found for dependent %select{member|friend}0 function template specialization'
HC620314BA8FA: '未找到依賴的 %select{成員|友元}0 函數模板特化的候選函數模板'
# "no case matching constant switch condition '%0'"
HBFE1788B232F: "沒有與常數 switch 條件 '%0' 匹配的 case"
# "no closing ']' for '%%[' in scanf format string"
H5E8D81CB9C26: "scanf 格式字串中的 '%%[' 未找到對應的 closing ']'"
# 'no corresponding base class here'
HBBF529A4447F: '此處沒有對應的基類'
# 'no corresponding enumerator here'
HCF6777617E14: '此處沒有對應的枚舉常數'
# 'no corresponding field here'
H8BC5689EEC5A: '此處沒有對應的成員變數'
# 'no corresponding friend here'
H0544B78403CC: '此處沒有對應的友元'
# 'no corresponding superclass here'
HE11938993661: '此處沒有對應的超類'
# "no declaration found for exported symbol '%0' in dynamic library"
H247D438751B2: "在動態庫中未找到導出符號 '%0' 的宣告"
# "no declaration was found for exported symbol '%0' in dynamic library"
H01E907352618: "在動態庫中未找到導出符號 '%0' 的宣告"
# "no expected directives found: consider use of '%0-no-diagnostics'"
H60C61DB5DCD2: "未找到期望的指示：考慮使用 '%0-no-diagnostics'"
# 'no function template matches function template specialization %0'
H783C344DF4FC: '沒有函數模板與函數模板特化 %0 匹配'
# 'no getter method %1 for %select{increment|decrement}0 of property'
H27A03BEFDE9D: '屬性的%select{遞增|遞減}0操作沒有getter方法 %1'
# 'no getter method for read from property'
HC653B7766A2E: '讀取屬性時沒有getter方法'
# "no handler registered for module format '%0'"
H54F9399D659E: '未為模組格式 "%0" 註冊處理程序'
# 'no input files'
HFFB86B2450DC: '沒有輸入檔案'
# 'no install name specified: add -install_name <path>'
H183DF472D6DF: '未指定安裝名稱：添加 -install_name <path>'
# 'no known %select{instance|class}1 method for selector %0'
H41C44394DC27: '選擇器 %0 沒有已知的%select{實例|類別}1方法'
# "no known method %select{%objcinstance1|%objcclass1}0; cast the message send to the method's return type"
HD141497E30B9: '未找到已知方法 %select{%objcinstance1|%objcclass1}0；將訊息傳遞轉換為方法的返回類型'
# "no library '%0' found in the default clang lib directory or in LIBRARY_PATH; use '--libomptarget-%1-bc-path' to specify %1 bitcode library"
H56082C491F7D: '在預設的clang庫目錄或LIBRARY_PATH中未找到庫 "%0"；使用 "--libomptarget-%1-bc-path" 指定 %1 位元碼庫'
# 'no macro named %0'
HDBF2015FF73B: '沒有名為 %0 的宏'
# 'no matching %0 function for non-allocating placement new expression; include <new>'
H7020E0B0AF12: '對非分配placement new運算式沒有匹配的 %0 函數；包含 <new>'
# "no matching '#pragma clang module begin' for this '#pragma clang module end'"
HCC39D351076F: "未找到對應的 '#pragma clang module begin' 來對應此 '#pragma clang module end'"
# "no matching '#pragma clang module end' for this '#pragma clang module begin'"
H688037E203CF: "未找到對應的 '#pragma clang module end' 來對應此 '#pragma clang module begin'"
# "no matching '#pragma clang module endbuild' for this '#pragma clang module build'"
H4D6A2C63F3F1: "未找到對應的 '#pragma clang module endbuild' 來對應此 '#pragma clang module build'"
# 'no matching constructor for initialization of %0'
H60A16B350ED3: '初始化 %0 時未找到匹配的建構函數'
# 'no matching conversion for %select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2'
HB6FD5E96FCBB: '從 %1 轉換為 %2 時，未找到與 %select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 匹配的轉換'
# 'no matching function for call to %0'
HF7D6FEC7B803: '呼叫 %0 時未找到匹配的函數'
# 'no matching function for call to object of type %0'
H4AB0B7C8D656: '呼叫類型為 %0 的物件時未找到匹配的函數'
# "no matching literal operator for call to %0%select{| with argument of type %2| with arguments of types %2 and %3}1%select{| or 'const char *'}4%select{|, and no matching literal operator template}5"
H1F7F02224823: "未找到與 %0 相對應的字面運算子；嘗試呼叫 %select{|具有類型 %2 的引數|具有類型 %2 和 %3 的引數}1%select{| 或 'const char *'}4%select{|，且未找到匹配的字面運算子模板}5"
# 'no matching member function for call to %0'
HACEA313A920D: '呼叫 %0 時未找到匹配的成員函數'
# "no matching target found for target variant '%0'"
H2CC48DEFF159: "未找到目標變體 '%0' 的對應目標"
# 'no member %0 in %1; it has not yet been instantiated'
H6800794A683C: '%1 中未找到成員 %0；它尚未被實體化'
# 'no member named %0 in %1'
H85214E062B3A: '%1 中未找到名為 %0 的成員'
# 'no member named %0 in %1; did you mean %select{|simply }2%3?'
H5B97925635DE: '%1 中未找到名為 %0 的成員；您是否想 %select{|直接 }2 使用 %3？'
# "no member named %0 in %1; did you mean to use '->' instead of '.'?"
HBE0974E3EE78: '%1 中未找到名為 %0 的成員；是否應改用 "→" 而非 "."？'
# 'no method with selector %0 is implemented in this translation unit'
H0CDD4F98E18F: '此翻譯单元中未實作選擇子 %0 的方法'
# 'no module map available for module %0'
HF688B8490C1B: '模組 %0 沒有可用的模組地圖'
# 'no module name provided; specify one with -fmodule-name='
H99A7BF8D2824: '未指定模組名稱；請使用 -fmodule-name= 指定'
# "no module named '%0' %select{found|in '%2'}1, parent module must be defined before the submodule"
H86A38EF918F2: "未找到名為 '%0' 的模組 %select{存在|在 '%2' 中}1，父模組必須在子模組之前定義"
# "no module named '%0' declared in module map file '%1'"
HABF2F4633281: "在模組地圖檔 '%1' 中未宣告名為 '%0' 的模組"
# "no module named '%0' in '%1'"
H658500ACD8C1: "在 '%1' 中未找到名為 '%0' 的模組"
# "no module named '%0' visible from '%1'"
HA7094B5AEB21: "從 '%1' 可見的範圍內未找到名為 '%0' 的模組"
# "no more 'if' clause is allowed"
H8F7A1C6703AA: "不允許再有 'if' 子句"
# "no more than one option '--config' is allowed"
H3089388E4475: "最多只能指定一個 '--config' 選項"
# 'no multilib found matching flags: %0'
HCDE4340CFBD3: '未找到符合旗標 %0 的 multilib'
# 'no namespace named %0 in %1; did you mean %select{|simply }2%3?'
HF6FEAE5E55D9: '在 %1 中未找到名為 %0 的命名空間；您是想要 %select{|僅 }2%3 嗎？'
# 'no namespace named %0; did you mean %1?'
H81CE4465B841: '未找到名為 %0 的命名空間；您是想要 %1 嗎？'
# 'no newline at end of file'
HC3F31DC1712E: '檔案結尾缺少換行符'
# 'no output file specified'
HA94EBB9ACB5A: '未指定輸出檔案'
# 'no previous extern declaration for non-static variable %0'
H8B284B72F880: '非靜態變數 %0 缺少先前的 extern 宣告'
# 'no previous prototype for function %0'
H03B77D9B5049: '函數 %0 缺少先前的函式原型'
# 'no profile data available for file "%0"'
H59152796471E: '檔案 "%0" 缺少可用的剖析資料'
# 'no return statement in %select{constexpr|consteval}0 function'
H6CABFAB2482E: '在 %select{constexpr|consteval}0 函式中缺少 return 語句'
# "no submodule named %0 in module '%1'"
H2B7BA310F788: "模組 '%1' 中未找到名為 %0 的子模組"
# "no submodule named %0 in module '%1'; did you mean '%2'?"
H7D6A5E92FB55: "模組 '%1' 中未找到名為 %0 的子模組；您是指 '%2' 嗎？"
# "no submodule named %0 in module '%1'; using top level '%2'"
H5C502E1660AA: "模組 '%1' 中未找到名為 %0 的子模組；改用頂層 '%2'"
# "no such %select{public|private|project}1 header file: '%0'"
H6EFAEBB81765: "未找到此 %select{public|private|project}1 頭檔案：'%0'"
# "no such excluded %select{public|private}0 header file: '%1'"
HED06FD077272: "未找到排除的 %select{public|private}0 頭檔案：'%1'"
# "no such file or directory: '%0'"
HE170FBCF53FC: "找不到檔案或目錄：'%0'"
# "no such file or directory: '%0'; did you mean '%1'?"
HE112F2418E57: "找不到檔案或目錄：'%0'; 是否是指 '%1'?"
# "no such include directory: '%0'"
H7E37FF613F8F: "找不到包含目錄：'%0'"
# "no such sysroot directory: '%0'"
H7EBC246FEEA8: "找不到 sysroot 目錄：'%0'"
# 'no suitable member %0 in %1'
H3750344F18EF: '在 %1 中未找到適合的成員 %0'
# "no suitable precompiled header file found in directory '%0'"
HC9D05A0684EB: "在目錄 '%0' 中未找到預編譯標頭檔案"
# 'no target microcontroller specified, please pass -mmcu=<mcu name>'
H861E68DCEBF9: '未指定目標微控制器，請傳遞 -mmcu=<mcu name>'
# 'no template named %0'
HFC0C70B06D89: '找不到名為 %0 的範本'
# 'no template named %0 in %1'
H16DB7E6BC24D: '在 %1 中未找到名為 %0 的範本'
# 'no template named %0 in %1; did you mean %select{|simply }2%3?'
HCDFE5581F7D6: '在 %1 中未找到名為 %0 的範本; 是否 %select{|僅}2指 %3?'
# 'no template named %0; did you mean %1?'
H32AFF6E21FDC: '未找到名為 %0 的範本; 是否指 %1?'
# 'no type named %0 in %1'
H6E87E8CAFF42: '在 %1 中未找到名為 %0 的類型'
# 'no type named %0 in %1; did you mean %select{|simply }2%3?'
H014C7B262D03: '在 %1 中未找到名為 %0 的類型; 是否 %select{|僅}2指 %3?'
# "no type named 'type' in %0; 'enable_if' cannot be used to disable this declaration"
H03B3775679FC: "在 %0 中未找到名為 'type' 的類型; 'enable_if' 無法用來禁用此宣告"
# 'no type or protocol named %0'
HFF0D89AB2752: '未找到名為 %0 的類型或協定'
# "no valid clauses specified in OpenACC 'declare' directive"
H136795D57206: "OpenACC 'declare' 指令中未指定有效的子句"
# 'no variable template matches specialization; did you mean to use %0 as function template instead?'
H702E78FBEC31: '未找到匹配的變數範本專門化; 是否應改用 %0 作為函數範本?'
# 'no variable template matches%select{| partial}0 specialization'
H0903C7695A91: '未找到匹配的 %select{|部分}0專門化變數範本'
# 'no viable candidate for explicit instantiation of %0'
HAEBC7520AFB0: '無法明確實體化 %0 的可行候選'
# 'no viable constructor %select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1'
HC9B75808C9E9: '無法找到合適的建構函數 %select{複製變數|複製參數|初始化模板參數|返回物件|初始化語句運算式結果|發送物件|複製成員子物件|複製陣列元素|建立物件|複製暫時物件|初始化基底子物件|初始化向量元素|捕捉值}0 的類型 %1'
# 'no viable constructor %select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1; C++98 requires a copy constructor when binding a reference to a temporary'
HBD2DEF3D3EA1: '無法找到可用的構造函數 %select{複製變數|複製參數|初始化範型參數|從物件傳回|初始化語句運算式結果|傳擲物件|複製成員子物件|複製陣列元素|分配物件|複製暫存器|初始化基類子物件|初始化向量元素|捕獲值}0 類型 %1；C++98 在將參考綁定到暫存器時需要複製構造函數'
# 'no viable constructor or deduction guide for deduction of template arguments of %0'
HECA595B57B5C: '無法找到可用的構造函數或範型參數推論指引以推論 %0 的範型參數'
# 'no viable conversion%diff{ from $ to incomplete type $|}0,1'
H0DDC152C267D: '無法進行轉換%diff{從$轉換為不完整類型$|}0,1'
# 'no viable conversion%select{%diff{ from $ to $|}1,2|%diff{ from returned value of type $ to function return type $|}1,2}0'
H742AD0829398: '無法進行轉換 %select{%diff{從$轉換為$|}1,2|%diff{從返回值類型$轉換為函數返回類型$|}1,2}0'
# 'no viable destructor found for class %0'
HE8AA8B1D9E66: '類別 %0 沒有合適的析構函數'
# "no viable overloaded '%0'"
H85F4D23A3BAD: "沒有合適的超載運算子 '%0'"
# 'no viable overloaded operator[] for type %0'
H2EF71DBEE631: '類型 %0 沒有合適的超載運算子 []'
# 'no visible @interface for %0 declares the selector %1'
HF35FE2A8D9B7: '類別 %0 沒有可見的 @interface 宣告選擇器 %1'
# 'noexcept expressions are incompatible with C++98'
H770DCD42AD88: 'noexcept 表達式與C++98不相容'
# 'noexcept specifications are incompatible with C++98'
HCDFCAD5EB464: 'noexcept指定與C++98不相容'
# 'non-ASM statement in naked function is not supported'
H13FAFC759C77: '在 naked 函數中使用非ASM 語句不受支援'
# 'non-class friend type %0 is a C++11 extension'
HD60A5C8C49AC: '非類友元類型 %0 是C++11擴充功能'
# 'non-class friend type %0 is incompatible with C++98'
H4D0DB388513A: '非類友元類型 %0 與C++98不相容'
# 'non-const static data member must be initialized out of line'
HFA5187DD3DCB: '非const的static資料成員必須在外部初始化'
# 'non-constant static local variable in inline function may be different in different files'
HDAC621E8867A: '內聯函數中的非常量static局部變數在不同檔案中可能不同'
# 'non-constant-expression cannot be narrowed from type %0 to %1 in initializer list'
H48217DABAA7D: '非常量運算式無法從類型 %0 窄化轉換為 %1 在初始化清單中'
# 'non-constant-expression cannot be narrowed from type %0 to %1 in initializer list in C++11'
H996365ACA997: '非常量運算式無法從類型 %0 窄化轉換為 %1 在初始化清單中（C++11）'
# 'non-consteval function %0 cannot override a consteval function'
H3BE45C7BF2C1: '非consteval函數 %0 無法覆寫consteval函數'
# 'non-constexpr comparison function declared here'
H6CDFA8CCBBD8: '在此處宣告的非constexpr比較函數'
# 'non-constexpr comparison function would be used to compare %select{|member %1|base class %1}0'
HFFB83E06B051: '非constexpr比較函數將被用來比較 %select{|成員 %1|基類 %1}0'
# 'non-deducible template parameter %0'
HD419F387C770: '無法推論的範型參數 %0'
# 'non-default #pragma pack value changes the alignment of struct or union members in the included file'
H2C52662649BE: '非預設的 #pragma pack 值會改變包含檔案中結構或共用體成員的對齊方式'
# "non-default visibility cannot be applied to 'dllimport' declaration"
H2A9EC7D43705: "無法將非預設的可見性套用到 'dllimport' 声明"
# 'non-defining declaration of enumeration with a fixed underlying type is only permitted as a standalone declaration%select{|; missing list of enumerators?}0'
H4D151B6B2BF9: '具有固定基礎類型的枚舉的非定義宣告只能作為獨立宣告使用 %select{|; 缺少枚舉器列表？}0'
# 'non-deleted function %0 cannot override a deleted function'
H2F21A881D5B2: '非已刪除的函數 %0 不能覆寫已刪除的函數'
# 'non-extern declaration of %0 follows extern declaration'
H7E386503A2B6: '對 %0 的非extern宣告跟在extern宣告之後'
# 'non-friend class member %0 cannot have a qualified name'
H01BBFAF999D6: '非友元類別成員 %0 不可以有合格名稱'
# 'non-inline external definitions are not permitted in C++ header units'
H0E67412E5EDC: 'C++ 頭目錄單元中不允许有非-inline的外部定義'
# 'non-inline namespace cannot be reopened as inline'
H43CE8E47A824: '非-inline的命名空間無法重新開啟為inline'
# 'non-literal type %0 cannot be used in a constant expression'
HFCBBB3F7D771: '非字面型別 %0 無法用於常數運算式'
# 'non-local lambda expression cannot have a capture-default'
H2B075ACEF012: '非局部的lambda運算式不能有捕獲預設值'
# 'non-local variable with sizeless type %0'
H92600D86A0C5: '型別 %0 的非局部變數沒有大小'
# 'non-namespace scope %0 cannot have a literal operator member'
H266845A5FE4C: '非命名空間作用域 %0 不可以有字面運算子成員'
# 'non-object type %0 is not assignable'
H8FB33F67F675: '非物件型別 %0 不可指派'
# "non-pointer argument to '__builtin_assume_aligned' is not allowed"
HD960D71E3301: "傳遞給 '__builtin_assume_aligned' 的非指標參數是不允許的"
# 'non-pointer operand type %0 incompatible with %select{NULL|nullptr}1'
H90B6AFB986DF: '與 %select{NULL|nullptr}1 不兼容的非指標操作元類型 %0'
# "non-portable path to file '%0'; specified path differs in case from file name on disk"
H43FE55A52897: "與磁碟上的檔案名稱大小寫不同，指定的非移植性路徑 '%0'"
# 'non-predefined allocator must have traits specified'
HFFB74BA64E52: '非預定義配置器必須指定特性'
# 'non-static data member %0 cannot be declared as a template'
HEE38B2049618: '非靜態數據成員 %0 不可宣告為範型'
# 'non-static data member cannot be constexpr%select{; did you intend to make it %select{const|static}0?|}1'
H19D13A6885F4: '非靜態數據成員不能是 constexpr%select{；您是否期望將其宣告為 %select{const|static}0？|}1'
# 'non-static data member defined out-of-line'
HC4D58BAF82DF: '非靜態數據成員以非-inline 方式定義'
# 'non-static declaration of %0 follows static declaration'
H25169BF9CE09: '非靜態宣告 %0 跟隨靜態宣告'
# 'non-static member %0 found in multiple base-class subobjects of type %1:%2'
H1D1EE8E2CCD9: '在基類子對象類型 %1:%2 中找到多個非靜態成員 %0'
# 'non-template declaration found by name lookup'
HF380F2D95EAA: '名稱查找找到非常式宣告'
# 'non-template friend declaration with a requires clause must be a definition'
H95DF301285CD: '帶有 requires 子句的非範型友元宣告必須是定義'
# 'non-template literal operator must have one or two parameters'
HAB8D25BD0598: '非範型文字運算符必須有一個或兩個參數'
# 'non-templated declaration is here'
H5E1276462F94: '非範型宣告在此處定義'
# 'non-templated function cannot have a requires clause'
H82190871139C: '非範型函數不能有 requires 子句'
# 'non-thread-local declaration of %0 follows thread-local declaration'
H015D893F1487: '非線程局部宣告 %0 跟隨線程局部宣告'
# 'non-trivial destruction of lifetime-extended temporary with type %0 used in the result of a constant expression is not yet supported'
HD2339C077B90: '使用具有非平凡析構函數類型 %0 的延伸生存期暫存值作為常量運算式的結果尚未支援'
# 'non-trivial destruction of type %0 in a constant expression is not supported'
HE2CD4D9E53E2: '在常量運算式中使用具有非平凡析構函數的類型 %0 尚未支援'
# 'non-trivially copyable type %0 cannot be used in a boxed expression'
HB2216F42639D: '非可輕鬆複製的類型 %0 不可在盒裝運算式中使用'
# 'non-type declaration found by destructor name lookup'
HB02DCE8A7FF1: '析構函數名稱搜尋找到非類型宣告'
# "non-type template argument '%0' is invalid"
H2399CD2B5610: "非類型模板參數 '%0' 無效"
# 'non-type template argument containing a dereference operation is a Microsoft extension'
HD4EF29A775AB: '包含解引用運算的非常式模板參數值是Microsoft擴充功能'
# 'non-type template argument does not refer to an object or function'
HE77C0A012513: '非常式模板參數值未引用任何物件或函數'
# 'non-type template argument does not refer to any declaration'
HB25807F91411: '非常式模板參數值未引用任何宣告'
# 'non-type template argument for template parameter of pointer type %0 must have its address taken'
H8D4CDD97C49D: '指標類型 %0 的模板參數的非常式模板參數值必須取得其位址'
# 'non-type template argument is not a pointer to member constant'
HDC21F0C558EB: '非常式模板參數值不是成員常數指標'
# 'non-type template argument of reference type %0 is not an object'
H50574CDA0DAD: '類型 %0 的參考類型非常式模板參數值不是物件'
# 'non-type template argument of type %0 cannot be converted to a value of type %1'
HDF1742D8033F: '類型 %0 的非常式模板參數值無法轉換為類型 %1 的值'
# 'non-type template argument of type %0 is not a constant expression'
H075FB8D7A63A: '類型 %0 的非常式模板參數值不是常量運算式'
# 'non-type template argument of type %0 is not an integral constant expression'
HE2EA0C6B3858: '類型 %0 的非常式模板參數值不是整數型別常量運算式'
# 'non-type template argument of type %0 must have an integral or enumeration type'
H06D35F5E0195: '非常式模板參數值的類型 %0 必須是整數或枚舉型別'
# 'non-type template argument referring to %select{function|object}0 %1 with internal linkage is a C++11 extension'
HEFF3308ED7FE: '引用具有內部連結性%select{函數|物件}0 %1 的非常式模板參數值是C++11擴充功能'
# 'non-type template argument referring to %select{function|object}0 %1 with internal linkage is incompatible with C++98'
H2F0100862103: '引用具有內部連結性%select{函數|物件}0 %1 的非常式模板參數值與C++98不相容'
# 'non-type template argument refers here'
HA953EF53E7DD: '非常式模板參數值指向這裡'
# 'non-type template argument refers to %select{function|object}0 %1 that does not have linkage'
H600BCDFEE43D: '非常式模板參數值引用這裡的%select{函數|物件}0 %1，該實體無連結性'
# 'non-type template argument refers to %select{function|object}0 here'
H9ED37B3451CC: '非常式模板參數值指向這裡的%select{函數|物件}0'
# 'non-type template argument refers to non-static data member %0'
H2465AB2AA5B5: '非常式模板參數值指向非靜態資料成員 %0'
# 'non-type template argument refers to non-static member function %0'
H6A037F433017: '非常式模板參數值指向非靜態成員函數 %0'
# "non-type template argument refers to subobject '%0'"
HD30CEA1C7504: "非常式模板參數值指向子物件 '%0'"
# 'non-type template argument refers to thread-local object'
H1DFBA6B66CEF: '非類型模板參數引用執行緒局部物件'
# 'non-type template argument specializes a template parameter with dependent type %0'
H77D31AA373EF: '非類型模板參數專門化了具有依賴類型 %0 的模板參數'
# "non-type template argument value '%0' truncated to '%1' for template parameter of type %2"
H5466021B086C: "非類型模板參數的值 '%0' 被截斷為 '%1'，因模板參數類型為 %2"
# "non-type template argument with value '%0' converted to '%1' for unsigned template parameter of type %2"
H4635C03C8C36: "非類型模板參數的值 '%0' 轉換為 '%1'，因無符號模板參數類型為 %2"
# 'non-type template parameter %0 with type %1 has incompatible initializer of type %2'
H36B37E5D284B: '非類型模板參數 %0 的類型 %1 具有不相容的初始值設定值類型 %2'
# 'non-type template parameter declared with incompatible types in different translation units (%0 vs. %1)'
H349C88186DB6: '不同翻譯單位中非類型模板參數宣告的類型不一致（%0 與 %1）'
# 'non-type template parameter has incomplete type %0'
H67B9597CFD9A: '非類型模板參數具有不完整類型 %0'
# 'non-type template parameter has non-literal type %0'
H271C87C2E376: '非類型模板參數具有非文字類型 %0'
# 'non-type template parameter has rvalue reference type %0'
H8258CBB4119D: '非類型模板參數具有右值引用類型 %0'
# 'non-type template parameter of reference type %diff{$ cannot bind to template argument of type $|cannot bind to template of incompatible argument type}0,1'
H4F089D7DCBD1: '非類型模板參數的類型 %diff{$ 無法綁定到類型 $ 的模板參數|無法綁定到不相容參數類型的模板}1,0'
# 'non-type template parameter of type %0 is incompatible with C++ standards before C++20'
H76F7D38734C2: 'C++20 之前的標準不支援類型 %0 的非類型模板參數'
# 'non-type template parameter of variably modified type %0'
HDB7696E83E21: '非類型模板參數具有可變長度修飾的類型 %0'
# 'non-type template parameters declared with %0 are incompatible with C++ standards before C++17'
H4034BC5F4762: 'C++17 之前的標準不支援以 %0 宣告的非類型模板參數'
# 'non-usual %0 declared here'
H9B44D0E82E0B: '這裡宣告了非常規 %0'
# "non-variable declaration in 'for' loop"
HE2801E92B8D8: "'for' 迴圈中的非變數宣告"
# "non-variable declaration in 'for' loop is a C23 extension"
H861D242B28D2: "'for' 迴圈中的非變數宣告是 C23 擴展"
# "non-variable declaration in 'for' loop is incompatible with C standards before C23"
H1A5C6F3C6A58: "'for' 迴圈中的非變數宣告與 C23 之前標準不相容"
# "non-virtual member function marked '%0' hides virtual member %select{function|functions}1"
H6156F12DC3F9: '非虛函數 %0 掩蓋了虛成員 %select{函數|函數們}1'
# 'non-void %select{constexpr|consteval}1 function %0 should return a value'
HCF55E17BA989: '非 void %select{constexpr|consteval}1 函數 %0 應該回傳值'
# 'non-void %select{function|block|lambda|coroutine}0 does not return a value%select{| in all control paths}1'
H75EE618D1AA4: '非void的%select{函數|區塊|lambda|coroutine}0 未回傳值 %select{|在所有控制路徑中}1'
# 'non-void %select{function|method}1 %0 should return a value'
HEE95067001EB: '非void的%select{函數|方法}1 %0 應回傳值'
# 'non-void block should return a value'
H66594B013217: '非void的區塊應回傳值'
# "nonnull %select{function call|parameter}0 '%1' will evaluate to 'true' on first encounter"
H925BCFBBE426: "非空%select{函數呼叫|參數}0 '%1' 在首次遇到時將評估為 'true'"
# 'not a Doxygen trailing comment'
HB02E938B9DEC: '不是Doxygen的尾注註解'
# "not currently inside '#pragma clang arc_cf_code_audited'"
HD79C4D940185: "目前不在 '#pragma clang arc_cf_code_audited' 指令內"
# "not currently inside '#pragma clang assume_nonnull'"
HF77D5E6601B3: "目前不在 '#pragma clang assume_nonnull' 指令內"
# "not currently inside '#pragma unsafe_buffer_usage'"
H658512A345D7: "目前不在 '#pragma unsafe_buffer_usage' 指令內"
# 'not enough variable arguments in %0 declaration to fit a sentinel'
H9930B56495BC: '在 %0 宣告中可變參數不足以適配哨兵'
# 'not packing field %0 as it is non-POD for the purposes of layout'
H7FBA81FDAA18: '不打包欄位 %0，因為其在布局用途上為非POD類型'
# 'not-yet-instantiated member is declared here'
HACFD1F41F676: '尚未實例化的成員在此宣告'
# 'null character ignored'
H6B4B3A47C8AC: '空值字元被忽略'
# 'null character(s) preserved in %select{char|string}0 literal'
H062C86F6116B: '%select{char|string}0 字面值中保留空值字元(s)'
# 'null non-type template argument must be cast to template parameter type %0'
HDDA635486EF3: '空值的非類型模板參數必須轉換為模板參數類型 %0'
# 'null non-type template argument of type %0 does not match template parameter of type %1'
HCF293B48A07C: '類型 %0 的空值非類型模板參數與類型 %1 的模板參數不相符'
# 'null passed to a callee that requires a non-null argument'
H5F7D096FCE08: '將空值傳遞給需要非空參數的呼叫目標'
# 'null returned from %select{function|method}0 that requires a non-null return value'
HEA9F26CD4560: '從需要非空回傳值的%select{函數|方法}0回傳空值'
# 'nullability keyword %0 cannot be applied to multi-level pointer type %1'
H9F63F0EFF7CC: 'nullability關鍵字 %0 無法應用於多層指標類型 %1'
# 'nullability specifier %0 cannot be applied to non-pointer type %1'
HA1F5D87BE3DF: 'nullability指定詞 %0 無法應用於非指標類型 %1'
# 'nullability specifier %0 cannot be applied to non-pointer type %1; did you mean to apply the specifier to the %select{pointer|block pointer|member pointer|function pointer|member function pointer}2?'
H3E269F064E84: '空值規範符 %0 不能應用於非指標類型 %1；您是否想要將規範符應用於 %select{指標|區塊指標|成員指標|函數指標|成員函數指標}2？'
# 'nullability specifier %0 conflicts with existing specifier %1'
H4421DC48369F: '空值規範符 %0 與現有規範符 %1 冲突'
# 'number of elements must be either one or match the size of the vector'
H2A474F4275FA: '元素數目必須為 1 或與向量大小一致'
# 'number of entries per line (default 256)'
H7D63977C73C8: '每行的條目數（預設值 256）'
# 'number of functions to display when printing the top largest differences in function activity'
H4322F776E088: '要列印其聚集剖面品質統計的熱點函數數目'
# 'number of hottest functions to print aggregated profile quality stats of.'
H5B5E76B4AA88: '要列印其聚集剖面品質統計的熱點函數數目'
# 'number of tasks to be created per thread'
HE2569802814C: '每個執行緒要創建的任務數'
# 'number of threads'
HE591548912FE: '執行緒數'
# 'numeric literal with user-defined suffix cannot be used here'
H6D6640DAD12D: '具有使用者定義後綴的數值字面量在此處無法使用'
# "nvcc does not allow '__%0__' to appear after the parameter list in lambdas"
H052A23E5C9DE: "nvcc 不允許在 lambda 的參數清單後使用 '__%0__'"
# 'nvptx-arch options'
H195E97C080C6: 'nvptx-arch 選項'
# 'obj2yaml Options'
HDEB46CD09A6E: 'obj2yaml 選項'
# 'objc_precise_lifetime is not meaningful for %select{__unsafe_unretained|__autoreleasing}0 objects'
H3B4A7538E1D6: 'objc_precise_lifetime 對於 %select{__unsafe_unretained|__autoreleasing}0 物件無意義'
# 'objc_precise_lifetime only applies to retainable types; type here is %0'
HCB888D9DBEF6: 'objc_precise_lifetime 只適用於可保留類型；這裡的類型是 %0'
# 'objc_root_class attribute may only be specified on a root class declaration'
H8B7E866F5F47: 'objc_root_class 屬性只能在根類別宣告中指定'
# 'object backing %select{|the pointer }0%1 will be destroyed at the end of the full-expression'
H4CCEF5B24A9C: '%select{|指標 }0%1 所支援的物件在全表達式結束時將被銷毀'
# 'object backing the pointer %0 will be destroyed at the end of the full-expression'
H4314D747B320: '指標 %0 所支援的物件在全表達式結束時將被銷毀'
# 'object backing the pointer will be destroyed at the end of the full-expression'
HCBDFA4406EFB: '該指標所支援的物件在全表達式結束時將被銷毀'
# 'object expression of non-scalar type %0 cannot be used in a pseudo-destructor expression'
H8E297F831414: '非標量類型 %0 的物件表達式無法用於偽析構運算式'
# "object format flags cannot be used with '%0' conversion specifier"
HAF558B2410E4: "物件格式旗標無法與 '%0' 轉換指定項一起使用"
# 'object of type %0 cannot be %select{constructed|copied|moved|assigned|assigned|destroyed}1 because its %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}1 is implicitly deleted'
H828A944AA309: '類型 %0 的物件無法被%select{建構|複製|移動|指定|指定|銷毀}1，因為其%select{預設建構函數|拷貝建構函數|移動建構函數|拷貝指定運算子|移動指定運算子|銷毀函數}1已被隱式刪除'
# 'object of type %0 cannot be compared because its %1 is implicitly deleted'
H4465935A9154: '類型 %0 的物件無法進行比較，因為其 %1 被隱式刪除'
# 'object of type %0 cannot be placed in read-only memory'
HD27A532EA3C9: '類型 %0 的物件無法存放在只讀記憶體中'
# 'object of type %0 is not compatible with %select{array element type|dictionary key type|dictionary value type}1 %2'
HBDF524B06F4F: '類型 %0 的物件與%select{陣列元素類型|字典鍵類型|字典值類型}1 %2 不相容'
# "object whose reference is captured by '%0' will be destroyed at the end of the full-expression"
H1329A74CEAA1: "被 '%0' 捕獲之參考的物件將在完整運算式結束時被銷毀"
# 'object whose reference is captured will be destroyed at the end of the full-expression'
H04404B93E557: '被捕獲之參考的物件將在完整運算式結束時被銷毀'
# 'octal integer literals are a C2y extension'
HCB95FC190C42: '八進位整數字面量是 C2y 的擴充功能'
# 'octal integer literals are a Clang extension'
H0A7A0AD8FA23: '八進位整數字面量是 Clang 的擴充功能'
# 'octal integer literals are incompatible with standards before C2y'
HFF58B98B1092: '八進位整數字面量與 C2y 之前的標準不相容'
# "octal literals without a '0o' prefix are deprecated"
H297C91C7799F: '未使用 "0o" 前綴的八進位字面量已被棄用'
# 'offset of asan shadow mapping [EXPERIMENTAL]'
HB87160E3C269: 'ASan陰影映射的偏移 [實驗性]'
# 'offset of on non-POD type %0'
H3798D618C09F: '非 POD 類型 %0 的 offsetof'
# 'offset of on non-standard-layout type %0'
H1C1DF95C948D: '非標準布局類型 %0 的 offsetof'
# 'offset-based plaintext format'
H4A173EEFA114: '基於偏移的純文字格式'
# 'offsetof of incomplete type %0'
H01B4054FE86A: '不完整類型 %0 的 offsetof'
# 'offsetof requires array type, %0 invalid'
H72E546984F9B: 'offsetof 需要陣列類型，%0 無效'
# 'offsetof requires struct, union, or class type, %0 invalid'
H1EED7971DB36: 'offsetof 需要 struct、union 或 class 類型，%0 無效'
# "old syntax '%0' on '%1' clause was deprecated, use new syntax '%2'"
H62AFC50986BB: '在 "%1" 子句上使用舊語法 "%0" 已被棄用，請改用新語法 "%2"'
# 'omit the namespace to add attributes to the most-recently pushed attribute group'
H33451023019A: '若要將屬性新增至最近新增的屬性群組，請省略命名空間'
# 'omitting the parameter name in a function definition is a C23 extension'
H239CD59B1E97: '在函數定義中省略參數名稱是C23擴充功能'
# 'on M-profile architectures %0 attribute is not supported on targets missing %1; specify an appropriate -march= or -mcpu='
HF63DAE65A9BA: '在M型態架構上，若目標缺少 %1，則 %0 屬性不受支援；請指定適當的 -march= 或 -mcpu='
# 'one cluster per opcode'
H571A5AC320D2: '每條機器碼指令對應一個群組'
# "one of 'for', 'parallel', 'sections' or 'taskgroup' is expected"
HA318D6E65846: "必須是 'for'、'parallel'、'sections' 或 'taskgroup' 其中之一"
# 'one possibility'
HF5AE3D1F7A2D: '一個可能選項'
# "only %select{'omp_priv' or 'omp_orig'|'omp_in' or 'omp_out'}0 variables are allowed in %select{initializer|combiner}0 expression"
HBFBFE733ACC9: "在%select{初始式|組合式}0 表達式中，僅允許 %select{'omp_priv' 或 'omp_orig'|'omp_in' 或 'omp_out'}0 變數"
# "only '*' can be exported from an inferred submodule"
HB1E7869E1AA8: "只能從推論的子模組中匯出 '*'"
# "only 'device_type(any)' clause is allowed with indirect clause"
H60FE040D9778: "僅允許在間接子句中使用 'device_type(any)' 子句"
# "only 'unavailable' and 'deprecated' are supported for Swift availability"
H711C14834055: "Swift 相容性僅支援 'unavailable' 和 'deprecated'"
# 'only a single match extension allowed per OpenMP context selector'
H54ED4E173E0C: '每個OpenMP語境選擇器僅允許單一匹配擴充功能'
# 'only allow matching call instructions if the name and type signature match.'
HA22B2A05D450: '僅允許在名稱及類型簽章相符時，匹配呼叫指令'
# 'only apply branch boundary alignment in hot code'
H486A9C1A43ED: '僅在熱點代碼中套用分支邊界對齊'
# 'only constructors take base initializers'
HDB605C258726: '僅建構函數可使用基底初始式'
# 'only dump ids with the specified hexadecimal type index'
H5475CDF64D0B: '僅顯示指定十六進位類型索引的識別碼'
# 'only dump symbol record with the specified symbol offset'
H990FE7E1637C: '僅顯示指定符號偏移量的符號紀錄'
# 'only dump types with the specified hexadecimal type index'
HF6EF25D1A99D: '僅顯示指定十六進位類型索引的類型'
# 'only enumeration types have underlying types'
H35007289C6D1: '僅枚舉類型具有底層類型'
# 'only function and template parameters can be parameter packs'
HE058E90890AE: '僅函數和範本參數可作為參數包'
# 'only functions can have deleted definitions'
H0BDC0C1C20D8: '只有函數可以具有刪除定義'
# 'only insert instrumentation on hot functions (needs profile, default: false)'
H6921A5326E9E: '僅在熱函數中插入插樁（需要剖析，預設值：false）'
# "only loop iteration variables are allowed in 'lastprivate' clause in 'omp %0' directives"
H93109DDAC062: "在 'omp %0' 指令的 'lastprivate' 子句中僅允許循環迭代變數"
# "only loop iteration variables are allowed in 'linear' clause in distribute directives"
HB4FBF6AB0B0A: "在 distribute 指令的 'linear' 子句中僅允許循環迭代變數"
# 'only one %0 clause can appear on a requires directive in a single translation unit'
H67EC4B23D848: '在單一翻譯單位的 requires 指令中，%0 子句只能出現一次'
# 'only one element declaration is allowed'
HB7E0C8F27CB5: '元素宣告只能有一個'
# "only one expression allowed in '%0' clause"
H200100A1AF70: "'%0' 子句中只能有一個運算式"
# 'only one offload target is supported'
H36578B307452: '僅支援單一卸載目標'
# "only one parameter on 'main' declaration"
H09469DD0E50E: "'main' 宣告只能有一個參數"
# 'only perform sctc when branch direction is preserved'
HF40E26771C18: '僅在分支方向保留時執行 sctc'
# 'only promote call targets eligible for inlining'
H48B4D984BB43: '僅提升符合內聯條件的調用目標'
# 'only recurse to a depth of N when displaying children of a symbol record.'
H9AF5A4C86831: '顯示符號記錄的子項目時，最多遞迴顯示 N 層深度。'
# 'only recurse to a depth of N when displaying parents of a symbol record.'
HFD73DE6E2DEF: '顯示符號記錄的父項目時，最多遞迴顯示 N 層深度。'
# 'only rename the instructions in the function'
H255C85A34C1B: '僅重新命名函數中的指示項'
# 'only replace exit value when it is an unused induction variable in the loop and has cheap replacement cost'
H4F514B4EF001: '僅當迴圈中的迭代變數未被使用且替換成本低廉時，才替換退出值'
# 'only replace exit value when the cost is cheap'
H8C5F857AAD22: '僅在替換成本低廉時才替換退出值'
# 'only replace exit values when loop def likely dead'
H1F90A0F5DC05: '僅在迴圈定義很可能未被使用時替換退出值'
# 'only show the top N results'
H31C65CA913F9: '僅顯示頂部 N 個結果'
# 'only special member functions %select{|and comparison operators }0may be defaulted'
H7676F4E831FD: '僅特殊成員函數 %select{|和比較運算子 }0可以被預設'
# 'only submodules and framework modules may be inferred with wildcard syntax'
HB41F304027AC: '只能使用通配符語法推斷子模組和框架模組'
# 'only the first dimension of an allocated array may have dynamic size'
HCC4AF93D4D25: '已分配陣列僅第一維度可以具有動態大小'
# 'only top-level modules can be re-exported as public'
H35599F0992E5: '僅頂層模組可以重新導出為公開模組'
# 'only use samples from process with specified PID'
HE4657121A5A3: '僅使用指定 PID 的進程的樣本'
# "only variable %0 is allowed in map clauses of this 'omp declare mapper' directive"
HCD77D6699FCF: "此 'omp declare mapper' 指令的 map 子句中僅允許變數 %0"
# "only variables can be arguments to '#pragma unused'"
H454069F49B2C: "只有變數可以用作 '#pragma unused' 的參數"
# "only virtual member functions can be marked '%0'"
H88BCFFA5846F: "只能標記虛成員函數為 '%0'"
# 'only zero-length WebAssembly tables are currently supported'
H834ECF2F9D5B: '目前僅支援長度為零的 WebAssembly 表格'
# 'opcode to measure, by index, or -1 to measure all opcodes'
H04C71CF551B6: '要測量的指令碼（通過索引），或輸入 -1 以測量所有指令碼'
# "operand argument to %select{overflow builtin|checked integer operation}0 must be an integer type %select{|other than plain 'char', 'bool', bit-precise, or an enumeration }0(%1 invalid)"
H232C02FD2560: "傳遞給 %select{溢位內建函數|帶檢查的整數運算}0 的操作元參數必須是整數類型 %select{|（不包括普通的 'char'、'bool'、精確位元或列舉類型）}0（%1 無效）"
# 'operand of ? changes signedness: %0 to %1'
H034F94202BD7: '? 運算元的運算元符號位變動：%0 至 %1'
# 'operand of type %0 cannot be cast to a pointer type'
H39550A20AC28: '類型 %0 的運算元無法轉換為指標類型'
# 'operand of type %0 where arithmetic or pointer type is required'
H73F559724DF8: '需要算術或指標類型，但類型 %0 的運算元不符合'
# 'operands to conditional of types%diff{ $ and $|}0,1 are incompatible in ARC mode'
HA7936DDDD636: '在 ARC 模式下，條件運算元的類型%diff{ $ 和 $|}0,1 不相容'
# "operator '%0' has lower precedence than '%1'; '%1' will be evaluated first"
H7655BF3550EE: "運算元 '%0' 的優先順序低於 '%1'；'%1' 將會先被評估"
# "operator '?:' has lower precedence than '%0'; '%0' will be evaluated first"
HFCE2B46187B8: "運算元 '?:' 的優先順序低於 '%0'；'%0' 將會先被評估"
# 'operators in fold expression must be the same'
H1479CC2CDE54: '摺疊表達式中的運算元必須相同'
# 'opt-like flags'
H2AE16EED276B: '類似優化選項的旗標'
# "optimization flag '%0' is not supported"
HED6E92EF31B3: "優化選項 '%0' 不受支援"
# "optimization flag '%0' is not supported for target '%1'"
H7BA15DDB49BE: "優化選項 '%0' 不支援目標 '%1'"
# "optimization level '%0' is not supported; using '%1%2' instead"
H6D18AF90D4BB: "不支援優化層級 '%0'；改用 '%1%2'"
# 'optimize PLT calls (requires linking with -znow)'
H1C6C02B1FC92: '優化PLT呼叫（需要使用-znow連結）'
# 'optimize all PLT calls'
H729D15249489: '優化所有PLT呼叫'
# 'optimize executed (hot) PLT calls'
HB328EE466E4E: '優化已執行（熱）PLT呼叫'
# 'optimize functions with jump tables'
H1F9747FD82E4: '優化具有跳躍表的函數'
# 'optimize hottest calls until at least this percentage of all indirect calls frequency is covered. 0 = all callsites'
H770180548F4F: '優化直到涵蓋所有間接呼叫頻率至少達此百分比的最熱呼叫。0 = 所有呼叫點'
# 'optimize stack frame accesses'
H72DEC23B9CC3: '優化堆疊框架存取'
# "option '%0' cannot be specified on this target"
H1BE1A4C28B5B: "選項 '%0' 無法在此目標上指定"
# "option '%0' cannot be specified with '%1'"
H70F63315B132: "選項 '%0' 無法與 '%1' 一同指定"
# "option '%0' cannot be specified with '%1' for the %2 sub-architecture"
HBBDD552F5F1A: "選項 '%0' 無法在 %2 子架構與 '%1' 一同指定"
# "option '%0' cannot be specified without '%1'"
H583C3C9DA6E7: "選項 '%0' 需要與 '%1' 一同指定"
# "option '%0' requires input to be LLVM bitcode"
HA5B4E61775E4: "選項 '%0' 需要輸入為LLVM位元碼"
# "option '%0' was ignored by the %1 toolchain, using '-fPIC'"
H22B2E1051C0B: "選項 '%0' 被 %1 工具鏈忽略，改用 '-fPIC'"
# "option '-MG' requires '-M' or '-MM'"
HCCC4BA63CA80: "選項 '-MG' 需要搭配 '-M' 或 '-MM'"
# "option '-ffine-grained-bitfield-accesses' cannot be enabled together with a sanitizer; flag ignored"
H4FD110105D82: "選項 '-ffine-grained-bitfield-accesses' 不能與 sanitizer 一同啟用；旗標被忽略"
# "option '-fmodule-output' cannot be used with multiple arch options"
H67AC45523A0C: "選項 '-fmodule-output' 無法與多個架構選項一同使用"
# "option '-fmodules-validate-once-per-build-session' requires '-fbuild-session-timestamp=<seconds since Epoch>' or '-fbuild-session-file=<file>'"
H5685B0FE4474: "選項 '-fmodules-validate-once-per-build-session' 需要 '-fbuild-session-timestamp=<自 Epoch 秒數>' 或 '-fbuild-session-file=<檔案>'"
# "option 'ffp-eval-method' cannot be used with option %select{'fapprox-func'|'mreassociate'|'freciprocal'}0"
H1D986A148023: "選項 'ffp-eval-method' 不能與選項 %select{'fapprox-func'|'mreassociate'|'freciprocal'}0 一起使用"
# 'options %0 and %1 are set to different values'
H15DAE6B37541: '選項 %0 和 %1 被設置為不同的值'
# 'or because setter is declared here, but no getter method %0 is found'
H9306685E39B6: '或因為 setter 這裡被宣告，但未找到對應的 getter 方法 %0'
# "or insert whitespace before ':' to use %0 as parameter name and have an empty entry in the selector"
H09DF98AB0B6F: '或在冒號前插入空白，將 %0 作為參數名稱，並在選擇器中保留空值'
# 'order by execution count'
H7EA3A097FEC2: '按執行次數排序'
# 'ordered compare requires two args of floating point type%diff{ ($ and $)|}0,1'
HC6DBD7D802C7: '有序比較需要兩個浮點類型參數%diff{ ($ 和 $)|}1,0'
# 'ordered comparison between pointer and integer (%0 and %1)'
HCE8E7EA44A15: '指標與整數 (%0 和 %1) 之間的有序比較'
# 'ordered comparison between pointer and zero (%0 and %1)'
H08DE668CB79E: '指標與零 (%0 和 %1) 之間的有序比較'
# 'ordered comparison between pointer and zero (%0 and %1) is an extension'
HEFA21113E58A: '指標與零 (%0 和 %1) 之間的有序比較是擴展功能'
# 'ordered comparison of function pointers (%0 and %1)'
H6623D571A716: '函數指標 (%0 和 %1) 之間的有序比較'
# 'original arguments in round-trip: %0'
H88D576AD9392: '往返測試的原始參數：%0'
# 'original arguments parse failed, then succeeded in round-trip'
H4354C394D0BE: '原始參數解析失敗，但往返測試成功'
# 'original storage of expression in data environment is shared but data environment do not fully contain mapped expression storage'
H8588EE9D0D77: '資料環境中表達式的原始存儲是共享的，但資料環境未完整包含映射表達式存儲'
# "orphaned 'omp %0' directives are prohibited; perhaps you forget to enclose the directive into a %select{|||target |teams|for, simd, for simd, parallel for, or parallel for simd }1region?"
H09B89CE1DDFB: "孤兒 'omp %0' 指令被禁止；是否遺漏將指令包在 %select{|||target |teams|for, simd, for simd, parallel for, or parallel for simd }1 區域中？"
# "os '%0' is not supported: '%1'"
HD285B7E47AB6: "作業系統 '%0' 不支援：'%1'"
# "os_log() '%%n' format specifier is not allowed"
HA308C5A1A678: 'os_log() 的格式指定符 "%%n" 不允許使用'
# 'os_log() argument %0 is too big (%1 bytes, max %2)'
H93B7553E2DE5: 'os_log() 參數 %0 過大 (%1 bytes，最大 %2)'
# 'os_log() format argument is not a string constant'
H6ABC3AD79FAA: 'os_log() 格式參數不是字串常數'
# 'other definition of %0'
HFB23FE3FA4F8: '其他定義的 %0'
# 'out-of-line %select{declaration|definition}2 of %0 does not match any declaration in %1'
HC3CEC6EF88DD: '離線 %select{宣告|定義}2 的 %0 與 %1 內的任何宣告不匹配'
# 'out-of-line %select{declaration|definition}2 of %0 does not match any declaration in %1; did you mean %3?'
H6724D4146D60: '外部定義的%select{宣告|定義}2 %0 在 %1 中沒有對應宣告；您是指 %3 嗎？'
# 'out-of-line constructor for %0 cannot have template arguments'
H33FE02CBF6A6: '%0 的外部建構函數不能有模板參數'
# 'out-of-line declaration of a member must be a definition'
HBCC796880D79: '成員的外部宣告必須是定義'
# 'out-of-line definition of %0 from class %1 without definition'
H3397C2717560: '來自類別 %1 的 %0 外部定義未提供定義'
# 'out-of-line definition of constexpr static data member is redundant in C++17 and is deprecated'
HF4242355CFAD: 'C++17 中外部定義的 constexpr static 資料成員是多餘的，且已棄用'
# 'outline as many cold basic blocks as possible'
HA720A2B172BB: '盡可能將冷的基本區塊提出來'
# "output data (.csv) for Stoke's use"
H566F7B66D7EF: '為 Stoke 輸出的資料（.csv）'
# 'output file to write out a summary of the partitions created for each module'
H9036C41EDFF6: '輸出每個模組所創建分割的摘要文件'
# 'output file to write out the dotgraph representation of the input module'
H491BF84F04E2: '輸出輸入模組的 dotgraph 表示圖文件'
# "output file; use '-' for stdout"
H239A9905E956: '輸出文件；使用 "-" 表示標準輸出'
# 'output format'
H8D3CACC9A576: '輸出格式'
# 'output in binary'
HF1C94F4E5F08: '以二進位格式輸出'
# 'output in yaml'
HFFA9E62F70D8: '以 YAML 格式輸出'
# 'output the AST dump'
HE5094C7EDA7B: '輸出 AST 轉存'
# 'output the LLVM IR dump'
H722A785E838D: '輸出 LLVM IR 轉存'
# 'output the MLIR dump'
H5AB21662EF6D: '輸出 MLIR 轉存'
# 'output the MLIR dump after affine lowering'
H412D35179012: '在仿射降階後輸出 MLIR 轉存'
# 'output the MLIR dump after llvm lowering'
H5560C4070D86: '在 LLVM 降階後輸出 MLIR 轉存'
# 'overflow converting case value to switch condition type (%0 to %1)'
HF36747707003: '將 case 值轉換為 switch 條件類型（%0 到 %1）時溢位'
# 'overflow in expression; result is %0 with type %1'
H5FE3FC44898D: '運算式溢位；結果為 %0，類型為 %1'
# 'overlapping comparisons always evaluate to %select{false|true}0'
H9631A49EAD2B: '重叠的比较始终評估為 %select{false|true}0'
# "overload resolution selected deleted operator '%0'%select{|: %2}1"
HB844E51E83EA: "運算子重載決策選擇了已刪除的運算子 '%0'%select{|: %2}1"
# 'overloaded %0 cannot be a static member function'
HE25D37D77FD9: '重載的 %0 不能是静态成员函数'
# 'overloaded %0 cannot be variadic'
H49C83B8BBB4E: '重載的 %0 不能是可変参'
# 'overloaded %0 cannot have %select{no|a defaulted|more than one}1 parameter before C++23'
H1FC62986EC90: '重載的 %0 在C++23之前不能有 %select{没有|一个預設|超过一个}1 参数'
# 'overloaded %0 must be a %select{unary|binary|unary or binary}2 operator (has %1 parameter%s1)'
HA142B5DEA04D: '重載的 %0 必须是 %select{单目|双目|单目或双目}2 运算符（有 %1 参数%s1）'
# 'overloaded %0 must be a non-static member function'
H359B48F5CEFF: '重載的 %0 必须是非静态成员函数'
# 'overloaded %0 must have at least one parameter of class or enumeration type'
H329B9199B7C8: '重載的 %0 必须至少有一个参数是类或枚举类型'
# 'overloaded %0 with %select{no|a defaulted|more than one}1 parameter is a C++23 extension'
H9DE4D96FF9C0: '带有 %select{没有|一个預設|超过一个}1 参数的重載 %0 是C++23的扩展'
# 'overloaded operator %select{>>|<<}0 has higher precedence than comparison operator'
H3D68DF30B083: '重載的运算符 %select{>>|<<}0 的优先级高于比较运算符'
# 'overridden method is here'
H33E209C67E48: '被覆寫的方法在此處'
# 'overridden method returns an instance of its class type'
HA983C03A495A: '被覆寫的方法返回其类类型的实例'
# 'overridden virtual function is here'
HFA2BCE5F4E2A: '被覆寫的虛函數在此處'
# 'override the name of the default PROGRAM entry (may be helpful for using other runtimes)'
HDBB3DF8CB32F: '覆寫預設PROGRAM入口的名稱（可能有助於使用其他執行時間庫）'
# 'overrides DW_AT_comp_dir, and provides an alternative base location, which is used with DW_AT_dwo_name to construct a path to *.dwo files.'
HB19702484022: '覆寫 DW_AT_comp_dir，並提供替代基址，用於與 DW_AT_dwo_name 搭配構建到 *.dwo 文件的路徑。'
# "overriding '%0' option with '%1'"
H0BEA2CFA1C71: '覆寫 "%0" 選項為 "%1"'
# 'overriding currently unsupported rounding mode on this target'
HE764C7911186: '覆寫此目標上目前不支援的捨入模式'
# 'overriding currently unsupported use of floating point exceptions on this target'
H4E019EDC5E1E: '覆寫此目標上目前不支援的浮點異常使用'
# 'overriding method has mismatched ns_consumed attribute on its parameter'
H94209C3B1D29: '覆寫的方法其參數的 ns_consumed 屬性不匹配'
# 'overriding method has mismatched ns_returns_%select{not_retained|retained}0 attributes'
HFA26D6769DAD: '覆寫的方法其 ns_returns_%select{not_retained|retained}0 屬性不匹配'
# 'overriding the module target triple with %0'
H7A3B62788722: '使用 %0 覆寫模組目標三元組'
# 'overriding virtual function must specify the same code segment as its overridden function'
HD38E3F8D7591: '覆寫虛函數時必須指定與被覆寫函數相同的程式碼段'
# 'p'
H516B9783FCA5: 'p'
# 'pack declaration outside of template'
HDF7BB0B67932: '模板外部的封包宣告'
# 'pack expansion contains parameter pack %0 that has a different length (%1 vs. %select{|at least }2%3) from outer parameter packs'
H41600DB01010: '封包展開包含參數封包 %0，其長度 (%1 vs. %select{|至少 }2%3) 與外部參數封包不同'
# 'pack expansion contains parameter pack %0 that has a different length (at least %1 vs. %2) from outer parameter packs'
H477211AA8361: '封包展開包含參數封包 %0，其長度 (至少 %1 與 %2 不同) 與外部參數封包不同'
# 'pack expansion contains parameter packs %0 and %1 that have different lengths (%2 vs. %select{|at least }3%4)'
H4F8FA8F98117: '封包展開包含參數封包 %0 和 %1，其長度 (%2 vs. %select{|至少 }3%4) 不同'
# 'pack expansion does not contain any unexpanded parameter packs'
H8BAD94174D96: '封包展開不包含任何未展開的參數封包'
# 'pack expansion for initialization of member %0'
HBD2872B50273: '初始化成員 %0 的封包展開'
# 'pack expansion of using declaration is a C++17 extension'
H1BE8FC7C5774: 'using宣告的封包展開是C++17擴充功能'
# 'pack expansion used as argument for non-pack parameter of %select{alias template|concept}0'
HBF85ED181091: '在%select{別名範型|概念}0的非封包參數中使用封包展開作為參數'
# 'pack expansion using declaration is incompatible with C++ standards before C++17'
HFDB9F5A38038: '使用宣告的封包展開與C++17之前的標準不相容'
# 'pack fold expression is a C++17 extension'
H7820808CC9E4: '封包摺疊運算式是C++17擴充功能'
# 'pack fold expression is incompatible with C++ standards before C++17'
H2F52B697F3BE: '封包摺疊運算式與C++17之前的標準不相容'
# 'pack indexing is a C++2c extension'
H1086B8F449EB: '封包索引是C++2c擴充功能'
# 'pack indexing is incompatible with C++ standards before C++2c'
H9DAE09EBBEA1: '封包索引與C++2c之前的標準不相容'
# 'packed attribute is unnecessary for %0'
H08493DD022D1: '%0 不需要 packed 屬性'
# "packoffset at 'y' not match alignment %0 required by %1"
H1D68367EC4D7: "在 'y' 位置的 packoffset 與 %1 需要的對齊 %0 不符合"
# 'packoffset cannot cross register boundary'
HA00AFB61162C: 'packoffset 不得跨越寄存器邊界'
# 'packoffset overlap between %0, %1'
H8FBBA6B5715E: '%0 和 %1 之間的 packoffset 重疊'
# 'padding %select{struct|interface|class}0 %1 with %2 %select{byte|bit}3%s2 to align %4'
HB4806E10E325: '填充 %select{結構|介面|類別}0 %1 以 %2 %select{位元組|位元}3%s2 對齊至 %4'
# 'padding %select{struct|interface|class}0 %1 with %2 %select{byte|bit}3%s2 to align anonymous bit-field'
HE333A36DBC3C: '填充 %select{結構|介面|類別}0 %1 以 %2 %select{位元組|位元}3%s2 對齊匿名位元域'
# 'padding %select{struct|interface|class}0 %1 with %2 %select{byte|bit}3%s2 to align anonymous field'
H1B5890218438: '填充 %select{結構|介面|類別}0 %1 以 %2 %select{位元組|位元}3%s2 對齊匿名成員'
# 'padding size of %0 with %1 %select{byte|bit}2%s1 to alignment boundary'
H5BCCA44B6E5B: '將 %0 的大小以 %1 %select{位元組|位元}2%s1 填充至對齊邊界'
# 'parameter %0 must have a complete type to use function %1 with the %2 calling convention'
H35B9EA765265: '參數 %0 必須具有完整類型，才能在 %2 調用規約下使用函數 %1'
# 'parameter %0 set but not used'
HB6BB1AF1B37E: '參數 %0 已設定但未使用'
# "parameter %0 was not declared, defaults to 'int'; ISO C99 and later do not support implicit int"
H41790618129F: "參數 %0 未宣告，預設為 'int'；ISO C99及之後版本不支援隱含int類型"
# "parameter '%0' is already documented"
HF9B7DF355428: "參數 '%0' 已被文檔化"
# "parameter '%0' not found in the function declaration"
HD7CC3BBE6634: "在函數宣告中未找到參數 '%0'"
# "parameter '%0' not in expected state when the function returns: expected '%1', observed '%2'"
H6EE5C60DD591: "參數 '%0' 在函數返回時未處於期望狀態：期望 '%1'，觀察到 '%2'"
# "parameter cannot be named '%select{global|unknown}0' while using 'lifetime_capture_by(%select{global|unknown}0)'"
H56545E5909EB: "在使用 'lifetime_capture_by(%select{global|unknown}0)' 時，參數不能命名為 '%select{global|unknown}0'"
# 'parameter declarator cannot be qualified'
HEB6B080E8792: '參數宣告不能使用修飾符'
# 'parameter kind mismatch; parameter is %select{not a|a}0 parameter pack'
H53E71EC45244: '參數類型不符；參數%select{不是|是}0參數包'
# 'parameter may not be qualified with an address space'
HFB13BD25F7E6: '參數不能使用地址空間修飾'
# 'parameter name cannot have template arguments'
H4AE4E444760E: '參數名稱不能包含範型參數'
# 'parameter named %0 is missing'
HE41EE5512047: '名為 %0 的參數缺失'
# "parameter of %0 attribute must be 'id' when used on a typedef"
H95DFECC378EF: "%0 屬性在用於typedef時必須為 'id'"
# 'parameter of %0 attribute must be a single name of an Objective-C %select{class|protocol}1'
H6E3911EE67CF: '%0 屬性必須是Objective-C %select{類|協定}1的單一名稱'
# 'parameter of %0 cannot have a default argument'
H9997206462BD: '%0 的參數不能有預設參數值'
# "parameter of literal operator must have type 'unsigned long long', 'long double', 'char', 'wchar_t', 'char16_t', 'char32_t', or 'const char *'"
H18EF0BD0BEB6: "字面運算子的參數必須具有類型 'unsigned long long'、'long double'、'char'、'wchar_t'、'char16_t'、'char32_t' 或 'const char *'"
# 'parameter of overloaded %0 cannot have a default argument'
H31033CF29CE2: '重載的 %0 參數不能有預設參數值'
# "parameter of overloaded post-%select{increment|decrement}1 operator must have type 'int' (not %0)"
H42A579D6B7B0: "重載的後置 %select{遞增|遞減}1 運算子的參數類型必須為 'int'（而非 %0）"
# 'parameter of overridden method is annotated with __attribute__((noescape))'
H1DC2A8B6BA41: '被覆寫的方法參數標註了 __attribute__((noescape))'
# 'parameter of overriding method should be annotated with __attribute__((noescape))'
HD9E0E2EF69AC: '覆寫方法的參數應標註 __attribute__((noescape))'
# "parameter of the 'collapse' clause"
H978C7D7597CF: "'collapse' 子句的參數"
# 'parameter of type %0 is declared here'
HB0D7D36BAAD5: '類型為 %0 的參數在此處宣告'
# 'parameter pack %0 declared here'
HF649CEA110D0: '參數包 %0 在此處宣告'
# 'parameter pack cannot have a default argument'
H220429408CBD: '參數包不能有預設參數值'
# 'parameter references not allowed in naked functions'
HE9A90AF8CF8F: '裸函數中不允许參數引用'
# "parameterized class %0 already conforms to the protocols listed; did you forget a '*'?"
H0F239CE68A40: '參數化類別 %0 已符合所列的協定；是否遺漏了 "*"？'
# 'parameters for defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator must have the same type%diff{ (found $ vs $)|}1,2'
H34C46A5FC53A: '預設的 %select{<ERROR>|相等|三向|相等|關係}0 比較運算子的參數必須具有相同的類型%diff{ (找到 $ 與 $)|}1,2'
# "parent region for 'omp %select{cancellation point|cancel}0' construct cannot be nowait"
H10627ACFF3E1: "'omp %select{取消點|取消}0' 建構式的父區域不能為 nowait"
# "parent region for 'omp %select{cancellation point|cancel}0' construct cannot be ordered"
H2F8AAD55F0CC: "'omp %select{取消點|取消}0' 建構式的父區域不能為 ordered"
# "parent umbrella does not match: '%0' (provided) vs '%1' (found)"
H38C90C7CC02F: "父層傘目錄不匹配：'%0'（提供）與 '%1'（找到）"
# "parent umbrella missing from %0: '%1'"
HCD77F7184E7F: "父層傘目錄 %0 中缺少 '%1'"
# 'parentheses are required around macro argument containing braced initializer list'
H41A73FF55953: '包含花括號初始化清單的宏參數必須加上括號'
# 'parentheses are required around this expression in a requires clause'
H8DF4B4E0E5BD: 'requires子句中的這個運算式必須加上括號'
# 'parentheses around address non-type template argument are a C++11 extension'
H55DF42498A9B: '地址非類型模板參數周圍的括號是C++11擴展'
# 'parentheses around address non-type template argument are incompatible with C++98'
H8ACABCA7F85D: '地址非類型模板參數周圍的括號與C++98不相容'
# "parentheses must be omitted if %0 attribute's argument list is empty"
H90F4FD29334C: '如果 %0 屬性的參數清單為空，必須省略括號'
# 'parentheses were disambiguated as a function declaration'
H329AE7B68E6C: '括號被解析為函數宣告的消歧'
# 'parentheses were disambiguated as redundant parentheses around declaration of variable named %0'
H911B6F6318F6: '括號被解析為 %0 變數宣告周圍的冗餘括號'
# 'parenthesize the second argument to silence'
HB3431A17CC77: '對第二個參數加上括號以消除警告'
# 'parenthesized initialization of a member array is a GNU extension'
HD07F8AE496CA: '成員陣列的括號初始化是GNU擴展'
# 'parse the input, create a PFT, dump it, and exit'
H8632144C8313: '分析輸入、建立PFT、傾印並退出'
# 'partial ordering for explicit instantiation of %0 is ambiguous'
HE38D1382AB5B: '%0 的明確實體化部分排序存在歧義'
# 'partial specialization cannot be declared as a friend'
HA147DDFF5AB9: '無法將部分特化宣告為友元'
# 'partial specialization matches %0'
HA30AC1C7D740: '部分特化與 %0 匹配'
# 'partial specialization of %0 does not use any of its template parameters'
H84CBC790F3FB: '%0 的部分特化未使用其任何模板參數'
# 'pass -fsafe-buffer-usage-suggestions to receive code hardening suggestions'
HB623B7D5D4C9: '傳遞-fsafe-buffer-usage-suggestions以取得程式碼強化建議'
# 'passing %0-byte aligned argument to %1-byte aligned parameter %2%select{| of %4}3 may result in an unaligned pointer access'
H8E7373BFAB19: '傳遞 %0 位元組對齊的引數至 %1 位元組對齊的參數 %2%select{| of %4}3 可能导致未對齊的指標存取'
# 'passing %select{address of|reference to}0 local temporary object to musttail function'
H185CAE78405D: '將本地臨時物件%select{的位址|的參考}0傳遞給musttail函數'
# "passing %select{an object that undergoes default argument promotion|an object of reference type|a parameter declared with the 'register' keyword}0 to 'va_start' has undefined behavior"
H71043E0BAFE6: "將%select{經預設參數提升的物件|引用類型的物件|以 'register' 關鍵字宣告的參數}0傳遞給 'va_start' 具有未定義行為"
# "passing '%0' format string where '%1' format string is expected"
HB0DCC631BCB0: "傳遞 '%0' 格式字串，而這裡期望的是 '%1' 格式字串"
# "passing a type argument as the first operand to '_Generic' is a C2y extension"
H9B0C1A1B2AAD: "將類型參數作為 '_Generic' 的第一個操作數傳遞是C2y的擴充功能"
# "passing a type argument as the first operand to '_Generic' is incompatible with C standards before C2y"
H0B03D58A8538: "將類型參數作為 '_Generic' 的第一個操作數傳遞與C2y之前的所有C標準不相容"
# 'passing address of %select{non-local|non-scalar}0 object to __autoreleasing parameter for write-back'
H8F97A19F11B3: '將%select{非局部|非純量}0物件的位址傳遞給__autoreleasing參數以執行寫回操作'
# 'passing argument to parameter %0 here'
H30E4C5FD05FE: '這裡傳遞參數 %0 的參數值'
# 'passing argument to parameter here'
HC7C3DD07B432: '這裡傳遞參數的參數值'
# 'passing arguments to %select{a function|%1}0 without a prototype is deprecated in all versions of C and is not supported in C23'
H192BBFFB4918: '將參數傳遞給%select{函數|%1}0 而無原型在所有C版本中均已被棄用，且不支援C23'
# 'passing byval argument %0 with potentially incompatible alignment here'
H730F797EFCA9: '這裡傳遞具有潛在不相容對齊的byval參數 %0'
# "passing no argument for the '...' parameter of a variadic macro is a C++20 extension"
H6D5DB0C5BBB6: "未為可變參數宏的 '...' 參數傳遞參數是C++20的擴充功能"
# "passing no argument for the '...' parameter of a variadic macro is a C23 extension"
H0F0C361742D6: "未為可變參數宏的 '...' 參數傳遞參數是C23的擴充功能"
# "passing no argument for the '...' parameter of a variadic macro is incompatible with C standards before C23"
HCA1A72FB669A: "未為可變參數宏的 '...' 參數傳遞參數與C23之前的C標準不相容"
# "passing no argument for the '...' parameter of a variadic macro is incompatible with C++ standards before C++20"
H2B8F35860B3B: "未為可變參數宏的 '...' 參數傳遞參數與C++20之前的C++標準不相容"
# 'passing non-generic address space pointer to %0 may cause dynamic conversion affecting performance'
HAEF068C749A4: '將非通用位址空間指標傳遞給 %0 可能導致動態轉換而影響效能'
# "passing object of class type %0 through variadic %select{function|block|method|constructor}1%select{|; did you mean to call '%3'?}2"
H39C1EFFB876B: "將類型 %0 的物件透過可變參數%select{函數|區塊|方法|建構函數}1傳遞 %select{|；您是否想呼叫 '%3'？}2"
# 'passing object of trivial but non-POD type %0 through variadic %select{function|block|method|constructor}1 is incompatible with C++98'
HD5D2FE67C0FC: '將類型 %0 的物件（其為非POD但具有平凡特性的類型）透過可變參數%select{函數|區塊|方法|建構函數}1傳遞與C++98不相容'
# "passing only one argument to 'va_start' is incompatible with C standards before C23"
H0DFF95F6ABB1: "僅傳遞一個參數給 'va_start' 與C23之前的C標準不相容"
# "passing pointer %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
H9E268E19A549: "傳遞指標 %1 需要持有 %0 %select{'%2'|' 獨佔的 %2'}3"
# "passing pointer to variable %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
H0E1F82092409: "傳遞變數 %1 的指標需要持有 %0 %select{'%2'|' 獨佔的 %2'}3"
# "passing the value that %1 points to by reference requires holding %0 %select{'%2'|'%2' exclusively}3"
HFB2B4F9A02B6: "以引用方式傳遞 %1 所指物件的值需要持有 %0 %select{'%2'|' 獨佔的 %2'}3"
# 'passing union across security boundary via %select{parameter %1|return value}0 may leak information'
HA1E50C08E561: '透過%select{參數 %1|傳回值}0傳遞聯組跨越安全性邊界可能會洩漏資訊'
# "passing variable %1 by reference requires holding %0 %select{'%2'|'%2' exclusively}3"
HB011E968C37B: "以引用方式傳遞變量 %1 需要持有 %0 %select{'%2'|' 排他性持有的 %2'}3"
# "pasting formed '%0', an invalid preprocessing token"
H17B929BA26C6: "拼接形成 '%0'，這是無效的預處理符號"
# "pasting two '/' tokens into a '//' comment is a Microsoft extension"
HBFF0AAF786C4: "將兩個 '/' 符號拼接成 '//' 註解是Microsoft擴展"
# 'path to a pass plugin for HIP to SPIR-V passes.'
HF42DFD9FA413: 'HIP到SPIR-V管線的插件路徑'
# 'path to instrumented binary in case if /proc/self/map_files is not accessible due to access restriction issues'
H9C547FEDA325: '在/proc/self/map_files因存取限制無法存取時，插樿二進位檔的路徑'
# 'pc tracing with a guard'
H66AAE93ED197: '具有守衛的PC追蹤'
# 'perf2bolt - BOLT data aggregator\n\nEXAMPLE: perf2bolt -p=perf.data executable -o data.fdata\n'
H64C11174A75F: 'BOLT資料聚合器\n\n範例：perf2bolt -p=perf.data 執行檔 -o data.fdata\n'
# 'perform FOP on all functions'
H2A14A47C13E8: '對所有函數執行FOP'
# 'perform FOP on hot functions'
H4C1838B87112: '對熱函數執行FOP'
# 'perform ICP on calls and jump tables'
H58DE93FE6F76: '對呼叫與跳轉表執行ICP'
# 'perform ICP on indirect calls'
HBCFC7E630187: '對間接呼叫執行ICP'
# 'perform ICP on jump tables'
HF431F48B1DC7: '對跳轉表執行ICP'
# 'perform layout optimizing I-cache behavior'
H978D4EED4690: '根據I-cache行為最佳化佈局'
# 'perform optimal layout based on profile'
HC1766F39AC7E: '根據配置文件執行最佳化佈局'
# 'perform optimal layout prioritizing I-cache behavior'
HBDF007516F2C: '以優先I-cache行為為基礎的最佳化佈局'
# 'perform optimal layout prioritizing branch predictions'
HB3E593E231FA: '以優先分支預測為基礎的最佳化佈局'
# 'perform profiling accuracy-sensitive optimizations only if function execution count >= the threshold (default: 0)'
HFF64335273A6: '僅執行剖面準確度敏感的優化（若函式執行次數 >= 閾值，預設：0）'
# 'perform random layout of clusters'
H7C7C380E5354: '隨機排列群集佈局'
# 'perform verification of LLVM instruction encoding/decoding. Every instruction in the input is decoded and re-encoded. If the resulting bytes do not match the input, a warning message is printed.'
H52D0672FF953: '驗證LLVM指令的編碼/解碼。輸入中的每個指令都會被解碼並重新編碼。如果結果位元組與輸入不符，會印出警告訊息。'
# 'performSelector may cause a leak because its selector is unknown'
H653C9447EE92: 'performSelector可能因選擇子未知導致記憶體洩漏'
# 'performSelector names a selector which retains the object'
HF51E4C8347B0: 'performSelector 指定的選擇器會保留該物件'
# 'performing pointer arithmetic on a null pointer has undefined behavior%select{| if the offset is nonzero}0'
HA288389E9F6A: '在空指標上執行指標運算具有未定行為 %select{|如果偏移量不為零}0'
# 'performing pointer subtraction with a null pointer %select{has|may have}0 undefined behavior'
HB725A707608F: '使用空指標進行指標減法%select{具有|可能具有}0 未定行為'
# 'performs disassembly sequentially'
HDD6DFBE032D2: '依序執行反組譯'
# 'permutation index must be at least 1 and at most %0'
H0297CCE3F38F: '排列索引必須至少為 1 且至多為 %0'
# 'pick register allocator based on -O option'
H46CB03DD1B68: '根據 -O 選項選擇寄存器配置器'
# 'pipes packet types cannot be of reference type'
H354A6AC50D78: '管道封包類型不能是引用類型'
# "place '...' %select{immediately before declared identifier|here}0 to declare a function parameter pack"
HD82CBB258C12: "在%select{宣告的識別符之前立即|這裡}0 放置 '...' 以宣告函數參數包"
# 'place all array allocations more than <size> elements on the heap'
H7583F9BA4C9F: '將所有元素數量超過 <size> 的陣列分配放在堆上'
# 'place all array allocations of dynamic size on the heap'
H1E67C0E84EC2: '將所有動態大小的陣列分配放在堆上'
# 'place parentheses around comparison expression to evaluate it first'
H1021BF49A48F: '在比較運算式外放置括號以優先評估它'
# 'place parentheses around the %0 expression to evaluate it first'
HD79F2195D659: '在 %0 運算式外放置括號以優先評估它'
# "place parentheses around the '%0' expression to silence this warning"
H7195F835EC30: "在 '%0' 運算式外放置括號以消除此警告"
# "place parentheses around the '?:' expression to evaluate it first"
H9605DB1A560A: "在 '?:' 運算式外放置括號以優先評估它"
# 'place parentheses around the assignment to silence this warning'
HE705E4D071BD: '在賦值運算式外放置括號以消除此警告'
# 'place parentheses around the string literal to silence warning'
H876899527936: '在字串字面量外放置括號以消除警告'
# 'placeholder declared here'
H7E34AEC856E5: '占位符在此處宣告'
# 'placeholder variables are a C++2c extension'
H4C0235C28642: '占位符變數是 C++2c 的擴充功能'
# 'placeholder variables are incompatible with C++ standards before C++2c'
H6BE10CEEDF1B: '占位符變數與 C++2c 之前的 C++ 標準不相容'
# 'placement new would change type of storage from %0 to %1'
H83FB1C107237: 'placement new 會將儲存的類型從 %0 改為 %1'
# "plain '_Complex' requires a type specifier; assuming '_Complex double'"
HBC4E2F0D8FF6: "純 '_Complex' 需要類型指定符；假設為 '_Complex double'"
# "platform does not match: '%0' (provided) vs '%1' (found)"
H5C64A2FB6312: "平台不符合：'%0'（提供的）與 '%1'（找到的）"
# "please rebuild precompiled header '%0'"
HFBA0A20CA8AF: "請重新建置預編譯標頭 '%0'"
# 'plt'
H8B8091C3AD1A: 'plt'
# 'pointer %0 declared here'
H22E4F3576FCE: '指標 %0 在此宣告'
# "pointer arguments to kernel functions must reside in '__global', '__constant' or '__local' address space"
HEE966568F6BF: "核心函數的指標參數必須位於 '__global'、'__constant' 或 '__local' 位址空間"
# 'pointer cannot be cast to type %0'
H0546695B4A22: '指標無法轉換為類型 %0'
# 'pointer cannot be mapped along with a section derived from itself'
HAF06E92DEBA3: '指標無法與自身衍生的區段進行映射'
# 'pointer comparisons before C11 need to be between two complete or two incomplete types; %0 is %select{|in}2complete and %1 is %select{|in}3complete'
H4DB22EDB67C8: '在 C11 之前的指標比較需要在兩個完整類型或兩個不完整類型之間進行；%0 是%select{不完整|完整}2類型，而 %1 是%select{不完整|完整}3類型'
# "pointer to function type %0 may not be 'restrict' qualified"
H909D3E85FCFF: "%0 的函數指標類型不可標示 'restrict' 屬性"
# 'pointer to type %0 is invalid in OpenCL'
HEF9B07C9C640: '類型 %0 的指標在 OpenCL 中無效'
# 'pointer type mismatch%diff{ ($ and $)|}0,1'
H8EAA8DFC686A: '指標類型不匹配%diff{ ($ 和 $)|}0,1'
# 'pointer-to-member function type %0 can only be called on an %select{rvalue|lvalue}1'
H08EA28E0562A: '成員函數指標類型 %0 只能用在 %select{右值|左值}1 上'
# 'pointer/integer type mismatch in conditional expression%diff{ ($ and $)|}0,1'
HC15C6EF198BF: '條件運算式中的指標/整數類型不匹配%diff{ ($ 和 $)|}0,1'
# 'poison on failure'
HE44AF8732393: '失敗時毒化（poison）'
# 'poison undef temps'
H7A7B675BE411: '毒化未定義的臨時變數'
# 'poison uninitialized stack variables'
H47518342CB8C: '毒化未初始化的堆疊變數'
# 'poison uninitialized stack variables with a call'
H429653491DDF: '使用函數呼叫毒化未初始化的堆疊變數'
# 'poison uninitialized stack variables with the given pattern'
H338B60F2873D: '以指定模式毒化未初始化的堆疊變數'
# 'poisoning existing macro'
HDD8F2D4A6FAB: '毒化現有宏'
# 'position arguments in format strings start counting at 1 (not 0)'
HC64922328C30: '格式字串中的位置參數從 1 開始編號（而非 0）'
# "position-independent code requires '-mabicalls'"
H69FA922C5B49: "位置獨立代碼需要 '-mabicalls'"
# 'positional arguments are not supported by ISO C'
HE496161E3DDA: 'ISO C 不支援位置參數'
# 'possible misuse of comma operator here'
H0A8E98669706: '可能在此處誤用逗號運算子'
# 'possible target for call'
H16BA315A6C23: '可能的調用目標'
# 'possible target of %select{indirect|asm}0 goto statement'
H03DE80F51E17: '%select{間接|組合語言}0 goto 語句的可能目標'
# 'postfix attributes are not allowed on Objective-C directives'
HA57AC12B1C85: '後置屬性不允許用於Objective-C指令'
# "postfix attributes are not allowed on Objective-C directives, place them in front of '%select{@interface|@protocol}0'"
H83C11CD38B50: "後置屬性不允許用於Objective-C指令，請將它們放在 '%select{@interface|@protocol}0' 之前"
# 'potential performance regression from use of __builtin_expect(): annotation was correct on %0 of profiled executions'
HD6474E353C24: '使用 __builtin_expect() 可能導致效能退化：在 %0 的剖析過的執行次數中，註解是正確的'
# 'pp-trace options'
H87829B6B5E89: 'pp-trace 選項'
# 'pragma %0 requires a parenthesized string'
H25DF715FB71D: 'pragma %0 需要括號包圍的字串'
# 'pragma %select{message|warning|error}0 requires parenthesized string'
H58AE415DBC7A: 'pragma %select{message|warning|error}0 需要括號包圍的字串'
# 'pragma STDC FENV_ROUND is not supported'
HF7A928CE98B4: 'pragma STDC FENV_ROUND 不受支援'
# 'pragma comment requires parenthesized identifier and optional string'
HD6BA08D64805: 'pragma comment 需要括號包圍的識別符和可選字串'
# 'pragma detect_mismatch is malformed; it requires two comma-separated string literals'
H82A7E617FBD6: 'pragma detect_mismatch 格式錯誤；它需要兩個以逗號分隔的字串文字'
# "pragma diagnostic expected 'error', 'warning', 'ignored', 'fatal', 'push', or 'pop'"
HD2286608AABA: "pragma diagnostic 期望 'error', 'warning', 'ignored', 'fatal', 'push' 或 'pop'"
# 'pragma diagnostic expected option name (e.g. "-Wundef")'
HF5C6654FAE5F: 'pragma diagnostic 須指定選項名稱（例如「-Wundef」）'
# 'pragma diagnostic pop could not pop, no matching push'
H6F8E683545E5: 'pragma diagnostic pop 無法彈出，沒有對應的 push'
# "pragma float_control is malformed; use 'float_control({push|pop})' or 'float_control({precise|except}, {on|off} [,push])'"
HDD83603CAD05: "pragma float_control 格式錯誤；使用 'float_control({push|pop})' 或 'float_control({precise|except}, {on|off} [,push])'"
# "pragma include_alias expected '%0'"
H01DD8237CC21: "pragma include_alias 須指定 '%0'"
# 'pragma include_alias expected include filename'
H08BDBEAABFC9: 'pragma include_alias 期望包含的文件名'
# "pragma pop_macro could not pop '%0', no matching push_macro"
HF67398D54EBA: "pragma pop_macro 無法取消推疊 '%0'，因未找到對應的 push_macro"
# "preceding '...' declares a function parameter pack"
HB271FF2CAE5F: "先前的 '...' 宣告了一個函數參數包"
# 'precompiled'
H5B5680CDE56B: '預編譯'
# "precompiled header '%0' was ignored because '%1' is not first '-include'"
H47051C658E08: "預編譯標頭 '%0' 因 '%1' 非第一個 '-include' 而被忽略"
# "precompiled header '%0' was ignored because it is not a clang PCH file"
HC110D52BBD02: "預編譯標頭 '%0' 因非 clang PCH 檔案而被忽略"
# "precompiled header directory '%0' was ignored because it contains no clang PCH files"
H3E91139CDF42: "預編譯標頭目錄 '%0' 因無 clang PCH 檔案而被忽略"
# 'predefined allocator cannot have traits specified'
H8666F51519BE: '預定義配置器不可指定特性'
# 'predefined identifier is only valid inside function'
HF82196FF10EA: '在函數內部以外使用預定義識別符'
# "predefined trait '%0' used here"
H55566D31A8B9: "在此處使用預定義特性 '%0'"
# 'predetermined as a firstprivate in a task construct here'
H405D7D760401: '在任務構造中已預先指定為 firstprivate'
# 'prefer tail-folding, create scalar epilogue if tail folding fails.'
HD0E4E0A8CB08: '優先採用尾部摺疊，若失敗則建立標量尾部。'
# 'prefer update form when ds form is also a update form'
HEA9A1D5F496C: '當雙源形式也符合更新形式時，應優先採用更新形式'
# 'prefer_list item must be a string literal or constant integral expression'
HCAFE9C287B6C: 'prefer_list 項目必須是字串常數或定值整數運算式'
# "prefers tail-folding, don't attempt vectorization if tail-folding fails."
H12E0DCDDA093: '優先採用尾部摺疊，若失敗則不嘗試向量化。'
# 'prefix attribute must be followed by an interface, protocol, or implementation'
H129BA69DE7F2: 'prefix 屬性必須跟隨介面、協定或實作'
# 'prefix with the address-of operator to silence this warning'
H51278B3A983C: '在警告前加上取址運算子以抑制此警告'
# 'prepare update form when the load/store increment is a loop invariant non-const value.'
H7F0464394BFE: '當載入/儲存增量是循環不變的非const值時，準備更新形式'
# 'preserve intermediate .o file'
HBCF9A92B45C8: '保留中間的.o 檔案'
# 'pretty-print DWARF debug information in object files and debug info archives.\n'
HFF4E6027BC6C: '在物件檔和除錯資訊存檔中美觀列印DWARF除錯資訊。\n'
# 'previous %select{template type|non-type template|template template}0 parameter%select{| pack}1 declared here'
HEDFC0D57E1AE: '先前%select{模板類型|非類型模板|模板模板}0 參數 %select{| 包}1 在此宣告'
# 'previous %select{unmarked |}0overload of function is here'
HAE3E66A916BE: '先前函數%select{未標記的 |}0 重載在此處'
# "previous '#pragma pack' directive that modifies alignment is here"
H39F3F82E0571: '先前修改對齊的 "#pragma pack" 指令在此處'
# "previous '%0' directive used here"
HE7A8B08DD5DE: '先前的 "%0" 指令在此處使用'
# "previous 'critical' region starts here"
H3FBC82C6CFEF: '先前的 "關鍵" 區域在此處開始'
# 'previous allocator is specified here'
H065261987D15: '先前指定的配置器在此處'
# 'previous attribute is here'
H6E32F6609895: '先前的屬性在此處'
# 'previous binding pack specified here'
H720F62C2E50B: '先前指定的綁定包在此處'
# 'previous call is here%select{; set to nil to indicate it cannot be called afterwards|}0'
HE8A56E8F5AF3: '先前的呼叫在此處 %select{; 設置為nil以表示其後不可呼叫|}0'
# 'previous case defined here'
H67B17B33B89D: '先前定義的案例在此處'
# 'previous clause is here'
HE9FAFB90DAE5: '先前的子句在此處'
# 'previous clause with directive name modifier specified here'
H59743B40EF38: '先前具有指令名稱修飾符的子句在此處指定'
# "previous command '%select{\\|@}0%1' (an alias of '\\%2') here"
HE969B475A653: '先前的指令 "%select{\\|@}0%1" (是 "\\%2" 的別名) 此處'
# "previous command '%select{\\|@}0%1' here"
H5B43AF8F451D: '先前的指令 "%select{\\|@}0%1" 此處'
# 'previous declaration is here'
H9CAB5B6B1715: '先前的宣告在此處'
# 'previous declaration of class template partial specialization %0 is here'
H8EF5BDE072C8: '類模板部分特化 %0 的先前宣告在此處'
# 'previous declaration of variable template partial specialization is here'
H5A936ED6E7F5: '先前的變數模板部分特殊化宣告位於此處'
# 'previous default generic association is here'
H5A119A508D2B: '先前的預設泛型關聯位於此處'
# 'previous default template argument defined here'
H828BBDD8C7F9: '先前的預設模板引數定義位於此處'
# 'previous default template argument defined in module %0'
H2F92B57F5F02: '先前在模組 %0 中定義的預設模板引數位於此處'
# 'previous definition is here'
H0AC845A11A85: '先前的定義位於此處'
# 'previous documentation'
H8053B03861AE: '先前的文件說明'
# 'previous equal key is here'
H916F7D758598: '先前的等效鍵位於此處'
# 'previous explicit instantiation is here'
HCA86CACA9800: '先前的明確實體化位於此處'
# 'previous expression is here'
H72EA4DC42083: '先前的運算式位於此處'
# 'previous implicit declaration is here'
H2F8B22E01C4A: '先前的隱式宣告位於此處'
# 'previous inheritance model specified here'
HDD10F14D9687: '先前指定的繼承模型位於此處'
# 'previous initialization %select{|with side effects }0is here%select{| (side effects will not occur at run time)}0'
HFE059F4FA2A1: '先前的初始化 %select{|具有副作用 }0位於此處 %select{|（執行階段不會產生副作用）}0'
# 'previous initialization for field %0 is here'
HEF0E98EA391B: '先前的成員 %0 初始化位於此處'
# 'previous module declaration is here'
HD052ACC784A7: '先前的模組宣告位於此處'
# 'previous non-type template parameter with type %0 is here'
H5A88D83E2220: '先前具有類型 %0 的非類型模板參數位於此處'
# 'previous reference is here'
HEFAE6804D795: '先前的參考位於此處'
# 'previous return statement is here'
H147041BC8FB0: '先前的傳回陳述式位於此處'
# 'previous statement is here'
H94AB14DFE365: '先前的陳述式位於此處'
# 'previous template %select{declaration|template parameter}0 is here'
H94CA97347769: '先前的模板 %select{宣告|模板參數}0 位於此處'
# 'previous template specialization is here'
H0FDA24AE451B: '先前的模板特殊化位於此處'
# 'previous use is here'
H39A31F8B143F: '先前的使用在此處'
# 'previous uuid specified here'
H8206D7044433: '先前指定的uuid在此處'
# "previously declared '%0' here"
H4ECE9D2CF70E: "先前在此處宣告 '%0'"
# "previously declared '%1' here"
H6BFF38DE7EEF: "先前在此處宣告 '%1'"
# 'previously declared as %0 here'
HEA5BCF07D9E2: '先前在此處宣告為 %0'
# 'previously defined as an alias for %0'
HC8CE8DE52E3E: '先前被定義為 %0 的別名'
# 'previously defined here'
H0787B53F4571: '先前在此處定義'
# 'previously marked as task_reduction with different reduction operation'
HFE3CA309C947: '先前以不同的簡化運算標記為 task_reduction'
# 'previously referenced here'
H8ADE478F0E44: '先前在此處引用'
# 'primary property declaration is implicitly strong while redeclaration in class extension is weak'
H331A66416F47: '主要屬性宣告隱含為強引用，而類別延伸中的重新宣告為弱引用'
# 'print ORC unwind information for instructions'
H4E31B5E474E7: '列印指令的 ORC 卸載資訊'
# 'print aliases when printing objects'
HF92219983E87: '列印物件時同時列印別名'
# 'print all SDT markers'
H98709AE1B551: '列印所有 SDT 標記'
# 'print all proposals received and whether they were rejected or accepted'
H04A22263A041: '列印收到的所有提案以及是否被拒絕或接受'
# 'print all registered sections'
H8FAB43011447: '列印已註冊的區段'
# 'print clusters'
H9B37594EE600: '列印叢集'
# 'print debug info when printing functions'
HFF8256E364B3: '列印函數時列印除錯資訊'
# 'print dyno stats after each stage'
H9275B8D7E627: '在每個階段後列印 dyno 統計資料'
# 'print everything - most verbose'
H1BEA0BEF5E2F: '列印所有資訊 - 最詳細'
# 'print exception handling data'
H8F7DF5B5AC2D: '列印例外處理資料'
# 'print execution info based on profile'
H93C84C9D44B9: '根據剖面資料列印執行資訊'
# 'print function after CFG is finalized'
H87F7D6E5ADA5: '控制流圖建構最終化後列印函數'
# 'print function after disassembly'
H6524D80C8BFA: '反組裝後列印函數'
# 'print function after edge counts are set for no-LBR profile'
H3061E9C9E191: '設定無 LBR 剖面的邊緣計數後列印函數'
# 'print function after fixing local branches'
H1402AC66D1C0: '修正本地分支後列印函數'
# 'print function after instruction lowering'
H612727DB3C18: '指令降階後列印函數'
# 'print function after jt-footprint-reduction pass'
HDF747925B28E: 'jt-footprint-reduction pass 後列印函數'
# 'print functions after ADR Relaxation pass'
H380909F95FC6: 'ADR 訪問位址模式鬆弛優化管線後列印函數'
# 'print functions after CFG construction'
HCF99E2AF5C10: '控制流圖建構後列印函數'
# 'print functions after CFG is normalized'
H52A0761BF0A3: '控制流圖正規化後列印函數'
# 'print functions after ICF optimization'
H0BC917F969E4: 'ICF 優化後列印函數'
# 'print functions after PLT optimization'
HF2CB032C6433: 'PLT 優化後列印函數'
# 'print functions after attaching profile'
HD8A5C41FAD15: '附加剖面後列印函數'
# 'print functions after bodyless optimization'
HBA38B0532A13: '無函數主體優化後列印函數'
# 'print functions after clustering'
H867D3C181C5B: '群集後列印函數'
# 'print functions after code splitting'
HFFE83E7C36B6: '代碼分割後列印函數'
# 'print functions after conditional tail call simplification'
H0EFD18F8B1CE: '條件尾調用簡化後列印函數'
# 'print functions after each stage'
H6F2DBD4C3BE5: '每個階段後列印函數'
# 'print functions after fix RISCV calls pass'
HA11DE9F7CABB: '修正 RISCV 呼叫 pass 後列印函數'
# 'print functions after fix relaxations pass'
H9A6C75CABE6B: '修正鬆弛優化 pass 後列印函數'
# 'print functions after frame optimizer pass'
H37293007159E: '在frame optimizer pass後列印函數'
# 'print functions after indirect call promotion'
H6777ED6D8688: '在間接調用提升後列印函數'
# 'print functions after inlining optimization'
H849DB929CE9A: '在內聯優化後列印函數'
# 'print functions after layout optimization'
H1EAABA34176F: '在布局優化後列印函數'
# 'print functions after longjmp pass'
H2C02F65E2B10: '在longjmp pass後列印函數'
# 'print functions after peephole optimization'
HF6F27EE243F4: '在窥孔優化後列印函數'
# 'print functions after regreassign pass'
H205E59625248: '在regreassign pass後列印函數'
# 'print functions after retpoline insertion pass'
H348587451657: '在插入retpoline pass後列印函數'
# 'print functions after simplification of RO data loads'
HA796FD5DA60B: '在簡化RO資料載入後列印函數'
# 'print functions after stoke analysis'
H090E8674EC1A: '在stoke分析後列印函數'
# 'print functions after unreachable code elimination'
HC31930E74334: '在未達可程式碼消除後列印函數'
# 'print functions after veneer elimination pass'
HD9F864AE57D7: '在veneer消除pass後列印函數'
# 'print functions of binary 2 that were not matched to any function in binary 1'
H74494F9D492B: '列印二進位 2 中未與二進位 1 的任何函數匹配的函數'
# 'print functions sorted by execution count'
HB0992E5F3DD7: '按執行次數排序後列印函數'
# 'print functions sorted by order of dyno stats'
H0A27E3FA15F0: '按動態統計順序排序後列印函數'
# 'print functions sorted by total branch count'
H58EE9BACA77C: '按總分支次數排序後列印函數'
# 'print functions that could not be overwritten due to excessive size'
H64A4A3141F70: '列印因大小過大而無法覆寫的函數'
# 'print functions that have profile in binary 1 but do not in binary 2'
H8FB878E6408D: '列印在二進位 1 中有剖析但二進位 2 中沒有對應的函數'
# 'print global symbols after disassembly'
H6F71EE919FF4: '在反組譯後列印全域符號'
# 'print jump tables'
HE7814FCDE82F: '列印跳轉表'
# 'print loop related information'
H1CC87F1B29B5: '列印與迴圈相關的資訊'
# 'print mappings in the legend, between characters/blocks and text sections (default false)'
HAB49FA127C23: '列印圖例中字符/區塊與文字段之間的對應關係（預設 false）'
# 'print memory data annotations when printing functions'
HE37470A2DD9C: '在列印函數時顯示記憶體資料註解'
# 'print names of functions with unknown control flow'
H02687E68D720: '列印具有未知控制流的函數名稱'
# 'print no details'
HE1459B6CBBDF: '不顯示詳細資訊'
# 'print out instructions with default strict semantics'
HBF6B61DB25E4: '列印出具有預設嚴格語意的指令'
# 'print output address range for each basic block in the function whenBinaryFunction::print is called'
H4D2F05339EF5: '在呼叫 BinaryFunction::print 時，列印函式中每個基本區塊的輸出位址範圍'
# "print pass arguments to pass to 'opt'"
H6E943315CBC7: '列印要傳遞給 "opt" 的 pass 參數'
# 'print pass details when it is executed'
H76B02F3EE5E5: '在執行 pass 時列印詳細資訊'
# 'print pass name before it is executed'
H741AF7A7B7D4: '在執行 pass 前列印其名稱'
# 'print pass structure before run()'
HF0D6992C747F: '在執行 run() 前列印 pass 結構'
# 'print per instruction opcode dyno stats and the functionnames:BB offsets of the nth highest execution counts'
HED6C36296EF9: '列印每條指令的 opcode 動態統計數據，以及執行次數第 n 高的函數名稱:BB 位移量'
# 'print profile quality/bias analysis'
H2BA901542885: '列印剖析品質/偏移分析'
# 'print pseudo probe info'
H497835ACD698: '列印偽探針資訊'
# 'print regions in detail with block_iterator'
HC53F268C8D37: '使用 block_iterator 以詳細方式列印區塊'
# 'print regions in detail with element_iterator'
HEED2CD6BB906: '使用 element_iterator 以詳細方式列印元素'
# 'print register usage details collected for analysis.'
H852E76ABE034: '列印為分析而收集的寄存器使用詳細資訊'
# 'print relocations when printing functions/objects'
HC7882ECBD016: '在列印函數/物件時顯示重新定位資訊'
# 'print section contents after reordering'
HBFCEFB46E060: '重新排列後列印區段內容'
# 'print statistics about basic block ordering'
HD0B0C3B01A36: '列印有關基本區塊排序的統計數據'
# 'print the CFG of important functions that changed in binary 2'
H50C9F66DBC43: '列印二進位 2 中重要且有變更函數的控制流圖 (CFG)'
# 'print the basic blocks showed in top differences'
H1DA154B840C3: '列印主要差異中顯示的基本區塊'
# 'print the list of functions with stale profile'
HE912214BA092: '列印具有過期剖析配置文件的函數列表'
# 'print the list of objects with count to stderr'
H2C756772AFAF: '將物件計數列印至 stderr'
# 'print time spent constructing binary functions'
H5978E6E15455: '列印建立二進位函數所耗時間'
# 'print time spent in each optimization'
H0BBB239D4108: '列印各項優化所耗時間'
# 'print time spent in rewriting passes'
H40857EC64F6B: '列印重寫 pass 所耗時間'
# 'print top <uint> functions with suboptimal code layout on input'
HBFD8DED23E2E: '列印輸入中次佳程式碼布局的前 <uint> 個函數'
# 'printing of statistics for each inlined function'
HCEA14F1643A5: '列印各內聯函數的統計資料'
# 'prints out offsets for abbrev and debug_info of Skeleton CUs that get patched.'
H71912C66C3FC: '列印已修補 Skeleton CUs 的縮寫與除錯資訊偏移量。'
# 'prioritize low virtual register numbers for test and debug'
H0A6C1C201BCE: '優先分配低虛擬寄存器號碼以供測試與除錯'
# "private API notes file for module '%0' should be named '%0_private.apinotes', not '%1'"
HB68113D2F79A: "模組 '%0' 的私人 API 笔記檔應命名為 '%0_private.apinotes'，而非 '%1'"
# 'private field %0 is not used'
H3584A3B50C2A: '私人成員 %0 未被使用'
# 'private module fragment begins here'
H3A617A73B3A6: '私人模組片段從此處開始'
# 'private module fragment declaration with no preceding module declaration'
H1202B7565A2E: '私人模組片段宣告前未先宣告模組'
# 'private module fragment in module implementation unit'
H48CE0D8A14BD: '模組實作單元中的私人模組片段'
# 'private module fragment redefined'
H1427CFAECC58: '重新定義私人模組片段'
# "private submodule '%0' in private module map, expected top-level module"
HCB6CC643EA83: "私人模組地圖中的私人子模組 '%0'，期望頂級模組"
# 'probability argument to __builtin_expect_with_probability is outside the range [0.0, 1.0]'
HFB32BCF3AB99: '傳遞給 __builtin_expect_with_probability 的機率參數超出 [0.0, 1.0] 範圍'
# 'probability argument to __builtin_expect_with_probability must be constant floating-point expression'
H828E266CB5B1: '傳遞給 __builtin_expect_with_probability 的機率參數必須為常數浮點運算式'
# 'process functions with stack pointer arithmetic'
H56D80573022C: '處理使用堆疊指標運算的函數'
# 'profile data may be incomplete: of %0 function%s0, %1 %plural{1:has|:have}1 no data'
H8ACA9571B75F: '剖析資料可能不完整：在 %0 個函數中，%1 %plural{1:有|:有}1個函數沒有資料'
# 'profile data may be out of date: of %0 function%s0, %1 %plural{1:has|:have}1 mismatched data that will be ignored'
HBED3698588C8: '剖析資料可能已過時：在 %0 個函數中，%1 %plural{1:有|:有}1個不匹配的資料將被忽略'
# 'propagate shadow through ICmpEQ and ICmpNE'
HB09C108C7674: '通過ICmpEQ和ICmpNE傳播陰影'
# 'propagating dll attribute to %select{already instantiated|explicitly specialized}0 base class template without dll attribute is not supported'
H6A4E6175A865: '將dll屬性傳播到%select{已實例化的|明確特殊化的}0基類範本（未指定dll屬性）不受支援'
# 'property %0 attempting to use instance variable %1 declared in super class %2'
HDDED40707D8D: '屬性 %0 嘗試使用在超類 %2 中宣告的實例變數 %1'
# 'property %0 cannot be found in forward class object %1'
H503270AA1975: '在前向類別物件 %1 中找不到屬性 %0'
# 'property %0 declared with incompatible types in different translation units (%1 vs. %2)'
H2F559B93D7CB: '屬性 %0 在不同翻譯單元中宣告為不相容的類型（%1 vs. %2）'
# 'property %0 found on object of type %1; did you mean to access it with the "." operator?'
H0A371D1A94C3: '物件類型 %1 上找到屬性 %0；是否應使用「.」運算子存取？'
# 'property %0 has a variably modified type'
H81C9932A69B3: '屬性 %0 具有可變長度類型'
# "property %0 is a class property; did you mean to access it with class '%1'?"
HFC5FD97AFD4C: '屬性 %0 是類別屬性；是否意圖使用類別「%1」存取？'
# 'property %0 is already implemented'
H4ECC248CA95F: '屬性 %0 已實作'
# 'property %0 is declared %select{deprecated|unavailable|partial}1 here'
HC2D276377832: '屬性 %0 在此處宣告為%select{已停用|不可用|部分}1'
# 'property %0 is implemented with %select{@synthesize|@dynamic}1 here'
H43FFE47B4C6F: '屬性 %0 已使用 %select{@synthesize|@dynamic}1 實作'
# 'property %0 is implemented with %select{@synthesize|@dynamic}1 in one translation but %select{@dynamic|@synthesize}1 in another translation unit'
H7C85E91BA02D: '屬性 %0 在某個翻譯單元使用 %select{@synthesize|@dynamic}1 實作，但在另一個翻譯單元使用 %select{@dynamic|@synthesize}1 實作'
# 'property %0 is synthesized to different ivars in different translation units (%1 vs. %2)'
HE49921A78EC2: '屬性 %0 在不同翻譯單元合成到不同的實例變數（%1 vs. %2）'
# 'property %0 not found on object of type %1'
H2822C5946CF1: '物件類型 %1 上找不到屬性 %0'
# 'property %0 not found on object of type %1; did you mean %2?'
HBDBDE3E27B96: '物件類型 %1 上找不到屬性 %0；是否意圖指 %2？'
# 'property %0 not found on object of type %1; did you mean to access instance variable %2?'
H8C5C6406F710: '物件類型 %1 上找不到屬性 %0；是否意圖存取實例變數 %2？'
# 'property %0 not found on object of type %1; did you mean to access property %2?'
H9C85D93EEE02: '屬性 %0 在類型 %1 的物件上找不到；您是否想存取屬性 %2？'
# 'property %0 refers to an incomplete Objective-C class %1 (with no @interface available)'
H5BDCDB941EFA: '屬性 %0 指向不完整的Objective-C類 %1（無可用的@interface）'
# 'property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this category'
HD9354003F0AB: '屬性 %0 需要定義方法 %1 - 請使用@dynamic或在這個類別延伸中提供方法實作'
# 'property %0 requires method %1 to be defined - use @synthesize, @dynamic or provide a method implementation in this class implementation'
HD343415F7FA6: '屬性 %0 需要定義方法 %1 - 請使用@synthesize、@dynamic或在這個類別實作中提供方法實作'
# "property %select{of type %1|with attribute '%1'|without attribute '%1'|with getter %1|with setter %1}0 was selected for synthesis"
HAD70544BC938: "屬性%select{類型 %1|具有屬性 '%1'|缺少屬性 '%1'|具有getter%1|具有setter%1}0 被選取進行合成"
# 'property access is using %0 method which is deprecated'
HC446F861F2EE: '屬性存取正在使用已棄用的 %0 方法'
# 'property access is using %0 method which is unavailable'
H61B587B99038: '屬性存取正在使用不可用的 %0 方法'
# 'property access result unused - getters should not be used for side effects'
H1D3B4CAFB27A: '屬性存取結果未被使用 - getter不應用於副作用'
# 'property attribute in class extension does not match the primary class'
H928CE0C5C480: '類別延伸中的屬性屬性與主類不符'
# "property attributes '%0' and '%1' are mutually exclusive"
H4A7BE0C59F5F: "屬性屬性 '%0' 和 '%1' 是互斥的"
# 'property cannot have array or function type %0'
HE68B6C09E364: '屬性宣告不能具有陣列或函數類型 %0'
# 'property declaration cannot have a default member initializer'
H5272D8E5D57E: '屬性宣告不能有預設成員初始化器'
# "property declaration specifies '%0' accessor twice"
H0E68E4E4BA05: "屬性宣告多次指定 '%0' 存取器"
# 'property declared as returning non-retained objects; getter returning retained objects'
H53034807D818: '屬性宣告為傳回非保留物件；getter傳回保留物件'
# 'property declared here'
H69D70856EBD1: '屬性在此處宣告'
# 'property declared in category %0 cannot be implemented in class implementation'
H04FE1B1065E1: '在類別 %0 的類別延伸中宣告的屬性無法在類別實作中實作'
# 'property does not specify a getter or a putter'
HD0F5818FB6C8: '屬性未指定getter或setter'
# "property follows Cocoa naming convention for returning 'owned' objects"
HEBB6CB98CE86: '屬性遵循Cocoa命名規約傳回「所有權」物件'
# 'property has a previous declaration'
H28BB0E9D9F7A: '屬性在先前宣告過'
# 'property implementation in a category with no category declaration'
HF42022DEA14A: '在沒有類別宣告的類別中實作屬性'
# 'property implementation must be in a class or category implementation'
HD59CD2B75162: '屬性實作必須位於類別或分類的實作中'
# 'property implementation must have its declaration in interface %0 or one of its extensions'
HFCF842D4EB86: '屬性實作必須在介面 %0 或其其中一個擴充中宣告'
# 'property implementation must have its declaration in the category %0'
H761B0BB38838: '屬性實作必須在分類 %0 中宣告'
# 'property is assumed atomic by default'
H2882A0CD4FD8: '屬性預設為原子性'
# 'property is assumed atomic when auto-synthesizing the property'
HC5E58A6AB217: '自動合成屬性時預設為原子性'
# 'property is synthesized to ivar %0 here'
H7E91E310D399: '此處將屬性合成至實例變數 %0'
# 'property name cannot be a bit-field'
H8E1C0549C2E5: '屬性名稱不能是位段'
# 'property requires fields to be named'
H9C4AAD2700BB: '屬性需要命名的成員變數'
# 'property should be changed to be readwrite'
H32DF2D479322: '此屬性應改為readwrite'
# 'property synthesized here'
H0BB379E6C96C: '此處合成屬性'
# 'property type %0 is incompatible with type %1 inherited from %2'
HDE3695134102: '屬性類型 %0 與從 %2 繼承的類型 %1 不相容'
# "property with '%0' attribute must be of object type"
H44EF18C35C26: "具有 '%0' 屬性的屬性必須為物件類型"
# 'protected %select{constructor|destructor}0 can only be used to %select{construct|destroy}0 a base class subobject'
H8490EFD629C0: '受保護的%select{建構函數|析構函數}0只能用於%select{建構|销毁}0基類子物件'
# 'protocol %0 has no definition'
H3F201B2D647A: '協定 %0 沒有定義'
# 'protocol has circular dependency'
HBFCB55FB9C5B: '協定存在循環依賴'
# "protocol has no object type specified; defaults to qualified 'id'"
H79AE64D3788F: "協定未指定物件類型；預設為已修飾的 'id'"
# 'protocol is declared here'
H63C66770E070: '協定在此處宣告'
# 'protocol method is expected to return an instance of the implementing class, but is declared to return %0'
HCECBCE2ED619: '協定方法期望返回實現類別的實例，但宣告返回 %0'
# 'protocol method is here'
H850DBE7D30DB: '協定方法在此處'
# 'protocol qualifiers must precede type arguments'
HE1585F9267E6: '協定限定符必須出現在類型參數之前'
# "provided host compiler IR file '%0' is required to generate code for OpenMP target regions but cannot be found"
H4ECB10C5BABB: "提供的主編譯器IR文件 '%0' 需要生成OpenMP目標區域的代碼，但無法找到"
# 'pseudo-destructor call is not permitted in constant expressions until C++20'
HFC660C022DFD: '在C++20之前，常量表達式中不允许使用偽析構函數調用'
# 'pseudo-destructor destroys object of type %0 with inconsistently-qualified type %1'
HFC3306882505: '偽析構函數銷毀了類型 %0 的物件，其修飾類型 %1 不一致'
# 'pseudo-destructors on type void are a Microsoft extension'
H6C76EC18D3A0: 'void類型的偽析構函數是Microsoft擴充功能'
# "public framework header includes private framework header '%0'"
H7F0AEF01704E: "公用框架標頭包含私有框架標頭 '%0'"
# 'pure virtual function %q0 called'
H3187DE144A64: '純虛函數%q0被調用'
# 'put the semicolon on a separate line to silence this warning'
HD2A85AED0A2F: '在新的一行放置分號以消除此警告'
# "putter for property must be specified as 'put', not 'set'"
H65FA70517FA4: "屬性必須指定為 'put'，而非 'set'"
# 'qualified call to %0::%1 is treated as a virtual call to %1 due to -fapple-kext'
HAEBB9D60FCD1: '%0::%1 的限定調用被視為對 %1 的虛調用，這是因-fapple-kext選項'
# 'qualified destructor name only found in lexical scope; omit the qualifier to find this type name by unqualified lookup'
H95040EDE1833: '限定的析構函數名稱僅在詞法作用域中找到；省略限定詞以透過非限定搜尋找到此類型名稱'
# 'qualified member access refers to a member in %0'
H69C8244E4885: '限定的成員存取引用 %0 的成員'
# 'qualified module name can only be used to define modules at the top level'
HCDFABF1A81DD: '限定的模組名稱只能用於頂層定義模組'
# 'qualified name refers into a specialization of %select{function|variable}0 template %1'
H4C7D694E4A70: '修飾名稱引用%select{函式|變數}0模板 %1 的特化'
# 'qualified reference to %0 is a constructor name rather than a %select{template name|type}1 in this context'
H08AE31B94F15: '修飾的 %0 引用在此上下文中是建構函數名稱而非%select{模板名稱|類型}1'
# "qualifier 'const' is needed for variables in address space '%0'"
HADB69D493623: "在地址空間 '%0' 中的變數需要 'const' 修飾"
# 'qualifier in explicit instantiation of %q0 requires a template-id (a typedef is not permitted)'
HB21409C3C5FB: '%q0的顯式實體化中的修飾需要一個template-id（不允許typedef）'
# 'qualifiers after comma in declarator list are ignored'
H09D49C9D12E0: '宣告列表中的逗號後修飾詞被忽略'
# 'qualify call to silence this warning'
HDB3D8B807347: '限定調用以消除此警告'
# 'r11 available before calls and jumps'
H69431C8A884E: 'r11在呼叫與跳轉前可用'
# 'r11 available before calls but not before jumps'
HAF3B1E936CB4: '在呼叫前可用r11，但在跳轉前不可用'
# 'r11 not available'
HD51A31809CB5: 'r11 不可用'
# "range-based 'for' statement uses ':', not '='"
HC53E3757D97C: "基於範圍的 'for' 語句使用 ':'，而非 '='"
# 'range-based for loop has empty body'
H2C4FFAA3CE47: '基於範圍的 for 迴圈有空的程式體'
# 'range-based for loop initialization statements are a C++20 extension'
H77FF5523C4B8: '基於範圍的 for 迴圈初始化語句是 C++20 的擴充功能'
# 'range-based for loop initialization statements are incompatible with C++ standards before C++20'
H529EE263FDB4: '基於範圍的 for 迴圈初始化語句與 C++20 之前的 C++ 標準不相容'
# 'range-based for loop is a C++11 extension'
HE56D92957A6D: '基於範圍的 for 迴圈是 C++11 的擴充功能'
# 'range-based for loop is incompatible with C++98'
H2229A30F511E: '基於範圍的 for 迴圈與 C++98 不相容'
# 'range-based for loop requires type for loop variable'
H07E32C6E46BC: '基於範圍的 for 迴圈需要為迴圈變數指定類型'
# 'raw string delimiter longer than 16 characters; use PREFIX( )PREFIX to delimit raw string'
H00B2DC6A7B32: '原始字串的分隔符超過 16 個字元；請使用 PREFIX( )PREFIX 來界定原始字串'
# 'raw string literals are incompatible with C++98'
H1C93D8A83CA2: '原始字串文字與 C++98 不相容'
# 'raw string missing terminating delimiter )%0"'
H7FD087037BE3: '缺少終止分隔符的原始字串 )%0"'
# "re-exported libraries do not match: '%0' (provided) vs '%1' (found)"
H6C320DEC171A: "重新導出的函式庫不匹配：'%0'（已提供）與 '%1'（已找到）"
# "re-exported library missing from %0: '%1'"
H552D4BA598A3: "'%1' 的重新導出函式庫缺少於 %0 中"
# 're-use space in old .text if possible (relocation mode)'
H05BFF380B5E6: '若可能，重新使用舊的 .text 區塊的空間（重定位模式）'
# 'read of incomplete type %0 is not allowed in a constant expression'
HCA641211FEEB: '在常數運算式中不允許讀取不完整類型 %0'
# 'read of non-const variable %0 is not allowed in a constant expression'
HD99D6E4F37A4: '在常數運算式中不允許讀取非 const 變數 %0'
# 'read of non-constexpr variable %0 is not allowed in a constant expression'
HF3D92222C519: '在常數運算式中不允許讀取非 constexpr 變數 %0'
# 'read of variable %0 of non-integral, non-enumeration type %1 is not allowed in a constant expression'
H33BFBE7CF01D: '在常數運算式中不允許讀取非整數、非列舉類型 %1 的變數 %0'
# "readonly IBOutlet property %0 when auto-synthesized may not work correctly with 'nib' loader"
H582EA0DF024A: "當自動合成唯讀 IBOutlet 屬性 %0 時，可能無法與 'nib' 載入器正確配合運作"
# 'reassign registers so as to avoid using REX prefixes in hot code'
HE2FFC9EC6F02: '重新分配寄存器以避免在熱點代碼中使用REX前綴'
# 'received warning after diagnostic serialization teardown was underway: %0'
H60ECB032353D: '在診斷序列化拆卸期間收到警告：%0'
# 'receiver %0 for class message is a forward declaration'
HAE87B957CEBD: '類別訊息的接收者 %0 是.forward declaration/'
# 'receiver %0 is a forward class and corresponding @interface may not exist'
H2EFCADD231BF: '接收者 %0 是.forward class/且對應的@interface可能不存在'
# 'receiver expression is here'
H16AA23E5E187: '接收端表達式在此處'
# 'receiver is instance of class declared here'
H063C50E49E8E: '接收者是此處宣告類別的實例'
# "receiver is treated with 'id' type for purpose of method lookup"
H23B037191711: "接收者將以 'id' 類型進行方法查找"
# 'receiver type %0 for instance message is a forward declaration'
H4107B7B01A42: '實例訊息的接收端類型 %0 是.forward declaration/'
# "receiver type %0 is not 'id' or interface pointer, consider casting it to 'id'"
HC44380DEE815: "接收端類型 %0 不是 'id' 或界面指標，建議轉型為 'id'"
# 'receiver type %0 is not an Objective-C class'
HDF1E1AF5B7B2: '接收端類型 %0 不是Objective-C類'
# 'record profile for inter-function control flow activity (default: true)'
HB3410F96E4B8: '記錄函數間控制流活動的剖析（預設：true）'
# 'recursive evaluation of default argument'
H9D22EE24805A: '預設參數的遞迴評估'
# 'recursive template instantiation exceeded maximum depth of %0'
H9F7DB4D308D0: '模板實例化超過最大深度 %0'
# "redeclaration cannot add 'loader_uninitialized' attribute"
H70EFB9FBF448: "重宣告不能添加 'loader_uninitialized' 屬性"
# 'redeclaration has different alignment requirement (%1 vs %0)'
H2965974DE860: '重宣告具有不同的對齊要求（%1 vs %0）'
# "redeclaration of %0 must %select{not |}1have the 'overloadable' attribute"
H9C609286F3D1: "重宣告 %0 必須%select{不具有 |}1'overloadable' 屬性"
# 'redeclaration of %0 with a different type%diff{: $ vs $|}1,2'
HEB05B74B4F52: '重宣告 %0 具有不同的類型 %diff{: $ vs $|}1,2'
# 'redeclaration of %q0 cannot add %q1 attribute'
H437273BF8230: '重宣告%q0不能添加%q1屬性'
# 'redeclaration of %q0 should not add %q1 attribute'
HBC3EEF68F79F: '重宣告%q0不应添加%q1屬性'
# "redeclaration of C++ built-in type 'bool'"
H4DE1B64751F8: "重新宣告C++內建類型 'bool'"
# 'redeclaration of already-defined enum %0 is a GNU extension'
H3B72AE37DEEE: '已定義的枚舉 %0 的重新宣告是GNU擴展'
# 'redeclaration of deduction guide'
H6C137FDA5914: '推導指引的重新宣告'
# 'redeclaration of method parameter %0'
H0D9F6CE9B2EA: '方法參數 %0 的重新宣告'
# 'redeclaration of type parameter %0'
HC29DAC039CAB: '類型參數 %0 的重新宣告'
# 'redeclaration of using declaration'
H96E43918A485: 'using宣告的重新宣告'
# 'redeclaration of using-enum declaration'
H7EA3B309B6C8: 'using-enum宣告的重新宣告'
# 'redeclaring non-static %0 as static is a Microsoft extension'
H853738CC6C0D: '將非靜態 %0 重新宣告為靜態是Microsoft擴展'
# 'redefining builtin macro'
H6021415EA4BB: '重新定義內建宏'
# 'redefinition of %0'
HB70C986DD184: '%0 的重新定義'
# 'redefinition of %0 as an alias for a different namespace'
H97345A757B2F: '將 %0 重新定義為不同命名空間的別名'
# 'redefinition of %0 as different kind of symbol'
H9380CBD04275: '將 %0 重新定義為不同類型的符號'
# 'redefinition of %0 will not be visible outside of this function'
H6605A7137B7E: '%0 的重新定義在這個函數之外不可見'
# 'redefinition of %0 with a different type%diff{: $ vs $|}1,2'
HB1C0A119B95E: '%0 的重新定義，類型不同%diff{：%$ vs $|}1,2'
# 'redefinition of %select{typedef|type alias}0 for variably-modified type %1'
HB599B51A5F4D: '可變長度修飾類型 %1 的 %select{typedef|類型別名}0的重新定義'
# "redefinition of a 'extern inline' function %0 is not supported in %select{C99 mode|C++}1"
HF158368144B8: '在 %select{C99模式|C++}1 中不支援重新定義extern inline函數 %0'
# 'redefinition of concept %0 with different template parameters or requirements'
H4C4283523181: '%0 概念的重新定義，其模板參數或需求不同'
# 'redefinition of default argument'
H6507C3F7227D: '預設參數的重新定義'
# 'redefinition of enumerator %0'
H1EE462BB5E46: '枚舉值 %0 的重新定義'
# 'redefinition of forward class %0 of a typedef name of an object type is ignored'
H06040CF8C316: '物件類型的typedef名稱 %0 的前向宣告類重新定義被忽略'
# 'redefinition of inferred submodule'
H43BB40E423BF: '推論子模組的重新定義'
# 'redefinition of label %0'
HD4F4A928D72C: '重新定義標籤 %0'
# 'redefinition of method parameter %0'
HE18AEF27C9A1: '重新定義方法參數 %0'
# "redefinition of module '%0'"
H6249FB58D003: "重新定義模組 '%0'"
# 'redefinition of parameter %0'
H88BE534E3F7A: '重新定義參數 %0'
# 'redefinition of typedef %0 is a C11 feature'
H8B88EC5F6F5C: '重新定義typedef %0 是C11的特性'
# 'redefinition of user-defined mapper for type %0 with name %1'
HADE614C371DA: '重新定義類型 %0 名稱為 %1 的使用者自定義.mapper'
# 'redefinition of user-defined reduction for type %0'
H4B307482E8CD: '重新定義類型 %0 的使用者自定義約束運算'
# 'redirect journaling to a file instead of stdout/stderr'
H5FEA9D013494: '將日誌記錄重導至檔案而非stdout/stderr'
# "reduction type cannot be %select{qualified with 'const', 'volatile' or 'restrict'|a function|a reference|an array}0 type"
H2D2C74F27FDF: "約束類型不可為 %select{以 'const', 'volatile' 或 'restrict' 修飾|函式|引用|陣列}0 類型"
# 'reduction variables may not be accessed in an explicit task'
H233496630504: '約束變數不可在明確任務中存取'
# "redundant #include of module '%0' appears within %1"
H3B45950DD3A3: "模組 '%0' 的重複#include 出現在 %1 內"
# 'redundant %0 availability change; only the last specified change will be used'
HE2065BD86C26: '重複的可用性變更 %0；僅最後指定的變更會被採用'
# "redundant 'sycl_kernel_entry_point' attribute"
H89B952CF4093: "重複的 'sycl_kernel_entry_point' 屬性"
# "redundant attribute subject matcher sub-rule '%0'; '%1' already matches those declarations"
HE12FF717092C: "重複的屬性主體匹配子規則 '%0'; '%1' 已匹配這些宣告"
# 'redundant move in return statement'
HC34A9F2066D1: '返回語句中的多餘移動操作'
# 'redundant parentheses surrounding declarator'
H47E8307AF60E: '包圍宣告項的多餘括號'
# "ref-qualifier '%select{&&|&}0' is not allowed on a constructor"
H5FB2827C1F13: "引用限定符 '%select{&&|&}0' 不允許用於建構函式"
# "ref-qualifier '%select{&&|&}0' is not allowed on a destructor"
H0C7698A4B274: "引用限定符 '%select{&&|&}0' 不允許用於解構函式"
# "ref-qualifier '&&' is not allowed on a defaulted comparison operator"
HE95322EAF78E: "引用限定符 '&&' 不允許用於預設的比較運算子"
# 'refactoring action cannot be initiated without a selection'
H24ED847BB22A: '未選擇範圍時無法啟動重构動作'
# 'reference %0 is not yet bound to a value when used here'
HF3E8D22129FD: '引用 %0 在此處使用時尚未綁定到一個值'
# 'reference %0 is not yet bound to a value when used within its own initialization'
HB4996BB1A27E: '引用 %0 在自身的初始化中使用時尚未綁定到一個值'
# 'reference %diff{to %select{type|incomplete type}1 $ could not bind to an %select{rvalue|lvalue}2 of type $|could not bind to %select{rvalue|lvalue}2 of incompatible type}0,3'
HFAC2C332E9F4: '引用 %diff{到 %select{類型|不完整類型}1 $ 無法綁定到類型 $ 的 %select{rvalue|lvalue}2|無法綁定到不相容類型的 %select{rvalue|lvalue}2}0,3'
# 'reference binding of non-type template parameter %diff{of type $ to template argument of type $|to template argument}0,1 ignores qualifiers'
H093001BBE364: '非類型模板參數 %diff{類型 $ 到類型 $ 的模板參數|到模板參數}0,1 的引用綁定忽略修飾符'
# 'reference cannot be bound to dereferenced null pointer in well-defined C++ code; comparison may be assumed to always evaluate to %select{true|false}0'
H136F139EE8E6: '引用無法綁定到符合語法的C++程式碼中的解引用空指標；比較可能被假設始終評估為 %select{true|false}0'
# 'reference cannot be bound to dereferenced null pointer in well-defined C++ code; pointer may be assumed to always convert to true'
H5320A7915E7F: '引用無法綁定到符合語法的C++程式碼中的解引用空指標；指標可能被假設始終轉換為 true'
# 'reference cannot be initialized with multiple values'
HE7DB5FCEC436: '引用無法用多個值進行初始化'
# 'reference cannot bind to bit-field in converted constant expression'
HF5063530D4A6: '引用無法綁定到轉換後的常量表達式中的位段'
# 'reference dynamic_cast failed: %select{static type %1 of operand is a non-public base class of dynamic type %2|dynamic type %2 of operand does not have a base class of type %3|%3 is an ambiguous base class of dynamic type %2 of operand|%3 is a non-public base class of dynamic type %2 of operand}0'
H4859449FAD67: 'reference dynamic_cast failed: %select{操作數的靜態類型 %1 是動態類型 %2 的非公開基類|操作數的動態類型 %2 沒有類型 %3 的基類|%3 是操作數動態類型 %2 的多態基類|%3 是操作數動態類型 %2 的非公開基類}0'
# 'reference initialization of type %0 with initializer of type %1 is ambiguous'
HB988A3E86777: '類型 %0 的引用初始化與初始化器類型 %1 存在歧義'
# 'reference initialized from initializer list is incompatible with C++98'
HCD4C182EF998: '來自初始化清單的引用初始化與C++98不相容'
# 'reference member of type %0 uninitialized'
HC2805DCE0AFC: '類型 %0 的引用成員未初始化'
# 'reference of type %0 cannot bind to a temporary object because of address space mismatch'
HF0C3B633C49A: '類型 %0 的引用因地址空間不匹配而無法綁定到臨時物件'
# 'reference qualifiers on functions are a C++11 extension'
H41B9EC19F32B: '函數上的引用限定詞是C++11擴展'
# 'reference qualifiers on functions are incompatible with C++98'
HF044E58F9C25: '函數上的引用限定詞與C++98不相容'
# 'reference to %0 is ambiguous'
H97A6825DEB56: '對 %0 的引用存在歧義'
# 'reference to %select{__device__|__global__|__host__|__host__ __device__}0 %select{function|variable}1 %2 in %select{__device__|__global__|__host__|__host__ __device__}3 function'
H43094BC1789F: '在 %select{__device__|__global__|__host__|__host__ __device__}3 函數中引用 %select{__device__|__global__|__host__|__host__ __device__}0 %select{函數|變數}1 %2'
# 'reference to %select{__device__|__global__|__host__|__host__ __device__}0 function %1 in global initializer'
H76762B8F478F: '在全域初始化器中引用 %select{__device__|__global__|__host__|__host__ __device__}0 函數 %1'
# 'reference to %select{destructor|pseudo-destructor}0 must be called%select{|; did you mean to call it with no arguments?}1'
H3484C551C20A: '必須呼叫 %select{析構函數|偽析構函數}0%select{|；您是否想要以無參數呼叫它？}1'
# 'reference to %select{overloaded|multiversioned}1 function could not be resolved; did you mean to call it%select{| with no arguments}0?'
HA7DE06C12730: '對 %select{重載|多版本}1 函數的引用無法解析；您是否想要以 %select{|無參數}0呼叫它？'
# "reference to a %select{bit-field|vector element|global register variable}0 in asm %select{input|output}1 with a memory constraint '%2'"
HCCFE4F550EEB: '在asm的%select{輸入|輸出}1中引用具有記憶體約束‘%2’的%select{位段|向量元素|全域寄存器變數}0'
# "reference to enumeration must use 'enum' not 'enum %select{struct|class}0'"
HDC33545DFD9E: "引用枚舉時必須使用 'enum' 而不是 'enum %select{struct|class}0'"
# 'reference to local %select{variable|binding}1 %0 declared in enclosing %select{%3|block literal|lambda expression|context}2'
H9B72122A433C: '在封閉的 %select{%3|區塊字面量|lambda expression|上下文}2中宣告的局部%select{變數|綁定}1 %0 被引用'
# "reference to marker '%0' is ambiguous"
HD452BD6D3FB0: '引用標記‘%0’是模稜兩可的'
# 'reference to non-static member function must be called%select{|; did you mean to call it with no arguments?}0'
H472EE5EB17CD: '引用非靜態成員函數必須被呼叫 %select{|; 您是否想要呼叫時不帶參數？}0'
# 'reference to type %0 cannot bind to an initializer list'
H9194F3CD2BD5: '類型 %0 的引用無法綁定到初始值列表'
# 'reference to type %0 requires an initializer'
HD97076E9024C: '類型 %0 的引用需要初始值設定項'
# 'reference to unresolved using declaration'
H4256A6DE4B09: '引用未解決的using宣告'
# 'referenced %0 is declared here'
HE1EBB7B8DBAD: '被引用的 %0 在此宣告'
# 'referenced member %0 is declared here'
H8DB9210452D3: '被引用的成員 %0 在此宣告'
# "referring to 'main' within an expression is a Clang extension"
H5EC3F4017EE7: "在運算式中引用 'main' 是Clang的擴充功能"
# "region cannot be%select{| closely}0 nested inside '%1' region%select{|; perhaps you forget to enclose 'omp %3' directive into a parallel region?|; perhaps you forget to enclose 'omp %3' directive into a for or a parallel for region with 'ordered' clause?|; perhaps you forget to enclose 'omp %3' directive into a target region?|; perhaps you forget to enclose 'omp %3' directive into a teams region?|; perhaps you forget to enclose 'omp %3' directive into a for, simd, for simd, parallel for, or parallel for simd region?}2"
H9F4A9870BA07: "%select{|緊密}0嵌套在 '%1' 區域內 %select{|; 可能您忘記將 'omp %3' 指令包圍在平行區域中？|; 可能您忘記將 'omp %3' 指令包圍在帶有 'ordered' 子句的for或parallel for區域中？|; 可能您忘記將 'omp %3' 指令包圍在target區域中？|; 可能您忘記將 'omp %3' 指令包圍在teams區域中？|; 可能您忘記將 'omp %3' 指令包圍在for、simd、for simd、parallel for或parallel for simd區域中？}2"
# "register '%0' unsuitable for global register variables on this target"
HAC3AEFE8413B: '此目標上寄存器‘%0’不適合用於全域寄存器變數'
# 'register number should be an integer'
H932EE02D1B8E: '寄存器號碼應為整數'
# 'register pressure factor for the transformations.'
H44776CA40899: '轉換的寄存器壓力因素。'
# 'register space cannot be specified on global constants'
H7D24E3150A81: '無法在全域常數上指定寄存器空間'
# 'reimplementation of category %1 for class %0'
H30BD90819E63: '為類別 %0 重新實作類別 %1'
# 'reimplementation of class %0'
HD4142B86FCD9: '類別 %0 的重新實作'
# 'reinterpret_cast cannot resolve overloaded function %0 to type %1'
H60D5F589023C: 'reinterpret_cast無法將重載函數 %0 解析為類型 %1'
# 'reinterpret_cast from %0 to %1 has undefined behavior'
H1A1328A6B1E4: '從 %0 到 %1 的reinterpret_cast行為未定義'
# 'reinterpret_cast of a %0 to %1 needs its address, which is not allowed'
H8633F993884D: '將 %0 重新詮釋為 %1 的reinterpret_cast需要其地址，但這並未被允許'
# "releasing %0 '%1' that was not held"
HD16686A7FEA7: "釋放未持有的 %0 '%1'"
# "releasing %0 '%1' using %select{shared|exclusive}2 access, expected %select{shared|exclusive}3 access"
H2106963D41B0: "使用%select{共享|獨佔}2存取方式釋放 %0 '%1'，期望%select{共享|獨佔}3存取方式"
# 'remainder by zero in preprocessor expression'
HE098B5222CAD: '在預處理表達式中除以零'
# 'remaining %0 candidate%s0 omitted; pass -fshow-overloads=all to show them'
HD0784BB8E50F: '省略 %0 個候選項；使用-fshow-overloads=all參數顯示所有候選項'
# 'remap file source paths <old> to <new> in coverage mapping. If there are multiple options, prefix replacement is applied in reverse order starting from the last one'
HD493DCAA04BC: '在覆蓋率映射中將來源路徑 <old> 重映射為 <new>。若有多個選項，則按反向順序從最後一個開始套用前綴替換'
# 'remap file source paths in debug info, coverage mapping, predefined preprocessor macros and __builtin_FILE(). Implies -ffile-reproducible.'
HD15C7DEA6A6F: '在除錯資訊、覆蓋率映射、預定義預處理宏和__builtin_FILE()中重映射來源路徑。隱含-ffile-reproducible參數。'
# 'remap file source paths in predefined preprocessor macros and __builtin_FILE(). Implies -ffile-reproducible.'
H6FA3D7D85AF9: '在預定義預處理宏和__builtin_FILE()中重映射來源路徑。隱含-ffile-reproducible參數。'
# 'remarks_a'
H1F5563CE509E: 'remarks_a'
# 'remarks_b'
H40EB09D856D2: 'remarks_b'
# "remove '_Noreturn'"
H4CD6C2426BE8: "移除 '_Noreturn'"
# "remove 'enum%select{| struct| class}0' to befriend an enum"
H9CF5F9198489: "移除 'enum%select{| struct| class}0' 以與枚舉建立友元關係"
# "remove 'u8' prefix to avoid a change of behavior; Clang encodes unprefixed narrow string literals as UTF-8"
H40BFCE51D12C: '移除u8前綴以避免行為變化；Clang將未加前綴的窄字元字串字面量編碼為UTF-8'
# 'remove call to max function and unsigned zero argument'
H746EE2CAAC37: '移除max函數調用及無符號零參數'
# 'remove constant to silence this warning'
H8233E14B9765: '移除常數以消除此警告'
# 'remove double jumps when able'
H144AFE550114: '當可能時移除雙重跳轉'
# 'remove extraneous parentheses around the comparison to silence this warning'
H7C576B6A85C7: '移除比較運算子周圍的多餘括號以消除此警告'
# 'remove parentheses to declare a variable'
H29AB7F8F0D04: '移除括號以宣告變數'
# 'remove parentheses to silence this warning'
HBB1C1AF59745: '移除括號以消除此警告'
# 'remove std::move call here'
H87B3A4171A2A: '在此處移除std::move調用'
# "remove the %select{'%1' if its condition|condition if it}0 is always %select{false|true}2"
HE5C66C3841AD: "移除 %select{'%1' 如果其條件|條件如果它}0始終為 %select{false|true}2"
# "remove the call to '%0' since unsigned values cannot be negative"
H3BE7257796E7: "移除對 '%0' 的呼叫，因為無符號值不能為負數"
# 'remove the kernel-info pass at the end of the full LTO pipeline'
HE9CC6C17C11E: '移除完整LTO管線末尾的kernel-info pass'
# 'remove useless conditional branches'
H7F773F483924: '移除無效的條件分支'
# "rename '%0' to ensure it can be found by name"
H730151DC5720: "重新命名 '%0' 以確保能通過名稱找到"
# 'reorder and cluster functions (works only with relocations)'
HB96EDA278BFF: '重新排序並群組函數（僅與重新定位一起使用）'
# 'reorder data sections in place'
HCACEBAE7CFC3: '就地重新排序資料區段'
# 'reorder functions randomly'
HA61C4AF88653: '隨機重新排序函數'
# 'reorder three way branches'
HF6331B33926D: '重新排序三向分支'
# 'reorder unconditional jump instructions in loops optimization'
H61D641F1F0CA: '在循環優化中重新排序無條件跳轉指令'
# "repeated RISC-V 'interrupt' attribute"
HE9564BE7AF0F: "重複的RISC-V 'interrupt' 屬性"
# "repeated RISC-V 'interrupt' attribute is here"
H2C65B1A1835B: "重複的RISC-V 'interrupt' 屬性在此處"
# 'repeated evaluation of the same literal expression can produce different objects'
H816EF14DCA64: '對同一字面運算式的重複評估可能產生不同的物件'
# "replace 'default' with 'delete'"
H6143A5F8A323: "將 'default' 替換為 'delete'"
# "replace expression with '%0' %select{|or use 'xor' instead of '^' }1to silence this warning"
H8BD6D24EAB4A: "將運算式替換為 '%0' %select{|或改用 'xor' 代替 '^' }1以消除此警告"
# 'replace parentheses with an initializer to declare a variable'
H1CB1AEAC6164: '使用初始化器替換括號以宣告變數'
# "replacement function %0 cannot be declared 'inline'"
H8E774898376D: "替代函數 %0 不能被宣告為 'inline'"
# 'report accesses through a pointer which has poisoned shadow'
HDB29EEB5BF15: '報告通過具有被污染影子的指標進行的存取'
# 'report stats in csv'
H4FBFD3CEA227: '以CSV格式報告統計數據'
# 'report stats in text'
HDFF33DBA8938: '以文字格式報告統計數據'
# "requested 'init_priority' %0 is reserved for internal use"
H2E025E570ED5: "要求的 'init_priority' %0 保留供內部使用"
# 'requested alignment %0 is not a positive power of two'
H9C01C430B004: '要求的對齊 %0 不是正的二的冪次方'
# 'requested alignment is dependent but declaration is not dependent'
H9D546DA38E42: '要求的對齊依賴於某個條件，但宣告本身並非依賴性宣告'
# 'requested alignment is less than minimum alignment of %1 for type %0'
H9E0857E89F1F: '要求的對齊小於類型 %0 的最小對齊 %1'
# 'requested alignment is not a power of 2'
HC6B6240D895B: '要求的對齊不是二的冪次方'
# 'requested alignment must be %0 bytes or smaller'
H7B9D334BA24B: '要求的對齊必須小於或等於 %0 個字節'
# 'requested alignment must be %0 bytes or smaller; maximum alignment assumed'
HCDB68D900AC4: '要求的對齊必須小於或等於 %0 個字節；假設使用最大對齊'
# 'requested alignment must be %0 or greater'
H097A66E5C9B7: '要求的對齊必須大於或等於 %0'
# 'requested alignment must be %0 or less for type %1; %2 is invalid'
H6B97FB634040: '類型 %1 的要求對齊必須小於或等於 %0；%2 無效'
# 'requested alignment must be %0 or smaller'
HEC3786C66ADB: '要求的對齊必須小於或等於 %0'
# 'requested shift is a vector of type %0 but the first operand is not a vector (%1)'
H149741EFCCA5: '要求的位移運算是類型 %0 的向量，但第一個操作數不是向量 (%1)'
# 'required alignment of type %0 (%1 bytes) is larger than the supported alignment of C++ exception objects on this target (%2 bytes)'
HFFCA5AAB79EE: '類型 %0 的必要對齊 (%1 個字節) 超過此目標對 C++ 例外物件支援的最大對齊 (%2 個字節)'
# "required by %select{'require_constant_initialization' attribute|'constinit' specifier}0 here"
H669C2D015B6E: "由這裡的 %select{'require_constant_initialization' 屬性|'constinit' 指定符}0 所要求"
# 'requires clause differs in template redeclaration'
H3C91EEDA34FA: 'requires 子句在範型重新宣告中不同'
# "requires expression in requirement body; did you intend to place it in a nested requirement? (add another 'requires' before the expression)"
H818E1323CB5B: "在需求主體中出現 requires 表達式；您是否想將其置於嵌套需求中？（在表達式前再添加 'requires'）"
# "reserved locator 'omp_all_memory' cannot be specified more than once"
HBB5542941955: "保留的定位符 'omp_all_memory' 不得指定超過一次"
# "reserved locator 'omp_all_memory' requires 'out' or 'inout' dependency types"
H98614BF4F5B5: "保留的定位符 'omp_all_memory' 需要 'out' 或 'inout' 依賴類型"
# 'resolve all otherwise unresolved externals to null'
H0D8FB57C5D95: '將所有未解決的外部符號解析為空值'
# 'respect alignment requirements provided by input IR'
H3C9B5ECCDE76: '尊重輸入 IR 提供的對齊需求'
# 'restrict requires a pointer or reference'
H044B0871CB3F: 'restrict 需要指標或參考'
# 'restrict requires a pointer or reference (%0 is invalid)'
HB4AA3977DC42: 'restrict 需要指標或引用（%0 無效）'
# "result argument to %select{overflow builtin|checked integer operation}0 must be a pointer to a non-const integer type %select{|other than plain 'char', 'bool', bit-precise, or an enumeration }0(%1 invalid)"
HD81ECBB4661A: "%select{溢位內建函數|已檢查整數運算}0的結果參數必須是對非const整數類型的指標 %select{|（不包括普通 'char'、'bool'、精確位元或列舉類型）}0（%1 無效）"
# "result of '%0' is %1; did you mean '%2' (%3)?"
H369683737B3D: "'%0' 的結果是 %1；您是否是指 '%2'（%3）？"
# "result of '%0' is %1; did you mean '%2'?"
H1B6516041439: "'%0' 的結果是 %1；您是否是指 '%2'？"
# "result of '%0' is %1; did you mean exponentiation?"
H6BDF285BA0FF: "'%0' 的結果是 %1；是否是指指數運算？"
# 'result of comparison %select{%3|%1}0 %2 %select{%1|%3}0 is always %4'
H3D76D2CD2831: '比較運算結果 %select{%3|%1}0 %2 %select{%1|%3}0 始終為 %4'
# 'result of comparison against %select{a string literal|@encode}0 is unspecified (use an explicit string comparison function instead)'
H42F5B6822163: '與 %select{字串常數|@encode}0 的比較結果未定義（請改用明確的字串比較函數）'
# 'result of comparison of %select{%3|char expression}0 %2 %select{char expression|%3}0 is always %4, since char is interpreted as unsigned'
H2652DE195D69: '比較 %select{%3|字元運算式}0 %2 %select{字元運算式|%3}0 的結果始終為 %4，因字元被視為無符號型別'
# 'result of comparison of %select{%3|unsigned enum expression}0 %2 %select{unsigned enum expression|%3}0 is always %4'
H86DA5A0E3154: '比較 %select{%3|無符號列舉運算式}0 %2 %select{無符號列舉運算式|%3}0 的結果始終為 %4'
# 'result of comparison of %select{%3|unsigned expression}0 %2 %select{unsigned expression|%3}0 is always %4'
HABA37A2C23DF: '比較 %select{%3|無符號運算式}0 %2 %select{無符號運算式|%3}0 的結果始終為 %4'
# 'result of comparison of %select{%4|%1-bit %select{signed|unsigned}2 value}0 %3 %select{%1-bit %select{signed|unsigned}2 value|%4}0 is always %5'
H3E54DBA92461: '%select{%4|%1 位 %select{有符號|無符號}2 數值}0 %3 %select{%1 位 %select{有符號|無符號}2 數值|%4}0 的比較結果始終為 %5'
# 'result of comparison of %select{constant %0|true|false}1 with %select{expression of type %2|boolean expression}3 is always %4'
H0604EEA5685E: '%select{常量 %0|true|false}1 與 %select{類型 %2 的運算式|布林運算式}3 的比較結果始終為 %4'
# "result of comparison of constant %0 with expression of type 'BOOL' is always %1, as the only well defined values for 'BOOL' are YES and NO"
H641A75823917: "與 'BOOL' 類型的運算式進行常數 %0 比較，結果始終為 %1，因 'BOOL' 的明確定義值僅有YES和NO"
# "retain'ed block property does not copy the block - use copy attribute instead"
HD7F1D5C5B0F0: '建構函數嘗試區塊的 catch 區塊中傳回為非法操作'
# 'return in the catch of a function try block of a constructor is illegal'
HBC7FDA21A80E: '建構函式函數嘗試區塊中的 catch 區塊中使用 return 語句是非法的'
# "return state set for an unconsumable type '%0'"
H2753EF9C9B3B: "為不可消耗類型 '%0' 設置了回傳狀態"
# "return statement not allowed in coroutine; did you mean 'co_return'?"
HD15AAC2A320B: "協程中禁止使用 return 語句；是否應改為使用 'co_return'？"
# "return type %0 of selected 'operator==' function for rewritten '%1' comparison is not 'bool'"
HC9853B2276CB: "改寫 '%1' 比較運算式時所選 'operator==' 函數的返回類型 %0 非 'bool'"
# 'return type cannot be qualified with address space'
H90249355EB7F: '傳回型別推論與 C++14 之前的 C++ 標準不相容'
# 'return type deduction is incompatible with C++ standards before C++14'
HB4A5F5EFADA6: '返回類型推導不兼容 C++14 之前的 C++ 標準'
# "return type for defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator must be 'bool', not %1"
H2EF639AB940D: "預設的 %select{<ERROR>|等值|三向|等值|關係}0 比較運算子的返回類型必須為 'bool'，而非 %1"
# "return type of 'await_ready' is required to be contextually convertible to 'bool'"
H043CECD8EB91: "'await_ready' 的返回類型必須能隱式轉換為 'bool'"
# "return type of 'await_suspend' is required to be 'void' or 'bool' (have %0)"
H64AB2C323A61: "'await_suspend' 的返回類型必須為 'void' 或 'bool'（目前為 %0）"
# "return type of 'coroutine_handle<>::address should be 'void*' (have %0) in order to get capability with existing async C API"
HA713CB41D910: "'coroutine_handle<>::address 的返回類型需為 'void*'（目前為 %0）以符合現有的異步 C API"
# "return type of 'main' is not 'int'"
HFBAC240E8034: "'main' 的返回類型非 'int'"
# "return type of defaulted 'operator<=>' cannot be deduced because return type %2 of three-way comparison for %select{|member|base class}0 %1 is not a standard comparison category type"
H424FC8A53CC9: "預設 'operator<=>' 的返回類型無法推導，因 %select{|成員|基類}0 %1 的三向比較返回類型 %2 非標準比較類別類型"
# "return type of defaulted 'operator<=>' cannot be deduced because three-way comparison for %select{|member|base class}0 %1 has a deduced return type and is not yet defined"
H0105A22E2A8D: "預設 'operator<=>' 的返回類型無法推導，因 %select{|成員|基類}0 %1 的三向比較運算式返回類型為推導型態且尚未定義"
# 'return type of out-of-line definition of %q0 differs from that in the declaration'
H469315680A98: '%q0 的實作定義與宣告的返回類型不符'
# 'return type of virtual function %0 is not covariant with the return type of the function it overrides (%1 has different qualifiers than %2)'
H00BA4129869D: '虛函數 %0 的返回類型與它覆寫的函數返回類型不協變（%1 的修飾符與 %2 不同）'
# 'return type of virtual function %0 is not covariant with the return type of the function it overrides (%1 is incomplete)'
HE8582E3BF357: '虛函數 %0 的返回類型與其覆寫函數的返回類型無協變關係（%1 為未完整類型）'
# 'return type of virtual function %0 is not covariant with the return type of the function it overrides (%1 is not derived from %2)'
H5A21B37900C4: '虛函數 %0 的返回類型與其覆寫函數的返回類型無協變關係（%1 非 %2 的派生類）'
# 'return type of virtual function %0 is not covariant with the return type of the function it overrides (class type %1 does not have the same cv-qualification as or less cv-qualification than class type %2)'
H2AB9EE663373: '虛函數 %0 的返回類型與它覆寫的函數返回類型不協變（類型 %1 的cv修飾符與類型 %2 不同或更少）'
# 'return type of virtual function %3 is not covariant with the return type of the function it overrides (ambiguous conversion from derived class %0 to base class %1:%2)'
H94F1AF985110: '虛函數 %3 的返回類型與它覆寫的函數返回類型不協變（派生類 %0 到基類 %1 的轉換存在歧義：%2）'
# "return value not in expected state; expected '%0', observed '%1'"
H8EF54209E2EA: "返回值不在期望狀態；期望 '%0'，觀察到 '%1'"
# 'return value of %0 is a large (%1 bytes) pass-by-value object; pass it by reference instead ?'
HA1B074D05D38: '%0 的返回值是大型（%1 位元組）傳遞值參數的物件；建議改用傳參考方式傳遞？'
# 'returning %select{address of|reference to}0 local temporary object'
H0D9CD7C30605: '%select{取址|引用}0局部暫時物件作為返回值'
# 'returning address of label, which is local'
H7C6FDC7A79CE: '返回存活於局部堆疊的區塊'
# 'returning block that lives on the local stack'
HFB5C6DCAD180: '返回局部堆疊上的區塊指標'
# "returning pointer %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
H524B3D4E5221: "返回指標 %1 需要持有 %0 %select{'%2'|'%2' 獨佔}3"
# "returning pointer to variable %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
HC47B423E80E3: "返回 %1 變數的指標需要持有 %0 %select{'%2'|'%2' 獨佔}3"
# 'returning reference to local temporary object'
H3C7B38DADD40: '返回局部暫時物件的引用'
# "returning the value that %1 points to by reference requires holding %0 %select{'%2'|'%2' exclusively}3"
HDFB7294684C5: "以引用返回 %1 所指的值需要持有 %0 %select{'%2'|'%2' 獨佔}3"
# "returning variable %1 by reference requires holding %0 %select{'%2'|'%2' exclusively}3"
H5E5D0E85F387: "以引用返回 %1 變數需要持有 %0 %select{'%2'|'%2' 獨佔}3"
# "rewriter doesn't support user-specified control flow semantics for @try/@finally (code may not execute properly)"
H9C522D3EEF6D: '重寫器不支援使用者指定的@try/@finally控制流程語法（程式碼可能無法正確執行）'
# 'rewriting block literal declared in global scope is not implemented'
HC8DC37202696: '重寫在全域作用域中宣告的區塊字面量尚未實作'
# 'rewriting sub-expression within a macro (may not be correct)'
H72B7281F7712: '重寫宏內的子運算式（結果可能不正確）'
# 'right hand operand to %0 has non-pointer-to-member type %1'
H53A963FA3084: '%0 的右操作元具有非成員指標類型 %1'
# "right shifting a 'bool' implicitly converts it to 'int'"
HEDBEE20D2831: "對 'bool' 進行右位移隱式轉換為 'int'"
# 'rocPrim path, required by the HIP Standard Parallel Algorithm Acceleration library, used to implicitly include the rocPrim library'
HD40BA7FFEFEE: 'rocPrim 路徑，rocPrim 庫加速 HIP 標準平行演算法的必要元件，用於隱含包含 rocPrim 庫'
# 'rocThrust path, required by the HIP Standard Parallel Algorithm Acceleration library, used to implicitly include the rocThrust library'
H2F4B1626A7F1: 'rocThrust 路徑，rocThrust 庫加速 HIP 標準平行演算法的必要元件，用於隱含包含 rocThrust 庫'
# 'run retpoline insertion pass'
H57D5B6539CD2: '執行 retpoline 插入 pass'
# 'run veneer elimination pass'
HC2BE3F62417A: '執行 veneer 消除 pass'
# "runpath search paths do not match: '%0' (provided) vs '%1' (found)"
H2CB428691FF3: "執行路徑搜尋路徑不相符：'%0'（指定）與 '%1'（實際）"
# "runpath search paths missing from %0: '%1'"
H427437B03484: "執行路徑搜尋路徑缺少於 %0：'%1'"
# 'rvalue reference %diff{to type $ cannot bind to lvalue of type $|cannot bind to incompatible lvalue}0,1'
H5D62614FC181: '右值引用 %diff{類型 $ 的右值引用無法綁定到類型 $ 的左值|無法綁定到不相容的左值}1,0'
# 'rvalue reference type %0 is not allowed in exception specification'
H63B188C37A7C: '右值引用類型 %0 不允許在例外規格中使用'
# 'rvalue references are a C++11 extension'
HE6F99D294F8D: '右值引用是 C++11 擴充功能'
# 'rvalue references are incompatible with C++98'
HBB045EE53C13: '右值引用與 C++98 不相容'
# 'safe buffers debug: %0'
H6B8774B1FDA7: '安全緩衝區除錯： %0'
# 'safety buffer size'
H48F48464759C: '安全緩衝區大小'
# 'same map type modifier has been specified more than once'
HE40C50BE338F: '相同的 map 子句類型修飾符被指定超過一次'
# 'same motion modifier has been specified more than once'
H855EE2722E18: '相同的 motion 修飾符被指定超過一次'
# 'same pointer dereferenced in multiple different ways in map clause expressions'
H176F03468FDB: '同一指標在 map 子句表達式中以多種不同方式解引用'
# 'sampler initializer has invalid %0 bits'
H18D45D49E7B9: '取樣器初始化器具有無效的 %0 位元'
# 'sampler type cannot be used with the __local and __global address space qualifiers'
H2695DF30EE8D: '取樣器類型不能與 __local 和 __global 位址空間限定詞一起使用'
# 'sampler_t initialization requires 32-bit integer, not %0'
HB7C873D08ECC: 'sampler_t 初始化需要 32 位元整數，而非 %0'
# 'sampler_t variable required - got %0'
H54F7785F9F3D: '需要 sampler_t 變數 - 獲取到 %0'
# 'sanstats Options'
H8526EFD0A943: 'sanstats 選項'
# "satisfaction of constraint '%0' depends on itself"
H3716B39C40C1: "限制條件 '%0' 的滿足取決於其自身"
# 'save recorded profile to a file'
H0DD7B7A894BB: '將記錄的剖析資料儲存至檔案'
# 'scalar initialized from empty initializer list is incompatible with C++98'
H4040E7512491: '初始化自空初始化清單的純量與C++98的返回類型不相容'
# 'scalar initializer cannot be empty'
HD3067EEE76AC: '純量初始化式不能為空'
# 'scalar operand type has greater rank than the type of the vector element. (%0 and %1)'
H2C50DCFF8689: '純量運算元類型的階級高於向量元素的類型. (%0 和 %1)'
# 'scale argument must be 1, 2, 4, or 8'
H325DB8FF3A78: 'scale參數必須為 1、2、4或 8'
# 'scale factor for the latch probability. Value should be greater than 1. Lower values are ignored'
HAACE1BBE5003: 'latch機率的scale因子。值必須大於 1，較小的值將被忽略'
# 'scale of asan shadow mapping'
H538257B2498C: 'asan陰影映射的scale因子'
# 'scale of memprof shadow mapping'
H256DA014D3E2: 'memprof陰影映射的scale因子'
# 'scale to be applied while reporting dyno stats'
H9327CA23C998: '在報告dyno統計資料時應用的scale因子'
# 'scoped enumeration requires a name'
H38F857947248: '作用域列舉需要名稱'
# 'scoped enumerations are a C++11 extension'
H880FA70730D4: '作用域列舉是C++11的擴充功能'
# 'scoped enumerations are incompatible with C++98'
H8FFFE671E01D: '作用域列舉與C++98不相容'
# 'score expressions in the OpenMP context selector need to be constant; %0 is not and will be ignored'
HBAE673BA4B11: 'OpenMP上下文選擇器中的評分表達式必須為常數；%0 不是且將被忽略'
# "search path used: '%0'"
H5005F53FE066: "使用的搜尋路徑：'%0'"
# "second argument to 'va_arg' is of ARC ownership-qualified type %0"
H5B02CB112F2F: "'va_arg' 的第二個參數為ARC擁有權修飾類型 %0"
# "second argument to 'va_arg' is of abstract type %0"
HB0CBA3C6712C: "'va_arg' 的第二個參數為抽象類型 %0"
# "second argument to 'va_arg' is of array type %0; this va_arg has undefined behavior because arguments will never be compatible with array type"
H0271D72D02D0: "'va_arg' 的第二個參數為陣列類型 %0；此va_arg因參數永遠無法與陣列類型相容而有未定行為"
# "second argument to 'va_arg' is of incomplete type %0"
HBAB6DD203AC7: "'va_arg' 的第二個參數為不完整類型 %0"
# "second argument to 'va_arg' is of non-POD type %0"
H6E23523199DB: "'va_arg' 的第二個參數為非POD類型 %0"
# "second argument to 'va_arg' is of promotable type %0; this va_arg has undefined behavior because arguments will be promoted to %1"
HD77AAC429CAF: 'va_arg的第二個參數是可提升的類型 %0；此va_arg具有未定義行為，因為參數將被提升為 %1'
# "second argument to 'va_start' is not the last non-variadic parameter"
H37CA82AB0144: 'va_start的第二個參數不是最後一個非可變參數'
# 'second argument to __builtin_alloca_with_align is supposed to be in bits'
HF3ADBC91450B: '__builtin_alloca_with_align的第二個參數應以位元為單位'
# 'second argument to __builtin_annotation must be a non-wide string constant'
HB28F8D41E677: '__builtin_annotation的第二個參數必須是非寬字元常數'
# 'second argument to __builtin_call_with_static_chain must be of pointer type'
H9D3B291ADD1F: '__builtin_call_with_static_chain的第二個參數必須是指標類型'
# 'section attribute is specified on redeclared variable'
H4BE9B9505588: 'section屬性指定在重新宣告的變數上'
# 'section length is evaluated to a negative value %0'
HDAA24A68E89D: 'section長度被評估為負值 %0'
# 'section length is unspecified and cannot be inferred because subscripted value is %select{not an array|an array of unknown bound}0'
HD324F8149A40: 'section長度未指定且無法推導，因為下標值是%select{非陣列|未知維度的陣列}0'
# 'section of pointer to function type %0'
HDFC73840E7DC: 'section的指標指向函數類型 %0'
# 'section of pointer to incomplete type %0'
HFA4996C0EBB1: 'section的指標指向不完整類型 %0'
# 'section stride is evaluated to a non-positive value %0'
H2C7B2A05B911: 'section的間隔被評估為非正數 %0'
# 'see attribute on parameter here'
HDD0675B1BF06: '參見此處參數上的屬性'
# 'seed for randomization'
HD63DCBC599F4: '隨機化種子'
# "selected '%select{begin|end}0' %select{function|template }1%2 with iterator type %3"
H752B6650220E: "選擇 '%select{begin|end}0' %select{函數|範本 }1%2，其迭代器類型為 %3"
# "selected 'operator<=>' for %select{|member|base class}0 %1 declared here"
H810A0D73AD55: "選擇 'operator<=>' 給 %select{|成員|基類}0 %1，該處宣告"
# 'selector element is not a valid lvalue'
H0BFE26B0616A: '選擇器元素不是有效的左值'
# 'selector element of type %0 cannot be a constant lvalue expression'
H9F3EFE55FA69: '類型 %0 的選擇器元素不能是常量左值表達式'
# 'selector element type %0 is not a valid object'
HED5168FB3348: '選擇器元素類型 %0 不是有效的物件'
# 'semantic annotations must be present for all parameters of an entry function or patch constant function'
H8F1EA44B7AC0: '入口函數或修補常數函數的所有參數都必須有語義註解'
# 'semicolon before method body is ignored'
H600E31190711: '方法主體前的分號被忽略'
# 'semicolon terminating header import declaration cannot be produced by a macro'
HD5CFDD7201E4: '分號結尾的頭檔導入宣告不能由宏產生'
# 'set format in which header info is emitted'
H2BE1FC27A3B2: '設定發送頭檔資訊的格式'
# 'set the flag that enables filtering header information'
H433BB7B2C953: '設定用以過濾頭檔資訊的旗標'
# 'set the incremental array construction buffer size (default=32)'
H062EDCFEADF9: '設定增量陣列建構緩衝區大小（預設=32）'
# 'set verbosity level for diagnostic output'
HA7F31A34A582: '設定診斷輸出的詳細程度'
# 'sets a boolean flag for every edge'
H5B3492ACEF7D: '為每個邊設定布林旗標'
# 'setter and getter must both be synthesized, or both be user defined, or the property must be nonatomic'
H13B288111B84: 'Setter和getter必須同時為合成，或同時為使用者定義，或該屬性必須為nonatomic'
# 'setter cannot be specified for a readonly property'
H0B75386E5DBF: '不能為readonly屬性指定setter'
# 'setting the floating point evaluation method to `source` on a target without SSE is not supported'
H3CBE26190DE7: '在無SSE的目標上將浮點數評估方法設定為`source`不受支援'
# 'several methods with selector %0 of mismatched types are found for the @selector expression'
H992F0A773FBB: '在@selector運算式中找到具有選擇子 %0 但類型不匹配的多個方法'
# 'share stubs across functions'
H4D76BB47577B: '在函數間共用存根'
# 'shift count %0 >= width of type %1 (%2 bit%s2)'
HF6F9C4B1183E: '位移次數 %0 >= 類型 %1 的位元數（%2 bit%s2）'
# 'shift count >= width of type'
H64BC6739BC0B: '位移次數 >= 類型的位元數'
# 'shift count is negative'
H49401E14D24E: '位移次數為負數'
# 'shifting a negative signed value is undefined'
H08F0D0D67884: '對負數有符號值進行位移是未定義的'
# 'shorten instructions'
H31FAC4015C01: '簡化指令'
# 'show a graph.'
HDBFEE5F65752: '顯示圖形。'
# 'show execution count of functions in binary 2 as a ratio of the total samples in binary 1 - make sure both profiles have equal collection time and sampling rate for this to make sense'
H7302A3496B1D: '以二進位 1 的總取樣數為基準，顯示二進位 2 中函數的執行次數比率 - 確保兩個配置文件具有相同的收集時間和取樣率，才能讓此顯示有意義'
# 'show in text.'
H8201270E0209: '以文字顯示。'
# 'show profile density details'
HA588BE6E194B: '顯示配置文件密度細節'
# 'show section contents after fixups have been applied'
HF6C65D702470: '顯示修復後的區段內容'
# 'signed bit-field %0 needs an extra bit to represent the largest positive enumerators of %1'
HE118008121A9: '已符號的位段 %0 需要額外的位元來表示 %1 的最大正枚舉值'
# 'signed left shift discards bits'
HD469BF80AF3C: '已符號的左位移會遺失位元'
# 'signed shift result (%0) requires %1 bits to represent, but %2 only has %3 bits'
HC5B9F5083ED5: '已符號的位移結果 (%0) 需要 %1 個位元來表示，但 %2 只有 %3 個位元'
# "signed shift result (%0) sets the sign bit of the shift expression's type (%1) and becomes negative"
H95CD10E060D8: '已符號的位移結果 (%0) 設置了位移運算式類型 (%1) 的符號位元，並變成負數'
# "signedness of format specifier '%0' is incompatible with '%1'"
H0E3D0B14B46F: "格式指定項 '%0' 的符號性與 '%1' 不相容"
# 'signing a null pointer will yield a non-null pointer'
H25C3D501EB46: '將 null 指針轉換為有符號的指針會產生非 null 指針'
# 'silence by adding parentheses to mark code as explicitly dead'
H99754744B060: '透過添加括號標記代碼為明確的死代碼以消除警告'
# 'similar constraint expression here'
HC25A9009F181: '這裡有類似的約束運算式'
# 'similar constraint expressions not considered equivalent; constraint expressions cannot be considered equivalent unless they originate from the same concept'
H671259A4BAC3: '不同來源的約束運算式不視為等效；約束運算式除非源自同一個概念，否則不能視為等效'
# "similar to '-lite-threshold-pct' but specify threshold using absolute function call count. I.e. limit processing to functions executed at least the specified number of times."
HAE7D7FD96C23: "類似 '-lite-threshold-pct'，但使用絕對函數調用次數指定閾值。換句話說，僅處理執行次數至少達到指定次數的函數。"
# 'simple ddg dot graph'
H18F32B7E23D9: '簡易 DDG DOT 圖表'
# 'simple-rename options'
H99366DD6F3BD: '簡易重命名選項'
# 'simplify conditional tail calls by removing unnecessary jumps'
H041707E8A1C3: '透過移除不必要的跳轉來簡化條件尾部調用'
# 'simplify loads from read-only sections by replacing the memory operand with the constant found in the corresponding section'
H05E90663FB35: '透過將記憶體運算元替換為對應區段中找到的常數，來簡化從唯讀區段的載入'
# "single declaration is expected after 'declare %select{simd|variant}0' directive"
H178440D95E1D: "在 'declare %select{simd|variant}0' 指令後面期望單一宣告"
# 'single subscript expressions are not allowed for matrix values'
H6751A19F6DB9: '矩陣值不允許使用單一索引運算式'
# 'size argument in %0 call appears to be size of the source; expected the size of the destination'
HA69933A2CC96: '%0 呼叫中的大小參數似乎為源的大小；期望目標的大小'
# 'size argument in %0 call is a comparison'
HAC4E42C8E89B: '%0 函數呼叫中的大小參數是比較運算式'
# "size argument in 'strncat' call appears to be size of the source"
HBE6DF8480F3A: "'strncat' 函數呼叫中的大小參數似乎是來源的大小"
# 'size must be %select{1, 2, or 4|1, 2, 4, 12 or 16}0'
H5666676F632D: '大小必須為 %select{1, 2 或 4|1, 2, 4, 12 或 16}0'
# "size of '__builtin_bit_cast' source type %0 does not match destination type %1 (%2 vs %3 bytes)"
HE2800B62712B: '__builtin_bit_cast 的源類型 %0 與目標類型 %1 的大小不匹配（%2 對 %3 個位元組）'
# 'size of a heat map block in bytes (default 64)'
HF50CC8CAD0AC: '熱地圖區塊的大小（以位元組為單位，預設值 64）'
# "size of array element of type %0 (%1 bytes) isn't a multiple of its alignment (%2 bytes)"
H64B3D7C6AA54: '類型 %0 的陣列元素大小（%1 個位元組）不是其對齊值（%2 個位元組）的倍數'
# 'size of array has non-integer type %0'
HE09F852059B1: '陣列的大小具有非整數類型 %0'
# 'size of feature field in .altinstructions'
H2B6C1D1A943E: '.altinstructions 中的特徵欄位大小'
# "size of register '%0' does not match variable size"
HECA9BDA68860: "寄存器 '%0' 的大小與變數大小不匹配"
# 'sizeof on array function parameter will return size of %0 instead of %1'
HFA0A8C5A6400: '陣列函式參數上的 sizeof 將返回 %0 的大小而非 %1'
# 'sizeof on pointer operation will return size of %0 instead of %1'
H23C83EADD90C: '指標運算上的 sizeof 將返回 %0 的大小而非 %1'
# 'skip access specifiers'
HB22E60CB51DB: '跳過存取修飾詞'
# 'skip calling convention'
HA89A2E2093C7: '跳過呼叫約定'
# 'skip member types'
HE3F86CF4D54B: '跳過成員類型'
# 'skip non-simple functions in reporting'
H7F9F6F20766F: '在報告中跳過非簡單函式'
# 'skip perf and read data from a pre-aggregated file format'
H38F758DFB377: '跳過 perf 資料收集，改從已聚合的檔案格式讀取資料'
# 'skip perf event collection by supplying a perf-script output in a textual format'
HD6505A3AF86B: '跳過 perf 事件收集，改供應文字格式的 perf-script 輸出'
# 'skip processing of cold functions'
H2FAB1AD4A339: '跳過冷函式的處理'
# 'skip return types'
H3988159D97D2: '跳過傳回類型'
# 'skip variable types'
H1C4CB11B7B2B: '跳過變數類型'
# "skipping '%0' because module declaration of '%1' lacks the 'framework' qualifier"
H07A078D1E04E: "跳過 '%0'，因為模組宣告 '%1' 缺少 'framework' 修飾符"
# 'skipping stray token'
HF5D19BFCA4A8: '跳過孤立的記號'
# 'sort hot data by hot function usage and count'
H35D38C633287: '按熱函數使用情形和計數排序熱數據'
# 'sort hot data by read counts'
HC3E7276E6170: '按此欄位排序輸出'
# 'sort ordering'
HE318259881C5: '排序順序'
# 'sort output by this field'
H610F666D308E: '按此欄位排序輸出'
# 'sort stack allocations'
HB4DFBCC44FE6: '按堆疊配置排序堆疊配置'
# 'sorted by all names'
H8915B99CE6ED: '按所有名稱排序'
# 'source file is not valid UTF-8'
HDC95C446AFAD: '來源檔案不是有效的UTF-8編碼'
# 'source manager location address space usage:'
H7D02F3625956: '來源管理器位置位址空間使用情形：'
# 'specialization of member %q0 does not specialize an instantiated member'
H7EB7CDEAD3CD: '成員%q0的特化未特化已實例化的成員'
# 'specified %0 type tag requires a null pointer'
HEFCCEFE3C17F: '指定的 %0 類型標籤需要空指標'
# 'specifies thread count for the multithreading for updating DWO debug info'
H230218760941: '指定多執行緒更新DWO除錯資訊的執行緒數量'
# 'specify a target CPU'
H6DAAF9946704: '指定目標CPU'
# 'specify a target triple'
H91E21A4D2F5C: '指定目標三元組'
# 'specify a tune CPU'
H484461AF94A8: '指定調諧CPU'
# 'specify path of the runtime hugify library'
H05DF4B0878FF: '指定執行階段hugify函式庫的路徑'
# 'specify path of the runtime instrumentation library'
HC0D79561313D: '指定執行階段插樁函式庫的路徑'
# 'specify that .altinstructions has padlen field'
H09DED786C540: '指定目標功能'
# 'specify the target features'
H68C8195F1EB5: '指定目標功能'
# "specifying 'uuid' as an ATL attribute is deprecated; use __declspec instead"
H12B975086F19: "將 'uuid' 指定為 ATL 屬性已棄用；請改用 __declspec"
# 'specifying OpenMP directives with [[]] is an OpenMP 5.1 extension'
H4B0556017370: '使用 [[]] 指定 OpenMP 指令是 OpenMP 5.1 的擴充功能'
# 'specifying OpenMP directives with [[]] is incompatible with OpenMP standards before OpenMP 5.1'
H8022C700FE36: '使用 [[]] 指定 OpenMP 指令與 OpenMP 5.1 之前的標準不相容'
# 'specifying an identifier within `#pragma pack` is not supported on this target'
H6F2B8F9FE9C4: '在 `#pragma pack` 中指定標識符在此目標平台上不受支援'
# "specifying both a name and alignment to 'pop' is undefined"
HC71C880E8806: "同時指定名稱和對齊至 'pop' 是未定義的行為"
# "specifying character '%0' with a universal character name is incompatible with C standards before C23"
H9E4A97D8B259: "使用通用字符名指定字元 '%0' 與 C23 之前的 C 標準不相容"
# "specifying character '%0' with a universal character name is incompatible with C++98"
H2678BC1F681E: "使用通用字符名指定字元 '%0' 與 C++98 不相容"
# "specifying vector types with the 'mode' attribute is deprecated; use the 'vector_size' attribute instead"
H29212F917029: "使用 'mode' 屬性指定向量類型已棄用；請改用 'vector_size' 屬性"
# 'speculative load hardening does not protect functions with asm goto'
H95EDE5332D8C: '預測性載入強化無法保護使用 asm goto 的函數'
# 'spirv.$TypedPointerType'
HDE833BFC0A0D: 'spirv.$TypedPointerType'
# 'split C++ exception handling code'
H77F537E188DE: '分割 C++ 例外處理程式碼'
# 'split all basic blocks of each function into fragments such that each fragment contains exactly a single basic block'
H4736D758A4A7: '將每個函數的所有基本區塊分割為片段，使每個片段恰好包含單一基本區塊'
# 'split each function into N fragments at a randomly chosen split points (ignoring any available profiling information)'
H5EA52FAFF0B6: '以隨機選擇的分割點將每個函數分割為 N 個片段（忽略任何可用的剖面資料）'
# 'split each function into a hot and cold fragment at a randomly chosen split point (ignoring any available profiling information)'
H2575993535E9: '以隨機選擇的分割點將每個函數分割為 hot 和 cold 片段（忽略任何可用的剖面資料）'
# 'split each function into a hot and cold fragment using profiling information'
H6FB4CEE61F8E: '使用剖面資料將每個函數分割為 hot 和 cold 片段'
# 'split each function into a hot, warm, and cold fragment using profiling information'
H39753BA1C3E6: '使用剖面資料將每個函數分割為 hot、warm 和 cold 片段'
# 'split function only if its main size is reduced by more than given amount of bytes. Default value: 0, i.e. split iff the size is reduced. Note that on some architectures the size can increase after splitting.'
H80577181729E: '僅當函數主體大小減少超過指定的位元組數時才分割函數。預設值：0，即僅當大小減少時才分割。注意部分架構在分割後大小可能增加。'
# 'split functions into fragments'
HE833096B1246: '將函數分割為片段'
# 'split jump tables section into hot and cold based on function execution frequency'
H593FAF497273: '根據函數執行頻率將跳轉表區段分割為 hot 和 cold 兩部分'
# 'split-file Options'
HDBFADA679092: '分割檔案選項'
# "stack frame size (%0) exceeds limit (%1) in '%2'"
HCF0AF62F4A65: "堆疊框架大小（%0）超過限制（%1）在 '%2' 中"
# 'stack nearly exhausted; compilation time may suffer, and crashes due to stack overflow are likely'
HD310C1B31961: '堆疊空間接近耗盡；編譯時間可能延長，且因堆疊溢位導致的崩潰風險增加'
# "standard library implementation of %0 is not supported; %select{member '%2' does not have expected form|member '%2' is missing|the type is not trivially copyable|the type does not have the expected form}1"
H8A51A30A514F: "標準函式庫實作的 %0 不受支援；%select{成員 '%2' 沒有期望的形態|成員 '%2' 缺失|類型無法進行簡單複製|類型沒有期望的形態}1"
# 'standard library not linked and so no interrupt vector table or compiler runtime routines will be linked'
H3B6E22A7AD97: '未連結標準函式庫，因此不會連結中斷向量表或編譯器執行期函式'
# 'star modifier used outside of function prototype'
HA2B9806ED1A1: '函式原型外部使用星號修飾符'
# "state of variable '%0' must match at the entry and exit of loop"
H7D285ABC5B72: "變數 '%0' 的狀態在迴圈入口和出口處必須一致"
# "statement after '#pragma omp dispatch' must be a direct call to a target function or an assignment to one"
H172FE1A4272E: '#pragma omp dispatch 後的語句必須是對目標函數的直接呼叫，或對目標函數的賦值'
# "statement associated with OpenACC 'atomic%select{| %1}0' directive is invalid"
H42056AC9B64A: "與 OpenACC 'atomic%select{| %1}0' 指令關聯的語句無效"
# "statement attribute %0 has higher precedence than function attribute '%select{always_inline|flatten|noinline}1'"
H0AF92FCED836: "語句屬性 %0 的優先級高於函式屬性 '%select{always_inline|flatten|noinline}1'"
# 'statement expression not allowed at file scope'
HB4FE90B7D7C8: '無法在文件作用域使用語句運算式'
# "statement in 'omp %0' directive must be enclosed into a section region"
H69791FF123D5: "'omp %0' 指令中的語句必須包含在區段區域內"
# 'statement not allowed in %select{constexpr|consteval}1 %select{function|constructor}0'
HD56C75E5841E: '不允許在 %select{constexpr|consteval}1 %select{函數|建構子}0 中使用該語句'
# 'statement requires expression of integer type (%0 invalid)'
H752828F0ECD0: '語句需要整數類型的運算式（%0 無效）'
# 'statement requires expression of scalar type (%0 invalid)'
HFBBF3A578FA4: '語句需要純量類型的運算式（%0 無效）'
# 'static %0 runtime is not supported on darwin'
H52FFB37B4DFA: '在 darwin 平台上不支援靜態 %0 運行時'
# 'static %select{function|variable}0 %1 is used in an inline function with external linkage'
HBAA29A669BB7: '外部連結的內聯函式中引用了靜態 %select{函數|變數}0 %1'
# 'static and non-static member functions with the same parameter types cannot be overloaded'
H455410FE204F: '具有相同參數類型的靜態和非靜態成員函數無法進行重載'
# 'static assertion expression is not an integral constant expression'
H4896ABC370E3: '靜態斷言運算式不是整數型態的常量運算式'
# "static assertion failed due to requirement '%0'%select{: %2|}1"
H3D43CA56F16F: "靜態斷言因要求 '%0'%select{：%2|}1 未被滿足而失敗"
# 'static assertion failed%select{: %1|}0'
H4F7EABF6B0DD: '靜態斷言失敗%select{：%1|}0'
# 'static const volatile data member must be initialized out of line'
H407C919E04E8: 'static const volatile 成員變數必須在外部初始化'
# 'static data member %0 already has an initializer'
H6ACB0F956377: '靜態資料成員 %0 已經有初始值設定'
# 'static data member %0 in union is a C++11 extension'
HA330F37BE63B: '聯結體中的靜態資料成員 %0 是C++11擴充功能'
# 'static data member %0 in union is incompatible with C++98'
HEBF9EACD8366: '聯結體中的靜態資料成員 %0 與C++98不相容'
# 'static data member %0 not allowed in anonymous %select{struct|interface|union|class|enum}1'
HC964FFEFDD87: '在匿名%select{結構|介面|聯結體|類別|列舉}1中不允许有靜態資料成員 %0'
# 'static data member %0 not allowed in local %select{struct|interface|union|class|enum}2 %1'
HA56CE2DF143E: '在區域%select{結構|介面|聯結體|類別|列舉}2 %1 中不允许有靜態資料成員 %0'
# 'static data member definition cannot specify a storage class'
HF3222609AACF: '靜態資料成員的定義不能指定儲存類別'
# 'static data member of type %0 must be initialized out of line'
H4598A36D5110: '類型為 %0 的靜態資料成員必須在外部初始化'
# 'static declaration of %0 follows non-static declaration'
H2C721D0B8C3C: '對 %0 的靜態宣告跟在非靜態宣告之後'
# 'static lambdas are a C++23 extension'
H0728106ADDA2: '靜態lambda表達式是C++23的擴充功能'
# 'static lambdas are incompatible with C++ standards before C++23'
H81C85F6C724E: '靜態lambda表達式與C++23之前的標準不相容'
# 'static member %0 cannot be a bit-field'
HDFCBA261B7FE: '靜態成員 %0 不能是位段'
# 'static members cannot be declared in an anonymous %select{struct|union}0'
HF2CC0A1A3C82: '無法在匿名%select{結構|聯結體}0中宣告靜態成員'
# 'static variable %0 is suspiciously used within its own initialization'
H1CCD7A0167D8: '在自身初始化時使用靜態變數 %0 可能有問題'
# 'static_cast between pointer-to-function and pointer-to-object is a Microsoft extension'
H747267A37B70: '將函式指標轉換為物件指標的static_cast是Microsoft的擴充功能'
# "std::coroutine_handle isn't a class template"
H20FD07579F32: 'std::coroutine_handle不是類模板'
# "std::coroutine_handle must have a member named '%0'"
HC01B7EC5D8D7: "std::coroutine_handle必須有一個名為 '%0' 的成員"
# "std::coroutine_traits isn't a class template"
H3D3F8F520E5F: 'std::coroutine_traits不是類模板'
# 'std::initializer_list must be a class template with a single type parameter'
H57E56532E11C: 'std::initializer_list必須是帶有一個型別參數的類模板'
# 'std::nothrow must be a valid variable declaration'
H81985EEDEA6B: 'std::nothrow 必須是有效的變數宣告'
# 'std::nothrow was not found; include <new> before defining a coroutine which uses get_return_object_on_allocation_failure()'
H553185766FEB: '未找到std::nothrow；在定義使用get_return_object_on_allocation_failure()的協程前，請包含 <new> 頭檔'
# "step simple modifier is exclusive and cannot be use with 'val', 'uval' or 'ref' modifier"
H61FE9B0F27A0: 'step 簡單修飾符是專屬的，不能與val、uval或ref修飾符併用'
# 'still within definition of %q0 here'
HE0627D20A1B5: '在此處的%q0 定義仍處於作用域內'
# 'stop processing once we have enough to compare two binaries'
H5E734E25A522: '一旦取得足夠資訊用以比較兩二進位檔時即停止處理'
# 'storage class specified for a member declaration'
HE2F76CA3682F: '為成員宣告指定儲存類別'
# 'store PCHs in memory'
HAE2E8E366E23: '將PCH檔存在記憶體中'
# 'store PCHs on disk'
HB5252992D5B4: '將PCH檔存在磁碟上'
# 'strategy used to partition blocks into fragments'
H892362B1790A: '用以將區塊分割為碎片的策略'
# 'stress rotate selection in aggressive ppc isel for bit permutations'
HAC5B66207D31: '在積極的ppc指令選擇中對位元排列進行壓力旋轉選擇'
# 'strftime format attribute requires 3rd parameter to be 0'
H48F53118805C: 'strftime 格式特性需要第三個參數為 0'
# 'stride must be greater or equal to the number of rows'
H8F8F20EB9F60: '間隔值必須大於或等於列數'
# 'string is ill-formed as UTF-8 and will become a null %0 when boxed'
H978281414E51: '此UTF-8格式有誤的字串在封裝後將成為空值 %0'
# "string literal after 'operator' cannot have an encoding prefix"
HE2D46EB90348: '操作符後面的字串字面量不能有編碼前綴'
# 'string literal after \'operator\' must be \'""\''
HB2C541BB7B81: '操作符後面的字串字面量必須為空字串""'
# 'string literal of length %0 exceeds maximum length %1 that %select{C90|ISO C99|C++}2 compilers are required to support'
H446F1FE51F67: '長度為 %0 的字串字面量超過 %select{C90|ISO C99|C++}2 編譯器必須支援的最大長度 %1'
# 'string literal operator templates are a GNU extension'
HC7C4AAEBD81D: '字串字面量操作符範本是GNU擴充語法'
# 'string literal with user-defined suffix cannot be used here'
H0A403620271A: '帶有使用者定義後綴的字串字面量在此處不可用'
# 'string literals that exceed this length will use a hash value as their symbol name'
HA27BA101BC94: '超過此長度的字串字面量將使用雜湊值作為符號名稱'
# 'string to set default kind values'
H7121B365791A: '設定預設類型值的字串'
# "strip 'repz' prefix from 'repz retq' sequence (on by default)"
H5E0A0D55638D: "從 'repz retq' 序列中移除 'repz' 前綴（預設啟用）"
# 'structured binding declaration in a condition is a C++2c extension'
H7AF1E5D1A2D0: '條件中的結構化綁定宣告是 C++2c 的擴充功能'
# 'structured binding declaration in a condition is incompatible with C++ standards before C++2c'
HD456E18D0B36: '條件中的結構化綁定宣告與 C++2c 之前的標準不相容'
# 'structured binding packs are a C++2c extension '
H041F82FB15BE: '結構化綁定包是 C++2c 的擴充功能'
# 'structured binding packs are incompatible with C++ standards before C++2c'
HD48DDFF6186B: '結構化綁定包與 C++2c 之前的標準不相容'
# 'structurize SPIRV'
H886FBF76EA85: '結構化 SPIRV'
# 'style of printing regions'
H063C50F12566: '區域列印的風格'
# 'subcommand'
H146947FFD26E: '子命令'
# 'subexpression not valid in a constant expression'
H9779A11486AE: '在常數運算式中無效的子運算式'
# 'submodule %0.%1 not declared in module map'
H1DA53EDBF661: 'module map 中未宣告子模組 %0.%1'
# "submodule of top-level module '%0' implicitly imported here"
HDAE6F5126C46: "頂層模組 '%0' 的子模組在此處隱含導入"
# 'subobject %select{of type |}0%1 is not initialized'
HF2C7BC6C2C0D: '子物件 %select{類型為 |}0%1 未初始化'
# 'subobject declared here'
H554F161157BC: '子物件在此處宣告'
# 'subscript of a pointer to void is a GNU extension'
H3CC7AA95FFD8: 'void 指標的下標運算是 GNU 的擴充功能'
# 'subscript of pointer to %select{incomplete|sizeless}0 type %1'
H1AFEC4E5E6B6: '指標至 %select{不完整|無大小}0 類型 %1 的下標運算'
# 'subscript of pointer to function type %0'
H768DEE928692: '函式類型 %0 指標的下標運算'
# 'subscript of svbool_t is not allowed'
H8F54745267C0: 'svbool_t 的下標運算不被允許'
# 'subscript requires size of interface %0, which is not constant for this architecture and platform'
H10B94DBD4388: '下標運算需要介面 %0 的大小，但該大小在這套架構與平台上並非常數'
# 'subscripted value is not an array or pointer'
HFC1E308C6B30: '下標運算的物件不是陣列或指標'
# 'subscripted value is not an array, pointer, or vector'
H1F892D50B541: '下標運算的物件不是陣列、指標或向量'
# 'substitution failure due to access control is incompatible with C++98'
H09899E5F733A: '因存取控制導致的代換失敗與C++98不相容'
# 'substitution into constraint expression resulted in a non-constant expression'
H0CC3DD33E92E: '代換約束式產生非常數運算式'
# 'subtracted pointers are not elements of the same array'
HBF5BC0994673: '相減的指標不是同一陣列的元素'
# 'subtraction of pointers to type %0 of zero size'
HAE88E507C99F: '類型 %0 大小為零的指標相減'
# 'subtraction of pointers to type %0 of zero size has undefined behavior'
H238100FAEBF4: '類型 %0 大小為零的指標相減行為未定義'
# 'suffix with parentheses to turn this into a function call'
HBA5C36C9B0F9: '加上括號後綴將此轉換為函式呼叫'
# 'suggest braces around initialization of subobject'
H122DA545D844: '建議用大括號包圍子物件的初始化'
# 'sum of call durations'
H97819C630794: '呼叫持續時間的總和'
# "support for '/Yc' and '/Yu' with different filenames not implemented yet; flags ignored"
HC924164CBDE2: "'/Yc' 和 '/Yu' 使用不同檔名尚未實作；標記被忽略"
# "support for '/Yc' with more than one source file not implemented yet; flag ignored"
H7450874B7BA1: "'/Yc' 使用超過一個來源檔尚未實作；標記被忽略"
# 'support for HLSL language version %0 is incomplete, recommend using %1 instead'
H68BB4F93A02C: 'HLSL 語言版本 %0 支援不完整，建議改用 %1'
# "support for linking stdlibs for microcontroller '%0' is not implemented"
H8995E8434A04: "為微控制器 '%0' 連結標準函式庫的支援尚未實作"
# "support for passing the data section address to the linker for microcontroller '%0' is not implemented"
H870D8231D796: "為微控制器 '%0' 將資料區段位址傳遞給連結器的支援尚未實作"
# 'surrounding namespace with visibility attribute ends here'
H4297D0DA8CEA: '包含可見性屬性的周圍命名空間結束處'
# 'surrounding namespace with visibility attribute starts here'
HA543A7B12EEA: '包含可見性屬性的周圍命名空間開始處'
# 'suspicious concatenation of string literals in an array initialization; did you mean to separate the elements with a comma?'
HE00F78FF32CA: '陣列初始化中可疑的字面字串連接；您是否想要用逗號分隔這些元素？'
# 'switch condition has boolean value'
HA563E9019204: '切換條件具有布林值'
# 'switch condition has incomplete class type %0'
HD68BA6071310: 'switch 條件具有不完整的類型 %0'
# 'switch condition type %0 requires explicit conversion to %1'
HF719378BC596: 'switch 條件類型 %0 需要顯式轉換為 %1'
# 'switch statement has empty body'
HD379C27E8554: 'switch 語句的主體為空'
# "symbol exported in dynamic library, but marked hidden in declaration '%0'"
H493627372D47: "在動態庫中導出的符號，但在宣告 '%0' 中被標記為隱藏"
# 'symbol sort order'
H13E171348CDC: '符號排序順序'
# 'symbolize function ids from the input log'
HBDC90FB5E310: '符號化解析輸入日誌中的函數識別碼'
# 'symbolize functions'
H4B741D643A7C: '符號化解析函數'
# 'synchronization scope argument to atomic operation is invalid'
HE1E237FB50C9: '原子運算的同步範圍參數無效'
# 'synthesized properties %0 and %1 both claim instance variable %2'
H9EA52B48540E: '合成屬性 %0 和 %1 共同聲稱實例變量 %2'
# 'synthesized properties %0 and %1 both claim setter %2 - use of this setter will cause unexpected behavior'
HA9255CAB38EC: '合成屬性 %0 和 %1 共同聲稱設定器 %2 - 使用此設定器將導致意外行為'
# 'synthesized property %0 must either be named the same as a compatible instance variable or must explicitly name an instance variable'
HC10D22B3B816: '合成屬性 %0 必須與兼容的實例變量同名，或明確指定實例變量'
# 'synthesized property with variable size type %0 requires an existing instance variable'
H594CC555D195: '可變大小類型 %0 的合成屬性需要現有的實例變量'
# 'synthesized setter %0 for null_resettable property %1 does not handle nil'
H95960177BFF3: 'null_resettable 屬性 %1 的合成設定器 %0 未處理 nil'
# 'synthesizing __weak instance variable of type %0, which does not support weak references'
H1E4EBACF7211: '__weak 實例變量的類型 %0 不支援弱引用'
# 'system diff used by change reporters'
HBA4E429740F6: '由變更報告器使用的系統差異'
# 'system dot used by change reporters'
H9A7274B114C8: '由變更報告器使用的系統圖'
# 'tail blocks whose size (in bytes) exceeds the value are never duplicated'
HDC606CA00EBA: '大小（以位元組為單位）超過該值的尾部區塊從未被複製'
# 'tail blocks with size (in bytes) not exceeding the value are always duplicated'
H2F3A5FED8EF0: '大小（以位元組為單位）未超過該值的尾部區塊始終被複製'
# 'tail call required by %0 attribute here'
H9FB91CA4B73B: '%0 屬性在此處需要尾調用'
# 'tail call requires that the return value, all parameters, and any temporaries created by the expression are trivially destructible'
HE303C40B04A3: '尾呼叫要求返回值、所有參數以及表達式所創建的任何暫存物件都可簡便銷毀'
# 'taking address of a capture is not allowed'
H35418F9DEF58: '取得捕獲的位址是不允許的'
# 'taking address of function is not allowed'
H4A30B839C6AB: '取得函式位址是不允許的'
# 'taking address of non-addressable standard library function'
H3ACD682CFC45: '取得不可取位址的標準函式庫函式'
# 'taking address of non-addressable standard library function is incompatible with C++20'
H888C6C415192: '取得不可取位址的標準函式庫函式與C++20不相容'
# 'taking address of packed member %0 of class or structure %q1 may result in an unaligned pointer value'
HD700C27ED0FC: '取得類別或結構 %q1 的緊湊成員 %0 的位址可能會導致未對齊的指標值'
# 'taking the absolute value of %select{pointer|function|array}0 type %1 is suspicious'
HDEB21F2512CF: '對 %select{指標|函式|陣列}0 類型 %1 取絕對值可能有疑慮'
# 'taking the absolute value of unsigned type %0 has no effect'
H8F6DAEC8BECD: '對無符號類型 %0 取絕對值沒有任何效果'
# 'taking the address of a destructor'
H7B853F7C78AC: '取得析構函數的位址'
# 'taking the address of a temporary object of type %0'
HD39DC5626A0A: '取得類型 %0 的暫存物件的位址'
# 'taking the max of %select{a value and unsigned zero|unsigned zero and a value}0 is always equal to the other value'
H75EF0725015B: '取 %select{一個值和無符號零|無符號零和一個值}0 的最大值始終等於另一個值'
# 'target %select{constructor|destructor}0 is declared here'
HD59E728E618B: '目標 %select{建構函數|析構函數}0 在此處宣告'
# "target '%0' does not support exception handling; 'catch' block is ignored"
H06DD0F5375FE: "目標 '%0' 不支援例外處理；'catch' 區塊被忽略"
# "target '%0' does not support exception handling; 'throw' is assumed to be never reached"
H29FDCCFA5847: "目標 '%0' 不支援例外處理；'throw' 假設永遠不會被執行到"
# "target '%0' is not a supported OpenMP host target"
H6B6204612E53: "目標 '%0' 不是支援的OpenMP主機目標"
# "target '%0' is unsupported by -fsanitize-kcfi-arity"
HCFEF0540C5A0: "目標 '%0' 不受 -fsanitize-kcfi-arity 支援"
# 'target construct with nested teams region contains statements outside of the teams construct'
HB05FDB001094: '帶有嵌套團隊區域的目標建構包含位於團隊建構之外的語句'
# "target does not support 'protected' visibility; using 'default'"
H9354CE031F68: "目標不支援 'protected' 可見性；使用 'default'"
# 'target exception specification is not superset of source'
H14AD31786EFD: '目標例外規格不是來源的超集'
# 'target function %select{is a member of different class%diff{ (expected $ but has $)|}1,2|has different number of parameters (expected %1 but has %2)|has type mismatch at %ordinal3 parameter%diff{ (expected $ but has $)|}1,2|has different return type%diff{ ($ expected but has $)|}1,2}0'
HFEFD6F95E799: '目標函數%select{是不同類別的成員%diff{（期望$但有$）|}1,2|參數數量不一致（期望 %1 但有 %2 個）|第%ordinal3 個參數類型不符%diff{（期望$但有$）|}1,2|回傳類型不同%diff{（期望$但有$）|}1,2}0'
# 'target function has calling convention %1 (expected %0)'
HE7D037C49FE5: '目標函數的呼叫約定為 %1（期望 %0）'
# 'target of using declaration'
HCB1C9C62D72D: 'using宣告的目標'
# 'target of using declaration conflicts with declaration already in scope'
H5C1974A3FA23: 'using宣告的目標與作用域內已存在的宣告衝突'
# 'target profile option (-T) is missing'
HD96117F3AEE8: '目標配置檔選項（-T）遺失'
# 'target-attribute based function overloads are not supported by NVCC and will be treated as a function redeclaration:new declaration is %select{__device__|__global__|__host__|__host__ __device__}0 function, old declaration is %select{__device__|__global__|__host__|__host__ __device__}1 function'
H48B3A7876AE7: '基於目標屬性的函數多載不受NVCC支援，將視為函數重新宣告：新宣告是 %select{__device__|__global__|__host__|__host__ __device__}0 函數，舊宣告是 %select{__device__|__global__|__host__|__host__ __device__}1 函數'
# 'tbd'
H1D9C8AC0B205: 'tbd'
# 'template %0 has no definition and no %select{|viable }1deduction guides for deduction of template arguments'
H39A2D17F6485: '模板 %0 沒有定義，也%select{找不到|找不到可行的 }1模板參數推導指引'
# 'template argument / label address difference / what did you expect?'
H4022196FB5B0: '模板參數/標籤位址差異/你期望的是什麼？'
# 'template argument does not refer to a class or alias template, or template template parameter'
H10B27B45B43C: '模板參數未指向類別或別名模板，或模板模板參數'
# 'template argument for non-type template parameter is treated as function type %0'
HF7C463216541: '非類型模板參數的模板參數被視為函數類型 %0'
# 'template argument for non-type template parameter must be an expression'
HA6F518CB9F6F: '非類型模板參數的模板參數必須是運算式'
# 'template argument for template template parameter must be a class template%select{| or type alias template}0'
H4605CB1853A3: '模板模板參數的模板參數必須是類別模板 %select{|或類型別名模板}0'
# 'template argument for template type parameter must be a type'
H9FFBB255FD4F: '模板類型參數的模板參數必須是類型'
# "template argument for template type parameter must be a type; did you forget 'typename'?"
H477EE50BCF4B: "模板類型參數的模板參數必須是類型；是否遺忘了 'typename'？"
# "template argument for template type parameter must be a type; omitted 'typename' is a Microsoft extension"
H0CC2569F4810: "模板類型參數的模板參數必須是類型；遺漏 'typename' 是Microsoft擴充"
# 'template argument is the type of an unresolved overloaded function'
H1DDFBAF8CEBB: '模板參數是未解析的多載函數類型'
# 'template argument refers to function template %0, here'
H59E0A4B6EEC0: '模板參數引用函數模板 %0，位置在此'
# 'template argument uses local type %0'
H8CFAA5F55F9C: '模板參數使用局部類型 %0'
# 'template argument uses unnamed type'
H1A9FF29A8094: '模板參數使用未命名類型'
# 'template declaration from hidden source: %0'
H607A13711E91: '隱藏來源的模板宣告：%0'
# 'template is declared here'
H8B583108C6ED: '模板在此處宣告'
# 'template name refers to non-type template %0'
HD8E4D2A7EC89: '模板名稱引用非類型模板 %0'
# 'template non-type parameter has a different type %0 in template %select{|template parameter }1redeclaration'
H29D49A380D2B: '模板的非類型參數在模板 %select{|模板參數 }1重新宣告中有不同的類型 %0'
# 'template non-type parameter has a different type %0 in template argument'
H83C8844C296B: '模板的非類型參數在模板參數中具有不同的類型 %0'
# "template parameter '%0' is already documented"
H4188A9C61053: "模板參數 '%0' 已經被文檔化"
# "template parameter '%0' not found in the template declaration"
H1A80B68DAC8D: "在模板宣告中找不到模板參數 '%0'"
# 'template parameter declared here'
HC6CFA91EE1C1: '模板參數在此處宣告'
# 'template parameter default argument is inconsistent with previous definition'
H6440E4D1834B: '模板參數的預設參數與先前定義不一致'
# 'template parameter from hidden source: %0'
HE652270F3F6D: '隱藏來源的模板參數：%0'
# 'template parameter has a different kind in template %select{|template parameter }0redeclaration'
HBF82CEEA37C8: '模板參數在模板 %select{|模板參數 }0重新宣告中有不同的種類'
# 'template parameter has a different kind in template argument'
H8F8F50E907A1: '模板參數在模板參數中具有不同的種類'
# 'template parameter has different kinds in different translation units'
H8BA5D6787AFF: '模板參數在不同的翻譯單元中有不同的種類'
# 'template parameter is declared here'
H6B3C8DC0FA6A: '模板參數在此處宣告'
# 'template parameter is used in default argument declared here'
HF0F9ED98885D: '此處宣告的預設參數使用了模板參數'
# 'template parameter list also declared here'
H1F8E29374B19: '模板參數列表也在此處宣告'
# "template parameter list for literal operator must be either 'char...' or 'typename T, T...'"
H409CCC2DB745: "字面運算子的模板參數列表必須是 'char...' 或 'typename T, T...'"
# "template parameter list matching the non-templated nested type %0 should be empty ('template<>')"
HE4D93F6B6699: "與非模板巢狀類型 %0 相匹配的模板參數列表應為空（'template<>'）"
# 'template parameter lists have a different number of parameters (%0 vs %1)'
HB5785F1417CF: '模板參數清單的參數數量不同（%0 vs %1）'
# 'template parameter missing a default argument'
H5BFE290A5AC0: '模板參數缺少預設參數'
# "template parameter of a function template with the 'sycl_kernel' attribute cannot be a non-type template parameter"
H7625BE567F07: "具有 'sycl_kernel' 屬性之函數模板的模板參數不能是非類型模板參數"
# 'template parameter pack cannot have a default argument'
HD1F9E9063EB7: '模板參數包不能有預設參數'
# 'template parameter pack must be the last template parameter'
HD5749F5C7756: '模板參數包必須是最後一個模板參數'
# 'template parameter redefines default argument'
H8C66CF577C62: '模板參數重新定義預設參數'
# 'template specialization declaration cannot be a friend'
HA8ECAC04AF8C: '模板特化宣告不能是友元'
# 'template specialization or definition requires a template parameter list corresponding to the nested type %0'
HC868EA3957FF: '模板特化或定義需要對應至嵌套類型 %0 的模板參數清單'
# "template specialization requires 'template<>'"
H1ADEE7A736DF: "模板特化需要使用 'template<>'"
# 'template template argument %0 is more constrained than template template parameter %1'
HE3F8D9BFA908: '模板模板參數 %0 比模板模板參數 %1 更受限'
# 'template template argument has different template parameters than its corresponding template template parameter'
HB7542BD3C1FF: '模板模板參數與其對應的模板模板參數具有不同的模板參數'
# 'template template parameter must have its own template parameters'
H2E8B286B021F: '模板模板參數必須有自己的模板參數'
# "template template parameter requires 'class'%select{| or 'typename'}0 after the parameter list"
HC7B5002008B5: "模板模板參數需要在參數清單後使用 'class'%select{|或 'typename'}0"
# "template template parameter using 'typename' is a C++17 extension"
HD13D228AA386: "使用 'typename' 的模板模板參數是C++17擴充"
# "template template parameter using 'typename' is incompatible with C++ standards before C++17"
H2724DAD0662B: "使用 'typename' 的模板模板參數與C++17之前的標準不相容"
# 'templates can only be declared in namespace or class scope'
H549BBF1A776B: '模板只能在命名空間或類別作用域中宣告'
# 'templates cannot be declared inside of a local class'
H9817A58D9951: '模板不能在局部類別內部宣告'
# 'templates must have C++ linkage'
H7DA4A8DB6A41: '模板必須具有C++連結性'
# 'temporary bound to reference member of allocated object will be destroyed at the end of the full-expression'
H013054578BC3: '綁定至已分配物件之成員引用的臨時物件將在完整表達式結束時被銷毀'
# 'temporary created here'
H6CF924D32FF7: '臨時物件在此處建立'
# 'temporary of type %0 has %select{private|protected}1 destructor'
HA776568AF253: '類型為 %0 的臨時物件具有 %select{private|protected}1 析構函數'
# 'tentative array definition assumed to have one element'
H1578DBDB8944: '假設未定義的陣列定義有單一元素'
# 'tentative definition has type %0 that is never completed'
H2533423DBC92: '未定義的定義具有從未完成的類型 %0'
# 'tentative definition of variable with internal linkage has incomplete non-array type %0'
H137EE1AFC5D6: '具有內部綁定的變數的未定義定義具有不完整的非陣列類型 %0'
# 'tenths of percents of main entry frequency to use as a threshold when evaluating whether a basic block is cold (0 means it is only considered cold if the block has zero samples). Default: 0 '
HB4A505AFFDA6: '在評估基本區塊是否為冷區塊時，用作閾值的主入口頻率的十分之一百分比（0表示僅當區塊的樣本為零時才視為冷區塊）。預設值：0 '
# "test module file extension '%0' has different version (%1.%2) than expected (%3.%4)"
HD419260C8BE7: "測試模組檔案擴充名 '%0' 的版本 (%1.%2) 與期望的 (%3.%4) 不同"
# 'the #__include_macros directive is only for internal use by -imacros'
H1FBDC6FD510E: '#__include_macros 指令僅供 -imacros 內部使用'
# 'the %0 sub-architecture does not support unaligned accesses'
H8EEF78B6F581: '子架構 %0 不支援未對齊的存取'
# 'the %0 type cannot be used to declare a program scope variable'
HCC2A02E45E01: '類型 %0 無法用於宣告程式的全域變數'
# 'the %0 type cannot be used to declare a structure or union field'
H3AA824360E4A: '類型 %0 無法用於宣告結構或共用體的成員'
# 'the %select{1st|2nd|3rd}1 template parameter of %0 needs to be %select{a type|an integer or enum value}2'
HC15D25E5BA46: '模板 %0 的%select{第 1 個|第 2 個|第 3 個}1參數需要是%select{類型|整數或枚舉值}2'
# 'the %select{function or variable|function}0 specified in an %select{alias|ifunc}1 must refer to its mangled name'
H2A963C3F164E: '在%select{別名|ifunc}1 中指定的%select{函數或變數|函數}0必須引用其裝飾名稱'
# "the %select{message|string}0 object in %select{this static assertion|this asm operand}0 is missing %select{a 'size()' member function|a 'data()' member function|'data()' and 'size()' member functions}1"
HF8EFF7FCD3A1: "在%select{此靜態斷言|此組合語言操作數}0中的%select{訊息|字串}0物件缺少%select{具名為 'size()' 的成員函數|具名為 'data()' 的成員函數|具名為 'data()' 和 'size()' 的成員函數}1"
# "the '%0' unit is not supported with this instruction set"
H66612647AED8: "指令集不支援 '%0' 單元"
# "the '%select{&|*|->}0' operator is unsupported in HLSL"
H831B25ED6E8C: "在HLSL中不支援 '%select{&|*|->}0' 運算子"
# "the '[[_Noreturn]]' attribute spelling is deprecated in C23; use '[[noreturn]]' instead"
H584C1C164ECE: "在C23中，'[[_Noreturn]]' 屬性拼寫已棄用；請改用 '[[noreturn]]'"
# "the 'copyprivate' clause must not be used with the 'nowait' clause"
H026F61D558F6: "不能將 'copyprivate' 子句與 'nowait' 子句一起使用"
# "the 'static' modifier for the array size is not legal in new expressions"
H285525BB6E11: "在new運算式中，陣列大小的 'static' 修飾符不合法"
# "the ApplicationExtensionSafe flag does not match: '%0' (provided) vs '%1' (found)"
H74ECAC68920E: "ApplicationExtensionSafe旗標不相符：提供的 '%0' 對比找到的 '%1'"
# 'the GNU address of label extension is not allowed in coroutines'
HEE9FFF3C021C: '在協程中不允許使用GNU標籤位址擴充功能'
# "the NotForDyldSharedCache flag does not match: '%0' (provided) vs '%1' (found)"
HAD9256F7D2F3: "NotForDyldSharedCache 標記不匹配：提供的 '%0' 對應找到的 '%1'"
# 'the __block storage type is not permitted'
H2951C6144658: '__block 儲存類型未被允許'
# 'the address of a declaration with unknown type can only be cast to a pointer type'
H6D4B76B01E9C: '未知型別宣告的地址只能轉換為指標型別'
# "the argument '%0' is not supported for option '%1'. Mapping to '%1%2'"
HA4EFCA49DC99: "選項 '%1' 不支援參數 '%0'。映射為 '%1%2'"
# "the clang compiler does not support '%0'"
HCB0DF6FD34A3: "clang 編譯器不支援 '%0'"
# "the clang compiler does not support '%0' for C++ on Darwin/i386"
HAB9E0C38E134: "clang 編譯器在 Darwin/i386 平台的 C++ 中不支援 '%0'"
# "the clang compiler does not support '%0', %1"
H70791B1776AF: "clang 編譯器不支援 '%0', %1"
# 'the clang compiler does not support -pg option on %select{Darwin|versions of OS X 10.9 and later}0'
HEC221F97986E: 'clang 編譯器在 %select{Darwin|OS X 10.9 及更新版本}0 平台不支援 -pg 選項'
# 'the clustering algorithm to use'
HEE034B797939: '使用的群聚演算法'
# "the combination of '%0' and '%1' is incompatible"
H04D1D2EB3A72: "'%0' 和 '%1' 的組合不相容"
# "the context %select{set|selector|property}0 '%1' was used already in the same 'omp declare variant' directive; %select{set|selector|property}0 ignored"
H6268D8504255: "在同一 'omp declare variant' 指令中已使用上下文 %select{集合|選擇器|屬性}0 '%1'；%select{集合|選擇器|屬性}0 被忽略"
# "the context property '%0' can be nested in the context selector '%1' which is nested in the context set '%2'; try 'match(%2={%1(%0)})'"
HAA758F7206BE: "上下文屬性 '%0' 可以嵌套在上下文選擇器 '%1' 中，而該選擇器又嵌套在上下文集合 '%2' 中；試用 'match(%2={%1(%0)})'"
# "the context property '%0' is not valid for the context selector '%1' and the context set '%2'; property ignored"
H88A5B848CED9: "上下文屬性 '%0' 不適用於上下文選擇器 '%1' 和上下文集合 '%2'；屬性被忽略"
# "the context selector '%0' can be nested in the context set '%1'; try 'match(%1={%0%select{|(property)}2})'"
HDD6FFFA1FE6E: "上下文選擇器 '%0' 可以嵌套在上下文集合 '%1' 中；試用 'match(%1={%0%select{|(屬性)}2})'"
# "the context selector '%0' in context set '%1' requires a context property defined in parentheses; selector ignored"
H4359A48C4F70: "上下文集合 '%1' 中的選擇器 '%0' 需要在括號內定義屬性；選擇器被忽略"
# "the context selector '%0' in the context set '%1' cannot have a score ('%2'); score ignored"
H98F3D66A37F6: "上下文集合 '%1' 中的選擇器 '%0' 不能具有分數 ('%2')；分數被忽略"
# "the context selector '%0' is not valid for the context set '%1'; selector ignored"
HDF7A50F1E9D4: "上下文選擇器 '%0' 不適用於上下文集合 '%1'；選擇器被忽略"
# "the coroutine promise type %0 declares both 'return_value' and 'return_void'"
H089B386C28E8: "協程承諾型別 %0 同時宣告了 'return_value' 和 'return_void'"
# 'the current #pragma pack alignment value is modified in the included file'
H1259B6694648: '目前 #pragma pack 對齊值在包含的檔案中被修改'
# 'the event_t type can only be used with __private address space qualifier'
HF7753CC750DA: 'event_t 類型只能與 __private 位址空間修飾符一起使用'
# 'the experimental clang interpreter failed to evaluate an expression'
H0E50C442ED03: '實驗性的 clang 解譯器無法計算該運算式'
# 'the explicit object parameter cannot be a function parameter pack'
HAC332D9FE6A2: '明確物件參數不能是函數參數包'
# 'the explicit object parameter cannot have a default argument'
HEF646D36FD87: '明確物件參數不能有預設參數'
# "the expression 'co_await __promise.final_suspend()' is required to be non-throwing"
HBE8E0E1AD063: "運算式 'co_await __promise.final_suspend()' 需要為不會拋出異常"
# "the flag '%0' has been deprecated and will be ignored"
H97F3754670BE: "旗標 '%0' 已被棄用，並將被忽略"
# "the form '-fmodule-file=<BMI-path>' is deprecated for standard C++ named modules; consider to use '-fmodule-file=<module-name>=<BMI-path>' instead"
H9E11832D49AD: "對標準 C++ 命名模組而言，'-fmodule-file=<BMI-path>' 格式已被棄用；建議改用 '-fmodule-file=<module-name>=<BMI-path>'"
# "the given MCU does not support hardware multiply, but '-mhwmult' is set to %0"
HBC73BCBB2AD5: "指定的 MCU 不支援硬體乘法，但 '-mhwmult' 設定為 %0"
# "the given MCU supports %0 hardware multiply, but '-mhwmult' is set to %1"
H33683D593A85: "指定的 MCU 支援 %0 硬體乘法，但 '-mhwmult' 設定為 %1"
# 'the host cannot update a declare target variable that is not externally visible'
H626F4DD8E816: '主機無法更新未對外部可見的宣告目標變數'
# 'the ignored %select{set|selector|property}0 spans until here'
H78F2F2873540: '被忽略的 %select{集合|選擇項|屬性}0 一直延伸到這裡'
# 'the ignored tokens spans until here'
HE724FD8D9E24: '被忽略的語法單元一直延伸到這裡'
# 'the implementation of header units is in an experimental phase'
H822B183C153E: '標頭單元的實作尚處於實驗階段'
# "the implicit output of reduced BMI may be overrided by the output file specified by '--precompile'. please consider use '-fmodule-output=' to specify the output file for reduced BMI explicitly"
HC77BA90C9A9E: "簡化 BMI 的隱式輸出可能被 '--precompile' 指定的輸出檔案覆蓋。請考慮使用 '-fmodule-output=' 明確指定簡化 BMI 的輸出檔案"
# "the inscan reduction list item must appear as a list item in an 'inclusive' or 'exclusive' clause on an inner 'omp scan' directive"
H5A6903CB5B88: "inscan 減少清單項目必須出現在內部 'omp scan' 指令的 'inclusive' 或 'exclusive' 子句的清單項目中"
# "the last '/TC' or '/TP' option takes precedence over earlier instances"
H1D4C07143ED6: "最後的 '/TC' 或 '/TP' 選項優先於前面的指定"
# "the library '%0=%1' is not supported, OpenMP will not be enabled"
H8332E220148A: "函式庫 '%0=%1' 不被支援，OpenMP 將不會啟用"
# "the list item must appear in 'reduction' clause with the 'inscan' modifier of the parent directive"
H331559E5A96C: "清單項目必須出現在父指令的 'inscan' 修飾符的 'reduction' 子句中"
# 'the loop %select{initializer|condition}0 expression depends on the current loop control variable'
H092C392BA41E: '迴圈的 %select{初始化式|條件}0 運算式依賴於目前的迴圈控制變數'
# 'the maximum number of instructions analyzed for may throw during attribute inference in inlined body'
HDB567B6559C9: '在內聯函數體中進行屬性推論時，用於分析可能拋出異常的指令最大數量'
# 'the mode to run'
H1067F4A3FF41: '執行的模式'
# 'the name of the PDB file to write'
H3B634F1D4C6F: '要寫入的PDB檔名稱'
# "the name of the construct must be specified in presence of 'hint' clause"
HF664729B6FC3: "存在 'hint' 子句時，該結構的名稱必須指定"
# 'the number of preprocessor source tokens (%0) exceeds this token limit (%1)'
H205DE1F2F79F: '預處理器源代碼標記 (%0) 的數量超過此標記限制 (%1)'
# 'the object size sanitizer has no effect at -O0, but is explicitly enabled: %0'
H314C428C1C64: '物件大小檢查器在-O0級別無效，但已被明確啟用：%0'
# "the option '-flto=thin' is a work in progress"
H5F57C367214A: "選項 '-flto=thin' 正在開發中"
# "the other acquisition of %0 '%1' is here"
HF9475FC44959: "另一處對 %0 '%1' 的取得在此"
# 'the parameter for an explicitly-defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 may not be volatile'
HEAA7EB9FB2E0: '明確預設的 %select{預設建構函數|複製建構函數|移動建構函數|複製指派運算子|移動指派運算子|析構函數}0 的參數不能是 volatile'
# 'the parameter for an explicitly-defaulted copy assignment operator must be an lvalue reference type'
H7CAB648A4737: '明確預設的複製指派運算子的參數必須是左值引用類型'
# 'the parameter for an explicitly-defaulted move %select{constructor|assignment operator}0 may not be const'
H34E3C1F201FC: '明確預設的移動 %select{建構函數|指派運算子}0 的參數不能是 const'
# 'the parameter for this explicitly-defaulted copy %select{constructor|assignment operator}0 is const, but a member or base requires it to be non-const'
H7307965D0004: '此明確預設的複製 %select{建構函數|指派運算子}0 的參數是 const，但成員或基類需要非 const'
# "the parameter of the 'ordered' clause must be greater than or equal to the parameter of the 'collapse' clause"
H21ACD6E7D4C2: "'ordered' 子句的參數必須大於或等於 'collapse' 子句的參數"
# 'the pointee of the 2nd argument must match the element type of the 1st argument (%0 != %1)'
H13AC040EDF7B: '第二個參數所指的物件類型必須與第一個參數的元素類型一致 (%0 != %1)'
# 'the pointer decremented by %0 refers before the beginning of the array'
H9FD5D86B7BD7: '減去 %0 後的指標指向陣列起始位置之前'
# 'the pointer incremented by %0 refers past the end of the array (that has type %1)'
H2098AEB20194: '增加 %0 後的指標指向陣列結束位置之後（陣列類型為 %1）'
# 'the pointer incremented by %0 refers past the last possible element for an array in %1-bit address space containing %2-bit (%3-byte) elements (max possible %4 element%s5)'
H85FE07542C80: '增加 %0 後的指標指向 %1 位地址空間中包含 %2 位（%3 字節）元素的陣列最後可能元素之後（最大可能元素數：%4 element%s5）'
# "the previous context %select{set|selector|property}0 '%1' used here"
H995F32331A92: "在此處使用先前的 %select{集合|選擇器|屬性}0 '%1'"
# 'the provided selection does not overlap with the AST nodes of interest'
H10756E8D2178: '提供的選擇與感興趣的AST節點無交集'
# 'the referenced item is not found in any private clause on the same directive'
HBDA357C86E91: '在相同的指令中未找到任何私有子句中的所引用項目'
# "the result of a delegate init call must be immediately returned or assigned to 'self'"
HA6A6824B2746: "代理初始化調用的結果必須立即返回或賦值給 'self'"
# 'the resulting value is always non-negative after implicit conversion'
H9908ECBF3885: '隱式轉換後的結果值始終為非負數'
# "the second argument of '-fpatchable-function-entry' must be smaller than the first argument"
HEC0EC1D581E8: "'-fpatchable-function-entry' 的第二個參數必須小於第一個參數"
# "the selected code is not a part of a function's / method's body"
H09129ED39DF9: '所選的程式碼段並非函數/方法主體的一部分'
# 'the selected expression cannot be extracted'
HC3B7DF91CF84: '無法提取所選的表示式'
# 'the selected expression is too simple to extract'
HEFB1186DBBA0: '所選的表示式過於簡單而無法提取'
# 'the semantics of this intrinsic changed with GCC version 4.4 - the newer semantics are provided here'
H1D55F6813757: '此內建函數的語意自GCC 4.4版本起有所改變，這裡提供的是較新的語意'
# 'the sign of a  flushed-to-zero number is preserved in the sign of 0'
HE7436E3F21CE: '被沖刷至零的數值的符號會在 0 的符號中保留'
# 'the specified comparator type does not provide a viable const call operator'
H327A107A2A90: '指定的比較器類型未提供有效的const呼叫運算子'
# 'the specified hash functor does not provide a viable const call operator'
H7B4F603F77A3: '指定的哈希函數未提供有效的const呼叫運算子'
# "the statement for '#pragma omp %0' must be a compound statement"
H8597FC2B3D8A: "'#pragma omp %0' 的語句必須是複合語句"
# "the statement for 'atomic capture' must be a compound statement of form '{v = x; x binop= expr;}', '{x binop= expr; v = x;}', '{v = x; x = x binop expr;}', '{v = x; x = expr binop x;}', '{x = x binop expr; v = x;}', '{x = expr binop x; v = x;}' or '{v = x; x = expr;}', '{v = x; x++;}', '{v = x; ++x;}', '{++x; v = x;}', '{x++; v = x;}', '{v = x; x--;}', '{v = x; --x;}', '{--x; v = x;}', '{x--; v = x;}' where x is an lvalue expression with scalar type"
H0E1E5BD56218: "'atomic capture' 的語句必須是符合以下形式的複合語句：'{v = x; x binop= expr;}'、'{x binop= expr; v = x;}'、'{v = x; x = x binop expr;}'、'{v = x; x = expr binop x;}'、'{x = x binop expr; v = x;}'、'{x = expr binop x; v = x;}' 或 '{v = x; x = expr;}'、'{v = x; x++;}'、'{v = x; ++x;}'、'{++x; v = x;}'、'{x++; v = x;}'、'{v = x; x--;}'、'{v = x; --x;}'、'{--x; v = x;}'、'{x--; v = x;}'，其中x是具有純量類型的左值運算式"
# "the statement for 'atomic capture' must be an expression statement of form 'v = ++x;', 'v = --x;', 'v = x++;', 'v = x--;', 'v = x binop= expr;', 'v = x = x binop expr' or 'v = x = expr binop x', where x and v are both lvalue expressions with scalar type"
H47D428195CE9: "'atomic capture' 的語句必須是符合以下形式的表示式語句：'v = ++x;'、'v = --x;'、'v = x++;'、'v = x--;'、'v = x binop= expr;'、'v = x = x binop expr' 或 'v = x = expr binop x'，其中x和v都是具有純量類型的左值運算式"
# "the statement for 'atomic compare capture' must be a compound statement of form '{v = x; cond-up-stmt}', ''{cond-up-stmt v = x;}', '{if(x == e) {x = d;} else {v = x;}}', '{r = x == e; if(r) {x = d;}}', or '{r = x == e; if(r) {x = d;} else {v = x;}}', where 'cond-update-stmt' can have one of the following forms: 'if(expr ordop x) {x = expr;}', 'if(x ordop expr) {x = expr;}', 'if(x == e) {x = d;}', or 'if(e == x) {x = d;}' where 'x', 'r', and 'v' are lvalue expressions with scalar type, 'expr', 'e', and 'd' are expressions with scalar type, and 'ordop' is one of '<' or '>'"
H09C6A6DB560B: "'atomic compare capture' 的語句必須是符合以下形式的複合語句：'{v = x; cond-up-stmt}'、''{cond-up-stmt v = x;}'、'{if(x == e) {x = d;} else {v = x;}}'、'{r = x == e; if(r) {x = d;}}' 或 '{r = x == e; if(r) {x = d;} else {v = x;}}'，其中 'cond-update-stmt' 可以是以下其中一種形式：'if(expr ordop x) {x = expr;}'、'if(x ordop expr) {x = expr;}'、'if(x == e) {x = d;}' 或 'if(e == x) {x = d;}'，其中 'x'、'r'、'v' 是具有純量類型的左值運算式，'expr'、'e'、'd' 是具有純量類型的運算式，且 'ordop' 是 '<' 或 '>' 中的一種"
# "the statement for 'atomic compare' must be a compound statement of form '{x = expr ordop x ? expr : x;}', '{x = x ordop expr? expr : x;}', '{x = x == e ? d : x;}', '{x = e == x ? d : x;}', or 'if(expr ordop x) {x = expr;}', 'if(x ordop expr) {x = expr;}', 'if(x == e) {x = d;}', 'if(e == x) {x = d;}' where 'x' is an lvalue expression with scalar type, 'expr', 'e', and 'd' are expressions with scalar type, and 'ordop' is one of '<' or '>'"
H4091D9BED6D2: "'atomic compare' 的語句必須是符合以下形式的複合語句：'{x = expr ordop x ? expr : x;}'、'{x = x ordop expr? expr : x;}'、'{x = x == e ? d : x;}'、'{x = e == x ? d : x;}'、'if(expr ordop x) {x = expr;}'、'if(x ordop expr) {x = expr;}'、'if(x == e) {x = d;}' 或 'if(e == x) {x = d;}'，其中 'x' 是具有純量類型的左值運算式，'expr'、'e'、'd' 是具有純量類型的運算式，且 'ordop' 是 '<' 或 '>' 中的一種"
# "the statement for 'atomic read' must be an expression statement of form 'v = x;', where v and x are both lvalue expressions with scalar type"
HDAD21CA5AD66: "'atomic read' 的語句必須是符合以下形式的表示式語句：'v = x;'，其中v和x都是具有純量類型的左值運算式"
# "the statement for 'atomic update' must be an expression statement of form '++x;', '--x;', 'x++;', 'x--;', 'x binop= expr;', 'x = x binop expr' or 'x = expr binop x', where x is an lvalue expression with scalar type"
H106E8810ABCE: "'atomic update' 的語句必須是符合以下形式的表示式語句：'++x;'、'--x;'、'x++;'、'x--;'、'x binop= expr;'、'x = x binop expr' 或 'x = expr binop x'，其中x是具有純量類型的左值運算式"
# "the statement for 'atomic write' must be an expression statement of form 'x = expr;', where x is a lvalue expression with scalar type"
HAEE051C701D8: "'atomic write' 的語句必須是符合以下形式的表示式語句：'x = expr;'，其中x是具有純量類型的左值運算式"
# "the statement for 'atomic' must be an expression statement of form '++x;', '--x;', 'x++;', 'x--;', 'x binop= expr;', 'x = x binop expr' or 'x = expr binop x', where x is an lvalue expression with scalar type"
H182C909CFBBD: "'atomic' 的語法必須是形如 '++x;'、'--x;'、'x++;'、'x--;'、'x binop= expr;'、'x = x binop expr' 或 'x = expr binop x' 的運算式語句，其中 x 是標量類型的左值運算式"
# "the target architecture '%0' is not supported by the target '%1'"
H9EB5284C09D2: "目標 '%1' 不支援目標架構 '%0'"
# 'the total number of preprocessor source tokens (%0) exceeds the token limit (%1)'
H8A02325A6920: '預處理器來源代碼的 token 總數 (%0) 超過限制 (%1)'
# 'the two-parameter std::span construction is unsafe as it can introduce mismatch between buffer size and the bound information'
HB6B2C19333E2: 'std::span 的雙參數建構函數不安全，可能導致緩衝區大小與長度資訊不匹配'
# 'the type %0 is already explicitly ownership-qualified'
H462F56962031: '類型 %0 已經明確指定所有權限定符'
# 'the type %0 is not a pointer to a fast-enumerable object'
HF043D197C95F: '類型 %0 不是指向快速可枚舉物件的指標'
# 'the type of object expression %diff{($) does not match the type being destroyed ($)|does not match the type being destroyed}0,1 in pseudo-destructor expression'
HF8245CD4DD36: '物件運算式的類型 %diff{($) 與正在被銷毀的類型 ($) 不匹配 | 與正在被銷毀的類型不匹配}0,1 在偽析構運算式中'
# 'the type of the explicit object parameter of an explicitly-defaulted %select{copy|move}0 assignment operator should be reference to %1'
H48B3F2D609BF: '明確預設的 %select{複製|移動}0 賦值運算式中，顯式物件參數的類型應為 %1 的參考'
# 'the user condition in the OpenMP context selector needs to be constant; %0 is not'
H518CAE3CEA63: 'OpenMP 環境選擇器中的使用者條件必須是常量；%0 不是'
# "the value of 'simdlen' parameter must be less than or equal to the value of the 'safelen' parameter"
H05F684C1DEC1: "'simdlen' 參數的值必須小於或等於 'safelen' 參數的值"
# "the value of the size argument in 'strncat' is too large, might lead to a buffer overflow"
H7CBEE5BA8363: "'strncat' 的大小參數值過大，可能導致緩衝區溢位"
# "the value of the size argument to 'strncat' is wrong"
H10EE22A40549: "'strncat' 的大小參數值錯誤"
# 'the vecreturn attribute can only be used on a POD (plain old data) class or structure (i.e. no virtual functions)'
HB24B6E1BF839: 'vecreturn 屬性只能用於沒有虛函數的 POD（plain old data）類別或結構'
# 'the vecreturn attribute can only be used on a class or structure with one member, which must be a vector'
H91431B029CC5: 'vecreturn 屬性只能用於具有一個成員的類別或結構，且該成員必須是向量'
# "the warning option '-%0' is not supported"
H961C96696067: "警告選項 '-%0' 不支援"
# 'there is no external assembler that can be used on this platform'
H36CA569B9742: '此平台沒有可用的外部組譯器'
# 'there is no symbol at the given location'
H99C4AECFC4C8: '給定位置沒有符號'
# 'this builtin is available only on AIX 7.2 and later operating systems'
H6E604B084F43: '此內建函數僅在 AIX 7.2 或更新版本作業系統中可用'
# 'this builtin is only available on 32-bit targets'
H56D31FAC556E: '此內建函數僅支援 32 位元目標'
# 'this builtin is only available on 64-bit targets'
HC0C706B2D8E7: '此內建函式僅支援 64-bit 目標平台'
# 'this builtin is only available on x86-64 and aarch64 targets'
H81BF150D8949: '此內建函式僅支援 x86-64 和 aarch64 目標平台'
# "this builtin requires 'dsp r2' ASE, please use -mdspr2"
HF59F7FBACC6E: "此內建函式需要 'dsp r2' ASE，請使用 -mdspr2 選項"
# "this builtin requires 'dsp' ASE, please use -mdsp"
H2B317AB4FDC4: "此內建函式需要 'dsp' ASE，請使用 -mdsp 選項"
# "this builtin requires 'msa' ASE, please use -mmsa"
H25EA8026E312: "此內建函式需要 'msa' ASE，請使用 -mmsa 選項"
# 'this builtin requires ABI -mabi=%0'
H6643558E97E9: '此內建函式需要 ABI -mabi=%0'
# 'this coroutine may be split into pieces; not every piece is guaranteed to be inlined'
HEF5E3EA3F783: '此協程可能被分割為多個部分；並非所有部分都能保證被內聯'
# "this declaration is not a prototype; add %select{'void'|parameter declarations}0 to make it %select{a prototype for a zero-parameter function|one}0"
HDD90A70940A7: "此宣告不是原型；請新增 %select{'void'|參數宣告}0 使其成為 %select{零參數函數的原型|一個}0"
# 'this expression will be parsed as explicit(bool) in C++20'
HE2974A48FA92: '此運算式在 C++20 中將被解析為 explicit(bool)'
# 'this function cannot be a coroutine: %0 is an incomplete type'
HEB887A198DFF: '此函數無法是協程：%0 是不完整類型'
# 'this function cannot be a coroutine: %0 is not a class'
HF896DD5CD9DB: '此函數無法是協程：%0 非類別'
# "this function cannot be a coroutine: %q0 has no member named 'promise_type'"
HAD42B5488901: "此函數無法是協程：%q0 無名為 'promise_type' 的成員"
# 'this function cannot be a coroutine: missing definition of specialization %0'
HFC5D41C5C0FA: '此函數無法是協程：缺少專屬定義 %0'
# 'this is generally caused by modules with the same name found in multiple paths'
HB435423839CE: '此問題通常由多個路徑中找到相同名稱的模組所引起'
# 'this placement new expression is not supported in constant expressions %select{|before C++2c}0'
HFED2CB8F9A5D: '此置位 new 運算式不支援在常量運算式中使用 %select{|於 C++2c 前}0'
# 'this pragma cannot appear in %0 declaration'
HCE58A657A4E9: '此 pragma 不可在 %0 宣告中使用'
# 'this style of line directive is a GNU extension'
H0B9D785486F6: '此種行指令為 GNU 延伸功能'
# 'this target does not support pointer authentication'
HB298CA51FDBD: '此目標平台不支援指標驗證'
# 'this type tag was not designed to be used with this function'
H6E259EADA90E: '此類型標記未設計與此函數一同使用'
# 'this use of statement expressions is not supported in a constant expression'
H15F3A7193C9C: '在常量表達式中不支援使用語句表達式'
# 'this value is too large for this fixed point type'
HC641D92F0E57: '此值對此定點數類型而言過大'
# 'this warning is no longer in use and will be removed in the next release'
H0EF268B5B2F9: '此警告已不再使用，並將在下一個版本中移除'
# 'thread safety beta warning'
HB0419777F950: '執行緒安全性測試版警告'
# 'thread safety verbose warning'
H313BE85969C3: '執行緒安全性的詳細警告'
# 'thread warning in function %0'
H36B44B602302: '在函數 %0 中的執行緒警告'
# 'thread-local declaration of %0 follows non-thread-local declaration'
HEFF70126975B: '%0 的執行緒局部宣告跟隨非執行緒局部宣告'
# 'thread-local declaration of %0 with %select{static|dynamic}1 initialization follows declaration with %select{dynamic|static}1 initialization'
H912C45CDB374: '具有 %select{靜態|動態}1 初始化的 %0 執行緒局部宣告跟隨具有 %select{動態|靜態}1 初始化的宣告'
# 'thread-local storage is not supported for the current target'
H98D675ADC45A: '目前目標平台不支援執行緒局部儲存'
# 'thread-local variable has non-trivial ownership: type is %0'
H6F11C930F55E: '執行緒局部變數具有非平凡的所有權：類型是 %0'
# 'threadprivate variable with incomplete type %0'
HCB733257A55A: '具有不完整類型 %0 的 threadprivate 變數'
# "threadprivate variables are not allowed in '%0' clause"
HEEB356882606: "'%0' 子句中不允许使用 threadprivate 變數"
# 'threadprivate variables cannot be used in target constructs'
HB21F31B22998: 'threadprivate 變數不能在目標構造中使用'
# 'three-way comparison between pointer and zero'
HD3520571E10A: '指標與零的三向比較'
# 'three-way comparison between vectors is not supported'
H00B5B249986A: '向量之間的三向比較不受支援'
# "three-way comparison cannot be synthesized because there is no viable function for %select{'=='|'<'}0 comparison"
H6263B6389D1C: '無法合成三向比較，因為沒有可用的 %select{"==|"<"}0 比較函數'
# 'threshold (in percent) for selecting functions to process in lite mode. Higher threshold means fewer functions to process. E.g threshold of 90 means only top 10 percent of functions with profile will be processed.'
HC3919B9CBB6D: '在 Lite 模式下選擇要處理函數的閾值（百分比）。閾值越高，要處理的函數越少。例如，閾值 90 表示僅處理具有剖析資料的前 10% 函數。'
# 'tile arguments must refer to different tiles'
HC74F5110780C: 'tile 參數必須指向不同的 tiles'
# 'time BOLT aggregator'
H034122EC1DF6: '計時 BOLT 統計器'
# 'time frame analysis steps'
H18422D3F506F: '時間框架分析步驟'
# 'time icf steps'
H17EA53E3423A: '時間 ICF 步驟'
# "timed out waiting to acquire lock file for module '%0'"
HD7ADFA168199: "等待取得模組 '%0' 的鎖檔時超時"
# 'tls_model must be "global-dynamic", "local-dynamic", "initial-exec" or "local-exec"'
H2BCDC88FA47E: 'tls_model 必須是「global-dynamic」、「local-dynamic」、「initial-exec」或「local-exec」'
# 'to match this %0'
HDA13A5D2D868: '以符合此 %0'
# "to match this ']'"
HEF9A1EC0D665: "以符合此 ']'"
# "to match this '{'"
H013B6E508561: "以符合此 '{'"
# 'token is not a valid binary operator in a preprocessor subexpression'
H93EB0C533EDF: '此字元在預處理器子運算式中不是有效的二元運算符'
# "token pasting of ',' and __VA_ARGS__ is a GNU extension"
H13889DCFA50D: "將 ',' 和 __VA_ARGS__ 進行字元串接是 GNU 擴充功能"
# 'too %select{few|many}0 arguments in call to %1'
H55C9E37AE906: '在呼叫 %1 時參數%select{過少|過多}0'
# 'too %select{few|many}0 initializers in list for type %1 (expected %2 but found %3)'
HD545C2517E80: '類型 %1 的清單中初始值設定過%select{少|多}0 (期望 %2 個但找到 %3 個)'
# 'too %select{few|many}0 parameters in the signature specified by the %1 attribute (expected %2; got %3)'
H6F4276FDBDF1: '屬性 %1 指定的函式簽章參數過%select{少|多}0 (期望 %2 個但找到 %3 個)'
# 'too %select{many|few}0 type arguments for class %1 (have %2, expected %3)'
H35A08DFD5F2A: '類別 %1 的型別參數過%select{多|少}0 (已有 %2，期望 %3)'
# 'too few %select{|||execution configuration }0%select{|non-object }2arguments to %select{function|block|method|kernel function}0 call, at least argument %1 must be specified'
HF6BA10037D33: '呼叫 %select{函式|區塊|方法|核心函式}0 時，%select{|||執行配置 }0%select{|非物件 }2參數不足，至少必須指定參數 %1'
# 'too few %select{|||execution configuration }0%select{|non-object }2arguments to %select{function|block|method|kernel function}0 call, single argument %1 was not specified'
H9CA8A408A5C7: '呼叫 %select{函式|區塊|方法|核心函式}0 時，%select{|||執行配置 }0%select{|非物件 }2參數不足，單一參數 %1 未指定'
# 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2'
H5939FAB31ED6: '%select{|||執行配置 }0%select{|非物件 }3參數不足，%select{函式|區塊|方法|核心函式}0 呼叫需要 %1 個參數，目前有 %2 個'
# 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2; did you mean %4?'
HF20F679C52F2: '%select{|||執行配置 }0%select{|非物件 }3參數不足，%select{函式|區塊|方法|核心函式}0 呼叫需要 %1 個參數，目前有 %2 個；是否要使用 %4？'
# 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at least %1, have %2'
HD24171A04B0B: '呼叫 %select{函式|區塊|方法|核心函式}0 時，%select{|||執行配置 }0%select{|非物件 }3參數不足，至少需要 %1 個參數，但只有 %2 個'
# 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at least %1, have %2; did you mean %4?'
HD3BBC6D9EFC0: '呼叫 %select{函式|區塊|方法|核心函式}0 時，%select{|||執行配置 }0%select{|非物件 }3參數不足，至少需要 %1 個參數，但只有 %2 個；是否想說 %4？'
# 'too few arguments provided to function-like macro invocation'
H1E346A7B8B3C: '函數式宏調用提供的參數過少'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2'
H90F884ECB318: '%select{|||執行配置 }0%select{|非物件 }3參數過多，%select{函式|區塊|方法|核心函式}0 呼叫需要 %1 個參數，目前有 %2 個'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2; did you mean %4?'
HCA745DFE1FDF: '%select{|||執行配置 }0%select{|非物件 }3參數過多，%select{函式|區塊|方法|核心函式}0 呼叫需要 %1 個參數，目前有 %2 個；是否要使用 %4？'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at most %1, have %2'
H94A2619722A2: '呼叫 %select{函數|區塊|方法|核心函數}0 時 %select{|||執行配置 }0%select{|非物件 }3參數超過最大數量 %1，實際有 %2 個'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at most %1, have %2; did you mean %4?'
HE9A38EF19888: '呼叫 %select{函數|區塊|方法|核心函數}0 時 %select{|||執行配置 }0%select{|非物件 }3參數超過最大數量 %1，實際有 %2 個；是否要改為 %4？'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected single argument %1, have %2 arguments'
HDBD2C1E2CE61: '%select{|||執行配置 }0%select{|非物件 }3參數過多，%select{函式|區塊|方法|核心函式}0 呼叫需要單一 %1 參數，但有 %2 個參數'
# 'too many %select{|||execution configuration }0arguments to %select{function|block|method|kernel function}0 call, expected at most single %select{|non-object }3argument %1, have %2%select{|non-object}3 arguments'
HDAC13624D426: '%select{|||執行配置 }0參數過多，%select{函式|區塊|方法|核心函式}0 呼叫最多接受單一 %select{|非物件 }3參數 %1，但有 %2%select{|非物件}3 個參數'
# 'too many arguments provided to function-like macro invocation'
HBB5E8EFBFD08: '函數式宏調用提供的參數過多'
# 'too many braces around %select{scalar |}0initializer'
H5C95D607138A: '初始值設定項前的括號過多（%select{純量 |}0 初始值設定項）'
# 'too many errors emitted, stopping now'
H208E3BCCF078: '發出的錯誤訊息過多，現停止處理'
# 'too many function parameters; subsequent parameters will be ignored'
H803517A338E0: '函數參數過多；後續參數將被忽略'
# "too many parameters (%0) for 'main': must be 0, 2, or 3"
H39E16B39631F: "'main' 的參數過多 (%0)：必須為 0、2 或 3"
# 'tool-template options'
HBCF3F3069BB4: '工具模板選項'
# 'top-level comma expression in array subscript is deprecated in C++20 and unsupported in C++23'
HE89EE6B0F334: 'C++20 中陣列下標的頂層逗號運算式已過時，C++23 中不支援'
# 'total number of threads cannot exceed %0'
H1884DB567221: '總執行緒數不可超過 %0'
# 'total token limit set here'
HC6BF74A3FD57: '在此設定的總記號限制'
# 'toy compiler\n'
H2EDD43662B08: '玩具編譯器\n'
# 'trailing requires clause can only be used when declaring a function'
H084306C3877A: '尾隨 requires 子句只能用在宣告函數時'
# 'trailing requires clause should be placed outside parentheses'
H548F58E8723A: '尾隨 requires 子句應放在括號外'
# 'trailing return type may not be nested within parentheses'
HC76578BE367C: '尾隨傳回型別不可嵌套在括號內'
# 'trailing return type must appear before trailing requires clause'
HA5D12CC5013B: '尾隨傳回型別必須出現在尾隨 requires 子句之前'
# 'trailing return types are incompatible with C++98'
H32DC951D7875: '尾隨傳回型別與 C++98 不相容'
# 'translate addresses using BAT'
HDDEE1DC9B85A: '使用 BAT 轉換地址'
# 'translation unit contains multiple module declarations'
HF895A4F45EF2: '翻譯單位包含多個模組宣告'
# 'translation unit is too large for Clang to process: ran out of source locations'
H8B3695BCDB65: '翻譯單位過大，Clang 無法處理：已耗盡原始程式碼位置'
# 'transparent union definition must contain at least one field; transparent_union attribute ignored'
H140F1B74DF83: '透明聯合型別定義必須包含至少一個欄位；transparent_union 屬性被忽略'
# 'transparent_union attribute can only be applied to a union definition; attribute ignored'
HD786E3576B74: 'transparent_union 屬性只能套用於聯合型別定義；否則屬性將被忽略'
# 'trap on failure'
H4518B36E2611: '失敗時中斷'
# 'treat the string as an argument to avoid this'
H276A4BE7C44E: '將字串視為參數以避免此錯誤'
# "treating #%select{include|import|include_next|__include_macros}0 as an import of module '%1'"
HCF878B660176: "將 #%select{include|import|include_next|__include_macros}0 處理為模組 '%1' 的匯入"
# "treating '%0' input as '%1' when in C++ mode, this behavior is deprecated"
H0FA024F7C782: "在 C++ 模式下將 '%0' 輸入視為 '%1'，此行為已被棄用"
# 'treating Ctrl-Z as end-of-file is a Microsoft extension'
H2B9F3B693225: '將 Ctrl-Z 視為資料流結束是 Microsoft 扩展功能'
# "treating Unicode character <U+%0> as an identifier character rather than as '%1' symbol"
H50914464E633: "將 Unicode 字元 <U+%0> 視為識別符元而非 '%1' 記號"
# 'treating Unicode character as whitespace'
HF7B2E2527DE4: '將 Unicode 字元視為空白字元'
# "trigraph converted to '%0' character"
HED476D72F781: '三字符組轉換為「%0」字元'
# 'trigraph ends block comment'
H52594FE74E90: '三字符組結束區塊註解'
# 'trigraph ignored'
H1C535A7D3139: '忽略三字符組'
# 'trust the input to be from a well-formed source'
H9D6FAC2CFAB6: '信任輸入來源為格式正確的程式碼'
# "try 'match(%0={%1%2})'"
H766B462800CF: "嘗試 'match(%0={%1%2})'"
# 'try to preserve basic block alignment'
H8B07C548FF85: '嘗試保留基本區塊的對齊'
# 'trying to recursively use %0 as superclass of %1'
H22C1DF007CBE: '遞迴使用 %0 當作 %1 的超類別'
# 'turn on the stoke analysis'
H0C2490B9B2A0: '啟用 stoke 分析'
# 'type %0 can only be used as a function parameter in OpenCL'
H43CCACC05DF1: '無法分解類型 %0'
# 'type %0 cannot be decomposed'
HAD575CEF4CDD: '類型 %0 無法分解'
# 'type %0 cannot be narrowed to %1 in initializer list'
HA66630D471E5: 'C++11的初始化清單中無法將類型 %0 窄化為 %1'
# 'type %0 cannot be narrowed to %1 in initializer list in C++11'
H121C0CF66257: '類型 %0 無法在初始化清單中窄化為 %1（C++11）'
# "type %0 cannot be used prior to '::' because it has no members"
HB29A2AE6A5EB: '類型 %0 在 "::" 之前無法使用，因其無成員'
# 'type %0 decomposes into %3 %plural{1:element|:elements}2, but %select{%plural{0:no|:only %1}1|%1}4 %plural{1:name was|:names were}1 provided'
HF59CA2FD696F: '類型 %0 分解成 %3 %plural{1:元素|:元素}2，但 %select{%plural{0:沒有|:僅有 %1}1|%1}4 %plural{1:名稱已指定|:名稱已指定}1'
# 'type %0 does not provide a %select{subscript|call}1 operator'
HCAF6714D32F7: '類型 %0 未提供 %select{索引運算子|呼叫運算子}1'
# 'type %0 found by destructor name lookup'
H35BD375D3364: '由析構函式名稱搜尋找到類型 %0'
# 'type %0 has incompatible definitions in different translation units'
HB192C667507F: '類型 %0 在不同翻譯单元中有不相容的定義'
# 'type %0 has unexpected layout'
H8C8909F11F0A: '類型 %0 具有意外的佈局'
# 'type %0 in generic association compatible with previously specified type %1'
H1178A958ED5C: '泛型關聯中的類型 %0 與先前指定的類型 %1 兼容'
# 'type %0 in generic association is a variably modified type'
HCA8F3A82743E: '泛型關聯中的類型 %0 是可變長度修飾類型'
# 'type %0 in generic association not an object type'
H9CBDAFFFD0D2: '泛型關聯中的類型 %0 不是物件類型'
# 'type %0 is incomplete'
H68C687943CFB: '類型 %0 是不完整類型'
# 'type %0 is not a direct or virtual base of %1'
HA6EFF9DEE3C5: '類型 %0 不是 %1 的直接或虛基類'
# 'type %0 is not trivially copyable and not guaranteed to be mapped correctly'
HA6A4CD2AE815: '類型 %0 不是可簡單複製的 (trivially copyable)，且無法保證正確映射'
# 'type %0 of function parameter pack does not contain any unexpanded parameter packs'
H5D64B61067E5: '函式參數包的類型 %0 不包含未展開的參數包'
# 'type %0 of non-type template parameter is not a structural type'
H546F4F02218C: '非類型模板參數的類型 %0 不是結構型類型'
# 'type %0 requires %1 bytes of alignment and the default allocator only guarantees %2 bytes'
H82A5F7C1A758: '類型 %0 需要 %1 bytes 的對齊，而預設配置器僅保證 %2 bytes 的對齊'
# 'type %2 of %select{explicit instantiation|explicit specialization|partial specialization|redeclaration}0 of %1 does not match expected type %3'
H34154FB5D28F: '類型 %2 的 %select{顯式實例化|顯式特化|部分特化|重新宣告}0 %1 的類型與期望類型 %3 不符'
# "type argument %0 cannot be qualified with '%1'"
HF21B2C8937B4: '類型參數 %0 不能使用 "%1" 修飾'
# 'type argument %0 cannot explicitly specify nullability'
H1330164CF91E: '類型參數 %0 不能明確指定空安全性'
# 'type argument %0 does not satisfy the bound (%1) of type parameter %2'
H3669CF5C9A7D: '類型參數 %0 不符合類型參數 %2 的限制 (%1)'
# 'type argument %0 is neither an Objective-C object nor a block type'
HC89732C094A1: '類型參數 %0 非 Objective-C 物件或 Block 類型'
# "type argument %0 must be a pointer (requires a '*')"
HF674997DE917: '類型參數 %0 必須是指標類型（需要 "*"）'
# 'type argument of iboutletcollection attribute cannot be a builtin type'
H26C24AC03DB8: 'iboutletcollection 屬性之類型參數不能是內建類型'
# 'type arguments cannot be applied to already-specialized class type %0'
H67EB09767F26: '無法將類型參數套用到已特化的類別類型 %0'
# 'type arguments cannot be applied to non-class type %0'
H41CCF55FF38B: '無法將類型參數套用到非類別類型 %0'
# 'type arguments cannot be applied to non-parameterized class %0'
HC40C2F44A862: '無法將類型參數套用到非參數化類別 %0'
# 'type bound %0 for type parameter %1 conflicts with %select{implicit|previous}2 bound %3%select{for type parameter %5|}4'
H7F10FC1165B9: '類型參數 %1 的類型限制 %0 與 %select{隱含的|先前的}2 限制 %3%select{對類型參數 %5|}4 冲突'
# 'type bound %0 for type parameter %1 is not an Objective-C pointer type'
H80B67C4F94CD: '類型參數 %1 的類型限制 %0 非 Objective-C 指標類型'
# "type bound %1 for type parameter %0 cannot be qualified with '%2'"
H3CC7E562DE4D: '%1 的類型限制 %0 不能使用 "%2" 修飾'
# 'type constraint differs in template redeclaration'
HA94E71A6CC7A: '範本重新宣告的類型限制不同'
# 'type conversion function declared here'
H7B0CCA1F5818: '類型轉換函數在此處宣告'
# 'type declaration hidden'
H161A31411076: '類型宣告被隱藏'
# 'type definition in a constexpr %select{function|constructor}0 is a C++14 extension'
HB61A32D40D4A: '在 constexpr %select{函式|建構函式}0 中的類型定義是 C++14 的擴充功能'
# 'type definition in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14'
H51291DDF6B58: '在 constexpr %select{函式|建構函式}0 中的類型定義與 C++14 之前的標準不相容'
# 'type inference of a declaration other than a plain identifier with optional trailing attributes is a Clang extension'
HB4EF9FC7F52F: '非簡單識別子（附帶可選的尾端屬性）的宣告類型推論是 Clang 的擴充功能'
# 'type is given name %0 for linkage purposes by this %select{typedef|alias}1 declaration'
HFEABA5A13E20: '此 %select{typedef|別名}1 宣告為連結目的將類型命名為 %0'
# 'type is not C-compatible due to this %select{base class|default member initializer|lambda expression|friend declaration|member declaration}0'
H8BEB926AC2A7: '此 %select{基類|預設成員初始化式|lambda 表達式|友元宣告|成員宣告}0 使類型無法與 C 兼容'
# 'type name does not allow %select{<ERROR>|constexpr|consteval|constinit}0 specifier to be specified'
H2BAC4BD9B411: '類型名稱不允許指定 %select{<ERROR>|constexpr|consteval|constinit}0 修飾符'
# 'type name does not allow function specifier to be specified'
H63933758FA41: '類型名稱不允許指定函式修飾符'
# 'type name does not allow storage class to be specified'
HD221C2943356: '類型名稱不允許指定儲存類別'
# 'type name requires a specifier or qualifier'
H9BCBB335F47F: '類型名稱需要指定修飾符或限定符'
# 'type nullability specifier %0 is a Clang extension'
HFDBD8198839C: '類型空值安全性修飾符 %0 是 Clang 的擴充功能'
# 'type of %ordinal0 parameter of local declaration does not match definition%diff{ ($ vs $)|}1,2'
HC35F751A0E20: '本地宣告的第%ordinal0個參數類型與定義%diff{ ($ vs $)|}1,2 不相符'
# 'type of %ordinal0 parameter of member declaration does not match definition%diff{ ($ vs $)|}1,2'
H6D265791AD7D: '成員宣告的第%ordinal0個參數類型與定義%diff{ ($ vs $)|}1,2 不相符'
# 'type of UTF-8 string literal will change from array of char to array of char8_t in C23'
HDD96729D3F80: 'UTF-8 字元串字面值的類型在 C23 中將從 char 陣列變更為 char8_t 陣列'
# 'type of UTF-8 string literal will change from array of const char to array of const char8_t in C++20'
H2FF4EC88FBDF: 'UTF-8 字串字面量的類型在 C++20 中將從 const char 陣列變更為 const char8_t 陣列'
# 'type of machine mode does not match type of base type'
HCC37C6223BD0: '機器模式類型與基礎類型的類型不符'
# 'type of machine mode does not support base vector types'
HC82FE5FB775E: '機器模式類型不支援基礎向量類型'
# 'type of property %0 (%1) does not match type of accessor %2 (%3)'
H588E7AE2B664: '屬性 %0 的類型 (%1) 與存取器 %2 的類型 (%3) 不符'
# 'type of property %0 (%1) does not match type of instance variable %2 (%3)'
H73BAE4F8734B: '屬性 %0 的類型 (%1) 與實體變數 %2 的類型 (%3) 不符'
# 'type of property %0 does not match type of accessor %1'
H270F876040C0: '屬性 %0 的類型與存取器 %1 的類型不符'
# 'type of property %0 in class extension does not match property type in primary class'
H132F7594C298: '類別擴充中屬性 %0 的類型與主要類別中的屬性類型不符'
# 'type of setter must be void'
HD41AE4C60492: '設定器的類型必須為 void'
# 'type of specialized non-type template argument depends on a template parameter of the partial specialization'
HBDE8FF32FC3A: '部分特殊化模板參數依賴的特殊化非類型模板參數類型會改變'
# 'type of thread-local variable has non-trivial destruction'
H8E6776B80F65: '執行緒局部變數的類型具有非平凡的析構'
# "type operand %0 of 'typeid' cannot have '%1' qualifier"
HBE87B8BABE8E: "'typeid' 的類型操作數 %0 不能具有 '%1' 限定符"
# 'type parameter %0 bound %1 cannot explicitly specify nullability'
H73C9FD2AB78B: '類型參數 %0 的綁定 %1 不能明確指定可為空性'
# 'type parameter %0 declared here'
HFF5B8C2A68FC: '在此處宣告的類型參數 %0'
# "type specifier missing, defaults to 'int'"
H4B268E82A57A: "類型指定項遺失，預設為 'int'"
# "type specifier missing, defaults to 'int'; ISO C99 and later do not support implicit int"
H8CEE1B0F6CB9: "類型指定者遺失，預設為 'int'; ISO C99 及更新版本不支援隱式 int"
# 'type trait requires %0%select{| or more}1 argument%select{|s}2; have %3 argument%s3'
H5F2DEBC2DD6F: '類型特性需要 %0%select{|或更多}1 個參數 %select{|s}2; 獲得 %3 個參數'
# 'type was declared read-only here'
HAFE8C580C1C1: '類型在此處被宣告為唯讀'
# 'type-id cannot have a name'
H0F4A38BF6BC0: '類型識別符無法命名'
# 'type-less parameter names in function declaration'
H4275A67CD2BD: '函數宣告中的無類型參數名稱'
# 'typedef declarator cannot be qualified'
H13CBEB4EC130: 'typedef 声明符不能被限定'
# 'typedef member %0 cannot be a bit-field'
HF1C17DDE556A: 'typedef 成員 %0 不能是位段'
# 'typedef name must be an identifier'
H0FF9C8135AE0: 'typedef 名稱必須是識別符'
# 'typedef requires a name'
HD4A732841C3B: 'typedef 需要名稱'
# 'typeid applied to expression of polymorphic type %0 is not allowed in a constant expression in C++ standards before C++20'
H56E5AEAEB4DB: '在 C++20 之前的標準中，對多態類型 %0 的表達式使用 typeid 不允許作為常量運算式'
# 'typeid will not work since RTTI data is disabled by %select{-fno-rtti-data|/GR-}0'
H44DAF1F1B628: 'typeid 將無法運作，因 RTTI 資料被 %select{-fno-rtti-data|/GR-}0 關閉'
# 'typename is allowed for identifiers only'
HEE2C4836DC27: 'typename 只允許用在識別符'
# 'typename specifier refers to %select{class template|function template|variable template|alias template|template template parameter|template}0 member in %1; argument deduction not allowed here'
H15F65651B175: 'typename 指定者引用 %select{類別模板|函數模板|變數模板|別名模板|模板模板參數|模板}0 成員於 %1; 此處不允許引數推論'
# 'typename specifier refers to %select{class template|function template|variable template|alias template|template template parameter|template}0; argument deduction not allowed here'
HDDA5FA8262A7: 'typename 指定符指向%select{類模板|函式模板|變數模板|別名模板|模板模板參數|模板}0；此處不允许參數推導'
# 'typename specifier refers to a dependent using declaration for a value %0 in %1'
HA4640204C28B: 'typename 指定符指向在 %1 中值 %0 的依賴 using 宣告'
# 'typename specifier refers to a non-type template'
HDA01E7DE1981: 'typename 指定符指向非類型模板'
# 'typename specifier refers to non-type %0'
H68FFAB15F6B4: 'typename 指定符指向非類型 %0'
# 'typename specifier refers to non-type member %0 in %1'
HAD3AB5D3DF5D: 'typename 指定符指向 %1 中的非類型成員 %0'
# 'types cannot be declared in an anonymous %select{struct|union}0'
HB8A6E3596B04: '匿名%select{結構|聯合}0中不能宣告類型'
# 'types declared in an anonymous %select{struct|union}0 are a Microsoft extension'
H10CD33288972: '匿名%select{結構|聯合}0中的類型宣告是 Microsoft 扩展'
# 'types may not be defined in a for range declaration'
HA0579AB1E4A8: 'for 範圍宣告中不能定義類型'
# "types with 'sycl_special_class' attribute must have one and only one '__init' method defined"
H49F85977919C: "具有 'sycl_special_class' 屬性的類必須定義且僅定義一個 '__init' 方法"
# "umbrella directory '%0' not found"
H7F60E99942C1: "找不到 umbrella 目錄 '%0'"
# "umbrella for module '%0' already covers this directory"
HAE8DEE1E4013: "module '%0' 的 umbrella 已覆蓋此目錄"
# "umbrella header for module '%0' does not include header '%1'"
H803B3F536D5A: "module '%0' 的 umbrella 頭檔未包含頭檔 '%1'"
# "unable to create target: '%0'"
H48D73D54C838: "無法建立目標：'%0'"
# 'unable to execute command: %0'
H1274C3267D8B: '無法執行指令：%0'
# "unable to find %0 directory, expected to be in '%1' found via %2"
HFA08DE02A86A: "找不到 %0 目錄，期望位於 '%1'，但透過 %2 找到的位置不同"
# "unable to find %select{'::operator new(size_t, nothrow_t)'|'::operator new(size_t, align_val_t, nothrow_t)'}1 for %0"
HD53B43D38AB3: "無法找到 %select{'::operator new(size_t, nothrow_t)'|'::operator new(size_t, align_val_t, nothrow_t)'}1 的宣告給 %0"
# 'unable to find a Visual Studio installation; try running Clang from a developer command prompt'
HD5A60BEBFC34: '無法找到 Visual Studio 安裝；嘗試從開發人員命令提示字元執行 Clang'
# "unable to find module '%0'"
H4F4B8FBAA599: "無法載入模組 '%0'"
# "unable to find plugin '%0'"
H694242203542: "無法載入外掛程式 '%0'"
# "unable to handle compilation, expected exactly one compiler job in '%0'"
H0ED90FBA3001: "無法處理編譯，'%0' 中期望恰好一個編譯任務"
# 'unable to interface with target machine'
H48913BEFE8AE: '無法與目標機器進行介面通訊'
# 'unable to load PCH file'
H0C8F5802F259: '無法載入 PCH 檔案'
# "unable to load basic block sections function list: '%0'"
H3C61D53F0989: "無法載入函式清單的基本區塊區段：'%0'"
# "unable to load plugin '%0': '%1'"
HEABDF34863F0: "無法載入外掛程式 '%0'：'%1'"
# 'unable to make temporary file: %0'
HB69A4D68B994: '無法建立臨時檔案：%0'
# "unable to merge a subprocess's serialized diagnostics"
H0736A846C8D2: '無法合併子程序的序列化診斷資訊'
# 'unable to open CC_LOG_DIAGNOSTICS file: %0 (using stderr)'
H5386FA1E767C: '無法開啟 CC_LOG_DIAGNOSTICS 檔案：%0（改用 stderr）'
# 'unable to open CC_PRINT_HEADERS file: %0 (using stderr)'
H9ABA30151CEC: '無法開啟 CC_PRINT_HEADERS 檔案：%0（改用 stderr）'
# 'unable to open CC_PRINT_OPTIONS file: %0'
HEA741366E890: '無法開啟 CC_PRINT_OPTIONS 檔案：%0'
# 'unable to open file %0 for serializing diagnostics (%1)'
HD09A684B5E47: '無法開啟用於序列化診斷的檔案 %0 (%1)'
# "unable to open output file '%0': '%1'"
H1FD155FFBE98: "無法開啟輸出檔案 '%0': '%1'"
# "unable to open statistics output file '%0': '%1'"
HDC9884A86150: "無法開啟統計資料輸出檔案 '%0': '%1'"
# 'unable to overwrite file %0: %1'
HF040F371E4DB: '無法覆寫檔案 %0: %1'
# 'unable to protect inline asm that clobbers stack pointer against stack clash'
H57F37138A9DF: '無法保護lobber stack pointer的內聯asm以防止堆疊衝突'
# "unable to read PCH file %0: '%1'"
H53BCE7FDE626: '無法讀取PCH檔案 %0: "%1"'
# 'unable to remove file: %0'
HA87F741C0BFD: '無法移除檔案: %0'
# "unable to rename temporary '%0' to output file '%1': '%2'"
H621AA5D0DBAB: '無法將臨時檔 "%0" 重新命名為輸出檔案 "%1": "%2"'
# 'unable to resolve declare reduction construct for type %0'
H4CBC0B2EAEEC: '無法解決型別 %0 的declare reduction構造'
# 'unable to set working directory: %0'
H1915AC32A7BB: '無法設置工作目錄: %0'
# 'unannotated fall-through between switch labels'
HD2F0C0FDF581: '未標註的fall-through在switch標籤間'
# 'unannotated fall-through between switch labels in partly-annotated function'
H8BA6FF77BB8B: '在部分標註的函數中，switch標籤間的未標註fall-through'
# "unary fold expression has empty expansion for operator '%0' with no fallback value"
HE62A3703EA3A: "運算子 '%0' 的單一摺疊運算式在無預設值的情況下展開為空"
# 'unary operator not supported, only increment and decrement operations permitted'
HCFDDCEAA7D4F: '不支援單一運算子，僅允許遞增和遞減運算'
# 'undeclared identifier %0 in destructor name'
H9E161BF60045: '析構函數名稱中未宣告的識別符 %0'
# 'undeclared selector %0'
H76DFE4FB888F: '未宣告的選擇子 %0'
# 'undeclared selector %0; did you mean %1?'
HFF50CB7951F9: '未宣告的選擇子 %0；您是否意指 %1？'
# "undeclared variable %0 used as an argument for '#pragma unused'"
H1A926D40EA78: "將未宣告的變數 %0 用作 '#pragma unused' 的參數"
# 'undef all system defines'
H5E817AACEB7A: '清除所有系統定義的宏'
# 'undefining builtin macro'
H855B9F8C6AE6: '清除內建宏'
# 'under -fcoro-aligned-allocation, the non-aligned allocation function for the promise type %0 has higher precedence than the global aligned allocation function'
H677A6074184D: '在 -fcoro-aligned-allocation 下，承諾類型 %0 的非對齊分配函數優先級高於全域對齊分配函數'
# 'underaligned exception object thrown'
H67F3421C41BE: '抛出未對齊的例外物件'
# "unelaborated friend declaration is a C++11 extension; specify '%select{struct|interface|union|class|enum}0' to befriend %1"
H85486A35A143: "未具體說明的 friend 宣告是 C++11 的擴充功能；請指定 '%select{struct|interface|union|class|enum}0' 來與 %1 建立 friend 關係"
# 'unexpected %0 in function call; perhaps remove the %0?'
HF91D5DDAC941: '函數呼叫中出現意外的 %0；或許移除 %0？'
# "unexpected %0, expected to see one of %select{|'best_case', 'full_generality', }1'single_inheritance', 'multiple_inheritance', or 'virtual_inheritance'"
H715E4C7A8362: "意外的 %0，期望下列其中一個：%select{|'best_case', 'full_generality', }1'single_inheritance', 'multiple_inheritance' 或 'virtual_inheritance'"
# "unexpected '#pragma acc ...' in program"
H1E1E01704393: "程式中出現意外的 '#pragma acc ...'"
# "unexpected '#pragma omp ...' in program"
H46D7021997C2: "程式中出現意外的 '#pragma omp ...'"
# "unexpected '%0' clause, '%1' is specified already"
H5B200478E6AE: "出現意外的 '%0' 子句，'%1' 已經被指定"
# "unexpected '%0' clause, only %select{'device_type'|'enter' or 'link'|'enter', 'link' or 'device_type'|'device_type', 'indirect'|'enter', 'link', 'device_type' or 'indirect'}1 clauses expected"
H3763BE9D9C9F: "出現意外的 '%0' 子句，僅允許 %select{'device_type'|'enter 或 link'|'enter'、'link' 或 'device_type'|'device_type'、'indirect'|'enter'、'link'、'device_type' 或 'indirect'}1 子句"
# "unexpected '%0' clause, only %select{'device_type'|'to' or 'link'|'to', 'link' or 'device_type'|'device_type', 'indirect'|'to', 'link', 'device_type' or 'indirect'}1 clauses expected"
H1A9F6651CC12: "出現意外的 '%0' 子句，僅允許 %select{'device_type'|'to 或 link'|'to'、'link' 或 'device_type'|'device_type'、'indirect'|'to'、'link'、'device_type' 或 'indirect'}1 子句"
# "unexpected '(', only 'to', 'link' or 'device_type' clauses expected for 'begin declare target' directive"
H5361030EF185: "在 'begin declare target' 指令中，括號 '(' 是不被允許的，僅接受 'to', 'link' 或 'device_type' 子句"
# "unexpected ':' in nested name specifier; did you mean '::'?"
HC8B611B07937: "嵌套名稱指定中出現意外的 ':'；是否想輸入 '::'？"
# "unexpected ';' before %0"
H257D20769B88: "在 %0 之前出現意外的 ';'"
# "unexpected '@' in member specification"
HFD6F988E847A: "成員規格中出現意外的 '@'"
# "unexpected '@' in program"
H0E6C2D976254: "程式中出現意外的 '@'"
# "unexpected 'enter' clause, use 'to' instead"
H005905027939: "出現意外的 'enter' 子句，請改用 'to'"
# "unexpected 'execution' modifier in non-executable context"
HA6BB9CA468FA: "在非可執行語境中遇到不期望的 'execution' 修飾符"
# "unexpected 'to' clause, use 'enter' instead"
H48CD21AE4031: "遇到不期望的 'to' 子句，應改用 'enter'"
# "unexpected OpenACC directive %select{|'#pragma acc %1'}0"
H996256861627: "意外的 OpenACC 指令 %select{|'#pragma acc %1'}0"
# "unexpected OpenMP clause '%0' in directive '#pragma omp %1'"
H1C5752C27ACF: "在 OpenMP 指令 '#pragma omp %1' 中發現不支援的子句 '%0'"
# "unexpected OpenMP directive %select{|'#pragma omp %1'}0"
HEF8086A19118: "意外的 OpenMP 指令 %select{|'#pragma omp %1'}0"
# "unexpected argument '%0' to '#pragma %1'%select{|; expected %3}2"
HB8C385DE07A5: "#pragma %1 的參數 '%0' 不正確 %select{|；期望 %3}2"
# "unexpected argument '%0' to '#pragma clang attribute'; expected 'push' or 'pop'"
H3133E5143B09: "#pragma clang attribute 的參數 '%0' 不正確；期望 'push' 或 'pop'"
# "unexpected argument '%0' to '#pragma clang fp %1'; expected %select{'fast' or 'on' or 'off'|'on' or 'off'|'on' or 'off'|'ignore', 'maytrap' or 'strict'|'source', 'double' or 'extended'}2"
H371571C43BD4: "#pragma clang fp %1 的參數 '%0' 不正確；期望 %select{'fast' 或 'on' 或 'off'|'on' 或 'off'|'on' 或 'off'|'ignore', 'maytrap' 或 'strict'|'source', 'double' 或 'extended'}2"
# "unexpected argument '%0' to '#pragma clang optimize'; expected 'on' or 'off'"
H1485FAA86056: "#pragma clang optimize 的參數 '%0' 不正確；期望 'on' 或 'off'"
# 'unexpected argument to debug command'
H3827CC068DE1: '除錯指令的參數不正確'
# 'unexpected character <U+%0>'
H5B9099D7894E: '意外的 Unicode 字元 <U+%0>'
# "unexpected clause after an implicit 'enter' clause"
H3710E8F80D5B: "隱含 'enter' 子句後不應再出現其他子句"
# "unexpected clause after an implicit 'to' clause"
H2010F6D7C809: "隱含 'to' 子句後不應再出現其他子句"
# "unexpected debug command '%0'"
H8054F9A13F94: "遇到未知的除錯指令 '%0'"
# 'unexpected end of default argument expression'
H2637B90369AC: '預設參數表達式意外結束'
# 'unexpected end of exception specification'
HE58D2A2E3875: '例外規格說明意外結束'
# 'unexpected expression: number of expressions is larger than the number of associated loops'
H7A04530C8247: '表達式數量大於相關的迴圈數量'
# "unexpected extra argument '%0' to '#pragma clang optimize'"
HD169A0238D64: "#pragma clang optimize 意外多出參數 '%0'"
# 'unexpected extra tokens at end of @import declaration'
HC94D2D8555A6: '@import 宣告結尾處有多餘的語法單元'
# 'unexpected interface name %0: expected expression'
HD34771026F11: '意外的介面名稱 %0：期望運算式'
# 'unexpected namespace name %0: expected expression'
HD2F7F8269F1D: '意外的命名空間名稱 %0：期望運算式'
# 'unexpected namespace scope prior to decltype'
H276642EE3F52: 'decltype 之前的命名空間作用域不合法'
# "unexpected operation specified in 'append_args' clause, expected 'interop'"
H7343FC2DA837: "在 'append_args' 子句中指定了意外的操作，期望 'interop'"
# "unexpected output symbol graph '%1'; please provide '--symbol-graph-dir=<directory>' instead"
H16E9C665ACBA: "unexpected 輸出符號圖 '%1'；請改提供 '--symbol-graph-dir=<目錄>'"
# "unexpected parameter '%0' in availability attribute, not permitted in %select{HLSL|C/C++}1"
H3A2F294B2383: "在 %select{HLSL|C/C++}1 中不允許在可用性屬性中使用參數 '%0'"
# 'unexpected token after Objective-C string'
H279452517A7B: 'Objective-C 字串後出現 unexpected token'
# 'unexpected token in pragma diagnostic'
HF7F8BD94B55D: 'pragma diagnostic 中出現 unexpected token'
# 'unexpected type name %0: expected expression'
H5096D6005D2D: '意外的類型名稱 %0：期望運算式'
# 'unexpected type name %0: expected identifier'
HECE4BA85049C: '意外的類型名稱 %0：期望識別符'
# "unexpected value; use 'true' or 'false'"
HBC54A5A54D19: "unexpected 值；請使用 'true' 或 'false'"
# 'unguarded header; consider using #ifdef guards or #pragma once'
H1B291D4D56CA: '未受保護的標頭；建議使用 #ifdef 守護或 #pragma once'
# 'unicode literals are incompatible with C standards before C23'
H7CE9D5273D56: 'Unicode 文字在 C23 之前的標準中不相容'
# 'unicode literals are incompatible with C++ standards before C++17'
H41D963C4F029: 'Unicode 文字與 C++17 之前的 C++ 標準不相容'
# 'unicode literals are incompatible with C++98'
H63FE9D503E73: 'Unicode 文字與 C++98 不相容'
# 'unicode literals are incompatible with C99'
H413288F05A72: 'Unicode 文字字面量與 C99 不相容'
# 'unimplemented constexpr lambda feature: %0 (coming soon!)'
H49A46ED86D09: '未實作的 constexpr lambda 功能：%0（即將推出！）'
# 'unimplemented pure virtual method %0 in %1'
H6BCBAEFB56A1: '%1 中未實作純虛函數 %0'
# 'uninitialized reference member is here'
HD2F77230D93D: '此處有未初始化的參考成員'
# 'uninitialized variable in a constexpr %select{function|constructor}0 is a C++20 extension'
HD0E4F93C0D47: 'constexpr %select{函數|建構子}0 中的未初始化變數是 C++20 的擴充功能'
# 'uninitialized variable in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++20'
HB023F58DC7FA: 'constexpr %select{函數|建構子}0 中的未初始化變數與 C++20 之前的标准不相容'
# 'union member %0 has reference type %1'
H0725C5FA90A3: '聯合成員 %0 的類型是引用類型 %1'
# 'union member %0 has reference type %1, which is a Microsoft extension'
H717E84EDF789: '聯合成員 %0 的類型是引用類型 %1，這是 Microsoft 的擴充功能'
# 'unions cannot be base classes'
H3537D21C3F62: '聯合不能作為基類'
# 'unions cannot have base classes'
HC69C8BA7958A: '聯合不能有基類'
# 'unions cannot have virtual functions'
HE6462B703CAB: '聯合不能有虛函數'
# 'universal character name referring to a control character is incompatible with C standards before C23'
H443795B4C160: '指向控制字元的通用字元名稱與 C23 之前的 C 標準不相容'
# 'universal character name referring to a control character is incompatible with C++98'
H441444D5A2FF: '指向控制字元的通用字元名稱與 C++98 不相容'
# 'universal character name refers to a control character'
H0A302EE7A7D5: '通用字元名稱指向代理字元'
# 'universal character name refers to a surrogate character'
H38343641D115: '通用字元名稱指向代理字元'
# 'universal character names are only valid in C99 or C++'
H6C064E2FEAA1: '通用字元名稱僅在 C99 或 C++ 中有效'
# "universal character names are only valid in C99 or C++; treating as '\\' followed by identifier"
H57AF83D90AE3: "通用字元名稱僅在 C99 或 C++ 中有效；將其視為 '\\' 後接識別符處理"
# "unknown %0 warning specifier: '%1'"
HE021FCA9FD45: "未知的 %0 警告指定符：'%1'"
# 'unknown %select{type|class}1 name %0; did you mean %2?'
H3C8376ED6B78: '未知的 %select{類型|類別}1 名稱 %0；是否是指 %2？'
# "unknown %select{warning|remark}0 option '%1'%select{|; did you mean '%3'?}2"
HE86784D7A808: "未知的 %select{警告|提示}0 選項 '%1'%select{|；是否是指 '%3'？}2"
# "unknown '-mindirect-jump=' option '%0'"
H632D52B85B4D: "未知的 '-mindirect-jump=' 選項 '%0'"
# "unknown FP unit '%0'"
HC0D93947CA5F: "未知的浮點運算單元 '%0'"
# 'unknown HLSL semantic %0'
H173D19A6AD63: '未知的 HLSL 語意 %0'
# "unknown action '%1' for '#pragma %0' - ignored"
HD5134EB4614C: "'#pragma %0' 中未預期的動作 '%1' - 已忽略"
# "unknown action for '#pragma %0' - ignored"
HC6ADA3F7938E: '未知的 #pragma %0 動作 - 已忽略'
# "unknown analyzer-config '%0'"
H50FE6AD53FF0: "未知的分析器配置 '%0'"
# "unknown argument '%0'; did you mean '%1'?"
HBDB4C2710C85: "未知的引數 '%0'；您是指 '%1' 吗？"
# "unknown argument ignored in clang-cl '%0'; did you mean '%1'?"
HFC74C4C6226A: "clang-cl 中忽略未知的引數 '%0'；您是指 '%1' 吗？"
# "unknown argument ignored in clang-cl: '%0'"
HC759BFBE35F6: "clang-cl 中忽略未知的引數：'%0'"
# "unknown argument: '%0'"
HA16D3B1BF1E9: "未知的引數：'%0'"
# "unknown assumption string '%0' may be misspelled; attribute is potentially ignored, did you mean '%1'?"
H50CF8A7A4EC4: "未知的假設字串 '%0' 可能拼寫錯誤；屬性可能被忽略，您是否是指 '%1'？"
# "unknown assumption string '%0'; attribute is potentially ignored"
H585A62063A9D: "未知的假設字串 '%0'；屬性可能被忽略"
# 'unknown attribute %0 ignored'
H2C00F439265B: '未知屬性 %0 被忽略'
# "unknown attribute '%0'"
HB9EC0CD4D3F9: "未知屬性 '%0'"
# "unknown attribute subject rule '%0'"
H3D3386816A55: "未知屬性主體規則 '%0'"
# 'unknown cast annotation __bridge_retain; did you mean __bridge_retained?'
H99CA4EEB19EE: '未知的轉換註解 __bridge_retain；您是否是指 __bridge_retained？'
# 'unknown command tag name'
H11BCD33A99AD: '未知的命令標籤名稱'
# "unknown command tag name '%0'; did you mean '%1'?"
H7FD2FDFA8A87: "未知的命令標籤名稱 '%0'；是否指 '%1'？"
# 'unknown diagnostic option'
HB8C73037AA51: '未知的診斷選項'
# 'unknown environment %0 in availability macro'
HAEC8AEED3CAD: '可用性巨集中未知的環境 %0'
# "unknown escape sequence '\\%0'"
H4849F8435E28: "未知的轉義序列 '\\%0'"
# 'unknown kind of pragma comment'
HA06D4573713E: '未知的 #pragma comment 種類'
# 'unknown linkage language'
H6501D0DE4EA8: '未知的連結語言'
# "unknown module '%0'"
H99985C296846: "未知模組 '%0'"
# "unknown or ill-formed Objective-C runtime '%0'"
HDD07911A4A21: "未知或格式錯誤的 Objective-C 執行階段 '%0'"
# 'unknown platform %0 in availability macro'
HD5C8076C5089: '可用性宏中包含未知平台 %0'
# 'unknown platform, assuming -mfloat-abi=%0'
HE055695902FF: '未知平台，預設使用 -mfloat-abi=%0'
# 'unknown pragma ignored'
H2A263E84EA76: '忽略未知的 pragma'
# 'unknown pragma in STDC namespace'
HB8BAEB9D2633: '在 STDC 命名空間中的未知 pragma'
# 'unknown property attribute %0'
HA552B52A5631: '未知屬性 %0'
# 'unknown receiver %0; did you mean %1?'
HF53B2435A683: '未知的接收器 %0；您是否要指定 %1？'
# "unknown register name '%0' in asm"
H0A30B49D2F93: "asm 中未知的暫存器名稱 '%0'"
# "unknown remark serializer format: '%0'"
H4745BF37BA54: "未知的註記序列化格式：'%0'"
# "unknown sanitizer '%0' ignored"
H7A7513A62BEF: "未知的除錯器 '%0' 被忽略"
# "unknown state '%0'"
HBCA6965044DA: "未知的狀態 '%0'"
# 'unknown symbolic operand name in inline assembly string'
HA556FD6AA91E: '內嵌組裝語言字串中存在未知的符號運算元名稱'
# "unknown target ABI '%0'"
HCA5838C6F428: "未知的目標 ABI '%0'"
# "unknown target CPU '%0'"
H70DCB9C1156C: "未知的目標 CPU '%0'"
# "unknown target triple '%0'"
HF45924A5A477: "未知的目標三元組 '%0'"
# 'unknown template name %0'
HF6FA1BD9E3B7: '未知的範本名稱 %0'
# 'unknown type name %0'
HE3210F6A77D6: '未知的類型名稱 %0'
# 'unknown type name %0; did you mean %1?'
H2AA39E457B1F: '未知的類型名稱 %0；您是否是指 %1？'
# 'unknown visibility %0'
HD580631FB230: '未知的可見性 %0'
# "unknown warning group '%0'"
H8B8A3DBA2D6F: "未知的警告群組 '%0'"
# "unknown warning group '%0', ignored"
H9E42BAF52A2D: "未知警告群組 '%0'，已忽略"
# "unknown%select{ | embed}0 preprocessor parameter '%1'"
HD697EE356FF3: "未知%select{ | 嵌入}0 前處理參數 '%1'"
# 'unnamed enumeration must be a definition'
H4B9605BBAC49: '未命名的列舉必須是定義'
# 'unnamed type as template argument is incompatible with C++98'
HCF539CBCF367: '未命名類型作為範型參數與 C++98 不相容'
# 'unnamed type used in template argument was declared here'
H766AB8914B51: '在此處宣告的未命名類型用於範型參數'
# 'unnamed variable cannot be implicitly captured in a lambda expression'
HC2AE531DDA32: '無法隱式捕獲未命名變數於 lambda 表達式中'
# 'unparsed tokens following type'
H64EC0A0DBA9B: '類型後跟有未解析的標記'
# 'unqualified base initializer of class templates is a Microsoft extension'
H18E0D4547A36: '類模板的無資格基類初始化器是 Microsoft 的擴充功能'
# "unqualified call to '%0'"
HA083B268F3B3: "對 '%0' 進行無資格呼叫"
# 'unqualified friend declaration referring to type outside of the nearest enclosing namespace is a Microsoft extension; add a nested name specifier'
H99771505062C: '在最近的包圍命名空間之外引用類型的無資格友元宣告是 Microsoft 的擴充功能；請加入嵌套名稱限定詞'
# 'unreachable declaration of template entity is here'
H8957FB46EC11: '無法抵達的模板實體宣告位於此處'
# "unrecognized parameter passing direction, valid directions are '[in]', '[out]' and '[in,out]'"
H451D99C06285: "未識別的參數傳遞方向，有效方向為 '[in]', '[out]' 和 '[in,out]'"
# 'unrecognized platform name %0'
H3352495501E4: '未識別的平台名稱 %0'
# 'unsequenced modification and access to %0'
HF69B798309CF: '%0 的未按序修改與存取'
# 'unsupported %0 gpu architecture: %1'
HFE203A3E528C: '不支援的 %0 GPU 架構：%1'
# "unsupported '%0' value '%1'; use 'ios-macabi' instead"
H4B7365627CB3: "不支援 '%0' 值 '%1'；請改用 'ios-macabi'"
# 'unsupported CUDA gpu architecture: %0'
HBDA907ABC960: '不支援的 CUDA GPU 架構：%0'
# 'unsupported MC/DC boolean expression; contains an operation with a nested boolean expression. Expression will not be covered'
H0E188D9916C4: '不支援的 MC/DC 布林運算式；其中包含帶有嵌套布林運算式的運算。此運算式不會被覆蓋'
# 'unsupported MC/DC boolean expression; number of conditions (%0) exceeds max (%1). Expression will not be covered'
H97B49477D381: '不支援的 MC/DC 布林運算式；條件數量 (%0) 超過最大值 (%1)。此運算式不會被覆蓋'
# 'unsupported MC/DC boolean expression; number of test vectors (%0) exceeds max (%1). Expression will not be covered'
HA1952652ED2D: '不支援的 MC/DC 布林運算式；測試向量數量 (%0) 超過最大值 (%1)。此運算式不會被覆蓋'
# 'unsupported OpenCL extension %0 - ignoring'
H90715CF4E48F: '不支援的 OpenCL 增益軛 %0 - 已忽略'
# "unsupported architecture '%0' for MS-style inline assembly"
H4CDA8CDAE447: "MS 風格內嵌組合語言不支援 '%0' 硬體架構"
# "unsupported architecture '%0' for host compilation"
HF6B9D10A3CB2: "主機編譯不支援 '%0' 硬體架構"
# "unsupported argument '%1' to option '%0'"
HF8679865943E: "選項 '%0' 的未支援引數 '%1'"
# "unsupported argument '%1' to option '%0' for target '%2'"
H4C786BC0FD2F: "目標 '%2' 的選項 '%0' 不支援引數 '%1'"
# "unsupported branch protection specification '%0'"
H2A7469D4D5C2: "未支援的分支保護規格 '%0'"
# 'unsupported combination: -header-include-format=%0 and -header-include-filtering=%1'
HDE5448E6CD09: '未支援的組合：-header-include-format=%0 和 -header-include-filtering=%1'
# 'unsupported combination: CC_PRINT_HEADERS_FORMAT=%0 and CC_PRINT_HEADERS_FILTERING=%1'
H2798CD78D9FC: '未支援的組合：CC_PRINT_HEADERS_FORMAT=%0 和 CC_PRINT_HEADERS_FILTERING=%1'
# 'unsupported expression with unknown type'
H3F334416D50C: '不支援未知類型的運算式'
# 'unsupported inline asm: input with type %diff{$ matching output with type $|}0,1'
HA68AF7F61C41: '不支援的內嵌組裝語言：具有類型 %diff{$ 匹配輸出類型 $|}0,1 的輸入'
# 'unsupported non-standard concatenation of string literals'
H5B7E63184569: '不支援非標準字串文字的連接'
# "unsupported option '%0'"
H76DA0BF83FA2: "不支援的選項 '%0'"
# "unsupported option '%0' for language mode '%1'"
HFB2A15C316AA: "語言模式 '%1' 中不支援選項 '%0'"
# "unsupported option '%0' for target '%1'"
H3BBDE17AAC2A: "目標 '%1' 中不支援選項 '%0'"
# "unsupported option '%0'; did you mean '%1'?"
H4AD874895A11: "不支援選項 '%0'；您是否指的是 '%1'？"
# "unsupported runtime library '%0' for platform '%1'"
HE43F5A0809F2: "平台 '%1' 不支援 '%0' 執行階段函式庫"
# 'unsupported signature for %q0'
H15BCEB35CA2A: '%q0 的函式簽章不受支援'
# "unsupported standard library implementation: 'std::%0' is not a class template"
HA2971F6C2CFB: "不受支援的標準函式庫實作：'std::%0' 非類模板"
# 'unsupported type for named register variable'
H1A238AEF63D8: '命名寄存器變數的類型不受支援'
# "unsupported unwind library '%0' for platform '%1'"
H36E9F0E6CE47: "平台 '%1' 不支援 '%0' unwind函式庫"
# 'unsupported vector cast from %0 to %1 in a constant expression'
H0EB0D2450B52: '常數運算式中將 %0 轉換為 %1 的向量轉換不受支援'
# 'unsupported: anonymous type given name for linkage purposes by %select{typedef|alias}0 declaration after its linkage was computed; add a tag name here to establish linkage prior to definition'
H912212F218D9: '不支援：為連結目的而為匿名型別指定名稱的 %select{typedef宣告|別名宣告}0，在其連結性已計算後才進行；在這裡加上標籤名稱以在定義前建立連結性'
# "unterminated '#pragma clang attribute push' at end of file"
HAA76B77750A8: "未終止的 '#pragma clang attribute push' 在檔案結尾處"
# "unterminated '#pragma pack (push, ...)' at end of file"
H95BE59428151: "未終止的 '#pragma pack (push, ...)' 在檔案結尾處"
# 'unterminated /* comment'
H43A167D7F07E: '未終止的 /* 註解'
# 'unterminated conditional directive'
H9448FAFF2F9A: '未終止的條件指示詞'
# 'unterminated function-like macro invocation'
HD9DD62FCE328: '未終止的類函數宏調用'
# 'unterminated symbolic operand name in inline assembly string'
HBE23072A59B4: '內聯組裝字串中的符號操作元名稱未終止'
# 'unused %select{function|variable}0 template %1'
H1A13AD1AD99E: '未使用的 %select{函式|變數}0 範本 %1'
# 'unused %select{typedef|type alias}0 %1'
HF81285298D17: '未使用的 %select{typedef|類型別名}0 %1'
# "unused attribute %0 in '#pragma clang attribute push' region"
HE033EC53FB54: "'#pragma clang attribute push' 區域中未使用的屬性 %0"
# 'unused exception parameter %0'
H53C55F431BFF: '未使用的例外參數 %0'
# 'unused function %0'
H452452A2578C: '未使用的函數 %0'
# 'unused label %0'
H876AC9FC8066: '未使用的標籤 %0'
# 'unused member function %0'
HCD85BCD73655: '未使用的成員函數 %0'
# 'unused parameter %0'
HA3441FCB7F5E: '未使用的參數 %0'
# 'unused variable %0'
HC6697F7C70D3: '未使用的變數 %0'
# 'unwind clobber cannot be used with asm goto'
HF66EC6AC58F5: 'asm goto 無法與 unwind clobber 同時使用'
# 'update DWARF debug sections of the executable'
HED8DED50ECC0: '更新可執行檔中的 DWARF 調試區段'
# 'update address2ProbesMap with output block address'
H5AFCEC7A601F: '更新 address2ProbesMap，加入輸出區塊位址'
# 'use %select{__bridge_retained|CFBridgingRetain call}1 to make an ARC object available as a +1 %0'
H2F547772958A: '使用 %select{__bridge_retained |CFBridgingRetain 呼叫}1 使 +1 %0 的 ARC 物件可用'
# 'use %select{__bridge_transfer|CFBridgingRelease call}1 to transfer ownership of a +1 %0 into ARC'
HF8A351DB4284: '使用 %select{__bridge_transfer |CFBridgingRelease 呼叫}1 將 +1 %0 的所有權轉移至 ARC'
# 'use %select{an alias declaration|a typedef declaration|a reference|a const variable|a constexpr variable}0 instead'
H31FA52067035: '建議改用 %select{別名宣告 |typedef 宣告 |參考 |const 變數 |constexpr 變數}0'
# "use '!=' to turn this compound assignment into an inequality comparison"
HFF11B4D027A3: "使用 '!=' 將此複合指派轉為不等式比較"
# "use '%0' for a bitwise operation"
HC5B930A30B61: "使用 '%0' 進行位元運算"
# "use '%0' instead"
H3E25F181DE0F: "應改用 '%0'"
# "use '%0'%select{| or '%3'|, '%3', or '%4'|, '%3', '%4', or '%5'}2 for '%1' standard"
H8EF0F3BAA8D4: "使用 '%0'%select{| 或 '%3'|, '%3', 或 '%4'|, '%3', '%4', 或 '%5'}2 來指定 '%1' 標準"
# "use '--' to treat subsequent arguments as filenames"
H6A626367FC6F: "使用 '--' 將後續參數視為檔案名稱"
# "use '=' to turn this equality comparison into an assignment"
H59DEE49ECF0A: "使用 '=' 將此等式比較轉換為賦值"
# "use '==' to turn this assignment into an equality comparison"
H00083B312DD9: "使用 '==' 將此賦值轉為等式比較"
# "use 'framework module' to declare module '%0'"
H4A41FDAB21BC: "使用 'framework module' 來宣告模組 '%0'"
# "use 'isEqual:' instead"
H4DB59E9DD438: "改用 'isEqual:'"
# "use 'static' to give inline function %0 internal linkage"
HFF537B0E0104: "使用 'static' 為內聯函數 %0 提供內部連結"
# "use 'static_cast' to adjust the pointer correctly while %select{upcasting|downcasting}0"
H11DA11C5BD86: "在 %select{向上轉換|向下轉換}0 時，使用 'static_cast' 正確調整指標"
# "use 'template' keyword to treat '%0' as a dependent template name"
H7991087B2538: "使用 'template' 關鍵字將 '%0' 視為依賴模板名稱"
# "use 'thread_local' to allow this"
H797BF646E244: "使用 'thread_local' 以允許此操作"
# "use '|=' to turn this inequality comparison into an or-assignment"
H080693EB5666: "使用 '|=' 將此不等式比較轉換為或分配"
# 'use -analyzer-disable-all-checks to disable all static analyzer checkers'
H352E7076CB09: '使用 -analyzer-disable-all-checks 禁用所有靜態分析器檢查器'
# 'use -fbracket-depth=N to increase maximum nesting level'
H336E5F530373: '使用 -fbracket-depth=N 提高最大嵌套層級'
# "use -foperator-arrow-depth=N to increase 'operator->' limit"
HF5AE9E6C2AED: "使用 -foperator-arrow-depth=N 提高 'operator->' 的限制"
# 'use -ftemplate-depth=N to increase recursive template instantiation depth'
HB6D1F29D249C: '使用 -ftemplate-depth=N 提高遞迴模板實例化深度'
# 'use /Tc or /Tp to set input type for standard input'
HA357D9386AFC: '使用 /Tc 或 /Tp 設定標準輸入的輸入類型'
# 'use DBSCAN/OPTICS algorithm'
HD85FBF4157B0: '使用 DBSCAN/OPTICS 演算法'
# 'use DFS order for YAML profile'
H3B1260947C69: '使用深度優先搜尋（DFS）順序為 YAML 剖析'
# 'use DFS ordering when using -icf option'
HBAAC1CA2D23D: '使用 -icf 選項時請使用 DFS 順序'
# 'use GNU_STACK program header for new segment (workaround for issues with strip/objcopy)'
H43641118D1BF: '使用 GNU_STACK 程式標頭建立新區段（用於解決 strip/objcopy 的問題）'
# 'use Machine Branch Probability Info'
H2ADCBE6C2DCD: '使用 Machine Branch Probability Info'
# 'use Pettis-Hansen algorithm'
H5F85980D861E: '使用 Pettis-Hansen algorithm'
# 'use __attribute__((visibility("hidden"))) attribute instead'
H69E62EF34DBF: '改用 __attribute__((visibility("hidden"))) 屬性'
# 'use __bridge to convert directly (no change in ownership)'
HF999F719DC1E: '改用 __bridge 進行直接轉換（不改變擁有權）'
# 'use __bridge with C-style cast to convert directly (no change in ownership)'
H25381B224554: '改用 __bridge 與 C 風格轉換進行直接轉換（不改變擁有權）'
# 'use __bridge_retained with C-style cast to make an ARC object available as a +1 %0'
H89038B186CBF: '使用 __bridge_retained 與 C 風格轉換讓 ARC 物件可作為 +1 %0 的可用物件'
# 'use __bridge_transfer with C-style cast to transfer ownership of a +1 %0 into ARC'
H0BF38DCCAF48: '使用 __bridge_transfer 與 C 風格轉換將 +1 %0 的擁有權轉移給 ARC'
# "use a function's hot size when doing clustering"
H10032CBF870F: '進行群集化時使用函數的 hot size'
# 'use a lock file so only one process in the system can run this pass at once. useful to avoid mangled debug output in multithreaded environments.'
H7CB74F0F7BF5: '使用鎖定檔確保系統中僅一個進程可同時執行此 pass。用於避免多執行緒環境中除錯輸出被破壞。'
# 'use a modified clustering algorithm geared towards minimizing branches'
HFDD79DC87D1A: '使用針對最小化分支設計的修改型群集化演算法'
# 'use absolute jump tables on ppc'
H88706E2F52B2: '在 PPC 平台使用絕對跳轉表'
# 'use aggressive ppc isel for bit permutations'
H99649C2F1B01: '使用積極型 PPC isel 進行位元排列轉換'
# 'use array indexing to silence this warning'
H85B32746AF01: '使用陣列索引來抑制此警告'
# 'use ascending or descending order when printing functions ordered by dyno stats'
HF0A78325BB17: '在根據 dyno 統計資料排序函數時，請使用升序或降序'
# 'use branch prediction data to control sctc'
H2D5E124AB149: '使用分支預測資料來控制 sctc'
# 'use cache-directed sort'
H993E2A52F48B: '使用快取指引排序'
# 'use constraint modifier "%0"'
H96B4F36A2D84: '使用限制修飾符 "%0"'
# 'use declarations are only allowed in top-level modules'
HB528050B8967: 'use 声明僅允許在頂層模組中使用'
# 'use edge count data when doing clustering'
H6F3C614822A7: '在進行聚類時使用邊計數資料'
# 'use fast runtime behavior'
H2D5F50DA24D3: '使用快速執行階段行為'
# "use function '%0' instead"
H30EA9A5A15F6: "改用函數 '%0'"
# 'use function order specified by -function-order'
H517260D51513: '使用由 -function-order 指定的函數順序'
# 'use hfsort algorithm'
H6D5DE1F47100: '使用 hfsort 演算法'
# 'use hot/cold data on basic blocks to determine hot sizes for call graph functions'
H898A061653FE: '使用基本區塊中的熱/冷數據來決定呼叫圖函數的熱點大小'
# 'use instrumentation with slow path for all accesses'
H244914CD834D: '對所有存取使用包含慢速路徑的插樁'
# 'use misprediction frequency for determining whether or not ICP should be applied at a callsite.  The -indirect-call-promotion-mispredict-threshold value will be used by this heuristic'
H3115132EB120: '使用間接呼叫提升誤判頻率，以判斷是否在呼叫位址處應用 ICP。此_heuristic 將使用 -indirect-call-promotion-mispredict-threshold 的值'
# 'use non-reference type %0'
HE4A5CE8520B2: '使用非引用類型 %0'
# 'use non-reference type %0 to make construction explicit or type %1 to prevent copying'
HAB8A2938766C: '使用非引用類型 %0 以明確建構，或使用類型 %1 以避免複製'
# 'use nullability type specifier %0 to affect the innermost pointer type of %1'
HA9A4302606C7: '使用 nullability 類型修飾符 %0 影響 %1 的最內層指標類型'
# 'use of %0 with tag type that does not match previous declaration'
H4AAB2FCDDAB1: '使用與先前宣告不匹配的標記類型 %0'
# 'use of %select{class template|function template|variable template|alias template|template template parameter|concept|template}0 %1 requires template arguments'
H8F99144D2E34: '使用 %select{類模板|函式模板|變數模板|別名模板|模板模板參數|概念|模板}0 %1 需要模板參數'
# 'use of %select{infinity|NaN}0%select{| via a macro}1 is undefined behavior due to the currently enabled floating-point options'
H18AE2A8F681F: '使用 %select{無限大|NaN}0%select{|透過巨集}1 會因目前啟用的浮點選項導致未定義行為'
# 'use of %select{type|declaration}0 %1 requires %2 support'
H39DB55887936: '使用 %select{類型|宣告}0 %1 需要 %2 支援'
# "use of '@import' in framework header is discouraged, including this header requires -fmodules"
H455C5312D820: "在框架標頭中使用 '@import' 不被鼓勵，包含此標頭需要 -fmodules"
# "use of '@import' when modules are disabled"
HE80AA99C30B1: "在禁用模組時使用 '@import'"
# "use of '__int128' with '__vector bool' requires VSX support enabled (on POWER10 or later)"
HBB36DE187BFD: "與 '__vector bool' 一同使用 '__int128' 需啟用 VSX 支援（POWER10 或更新版本）"
# "use of '__int128' with '__vector' requires extended Altivec support (available on POWER8 or later)"
H02493A6B8143: "與 '__vector' 一同使用 '__int128' 需啟用擴展 Altivec 支援（POWER8 或更新版本）"
# "use of '__super' inside a lambda is unsupported"
H5812045C24A5: "在 lambda 內使用 '__super' 不被支援"
# "use of 'double' with '__vector' requires VSX support to be enabled (available on POWER7 or later)"
HFF794EBE240D: "使用 'double' 與 '__vector' 需要啟用 VSX 支援（POWER7 或更新版本提供）"
# "use of 'long long' with '__vector' requires VSX support (available on POWER7 or later) to be enabled"
HEDE074D6F05D: "使用 'long long' 與 '__vector' 需要啟用 VSX 支援（POWER7 或更新版本提供）"
# "use of 'long' with '__vector' is deprecated"
H194F4A31DAD4: "使用 'long' 與 '__vector' 已棄用"
# "use of 'operator->' on type %0 would invoke a sequence of more than %1 'operator->' calls"
HE55B12BF8DE6: "在類型 %0 上使用 'operator->' 會觸發超過 %1 次 'operator->' 呼叫的序列"
# "use of 'static_assert' without inclusion of <assert.h> is a Microsoft extension"
HFC681B3993FC: "未包含 <assert.h> 時使用 'static_assert' 是 Microsoft 延伸語法"
# "use of 'template' keyword outside of a template is incompatible with C++98"
HADE615C257C6: "在非範本上下文中使用 'template' 關鍵字與 C++98 不相容"
# 'use of @defs is not supported on this architecture and platform'
HA2315B23A421: '在此架構和平台上不支援 @defs'
# 'use of C-style parameters in Objective-C method declarations is deprecated'
H124575A24936: '在 Objective-C 方法宣告中使用 C 風格參數已棄用'
# "use of GNU 'missing =' extension in designator"
HE3037B23921A: "在設計者中使用 GNU '缺少 =' 延伸語法"
# 'use of GNU ?: conditional expression extension, omitting middle operand'
H0DE762B90B0D: '使用 GNU ?: 條件表達式延伸語法，省略中間運算元'
# 'use of GNU address-of-label extension'
HA7B26095AD53: '使用GNU的address-of-label擴充功能'
# 'use of GNU array range extension'
H678FC3DF1C6F: '使用GNU的array range擴充功能'
# 'use of GNU indirect-goto extension'
H3D429B23EFAC: '使用GNU的indirect-goto擴充功能'
# 'use of GNU old-style field designator extension'
H85575BE49C11: '使用GNU舊式欄位指定符擴充功能'
# 'use of GNU statement expression extension'
HD7924EDC2399: '使用GNU的statement expression擴充功能'
# 'use of GNU statement expression extension from macro expansion'
HDFF296407839: '透過巨集展開使用GNU的statement expression擴充功能'
# 'use of NULL in arithmetic operation'
H72A441293B63: '在算術運算中使用NULL'
# 'use of Objective-C property in function nested in Objective-C container not supported, move function outside its container'
H1B2603FEAF82: '不支援在Objective-C容器內部的函數中使用Objective-C屬性，請將函數移至容器外部'
# 'use of __private_extern__ on a declaration may not produce external symbol private to the linkage unit and is deprecated'
HC7A56E0EB4D2: '__private_extern__在宣告上的使用可能無法產生連結單位私有外部符號，且已被棄用'
# "use of a '#%select{<BUG IF SEEN>|elifdef|elifndef}0' directive is a C++23 extension"
H6A5DD5BE1302: "使用 '#%select{<BUG IF SEEN>|elifdef|elifndef}0' 指令是C++23擴充功能"
# "use of a '#%select{<BUG IF SEEN>|elifdef|elifndef}0' directive is a C23 extension"
H0BF82439932C: "使用 '#%select{<BUG IF SEEN>|elifdef|elifndef}0' 指令是C23擴充功能"
# "use of a '#%select{<BUG IF SEEN>|elifdef|elifndef}0' directive is incompatible with C standards before C23"
HDFCC088F181F: "使用 '#%select{<BUG IF SEEN>|elifdef|elifndef}0' 指令與C23之前標準不相容"
# "use of a '#%select{<BUG IF SEEN>|elifdef|elifndef}0' directive is incompatible with C++ standards before C++23"
H16A663A66375: "使用 '#%select{<BUG IF SEEN>|elifdef|elifndef}0' 指令與C++23之前標準不相容"
# 'use of address-of-label extension outside of a function body'
HEBDAFDF05EDA: '在函數本體外使用address-of-label擴充功能'
# 'use of an empty initializer is a C23 extension'
HD0F8B4BA3FB2: '使用空初始化器是C23的擴展功能'
# 'use of an empty initializer is incompatible with C standards before C23'
H28862631C8FD: '在C23之前的C標準中，使用空初始化器是不兼容的'
# "use of bitwise '%0' with boolean operands"
H3DCD98477290: "在布林運算元上使用位元操作符 '%0'"
# 'use of default argument to function %0 that is declared later in class %1'
HBEFC6E561806: '使用在類別 %1 的後續宣告中定義預設參數的函數 %0'
# 'use of dynamic_cast requires -frtti'
HE86B35BE234A: '使用 dynamic_cast 需要指定 -frtti 旗標'
# 'use of empty enum'
H0A3EEAE0C204: '使用空枚舉類型'
# 'use of enumeration in a nested name specifier is a C++11 extension'
H9F1C227C8017: '在嵌套名稱指定項中使用枚舉是C++11的擴展功能'
# 'use of function %0 is discouraged; there is no way to check for failure but failure may still occur, resulting in a possibly exploitable security vulnerability'
H123B46BAB412: '使用函數 %0 是不建議的；雖然無法檢查失敗情況，但失敗仍可能發生，導致可能被利用的安全漏洞'
# 'use of function template name with no prior declaration in function call with explicit template arguments is a C++20 extension'
H17E19DFB3C7C: '在明確指定範型參數的函數呼叫中，使用未經先前宣告的範型函數名稱是C++20的擴展功能'
# 'use of function template name with no prior declaration in function call with explicit template arguments is incompatible with C++ standards before C++20'
H640DD80A631A: '在明確指定範型參數的函數呼叫中，使用未經先前宣告的範型函數名稱與C++20之前的標準不相容'
# "use of implicit 'typename' is incompatible with C++ standards before C++20"
HFA6B14FF689A: "在C++20之前的標準中，隱含使用 'typename' 是不相容的"
# "use of incomplete type %0 in a '_Generic' association is incompatible with C standards before C2y"
H805F57844181: "在 '_Generic' 關聯中使用不完整類型 %0 與C2y之前的C標準不相容"
# "use of logical '%0' with constant operand"
H91174008E58D: "在常數運算元上使用邏輯操作符 '%0'"
# 'use of member %0 before its declaration is a Microsoft extension'
HF1849841B9E7: '在宣告前使用成員 %0 是Microsoft的擴展功能'
# 'use of member %0 found via unqualified lookup into dependent bases of class templates is a Microsoft extension'
H8CD447C8CC3A: '通過未資格化搜尋在類別範型的依賴基類中找到成員 %0 是Microsoft的擴展功能'
# 'use of multiple declarators in a single using declaration is a C++17 extension'
H82698382734A: '在單一using宣告中使用多個宣告符是C++17的擴展功能'
# 'use of multiple declarators in a single using declaration is incompatible with C++ standards before C++17'
HF5A1B33A1986: '在單一using宣告中使用多個宣告符與C++17之前的標準不相容'
# "use of non-standard escape character '\\%0'"
H8F21313E1DFF: "使用非標準轉義字元 '\\%0'"
# 'use of non-static data member %0 in an unevaluated context is incompatible with C++98'
H47868E15CED8: '在未評估的語境中使用非靜態資料成員 %0 與C++98標準不相容'
# 'use of null pointer as non-type template argument is incompatible with C++98'
H6944D3B803C2: '將空指標用作非類型模板參數與 C++98 不相容'
# 'use of old-style cast'
H0C8605CE0E58: '使用舊式轉型'
# 'use of out-of-scope declaration of %0%select{| whose type is not compatible with that of an implicit declaration}1'
H9DFA1FDF94B0: '使用作用域外的宣告 %0%select{| 其類型與隱含宣告不相容}1'
# "use of overloaded operator '%0' is ambiguous (operand type %1)"
H4300BB2DDBA6: "使用重載運算符 '%0' 會導致歧義（運算元類型 %1）"
# "use of overloaded operator '%0' is ambiguous (with operand types %1 and %2)"
H792DBC228D1F: "使用重載運算符 '%0' 會導致歧義（運算元類型 %1 和 %2）"
# 'use of placement new requires explicit declaration'
H992499F64501: '使用placement new需要明確宣告'
# "use of private header from outside its module: '%0'"
H4B3CFE33871D: "從其模組外部使用私有標頭檔案: '%0'"
# 'use of reference outside its lifetime is not allowed in a constant expression'
H2C7D8C6358B3: '在常量運算式中使用超出其生命周期的引用是不被允許的'
# 'use of result of assignment to object of volatile-qualified type %0 is deprecated'
H0FD6FA3111E8: '對 volatile 修飾類型 %0 的物件進行指派後的結果之使用已棄用'
# "use of right-shift operator ('>>') in template argument will require parentheses in C++11"
H4B1C2F8BF668: '在模板參數中使用右移運算符 (>>) 在 C++11 中將需要括號'
# 'use of the %0 attribute is a C++14 extension'
HD7333826DEB8: '%0 屬性的使用是 C++14 的擴充功能'
# 'use of the %0 attribute is a C++17 extension'
H9D6E9F75124A: '%0 屬性的使用是 C++17 的擴充功能'
# 'use of the %0 attribute is a C++20 extension'
H85EE1317CADA: '%0 屬性的使用是 C++20 的擴充功能'
# 'use of the %0 attribute is a C++23 extension'
H3769FB94DD63: '%0 屬性的使用是 C++23 的擴充功能'
# 'use of this expression in an %0 attribute requires parentheses'
H4B6BF2EAA0DF: '在 %0 屬性中使用此運算式需要括號'
# 'use of this statement in a constexpr %select{function|constructor}0 is a C++14 extension'
H009816A3B264: '在 constexpr %select{函數|建構函數}0 中使用此語句是 C++14 的擴充功能'
# 'use of this statement in a constexpr %select{function|constructor}0 is a C++20 extension'
H383EABB05A34: '在 constexpr %select{函數|建構函數}0 中使用此語句是 C++20 的擴充功能'
# 'use of this statement in a constexpr %select{function|constructor}0 is a C++23 extension'
H3CD433F9DEED: '在 constexpr %select{函數|建構函數}0 中使用此語句是 C++23 的擴充功能'
# 'use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14'
HDB9F101C6FD8: '在 constexpr %select{函數|建構函數}0 中使用此語句與 C++14 之前的標準不相容'
# 'use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++20'
H10E657C568DA: '在 constexpr %select{函數|建構函數}0 中使用此語句與 C++20 之前的標準不相容'
# 'use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++23'
HBB6862211968: '在 C++23 之前的標準中，constexpr %select{函數|建構函數}0 中使用此語句不符合規範'
# 'use of typeid requires -frtti'
H6516CAF74372: '使用 typeid 需要 -frtti'
# 'use of unary operator that may be intended as compound assignment (%0=)'
H52686183E946: '使用可能被誤解為複合指派（%0=）的單元運算子'
# 'use of undeclared %0'
H4249B6D3D66A: '使用未宣告的 %0'
# 'use of undeclared %0; did you mean %1?'
H152AECD0CF73: '使用未宣告的 %0；是否是指 %1？'
# 'use of undeclared identifier %0'
H2DA2A4EF5956: '使用未宣告的識別符 %0'
# 'use of undeclared identifier %0; did you mean %1?'
H448AE4CE2F58: '使用未宣告的識別符 %0；是否是指 %1？'
# 'use of undeclared identifier %0; unqualified lookup into dependent bases of class template %1 is a Microsoft extension'
HB6A34859F540: '使用未宣告的識別符 %0；類模板 %1 的相關基類未限定查找是 Microsoft 擴充'
# 'use of undeclared label %0'
H685C1928674B: '使用未宣告的標籤 %0'
# "use of undefined marker '%0'"
HAEC3C6045C74: "使用未定義的標記 '%0'"
# 'use of unknown builtin %0'
HBFCE16721923: '使用未知的內建函數 %0'
# 'use old code sequence for promoted calls'
H27311E45E8D5: '使用提升調用的舊代碼序列'
# 'use perf data directly when constructing the call graph for stale functions'
H9C843E88A00A: '在構建過期函數的呼叫圖時直接使用性能數據'
# 'use precise runtime behavior'
H864CB2EB7B9A: '使用精確的執行階段行為'
# 'use reference type %0 to prevent copying'
H96F12D2BC3F2: '使用引用類型 %0 以避免複製'
# 'use register liveness analysis to try to find more opportunities for -reg-reassign optimization'
H7BCD305B01BE: '使用寄存器活化分析試圖尋找更多 -reg-reassign 優化機會'
# 'use regular size pages for code alignment'
H041AAF5448A5: '使用標準大小的頁面進行程式碼對齊'
# 'use relaxed runtime behavior'
H386C9EF15D8D: '使用鬆弛的執行階段行為'
# 'use relocations in the binary (default=autodetect)'
HA2145EBF1AF4: '在二進位檔中使用重定位資訊（預設=自動偵測）'
# 'use same count for BBs that should have equivalent count (used in non-LBR and shrink wrapping)'
H2FCA1FC45D12: '為應具有等效計數的基本塊（BB）使用相同的計數（用於非LBR和收縮包裝）'
# "use same version number separators '_' or '.'; as in 'major[.minor[.subminor]]'"
H152CFF6748B3: "使用相同的版本號分隔符 '_' 或 '.'；如 'major[.minor[.subminor]]'"
# 'use short granules in allocas and outlined checks'
H1D7871DD27F1: '在alloca和外部分析中使用短粒度'
# 'use strict dwarf'
HD69F3507E82F: '使用嚴格的DWARF'
# 'use stricter verifier for HLFIR intrinsic operations'
H7296989D6AE9: '對HLFIR內建運算使用更嚴格的驗證器'
# "use the GNU '__attribute__' syntax"
H7DBF5BB23C34: '使用GNU "__attribute__" 語法'
# 'used here'
H1359FF249380: '在此處使用'
# 'used in initialization here'
H9614905D4DE2: '在此處初始化時使用'
# 'used type %0 where __hlsl_resource_t is required'
HB0299AD4C891: '在需要__hlsl_resource_t的地方使用了類型 %0'
# 'used type %0 where arithmetic or pointer type is required'
HEF054774D419: '在需要算術或指針類型的地方使用了類型 %0'
# 'used type %0 where floating point type is not allowed'
HF095E0FB08EE: '在不允許浮點類型的地方使用了類型 %0'
# 'used type %0 where integer is required'
HCD053F3A5F86: '在需要整數類型的地方使用了類型 %0'
# 'used type %0 where integer or floating point type is required'
H46DF1623ED73: '在需要整數或浮點類型的地方使用了類型 %0'
# 'used%select{| in pointer arithmetic| in buffer access}0 here'
H2D0FA9F859F9: '在此處 %select{|在指標運算|在緩衝區存取}0使用'
# "user-defined literal suffixes %select{<ERROR>|not starting with '_'|containing '__'}0 are reserved%select{; no literal will invoke this operator|}1"
H414028466FC2: '用戶定義的字面量後綴 %select{<ERROR>|未以 "_" 開頭|包含 "__"}0 被保留%select{；沒有字面量會調用此運算符|}1'
# 'using'
H92BD75EBD8FD: '使用'
# 'using %0 directive in %select{NSString|CFString}1 which is being passed as a formatting argument to the formatting %select{method|CFfunction}2'
HFA21A8452E12: '在 %select{NSString|CFString}1 中使用 %0 指令，該指令被用作格式化%select{方法|CF函數}2的格式化參數'
# 'using %0 with a literal is redundant'
HA26F40AA0176: '與字面量一起使用 %0 是冗餘的'
# 'using %select{integer|floating point|complex}1 absolute value function %0 when argument is of %select{integer|floating point|complex}2 type'
H2A1C61EF88A1: '當參數為%select{整數|浮點|複數}2類型時，使用%select{整數|浮點|複數}1絕對值函數 %0'
# "using '%%P' format specifier with an Objective-C pointer results in dumping runtime object structure, not object value"
H513C1ECC12E7: "在Objective-C指針中使用 '%%P' 格式說明符將會傾印執行階段物件結構，而不是物件值"
# "using '%%P' format specifier without precision"
HE89A56274479: "在不指定精確度的情況下使用 '%%P' 格式指定項"
# "using '%0' format specifier annotation outside of os_log()/os_trace()"
H2CE6DDE79E74: "在非 os_log()/os_trace() 中使用 '%0' 格式指定項註解"
# "using '%0' format specifier, but argument has boolean value"
HDDBB822724E7: "使用 '%0' 格式指定項，但引數具有布林值"
# "using declaration annotated with 'using_if_exists' here"
HDB8ACBC0FBF5: "在此處使用標註有 'using_if_exists' 的宣告"
# 'using declaration cannot refer to a constructor'
HF62840A086D5: '使用宣告不能引用建構函數'
# 'using declaration cannot refer to a destructor'
HE836ECBAB540: '使用宣告不能引用解構函數'
# 'using declaration cannot refer to a namespace'
H0DDDFEE0D0FD: '使用宣告不能引用命名空間'
# 'using declaration cannot refer to a template specialization'
H99346E56FD07: '使用宣告不能引用模板特化'
# 'using declaration cannot refer to class member'
H667DB55E8D61: '使用宣告不能引用類別成員'
# 'using declaration in class refers into %0, which is not a class'
H703FE2D02B05: '在類別中使用的宣告引用 %0，但其並非類別'
# 'using declaration naming a scoped enumerator is a C++20 extension'
H5CF0B64CDA35: '使用宣告命名作用域枚舉常量是 C++20 擴展'
# 'using declaration naming a scoped enumerator is incompatible with C++ standards before C++20'
H52802307DDAC: '使用宣告命名作用域枚舉常量與 C++20 之前標準不相容'
# 'using declaration pack expansion at block scope produces multiple values'
HFC5BC61E58BC: '區塊作用域中的使用宣告包展開會產生多個值'
# 'using declaration referring to %1 with %select{internal|module|unknown}0 linkage cannot be exported'
HFDD1D0A3610E: '引用具有%select{內部|模組|未知}0連結的 %1 的使用宣告無法被導出'
# "using declaration referring to inaccessible member '%0' (which refers to accessible member '%1') is a Microsoft compatibility extension"
HA7AB89787DCC: "引用無法存取的成員 '%0'（其引用可存取成員 '%1'）的使用宣告是 Microsoft 兼容性擴展"
# 'using declaration refers into %0, which is not a base class of %1'
HE8EC9FE5FD16: '使用宣告引用 %0，但其並非 %1 的基底類別'
# 'using declaration refers to its own class'
H435B6D84F0D6: '使用宣告引用自身類別'
# 'using declaration requires a qualified name'
H9CE75E7C4CF5: '使用宣告需要已修飾的名稱'
# "using directive refers to implicitly-defined namespace 'std'"
H5C8831D062A8: "使用指示項引用隱式定義的 'std' 命名空間"
# 'using enum %select{requires an enum or typedef name|does not permit an elaborated enum specifier}0'
H07DCC7345590: '使用enum %select{需要枚舉或typedef名稱|不允許使用詳細枚舉指定項}0'
# 'using enum declaration is a C++20 extension'
H30E94CBBC49F: '使用enum宣告是C++20擴充功能'
# 'using enum declaration is incompatible with C++ standards before C++20'
HA6B3DF063338: '使用enum宣告與C++20之前的標準不相容'
# "using length modifier '%0' with conversion specifier '%1' is not supported by ISO C"
HCAD96DA2A48D: "在ISO C中不支援在轉換指定項 '%1' 使用長度修飾符 '%0'"
# 'using namespace directive in global context in header'
HDFF3F4F00DD3: '在標頭檔案的全域範圍中使用using命名空間指令'
# "using sysroot for '%0' but targeting '%1'"
H23CBFE9436FA: "正在使用 '%0' 的sysroot，但目標為 '%1'"
# 'using the result of an assignment as a condition without parentheses'
HD808A1E3A9FB: '在條件中使用賦值運算的結果但未使用括號'
# 'using the undeclared type %0 as a default template argument is a Microsoft extension'
H9BAAEE7535FA: '將未宣告的類型 %0 用作預設模板參數是Microsoft擴充功能'
# 'using unversioned Android target directory %0 for target %1; unversioned directories will not be used in Clang 19 -- provide a versioned directory for the target version or lower instead'
H120D3110B47A: '為目標 %1 使用未指定版本的Android目標目錄 %0；Clang 19 將不再使用未指定版本的目錄——請為目標版本提供已指定版本的目錄或使用較低版本'
# 'using-enum cannot name a dependent type'
H3DC57F2168E8: 'using-enum不能命名依賴類型'
# 'usual LSP protocol'
H562B11D542B5: '標準的LSP通訊協定'
# 'uuid attribute contains a malformed GUID'
H1FAF5254B686: 'UUID屬性包含格式錯誤的GUID'
# 'uuid does not match previous declaration'
H1E8E115FA4D8: 'UUID與之前的宣告不相符'
# 'valid %0 clauses start with %1; %select{token|tokens}2 will be ignored'
HA977999237FF: '有效的 %0 子句以 %1 開頭；%select{詞彙|詞彙們}2將被忽略'
# 'valid target CPU values are: %0'
HB573A028A656: '有效的目標CPU值為：%0'
# 'value %0 is outside the range of representable values of type %1'
H76B206381D68: '值 %0 超出類型 %1 可表示的範圍'
# 'value %1 cannot be represented in type %0'
H0FCCEC09B538: '值 %1 無法以類型 %0 表示'
# "value '%0' out of range for constraint '%1'"
H2964C78586A1: "值 '%0' 超出約束 '%1' 的範圍"
# 'value is not an integer: %0'
HDF6724275715: '值不是整數：%0'
# 'value of #pragma pack(show) == %0'
H78F0B6172824: '#pragma pack(show)的值等於 %0'
# 'value of the aligned pointer (%0) is not a multiple of the asserted %1 %plural{1:byte|:bytes}1'
HCBC69FE1B218: '對齊指標 (%0) 的值不是聲稱的 %1 %plural{1:位元組|:位元組}1 的倍數'
# "value of type %0 is not contextually convertible to 'bool'"
H8D6D08CCD77E: "類型 %0 的值在語境上無法轉換為 'bool'"
# 'value of type %0 is not implicitly convertible to %1'
H7F07136EE80D: '類型 %0 的值不能隱式轉換為 %1'
# "value returned by '__builtin_counted_by_ref' cannot be %select{assigned to a variable|passed into a function|returned from a function}0"
H0D53FCA7346F: '__builtin_counted_by_ref 的返回值不能 %select{被指派給變數|傳遞給函數|從函數返回}0'
# "value returned by '__builtin_counted_by_ref' cannot be used in %select{an array subscript|a binary}0 expression"
H4F263548602C: '__builtin_counted_by_ref 的返回值不能在 %select{陣列索引運算式|二元運算式}0 中使用'
# 'value size does not match register size specified by the constraint and modifier'
H45E5585EA0B2: '值大小與約束和修飾符指定的寄存器大小不匹配'
# 'varargs not allowed in requires expression'
H65BA20F3C0FC: 'requires 表達式中不允許使用可變長參數'
# "variable %0 cannot be declared both 'extern' and with the 'loader_uninitialized' attribute"
H66B3CD6187EF: '變數 %0 不可同時宣告為「extern」和具有「loader_uninitialized」屬性'
# 'variable %0 cannot be implicitly captured in a lambda with no capture-default specified'
H17BA614E3EF4: '在未指定捕獲預設值的 lambda 中，無法隱式捕獲變數 %0'
# 'variable %0 cannot be threadprivate because it is %select{thread-local|a global named register variable}1'
HF72C764C6D1B: '變數 %0 不可指定為 threadprivate，因為它是 %select{執行緒局部變數|名為的全域寄存器變數}1'
# 'variable %0 declared with deduced type %1 cannot appear in its own initializer'
H9648530537F2: '使用推論類型 %1 声明的變數 %0 不能出現在自身的初始化式中'
# 'variable %0 is %select{decremented|incremented}1 both in the loop header and in the loop body'
H5880C36D679C: '變數 %0 在迴圈標頭和迴圈主體中都被 %select{遞減|遞增}1'
# "variable %0 is %select{used|captured}1 uninitialized whenever %select{'%3' condition is %select{true|false}4|'%3' loop %select{is entered|exits because its condition is false}4|'%3' loop %select{condition is true|exits because its condition is false}4|switch %3 is taken|its declaration is reached|%3 is called}2"
H5B3E786190C7: '變數 %0 在 %select{「%3」條件為 %select{true|false}4 時|「%3」迴圈 %select{被進入|因條件為 false 而退出}4 時|「%3」迴圈 %select{條件為 true|因條件為 false 而退出}4 時|切換 %3 被執行時|其宣告處被達成時|%3 被呼叫時}2 的所有情況下 %select{使用|捕獲}1 時均未初始化'
# 'variable %0 is declared here'
H9C1D29CE922D: '變數 %0 是在此處宣告的'
# 'variable %0 is uninitialized when %select{used here|captured by block}1'
HC11F7DAD1A0E: '變數 %0 在 %select{這裡使用時|被區塊捕獲時}1 時未初始化'
# 'variable %0 is uninitialized when passed as a const reference argument here'
H12F79B618200: '變數 %0 在傳遞為常值參考參數時未初始化'
# 'variable %0 is uninitialized when used within its own initialization'
H9B3210B51205: '變數 %0 在自身初始化期間使用時未初始化'
# 'variable %0 is%select{| explicitly}1 captured here'
HC5A87C36FF05: '變數 %0 %select{|明確地}1 在此處被捕獲'
# 'variable %0 may be uninitialized when %select{used here|captured by block}1'
HC0A7D9F9078D: '變數 %0 可能未初始化而 %select{在這裡使用|被區塊捕獲}1'
# 'variable %0 must have explicitly specified data sharing attributes'
H9EFAEC625413: '變數 %0 必須明確指定資料共享屬性'
# 'variable %0 must have explicitly specified data sharing attributes, data mapping attributes, or in an is_device_ptr clause'
H577354E45CD4: '變數 %0 必須明確指定資料共用屬性、資料映射屬性，或位於 is_device_ptr 子句中'
# 'variable %0 set but not used'
H9EEEA592434A: '變數 %0 被設定但未使用'
# 'variable %0 with flexible array member cannot be captured in a lambda expression'
HEE231707A80F: '具有可伸縮陣列成員的變數 %0 不能在 lambda 表達式中被捕獲'
# 'variable %0 with type %1 has incompatible initializer of type %2'
HECE6754B3154: '類型為 %1 的變數 %0 的初始值設定項具有不相容的類型 %2'
# 'variable %0 with unknown type cannot be given a function type'
HBD6B0E34602F: '類型未知的變數 %0 不可賦予函式類型'
# "variable %select{|in unary expression|on right hand side of assignment|on left hand side of assignment|on left hand side of compound assignment|on left hand side of assignment}2('%3') must match variable used %select{|in unary expression|on right hand side of assignment|<not possible>|on left hand side of compound assignment|on left hand side of assignment}0('%1') from the first statement"
H68D8E5C8B649: "%select{|一元運算式|賦值運算式的右操作元|賦值運算式的左操作元|複合賦值運算式的左操作元|賦值運算式的左操作元}2('%3') 中的變數必須與第一個語句中使用的 %select{|一元運算式|賦值運算式的右操作元|<not possible>|複合賦值運算式的左操作元|賦值運算式的左操作元}0('%1') 所對應的變數一致"
# 'variable already marked as mapped in current construct'
HA15930719644: '當前建構中已標記此變數為已映射'
# "variable appearing in '%0' clause of OpenACC 'declare' directive must be in the same scope as the directive"
H32CD6FB44C7B: "OpenACC 'declare' 指令中 '%0' 子句內的變數必須與指令位於相同的範疇"
# "variable can appear only once in OpenMP '%0' clause"
H084B181F0F6F: "OpenMP '%0' 子句內的變數只能出現一次"
# "variable can appear only once in OpenMP 'target update' construct"
H78D2AF4A7A62: "OpenMP 'target update' 建構內的變數只能出現一次"
# 'variable captured in declare target region must appear in a to clause'
H2004C3E36B6D: '在 declare target 區塊中捕獲的變數必須出現在 to 子句中'
# 'variable declaration in a constexpr %select{function|constructor}0 is a C++14 extension'
H953C3A7294B8: '在 constexpr %select{函式|建構子}0 內的變數宣告是 C++14 擴充功能'
# 'variable declaration in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14'
H5037F674FC7B: '在 constexpr %select{函式|建構子}0 內的變數宣告與 C++14 之前標準不相容'
# 'variable declaration in condition cannot have a parenthesized initializer'
HA7027EDD1E14: '條件中的變數宣告不可使用括號包覆的初始值設定項'
# 'variable declaration in condition must have an initializer'
H031DEC12DA47: '條件中的變數宣告必須有初始值設定項'
# 'variable declaration in for loop is a C99-specific feature'
HCED2B7B23919: 'for 迴圈中的變數宣告是 C99 特定功能'
# 'variable declared constinit here'
HBD9CCEC96BCC: '在此處宣告 constinit 變數'
# "variable declared with 'objc_externally_retained' cannot be modified in ARC"
H47C52BC3E77D: "'objc_externally_retained 宣告的變數在 ARC 中不可修改"
# 'variable does not have a constant initializer'
HB267A973AA07: '此變數的初始值設定項並非常數'
# 'variable has incomplete type %0'
HF07B48579A53: '變數具有不完整的類型 %0'
# 'variable in constant address space must be initialized'
H66FDD0998C58: '常數地址空間中的變數必須進行初始化'
# 'variable is not assignable (missing __block type specifier)'
HAA0B269B98F3: '無法對此變數進行賦值（缺少 __block 類型修飾符）'
# 'variable length array cannot be formed during template argument deduction'
HF26A880CF088: '無法在模板參數推導期間形成可變長度陣列'
# "variable length array declaration cannot have 'extern' linkage"
H2436B28C5991: "具 'extern' 連結的可變長度陣列宣告不被允許"
# "variable length array declaration cannot have 'static' storage duration"
H9C9D3E1402A9: "具有 'static' 儲存期間的可變長度陣列宣告不被允許"
# 'variable length array declaration not allowed at file scope'
H01CDB7349FFD: '在全域作用域中無法使用可變長度陣列'
# 'variable length array folded to constant array as an extension'
H861F6896A4A9: '可變長度陣列已透過擴充功能展開為常數陣列'
# 'variable length array must be bound in function definition'
HACDD33225FC5: '函數定義中必須綁定可變長度陣列'
# 'variable length array used'
HFCB17814F664: '使用了可變長度陣列'
# 'variable length arrays are a C99 feature'
H82A7E9913A2F: '可變長度陣列是 C99 的功能'
# "variable length arrays are not supported %select{for the current target|in '%1'}0"
H5707BCACEAC8: '可變長度陣列 %select{在目前目標平台上|在 "%1" 中}0 不被支援'
# 'variable length arrays are not supported for the current target'
H50B2A4B545B7: '可變長度陣列在目前目標平台上不被支援'
# 'variable length arrays are not supported in OpenCL'
H201996231D1A: '在 OpenCL 中不支援可變長度陣列'
# "variable length arrays are not supported in OpenMP tasking regions with 'untied' clause"
H20FB8AB94029: "在帶有 'untied' 子句的 OpenMP 工作區塊中不支援可變長度陣列"
# 'variable length arrays in C++ are a Clang extension'
HCD7C2CD01723: 'C++ 中的可變長度陣列是 Clang 的擴充功能'
# "variable length arrays in C++ are a Clang extension; did you mean to use 'static_assert'?"
H53E1EE683577: "C++ 中的可變長度陣列是 Clang 的擴充功能；是否想要使用 'static_assert'？"
# 'variable length arrays in a coroutine are not supported'
HD279E72346CE: '在協程中使用可變長度陣列不被支援'
# 'variable must be of integer or %select{pointer|random access iterator}0 type'
H4F34EF5C94E2: '變數的類型必須為整數或 %select{指標|隨機存取迭代器}0'
# "variable named 'main' with external linkage has undefined behavior"
H38BA25ED2BA1: "具有外部連結的 'main' 變數會導致未定義行為"
# 'variable of non-literal type %1 cannot be defined in a constexpr %select{function|constructor}0 before C++23'
H5F89C6201D7E: '在 C++23 之前，無法在 constexpr %select{函數|建構子}0 中定義非文字類型 %1 的變數'
# "variable of non-reference type %0 can be used only with 'val' modifier, but used with '%1'"
HFF57CDDBE63D: "非引用類型 %0 的變數只能與 'val' 修飾符一起使用，但實際使用了 '%1'"
# 'variable of type %1 has %select{private|protected}2 destructor'
H8BC8C9632B1A: '類型 %1 的變數具有 %select{私有|受保護}2 的析構函數'
# "variable referenced by 'link' clause not in global or namespace scope must be marked 'extern'"
HF7968BA9CE92: "在全局或命名空間作用域之外被 'link' 子句引用的變數必須標記 'extern'"
# "variable referenced in '%0' clause of OpenACC 'declare' directive was already referenced"
H8FFABBD53A56: "OpenACC 'declare' 指令的 '%0' 子句中引用的變數已被其他位置引用"
# 'variable template partial specialization %0 cannot be redefined'
HB5621CB8D5D4: '變數模板部分特化 %0 不可重新定義'
# 'variable templates are a C++14 extension'
H031A6133F773: '變數模板是 C++14 擴充功能'
# 'variable templates are incompatible with C++ standards before C++14'
HC36BFC632A54: '變數模板不相容於 C++14 之前的標準'
# "variable with 'loader_uninitialized' attribute cannot have an initializer"
H9908D11CFEF9: "具有 'loader_uninitialized' 屬性的變數不可指定初始值"
# "variable with 'loader_uninitialized' attribute must have a trivial default constructor"
H30559420B01D: "具有 'loader_uninitialized' 屬性的變數必須具有平凡的預設建構函數"
# 'variable with local storage in initial value of threadprivate variable'
H06BE1F004442: '執行緒私有變數的初始值中包含具有局部儲存類型的變數'
# 'variable%select{s| %1|s %1 and %2|s %1, %2, and %3|s %1, %2, %3, and %4}0 used in loop condition not modified in loop body'
H78CB81888F63: '%select{該變數|該變數 %1|該變數 %1 和 %2|該變數 %1、%2 和 %3|該變數 %1、%2、%3 和 %4}0 在迴圈條件中使用但未在迴圈主體中修改'
# 'variable-sized object may not be initialized'
HF22D786D9F31: '可變長度物件不可指定初始值'
# 'variables in function scope cannot be declared static'
H588D8DBF6957: '函式作用域中的變數不可宣告為 static'
# 'variables in the %0 address space can only be declared in the outermost scope of a kernel function'
H077534025BE2: '%0 位址空間中的變數只能在核心函式最外層作用域中宣告'
# 'variably modified type %0 cannot be used as a template argument'
H43ADD4446C3D: '可變長度類型 %0 不可作為模板參數使用'
# "variably modified type declaration cannot have 'extern' linkage"
H31174A21A725: '具有 extern 連結性的可變長度類型宣告不符合語法規則'
# 'variably modified type declaration not allowed at file scope'
H0326E5892284: '檔案作用域中不可宣告可變長度類型'
# 'variably-modified type %0 cannot be used in a constexpr %select{function|constructor}1'
HA78DFABA86CF: '可變長度類型 %0 不可於 constexpr %select{函式|建構函數}1 中使用'
# "variadic 'friend' declarations are a C++2c extension"
H3D2FFF66A145: '可變參數的 friend 宣告是 C++2c 擴充功能'
# "variadic 'friend' declarations are incompatible with C++ standards before C++2c"
H365CB532BF3E: '可變參數的 friend 宣告不相容於 C++2c 之前的標準'
# 'variadic function cannot use %0 calling convention'
HEC894E082768: '可變參數函數無法使用 %0 呼叫約定'
# 'variadic macros are a C99 feature'
H6AA48F3D31FE: '可變參數宏是 C99 的功能'
# 'variadic macros are a Clang extension in OpenCL'
H1CAB7A29DC4C: '在 OpenCL 中可變參數宏是 Clang 的擴充功能'
# 'variadic macros are incompatible with C++98'
H4BD20CD6A5E1: '可變參數宏與 C++98 不相容'
# 'variadic templates are a C++11 extension'
H499FA3A280B8: '可變參數範型是 C++11 的擴充功能'
# 'variadic templates are incompatible with C++98'
H4B7B3608CF46: '可變參數範型與 C++98 不相容'
# "variant function in '#pragma omp declare variant' is itself marked as '#pragma omp declare variant'"
H82A01F59E7E3: "在 '#pragma omp declare variant' 中宣告的變體函數本身也被標記為 '#pragma omp declare variant'"
# "variant in '#pragma omp declare variant' is the same as the base function"
HEC73C56687BA: "在 '#pragma omp declare variant' 中的變體與基底函數相同"
# "variant in '#pragma omp declare variant' with type %0 is incompatible with type %1%select{| with appended arguments}2"
H443E0ACFD62A: '#pragma omp declare variant中類型為 %0 的變體與 %1%select{|加上附加參數}2的類型不相容'
# 'vector component access exceeds type %0'
HA6E77B2F0A3C: '向量元件存取超出類型 %0 的範圍'
# 'vector component access has invalid length %0; supported lengths are: 1,2,3,4,8,16'
HCB71F9B8CFBC: '向量元件存取長度 %0 無效；支援的長度為：1,2,3,4,8,16'
# "vector component name '%0' is a feature from OpenCL version 3.0 onwards"
H6B53729D7A1D: "OpenCL 3.0 版本以後才支援向量元件名稱 '%0'"
# 'vector condition type %0 and result type %1 do not have elements of the same size'
H9FFA8360C1AF: '向量條件類型 %0 和結果類型 %1 的元素大小不一致'
# 'vector condition type %0 and result type %1 do not have the same number of elements'
H48693917C57D: '向量條件類型 %0 和結果類型 %1 的元素數量不同'
# 'vector initializers are not compatible with NEON intrinsics in big endian mode'
H20E090504D21: '向量初始值設定項與大端模式下的 NEON 內在函數不相容'
# 'vector is not assignable (contains duplicate components)'
HA13B723E09E4: '向量無法被指派（包含重複元件）'
# 'vector operands do not have the same elements sizes (%0 and %1)'
H20CF2F14B1AB: '向量操作數的元素大小不一致 (%0 和 %1)'
# 'vector operands do not have the same number of elements (%0 and %1)'
H02E2D0489C4C: '向量操作數的元素數量不同 (%0 和 %1)'
# 'vector operands to the vector conditional must be the same type %diff{($ and $)|}0,1}'
HBD47DE4A7313: '向量條件運算子的向量操作數必須為相同類型 %diff{($和$)|}0,1}'
# 'vector size not an integral multiple of component size'
H77E12186A8E0: '向量大小不是元件大小的整數倍數'
# "vectorize_width loop hint malformed; use vectorize_width(X, fixed) or vectorize_width(X, scalable) where X is an integer, or vectorize_width('fixed' or 'scalable')"
H52976DB4C3C0: "vectorize_width循環提示格式錯誤；請使用vectorize_width(X, fixed)或vectorize_width(X, scalable)，其中X為整數，或vectorize_width('fixed' 或 'scalable')"
# "vendor '%0' is not supported: '%1'"
HEF7F8EFDE1D2: "供應商 '%0' 不受支援：%1"
# 'verbose'
H3F73A838273F: '詳細模式'
# 'verify structure of the log'
HA2B07D4BBAB9: '驗證日誌結構'
# 'verify the CFG after every pass'
H94E54A437791: '每個pass後驗證CFG結構'
# 'verify-uselistorder Options'
HBF754C1F763D: '驗證使用清單順序選項'
# "version '%0' in target triple '%1' is invalid"
H638A2A1C27BA: "目標三元組 '%1' 中的版本 '%0' 無效"
# 'version 1'
H58A74A7AA4A0: '版本 1'
# 'version 2'
H85DE840F8B53: '版本 2'
# 'version 3'
HA54E81A648CA: '版本 3'
# 'version control conflict marker in file'
H58D6C666A33F: '文件中存在版本控制衝突標記'
# "version for '%0' already specified"
HD1955B4EAF6D: "'%0' 的版本已指定"
# 'version list contains duplicate entries'
HDC1A5F99BC1B: '版本列表包含重複條目'
# "version list contains entries that don't impact code generation"
H346B24B0B01F: '版本列表包含對程式碼生成無影響的條目'
# 'version number must have non-zero major, minor, or sub-minor version'
H32D5C8ECFF2D: '版本號必須有非零的主要、次要或次次要版本'
# 'violations found for %0'
HC357EBB7E4D0: '在 %0 中發現違規項目'
# 'virtual base class declared here'
H2738AB0FED80: '在此處宣告虛基類'
# 'virtual constexpr functions are incompatible with C++ standards before C++20'
H0CA73C06B6D5: '虛constexpr函數與C++20之前的C++標準不相容'
# "virtual destructor requires an unambiguous, accessible 'operator delete'"
H23281750E023: "虛析構函數需要明確且可存取的 'operator delete'"
# "virtual filesystem overlay file '%0' not found"
H26F74FB8B8C2: "虛擬檔案系統覆寫檔 '%0' 未找到"
# 'virtual function %0 has a different return type %diff{($) than the function it overrides (which has return type $)|than the function it overrides}1,2'
HD8B18D2DDADC: '虛函數 %0 的回傳類型 %diff{ $ 與其覆寫的函數（其回傳類型為 $）不同|與被覆寫的函數不同}1,2'
# 'virtual function %0 has different attributes %diff{($) than the function it overrides (which has $)|than the function it overrides}1,2'
H105CB368BBFA: '虛函數 %0 的屬性 %diff{ $ 與其覆寫的函數（其具有 $ 屬性）不同|與被覆寫的函數不同}1,2'
# 'virtual function %0 has different calling convention attributes %diff{($) than the function it overrides (which has calling convention $)|than the function it overrides}1,2'
HB03FA37606B1: '虛函數 %0 的呼叫約定屬性 %diff{ $ 與其覆寫的函數（其具有呼叫約定 $）不同|與被覆寫的函數不同}1,2'
# 'virtual function %q0 has more than one final overrider in %1'
H80394FC58D1D: '虛函數 %q0 在 %1 中有多於一個 final 覆寫者'
# 'virtual function cannot be constexpr'
H01635D482A33: '虛函數不能是 constexpr'
# 'virtual function cannot have a requires clause'
H138054D4510B: '虛函數不能有 requires 子句'
# 'virtual functions are not supported in C++ for OpenCL'
H820F01CD9896: 'C++ 的 OpenCL 中不支援虛函數'
# 'virtual functions are unsupported in HLSL'
H207695B65E04: 'HLSL 中不支援虛函數'
# 'virtual inheritance is unsupported in HLSL'
H8C2B278220B7: 'HLSL 中不支援虛基類繼承'
# "virtual method %0 is inside a 'final' class and can never be overridden"
HAC30D95A1570: "虛方法 %0 在 'final' 類別中，永遠無法被覆寫"
# 'visibility does not match previous declaration'
H17040BB5EC03: '可見性與先前宣告不匹配'
# 'void %select{function|method|block}1 %0 should not return void expression'
HCA9EAB88160F: '無型別 %select{函數|方法|區塊}1 %0 不應傳回 void 表達式'
# 'void block should not return a value'
H1C0762ECEC55: 'void 區塊不應傳回值'
# 'volatile %select{temporary created|object declared|member declared}0 here'
HBA1E3AEA8BE2: 'volatile %select{建立的臨時物件|宣告的物件|宣告的成員}0 這裡'
# 'volatile qualifier in structured binding declaration is deprecated'
H8119BA6E8068: '結構化綁定宣告中的 volatile 修飾符已被棄用'
# 'volatile-qualified parameter type %0 is deprecated'
H9F774F8B8E15: 'volatile 修飾的參數類型 %0 已被棄用'
# 'volatile-qualified return type %0 is deprecated'
H34762436C2FA: 'volatile 修飾的回傳類型 %0 已被棄用'
# 'warn on trailing characters'
H82F663F8D48C: '在尾隨字元時發出警告'
# 'warnings are errors'
HB9FCBCA0C7DE: '警告視為錯誤'
# 'was searched for in the directory: %0'
H4B8949005850: '在目錄中搜索： %0'
# 'wave good bye'
H29B5647E64A4: '揮手道別'
# 'weak %select{variable|property|implicit property|instance variable}0 %1 is accessed multiple times in this %select{function|method|block|lambda}2 but may be unpredictably set to nil; assign to a strong variable to keep the object alive'
H7F2B64A607B2: '弱 %select{變數|屬性|隱含屬性|實例變數}0 %1 在此 %select{函式|方法|區塊|lambda}2 中被多次存取，但可能不可預測地設為 nil；將其分配給強引用變數以保持物件存活'
# 'weak %select{variable|property|implicit property|instance variable}0 %1 may be accessed multiple times in this %select{function|method|block|lambda}2 and may be unpredictably set to nil; assign to a strong variable to keep the object alive'
H301C12832949: '弱 %select{變數|屬性|隱含屬性|實例變數}0 %1 可能在此 %select{函式|方法|區塊|lambda}2 中被多次存取，並可能不可預測地設為 nil；將其分配給強引用變數以保持物件存活'
# 'weak attribute declared on a __strong type property in GC mode'
H088D436307D2: '在GC模式下，__strong類型屬性上宣告了weak屬性'
# 'weak declaration cannot have internal linkage'
HC1895405FFA7: '弱宣告不能具有內部連結性'
# 'weak identifier %0 never declared'
H22A978739C8D: '弱識別符 %0 永未宣告'
# 'weakref declaration must have internal linkage'
H8016E3683340: 'weakref宣告必須具有內部連結性'
# 'weakref declaration of %0 must also have an alias attribute'
H101799E65B31: '%0 的weakref宣告還必須具有別名屬性'
# 'weakref declaration of %0 must be in a global context'
HDA1EB6DAD24A: '%0 的weakref宣告必須在全域環境中'
# 'webassembly: disables the fix  irreducible control flow optimization pass'
HA0B81E145B1D: 'webassembly：禁用修正不可簡化控制流優化pass'
# 'when a function is considered for merging into a partition that already contains some of its callees, do the merge if at least n% of the code it can reach is already present inside the partition; e.g. 0.7 means only merge >70%'
HB679EAE1AA06: '當一個函數被考慮合併到已經包含其部分被呼叫函數的區塊時，如果至少有n%的可達代碼已經存在於該區塊中，則進行合併；例如 0.7表示僅合併>70%'
# 'when applied to this declaration'
HA6DB04448955: '當應用於此宣告時'
# 'when deciding to split a function, apply this alignment while doing the size comparison (see -split-threshold). Default value: 2.'
HD6693F2AB0CA: '當決定分割函數時，執行大小比較時使用此對齊值（參見 -split-threshold）。預設值：2.'
# 'when emitting large string tables, prefer string literals over comma-separated char literals. This can be a readability and compile-time performance win, but upsets some compilers'
H2D23BA9375B5: '當發射大型字串表時，優先使用字串字面量而非以逗號分隔的字符字面量。此舉可提高可讀性和編譯時間效能，但可能影響某些編譯器'
# 'when implemented by class %0'
H9F7ED2DB900A: '當由類別 %0 實作時'
# "when looking up '%select{begin|end}0' function for range expression of type %1"
HC4C870329421: '在為類型 %1 的區間運算式尋找 %select{begin|end}0 函數時'
# 'when max depth is reached and we can no longer branch out, this value determines if a function is worth merging into an already existing partition to reduce code duplication. This is a factor of the ideal partition size, e.g. 2.0 means we consider the function for merging if its cost (including its callees) is 2x the size of an ideal partition.'
HC50D6FBB78F2: '當最大深度達到且我們無法再分支時，此值決定了函數是否值得合併到已存在的區塊以減少代碼重複。這是理想區塊大小的因子，例如 2.0表示如果函數的代價（包括其被呼叫函數）是理想區塊大小的 2 倍，則考慮進行合併。'
# 'when possible, poison scoped variables at the beginning of the scope (slower, but more precise)'
H00AA44541919: '在可能的情況下，從作用域的開頭毒化作用域變數（較慢，但更精確）'
# 'when repeating the instruction snippet by looping over it, duplicate the snippet until the loop body contains at least this many instruction'
HED512258C903: '當透過迴圈重複指令片段時，複製片段直到迴圈主體包含至少此數量的指令'
# 'when type is in parentheses, array cannot have dynamic size'
HBDE59C8D782B: '當類型在括號中時，陣列無法具有動態大小'
# 'which delegates to'
H90C5BED46FE0: '哪個委派到'
# 'which gadget scanners to run'
HF9F26A96F310: '要執行的gadget掃描器'
# 'while building implicit deduction guide first needed here'
HD4658CE20D59: '在建立隱含的推導指引時，首先需要在此處'
# 'while calculating associated constraint of template %0 here'
HD4CBA036E98A: '在計算模板 %0 的相關約束時'
# 'while checking a default template argument used here'
H7E4F64D4A848: '在檢查在此處使用的預設模板參數時'
# "while checking constraint satisfaction for class template partial specialization '%0' required here"
H190F26B4DB43: '在檢查類模板部分特化 %0 的約束滿足情況時，需要在此處'
# "while checking constraint satisfaction for function '%0' required here"
H1A3A707B1D73: '在檢查函數 %0 的約束滿足情況時，需要在此處'
# "while checking constraint satisfaction for template '%0' required here"
H19BE8EB0741D: '在檢查模板 %0 的約束滿足情況時，需要在此處'
# "while checking constraint satisfaction for variable template partial specialization '%0' required here"
HD73CEE0E62DB: '在檢查變數模板部分特化 %0 的約束滿足情況時，需要在此處'
# "while checking implicit 'delete this' for virtual destructor"
H738DE49AA679: "在檢查虛函數析構函數的隱含 'delete this' 時"
# "while checking the satisfaction of concept '%0' requested here"
HE2FF74B26A28: '在檢查在此處請求的概念 %0 的滿足情況時'
# 'while checking the satisfaction of nested requirement requested here'
HE3D634694184: '在檢查在此處請求的嵌套需求的滿足情況時'
# "while declaring the corresponding implicit 'operator==' for this defaulted 'operator<=>'"
H332A7297AC58: "在為此預設的 'operator<=>' 宣告對應的隱含 'operator==' 時"
# 'while declaring the implicit %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}1 for %0'
HAC5877F575DC: '在為 %0 宣告隱含的%select{預設建構函數|複製建構函數|移動建構函數|複製指定運算子|移動指定運算子|析構函數}1時'
# 'while loop has empty body'
H374FEF617D4F: 'while迴圈的身體為空'
# 'while loop outside of a function'
HAB96332E82A6: '函式外部的while迴圈'
# 'while printing functions output dyno-stats and skip instructions'
HF414286E0A36: '在列印函式時輸出dyno-stats並跳過指令'
# "while rewriting comparison as call to 'operator<=>' declared here"
H9A478A9E2AA1: "在將比較重寫為對在此處宣告的 'operator<=>' 的呼叫時"
# 'while substituting deduced template arguments into function template %0 %1'
H4E16912522F9: '在將推導出的模板參數替換到函數模板 %0 %1 時'
# 'while substituting explicitly-specified template arguments into function template %0 %1'
H862C7E7129FA: '在將明確指定的模板參數替換到函數模板 %0 %1 時'
# 'while substituting into a lambda expression here'
H154EA9F3EDC1: '在這裡替換 lambda 表達式時'
# 'while substituting into concept arguments here; substitution failures not allowed in concept arguments'
HAC706623FF86: '在此處替換概念參數時；概念參數不允許替換失敗'
# 'while substituting prior template arguments into %select{non-type|template}0 template parameter%1 %2'
HF0EDCF82D09D: '在將先前模板參數替換到 %select{非類型|模板}0 模板參數 %1 %2 時'
# 'while substituting template arguments into constraint expression here'
H19C71987DC07: '在將模板參數替換到約束表達式時'
# 'whitespace is not allowed in parameter passing direction'
H82BD58AB277F: '參數傳遞方向中不允許有空白'
# 'whitespace recommended after macro name'
H47F8347E0371: '建議在宏名稱後面添加空白'
# 'whitespace required after macro name'
H2F43B2E26F3A: '在宏名稱後面必須添加空白'
# 'widen this field to %0 bits to store all values of %1'
HD1698255B212: '將此欄位擴展到 %0 位以存儲 %1 的所有值'
# 'width of bit-field %0 (%1 bits) exceeds the width of its type; value will be truncated to %2 bit%s2'
H8896C13CC6D9: '位段 %0 的位數 (%1 位) 超過其類型的寬度；值將被截斷為 %2 位'
# 'width of%select{ anonymous|}0 bit-field%select{| %1}0 (%2 bits) exceeds the %select{width|size}3 of its type (%4 bit%s4)'
H02B50746D7D1: '%select{匿名|}0 位段 %select{| %1}0 的寬度 (%2 位) 超過其類型的%select{寬度|大小}3 (%4 位)'
# 'with jt-footprint-reduction, only process PIC jumptables and turn off other transformations that increase code size'
H3BB007DE5DDB: '在啟用 jt-footprint-reduction 時，僅處理 PIC jumptables 並關閉其他會增加代碼大小的轉換'
# 'within field of type %0 declared here'
HEC6FDC220283: '在此處宣告的類型 %0 的成員域中'
# 'writable atomic property %0 cannot pair a synthesized %select{getter|setter}1 with a user defined %select{getter|setter}2'
HA65A16D8E26B: '可寫的原子屬性 %0 不可將合成的 %select{getter|setter}1 與使用者定義的 %select{getter|setter}2 結合'
# 'write BOLT Address Translation tables'
H1540FEF77408: '寫入 BOLT Address Translation 表格'
# 'write bolt info section in the output binary'
H5BC44776C33F: '在輸出二進位檔中寫入 BOLT 資料區段'
# 'wrong argument format for hlsl attribute, use %0 instead'
H514518256D51: 'HLSL 屬性使用錯誤的參數格式，應改用 %0'
# 'wrong fpu width; %select{LSX|LASX}0 depends on 64-bit FPU'
H65FC5C473561: '錯誤的 FPU 寬度；%select{LSX|LASX}0 依賴 64 位 FPU'
# 'yaml2obj Options'
H095AAC30EBC3: 'YAML2OBJ 選項'
# "you need to include <typeinfo> before using the 'typeid' operator"
H64B8C0D4E612: "您需要在使用 'typeid' 運算子前包含 <typeinfo>"
# 'z/OS target level "%0" is discontinued'
HB5BA348592D3: 'z/OS 目標層級 "%0" 已廢止'
# 'z/OS target level "%0" is invalid'
H0080755EFA11: 'z/OS 目標層級 "%0" 無效'
# 'zero %0 size'
HF7816CFF7955: '%0 大小為零'
# 'zero as null pointer constant'
H824A61FB1C48: '零用作空指針常量'
# 'zero field width in scanf format string is unused'
H122ACCFBBD62: '在 scanf 格式字串中未使用的零字段寬度'
# 'zero linear step (%0 %select{|and other variables in clause }1should probably be const)'
HDA0E059C273A: '%0 %select{|和子句中的其他變數}1可能應為 const（常數）'
# 'zero size arrays are an extension'
H49512BBF0CE4: '零長度陣列是擴充功能'
# "zero-length array section is not allowed in 'depend' clause"
HC5FAF4CE6159: "在 'depend' 子句中不允許使用零長度陣列區段"
# 'zero-length arrays are not permitted in %select{C++|SYCL device code|HIP device code}0'
H2F083F032372: '在 %select{C++|SYCL裝置代碼|HIP裝置代碼}0中不允許使用零長度陣列'
