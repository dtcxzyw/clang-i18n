# '\n********************\n\nPLEASE ATTACH THE FOLLOWING FILES TO THE BUG REPORT:\nPreprocessed source(s) and associated run script(s) are located at:'
H8F8E0E346199: '\n********************\n\n버그 보고서에 다음 파일을 첨부해 주세요:\n미리 처리된 소스 파일(들)과 연관된 실행 스크립트(들)의 위치는 다음과 같습니다:'
# '\nDirectory where processed files are stored.\nLinks to definition locations will only be\ngenerated if the file is in this dir.'
H71324B3824F3: '\n프로세싱된 파일들이 저장되는 디렉토리입니다.\n이 디렉토리에 있는 파일에 대해서만 정의 위치로의 링크가 생성됩니다.'
# '\nThe directory for merging symbols.'
H41BC7E2887B5: '\n심볼 병합을 위한 디렉토리입니다.'
# '\nThe output directory for saving the results.'
H9976AAF7AB83: '\n결과를 저장하는 출력 디렉토리입니다.'
# '\nTurn on time profiler. Generates clang-doc-tracing.json'
H57CFA45FD036: '\n시간 프로파일러를 켭니다. clang-doc-tracing.json을 생성합니다'
# '\nURL of repository that hosts code.\nUsed for links to definition locations.'
HC00AE5E38B4C: '\n코드를 호스팅하는 저장소의 URL.\n정의 위치로의 링크에 사용됩니다.'
# '  Type "'
H1DFDE84EB693: '  "를 입력하면 도움말을 볼 수 있습니다.'
# " '%0 %select{sink:|source:}1' must be with '%select{omp_cur_iteration - 1|omp_cur_iteration}1'"
HCB22E641D2E6: " '%0 %select{수신단:|소스:}1'은 '%select{omp_cur_iteration - 1|omp_cur_iteration}1'과 함께 있어야 합니다"
# " '%0' in a raw string literal delimiter is a C++2c extension"
H03B242298EB9: " '%0'은 원시 문자열 리터럴 구분자에서 C++2c 확장 기능입니다"
# " '%0' in a raw string literal delimiter is incompatible with standards before C++2c"
HFCBE1727461C: " '%0'은(는) 원시 문자열 리터럴 구분자에서 C++2c 이전의 표준과 호환되지 않습니다"
# ' (default: '
H6248B40D9879: ' (기본값: '
# ' <subcommand> --help" to get more help on a specific subcommand'
H386881D1E849: ' <subcommand> --help를 입력하면 특정 하위 명령어에 대한 자세한 도움말을 얻을 수 있습니다"'
# ' BOLT Code Heatmap tool\n\n  Produces code heatmaps using sampled profile\n\n  Inputs:\n  - Binary (supports BOLT-optimized binaries),\n  - Sampled profile collected from the binary:\n    - perf data or pre-aggregated profile data (instrumentation profile not supported)\n    - perf data can have basic (IP) or branch-stack (LBR) samples\n\n  Outputs:\n  - Heatmaps: colored ASCII (requires a color-capable terminal or a conversion tool like `aha`)\n    Multiple heatmaps are produced by default with different granularities (set by `block-size` option)\n  - Section hotness: per-section samples% and utilization%\n  - Cumulative distribution: working set size corresponding to a given percentile of samples\n'
H8E5615231EC0: ' BOLT 코드 히트맵 도구\n\n  샘플링된 프로파일을 사용하여 코드 히트맵을 생성합니다\n\n  입력:\n  - 바이너리(BOLT 최적화 바이너리 지원),\n  - 바이너리에서 수집된 샘플링된 프로파일:\n    - perf 데이터 또는 사전 집계된 프로파일 데이터(계측 프로파일은 지원되지 않음)\n    - perf 데이터는 기본(IP) 또는 브랜치 스택(LBR) 샘플을 가질 수 있음\n\n  출력:\n  - 히트맵: 색상 ASCII(색상 지원 터미널 또는 `aha` 같은 변환 도구 필요)\n    기본적으로 다양한 세분성(블록 크기 옵션으로 설정됨)으로 여러 히트맵 생성\n  - 섹션 핫니스: 섹션별 샘플 % 및 활용도 %\n  - 누적 분포: 샘플의 주어진 백분율에 해당하는 작업 세트 크기'
# ' BrainF compiler\n'
H25D59DE4A1CF: ' 뇌분 컴파일러\n'
# ' [options]'
HE3EDA38172DD: ' [옵션]'
# ' [subcommand]'
HEBFEA7B72C8E: ' [서브커맨드]'
# ' positional argument'
HB552499219D4: ' 위치 인수'
# ' positional arguments: See: '
H847D7E575852: ' 위치 인수: 참조: '
# '#else after #else'
H73FE4A6784FB: '#else 뒤에 #else'
# '#else without #if'
HF8F50363B288: '#else가 #if 없이 사용되었습니다.'
# '#embed is a %select{C23|Clang}0 extension'
H799E9AA4840E: '#embed는 %select{C23|Clang}0 확장입니다'
# '#embed is incompatible with C standards before C23'
H1AF95A3E3444: '#embed는 C23 이전의 C 표준과 호환되지 않습니다'
# '#endif without #if'
H56B14C401F16: '#endif가 #if 없이 사용됨'
# '#ident is a language extension'
H45C329EC97BC: '#ident는 언어 확장입니다'
# '#import is a language extension'
H8768B3DA6294: '#import는 언어 확장 기능입니다'
# '#import of type library is an unsupported Microsoft feature'
H1CFAB9C94AB6: '#import 타입 라이브러리의 사용은 지원되지 않는 Microsoft 기능입니다.'
# '#include nested too deeply'
H21908EF6D74E: '#include가 너무 깊게 중첩되었습니다'
# "#include of '%0' not seen while attempting to %select{create|use}1 precompiled header"
H05355AF7456A: "#include '%0'가 %select{생성|사용}1 시도 중에 발견되지 않았습니다"
# '#include resolved using non-portable Microsoft search rules as: %0'
HE0D8871EA3B6: '#include가 비포터블 마이크로소프트 검색 규칙을 사용하여 해결되었습니다: %0'
# '#include_next in file found relative to primary source file or found by absolute path; will search from start of include path'
H92850FB4B236: '#include_next가 주 소스 파일에 상대적으로 위치하거나 절대 경로로 찾은 파일에서 발견되면; include 경로의 시작부터 검색합니다'
# '#include_next in primary source file; will search from start of include path'
HA1F5AE68D4B4: '#include_next가 주 소스 파일에서 사용되었습니다; 인클루드 경로의 시작 부분부터 검색합니다'
# '#include_next is a language extension'
H924C2DCE9AC7: '#include_next는 언어 확장입니다'
# '#line directive requires a positive integer argument'
H2EB091899FF1: '#line 지시문은 양의 정수 인수가 필요합니다'
# '#line directive with zero argument is a GNU extension'
H05235496C826: '#line 지시어는 인수가 없을 때 GNU 확장 기능입니다'
# '#line number greater than 32767 is incompatible with C++98'
HF9B195DC3866: '32767보다 큰 줄 번호는 C++98과 호환되지 않습니다'
# '#pragma %0(".drectve") has undefined behavior, use #pragma comment(linker, ...) instead'
H6CC89C517043: '#pragma %0(".drectve")는 정의되지 않은 동작을 합니다. 대신 #pragma comment(linker, ...)를 사용하세요'
# '#pragma %0(pop, ...) failed: %1'
H1F44FB9E690A: '#pragma %0(pop, ...) 실패: %1'
# '#pragma align(packed) may not be compatible with objects generated with AIX XL C/C++'
H19CC6269DA45: '#pragma align(packed)는 AIX XL C/C++로 생성된 개체들과 호환되지 않을 수 있습니다'
# '#pragma entered here'
H4EB06A1F820E: '#pragma가 여기에 입력되었습니다'
# "#pragma execution_character_set expected '%0'"
H3700F774625D: "#pragma execution_character_set에 '%0'이(가) 필요합니다."
# "#pragma execution_character_set expected 'push' or 'pop'"
HF944C9D4F311: "#pragma 실행 문자 집합에 'push' 또는 'pop'이 필요합니다"
# "#pragma execution_character_set invalid value '%0', only 'UTF-8' is supported"
HF7B9B86DDFE7: "#pragma execution_character_set 유효하지 않은 값 '%0', 오직 'UTF-8'만 지원됩니다"
# '#pragma hdrstop filename not supported, /Fp can be used to specify precompiled header filename'
HB20EE88D126A: '#pragma hdrstop 파일명은 지원되지 않습니다. /Fp 옵션을 사용하여 사전 컴파일 헤더 파일명을 지정할 수 있습니다.'
# '#pragma hdrstop not seen while attempting to use precompiled header'
H482D12372789: '#pragma hdrstop가 발견되지 않았습니다. 이는 precompiled header를 사용하려고 시도하는 동안 발생했습니다'
# '#pragma once in main file'
H9D36B8727C26: '#pragma once를 메인 파일에서 사용함'
# '#pragma options align=reset failed: %0'
H3024180A558C: '#pragma 옵션 align=reset 실패: %0'
# '#pragma redefine_extname is applicable to external C declarations only; not applied to %select{function|variable}0 %1'
HAF6CFAD80C5F: '#pragma redefine_extname은 외부 C 선언에만 적용됩니다; 지정된 %select{함수|변수}0 %1에 적용되지 않았습니다'
# '#pragma system_header ignored in main file'
HE58DA574E5C2: '#pragma system_header가 메인 파일에서 무시됨'
# '#pragma visibility pop with no matching #pragma visibility push'
H3EDA32C5E985: '#pragma visibility pop이 대응하는 #pragma visibility push가 없습니다'
# '#pragma visibility push with no matching #pragma visibility pop'
HB15E579A68AB: '#pragma visibility push가 있으나 매칭되는 #pragma visibility pop가 없습니다'
# "#pragma warning expected '%0'"
HE762E253E06E: "#pragma warning '%0' 기대됩니다"
# "#pragma warning expected 'push', 'pop', 'default', 'disable', 'error', 'once', 'suppress', 1, 2, 3, or 4"
HBCB4550F177A: "#pragma warning은 '추가', '제거', '기본', '비활성화', '오류', '한번', '억제', 1, 2, 3 또는 4를 예상합니다"
# '#pragma warning expected a warning number'
HB9A465F10016: '#pragma warning 경고 번호가 필요합니다'
# '#pragma warning(push, level) requires a level between 0 and 4'
H99A37FD4A6D8: '#pragma warning(push, level)은 0과 4 사이의 level이 필요합니다'
# '#warning is a %select{C23|C++23}0 extension'
H0F157EC51CD6: '#warning은 %select{C23|C++23}0 확장입니다'
# '#warning is incompatible with C standards before C23'
H447994BFEB83: '#warning은 C23 이전의 C 표준과 호환되지 않습니다'
# '#warning is incompatible with C++ standards before C++23'
H42FA898C6606: '#warning은 C++23 이전의 C++ 표준과 호환되지 않습니다'
# '%0 %select{parameter|return}1 type is unsupported; support for vector types for this target is introduced in %2'
HDC6BFCFF388E: '%0 %select{파라미터|리턴}1 유형은 지원되지 않습니다; 이 타겟에 대한 벡터 유형의 지원은 %2에서 도입되었습니다'
# "%0 '%1' is acquired exclusively and shared in the same scope"
H7390A9DF88C0: "%0 '%1'는 동일한 범위에서 독점적으로 획득되고 공유됩니다"
# "%0 '%1' is not held on every path through here%select{| with equal reentrancy depth}2"
HDC5F203131ED: "%0 '%1'이(가) 이 경로를 통해 모든 경로에서 보유되지 않았습니다%select{| 동일한 재진입 깊이로}2"
# "%0 '%1' is still held at the end of function"
HC378A7D8C58E: "%0 '%1'은(는) 함수의 끝에서 여전히 참조되고 있습니다"
# "%0 '%1' must be acquired before '%2'"
H1AA537616F4E: "%0 '%1'은 '%2'보다 먼저 획득되어야 합니다."
# "%0 '%2' not managed by '%1'"
H7EC62D1C1AF9: "%0 '%2'는 '%1'에 의해 관리되지 않습니다"
# "%0 (%1) exceeds limit (%2) in '%3'"
HE73AA4C10244: "%0 (%1)이 %2를 초과합니다. '%3'에서"
# '%0 acquired here'
HEA3E3310E736: '%0 여기서 획득됨'
# '%0 additional files entered using a total of %1B (%human1B) of space'
HBB08F5A2D9D4: '%0 추가 파일이 입력됨: 총 %1B (%human1B) 공간 사용'
# '%0 and %1%select{ attributes|}2 are not compatible'
H3E0737276230: '%0와 %1%select{ 속성|}2는 호환되지 않습니다'
# '%0 appears multiple times in clauses on the same declare target directive'
H71D418F6E9B9: '%0가 동일한 declare target 디렉티브의 클라우즈에서 여러 번 등장했습니다'
# '%0 applied to an expression is a GNU extension'
HE4B8DDF4E86C: '%0를 표현식에 적용하는 것은 GNU 확장 기능입니다'
# '%0 argument must be a constant unsigned integer expression'
HD9AE42B82C9D: '%0 인수는 상수 unsigned 정수 표현식이어야 합니다'
# '%0 argument of MTE builtin function must be a null or a pointer (%1 invalid)'
H1FAF65C9963B: 'MTE 내장 함수의 %0 번째 인수는 null 또는 포인터여야 합니다 (%1이/가 무효합니다)'
# '%0 argument of MTE builtin function must be a pointer (%1 invalid)'
H0BF1182D2AC8: '%0번째 인수는 MTE 내장 함수의 포인터여야 합니다 (%1이 유효하지 않음)'
# '%0 argument of MTE builtin function must be an integer type (%1 invalid)'
H2B10B0C97CC4: '%0 인수는 MTE 내장 함수의 정수 형식이어야 합니다 (%1이 유효하지 않습니다)'
# '%0 argument to %1 must be of vector type'
H61B90BC8950E: '인수 %0는 %1에 전달되며 벡터 유형이어야 합니다'
# '%0 attribute %plural{0:takes no arguments|1:takes one argument|:requires exactly %1 arguments}1'
H8625FD5B48BC: '%0 어트리뷰트 %plural{0:인자를 받지 않습니다.|1:하나의 인자를 받습니다.|:정확히 %1개의 인자를 요구합니다.}1'
# '%0 attribute applied to non-RVV type %1'
H49243AEFBCDB: '%0 속성이 RVV 타입이 아닌 %1에 적용됨'
# '%0 attribute applied to non-SVE type %1'
H7CA8225CCF33: '%0 속성이 비-SVE 형식 %1에 적용되었습니다'
# "%0 attribute applies to function parameters only if their type is a reference to a 'scoped_lockable'-annotated type"
H8F04340A3021: "%0 특성은 매개변수 유형이 'scoped_lockable' 어노테이션이 적용된 유형의 참조일 경우에만 함수 매개변수에 적용됩니다"
# "%0 attribute argument '%1' not supported on a global variable"
H12B4D27D7798: "%0 속성 인수 '%1'은 전역 변수에 지원되지 않습니다"
# '%0 attribute argument is invalid: %select{max must be 0 since min is 0|min must not be greater than max}1'
HD3E478873102: '%0 속성 인수는 유효하지 않습니다: %select{min이 0이므로 max는 0이어야 합니다|max는 min보다 커서는 안 됩니다}1'
# '%0 attribute argument may only refer to a function parameter of integer type'
H05E563701DF2: '속성 인자 %0는 정수 형식의 함수 매개변수만 참조할 수 있습니다'
# '%0 attribute argument must be a string literal specifying a Swift function name'
H056A97564B83: '%0 특성 인수는 Swift 함수 이름을 지정하는 문자열 리터럴이어야 합니다'
# '%0 attribute argument not supported: %1'
HB519160711B1: '%0 특성 인수는 지원되지 않습니다: %1'
# "%0 attribute can only be applied in a context annotated with 'capability' attribute"
H9411040D8420: "%0 특성은 'capability' 특성이 지정된 컨텍스트에서만 적용할 수 있습니다"
# '%0 attribute can only be applied once per parameter'
H3C2BAB720741: '%0 속성은 매개변수당 한 번만 적용할 수 있습니다'
# '%0 attribute can only be applied to a %select{function|method}1 with an error parameter'
H5477D07BA320: '속성 %0은 오류 매개변수가 있는 %select{함수|메소드}1에만 적용될 수 있습니다'
# '%0 attribute can only be applied to a ARM, HLSL, SPIR-V or RISC-V builtin'
H57FF55F870DD: '%0 속성은 ARM, HLSL, SPIR-V 또는 RISC-V 내장 함수에만 적용할 수 있습니다'
# '%0 attribute can only be applied to instance variables or properties'
H30E90B5958C9: '%0 특성은 인스턴스 변수나 속성에만 적용될 수 있습니다'
# "%0 attribute cannot be applied to %select{a function parameter|a variable with 'register' storage class|a 'catch' variable|a bit-field|an enumeration}1"
HD202D2E58321: "%0 특성은 %select{함수 매개변수|'register' 저장 클래스를 가진 변수|'catch' 변수|비트 필드|열거형}1에 적용할 수 없습니다."
# '%0 attribute cannot be applied to %select{methods in protocols|dealloc}1'
HC18046C82752: '%0 속성은 %select{프로토콜의 메서드|dealloc}1에 적용할 수 없습니다'
# '%0 attribute cannot be applied to a %select{function|method}1 with no parameters'
H9F395B21D226: '%0 속성은 매개변수가 없는 %select{function|method}1에 적용할 수 없습니다'
# '%0 attribute cannot be applied to a module'
H6CF918E64873: '특성 %0는 모듈에 적용할 수 없습니다'
# '%0 attribute cannot be applied to a module import'
H3AD0DE140148: '%0 attribute는 모듈 임포트에 적용할 수 없습니다'
# '%0 attribute cannot be applied to non-static member functions'
HCA6FA0E6C0E4: '%0 속성은 비정적 멤버 함수에 적용할 수 없습니다'
# '%0 attribute cannot be applied to sizeless type %1'
H60D82BB85EBA: '속성 %0는 크기 없는 타입 %1에 적용할 수 없습니다.'
# '%0 attribute cannot be applied to this declaration'
H1A106E97EE94: '%0 속성은 이 선언에 적용할 수 없습니다'
# '%0 attribute cannot be repeated'
H1FB2864F8926: '%0 attribute는 반복될 수 없습니다'
# '%0 attribute cannot be used from %select{a block|an Objective-C function|this context}1'
HFCD2CCA9A22B: '%0 속성은 %select{블록에서|Objective-C 함수에서|이 컨텍스트에서}1 사용할 수 없습니다'
# '%0 attribute cannot be used with pointers to members'
H828AE7C76F14: '%0 속성은 멤버 포인터와 함께 사용할 수 없습니다'
# "%0 attribute cannot specify more than one 'self:' parameter"
HC2B60D257432: "%0 특성은 'self:' 매개변수를 하나 이상 지정할 수 없습니다"
# '%0 attribute does not appear on the first declaration'
HE84901B6BFC0: '%0 속성이 첫 번째 선언에 지정되지 않았습니다'
# '%0 attribute expression never produces a constant expression'
H6DB854C2324C: '%0 특성 표현은 절대 상수 표현을 생성하지 않습니다'
# "%0 attribute for 'subscript' getter cannot have a 'newValue:' parameter"
HEBB5613EEF15: "%0 속성은 'subscript' getter에 'newValue:' 매개변수가 있을 수 없습니다"
# "%0 attribute for 'subscript' must %select{be a getter or setter|have at least one parameter|have a 'self:' parameter}1"
H445CA4D5B31B: "%0 속성은 'subscript'에 사용될 때 %select{가져오기 또는 설정기 메서드여야 합니다|최소한 하나의 매개변수를 가져야 합니다|'self:' 매개변수를 가져야 합니다}1"
# "%0 attribute for 'subscript' setter cannot have multiple 'newValue:' parameters"
H2C95053B8BED: "%0 속성은 'subscript' setter에 대해 여러 개의 'newValue:' 매개변수를 가질 수 없습니다"
# "%0 attribute for 'subscript' setter must have a 'newValue:' parameter"
HD3A5819D09C5: "%0 속성은 'subscript' 인덱서 세터에 'newValue:' 매개변수가 필요합니다"
# "%0 attribute for getter must not have any parameters besides 'self:'"
HA628A2E87201: "getter의 %0 속성은 'self:' 이외의 매개변수를 가질 수 없습니다."
# '%0 attribute for setter must have one parameter for new value'
H349FB00769DE: '%0 속성은 setter에 새 값 매개변수 하나를 가져야 합니다'
# '%0 attribute has invalid identifier for the %select{base|context|parameter}1 name'
HC37D287D1C6D: '%0 속성은 %select{기반|컨텍스트|매개변수}1 이름으로 사용되는 올바르지 않은 식별자를 가지고 있습니다'
# '%0 attribute has no effect on defaulted or deleted functions'
HDFBEF81FB2EF: '특성 %0는 defaulted나 deleted 함수에 영향을 주지 않습니다'
# '%0 attribute ignored'
HCD3BE326728C: '%0 특성 무시됨'
# '%0 attribute ignored because Clang does not yet support this attribute signature'
HB0B12C0AB26E: '%0 attribute가 무시되었습니다. Clang은 아직 이 attribute 시그니처를 지원하지 않습니다'
# '%0 attribute ignored for field of type %1'
HBE46E60BBC6F: '속성 %0은 타입 %1의 필드에 대해 무시됨'
# '%0 attribute ignored on a non-definition declaration'
H208A7E24C5FA: '%0 속성이 정의되지 않은 선언에서 무시되었습니다.'
# '%0 attribute ignored on inline function'
H96102C6ED34D: '인라인 함수에 적용된 %0 속성이 무시되었습니다.'
# '%0 attribute ignored on local class%select{| member}1'
HFF01D57072C2: '%0 어트리뷰트가 로컬 class%select{| 멤버}1에 무시되었습니다.'
# '%0 attribute ignored when parsing type'
HD37333D19CA5: '%0 어트리뷰트는 타입 해석 중에 무시되었습니다.'
# '%0 attribute is deprecated and ignored in %1'
HEFE3D7F726A1: '%0 특성은 더 이상 사용되지 않으며 %1에서 무시됩니다'
# '%0 attribute is ignored because %1 is not a function pointer'
H4475E1120012: '%0 속성이 무시되었습니다. %1은 함수 포인터가 아니기 때문입니다.'
# '%0 attribute is ignored because there exists no call expression inside the statement'
H7E65A2DFE3B4: '%0 속성이 무시됩니다. 문장 내부에 호출 표현식이 존재하지 않기 때문입니다'
# '%0 attribute is ignored in non-aggregate type %1'
HDDFDF4BAA343: '%0 속성은 집합型이 아닌 형 %1에서 무시됩니다'
# '%0 attribute is invalid for the implicit this argument'
H2D89A7CAF8E9: '%0 속성은 암시적 this 인수에 대해 유효하지 않습니다'
# '%0 attribute is missing parameter label clause'
HD08320D115DE: '%0 특성에 매개변수 레이블 절이 누락되었습니다'
# '%0 attribute is not supported in %select{C|C++|Objective-C}1'
H40645DEA04DB: '속성 %0는 %select{C|C++|Objective-C}1에서 지원되지 않습니다'
# "%0 attribute is not supported on '%1'"
H46128D024C15: "%0 속성은 '%1'에 지원되지 않습니다"
# '%0 attribute is not supported on targets missing %1; specify an appropriate -march= or -mcpu='
H8B26915B3400: '%0 어트리뷰트는 %1이 없는 타겟에서 지원되지 않습니다; 적절한 -march= 또는 -mcpu=를 지정해 주세요'
# '%0 attribute is not yet supported on AIX'
H09BE0575B2ED: '%0 속성은 AIX에서 아직 지원되지 않습니다'
# '%0 attribute is only allowed on empty statements'
H523B4DCA9F57: '%0 attribute는 비어 있는 문에만 적용할 수 있습니다'
# '%0 attribute is permitted on definitions only'
H7BE8228ED388: '%0 특성은 정의에만 허용됩니다'
# "%0 attribute isn't implemented by this Objective-C runtime"
H4540FD7320B4: '이 Objective-C 런타임에서 %0 속성이 구현되지 않았습니다.'
# '%0 attribute may not be used with no-return-attribute functions'
H9936965C5605: '%0 속성은 no-return-attribute가 있는 함수와 함께 사용할 수 없습니다'
# '%0 attribute may not be used with variadic functions'
HC4348E6FE2CB: '%0 속성은 가변 인자 함수와 함께 사용할 수 없습니다'
# '%0 attribute minimum and maximum arguments are equal'
HCEAC369F8447: '%0 어트리뷰트의 최소와 최대 인수가 동일합니다'
# "%0 attribute must be applied to a %select{function|method}1 annotated with non-'none' attribute 'swift_async'"
H1EED532B31A7: "%0 속성은 non-'none' 속성 'swift_async'로 지정된 %select{함수|메소드}1에 적용해야 합니다"
# '%0 attribute must be greater than 0'
H2544E0569FB3: '%0 속성은 0보다 커야 합니다'
# '%0 attribute on %1 must be preceded by %2 attribute'
H0419F1FBA2F3: '%0 속성이 %1에 적용될 경우 반드시 %2 속성이 앞서야 합니다'
# '%0 attribute on entry function does not match the target profile'
H789CC95F4AD2: '%0 속성이 엔트리 함수의 타겟 프로파일과 일치하지 않습니다'
# '%0 attribute only applies to %select{Objective-C object|pointer|pointer-to-CF-pointer|pointer/reference-to-OSObject-pointer}1 parameters'
H5089073C0897: '%0 속성은 오직 %select{Objective-C 객체|포인터|CF 포인터 포인터|OSObject 포인터 포인터/참조}1 매개변수에만 적용됩니다'
# '%0 attribute only applies to %select{Objective-C object|pointer|pointer-to-CF-pointer}1 parameters'
HF1529765C253: '%0 속성은 다음 %select{Objective-C 객체|pointer|pointer-to-CF-pointer}1 매개변수에만 적용됩니다'
# '%0 attribute only applies to %select{functions|methods|properties}1 that return %select{an Objective-C object|a pointer|a non-retainable pointer}2'
H0AEFAD59CD2C: '%0 속성은 %select{함수|메서드|속성}1에서만 적용되며, %select{Objective-C 객체|포인터|non-retainable 포인터}2를 반환하는 경우에만 사용할 수 있습니다'
# '%0 attribute only applies to %select{pointer|integer}1 arguments'
H3971FB6B9374: '%0 attribute는 %select{pointer|integer}1 인수에만 적용될 수 있습니다'
# '%0 attribute only applies to a pointer or reference (%1 is invalid)'
HC8C4E00A6BE4: '%0 속성은 포인터 또는 참조 형식에만 적용됩니다 (%1은 유효하지 않습니다)'
# '%0 attribute only applies to return values that are pointers'
H83B4DE3C5663: '%0 속성은 포인터인 반환 값에만 적용됩니다'
# '%0 attribute only applies to return values that are pointers or references'
HA603B89762A9: '%0 속성은 오직 포인터 또는 참조자인 리턴 값에만 적용됩니다'
# '%0 attribute only applies to%select{| constant}1 pointer arguments'
H1E90BC4B3746: '속성 %0는 오직%select{ | 상수}1 포인터 인수에만 적용됩니다'
# '%0 attribute parameter %1 is negative and will be ignored'
HB94334A9F06D: '%0 속성 매개변수 %1은 음수이므로 무시됩니다'
# '%0 attribute parameter %1 is out of bounds'
H9C7D1C19F9DB: '%0 속성 매개변수 %1은 범위를 벗어났습니다'
# '%0 attribute parameter %1 is out of bounds: %plural{0:no parameters to index into|1:can only be 1, since there is one parameter|:must be between 1 and %2}2'
HF05125794562: '%0 속성 매개변수 %1이 유효 범위를 벗어났습니다: %plural{0:인덱싱할 매개변수가 없습니다|1:매개변수가 하나 있으므로 1만 가능합니다|:1과 %2 사이의 값이어야 합니다}2'
# '%0 attribute parameter types do not match: parameter %1 of function %2 has type %3, but parameter %4 of function %5 has type %6'
H4FBE5E81E84C: '%0 속성 매개변수 유형이 일치하지 않습니다: 함수 %2의 %1 번째 매개변수는 유형 %3을 가지지만, 함수 %5의 %4 번째 매개변수는 유형 %6을 가집니다'
# '%0 attribute parameters do not match the previous declaration'
HBB1E6D667EEA: '%0 속성 매개변수는 이전 선언과 일치하지 않습니다'
# '%0 attribute references function %1, which %plural{0:takes no arguments|1:takes one argument|:takes exactly %2 arguments}2'
HC6916839EF90: '%0 속성이 %1 함수를 참조합니다. 해당 함수는 %plural{0:인수가 없습니다|1:인수 하나를 받습니다|:정확히 %2개의 인수를 받습니다}2'
# '%0 attribute references parameter %1, but the function %2 has only %3 parameters'
H95C6EBBF3D05: '특성 %0는 매개변수 %1을 참조하지만, 함수 %2에는 %3개의 매개변수만 있습니다'
# '%0 attribute requires %select{int or bool|an integer constant|a string|an identifier}1'
H4D660FD4970F: '%0 속성은 %select{정수 또는 부울|정수 상수|문자열|식별자}1이 필요합니다'
# '%0 attribute requires a %select{positive|non-negative}1 integral compile time constant expression'
H88B2A4A1C6F1: '특성 %0는 %select{양수|음이 아닌}1 정수형 컴파일 타임 상수 표현식이 필요합니다'
# '%0 attribute requires an integer argument which is a constant power of two between %1 and %2 inclusive; provided argument was %3'
HBE3281153430: '%0 특성은 상수의 2의 제곱으로 %1과 %2 사이 (둘 다 포함)에 있는 정수 인수를 필요로 합니다; 제공된 인수는 %3입니다'
# "%0 attribute requires arguments whose type is annotated with 'capability' attribute; type here is %1"
H6A637254187D: "%0 속성은 'capability' 속성이 지정된 타입의 인수를 요구합니다; 현재 타입은 %1입니다"
# '%0 attribute requires integer constant between %1 and %2 inclusive'
HEAC447E72E0E: '%0 속성은 %1과 %2 사이의 정수 상수(포함)를 필요로 합니다'
# '%0 attribute requires parameter %1 to be %select{int or bool|an integer constant|a string|an identifier|a constant expression|a builtin function}2'
H410FC41452B2: '%0 특성은 매개변수 %1이(가) %select{int 또는 bool|정수 상수|문자열|식별자|상수 표현식|내장 함수}2여야 합니다'
# '%0 attribute requires that both caller and callee functions have a prototype'
H16EEA1808E57: '%0 속성은 호출자와 피호출 함수 모두가 프로토타입을 가져야 합니다'
# '%0 attribute requires that the return value is the result of a function call'
H374EE3F9FB1E: '%0 속성은 반환 값이 함수 호출의 결과여야 합니다'
# '%0 attribute takes at least %1 argument%s1'
HADEF6E200C29: '%0 어트리뷰트는 최소 %1 개의 인자를 필요로 합니다.'
# '%0 attribute takes no more than %1 argument%s1'
H19CAD7127F59: '%0 속성은 최대 %1 인수%s1 이상 허용되지 않습니다.'
# "%0 attribute with '%1' convention can only be applied to a %select{function|method}2 returning %select{an integral type|a pointer}3"
HD834E8E626F3: "%0 속성은 '%1' 규약과 함께 %select{함수|메소드}2가 %select{정수형|포인터}3을 반환할 때만 적용될 수 있습니다"
# "%0 attribute with '%1' convention must have an integral-typed parameter in completion handler at index %2, type here is %3"
HA510BC647385: "%0 속성은 '%1' 협약을 사용할 때 완료 핸들러의 인덱스 %2에서 정수형 매개변수가 있어야 합니다. 여기서의 타입은 %3입니다"
# "%0 attribute with 'nonnull_error' convention can only be applied to a %select{function|method}1 with a completion handler with an error parameter"
HB02ECE112485: "%0 속성과 'nonnull_error' 규칙은 %select{함수|메서드}1에만 적용할 수 있으며, 이는 에러 매개변수를 가진 완료 핸들러를 가져야 합니다"
# '%0 attribute without capability arguments can only be applied to non-static methods of a class'
H1A6503974C19: '%0 속성은 능력 인수 없이 클래스의 정적 메서드가 아닌 메서드에만 적용될 수 있습니다'
# "%0 attribute without capability arguments refers to 'this', but %1 isn't annotated with 'capability' or 'scoped_lockable' attribute"
H4FEFB6A31DD8: "%0 특성에 capability 인자가 없을 경우 'this'를 가리키지만, %1에는 'capability' 또는 'scoped_lockable' 특성이 지정되지 않았습니다"
# "%0 availability is ignored without a valid 'SDKSettings.json' in the SDK"
H44C1644AD110: "%0 사용 가능 여부는 SDK 내에서 유효한 'SDKSettings.json'이 없으면 무시됩니다."
# '%0 begins here'
H3AEE48765E33: '%0 여기서 시작됩니다'
# '%0 bridges to %1, not %2'
HF3302ECAA235: '%0는 %1과 연결되나, %2와는 연결되지 않습니다'
# "%0 byte order mark detected in '%1', but encoding is not supported"
H4406B8F3C975: "%0 바이트 순서 마크가 '%1'에서 발견되었습니다, 그러나 인코딩이 지원되지 않습니다"
# '%0 calling convention is not supported %select{for this target|on variadic function|on constructor/destructor|on builtin function}1'
HEDD5B64E1439: '%0 호출 규칙은 지원되지 않습니다 %select{이 타겟에서|가변 인자 함수에서|생성자/소멸자에서|내장 함수에서}1'
# '%0 can appear only once in a capture list'
H17CCB4C13684: '%0는 캡처 목록 내에서 한 번만 나타날 수 있습니다'
# "%0 cannot appear before '::' because it is not a class%select{ or namespace|, namespace, or enumeration}1; did you mean ':'?"
H95866D5EB8E3: "%0는 '::' 앞에 나타날 수 없습니다因为它 class%select{ 또는 namespace|, namespace, 또는 enumeration}1이 아니기 때문입니다; ':'를 의미하셨나요?"
# '%0 cannot appear here'
H7B57CA319863: '%0는 여기에 사용할 수 없습니다'
# '%0 cannot appear here, place it after "%select{class|struct|interface|union|enum}1" to apply it to the type declaration'
H2B1210C2EB9F: '%0는 여기서 나타날 수 없습니다. "%select{class|struct|interface|union|enum}1" 뒤에 배치하여 유형 선언에 적용하려면 그렇게 해 주세요.'
# '%0 cannot be a template'
H09B919FC579B: '%0는 템플릿으로 사용될 수 없습니다'
# '%0 cannot be applied to a module'
HED10CE4A1D68: '%0는 모듈에 적용될 수 없습니다'
# '%0 cannot be applied to a module import'
HE5DD1D7C816C: '%0은 모듈 임포트에 적용할 수 없습니다'
# '%0 cannot be captured because it does not have automatic storage duration'
HBA5ABB384993: '%0는 자동 저장 기간이 없기 때문에 포착할 수 없습니다'
# "%0 cannot be declared 'weak_import' because its definition has been provided"
HE0A69210AAA7: "%0는 정의가 제공되었기 때문에 'weak_import'로 선언할 수 없습니다"
# '%0 cannot be declared consteval'
H16F780D20CBE: '%0를 consteval로 선언할 수 없습니다'
# '%0 cannot be declared inside a namespace'
H52C308DDDEAD: '%0는 namespace 내부에서 선언될 수 없습니다'
# '%0 cannot be declared static in global scope'
HE95F0FB30315: '전역 범위에서 %0을 static으로 선언할 수 없습니다'
# '%0 cannot be defined in a condition'
H4D213A54365F: '%0는 조건식에서 정의될 수 없습니다'
# '%0 cannot be defined in a parameter type'
H73A9723882B3: '%0는 매개변수 유형에서 정의할 수 없습니다'
# '%0 cannot be defined in a type alias template'
H481A328DC270: '%0는 형식 별칭 템플릿 내에서 정의될 수 없습니다'
# '%0 cannot be defined in a type specifier'
H66CFEB606651: '%0는 유형 지정자에서 정의될 수 없습니다'
# '%0 cannot be defined in an enumeration'
H9015777D8EDA: '%0는 열거형 내에서 정의될 수 없습니다'
# '%0 cannot be defined in the result type of a function'
HBCF321DF1229: '%0는 함수의 결과 타입에서 정의될 수 없습니다'
# '%0 cannot be specialized%select{|: %2}1'
H2F24480223D6: '%0는 특수화할 수 없습니다%select{|: %2}1'
# '%0 cannot be the name of a parameter'
H86909FCB5AFA: '%0는 매개변수 이름으로 사용할 수 없습니다'
# '%0 cannot be the name of a variable or data member'
H97536A002E4D: '%0는 변수나 데이터 멤버의 이름으로 사용할 수 없습니다'
# '%0 cannot be used as the type of a kernel parameter'
H4649232301DD: '%0는 커널 매개변수의 유형으로 사용할 수 없습니다'
# '%0 cannot bridge to %1'
H223FE9046675: '인수 %0는 %1로 변환할 수 없습니다'
# '%0 cannot have a dependent return type; use %1 instead'
H622C863D5758: '%0는 반환 타입이 의존 타입일 수 없습니다; %1을 대신 사용하세요'
# "%0 cannot use 'super' because it is a root class"
HCB7FBC7D0FE7: "%0는 root 클래스이기 때문에 'super'를 사용할 수 없습니다"
# '%0 causes a section type conflict with %1'
HC2A4EF19BEEF: '%0는 %1과(와) 섹션 유형 충돌을 일으킵니다'
# '%0 clause previously used here'
HB8E770744C3C: '%0 절은 여기서 이전에 사용되었습니다'
# '%0 clause should not be followed by arguments; tokens will be ignored'
HC180595F601D: '%0 절 뒤에 인수가 오면 안 됩니다; 토큰은 무시됩니다'
# '%0 command failed due to signal (use -v to see invocation)'
H6D5905ABD1C8: '%0 명령어가 시그널로 인해 실패했습니다 (호출을 확인하려면 -v 옵션을 사용하세요)'
# '%0 command failed with exit code %1 (use -v to see invocation)'
H4949FF66B370: '명령어 "%0"이(가) 종료 코드 %1로 실패했습니다 (상세 정보를 보려면 -v 옵션을 사용하세요)'
# '%0 currently has no effect on a using declaration'
HF72F1D74D1D1: '%0는 현재 using declaration에 영향을 주지 않습니다'
# '%0 declared as a reference to a reference'
H6B7D1478B098: '%0는 참조의 참조로 선언되었습니다'
# '%0 declared here'
HF5B76F9106FA: '%0 여기에서 선언됨'
# '%0 defined here'
HAF9360C4877D: '%0 여기에서 정의됨'
# "%0 differs in precompiled file '%1' vs. current file"
HA74FA48CA1FC: "%0가(이) 사전 컴파일된 파일 '%1'과 현재 파일 간에 서로 다릅니다"
# '%0 dimension is outside the allowed range [1, %1]'
H082ED204EAD0: '차원 %0은 허용 범위 [1, %1]을 벗어났습니다.'
# '%0 does not have a member named %1'
H9A87A68C56D5: '%0에는 이름이 %1인 멤버가 없습니다'
# '%0 does not have a member named %1; did you mean %2?'
HB35AA56437F0: '%0에 %1이라는 멤버가 없습니다; %2를 의미하는 게 아니었나요?'
# '%0 does not identify a valid pointer authentication key for the current target'
H788DB99BF41E: '%0은 현재 타겟에 유효한 포인터 인증 키를 식별하지 못했습니다'
# '%0 does not name a template but is followed by template arguments'
H33B12988518D: '%0는 템플릿을 지칭하지 않지만 템플릿 인수가 있습니다'
# '%0 does not name a template but is followed by template arguments; did you mean %1?'
H4461F93F60D6: '%0은 템플릿 이름이 아니지만 템플릿 인수가 따라옵니다; %1을 의도한 것이었는지 확인하세요?'
# '%0 does not point into a class'
H54F4142F16BD: '%0는 클래스 내부를 가리키지 않습니다'
# '%0 does not refer to a type name in pseudo-destructor expression; expected the name of type %1'
H439E7BF75B12: '%0는 가짜 소멸자 표현식에서 타입 이름을 가리키지 않습니다; 타입 %1의 이름이 필요합니다'
# '%0 does not refer to a value'
H21D124F292F8: '%0는 값을 가리키지 않습니다'
# '%0 does not refer to the name of a parameter pack'
H84CFFC360255: '%0는 파라미터 팩의 이름을 가리키지 않습니다'
# '%0 does not refer to the name of a parameter pack; did you mean %1?'
H833E3DFEF469: '%0는 매개변수 팩의 이름을 참조하지 않습니다; %1 의 뜻이었나요?'
# "%0 does not support input file format of file '%1': '%select{Source|ModuleMap|Precompiled|Unknown}2'"
HBC389132B383: "%0은(는) 파일 '%1'의 입력 파일 형식 '%select{소스|모듈맵|사전 컴파일됨|알 수 없음}2'(을)를 지원하지 않습니다"
# "%0 does not support the '%1' %select{type qualifier|storage class specifier}2"
H0775C84F5711: "%0는 '%1' %select{형식 자격어|저장 클래스 지정자}2를 지원하지 않습니다"
# "%0 does not support the option '%1'"
HCC61DEFC8375: "%0는 '%1' 옵션을 지원하지 않습니다"
# '%0 evaluates to a null function pointer'
H8F92FCB5C04A: '%0는 null 함수 포인터로 평가됩니다'
# '%0 has C-linkage specified, but returns incomplete type %1 which could be incompatible with C'
H36CF04C5AD21: '%0는 C 린크지지를 지정했지만, C와 호환되지 않을 수 있는 미완결 형식 %1을 반환합니다'
# '%0 has C-linkage specified, but returns user-defined type %1 which is incompatible with C'
H33D15C91E278: '%0은 C 링크지정이 지정되었지만, C와 호환되지 않는 사용자 정의 형식 %1을 반환합니다'
# '%0 has a non-throwing exception specification but can still throw'
H115C08CCD253: '%0는 던지지 않는 예외 사양을 가지고 있지만 여전히 예외를 던질 수 있습니다'
# '%0 has been explicitly marked %select{unavailable|deleted|deprecated}1 here'
H8BC49D6916A0: '%0는 여기서 명시적으로 %select{사용 불가능|삭제됨|비추천}1로 표시되었습니다'
# '%0 has been marked as being introduced in %1 %2 %select{|in %5 environment }4here, but the deployment target is %1 %3%select{| %6 environment }4'
H0D47117119FF: '%0는 %1 %2 %select{|%5 환경에서 }4 여기에서 소개되었지만, 배포 대상은 %1 %3%select{| %6 환경 }4입니다'
# "%0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%select{no super class|super class with type %5}4|instance variable '%4' access control is %select{|@private|@protected|@public|@package}5}3"
H8AC2F2F00B17: "%0는 다른 모듈에서 서로 다른 정의를 가지고 있습니다; 첫 번째 차이는 %select{module '%2'에서 정의됨|여기서 정의됨}1에서 발견되었습니다 %select{%select{상위 클래스 없음|유형 %5의 상위 클래스}4|인스턴스 변수 '%4'의 접근 제어는 %select{없음|@private|@protected|@public|@package}5}3"
# '%0 has lower precedence than %1; %1 will be evaluated first'
HFFF20BD3A51A: '%0는 %1보다 우선 순위가 낮아 %1가 먼저 계산됩니다'
# '%0 has no out-of-line virtual method definitions; its vtable will be emitted in every translation unit'
HF80DD309C805: '%0에는 out-of-line 가상 메서드 정의가 없습니다; 해당 vtable은 모든 번역 단위에 생성됩니다'
# '%0 has unknown return type; cast the call to its declared return type'
H98622C79AEFA: '%0는 알 수 없는 반환 타입을 가지고 있습니다, 호출을 선언된 반환 타입으로 cast하세요'
# '%0 has unknown type, which is not supported for this kind of declaration'
H62292154D971: '%0은(는) 이 선언 유형에서 지원되지 않는 알 수 없는 형식을 가지고 있습니다'
# '%0 has unknown type; cast it to its declared type to use it'
HB47BA1F1A811: '%0는 알 수 없는 형식을 가집니다; 사용하려면 선언된 형식으로 캐스팅해야 합니다'
# '%0 has virtual functions but non-virtual destructor'
HE7971ACC4D33: '%0에는 가상 함수가 있지만 비가상 소멸자가 없습니다'
# '%0 in capture list does not name a variable'
HDBFB52EAD640: '%0 캡쳐 목록에서 변수를 지정하지 않았습니다'
# '%0 is a %select{struct|interface|union|class|enum}1 here'
H03376E721EF2: '%0는 여기서 %select{struct|interface|union|class|enum}1입니다'
# '%0 is a builtin with type %1'
HF5D497B12074: '%0는 %1 타입의 내장 항목입니다'
# '%0 is a core feature in %select{OpenCL C|C++ for OpenCL}1 version %2 but not supported on this target'
HB2B1D8E45B2F: '%0는 %select{OpenCL C|C++ for OpenCL}1 버전 %2의 핵심 기능이지만 이 타겟에서는 지원되지 않습니다'
# '%0 is a large (%1 bytes) pass-by-value argument; pass it by reference instead ?'
H3328D1D6C300: '인자 %0는 큰 값(%1 바이트)으로 전달됩니다; 대신 참조로 전달하시겠습니까?'
# '%0 is a reserved attribute identifier'
HA23BACAA2167: '%0는 예약된 속성 식별자입니다'
# '%0 is a reserved name for a module'
H539795173149: '%0는 모듈의 예약된 이름입니다'
# '%0 is an %select{unsafe pointer used for buffer access|unsafe buffer that does not perform bounds checks}1'
HD2DA3F5D5287: '%0는 %select{버퍼 액세스에 사용되는 안전하지 않은 포인터|경계 검사를 수행하지 않는 안전하지 않은 버퍼}1입니다'
# '%0 is an immediate %select{function|constructor}5 because %select{its body|the%select{| default}7 initializer of %8}6 %select{evaluates the address of %select{an immediate|a consteval}2 function %1|contains a call to %select{an immediate|a consteval}2 %select{function|constructor}4 %1 and that call is not a constant expression}3'
H2D11120EB0CD: '%0는 즉시 %select{함수|생성자}5입니다. 왜냐하면 %select{본문|the%select{| 기본}7 초기화자 of %8}6이 %select{%select{즉시|consteval}2 함수 %1의 주소를 평가합니다| %select{즉시|consteval}2 %select{함수|생성자}4 %1을 호출하고 그 호출이 상수 표현식이 아닙니다}3 때문입니다.'
# '%0 is an implicit parameter'
H18B31C3BE2ED: '%0는 암시적 매개변수입니다'
# '%0 is an incomplete type'
H23B2652D4493: '%0는 완전하지 않은 형식입니다'
# '%0 is an invalid name for a module'
H04BC4C58E825: '%0는 유효하지 않은 모듈 이름입니다'
# "%0 is currently enabled, but was not in the precompiled file '%1'"
H7E4FD8DFEFA0: "%0은(는) 현재 활성화되어 있지만 사전 컴파일된 파일 '%1'에는 없었습니다"
# '%0 is defined here; did you mean %1?'
H3B788FE6A551: '여기서 %0가 정의되었습니다; %1을(를) 의도하셨는지요?'
# '%0 is deprecated'
HFB3435CCEF09: '%0는 deprecated 됐습니다'
# '%0 is deprecated: %1'
HBBBFE1910250: '%0는 사용되지 않게 되었습니다: %1'
# '%0 is expected to be a non-type template, but instantiated to a %select{class|type alias}1 template'
H0D2CA33F6096: '%0는 비유형 템플릿이어야 하지만, %select{클래스|타입 별칭}1 템플릿으로 인스턴스화되었습니다'
# '%0 is incompatible with selectors that return a %select{struct|union|vector}1 type'
HF29FF6DC9511: '%0는 %select{struct|union|vector}1 형식을 반환하는 선택자와 호환되지 않습니다'
# '%0 is incomplete'
HE1EB0B2A5FDF: '%0는 완전하지 않습니다'
# "%0 is missing exception specification '%1'"
HFEFEB7B90D08: "%0에 예외 지정자 '%1'이 누락되었습니다"
# '%0 is no longer a pack expansion but a pack indexing type; add a name to specify a pack expansion'
H52ECBB1B9A17: '%0은 더 이상 팩 팽창이 아닌 팩 인덱싱 형식입니다; 팩 팽창을 지정하려면 이름을 추가하세요'
# '%0 is not %select{trivially relocatable|replaceable|trivially copyable|constructible with provided types}1'
H286C96520443: '%0은(는) %select{단순히 재배치 가능|대체 가능|단순히 복사 가능|제공된 타입으로 생성 가능}1하지 않습니다'
# '%0 is not a class type'
H5598919CD04A: '%0는 클래스 형식이 아닙니다'
# '%0 is not a class%select{ or namespace|, namespace, or enumeration}1'
H6791F56D81BD: '%0은 클래스%select{ 또는 네임스페이스|, 네임스페이스, 또는 열거형}1가 아닙니다'
# '%0 is not a direct base of %1, cannot inherit constructors'
H9090F9B02C3F: '%0는 %1의 직접적인 기반 클래스가 아니므로 생성자를 상속할 수 없습니다'
# '%0 is not a global variable, static local variable or static data member'
HC570BF566E38: '%0는 전역 변수, 정적 로컬 변수 또는 정적 데이터 멤버가 아닙니다'
# '%0 is not a global variable, static local variable or static data member; did you mean %1'
H32A3026BA924: '%0은 전역 변수, 정적 로컬 변수 또는 정적 데이터 멤버가 아닙니다; 의미하는 게 %1이었나요'
# '%0 is not a recognized builtin%select{|; consider including <intrin.h> to access non-builtin intrinsics}1'
HB8FF0E17F733: '%0은(는) 인식되지 않은 내장 함수입니다%select{|; <intrin.h>를 포함시켜 비빌트인 인트린식에 접근할 수 있습니다}1'
# '%0 is not a structural type because it has a %select{non-static data member|base class}1 of non-structural type %2'
HF393BE38CC50: '%0는 %select{정적 멤버가 아닌 데이터 멤버|기반 클래스}1이 구조적이 아닌 형식 %2를 가지고 있기 때문에 구조적 형식이 아닙니다'
# '%0 is not a structural type because it has a %select{non-static data member|base class}1 that is not public'
H7772D2C2337B: '%0은(는) 구조적 형식이 아닙니다.因为它의 %select{정적 멤버가 아닌 데이터 멤버|기반 클래스}1가 공개적이지 않습니다'
# '%0 is not a structural type because it has a mutable non-static data member'
HF8F430793986: '%0는 구조적 유형인 것이 아닙니다. 가변 비정적 데이터 멤버를 포함하기 때문입니다'
# '%0 is not a structural type because it has a non-static data member of rvalue reference type'
H3FC432618326: '%0는 구조적 형식이 아닙니다.因为它가 rvalue 참조 형식의 non-static 데이터 멤버를 가지고 있기 때문입니다'
# '%0 is not a valid SYCL kernel name type; a non-union class type is required'
H0BC00170201E: '%0는 유효한 SYCL 커널 이름 타입이 아닙니다; 유니온이 아닌 클래스 타입이 필요합니다'
# '%0 is not a valid literal type for NSNumber'
H994AF662B0D5: '%0은 NSNumber의 유효한 리터럴 형식이 아닙니다.'
# '%0 is not a valid property name (accessing an object of type %1)'
HA0D8AFF85380: '%0는 유효한 속성 이름이 아닙니다 (타입 %1의 객체에 접근 중)'
# "%0 is not an availability stage; use 'introduced', 'deprecated', or 'obsoleted'"
H5FED6488A0D9: "%0는 사용 가능 단계가 아닙니다; 'introduced', 'deprecated', 또는 'obsoleted'를 사용하십시오"
# '%0 is not an enumerated type'
H7F1BAB170C64: '%0는 열거형 타입이 아닙니다'
# '%0 is not defined, but forward declared here; conversion would be valid if it was derived from %1'
H176B6CEA9A74: '%0는 정의되지 않았지만 여기서 전방 선언되었습니다; %1로 파생되었다면 변환이 유효합니다'
# '%0 is not defined, evaluates to 0'
HBDB44DE505CF: '%0이 정의되지 않았습니다. 0으로 평가됩니다'
# '%0 is not literal because it has a non-trivial destructor'
HC9535B0A1692: '%0는 비기본 소멸자를 가지고 있기 때문에 리터럴이 아닙니다'
# '%0 is not literal because it has a user-provided destructor'
H35BFFB66B4EF: '%0는 리터럴이 아닙니다. 사용자 제공 소멸자가 있기 때문입니다'
# '%0 is not literal because it has base class %1 of non-literal type'
H41CFD9851FA8: '%0는 리터럴 형식이 아닙니다. 비리터럴 형식인 기반 클래스 %1를 가지고 있기 때문입니다'
# '%0 is not literal because it has data member %1 of %select{non-literal|volatile}3 type %2'
H39754ECC239F: '%0는 리터럴이 아닙니다.因为它具有数据成员 %1의 %select{비리터럴|볼래블}3 유형 %2를 가지기 때문입니다'
# '%0 is not literal because it is not an aggregate and has no constexpr constructors other than copy or move constructors'
HD7160BA9A570: '%0는 리터럴 형식이 아닙니다.因为它 집합체가 아니며, 복사 또는 이동 생성자 이외의 constexpr 생성자가 없기 때문입니다'
# '%0 is not literal because its destructor is not constexpr'
HEAC0F5C26B7E: '%0는 리터럴이 아닙니다. 그 소멸자가 constexpr가 아니기 때문입니다'
# '%0 is not polymorphic'
H67C71DB95F18: '%0는 다형적이지 않습니다'
# '%0 is not supported on HVX %1'
H7927AD732A30: '%0는 HVX %1에서 지원되지 않습니다'
# '%0 is not supported on this target'
H331CCFBB5DA0: '%0은(는) 이 타겟에서 지원하지 않습니다'
# '%0 is not supported with -fembed-bitcode'
H580226EF44DA: '%0는 -fembed-bitcode를 사용할 때 지원하지 않습니다'
# '%0 is not virtual and cannot be declared pure'
HFCE20933CC31: '%0은 가상적이지 않아서 순수로 선언할 수 없습니다'
# '%0 is only available %select{|in %4 environment }3on %1 %2 or newer'
H1926B8ADA9BD: '%0는 %select{ |%4 환경에서 }3 %1 %2 버전 이상에서만 사용 가능합니다'
# '%0 is only available for the SPIR-V target'
H92D6E58DBBBB: '%0은(는) 오직 SPIR-V 대상에 대해서만 사용할 수 있습니다'
# '%0 is only supported when \'-mrvv-vector-bits=<bits>\' is specified with a value of "zvl" or a power 2 in the range [64,65536]'
H714177E08C3D: '%0는 옵션 \'-mrvv-vector-bits=<bits>\'에 "zvl" 값이나 64부터 65536 사이의 2의 거듭제곱 수를 지정했을 때만 사용할 수 있습니다'
# "%0 is only supported when '-msve-vector-bits=<bits>' is specified with a value of 128, 256, 512, 1024 or 2048"
H5256E220BB0F: "%0는 '-msve-vector-bits=<bits>' 옵션이 128, 256, 512, 1024 또는 2048 값으로 지정되었을 때만 지원됩니다"
# "%0 is required to declare the member 'unhandled_exception()'"
H72F7248FC774: "%0는 멤버 'unhandled_exception()'을 선언하기 위해 필요합니다"
# "%0 is required to declare the member 'unhandled_exception()' when exceptions are enabled"
HA2F4C1A14DF7: "%0는 예외가 활성화되었을 때 멤버 'unhandled_exception()'을 선언해야 합니다"
# "%0 is required to have a non-throwing noexcept specification when the promise type declares 'get_return_object_on_allocation_failure()'"
H267685A6E8FC: "%0는 프로미스 형식이 'get_return_object_on_allocation_failure()'를 선언할 때 예외를 발생시키지 않는 noexcept 사양을 포함해야 합니다"
# '%0 is unavailable'
HD9DCE040D90B: '%0는 사용할 수 없습니다'
# '%0 is unavailable in ARC'
H5A0EF77D1311: '%0는 ARC에서 사용할 수 없습니다'
# '%0 is unavailable: %1'
H3F1A4B4C46AF: '%0는 사용할 수 없습니다: %1'
# '%0 is unsupported with LoongArch linker relaxation (-mrelax)'
H711EE6DE37A1: '%0는 LoongArch 링커 완화(-mrelax)와 호환되지 않습니다'
# '%0 is unsupported with RISC-V linker relaxation (-mrelax)'
H7184497D9FBD: '%0는 RISC-V 링커 완화(-mrelax)와 호환되지 않습니다'
# '%0 is used as a header guard here, followed by #define of a different macro'
HD1F7F8F6EEEE: '%0은 여기서 헤더 가드로 사용되었으며, 다른 매크로의 #define이 그 뒤에 오고 있습니다'
# "%0 layout not recognized. Must be a non-polymorphic class type with no bases and two fields: a 'const E *' and either another 'const E *' or a 'std::size_t'"
HED28B381356F: "%0 레이아웃이 인식되지 않았습니다. 비폴리모픽 클래스 형식이어야 하며, 기반 클래스가 없고 두 개의 필드를 가져야 합니다: 'const E *'와 다른 'const E *' 또는 'std::size_t'"
# '%0 macro redefined'
H137240D8643E: '매크로 %0가 재정의되었습니다.'
# "%0 managed by '%1' is '%3' instead of '%2'"
H2BF1BAAD2D9C: "“%0”은(는) '%1'에 의해 '%3'으로 지정되었으나 '%2'여야 합니다"
# "%0 marked 'override' but does not override any member functions"
H4E355023D40F: "%0는 'override'로 표시되었지만 오버라이드할 멤버 함수가 없습니다"
# '%0 may be deprecated because the receiver type is unknown'
H33FCAE6FB142: '%0는 수신자 타입이 알려지지 않았기 때문에 비추천되거나 삭제될 수 있습니다'
# '%0 may be duplicated when built into a shared library: it is mutable, has hidden visibility, and external linkage'
H5AAA1A09F587: '%0는 공유 라이브러리로 빌드될 때 중복될 수 있습니다: mutable이며, 숨겨진 가시성을 가지고 있고 외부 링크지정을 가집니다'
# '%0 may be unavailable because the receiver type is unknown'
H5F639AF749BC: '%0는 리시버 유형이 알 수 없어 사용할 수 없을 수 있습니다'
# '%0 may not be nested in a struct due to flexible array member'
H56A636FEC1E0: '%0는 유연한 배열 멤버 때문에 struct 내에서 중첩될 수 없습니다'
# '%0 may not be used as an array element due to flexible array member'
H4CE3DAD3A8F2: '%0는 유연한 배열 멤버 때문에 배열 요소로 사용할 수 없습니다'
# '%0 may not intend to support class template argument deduction'
H3F1AA6022CE0: '%0는 클래스 템플릿 인자 추론을 지원하지 않을 수 있습니다'
# '%0 may not respond to %1'
HE863B7C4E09E: '%0는 %1에 응답하지 않을 수 있습니다'
# '%0 must be explicitly converted to %1; use %select{%objcclass2|%objcinstance2}3 method for this conversion'
H7B5D141884DB: '%0는 명시적으로 %1로 변환되어야 합니다; 이 변환을 위해 %select{%objcclass2|%objcinstance2}3 메서드를 사용하십시오'
# '%0 must be name of an Objective-C class to be able to convert %1 to %2'
HF9706A398326: '%0는 Objective-C 클래스 이름이어야 %1을 %2로 변환할 수 있습니다'
# '%0 must be specified on definition if it is specified on any declaration'
H593384CDC4FD: '%0는 어떠한 선언에서도 지정된 경우, 정의 시에도 반드시 지정되어야 합니다'
# '%0 must be used within a preprocessing directive'
HAA08D126AF16: '%0는 프리프로세서 지시문 내에서 사용되어야 합니다'
# "%0 must not appear in both clauses 'to' and 'link'"
HC3403F617C92: "%0는 'to'와 'link' 두 절 모두에서 등장해서는 안 됩니다."
# '%0 must return type %1'
H561F31EBFB23: '%0의 반환 타입은 %1이어야 합니다'
# '%0 needs target feature %1'
H5236119E54CB: '%0는 타겟 특성 %1이 필요합니다'
# '%0 needs to be instantiated from a class template with proper template arguments'
H6CDDF6DD374E: '%0는 올바른 템플릿 인수를 가진 클래스 템플릿에서 인스턴스화되어야 합니다'
# '%0 needs to have exactly %1 template parameters'
HD0C675913338: '%0는 정확히 %1개의 템플릿 매개변수를 가져야 합니다'
# '%0 only allowed in __except block or filter expression'
H5D665A901228: '%0는 __except 블록이나 필터 표현식에서만 허용됩니다'
# '%0 only allowed in __except filter expression'
H6152837B25ED: '%0은 __except 필터 표현식에서만 허용됩니다'
# '%0 only allowed in __finally block'
H4B415A24C89A: '%0는 __finally 블록에서만 허용됩니다'
# '%0 only applies to pointer types; type here is %1'
HAB4FE8662D8D: '%0는 포인터 유형에만 적용됩니다; 현재 유형은 %1입니다'
# "%0 overrides a destructor but is not marked 'override'"
HEE01F5122D86: "%0는 소멸자를 재정의했지만 'override'로 표시하지 않았습니다."
# "%0 overrides a member function but is not marked 'override'"
H7449F9821D96: "%0는 멤버 함수를 재정의하지만 'override'로 표시되지 않았습니다"
# "%0 parameter marked 'called_once' is called twice"
H9B0F1F204498: "%0 매개변수에 'called_once'가 표시되었지만 두 번 호출되었습니다"
# "%0 parameter marked 'called_once' is never %select{used|called}1 when %select{taking true branch|taking false branch|handling this case|none of the cases applies|entering the loop|skipping the loop|taking one of the branches}2"
HBB87206669E4: "'called_once'로 표시된 %0 매개변수는 %select{사용되지|호출되지}1 %select{true 분기 시|false 분기 시|이 경우 처리 시|이 경우 모두 해당하지 않음|루프 진입 시|루프 건너뛰기 시|분기 중 하나를 선택 시}2"
# "%0 redeclared with '%1' access"
H6D05457F8E04: "%0가 '%1' 접근성으로 재선언되었습니다"
# '%0 released here'
H2E4FF4BE13D1: '%0 여기에서 해제됨'
# "%0 requires %1 type support, but ABI '%2' does not support it"
H03B0999A3C3B: "%0는 %1 형식 지원이 필요하지만, ABI '%2'는 이를 지원하지 않습니다"
# "%0 requires %select{|%2 bit size}1 %3 %select{|return }4type support, but target '%5' does not support it"
HE937C1210F37: "%0는 %select{|%2 비트 크기}1 %3 %select{|리턴 }4type 지원을 필요로 하지만, 대상 '%5'는 이를 지원하지 않습니다"
# '%0 requires HVX, use -mhvx/-mhvx= to enable it'
H9F7369C63134: '%0는 HVX가 필요합니다. 활성화하려면 -mhvx/-mhvx= 옵션을 사용하십시오'
# "%0 requires debug info. Use %1 or debug options that enable debugger's stepping function; option ignored"
H985F4F582A8C: '%0는 디버그 정보가 필요합니다. %1 또는 디버거의 스텝 기능을 활성화하는 디버그 옵션을 사용하세요; 옵션 무시됨'
# '%0 requires more than 1 template argument; provide the remaining arguments explicitly to use it here'
H33A930D763B0: '%0는 1보다 많은 템플릿 인수가 필요합니다; 여기서 사용하려면 나머지 인수들을 명시적으로 제공해야 합니다'
# '%0 returns a reference'
H81B0F21DCC91: '%0 참조를 반환합니다'
# '%0 should be declared prior to the call site%select{| or in %2| or in an associated namespace of one of its arguments}1'
H80A1DB32BBA2: '%0는 호출 지점 이전에 선언되어야 합니다%select{| 또는 %2 내에서| 또는 인자 중 하나와 연관된 네임스페이스 내에서}1'
# "%0 should not return a null pointer unless it is declared 'throw()'%select{| or 'noexcept'}1"
HD6330A6C968B: "'throw()'%select{| 또는 'noexcept'}1로 선언되지 않았다면 %0는 null 포인터를 반환해서는 안 됩니다"
# '%0 size too large'
HC155B92BBDDE: '%0 크기가 너무 큽니다'
# '%0 specified here'
H2793186BA8E0: '%0가 여기서 지정되었습니다'
# '%0 template must have at least two parameters'
HC33714C2985B: '%0 템플릿은 최소 두 개의 매개변수가 필요합니다'
# '%0 type %1 not found; include the base header with -finclude-default-header'
HB4775AA2AD70: '%0 유형 %1이 발견되지 않았습니다; -finclude-default-header 옵션을 사용하여 기본 헤더를 포함하십시오'
# '%0 type was not found; include <coroutine> before defining a coroutine'
H89DE99125E80: '%0 타입이 발견되지 않았습니다; 코루틴을 정의하기 전에 <coroutine>을 포함시켜야 합니다'
# '%0 used as the name of the previous parameter rather than as part of the selector'
HAA86630AF908: '%0가 이전 매개변수의 이름으로 사용되었으나, 선택기의 일부로 사용되는 것은 아닙니다'
# '%0 used in array declarator outside of function prototype'
H667299EFB745: '%0가 함수 프로토타입 외부의 배열 선언자에서 사용되었습니다'
# '%0 used in declare target directive is not a variable or a function name'
H56AD7716F4DF: '%0는 declare target 지시문에서 사용되었지만 변수나 함수 이름이 아닙니다'
# '%0 used in non-outermost array type derivation'
H7D46A3E1139D: '%0이 최상위가 아닌 배열 형식 유도에서 사용되었습니다'
# '%0 variable cannot be %1'
H88684475A953: '%0 변수는 %1이 될 수 없습니다.'
# "%0 variable cannot be in a %1 clause in '#pragma omp %2' directive"
HF56ADE356ADE: "%0 변수는 '#pragma omp %2' 지시문의 %1 절 내에 사용할 수 없습니다"
# '%0 variable must be %1'
H2457271DFCB0: '%0 변수는 %1이어야 합니다'
# "%0 was %select{disabled|enabled}1 in precompiled file '%3' but is currently %select{disabled|enabled}2"
H4CAD7163A1ED: "%0은(는) 사전 컴파일된 파일 '%3'에서 %select{비활성화됨|활성화됨}1되었지만 현재는 %select{비활성화됨|활성화됨}2입니다"
# '%0 was deserialized'
H39D399F5AEF8: '%0는 역직렬화되었습니다'
# '%0 was marked unused but was used'
H40B831F8FB51: '%0는 사용되지 않음으로 표시되었지만 사용되었습니다'
# '%0 will return the size of the pointer, not the array itself'
H8CFDDD42E21F: '%0는 포인터의 크기를 반환할 것입니다. 배열 자체의 크기는 아닙니다'
# '%0%select{ attribute|}1 cannot be applied to a base specifier'
H11035A3B905C: '%0%select{ 속성|}1은 기본 지정자에 적용될 수 없습니다'
# '%0%select{ attribute|}1 cannot be applied to a declaration'
H127063747A92: '%0%select{ 속성|}1을 선언에 적용할 수 없습니다'
# '%0%select{ attribute|}1 cannot be applied to a statement'
H1C3F2544F25A: '%0%select{ attribute|}1은(는) 문자열에 적용할 수 없습니다'
# '%0%select{ attribute|}1 cannot be applied to types'
H96D80DF95948: '%0%select{ attribute|}1 적용할 수 없는 타입입니다'
# '%0%select{ attribute|}1 only applies to %2'
H45C12381C633: '%0%select{ 특성|}1는 %2에만 적용됩니다.'
# '%0%select{ attribute|}1 only applies to %select{functions|unions|variables and functions|functions and methods|functions, methods and blocks|functions, methods, and parameters|variables|variables and fields|variables, data members and tag types|types and namespaces|variables, functions and classes|kernel functions|non-K&R-style functions|for loop statements|virtual functions|parameters and implicit object parameters|non-member functions|functions, classes, or enumerations|classes|typedefs}2'
H9D37840D3CB2: '%0%select{ 속성|}1은 %select{함수|유니온|변수 및 함수|함수와 메소드|함수, 메소드 및 블록|함수, 메소드, 매개변수|변수|변수 및 필드|변수, 데이터 멤버 및 태그 유형|유형 및 네임스페이스|변수, 함수 및 클래스|커널 함수|K&R 스타일이 아닌 함수|for 루프 문|가상 함수|매개변수 및 암시적 객체 매개변수|멤버가 아닌 함수|함수, 클래스 또는 열거형|클래스|typedef}2에만 적용됩니다'
# '%0%select{ attribute|}1 only applies to fields or variables of character array type; type is %2'
H0DF527EADF11: '%0%select{ 속성|}1은(는) 문자 배열 타입의 필드 또는 변수에만 적용됩니다. 타입은 %2입니다'
# "%0%select{| following the 'template' keyword}1 cannot refer to a dependent template"
HA18DA36B7236: '%0%select{| 템플릿 키워드 뒤에 오는}1은 의존적 템플릿을 참조할 수 없습니다'
# "%0%select{| following the 'template' keyword}1 does not refer to a template"
HCADF8F759262: "%0%select{| 'template' 키워드 뒤에 오는 }1 템플릿을 가리키지 않습니다"
# "%0: '%1' input unused in cpp mode"
HF14789F9D841: "%0: '%1' 입력이 C++ 모드에서 사용되지 않았습니다."
# "%0: '%1' input unused%select{ when '%3' is present|}2"
HA6B5E8785AC8: "%0: '%1' 입력이 사용되지 않음%select{ '%3'가 존재할 때|}2"
# "%0: 'get_return_object_on_allocation_failure()' must be a static member function"
HB26892211ABD: "%0: 'get_return_object_on_allocation_failure()'는 정적 멤버 함수여야 합니다"
# "%0: previously preprocessed input%select{ unused when '%2' is present|}1"
H1EB52EB9DA3B: '%0: 이전에 전처리된 입력%select{ %2가 존재할 때 사용되지 않음|}1'
# "%0; allow reordering by specifying '#pragma clang loop vectorize(enable)' before the loop or by providing the compiler option '-ffast-math'"
H50F1AE498158: "%0; 재정렬을 허용하려면 루프 전에 '#pragma clang loop vectorize(enable)'를 지정하거나 '-ffast-math' 컴파일러 옵션을 제공할 수 있습니다"
# "%0; allow reordering by specifying '#pragma clang loop vectorize(enable)' before the loop; if the arrays will always be independent, specify '#pragma clang loop vectorize(assume_safety)' before the loop or provide the '__restrict__' qualifier with the independent array arguments -- erroneous results will occur if these options are incorrectly applied"
H696063533F0E: "%0; '#pragma clang loop vectorize(enable)'를 루프 전에 지정하여 재정렬을 허용할 수 있습니다; 배열이 항상 독립적이면 '#pragma clang loop vectorize(assume_safety)'를 루프 전에 지정하거나 독립적인 배열 인수에 '__restrict__' 자격 증명을 제공하세요 -- 이러한 옵션을 잘못 적용하면 오류 결과가 발생합니다"
# '%0B (%human0B) in local locations, %1B (%human1B) in locations loaded from AST files, for a total of %2B (%human2B) (%3%% of available space)'
H9B3C5907D274: '%0B (%human0B) 로컬 위치에서, %1B (%human1B) AST 파일에서 로드된 위치에서, 총 %2B (%human2B) (사용 가능 공간의 %3%%)'
# '%0{storage class} argument for SPIR-V builtin is not a 32-bits integer'
H519A82184DBD: 'SPIR-V 내장 함수의 %0{저장 클래스} 인수가 32비트 정수가 아닙니다'
# '%1 %0 is hidden by a non-type declaration of %0 here'
HC05432050C69: '%1 %0는 여기서 %0의 비형식 선언에 의해 숨겨졌습니다'
# '%1 is a %select{private|protected}0 member of %3'
H4162E2E8D4C1: '%1은 %3의 %select{비공개|보호된}0 멤버입니다'
# '%2 defined as %select{a struct|an interface|a class}0%select{| template}1 here but previously declared as %select{a struct|an interface|a class}3%select{| template}1; this is valid, but may result in linker errors under the Microsoft C++ ABI'
H65DDB76661CA: '%2가 %select{구조체|인터페이스|클래스}0%select{| 템플릿}1로 여기서 정의되었지만 이전에 %select{구조체|인터페이스|클래스}3%select{| 템플릿}1로 선언되었습니다; 이 것은 유효하지만 Microsoft C++ ABI에서 링커 오류가 발생할 수 있습니다'
# '%diff{$ and $ are not pointers to compatible types|pointers to incompatible types}0,1'
HE4DF3395C0FE: '%diff{$와 $는 호환 가능한 타입의 포인터가 아닙니다|호환되지 않는 타입의 포인터}0,1'
# '%diff{promoted type $ of K&R function parameter is not compatible with the parameter type $|promoted type of K&R function parameter is not compatible with parameter type}0,1 declared in a previous prototype'
HBE91EA4F0CCD: '%diff{K&R 함수 매개변수의 승격된 형식 $는 매개변수 형식 $와 호환되지 않습니다.|K&R 함수 매개변수의 승격된 형식은 매개변수 형식과 호환되지 않습니다.}0,1 이전 프로토타입에서 선언되었습니다.'
# '%diff{return type $ must match previous return type $|return type must match previous return type}0,1 when %select{block literal|lambda expression}2 has unspecified explicit return type'
H503B0717AF47: '%diff{리턴 타입 $는 이전 리턴 타입 $와 일치해야 합니다.|리턴 타입은 이전 리턴 타입과 일치해야 합니다.}0,1 when %select{블록 리터럴|람다 표현식}2에 명시적 리턴 타입이 지정되지 않았습니다'
# "%ordinal0 argument must be a %select{|scalar|vector|matrix|vector of|scalar or vector of}1%plural{[2,3]:%plural{0:|:%plural{0:|:,}2}3|:}1%plural{0:|: }1%select{|integer|signed integer|unsigned integer|'int'|pointer to a valid matrix element}2%plural{0:|: }2%plural{0:|:%plural{0:|:or }2}3%select{|floating-point|16 or 32 bit floating-point}3%plural{0:|: }3%plural{[0,3]:type|:types}1 (was %4)"
HAE59C0ED31CA: "%ordinal0 인수는 %select{|스칼라|벡터|행렬|벡터형|스칼라 또는 벡터형}1%plural{[2,3]:%plural{0:|:%plural{0:|:,}2}3|:}1%plural{0:|: }1%select{|정수|부호 있는 정수|부호 없는 정수|'int'|유효한 행렬 요소 포인터}2%plural{0:|: }2%plural{0:|:%plural{0:|:또는 }2}3%select{|부동소수점|16 또는 32비트 부동소수점}3%plural{0:|: }3%plural{[0,3]:타입|:타입들}1이어야 합니다 (현재: %4)"
# '%ordinal0 argument must be a WebAssembly table'
HF0E3AF42C5DD: '%ordinal0 번째 인수는 WebAssembly 테이블이어야 합니다'
# '%ordinal0 argument must be an externref'
H80DC046B6BA1: '%ordinal0 인수는 externref여야 합니다'
# '%ordinal0 argument must be an integer'
HB74677AB0CCF: '%ordinal0 인수는 정수여야 합니다'
# '%ordinal0 argument must match the element type of the WebAssembly table in the %ordinal1 argument'
HCC6BF06B970F: '%ordinal0번째 인수는 %ordinal1번째 인수의 WebAssembly 테이블의 요소 유형과 일치해야 합니다'
# '%ordinal3 parameter of%select{| type aware}0%select{| destroying}1 %2 must have type %4'
H2E6F520064CE: '%select{|type aware}0 %select{|destorying}1 %2의 %ordinal3 매개변수는 %4 형식이어야 합니다'
# '%plural{1:enumeration value %1 not explicitly handled in switch|2:enumeration values %1 and %2 not explicitly handled in switch|3:enumeration values %1, %2, and %3 not explicitly handled in switch|:%0 enumeration values not explicitly handled in switch: %1, %2, %3...}0'
HE8DAC9A52D87: '%plural{1:열거형 값 %1이 switch문에서 명시적으로 처리되지 않았습니다|2:열거형 값 %1 및 %2가 switch문에서 명시적으로 처리되지 않았습니다|3:열거형 값 %1, %2, 및 %3이 switch문에서 명시적으로 처리되지 않았습니다|:%0 열거형 값이 switch문에서 명시적으로 처리되지 않았습니다: %1, %2, %3...}0'
# '%plural{1:enumeration value %1 not handled in switch|2:enumeration values %1 and %2 not handled in switch|3:enumeration values %1, %2, and %3 not handled in switch|:%0 enumeration values not handled in switch: %1, %2, %3...}0'
H0E3F79F6C010: '%plural{1:열거형 값 %1이 switch에서 처리되지 않았습니다.|2:열거형 값 %1과 %2가 switch에서 처리되지 않았습니다.|3:열거형 값 %1, %2, 그리고 %3가 switch에서 처리되지 않았습니다.|:%0개의 열거형 값이 switch에서 처리되지 않았습니다: %1, %2, %3...}0'
# "%plural{2:'delete' used to delete pointer to object allocated with 'std::allocator<...>::allocate'|:%select{non-array delete|array delete|'std::allocator<...>::deallocate'}0 used to delete pointer to %select{array object of type %2|non-array object of type %2|object allocated with 'new'}0}1"
H1294E54BD6EF: "%plural{2:'delete'를 'std::allocator<...>::allocate'로 할당된 객체 포인터에 사용함 | %select{비배열 delete|배열 delete|'std::allocator<...>::deallocate'를 사용}0를 %select{타입 %2의 배열 객체|타입 %2의 비배열 객체|'new'로 할당된 객체}0에 포인터를 삭제하는데 사용함}1"
# '%plural{[0,2]:must use a qualified name when declaring|3:cannot declare}0 a %select{constructor|destructor|conversion operator|deduction guide}0 as a friend'
H180E877A4B1E: '%plural{[0,2]:선언할 때는 격자 이름을 사용해야 합니다|3:선언할 수 없습니다}0 %select{constructor|destructor|conversion operator|deduction guide}0을 친구로'
# "%q0 %select{with definition in module '%2'|defined here}1 has different definitions in different modules; first difference is this %select{||||static assert|field|method|type alias|typedef|data member|friend declaration|function template|method|instance variable|property|unexpected decl}3"
HC2ECA20D4E80: "%q0 %select{모듈 '%2'에서 정의됨|여기서 정의됨}1은 다른 모듈에서 서로 다른 정의를 가지고 있습니다; 첫 번째 차이는 이 %select{||||static assert|필드|메소드|유형 별칭|typedef|데이터 멤버|프렌드 선언|함수 템플릿|메소드|인스턴스 변수|프로퍼티|예상치 못한 선언}3에서 발생했습니다"
# '%q0 cannot be thread local when declared %q1'
H1F0205F4AD29: '%q0는 %q1로 선언될 때 스레드 로컬일 수 없습니다'
# "%q0 from module '%1' is not present in definition of %q2%select{ in module '%4'| provided earlier}3"
H9DF776E318FF: "%q0는 모듈 '%1'에서 %q2의 정의에 존재하지 않습니다%select{ 모듈 '%4'에서| 이전에 제공된}3"
# "%q0 has different definitions in different modules; %select{definition in module '%2' is here|defined here}1"
HB3D6EB7685C3: "%q0는 다른 모듈에서 서로 다른 정의가 있습니다; %select{모듈 '%2'에서의 정의는 여기에 있습니다|여기에서 정의되었습니다}1"
# "%q0 has different definitions in different modules; %select{definition in module '%2'|defined here}1 first difference is %select{enum that is %select{not scoped|scoped}4|enum scoped with keyword %select{struct|class}4|enum %select{without|with}4 specified type|enum with specified type %4|enum with %4 element%s4|%ordinal4 element has name %5|%ordinal4 element %5 %select{has|does not have}6 an initializer|%ordinal4 element %5 has an initializer|}3"
H39CEC8B6DBEB: "%q0는 다른 모듈에서 서로 다른 정의를 가집니다; %select{모듈 '%2'의 정의|여기서 정의됨}1 첫 번째 차이는 %select{범주가 %select{scoped가 아님|scoped임}|scoped 키워드 %select{struct|class}4와 함께 있는 범주|범주 %select{지정된 유형 없음|지정된 유형과 함께}|범주와 지정된 유형 %4|범주와 %4 요소%s4|%ordinal4 번째 요소의 이름이 %5|%ordinal4 번째 요소 %5 %select{초기화 값이 있음|초기화 값이 없음}|%ordinal4 번째 요소 %5가 초기화 값이 있음|}3"
# "%q0 has different definitions in different modules; %select{definition in module '%2'|defined here}1 first difference is %select{return type is %4|%ordinal4 parameter with name %5|%ordinal4 parameter with type %5%select{| decayed from %7}6|%ordinal4 parameter with%select{out|}5 a default argument|%ordinal4 parameter with a default argument|function body}3"
H68AA8A549FAA: "%q0은 다른 모듈에서 서로 다른 정의를 가지고 있습니다; %select{모듈 '%2'에서의 정의|여기서 정의됨}1 첫 번째 차이는 %select{리턴 유형이 %4|%ordinal4 매개변수 이름 %5|%ordinal4 매개변수 유형 %5%select{| %7에서 변환됨}6|%ordinal4 매개변수에 %select{out|}5 기본 인자가 있음|%ordinal4 매개변수에 기본 인자가 있음|함수 본문}3입니다"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%4 base %plural{1:class|:classes}4|%4 virtual base %plural{1:class|:classes}4|%ordinal4 base class with type %5|%ordinal4 %select{non-virtual|virtual}5 base class %6|%ordinal4 base class %5 with %select{public|protected|private|no}6 access specifier}3"
HC4303FABC437: "%q0의 정의가 다른 모듈에서 서로 다릅니다; 첫 번째 차이는 %select{모듈 '%2'의 정의|여기에서 정의됨}1에서 %select{%4 기본 %plural{1:클래스|:클래스들}4|%4 가상 기본 %plural{1:클래스|:클래스들}4|%ordinal4 번째 기본 클래스 형식 %5|%ordinal4 %select{비가상|가상}5 기본 클래스 %6|%ordinal4 번째 기본 클래스 %5와 %select{공개|보호|비공개|없음}6 접근 지정자}3을 발견했습니다"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%4 referenced %plural{1:protocol|:protocols}4|%ordinal4 referenced protocol with name %5}3"
HC9695A16C965: "%q0는 다른 모듈에서 서로 다른 정의를 가집니다; 첫 번째 차이는 %select{모듈 '%2'에 정의됨|여기서 정의됨}1에서 %select{%4 %plural{1:프로토콜|:프로토콜}4 참조됨|%ordinal4 번째 %5 이름을 가진 프로토콜 참조됨}3를 찾았습니다"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%select{method %5|constructor|destructor}4 that has %6 parameter%s6|%select{method %5|constructor|destructor}4 with %ordinal6 parameter of type %7%select{| decayed from %9}8|%select{method %5|constructor|destructor}4 with %ordinal6 parameter named %7}3"
HA17814A91726: "%q0은 다른 모듈에서 서로 다른 정의를 가지고 있습니다; 첫 번째 차이는 %select{모듈 '%2'에서의 정의|여기서 정의됨}1 %select{%select{메소드 %5|생성자|소멸자}4가 %6 매개변수%s6|%select{메소드 %5|생성자|소멸자}4의 %ordinal6 매개변수 유형 %7%select{| %9에서 변환됨}8|%select{메소드 %5|생성자|소멸자}4의 %ordinal6 매개변수 이름 %7}3이 발생했습니다"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%select{typedef|type alias}4 name %5|%select{typedef|type alias}4 %5 with underlying type %6}3"
H290AB6198D53: "%q0은 다른 모듈에서 서로 다른 정의를 가지고 있습니다; 첫 번째 차이는 %select{모듈 '%2'에서의 정의|여기서 정의됨}1 %select{%select{typedef|type alias}4 이름 %5|%select{typedef|type alias}4 %5의 밑바닥 유형 %6}3이 발생했습니다"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{data member with name %4|data member %4 with type %5|data member %4 with%select{out|}5 an initializer|data member %4 with an initializer|data member %4 %select{is constexpr|is not constexpr}5}3"
H3C6A067820A4: "%q0은 다른 모듈에서 서로 다른 정의를 가지고 있습니다; 첫 번째 차이는 %select{모듈 '%2'에서의 정의|여기서 정의됨}1 %select{데이터 멤버 이름 %4|데이터 멤버 %4 유형 %5|데이터 멤버 %4 %select{out|}5 초기화됨|데이터 멤버 %4 초기화됨|데이터 멤버 %4 %select{constexpr 아님|constexpr}5}3이 발생했습니다"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{end of class|public access specifier|private access specifier|protected access specifier|static assert|field|method|type alias|typedef|data member|friend declaration|function template|method|instance variable|property}3"
HC7FCD2470FA2: "%q0는 다른 모듈에서 서로 다른 정의를 가지고 있습니다; 첫 번째 차이는 %select{모듈 '%2'의 정의|여기서 정의되었습니다}1에서 %select{클래스 끝|공개 접근 지정자|비공개 접근 지정자|보호된 접근 지정자|정적 암시|필드|메서드|유형 별칭|typedef|데이터 멤버|프렌드 선언|함수 템플릿|메서드|인스턴스 변수|속성}3를 발견했습니다"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{field %4|field %4 with type %5|%select{non-|}5bit-field %4|bit-field %4 with one width expression|%select{non-|}5mutable field %4|field %4 with %select{no|an}5 initializer|field %4 with an initializer}3"
H60D85DC0E685: "%q0은 다른 모듈에서 서로 다른 정의를 가지고 있습니다; 첫 번째 차이는 %select{모듈 '%2'에서의 정의|여기서 정의됨}1 %select{필드 %4|필드 %4 유형 %5|%select{비-|}5비트 필드 %4|%4의 비트 필드 너비 표현식 1개|%select{비-|}5mutable 필드 %4|필드 %4 %select{초기화 없음|초기화 있음}5|필드 %4 초기화됨}3이 발생했습니다"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{method %4 with return type %5|%select{class|instance}5 method %4|%select{no|'required'|'optional'}4 method control|method %4 with %select{no designated initializer|designated initializer}5|%select{regular|direct}5 method %4|method %4}3"
H5AECB1226BDE: "%q0는 다른 모듈에서 서로 다른 정의가 있습니다; 첫 번째 차이는 %select{모듈 '%2'의 정의|여기서 정의됨}1에서 %select{리턴 타입 %5인 메서드 %4|%select{class|instance}5 메서드 %4|%select{no|'required'|'optional'}4 메서드 컨트롤|메서드 %4에 %select{no designated initializer|designated initializer}5|%select{regular|direct}5 메서드 %4|메서드 %4}3을 발견했습니다"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{property %4|property %4 with type %5|%select{no|'required'|'optional'}4 property control|property %4 with %select{default |}6'%select{none|readonly|getter|assign|readwrite|retain|copy|nonatomic|setter|atomic|weak|strong|unsafe_unretained|nullability|null_resettable|class|direct}5' attribute}3"
H47E62251068F: "%q0는 다른 모듈에서 서로 다른 정의를 가집니다; 첫 번째 차이는 %select{module '%2'의 정의|여기서 정의됨}1에서 %select{%4 속성|%4 속성과 %5 형식|%select{없음|'필수'|'옵셔널'}4 속성 제어|%4 속성과 %select{기본 |}6'%select{none|readonly|getter|assign|readwrite|retain|copy|nonatomic|setter|atomic|weak|strong|unsafe_unretained|nullability|null_resettable|class|direct}5' 속성}3을 발견했습니다"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{static assert with condition|static assert with message|static assert with %select{|no }4message|%select{method %5|constructor|destructor}4|%select{method %5|constructor|destructor}4 is %select{not deleted|deleted}6|%select{method %5|constructor|destructor}4 is %select{not defaulted|defaulted}6|%select{method %5|constructor|destructor}4 is %select{|pure }6%select{not virtual|virtual}7|%select{method %5|constructor|destructor}4 is %select{not static|static}6|%select{method %5|constructor|destructor}4 is %select{not volatile|volatile}6|%select{method %5|constructor|destructor}4 is %select{not const|const}6|%select{method %5|constructor|destructor}4 is %select{not inline|inline}6|%select{method %5|constructor|destructor}4 with %ordinal6 parameter with%select{out|}7 a default argument|%select{method %5|constructor|destructor}4 with %ordinal6 parameter with a default argument|%select{method %5|constructor|destructor}4 with %select{no |}6template arguments|%select{method %5|constructor|destructor}4 with %6 template argument%s6|%select{method %5|constructor|destructor}4 with %6 for %ordinal7 template argument|%select{method %5|constructor|destructor}4 with %select{no body|body}6|%select{method %5|constructor|destructor}4 with body|friend %select{class|function}4|friend %4|friend function %4|function template %4 with %5 template parameter%s5|function template %4 with %ordinal5 template parameter being a %select{type|non-type|template}6 template parameter|function template %4 with %ordinal5 template parameter %select{with no name|named %7}6|function template %4 with %ordinal5 template parameter with %select{no |}6default argument|function template %4 with %ordinal5 template parameter with default argument %6|function template %4 with %ordinal5 template parameter with one type|function template %4 with %ordinal5 template parameter %select{not |}6being a template parameter pack|}3"
HCEB41952ED68: "%q0는 다른 모듈에서 서로 다른 정의를 가집니다; 첫 번째 차이는 %select{모듈 '%2'의 정의|여기서 정의됨}1에서 %select{조건이 있는 정적 어설트|메시지가 있는 정적 어설트|정적 어설트에 %select{|없는 }4메시지|%select{메서드 %5|생성자|소멸자}4|%select{메서드 %5|생성자|소멸자}4가 %select{삭제되지 않음|삭제됨}6|%select{메서드 %5|생성자|소멸자}4가 %select{기본값이 아님|기본값임}6|%select{메서드 %5|생성자|소멸자}4가 %select{비가상|가상}7 %select{순수|}6|%select{메서드 %5|생성자|소멸자}4가 %select{정적 아님|정적}6|%select{메서드 %5|생성자|소멸자}4가 %select{볼트 아님|볼트}6|%select{메서드 %5|생성자|소멸자}4가 %select{const 아님|const}6|%select{메서드 %5|생성자|소멸자}4가 %select{인라인 아님|인라인}6|%select{메서드 %5|생성자|소멸자}4가 %ordinal6번째 매개변수에 %select{출력|}7 기본 인수를 가짐|%select{메서드 %5|생성자|소멸자}4가 %ordinal6번째 매개변수에 기본 인수를 가짐|%select{메서드 %5|생성자|소멸자}4가 %select{템플릿 인수가 없음|템플릿 인수가 있음}6|%select{메서드 %5|생성자|소멸자}4가 %6 템플릿 인수%s6|%select{메서드 %5|생성자|소멸자}4가 %ordinal7번째 템플릿 인수에 %6|%select{메서드 %5|생성자|소멸자}4가 %select{본문 없음|본문 있음}6|%select{메서드 %5|생성자|소멸자}4가 본문 있음|프렌드 %select{클래스|함수}4|프렌드 %4|프렌드 함수 %4|함수 템플릿 %4에 %5 템플릿 매개변수%s5|함수 템플릿 %4의 %ordinal5번째 템플릿 매개변수는 %select{타입|비타입|템플릿}6 템플릿 매개변수|함수 템플릿 %4의 %ordinal5번째 템플릿 매개변수 %select{이름 없음|%7 이름}6|함수 템플릿 %4의 %ordinal5번째 템플릿 매개변수 %select{기본 인수 없음|기본 인수 있음}6|함수 템플릿 %4의 %ordinal5번째 템플릿 매개변수 기본 인수 %6|함수 템플릿 %4의 %ordinal5번째 템플릿 매개변수에 타입 하나|함수 템플릿 %4의 %ordinal5번째 템플릿 매개변수 %select{템플릿 매개변수 팩이 아님|템플릿 매개변수 팩임}6|}3를 찾았습니다"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{unnamed template parameter|template parameter %5|template parameter with %select{no |}4default argument|template parameter with default argument}3"
HA9E92FE31082: "%q0가 다른 모듈에서 서로 다른 정의를 가집니다; 첫 번째 차이는 %select{모듈 '%2'의 정의|여기서 정의됨}1에서 %select{이름 없는 템플릿 매개변수|템플릿 매개변수 %5|기본 인수가 %select{없는 |}4템플릿 매개변수|기본 인수가 있는 템플릿 매개변수}3을 발견함"
# '%q0 hides overloaded virtual %select{function|functions}1'
H2FDDD909C4BF: '%q0는 오버로드된 가상 %select{함수|함수들}1을 가리킵니다'
# '%q0 is not a member of class %1'
H76BB7974AA85: '%q0는 클래스 %1의 멤버가 아닙니다'
# '%q0 must have external linkage when declared %q1'
HEEACDE119817: '%q0는 %q1로 선언될 때 외부 링크지(external linkage)가 있어야 합니다'
# '%q0 redeclared inline; %1 attribute ignored'
HE698B2D72430: '%q0 inline으로 재선언되었습니다; %1 속성이 무시됨'
# '%q0 redeclared without %1 attribute: previous %1 ignored'
HD8FE54A130EE: '%q0가 %1 속성 없이 재선언되었습니다: 이전 %1이 무시됩니다'
# "%q0 redeclared without 'dllimport' attribute: 'dllexport' attribute added"
H6D76D4BE2232: '%q0 dllimport 속성이 없이 재선언됨: dllexport 속성 추가됨'
# '%select{#elif|#elifdef|#elifndef}0 after #else'
H66B8B159F15D: '%select{#elif|#elifdef|#elifndef}0은(는) #else 이후에 사용할 수 없습니다.'
# '%select{#elif|#elifdef|#elifndef}0 without #if'
HF4D335F3B905: '%select{#elif|#elifdef|#elifndef}0은 #if 없이 사용되었습니다.'
# '%select{#line|GNU line marker}0 directive interprets number as decimal, not octal'
HDF9BCDB36B4E: '%select{#line|GNU line marker}0 지시문은 숫자를 10진수로 해석하지, 8진수로는 해석하지 않습니다'
# '%select{#line|GNU line marker}0 directive requires a simple digit sequence'
H065F2C4ACA47: '%select{#line|GNU line marker}0 지시문은 단순한 숫자 시퀀스가 필요합니다'
# '%select{%1 and |}0%2 tokens %select{introducing statement expression|terminating statement expression|introducing attribute|terminating attribute|forming pointer to member type}3 appear in different macro expansion contexts'
H64A1AC254D6A: '%select{%1과 |}0%2 토큰 %select{문장 표현을 도입하는|문장 표현을 종료하는|속성을 도입하는|속성을 종료하는|멤버 타입 포인터를 형성하는}3가 다른 매크로 확장 컨텍스트에서 나타납니다'
# '%select{%1 and |}0%2 tokens %select{introducing statement expression|terminating statement expression|introducing attribute|terminating attribute|forming pointer to member type}3 are separated by whitespace'
H9C7F5E5CC536: '%select{%1과 |}0%2 토큰 %select{문장 표현을 도입하는|문장 표현을 종료하는|속성을 도입하는|속성을 종료하는|멤버 타입 포인터를 형성하는}3는 공백으로 구분되었습니다'
# '%select{%1 is a virtual base class of base class %2 declared here|virtual base class %1 declared here}0'
H0907DB13630C: '%select{%1은 기본 클래스 %2의 가상 기반 클래스로 여기서 선언되었습니다|가상 기반 클래스 %1이 여기서 선언되었습니다}0'
# '%select{%2 has subobjects that are|%3 has type %2 that is}0 non-trivial to %select{default-initialize|destruct|copy}1'
H48AF719C5841: '%select{%2의 서브 오브젝트가|%3의 유형 %2가}0 %select{기본 초기화|소멸|복사}1에 대해 비트리비얼하지 않습니다'
# '%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes address space of nested pointer'
H229282294F90: '%select{%diff{첫 번째 $를 두 번째 $에 할당|다른 형식으로 할당}1,0|%diff{첫 번째 $를 형식 두 번째 $의 매개변수에 전달|다른 형식의 매개변수에 전달}0,1|%diff{함수의 결과 형식 두 번째 $에서 첫 번째 $를 반환|다른 반환 형식의 함수에서 반환}0,1|%diff{첫 번째 $를 두 번째 $ 형식으로 변환|형식 간 변환}0,1|%diff{두 번째 $ 형식의 표현식으로 첫 번째 $를 초기화|다른 형식의 표현식으로 초기화}0,1|%diff{첫 번째 $를 형식 두 번째 $의 매개변수에 전송|다른 형식의 매개변수에 전송}0,1|%diff{첫 번째 $를 두 번째 $ 형식으로 캐스팅|형식 간 캐스팅}0,1}2 중첩 포인터의 주소 공간을 변경합니다'
# '%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes address space of pointer'
H34858D5559B9: '%select{%diff{첫 번째 $를 두 번째 $에 할당|不同类型 간 할당}1,0|%diff{$를 $ 형식의 매개변수에 전달|다른 형식 매개변수로 전달}0,1|%diff{결과 형식 $인 함수에서 $ 반환|반환 형식이 다른 함수에서 반환}0,1|%diff{$를 $ 형식으로 변환|형식 간 변환}0,1|%diff{$ 형식의 표현식으로 $ 초기화|다른 형식 표현식으로 초기화}0,1|%diff{매개변수 $에 $ 전송|다른 형식 매개변수로 전송}0,1|%diff{$를 $ 형식으로 캐스팅|형식 간 캐스팅}0,1}2 포인터의 주소 공간이 변경됩니다'
# '%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes pointer authentication of pointee type'
H8986390D3B16: '%select{%diff{첫 번째 매개변수 $와 두 번째 매개변수 $ 간 할당|不同类型 간 할당}1,0|%diff{두 번째 매개변수 $를 첫 번째 매개변수 형식 $에 전달|parameter of different type}0,1|%diff{함수 결과 타입 $에서 $를 반환|returning from function with different return type}0,1|%diff{$를 $ 형식으로 변환|casting between types}0,1|%diff{두 번째 매개변수 $를 첫 번째 매개변수 $로 초기화|initializing with expression of different type}0,1|%diff{두 번째 매개변수 $를 첫 번째 매개변수 $에 전송|sending to parameter of different type}0,1|%diff{$를 $ 형식으로 캐스팅|casting between types}0,1}2 포인터 인증의 pointee 형식이 변경됩니다'
# '%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes retain/release properties of pointer'
HCD0B002FCAD8: '%select{%diff{할당 $를 $에|다른 타입에 할당}1,0|%diff{전달 $를 타입 $인 파라미터에|다른 타입 파라미터에 전달}0,1|%diff{반환 $를 타입 $인 함수에서|다른 반환 타입인 함수에서 반환}0,1|%diff{변환 $를 타입 $로|타입 간 변환}0,1|%diff{초기화 $를 타입 $ 표현식으로|다른 타입 표현식으로 초기화}0,1|%diff{전송 $를 타입 $ 파라미터에|다른 타입 파라미터에 전송}0,1|%diff{캐스팅 $를 타입 $로|타입 간 캐스팅}0,1}2 포인터의 retain/release 속성을 변경합니다'
# "%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 converts between pointers to integer types %select{with different sign|where one is of the unique plain 'char' type and the other is not}3"
H1F24CCDCD587: "%select{%diff{다른 형식으로 $에 할당|다른 형식으로 할당}0,1|%diff{파라미터의 형식인 $에 $ 전달|다른 형식의 파라미터로 전달}0,1|%diff{결과 형식 $인 함수에서 $ 반환|반환 형식이 다른 함수에서 반환}0,1|%diff{$를 $ 형식으로 변환|형식 간 변환}0,1|%diff{$ 형식 표현식으로 $ 초기화|다른 형식 표현식으로 초기화}0,1|%diff{파라미터의 형식인 $에 $ 전송|다른 형식의 파라미터로 전송}0,1|%diff{$를 $ 형식으로 캐스팅|형식 간 캐스팅}0,1}2 정수 형식 포인터 간 변환 %select{부호가 다른 경우|하나는 일반 'char' 형식이고 다른 것은 아닌 경우}3"
# '%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 converts between void pointer and function pointer'
HA7C5AA745059: '%select{%diff{할당 대상 $에 $를 할당|다른 타입으로의 할당}0,1|%diff{매개변수 $의 타입에 $ 전달|다른 타입의 매개변수에 전달}0,1|%diff{결과 타입 $인 함수에서 $ 반환|다른 반환 타입의 함수에서 반환}0,1|%diff{$를 $ 타입으로 변환|타입 간 변환}0,1|%diff{$ 타입의 표현식으로 $ 초기화|다른 타입의 표현식으로 초기화}0,1|%diff{매개변수 $의 타입에 $ 전송|다른 타입의 매개변수에 전송}0,1|%diff{$를 $ 타입으로 캐스팅|타입 간 캐스팅}0,1}2 void 포인터와 함수 포인터 간 변환'
# '%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers'
H7F0C4095C720: '%select{%diff{첫 번째 $를 두 번째 $로 할당시 qualifiers를 무시함|다른 형식으로 할당시 qualifiers를 무시함}0,1|%diff{첫 번째 $를 두 번째 $ 유형의 파라미터로 전달시 qualifiers를 무시함|파라미터 유형이 다른 것으로 전달시 qualifiers를 무시함}0,1|%diff{첫 번째 $를 두 번째 $ 결과 유형의 함수에서 반환시 qualifiers를 무시함|다른 반환 형식의 함수에서 반환시 qualifiers를 무시함}0,1|%diff{첫 번째 $를 두 번째 $ 유형으로 변환시 qualifiers를 무시함|유형 간 변환시 qualifiers를 무시함}0,1|%diff{첫 번째 $를 두 번째 $ 유형 표현식으로 초기화시 qualifiers를 무시함|다른 유형 표현식으로 초기화시 qualifiers를 무시함}0,1|%diff{첫 번째 $를 두 번째 $ 유형 파라미터로 전송시 qualifiers를 무시함|유형이 다른 파라미터로 전송시 qualifiers를 무시함}0,1|%diff{첫 번째 $를 두 번째 $ 유형으로 캐스팅시 qualifiers를 무시함|유형 간 캐스팅시 qualifiers를 무시함}0,1}2'
# '%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers in nested pointer types'
HA6738ACC7EBA: '%select{%diff{변수 $에 $를 할당하는 중|타입이 다른 대상에 할당}0,1|%diff{$를 $ 형식의 매개변수에 전달하는 중|다른 형식의 매개변수에 전달}0,1|%diff{결과 타입 $인 함수에서 $를 반환하는 중|다른 반환 타입의 함수에서 반환}0,1|%diff{$를 $ 형식으로 변환하는 중|타입 간 변환}0,1|%diff{$를 $ 형식의 표현식으로 초기화하는 중|다른 형식의 표현식으로 초기화}0,1|%diff{$를 $ 형식의 매개변수에 전송하는 중|다른 형식의 매개변수에 전송}0,1|%diff{$를 $ 형식으로 캐스팅하는 중|타입 간 캐스팅}0,1}2 중첩된 포인터 형식의 자격 증명을 무시합니다'
# '%select{%diff{assigning to $ from incompatible type $|assigning to type from incompatible type}0,1|%diff{passing $ to parameter of incompatible type $|passing type to parameter of incompatible type}0,1|%diff{returning $ from a function with incompatible result type $|returning type from a function with incompatible result type}0,1|%diff{converting $ to incompatible type $|converting type to incompatible type}0,1|%diff{initializing $ with an expression of incompatible type $|initializing type with an expression of incompatible type}0,1|%diff{sending $ to parameter of incompatible type $|sending type to parameter of incompatible type}0,1|%diff{casting $ to incompatible type $|casting type to incompatible type}0,1}2'
HCAB9D3041C51: '%select{%diff{부적합한 타입 $에서 $에 할당함|타입을 부적합한 타입으로 할당}0,1|%diff{부적합한 타입 매개변수에 $를 전달|타입을 부적합한 타입 매개변수에 전달}0,1|%diff{부적합한 결과 타입 $를 가진 함수에서 $를 반환|타입을 부적합한 결과 타입을 가진 함수에서 반환}0,1|%diff{$를 부적합한 타입 $로 변환|타입을 부적합한 타입으로 변환}0,1|%diff{부적합한 타입 $ 표현식으로 $ 초기화|타입을 부적합한 타입 표현식으로 초기화}0,1|%diff{부적합한 타입 매개변수에 $를 전송|타입을 부적합한 타입 매개변수에 전송}0,1|%diff{$를 부적합한 타입 $로 캐스팅|타입을 부적합한 타입으로 캐스팅}0,1}2'
# '%select{%diff{assigning to $ from incompatible type $|assigning to type from incompatible type}0,1|%diff{passing $ to parameter of incompatible type $|passing type to parameter of incompatible type}0,1|%diff{returning $ from a function with incompatible result type $|returning type from a function with incompatible result type}0,1|%diff{converting $ to incompatible type $|converting type to incompatible type}0,1|%diff{initializing $ with an expression of incompatible type $|initializing type with an expression of incompatible type}0,1|%diff{sending $ to parameter of incompatible type $|sending type to parameter of incompatible type}0,1|%diff{casting $ to incompatible type $|casting type to incompatible type}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3%select{|: different classes%diff{ ($ vs $)|}5,6|: different number of parameters (%5 vs %6)|: type mismatch at %ordinal5 parameter%diff{ ($ vs $)|}6,7|: different return type%diff{ ($ vs $)|}5,6|: different qualifiers (%5 vs %6)|: different exception specifications}4'
H5631F8DA82CD: '%select{%diff{$에 호환되지 않는 형식 $를 사용하여 할당|호환되지 않는 형식 $를 가진 타입에 할당}0,1|%diff{인수의 호환되지 않는 형식 $에 $ 전달|호환되지 않는 형식 $를 가진 인수로 전달}0,1|%diff{호환되지 않는 결과 형식 $를 가진 함수에서 $ 반환|호환되지 않는 결과 형식으로 반환}0,1|%diff{$를 호환되지 않는 형식 $로 변환|호환되지 않는 형식으로 변환}0,1|%diff{$를 호환되지 않는 형식 $ 표현식으로 초기화|호환되지 않는 형식 표현식으로 초기화}0,1|%diff{인수의 호환되지 않는 형식 $에 $ 전송|호환되지 않는 형식 $를 가진 인수로 전송}0,1|%diff{$를 호환되지 않는 형식 $로 캐스팅|호환되지 않는 형식으로 캐스팅}0,1}2%select{|; 별표(*)를 사용하십시오|; 앤드(&)를 사용하십시오|; 별표(*)를 제거하십시오|; 앤드(&)를 제거하십시오}3%select{|: 다른 클래스%diff{ ($ vs $)|}5,6|: 매개변수 수가 다릅니다 (%5 vs %6)|: %ordinal5 번째 매개변수에서 형식 불일치%diff{ ($ vs $)|}6,7|: 반환 형식이 다릅니다%diff{ ($ vs $)|}5,6|: 수식어가 다릅니다 (%5 vs %6)|: 예외 지정 사항이 다릅니다}4'
# '%select{%select{increment|decrement}1 of readonly property|no setter method %2 for %select{increment|decrement}1 of property}0'
HAF55C5B7D9CC: '%select{읽기 전용 속성의 %select{증가|감소}1|%select{증가|감소}1에 대한 property의 세터 메소드 %2가 없습니다.}0'
# "%select{%select{reference|'std::initializer_list'}0 member|member with %select{reference|'std::initializer_list'}0 subobject}1 declared here"
H1B5CDFE7B6DA: "%select{%select{참조|'std::initializer_list'}0 멤버|%select{참조|'std::initializer_list'}0 서브오브젝트가 있는 멤버}1 여기에서 선언됨"
# "%select{'#pragma clang fp eval_method'|option 'ffp-eval-method'}0 cannot be used with %select{option 'fapprox-func'|option 'mreassociate'|option 'freciprocal'|option 'ffp-eval-method'|'#pragma clang fp reassociate'|'#pragma clang fp reciprocal'}1"
HD4A3AC42422A: "%select{'#pragma clang fp eval_method'|옵션 'ffp-eval-method'}0는 %select{옵션 'fapprox-func'|옵션 'mreassociate'|옵션 'freciprocal'|옵션 'ffp-eval-method'|'#pragma clang fp reassociate'|'#pragma clang fp reciprocal'}1와 함께 사용할 수 없습니다"
# "%select{'auto'|'decltype(auto)'|'__auto_type'|template arguments}0 deduced as %1 in declaration of %2 and deduced as %3 in declaration of %4"
H11DB7A31A7DA: "%select{ 'auto' | 'decltype(auto)' | '__auto_type' | 템플릿 인수 }0가 %2의 선언 시 %1로 추론되었고 %4의 선언 시 %3로 추론되었습니다"
# "%select{'auto'|'decltype(auto)'|'__auto_type'|use of %select{class template|function template|variable template|alias template|template template parameter|concept|template}2 %3 requires template arguments; argument deduction}0 not allowed %select{in function prototype|in non-static struct member|in struct member|in non-static union member|in union member|in non-static class member|in interface member|in exception declaration|in template parameter until C++17|in block literal|in template argument|in typedef|in type alias|in function return type|in conversion function type|here|in lambda parameter|in type allocated by 'new'|in K&R-style function parameter|in template parameter|in friend declaration|in function prototype that is not a function declaration|in requires expression parameter|in array declaration|in declaration of conversion function template|in lambda parameter before C++14}1"
H7226E87E7B56: "%select{'auto'|'decltype(auto)'|'__auto_type'|%select{클래스 템플릿|함수 템플릿|변수 템플릿|별칭 템플릿|템플릿 템플릿 매개변수|컨셉|템플릿}2 %3 템플릿 인수를 요구합니다; 인수 추론}0 허용되지 않습니다 %select{함수 프로토타입에서|정적 멤버가 아닌 구조체 멤버에서|구조체 멤버에서|정적 멤버가 아닌 유니온 멤버에서|유니온 멤버에서|정적 멤버가 아닌 클래스 멤버에서|인터페이스 멤버에서|예외 선언에서|C++17까지 템플릿 매개변수에서|블록 리터럴에서|템플릿 인자에서|typedef에서|타입 별칭에서|함수 반환 타입에서|변환 함수 타입에서|여기서|람다 매개변수에서|'new'로 할당된 타입에서|K&R 스타일 함수 매개변수에서|템플릿 매개변수에서|friend 선언에서|함수 선언이 아닌 함수 프로토타입에서|requires 표현식 매개변수에서|배열 선언에서|변환 함수 템플릿의 선언에서|C++14 이전 람다 매개변수에서}1"
# "%select{'mutable'|'static'|'constexpr'|'consteval'}0 cannot appear multiple times in a lambda declarator"
HA9F29290F39F: "%select{'mutable'|'static'|'constexpr'|'consteval'}0는 lambda 선언자에서 여러 번 나타날 수 없습니다"
# "%select{'size' argument to memset is '0'|setting buffer to a 'sizeof' expression}0; did you mean to transpose the last two arguments?"
HBE450D9F2F6C: "%select{memset의 size 인수는 '0'입니다|'sizeof' 표현식으로 버퍼를 설정}0; 마지막 두 인수를 바꾸려는 의도가 있었나요?"
# '%select{<ERROR>|constexpr|consteval|constinit}0 can only be used in %select{|variable and function|function|variable}0 declarations'
H8ABC77B14403: '%select{<오류>|constexpr|consteval|constinit}0는 오직 %select{|변수와 함수|함수|변수}0 선언에서만 사용할 수 있습니다'
# '%select{<ERROR>|equality|three-way|equality|relational}0 comparison operator is not a friend of %select{|incomplete class }1%2'
HFE0AE74FD7A7: '%select{<ERROR>|등식 비교|세방향 비교|등식 비교|관계 비교}0 비교 연산자가 %select{|완성되지 않은 클래스 }1%2의 친구 함수가 아닙니다'
# '%select{<error>|function template|variable template|alias template|template template parameter|concept|template}0 %1 requires template arguments; argument deduction only allowed for class templates or alias templates'
HDE23AA7C6E82: '%select{<error>|함수 템플릿|변수 템플릿|별칭 템플릿|템플릿 템플릿 매개변수|개념|템플릿}0 %1 템플릿 인수가 필요합니다; 인수 추론은 클래스 템플릿 또는 별칭 템플릿에서만 허용됩니다'
# '%select{@available|__builtin_available}0 does not guard availability here; use if (%select{@available|__builtin_available}0) instead'
HBA44F219FD20: '%select{@available|__builtin_available}0는 여기서 가용성을 보호하지 않습니다; 대신 if (%select{@available|__builtin_available}0)을 사용하십시오'
# "%select{MIPS|MSP430|RISC-V|AVR}0 '%select{interrupt|signal}1' attribute only applies to functions that have %select{no parameters|a 'void' return type}2"
HC530D462FB18: "%select{MIPS|MSP430|RISC-V|AVR}0 '%select{interrupt|signal}1' 속성은 %select{매개변수가 없는|'void' 반환 형식을 가진}2 함수에만 적용됩니다"
# "%select{OpenACC '%3' construct|while loop|do loop}0 cannot appear in intervening code of a '%1' with a '%2' clause"
HB2C5F39C46C3: "%select{OpenACC '%3' 구문|while 루프|do 루프}0는 '%1'에 '%2' 절이 있는 중간 코드 영역에서 나타날 수 없습니다."
# "%select{OpenACC 'gang' clause with a 'dim' value greater than 1|OpenACC 'reduction' clause}0 cannot appear on the same '%1' construct as a %select{'reduction' clause|'gang' clause with a 'dim' value greater than 1}0"
H3449F0200ABB: "%select{dim 값이 1보다 큰 OpenACC 'gang' 절|OpenACC 'reduction' 절}0은 '%1' 구조체와 함께 %select{reduction 절|dim 값이 1보다 큰 gang 절}0이 있는 경우 나타날 수 없습니다"
# '%select{OpenACC sub-array|OpenMP array section}0 is not allowed here'
H8129F6E36883: '%select{OpenACC 서브 어레이|OpenMP 어레이 섹션}0은 여기서 허용되지 않습니다'
# '%select{PCH|current translation unit}0 has no VFS overlays'
H1F8E7EA59762: '%select{PCH|현재 번역 단위}0 VFS 오버레이가 없습니다'
# '%select{PCH|current translation unit}0 has the following VFS overlays:\n%1'
HF3357458F7A1: '%select{PCH|현재 번역 단위}0에는 다음 VFS 오버레이가 있습니다:\n%1'
# "%select{PCH|module|precompiled }0 file '%1' uses a newer format that cannot be read"
H07F5AC341880: "%select{PCH|모듈|사전 컴파일된 }0 파일 '%1'은(는) 더 최신 형식을 사용하므로 읽을 수 없습니다"
# "%select{PCH|module|precompiled}0 file '%1' built from a different branch (%2) than the compiler (%3)"
H9745C76C9827: "%select{PCH|모듈|사전 컴파일된}0 파일 '%1'은(는) 컴파일러(%3)와 다른 브랜치(%2)에서 빌드되었습니다"
# "%select{PCH|module|precompiled}0 file '%1' contains compiler errors"
H4EAD7147E188: "%select{PCH|모듈|사전 컴파일된}0 파일 '%1'은(는) 컴파일러 오류를 포함하고 있습니다"
# "%select{PCH|module|precompiled}0 file '%1' is out of date and needs to be rebuilt%select{|: %3}2"
H34F1D2EC0C97: "%select{PCH|모듈|사전 컴파일된}0 파일 '%1'은(는) 오래되었습니다. 다시 빌드해야 합니다%select{|: %3}2"
# "%select{PCH|module|precompiled}0 file '%1' not found%select{|: %3}2"
HD144036A5800: "%select{PCH|모듈|사전 컴파일된}0 파일 '%1'을(를) 찾을 수 없습니다%select{|: %3}2"
# "%select{PCH|module|precompiled}0 file '%1' uses an older format that is no longer supported"
HBC82CDA04A3A: "%select{PCH|모듈|사전 컴파일된}0 파일 '%1'은(는) 더 이상 지원되지 않는 오래된 형식을 사용합니다."
# '%select{__block variables|global variables|fields|instance variables}0 cannot have __autoreleasing ownership'
H8459C5DA92C1: '%select{__block 변수|전역 변수|필드|인스턴스 변수}0에는 __autoreleasing 소유권을 가질 수 없습니다'
# '%select{__device__|__global__|__host__|__host__ __device__}0 function %1 cannot overload %select{__device__|__global__|__host__|__host__ __device__}2 function %3'
HD56CBB05D1A2: '%select{__device__|__global__|__host__|__host__ __device__}0 함수 %1은/는 %select{__device__|__global__|__host__|__host__ __device__}2 함수 %3과 오버로드할 수 없습니다'
# '%select{a reference type|an array type|a non-vector or non-vectorizable scalar type}0 is an invalid argument to attribute %1'
H9A7D97DDD421: '%select{참조 형식|배열 형식|비벡터 형식 또는 벡터화할 수 없는 스칼라 형식}0는 속성 %1의 인수로는 유효하지 않은 형식입니다.'
# "%select{a variable|a parameter|'this'}0 cannot appear in more than one %1 clause"
HE09D18DCA51A: "%select{변수|매개변수|'this'}0는 %1 절에 중복하여 나타날 수 없습니다"
# "%select{active|which applies to}0 '%1' clause here"
H2AA7AEE20DF7: "여기서 '%1' 절이 %select{활성화됨|적용됨}0"
# '%select{address of|reference to}0 stack memory associated with %select{local variable|parameter|compound literal}2 %1 %select{returned|passed to musttail function}3'
HDE8352A90808: '%select{주소|참조}0 스택 메모리가 %select{지역 변수|매개변수|복합 리터럴}2 %1 %select{반환된|musttail 함수에 전달된}3'
# '%select{alias|ifunc}0 definition is part of a cycle'
H75F8799A172C: '%select{alias|ifunc}0 정의는 사이클의 일부입니다'
# '%select{alias|ifunc}0 must point to a defined %select{variable or |}1function'
HA8FBD807C04A: '%select{alias|ifunc}0는 지정된 %select{변수 또는 |}1정의된 함수에 포인트해야 합니다'
# "%select{alias|ifunc}1 will not be in section '%0' but in the same section as the %select{aliasee|resolver}2"
H14919DB80F8A: "%select{alias|ifunc}1은 '%0' 섹션에 있지 않을 것이지만, %select{aliasee|resolver}2와 같은 섹션에 있습니다"
# '%select{alias|ifunc}2 will always resolve to %0 even if weak definition of %1 is overridden'
H739E4FBA0F0D: '%select{alias|ifunc}2는 %1의 약한 정의가 재정의되더라도 항상 %0으로 해석됩니다'
# '%select{aligning a value|the result of checking whether a value is aligned}0 to 1 byte is %select{a no-op|always true}0'
H6A34843E702F: '%select{값을 정렬하는 것은|값이 정렬되었는지 확인한 결과는}0을 1바이트로는 %select{무효 연산입니다|항상 참입니다}0'
# '%select{alignment of|offset of the aligned pointer from}0 the base pointee object (%1 %plural{1:byte|:bytes}1) is %select{less than|not a multiple of}0 the asserted %2 %plural{1:byte|:bytes}2'
H473934A0D013: '%select{기반 포인티 객체의 정렬|기반 포인티 객체에서 정렬된 포인터의 오프셋}0 (%1 %plural{1:바이트|:바이트}1)이 %select{보다 작음|지정된 값의 배수가 아님}0 %2 %plural{1:바이트|:바이트}2입니다'
# '%select{alignment|size}0 of field %1 (%2 bits) does not match the %select{alignment|size}0 of the first field in transparent union; transparent_union attribute ignored'
HF5A022BDF3DB: '필드 %1 (%2 비트)의 %select{정렬|크기}0이 투명 유니온의 첫 번째 필드의 %select{정렬|크기}0과 일치하지 않습니다; transparent_union 속성 무시됨'
# '%select{alignment|size}0 of first field is %1 bits'
H996CEE2D3252: '첫 번째 필드의 %select{정렬|크기}0은 %1 비트입니다.'
# '%select{all|second and third}0 arguments to %1 must be of scalar or vector type with matching scalar element type%diff{: $ vs $|}2,3'
HE09C48EB126A: '%select{모든|두 번째 및 세 번째}0 인수는 %1의 스칼라 또는 벡터 타입(일치하는 스칼라 요소 타입을 가짐)이어야 합니다%diff{: $ 대 $|}2,3'
# '%select{an attribute specifier sequence|%0}1 in this position is a C++23 extension'
H561F9F6DB91B: '%select{속성 지정자 시퀀스|%0}1 이 위치에 C++23 확장 기능입니다'
# '%select{an attribute specifier sequence|%1}0 in this position is incompatible with C++ standards before C++23'
HEF130F97BB12: '%select{속성 지정자 시퀀스|%1}0는 C++23 이전 표준과 이 위치에서 호환되지 않습니다'
# '%select{and|because}0 %1 (%2 %3 %4) evaluated to false'
H66E1D07D582D: '%select{그리고|왜냐하면}0 %1 (%2 %3 %4)가 거짓으로 평가되었습니다'
# '%select{and|because}0 %1 does not satisfy %2'
H1152B396A251: '%select{그리고|왜냐하면}0 %1는 %2를 충족하지 않습니다'
# '%select{and|because}0 %1 does not satisfy %2:'
H7FDA8323151A: '%select{그리고|왜냐하면}0 %1은 %2를 만족하지 않습니다:'
# '%select{and|because}0 %1 evaluated to false'
H26D0E6409D84: '%select{그리고|왜냐하면}0 %1가 거짓으로 평가되었습니다'
# '%select{and|because}0 %1 may throw an exception'
H22182AFC34C5: '%select{그리고|왜냐하면}0 %1은 예외를 발생시킬 수 있습니다'
# "%select{and|because}0 '%1' would be invalid"
HAD3CC48247E5: "%select{그리고|때문에}0 '%1'은(는) 유효하지 않습니다"
# "%select{and|because}0 '%1' would be invalid%2"
HEF46AC24BE27: '%select{그리고|왜냐하면}0 ‘%1’은 유효하지 않을 것입니다%2'
# "%select{and|because}0 '%1' would be invalid: %2"
HD3831227C190: "%select{그리고|왜냐하면}0 '%1'은 잘못되었습니다: %2"
# '%select{and|because}0 type constraint %1 was not satisfied:'
H0831E4850047: '%select{그리고|왜냐하면}0 형식 제약 %1이 충족되지 않았습니다:'
# '%select{anonymous struct|union}0 member %1 has a non-trivial %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}2'
H443C398B6494: '%select{익명 구조体型|유니온}0 멤버 %1은 비트리비얼한 %select{디폴트 생성자|복사 생성자|이동 생성자|복사 대입 연산자|이동 대입 연산자|소멸자}2를 가지고 있습니다.'
# '%select{anonymous struct|union}0 member %1 with a non-trivial %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}2 is incompatible with C++98'
HE6728E1CAD49: '%select{익명 구조체|유니온}0 멤버 %1에 비平凡 %select{기본 생성자|복사 생성자|이동 생성자|복사 대입 연산자|이동 대입 연산자|소멸자}2는 C++98과 호환되지 않습니다'
# '%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 %select{floating-point|enumeration}1 type %2 %plural{2:with|4:from|:and}0 %select{enumeration|floating-point}1 type %3'
H510A2D2A82E0: '%select{유형 사이의 산술|비트 연산 유형 사이의|비교 유형 사이의|조건 표현식 유형 사이의|복합 할당 유형 사이의}0 %select{부동소수점|열거형}1 유형 %2 %plural{2:와|4:에서|:및}0 %select{열거형|부동소수점}1 유형 %3'
# '%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 %select{floating-point|enumeration}1 type %2 %plural{2:with|4:from|:and}0 %select{enumeration|floating-point}1 type %3 is deprecated'
H08C01E0FFD79: '%select{산술 연산 사이|비트 연산 사이|비교|조건 표현 사이|복합 할당}0 %select{부동 소수점|열거형}1 타입 %2 %plural{2:와|4:에서|:와}0 %select{열거형|부동 소수점}1 타입 %3은 비추천 됩니다'
# '%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different Unicode character types %1 and %2'
H815FA4B1A658: '%select{산술 연산|비트 연산|비교|조건식|복합 대입}0에서 서로 다른 유니코드 문자형 %1과 %2가 사용되었습니다.'
# '%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2'
H15481858FE39: '%select{연산자 사이의 산술 연산|비트 연산 사이의 비트 연산|다른 열거형 유형의 비교|두 열거형 유형 사이의 조건 표현식|두 열거형 유형 사이의 복합 할당}0 다른 열거형 유형%diff{ ($와 $)|}1,2'
# '%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2 is deprecated'
HB2E74DC62C72: '%select{정수 연산 사이|비트 연산 사이|비교|조건 표현식 사이|복합 할당}0 다른 열거형 유형%diff{ (과 )|}1,2는 더 이상 사용되지 않습니다'
# '%select{assignment to readonly property|no setter method %1 for assignment to property}0'
H7FB56A6FE5D6: '%select{읽기 전용 프로퍼티에 대한 할당|세터 메서드 %1이 없어서 프로퍼티에 할당할 수 없습니다}0'
# '%select{base class|inherited virtual base class}0 %1 has %select{private|protected}3 %select{default |copy |move |*ERROR* |*ERROR* |*ERROR*|}2constructor'
H3EE5604475F7: '%select{기반 클래스|상속된 가상 기반 클래스}0 %1는 %select{프라이빗|프로텍티드}3 %select{디폴트 |복사 |이동 |*ERROR* |*ERROR* |*ERROR*|}2 생성자를 갖습니다'
# '%select{bit-field %1|anonymous bit-field}0 is too wide (%2 bits)'
H4CB82469419C: '%select{비트 필드 %1은|익명의 비트 필드는}0 너무 넓습니다 (%2 비트)'
# "%select{block pointer|pointer|reference}0 to function type %select{%2 |}1cannot have '%3' qualifier"
H0BABB964A63A: "%select{블록 포인터|포인터|참조}0 함수 유형에 대한 %select{%2 |}1는 '%3' 형식 지정자를 가질 수 없습니다"
# '%select{call to non-static member function|use of non-static data member}0 %2 of %1 from nested type %3'
H4DA493B4F5FF: '%select{비정적 멤버 함수 호출|비정적 데이터 멤버 사용}0 %2의 %1에서 중첩된 타입 %3'
# '%select{cannot assign to return value because function %1 returns a const value|cannot assign to variable %1 with const-qualified type %2|cannot assign to %select{non-|}1static data member %2 with const-qualified type %3|cannot assign to non-static data member within const member function %1|cannot assign to %select{variable %2|non-static data member %2|lvalue}1 with %select{|nested }3const-qualified data member %4|read-only variable is not assignable}0'
H957C121C1C4E: '%select{함수 %1이 const 값을 반환하므로 반환 값에 할당할 수 없습니다|const- 자격이 부여된 형식 %2인 변수 %1에 할당할 수 없습니다|%select{비정적|}1데이터 멤버 %2의 const- 자격이 부여된 형식 %3에 할당할 수 없습니다|%1 const 멤버 함수 내에서 비정적 데이터 멤버에 할당할 수 없습니다|%select{변수 %2|비정적 데이터 멤버 %2|lvalue}1의 %select{ |내포된 }3const- 자격이 부여된 데이터 멤버 %4에 할당할 수 없습니다|읽기 전용 변수는 할당할 수 없습니다}0'
# "%select{case value|enumerator value|non-type template argument|non-type parameter of template template parameter|array size|explicit specifier argument|noexcept specifier argument|call to 'size()'|call to 'data()'}0 %select{cannot be narrowed from type %2 to %3|evaluates to %2, which cannot be narrowed to type %3}1"
HECF4733C9DA0: "%select{case 값|열거형 값|템플릿의 비유형 인수|템플릿 템플릿 파라미터의 비유형 매개변수|배열 크기|explicit 지정자 인수|noexcept 지정자 인수|함수 'size()' 호출|함수 'data()' 호출}0 %select{타입 %2에서 %3으로 줄일 수 없습니다|값이 %2로 평가되지만, 이는 %3 타입으로 줄일 수 없습니다}1"
# "%select{case value|enumerator value|non-type template argument|non-type parameter of template template parameter|array size|explicit specifier argument|noexcept specifier argument|call to 'size()'|call to 'data()'}0 is not a constant expression"
HFB41B693F137: "%select{case 값|열거형 값|비유형 템플릿 인수|템플릿 템플릿 매개변수의 비유형 매개변수|배열 크기|explicit 지정자 인수|noexcept 지정자 인수|'size()' 호출|'data()' 호출}0은 상수 표현식이 아닙니다"
# '%select{cast|implicit conversion}0 of %select{Objective-C|block|C}1 pointer type %2 to %select{Objective-C|block|C}3 pointer type %4 requires a bridged cast'
H312933E2115D: '%select{형 변환|암시적 변환}0의 %select{Objective-C|block|C}1 포인터 유형 %2를 %select{Objective-C|block|C}3 포인터 유형 %4로 변환하는 것은 브리지 형 변환이 필요합니다'
# '%select{category %1|class extension}0 cannot conform to protocol %2 because of direct members declared in interface %3'
H86E18740A145: '%select{카테고리 %1|클래스 확장}0는 인터페이스 %3에서 선언된 직접 멤버 때문에 프로토콜 %2에 준수할 수 없습니다.'
# '%select{category|class extension}0 conforms to protocol %1 which defines method %2'
H1219B6B58D30: '%select{카테고리|클래스 확장}0 프로토콜 %1을 준수하는데, 이 프로토콜은 메서드 %2를 정의합니다'
# '%select{character|integer}0 literal with user-defined suffix cannot be used in preprocessor constant expression'
HF3B4B5DEEBAB: '%select{문자|정수}0 리터럴에 사용자 정의 접미사를 가진 프리프로세서 상수 표현식에 사용할 수 없습니다'
# '%select{class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration}0 specialization of %1 must occur at global scope'
HB1B7C78CE71E: '%select{클래스 템플릿|클래스 템플릿 부분|변수 템플릿|변수 템플릿 부분|함수 템플릿|멤버 함수|정적 데이터 멤버|멤버 클래스|멤버 열거형}0 전문화의 %1은 전역 범위에서 발생해야 합니다'
# '%select{class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration}0 specialization of %1 not in %select{a namespace enclosing %2|class %2 or an enclosing namespace}3'
HFB74AB926D65: '%select{클래스 템플릿|클래스 템플릿 부분 전문화|변수 템플릿|변수 템플릿 부분 전문화|함수 템플릿|멤버 함수|정적 데이터 멤버|멤버 클래스|멤버 열거형}0 특정화의 %1이 %select{포함하는 네임스페이스 내에서 %2|클래스 %2 또는 포함하는 네임스페이스}3에 있지 않음'
# '%select{class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration}0 specialization of %1 not in %select{a namespace enclosing %2|class %2 or an enclosing namespace}3 is a Microsoft extension'
H61AEC4FCDF68: '%select{클래스 템플릿|클래스 템플릿 부분|변수 템플릿|변수 템플릿 부분|함수 템플릿|멤버 함수|정적 데이터 멤버|멤버 클래스|멤버 열거형}0 특수화 %1의 %select{%2를 둘러싼 네임스페이스|클래스 %2 또는 둘러싼 네임스페이스}3에 속하지 않으면 Microsoft 확장 기능입니다'
# '%select{class|instance}0 method %1 also declared here'
H40D03C99413F: '%select{클래스|인스턴스}0 메서드 %1도 여기서 선언되었습니다'
# '%select{class|instance}0 method %1 has a different number of parameters in different translation units (%2 vs. %3)'
H1C2BED5A5D12: '%select{클래스|인스턴스}0 메소드 %1이 다른 번역 단위에서 매개변수 개수가 다릅니다 (%2 vs. %3)'
# '%select{class|instance}0 method %1 has a parameter with a different types in different translation units (%2 vs. %3)'
H27FF7F628706: '%select{클래스|인스턴스}0 메서드 %1에는 다른 번역 단위에서 다른 형식의 매개변수가 있습니다 (%2 vs. %3)'
# '%select{class|instance}0 method %1 has incompatible result types in different translation units (%2 vs. %3)'
H81568F1228D2: '%select{클래스|인스턴스}0 메소드 %1은 다른 번역 단위에서 호환되지 않는 반환 타입을 가집니다 (%2 vs. %3)'
# '%select{class|instance}0 method %1 is assumed to return an instance of its receiver type (%2)'
H57512855C27C: '%select{클래스|인스턴스}0 메서드 %1은 수신자 유형 (%2)의 인스턴스를 반환한다고 가정됩니다.'
# '%select{class|instance}0 method %1 is variadic in one translation unit and not variadic in another'
HF51A27778394: '%select{클래스|인스턴스}0 메서드 %1은 하나의 번역 단위에서는 가변 인자 메서드이지만 다른 번역 단위에서는 그렇지 않습니다'
# '%select{class|protocol|category|class extension|implementation|category implementation}0 started here'
HB972B56B97CE: '%select{클래스|프로토콜|카테고리|클래스 확장|구현|카테고리 구현}0 시작되었습니다'
# '%select{class|struct|interface|union|enum|enum class|enum struct}0 cannot be marked %select{<ERROR>|constexpr|consteval|constinit}1'
H6CC4F10FF6EF: '%select{클래스|구조체|인터페이스|유니온|열거형|열거 클래스|열거 구조체}0는 %select{<ERROR>|constexpr|consteval|constinit}1로 표시할 수 없습니다'
# '%select{class|type alias}0 template declared here'
HC92E96CB1535: '%select{class|type alias}0 템플릿이 여기서 선언되었습니다'
# '%select{class|variable}0 template partial specialization contains %select{a template parameter|template parameters}1 that cannot be deduced; this partial specialization will never be used'
H8F8D0B49DE65: '%select{클래스|변수}0 템플릿 부분 특수화에 %select{추론할 수 없는 템플릿 매개변수|추론할 수 없는 템플릿 매개변수들}1이 포함되었습니다; 이 부분 특수화는 절대로 사용되지 않을 것입니다'
# '%select{class|variable}0 template partial specialization does not specialize any template argument; to %select{declare|define}1 the primary template, remove the template argument list'
HC805ED783ADF: '%select{클래스|변수}0 템플릿 부분 특수화는 어떤 템플릿 인수도 특수화하지 않습니다; %select{선언|정의}1 주 템플릿을 위해 템플릿 인수 목록을 제거하십시오'
# '%select{class|variable}0 template partial specialization is not more specialized than the primary template'
HD6682742D913: '%select{클래스|변수}0 template 부분 특수화는 기본 템플릿보다 더 특수화되지 않았습니다'
# '%select{codeseg|section}0 does not match previous declaration'
H9AFE01E1A06A: '%select{코드 섹션|section}0은 이전 선언과 일치하지 않습니다'
# "%select{command line contains|precompiled file '%1' was built with}0 '-detailed-preprocessing-record' but %select{precompiled file '%1' was not built with it|it is not present on the command line}0"
HDDE8830E5E4D: "%select{명령줄에 포함됨|사전 컴파일된 파일 '%1'이(가) 함께 빌드됨}0 '-detailed-preprocessing-record' 옵션을 사용했지만 %select{사전 컴파일된 파일 '%1'은(는) 해당 옵션 없이 빌드됨|명령줄에 해당 옵션이 없음}0"
# "%select{command line contains|precompiled file '%1' was built with}0 '-undef' but %select{precompiled file '%1' was not built with it|it is not present on the command line}0"
H538B2717C6E0: "%select{명령줄에 '-undef' 포함됨|사전 컴파일된 파일 '%1'이(가) '-undef'와 함께 빌드됨}0 하지만 %select{사전 컴파일된 파일 '%1'은(는) '-undef' 없이 빌드됨|명령줄에 '-undef' 없음}0"
# '%select{comparison between %diff{ ($ and $)|}0,1|arithmetic operation with operands of type %diff{ ($ and $)|}0,1|conditional operator with the second and third operands of type %diff{ ($ and $)|}0,1}2 which are pointers to non-overlapping address spaces'
H47A4B5F7D5D9: '%select{비교 연산자의 %diff{ ($와 $)|}0,1 사이의 비교|유형이 %diff{ ($와 $)|}0,1인 피연산자를 가진 산술 연산|두 번째와 세 번째 피연산자의 유형이 %diff{ ($와 $)|}0,1인 조건 연산자}2입니다. 이들은 non-overlapping 주소 공간을 가리키는 포인터들입니다'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 from %1 to %2 converts between mismatching address spaces'
HB50BD1C6F363: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0에서 %1에서 %2로 변환하는 것은 일치하지 않는 주소 공간 간 변환입니다'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 from %1 to %2 is not allowed'
H0994EC770949: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 %1에서 %2로의 변환은 허용되지 않습니다'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 from rvalue to reference type %2'
H79F10447DC2A: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0에서 rvalue를 %2 참조 형식으로 캐스팅'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2 casts away qualifiers'
H56EB9B5EABD1: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0에서 %1에서 %2로 형 변환 시 자격 증명을 제거함'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2, which are not related by inheritance, is not allowed'
HC3DB71EF3442: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 %1에서 %2로의 캐스트는 상속 관계가 없으므로 허용되지 않습니다'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from bit-field lvalue to reference type %2'
H1DAD5B4DA5AC: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 비트 필드 lvalue에서 참조 형식 %2로'
# '%select{const_cast||||C-style cast|functional-style cast|}0 to %2, which is not a reference, pointer-to-object, or pointer-to-data-member'
H2773305E9004: '%select{const_cast||||C 스타일 캐스트|함수형 스타일 캐스트|}0에서 %2로 변환하는 것은 참조, 객체 포인터, 또는 데이터 멤버 포인터가 아닙니다'
# "%select{constexpr|consteval}0 function's return type %1 is not a literal type"
H8C05F94E8F5F: '%select{constexpr|consteval}0 함수의 반환 형식 %1은 리터럴 형식이 아닙니다'
# '%select{constexpr|consteval}1 %select{function|constructor}0 never produces a constant expression'
H022CBA14DE42: '%select{constexpr|consteval}1 %select{function|constructor}0는 상수 표현식을 생성하지 않습니다'
# "%select{constexpr|consteval}2 %select{function|constructor}1's %ordinal0 parameter type %3 is not a literal type"
H6B5DAAD976BB: '%select{constexpr|consteval}2 %select{function|constructor}1의 %ordinal0 번째 매개변수 유형 %3은 리터럴 유형이 아닙니다'
# '%select{constructor for %1 must explicitly initialize the|implicit default constructor for %1 must explicitly initialize the|cannot use constructor inherited from base class %4;}0 %select{base class|member}2 %3 %select{which|which|of %1}0 does not have a default constructor'
HE93B407A4DE4: '%select{%1의 생성자는 기본 생성자로 명시적으로 초기화해야 하는|%1의 암시적 기본 생성자는 명시적으로 초기화해야 하는|기반 클래스 %4에서 상속된 생성자를 사용할 수 없습니다;}0 %select{기반 클래스|멤버}2 %3 %select{가|가|의 %1}0 기본 생성자가 없습니다'
# '%select{constructor for %1|implicit default constructor for %1|cannot use constructor inherited from %1:}0 must explicitly initialize the %select{reference|const}2 member %3'
H5DD624CAFF41: '%select{%1의 생성자|%1의 암시적 기본 생성자|기반 클래스 %1에서 상속된 생성자:}0는 %select{참조|const-qualifier}2 멤버 %3을 명시적으로 초기화해야 합니다'
# '%select{constructor|destructor}1 %0 must not return void expression'
H76E14738E327: '%select{생성자|소멸자}1 %0는 void 표현식을 반환할 수 없습니다'
# '%select{const|reference}0 member %1 will never be initialized'
H67E2118A2E7C: '%select{const|reference}0 멤버 %1은 절대 초기화되지 않을 것입니다'
# '%select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1 invokes deleted constructor'
HE9CE7E623BF3: '%select{변수 복사|매개변수 복사|템플릿 매개변수 초기화|객체 반환|표현식 결과 초기화|객체 던지기|멤버 서브오브젝트 복사|배열 요소 복사|객체 할당|임시 객체 복사|기반 서브오브젝트 초기화|벡터 요소 초기화|값 포착}0의 %1 형식 타입은 삭제된 생성자를 호출합니다'
# '%select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}1 of type %2 when binding a reference to a temporary would %select{invoke an inaccessible constructor|find no viable constructor|find ambiguous constructors|invoke a deleted constructor}0 in C++98'
H29AE4DB3DE15: '%select{변수 복사|매개변수 복사|템플릿 매개변수 초기화|객체 반환|문자열 표현 결과 초기화|예외 객체 던짐|멤버 서브오브젝트 복사|배열 요소 복사|객체 할당|임시 오브젝트 복사|기반 서브오브젝트 초기화|벡터 요소 초기화|값 캡처}1 타입 %2는 C++98에서 임시 객체 참조 생성 시 %select{접근 불가능한 생성자 호출|적합한 생성자 없음|동일한 생성자 중복|삭제된 생성자 호출}0'
# '%select{copy|move}0 assignment operator of %1 is implicitly deleted because field %2 is of %select{reference|const-qualified}4 type %3'
HA5E40C813D22: '%select{copy|move}0 할당 연산자 %1의는 필드 %2가 %select{reference|const-qualified}4 형식 %3이기 때문에 암묵적으로 삭제되었습니다'
# '%select{data member %1|base class %2}0 declared here'
HC9ED4A45B57E: '%select{데이터 멤버 %1|기반 클래스 %2}0 여기서 선언되었습니다'
# '%select{data member |non-public member function |static member function |user-declared constructor|user-declared destructor|operator |nested class }0%1 is not permitted within an interface type'
H9EC34E188C56: '%select{데이터 멤버|비공개 멤버 함수|정적 멤버 함수|사용자 선언 생성자|사용자 선언 소멸자|연산자|내포 클래스}0%1은 인터페이스 형식 내에서는 허용되지 않습니다'
# '%select{declaration|definition|default argument declared|explicit specialization declared|partial specialization declared}0 here is not %select{visible|reachable|reachable|reachable|reachable|reachable}0'
H804351062C9E: '%select{선언|정의|기본 인수 선언됨|명시적 특수화 선언됨|부분 특수화 선언됨}0 여기서는 %select{가시적|도달 가능|도달 가능|도달 가능|도달 가능|도달 가능}0하지 않습니다'
# "%select{declaration|definition|default argument|explicit specialization|partial specialization}0 of %1 must be imported from module '%2' before it is required"
HC491502A3888: "%select{선언|정의|기본 인수|명시적 특수화|부분 특수화}0 %1은 필요하기 전에 모듈 '%2'에서 가져와야 합니다"
# '%select{declaration|definition|default argument|explicit specialization|partial specialization}0 of %1 must be imported from one of the following modules before it is required:%2'
HA8E1DF60359B: '%select{선언|정의|기본 인수|명시적 특수화|부분 특수화}0의 %1은 사용되기 전에 한 개 이상의 다음 모듈 중 하나에서 가져와야 합니다:%2'
# '%select{declaration|definition}0 of %select{struct|interface|union|class|enum}1 in a dependent scope'
H690477FDDE60: '의존적 범위에서 %select{선언|정의}0의 %select{구조체|인터페이스|공용体型|클래스|열거형}1'
# '%select{decremented|incremented}0 here'
HD8461A402F1F: '%select{감소되었습니다|증가되었습니다}0 여기서'
# '%select{decrement|increment}0 of object of volatile-qualified type %1 is deprecated'
H57C759966E48: '%select{감소|증가}0 연산의 volatile 자격이 지정된 형식 %1의 객체는 더 이상 권장되지 않습니다'
# '%select{default construction|assignment}0 of lambda is incompatible with C++ standards before C++20'
H3C92D92BB26F: '%select{람다의 디폴트 생성|할당}0는 C++20 이전 표준과 호환되지 않습니다'
# '%select{default constructor of|constructor inherited by}0 %1 is implicitly deleted because all %select{data members|data members of an anonymous union member}2 are const-qualified'
HF80E1E94C448: '%select{기본 생성자의|상속받은 생성자의}0 %1의 기본 생성자가 암묵적으로 삭제되었습니다. 모든 %select{데이터 멤버|익명 유니온 멤버의 데이터 멤버}2가 const 자격이 있음'
# '%select{default constructor of|constructor inherited by}0 %1 is implicitly deleted because field %2 of %select{reference|const-qualified}4 type %3 would not be initialized'
H3F45472DFCD6: '%select{기본 생성자의|상속받은 생성자의}0 %1의 기본 생성자가 암묵적으로 삭제되었습니다. %2의 %select{참조|const 자격이 있는}4 타입 %3는 초기화되지 않음'
# "%select{default constructor of|copy constructor of|move constructor of|copy assignment operator of|move assignment operator of|destructor of|constructor inherited by}0 %1 is implicitly deleted because %select{base class %3|%select{||||variant }4field %3}2 %select{has %select{no|a deleted|multiple|an inaccessible|a non-trivial}4 %select{%select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|%select{default|corresponding|default|default|default}4 constructor}0|destructor}5%select{||s||}4|is an ObjC pointer|has an address-discriminated '__ptrauth' qualifier}6"
H8B06D5202BF4: "%select{디폴트 생성자 of|복사 생성자 of|이동 생성자 of|복사 할당 연산자 of|이동 할당 연산자 of|소멸자 of|기반 클래스에 상속된 생성자 of}0 %1은 %select{기반 클래스 %3|%select{||||variant }4필드 %3}2 %select{이 %select{없는|삭제된|복수의|접근 불가능한|비平凡}4 %select{%select{디폴트 생성자|복사 생성자|이동 생성자|복사 할당 연산자|이동 할당 연산자|소멸자|%select{디폴트|대응하는|디폴트|디폴트|디폴트}4 생성자}0|소멸자}5%select{||s||}4|ObjC 포인터임|주소 구분 '__ptrauth' 자격 증명을 가짐}6 때문에 암묵적으로 삭제되었습니다"
# "%select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot be 'constexpr' in a class with virtual base class"
HAA0AD1F4C5AC: "%select{기본 생성자|복사 생성자|이동 생성자|복사 대입 연산자|이동 대입 연산자|소멸자}0는 가상 기반 클래스를 갖는 클래스에서 'constexpr'일 수 없습니다"
# '%select{defaulted|deleted}0 function definitions are a C++11 extension'
H2588FE2C83FF: '%select{디폴트로 지정됨|삭제됨}0 함수 정의는 C++11 확장 기능입니다'
# '%select{defaulted|deleted}0 function definitions are incompatible with C++98'
HE7CB963644EA: '%select{디폴트|삭제된}0 함수 정의는 C++98과 호환되지 않습니다'
# "%select{definition|#undef}0 of configuration macro '%1' has no effect on the import of '%2'; pass '%select{-D%1=...|-U%1}0' on the command line to configure the module"
H20DEB068BA86: "%select{정의|#undef}0의 구성 매크로 '%1'은 '%2'의 import에 영향을 주지 않습니다; 모듈을 구성하려면 명령줄에 '%select{-D%1=...|-U%1}0'을 전달하십시오"
# '%select{delete|destructor}0 called on %1 that is abstract but has non-virtual destructor'
HD3B2B405330A: '%select{delete|destructor}0가 %1의 추상 클래스에 호출되었지만 비가상 소멸자가 있습니다'
# '%select{delete|destructor}0 called on non-final %1 that has virtual functions but non-virtual destructor'
HD186820BFF8C: '%select{삭제|소멸자}0가 가상 함수를 가진 최종적이지 않은 %1에 대해 호출되었지만 비가상 소멸자를 가지고 있지 않습니다'
# '%select{delimited|named}0 escape sequences are a %select{C++23|C2y|Clang}1 extension'
HDBE05BE4D14B: '%select{구분자로 감싸인|이름 붙인}0 탈출 시퀀스는 %select{C++23|C2y|Clang}1의 확장 기능입니다'
# '%select{delimited|named}0 escape sequences are incompatible with C++ standards before C++23'
HFB62920439FF: '%select{구분자로 구분된|이름 지정}0 탈출 시퀀스는 C++23 이전 표준과 호환되지 않습니다'
# '%select{destination for|source of|first operand of|second operand of}0 this %1 call is a pointer to %select{|class containing a }2dynamic class %3; vtable pointer will be %select{overwritten|copied|moved|compared}4'
H63A8D05F544B: '%select{의 목적지|의 소스|첫 번째 피연산자|두 번째 피연산자}0 이 %1 호출은 %select{|동적 클래스 %3를 포함하는 클래스 }2의 포인터입니다; vtable 포인터는 %select{덮어쓰여집니다|복사됩니다|이동됩니다|비교됩니다}4'
# '%select{destination for|source of|first operand of|second operand of}0 this %1 call is a pointer to record %2 that is not trivial to %select{primitive-default-initialize|primitive-copy}3'
HB6A0DAA8C1C8: '%select{이 항목의 목적지|이 항목의 원천|첫 번째 연산자의|두 번째 연산자의}0 이 %1 호출은 %2 레코드에 대한 포인터로서 %select{primitive-default-initialize|primitive-copy}3 작업에 있어서 비트리비얼합니다'
# '%select{destination for|source of}0 this %1 call is a pointer to ownership-qualified type %2'
HEE4DB03498AC: '%select{목적지|원본}0 이 %1 호출은 소유권 지정된 타입 %2 포인터입니다'
# '%select{destructor|deallocator}0 has a %select{non-throwing|implicit non-throwing}1 exception specification'
H78E56ACB6245: '%select{소멸자|할당 해제자}0은(는) %select{non-throwing|암시적 non-throwing}1 예외 지정을 가지고 있습니다'
# '%select{dictionary|array}1 subscript base type %0 is not an Objective-C object'
HE2828D54BB1B: '%select{사전|array}1 서브스크립트 기반 유형 %0는 Objective-C 객체가 아닙니다'
# '%select{equality|inequality|relational|three-way}0 comparison result unused'
H69C6598EFBD9: '%select{등호 비교|부등호 비교|관계 비교|세방향 비교}0 비교 결과가 사용되지 않음'
# '%select{expected an expression statement|expected built-in assignment operator|expected expression of scalar type|expected lvalue expression}0'
H7F94DE3BA105: '%select{표현식 문이 필요합니다|내장 할당 연산자가 필요합니다|스칼라 형식의 표현식이 필요합니다|lvalue 표현식이 필요합니다}0'
# "%select{expected an expression statement|expected built-in binary or unary operator|expected unary decrement/increment operation|expected expression of scalar type|expected assignment expression|expected built-in binary operator|expected one of '+', '*', '-', '/', '&', '^', '%|', '<<', or '>>' built-in operations|expected in right hand side of expression}0"
H13014A5049BE: "%select{표현식 문을 기대했습니다|내장 이진 또는 일항 연산자를 기대했습니다|일항 감소/증가 연산을 기대했습니다|스칼라 형식의 표현식을 기대했습니다|할당 표현식을 기대했습니다|내장 이진 연산자를 기대했습니다|'+', '*', '-', '/', '&', '^', '%|', '<<', 또는 '>>' 내장 연산 중 하나를 기대했습니다|표현식의 우측에서 기대했습니다}0"
# '%select{expected assignment expression|expected compound statement|expected exactly two expression statements|expected in right hand side of the first expression}0'
H71EE048AAB44: '%select{할당 표현식이 예상됩니다|복합 문이 예상됩니다|정확히 두 개의 표현식 문이 필요합니다|첫 번째 표현식의 오른쪽에 위치해야 합니다}0'
# "%select{expected compound statement|expected exactly one expression statement|expected assignment statement|expected conditional operator|expect result value to be at false expression|expect binary operator in conditional expression|expect '<', '>' or '==' as order operator|expect comparison in a form of 'x == e', 'e == x', 'x ordop expr', or 'expr ordop x'|expect lvalue for result value|expect scalar value|expect integer value|unexpected 'else' statement|expect '==' operator|expect an assignment statement 'v = x'|expect a 'if' statement|expect no more than two statements|expect a compound statement|expect 'else' statement|expect a form 'r = x == e; if (r) ...'}0"
H2BEDF1CDD9ED: "%select{복합 문을 기대함|표현식 문 하나가 필요함|할당 문이 필요함|조건 연산자(ternary operator)가 필요함|결과 값이 false 표현식에 있어야 함|조건 표현식에 이항 연산자가 있어야 함|'<', '>' 또는 '=='를 순서 연산자로 사용해야 함|비교식이 'x == e', 'e == x', 'x ordop expr', 또는 'expr ordop x' 형태여야 함|결과 값에 lvalue가 필요함|스칼라 값이 필요함|정수 값이 필요함|예상하지 못한 'else' 문|'==' 연산자가 필요함|'v = x' 형태의 할당 문이 필요함|'if' 문이 필요함|문이 두 개를 초과하지 않아야 함|복합 문이 필요함|'else' 문이 필요함|'r = x == e; if (r) ...' 형태가 필요함}0"
# '%select{explicit|friend}0 specialization cannot have a trailing requires clause unless it declares a function template'
H4B8C1F1CA2BB: '%select{explicit|friend}0 특수화는 함수 템플릿을 선언하는 경우를 제외하고는 뒤따르는 requires 절을 가질 수 없습니다'
# '%select{expression|base type|declaration type|data member type|bit-field size|static assertion|fixed underlying type|enumerator value|using declaration|friend declaration|qualifier|initializer|default argument|non-type template parameter type|exception type|explicit specialization|partial specialization|__if_exists name|__if_not_exists name|lambda|block|type constraint|requirement|requires clause}0 contains%plural{0: an|:}1 unexpanded parameter pack%plural{0:|1: %2|2:s %2 and %3|:s %2, %3, ...}1'
HE9A8E0B2E8F5: '%select{표현식|기본 형식|선언 형식|데이터 멤버 형식|비트 필드 크기|정적 확인|고정된 기본 형식|열거자 값|using 선언|친구 선언|자격 증명자|초기식|기본 인수|비형식 템플릿 매개변수 형식|예외 형식|명시적 특수화|부분 특수화|__if_exists 이름|__if_not_exists 이름|람다|블록|형식 제약|요구 사항|requires 절}0는%plural{0: 1개의|:}1 확장되지 않은 매개변수 패็ก%plural{0:|1: %2|2: %2와 %3|: %2, %3, ...}1을 포함합니다.'
# '%select{extension|category}0 of non-parameterized class %1 cannot have type parameters'
H6F4F8CBFDF9B: '%select{확장|분류}0 of 매개변수화되지 않은 클래스 %1은 유형 매개변수를 가질 수 없습니다.'
# '%select{fewer|more}0 specifiers in format string than expected'
H294968301C0D: '%select{적은|더 많은}0 지정자가 포맷 문자열에서 예상보다 있습니다'
# "%select{field width|precision}0 used with '%1' conversion specifier, resulting in undefined behavior"
H2CF9930D6217: "%select{필드 너비|정밀도}0을 '%1' 변환 지정자와 함께 사용하여 미정의 동작을 초래합니다"
# '%select{field|base class}0 %1 will be initialized after %select{field|base}2 %3'
HE92BDD84B944: '%select{필드|기반 클래스}0 %1는 %select{필드|기반}2 %3 이전에 초기화됩니다'
# '%select{first two|all}1 arguments to %0 must be vectors'
HF5292D19FFBC: '%select{첫 번째 두 개|모든}1 %0의 인수는 벡터여야 합니다'
# '%select{first two|all}1 arguments to %0 must have the same type'
H648C1151AF74: '%select{첫 번째 두 개|모든}1 arguments to %0 must have the same type'
# "%select{first|second|third|fourth}0 parameter of 'main' (%select{argument count|argument array|environment|platform-specific data}0) must be of type %1"
HF5B9D5CD8E73: "%select{첫 번째|두 번째|세 번째|네 번째}0 매개변수 of 'main' (%select{인자 개수|인자 배열|환경|플랫폼 특정 데이터}0)은 %1 형식이어야 합니다"
# '%select{first|second|third}0 parameter has unexpected type %1 (should be %2)'
HB94305DC6AD8: '%select{첫 번째|두 번째|세 번째}0 번째 매개변수는 예상치 못한 유형 %1입니다 (여야 하는 유형은 %2입니다)'
# '%select{first|second}0 operand was implicitly converted to type %1'
HBF77ADC8F095: '%select{첫 번째|두 번째}0 연산수가 %1 타입으로 암시적으로 변환되었습니다'
# '%select{forward class declaration|class definition|category|extension}0 has too %select{few|many}1 type parameters (expected %2, have %3)'
HF027D432E158: '%select{클래스의 전방 선언|클래스 정의|카테고리|확장}0는 타입 매개변수가 너무 %select{적습니다|많습니다}1 (예상 %2개, %3개 있음)'
# '%select{function %1 which returns const-qualified type %2 declared here|variable %1 declared const here|%select{non-|}1static data member %2 declared const here|member function %q1 is declared const here|%select{|nested }1data member %2 declared const here}0'
HA9209A7005BD: '%select{함수 %1은 const 자격이 있는 타입 %2를 반환하는 것이 여기서 선언되었습니다|변수 %1이 여기서 const로 선언되었습니다|%select{비-|}1정적 데이터 멤버 %2가 여기서 const로 선언되었습니다|%q1 멤버 함수가 여기서 const로 선언되었습니다|%select{ |중첩된 }1데이터 멤버 %2가 여기서 const로 선언되었습니다}0'
# '%select{function parameter|typedef}0 cannot be %select{<ERROR>|constexpr|consteval|constinit}1'
H86C3A8B0C257: '%select{함수 매개변수|typedef}0는 %select{<ERROR>|constexpr|consteval|constinit}1로 지정할 수 없습니다.'
# '%select{function template|class template|variable template|type alias template|template template parameter}0 %1 declared here'
H91E08CCD64B6: '%select{함수 템플릿|클래스 템플릿|변수 템플릿|유형 별칭 템플릿|템플릿 템플릿 매개변수}0 %1 여기에서 선언되었습니다'
# '%select{function with deduced return type|declaration with trailing return type}0 must be the only declaration in its group'
HA1CB6C2DD073: '%select{추론된 반환 형식을 가진 함수|뒤따르는 반환 형식을 가진 선언}0는 그 그룹에서 유일한 선언이어야 합니다'
# "%select{function|block|lambda|coroutine}0 declared 'noreturn' should not return"
HBB674CBF2E79: "%select{함수|블록|람다|코루틴}0은 'noreturn'로 선언되었으므로 반환하지 않아야 합니다"
# "%select{function|class|variable}0 cannot be defined in an explicit instantiation; if this declaration is meant to be a %select{function|class|variable}0 definition, remove the 'template' keyword"
HF2F19E25243A: "%select{함수|클래스|변수}0는 명시적 인스턴스화 안에서 정의될 수 없습니다. 이 선언이 %select{함수|클래스|변수}0의 정의를 의미한다면 'template' 키워드를 제거하십시오"
# "%select{function|constructor|destructor|lambda|block|member initializer of constructor}0 with '%1' attribute must not %select{allocate or deallocate memory|throw or catch exceptions|have static local variables|use thread-local variables|access ObjC methods or properties}2"
H8DE43E9D40B0: "%select{함수|생성자|소멸자|람다|블록|생성자의 멤버 초기화자}0에 '%1' 속성이 있는 경우 %select{메모리를 할당하거나 해제할 수 없습니다|예외를 발생시키거나 잡을 수 없습니다|정적 로컬 변수를 가질 수 없습니다|스레드 로컬 변수를 사용할 수 없습니다|Objective-C 메서드나 프로퍼티에 접근할 수 없습니다}2"
# "%select{function|constructor|destructor|lambda|block|member initializer of constructor}0 with '%1' attribute must not call non-'%1' %select{function|constructor|destructor|lambda|block}2 '%3'"
HD57CFC80D164: "%select{함수|생성자|소멸자|람다|블록|생성자의 멤버 초기화자}0 '%1' 속성은 non-'%1' %select{함수|생성자|소멸자|람다|블록}2 '%3'를 호출할 수 없습니다"
# "%select{function|constructor|destructor|lambda|block|member initializer of constructor}0 with '%1' attribute must not call non-'%1' expression"
H5BD0868978EA: "%select{함수|생성자|소멸자|람다|블록|생성자의 멤버 초기화자}0에 '%1' 속성을 가진 것은 비-'%1' 표현을 호출할 수 없습니다"
# "%select{function|constructor|destructor|lambda|block|member initializer}0 cannot be inferred '%1' because it %select{allocates or deallocates memory|throws or catches exceptions|has a static local variable|uses a thread-local variable|accesses an ObjC method or property}2"
H2867CEC6E928: "%select{함수|생성자|소멸자|람다|블록|멤버 초기화자}0은 '%1'로 추론될 수 없습니다.因为它 %select{메모리를 할당하거나 해제합니다|예외를 발생시키거나 잡습니다|정적 로컬 변수를 가집니다|쓰레드 로컬 변수를 사용합니다|ObjC 메서드나 속성에 접근합니다}2"
# "%select{function|constructor|destructor|lambda|block|member initializer}0 cannot be inferred '%1' because it calls non-'%1' %select{function|constructor|destructor|lambda|block}2 '%3'"
H314F30794920: "%select{함수|생성자|소멸자|람다|블록|멤버 초기화자}0는 '%1'로 추론될 수 없습니다.因为它 호출한 비-'%1' %select{함수|생성자|소멸자|람다|블록}2 '%3' 때문입니다"
# "%select{function|constructor|destructor|lambda|block}0 does not permit inference of '%1' because it is declared '%2'"
HB9A03E541F67: "%select{함수|생성자|소멸자|람다|블록}0는 '%2'로 선언되어 '%1'의 추론을 허용하지 않습니다"
# "%select{function|constructor|destructor|lambda|block}0 with '%1' attribute should be declared noexcept"
HB030E37D6AD6: "%select{함수|생성자|소멸자|람다|블록}0 '%1' 속성은 noexcept로 선언되어야 합니다"
# "%select{function|kernel}0 cannot be called 'main'"
H12368C59A019: "%select{함수|커널}0는 'main'이라고 이름을 지을 수 없습니다"
# '%select{function|method|block}0 has been explicitly marked sentinel here'
H02C89F36F346: '%select{함수|메서드|블록}0가 여기서 명시적으로 sentinel로 표시되었습니다'
# "%select{function|method}0 %1 could be declared with attribute 'noreturn'"
H2A06C5AB5A01: "%select{함수|메소드}0 %1은 특성 'noreturn'으로 선언될 수 있습니다"
# "%select{function|parameter}0 declared '[[carries_dependency]]' after its first declaration"
HA7BEBD006826: "%select{함수|파라미터}0 '[[carries_dependency]]' 속성을 첫 번째 선언 후에 선언했습니다"
# '%select{function|variable}0 %1 is not needed and will not be emitted'
HF8ADE574A433: '%select{함수|변수}0 %1은 필요하지 않아서 생성되지 않을 것입니다'
# '%select{function|variable}0 %q1 has internal linkage but is not defined'
H45C099CD2E21: '%select{함수|변수}0 %q1은 internal linkage가 지정되어 있으나 정의되지 않았습니다'
# '%select{function|variable}0 %q1 is used but not defined in this translation unit, and cannot be defined in any other translation unit because its type does not have linkage'
H4CCCEB729733: '%select{함수|변수}0 %q1은 이 번역 단위에서 사용되지만 정의되지 않았으며, 타입이 링크지가 없기 때문에 다른 번역 단위에서도 정의될 수 없습니다'
# '%select{global|private}0 module fragment cannot be exported'
H32D31F303DCC: '%select{global|private}0 모듈 프래그먼트는 내보낼 수 없습니다.'
# '%select{hex|octal}0 escape sequence out of range'
HD900722CD654: '%select{16진수|8진수}0 이스케이프 시퀀스 범위를 벗어남'
# '%select{if|switch}0 initialization statements are incompatible with C++ standards before C++17'
H48F2A35749E7: '%select{if|switch}0 초기화 문은 C++17 이전의 C++ 표준과 호환되지 않습니다'
# '%select{implicit conversion|cast}0 of %select{%2|a non-Objective-C pointer type %2|a block pointer|an Objective-C pointer|an indirect pointer to an Objective-C pointer}1 to %3 is disallowed with ARC'
H2BE56E173B04: '%select{암시적 변환|명시적 형변환}0 %select{%2|비오브젝티브-씨 포인터 유형 %2|블록 포인터|오브젝티브-씨 포인터|오브젝티브-씨 포인터의 간접 포인터}1을 %3로의 변환은 ARC에서 허용되지 않습니다'
# '%select{implicit conversion|cast}0 of weak-unavailable object of type %1 to a __weak object of type %2'
H5E0A61E4DC2C: '%select{암시적 변환|캐스트}0 of %1 형식의 weak-unavailable 객체를 %2 형식의 __weak 객체로'
# '%select{implicitly |}2captured%select{| by reference}3%select{%select{ due to use|}2 here| via initialization of lambda capture %0}1'
H0BA3D7D599E5: '%select{암시적으로 |}2포착된%select{| 참조로}3%select{%select{ 사용으로 인해 |}2 여기서| via initialization of lambda capture %0}1'
# '%select{implicit|explicit}0 instantiation first required here'
HB12903FE55DA: '%select{implicit|explicit}0 인스턴스화가 처음 필요로 하는 위치입니다'
# '%select{implicit|explicit}0 instantiation of template %1 within its own definition'
H0FEA9F8C421A: '%select{암묵적|명시적}0 템플릿 %1의 실체화가 자신의 정의 내에서 발생했습니다'
# '%select{implicit|explicit}0 instantiation of undefined template %1'
H04E01542E9F2: '%select{암시적|명시적}0 인스턴스화의 정의되지 않은 템플릿 %1'
# "%select{incompatible|duplicate}0 directives '%1' and '%2'"
HEFD5CC9864D7: "%select{호환되지 않는|중복된}0 지시문 '%1'과 '%2'"
# '%select{instance variable|property}2 with %0 attribute must be an object type (invalid %1)'
HFD8E12A874BC: '%select{인스턴스 변수|프로퍼티}2 %0 어트리뷰트는 객체 타입이어야 합니다 (잘못된 %1)'
# '%select{instance|class}1 method %0 not found ; did you mean %2?'
H113C6B0985AF: '%select{인스턴스|클래스}1 메서드 %0를 찾을 수 없음; %2를 의미하시는 건가요?'
# '%select{integer|float}0 literal is too large to be represented as a %select{32-bit %select{signed|}1 integer|float}0 type'
H84C45039D88A: '%select{정수|부동소수점}0 리터럴이 %select{32비트 %select{부호 있는|}1 정수|부동소수점}0 타입으로 표현하기에는 너무 큽니다.'
# '%select{integer|integral}1 constant expression must have %select{integer|integral or unscoped enumeration}1 type, not %0'
H07847569345A: '%select{정수|적분}1 상수 표현식은 %select{정수형 또는 unscoped 열거형|적분형 또는 unscoped 열거형}1 타입이어야 합니다. %0 타입을 사용할 수 없습니다.'
# "%select{interrupt service routine|function with attribute 'no_caller_saved_registers'}0 should only call a function with attribute 'no_caller_saved_registers' or be compiled with '-mgeneral-regs-only'"
HE2C243372C8E: "%select{인터럽트 서비스 루틴|'no_caller_saved_registers' 속성을 가진 함수}0는 'no_caller_saved_registers' 속성을 가진 함수만 호출하거나 '-mgeneral-regs-only' 플래그로 컴파일되어야 합니다"
# "%select{invalid use of|unknown}2 attribute subject matcher sub-rule '%0'; '%1' matcher %select{does not support sub-rules|supports the following sub-rules: %3}2"
H8BFF482F0D6A: "%select{잘못된 사용의|알 수 없는}2 attribute subject matcher 서브 룰 '%0'; '%1' matcher %select{서브 룰을 지원하지 않습니다|다음 서브 룰을 지원합니다: %3}2"
# "%select{invalid value '%0'; must be positive|value '%0' is too large}1"
HEC3DA4A69943: "%select{잘못된 값 '%0'; 양수여야 합니다|값 '%0'이 너무 큽니다}1"
# "%select{invalid|missing}0 option%select{ %1|}0; expected 'contract', 'reassociate', 'reciprocal', or 'exceptions'"
H280D64C6E2E8: "%select{잘못된|누락된}0 옵션%select{ %1|}0; 예상되는 옵션은 'contract', 'reassociate', 'reciprocal', 또는 'exceptions'입니다."
# '%select{invalid|missing}0 option%select{ %1|}0; expected vectorize, vectorize_width, interleave, interleave_count, unroll, unroll_count, pipeline, pipeline_initiation_interval, vectorize_predicate, or distribute'
HC3AB036EF44A: '%select{잘못된|누락된}0 옵션%select{ %1|}0; 기대된 vectorize, vectorize_width, interleave, interleave_count, unroll, unroll_count, pipeline, pipeline_initiation_interval, vectorize_predicate, 또는 distribute'
# '%select{in|co|contra}0variant type parameter %1 conflicts with previous %select{in|co|contra}2variant type parameter %3'
H893590D91D8F: '%select{in|co|contra}0 변이 형식 매개변수 %1이 이전 %select{in|co|contra}2 변이 형식 매개변수 %3과 충돌합니다'
# '%select{left |right |}0operand to %select{assignment|compound assignment|increment|decrement}1 expression must be %select{an l-value|of scalar type (was %3)}2'
H115469577E3D: '%select{왼쪽 |오른쪽 |}0 피연산자는 %select{할당|복합 할당|증가|감소}1 표현식의 %select{l-값|스칼라 형식이어야 합니다 (현재 %3)}2여야 합니다.'
# '%select{left|right}0 side of operator converted from negative value to unsigned: %1'
H1DC6B6DA95C3: '%select{left|right}0 측의 연산자가 음수 값에서 부호 없는 값으로 변환되었습니다: %1'
# '%select{left|right}1 operand to ? is void, but %select{right|left}1 operand is of type %0'
H8125EE82CC5A: '%select{왼쪽|오른쪽}1 피연산자의 타입이 void이지만, %select{오른쪽|왼쪽}1 피연산자는 %0 타입입니다.'
# '%select{loading directly from|assigning directly to}0 pointer to type %1 requires cl_khr_fp16. Use vector data %select{load|store}0 builtin functions instead'
H66CF7FCAA26B: '%select{포인터를 직접 로드하는|포인터를 직접 할당하는}0 타입 %1에 대해 cl_khr_fp16이 필요합니다. 벡터 데이터 %select{로드|저장}0 내장 함수를 사용하세요'
# '%select{local variable|parameter|typedef}0 %1 cannot be declared __module_private__'
H1DE6DC0BF8C5: '%select{로컬 변수|파라미터|typedef}0 %1을 __module_private__로 선언할 수 없습니다'
# "%select{map type '%1' is not allowed|map type must be specified}0 for '#pragma omp %2'"
HA49CE3340880: "%select{map 형식 '%1'은 허용되지 않습니다|map 형식을 지정해야 합니다}0 '#pragma omp %2'에 대해"
# "%select{missing '#include'|missing '#include %3'}2; %select{||default argument of |explicit specialization of |partial specialization of }0%1 must be %select{declared|defined|defined|declared|declared}0 before it is used"
H0EC06C773CD9: '%select{#include 누락|#include %3 누락}2; %select{||기본 인수 |명시적 특수화 |부분 특수화 }0%1은 %select{선언|정의|정의|선언|선언}0되어야 사용할 수 있습니다'
# '%select{no_destroy|always_destroy}0 attribute can only be applied to a variable with static or thread storage duration'
H7D17D7EDA6B0: '%select{no_destroy|always_destroy}0 속성은 정적 또는 스레드 저장 기간을 가진 변수에만 적용할 수 있습니다'
# '%select{non-constexpr|constexpr|consteval}1 declaration of %0 follows %select{non-constexpr|constexpr|consteval}2 declaration'
H2DCC831B3932: '%select{비 constexpr|constexpr|consteval}1 %0의 선언이 %select{비 constexpr|constexpr|consteval}2 선언 이후에 따라옵니다'
# '%select{non-constexpr|undefined}0 %select{function|constructor}1 %2 cannot be used in a constant expression'
H338EAA31FD42: '%select{비 constexpr|정의되지 않은}0 %select{함수|생성자}1 %2는 상수 표현식에서 사용할 수 없습니다'
# '%select{non-const|volatile}0 lvalue reference %diff{to type $ cannot bind to a temporary of type $|cannot bind to incompatible temporary}1,2'
HD89DCBC20587: '%select{non-const|volatile}0 lvalue reference %diff{형 $에 대한 lvalue 참조는 $의 일시적 객체에 바인딩할 수 없습니다|호환되지 않는 일시적 객체에 바인딩할 수 없습니다}1,2'
# '%select{non-const|volatile}0 lvalue reference %diff{to type $ cannot bind to a value of unrelated type $|cannot bind to a value of unrelated type}1,2'
H1777D1633EE8: '%select{비)const|volatile}0 왼쪽 값 참조 %diff{형 $의 왼쪽 값 참조는 관련 없는 형 $의 값에 바인딩할 수 없습니다.|관련 없는 형의 값에 바인딩할 수 없습니다.}1,2'
# '%select{non-const|volatile}0 lvalue reference to type %1 cannot bind to an initializer list temporary'
H3CF62E12AA3E: '%select{non-const|volatile}0 l값 참조 형식 %1은 초기화자 목록 임시 객체에 바인딩할 수 없습니다'
# '%select{non-const|volatile}0 reference cannot bind to bit-field%select{| %1}2'
H8AF09902E67B: '%select{const가 아닌|volatile}0 참조는 비트 필드에 바인딩할 수 없습니다.%select{| %1}2'
# '%select{non-const|volatile}0 reference cannot bind to matrix element'
HA82833F246FF: '%select{비)const|volatile}0 참조는 행렬 요소에 바인딩할 수 없습니다'
# '%select{non-const|volatile}0 reference cannot bind to vector element'
H6E26FD01A944: '%select{non-const|volatile}0 참조는 vector element에 바인딩할 수 없습니다'
# '%select{non-integral type %0|%0}1 is an invalid underlying type'
HAB3E494D65F5: '%select{정수 형식이 아닌 형식 %0|%0}1은 유효하지 않은 기본 형식입니다'
# '%select{non-kernel function|function scope}0 variable cannot be declared in %1 address space'
H0866366952CF: '%select{커널이 아닌 함수|함수 범위}0 변수는 %1 주소 공간에 선언될 수 없습니다'
# "%select{non-member function|static member function|explicit object member function|deduction guide}0 %select{of type %2 |}1cannot have '%3' qualifier"
HFB817CBCD184: "%select{비멤버 함수|정적 멤버 함수|명시적 객체 멤버 함수|추론 가이드}0 %select{유형 %2의 |}1'%3' 수식자를 가질 수 없습니다"
# '%select{non-member|member}0 %select{<ERROR>|equality|three-way|equality|relational}1 comparison operator must have %select{2|1}0 parameters'
HB5C9D99264DA: '%select{비멤버|멤버}0 %select{<ERROR>|등가|삼항|등가|관계}1 비교 연산자는 %select{2|1}0 매개변수를 가져야 합니다'
# '%select{non-member|static member|non-static member}0 function cannot perform a tail call to %select{non-member|static member|non-static member|pointer-to-member}1 function%select{| %3}2'
HE869F55E570F: '%select{비멤버|정적 멤버|비정적 멤버}0 함수는 %select{비멤버|정적 멤버|비정적 멤버|멤버 포인터}1 함수로 꼬리 호출을 수행할 수 없습니다%select{| %3}2'
# "%select{non-pointer|function pointer|void pointer}0 argument to '__builtin_launder' is not allowed"
H5F5CB4F84C85: "%select{포인터가 아닌|함수 포인터|void 포인터}0는 '__builtin_launder'의 인자로 허용되지 않습니다"
# "%select{non-struct type|non-class type|non-union type|non-enum type|typedef|type alias|template|alias template|template template argument}1 %0 cannot be referenced with the '%select{struct|interface|union|class|enum}2' specifier"
HA353FC8D883A: "%select{구조体型이 아닌|클래스 형이 아닌|유니온 형이 아닌|열거体型이 아닌|typedef|형 별칭|템플릿|별칭 템플릿|템플릿 템플릿 인자}1 %0는 '%select{struct|인터페이스|union|class|enum}2' 지정자로 참조할 수 없습니다."
# '%select{non-virtual|virtual}0 derivation here'
H7895E4BCBED9: '%select{비가상|virtual}0 파생이 여기서 필요합니다'
# "%select{non-|function }0pointer argument to '__builtin_is_within_lifetime' is not allowed"
HEC6E2A0FBA29: "%select{비-|함수 }0포인터 인수는 '__builtin_is_within_lifetime'에 허용되지 않습니다"
# '%select{non-|}0overlapping comparisons always evaluate to %select{false|true}0'
HDA33BE63192F: '%select{비|}0중복 비교는 항상 %select{거짓|참}0으로 평가됩니다.'
# '%select{non-|}0type aware %1 declared here in %2'
HC09774CA5903: '%select{non-|}0type aware %1은 %2에 여기 선언되었습니다'
# "%select{no|too many}0 integer expression arguments provided to OpenACC 'num_gangs' %select{|clause: '%1' directive expects maximum of %2, %3 were provided}0"
HDF54FE517944: "%select{없음|너무 많음}0 정수 표현 인수가 OpenACC 'num_gangs' %select{|절: '%1' 지시문은 최대 %2개를 요구하지만 %3개가 제공되었습니다}0에 제공되었습니다"
# "%select{orphaned 'omp section' directives are prohibited, it|'omp section' directive}0 must be closely nested to a sections region%select{|, not a %1 region}0"
HF07F4A64D372: "%select{독립된 'omp section' 지시문은 허용되지 않습니다, 이|'omp section' 지시문}0은 섹션스 영역에 직접 포함되어야 합니다%select{|, %1 영역이 아님}0"
# "%select{overridden|current}0 method is explicitly declared 'instancetype'%select{| and is expected to return an instance of its class type}0"
HB89C11914779: "%select{오버라이드|현재}0 메서드는 명시적으로 'instancetype'이%select{|되어 있으며 이 클래스 타입 인스턴스를 반환해야 합니다}0"
# "%select{overridden|current}0 method is part of the '%select{|alloc|copy|init|mutableCopy|new|autorelease|dealloc|finalize|release|retain|retainCount|self}1' method family%select{| and is expected to return an instance of its class type}0"
HB76B1E081BAA: "%select{오버라이드된|현재}0 메서드는 '%select{|alloc|copy|init|mutableCopy|new|autorelease|dealloc|finalize|release|retain|retainCount|self}1' 메서드 그룹의 일부이며%select{| 그리고 해당 클래스 형식의 인스턴스를 반환해야 합니다}0"
# '%select{parameters|function return value}0 cannot have __fp16 type; did you forget * ?'
H3BDED28AD784: '%select{매개변수|함수 반환 값}0는 __fp16 타입을 가질 수 없습니다; 별号를 빠뜨리지 않았나요?'
# '%select{parameter|non-static data member}3 %0 %select{|of %1 }3shadows member inherited from type %2'
H35412B47BBE2: '%select{매개변수|비정적 데이터 멤버}3 %0 %select{|의 %1 }3는 형식 %2에서 상속된 멤버를 가리고 있습니다'
# '%select{parameter|parameter pack}0 declared here'
H2699C14A1A0C: '%select{매개변수|매개변수 패킹}0 여기서 선언됨'
# "%select{parenthesize the third argument|cast the second argument to 'int'}0 to silence"
H798E3A404637: "%select{세 번째 인수를 괄호로 감싸세요|두 번째 인수를 'int'로 캐스팅하세요}0 경고를 제거하려면"
# '%select{partial specialization|explicit specialization|explicit instantiation}0 of alias templates is not permitted'
H336DD87FEE99: '%select{부분 전문화|명시적 전문화|명시적 인스턴스화}0의 alias 템플릿은 허용되지 않습니다'
# '%select{pointers|references}0 are unsupported in HLSL'
H134DDEB0FD66: '%select{포인터|참조}0는 HLSL에서 지원되지 않습니다'
# '%select{pointers|references}0 to functions are not allowed'
H30519C3FCFC8: '%select{pointers|references}0 함수에 대한 포인터나 참조는 허용되지 않습니다'
# '%select{pointer|block pointer|member pointer}0 is missing a nullability type specifier (_Nonnull, _Nullable, or _Null_unspecified)'
HF29961D95705: '%select{포인터|블록 포인터|멤버 포인터}0는 nullability type specifier (_Nonnull, _Nullable 또는 _Null_unspecified)가 누락되었습니다.'
# '%select{pointer|reference}0 to %select{|subobject of }1%select{temporary|%3}2 is not a constant expression'
H7F2DE7357BB3: '%select{포인터|참조자}0 %select{ |부 객체의 }1%select{임시|%3}2는 상수 표현식이 아닙니다'
# "%select{pointer|reference}0 to %select{|subobject of }1%select{type_info object|string literal|temporary object|predefined '%3' variable}2 is not allowed in a template argument"
HD8CE51EB9A3E: "%select{포인터|참조}0%select{ |의 서브 오브젝트 }1%select{type_info 객체|문자열 리터럴|임시 객체|선정의된 '%3' 변수}2는 템플릿 인수에 허용되지 않습니다."
# '%select{pointer|reference}0 to %select{|subobject of }1heap-allocated object is not a constant expression'
H9D1E7F5B4FD5: '%select{포인터|참조}0 %select{ |하위 객체의 }1힙에 할당된 객체는 상수 표현식이 아닙니다'
# '%select{pointer|reference}0 to WebAssembly reference type is not allowed'
HECDCB166B532: '%select{포인터|참조}0 WebAssembly reference type으로의 변환은 허용되지 않습니다'
# '%select{pointer|reference}0 to a consteval declaration is not a constant expression'
H8FC8E4B28636: '%select{포인터|참조}0에 해당하는 consteval 선언은 상수 표현식이 아닙니다'
# '%select{pointer|reference}1 to non-const type %0 with no explicit ownership'
H0FF342784C44: 'const가 아닌 유형 %0의 %select{포인터|참조}1에 명시적인 소유권이 없습니다.'
# "%select{precompiled file '%1' was|current translation unit is}0 compiled with the target feature '%2' but the %select{current translation unit is|precompiled file '%1' was}0 not"
H61983A41BC0C: "%select{사전 컴파일된 파일 '%1'이(가)|현재 번역 단위는}0 대상 기능 '%2'와(과) 함께 컴파일되었지만 %select{현재 번역 단위는|사전 컴파일된 파일 '%1'은(는)}0 그렇지 않습니다."
# '%select{precompiled header|module}0 uses __DATE__ or __TIME__'
H2637E05CCFD6: '%select{전처리된 헤더|모듈}0에서 __DATE__ 또는 __TIME__이 사용되었습니다'
# '%select{program scope|static local|extern}0 variable must reside in %1 address space'
H8250A4383E97: '%select{프로그램 범위|정적 로컬|외부}0 변수는 %1 주소 공간에 위치해야 합니다'
# '%select{property|instance variable}0 access cannot be qualified with %1'
H8153C2BE3904: '%select{속성|인스턴스 변수}0에 대한 접근은 %1로 자격을 지정할 수 없습니다'
# "%select{public|private|project}1 umbrella header file not found in input: '%0'"
HFB4B45B92460: "%select{public|private|project}1 아이버렐 헤더 파일이 입력에서 발견되지 않았습니다: '%0'"
# "%select{qualifier in |static |}0array size %select{||'[*] '}0is a C99 feature"
H5561702CDE0D: "%select{||'[*] '}0%select{qualifier in |static |}0배열 크기는 C99 기능입니다"
# "%select{qualifier in |static |}0array size %select{||'[*] '}0is a C99 feature, not permitted in C++"
HD9EDD0C87400: "%select{qualifier에 |static |}0배열 크기 %select{||'[*] '}0는 C99 기능으로 C++에서는 허용되지 않습니다."
# '%select{read of|read of|assignment to|increment of|decrement of|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>}0 volatile %select{temporary|object %2|member %2}1 is not allowed in a constant expression'
H88BF34501395: '%select{읽기|읽기|대입|증가|감소|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>}0 volatile %select{임시|객체 %2|멤버 %2}1는 상수 표현식에서 허용되지 않습니다'
# '%select{read of|read of|assignment to|increment of|decrement of|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>}0 volatile-qualified type %1 is not allowed in a constant expression'
HFA8AACB1DC9D: '%select{읽기|읽기|대입|증가|감소|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>}0 volatile-qualified type %1은 상수 표현식에서 허용되지 않습니다'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of subobject of|destruction of|read of}0 %select{object outside its lifetime|uninitialized object}1 is not allowed in a constant expression'
H030F1EA383B2: '%select{읽기|읽기|대입|증가|감소|멤버 호출|dynamic_cast|typeid 적용|하위 객체의 생성|소멸|읽기}0 %select{객체의 생명주기가 종료된 후의 객체|초기화되지 않은 객체}1는 상수 표현식에서 허용되지 않습니다'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of subobject of|destruction of|read of}0 member %1 of union with %select{active member %3|no active member}2 is not allowed in a constant expression'
HAA36C87281CE: '%select{읽기|읽기|대입|증가|감소|멤버 호출|dynamic_cast|typeid 적용|부분 객체 생성|소멸|읽기}0 멤버 %1의 union의 %select{활성 멤버 %3|활성 멤버 없음}2는 상수 표현식에서 허용되지 않습니다'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 %select{temporary|variable}1 whose %plural{8:storage duration|:lifetime}0 has ended'
H1E2EE7FC7CDC: '%select{읽기|읽기|에 대한 대입|증가|감소|멤버 호출|dynamic_cast|typeid 적용|생성|소멸|읽기}0 %select{임시 객체|변수}1 의 %plural{8:저장 기간|:생명 주기}0가 종료되었습니다'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 dereferenced null pointer is not allowed in a constant expression'
H22FE9FDFDD6D: '%select{읽기|읽기|대입|증가|감소|멤버 호출|dynamic_cast의|typeid 적용된|생성|소멸|읽기}0 디레퍼런스된 null 포인터는 상수 표현식에서 허용되지 않습니다'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 dereferenced one-past-the-end pointer is not allowed in a constant expression'
H0D344CA7C10F: '%select{읽기|읽기|할당|증가|감소|멤버 호출|dynamic_cast 적용|typeid 적용|생성|소멸|읽기}0의 해제된 종료 이후 포인터는 상수 표현식에서 허용되지 않습니다.'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 element of array without known bound is not allowed in a constant expression'
H5DD079C28614: '%select{읽기|읽기|대입에 대한|증가|감소|의 멤버 호출|의 dynamic_cast|에 적용된 typeid|의 생성|의 소멸|읽기}0 요소에 대한 접근은 상수 표현식에서 허용되지 않습니다.'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 heap allocated object that has been deleted'
H0F4326DA1EA9: '%select{읽기|읽기|대입|증가|감소|멤버 호출|dynamic_cast의|typeid 적용|생성|파괴|읽기}0 할당된 힙 객체가 삭제된 후 수행된'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 mutable member %1 is not allowed in a constant expression'
H08EBC2661AFA: '%select{읽기|읽기|대입|증가|감소|멤버 호출|dynamic_cast|typeid 적용|생성|소멸|읽기}0 mutable member %1은 상수 표현식에서 허용되지 않습니다'
# "%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 object '%1' whose value is not known"
H2547ED9973E0: "%select{읽기|읽기|대입|증가|감소|멤버 호출|dynamic_cast|typeid 적용|생성|파괴|읽기}0 객체 '%1'의 값이 알려지지 않았습니다"
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 temporary is not allowed in a constant expression outside the expression that created the temporary'
H1A04D5C0C6D4: '%select{읽기|읽기|대입|증가|감소|멤버 호출|dynamic_cast 변환|typeid 적용|생성|파괴|읽기}0 일시적 객체는 상수 표현식에서 일시적 객체를 생성한 표현식 밖에서 허용되지 않습니다'
# '%select{reading|writing}1 the value pointed to by %0 requires holding %select{any mutex|any mutex exclusively}1'
H20B2C79559EA: '%select{읽기|쓰기}1 %0가 가리키는 값에 접근하려면 %select{어떤 뮤텍스|어떤 뮤텍스를 배타적으로}1 획득해야 합니다'
# '%select{reading|writing}1 variable %0 requires holding %select{any mutex|any mutex exclusively}1'
HAB41C50F5547: '%select{읽기|쓰기}1 변수 %0를 사용하려면 %select{어떤 뮤텍스|어떤 뮤텍스를 독점적으로}1 획득해야 합니다'
# "%select{reading|writing}3 the value pointed to by %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
HA3CF53D5D321: '%select{읽기|쓰기}3 %1이 가리키는 값에 접근할 때 %0 %select{%2|%2 전용}3를 보유해야 합니다'
# "%select{reading|writing}3 variable %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
HBF61FE4FFCA3: "%select{읽기|쓰기}3 변수 %1는 %0 %select{'%2'|'%2' 독점적으로}3를 획득해야 합니다"
# "%select{reference|backing array for 'std::initializer_list'}2 %select{|subobject of }1member %0 %select{binds to|is}2 a temporary object whose lifetime is shorter than the lifetime of the constructed object"
H31A36503387B: '%select{std::initializer_list의 백킹 배열|}2%select{ | }1%0 멤버 %select{의 하위 객체는 임시 객체에 바인드됩니다|는 임시 객체입니다}2 해당 임시 객체의 생명 주기는 구성된 객체의 생명 주기보다 짧습니다'
# "%select{reference|backing array for 'std::initializer_list'}2 %select{|subobject of }1member %0 %select{binds to|is}2 a temporary object whose lifetime would be shorter than the lifetime of the constructed object"
H54C5751F42B3: '%select{std::initializer_list의 백킹 배열|}2%select{ | }1%0 멤버 %select{의 하위 객체는 임시 객체에 바인드됩니다|는 임시 객체입니다}2 해당 임시 객체의 생명 주기는 구성된 객체의 생명 주기보다 짧을 것입니다'
# '%select{reference|pointer}0 member declared here'
H8AC5A0A64CFD: '%select{reference|pointer}0 여기서 선언된 멤버'
# '%select{reinterpret_cast|C-style cast}0 from %1 to %2 changes address space of nested pointers'
HDAB148B74E30: '%select{reinterpret_cast|C-style cast}0에서 %1에서 %2로의 변환은 중첩된 포인터의 주소 공간을 변경합니다'
# '%select{reinterpret_cast|dynamic_cast|%select{this conversion|cast that performs the conversions of a reinterpret_cast}1|cast from %1}0 is not allowed in a constant expression%select{| in C++ standards before C++20||}0'
H1688ED0E5178: '%select{reinterpret_cast|dynamic_cast|%select{이 변환|reinterpret_cast 변환을 수행하는 캐스트}|%1 형식의 캐스트}0은 상수 표현식에서 허용되지 않습니다%select{| C++20 이전 표준에서는||}0'
# '%select{remainder|division}0 by zero is undefined'
HDDF6DBF3AFB2: '%select{나머지|나눗셈}0은 0으로 나누면 정의되지 않습니다'
# "%select{return type|parameter type|property}1 may not be qualified with '__ptrauth'; type is %0"
H89CAD73DCBC0: "%select{반환 형식|매개변수 형식|속성}1은 '__ptrauth' 자격 증명으로 지정할 수 없습니다. 형식은 %0입니다"
# '%select{returning|passing}0 a VL-dependent argument %select{from|to}0 a function with a different streaming-mode is undefined behaviour when the streaming and non-streaming vector lengths are different at runtime'
HD835E99E7B94: '%select{반환하는|전달하는}0 VL 의존 인수 %select{에서|로}0 스트리밍 모드가 다른 함수는 streaming 및 non-streaming 벡터 길이가 실행 시 다른 경우 정의되지 않은 동작입니다'
# '%select{returning|passing}0 a VL-dependent argument %select{from|to}0 a locally streaming function is undefined behaviour when the streaming and non-streaming vector lengths are different at runtime'
H78DE8F398FA2: '%select{반환하는|전달하는}0 VL에 의존적인 인수 %select{에서|로}0 지역 스트리밍 함수는 스트리밍 및 비스트리밍 벡터 길이가 실행 시 다를 때 정의되지 않은 동작을 유발합니다'
# '%select{return|parameter|variable|field|instance variable|synthesized instance variable}0 type %1 is an abstract class'
H83DAE33A1A29: '%select{반환|매개변수|변수|필드|인스턴스 변수|합성된 인스턴스 변수}0 유형 %1은 추상 클래스입니다'
# "%select{self-|array |pointer }0comparison always evaluates to %select{a constant|true|false|'std::strong_ordering::equal'}1"
H25C7EE9B164E: "%select{자기-| array | pointer }0 비교는 항상 %select{상수|참|거짓|'std::strong_ordering::equal'}1로 평가됩니다."
# "%select{shader model|Vulkan environment|shader stage}0 '%1' in target '%2' is invalid for HLSL code generation"
H559D5EF03AE6: "%select{쉐이더 모델|Vulkan 환경|쉐이더 스테이지}0 '%1'은 타겟 '%2' 내에서 HLSL 코드 생성에 유효하지 않습니다."
# "%select{shader model|Vulkan environment|shader stage}0 is required as %select{OS|environment}1 in target '%2' for HLSL code generation"
H2955A7AC1204: "%select{쉐이더 모델|바이크ン 환경|쉐이더 단계}0은(는) HLSL 코드 생성을 위해 대상 '%2'에서 %select{OS|환경}1로 지정되어야 합니다"
# '%select{signed value|extra discriminator|blended pointer|blended integer}0 must have %select{pointer|integer|pointer or integer}1 type; type here is %2'
HA4822404707C: '%select{부호 있는 값|추가 구분자|복합 포인터|복합 정수}0는 %select{포인터|정수|포인터 또는 정수}1 type이어야 합니다; 여기서의 type은 %2입니다'
# "%select{signed |}0'size_t' literal is out of range of possible %select{signed |}0'size_t' values"
HADACA5CF45B7: "%select{부호 있는 |}0'size_t' 리터럴은 가능한 %select{부호 있는 |}0'size_t' 값 범위를 벗어났습니다"
# '%select{signed|unsigned}0 _BitInt must have a bit size of at least %select{2|1}0'
H866585566251: '%select{부호 있는|부호 없는}0 _BitInt의 비트 크기는 최소 %select{2|1}0 이상이어야 합니다'
# '%select{signed|unsigned}0 _BitInt of bit sizes greater than %1 not supported'
HB66515AEE2F3: '%select{부호화|무부호}0 _BitInt의 비트 크기가 %1보다 크면 지원되지 않습니다'
# "%select{source|destination}2 of '%select{%select{memcpy|wmemcpy}1|%select{memmove|wmemmove}1}0' is %3"
H752C91AB4DE4: "%select{원본|목적지}2의 '%select{%select{memcpy|wmemcpy}1|%select{memmove|wmemmove}1}0'은 %3입니다."
# "%select{statement after '#pragma omp %1' must be a for loop|expected %2 for loops after '#pragma omp %1'%select{|, but found only %4}3}0"
H5AE78EDFB051: "%select{'#pragma omp %1' 이후 문장은 for 루프여야 합니다|%2 개의 for 루프가 '#pragma omp %1' 이후 필요합니다%select{|, 하지만 %4 개만 발견되었습니다}3}0"
# '%select{statement|directive}0 outside teams construct here'
HCEC20E30EFC9: '%select{문장|지시문}0이 teams 구문 밖에서 여기에 있습니다'
# "%select{static data member is predetermined as shared|variable with static storage duration is predetermined as shared|loop iteration variable is predetermined as private|loop iteration variable is predetermined as linear|loop iteration variable is predetermined as lastprivate|constant variable is predetermined as shared|global variable is predetermined as shared|non-shared variable in a task construct is predetermined as firstprivate|variable with automatic storage duration is predetermined as private}0%select{|; perhaps you forget to enclose 'omp %2' directive into a parallel or another task region?}1"
HF1446F769957: "%select{정적 데이터 멤버는 공유로 미리 결정되었습니다|스토리지 기간이 정적인 변수는 공유로 미리 결정되었습니다|루프 반복 변수는 private으로 미리 결정되었습니다|루프 반복 변수는 linear으로 미리 결정되었습니다|루프 반복 변수는 lastprivate으로 미리 결정되었습니다|상수 변수는 공유로 미리 결정되었습니다|전역 변수는 공유로 미리 결정되었습니다|작업 구조체에서 non-shared 변수는 firstprivate으로 미리 결정되었습니다|자동 스토리지 기간 변수는 private으로 미리 결정되었습니다}0%select{|; 'omp %2' 지시문을 병렬 또는 다른 작업 영역에 포함하지 않았을 수 있습니다}1"
# "%select{string|character|boolean|numeric}0 literal must be prefixed by '@' in a collection"
H437BC3E10750: "%select{문자열|문자|부울|수치형}0 리터럴은 컬렉션 내에서 '@'로 시작되어야 합니다"
# "%select{string|numeric}0 literal must be prefixed by '@'"
HE32E641B2BF1: "%select{문자열|수치}0 리터럴은 '@'로 시작해야 합니다"
# '%select{struct|interface|class}0 with virtual base %plural{1:class|:classes}1 is not a literal type'
H74349A7BD7CA: '%select{구조체|인터페이스|클래스}0는 가상 기반 %plural{1:클래스|:클래스들}1을 가지며 리터럴 타입이 아닙니다'
# '%select{struct|interface|class}0%select{| template}1 %2 was previously declared as a %select{struct|interface|class}3%select{| template}1; this is valid, but may result in linker errors under the Microsoft C++ ABI'
H2D10AD8D0564: '%select{struct|interface|class}0%select{| template}1 %2는 이전에 %select{struct|interface|class}3%select{| template}1로 선언되었습니다. 이는 유효하지만 Microsoft C++ ABI에서 링커 오류가 발생할 수 있습니다'
# '%select{struct|interface|union|class|enum}0 %1 does not declare any constructor to initialize its non-modifiable members'
HAB227F7E6966: '%select{struct|interface|union|class|enum}0 %1는 비변경 가능 멤버를 초기화하는 생성자를 선언하지 않았습니다'
# '%select{struct|union|enum}0 defined within a struct or union is not visible in C++'
H20DE76C1377D: '구조체 또는 공용체 내에 정의된 %select{구조체|공용체|열거형}0은(는) C++에서 볼 수 없습니다.'
# '%select{struct|union}0 kernel parameters may not contain pointers'
H1723C50B8752: '%select{struct|union}0 커널 파라미터에는 포인터를 포함할 수 없습니다'
# '%select{struct|union}0 without named members is a GNU extension'
HBECD0A183C46: '이름이 지정되지 않은 %select{구조체|공용体型}0는 GNU 확장 기능입니다'
# '%select{subtraction|addition}0 of address-of-label expressions is not supported with ptrauth indirect gotos'
H131327EB0D0D: '%select{뺄셈|덧셈}0 라벨 주소 표현식의 사용은 ptrauth 간접 goto와 함께 지원되지 않습니다'
# '%select{template type|non-type template|template template}0 parameter%select{| pack}1 conflicts with previous %select{template type|non-type template|template template}0 parameter%select{ pack|}1'
HACD51B91D6D5: '%select{템플릿 유형|비유형 템플릿|템플릿 템플릿}0 매개변수%select{| pack}1은 이전 %select{템플릿 유형|비유형 템플릿|템플릿 템플릿}0 매개변수%select{ pack|}1과 충돌합니다'
# '%select{template type|non-type template|template template}0 parameter%select{| pack}1 does not match %select{template type|non-type template|template template}0 parameter%select{ pack|}1 in template argument'
H42D8D01F5E06: '%select{템플릿 형식|비형식 템플릿|템플릿 템플릿}0 매개변수%select{ 패키지|}1가 템플릿 인수에서의 %select{템플릿 형식|비형식 템플릿|템플릿 템플릿}0 매개변수%select{ 패키지|}1와 일치하지 않습니다'
# '%select{template|partial|member}0 specialization cannot be declared __module_private__'
H0A90D5264D30: '%select{템플릿|부분|멤버}0 전문화는 __module_private__로 선언할 수 없습니다'
# '%select{temporary %select{whose address is used as value of|%select{|implicitly }2bound to}4 %select{%select{|reference }4member of local variable|local %select{variable|reference}4}1|array backing %select{initializer list subobject of local variable|local initializer list}1}0 %select{%3 |}2will be destroyed at the end of the full-expression'
H1685FEE7827D: '%select{임시 %select{의 주소가 값으로 사용된|%select{|암시적으로 }2바인딩된}4 %select{%select{|참조 }4멤버를 가진 지역 변수|지역 %select{변수|참조}4}1|array backing %select{지역 변수의 initializer list subobject|지역 initializer list}1}0 %select{%3 |}2전체 표현식이 끝날 때 파괴됩니다'
# "%select{the message|the expression}0 in %select{a static assertion|this asm operand}0 must be a string literal or an object with 'data()' and 'size()' member functions"
H320EEB9B1530: "%select{메시지|표현식}0은 %select{정적 애서션|이 어셈블리 연산자}0에서 문자열 리터럴이거나 'data()' 및 'size()' 멤버 함수를 갖는 객체여야 합니다"
# '%select{the message|the expression}0 in %select{a static assertion|this asm operand}0 must be produced by a constant expression'
H9571480E2335: '%select{메시지|표현식}0는 %select{정적 assertion|이 asm 인자}0에 상수 표현식으로 평가되어야 합니다'
# "%select{the message|the expression}0 in %select{a static assertion|this asm operand}0 must have a '%select{size|data}1()' member function returning an object convertible to '%select{std::size_t|const char *}1'"
HE077A8EBD022: "%select{메시지|표현식}0은 %select{정적 액서션|이 어셈블리 연산자}0 내에서 '%select{size|data}1()' 멤버 함수를 가져야 하며, 이 함수는 %select{std::size_t|const char *}1로 변환 가능한 객체를 반환해야 합니다"
# '%select{the message|the expression}0 in %select{this static assertion|this asm operand}0 is not a constant expression'
H1136016D414E: '%select{메시지|표현식}0이 %select{이 정적 assertion|이 asm 연산자}0에 상수 표현식이 아닙니다'
# '%select{too few|too many}0 template arguments for %select{class template|function template|variable template|alias template|template template parameter|concept|template}1 %2'
HA3BFC0466346: '%select{너무 적은|너무 많은}0 템플릿 인수를 %select{클래스 템플릿|함수 템플릿|변수 템플릿|별칭 템플릿|템플릿 템플릿 매개변수|컨셉|템플릿}1 %2에 대해 제공했습니다'
# '%select{too few|too many}0 template parameters in template %select{|template parameter }1redeclaration'
H2FC8E4427754: '%select{템플릿 매개변수가 너무 적음|템플릿 매개변수가 너무 많음}0 템플릿 %select{ |템플릿 매개변수 }1재선언'
# '%select{too few|too many}0 template parameters in template template argument'
HEDDF73011D6C: '%select{너무 적은|너무 많은}0 template 매개변수가 template template 인수에 있습니다.'
# '%select{too many|too few}0 elements in vector %select{initialization|operand}3 (expected %1 elements, have %2)'
HEB48F48C2E39: '벡터 %select{초기화|연산자}3에 요소가 %select{너무 많음|너무 적음}0 (기대한 %1 요소, %2 요소 있습니다)'
# '%select{type tag|argument}0 index %1 is greater than the number of arguments specified'
H7C0418F179E9: '%select{형식 태그|인자}0 인덱스 %1은 지정된 인자의 수보다 큽니다.'
# '%select{typedef|type alias|type alias template}0 redefinition with different types%diff{ ($ vs $)|}1,2'
H7F72DD3ED811: '%select{typedef|유형 별칭|유형 별칭 템플릿}0 다른 유형으로 재정의%diff{ ($ 대 $)|}1,2'
# '%select{uninitialized use occurs|variable is captured by block}0 here'
H80571A54148A: '%select{초기화되지 않은 사용이 발생합니다|변수가 블록에 포착됩니다}0 여기서'
# "%select{unknown|duplicate}0 modifier %1 in OpenACC modifier-list on '%2' clause"
H8603FBD5B2C6: "OpenACC modifier-list의 '%2' 절에서 %select{알 수 없는|중복된}0 수정자 %1이 발견되었습니다"
# '%select{unknown|unsupported}0 machine mode %1'
HB579643BB1CB: '%select{알 수 없는|지원하지 않는}0 머신 모드 %1'
# '%select{unsafe pointer operation|unsafe pointer arithmetic|unsafe buffer access|function introduces unsafe buffer manipulation|unsafe invocation of %1|field %1 prone to unsafe buffer manipulation}0'
HD969AD0BDB13: '%select{안전하지 않은 포인터 연산|안전하지 않은 포인터 산술|안전하지 않은 버퍼 접근|해당 함수는 안전하지 않은 버퍼 조작을 포함합니다|안전하지 않은 %1 호출|필드 %1은 안전하지 않은 버퍼 조작에 취약합니다}0'
# "%select{unsupported|duplicate|unknown}0%select{| CPU| tune CPU}1 '%2' in the '%select{target|target_clones|target_version}3' attribute string;"
H8412993B41A2: "%select{지원되지 않는|중복된|알 수 없는}0%select{| CPU| tune CPU}1 '%2' %select{target|target_clones|target_version}3 속성 문자열에서 발견됨;"
# "%select{unsupported|duplicate|unknown}0%select{| CPU| tune CPU}1 '%2' in the '%select{target|target_clones|target_version}3' attribute string; '%select{target|target_clones|target_version}3' attribute ignored"
H952DC46C8259: "%select{지원되지 않음|중복|알 수 없음}0%select{| CPU| tune CPU}1 '%2'은 '%select{target|target_clones|target_version}3' 속성 문자열에서 사용할 수 없습니다; '%select{target|target_clones|target_version}3' 속성이 무시되었습니다"
# '%select{using this character in an identifier|starting an identifier with this character}0 is incompatible with C99'
H2BC4F8FF7FD4: '%select{이 문자를 식별자에 사용하는 것은|이 문자로 식별자를 시작하는 것은}0 C99와 호환되지 않습니다'
# "%select{values of type|enum values with underlying type}2 '%0' should not be used as format arguments; add an explicit cast to %1 instead"
H74FA7B9CE6BC: "%select{타입의 값|밑바닥 타입을 가진 열거 값}2 '%0'은 포맷 인수로 사용되어서는 안 됩니다; 대신 %1로 명시적 캐스팅을 추가해야 합니다"
# '%select{value|type}0-dependent expression passed as an argument to debug command'
HF8F02B43BB62: '%select{값|형식}0에 의존적인 표현식이 디버그 명령의 인수로 전달되었습니다'
# '%select{variable|static data member}0 instantiated with function type %1'
HE6193A7D74C4: '%select{변수|정적 데이터 멤버}0 함수 유형 %1로 인스턴스화되었습니다'
# '%select{variable|variable template|variable template partial specialization|variable template explicit specialization}0 %1 declared with deduced type %2 cannot appear in its own initializer'
H7CD30BEC5DE9: '%select{변수|변수 템플릿|변수 템플릿 부분 특수화|변수 템플릿 명시적 특수화}0 %1은(는) 추론된 타입 %2로 선언되었으며 자신의 초기화자에 나타날 수 없습니다.'
# '%select{via initialization of|binding reference}0 variable %select{%2 |}1here'
HB0440A5001E5: '%select{변수 초기화를 통한 |참조 바인딩을 통한}0 %select{%2 |}1여기서'
# "%select{virtual method|function pointer}0 cannot be inferred '%1'"
H57712FD11644: "%select{가상 메서드|함수 포인터}0는 '%1'로 추론할 수 없습니다"
# '%select{void function|void method|constructor|destructor}1 %0 must not return a value'
HE90DDC8579B5: '%select{void 함수|void 메서드|생성자|소멸자}1 %0는 값 반환을 할 수 없습니다'
# '%select{void function|void method|constructor|destructor}1 %0 should not return a value'
H917D4EA3DC61: '%select{void 함수|void 메서드|생성자|소멸자}1 %0는 값을 반환하지 않아야 합니다'
# '%select{wide|Unicode}0 character literals may not contain multiple characters'
HEBA1B65B6166: '%select{너비|유니코드}0 문자 리터럴은 여러 문자를 포함할 수 없습니다'
# "%select{x86|x86-64}0 'interrupt' attribute only applies to functions that have %select{a 'void' return type|only a pointer parameter optionally followed by an integer parameter|a pointer as the first parameter|a %2 type as the second parameter}1"
H6EAE552C7EA8: "%select{x86|x86-64}0 '인터럽트' 어트리뷰트는 %select{반환 타입이 'void'인|포인터 매개변수만을 가진 것, 옵션으로 정수 매개변수가 따라올 수 있음|첫 번째 매개변수가 포인터인|%2 타입이 두 번째 매개변수인}1 함수에만 적용됩니다"
# "%select{|'%1-%2' }0diagnostics %select{with '%2' severity |}0%select{expected|seen}3 but not %select{seen|expected}3: %4"
H6E1DC1644300: "%select{ |'%1-%2' }0진단 %select{중요도 '%2'인 |}0%select{예상된|확인된}3지만 %select{확인된|예상된}3되지 않았습니다: %4"
# '%select{|a template declaration|an explicit template specialization|an explicit template instantiation}0 can only %select{|declare|declare|instantiate}0 a single entity'
HCEE3630F178B: '%select{ |템플릿 선언|명시적 템플릿 특수화|명시적 템플릿 인스턴스화}0은 단일 엔티티만 %select{ |선언|선언|인스턴스화}0할 수 있습니다'
# "%select{|captured }1%0 parameter marked 'called_once' is never called"
H5EDD8753404F: "%select{|포착된 }1%0 매개변수는 'called_once'로 표시되었으나 호출되지 않았습니다"
# '%select{|captured }1completion handler is never called'
H31A1FA39F285: '%select{|포획된 }1완료 핸들러는 호출되지 않습니다'
# "%select{|change to 'snprintf' for explicit bounds checking | buffer pointer and size may not match|string argument is not guaranteed to be null-terminated|'va_list' is unsafe}0"
H071DEF637982: "%select{|'snprintf'로 변경하여 명시적인 경계 확인을 수행하세요 | 버퍼 포인터와 크기가 일치하지 않을 수 있습니다|string 인수는 NULL로 종료되지 않을 수 있습니다|'va_list'는 안전하지 않습니다}0"
# '%select{|direct }0%select{method|property}1 declaration conflicts with previous %select{|direct }2declaration of %select{method|property}1 %3'
H1D02391D3A58: '%select{ |직접 }0%select{메서드|프로퍼티}1 선언이 이전 %select{ |직접 }2 선언과 충돌합니다 %select{메서드|프로퍼티}1 %3'
# '%select{|empty }0%select{struct|union}1 has size 0 in C, %select{size 1|non-zero size}2 in C++'
HEA8D8C4B49F9: '%select{|비어 있는 }0%select{구조体型|공용体型}1은 C에서 크기가 0이며, %select{크기 1|0이 아닌 크기}2입니다'
# "%select{|implicit }0use of 'this' pointer is only allowed within the evaluation of a call to a 'constexpr' member function"
HE1347141F3D2: "%select{|암시적 }0'this' 포인터의 사용은 'constexpr' 멤버 함수 호출의 평가 중에만 허용됩니다."
# '%select{|implicitly }1declared %select{private|protected}0 here'
H8D12655CD9C3: '%select{ |암묵적으로 }1선언된 %select{private|protected}0 여기에서'
# "%select{|incremented }0enumerator value which exceeds the range of 'int' is a C23 extension (%1 is too %select{small|large}2)"
H7317CEFA834D: "%select{ |증분된 }0열거자 값이 'int'의 범위를 초과하면 C23 확장 기능입니다 (%1이 %select{작습니다|큽니다}2)"
# "%select{|incremented }0enumerator value which exceeds the range of 'int' is incompatible with C standards before C23 (%1 is too %select{small|large}2)"
H02CD4F5E389B: "%select{ |증가된 }0열거형 값이 'int'의 범위를 초과하면 C23 이전의 C 표준과 호환되지 않습니다. (%1는 너무 %select{작|크}2)"
# '%select{|member|base class}0 %1 declared here'
H83331E20A1A3: '%select{|멤버|기본 클래스}0 %1 여기서 선언되었습니다'
# '%select{|member}0 using declaration %1 instantiates to an empty pack'
H03EFD19ED92A: '%select{|멤버}0 using 선언문 %1은 빈 패킹으로 인스턴스화됩니다'
# '%select{|non-aggregate }0type %1 cannot be initialized with an initializer list'
H94A9DAA06E2F: '%select{|집합체가 아닌 }0타입 %1은 초기화자 목록으로 초기화할 수 없습니다'
# '%select{|overriding }1method cannot be unavailable on %0 when %select{the protocol method it implements|its overridden method}1 is available'
H11BFB9C90008: '오버라이딩 메서드는 %select{|오버라이딩 }1%0에서 사용 불가능할 수 없습니다. %select{구현하는 프로토콜 메서드|오버라이딩된 메서드}1이 사용 가능할 때'
# '%select{|overriding }4method %select{introduced after|deprecated before|obsoleted before}0 %select{the protocol method it implements|overridden method}4 on %1 (%2 vs. %3)'
H3102E4185799: '%select{|오버라이딩 }4메서드 %select{이후에 도입된|이전에 비추천된|이전에 폐기된}0 %select{구현하는 프로토콜 메서드|오버라이딩된 메서드}4에서 %1 (%2 vs. %3)'
# '%select{|pointer to |reference to }0incomplete type %1 is not allowed in exception specification'
HBD4554E2864A: '%select{ |포인터 |참조 }0부분 완성된 형식 %1은 예외 사양에서 허용되지 않습니다'
# "%select{|previous }0'hint' clause with value '%1'"
HBBFA3E1A9C6B: "%select{ |이전 }0'hint' 절의 값 '%1'"
# "%select{|previous }0directive with no 'hint' clause specified"
H8CE1C8734C39: "%select{ |이전 }0지시문에 'hint' 절이 지정되지 않았습니다."
# '%select{|previous }0using declaration'
H5AE3701DBB92: '%select{|이전 }0사용 선언'
# '%select{|previous }0using-enum declaration'
H5BC63E8C8F5E: '%select{ |이전 }0using-enum 선언'
# '%select{|reference to }0sizeless type %1 is not allowed in exception specification'
H3E89611A15B6: '%select{|크기 없는 형식 %1에 대한 참조 }0예외 지정에 허용되지 않습니다'
# '%select{|second }0%1 token is here'
H00E98F1D44F7: '%select{|두 번째 }0%1 토큰이 여기 있습니다'
# '%select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2 uses deleted function%select{|: %4}3'
HD806C936F5D9: '%select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0에서 %1에서 %2로 변환하는 %select{|: %4}3 삭제된 함수를 사용합니다'
# '%select{|success |failure }0memory order argument to atomic operation is invalid'
HFAC869D2863E: '%select{|성공 |실패 }0원자 연산의 메모리 순서 인수는 유효하지 않음'
# '%select{|type aware }0%select{|destroying }1%2 cannot take a dependent type as its %ordinal3 parameter; use %4 instead'
H965362A13DF2: '%select{|type aware }0%select{|destorying }1%2의 %ordinal3 매개변수는 종속 형식을 취할 수 없습니다. %4를 사용하세요'
# '%select{|type aware }0%select{|destroying }1%2 cannot take a dependent type as its %ordinal3 parameter; use %5 (%4) instead'
H8DC61B9CED29: '%select{|type aware }0%select{|destorying }1%2의 %ordinal3 매개변수는 종속 형식을 취할 수 없습니다. %5 (%4)를 사용하세요'
# '%select{|type aware }0%select{|destroying }1%2 must have at least %select{|one|two|three|four|five}3 parameter%s3'
HDBF7BEA2895C: '%select{|type aware }0%select{|destorying }1%2는 최소 %select{|1개|2개|3개|4개|5개}3 매개변수가 필요합니다'
# '%select{|type aware }0%select{|destroying }1%2 takes type %5 (%4) as %ordinal3 parameter'
HCA17F3BCF987: '%select{|type aware }0%select{|destorying }1%2는 %ordinal3 매개변수로 %5 (%4) 형식을 취합니다'
# "%select{|umbrella }0header '%1' not found"
H3FDB64D57A92: "%select{|umbrella }0헤더 '%1'을 찾을 수 없음"
# '%select{|unsafe_unretained|strong|weak}1 property %0 may not also be declared %select{|__unsafe_unretained|__strong|__weak|__autoreleasing}2'
HC9D6BEED9F9F: '%select{|unsafe_unretained|strong|weak}1 프로퍼티 %0는 또한 %select{|__unsafe_unretained|__strong|__weak|__autoreleasing}2로 선언될 수 없습니다'
# '%select{||reinterpret_cast||C-style cast||}0 from scalar %1 to vector %2 of different size'
HFF11D1B4EA50: '%select{||reinterpret_cast||C-style cast||}0를 사용한 스칼라 %1에서 다른 크기의 벡터 %2로의 캐스팅'
# '%select{||reinterpret_cast||C-style cast||}0 from vector %1 to scalar %2 of different size'
H4BC2B3E593E1: '%select{||reinterpret_cast||C 스타일 캐스트||}0를 사용하여 벡터 %1에서 다른 크기의 스칼라 %2로 변환'
# '%select{||reinterpret_cast||C-style cast||}0 from vector %1 to vector %2 of different size'
H855233AE0D42: '%select{||reinterpret_cast||C-style cast||}0에서 벡터 %1에서 다른 크기의 벡터 %2로 변환'
# "%select{|||||virtual function called on|dynamic_cast applied to|typeid applied to|construction of|destruction of}0 object '%1' whose dynamic type is not constant"
H292A692F3948: "%select{|||||가상 함수 호출됨|dynamic_cast 적용됨|typeid 적용됨|생성됨|소멸됨}0 '%1' 객체의 동적 타입이 상수형이 아닙니다"
# "'##' cannot appear at end of __VA_OPT__ argument"
H2B78B6D67ACA: "'##'는 __VA_OPT__ 인수의 마지막에 사용될 수 없습니다"
# "'##' cannot appear at end of macro expansion"
H0D880CABAC3F: "'##'는 매크로 확장의 끝에서 나타날 수 없습니다"
# "'##' cannot appear at start of __VA_OPT__ argument"
H2F2411264E60: "'##'는 __VA_OPT__ 인수의 시작 부분에 사용할 수 없습니다"
# "'##' cannot appear at start of macro expansion"
H49669D0F3359: "'##'는 매크로 확장의 시작 부분에 출현할 수 없습니다"
# "'#include <filename>' attaches the declarations to the named module '%0', which is not usually intended; consider moving that directive before the module declaration"
HE8759FB5FF70: "'#include <filename>' 지시문은 선언들을 지정된 모듈 '%0'에 연결합니다. 이는 일반적으로 의도한 것이 아닙니다; 해당 지시문을 모듈 선언 전으로 이동하는 것을 고려하세요."
# "'#pragma %0' can only appear at file scope"
HCE0F9341D433: "'#pragma %0'는 파일 범위에서만 사용할 수 있습니다"
# "'#pragma %0' can only appear at file scope or at the start of a compound statement"
HD3947EF6D864: "'#pragma %0'는 파일 범위 또는 복합 문의 시작 부분에서만 사용할 수 있습니다"
# "'#pragma %0' is not supported on this target - ignored"
H10F342B08150: "'#pragma %0'는 이 타겟에서 지원되지 않습니다 - 무시됩니다"
# "'#pragma STDC FENV_ACCESS ON' is illegal when precise is disabled"
H17CE846EF8B0: "'#pragma STDC FENV_ACCESS ON'은 'precise'가 비활성화되었을 때 사용할 수 없습니다"
# "'#pragma alloc_text' is applicable only to functions"
H29BA150C71BF: '‘#pragma alloc_text’는 함수에만 적용됩니다.'
# "'#pragma alloc_text' is applicable only to functions with C linkage"
H8053A181B977: '#pragma alloc_text는 C 언어 연결성을 가진 함수에만 적용 가능합니다'
# "'#pragma clang arc_cf_code_audited' was not ended within this file"
H3175433AA2FB: "'#pragma clang arc_cf_code_audited'는 이 파일 내에서 종료되지 않았습니다."
# "'#pragma clang assume_nonnull' was not ended within this file"
H344021929D5B: "'#pragma clang assume_nonnull'는 이 파일 내에서 종료되지 않았습니다"
# "'#pragma clang attribute %select{%1.|}0pop' with no matching '#pragma clang attribute %select{%1.|}0push'"
H170B16ACF46E: "'#pragma clang attribute %select{%1.|}0pop'에 매칭되는 '#pragma clang attribute %select{%1.|}0push' 없음"
# "'#pragma clang attribute push' regions ends here"
HF6A5F5655AB0: "'#pragma clang attribute push' 영역이 여기서 끝납니다"
# "'#pragma clang attribute' attribute with no matching '#pragma clang attribute push'"
HAAE6327E2566: "'#pragma clang attribute' 속성에 일치하는 '#pragma clang attribute push'가 없습니다"
# "'#pragma comment %0' ignored"
HEB14674C1594: "'#pragma comment %0' 무시됨"
# "'#pragma float_control push/pop' can only appear at file or namespace scope or within a language linkage specification"
H053264F8F924: "'#pragma float_control push/pop'는 파일 또는 네임스페이스 범위 또는 언어 연관 지정 내에서만 나타날 수 있습니다"
# "'#pragma float_control(except, on)' is illegal when precise is disabled"
H28022D025F51: "'#pragma float_control(except, on)'는 precise가 비활성화되었을 때 사용할 수 없습니다"
# "'#pragma float_control(precise, off)' is illegal when except is enabled"
H922887ACFECE: "'#pragma float_control(precise, off)' 지시문은 except가 활성화되었을 때 사용할 수 없습니다"
# "'#pragma float_control(precise, off)' is illegal when fenv_access is enabled"
HAFA440F76585: "'#pragma float_control(precise, off)'는 fenv_access가 활성화되었을 때 허용되지 않습니다"
# "'#pragma init_seg' is only supported when targeting a Microsoft environment"
H4E91F2EF3757: '#pragma init_seg는 마이크로소프트 환경을 대상으로 할 때만 지원됩니다.'
# "'#pragma omp %0' %select{|with '%2' clause }1cannot be an immediate substatement"
HA805BCE4C312: "'#pragma omp %0' %select{|조건절 '%2'를 사용하여 }1즉각적인 하위 문이 될 수 없습니다"
# "'#pragma omp %0' directive must appear only in file scope"
H3C04CBDE708E: "'#pragma omp %0' 디렉티브는 파일 범위에서만 나타나야 합니다"
# "'#pragma omp %0' must appear in the scope of the %q1 variable declaration"
HCD521713958F: "'#pragma omp %0'는 %q1 변수 선언의 범위 내에서 나타나야 합니다"
# "'#pragma omp %0' must precede all references to variable %q1"
HA982E769431D: "'#pragma omp %0'는 변수 %q1에 대한 모든 참조 앞에 오아야 합니다"
# "'#pragma omp declare %select{simd|variant}0' can only be applied to functions"
HC2DB961C6B39: "'#pragma omp declare %select{simd|variant}0'은(는) 함수에만 적용할 수 있습니다"
# "'#pragma omp declare variant' cannot be applied for function after first usage; the original function might be used"
H504957D176C7: "'#pragma omp declare variant'는 함수의 첫 사용 이후에는 적용할 수 없습니다; 원본 함수가 이미 사용되었을 수 있습니다"
# "'#pragma omp declare variant' cannot be applied to the function that was defined already; the original function might be used"
HB5A7CD5EEB6F: "'#pragma omp declare variant'는 이미 정의된 함수에는 적용할 수 없습니다; 원본 함수가 사용될 수 있습니다"
# "'#pragma omp declare variant' does not support %select{function templates|virtual functions|deduced return types|constructors|destructors|deleted functions|defaulted functions|constexpr functions|consteval function}0"
H240B964685D1: "'#pragma omp declare variant'는 %select{함수 템플릿|가상 함수|추론된 반환 형식|생성자|소멸자|삭제된 함수|디폴트화된 함수|constexpr 함수|consteval 함수}0을 지원하지 않습니다."
# "'#pragma omp declare variant' is not compatible with any target-specific attributes"
HDFFC2CD6FA69: "'#pragma omp declare variant'는 어떤 타겟-특정 속성과도 호환되지 않습니다"
# "'#pragma omp end assumes' with no matching '#pragma omp begin assumes'"
HAF63C041427E: "'#pragma omp end assumes'에 매칭되는 '#pragma omp begin assumes'가 없습니다."
# "'#pragma omp end declare variant' with no matching '#pragma omp begin declare variant'"
HD60959180819: "'#pragma omp end declare variant'에 대응하는 '#pragma omp begin declare variant'가 없습니다"
# "'#pragma unsafe_buffer_usage' was not ended"
H8FB2F039CC57: "'#pragma unsafe_buffer_usage'가 종료되지 않았습니다"
# "'$' in identifier"
HB5654708DC14: "'$' 식별자 내에 포함됨"
# "'%%n' specifier not supported on this platform"
HC8B8AD4E064B: "'%%n' 지정자는 이 플랫폼에서는 지원되지 않습니다"
# "'%0' %select{length modifier|conversion specifier}1 is not supported by ISO C"
H5FE655A569EF: "'%0' %select{길이 수정자|변환 지정자}1은(는) ISO C에서 지원하지 않습니다"
# "'%0' ABI is not supported with FPU"
H0E4CA678D6B9: "'%0' ABI는 FPU와 호환되지 않습니다"
# "'%0' action ignored; '%1' action specified previously"
H140C3ABC4AE4: "'%0' 액션이 무시되었습니다; '%1' 액션이 이미 지정되었습니다"
# "'%0' and '%1' clause are mutually exclusive and may not appear on the same directive"
H124967FEEE58: "'%0'과 '%1' 절은 상호 배타적이며 동일한 지시문에 함께 사용될 수 없습니다"
# "'%0' argument on '%1' clause is not permitted on a%select{|n orphaned}2 '%3' construct%select{| associated with a '%5' compute construct}4"
H43AC213E21A0: "'%0' 인수는 '%1' 절에서 %select{|고아된}2 '%3' 구조체%select{| '%5' 계산 구조체와 연관된}4 에서 허용되지 않습니다."
# "'%0' argument to '%1' clause not allowed on a '%2' construct%select{| associated with a '%4' construct}3 that has a '%5' clause"
H08457CF75CEB: "'%0' 인수는 '%1' 절에 '%2' 구조체%select{| '%4' 구조체와 연결된}3에 적용할 수 없습니다. '%5' 절을 가진 경우입니다."
# "'%0' as a module map name is deprecated, rename it to %select{module.modulemap|module.private.modulemap}1%select{| in the 'Modules' directory of the framework}2"
H871445ACDF0B: "'%0'을 모듈 맵 이름으로 사용하는 것은 더 이상 권장되지 않습니다. %select{module.modulemap|module.private.modulemap}1%select{| 프레임워크의 'Modules' 디렉토리에}2 이름을 변경해야 합니다."
# "'%0' attribute cannot be specified on a definition"
H3887172CED45: "'%0' 속성은 정의에 지정될 수 없습니다"
# "'%0' call operates on objects of type %1 while the size is based on a different type %2"
H9E506A66F2D3: "'%0' 호출은 %1 형식의 객체에 작동하지만 크기는 다른 형식 %2를 기반으로 합니다"
# "'%0' can only be used if the target supports the mfhc1 and mthc1 instructions"
HD98657B082CC: "'%0'은(는) 타겟이 mfhc1 및 mthc1 명령어를 지원할 때만 사용할 수 있습니다"
# "'%0' can only be used with the '%1' ABI"
HAC173E806F23: "'%0'은 '%1' ABI에서만 사용할 수 있습니다."
# "'%0' cannot be a part of nested name specifier; did you mean ':'?"
H6E2E8EF01102: "'%0'는 중첩된 이름 지정자的一部分일 수 없습니다. ':'을 의미하지 않았나요?"
# "'%0' cannot be called with %select{a null pointer|a one-past-the-end pointer|a pointer to an object whose lifetime has not yet begun}1"
H9E6A8072EAD3: "'%0'는 %select{null 포인터|배열 끝 바로 다음 위치 포인터|생명 주기가 아직 시작되지 않은 객체의 포인터}1로 호출할 수 없습니다."
# "'%0' cannot be signed or unsigned"
HE82DC08D960E: "'%0'은(는) 부호 있는 또는 부호 없는 형식으로 지정할 수 없습니다"
# "'%0' cannot be used in an unevaluated context"
HACCAB0092430: "'%0'는 평가되지 않은 컨텍스트에서 사용할 수 없습니다"
# "'%0' cannot be used in the handler of a try block"
HCC6C7DE7C0DC: "'%0'는 try 블록의 핸들러에서 사용할 수 없습니다"
# "'%0' cannot be used outside a function"
HF038C50615EF: "'%0'은 함수 밖에서 사용할 수 없습니다."
# "'%0' casts have no effect when not using ARC"
H0985DFE3C8AA: "'%0' 형 변환은 ARC(자동 참조 카운팅)을 사용하지 않을 때 영향을 주지 않습니다."
# "'%0' clause is specified here"
H573F42F97FF4: "'%0' 절은 여기서 지정되었습니다"
# "'%0' clause not allowed on a 'kernels loop' construct that has a '%1' clause with a%select{n| 'num'}2 argument"
HA63B4E6AC69A: "'%0' 구문은 '%1' 구문이 %select{n| 'num'}2 인수를 가진 'kernels loop' 구조에 적용할 수 없습니다"
# "'%0' clause requires 'dispatch' context selector"
H94FAB67C930A: '‘%0’ 절은 ‘dispatch’ 컨텍스트 선택자를 필요로 합니다'
# "'%0' clause specifies a loop count greater than the number of available loops"
H13BED1AA5B60: "'%0' 절은 사용 가능한 루프 수보다 큰 루프 수를 지정합니다"
# "'%0' clause used here"
HC259BC00C8FD: "'%0' 절이 여기서 사용되었습니다"
# "'%0' clause with '%1' modifier cannot be specified if an 'ordered' clause is specified"
HFFE6A9A75740: "'ordered' 절이 지정된 경우에는 '%0' 절과 '%1' 수정자를 지정할 수 없습니다."
# "'%0' clauses cannot be mixed with '%1' clause"
H0A2484D8EEB5: "'%0' 절은 '%1' 절과 혼합될 수 없습니다"
# "'%0' construct is here"
H4E6A1EF91E1B: "'%0' 구조가 여기에 있습니다"
# "'%0' declared as a member pointer to a reference of type %1"
HF4FF87D5007C: "'%0'는 %1 형식의 참조인 멤버 포인터로 선언되었습니다"
# "'%0' declared as a member pointer to void"
HB8704C365E55: "'%0'가 void를 가리키는 멤버 포인터로 선언되었습니다"
# "'%0' declared as a pointer to a reference of type %1"
H95E780665FDE: "'%0'는 %1 형식의 참조에 대한 포인터로 선언되었습니다"
# "'%0' declared as an array with a negative size"
H44D9A6FDB5F3: "'%0'는 음수 크기를 가지는 배열로 선언되었습니다"
# "'%0' declared as array of functions of type %1"
HF167BCD9180C: "'%0'이 %1 형식의 함수 배열로 선언되었습니다."
# "'%0' declared as array of references of type %1"
H07B7977DE9AC: "'%0'은 %1 형식의 참조 배열로 선언되었습니다"
# "'%0' directive cannot follow %select{'%2' directive|other expected directives}1"
H81459AA5C045: "'%0' 지시문은 %select{'%2' 지시문|기대되는 다른 지시문}1 뒤에 오면 안 됩니다."
# "'%0' directive found here"
H689CAA47B15F: "'%0' 지시문이 여기에 있습니다"
# "'%0' does not contain a GCC installation"
H5EA2B901E3DD: "'%0'에 GCC 설치본이 포함되어 있지 않습니다"
# "'%0' does not support '-%1'; flag ignored"
H5F193B6442A3: "‘%0’은 '-%1'을 지원하지 않습니다; 플래그가 무시되었습니다."
# "'%0' does not support '-moutline'; flag ignored"
H8FCF49E8EFFE: "'%0'는 '-moutline'을 지원하지 않습니다; 플래그 무시됨"
# "'%0' file not found"
HE40852833202: "'%0' 파일을 찾을 수 없습니다"
# '\'%0\' file not found with <angled> %select{include|import}1; use "quotes" instead'
HB65E7D8C29D0: '\'%0\' 파일이 <>로 감싸진 %select{include|import}1 문에서 발견되지 않았습니다; 대신 " "를 사용하세요'
# "'%0' file not found, did you mean '%1'?"
HA3BAEA90173D: "'%0' 파일이 발견할 수 없습니다. '%1'을(를) 의미하시는 건가요?"
# "'%0' function must have a prototype"
H161348B5A00F: "'%0' 함수는 프로토타입이 있어야 합니다"
# "'%0' ignored on this declaration"
H3A73EC6937F0: "'%0' 이 선언에서는 무시됩니다"
# "'%0' included multiple times, additional include site here"
H67346CC37DF8: "'%0'이(가) 여러 번 포함되었습니다, 추가적인 포함 위치입니다"
# "'%0' included multiple times, additional include site in header from module '%1'"
HC2226976DFB3: "'%0'이(가) 여러 번 포함되었습니다: 추가 include 위치는 모듈 '%1'의 헤더에서 발견되었습니다"
# "'%0' invalid for input of type %1"
H0F254F5D0DEC: "'%0'은(는) 유형 %1의 입력에 유효하지 않습니다."
# "'%0' is a C11 extension"
HACD9CD0EB9B2: "'%0'은 C11 확장입니다"
# "'%0' is a C2y extension"
H46F684F39EE1: "'%0'은 C2y 확장 기능입니다"
# "'%0' is a C99 extension"
H553903351EEE: "'%0'는 C99 확장 문법입니다"
# "'%0' is a context %select{set|selector|property}1 not a context %select{set|selector|property}2"
H0E6818DF21E4: "'%0'는 %select{set|selector|property}1 컨텍스트가 아니라 %select{set|selector|property}2 컨텍스트입니다"
# "'%0' is a keyword in C++11"
H6E1B6EF2D90A: "'%0'는 C++11의 키워드입니다"
# "'%0' is a keyword in C++20"
HED77874B7FB4: "'%0'는 C++20에서 예약어입니다"
# "'%0' is a keyword in C23"
H55337290EE76: "'%0'은 C23의 키워드입니다"
# "'%0' is a keyword in C99"
H305C2462E219: '‘%0’는 C99의 키워드입니다'
# "'%0' is bound to current loop, GCC binds it to the enclosing loop"
H6C2FAF9A98CF: "'%0'는 현재 루프에 바인딩됩니다. GCC는 이를 상위 루프에 바인딩합니다"
# "'%0' is ignored since it is only supported for HIP"
HAF6605CCA46F: "'%0'은 HIP에서만 지원되기 때문에 무시됩니다"
# "'%0' is incompatible with C standards before C11"
H0DA1AA64E023: "'%0'는 C11 이전의 C 표준과 호환되지 않습니다"
# "'%0' is incompatible with C standards before C23"
HDD86BE78B3D0: "'%0'는 C23 이전의 C 표준과 호환되지 않습니다"
# "'%0' is incompatible with C standards before C2y"
H1CC83438FCCD: "'%0'은 C2y 이전의 C 표준과 호환되지 않습니다"
# "'%0' is invalid in friend declarations"
H3D161449A142: "'%0'는 friend 선언에서 유효하지 않습니다"
# "'%0' is not a valid Unicode character name"
H469DC75B6244: "'%0'은 유효한 유니코드 문자 이름이 아닙니다"
# "'%0' is not a valid builtin name for %1"
H4BF3E4DBB43C: "'%0'은 %1에 대한 유효한 내장 이름이 아닙니다"
# "'%0' is not a valid context property for the context selector '%1' and the context set '%2'; property ignored"
HEB6F750CA90C: "'%0'은/는 '%1' 컨텍스트 선택기와 '%2' 컨텍스트 세트에 대한 유효한 컨텍스트 속성이 아닙니다; 속성이 무시됩니다"
# "'%0' is not a valid context selector for the context set '%1'; selector ignored"
H6CA470A4E352: "'%0'은 컨텍스트 세트 '%1'에 대한 유효한 컨텍스트 선택기가 아닙니다; 선택기가 무시됩니다"
# "'%0' is not a valid context set in a `declare variant`; set ignored"
HA1E62D28111D: "'%0'은 `declare variant`에서 유효한 컨텍스트 세트가 아닙니다; 세트 무시됨"
# "'%0' is not a valid object format flag"
H0558CE31CE90: "'%0'는 유효한 객체 형식 플래그가 아닙니다"
# "'%0' is not permitted on a declaration of a type"
H43ABF8D7D74B: "'%0'은/는 타입 선언에 허용되지 않습니다"
# "'%0' is not supported in C++ for OpenCL"
HDCEA34FAF8C7: "'%0'은 C++에서 OpenCL에 지원되지 않습니다"
# "'%0' is only allowed on variable declarations"
H6BFADFD542E9: "'%0'은 변수 선언에만 사용할 수 있습니다"
# "'%0' is only available in %1"
H468F8034CF09: "'%0'는 %1에서만 사용할 수 있습니다"
# "'%0' is used without '-mstack-protector-guard-offset', and there is no default"
H8812B24333D0: "‘%0’는 '-mstack-protector-guard-offset' 옵션이 지정되지 않았고 기본값도 없습니다"
# "'%0' keyword is a C++11 extension"
H23175F3671E1: "'%0' 키워드는 C++11 확장입니다"
# "'%0' keyword is incompatible with C++98"
HCFDB7E16EAB8: "'%0' 키워드는 C++98과 호환되지 않습니다"
# "'%0' keyword not permitted with interface types"
HFAA4A308281C: "'%0' 키워드는 인터페이스 형식과 함께 허용되지 않습니다"
# "'%0' may overflow; destination buffer in argument %1 has size %2, but the corresponding specifier may require size %3"
H45D6462C38BC: "'%0'은 초과할 수 있습니다. 인수 %1의 목적지 버퍼 크기는 %2이지만, 해당 지정자는 크기 %3이 필요할 수 있습니다"
# "'%0' not supported, please use -iquote instead"
HD03640F49183: "'%0'은(는) 지원되지 않습니다. 대신에 -iquote 옵션을 사용해 주세요"
# "'%0' only applies to %select{function|pointer|Objective-C object or block pointer}1 types; type here is %2"
H76B771A1DA3E: "'%0'는 %select{function|pointer|Objective-C object or block pointer}1 유형에만 적용됩니다; 현재 유형은 %2입니다"
# "'%0' only applies to medium and large code models"
H2B43B16BADDB: "'%0'은 중간 및 대형 코드 모델에만 적용됩니다"
# "'%0' option requires target HLSL Version >= 2018%select{| and shader model >= 6.2}1, but HLSL Version is '%2'%select{| and shader model is '%3'}1"
H73FD169C1664: "옵션 '%0'은 대상 HLSL 버전이 2018 이상%select{| 및 셰이더 모델 6.2 이상}1이 필요하지만, 현재 HLSL 버전은 '%2'%select{| 및 셰이더 모델은 '%3'}1입니다"
# "'%0' parameter can only be used with swiftcall%select{ or swiftasynccall|}1 calling convention%select{|s}1"
H7F6C0A7A9011: "'%0' 매개변수는 swiftcall%select{ 또는 swiftasynccall|}1 호출 규칙%select{|s}1과 함께만 사용할 수 있습니다"
# "'%0' parameter must have pointer%select{| to unqualified pointer}1 type; type here is %2"
HA49C073BB7A8: "'%0' 매개변수는 포인터%select{| 비정격 포인터로의}1 유형을 가져야 합니다; 여기의 유형은 %2입니다"
# "'%0' previously encountered here"
HC082D10D967F: "'%0' 이전에 여기서 발견됨"
# "'%0' qualifier is not allowed on a constructor"
HD3C37F48AA10: "'%0' 자격어는 생성자에 허용되지 않습니다"
# "'%0' qualifier is not allowed on a destructor"
H63A821EC7A98: "'%0' qualifier is not allowed on a destructor"
# "'%0' qualifier may not appear after the virtual specifier '%1'"
HC82C66448381: "'%0' 수정자는 '%1' 지정자 뒤에 위치할 수 없습니다"
# "'%0' qualifier may not be applied to a reference"
H39DF4A724F57: "'%0' 지정자는 참조에 적용될 수 없습니다"
# "'%0' qualifier on function type %1 has no effect"
HCA4F5C288E32: "'%0' 지정자가 함수 형식 %1에 적용되어도 효과가 없습니다"
# "'%0' qualifier on function type %1 has no effect and is a Clang extension"
HA82B1E90695B: "'%0' 지정자가 함수 유형 %1에 적용되었으나 효과가 없으며 Clang 확장 기능입니다"
# "'%0' qualifier on omitted return type %1 has no effect"
H226C520C0A5C: "생략된 반환 타입 %1에 적용된 '%0' 자격 증명자는 효과가 없습니다."
# "'%0' qualifier on reference type %1 has no effect"
H9D5F7EA85F79: "'%0' 수정자는 참조 형식 %1에 효과가 없습니다"
# "'%0' qualifier%s1 on base class type %2 %plural{1:has|:have}1 no effect"
HB4BF74C2E9A3: "'%0' 자격 증명자%s1 기반 클래스 유형 %2에 %plural{1:적용된|:적용된}1 영향이 없습니다"
# "'%0' region encountered before requires directive with '%1' clause"
HAC48A5EE380D: "'%0' 지역이 '%1' 절을 가진 requires 지시문보다 먼저 발견되었습니다"
# "'%0' required by '%1'"
H149191A7D780: "'%0'은 '%1'에 필요합니다."
# "'%0' required for precompiled header not found"
HBDA853057C16: "'%0'이(가) 프리컴파일된 헤더에 필요하지만 발견되지 않았습니다"
# "'%0' size argument is too large; destination buffer has size %1, but size argument is %2"
H1B04445BBECB: "'%0'의 크기 인수가 너무 큽니다; 목적지 버퍼의 크기는 %1이지만, 크기 인수는 %2입니다"
# "'%0' specifier is not allowed outside a class definition"
H496E8612120E: "클래스 정의 밖에서 '%0' 지정자는 허용되지 않습니다."
# "'%0' statement cannot be used in OpenMP for loop"
HB1E296AE95BC: "'%0' 문은 OpenMP for 루프에서 사용할 수 없습니다"
# "'%0' statement cannot be used in OpenMP simd region"
H1C587C7353B1: "'%0' 문을 OpenMP simd 영역에서 사용할 수 없습니다"
# "'%0' type not found; include <omp.h>"
H4CF50F4E769F: "'%0' 형식이 발견되지 않았습니다; <omp.h>를 포함해 주세요"
# "'%0' type qualifier%s1 on return type %plural{1:has|:have}1 no effect"
H065A9C128711: "'%0' 형식 지정자%s1%plural{1:는|:들은} 리턴 타입에 영향을 미치지 않습니다."
# "'%0' type specifier is incompatible with C++98"
HB674C3599FA0: "'%0' 유형 지정자는 C++98과 호환되지 않습니다"
# "'%0' variables must have global storage"
H08EBA7A5907F: "'%0' 변수들은 글로벌 저장 공간을 가져야 합니다"
# "'%0' will always be truncated; specified size is %1, but format string expands to at least %2"
H0AA6DDAAABA2: "'%0'은 항상 잘림이 발생할 것입니다; 지정된 크기는 %1이지만, 포맷 문자열은 적어도 %2로 확장됩니다"
# "'%0' will always evaluate to 'true' in a manifestly constant-evaluated expression"
H75D7A83FFEC6: "'%0'은 명백히 상수 평가되는 표현에서 항상 'true'로 평가됩니다"
# "'%0' will always overflow; destination buffer has size %1, but format string expands to at least %2"
H6C8DA523F6B3: "'%0'은 항상 넘침이 발생할 것입니다; 목적지 버퍼의 크기는 %1이지만, 포맷 문자열은 최소 %2로 확장됩니다"
# "'%0' will always overflow; destination buffer has size %1, but size argument is %2"
H6A8E065AE173: "'%0'은 항상 오버플로우가 발생합니다; 목적지 버퍼의 크기는 %1이지만, 크기 인수는 %2입니다"
# "'%0' will always overflow; destination buffer has size %1, but the source string has length %2 (including NUL byte)"
H4E1F13141ECB: '‘%0’는 항상 오버플로우가 발생합니다. 목적지 버퍼의 크기는 %1이지만, 소스 문자열의 길이는 %2(NUL 바이트 포함)입니다'
# "'%0' within '%1'"
HFD060F45F3E4: '‘%0’은 ‘%1’ 내부에 있습니다'
# "'%0': selected processor lacks floating point registers"
H5E83058CA4FE: "'%0': 선택된 프로세서는 부동 소수점 레지스터가 없습니다"
# "'%0': unable to pass LLVM bit-code files to linker"
H5B7DB64DAEE9: "'%0': 링커에 LLVM 비트코드 파일을 전달할 수 없습니다"
# "'%0': unable to use AST files with this tool"
HEA339F2E046F: "'%0': 이 도구에서는 AST 파일을 사용할 수 없습니다"
# "'%0': unable to use module files with this tool"
H25C074B573CF: "'%0': 이 도구와 함께 모듈 파일을 사용할 수 없습니다"
# "'%0(%select{source|sink:vec}1)' clause%select{|s}1 cannot be mixed with '%0(%select{sink:vec|source}1)' clause%select{s|}1"
H081C849E3FF9: "'%0(%select{source|sink:vec}1)' 절%select{|s}1은 '%0(%select{sink:vec|source}1)' 절%select{s|}1와 함께 사용할 수 없습니다"
# "'%1' attribute on property %0 does not match the property inherited from %2"
H0392738DA622: "프로퍼티 %0의 '%1' 속성이 %2로부터 상속받은 프로퍼티와 일치하지 않습니다"
# "'%1' cannot be used in %select{a constructor|a destructor|the 'main' function|a constexpr function|a function with a deduced return type|a varargs function|a consteval function}0"
HB2DCA2D92D0E: "‘%1’은 %select{생성자|소멸자|'main' 함수|constexpr 함수|추론된 반환 형식 함수|가변 인자 함수|consteval 함수}0에서 사용할 수 없습니다"
# "'%select{#|#@}0' is not followed by a macro parameter"
HFFC615C42B6A: '‘%select{#|#@}0’이 매크로 매개변수에 이어지지 않았습니다'
# "'%select{%select{memcpy|wmemcpy}1|%select{memmove|wmemmove}1}0' not supported: %select{size to copy (%4) is not a multiple of size of element type %3 (%5)|source is not a contiguous array of at least %4 elements of type %3|destination is not a contiguous array of at least %4 elements of type %3}2"
HEE3F2A4E1A36: "'%select{%select{memcpy|wmemcpy}1|%select{memmove|wmemmove}1}0' 지원되지 않습니다: %select{복사할 크기(%4)가 요소 유형 %3(%5)의 배수가 아닙니다|소스가 유형 %3의 최소 %4 요소를 가지는 연속 배열이 아닙니다|목적지가 유형 %3의 최소 %4 요소를 가지는 연속 배열이 아닙니다}2"
# "'%select{*|.*}0' specified field %select{width|precision}0 is missing a matching 'int' argument"
H0D1F0E4F63B2: "'%select{*|.*}0'에서 지정된 필드 %select{width|precision}0에는 일치하는 'int' 인수가 없습니다"
# "'%select{--|++}0' on an object of complex type is a C2y extension"
HDA93C21904C8: "'%select{--|++}0' 연산자를 복합 타입의 객체에 사용하는 것은 C2y 확장입니다"
# "'%select{--|++}0' on an object of complex type is incompatible with C standards before C2y"
H20E81B85B020: "'%select{--|++}0'를 복합 형식의 객체에 적용하는 것은 C2y 이전의 C 표준과 호환되지 않습니다"
# "'%select{\\|@}0%1' command does not terminate a verbatim text block"
H42F81A2BAA36: "'%select{\\|@}0%1' 명령어는 원문 텍스트 블록을 종료하지 않습니다"
# "'%select{\\|@}0%1' command has %plural{0:no|:%2}2 word argument%s2, expected %3"
HBEDC67E6720C: "'%select{\\|@}0%1' 명령어에는 %plural{0:없음|:%2}2 단어 인자%s2가 있어야 하지만, %3이 예상됩니다"
# "'%select{\\|@}0%1' command used in a comment that is attached to a %select{function returning void|constructor|destructor|method returning void}2"
HFBFA65D15A47: "'%select{\\|@}0%1' 명령어가 %select{void를 반환하는 함수|생성자|소멸자|void를 반환하는 메소드}2에 연결된 주석에서 사용되었습니다."
# "'%select{\\|@}0%1' command used in a comment that is not attached to a function or method declaration"
H9A9CB5F0CECC: "'%select{\\|@}0%1' 명령어가 함수 또는 메소드 선언에 연결되지 않은 주석에서 사용되었습니다"
# "'%select{\\|@}0%select{classdesign|coclass|dependency|helper|helperclass|helps|instancesize|ownership|performance|security|superclass}1' command should not be used in a comment attached to a non-container declaration"
H63CA64568B3F: "'%select{\\|@}0%select{classdesign|coclass|dependency|helper|helperclass|helps|instancesize|ownership|performance|security|superclass}1' 명령어는 비컨테이너 선언에 연결된 주석에서 사용하지 마십시오"
# "'%select{\\|@}0%select{class|interface|protocol|struct|union}1' command should not be used in a comment attached to a non-%select{class|interface|protocol|struct|union}2 declaration"
H2B2D23C85C31: "'%select{\\|@}0%select{class|interface|protocol|struct|union}1' 명령어는 비-%select{class|interface|protocol|struct|union}2 선언에 부착된 주석에서 사용되어서는 안 됩니다"
# "'%select{\\|@}0%select{function|functiongroup|method|methodgroup|callback}1' command should be used in a comment attached to %select{a function|a function|an Objective-C method|an Objective-C method|a pointer to function}2 declaration"
H30965075CCD3: "'%select{\\|@}0%select{함수|함수 그룹|메소드|메소드 그룹|콜백}1' 명령어는 %select{함수|함수|Objective-C 메소드|Objective-C 메소드|함수 포인터}2 선언에 붙은 주석에서 사용되어야 합니다"
# "'%select{\\|@}0param' command used in a comment that is not attached to a function declaration"
HA6D99227D713: '‘%select{\\|@}0param’ 명령어는 함수 선언에 연결되지 않은 주석 내에서 사용되었습니다'
# "'%select{\\|@}0tparam' command used in a comment that is not attached to a template declaration"
H78D96F6B0A65: "'%select{\\|@}0tparam' 명령어가 템플릿 선언에 연결되지 않은 주석에서 사용되었습니다"
# "'%select{auto|decltype(auto)}0' in return type deduced as %1 here but deduced as %2 in earlier return statement"
HDFEF08FDDF8E: "'%select{auto|decltype(auto)}0' 리턴 타입은 여기서 %1로 추론되었지만 이전 리턴 문에서 %2로 추론되었습니다"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' argument cannot refer to a union member"
HF50BCD9CECE6: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' 인수는 유니언 멤버를 참조할 수 없습니다"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' argument must be a simple declaration reference"
HF6AC15305460: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' 인수는 단순 선언 참조여야 합니다"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' cannot be applied to a union member"
H01022C27C2BB: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0'는 유니온 멤버에 적용할 수 없습니다"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' only applies to pointers%select{ or C99 flexible array members|||}0%select{|; did you mean to use 'counted_by'?}1"
H077E0A5BF4C4: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0'는 포인터에만 적용됩니다%select{또는 C99 flexible array members|||}0%select{|; counted_by를 사용하려는 것이었나요?}1"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' requires a non-boolean integer type argument"
H69D52A4DAF87: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0'은 비불리언 정수 형식의 인수가 필요합니다"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}1' field %0 isn't within the same struct as the annotated %select{pointer|flexible array}2"
HBD3F5637D173: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}1' 필드 %0는 аннотированный %select{pointer|flexible array}2와 같은 struct 안에 있지 않습니다"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}4' %select{cannot|should not}3 be applied to %select{a pointer with pointee|an array with element}0 of unknown size because %1 is %select{an incomplete type|a sizeless type|a function type|a struct type with a flexible array member%select{|. This will be an error in a future compiler version}3}2"
HEFA740A9E276: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}4'는 %select{사용할 수 없습니다|사용하지 않아야 합니다}3 %select{a pointer with pointee|an array with element}0의 크기가 알려지지 않았기 때문에 %1이 %select{완전하지 않은 타입|크기가 없는 타입|함수 타입|유연한 배열 멤버를 가진 구조체 타입%select{|. 향후 컴파일러 버전에서는 오류가 될 것입니다}3}2이기 때문입니다"
# "'%select{if|switch}0' initialization statements are a C++17 extension"
HBFF569602D2E: "'%select{if|switch}0' 초기화 문은 C++17 확장입니다"
# "'%select{make_unsigned|make_signed}0' is only compatible with non-%select{bool|_BitInt(1)}1 integers and enum types, but was given %2%select{| whose underlying type is %4}3"
H89BC3FB5059E: "'%select{make_unsigned|make_signed}0'은 다음과 호환됩니다: 비-%select{bool|_BitInt(1)}1 정수형 및 열거형 타입. 하지만 %2%select{| 그 밑바닥 타입은 %4}3가 주어졌습니다."
# "'%select{memcpy|wmemcpy}0' between overlapping memory regions"
HF4936F4E6501: "'%select{memcpy|wmemcpy}0' 중첩된 메모리 영역 사이"
# "'%select{pure|const}0' attribute on function returning 'void'; attribute ignored"
H219A6665B476: "'%select{pure|const}0' 속성이 void를 반환하는 함수에 적용되었습니다; 속성이 무시되었습니다"
# "'%select{trivially_relocatable_if_eligible|replaceable_if_eligible}0' keyword is a C++2c extension"
H6BB09EC63ECD: "'%select{trivially_relocatable_if_eligible|replaceable_if_eligible}0' 키워드는 C++2c 확장입니다."
# "'%select{trivially_relocatable|replaceable}0_if_eligible' keyword is incompatible with standards before C++2c"
HE67149BBE77B: "'%select{trivially_relocatable|replaceable}0_if_eligible' 키워드는 C++2c 이전 표준과 호환되지 않습니다."
# "'%select{|short|long|long long}0 %1' is invalid"
H4742130B5F6C: "'%select{|short|long|long long}0 %1'은 유효하지 않습니다"
# "'&&' of a value and its negation always evaluates to false"
H35E9DA987909: "값과 그 부정의 '&&'은 항상 false로 평가됩니다"
# "'&&' within '||'"
H8790A025A3C5: "'&&'는 '||' 안에 사용되었습니다"
# "'&' cannot precede a capture when the capture default is '&'"
HA416D7E37193: "'&' 기호는 포획 기본값이 &일 때는 포획 앞에 사용할 수 없습니다."
# "'&' must precede a capture when the capture default is '='"
HC2B64117C04B: "'&'는 캡처 기본값이 '='일 때 캡처를 할 때 앞에 오아야 합니다"
# "'*' query has already been specified"
H24FF63F5C6A0: '별표(*) 쿼리는 이미 지정되었습니다.'
# "'--hip-path' must be specified when offloading to SPIR-V unless '-nogpuinc' is given"
HF39C24E57C93: "'--hip-path'는 SPIR-V로 오프로딩할 때 '-nogpuinc'가 지정되지 않은 경우 지정되어야 합니다"
# "'->' applied to return value of the operator->() declared here"
H2D7F207160DF: "'->' 연산자가 여기서 선언된 operator->()의 반환 값에 적용되었습니다"
# "'-fopenmp-targets' must be used in conjunction with a '-fopenmp' option compatible with offloading; e.g., '-fopenmp=libomp' or '-fopenmp=libiomp5'"
HECE3FA60C323: "'-fopenmp-targets'는 오프로딩과 호환되는 '-fopenmp' 옵션과 함께 사용해야 합니다. 예를 들어 '-fopenmp=libomp' 또는 '-fopenmp=libiomp5'와 같이 사용하십시오."
# "'-fsanitize=memtag-stack' requires hardware support (+memtag). For Armv8 or Armv9, try compiling with -march=armv8a+memtag or -march=armv9a+memtag"
H3869C74238EE: "'-fsanitize=memtag-stack' 옵션은 하드웨어 지원(+memtag)이 필요합니다. Armv8 또는 Armv9를 사용하는 경우 -march=armv8a+memtag 또는 -march=armv9a+memtag 옵션으로 컴파일해 보세요"
# "'-ftrivial-auto-var-init-max-size=*' is used without '-ftrivial-auto-var-init=zero' or '-ftrivial-auto-var-init=pattern'"
H85D7452F85FC: "'-ftrivial-auto-var-init-max-size=*' 옵션이 '-ftrivial-auto-var-init=zero' 또는 '-ftrivial-auto-var-init=pattern' 옵션이 없이 사용되었습니다."
# "'-ftrivial-auto-var-init-max-size=*' only accepts positive integers (in bytes)"
H15368DD22E8B: "'-ftrivial-auto-var-init-max-size=*'는 양의 정수만 허용됩니다 (바이트 단위)"
# "'-ftrivial-auto-var-init-stop-after=*' is used without '-ftrivial-auto-var-init=zero' or '-ftrivial-auto-var-init=pattern'"
HA64F3C5CF11D: "'-ftrivial-auto-var-init-stop-after=*' 옵션이 '-ftrivial-auto-var-init=zero' 또는 '-ftrivial-auto-var-init=pattern' 옵션 없이 사용되었습니다"
# "'-ftrivial-auto-var-init-stop-after=*' only accepts positive integers"
H964D5FF3D330: "'-ftrivial-auto-var-init-stop-after=*' 옵션은 양의 정수만 허용합니다"
# "'-fuse-ld=' taking a path is deprecated; use '--ld-path=' instead"
H24009BC2E029: "'-fuse-ld=' 옵션에 경로를 지정하는 것은 사용 중지 예정입니다; 대신 '--ld-path='을 사용하세요"
# "'-mbranch-protection=' option is incompatible with the '%0' architecture"
H4CC02B48C139: "'-mbranch-protection=' 옵션이 '%0' 아키텍처와 호환되지 않습니다"
# "'-mindirect-jump=%0' is unsupported with the '%1' architecture"
HA019BCF52E06: "옵션 '-mindirect-jump=%0'은 '%1' 아키텍처에서 지원되지 않습니다"
# "'-x %0' after last input file has no effect"
H37D74D222DAD: "'-x %0'은(는) 마지막 입력 파일 이후 효과가 없습니다"
# "'.  Try: '"
H3E571CE448AB: "'입니다. 시도해 보십시오: '"
# "'...' as the only parameter of a function is incompatible with C standards before C23"
H0778011D458B: "함수의 유일한 매개변수가 '...'는 C23 이전의 C 표준과 호환되지 않습니다"
# "'...' in this location creates a C-style varargs function%select{, not a function parameter pack|}0"
HDE7D8371A836: "'...'이 위치에서 C 스타일 가변 인자 함수를 생성합니다%select{, 함수 매개변수 패키지가 아닙니다|}0"
# "'...' must %select{immediately precede declared identifier|be innermost component of anonymous pack declaration}0"
H636262C7094A: "'...'는 %select{선언된 식별자 바로 앞에 위치해야 합니다|익명 패키지 선언의 가장 안쪽 구성 요소여야 합니다}0"
# "'/*' within block comment"
HF2D384BEFA1C: "블록 주석 내의 '/*'"
# "'/U%0' treated as the '/U' option"
HE813F64217D5: "'/U%0'는 '/U' 옵션으로 간주됩니다."
# "':' without preceding '?'"
H8AFE0C8D8DEE: "':' 앞에 '?'가 없습니다."
# "'<::' is treated as digraph '<:' (aka '[') followed by ':' in C++98"
H79B7386C3992: "'<::'는 C++98에서 '<:' 디그래프(즉, '[')로 처리되며 그 다음에 ':'가 오는 것으로 간주됩니다"
# "'<=>' is a single token in C++20; add a space to avoid a change in behavior"
HA94282EE55ED: "C++20에서 '<=>'는 단일 토큰입니다; 동작 변경을 피하려면 공백을 추가하십시오"
# "'<=>' operator is incompatible with C++ standards before C++20"
H95F1D52E2E7F: "'<=>' 연산자는 C++20 이전 표준과 호환되지 않습니다"
# "'= %select{default|delete}0' is a function definition and must occur in a standalone declaration"
H500D10ACAD58: "'= %select{default|delete}0'는 함수 정의이며, 독립된 선언에서 발생해야 합니다"
# "'= delete' with a message is a C++2c extension"
H31210BBF787E: "메시지와 함께 '= delete'를 사용하는 것은 C++2c 확장 기능입니다."
# "'= delete' with a message is incompatible with C++ standards before C++2c"
HF4121BB98E1E: "'= delete'와 메시지를 함께 사용하는 것은 C++2c 이전의 C++ 표준과 호환되지 않습니다"
# "'@encode' of incomplete type %0"
H26BBB8B07598: "'@encode'의 미완성 형식 %0"
# "'@end' appears where closing brace '}' is expected"
H0D104C2A47DE: "'@end'가 닫는 중괄호 '}'가 예상되는 곳에 있습니다"
# "'@end' must appear in an Objective-C context"
H53F73799BBFE: '@end는 Objective-C 컨텍스트에서만 사용되어야 합니다'
# "'NSObject' attribute is for pointer types only"
HB79535A35025: "'NSObject' 속성은 포인터 타입에만 사용됩니다"
# "'NSObject' attribute may be put on a typedef only; attribute is ignored"
H5749529C7AA1: "'NSObject' 특성은 typedef에만 적용할 수 있습니다; 특성은 무시됩니다"
# "'[[%select{nodiscard|gnu::warn_unused_result}0]]' attribute ignored when applied to a typedef; consider using '__attribute__((warn_unused_result))' or '[[clang::warn_unused_result]]' instead"
HC050BA19FE21: "'[[%select{nodiscard|gnu::warn_unused_result}0]]' 속성이 typedef에 적용될 때 무시됩니다; 대신 '__attribute__((warn_unused_result))' 또는 '[[clang::warn_unused_result]]'를 사용하는 것을 고려하세요"
# "'[[carries_dependency]]' attribute only allowed on parameter in a function declaration or lambda"
HA6D310EC7345: "'[[carries_dependency]]' 속성은 함수 선언 또는 람다의 매개변수에만 허용됩니다."
# "'[]' after delete interpreted as 'delete[]'; add parentheses to treat this as a lambda-expression"
H9FAF75D55EEF: "'[]' after delete interpreted as 'delete[]'; add parentheses to treat this as a lambda-expression"
# "'_BitInt' %select{vector|matrix}0 element width must be a power of 2"
HE9CD7B30FBE6: "'_BitInt' %select{벡터|행렬}0 요소 너비는 2의 거듭제곱이어야 합니다."
# "'_BitInt' in %select{C17 and earlier|C++}0 is a Clang extension"
HDE7EEC66FEFB: "'_BitInt'는 %select{C17 및 이전|C++}0에서 Clang 확장 기능입니다"
# "'_BitInt' suffix for literals is a C23 extension"
HA6733F109D23: "리터럴의 '_BitInt' 접미사는 C23 확장 기능입니다"
# "'_BitInt' suffix for literals is a Clang extension"
HE33869F03EE8: "'_BitInt' 리터럴의 접미사는 Clang 확장 기능입니다"
# "'_BitInt' suffix for literals is incompatible with C standards before C23"
H8F9C2C09F088: "리터럴의 '_BitInt' 접미사는 C23 이전의 C 표준과 호환되지 않습니다"
# "'_Complex %0' is invalid"
HF4E888A73841: "'_Complex %0'은(는) 유효하지 않습니다"
# "'_Countof' requires an argument of array type; %0 invalid"
H8DD99C0DA777: "'_Countof'는 배열 형식의 인수가 필요합니다; %0 무효입니다"
# "'_ExtInt' is deprecated; use '_BitInt' instead"
H6A2C7F4FE8E7: '‘_ExtInt’는 비추천됩니다; 대신 ‘_BitInt’를 사용하십시오'
# "'_Noreturn' can only appear on functions"
H8C4082088BE9: "'_Noreturn'은 함수에만 사용될 수 있습니다"
# "'_Noreturn' keyword must precede function declarator"
HC448318DE5F1: "'_Noreturn' 키워드는 함수 선언자 앞에 와야 합니다"
# "'_Sat' specifier is only valid on '_Fract' or '_Accum', not '%0'"
H43A3B4233E86: "'_Sat' 지정자는 '_Fract' 또는 '_Accum'에서만 사용할 수 있으며 '%0'에서는 사용할 수 없습니다."
# "'_Static_assert' with no message is a C23 extension"
H1BCF5D7E02AE: "'_Static_assert'에 메시지가 없는 것은 C23 확장 기능입니다"
# "'_Static_assert' with no message is incompatible with C standards before C23"
H977D55CE0649: '_Static_assert에 메시지가 없으면 C23 이전의 C 표준과 호환되지 않습니다'
# "'__FLT_EVAL_METHOD__' cannot be expanded inside a scope containing '#pragma clang fp eval_method'"
H2CAB7A2D4110: "'__FLT_EVAL_METHOD__'는 '#pragma clang fp eval_method'를 포함하는 범위 내에서 확장할 수 없습니다"
# "'__auto_type' is a GNU extension"
H2094509BC6E5: "'__auto_type'은 GNU 확장 기능입니다."
# "'__builtin_bit_cast' %select{source|destination}0 type must be trivially copyable"
H90D0B71921CD: "'__builtin_bit_cast' %select{source|destination}0 유형은 trivially copyable 이어야 합니다"
# "'__builtin_choose_expr' requires a constant expression"
H090BF417F6DF: "'__builtin_choose_expr'는 상수 표현식이 필요합니다"
# "'__builtin_counted_by_ref' argument cannot have side-effects"
HD566565DD11F: "'__builtin_counted_by_ref' 인수는 부작용을 가질 수 없습니다"
# "'__builtin_counted_by_ref' argument must reference a flexible array member"
HABF270462F6F: "'__builtin_counted_by_ref' 인수는 유연한 배열 멤버를 참조해야 합니다"
# "'__builtin_ms_va_start' used in System V ABI function"
H007690BB92E1: "'__builtin_ms_va_start'는 System V ABI 함수에서 사용되었습니다"
# "'__clang__' is a predefined macro name, not an attribute scope specifier; did you mean '_Clang' instead?"
HE8F991CDE8C6: "'__clang__'은 미리 정의된 매크로 이름으로, 속성 범위 지정자가 아닙니다. 대신 '_Clang'을(를) 원하셨는지요?"
# "'__clang_arm_builtin_alias' attribute can only be applied to an ARM builtin"
H79EABB0EF1E5: "'__clang_arm_builtin_alias' 속성은 ARM 내장 함수에만 적용될 수 있습니다"
# "'__clang_arm_mve_strict_polymorphism' attribute can only be applied to an MVE/NEON vector type"
H202E8786A308: "'__clang_arm_mve_strict_polymorphism' 속성은 오직 MVE/NEON 벡터 타입에만 적용될 수 있습니다"
# "'__declspec' attributes are not enabled; use '-fdeclspec' or '-fms-extensions' to enable support for __declspec attributes"
H465DF3E43560: "'__declspec' 속성은 활성화되어 있지 않습니다; __declspec 속성 지원을 활성화하려면 '-fdeclspec' 또는 '-fms-extensions' 옵션을 사용하십시오"
# "'__declspec(dllexport)' cannot be applied to more than one default constructor in %0"
HB67031034443: "'__declspec(dllexport)'은 %0에 한 개 이상의 디폴트 생성자에 적용할 수 없습니다"
# "'__declspec(thread)' applied to variable that already has a thread-local storage specifier"
HFE6629E646D9: "'__declspec(thread)'가 이미 스레드 로컬 저장소 지정자를 가진 변수에 적용되었습니다"
# "'__funcref' attribute can only be applied to a function pointer type"
H5101424932DE: "'__funcref' 속성은 오직 함수 포인터 유형에만 적용될 수 있습니다"
# "'__kindof' specifier cannot be applied to non-object type %0"
HBB66D4C1FC38: "'__kindof' 지정자는 비객체 형식 %0에 적용할 수 없습니다"
# "'__kindof' type specifier must precede the declarator"
H111C48694838: "'__kindof' 형식 지정자는 선언자 앞에 와야 합니다"
# "'__leave' statement not in __try block"
HA19FB1CE432F: "'__leave' 문이 __try 블록 내부에 있지 않습니다"
# "'__local' variable cannot have an initializer"
H0B1BBFD1CDEA: "'__local' 변수에는 초기화자를 가질 수 없습니다"
# "'__pixel' must be preceded by '__vector'.  '%0' declaration specifier not allowed here"
H88B3B9C40157: "'__pixel'은 '__vector' 앞에 위치해야 합니다. '%0' 선언 지정자는 여기서 허용되지 않습니다"
# "'__ptrauth' qualification mismatch%diff{ ($ and $)|}0,1"
H6E0E8F990A99: "'__ptrauth' 자격 증명 불일치%diff{ ($와 $)|}0,1"
# "'__ptrauth' qualifier must take between 1 and 3 arguments"
HD53DD31D4F33: "'__ptrauth' 자격 증명은 1~3개의 인수만 허용됩니다"
# "'__ptrauth' qualifier only applies to pointer or pointer sized integer types; %0 is invalid"
HEA3E527DDE36: "'__ptrauth' 한정자는 포인터나 포인터 크기 정수형에만 적용 가능합니다; %0은(는) 무효입니다."
# "'__super' cannot be used with a using declaration"
HE7865E9E15F7: "'__super'는 using 선언에서 사용할 수 없습니다."
# "'__thread' before '%0'"
H4E940DC3AE07: "'__thread'는 '%0' 앞에 올 수 없습니다"
# "'abi_tag' %0 missing in original declaration"
H1628165A1258: "'abi_tag' %0는 원래 선언에 누락되었습니다"
# "'abi_tag' attribute on %select{non-inline|anonymous}0 namespace ignored"
HDBC2CCB057F1: "'abi_tag' 속성이 %select{비인라인|익명}0 네임스페이스에서 무시되었습니다."
# "'abstract' keyword is a Microsoft extension"
HA16E3E3ED791: "'abstract' 키워드는 Microsoft 확장 기능입니다"
# "'adjust_arg' argument %0 used in multiple clauses"
H05E9C9F203D8: "'adjust_arg' 인수 %0이 여러 개의 절에서 사용되었습니다"
# "'align_value' attribute requires integer constant"
H6853424EF803: "'align_value' 속성은 정수 상수를 필요로 합니다"
# "'alignas' is incompatible with C++98"
H0BBFE28F35BF: 'alignas는 C++98과 호환되지 않습니다'
# "'aligned' attribute requires integer constant"
H1ADA356A8681: '‘aligned’ 속성은 정수 상수를 필요로 합니다'
# "'alignof' on an incomplete array type is a C2y extension"
HFD6D41C433A2: "'alignof'를 완전하지 않은 배열 형식에 사용하는 것은 C2y 확장입니다"
# "'alignof' on an incomplete array type is incompatible with C standards before C2y"
HF644B202EC9A: "'alignof'를 미완성 배열 형식에 사용하면 C2y 이전의 C 표준과 호환되지 않습니다"
# "'append_args' is not allowed with varargs functions"
H99449471B7D4: "'append_args'는 가변 인자 함수(varargs 함수)와 함께 사용할 수 없습니다"
# "'assign' property of object type may become a dangling reference; consider using 'unsafe_unretained'"
H7256F2B86929: "'assign' 속성의 객체 형식 프로퍼티는 dangling 참조가 될 수 있습니다; 'unsafe_unretained'를 사용해 보십시오"
# "'atomic capture' with a compound statement only supports two statements"
H0E46970C2D96: "복합 문(compound statement)에서 'atomic capture'는 두 개의 문만 지원합니다"
# "'auto' as a functional-style cast is incompatible with C++ standards before C++23"
HD4DCD08E6C51: "C++23 이전의 C++ 표준과 호환되지 않습니다: 'auto'를 함수 스타일 캐스트로 사용할 경우"
# "'auto' deduced as 'id' in declaration of %0"
HD22AA217F352: "'auto'가 %0 선언 시 'id'로 추론되었습니다"
# "'auto' return without trailing return type; deduced return types are a C++14 extension"
H2CC514506858: "'auto' 반환에 후위 반환 형식이 없습니다; 추론된 반환 형식은 C++14 확장 기능입니다"
# "'auto' storage class specifier is not permitted in C++11, and will not be supported in future releases"
H51939B968318: "'auto' 저장 클래스 지정자는 C++11에서 허용되지 않으며, 향후 릴리즈에서도 지원되지 않을 예정입니다"
# "'auto' storage class specifier is redundant and incompatible with C++11"
HFAD8EB4C5407: "'auto' 저장 클래스 지정자는 중복되며 C++11과 호환되지 않습니다"
# "'auto' type specifier is a %select{C++11|HLSL 202y}0 extension"
H96C499C3C66C: "'auto' 유형 지표자는 %select{C++11|HLSL 202y}0 확장 기능입니다"
# "'auto' type specifier is incompatible with C++98"
HA4F3AA6BB021: "'auto' 형식 지정자는 C++98과 호환되지 않습니다"
# "'auto' variable template instantiation is not allowed"
H7677E31876EE: "'auto' 변수 템플릿 인스턴스화는 허용되지 않습니다"
# "'begin' and 'end' returning different types (%0 and %1) is a C++17 extension"
H440F964925D8: "'begin'과 'end'가 서로 다른 타입(%0과 %1)을 반환하는 것은 C++17 확장 기능입니다"
# "'begin' and 'end' returning different types (%0 and %1) is incompatible with C++ standards before C++17"
HCE5BB9C433E6: "'begin'과 'end'가 다른 유형을 반환(%0과 %1)하는 것은 C++17 이전의 표준과 호환되지 않습니다"
# "'break' is bound to loop, GCC binds it to switch"
HB56827FEFDD0: "'break'는 루프에 바인드되지만, GCC는 이를 switch에 바인드합니다"
# "'break' statement not in loop or switch statement"
HD351562F6355: "'break' 문이 루프나 switch 문에 있지 않습니다"
# "'break' will never be executed"
H6E907B3877AE: "'break'는 절대 실행되지 않을 것입니다"
# "'callback' argument at position %0 references unavailable implicit 'this'"
HFC4B047896FC: "'callback' 인수는 위치 %0에서 사용할 수 없는 암시적 'this'를 참조합니다"
# "'callback' attribute argument %0 is not a known function parameter"
H5112D2E8FE1B: "'callback' 속성 인수 %0는 알려진 함수 매개변수가 아닙니다"
# "'callback' attribute callee does not have function type"
H11C2E7DC48A0: "'callback' 속성의 callee가 함수 형식을 갖지 않습니다"
# "'callback' attribute callee may not be variadic"
H5339D3799089: "'callback' 특성 callee는 가변 인수를 가질 수 없습니다"
# "'callback' attribute references function of type %0 which expects %1 %plural{1:argument|:arguments}1 but attribute specifies %2 parameter index %plural{1:argument|:arguments}2"
HE68D93E84E5E: "'callback' 속성은 %0 형식의 함수를 참조하는데, 이 함수는 %1 %plural{1:인수|:인수}1를 기대하지만 속성은 %2 매개변수 인덱스 %plural{1:인수|:인수}2를 지정했습니다"
# "'callback' attribute specifies invalid callback callee"
HAE51B1A6C397: "'callback' 속성은 유효하지 않은 콜백 호출 대상을 지정했습니다"
# "'callback' attribute specifies no callback callee"
HC67CEF8B86D2: "'callback' 속성은 콜백 호출 대상이 지정되어 있지 않습니다"
# "'called_once' attribute only applies to function-like parameters"
HFCB51789AAF0: "'called_once' 속성은 함수 유형인 매개변수에만 적용됩니다"
# "'case' statement not in switch statement"
H3C29CC73E754: 'case 문이 switch 문에 있지 않습니다'
# "'char8_t' type specifier is incompatible with C++ standards before C++20"
H6EF68EF28349: "'char8_t' 형식 지정자는 C++20 이전의 C++ 표준과 호환되지 않습니다"
# "'cleanup' argument %select{|%1 |%1 }0is not a %select{||single }0function"
HF9B0713C400E: '%select{|%1 |%1 }0%select{||단일 }0함수가 아님'
# "'cleanup' function %0 must take 1 parameter"
H70C0FCE6BEDE: "'cleanup' 함수 %0는 1개의 매개변수를 가져야 합니다"
# "'cleanup' function %0 parameter has %diff{type $ which is incompatible with type $|incompatible type}1,2"
H24491DE4E886: "'정리' 함수 %0 매개변수가 %diff{형식 $는 형식 $와 호환되지 않습니다.|호환되지 않는 형식}1,2"
# "'cmse_nonsecure_entry' cannot be applied to functions with internal linkage"
H36BD2CDFCAC5: "'cmse_nonsecure_entry'는 내부 링크지기 함수에 적용할 수 없습니다"
# "'co_await' modifier can only be applied to range-based for loop"
H23B6AEBD1B5B: "'co_await' 수정자는 범위 기반 for 루프에만 적용될 수 있습니다"
# "'const' attribute imposes more restrictions; 'pure' attribute ignored"
HAC8EEAA61CD9: "'const' 속성은 더 엄격한 제약을 가집니다; 'pure' 속성이 무시됨"
# "'consteval' specifier is incompatible with C++ standards before C++20"
HFAB40415D777: "'consteval' 지정자는 C++20 이전 표준과 호환되지 않습니다"
# "'constexpr' can only be used in variable declarations"
HCCD21640DBE9: "'constexpr'은 변수 선언문에서만 사용할 수 있습니다"
# "'constexpr' non-static member function will not be implicitly 'const' in C++14; add 'const' to avoid a change in behavior"
H23AE1DDB6BF2: "'constexpr' 비정적 멤버 함수는 C++14에서 암시적으로 'const'가 되지 않습니다; 동작 변경을 피하려면 'const'를 추가하세요"
# "'constexpr' on lambda expressions is a C++17 extension"
H99E246301B16: "'constexpr'은 람다 표현식에 적용되는 C++17 확장 기능입니다"
# "'constexpr' specifier is incompatible with C++98"
H26D17B863D82: "'constexpr' 지정자는 C++98과 호환되지 않습니다."
# "'constinit' specifier added after initialization of variable"
H941EB6451F6C: "'constinit' 지정자를 변수를 초기화한 후 추가했습니다"
# "'constinit' specifier is incompatible with C++ standards before C++20"
HA94D78D91751: "'constinit' 지정자는 C++20 이전의 C++ 표준과 호환되지 않습니다"
# "'constinit' specifier missing on initializing declaration of %0"
H55C3572EEC7C: "'constinit' 지정자가 %0의 초기화 선언에 없습니다."
# "'continue' statement not in loop statement"
HCD539EA88B8F: 'continue 문이 루프 문에 있지 않습니다.'
# "'copy' attribute must be specified for the block property when -fobjc-gc-only is specified"
H87791A0AEA62: "'copy' 속성이 -fobjc-gc-only가 지정될 때 블록 프로퍼티에 지정되어야 합니다"
# "'counted_by' cannot refer to the flexible array member %0"
H5B04880F56A4: '‘counted_by’는 유연한 배열 멤버 %0를 참조할 수 없습니다.'
# "'counted_by' on arrays only applies to C99 flexible array members"
HB17E489D7021: "'counted_by' 속성은 배열에 적용될 경우 C99 유연한 배열 멤버(flexible array members)에만 해당합니다"
# "'cpu_dispatch' function redeclared with different CPUs"
HCA2FB0047F16: "'cpu_dispatch' 함수가 다른 CPU로 재선언되었습니다"
# "'decltype' type specifier is incompatible with C++98"
H06E59DDEED89: "'decltype' 형식 지정자는 C++98와 호환되지 않습니다"
# "'decltype(auto)' can only be used as a return type in a function declaration"
H5356DF2FE6D3: '‘decltype(auto)’은 함수 선언의 반환 타입으로만 사용할 수 있습니다'
# "'decltype(auto)' cannot be combined with other type specifiers"
H139F443827AC: "'decltype(auto)은 다른 형식 지정자와 함께 사용할 수 없습니다'"
# "'decltype(auto)' not allowed here"
HA795F2923798: "'decltype(auto)'는 여기서 사용할 수 없습니다."
# "'decltype(auto)' type specifier is a C++14 extension"
H7E1DB4CB833F: "'decltype(auto)' 형식 지정자는 C++14 확장입니다"
# "'decltype(auto)' type specifier is incompatible with C++ standards before C++14"
HA38CAC8829B9: "'decltype(auto)' 유형 지정자는 C++14 이전 표준과 호환되지 않습니다"
# "'default' clause for 'metadirective' is deprecated; use 'otherwise' instead"
H505947545CF6: "'metadirective'의 'default' 절은 더 이상 사용되지 않습니다. 대신 'otherwise'를 사용하세요."
# "'default' statement not in switch statement"
H1133498536DD: 'default 절이 switch 문 내에 없습니다'
# "'defined' cannot appear within this context"
HDAE80537A1D3: "'defined'는 이 문맥 내에서 사용할 수 없습니다"
# "'defined' cannot be used as a macro name"
HB4BA3900B80E: "'defined'는 마크로 이름으로 사용할 수 없습니다"
# "'delete%select{|[]}0' applied to a pointer that was allocated with 'new%select{[]|}0'; did you mean 'delete%select{[]|}0'?"
H84CC0C534191: "'delete%select{|[]}0'가 'new%select{[]|}0'로 할당된 포인터에 적용되었습니다; 'delete%select{[]|}0'를 의미하셨는지요?"
# "'delete' applied to a pointer-to-array type %0 treated as 'delete[]'"
H011BFAE8BB84: "배열 포인터 형식 %0에 'delete'가 적용되었습니다. 'delete[]'로 처리됩니다"
# "'delete' cannot delete objects of type %0 in address space '%1'"
H7E66A4AF7B26: "'delete' 연산자는 '%1' 주소 공간에 있는 %0 유형의 개체를 삭제할 수 없습니다"
# "'depend' clause for 'ordered' is deprecated; use 'doacross' instead"
HB07DCDAB27B1: "'depend' 절을 'ordered'에 사용하는 것은 비추천 됩니다; 대신 'doacross'를 사용하세요"
# "'depend' clause requires the 'targetsync' interop type"
H2DD7E54EBF24: "'depend' 절은 'targetsync' 인터옵 형식이 필요합니다"
# "'deprecated' attribute on anonymous namespace ignored"
HE49B32CE23AF: "'deprecated' 속성은 익명 네임스페이스에서 무시됩니다."
# "'device_type(%0)' does not match previously specified 'device_type(%1)' for the same declaration"
HDE923438E688: "'device_type(%0)'은(는) 같은 선언에 대해 이전에 지정된 'device_type(%1)'과 일치하지 않습니다"
# "'diagnose_if' is a clang extension"
H6ABE610AE6BE: "'diagnose_if'는 clang 확장 문법입니다"
# "'dllexport' attribute ignored on explicit instantiation definition"
H5570C9EC211D: "'dllexport' 속성이 명시적 인스턴스화 정의에서 무시됨"
# "'enable_if' is a clang extension"
HF8D51A54A3FE: '‘enable_if’는 clang 확장 기능입니다'
# "'explicit' can only appear on non-static member functions"
H4ED84C1B6695: "키워드 'explicit'은 정적 멤버 함수가 아닌 멤버 함수에만 사용할 수 있습니다"
# "'explicit' can only be applied to a constructor or conversion function"
H31AF261810E7: "'explicit'는 오직 생성자 또는 형 변환 함수에만 적용될 수 있습니다"
# "'explicit' can only be specified inside the class definition"
H4954093357D9: "명시적 키워드 'explicit'은 클래스 정의 내에서만 지정할 수 있습니다."
# "'explicit' is not permitted on top-level modules"
HDAE06689A152: "'explicit'은 최상위 모듈에서 허용되지 않았습니다"
# "'extern' variable has an initializer"
HB91B40E25B4C: "'extern' 변수에 초기화자가 있습니다"
# "'extern' variable may not be referenced by '%0' clause on an OpenACC 'declare' directive"
H270234BE5B42: "'외부' 변수는 OpenACC 'declare' 지시문의 '%0' 절에 참조될 수 없습니다"
# "'flush' directive with memory order clause '%0' cannot have the list"
HC2158D6851BB: "'flush' 지시문에 메모리 순서 절 '%0'은 목록을 포함할 수 없습니다"
# "'for co_await' belongs to CoroutineTS instead of C++20, which is deprecated"
H6DA54D0F5428: "'for co_await'은 C++20이 아닌 CoroutineTS에 속하며, 이는 비추천된 기능입니다"
# "'friend' must appear first in a non-function declaration"
HEBE4422274B2: "'friend'는 비함수 선언에서 처음에 나타나야 합니다"
# "'friend' used outside of class"
HABD952B07FCB: "'friend' 클래스 밖에서 사용되었습니다"
# "'gnu_inline' attribute requires function to be marked 'inline', attribute ignored"
HEDCF2C7F36F0: "'gnu_inline' 특성은 함수가 inline으로 표시되어야 합니다. 특성 무시됨"
# "'gnu_inline' attribute without 'extern' in C++ treated as externally available, this changed in Clang 10"
H021467CD0886: "C++에서 'extern'이 없는 'gnu_inline' 속성은 외부에서 사용 가능하도록 처리됩니다. Clang 10부터 이 동작 방식이 변경되었습니다."
# "'hybrid_patchable' is ignored on functions without external linkage"
H0ADF7398ED3A: "'hybrid_patchable'은 외부 링크지정이 없는 함수에서 무시됩니다"
# "'inline' can only appear on functions%select{| and non-local variables}0"
H89E78E1738F9: "'inline'은 함수%select{| 및 비국소 변수}0에만 사용할 수 있습니다"
# "'inscan' modifier can be used only in 'omp for', 'omp simd', 'omp for simd', 'omp parallel for', or 'omp parallel for simd' directive"
HD994FA838907: "'inscan' 수식자는 'omp for', 'omp simd', 'omp for simd', 'omp parallel for' 또는 'omp parallel for simd' 지시문에서만 사용할 수 있습니다."
# "'internal_linkage' attribute on a non-static local variable is ignored"
H66A8BF53EA8F: "'internal_linkage' 속성은 static이 아닌 지역 변수에 적용될 경우 무시됩니다"
# "'lifetime_capture_by' argument references itself"
H3627CC1FAD24: 'lifetime_capture_by 인수는 자신을 참조합니다'
# "'lifetime_capture_by' argument references unavailable implicit 'this'"
HCCCF5641FC93: "'lifetime_capture_by' 인수는 사용할 수 없는 암시적 'this'를 참조합니다"
# "'lifetime_capture_by' attribute argument %0 is not a known function parameter; must be a function parameter, 'this', 'global' or 'unknown'"
H3A8F776F3ADB: "'lifetime_capture_by' attribute argument %0는 알려진 함수 매개변수가 아닙니다; 반드시 함수 매개변수, 'this', 'global' 또는 'unknown' 중 하나여야 합니다"
# "'lifetime_capture_by' attribute specifies no capturing entity"
HA61E4C8D2E68: "'lifetime_capture_by' 속성은 포획하는 엔터티가 없습니다"
# "'lifetimebound' attribute cannot be applied to a %select{constructor|destructor}0"
H67DD72C3F644: "'lifetimebound' 특성은 %select{생성자|소멸자}0에 적용할 수 없습니다"
# "'lifetimebound' attribute cannot be applied to a parameter of a function that returns void; did you mean 'lifetime_capture_by(X)'"
H7AF0F9960FBE: "'lifetimebound' 속성은 void를 반환하는 함수의 매개변수에 적용할 수 없습니다; 'lifetime_capture_by(X)'를 의도하셨나요?"
# "'lifetimebound' attribute cannot be applied to an implicit object parameter of a function that returns void; did you mean 'lifetime_capture_by(X)'"
H246C1F79D057: "'lifetimebound' 속성은 void를 반환하는 함수의 암시적 객체 매개변수에 적용할 수 없습니다; 의도한 것은 'lifetime_capture_by(X)'였는지 확인하세요"
# "'lifetimebound' attribute cannot be applied; %select{non-|static |explicit object }0member function has no implicit object parameter"
H4EDB6AB20113: "'lifetimebound' 속성을 적용할 수 없습니다; %select{비-|정적 |명시적 객체 }0멤버 함수에는 암시적 객체 매개변수가 없습니다"
# "'linear' clause cannot be specified along with 'ordered' clause with a parameter"
H20416EEA599F: "'linear' 절은 매개변수가 있는 'ordered' 절과 함께 지정될 수 없습니다"
# "'long long' is a C++11 extension"
HC63DB1FBE144: "'long long'은 C++11 확장 기능입니다"
# "'long long' is an extension when C99 mode is not enabled"
H90F12D1B1D4D: "'long long'은 C99 모드가 활성화되지 않았을 때 확장 기능입니다"
# "'long long' is incompatible with C++98"
H0DAB29466D2C: "'long long'는 C++98와 호환되지 않습니다"
# "'main' cannot be a multiversioned function"
HAFF8B40A53DE: "'main'은 다중 버전화된 함수일 수 없습니다"
# "'main' is not allowed to be declared %select{constexpr|consteval}0"
H13F25D825A17: "'main'은 %select{constexpr|consteval}0로 선언할 수 없습니다"
# "'main' is not allowed to be declared _Noreturn"
HE455B9A59591: "'main'은 _Noreturn로 선언할 수 없습니다"
# "'main' is not allowed to be declared inline"
HBC0A4A59C65E: "'main'은 inline으로 선언할 수 없습니다"
# "'main' is not allowed to be declared static"
HB1B95BDA01B7: '‘main’은 static으로 선언될 수 없습니다'
# "'main' is not allowed to be declared variadic"
HD3EE247E6A72: '‘main’은 가변 인자 함수로 선언할 수 없습니다'
# "'main' is not allowed to be deleted"
HB0C6AFB93EDB: "'main'은 삭제될 수 없습니다"
# "'main' must return 'int'"
HD54CCE2AF684: "'main'은 'int'를 반환해야 합니다"
# '\'main\' should not be \'extern "%select{C|C++}0"\''
H19102C631788: '\'main\'은 \'extern "%select{C|C++}0"\'로 선언되어서는 안 됩니다.'
# "'main' should not be declared static"
H9A6B59304912: "'main'은 static으로 선언되어서는 안 됩니다"
# "'malloc' argument %0 must take a pointer type as its first argument"
HEF17CC57A675: "'malloc' 인수 %0는 첫 번째 인수로 포인터 형식이어야 합니다"
# "'malloc' argument %select{for deallocator |%1 |%1 }0is not a %select{||single }0function"
HC684E8204794: "'malloc' 인수 %select{디얼로케이터를 위해|%1|%1}0은/는 %select{||단일}0함수가 아닙니다."
# "'malloc' argument '%0' refers to non-pointer type %1 of %2"
HFD06C554D4E6: "'malloc' 인수 '%0'은 %2의 비포인터 유형 %1을 가리킵니다"
# "'mig_server_routine' attribute only applies to routines that return a kern_return_t"
HF1C5C16FC7E6: "'mig_server_routine' 속성은 오직 kern_return_t를 반환하는 루틴에만 적용됩니다"
# "'module' declaration found while building header unit"
HA86B9DC6C734: '‘모듈’ 선언이 헤더 유닛을 빌드하는 동안 발견되었습니다'
# "'module' declaration found while building module from module map"
H880BB7F53078: "'module' 선언이 모듈 맵에서 모듈을 생성하는 동안 발견되었습니다"
# "'module;' introducing a global module fragment can appear only at the start of the translation unit"
H617DC2BE71CE: "'module;'은 글로벌 모듈 프래그먼트를 도입하는 구문으로, 번역 단위의 시작 부분에만 출현할 수 있습니다"
# "'musttail' attribute for this call is impossible because %select{long calls cannot be tail called on PPC|indirect calls cannot be tail called on PPC|external calls cannot be tail called on PPC}0"
H14240DA28AAD: "'musttail' 속성은 이 호출에 적용할 수 없습니다. 왜냐하면 %select{PPC에서 긴 호출은 테일 호출할 수 없습니다.|PPC에서 간접 호출은 테일 호출할 수 없습니다.|PPC에서 외부 호출은 테일 호출할 수 없습니다.}0"
# "'musttail' attribute is not supported on AIX"
H92717FE13CEF: '‘musttail’ 속성은 AIX에서는 지원되지 않습니다'
# "'mutable' and 'const' cannot be mixed"
H6CE01BCA1797: "'mutable'과 'const'는 혼합될 수 없습니다"
# "'mutable' can only be applied to member variables"
HC1CD8F78BDE1: "'mutable' 키워드는 멤버 변수에만 적용될 수 있습니다"
# "'mutable' cannot be applied to functions"
H9B6452717014: "'mutable'는 함수에 적용할 수 없습니다"
# "'mutable' cannot be applied to references"
H7CCDA0B2596A: "'mutable'은 참조에 적용될 수 없습니다"
# "'mutable' on a reference type is a Microsoft extension"
H6E975C04AF4E: "'mutable'은 참조 형식에 사용된 Microsoft 확장 기능입니다"
# "'mutexinoutset' modifier not allowed in 'depend' clause on 'taskwait' directive"
H54D9DFD0A59D: "'mutexinoutset' 수정자는 'taskwait' 지시어의 'depend' 절에서 허용되지 않습니다"
# "'new' cannot allocate an array of %0 with no explicit ownership"
H01CEEA4215DD: "'new'는 명시적인 소유권이 없는 %0 배열을 할당할 수 없습니다."
# "'new' cannot allocate object of variably modified type %0"
HB68377C1CB34: "'new'는 %0 형식의 가변적으로 수정된 객체를 할당할 수 없습니다."
# "'new' cannot allocate objects of type %0 in address space '%1'"
H8F2EE8209986: "'new'는 '%1' 주소 공간에서 %0 형 객체를 할당할 수 없습니다"
# "'new' expression with placement arguments refers to non-placement 'operator delete'"
H9A938FDFCB36: "'placement 인수를 사용하는 'new' 표현식은 placement가 아닌 'operator delete'를 참조합니다'"
# "'nocf_check' attribute ignored; use -fcf-protection to enable the attribute"
HCD98AFA044EC: "특성 'nocf_check'가 무시됨; 어트리뷰트를 활성화하려면 -fcf-protection 옵션을 사용하십시오"
# "'noderef' can only be used on an array or pointer type"
H265BDBEEC1EC: "'noderef'는 배열 또는 포인터 형식에만 사용할 수 있습니다"
# "'noexcept' can only be used in a compound requirement (with '{' '}' around the expression)"
H88CA64B4E3F6: "'noexcept'는 표현식 주위에 '{' '}'를 사용한 복합 조건에서만 사용할 수 있습니다"
# "'nonmonotonic' modifier can only be specified with 'dynamic' or 'guided' schedule kind"
H60F2BCD19874: "'nonmonotonic' 수정자는 'dynamic' 또는 'guided' 스케줄 종류와 함께만 지정될 수 있습니다"
# "'nonnull' attribute applied to function with no pointer arguments"
H0D4CBB499E30: "'nonnull' 속성이 포인터 인자가 없는 함수에 적용됨"
# "'nonnull' attribute when used on parameters takes no arguments"
H8544A5398585: "'nonnull' 속성은 매개변수에 사용될 때 인수를 받지 않습니다."
# "'not_tail_called' attribute prevents being called as a tail call"
HD566EBB2A50E: "'not_tail_called' 속성이 꼬리 호출로 호출되는 것을 방지합니다"
# "'nothrow' attribute conflicts with exception specification; attribute ignored"
HA43C7748DBD1: "'nothrow' 특성은 예외 사양과 충돌하므로 무시됩니다"
# "'nowait' clause is here"
H4C9748BD1A0B: "'nowait' 클라우스가 여기에 있습니다"
# "'nullptr' is a C23 extension"
H0CCA94E13259: "'nullptr'는 C23 확장 기능입니다"
# "'nullptr' is incompatible with C++98"
HA3F1CF3D3055: "'nullptr'는 C++98와 호환되지 않습니다"
# "'objc_bridge(id)' is only allowed on structs and typedefs of void pointers"
H19339C3149E3: "'objc_bridge(id)'는 void 포인터의 구조체 및 typedef에만 허용됨"
# "'objc_class_stub' attribute cannot be specified on a class that does not have the 'objc_subclassing_restricted' attribute"
H131E98846FD9: "'objc_class_stub' 어트리뷰트는 'objc_subclassing_restricted' 어트리뷰트가 없는 클래스에는 지정할 수 없습니다."
# "'objc_designated_initializer' attribute only applies to init methods of interface or class extension declarations"
H0C4330D28BB6: "'objc_designated_initializer' 특성은 인터페이스 또는 클래스 확장 선언문의 init 메서드에만 적용됩니다"
# "'objc_direct' attribute cannot be applied to %select{methods|properties}0 declared in an Objective-C protocol"
H0E0D013ED449: "'objc_direct' 속성은 Objective-C 프로토콜에서 선언된 %select{메서드|속성}0에 적용할 수 없습니다"
# "'objc_externally_retained' can only be applied to local variables %select{of retainable type|with strong ownership}0"
H863E7A12B731: "'objc_externally_retained'는 로컬 변수에만 적용될 수 있습니다. %select{retain 가능한 형식의|강한 소유권을 가진}0"
# "'objc_independent_class' attribute may be put on Objective-C object pointer type only; attribute is ignored"
H917C3A1684AC: 'objc_independent_class 속성은 오직 Objective-C 객체 포인터 타입에만 적용될 수 있으며, 그렇지 않은 경우 속성이 무시됩니다'
# "'objc_independent_class' attribute may be put on a typedef only; attribute is ignored"
HCF5FB9401D67: "'objc_independent_class' 어트리뷰트는 typedef에만 적용 가능하며; 해당 어트리뷰트는 무시됩니다"
# "'offsetof' on non-POD type %0"
H2BFD47074829: "'offsetof'을 비POD 형식 %0에 사용함"
# "'offsetof' on non-standard-layout type %0"
H0A19805CBC92: "'offsetof'을 비표준 레이아웃 형식 %0에 사용함"
# "'omp_interop_t' must be defined when 'append_args' clause is used; include <omp.h>"
H584E24086261: "'omp_interop_t'는 'append_args' 절을 사용할 때는 정의되어야 하며, <omp.h>를 포함시켜 주세요."
# "'ompx_attribute' clause only allows 'amdgpu_flat_work_group_size', 'amdgpu_waves_per_eu', and 'launch_bounds'; %0 is ignored"
H15379B8D06F4: '‘ompx_attribute’ 절에서는 오직 ‘amdgpu_flat_work_group_size’, ‘amdgpu_waves_per_eu’ 및 ‘launch_bounds’만 허용됩니다; %0는 무시됩니다'
# "'ompx_bare' clauses requires explicit grid size via 'num_teams' and 'thread_limit' clauses"
HC78DCADADB1C: "'ompx_bare' 절은 'num_teams' 및 'thread_limit' 절을 통해 명시적인 그리드 크기를 지정해야 합니다"
# "'operator new' provided by %0 is not usable with the function signature of %1"
HC75862C47BD1: "'operator new'는 %0에 의해 제공되나, %1의 함수 시그니처와 호환되지 않습니다"
# "'operator->' declared here produces an object of type %0"
HC1D7E6DA4A9D: "'operator->'가 여기서 선언되었으며 %0 유형의 객체를 생성합니다"
# "'ordered' clause with a parameter cannot be specified in '#pragma omp %0' directive"
HE291A06801DB: "매개변수가 있는 'ordered' 절은 '#pragma omp %0' 지시문에서 지정할 수 없습니다."
# "'ordered' clause%select{| with specified parameter}0"
H337028DA61A4: "'ordered' 절%select{| 지정된 매개변수가 있는}0"
# "'ordered' directive %select{without any clauses|with 'threads' clause}0 cannot be closely nested inside ordered region with specified parameter"
HB16FD1003ED0: "'ordered' 지시어 %select{어떠한 절도 없이|'threads' 절을 사용하여}0는 지정된 매개변수가 있는 ordered 영역 안에서 가까이 중첩될 수 없습니다"
# "'ordered' directive with '%0' clause cannot be closely nested inside ordered region without specified parameter"
H1845D44BB3DE: "'ordered' 지시문의 '%0' 절을 가진 문은 매개변수가 지정되지 않은 ordered 영역 내에서 가까이 중첩될 수 없습니다"
# "'overloadable' function %0 must have a prototype"
HA041210B9619: "'overloadable' 함수 %0는 프로토타입이 있어야 합니다"
# "'ownership_returns' attribute index does not match; here it is %0"
H1C0451B398DB: "'ownership_returns' 속성 인덱스가 일치하지 않습니다; 여기서는 %0입니다"
# "'ownership_returns' attribute only applies to functions that return a pointer"
HE96B6120100D: "'ownership_returns' 특성은 포인터를 반환하는 함수에만 적용됩니다"
# "'ownership_takes' attribute class does not match; here it is '%0'"
H2E44647C4A59: "속성 클래스 'ownership_takes'가 일치하지 않습니다; 여기서는 '%0'입니다"
# "'packed' attribute was ignored on bit-fields with single-byte alignment in older versions of GCC and Clang"
H8DB05E11AD0A: "'packed' 어트리뷰트는 과거 버전의 GCC 및 Clang에서 단일 바이트 정렬을 가진 비트 필드에 적용되었을 때 무시되었습니다"
# "'reduction' clause cannot be used with 'nogroup' clause"
H186A32581806: "'reduction' 절은 'nogroup' 절과 함께 사용할 수 없습니다."
# "'reduction' clause not allowed with '#pragma omp loop bind(teams)'"
H4981CB6A6643: "'reduction' 클라우즈는 '#pragma omp loop bind(teams)'와 함께 사용할 수 없습니다"
# "'reduction' clause with 'inscan' modifier is used here"
HE04EBCC11985: "'reduction' 절에 'inscan' 수정자가 여기에서 사용되었습니다"
# "'reduction' clause with 'task' modifier allowed only on non-simd parallel or worksharing constructs"
HD0FEE7231060: "'reduction' 절과 'task' 수정자는 비-SIMD 병렬 또는 작업공유 구문에서만 허용됩니다"
# "'register' storage class specifier is deprecated and incompatible with C++17"
HDBC08F071224: "'register' 저장 클래스 지정자는 비추천 기능이며 C++17과 호환되지 않습니다"
# "'register' storage specifier on @catch parameter will be ignored"
H4232960B8CCE: "'register' 저장 지정자가 catch 매개변수에 적용되면 무시됩니다"
# "'regparm' is not valid on this platform"
H1E534F14C852: "'regparm'은 이 플랫폼에서 유효하지 않습니다"
# "'regparm' parameter must be between 0 and %0 inclusive"
H63349C70781C: "'regparm' 매개변수는 0과 %0 사이의 범위 내에서 지정해야 합니다"
# "'reinterpret_cast' %select{from|to}3 class %0 %select{to|from}3 its %select{virtual base|base at non-zero offset}2 %1 behaves differently from 'static_cast'"
HF87527FE7FBB: "'reinterpret_cast' %select{에서|로}3 클래스 %0 %select{를|에서}3 그 %select{가상 기반|비영점 오프셋 기반}2 %1 클래스로 변환하는 행위는 'static_cast'와 다르게 동작합니다"
# "'require_constant_initialization' attribute added after initialization of variable"
HCCF005312D01: "'require_constant_initialization' 속성은 변수 초기화 이후에 추가되었습니다"
# "'restrict' qualifier on an array of pointers is a C23 extension"
H831A2BF01322: "'restrict' 자격자가 포인터 배열에 적용될 경우 C23 확장 기능입니다"
# "'restrict' qualifier on an array of pointers is incompatible with C standards before C23"
H7AB582A89AF4: "'restrict' 자격 지정자는 C23 이전의 C 표준과 호환되지 않습니다."
# "'return' will never be executed"
HF9D8B2478204: "'return'은 실행되지 않을 것입니다"
# "'sealed' keyword is a Microsoft extension"
H2371564F3064: "'sealed' 키워드는 Microsoft의 확장입니다"
# "'selectany' can only be applied to data items with external linkage"
H0D95115281D5: "'selectany'는 외부 링크지가 있는 데이터 항목에만 적용할 수 있습니다."
# "'sentinel' attribute only supported for variadic %select{functions|blocks}0"
H0C7CDE5CC83E: "'sentinel' 속성은 가변 %select{함수|블록}0에만 지원됩니다"
# "'sentinel' attribute requires named arguments"
HB4DB8DB54C63: "'sentinel' 속성은 이름이 지정된 인수를 필요로 합니다"
# "'sentinel' parameter 1 less than zero"
HE854964454A6: '‘sentinel’ 파라미터 1이 0보다 작습니다'
# "'sentinel' parameter 2 not 0 or 1"
H99541E948450: "'sentinel' 매개변수 2가 0 또는 1이 아닙니다"
# "'size' argument to bzero is '0'"
H50A840FAEA15: "bzero의 size 인수는 '0'입니다."
# "'size_t' suffix for literals is a C++23 extension"
HE55B1E186F37: "'size_t' 접미사는 리터럴에 대한 C++23 확장 기능입니다"
# "'size_t' suffix for literals is a C++23 feature"
HFE4E8B889F8C: "'size_t' 리터럴 접미사는 C++23 기능입니다"
# "'size_t' suffix for literals is incompatible with C++ standards before C++23"
H01C26A9D5D7B: "'size_t' 접미사는 C++23 이전의 표준들과 호환되지 않습니다"
# "'static' can only be specified inside the class definition"
HC2C3574A2AC5: '‘static’은 클래스 정의 내에서만 지정할 수 있습니다'
# "'static' function %0 declared in header file should be declared 'static inline'"
HAC6B8325923D: "'static' 함수 %0가 헤더 파일에 선언되었으므로 'static inline'로 선언해야 합니다"
# "'static' may not be used with an unspecified variable length array size"
H8C886B8B17D3: "'static'는 지정되지 않은 가변 길이 배열 크기와 함께 사용할 수 없습니다"
# "'static' may not be used without an array size"
H3CD973765C05: "'static'은 배열 크기를 지정하지 않고 사용할 수 없습니다"
# "'static' member function %0 overrides a virtual function in a base class"
H917973A36E2C: "'static' 멤버 함수 %0는 기반 클래스의 가상 함수를 오버라이드합니다"
# "'static_assert' declarations are incompatible with C++98"
HEBCFD6945359: "'static_assert' 선언은 C++98과 호환되지 않습니다"
# "'static_assert' with a user-generated message is a C++26 extension"
HFCA41F0C6554: "사용자 생성 메시지가 있는 'static_assert'는 C++26 확장 기능입니다."
# "'static_assert' with a user-generated message is incompatible with C++ standards before C++26"
H71F257CCE8FF: "'static_assert'에 사용자 생성 메시지를 사용하면 C++26 이전의 C++ 표준과 호환되지 않습니다"
# "'static_assert' with no message is a C++17 extension"
H89070CD2F991: "메시지가 없는 'static_assert'는 C++17 확장 기능입니다"
# "'static_assert' with no message is incompatible with C++ standards before C++17"
HFE8F37E6AE5C: "'static_assert'에 메시지가 없으면 C++17 이전의 C++ 표준과 호환되지 않습니다"
# "'std::allocator<...>::deallocate' used to delete a null pointer"
HF2B279909DBC: "'std::allocator<...>::deallocate'는 null 포인터를 삭제하는 데 사용되었습니다"
# "'std::source_location::__impl' must be standard-layout and have only two 'const char *' fields '_M_file_name' and '_M_function_name', and two integral fields '_M_line' and '_M_column'"
HCA27D3915F0B: "'std::source_location::__impl'는 표준 레이아웃이어야 하며, '_M_file_name'과 '_M_function_name'이라는 이름의 const char * 타입 필드 두 개와 '_M_line'과 '_M_column'이라는 이름의 정수형 필드 두 개만을 가야 합니다."
# "'std::source_location::__impl' was not found; it must be defined before '__builtin_source_location' is called"
HD0F806FB73A8: "'std::source_location::__impl가 발견되지 않았습니다; '__builtin_source_location'을 호출하기 전에 정의되어야 합니다"
# "'super' is only valid in a method body"
HB06D73D4C0E7: "'super'는 메서드 본문 내에서만 유효합니다"
# "'swift_async' completion handler parameter must have block type returning 'void', type here is %0"
H9874890FB098: "'swift_async' 완료 핸들러 매개변수는 반환 값이 'void'인 블록 형식을 가져야 합니다. 현재 여기서의 형식은 %0입니다"
# "'swift_error_result' parameter must follow 'swift_context' parameter"
HFA5F4F66F83B: "‘swift_error_result’ 매개변수는 'swift_context' 매개변수 다음에 와야 합니다"
# "'swift_indirect_result' parameters must be first parameters of function"
H624EF03C7676: "'swift_indirect_result' 매개변수는 함수의 첫 번째 매개변수여야 합니다"
# "'switch' missing 'default' label"
H855B85E209CE: "switch에 'default' 레이블이 없습니다"
# "'sycl_kernel' attribute only applies to a function template with at least two template parameters"
H5AFFA7408711: "'sycl_kernel' 특성은 최소 두 개의 템플릿 매개변수가 있는 함수 템플릿에만 적용됩니다"
# "'sycl_kernel_entry_point' attribute cannot be added to a function after the function is defined"
H018E12D5A5B2: "'sycl_kernel_entry_point' 속성은 함수가 정의된 후에는 추가할 수 없습니다"
# "'sycl_kernel_entry_point' attribute cannot be applied to a %select{non-static member function|variadic function|deleted function|defaulted function|constexpr function|consteval function|function declared with the 'noreturn' attribute|coroutine|function defined with a function try block}0"
H86CAEB999295: "'sycl_kernel_entry_point' 속성은 %select{정적 멤버 함수가 아닌 멤버 함수|가변 인자 함수|삭제된 함수|디폴트화된 함수|constexpr 함수|consteval 함수|'noreturn' 속성을 가진 함수|코루틴|함수 try 블록으로 정의된 함수}0에 적용될 수 없습니다."
# "'sycl_kernel_entry_point' attribute only applies to functions with a 'void' return type"
H99CA3F9B2DC2: "'sycl_kernel_entry_point' 속성은 리턴 타입이 'void'인 함수에만 적용됩니다"
# "'sycl_kernel_entry_point' attribute only applies to functions with a non-deduced 'void' return type"
H14251E8B39CA: "'sycl_kernel_entry_point' 속성은 반환 타입이 추론되지 않은 'void'인 함수에만 적용됩니다"
# "'sycl_kernel_entry_point' kernel name argument conflicts with a previous declaration"
HFAE6DB6B8BBB: "'sycl_kernel_entry_point' 커널 이름 인수는 이전 선언과 충돌합니다"
# "'sycl_kernel_entry_point' kernel name argument does not match prior declaration%diff{: $ vs $|}0,1"
H6714A3237372: "'sycl_kernel_entry_point' 커널 이름 인수가 이전 선언과 일치하지 않습니다%diff{: $와 $ 비교|}0,1"
# "'target_clones' attribute does not match previous declaration"
HBD2CF88C376B: "'target_clones' 속성이 이전 선언과 일치하지 않습니다"
# "'target_clones' multiversioning requires a default target"
HCC23909A82CE: "'target_clones' 멀티버전화는 기본 대상이 필요합니다"
# "'template' cannot be used after a declarative nested name specifier"
H7173607CA62C: '템플릿은 선언적 중첩 이름 지정자 이후에 사용할 수 없습니다.'
# "'template' keyword not permitted after 'using' keyword"
H026D09D01933: "'template' 키워드는 'using' 키워드 이후에 허용되지 않습니다"
# "'template' keyword not permitted here"
HF55CDE212145: "'template' 키워드는 여기서 허용되지 않습니다"
# "'template' keyword not permitted in destructor name"
H67CEB40C2F65: '템플릿 키워드는 소멸자 이름에서 허용되지 않습니다'
# "'template' keyword outside of a template"
H5580CDE2DB12: "템플릿 외부에서 'template' 키워드 사용"
# "'template<>' header not required for explicitly-specialized class %0 declared here"
H3FF5BAF37ECE: "'template<>' 헤더는 명시적으로 특수화된 클래스 %0에 필요하지 않습니다. 여기서 선언되었습니다"
# "'this' argument to member function %0 has type %1, but function is not marked %select{const|restrict|const or restrict|volatile|const or volatile|volatile or restrict|const, volatile, or restrict}2"
HB5D291C13072: "'this' 인수를 갖는 멤버 함수 %0의 형식은 %1이지만, 해당 함수에 %select{const|restrict|const 또는 restrict|volatile|const 또는 volatile|volatile 또는 restrict|const, volatile 또는 restrict}2가 지정되지 않았습니다"
# "'this' argument to member function %0 is an %select{lvalue|rvalue}1, but function has %select{non-const lvalue|rvalue}2 ref-qualifier"
H0AF4BFFD004C: "멤버 함수 %0의 'this' 인수는 %select{lvalue|rvalue}1이지만, 이 함수는 %select{non-const lvalue|rvalue}2 ref-qualifier를 가지고 있습니다."
# "'this' cannot be %select{implicitly |}0captured in this context"
H0697D44E3441: "'this'는 이 컨텍스트에서 %select{암시적으로 |}0포착될 수 없습니다"
# "'this' cannot be captured by reference"
H13B6762030CD: "'this'는 참조로 캡처될 수 없습니다"
# "'this' cannot be%select{| implicitly}0 used in a static member function declaration"
H4C9AC15A6831: '“this”는%select{| 명시적으로}0 정적 멤버 함수 선언에서 사용할 수 없습니다.'
# "'this' pointer cannot be null in well-defined C++ code; comparison may be assumed to always evaluate to %select{true|false}0"
HC979F6DEC864: "'this' 포인터는 정의되지 않은 C++ 코드에서 null일 수 없습니다; 비교 연산이 항상 %select{참|거짓}0로 평가될 수 있습니다"
# "'this' pointer cannot be null in well-defined C++ code; pointer may be assumed to always convert to true"
HE4633A40CE28: "'this' 포인터는 정의된 C++ 코드에서 NULL일 수 없습니다; 포인터가 항상 true로 변환될 수 있다고 가정될 수 있습니다"
# "'this' pointer references not allowed in naked functions"
H95FED6FF2C73: "'this' 포인터 참조는 naked 함수에서 허용되지 않습니다."
# "'trivial_abi' cannot be applied to %0"
H39CEA0BB8E5A: "'trivial_abi'는 %0에 적용할 수 없습니다"
# "'trivial_abi' is disallowed on %0 because %select{its copy constructors and move constructors are all deleted|it is polymorphic|it has a base of a non-trivial class type|it has a virtual base|it has a __weak field|it has a field of a non-trivial class type|it has an address-discriminated '__ptrauth' field}1"
HF2341EAAEAEC: "'trivial_abi'는 %0에서 금지되었습니다. %select{복사 생성자와 이동 생성자가 모두 삭제됨|폴리모픽 클래스임|비平凡 클래스 형식의 기반 클래스를 가짐|가상 기반 클래스를 가짐|__weak 필드를 가짐|비平凡 클래스 형식의 필드를 가짐|주소 구분 '__ptrauth' 필드를 가짐}1"
# "'true' is not defined, evaluates to 0"
HEC6C8880A6A3: "'true'가 정의되지 않았습니다. 0으로 평가됩니다"
# "'type_tag_for_datatype' attribute requires the initializer to be an %select{integer|integral}0 constant expression"
H2191B1B324E8: "'type_tag_for_datatype' 특성은 초기화자를 %select{정수|정수형}0 상수 표현식으로 지정해야 합니다"
# "'type_tag_for_datatype' attribute requires the initializer to be an %select{integer|integral}0 constant expression that can be represented by a 64 bit integer"
HD8F7C3D572F8: "'type_tag_for_datatype' 속성은 초기화자가 64비트 정수로 표현될 수 있는 %select{정수|정수형}0 상수 표현식이어야 합니다"
# "'typeid' of incomplete type %0"
H9D618623D4E9: "'typeid'의 대상 형식 %0이 완전하지 않습니다"
# "'typeid' of variably modified type %0"
HB7FBFC93B3FA: "'typeid'의 가변 길이 형식 %0"
# "'typename' is redundant; base classes are implicitly types"
HD8EB6D904937: "'typename'은 필요 없습니다; 기반 클래스는 암시적으로 유형입니다"
# "'typename' keyword used on a non-type"
HEFF0F4A3C4F6: "'typename' 키워드는 비형식(non-type)에 사용되었습니다."
# "'typename' outside of a template is a C++11 extension"
H2C5188CF8D58: "'typename' 키워드를 템플릿 밖에서 사용하는 것은 C++11 확장 기능입니다"
# "'typename' outside of a template is incompatible with C++98"
H89322C630BA2: "'typename' 템플릿 밖에서 사용되는 경우 C++98과 호환되지 않습니다"
# "'unavailable' availability overrides all other availability information"
H321E5EA6571D: "'unavailable' 가용성은 모든 다른 가용성 정보를 덮어씁니다."
# "'using namespace' is not allowed in classes"
H133BFD711C94: "'using namespace'는 클래스 내에서는 허용되지 않습니다"
# "'using_if_exists' attribute cannot be applied to an inheriting constructor"
H551D8C76B087: "'using_if_exists' 속성은 상속 생성자에 적용할 수 없습니다"
# "'va_start' cannot be used in a captured statement"
H7AC0FC921988: "'va_start'는 캡처된 문에서 사용할 수 없습니다"
# "'va_start' cannot be used outside a function"
HFCBDF5268E7D: 'va_start는 함수 밖에서 사용할 수 없습니다.'
# "'va_start' used in %select{System V|Win64}0 ABI function"
HCA2FE8C64692: "'va_start'가 %select{System V|Win64}0 ABI 함수에서 사용되었습니다"
# "'va_start' used in function with fixed args"
HDCEB40407EDC: "'va_start'가 고정된 인수를 가진 함수에서 사용되었습니다"
# "'vec_step' requires built-in scalar or vector type, %0 invalid"
H2D0A081561E0: "'vec_step'은 내장 스칼라 또는 벡터 형식이 필요합니다, %0는 무효입니다"
# "'virtual' can only appear on non-static member functions"
HB1449ED6BD56: "'virtual'은 비정적 멤버 함수에만 나타날 수 있습니다"
# "'virtual' can only be specified inside the class definition"
HC2C042A27D12: "'virtual'은 클래스 정의 내에서만 지정할 수 있습니다"
# "'virtual' cannot be specified on member function templates"
H345B16C9EDA3: "'virtual'은 멤버 함수 템플릿에 지정할 수 없습니다"
# "'void' as parameter must not have type qualifiers"
H3B7FE1A42F0E: "'void'를 매개변수로 사용하는 경우 유형 자격 증명자를 가질 수 없습니다"
# "'void' must be the first and only parameter if specified"
H7DDAB71DFE28: "'void'는 지정되었을 경우 첫 번째이자 유일한 매개변수여야 합니다"
# "'||' of a value and its negation always evaluates to true"
H067D990351EF: '|| 연산자를 사용하여 어떤 값과 그 부정을 결합하면 항상 참으로 평가됩니다'
# "'~' in destructor name should be after nested name specifier"
H85ED3FE9838A: "소멸자의 이름에서 '~'는 중첩 이름 지정자 뒤에 와야 합니다"
# "(Deprecated) Controls whether '-Winvalid-gnu-asm-cast' defaults to an error or a warning"
HBE7A04BC29B9: "(비추천됨) '-Winvalid-gnu-asm-cast' 옵션이 기본적으로 오류 또는 경고로 설정되는지 제어합니다"
# "(For new pass manager) 'per-pass': one report for each pass; 'per-pass-run': one report for each pass invocation"
H0C49717D08C4: "(새 패스 매니저를 위한) 'per-pass': 각 패스마다 하나의 보고서; 'per-pass-run': 각 패스 호출마다 하나의 보고서"
# '(integrated-as) Emit an object file which can be used with an incremental linker'
HC13894BE0052: '(integrated-as) 증분 링커와 함께 사용할 수 있는 오브젝트 파일을 생성합니다'
# '(integrated-as) Emit an object file which cannot be used with an incremental linker'
H902BD058678C: '(통합된 어셈블러) 증분 링커와 함께 사용할 수 없는 목적 파일을 생성합니다'
# '(integrated-as) Relax all machine instructions'
H523BAD847EDC: '(integrated-as) 모든 머신 명령문을 완화하기'
# "(skipping %0 'operator->'%s0 in backtrace)"
H3980AA6C4367: "(백트레이스에서 %0 'operator->'%s0을(를) 건너뜁니다)"
# '(skipping %0 call%s0 in backtrace; use -fconstexpr-backtrace-limit=0 to see all)'
HD7D8BC5DDF54: '(백트레이스에서 %0 개의 호출%s0 건너뛰기; -fconstexpr-backtrace-limit=0 옵션을 사용하여 모두 표시)'
# '(skipping %0 context%s0 in backtrace; use -ftemplate-backtrace-limit=0 to see all)'
H1BB10F671BF7: '(백트레이스에서 %0 context%s0을(를) 건너뜁니다; 모두 표시하려면 -ftemplate-backtrace-limit=0 옵션을 사용하십시오)'
# '*no default*'
H01EF8BE8DE07: '기본값 없음'
# '--rtlib=libgcc requires --unwindlib=libgcc'
HED8A5F89C398: '--rtlib=libgcc는 --unwindlib=libgcc가 필요합니다'
# '-E or -x required when input is from standard input'
H5AC04D68943E: '-E 또는 -x 옵션이 표준 입력에서 입력이 올 때는 필요합니다'
# '-O4 is equivalent to -O3'
H0B5239D5C711: '옵션 -O4는 -O3와 동일합니다'
# '-Wa,--allow-experimental-crel must be specified to use -Wa,--crel. CREL is experimental and uses a non-standard section type code'
HB2A451FA1760: '-Wa,--allow-experimental-crel 옵션이 지정되어야 -Wa,--crel을 사용할 수 있습니다. CREL은 실험적 기능이며 비표준 섹션 유형 코드를 사용합니다'
# '-code-completion-at=<file>:<line>:<column> requires <line> and <column> to be integers greater than zero'
HEFD41ED402A1: '-code-completion-at=<파일>:<줄>:<열>은(는) <줄>과 <열>이 0보다 큰 정수여야 합니다.'
# '-dealloc is being overridden in a category'
H75DBC0C062A1: '-dealloc 메소드가 카테고리에서 재정의되고 있습니다.'
# '-dependency-file requires at least one -MT or -MQ option'
HF99E1B6F31F8: '-dependency-file는 최소한 하나의 -MT 또는 -MQ 옵션이 필요합니다'
# '-emit-llvm cannot be used when linking'
H8745DC614FEB: '-emit-llvm는 링킹 시 사용할 수 없습니다.'
# '-fdelayed-template-parsing is deprecated after C++20'
HD52CE72E55C9: '--fdelayed-template-parsing은 C++20 이후에 더 이상 사용되지 않습니다'
# '-fembed-bitcode is not supported on versions of iOS prior to 6.0'
HD9B9277DB1F5: '-fembed-bitcode는 iOS 6.0 이전 버전에서는 지원되지 않습니다'
# '-fexperimental-omit-vtable-rtti call only be used with -fno-rtti'
H27AC8E91BEE0: '-fexperimental-omit-vtable-rtti는 오직 -fno-rtti와 함께 사용될 수 있습니다'
# "-fglobal-isel support for the '%0' architecture is incomplete"
HB8576FBD6C6A: "-fglobal-isel 옵션의 '%0' 아키텍처 지원이 완료되지 않았습니다"
# '-fglobal-isel support is incomplete for this architecture at the current optimization level'
HD08F381A1C6F: '-fglobal-isel 지원은 현재 최적화 레벨에서 이 아키텍처에 대해 완전하지 않습니다'
# '-fjmc works only for ELF; option ignored'
H862E3BB749F5: '-fjmc는 ELF에서만 작동합니다; 옵션이 무시됩니다'
# '-fobjc-arc is not supported on platforms using the legacy runtime'
HE6B9338AE9F6: "옵션 '-fobjc-arc'는 전통 런타임을 사용하는 플랫폼에서는 지원되지 않습니다"
# '-fobjc-arc is not supported on versions of OS X prior to 10.6'
H0AF526E18958: '-fobjc-arc는 OS X 10.6 이전 버전에서는 지원되지 않습니다'
# '-fobjc-weak is not supported in Objective-C garbage collection'
H7AD62E69E380: '-fobjc-weak는 Objective-C 가비지 컬렉션에서 지원되지 않습니다'
# '-fobjc-weak is not supported on the current deployment target'
H062C1F6DCD65: '-fobjc-weak는 현재 배포 대상에서 지원되지 않습니다'
# '-fsanitize-address-field-padding applied to %0'
H3C21F4C44A7E: '-fsanitize-address-field-padding 옵션이 %0에 적용되었습니다.'
# '-fsanitize-address-field-padding ignored for %0 because it %select{is not C++|is packed|is a union|is trivially copyable|has trivial destructor|is standard layout|is in a ignorelisted file|is ignorelisted}1'
H6C62B9F141CF: '-fsanitize-address-field-padding %0에 대해 무시됨: %select{C++가 아님|압축됨|유니온|간단한 복사 가능|단순한 소멸자|표준 레이아웃|무시 목록 파일 내|무시 목록 항목}1'
# "-ftest-module-file-extension argument '%0' is not of the required form 'blockname:major:minor:hashed:user info'"
HA7F31D279886: "-ftest-module-file-extension 인수 '%0'는 필요한 형식 'blockname:major:minor:hashed:user info'가 아닙니다"
# '-ftrivial-auto-var-init-stop-after=%0 has been enabled to limit the number of times ftrivial-auto-var-init=%1 gets applied.'
HA5103A32F2CB: '-ftrivial-auto-var-init-stop-after=%0이 활성화되어 ftrivial-auto-var-init=%1이 적용되는 횟수를 제한했습니다.'
# '-header-include-filtering=%0 requires a compatible value for -header-include-format'
HFD5CA9639FF5: '-header-include-filtering=%0은(는) -header-include-format에 대한 호환 가능한 값이 필요합니다.'
# '-header-include-format=%0 requires a compatible value for -header-include-filtering'
H11F9E33E0B1B: '-header-include-format=%0은(는) -header-include-filtering에 대한 호환 가능한 값이 필요합니다.'
# '-mcmse is not supported for %0'
HBC9BABD34806: '-mcmse는 %0를 위해 지원되지 않습니다'
# '-mharden-sls is only supported on armv7-a or later'
H370C2A9E9085: '-mharden-sls 옵션은 armv7-a 또는 그 이후 버전에서만 지원됩니다'
# '-mtocdata option is ignored for %0 because %1'
HFF374450D777: '-mtocdata 옵션이 %0에 대해 %1 때문에 무시됩니다'
# '-mxcoff-roptr is not supported with -shared'
H6DCDD2D9C271: '-mxcoff-roptr는 -shared와 함께 사용할 수 없습니다.'
# '-mxcoff-roptr is supported only with -fdata-sections'
H64F8AE7E83F9: '-mxcoff-roptr은 -fdata-sections와 함께 사용될 때만 지원됩니다'
# '-verify prefixes must start with a letter and contain only alphanumeric characters, hyphens, and underscores'
H52220FBA1BD4: '-verify 접두사는 대문자 또는 소문자로 시작해야 하며, 알파벳, 숫자, 하이픈(-), 밑줄(_)만 포함해야 합니다'
# '.dwo output filename'
HEF051A2EFA9C: '.dwo 출력 파일 이름'
# '// comments are not allowed in this language'
HC63D7ED8A253: '// 주석은 이 언어에서 허용되지 않습니다'
# '/arm64EC has been overridden by specified target: %0; option ignored'
HD52B23C67DCF: '/arm64EC가 지정된 타겟: %0에 의해 덮어쓰어졌습니다; 옵션이 무시됨'
# '32-bit targets are not supported when building for Mac Catalyst'
H2B5ECA150DDF: '32-bit 대상은 Mac Catalyst를 위한 빌드 시 지원되지 않습니다'
# '90th percentile durations'
HCFF900413C06: '90th 백분위 지속 시간'
# '99th percentile durations'
H401BE67F4D43: '99 백분위 지속 시간'
# ": Did you mean '"
HF9464896A916: ": 의미하는 것이 '"
# ': Not enough positional command line arguments specified!\n'
H41F31955D402: ': 지정된 포지셔널 명령 줄 인수가 충분하지 않습니다!\n'
# ': See: '
HAF76FB12E339: ': 참조: '
# ': Too many positional arguments specified!\n'
H166421801500: '위치 인수를 너무 많이 지정했습니다!\n'
# ': Unknown '
H62CC89B124B8: ': 알 수 없음 '
# '<INDEX FILE>'
HA21BDF8C3F73: '<인덱스 파일>'
# '<Line Number>'
H6986C655554D: '에러: 세미콜론 (;)이 누락되었습니다'
# '<Line Number>.<Discriminator>'
H9B952BEB1010: '<라인 번호.디스크리미네이터>'
# '<Line Number>:<Column Number>'
H3D8D3ACA02BF: '행 번호:열 번호'
# '<Line Number>:<Column Number>.<Discriminator> (default)'
HF63B70CCE643: '<줄 번호>:<열 번호>.<식별자> (기본값)'
# '<PROJECT ROOT>'
H49C3DE6F4DBC: '<프로젝트 루트>'
# '<Search Root Directory>'
H6D7091309552: '<검색 루트 디렉토리>'
# '<Source file>'
H6EC586CC52E3: '소스 파일'
# '<Source files>'
H3C1CECBB7A05: '<소스 파일>'
# '<arguments to be passed to front end>...'
H60720E11CCAF: '프론트엔드에 전달할 인수...'
# '<base profile file>'
H8C88CD489F08: '<기본 프로파일 파일>'
# '<check-file>'
HAFAA29ACBEA3: '<파일 검사>'
# '<data file>'
HF37127A33D60: '<데이터 파일>'
# '<demangler-path>|<demangler-option>'
H7D9510852764: '<디맨글러-경로>|<디맨글러-옵션>'
# '<destination>'
H10F397C9B9E7: '<목적지>'
# '<diagnostic-name>'
H48ABA509B551: '오류: 식이 예상됩니다'
# '<executable>'
H194C8BA9DC59: '실행 파일'
# '<fdata1> [<fdata2>]...'
H31B7871CCFAC: '옵션 또는 인수...'
# '<filename...>'
HFE7069E9DD18: '<파일명...>'
# '<filename>'
HB80C8D77FF58: '파일 이름'
# '<first file>'
H701B2C95DDEA: '첫 번째 파일'
# '<from>,<to> Map coverage data paths to local source file paths'
HA29C275A5689: '<from>,<to> 커버리지 데이터 경로를 로컬 소스 파일 경로로 매핑합니다'
# '<gcc-tool arguments>...'
H14ED68F16708: '<gcc-도구 인수>...'
# '<globals to compare>'
HDCFEFCD16186: '비교할 글로벌 변수'
# '<gpu executable>'
HE3D4861759AD: '<GPU 실행 파일>'
# '<high>,<low> value indicate thresholds for high and lowcoverage watermark'
HEAFB910E7206: '<high>,<low> 값은 고 및 저 커버리지 워터마크의 임계값을 지정합니다'
# '<input .ll file>'
HBDCA7FE10EAC: '<입력 .ll 파일>'
# '<input IR file>'
H7E82294FE4BC: '입력 IR 파일'
# '<input PDB file>'
H709A48456EF7: '입력 PDB 파일'
# '<input PDB files>'
H126A4B67EBAB: '<입력 PDB 파일>'
# '<input YAML file>'
H7A7A324B78FC: '입력 YAML 파일'
# '<input bitcode file>'
H0498EDBECDA2: '입력 비트코드 파일'
# '<input bitcode files>'
H18F82A53F250: '입력 비트코드 파일'
# '<input bitcode>'
HC1462E145577: '<입력 비트코드>'
# '<input brainf>'
H925565A9DFB3: '<입력 brainf>'
# '<input file #1>'
H8FA0EC745E89: '<입력 파일 #1>'
# '<input file #2>'
H09D1580255E0: '<입력 파일 #2>'
# '<input file>'
HC2587AA6902C: '입력 파일'
# '<input files>'
H9415F263685E: '입력 파일'
# '<input kernel json file>'
HF85B67BC3727: '입력 커널 JSON 파일'
# '<input llvm ll/bc file>'
HC39181A9A624: '<입력 llvm ll/bc 파일>'
# '<input llvm ll/bc files>'
H41A5FA014705: '<LLVM ll/bc 파일 입력>'
# '<input object files or .dSYM bundles>'
HDA6B96681ECA: '<입력 오브젝트 파일 또는 .dSYM 번들>'
# '<input object files>'
HD219B490846E: '<입력 오브젝트 파일>'
# '<input symbols>'
H45D1386EF577: '에러: 초기화 목록에서 %T를 %T로 변환할 수 없습니다'
# '<input toy file>'
H84A385940941: '<입력 장난감 파일>'
# '<input>'
H89C4EB09495F: '<input>'
# '<list of one or more header list files>'
H27C475BB767E: '<하나 이상의 헤더 목록 파일의 목록>'
# '<maxsize>'
H327F70512C50: '<최대 크기>'
# '<module summary index>'
HC647DB885E7B: '<모듈 요약 인덱스>'
# '<opt arguments>...'
HCE37C5C87525: '<옵션 인수>...'
# '<output file>'
H44B468338EC5: '출력 파일'
# '<path to index file | remote:server.address>'
H55C1FC4669FC: '<인덱스 파일 경로 | 원격:서버 주소>'
# '<profdata-file>'
H83762F3A8AFE: '<프로파일 데이터 파일>'
# '<program arguments>...'
H9648B06044BF: '<프로그램 인수...>'
# '<program to run>'
H9127819F0F1D: '실행할 프로그램'
# '<safe-tool arguments>...'
H5EABB33684C4: '<안전 도구 인수>...'
# '<second file>'
H59A18696A728: '<두 번째 파일>'
# '<source0> [... <sourceN>]'
H4D671F64A81C: '<소스0> [... <소스N>]'
# '<source>'
HE6634DF59D09: '<소스>'
# "<start line>:<end line> - format a range of\nlines (both 1-based).\nMultiple ranges can be formatted by specifying\nseveral -lines arguments.\nCan't be used with -offset and -length.\nCan only be used with one input file."
HDEA3B9BD2A49: '<시작 줄>:<종료 줄> - 1 기반으로 된 줄의 범위를 포맷합니다.\n여러 개의 -lines 인수를 지정하면 여러 개의 범위를 포맷할 수 있습니다.\n-offset과 -length와 함께 사용할 수 없습니다.\n단일 입력 파일과만 사용할 수 있습니다.'
# '<symbol-file>'
H6E5CDBA6FB29: '<기호 파일>'
# '<test profile file>'
H11468CAF4D7F: '<테스트 프로파일 파일>'
# '<tool arguments>...'
HF6F458922E63: '<도구 인수>...'
# '<topdown|bottomup>'
H9180E4B0E8C6: '<상향식|하향식>'
# '<weight>,<filename>'
HCEE927C66E78: '<무게>,<파일명>'
# '<xray fdr mode log>'
H4907FD73C66B: '<X레이 FDR 모드 로그>'
# '<xray log file 1>'
HB4D281AAED36: '<xray 로그 파일 1>'
# '<xray log file 2>'
H1C142C095FCF: '<xray 로그 파일 2>'
# '<xray log file>'
HE9A7E93A5C35: '<xray 로그 파일>'
# '<xray trace>'
HA7901FE618F5: 'XRay 추적'
# '= *cannot print option value*\n'
HE274379BF9C1: '= *옵션 값을 출력할 수 없습니다*\n'
# '= *unknown option value*\n'
H164C5812BA3B: '= 알 수 없는 옵션 값\n'
# '?: operator with omitted middle operand cannot be mangled'
H3E44EE9DABB8: '중간 피연산자를 생략한 ?: 연산자는 mangling이 불가능합니다'
# '@%0 must be followed by a number to form an NSNumber object'
HDF1E414372F2: '@%0는 NSNumber 객체를 생성하기 위해 숫자로 이어져야 합니다'
# "@catch parameter cannot have storage specifier '%0'"
HAEB289D52AD8: "@catch 매개변수는 저장 지정자 '%0'를 가질 수 없습니다"
# '@catch parameter declarator cannot be qualified'
H9BAC8F95B81C: '@catch 매개변수 선언자는 자격을 가질 수 없습니다'
# '@catch parameter is not a pointer to an interface type'
HE87FCFF30D0A: '@catch 매개변수가 인터페이스 형식의 포인터가 아닙니다'
# '@defs is not supported in Objective-C++'
H64B526C3172C: '@defs는 Objective-C++에서 지원되지 않습니다'
# '@implementation cannot have type parameters'
HA936A031AC88: '@implementation은 유형 매개변수를 가질 수 없습니다'
# '@implementation declaration cannot be protocol qualified'
H4CA986D1E0F8: '@implementation 선언은 프로토콜 자격을 가질 수 없습니다.'
# "@import of module '%0' in implementation of '%1'; use #import"
H16AC87FD7968: "@import 모듈 '%0'을(를) '%1'의 구현에서 사용했습니다; 대신 #import를 사용하십시오."
# '@protocol is using a forward protocol declaration of %0'
H0D6847EE9BAD: '@protocol은 %0의 전방 프로토콜 선언을 사용 중입니다'
# '@selector expression formed with direct selector %0'
HB5C475EA47ED: '@selector 표현식이 직접 선택자 %0로 형성되었습니다'
# '@selector expression formed with potentially direct selector %0'
H7FC0DE89B5F4: '@selector 표현식이 직접적일 수 있는 셀렉터 %0로 형성되었습니다'
# '@synchronized requires an Objective-C object type (%0 invalid)'
H4E94A0FBFD2A: '@synchronized는 Objective-C 객체 형식이 필요합니다 (%0 무효)'
# "@synthesize not allowed in a category's implementation"
HAD49CB90931E: '@synthesize는 카테고리 구현体内에서 사용할 수 없습니다'
# '@synthesize not allowed on a class property %0'
H37538A67AC33: '@synthesize는 클래스 프로퍼티 %0에서 사용할 수 없습니다'
# '@throw (rethrow) used outside of a @catch block'
HAB2C03614B94: '@throw (rethrow)는 @catch 블록 외부에서 사용되었습니다'
# '@throw requires an Objective-C object type (%0 invalid)'
HF85FCC60471E: '@throw는 Objective-C 객체 타입이 필요합니다. (%0이 유효하지 않습니다)'
# '@try statement without a @catch and @finally clause'
H0097E9BE678E: '@try 문에 @catch 및 @finally 절이 없습니다'
# 'A CSV file containing (JITDylib, Function) pairs tospeculatively look up'
H27E7912AA129: 'JITDylib와 Function 쌍을 예측적으로 검색하기 위해 포함된 CSV 파일'
# 'A No-Op Barrier Pass'
H189EA9AAB8E2: '무작용 장벽 패스'
# 'A boolean option to show CFG dag or text with block profile counts and branch probabilities right after PGO profile annotation step. The profile counts are computed using branch probabilities from the runtime profile data and block frequency propagation algorithm. To view the raw counts from the profile, use option -pgo-view-raw-counts instead. To limit graph display to only one function, use filtering option -view-bfi-func-name.'
H1F6AD91CDAD1: 'PGO 프로파일 어노테이션 단계 직후 CFG dag 또는 텍스트를 표시하는 불리언 옵션입니다. 프로파일 카운트는 런타임 프로파일 데이터의 분기 확률과 블록 빈도 전파 알고리즘을 사용하여 계산됩니다. 프로파일에서 원시 카운트를 보기 위해서는 -pgo-view-raw-counts 옵션을 대신 사용하세요. 그래프 표시를 단 하나의 함수로 제한하려면 -view-bfi-func-name 필터링 옵션을 사용하세요.'
# 'A boolean option to show CFG dag or text with raw profile counts from profile data. See also option -pgo-view-counts. To limit graph display to only one function, use filtering option -view-bfi-func-name.'
H84462D2AF2CA: '프로파일 데이터에서 원시 프로파일 카운트와 함께 CFG DAG 또는 텍스트를 표시하는 불리언 옵션입니다. 또한 옵션 -pgo-view-counts도 참고하세요. 그래프 표시를 단일 함수로 제한하려면 필터링 옵션 -view-bfi-func-name을 사용하세요.'
# 'A comma-separated list of regexes to match against suffix of a header, and disable analysis if matched.'
HC652CCDF0460: '헤더의 접미사와 일치시키기 위한 정규식의 쉼표로 구분된 목록, 일치할 경우 분석을 비활성화합니다.'
# 'A comma-separated list of regexes to match against suffix of a header. Only headers that match will be analyzed.'
H98978B75D13A: '헤더 파일의 확장자와 일치하는 정규식 목록을 쉼표로 구분한 목록입니다. 일치하는 헤더만 분석됩니다.'
# 'A count is cold if it is below the minimum count to reach this percentile of total counts.'
H2339A8FDD5A8: '카운트가 cold 상태라면 전체 카운트의 이 백분율에 도달하기 위한 최소 카운트 미만인 경우입니다.'
# 'A count is hot if it exceeds the minimum count to reach this percentile of total counts.'
H7D01FE9FC1EB: '카운트가 총 카운트의 이 백분위수에 도달하기 위한 최소 카운트를 초과하면 이 카운트는 핫합니다.'
# 'A debug option to add additional penalty to the computed one.'
H2D6A17BDE0D3: '계산된 값에 추가 패널티를 적용하는 디버그 옵션입니다.'
# 'A file containing a list of files to process, one per line.'
H3723DB39ACD6: '처리할 파일들의 목록이 기록된 파일, 한 줄에 하나씩.'
# 'A file containing list of basic blocks to extract'
HBF68C649BA33: '추출할 기본 블록 목록이 포함된 파일'
# 'A file containing list of symbol names to preserve'
HCBA362E0A436: '보존할 심볼 이름 목록이 포함된 파일'
# 'A file containing regexes of symbol names that are not expected to be updated when changing namespaces around them.'
HE689FDC11988: '주변 네임스페이스 변경 시 업데이트되지 않을 것으로 예상되는 심볼 이름의 정규식을 포함하는 파일'
# 'A file in which to write minimized bitcode for the thin link only'
HC50A535724B5: 'thin link 전용 최소화된 비트코드를 작성할 파일'
# 'A fixed cold count that overrides the count derived from profile-summary-cutoff-cold'
H6BD0A927E583: 'profile-summary-cutoff-cold에서 유도된 count 값을 대체하는 고정된 cold count 값'
# 'A fixed hot count that overrides the count derived from profile-summary-cutoff-hot'
HDDA22CC4FF28: 'profile-summary-cutoff-hot에서 파생된 카운트를 대체하는 고정된 핫 카운트'
# "A flag that overrides the target's expected cost for an instruction to a single constant value. Mostly useful for getting consistent testing."
HB9C94533EB20: '타겟의 명령어에 대한 예상 비용을 단일 상수 값으로 재정의하는 플래그. 주로 일관된 테스트를 위해 유용함.'
# "A flag that overrides the target's max interleave factor for scalar loops."
H8C8153E64ADB: '스칼라 루프에 대한 타겟의 최대 인터리빙 요소를 재정의하는 플래그입니다.'
# "A flag that overrides the target's max interleave factor for vectorized loops."
H3505D260BD96: '벡터화 루프의 타겟 최대 인터리브 요소를 재정의하는 플래그'
# "A flag that overrides the target's number of scalar registers."
HFF8F958A02D3: '타겟의 스칼라 레지스터 수를 재정의하는 플래그입니다.'
# "A flag that overrides the target's number of vector registers."
HEC99B1D21B33: '타겟의 벡터 레지스터 개수를 재정의하는 플래그입니다.'
# "A flag that overrides the target's preferred addressing mode."
H7B1AA7CE93D4: '타겟의 선호하는 주소 모드를 대체하는 플래그입니다.'
# 'A function is considered hot for staleness error check if its total sample count is above the specified percentile'
H652DA545BF0D: '함수의 총 표본 수가 지정된 백분위를 초과하면, 그 함수는 staleness 오류 검사에서 핫 함수로 간주됩니다'
# 'A function name, assumed to be global, which will be treated as the root of an interesting graph, which will be profiled independently from other similar graphs.'
H3FD0C1E415AD: '전역으로 가정되는 함수 이름으로, 흥미로운 그래프의 루트로 처리되어 다른 유사한 그래프와 독립적으로 프로파일링됩니다.'
# 'A huge scheduling region will have maps reduced by this many nodes at a time. Defaults to HugeRegion / 2.'
HAEEA6B54FAD5: '대규모 스케줄링 영역의 맵은 한 번에 이렇게 많은 노드 수만큼 감소합니다. 기본값은 HugeRegion / 2입니다.'
# 'A key=value pair. Replace __nvvm_reflect(name) with value.'
H3D02297FABD7: '키=값 쌍입니다. __nvvm_reflect(name)을 값으로 대체합니다.'
# 'A lexical block (Function, Class, etc.).'
HC41EB530ACBA: 'лекс(лекс) 블록(함수, 클래스 등).'
# "A list of mangled vtable type info names. Classes specified by the type info names and their derived ones will not be vtable-ICP'ed. Useful when the profiled types and actual types in the optimized binary could be different due to profiling limitations. Type info names are those string literals used in LLVM type metadata"
HB3A60F3783C6: 'angling된 vtable type info 이름들의 목록. type info 이름으로 지정된 클래스와 그들의 파생 클래스들은 vtable-ICP 처리되지 않을 것입니다. 프로파일링 제한으로 인해 최적화된 이진 파일 내에서 프로파일링된 유형과 실제 유형이 다를 수 있는 경우에 유용합니다. 유형 정보 이름들은 LLVM 유형 메타데이터에 사용되는 문자열 리터럴들입니다'
# 'A list of symbol names to preserve'
HC033F70F7A4D: '보존할 기호 이름의 목록'
# "A multiplier on top of cycle savings to decide whether the savings won't justify the cost"
H6A89F885E7F6: '사이클 절약 위에 있는 계수로, 절약이 비용을 정당화하지 않는지 판단하기 위해 사용됩니다'
# "A string that'll be prepended to all log statements. Useful when running multiple instances on same host."
HE0B8D8E429AE: '모든 로그 문장에 앞에 추가될 문자열입니다. 동일 호스트에서 여러 인스턴스를 실행할 때 유용합니다.'
# 'A textual (comma separated) description of the pass pipeline e.g.,-passes="foo,bar", to have analysis passes available before a pass, add "require<foo-analysis>". See https://llvm.org/docs/NewPassManager.html#invoking-opt for more details on the pass pipeline syntax. '
HB4D744456DA4: '예를 들어 -passes="foo,bar"와 같이 텍스트 형식(쉼표 구분자)의 패스 파이프라인 설명입니다. 패스 이전에 분석 패스를 사용할 수 있도록 하려면 "require<foo-analysis>"을 추가하십시오. 패스 파이프라인 구문에 대한 자세한 내용은 https://llvm.org/docs/NewPassManager.html#invoking-opt 를 참조하십시오.'
# 'A textual description of the alias analysis pipeline for handling managed aliasing queries'
H4D54EF8DEC89: '관리된 aliasing 쿼리를 처리하기 위한 alias analysis 파이프라인의 텍스트 설명'
# 'A textual description of the cgscc pass pipeline inserted at the CGSCCOptimizerLate extension point into default pipelines'
HFA3CF56CCD45: 'CGSCCOptimizerLate 확장 포인트에 기본 파이프라인에 삽입된 cgscc 패스 파이프라인의 텍스트 설명'
# 'A textual description of the function pass pipeline inserted at the Peephole extension points into default pipelines'
H1744F3F7F9B4: '기본 파이프라인에 피히폴 확장 포인트에 삽입된 함수 패스 파이프라인의 텍스트 설명'
# 'A textual description of the function pass pipeline inserted at the ScalarOptimizerLate extension point into default pipelines'
HA2E18C3D97E7: '기본 파이프라인에 ScalarOptimizerLate 확장 포인트에 삽입된 함수 패스 파이프라인의 텍스트 설명'
# 'A textual description of the function pass pipeline inserted at the VectorizerEnd extension point into default pipelines'
HD2BE547AE303: 'VectorizerEnd 확장점에 기본 파이프라인에 삽입된 함수 패스 파이프라인의 텍스트 설명'
# 'A textual description of the function pass pipeline inserted at the VectorizerStart extension point into default pipelines'
HA843C3B1B6F5: 'VectorizerStart 확장 지점에 기본 파이프라인에 삽입된 함수 패스 파이프라인의 텍스트 설명'
# 'A textual description of the loop pass pipeline inserted at the LateLoopOptimizations extension point into default pipelines'
H081E56CD31AA: '기본 파이프라인에 LateLoopOptimizations 확장 점에 삽입된 루프 패스 파이프라인의 텍스트 설명'
# 'A textual description of the loop pass pipeline inserted at the LoopOptimizerEnd extension point into default pipelines'
HFDB774C5E68A: '기본 파이프라인에 LoopOptimizerEnd 확장 지점에 삽입된 루프 패스 파이프라인의 텍스트 설명'
# 'A textual description of the module pass pipeline inserted at the EarlySimplification extension point into default pipelines'
HADF08723EA0B: '기본 파이프라인에 EarlySimplification 확장 포인트에 삽입된 모듈 패스 파이프라인의 텍스트 설명'
# 'A textual description of the module pass pipeline inserted at the FullLinkTimeOptimizationEarly extension point into default pipelines'
HBAAC4BEB26E7: '기본 파이프라인에 FullLinkTimeOptimizationEarly 확장 포인트에 삽입된 모듈 패스 파이프라인의 텍스트 설명'
# 'A textual description of the module pass pipeline inserted at the FullLinkTimeOptimizationLast extension point into default pipelines'
HC7A2BAD76212: '기본 파이프라인에 FullLinkTimeOptimizationLast 확장 포인트에서 삽입된 모듈 패스 파이프라인에 대한 텍스트 설명'
# 'A textual description of the module pass pipeline inserted at the OptimizerEarly extension point into default pipelines'
H556744FF114A: '기본 파이프라인에 OptimizerEarly 확장점에 삽입된 모듈 패스 파이프라인의 텍스트 설명'
# 'A textual description of the module pass pipeline inserted at the OptimizerLast extension point into default pipelines'
H97AB14D6A40C: '기본 파이프라인에 OptimizerLast 확장점에 삽입된 모듈 패스 파이프라인의 텍스트 설명'
# 'A textual description of the module pass pipeline inserted at the PipelineStart extension point into default pipelines'
H5D27DE009EB3: '디폴트 파이프라인에 PipelineStart 확장 지점에 삽입된 모듈 패스 파이프라인의 텍스트 설명'
# 'A textual description of the pass pipeline for testing'
H07C815591653: '테스트를 위한 패스 파이프라인의 텍스트 설명'
# "A textual description of the pass pipeline, same as what's passed to `opt -passes`."
HAD654D568007: '패스 파이프라인의 텍스트 설명으로, `opt -passes`에 전달되는 것과 동일합니다.'
# "A textual description of the pass pipeline. To have analysis passes available before a certain pass, add 'require<foo-analysis>'."
HB92573A0FB9B: "패스 파이프라인의 텍스트 설명입니다. 특정 패스 이전에 분석 패스를 사용할 수 있도록 하려면 'require<foo-analysis>'를 추가하세요."
# "A textual description of the pass pipeline. To have analysis passes available before a certain pass, add 'require<foo-analysis>'. '-passes' overrides the pass pipeline (but not all effects) from specifying '--opt-level=O?' (O2 is the default) to clang-linker-wrapper.  Be sure to include the corresponding 'default<O?>' in '-passes'."
H4608F37A5D56: "패스 파이프라인에 대한 텍스트 설명입니다. 특정 패스 이전에 분석 패스를 사용하려면 'require<foo-analysis>'를 추가하세요. '-passes'는 '--opt-level=O?'를 지정할 때 clang-linker-wrapper에 대한 패스 파이프라인을 덮어쓰지만(모든 효과는 아님), 기본값은 O2입니다. '-passes'에 해당하는 'default<O?>'를 반드시 포함시켜야 합니다."
# 'A threshold controls whether an indirect call will be specialized'
HE03B79F00E10: '임계값은 간접 호출이 특수화되는지 여부를 제어합니다'
# 'A threshold of live range size which may cause high compile time cost in global splitting.'
H1C364B861BCF: '전역 분할에서 높은 컴파일 시간 비용을 초래할 수 있는 라이브 범위 크기의 임계값입니다.'
# 'A throughput of the processor floating-point arithmetic units expressed in the number of vector fused multiply-add instructions per clock cycle.'
H419471CCE4DF: '프로세서의 부동소수점 산술 유닛의 처리량을 클럭 주기당 벡터 퓨전 곱셈-덧셈 명령어 수로 표현한 값입니다.'
# 'A tile size for each loop dimension, filled with --polly-default-tile-size'
H104573A3D1B6: '각 루프 차원에 대한 타일 크기, --polly-default-tile-size로 채워집니다'
# 'A tile size for each loop dimension, filled with --polly-register-tile-size'
H8DEB87E7711B: '각 루프 차원별 타일 크기, --polly-register-tile-size로 채워집니다'
# 'A tool to bundle several input files of the specified type <type> \nreferring to the same source file but different targets into a single \none. The resulting file can also be unbundled into different files by \nthis tool if -unbundle is provided.\n'
HD409DEDBF7C5: '지정된 유형 <type>의 동일한 소스 파일을 가리키지만 다른 타겟을 위한 여러 입력 파일을 하나로 묶는 도구입니다.\n-umundle 옵션이 제공되면 이 도구로 결과 파일을 다시 분리할 수 있습니다.\n'
# 'A tool to detect the presence of offloading devices on the system. \n\nThe tool will output each detected GPU architecture separated by a\nnewline character. If multiple GPUs of the same architecture are found\na string will be printed for each\n'
H1DF8966C5917: '시스템에 존재하는 오프로딩 디바이스를 탐지하는 도구입니다.\n\n이 도구는 탐지된 각 GPU 아키텍처를 개행 문자로 구분하여 출력합니다. 동일한 아키텍처의 GPU가 여러 개 발견되면 각각에 대해 문자열을 출력합니다.'
# 'A tool to format C/C++/Java/JavaScript/JSON/Objective-C/Protobuf/C# code.\n\nIf no arguments are specified, it formats the code from standard input\nand writes the result to the standard output.\nIf <file>s are given, it reformats the files. If -i is specified\ntogether with <file>s, the files are edited in-place. Otherwise, the\nresult is written to the standard output.\n'
HBD33E3D62435: 'C/C++/Java/JavaScript/JSON/Objective-C/Protobuf/C# 코드를 포맷팅하는 도구입니다.\n\n인수가 지정되지 않으면 표준 입력에서 코드를 읽어 포맷팅하고 표준 출력에 결과를 작성합니다.\n<file>이 주어지면 해당 파일을 재포맷팅합니다. -i 옵션과 함께 <file>이 주어지면 파일을 직접 수정합니다. 그렇지 않으면\n결과를 표준 출력에 작성합니다.\n'
# 'A tool to generate an optimization report from YAML optimization record files.\n'
HACA86A981224: 'YAML 최적화 기록 파일에서 최적화 보고서를 생성하는 도구입니다.\n'
# 'A utility for bundling several object files into a single binary.\nThe output binary can then be embedded into the host section table\nto create a fatbinary containing offloading code.\n'
H87DB5533D231: '여러 개체 파일을 하나의 이진 파일로 묶는 유틸리티입니다.\n생성된 이진 파일은 호스트 섹션 테이블에 내장될 수 있습니다.\n오프로딩 코드가 포함된 fatbinary를 생성하기 위한 것입니다.\n'
# 'A utility used to launch unit tests built for a GPU target. This is\nintended to provide an intrface simular to cross-compiling emulators\n'
H43DC1BE6F67F: 'GPU 대상으로 구축된 유닛 테스트를 실행하는 유틸리티입니다. 이는 크로스 컴파일 엠플레이터와 유사한 인터페이스를 제공하기 위한 것입니다\n'
# 'AArch64 A57 FP Load-Balancing'
H89C796F20C61: 'AArch64 A57 부동소수점 로드 분산'
# 'AArch64 Assembly Printer'
H149E1B5ADAFC: 'AArch64 어셈블리 프린터'
# 'AArch64 Branch Targets'
H9304B7C9D5D8: 'AArch64 분기 타겟'
# 'AArch64 CCMP Pass'
HD86F88A4A107: 'AArch64 CCMP 패스'
# 'AArch64 CondOpt Pass'
H57677EA713E0: 'AArch64 CondOpt 패스'
# 'AArch64 Conditional Branch Tuning'
H22AFD058BC38: 'AArch64 조건부 분기 튜닝'
# 'AArch64 Dead register definitions'
HDD34EEF0A0FD: 'AArch64 죽은 레지스터 정의들'
# 'AArch64 Instruction Selection'
H5E1BF7DD5E18: 'AArch64 명령어 선택'
# 'AArch64 Local Dynamic TLS Access Clean-up'
H60D83F556D1C: 'AArch64 로컬 다이나믹 TLS 액세스 정리'
# 'AArch64 MI Peephole Optimization'
H5CB8022D53B1: 'AArch64 머신 인스트럭션 피프홀 최적화'
# 'AArch64 Pointer Authentication'
H3B42C021D00A: 'AArch64 포인터 인증'
# 'AArch64 Post Coalescer Pass'
H06C95CD832E0: 'AArch64 후 결합기 패스'
# 'AArch64 Promote Constant Pass'
H70B4D04F132C: 'AArch64 상수 승격 패스'
# 'AArch64 SIMD instructions optimization pass'
H407FCE4191EB: 'AArch64 SIMD 명령어 최적화 패스'
# 'AArch64 Stack Tagging'
HE4582C5513D0: 'AArch64 스택 태깅'
# 'AArch64 Stack Tagging PreRA Pass'
H576B6E1D60C6: 'AArch64 스택 태깅 RA 전 패스'
# 'AArch64 Store Pair Suppression'
HD68B4FD8992D: 'AArch64 스토어 페어 억제'
# 'AArch64 compress jump tables pass'
HB1CD15516755: 'AArch64 점프 테이블 압축 패스'
# 'AArch64 fix for A53 erratum 835769'
HBBD9D2E5295C: 'AArch64 A53 에러타움 835769 수정'
# 'AArch64 homogeneous prolog/epilog lowering pass'
H2B5E843A360C: 'AArch64 균일 프롤로그/에필로그 하향 변환 패스'
# 'AArch64 load / store optimization pass'
HC1E1B5661C2B: 'AArch64 로드/스토어 최적화 패스'
# 'AArch64 pseudo instruction expansion pass'
H39C8B02C1D58: 'AArch64 의사 명령어 확장 패스'
# 'AArch64 redundant copy elimination pass'
HAEB13D1AFB9C: 'AArch64 중복 복사 제거 패스'
# 'AArch64 sls hardening pass'
H988D224CDB63: 'AArch64 sls 강화 패스'
# 'AArch64 speculation hardening pass'
H7D2AB26196EE: 'AArch64 예측 강화 패스'
# 'AArch64Arm64ECCallLowering'
H73581D76FB10: 'AArch64Arm64EC 콜 레이링'
# "ABI '%0' is not supported for '%1'"
H7FF392C86EBF: "ABI '%0'은 '%1'에 지원되지 않습니다"
# "ABI '%0' is not supported on CPU '%1'"
H1189F24D3D62: "ABI '%0'는 CPU '%1'에서 지원되지 않습니다"
# 'AIX PPC Assembly Printer'
H954F34380A8A: 'AIX PPC 어셈블리 프린터'
# 'AMD vector math library'
HA177FC4B0F5A: 'AMD 벡터 수학 라이브러리'
# 'AMDGPU Address space based Alias Analysis'
HEE464CD5CFF9: 'AMDGPU 주소 공간 기반 ALIAS 분석'
# 'AMDGPU Address space based Alias Analysis Wrapper'
HA70F43663430: 'AMDGPU 주소 공간 기반 별칭 분석 래퍼'
# 'AMDGPU Assembly Printer'
HFD4F4422703F: 'AMDGPU 어셈블리 프린터'
# 'AMDGPU Attributor'
HB96C03301054: 'AMDGPU 속성 지정기'
# 'AMDGPU CFG Structurizer'
HFAE00DA66175: 'AMDGPU CFG 구조화기'
# 'AMDGPU DAG->DAG Pattern Instruction Selection'
H1C6011A1E507: 'AMDGPU DAG->DAG 패턴 명령 선택'
# 'AMDGPU GlobalISel divergence lowering'
H60A2AE965388: 'AMDGPU GlobalISel 분산 하향 변환'
# 'AMDGPU IR late optimizations'
H2A662801978F: 'AMDGPU IR 지연 최적화'
# 'AMDGPU IR optimizations'
H6CEDA43B5424: 'AMDGPU IR 최적화'
# 'AMDGPU Image Intrinsic Optimizer'
H28FFA260019F: 'AMDGPU 이미지 내장 함수 최적화기'
# 'AMDGPU Inline All Functions'
HFBEEFEAD43D4: 'AMDGPU 모든 함수 인라인'
# 'AMDGPU Insert Delay ALU'
HD712301B82FE: 'AMDGPU 삽입 지연 ALU'
# 'AMDGPU Insert waits for SGPR read hazards'
H3CE801DC5FBE: 'AMDGPU SGPR 읽기 위험을 위해 대기 명령어 삽입'
# 'AMDGPU Kernel Attributes'
H5B736779332B: 'AMDGPU 커널 속성'
# 'AMDGPU Lower Kernel Arguments'
H345C5C7C45FB: 'AMDGPU 커널 인수 변환'
# 'AMDGPU Mark last scratch load'
H570A9C93F411: 'AMDGPU 마지막 스크래치 로드 표시'
# 'AMDGPU Pre-RA Long Branch Reg'
HF352DB9ED395: 'AMDGPU Pre-RA 장 분기 레지스터'
# 'AMDGPU Pre-RA optimizations'
HB1D166D82990: 'AMDGPU 사전-RA 최적화'
# 'AMDGPU Preload Kernel Arguments'
H8AF72F195656: 'AMDGPU 커널 인수 사전 로드'
# 'AMDGPU Preload Kernel Arguments Prolog'
HA4C7048C1EF3: 'AMDGPU 커널 인수 사전 로드 프롤로그'
# 'AMDGPU Printf lowering'
H9F0BCA780CE7: 'AMDGPU Printf 하위 변환'
# 'AMDGPU Promote Kernel Arguments'
HAD6BF4A8858C: 'AMDGPU 커널 인수 승격'
# 'AMDGPU Register Bank Legalize'
HD913B83CEA2C: 'AMDGPU 레지스터 뱅크 합법화'
# 'AMDGPU Register Bank Select'
H910A7C3E575C: 'AMDGPU 레지스터 뱅크 선택'
# 'AMDGPU Remove Incompatible Functions'
H697AE5C583A4: 'AMDGPU 호환되지 않는 함수 제거'
# 'AMDGPU Reserve WWM Registers'
H9CD9A7466F8D: 'AMDGPU WWM 레지스터 예약'
# 'AMDGPU Rewrite Out Arguments'
H1EE5CA590389: 'AMDGPU 아웃 매개변수 재작성'
# 'AMDGPU Software lowering of LDS'
H06C3E98E4BA5: 'AMDGPU 소프트웨어 하향 변환(LDS)'
# 'AMDGPU atomic optimizations'
HD4C4B30A81C8: 'AMDGPU 원자적 최적화'
# 'AMDGPU promote alloca to vector'
H76A58E341CF5: 'AMDGPU alloca를 벡터로 승격'
# 'AMDGPU promote alloca to vector or LDS'
H505D453A0AB0: 'AMDGPU alloca를 벡터 또는 LDS로 승격'
# 'ANALYSIS'
HB0D5F3D274BF: '분석'
# 'ANALYSIS_ALIASING'
H652422606A7D: 'ALIAS 분석'
# 'ANALYSIS_FP_COMMUTE'
H5B6E5D0BD096: '부동소수점 연산 교환 분석'
# 'API notes replacement type %0 has a different size from original type %1'
HB87A25B6CDE7: 'API 노트 대체 타입 %0은 원래 타입 %1과 다른 크기를 가지고 있습니다'
# 'ARC %select{unused|__unsafe_unretained|__strong|__weak|__autoreleasing}0 lifetime qualifier on return type is ignored'
H4E4E8ED8984D: 'ARC %select{사용되지 않은|__unsafe_unretained|__strong|__weak|__autoreleasing}0 생명 주기 자격을 리턴 타입에 적용하면 무시됩니다'
# 'ARC Assmebly Printer'
H528084674BCB: 'ARC 어셈블리 프린터'
# 'ARC DAG->DAG Pattern Instruction Selection'
H40C54AF1B605: 'ARC DAG->DAG 패턴 명령어 선택'
# 'ARC finalize branches'
H275EE97FB8AE: 'ARC 최종 분기'
# 'ARC forbids %select{implementation|synthesis}0 of %1'
HC91D535AD424: 'ARC는 %1의 %select{구현|합성}0을 금지합니다.'
# 'ARC forbids explicit message send of %0'
H35558B925DCC: 'ARC는 %0 메시지의 명시적 전송을 허용하지 않습니다'
# 'ARC forbids flexible array members with retainable object type'
HBA6CEB1E81A4: 'ARC는 retain 가능한 객체 타입을 가진 유연한 배열 멤버를 금지합니다'
# 'ARC forbids synthesizing a property of an Objective-C object with unspecified ownership or storage attribute'
H8E9C79FD3192: 'ARC는 지정되지 않은 소유권 또는 저장 속성을 갖는 Objective-C 객체의 프로퍼티 합성을 금지합니다'
# 'ARC forbids use of %0 in a @selector'
H9E100CA24C33: 'ARC는 @selector 내에서 %0의 사용을 금지합니다'
# 'ARM Assembly Printer'
H821520E8B386: 'ARM 어셈블리 프린터'
# 'ARM Branch Targets'
H320FDCF5D874: 'ARM 분기 타겟'
# 'ARM EHABI exceptions'
HF924BFE7B7BB: 'ARM EHABI 예외'
# 'ARM Execution Domain Fix'
H8BB9925360D9: 'ARM 실행 도메인 수정'
# 'ARM Instruction Selection'
HD4C5D9A9956F: 'ARM 명령어 선택'
# 'ARM Low Overhead Loops pass'
HF8B8270CD0E0: 'ARM 저 오버헤드 루프 패스'
# 'ARM MVE TailPred and VPT Optimisations pass'
HE6A4A21F0251: 'ARM MVE TailPred 및 VPT 최적화 패스'
# 'ARM MVE VPT block pass'
HE579D00C5557: 'ARM MVE VPT 블록 패스'
# 'ARM block placement'
HE7AFE256FA69: 'ARM 블록 배치'
# 'ARM constant island placement and branch shortening pass'
H12503A372FDC: 'ARM 상수 섬 배치 및 분기 최소화 패스'
# 'ARM fix for Cortex-A57 AES Erratum 1742098'
HFB722C2D2741: 'Cortex-A57 AES 오류 1742098에 대한 ARM 수정'
# 'ARM load / store optimization pass'
HFAD45B23E308: 'ARM 로드/스토어 최적화 패스'
# 'ARM pre- register allocation load / store optimization pass'
HAF68B491BF25: 'ARM 레지스터 할당 전 로드/스토어 최적화 패스'
# 'ARM pseudo instruction expansion pass'
H77670EF47A4C: 'ARM 허구 명령어 확장 단계'
# 'ARM sls hardening pass'
H7DDE5DF1D5E8: 'ARM SLS 강화 패스'
# 'AST and IR generation'
H9BC428E8F3F3: 'AST 및 IR 생성'
# 'AVR Assembly Printer'
HEC272DC617AD: 'AVR 어셈블리 프린터'
# 'AVR DAG->DAG Instruction Selection'
H8D3BB39761E3: 'AVR DAG->DAG 명령 선택'
# 'AVR Shift Expansion'
HB0A514A46417: 'AVR 시프트 확장'
# 'AVR pseudo instruction expansion pass'
H957B71DEFB30: 'AVR 의사 명령어 확장 패스'
# "AVX vector %select{return|argument}0 of type %1 without '%2' enabled changes the ABI"
HA1797A0B7AA1: "AVX 벡터 %select{반환값|인수}0가 '%2'가 활성화되지 않은 %1 형식의 경우 ABI를 변경합니다"
# 'Abbreviation for -input-style=delimited -pretty -log=verbose. Intended to simplify lit tests'
H80629E8FC6D8: '옵션 -input-style=delimited, -pretty, -log=verbose의 약어입니다. lit 테스트를 단순화하기 위해 설계되었습니다'
# 'Abort if an isl error is encountered'
HA9BB62CCA982: 'isl 오류가 발생하면 강제 종료합니다'
# 'Abort if any reduction results in invalid IR'
HE190E2B8E3A2: '어떤 reduction이 무효한 IR을 생성하면 Abort'
# 'Abort when the max iterations for devirtualization CGSCC repeat pass is reached'
H625080B5E512: '가상화 해제 CGSCC 반복 패스의 최대 반복 횟수가 도달하면 중단합니다.'
# 'Absolute error tolerated'
H0DDBDDDD2804: '허용되는 절대 오차'
# 'Abstract subprograms'
HE11B4671C4D0: '추상 서브 프로그램'
# 'Accelerate framework'
HC4987E7BA17F: 'Accelerate 프레임워크'
# 'Accept a PCH file that was created with a different modules cache path'
H30FC52342749: '다른 모듈 캐시 경로로 생성된 PCH 파일을 허용합니다'
# 'Accept a PCH file that was created with compiler errors'
H3D9D9492A95B: '컴파일러 오류가 있는 PCH 파일을 허용합니다'
# 'Accept a PCM file that was created with compiler errors'
H491D98E75DB9: '컴파일러 오류로 생성된 PCM 파일을 허용합니다'
# 'Accept in ARM, reject in Thumb'
H947CDAFC2217: 'ARM에서는 허용하지만 Thumb에서는 거부합니다'
# 'Accept in both ISAs, emit implicit ITs in Thumb'
H1A576FCAF9D9: '두 가지 ISAs에서 허용, Thumb 모드에서 암시적 IT 생성'
# 'Accept non-standard constructs supported by the Borland compiler'
HA22BD3681EC1: 'Borland 컴파일러에서 지원하는 비표준 구문을 허용합니다'
# 'Accept some non-standard constructs supported by the Microsoft compiler'
HECEF41C80814: '마이크로소프트 컴파일러에서 지원하는 비표준 구문을 허용합니다'
# 'Accept some non-standard constructs supported by the z/OS compiler'
H043675240BDC: 'z/OS 컴파일러에서 지원하는 일부 비표준 구문을 허용합니다.'
# 'Access dynamic shadow through an ifunc global on platforms that support this'
HB6225A3E2790: '해당 기능을 지원하는 플랫폼에서 ifunc 글로벌을 통해 동적 샤도우에 접근합니다'
# 'Act like old LiveDebugValues did'
HFD5F11157A46: '오래된 LiveDebugValues와 동일하게 동작합니다'
# 'Action to perform on deprecated def'
H5D2AEBD499B4: '비추천된 정의에 적용할 작업'
# 'Action to perform:'
H0985CD6D5E8B: '수행할 작업:'
# 'Add !range metadata to NVVM intrinsics.'
H210E13100D6D: 'NVVM 내장 함수에 !range 메타데이터를 추가합니다.'
# 'Add -rpath with architecture-specific resource directory to the linker flags. When --hip-link is specified, also add -rpath with HIP runtime library directory to the linker flags'
H0E7215A9DCD3: '-rpath 옵션에 아키텍처별 리소스 디렉토리를 링커 플래그에 추가합니다. --hip-link가 지정되면 HIP 런타임 라이브러리 디렉토리도 -rpath 옵션과 함께 추가합니다'
# 'Add .note.gnu.property with BTI to assembly files'
HD58C1F70322E: '어셈블리 파일에 .note.gnu.property와 BTI를 추가합니다'
# 'Add .note.gnu.property with BTI to assembly files (AArch64 only)'
H497BB320D249: '어셈블리 파일에 .note.gnu.property를 BTI와 함께 추가합니다 (AArch64 전용)'
# 'Add <dir> to system include search path, as if in %INCLUDE%'
H8CB70533A0CD: '시스템 include 검색 경로에 <dir>을 추가합니다. %INCLUDE%에 있는 것처럼'
# 'Add AMDGPU uniform metadata'
HE950C74F7CBF: 'AMDGPU uniform metadata를 추가합니다'
# 'Add C++ implicit destructors to CFGs for all analyses'
H7BE6C1575B4A: '모든 분석을 위해 CFG들에 C++ 암시적 소멸자를 추가합니다.'
# 'Add Contextual/Debug comments to all C++ predicates'
H23C6808D6E2D: '모든 C++ 예측자에 맥락/디버그 주석 추가'
# 'Add DW_AT_linkage_name to function declaration DIEs referenced by DW_AT_call_origin attributes. Enabled by default for -gsce debugger tuning.'
H71407E50301C: 'DW_AT_call_origin 속성으로 참조되는 함수 선언 DIE에 DW_AT_linkage_name을 추가합니다. 디버거 튜닝을 위한 -gsce 옵션에서 기본적으로 활성화됩니다.'
# 'Add MIR Flow Sensitive Discriminators'
H2C6CDC724E3F: 'MIR 플로우 민감 판별자 추가'
# 'Add OpenCL builtin function declarations (experimental)'
HC7FA758DA63E: '실험용 OpenCL 내장 함수 선언 추가'
# 'Add TBAA tags to direct variables'
HAAED7844B106: '직접 변수에 TBAA 태그를 추가'
# 'Add TBAA tags to dummy arguments'
H3C7A729C0FA0: '가짜 인수에 TBAA 태그 추가'
# 'Add TBAA tags to global variables'
HE3F5E682DA95: 'TBAA 태그를 전역 변수에 추가합니다'
# 'Add TBAA tags to local allocations.'
H4C0FDC192CCF: '로컬 할당에 TBAA 태그 추가'
# 'Add __emutls_[vt]. variables for emultated TLS model'
H0F84398949DD: 'emultated TLS 모델을 위한 __emutls_[vt]. 변수 추가'
# 'Add a call to __hwasan_add_frame_record for storing into the stack ring buffer'
H42AEFE2097E5: '__hwasan_add_frame_record에 대한 호출을 스택 링 버퍼 저장을 위해 추가하세요'
# 'Add a note for each bug report to denote their analysis entry points'
H540B9CECB600: '각 버그 보고에 대한 분석 진입점을 표시하기 위한 주석을 추가합니다'
# "Add a preheader to a hardware loop if one doesn't exist"
H90D8EF6E5EFA: '하드웨어 루프에 프리헤더가 존재하지 않는 경우 추가합니다'
# "Add an attribute to a function. This can be a pair of 'function-name:attribute-name', to apply an attribute to a specific function. For example -force-attribute=foo:noinline. Specifying only an attribute will apply the attribute to every function in the module. This option can be specified multiple times."
H025869CF3D3D: "함수에 어트리뷰트를 추가합니다. 특정 함수에 어트리뷰트를 적용하려면 '함수-이름:어트리뷰트-이름'의 쌍을 지정할 수 있습니다. 예를 들어 -force-attribute=foo:noinline. 단독으로 어트리뷰트만 지정하면 모듈 내 모든 함수에 적용됩니다. 이 옵션은 여러 번 지정할 수 있습니다."
# 'Add an implicit negative check with this pattern to every\npositive check. This can be used to ensure that no instances of\nthis pattern occur which are not matched by a positive pattern'
H9C46F681BD1E: '이 패턴을 사용하여 모든 양성 검사에 암시적 음성 검사를 추가합니다.\n이는 양성 패턴에 의해 일치되지 않는 이 패턴의 인스턴스가 발생하지 않도록 보장하는 데 사용될 수 있습니다'
# 'Add block information to the output of -streams'
H31B10635B121: '블록 정보를 -streams 출력에 추가합니다'
# 'Add comments to directives.'
HB60639F27CEA: '디렉티브에 주석을 추가하십시오.'
# 'Add cs prefix to call and jmp to indirect thunk'
HF4B763BF676A: 'call 및 jmp에 대한 간접Thunk에 cs 접두사를 추가합니다'
# 'Add debug loc information when generating tables for '
HFC939A7BE90F: '테이블을 생성할 때 디버그 위치 정보 추가'
# 'Add dependent library'
H340E932EB390: '의존성 라이브러리 추가'
# 'Add dir to the list of library search paths'
HAF0260DD25B2: '라이브러리 검색 경로 목록에 dir을 추가합니다'
# 'Add directory to AFTER include search path'
HC2FABF8EF08B: 'AFTER include 검색 경로에 디렉토리를 추가합니다'
# 'Add directory to QUOTE include search path'
H24E806E38760: 'QUOTE include 검색 경로에 디렉토리 추가'
# 'Add directory to SYSTEM framework search path'
H8A929D35C6A7: '시스템 프레임워크 검색 경로에 디렉토리를 추가합니다'
# 'Add directory to SYSTEM framework search path, absolute paths are relative to -isysroot'
H690B2B7E95FE: 'SYSTEM 프레임워크 검색 경로에 디렉토리를 추가, 절대 경로는 -isysroot에 상대적입니다'
# 'Add directory to SYSTEM include search path'
H87F8A546FC28: '시스템 포함 검색 경로에 디렉토리를 추가'
# 'Add directory to SYSTEM include search path, absolute paths are relative to -isysroot'
HCAEDF5228592: '시스템 포함 경로 탐색 경로에 디렉토리를 추가합니다. 절대 경로는 -isysroot에 상대적입니다'
# 'Add directory to embed search path'
H6605669711E5: '내장 검색 경로에 디렉토리 추가'
# 'Add directory to end of the SYSTEM include search path'
HD7B48A7E62C9: '시스템 인클루드 검색 경로의 끝에 디렉토리를 추가합니다'
# 'Add directory to framework include search path'
H18A8E8D0F71C: '프레임워크 include 검색 경로에 디렉토리를 추가합니다'
# 'Add directory to include search path'
H8E2DBDC224AD: '포함 경로 검색 경로에 디렉토리 추가'
# 'Add directory to include search path with warnings suppressed'
H3D1B9139D392: '경고를 비활성화한 상태로 포함 경로 검색 경로에 디렉토리 추가'
# 'Add directory to library search path'
H7382A4AE54AB: '라이브러리 검색 경로에 디렉토리 추가'
# 'Add directory to the API notes search path referenced by module name'
H15347B13D121: '모듈 이름으로 참조되는 API 노트 검색 경로에 디렉토리를 추가합니다'
# 'Add directory to the C SYSTEM include search path'
H04DB229B7703: 'C 시스템 include 검색 경로에 디렉토리를 추가합니다'
# 'Add directory to the C++ SYSTEM include search path'
H99AF1D3B47BB: 'C++ SYSTEM include 검색 경로에 디렉토리를 추가합니다.'
# 'Add directory to the ObjC SYSTEM include search path'
H4AD0218E28C9: '시스템 인클루드 검색 경로에 ObjC 디렉토리를 추가합니다'
# 'Add directory to the ObjC++ SYSTEM include search path'
H4E8397371575: 'ObjC++ SYSTEM 인클루드 검색 경로에 디렉토리를 추가합니다'
# 'Add directory to the end of the list of include search paths'
HA9C01D5A6394: '인클루드 검색 경로 목록의 끝에 디렉토리를 추가합니다'
# "Add directory to the internal system framework search path; these are assumed to not be user-provided and are used to model system and standard frameworks' paths."
H52CD13889F28: '내부 시스템 프레임워크 검색 경로에 디렉터리 추가; 사용자 제공이 아닌 것으로 간주되며 시스템 및 표준 프레임워크 경로를 모델링하는 데 사용됩니다.'
# 'Add directory to the internal system include search path with implicit extern "C" semantics; these are assumed to not be user-provided and are used to model system and standard headers\' paths.'
HA6F738C6C497: '내부 시스템 include 검색 경로에 디렉토리를 추가합니다. 이 경로들은 암시적 extern "C" 의미를 갖으며, 사용자 제공이 아닌 것으로 간주되며 시스템 및 표준 헤더 경로를 모델링하는 데 사용됩니다.'
# "Add directory to the internal system include search path; these are assumed to not be user-provided and are used to model system and standard headers' paths."
H76AF34D02BE9: '내부 시스템 include 검색 경로에 디렉토리를 추가합니다; 이 디렉토리들은 사용자 제공이 아니라고 가정되며, 시스템 및 표준 헤더 경로를 모델링하는 데 사용됩니다.'
# 'Add dirs in env var <var> to include search path with warnings suppressed'
HFB17BE810349: '환경 변수 <var>에 있는 디렉토리를 경고를 표시하지 않는 헤더 파일 검색 경로에 추가합니다'
# 'Add extra TOC register dependencies'
HB5EA8815333D: '추가적인 TOC 레지스터 의존성 추가'
# 'Add informational comments to the .ll file'
H1430FC8452EC: '정보성 주석을 .ll 파일에 추가하세요'
# 'Add instruction count to a LSR cost model'
H35835E4FFD3B: 'LSR 비용 모델에 명령어 수를 추가합니다'
# 'Add library.'
H87317E57D7DD: '라이브러리 추가'
# 'Add lifetime markers to generated constant size allocas'
HC8366738065B: '상수 크기의 알로카에 라이프타임 마커 추가'
# 'Add linker option'
HEB1AFB3AB781: '링커 옵션 추가'
# 'Add missing headers to depfile'
H874052E89FC5: '의존성 파일에 누락된 헤더를 추가하세요'
# 'Add no-alias annotation for instructions that are disambiguated by memchecks'
H7736CFB59CC2: '메모리 검사로歧異가_해결된 명령문에 no-alias 어노테이션을 추가하세요.'
# 'Add printf calls that print the statement being executed'
H09CC61D8FD2B: '실행 중인 문을 출력하는 printf 호출을 추가합니다.'
# 'Add printf calls that print the values of all scalar values used in a statement. Requires -polly-codegen-trace-stmts.'
H955E9733D080: '문에서 사용된 모든 스칼라 값들의 값을 출력하는 printf 호출을 추가합니다. -polly-codegen-trace-stmts 옵션이 필요합니다.'
# 'Add printf calls that show the values loaded/stored.'
H7361CFCA90ED: 'printf 호출을 추가하여 로드/스토어된 값들을 표시하십시오.'
# 'Add prototypes to prototypes-less functions'
H129252A67396: '프로토타입이 없는 함수에 프로토타입을 추가하세요'
# 'Add relocations to function pointers to the current function'
HC90D5751B49C: '현재 함수의 함수 포인터에 재정렬을 추가합니다'
# 'Add run-time performance monitoring'
H67AB397B08D2: '런타임 성능 모니터링 추가'
# 'Add system library paths to library search paths'
H444464D6D9E2: '시스템 라이브러리 경로를 라이브러리 검색 경로에 추가합니다'
# 'Add the view as compare context.'
H9E4AA9613AAE: '비교 컨텍스트로 보기 추가.'
# 'Additional IR scalar types (always includes i1, i8, i16, i32, i64, float and double)'
H0A5D563266B6: '추가적인 IR 스칼라 유형 (항상 포함하는 항목은 i1, i8, i16, i32, i64, float 및 double)'
# 'Additional argument to append to the compiler command line'
HEBA0B777F61D: '컴파일러 명령행에 추가할 추가 인수'
# 'Additional argument to prepend to the compiler command line'
H6170CF05A381: '컴파일러 명령행 앞쪽에 추가할 추가 인수'
# "Additional arguments to forward to LLVM's option processing"
HF5FFCDFCC6A2: 'LLVM의 옵션 처리로 전달할 추가 인수'
# "Additional arguments to forward to MLIR's option processing"
HF4553A1AE254: 'MLIR 옵션 처리에 전달할 추가 인수'
# 'Additional arguments to pass to the linker'
H4F377C1D9775: '링커에 전달할 추가 인수'
# 'Additional shared objects to load into executing programs'
HE9D3E5D77A09: '실행 중인 프로그램에 로드할 추가 공유 객체'
# 'Address of the invoked server.'
H6E702787A95D: '호출된 서버의 주소입니다.'
# 'Address of the invoked server. Defaults to 0.0.0.0:50051'
H54519DAF9B40: '호출된 서버의 주소입니다. 기본값은 0.0.0.0:50051입니다'
# 'Address sinking in CGP using GEPs.'
HC7C32F638F6D: 'CGP에서 GEP를 사용한 주소 내리기.'
# "AddressSanitizer doesn't support linking with debug runtime libraries yet"
H46222370DDE7: 'AddressSanitizer는 아직 디버그 런타임 라이브러리와 링크하는 것을 지원하지 않습니다'
# 'Adjust basic block layout to better use TB[BH]'
HB4BC97D1857E: '기본 블록 레이아웃을 조정하여 TB[BH]를 더 잘 사용하도록 함'
# 'Adjust wave priority'
HBA116352E062: '웨이브 우선순위 조정'
# 'AdvSIMD Scalar Operation Optimization'
H45225A2C5722: 'AdvSIMD 스칼라 연산 최적화'
# 'Advanced attributes alias.'
HA39A91E5AAD4: '고급 속성 별칭.'
# 'Aggregate arguments to code-extracted functions'
H328995968B2E: '코드에서 추출된 함수의 인수 수집'
# 'Aggregate stack times across threads'
H5CF510D1EBBA: '각 스레드의 스택 시간을 집계합니다'
# 'Aggressive extension optimization'
HA4AE7C7FBB62: '공격적인 확장 최적화'
# 'Aggressively try to fuse everything'
H9E616808E7EC: '적극적으로 모든 것을 융합하려 시도합니다'
# 'Algorithm to use for splitting basic blocks into multiple statements'
H077B22383231: '기본 블록을 여러 문으로 분할하는 데 사용할 알고리즘'
# 'Alias Analysis Pipeline'
HE33821D525F2: '에이리어스 분석 파이프라인'
# 'Alias for --'
HA3FB2C7B610D: '--의 별칭'
# 'Alias for --blocks-x'
H57C6A0E441DA: '--blocks-x의 별칭'
# 'Alias for --demangled-names'
HE840FF95BF7A: '--demangled-names 옵션의 별칭입니다'
# 'Alias for --dry-run'
H0FA96A999664: '--dry-run 옵션의 별칭'
# 'Alias for --help'
HF39AA3CC9361: '--help의 별칭'
# 'Alias for --indirect-call-promotion'
HDBD75B583A13: '--indirect-call-promotion 옵션의 별칭'
# 'Alias for --input-files'
HDFC325842CEB: '--input-files의 별칭'
# 'Alias for --intermediate-format'
HD7D86B4F5A3A: '--intermediate-format 옵션의 별칭'
# 'Alias for --no-warn'
H6C7B7F57DEA7: '--no-warn의 별칭'
# 'Alias for --num-threads'
HE9977CCA0811: '--num-threads의 별칭'
# 'Alias for --output'
HA7011D865212: '옵션 --output의 별칭'
# 'Alias for --output-dir'
HC51012922C34: '--output-dir의 별칭입니다'
# 'Alias for --perfdata'
H136FC40E1E00: '대체 명칭으로 --perfdata'
# 'Alias for --perfscript'
H3EE8965681A7: '—perfscript의 별칭'
# 'Alias for --remapping-file'
H24A193959D48: '--remapping-file의 별칭'
# 'Alias for --save-temps=cwd'
HB0770869E271: '--save-temps=cwd의 별칭'
# 'Alias for --threads-x'
H2B37E4881B6D: '옵션 --threads-x의 별칭'
# 'Alias for --unsymbolized-profile'
HAAA114F8EC1E: '--unsymbolized-profile의 별칭'
# 'Alias for -Xclang'
HCD7F2ECE0041: '옵션 -Xclang의 별칭'
# 'Alias for -Xclangas'
H132AA9B77570: '-Xclangas의 별칭'
# 'Alias for -all-stacks'
HBF7B049FB306: '모든 스택을 출력하는 옵션의 별칭'
# 'Alias for -check-prefix permitting multiple comma separated values'
HD103BAE71227: '여러 개의 쉼표로 구분된 값을 허용하는 -check-prefix의 대체 명령어'
# 'Alias for -color-edges'
HC19B12CB2430: "옵션 '-color-edges'의 별칭"
# 'Alias for -deduce-sibling-calls'
H2E10ADB53A0A: '-deduce-sibling-calls의 별칭'
# 'Alias for -deduce-sibling-calls-1'
HF24D573B4E93: '다음 옵션의 별칭: -deduce-sibling-calls-1'
# 'Alias for -deduce-sibling-calls-2'
H4800F023F658: '-deduce-sibling-calls-2의 별칭'
# 'Alias for -deduce_sibling_calls'
HFE68AA381CCA: '-deduce_sibling_calls 옵션의 별칭'
# 'Alias for -edge-color'
H5FEAD1AEB73F: "옵션 '-edge-color'의 별칭"
# 'Alias for -edge-label'
HAFADF6FC17E1: 'edge-label의 별칭'
# 'Alias for -fextend-variable-liveness=all.'
H2B2334ED3B9F: '이 옵션은 -fextend-variable-liveness=all의 대체 이름입니다.'
# 'Alias for -fsanitize-ignorelist='
H6624562D7869: '-fsanitize-ignorelist의 별칭입니다.'
# 'Alias for -help'
HEA697AFD46B7: '-help 옵션의 별칭입니다.'
# 'Alias for -instr-map'
HB57A8B70724F: "옵션 '-instr-map'의 별칭"
# 'Alias for -instr-map-1'
H6F2C86FF53ED: '-instr-map-1의 별칭'
# 'Alias for -instr-map-2'
HD9A737CB2F17: '-instr-map-2의 별칭'
# 'Alias for -instr_map'
H13EC2B696DE5: '-instr_map의 별칭'
# 'Alias for -keep-going'
HC2FBFBC9B1BF: 'keep-going 옵션의 별칭'
# 'Alias for -keep-going-1'
HFC1713D60AC5: '-keep-going-1의 별칭'
# 'Alias for -keep-going-2'
HB73DA9252C0A: 'keep-going-2의 별칭'
# 'Alias for -keep_going'
H25546D53A1D1: '-keep_going의 별칭'
# 'Alias for -mllvm'
HE5CF0AF34303: '-mllvm의 별칭'
# 'Alias for -output'
H11E85BC44369: '-output의 별칭'
# 'Alias for -output-format'
HCE5EA67FACF7: '출력 형식에 대한 별칭'
# 'Alias for -passes'
HAC9042256B8B: '옵션 -passes의 별칭'
# 'Alias for -sort'
H439A5386F45B: '옵션 -sort의 별칭'
# 'Alias for -sortorder'
H29F0D261B98A: "옵션 '-sortorder'의 별칭"
# 'Alias for -symbolize'
HD9D9FFEE4D20: 'Symbolize 옵션의 별칭'
# 'Alias for -top'
H0697652EC65F: '옵션 -top의 별칭'
# 'Alias for -version'
HD2E0461080FA: '옵션 -version의 별칭'
# 'Alias for -vertex-color'
HB336A9FE055A: '-vertex-color의 별칭'
# 'Alias for -vertex-label'
HB5305BD11A1C: 'vertex-label의 별칭'
# 'Alias for -vertex-label-trun'
HBB4740B7076F: '가 -vertex-label-trun의 별칭입니다.'
# 'Alias of -format'
HD5F8D2C37C5D: '-format의 별칭입니다'
# 'Align ARM NEON spills in prolog and epilog'
HA6EB49748CD3: '프롤로그와 에필로그에서 ARM NEON 스팔 정렬'
# 'Align branches within 32-byte boundaries to mitigate the performance impact of the Intel JCC erratum.'
H5A28F46326DE: '32바이트 경계 내에서 분기를 정렬하여 인텔 JCC 오류로 인한 성능 영향을 완화합니다.'
# 'Align constant islands in code'
H461BA6D2D6E3: '코드에서 상수 섬 정렬하기'
# 'Align doubles to two words in structs (x86 only)'
HEDC15B5DDF59: '구조体型에서 double들을 두 워드로 정렬 (x86 전용)'
# 'Align selected branches (fused, jcc, jmp) within 32-byte boundary'
H61C864267E04: '선택된 분기문(fused, jcc, jmp)을 32바이트 경계 내에서 정렬합니다'
# "Align selected instructions to mitigate negative performance impact of Intel's micro code update for errata skx102.  May break assumptions about labels corresponding to particular instructions, and should be used with caution."
H4F2747860017: '선택된 명령어를 정렬하여 Intel의 에러타 skx102를 위한 마이크로 코드 업데이트로 인한 부정적인 성능 영향을 완화합니다. 특정 명령어에 해당하는 라벨의 가정을 깨뜨릴 수 있으며, 주의를 기울여 사용해야 합니다.'
# 'Aligned allocation/deallocation functions are unavailable'
H93CADD3D554F: '정렬된 할당/해제 함수는 사용할 수 없습니다'
# 'Alignment of bundle for binary files'
H746C20CFEB90: '바이너리 파일용 번들 정렬'
# 'All Pointer Authentication scanners'
HE5781D397620: '모든 포인터 인증 스캐너'
# "All compile commands come from LSP and 'compile_commands.json' files are ignored"
H35E96D7E99B1: "모든 컴파일 명령은 LSP에서 생성되며 'compile_commands.json' 파일은 무시됩니다"
# "All compile commands come from the 'compile_commands.json' files"
H2E03660ADBFF: "모든 컴파일 명령의 출처는 'compile_commands.json' 파일들입니다"
# 'All decisions not in replay are inlined'
H9B15B2C90AE0: '재생되지 않은 모든 결정은 인라인 처리됩니다'
# 'All decisions not in replay are not inlined'
H1838D4DFB9C1: '리플레이에 없는 모든 결정은 인라인되지 않았습니다'
# 'All decisions not in replay send to original advisor (default)'
H8494FD0B179D: '재생에 포함되지 않은 모든 결정을 원래 권고자로 전송 (기본값)'
# 'All edges.'
HA0232E12FF85: '모든 엣지.'
# 'All elements.'
HD1FF88F0C212: '모든 요소'
# 'All implemented scanners'
HC6B3DAC5AC10: '구현된 모든 스캐너'
# 'All input lines'
HAA2659CBF3BE: '모든 입력 라인'
# 'All known subsections'
H605028076261: '모든 알려진 하위 섹션'
# 'All non-critical edges.'
H4DF2A4AF93D9: '모든 비필수 간선.'
# 'All of the above and take the minimum of measurements'
H8D49782EBA5E: '위의 모든 것들을 포함하고 측정값의 최소를 취합니다'
# 'All outputs.'
HA29C21D07A12: '모든 출력.'
# 'All possible int comparisons in GPRs.'
H166898BCED35: 'GPRs 내의 모든 가능한 int 비교.'
# 'All suitable variables will have the TOC data transformation applied'
H5309722D6033: '적합한 모든 변수에는 TOC 데이터 변환이 적용됩니다'
# 'All vtables have type infos'
H69D2DF6DECC5: '모든 vtables에는 타입 정보가 있습니다.'
# 'All warnings.'
H294EA62DA621: '모든 경고.'
# 'Allocate -frepack-arrays temporaries on the heap (default)'
H23DD0FDC2602: '-frepack-arrays 임시 변수를 힙에 할당 (기본)'
# 'Allocate array temporaries on the heap (default)'
HF192F6B25D6C: '힙에 배열 일시 객체 할당 (기본값)'
# 'Allocate from a slab of the given size (allowable suffixes: Kb, Mb, Gb. default = Kb)'
H8D1230E33C0D: '지정된 크기의 슬래브에서 할당 (허용되는 접미사: Kb, Mb, Gb. 기본값은 Kb입니다)'
# 'Allocate memory upfront rather than on-demand'
H067B160BE7A4: '필요에 따라 메모리를 할당하는 대신 미리 메모리를 할당합니다'
# 'Allocate temporary arrays for -frepack-arrays in stack memory'
H60EEEE1BB97A: '-frepack-arrays에 의해 생성된 임시 배열을 스택 메모리에 할당합니다'
# 'Allocate to an enum type only as many bytes as it needs for the declared range of possible values'
H5482421F99A5: 'enum 형식에 할당할 때는 선언된 가능한 값 범위에 필요한 바이트 수만 할당해야 합니다'
# "Allow '$' in identifiers"
H6DB82DC47410: "식별자에서 '$' 사용 허용"
# 'Allow (may be subject to certain conditions) conversion of memcpy to TP loop.'
HF0E5B5A536C5: '특정 조건에 따라 허용될 수 있는 memcpy에서 TP 루프로의 변환을 허용합니다.'
# 'Allow AArch64 Local Dynamic TLS code generation'
H307A55AE7B7F: 'AArch64 로컬 다이나믹 TLS 코드 생성을 허용합니다'
# 'Allow DSE to optimize memory accesses.'
H6047B03BEC73: 'DSE가 메모리 액세스를 최적화하도록 허용합니다.'
# 'Allow GNU-extension keywords regardless of language standard'
H2947F99E638F: 'GNU 확장 키워드를 언어 표준과 무관하게 허용합니다'
# 'Allow G_INSERT to be considered an artifact. Hack around AMDGPU test infinite loops.'
H8D40AAA978F4: 'G_INSERT를 아티팩트로 간주할 수 있도록 허용합니다. AMDGPU 테스트의 무한 루프를 우회하기 위한 조치입니다.'
# 'Allow JumpThreading to thread across loop headers, for testing'
H0966C1037306: '테스트를 위해 루프 헤더를 통해 JumpThreading의 스레딩을 허용'
# 'Allow Objective-C array and dictionary subscripting in legacy runtime'
HCDF0596C06B7: '레거시 런타임에서 Objective-C 배열과 사전의 서브스크립팅 허용'
# 'Allow SimplifyCFG to merge invokes together when appropriate'
H6D05BDC01566: '적절한 경우 SimplifyCFG가 invokes를 함께 병합하도록 허용'
# 'Allow __declspec as a keyword'
HCB246A7067C5: '키워드로 __declspec 허용'
# 'Allow aggressive, lossy floating-point optimizations'
H0FAF2AF8BF00: '공격적이고 손실이 있는 부동소수점 최적화를 허용합니다'
# 'Allow atomic operations to ignore denormal mode'
HCF502E940887: '원자적 연산이 denormal 모드를 무시하도록 허용'
# 'Allow calls to the specified functions in SCoPs even if their side-effects are unknown. This can be used to do debug output in Polly-transformed code.'
H1410ADCFCAA7: '지정된 함수들에 대한 호출을 SCoPs에서 허용합니다. 해당 함수의 부작용이 알려지지 않았더라도 상관하지 않습니다. 이 옵션은 Polly 변환된 코드에서 디버그 출력을 수행하는 데 사용될 수 있습니다.'
# 'Allow certain math function calls to be replaced with an approximately equivalent calculation'
H7E6336F3B5B7: '특정 수학 함수 호출을 근사적으로 동등한 계산으로 대체할 수 있게 허용합니다'
# 'Allow cloning of callsites involved in recursive cycles'
HF572EEE2B09E: '재귀 사이클에 참여하는 callsites의 복제를 허용'
# 'Allow cloning of contexts having recursive cycles'
H599BF96DBCB9: '재귀적 사이클을 가진 컨텍스트의 복제를 허용합니다'
# 'Allow cloning of contexts through recursive cycles'
HB9EECACDCD85: '재귀적 사이클을 통해 컨텍스트 복제를 허용합니다'
# 'Allow combining of BaseGV field in Address sinking.'
H2D77F4CB6201: '주소 침식에서 BaseGV 필드의 결합을 허용합니다.'
# 'Allow combining of BaseOffs field in Address sinking.'
HF852DDC4F55A: 'Address sinking에서 BaseOffs 필드 결합을 허용합니다.'
# 'Allow combining of BaseReg field in Address sinking.'
H26B9669FA2AC: 'Address sinking에서 BaseReg 필드의 결합을 허용합니다.'
# 'Allow combining of ScaledReg field in Address sinking.'
HDEF3EE554628: 'Address sinking에서 ScaledReg 필드의 결합을 허용합니다.'
# 'Allow compiler to annotate sanitizer instrumentation with extra debug info for all sanitizers, where supported'
HCBC6B18AD214: '모든 산티나이저에서 지원하는 경우 산티나이저 계측에 추가 디버그 정보 주석 추가를 컴파일러에 허용'
# 'Allow compiler to merge handlers for all sanitizers'
H5230AC99F094: '모든 샌타이저의 핸들러를 컴파일러가 병합하도록 허용합니다'
# 'Allow compiler to merge handlers for specified sanitizers'
HD4BB34899488: '컴파일러가 지정된 산타이저 핸들러를 병합할 수 있도록 허용합니다'
# 'Allow conditional instructions outside of an IT block'
H08E49F0EFDBF: 'IT 블록 밖에서 조건부 명령문을 허용합니다'
# 'Allow counter promotion across the whole loop nest.'
HD6A96DE259B4: '전체 루프 네스트를 통해 카운터 프로모션을 허용합니다.'
# 'Allow creation of Phis in Address sinking.'
HE9D1F49BEE6D: 'Address sinking 단계에서 Phis 생성을 허용합니다.'
# 'Allow creation of selects in Address sinking.'
HF3DF8C2D011E: 'Address sinking 단계에서 select 생성을 허용합니다.'
# 'Allow device side init function in HIP (experimental)'
HBC635735388C: 'HIP에서 디바이스 측 초기화 함수 허용 (실험적)'
# 'Allow different element types for array accesses'
HE3FBA82C5731: '배열 접근시 다른 요소 유형 허용'
# 'Allow division operations to be reassociated'
HAD0D8D2448AD: '나눗셈 연산의 재결합을 허용'
# 'Allow enabling loop hints to reorder FP operations during vectorization.'
HD2BC949EEEE2: '벡터화 중에 부동소수점 연산을 재정렬하기 위해 루프 힌트를 활성화할 수 있도록 허용합니다.'
# 'Allow exactly one expensive instruction to be speculatively executed'
H2182F06086EB: '정확히 한 개의 비싼 명령을 추정 실행되게 허용합니다'
# 'Allow floating-point optimizations that assume arguments and results are not NaNs or +-inf. This defines the \\_\\_FINITE\\_MATH\\_ONLY\\_\\_ preprocessor macro.'
H49916D802745: 'NaN 또는 ±inf가 아닌 인수와 결과를 가정하는 부동소수점 최적화를 허용합니다. 이는 \\_\\_FINITE\\_MATH\\_ONLY\\_\\_ 전처리기 매크로를 정의합니다.'
# 'Allow for a mixture of Mips16 and Mips32 code in a single output file'
H85A1B3521C3C: '단일 출력 파일 내에서 Mips16과 Mips32 코드의 혼합을 허용합니다'
# 'Allow functions with known modref behavior'
HE8FEED2897E6: '알려진 modref 동작을 가진 함수 허용'
# 'Allow generation of a loop remainder (extra iterations) when unrolling a loop.'
HA9A95BA27CAD: '루프를 펼칠 때 루프 나머지(추가 반복)를 생성할 수 있도록 허용합니다.'
# 'Allow generation of complex IT blocks.'
H0C587C47350A: '복잡한 IT 블록 생성을 허용합니다.'
# 'Allow generation of data access to code sections (AArch64/ARM only)'
H4E803F81C9B5: '데이터에 대한 코드 섹션 액세스 생성을 허용 (AArch64/ARM 전용)'
# 'Allow header insertions (deprecated. Use -disable-insert instead)'
H2636E70EED6C: '헤더 삽입 허용 (더 이상 사용되지 않음. -disable-insert 사용 권장)'
# 'Allow header removals (deprecated. Use -disable-remove instead)'
H6A88BB16BC90: '헤더 제거 허용 (더 이상 사용되지 않음. -disable-remove 사용 권장)'
# 'Allow incomplete IR on a best effort basis (references to unknown metadata will be dropped)'
H05F1B598EC8B: '가장 좋은 노력을 기반으로 불완전한 IR을 허용합니다(알 수 없는 메타데이터에 대한 참조가 제거됨)'
# "Allow inlining when caller has a superset of callee's nobuiltin attributes."
H21EB86A2A3AB: '호출자가 피호출자의 nobuiltin 속성의 슈퍼셋을 가지면 인라인을 허용합니다.'
# 'Allow loop rotation multiple times in order to reach a better latch exit'
HE5B48E5AC62B: '더 나은 latch exit에 도달하기 위해 loop rotation을 여러 번 허용합니다'
# 'Allow mapping symbol at section beginning to be implicit, lowering number of mapping symbols at the expense of some portability. Recommended for projects that can build all their object files using this option'
HE30942163DF4: '섹션 시작에 있는 매핑 심볼을 암시적으로 허용하여 매핑 심볼의 수를 줄이지만 일부 포터블성을 희생합니다. 이 옵션을 사용하여 모든 객체 파일을 빌드할 수 있는 프로젝트에 권장됩니다'
# 'Allow memory accesses to be unaligned (AArch32/MIPSr6 only)'
H4DACD884827E: '미대齐된 메모리 접근을 허용 (AArch32/MIPSr6에만 해당)'
# 'Allow memory accesses to be unaligned (AArch64/LoongArch/RISC-V only)'
H075169115FA2: '비정렬 메모리 접근을 허용합니다 (AArch64/LoongArch/RISC-V 전용)'
# 'Allow mergefunc to create aliases'
H96D31DA83FB1: 'mergefunc에 ALIAS 생성을 허용합니다'
# 'Allow merging of constants'
H7B7B2A69B6A1: '상수 병합을 허용합니다'
# 'Allow non affine access functions in arrays'
H1B750054F6AE: '배열에서 비_affine 접근 함수를 허용'
# 'Allow non affine conditions for branches'
H02FFF4B1AF5A: '분기문의 비 affine 조건 허용'
# 'Allow non affine conditions for loops'
H7C67DD81E47E: '루프에 대해 비 아핀 조건을 허용합니다'
# 'Allow non-power-of-2 vectorization.'
HA2D0D7F2C7BF: '2의 거듭제곱이 아닌 벡터화 허용'
# 'Allow non-solo packetization of volatile memory references'
H5792B0D4B6CC: 'Volatile 메모리 참조의 단독이 아닌 패킷화 허용'
# 'Allow operation with no registered dialects'
H7A999A69E320: '등록되지 않은 디어랙트가 있을 때도 작업을 허용'
# 'Allow operation with no registered dialects (discouraged: testing only!)'
HF9B2D65D3FE4: '등록되지 않은 방언이 있는 작업을 허용합니다 (권장하지 않음: 테스트용으로만 사용!)'
# 'Allow operations coming from an unregistered dialect'
HC8673F2EA652: '등록되지 않은 방언에서 오는 연산을 허용합니다'
# 'Allow optimization to assume there are no NaNs.'
H4027A2790C01: '최적화가 NaN이 존재하지 않는다는 가정 하에 수행되도록 허용합니다.'
# 'Allow optimization to assume there are no infinities.'
H2F8AEF326E4D: '최적화가 무한대가 없다고 가정하도록 허용합니다.'
# 'Allow optimizations that ignore the sign of floating point zeros'
H74EA3796D9B9: '부동 소수점 제로의 부호를 무시하는 최적화를 허용'
# 'Allow partial writes'
H36F20305E82F: '부분적 쓰기를 허용합니다'
# 'Allow passing GC Pointer arguments in callee saved registers'
HAAA2F5C160B0: '피호출자 보존 레지스터에 GC 포인터 인수를 전달할 수 있도록 허용합니다'
# 'Allow placing main program variables on the stack (default)'
HFA7AA687FA70: '메인 프로그램 변수를 스택에 배치할 수 있음 (기본값)'
# 'Allow prefixes to be specified but not appear in the test.'
HE9A068B65F59: '테스트에서 지정되지만 나타나지 않는 접두사를 허용합니다.'
# 'Allow reassociation transformations for floating-point instructions'
H69FAD124BA17: '부동소수점 명령어에 대한 재결합 변환을 허용합니다'
# 'Allow relaxed uniform region checks'
HECAF51D715EB: '완화된 일관성 영역 검사 허용'
# 'Allow reordering across at most this many instructions when hoisting'
H03C130FA1582: '호이스팅 시 이 수만큼의 명령문을 넘지 않도록 재정렬을 허용'
# 'Allow runtime unroll for AMDGPU if local memory used in a loop'
H6AD964FBACC9: 'AMDGPU에서 루프 내에서 로컬 메모리를 사용할 경우 런타임 언롤을 허용합니다'
# 'Allow runtime unrolled loops to be unrolled with epilog instead of prolog.'
H402D9BD954E3: '런타임 언롤된 루프를 프롤로그 대신 에필로그를 사용하여 언롤되도록 허용합니다.'
# 'Allow runtime unrolling for loops with multiple exits, when epilog is generated'
H612B7424A810: '에필로그가 생성될 때 다중 출구를 가진 루프에 대해 실행 시 언롤링을 허용합니다'
# 'Allow sample loader inliner to inline recursive calls.'
HA6530F6AAC71: '샘플 로더 인라인러가 재귀 호출을 인라인 처리할 수 있도록 허용합니다.'
# 'Allow scalar memory accesses to be unaligned (RISC-V only)'
HFC86196CBA64: '비정렬된 스칼라 메모리 접근을 허용 (RISC-V 전용)'
# 'Allow slot1 store and slot0 load'
H7437ACC71E24: 'slot1 저장과 slot0 로드를 허용합니다'
# 'Allow speculation of preheader instructions'
H363DA7F8452D: '프리헤더 지시문의 추측을 허용'
# 'Allow spill in spill slot of greater size than register size'
H9CD29F6A2A53: '리지스트 크기보다 큰 크기의 스플라이 슬롯에서 스플라이 허용'
# 'Allow static variables in .sdata'
H770981D5F907: '.sdata 섹션에서 정적 변수 허용'
# 'Allow the Attributor to create shallow wrappers for non-exact definitions.'
HB6DC09C0C648: 'Attributor가 정확하지 않은 정의에 대해 얕은 래퍼를 생성할 수 있도록 허용합니다.'
# 'Allow the Attributor to do call site specific analysis'
H2595BA1E26D0: 'Attributor가 콜 사이트별 특정 분석을 수행할 수 있도록 허용'
# 'Allow the Attributor to use IP information derived from non-exact functions via cloning'
H0E8CFBCDE797: 'Attributor가 복제를 통해 정확하지 않은 함수에서 유래된 IP 정보를 사용할 수 있도록 허용'
# 'Allow the compiler to assume that each translation unit has a unique source file identifier (see -funique-source-file-identifier) at link time'
H857226BB03C5: '링크 시 각 번역 단위가 고유한 소스 파일 식별자를 갖는다고 컴파일러에 가정시킴 (자세한 내용은 -funique-source-file-identifier 참조)'
# 'Allow the detection of full functions'
H6DD82ED565A3: '전체 함수 감지 허용'
# 'Allow the formation of VW_W operations (e.g., VWADD_W) with splat constants'
H845C6DF92D8C: 'VW_W 연산(예: VWADD_W)을 splat 상수와 함께 생성할 수 있도록 허용'
# 'Allow the input file to be empty. This is useful when making\nchecks that some error message does not occur, for example.'
H658BEA7D8D36: '입력 파일이 비어 있도록 허용합니다. 예를 들어 어떤 오류 메시지가 발생하지 않는지 확인할 때 유용합니다.'
# 'Allow the loop remainder to be unrolled.'
H54EBCBE4781C: '루프 나머지를 언롤할 수 있게 합니다.'
# 'Allow the use of FMAs if available and profitable. This may result in different results, due to less rounding error.'
H996DA0DE6CCE: 'FMAs를 사용할 수 있고 효율적이라면 허용합니다. 이는 적은 반올림 오류로 인해 다른 결과를 초래할 수 있습니다.'
# 'Allow to search for module maps in subdirectories of search paths'
H4C313304A657: '검색 경로의 하위 디렉토리에서 모듈 맵을 찾도록 허용합니다'
# "Allow to speculate on the execution of 'error blocks'."
H88DB79B94D55: '에러 블록의 실행을 추측하도록 허용합니다.'
# 'Allow unsafe floating-point math optimizations which may decrease precision'
H67E450B90F32: '안전하지 않은 부동소수점 수학 최적화를 허용하며, 이는 정밀도를 감소시킬 수 있습니다'
# 'Allow unsigned operations such as comparisons or zero-extends.'
H33CDECA8CBA8: '비교 연산이나 제로 확장과 같은 부호 없는 연산을 허용할 수 있습니다.'
# 'Allow use of CMSE (Armv8-M Security Extensions)'
H21EADF8CC690: 'CMSE (Armv8-M 보안 확장) 사용을 허용합니다'
# 'Allow use of CRC instructions (ARM/Mips only)'
H0928C2372DB2: 'CRC 명령어 사용 허용 (ARM/Mips만)'
# 'Allow using blocks with parameters of more specific type than the type system guarantees when a parameter is qualified id'
HEADAE3890D46: '매개변수가 qualifier가 붙은 식별자일 때, 타입 시스템이 보장하는 것보다 더 구체적인 형식의 매개변수를 사용하는 블록을 허용합니다'
# 'Allow using registers for gc pointer in landing pad'
H6D19D992878A: 'landing pad에서 GC 포인터를 레지스터로 사용 허용'
# 'Allow using registers for non pointer deopt args'
HD185DF4F0E95: '리지스터를 포인터가 아닌 deopt 인수에 사용할 수 있게 허용'
# 'Allow variadic functions in CUDA device code.'
H918161EF13F5: 'CUDA 장치 코드에서 가변 인자 함수를 허용합니다.'
# 'Allow vector memory accesses to be unaligned (RISC-V only)'
HB7E7D4EF733A: '벡터 메모리 접근을 미배치로 허용합니다 (RISC-V 전용)'
# 'Allow widening of indvars to eliminate s/zext'
HC582FEBF6EC9: '인덕션 변수의 확장을 허용하여 s/zext 제거'
# 'Allowed symbol scopes (comma-separated list)'
H09C539E5B693: '허용되는 심볼 범위(쉼표로 구분된 목록)'
# 'Allows assuming by-value parameters do not alias any other value. Has no effect on non-trivially-copyable classes in C++.'
HA18120EB5360: '값에 의한 매개변수가 다른 어떤 값과도 별칭을 가지지 않는다고 가정할 수 있습니다. C++에서 비平凡 복사 가능한 클래스에는 영향을 미치지 않습니다.'
# 'Allows control over excess precision on targets where native support for BFloat16 precision types is not available. By default, excess precision is used to calculate intermediate results following the rules specified in ISO C99.'
HBB6845887CAC: '네이티브 BFloat16 정밀도 유형 지원이 없는 대상에서 과도한 정밀도를 제어할 수 있습니다. 기본적으로 ISO C99에서 지정된 규칙에 따라 중간 결과를 계산하기 위해 과도한 정밀도가 사용됩니다.'
# 'Allows control over excess precision on targets where native support for Float16 precision types is not available. By default, excess precision is used to calculate intermediate results following the rules specified in ISO C99.'
HC49D9EDA0518: 'Float16 정밀도 유형에 네이티브 지원이 없는 환경에서 과도한 정밀도를 제어할 수 있습니다. 기본적으로 ISO C99에서 정의된 규칙에 따라 중간 결과를 계산하기 위해 과도한 정밀도가 사용됩니다.'
# 'Allows control over excess precision on targets where native support for the precision types is not available. By default, excess precision is used to calculate intermediate results following the rules specified in ISO C99.'
HF60814E6692A: '네이티브 정밀도 유형 지원이 없는 타겟에서 과도한 정밀도를 제어할 수 있습니다. 기본적으로 ISO C99에서 정의된 규칙에 따라 중간 결과를 계산하기 위해 과도한 정밀도가 사용됩니다.'
# 'Allows loop nests to be peeled.'
HFE032116CB53: '루프 네스트를 피어링할 수 있도록 허용합니다.'
# 'Allows loops to be partially unrolled until -unroll-threshold loop size is reached.'
HAAF79FCD3521: '루프를 부분적으로 펼칠 수 있도록 하여 -unroll-threshold 루프 크기가 도달할 때까지 반복합니다.'
# 'Allows loops to be peeled when the dynamic trip count is known to be low.'
HE4D86D272F84: '동적 루프 횟수가 낮다는 것이 알려지면 루프를 언_RAPEL할 수 있도록 합니다.'
# 'Allows loops to be unroll-and-jammed.'
H08E5D5835443: '루프를 언롤-앤드-잼할 수 있게 합니다.'
# 'Allows to add additional results to private functions to return ownership of returned memrefs to callers. This can avoid spurious buffer clones in the callee.'
H2478745EEA16: '비공개 함수에 추가 결과를 추가하여 반환된 memrefs의 소유권을 호출자에게 반환할 수 있습니다. 이렇게 하면 호출된 함수에서 불필요한 버퍼 복사를 피할 수 있습니다.'
# 'Allows using features specific to Hugo'
H5D750A78EC0D: 'Hugo에 특화된 기능을 사용할 수 있게 합니다'
# 'Also show functions without any scops'
H8AA7DD878BF3: '또한 어떤 스코프도 없는 함수를 표시합니다'
# 'Also write profiles with all-zero counters. Intended for testing/debugging.'
HC00EF438F6CF: '모든 카운터가 0인 프로파일도 작성합니다. 테스트/디버깅을 위해 사용됩니다.'
# 'Always Step Into.'
H2D9E73855459: '항상 들어가기.'
# 'Always convert memcpy to TP loop.'
H43BC365E404A: '항상 memcpy를 TP 루프로 변환합니다.'
# 'Always detect stack use after return.'
HAA3BC6D7C687: '리턴 후 스택 사용을 항상 감지합니다.'
# 'Always dump input'
HA3473C53D75A: '항상 입력을 덤프합니다'
# 'Always emit EH frame entries'
HDDDD83A3567E: '항상 EH 프레임 엔트리를 생성합니다'
# 'Always emit __xray_customevent(...) calls even if the containing function is not always instrumented'
H3096C16CDC52: '항상 __xray_customevent(...) 호출을 생성하即使 포함된 함수가 항상 instrumented되지 않은 경우에도'
# 'Always emit __xray_typedevent(...) calls even if the containing function is not always instrumented'
H2E61DC30BF81: '포함된 함수가 항상strument되지 않을 때에도 항상 __xray_typedevent(...) 호출을 생성합니다'
# 'Always emit a debug frame section'
HB80937D1780A: '디버그 프레임 섹션을 항상 생성합니다'
# 'Always emit a debug frame section.'
H23A9192A38F7: '디버그 프레임 섹션을 항상 생성합니다.'
# 'Always exclude wrong side overloads in overloading resolution for CUDA/HIP'
HA5AB629FB85E: 'CUDA/HIP의 오버로딩 해소 시 항상 잘못된 쪽 오버로드를 제외합니다'
# 'Always generate function calls for address sanitizer instrumentation'
HA25586514168: '주소 산타이저 추적을 위해 항상 함수 호출을 생성합니다'
# 'Always modify dest registers regardless of color'
H58E66AB0CF8C: '항상 목적 레지스터를 변경하십시오(색상과 무관하게)'
# 'Always set the bit'
H9287AFC9334D: '항상 비트를 설정하세요'
# 'Always track the overflow bit.'
H577F71683BBC: '항상 오버플로우 비트를 추적하세요.'
# 'Always use $gp as the global base register.'
HC4090BE1945A: '전역 기본 레지스터로 $gp를 항상 사용하십시오.'
# 'Always use DW_AT_ranges in DWARFv5 whenever it could allow more address pool entry sharing to reduce relocations/object size'
H5C1DD29350B5: '항상 DWARFv5에서 DW_AT_ranges를 사용하여 주소 풀 엔트리 공유를 더 많이 허용해 relocations 및 객체 크기를 줄일 수 있는 경우 그렇게 하십시오'
# 'Always use compact branches if possible.'
H9248BC8A7969: '가능한 경우 항상 간결한 분기를 사용하세요.'
# 'Always use descriptors for POINTER and ALLOCATABLE'
H088038A3E688: '포인터 및 할당 가능 타입의 포인터를 사용할 때는 항상 설명자(descriptor)를 사용하십시오.'
# 'Always used text-based completion'
H186681547B61: '항상 사용된 텍스트 기반 완성'
# 'Always write temporary files as bitcode instead of textual IR'
H1C24DC778992: '임시 파일을 항상 비트코드로 작성하고 텍스트 IR 대신에'
# 'An ID for compilation unit, which should be the same for the same compilation unit but different for different compilation units. It is used to externalize device-side static variables for single source offloading languages CUDA and HIP so that they can be accessed by the host code of the same compilation unit.'
HEAEE5FF78DA6: '컴파일 단위를 식별하는 ID로, 동일한 컴파일 단위에서는 같은 값이어야 하지만 다른 컴파일 단위에서는 서로 다른 값이어야 합니다. 이는 단일 소스 오프로딩 언어인 CUDA 및 HIP의 장치 측 정적 변수를 외부화하는 데 사용되며, 이를 통해 같은 컴파일 단위의 호스트 코드가 이를 접근할 수 있도록 합니다.'
# 'An additional cost threshold that must be exceeded for merging to be considered beneficial.'
H80CD60A8D728: '병합을 유리하게 고려하기 위해 초과되어야 하는 추가 비용 임계값입니다.'
# 'An allocatable left-hand side of an intrinsic assignment is assumed to be allocated and match the shape/type of the right-hand side'
H80F5410F8454: '내재적 할당의 할당 가능한 좌측 표현은 할당된 것으로 간주되며 우측 표현의 형상/형식과 일치해야 합니다'
# 'An integer in percent used to specify the hot blocks/edges to be displayed in red: a block or edge whose frequency is no less than the max frequency of the function multiplied by this percent.'
H785F9B56BA61: '빨강으로 표시할 핫 블록/엣지를 지정하기 위해 사용되는 백분율 단위의 정수입니다: 해당 함수의 최대 빈도에 이 백분율을 곱한 값 이상의 빈도를 가진 블록 또는 엣지입니다.'
# 'Analysis'
H62C7FCF46E27: '분석'
# 'Analysis containing CSE Info'
H844D68401590: 'CSE 정보를 포함하는 분석'
# 'Analysis for ComputingKnownBits'
H7CC4A0AB7F2C: 'KnownBits 계산을 위한 분석'
# 'Analysis if a function is memory bound'
H4D110E7E06DE: '함수가 메모리에 의존하는지 분석'
# 'Analyze Machine Code For Garbage Collection'
H9DF9D8E23EF5: '가비지 컬렉션을 위한 머신 코드 분석'
# 'Analyze and emit instructions for Win64 Unwind v2'
HBAD8BCB2E044: 'Win64 Unwind v2에 대한 명령 분석 및 생성'
# 'Analyze array contents for load forwarding'
H400B26D98EF4: '로드 포워딩을 위한 배열 내용 분석'
# 'Annotate LTO phase (prelink / postlink), or main (no LTO) for sample-profile inline pass name.'
HE2E0B6955283: '샘플-프로파일 인라인 패스 이름에 대한 LTO 단계(prelink/postlink) 또는 LTO가 없는 메인 단계를 주석으로 표시하십시오.'
# 'Annotate SI Control Flow'
H917E9747DC24: 'SI 제어 흐름에 주석 추가'
# 'Annotate call sites of function declarations.'
H117120C6D4F8: '함수 선언의 호출 위치에 주석을 추가합니다.'
# 'Annotate sanitizer instrumentation with extra debug info for the specified sanitizers, if supported'
H2FA3995AD0E4: '지정된 산티나이저에서 지원하는 경우 산티나이저 계측에 추가 디버그 정보 주석 추가'
# 'Annotate table jump instruction to correlate it with the jump table.'
H49774B77C4AA: '테이블 점프 명령어에 주석을 달아 점프 테이블과 연관시킵니다.'
# 'Any subsection not covered by another option'
HE0257BE6772D: '다른 옵션으로 커버되지 않은 하위 섹션'
# 'Append function hash to the name of COMDAT function to avoid function hash mismatch due to the preinliner'
HFFA3462002F7: 'COMDAT 함수의 이름에 함수 해시를 추가하여 프리인라인러로 인한 함수 해시 불일치를 방지합니다'
# "Append the exit code to the output so it gets diff'd too"
H9E3A9D6959C1: '종료 코드를 출력에 추가하여 차이 비교에도 포함되도록 합니다'
# 'Append vectorize enable/disable metadata from polly'
H9E5D3061A26C: 'Polly로부터 벡터화 활성화/비활성화 메타데이터를 추가합니다'
# 'Appends one trailing underscore to external names'
HD2751F46D9D1: '외부 이름에 한 개의 뒤따르는 밑줄을 추가합니다'
# 'Apple'
H476432A3E85A: '애플'
# 'Applies path clonings for the -basic-block-sections=list option'
H2424A194F26C: "옵션 '-basic-block-sections=list'에 대해 패스 클로닝을 적용합니다"
# 'Apply CHR for all functions'
H577A52B0B7CC: '모든 함수에 CHR 적용'
# 'Apply an iterative post-processing to infer correct BFI counts'
H66ADFA49B9E1: '반복적 후처리를 적용하여 정확한 BFI 카운트를 추론합니다'
# 'Apply edits to analyzed source files'
HFDE3C74EED4D: '분석된 소스 파일에 편집을 적용합니다'
# 'Apply first slot optimization for stack tagging (eliminate ADDG Rt, Rn, 0, 0).'
H2ADE0B593B04: '스택 태깅을 위한 첫 번째 슬롯 최적화 적용 (ADDG Rt, Rn, 0, 0 제거).'
# 'Apply fix-it advice creating a file with the given suffix'
H2BD66E062CA1: '지정된 접미사를 가진 파일을 생성하는 fix-it 권고를 적용합니다'
# 'Apply fix-it advice even in the presence of unfixable errors'
H011FCA2E909C: '고칠 수 없는 오류가 있는 경우에도 수정 제안을 적용합니다'
# 'Apply fix-it advice only for warnings, not errors'
H6ED66F770BAD: '경고에 대해서만 fix-it 조언을 적용하고 오류에는 적용하지 않음'
# 'Apply fix-it advice to the input source'
HFFEDA0075E38: '입력 소스에 fix-it 제안을 적용합니다'
# 'Apply fix-it changes and recompile'
H6D9BFB4F5F51: 'fix-it 변경사항을 적용하고 다시 컴파일하십시오'
# 'Apply fix-it changes to temporary files'
HF35652D64499: '임시 파일에 fix-it 변경사항을 적용'
# 'Apply given attribute to all functions'
H0A840E827150: '지정된 특성을 모든 함수에 적용합니다'
# 'Apply global symbol visibility to external declarations without an explicit visibility'
HB6DB5D64D7AE: '명시적인 가시성이 없는 외부 선언에 글로벌 심볼 가시성을 적용합니다'
# 'Apply no_sanitize to the whole file'
H1820034AB28F: '전체 파일에 no_sanitize 적용'
# 'Apply post-rescheduling optimizations such as tiling (requires -polly-reschedule)'
HD42F33B0AD22: '재배치 후 최적화 적용 (예: tiling) (-polly-reschedule 옵션이 필요합니다)'
# 'Apply the profile guided size optimizations only if the working set size is large (except for cold code.)'
HCAA14E2BEA3D: '작업 집합 크기가 클 경우에만 프로파일 기반 크기 최적화를 적용합니다(콜드 코드는 제외함).'
# 'Apply the profile guided size optimizations only to cold code under instrumentation PGO.'
H88E35D1AFA04: '프로파일 기반 크기 최적화를 기기측정 PGO 하에서 콜드 코드에만 적용합니다.'
# 'Apply the profile guided size optimizations only to cold code under partial-profile sample PGO.'
HA712F1C73153: '프로파일 기반 크기 최적화를 부분 프로파일 샘플 PGO 아래에서 차가운 코드에만 적용합니다.'
# 'Apply the profile guided size optimizations only to cold code under sample PGO.'
H15AF6FCF8AC2: '샘플 PGO 하에서의 콜드 코드에만 프로파일 가이드 사이즈 최적화를 적용합니다.'
# 'Apply the profile guided size optimizations only to cold code.'
HFC7E2CE1D9BB: '프로파일 지도 크기 최적화를 cold 코드에만 적용합니다.'
# 'Apply the terminal rule'
HE81B9410B1C9: '말단 규칙을 적용합니다'
# 'Apply user-directed transformation from metadata'
HC2B25CDB2B7C: '메타데이터에서 사용자 지정 변환 적용'
# 'Approximately limit number of return registers for replacing out arguments'
H004F37FECEE5: '아웃 인수 대체를 위해 리턴 레지스터의 수를 약하게 제한'
# 'Architecture to generate code for (see --version)'
H3DBAAEAEDF16: '생성할 코드를 위한 아키텍처 (--version 참조)'
# 'Argument Register Usage Information Storage'
H5FFD7A67FE89: '인수 레지스터 사용 정보 저장소'
# 'Argument Stack Rebase'
HAB61ED834BD0: '인수 스택 재기준점 설정'
# 'Argument to pass to the CompilerInvocation'
H3D79343D82D3: 'CompilerInvocation에 전달할 인수'
# 'Arguments passed onto the interesting-ness test'
H2C80A4DD32DD: '이 테스트에 전달된 인자들'
# 'Arguments to pass to the DTLTO distributor process.'
H02599B65A936: 'DTLTO 배포자 프로세스에 전달할 인수'
# 'Arguments to pass to the remote compiler for backend compilations.'
HE57FA5E1C8EF: '백엔드 컴파일을 위한 원격 컴파일러에 전달할 인수'
# 'Arm Performance Libraries'
H044D40FECAA8: '아머 퍼포먼스 라이브러리'
# 'Array subrange.'
HC09EA244D244: '배열 부분 범위.'
# 'Array.'
H75555184EF20: '배열.'
# 'As secure log file name'
H1E6AE7BB635A: '안전한 로그 파일 이름으로'
# 'As we import functions called from hot callsite, multiply the `import-instr-limit` threshold by this factor before processing newly imported functions'
HFC6F5302C981: '뜨거운 콜사이트에서 호출된 함수를 가져올 때, 새로운 함수를 처리하기 전에 이 요인으로 `import-instr-limit` 임계값을 곱합니다'
# 'As we import functions, multiply the `import-instr-limit` threshold by this factor before processing newly imported functions'
H807021E7830C: '함수를 가져올 때, 새로운 함수를 처리하기 전에 `import-instr-limit` 임계값을 이 계수로 곱합니다'
# 'Asm comments indentation'
HA72479C6AB4B: '어셈블리 주석 들여쓰기'
# 'Assemble a .s file (default)'
H6369F207FAFB: 's 파일 어셈블 (기본값)'
# 'Assembler instructions.'
H66538D7A1ED5: '어셈블러 명령문.'
# 'Assembler line.'
H85B24622E0B1: '어셈블러 라인.'
# 'Assert no nested parallel regions in the GPU'
H418AEEF6FF3F: 'GPU에서 중첩된 병렬 영역이 없음을 확인해야 합니다'
# 'Assert no thread in a parallel region modifies an ICV'
HBA986658A86D: '병렬 영역 내의 어떤 스레드도 ICV를 수정하지 않아야 합니다'
# 'Assert that the compilation takes place in a freestanding environment'
H511BD8C1C674: '컴파일이 자립형 환경에서 이루어지도록 보장합니다'
# 'Assign reference type allocas to local address space'
H59903DB020B4: '참조 형식 allocas를 로컬 주소 공간에 할당합니다'
# 'Assign register bank of generic virtual registers'
H2974E89C9B08: '일반 가상 레지스터의 레지스터 뱅크 할당'
# 'Assign valid PTX names to globals'
HB126730FBD94: '전역 변수에 유효한 PTX 이름을 할당합니다'
# 'Assignment Tracking Analysis'
H52ADB4784DA7: '할당 추적 분석'
# 'Assigns WebAssembly register numbers for virtual registers'
H3989AF635266: 'WebAssembly 레지스터 번호를 가상 레지스터에 할당합니다'
# 'Assume SVE vector registers are at least this big, with zero meaning no minimum size is assumed.'
H2E16603634C1: 'SVE 벡터 레지스터의 크기를 최소 이 크기 이상으로 가정하며, 0인 경우 최소 크기를 가정하지 않습니다.'
# 'Assume SVE vector registers are at most this big, with zero meaning no maximum size is assumed.'
H9D138AF1C883: 'SVE 벡터 레지스터의 최대 크기는 이 크기까지로 가정하며, 0인 경우는 최대 크기를 가정하지 않습니다.'
# 'Assume V extension vector registers are at least this big, with zero meaning no minimum size is assumed. A value of -1 means use Zvl*b extension. This is primarily used to enable autovectorization with fixed width vectors.'
HD680D88BB0DC: 'V 확장 벡터 레지스터가 최소한 이 크기 이상이라는 것을 가정합니다. 0은 최소 크기를 가정하지 않는다는 의미입니다. -1 값은 Zvl*b 확장을 사용한다는 의미입니다. 이는 주로 고정 너비 벡터를 사용한 자동 벡터화를 활성화하기 위해 주로 사용됩니다.'
# 'Assume V extension vector registers are at most this big, with zero meaning no maximum size is assumed.'
H72E88FB1B9F8: 'V 확장 벡터 레지스터의 최대 크기를 이 값으로 가정합니다. 여기서 0은 최대 크기를 가정하지 않는다는 의미입니다.'
# 'Assume all functions may be convergent.'
H4C995A5519E7: '모든 함수가 수렴할 수 있다고 가정합니다.'
# 'Assume all functions with C linkage do not unwind'
H687362EE1CE8: 'C 연결을 가진 모든 함수는 언윈드하지 않는다고 가정합니다'
# 'Assume all non-trivial loops are finite.'
HE8DEA9F53022: '비중요하지 않은 모든 루프를 유한하다고 가정합니다.'
# 'Assume data segments are relative to text segment'
HDE84E251972D: '데이터 섹션이 텍스트 섹션을 기준으로 상대적이라고 가정합니다'
# 'Assume distributed loops do not have more iterations than participating teams.'
H40EE5717199D: '분산 루프가 참여하는 팀보다 더 많은 반복을 가정합니다.'
# 'Assume no atomic operations on fine-grained memory'
H63C989F614F3: '세분화된 메모리에 대한 원자 연산이 없다고 가정합니다'
# 'Assume no atomic operations on remote memory'
H0DEE4D7E8196: '원격 메모리에서 원자 연산이 없다고 가정합니다'
# 'Assume that UAVs/SRVs may alias'
HCF25B628FDEC: 'UAV/SRV가 별칭을 가질 수 있다고 가정합니다'
# "Assume that exception objects' destructors are non-throwing"
HA13DECB16694: '예외 객체의 소멸자가 던지지 않는다고 가정합니다'
# 'Assume that execution stops at trap instruction'
HFD7E94900060: '트랩 명령어에서 실행이 중단되었다고 가정합니다'
# 'Assume that externally defined data is in the small data if it meets the -G <size> threshold (MIPS)'
H79ED681B6E82: '외부에서 정의된 데이터가 -G <size> 임계값을 충족하면 작은 데이터 영역에 있다고 가정합니다 (MIPS)'
# 'Assume that kernels are launched with uniform block sizes (default true for CUDA/HIP and false otherwise)'
HA763A763DA9A: '커널이 일정한 블록 크기로 실행되었다고 가정합니다 (CUDA/HIP의 기본값은 true이며, 다른 경우에는 false입니다)'
# 'Assume that no thread in a parallel region will encounter a parallel region.'
HCB2AEFAC7594: '병렬 영역 내의 어떤 스레드도 병렬 영역을 만나지 않을 것으로 가정합니다.'
# 'Assume that no thread in a parallel region will modify an ICV.'
HF1302F78B04D: '병렬 영역 내의 스레드가 ICV를 수정하지 않을 것이라고 가정함'
# 'Assume that overflowing float-to-int casts are undefined (default)'
HCD9EDFDB1A53: 'float에서 int로 변환 시 발생하는 오버플로우가 정의되지 않았다고 가정합니다 (기본값)'
# 'Assume that the precompiled header is a precompiled preamble covering the first N bytes of the main file'
H9D4E9ACCBF56: '미리 컴파일된 헤더가 메인 파일의 첫 N 바이트를 포함하는 미리 컴파일된 프리에이블이라고 가정합니다'
# 'Assume that the product of the two iteration trip counts will never overflow'
HE37E63049A0E: '두 반복 trip count의 곱이 절대로 오버플로우하지 않을 것으로 가정합니다'
# 'Assume that top byte of an address is ignored'
H9BFCB8929B9A: '주소의 상위 바이트는 무시된다고 가정합니다'
# 'Assume the input has already undergone ThinLTO function importing and the other pre-optimization pipeline changes.'
H2CA2E2C1C103: '입력이 이미 ThinLTO 함수 임포트 및 다른 사전 최적화 파이프라인 변경 사항을 거쳤다고 가정합니다.'
# 'Assume the module is loaded at the specified address'
H85B7A3226995: '지정된 주소에서 모듈이 로드되었음을 가정합니다'
# 'Assume the non latch exit block to be predictable'
HEBCC8B6F378D: '비 래치 이택트 블록을 예측 가능한 것으로 가정합니다'
# 'Assume thread-local variables are defined in the executable'
H9F2FA53E0530: '쓰레드 로컬 변수들이 실행 파일에 정의되었다고 가정합니다'
# 'Assume work-shared loops do not have more iterations than participating threads.'
HF6F555EC0542: '작업 분할 루프는 참여하는 스레드보다 더 많은 반복을 가질 수 없습니다.'
# 'Assumed aligned memory accesses.'
H1F99EB0F5177: '가정된 맞춤 메모리 접근.'
# 'Assumed extra stack use if there are any variable sized objects (in bytes)'
HC8C97CA4569F: '가변 크기의 개체가 있는 경우 추가 스택 사용량을 추정 (바이트 단위)'
# 'Assumed stack use of any external call (in bytes)'
H4EA740EFEAD0: '외부 호출의 스택 사용량 추정치 (바이트 단위)'
# 'Assumption Cache Tracker'
HD200FE62329F: '가정 캐시 추적기'
# 'At top of block or after label'
H305A8BE31E6D: '블록의 최상단이나 레이블 이후'
# 'Attach calleeguids as value profile metadata for indirect calls.'
HDF15CBA413B3: '간접 호출에 대한 값 프로파일 메타데이터로 호출 대상 GUID 첨부'
# 'Attach debug info to a function'
H08A666FD7289: '함수에 디버그 정보를 첨부합니다'
# 'Attach debug info to everything'
HED658EC60D0F: '디버그 정보를 모든 항목에 연결합니다'
# 'Attempt coalescing during PBQP register allocation.'
H7648F369F9C7: 'PBQP 레지스터 할당 중 결합을 시도합니다.'
# 'Attempt to allocate array temporaries created under -frepack-arrays on the stack'
HB0B7FBFAAEA5: '-frepack-arrays에서 생성된 배열 임시 변수를 스택에 할당을 시도합니다'
# 'Attempt to allocate array temporaries on the stack, no matter their size'
H1898E5AD9AA7: '배열 일시 객체를 스택에 할당하려고 시도함, 크기에 관계없이'
# 'Attempt to drop solution if it is less profitable'
H339D061FB39B: '해결책이 덜 이익을 brings 경우 해당 해결책을 제거하려고 시도함'
# 'Attempt to match the ABI of Clang <version>'
H0603A0819A4F: 'Clang <version>의 ABI를 일치시키려는 시도'
# 'Attempt to vectorize for this register size in bits'
HC4E22D3921AE: '비트 단위의 이 레지스터 크기로 벡터화를 시도했습니다'
# 'Attempt to vectorize horizontal reductions'
H7D29B593C54B: '수평적 감소를 벡터화하려고 시도했습니다'
# 'Attempt to vectorize horizontal reductions feeding into a store'
H86C2FB57AC78: '저장으로 피드되는 수평 감소를 벡터화하려는 시도'
# 'Attribute Options'
H80A446F5E125: '속성 옵션'
# "Attribute all functions' range with zero count even it's not hit by any samples."
H6A8CFBBE8142: '함수의 모든 범위에 0 카운트로 특성을 부여하더라도 샘플에 의해 히트되지 않더라도.'
# 'Auto-generates preprocessed source files and a reproduction script'
H2B36EB61E3F1: '자동으로 사전 처리된 소스 파일과 재현 스크립트를 생성합니다'
# 'Automatically put hot code on 2MB page(s) (hugify) at runtime. No manual call to hugify is needed in the binary (which is what --hot-text relies on).'
H0155A65DE424: '실행 시 자동으로 뜨거운 코드를 2MB 페이지(들)에 배치합니다 (hugify). 이진 파일 내에서 hugify에 대한 수동 호출이 필요하지 않습니다 (이는 --hot-text가 의존하는 것과 동일합니다).'
# 'Auxiliary target triple.'
H7C66B9F24C8E: '보조 타겟 트리플.'
# 'Average inst/cycle when no target itinerary exists.'
HAC1A1866B355: '타겟 이터리너리가 없는 경우의 평균 명령어/시클.'
# 'Avoid FPU mode dependent operations when used with the O32 ABI'
HFD29595F0062: 'O32 ABI와 함께 사용될 때 FPU 모드에 의존적인 연산을 피하십시오'
# 'Avoid logging potentially-sensitive request details'
H7AE408773694: '민감할 수 있는 요청 세부 정보 기록을 피하십시오'
# 'Avoid optimizing x86 call frames for size'
HEAFF156A02EB: 'x86 호출 프레임을 크기 최적화를 위해 최적화하지 마십시오'
# 'Avoid translating the elements of DICompositeTypes during the LLVM IR import (discouraged: testing only!)'
H92E0AEF9C7F0: 'LLVM IR를 가져오는 동안 DICompositeTypes의 요소를 번역하지 않음 (권장하지 않음: 테스트용으로만!)'
# 'Avoid using scaled registers with vscale-relative addressing'
H9CD1A0FBC370: 'vscale 상대적 주소 지정과 함께 스케일된 레지스터를 사용하지 마십시오'
# 'BAT dump options'
HE7548A5409DC: 'BAT 덤프 옵션'
# 'BC Analyzer Options'
H4B23BE663585: 'BC 분석기 옵션'
# 'BOLT - Binary Optimization and Layout Tool\n'
H01223DC88456: 'BOLT - 이진 최적화 및 레이아웃 도구\n'
# 'BOLT generic options'
H833927334F93: 'BOLT 일반 옵션'
# 'BOLT instrumentation options'
H236274761B58: 'BOLT 인스트루먼테이션 옵션'
# 'BOLT optimization options'
HF7FB7C2D71C6: 'BOLT 최적화 옵션'
# 'BOLT options in relocation mode'
H72F40B1DAEF4: '리로케이션 모드의 BOLT 옵션'
# 'BOLTDIFF generic options'
HBCE6535FC79B: 'BOLTDIFF 일반 옵션'
# 'BPF Assembly Printer'
H12132B1ED395: 'BPF 어셈블리 프린터'
# 'BPF Check And Adjust IR'
H4D7204899754: 'BPF IR 검사 및 조정'
# 'BPF DAG->DAG Pattern Instruction Selection'
H7C44CC075E35: 'BPF DAG→DAG 패턴 기반 명령 선택'
# 'BPF MachineSSA Peephole Optimization For ZEXT Eliminate'
H1FCC7FDAD7BB: 'BPF MachineSSA 피치홀 최적화를 위한 ZEXT 제거'
# 'BPF PreEmit Checking'
H9D3E8CD483F5: 'BPF 사전 생성 검사'
# 'BPF PreEmit Peephole Optimization'
H9917446E38FB: 'BPF PreEmit 피홀 최적화'
# 'BPF PreEmit SimplifyPatchable'
HD1C3DD579B0E: 'BPF 사전 에밋 단순화 가능한 패치'
# 'BPF: Disable Avoiding Speculative Code Motion.'
HA01C55FDDABF: 'BPF: 추측 코드 이동 회피 비활성화.'
# 'BPF: Disable Serializing ICMP insns.'
H688F09F03EC9: 'BPF: 직렬화 ICMP 명령문 비활성화합니다.'
# 'Bail out on unprofitable SCoPs before rescheduling'
HD7D2870382BF: '재스케줄링 전에 수익성이 없는 SCoPs에서 탈출합니다'
# 'Base Directory for generated documentation.\nURLs will be rooted at this directory for HTML links.'
HD430D315BE29: '생성된 문서의 기본 디렉토리입니다.\nHTML 링크의 URL은 이 디렉토리를 루트로 사용합니다.'
# 'Base Type (int, bool, etc.).'
H7F681232E46A: '기본 형식 (int, bool 등).'
# 'Base cost of vector insert/extract element'
HA29AACEEF76F: '벡터 삽입/추출 요소의 기본 비용'
# 'Base file path for the interactive mode. The incoming filename should have the name <inliner-interactive-channel-base>.in, while the outgoing name should be <inliner-interactive-channel-base>.out'
HED13A1932932: '인터랙티브 모드의 기본 파일 경로입니다. 입력 파일 이름은 <inliner-interactive-channel-base>.in이어야 하며, 출력 파일 이름은 <inliner-interactive-channel-base>.out이어야 합니다'
# 'Base file path for the interactive mode. The incoming filename should have the name <regalloc-evict-interactive-channel-base>.in, while the outgoing name should be <regalloc-evict-interactive-channel-base>.out'
HEEBA85373FA8: '인터랙티브 모드의 기본 파일 경로입니다. 들어오는 파일 이름은 <regalloc-evict-interactive-channel-base>.in으로 지정해야 하며, 나가는 파일 이름은 <regalloc-evict-interactive-channel-base>.out으로 사용해야 합니다'
# 'Base file path for the interactive mode. The incoming filename should have the name <regalloc-priority-interactive-channel-base>.in, while the outgoing name should be <regalloc-priority-interactive-channel-base>.out'
H9411EE803DAA: '인터랙티브 모드의 기본 파일 경로입니다. 입력 파일 이름은 <regalloc-priority-interactive-channel-base>.in이어야 하며, 출력 이름은 <regalloc-priority-interactive-channel-base>.out이어야 합니다'
# 'Base penalty for splitting cold code (as a multiple of TCC_Basic)'
H9A157E9C325A: 'TCC_Basic의 배수로 cold code 분할에 대한 기본 벌점'
# 'Base types (int, bool, etc.).'
H6DA8FED6F2CE: '기본 유형 (int, bool 등).'
# 'Basic Alias Analysis (stateless AA impl)'
H5B13D0BE4C70: '기본 별칭 분석 (상태 없는 AA 구현)'
# 'Basic Block Frequency'
H288285DDFDA1: 'Basic Block 빈도'
# 'Basic Block Placement Stats'
H907EA5CFB1D6: '기본 블록 배치 통계'
# 'Basic Register Allocator'
H79DC6E995B15: '기본 레지스터 할당기'
# 'Basic algebraic expansions of complex arithmetic operations involving are disabled.'
HDF7A39346B61: '복소 산술 연산에 관련된 기본 대수 확장이 비활성화되었습니다.'
# 'Basic algebraic expansions of complex arithmetic operations involving are enabled.'
H262F35B467F4: '복소수 산술 연산에 대한 기본 대수적 전개가 활성화되었습니다.'
# 'Basic attributes alias.'
HE45CB3A77EAA: '기본 속성 별칭.'
# 'Basic block limit for a function for RDF optimizations'
H4FCE83C0EE11: 'RDF 최적화를 위한 함수의 기본 블록 한계'
# 'Basic block.'
H0E36AB3035D5: '기본 블록.'
# 'Basic register allocator'
HAA9EC9D57F33: '기본 레지스터 할당기'
# 'Be more conservative in ARM load/store opt'
HDDB9289EB602: 'ARM 로드/스토어 최적화에서 보다 보수적 옵션 사용'
# 'Before everything'
HD2BEA8D1D530: '전체 내용보다 앞에 위치합니다'
# 'Best scheduler for the target'
H5C9427319FEA: '목표 아키텍처에 대한 최적의 스케줄러'
# 'Binary encoding'
H2B45E735D11B: '바이너리 인코딩'
# 'Binary encoding (default)'
H75E6792272B3: '이진 인코딩 (기본값)'
# 'BinaryAnalysis\n'
HC08403F87EF1: '이진분석\n'
# 'BinaryAnalysis options'
H0030C9E3CDAC: '바이너리 분석 옵션'
# 'Bit simplification'
HD2769EDD49F1: '비트 단순화'
# 'Bit size of immediate TLS offsets'
HE94155328C5F: '즉시 TLS 오프셋의 비트 크기'
# 'Bitstream'
HA8A9704FB47E: '비트스트림'
# 'Bitwidth of the index type for the host (warning this should be 64 until the GPU layering is fixed)'
H1A2F700B75FE: '호스트의 색인 유형 비트폭 (경고: GPU 계층이 수정될 때까지 이 값은 64여야 합니다)'
# 'Block Frequency Analysis'
H0F710FC006A0: '블록 빈도 분석'
# 'Block frequency percentage a loop exit block needs over the original exit to be considered the new exit.'
H1B72423F0425: '루프 종료 블록이 새로운 종료로 간주되기 위해 원래 종료에 비해 필요한 블록 빈도 퍼센트입니다.'
# 'Block until the parser can be used'
H1C8FDBE8C1C0: '파서가 사용될 수 있을 때까지 대기합니다'
# 'Bottom-up register pressure aware list scheduling which tries to balance ILP and register pressure'
H9D996A6F7F40: '하향식 레지스터 압력 인지 리스트 스케줄링으로 ILP와 레지스터 압력을 균형 있게 맞추려는 방식'
# 'Bottom-up register pressure aware list scheduling which tries to balance latency and register pressure'
H394C581D41AA: '지연 시간과 레지스터 압력을 균형 있게 유지하려는 하향식 레지스터 압력 인식 리스트 스케줄링'
# 'Bottom-up register reduction list scheduling'
H669DA6589497: '하향식 레지스터 감소 리스트 스케줄링'
# 'Bound on stack depth while inlining (4 by default)'
H517AFAFA9D42: '인라인 중 스택 깊이 제한 (기본값 4)'
# 'Bound the dependence analysis by a maximal amount of computational steps (0 means no bound)'
H649A261EB1B0: '의존성 분석을 계산 단계의 최대 양으로 제한합니다 (0은 제한 없음을 의미합니다)'
# 'Bound the scheduler by maximal amountof computational steps. '
H51E6C0F8C158: '실행 관리자를 최대 계산 단계 수로 제한합니다.'
# 'Bound the scop analysis by a maximal amount of computational steps (0 means no bound)'
H82EB650E9442: 'scop 분석을 계산 단계의 최대 양으로 제한합니다 (0은 제한 없음을 의미합니다)'
# 'Branch Coalescing'
H2DBEA167A999: '브랜치 결합'
# 'Branch Probability'
HC336B7481E8C: '분기 확률'
# 'Branch Probability Analysis'
HE38E9B0A525A: '분기 확률 분석'
# 'Branch Probability Basic Block Placement'
H87FA8A5489AA: '분기 확률 기본 블록 배치'
# 'Branch relaxation pass'
H6AFFC7671D8D: '가지 완화 패스'
# 'Break backedge through symbolic execution of 1st iteration attempting to prove that the backedge is never taken'
HE2539A780F40: '기호 실행을 통해 첫 번째 반복을 실행하며 백 엣지가 결코 실행되지 않음을 증명하려고 시도하는 백 엣지를 끊습니다'
# 'Break critical edges in CFG'
HD9D1E732D541: 'CFG의 비판적 간선을 분할합니다'
# 'Break large PHI nodes for DAGISel'
HCF5413A8839F: 'DAGISel을 위한 큰 PHI 노드 분할'
# 'Break post-RA scheduling anti-dependencies: "critical", "all", or "none"'
H75472E865DE3: 'RA 후 스케줄링 반의존성 파괴: "critical", "all", 또는 "none"'
# 'BreakFalseDeps'
H5FF559A5250F: '가짜 의존성 해제'
# 'Breakdown the count by function name taking into consideration the filepath info from the DebugLoc of the remark.'
HC1EFEB5BC743: '리마크의 DebugLoc에서 파일 경로 정보를 고려하여 함수 이름별로 카운트를 분할하라.'
# 'Breakdown the count by function name.'
H55D8DD7267D8: '함수 이름별로 카운트를 분할합니다.'
# 'Bucket number per loop for PPC loop chain common'
H095EE2A27794: 'PPC 루프 체인 공통 루프 당 버킷 번호'
# 'Buffer the last N characters of debug output until program termination. [default 0 -- immediate print-out]'
HEA243B6BB971: '디버그 출력의 마지막 N 문자를 프로세스 종료까지 버퍼에 저장합니다. [기본값 0 -- 즉시 출력]'
# "BugPoint Test Pass - Intentionally 'misoptimize' CallInsts"
H89AAE42B7AE6: "BugPoint 테스트 패스 - 의도적으로 '잘못 최적화' CallInsts"
# 'BugPoint Test Pass - Intentionally crash on CallInsts'
HDE32B6B83F4F: 'BugPoint 테스트 패스 - CallInst에서 의도적으로 크래시 발생'
# 'BugPoint Test Pass - Intentionally crash on declared functions'
H42F2EE82DA8D: 'BugPoint 테스트 패스 - 선언된 함수에서 의도적으로 크래시'
# 'BugPoint Test Pass - Intentionally crash on fabs calls with fpmath metadata and an fadd as argument'
H1E926C1BB889: 'BugPoint 테스트 패스 - fpmath 메타데이터와 fadd 인수를 가진 fabs 호출 시 의도적으로 크래시 발생'
# "BugPoint Test Pass - Intentionally crash on function attribute 'bugpoint-crash'"
H05C0FF4CFB70: "BugPoint 테스트 통과 - 함수 속성 'bugpoint-crash'에서 의도적으로 크래시 발생"
# 'BugPoint Test Pass - Intentionally crash on too many CUs'
H8C6E2ED6A47E: 'BugPoint 테스트 패스 - 너무 많은 CUs로 인해 의도적으로 크래시 발생'
# 'Build ASTs and convert to LLVM, discarding output'
HFD98A9A1FB1A: 'AST를 생성하고 LLVM으로 변환하며 출력을 무시'
# 'Build ASTs and print the list of declaration node qualified names'
HCB31A5A33A8E: 'AST를 빌드하고 선언 노드의 전체 이름 목록을 출력합니다'
# 'Build ASTs and then debug dump their name lookup tables'
HB898C7F894F2: 'AST를 구축한 다음 이름 검색 테이블을 디버그 덤프합니다'
# 'Build ASTs and then debug dump them'
H7902F2D13330: 'AST를 생성한 후 디버그 덤프를 수행합니다'
# 'Build ASTs and then debug dump them in the specified format, forcing deserialization. Supported formats include: default, json'
HE96A00FC958F: 'AST를 구축한 다음 지정된 형식으로 디버그 덤프를 강제 역직렬화하여 수행합니다. 지원되는 형식에는 default 및 json이 있습니다'
# 'Build ASTs and then debug dump them in the specified format. Supported formats include: default, json'
H92BA7F1490EF: 'AST를 생성한 후 지정된 형식으로 디버그 덤프합니다. 지원되는 형식에는 default, json이 포함됩니다'
# 'Build ASTs and then debug dump them, forcing deserialization'
HEE028C067F24: 'AST를 구축한 후 디버그 덤프를 생성하고 역직렬화를 강제합니다'
# 'Build ASTs and then lower to ClangIR'
HDF4F258BFB65: 'AST를 생성한 다음 ClangIR로 하향 변환합니다'
# 'Build ASTs and then pretty-print them'
H9599366C5CC9: 'AST를 구축한 다음 pretty-print합니다'
# 'Build ASTs and view them with GraphViz'
H03B49E6509AA: 'AST를 구축하고 GraphViz로 확인합니다'
# 'Build ASTs then convert to LLVM, emit .bc file'
H3D999491C902: 'ASTs를 구축한 다음 LLVM으로 변환하고 .bc 파일을 생성합니다'
# 'Build VPlan for every supported loop nest in the function and bail out right after the build (stress test the VPlan H-CFG construction in the VPlan-native vectorization path).'
HE361DC02BCE3: '함수 내에서 지원되는 모든 loop nest에 대해 VPlan을 생성한 후, 구축 과정 직후 즉시 중단 (VPlan-native 벡터화 경로에서의 VPlan H-CFG 구조 생성을 스트레스 테스트하기 위한 목적).'
# 'Build a C++20 Header Unit from a header'
H9A493A45835C: '헤더로부터 C++20 헤더 유닛을 구축'
# 'Build a C++20 Header Unit from a header that should be found in the user (fmodule-header=user) or system (fmodule-header=system) search path.'
H0DC1129B500A: 'C++20 헤더 유닛을 사용자(fmodule-header=user) 또는 시스템(fmodule-header=system) 검색 경로에서 찾을 수 있는 헤더 파일에서 구축합니다.'
# 'Build for HVX v60'
H5F194250AE06: 'HVX v60을 위한 빌드'
# 'Build for HVX v62'
HAFED34899A8C: 'HVX v62를 위한 빌드'
# 'Build for HVX v65'
H207B9B2D5225: 'HVX v65용 빌드'
# 'Build for HVX v66'
HEA3895BB213D: 'HVX v66용 빌드'
# 'Build for HVX v67'
H42B647301419: 'HVX v67을 위한 빌드'
# 'Build for HVX v68'
H77FF21179BCC: 'HVX v68을 위한 빌드'
# 'Build for HVX v69'
H905F9940179D: 'HVX v69용 빌드'
# 'Build for HVX v71'
H165F94AD0A42: 'HVX v71을 위한 빌드'
# 'Build for HVX v73'
H67E019A7BE26: 'HVX v73용 빌드'
# 'Build for HVX v75'
HEB883439B283: 'v75용 HVX 빌드'
# 'Build for HVX v79'
H231DD2C4D603: 'v79용 HVX 빌드'
# 'Build for Hexagon V5'
H1C71E9B94F5C: 'Hexagon V5용 빌드'
# 'Build for Hexagon V55'
H58046BC87A11: 'Hexagon V55용 빌드'
# 'Build for Hexagon V60'
H05D6BD8DE043: 'Hexagon V60 용 빌드'
# 'Build for Hexagon V62'
H397E863A80C2: 'Hexagon V62 용 빌드'
# 'Build for Hexagon V65'
HD1EC00E09426: 'Hexagon V65용 빌드'
# 'Build for Hexagon V66'
HE5554963D68F: 'Hexagon V66용 빌드'
# 'Build for Hexagon V67'
H87AB7CC8B603: 'Hexagon V67용 빌드'
# 'Build for Hexagon V67T'
HB3C7C60D0839: 'Hexagon V67T용 빌드'
# 'Build for Hexagon V68'
H712B082469B0: 'Hexagon V68용 빌드'
# 'Build for Hexagon V69'
H33FDB62409F4: 'Hexagon V69용 빌드'
# 'Build for Hexagon V71'
HF8AB85CAF9EB: 'Hexagon V71용 빌드를 수행 중입니다'
# 'Build for Hexagon V71T'
H6AC6FBE66236: 'Hexagon V71T를 위한 빌드'
# 'Build for Hexagon V73'
H7840346BDBBB: 'Hexagon V73용 빌드'
# 'Build for Hexagon V75'
HB923BD289BC7: 'Hexagon V75용 빌드'
# 'Build for Hexagon V79'
H860D9669E777: 'Hexagon V79를 위한 빌드'
# 'Build path'
H51B665BD227F: '빌드 경로'
# 'Build the parse tree, then lower it to FIR'
H5AA5D4111927: '문법 분석 트리를 구축한 다음, 이를 FIR로 하향 변환합니다.'
# 'Build the parse tree, then lower it to HLFIR'
H209B3028A0CD: '파스 트리를 빌드한 다음 HLFIR로 하향 변환합니다'
# 'Build this module as a system module. Only used with -emit-module'
HF896829DCA95: '이 모듈을 시스템 모듈로 빌드합니다. -emit-module과 함께 사용됩니다'
# 'Bundle Machine CFG Edges'
H7815BA6F9789: '머신 CFG 간선 묶기'
# 'Bundle output files of HIP device compilation'
HCA7306204A95: 'HIP 장치 컴파일의 출력 파일을 통합합니다'
# 'Burnside Bridge Compiler\n'
H5B149431AA40: '번사이드 브리지 컴파일러\n'
# 'By default, we analyze the benchmarks for the triple/CPU they were measured for, but if you want to analyze them for some other combination (specified via -mtriple/-mcpu), you can pass this flag.'
H76350EEAD124: '기본적으로, 이 도구는 벤치마크를 측정된 triple/CPU에 대해 분석하지만, 다른 조합( -mtriple/-mcpu로 지정)으로 분석하려면 이 플래그를 전달할 수 있습니다.'
# 'Bypass the profitability model of load slicing'
H3E3A7818BD1C: '로드 슬라이싱의 수익성 모델을 우회하다'
# 'C does not support default arguments'
H9634D9BB0DF6: 'C는 기본 인수를 지원하지 않습니다'
# 'C requires #line number to be less than %0, allowed as extension'
H2FF7FD761591: 'C 언어는 #line 번호가 %0 미만이어야 한다고 요구하지만, 확장 기능으로 허용됩니다'
# 'C requires a comma prior to the ellipsis in a variadic function type'
HF2B9DE1954B1: 'C 언어는 가변 인자 함수 타입에서 Ellipsis(...) 앞에 쉼표(,)가 필요합니다'
# "C++ ABI '%0' is not supported on target triple '%1'"
H00336F051C87: "C++ ABI '%0'은(는) 타겟 triple '%1'에서 지원되지 않습니다"
# 'C++ ABI to use. This will override the target C++ ABI.'
H9B471B29FD3A: '사용할 C++ ABI. 이 설정은 대상 C++ ABI를 재정의합니다.'
# 'C++ implementation file name'
HE4F416D1C66F: 'C++ 구현 파일 이름'
# 'C++ operator %0 (aka %1) used as a macro name'
H2A2A24E029F0: 'C++ 연산자 %0 (즉, %1)이 매크로 이름으로 사용되었습니다'
# 'C++ standard library to use'
HEE4D104DB34B: '사용할 C++ 표준 라이브러리'
# 'C++11 only allows consecutive left square brackets when introducing an attribute'
H2040F8CA0C12: 'C++11은 속성을 도입할 때 연속된 왼쪽 대괄호만 허용됩니다'
# 'C++98 requires an accessible copy constructor for class %2 when binding a reference to a temporary; was %select{private|protected}0'
H89F3A4330FF6: 'C++98은 임시 객체에 대한 참조를 바인딩할 때 %2 클래스에 대한 접근 가능한 복사 생성자가 필요합니다; 그러나 %select{프라이빗|프로텍티드}0 이었습니다'
# 'C99 forbids casting nonscalar type %0 to the same type'
H26E6559D43AC: 'C99는 비스칼라 형식 %0를 같은 형식으로 캐스팅하는 것을 금지합니다'
# 'C99 forbids conditional expressions with only one void side'
HD3A412BC601A: 'C99는 단일 void 측면만 있는 조건식을 금지합니다'
# 'CF object of type %0 is bridged to %1, which is not an Objective-C class'
H41EE49AD057C: '유형 %0의 CF 객체는 %1으로 교환되지만, 이는 Objective-C 클래스가 아닙니다'
# 'CFGuard'
H6826B8A9825A: '제어 흐름 보호'
# 'CFI Verify Options'
H72E6B238AC79: 'CFI 검증 옵션'
# 'CFString literal is not a string constant'
H89C093890935: 'CFString 리터럴은 문자열 상수가 아닙니다'
# 'CHR considers a branch bias greater than this ratio as biased'
HDF87AB6569F2: 'CHR은 이 비율보다 큰 분기 편향을 편향된 것으로 간주합니다'
# 'CHR merges a group of N branches/selects where N >= this value'
H5C657F973B2B: 'CHR은 N이 이 값 이상일 때 N개의 분기/선택문 그룹을 결합합니다'
# 'CIR module verification error before running CIR-to-CIR passes'
H045DC8C3B34D: 'CIR-TO-CIR 패스 실행 전 CIR 모듈 검증 오류'
# 'CIR-to-CIR transformation failed'
H9F8DAC16F05E: 'CIR에서 CIR로의 변환에 실패했습니다'
# 'CL.EXE COMPATIBILITY OPTIONS'
H505EEFB93C8E: 'CL.EXE 호환성 옵션'
# 'COFF Symbol RVAs (DEBUG_S_COFF_SYMBOL_RVA subsection)'
HFE26A86E5CFD: 'COFF 기호 RVA 값 (DEBUG_S_COFF_SYMBOL_RVA 하위 섹션)'
# "CPU '%0' does not support '%1' execution mode"
H489FB3B6F514: "%0 CPU는 '%1' 실행 모드를 지원하지 않습니다"
# 'CPU list contains duplicate entries; attribute ignored'
H40F374760829: 'CPU 목록에 중복 항목이 포함되었습니다; 속성이 무시되었습니다'
# 'CSKY DAG->DAG Pattern Instruction Selection'
H21AAA3835725: 'CSKY DAG→DAG 패턴 명령어 선택'
# 'CSKY constant island placement and branch shortening pass'
H1AC93DA4EF44: 'CSKY 상수 섬 배치 및 분기 단축 패스'
# 'CSS stylesheets to extend the default styles.'
H9DE4F76128DB: '기본 스타일을 확장하기 위한 CSS 스타일 시트입니다.'
# 'CSV format'
H6111A3501F49: 'CSV 형식'
# 'CUDA device code does not support va_arg'
H3A59FE235409: 'CUDA 디바이스 코드는 va_arg를 지원하지 않습니다'
# 'CUDA device code does not support variadic functions'
H218B98CDADDE: 'CUDA 디바이스 코드는 가변 인자 함수를 지원하지 않습니다'
# 'CUDA does not support global %0 for __device__ functions'
H8DC2F94408E4: 'CUDA는 __device__ 함수에 대한 global %0를 지원하지 않습니다'
# 'CUDA installation path'
H42DE34B3E373: 'CUDA 설치 경로'
# 'CUDA offload target is supported only along with --emit-llvm'
H1424A8C5858B: 'CUDA 오프로드 타겟은 --emit-llvm과 함께 사용시에만 지원됩니다'
# 'CUDA older than 10.0 does not support .alias'
H4BD47BC9C21A: 'CUDA 10.0 미만 버전은 .alias를 지원하지 않습니다'
# "CUDA special function '%0' must have scalar return type"
H4386F29D7C1C: "CUDA 특수 함수 '%0'는 스칼라 반환 타입을 가져야 합니다"
# 'CUDA version %0 is only partially supported'
HABB5F3AD45B9: 'CUDA 버전 %0는 부분적으로만 지원됩니다'
# 'CUDA version%0 is newer than the latest%select{| partially}1 supported version %2'
HC8470F3A3C10: 'CUDA 버전%0는 지원되는 최신%select{ | 부분적으로}1 버전 %2보다 최신입니다'
# 'CXX Dump Options'
HEC70FF6EBB76: 'CXX 옵션 덤프'
# 'CXX Map Options'
H4ACF6390C9B8: 'C++ 맵 옵션'
# 'Cache Directory'
HBD7A05972161: '캐시 디렉토리'
# 'Calculate the intrinsic cost based only on argument types'
H204B60BE4CD1: '인수 유형에만 기반하여 내재적 비용을 계산합니다'
# 'Call nonlazybind functions via direct GOT load for Mach-O'
H734541906E0F: 'Mach-O를 위해 nonlazybind 함수를 직접 GOT 로드를 통해 호출합니다'
# 'Call penalty that is applied per callsite when inlining'
HF8A8A3618DB8: '인라인 시 각 호출 위치에 적용되는 호출 패널티'
# 'Call score power (when --split-strategy=cdsplit)'
H657B2E4D7127: '호출 점수 강도 (옵션 --split-strategy=cdsplit 활성화 시)'
# 'Call score scale coefficient (when --split-strategy=cdsplit)'
H3C68D9A52C2C: '호출 점수 스케일 계수(옵션 --split-strategy=cdsplit을 사용할 때)'
# 'Call site block.'
H1A44C6CE10A5: '호출 사이트 블록.'
# 'Call site parameter.'
H13AFDEB70D71: '호출 위치 매개변수.'
# 'CallGraph Construction'
H59F475A8E976: '호출 그래프 구축'
# 'Can specify at most '
H04A2B40FE103: '최대 '
# 'Canonicalize Freeze Instructions in Loops'
HA0687B0F1DED: '루프 내 프리즈 명령 표준화'
# 'Canonicalize natural loops'
H36CFB482F86F: '자연 루프 정규화'
# 'Capture the number of times a stack was invoked. In flamegraph mode, this count also includes invocations of all callees.'
HC70FACC6E899: '스택이 호출된 횟수를 기록합니다. 플레임그래프 모드에서는 이 카운트에는 모든 호출받는 함수의 호출 횟수도 포함됩니다.'
# 'Capture the total time spent in an all invocations of a stack.'
H44E274E610C2: '스택의 모든 호출에서 소요된 총 시간을 측정합니다.'
# 'Causes the backend to crash instead of generating a nop VSX copy'
H3232545B99E1: 'nop VSX 복사본을 생성하는 대신 백엔드가 크래시하게 합니다'
# 'Change byte and word instructions to larger sizes'
HEF144CF00477: '바이트 및 워드 명령어를 더 큰 크기로 변경합니다'
# 'Change diagnostic formatting to match IDE and command line tools'
H8A6273359475: '진단 형식을 IDE 및 명령행 도구와 일치되도록 변경합니다'
# 'Change indirect jump instructions to inhibit speculation'
H3608CF11CF48: '간접 점프 명령어를 변경하여 추측을 억제합니다'
# 'Change namespace.'
H43653D361A25: '네임스페이스를 변경합니다.'
# 'Change the C++ ABI to returning `this` pointer from constructors and non-deleting destructors. (No effect on Microsoft ABI)'
H33EEEB0B1310: 'C++ ABI를 생성자와 non-deleting 소멸자에서 `this` 포인터를 반환하도록 변경합니다. (Microsoft ABI에는 영향을 주지 않습니다)'
# "Change the greedy register allocator's live range priority calculation to make the AllocationPriority of the register class more important then whether the range is global"
H8D990FD681E2: '탐욕스러운 레지스터 할당기의 라이브 레인지 우선순위 계산을 변경하여 레지스터 클래스의 AllocationPriority가 해당 범위가 전역인지 여부보다 더 중요하게 만듭니다'
# 'Change variadic calling convention'
HD4EADD7ABB24: '가변 인자 호출 규칙 변경'
# 'Check CFA info and insert CFI instructions if needed'
HB1FAB917FF49: 'CFA 정보를 확인하고 필요한 경우 CFI 지시문을 삽입합니다'
# 'Check all diagnostics (expected, unexpected, near-misses)'
HDD500F45AE52: '모든 진단을 확인 (예상, 예상되지 않음, 근접 미스)'
# 'Check debug info from -debugify'
H8AF6D59AB27A: '-debugify에서 디버그 정보 확인'
# 'Check debug info from -debugify-function'
HE67C041D8BED: '디버그 정보를 -debugify-function에서 확인합니다.'
# 'Check elements integrity.'
HEA4B7C7680A0: '요소 정합성을 확인합니다.'
# 'Check floating-point load'
H7623BFCEEC52: '부동소수점 로드 확인'
# 'Check floating-point return values'
H59EBDCF68E8C: '부동소수점 반환 값을 확인하세요'
# 'Check floating-point stores'
H27184F67D1D6: '부동소수점 저장 확인'
# 'Check for parallel loops'
H86C1DC29F0D4: '병렬 루프 확인'
# 'Check for vectorizable loops'
H3CD8604AF754: '벡터화 가능한 루프 확인'
# 'Check if block frequency is queried for an unknown block for debugging missed BFI updates'
H105B69431A40: '알려지지 않은 블록에 대한 블록 빈도 조회 여부 확인 (누락된 BFI 업데이트 디버깅용)'
# 'Check if input heterogeneous archive is valid in terms of TargetID rules.\n'
HA0A80D536062: '입력된 이질적인 아카이브가 TargetID 규칙에 따라 유효한지 확인합니다.\n'
# 'Check module hash using the argument as a string table'
H43F3CCEA9F64: '인수를 문자열 테이블로 사용하여 모듈 해시 확인'
# 'Check only expected diagnostics'
H1D795C0D9F5F: '예상 진단만 확인'
# 'Check pointer authentication auth/resign failures'
HBEEB7E32E077: '포인터 인증 인증/재서명 실패 확인'
# 'Check stack-use-after-scope'
H899C3D082FBF: 'stack-use-after-scope 확인'
# 'Check that emitted diagnostics match expected-* lines on the corresponding line'
H0CFA18038D08: '생성된 진단 메시지가 해당 라인의 예상된-* 라인과 일치하는지 확인합니다'
# 'Check the input source files from C++20 modules explicitly'
HA2774E416A4F: 'C++20 모듈에서 입력 소스 파일을 명시적으로 확인하십시오'
# 'Chip to use to serialize to cubin.'
H07B7361E60E0: 'cubin 직렬화에 사용할 칩.'
# 'Choose DWARF debug sections compression:'
H2B65135A807B: 'DWARF 디버그 섹션 압축을 선택하세요:'
# 'Choose a file type (not all types are supported by all targets):'
HAA6114F47F11: '파일 유형을 선택하세요 (모든 타겟에서 모든 유형을 지원하지 않을 수 있습니다):'
# 'Choose an output file type:'
H92BDEF215C75: '출력 파일 유형을 선택하세요:'
# 'Choose analyzer checkers to disable'
H77983530DA75: '비활성화할 분석기 체커를 선택하세요'
# 'Choose analyzer checkers to enable'
H41B48112BDF6: '사용할 분석기 체커를 선택하세요'
# 'Choose analyzer options to enable'
HCB7427D52FDE: '사용할 분석기 옵션을 선택해 주세요'
# 'Choose code model'
HA2B6154EBE1C: '코드 모델을 선택하세요'
# 'Choose float ABI type'
HA37D38E85873: 'float ABI 유형을 선택하세요'
# 'Choose large data threshold for x86_64 medium code model'
HE1DFA96AAF80: 'x86_64 중간 코드 모델용 큰 데이터 임계값 지정'
# 'Choose level of diagnostic information'
HD8EA761DDF80: '진단 정보의 수준을 선택합니다'
# 'Choose relocation model'
HD54EDB40A370: '재배치 모델을 선택하세요'
# 'Choose speculation scheme'
HCB6C8E99AC45: '추측 방식을 선택하세요'
# 'Choose style of NEON code to emit from AArch64 backend:'
H2D6E1D10E2D8: 'AArch64 백엔드에서 방출할 NEON 코드의 스타일을 선택하세요:'
# 'Choose the OpenMP library to use:'
HE50F5292F771: '사용할 OpenMP 라이브러리를 선택하세요:'
# 'Choose the dynamic linker/loader.'
H10D084FE139A: '동적 링커/로더를 선택해 주세요.'
# 'Choose the number of compile threads (jit-kind=orc-lazy only)'
H098814BE3E37: '컴파일 스레드의 숫자를 선택하세요 (jit-kind=orc-lazy만 해당)'
# 'Choose the priority mode to use in module inline'
H3DB5A6B44603: '모듈 인라인에서 사용할 우선순위 모드를 선택하세요'
# 'Choose the report output format:'
HAA84783D1EFB: '보고서 출력 형식을 선택하세요:'
# 'Choose the strategy to replace exit value in IndVarSimplify'
H3B106241E759: 'IndVarSimplify에서 exit value를 대체하기 위한 전략을 선택하세요'
# 'Choose threading model'
HC20B03302377: '스레딩 모델을 선택하세요'
# 'Choose to use MD5 to represent string in name table (only meaningful for -extbinary)'
H2AF20046DB81: '이름 테이블에서 문자열을 나타내기 위해 MD5를 사용하도록 선택 (단, -extbinary 옵션과 함께 의미가 있음)'
# 'Choose underlying JIT kind.'
HCA7AB9E73E1E: '기반 JIT 유형을 선택하세요.'
# 'Chunksize to use by the OpenMP runtime calls'
H9BE7E3A1146E: 'OpenMP 런타임 호출에서 사용하는 Chunksize'
# "Clang permits use of type 'double' regardless pragma if 'cl_khr_fp64' is supported"
H36E837B04A86: "Clang은 'cl_khr_fp64'가 지원되는 경우, pragma를 무시하고 'double' 타입의 사용을 허용합니다."
# 'Clang-format options'
H5807AFA36D8E: 'Clang-format 옵션'
# 'ClangIR code gen Not Yet Implemented: %0'
HC54E3E6A2065: 'ClangIR 코드 생성 미구현: %0'
# 'ClangIR code gen Not Yet Implemented: %0: %1'
H56E1FD5A9575: 'ClangIR 코드 생성 미구현: %0: %1'
# 'ClangIR: Disable MLIR module verifier'
H751870E4D956: 'ClangIR: MLIR 모듈 검증기를 비활성화합니다.'
# 'Class definition format'
HDB879BF08A12: '클래스 정의 형식'
# 'Class recursion depth (0=no limit)'
HB9C55ABE5CC8: '클래스 재귀 깊이 (0=제한 없음)'
# 'Class sort order'
H85CBA379BBF6: '클래스 정렬 순서'
# 'Class, Structure or Union.'
H496FA9D4B718: '클래스, 구조체 또는 유니온입니다.'
# 'Class.'
H148765CD0A8E: '클래스.'
# 'Cleanup of TFRs/COPYs'
H9B2D2779E91B: 'TFRs/COPYs 정리'
# 'Clear call-used registers upon function return (AArch64/x86 only)'
H477A7A2C3A31: '함수 반환 시 호출에 사용된 레지스터를 지웁니다 (AArch64/x86 전용)'
# 'Clear the Clang AST before running backend code generation'
H25C2CBF7F396: '백엔드 코드 생성을 실행하기 전에 Clang AST를 지웁니다'
# 'Clearance between two register writes for inserting XOR to avoid partial register update'
H72C3AC434C02: '두 레지스터 쓰기 간의 간격: XOR 삽입을 통해 부분 레지스터 업데이트 방지용'
# 'Clone multicolor basic blocks but do not demote cross scopes'
H6C8216BC2E37: '다중색상 기본 블록을 복제하지만 교차 스코프 강등은 수행하지 않음'
# 'Coalesce copies (default=true)'
H8F39652946C0: '복사 병합 (기본값=true)'
# 'Coalesce copies by rescheduling (default=true)'
H0B50CD5328B9: '재정렬을 통해 복사본을 결합(기본값=true)'
# 'Coalesce copies on split edges (default=subtarget)'
H9B11258186AA: '분할된 엣지에서 복사본 결합 (기본값=subtarget)'
# 'Coalesce copies that span blocks (default=subtarget)'
H60E87F9D68CA: '블록을 넘는 복사들을 결합 (기본값=subtarget)'
# 'Code and read-only data relocatable, accessed PC-relative'
H7787A55DE1DB: '코드와 읽기 전용 데이터는 재배치 가능하며, PC 상대 접근'
# 'Code growth limit for address mode optimization'
H68CE7F106A6D: '주소 모드 최적화를 위한 코드 증가 한계'
# 'Code sinking'
H7049DF5F2CFA: '코드 싱킹'
# 'Code size'
H555486354DDF: '코드 크기'
# 'Code size and latency'
H66FA420C1EB1: '코드 크기 및 지연 시간'
# 'CodeGen (expected to match llc)'
HD2FDC55840F0: 'CodeGen (llc와 일치해야 함)'
# "Codegen optimization level (0, 1, 2 or 3, default = '2')"
H0604F43896B4: "코드 생성 최적화 수준 (0, 1, 2 또는 3, 기본값 = '2')"
# 'Collect access count histograms'
HEFDB6DB25681: '액세스 횟수 히스토그램 수집'
# 'Collect control flow of function'
HECF6D002A2F5: '함수의 제어 흐름 수집'
# 'Collect probability-driven block placement stats'
H3B3A74A7C1CA: '확률 기반 블록 배치 통계 수집'
# "Collect these seeds. Use empty for none or a comma-separated list of '"
H6FDC6608AD13: "이 시드를 수집하세요. 아무 것도 없을 경우 empty를 사용하거나 콤마(,)로 구분된 목록을 지정하세요: '"
# 'Collects information ahead of time for MC lowering'
H247A53130B24: 'MC 하향 변환을 위해 사전에 정보를 수집합니다'
# 'Color Options'
HF1A7AFA23440: '색상 옵션'
# 'Color for dot-cfg after elements'
HE6BC004D0C08: '요소 이후 dot-cfg에 사용할 색상'
# 'Color for dot-cfg before elements'
HCBAF257C085C: 'dot-cfg 요소 전의 색상'
# 'Color for dot-cfg common elements'
H49F473D0D7F3: 'dot-cfg 공통 요소의 색상'
# 'Colored disassembly of strings of hex bytes'
H4E6D0548B4D8: '16진수 바이트 문자열의 색상 분해'
# 'Combination of ropi and rwpi'
HFA6236DECFF7: 'ropi와 rwpi의 조합'
# 'Combine AArch64 MachineInstrs after legalization'
HD7E343321E16: '법적화 후 AArch64 머신 명령어 결합'
# 'Combine AArch64 machine instrs before legalization'
H4D22AAB36024: '합법화 전 AArch64 머신 명령어 결합'
# 'Combine AMDGPU machine instrs after legalization'
H2FD87CC8B39B: '정규화 후 AMDGPU 머신 명령어 결합'
# 'Combine AMDGPU machine instrs after regbankselect'
H372E81B03355: 'regbankselect 이후 AMDGPU 머신 명령어 결합'
# 'Combine AMDGPU machine instrs before legalization'
H6682D3768EA0: 'AMDGPU 머신 명령어를 정규화 이전에 결합합니다'
# 'Combine Mips machine instrs after legalization'
HA03CAB5DCA3D: '합성 Mips 기계 명령어를 Legalization 후 결합'
# 'Combine Mips machine instrs before legalization'
H7EFE7A48A439: '합법화 이전에 Mips 머신 인스트럭션 결합'
# 'Combine RISC-V MachineInstrs after legalization'
H4BDB10B3DC9C: '정합성 처리 후 RISC-V MachineInstrs 결합'
# 'Combine RISC-V machine instrs before legalization'
H358426A68073: 'RISC-V 머신 명령어를 합법화 단계 전에 결합합니다'
# 'Combine SPIRV machine instrs before legalization'
H7E2252FE6075: 'SPIRV 머신 명령어들을 합법화 이전에 결합'
# 'Combine ext and trunc to TBL'
H8DCB8DB3D191: 'ext와 trunc를 TBL로 결합합니다'
# 'Combine extends of AArch64 masked gather intrinsics'
HF9B54CB5AC6B: 'AArch64 마스킹된 gather 인트린스의 확장 결합'
# 'Combine interleaved loads into wide loads and shufflevector instructions'
HC7C7ED4923BB: '교차 로드를 넓은 로드와 shufflevector 명령문으로 결합합니다'
# 'Combine redundant instructions'
H6A7B591C5F01: '중복된 명령어를 결합합니다'
# 'Combine the label of the offset with the label of the pointer when doing pointer arithmetic.'
HB7BD5BAE0A94: '포인터 산술을 할 때 오프셋의 라벨을 포인터의 라벨과 결합합니다.'
# 'Combine the label of the pointer with the label of the data when loading from memory.'
H4B6E43BF4FF7: '메모리에서 데이터를 로드할 때 포인터의 라벨을 데이터의 라벨과 결합합니다.'
# 'Combine the label of the pointer with the label of the data when storing in memory.'
H66A9D747B5EF: '메모리에 저장할 때 포인터의 레이블과 데이터의 레이블을 결합하십시오.'
# 'Comma separated list of attribute names that are allowed to be seeded.'
H725610B9DAC4: '허용되는 속성 이름을逗号로 구분한 목록.'
# 'Comma separated list of debug counter skip and count'
H9FAFDA93ACE1: '콤마로 구분된 디버그 카운터 스킵 및 카운트 목록'
# 'Comma separated list of debug counter skip and count arguments'
H6FCA88B30FCF: '디버그 카운터 스킿 및 카운트 인수의 쉼표로 구분된 목록'
# 'Comma separated list of files containing a new line separated list of API symbols to ignore when extracting API information.'
H4521BA006280: '`,`로 구분된 파일들의 목록으로, 각 파일은 API 정보를 추출할 때 무시할 줄 바꿈으로 구분된 API 심볼 목록을 포함합니다.'
# 'Comma separated list of function names that are allowed to be seeded.'
HD18F456FDFD5: '시드될 수 있는 함수 이름의 쉼표로 구분된 목록.'
# 'Comma separated list of functions to replace with native, or all'
HFF9C64BB9821: '네이티브로 대체할 함수의 쉼표로 구분된 목록 또는 전체'
# 'Comma separated list of globs for white-listing gcc-compatible drivers that are safe to execute. Drivers matching any of these globs will be used to extract system includes. e.g. /usr/bin/**/clang-*,/path/to/repo/**/g++-*'
H454E7FBEF67B: 'gcc 호환 드라이버 중 안전하게 실행할 수 있는 드라이버를 허용 목록에 추가하기 위한 콤마로 구분된 글로브 목록. 이 글로브 중 하나라도 일치하는 드라이버는 시스템 인클루드를 추출하는 데 사용됩니다. 예: /usr/bin/**/clang-*,/path/to/repo/**/g++-*'
# 'Comma separated list of locations to filter actions from logging'
H089CBD249A00: '로깅에서 액션을 필터링하기 위한 위치 목록을 콤마로 구분하여 나열한 리스트'
# "Comma-separated list of comment prefixes to use from check file\n(defaults to 'COM,RUN'). Please avoid using this feature in\nLLVM's LIT-based test suites, which should be easier to\nmaintain if they all follow a consistent comment style. This\nfeature is meant for non-LIT test suites using FileCheck."
H40AA0BE08629: "체크 파일에서 사용할 주석 접두사의 콤마 구분 목록\n(기본값은 'COM,RUN'입니다). LLVM의 LIT 기반 테스트 스위트에서는 이 기능을 사용하지 않는 것을 권장합니다,\n모두 일관된 주석 스타일을 따르면 유지 관리가 더 쉬울 것입니다. 이 기능은 FileCheck를 사용하는 비-LIT 테스트 스위트를 위해 설계되었습니다."
# "Comma-separated list of globs describing the list of callbacks to output. Globs are processed in order of appearance. Globs with the '-' prefix remove callbacks from the set. e.g. '*,-Macro*'."
HB2EA0F3C4C38: "출력할 콜백 목록을 설명하는 globs의 콤마로 구분된 목록입니다. Globs는 등장한 순서대로 처리됩니다. '-' 접두사가 있는 globs는 셋에서 콜백을 제거합니다. 예: '*,-Macro*'."
# 'Comma-separated list of vectorizer passes. If not set we run the predefined pipeline.'
H5F9267E8F02A: '콤마로 구분된 벡터라이저 패스 목록. 설정되지 않으면 미리 정의된 파이프라인을 실행합니다.'
# 'Command line options to pass to the downstream compiler.'
H24FC3F9175A2: '다운스트림 컴파일러에 전달할 명령 줄 옵션.'
# 'Command to compile the bitcode (use with -compile-custom) (default: llc)'
H3748E1E74688: '비트코드 컴파일을 위한 명령어 (-compile-custom 옵션과 함께 사용) (기본값: llc)'
# 'Command to execute and then exit.'
H9D395E8BC35F: '실행 후 종료할 명령을 실행합니다.'
# 'Command to execute the bitcode (use with -run-custom) (default: simulate)'
H8B8E553AB463: '비트코드를 실행하는 명령어 ( -run-custom 옵션과 함께 사용) (기본값: simulate)'
# 'CommonOptionsParser: failed to parse command-line arguments. '
H6D048D13358D: 'CommonOptionsParser: 명령 줄 인수를 해석하는 데 실패했습니다. '
# 'Compare Options'
H10812CD37717: '비교 옵션'
# 'Compare all elements.'
HD1160DBAE7C6: '모든 요소를 비교합니다.'
# 'Compare bits 62 and 61 of address (TBI should be disabled)'
HC1881DEFBF5A: '주소의 62비트와 61비트를 비교 (TBI는 비활성화되어야 함)'
# 'Compare with the result of XPAC (requires Armv8.3-a)'
HBA5A269FECBF: 'XPAC의 결과와 비교 (Armv8.3-a가 필요함)'
# 'Compare with the result of XPACLRI'
HAAF036306B3E: 'XPACLRI의 결과와 비교합니다'
# 'Compilation YAML databases containing additional compilation information for .pdll files'
HE9807E72350C: '추가 컴파일 정보를 포함한 .pdll 파일용 컴파일 YAML 데이터베이스'
# 'Compilation YAML databases containing additional compilation information for .td files'
HFBD096AE492B: 'TD 파일을 위한 추가 컴파일 정보를 포함하는 컴파일 YAML 데이터베이스'
# 'Compilation format to use to serialize to cubin.'
HB1FF55993026: 'Cubin으로 직렬화하기 위해 사용할 컴파일 형식.'
# 'Compile CUDA code for both host and device (default). Has no effect on non-CUDA compilations.'
H77D43CB7BF77: 'CUDA 코드를 호스트와 디바이스 모두를 위해 컴파일합니다 (기본값). CUDA가 아닌 컴파일에는 영향을 미치지 않습니다.'
# 'Compile CUDA code for device only'
H15DCB9A13744: '장치 전용으로 CUDA 코드 컴파일'
# 'Compile CUDA code for host only. Has no effect on non-CUDA compilations.'
H0F42A4E8A53F: 'CUDA 코드를 호스트만을 위해 컴파일합니다. 비-CUDA 컴파일에는 영향을 주지 않습니다.'
# 'Compile HIP source to relocatable'
HDC4174A29E78: 'HIP 소스를 재배치 가능 파일로 컴파일'
# 'Compile SYCL code for device only'
HC13E70999744: '디바이스만을 위해 SYCL 코드를 컴파일합니다'
# 'Compile SYCL code for host only. Has no effect on non-SYCL compilations'
HEB697C17E8BD: '호스트만을 위해 SYCL 코드를 컴파일합니다. SYCL이 아닌 컴파일에는 영향을 주지 않습니다'
# "Compile all functions that don't use floating point as Mips 16"
H5CC84DC9C7B5: '플로팅 포인트를 사용하지 않는 모든 함수를 Mips 16으로 컴파일합니다.'
# 'Compile common globals like normal definitions'
HD71FBB30E436: '일반 정의와 같이 공통 글로벌 변수를 컴파일합니다'
# 'Compile for both the offloading host and device (default).'
H9A1D25E1163E: '오프로딩 호스트와 디바이스 모두를 대상으로 컴파일합니다(기본값).'
# 'Compile only'
H8E8E6B258925: '직접 컴파일만'
# 'Compile unit.'
HD0B9CF45B690: '번역 단위.'
# 'Compile with LLC'
H0F009B4F1879: 'LLC로 컴파일하세요'
# 'Compile with LLC with integrated assembler'
HEC7B02DFBAC4: 'LLC와 통합된 어셈블러를 사용하여 컴파일하십시오.'
# 'Compiler generated elements.'
HCD76E8AFE5EE: '컴파일러가 생성한 요소들.'
# 'Compiler runtime library to use'
H8A88FADF9B7C: '사용할 컴파일러 런타임 라이브러리'
# 'Compiler to use for DTLTO ThinLTO backend compilations.'
H870FEFEAA364: 'DTLTO ThinLTO 백엔드 컴파일에 사용할 컴파일러.'
# 'Complex Deinterleaving'
H7404ACD7E023: '복잡한 디인터리빙'
# 'Compress all sections when writing the profile (only meaningful for -extbinary)'
HCB671C4254BD: '프로파일을 작성할 때 모든 섹션을 압축합니다 (단, -extbinary와 함께 의미가 있음)'
# 'Compress offload device binaries (HIP only)'
H500BC9AF0B40: '장치 바이너리 압축 전송 (HIP만)'
# 'Compress output file when bundling.\n'
HFEA3EDE7947A: '번들링할 때 출력 파일을 압축합니다.\n'
# 'Compressing recursion by deduplicating adjacent frame sequences up to the specified size. -1 means no size limit.'
H30029AFB7F05: '지정된 크기까지 인접한 프레임 시퀀스의 중복을 제거하여 재귀를 압축합니다. -1은 크기 제한이 없다는 의미입니다.'
# 'Compression level for offload device binaries (HIP only)'
HAD420748A1D9: '오프로드 디바이스 바이너리용 압축 수준 (HIP만 해당)'
# 'Compute and report stale profile statistical metrics.'
H8415583C1A20: '오래된 프로파일의 통계 지표를 계산하고 보고합니다.'
# "Compute and store the hash of input files used to build an AST. Files with mismatching mtime's are considered valid if both contents is identical"
H9585117CC641: 'AST를 생성하는 데 사용된 입력 파일의 해시를 계산하고 저장합니다. 내용이 동일한 경우 불일치하는 mtime을 가진 파일도 유효한 것으로 간주됩니다'
# 'Compute dead symbols'
H06FD59310A4C: '사용되지 않은 심볼 계산'
# 'Compute known content of array elements'
HF867A4592891: '배열 요소의 알려진 내용 계산'
# 'Compute mean of all readings'
H8282EDF1CC14: '모든 측정값의 평균을 계산합니다'
# 'Compute stale profile statistical metrics and write it into the native object file(.llvm_stats section).'
H2211EA0D1BE2: '과기 profile 통계 메트릭을 계산하고 .llvm_stats 섹션에 있는 네이티브 오브젝트 파일에 작성합니다.'
# 'Compute the full inline cost of a call site even when the cost exceeds the threshold.'
HF635A2D8BE0B: '호출 위치의 전체 inline 비용을 계산합니다, 비용이 임계값을 초과하더라도.'
# 'Conditions to use when printing elements.'
H57BD843032A5: '요소를 출력할 때 사용하는 조건들.'
# 'Configure the polly loop optimizer'
H40019CBBC00E: 'Polly 루프 최적화기를 구성합니다'
# 'Connect to an out-of-process executor through a TCP socket'
H89D591EB992E: 'TCP 소켓을 통해 외부 프로세스 실행기와 연결합니다'
# 'Connect to an out-of-process executor via TCP'
H84FC6B32A5A3: 'TCP를 통해 외부 프로세스 실행기와 연결합니다'
# 'Consider R1 caller preserved so stack saves of caller preserved registers can be LICM candidates'
H7A2CC0A44257: '호출자 보존 R1을 고려하여 호출자 보존 레지스터의 스택 저장을 LICM 후보로 만들 수 있습니다'
# 'Consider a profile matches a function if the similarity of their callee sequences is above the specified percentile.'
HE02A66F58798: '프로필의 호출 시퀀스 유사도가 지정된 백분위수를 초과할 경우 해당 프로필을 함수와 일치시킵니다.'
# 'Consider all leaf descendants of internal nodes of the suffix tree as candidates for outlining (if false, only leaf children are considered)'
HCFBF788CDF8F: '접미사 트리의 내부 노드의 모든 잎 후손을 추출 후보로 고려합니다(거짓인 경우, 오직 잎 자식만이 고려됩니다)'
# 'Consider calls to be predicable'
HF4AE01562CCA: '호출을 예측 가능하다고 간주합니다'
# 'Constant Hoisting'
HA20E9E7B7D12: '상수 끌어올림'
# 'Constant specifier.'
H27C86387B88E: '상수 지정자.'
# 'Constant.'
H69328F1434C8: '상수입니다.'
# 'Context sensitive profile file path'
H6AAD89B511B3: '컨텍스트 감도형 프로파일 파일 경로'
# 'Contiguously Lay Out Funclets'
H35F4CF635E0B: 'Funclets를 연속적으로 레이아웃합니다'
# 'Continue if files are not mapped correctly.'
H0AB9362D475E: '파일이 올바르게 매핑되지 않았을 경우 계속합니다.'
# 'Control Flow Optimizer'
H072A594766A3: '제어 흐름 최적화기'
# 'Control conversion of memcpy to Tail predicated loops (WLSTP)'
HE778B3B33793: 'memcpy를 꼬리 조건부 루프(Tail predicated loops)로 변환 제어 (WLSTP)'
# 'Control emission of Swift async extended frame info'
H02D3442EBA23: 'Swift 비동기 확장 프레임 정보 방출 제어'
# "Control how the assembler should align branches with NOP. If the boundary's size is not 0, it should be a power of 2 and no less than 32. Branches will be aligned to prevent from being across or against the boundary of specified size. The default value 0 does not align branches."
H8B5A4A325A23: '어셈블러가 NOP로 브랜치를 정렬하는 방식을 제어합니다. 경계의 크기가 0이 아닌 경우, 해당 크기는 2의 거듭제곱이어야 하며 32 이상이어야 합니다. 브랜치는 지정된 크기의 경계를 넘어거나 역으로 정렬되지 않도록 정렬됩니다. 기본값 0은 브랜치를 정렬하지 않습니다.'
# 'Control jump table emission on Hexagon target'
H6602FAB1D723: 'Hexagon 타겟에서 점프 테이블 생성 제어'
# 'Control lookup table emission on Hexagon target'
HAAA735B3BA36: 'Hexagon 타겟의 제어 룩업 테이블 생성을 제어합니다'
# 'Control the CR-bit tracking feature on PowerPC. ``-mcrbits`` (the enablement of CR-bit tracking support) is the default for POWER8 and above, as well as for all other CPUs when optimization is applied (-O2 and above).'
H81C5A0E206B5: 'PowerPC에서 CR-bit 추적 기능을 제어합니다. ``-mcrbits``(CR-bit 추적 기능 활성화)는 POWER8 및 그 이상의 버전에서 기본 설정이며, 최적화(-O2 이상)가 적용될 때 다른 모든 CPU에서도 기본 설정입니다.'
# 'Control the amount of inlining in pre-instrumentation inliner (default = 75)'
H601514BCD01B: '측정 도구 삽입 전 인라인 단계에서의 인라인 양을 제어 (기본값 = 75)'
# 'Control the amount of inlining to perform (default = 225)'
H54F72241070E: '제어할 인라인 양을 조절합니다 (기본값 = 225)'
# 'Control the amount of phi node folding to perform (default = 2)'
H27887A938BFF: 'phi 노드 결합 양을 제어합니다 (기본값 = 2)'
# 'Control the maximal conditional load/store that we are willing to speculatively execute to eliminate conditional branch (default = 6)'
HEA5F4A80FEFE: '조건부 분기를 제거하기 위해 추론 실행할 최대 조건부 로드/스토어를 제어합니다 (기본값 = 6)'
# 'Control the maximal total instruction cost that we are willing to speculatively execute to fold a 2-entry PHI node into a select (default = 4)'
H57D2DDD9FD2C: '추측 실행을 통해 2개 항목 PHI 노드를 select로 접기 위해 허용할 최대 총 명령 비용을 제어합니다 (기본값 = 4)'
# 'Control the number of bonus instructions (default = 1)'
H7BC9F590620F: '보너스 명령어의 수를 제어 (기본값 = 1)'
# 'Control the rules which are enabled. These options all take a comma separated list of rules to disable and may be specified by number or number range (e.g. 1-10).'
H7704451C821B: '활성화된 규칙을 제어합니다. 이 옵션들은 비활성화할 규칙 목록을 쉼표로 구분된 목록으로 받을 수 있으며, 숫자나 숫자 범위(예: 1-10)로 지정할 수 있습니다.'
# 'Control the use of vectorisation using tail-folding for SVE where the option is specified in the form (Initial)[+(Flag1|Flag2|...)]:\ndisabled      (Initial) No loop types will vectorize using tail-folding\ndefault       (Initial) Uses the default tail-folding settings for the target CPU\nall           (Initial) All legal loop types will vectorize using tail-folding\nsimple        (Initial) Use tail-folding for simple loops (not reductions or recurrences)\nreductions    Use tail-folding for loops containing reductions\nnoreductions  Inverse of above\nrecurrences   Use tail-folding for loops containing fixed order recurrences\nnorecurrences Inverse of above\nreverse       Use tail-folding for loops requiring reversed predicates\nnoreverse     Inverse of above'
H48B9B6BA5047: 'SVE에서 tail-folding을 사용한 벡터화 사용을 제어할 때, 옵션이 (Initial)[+(Flag1|Flag2|...) 형식으로 지정됩니다:\ndisabled      (초기) tail-folding을 사용한 벡터화가 적용되지 않는 모든 루프 유형\ndefault       (초기) 대상 CPU의 기본 tail-folding 설정을 사용\nall           (초기) 모든 유효한 루프 유형에 tail-folding을 사용한 벡터화 적용\nsimple        (초기) reduction이나 recurrence가 아닌 단순 루프에 tail-folding 사용\nreductions    reduction이 있는 루프에 tail-folding 사용\nnoreductions  위와 반대(반duction 사용 안 함)\nrecurrences   고정 순서 recurrence가 있는 루프에 tail-folding 사용\nnorecurrences 위와 반대(고정 순서 recurrence 제외)\nreverse       역전된 예측자(reverse predicate)가 필요한 루프에 tail-folding 사용\nnoreverse     위와 반대(역전된 예측자 제외)'
# "Control use of approximate reciprocal and reciprocal square root instructions followed by <n> iterations of Newton-Raphson refinement. <value> = ( ['!'] ['vec-'] ('rcp'|'sqrt') [('h'|'s'|'d')] [':'<n>] ) | 'all' | 'default' | 'none'"
HC7E65C6B3833: "Newton-Raphson 방법의 <n> 회 반복을 거친 근사 역수 및 역제곱근 명령어 사용을 제어합니다. <value> = ( ['!'] ['vec-'] ('rcp'|'sqrt') [('h'|'s'|'d')] [':'<n>] ) | 'all' | 'default' | 'none'"
# 'Control vtordisp placement'
HE1318392829D: 'vtordisp 배치 제어'
# 'Control vtordisp placement on win32 targets'
H1B28D470DA9E: 'win32 타겟에서 vtordisp 배치 제어'
# "Control where files for distributed backends are created. Expects 'oldprefix;newprefix' and if path prefix of output file is oldprefix it will be replaced with newprefix."
HC0263D605A37: "분산 백엔드용 파일 생성 위치를 제어합니다. 옵션 값으로 'oldprefix;newprefix'를 기대하며, 출력 파일의 경로 접두사가 oldprefix인 경우 이를 newprefix로 대체합니다."
# 'Control whether the compiler can use scalable vectors to vectorize a loop'
H6A90BC2050A3: '컴파일러가 루프를 벡터화할 때 확장 가능한 벡터를 사용할 수 있는지 제어합니다'
# 'Control whether unstable and experimental library features are enabled. This option enables various library features that are either experimental (also known as TSes), or have been but are not stable yet in the selected Standard Library implementation. It is not recommended to use this option in production code, since neither ABI nor API stability are guaranteed. This is intended to provide a preview of features that will ship in the future for experimentation purposes'
H292802AB79DD: '불안정하거나 실험적인 라이브러리 기능을 활성화할지 여부를 제어합니다. 이 옵션은 선택된 표준 라이브러리 구현체에서 실험적(또는 TS(기술 스펙)로 알려진)이거나 아직 안정화되지 않은 다양한 라이브러리 기능을 활성화합니다. ABI 및 API의 안정성이 보장되지 않기 때문에 이 옵션은 생산 환경 코드에서 사용하지 않는 것이 좋습니다. 이는 미래에 출시될 기능을 미리 살펴보기 위한 실험 목적으로 제공되었습니다'
# 'Controls Negator transformations in InstCombine pass'
H08542ADEE520: 'InstCombine 패스에서 Negator 변환을 제어합니다'
# 'Controls how scalar integer arguments are extended in calls to unprototyped and varargs functions'
H7A8FE1AC1071: '프로토타입이 없는 함수와 가변 인수 함수 호출 시 스칼라 정수 인수의 확장 방식을 제어합니다'
# 'Controls if structs should be imported as literal structs, i.e., nameless structs.'
H2343CB68FB97: '구조체를 리터럴 구조체(즉, 이름 없는 구조체)로 가져올지 제어합니다.'
# 'Controls the backend parallelism of -flto=thin (default of 0 means the number of threads will be derived from the number of CPUs detected)'
H6966D13FD63C: 'Controls the backend parallelism of -flto=thin (default of 0 means the number of threads will be derived from the number of CPUs detected)'
# 'Controls the semantics of floating-point calculations.'
H71E38C97DF72: '부동 소수점 계산의 의미론을 제어합니다.'
# 'Controls transformations in div-rem-pairs pass'
HECF2FCF96025: 'div-rem-pairs 패스에서 변환을 제어합니다'
# 'Controls transformations in partially-inline-libcalls'
HD0E8FE10DABD: '부분적으로 인라인된 라이브러리 호출 내에서 변환을 제어합니다'
# 'Controls whether PPC per opcode peephole is performed on a MI'
HE5F923C4F31C: 'PPC opcode별 피히OLER 최적화가 MI에서 수행되는지 여부를 제어합니다'
# 'Controls whether PPC reg+reg to reg+imm peephole is performed on a MI'
HE845FFE9D736: '파워PC에서 reg+reg를 reg+imm 피ephole 최적화로 변환하는 MI에 적용되는지 여부를 제어합니다'
# 'Controls whether a DAG combine is performed for a node'
H093B59DCA1FC: '노드에 대해 DAG 결합이 수행되는지 제어합니다'
# 'Controls whether rewriteCandidateWithBasis is executed.'
H07C470C4B05C: 'rewriteCandidateWithBasis가 실행되는지 여부를 제어합니다.'
# 'Controls whether to select function with GlobalISel'
HBD7BF3862B9C: 'GlobalISel을 사용하여 함수를 선택하는지 제어합니다'
# 'Controls which MemoryDefs are eliminated.'
H791CB4538D1F: 'MemoryDefs 중 제거되는 항목을 제어합니다.'
# 'Controls which SLP graphs should be vectorized.'
H3651F2112EDB: '어떤 SLP 그래프를 벡터화할지 제어합니다.'
# 'Controls which assumes gets created'
HC60E96036F48: '어떤 assumes가 생성되는지 제어합니다'
# 'Controls which checks to insert'
H85AB8C69F0A9: '삽입할 검사 항목을 제어합니다'
# 'Controls which conditions are eliminated'
HCCAC8F989163: '어떤 조건들이 제거되는지 제어합니다'
# 'Controls which instruction to instrument'
HC782D790D691: '측정할 명령어를 지정합니다'
# 'Controls which instructions are eliminated'
H11684921476B: '실행 명령어 중 어떤 것을 제거할지 제어합니다'
# 'Controls which instructions are removed'
HAA6FE4D6ECC8: '삭제되는 명령문을 제어합니다'
# 'Controls which instructions are value numbered'
HB785D2555BC9: '어떤 명령문들이 값 번호 매김을 받는지 제어합니다'
# 'Controls which instructions are visited'
H636F2545BF3D: '어떤 명령어들이 방문되는지 제어합니다'
# 'Controls which instructions we create phi of ops for'
HE27BA11ED3BE: '어떤 지시문에 대해 phi 노드를 생성할지 제어합니다'
# 'Controls which pairs are considered for renaming'
HD4F491A48E58: '리네이밍을 위해 고려되는 페어들을 제어합니다'
# 'Controls which register COPYs are forwarded'
H3AAE7A42C897: '어떤 register COPY들이 전달되는지 제어합니다'
# 'Controls which tag collisions are avoided'
H425F30EA7D35: '태그 충돌을 피하는 방법을 제어합니다'
# 'Controls which variables C++ static destructors are registered for'
HBD9C8A005FBD: 'C++ 정적 소멸자가 등록되는 변수를 제어합니다'
# 'Controls which variables are renamed with predicateinfo'
H64B5B42BA3C1: 'predicateinfo를 사용하여 재명명되는 변수를 제어합니다'
# 'Conventional ABI instrumentation for sanitizer runtime. Default: Conventional'
HAE6876018E56: '샌타이저 런타임용 전통적인 ABI 인스트루먼테이션. 기본값: Conventional'
# 'Convert align attributes to assumptions during inlining.'
H3BBD1D4AD52A: '인라인 중 align 속성을 가정으로 변환합니다.'
# 'Convert all cmovs to branches.'
HC3FD80CE54EF: '모든 cmovs를 분기문으로 변환합니다.'
# 'Convert available_externally into locals, renaming them to avoid link-time clashes.'
H719EAE04A8AC: 'available_externally를 지역 변수로 변환하고, 연결 시 충돌을 피하기 위해 이름을 변경합니다.'
# 'Convert cmovs to branches whenever they have memory operands.'
HF77C545DF219: '메모리 오퍼랜드가 있는 경우 cmovs를 branches로 변환합니다.'
# 'Convert eligible reg+reg instructions to reg+imm'
HC9D049FFF42E: '적격된 reg+reg 명령문을 reg+imm로 변환합니다.'
# 'Convert i1 constants to i32/i64 if they are returned'
HB5295C482B89: '리턴되는 경우 i1 상수를 i32/i64로 변환합니다'
# 'Convert irreducible control-flow into natural loops'
HE7DC2EC0D50F: '분할할 수 없는 제어 흐름을 자연 루프로 변환'
# 'Convert noalias attributes to metadata during inlining.'
H693AF480BD18: '인라인 중에 noalias 속성을 메타데이터로 변환합니다.'
# 'Convert registers to WebAssembly locals'
H42DF7CAF4C71: '레지스터를 WebAssembly 로컬 변수로 변환합니다.'
# 'Convert switches into an integer range comparison (default = false)'
HDCDA8562FA9F: 'switches를 정수 범위 비교로 변환 (기본값 = false)'
# 'Convert switches to lookup tables (default = false)'
H5FE1320AA9A1: '스위치를 룩업 테이블로 변환 (기본값 = false)'
# 'Convert the generated profile to a profile with a new layout'
H7167152F0FAC: '생성된 프로필을 새로운 레이아웃을 가진 프로필로 변환합니다'
# 'Cost for first time use of callee-saved register.'
H378B86E985E0: 'callee-saved register의 첫 사용 비용'
# 'Cost multiplier to multiply onto inlined call sites where the new call was previously an intra-SCC call (not relevant when the original call was already intra-SCC). This can accumulate over multiple inlinings (e.g. if a call site already had a cost multiplier and one of its inlined calls was also subject to this, the inlined call would have the original multiplier multiplied by intra-scc-cost-multiplier). This is to prevent tons of inlining through a child SCC which can cause terrible compile times'
H698CAA7A18F5: '인라인된 호출 위치에 적용되는 비용 곱수입니다. 여기서 새로운 호출은 이전에 intra-SCC 호출이어야 합니다(원래 호출이 이미 intra-SCC였을 경우 적용되지 않습니다). 이것은 여러 번의 인라인 과정에서 누적될 수 있습니다(예: 호출 위치에 이미 비용 곱수가 있고, 그 중 하나의 인라인된 호출이 이 조건에 해당한다면, 해당 인라인된 호출은 원래 곱수에 intra-scc-cost-multiplier를 곱한 값이 됩니다).이는 자식 SCC를 통해 과도한 인라인을 방지하여 악화되는 컴파일 시간을 막기 위한 것입니다'
# 'Cost of a single instruction when inlining'
H036B559D08B8: '인라인 시 단일 명령의 비용'
# 'Cost of alloca argument'
HC1E9D60217AE: 'alloca 인자의 비용'
# 'Cost of jump instructions.'
H7ED2E2DD5641: '점프 명령문의 비용.'
# 'Cost of load/store instruction when inlining'
H4C8BA9CE961B: '인라인 시 로드/스토어 명령어의 비용'
# 'Cost penalty for blocks that can avoid breaking CFG by copying. Copying can increase fallthrough, but it also increases icache pressure. This parameter controls the penalty to account for that. Percent as integer.'
HC9F72F77D39D: '복사로 CFG를 깨지 않도록 할 수 있는 블록의 비용 패널티. 복사는 fallthrough를 증가시킬 수 있지만, 동시에 icache 압력을 증가시킵니다. 이 매개변수는 그에 대한 패널티를 조절합니다. 정수로 표시된 백분율.'
# 'Cost that models the probabilistic risk of an instruction misfetch due to a jump comparing to falling through, whose cost is zero.'
H84CCB8356D8E: '_BRANCH를 통해 넘어가는 경우에 비해_BRANCH 명령어 미페치(instruction misfetch)의 확률적 위험을 모델로 하는 비용, 여기서 기본 흐름(falling through)의 비용은 0입니다.'
# 'Costing strategy for intrinsic instructions'
H8D22576D5E28: '인트리니시크 명령어를 위한 비용 전략'
# 'Count statements with scalar accesses as not optimizable'
H20E33614C70B: '스칼라 액세스가 있는 문을 최적화할 수 없는 것으로 간주하여 세도록 합니다'
# 'Count the induction variable only once when interleaving'
HDCB004AC534E: '인터리빙 시 인도션 변수를 한 번만 세도록'
# 'Counts based on the value each specified argument has. The argument has to have a number value to be considered.'
HE174F4DEB8D5: '지정된 각 인자의 값에 기반하여 카운트합니다. 인자는 고려 대상이 되려면 숫자 값이 있어야 합니다.'
# 'Counts individual remarks based on how many of the remark exists.'
H16283CDE8F40: '주석의 존재 횟수에 따라 개별적인 주석을 세습니다.'
# 'Coverage executable or object file'
H2B8E5F52400C: '커버리지 실행 파일 또는 오브젝트 파일'
# 'Covered executable or object file.'
H20476C00EDC5: '포함된 실행 파일 또는 오브젝트 파일.'
# 'Create DLL'
H8F2F15C96BC4: 'DLL 생성'
# 'Create Garbage Collector Module Metadata'
H7493F37F2CB6: '가비지 컬렉터 모듈 메타데이터 생성'
# 'Create a copy of byval function arguments early.'
HFD4F400F3DC5: 'byval 함수 인수의 복사본을 조기 생성합니다.'
# 'Create a dot file of CFGs with block coverage inference information'
HEAFA159C65C9: '블록 커버리지 추론 정보가 있는 CFG의 dot 파일을 생성합니다'
# 'Create a table of coverage-instrumented PCs'
HE002CE3DC7B7: '커버리지 측정을 위한 액세스가 적용된 PC 테이블을 생성합니다'
# 'Create a website with graphical changes'
H01E9364CFCA0: '그래픽 변경 사항이 있는 웹사이트를 생성합니다'
# 'Create a website with graphical changes in quiet mode'
H70CA1F4FAB9C: 'Quiet 모드에서 그래픽 변경사항이 있는 웹사이트 생성'
# 'Create cfi directives that assume the code might be more than 2gb away'
H558862C2332B: '2GB 이상 떨어져 있을 수 있는 코드에 대한 cfi 디렉티브를 생성합니다'
# 'Create debug DLL'
H983B4E5552B9: '디버그 DLL 생성'
# 'Create empty files if bundles are missing when unbundling.\n'
H57F1E8EF31C0: '언번들링 시 번들이 누락된 경우 빈 파일을 생성합니다.\n'
# 'Create hotpatchable image'
HA0C5E8AB1DC6: '핫패치 가능한 이미지 생성'
# 'Create lane mask for data only, using active.lane.mask intrinsic'
HFF5BD5C1DCB1: '데이터만을 위한 레인 마스크 생성, active.lane.mask 내장 함수를 사용하여'
# 'Create lane mask using active.lane.mask intrinsic, and use it for both data and control flow'
H1B146FBA9B46: 'active.lane.mask intrinsic을 사용하여 레인 마스크를 생성하고, 이를 데이터 및 제어 흐름 모두에 사용합니다'
# 'Create lane mask with compare/stepvector'
HE51056AA8ABD: '비교/스텝벡터를 사용하여 레인 마스크 생성'
# 'Create phony target for each dependency (other than main file)'
H49C550B30EC3: '메인 파일을 제외한 각 의존성에 대해 가상 타겟을 생성합니다'
# 'Create pi-block nodes.'
H3DDF1DCDF3C3: 'pi-block 노드를 생성합니다.'
# 'Create redzones for byval arguments (extra copy required)'
HF6B190018549: 'byval 인수를 위한 레드존 생성 (추가 복사 필요)'
# 'Create unit-strided versions of loops'
H1EF207263F28: '루프의 단일 간격 버전 생성'
# "Creates .debug_names section, if the input binary doesn't have it already, for DWARF5 CU/TUs."
HFA262F88083F: '입력 이진 파일에 이미 존재하지 않는 경우, DWARF5 CU/TUs에 대해 .debug_names 섹션을 생성합니다.'
# 'Cross module exports (DEBUG_S_CROSSSCOPEEXPORTS subsection)'
HE827878921EC: '모듈 간 내보내기 (DEBUG_S_CROSSSCOPEEXPORTS 부분)'
# 'Cross module imports (DEBUG_S_CROSSSCOPEIMPORTS subsection)'
HE6104A2735AD: '교차 모듈 임포트 (DEBUG_S_CROSSSCOPEIMPORTS 부분)'
# 'Cull hazards on function boundaries'
HD35403A45243: '함수 경계에서 위험 요소 제거'
# 'Cull hazards on memory waits'
HF9A83C7746B5: '메모리 대기 상태의 위험 요소 제거'
# 'Cutoff for generating "extract" instructions'
HF67D76A2F279: 'Extract 명령어 생성을 위한 임계값'
# 'Cutoff percentages (times 10000) for generating detailed summary'
HF12B62925337: '상세 요약 생성을 위해 10000을 곱한 잘림 백분율'
# 'Cutoff value about how many symbols in profile symbol list will be used. This is very useful for performance debugging'
H866011BDFA50: '프로파일 심볼 목록에 사용될 심볼 수의 제한값입니다. 이 값은 성능 디버깅에 매우 유용합니다'
# 'Cycle Info Analysis'
HD7B2CE61522D: '사이클 정보 분석'
# 'DAG combiner enable load/<replace bytes>/store with a narrower store'
H7A381CB1EB04: 'DAG 결합기가 load/<replace bytes>/store를 더 좁은 저장 명령어로 대체하여 활성화합니다'
# 'DAG combiner enable merging multiple stores into a wider store'
H9B98909FAA22: 'DAG 결합기가 여러 스토어를 더 넓은 스토어로 병합 가능하도록 활성화'
# 'DAG combiner enable reducing the width of load/op/store sequence'
H56650D4975A5: 'DAG combiner는 load/op/store 시퀀스의 너비를 줄이는 기능을 활성화합니다'
# 'DAG combiner force override the narrowing profitable check when reducing the width of load/op/store sequences'
HA751CC58B87A: 'DAG 조합기는 로드/연산/스토어 시퀀스의 너비를 줄일 때 좁아지는 이익 검사를 강제로 무시합니다.'
# 'DAG combiner limit number of steps when searching DAG for predecessor nodes'
HEF62B0854706: 'DAG 결합기: 이전 노드를 찾을 때 DAG 탐색 단계 수 제한'
# 'DAG combiner may split indexing from loads'
HFB4258B46B3C: 'DAG 결합기는 로드에서 인덱싱을 분할할 수 있습니다'
# 'DEBUG/DEVELOPMENT OPTIONS'
H43B5FBE6C89C: '디버그/개발 옵션'
# "DEPRECATED: Filename defining the whitelist for imbuing the 'always instrument' XRay attribute."
HC9A9C6768A2E: "DEPRECATED: XRay '항상 측정' 속성을 부여하기 위한 화이트리스트를 정의하는 파일명."
# "DEPRECATED: Filename defining the whitelist for imbuing the 'never instrument' XRay attribute."
H640211D9F2F8: "DEPRECATED: 'never instrument' XRay 속성에 적용할 허용 목록을 정의하는 파일 이름."
# 'DRIVER OPTIONS'
H8F860C8326CF: '드라이버 옵션'
# 'DWARF'
HDD71DBDFB287: 'DWARF'
# 'DWARF debug sections compression type'
H91FF9BE5328B: 'DWARF 디버그 섹션의 압축 유형'
# 'DWARF-like CFI based exception handling'
HC32F13DA0A07: 'DWARF 유사 CFI 기반 예외 처리'
# 'DWO output filename'
H6E851EAFE0D8: 'DWO 출력 파일 이름'
# 'DXContainer Global Emitter'
H7800E8E1E097: 'DXContainer 전역 에미터'
# 'DXIL Array Flattener'
H8F82D482C158: 'DXIL 배열 평탄화기'
# 'DXIL CBuffer Access'
HD94C3B98AA6B: 'DXIL CBuffer 접근'
# 'DXIL Data Scalarization'
H8CA416EED877: 'DXIL 데이터 스칼라화'
# 'DXIL Finalize Linkage'
H674F973B6F8F: 'DXIL 링크 최종화'
# 'DXIL Forward Handle Accesses'
HC699E42DFEAE: 'DXIL 포워드 핸들 액세스'
# 'DXIL Intrinsic Expansion'
H92F9B358ADE0: 'DXIL 내장 확장'
# 'DXIL Legalizer'
HB4D0483DF9F7: 'DXIL 합법화기'
# 'DXIL Metadata Pretty Printer'
HF96947D33548: 'DXIL 메타데이터 예쁘게 출력기'
# 'DXIL Module Metadata analysis'
HA9F2740D603A: 'DXIL 모듈 메타데이터 분석'
# 'DXIL Op Lowering'
HEEFF9D70DBBF: 'DXIL 옵 강하'
# 'DXIL Post Optimization Validation'
H0D86A1C91B64: 'DXIL 최적화 후 검증'
# 'DXIL Prepare Module'
HF62B7360E273: 'DXIL 모듈 준비'
# 'DXIL Resource Access'
HF5E458A33121: 'DXIL 리소스 접근'
# 'DXIL Resource Binding Analysis'
HC92CD4D22E79: 'DXIL 리소스 바인딩 분석'
# 'DXIL Resource Implicit Binding'
H9C2D45B76116: 'DXIL 리소스 암시적 바인딩'
# 'DXIL Resource Type Analysis'
HF10ABCFBFE52: 'DXIL 자원 유형 분석'
# 'DXIL Resources Analysis'
HDA90852D3576: 'DXIL 리소스 분석'
# 'DXIL Root Signature Analysis'
HBF76A637272F: 'DXIL 루트 서명 분석'
# 'DXIL Shader Flag Analysis'
H7A214ED13A39: 'DXIL 셰이더 플래그 분석'
# 'DXIL Translate Metadata'
HF4C419C952DF: 'DXIL 메타데이터 변환'
# 'DXIL validator installation path'
H9657CC613141: 'DXIL 검증기 설치 경로'
# 'Darwin libsystem_m'
H91DFA86D618A: '다윈 libsystem_m'
# 'Data aggregation options'
H2670869C509A: '데이터 집계 옵션'
# 'Dbi Stream Options'
HD27A954F7342: 'Dbi 스트림 옵션'
# 'Dead Argument Elimination'
HA9265D7501D4: '사용되지 않는 인자 제거'
# 'Dead Argument Hacking (BUGPOINT USE ONLY; DO NOT USE)'
HDA7D75078335: '사용되지 않는 인자 해킹 (BUGPOINT 전용; 사용 금지)'
# 'Dead Code Elimination'
HF23F9DE62329: '사용되지 않는 코드 제거'
# 'Debug Variable Analysis'
H4B43DA399B8A: '디버그 변수 분석'
# 'Debug control MBBs that are scheduled'
HFA489B3CE974: '스케줄링된 MBB의 디버깅 제어'
# 'Debug control for aggressive anti-dep breaker'
HDCDB4687E0FE: '공격적인 안티-의존성 분리기 디버그 제어'
# 'Debug dumping for the orc-lazy JIT.'
HB541A1485401: 'orc-lazy JIT의 디버그 덤프'
# 'Debug func'
H4ECA9A2353F4: '디버그 함수'
# 'Debug information offset.'
H34EB3EE5B41D: '디버그 정보 오프셋.'
# 'Debug information tags.'
H2591856B760C: '디버그 정보 태그.'
# 'Debug line.'
HC0773DFAAF93: '디버그 라인.'
# 'Debug lines that are zero.'
H28A0CEC425F6: '0인 디버그 라인.'
# 'Debug location ranges.'
H40716F5089BC: '디버그 위치 범위.'
# 'Debug max inst'
H8671ED460AD3: '디버그 최대 명령'
# 'Debug min inst'
H10F353058E6B: '디버그 최소 명령'
# 'Debug option to outline greedily, without restriction that calculated benefit outweighs cost'
H173943EFDB58: '디버그 옵션으로, 계산된 이익이 비용을 초과해야 하는 제약 없이 탐욕스럽게 적용합니다'
# 'Debugify MIR before and Strip debug after each pass except those known to be unsafe when debug info is present'
H0F54403815FA: '디버그 정보가 존재할 때 위험하다 알려진 패스들을 제외하고, 각 패스 전 MIR를 디버그화하고, 각 패스 후 디버그를 제거합니다'
# 'Debugify MIR before, by checking and stripping the debug info after, each pass except those known to be unsafe when debug info is present'
HC24A7BC34E88: '디버그 정보가 존재할 때 안전하지 않은 것으로 알려진 것들을 제외한 모든 패스에서 각 패스 후에 디버그 정보를 확인하고 제거하여 MIR를 사전에 디버그화합니다'
# 'Decided the kind of output desired'
H734A5ED4813F: '원하는 출력 유형을 결정했습니다'
# 'Declare callbacks extern weak, and only call if non-null.'
H2C4EDA19C0CD: '콜백을 extern weak로 선언하고, null이 아닌 경우에만 호출하십시오.'
# 'Declare variables at top when emitting C/C++'
HB43A4E22EF20: 'C/C++를 생성할 때 변수를 상단에 선언하십시오'
# "Decreases 'x86-br-merging-base-cost' in cases that it is unlikely that all conditionals will be executed. For example for merging the conditionals (a == b && c > d), if its known that a == b is unlikely, then it is unlikely that if the conditionals are split both sides will be executed, so it may be desirable to decrease the instruction cost threshold. Set to -1 to never merge unlikely branches."
H63754944E6A3: 'x86-br-merging-base-cost 값을 조건문들이 모두 실행될 가능성이 낮은 경우에 줄입니다. 예를 들어 (a == b && c > d) 조건문을 병합할 때, a == b가 발생할 가능성이 낮다고 알려져 있다면, 조건문을 분할했을 때 양쪽이 실행될 가능성도 낮으므로, 명령어 비용 임계값을 낮추는 것이 바람직할 수 있습니다. -1로 설정하면 불확실한 분기문을 병합하지 않습니다.'
# 'Deduce sibling calls when unrolling function call stacks'
HDD364524269F: '함수 호출 스택을 펼칠 때 형제 호출을 추론합니다'
# 'Default (no attribute)'
H2C9C1DE32DAB: '기본값 (속성이 없음)'
# 'Default DWARF version to use, if a -g option caused DWARF debug info to be produced'
HFF353DB7A2F1: '사용할 기본 DWARF 버전, -g 옵션이 DWARF 디버그 정보를 생성할 경우'
# 'Default address minimization strategy'
H1000E773EFCF: '기본 주소 최소화 전략'
# 'Default alignment for loops'
HFA44E84983F7: '루프의 기본 정렬'
# 'Default amount of inlining to perform'
H05B97F3AF721: '인라인 수행의 기본 양'
# 'Default for platform'
H91B018E0FAE2: '플랫폼 기본값'
# 'Default for platform and JIT-kind'
H0675076F20CF: '플랫폼 및 JIT-종류의 기본값'
# 'Default max threads per block for kernel launch bounds for HIP'
HDE6E6DE6B0D5: '커널 런치 경계에 대한 HIP의 기본 블록당 최대 스레드 수'
# 'Default mispredict rate (initialized to 25%).'
HA90859109DC8: '기본 mispredict rate (초기값으로 25%로 설정됨).'
# 'Default register allocator'
HF2112AFDE4A0: '기본 레지스터 할당기'
# 'Default threshold (max size of unrolled loop), used in all but O3 optimizations'
H450E3D6B5565: '기본 임계값(언롤된 루프의 최대 크기), O3 최적화를 제외한 모든 최적화에서 사용됩니다'
# 'Default type visibility'
H7E06B3502FFA: '기본 유형 가시성'
# 'Defer host/device related diagnostic messages for CUDA/HIP'
HD7B0D94624F9: 'CUDA/HIP에 대한 호스트/디바이스 관련 진단 메시지를 연기합니다'
# "Define '__STDC__' to '1' in MSVC Compatibility mode"
HE12E4DC30513: "MSVC 호환 모드에서 '__STDC__'를 '1'로 정의하세요"
# 'Define <macro> to <value> (or 1 if <value> omitted)'
HC9C0FAB29C48: '매크로를 값으로 정의합니다 (값이 생략되면 1로 설정됨)'
# 'Define __STDC__'
H403D03CBAA5E: " '__STDC__'를 정의합니다"
# 'Define a value for a symbol'
HF0BE0602E7DD: '기호에 대한 값을 정의합니다'
# 'Define a variable to be used in capture patterns.'
H430D1D820ECC: '캡처 패턴에서 사용할 변수를 정의하세요.'
# 'Define custom MSan AndMask'
H293D08EE84D2: '사용자 지정 MSan AndMask 정의'
# 'Define custom MSan OriginBase'
H8FF05FDD24B0: '사용자 지정 MSan OriginBase를 정의하세요'
# 'Define custom MSan ShadowBase'
H936AD234A7BD: '사용자 정의 MSan ShadowBase 정의'
# 'Define custom MSan XorMask'
HE0448D308359: '사용자 정의 MSan XorMask 정의'
# 'Define macro'
H1A169BE8E69A: '매크로 정의'
# 'Define threshold for number of checks per debug location to force origin update.'
H97F94F0D6F64: '디버그 위치 당 체크 수의 임계값을 설정하여 원본 업데이트를 강제합니다.'
# 'Define where potential integer overflows in generated expressions should be tracked.'
H76CDAC079D12: '생성된 표현식에서 발생하는 잠재적인 정수 오버플로우를 추적할 위치를 지정합니다.'
# 'Defined the specified macros to their specified definition. The syntax is <macro>=<definition>'
H8B59655A675D: '지정된 매크로를 해당 정의로 정의합니다. 문법은 <macro>=<definition>입니다.'
# 'Defines a symbol to be an integer constant'
H876930F92D82: '기호를 정수 상수로 정의합니다'
# 'Defines the __DEPRECATED macro'
H49D43A572A26: '__DEPRECATED 매크로를 정의합니다'
# 'Delete specified Globals from Module'
HB4A9BA47E594: '지정된 Globals를 모듈에서 삭제합니다'
# 'Delinearize array access functions'
HA9C6C1714FE6: '배열 접근 함수의 선형화 해제'
# 'Delta passes to not run, separated by commas. By default, run all delta passes.'
H76B8D7EFA5BE: '실행하지 않을 델타 패스 목록은 쉼표로 구분해 입력합니다. 기본적으로는 모든 델타 패스를 실행합니다.'
# 'Delta passes to run, separated by commas. By default, run all delta passes.'
H192F0FF37D50: '실행할 Delta 패스를 쉼표로 구분합니다. 기본값으로는 모든 Delta 패스가 실행됩니다.'
# 'Demangle function names'
H0F5F6B77621B: '함수 이름 디맨글링'
# 'Demote catchswitch BBs only (for wasm EH)'
H0707EDF1B004: 'catchswitch BBs만 강등시킵니다 (wasm EH를 위한)'
# 'Dependence Analysis'
H1CE69C87EFED: '의존성 분석'
# 'Dependences should be simplified (yes/no)'
HFE9403DC8E00: '의존성이 단순화되어야 합니다 (예/아니오)'
# 'Dependency filename'
H48F0BFFD012C: '종속성 파일 이름'
# 'Deprecated (like /Og /Oi /Ot /Oy /Ob2); use /O2'
HC8F13BE3A9B1: '비추천됨(예: /Og /Oi /Ot /Oy /Ob2); 대신 /O2를 사용하십시오'
# 'Deprecated (like not passing /EH)'
HB203EF80F1D6: '비추천 (예: /EH를 전달하지 않는 경우와 유사)'
# 'Deprecated (set output file name); use /Fe or /Fe'
H43E83CDF9C2D: '사용 권장 중지됨 (출력 파일 이름 설정); /Fe 또는 /Fe를 사용하십시오'
# "Deprecated; use '-O3 -ffast-math -fstack-arrays' for the same behavior, or '-O3 -fstack-arrays' to enable only conforming optimizations"
H894A29167B0A: "사용 중지 예정; 동일한 동작을 위해서는 '-O3 -ffast-math -fstack-arrays'를 사용하거나, 표준 준수 최적화만 활성화하려면 '-O3 -fstack-arrays'를 사용하세요"
# "Deprecated; use '-O3 -ffast-math' for the same behavior, or '-O3' to enable only conforming optimizations"
H68FB98DB67B0: "사용 중지됨; 동일한 동작을 위해서는 '-O3 -ffast-math'를 사용하거나, 규격에 부합하는 최적화만 활성화하려면 '-O3'을 사용하십시오."
# 'Deprecated; use /EHsc'
H0521F1C5E495: '사용 중지 예정입니다; /EHsc 옵션을 사용하세요'
# 'Depth limit for finding address space through traversal'
HD8946F32E697: '순회를 통해 주소 공간을 찾는 데 사용되는 깊이 제한 값'
# 'Depth limit when simplifying vector instructions and their operands'
H77D06B036D51: '벡터 명령문 및 그들의 연산자를 간소화할 때의 깊이 제한'
# 'Deref attributes and metadata infer facts at definition only'
HA8F233351C69: 'Deref attributes 및 메타데이터는 정의 시에만 사실을 추론합니다'
# 'Details for each and every function'
HC3D59D83E7DB: '각 함수의 상세 정보'
# 'Detect Dead Lanes'
H72FCA4FFA4F4: '사용되지 않는 레인 감지'
# 'Detect and exploit reductions'
HE6789AB23B98: '리덕션을 감지하고 활용합니다'
# 'Detect parallelism'
H2FE6FC8C4E2A: '병렬성 탐지'
# 'Detect single entry single exit regions'
H9F71476F6AF4: '단일 진입 단일 출구 영역 감지'
# "Detect stack use after return if binary flag 'ASAN_OPTIONS=detect_stack_use_after_return' is set."
H52A7D51EA3C5: "바이너리 플래그 'ASAN_OPTIONS=detect_stack_use_after_return'이 설정되어 있으면 스택 사용 후 반환을 탐지합니다."
# 'Determine based on deployment target'
H73C787FF3B61: '배포 대상에 따라 결정합니다'
# 'Determine what attributes are manifested in the IR'
H535B6DB54DEC: 'IR에 나타나는 속성들을 결정합니다'
# 'Determine when the Swift async frame pointer should be set'
H0BCAA17B1F0F: 'Swift 비동기 프레임 포인터가何时何时에 설정되어야 하는지 결정합니다'
# 'Determines whether the optimizer honors parentheses when floating-point expressions are evaluated'
HD46386982C52: '최적화기가 부동소수점 표현식이 평가될 때 괄호를 존중하는지 여부를 결정합니다'
# 'Diagnostic ID mapping utility'
HC6CDFACE6E9C: '진단 ID 매핑 유틸리티'
# 'Diff Options'
H28F8A773273E: '차이 옵션'
# 'Directly create compilation output files. This may lead to incorrect incremental builds if the compiler crashes'
H2C3E48B98787: '컴파일 출력 파일을 직접 생성합니다. 만약 컴파일러가 크래시하면 잘못된 증분 빌드가 발생할 수 있습니다'
# 'Directories referenced in the debug information.'
HA9318D60737D: '디버그 정보에 참조된 디렉토리 목록'
# 'Directories to search for object files by build ID'
HC9E3A565BEEA: '빌드 ID로 오브젝트 파일을 찾기 위해 검색할 디렉토리'
# 'Directory for crash diagnostic files.'
H168FC0AAB4F7: 'crash 진단 파일의 디렉토리 경로'
# 'Directory for outputting generated files.'
H8BAEDDCD56DA: '생성된 파일을 출력하는 디렉토리.'
# 'Directory in which coverage information is written out'
HE36AE6B0A9D2: '커버리지 정보를 작성하는 디렉토리'
# 'Directory in which to emit symbol graphs.'
HD25DF8577F21: '기호 그래프를 생성하기 위한 디렉토리.'
# 'Directory of include files'
H4769C553D95E: '헤더 파일 디렉토리'
# 'Directory to dump module dependencies to'
H34B714818DA5: '모듈 의존성을 덤프하기 위한 디렉토리'
# "Directory to output dSYM's (if any) to"
H6E5284514F1A: 'dSYM 파일을 출력할 디렉토리(있을 경우)'
# 'Directory to store cached object files (must be user writable)'
HF3C59BF42111: '캐시된 오브젝트 파일을 저장할 디렉토리 (사용자에게 쓰기 가능해야 함)'
# 'Directory used as a base for relative coverage mapping paths'
H60985D18A905: '상대 커버리지 매핑 경로 기반 디렉토리'
# 'Disable BPF_ST (immediate store) insn'
HD28C63C4DB63: 'BPF_ST (즉시 저장) 명령 비활성화'
# 'Disable C++ access control'
H88EE329A1455: 'C++ 접근 제어 비활성화'
# 'Disable C++ builtin type char8_t'
HE8005A3ED4D9: 'C++ 내장 형식 char8_t 비활성화'
# 'Disable C++ builtin type wchar_t'
H2F081FBCFFCE: 'C++ 내장 형 wchar_t 비활성화'
# 'Disable C++ copy constructor elision'
H7BE31CDC2832: 'C++ 복사 생성자 생략 비활성화'
# 'Disable C++ static destructor registration'
H2B2B7EA1E24C: 'C++ static 소멸자 등록 비활성화'
# 'Disable C++14 sized global deallocation functions'
H31DC24E25DC3: 'C++14 크기 지정 전역 해제 함수를 비활성화합니다'
# 'Disable C++17 aligned allocation functions'
H45EDF7CE8D2D: 'C++17 정렬된 할당 함수 비활성화'
# 'Disable CHR for all functions'
HE1BB044E9400: '모든 함수에 대해 CHR 비활성화'
# 'Disable CIR transformations pipeline'
H0D1EAB308F4D: 'CIR 변환 파이프라인을 비활성화합니다'
# 'Disable CTR loops for PPC'
HFB1BF72E3D56: 'PPC에서 CTR 루프를 비활성화'
# 'Disable CUDA Warp Function'
HED60E177B610: 'CUDA 워프 함수 비활성화'
# 'Disable Codegen Prepare'
H9DF18DE3903B: '코드 생성 준비 비활성화'
# 'Disable ConstantHoisting'
HA432AE659D39: '상수 휀팅 비활성화'
# 'Disable Copy Propagation pass'
H6FAF844B65AE: '복사 전파 패스 비활성화'
# 'Disable Dealloc Return for Hexagon target'
HC23D9F3300FD: 'Hexagon 타겟에 대한 Dealloc Return 비활성화'
# 'Disable Early If-conversion'
H0D9C330086F8: '조기 if 변환 비활성화'
# 'Disable GC optimizations in CodeGenPrepare'
HFD8A99D7BFCD: 'CodeGenPrepare에서 GC 최적화를 비활성화합니다'
# 'Disable GNU style inline asm'
H1CF933954FC2: 'GNU 양식의 인라인 어셈블리 사용 안 함'
# 'Disable Hardware Loops for Hexagon target'
H783975C3C5DB: 'Hexagon 타겟의 하드웨어 루프 비활성화'
# 'Disable Hexagon Addressing Mode Optimization'
H071B2E4C0FD8: 'Hexagon 주소 모드 최적화 비활성화'
# 'Disable Hexagon CFG Optimization'
HEF36B4E6BB85: 'Hexagon CFG 최적화를 비활성화'
# 'Disable Hexagon HVX IEEE floating-point'
H506C4D61FBA6: 'Hexagon HVX IEEE 부동 소수점 비활성화'
# 'Disable Hexagon HVX QFloat instructions'
HF256A44FD3F5: 'Hexagon HVX QFloat 명령어를 비활성화합니다'
# 'Disable Hexagon MI Scheduling'
HA39B5931FB8D: 'Hexagon MI 스케줄링을 비활성화'
# 'Disable Hexagon Vector eXtensions'
HDECA543F8233: 'Hexagon 벡터 확장 비활성화'
# 'Disable Hexagon constant propagation'
HED97EBD49929: 'Hexagon 상수 전파를 비활성화'
# 'Disable Hexagon instruction shuffling'
HC9709908CDDF: 'Hexagon 명령어 재정렬을 비활성화합니다'
# 'Disable Hexagon loop alignment pass'
HCE964D02A0A9: 'Hexagon 루프 정렬 패스 비활성화'
# 'Disable Hexagon packetizer pass'
HCB5AE1AB8542: 'Hexagon 패킷IZER 패스 비활성화'
# 'Disable Hexagon specific Mask generation pass'
H8E1C9C7C8EC3: 'Hexagon 고유 마스크 생성 패스를 비활성화합니다'
# 'Disable JIT lazy compilation'
H24C8D24310DC: 'JIT 지연 컴파일을 비활성화합니다'
# 'Disable LTO mode (default)'
H508DDA148F38: 'LTO 모드 비활성화 (기본값)'
# 'Disable LTO mode (default) for offload compilation'
H7985601FAE0D: '오프로드 컴파일을 위해 LTO 모드 (기본값)을 비활성화합니다'
# 'Disable Linear Function Test Replace optimization'
HA3DA3179BF69: '리니어 함수 테스트 대체 최적화를 비활성화합니다'
# 'Disable Loongson Advanced SIMD Extension (LASX).'
HEC68A6D43B64: 'Loongson 고급 SIMD 확장(LASX) 비활성화합니다.'
# 'Disable Loongson SIMD Extension (LSX).'
H51EB682DB218: 'Loongson SIMD 확장(LSX) 비활성화'
# 'Disable Loop Idiom Vectorize Pass.'
HCD6AF30D16E4: 'Loop Idiom Vectorize Pass를 비활성화합니다.'
# 'Disable Loop Strength Reduction Pass'
HFDE52CD02ECB: '루프 강도 감소 패스 비활성화'
# 'Disable MC/DC coverage criteria'
H5A71DE0EA17B: 'MC/DC 커버리지 기준을 비활성화합니다'
# 'Disable MIRProfileLoader before BlockPlacement'
H7119CF48A829: 'BlockPlacement 이전에 MIRProfileLoader를 비활성화하십시오'
# 'Disable MIRProfileLoader before RegAlloc'
HCEBEE56EAD41: 'RegAlloc 이전에 MIRProfileLoader를 비활성화하세요'
# 'Disable MSA ASE (MIPS only)'
H771BF5C8F84F: 'MSA ASE 비활성화 (MIPS 전용)'
# 'Disable MT ASE (MIPS only)'
H1B6CF37939E2: 'MT ASE 비활성화 (MIPS 전용)'
# 'Disable Machine Common Subexpression Elimination'
H600985BEDBBF: '머신 공통 하위 표현 제거를 비활성화합니다'
# 'Disable Machine Dead Code Elimination'
H436919B5DD6D: '머신 사소 코드 제거를 비활성화합니다'
# 'Disable Machine LICM'
HCA4B000FCB0F: '머신 LICM 비활성화'
# 'Disable Machine Sinking'
H84436D44017D: '머신 싱킹 비활성화'
# 'Disable MergeICmps Pass'
H127BD98A6338: 'MergeICmps 패스 비활성화'
# 'Disable New Value Jumps'
H3397AA24247F: '새 값 점프 비활성화'
# 'Disable ODR indicator globals'
H2F9A01FFB645: 'ODR 표시 글로벌 비활성화'
# 'Disable OpenMP optimizations involving SPMD-ization.'
HAF8239BD178C: 'SPMD화를 포함한 OpenMP 최적화를 비활성화합니다.'
# 'Disable OpenMP optimizations involving deglobalization.'
H74B4ADA2F47B: '디글로벌화를 포함한 OpenMP 최적화를 비활성화합니다.'
# 'Disable OpenMP optimizations involving folding.'
HBD10CEF55EEF: 'OpenMP에서 폴딩을 포함한 최적화를 비활성화합니다.'
# 'Disable OpenMP optimizations that eliminate barriers.'
H5C4E1057F8BD: '장벽을 제거하는 OpenMP 최적화를 비활성화합니다.'
# 'Disable OpenMP optimizations that replace the state machine.'
HC78F7C4114D3: 'OpenMP에서 상태 머신을 대체하는 최적화를 비활성화합니다.'
# 'Disable OpenMP specific optimizations.'
HA40A50850068: 'OpenMP 특정 최적화를 비활성화합니다.'
# 'Disable OpenMP support'
HFCB159BB2AD0: 'OpenMP 지원을 비활성화합니다'
# 'Disable Optimization of PNotP'
HE9DF380BE58C: 'PNotP 최적화 비활성화'
# 'Disable Optimization of Sign/Zero Extends'
H821C42065D98: '부호/제로 확장 최적화 비활성화'
# 'Disable Optimization of extensions to i64.'
HD38C1BE50891: 'i64 확장의 최적화를 비활성화합니다.'
# 'Disable PPC loop instr form prep'
H8547684E746B: 'PPC 루프 명령어 형식 준비를 비활성화'
# 'Disable Partial Libcall Inlining'
HDD48CA4D7B3E: '부분 Libcall 인라인화 비활성화'
# 'Disable Peephole Optimization'
H6E6615A7A740: 'peephole 최적화를 비활성화합니다'
# 'Disable Post Regalloc Scheduler'
HD739F0016551: '포스트 레게일로우 스케줄러 비활성화'
# 'Disable PostRA Machine Sinking'
HBB5CB09CF7E3: 'RA 후 머신 싱킹 비활성화'
# 'Disable SVR4-style position-independent code (Mips only)'
HA6D44538AD07: 'SVR4 방식의 위치 독립 코드를 비활성화 (Mips 전용)'
# 'Disable SYCL C++ extensions'
H66EB15B22DDA: 'SYCL C++ 확장 기능 비활성화'
# 'Disable Sparc leaf procedure optimization.'
H4EAE17DB87E5: '스파크 리프 프로시저 최적화를 비활성화합니다.'
# 'Disable Stack Slot Coloring'
HC67B1F734851: '스택 슬롯 색칠을 비활성화'
# 'Disable Trap Unreachable for BPF'
HAE15965950D8: 'BPF용 Trap Unreachable 비활성화'
# 'Disable V8+ mode'
HF617D77F2415: 'V8+ 모드를 비활성화합니다'
# 'Disable VSX FMA instruction mutation'
HEA8BD8C0F7FD: 'VSX FMA 명령어 변환을 비활성화'
# 'Disable VSX Swap Removal for PPC'
H5BF6CF30BC27: 'PPC용 VSX 교환 제거 비활성화'
# 'Disable Value Profiling'
H0CA8694E7036: '값 프로파일링을 비활성화합니다'
# 'Disable XMM8-XMM15 register usage'
H1FBE9270DAE0: 'XMM8-XMM15 레지스터 사용을 비활성화'
# 'Disable adding the optnone attribute to functions at O0'
H7B7D0B68A353: 'O0에서 함수에 optnone 속성 추가를 비활성화합니다'
# 'Disable advance peeling. Issues for convergent targets (D134803).'
H96D4946929C2: '고급 피닝을 비활성화합니다. convergent targets에 대한 문제가 있습니다 (D134803).'
# 'Disable advanced copy optimization'
H450999EB2A6C: '고급 복사 최적화 비활성화'
# 'Disable aliasing mode in HWAddressSanitizer'
HDA55D81C7ABD: 'HWAddressSanitizer의 aliasing 모드를 비활성화합니다'
# 'Disable all Clang extensions for OpenMP directives and clauses'
HAECEE0FE6723: 'Clang의 OpenMP 지시문과 절에 대한 모든 확장 기능을 비활성화합니다'
# 'Disable all options'
H2FCF77933240: '모든 옵션을 비활성화합니다.'
# 'Disable all outlining'
H452D85B48206: '모든 아웃라인 비활성화'
# 'Disable all rules in the '
H96795369E1EA: '해당의 모든 규칙을 비활성화합니다'
# 'Disable all static analyzer checks'
H8DC2486B7F10: '모든 정적 분석기 검사 비활성화'
# 'Disable all vector combine transforms'
H63388692148E: '모든 벡터 결합 변환을 비활성화합니다'
# 'Disable all warnings'
H113C54A4E2E2: '모든 경고를 비활성화합니다.'
# 'Disable amcas[_db].{b/h/w/d}'
H4094C4B64BFB: 'amcas[_db].{b/h/w/d} 비활성화'
# 'Disable amswap[_db].{b/h} and amadd[_db].{b/h}'
HF02B3FF824A2: 'amswap[_db].{b/h} 및 amadd[_db].{b/h} 비활성화'
# 'Disable analysis for CTR loops'
H4E1A550B8424: 'CTR 루프의 분석을 비활성화합니다'
# 'Disable analyzing function argument and return types for mandatory definedness'
H035F5FA49F38: '함수 인자 및 리턴 타입에 대한 필수 정의 여부 분석을 비활성화합니다'
# 'Disable annotate table jump instruction to correlate it with the jump table.'
HE3C86797416A: '점프 테이블 명령어에 주석을 달지 않도록 비활성화하여 점프 테이블과의 상관관계를 맞춥니다.'
# 'Disable any #pragma clang __debug that can lead to crashing behavior. This is meant for testing.'
H22EE3114285C: '파괴적인 동작을 유발할 수 있는 모든 #pragma clang __debug를 비활성화합니다. 이 기능은 테스트를 위해 고안되었습니다.'
# 'Disable atomic operations instrumentation in ThreadSanitizer'
H436F5749CCF4: 'ThreadSanitizer의 원자 연산 모니터링을 비활성화합니다'
# 'Disable atomic optimizer'
H91DDEC6A5CA5: '원자적 최적화를 비활성화합니다'
# 'Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash'
HCBAE420C8090: 'clang 크래시 중 전처리된 소스 파일과 재현을 위한 스크립트의 자동 생성을 비활성화합니다'
# 'Disable automatic bitcode upgrade for version mismatch'
H5A3DEE200EB5: '버전 불일치로 인한 자동 비트코드 업그레이드를 비활성화합니다'
# 'Disable autoupgrade of debug info'
HC2D0BCF7F57C: '디버그 정보 자동 업그레이드 비활성화'
# 'Disable backend optimizations'
HB773D8B41328: '백엔드 최적화 비활성화'
# 'Disable binop extract to shuffle transforms'
H6FB234E00070: '셔플 변환으로의 binop 추출을 비활성화'
# 'Disable block signature string)'
H0B1A3707BF42: '블록 서명 문자열 비활성화)'
# 'Disable both standard system #include directories and builtin #include directories'
H7E21F38033ED: '표준 시스템 #include 디렉토리와 내장 #include 디렉토리를 모두 비활성화합니다'
# 'Disable branch folding'
HF6094945EF27: '분기 접기를 비활성화'
# 'Disable branch optimizations in CodeGenPrepare'
H9E934B1894F9: 'CodeGenPrepare에서 분기 최적화를 비활성화합니다.'
# 'Disable bswap insns'
HEC30AD38E748: 'bswap 명령어 비활성화'
# 'Disable buffer security check'
H8BA30D52B9A7: '버퍼 보안 검사를 비활성화합니다'
# 'Disable builtin #include directories only'
HF9A61F76A5C0: '내장된 #include 디렉토리만 비활성화'
# 'Disable calling convention lowering pass'
H9858ACECE04B: '호출 규약 변환 패스 비활성화'
# 'Disable caret diagnostics but keep column info'
H597AC3D9E291: 'caret 진단을 비활성화하지만 열 정보는 유지합니다'
# 'Disable char8_t from c++2a'
H5E206E934042: 'C++2a에서 char8_t 비활성화'
# 'Disable checking of constexpr function bodies for validity within a constant expression context'
H6ABC0DD0EC14: 'constexpr 함수 본체의 상수 표현식 컨텍스트 내 유효성 검사를 비활성화합니다'
# 'Disable checks that try to statically verify validity of delinearized subscripts. Enabling this option may result in incorrect dependence vectors for languages that allow the subscript of one dimension to underflow or overflow into another dimension.'
H5CACAB20797B: '비선형화된 서브스크립트의 유효성을 정적 검증을 시도하는 검사들을 비활성화합니다. 이 옵션을 활성화하면 차원의 하나의 서브스크립트가 다른 차원으로 underflow하거나 overflow를 허용하는 언어에서 잘못된 종속성 벡터가 발생할 수 있습니다.'
# 'Disable clustered low occupancy rescheduling for ILP scheduling stage.'
HA583E3ADAB6E: 'ILP 스케줄링 단계에 대한 클러스터링 저 점유율 재일정화를 비활성화합니다.'
# 'Disable code coverage analysis'
H7E958EA264B1: '코드 커버리지 분석을 비활성화합니다'
# "Disable codegen and compile-time checks for C++23's [[assume]] attribute"
H8CC8CAFE3A4B: 'C++23의 [[assume]] 속성에 대한 코드 생성 및 컴파일 타임 검사 비활성화'
# 'Disable codegen data for function merging. Local merging is still enabled within a module.'
HA6F585942D4A: '함수 결합을 위한 코드 생성 데이터를 비활성화합니다. 모듈 내에서의 로컬 결합은 여전히 활성화됩니다.'
# 'Disable colors in diagnostics'
HDC4DB95966A6: '진단 메시지에서 색상을 비활성화'
# 'Disable column and caret diagnostics'
H66ABD4DABB22: '열과 캐럿 진단을 비활성화'
# 'Disable combining of interleaved loads'
HDC89DC5720AF: '인터리브된 로드의 결합을 비활성화합니다'
# 'Disable command line arguments round-trip.'
H529251337527: '명령 줄 인수의 반환 경로를 비활성화합니다.'
# 'Disable compare instruction optimization'
HCA46CE080B75: '비교 명령 최적화 비활성화'
# 'Disable constant-folding of FP intrinsics and libcalls.'
HFF24E246DB9A: 'FP 내장 함수 및 라이브러리 호출의 상수 폴딩을 비활성화합니다.'
# 'Disable control flow integrity (CFI) checks for cross-DSO calls.'
HBA298571E50D: '크로스-DSO 호출에 대한 제어 흐름 무결성(CFI) 검사를 비활성화합니다.'
# 'Disable control-flow mitigations for Load Value Injection (LVI)'
HC84915AF941B: '로드 값 주입(LVI)에 대한 제어 흐름 완화를 비활성화합니다'
# 'Disable convert to D suffix'
HEE0A84D95394: 'D 접미사 변환을 비활성화합니다'
# 'Disable coverage pruning (i.e. instrument all blocks/edges)'
HF9991A3D9D32: '커버리지 정리 비활성화(즉, 모든 블록/엣지에 인스트루먼트 적용)'
# 'Disable creation of CodeFoundation-type constant strings'
H8A3AF608A73D: 'CodeFoundation 형식의 상수 문자열 생성을 비활성화합니다'
# 'Disable critical edge splitting during PHI elimination'
HF87FC46C993D: 'PHI 제거 중 중요 엣지 분할을 비활성화'
# 'Disable critical path priority in sched=list-ilp'
H2CD6F07C5299: 'sched=list-ilp에서 크리티컬 경로 우선순위를 비활성화합니다'
# 'Disable custom behaviour (use the default class which does nothing).'
HDD6103F48106: '커스텀 동작을 비활성화합니다(기본 클래스를 사용하며 아무 동작도 수행하지 않습니다).'
# 'Disable cycle-level precision during preRA scheduling'
HF9826B2C9560: 'pre-RA 스케줄링 중 클럭 사이클 단위 정밀도 비활성화'
# 'Disable delayed template parsing'
H78E92B7DA979: '지연된 템플릿 파싱 비활성화'
# 'Disable detection of uninitialized parameters and return values'
H58D5476F7351: '초기화되지 않은 매개변수와 반환 값 탐지를 비활성화합니다'
# 'Disable diagnostic notes.'
HC94928475428: '진단 참고 메시지를 비활성화합니다.'
# 'Disable direct TLS access through segment registers'
H458A3D5DF9C8: '세그먼트 레지스터를 통해 직접 TLS 접근을 비활성화합니다'
# 'Disable elimination of dead PHI nodes.'
HC1471E3BABD6: '사망 PHI 노드의 제거를 비활성화합니다.'
# 'Disable emission .debug_ranges section.'
H8261A262490A: '디버그 레인지를 포함하는 섹션(.debug_ranges)을 비활성화합니다.'
# 'Disable emission of core files if possible'
H5CA16DE0180D: '가능한 경우 코어 파일 생성을 비활성화합니다'
# 'Disable emission of the extended flags in .loc directives.'
HC16B51206891: '.loc 지시문에서 확장 플래그의 생성을 비활성화합니다.'
# 'Disable emitting complete constructors and destructors as aliases when possible'
H4E4DBEA88413: '가능한 경우 완전한 생성자와 소멸자를 별칭으로 생성하지 않도록 금지'
# 'Disable emitting metadata for binary analysis sanitizers'
H9438B3F5F3E7: '바이너리 분석 정화 도구용 메타데이터 생성을 비활성화합니다'
# 'Disable experimental bounds safety extension for C'
H949767942150: 'C에 대한 실험적 경계 안전 확장 기능을 비활성화합니다'
# 'Disable experimental late parsing of attributes'
HAEA82819E6DD: '실험적인 속성의 늦은 분석을 비활성화합니다'
# 'Disable ext(promotable(ld)) -> promoted(ext(ld)) optimization in CodeGenPrepare'
HFA8DE3453A19: 'CodeGenPrepare에서 ext(promotable(ld)) -> promoted(ext(ld)) 최적화를 비활성화합니다'
# 'Disable external API notes support'
H4877A26CE44B: '외부 API 노트 지원을 비활성화합니다'
# 'Disable fat LTO object support'
HECD714B1BF31: '비만 LTO 오브젝트 지원을 비활성화합니다'
# 'Disable features of APX'
H69A07C7EF30D: 'APX 기능을 비활성화합니다'
# 'Disable features of coverage instrumentation for Sanitizers'
H0B74A3F5C9BC: 'Sanitizers용 커버리지 인스트루먼테이션 기능을 비활성화합니다'
# 'Disable fixed point types'
H9D07DD6F2288: '고정 소수점 형식 비활성화'
# 'Disable fixing up resolved relocations for Hexagon'
H2F59DE7595A3: 'Hexagon에서 해결된 재정의 위치를 수정하는 기능을 비활성화합니다'
# 'Disable frame pointer elimination'
H163B87ED062D: '프레임 포인터 제거를 비활성화합니다'
# 'Disable frame pointer elimination for non-leaf frame'
HAF65627719BE: '비리프 프레임에 대해 프레임 포인터 제거를 비활성화합니다'
# 'Disable frame pointer omission (x86 only, default)'
H1E0AE27D951E: '프레임 포인터 생략을 비활성화 (x86 전용, 기본값)'
# 'Disable frecipe.{s/d} and frsqrte.{s/d}'
H62E54664CC80: '비활성화 frecipe.{s/d}와 frsqrte.{s/d}'
# 'Disable freeing of memory on exit'
HF1F277AF14E7: '종료 시 메모리 해제 비활성화'
# 'Disable function entry/exit instrumentation in ThreadSanitizer'
H1351B571C7D6: 'ThreadSanitizer에서 함수 진입/퇴장 인스트루먼트를 비활성화합니다'
# 'Disable function inlining'
H5A7ECCE87EED: '인라인 함수 비활성화'
# 'Disable function internalization.'
H8C418ABB3A74: '함수 내부화를 비활성화합니다.'
# 'Disable function multiversioning'
H1ECFC327C1B3: '함수 다중 버전화 비활성화'
# 'Disable function outlining (AArch64 only)'
H3491F6797D9A: '함수 아웃라인 기능을 비활성화합니다 (AArch64 전용)'
# 'Disable fusing of spill code into instructions'
H7DEB69686DC1: 'spill 코드를 지시문에 융합하는 것을 비활성화합니다'
# 'Disable generation of RTTI data'
H41B72E945CBF: 'RTTI 데이터 생성을 비활성화합니다'
# 'Disable generation of const64'
HE3959EA50320: 'const64 생성을 비활성화합니다'
# 'Disable generation of discriminator information.'
HC17557FCC17F: '구분자 정보 생성을 비활성화합니다.'
# 'Disable generation of gather instructions in auto-vectorization(x86 only)'
H983AEC35DB6E: '자동 벡터화에서 가져오기 명령어의 생성을 비활성화합니다 (x86 전용)'
# 'Disable generation of instruction packets'
H1BEE193809E5: '명령어 패킷 생성을 비활성화합니다'
# 'Disable generation of linker directives for automatic library linking'
HD9086365BC76: '자동 라이브러리 링크를 위한 린커 지시문의 생성을 비활성화합니다'
# 'Disable generation of memcpy in loop idiom recognition'
H75B5FDDE583A: '루프 아이디엄 인식 시 memcpy 생성 비활성화'
# 'Disable generation of memmove in loop idiom recognition'
HBDF5135E8486: '루프 아이디어 인식에서 memmove 생성 비활성화'
# 'Disable generation of memop instructions'
H58306072EDD8: 'memop 명령어 생성을 비활성화합니다'
# 'Disable generation of new-value jumps'
H7CFC8831E9E7: '새 값 점프 생성 비활성화'
# 'Disable generation of new-value stores'
HD912422CF388: '새 값 저장 생성을 비활성화합니다'
# 'Disable generation of profile instrumentation.'
H91EE299476D4: '프로파일 인스트루먼테이션 생성을 비활성화합니다.'
# 'Disable generation of rtti information'
HD27D5DABC1FC: 'rtti 정보 생성을 비활성화합니다'
# 'Disable generation of scatter instructions in auto-vectorization(x86 only)'
HE3E5F2C6BEE2: '자동 벡터화(x86 전용)에서 스캐터 명령어의 생성을 비활성화합니다'
# 'Disable global outlining only by ignoring the codegen data generation or use'
H9030F85E3C32: '전역 개략화를 비활성화하려면 코드 생성 데이터 생성 또는 사용을 무시하라'
# 'Disable gotol insn'
HA056175A68C0: 'gotol 명령어를 비활성화합니다'
# 'Disable hazard detection during preRA scheduling'
H42E4A02F5152: 'preRA 스케줄링 중 해저드 탐지를 비활성화합니다'
# 'Disable header insertions'
H11A783969925: '헤더 삽입 비활성화'
# 'Disable header removals'
H0705FC99009C: '헤더 제거 비활성화'
# 'Disable heap memory profiling'
HD2AF1D7462E3: '힙 메모리 프로파일링 비활성화'
# 'Disable hoisting instructions to hotter blocks'
HECAA5605738C: '더 뜨거운 블록으로의 지시문 호이스팅을 비활성화합니다'
# 'Disable identical code folding (default)'
H2724011BEF3B: '동일 코드 접기를 비활성화 (기본값)'
# 'Disable implicit addition of a top-level module op during parsing'
H38ED3CECF1BE: '파싱 중 상위 레벨 모듈 오퍼레이션에 대한 암시적 추가를 비활성화합니다'
# 'Disable implicit builtin knowledge of a specific function'
H72774275D87A: '특정 함수에 대한 암시적 내장 지식을 비활성화합니다'
# 'Disable implicit builtin knowledge of functions'
H4AC3CF326B03: '암시적 내장 함수 정보 사용을 비활성화합니다'
# 'Disable implicit builtin knowledge of math functions'
H19E24A418BA8: '내재된 수학 함수에 대한 암시적 기본 지식 비활성화'
# 'Disable inclusion of timestamp in precompiled headers'
H0CF0F2D88326: '미리 컴파일된 헤더에서 timestamp의 포함을 비활성화합니다'
# 'Disable indirect call promotion'
HEA9F9E3D24D2: '간접 호출 프로모션 비활성화'
# 'Disable instrumentation manager (use the default class which ignores instruments.).'
HFBC374870D12: '인스트루먼테이션 관리자를 비활성화합니다(기본 클래스를 사용합니다. 해당 클래스는 인스트루먼테이션을 무시합니다).'
# 'Disable integer(KIND=16) from TargetCharacteristics'
H1BFDF2763387: 'TargetCharacteristics에서 KIND=16 정수형을 비활성화합니다'
# 'Disable integer(KIND=2) from TargetCharacteristics'
HBBF18B435116: 'TargetCharacteristics에서 integer(KIND=2)를 비활성화합니다'
# 'Disable integrated assembler'
HA16408310A5F: '통합 어셈블러 비활성화'
# 'Disable isel of shifter-op'
H7D5BCC95A13C: 'shifter-op의 isel 비활성화'
# 'Disable just-my-code debugging (default)'
H32F1427A6837: '자신의 코드만 디버깅 기능을 비활성화합니다 (기본값)'
# 'Disable keeping all variables that have a persistent storage duration, including global, static and thread-local variables, to guarantee that they can be directly addressed'
H49BC5C7A9B8E: '지속적인 저장 기간을 가진 모든 변수(전역, 정적, 스레드 로컬 변수 포함)를 유지하지 않도록 비활성화하여 직접 주소 지정이 가능하도록 보장합니다'
# 'Disable last run tracking'
HC4C7223E1ECA: '마지막 실행 추적 비활성화'
# 'Disable late function splitting using profile information (x86 and aarch64 ELF)'
HE4A96F3E3F80: '프로파일 정보를 사용하여 지연 함수 분할을 비활성화 (x86 및 aarch64 ELF)'
# 'Disable lazy module loading'
HEF9F9437498A: '%tr(지연 모듈 로딩 비활성화)'
# 'Disable ldsx insns'
H5394D7A0EA62: 'ldsx insns를 비활성화합니다'
# 'Disable lifetime-markers emission even when optimizations are enabled'
HBD15CF06A54D: '최적화가 활성화되어 있더라도 lifetime-markers 방출을 비활성화합니다'
# 'Disable linemarker output and preprocess to stdout'
HA445684726D8: '줄마커 출력을 비활성화하고 표준 출력으로 전처리합니다'
# 'Disable linemarker output in -E mode'
HF1226A7F981C: '-E 모드에서 라인마커 출력을 비활성화합니다'
# 'Disable linker dead stripping of globals in AddressSanitizer'
H529E513B965C: 'AddressSanitizer에서 글로벌 변수에 대한 링커 데드 스트리핑 비활성화'
# 'Disable linker relaxation'
H1AC503411592: '링커 완화를 비활성화'
# 'Disable live use priority in sched=list-ilp'
H265D7EB1A110: 'sched=list-ilp에서 라이브 사용 우선순위를 비활성화합니다.'
# 'Disable load widening'
HE007529C1391: '로드 확장 비활성화'
# 'Disable load-acquire and store-release insns'
HC50A5A53467A: '로드-획득 및 스토어-해제 명령어 비활성화'
# 'Disable load/store vectorizer'
H0E242722155F: '로드/스토어 벡터라이저 비활성화'
# 'Disable loading default configuration files'
H3C44B12DD359: '디폴트 설정 파일 로딩을 비활성화합니다'
# 'Disable looking for compound instructions for Hexagon'
HD818D391C2CA: 'Hexagon의 복합 명령어 탐색을 비활성화합니다'
# 'Disable looking for duplex instructions for Hexagon'
H3BEF6EB4C76F: 'Hexagon을 위한 duplex 명령어 탐색을 비활성화합니다.'
# 'Disable loop unrolling in all relevant passes'
H8679BDFD2EE8: '모든 관련 패스에서 루프 언롤링을 비활성화합니다'
# 'Disable loop-level heuristics.'
H3756953B43F4: '루프 수준 휴리스틱을 비활성화합니다.'
# 'Disable machine peepholes for BPF'
H195E092FC1CB: 'BPF에 대한 머신 피폴 최적화를 비활성화합니다'
# 'Disable machine peepholes for PPC'
HD0AFF1F89154: 'PPC를 위한 머신 피킹 홀 비활성화'
# 'Disable memory access instrumentation in ThreadSanitizer'
H29829654F38C: 'ThreadSanitizer에서 메모리 접근 인스트루먼테이션을 비활성화합니다'
# 'Disable memory promotion in LICM pass'
HFD9EDE137232: 'LICM 패스에서 메모리 프로모션을 비활성화합니다'
# 'Disable merging into combines'
H1147057C0FDD: '결합 병합을 비활성화'
# 'Disable merging of globals'
H0911384E3022: '글로벌 병합을 비활성화합니다'
# 'Disable minimum alignment of 1 for arguments passed by value on stack'
HAF9C1AF67E2F: '스택에 값으로 전달되는 인수에 대한 최소 정렬 1을 비활성화합니다'
# 'Disable mitigations for Load Value Injection (LVI)'
HE89F1385E864: '로드 값 주입(LVI) 완화 기능을 비활성화합니다'
# 'Disable module-based external API notes support'
H8FEB52AFA393: '모듈 기반 외부 API 노트 지원을 비활성화'
# 'Disable modules for C++'
H95B7103D9331: 'C++ 모듈 비활성화'
# 'Disable movsx insns'
H904B978BABF1: 'movsx 명령어를 비활성화합니다'
# 'Disable multi-region partial inlining'
H11B004AA7429: '다중 영역 부분 인라인 비활성화'
# 'Disable multi-threading within MLIR, overrides any further call to MLIRContext::enableMultiThreading()'
HE606F0AD2719: 'MLIR 내의 멀티스레딩을 비활성화하며, MLIRContext::enableMultiThreading()의 후속 호출을 무시합니다'
# 'Disable multiplicative reductions'
H68023B4BA449: '곱셈 축소 기능을 비활성화'
# 'Disable no-stall priority in sched=list-ilp'
H41669C812FF9: 'sched=list-ilp에서 no-stall 우선순위 비활성화'
# 'Disable non conforming code from compiling (default)'
HC27C523454B5: '표준에 맞지 않는 코드가 컴파일되는 것을 방지합니다 (기본값)'
# 'Disable non-allocatable physical register copy optimization'
H9F6E8121BA35: '할당 불가능한 물리 레지스터 복사 최적화 비활성화합니다'
# 'Disable odd single-precision floating point registers'
HC69012E33908: '홀수 단정도 부동소수점 레지스터 사용 안 함'
# "Disable omitting 'dls lr, lr' instructions"
HBB8A633ECC4C: 'dls lr, lr 명령어 생략을 비활성화'
# 'Disable on-demand initialization of thread-local variables'
HD53AA5AC4AC6: 'Thread-local 변수의 요청 시 초기화를 비활성화합니다'
# 'Disable one or more combiner rules temporarily in '
HD45ADA00F46A: '일시적으로 하나 이상의 조합 규칙을 비활성화합니다 '
# 'Disable optimization'
HD31C9965E766: '최적화를 비활성화합니다'
# 'Disable optimizations based on strict aliasing rules'
H0CE3F6B4E092: '엄격한 별칭 규칙에 기반한 최적화를 비활성화합니다'
# 'Disable optimizations based on vtable pointer identity'
HB754D32A5739: 'vtable 포인터 동일성에 기반한 최적화를 비활성화합니다'
# 'Disable optimize'
H7A717771741E: '최적화 비활성화'
# 'Disable optimized frm insertion.'
HC173F38AB5E6: '옵티마이징 frm 삽입을 비활성화합니다.'
# 'Disable origins tracking in MemorySanitizer'
H6CD4173EEC53: 'MemorySanitizer에서 원본 추적을 비활성화합니다'
# 'Disable output'
H10D88D0CF0F6: '출력 비활성화'
# 'Disable partial inlining'
H928A39907BEB: '부분 인라인 기능을 비활성화합니다'
# 'Disable physreg def-use affinity'
HC8A2DB30E27A: '물리 레지스터 정의-사용 친화성 비활성화'
# 'Disable platform support explicitly'
H0A0D6D39B390: '플랫폼 지원을 명시적으로 비활성화합니다'
# 'Disable poisoning array cookies when using custom operator new[] in AddressSanitizer'
H04ADC5D02283: 'AddressSanitizer에서 사용자 정의 오퍼레이터 new[]를 사용할 때 배열 쿠키 중독을 비활성화'
# 'Disable polly legality check'
H4B855C14E497: 'Polly 정합성 검사를 비활성화합니다'
# 'Disable pre-instrumentation inliner'
H6AAEA4B38739: '프리-인스트루먼테이션 인라이너 비활성화'
# 'Disable pre-register allocation tail duplication'
H74925BF6B59C: '사전 레지스터 할당 테일 복제를 비활성화합니다.'
# 'Disable precise memory mode (AMDGPU only)'
H638CDA8718C5: '정밀 메모리 모드를 비활성화 (AMDGPU 전용)'
# 'Disable precompiled headers, overrides /Yc and /Yu'
HA85F69F96408: '프리컴파일된 헤더를 비활성화합니다. /Yc 및 /Yu를 재정의합니다'
# 'Disable predefined and command line preprocessor macros'
HB44C3311DC89: '사전 정의된 및 명령줄 전처리기 매크로를 비활성화합니다'
# 'Disable predefined target OS macros'
H55CEC6079E93: '미리 정의된 타겟 OS 매크로 비활성화'
# "Disable printing the 'ready' prompt"
H60B484C23636: '준비 프롬프트 출력을 비활성화합니다'
# 'Disable probability-driven block placement'
H99FD887473AA: '확률 기반 블록 배치 비활성화'
# 'Disable promote alloca to LDS'
H12640892E5F6: 'alloca를 LDS로의 프로모션 비활성화'
# 'Disable promote alloca to vector'
H58F548447B08: '알로카를 벡터로 변환 비활성화'
# 'Disable protection against removing loop preheaders'
H11458F88A73B: '루프 프리헤더 제거 방지 기능을 비활성화합니다'
# 'Disable raw string literals'
H5372647D5F22: '원시 문자열 리터럴을 비활성화합니다'
# 'Disable real(KIND=10) from TargetCharacteristics'
H7AB18BD04A08: 'TargetCharacteristics에서 real(KIND=10) 비활성화'
# 'Disable real(KIND=3) from TargetCharacteristics'
H184DC371A7A3: 'TargetCharacteristics에서 real(KIND=3) 비활성화'
# 'Disable recovery for specified sanitizers'
HA007863682E4: '지정된 세이프티저에 대한 복구를 비활성화합니다'
# 'Disable regpressure priority in sched=list-ilp'
HF6314D19EB9F: '등록 압력 우선순위를 sched=list-ilp에서 비활성화'
# 'Disable removal of sext.w'
HB0977BC6B970: 'sext.w 제거를 비활성화합니다'
# 'Disable removal of sign-extend insn'
H484EAB4F216F: '부호 확장 명령어 제거를 비활성화'
# 'Disable replace with vector math call pass'
HC8A504A99877: '벡터 수학 호출로 변환하는 패스를 비활성화합니다'
# 'Disable sanitizer coverage instrumentation for modules and functions that match the provided special case list, even the allowed ones'
H8AE573AF38D9: '제공된 특수 사례 목록과 일치하는 모듈과 함수의 샌타이저 커버리지 인스트루먼테이션을 비활성화합니다. 허용된 항목들도 포함됩니다'
# 'Disable sanitizer metadata for modules and functions that match the provided special case list'
H09C17F700040: '제공된 특별한 경우 목록과 일치하는 모듈과 함수에 대해 샌타이저 메타데이터를 비활성화합니다'
# 'Disable sanitizer statistics gathering.'
HFB69298094E2: 'sanitizer의 통계 수집을 비활성화합니다.'
# 'Disable sc.q instruction.'
H283A06DB04BD: 'sc.q 명령어를 비활성화합니다.'
# 'Disable schedule adjustment for new value stores.'
H391300C49ACE: '새 값 저장소에 대한 스케줄 조정을 비활성화합니다.'
# 'Disable scheduled-height priority in sched=list-ilp'
H9402AC53BA7A: 'sched=list-ilp에서 scheduled-height 우선순위를 비활성화합니다.'
# "Disable scheduler's two-address hack"
HE3E8E40A1932: '스케줄러의 두 주소 트릭을 비활성화'
# 'Disable scheduling addi instruction beforeload for ppc'
H06295571D2AE: 'ppc용 addi 명령어 로드 전 스케줄링을 비활성화'
# 'Disable sdiv/smod insns'
HE1C6E99EA2FD: 'sdiv/smod 명령어를 비활성화합니다'
# 'Disable select to branch conversion.'
H3543CDE71CB9: 'select를 branch로 변환을 비활성화합니다.'
# 'Disable sharing the FileManager when building a module implicitly'
H8B60BD26410A: '암시적으로 모듈을 생성할 때 FileManager 공유를 비활성화합니다.'
# 'Disable simplify-libcalls'
H49E652857C1A: '간소화된 라이브러리 호출 사용 안 함'
# 'Disable small data sections sorting'
H8333FC4754B0: '작은 데이터 섹션 정렬을 비활성화'
# 'Disable specific target library builtin function'
HC0FDBC3C7F0C: '특정 타겟 라이브러리의 내장 함수를 비활성화합니다'
# 'Disable speculative execution side effect suppression (SESES)'
HC1901080B0A5: '추측 실행 부작용 억제 (SESES) 비활성화'
# 'Disable spell-checking'
HF73309AEBDCA: '스펠 검사 비활성화'
# 'Disable splitting double registers'
H5E3AECE38535: '더블 레지스터 분할 비활성화'
# 'Disable stack clash protection'
H8811AFD259AC: '스택 충돌 보호를 비활성화합니다'
# 'Disable stack coloring'
HC094CB265B68: '스택 색상 지정 비활성화'
# 'Disable stack probes which are enabled by default'
H7F863834E502: '기본적으로 활성화된 stack probes를 비활성화합니다'
# 'Disable standard #include directories for the C++ standard library'
HED953CC1E7C1: 'C++ 표준 라이브러리의 표준 #include 디렉토리를 비활성화합니다'
# 'Disable standard system #include directories'
HAB8A8040E467: '표준 시스템 #include 디렉토리를 비활성화합니다'
# 'Disable standard system #include directories only'
HA5DB077BC490: '표준 시스템 #include 디렉토리만 비활성화합니다'
# 'Disable store widening'
H4BB106975BD7: '저장 확장 비활성화'
# 'Disable store(extract) optimizations in CodeGenPrepare'
HD78BB1861BFD: 'CodeGenPrepare 단계에서 저장(추출) 최적화를 비활성화합니다'
# 'Disable string pooling'
HC733A3918F74: '문자열 풀링을 비활성화합니다'
# 'Disable strip W suffix'
HF34CE2AC1BA4: 'W 접미사 제거 비활성화'
# 'Disable support for K&R C function declarations'
HEA32A58B7196: 'K&R C 함수 선언에 대한 지원을 비활성화합니다'
# 'Disable support for exception handling'
HAC5AC768AAF8: '예외 처리 기능을 비활성화합니다'
# 'Disable support for int128_t type'
H064E25645BF2: 'int128_t 유형 지원을 비활성화합니다'
# 'Disable symbolizing crash backtraces.'
HA299A2AEAED6: '시스템 종료(クラ쉬)의 백트레이스 기호화를 비활성화합니다.'
# 'Disable tail call optimization, keeping the call stack accurate'
H8EF83315B758: '꼬리 호출 최적화를 비활성화하여 호출 스택의 정확성을 유지합니다'
# 'Disable tail duplication'
HACA1C01DCC7A: '꼬리 복제 비활성화'
# 'Disable tail folding'
HA81C7EA6791A: '꼬리 접기를 비활성화합니다'
# 'Disable tail-predication in the ARM LowOverheadLoop pass'
HF132A6CB93FD: 'ARM 저오버헤드 루프 패스에서 꼬리 예측을 비활성화합니다'
# 'Disable that single precision floating-point divide and sqrt used in '
H475D4ABE9D62: '단정도 부동소수점 나눗셈과 sqrt 사용을 해당 부분에서 비활성화합니다'
# 'Disable the ARM Parallel DSP pass'
H8178C8159BC2: 'ARM 병렬 DSP 패스를 비활성화합니다'
# 'Disable the CFI fixup pass'
H170DD55153F0: 'CFI 수정 패스를 비활성화합니다'
# 'Disable the DAG combiner'
HF3DAFFFFA107: 'DAG 콤바이너 비활성화'
# 'Disable the Sparc delay slot filler.'
HDE8C0A85D477: 'Sparc 지연 슬롯 필러를 비활성화합니다.'
# 'Disable the abort'
H9CB580C2DD7C: '중단을 비활성화합니다'
# 'Disable the abort but emit a diagnostic on failure'
H84A7D406A5F3: 'abort를 비활성화하지만 실패 시 진단을 발생시킵니다'
# 'Disable the emission of assembler pseudo instructions'
H9E100408BFFF: '어셈블러 가짜 명령어의 생성을 비활성화합니다'
# 'Disable the expand reduction intrinsics pass from running'
H040AA8C3CBF5: '확장 감소 내부 함수 패스 실행을 비활성화합니다'
# 'Disable the generation of 4-operand madd.s, madd.d and related instructions.'
HB91438C02652: '4개 연산자의 madd.s, madd.d 및 관련 명령문의 생성을 비활성화합니다.'
# 'Disable the generation of low-overhead loops'
H1104A5C142EF: '낮은 오버헤드 루프 생성을 비활성화합니다'
# 'Disable the integrated assembler'
H779AD38A6D36: '통합 어셈블러를 비활성화합니다'
# 'Disable the loop interchange pass'
H8A139F798C85: '루프 교환 패스를 비활성화합니다'
# 'Disable the loop vectorization passes'
H55BB6EBCE09F: '루프 벡터화 패스를 비활성화합니다'
# 'Disable the module hash'
H7FE90FAE4F03: '모듈 해시를 비활성화합니다.'
# 'Disable the parsing of an implicit top-level module op'
HF5D65FFCFADF: '암시적 최상위 모듈 오퍼레이션의 해석을 비활성화합니다'
# 'Disable the pass entirely'
HA841AC9C39A5: '전체적으로 패스를 비활성화합니다'
# 'Disable the peephole optimizer'
H5AEFA90F7A64: 'peephole 최적화를 비활성화합니다.'
# 'Disable the select-optimization pass from running'
H0DA28C5C19DF: 'select 최적화 패스의 실행을 비활성화합니다'
# 'Disable the usage of LEB128 directives, and generate .byte instead.'
HFFB7D99931FD: 'LEB128 지시문의 사용을 비활성화하고 대신 .byte를 생성합니다.'
# 'Disable the use of non-volatile CR register fields'
H01F2C9F9FECF: '비휘발성 CR 레지스터 필드의 사용을 비활성화합니다'
# 'Disable the use of stack protectors'
HCC816F874533: '스택 보호기의 사용을 비활성화합니다'
# 'Disable the vector mask scheduling mutation'
H6FF8BC95F625: '벡터 마스크 스케줄링 변이를 비활성화합니다'
# 'Disable the verifier on parsing (very unsafe)'
H314B68416CA8: '파싱 시 검증기를 비활성화 (매우 위험)'
# 'Disable the wasm-opt optimizer'
H214565A17764: 'wasm-opt 최적화 비활성화'
# 'Disable thread-safe initialization of static variables'
H9A6053E9675B: '정적 변수의 스레드 안전 초기화를 비활성화합니다'
# 'Disable threadgroup split execution mode (AMDGPU only)'
HFE9B2C98E16A: 'threadgroup 스플릿 실행 모드를 비활성화합니다 (AMDGPU 전용)'
# 'Disable trapping for all sanitizers'
H434CA7F72650: '모든 샌타이저에 대한 트래핑 비활성화'
# 'Disable trapping for specified sanitizers'
H8374BC4644FA: '지정된 산타이저에 대한 트래핑을 비활성화합니다'
# 'Disable treating throwing global C++ operator new as always returning valid memory (annotates with __attribute__((returns_nonnull)) and throw()). This is detectable in source.'
H1293614D97E9: 'throwing 전역 C++ operator new를 항상 유효한 메모리를 반환한다고 처리하는 것을 비활성화 ( __attribute__((returns_nonnull)) 및 throw()로 주석을 추가합니다). 이 기능은 소스 코드에서 감지할 수 있습니다.'
# 'Disable trigraphs (default)'
H739A08E7CEDE: '트리그라프를 비활성화 (기본값)'
# 'Disable two address hints for register allocation'
H82ADA80F88F5: '리지스트 할당을 위한 두 주소 힌트 비활성화'
# 'Disable two-phase name lookup in templates (default)'
HB877DF6B6337: '템플릿에서 두 단계 이름 조회를 비활성화합니다 (기본값)'
# 'Disable type promotion pass'
HE0F6634D8D16: '유형 승격 패스를 비활성화합니다'
# 'Disable unclustered high register pressure reduction scheduling stage.'
HAE3C6A80BF96: '비클러스터링된 고레지스터 압력 감소 스케줄링 단계를 비활성화합니다.'
# 'Disable unused template argument warnings.'
H8A2178DF0ED5: '사용되지 않은 template 인수 경고를 비활성화합니다.'
# 'Disable unwind v2 (epilog) information for x64 Windows'
H2002C343134B: 'x64 Windows용 unwind v2(에필로그) 정보 비활성화'
# 'Disable use of DFA during scheduling'
HFCEBEB8744EF: '스케줄링 중 DFA 사용 비활성화'
# 'Disable use of LD/ST pairs for SME2 or SVE2p1'
H886738D62F05: 'SME2 또는 SVE2p1을 위해 LD/ST 쌍 사용을 비활성화합니다'
# 'Disable use of builtin functions'
H6011A85599FF: '빌트인 함수 사용을 비활성화'
# 'Disable use-after-destroy detection in MemorySanitizer'
H76DBA1F549C7: 'MemorySanitizer에서 use-after-destroy 감지를 비활성화합니다'
# 'Disable use-after-scope detection in AddressSanitizer'
HDEA7FE9A7621: 'AddressSanitizer에서 use-after-scope 탐지를 비활성화합니다'
# 'Disable using constant pool for large integers.'
H8489E618879C: '큰 정수에 대한 상수 풀 사용을 비활성화합니다.'
# 'Disable using instrumentation data for profile-guided optimization'
H0DABDB711ED0: '프로파일 기반 최적화를 위한 인스트루먼테이션 데이터 사용을 비활성화합니다'
# 'Disable using library calls for save and restore'
HABD1CF6BBA21: '저장 및 복원을 위한 라이브러리 호출 사용을 비활성화합니다'
# 'Disable validation'
H26FB09D2AB0A: '검증 비활성화'
# 'Disable validation of precompiled headers'
H2DA6E28812C6: '사전 컴파일된 헤더의 검증을 비활성화'
# 'Disable validation of the diagnostic options when loading the module'
HE4C65ABEFA0D: '모듈을 로드할 때 진단 옵션 검증을 비활성화합니다'
# 'Disable vector double new-value-stores'
H46E40B609BEA: '벡터 더블 새 값 저장 비활성화'
# 'Disable verification of LLVM IR'
H1AB74862104E: 'LLVM IR 검증을 비활성화합니다'
# 'Disable virtual register cycle interference checks'
H2BA1419A0C46: '가상 레지스터 사이클 간섭 검사를 비활성화합니다'
# 'Disable whole program visibility (overrides enabling options)'
H1D60C5E310B2: '전체 프로그램 가시성 비활성화 (활성화 옵션 무시)'
# 'Disable writing diagnostic options'
H37E0E37A8998: '진단 옵션 기록 비활성화'
# 'Disable writing header search paths'
HCFD8074000E3: '헤더 검색 경로 쓰기를 비활성화합니다'
# 'Disable x86 relax relocations'
HB7F95908656B: 'x86 리로케이션 완화 비활성화'
# 'Disabled.'
HBC2D62F7229F: '비활성화됨.'
# 'Disables -fvisibility-inlines-hidden-static-local-var (this is the default on non-darwin targets)'
H2552506748D2: '비활성화 -fvisibility-inlines-hidden-static-local-var (비-Darwin 타겟에서 기본값입니다)'
# 'Disables combining addressing modes with different parts in optimizeMemoryInst.'
H1A57049BF682: 'optimizeMemoryInst에서 서로 다른 부분의 주소 모드 결합을 비활성화합니다.'
# 'Disables debug printing for the new pass manager'
H92F40F826D39: '새 패스 매니저의 디버깅 출력을 비활성화합니다'
# 'Disables evaluation of GetElementPtr with constant operands'
H5A42772B82EF: '상수 인수를 사용한 GetElementPtr 평가를 비활성화합니다'
# 'Disables inttoptr/ptrtoint roundtrip optimization'
H03E816B33DC1: 'inttoptr/ptrtoint 왕복 최적화를 비활성화합니다'
# 'Disables potentially expensive checks in the transform interpreter, providing more speed at the expense of potential memory problems and silent corruptions'
H8C53B2F32644: '변환 인터프리터 내에서 발생할 수 있는 고비용 검사를 비활성화하여, 잠재적인 메모리 문제와 은밀한 손상의 위험을 감수하고 더 빠른 속도를 제공합니다.'
# 'Disables the global instruction selector'
HD7298FC773DA: '전역 명령어 선택기를 비활성화합니다'
# "Disallow '$' in identifiers"
HEC529DE7E6EB: "식별자에서 '$'를 허용하지 않습니다"
# 'Disallow MIPS delay filler to search backward.'
H93B2211830F9: 'MIPS 딜레이 필러가 역방향으로 탐색하도록 허용하지 않습니다.'
# 'Disallow MIPS delay filler to search forward.'
H0A7403D7CADA: 'MIPS 지연 필러가 앞으로 탐색하는 것을 금지합니다.'
# 'Disallow MIPS delay filler to search successor basic blocks.'
H806FD91060E7: 'MIPS 딜레이 필러가 후속 기본 블록을 탐색하도록 금지합니다.'
# 'Disallow __declspec as a keyword'
HC17ADE50EB84: '__declspec을 키워드로 금지합니다'
# "Disallow alternative token representations '<:', ':>', '<%', '%>', '%:', '%:%:'"
HF519C51A2110: "다음 토큰 표현들의 사용을 금지합니다 '<:', ':>', '<%', '%>', '%:', '%:%:'"
# 'Disallow atomic operations to ignore denormal mode'
HE8CD8EB9071A: '원자 연산이 비정규 모드를 무시하는 것을 허용하지 않음'
# 'Disallow complex IT blocks'
H020AA42EE64B: '복잡한 IT 블록을 허용하지 않습니다'
# 'Disallow converting instructions with negative immediates to their negation or inversion.'
H4A70CE206CB7: '부정 즉시값이 있는 명령어를 그들의 부정 또는 역전으로 변환하는 것을 금지합니다.'
# 'Disallow generation of complex IT blocks. It is off by default.'
HB67D63CAAB67: '복잡한 IT 블록의 생성을 허용하지 않습니다. 기본적으로 비활성화되어 있습니다.'
# 'Disallow generation of data access to code sections (AArch64/ARM only)'
HF9C8C76A5FB2: '코드 섹션에 대한 데이터 접근 생성을 허용하지 않음 (AArch64/ARM 전용)'
# 'Disallow merging of constants'
H70C4FD1FC35B: '상수 병합을 금지'
# 'Disallow use of CRC instructions (ARM only)'
HB840DEC2FEB5: 'CRC 명령어의 사용을 금지 (ARM만)'
# 'Disallow use of CRC instructions (Mips only)'
H9E92A4FAF94C: 'CRC 명령어의 사용을 금지 (Mips 전용)'
# 'Disallow use of movt/movw pairs (ARM only)'
H1C82DB59E408: 'movt/movw 쌍의 사용을 금지합니다 (ARM 전용)'
# 'Disassemble strings of hex bytes'
H613CDE699EC0: '16진수 바이트 문자열 분해'
# 'Disassembler Options'
H4DCD7C09D805: '디스어셈블러 옵션'
# 'Discard names from Value (other than GlobalValue).'
H742AC63D224D: 'Value(전역 값이 아닌 경우)에서 이름을 제거합니다.'
# 'Discard value names in LLVM IR'
HCD7AD84832F7: 'LLVM IR에서 값 이름을 무시합니다'
# 'Discarded elements by the linker.'
HD3934CD11684: '링커에 의해 버려진 요소들.'
# 'Discriminator.'
H206A9AC4C507: '구분자.'
# 'Discriminators for inlined function instances.'
HCFDAECEFD17E: '인라인 함수 인스턴스를 위한 디스카미네이터.'
# "Display PDB's MS system elements."
H9055330B7E79: 'PDB의 MS 시스템 요소를 표시합니다.'
# 'Display all available options'
H4F3544FDA0B5: '사용 가능한 모든 옵션을 표시'
# 'Display all basic blocks'
H75BB63BE80F7: '모든 기본 블록 표시'
# 'Display all class members including data, constants, typedefs, functions, etc'
HCA18E04B4029: '모든 클래스 멤버(데이터, 상수, typedefs, 함수 등)를 표시합니다'
# 'Display all symbols (default)'
H809598610BD8: '모든 심볼 표시 (기본값)'
# 'Display all types (implies -classes, -enums, -typedefs)'
H5D20AC3AE6F6: '모든 유형 표시(-classes, -enums, -typedefs를 함의)'
# 'Display any symbol or type with the specified exact name'
H2B91D0A39EC5: '지정된 정확한 이름을 가진 심볼이나 타입을 표시합니다'
# 'Display arrays'
HDC2B25BF5710: '배열 표시'
# 'Display available options'
H46A7DC1788BB: '사용 가능한 옵션 표시'
# 'Display available options (--help-hidden for more)'
HB2294B093626: '사용 가능한 옵션을 표시 (--help-hidden을 더 보기)'
# 'Display branch counts instead of percentages (requires -b)'
HE5D58860A9A5: '분기 수를 백분율 대신 표시 (옵션 -b가 필요합니다)'
# 'Display branch probabilities'
H1A848099A8E1: '분기 확률 표시'
# 'Display class types'
H4B4B15B36D12: '클래스 유형 표시'
# 'Display compilands'
H98204E2FD2A3: '컴파일 대상 표시'
# 'Display data symbols'
HE0831CC1C7E5: '데이터 심볼 표시'
# 'Display each error as well as a summary. [default]'
HB4E9ED4A232D: '각 오류와 요약을 표시합니다. [기본값]'
# 'Display each error in detail but no summary.'
H84BA445E865B: '각 오류를 상세히 표시하지만 요약은 표시하지 않습니다.'
# 'Display enum types'
H7D0238663B0A: '열거형 유형 표시'
# 'Display execution times'
HA3302D5C387F: '실행 시간 표시'
# 'Display exploded graph using GraphViz'
H57BD4170B555: 'GraphViz를 사용하여 분해 그래프 표시'
# 'Display function signatures'
H616CCB32163A: '함수 시그니처 표시'
# 'Display function symbols'
H2496573880E0: '함수 심볼 표시'
# 'Display help for hidden options'
H64D149DE5706: '숨겨진 옵션 도움말 표시'
# 'Display include stacks for diagnostic notes'
HBF49F525A9C8: '진단 메시지의 인클루드 스택 표시합니다'
# 'Display injected sources'
H615D1D35669F: '주입된 소스 표시'
# 'Display list of all available options'
HC3085F81E368: '사용 가능한 모든 옵션 목록 표시'
# 'Display list of available options (--help-list-hidden for more)'
H6C69B229E72D: '사용 가능한 옵션 목록을 표시합니다 (--help-list-hidden을 사용하면 더 많은 옵션을 볼 수 있습니다)'
# "Display lists of good files (no compile errors), problem files, and a combined list with problem files preceded by a '#'."
HC6E030BB5330: '오류 없는 파일(컴파일 에러 없음), 문제 파일, 그리고 #로 시작하는 문제 파일을 포함한 결합된 목록을 표시합니다.'
# 'Display method for pass statistics'
H93E064D4A3FD: '패스 통계 표시 방법'
# 'Display method for timing data'
H6D05268C903F: '타이밍 데이터 표시 방법'
# 'Display more information when dumping selection DAG nodes.'
H7335ABA75176: 'selection DAG 노드를 덤프할 때 더 많은 정보를 표시합니다.'
# 'Display only a summary of the errors found.'
HD9988E75DBC1: '발견된 오류만 요약하여 표시합니다.'
# 'Display patch-like changes'
H944897EBC1CF: '패치 형식의 변경 내용 표시'
# 'Display patch-like changes in quiet mode'
H1874C26C00E8: 'quiet 모드에서 패치와 유사한 변경 사항 표시'
# 'Display patch-like changes in quiet mode with color'
HDA3927492A7C: 'quiet 모드에서 색상으로 패치 형식의 변경 사항 표시'
# 'Display patch-like changes with color'
HC5827DF84A7E: '색상으로 패치 유사 변경 사항 표시'
# 'Display pointer types'
H5EE2D9F1E113: '포인터 유형 표시'
# 'Display statistics as json data'
H332F68176CB1: 'JSON 데이터로 통계 정보 표시'
# 'Display suggestions to update code associated with -Wunsafe-buffer-usage warnings'
H5B046555524E: '관련된 -Wunsafe-buffer-usage 경고와 연결된 코드를 업데이트하기 위한 제안을 표시합니다'
# 'Display symbols for each compiland'
H087A1D8A2407: '각 컴파일 단위의 심볼 표시'
# 'Display the SLP trees with Graphviz'
H5A01A170758F: '그래프비(Graphviz)로 SLP 트리를 표시합니다'
# "Display the compiler's target processor"
HFDA3133B76AB: '컴파일러의 대상 프로세서를 표시합니다'
# 'Display the count broken down by the filepath of each remark emitted. Requires remarks to have DebugLoc information.'
HDD5492CA6C68: '발생한 각 주석의 파일 경로별로 카운트를 상세히 표시합니다. 이 옵션을 사용하려면 주석에 DebugLoc 정보가 있어야 합니다.'
# 'Display the list of -analyzer-config options. These are meant for development purposes only!'
HEEAD9A5EE121: '-analyzer-config 옵션 목록을 표시합니다. 이 옵션들은 개발 용도로만 제공됩니다!'
# 'Display the list of analyzer checkers that are available'
H74EADAEE0F8E: '사용 가능한 분석기 체커 목록을 표시합니다'
# 'Display the list of checker and package options'
H9FD261E9343C: 'checker와 패키지 옵션 목록을 표시합니다'
# 'Display the list of checker and package options meant for development purposes only'
H99D575B08548: '개발 용도로만 사용되는 체커 및 패키지 옵션 목록을 표시합니다'
# 'Display the list of developer-only checkers such as modeling and debug checkers'
H5D875C21A22A: '개발자 전용 체커(예: 모델링 및 디버그 체커) 목록을 표시합니다'
# 'Display the list of enabled analyzer checkers'
HDD1AC8873D07: '활성화된 분석 체커 목록을 표시합니다'
# 'Display the list of in development analyzer checkers. These are NOT considered safe, they are unstable and will emit incorrect reports. Enable ONLY FOR DEVELOPMENT purposes'
H9701D9AE6717: '개발 중인 분석기 체커 목록을 표시합니다. 이들은 안전하지 않으며, 불안정하고 잘못된 보고를 발생시킬 수 있습니다. 개발 목적으로만 활성화하세요'
# 'Display the list of in development checker and package options. These are NOT considered safe, they are unstable and will emit incorrect reports. Enable ONLY FOR DEVELOPMENT purposes'
H44975E30827B: '개발 중인 검사기와 패키지 옵션의 목록을 표시합니다. 이 옵션들은 안전하지 않으며, 불안정하여 잘못된 보고서를 생성할 수 있습니다. 단지 개발 목적으로만 활성화해야 합니다'
# 'Display the statistics of each pass'
HC9CD9384324F: '각 패스의 통계를 표시합니다'
# 'Display the version of the compiler'
H5C279623CA4C: '컴파일러 버전을 표시합니다'
# 'Display the version of this program'
H5228B6ADFC09: '이 프로그램의 버전을 표시합니다'
# 'Display thunk symbols'
H60D32CD26A79: 'Thunk 심볼 표시'
# 'Display typedef types'
H80D29E660696: 'typedef 유형 표시'
# 'Display unconditional branch info (requires -b)'
H860C02BEA720: '무조건 분기 정보 표시 (옵션 -b 필요)'
# 'Display vftable shapes'
H0BAEA6CF044D: 'vftable 형태 표시'
# 'Displays only those classes which have at least the specified amount of immediate padding, ignoring padding internal to bases and aggregates.'
H4365E41B0200: '지정된 양 이상의 즉각적인 패딩을 가진 클래스만 표시하며, 기반 클래스와 집합체 내부의 패딩은 무시합니다.'
# 'Displays only those classes which have at least the specified amount of padding.'
HC457A02E6744: '지정된 패딩 양 이상을 가진 클래스만 표시합니다.'
# 'Displays only those types which are greater than or equal to the specified size.'
H939E231DB942: '지정된 크기 이상인 유형만 표시합니다.'
# 'Distributor to use for ThinLTO backend compilations. Specifying this enables DTLTO.'
H94E676409243: 'ThinLTO 백엔드 컴파일에 사용할 배포 도구입니다. 이 옵션을 지정하면 DTLTO가 활성화됩니다.'
# 'Divisor of cold branch probability.BranchProbability = 1/ColdBranchProbDenom'
HFEB48317469C: 'cold branch 확률의 분모. BranchProbability = 1/ColdBranchProbDenom'
# 'Do PGO instrumentation sampling'
H20E4EAC6B490: 'PGO 인스트루먼테이션 샘플링 수행'
# 'Do counter register promotion'
H9B115D4FE5B7: '카운터 레지스터 프로모션 수행'
# 'Do counter update using atomic fetch add  for promoted counters only'
H7767713DC2D0: '프로모션된 카운터에만 원자성 fetch add를 사용하여 카운터 업데이트를 수행합니다'
# 'Do more PHI writes than necessary in order to avoid partial accesses'
HE1D29CA7DAB8: '필요 이상으로 PHI 쓰기를 추가하여 부분적 액세스를 피하라'
# 'Do not accept non-standard constructs supported by the z/OS compiler'
HD8F703A83AED: 'z/OS 컴파일러에서 지원하는 비표준 구문을 허용하지 않습니다'
# 'Do not add %INCLUDE% to include search path'
H7E3445F24099: '인클루드 검색 경로에 %INCLUDE%를 추가하지 마세요'
# 'Do not add -rpath with architecture-specific resource directory to the linker flags. When --hip-link is specified, do not add -rpath with HIP runtime library directory to the linker flags'
H98822B20FC31: '아키텍처별 리소스 디렉토리와 함께 -rpath를 링커 플래그에 추가하지 마십시오. --hip-link가 지정되면 HIP 런타임 라이브러리 디렉토리와 함께 -rpath를 링커 플래그에 추가하지 마십시오.'
# 'Do not add a BTI instruction after a setjmp or other return-twice construct (Arm/AArch64 only)'
H97946DA95B7B: 'setjmp 또는 다른 return-twice 구조 이후에는 BTI 명령문을 추가하지 마십시오 (Arm/AArch64 전용)'
# 'Do not add include paths for CUDA/HIP and do not include the default CUDA/HIP wrapper headers'
HCB5DBE4305C2: 'CUDA/HIP를 위한 include 경로를 추가하지 마시고 기본 CUDA/HIP 래퍼 헤더를 포함하지 마세요'
# 'Do not add instruction count to lsr cost model'
HE7651E5EC0B1: 'LSR 비용 모델에 명령어 수를 추가하지 마십시오'
# 'Do not add parameter bounds and do no gist simplify sets accordingly'
HC6FB1327B189: '매개변수 경계를 추가하지 말고 do no gist 단순화 집합을 그에 따라 갱신하지 마십시오'
# 'Do not align and prefetch loops'
HFA5D85E291BA: '정렬 및 루프 미리 가져오기를 하지 마십시오'
# 'Do not allocate the LR register for general purpose usage, only for calls. (AArch64 only)'
H80E0CE8F43D2: 'LR 레지스터는 일반적인 용도로 사용하지 말고, 오직 호출을 위해만 할당해야 합니다. (AArch64 전용)'
# 'Do not allow compiler to annotate sanitizer instrumentation with extra debug info for any sanitizers'
H4387C2461E4F: '컴파일러가 모든 샌니타이저에 대해 샌니타이저 계측에 추가 디버그 정보를 주석으로 추가하는 것을 허용하지 않습니다.'
# 'Do not allow compiler to annotate sanitizer instrumentation with extra debug info for the specified sanitizers'
H0A0FD94EAF41: '컴파일러가 지정된 샌니타이저에 대해 샌니타이저 계측에 추가 디버그 정보를 주석으로 추가하는 것을 허용하지 않습니다.'
# 'Do not allow compiler to merge handlers for any sanitizers'
HC4FB93EDAFBC: '어떤 산타이저에 대한 핸들러를 컴파일러가 병합하도록 허용하지 마십시오'
# 'Do not allow compiler to merge handlers for specified sanitizers'
H14D0727FA9D4: '지정된 산타이저 핸들러를 병합하도록 컴파일러를 허용하지 마십시오'
# 'Do not assume C++ operator new may not return NULL'
H1F6F59A37FC5: 'C++ operator new가 NULL을 반환하지 않을 수 있다는 가정을 하지 마십시오'
# 'Do not assume that any loop is finite.'
H5580E1E87EBF: '어떤 루프도 유한하다고 가정하지 마십시오.'
# 'Do not assume that externally defined data is in the small data if it meets the -G <size> threshold (MIPS)'
HAD54547B8D0E: '외부에서 정의된 데이터가 -G <size> 임계값을 충족하더라도, 이를 소데이터에 포함된 것으로 가정하지 마십시오 (MIPS)'
# 'Do not automatically generate or update the global module index'
H6DB4D9D7E3EF: '전역 모듈 인덱스를 자동으로 생성하거나 업데이트하지 마십시오'
# 'Do not automatically import modules for error recovery'
H8260A94CB46D: '오류 복구를 위해 모듈을 자동으로 가져오지 마십시오'
# 'Do not build run-time checks to proof absence of integer wrapping'
H067730FFEE80: '정수 오버플로의 부재를 증명하기 위한 런타임 검사를 생성하지 않습니다.'
# 'Do not bundle output files of HIP device compilation'
H3591F62084D9: 'HIP 디바이스 컴파일의 출력 파일을 묶지 마세요'
# 'Do not check authenticated address'
H0709C5934F02: '인증된 주소를 확인하지 마십시오'
# 'Do not color Edges'
HAA019B0E453C: 'Edges에 색상을 적용하지 마십시오'
# 'Do not color Vertices'
HCD93BE0D4AC9: 'Vertices를 색상으로 채우지 마십시오.'
# 'Do not color vertices'
H1FA039A4B956: '정점을 색칠하지 마십시오'
# 'Do not combine ALU and memory operators'
H22D1C7806EDC: 'ALU와 메모리 연산자를 결합하지 마십시오'
# 'Do not consider inline-asm a scheduling/packetization boundary.'
H930DAD5CB7A3: '인라인 어셈블리를 스케줄링/패킷화 경계로 간주하지 마십시오.'
# 'Do not convert branches that may exit the loop'
H912C8CC5220C: '루프를 벗어날 수 있는 분기는 변환하지 마십시오'
# 'Do not convert find-first-byte loop(s).'
H586B9EEE9F17: '첫 바이트 찾기 루프(들)을 변환하지 않습니다.'
# 'Do not create a host fallback if offloading to the device fails.'
HFCABEED29F02: '장치로 오프로딩하는 것이 실패할 경우 호스트 대체를 생성하지 마십시오.'
# 'Do not create extra branches to split comparison logic.'
H67D6951DD9C2: '비교 논리를 분할하기 위해 추가적인 분기문을 생성하지 마십시오.'
# 'Do not create unit-strided loops (default)'
HA7BFEC1D48BB: '단위 간격 루프 생성하지 않음 (기본값)'
# 'Do not discard comments when preprocessing'
HF9B5FA45AABB: '프리프로세싱 시 주석을 무시하지 마십시오'
# 'Do not discard value names in LLVM IR'
H4D77D8B34317: 'LLVM IR에서 값 이름들을 버리지 마십시오'
# 'Do not dllexport/dllimport inline member functions of dllexport/import classes'
H178235CEFFFB: 'dllexport/import 클래스의 인라인 멤버 함수에 dllexport/dllimport를 사용하지 마십시오'
# 'Do not drop any type tests'
H0426A41590E9: '타입 테스트를 생략하지 마십시오.'
# 'Do not dump MSF file headers'
H5B5B36671D5C: 'MSF 파일 헤더를 덤프하지 마십시오'
# 'Do not elide types when printing diagnostics'
HAAA41F99F968: '진단을 출력할 때 타입을 생략하지 마십시오'
# 'Do not eliminate read instrumentation for read-before-writes'
HFAB29E5FAAB8: '읽기 전 읽기용 읽기 액세스 추적을 제거하지 마십시오'
# 'Do not embed'
H58D31A15C486: '내장하지 마십시오'
# 'Do not emit  debug info for defined but unused types'
HB04F2AC6377B: '정의되었지만 사용되지 않은 타입에 대한 디버그 정보를 생성하지 않습니다'
# 'Do not emit RTTI data'
H0669AFF65C8F: 'RTTI 데이터를 생성하지 않습니다'
# "Do not emit a trap instruction for 'unreachable' IR instructions after noreturn calls, even if --trap-unreachable is set."
HB71318F0BBDA: "noreturn 호출 이후 'unreachable' IR 지시문에 대해 트랩 명령문을 생성하지 않으며, --trap-unreachable 옵션이 설정되더라도 마찬가지입니다."
# 'Do not emit code that uses the red zone.'
H4923C3F307F8: '레드 존을 사용하는 코드를 생성하지 마십시오.'
# 'Do not emit code to make initialization of local statics thread safe'
HB028FFDC42D1: '지역 정적 변수의 초기화를 스레드 안전하게 하기 위한 코드를 생성하지 않습니다'
# 'Do not emit code to perform on-demand initialization of thread-local variables'
HC624E884FFD9: '쓰레드 로컬 변수의 on-demand 초기화를 수행하기 위한 코드를 생성하지 않습니다'
# 'Do not emit macro debug information'
H8F91A57AE16C: '마크로 디버그 정보를 생성하지 않습니다'
# 'Do not emit metadata containing compiler name and version'
HAB66E1C6275C: '컴파일러 이름 및 버전을 포함하는 메타데이터를 생성하지 마십시오'
# 'Do not emit pseudo probes for sample profiling'
H98592A339F09: '샘플 프로파일링에 대한 가상 프로브를 생성하지 마십시오'
# 'Do not emit remarks about assumptions that are known'
H0F5A09E813C1: '알려진 가정에 대한 주석을 생성하지 마십시오'
# 'Do not enforce -fmodules-decluse and private header restrictions for textual headers. This flag will be removed in a future Clang release.'
H0CAD9E73AF57: '텍스트 헤더에 대해 -fmodules-decluse 및 프라이빗 헤더 제한을 강제하지 않습니다. 이 플래그는 미래의 Clang 릴리스에서 제거될 것입니다.'
# 'Do not error on use of NSAllocateCollectable/NSReallocateCollectable'
HFB2D301661F8: 'NSAllocateCollectable/NSReallocateCollectable 사용 시 오류 표시하지 않음'
# 'Do not execute loaded code'
HAC6A8BA715B2: '로드된 코드를 실행하지 마십시오'
# 'Do not extend the -G behaviour to object local data (MIPS)'
HE38064F00B03: '객체 내부 데이터에 -G 동작을 확장하지 마십시오 (MIPS)'
# 'Do not fail and just print warnings.'
H194F6AFAEB48: '실패하지 말고 경고만 출력합니다.'
# 'Do not fail on the first error.'
H09A7570CEE99: '첫 번째 오류에서 실패하지 마십시오.'
# 'Do not follow the AAPCS standard requirement stating that volatile bit-field width is dictated by the field container type. (ARM only).'
H33C6AFA87C27: 'AAPCS 표준 요구사항 중 "volatile bit-field 너비는 필드 컨테이너 유형에 의해 결정된다"는 조항을 따르지 않습니다. (ARM 전용)'
# 'Do not force validation of user headers when repeatedly loading a module file within single build session'
HC2C2C627ADC2: '단일 빌드 세션 내에서 모듈 파일을 반복적으로 로드할 때 사용자 헤더의 검증을 강제하지 않습니다.'
# 'Do not generate code for uses of this PCH that assumes an explicit object file will be built for the PCH'
H882EA3DF4A8E: '이 PCH가 명시적인 오브젝트 파일이 생성된다고 가정하는 사용 사례에 대한 코드 생성을 하지 마세요.'
# 'Do not generate comments'
H64C7ECF357DC: '주석을 생성하지 마십시오'
# 'Do not generate debug info for types in an object file built from this PCH and do not generate them elsewhere'
H4C63A76D37C7: '이 PCH로 생성된 객체 파일 내의 타입에 대한 디버그 정보를 생성하지 말고, 다른 곳에도 생성하지 마세요'
# 'Do not generate same-address load-load barrier instructions (dbar 0x700)'
HAC760584246F: '동일 주소 로드-로드 배리어 명령어(dbar 0x700)를 생성하지 않습니다.'
# 'Do not globally set the denormals-are-zero (DAZ) and flush-to-zero (FTZ) bits in the floating-point control register on program startup'
H792FD67CD9D7: '프로그램 시작 시 부동소수점 제어 레지스터의 denormals-are-zero (DAZ) 및 flush-to-zero (FTZ) 비트를 전역적으로 설정하지 마십시오.'
# 'Do not hoist instructions if targetblock is N times hotter than the source.'
HFE3581AD2058: '타겟블록이 소스보다 N배 더 자주 실행된다면 명령어를 hoist하지 마십시오.'
# "Do not include PTX for the following GPU architecture (e.g. sm_35) or 'all'. May be specified more than once."
H3358F862A98F: "다음 GPU 아키텍처(예: sm_35) 또는 'all'에 대한 PTX를 포함하지 마세요. 여러 번 지정할 수 있습니다."
# 'Do not include column number on diagnostics'
H6BC5ADEE7CCD: '진단 메시지에 열 번호를 포함하지 마십시오'
# 'Do not include declarations inside namespaces (incl. global namespace) in the code-completion results.'
HB945B735ADE9: '코드 완성 결과에 네임스페이스(전역 네임스페이스 포함) 내의 선언을 포함하지 마십시오.'
# 'Do not include fixit information in diagnostics'
H9F028B9AB9A0: '진단 메시지에 fixit 정보를 포함하지 마세요'
# 'Do not include global declarations in code-completion results.'
H5184034D4282: '코드 완성 결과에 전역 선언문을 포함하지 마십시오.'
# 'Do not include source location information with diagnostics'
HC43E127B525B: '진단 메시지에 소스 위치 정보를 포함하지 마십시오'
# 'Do not include the default HIP wrapper headers and include paths'
HF033C0F0A8BE: '기본 HIP 래퍼 헤더와 포함 경로를 포함하지 마십시오'
# 'Do not inline functions with a stack size that exceeds the specified limit'
HF6E40440F4E2: '스택 크기가 지정된 한계를 초과하는 함수를 인라인하지 마십시오'
# 'Do not inline hlfir.copy_in operations'
H36767557A51A: 'hlfir.copy_in 연산을 인라인하지 않습니다.'
# 'Do not inline recursive functions with a stack size that exceeds the specified limit'
HE8D9228D38D0: '스택 크기가 지정된 한계를 초과하는 재귀 함수는 인라인하지 마십시오'
# 'Do not instrument callsites to functions in this list. Intended for testing.'
HEEE67A6ADD3A: '이 목록에 있는 함수의 호출 지점을 측정하지 않습니다. 테스트를 위해 사용되었습니다.'
# 'Do not instrument functions smaller than this threshold.'
H0676C97A079B: '이 임계값보다 작은 함수에는 도구를 적용하지 마세요.'
# 'Do not instrument functions with the number of critical edges  greater than this threshold.'
HAC5F841AADEE: '이 임계값보다 큰 critical edges 수를 가진 함수에는 인스트루먼트하지 마십시오.'
# 'Do not instrument promotable allocas'
HFE692DA83BC2: '변환 가능한 allocas에 대해 도구를 적용하지 마십시오'
# 'Do not label Edges'
H02B067792434: 'Edges에 레이블을 지정하지 마십시오.'
# 'Do not label Vertices'
HF8CF06D59C0D: '정점을 라벨링하지 마십시오'
# 'Do not let object file auto-link default libraries'
H77A1B6D3EF99: '객체 파일이 기본 라이브러리를 자동으로 연결하지 않도록 하십시오'
# 'Do not link against HIP runtime libraries'
H29FEC2BA3B74: 'HIP 런타임 라이브러리에 링크하지 마십시오'
# 'Do not link device library for CUDA/HIP device compilation'
HEC768FBA7D56: 'CUDA/HIP 장치 컴파일 시 장치 라이브러리를 연결하지 마십시오'
# 'Do not make the jump table addresses canonical in the symbol table'
H6138F7A3816E: '기호 테이블에서 점프 테이블 주소를 표준으로 만들지 마십시오'
# 'Do not modify integer comparisons.'
H85B2E33EE3E8: '정수 비교를 수정하지 마십시오.'
# 'Do not omit the RTTI component from virtual tables'
H29D8FAD7370D: '가상 테이블에서 RTTI 구성 요소를 생략하지 마십시오'
# 'Do not optimize lifetime zones that are broken'
HDB8A084545A8: '고장난 생명 주기 구역을 최적화하지 마세요'
# 'Do not output any .gcov files'
H5B1E0C37199B: 'gcov 파일을 출력하지 않습니다'
# 'Do not override toolchain to compile HIP source to relocatable'
H67099DA33091: '도구체인을 재정의하여 HIP 소스를 재배치 가능 파일로 컴파일하지 마세요'
# 'Do not pack non-contiguous assumed shape dummy arrays into contiguous memory'
HCB4D2BF8E235: '연속되지 않은 가정된 형태의 가짜 배열을 연속 메모리로 패킹하지 않습니다'
# 'Do not place constants in the .rodata section instead of the .sdata if they meet the -G <size> threshold (MIPS)'
H21A91E9ACB5C: '상수를 -G <size> 임계값을 충족할 경우 .sdata 섹션 대신 .rodata 섹션에 배치하지 마세요 (MIPS)'
# 'Do not preserve comments in inline assembly'
H942DAB64A211: '인라인 어셈블리에 있는 주석을 보존하지 마십시오'
# 'Do not prevent DecoderTable duplications caused by HwModes'
H38CABD41B4CC: 'HwModes로 인한 DecoderTable 중복을 방지하지 마십시오.'
# 'Do not print instruction tables'
HF7003F2ECEFB: '지시문 테이블을 출력하지 마십시오'
# 'Do not print per-code histogram'
HC08155C4172C: '각 코드별 히스토그램을 출력하지 않음'
# 'Do not print the name of each compiled file (default)'
H5DF4E1712DEF: '각 컴파일된 파일 이름을 출력하지 않습니다 (기본값)'
# 'Do not process trigraph sequences'
H0D43C57804DE: '삼자문자열을 처리하지 않습니다'
# 'Do not produce relaxation hints for linkers to try optimizing PIC call sequences into direct calls (MIPS only)'
HCE5BC5F9BE43: '링커가 PIC 호출 시퀀스를 직접 호출로 최적화하려는 시도를 위해 완화 힌트를 생성하지 마십시오 (MIPS 전용)'
# 'Do not prune non-affecting module map files when writing module files'
H5ABD84685A1F: '모듈 파일을 작성할 때 영향을 주지 않는 모듈 맵 파일들을 제거하지 마세요'
# 'Do not put each data item in its own section (default)'
HF88D281A3FD5: '각 데이터 아이템을 각각의 섹션에 넣지 마십시오 (기본값)'
# 'Do not put each function in its own section (default)'
HCE20256E9133: '각 함수를 각각의 섹션에 넣지 않음 (기본값)'
# 'Do not re-analyze paths leading to exhausted nodes with a different strategy (may decrease code coverage)'
HDFE0F346053C: '다른 전략으로 고갈된 노드로 가는 경로를 다시 분석하지 마세요(코드 커버리지가 감소할 수 있습니다)'
# 'Do not read real performance counters, use dummy values (for testing)'
H85D51A611E68: '실제 성능 카운터를 읽지 마십시오, 테스트를 위한 더미 값을 사용하십시오'
# 'Do not rebase if number of dependent constants of a Base is less than this number.'
H5F4C154B55E1: 'Base의 종속 상수 개수가 이 숫자보다 작으면 재기반화하지 마십시오.'
# 'Do not record stack ring history'
HFF15CDD011A3: '스택 링 히스토리를 기록하지 마십시오'
# 'Do not remove finalize method in gc mode'
H986F722192B5: 'GC 모드에서 finalize 메소드를 제거하지 마십시오'
# 'Do not remove function attributes'
HAF5DC7041092: '함수 속성은 제거하지 마십시오'
# 'Do not remove global named metadata'
H8C721AA4D60E: '전역 이름 지정 메타데이터를 제거하지 마십시오.'
# 'Do not remove global variables'
H715B487CBBAD: '전역 변수를 제거하지 마십시오.'
# 'Do not remove implausible terminators or other similar cleanups'
HFBFADCCB2615: '불가능한 종료자 또는 유사한 클리닝업을 제거하지 마십시오'
# 'Do not report an error for non-bitcode files in archives'
H656A3544880E: '아카이브 내 비 비트코드 파일에 대해 오류를 보고하지 않습니다'
# 'Do not require member pointer base types to be complete if they would be significant under the Microsoft ABI'
H7A0FDA03C4CD: 'Microsoft ABI 하에서 의미가 있는 경우 멤버 포인터 기본 타입이 완전해야 한다는 요구를 하지 않습니다'
# "Do not resolve lli process symbols in JIT'd code"
HF4ADB638CB76: 'JIT 컴파일된 코드에서 lli 프로세스 심볼을 해결하지 마십시오'
# 'Do not resolve to llvm-jitlink process symbols'
H0C15A19D6DA3: 'llvm-jitlink 프로세스 심볼을 해결하지 마십시오'
# 'Do not run the verifier'
H227D5D3081B9: '검증기를 실행하지 마십시오'
# 'Do not run the verifier during the optimization pipeline'
H812C7F5AE104: '최적화 파이프라인 중에 검증기를 실행하지 마십시오'
# 'Do not run verifier on input LLVM (dangerous!)'
H91033F23321D: 'LLVM 입력에 검증기를 실행하지 마세요 (위험합니다!)'
# 'Do not separate the constant offset from a GEP instruction'
H1A5B4ED53276: 'GEP 명령어에서 상수 오프셋을 분리하지 마십시오'
# 'Do not set the default structure layout to be compatible with the Microsoft compiler standard'
H9523EC62FA32: '기본 구조 레이아웃을 Microsoft 컴파일러 표준과 호환되도록 설정하지 마십시오'
# 'Do not sink instructions that have too many uses.'
H7989366B848B: '사용 횟수가 너무 많은 명령문은沈하하지 마세요.'
# 'Do not sink instructions that require cloning unless they execute less than this percent of the time.'
HFCE852F940A6: '클로닝이 필요한 명령문은 이 백분율보다 적게 실행될 때만 내리세요.'
# 'Do not split loads or stores'
H5C77F77F7EDB: '로드나 스토어를 분할하지 마십시오'
# 'Do not strip debug info metadata'
H72442AB7AE2C: '디버그 정보 메타데이터를 제거하지 마십시오'
# 'Do not strip debug type info metadata'
H773E596FDA32: '디버그 타입 정보 메타데이터를 제거하지 마십시오'
# 'Do not take inbounds assumptions at all'
H3B09FD23C9A9: 'inbounds 가정을 전혀 사용하지 않습니다'
# 'Do not treat C++ operator name keywords as synonyms for operators'
HF45D733F49BB: 'C++ 연산자 이름 키워드를 연산자의 동의어로 간주하지 마십시오'
# 'Do not treat all horizontal whitespace as equivalent'
H821E9671833B: '수평 공백을 모두 동일하게 처리하지 마세요'
# 'Do not treat usage of null pointers as undefined behavior'
H81D67D4AE33E: 'NULL 포인터 사용을 정의되지 않은 동작으로 간주하지 않음'
# 'Do not treat warnings as errors (default)'
H9D2EBEBFE5AF: '경고를 오류로 처리하지 않음 (기본값)'
# 'Do not try to find alias store for a load if the block number in the straight line is higher than this threshold.'
HA9F23FA6536D: '연속된 코드 라인의 블록 번호가 이 임계값보다 높은 경우 로드에 대한 alias 저장을 찾으려고 하지 마세요.'
# 'Do not try to find alias store for a load if there is a in-path block whose instruction number is higher than this threshold.'
H9F8822A4702E: '경로 내 블록 중 이 임계값보다 큰 명령 번호를 가진 것이 있다면 해당 로드에 대한 alias 저장소를 찾지 마십시오.'
# 'Do not use CSPGO.'
HF15B70CBCC17: 'CSPGO를 사용하지 마세요.'
# 'Do not use GP relative accesses for symbols known to be in a small data section (MIPS)'
HD0753F3CDAB8: '소규모 데이터 섹션에 있다고 알려진 심볼에 대해 GP 상대적 접근을 사용하지 마십시오 (MIPS)'
# 'Do not use HLFIR lowering (deprecated)'
HE332EA8EB38E: 'HLFIR lowering을 사용하지 마세요 (비추천)'
# 'Do not use PGO.'
H19DC80776155: 'PGO를 사용하지 마십시오.'
# 'Do not use an early exit if isLiveOutPastPHIs returns true.'
HA74DFEC29B52: 'isLiveOutPastPHIs가 true를 반환하면 조기 종료를 사용하지 마십시오.'
# 'Do not use compact branches if possible.'
H541C69D3E8C0: '가능한 경우 컴팩트 브랜치를 사용하지 마세요.'
# 'Do not use div.w[u] and mod.w[u] instructions with input not sign-extended.'
H5B65DD1D4E29: '부호 확장되지 않은 입력을 사용하는 경우 div.w[u] 및 mod.w[u] 명령어를 사용하지 마십시오.'
# 'Do not use hardware multiplier'
H2D984261D820: '하드웨어 멀티플라이어를 사용하지 마십시오'
# 'Do not use jump tables for lowering switches'
H553BE5736ED7: 'switch를 최적화할 때 jump tables를 사용하지 마십시오.'
# 'Do not use more megabytes of memory'
HABD5A40DFA1B: '메모리 사용량은 %dMB를 초과하지 마십시오.'
# 'Do not use the -dce pass to reduce testcases'
HAA57D41E6E51: '테스트 케이스를 줄이기 위해 -dce 패스를 사용하지 마세요'
# 'Do not use the -simplifycfg pass to reduce testcases'
H29CCC0670DF0: '테스트 케이스를 축소하기 위해 -simplifycfg 패스를 사용하지 마십시오'
# 'Do not use the analyzed objects when unparsing'
H83CE402540D9: '언어 분석된 객체를 언파싱(unparsing) 할 때는 사용하지 마십시오'
# 'Do not use the experimental C++ class ABI for classes with virtual tables'
H6D985C46C06C: '가상 테이블을 가진 C++ 클래스에 대한 실험적 ABI를 사용하지 마세요'
# 'Do not validate testcase is interesting after counting chunks (may speed up reduction)'
HA696CDBE3AE6: 'Chunks를 세고 나서 테스트 케이스가 흥미롭다는 것을 검증하지 마세요 (줄이기 속도를 높일 수 있음)'
# 'Do not verify input module'
H39AA36F540E0: '입력 모듈을 검증하지 않습니다'
# 'Do not warn about individual formatting changes needed. Used only with --dry-run or -n'
H754226DD39F9: '개별 형식 변경 사항에 대해 경고하지 않습니다. 단, --dry-run 또는 -n 옵션과 함께만 사용됩니다.'
# 'Do not write current time into COFF output (breaks link.exe /incremental)'
HBABC5A49FA79: 'COFF 출력에 현재 시간을 쓰지 마십시오 (link.exe /incremental과 호환되지 않음)'
# 'Do not write result bitcode file'
H22D616F37560: '결과 비트코드 파일을 작성하지 마십시오'
# 'Do not zero initialize globals without default initialization'
HECF1970A8089: '기본 초기화 없이 글로벌 변수를 0으로 초기화하지 마십시오'
# 'Do nothing'
HD268BA5209C4: '무언가 하지 않음'
# 'Do profile annotation and inlining for functions in top-down order of call graph during sample profile loading. It only works for new pass manager. '
HF43D143A0C90: '샘플 프로파일 로드 중에 호출 그래프의 상향식 순서에 따라 함수에 대한 프로파일 어노테이션과 인라인을 수행합니다. 이 기능은 새 패스 매니저에서만 작동합니다.'
# 'Do pseudo probe verification'
HC942827254CC: '가상 프로브 검증을 수행합니다'
# 'Do static counter allocation for value profiler'
H465B564B215B: '값 프로파일러를 위한 정적 카운터 할당'
# 'Document only public declarations.'
HAA6808E72416: '공개 선언문만 문서화합니다.'
# 'Documentation in HTML format.'
H35BAD16C1698: 'HTML 형식의 문서'
# 'Documentation in JSON format'
HF1E57A499766: 'JSON 형식의 문서'
# 'Documentation in MD format.'
HA974194AB003: 'MD 형식의 문서입니다.'
# 'Documentation in YAML format.'
H5814855B30B7: 'YAML 형식의 문서.'
# 'Documentation in mustache HTML format'
H1B1C504B8FE0: 'mustache HTML 형식의 문서'
# 'Dominance Frontier Construction'
H0D043E29B031: 'dominance frontier 생성'
# 'Dominator Tree Construction'
HD7B4E93722B4: '지배 트리 구축'
# "Don't Use the new driver for offloading compilation."
H348818D3A16A: '오프로딩 컴파일을 위한 새 드라이버를 사용하지 마십시오.'
# "Don't allow device side init function in HIP (experimental)"
H8D56505F6239: 'HIP에서 디바이스 측 초기화 함수 허용 안 함 (실험용)'
# "Don't allow loop unrolling to simulate more than this number of iterations when checking full unroll profitability"
HA88E0E56432E: '전체 언롤 효과성을 검사할 때 루프 언롤링이 이 수의 반복보다 더 많은 것을 시뮬레이션하도록 허용하지 마십시오'
# "Don't assume assembly file starts in the text section"
HFEF6F05E02CF: '어셈블리 파일이 텍스트 섹션에서 시작한다고 가정하지 마십시오'
# "Don't assume data segments are relative to text segment"
H1D0D36BE1FD6: '데이터 섹션이 텍스트 섹션에 상대적이라는 가정을 하지 마세요'
# "Don't assume that C++'s global operator new can't alias any pointer"
HC32AE2553730: 'C++의 전역 오퍼레이터 new가 어떤 포인터와도 별칭이 될 수 없다고 가정하지 마십시오'
# "Don't assume that kernels are launched with uniform block sizes (default true for CUDA/HIP and false otherwise)"
H328B84E6AEC0: '커널이 일관된 블록 크기로 실행되었음을 가정하지 마십시오 (CUDA/HIP의 기본값은 true이며 다른 경우는 false입니다)'
# "Don't automatically start assembly file with a text section"
HB573B3460C18: '어셈블리 파일을 텍스트 섹션으로 자동으로 시작하지 마세요'
# "Don't clear counters across dumps (use with instrumentation-sleep-time option)"
HFB41C45D3123: '덤프 사이에서 카운터를 지우지 마십시오 (instrumentation-sleep-time 옵션과 함께 사용하십시오)'
# "Don't clear the Clang AST before running backend code generation"
H438A0AAAB7E0: '백엔드 코드 생성을 실행하기 전에 Clang AST를 지우지 마세요.'
# "Don't convert memcpy to TP loop."
H4B53144272CD: 'memcpy를 TP 루프로 변환하지 마십시오.'
# "Don't defer host/device related diagnostic messages for CUDA/HIP"
H9AB401869BF7: 'CUDA/HIP에 대한 호스트/디바이스 관련 진단 메시지를 지연하지 마세요'
# "Don't demangle function names"
H618F1A05266D: '함수 이름을 덤블하지 않음'
# "Don't disable block signature string)"
HD22256B8D923: '블록 서명 문자열을 비활성화하지 마세요)'
# "Don't disable features used for crash debugging (crash reports, llvm-symbolizer and core dumps)"
HA02320B35AF6: 'crash 디버깅에 사용되는 기능( crash 리포트, llvm-symbolizer 및 코어 덤프)을 비활성화하지 마세요.'
# "Don't disable freeing of memory on exit"
HE9E8ABFA5D70: '종료 시 메모리 해제를 비활성화하지 않습니다'
# "Don't discard temporary labels"
H59AD35796471: '임시 라벨들을 버리지 마세요'
# "Don't display class definitions"
HF6C8FDDA5009: '클래스 정의를 표시하지 않습니다'
# "Don't display full enum definitions"
HB5A6C783A07D: '전체 enum 정의 표시하지 않기'
# "Don't do the coverage check."
H193F8F133737: '커버리지 검사를 하지 마세요.'
# "Don't dump anything."
HA287D365311B: '아무것도 dump하지 마십시오.'
# "Don't emit an address-significance table"
H7A772E673769: '주소 의미 표를 생성하지 않음'
# "Don't emit anything (for timing purposes)"
H097B7300276D: '시간 측정을 위해 아무것도 생성하지 않습니다'
# "Don't emit compiler path and command line into CodeView debug information"
H76DE26A5896D: 'CodeView 디버그 정보에 컴파일러 경로와 명령줄을 포함하지 않음'
# "Don't emit errors on invalid analyzer-config inputs"
H344F10286BA2: '무효한 analyzer-config 입력에 대해 오류를 발생하지 않도록 합니다'
# "Don't emit inline line tables."
H18C272BB702A: '인라인 라인 테이블을 생성하지 않습니다.'
# "Don't emit warning for unused driver arguments"
HCD60E199F7C0: '사용되지 않은 드라이버 인수에 대해 경고를 발생하지 않음'
# "Don't emit warnings about unused arguments for the following arguments"
H2C209A90E709: '다음 인수에 대해 사용되지 않은 인수 경고를 발생하지 않도록 합니다'
# "Don't error out if the detected version of the CUDA install is too low for the requested CUDA gpu architecture."
H16AC4195802C: 'CUDA 설치의 감지된 버전이 요청된 CUDA GPU 아키텍처에 대해 너무 낮으면 에러를 발생하지 마십시오.'
# "Don't expand conditional move related pseudos for Mips 16"
H68A3ACC276BC: 'Mips 16용 조건부 이동 관련 의사 명령어를 확장하지 마세요'
# "Don't export branch data (LCOV)"
H15B1E91EF10C: '가지 데이터 내보내기 금지 (LCOV)'
# "Don't export expanded source regions"
H4609EDADC332: '확장된 소스 영역을 내보내지 마십시오'
# "Don't export per-function data"
H2769FE377EEE: '함수별 데이터를 내보내지 마십시오.'
# "Don't extract blocks when searching for miscompilations"
H82D476F902A7: '미스컴파일을 찾을 때 블록을 추출하지 마십시오'
# "Don't extract loops when searching for miscompilations"
H9384DB503321: '미컴필레이션을 찾을 때 루프를 추출하지 마세요'
# "Don't generate implicit floating point or vector instructions"
H54B5124D5D1B: '암시적 부동소수점 또는 벡터 명령어를 생성하지 마세요'
# "Don't generate local calls to out-of-line atomic operations"
H96F508547438: '아웃-오브-라인 원자 연산에 대한 로컬 호출을 생성하지 마십시오'
# "Don't include vectorization factors, etc."
HB5557A169D42: '벡터화 요인 등을 포함하지 마세요.'
# "Don't instrument functions with loops unless they also meet the minimum function size"
H574C69576F45: '루프를 포함하는 함수에는 최소 함수 크기 조건을 만족하지 않는 한 측정 도구를 삽입하지 마세요.'
# "Don't instrument scalar globals"
H6894CA3DD417: '스칼라 글로벌 변수에 측정 도구를 설치하지 마십시오'
# "Don't instrument scalar stack variables"
H87D069F48ECC: '스칼라 스택 변수에 도구를 삽입하지 않음'
# "Don't keep static const variables even if unused"
H286AB8A3B099: '사용되지 않는 static const 변수도 유지하지 마세요'
# "Don't match or outline intrinsics"
H34D78D938C2B: '인트리니스키를 일치시킬 수 없거나 정리하지 않습니다'
# "Don't mutate strict-float node to a legalize node"
H6DCCA4AAE41B: '엄격한 부동소수점 노드를 허용되는 노드로 변환하지 마십시오'
# "Don't output the .ll file"
H1B261E3A62B3: '.ll 파일을 출력하지 마세요'
# "Don't perform type checking of the assembly code (wasm only)"
HDF197C4FAB89: '어셈블리 코드의 형식 검사 비활성화 (wasm 전용)'
# "Don't place zero initialized data in BSS"
H2108D326FE0B: '0으로 초기화된 데이터를 BSS에 두지 마세요'
# "Don't place zero-initialized symbols into bss section"
H6FEBA18EB379: 'BSS 섹션에 제로 초기화된 심볼을 배치하지 마십시오'
# "Don't prefer any addressing mode"
H8ABFDD32EA98: '어떤 주소 지정 방식도 선호하지 마세요'
# "Don't preserve line numbers (default)"
H9468F0C93544: '줄 번호 유지하지 않기 (기본값)'
# "Don't preserve order of LLVM use-lists when serializing"
HC0EBF389C575: '직렬화할 때 LLVM use-lists의 순서를 보존하지 마세요'
# "Don't propagate function-attrs in thinLTO"
HA4C570976962: 'ThinLTO에서 함수 속성을 전파하지 마세요'
# "Don't relax loads to long loads - for testing purposes"
H30C29761BE41: '로드를 long 로드로 완화하지 않음 - 테스트 목적으로'
# "Don't run the LLVM IR verifier pass"
H5E9DB83319CA: 'LLVM IR 검증 패스를 실행하지 마십시오.'
# "Don't run the LLVM verifier during the optimization pipeline"
HBB1839A83C81: '최적화 파이프라인 동안 LLVM 검증기를 실행하지 마세요'
# "Don't show any SymIndexId fields (overrides -hierarchy)"
H9033D913589F: 'SymIndexId 필드를 표시하지 않음 (-hierarchy 옵션을 복盖함)'
# "Don't show compiler generated types and symbols"
H6CE8BA80D4D4: '컴파일러가 생성한 타입과 심볼을 표시하지 않습니다'
# "Don't show symbols from system libraries"
H1D2970DB0285: '시스템 라이브러리의 심볼을 표시하지 않습니다'
# "Don't specialize functions that have less than this number of instructions"
H6394C9853CC0: '이 개수보다 적은 명령문을 가진 함수는 특수화하지 마십시오'
# "Don't specify that kernel argument names are preserved (HIP only)"
H682A59EE1E8F: '커널 인수 이름이 보존되도록 지정하지 마세요 (HIP 전용)'
# "Don't specify that single precision floating-point divide and sqrt used in the program source are correctly rounded (HIP device compilation only)"
HAC5422C51310: '프로그램 소스에서 사용된 단정도 부동소수점 나눗셈과 제곱근 함수가 올바르게 반올림되었다고 지정하지 마세요 (HIP 장치 컴파일 전용)'
# "Don't tail-predicate loops"
H2D6501929AEC: '루프를 꼬리 조건으로 하지 마세요'
# "Don't tail-predicate loops, create scalar epilogue"
H9B8DA5043D54: '루프에 tail-predicate를 사용하지 말고, scalar epilogue를 생성하라'
# "Don't treat conditional branches as disclosure gadgets. This may improve performance, at the cost of security."
H9B8D554F070F: '조건부 분기를 정보 유출 장치로 처리하지 않습니다. 이는 성능을 향상시킬 수 있지만, 보안에 대한 손실을 감수해야 합니다.'
# "Don't treat control flow paths that fall off the end of a non-void function as unreachable"
H5D4780A60912: 'void가 아닌 함수의 끝에서 떨어지는 제어 흐름 경로를 도달할 수 없는 것으로 처리하지 마세요'
# "Don't treat unattributed constexpr functions as __host__ __device__."
HE736239C2F73: '미처분인 constexpr 함수를 __host__ __device__로 취급하지 마십시오.'
# "Don't try to avoid heapifying local blocks"
HA0E5E1480194: '지역 블록의 힙화(heapifying)를 회피하려고 시도하지 마세요'
# "Don't use GOT indirection to reference external data symbols"
H446ED22B127C: '외부 데이터 심볼을 참조할 때 GOT 간접 참조를 사용하지 마십시오.'
# "Don't use LLVM/Offload as portable offloading runtime."
H993CF148793E: 'LLVM/Offload를 이동식 오프로딩 런타임으로 사용하지 마십시오.'
# "Don't use __cxa_atexit for calling destructors"
HB9FAC41CF208: '소멸자를 호출하기 위해 __cxa_atexit를 사용하지 마세요'
# "Don't use a const qualified type for string literals in C and ObjC"
H45BD6EFBF0D7: 'C 및 ObjC에서 문자열 리터럴에 대해 const 자격 증명된 형식을 사용하지 마세요'
# "Don't use a uniquing type map for debug info"
HD459DA46855B: '디버그 정보를 위해 유니크화된 타입 맵을 사용하지 마세요.'
# "Don't use approximate transcendental functions"
H0ED50C803EDB: '근사적인 초월 함수를 사용하지 마세요'
# "Don't use atexit or __cxa_atexit to register global destructors"
HC46180126A88: 'atexit 또는 __cxa_atexit을 사용하여 전역 소멸자를 등록하지 마세요'
# "Don't use constructor homing for debug info"
HD49F3B3625FB: '디버그 정보를 위해 생성자 호밍을 사용하지 마십시오'
# "Don't use ignorelist file for sanitizers"
HFDCDF48F9121: '샌타이저용 ignorelist 파일을 사용하지 마십시오.'
# "Don't use new kernel launching API for HIP"
HFB5E65669ABA: 'HIP용 새로운 커널 실행 API를 사용하지 마십시오'
# "Don't use the new driver for OpenMP offloading."
H301CA6785230: 'OpenMP 오프로딩을 위해 새 드라이버를 사용하지 마세요.'
# "Don't use unique names for text and data sections"
H8E78A20B661E: '텍스트 및 데이터 섹션에 대한 고유한 이름을 사용하지 마세요'
# "Don't verify input files for the modules if the module has been successfully validated or loaded during this build session"
HE1A69C7730A8: '이 빌드 세션 중에 모듈이 성공적으로 검증되거나 로드되었을 경우 모듈에 대한 입력 파일을 검증하지 않습니다.'
# "Don't verify that MIR is fully legal between GlobalISel passes"
H2547A49B1E5F: 'GlobalISel 패스 사이에서 MIR가 완전히 합법화되었는지 확인하지 마세요'
# "Don't work around Cortex-A57 Erratum 1742098 (ARM only)"
H3E4B9BDEA672: 'Cortex-A57 Erratum 1742098를 회피하지 않음 (ARM 전용)'
# "Don't work around Cortex-A72 Erratum 1655431 (ARM only)"
HBBA28409C8FE: 'Cortex-A72 Erratum 1655431 회피하지 않음 (ARM 전용)'
# "Don't work around VLLDM erratum CVE-2021-35465 (ARM only)"
H2D48982037C5: 'VLLDM 오류 수정 CVE-2021-35465를 회피하지 않음 (ARM 전용)'
# "Don't workaround Cortex-A53 erratum 835769 (AArch64 only)"
H674F1B2934BD: 'Cortex-A53 에러타움 835769 회피하지 않음 (AArch64 전용)'
# "Don't write fields with default values"
HDC62F7F06017: '기본값이 있는 필드에 값을 쓰지 마세요'
# "Dot-separated value representing the Microsoft compiler version number to report in _MSC_VER (0 = don't define it (default))"
H3158063BCCC4: 'MSC_VER에 보고할 마이크로소프트 컴파일러 버전 번호를 나타내는 점으로 구분된 값 (0 = 정의하지 않음; 기본값)'
# 'Dr. Watson Assassin.\n'
H2FDABEFA9036: 'Dr. Watson 암살자.\n'
# 'Drop all type test sequences'
HA428B8584F95: '모든 타입 테스트 시퀀스 제거'
# 'Drop the profile symbol list when merging AutoFDO profiles (only meaningful for -sample)'
HF313BEF9935A: 'AutoFDO 프로파일을 병합할 때 프로파일 심볼 목록을 제거 (단, -sample 옵션과 관련됨)'
# 'Drop type test assume sequences'
HB2138C89F2F0: 'type 테스트 가정 시퀀스 제거'
# 'DummyCGSCCPass'
H4B94DA391D3F: '가짜CGSCCPass'
# 'Dump AMDGPU HSA Metadata'
HAD21DA71DA94: 'AMDGPU HSA 메타데이터 덤프'
# 'Dump C11 CodeView debug chunks'
HE18236D9F17D: 'C11 CodeView 디버그 조각 덤프'
# 'Dump C13 CodeView debug chunk subsection'
H0E6AB0F1E2CC: 'C13 CodeView 디버그 청크 하위 섹션 덤프'
# 'Dump CallingContextGraph to stdout after each stage.'
HE2FF79E701CA: '각 단계 후에 stdout에 CallingContextGraph를 덤프합니다.'
# 'Dump IR after transformation happens'
H27451FBBE078: '변환 후 IR을 출력합니다'
# 'Dump IR from modules to stderr on shutdown'
H16357A60101D: '종료 시 모듈에서 IR을 stderr로 내보내기'
# 'Dump IR to reproduce successful transformations.'
H30BFC03DFD55: '성공적인 변환을 재현하기 위해 IR을 dump합니다.'
# 'Dump JITted-compiled object to file <input file>.o'
HCEEB046B9401: 'JIT 컴파일된 객체를 파일 <input file>.o로 내보냅니다'
# 'Dump JITted-compiled object to file specified with -object-filename (<input file>.o by default).'
HF39EA47FD712: 'JIT 컴파일된 객체를 -object-filename 옵션으로 지정된 파일에 덤프합니다. (기본값: <input file>.o)'
# 'Dump MIR with SPIR-V dependencies info'
H3C877ECA1BED: 'SPIR-V 의존성 정보를 포함한 MIR 덤프'
# 'Dump __jit_debug_descriptor contents to stdout'
HEDC251CD7F96: 'stdout에 __jit_debug_descriptor 내용을 출력합니다'
# 'Dump __jit_debug_descriptor in-memory debug objects as tool output'
HEFEA598ED348: '메모리 내 디버그 개체를 도구 출력으로 덤프'
# 'Dump a detailed breakdown of IPI types usage/size'
HE1625844BBC6: 'IPI 유형의 사용량 및 크기에 대한 상세한 분석을 출력합니다'
# 'Dump a detailed breakdown of S_UDT record usage / stats'
HFAECE5B8125B: 'S_UDT 레코드 사용/통계에 대한 자세한 분할을 출력'
# 'Dump a detailed breakdown of symbol usage/size for each module'
HC9A6B5A07738: '모듈별 심볼 사용량/크기별 상세 분류를 출력합니다'
# 'Dump a detailed breakdown of type usage/size'
H55DC9D5447F4: '유형 사용/크기의 상세한 분할을 덤프합니다'
# "Dump all declarations in old header (JSON format) to stdout. If the option is specified, other command options will be ignored. An empty JSON will be returned if old header isn't specified."
H716B07B285CE: '기존 헤더(JSON 형식)에 있는 모든 선언을 표준 출력에 출력합니다. 이 옵션이 지정되면 다른 명령어 옵션이 무시됩니다. 기존 헤더가 지정되지 않았을 경우 빈 JSON이 반환됩니다.'
# 'Dump all records as machine-readable JSON'
HC8D3646E5507: '머신 가독 가능한 JSON 형식으로 모든 레코드를 덤프합니다'
# 'Dump all substituted intrs'
H17F291CCDE2E: '대체된 모든 intrinsic을 덤프합니다'
# 'Dump array types'
H49086B41135B: '배열 유형을 덤프합니다'
# 'Dump binary data from specified range of blocks.'
H84E1DDB15414: '지정된 블록 범위의 이진 데이터를 덤프합니다.'
# 'Dump binary data from specified range of bytes'
H8032C8C6B89F: '지정된 바이트 범위에서 이진 데이터를 덤프합니다'
# 'Dump binary data from specified streams.  Format is SN[:Start][@Size]'
H025773DC5489: '지정된 스트림에서 바이너리 데이터를 덤프합니다. 형식은 SN[:Start][@Size]입니다.'
# 'Dump bytes of PDB Name Map'
HEA0DA34178F3: 'PDB 이름 매핑의 바이트 덤프'
# 'Dump code-completion information at a location'
HAD967F4C2789: '위치에서 코드 완성 정보를 출력합니다'
# 'Dump compiland information'
HC4F8C0431CDD: '컴파일 대상 정보를 덤프합니다'
# 'Dump configuration options to stdout and exit.\nCan be used with -style option.'
HC24D568EFEC0: '설정 옵션을 stdout에 출력하고 종료합니다.\n-style 옵션과 함께 사용할 수 있습니다.'
# 'Dump declarations that are deserialized from PCH, for testing'
HE581DC659FD7: '테스트를 위해 PCH에서 역직렬화된 선언들을 덤프합니다.'
# 'Dump dropped debug variables stats'
H85E673327785: '제거된 디버그 변수 통계 내보내기'
# 'Dump dropped debug variables stats for MIR passes'
HEA66796E7964: 'MIR 패스에 대한 버려진 디버그 변수 통계를 덤프합니다'
# "Dump each stream's block map (implies -stream-metadata)"
H5165BD588D74: '각 스트림의 블록 맵을 dump ( -stream-metadata 옵션을 포함합니다 )'
# 'Dump edit and continue map'
HBCE09E7C4018: '편집 및 계속 맵 덤프'
# 'Dump enum types'
HB104D7EA4F5F: 'enum 타입 덤프'
# 'Dump everything we know how to dump.'
H37AD9BC8A78E: '알 수 있는 모든 dump 정보를 출력합니다.'
# 'Dump exploded graph to the specified file'
H77D296A430F7: '폭발 그래프를 지정된 파일에 출력'
# 'Dump external symbols'
HA768DB613A32: '외부 심볼을 출력합니다'
# 'Dump free page map'
HE90F56D21A38: '무료 페이지 맵 덤프'
# 'Dump function names to stdout.'
H13D3781376F8: '표준 출력(stdout)으로 함수 이름을 내보냅니다.'
# 'Dump function signature information'
H1625F7D7A62D: '함수 시그니처 정보를 덤프합니다'
# 'Dump global symbols'
H4E004D714E1B: '전역 심볼 덤프'
# 'Dump graphs for each function/round in the compilation unit.'
H2EA9EDCA4026: '컴파일 유닛 내 각 함수/라운드마다 그래프를 덤프합니다.'
# 'Dump image section headers'
H01B54D632FED: '이미지 섹션 헤더 덤프'
# 'Dump input on failure'
H6F31E933D50C: '실패 시 입력을 덤프합니다'
# "Dump input to stderr, adding annotations representing\ncurrently enabled diagnostics.  When there are multiple\noccurrences of this option, the <value> that appears earliest\nin the list below has precedence.  The default is 'fail'.\n"
H768FAF2A8E36: "입력 내용을 stderr에 dump하고 현재 활성화된 진단을 나타내는 주석을 추가합니다.\n이 옵션이 여러 번 나타날 경우, 아래 목록에서 가장 먼저 등장하는 <value>가 우선합니다.\n기본값은 'fail'입니다.\n"
# 'Dump list of actions to perform'
HD3BA4698DD33: '실행할 작업 목록을 출력합니다'
# 'Dump low level bitcode trace'
H1754A9E4C373: '저수준 비트코드 추적을 덤프합니다.'
# 'Dump module after Polly transformations into a file suffixed with "-after"'
HDF35672E1E22: 'Polly 변환 후 모듈을 "-after" 접미사가 붙은 파일에 덤프합니다'
# 'Dump module after Polly transformations to the given file'
HFE02E969722D: 'Polly 변환 후 모듈을 지정된 파일에 덤프합니다'
# 'Dump module before Polly transformations into a file suffixed with "-before"'
HF0A6CA5B945A: 'Polly 변환 전 모듈을 -before 접미사가 붙은 파일에 덤프합니다'
# 'Dump module before Polly transformations to the given file'
H3D5A0282D19D: 'Polly 변환 이전에 모듈을 지정된 파일에 덤프합니다'
# 'Dump module info'
H35667204516C: '모듈 정보 dump'
# 'Dump modules to stdout.'
HAFE4570AAD96: '모듈을 표준 출력으로 덤프합니다.'
# 'Dump modules to the current working directory. (WARNING: will overwrite existing files).'
H5DEA08F3B824: '모듈을 현재 작업 디렉토리에 덤프합니다. (경고: 기존 파일을 덮어쓰게 됩니다.)'
# 'Dump new file contents in YAML, if specified.'
H0F661C11A2F3: '지정된 경우 YAML 형식으로 새 파일 내용을 덤프합니다.'
# 'Dump provenance'
H0B7FC19C4E7C: '증분 추적 정보를 출력합니다'
# 'Dump ranges of deserialized declarations to use as bug minimization hints'
HABFDC2505B83: '버그 최소화 힌트로 사용되는 역.Deserialize된 선언 범위를 출력합니다'
# 'Dump record layout information'
H1A9181305386: '레이아웃 정보를 출력합니다'
# 'Dump record layout information for all complete types'
HFF3CB6AA485A: '모든 완전한 타입의 레코드 레이아웃 정보를 덤프합니다'
# 'Dump record layout information in a simple form used for testing'
HEC89F4D9A445: '테스트에 사용되는 간단한 형식으로 레코드 레이아웃 정보를 표시합니다'
# 'Dump record layout information with canonical field types'
H371339BFDE60: '정규 필드 유형을 사용한 레코드 레이아웃 정보 표시'
# 'Dump register information to help debugging'
HA4313634E698: '디버깅을 돕기 위해 리지스터 정보를 덤프합니다'
# 'Dump resource usage at schedule boundary.'
H8B22EBFC198A: '스케줄 경계에서 리소스 사용량을 덤프합니다.'
# 'Dump results in JSON format to stdout.'
H76D763966BEB: '표준 출력으로 JSON 형식으로 결과를 출력합니다.'
# 'Dump section contributions'
HDC1D19FADC7C: '섹션 기여도 덤프'
# 'Dump section map'
HBED8393F6931: '섹션 맵 덤프'
# 'Dump source file info'
H9D1B330F5346: '소스 파일 정보 덤프'
# 'Dump sum of timings for all stacks. By default separates stacks per-thread.'
H39EFC1DB7865: '모든 스택의 타이밍 합계를 출력합니다. 기본적으로 각 쓰레드별로 스택을 분리합니다.'
# 'Dump symbol record substream'
H254B4E85A075: '기호 기록 하위 스트림 덤프'
# 'Dump symbols after the semantic analysis'
HDA7B67B72F4C: '구문 분석 후 기호 덤프'
# 'Dump symbols and the parse tree after the semantic checks'
H8BBAF59A717D: '구문 분석 후 기호와 구문 트리를 덤프합니다'
# 'Dump symbols and their source code locations'
H8E456C399A58: '기호 및 그 소스 코드 위치를 덤프합니다'
# 'Dump templight information to stdout'
H1AD586FAA55A: 'stdout에 templight 정보를 출력합니다'
# 'Dump the DBI Stream Headers (Stream 2)'
H129FA94CBB86: 'DBI 스트림 헤더 덤프 (스트림 2)'
# 'Dump the FIR created by lowering and exit'
H91B777999917: '하향 변환을 통해 생성된 FIR을 덤프하고 종료합니다'
# 'Dump the HLFIR created by lowering and exit'
H2BFC1CB7ACAA: '하위 변환으로 생성된 HLFIR를 덤프하고 종료합니다'
# 'Dump the IPI Stream (Stream 5)'
H0EC59D4B528C: 'IPI 스트림 (Stream 5) 덤프'
# 'Dump the PDB Stream (Stream 1)'
H4577B257A885: 'PDB 스트림 (스트림 1)을 덤프합니다'
# 'Dump the PDB String Table'
H46D5A974F1C3: 'PDB 문자열 테이블을 덤프합니다'
# 'Dump the Publics Stream'
H9A8FF0F8500C: 'Publics 스트림을 덤프합니다'
# "Dump the SCCs in the ThinLTO index's callgraph"
H05F63DC7879B: 'ThinLTO 인덱스의 호출 그래프에 있는 SCCs를 덤프합니다.'
# 'Dump the TPI Stream (Stream 3)'
H838873B9AC8D: 'TPI 스트림 (스트림 3) 덤프'
# 'Dump the compiler configuration options'
H3D1A24CE8D0E: '컴파일러 구성 옵션을 내보냅니다'
# 'Dump the cooked character stream in -E mode'
H7DB9E0B6C82A: '가공된 문자 스트림을 -E 모드에서 덤프합니다'
# 'Dump the coverage mapping records, for testing'
H95CDC790B673: '커버리지 매핑 레코드를 덤프합니다(테스트 용도)'
# 'Dump the dependency graph to dot files.'
HF4BCFC89AF2D: '의존성 그래프를 dot 파일로 덤프합니다.'
# 'Dump the gcov file to stderr'
H58322A4E2763: 'gcov 파일을 stderr에 출력합니다'
# 'Dump the id record with the given type index'
H759F0D055070: '지정된 타입 인덱스에 해당하는 ID 레코드를 내보냅니다'
# 'Dump the layouts of all vtables that will be emitted in a translation unit'
H5286BCB58A1F: '번역 단위에서 생성되는 모든 vtable의 레이아웃을 출력합니다'
# 'Dump the list of input files and their weights, then exit'
HFD20CED5CA14: '입력 파일 목록과 각각의 가중치를 출력한 후 종료합니다'
# "Dump the number of streams and each stream's size"
HD36F7FCDEEBC: '스트림 수와 각 스트림의 크기를 출력'
# 'Dump the parse tree'
H64405164E18C: '문법 트리를 덤프합니다'
# 'Dump the parse tree (skips the semantic checks)'
H65A5DE3C84CD: '해석 트리를 덤프합니다(세미안틱 검사 건너뜀)'
# 'Dump the pre-FIR tree'
H313B5A95699E: 'FIR 이전 트리를 덤프합니다'
# 'Dump the pre-fir parse tree'
HA7DC87D10265: 'pre-fir 단계의 분석 트리를 덤프합니다'
# "Dump the source files that contribute to each module's."
H804482274E2A: '각 모듈에 기여하는 소스 파일들을 출력합니다.'
# 'Dump the type record with the given type index'
H8A9E9857BE0A: '지정된 유형 인덱스와 함께 유형 기록을 덤프합니다'
# 'Dump the unsymbolized profile to the output file. It will show unwinder output for CS profile generation.'
H9822074C616B: '해제된 심볼 프로파일을 출력 파일에 덤프합니다. 이는 CS 프로파일 생성을 위한 언윈더 출력을 표시합니다.'
# 'Dump type server map'
HA60CB6E2EBD6: '타입 서버 맵 덤프'
# 'Dump typedefs'
HB4499E4CA24E: 'typedef 정보 출력'
# 'Dump udt types'
H4EEAE7678976: 'UDT 유형 덤프'
# 'Dump virtual table shapes'
H94754C1D9BD7: '가상 테이블 구조 덤프'
# 'Duplicate the snippet'
HB2CC4A27F6FB: '스니펫을 중복시켰습니다'
# 'During rematerialization for a copy, if the def instruction has many other copy uses to be rematerialized, delay the multiple separate live interval update work and do them all at once after all those rematerialization are done. It will save a lot of repeated work. '
H2B948F8A8B8A: '복사 작업 중 재재료화를 수행할 때, def 명령어가 다른 많은 복사 사용을 재재료화해야 하는 경우, 여러 개별적인 생존 간격 업데이트 작업을 지연시키고 모든 재재료화가 완료된 후에 한 번에 처리하세요. 이렇게 하면 반복 작업을 많이 줄일 수 있습니다.'
# 'Dwarf version'
H5862F01F0C5E: 'DWARF 버전'
# 'Dynamic libraries to load before linking'
H926C9AA42A23: '링킹 전에 불러올 동적 라이브러리'
# 'Dynamic scheduling'
H762ACA0C3351: '동적 스케줄링'
# 'Dynamically link the sanitizer runtime'
HE0360B0DDF0D: '샌타이저 런타임을 동적으로 링크합니다'
# 'EABI GNU'
H7E2A3B789B36: 'EABI GNU'
# 'EABI version 4'
H3C615C59EEA1: 'EABI 버전 4'
# 'EABI version 5'
HDD2C36FB7B3F: 'EABI 버전 5'
# 'Eagerly compute live intervals for all physreg units.'
H8BDCB87E4D2E: '모든 물리 레지스터 단위에 대해 즉시 라이브 인터벌을 계산합니다.'
# 'Eagerly invalidate more analyses in default pipelines'
HC29BAEFB7500: '기본 파이프라인에서 분석을 더 적극적으로 무효화합니다.'
# 'Early CSE'
H7995F9E82B8F: '초기 CSE'
# 'Early CSE w/ MemorySSA'
HA097BFA29921: '초기 CSE와 MemorySSA'
# 'Early If Converter'
HEACD98DB3CB0: '조기 If 변환기'
# 'Early If Predicator'
H3899A5E56B26: '조기 If 예측'
# 'Early Machine Loop Invariant Code Motion'
H93B90001D05A: '초기 머신 루프 불변 코드 이동'
# 'Early Tail Duplication'
H9F05343E7731: '조기 꼬리 복제'
# 'Early expansion of MUX'
HC9BB5C4937A3: 'MUX의 조기 확장'
# 'Element attributes.'
HA3DEA8BD288F: '요소 속성.'
# 'Element debug location.'
HDDAB4BDAA546: '요소 디버그 위치.'
# 'Element declaration and definition references.'
HF82FBA3D05B2: '요소 선언 및 정의 참조.'
# 'Element referenced across Compile Units.'
H6E34E57CF7C6: '요소가 다른 컴파일 유닛에서 참조되었습니다.'
# 'Element referenced only in the Compile Unit.'
HB0C2FAF86940: '컴파일 유닛 내에서만 참조된 요소입니다.'
# 'Element to print.'
H1150FC4D6BB7: '인쇄할 요소.'
# 'Elements to compare.'
H7D8A91E768C7: '비교할 요소들.'
# 'Elide ElementsAttrs with "..." that have more elements than the given upper limit'
HE475543A5C00: '지정된 상한값보다 많은 요소가 있는 ElementsAttrs는 "..."로 생략합니다'
# 'Elide printing value of resources if string is too long in chars.'
H89DF7B30813D: '문자가 너무 길면 리소스의 값 출력을 생략합니다.'
# 'Elide resources when generating bytecode'
HE18501EFA3FF: '바이트코드 생성 시 리소스 생략'
# 'Eliminate PHI nodes for register allocation'
H951E7DE45FDF: '리지스트 할당을 위한 PHI 노드 제거'
# 'Eliminate scalar loop carried dependences'
H57EB486234E9: '스칼라 루프 카리드 의존성을 제거합니다'
# 'Embed DXIL'
H07B28C451A5A: 'DXIL 내장'
# 'Embed LLVM IR bitcode as data'
H595F481498B5: 'LLVM IR 비트코드를 데이터로 내장'
# 'Embed LLVM bitcode'
H4AADB26DC12B: 'LLVM 비트코드 내장'
# 'Embed LLVM bitcode in object files produced by LTO'
H16F1861B6BE7: 'LTO로 생성된 객체 파일에 LLVM 비트코드 내장'
# 'Embed Offloading device-side binary into host object file as a section.'
H5475B2E44660: '호스트 오브젝트 파일의 섹션으로 오프로딩 장치 측 이진 파일을 내장합니다.'
# 'Embed PDB in shader container (ignored)'
HEF26692F47BE: '쉐이더 컨테이너에 PDB 내장 (무시됨)'
# 'Embed after all optimization passes'
HD4E0BFB5C58B: '모든 최적화 패스 이후에 내장'
# 'Embed function arity information into the KCFI patchable function prefix'
H9B1AB0019717: 'KCFI 패치 가능한 함수 접두사에 함수 인자 수 정보를 내장합니다'
# 'Embed placeholder LLVM IR data as a marker'
HCFCB6093DA4B: '플레이스홀더 LLVM IR 데이터를 마커로 내장합니다'
# 'Embed post merge, but before optimizations'
HEA0EFEB4A060: '최적화 전에 포스트 머지 단계를 내장합니다'
# 'Embed source text in DWARF debug sections'
HC2C8736B7263: 'DWARF 디버그 섹션에 소스 텍스트 내장'
# 'Embed the contents of all files read by this compilation into the produced module file.'
HECD9878DE365: '이 컴파일에 의해 읽은 모든 파일의 내용을 생성된 모듈 파일에 내장합니다.'
# 'Embed the contents of the specified file into the module file being compiled.'
H5C7A5481DBF2: '지정된 파일의 내용을 현재 컴파일 중인 모듈 파일에 내장합니다.'
# 'Emit  debug info for defined but unused types'
H4259F2A07B2E: '정의되지만 사용되지 않는 타입에 대한 디버그 정보를 생성합니다'
# 'Emit (experimental) loops (with sparse.iterate).'
H6558C2381246: '실험용 루프 (sparse.iterate를 사용)를 생성합니다.'
# 'Emit .secure_log_unique directives to this filename.'
HA73462D861E9: '이 파일 이름에 .secure_log_unique 지시문을 생성합니다.'
# 'Emit .su file containing information on function stack sizes'
H17B887378AAE: '함수 스택 크기 정보를 포함하는 .su 파일 생성'
# 'Emit AT&T-style assembly'
HED9E24C24759: 'AT&T 스타일 어셈블리를 생성합니다'
# 'Emit Apple-style NEON assembly'
H45694CDA7EC7: 'Apple 스타일 NEON 어셈블리 생성'
# 'Emit Clang AST files for source inputs'
H2EA489E49444: '소스 입력에 대한 Clang AST 파일 생성'
# 'Emit CodeGen Data into custom sections'
H363A7576BA25: '커스텀 섹션에 CodeGen 데이터 생성'
# 'Emit GNU Assembly Syntax on z/OS.'
H56A1FC66D6EC: 'z/OS에서 GNU 어셈블리 구문을 생성합니다.'
# 'Emit GOTPCRELX/REX_GOTPCRELX/CODE_4_GOTPCRELX instead of GOTPCREL on x86-64 ELF'
HA621D70D3E80: 'x86-64 ELF에서 GOTPCREL 대신 GOTPCRELX/REX_GOTPCRELX/CODE_4_GOTPCRELX를 생성합니다'
# 'Emit IR to support LTO unit features (CFI, whole program vtable opt)'
H1C0C26CCDFE7: 'IR을 생성하여 LTO 유닛 기능(CFI, 전체 프로그램 vtable 최적화)을 지원합니다'
# 'Emit Import Call sections on supported targets that can be used by the Windows kernel to enable import call optimization'
HD73224065892: '지원되는 타겟에서 Windows 커널에 의해 import call 최적화를 활성화하기 위해 사용될 수 있는 Import Call 섹션을 생성'
# 'Emit Intel-style assembly'
HD0D98D71E373: '인텔 스타일 어셈블리 생성'
# 'Emit JSON-formatted debug info quality metrics.'
HE95341B061E7: 'JSON 형식의 디버그 정보 품질 지표를 생성합니다.'
# 'Emit LLVM textual assembly'
H5687C7B339C1: 'LLVM 텍스트 어셈블리 생성'
# 'Emit OpenMP code only for SIMD-based constructs.'
H566FF0EF84C2: 'SIMD 기반 구조 전용으로 OpenMP 코드를 생성합니다.'
# 'Emit PCs for atomic operations used by binary analysis sanitizers'
H1D074F0F258F: '원자적 작업을 사용하는 바이너리 분석 정화 도구용 프로그램 카운터를 생성합니다'
# 'Emit PCs for atomic operations.'
H62316BF0E45F: '원자 연산을 위해 PC를 생성합니다.'
# 'Emit PCs for code covered with binary analysis sanitizers'
H3D28246BA2B9: '바이너리 분석 세이프티저로 덮힌 코드에 대한 PCs 생성'
# 'Emit PCs for covered functions.'
H831FD59B3528: '커버된 함수에 대한 PCs 생성합니다.'
# 'Emit PCs for start of functions that are subject for use-after-return checking'
H797088C91ACC: '리턴 후 사용 검사 대상인 함수의 시작 부분에 대한 프로그램 카운터를 생성합니다'
# 'Emit PCs for start of functions that are subject for use-after-return checking.'
HEC66708B7812: '리턴 이후 사용 검사 대상인 함수의 시작 부분에 대한 프로그램 카운터(PCs)를 생성합니다.'
# 'Emit RTTI data (default)'
H28F26C2AAAEF: 'RTTI 데이터를 생성 (기본값)'
# 'Emit R_RISCV_SET_ULEB128/E_RISCV_SUB_ULEB128 if appropriate'
H2DC3F5A68E91: '적절한 경우 R_RISCV_SET_ULEB128/E_RISCV_SUB_ULEB128 생성'
# 'Emit SPIR-V NonSemantic.Shader.DebugInfo.100 instructions'
H3620039F4736: 'SPIR-V NonSemantic.Shader.DebugInfo.100 명령문을 생성합니다'
# 'Emit VPU instructions for VE'
H336AA1A757FD: 'VE용 VPU 명령어 생성'
# 'Emit Windows Control Flow Guard tables and checks'
H2B3A6CDD77E1: 'Windows 제어 흐름 보호 테이블 및 검사를 생성합니다'
# 'Emit Windows Control Flow Guard tables only (no checks)'
H12EF1A548A1C: 'Windows Control Flow Guard 테이블만 생성 (체크 없음)'
# 'Emit Windows EH Continuation Guard tables'
H7CFD101BE344: 'Windows EH Continuation Guard 테이블 생성'
# 'Emit a call to trap function rather than a trap instruction'
H7926ECB4152F: '트랩 명령어 대신 트랩 함수 호출을 삽입'
# 'Emit a compilation database fragment to the specified directory'
HBAB9D592240A: '지정된 디렉토리에 컴파일 데이터베이스 조각을 생성합니다'
# 'Emit a diagnostic when "fast" instruction selection falls back to SelectionDAG.'
H88EB0DEF1034: '빠른 명령어 선택이 SelectionDAG로 되돌아갈 때 진단 메시지를 발생시킵니다.'
# 'Emit a fatal error if format parsing fails'
H0EBAF7E7ADAA: '포맷 해석이 실패하면 치명적인 오류를 발생시킵니다'
# "Emit a native object ('.o') file"
HAE97C70DDD39: '네이티브 오브젝트(.o) 파일을 생성합니다'
# 'Emit a section containing jump table addresses and sizes'
H0281F291EFBA: '점프 테이블의 주소와 크기를 포함하는 섹션을 생성합니다'
# 'Emit a section containing remark diagnostics metadata. By default, this is enabled for the following formats: yaml-strtab, bitstream.'
H75D67E9CFF88: '리마크 진단 메타데이터를 포함하는 섹션을 생성합니다. 기본적으로 다음 형식에서 활성화됩니다: yaml-strtab, bitstream.'
# 'Emit a section containing stack size metadata'
H698AD84DCB32: '스택 크기 메타데이터를 포함하는 섹션을 생성합니다'
# 'Emit a warning if less than N% of records in the input profile are matched to the IR.'
HB962CC606D2C: '입력 프로파일의 레코드 중 IR과 매칭된 것이 N% 미만이면 경고를 발생시킵니다.'
# 'Emit a warning if less than N% of samples in the input profile are matched to the IR.'
HED39F9DCFD05: '입력 프로파일의 표본 중 N% 미만이 IR에 매칭되지 않았을 경우 경고를 표시합니다.'
# 'Emit all declarations, even if unused'
HF5BC1521C99D: '사용되지 않은 선언도 모두 출력합니다'
# 'Emit an address-significance table'
H378504D13B46: '주소 중요성 표를 생성합니다'
# "Emit an assembly ('.s') file"
H34226183B99D: "어셈블리 ('s') 파일을 생성합니다"
# 'Emit an error if a C++ static local initializer would need a guard variable'
HA81110278BFB: '정적 로컬 초기화자가 가드 변수가 필요하면 오류를 발생시킵니다'
# 'Emit analyzer results as errors rather than warnings'
H3B5E1411AD19: '분석기 결과를 경고 대신 오류로 표시합니다'
# 'Emit basic blocks into separate sections'
H67EB14D9E7DC: '독립된 섹션에 기본 블록 생성'
# 'Emit bytecode when generating output'
H6A294EDCD1D8: '출력을 생성할 때 바이트코드를 생성합니다'
# 'Emit call site debug information, if debug information is enabled.'
H4DFAA1C6FE5A: '디버그 정보가 활성화된 경우, 콜 사이트 디버그 정보를 생성합니다.'
# 'Emit code that can be JIT compiled for OpenMP offloading. Implies -foffload-lto=full'
HCB19BAB5F044: 'OpenMP 오프로딩을 위한 JIT 컴파일이 가능한 코드를 생성합니다. 다음 옵션을 포함합니다: -foffload-lto=full'
# 'Emit code that prints the runtime check result dynamically.'
H83A96897A283: '실행 시점 검사 결과를 동적으로 출력하는 코드를 생성합니다.'
# 'Emit codegen data into the object file. LLD for MachO (currently) merges them into default.cgdata.'
HE5A9DF802056: '오브젝트 파일에 codegen 데이터를 생성합니다. LLD for MachO (현재)는 그들을 default.cgdata에 병합합니다.'
# 'Emit codegen data into the object file. LLD for MachO (currently) merges them into the specified <path>.'
HB514733CE70A: '객체 파일에 codegen 데이터를 생성합니다. MachO용 LLD (현재)는 지정된 <path>에 이를 병합합니다.'
# 'Emit colored output (default=autodetect)'
H1C348B34C157: '색상 출력 생성 (기본값=자동 감지)'
# 'Emit compiler path and command line into CodeView debug information'
H252107FF70F1: 'CodeView 디버그 정보에 컴파일러 경로 및 명령 줄을 포함시킵니다'
# 'Emit complete descriptions of template parameters in forward declarations'
H73932760DABC: '전방 선언에서 템플릿 매개변수의 완전한 설명을 생성합니다'
# 'Emit data into separate sections'
HF75AE625B842: '데이터를 별도의 섹션에 생성'
# 'Emit debug info that places array-bounds instrumentation in an inline function called __ubsan_check_array_bounds.'
HCA08BC9E900F: '디버그 정보를 생성하여 배열 경계 감시 장치를 __ubsan_check_array_bounds라는 인라인 함수에 배치합니다.'
# 'Emit debug line info directives only'
HE3308044AB2D: '디버그 라인 정보 지시문만 생성합니다'
# 'Emit debug line number tables only'
H8174B5298FE7: '디버그 라인 번호 테이블만 생성합니다'
# 'Emit emitc.file ops with matching id'
H236B850BC868: '일치하는 ID와 함께 emitc.file ops를 생성합니다'
# 'Emit emptylines and comment lines as skipped regions (only disable it on test)'
H7D7A380200FE: '빈 줄과 주석 줄을 건너뛴 영역으로 생성 (테스트에서는 이를 비활성화할 수 있음)'
# 'Emit error if a specific declaration is deserialized from PCH, for testing'
H2CD80B3DD8B2: 'PCH에서 특정 선언이 역직렬화될 경우 테스트를 위해 오류를 발생시킵니다'
# 'Emit expensive warnings during LLVM IR import (discouraged: testing only!)'
H04DDF8C7828C: 'LLVM IR import 중 비용이 많이 드는 경고를 발생시킵니다 (권장되지 않음: 테스트 용도입니다!)'
# 'Emit extra debug info to make sample profile more accurate'
H367D707A9507: '추가 디버그 정보를 출력하여 샘플 프로파일을 더 정확하게 만듭니다'
# 'Emit final result as bitcode instead of text IR'
H7F4BFD221CF3: '최종 결과를 텍스트 IR 대신 바이트코드로 생성'
# 'Emit full debug info for all types used by the program'
H30220D4F255D: '프로그램이 사용하는 모든 타입에 대해 완전한 디버그 정보를 생성합니다'
# 'Emit functional code (with scf.for/while).'
HB278CDF9ABA9: '기능적 코드 생성( scf.for/while을 사용하여).'
# 'Emit functional code or interfaces (to debug) for sparse loops'
HBDA72C0CBE39: '스파스 루프를 위한 디버깅 목적으로 기능 코드나 인터페이스를 생성합니다'
# 'Emit functions into separate sections'
H09C9B71236EA: '함수를 개별 섹션에 생성합니다'
# 'Emit generic NEON assembly'
H39274034DB2D: '일반 NEON 어셈블리 생성'
# 'Emit hermetic module files (no nested USE association)'
HD5D99550F319: '헤르메틱 모듈 파일을 생성 (중첩된 USE 연관 없음)'
# 'Emit hexagon jump tables in function section'
HEE6DA2F43CCC: '함수 섹션 내에서헥사곤 점프 테이블 생성'
# 'Emit hexagon lookup tables in function section'
H100801A51219: '함수 섹션에 hexagon 룩업 테이블을 생성합니다'
# 'Emit homogeneous prologue and epilogue for the size optimization (default = off)'
H835061FF9BD7: '크기 최적화를 위해 동일한 프롤로그와 에필로그를 생성 (기본값 = 비활성화)'
# 'Emit imports files for distributed backends.'
H99F865E8CA6D: '분산 백엔드용 import 파일을 생성합니다.'
# 'Emit information about accumulator register spills and copies'
H99CD32F2A0A4: '누적기 레지스터 스플리스와 복사에 대한 정보를 생성'
# 'Emit internal instruction representation to assembly file'
H61E38F521500: '어셈블리 파일에 내부 명령어 표현을 출력'
# 'Emit kernels to call ctor/dtor globals.'
HF3F0CC8F9DC0: '생성자/소멸자 글로벌 변수를 호출하기 위한 커널을 생성합니다.'
# 'Emit limited coverage mapping information (experimental)'
H42E2BE163D31: '제한적인 커버리지 매핑 정보를 생성 (실험적)'
# 'Emit log of dataflow analysis. With no arg, writes textual log to stderr. With an arg, writes HTML logs under the specified directory (one per analyzed function).'
HFAAFE42FF67A: '데이터 플로우 분석 로그를 생성합니다. 인수가 없을 경우 텍스트 형식의 로그를 stderr에 작성합니다. 인수가 있을 경우 지정된 디렉토리 하위에 HTML 형식의 로그를 작성합니다(분석된 각 함수마다 하나씩).'
# 'Emit macro debug information'
H5AADCC833ADB: '마크로 디버그 정보를 생성합니다'
# 'Emit metadata containing compiler name and version'
H02D252B322FC: '컴파일러 이름과 버전을 포함하는 메타데이터를 생성'
# 'Emit module hash'
H8D92949B5594: '모듈 해시 출력'
# 'Emit module summary index'
H81A5D22F1814: '모듈 요약 색인을 생성합니다'
# 'Emit native object files'
HD1D98EAD4C67: '원생 오브젝트 파일을 생성합니다'
# 'Emit non-functional but easy-to-read interfaces to debug.'
HFB7CBF2DAD9A: '디버깅을 위해 비기능적이지만 읽기 쉬운 인터페이스를 생성합니다.'
# 'Emit nothing, for performance testing'
H59E0020EF2FE: '성능 테스트를 위해 아무것도 생성하지 않음'
# 'Emit numeric info in dump even if symbolic info is available'
H44DA13315AA2: '기호 정보가 사용 가능하더라도 덤프에 수치 정보를 포함합니다'
# 'Emit output in the selected format if supported'
HDFDB7BBE51F4: '지정된 형식을 지원할 경우 해당 형식으로 출력을 생성합니다'
# 'Emit pretty printed symbol graphs'
H9D5251957AE9: '정돈된 출력 기호 그래프 생성'
# 'Emit pristine LLVM IR from the frontend by not running any LLVM passes at all.Same as -S + -emit-llvm + -disable-llvm-passes.'
H4945F63ADF72: '프론트엔드에서 LLVM 패스를 전혀 실행하지 않아서 순수한 LLVM IR을 생성합니다.-S + -emit-llvm + -disable-llvm-passes와 동일합니다.'
# 'Emit private/local variables as clauses/specifiers on MLIR ops.'
HBCB27910E0F7: 'MLIR 연산에서 개인/지역 변수를 절/지정자로 생성합니다.'
# 'Emit pseudo probes for sample profiling'
HEE6673E22F38: '샘플 프로파일링을 위한 가상 프로브 생성'
# 'Emit pseudo probes to enable PGO profile generation.'
H68FBB431D14A: 'PGO 프로파일 생성을 활성화하기 위해 가짜 탐지기를 생성합니다.'
# 'Emit reproducer on (option: off, crash (default), error, always)'
HA45B571A7690: '재현 파일을 생성합니다 (옵션: off, crash (기본값), error, always)'
# 'Emit section containing metadata on function stack sizes'
H55BB0296572C: '함수 스택 크기 메타데이터를 포함하는 섹션을 생성합니다'
# 'Emit special compound instrumentation for reads-before-writes'
H7C94AB6DD4CB: '읽기-쓰기 전의 특수 복합 인스트루먼테이션 생성'
# 'Emit special debug info to enable PGO profile generation.'
H92226FB5F865: '특수 디버그 정보를 생성하여 PGO 프로파일 생성을 활성화합니다.'
# 'Emit special instrumentation for accesses to volatiles'
H807EB1BCE795: 'volatile에 대한 접근에 대해 특수한 인스트루먼테이션을 생성합니다'
# 'Emit the GNU .debug_macro format with DWARF <5'
H05986F777FFF: 'GNU .debug_macro 형식을 DWARF 5 미만 버전과 함께 생성'
# 'Emit the XCOFF traceback table'
H2AD67289821E: 'XCOFF 추적 백업 테이블을 생성합니다'
# 'Emit the basic block address map section'
HE67CB0846DD5: '기본 블록 주소 맵 섹션을 생성합니다'
# 'Emit the basic block address map section.'
HD66B24BE91BF: '기본 블록 주소 맵 섹션을 생성합니다.'
# 'Emit the specified combiners'
HD6132B919401: '지정된 조합기를 발생시킵니다.'
# 'Emit type record hashes in a .debug$H section'
HE5D98DDE9AE9: '타입 레코드 해시를 .debug$H 섹션에 기록합니다'
# "Emit verbose output about the analyzer's progress"
HF03ADA31D285: '분석기의 진행 상황에 대한 상세한 출력을 생성합니다'
# 'Emit x8 as fp instead of s0'
H88FD472C55F8: 'x8를 fp로 내보내고 s0 대신 사용'
# 'Emit xray_fn_idx section'
HCE1B25AEB13C: 'xray_fn_idx 섹션 생성'
# 'Emits more virtual tables to improve devirtualization'
HEF76217E9284: '더 많은 가상 테이블을 생성하여 디버추얼라이제이션을 개선합니다'
# 'Emulate weak link against library X. Must resolve to a TextAPI file, and all symbols in the interface will resolve to null.'
H1586C40C45A2: '라이브러리 X에 대한 약한 링크를 모방합니다. 해당 파일은 반드시 TextAPI 파일로 해결되어야 하며, 인터페이스 내 모든 심볼은 null로 해결됩니다.'
# 'Emulate weak link against library X. X must point to a TextAPI file, and all symbols in the interface will resolve to null'
HDE0D8058522D: '라이브러리 X에 대한 약한 링크를 모방합니다. X는 TextAPI 파일을 가리켜야 하며, 인터페이스 내의 모든 심볼은 null로 지정됩니다'
# 'Enable -Wall'
HFE182F701ACC: '모든 일반 경고 활성화'
# 'Enable -Wall and -Wextra'
HCCDF3CF2B538: 'Wall 및 Wextra 옵션을 활성화합니다'
# 'Enable -Weverything'
H85639A20AE92: '활성화 -Weverything'
# 'Enable -Wsystem-headers'
HCF6CBF83669C: '-Wsystem-headers 옵션을 활성화합니다'
# 'Enable -Wsystem-headers when building <module>'
H7BD118FCCA2F: '모듈을 빌드할 때 -Wsystem-headers를 사용하도록 설정합니다'
# 'Enable -time-passes memory tracking (this may be slow)'
HCD77711AC848: '메모리 추적을 활성화합니다 -time-passes (이 작업은 느릴 수 있습니다)'
# 'Enable .XOR. as a synonym of .NEQV.'
H26B24A90CE2E: '.XOR.을 .NEQV.의 동의어로 활성화합니다.'
# 'Enable / disable ARM interworking (for debugging only)'
H0E7C6271B7D5: 'ARM 인터워킹 활성화/비활성화 (디버깅을 위해만)'
# 'Enable / disable SVE scalable vectors in Global ISel'
H2EC78B18E661: 'Global ISel에서 SVE 확장 벡터를 활성화 / 비활성화'
# 'Enable / disable promotion of unnamed_addr constants into constant pools'
HFAE28EE53BD3: 'unnamed_addr 상수의 상수 풀 이동 활성화 / 비활성화'
# 'Enable 16-bit types and disable min precision types.Available in HLSL 2018 and shader model 6.2.'
HAAC77E9561C2: '16비트 형식을 활성화하고 최소 정밀도 형식을 비활성화합니다. HLSL 2018 및 쉐이더 모델 6.2에서 사용 가능합니다.'
# 'Enable <feature> in module map requires declarations'
H5C8DA92AFFD8: '모듈 맵에서 <feature>를 활성화하려면 선언문이 필요합니다'
# 'Enable AArch64 SME memory operations to lower to librt functions'
H2DE7C9221C4E: 'AArch64 SME 메모리 연산을 librt 함수로 변환하도록 활성화합니다'
# 'Enable AArch64 logical imm instruction optimization'
H3E7D3BE3C68D: 'AArch64 로직 즉시 명령어 최적화를 활성화합니다'
# 'Enable AMDGPU Alias Analysis'
H6232FED85C51: 'AMDGPU 별칭 분석을 활성화합니다'
# 'Enable AMDGPU function call support'
HA046043EEDCA: 'AMDGPU 함수 호출 지원 활성화'
# 'Enable AMDGPUAttributorPass'
H9BDDE4ABB4D1: 'AMDGPUAttributorPass 활성화'
# 'Enable APX features (EGPR, NDD and NF) for instructions with relocations on x86-64 ELF'
H93395525FD86: 'x86-64 ELF에서 재배치가 있는 명령어에 대해 APX 기능(EGPR, NDD 및 NF)을 활성화합니다.'
# 'Enable ARC-style weak references in Objective-C'
H9B793CE9E824: 'ARC 스타일의 약한 참조를 Objective-C에서 활성화합니다'
# 'Enable ARM load/store optimization pass'
HF1C1057F91DB: 'ARM 로드/스토어 최적화 패스 활성화'
# 'Enable AddressSanitizer'
H10A93E69F908: 'AddressSanitizer 활성화'
# 'Enable AltiVec vector initializer syntax'
H39CF1AD1DDBB: 'AltiVec 벡터 초기화 구문 활성화'
# 'Enable Apple gcc-compatible #pragma pack handling'
HF6255EFF4697: 'Apple gcc 호환적인 #pragma pack 처리 활성화'
# 'Enable BFI update verification for CodeGenPrepare.'
HDEF1BBE64E03: 'CodeGenPrepare에 대한 BFI 업데이트 검증을 활성화합니다.'
# 'Enable C++ builtin type char8_t'
HB51A1047EAD1: 'C++ 내장 형식 char8_t를 사용 가능하게 합니다'
# 'Enable C++ builtin type wchar_t (default)'
H2E6A98E0A8E9: 'C++ 내장 형 wchar_t 활성화 (기본값)'
# 'Enable C++ exceptions'
HD8120A0570B1: 'C++ 예외를 활성화합니다'
# 'Enable C++14 sized global deallocation functions'
HA9B36C7CDED1: 'C++14 크기 지정 전역 할당 해제 함수 활성화합니다'
# 'Enable C++17 aligned allocation functions'
H3A997E1CD1C0: 'C++17 정렬된 할당 함수 활성화'
# 'Enable C-SKY asm compressed instruction'
HE6033CE9D615: 'C-SKY 어셈블리 압축 명령어 활성화'
# 'Enable CABAC instructions'
HCAFDAD7AAC69: 'CABAC 명령어를 활성화합니다'
# 'Enable CREL relocation format (ELF only)'
H0C82A363E7CF: 'CREL 재정의 형식을 활성화 (ELF 전용)'
# 'Enable CodeView debug information in object files'
H190F12E62C0D: '객체 파일에 CodeView 디버그 정보를 사용하도록 합니다'
# 'Enable Control Flow Guard with /guard:cf, or only the table with /guard:cf,nochecks. Enable EH Continuation Guard with /guard:ehcont'
H0DCA490E39F9: 'Control Flow Guard를 /guard:cf로 활성화하거나, /guard:cf,nochecks로 단순히 테이블만 활성화할 수 있습니다. EH Continuation Guard는 /guard:ehcont로 활성화할 수 있습니다.'
# 'Enable CopyToPhi DAG Mutation'
H795903E75A63: 'CopyToPhi DAG 변이 활성화'
# "Enable DAG combiner's use of IR alias analysis"
HEFB2E9C4316E: 'DAG 조합기의 IR 별칭 분석 사용을 활성화합니다'
# "Enable DAG combiner's use of TBAA"
HC13D2DED69A7: 'DAG 조합기의 TBAA 사용을 활성화합니다'
# 'Enable DFA jump threading'
HDA1B9DF0576D: 'DFA 점프 스레딩을 활성화합니다'
# 'Enable DPP combiner'
H1C2845754879: 'DPP 결합기를 활성화합니다.'
# 'Enable Debug Info Metadata preservation testing in optimizations.'
H261A5A2FD07D: '옵티마이제이션에서 디버그 정보 메타데이터 보존 테스트를 활성화합니다.'
# 'Enable Debugger hook for debugging MLIR Actions'
H7236F64CF290: '디버깅을 위해 MLIR 액션의 디버거 훅을 활성화합니다'
# 'Enable EH Asynchronous exceptions'
H2CA5CA1CFDC6: 'EH 비동기 예외 활성화'
# 'Enable EVL-based induction variable simplify Pass'
H0167530440BA: 'EVL 기반의 인덕션 변수 단순화 패스를 활성화합니다.'
# 'Enable FP math optimizations that assume approx func'
HA55AFA6BF75B: '부동소수점 계산 최적화를 활성화(근사 함수 가정)'
# 'Enable FP math optimizations that assume no +-Infs'
H3B25285FD614: '부동소수점 수학 최적화를 활성화하며 ±무한대를 가정하지 않음'
# 'Enable FP math optimizations that assume no NaNs'
H9640D97F95AD: 'NaN이 없음을 가정하는 부동소수점 수학 최적화를 활성화합니다'
# 'Enable FP math optimizations that assume the sign of 0 is insignificant'
HE827F0FDD8E0: '0의 부호가 중요하지 않다고 가정하는 FP 수학 최적화를 활성화합니다'
# 'Enable Fast Math processing'
H2F61C44B4052: '빠른 수학 처리를 활성화'
# 'Enable Freestanding (disable builtins / TLI) during LTO'
H4C62FBB216B5: 'LTO 중 프리스테이딩 활성화 (빌트인/TLI 비활성화)'
# 'Enable GPU Mode managed|unified'
H1342A6457C14: 'GPU 모드 활성화: managed|unified'
# 'Enable Global-ISel Big Endian Lowering'
H51843BE1AC18: 'Global-ISel Big Endian 변환 활성화'
# 'Enable GlobalISel at or below an opt level (-1 to disable)'
HD97724CE8B7C: '옵티마이제이션 레벨 이하에서 GlobalISel 활성화 (-1로 비활성화)'
# "Enable GlobalISel's post-legalizer load/store optimization pass"
H6BA2F1588338: 'GlobalISel의 post-legalizer 로드/스토어 최적화 패스 활성화'
# "Enable GlobalISel's pre-legalizer load/store optimization pass"
H7E199DBC971A: 'GlobalISel의 사전-legalizer 로드/스토어 최적화 패스 활성화'
# 'Enable HIP Standard Parallelism Offload support'
H1C99F32D38F4: 'HIP 표준 병렬화 오프로드 지원 활성화'
# 'Enable HIP acceleration for standard parallel algorithms'
H03CDA0DFF566: '표준 병렬 알고리즘을 위한 HIP 가속을 활성화합니다'
# 'Enable HVX IEEE floating point extensions'
HEDB94BF0B878: 'HVX IEEE 부동소수점 확장 기능을 활성화'
# 'Enable HVX vector combining'
HDFF35C9FE78C: 'HVX 벡터 결합 활성화'
# 'Enable Hexagon HVX IEEE floating-point'
HB190E3ACA8B9: 'Hexagon HVX IEEE 부동소수점 기능을 사용합니다.'
# 'Enable Hexagon HVX QFloat instructions'
HD10ED4BFBA4F: 'Hexagon HVX QFloat 명령어 활성화'
# 'Enable Hexagon SDNode scheduling'
H421486189A34: 'Hexagon SDNode 스케줄링 활성화'
# 'Enable Hexagon Vector eXtensions'
H849D45B20815: 'Hexagon 벡터 확장을 사용합니다'
# 'Enable Hexagon Vector print instr pass'
HF6F3126A4402: 'Hexagon 벡터 인스트럭션 출력 패스 활성화'
# 'Enable Hexagon constant-extender optimization'
HB232046E41EF: 'Hexagon 상수 확장 최적화를 활성화합니다'
# 'Enable Hexagon copy hoisting'
H52502969FA5F: 'Hexagon 복사 끌어올림 기능 활성화'
# 'Enable Hexagon-specific memcpy for volatile destination.'
H37F33A534B6A: 'volatile 목적지에 대한 Hexagon 전용 memcpy 활성화'
# 'Enable IBM XL #pragma pack handling'
H56C08FC94B0D: 'IBM XL #pragma pack 처리를 사용합니다'
# 'Enable ICMP_EQ to ICMP_S(L|G)T conversion.'
H50B860EE6750: 'ICMP_EQ를 ICMP_S(L|G)T 변환으로 활성화합니다.'
# 'Enable JumpTableToSwitch pass (default = off)'
H595911A42177: 'JumpTableToSwitch 패스 활성화 (기본값 = 비활성화)'
# 'Enable KernelAddressSanitizer instrumentation'
HDC17AF33380B: '커널 주소 산사태 인스트루먼테이션 활성화'
# 'Enable KernelHWAddressSanitizer instrumentation'
HE6892C669196: 'KernelHWAddressSanitizer 인스트루멘테이션을 활성화합니다'
# 'Enable KernelMemorySanitizer instrumentation'
H98BCB50602AD: '커널 메모리 산타이저 기능을 활성화합니다'
# 'Enable Key Instructions, which reduces the jumpiness of optimized code stepping (DWARF only). Requires LLVM built with LLVM_EXPERIMENTAL_KEY_INSTRUCTIONS.'
H235B8746F9EA: '최적화된 코드 단계 실행 시 점프 현상을 줄이는 키 명령어를 활성화합니다(DWARF만 해당). LLVM_EXPERIMENTAL_KEY_INSTRUCTIONS 옵션으로 빌드된 LLVM이 필요합니다.'
# 'Enable LSR phi elimination'
H6F6B88180DCF: 'LSR phi 제거 활성화'
# "Enable LTO in 'full' mode"
HDE2B72E90D39: "링크 타임 최적화(LTO)를 'full' 모드로 활성화합니다"
# "Enable LTO in 'full' mode for offload compilation"
H1AD130930D3D: "오프로드 컴파일을 위한 LTO를 'full' 모드로 활성화합니다"
# 'Enable Loongson Advanced SIMD Extension (LASX).'
H8708BF686447: 'Loongson 고급 SIMD 확장(LASX)을 사용하도록 합니다.'
# 'Enable Loongson SIMD Extension (LSX).'
H9319CC082DD4: 'Loongson SIMD 확장(LSX)을 활성화합니다.'
# 'Enable MASM-style hex float initializers (3F800000r)'
H44F2E6A19192: 'MASM 형식의 16진수 부동소수점 초기화자 활성화 (3F800000r)'
# 'Enable MC/DC criteria when generating code coverage'
HDDD25377703C: '코드 커버리지를 생성할 때 MC/DC 기준을 사용합니다'
# 'Enable ML policy for inliner. Currently trained for -Oz only'
H4BD737EDDE37: '인라이너에 대한 ML 정책을 활성화합니다. 현재는 -Oz 옵션에만 훈련되었습니다'
# 'Enable MSA ASE (MIPS only)'
HF57FBC9A1C49: 'MSA ASE 활성화 (MIPS 전용)'
# 'Enable MT ASE (MIPS only)'
H4037C7D0B0DC: 'MT ASE를 활성화 (MIPS 전용)'
# 'Enable Machine Pipeliner for AArch64'
HC2A6D688CFC7: 'AArch64용 Machine Pipeliner 활성화'
# 'Enable Machine Pipeliner for PPC'
H533D989E39D2: '머신 파이플라인러를 PPC에 활성화'
# 'Enable Machine Pipeliner for RISC-V'
H06DAB50244BB: 'RISC-V용 기계 파이프라인 활성화'
# 'Enable MemProf context disambiguation'
H31287310FC75: 'MemProf 맥락 모호성 해소 활성화'
# 'Enable MemProf support for summarizing and cloning indirect calls'
H467E2FD95CC9: 'MemProf 지원을 활성화하여 간접 호출 요약 및 복제를 사용'
# 'Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size'
H305D879EAD05: 'ODR 지시자 전역 변수를 활성화하여 부분적으로 클렌징된 프로그램에서 허위 ODR 위반 보고를 피할 수 있으나, 이진 파일 크기 증가의 비용을 감수해야 합니다'
# 'Enable Objective-C Ivar layout bitmap print trace'
H8E7C0A4EC106: 'Objective-C Ivar 레이아웃 비트맵 프린트 추적을 활성화'
# 'Enable Objective-C exceptions'
HC28B4C97C29D: 'Objective-C 예외를 사용하도록 설정'
# 'Enable Objective-C garbage collection'
HC3AA6362E4C5: 'Objective-C 가비지 컬렉션을 활성화합니다'
# 'Enable OpenACC'
HFA0D5CED023C: 'OpenACC 활성화'
# 'Enable OpenMP support'
HBFD2A2659227: 'OpenMP 지원을 활성화합니다'
# 'Enable OpenMP support with experimental SIMD support'
H3F6D5F2001FE: '실험적인 SIMD 지원을 포함하는 OpenMP 지원을 활성화합니다'
# 'Enable PC tracing in sanitizer coverage'
H63A67D8CBA77: 'pc 추적을 샌다이저 커버리지에 활성화합니다'
# 'Enable PC tracing with guard in sanitizer coverage'
HF28D97CE20BD: 'sanitizer 커버리지에서 보호를 사용한 PC 추적을 활성화합니다'
# 'Enable PGO instrumentation'
H275AC31A4E6B: 'PGO 인스트루먼테이션 활성화'
# 'Enable Passing SSP Canary info in Trackback on AIX'
HF2D40BF85363: 'AIX에서 Trackback에 SSP 캐나리 정보 전달 활성화'
# 'Enable PatchPoint Liveness Analysis Pass'
HC23201EA3F30: 'PatchPoint 생존성 분석 패스 활성화'
# 'Enable PostRA load and store clustering in the machine scheduler'
H7DBDA92CD831: '머신 스케줄러에서 PostRA 로드 및 스토어 클러스터링을 활성화합니다'
# 'Enable Pre-RA optimizations pass'
HBF2BE955A63C: 'Pre-RA 최적화 패스 활성화'
# 'Enable RDF-based optimizations'
HB93D1CE5916C: 'RDF 기반 최적화를 활성화합니다'
# 'Enable SDWA peepholer'
HAA3AA4CDEBA5: 'SDWA 피에홀러를 활성화하세요'
# 'Enable SVE intrinsic opts'
HC49B4494813B: 'SVE 내장 최적화 활성화'
# 'Enable SVR4-style position-independent code (Mips only)'
H39A5D03E5D80: 'SVR4 스타일 위치 독립 코드 활성화 (Mips 전용)'
# 'Enable SWP at Os.'
HE7BF8843A5BE: 'Os에서 SWP 활성화합니다.'
# 'Enable SYCL C++ extensions'
HB66B108F597C: 'SYCL C++ 확장 기능 활성화'
# 'Enable Software Pipelining'
H701BBA1060C2: '소프트웨어 파이프라인 사용'
# 'Enable System z vector language extension'
H0ADCFE4F5EB1: 'System z 벡터 언어 확장을 활성화합니다'
# 'Enable ThinLTO caching.'
H4E40230CBB89: 'ThinLTO 캐싱을 활성화합니다.'
# 'Enable Unroll And Jam Pass'
HC78C6B520033: '언롤 앤 잼 패스 활성화'
# 'Enable V8+ mode, allowing use of 64-bit V9 instructions in 32-bit code'
H51CF3B974577: 'V8+ 모드를 활성화하여 32비트 코드에서 64비트 V9 명령어 사용을 허용합니다'
# 'Enable VGPR liverange optimizations for if-else structure'
H7A56B298E40B: 'if-else 구조의 VGPR 라이프레인지 최적화를 활성화합니다'
# 'Enable VOPD, dual issue of VALU in wave32'
H89877353D212: 'VOPD 활성화, wave32에서 VALU의 중복 실행'
# 'Enable VPlan-native vectorization path with support for outer loop vectorization.'
H5546DBF9A313: 'VPlan 네이티브 벡터화 경로를 활성화하고 외부 루프 벡터화를 지원합니다.'
# 'Enable X86 indirect branch tracking pass.'
H9D4BDB5AD7B9: 'X86 간접 분기 추적 패스를 활성화합니다.'
# 'Enable a 2nd level loop of loop tiling'
HCA8FDA365AE9: '루프 타일링의 2번째 단계 루프를 활성화합니다'
# 'Enable a specific type of debug output (comma separated list of types)'
H3151AFA58B61: '특정 유형의 디버그 출력을 활성화 (유형의 쉼표로 구분된 목록)'
# 'Enable abort calls when "fast" instruction selection fails to lower an instruction: 0 disable the abort, 1 will abort but for args, calls and terminators, 2 will also abort for argument lowering, and 3 will never fallback to SelectionDAG.'
H1EC44B72B380: 'fast instruction selection이 어떤 instruction을 lower하지 못했을 때 abort 호출을 활성화합니다: 0은 abort 비활성화, 1은 args, calls, terminators를 제외한 경우에 abort, 2는 argument lowering시에도 abort, 3은 SelectionDAG로의 fallback 절대로 하지 않음.'
# 'Enable abort calls when "global" instruction selection fails to lower/select an instruction'
HC411401F6CE3: '전역 인스트럭션 선택이 인스트럭션을 하위 변환하거나 선택하지 못할 때 abort 호출을 활성화합니다'
# 'Enable adding flow sensitive discriminators'
H127CCD0CABA6: '플로우 민감 구분자의 추가를 활성화합니다'
# 'Enable adding inline-remark attribute to callsites processed by inliner but decided to be not inlined'
HFF28D2651FAF: '인라인 처리자에 의해 처리된 호출 위치에 대해 인라인되지 않기로 결정된 경우 inline-remark 어트리뷰트를 추가할 수 있도록 활성화'
# 'Enable additional debug output'
HBEA92C1C802B: '추가 디버그 출력 활성화'
# 'Enable address discrimination of function pointers in init/fini arrays'
H45A216E54E14: 'init/fini 어레이에 있는 함수 포인터의 주소 구분을 활성화합니다'
# 'Enable address discrimination of vtable pointers'
H248ADBB468B0: 'vtable 포인터의 주소 차별화를 활성화합니다'
# 'Enable aggressive formation of fused FP ops'
HD91A957036F5: '결합된 부동소수점 연산의 적극적인 형성을 활성화합니다'
# 'Enable aliasing mode in HWAddressSanitizer'
HFC48EEE3F6A8: 'HWAddressSanitizer에서 aliasing 모드를 활성화합니다'
# 'Enable all Clang extensions for OpenMP directives and clauses'
H1D7ED18ACD09: 'OpenMP 지시문과 절을 위한 모든 Clang 확장 기능을 활성화합니다'
# 'Enable all mitigations for Load Value Injection (LVI)'
H62EE869ADC27: 'LVI(로드 값 주입)에 대한 모든 완화 조치를 활성화합니다'
# 'Enable all options'
HEE8F72CD2211: '모든 옵션을 활성화합니다'
# 'Enable all traces.'
H57C177E41601: '모든 추적을 활성화합니다.'
# "Enable alternative token representations '<:', ':>', '<%', '%>', '%:', '%:%:' (default)"
H4DF4837FAB61: "대체 토큰 표현 '<:', ':>', '<%', '%>', '%:', '%:%:'를 활성화합니다 (기본값)"
# 'Enable amcas[_db].{b/h/w/d}'
H63806DAD9D8C: 'amcas[_db].{b/h/w/d}를 활성화합니다'
# 'Enable amdgpu library simplifications'
HECCE410BA86E: 'amdgpu 라이브러리 단순화 기능 활성화'
# 'Enable amswap[_db].{b/h} and amadd[_db].{b/h}'
H8299FC02710F: 'amswap[_db].{b/h}와 amadd[_db].{b/h}를 활성화합니다'
# 'Enable analysis of vscale-relative immediates in LSR'
H82C5A0E019DD: 'LSR에서 vscale-상대적 즉시 값 분석을 활성화합니다'
# 'Enable analyzing function argument and return types for mandatory definedness'
HF2001822C16A: '함수 인자와 반환 타입에 대한 필수 정의성 분석을 활성화합니다'
# 'Enable annotate table jump instruction to correlate it with the jump table.'
HFDE9D12C2ECD: 'jump table과 연관시키기 위해 jump instruction에 annotate를 활성화합니다.'
# 'Enable array bounds checking'
HD533CAFCE917: '배열 경계 확인을 사용합니다'
# 'Enable assumed rank lowering'
H38B9CF78153E: '가정된 랭크 강하 활성화'
# 'Enable atomic operations instrumentation in ThreadSanitizer (default)'
H28E05B9D8B0A: 'ThreadSanitizer에서 원자 연산 악기화를 활성화합니다 (기본값)'
# 'Enable authentication of pointers from GOT (ELF only)'
HEE1192FA1CBD: 'GOT에서의 포인터 인증을 활성화합니다 (ELF에서만)'
# 'Enable auto-vectorization of floatint point types on v68.'
H407986FED01C: 'v68에서 부동 소수점 형식에 대한 자동 벡터화를 활성화합니다.'
# 'Enable basic block tracing in sanitizer coverage'
HB288E3CF4716: '샌타이저 커버리지에서 기본 블록 추적을 활성화합니다'
# 'Enable binary and hex Motorola integers (%110 and $ABC)'
H929D942FA2B2: '모토롤라 형식의 이진 및 16진수 정수 사용을 허용 (%110 및 $ABC)'
# 'Enable binary and hex masm integers (0b110 and 0ABCh)'
H299555A297D6: '이진 및 16진법 masm 정수 활성화 (0b110 및 0ABCh)'
# 'Enable binary output on terminals'
HB1EFC8602261: '터미널에서 이진 출력 활성화'
# 'Enable bottleneck analysis (disabled by default)'
H0EF8CE1914F9: '보틀넥 분석 활성화 (기본값 비활성화)'
# 'Enable branch hint.'
HA68C6AA0EC92: '분 brunch 힌트를 활성화합니다.'
# 'Enable branch prediction'
HA09824F26C29: '가지치기 예측을 활성화합니다'
# 'Enable branch probability info'
HACC86396C5DC: '분기 확률 정보 활성화'
# 'Enable buffer security check (default)'
HC4E83D1F5690: '버퍼 보안 검사 기능을 사용합니다(기본값)'
# 'Enable builtin #include directories even when -nostdinc is used before or after -ibuiltininc. Using -nobuiltininc after the option disables it'
H03545481E610: '내장된 #include 디렉토리를 활성화합니다. -nostdinc 옵션이 -ibuiltininc 옵션 전후에 사용되더라도 유지됩니다. 해당 옵션 이후에 -nobuiltininc 옵션을 사용하면 이를 비활성화합니다'
# 'Enable caret and column diagnostics (default)'
HB9B531DB1BD2: '-caret 및 열 진단 기능을 활성화합니다(기본값)'
# 'Enable casting unknown expression results to id'
H1BB41E97517E: '미지수 표현식 결과를 id로 캐스팅을 허용합니다'
# "Enable cf-protection in 'full' mode"
HB3ADE4BC6E10: '‘full’ 모드에서 cf-protection을 활성화합니다'
# 'Enable chain commoning in PPC loop prepare pass.'
HA72C1C0CBB48: 'PPC 루프 준비 패스에서 체인 커먼링을 활성화합니다.'
# 'Enable char8_t from C++2a'
HE9352E073F40: 'C++2a에서 char8_t 활성화'
# 'Enable checking for cache bank conflicts'
HD40C33D97687: '캐시 뱅크 충돌 검사를 활성화합니다'
# "Enable checking of SDNode's single-use status"
H2C3A08FCCF0D: 'SDNode의 단일 사용 상태 확인을 활성화합니다'
# 'Enable checking of constexpr function bodies for validity within a constant expression context'
HD3707040DC7C: 'constexpr 함수 바디의 유효성을 상수 표현식 컨텍스트 내에서 검사하도록 활성화'
# 'Enable cmp instruction tracing in sanitizer coverage'
H903963183CE2: '_SANITIZER 커버리지에서 cmp 명령어 추적을 활성화합니다'
# 'Enable code sinking'
HC9AEC37E0425: '코드 섭킹을 활성화합니다'
# 'Enable cold function only instrumentation.'
H103EC2AD6CD5: 'cold 함수만의 인스트루먼트 활성화합니다.'
# 'Enable collecting coverage from system headers'
H14D681672737: '시스템 헤더에서 커버리지를 수집하도록 활성화'
# 'Enable colors in diagnostics'
H2602C065FC54: '진단 메시지의 색상 표시 활성화'
# 'Enable command line arguments round-trip.'
H0FC588FEB00A: '명령 줄 인수 원본 그대로 전달을 활성화합니다.'
# 'Enable commoning of GEP instructions'
H21E18391E092: 'GEP 명령문의 공통화를 활성화합니다'
# 'Enable conflict detection in loop-access analysis'
H9866609C7AAA: '루프 액세스 분석에서 충돌 감지를 활성화합니다'
# 'Enable consecutive memop optimization in AArch64PostLegalizerCombiner'
H8A9AB4FF7791: 'AArch64PostLegalizerCombiner 내에서 연속 memop 최적화를 활성화합니다'
# 'Enable continuous instrumentation profiling mode'
HCFE5EA586D23: '연속 인스트루먼테이션 프로파일링 모드를 활성화합니다'
# 'Enable control flow (and PHI) hoisting in LICM'
H655AACCB94AB: 'LICM에서 제어 흐름(및 PHI) 하이스팅을 활성화합니다'
# 'Enable control flow integrity (CFI) checks for cross-DSO calls.'
H65983BF9B362: 'Control Flow Integrity (CFI) 검사를 활성화하여 DSO 간 호출에 대한 검사를 수행합니다.'
# 'Enable control flow structurization into `spirv.mlir.selection` and `spirv.mlir.loop`. This may need to be disabled to support deserialization of early exits (see #138688)'
H34FF13170268: '제어 흐름 구조화를 `spirv.mlir.selection` 및 `spirv.mlir.loop`로 활성화합니다. 조기 종료(early exits)의 역직렬화를 지원하려면 비활성화해야 할 수 있습니다(참조: #138688)'
# 'Enable control height reduction optimization (CHR)'
H0F0478FE42AF: '제어 높이 감소 최적화(CHR)를 사용합니다'
# 'Enable conversion of arithmetic operations to predicate instructions'
H0A4B03E5BC23: '산술 연산을 예측 명령어로 변환을 활성화합니다'
# 'Enable converting conditional transfers into MUX instructions'
HC372E511555B: '조건부 전송을 MUX 명령문으로 변환 활성화'
# 'Enable converting phi types in CodeGenPrepare'
H646E9AD5179B: 'CodeGenPrepare에서 phi 타입 변환을 허용합니다'
# 'Enable crash diagnostic reporting (default)'
H57A29C53DDA2: 'クラッシュ 진단 보고를 사용 (기본값)'
# 'Enable cross-cu references in DWO files'
H371A16C91C53: 'DWO 파일에서 cross-cu 참조를 활성화합니다'
# 'Enable cyclic critical path analysis.'
HF81A62B6A5A8: '순환 비판 경로 분석을 활성화합니다.'
# 'Enable debug info for the debug entry values.'
H62773C4101CF: '디버그 엔트리 값에 대한 디버그 정보를 활성화합니다.'
# 'Enable debug messages while writing module files'
H8923A1076553: '모듈 파일을 작성할 때 디버그 메시지를 활성화합니다'
# 'Enable debug output'
H8FF327476155: '디버그 출력을 활성화합니다'
# 'Enable debug output for only polly passes.'
HBDB1EA3DBD28: 'Polly 패스에 대해서만 디버그 출력을 활성화합니다.'
# 'Enable debugger suppport (default = !-noexec)'
H835D3E853677: '디버거 지원을 활성화합니다(기본값 = !-noexec)'
# 'Enable debugging in the OpenMP offloading device RTL'
H333C6CC1A821: 'OpenMP 오프로딩 디바이스 RTL에서 디버깅을 활성화합니다.'
# 'Enable debuginfod'
H6FC46DBD1099: '디버그인포드 활성화'
# 'Enable deferred inlining'
H2F93ACD0E23A: '지연 인라인 활성화'
# 'Enable dense outer loop sparse parallelization.'
H9C0E69F4C10C: '밀집된 외부 루프 희소 병렬화를 활성화합니다.'
# 'Enable dense parallelization for any loop.'
H966B38C95DEA: '모든 루프에 밀집 병렬화를 활성화합니다.'
# 'Enable detailed timing of insert generation'
H2B4DFBE7DA6E: '삽입 생성의 상세한 타이밍을 활성화합니다'
# 'Enable detection of uninitialized parameters and return values'
H37967C89985E: '미 초기화 매개변수 및 반환 값 감지 기능을 활성화합니다'
# 'Enable device-side debug info generation. Disables ptxas optimizations.'
HBE33969C4B31: '디바이스 측 디버그 정보 생성을 활성화합니다. ptxas 최적화를 비활성화합니다.'
# 'Enable direct TLS access through segment registers (default)'
H6B41286A3288: '세그먼트 레지스터를 통해 직접 TLS 액세스를 활성화 (기본값)'
# 'Enable div instruction tracing in sanitizer coverage'
H70F6EE4DB4D3: '샌타이저 커버리지에서 div 명령 추적을 활성화합니다'
# 'Enable early if-conversion'
HCD88FA9972DA: '조기 if 변환을 활성화'
# 'Enable early if-conversion on X86'
H54EA1744EB53: 'X86에서 조기 if 변환을 활성화합니다'
# 'Enable elimination of non-kernel functions and unused globals'
H565DB5148508: '커널이 아닌 함수와 사용되지 않는 글로벌 변수의 제거를 활성화합니다'
# 'Enable emitting RISC-V ELF attributes for ABI features'
HEE2BA9740DE2: 'ABI 기능을 위한 RISC-V ELF 속성 생성 활성화'
# 'Enable emitting complete constructors and destructors as aliases when possible'
HD806A5232009: '가능한 경우 완전한 생성자와 소멸자를 별칭으로 생성하도록 활성화합니다'
# 'Enable enhanced struct-path aware Type Based Alias Analysis'
HB0D34B7D8979: '개선된 struct 경로 인식 형 기반 별칭 분석을 활성화합니다'
# 'Enable experimental bounds safety extension for C'
H19BF4377E02E: 'C에 대한 실험적 경계 안전 확장 활성화'
# 'Enable experimental late parsing of attributes'
H9BF048F97F63: '실험적 지연 속성 해석을 활성화합니다'
# 'Enable extended information within the SHT_LLVM_BB_ADDR_MAP that is extracted from PGO related analysis.'
H90477C1DC52F: 'PGO 관련 분석에서 추출된 SHT_LLVM_BB_ADDR_MAP 내의 확장 정보를 활성화합니다.'
# 'Enable external API notes support'
H5E8A30586330: '외부 API 노트 지원을 활성화합니다'
# 'Enable fat LTO object support'
H21F1B6309F52: 'FAT LTO 객체 지원을 활성화합니다'
# 'Enable features of APX'
HD328EFFFB9A0: 'APX의 기능을 활성화합니다'
# 'Enable fixed point types'
H0490DFC8424C: '고정 소수점 타입 활성화'
# 'Enable formatting of code changed by applying replacements.\nUse -style to choose formatting style.\n'
H8F0F987DA270: '대체 적용으로 변경된 코드의 포맷팅을 활성화합니다.\n-style 옵션을 사용하여 포맷팅 스타일을 선택합니다.\n'
# 'Enable frame pointer elimination'
HAEAFB8EDDF71: '프레임 포인터 제거를 사용합니다'
# 'Enable frame pointer elimination, but reserve the frame pointer register'
HE8BA912638EF: '프레임 포인터 제거를 활성화하지만, 프레임 포인터 레지스터를 보존합니다.'
# 'Enable frame pointer omission (x86 only)'
H4DBA3F274530: '프레임 포인터 생략을 활성화 (x86 전용)'
# 'Enable frecipe.{s/d} and frsqrte.{s/d}'
H3977CB98EF0D: 'frecipe.{s/d} 및 frsqrte.{s/d} 활성화'
# 'Enable frequency counters in sanitizer coverage'
H5B9962B0B423: '_SANITIZER_COVERAGETracePcCount=1: 산itizer 커버리지에 빈도 카운터를 활성화합니다'
# 'Enable full Microsoft Visual C++ compatibility'
H12B2EDEE6E67: 'Microsoft Visual C++ 완전 호환 모드 활성화'
# 'Enable function entry/exit instrumentation in ThreadSanitizer (default)'
H852113DDBCFA: 'ThreadSanitizer에서 함수 진입/이탈 인스트루먼트 활성화(기본값)'
# 'Enable function merging as part of the optimization pipeline'
H3BF73DD457C7: '최적화 파이프라인의 일부로 함수 병합을 활성화합니다'
# 'Enable function outlining (AArch64 only)'
H15FFCDCECD61: '함수 아웃라인 기능을 사용 (AArch64 전용)'
# 'Enable function specialization on the address of global values'
H46D83DE2E772: '전역 값의 주소에 대한 함수 특수화를 활성화합니다'
# 'Enable garbage-collecting empty basic blocks'
H82096BB5EF83: '비어 있는 기본 블록의 가비지 수집 활성화'
# 'Enable generating trap for unreachable'
HA93A4015EC75: '미달성 가능한 위치에서 트랩 생성을 활성화합니다'
# 'Enable generation of calls to objc_claimAutoreleasedReturnValue'
HBF41104B9A28: 'objc_claimAutoreleasedReturnValue 호출 생성 활성화'
# 'Enable generation of complex instructions'
HD949F4B874C3: '복잡한 명령어 생성을 활성화합니다'
# 'Enable generation of instruction packets'
H9270F92493EE: '지시문 패킷 생성을 활성화합니다'
# 'Enable generation of memop instructions'
HA7AE5A0F239A: 'memop 명령어 생성을 활성화합니다'
# 'Enable generation of new-value jumps'
H88666002BB2B: '새 값 점프 생성을 활성화합니다'
# 'Enable generation of new-value stores'
HE01CC1564066: '새 값 저장소 생성 활성화'
# 'Enable gep instruction tracing in sanitizer coverage'
H24F638FE5491: 'sanitizer coverage에서 gep 명령 추적을 활성화합니다'
# 'Enable global load scalarization'
HEACC856F3BB8: '전역 로드 스칼라화 활성화'
# 'Enable global merge functions that are based on hash function'
H5280CEF67BB7: '해시 함수 기반의 전역 병합 함수를 활성화합니다'
# 'Enable global merge pass on constants'
H16452CA5347D: '상수에 대한 글로벌 병합 패스 활성화'
# 'Enable global merge pass on external linkage'
HB636A98A47D2: '외부 링크지에 글로벌 머지 패스 활성화'
# 'Enable global value internalization in LTO'
HD751EE9A7CD2: 'LTO에서 전역 값 내부화 활성화'
# 'Enable gp-relative addressing of mips small data items'
H4B029B95E3C4: 'mips 소 데이터 항목의 gp 상대 주소 사용 활성화'
# 'Enable hashing of all compiler options that could impact the semantics of a module in an implicit build'
H3D8DF6DE718C: '암시적 빌드 내에서 모듈의 의미론에 영향을 줄 수 있는 모든 컴파일러 옵션의 해시화를 활성화합니다'
# 'Enable hashing the content of a module file'
H181E6C00680E: '모듈 파일의 내용을 해싱하는 기능을 활성화합니다'
# 'Enable heap memory profiling'
H80510263BC9C: '힙 메모리 프로파일링을 사용합니다.'
# 'Enable heap memory profiling and dump results into <directory>'
H29A449A8CDB1: '힙 메모리 프로파일링을 활성화하고 결과를 <directory>에 덤프합니다'
# 'Enable hexagon-qdsp6 backward compatibility'
HC33E9FDD1F01: '헥사곤-QDSP6 하위 호환성 활성화'
# 'Enable hot-cold splitting pass'
H303E669D24AE: '핫-콜드 분할 패스를 사용함'
# 'Enable hot/cold operator new library calls'
HC2E3EA90629E: '핫/콜드 operator new 라이브러리 호출을 활성화합니다'
# 'Enable identical code folding'
H28BAA680F117: '동일 코드 접기를 활성화합니다'
# 'Enable if predication of stores during vectorization.'
HA5E79DD1344A: '벡터화 중 저장의 if 조건부 처리를 활성화합니다.'
# 'Enable if-conversion during vectorization.'
H0446E14EDCAC: '벡터화 중 if-conversion 활성화.'
# 'Enable image intrinsic optimizer pass'
H97E756CD1450: '이미지 인트리니크 최적화 패스 활성화'
# 'Enable implicit vector bit-casts'
HEB80538424B3: '암시적 벡터 비트 캐스트를 활성화합니다'
# "Enable import metadata like 'thinlto_src_module' and 'thinlto_src_file'"
H2A8113D65BE4: "메타데이터(예: 'thinlto_src_module', 'thinlto_src_file')를 import하도록 활성화합니다."
# 'Enable imprecision in EarlyCSE in pathological cases, in exchange for faster compile. Caps the MemorySSA clobbering calls.'
HAA73048B5B86: '극단적인 경우에서 EarlyCSE의 정밀도 감소를 활성화하여 더 빠른 컴파일을 얻습니다. MemorySSA 오염 호출을 제한합니다.'
# 'Enable imprecision in LICM in pathological cases, in exchange for faster compile. Caps the MemorySSA clobbering calls.'
H636968D53932: '극단적인 경우에 LICM의 불확실성을 허용하여 더 빠른 컴파일을 위해. MemorySSA clobbering 호출을 제한합니다.'
# 'Enable incremental processing extensions such as processing statements on the global scope.'
H6BA53F1C325A: '증분 처리 확장 기능(예: 전역 범위에서의 문 처리 등)을 활성화합니다.'
# 'Enable inline 8-bit counters in sanitizer coverage'
H519F01E8620F: '샌타이저 커버리지에 인라인 8비트 카운터를 활성화합니다'
# 'Enable inline bool flag in sanitizer coverage'
HC8EAB045EC47: 'sanitizer coverage에서 inline bool 플래그를 활성화합니다'
# 'Enable inline deferral during PGO'
H66E4DB2AD29F: 'PGO 중 인라인 지연을 활성화합니다'
# 'Enable inliner stats for imported functions'
H0D332728E36F: '수입된 함수에 대한 인라인기 통계를 활성화합니다'
# 'Enable instsimplify'
HB39E8D05245E: 'instsimplify 활성화'
# 'Enable inter-procedural analyses'
H528C6719D608: '인터프로시저 분석 활성화합니다'
# 'Enable interleave MVE vector operation lowering'
H8E26ADE70A0E: '인터리브 MVE 벡터 연산 강하를 활성화합니다'
# 'Enable interprocedural register allocation to reduce load/store at procedure calls.'
H6F0CA76DA224: '프로시저 호출에서 로드/스토어를 줄이기 위해 프로시저 간 레지스터 할당을 활성화합니다.'
# 'Enable ir outliner pass'
H06C93577A2B7: 'IR 아웃라인 패스 활성화'
# 'Enable just-my-code debugging'
H59918B7E8599: '내 코드만 디버깅 활성화'
# 'Enable keeping all variables that have a persistent storage duration, including global, static and thread-local variables, to guarantee that they can be directly addressed'
H04E5C2AB8675: '지속 저장 기간을 가지는 모든 변수(전역, 정적 및 스레드 로컬 변수 포함)를 유지 활성화하여 직접 주소를 참조할 수 있도록 보장합니다'
# 'Enable late function splitting using profile information (x86 and aarch64 ELF)'
H4664498771BF: '프로파일 정보를 사용하여 지연 함수 분할을 활성화합니다 (x86 및 aarch64 ELF)'
# 'Enable lazy compilation when using the MCJIT engine'
H1A4A6063E46C: 'MCJIT 엔진을 사용할 때 지연 컴파일을 활성화합니다'
# 'Enable linker dead stripping of globals in AddressSanitizer'
H9E8C5D19A202: 'AddressSanitizer에서 전역 변수에 대한 링커 사후 정리 기능을 활성화합니다.'
# 'Enable linker job to emit a static library.'
H1300A9593E8D: '링커 작업을 사용하여 정적 라이브러리를 생성하도록 활성화합니다.'
# 'Enable linker relaxation'
H4AD9A11300BE: '링커 관개를 사용합니다'
# 'Enable load and store clustering in the machine scheduler'
H9A7A3DC7E082: '로드 및 스토어 클러스터링을 머신 스케줄러에서 활성화합니다'
# 'Enable load store vectorizer'
H6C9482FFD1BF: '로드/스토어 벡터라이저를 활성화합니다'
# 'Enable logical abbreviations'
H0D1D59444F4E: '논리적 약어를 활성화합니다'
# 'Enable long calls for save-restore stubs.'
H12EA9151A98D: '세이브-리스토어 stubs에 대한 긴 호출을 활성화합니다.'
# 'Enable loop data prefetch on AMDGPU'
H4B4F5CE87A14: 'AMDGPU에서 루프 데이터 예측 읽기를 활성화합니다.'
# 'Enable loop data prefetch on Hexagon'
H90194BED7184: 'Hexagon에서 루프 데이터 프리패치를 활성화합니다'
# 'Enable loop header duplication at any optimization level'
H88A7D3561B15: '모든 최적화 단계에서 루프 헤더 복제를 활성화합니다'
# 'Enable loop interleaving in Loop vectorization passes'
H437D1745A932: 'Loop 벡터화 패스에서 루프 교차를 활성화합니다'
# 'Enable loop iv regalloc heuristic'
H2FAF4EF1BAC2: '루프 IV 레지스터 할당 휴리스틱을 사용합니다'
# 'Enable loop tiling'
HF3F1904F445C: '루프 타일링을 사용합니다'
# 'Enable loop vectorizer for HVX'
H0E3AC61CFA2F: 'HVX용 루프 벡터라이저를 활성화합니다'
# 'Enable lower module lds pass'
H5FAE08416AEA: 'lower 모듈 lds 패스 활성화'
# 'Enable lowering interleaved accesses to intrinsics'
H848C570E6895: '_INTRINSICS에 대한 교차 접근을 저수준 연산으로 변환을 활성화합니다'
# 'Enable lowering math functions to their corresponding MASS (scalar) entries'
H87849497C3F3: '수학 함수를 해당하는 MASS(스칼라) 항목으로 변환을 활성화합니다.'
# 'Enable lowering of lds to global memory pass and asan instrument resulting IR.'
H778C2CAE9787: 'lds를 전역 메모리 패스로 변환 및 asan 도구를 적용한 결과 IR 활성화'
# 'Enable lowering of the matrix intrinsics'
HFC73281BE936: '행렬 인트리니크 변환 활성화'
# 'Enable machine DCE inside regalloc'
H59DAE158F032: '레지스터 할당 내에서 머신 DCE를 활성화합니다'
# 'Enable machine block placement based on the ext-tsp model, optimizing I-cache utilization.'
HE6CB65616359: '확장-TSP 모델에 기반한 머신 블록 배치를 활성화하여 I-캐시 효율을 최적화합니다.'
# 'Enable masked loads/stores for HVX'
H9199C5705B41: 'HVX용 마스킹된 로드/스토어 활성화'
# 'Enable matrix data type and related builtin functions'
H43FB20CC8C7B: '매트릭스 데이터 유형 및 관련된 빌트인 함수를 활성화합니다'
# 'Enable max stack depth tracing'
H509FC7F703A3: '최대 스택 깊이 추적을 활성화합니다'
# 'Enable mcount instrumentation'
H29618381AE6B: 'mcount 인스트루먼트 활성화'
# 'Enable mcount instrumentation with prof'
H0C1503D1A868: 'prof를 사용하여 mcount 인스트루먼트 활성화'
# 'Enable memcpyopt even when libcalls are disabled'
HF4D685F00134: 'libcalls가 비활성화된 경우에도 memcpyopt를 활성화합니다'
# 'Enable memop clustering.'
H4CE08B6CBECC: 'memop 클러스터링을 활성화합니다.'
# 'Enable memory access instrumentation in ThreadSanitizer (default)'
H40FD5983A03D: 'ThreadSanitizer에서 메모리 액세스 인스트루먼트를 활성화(기본값)'
# 'Enable merging Loop End and Dec instructions.'
H2EA5947F6FF8: 'Loop End 및 Dec 명령어의 병합을 활성화합니다.'
# 'Enable merging of globals'
H626AD7B90529: '전역 변수 병합 활성화'
# 'Enable merging of redundant sexts when one is dominating the other.'
H1BD2BF0E8B4D: '중복된 sext를 하나가 다른 것을 지배할 때 병합하도록 활성화합니다.'
# 'Enable mips16 constant islands.'
HC33E1B95CA7C: 'mips16 상수 섬 활성화'
# 'Enable mips16 hard float.'
H077B35DE76F5: 'mips16 하드 부동소수점을 활성화합니다.'
# 'Enable missed optimization remarks from passes whose name match the given regular expression'
H5892F9670CED: '지정된 정규식과 일치하는 이름을 가진 패스에서 놓친 최적화 메모를 활성화합니다'
# 'Enable mode register pass'
H1263C2240107: '모드 레지스터 패스 활성화'
# 'Enable module inliner'
H809D724384CF: '모듈 인라이너를 활성화'
# 'Enable module-based external API notes support'
HAD6C2BA49C14: '모듈 기반 외부 API 노트 지원을 활성화합니다'
# 'Enable modules for C++'
HBB0113F4D937: 'C++ 모듈을 활성화합니다'
# 'Enable name/filename string compression'
H9667A6AB14A5: '이름/파일 이름 문자열 압축 활성화'
# 'Enable non legal immediates (for testing purposes only)'
H2DA699F30B71: '비허용 즉시 값 허용 (테스트 목적으로만)'
# 'Enable odd single-precision floating point registers'
H6A9DE1E88E0D: '홀수 단정밀도 부동소수점 레지스터를 활성화합니다'
# 'Enable on-demand initialization of thread-local variables'
H7700944705A7: '스레드 로컬 변수의 요청에 따른 초기화 활성화'
# 'Enable only control-flow mitigations for Load Value Injection (LVI)'
HF9542EDE9001: '로드 값 주입(LVI)에 대해 제어 흐름 완화만 활성화합니다'
# 'Enable operand tree forwarding'
HB93EA483D9C3: 'операнд 트리 전달 활성화'
# 'Enable optimization analysis remarks from passes whose name match the given regular expression'
H2B83EB5BDF40: '지정된 정규 표현식과 이름이 일치하는 패스에서 최적화 분석 주석을 활성화합니다'
# 'Enable optimization of existing hot/cold operator new library calls'
H7F82E9E27CD9: '기존 hot/cold operator new 라이브러리 호출에 대한 최적화를 활성화합니다'
# 'Enable optimization remarks from passes whose name match the given regular expression'
H2198D7418FE6: '지정된 정규표현식과 일치하는 이름을 가진 패스의 최적화 주석을 활성화합니다'
# 'Enable optimizations'
H5D736AD67AD6: '최적화를 사용합니다'
# 'Enable optimizations based on strict aliasing rules'
HCF0A62237B7C: '엄격한 별칭 규칙에 기반한 최적화를 활성화합니다'
# "Enable optimizations based on the strict definition of an enum's value range"
H186F36BCDB9E: '열거형의 값 범위의 엄격한 정의에 기반한 최적화를 활성화합니다'
# 'Enable optimizations based on the strict definition of flexible arrays.'
H63F456F0E338: '유연한 배열의 엄격한 정의를 기반으로 한 최적화 활성화'
# 'Enable optimizations based on the strict rules for overwriting polymorphic C++ objects'
H13CA0465139C: '다형성 C++ 객체 덮어쓰기에 대한 엄격한 규칙을 기반으로 최적화를 활성화합니다'
# 'Enable optimizations on complex GEPs'
H50EEF415122A: '복잡한 GEP에 대한 최적화 활성화'
# 'Enable optimizations that may decrease FP precision'
H67D78B43979D: 'FP 정밀도 감소 가능 최적화 활성화'
# 'Enable optimized register allocation compilation path.'
H0059F32A3970: '최적화된 레지스터 할당 컴파일 경로를 활성화합니다.'
# 'Enable or disable Control Flow Guard checks and guard tables emission'
H20C0331A083C: 'Control Flow Guard(CFG) 검사 및 가드 테이블 생성을 활성화 또는 비활성화합니다'
# 'Enable origins tracking in MemorySanitizer'
H2743C4FAB786: 'MemorySanitizer에서 오리진 추적을 활성화합니다'
# 'Enable overlapping among matches in a group of consecutive\nCHECK-DAG directives.  This option is deprecated and is only\nprovided for convenience as old tests are migrated to the new\nnon-overlapping CHECK-DAG implementation.\n'
HA5495662EA0A: '연속된 CHECK-DAG 지시문 그룹 내에서 매치 간의 중첩을 활성화합니다.\n이 옵션은 비추천되며, 구 테스트가 새로운 중첩되지 않는 CHECK-DAG 구현으로 마이그레이션되는 동안 편의를 위해 제공됩니다.\n'
# 'Enable parser support for the __unknown_anytype type; for testing purposes only'
H4226A11EC54A: '__unknown_anytype 유형에 대한 파서 지원을 활성화합니다; 테스트 용도로만 사용 가능합니다'
# 'Enable partial store merging in DSE'
HEF8E935B1092: 'DSE에서 부분 저장 병합 활성화'
# 'Enable partial-overwrite tracking in DSE'
H4283D5D63662: 'DSE에서 부분 덮어쓰기 추적을 활성화합니다'
# 'Enable pass to eliminate conditions based on linear constraints'
H59888AB6AA6D: '조건을 선형 제약 조건에 따라 제거하는 패스를 활성화합니다.'
# 'Enable perf profiling support'
H6FDDBD2502B8: 'perf 프로파일링 지원을 활성화합니다'
# 'Enable phi-translation of add instructions'
H2871DDB08B81: '덧셈 명령어에 Phi 번역 기능을 활성화합니다'
# 'Enable placement of extracted cold functions into a separate section after hot-cold splitting.'
HC9DB0E175EB1: 'hot-cold 분할 후 추출된 cold 함수를 개别的 섹션에 배치하도록 활성화합니다.'
# 'Enable pointer authentication intrinsics'
H367806655729: '포인터 인증 인트린스믹 활성화'
# 'Enable poisoning array cookies when using custom operator new[] in AddressSanitizer'
HC79D664C6E42: 'AddressSanitizer에서 커스텀 연산자 new[]를 사용할 때 배열 쿠키의 오염을 활성화합니다'
# 'Enable pre-link mode optimizations'
H20BCBBC300E0: '프리-링크 모드 최적화를 활성화합니다'
# 'Enable precise memory mode (AMDGPU only)'
HE9548687DBB5: '정확한 메모리 모드를 사용함 (AMDGPU 전용)'
# 'Enable predefined and command line preprocessor macros'
H69A47E977056: '미리 정의된 및 명령 줄 전처리기 매크로를 활성화합니다'
# 'Enable predefined target OS macros'
H9D44D77675A5: '사전 정의된 대상 OS 매크로를 활성화합니다'
# 'Enable profile hotness information in diagnostic line'
H6ECB1E31250D: '진단 라인에 프로파일 핫니스 정보를 활성화합니다'
# 'Enable profile instrumentation sampling (default = off)'
H16EB6D513222: '프로파일 인스트루먼테이션 샘플링을 활성화합니다 (기본값 = 비활성화)'
# 'Enable promoting aligned anyext load to wider load'
H1CA89F41F132: 'aligned anyext load를 더 넓은 로드로 최적화 활성화'
# 'Enable promotion of flat kernel pointer arguments to global'
H4206A6231E2E: '플랫 커널 포인터 인수를 글로벌로 승격 활성화'
# 'Enable quadword atomics ABI on AIX (AIX PPC64 only). Uses lqarx/stqcx. instructions.'
H01E0F762B340: 'AIX에서 쿼드워드 원자성 ABI 사용을 활성화합니다 (AIX PPC64 전용). lqarx/stqcx 명령문을 사용합니다.'
# 'Enable raw string literals'
H8C8B44AEB3E9: '원시 문자열 리터럴을 활성화합니다'
# 'Enable reassociation of accumulation chains'
H35D68C90E430: '누적 체인의 재결합 활성화'
# 'Enable reciprocal sqrt optimization'
H6556F5DE61D3: '역제곱근 최적화를 활성화합니다'
# 'Enable recognition of non-constant strided pointer induction variables.'
H95B2F8C1B69F: '비상수 스트라이드 포인터 유도 변수의 인식을 활성화합니다.'
# 'Enable recovery for specified sanitizers'
H2A20F3F3EA12: '지정된 세이프티 체크에 대한 복구 기능을 활성화합니다'
# 'Enable recovery mode (continue-after-error).'
HBD337CDF104A: '회복 모드를 사용합니다(continue-after-error).'
# 'Enable regalloc advisor mode'
H7AE29F2A8C3F: 'regalloc諮問 모드를 활성화합니다'
# 'Enable register pressure scheduling.'
HC0DF1D86F80E: '레지스터 압력 기반 스케줄링을 사용합니다.'
# 'Enable register reassign optimizations on gfx10+'
H2EA748D732DD: 'gfx10+에서 레지스터 재할당 최적화를 활성화합니다'
# 'Enable register tiling'
H02ACF2158ECD: '리지스터 타일링 활성화'
# 'Enable relocating counters at runtime.'
H1C98545F997D: '런타임 시 카운터 재배치를 활성화합니다.'
# 'Enable removal of functions when theyuse features not supported by the target GPU'
HA60D39957FD6: '타겟 GPU에서 지원하지 않는 기능을 사용할 때 함수 제거를 활성화합니다'
# 'Enable required s_wait_alu on SGPR hazards'
H5931DB0CC40E: 'SGPR hazards 시 필요한 s_wait_alu 활성화'
# 'Enable rewrite partial reg uses pass'
HC2E09FB1800A: '부분 등록 사용 재작성 패스 활성화'
# 'Enable runtime checks for stack overflow.'
H20B19FA46C02: '스택 오버플로우를 위한 런타임 검사 기능을 활성화합니다.'
# 'Enable runtime interleaving until load/store ports are saturated'
H83E188A2297B: '런타임 교차 실행을 활성화하여 로드/스토어 포트가 포화 상태가 될 때까지'
# 'Enable s_delay_alu insertion'
H8A9476D62164: 's_delay_alu 삽입을 활성화합니다'
# 'Enable safe identical code folding'
H31D3779CB68C: '안전한 동일 코드 폴딩 활성화'
# 'Enable sample-based profile guided optimizations'
H96541402ED68: '샘플 기반 프로파일 가이드 최적화를 활성화합니다'
# 'Enable sanitizer coverage for indirect calls'
HB591DDDA07BD: '간접 호출에 대한 산타이저 커버리지 활성화'
# 'Enable sanitizer for supported offloading devices'
HFDA0060284A3: '지원되는 오프로딩 장치에 대한 샌타이저 활성화'
# 'Enable sanitizer statistics gathering.'
HC1E74A5D06CE: '샌타이저 통계 수집을 활성화합니다.'
# 'Enable sc.q instruction.'
H657B7BD0EB9D: 'sc.q 명령어를 활성화합니다.'
# 'Enable scalar IR passes'
HD2045AE5F150: '스칼라 IR 패스 활성화'
# 'Enable scheduling addi instruction as earlyas possible post ra'
H3324B351B51A: 'RA 후 addi 명령어의 스케줄링을 최대한 빨리 활성화'
# 'Enable scheduling after register allocation'
H142271112BA0: '레지스터 할당 후 스케줄링 활성화'
# 'Enable scheduling for macro fusion.'
H3396D13A8F30: '매크로 퓨전 스케줄링을 활성화합니다.'
# 'Enable select to branch optimizations'
H7DB0FCE3CF68: 'select를 branch로 변환하는 최적화를 활성화합니다'
# 'Enable setting constant bits to reduce size of mask immediates'
HD06E3ECAB947: '상수 비트 설정을 활성화하여 마스크 즉시 값의 크기를 줄입니다'
# 'Enable setting lr as a predicate in tail predication regions.'
H5D3D99EE631D: '테일 예측 영역에서 lr을 예측자로 설정을 활성화합니다.'
# 'Enable setting the FP exceptions build attribute not to use exceptions'
H29262DC5BE27: 'FP 예외 빌드 속성을 설정하여 예외를 사용하지 않도록 합니다'
# 'Enable shared library instrumentation with XRay'
HBB7CC7BAF352: 'XRay로 공유 라이브러리 인스트루먼테이션을 활성화합니다'
# 'Enable signing and authentication of all indirect calls'
H85AEAA3DF7E2: '모든 간접 호출의 서명 및 인증을 활성화합니다'
# 'Enable signing and authentication of indirect goto targets'
H7778174B9D56: '간접 goto 대상의 서명 및 인증 활성화'
# 'Enable signing and authentication of return addresses'
HB69C655EC5B4: '리턴 주소의 서명 및 인증을 활성화합니다'
# 'Enable signing of function pointers in init/fini arrays'
HF447A017CA1C: '초기화/종료 배열 내의 함수 포인터 서명 활성화'
# 'Enable simple copy propagation during register reloading'
HB0CCABAD4B9C: '리지스터 재로딩 중 간단한 복사 전파를 활성화합니다'
# 'Enable single byte coverage'
HCE6038C8EF64: '단일 바이트 커버리지 기능을 활성화합니다'
# 'Enable sinking and folding of instruction copies'
HAFBBC2D2907E: '명령 복사의 sinking 및 folding 활성화합니다'
# 'Enable sinking and/cmp into branches.'
HC2C79127C7B6: '싱킹 및 and/cmp 연산자를 분기로 이동하도록 활성화합니다.'
# 'Enable some non conforming code to compile'
H97500F6CC226: '비준수 코드의 컴파일을 허용합니다'
# 'Enable some traditional CPP emulation'
H86897CE40B49: '일부 전통적인 CPP 에뮬레이션을 활성화합니다'
# 'Enable sparse parallelization for any storage and loop.'
H86D1CE3B297F: '모든 저장소 및 루프에 대해 희소 병렬화를 활성화합니다.'
# 'Enable sparse parallelization regardless of storage for the outer loop.'
HD78181DC6B92: '외부 루프의 저장 공간과 무관하게 희소 병렬화를 활성화합니다.'
# 'Enable special debugger support behavior'
H526152B74AA2: '특수 디버거 지원 동작을 활성화합니다'
# 'Enable special debugger support for Objective-C subscripting and literals'
H40F60E7DDF05: 'Objective-C의 서브스크립팅 및 리터럴에 대한 특수 디버거 지원을 활성화합니다'
# 'Enable specialization of functions that take a literal constant as an argument'
H8CB997684347: '리터럴 상수를 인자로 받는 함수의 특수화를 활성화합니다'
# 'Enable specifying registers without the % prefix'
H4FA626EAB19A: '레지스터를 % 접두사 없이 지정하는 것을 활성화합니다'
# 'Enable speculative execution side effect suppression (SESES). Includes LVI control flow integrity mitigations'
H8F91025B1797: '예측 실행 부작용 억제(SESES) 활성화. LVI 제어 흐름 무결성 완화 조치를 포함합니다'
# 'Enable spilling SGPRs to VGPRs'
HBC64889F75D9: 'SGPRs를 VGPRs로 스필링을 활성화합니다'
# 'Enable spilling VGPRs to AGPRs'
HCAAEDB0207AA: 'VGPRs를 AGPRs로 스파일링을 활성화합니다'
# 'Enable spills from gpr to vsr rather than stack'
H93A49F7D7A81: 'gpr에서 vsr로 스파일을 생성할 때 스택 대신 허용'
# 'Enable spills in prologue to vector registers.'
H14C00957A630: '프롤로그에서 벡터 레지스터에 대한 스파일을 활성화합니다.'
# 'Enable splitting large offset of GEP.'
HC17E8C448D7B: 'GEP의 큰 오프셋 분할을 활성화합니다.'
# 'Enable splitting of a ThinLTO LTOUnit'
HD2FEBF5117B2: 'ThinLTO LTOUnit 분할 활성화'
# 'Enable stack clash protection'
HD6B8B4D2B61B: '스태킹 클래시 보호 기능을 활성화합니다'
# 'Enable stack frame shrink wrapping'
H96A0AAD52568: '스택 프레임 축소 감싸기를 활성화합니다'
# 'Enable stack probes'
H2C8F59EB6B80: '스택 프로브 활성화'
# 'Enable stack protectors'
H92CD4261F56E: '스택 보호기를 활성화합니다'
# 'Enable stack protectors for all functions'
H4AAD4C1AF839: '모든 함수에 스택 보호기 활성화'
# 'Enable stack protectors for some functions vulnerable to stack smashing. Compared to -fstack-protector, this uses a stronger heuristic that includes functions containing arrays of any size (and any type), as well as any calls to alloca or the taking of an address from a local variable'
H01F993B30A66: '스택 스매시에 취약한 특정 함수에 스택 보호기를 활성화합니다. -fstack-protector와 비교했을 때, 이 옵션은 어떠한 크기(또는 타입)의 배열을 포함하는 함수, 또는 alloca 호출, 지역 변수의 주소 취득을 포함하는 경우 더 강력한 휴리스틱을 사용합니다.'
# "Enable stack protectors for some functions vulnerable to stack smashing. This uses a loose heuristic which considers functions vulnerable if they contain a char (or 8bit integer) array or constant sized calls to alloca , which are of greater size than ssp-buffer-size (default: 8 bytes). All variable sized calls to alloca are considered vulnerable. A function with a stack protector has a guard value added to the stack frame that is checked on function exit. The guard value must be positioned in the stack frame such that a buffer overflow from a vulnerable variable will overwrite the guard value before overwriting the function's return address. The reference stack guard value is stored in a global variable."
H216044E73536: '스택 스크래시에 취약한 일부 함수에 대해 스택 보호기를 활성화합니다. 이는 함수가 ssp-buffer-size보다 큰 크기(char 또는 8비트 정수 배열 또는 고정 크기의 alloca 호출)를 가지면 취약하다고 간주하는 느슨한 휴리스틱을 사용합니다. (기본값: 8바이트). alloca의 모든 가변 크기 호출은 취약하다고 간주됩니다. 스택 보호기가 있는 함수는 스택 프레임에 검사 값을 추가하며, 이 값은 함수 종료 시 확인됩니다. 이 보호 값은 취약한 변수에서 발생한 버퍼 오버플로가 함수의 반환 주소보다 먼저 이 보호 값을 덮어쓰도록 스택 프레임 내에 위치해야 합니다. 참조 스택 보호 값은 전역 변수에 저장됩니다.'
# 'Enable static hinting of branches on ppc'
H1318D7CF750E: 'ppc에서 브랜치의 정적 힌팅을 활성화합니다'
# 'Enable statistics output from program (available with Asserts)'
H7E1E434B51DE: '프로그래밍에서 통계 출력을 활성화 (Asserts 활성화 시 사용 가능)'
# 'Enable stress test of coldcc by adding calling conv to all internal functions.'
H864C98F93D8C: 'coldcc의 스트레스 테스트를 활성화하기 위해 모든 내부 함수에 호출 규약을 추가합니다.'
# 'Enable stricter verification with -verify-scev is passed'
HA0BAD2CA5C13: '-verify-scev 옵션이 전달되면 더 엄격한 검증을 활성화합니다'
# 'Enable string pooling (default)'
H01420F7F4ED8: '문자열 풀링을 활성화합니다 (기본값)'
# 'Enable subreg liveness tracking'
H59D79C24D746: '서브레지스터 활성 추적을 활성화합니다'
# 'Enable subregister liveness tracking for SystemZ (experimental)'
H278D5FB962A3: 'SystemZ용 하위 레지스터 활성 추적을 활성화합니다 (실험적)'
# 'Enable subregister liveness tracking.'
HA8D796B2328B: '서브레지스터 생존 추적을 활성화합니다.'
# 'Enable support for exception handling'
HFB1350CAA576: '예외 처리를 위한 기능을 사용합니다'
# 'Enable support for ignoring exception handling constructs'
H1F7624DB7FC3: '예외 처리 구문 무시를 지원합니다'
# 'Enable support for int128_t type'
H8EC6E7CC318F: 'int128_t 타입에 대한 지원을 활성화합니다'
# 'Enable support for the C++ Coroutines'
H7925EA35B0A4: 'C++ Coroutines 지원을 활성화합니다'
# 'Enable symbolic stride memory access versioning'
H614C3C8C780E: '심볼릭 스트라이드 메모리 액세스 버전화를 활성화합니다'
# 'Enable tail-predication, but not for reduction loops'
H7759A373B899: '꼬리 예측을 활성화하지만, 리덕션 루프에는 적용하지 않음'
# 'Enable tail-predication, but not for reduction loops, and force this which might be unsafe'
HEC8679DD9C06: 'tail-predication을 활성화하지만 reduction 루프에는 적용하지 않으며, 안전하지 않을 수 있으나 강제 적용합니다'
# 'Enable tail-predication, including reduction loops'
H9E0011DEC062: '꼬리 예측을 활성화하며 감소 루프를 포함합니다'
# 'Enable tail-predication, including reduction loops, and force this which might be unsafe'
H65CA4B853D34: '테일 예측화를 활성화하며 감소 루프를 포함하며, 이는 안전하지 않을 수 있으나 강제 적용합니다'
# 'Enable that single precision floating-point divide and sqrt used in '
H40916D94286B: '단정도 부동소수점 나눗셈과 제곱근을 사용하도록 활성화합니다. '
# 'Enable the "fast" instruction selector'
HB827608C6F32: '"빠른" 명령어 선택기를 활성화합니다'
# 'Enable the "global" instruction selector'
HC28B60B42675: '"global" 명령어 선택기를 활성화합니다'
# "Enable the 'blocks' language feature"
H8A0F69B5F85C: '‘blocks’ 언어 기능을 활성화합니다'
# "Enable the 'modules' language feature"
H047278B48AFB: "'모듈' 언어 기능을 활성화합니다"
# 'Enable the AArch64 branch target pass'
H288D5F3BECED: 'AArch64 분기 대상 패스를 활성화합니다'
# 'Enable the AIX Extended Altivec ABI.'
H2F5C4C6F1979: 'AIX 확장된 Altivec ABI를 활성화합니다.'
# 'Enable the CCMP formation pass'
HD0F0CA1649A7: 'CCMP 형성 패스를 활성화합니다'
# 'Enable the GVN hoisting pass (default = off)'
HEAFC22E87450: 'GVN hoisting 패스 활성화 (기본값 = 비활성화)'
# 'Enable the GVN sinking pass (default = off)'
H58E31BED29F9: 'GVN sinking 패스를 활성화합니다 (기본값 = off)'
# 'Enable the IR outliner on linkonceodr functions'
H040BEC05F858: 'linkonceodr 함수에서 IR 아웃라인러 사용을 활성화합니다'
# 'Enable the LoopFlatten Pass'
HAC22881851DD: 'LoopFlatten 패스를 활성화합니다'
# 'Enable the LoopInterchange Pass'
HDD03023B6FBB: 'LoopInterchange 패스를 활성화합니다'
# 'Enable the OpenMP region merging optimization.'
HE96DB2508A4B: 'OpenMP 영역 병합 최적화를 활성화합니다.'
# 'Enable the Polly DOT printer in -O3'
H4E0A173B05AF: 'Polly DOT 프린터를 -O3에서 활성화합니다'
# 'Enable the Polly DOT printer in -O3 (no BB content)'
HEAA8FA2DC249: '옵션 -O3에서 Polly DOT 프린터를 활성화 (BB 내용 없음)'
# 'Enable the RISC-V VL Optimizer pass'
HC773BD141E4D: 'RISC-V VL 최적화 패스를 활성화합니다'
# 'Enable the VR4300 mulmul bug fix.'
HF647968864FA: 'VR4300 mulmul 버그 수정을 활성화합니다.'
# 'Enable the X86 cmov-to-branch optimization.'
HA57709995537: 'X86 cmov-to-branch 최적화를 활성화합니다.'
# 'Enable the abort'
HF630F0E0D97E: '강제 종료를 활성화합니다'
# 'Enable the attributor inter-procedural deduction pass'
HC3A4293C13B2: '_ATTRIBUTOR 절차 간 추론 패스를 활성화합니다'
# 'Enable the condition optimizer pass'
H9D8DD66B429A: '조건 최적화 패스 활성화'
# 'Enable the conditional branch tuning pass'
H08843D4DB1BA: '조건부 분기 최적화 패스를 활성화합니다'
# 'Enable the copy propagation with AArch64 copy instr'
H7A7BF4C2FF44: 'AArch64 copy instruction을 사용하여 copy propagation 활성화'
# 'Enable the copy propagation with RISC-V copy instr'
H8FDD7DCFE43D: 'RISC-V 복사 명령어를 사용하여 복사 전파를 활성화합니다'
# 'Enable the cost-benefit analysis for the inliner'
H4A32DF87AC31: '인라인러에 대한 비용-효용 분석을 활성화합니다'
# 'Enable the early if converter pass'
HC1AB5BB544BB: '초기 if 변환기 패스를 활성화합니다'
# 'Enable the experimental Loop Versioning LICM pass'
HAC7286F63BD3: '실험적인 Loop Versioning LICM 패스를 활성화합니다'
# 'Enable the experimental new constant interpreter'
HA94181FC4D28: '실험적 새로운 상수 해석기를 활성화합니다'
# 'Enable the extended Altivec ABI on AIX. Use volatile and nonvolatile vector registers'
H6369C2DE5BEE: 'AIX에서 확장 Altivec ABI를 활성화합니다. volatile 및 nonvolatile 벡터 레지스터를 사용하십시오.'
# 'Enable the generation of 4-operand madd.s, madd.d and related instructions.'
H2954D704DCA6: '4-operand madd.s, madd.d 및 관련 명령어의 생성을 활성화합니다.'
# 'Enable the generation of WLS loops'
HB0BD6C355304: 'WLS 루프 생성을 활성화합니다'
# 'Enable the generation of masked gathers and scatters'
H69417D79F86A: '마스킹된 gathers 및 scatters 생성을 사용합니다'
# 'Enable the generation of masked loads and stores'
H8811F179AC8C: '마스킹된 로드와 스토어 생성을 활성화합니다'
# 'Enable the global merge pass'
HF3A16D1A310B: '전역 병합 패스를 활성화합니다'
# 'Enable the initializes attr improvement in DSE'
H2C13638D3B7A: 'DSE의 initializes attr 개선을 활성화합니다'
# 'Enable the integrated assembler'
H6897999B76AE: '통합 어셈블러를 사용합니다'
# 'Enable the legacy pass manager. This is strictly for bugpoint due to it not working with the new PM, please do not use otherwise.'
H4ACF17F9F060: '레거시 패스 매니저를 사용하도록 합니다. 이 옵션은 bugpoint와 새 PM이 호환되지 않기 때문에 bugpoint를 위해만 사용되도록 하며, 다른 용도로는 사용하지 마십시오.'
# 'Enable the live debug variables pass'
H97C40BB61A18: '실행 중인 디버그 변수 패스를 활성화합니다'
# 'Enable the load/store pair optimization pass'
HAF961AA83173: '로드/스토어 쌍 최적화 패스를 활성화합니다'
# 'Enable the loop data prefetch pass'
H1F5F62A8C420: '루프 데이터_PREFETCH 패스를 활성화합니다'
# 'Enable the loop interchange pass'
HACD3CEF0E137: '루프 교환 패스를 활성화합니다'
# 'Enable the loop vectorization passes'
HD80457B01B02: '루프 벡터화 패스를 활성화함'
# 'Enable the machine combiner pass'
H6170C8360FA8: '머신 결합기 패스를 활성화합니다'
# 'Enable the machine instruction scheduling pass.'
H5ED9F17A2AD8: '머신 인스트럭션 스케줄링 패스를 활성화합니다.'
# 'Enable the machine outliner'
H6AA5708D3CBD: '머신 아웃라이너를 활성화합니다'
# 'Enable the machine outliner on linkonceodr functions'
HC9ED1CD426C7: 'linkonceodr 함수에서 머신 아웃라인러를 활성화합니다'
# 'Enable the new pass manager'
H93E040EA4A3C: '새 패스 매니저를 활성화합니다'
# 'Enable the new, experimental LoopDistribution Pass'
H349A804BD347: '새로운 실험적인 LoopDistribution 패스를 활성화합니다'
# 'Enable the old style PARAMETER statement'
H17563270F079: '구식 PARAMETER 문을 활성화합니다'
# 'Enable the pass that emits the linker optimization hints (LOH)'
HA4C27576F1AF: '링커 최적화 힌트(LOH)를 생성하는 패스를 활성화합니다'
# 'Enable the pass that removes dead definitions and replaces stores to them with stores to the zero register'
HB91327722E91: '사용되지 않는 정의를 제거하고, 그 정의에 대한 저장을 제로 레지스터에 대한 저장으로 대체하는 패스를 활성화합니다'
# 'Enable the pass that removes dead definitions and replaces stores to them with stores to x0'
H3F4AC3AD0D0C: '패스를 활성화하여 사용되지 않는 정의를 제거하고, 그들을 가리키는 스토어를 x0 스토어로 대체합니다'
# 'Enable the pass that removes dead definitons and replaces stores to them with stores to r0'
H8430D489B8AD: '사용되지 않는 정의를 제거하고 그들에게 저장하는 것을 r0에 저장하는 것으로 대체하는 패스를 활성화합니다'
# 'Enable the polly optimizer (with -O1, -O2 or -O3)'
H2F44BA5CB43F: 'Polly 최적화기 활성화 (-O1, -O2 또는 -O3와 함께)'
# 'Enable the post-ra machine instruction scheduling pass.'
H81A625E2EDC2: 'RA 후 기계 명령어 스케줄링 패스를 활성화합니다.'
# 'Enable the profile guided size optimizations. '
HD0F54569CD57: '프로파일 기반 크기 최적화를 활성화합니다. '
# 'Enable the promote constant pass'
H39117666C528: '상수 증폭 패스를 활성화합니다'
# 'Enable the redundant copy elimination pass'
HCC7E809780AA: '_REDUNDANT_COPY_ELIMINATION 패스를 활성화합니다'
# 'Enable the scheduler to generate .cur'
H9F36FFDB648E: '스케줄러가 .cur를 생성하도록 허용합니다.'
# 'Enable the specified remark'
HF163370BA2BE: '지정된 주석을 활성화합니다'
# 'Enable the specified warning'
HB465ABA562BF: '지정된 경고를 활성화합니다'
# 'Enable the superword-level parallelism vectorization passes'
H03A53AF6091A: '초워드 수준 병렬성 벡터화 패스를 활성화합니다'
# 'Enable the tile register allocation pass'
H8BFDE65405FB: '타일 레지스터 할당 패스를 활성화합니다'
# 'Enable the use of AA during codegen.'
H330FE8DFBA44: '코드 생성 중 AA 사용을 활성화합니다.'
# 'Enable the use of TLS Descriptors'
HC87014CCBA07: 'TLS Descriptors 사용 활성화'
# 'Enable the use of the block frequency analysis to access PGO heuristics minimizing code growth in cold regions and being more aggressive in hot regions.'
H6383E4E8CC05: '블록 빈도 분석을 사용하도록 하여 PGO 휴리스틱이 차가운 영역에서의 코드 성장 최소화 및 뜨거운 영역에서의 공격적 최적화를 수행하게 합니다.'
# 'Enable the use of the block frequency analysis to reduce the chance to execute const materialization more frequently than without hoisting.'
H05FE62E1BC2A: 'hoisting을 하지 않았을 때보다 const materialization이 더 자주 실행될 가능성을 줄이기 위해 블록 빈도 분석을 사용하도록 활성화합니다.'
# 'Enable the vectorisation of loops with in-order (strict) FP reductions'
HC23A0D871AA8: '순차적(엄격한) 부동소수점 리덕션을 갖는 루프의 벡터화를 활성화합니다'
# 'Enable the wasm-opt optimizer (default)'
H66A2CFFFDC43: 'wasm-opt 최적화기를 활성화합니다 (기본값)'
# 'Enable the widening of global strings to alignment boundaries'
HEA83816331AB: '전역 문자열을 alignment 경계에 맞춘 확장 기능을 활성화합니다'
# 'Enable the workaround for OCL name mangling mismatch.'
H76DA67C39D2D: 'OCL 이름 매글링 불일치를 위한 워크라운드를 활성화하십시오.'
# 'Enable thread-safe initialization of static variables'
H50C0425B9069: '정적 변수의 스레드 안전한 초기화를 활성화합니다'
# 'Enable threadgroup split execution mode (AMDGPU only)'
H94C846ABEAAC: '쓰레드 그룹 분할 실행 모드를 활성화합니다 (AMDGPU 전용)'
# 'Enable timing class latency'
H68F7539AA86E: '타이밍 클래스 지연 활성화'
# 'Enable timing of insert generation'
HF299FBD7AEA4: '삽입 생성 시간 측정을 활성화합니다'
# 'Enable tls optimization peephole'
H5607F3078246: 'tls 최적화 피홀 기능을 사용합니다'
# 'Enable tracing of loads'
HFCB6983FD21E: '로딩 추적을 활성화합니다'
# 'Enable tracing of stores'
HE51956EA02F1: '저장 추적 활성화'
# 'Enable trapping for all sanitizers'
H797FF784214D: '모든 산이타이저에 트래핑 활성화'
# 'Enable trapping for specified sanitizers'
H8D7750937E63: '지정된 정화기의 트래핑을 활성화합니다'
# 'Enable traps on authentication failures'
HB1958D1E9CCE: '인증 실패 시 트랩 활성화'
# 'Enable treating throwing global C++ operator new as always returning valid memory (annotates with __attribute__((returns_nonnull)) and throw()). This is detectable in source.'
H98A09520B600: '예외를 던지는 전역 C++ operator new를 항상 유효한 메모리를 반환하는 것으로 처리하도록 활성화 ( __attribute__((returns_nonnull)) 및 throw() 어노테이션을 추가합니다). 이 옵션은 소스 코드에서 감지할 수 있습니다.'
# 'Enable trigraphs'
HD29B31F12F2E: '트리그라프를 사용합니다'
# 'Enable two-phase name lookup in templates'
H808ED9B492E8: '템플릿에서 이상위 이름 검색을 활성화합니다'
# 'Enable two-round ThinLTO code generation. The first round emits codegen data, while the second round uses the emitted codegen data for further optimizations.'
H4183BCD4B48B: '두 단계 ThinLTO 코드 생성을 사용합니다. 첫 번째 단계는 코드 생성 데이터를 생성하고, 두 번째 단계는 생성된 코드 생성 데이터를 추가 최적화에 사용합니다.'
# 'Enable type and address discrimination of vtable pointer of std::type_info'
H10834C3F61A6: 'std::type_info의 가상 테이블 포인터의 타입과 주소 구분을 활성화'
# 'Enable type discrimination of vtable pointers'
H5E406CE94798: '가상 테이블 포인터의 타입 구분을 활성화합니다'
# 'Enable type discrimination on C function pointers'
HB262A3E07E79: 'C 함수 포인터에 대한 타입 구분 활성화'
# 'Enable unsafe double to float shrinking for math lib calls'
HADD895A7C263: '수학 라이브러리 호출에 대한 안전하지 않은 double에서 float로의 축소 사용'
# 'Enable unswitch cost multiplier that prohibits exponential explosion in nontrivial unswitch.'
H05E336233C05: '비트리비얼한 unswitch에서의 지수 폭발을 방지하는 unswitch 비용 곱을 활성화합니다.'
# 'Enable unwind v2 (epilog) information for x64 Windows'
H53CAE0AFFD48: 'x64 Windows용 unwind v2(에필로그) 정보 활성화'
# 'Enable use of AA during MI DAG construction'
H13EA04236348: 'AA를 MI DAG 구축 중 사용 가능하게 함'
# 'Enable use of AdvSIMD scalar integer instructions'
H2C1BB8E0F766: 'AdvSIMD 스칼라 정수 명령어 사용을 허용'
# 'Enable use of GPR32 in inline assembly for APX'
HD4DD583F3412: 'APX용 인라인 어셈블리에서 GPR32 사용 가능하게 함'
# 'Enable use of TBAA during MI DAG construction'
H8EF1EE9B884D: 'MI DAG 생성 중 TBAA 사용 활성화'
# 'Enable use of a base pointer for complex stack frames'
H6F6CB09044A3: '복잡한 스택 프레임에 대한 기저 포인터 사용을 활성화합니다'
# 'Enable use of builtin functions'
H6E647497900D: '내장 함수 사용을 활성화합니다'
# 'Enable use of experimental RISC-V extensions.'
H16ED2241C9C1: '실험적인 RISC-V 확장 기능의 사용을 허용합니다.'
# 'Enable use of hot hints (only supported for unambigously hot allocations)'
H80EB4017A5F5: '핫 힌트의 사용을 활성화합니다 (단, 의심의 여지 없는 핫 할당에 대해서만 지원됩니다)'
# 'Enable use of the DWARFv5 DW_OP_convert operator'
H68201FB3FEC3: 'DWARFv5 DW_OP_convert 연산자의 사용을 활성화합니다'
# 'Enable use of the MCJIT object caching'
H8DEBC9578EBC: 'MCJIT 객체 캐시 사용을 활성화합니다'
# 'Enable use-after-destroy detection in MemorySanitizer'
H9D193DAF1144: 'MemorySanitizer에서 사용 후 해제 검출을 활성화합니다'
# 'Enable use-after-scope detection in AddressSanitizer'
H57E5EACCD6DF: 'AddressSanitizer 내에서 use-after-scope 감지를 활성화합니다'
# 'Enable using coldcc calling conv for cold internal functions'
H2D564DBF6E20: 'coldcc 호출 규약을 cold 내부 함수에 사용하도록 활성화'
# 'Enable using library calls for save and restore'
H5D8D6E37F3DB: '라이브러리 호출을 사용한 저장 및 복원을 활성화합니다.'
# 'Enable value profiling'
HC22D05737DD8: '값 프로파일링을 활성화합니다'
# 'Enable vec acc forwarding'
H5E7B35E50AEB: 'vec acc 전달을 활성화합니다'
# 'Enable vec alu forwarding'
HB58D78835B76: '벡터 ALU 전달을 사용합니다'
# 'Enable vectorization for wider vector utilization'
HA93E4FD1B769: '더 넓은 벡터 활용을 위해 벡터화를 사용합니다'
# 'Enable vectorization of early exit loops with uncountable exits.'
H5BAE1D5D430F: '비측정 가능한 출구를 가진 조기 종료 루프의 벡터화를 활성화합니다.'
# 'Enable vectorization of epilogue loops.'
H633875436202: '에필로그 루프의 벡터화를 활성화합니다.'
# 'Enable vectorization on interleaved memory accesses in a loop'
HAC5648620E31: '루프 내 교차된 메모리 접근에서 벡터화를 사용하도록 설정'
# 'Enable vectorization on masked interleaved memory accesses in a loop'
H043FDB797D48: '루프 내에서 마스킹된 교차 메모리 접근에 대한 벡터화를 활성화합니다'
# 'Enable verbose debugging for Loop Fusion'
H0D6210EADA30: 'Loop Fusion에 대한 자세한 디버깅을 활성화합니다.'
# 'Enable verbose output'
H11B3BB594E91: '상세 출력을 활성화합니다'
# 'Enable verbose output (results, IR, etc.) to stderr'
HCCA7B2AA9E71: '자세한 출력 (결과, IR 등)을 stderr로 활성화합니다'
# 'Enable verification of LLVM IR'
H21971438C1F9: 'LLVM IR 검증을 활성화합니다'
# 'Enable verification of MemorySSA.'
H0C498CC2C452: '메모리SSA 검증을 활성화합니다.'
# 'Enable verification of assumption cache'
HA1CDE46C471E: '가정 캐시 검증을 활성화합니다'
# 'Enable vextract optimization'
HEA51F4DB759E: 'vextract 최적화를 활성화합니다'
# 'Enable virtual function elimination'
HB0B4C26F8F08: '가상 함수 제거를 활성화합니다'
# 'Enable vtune profiling support'
H19C598762536: 'VTune 프로파일링 지원을 활성화합니다'
# 'Enable warnings for deprecated constructs and define __DEPRECATED'
H141A6A5BBE2F: '비precated된 구문에 대한 경고를 활성화하고 __DEPRECATED를 정의합니다'
# 'Enable warnings for undefined macros with a prefix in the comma separated list <arg>'
HCD611C0CC9C3: '정의되지 않은 매크로에 대해 접두사가 있는 쉼표로 구분된 목록 <arg>에서 경고를 활성화합니다'
# 'Enable whole program visibility'
HED7D14DA2E46: '전체 프로그램 가시성 활성화'
# 'Enable whole program visibility during LTO'
H467630D788B8: 'LTO 중 전체 프로그램 가시성을 활성화합니다'
# 'Enable workarounds for GR712RC errata'
H12F1DF5F1AA6: 'GR712RC 에러타 항목을 위한 대체 방법 활성화'
# 'Enable workarounds for UT700 errata'
HEED588686E0F: 'UT700 errata에 대한 대응 방법을 활성화합니다'
# 'Enable/disable fusing matrix instructions.'
HCF6BF736057E: '행렬 명령어 융합을 활성화/비활성화합니다.'
# 'Enable/disable matrix shape verification.'
HBF4777571623: '행렬 모양 검증을 활성화/비활성화합니다.'
# 'Enables DWARF32 format for ELF binaries, if debug information emission is enabled.'
HC14824860E5E: '디버그 정보 생성이 활성화되면, ELF 바이너리에 대해 DWARF32 형식을 사용합니다.'
# 'Enables DWARF64 format for ELF binaries, if debug information emission is enabled.'
H636F6BB5F153: '디버그 정보 출력이 활성화된 경우, ELF 이진 파일에 대해 DWARF64 형식을 사용 가능하게 합니다.'
# 'Enables UNSIGNED type'
H12352306E73A: '부호 없는 형식을 활성화합니다'
# 'Enables autovectorization of some loops containing histograms'
HC9BA8F6B64F6: '히스토그램이 포함된 일부 루프의 자동 벡터화를 활성화합니다'
# 'Enables dead virtual function elimination optimization. Requires -flto=full'
HF54593F712BA: '사용되지 않는 가상 함수 제거 최적화를 활성화합니다. 전체 LTO(-flto=full)가 필요합니다.'
# 'Enables more verbose remarks.'
H247202E5D41C: '더 자세한 참고 메시지를 활성화합니다.'
# "Enables scope for regex variables. Variables with names that\ndo not start with '$' will be reset at the beginning of\neach CHECK-LABEL block."
H1C0B00C976AB: "정규식 변수에 범위를 활성화합니다. 이름이 '$'로 시작하지 않는 변수들은 각 CHECK-LABEL 블록의 시작 부분에서 재설정됩니다."
# 'Enables spilling/reloading SVE predicates as data vectors (ZPRs)'
H7E00B4776D94: 'SVE 조건을 데이터 벡터(ZPRs)로 스피링/리로딩을 활성화합니다'
# 'Enables splitting of the LTO unit'
H14642BDE0542: 'LTO 단위 분할을 활성화합니다'
# 'Enables strict availability diagnostic mode for HLSL built-in functions.'
H68650E3ED1FE: 'HLSL 내장 함수에 대해 엄격한 가용성 진단 모드를 활성화합니다.'
# 'Enables the global instruction selector'
H6762200C8D35: '전역 명령어 선택기를 활성화합니다'
# 'Enables the use of non-default rounding modes and non-default exception handling on targets that are not currently ready.'
H405A02EF316C: '현재 준비되지 않은 타겟에서 기본값이 아닌 반올림 모드와 기본값이 아닌 예외 처리를 사용할 수 있도록 활성화합니다.'
# 'Enables tracing of vector stores'
H5763CA739FFE: '벡터 저장 추적을 활성화합니다'
# 'Enables whole-program vtable optimization. Requires -flto'
H251D67CF92D1: '전체 프로그램 vtable 최적화를 활성화합니다. -flto 옵션이 필요합니다.'
# 'End sequence.'
H06B975DED7C7: '종료 시퀀스.'
# 'Enforce name visibility rules across submodules of the same top-level module.'
H3A526080F9BF: '같은 최상위 모듈의 서브모듈 간 이름 가시성 규칙 강제 적용'
# 'Enforce targets of indirect branches and function returns'
H01AC3BBC07B8: '간접 분기 및 함수 반환점의 대상 강제화'
# "Enqueue and re-visit child loops in the loop PM after unrolling. This shouldn't typically be needed as child loops (or their clones) were already visited."
H26C9D96CFA95: '언롤링 후 루프 PM에서 자식 루프를 큐에 넣고 다시 방문합니다. 자식 루프(또는 그 클론)는 이미 방문되었기 때문에 보통은 이 작업이 필요하지 않습니다.'
# 'Ensure that all functions can be hotpatched at runtime'
H2573A45755AF: '모든 함수가 런타임에 핫패치될 수 있도록 확실히 하십시오'
# 'Ensure that llvm.experimental.noalias.scope.decl for identical scopes are not dominating'
H529A91904E5D: '동일한 범위에 대한 llvm.experimental.noalias.scope.decl이 지배하지 않는지 확인하십시오'
# 'Ensure that the global variables are in the global address space'
HE46C47C5C88F: '전역 변수들이 전역 주소 공간에 있도록 확실히 하십시오'
# "Ensures debug_value's that have been stackified become stack relative"
H7ED7A97DC8DC: '디버그 값들의 스택화된 상태가 스택 상대적 위치가 되도록 보장합니다'
# 'Entry point name'
H289D7303E351: '진입점 이름'
# 'Entry point name for hlsl'
HE591D017B2D3: 'HLSL 용 진입점 이름'
# 'Enumerate different FRM and VXRM'
H01FEC6A04D14: '다른 FRM과 VXRM을 열거합니다'
# 'Enumeration.'
H14D4DDE07BE9: '열거형.'
# 'Enumerator.'
H1BB8B827F47C: '열거자.'
# 'Epilogue begin.'
HAB658397C42F: '에필로그 시작.'
# "Equivalent to '-mrecip=all'"
H732521E2A55F: "'-mrecip=all'과 동일합니다."
# 'Equivalent to -march=mips1'
H7FC3E35D9090: 'mips1과 동일합니다'
# 'Equivalent to -march=mips2'
HE867B04F1EDA: '이 옵션은 -march=mips2를 지정하는 것과 동일합니다'
# 'Equivalent to -march=mips3'
H2E91BF8C7F63: 'mips3 아키텍처를 지정하는 옵션과 동일합니다.'
# 'Equivalent to -march=mips32'
HD42FF697CA84: '이 옵션은 -march=mips32와 동일합니다'
# 'Equivalent to -march=mips32r2'
H1346CAA8E004: 'mips32r2 아키텍처를 지정하는 옵션과 동일합니다.'
# 'Equivalent to -march=mips32r3'
H1F78C0BD4227: 'mips32r3 아키텍처를 지정하는 옵션과 동일합니다.'
# 'Equivalent to -march=mips32r5'
H46694C52E140: '-march=mips32r5와 동일합니다'
# 'Equivalent to -march=mips32r6'
H7EF21D815E8D: 'mips32r6 아키텍처를 지정하는 -march 옵션과 동일합니다.'
# 'Equivalent to -march=mips4'
H28139C7F49F1: '-march=mips4 옵션과 동일합니다'
# 'Equivalent to -march=mips5'
H677B666B87C9: '-march=mips5와 동일합니다'
# 'Equivalent to -march=mips64'
H4A78C54743DE: 'mips64 아키텍처를 지정하는 옵션과 동일합니다. -march=mips64'
# 'Equivalent to -march=mips64r2'
HAA2577781717: '-march=mips64r2 옵션과 동일합니다.'
# 'Equivalent to -march=mips64r3'
H5285D4DA9B3F: 'mips64r3 아키텍처를 지정하는 -march=mips64r3 옵션과 동일합니다.'
# 'Equivalent to -march=mips64r5'
H271253ED3AFA: '-march=mips64r5 옵션과 동일함'
# 'Equivalent to -march=mips64r6'
H9AB4B9314716: '-march=mips64r6 옵션과 동일합니다'
# 'Equivalent to -verify=expected'
H8E09CC7EDD92: 'Verify 옵션과 동일합니다: -verify=expected'
# 'Erase GP Operand'
HB8F1F7E9AA26: 'GP 오퍼랜드 제거'
# 'Erase the existing functions'
H8F328C294A4D: '기존의 함수를 지웁니다'
# 'Errata workaround pass'
H882D2A8DC3F5: '에러타 우회 패스'
# 'Error collecting HIP undefined fatbin symbols: %0'
H8A6EDE3371D0: 'HIP에서 정의되지 않은 fatbin 심볼 수집 중 오류: %0'
# 'Error for missing parenthesis around predicate registers'
H227937134E2E: '조건 레지스터 주위에 괄호가 누락된 오류'
# "Error for register names that aren't contigious"
H8D6DA19266F4: '연속되지 않은 레지스터 이름에 대한 오류'
# 'Error in reading profile %0: %1'
H431D01FCD538: '프로파일 %0 읽기 오류: %1'
# 'Error messages only'
H0A7E083717DD: '오류 메시지만 표시합니다'
# 'Error on use'
HD221DA4D89E6: '사용 시 오류'
# 'Errors and warnings'
H2848EBF5EBC2: '오류 및 경고'
# 'Errors only'
H970D9ABE25E2: '오류만'
# 'Errors, warnings and remarks'
HF85336965841: '오류, 경고 및 참고'
# 'Evenly re-distribute flow among unknown subgraphs.'
H5604C90F2BE4: '알 수 없는 하위 그래프들 사이에서 흐름을 균등하게 재분배합니다.'
# 'Exact dependences without transitive dependences'
HA1B7947727A7: '정확한 종속성 없이 전이적 종속성'
# 'Exception catch block.'
H6264B2F9B33C: '예외 캐치 블록.'
# 'Exception try block.'
H5C51BB50B6C6: '예외 try 블록.'
# 'Exclude compilands by regular expression'
HE55B6BA9D8DC: '정규 표현식으로 컴파일 대상 제외'
# 'Exclude functions matching the filter from the output.'
H1D0BAA0AC132: '필터에 맞는 함수들을 출력에서 제외합니다.'
# 'Exclude sanitization for the top hottest code responsible for the given fraction of PGO counters (0.0 [default] = skip none; 1.0 = skip all). Argument format: <sanitizer1>=<value1>,<sanitizer2>=<value2>,...'
H7D028CB3230B: 'PGO 카운터의 주어진 분수에 해당하는 상위 최상위 코드의 정화를 제외합니다(0.0[기본값] = 아무것도 건너뛰지 않음; 1.0 = 모두 건너뛰기). 인자 형식: <sanitizer1>=<value1>,<sanitizer2>=<value2>,...'
# 'Exclude symbols by regular expression'
H599455B9067B: '정규 표현식으로 심볼 제외'
# 'Exclude types by regular expression'
H40334405F17A: '정규 표현식으로 타입 제외'
# 'Exclude wrong side overloads only if there are same side overloads in overloading resolution for CUDA/HIP'
H5AA1CC8C618A: 'CUDA/HIP의 오버로딩 해석 시 동일한 측 오버로드가 존재할 경우에만 잘못된 측 오버로드를 제외합니다.'
# "Execute MCJIT'ed code in a separate process."
HC2E4E9BA2FB9: '독립된 프로세스에서 MCJIT로 생성된 코드를 실행합니다.'
# 'Execute graph viewer in the background. Creates tmp file litter.'
HA7075AF10C7F: '배경에서 그래프 뷰어 실행. 일시 파일 잔재 생성.'
# 'Execute with JIT'
HE5464053A6D4: 'JIT로 실행'
# 'Execute with the interpreter'
HEC3165B8EAB3: '해석기와 함께 실행'
# 'Executes the snippets within the same process'
H22C3FC000703: '동일한 프로세스 내에서 코드 조각을 실행합니다'
# 'Execution model (WebAssembly only)'
H41BAD8F12174: '실행 모델 (WebAssembly 전용)'
# 'Exhaustive Search for registers bypassing the depth and interference cutoffs of last chance recoloring'
H3536DA79C20E: '최후의 기회 재색칠의 깊이 및 간섭 제한을 패스하는 레지스터를 위한 완전 탐색'
# 'Exit early if an unpredictable value come from the same loop'
H1F5EDB8C4566: '예측 불가능한 값이 같은 루프에서 오는 경우 조기 종료'
# 'Exit with an error when an instruction is unsupported for any reason (default)'
HDA0C7DD7EA63: '지원되지 않은 명령이 있는 경우 오류로 종료 (기본값)'
# 'Expand 64-bit division in AMDGPUCodeGenPrepare'
HEA34070476C9: 'AMDGPUCodeGenPrepare에서 64비트 나눗셈 확장'
# 'Expand Atomic instructions'
H30D3E9ACF190: '원자 명령어 확장'
# 'Expand certain fp instructions'
H98876AA7B147: '특정 fp 명령어 확장'
# 'Expand constant expressions to instructions for testing purposes'
H9BED0D03A404: '테스트를 위해 상수 표현식을 명령어로 전개합니다'
# 'Expand double precision loads and stores to their single precision counterparts'
H09525D3EC7B4: '더블 정밀도 로드 및 스토어를 각각의 싱글 정밀도 대응체로 확장합니다'
# 'Expand eligible cr-logical binary ops to branches'
H785023B9F185: '적용 가능한 cr-logical binary ops를 분기문으로 확장합니다'
# 'Expand fp'
H2ACDE0C56583: 'fp 확장'
# 'Expand hlfir.matmul as elemental operation'
HB8FB6378B2A3: 'hlfir.matmul을 요소별 연산으로 확장합니다'
# 'Expand indirectbr instructions'
H0645EC041241: 'indirectbr 명령문 전개'
# 'Expand large div/rem'
H6BA324BB9D05: '큰 나눗셈/나머지 확장'
# 'Expand macros without full preprocessing'
H13AAEB743C7B: '전처리를 완전히 하지 않고 매크로를 확장'
# 'Expand memcmp() to load/stores'
H44E3E46EDFEB: 'memcmp()를 load/stores로 확장합니다'
# 'Expand memcpy into load/store pairs in order'
H9B1207BABDAD: 'memcpy를 load/store 쌍으로 순서대로 확장합니다'
# "Expand operand's MIOperandInfo DAG into suboperands"
H0AED692FCB12: '작용소의 MIOperandInfo DAG를 하위 작용소로 확장합니다'
# 'Expand out of range branch instructions and fix forbidden slot hazards'
HB54E4CE04809: '범위를 벗어난 분기 명령문을 확장하고 금지된 슬롯 위험 요소를 수정합니다'
# 'Expand out of range branches'
H08752DCA250D: '범위를 벗어난 분기문 확장'
# 'Expand reduction intrinsics'
H9287AE31FDD0: '리덕션 인트린스틱 확장'
# 'Expand variadic functions'
HC0CCC1B4F1F9: '가변 인자 함수 확장'
# 'Expect external char-aligned symbols to be without ABI alignment (SystemZ only)'
HEE285623EE10: '외부의 char 정렬된 심볼은 ABI 정렬 없이 존재해야 합니다 (SystemZ만 해당)'
# 'Experimental pc tracing'
H45FAF05767D2: '실험적 PC 추적'
# 'Explain input dump and quit'
HB398CAAA9E7D: '입력 덤프 설명 및 종료'
# 'Explain why a node was skipped (default=true)'
H51DC101E0A71: '노드가 건너뛴 이유를 설명합니다 (기본값=true)'
# 'Explain why a pattern was skipped for inclusion in the GlobalISel selector'
HAC0A3B68049F: 'GlobalISel 선택기에서 패턴이 포함되지 않은 이유 설명'
# 'Exploit reductions in dependence analysis'
H76A87C10B6BB: '의존성 분석에서의 감소 활용'
# 'Export debug info (by testing original Debug Info) failures into specified (JSON) file (should be abs path as we use append mode to insert new JSON objects).'
H632F15D60721: '디버그 정보(원본 디버그 정보 테스트를 통해 실패한 부분)를 지정된 (JSON) 파일(절대 경로로 지정해야 합니다. 추가 모드를 사용해 새 JSON 객체를 삽입하기 때문)에 내보냅니다.'
# 'Export debug info preservation failures into specified (JSON) file (should be abs path as we use append mode to insert new JSON objects)'
HD135A5123609: '디버그 정보 보존 실패 사항을 지정된 (JSON) 파일에 내보내기 (절대 경로로 지정해야 합니다. 추가 모드를 사용하여 새 JSON 개체를 삽입하기 때문입니다)'
# 'Export full callsite graph'
H8538ECACAB5E: '전체 callsite 그래프 내보내기'
# 'Export graph to dot files.'
H314220D2E444: '그래프를 dot 파일로 내보냅니다.'
# 'Export only nodes with contexts feeding given -memprof-dot-alloc-id'
H11F3042B06F8: '지정된 -memprof-dot-alloc-id를 공급하는 노드들만 출력합니다'
# 'Export only nodes with given -memprof-dot-context-id'
H910BF34B1ED8: '지정된 -memprof-dot-context-id를 가진 노드만 내보내기'
# 'Export only summary information for each source file'
HD9DCC346A6DB: '각 소스 파일에 대한 요약 정보만 내보내기'
# 'Export per-pass debugify statistics to this file'
H798BCDB12E0E: '각 패스별 디버기프 통계를 이 파일에 내보내기'
# 'Export the polyhedral description of the detected Scops'
H517A4767D0DE: '감지된 Scops의 다면체 설명을 내보냅니다'
# 'Export typeid resolutions to summary and globals'
H705A17261B58: 'summary 및 globals로 typeid 해결 내용을 내보냅니다'
# 'Exporting options'
HA28E86F82A20: '옵션 내보내기'
# 'Extend the -G behaviour to object local data (MIPS)'
H807C41A2617A: '-G 동작을 객체 로컬 데이터로 확장 (MIPS)'
# 'Extend the liveness of user variables through optimizations to prevent stale or optimized-out variable values when debugging.'
HE9566864B09C: '디버깅 시 과부화되거나 최적화로 제거된 변수 값이 발생하지 않도록 최적화를 통해 사용자 변수의 활성도를 확장합니다.'
# 'Extensible binary encoding'
H16E285BD9929: '확장 가능한 이진 인코딩'
# 'Extensible binary encoding (default)'
HBCE99B0D176C: '확장 가능한 바이너리 인코딩 (기본)'
# 'External Alias Analysis'
H99D45183AADE: '외부 별칭 분석'
# 'Externalize enqueued block runtime handles'
HD158E9A6F40A: '큐에 넣은 블록 런타임 핸들을 외부화합니다'
# 'Extra archive files to be loaded'
HD60827C100DD: '로드할 추가 아카이브 파일'
# 'Extra directory of include files'
H401E9781A70C: '추가 include 파일 디렉토리'
# 'Extra modules to be loaded'
H4905A00383B5: '로드할 추가 모듈'
# 'Extra object files to be loaded'
HFBB158EB888B: '로드될 추가 객체 파일들'
# 'Extract API information'
HAD16D93996E0: 'API 정보 추출'
# 'Extract HwModes-specific instructions into new DecoderTables, significantly reducing Table Duplications'
HF76D682A9D15: 'HwModes 고유 명령어를 새로운 DecoderTables로 추출하여 테이블 중복을 크게 감소시킴'
# 'Extract at most one loop into a new function'
H2D39B07FBC4D: '최대 하나의 루프를 새로운 함수로 추출합니다'
# 'Extract from <file>.'
H4A68D5BEAE14: '<file>에서 추출합니다.'
# 'Extract loops into new functions'
H053EB2868DBF: '루프를 새로운 함수로 추출'
# 'FAILURE'
HF9C22E097EEB: '실패'
# 'FILECHECK_OPTS'
H2A422AA39933: 'FILECHECK 옵션'
# 'FIX-IT applied suggested code changes'
H19B769DF31D9: 'FIX-IT 제안된 코드 변경을 적용함'
# 'FIX-IT detected an error it cannot fix'
HD809189A8863: 'FIX-IT가 수정할 수 없는 오류를 감지했습니다'
# 'FIX-IT detected errors it could not fix; no output will be generated'
HEE3E7F0F9BA0: 'FIX-IT가 수정할 수 없는 오류를 감지했습니다; 따라서 출력물이 생성되지 않을 것입니다'
# 'FIX-IT unable to apply suggested code changes'
H2B4E9FB21753: 'FIX-IT 제안된 코드 변경을 적용할 수 없습니다'
# 'FIX-IT unable to apply suggested code changes in a macro'
H3E3C2FB702A6: 'FIX-IT 매크로 내에서 제안된 코드 변경 사항을 적용할 수 없습니다'
# 'Factor for the unroll threshold to account for code simplifications still taking place'
HBD6D5665E545: '언롤 임계값 계산에 진행 중인 코드 단순화를 반영하기 위한 인수'
# 'Factor to apply to what qualifies as a long branch to reserve a pair of scalar registers. If this value is 0 the long branch registers are never reserved. As this value grows the greater chance the branch distance will fall within the threshold and the registers will be marked to be reserved. We lean towards always reserving a register for  long jumps'
H106A273943F9: '긴 분기로 간주되도록 적용하는 계수입니다. 이 값이 0이면 긴 분기 레지스터는 절대 할당되지 않습니다. 이 값이 증가할수록 분기 거리가 임계값 내에 들어갈 가능성이 높아지며, 레지스터가 할당될 것으로 표시됩니다. 우리는 긴 점프에는 항상 레지스터를 할당하는 쪽으로 경향이 있습니다'
# "Fail if an object couldn't be found for a binary ID in the profile"
H4235E7E596D5: '프로파일에서 이진식 ID에 해당하는 객체를 찾을 수 없으면 실패합니다'
# 'Fail if any profile is invalid.'
HFB8AB051E56E: '프로파일이 유효하지 않으면 실패합니다.'
# 'Fail only if all profiles are invalid.'
HF5E080277997: '모든 프로파일이 유효하지 않을 경우에만 실패합니다.'
# 'Failure mode:'
H1A58BCEE2CF5: '실패 모드:'
# 'Falkor HW Prefetch Fix'
H323CD584CC0F: 'Falkor HW 프리페치 수정'
# 'Falkor HW Prefetch Fix Late Phase'
H682A690E57FE: 'Falkor HW 프리페치 고정 지연 단계'
# 'Fallback style for reformatting after inserting new\nheaders if there is no clang-format config file found.'
H581E7F83176F: 'clang-format 구성 파일이 발견되지 않을 경우 새 헤더를 삽입한 후 코드를 재포맷할 때 사용할 대체 스타일.'
# 'Fallback to indirect when incorrect'
HD59C4BCB012E: '잘못된 경우 간접 방식으로 대체합니다'
# 'Fast Register Allocator'
H749535234AA8: '빠른 레지스터 할당기'
# 'Fast Tile Register Configure'
HE2B5F0EAEB3A: '빠른 Tile Register 구성'
# 'Fast Tile Register Preconfigure'
H049C9C8DDC88: '빠른 타일 레지스터 사전 구성'
# 'Fast register allocator'
H0FB6B67552E0: '빠른 레지스터 할당기'
# 'Fast suboptimal list scheduling'
HE44BDB59069E: '빠른 부최적 리스트 스케줄링'
# 'Features to use to serialize to cubin.'
H480406601DAF: 'cubin으로 직렬화하기 위해 사용할 기능들.'
# 'File checksums (DEBUG_S_CHECKSUMS subsection)'
H0341151319EC: '파일 체크섬 (DEBUG_S_CHECKSUMS 하위 섹션)'
# 'File containing RuntimeDyld verifier checks.'
H91AFD2697B81: 'RuntimeDyld 검증기 검사 항목이 포함된 파일'
# 'File containing diagnostic suppression mappings. See user manual for file format.'
H65FE3D35314C: '진단 억제 매핑을 포함하는 파일입니다. 파일 형식에 대한 자세한 내용은 사용자 매뉴얼을 참조하세요.'
# 'File containing entry point of the transform script, if different from the input file'
H6B64668AC58F: '변환 스크립트의 진입점을 포함하는 파일(입력 파일과 다른 경우)'
# 'File containing verifier checks'
H4CA0F6F72C6E: '검증 체크를 포함하는 파일'
# "File doesn't need an exec stack"
H9CC2858800DD: '파일은 실행 스택이 필요 없습니다'
# 'File for serializing diagnostics in a binary format'
H94768CE895D7: '바이너리 형식으로 진단 정보를 직렬화하는 파일'
# 'File holding the seed used by the randomize structure layout feature'
HE8D1A6EACA51: '구조체 레이아웃 무작위화 기능에서 사용하는 시드를 보관하는 파일'
# 'File is for a position independent executable'
HC6398B79E913: '파일은 위치 독립적 실행 파일용입니다.'
# 'File listing native ABI functions and how the pass treats them'
H779A21941187: '네이티브 ABI 함수 목록과 패스의 처리 방식을 나타내는 파일'
# 'File name to use for YAML optimization record output'
HDFBB63F1AC25: 'YAML 최적화 기록 출력을 위해 사용할 파일 이름'
# 'File name to use for split dwarf debug info output'
H6FBC3D7AD088: '분할 DWARF 디버그 정보 출력에 사용할 파일 이름'
# 'File path for cold function only instrumentation(requires use with --pgo-instrument-cold-function-only)'
H833BBD566D2F: 'Cold function만을 위한 인스트루먼테이션 파일 경로(사용시 --pgo-instrument-cold-function-only 옵션과 함께 사용해야 함)'
# 'File path to where .cgdata file is read'
HD25E7479AD77: 'cgdata 파일이 읽힐 경로를 지정하는 파일 경로'
# 'File to append -stats and -timer output to'
H8C0548CC1115: '-stats 및 -timer 출력을 추가할 파일'
# 'File to check (defaults to stdin)'
H44D35D906559: '검사할 파일 (기본값은 stdin)'
# 'File to emit dot graph of new summary into'
HB22275C53F6F: '새 요약을 위한 dot 그래프를 생성할 파일'
# 'File to read (analysis mode) or write (latency/uops/inverse_throughput modes) benchmark results. “-” uses stdin/stdout.'
H44970F94DF2D: '읽기(분석 모드) 또는 쓰기(latency/uops/inverse_throughput 모드) 벤치마크 결과를 위한 파일. “-”는 stdin/stdout을 사용합니다.'
# 'File to record the coroutines got elided'
H175805F86595: '에러를 누락한 코루틴을 기록하는 파일'
# 'File with the profile data obtained after an instrumented run'
HD4AF1660449E: '인스트루먼트된 실행 이후에 수집된 프로파일 데이터가 포함된 파일'
# 'File(s) containing definitions of additional transform script symbols'
HF1DBCA863288: '추가적인 변환 스크립트 기호의 정의가 포함된 파일(들)'
# 'Filename (or -) to log diagnostics to'
HDACB45AABD12: '진단 정보를 기록할 파일 이름(또는 -)'
# 'Filename (or -) to write dependency output to'
H8BC9F30BC52B: '의존성 출력을 쓸 파일 이름(또는 -)입니다'
# 'Filename (or -) to write header include output to'
H5BF600319EF5: '헤더 포함 출력을 작성할 파일 이름 (또는 -)'
# 'Filename (or -) to write stack usage output to'
H3BC188E55BBD: '스택 사용량 출력을 기록할 파일 이름(또는 -)'
# 'Filename defining the list of functions/files to instrument. The file uses the sanitizer special case list format.'
HC15DFAEF876C: '기기(Instrumentation을 위한) 함수/파일 목록을 정의하는 파일 이름. 이 파일은 sanitizer 특수 사례 목록 형식을 사용합니다.'
# 'Filename defining the list of functions/types for imbuing XRay attributes.'
H59E8B9411DF9: 'XRay 속성을 적용하기 위한 함수/형식 목록을 정의하는 파일 이름입니다.'
# 'Filename to pipe in as stdin (default: /dev/null)'
HBE65800DDA37: '표준 입력으로 파이프 처리할 파일 이름 (기본값: /dev/null)'
# 'Filename to write DOT-formatted header dependencies to'
HA2996F065595: 'DOT 형식의 헤더 의존성을 쓰기 위한 파일 이름'
# 'Filename to write statistics to'
HE239C00D43A5: '통계를 기록할 파일 이름'
# 'Filename where the element is defined.'
H1FDF8DE162D7: '요소가 정의된 파일 이름입니다.'
# 'Files referenced in the debug information.'
HBAB8680F7972: '디버그 정보에 참조된 파일들.'
# 'Fill Lanai delay slots with NOPs.'
H5DF685F1DB1E: '딜레이 슬롯을 NOP로 채웁니다.'
# 'Fill a percentage of the latency between neighboring MFMA with s_nops.'
H17E41E561253: '이웃한 MFMA 사이의 지연 시간의 백분율을 s_nops로 채웁니다.'
# 'Fill all delay slots with NOPs.'
HDA6B69446833: '딜레이 슬롯을 모두 NOP로 채웁니다.'
# 'Fill delay slot for MIPS'
HAFAF170DC965: 'MIPS를 위한 딜레이 슬롯 채우기'
# 'Filter all non-error diagnostics (discouraged: testing only!)'
H9EF0422D020C: '오류가 아닌 모든 진단 정보 필터링 (권장하지 않음: 테스트용으로만 사용!)'
# 'Filter the benchmarks before analysing them'
H30E98BA4CBDB: '분석하기 전에 벤치마크를 필터링합니다'
# 'Filtering and Sorting Options'
HAE5C92A1E57B: '필터링 및 정렬 옵션'
# 'Finalize ISel and expand pseudo-instructions'
HAC66FC917CAA: 'ISel 최종화 및 가상 명령어 확장'
# 'Finalize machine instruction bundles'
H54F93CB22051: '머신 명령어 번들 최종화'
# 'Find methods that overrides a virtual method.'
H26E803BD2E38: '가상 메서드를 오버라이드하는 메서드를 찾습니다.'
# "Find objects in DIR or based on FILE's path"
H4D2FE19AC654: 'DIR 또는 FILE 경로를 기반으로 오브젝트 찾기'
# 'Find subclasses of a class.'
HC1D51E00B82D: '클래스의 하위 클래스를 찾습니다.'
# 'Fix copies between 32 and 16 bit registers by extending to 32 bit'
H2E54AD53EEA9: '32비트와 16비트 레지스터 간의 복사를 32비트로 확장하여 수정합니다'
# 'Fix function entry count in profile use.'
H99125FC0562C: '프로파일 사용 중 함수 진입 카운트 수정'
# 'Fix mismatching bitcasts for WebAssembly'
H6D3A5F07020F: 'WebAssembly의 일치하지 않는 비트캐스트 수정'
# 'Fixup Statepoint Caller Saved'
H2BF0C8053839: '수정 상태 포인트 호출자 저장'
# 'Fixup each natural loop to have a single exit block'
H866DA2E73BC2: '각 자연 루프를 단일 출구 블록을 가지도록 수정합니다'
# 'Flatten the CFG'
H68BF16D61F64: 'CFG 평탄화'
# 'Flow Sensitive profile file name.'
HD4BF3081650C: '플로우 감도 프로파일 파일 이름.'
# 'Flow Sensitive profile remapping file name.'
H21713A45D881: '플로우 센티티브 프로파일 재매핑 파일 이름.'
# 'Flush denormal floating point values to zero in CUDA/HIP device mode.'
HF25D292D7C52: 'CUDA/HIP 디바이스 모드에서 비정규 부동소수점 값을 영(zero)으로 강제 변환합니다.'
# 'Fold memory accesses to model more possible delinearizations (does not scale well)'
HC5006CA24C2C: '메모리 접근을 결합하여 더 많은 가능한 비선형화 모델링을 수행 (확장성이 좋지 않음)'
# 'Fold null checks into faulting memory operations'
HC5500C22FC68: '널 확인을 실패하는 메모리 연산에 통합'
# 'Folder name for view splitting.'
HE1AD57EFF1BD: '뷰 분할을 위한 폴더 이름.'
# 'Follow Fortran 2003 rules for (re)allocating the LHS of the intrinsic assignment'
H1CD29CD7E654: 'Fortran 2003 규정을 따르는 내장 할당의 왼쪽 측(LHS)에 대한 (재)할당 규칙을 적용합니다'
# 'Follow the AAPCS standard requirement stating that volatile bit-field width is dictated by the field container type. (ARM only).'
H318AB39D2C02: 'AAPCS 표준 요구사항에 따라 volatile 비트 필드의 너비는 필드 컨테이너 유형에 의해 결정됩니다. (ARM 전용).'
# 'Follows the AAPCS standard that all volatile bit-field write generates at least one load. (ARM only).'
HBE2099993756: 'AAPCS 표준을 따릅니다. 모든 volatile 비트 필드 쓰기 작업이 적어도 하나의 로드를 생성합니다 (ARM 전용).'
# 'For -verify only: Inject a symbol into the extern symbol table.'
H691B584BF08D: '-verify 옵션 전용: 외부 심볼 테이블에 심볼을 삽입합니다.'
# 'For -verify only: Map a section to a specific address.'
H943A8FBB7A51: '오직 -verify를 위한 것입니다: 특정 주소로 섹션을 매핑합니다.'
# 'For -verify only: Separation between sections in phony target address space.'
HFFEB26CFD553: 'Verify 옵션 전용: Phony target 주소 공간 내 섹션 간의 분리.'
# 'For -verify only: end of phony target address range.'
H2C3EAFFA8499: '-verify 옵션 전용: 가짜 타겟 주소 범위의 끝입니다.'
# 'For -verify only: start of phony target address range.'
H1B0A5AC1E801: '-verify 전용: 가짜 대상 주소 범위의 시작.'
# 'For MachO, disable atexit()-based global destructor lowering'
HFC5FF11ED2AC: 'MachO에 대해 atexit() 기반 글로벌 소멸자 하향 변환을 비활성화합니다'
# 'For a large interval, if it is coalesced with other live intervals many times more than the threshold, stop its coalescing to control the compile time. '
H31454C2664AA: '대규모 인터벌의 경우, 다른 활성 인터벌과의 결합 횟수가 임계값보다 훨씬 더 많을 때 컴파일 시간을 통제하기 위해 결합을 중단합니다.'
# "For a list of available CPUs for the target use '-mcpu=help'"
HFB257544DEA1: "대상에 사용 가능한 CPU 목록을 보려면 '-mcpu=help'를 사용하세요"
# "For a list of available architectures for the target use '-mcpu=help'"
HCFFD910F1E45: "타겟을 위한 사용 가능한 아키텍처 목록은 '-mcpu=help' 옵션을 사용하십시오"
# 'For all options that iterate over modules, ignore modules from system libraries'
HF30AFF2F9F8C: '모듈을 반복하는 모든 옵션에 대해 시스템 라이브러리의 모듈을 무시합니다'
# 'For all options that iterate over modules, limit to the specified module'
H076A99AD2B76: '모듈을 반복 처리하는 모든 옵션에 대해 지정된 모듈로 제한합니다'
# 'For cold function instrumentation, skip instrumenting functions whose entry count is above the given value.'
HE6D6C775176E: '콜드 함수 인스트루먼테이션 시, 엔트리 카운트가 지정된 값보다 큰 함수의 인스트루먼트를 생략합니다.'
# 'For cold function instrumentation, treat count unknown(e.g. unprofiled) functions as cold.'
H063B03A52387: '콜드 함수 인스트루먼테이션을 위해, 카운트가 알려지지 않은(예: unprofiled) 함수를 콜드로 간주합니다.'
# 'For context sensitive PGO counts. Does not work with CSSPGO.'
HBBB3E8C601A8: '컨텍스트 센시티브 PGO 카운트를 위해. CSSPGO와 함께 사용할 수 없습니다.'
# 'For each function, emit a dot graph depicting potential LVI gadgets'
H57E599CB6769: '각 함수마다 잠재적인 LVI 기구를 나타내는 dot 그래프를 생성합니다'
# 'For each function, emit a dot graph depicting potential LVI gadgets, and do not insert any fences'
HAC353EF77E07: '각 함수에 대해 잠재적 LVI 기기들을 표시하는 dot 그래프를 생성하고, 어떤 fences도 삽입하지 않습니다'
# 'For each function, emit a dot graph to stdout depicting potential LVI gadgets, used for testing purposes only'
H3C8BB209ABDE: '각 함수에 대해, stdout에 잠재적인 LVI 기구를 표시하는 dot 그래프를 출력합니다. 테스트 목적으로만 사용됩니다'
# 'For merge, use the provided unstripped binary to correlate the raw profile.'
H5C641C769774: '병합을 위해 원시 프로파일을 상관시키기 위해 제공된 unstripped 바이너리를 사용하십시오.'
# 'For partially supported constructs, emit private/local variables as clauses/specifiers on MLIR ops.'
H5E0F9648E945: '부분적으로 지원되는 구조에 대해 MLIR 연산에서 개인/지역 변수를 절/지정자로 생성합니다.'
# 'For paths in debug info, remap directory <old> to <new>. If multiple options match a path, the last option wins'
H3D3679C30C18: '디버그 정보의 경로에서 디렉토리 <old>를 <new>로 재매핑합니다. 여러 옵션이 경로와 일치하면 마지막 옵션이 적용됩니다'
# 'For sample profiles, list function names (with calling context for csspgo) for overlapped functions with similarities below the cutoff (percentage times 10000).'
H463D2852BF2F: '샘플 프로파일에서, 유사도가 임계값 이하인 중첩된 함수의 함수 이름(퍼센트 값에 10000을 곱한 값)을 (csspgo를 위한 호출 컨텍스트와 함께) 나열합니다.'
# 'For shared library loaded with the main program, change local-dynamic access(es) to initial-exec access(es) at the function level (AIX 64-bit only).'
HD94E43E648D1: '메인 프로그램과 함께 로드된 공유 라이브러리에 대해, 함수 단위에서 local-dynamic 액세스를 initial-exec 액세스로 변경합니다 (AIX 64-bit 전용).'
# 'For show, read and extract profile metadata from debug info and show the functions it found. For merge, use the provided debug info to correlate the raw profile.'
H3F78033E8267: '보기(Show) 옵션은 디버그 정보에서 프로파일 메타데이터를 읽고 추출하고, 발견한 함수를 표시합니다. 병합(Merge) 옵션은 제공된 디버그 정보를 사용하여 원시 프로파일과 연관시킵니다.'
# 'For symbols in profile symbol list, regard their profiles to be accurate. It may be overridden by profile-sample-accurate. '
H960468D026B4: '프로파일 심볼 목록에 있는 심볼들의 프로파일을 정확한 것으로 간주합니다. 이는 profile-sample-accurate에 의해 재정의될 수 있습니다.'
# "For test - keep the ML Inline advisor's FunctionPropertiesInfo cache"
H68E3D966BDA0: '테스트를 위해 - ML Inline advisor의 FunctionPropertiesInfo 캐시를 유지하십시오'
# "For testing purposes, always break large PHIs even if it isn't profitable."
H0BECF527CC8D: '테스트 목적으로, 효익이 없더라도 큰 PHI 노드를 항상 분할합니다.'
# 'For the function which is cold in instr profile but hot in sample profile, if the ratio of the number of zero counters divided by the total number of counters is above the threshold, the profile of the function will be regarded as being harmful for performance and will be dropped.'
H326030B813BD: 'instr 프로파일에서는 cold이지만 sample 프로파일에서는 hot인 함수에 대해, 0인 카운터 수와 전체 카운터 수의 비율이 임계값을 초과하면 해당 함수의 프로파일이 성능에 해로운 것으로 간주되어 제거됩니다.'
# 'For the module ID for the file to process, useful to match what is in the index.'
HB6A96C6D31C3: '처리할 파일의 모듈 ID를 지정하는 데 사용되며, 인덱스에 있는 내용과 일치시키는 데 유용합니다.'
# 'For use with /winsysroot, defaults to newest found'
H9FFDA74D3CE8: 'winsysroot 옵션과 함께 사용할 때 기본값은 가장 최근에 발견된 것을 사용합니다'
# 'Force a peel count regardless of profiling information.'
H6BA57EBF2817: '프로파일링 정보와 관계없이 peel count를 강제로 지정합니다.'
# 'Force a specific generic_v<N> flag to be added. For testing purposes only.'
H12597D7C787F: '특정 generic_v<N> 플래그를 강제로 추가합니다. 테스트 목적으로만 사용됩니다.'
# 'Force align the stack to the minimum alignment'
H6ABD893EDD1A: '스택을 최소 정렬로 강제 정렬합니다'
# 'Force all edges in the function summary to cold'
HF7516A69CF5A: '함수 요약에 있는 모든 엣지를 cold로 강제'
# 'Force all functions to be noinline'
HB0A34849A65E: '모든 함수를 noinline로 강제'
# 'Force all indexed operations to be legal for the GlobalISel combiner'
H8B4D9E88A547: 'GlobalISel 결합기(combiner)에 대한 모든 인덱싱 연산을 유효하게 강제합니다'
# 'Force all memory accesses to be aligned (AArch32/MIPSr6 only)'
HB9DB3E9A0275: '모든 메모리 접근을 정렬되도록 강제합니다 (AArch32/MIPSr6에서만 적용됨)'
# 'Force all memory accesses to be aligned (AArch64/LoongArch/RISC-V only)'
H592DBE5D5A8A: '모든 메모리 접근을 정렬되도록 강제 (AArch64/LoongArch/RISC-V 전용)'
# 'Force all scalar memory accesses to be aligned (RISC-V only)'
H47C5C3723D44: '스칼라 메모리 접근을 모두 정렬되도록 강제 (RISC-V 전용)'
# 'Force all vector memory accesses to be aligned (RISC-V only)'
H8477BA8471BC: '모든 벡터 메모리 접근을 정렬되게 강제합니다 (RISC-V 전용)'
# 'Force all waitcnt instrs to be emitted as s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)'
H687C328A88F2: '모든 waitcnt 명령문을 s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0) 형태로 강제로 생성합니다'
# 'Force all waitcnt load counters to wait until 0'
H896788DC2080: '모든 waitcnt 로드 카운터를 0이 될 때까지 대기하도록 강제'
# 'Force allowance of nested hardware loops'
HAD8E45F66910: '중첩된 하드웨어 루프 사용 허용 강제'
# 'Force analysis to continue in the presence of unsupported instructions'
H0386966E38DA: '지원되지 않는 명령어가 있을 때도 분석을 계속하도록 강제'
# 'Force behavior as if the user specified pragma omp requires unified_shared_memory.'
H0D0C1138BD58: '사용자가 pragma omp requires unified_shared_memory를 지정한 것처럼 동작을 강제합니다.'
# 'Force bidirectional post reg-alloc list scheduling'
H2AB733A479DE: '등록 할당 후 양방향 리스트 스케줄링 강제'
# 'Force bidirectional pre reg-alloc list scheduling'
H9527EDFB6708: '등록할당 전 양방향 리스트 스케줄링 강제'
# 'Force bottom-up post reg-alloc list scheduling'
HC9A155CC7DD9: '강제 하향식 레지스터 할당 후 목록 스케줄링'
# 'Force bottom-up pre reg-alloc list scheduling'
HD5FFAD3EC478: '강제 하향식 등록 할당 전 리스트 스케줄링'
# 'Force codegen to assume rounding mode can change dynamically'
H5694C07468F1: '코드 생성을 강제로 반올림 모드가 동적으로 변경될 수 있다고 가정하게 합니다'
# 'Force disable the lazy-loading on-demand of metadata when loading bitcode for importing.'
H2329A45D867C: '비트코드를 가져오기 위해 로드할 때 메타데이터의 요청 시 지연 로딩을 강제로 비활성화합니다.'
# 'Force double to be <n> bits'
H6A3CAE57D5DB: 'double을 <n> 비트로 강제'
# 'Force each unsigned fixed point type to have an extra bit of padding to align their scales with those of signed fixed point types'
H2DB086248971: '각 부호 없는 고정 소수점 유형에 추가 비트의 패딩을 강제로 추가하여 그들의 스케일을 부호 있는 고정 소수점 유형의 스케일과 일치시킵니다.'
# 'Force emit s_waitcnt expcnt(0) instrs'
H88E5FE04F072: 's_waitcnt expcnt(0) 명령문을 강제로 생성합니다'
# 'Force emit s_waitcnt lgkmcnt(0) instrs'
HE8A3AAF43D8E: '강제로 s_waitcnt lgkmcnt(0) 명령문 생성'
# 'Force emit s_waitcnt vmcnt(0) instrs'
H38DB94C17996: 's_waitcnt vmcnt(0) 명령문 강제 발생'
# 'Force enable speculative execution side effect suppression. (Note: User must pass -mlvi-cfi in order to mitigate indirect branches and returns.)'
H5C45F8896F6A: '예측 실행 부작용 억제를 강제로 활성화합니다. (참고: 간접 분기 및 반환을 완화하려면 사용자는 -mlvi-cfi를 전달해야 합니다.)'
# 'Force enable speculative load hardening'
HE35AC46B0548: '추정 로드 강화를 강제로 활성화'
# 'Force function reduction to keep main'
H0BB63C069108: '메인을 유지하기 위해 함수 축소를 강제합니다'
# 'Force function specialization for every call site with a constant argument'
H16827AFD0E0F: '상수 인자가 있는 모든 호출 위치에서 함수 특수화를 강제합니다.'
# 'Force function to be mips32'
H47CC37388F1A: '함수를 mips32로 강제'
# 'Force generation of loop guard intrinsic'
H660425C561DD: '루프 가드 인트리니스의 생성 강제'
# 'Force generation of thread parallel code ignoring any cost model'
HD5652803169B: '강제로 어떤 비용 모델도 무시하고 스레드 병렬 코드를 생성합니다'
# 'Force hardware loop counter to be updated through a phi'
H6034A18A690A: '하드웨어 루프 카운터를 phi를 통해 업데이트하도록 강제'
# 'Force hardware loops intrinsics to be inserted'
H526108F8C3D0: '하드웨어 루프 인트리니스 삽입 강제'
# 'Force interpretation: disable JIT'
HE0B08266ED91: '강제 해석: JIT 비활성화'
# 'Force linking the clang builtins runtime library'
H602A2DB51D2C: 'clang builtins 런타임 라이브러리 강제 연결'
# 'Force long double to be 128 bits'
HF5330D6B0F62: 'long double을 128비트로 강제합니다'
# 'Force long double to be 64 bits'
HF1CEF43473D8: 'long double을 64비트로 강제'
# 'Force long double to be 80 bits, padded to 128 bits for storage'
H2FBC78A0A1C7: 'long double을 80비트로 강제하고, 저장을 위해 128비트로 패딩합니다'
# 'Force machine combiner to use a specific strategy for machine trace metrics evaluation.'
H8D7274D95AD0: '머신 커민더가 머신 추적 메트릭스 평가를 위한 특정 전략을 사용하도록 강제합니다.'
# 'Force matrix instruction fusion even if not profitable.'
HABD067814D75: '윤리적이지 않아도 매트릭스 명령어 통합을 강제합니다.'
# 'Force optimization experiment (for testing)'
H23001FDFF697: '강제 최적화 실험 (테스트용)'
# 'Force outline regions with live exits'
H13A02DD93B7D: '활성 출구를 가진 영역을 강제로 아웃라인 처리'
# 'Force outlining cold blocks from loops.'
H04711024D9E9: '루프의 콜드 블록을 강제로 아웃라인화합니다.'
# 'Force pipeliner to use specified II.'
H17E89A49B48C: '지정된 II를 사용하도록 파이프라인 처리기를 강제합니다.'
# 'Force pipeliner to use specified issue width.'
HA8DD64472E32: '지정된 이슈 너비를 사용하도록 파이프라인에 강제 적용합니다.'
# 'Force realign the stack at entry to every function'
H31A8B99D0D70: '모든 함수의 진입점에서 스택을 강제 재정렬합니다'
# 'Force store splitting no matter what the target query says.'
H7A397BF735D5: '타겟 쿼리에 상관없이 스토어 분할을 강제로 적용합니다.'
# 'Force the (profiled-guided) size optimizations. '
HA4B424DB2FF9: '프로파일링 기반 크기 최적화를 강제로 실행합니다. '
# 'Force the alignment of all blocks in the function in log2 format (e.g 4 means align on 16B boundaries).'
HB1C496FAEC2F: '함수 내 모든 블록의 정렬을 log2 형식으로 강제합니다. (예: 4는 16B 경계에서 정렬한다는 의미입니다.)'
# "Force the alignment of all blocks that have no fall-through predecessors (i.e. don't add nops that are executed). In log2 format (e.g 4 means align on 16B boundaries)."
HEC173CEDA264: '폴스루 전신자가 없는 모든 블록의 정렬을 강제합니다(즉, 실행되는 nop을 추가하지 않음). log2 형식으로 지정합니다(예를 들어 4는 16B 경계에 맞춥니다).'
# 'Force the alignment of all functions in log2 format (e.g. 4 means align on 16B boundaries).'
HAC694582BD7C: '모든 함수의 정렬을 log2 형식으로 강제합니다(예: 4는 16B 경계에 정렬을 의미합니다).'
# 'Force the interpretation of -stream as a string, even if it is a valid integer'
HD1DE45392158: '유효한 정수일지라도 -stream을 문자열로 강제로 해석합니다'
# 'Force the static analyzer to analyze functions defined in header files'
HAB6B5ACFD382: '정적 분석기를 헤더 파일에 정의된 함수를 분석하도록 강제합니다'
# 'Force the tail folding style'
HA1C7FE88ED1D: '테일 폴딩 방식 강제 적용합니다'
# 'Force the use of a base pointer in every function'
HBE1018F652C4: '모든 함수에서 기본 포인터 사용을 강제합니다'
# 'Force the use of precise cost loop rotation strategy.'
HEC5F52CCB084: '정확한 비용 루프 회전 전략의 사용을 강제합니다.'
# 'Force the use of resource intervals in the schedule model'
HC146F04B90B5: '스케줄 모델에서 자원 구간 사용을 강제'
# 'Force the use of streaming code for all functions'
H9D121C14481F: '모든 함수에 대해 스트리밍 코드 사용을 강제합니다'
# 'Force the use of streaming-compatible code for all functions'
H3939F502979A: '모든 함수에 스트리밍 호환 코드의 사용을 강제합니다'
# 'Force thread model single in LICM pass'
H95CEFB645311: 'LICM 패스에서 스레드 모델을 단일로 강제'
# 'Force to instrument function entry basicblock.'
HCB64281E774F: '함수 진입 기본 블록에 인스트루먼트 강제 적용.'
# 'Force to instrument loop entries.'
H3FF84C8727C9: '루프 엔트리에 분석 코드를 삽입하도록 강제합니다.'
# 'Force top-down post reg-alloc list scheduling'
H624C5BFC69FE: '강제 상향식 레지스터 할당 후 리스트 스케줄링'
# 'Force top-down pre reg-alloc list scheduling'
HF7823207CF83: '강제 상향식 pre reg-alloc 리스트 스케줄링'
# 'Force use of AdvSIMD scalar instructions everywhere'
H5BE24FD8EC8D: 'AdvSIMD 스칼라 명령어를 모든 곳에서 강제로 사용'
# 'Force using MLIR complex operations instead of libm complex operations'
HE874B9895802: 'MLIR 복소수 연산을 강제로 사용하여 libm 복소수 연산 대신'
# 'Force validation of user headers when repeatedly loading a module file within single build session'
H0E2DB592B82B: '단일 빌드 세션 내에서 모듈 파일을 반복적으로 로드할 때 사용자 헤더의 검증을 강제합니다.'
# 'Force wchar_t to be a short unsigned int'
H344B5212E317: 'wchar_t를 short unsigned int로 강제 지정'
# 'Force wchar_t to be an unsigned int'
H43342C927949: 'wchar_t를 unsigned int로 강제'
# 'Force whether the StructurizeCFG pass skips uniform regions'
H1E4EFD3EA072: 'StructurizeCFG 패스가 일관된 영역을 건너뛰도록 강제 여부를 지정합니다'
# 'Forces the maximum bytes allowed to be emitted when padding for alignment'
H3B4D326FCA22: '정렬을 위해 패딩할 때 발생되는 바이트의 허용 최대값을 강제로 설정합니다'
# 'Forcibly enables non-trivial loop unswitching rather than following the configuration passed into the pass.'
H2E9D92A16FC3: '패스에 전달된 구성 대신 비상수 루프 언스위칭을 강제로 활성화합니다.'
# 'Forget everything in SCEV when doing LoopUnroll, instead of just the current top-most loop. This is sometimes preferred to reduce compile time.'
HDBEAD86F6F49: 'LoopUnroll을 수행할 때 SCEV의 모든 것을 삭제하는 대신 현재 상단 루프만 삭제하는 것을 피합니다. 이렇게 하면 컴파일 시간을 줄이기 위해 때로는 선호됩니다.'
# 'Form fused FP ops (e.g. FMAs)'
H88EF5D85058D: '복합 부동소수점 연산 생성 (예: FMA)'
# 'Format a range of this length (in bytes).\nMultiple ranges can be formatted by specifying\nseveral -offset and -length pairs.\nWhen only a single -offset is specified without\n-length, clang-format will format up to the end\nof the file.\nCan only be used with one input file.'
H93D871018723: '이 길이(바이트 단위)의 범위를 포맷합니다.\n여러 개의 -offset과 -length 쌍을 지정하여 여러 범위를 포맷할 수 있습니다.\n-length가 없이 단일 -offset만 지정된 경우 clang-format은 파일의 끝까지 포맷합니다.\n단일 입력 파일과만 사용할 수 있습니다.'
# 'Format a range starting at this byte offset.\nMultiple ranges can be formatted by specifying\nseveral -offset and -length pairs.\nCan only be used with one input file.'
H28E3CD62FED9: '이 바이트 오프셋부터 시작하는 구간을 포맷합니다.\n여러 개의 -offset과 -length 쌍을 지정하여 여러 구간을 포맷할 수 있습니다.\n단일 입력 파일에서만 사용할 수 있습니다.'
# "Format consumable by Brendan Gregg's FlameGraph tool. Only valid with -all-stacks."
HE769F9BDFBAB: '브렌던 그리그의 FlameGraph 도구에 사용할 수 있는 형식. -all-stacks 옵션과 함께만 유효합니다.'
# 'Format for outputted docs.'
HC5A8B725033A: '문서 출력 형식'
# 'Format message diagnostics so that they fit within N columns'
H5F2F2FEC74C8: '진단 메시지를 N 열 내에 맞추도록 포맷합니다'
# 'Format of index export'
H9AED5C1C80E8: '인덱스 내보내기 형식'
# 'Format of output profile'
HAE3C92A81F31: '출력 프로파일 형식'
# 'Format of the index to be written'
H036107DC230C: '작성될 인덱스의 형식'
# 'Formatting Options'
H7C2DC2E6B392: '서식 옵션'
# 'Forward options to the linker'
H0E5969703D2A: '링커에 옵션을 전달합니다'
# 'Forward switch condition to phi ops (default = false)'
HB7C76B2E6FA2: '스위치 조건을 phi 연산자에 전달 (기본값 = false)'
# 'Four-byte version string for gcov files.'
H32782AC0D44C: 'gcov 파일을 위한 4바이트 버전 문자열'
# 'Frame Data (DEBUG_S_FRAMEDATA subsection)'
H4EACA6AC6ABA: '프레임 데이터 (DEBUG_S_FRAMEDATA 하위 섹션)'
# 'Fuchsia API Level prohibits specifying a minor or sub-minor version'
H73A16BC6357D: 'Fuchsia API 레벨은 소 버전 또는 서브-소 버전을 지정하는 것을 금지합니다'
# 'Full version of the Windows SDK, defaults to newest found'
HD00F6CBB0217: 'Windows SDK의 전체 버전, 기본값은 가장 최근에 찾은 버전'
# 'Fully encode c++ class template specialization'
H83B6D3243278: 'C++ 클래스 템플릿 특수화를 완전히 인코딩'
# 'Fully expand the memory accesses of the detected Scops'
H41926418D084: '감지된 Scops의 메모리 액세스를 완전히 확장합니다'
# 'Fully relocatable, position independent code'
H2EE1300E53E0: '완전히 재배치 가능, 위치 독립 코드'
# 'Function Alias Analysis Results'
H5E305706D9B2: 'Function Alias 분석 결과'
# 'Function Entry Count'
HF80E7DCD1642: '함수 진입 횟수'
# 'Function attribute to apply to cold functions as determined by PGO'
H345451AD326B: 'PGO에 의해 결정된 cold 함수에 적용할 함수 속성'
# 'Function entry point.'
HAD67FD8DA947: '함수 진입점.'
# 'Function filtering options'
H71383E432CB7: '함수 필터링 옵션'
# 'Function level overlap information for every function (with calling context for csspgo) in test profile with max count value greater than the parameter value'
H66ADA33E3E20: '테스트 프로파일에서 최대 카운트 값이 매개변수 값보다 큰 각 함수에 대한 함수 수준 오버랩 정보 (csspgo를 위한 호출 컨텍스트 포함)'
# 'Function mem bound threshold in %'
HC48D6911C0B3: '함수 메모리 경계 임계값 %로 지정'
# 'Function names that are public.'
H1CBBD51F21AA: '공개적인 함수 이름입니다.'
# 'Function number to canonicalize.'
H14E5011F4FDD: '정규화할 함수 번호.'
# 'Function register usage analysis'
HC45FBE8F1495: '함수 레지스터 사용 분석'
# 'Function to call as entry point.'
H9A688E8595B8: '실행 시작 지점으로 호출할 함수입니다.'
# 'Function type.'
HC8800532CD60: '함수 형식.'
# 'Function.'
H7375AFF85987: '함수.'
# 'Fuse FP ops whenever profitable'
H9F1BE3BC2E20: '윤리적일 때 FP 연산 결합'
# 'GC Lowering'
HB5C53C8FC4DB: 'GC 변환'
# 'GCC does not allow %0 attribute in this position on a function definition'
H6258B157AA4F: 'GCC는 이 위치에 함수 정의에서 %0 속성을 허용하지 않습니다'
# 'GCC does not allow an attribute in this position on a function declaration'
H6328F86D9296: 'GCC는 함수 선언의 이 위치에 속성을 허용하지 않습니다'
# 'GCC does not allow the %0 attribute to be written on a type'
HAF18361FDD0D: 'GCC는 %0 속성을 타입에 작성하는 것을 허용하지 않습니다'
# "GCC does not allow the 'cleanup' attribute argument to be anything other than a simple identifier"
HB0EE895D3D5D: "GCC는 'cleanup' 속성 인수가 단순 식별자 외의 어떤 것도 허용하지 않습니다"
# 'GCC does not allow variable declarations in for loop initializers before C99'
HD212EAC451BD: 'GCC는 C99 이전에 for 루프 초기화자 내에서 변수 선언을 허용하지 않습니다'
# 'GCC encoding (only meaningful for -sample)'
H893D2EDBC511: 'GCC 인코딩 (-sample 옵션과 함께 사용될 때만 의미가 있음)'
# 'GCC requires a function with the %0 attribute to be variadic'
H4044A123EF83: 'GCC는 %0 속성을 가진 함수가 가변 인자 함수여야 합니다'
# 'GCN Create VOPD Instructions'
HD50B13295BAC: 'GCN VOPD 명령어 생성'
# 'GCN DPP Combine'
H19E8A5665832: 'GCN DPP 결합'
# 'GCN NSA Reassign'
H506D8BF350C1: 'GCN NSA 재할당'
# 'GLIBC Vector Math library'
HFDA2A482B5C5: 'GLIBC 벡터 수학 라이브러리'
# 'GNU OpenMP'
H7F5648C19468: 'GNU 오픈MP'
# 'GNU decimal type extension not supported'
HE1719E002830: 'GNU 십진수 유형 확장은 지원되지 않습니다'
# 'GNU vector conditional operand cannot be %select{void|a throw expression}0'
H5DF13110207F: 'GNU 벡터 조건부 피연산자는 %select{void|a throw expression}0일 수 없습니다'
# 'GNU-style inline assembly is disabled'
H2E56E6455BF0: 'GNU 스타일의 인라인 어셈블리는 비활성화되었습니다'
# 'GNUstep Objective-C runtime version %0 incompatible with target binary format'
HBFB3FAB065B9: 'GNUstep Objective-C 런타임 버전 %0는 대상 바이너리 형식과 호환되지 않습니다'
# "GPU arch %0 is supported by CUDA versions between %1 and %2 (inclusive), but installation at %3 is %4; use '--cuda-path' to specify a different CUDA install, pass a different GPU arch with '--cuda-gpu-arch', or pass '--no-cuda-version-check'"
HA444373A0822: "GPU 아키텍처 %0는 CUDA 버전 %1부터 %2까지(포함)에서 지원되지만, %3에 설치된 CUDA 버전은 %4입니다. 다른 CUDA 설치 경로를 지정하려면 '--cuda-path' 옵션을 사용하세요, 다른 GPU 아키텍처는 '--cuda-gpu-arch' 옵션으로 전달하거나, '--no-cuda-version-check' 옵션을 전달하여 확인을 건너뛸 수 있습니다"
# 'Gang up loads and stores generated by inlining of memcpy'
HE535C0271E93: 'memcpy의 인라인화에 의해 생성된 로드와 스토어를 그룹화합니다'
# 'Gate the invocation of the tracing callbacks on a global variable. Currently only supported for trace-pc-guard and trace-cmp.'
HE7375E04E4A1: '추적 콜백 호출을 전역 변수에 따라 제어합니다. 현재는 trace-pc-guard 및 trace-cmp에서만 지원됩니다.'
# 'Generalize pointers in CFI indirect call type signature checks'
H05CAF1DC1C80: 'CFI 간접 호출 유형 서명 검사에서 포인터 일반화'
# 'Generate "extract" instructions'
HC571F6794268: '추출 명령문 생성'
# 'Generate "insert" instructions'
H783E8CF7431F: '“insert” 명령어 생성'
# 'Generate ARM CDE builtin code-generator for clang'
H5A5EC1A5B6C3: 'clang용 ARM CDE 내장 코드 생성기를 생성합니다'
# 'Generate ARM CDE builtin definitions for clang'
H4D955CE0B09F: 'clang용 ARM CDE 내장 정의 생성'
# 'Generate ARM CDE builtin sema checks for clang'
H322C3CB145B5: 'ARM CDE 내장 세마 체크 생성'
# 'Generate ARM MVE builtin code-generator for clang'
H51464E4006BA: 'clang에 대한 ARM MVE 내장 코드 생성기를 생성합니다'
# 'Generate ARM MVE builtin definitions for clang'
HB30829C9D62F: 'clang용 ARM MVE 내장 정의 생성'
# 'Generate ARM MVE builtin sema checks for clang'
H9EB24BD38363: 'ARM MVE 내장 세마 검사 생성을 위한 Clang'
# 'Generate ARM NEON sema support for clang'
HB47F65A392BE: 'clang을 위한 ARM NEON sema 지원 생성'
# 'Generate ARM NEON tests for clang'
HB3324D2A49FC: 'clang용 ARM NEON 테스트 생성'
# 'Generate AST expressions for unmodified and modified accesses'
H729F2BA5C5BE: '변경되지 않은 액세스와 수정된 액세스의 AST 표현 생성'
# 'Generate C++20 header units from header files'
H8199E8EA3A2D: '헤더 파일에서 C++20 헤더 유닛 생성'
# 'Generate CXX11 attributes info'
H008C47C9924C: 'CXX11 attributes 정보 생성'
# 'Generate Clang AST comment nodes'
H1A2137DB81DD: 'Clang AST 주석 노드 생성'
# 'Generate Clang AST declaration nodes'
H0D831097F249: 'Clang AST 선언 노드 생성'
# 'Generate Clang AST statement nodes'
H9DA2A7F822D1: 'Clang AST 문 노드 생성'
# 'Generate Clang AST type nodes'
H6C40DA5710E5: 'Clang AST 타입 노드 생성'
# 'Generate Clang AbstractTypeReader class'
H0B517D2DC9BE: 'Clang AbstractTypeReader 클래스 생성'
# 'Generate Clang AbstractTypeWriter class'
H3C1A155F700F: 'Clang AbstractTypeWriter class 생성'
# 'Generate Clang BasicReader classes'
HCAC9D912FD7C: 'Clang BasicReader 클래스 생성'
# 'Generate Clang BasicWriter classes'
H7777A854222B: 'Clang BasicWriter 클래스 생성'
# 'Generate Clang Static Analyzer checkers'
HAF44CF1570A7: 'Clang 정적 분석기 검사기 생성'
# 'Generate Clang constexpr interpreter opcodes'
HCE00FBA3D9DA: 'Clang constexpr 인터프리터 오퍼코드 생성'
# 'Generate Clang diagnostic compatibility ids'
HB3B0D51C372C: 'Clang 진단 호환성 ID 생성'
# 'Generate Clang diagnostic enums for selects'
HFF484ABCD39B: '선택을 위한 Clang 진단 열거형 생성'
# 'Generate Clang diagnostic groups'
HD491E8E3F838: 'Clang 진단 그룹 생성'
# 'Generate Clang diagnostic interface headers'
HC78769A357D2: 'Clang 진단 인터페이스 헤더 생성'
# 'Generate Clang diagnostic name index'
H26D83AD60FA3: 'clang 진단 이름 색인 생성'
# 'Generate Clang diagnostics definitions'
H42FB0D88C678: 'Clang 진단 정의 생성'
# 'Generate CodeView debug information'
H5E04C2FAE7DA: 'CodeView 디버그 정보 생성'
# 'Generate DWARF4 type units.'
H93A2FEDB326C: 'DWARF4 타입 유닛을 생성합니다.'
# 'Generate Extract API information as a side effect of compilation.'
H35927234EEF2: '컴파일 과정의 부산물로 API 정보 추출을 생성합니다.'
# 'Generate IR involving scalable vector types'
HBFD721B3719E: '확장 벡터 유형을 포함하는 IR 생성'
# 'Generate Interface Stub Files, emit merged text not binary.'
H48D6D551365C: '인터페이스 스텁 파일 생성, 병합된 텍스트를 생성하고 이진 파일은 생성하지 않음.'
# 'Generate Interface Stub Files.'
H93E694C37FB8: '인터페이스 스텁 파일 생성합니다.'
# 'Generate LBR info with perf itrace argument'
H63A1CBFF2B95: 'perf itrace 인수를 사용하여 LBR 정보 생성'
# 'Generate M NOPs before function entry'
H411052747AED: '함수 시작 전에 M NOP를 생성합니다'
# 'Generate M NOPs before function entry and N-M NOPs after function entry. If section is specified, use it instead of __patchable_function_entries.'
H4A7E3BFEB46A: '함수 진입 전 M NOP 생성하고 함수 진입 후 N-M NOP 생성. 섹션이 지정되면 __patchable_function_entries 대신 사용'
# 'Generate Metal library'
H30181B8F806A: '메탈 라이브러리 생성'
# 'Generate Offload API header contents'
H228CB18FCD9A: '오프로드 API 헤더 내용 생성'
# 'Generate Offload API print header'
HDB1F685BA2FE: 'Offload API 출력 헤더 생성'
# 'Generate Offload API wrapper function definitions'
HE6C5D6F8A8FB: 'Offload API 랩퍼 함수 정의 생성'
# 'Generate Offload Error Code enum'
HD6D65DD43A04: '오프로드 오류 코드 열거형 생성'
# 'Generate OpenCL builtin declaration handlers'
HA18DDE5AEDF3: 'OpenCL 내장 선언 핸들러 생성'
# 'Generate OpenCL builtin declaration tests'
H5DAE86CEEBCA: 'OpenCL 내장 선언 테스트 생성'
# 'Generate OpenCL builtin header'
H2590CD761606: 'OpenCL 내장 헤더 생성'
# 'Generate SPIR-V code'
HC1B38B428E45: 'SPIR-V 코드 생성'
# 'Generate Scalar MASS entries'
H428973D80E2B: '스칼라 MASS 항목 생성'
# 'Generate XRay instrumentation sleds on function entry and exit'
H3016D234FBA9: '함수 진입 및 종료 시 XRay 인스트루먼테이션 슬리드 생성'
# 'Generate a .mlir reproducer file at the given output path if the pass manager crashes or fails'
HBC83C0234127: '패스 매니저가 크래시되거나 실패할 경우 지정된 출력 경로에 .mlir 재현 파일을 생성합니다'
# 'Generate a YAML optimization record file'
H1942B716CF27: 'YAML 최적화 기록 파일을 생성합니다'
# 'Generate a __mcount_loc section entry for each __fentry__ call.'
HE460D06CF31F: '각 __fentry__ 호출마다 __mcount_loc 섹션 항목을 생성합니다.'
# 'Generate a clang attribute list'
H89A583ECD8F5: 'clang 속성 목록 생성'
# 'Generate a clang attribute spelling index'
HE19534D90FCA: 'clang 속성 철자 색인 생성'
# 'Generate a clang attribute spelling list'
H4F8740D65FE7: 'clang 속성 맞춤법 목록 생성'
# 'Generate a clang attribute subject match rule list'
HC95A81873DA9: 'Clang 속성 대상 일치 규칙 목록을 생성합니다'
# 'Generate a clang parsed attribute kinds'
H78888371BD55: 'clang이 파싱한 속성 종류 생성'
# 'Generate a clang parsed attribute list'
HD97B596A50F3: 'Clang 파싱된 속성 목록 생성'
# 'Generate a clang template instantiate code'
H961D4AD666CA: 'clang 템플릿 인스턴스화 코드 생성'
# 'Generate a list of all Offload API function names'
H3DB190C217E7: '오프로드 API의 모든 함수 이름 목록을 생성합니다'
# 'Generate a list of attributes supported by #pragma clang attribute for testing purposes'
HE3D52A2C4CA9: '테스트를 위한 #pragma clang attribute가 지원하는 속성 목록을 생성합니다'
# 'Generate a list of regular keyword attributes with info about their arguments'
H86F657FC95B7: '정규 키워드 속성의 목록을 생성하고 각각의 인자 정보를 포함합니다'
# 'Generate a partial profile (only meaningful for -extbinary)'
H8B3C403992F1: '부분 프로파일을 생성합니다( -extbinary 옵션과 함께 사용할 때만 의미가 있습니다)'
# 'Generate a pch file for all code up to and including <filename>'
H3A6818A5EE16: '모든 코드에서 <filename>까지 포함하여 pch 파일 생성'
# 'Generate a recursive AST visitor for clang attributes'
HD2CD27931B90: 'clang 속성을 위한 재귀적 AST 방문자를 생성합니다'
# 'Generate a sparse profile (only meaningful for -instr)'
H2390B2DEB1A2: '스파스 프로파일을 생성(단, -instr 옵션과 함께 사용할 때 의미가 있음)'
# 'Generate a table of attribute documentation'
H4075E225B4D0: '속성 설명서 테이블을 생성합니다'
# 'Generate absolute set instructions'
HD09B902A76CD: '절대 설정 명령어 생성'
# 'Generate additional symbol graphs for extended modules.'
H621EAE5CB426: '확장된 모듈을 위해 추가적인 심볼 그래프를 생성합니다.'
# 'Generate all instruction with TC'
HCB4E103EFF3E: 'TC를 사용하여 모든 명령어 생성'
# 'Generate all parser-related attribute string switches'
HBC7D18EAD0C4: '모든 parser 관련 attribute 문자열 스위치를 생성합니다'
# 'Generate all parser-related attribute subject match rulestring switches'
H3DDA6CE234B8: '모든 파서 관련 속성 대상 일치 룰스트링 스위치 생성'
# 'Generate all reports.'
H56F361794B7A: '모든 보고서를 생성합니다.'
# 'Generate an mlir reproducer at the provided filename (no crash required)'
HEF652CF84C8A: '지정된 파일 이름에 mlir 재현 파일을 생성합니다(クラ시가 필요 없습니다)'
# 'Generate an optimization record file in a specific format'
H93DDC23AE075: '특정 형식의 최적화 기록 파일을 생성합니다'
# 'Generate an optimized version of the match table'
HB99621634FE9: '매치 테이블의 최적화된 버전을 생성합니다'
# 'Generate any type of IT block'
H3521C624C6E3: '어떠한 유형의 IT 블록도 생성합니다'
# 'Generate arm_bf16.h for clang'
H4049A4CCEEB2: 'clang용 arm_bf16.h 생성'
# 'Generate arm_cde.h for clang'
H20C9AE949999: 'clang용 arm_cde.h 생성'
# 'Generate arm_fp16.h for clang'
HA003409EA627: 'Clang용 arm_fp16.h 생성'
# 'Generate arm_immcheck_types.inc (immediate range check types) for clang'
H3E399A3BC5ED: 'clang용 arm_immcheck_types.inc (즉시 범위 검사 유형) 생성'
# 'Generate arm_mve.h for clang'
H9B02FDBF61FE: 'clang용 arm_mve.h 생성'
# 'Generate arm_neon.h for clang'
HBC7A4B2C0607: 'clang용 arm_neon.h 생성'
# 'Generate arm_sme.h for clang'
HE4D6EF6670EF: 'clang용 arm_sme.h 생성'
# 'Generate arm_sme_builtin_cg_map.inc for clang'
H9942231BE658: 'clang 용 arm_sme_builtin_cg_map.inc 생성'
# 'Generate arm_sme_builtins.inc for clang'
HB5A0445595D2: 'clang용 arm_sme_builtins.inc 생성'
# 'Generate arm_sme_builtins_za_state.inc for clang'
H1A92D0667981: 'clang용 arm_sme_builtins_za_state.inc 생성'
# 'Generate arm_sme_sema_rangechecks.inc for clang'
H934D5C9C551E: 'clang용 arm_sme_sema_rangechecks.inc 생성'
# 'Generate arm_sme_streaming_attrs.inc for clang'
HB0ACDD97739D: 'clang을 위해 arm_sme_streaming_attrs.inc 생성'
# 'Generate arm_sve.h for clang'
HA4A04F03FE49: 'clang용 arm_sve.h 생성'
# 'Generate arm_sve_builtin_cg_map.inc for clang'
H85004239686F: 'clang용 arm_sve_builtin_cg_map.inc 생성'
# 'Generate arm_sve_builtins.inc for clang'
H521827D71962: 'clang용 arm_sve_builtins.inc 생성'
# 'Generate arm_sve_sema_rangechecks.inc for clang'
H7845A0DBDBD3: 'clang 용 arm_sve_sema_rangechecks.inc 생성'
# 'Generate arm_sve_streaming_attrs.inc for clang'
H0E1FDBC6C09B: 'clang을 위한 arm_sve_streaming_attrs.inc 생성'
# 'Generate arm_sve_typeflags.inc for clang'
HACE26ADDC9C9: 'clang용 arm_sve_typeflags.inc 파일 생성'
# 'Generate arm_vector_types.h for clang'
H7C1E9F56F891: 'clang을 위한 arm_vector_types.h 생성'
# 'Generate attribute documentation'
H5EECEC688125: '속성 설명서 생성'
# 'Generate attribute spelling list'
H5E3166505291: '속성 철자 목록 생성'
# 'Generate attributes for this dialect'
HE3FD9C3103CA: '이 방언에 대한 속성 생성'
# 'Generate bitsplit instructions'
HE0B4AD43ABB0: '비트 분할 명령문을 생성합니다.'
# 'Generate branches with extended addressability, usually via indirect jumps.'
H84AA69F9BF2B: '확장된 주소 가능성을 가진 분기를 생성, 일반적으로 간접 점프를 통해.'
# 'Generate calls to instrument function entry and exit'
HFC18B10AD85D: '함수 진입과 퇴장 시 인스트루먼트 함수 호출을 생성합니다'
# 'Generate clang PCH attribute reader'
HACB0FB3DEE14: 'clang PCH 속성 리더 생성'
# 'Generate clang PCH attribute writer'
H0829BFECBA6A: 'clang PCH 속성 작성기 생성'
# 'Generate clang attribute clases'
HCAA1C36C6E17: 'clang 속성 클래스 생성'
# 'Generate clang attribute implementations'
H58D8D7EF6BF7: 'clang 속성 구현 생성'
# 'Generate clang attribute text node dumper'
H7B79A1565130: 'clang 속성 텍스트 노드 덤플러 생성'
# 'Generate clang attribute traverser'
H82452D8DFFBB: 'clang 속성 순회기 생성'
# 'Generate clang builtins list'
H7DD3DD5CD09E: 'clang 내장 함수 목록 생성'
# 'Generate code for CUDA device'
H28657BCC831E: 'CUDA 장치용 코드 생성'
# 'Generate code for SYCL device.'
HFDECAC3EE76F: 'SYCL 장치용 코드 생성.'
# 'Generate code for an additional runtime variant of the deployment target'
HC009196F06DE: '배포 대상의 추가 런타임 변형에 대한 코드를 생성합니다'
# 'Generate code for statically linking libclosure (BlocksRuntime)'
H655EBC8C95D8: 'libclosure (BlocksRuntime)를 위한 정적 링킹 코드를 생성합니다'
# 'Generate code for the given target'
H978948BBCF74: '지정된 대상에 대한 코드 생성'
# 'Generate code for uses of this PCH that assumes an explicit object file will be built for the PCH'
H73D5D7524BBC: '이 PCH의 사용을 위해 명시적인 오브젝트 파일이 생성될 것으로 가정하는 경우에 코드를 생성합니다.'
# 'Generate code for uses of this module that assumes an explicit object file will be built for the module'
H0A914343419E: '이 모듈 사용 시 이 모듈에 대해 명시적 객체 파일이 생성됨을 가정하는 경우에 대한 코드를 생성합니다'
# 'Generate code only for an OpenMP target device.'
H22275002B232: 'OpenMP 대상 장치에 대해서만 코드를 생성합니다.'
# 'Generate code which only uses the general purpose registers (AArch64/x86 only)'
HE13BDFDB4618: '일반 목적 레지스터만 사용하는 코드를 생성합니다 (AArch64/x86 전용)'
# 'Generate command properties for commands that are used in documentation comments'
HDF34DF8FD98C: '문서 주석에서 사용되는 명령어에 대한 명령어 속성을 생성합니다'
# 'Generate coverage instrumentation for GlobalISel'
H98DAD8E8562B: 'GlobalISel을 위한 커버리지 인스트루멘테이션 생성'
# 'Generate coverage mapping to enable code coverage analysis'
H3FA8EAFBA329: '코드 커버리지 분석을 활성화하기 위해 커버리지 매핑을 생성합니다'
# 'Generate data collectors for AST nodes'
HB676E426CC9E: 'AST 노드를 위한 데이터 수집기를 생성합니다'
# 'Generate debug info for types in an object file built from this PCH and do not generate them elsewhere'
H2C592F95A21D: '이 PCH로부터 생성된 오브젝트 파일 내의 타입에 대한 디버그 정보를 생성하고, 다른 곳에서는 생성하지 않습니다'
# 'Generate debug info for types in an object file built from this module and do not generate them elsewhere'
HE7EB6B773956: '이 모듈에서 생성된 오브젝트 파일에 대한 타입의 디버그 정보를 생성하고 다른 곳에서는 생성하지 않습니다'
# 'Generate debug info with external references to clang modules or precompiled headers'
HAD4093E5621B: '디버그 정보를 생성하고 clang 모듈 또는 사전 컴파일된 헤더에 대한 외부 참조를 포함합니다'
# 'Generate debugging info in the 64-bit DWARF format'
H70C04792FFA2: '64-bit DWARF 형식으로 디버깅 정보를 생성'
# 'Generate declarations for Offload API implementation functions'
H36074FE5A628: '오프로드 API 구현 함수의 선언을 생성합니다'
# 'Generate definitions of Clang Syntax Tree node clasess'
H83004344D792: 'Clang 구문 트리 노드 클래스 정의 생성'
# 'Generate diagnostic documentation'
H376A46B39692: '진단 문서 생성'
# 'Generate directives for this dialect'
HF8CA4ECC7825: '이 방언에 대한 지시문 생성'
# 'Generate dot files into specified directory for changed IRs'
HD4CB202E81D5: '지정된 디렉토리에 변경된 IR의 dot 파일 생성'
# 'Generate dwarf aranges'
H6F048344D108: 'DWARF aranges 생성'
# 'Generate dwarf debugging info for assembly source files'
H5645E7139B8A: '어셈블기 소스 파일에 대한 DWARF 디버깅 정보를 생성합니다'
# 'Generate efficient matchers for HTML tag names that are used in documentation comments'
H20BDF8097FEE: '문서 주석에서 사용되는 HTML 태그 이름을 위한 효율적인 매처를 생성합니다'
# 'Generate efficient matchers for HTML tag properties'
H7F720B1F0148: 'HTML 태그 속성에 대한 효율적인 매처 생성'
# 'Generate explicit import from anonymous namespace to containing scope'
HAFE44C2C60BD: '익명 네임스페이스에서 포함된 범위로 명시적 import 생성'
# 'Generate export file for the Offload library'
H1A8F89282970: 'Offload 라이브러리용 Export 파일 생성'
# 'Generate extract instructions'
HABD4DCD38172: '추출 명령어 생성'
# 'Generate function to translate named character references to UTF-8 sequences'
H2212027837CC: '이름 지정된 문자 참조를 UTF-8 시퀀스로 변환하는 함수 생성'
# 'Generate hot text symbols. Apply this option to a precompiled binary that manually calls into hugify, such that at runtime hugify call will put hot code into 2M pages. This requires relocation.'
HE07FCEA6613B: '핫 텍스트 심볼을 생성합니다. 이 옵션을 hugify로 직접 호출하는 미리 컴파일된 이진 파일에 적용해야 합니다. 이렇게 하면 실행 중에 hugify 호출이 2M 페이지에 핫 코드를 할당하게 됩니다. 이는 재배치가 필요합니다.'
# 'Generate instrumented code to collect context sensitive execution counts into <directory>/default.profraw (overridden by LLVM_PROFILE_FILE env var)'
H10A2DF54F49A: '컨텍스트에 민감한 실행 횟수를 수집하기 위해 측정 코드를 생성하여 <directory>/default.profraw에 저장(LVM_PROFILE_FILE 환경 변수에 의해 재정의됨)'
# 'Generate instrumented code to collect context sensitive execution counts into default.profraw (overridden by LLVM_PROFILE_FILE env var)'
HCBAB6F9C9B4D: '인스트루먼테이션 코드를 생성하여 컨텍스트 감도 실행 횟수를 default.profraw에 수집 (LLVM_PROFILE_FILE 환경 변수에 의해 재정의됨)'
# 'Generate instrumented code to collect coverage info for cold functions into <directory>/default.profraw (overridden by LLVM_PROFILE_FILE env var)'
H389023BECF0C: '콜드 함수의 커버리지 정보를 수집하기 위해 인스트루먼트 코드를 생성하여 <directory>/default.profraw에 저장합니다 (LLVM_PROFILE_FILE 환경 변수에 의해 재정의됨)'
# "Generate instrumented code to collect coverage info for cold functions into default.profraw file (overridden by '=' form of option or LLVM_PROFILE_FILE env var)"
H40F8D1777D6C: "콜드 함수의 커버리지 정보를 수집하기 위해 default.profraw 파일에 기기 코드를 생성합니다 (옵션의 '=' 형태나 LLVM_PROFILE_FILE 환경 변수에 의해 재정의됨)"
# 'Generate instrumented code to collect execution counts into <directory>/default.profraw (overridden by LLVM_PROFILE_FILE env var)'
H884AE4DB8A23: '실행 횟수를 <directory>/default.profraw에 수집하기 위해 애플리케이션 코드를 생성합니다 (LLVM_PROFILE_FILE 환경 변수에 의해 재정의됨)'
# 'Generate instrumented code to collect execution counts into <file> (overridden by LLVM_PROFILE_FILE env var)'
HF1CDB71BC3BA: '측정 코드를 생성하여 실행 횟수를 <파일>에 수집 (LLVM_PROFILE_FILE 환경 변수에 의해 덮어쓰어짐)'
# 'Generate instrumented code to collect execution counts into default.profraw (overridden by LLVM_PROFILE_FILE env var)'
HEDA64E6D9E58: '기본.profraw 파일에 실행 횟수를 수집하기 위해 악기화된 코드 생성(LLVM_PROFILE_FILE 환경 변수에 의해 재정의됨)'
# "Generate instrumented code to collect execution counts into default.profraw file (overridden by '=' form of option or LLVM_PROFILE_FILE env var)"
HCED0768BDFD7: "실행 횟수를 default.profraw 파일에 수집하기 위해 프로파일링 코드를 생성(옵션의 '=' 형식 또는 LLVM_PROFILE_FILE 환경 변수에 의해 대체됨)"
# 'Generate instrumented code to collect temporal information'
H454449192474: '시간 정보를 수집하기 위해 인스트루먼테이션 코드를 생성합니다'
# 'Generate intrinsics with this target prefix'
H5CEC7C3808CA: '이 타겟 접두사로 인트린식 생성'
# 'Generate invalid output'
H668CF0E474FA: '잘못된 출력 생성'
# 'Generate list of Clang Syntax Tree node types'
H3A9E31163210: 'Clang Syntax Tree 노드 유형 목록을 생성합니다'
# 'Generate list of commands that are used in documentation comments'
H55166381B0A4: '문서 주석에서 사용되는 명령어 목록을 생성합니다'
# 'Generate list of valid ARM CDE builtin aliases for clang'
H1E92420752F1: 'clang용 유효한 ARM CDE 내장 별명 목록 생성'
# 'Generate list of valid ARM MVE builtin aliases for clang'
H18CC5313A2F6: 'clang에 대한 유효한 ARM MVE 내장 별칭 목록 생성'
# 'Generate lldb option definitions'
HF07E69C59A11: 'lldb 옵션 정의를 생성합니다'
# 'Generate lldb property definitions'
HBD76019A4518: 'LLDB 속성 정의 생성'
# 'Generate lldb property enum definitions'
H4D3EB8680DC4: 'lldb 프로퍼티 enum 정의 생성'
# 'Generate local calls to out-of-line atomic operations'
H160B36160D89: '아웃-오브-라인 원자 연산에 대한 로컬 호출 생성'
# 'Generate loop nest for tiling.'
H40BB5343F902: '타일링을 위한 루프 네스트 생성'
# 'Generate low-precision inline sequences for some float libcalls'
HA2542185A00F: '일부 float libcalls에 대한 낮은 정밀도 인라인 시퀀스를 생성합니다'
# 'Generate machine code, but discard output'
HA74064264324: '머신 코드를 생성하지만 출력을 삭제합니다'
# 'Generate mcount/__fentry__ calls as nops. To activate they need to be patched in.'
HE3A927985452: 'mcount/__fentry__ 호출을 nop로 생성합니다. 활성화하려면 해당 호출을 패치해야 합니다.'
# 'Generate nested function profiles for CSSPGO'
H267DA13728E4: 'CSSPGO를 위한 중첩된 함수 프로파일 생성'
# 'Generate option documentation'
HF1C9A7ED3825: '옵션 문서 생성'
# 'Generate output compatible with the standard GNU Objective-C runtime'
H0A3E1D413F6F: '표준 GNU Objective-C 런타임과 호환되는 출력을 생성합니다'
# 'Generate pre-compiled header file'
H6076A415050D: '이전처리된 헤더 파일 생성'
# 'Generate pre-compiled module file from a module map'
H32E4ACE09217: '모듈 맵에서 미리 컴파일된 모듈 파일 생성'
# 'Generate pre-compiled module file from a standard C++ module interface unit'
H332BF5CFA1C0: '표준 C++ 모듈 인터페이스 유닛에서 사전 컴파일된 모듈 파일 생성'
# 'Generate random hotness values'
H5B6B1D07D43D: '임의의 핫니스 값 생성'
# 'Generate read-only position independent code (ARM only)'
H8619C4BF8421: '읽기 전용 위치 독립 코드 생성 (ARM 전용)'
# 'Generate read-write position independent code (ARM only)'
H49DE9A8DC6D7: '읽고 쓰기 가능 위치 독립 코드 생성 (ARM 전용)'
# 'Generate reduced prebuilt module interface from a standard C++ module interface unit'
HBCD3850127B9: '표준 C++ 모듈 인터페이스 단위에서 축소된 사전 컴파일 모듈 인터페이스를 생성합니다'
# 'Generate relocatable device code, also known as separate compilation mode'
H2AB415613F7B: '재배치 가능한 장치 코드(분리된 컴파일 모드)를 생성합니다'
# 'Generate riscv_andes_vector_builtin_cg.inc for clang'
H99B584F39405: 'clang용 riscv_andes_vector_builtin_cg.inc 생성'
# 'Generate riscv_andes_vector_builtin_sema.inc for clang'
HBB62F00F6C63: 'clang용 riscv_andes_vector_builtin_sema.inc 생성'
# 'Generate riscv_andes_vector_builtins.inc for clang'
H01F7AE9F3E5F: 'clang용 riscv_andes_vector_builtins.inc 생성'
# 'Generate riscv_sifive_vector_builtin_cg.inc for clang'
H2F882B6DED2D: 'clang용 riscv_sifive_vector_builtin_cg.inc 생성'
# 'Generate riscv_sifive_vector_builtin_sema.inc for clang'
HD872420A09E4: 'clang용 riscv_sifive_vector_builtin_sema.inc 생성'
# 'Generate riscv_sifive_vector_builtins.inc for clang'
HD182FA023D72: 'clang용 riscv_sifive_vector_builtins.inc 생성'
# 'Generate riscv_vector.h for clang'
HECE8F71BFB56: 'clang을 위한 riscv_vector.h 생성'
# 'Generate riscv_vector_builtin_cg.inc for clang'
H5A79CE9F1F74: 'clang을 위해 riscv_vector_builtin_cg.inc 생성'
# 'Generate riscv_vector_builtin_sema.inc for clang'
HA3230378A26C: 'clang용 riscv_vector_builtin_sema.inc 생성'
# 'Generate riscv_vector_builtins.inc for clang'
H5D02D25DD210: 'clang용 riscv_vector_builtins.inc 생성'
# 'Generate same-address load-load barrier instructions (dbar 0x700)'
HA12298FF2D2D: '동일 주소 로드-로드 배리어 명령어(dbar 0x700) 생성'
# 'Generate software floating point library calls'
H05167BC54E72: '소프트웨어 부동소수점 라이브러리 호출 생성'
# 'Generate source-level debug information'
HAEF3BF8D74CD: '소스 레벨 디버그 정보 생성'
# 'Generate source-level debug information with dwarf version 2'
HD2B80CB88FC9: '소스 레벨 디버그 정보 생성 및 DWARF 버전 2 사용'
# 'Generate source-level debug information with dwarf version 3'
HA4075062488F: 'DWARF 버전 3을 사용하여 소스 레벨 디버그 정보를 생성합니다'
# 'Generate source-level debug information with dwarf version 4'
H248AE385BE0D: '소스 레벨 디버그 정보를 dwarf 버전 4로 생성합니다'
# 'Generate source-level debug information with dwarf version 5'
HE4BA3B14D0D7: '소스 레벨 디버그 정보를 생성하고 DWARF 버전 5를 사용합니다'
# 'Generate source-level debug information with the default dwarf version'
H938AF5B9960A: '소스 레벨 디버그 정보를 디폴트 DWARF 버전으로 생성합니다'
# 'Generate the clang parsed attribute helpers'
HFA9E86870CB2: 'clangParsedAttributeHelper를 생성합니다'
# 'Generate the profile for Linux kernel binary.'
HB596668CB82B: '리눅스 커널 바이너리 프로파일 생성'
# 'Generate the reduced BMI'
HED698C3C66EE: '축소된 BMI를 생성합니다'
# 'Generate thread parallel code (isl codegen only)'
H34625E399986: '쓰레드 병렬 코드 생성 (isl codegen 전용)'
# 'Generate types for this dialect'
H62C541A61A79: '이 방언에 대한 타입 생성'
# 'Generate unique debug info for each instruction with a memory operand. Should be enabled for profile-driven cache prefetching, both in the build of the binary being profiled, as well as in the build of the binary consuming the profile.'
H337DAB1315D8: '각 메모리 연산자를 가진 명령문에 대해 고유한 디버그 정보를 생성합니다. 프로파일 기반 캐시 프리패칭을 위해 활성화되어야 하며, 이는 프로파일되는 바이너리의 빌드뿐만 아니라 프로파일을 사용하는 바이너리의 빌드에서도 마찬가지입니다.'
# 'Generate unoptimized CFGs for all analyses'
HA85B8A701BAB: '모든 분석을 위한 최적화되지 않은 CFG 생성'
# 'Generate unwinding tables for all functions'
HF1490D883AAC: '모든 함수에 대해 언윈딩 테이블 생성'
# 'Generate verbose assembly output'
H0B7F9E41E63B: '상세 어셈블리 출력을 생성'
# 'Generated inlined abstract references.'
H21A52BEF39EC: '인라인된 추상 참조가 생성되었습니다.'
# 'Generates tables to help identify patterns matched'
HD3439779FA7F: '매칭된 패턴을 식별하기 위해 테이블을 생성합니다'
# 'Generator to run'
H9B18D7EC4146: '실행할 생성기'
# 'Generic Options'
H5EEF255AAE70: '일반 옵션'
# 'Generic memory optimizations'
H800F1622EB9A: '메모리 최적화 기본 사항'
# 'Get the symbol definition from <line> <start-column> <end-column>'
H9C96E5C80114: '문자 정의를 줄 <line>, 시작 열 <start-column>, 종료 열 <end-column>에서 가져옵니다'
# 'Give each function an independent TBAA tree (default)'
H7A952E99A7FC: '각 함수에 독립적인 TBAA 트리를 제공(기본값)'
# 'Give global C++ operator new and delete declarations hidden visibility'
HAD504B33021E: '전역 C++ operator new 및 delete 선언에 은닉 가시성을 부여합니다'
# "Give global types 'default' visibility and global functions and variables 'hidden' visibility by default"
H095BFBCE25DF: "기본적으로 글로벌 타입에는 'default' 가시성을, 함수와 변수에는 'hidden' 가시성을 적용합니다"
# 'Give inline C++ member functions hidden visibility by default'
HAF1CF839FC8A: '인라인 C++ 멤버 함수에 기본적으로 숨겨진 가시성을 부여합니다'
# 'Give the maximum number of instructions that we will use for creating a floating-point immediate value'
HB7780EA795D5: '플로팅 포인트 즉시 값 생성에 사용할 명령문의 최대 수를 지정합니다'
# 'Give the maximum size (in number of nodes) of the web of instructions that we will consider for VW expansion'
H6AD97D209EFA: 'VW 확장에 사용할 명령어 웹의 최대 크기를 (노드 수로 지정)하세요'
# 'Give unique names to every basic block section'
HE9E6E34AE2B8: '각 기본 블록 섹션에 고유한 이름을 지정하십시오'
# 'Give unique names to every section'
HAE1CB86AEAE6: '모든 섹션에 고유한 이름을 지정해야 합니다'
# 'Global Pointer Addressing Size.  The default size is 8.'
H7DA66DD4C059: '전역 포인터 주소 지정 크기입니다. 기본 크기는 8입니다.'
# 'Global Value Numbering'
H7BB46D78F883: '전역 값 번호 지정'
# 'Global merge function pass'
H22AF90C7A55F: '전역 병합 함수 패스'
# 'GlobalISel Combiner'
H204136E4EB5C: '전역 선택 조합기'
# 'Globally set the denormals-are-zero (DAZ) and flush-to-zero (FTZ) bits in the floating-point control register on program startup'
H3BA6F3373251: '프로그램 시작 시 부동소수점 제어 레지스터의 denormals-are-zero (DAZ) 및 flush-to-zero (FTZ) 비트를 전역적으로 설정합니다'
# 'Globals Alias Analysis'
H9A682873774C: '전역 별칭 분석'
# 'Good Bye World Pass'
H6716A126CB42: '안녕, 세상 패스'
# 'Gradient gain threshold (%).'
H28D3EF05A6AB: '경사도 증益 임계값 (%).'
# 'Greedy Register Allocator'
HB8463656EACF: '탐욕스러운 레지스터 할당기'
# 'Greedy register allocator'
HE2214CA75FBC: '그리디 레지스터 할당기'
# 'Guard UBSAN checks with `llvm.allow.ubsan.check()`.'
H368DFFFB3230: 'UBSAN 검사 항목을 `llvm.allow.ubsan.check()`로 제어합니다.'
# 'Guard against compiler/runtime version mismatch.'
HA3897596A344: '컴파일러/런타임 버전이 불일치하는 것을 방지합니다.'
# 'Guided scheduling'
H4B9648519786: '가이드 스케줄링'
# 'HIP Standard Parallel Algorithm Acceleration library path, used for finding and implicitly including the library header'
H8403B00ECFB8: 'HIP 표준 병렬 알고리즘 가속 라이브러리 경로, 라이브러리 헤더를 찾고 암묵적으로 포함시키기 위해 사용됨'
# 'HIP device library'
H14BC304940A6: 'HIP 장치 라이브러리'
# 'HIP does not support OpenMP target directives; directive has been ignored'
H0DF90C6E349C: 'HIP는 OpenMP 타겟 지시문을 지원하지 않습니다; 해당 지시문이 무시되었습니다'
# 'HIP runtime installation path, used for finding HIP version and adding HIP include path.'
HD2A8F00A760F: 'HIP 런타임 설치 경로, HIP 버전을 찾고 HIP 포함 경로를 추가하기 위해 사용됨.'
# 'HIP version in the format of major.minor.patch'
H4C1B608415FC: '주요.소.패치 형식의 HIP 버전'
# 'HLSL Version'
HB3FA8D10C87C: 'HLSL 버전'
# "HLSL code generation is unsupported for target '%0'"
HE92A9C826849: "HLSL 코드 생성은 타겟 '%0'에서 지원되지 않습니다."
# 'HLSL only. Disables all standard includes containing non-native compiler types and functions.'
H1F13E0FA5ECA: 'HLSL 전용. 비네이티브 컴파일러 유형과 함수를 포함하는 모든 표준 인클루드를 비활성화합니다.'
# 'HLSL resource needs to have [[hlsl::resource_class()]] attribute'
HAC100FF02618: 'HLSL 리소스는 [[hlsl::resource_class()]] 속성을 가져야 합니다'
# "HTML end tag '%0' is forbidden"
H685A0F5F60EA: "HTML 종료 태그 '%0'는 금지되었습니다"
# 'HTML end tag does not match any start tag'
H04F1BAAABD62: 'HTML 종료 태그가 시작 태그와 일치하지 않습니다'
# 'HTML output'
H9222F90CA7BE: 'HTML 출력'
# "HTML start tag '%0' closed by '%1'"
H5D28040DFF0A: "HTML 시작 태그 '%0'이 '%1'에 의해 닫힘"
# "HTML start tag prematurely ended, expected attribute name or '>'"
HB396911AC86C: "HTML 시작 태그가 조기 종료됨, 속성 이름 또는 '>'가 필요합니다"
# "HTML tag '%0' requires an end tag"
HC3A525011E51: "HTML 태그 '%0'는 종료 태그가 필요합니다"
# 'HTML tag started here'
H3CB5C9051AF3: 'HTML 태그가 여기에서 시작되었습니다'
# 'HWASan shadow mapping dynamic offset location'
H0D34082EDF7B: 'HWASan 쉐이도우 매핑 동적 오프셋 위치'
# 'HWASan shadow mapping offset [EXPERIMENTAL]'
H2991A813E596: 'HWASan 쉐도우 맵 오프셋 [실험적]'
# 'Handle <= and >= in finite loops'
H5AA1FAB9586D: '유한 루프에서 <= 및 >= 처리'
# 'Handle C++ exceptions (insert cleanup blocks for unwinding)'
H250354C717B0: 'C++ 예외 처리(언윈딩을 위한 정리 블록 삽입)'
# 'Handle C++ initializer order'
HC63CC32922AA: 'C++ 초기화 순서 처리'
# 'Handle global objects'
H5D8738E4497F: '전역 객체 처리'
# 'Handle stack memory'
H9B9B06338F2E: '스택 메모리 처리'
# 'Hard float ABI (uses FP registers)'
HEEAB4CE3F0BA: '하드웨어 부동소수점 ABI(FP 레지스터 사용)'
# 'Hard-coded mapping'
H6EC79E37D2B2: '직접 지정된 매핑'
# 'Harden indirect calls and jumps against using speculatively stored attacker controlled addresses. This is designed to mitigate Spectre v1.2 style attacks.'
H64FF4BC73D36: '간접 호출 및 점프를 공격자가 제어하는 추측 저장 주소의 사용으로부터 강화합니다. 이 옵션은 Spectre v1.2 유형 공격을 완화하기 위해 설계되었습니다.'
# 'Harden inline assembly code that may be vulnerable to Load Value Injection (LVI). This feature is experimental.'
H9EF1510D3F11: 'Load Value Injection(LVI) 취약점에 노출될 수 있는 인라인 어셈블리 코드를 강화합니다. 이 기능은 실험적 단계입니다.'
# 'Harden interprocedurally by passing our state in and out of functions in the high bits of the stack pointer.'
HD67DA497275B: '인터프로시저적으로 강화하기 위해 스택 포인터의 상위 비트에 함수의 진입과 출구에서 상태를 전달합니다.'
# 'Harden the value loaded *after* it is loaded by flushing the loaded bits to 1. This is hard to do in general but can be done easily for GPRs.'
HC7A0E024F604: '로드된 후의 값을 플러시하여 로드된 비트를 1로 하여 경화합니다. 일반적으로는 어렵지만 GPR의 경우 쉽게 수행할 수 있습니다.'
# 'Hardware Loop Insertion'
HD9C10B054698: '하드웨어 루프 삽입'
# 'Hardware multiplier use mode for MSP430'
HE8A05395F9BD: '하드웨어 멀티플라이어 사용 모드 (MSP430용)'
# 'Hash long pathnames'
H2984D386D5E0: '긴 경로 이름 해시화'
# 'Hazard size for streaming mode memory accesses. 0 = disabled.'
H4C73818D60FE: '스트리밍 모드 메모리 접근을 위한 해저드 크기. 0 = 비활성화.'
# 'Heatmap options'
H6D36D04383CD: '히트맵 옵션'
# 'Helps find bugs by verifying the IR whenever we emit new instructions (*very* expensive).'
H92F16AA997F0: '새 명령문을 생성할 때마다 IR을 검증하여 버그를 찾아줍니다. (*매우* 비용이 큽니다).'
# 'Heuristics-based inliner version'
H91CCDBD88F85: '휴리스틱 기반 인라인어 버전'
# 'Hexagon Assembly Printer'
H04AB1ED5271E: '헥사곤 어셈블리 프린터'
# 'Hexagon Branch Relaxation'
HE56E26D71726: 'Hexagon 분기 완화'
# 'Hexagon CFG Optimizer'
HADEAF8F4224F: 'Hexagon CFG 최적화기'
# 'Hexagon Common GEP'
H7416FD0F0215: 'Hexagon 일반 GEP'
# 'Hexagon Constant Propagation'
H4545D96F56E6: 'Hexagon 상수 전파'
# 'Hexagon Copy-To-Combine Pass'
HA9D6C5272766: 'Hexagon 복사-결합 패스'
# 'Hexagon DAG->DAG Pattern Instruction Selection'
H8C61F3028012: 'Hexagon DAG->DAG 패턴 기반 명령 선택'
# 'Hexagon Expand Condsets'
H77C9EE5ECE10: 'Hexagon 조건 집합 확장'
# 'Hexagon Generate Load/Store Set Absolute Address Instruction'
HDCC2529025E3: 'Hexagon 로드/스토어 절대 주소 설정 명령어 생성'
# 'Hexagon Hardware Loops'
H430E0FA91788: 'Hexagon 하드웨어 루프'
# 'Hexagon Hardware Loops Fixup'
HEBB89CCF449D: 'Hexagon 하드웨어 루프 수정'
# 'Hexagon Load Widening'
H629EAC297715: 'Hexagon 로드 확장'
# 'Hexagon Loop Rescheduling'
H9B5F9E54FF64: 'Hexagon 루프 재스케줄링'
# 'Hexagon LoopAlign pass'
H079823890488: 'Hexagon LoopAlign 패스'
# 'Hexagon NewValueJump'
HD050A64FD350: 'Hexagon 새 값 점프'
# 'Hexagon Packetizer'
HD80045280EC2: 'Hexagon 패킷화'
# 'Hexagon Peephole'
H96F1818D0A76: 'Hexagon 피 hå올'
# 'Hexagon RDF optimizations'
H0E48883DC0AC: 'Hexagon RDF 최적화'
# 'Hexagon Split Const32s and Const64s'
HE37A260C9D82: 'Hexagon Const32 및 Const64 분할'
# 'Hexagon Split Double Registers'
H6CA85CE5559C: 'Hexagon 더블 레지스터 분할'
# 'Hexagon Store Widening'
H23CE261CD27B: 'Hexagon 저장소 확장'
# 'Hexagon TFR Cleanup'
H6ECA189DB2DB: 'Hexagon TFR 정리'
# 'Hexagon Vector Combine'
H9F8DB4B385EA: 'Hexagon 벡터 결합'
# 'Hexagon VectorPrint pass'
H540A5ECB5448: 'Hexagon 벡터 프린트 패스'
# 'Hexagon bit simplification'
HF73F7F5D57C5: 'Hexagon 비트 단순화'
# 'Hexagon call frame information'
H93CA35321D07: 'Hexagon 호출 프레임 정보'
# 'Hexagon constant-extender optimization'
H1C0F5065601C: 'Hexagon 상수 확장기 최적화'
# 'Hexagon early if conversion'
H5C9514E28A85: 'Hexagon 조기 if 변환'
# 'Hexagon generate "extract" instructions'
H7636CC8F55F3: 'Hexagon "extract" 명령어 생성'
# 'Hexagon generate "insert" instructions'
H3778EAC02853: 'Hexagon "insert" 명령어 생성'
# 'Hexagon generate mux instructions'
H5C45CA2F85F2: 'Hexagon mux 명령어 생성'
# 'Hexagon generate predicate operations'
H40F613387EB4: 'Hexagon 예측 연산 생성'
# 'Hexagon mask'
HEEBCEB3469AC: 'Hexagon 마스크'
# 'Hexagon move phi copy'
HDCDB2AA0AED1: 'Hexagon 이동 phi 복사'
# 'Hexagon optimize vextract'
H278043636EF5: 'Hexagon 최적화 vextract'
# 'Hexagon-specific predictive commoning for HVX vectors'
H536F10F1AEBD: 'Hexagon 고유의 예측 공통화 HVX 벡터'
# 'Hide blocks with relative frequency below the given value'
H3675151E5C00: '주어진 값보다 상대적 빈도가 낮은 블록을 숨김'
# 'Hide nodes with more predecessor/successor than cutoff'
HBFFDABE2C9B6: 'cutoff보다 더 많은 predecessor/successor를 가진 노드 숨기기'
# 'High level execution tracing'
HEC0DB93568EB: '고수준 실행 추적'
# 'High level qualifier for z/OS C++RT side deck datasets'
HAA6C6806CE9D: 'z/OS C++RT 측면 덱 데이터셋의 고수준 자격 증명'
# 'High level qualifier for z/OS CSSLIB dataset'
H3CB003A4AC08: 'z/OS CSSLIB 데이터셋의 고수준 지정자'
# 'High level qualifier for z/OS Language Environment datasets'
HF68A673FB7E5: 'z/OS 언어 환경 데이터셋에 대한 고수준 자격 증명'
# 'High register pressure threhold.'
H72FE4FE03B96: '높은 레지스터 압력 threhold.'
# 'Highlight the code regions that will be optimized in a (CFG BBs and LLVM-IR instructions)'
H011F5431A825: '최적화될 코드 영역을 강조합니다 (CFG BBs 및 LLVM-IR 명령문)'
# 'Highlight the code regions that will be optimized in a (CFG only BBs)'
H8868F2ACA588: 'CFG only BBs에서 최적화될 코드 영역을 강조합니다'
# 'Hoist common instructions up to the parent block'
H626E78174BD3: '공통 명령문을 상위 부모 블록까지 상승시킵니다'
# 'Hoist conditional stores even if an unconditional store does not precede - hoist multiple conditional stores into a single predicated store'
HAF676B43A7DA: '비조건부 저장이 이전에 없더라도 조건부 저장을 상향 이동하고, 다중 조건부 저장을 단일 조건부 저장으로 통합합니다'
# 'Hoist conditional stores if an unconditional store precedes'
H051D0419768A: '조건 없는 저장이 먼저 오는 경우 조건부 저장을 추출합니다'
# 'Hoist inner loop runtime memory checks to outer loop if possible'
H1896B47EDC00: '가능한 경우 내부 루프의 런타임 메모리 검사를 외부 루프로 상향시키기'
# 'Hoist instructions from the beginning of the BB up to the maximum specified depth (default = 100, unlimited = -1)'
H19FF88ADEF86: 'BB의 시작 부분에서부터 지정된 최대 깊이까지 명령문을 상승시킵니다 (기본값 = 100, 무제한 = -1)'
# 'Hoist invariant loads'
H04F2E5FA708B: '불변 로드 상승'
# 'Hoist invariant loads.'
HFD3073FAF6A0: '불변 로드 상승'
# 'Hoist invariant stores'
H37B16BDD134A: '불변 저장 위치 상승'
# 'Hoist loads if the target supports conditional faulting'
HFE6E57FFE11D: '타겟이 조건부 예외를 지원하면 로드를 상향식으로 이동'
# 'Hoist loads/stores if the target supports conditional faulting (default = false)'
H360599A9B4F2: '타겟이 조건부 예외 발생을 지원하면 로드/스토어를 상승시킵니다 (기본값 = false)'
# 'Hoist stores if the target supports conditional faulting'
HD60C7781C619: '타겟이 조건부 오류를 지원하면 저장을 상향식으로 이동합니다'
# 'Hoisting alloca instructions in non-entry blocks to the entry block'
H1611B6B7938C: '엔트리 블록이 아닌 블록의 alloca 명령어를 엔트리 블록으로 올림'
# 'Hot callsite threshold for proirity-based sample profile loader inlining.'
HF203067F3822: '프라이어리티 기반 샘플 프로파일 로더 인라인에 대한 핫 콜사이트 임계값.'
# 'Hot percentile cutoff.'
HCEE9FC61C4DD: '핫 백분위 절단값.'
# 'How cgscc inline replay file is formatted'
HD50D41502699: 'cgscc 인라인 재생 파일의 형식은 어떻게 되는가?'
# "How cgscc inline replay treats sites that don't come from the replay. Original: defers to original advisor, AlwaysInline: inline all sites not in replay, NeverInline: inline no sites not in replay"
H6F8523C009E8: 'replay에 없는 위치를 cgscc inline replay가 어떻게 처리하는가? 기본(Original): 원래 advisor의 결정을 따른다. AlwaysInline: replay에 없는 모든 위치를 inline 처리한다. NeverInline: replay에 없는 위치를 전혀 inline 처리하지 않는다.'
# "How many functions in a module could be used for MergeFunctions to pass a basic correctness check. '0' disables this check. Works only with '-debug' key."
H65C2FF1A291C: "모듈 내에서 MergeFunctions가 기본적인 정확성 검사를 통과할 수 있는 함수의 수는 몇 개인가요. '0'은 이 검사를 비활성화합니다. '-debug' 키와 함께 사용할 때만 작동합니다."
# 'How many idle instructions we would like before certain undef register reads'
HAF5EEC679340: '특정 정의되지 않은 레지스터 읽기 전에 원하는 idle 명령문의 개수'
# 'How many kernel arguments to preload onto SGPRs'
H2C2BF298A146: 'SGPR에 미리 로드할 커널 인수의 개수'
# 'How many lifetime ends to handle for a single alloca.'
H1A9776E5D001: 'alloca당 처리할 라이프타임 종료 수.'
# 'How much code-generation to perform'
HB6C2FA93092D: '코드 생성을 얼마나 수행할 것인지'
# 'How sample profile inline replay file is formatted'
H7CB1B737EC5A: '샘플 프로파일 인라인 재생 파일 형식은 어떻게 되어 있나요?'
# "How sample profile inline replay treats sites that don't come from the replay. Original: defers to original advisor, AlwaysInline: inline all sites not in replay, NeverInline: inline no sites not in replay"
H023EFDA855FF: '샘플 프로파일 인라인 리플레이가 리플레이에서 오지 않은 사이트를 어떻게 처리하는지. Original: 원래 자문가의 결정을 따릅니다, AlwaysInline: 리플레이에 없는 모든 사이트를 인라인 처리합니다, NeverInline: 리플레이에 없는 사이트를 전혀 인라인 처리하지 않습니다'
# 'How to aggregate multi-values result'
HE0FCAEDB7A77: '다중 값 결과를 집계하는 방법'
# 'How wide an instruction window to bypass looking for another guard'
H190528E1E0D0: '명령어 윈도우의 너비를 다른 가드를 찾는 과정을 우회하기 위해 얼마나 넓게 할 것인가요?'
# 'HowToUseLLJIT'
H56EB31810445: 'LLJIT 사용 방법'
# 'Human readable output. Only valid without -all-stacks.'
H1D2D4ECF9DBD: '인간이 읽기 쉬운 출력. -all-stacks 옵션이 없을 때만 유효합니다.'
# 'Human-readable format'
H5B717FB38D2F: '인간이 읽기 쉬운 형식'
# 'IBM MASS vector library'
HC5A8A1BFD3A5: 'IBM MASS 벡터 라이브러리'
# 'IBOutletCollection properties should be copy/strong and not assign'
H91B04B0AEDF0: 'IBOutletCollection 프로퍼티는 copy/strong 속성을 가져야 하며, assign으로 지정하지 마십시오'
# 'IEEE 754 denormal numbers'
HB645808304FA: 'IEEE 754 비정상 소수'
# 'IR2Vec Options'
H353091CB276E: 'IR2Vec 옵션들'
# 'IRDL file to register before processing the input'
H9ADEB68395C9: '입력 처리 전에 등록해야 할 IRDL 파일'
# 'IRTranslator LLVM IR -> MI'
HA8BDC735DCBC: 'IRTranslator LLVM IR에서 MI로'
# 'ISO C does not allow indirection on operand of type %0'
HC4C25916B558: 'ISO C에서는 %0 타입의 피연산자에 대해 간접화를 허용하지 않습니다'
# "ISO C does not support '~' for complex conjugation of %0"
H592FB210723A: "ISO C는 '~' 기호를 복소켤레 연산에 대한 %0에 대해 지원하지 않습니다"
# "ISO C forbids forward references to 'enum' types"
H3A2E43246AF1: "ISO C는 'enum' 유형에 대한 전방 참조를 허용하지 않습니다"
# "ISO C forbids taking the address of an expression of type 'void'"
H5DC6DC421D10: "ISO C는 'void' 형식의 표현식의 주소를 취하는 것을 금지합니다"
# "ISO C requires a named parameter before '...'"
HAAD7320B82D0: "ISO C는 '...' 이전에 이름이 지정된 매개변수가 필요합니다"
# 'ISO C requires a translation unit to contain at least one declaration'
HD453AE5DFC44: 'ISO C는 번역 단위가 적어도 하나의 선언을 포함해야 합니다'
# 'ISO C++ considers this destructor name lookup to be ambiguous'
H51664244F36F: 'ISO C++은 이 소멸자 이름 검색을 모호한 것으로 간주합니다'
# 'ISO C++ does not allow %select{an attribute list|%0}1 to appear here'
H6EEF885F4392: 'ISO C++에서는 %select{속성 목록|%0}1을 여기에 사용할 수 없습니다'
# 'ISO C++ does not allow %select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2 because it casts away qualifiers, even though the source and destination types are unrelated'
HA24736A782D5: 'ISO C++은 %select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style 캐스트|함수 스타일 캐스트|}0을(를) %1에서 %2로 사용하지 않습니다.这是因为 형 변환 연산자가 자격 증명을 제거하는 데다 소스와 대상 유형이 관련이 없기 때문입니다'
# "ISO C++ does not permit the 'bool' keyword after 'concept'"
HED15AAEA01CD: "ISO C++에서는 'concept' 키워드 이후에 'bool' 키워드를 허용하지 않습니다"
# "ISO C++ forbids forward references to 'enum' types"
H565E6A76B7E7: "ISO C++은 'enum' 형식에 대한 전방 참조를 금지합니다"
# "ISO C++ only allows ':' in member enumeration declaration to introduce a fixed underlying type, not an anonymous bit-field"
HD765E30339DE: "ISO C++은 멤버 열거형 선언에서 ':'를 기본 형식을 명시하기 위해만 허용하며, 익명 비트 필드를 위한 것이 아닙니다"
# 'ISO C++ requires a definition in this translation unit for %select{function|variable}0 %q1 because its type does not have linkage'
HCF564C1243BB: 'ISO C++은 이 번역 단위에 %select{함수|변수}0 %q1의 정의가 필요합니다.因为它类型不具备链接性'
# 'ISO C++ requires field designators to be specified in declaration order; field %1 will be initialized after field %0'
HF7272CADD93F: 'ISO C++ 표준은 필드 지정자를 선언 순서대로 지정해야 합니다; 필드 %1은 %0 필드보다 나중에 초기화될 것입니다'
# "ISO C++ requires the name after '::~' to be found in the same scope as the name before '::~'"
H1B12535D9EA0: "ISO C++는 '::~' 이후의 이름이 '::~' 이전의 이름과 동일한 범위에 있어야 한다고 요구합니다."
# "ISO C++ specifies that qualified reference to %0 is a constructor name rather than a %select{template name|type}1 in this context, despite preceding %select{'typename'|'template'}2 keyword"
H0AEAB31369D3: "ISO C++ 표준은 %0의 지정된 참조가 이 컨텍스트에서 %select{템플릿 이름|형}1이 아닌 생성자 이름임을 규정하며, %select{'typename'|'template'}2 키워드가 앞에 있음에도 불구하고."
# 'ISO C++ standards before C++17 do not allow new expression for type %0 to use list-initialization'
H36A45BAF91C7: 'C++17 이전의 ISO C++ 표준은 %0 유형의 new 표현식에 리스트 초기화를 사용하도록 허용하지 않습니다'
# 'ISO C++11 does not allow access declarations; use using declarations instead'
H949947FDD999: 'ISO C++11에서는 접근 선언문을 허용하지 않습니다; 대신 using 선언문을 사용하세요'
# 'ISO C++11 does not allow conversion from string literal to %0'
HDCEA926F7FF8: 'ISO C++11은 문자열 리터럴을 %0로의 변환을 허용하지 않습니다'
# 'ISO C++11 requires a parenthesized pack declaration to have a name'
H70DD46DED2FB: 'ISO C++11은 괄호로 감싸진 패키지 선언이 이름을 가져야 합니다.'
# "ISO C++17 does not allow 'register' storage class specifier"
HFBD7E25436E2: "ISO C++17은 'register' 저장 클래스 지정자를 허용하지 않습니다"
# 'ISO C++17 does not allow a decomposition group to be empty'
H38C9A47FB6B4: 'ISO C++17은 분해 그룹이 비어 있는 것을 허용하지 않습니다'
# 'ISO C++17 does not allow dynamic exception specifications'
HDA1158B635F1: 'ISO C++17은 동적 예외 지정을 허용하지 않습니다'
# 'ISO C++17 does not allow incrementing expression of type bool'
H8CE1E8E6EA54: 'ISO C++17은 bool 형식의 증가 표현식을 허용하지 않습니다'
# "ISO C++20 considers use of overloaded operator '%0' (with operand types %1 and %2) to be ambiguous despite there being a unique best viable function%select{ with non-reversed arguments|}3"
HE2B331A9C128: "ISO C++20은 과적재된 연산자 '%0' (피연산자 타입 %1과 %2)의 사용을 애매모호한 것으로 간주하지만, %select{ 반전되지 않은 인수를 가진 |}3 유일한 최상의 유효 함수가 존재합니다"
# "ISO C++20 requires return type of selected 'operator==' function for rewritten '%1' comparison to be 'bool', not %0"
H96DD21560E53: "ISO C++20 표준은 재작성된 '%1' 비교를 위한 선택된 'operator==' 함수의 반환 타입이 'bool'이어야 하며, %0가 아닌 것이어야 합니다"
# 'ISO C90 does not allow subscripting non-lvalue array'
HB75A7925DCA5: 'ISO C90은 비 lvalue 배열의 인덱싱을 허용하지 않습니다'
# 'ISO C99 requires whitespace after the macro name'
HDC593F4C1475: 'ISO C99는 매크로 이름 뒤에 공백이 필요합니다'
# 'IT block support'
H110A8754A4BC: 'IT 블록 지원'
# 'Id of alloc to export if -memprof-dot-scope=alloc or to highlight if -memprof-dot-scope=all'
HB6A8CDFE5726: '할당의 아이디를 -memprof-dot-scope=alloc일 경우 내보내거나, -memprof-dot-scope=all일 경우 강조합니다'
# 'Id of context to export if -memprof-dot-scope=context or to highlight otherwise'
H0412058D0B19: '컨텍스트의 ID: -memprof-dot-scope=context 옵션이면 내보내고, 그렇지 않으면 강조하는 데 사용'
# "Identifies whether Control Flow Integrity protects all indirect control flow instructions in the provided object file, DSO or binary.\nNote: Anything statically linked into the provided file *must* be compiled with '-g'. This can be relaxed through the '--ignore-dwarf' flag."
H7027E6C59DD5: "제공된 오브젝트 파일, DSO 또는 바이너리에서 제어 흐름 무결성이 모든 간접 제어 흐름 명령문을 보호하는지 확인합니다.\n참고: 제공된 파일에 정적 링크된 모든 내용은 '-g' 플래그로 컴파일되어야 합니다. 이는 '--ignore-dwarf' 플래그를 통해 완화할 수 있습니다."
# 'If Converter'
H8621034DF5DA: 'If 변환기'
# "If ThinLTO and WPD is enabled and this option is true, vtable profiles will be used by ICP pass for more efficient indirect call sequence. If false, type profiles won't be used."
H97A5D327A1D2: 'ThinLTO와 WPD가 활성화되고 이 옵션이 true일 경우, vtable 프로파일이 ICP 패스에 의해 더 효율적인 간접 호출 시퀀스에 사용됩니다. false일 경우, 타입 프로파일은 사용되지 않습니다.'
# 'If a personality routine is marked uninstrumented from the ABI list, do not create a wrapper for it.'
H830E42B2D102: 'ABI 목록에서 미측정(uninstrumented)으로 표시된 personality routine에 대해 포장기를 생성하지 마십시오.'
# 'If an allocatable left-hand side of an intrinsic assignment is unallocated or its shape/type does not match the right-hand side, then it is automatically (re)allocated'
HFF2E7612E3B3: '내장 할당의 할당 가능한 왼쪽 피연산자가 할당되지 않았거나 그 형상/유형이 오른쪽 피연산자와 일치하지 않으면, 자동으로 (재)할당됩니다'
# 'If enabled, drop make.implicit metadata in unswitched implicit null checks to save time analyzing if we can keep it.'
H84A812339ADF: '활성화되면 unswitched 암시적 null 확인에서 make.implicit 메타데이터를 제거하여 이를 유지할 수 있는지 분석하는 시간을 절약합니다.'
# 'If enabled, simple loop unswitching will also consider llvm.experimental.guard intrinsics as unswitch candidates.'
H0DECF1F15908: '활성화되면 단순 루프 언스위칭은 llvm.experimental.guard 내재 함수를 또한 언스위칭 후보로 고려합니다.'
# 'If enabled, the freeze instruction will be added to condition of loop unswitch to prevent miscompilation.'
H29F9314FFE86: '활성화되면, freeze 명령어가 loop unswitch의 조건에 추가되어 잘못된 컴파일을 방지합니다.'
# 'If present, forces/disables the use of long calls'
H244BD3DDA186: '지정되면 long calls의 사용을 강제하거나 비활성화합니다'
# 'If present, stops packetizing after N instructions'
HC908BB95C55F: '지정되면 N 개의 명령문 후 패킷화를 중지합니다'
# 'If profile count information is used in tail duplication cost model, the gained fall through number from tail duplication should be at least this percent of hot count.'
H4BE057670DD8: '꼬리 복제 비용 모델에 프로파일 카운트 정보가 사용되는 경우, 꼬리 복제를 통해 얻은 통과 수는 이 핫 카운트의 최소한 이 백분율이어야 합니다.'
# 'If set to true, IRCE may eliminate wide range checks in loops with narrow latch condition.'
HC7CC2CE2097F: '참으로 설정되면 IRCE는 narrow latch 조건이 있는 루프의 넓은 범위 검사를 제거할 수 있습니다.'
# 'If set, and on a color-capable terminal controls whether or not to print diagnostics in color'
H22D7A9441E62: '설정되어 있으면, 색상 지원 터미널에서 진단 메시지를 색상으로 표시할지 여부를 제어합니다'
# 'If set, assume that loads and stores do not alias'
H938298BEB1B1: '설정되면 로드와 스토어가 서로 별개라고 가정합니다'
# 'If set, benchmark all sizes from sweep-min-size to sweep-max-size'
H918C41E05E1C: '설정 시, sweep-min-size부터 sweep-max-size까지 모든 크기를 벤치마킹합니다'
# 'If set, changes formatting warnings to errors'
HF6B939F6D70E: '설정이 활성화되면 포맷팅 경고를 오류로 전환합니다'
# 'If set, do not actually make the formatting changes'
H11412975A779: '설정되면, 실제로 포맷팅 변경을 수행하지 않습니다'
# "If set, don't error out on the specified warning type."
H94EED0D743F6: '설정되면 지정된 경고 유형에 대해 에러를 발생하지 않습니다.'
# 'If set, fail with exit code 1 on incomplete format.'
H3940587B501D: '설정되면 불완전한 형식에서 종료 코드 1로 실패합니다.'
# 'If set, overrides the include sorting behavior\ndetermined by the SortIncludes style flag'
HA0F9A020C51D: '설정되면, SortIncludes 스타일 플래그에 의해 결정된 include 정렬 동작을 재정의합니다'
# 'If set, overrides the qualifier alignment style\ndetermined by the QualifierAlignment style flag'
H7D8374F39C0A: '설정하면 qualifier alignment 스타일을 재정의합니다\nQualifierAlignment style flag에 의해 결정된'
# 'If set, shows the list of processed files'
HB1247E3D1FC1: '설정 시 처리된 파일 목록을 표시합니다'
# 'If set, unknown format options are only warned about.\nThis can be used to enable formatting, even if the\nconfiguration contains unknown (newer) options.\nUse with caution, as this might lead to dramatically\ndiffering format depending on an option being\nsupported or not.'
HB78C3D57EF8C: '이 옵션이 설정되면 알 수 없는 형식 옵션에 대해서는 경고만 발생합니다.\n이 옵션을 사용하면 구성에 알 수 없는(신규) 옵션이 있어도 포맷팅을 활성화할 수 있습니다.\n이 옵션을 사용할 때는 주의가 필요합니다. 특정 옵션이 지원되냐 안되냐에 따라 포맷 결과가 극명하게 달라질 수 있기 때문입니다.'
# 'If specified, IR printed using the -print-[before|after]{-all} options will be dumped into files in this directory rather than written to stderr'
HC6C4D32713B0: '지정되면, -print-[before|after]{-all} 옵션을 사용하여 출력되는 IR은 stderr 대신 이 디렉토리의 파일에 덤프됩니다'
# 'If stats should be appended to stats-file instead of overwriting it'
H7B41C07F5D40: '통계를 stats-file에 덮어쓰는 대신 덧붙여 기록할 경우'
# 'If the function being instrumented contains more than this number of memory accesses, use callbacks instead of inline checks (-1 means never use callbacks).'
HD30970E83223: '측정 중인 함수가 이 수보다 많은 메모리 접근을 포함하는 경우 인라인 확인 대신 콜백을 사용합니다. (-1은 콜백을 절대 사용하지 않음을 의미합니다.)'
# 'If the function being instrumented requires more than this number of checks and origin stores, use callbacks instead of inline checks (-1 means never use callbacks).'
H5B3AA5D69CF8: '추적 중인 함수가 이 숫자보다 많은 수의 검사와 원본 저장이 필요할 경우 인라인 검사 대신 콜백을 사용하십시오. (-1은 콜백을 절대 사용하지 않음을 의미합니다.)'
# 'If the function being instrumented requires more than this number of origin stores, use callbacks instead of inline checks (-1 means never use callbacks).'
H3A18D04548FF: '측정 대상인 함수가 이 숫자보다 많은 원본 저장소를 필요로 할 경우, 인라인 검사 대신 콜백을 사용하십시오 (-1은 콜백을 절대 사용하지 않음을 의미합니다).'
# 'If the profile density is below the given threshold, it will be suggested to increase the sampling rate.'
HDF4D3E04985A: '프로파일 밀도가 주어진 임계값보다 낮으면 샘플링률을 높이는 것이 제안될 것입니다.'
# 'If the runtime tripcount for the loop is lower than the threshold, the loop is considered as flat and will be less aggressively unrolled.'
HAC4BCB57FDE7: '루프의 런타임 반복 횟수가 문턱값보다 낮으면, 해당 루프는 평탄한 것으로 간주되어 강하게 펼쳐지지 않을 것입니다.'
# 'If the sample profile is accurate, we will mark all un-sampled branches and calls as having 0 samples. Otherwise, treat them conservatively as unknown. '
H815D8C5F471D: '정확한 샘플 프로파일이 있다면, 모든 샘플링되지 않은 분기 및 호출을 0 샘플을 가진 것으로 표시합니다. 그렇지 않으면, 보수적으로 미지의 것으로 처리합니다.'
# 'If the sample profile is accurate, we will mark all un-sampled callsite and function as having 0 samples. Otherwise, treat un-sampled callsites and functions conservatively as unknown. '
H196C3B85DE70: '샘플 프로파일이 정확하다면, 모든 샘플링되지 않은 콜사이트와 함수를 0 샘플을 가진 것으로 표시합니다. 그렇지 않으면, 샘플링되지 않은 콜사이트와 함수를 보수적으로 미지의 것으로 처리합니다.'
# "If the size of a function is smaller than the threshold, assume it can be inlined by PGO early inliner and it won't be adjusted based on sample profile."
HE6D98DD47634: '함수의 크기가 임계값보다 작으면 PGO 조기 인라인에 의해 인라인될 수 있다고 가정하며 샘플 프로파일에 따라 조정되지 않습니다.'
# 'If the total count of context profile is smaller than the threshold, it will be merged into context-less base profile.'
H78D9F132106C: '컨텍스트 프로파일의 총 개수가 임계값보다 작을 경우, 이 프로파일은 컨텍스트 없는 기본 프로파일에 병합됩니다.'
# 'If the total count of the profile is smaller than threshold, it will be trimmed.'
H29DFE55539B7: '프로파일의 총 카운트가 임계값보다 작으면, 이는 잘려집니다.'
# 'If the valnos size of an interval is larger than the threshold, it is regarded as a large interval. '
H65099468E23D: '구간의 valnos 크기가 임계값보다 크면, 그 구간은 대규모 구간으로 간주됩니다.'
# 'If true, annotate inline advisor remarks with LTO and pass information.'
HBCBB7977FE78: '참일 경우, LTO 및 패스 정보와 함께 인라인 어드바이저 메모를 표시합니다.'
# 'If true, artificially skip inline transformation in sample-loader pass, and merge (or scale) profiles (as configured by --sample-profile-merge-inlinee).'
HB64A7E1DFEB3: '참일 경우, sample-loader 패스에서 인라인 변환을 인위적으로 건너뛰고, 프로파일을 병합(또는 확대/축소)합니다(이 동작은 --sample-profile-merge-inlinee 옵션에 따라 구성됩니다).'
# 'If true, basic blocks are re-numbered before MBP layout is printed into a dot graph. Only used when a function is being printed.'
HBEE86CE05AA8: '참일 경우, MBP 레이아웃이 dot 그래프에 출력되기 전에 기본 블록들이 다시 번호가 매겨집니다. 함수가 출력될 때만 사용됩니다.'
# 'If true, import function declaration as fallback if the function definition is not imported.'
HD7D070FB023F: '참일 경우, 함수 정의가 가져오지 않았을 때 대체로 함수 선언을 가져옵니다.'
# 'If true, keep the vtable symbols in indexed profiles'
H52D48DA006BE: '참이면 인덱스된 프로파일에 vtable 심볼을 유지합니다'
# 'If true, scale the working set size of the partial sample profile by the partial profile ratio to reflect the size of the program being compiled.'
HBDDA0894BE03: '참인 경우, 부분 샘플 프로파일의 작업 세트 크기를 부분 프로파일 비율에 따라 조정하여 컴파일 중인 프로그램의 크기를 반영합니다.'
# 'If true, the virtual table address will be instrumented to know the types of a C++ pointer. The information is used in indirect call promotion to do selective vtable-based comparison.'
H3E8FA9464A37: '참일 경우, 가상 테이블 주소가 C++ 포인터의 타입을 알기 위해 분석됩니다. 이 정보는 간접 호출 최적화에서 선택적 가상 테이블 기반 비교를 수행하는 데 사용됩니다.'
# 'If using a contextual profile in this module, and an indirect call target is marked as alwaysinline, perform indirect call promotion for that target. If multiple targets for an indirect call site fit this description, they are all promoted.'
H51C56F762F1D: '이 모듈에서 컨텍스트 프로필을 사용하는 경우, 간접 호출 대상이 alwaysinline로 표시된 경우 해당 대상에 대해 간접 호출 프로모션을 수행합니다. 간접 호출 위치에 대해 이 조건에 해당하는 여러 개의 대상이 있는 경우 모두 프로모션됩니다.'
# 'Ignore #line directives when displaying diagnostic locations'
HD98F069577E5: '진단 위치를 표시할 때 #line 지시문을 무시함'
# 'Ignore RecMII'
H2050B14C1C4D: 'RecMII 무시'
# 'Ignore TTI attributes compatibility check between callee/caller during inline cost calculation'
H6DBD3A9D0CF3: '인라인 비용 계산 중 호출자/피호출자의 TTI 속성 호환성 검사 무시'
# "Ignore all DWARF data. This relaxes the requirements for all statically linked libraries to have been compiled with '-g', but will result in false positives for 'CFI unprotected' instructions."
H39BB8E06FB84: "모든 DWARF 데이터 무시. 이 옵션은 정적 링크된 모든 라이브러리가 '-g' 옵션으로 컴파일되었음을 요구하는 조건을 완화하지만, 'CFI unprotected' 명령문에 대한 오류를 잘못 감지할 수 있습니다."
# 'Ignore attribute objc_direct so that direct methods can be tested'
HCF66187C2621: 'objc_direct 속성을 무시하여 직접 메서드를 테스트할 수 있습니다'
# 'Ignore balance information, always return (1: Even, 2: Odd).'
HFC882D591A40: '균형 정보를 무시하고, 항상 (1: 짝수, 2: 홀수)를 반환합니다.'
# 'Ignore bit-field types when aligning structures'
H37A6736DD441: '구조체 정렬 시 비트 필드 유형을 무시합니다'
# 'Ignore call stack samples for hybrid samples and produce context-insensitive profile.'
H7E47B7D4BE2D: '하이브리드 샘플에 대한 콜 스택 샘플을 무시하고 컨텍스트-감도 없는 프로파일을 생성합니다.'
# 'Ignore case distinctions when searching.'
H17840E450A3A: '검색 시 대문자와 소문자의 구별을 무시합니다.'
# 'Ignore element line number.'
H68F79AF97A49: '요소의 줄 번호를 무시합니다.'
# 'Ignore environment variables to detect CUDA installation'
HAC9812BECEE3: '환경 변수를 무시하고 CUDA 설치 감지'
# 'Ignore existing branch weights on IR and always overwrite.'
HB7CA4D0B2FB1: 'IR에서 기존의 분기 가중치를 무시하고 항상 덮어씁니다.'
# 'Ignore functions that match a regex. Multiple regexes can be comma separated. Scop detection will ignore all functions that match ANY of the regexes provided.'
HDF7F5F41C8A9: '정규식과 일치하는 함수를 무시합니다. 여러 개의 정규식은 콤마로 구분해서 지정할 수 있습니다. Scop 탐지에서는 제공된 정규식 중 하나라도 일치하는 모든 함수를 무시합니다.'
# 'Ignore insert conflict and keep running to fix.'
HABB3F2EDAFC7: '삽입 충돌을 무시하고 계속 실행하여 문제를 해결합니다.'
# 'Ignore possible aliasing of the array bases'
H64EE4A3BEF1A: '배열 기반의 가능한 별칭 무시'
# 'Ignore redundant instrumentation'
H4E0E4A3BF250: '중복된 instrumentation 무시'
# 'Ignore the definition of the given macro when building and loading modules'
H7770258C460D: '지정된 매크로의 정의를 모듈 빌드 및 로딩 시 무시함'
# 'Ignore the whitespace from the input file when emitting preprocessor output. It will only contain whitespace when necessary, e.g. to keep two minus signs from merging into to an increment operator. Useful with the -P option to normalize whitespace such that two files with only formatting changes are equal.\n\nOnly valid with -E on C-like inputs and incompatible with -traditional-cpp.'
HD37ED8478D7E: '프리프로세서 출력을 생성할 때 입력 파일의 공백을 무시합니다. 공백은 필요한 경우에만 포함됩니다. 예를 들어 두 개의 마이너스 기호가 증가 연산자로 합쳐지지 않도록 유지하기 위해 사용됩니다. -P 옵션과 함께 사용하면 형식 변경만 있는 두 파일이 동일해지도록 공백을 정규화하는 데 유용합니다.\n\nC 형식 입력에서 -E 옵션과 함께만 사용 가능하며 -traditional-cpp와 호환되지 않습니다.'
# 'Ignore unexpected diagnostic messages'
H81B938CFE11E: '예상치 못한 진단 메시지를 무시함'
# 'Ignore warnings from system headers (default)'
H7D4D3672A31D: '시스템 헤더에서 발생한 경고 무시 (기본 설정)'
# "Implement the 'patchable-function' attribute"
H53EFAEE072B9: '‘patchable-function’ 속성을 구현하십시오'
# 'Implicit null checks'
H40CAC5790CAC: '암시적 null 검사'
# 'Implicitly search the file system for module map files.'
HA09A2D8486F2: '암시적으로 파일 시스템을 검색하여 모듈 맵 파일을 찾습니다.'
# "Implies all other options in 'Symbol Types' category"
HA831AAE57383: 'Symbol Types 카테고리에 속한 모든 다른 옵션을 포함합니다'
# 'Implies most other options.'
H6CE9D8EF9C43: '다른 대부분의 옵션을 포함합니다.'
# 'Implies the SAVE attribute for non-automatic local objects in subprograms unless RECURSIVE'
H4C9AEE72AB8A: '서브프로그램 내에서 RECURSIVE가 아닌 경우 비자동 로컬 객체에 대해 SAVE 속성을 암시합니다'
# 'Import all external functions in index.'
H6AA576FCF40F: '인덱스에 있는 모든 외부 함수를 가져옵니다.'
# 'Import constant global variables with references'
H2A392B0AB0D3: '상수 전역 변수와 참조를 가져옵니다'
# 'Import declaration.'
H4A43ED2EE433: 'Import 선언입니다.'
# 'Import full type definitions for ThinLTO.'
HC44C755DA4C3: 'ThinLTO의 전체 타입 정의를 포함합니다.'
# 'Import functions with noinline attribute'
HD198F1298814: 'noinline 어트리뷰트가 있는 함수 가져오기'
# 'Import module.'
H6E01604A8D9D: '모듈을 가져옵니다.'
# 'Import summary to use for testing the ThinLTO backend via opt'
HED7EEF5C6F9E: 'opt를 통해 ThinLTO 백엔드를 테스트하기 위해 사용하는 요약을 가져오기'
# 'Import the polyhedral description of the detected Scops'
H5D0606A7CB94: '검출된 Scops의 다면체 설명을 가져오기'
# 'Import typeid resolutions from summary and globals'
HC32DC5EADEE2: '요약 및 전역에서 typeid 해결 내용 가져오기'
# 'Import.'
H0E5CF36B48DC: '수입.'
# 'Improve global merge pass to ignore globals only used alone'
H26A9763EC62A: '글로벌 병합 패스를 개선하여 단독으로만 사용되는 글로벌을 무시하도록 하기'
# 'Improve global merge pass to look at uses'
HA9CE9E94603C: '글로벌 병합 패스를 사용처를 고려하도록 개선합니다'
# 'Improve the code quality by splitting alternate instructions'
H103FED3C5FE8: '대체 명령문을 분할하여 코드 품질을 개선하십시오'
# 'In all cases'
HCC1A697CD02F: '모든 경우에'
# 'In conjunection with -type-index and -id-index, dumps the entire dependency graph for the specified index instead of just the single record with the specified index'
H835459E7E97D: '-type-index와 -id-index와 함께 사용할 때, 지정된 인덱스의 전체 종속성 그래프를 지정된 인덱스의 단일 레코드만 출력하는 대신 덤프합니다'
# "In profiling mode like sampleFDO, if a function doesn't have profile, we cannot tell the function is cold for sure because it may be a function newly added without ever being sampled. With the flag enabled, compiler can put such profile unknown functions into a special section, so runtime system can choose to handle it in a different way than .text section, to save RAM for example. "
H4571B587B651: '프로파일링 모드인 sampleFDO에서 프로파일이 없는 함수는, 해당 함수가 채집된 적이 없는 새롭게 추가된 함수일 수 있기 때문에 확실히 콜드 함수라고 단정할 수 없습니다. 이 플래그를 활성화하면 컴파일러는 이러한 프로파일이 없는 함수를 특수 섹션에 배치할 수 있도록 하여, 런타임 시스템은 .text 섹션과 다른 방식으로 처리할 수 있게 됩니다. 예를 들어 RAM 절약을 위해 활용할 수 있습니다.'
# 'In the OpenMP data clauses treat `a(N)` as `a(N:N)`.'
H1CA9E31B3F5D: 'OpenMP 데이터 절에서 `a(N)`을 `a(N:N)`로 처리합니다.'
# 'In the dump requested by -dump-input, print <N> input lines\nbefore and <N> input lines after any lines specified by\n-dump-input-filter.  When there are multiple occurrences of\nthis option, the largest specified <N> has precedence.  The\ndefault is 5.\n'
HEB48ED43B50E: '-dump-input을 통해 요청된 덤프에서 -dump-input-filter로 지정된 줄 주변에 각각 <N> 입력 줄 전과 <N> 입력 줄 후를 출력합니다. 이 옵션이 여러 번 지정될 경우 가장 큰 <N>이 우선 적용됩니다. 기본값은 5입니다.\n'
# "In the dump requested by -dump-input, print only input lines of\nkind <value> plus any context specified by -dump-input-context.\nWhen there are multiple occurrences of this option, the <value>\nthat appears earliest in the list below has precedence.  The\ndefault is 'error' when -dump-input=fail, and it's 'all' when\n-dump-input=always.\n"
H9104E1DEC417: "dump 입력에서 -dump-input 옵션으로 요청된 덤프에선 종류 <value>의 입력 라인과\n-dump-input-context로 지정된 컨텍스트를 포함하여 출력합니다.\n이 옵션이 여러 번 지정된 경우 아래 목록에서 가장 먼저 등장한 <value>가 우선권을 갖습니다.\n기본값은 -dump-input=fail일 때 'error', -dump-input=always일 때는 'all'입니다."
# 'In the report, sort the timers in each group in wall clock time order'
H2F13A69F022D: '리포트에서 각 그룹의 타이머를 월클록 시간 순서대로 정렬하십시오'
# 'Include BLOCKINFO details in low level dump'
H27C5E3DE841C: 'low level dump에 BLOCKINFO 세부 정보 포함'
# "Include PTX for the following GPU architecture (e.g. sm_35) or 'all'. May be specified more than once."
H2031AC36E8FB: "다음 GPU 아키텍처(예: sm_35) 또는 'all'에 대해 PTX를 포함하십시오. 여러 번 지정할 수 있습니다."
# 'Include Parameters in templates.'
H8654E7CEAC51: '템플릿에 매개변수를 포함시키세요.'
# 'Include all attributes.'
H5307C43E1D9E: '모든 속성을 포함합니다.'
# 'Include and chain a header file after turning it into PCH'
HBFEBA9B95050: '헤더 파일을 PCH로 변환한 후 포함하고 체이닝합니다'
# 'Include brief documentation comments in code-completion results.'
H235F6D6F7048: '코드 완성 결과에 간결한 문서 주석을 포함합니다.'
# 'Include code completion results which require small fix-its.'
HFB6D833443A2: '소규모 fix-its가 필요한 코드 완성 결과를 포함합니다.'
# 'Include code patterns in code-completion results'
H22A7B204F988: '코드 완성 결과에 코드 패턴을 포함합니다'
# 'Include comments from within macros in preprocessed output'
H6B3D5AD18D24: '전처리된 출력에 매크로 내의 주석을 포함합니다'
# 'Include comments in preprocessed output'
H5CEC03939D7C: '프리프로세스된 출력에 주석을 포함합니다'
# 'Include declaration types in AST dumps'
H327A3B852BC1: 'AST 덤프에 선언 유형을 포함합니다'
# 'Include default header file for OpenCL and HLSL'
H5BEB3A92485B: 'OpenCL 및 HLSL용 기본 헤더 파일을 포함합니다'
# 'Include file before parsing'
H9043E8EF9CD8: '파싱 전에 포함 파일을 포함하십시오.'
# "Include line table offset in function's debug info and emit end sequence after each function's line data."
H98EA6A67A95E: '함수의 디버그 정보에 라인 테이블 오프셋을 포함하고 각 함수의 라인 데이터 후에 종료 시퀀스를 생성합니다.'
# 'Include macros from file before parsing'
H36D4DE65DD21: '파싱 전 파일에서 매크로를 포함시키기'
# 'Include macros in code-completion results'
H3EC7A0C589B9: '코드 완성 결과에 매크로 포함'
# 'Include module files in dependency output'
H1900641C3AE2: '의존성 출력에 모듈 파일을 포함합니다'
# 'Include only compilands those which match a regular expression'
H077919CD113F: '정규 표현식과 일치하는 compilands만 포함합니다'
# 'Include only symbols which match a regular expression'
HC57ED85CA0C0: '정규 표현식과 일치하는 기호만 포함합니다'
# 'Include only types which match a regular expression'
HF1FE163F1EFB: '정규 표현식과 일치하는 유형만 포함합니다'
# 'Include path for coverage check.'
HCF44564AEDD8: '커버리지 검사용 Include 경로.'
# 'Include precompiled header file'
HCCC9D73787DC: '사전 컴파일된 헤더 파일을 포함하라'
# 'Include system headers in dependency output'
HA0C79FE37C8B: '의존성 출력에 시스템 헤더 포함'
# 'Include what you use. Insert the owning header for top-level symbols, unless the header is already directly included or the symbol is forward-declared'
H8E18AB6F55BF: '사용하는 것들을 포함하라. 상위 레벨 심벌에 대한 소유 헤더를 삽입하라(헤더가 이미 직접 포함되거나 심벌이 전방 선언된 경우 제외)'
# 'Incorporate CUDA device-side binary into host object file.'
HC64F11374476: 'CUDA 장치 측 이진 파일을 호스트 오브젝트 파일에 통합합니다.'
# 'Increase alignment of LDS if it is not on align boundary'
H6B6D9E0BE911: '정렬 경계에 있지 않을 경우 LDS의 정렬을 늘립니다'
# "Increases 'x86-br-merging-base-cost' in cases that it is likely that all conditionals will be executed. For example for merging the conditionals (a == b && c > d), if its known that a == b is likely, then it is likely that if the conditionals are split both sides will be executed, so it may be desirable to increase the instruction cost threshold. Set to -1 to never merge likely branches."
H9238554A10FA: "특정 조건에서 'x86-br-merging-base-cost' 값을 증가시킵니다. 예를 들어 모든 조건문이 실행될 가능성이 높은 경우입니다. 예를 들어 조건 (a == b && c > d)을 병합할 때, a == b가 발생 가능성이 높은 것으로 알려져 있다면, 조건문을 분할할 경우 양쪽 모두 실행될 가능성이 높으므로 명령어 비용 임계값을 증가시키는 것이 바람직할 수 있습니다. -1로 설정하면 가능성 있는 분기 조건을 결코 병합하지 않습니다."
# "Increases 'x86-br-merging-base-cost' in cases that the target supports conditional compare instructions."
H0EFC5555FAAB: "타겟이 조건부 비교 명령을 지원하는 경우 'x86-br-merging-base-cost'를 증가시킵니다."
# 'Incremental depth computation will be used for basic blocks with more instructions.'
HE1566572AE0C: '명령문이 더 많은 기본 블록에 대해 증분 깊이 계산이 사용될 것입니다.'
# 'Index of module to extract'
H61BCB37228FB: '추출할 모듈의 인덱스'
# 'Indicate the sample profile being used is flattened, i.e., no inline hierarchy exists in the profile'
H8CEB9B04AD89: '사용되는 샘플 프로파일이 평평화되었음을 나타냅니다. 즉, 프로파일 내에 인라인 계층 구조가 존재하지 않습니다'
# 'Indirect access memory instruction weight'
H4459013C64C1: '간접 액세스 메모리 명령문 중량'
# 'Induction Variable Users'
HCAD9EC424CF6: '유도 변수 사용자들'
# 'Infer address spaces'
H384231A2B40A: '주소 공간 추론'
# 'Infer counts from stale profile data.'
H68A503AAE479: 'старый 프로파일 데이터에서 카운트를 추정합니다.'
# 'Infer missing call frames due to compiler tail call elimination.'
H3DAC7DFCC466: '컴파일러 꼬리 호출 제거로 인해 누락된 호출 프레임을 추론합니다.'
# 'Infer nuw/nsw flags using context where suitable'
H6B2FAC7DF345: '적절한 컨텍스트에서 nuw/nsw 플래그 추론'
# 'Inheritance.'
H21B03FF2F5DB: '상속.'
# 'Inhibit optimization of S->D register accesses on A15'
H9EE07FA9B2FD: 'A15에서 S->D 레지스터 접근의 최적화를 억제합니다'
# 'Init Undef Pass'
HA592C8476F8C: '초기화 미정의 패스'
# "Initialize trivial automatic stack variables. Defaults to 'uninitialized'"
H413F6C855E54: "단순 자동 스택 변수를 초기화합니다. 기본값은 'uninitialized'입니다."
# 'Inject absolute symbol definitions (syntax: <name>=<addr>)'
HD553F9022403: '절대 심볼 정의를 주입 (구문: <name>=<addr>)'
# 'Inject symbol aliases (syntax: <alias-name>=<aliasee>)'
H4CF0C6E38779: '기호 별칭 삽입 (구문: <별칭 이름>=<대상 기호>)'
# 'Inline all applicable functions on the device.'
H843E2B29FDA6: 'Inline 적용 가능한 모든 함수를 장치에서 inline 처리합니다.'
# 'Inline all functions early'
HBFFBF85B1F6E: '모든 함수를 조기 인라인'
# "Inline cold call sites in profile loader if it's beneficial for code size."
H86BDD048441C: '코드 크기에 유리할 경우 프로필 로더에서 cold 호출 사이트를 inline 처리합니다.'
# 'Inline expressions that are used only once rather than generating a let-binding'
HBC10ADACCD0B: '단 한 번만 사용되는 표현식을 let-바인딩 생성 대신 인라인 처리'
# 'Inline functions as deemed beneficial by the compiler'
H648E731FB641: '컴파일러가 유리하다고 판단되는 Inline 함수로'
# 'Inline functions which are (explicitly or implicitly) marked inline'
H8CD71C20FEE1: 'inline으로 명시적 또는 암묵적으로 표시된 Inline 함수'
# 'Inline shadow poisoning for blocks up to the given size in bytes.'
HD3284F467146: '지정된 바이트 크기까지의 블록에 대한 인라인 쉐도우 중독'
# 'Inline suitable functions'
H8AADDFE804BD: 'Inline 적합한 함수들'
# 'Inline threshold for device compilation for CUDA/HIP'
H94D1EB14515E: 'CUDA/HIP 디바이스 컴파일을 위한 인라인阙值'
# 'Inlined function.'
H5766708CD3DD: '인라인된 함수.'
# 'Inlinee lines (DEBUG_S_INLINEELINES subsection)'
H605540E4F837: '인라인된 라인 (DEBUG_S_INLINEELINES 하위 섹션)'
# 'Inliner for always_inline functions'
H228DE039DDE2: 'always_inline 함수를 위한 인라이너'
# 'Inner loop block size threshold to analyze in unroll for AMDGPU'
H2139A958B6DF: 'AMDGPU용 언롤 분석 시 내부 루프 블록 크기 임계값'
# 'Inplace edit <file>s'
H1E18B41D725B: '원본 편집 <file>'
# 'Inplace edit <file>s, if specified.'
H469713E2DE1D: '지정된 경우 <file>을(를) 원본 파일 내에서 편집합니다.'
# 'Input JSON stream encoding'
HDA67A1195E8E: '입력 JSON 스트림 인코딩'
# 'Input file. Can be specified multiple times for multiple input files.'
H5D0C7337A0AA: '입력 파일입니다. 여러 개의 입력 파일을 지정하려면 여러 번 지정할 수 있습니다.'
# "Input file. The format is an array of contexts.\nEach context is a dictionary with the following keys:\n'Guid', mandatory. The value is a 64-bit integer.\n'Counters', mandatory. An array of 32-bit ints. These are the counter values.\n'Contexts', optional. An array containing arrays of contexts. The context array at a position 'i' is the set of callees at that callsite index. Use an empty array to indicate no callees."
H53610FB0F715: "입력 파일입니다. 형식은 컨텍스트 배열로 지정됩니다.\n각 컨텍스트는 다음 키를 갖는 딕셔너리입니다:\n'Guid': 필수. 값은 64비트 정수입니다.\n'Counters': 필수. 32비트 정수 배열입니다. 이 배열은 카운터 값들을 포함합니다.\n'Contexts': 선택적. 컨텍스트 배열을 포함하는 배열입니다. 위치 'i'의 컨텍스트 배열은 해당 호출 지점 인덱스의 호출받는 함수 집합입니다. 호출자가 없는 경우 빈 배열을 사용합니다."
# "Input language ('ir' or 'mir')"
HAAA3662FD097: "입력 언어 ('ir' 또는 'mir')"
# 'Input lines with annotations'
H7B5B0A60C876: '주석이 있는 입력 라인'
# 'Input lines with starting points of annotations'
H2C5EEFB1318C: '주석의 시작 지점을 가진 입력 라인'
# 'Input lines with starting points of error annotations'
H738B96DDE138: '오류 주석의 시작 지점을 포함하는 입력 라인'
# 'Input remark format to parse'
H719353F24FE9: '해석할 입력 주석 형식'
# 'Insert BLOCK/LOOP/TRY/TRY_TABLE markers for WebAssembly scopes'
H7D3A208C7E5E: 'WebAssembly 범위를 위한 BLOCK/LOOP/TRY/TRY_TABLE 마커를 삽입하세요'
# 'Insert CFI remember/restore state instructions'
H6E95A98450BA: 'CFI 상태를 기억/복원하는 명령어 삽입'
# 'Insert KCFI indirect call checks'
H9190E8521B57: 'KCFI 간접 호출 검사 삽입'
# 'Insert XRay ops'
HB3BFBF584BC3: 'XRay 연산자 삽입'
# 'Insert a break point on the last enabled count of a chunks list'
H14F2710F0183: 'Chunks 목록의 마지막 활성화 카운트에 중단점을 삽입합니다'
# 'Insert a specific header. This should run with STDIN mode.\nThe result is written to stdout. It is currently used for\neditor integration. Support YAML/JSON format:\n  -insert-header="{\n     FilePath: "/path/to/foo.cc",\n     QuerySymbolInfos: [\n       {RawIdentifier: foo,\n        Range: {Offset: 0, Length: 3}}\n     ],\n     HeaderInfos: [ {Headers: "\\"foo_a.h\\"",\n                     QualifiedName: "a::foo"} ]}"'
HAF484669F973: '특정 헤더를 삽입합니다. STDIN 모드로 실행되어야 합니다.\n결과는 stdout에 작성됩니다. 현재 편집기 통합에 사용됩니다.\nYAML/JSON 형식을 지원합니다:\n  -insert-header="{\n     FilePath: "/path/to/foo.cc",\n     QuerySymbolInfos: [\n       {RawIdentifier: foo,\n        Range: {Offset: 0, Length: 3}}\n     ],\n     HeaderInfos: [ {Headers: "\\"foo_a.h\\"",\n                     QualifiedName: "a::foo"} ]}"'
# 'Insert calls to __dfsan_*_callback functions on data events.'
HBF62B008B7B5: '데이터 이벤트 시 __dfsan_*_callback 함수의 호출을 삽입하십시오.'
# 'Insert calls to __dfsan_nonzero_label on observing a parameter, load or return with a nonzero label'
HCF1838FEBC0F: '매개변수, 로드 또는 0이 아닌 레이블을 가진 리턴을 감지할 때 __dfsan_nonzero_label에 대한 호출을 삽입하십시오'
# 'Insert calls to callback functions on conditionals.'
H462621715E94: '조건문에 콜백 함수 호출을 삽입합니다.'
# 'Insert calls to callback functions on data reaching a function.'
H874EB16726E7: '데이터가 함수에 도달할 때 콜백 함수 호출을 삽입합니다.'
# 'Insert calls to fentry at function entry (x86/SystemZ only)'
H5602F1E7FC9F: '함수 시작 부분에 fentry 호출을 삽입 (x86/SystemZ 전용)'
# 'Insert checks for constant shadow values'
HEF594A46B3BD: '상수 샤도우 값에 대한 검사 추가'
# 'Insert fentry calls'
HCD006A416E6E: 'fentry 호출 삽입'
# 'Insert instructions into the prologue for storing into the stack ring buffer'
H46F958F6D7F3: '프롤로그에 스택 링 버퍼에 저장하기 위한 명령문을 삽입합니다'
# 'Insert instructions into the prologue for storing into the stack ring buffer directly'
H31D52AECD84E: '프롤로그에 스택 링 버퍼에 직접 저장하기 위한 지시문을 삽입합니다'
# 'Insert pseudo probe annotations for value profiling'
H219A8D7D9F81: '값 프로파일링을 위한 의사 프로브 주석 삽입'
# 'Insert required mode register values'
HA0E87197EB1B: '필요한 모드 레지스터 값 삽입'
# 'Insert sanitizers on OptimizerEarlyEP.'
HC54CCA49CF20: 'OptimizerEarlyEP 단계에 산타이저를 삽입합니다.'
# 'Insert stack protectors'
H2189E21FAD58: '스택 보호기 삽입'
# 'Insert stores for EH state numbers'
HAFD53ADD3CBA: 'EH 상태 번호를 위한 stores 삽입'
# 'Insert symbols at valid longjmp targets for /guard:cf'
H36BD6FBCD02B: '/guard:cf를 위해 유효한 longjmp 대상에 심볼을 삽입합니다'
# 'Insert symbols at valid targets for /guard:ehcont'
H071F81C54D78: 'guard:ehcont 옵션에 적합한 위치에 심볼을 삽입하세요'
# 'Insert the experimental `assertalign` node.'
H893CAC606686: '실험적인 `assertalign` 노드를 삽입합니다.'
# 'Insert vsetvlis before vmvNr.vs to ensure vtype is valid and vill is cleared'
H0091B7D0D6C7: 'vmvNr.vs 앞에 vsetvlis를 삽입하여 vtype이 유효하고 vill이 초기화되도록 하십시오'
# 'InstPrinter options'
HFBC5B2731840: 'InstPrinter 옵션'
# 'Instantiate templates already while building a PCH'
H9EE0E3239942: 'PCH를 생성하는 동안 템플릿을 미리 인스턴스화합니다'
# 'Instead of emitting the pipelined code, annotate instructions with the generated schedule for feeding into the -modulo-schedule-test pass'
HD7DD1AFC4508: '파이프라인된 코드를 생성하는 대신, 생성된 스케줄을 지시문에 추가하여 -modulo-schedule-test 패스에 입력으로 전달합니다'
# 'Instead of expanding system headers when emitting preprocessor output, preserve the #include directive. Useful when producing preprocessed output for test case reduction. May produce incorrect output if preprocessor symbols that control the included content (e.g. _XOPEN_SOURCE) are defined in the including source file. The portability of the resulting source to other compilation environments is not guaranteed.\n\nOnly valid with -E.'
H2BDDF0355665: '프리프로세서 출력을 생성할 때 시스템 헤더를 확장하는 대신 #include 지시문을 유지합니다. 테스트 케이스 축소를 위한 프리프로세서 출력을 생성할 때 유용합니다. 포함된 내용을 제어하는 프리프로세서 심벌(예: _XOPEN_SOURCE)이 포함하는 소스 파일에 정의되어 있으면 잘못된 출력이 생성될 수 있습니다. 결과 소스의 다른 컴파일 환경에서의 포터빌리티는 보장되지 않습니다.\n\n-E 옵션과 함께 사용할 수 있습니다.'
# 'Instead of running LTO, list the dependent libraries in each IR file'
H03C32E83B1C7: 'LTO 실행 대신 각 IR 파일의 의존 라이브러리를 나열하세요'
# 'Instead of running LTO, list the symbols in each IR file'
HA0AFB51F310C: 'LTO를 실행하는 대신 각 IR 파일의 심볼을 나열하십시오'
# 'Instead of running LTO, print the mach-o cpu in each IR file'
HE9DA1147E6B8: 'LTO 실행 대신 각 IR 파일의 mach-o CPU를 출력합니다'
# 'Instruction Inverse Throughput'
H08AC91953156: '명령어 역 투과율'
# 'Instruction Latency'
HFD97D6973432: '지시문 지연 시간'
# "Instruction cutoff for aggressive tail duplication during layout. Used at -O3. Tail merging during layout is forced to have a threshold that won't conflict."
H0BFD5BDD2709: '레이아웃 중 강력한 테일 복제를 위한 인스트럭션 기준. 옵티마이저 레벨 -O3에서 사용됩니다. 레이아웃 중 테일 병합은 충돌하지 않는 임계값을 강제로 설정됩니다.'
# "Instruction cutoff for tail duplication during layout. Tail merging during layout is forced to have a threshold that won't conflict."
HCFA67B310DAB: '레이아웃 중 꼬리 복제를 위한 인스트럭션 절단. 레이아웃 중 꼬리 병합은 충돌하지 않는 임계값을 강제로 설정됩니다.'
# 'Instruction latency'
H6CD53FB2E731: '명령어 레이턴시'
# 'Instruction schedulers available (before register allocation):'
H4C7D1036B846: '명령어 스케줄러 (레지스터 할당 전에 사용 가능):'
# 'Instructions, lines, scopes, symbols and types.'
HD37C6649C311: '명령문, 라인, 범위, 기호 및 유형입니다.'
# 'Instrument (context sensitive) the IR to generate profile.'
HAAB0AE0AE781: '프로파일을 생성하기 위해 IR에 (컨텍스트 감도 있는) 측정 도구를 삽입합니다.'
# 'Instrument - operations with pointer operands'
HDBC71D3E6754: '추적 - 포인터 피연산자 연산'
# 'Instrument <, <=, >, >= with pointer operands'
H6DA2CC308CCE: '포인터 피연산자를 사용한 <, <=, >, >= 연산자 측정'
# 'Instrument <, <=, >, >=, - with pointer operands'
H012240D9415C: '포인터 피연산자와 함께 <, <=, >, >=, - 연산자를 측정합니다'
# 'Instrument atomics'
HBB3D2F3D5275: '원자 연산 추적'
# 'Instrument code to produce gcov data files (*.gcda)'
HFE3A9A25C96C: 'gcov 데이터 파일(*.gcda)을 생성하기 위해 코드에 트레이스를 삽입합니다.'
# 'Instrument control-flow architecture protection'
H2142469CBC51: '제어 흐름 아키텍처 보호 기능 활성화'
# 'Instrument device library for HIP, which is a LLVM bitcode containing __cyg_profile_func_enter and __cyg_profile_func_exit'
H24C9537239C3: 'HIP를 위한 디바이스 라이브러리에 LLVM 비트코드로 구성된 측정 도구를 추가하며, 이는 __cyg_profile_func_enter와 __cyg_profile_func_exit를 포함합니다'
# 'Instrument floating-point comparisons'
HFB5DAE0497FE: '부동소수점 비교 트레이스 활성화'
# 'Instrument function entry and exit'
H744C2AF9F0F5: '함수 진입과 종료를 기록합니다'
# 'Instrument function entry only, after inlining, without arguments to the instrumentation call'
H10B2DF0B7A61: '인라인 후 함수 진입부만 기록하고 인스트루먼트 호출에 인자를 포함하지 않음'
# 'Instrument function entry with call to __CheckForDebuggerJustMyCode'
H38C50073F978: '함수 진입점에 __CheckForDebuggerJustMyCode 호출을 추가합니다'
# 'Instrument function entry/exit with calls to e.g. mcount() (post inlining)'
H41E9F3846338: '함수 진입/종료에 mcount()와 같은 호출을 통해 측정 도구 삽입 (인라인 후)'
# 'Instrument functions with a call to __CheckForDebuggerJustMyCode'
H179F36D1CDA5: '함수에 __CheckForDebuggerJustMyCode 호출을 삽입합니다'
# 'Instrument globals'
HF9B96A5EACA6: '전역 변수 기록'
# 'Instrument memintrinsics (memset/memcpy/memmove)'
HE6033F8FFDF9: 'memintrinsics (memset/memcpy/memmove) 분석 활성화'
# 'Instrument memory accesses'
H9382264E0AFD: '메모리 액세스를 기록합니다'
# "Instrument only functions from files where names don't match all the regexes separated by a semi-colon"
HD8259B6217C3: '세미콜론으로 구분된 모든 정규식과 일치하지 않는 이름을 가진 파일의 함수만 측정합니다'
# 'Instrument only functions from files where names match any regex separated by a semi-colon'
H261C37210502: '세미콜론으로 구분된 정규식 중 하나와 이름이 일치하는 파일의 함수만 인스트루먼트합니다'
# 'Instrument scalar stack variables'
HC15A017384F6: '스칼라 스택 변수에 도구를 적용합니다'
# 'Instrument the IR to generate profile.'
H5521F08582E8: 'IR에 프로파일을 생성하기 위한 도구를 추가합니다.'
# 'Instrument the same temp just once'
H47FE01195CE1: '같은 temp를 한 번만 악기화합니다'
# 'Instrumentation profile (default)'
H8B8FBAF3F224: '인스트루먼테이션 프로파일 (기본값)'
# 'Intel SVML library'
H43C24287102B: '인텔 SVML 라이브러리'
# 'Interchange if you gain more than this number'
H1A5217DD30CE: '이 숫자보다 더 많은 이점을 얻는 경우 교환'
# 'Internal Options'
HE6B42A71FEB4: '내부 옵션'
# 'Internal and debugging options'
H1AFE239C87EF: '내부 및 디버깅 옵션'
# 'Internal traces and extra debugging code.'
HFC2113D2B3C3: '내부 추적 및 추가 디버깅 코드입니다.'
# 'Internalize linked symbols'
H4254AEAF9E4E: 'Internalize linked symbols'
# 'Intrinsics Generator Options'
H4BD784F50D5F: '인트리니크 생성기 옵션'
# 'Introduce mul24 intrinsics in AMDGPUCodeGenPrepare'
H3C667C2E6C53: 'AMDGPUCodeGenPrepare에 mul24 인트린스틱 추가'
# 'Invalid code ranges.'
H1F42CA5A3D9B: '잘못된 코드 범위입니다.'
# 'Invalid symbol coverages values.'
H3E269D60065B: '잘못된 심볼 커버리지 값입니다.'
# 'Invalid symbol locations.'
H5E97A467E1AD: '잘못된 기호 위치입니다.'
# 'Issue call to specified function rather than a trap instruction'
HA69FCF5CDF0A: '지정된 함수 호출을 트랩 명령 대신 발생시킵니다'
# 'Iterate to a fixed point when attempting to convert reg-reg instructions to reg-imm'
HD223D51415E6: 'reg-reg 명령문을 reg-imm로 변환하려고 시도할 때 고정 지점에 도달할 때까지 반복'
# 'Iterative inference: delta convergence precision; smaller values typically lead to better results at the cost of worsen runtime'
H1328F2EA33BA: '반복 추론: 델타 수렴 정밀도; 작은 값은 일반적으로 더 나은 결과를 가져오지만 실행 시간이 악화되는 비용을 지불해야 합니다'
# 'Iterative inference: maximum number of update iterations per block'
H5F6BCC565010: '반복 추론: 각 블록당 최대 업데이트 반복 횟수'
# 'JIT the code and run it by invoking the main function'
HC922A3A5E7D1: '코드를 JIT 컴파일하고 메인 함수를 호출하여 실행합니다'
# 'JITLink Options'
H759F3B87058B: 'JITLink 옵션'
# 'JSON format'
H5766BFD5841D: 'JSON 형식'
# 'Join isolated components having positive flow.'
HA5D28D00BB60: '양의 유량을 가진 격리된 구성 요소를 연결합니다.'
# 'Jump score power (when --split-strategy=cdsplit)'
H4F864F9914B4: '점프 점수 파워 (cdsplit 옵션을 사용할 때)'
# 'Just print the preprocessed file'
H19C52BC87B22: '전처리된 파일을 출력합니다'
# 'Just run preprocessor, no output (for timings)'
HA774A3EF0AA6: '전처리기만 실행하고 출력 없음 (타이밍 측정용)'
# 'Kaleidoscope example program\n'
HCF3536F4FAAB: 'Kaleidoscope 예제 프로그램\n'
# 'Keep all benchmarks (default)'
HD3F623D56EDC: '모든 벤치마크 유지 (기본값)'
# 'Keep all non-cold contexts (increases cloning overheads)'
H4544ED3678BF: '모든 non-cold 컨텍스트 유지(클로닝 오버헤드 증가)'
# 'Keep aside the last <num-test-traces> traces in the profile when computing the function order and instead use them to evaluate that order'
H77D85A9D26A6: '프로파일에서 함수 순서를 계산할 때 마지막 <num-test-traces> 추적을 보존하고, 대신 이를 사용하여 해당 순서를 평가합니다'
# 'Keep copies of symbols in LTO indexing'
HB94AF3670BCE: 'LTO 인덱싱 중 심볼의 복사본을 유지합니다'
# 'Keep going on errors encountered'
H418BF6CA6A97: '에러가 발생할 때도 계속 진행'
# 'Keep going on errors encountered in trace 1'
H99638570EFA7: '트레이스 1에서 발생한 오류가 있어도 계속 진행합니다.'
# 'Keep going on errors encountered in trace 2'
HCFE6CEB4DFCA: 'trace 2에서 발견된 오류가 발생해도 계속 실행합니다'
# 'Keep initializers of constants'
H36ACE3809A61: '상수의 초기화자를 유지하십시오'
# 'Keep max reading'
H5A60CCC0248E: '최대 읽기 유지'
# 'Keep min reading'
H6EAFD9A719C6: '최소 읽기를 유지하십시오'
# 'Keep only the benchmarks that *DO* involve memory'
HF9706AF3813D: '메모리와 관련된 벤치마크만 유지합니다'
# 'Keep only those benchmarks that do *NOT* involve memory'
H135A99676AA8: '메모리와 관련되지 않은 벤치마크만 유지합니다'
# 'Keep readings set with min-variance'
H09D9C8B784B4: '최소 분산으로 설정된 읽기를 유지'
# 'Keep static const variables even if unused'
H6813EA88BF1D: '사용되지 않더라도 static const 변수를 유지합니다'
# 'Keep the last K contexts while merging cold profile. 1 means the context-less base profile'
H3B3B98C36252: 'coldd 프로파일을 병합할 때 마지막 K 개의 컨텍스트를 유지합니다. 1은 컨텍스트가 없는 기본 프로파일을 의미합니다'
# 'Keep the last K contexts while merging profile. -1 means no depth limit.'
HE51374D52FCC: '프로파일을 병합하는 동안 최종 K 컨텍스트를 유지합니다. -1은 깊이 제한이 없다는 의미입니다.'
# 'Keep the last K contexts while merging unsymbolized profile. -1 means no depth limit.'
HCA7356B0D5FB: '프로파일을 병합할 때 마지막 K 개의 컨텍스트를 유지합니다. -1은 깊이 제한이 없음을 의미합니다.'
# 'Keep the last K frames while merging cold profile. 1 means the context-less base profile'
H4AC5A2FF5CAD: 'cold profile을 병합할 때 마지막 K 프레임을 유지합니다. 1은 컨텍스트가 없는 기본 프로파일을 의미합니다'
# 'Kernel code model'
H99C64FCE935F: '커널 코드 모델'
# 'Kernel limit wave threshold in %'
H670F8AEC39A0: '커널 제한 파동 임계값 %에서'
# 'Kind of debug info to add'
HBD02ACC04B34: '추가할 디버그 정보의 종류'
# 'LCSSA Verifier'
HF121CA5D89C7: 'LCSSA 검증기'
# 'LLDB Instrumentation Generator'
H3C61B845C07E: 'LLDB 인스트루먼테이션 생성기'
# 'LLJITDumpObjects'
H6958140CABBB: 'LLJIT 객체 덤프'
# 'LLJITWithCustomObjectLinkingLayer'
H632B9B1CBCE5: 'LLJIT사용자정의객체링크레이어'
# 'LLJITWithGDBRegistrationListener'
HB6D370668767: 'LLJITWithGDBRegistrationListener'
# 'LLJITWithInitializers'
HACE516CC94B0: 'LLJITWithInitializers'
# 'LLJITWithLazyReexports'
H3A104CF605C4: 'LLJITWithLazyReexports'
# 'LLJITWithObjectCache'
H71A8C9D07573: 'LLJITWithObjectCache'
# 'LLJITWithObjectLinkingLayerPlugin'
H748539F4EA26: 'LLJIT 객체 연결 계층 플러그인'
# 'LLJITWithRemoteDebugging'
H3A8FDD7C38FF: 'LLJITWithRemoteDebugging'
# 'LLJITWithThinLTOSummaries'
HE8A81BB7479F: 'LLJIT와 ThinLTO 요약 정보'
# 'LLVM C++ ABI Data Dumper\n'
HEF94C326E777: 'LLVM C++ ABI 데이터 덤피어\n'
# 'LLVM C++ mangled name remapper\n'
H374D96C0B2FD: 'LLVM C++ 이름 압축 재정의 도구\n'
# 'LLVM Contextual Profile Utils\n'
H96B79F1155FF: 'LLVM 컨텍스트 프로파일 유틸리티\n'
# 'LLVM IR Similarity Visualizer\n'
H1B7F78E6F996: 'LLVM IR 유사성 시각화 도구\n'
# 'LLVM OpenMP'
H6A5AC73C091C: 'LLVM OpenMP'
# 'LLVM PDB Dumper\n'
HD0867800CD16: 'LLVM PDB 덤피어\n'
# 'LLVM automatic testcase reducer.\nSee https://llvm.org/docs/CommandGuide/llvm-reduce.html for more information.\n'
HD6FE445BE8E3: 'LLVM 자동 테스트 케이스 축소기.\n자세한 내용은 https://llvm.org/docs/CommandGuide/llvm-reduce.html을 참고하시오.\n'
# 'LLVM automatic testcase reducer. See\nhttp://llvm.org/cmds/bugpoint.html for more information.\n'
H28E8E607A645: 'LLVM 자동 테스트 케이스 감소기입니다. 참조: http://llvm.org/cmds/bugpoint.html 자세한 내용은\n'
# 'LLVM code coverage tool\n'
HB94353E136F7: 'LLVM 코드 커버리지 툴\n'
# 'LLVM module splitter\n'
H99370B462DED: 'LLVM 모듈 분할기\n'
# 'LLVM profile data\n'
H799B04E164DC: 'LLVM 프로파일 데이터\n'
# 'LMUL argument must be in the range [0,3] or [5,7]'
H3949F7728682: 'LMUL 인수는 [0,3] 또는 [5,7] 범위 내에 있어야 합니다'
# 'LSR search space complexity limit'
H6C951DA0F280: 'LSR 검색 공간 복잡성 제한'
# 'LTO Options'
H45ADD610F25F: 'LTO 옵션'
# 'LTO requires -fuse-ld=lld'
H1F6F6CBC7560: 'LTO는 -fuse-ld=lld를 지정해야 합니다'
# 'Label.'
H213B873A2E3C: '레이블.'
# 'Lanai Assembly Printer'
HABEAC7BF71A9: '라나이 어셈블리 프린터'
# 'Lanai DAG->DAG Pattern Instruction Selection'
HF0BD56FB7903: 'Lanai DAG->DAG 패턴 명령 선택'
# 'Lanai memory ALU combiner pass'
H6ECAF3A1B377: 'Lanai 메모리 ALU 조합 패스'
# 'Language standard to compile for'
HC9609252D3B1: '컴파일할 언어 표준'
# 'Large code model'
H6118BEDCF561: '큰 코드 모델'
# 'Large stride memory access threshold'
H0DDCC23DCFC1: '큰 스트라이드 메모리 접근 임계값'
# 'Large stride memory access weight'
HD5651F61773D: '큰 스트라이드 메모리 액세스 가중치'
# 'Last chance recoloring max depth'
HF4F4F97F3F0A: '마지막 기회 재색칠 최대 깊이'
# 'Last chance recoloring maximum number of considered interference at a time'
HB5BF2EA66D0A: '마지막 기회 재색칠 시 한 번에 고려하는 간섭 최대 수'
# 'Launch an out-of-process executor to run code'
HB7F275AE5070: '프로세스 외부의 실행기를 실행하여 코드를 실행합니다'
# 'Lazy Block Frequency Analysis'
HAEAE6F9C4ECD: '지연 블록 빈도 분석'
# 'Lazy Branch Probability Analysis'
H0F9273E7A928: '지연 분기 확률 분석'
# 'Lazy Machine Block Frequency Analysis'
H58403538D0D3: '지연 머신 블록 빈도 분석'
# 'Lazy Value Information Analysis'
HD066D1FABC77: '지연 값 정보 분석'
# 'Least BB number of huge function.'
H5201BDD0F5FF: '대규모 함수의 최소 BB 수.'
# 'Leave out unnecessary information when printing MIR'
HEE7C41A11713: 'MIR 출력 시 불필요한 정보 생략'
# "Legalize the Machine IR a function's Machine IR"
H082594DE8633: 'Machine IR을 함수의 Machine IR로 합법화합니다.'
# 'Level of field padding for AddressSanitizer'
H02387EE95AC8: 'AddressSanitizer의 필드 패딩 수준'
# 'Lex file in raw mode and dump raw tokens'
H9BBDD925BA53: '원시 모드에서 파일을 분석하고 원시 토큰을 dump'
# 'Lex tokens from a .s file'
H4216F66AFBE5: '어셈블리 파일(.s)에서 토큰을 분석합니다.'
# 'Lexical block.'
HDAAEFA6A8637: '문법적 블록.'
# 'Lexical scope level (File=0, Compile Unit=1).'
H7F636BA87B45: '문법적 범위 수준 (파일=0, 번역 단위=1).'
# 'Libraries to link dynamically'
H9E0097DC803F: '동적으로 링크할 라이브러리'
# "Like 'ExecutorNative' if ORC runtime provided, otherwise like 'GenericIR'"
H4792AD158E44: "ORC 런타임이 제공되는 경우 'ExecutorNative'와 같고, 그렇지 않은 경우 'GenericIR'과 같습니다."
# 'Like -MD, but also implies -E and writes to stdout by default'
H09E4A86636C3: '-MD와 유사하지만, -E도 포함하고 기본적으로 stdout에 작성합니다'
# 'Like -MMD, but also implies -E and writes to stdout by default'
H3264A1580B97: '‘-MMD와 유사하지만, -E도 포함하며 기본적으로 stdout에 씁니다.’'
# 'Like -O2 but optimize for code size above all else. Similar to clang -Oz. Same as -passes="default<Oz>"'
H2F3FC31B4B90: '-O2와 유사하지만 코드 크기를 최대한 줄이는 것을 가장 우선시합니다. clang -Oz와 유사합니다. -passes="default<Oz>"와 동일합니다'
# 'Like -O2 but size-conscious. Similar to clang -Os. Same as -passes="default<Os>"'
H17C4D6C7AE33: 'O2 옵션과 유사하지만 코드 크기에 주의를 기울입니다. clang -Os와 유사합니다. -passes="default<Os>"와 동일합니다.'
# 'Like -finstrument-functions, but insert the calls after inlining'
H71DE1A83F0E0: '-finstrument-functions 옵션과 유사하지만, 인라인 후 호출을 삽입합니다'
# 'Like -fmodules-decluse but requires all headers to be in modules'
H9B04279148C1: '-fmodules-decluse 옵션과 유사하지만 모든 헤더가 모듈에 포함되어야 합니다'
# "Like -fno-semantic-interposition but don't use local aliases"
H1E8DA2527D1D: '-fno-semantic-interposition과 같이 하지만 로컬 별칭을 사용하지 않습니다'
# 'Like -printlineinfo but does not load the object first'
H4419DBB99339: '-printlineinfo와 동일하지만 먼저 오브젝트를 로드하지는 않습니다'
# 'Like /Z7'
H4FD8854D9F4E: '예를 들어 /Z7'
# 'Like /showIncludes but omit system headers'
H688724C80945: 'showIncludes와 비슷하지만 시스템 헤더는 생략합니다'
# 'Limit all regclasses to N registers'
H63DA69AD987D: '모든 레지스터 클래스를 N 레지스터로 제한합니다'
# 'Limit block size to analyze in load/store widening pass'
H7ECB2D63C850: '로드/스토어 확장 패스에서 분석 시 블록 크기 제한'
# 'Limit cases to analyze when converting a switch to select'
H4850FF8E3DC7: 'switch를 select로 변환할 때 분석할 사례 제한'
# 'Limit debug information produced to reduce size of debug binary'
H538935517F09: '생성된 디버그 정보를 제한하여 디버그 바이너리의 크기를 줄입니다'
# 'Limit float precision to the given value'
HF96C59869298: '지정된 값으로 부동소수점 정밀도 제한'
# 'Limit maximum recursion depth when calculating costs of speculatively executed instructions'
H66110CD9CA1F: '예측 실행 명령어의 비용을 계산할 때 최대 재귀 깊이 제한'
# 'Limit on instruction search range in frame index elimination'
HBC1B1C08E702: '프레임 인덱스 제거에서의 명령어 탐색 범위 제한'
# 'Limit on the cost of instructions that can be repeated due to loop flattening'
HD92D80EEAC82: '루프 평평화로 인해 반복될 수 있는 명령어의 비용 제한'
# 'Limit on the number of reused registers in frame index elimination'
H607E68347FE8: '프레임 인덱스 제거 시 재사용된 레지스터 수의 제한'
# 'Limit options in the Modules category to the specified module index'
HB070B9863405: 'Modules 카테고리의 옵션을 지정된 모듈 인덱스로 제한'
# 'Limit ready list to N instructions'
H5F2D4380F5BB: 'N개의 명령문까지 준비 목록을 제한합니다'
# 'Limit register pressure of scheduled loop'
H7D5776BBBD61: '스케줄된 루프의 레지스터 압력을 제한합니다.'
# 'Limit the length of PHI chains to lookup'
H44DF903D7B74: 'PHI 체인의 길이를 조회 시 제한합니다'
# 'Limit the number of collected seeds groups in a BB to cap compilation time.'
HCB093C287DF8: 'BB에서 수집한 시드 그룹의 수를 제한하여 컴파일 시간을 제한합니다.'
# 'Limit the number of instructions to process (0 for no limit)'
H0F105AAF8005: '처리할 명령문의 수를 제한합니다 (0은 제한 없음)'
# 'Limit the number of loads analysed'
H27294DA00A2A: '분석된 로드의 수를 제한합니다'
# 'Limit the number of operands to inline for Token Factors'
HEA9F8176A261: '토큰 팩터의 인라인 처리에 사용되는 연산자 수 제한'
# 'Limit the number of registers available for integer arguments'
HD3D75863FAEB: '정수 인수에 사용할 수 있는 레지스터 수를 제한합니다'
# 'Limit the number of times for the same StoreNode and RootNode to bail out in store merging dependence check'
H611EA77C379A: '저장 병합 종속성 검사에서 동일한 StoreNode와 RootNode의 포기 횟수를 제한합니다'
# 'Limit the recursion depth when building a vectorizable tree'
HAF7BB4678550: '벡터화 가능한 트리를 구축할 때 재귀 깊이를 제한합니다'
# 'Limit the size of the SLP scheduling region per block'
HEAF5A10A6293: '블록 당 SLP 스케줄링 영역의 크기를 제한합니다'
# 'Limit the size of the seed bundle to cap compilation time.'
H4DFB40A73CC1: '시드 번들의 크기를 제한하여 컴파일 시간을 제한합니다.'
# 'Limits the range of tokens in -check file on which various features are tested. Example --check-lines=3-7 restricts testing to lines 3 to 7 (inclusive) or --check-lines=5 to restrict to one line. Default is testing entire file.'
H2A6188976AA0: '-check 파일에서 다양한 기능을 테스트하는 토큰의 범위를 제한합니다. 예시: --check-lines=3-7는 3줄부터 7줄까지(포함) 테스트 범위를 제한하며, --check-lines=5는 한 줄만 제한합니다. 기본값은 전체 파일을 테스트하는 것입니다.'
# 'Linalg ODS Gen from YAML'
H78D204B7569D: 'YAML에서 Linalg ODS 생성'
# 'Line kind to use when printing lines.'
H1ECE7CAA5A71: '프린트할 때 사용할 줄 종류'
# 'Line qualifiers (Newstatement, BasicBlock, etc.).'
H20226D797BE3: '라인 자격식 (Newstatement, BasicBlock 등).'
# 'Line tables'
H4C16BA3AF07D: '라인 테이블'
# 'Linearize DAG, no scheduling'
HD1B44C093366: 'DAG 선형화, 스케줄링 없음'
# 'Lines (DEBUG_S_LINES subsection)'
H916009E842F5: '라인 (DEBUG_S_LINES 하위 섹션)'
# 'Lines referenced in the debug information.'
H59B1C9901129: '디버그 정보에 참조된 라인.'
# 'Lines.'
HC7986E72D11E: '라인 수.'
# 'Link Options'
HCC3832473F0F: '링크 옵션'
# 'Link XRay runtime library when -fxray-instrument is specified (default)'
H3CD4BCB6EB07: '-fxray-instrument가 지정되면 XRay 런타임 라이브러리를 링크합니다 (기본값)'
# 'Link against library X in the library search paths'
HCEDA0BA2279F: '라이브러리 검색 경로에 있는 라이브러리 X와 링크합니다'
# 'Link against library X in the library search paths with hidden visibility'
H0C1A37003713: '라이브러리 검색 경로에서 숨겨진 가시성으로 X 라이브러리를 링크하라'
# 'Link against library X with hidden visibility'
H7FCFC84F1391: 'X 라이브러리를 숨겨진 가시성으로 연결합니다'
# 'Link and internalize needed symbols from the given bitcode file before performing optimizations.'
H592432E99C1A: '최적화를 수행하기 전에 지정된 비트코드 파일에서 필요한 심볼을 연결하고 내부화합니다.'
# 'Link as a hybrid ARM64X image'
H741A1167C632: '하이브리드 ARM64X 이미지로 링크'
# 'Link builtin bitcodes after the optimization pipeline'
HA396158ACBD5: '최적화 파이프라인 후에 내장 비트코드를 연결합니다'
# 'Link clang-offload-bundler bundles for HIP'
HB7831777CE51: 'HIP용 clang-offload-bundler 번들 링크'
# 'Link device libraries for GPU device compilation'
H585B50C49350: 'GPU 디바이스 컴파일을 위한 디바이스 라이브러리 연결'
# 'Link only needed symbols'
H7CCE9D08A2A1: '필요한 심볼만 연결합니다'
# 'Link stack frames through backchain on System Z'
H0C4B76743142: 'System Z에서 backchain을 통해 스택 프레임을 연결합니다'
# 'Link the LLVM C Library for GPUs'
HD105C9964C21: 'GPU용 LLVM C 라이브러리를 링크합니다'
# 'Link the flang-rt shared library'
H92B8D27A2242: 'flang-rt 공유 라이브러리 연결'
# 'Link the flang-rt static library'
H31D4E54E52D3: 'flang-rt 정적 라이브러리 연결'
# 'Link the following file lazily'
HB68406E1D5AC: '다음 파일을 지연 로딩으로 연결하십시오'
# 'Link the given bitcode file before performing optimizations.'
H1729D1922ED4: '최적화를 수행하기 전에 지정된 비트코드 파일을 링크합니다.'
# 'Link two nested MLIR modules into a single LLVM IR module. Useful if both the host and device code can be run on the same CPU, as in SPIR-V CPU Runner tests.'
HF4FD097D1426: '중첩된 두 개의 MLIR 모듈을 단일 LLVM IR 모듈로 연결합니다. 호스트 및 디바이스 코드가 동일한 CPU에서 실행될 수 있는 경우, 예를 들어 SPIR-V CPU 러너 테스트와 같이 유용합니다.'
# 'Linkage name.'
HC775F1647BB7: '링크지 이름.'
# 'Linking with hot/cold operator new interfaces'
H1970EBF2160A: 'hot/cold operator new 인터페이스와 연결 중'
# 'Linux PPC Assembly Printer'
H99056A1F92AF: '리눅스 PPC 어셈블리 프린터'
# 'List bundle IDs in the bundled file.\n'
H3D67FC934FB6: '번들 파일에 있는 번들 ID를 나열합니다.\n'
# 'List each file/graph name if/when it is linked'
H0D70E4352A2A: '각 파일/그래프 이름을 연결될 경우/시에 나열하십시오'
# 'List ignored files.'
H1A394A6B07E1: '무시된 파일 목록을 표시합니다.'
# 'List of files with compilation or modularization problems for assistant mode.  This will be excluded.'
H7F26F6260A72: '컴파일 또는 모듈화 문제가 있는 파일 목록입니다. 이 파일들은 제외됩니다.'
# 'List of functions to print disassembly for. Accept demangled names only. Only work with show-disassembly-only'
H3054F37FF6EE: '디셈블리 출력을 위한 함수 목록입니다. 언마글된 이름만 허용합니다. show-disassembly-only와 함께만 작동합니다.'
# "List of key and value arguments. Required keywords are 'file' and 'triple'."
H45A6C5D3DB8C: "키와 값 인수의 목록입니다. 필수 키워드는 'file'과 'triple'입니다."
# 'List of modes to link in by default into XRay instrumented binaries.'
HA0397880FB9D: 'XRay 인스트루먼트된 바이너리에 기본으로 연결할 모드 목록.'
# 'List of profitability heuristics to be used. They are applied in the given order'
HA13A6720841E: '사용할 효익 휴리스틱 목록. 주어진 순서대로 적용됩니다'
# 'List of symbols to export from the resulting object file'
H1BA25E23CBFD: '결과 객체 파일로부터 수출할 기호 목록'
# 'Live DEBUG_VALUE analysis'
H61CCF64E7BF9: '활성 DEBUG_VALUE 분석'
# 'Live Interval Analysis'
H1E8AD554BB44: '활성 구간 분석'
# 'Live Range Shrink Pass'
H1774992DE87F: '활성 범위 축소 패스'
# 'Live Register Matrix'
H01100D0853E2: '활성 레지스터 행렬'
# 'Live Stack Slot Analysis'
H2C770BB0409B: '활성 스택 슬롯 분석'
# 'Live Variable Analysis'
HDDDE0A8181A8: '활성 변수 분석'
# 'Load MIR Sample Profile'
HE68192F483EE: 'MIR 샘플 프로파일 로드'
# 'Load a pch file and use it instead of all code up to and including <filename>'
H2B4B69D546AF: 'pch 파일을 로드하고 이를 모든 코드 대신 사용하며 <filename>까지 포함합니다'
# 'Load all members of static archives'
H37DC6D24F9AF: '정적 아카이브의 모든 멤버 로드'
# 'Load all members of static archives that implement Objective-C classes or categories, or Swift structs, classes or extensions'
HCC377DE628E7: '정적 아카이브에 포함된 Objective-C 클래스 또는 카테고리, Swift 구조체, 클래스 또는 확장을 구현하는 모든 멤버를 로드합니다'
# 'Load and verify that a pre-compiled header file is not stale'
H71047E98C4FB: '로드하고 미리 컴파일된 헤더 파일이 유효한지 검증합니다'
# 'Load dialects from plugin library'
H4452CA7D250C: '플러그인 라이브러리에서 디아LECTS 로드'
# 'Load module without materializing metadata, then materialize only the metadata'
H43A90C52B97C: '메타데이터 물리화 없이 모듈을 로드한 다음, 메타데이터만 물리화합니다.'
# 'Load pass plugin from a dynamic shared object file (only with new pass manager).'
HDC805E376CE5: '동적 공유 객체 파일에서 패스 플러그인을 로드(새 패스 매니저와 함께만).'
# 'Load passes from plugin library'
H8D748D07CDD6: '플러그인 라이브러리에서 패스 로드'
# 'Load shadow address into a local variable for each function'
HFDF300DF287B: '각 함수마다 로컬 변수에 샤도우 주소를 로드합니다'
# 'Load target address from GOT'
H9E377C7D35D0: 'GOT에서 대상 주소 로드'
# 'Load the clang builtins module map file.'
H593B89CC5BB8: 'clang builtins 모듈 맵 파일을 로드합니다.'
# 'Load the named plugin (dynamic shared object)'
HB2664DBBD1D2: '지정된 플러그인(동적 공유 객체)을 로드합니다.'
# 'Load the specified plugin'
H92708A3C1B95: '지정된 플러그인을 로드합니다'
# 'Load this module map file'
HF58B1913A1B8: '이 모듈 맵 파일을 로드합니다'
# 'Load top-level profiles that the sample reader initially skipped for the call-graph matching (only meaningful for extended binary format)'
H98AEC89E8CA3: '호출 그래프 일치를 위해 샘플 리더가 초기에 건너뛴 최상위 레벨 프로파일을 로드(확장된 이진 형식에만 적용됨)'
# 'Load, link and verify the resulting memory image.'
H9DA1560B06F8: '로드, 링크 및 생성된 메모리 영역 검증.'
# 'Load, link, and execute the inputs.'
H33C79A8E17E5: '입력 파일을 로드하고 연결한 다음 실행합니다.'
# 'Load, link, and print line information for each function using the debug object'
HD0FE71B40225: '디버그 객체를 사용하여 각 함수의 라인 정보를 로드, 연결, 그리고 출력합니다'
# 'Load, link, and print line information for each function.'
HD0F8E4BC3426: '각 함수에 대한 라인 정보를 로드하고, 링크하고, 출력합니다.'
# 'Local Stack Slot Allocation'
H9064C8611F98: '로컬 스택 슬롯 할당'
# 'Local reassignment can yield better allocation decisions, but may be compile time intensive'
HDA7A0257A39E: '지역 재할당은 더 나은 할당 결정을 내릴 수 있지만, 컴파일 시간에 많은 자원을 소모할 수 있습니다'
# 'Local strategy.'
H69F9DACD1EB4: '로컬 전략.'
# 'Locations and Variables'
HAAA0526E734E: '위치 및 변수'
# 'Locations only'
H997812E5B96A: '위치만'
# "Log action execution to a file, or stderr if  '-' is passed"
H7DDDF7706229: "작업 실행을 파일에 로그로 기록하거나 '-'가 전달되면 stderr로"
# 'Look up implicit modules in the prebuilt module path'
H7389FC31B294: '암시적 모듈을 미리 생성된 모듈 경로에서 찾기'
# 'LoongArch Assembly Printer'
H883C4FD99127: '로직아크 어셈블리 프린터'
# 'LoongArch DAG->DAG Pattern Instruction Selection'
HCE16825D2625: 'LoongArch DAG->DAG 패턴 명령어 선택'
# 'LoongArch Dead register definitions'
HAC29789F40DC: 'LoongArch 사용되지 않는 레지스터 정의'
# 'LoongArch Merge Base Offset'
H4ADCE551F44A: 'LoongArch 병합 기준 오프셋'
# 'LoongArch Optimize W Instructions'
HE6925B9D5E46: 'LoongArch W 명령어 최적화'
# 'LoongArch Pre-RA pseudo instruction expansion pass'
HABF2FA12711A: 'LoongArch Pre-RA 가짜 명령어 확장 패스'
# 'LoongArch atomic pseudo instruction expansion pass'
H9277CF038FA3: 'LoongArch 원자적 의사 명령어 확장 패스'
# 'Loop Data Prefetch'
H4A7486BE5EE1: '루프 데이터 프리페치'
# 'Loop Invariant Code Motion'
H1F7B4F47808C: '루프 불변 코드 이동'
# 'Loop Strength Reduction'
HD2B0D185F01F: '루프 벡터화'
# 'Loop Terminator Folding'
HA587F9DFACE9: '루프 종료자 폴딩'
# 'Loop over the snippet'
H8CE72D20104F: '스니펜트를 반복 처리합니다.'
# 'Loop rescheduling'
H3C5B4019E9D4: '루프 재순서화'
# 'Loop-Closed SSA Form Pass'
HA93B03345334: '루프-클로즈 SSA 형식 패스'
# "LoopVersioningLICM's minimum allowed percentage of possible invariant instructions per loop"
H9A2539A9680F: 'LoopVersioningLICM의 각 루프 당 가능한 불변 명령문의 허용되는 최소 퍼센트'
# "LoopVersioningLICM's threshold for maximum allowed loop nest/depth"
H17B01644371B: 'LoopVersioningLICM의 임계값: 허용되는 최대 루프 중첩/깊이'
# 'Loops with a constant trip count smaller than this value will not use the count register.'
H9C4270A71595: '상수 반복 횟수가 이 값보다 작은 루프는 카운트 레지스터를 사용하지 않습니다.'
# 'Loops with a constant trip count that is smaller than this value are vectorized only if no scalar iteration overheads are incurred.'
HEB5EC35573F1: '상수 반복 횟수가 이 값보다 작은 루프는 스칼라 반복 오버헤드가 발생하지 않을 경우에만 벡터화됩니다.'
# 'Low level details'
H736A60384473: '저수준 세부 정보'
# 'Lower @llvm.global_dtors via `__cxa_atexit`'
H38BCAF8DE61E: 'llvm.global_dtors를 __cxa_atexit를 통해 변환'
# 'Lower AArch64 MachineInstrs after legalization'
HAA249D8E7311: '합법화 후 AArch64 MachineInstrs 변환'
# 'Lower Alloca'
H607A1E54E99B: 'Alloca 변환'
# 'Lower GPU ctor / dtors to globals on the device.'
HAFC608781787: 'GPU 생성자/소멸자를 기기의 전역 변수로 변환합니다.'
# 'Lower MASSV entries'
HA1CC2E7E8DB7: 'MASSV 항목 변환'
# "Lower SwitchInst's to branches"
H254491D92394: 'SwitchInst를 분기문으로 변환'
# 'Lower Unreachable'
H28B0408D99E5: '불가능한 코드 변환'
# 'Lower aggregate copies, and llvm.mem* intrinsics into loops'
HF50CBF4651A2: '집합 복사 및 llvm.mem* 인트리니직을 루프로 변환'
# 'Lower all intrinsic procedure implementation in their own functions'
H898AB0478AF6: '각각의 함수에서 내재된 프로시저 구현을 모두 분리합니다'
# 'Lower allocations to fortran runtime calls'
H567EFB84A4D9: '할당을 Fortran 런타임 호출로 변환'
# 'Lower arguments (NVPTX)'
H0BEAE5323F8F: '인수 변환 (NVPTX)'
# 'Lower atomic intrinsics to non-atomic form'
H691AF9D6E735: '원자적 내재 함수를 비원자적 형태로 변환'
# 'Lower atomics of local memory to simple load/stores'
H26EEFC4DB3B1: '로컬 메모리의 원자적 연산을 단순한 load/stores로 변환'
# 'Lower bound for a buffer to be considered for stack protection'
HD34EE96BB584: '버퍼가 스택 보호 대상으로 고려되기 위한 하한 값'
# 'Lower ctors and dtors for AMDGPU'
HF7F8D40F075B: 'AMDGPU용 생성자 및 소멸자 변환'
# 'Lower ctors and dtors for NVPTX'
HFEBDC177145F: 'NVPTX를 위한 생성자 및 소멸자 하위 변환'
# 'Lower interleaved memory accesses to target specific intrinsics'
H47470ECDFD4E: '교차 메모리 접근을 타겟별 고유 인트린식으로 변환'
# 'Lower invoke and unwind, for unwindless code generators'
H0DB5191C7AE1: 'invoke 및 unwind 변환: unwindless 코드 생성기용'
# 'Lower kernel argument loads in IR pass'
H46087569AE6A: 'IR 패스에서 커널 인수 로드 최적화'
# 'Lower thread local variables'
HCFB0F36689FE: '스레드 로컬 변수 변환'
# 'Lower threshold (in bytes) for widening to HVX vectors'
H2F815B7CEA99: 'HVX 벡터로 확장하기 위한 바이트 단위의 하한 임계값'
# 'Lower to high level FIR'
H5AA0AFC0202E: '고수준 FIR로 변환'
# 'Lower uses of LDS variables from non-kernel functions'
H08631E6900A9: '커널 함수가 아닌 함수에서의 LDS 변수 사용을 기본 형식으로 변환'
# 'Lower variables reachable from one kernel, otherwise abort'
H53F0B2E74B9F: '하나의 커널에서 접근 가능한 변수를 하향 변환하고, 그렇지 않으면 종료합니다'
# 'Lower via HLFIR transformational intrinsic operations such as hlfir.sum'
H6FB7E3DD0B99: 'HFIR 변환 내재 연산을 통해 하위 수준으로 변환(예: hlfir.sum)'
# 'Lower via mixture of above strategies'
HC2846B7FC01C: '위의 전략들의 혼합을 통해 하향'
# 'Lower via module struct'
HA8D215D9A1DE: '모듈 구조체를 통해 하향'
# 'Lower via table lookup'
HDC139AA56721: '테이블 조회를 통해 변환'
# 'Lowers br_unless into inverted br_if'
H7B5FDAFDDAB0: 'br_unless를 반전된 br_if로 변환합니다'
# 'M68k Assembly Printer'
HC2BE99D7AAA9: 'M68k 어셈블리 프린터'
# 'M68k DAG->DAG Pattern Instruction Selection'
H81D40D6EAF4E: 'M68k DAG->DAG 패턴 명령 선택'
# 'M68k MOVEM collapser pass'
H0AB275B2A2C5: 'M68k MOVEM 결합 최적화 패스'
# 'M68k PIC Global Base Reg Initialization'
HD01B16D18C62: 'M68k PIC 전역 기본 레지스터 초기화'
# 'M68k pseudo instruction expansion pass'
H8C1C2FF3E960: 'M68k 의사 명령어 확장 패스'
# 'MC Options'
HF844BA7E67B9: 'MC 옵션'
# 'MCJIT'
H06F256016480: 'MCJIT'
# 'MIPS DAG->DAG Pattern Instruction Selection'
H4A85ADA9A35B: 'MIPS DAG->DAG 패턴 명령 선택'
# 'MIPS Specific: Compact branch policy.'
HDB7172F0C6EB: 'MIPS 특정: 컴팩트 분기 정책.'
# "MIPS: Don't trap on integer division by zero."
H3C2E18133FF5: 'MIPS: 정수 나누기에서 0으로 나눌 때 트랩하지 않음.'
# 'MIPS: Emit R_{MICRO}MIPS_JALR relocation with jalr'
HED32A15E03DE: 'MIPS: jalr를 사용하여 R_{MICRO}MIPS_JALR 재정렬 생성'
# 'MIPS: Expand all branches to long format.'
H441E04A7504F: 'MIPS: 모든 분기를 긴 형식으로 확장합니다.'
# 'MIPS: Skip branch expansion pass.'
HDA9370733E14: 'MIPS: 브랜치 확장 패스 건너뛰기.'
# 'MIPS: Try to allocate variables in the following sections if possible: .rodata, .sdata, .data .'
HE9B7319D8937: 'MIPS: 가능하면 다음 섹션에 변수를 할당하려고 합니다: .rodata, .sdata, .data.'
# 'MIPS: Use gp_rel for data that is not defined by the current object.'
HD75E517CA71E: 'MIPS: 현재 오브젝트에서 정의되지 않은 데이터에는 gp_rel을 사용하십시오.'
# 'MIPS: Use gp_rel for object-local data.'
H545674F997F2: 'MIPS: 객체 내부 데이터에 대해 gp_rel을 사용하십시오.'
# 'MIPS: permit tail calls.'
H0C7FED214ED3: 'MIPS: 꼬리 호출 허용.'
# 'MIR Printer'
H94EFB069787F: 'MIR 프린터'
# 'MISSED'
HD46F0E6CE802: '누락됨'
# 'MLIR CPU execution driver\n'
H6CE30C11490B: 'MLIR CPU 실행 드라이버\n'
# 'MLIR LSP Language Server'
HC4C223FFD5B8: 'MLIR LSP 언어 서버'
# 'MLIR test case query tool.\n'
H55F5673383F5: 'MLIR 테스트 케이스 질의 도구.\n'
# 'MLIR test case reduction tool.\n'
H51C59AF94F1B: 'MLIR 테스트 케이스 축소 도구.\n'
# 'MS-style inline assembly is not available: %0'
H730B2A8B0BD8: 'MS 스타일 인라인 어셈블리는 사용할 수 없습니다: %0'
# 'MSF Container Options'
H3C329400C4C7: 'MSF 컨테이너 옵션'
# 'MSF File Options'
H4EFCF40C1C07: 'MSF 파일 옵션'
# 'MSP430 Assembly Printer'
HCA8BC34B7977: 'MSP430 어셈블리 프린터'
# 'MSP430 DAG->DAG Pattern Instruction Selection'
H9B855DBB6F56: 'MSP430 DAG→DAG 패턴 기반 명령어 선택'
# 'MVE gather/scattering lowering pass'
HEFE04D3A4063: 'MVE 수집/분산 하향 변환 패스'
# 'MVE lane interleaving'
H439E688DEBCA: 'MVE 레인 교차'
# 'MVE tail-predication pass options'
H401525ED37E3: 'MVE 테일 예측정 패스 옵션'
# 'Mach-O: dump the raw contents of the listed segments instead of parsing them:'
HD2ADEEA8E714: 'Mach-O: 지정된 세그먼트의 원시 내용을 해석 대신 덤프합니다:'
# 'Machine Block Frequency Analysis'
H7E1FF2D34591: '머신 블록 빈도 분석'
# 'Machine Branch Probability Analysis'
HDAEAA64E78E7: '머신 브랜치 확률 분석'
# 'Machine CFG Printer Pass'
HEFF257D542EC: '머신 CFG 출력기 패스'
# 'Machine Check Debug Module'
H5340142C3573: '머신 체크 디버그 모듈'
# 'Machine Common Subexpression Elimination'
H4C5AC03D0280: '머신 공통 부분 표현 제거'
# 'Machine Copy Propagation Pass'
H4162739F0E51: '머신 복사 전파 패스'
# 'Machine Cycle Info Analysis'
H573F9920FA64: '기계 주기 정보 분석'
# 'Machine Debugify Module'
H1918B0E46C7D: '머신 디버깅 모듈'
# 'Machine Dominance Frontier Construction'
HACFFF417BF5C: '머신 도미넌스 프런티어 구성'
# 'Machine Function Outliner'
HEAF804C2398F: '머신 함수 아웃라인러'
# 'Machine Function Printer'
H5377EFCC5465: '머신 함수 프린터'
# 'Machine InstCombiner'
H33E9EB463E41: '머신 InstCombiner'
# 'Machine Instruction Scheduler'
H83994F7A225C: '머신 명령어 스케줄러'
# 'Machine Late Instructions Cleanup Pass'
H85C102FDCCD8: '머신 후기 지시문 정리 패스'
# 'Machine Loop Invariant Code Motion'
H4BBB4B53869D: '머신 루프 불변 코드 이동'
# 'Machine Module Information'
HD424C5585BBC: '머신 모듈 정보'
# 'Machine Natural Loop Construction'
H18E1BBE724BC: '머신 자연 루프 구조'
# 'Machine Sanitizer Binary Metadata'
H981195858AEF: '머신 산이저 바이너리 메타데이터'
# 'Machine Strip Debug Module'
HC906EF4D8D67: '머신 디버그 모듈 제거'
# 'Machine Trace Metrics'
HD6F5807E2725: '머신 추적 지표'
# 'Machine Uniformity Info Analysis'
HF8ED9A64EFA7: '머신 유니폼성 정보 분석'
# 'Machine code sinking'
H8D9C4D604139: '머신 코드 하강'
# 'Machine instruction scheduler to use'
H6D20879B4B16: '사용할 기계 명령어 스케줄러'
# 'MachineDominator Tree Construction'
H0EB86F56D320: '머신 도미네이터 트리 구축'
# 'MachineLICM should avoid speculation'
HA9CBAFDEBFAA: 'MachineLICM는 추측을 피해야 합니다'
# 'MachineLICM should hoist even cheap instructions'
H98697F2D8341: 'MachineLICM는 심지어 저렴한 명령문도 올려야 합니다'
# 'MachinePostDominator Tree Construction'
H556CF668A622: '머신 포스트 도미네이터 트리 생성'
# 'Main file name to use for debug info and source if missing'
H28B54D392A83: '디버그 정보 및 소스에 사용할 메인 파일 이름 (누락된 경우)'
# 'Make -gen-asm-parser emit assembly parser #N'
HE5BFEAE0A31B: '옵션 -gen-asm-parser로 어셈블리 파서 생성 #N'
# 'Make -gen-asm-writer emit assembly writer #N'
H1EC4E0DFB493: '어셈블리 작성기를 생성하도록 -gen-asm-writer 옵션을 사용합니다 #N'
# 'Make StdCall calling convention the default'
H597E577C2DF9: 'StdCall 호출 규약을 기본 값으로 설정합니다'
# 'Make all profile counter updates atomic (for testing only)'
HF170445DE3AF: '프로파일 카운터 업데이트를 모두 원자적으로 만듭니다 (테스트용으로만)'
# 'Make an absence of debug location information explicit.'
H9B828535ADE5: '디버그 위치 정보 부재를 명시적으로 표현합니다.'
# 'Make assembler not emit warnings'
HE1F052382E9E: '어셈블러가 경고를 출력하지 않도록 하기'
# 'Make assembler warnings fatal'
HE5A6B0140C8A: '어셈블러 경고를 치명적 오류로 만듭니다'
# 'Make char type unsigned'
H0811C60DAE54: 'char 형식을 부호없음으로 만듭니다'
# 'Make counter updates atomic'
HF0DF6FDD3F46: '카운터 업데이트를 원자적으로 만듭니다'
# 'Make small offsets be this amount for testing purposes'
HA8D9F86D01B4: '테스트 목적으로 작은 오프셋을 이 양으로 만듭니다'
# 'Make the jump table addresses canonical in the symbol table'
H96E8C8D2BE5D: '점프 테이블 주소를 심볼 테이블에서 표준화합니다'
# 'Make the x10 register call-saved (AArch64 only)'
HBF2D2B8AB5A7: 'x10 레지스터를 콜-세이브드로 설정합니다 (AArch64 전용)'
# 'Make the x11 register call-saved (AArch64 only)'
H361FBEA409F7: 'x11 레지스터를 호출 유지 레지스터로 지정합니다 (AArch64 전용)'
# 'Make the x12 register call-saved (AArch64 only)'
HC22300ADD634: 'x12 레지스터를 콜-세이브드로 지정합니다 (AArch64 전용)'
# 'Make the x13 register call-saved (AArch64 only)'
H115B747B671D: 'x13 레지스터를 call-saved로 지정합니다 (AArch64 전용)'
# 'Make the x14 register call-saved (AArch64 only)'
H3E53A0765B94: 'x14 레지스터를 호출 유지 레지스터로 지정(AArch64 전용)'
# 'Make the x15 register call-saved (AArch64 only)'
HBD1C266220AD: 'x15 레지스터를 호출 후 유지 레지스터로 지정 (AArch64 전용)'
# 'Make the x18 register call-saved (AArch64 only)'
HFB92CC39C02E: 'x18 레지스터를 call-saved로 지정합니다 (AArch64 전용)'
# 'Make the x8 register call-saved (AArch64 only)'
H346589ED29E7: 'x8 레지스터를 호출 후 유지 레지스터로 설정 (AArch64 전용)'
# 'Make the x9 register call-saved (AArch64 only)'
H2A86BF8B5845: 'x9 레지스터를 호출 유지 레지스터로 지정 (AArch64 전용)'
# 'Make time trace capture verbose event details (e.g. source filenames). This can increase the size of the output by 2-3 times'
HAFFB278A14B8: '시간 추적 캡처에 상세 이벤트 정보(예: 소스 파일 이름)를 포함합니다. 이 옵션은 출력 크기를 2-3배 증가시킬 수 있습니다'
# 'Mangling number exceeds limit (65535)'
HB23269E224B2: '이름 매꾸기 번호가 한계를 초과했습니다 (65535)'
# 'Manifest Attributor internal string attributes.'
H94BF7FE1AB16: '속성 부여자는 내부 문자열 속성을 명시합니다.'
# 'Manually specify the CUDA feature to use'
HDDA17BF1758B: '사용할 CUDA 기능을 수동으로 지정합니다'
# 'Map file source paths in debug info'
H1AD32AEEC75F: '디버그 정보에 소스 파일 경로 매핑'
# 'Mapping between default visibility and export'
H9B100E19B599: '기본 가시성과 export 간의 매핑'
# 'Margin representing the unused percentage of the register pressure limit'
HC98A7EB598BA: '레지스터 압력 제한의 미사용 비율을 나타내는 여유도'
# 'Mark <function> as being replaceable by the Windows kernel loader'
HE4564C872616: '<함수>를 Windows 커널 로더가 교체할 수 있도록 표시합니다'
# 'Mark code section jump table data regions.'
H820E75B4A88C: '코드 섹션 점프 테이블 데이터 영역을 표시합니다.'
# 'Mark cold functions with minsize.'
H17C76AA34906: '희귀 함수를 minsize로 표시합니다.'
# 'Mark cold functions with optnone.'
H16FE57B8D4DF: 'cold 함수를 optnone으로 지정합니다.'
# 'Mark cold functions with optsize.'
H10A3EEBA4167: 'optsize 속성으로 cold 함수를 지정합니다.'
# 'Mark intrinsics that match the specified regexp as taking alias.scopes, noalias, and tbaa metadata'
H2D0DBCB8116B: '지정된 정규식과 일치하는 인트린스틱들을 alias.scopes, noalias, 및 tbaa 메타데이터를 가지는 것으로 표시합니다'
# 'Mark intrinsics that match the specified regexp as taking an access group metadata'
HFCB2F343E2E0: '지정된 정규식과 일치하는 인트리니크를 액세스 그룹 메타데이터를 취하는 것으로 표시합니다'
# 'Mark outline function calls with ColdCC'
H4A447EEA400F: 'ColdCC로 아웃라인 함수 호출 표시'
# 'Mark some metadata features uncovered in functions with associated no_sanitize attributes.'
H04B3B3707DAA: '함수에 연관된 no_sanitize 속성과 관련된 메타데이터 기능 중 표시되지 않은 부분을 표시합니다.'
# 'Mark the file as not needing an executable stack'
H4B702846F054: '파일을 실행 가능한 스택이 필요하지 않다고 표시합니다'
# 'Marked up disassembly of strings of hex bytes'
HEACC40B7D059: '16진수 바이트 문자열의 표시된 디스어셈블리'
# 'Match allocation profiles onto existing hot/cold operator new calls'
H6EADDFEDDECF: 'hot/cold operator new 호출에 맞는 할당 프로파일 매칭'
# 'Match functions using namespace and edit distance'
HE4F3BAC888AB: '네임스페이스 및 편집 거리를 사용한 함수 일치'
# 'Match functions with call graph'
HBB25B5D67EE6: '호출 그래프와 일치하는 함수 찾기'
# 'Match profile with function hash'
H34EA8794C102: '프로필을 함수 해시와 일치시키기'
# 'Match string for rename'
HFCC0109CD543: '리네임을 위한 문자열 일치'
# 'Max #stores to inline memcpy'
HD503383C20D0: '인라인 memcpy에 사용할 최대 저장 연산 수'
# 'Max #stores to inline memmove'
HBA55FF5D30C1: '인라인 memmove에 대한 최대 저장 개수'
# 'Max #stores to inline memset'
H2710D6276878: '인라인 memset에 허용되는 최대 저장 횟수'
# 'Max PHIs in BB to duplicate for jump threading'
H877E847520D6: 'jump threading을 위한 기본 블록(BB) 내에서 복제할 최대 PHI 수'
# 'Max average trip count which will cause loop peeling.'
HF3BB048901AF: '루프 피닝을 유발하는 최대 평균 루프 실행 횟수.'
# 'Max block size to duplicate for jump threading'
HBFBAF7D2C906: '점프 스레딩을 위한 복제 최대 블록 크기'
# 'Max coefficients in AddRec during evolving'
H3496AC43AF41: '진화 중 AddRec의 최대 계수'
# 'Max count of stack frame shrink-wraps'
H837664B5CADB: '스택 프레임 축소 감싸기 최대 횟수'
# 'Max depth to recursively search for missing frames through tail calls.'
HF33980EA2977: '꼬리 호출을 통해 누락된 프레임을 재귀적으로 탐색하는 데 사용되는 최대 깊이.'
# 'Max integer bitwidth to consider in float2int(default=64)'
H564282CBC7AC: 'float2int에서 고려할 정수 비트폭 최대치(기본값=64)'
# 'Max num VGPRs for whole-wave register allocation.'
H7B8CA4EA95B5: '전체 웨이브 레지스터 할당을 위한 최대 VGPR 수'
# 'Max num uses visited for identifying load invariance in loop using invariant start (default = 8)'
H482EC7115683: '루프 내에서 불변 시작점을 사용하여 로드 불변식을 식별하기 위해 방문하는 최대 사용 횟수 (기본값 = 8)'
# 'Max number counter promotions per loop to avoid increasing register pressure too much'
H57369D9DCC7A: '각 루프 당 레지스터 압력을 너무 높이지 않기 위해 허용하는 카운터 프로모션의 최대 수량'
# 'Max number of BBs to explore for reachability analysis'
H59AE85966A2A: '도달 가능성 분석을 위해 탐색할 BBs의 최대 수'
# 'Max number of VRegs allowed to pass GC pointer meta args in'
HFCD4D70A5FD8: 'GC 포인터 메타 인수를 전달하기 위해 허용되는 VRegs의 최대 개수'
# 'Max number of address users to look at'
H5E86D74534B7: '확인할 주소 사용자의 최대 개수'
# 'Max number of allowed counter promotions'
H870A811CD7E4: '허용되는 카운터 프로모션의 최대 수'
# 'Max number of annotations for a single indirect call callsite'
HEA902A4CD336: '단일 간접 호출 콜사이트에 대한 주석의 최대 수'
# 'Max number of basic blocks on the path between hoisting locations (default = 4, unlimited = -1)'
H48EFC5F46396: 'hoisting 위치 사이 경로에 있는 기본 블록의 최대 개수 (기본값 = 4, 제한 없음 = -1)'
# 'Max number of blocks searched to find a threading path'
HF1261B57416B: '스레드 경로를 찾기 위해 검색된 블록 수의 최대값'
# 'Max number of blocks to be partially inlined'
H7AAFBCD2FD5C: '부분 인라인 될 수 있는 블록 수의 최대값'
# 'Max number of blocks visited while enumerating paths around a switch'
H3917E93C3F69: '스위치 주변 경로를 열거할 때 방문한 블록의 최대 수'
# "Max number of blocks we're willing to speculate on (and recurse into) when deducing if a value is fully available or not in GVN (default = 600)"
HCC0B004EA3EE: 'GVN에서 값이 완전히 사용 가능 여부를 추론할 때 추측하고 재귀적으로 탐색할 수 있는 블록의 최대 개수(기본값 = 600)'
# 'Max number of dependences to attempt Load PRE (default = 100)'
HAEF9EFC0D587: 'Load PRE를 시도하기 위한 최대 의존성 개수 (기본값 = 100)'
# 'Max number of devirtualizations for devirt module pass'
H37CF7FA70B53: 'devirt 모듈 패스에 대한 디버추얼라이제이션 최대 개수'
# 'Max number of duplications by CHR for a region'
HB5C21E0295E9: '영역당 CHR별 최대 중복 횟수'
# 'Max number of instructions to hoist (default unlimited = -1)'
H1E95E88763B1: 'hoist할 최대 명령어 수(기본값 무제한 = -1)'
# 'Max number of instructions to scan for aggressive instcombine.'
H5E9EDAFCAA29: '공격적 instcombine을 위해 스캔할 명령문의 최대 개수.'
# 'Max number of instructions to scan for vector combining.'
H596CAD742579: '벡터 결합을 위해 스캔할 명령문의 최대 개수.'
# 'Max number of instructions to scan in each basic block in GVN (default = 100)'
H8FA4F608C594: 'GVN 내에서 각 기본 블록당 스캔할 명령문의 최대 개수 (기본값 = 100)'
# 'Max number of iterations to be peeled from a loop, such that fusion can take place'
HA1B7957932D5: '반복문에서 결합이 가능하도록 분리할 최대 반복 횟수'
# 'Max number of iterations to prefetch ahead'
H74DE81E5BEDC: '최대 예치 이터레이션 수'
# 'Max number of memchecks allowed per eliminated load on average'
H929763545CE5: '평균적으로 제거된 로드당 허용된 메모리 체크의 최대 수'
# 'Max number of memory uses to explore during partial unswitching analysis'
H5E2B4A7FE9D0: '부분 unswitching 분석 중 탐색 시 메모리 사용 횟수의 최대 값'
# 'Max number of mux expansions'
H413CD17EDBFC: 'mux 확장의 최대 수'
# 'Max number of partial inlining. The default is unlimited'
HEF03ECFDE4EE: '부분 인라인의 최대 개수. 기본값은 제한 없음'
# 'Max number of paths enumerated around a switch'
H733A7744C96C: '스위치 주변에서 열거된 경로 최대 수'
# 'Max number of precise value annotations for a single memopintrinsic'
H43400B846308: '단일 memopintrinsic에 대한 정확한 값 주석의 최대 개수'
# 'Max number of predecessors to consider tail merging'
H077931C4B5A6: '꼬리 병합에 고려할 최대 이전 항목 수'
# 'Max number of promotions for a single indirect call callsite'
H1160EEB59410: '단일 간접 호출 호출 사이트당 프로모션의 최대 수'
# 'Max number of promotions for a single indirect call callsite in sample profile loader'
H05F78FEA2FAF: '샘플 프로파일 로더에서 단일 간접 호출 콜사이트에 대한 최대 프로모션 수'
# 'Max number of promotions for this compilation'
HBE53E07F67D3: '이 컴파일의 최대 프로모션 수'
# 'Max number of segment coalescings'
H76831528316D: '세그먼트 결합의 최대 개수'
# 'Max number of statepoints allowed to pass GC Ptrs in registers'
HBF13380980F5: '레지스터에 GC Ptrs를 전달할 수 있는 statepoints의 허용되는 최대 수'
# 'Max number of stores to be predicated behind an if.'
HC838F9655113: 'if 문 뒤에 조건부로 수행되는 스토어의 최대 개수'
# 'Max number of visited instructions when trying to find dominating value of select dependency (default = 100)'
H9E6FEA476B9C: '방문한 명령문의 최대 개수 (select 종속성의 지배적인 값 찾을 때, 기본값 = 100)'
# 'Max number of vtables annotated for a vtable load instruction.'
H1F81EEE11A92: 'vtable 로드 명령문에 대해 표시된 vtable의 최대 수.'
# 'Max results to display'
HB76D3DEE4518: '표시할 최대 결과 수'
# 'Max size of a block which is still considered small enough to thread through'
H36A8554A7A20: '블록이 여전히 스레드를 통해 전달하기에 충분히 작다고 판단되는 최대 크기'
# 'Max total number of preprocessed tokens for -Wmax-tokens.'
HC95A06179FBD: '프리프로세스된 토큰의 최대 총 개수(-Wmax-tokens용).'
# 'Maximal number of attributor iterations.'
HD46DDBA87859: '_ATTRIBUTOR_ITERATIONS의 최대 반복 횟수.'
# 'Maximal number of callees specialized for a call base'
HA4B29DB6599A: '특정 호출 기반에 특수화된 피호출자의 최대 개수'
# 'Maximal number of chained initializations (to avoid stack overflows)'
H907C6E291577: '연쇄 초기화의 최대 개수 (스택 오버플로우를 방지하기 위해)'
# 'Maximal number of fixpoint iterations.'
HD4791B6062DE: '최대 고정점 반복 횟수.'
# 'Maximal number of uses to explore.'
H3B80E7F90921: '탐색할 사용 횟수의 최댓값.'
# 'Maximize bandwidth when selecting vectorization factor which will be determined by the smallest type in loop.'
H1FD207584DE2: '벡터화 인자를 선택할 때, 이 인자가 루프 내 가장 작은 타입에 의해 결정되도록 하여 대역폭을 최대화합니다.'
# 'Maximize the band depth (yes/no)'
H16AE46F8C5D0: '밴드 깊이 최대화 (예/아니오)'
# 'Maximum SLP vectorization factor (0=unlimited)'
HFDC1B422DFB3: '최대 SLP 벡터화 계수 (0=제한 없음)'
# 'Maximum alloca size to use for inline cost'
H85D97309D239: '인라인 비용에 사용하기 위한 최대 alloca 크기'
# 'Maximum allowed iterations to unroll under pragma unroll full.'
H369A26E92574: 'pragma unroll full 지시문에서 언롤할 수 있는 최대 반복 횟수.'
# 'Maximum amount of memory to use. 0 disables check. Defaults to 400MB (800MB under valgrind, 0 with sanitizers).'
HD9F29E050069: '사용할 수 있는 최대 메모리 양입니다. 0을 지정하면 확인을 비활성화합니다. 기본값은 400MB(Valgrind에서는 800MB, sanitizers 사용 시 0)입니다.'
# 'Maximum amount of nodes to process while searching SCEVUnknown Phi strongly connected components'
H733D2DA20417: 'SCEVUnknown Φ 강결합 성분을 탐색하는 동안 처리할 노드의 최대 수'
# 'Maximum amount of shared memory to use.'
H87E40E4A881F: '사용할 수 있는 최대 공유 메모리 양.'
# 'Maximum array size considered when doing a combine'
HA910C2785634: '결합을 수행할 때 고려되는 최대 배열 크기'
# "Maximum block frequency, expressed as a percentage of caller's entry frequency, for a call site to be considered cold for enabling coldcc"
H39E2E109FC72: '콜 사이트가 coldcc 활성화를 위해 cold로 간주되려면, 호출자의 진입 빈도의 백분율로 표현된 최대 블록 빈도'
# "Maximum block frequency, expressed as a percentage of caller's entry frequency, for a callsite to be cold in the absence of profile information."
HDD8AD6EFCAAB: '프로파일 정보가 없는 경우 호출 사이트가 cold로 간주되도록, 호출자의 엔트리 빈도의 백분율로 표현된 최대 블록 빈도입니다.'
# 'Maximum byte size to consider promote alloca to vector'
HDC8E89EF71AD: 'alloca를 벡터로 승격하기 위해 고려하는 최대 바이트 크기'
# 'Maximum codesize growth allowed per function'
H78609FC7BCF8: '함수당 허용되는 최대 코드 사이즈 증가량'
# 'Maximum cost accepted for the transformation'
H83731968FC73: '변환에 허용되는 최대 비용'
# 'Maximum cost multiplier of TCC_expensive for the dependence slice of a cold operand to be considered inexpensive.'
H6DFC35CF6D50: 'TCC_expensive의 차가운 연산자의 의존성 슬라이스가 저렴한 것으로 간주되도록 하는 최대 비용 곱수.'
# 'Maximum cost of combining conditions when folding branches'
H781B5E7517C1: '분기 접기 시 조건 결합의 최대 비용'
# 'Maximum depth allowed for the recursive algorithm used to explore MIV direction vectors.'
H1A8D3D915439: 'MIV 방향 벡터를 탐색하기 위해 사용되는 재귀 알고리즘에 허용되는 최대 깊이'
# 'Maximum depth for recursive loop guard collection'
H30DB13FC6626: '재귀적 루프 가드 수집을 위한 최대 깊이'
# 'Maximum depth of loop nest considered for the transform'
HB49D9378BE58: '변환에 고려되는 중첩 루프의 최대 깊이'
# 'Maximum depth of recursive SCEV complexity comparisons'
H91C70931DE15: '재귀적 SCEV 복잡성 비교의 최대 깊이'
# 'Maximum depth of recursive SCEV operations implication analysis'
H11D5122A9F0A: '재귀적 SCEV 연산 함의 분석의 최대 깊이'
# 'Maximum depth of recursive SExt/ZExt/Trunc'
HC985D30DDFD4: '재귀적 SExt/ZExt/Trunc의 최대 깊이'
# 'Maximum depth of recursive arithmetics'
HAE0E4B668E3D: '재귀적 산술 연산의 최대 깊이'
# 'Maximum depth of recursive constant evolving'
H729F236B8A12: '재귀적 상수 진화의 최대 깊이'
# 'Maximum depth of recursive value complexity comparisons'
HF2B077915503: '재귀적 값 복잡성 비교의 최대 깊이'
# 'Maximum distance between a tfr feeding a store we consider the store still to be newifiable'
HA3A3AE754AA0: 'tfr이 저장소에 공급하는 최대 거리: 저장소가 여전히 newifiable하다고 간주하는 거리'
# 'Maximum distance of loop carried dependences that are handled'
HC5B916D346C8: '처리되는 루프 전달 종속성의 최대 거리'
# 'Maximum factor by which expected native size may increase before blocking any further inlining.'
H1A06B982376C: '인라인을 더 이상 허용하지 않기 전까지 예상 네이티브 크기가 증가할 수 있는 최대 배수.'
# 'Maximum factor for an interleaved access group (default = 8)'
HCB89C86317C6: '인터리브된 액세스 그룹의 최대 요인 (기본값 = 8)'
# 'Maximum frequency of path for an operand to be considered cold.'
H229E4B064589: '피연산자의 경로가 콜드로 간주되기 위한 최대 빈도.'
# 'Maximum global merge offset'
HDC72CED70E8A: '최대 전역 병합 오프셋'
# 'Maximum input DBG_VALUE insts supported by debug range extension'
H5626CEECD47D: '디버그 범위 확장 기능에 의해 지원되는 DBG_VALUE 명령문의 최대 입력 수'
# 'Maximum input basic blocks before DBG_VALUE limit applies'
H05C4A13D67D8: 'DBG_VALUE 제한 적용 전 최대 입력 기본 블록'
# 'Maximum instructions to analyze per moved initialization'
H28DB4399F2D2: '분석할 이동된 초기화 당 최대 명령문 수'
# 'Maximum instructions to consider tail duplicating'
H4A94E8A5FC9B: '꼬리 복제를 고려할 최대 명령문 수'
# 'Maximum instructions to consider tail duplicating blocks that end with indirect branches.'
H24A02DE8C7F1: '간접 분기로 끝나는 블록을 대상으로 꼬리 복제를 고려할 최대 명령문 수.'
# 'Maximum interleave factor for MVE VLDn to generate.'
H213FF805CEF2: 'MVE VLDn을 생성할 때 사용하는 최대 인터리브 계수.'
# 'Maximum length of a memory clause, instructions'
H7D54283EC716: '메모리 절 및 명령어의 최대 길이'
# 'Maximum length of dependent chains to hoist (default = 10, unlimited = -1)'
HC4AAAE7F5958: 'hoist할 수 있는 의존 체인의 최대 길이 (기본값 = 10, 무제한 = -1)'
# 'Maximum length of recurrence chain when evaluating the benefit of commuting operands'
H84087A27148D: '교환 연산자의 이점 평가 시 재귀 체인의 최대 길이'
# 'Maximum nesting level for parentheses, brackets, and braces'
H62138B784DC3: '괄호, 대괄호, 중괄호의 중첩 수준 최대 제한'
# 'Maximum num basic blocks before debug info dropped'
HF7FD1D6C6637: '디버그 정보가 삭제되기 전 기본 블록의 최대 개수'
# "Maximum number of 'operator->'s to call for a member access"
H2363B77A7D06: "멤버 접근 시 호출할 'operator->'의 최대 개수"
# 'Maximum number of BBs allowed in a function after inlining (compile time constraint)'
H02A0499B6C90: '인라인 후 함수당 허용되는 BB의 최대 수 (컴파일 타임 제약)'
# 'Maximum number of ISL operations to invest for known analysis; 0=no limit'
H1E380A641D89: '알려진 분석을 위해 할당할 ISL 연산의 최대 개수; 0=제한 없음'
# 'Maximum number of base-updates to check generating postindex.'
HA9EAB9913B99: 'postindex 생성을 확인하는 데 적용할 기초 업데이트의 최대 개수'
# 'Maximum number of basic blocks in a function to run ext-TSP block placement.'
HEAD0A5AFAB52: '함수에서 ext-TSP 블록 배치를 실행하기 위한 기본 블록의 최대 개수.'
# 'Maximum number of branches in the accumulator tree'
HE163718A2F82: '누산기 트리 내의 최대 가지 수'
# 'Maximum number of call targets per call site to enable branch funnels'
H2188104092EB: '각 호출 위치당 호출 대상의 최대 개수(브랜치 퓨너 활성화를 위해)'
# 'Maximum number of comparisons done when trying to merge runtime memory checks. (default = 100)'
H9FAF3F7149E1: '런타임 메모리 검사 병합을 시도할 때 수행되는 비교 횟수의 최대값 (기본값 = 100)'
# 'Maximum number of conditions in MC/DC coverage'
H6395D2BBFABE: 'MC/DC 커버리지에서의 조건 최대 개수'
# 'Maximum number of cycles in the timeline view, or 0 for unlimited. Defaults to 80 cycles'
H17E412044F75: '타임라인 뷰의 최대 사이클 수 또는 0을 입력하면 무제한입니다. 기본값은 80 사이클입니다'
# 'Maximum number of dataflow edges to traverse when evaluating the benefit of commuting operands'
H635DA15AA164: '연산자 순서 변경의 이점을 평가할 때 데이터 플로우 엣지를 탐색하는 최대 수'
# 'Maximum number of dependences collected by loop-access analysis (default = 100)'
H498CAFF81EAD: '루프 액세스 분석에 의해 수집된 종속성의 최대 개수 (기본값 = 100)'
# 'Maximum number of instruction to generate when lowering constant multiplication instead of calling library function [default=14]'
HA8EBACF52A9C: '상수 곱셈을 라이브러리 함수 호출 대신 변환할 때 생성할 최대 명령문 수 [기본값=14]'
# 'Maximum number of instructions for ObjectSizeOffsetVisitor to look at'
H87E9B845C1F1: 'ObjectSizeOffsetVisitor가 확인할 명령문의 최대 개수'
# 'Maximum number of instructions per speculated block.'
H9257791CBCD4: '예측 블록당 최대 명령문 수입니다.'
# 'Maximum number of isl operations to invest for lifetime analysis; 0=no limit'
HEF3BE03FC67D: '라이프타임 분석을 위해 수행할 수 있는 isl 연산의 최대 수; 0=제한 없음'
# 'Maximum number of iterations SCEV will symbolically execute a constant derived loop'
H2F35B8D580F6: 'SCEV가 기호적으로 실행할 상수 유래 루프의 반복 횟수의 최대 값'
# 'Maximum number of iterations to go through when propagating sample block/edge weights through the CFG.'
H76A911EDD837: 'CFG를 통해 표본 블록/엣지 가중치를 전파할 때 반복할 최대 횟수입니다.'
# 'Maximum number of iterations to print in timeline view'
H61122E3872D7: '타임라인 뷰에서 출력할 반복의 최대 개수'
# 'Maximum number of iterations we keep dismantling potential values.'
HACE4628A8A6D: '잠재적 값 분해를 계속하는 동안 유지하는 반복 횟수의 최대값.'
# 'Maximum number of load-store instructions that should be handled in the dependency matrix. Higher value may lead to more interchanges at the cost of compile-time'
HC041FD354820: '의존성 행렬에서 처리해야 하는 load-store 명령어의 최대 수입니다. 더 높은 값은 컴파일 시간을 희생하여 더 많은 교환이 발생할 수 있습니다'
# 'Maximum number of memory instructions to place in the same hard clause'
H0D0A665E7C31: '동일한 하드 절에 배치할 수 있는 최대 메모리 명령어 수입니다'
# 'Maximum number of parameters for a split function'
H21349A957046: '분할 함수의 최대 매개변수 개수'
# 'Maximum number of physical registers which can be used for register mappings'
HDA7C27C95D63: '레지스터 매핑에 사용 가능한 물리 레지스터의 최대 수'
# 'Maximum number of potential values to be tracked for each position.'
H955218AAB793: '각 위치에 대해 추적할 수 있는 가능한 값들의 최대 개수.'
# 'Maximum number of predicated jumps to be converted to New Value Jump'
HF3F6203AD570: 'New Value Jump으로 변환될 조건부 점프의 최대 개수'
# 'Maximum number of prefixes to use for padding'
H7458F00CCA26: '패딩에 사용할 접두사의 최대 개수'
# 'Maximum number of ptr states the optimizer keeps track of'
HB7E5E43FBE1D: '최적화 프로세스가 추적하는 포인터 상태의 최대 개수'
# 'Maximum number of replacements'
H6F2E3DB8E40F: '최대 대체 개수'
# "Maximum number of results to stream as a response to single request. Limit is to keep the server from being DOS'd. Defaults to 10000."
H8CFDD20881AA: '한 번의 요청에 대한 응답으로 스트리밍할 결과의 최대 수입니다. 이 제한은 서버가 DOS 공격을 받지 않도록 하기 위한 것이며, 기본값은 10000입니다.'
# 'Maximum number of rows to keep in constraint system'
H99BCC72F0CE0: '제약 시스템에 유지할 행의 최대 개수'
# 'Maximum number of simplification steps in HLIR'
H8BBD18037D20: 'HLIR 내 단순화 단계의 최대 개수'
# 'Maximum number of split partitions'
HFE60C6DE65ED: '분할 파티션의 최대 수'
# 'Maximum number of test vectors in MC/DC coverage'
HAFD4B8816F42: 'MC/DC 커버리지에서 테스트 벡터의 최대 개수'
# 'Maximum number of threads (for emulation thread-local storage)'
H0870E5A4F08E: '최대 스레드 수 (에뮬레이션용 스레드 로컬 스토리지)'
# 'Maximum number of threads to use to process chunks. Set to 1 to disable parallelism.'
H35B2504140C1: 'Chunks를 처리하기 위해 사용할 스레드의 최대 수. 병렬 처리를 비활성화하려면 1로 설정합니다.'
# 'Maximum number of times to run the full set of delta passes (default=5)'
H2DC8A9AE4C6B: '델타 패스 전체 세트를 실행하는 최대 횟수 (기본값=5)'
# 'Maximum number of undroppable users for instruction sinking'
H51772496A3DD: '명령문 침식을 위한 제거할 수 없는 사용 항목의 최대 개수'
# 'Maximum number phis to handle in intptr/ptrint folding'
H8EB042BFB02C: 'intptr/ptrint folding에서 처리할 phis의 최대 개수'
# 'Maximum of xors'
H1D5D83FA6AD6: 'xors의 최대값'
# 'Maximum optimization to perform'
HE99B191AFFD1: '실행할 최대 최적화 수준'
# 'Maximum predecessors (maximum successors at the same time) to consider tail duplicating blocks.'
HEA56889501D6: '꼬리 복제 블록을 고려할 때 고려할 최대 전신(동시 최대 후신)'
# 'Maximum recursion depth when finding forked SCEVs (default = 5)'
H0BFBD51E5518: '분기된 SCEV를 찾을 때의 최대 재귀 깊이 (기본값 = 5)'
# 'Maximum recursion level'
HE3B9BD0F99EA: '최대 재귀 깊이'
# 'Maximum search distance for definition of CR bit spill on ppc'
H3E64147E3DA7: 'ppc에서 CR 비트 스파일의 정의를 위한 최대 탐색 거리'
# 'Maximum size for the name of non-global values.'
HD0F170A76DAC: '비글로벌 값 이름의 최대 크기입니다.'
# 'Maximum size of ALL constants to promote into a constant pool'
H601F886CFD14: '상수 풀에 편입시키기 위한 모든 상수의 최대 크기'
# 'Maximum size of IFMap'
H36B1B6A77B2F: 'IFMap의 최대 크기'
# 'Maximum size of OrderedRegisterList'
H272C7A54D906: 'OrderedRegisterList의 최대 크기'
# 'Maximum size of constant to promote into a constant pool'
H64D76AF05D3E: '상수 풀로 승격할 상수의 최대 크기'
# "Maximum size of range check type for which can be produced runtime overflow check of its limit's computation"
H186E992A3695: '범위 검사 타입의 최대 크기, 해당 타입의 제한 계산에 대한 런타임 오버플로우 체크가 생성될 수 있는 경우'
# 'Maximum stages allowed in the generated scheduled.'
H48FD271D1F26: '생성된 스케줄에서 허용되는 최대 단계 수입니다.'
# 'Maximum successors (maximum predecessors at the same time) to consider tail duplicating blocks.'
H43B65927F125: '꼬리 복제 블록을 고려할 때 고려할 후속 노드(동시에 최대 이전 노드)의 최대 수'
# 'Maximum throughput from the decoders (instructions per cycle)'
H7563F8838724: '디코더의 최대 처리량 (사이클당 명령어 수)'
# 'Maximum time a channel may stay idle until server closes the connection, in seconds. Defaults to 480.'
HAA88BB6FEBEE: '서버가 연결을 종료할 때까지 채널이 비활성 상태로 머무를 수 있는 최대 시간(초 단위). Defaults to 480.'
# 'Maximum users to visit in copy from constant transform'
H0BCD40F173F6: '상수 변환에서 복사 중 방문할 최대 사용자 수'
# 'Maximum vector size (in 32b registers) to use when promoting alloca'
HBBF17E62FD6E: 'alloca를 승격할 때 사용할 최대 벡터 크기 (32비트 레지스터 기준)'
# 'May have atomic operations on fine-grained memory'
HADF7ECC58A34: '세분화된 메모리에서 원자 연산이 발생할 수 있습니다'
# 'May have atomic operations on remote memory'
H32B8F16B1079: '원격 메모리에 원자 연산이 있을 수 있습니다'
# 'Measure the parse tree'
HCE9EAC149D17: '문법 트리를 측정합니다'
# 'Medium code model'
H72290D3E5AED: '중형 코드 모델'
# 'MemProf memory access profile'
H1BF9427AF0C9: 'MemProf 메모리 접근 프로파일'
# 'Member.'
H2A50D724340B: '멤버입니다.'
# 'Memory Dependence Analysis'
H4CBD5FC4ABBF: '메모리 종속성 분석'
# 'Memory SSA'
H3A3FEB09FB66: '메모리 SSA'
# 'Memory reference level analysis that distinguish access instructions in the same statement'
H0AE95D83B775: '같은 문장 내에서 접근 명령문을 구분하는 메모리 참조 수준 분석'
# 'Memory reference level analysis that distinguish accessed references in the same statement'
H4E1E23E6B24B: '동일한 문에서 액세스된 참조를 구분하는 메모리 참조 레벨 분석'
# 'Merge all const globals without looking at uses'
H6449013A03CB: '사용 여부를 확인하지 않고 모든 const 글로벌 변수를 통합합니다'
# 'Merge and hoist M0 initializations'
H2D268DBDEF86: 'M0 초기화 통합 및 상향'
# 'Merge clones before assigning functions'
H18C7B017FA56: '함수 할당 전 클론 병합'
# 'Merge context profiles before calculating thresholds.'
H1C9DF3097EF8: '컨텍스트 프로파일을 계산하기 전에 병합해야 합니다.'
# 'Merge context sample profiles whose count is below cold threshold'
HC6C3845D54A1: '카운트가 저사용 임계값 미만인 컨텍스트 샘플 프로파일을 병합'
# 'Merge contiguous icmps into a memcmp'
H7D045C95D910: '연속된 icmp들을 memcmp로 병합'
# 'Merge disjoint stack slots'
HC48D29B2D11A: '이격된 스택 슬롯 병합'
# 'Merge global variables'
HBC9C437F360A: '전역 변수 병합'
# "Merge past inlinee's profile to outline version if sample profile loader decided not to inline a call site. It will only be enabled when top-down order of profile loading is enabled. "
H647C9F0ED977: '샘플 프로파일 로더가 호출 위치를 인라인하지 않기로 결정했을 경우, 이전 인라인 대상의 프로파일을 아웃라인 버전에 병합합니다. 이 기능은 프로파일 로딩의 상향식 순서가 활성화되었을 때만 활성화됩니다.'
# 'Merge the given AST file into the translation unit being compiled.'
H044732F67319: '지정된 AST 파일을 컴파일 중인 번역 단위에 병합합니다.'
# "Method to generate ID's for compilation units for single source offloading languages CUDA and HIP: 'hash' (ID's generated by hashing file path and command line options) | 'random' (ID's generated as random numbers) | 'none' (disabled). Default is 'hash'. This option will be overridden by option '-cuid=[ID]' if it is specified."
HF56CB8DC51CB: "CUDA 및 HIP와 같은 단일 소스 오프로딩 언어를 위한 컴파일 단위 ID 생성 방법: 'hash' (파일 경로와 옵션을 해싱하여 생성) | 'random' (랜덤 수를 사용) | 'none' (비활성화). 기본값은 'hash'입니다. '-cuid=[ID]' 옵션이 지정되면 이 옵션이 무시됩니다."
# 'MicroMips instruction size reduce pass'
H43AA98943979: 'MicroMips 명령어 크기 줄이기 패스'
# "Microsoft compiler version number to report in _MSC_VER (0 = don't define it (default))"
H84908CA49591: '보고할 Microsoft 컴파일러 버전 번호 (0 = 정의하지 않음 (기본값))'
# 'Middle half duplicate mode'
H18C80D21224E: '중간 반 중복 모드'
# 'Middle half loop mode'
H43135A085735: '중간 반 루프 모드'
# 'Min number of instructions to consider tail merging'
HCFE1247214B4: '꼬리 병합을 고려하기 위한 최소 명령문 수'
# 'Min percent of cold bytes at a callsite to discard non-cold contexts'
HF5E8027EF436: '호출 지점에서 비-콜드 컨텍스트를 폐기하기 위한 콜드 바이트의 최소 비율입니다'
# 'Min percent of cold bytes matched to hint allocation cold'
HF5A0792EF995: '힌트 할당 cold에 매칭된 차가운 바이트의 최소 백분율'
# 'Min percent of cold bytes to hint alloc cold during cloning'
H30A19A7158C7: '복제 중에 alloc cold를 암시할 때 cold bytes의 최소 퍼센트'
# 'Min percent of max cold bytes for critical cold context'
HC9060B18CE7F: '중요한 콜드 컨텍스트를 위한 최대 콜드 바이트의 최소 비율입니다'
# 'Min stride to add prefetches'
H9E2620BA9D60: '최소 스트라이드에 PREFETCH 추가'
# 'MinGW specific. Disable support for automatic dllimport in code generation and linking'
H3256426D82B0: 'MinGW 특정 옵션입니다. 코드 생성 및 링킹 시 자동 dllimport 지원을 비활성화합니다'
# 'MinGW specific. Enable code generation support for automatic dllimport, and enable support for it in the linker. Enabled by default.'
H2BCAB89FF663: 'MinGW 전용. 자동 dllimport를 위한 코드 생성 지원을 활성화하고, 링커에서도 해당 지원을 활성화합니다. 기본값으로 활성화됩니다.'
# 'MinInstrCount strategy.'
H611D13E20CE8: 'MinInstrCount 전략.'
# 'Minimal Transform dialect driver\n'
H4CF75EEC17A9: '최소 변환 디아лект 드라이버\n'
# 'Minimal common base load/store instructions triggering DS/DQ form preparation'
H0EEF17599CF6: 'DS/DQ 형식 준비를触发하는 최소 공통 기반 로드/스토어 명령문'
# 'Minimal common base load/store instructions triggering chain commoning preparation. Must be not smaller than 4'
H8810625AE483: '최소 공통 기반 로드/스토어 명령문은 체인 공통화 준비를 유발합니다. 값은 4보다 작을 수 없습니다'
# 'Minimize AVX to SSE transition penalty'
H8DBDD3BC94CA: 'AVX에서 SSE로 전환 시 패널티 최소화'
# 'Minimize number of registers used'
H4957842A8433: '사용된 레지스터 수를 최소화합니다'
# 'Minimum BranchProbability to consider a region cold.'
HD5C5EDF501D8: '특정 영역을 cold로 간주하기 위한 최소 BranchProbability 값입니다.'
# 'Minimum block executions to consider its BranchProbabilityInfo valid'
HC699EC9E0880: 'BranchProbabilityInfo가 유효한 것으로 간주하기 위한 최소 블록 실행 횟수'
# "Minimum block frequency, expressed as a multiple of caller's entry frequency, for a callsite to be hot in the absence of profile information."
H7B3632E358D5: '프로파일 정보가 없는 경우 콜 사이트가 hot으로 간주되도록, 호출자의 진입 빈도의 배수로 표현된 최소 블록 빈도입니다.'
# 'Minimum density for building a jump table in a normal function'
H0D43760047E0: '일반 함수에서 점프 테이블을 구축하기 위한 최소 밀도'
# 'Minimum density for building a jump table in an optsize function'
H6EFB80EE1C35: 'optsize 함수 내에서 점프 테이블을 생성하기 위한 최소 밀도'
# 'Minimum depth of loop nest considered for the transform'
H277B1F275C2D: '변환에 고려되는 루프 네스트의 최소 깊이'
# 'Minimum distance between predicate definition and farther of the two predicated uses'
HBAA80BA0F268: '두 조건 적용된 사용 중 더 먼 위치와 예측자 정의 사이의 최소 거리'
# 'Minimum gain per loop (in cycles) threshold.'
H563FE7251C8B: '루프당 최소 이득 (클럭 사이클 단위) 임계값.'
# 'Minimum length of accumulator chains required for the optimization to kick in'
HE6E58DA8C268: '최적화가 적용되기 위해 필요한 누산기 체인의 최소 길이'
# 'Minimum number of extenders to trigger replacement'
HA7EB99ED5DCC: '대체를触발하기 위해 필요한 확장 항목의 최소 개수'
# 'Minimum number of similar functions with the same hash required for merging.'
H332DB9D9B554: '병합을 위해 필요한 동일한 해시를 가진 유사한 함수들의 최소 수.'
# 'Minimum number of times a block must be executed to be retained.'
H78B91828296F: '블록이 유지되기 위해 실행되어야 하는 최소 횟수입니다.'
# "Minimum priority, runs on idle CPUs. May leave 'performance' cores unused."
H2308F82368EA: "최소 우선순위로, 아이들 상태 CPU에서 실행됩니다. '성능' 코어가 사용되지 않을 수 있습니다."
# "Minimum profile count required for an optimization remark to be output. Use 'auto' to apply the threshold from profile summary"
H3D2B4D99467F: "최적화 주석을 출력하기 위해 필요한 프로파일 카운트의 최솟값입니다. 'auto'를 사용하여 프로파일 요약에서 임계값을 적용할 수 있습니다"
# "Minimum profile count required for an optimization remark to be output. Use 'auto' to apply the threshold from profile summary."
H05750FA1DE8F: "최적화 메모를 출력하기 위해 필요한 최소 프로파일 카운트 값입니다. 'auto'를 사용하면 프로파일 요약의 임계값을 적용할 수 있습니다."
# 'Minimum ratio comparing relative sizes of each outline candidate and original function'
H4C5E36FE2F68: '각 아웃라인 후보와 원본 함수의 상대 크기를 비교한 최소 비율'
# 'Minimum relative gain per loop threshold (1/X). Defaults to 12.5%'
H2DECB545864A: '루프 당 최소 상대적 이득 임계값 (1/X). 기본값은 12.5%입니다.'
# 'Minimum time granularity (in microseconds) traced by time profiler'
H82ABB54FDFA0: '시간 프로파일러가 추적하는 최소 시간 단위 (마이크로초)'
# 'Minimum type size in bits for breaking large PHI nodes'
HB05B1AF899B8: 'PHI 노드를 분할하기 위한 비트 단위의 최소 타입 크기'
# 'Mips Assembly Printer'
H033FCF512C08: 'Mips 어셈블리 프린터'
# 'Mips VR4300 mulmul bugfix'
HBC6DCC9857CF: 'Mips VR4300 mulmul 버그 수정'
# 'Miscellaneous Options'
HE9A41E28CF82: '기타 옵션'
# 'Missing debug location (gaps).'
HCFAF9A1705D6: '디버그 위치 누락 (구간).'
# 'Mode for reading thread pointer'
H56EB4841FF26: '쓰레드 포인터 읽기 모드'
# 'Mode of the RegBankSelect pass'
HC6D74CC5D13F: 'RegBankSelect 패스의 모드'
# 'Model read-only scalar values in the scop description'
HEF37BBE0A859: 'scop 설명에서 읽기 전용 스칼라 값을 모델링합니다'
# 'Model the cost of loop rotation more precisely by using profile data.'
H5615ACF94C6A: '프로파일 데이터를 사용하여 루프 회전의 비용을 더 정확하게 모델링합니다.'
# 'Modextract Options'
H29E9EFFE5231: 'Modextract 옵션'
# 'Module & File Options'
HDFC5298823CB: '모듈 및 파일 옵션'
# 'Module Options'
H15D7561EF70B: '모듈 옵션'
# 'Module Summary Analysis'
H35F5D0BFCE0A: '모듈 요약 분석'
# 'Module Verifier'
HB268B018B769: '모듈 검증기'
# 'Module concatenation'
H521219EE1D9E: '모듈 연결'
# 'Module extractor'
HDE0289089F3A: '모듈 추출기'
# 'Module summary index filename'
H3224F1E17512: '모듈 요약 색인 파일 이름'
# 'Module summary info'
HCFDC7E39A72C: '모듈 요약 정보'
# 'Module.'
H9EC9858FCED5: '모듈입니다'
# 'Modulo Schedule test pass'
H9F5185006F74: '모듈로 스케줄링 테스트 패스'
# 'Modulo Software Pipelining'
HC40B97D6B9FA: 'Modulo 소프트웨어 파이프라인'
# 'Move ARGUMENT instructions for WebAssembly'
H688758DE208F: 'WebAssembly용 ARGUMENT 명령어 이동'
# 'Move contextual profiling roots and the graphs under them in their own module.'
HC78C448BC37B: '컨텍스트 프로파일 루트와 그 아래의 그래프를 해당 모듈로 이동'
# 'Move the symbols with the given name. This will delete these symbols wherever they are originally defined, and make sure their linkage is External where they are imported. It is meant to be used with the name of contextual profiling roots.'
H50A29B7AC907: '지정된 이름의 심볼을 이동합니다. 이는 원래 정의된 모든 위치에서 해당 심볼을 삭제하고, 가져온 곳에서 외부 연결(External)이 되도록 합니다. 컨텍스트 프로파일 루트 이름과 함께 사용해야 합니다.'
# 'Move/duplicate certain instructions close to their use'
HD38286726698: '특정 명령문들을 그 사용 위치 근처로 이동/복제합니다'
# 'Multiplier to apply to threshold when determining whether or not to fold branch to common destination when vector operations are present'
HC6051096B6ED: '벡터 연산이 있을 경우 공통 목적지로 브랜치를 접어들지 여부를 결정할 때閾値에 적용할 계수'
# 'Multiplier to bump up callsite threshold for previous inlining.'
H80636EF6462B: '이전 인라인의 호출 위치 임계값을 증가시키는 계수'
# 'Multiplier to multiply cycle savings by during inlining'
H1D068428F9A5: '인라인 중 사이클 절약량을 곱할 곱셈자'
# 'Multiply the `import-instr-limit` threshold for cold callsites'
HC6AF6BE5F0E1: '콜드 콜사이트에 대한 `import-instr-limit` 임계값을 곱합니다'
# 'Multiply the `import-instr-limit` threshold for critical callsites'
HA6A6A6EE28A9: '중요한 호출 위치의 `import-instr-limit` 임계값을 증가시킵니다'
# 'Multiply the `import-instr-limit` threshold for hot callsites'
H4850606E5CF1: '뜨거운 콜사이트에 대한 `import-instr-limit` 임계값을 곱합니다'
# 'Must specify at least '
HEC0DF6B1AD3C: '적어도 '
# 'My Pass Name'
H68A400666676: '내 Pass 이름'
# 'N must be a power of two. Align loops to the boundary'
H2A7AB317ED00: 'N은 2의 제곱수여야 합니다. 루프를 경계에 맞춰 정렬해야 합니다'
# 'NVPTX Address space based Alias Analysis'
H9D1213E22820: 'NVPTX 주소 공간 기반 별칭 분석'
# 'NVPTX Address space based Alias Analysis Wrapper'
HB227AE568CB7: 'NVPTX 주소 공간 기반 별칭 분석 래퍼'
# 'NVPTX Assembly Printer'
H0111C7243DC7: 'NVPTX 어셈블리 프린터'
# 'NVPTX DAG->DAG Pattern Instruction Selection'
HB23F4D978D1F: 'NVPTX DAG->DAG 패턴 기반 명령어 선택'
# 'NVPTX Forward Params'
H3B9CC422F869: 'NVPTX 포워드 파라미터'
# 'NVPTX Peephole'
H5BF795D76A44: 'NVPTX 피히홀 최적화'
# 'NVPTX ProxyReg Erasure'
HDFA70554F191: 'NVPTX 프록시 레지스터 제거'
# 'NVPTX Specific: 0 use sqrt.approx, 1 use sqrt.rn.'
H11B08A79FA4D: 'NVPTX 특정: 0을 지정하면 sqrt.approx 사용, 1을 지정하면 sqrt.rn 사용.'
# 'NVPTX Specific: Disable generation of f16 math ops.'
HDAF968D22832: 'NVPTX 특정: f16 수학 연산의 생성을 비활성화합니다.'
# "NVPTX Specific: FMA contraction (0: don't do it 1: do it  2: do it aggressively"
HD36FDD8676CA: 'NVPTX 특정: FMA 축약 (0: 안 함 1: 적용 2: 적극적으로 적용)'
# 'NVPTX Specific: Override the precision of the lowering for f32 fdiv'
H1927850A3B01: 'NVPTX 특정: f32 fdiv 변환 시 정밀도 재정의'
# 'NVPTX Specific: force 4-byte minimal alignment for byval params of device functions.'
H40664A3C3B0F: 'NVPTX 특정: 디바이스 함수의 byval 매개변수에 대해 4바이트 최소 정렬을 강제.'
# 'NVPTX Specific: schedule for register pressue'
H0940771EECAF: 'NVPTX 특수: 레지스터 프레셔를 위한 스케줄'
# 'NVPTX Specific: whether to use lg2.approx for log2'
HDC539A3BEBE1: 'NVPTX 특정 옵션: log2에 대해 lg2.approx를 사용할지 여부'
# 'NVPTX Tag Invariant Loads'
HB8013F653097: 'NVPTX 불변 로드 태그'
# 'NVPTX target requires CUDA 9.2 or above; CUDA %0 detected'
HC81CA29CBF97: 'NVPTX 타겟은 CUDA 9.2 이상이 필요합니다; CUDA %0이 감지되었습니다'
# 'NVVM reflection, enabled by default'
H0FD65ACF0E14: 'NVVM 반사, 기본적으로 활성화됨'
# 'Name for native GCC compiler'
H0AD88C41A101: '네이티브 GCC 컴파일러 이름'
# 'Name for the section containing cold functions extracted by hot-cold splitting.'
H350954655BC3: '핫-콜드 분할을 통해 추출된 콜드 함수가 포함된 섹션의 이름입니다.'
# 'Name of checks to match against'
HAD04C40729DF: '매칭할 검사 항목의 이름'
# 'Name of op to match on'
H9F76B5F57ED0: '-Wno-unnamed-type-template-args 옵션을 사용하여 이 경고를 비활성화할 수 있습니다'
# 'Name of project.'
HD47E84631ECF: '프로젝트 이름.'
# 'Name of the entry point transform symbol'
H9FE29477F41B: '진입 지점 변환 심볼의 이름'
# 'Name of the interesting-ness test to be run'
H01AA1C566B65: '실행할 흥미도 테스트의 이름'
# 'Name of the macro to be defined'
H74E9FD90F24A: '정의할 매크로의 이름'
# 'Name of the macro to be defined -- ignored by mlir-pdll'
H03D44F059B30: '정의할 매크로의 이름 -- mlir-pdll에 의해 무시됨'
# 'Name of the macro to be defined -- ignored by mlir-src-sharder'
H3F90161CF695: '정의할 매크로의 이름 -- mlir-src-sharder에 의해 무시됨'
# 'Name of the split dwarf debug info file to encode in the object file'
HCFEFDA365E00: '객체 파일에 인코딩할 분할 DWARF 디버그 정보 파일의 이름'
# 'Namespace.'
HD451EBBFFEAD: '네임스페이스.'
# 'Narrow LSR complex solution using expectation of registers number'
H13DBBF2C516C: '레지스터 수의 기대값을 사용한 LSR 복잡한 해결책 축소'
# 'Narrow LSR search space by filtering non-optimal formulae with the same ScaledReg and Scale'
HBD4BDD760DFA: '동일한 ScaledReg 및 Scale을 가진 비최적 공식을 필터링하여 LSR 검색 공간을 축소합니다'
# 'Nary reassociation'
HAC5287C54D8E: 'N항 재결합'
# 'Natural Loop Information'
HB731CE00868C: '자연 루프 정보'
# 'Neon vector size must be 64 or 128 bits'
H97DBFE49CD6B: 'Neon 벡터 크기는 64 또는 128 비트여야 합니다'
# 'Nested profile, the input should be CS flat profile'
HA55917D514EC: '중첩된 프로파일입니다. 입력은 CS 플랫 프로파일이어야 합니다.'
# 'Never'
H80C3052D33CC: '미결'
# 'Never Step Into.'
HA04C48D1B790: '들어가지 않음.'
# 'Never detect stack use after return.'
HC4D92AB5F1A8: '함수 리턴 후 스택 사용을 절대 감지하지 않습니다.'
# 'Never dump input'
H182384737343: '입력 데이터를 절대로 덤프하지 않음'
# 'Never emit tail calls'
H295822EA6C7C: '꼬리 호출을 절대 생성하지 않음'
# 'Never insert #include directives as part of code completion'
H6893E7F599D8: '코드 완성 시 #include 지시문을 절대 삽입하지 마십시오'
# 'Never set the bit'
H77A3923DD75B: '비트를 절대로 설정하지 마십시오.'
# 'Never track the overflow bit.'
HF22B430EF914: '오버플로우 비트를 절대 추적하지 마십시오.'
# 'New FS discriminators encoding (incompatible with the original encoding)'
H525B7044D16E: '새로운 FS 구분자 인코딩 (기존 인코딩과 호환되지 않음)'
# 'New namespace.'
H7E03703F3B39: '새 네임스페이스입니다.'
# 'New statement.'
HBA1639E60F46: '새 문장입니다.'
# 'No Vectorization'
H1F3B2817613C: '벡터화 안 함'
# 'No action'
HF34AC77F7E82: '동작 없음'
# 'No checking'
H4F955C5DB2D5: '체크하지 않음'
# 'No code generation'
H3AC7DD01B6EE: '코드 생성 없음'
# 'No compression'
HB3E344B2C4BB: '압축 없음'
# 'No constructors'
HAD09B30D8B5D: '생성자가 없습니다'
# 'No destructors'
H24AE7DC3B6A4: '소멸자가 없습니다'
# 'No effect'
H7ED12CB7B709: '영향 없음'
# 'No extract instruction with offset 0'
HEB2933468549: '0 오프셋을 가진 extract 명령어가 없습니다'
# 'No implicit externals allowed'
H6CDA41F7B635: '암시적 외부 선언은 허용되지 않습니다'
# 'No implicit typing allowed unless overridden by IMPLICIT statements'
HA46325FCDDD6: 'IMPLICIT 문으로 덮어쓰어지지 않는 한 암시적 타이핑은 허용되지 않습니다'
# 'No offloading entry generated while offloading is mandatory.'
H4E35CC32EE7C: '오프로딩이 필수인 경우 오프로딩 엔트리가 생성되지 않았습니다.'
# 'No optimizer'
HF1ED527BC3E1: '최적화기 없음'
# 'No profile correlation'
H7B0904A6A54F: '프로파일 상관관계가 없습니다'
# 'No speculation'
H4F7A24022364: '추측 없음'
# 'No vector functions library'
H42FA0B1EA03D: '벡터 함수 라이브러리가 없습니다'
# 'No verification'
H41C637F6055E: '검증 없음'
# 'Non-relocatable code'
H9A85EA682847: '재배치 불가능한 코드'
# 'None.'
H9A9707BE07DA: 'None.'
# 'Normalize integers in CFI indirect call type signature checks'
H47F05B50721C: 'CFI 간접 호출 타입 서명 검사에서 정수를 정규화합니다'
# "Not emit the visibility attribute for asm in AIX OS or give all symbols 'unspecified' visibility in XCOFF object file"
H98251062C447: "AIX OS에서 asm에 대한 가시성 속성을 생성하지 않거나 XCOFF 객체 파일의 모든 심볼에 '지정되지 않음' 가시성을 부여합니다"
# 'Number limit for gluing ld/st of memcpy.'
HD8077326B9B0: 'memcpy의 ld/st 결합을 위한 숫자 제한.'
# 'Number of addresses from which to enable MIMG NSA.'
HCE8A8E1997D3: '활성화하기 위해 사용할 주소의 수 (MIMG NSA를 위한).'
# 'Number of backend threads'
HE56514D09150: '백엔드 스레드 수'
# "Number of blocks in the 'x' dimension"
H76CD51A21746: '‘x’ 차원의 블록 수'
# "Number of blocks in the 'y' dimension"
H6D16D2BE9F69: 'y 차원의 블록 수'
# "Number of blocks in the 'z' dimension"
H2E857E7750A0: "'z' 차원의 블록 수"
# 'Number of compile threads'
H083DE0C34AB1: '컴파일 스레드 수'
# 'Number of cycles to assume for a call instruction'
H48B171D665C7: '콜 명령문에 대한 가정값으로 사용할 사이클 수'
# 'Number of entries in the micro-op queue'
H6A848E9631B1: '마이크로-오퍼 큐의 항목 수'
# 'Number of instructions to allow ahead of the critical path in sched=list-ilp'
H6B314605368E: 'sched=list-ilp에서 크리티컬 경로 전방에 허용할 지시문의 수'
# 'Number of instructions to prefetch ahead'
HF2FFA16038B4: '프리패치할 명령문의 수'
# 'Number of interferences after which we declare an interference unevictable and bail out. This is a compilation cost-saving consideration. To disable, pass a very large number.'
H7D7A199C7C69: '간섭 횟수가 일정 수준에 도달하면 추방할 수 없는 간섭으로 판단하고 작업을 중단합니다. 이는 컴파일 비용을 절감하기 위한 조치입니다. 비활성화하려면 매우 큰 수를 전달하세요.'
# 'Number of intervals to track'
HB4B7D2AC3D9C: '추적할 구간 수'
# 'Number of iterations to run'
HE50757CD0D43: '실행할 반복 횟수'
# 'Number of materialization threads to use'
H7A97C7DA89FF: '사용할 materialization 스레드의 수'
# 'Number of merge threads to use (default: autodetect)'
H2EA5A0F7B460: '병합 스레드의 수 (기본값: 자동 감지)'
# 'Number of metadatas above which we emit an index to enable lazy-loading'
H4896D21A9235: '메타데이터의 수가 이 값 이상일 때 지연 로딩을 활성화하기 위해 인덱스를 생성합니다'
# 'Number of output files'
H5DDB526BD36F: '출력 파일의 수'
# 'Number of partitions to use for parallel full LTO codegen, ld.lld only.'
HEC293753B227: '병렬 완전 LTO 코드 생성에 사용할 파티션 수, ld.lld에만 적용.'
# 'Number of registers to limit to when printing regmask operands in IR dumps. unlimited = -1'
H0373C047E939: 'IR 덤프에서 regmask 오퍼랜드를 출력할 때 제한할 레지스터 수입니다. 무제한은 -1입니다.'
# 'Number of seconds program is allowed to run before it is killed (default is 300s), 0 disables timeout'
HE6EB2161F536: '프로세스가 종료되기 전까지 허용되는 실행 시간(초) (기본값은 300초), 0은 타임아웃을 비활성화합니다'
# "Number of threads in the 'x' dimension"
H07DD57A90CC5: "'x' 차원의 쓰레드 수"
# "Number of threads in the 'y' dimension"
H986B3D9F34E9: 'y 차원의 스레드 수'
# "Number of threads in the 'z' dimension"
HFC9646CFE097: "'z' 차원의 스레드 수"
# 'Number of threads to use (0 = auto)'
H9A06154F2AD2: '사용할 스레드 수 (0 = auto)'
# 'Number of times to divide chunks prior to first test'
H4AB8A9674250: '첫 번째 테스트 이전에 조각을 나누는 횟수'
# 'Number of times to rerun the outliner after the initial outline'
H45429D789C93: '초기 아웃라인 이후 아웃라인러를 재실행하는 횟수'
# 'Number of times to shuffle and verify use-lists'
HEBDA566F30F3: 'use-list를 섞고 검증하는 횟수'
# 'Number of tracked SGPRs before initiating hazard cull on memory wait'
H34DB613CB239: '메모리 대기 시 해저드 제거를 시작하기 전 추적된 SGPR의 수'
# "Number of triangle-shaped-CFG's that need to be in a row for the triangle tail duplication heuristic to kick in. 0 to disable."
HAF152F5B6E3F: '삼각 꼬리 복제 휴리스틱이 작동하도록 하기 위해 연속적으로 있어야 하는 삼각형 형태의 CFG의 수입니다. 0을 지정하면 비활성화됩니다.'
# 'Number of unswitch candidates that are ignored when calculating cost multiplier.'
H4873CA41A98E: '비용 곱셈 계수를 계산할 때 무시된 unswitch 후보의 개수.'
# 'Number of uses of a base pointer to check before it is no longer considered for post-indexing.'
H02421600E168: '기반 포인터의 사용 횟수를 확인하여 후 인덱싱에 더 이상 고려되지 않을 때까지 검사하는 횟수입니다.'
# 'OBJECT_MODE setting %0 is not recognized and is not a valid setting'
HEC8A063EC23B: 'OBJECT_MODE 설정 %0은 인식되지 않았으며 유효하지 않은 설정입니다'
# 'ODS output filename'
H1E3A5BE01485: 'ODS 출력 파일 이름'
# 'OPTIONS:\n'
H90A71B46515B: '옵션:\n'
# 'OVERVIEW: '
H41828FCAB87A: '개요: '
# 'ObjC ARC contraction'
H3B8218111844: 'ObjC ARC 축약'
# 'Object file format name.'
H116E706BF6D9: '객체 파일 형식 이름.'
# 'Objective-C GC does not allow weak variables on the stack'
H501EF197353A: 'Objective-C 가비지 컬렉션은 스택 상에서 약한 변수를 허용하지 않습니다'
# 'Objective-C declarations may only appear in global scope'
HBE7743C7A3D5: 'Objective-C 선언은 전역 범위에서만 나타날 수 있습니다'
# 'Objective-C dispatch method to use'
H71CD5643C8D8: '사용할 Objective-C 디스패치 메서드'
# 'Objective-C index expression has incomplete class type %0'
H3BF9CC2B38D9: 'Objective-C 인덱스 표현식이 완전하지 않은 클래스 형식 %0를 가지고 있습니다.'
# 'Objective-C message has incomplete result type %0'
HA58AB6CD0922: 'Objective-C 메시지가 완전하지 않은 결과 타입 %0를 가집니다'
# 'Objective-C methods as coroutines are not yet supported'
H197AF4BB9670: 'Objective-C 메소드를 코루틴으로 사용하는 것은 아직 지원되지 않습니다'
# 'Objective-C object of type %0 is bridged to %1, which is not valid CF object'
HC21532E95928: '타입 %0인 Objective-C 객체는 %1로 브릿지 되었지만 유효하지 않은 CF 객체입니다'
# 'Objective-C++ Automatic Reference Counting standard library kind'
HBD2739B5128E: 'Objective-C++ 자동 참조 카운팅 표준 라이브러리 종류'
# 'Offloading entry for declare target variable %0 is incorrect: the address is invalid.'
H44B1C3BF0A67: 'declare target 변수 %0의 오프로딩 항목이 올바르지 않습니다: 주소가 유효하지 않습니다.'
# 'Offloading entry for declare target variable is incorrect: the address is invalid.'
H3668F9F00CF1: '오프로딩 엔트리의 declare target variable이 잘못되었습니다: 주소가 유효하지 않습니다.'
# 'Offloading entry for target region in %0 is incorrect: either the address or the ID is invalid.'
HB922AD26B2CB: '타겟 영역의 오프로딩 엔트리가 %0에서 잘못되었습니다: 주소 또는 ID가 유효하지 않습니다.'
# 'Offset element to print.'
HCA7A2283660F: '출력할 요소의 오프셋'
# 'Offsets are in UTF-16 code units'
H3B426E622CC8: '오프셋은 UTF-16 코드 유닛으로 표시됩니다'
# 'Offsets are in UTF-8 bytes'
HB9A6C5C455E1: '오프셋은 UTF-8 바이트 단위입니다'
# 'Offsets are in unicode codepoints'
H0151FBB5A950: '오프셋은 유니코드 코드 포인트 단위로 지정됩니다'
# 'Old namespace.'
HC6DBF56DB427: '구 네임스페이스입니다.'
# 'Omit all lfences before branch instructions.'
H64285876BCDE: '분기 명령어 이전에 모든 lfences를 생략합니다.'
# 'Omit all lfences other than the first to be placed in a basic block.'
HF3797EC0A201: '첫 번째를 제외한 베이직 블록에 배치되는 모든 lfences를 생략합니다.'
# 'Omit frame pointer setup for leaf functions'
HE755622424D0: '리프 함수의 프레임 포인터 설정 생략'
# 'Omit function index section at the expense of single-function patching performance'
HE5E5A5FAB8F1: '함수 인덱스 섹션을 생략함으로써 단일 함수 패치 성능이 저하됩니다'
# 'Omit the RTTI component from virtual tables'
H4D1372C43A35: '가상 테이블의 RTTI 구성 요소 생략'
# "Omit the frame pointer from functions that don't need it. Some stack unwinding cases, such as profilers and sanitizers, may prefer specifying -fno-omit-frame-pointer. On many targets, -O1 and higher omit the frame pointer by default. -m[no-]omit-leaf-frame-pointer takes precedence for leaf functions"
H40ED6B28D90F: '프레임 포인터를 필요로 하지 않는 함수에서 프레임 포인터를 생략합니다.\n프로파일러나 산타이저와 같은 스택 언윈딩 사례에서는 -fno-omit-frame-pointer를 지정하는 것이 좋을 수 있습니다.\n다수의 타겟에서 -O1 이상 옵션에서는 기본적으로 프레임 포인터가 생략됩니다.\n-м[no-]omit-leaf-frame-pointer 옵션이 리프 함수에 대해서는 우선 적용됩니다.'
# 'On AIX, request creation of a build-id string, "0xHEXSTRING", in the string table of the loader section inside the linked binary'
H9CC108588817: 'AIX에서 빌드-ID 문자열 "0xHEXSTRING"을 링크된 바이너리 내 로더 섹션의 문자열 테이블에 생성하도록 요청합니다'
# 'On Windows, do not emit /defaultlib: directives to link compiler-rt libraries'
H9E62CED5E13B: 'Windows에서는 compiler-rt 라이브러리를 링크할 때 /defaultlib: 지시문을 포함하지 마세요.'
# 'On Windows, emit /defaultlib: directives to link compiler-rt libraries (default)'
H84415BE98E65: 'Windows에서 compiler-rt 라이브러리를 링크하기 위해 /defaultlib: 지시문을 생성 (기본값)'
# 'One completion item for each semantically distinct completion, with full type information'
HE890AD8AA9F7: '각 의미적으로 구분되는 완성 항목에 대한 하나의 완성 항목, 완전한 형식 정보 포함'
# 'One shadow type id for each of `float`, `double`, `long double`. `d`,`l`,`q`,`e` mean double, x86_fp80, fp128 (quad) and ppc_fp128 (extended double) respectively. The default is to shadow `float` as `double`, and `double` and `x86_fp80` as `fp128`'
H95084AA4612D: '각각의 `float`, `double`, `long double`에 대한 하나의 쉐도우 타입 아이디입니다. `d`, `l`, `q`, `e`는 각각 double, x86_fp80, fp128 (quad) 및 ppc_fp128 (extended double)을 의미합니다. 기본값은 `float`을 `double`로, `double`과 `x86_fp80`을 `fp128`로 쉐도우 처리합니다'
# 'One statement per basic block'
HD6EC7448F7DB: '기본 블록당 하나의 문'
# 'Only AST generation'
HCF69EA2C9F2B: 'AST 생성만'
# 'Only a certain kind of dependences (all/raw)'
HDDC1270FFF46: '특정 종류의 종속성만 허용됩니다 (all/raw)'
# 'Only allow instructions before a call, if their cost is below DuplicationThreshold'
HF553DB6BFC41: '호출 이전의 명령문만 허용하며, 그 비용이 DuplicationThreshold 미만일 경우에만'
# 'Only check if the module has objective-C defined in it'
H77EBD1C814CB: '모듈이 Objective-C를 정의했는지만 확인합니다.'
# "Only comparisons where inputs don't need [sz]ext."
HF4DF79025CD9: '비교 연산 중에서 입력이 [sz]ext가 필요하지 않은 경우만'
# 'Only comparisons with sext result.'
H4718DE1FE775: 'sext 결과와의 비교만 허용됩니다.'
# 'Only comparisons with zext result.'
H13645F5A29D7: 'zext 결과와의 비교만 허용됩니다.'
# 'Only compile for the offloading device.'
H215BF96D8531: '오직 오프로딩 디바이스를 위해 컴파일합니다.'
# 'Only compile for the offloading host.'
H064D887D36F7: '오프로딩 호스트에 대해서만 컴파일합니다.'
# 'Only consider IR changes for passes whose names match the specified value. No-op without -print-changed'
HEBE7550E221C: '지정된 값과 이름이 일치하는 패스의 경우에만 IR 변경 사항을 고려합니다. -print-changed 옵션이 없으면 실행되지 않습니다.'
# 'Only count the calls that are recursive'
H531F12291A31: '재귀적인 호출만 세도록 합니다'
# 'Only display members that contribute to class size.'
HAA83522F47FE: '클래스 크기에 기여하는 멤버만 표시합니다.'
# 'Only display the basic block whose name matches this for all view-*-dags options'
HB71A82047A43: '모든 view-*-dags 옵션에 대해 이 이름과 일치하는 기본 블록만 표시합니다'
# 'Only display whether errors occurred.'
HDB4BCEB24DBE: '오류 발생 여부만 표시합니다.'
# 'Only do the coverage check.'
HD8B2B9D841CB: '커버리지 확인만 수행합니다.'
# 'Only dump files with relative paths or absolute paths with the prefix specified by -s'
HD834488625EB: '상대 경로 또는 -s 옵션으로 지정된 접두사가 있는 절대 경로를 가진 파일만 dump합니다.'
# 'Only emit EH frame entries when compact unwind is not available'
HBF3C0E4970CD: 'Compact unwind가 사용되지 않을 때만 EH 프레임 항목을 생성합니다'
# 'Only emit checks for arguments of functions whose names match the given regular expression'
HA389B7E0BDB5: '특정 정규식과 일치하는 이름을 가진 함수의 인수에 대해서만 검사를 생성합니다'
# 'Only enable generating memmove in non-nested loops'
H29441902D683: '중첩되지 않은 루프에서만 memmove 생성을 활성화합니다'
# 'Only enumerate VLMAX for VL operand'
H6E315308AF5A: 'VL operand에 대해서는 VLMAX만을 열거해야 합니다'
# 'Only execute frontend initialization'
H918B5DDB51E1: '프론트엔드 초기화만 실행합니다'
# 'Only functions matching the filter are shown in the output. For overlapping CSSPGO, this takes a function name with calling context.'
H189EF6F2A967: '출력에는 필터에 맞는 함수만 표시됩니다. 중첩된 CSSPGO인 경우, 이 옵션은 호출 컨텍스트와 함께 함수 이름을 사용합니다.'
# "Only fuse 'blessed' FP ops."
H7765353506F0: "지정된 'blessed' FP 연산만 융합합니다."
# "Only fuse FP ops when the result won't be affected."
HDA090F75D8FD: '결과가 영향을 받지 않을 때만 FP 연산을 결합합니다.'
# 'Only generate the minimal instruction sequence'
H0CBFA1B64E41: '최소한의 명령어 시퀀스만 생성합니다'
# 'Only has an effect when specified with -print-pipeline-passes. Disables verifying that the textual pipeline generated by -print-pipeline-passes can be used to create a pipeline.'
HD2EDB018C926: '-print-pipeline-passes와 함께 지정될 때만 효과가 있습니다. -print-pipeline-passes로 생성된 텍스트 파이프라인이 파이프라인을 생성하는 데 사용될 수 있는지 확인을 비활성화합니다.'
# 'Only i32 comparisons in GPRs.'
HC06CC3A659A2: 'GPR에서 i32 비교만 허용됩니다.'
# 'Only i32 comparisons with sext result.'
HAF411A709509: 'sext 결과를 갖는 i32 비교 연산만 허용됩니다.'
# 'Only i32 comparisons with zext result.'
HF0A9D937090A: '오직 zext 결과를 갖는 i32 비교만 허용됩니다.'
# 'Only i64 comparisons in GPRs.'
HD8F85598F6F1: 'GPR 내의 i64 비교만 허용합니다.'
# 'Only i64 comparisons with sext result.'
H43DD157FC439: 'i64 비교 연산에만 sext 결과가 있습니다.'
# 'Only i64 comparisons with zext result.'
H32746962EC6F: 'i64 비교만 zext 결과와 함께 허용됩니다.'
# 'Only import first N functions if N>=0 (default -1)'
H22AE4A1BA0B0: 'N이 0보다 크거나 같을 경우 처음 N개의 함수만 import합니다 (기본값 -1)'
# 'Only import functions with less than N instructions'
HFF880FC2904D: 'N개 이하의 명령문을 가진 함수만 가져옵니다'
# 'Only include passes which match a specified regular expression in the generated optimization record (by default, include all passes)'
H8C18E65FDB94: '생성된 최적화 기록에서 지정된 정규 표현식과 일치하는 패스만 포함합니다 (기본값: 모든 패스 포함)'
# 'Only inline functions explicitly or implicitly marked inline'
H4FB05EC4AB48: 'inline로 명시적 또는 암시적으로 표시된 내联 함수만 허용됩니다'
# 'Only instrument 1 of N groups'
HE6DD6434319A: 'N 그룹 중 1개만 측정합니다'
# 'Only keep the intrinsics with the specified substring in their record name'
HCC2CC4639600: '레코드 이름에 지정된 하위 문자열이 있는 내장 함수만 유지합니다'
# 'Only lfence before groups of terminators where at least one branch instruction has an input to the addressing mode that is a register other than %rip.'
H7E6136B9D7D9: 'lfence는 분기 명령문의 주소 모드 입력으로 %rip 이외의 레지스터가 사용되는 것이 하나라도 있는 터미네이터 그룹 앞에만 배치되어야 합니다.'
# 'Only loops with vectorization factor equal to or larger than the specified value are considered for epilogue vectorization.'
H4A61EE8AECF1: '벡터화 인자가 지정된 값과 같거나 큰 루프만 에필로그 벡터화에 고려됩니다.'
# 'Only match instructions with the given prefix'
H83B563F0FFD8: '지정된 접두사와 일치하는 명령문만 찾음'
# 'Only output names of functions whose max count values are below the cutoff value'
HC54ECBB9C757: '최대 카운트 값이 컷오프 값보다 작은 함수의 이름만 출력합니다'
# 'Only precompile the input'
H8B49F001F9E2: '입력만 사전 컴파일합니다'
# 'Only print AMD GPUs'
HAEAFB4C4A2F4: 'AMD GPU만 표시'
# 'Only print IR for functions whose name match this for all print-[before|after][-all] options'
HBF4D64D1868D: '모든 print-[before|after][-all] 옵션에 대해 이 이름과 일치하는 함수에 대해서만 IR을 출력합니다'
# 'Only print NVIDIA GPUs'
HA8E45EB5D306: 'NVIDIA GPU만 표시'
# 'Only print to a depth of N elements.'
HFC218BA7E9C0: '깊이 N 요소까지만 출력합니다.'
# 'Only process files that match this filter. This flag only applies to all-TUs.'
H9C7DF00BB84A: '이 필터에 맞는 파일만 처리합니다. 이 플래그는 모든 TU에만 적용됩니다.'
# 'Only read thinlto index and print the index as LLVM assembly.'
H4D1BB8D241C8: 'thinlto 인덱스만 읽어 LLVM 어셈블리로 출력합니다.'
# 'Only record optimization remarks from passes whose names match the given regular expression'
HB7A5156C3AD3: '지정된 정규 표현식과 이름이 일치하는 패스에서만 최적화 주석을 기록합니다'
# 'Only record remark information for passes whose names match the given regular expression'
H53791F3D3835: '지정된 정규 표현식과 일치하는 이름을 가진 패스의 리마크 정보만 기록합니다'
# 'Only rename namespaces in files that match the given pattern.'
H3FFAEADCD3A9: '주어진 패턴과 일치하는 파일 내에서 네임스페이스만 이름을 변경합니다.'
# 'Only reorder expressions within a basic block when exposing CSE opportunities'
HEC96777F89E9: 'CSE 기회를 노출할 때는 기본 블록 내에서만 표현식을 재정렬해야 합니다'
# "Only run on certain regions (The provided identifier must appear in the name of the region's entry block"
H88F1D2665F48: '특정 영역에서만 실행 (제공된 식별자는 영역의 엔트리 블록 이름에 포함되어야 합니다)'
# 'Only run on functions that match a regex. Multiple regexes can be comma separated. Scop detection will run on all functions that match ANY of the regexes provided.'
H1DBFD722220A: '정규표현식과 일치하는 함수들만 실행합니다. 여러 정규표현식은 쉼표로 구분해서 지정할 수 있습니다. Scop 탐지는 제공된 정규표현식 중 어떤 것이라도 일치하는 모든 함수에 대해 실행됩니다.'
# 'Only run ordered assignment scheduling with no codegen'
HD5721C8545D7: 'CodeGen 없이 순서 지정 할당 스케줄링만 실행합니다.'
# 'Only run preprocess and compilation steps'
HF940D137E364: '사전 처리 및 컴파일 단계만 실행합니다'
# 'Only run preprocess, compile, and assemble steps'
H81C1E28BCD95: '예처리, 컴파일, 그리고 어셈블 단계만 실행합니다'
# 'Only run scop detection, but no other optimizations'
HBD3276584517: '스코프 검출만 실행하고, 다른 최적화는 수행하지 않음'
# 'Only run the driver.'
H11F300F88E2D: '드라이버만 실행합니다.'
# 'Only run the preprocessor'
HCB8008C01361: '예처리기만 실행합니다'
# 'Only schedule this MBB#'
HAAC66E179615: '이 MBB#만 스케줄링하십시오'
# 'Only schedule this function'
HDDB8FF491938: '이 함수만 스케줄링하십시오.'
# 'Only show debug message if the branch probability is greater than this value (in percentage).'
H364FCDA181C3: '이 값보다 분기 확률이 높을 경우에만 디버그 메시지를 표시합니다 (백분율로 지정).'
# 'Only show debug message if the source branch weight is greater  than this value.'
HAD26C2C5503B: '소스 분기 가중치가 이 값보다 클 경우에만 디버그 메시지를 표시합니다.'
# 'Only show error-related paths in the analysis graph'
HA2114E4FC51E: '분석 그래프에서 오류 관련 경로만 표시합니다'
# 'Only split jump tables containing functions whose sizes are less or equal than this threshold.'
H115A29858DAD: '함수의 크기가 이 임계값 이하인 점프 테이블만 분할합니다.'
# 'Only split jump tables with size less or equal than JumpTableSizeThreshold.'
H159246FC6C6B: '점프 테이블의 크기가 JumpTableSizeThreshold보다 작거나 같은 경우에만 분할합니다.'
# 'Only supported on AArch64, PowerPC, RISC-V, SPARC, SystemZ, and X86'
H6BC9222A7886: '지원되는 아키텍처는 AArch64, PowerPC, RISC-V, SPARC, SystemZ 및 X86입니다.'
# 'Only try to inject loop invariant conditions and unswitch on them to eliminate branches that are not-taken 1/<this option> times or less.'
H93BBEDA4C81E: '단, 이 옵션 값의 역수 이하의 횟수인 실행되지 않는 분기를 제거하기 위해 루프 불변 조건을 주입하고 이를 기반으로 루프 언스위치를 시도합니다.'
# 'Only use DAG-combiner alias analysis in this function'
H9A1CF1A6CF3A: '이 함수에서는 DAG-combiner 별칭 분석만 사용합니다'
# 'Only use warnings from specified component'
H87D3AEA990F7: '지정된 구성 요소에서만 경고를 사용합니다'
# 'Only vectorize if you gain more than this number '
H4BBF18444D60: '이 숫자보다 더 많은 이득을 얻을 경우에만 벡터화합니다'
# 'Only vectorize small trees if they are fully vectorizable'
H374794964C3E: '작은 트리는 완전히 벡터화 가능할 경우에만 벡터화합니다'
# 'Only view functions that match this pattern'
H0D8068A91934: '이 패턴과 일치하는 뷰 함수만'
# 'Only warn if #include directives are inside extern or namespace blocks if the included header is in the header list.'
H9AF148F3DBE5: '포함된 헤더가 헤더 목록에 있고 #include 지시문이 extern 또는 namespace 블록 내에 있는 경우에만 경고합니다.'
# 'Only write combined global index for ThinLTO backends'
HDCE16F222238: 'ThinLTO 백엔드에 대한 결합된 글로벌 인덱스만 작성합니다'
# 'Only write output if it changed'
H89C2A6721B4D: '변경된 경우에만 출력을 작성합니다'
# 'Only write to the output file if it changed'
H82DD0380BC4C: '파일이 변경된 경우에만 아웃풋 파일에 씁니다'
# "OpenACC %select{clause '%1'|directive '%2'|sub-array bound}0 requires expression of integer type (%3 invalid)"
H24F0AB7B1FF3: "OpenACC %select{절 '%1'|지시문 '%2'|sub-array bound}0는 정수 형식의 표현식이 필요합니다 (%3 유효하지 않음)"
# "OpenACC '%0' clause applies to 'device_type' '%1', which conflicts with previous '%0' clause"
HF0863871567F: "OpenACC '%0' 절이 'device_type' '%1'에 적용되지만 이전 '%0' 절과 충돌합니다"
# "OpenACC '%0' clause cannot appear more than once%select{| in a 'device_type' region}2 on a '%1' directive"
H5BA479702441: "OpenACC '%0' 절은 '%1' 지시문에서%select{| device_type 영역 내에서}2 1회 이상 사용할 수 없습니다."
# "OpenACC '%0' clause cannot appear on the same '%2' construct as a '%1' clause %select{inside a compute construct with a|and a}3 'num_gangs' clause with more than one argument"
H86F6667DC7E5: "OpenACC '%0' 절은 '%2' 구조체에서 '%1' 절과 함께 사용될 수 없습니다 %select{compute 구조체 내의 a|and a}3 'num_gangs' 절에 한 개 이상의 인수가 있는 경우"
# "OpenACC '%0' clause on a 'declare' directive is not allowed at global or namespace scope"
H0D95AB23A6A9: "OpenACC 'declare' 지시문의 '%0' 절은 전역 또는 네임스페이스 범위에서 허용되지 않습니다"
# "OpenACC '%0' construct can only be applied to a 'for' loop"
H7F39DD2F9D48: "OpenACC '%0' 구조는 'for' 루프에만 적용될 수 있습니다"
# "OpenACC '%0' construct must have a terminating condition"
HA5F584B3696E: "OpenACC '%0' 구조는 종료 조건을 반드시 지정해야 합니다"
# "OpenACC '%0' construct must have at least one %1 clause"
H5108FA0063F8: "OpenACC '%0' 구문은 최소 하나의 %1 절을 포함해야 합니다"
# "OpenACC '%0' construct must have initialization clause in canonical form ('var = init' or 'T var = init')"
HB6396996D535: "OpenACC '%0' 구문은 초기화 절을 표준 형식('var = init' 또는 'T var = init')로 포함해야 합니다"
# "OpenACC '%0' modifier not valid on '%1' clause"
H3160CD5E4802: "OpenACC '%0' 수정자는 '%1' 절에서 유효하지 않습니다."
# "OpenACC '%0' variable must monotonically increase or decrease ('++', '--', or compound assignment)"
H4842B31AA1BD: "OpenACC '%0' 변수는 단조 증가 또는 감소해야 합니다('++', '--', 또는 복합 할당)"
# "OpenACC '%1' clause %select{|with more than 1 argument }0may not appear on a '%2' construct with a '%3' clause%select{ with more than 1 argument|}0"
HE77D7FA4A4F6: "OpenACC '%1' 절 %select{|인자가 1개보다 많을 경우 }0는 '%2' 구조체에 '%3' 절%select{ 인자가 1개보다 많을 경우|}0이 있는 경우에 나타날 수 없습니다."
# "OpenACC '%1' clause cannot appear more than once on a '%0' directive"
H22BA6A918DDE: "OpenACC '%1' 절은 '%0' 지시문에 한 번 이상 등장할 수 없습니다"
# "OpenACC '%1' clause is not valid on '%0' directive"
H226495157F78: "OpenACC '%1' 절은 '%0' 지시문에 적용할 수 없습니다"
# "OpenACC 'bind' clause on a declaration must bind to the same name as previous 'bind' clauses"
HC59CAAD94E7A: "OpenACC 'bind' 절은 이전 'bind' 절들과 동일한 이름에 바인딩되어야 합니다"
# "OpenACC 'collapse' clause loop count must be a %select{constant expression|positive integer value, evaluated to %1}0"
HF187F732137C: "OpenACC 'collapse' 절의 루프 카운트는 %select{상수 표현식|양의 정수 값, %1로 평가됨}0이어야 합니다"
# "OpenACC 'device_type' clause on a 'set' construct only permits one architecture"
HB63E35D8A787: "OpenACC 'set' 구조체에서 'device_type' 절은 단일 아키텍처만 허용합니다."
# "OpenACC 'gang' clause may have at most one %select{unnamed or 'num'|'dim'|'static'}0 argument"
HC064C4557CFE: "OpenACC 'gang' 절은 최대 한 개의 %select{미지정 또는 'num'|'dim'|'static'}0 인수를 가질 수 있습니다."
# "OpenACC 'reduction' composite variable must not have non-scalar field"
H9A717A5BB65E: "OpenACC 'reduction' 복합 변수는 스칼라가 아닌 필드가 포함되어서는 안 됩니다"
# "OpenACC 'reduction' variable must be a composite of scalar types; %1 %select{is not a class or struct|is incomplete|is not an aggregate}0"
HD35F9CAD567D: "OpenACC 'reduction' 변수는 스칼라 타입의 복합체여야 합니다; %1 %select{클래스나 구조체가 아닙니다|완전하지 않습니다|집합体型이 아닙니다}0"
# "OpenACC 'reduction' variable must be of scalar type, sub-array, or a composite of scalar types;%select{| sub-array base}1 type is %0"
HEC7D1B479B8F: "OpenACC 'reduction' 변수는 스칼라 형식, 서브 어레이, 또는 스칼라 형식의 복합체여야 합니다;%select{| 서브 어레이 베이스}1 형식은 %0입니다"
# "OpenACC 'reduction' variable must have the same operator in all nested constructs (%0 vs %1)"
H28C388119D4E: "OpenACC 'reduction' 변수는 중첩된 모든 구조体内에서 동일한 연산자를 가져야 합니다 (%0 vs %1)"
# "OpenACC 'routine' construct must have at least one 'gang', 'seq', 'vector', or 'worker' clause that applies to each 'device_type'"
H32818FCDE6B7: "OpenACC 'routine' 구조체는 각 'device_type'에 적용되는 'gang', 'seq', 'vector', 또는 'worker' 절 중 적어도 하나가 있어야 합니다."
# "OpenACC 'routine' directive with a name refers to a function with the same name as the function on the following line; this may be unintended"
H18CDEE7EFD75: "OpenACC 'routine' 디렉티브의 이름이 다음 줄에 있는 함수와 동일한 이름을 가진 함수를 참조하고 있습니다; 이는 의도하지 않은 상황일 수 있습니다"
# "OpenACC 'tile' clause size expression must be %select{an asterisk or a constant expression|positive integer value, evaluated to %1}0"
HA638C30812B2: "OpenACC 'tile' 절 크기 표현식은 반드시 %select{별표(*) 또는 상수 표현식|양의 정수 값으로 %1로 평가되어야 합니다}0"
# "OpenACC 'update' construct may not appear in place of the statement following a%select{n if statement| while statement| do statement| switch statement| label statement}0"
H3E931AFE1E4E: "OpenACC 'update' 구문은 %select{n if 문| while 문| do 문| switch 문| label 문}0 다음 문장 위치에 등장할 수 없습니다"
# "OpenACC clause '%0' after 'device_type' clause on a 'routine' conflicts with the '%1' clause before the first 'device_type'"
HA93644C02FFF: "OpenACC 'routine'에서 'device_type' 절 다음에 온 '%0' 절은 첫 번째 'device_type' 이전의 '%1' 절과 충돌합니다."
# "OpenACC clause '%0' may not appear on the same construct as a '%1' clause on a '%2' construct"
HFD5E5BF152EC: "OpenACC clause '%0'는 '%2' construct의 '%1' clause와 같은 construct에 등장할 수 없습니다"
# "OpenACC clause '%0' may not follow a '%1' clause in a '%2' construct"
H3810BDC5F66B: "OpenACC 절 '%0'은 '%2' 구문 안에서 '%1' 절 뒤에 오면 안 됩니다"
# "OpenACC clause '%0' on a 'routine' directive conflicts with the '%1' clause applying to the same 'device_type'"
H672EE4A10B1D: "OpenACC 'routine' 지시문에서 '%0' 절은 동일한 'device_type'에 적용되는 '%1' 절과 충돌합니다."
# "OpenACC clause name '%0' is a deprecated clause name and is now an alias for '%1'"
H0277741A1F9D: "OpenACC 절 이름 '%0'는 비추천된 절 이름으로, 이제 '%1'의 별칭이 되었습니다"
# "OpenACC construct '%0' cannot be used here; it can only be used in a statement context"
HCF6F4162FC42: "오픈액스 구조 '%0'는 여기서 사용할 수 없습니다; 이는 문에서만 사용할 수 있습니다"
# "OpenACC construct 'routine' with implicit function not yet implemented, pragma ignored"
H861502AB5841: "OpenACC 'routine' 구조체에 암시적 함수가 포함된 경우 아직 구현되지 않았습니다. pragma가 무시됩니다."
# "OpenACC construct 'self' has no effect when an 'if' clause evaluates to true"
H4B8F857AB30C: "OpenACC의 'self' 구문 요소는 'if' 절이 true로 평가될 때 효과가 없습니다"
# 'OpenACC directives will result in no runtime behavior; use -fclangir to enable runtime effect'
H106A424B384D: 'OpenACC 지시문은 실행 시 동작이 없습니다; 실행 효과를 활성화하려면 -fclangir를 사용하세요.'
# 'OpenACC integer expression has incomplete class type %0'
H5F66C1830606: 'OpenACC 정수 표현식은 미완성 클래스 형식 %0를 가집니다'
# 'OpenACC integer expression requires explicit conversion from %0 to %1'
H20507033806F: 'OpenACC integer 표현은 %0에서 %1로의 명시적 변환을 필요로 합니다'
# 'OpenACC routine name %0 does not name a function'
H38F10B674F17: 'OpenACC 루틴 이름 %0는 함수를 지정하지 않습니다'
# 'OpenACC routine name %0 names a set of overloads'
H417FD900A33B: 'OpenACC 루틴 이름 %0는 오버로드된 함수 집합을 지정합니다'
# 'OpenACC sub-array %select{lower bound|length}0 evaluated to a value (%1) that would be out of the range of the subscripted array size of %2'
HD993EBC2FF56: 'OpenACC 부분 배열 %select{하단 경계|길이}0에서 계산된 값(%1)이 서브스크립트된 배열 크기(%2)의 범위를 벗어납니다'
# 'OpenACC sub-array %select{lower bound|length}0 evaluated to negative value %1'
H9C42001B0E35: 'OpenACC 부분 배열 %select{하한 값|길이}0이 음수 값 %1로 계산됨'
# 'OpenACC sub-array base is of incomplete type %0'
H568C42694CA4: 'OpenACC 하위 배열 기반은 미완료 형식 %0입니다'
# 'OpenACC sub-array cannot be of function type %0'
H1F4C209C1D7A: 'OpenACC 서브 어레이는 함수 타입일 수 없습니다 %0'
# 'OpenACC sub-array length is unspecified and cannot be inferred because the subscripted value is %select{not an array|an array of unknown bound}0'
H3D8516DAE66C: 'OpenACC 부분 배열의 길이가 지정되지 않았으며 추론할 수 없습니다.这是因为 인덱싱된 값이 %select{배열이 아닙니다|크기가 알려지지 않은 배열입니다}0 때문입니다'
# 'OpenACC sub-array specified range [%0:%1] would be out of the range of the subscripted array size of %2'
H7C8F28679BDB: 'OpenACC 서브어레이에 지정된 범위 [%0:%1]은 인덱싱된 배열 %2의 크기 범위를 초과합니다'
# 'OpenACC sub-array subscripted value is not an array or pointer'
H64A7517C6764: 'OpenACC 부분 배열의 서브스크립트 값이 배열 또는 포인터가 아닙니다'
# "OpenACC variable %select{in 'use_device' clause|on 'declare' construct}0 is not a valid variable name or array name"
H5FFA8811F2EF: "OpenACC 변수 %select{in 'use_device' clause|on 'declare' construct}0은 유효한 변수 이름 또는 배열 이름이 아닙니다"
# 'OpenACC variable in cache directive is not a valid sub-array or array element'
H0DEC3018E66D: 'cache 지시문에 있는 OpenACC 변수가 유효한 서브 어레이 또는 배열 요소가 아닙니다'
# 'OpenACC variable is not a valid variable name, sub-array, array element,%select{| member of a composite variable,}0 or composite variable member'
HA8B26141C7C6: 'OpenACC 변수는 유효한 변수 이름, 서브 어레이, 어레이 요소, %select{| 복합 변수의 멤버,}0 또는 복합 변수 멤버가 아닙니다'
# 'OpenCL extension %0 is core feature or supported optional core feature - ignoring'
H1E2DAA7C8DD9: 'OpenCL 확장 %0는 코어 기능이거나 지원되는 선택적 코어 기능이므로 무시함'
# 'OpenCL extension %0 unknown or does not require pragma - ignoring'
HB7D9C7E097C0: 'OpenCL 확장 %0는 알 수 없거나 pragma가 필요하지 않으므로 무시함'
# 'OpenCL language standard to compile for.'
H165955277EF6: 'OpenCL 언어 표준을 위한 컴파일 옵션입니다.'
# 'OpenCL only. Allow denormals to be flushed to zero.'
H8AAB3F5FE401: 'OpenCL만 해당합니다. 차수 정규화되지 않은 수를 0으로 강제 변환을 허용합니다.'
# 'OpenCL only. Allow floating-point optimizations that assume arguments and results are not NaNs or +-Inf.'
HD11F5701CC10: 'OpenCL 전용입니다. NaN 또는 +-Inf가 아닌 인수와 결과를 가정하는 부동소수점 최적화를 허용합니다.'
# 'OpenCL only. Allow unsafe floating-point optimizations.  Also implies -cl-no-signed-zeros and -cl-mad-enable.'
HF643B16A83F5: 'OpenCL 전용입니다. 안전하지 않은 부동소수점 최적화를 허용합니다. 또한 -cl-no-signed-zeros 및 -cl-mad-enable 옵션이 자동으로 활성화됩니다.'
# 'OpenCL only. Allow use of less precise MAD computations in the generated binary.'
H9C454BE02287: 'OpenCL 전용. 생성된 이진 파일에서 낮은 정밀도 MAD 계산을 허용합니다.'
# 'OpenCL only. Allow use of less precise no signed zeros computations in the generated binary.'
H8DE8DC71375B: 'OpenCL 전용. 생성된 이진 파일에서 부호화된 제로를 고려하지 않는 덜 정밀한 계산을 사용할 수 있게 합니다.'
# 'OpenCL only. Defines that the global work-size be a multiple of the work-group size specified to clEnqueueNDRangeKernel'
H3AFC0A3E3E23: 'OpenCL 전용. clEnqueueNDRangeKernel에 지정된 작업 그룹 크기의 배수로 전역 작업 크기를 정의합니다'
# 'OpenCL only. Disables all standard includes containing non-native compiler types and functions.'
H89344E39C234: 'OpenCL 전용. 비네이티브 컴파일러 유형과 함수를 포함하는 모든 표준 인클루드를 비활성화합니다.'
# "OpenCL only. Enable or disable OpenCL extensions/optional features. The argument is a comma-separated sequence of one or more extension names, each prefixed by '+' or '-'."
H2870B3BCDE72: "OpenCL 전용입니다. OpenCL 확장 기능/선택적 기능을 활성화하거나 비활성화합니다. 인수는 '+' 또는 '-' 접두사가 붙은 하나 이상의 확장 이름으로 구성된 쉼표로 구분된 시퀀스입니다."
# 'OpenCL only. Generate kernel argument metadata.'
HD27868AF8559: 'OpenCL 전용. 커널 인수 메타데이터 생성.'
# 'OpenCL only. Sets -cl-finite-math-only and -cl-unsafe-math-optimizations, and defines __FAST_RELAXED_MATH__.'
HA1D24030C687: 'OpenCL 전용. -cl-finite-math-only와 -cl-unsafe-math-optimizations 옵션을 설정하고, __FAST_RELAXED_MATH__를 정의합니다.'
# 'OpenCL only. Specify that single precision floating-point divide and sqrt used in the program source are correctly rounded.'
H2DD948248943: 'OpenCL 전용입니다. 프로그램 소스에서 사용된 단정밀도 부동소수점 나눗셈과 제곱근이 올바르게 반올림되어야 함을 지정합니다.'
# 'OpenCL only. This option disables all optimizations. By default optimizations are enabled.'
HB24BF4359851: 'OpenCL 전용입니다. 이 옵션은 모든 최적화를 비활성화합니다. 기본적으로 최적화는 활성화되어 있습니다.'
# 'OpenCL only. This option is added for compatibility with OpenCL 1.0.'
HEF34F847970F: 'OpenCL 전용. 이 옵션은 OpenCL 1.0 호환성을 위해 추가되었습니다.'
# 'OpenCL only. Treat double precision floating-point constant as single precision constant.'
H9F9807A3E0E7: 'OpenCL 전용. 이중 정밀도 부동소수점 상수를 단일 정밀도 상수로 처리합니다.'
# 'OpenMP array shaping operation is not allowed here'
H6B78DAFB84E5: 'OpenMP 배열 형상 지정 연산은 여기에 허용되지 않습니다'
# 'OpenMP captured regions are not yet supported in %select{streaming functions|functions with ZA state|functions with ZT0 state}0'
HBFAEB31DF5F3: 'OpenMP 캡처된 영역은 %select{스트리밍 함수|ZA 상태 함수|ZT0 상태 함수}0에서 아직 지원되지 않았습니다'
# "OpenMP clause '%0' is only available as extension, use '-fopenmp-extensions'"
H7D732B734761: "OpenMP 절 '%0'은 확장 기능으로만 사용 가능합니다. '-fopenmp-extensions' 옵션을 사용하세요."
# 'OpenMP constructs may not be nested inside a simd region%select{| except for ordered simd, simd, scan, or atomic directive}0'
HC65424272817: 'OpenMP 구조체는 simd 영역 내에 중첩될 수 없습니다%select{| 단, ordered simd, simd, scan 또는 atomic 지시문을 제외하고}0'
# 'OpenMP constructs may not be nested inside an atomic region'
HE2C47884F9E6: 'OpenMP 구문은 원자적 영역 내에서 중첩될 수 없습니다'
# "OpenMP extension clause '%0' only allowed with '#pragma omp %1'"
HB7695EC8B674: "OpenMP 확장 절 '%0'은 '#pragma omp %1'과 함께 사용할 수 있습니다."
# 'OpenMP iterator is not allowed here'
HB9668BC52F3C: 'OpenMP 반복자는 여기서 허용되지 않습니다'
# 'OpenMP loop iteration variable cannot have more than 64 bits size and will be narrowed'
H85A842BD8107: 'OpenMP 루프 반복 변수는 64비트보다 큰 크기를 가질 수 없으며 축소됩니다'
# "OpenMP offloading target '%0' is similar to target '%1' already specified; will be ignored"
H66F93F9F54F1: "OpenMP 오프로딩 타겟 '%0'은 이미 지정된 타겟 '%1'과 유사하므로 무시됩니다"
# 'OpenMP only allows an ordered construct with the simd clause nested in a simd construct'
H52C83AA3C087: 'OpenMP는 simd 절을 포함하는 ordered 절이 simd 구조체 내에 중첩되어야만 허용합니다'
# 'OpenMP standard version'
HA403864CFA0F: 'OpenMP 표준 버전'
# 'OpenMP support in flang is still experimental'
HA42DEF114A36: 'flang의 OpenMP 지원은 여전히 실험적입니다'
# "OpenMP target architecture '%0' pointer size is incompatible with host '%1'"
HF18160FDA94C: "OpenMP 타겟 아키텍처 '%0'의 포인터 크기는 호스트 '%1'과 호환되지 않습니다"
# "OpenMP target is invalid: '%0'"
H6461D2D7A8F6: "OpenMP 대상이 유효하지 않습니다: '%0'"
# 'Optimise without changing ABI'
H19D2D13E9ED7: 'ABI 변경 없이 최적화'
# 'Optimization level 0. Similar to clang -O0. Same as -passes="default<O0>"'
H809F6417B5CD: '최적화 수준 0. clang -O0와 유사합니다. -passes="default<O0>"와 동일함'
# 'Optimization level 1. Similar to clang -O1. Same as -passes="default<O1>"'
H563E0780E60E: '최적화 레벨 1. clang -O1과 유사합니다. -passes="default<O1>"과 동일합니다'
# 'Optimization level 2. Similar to clang -O2. Same as -passes="default<O2>"'
H71099B09BC66: '최적화 수준 2. clang -O2와 유사합니다. -passes="default<O2>"와 동일합니다.'
# 'Optimization level 3. Similar to clang -O3. Same as -passes="default<O3>"'
H73EA61C4E41D: '최적화 레벨 3. clang -O3과 유사합니다. -passes="default<O3>" 옵션과 동일합니다.'
# 'Optimization level for NVVM compilation'
HA23F3D2204EA: '최적화 단계 (NVVM 컴파일을 위한)'
# "Optimization level. [-O0, -O1, -O2, or -O3] (default = '-O2')"
H8F5A63304993: "최적화 수준. [-O0, -O1, -O2, 또는 -O3] (기본값 = '-O2')"
# 'Optimization remarks file containing inline remarks to be replayed by cgscc inlining.'
HEFDDA07D8CA1: 'cgscc 인라인에 의해 재생될 내부 인라인 주석을 포함하는 최적화 주석 파일.'
# 'Optimization remarks file containing inline remarks to be replayed by inlining from sample profile loader.'
H7FC66DD3A1D4: '최적화 메모 파일로, 샘플 프로파일 로더에서 인라인을 통해 재생될 인라인 메모를 포함합니다.'
# 'Optimizations available (use "-passes=" for the new pass manager)'
H61E922DB15A6: '사용 가능한 최적화 (새 패스 매니저를 위해 "-passes=" 옵션을 사용하세요)'
# 'Optimize AArch64 selected instructions'
HC4CE467B7223: 'AArch64 선택된 명령어 최적화'
# 'Optimize LiveIntervals for WebAssembly'
H18D7A3DF4B0B: 'WebAssembly용 LiveIntervals 최적화'
# 'Optimize SCoPs using ISL'
HCB9C725F1344: 'SCoPs를 ISL을 사용하여 최적화'
# 'Optimize addressing mode'
HD2F645235970: '주소 모드 최적화'
# 'Optimize callbacks'
H4FA5D57DC24A: '콜백 최적화'
# 'Optimize calls with "returned" attributes for WebAssembly'
H77D4D84768F4: 'WebAssembly용 "returned" 속성을 가진 호출 최적화'
# 'Optimize for code generation'
HB09B7FAA4243: '코드 생성을 위한 최적화'
# 'Optimize for size'
H36D83A6CA81E: '크기 최적화'
# 'Optimize for size  (like /Og     /Os /Oy /Ob2 /GF /Gy)'
H45F672EE3075: '크기 최적화 (예: /Og /Os /Oy /Ob2 /GF /Gy)'
# 'Optimize for size (like clang -Os)'
HFB8E68DF5FCB: '크기 최적화(clang -Os과 유사)'
# 'Optimize for speed'
H56E47BC17587: '속도 최적화'
# 'Optimize for speed (like /Og /Oi /Ot /Oy /Ob2 /GF /Gy)'
HC5F6A322D605: '속도 최적화 (예: /Og /Oi /Ot /Oy /Ob2 /GF /Gy)'
# 'Optimize for speed (like clang -O3)'
HA3959EB2D045: '속도 최적화 (clang -O3과 유사)'
# 'Optimize instrumentation'
H4C86894C9330: '최적화 인스트루먼테이션'
# 'Optimize machine instruction PHIs'
H86D600E2A81C: '머신 명령어 PHI 노드 최적화'
# 'Optimize memory intrinsic result values for WebAssembly'
HFC7D2A9B2DB2: 'WebAssembly를 위한 메모리 내재 결과 값 최적화'
# 'Optimize selects'
H2F525E20DF58: 'select 최적화'
# 'Optimize spill slots'
HE31BB3136FBC: '스pill 슬롯 최적화'
# 'Optimize the memop size <= this value'
HD160B7A51C58: 'memop 크기를 이 값보다 작거나 같도록 최적화합니다'
# 'Optimizer Pipeline'
H226573EDB1C0: '최적화 파이프라인'
# 'Option passed to ISL'
HA7C0FFCC5B20: 'ISL에 전달된 옵션'
# 'Optional function name to filter collection by'
H65912274A33B: '필터링할 함수 이름 (선택 사항)입니다'
# 'Optional function name to filter collection by (accepts regular expressions)'
HB4B18F2D54D8: '필터링할 함수 이름 (선택 사항, 정규 표현식 지원)'
# 'Optional remark arg to filter collection by (accepts regular expressions).'
H3E0D571E2D16: '선택적 알림 인수(정규 표현식을 허용하며 컬렉션 필터링에 사용).'
# 'Optional remark arg to filter collection by.'
H4BB3B1D09826: '수집을 필터링하기 위한 선택적 주석 인수.'
# 'Optional remark name to filter collection by (accepts regular expressions).'
H1C5E04FF9D98: '필터링에 사용할 선택적 주석 이름(정규 표현식을 허용합니다).'
# 'Optional remark name to filter collection by.'
H660F0832C261: '컬렉션 필터링에 사용할 선택적 주석 이름을 지정합니다.'
# 'Optional remark pass name to filter collection by (accepts regular expressions).'
H2B175B559D90: '필터링할 수집 대상을 지정할 선택적 리마크 패스 이름 (정규 표현식을 허용함).'
# 'Optional remark pass name to filter collection by.'
H4733818447B2: '선택적 리마크 패스 이름을 지정하여 콜렉션을 필터링합니다.'
# 'Optional remark type to filter collection by.'
HA70FC86A45D5: '선택적 주의 메시지 유형으로 수집을 필터링합니다.'
# 'Options for -gen-(attrdef|typedef|enum|op|dialect)-doc'
H639716290785: '-gen-(attrdef|typedef|enum|op|dialect)-doc 옵션'
# 'Options for -gen-asm-matcher'
H01AF394D0C16: '옵션: -gen-asm-matcher'
# 'Options for -gen-asm-parser'
H9ACA7721D57A: '-gen-asm-parser 옵션'
# 'Options for -gen-asm-writer'
HC2084E3135D4: '-gen-asm-writer 옵션'
# 'Options for -gen-attrdef-*'
H904334F41DE4: '옵션: -gen-attrdef-*'
# 'Options for -gen-bytecode'
H6F6AAAD1A1D2: '-gen-bytecode 옵션'
# 'Options for -gen-dag-isel'
H28817938BEA9: '-gen-dag-isel 관련 옵션'
# 'Options for -gen-dialect-*'
HA2A748C26694: '옵션 -gen-dialect-*'
# 'Options for -gen-disassembler'
H7B14D2A69B34: '옵션: -gen-disassembler 관련 옵션'
# 'Options for -gen-global-isel'
HAE024C7C3B27: '-gen-global-isel 옵션'
# 'Options for -gen-global-isel-combiner'
H4132B3D1DEF9: '-gen-global-isel-combiner 옵션'
# 'Options for -gen-instr-info'
H0D7A354B88C3: '-gen-instr-info 옵션'
# 'Options for -gen-intrinsic-enums'
H65B201D59766: '옵션: -gen-intrinsic-enums'
# 'Options for -gen-irdl-dialect'
HAAF45CF21F4C: '-gen-irdl-dialect 옵션'
# 'Options for -gen-pass-capi-header and -gen-pass-capi-impl'
H849A90D3FA97: '-gen-pass-capi-header 및 -gen-pass-capi-impl에 대한 옵션'
# 'Options for -gen-pass-decls'
HD4DF70DE63FF: '옵션 -gen-pass-decls을(를) 위한'
# 'Options for -gen-python-op-bindings'
HFFB2EE013BDE: '-gen-python-op-bindings 옵션에 대한 옵션'
# 'Options for -gen-register-info'
H1593471B9CB0: '-gen-register-info 옵션'
# 'Options for -gen-sdnode-info'
H1CDBACD50609: '옵션 -gen-sdnode-info 관련'
# 'Options for -gen-typedef-*'
H9F13AB96225A: '옵션 -gen-typedef-*'
# 'Options for -print-enums'
HCC367BFA06F6: '-print-enums 옵션'
# 'Options for gen-directive-decl'
HB3B2620C73DD: 'gen-directive-decl 관련 옵션'
# 'Options for op definition generators'
H563831A68B15: '연산자 정의 생성기 옵션'
# 'Options to disable Loop Idiom Recognize Pass.'
HEC1AFA3F201E: 'Loop Idiom Recognize Pass를 비활성화하는 옵션입니다.'
# 'Options to pass to the fuzzer'
H35D63FFBE491: '파지저에 전달할 옵션'
# 'Options: <empty>'
H86F57A40CF46: '옵션: <비어 있음>'
# 'Options: <empty>|Legal|Discard|Convert. If non-empty, ignore TargetTransformInfo and always use this transformation for the %evl parameter (Used in testing).'
H04319FFE1FD4: '옵션: <empty>|Legal|Discard|Convert. 비어 있지 않은 경우, TargetTransformInfo를 무시하고 항상 이 변환을 %evl 매개변수에 적용합니다 (테스트 시 사용됨).'
# 'Orc JIT'
H76C72319C493: 'Orc JIT'
# 'Orc-based lazy JIT.'
H732AA2A7BDF4: 'Orc 기반 지연 JIT.'
# 'Orc-specific linker'
HCE705FE1F603: 'Orc 고유 링커'
# 'Order local stack symbols.'
H1D5554EC3474: '로컬 스택 심볼을 정렬하십시오.'
# 'Other Options'
H9CB6F2FB01DF: '기타 옵션'
# 'Outline loop blocks from loop chain if (frequency of loop) / (frequency of block) is greater than this ratio'
HB57131BBFAC5: '루프 체인에서 루프 블록들을 추출합니다. (루프의 빈도) / (블록의 빈도)가 이 비율보다 클 경우'
# 'Output'
H4BED336194A9: '출력'
# 'Output .gcov in intermediate text format'
HF37052F8B66C: '중간 텍스트 형식으로 .gcov 출력'
# 'Output Filename'
H253060EBAB8E: '출력 파일 이름'
# 'Output Options'
HFCD12607F17F: '출력 옵션'
# 'Output a side-by-side diff in HTML.'
H57654452ACF4: 'HTML 형식으로 옆으로 나란히 차이를 출력합니다.'
# 'Output assembly code file during compilation'
H6310B853EF5F: '컴파일 중 어셈블리 코드 파일 출력'
# 'Output assembly listing file'
H1DE8B74129C4: '어셈블리 목록 파일 출력'
# 'Output dwarf accelerator tables.'
H13E79CD2B348: 'DWARF 가속 테이블을 출력합니다.'
# 'Output file'
HB6AEEF874B66: '출력 파일'
# 'Output file for export'
HF9225788216E: '내보내기 위한 출력 파일'
# 'Output file. Can be specified multiple times for multiple output files.'
HEE2A7A1E3079: '출력 파일입니다. 여러 개의 출력 파일을 위해 여러 번 지정할 수 있습니다.'
# 'Output filename'
H85DF5E35434C: '출력 파일 이름'
# 'Output filename for pass remarks'
HB92A0E8D19B1: 'pass 비고를 위한 출력 파일 이름'
# 'Output filename for the reduced test case'
HD417AF7888E3: '줄인 테스트 케이스의 출력 파일 이름'
# 'Output format for line-based coverage reports'
H556FF7AB0CB0: '라인 기반 커버리지 보고서의 출력 형식'
# 'Output format for timing data'
H55AABD7334B6: '타이밍 데이터의 출력 형식'
# 'Output graphs with edge colors determined by this field'
H794FD3A570E0: '이 필드에 따라 결정된 엣지 색상을 사용하여 그래프를 출력합니다'
# 'Output graphs with edges colored by this field'
HF746FFB4D465: '이 필드에 따라 간선 색상을 지정한 그래프 출력'
# 'Output graphs with edges labeled with this field'
H24D87E28CEB2: '이 필드로 표시된 간선을 가진 그래프 출력'
# 'Output graphs with vertex colors determined by this field'
H074479A80832: '이 필드에 의해 결정된 정점 색상을 사용하여 그래프 출력'
# 'Output graphs with vertices colored by this field'
H2DF9C4C8C65F: '이 필드로 색칠된 꼭짓점을 가진 그래프를 출력합니다'
# 'Output graphs with vertices labeled with this field'
HE53D4D1DCDFD: '이 필드로 레이블을 표시한 정점을 가지는 그래프를 출력합니다'
# "Output in chrome's trace event format. May be visualized with the Catapult trace viewer."
H9A05A1436798: '크롬의 추적 이벤트 형식으로 출력합니다. Catapult 추적 뷰어로 시각화할 수 있습니다.'
# 'Output input source as HTML'
HE9E58C4AFE0A: '입력 소스를 HTML로 출력'
# 'Output instructions per ScopStmt'
H0963CFA695BF: 'ScopStmt 별 명령 출력'
# 'Output object file'
H427E379BB7CB: '출력 오브젝트 파일'
# 'Output options'
HCA4409BA27DC: '출력 옵션'
# 'Output profile file'
H3C5CF3CF6071: '프로파일 파일 출력'
# 'Output replacements as XML.'
H1724D4877353: 'XML 형식으로 대체 내용 출력'
# 'Output resource usage of launched kernels'
H76E82EB3BAF1: '실행된 커널의 자원 사용량을 출력'
# 'Output the total number corresponding to the count for the provided input file.'
H8049C03B1803: '제공된 입력 파일의 카운트에 해당하는 총합 수치를 출력하십시오.'
# "Output trace to the given file name or '-' for stdout."
H8DCBEA863061: "지정된 파일 이름 또는 stdout을 위해 '-'를 사용하여 추적 정보를 출력합니다."
# 'Outputs for view.'
H377C2CC892EF: '뷰에 대한 출력입니다.'
# 'Overapproximation of dependences'
HEFB667282405: '의존성의 과근사'
# 'Overlay the virtual filesystem described by file over the real file system'
H291889337D71: '파일에 의해 정의된 가상 파일 시스템을 실제 파일 시스템 위에 덮어씌웁니다'
# 'Overlay the virtual filesystem described by file over the real file system. Additionally, pass this overlay file to the linker if it supports it'
HAFADC554CE4B: '파일에 설명된 가상 파일 시스템을 실제 파일 시스템 위에 덮어씌웁니다. 또한, 링커가 이를 지원하면 이 오버레이 파일을 링커에 전달합니다'
# 'Override cost based safe divisor widening for div/rem instructions'
H81D91B0A076D: 'div/rem 명령문을 위한 비용 기반 방식을 무시하고 안전한 약수 범위 확장을 적용합니다.'
# 'Override default dump names'
H7A6C6DC9BBC4: '기본 덤프 이름 재정의'
# 'Override host target triple'
HF3CC7F9CE700: '호스트 타겟 트리플 대체'
# 'Override inferred gcda file'
H68DED86E4EE4: '추론된 gcda 파일 대체'
# 'Override inferred gcno file'
H756521C312EE: '추론된 gcno 파일 대체'
# 'Override optimization level for codegen hooks, legacy PM only'
HCB07980F5249: '코드 생성 훅을 위한 최적화 수준 재정의, 레거시 PM만 적용'
# 'Override output filename'
HAFF5159DAF01: '출력 파일 이름 재정의'
# 'Override record layouts with those in the given file'
H3D9B83089303: '지정된 파일의 레이아웃으로 레코드 레이아웃을 덮어씁니다'
# "Override source file's content (in the overlaying\nvirtual file system) with input from <stdin> and run\nthe tool on the new content with the compilation\noptions of the source file. This mode is currently\nused for editor integration."
H9F6FADB4D508: '소스 파일의 내용(오버레이 가상 파일 시스템 내)을 stdin 입력으로 덮어쓰고, 소스 파일의 컴파일 옵션으로 새로운 내용에 도구를 실행합니다. 이 모드는 현재 편집기 통합에 사용됩니다.'
# 'Override target triple detection'
H3331B75D4B40: '타겟 triple 감지 재정의'
# 'Override target triple for module'
HAD133DEC039A: '모듈의 타겟 트리플을 재정의합니다.'
# "Override the 'argv[0]' value passed into the executing program"
HD3C4FA0CA7DA: "실행 중인 프로그램에 전달된 'argv[0]' 값을 재정의합니다"
# 'Override the behaviour of '
H053262A576A2: '특정 동작을 재정의하려면'
# 'Override the behaviour of expand-variadics'
H8E4D335E1CAD: '확장 가변 인수의 동작을 재정의합니다'
# 'Override the default ABI to return all structs on the stack'
H796683BA46B0: '기본 ABI를 재정의하여 모든 구조体型을 스택에 반환합니다'
# 'Override the default ABI to return small structs in registers'
H14D9E95511EF: '기본 ABI를 재정의하여 소형 구조체를 레지스터에 반환하게 함'
# 'Override the path to the output spec json file. See -ml-inliner-model-under-training documentation for the specification of that file.'
HA0B2BFC5945E: '출력 spec JSON 파일 경로를 대체합니다. 해당 파일의 규격에 대한 설명은 -ml-inliner-model-under-training 문서를 참고하세요.'
# 'Override the processor dispatch width'
HBBE12C3A519F: '프로세서 디스패치 너비 재정의'
# 'Override the profitability heuristics for Machine CSE'
H05022840BC44: '머신 CSE의 수익성 휴리스틱을 무시합니다'
# 'Override the variant of check applied to authenticated LR during tail call'
H929544275FD6: '꼬리 호출 중 인증된 LR에 적용되는 체크의 변종을 오버라이드합니다'
# 'Override the vector register size in bits, which is otherwise found by querying TTI.'
H8FCFAFF95563: '비트 단위로 벡터 레지스터 크기를 재정의하며, 그렇지 않으면 TTI 쿼리로 찾을 수 있습니다.'
# 'Override the visibility of globals based on their final DLL storage class.'
HB70286716DCC: '전역 변수의 가시성을 최종 DLL 저장 클래스에 따라 재정의합니다.'
# 'Override unique ID of ctor/dtor globals.'
HA514528D025F: '생성자/소멸자 전역 변수의 고유 ID를 재정의합니다.'
# 'Override use of color (default = isatty)'
HFB4A1E45D51F: '색상 사용 재정의 (기본값 = isatty)'
# 'Override validator version for module. Format: <major.minor>;Default: DXIL.dll version or current internal version'
H29DBA8820EEB: '모듈의 검증기 버전을 재정의합니다. 형식: <주.부>; 기본값: DXIL.dll 버전 또는 현재 내부 버전'
# 'Overrides result used for getMaximumVF query which is used exclusively by SLP vectorizer.'
H790D0193AFF1: 'getMaximumVF 쿼리에 사용되는 결과를 재정의합니다. 이 쿼리는 SLP 벡터라이저에 의해 전적으로 사용됩니다.'
# 'Overrides the _OPENACC macro value for experimental testing during OpenACC support development'
H1F6C8876A478: 'OpenACC 지원 개발 중 실험적 테스트를 위해 _OPENACC 매크로 값을 재정의합니다'
# 'Overwrite edited files.'
HA46F1C96B7DC: '수정된 파일 덮어쓰기.'
# 'PASSED'
H75168D9452E2: '성공'
# 'PBQP register allocator'
HC52F58BD0440: 'PBQP 레지스터 할당기'
# 'PCH was compiled with different VFS overlay files than are currently in use'
H6654F3AEB3F7: 'PCH는 현재 사용 중인 것과 다른 VFS 오버레이 파일을 사용하여 컴파일되었습니다'
# 'PDB Stream Options'
HE58091817322: 'PDB 스트림 옵션'
# 'PDLL Frontend'
H667EECC1B90F: 'PDLL 프런트엔드'
# 'PDLL LSP Language Server'
HCB7860D44409: 'PDLL LSP 언어 서버'
# 'PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace, preprocessed source, and associated run script.\n'
H3E1C9F287454: '바랍니다 버그 보고서를 https://github.com/llvm/llvm-project/issues/ 에 제출해 주시고, crash backtrace, preprocessed source, 및 associated run script를 포함해 주시기 바랍니다.\n'
# 'PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\n'
H0DE59CCB7CD2: 'BUG 보고서를 https://github.com/llvm/llvm-project/issues/에 제출해 주시고, crash backtrace를 포함해 주세요.\n'
# 'POSIX thread model'
HAAFA3F8D71A1: 'POSIX 쓰레드 모델'
# 'Pack non-contiguous assumed shape dummy arrays into contiguous memory'
H921464C334CB: '비연속 가정 형상 가짜 배열을 연속 메모리에 패킹합니다'
# 'Pack non-contiguous assummed shape arrays into contiguous memory'
H3E0440CD78CB: '비연속 가정된 형상 배열을 연속 메모리에 압축합니다'
# 'Pad previous instructions to implement align directives'
H461F83B5992B: '정렬 지시문을 구현하기 위해 이전 명령문에 패딩을 추가합니다'
# 'Pad previous instructions to implement branch alignment'
H9A3FD2CE91B3: '이전 명령문에 패딩을 추가하여 브랜치 정렬을 구현합니다'
# 'Pair of function name and filename, where function should be imported from bitcode in filename'
H0856646593E7: '함수 이름과 파일 이름의 조합으로, 해당 함수가 해당 파일의 비트코드에서 가져와야 함을 나타냅니다'
# 'Parameter.'
H78B17095F0E6: '매개변수.'
# 'Parse OpenMP pragmas and generate parallel code.'
H203F2D0AAEA4: 'OpenMP pragma 해석 및 병렬 코드 생성'
# 'Parse and pretty-print the input'
HE106679F4FE4: '입력을 분석하고 정리된 형식으로 출력합니다'
# 'Parse templated function definitions at the end of the translation unit'
H187BB681FD43: '번역 단위의 끝에서 템플릿 함수 정의를 분석합니다'
# 'Partially inline calls to library functions'
HD08FDB669104: '라이브러리 함수의 호출을 부분적으로 인라인합니다'
# 'Partition data sections using profile information.'
HBDB4D3B42575: '프로파일 정보를 사용하여 데이터 섹션을 분할합니다.'
# 'Partition functions into N groups and select only functions in group i to be instrumented using -fprofile-selected-function-group'
H245EBE517AA5: '함수를 N개의 그룹으로 분할하고, 그룹 i에 속한 함수만을 선택하여 -fprofile-selected-function-group 옵션으로 인스트루먼트합니다'
# 'Partition functions into N groups using -fprofile-function-groups and select only functions in group i to be instrumented. The valid range is 0 to N-1 inclusive'
HE1BA0DFA9946: 'Partition 함수를 -fprofile-function-groups 옵션을 사용하여 N개의 그룹으로 분할하고, 그룹 i에 속한 함수만 측정 대상으로 선택합니다. 유효한 범위는 0부터 N-1까지입니다'
# 'Pascal string is too long'
HDF5B602956C9: 'Pascal 문자열이 너무 깁니다'
# 'Pass -b <arg> to the linker on AIX'
HC027AB59908D: 'AIX의 링커에 -b <arg>를 전달하십시오'
# 'Pass -z <arg> to the linker'
HC96FADA8EF05: '링커에 -z <arg> 옵션을 전달하십시오.'
# 'Pass <arg> to clang -cc1'
H7056B37839B2: 'clang -cc1에 <arg>를 전달하십시오'
# 'Pass <arg> to clang -cc1as'
HB0D05A4A9173: 'clang -cc1as에 <arg>를 전달합니다'
# 'Pass <arg> to fatbinary invocation'
HE6E06CC967E5: 'fatbinary 호출에 <arg>를 전달'
# 'Pass <arg> to plugin <name>'
H194FFD6DEF4E: '플러그인 <name>에 인수 <arg> 전달'
# 'Pass <arg> to the CUDA/HIP device compilation'
H6E93CAC5A2A4: 'CUDA/HIP 디바이스 컴파일에 인수 <arg>를 전달합니다'
# 'Pass <arg> to the CUDA/HIP host compilation'
HBD5864C8EAAC: 'CUDA/HIP 호스트 컴파일에 <arg>를 전달합니다'
# 'Pass <arg> to the assembler'
H260454350861: '어셈블러에 <arg>를 전달합니다'
# 'Pass <arg> to the clang driver'
H0BA43F60ADF1: 'clang 드라이버에 <arg>를 전달하십시오'
# 'Pass <arg> to the compilation if the target matches <arch>'
H28A6957698C7: '타겟이 <arch>와 일치하면 컴파일에 <arg>를 전달합니다'
# 'Pass <arg> to the flang compiler'
HA8F1AD31AB5E: '플랑 컴파일러에 <arg>를 전달하세요.'
# 'Pass <arg> to the linker'
H47C4E471D4CC: '링커에 <arg>를 전달합니다'
# 'Pass <arg> to the offload linkers or the ones identified by -<triple>'
HF43CE14F52D9: '옵프로드 링커나 -<triple>로 식별된 링커에 <arg>를 전달합니다.'
# 'Pass <arg> to the preprocessor'
HECFF1F09AA70: '프리프로세서에 <arg>를 전달'
# 'Pass <arg> to the ptxas assembler'
HDA10BB61A91B: 'ptxas 어셈블러에 <arg> 인자를 전달합니다.'
# 'Pass <arg> to the static analyzer'
H665CD83A1EA3: '정적 분석기에 <arg>를 전달하십시오'
# 'Pass <arg> to the target offloading toolchain identified by <triple>.'
HD393E82FA340: 'triple로 식별된 대상 오프로딩 툴체인에 <arg>를 전달합니다.'
# 'Pass <arg> to the target offloading toolchain.'
H786E5FF9D985: '대상 오프로딩 툴체인에 <arg>를 전달해 주세요.'
# 'Pass a workload definition. This is a file containing a JSON dictionary. The keys are root functions, the values are lists of functions to import in the module defining the root. It is assumed -funique-internal-linkage-names was used, to ensure local linkage functions have unique names. For example: \n{\n  "rootFunction_1": ["function_to_import_1", "function_to_import_2"], \n  "rootFunction_2": ["function_to_import_3", "function_to_import_4"] \n}'
H8F2A17B54334: '워크로드 정의를 전달합니다. 이는 JSON 사전을 포함하는 파일입니다. 키는 루트 함수이고, 값은 루트를 정의하는 모듈에서 가져올 함수 목록입니다. -funique-internal-linkage-names 옵션이 사용되었다고 가정하며, 이를 통해 로컬 링크 함수가 고유한 이름을 가지도록 합니다. 예를 들어:\n{\n  "rootFunction_1": ["function_to_import_1", "function_to_import_2"],\n  "rootFunction_2": ["function_to_import_3", "function_to_import_4"]\n}'
# 'Pass all reduction arguments by reference'
H1F6E6E7DA880: '모든 줄임 인수를 참조로 전달해야 합니다.'
# 'Pass the comma separated arguments in <arg> to the assembler'
H0BB4ECAE0BD9: '어셈블러에 <arg>의 쉼표로 구분된 인자를 전달합니다'
# 'Pass the comma separated arguments in <arg> to the linker'
H01CAEC128AC9: '링커에 <arg>의 콤마로 구분된 인수들을 전달합니다'
# 'Pass the comma separated arguments in <arg> to the preprocessor'
H596C87A5B391: '프리프로세서에 <arg>의 인수를 쉼표로 구분해 전달합니다'
# 'Passes available:'
H13989372E812: '사용 가능한 패스:'
# 'Path and name to DWP file.'
H6E3C7CBCF218: 'DWP 파일의 경로와 이름.'
# 'Path of .dwp file. When not specified, it will be <binary>.dwp in the same directory as the main binary.'
H743B0B321E91: 'dwp 파일의 경로입니다. 지정하지 않을 경우 메인 바이너리와 동일한 디렉토리의 <binary>.dwp가 사용됩니다.'
# 'Path of debug info binary, llvm-profgen will load the DWARF info from it instead of the executable binary.'
H7CB4490678CE: '디버그 정보 바이너리의 경로입니다. llvm-profgen는 실행 파일 대신 해당 바이너리에서 DWARF 정보를 로드합니다.'
# 'Path of perf-script trace created by Linux perf tool with `script` command(the raw perf.data should be profiled with -b)'
H3DEF1722D3DA: 'Linux perf 도구와 `script` 명령어로 생성된 perf-script 추적 경로(원시 perf.data는 -b 옵션으로 프로파일링되어야 합니다)'
# 'Path of profiled executable binary.'
H3B42E7676CEA: '프로파일링된 실행 가능 바이너리의 경로.'
# 'Path of raw perf data created by Linux perf tool (it should be profiled with -b)'
HFDF5B6ACDEB6: 'Linux perf 도구가 생성한 원시 perf 데이터 경로 (프로파일링 시 -b 옵션을 사용해야 합니다)'
# 'Path of the LLVM sample profile'
H33F3BE9ADD2D: 'LLVM 샘플 프로파일 경로'
# 'Path of the unsymbolized profile created by `llvm-profgen` with `--skip-symbolization`'
H946923D050AC: 'llvm-profgen에 의해 --skip-symbolization 옵션으로 생성된 언 심볼화된 프로파일 경로'
# 'Path to CSV file containing lines of function names and attributes to add to them in the form of `f1,attr1` or `f2,attr2=str`.'
HAA93B63D725F: 'CSV 파일 경로를 지정합니다. 파일에는 함수 이름과 추가할 속성을 줄 단위로 `f1,attr1` 또는 `f2,attr2=str` 형식으로 기술합니다.'
# 'Path to SavedModel from the previous training iteration.\nThe directory is also expected to contain a JSON specification of the \noutputs expected to be logged, where the first entry must be the \ninlining decision. The file containing the specification should be \ncalled output_spec.json. The expected JSON value is an array of \ndictionaries. Each dictionary should have 2 keys: \n\n- "tensor_spec, followed by the TensorSpec description of the\noutput; and \n- "logging_name", a string indicating the name to use when\nlogging the output values. \n\nExample:\n[\n  {\n    "logging_name" : "some_name", \n    "tensor_spec" : { \n      "name" : "model_name", \n      "port" : 0,\n      "shape" : [2, 3],\n      "type" : "float"\n      }\n  }\n]\n\nThe first value must always correspond to the decision.'
H9AB7FF7DDB14: '이전 훈련 반복의 SavedModel 경로.\n해당 디렉토리는 로깅될 것으로 예상되는 출력의 JSON 스펙을 포함해야 하며,\n첫 번째 항목은 인라인 결정이어야 합니다. 스펙을 포함하는 파일은\noutput_spec.json이라는 이름을 가져야 합니다. 예상하는 JSON 값은 \n딕셔너리 배열입니다. 각 딕셔너리는 2개의 키를 가져야 합니다:\n\n- "tensor_spec"에 이어 출력의 TensorSpec 설명;\n- "logging_name", 출력 값 로깅 시 사용할 이름을 나타내는 문자열.\n\n예시:\n[\n  {\n    "logging_name" : "some_name", \n    "tensor_spec" : { \n      "name" : "model_name", \n      "port" : 0,\n      "shape" : [2, 3],\n      "type" : "float"\n      }\n  }\n]\n\n첫 번째 값은 항상 결정에 해당해야 합니다.'
# 'Path to a directory containing a .clang-format file\ndescribing a formatting style to use for formatting\ncode when -style=file.\n'
H1C68FD05289D: 'clang-format 파일이 포함된 디렉토리의 경로\n포맷팅에 사용할 스타일을 설명하는\n-style=file 옵션을 사용할 때의 코드.\n'
# 'Path to a system assembler, picked up on AIX only'
HD76EB0189931: '시스템 어셈블러의 경로, AIX에서만 선택됨'
# 'Path to binary from which the profile was collected.'
HDF7F0FA583A9: '프로파일이 수집된 바이너리 파일의 경로.'
# 'Path to file containing newline-separated [<weight>,]<filename> entries'
H39AF8CCE2C18: '줄 바꿈으로 구분된 [<weight>,]<filename> 항목을 포함하는 파일의 경로'
# 'Path to file containing the list of function symbols used to populate profile symbol list'
H85546B6474C7: '프로파일 심볼 목록을 채우기 위해 사용된 함수 심볼의 목록이 포함된 파일의 경로'
# 'Path to ignorelist file for sanitizers'
H685EED5F185D: 'asan, msan, tsan 등 샌타이저들이 무시해야 할 파일의 경로'
# 'Path to libomptarget-amdgcn bitcode library'
H409595E6068A: 'libomptarget-amdgcn 비트코드 라이브러리 경로'
# 'Path to libomptarget-nvptx bitcode library'
H1DFEDD2BDCE9: 'libomptarget-nvptx 비트코드 라이브러리 경로'
# 'Path to libomptarget-spirv bitcode library'
H17C48C664B7B: 'libomptarget-spirv 비트코드 라이브러리 경로'
# "Path to opt. (default: search path for 'opt'.)"
H87E2E1DC35F9: "opt 경로. (기본값: 'opt' 검색 경로.)"
# 'Path to ptxas (used for compiling CUDA code)'
H902CF64E7382: 'ptxas의 경로 (CUDA 코드 컴파일에 사용됨)'
# 'Path to saved model evaluating native size from IR.'
H90E4D367F618: 'IR에서 원시 크기를 평가한 저장 모델의 경로.'
# 'Path to system headers on z/OS'
H858924F171F6: 'z/OS 시스템 헤더 경로'
# 'Path to system ignorelist file for sanitizers'
H6EB010D2085A: 'Sanitizers를 위한 시스템 무시 목록 파일 경로'
# 'Path to the DIA SDK'
HEE09636C6E6A: 'DIA SDK 경로'
# 'Path to the IR file produced by the frontend for the host.'
H6108420B0DC9: '프런트엔드가 호스트용으로 생성한 IR 파일의 경로.'
# 'Path to the VCToolChain'
H5C43C23950E7: 'VCToolChain의 경로'
# 'Path to the Windows SDK'
H6252659C1D52: 'Windows SDK 경로'
# 'Path to the YAML configuration file to be used for multilib selection'
H370257D7FAE7: 'multilib 선택에 사용할 YAML 구성 파일의 경로'
# 'Path to the file where tracer logs will be stored'
HB84166BE320D: '트레이서 로그를 저장할 파일의 경로'
# 'Path to the instrumented context sensitive profile.'
H374A91784042: '인스트루먼트된 컨텍스트 감도형 프로필의 경로.'
# 'Path to the memory profile.'
H0F3D8AAD8CB7: '메모리 프로파일의 경로.'
# 'Path to the prefetch hints profile. See also -x86-discriminate-memops'
HC95B0BC0D2ED: '프리페치 힌트 프로파일의 경로. 참고: -x86-discriminate-memops'
# 'Path to the profile remapping file.'
H16575118DC15: '프로파일 재매핑 파일의 경로입니다.'
# 'Path to the profile.'
H327691C6666D: '프로파일의 경로.'
# 'Path to the project. Required when connecting using remote index.'
HD4FC494735F6: '프로젝트 경로. 리모트 인덱스를 사용하여 연결할 때 필요합니다.'
# 'Path to the vocabulary file for IR2Vec'
HD630B03243E1: 'IR2Vec 용 어휘 파일 경로입니다'
# 'Path to where .dwo files will be written out to.'
H41452088F682: 'DWO 파일을 출력할 경로'
# 'Path where the development - mode inlining log is saved.'
H72974DF4C8AA: '개발 모드 인라인 로그를 저장할 경로입니다.'
# 'Pathname where the element is defined.'
H33A4EFF1B837: '요소가 정의된 경로명입니다.'
# 'Peephole Optimizations'
H6FFA8D4ADC02: '피크홀 최적화'
# 'Penalty of calling a function that requires a change to PSTATE.SM'
H135B935B6400: 'PSTATE.SM 변경이 필요한 함수 호출의 비용'
# 'Penalty of inlining a call that requires a change to PSTATE.SM'
HF8B0216049CB: 'PSTATE.SM 변경이 필요한 호출을 인라인할 때 발생하는 벌점'
# 'Percentage of prologue execution count to use as threshold when evaluating whether a block is cold enough to be profitable to move eligible spills there'
HB814EF09C393: '프롤로그 실행 횟수의 백분율을 임계값으로 사용하여, 블록이 충분히 적은 실행 빈도를 가진 경우 해당하는 적격된 스파일을 이동하는 것이 유리한지 평가할 때 사용합니다'
# 'Percentage threshold for splitting single-instruction critical edge. If the branch threshold is higher than this threshold, we allow speculative execution of up to 1 instruction to avoid branching to splitted critical edge'
HF3E418A57D78: '단일 명령어 임계 경로 분할을 위한 백분율 임계치입니다. 분기 임계치가 이 임계치보다 높으면, 분할된 임계 경로로의 분기를 피하기 위해 최대 1개 명령어의 예측 실행을 허용합니다'
# 'Percentage threshold of matched basic blocks at which stale profile inference is executed.'
H38AE58F6A0A2: '일치하는 기본 블록의 퍼센트 임계값에서 고차가 된 프로파일 추론이 실행되는 시점.'
# 'Percentile of profile quality distributions over hottest functions to report.'
H5CD854B0BEDF: '보고할 가장 뜨거운 함수에 대한 프로파일 품질 분포의 백분위수'
# 'Percentile profile summary cutoff used to determine cold blocks. Unused if set to zero.'
H3E03792B2D91: '차가운 블록을 결정하는 데 사용되는 백분위 프로파일 요약 컷오프. 값이 0으로 설정되면 사용되지 않습니다.'
# 'Perform ODR checks for decls in the global module fragment.'
H69A7B0ED61B4: '글로벌 모듈 프래그먼트의 선언에 대해 ODR 검사를 수행합니다.'
# 'Perform SME peephole optimization'
HCDB7263D2CEF: 'SME 피홀 최적화 수행'
# 'Perform ThinLTO end-to-end'
H303BC754B9A0: 'ThinLTO 종단 간 작업을 수행합니다'
# 'Perform ThinLTO importing using provided function summary index'
HC1B8CB3D2919: '제공된 함수 요약 색인을 사용하여 ThinLTO 통합을 수행합니다'
# 'Perform ThinLTO optimizations.'
H801619F35DAD: 'ThinLTO 최적화를 수행합니다.'
# 'Perform a single ThinLTO stage:'
H6083E399B9A6: 'ThinLTO 단계를 단일로 수행:'
# 'Perform both promotion and cross-module importing (requires -thinlto-index).'
H625E880C0440: '프로모션과 모듈 간 임포트를 모두 수행합니다 (옵션 -thinlto-index가 필요합니다).'
# 'Perform branch folding during placement. Reduces code size.'
HC83634EE199F: '배치 중에 가지 접기를 수행합니다. 코드 크기를 줄입니다.'
# 'Perform context sensitive PGO instrumentation'
H9FA2FCAD28BD: '맥락 감도형 PGO 앤스트루먼트 실행'
# 'Perform dummy load from authenticated address'
H53EA500A8E1C: '인증된 주소에서 가짜 로드를 수행합니다'
# 'Perform expensive assert validation on every query to Instruction Precedence Tracking'
HB66C9831C0D5: '모든 쿼리마다 Instruction Precedence Tracking에 대한 고비용 assert 검증을 수행합니다.'
# "Perform extra assertion checking to verify that PHINodes's hash function is well-behaved w.r.t. its isEqual predicate"
HC9E8890BCE7F: '추가적인 액서션 검사를 수행하여 PHINodes의 해시 함수가 isEqual predicate에 대해 잘 동작하는지 확인합니다'
# "Perform extra assertion checking to verify that SimpleValue's hash function is well-behaved w.r.t. its isEqual predicate"
H56A34E9BD071: '추가적인 액세션 검사를 수행하여 SimpleValue의 해시 함수가 isEqual 판정식에 대해 올바르게 동작하는지 검증합니다.'
# 'Perform frequent verification checks on nodes.'
H17FE3747FAAC: '노드에 대한 빈번한 검증 확인을 수행합니다.'
# 'Perform internalization driven by -exported-symbol (requires -thinlto-index).'
H1934C0B7F9D0: '-exported-symbol 옵션에 의해 주도되는 내부화를 수행합니다 ( -thinlto-index 옵션이 필요합니다).'
# 'Perform link through clang-sycl-linker via the target offloading toolchain.'
H3D0FA081F298: 'clang-sycl-링커를 타겟 오프로딩 툴체인을 통해 링크를 수행합니다.'
# 'Perform mandatory inlinings module-wide, before performing inlining'
HBFA39AA6F76F: '모듈 전체에서 인라인 수행 전에 필수 인라인을 강제로 수행합니다.'
# 'Perform optimizations based on pattern matching'
H48981223D558: '패턴 매칭을 기반으로 최적화를 수행합니다'
# 'Perform optimizations of matrix multiplications based on pattern matching'
H175644A4FF20: '패턴 매칭을 기반으로 하는 행렬 곱셈의 최적화를 수행합니다'
# 'Perform optimizations of tensor contractions based on pattern matching'
H07134EDA2398: '패턴 매칭 기반의 텐서 축약 최적화를 수행합니다'
# 'Perform pre-import promotion (requires -thinlto-index).'
HD57DCDC50753: 'pre-import promotion 수행 (옵션 -thinlto-index가 필요합니다).'
# 'Perform tail duplication during placement. Creates more fallthrough opportunities in outline branches.'
HF926F65659FB: '배치 중 꼬리 복제를 수행합니다. 윤곽 분기에서 더 많은 fallthrough 기회를 생성합니다.'
# 'Perform verification checks on CallingContextGraph.'
H0D2194DF6309: 'CallingContextGraph에 대한 검증 검사를 수행합니다.'
# 'Performs lazy compilation on whole module boundaries rather than individual functions'
H0286F9E0FE8F: '전체 모듈 경계에서 개별 함수 대신 지연 컴파일을 수행합니다'
# 'Permit merging of identical functions when optimizing.'
H3F2353AD4C4D: '최적화 시 동일한 함수를 병합할 수 있도록 허용합니다.'
# 'Phi Values Analysis'
H4E3B42E3B884: '파이 값 분석'
# 'Place ASan constructors in comdat sections'
H88C0022D413C: 'comdat 섹션에 ASan constructors를 배치합니다'
# 'Place Backedge Safepoints'
H8C4883CA47B7: '백엣지 안전 지점 배치'
# 'Place MSan constructors in comdat sections'
H3E7B76D6C9CA: 'comdat 섹션에 MSan 생성자를 배치합니다'
# 'Place all main program variables in static memory (otherwise scalars may be placed on the stack)'
HC378DD7FF55D: '메인 프로그램의 모든 변수를 정적 메모리에 배치해야 합니다(그렇지 않으면 스칼라 변수들이 스택에 배치될 수 있습니다)'
# 'Place constant objects with relocatable address values in the RO data section and add -bforceimprw to the linker flags (AIX only)'
HD2C46719D2EF: '재배치 가능한 주소 값을 가진 상수 객체를 RO 데이터 섹션에 배치하고 링커 플래그에 -bforceimprw를 추가하세요 (AIX 전용)'
# 'Place constants in the .rodata section instead of the .sdata section even if they meet the -G <size> threshold (MIPS)'
H509FF0828C91: '상수를 -G <크기> 임계값을 충족하더라도 .sdata 섹션 대신 .rodata 섹션에 배치합니다 (MIPS)'
# 'Place debug types in their own section (ELF Only)'
H73B21ADBA4FE: '디버그 타입을 별도 섹션에 배치 (ELF 전용)'
# 'Place each data in its own section'
H7C2A5E2E04CE: '각 데이터를 자체 섹션에 배치하십시오'
# 'Place each function in its own section'
H9BBADC5A5281: '각 함수를 별도의 섹션에 배치하십시오'
# "Place each function's basic blocks in unique sections (ELF Only)"
H517D3F2B0E57: '각 함수의 기본 블록을 고유한 섹션에 배치 (ELF 전용)'
# 'Place uninitialized global variables in a common block'
H97F2AD11B476: '초기화되지 않은 전역 변수를 공통 블록에 배치하십시오'
# 'Platform to use with LLJIT'
HAEF32BE4B3F4: 'LLJIT와 함께 사용할 플랫폼'
# 'Pointer to member.'
HDE1D650C630F: '멤버 포인터.'
# 'Pointer.'
H2EBACB6EF9AE: '포인터.'
# 'Polly - Calculate dependences'
H6CAD158D9763: '폴리 - 의존성 계산'
# 'Polly - Calculate dependences for all the SCoPs of a function'
H32F2275306BF: 'Polly - 함수의 모든 SCoPs에 대한 의존성 계산'
# 'Polly - Create LLVM-IR from SCoPs'
H64A957DE1EE7: '폴리 - SCoP로부터 LLVM-IR 생성'
# 'Polly - Create polyhedral description of Scops'
HFD5B7E2064CE: '폴리 - Scops의 다면체적 설명 생성'
# 'Polly - Create polyhedral description of all Scops of a function'
H3225EA9E728D: '폴리 - 함수의 모든 Scop의 다면체 설명을 생성'
# 'Polly - DeLICM/DePRE'
H209DA16A8BB4: '폴리 - DeLICM/DePRE'
# 'Polly - Detect static control parts (SCoPs)'
HFF16BBB95B79: 'Polly - 정적 제어 부분(SCoPs) 감지'
# 'Polly - Dump Function'
HF98ECB8A4F3A: 'Polly - 함수 덤프'
# 'Polly - Dump Module'
H406314AC52B6: '폴리 - 모듈 덤프'
# 'Polly - Dump polyhedral description of Scops optimized with the isl scheduling optimizer and the set of post-scheduling transformations is applied on the schedule tree'
H29D7996B3B49: 'Polly - isl 스케줄링 최적화기로 최적화된 Scop의 폴리edral 설명을 Dump하고, 스케줄 트리에 후 스케줄링 변환 집합을 적용합니다'
# 'Polly - Export Scops as JSON (Writes a .jscop file for each Scop)'
H20651143EB75: 'Polly - JSON 형식으로 Scop 내보내기 (각 Scop에 대해 .jscop 파일을 생성합니다)'
# 'Polly - Flatten schedule'
HB1962B7EDBD9: '폴리 - 스케줄 평평하게 만들기'
# 'Polly - Forward operand tree'
HBFECA734FD00: '폴리 - 정방향 연산자 트리'
# 'Polly - Generate an AST from the SCoP (isl)'
HDBF9CF6A0C48: 'Polly - SCoP( isl)로부터 AST 생성'
# 'Polly - Generate an AST of the SCoP (isl)'
H12CE909F63DA: 'Polly - SCoP의 AST 생성 (isl)'
# 'Polly - Import Scops from JSON (Reads a .jscop file for each Scop)'
H16E203839258: 'Polly - JSON에서 Scop 가져오기 (각 Scop에 대해 .jscop 파일을 읽음)'
# 'Polly - Interface to polyhedral analysis engine'
HEE4D2D43660E: '폴리 - 다면체 분석 엔진 인터페이스'
# 'Polly - Maximal static expansion of SCoP'
H0CA779A2D7D3: '폴리 - SCoP의 정적 확장 최대화'
# 'Polly - Optimize schedule of SCoP'
H377579EA76A0: '폴리 - SCoP의 스케줄 최적화'
# 'Polly - Prepare code for polly'
HA31E0A502467: 'Polly - polly를 위한 코드 준비'
# 'Polly - Print DeLICM/DePRE'
HE392A0315DF8: 'Polly - DeLICM/DePRE 출력'
# 'Polly - Print Scop import result'
H4A167D1D4274: 'Polly - 스코프 임포트 결과 출력'
# 'Polly - Print Scops of function'
H31ABAE6ABC4E: 'Polly - 함수의 scop 출력'
# 'Polly - Print Scops of function (with no function bodies)'
HF9B4E2CB9C70: '폴리 - 함수의 스코프 출력 (함수 본문 없음)'
# 'Polly - Print Simplify actions'
H5741448BF9F8: '폴리 - 간소화 작업 출력'
# 'Polly - Print dependences'
HD5CEBA14DA9B: 'Polly - 의존성 출력'
# 'Polly - Print dependences for all the SCoPs of a function'
HD7464B6EDE01: '폴리 - 함수의 모든 SCoPs에 대한 의존성 출력'
# 'Polly - Print flattened schedule'
H33EAB5733200: 'Polly - 평탄화된 스케줄 출력'
# 'Polly - Print forward operand tree result'
H7CD855EC5084: '폴리 - 전방 피연산자 트리 결과 출력'
# 'Polly - Print interface to polyhedral analysis engine analysis'
HF7F243A50BCB: 'Polly - 다면체 분석 엔진의 인터페이스를 출력'
# 'Polly - Print optimizer schedule of SCoP'
HB4511056F80D: '폴리 - SCoP의 최적화 스케줄 출력'
# 'Polly - Print polyhedral description of Scops'
HE3A4EE9454B0: 'Polly - 다면체적 Scop 설명 출력'
# 'Polly - Print polyhedral description of all Scops of a function'
H23C591077544: '폴리 - 함수의 모든 Scops의 polyhedral 설명 출력'
# 'Polly - Print static control parts (SCoPs)'
H2CB7C4BBD709: '폴리 - 정적 제어 부분(SCoPs) 출력'
# 'Polly - Print the AST from a SCoP (isl)'
H984A4B6D2819: 'Polly - SCoP에서 AST 출력 (isl)'
# 'Polly - Prune unprofitable SCoPs'
HB8C0844D69B4: '폴리 - 효율적이지 않은 SCoPs 제거'
# 'Polly - Remove dead iterations'
H67A46F65DA9E: '폴리 - 사용되지 않는 이터레이션 제거'
# 'Polly - Run canonicalization passes'
H0C8C62952E1F: 'Polly - 정규화 패스 실행'
# 'Polly - Simplify'
HE98E9DE36187: 'Polly - 간소화'
# 'Polly - View Scops of function'
HD3BFFB69003F: '폴리 - 함수의 Scop 보기'
# 'Polly - View Scops of function (with no function bodies)'
H8C7475C4A4E8: '폴리 - 함수의 스코프 보기 (본체가 없는 함수)'
# 'Polly Options'
H4116368BA8CD: '폴리 옵션'
# 'Pop up a window to show MISched dags after they are processed'
HAAFE046654B3: '처리된 MISched dags를 보여주기 위해 창을 띄웁니다'
# 'Pop up a window to show SUnit dags after they are processed'
HDD5439EA4C3E: '처리된 후 SUnit dag를 표시하기 위해 창을 띄웁니다'
# 'Pop up a window to show a dag displaying MBP layout and associated block frequencies of the CFG.'
HBC76A8873486: '창을 띄워 CFG의 관련 블록 빈도와 MBP 레이아웃을 표시하는 DAG를 보여줍니다.'
# 'Pop up a window to show a dag displaying how block frequencies propagation through the CFG.'
H5017224EFFF8: '창을 표시하여 CFG를 통해 블록 빈도가 전파되는 방식을 보여주는 DAG를 보여줍니다.'
# 'Pop up a window to show a dag displaying how machine block frequencies propagate through the CFG.'
H06EB3103BBDD: '창을 표시하여 CFG를 통해 전파되는 머신 블록 빈도의 흐름을 보여주는 dag를 보여줍니다.'
# 'Pop up a window to show dags before legalize'
HCEEBF08E9304: '팝업 창을 열어 legalize 전 DAG를 표시합니다'
# 'Pop up a window to show dags before legalize types'
H7DF81922AFEE: '타입 합법화 이전의 DAG를 보여주기 위해 창을 표시'
# 'Pop up a window to show dags before the first dag combine pass'
HD6B32ED73930: '첫 번째 dag combine 패스 이전의 dags를 보여주기 위해 창을 표시합니다'
# 'Pop up a window to show dags before the post legalize types dag combine pass'
H411955B7261A: '타입 합법화 후 DAG 결합 패스 전의 DAG를 표시하기 위해 창을 띄웁니다'
# 'Pop up a window to show dags before the second dag combine pass'
HC7BCA3632D13: '두 번째 dag 결합 패스 이전의 dag를 표시하기 위해 창을 표시합니다'
# 'Pop up a window to show edge bundle graphs'
H5831F520A8FB: '엣지 번들 그래프를 보여주기 위해 창을 띄웁니다'
# 'Pop up a window to show isel dags as they are selected'
HA52C2A41472F: '선택 시 isel dags를 보여주는 창을 표시합니다'
# 'Pop up a window to show sched dags as they are processed'
H1FD861E7E0A4: '처리되는 대로 sched dags를 표시하기 위해 창을 띄웁니다'
# 'Populate profile symbol list (only meaningful for -extbinary)'
HB40FFCA64E8B: '프로파일 심볼 목록을 생성(단, -extbinary 옵션과 함께 사용할 때 의미가 있음)'
# 'Position independent'
H3F7792F17E68: '위치 독립적'
# 'Post RA hazard recognizer'
H03992384B25F: 'RA 후 위험 인식기'
# 'Post RA top-down list latency scheduler'
H59EA1D628EE5: 'RA 이후 상향식 리스트 지연 스케줄러'
# 'Post reg-alloc list scheduling direction'
H4071BC55C6A4: '레지스터 할당 후 리스트 스케줄링 방향'
# 'Post-Dominator Tree Construction'
HEC3645FCF915: '후속 지배자 트리 구축'
# 'Post-RA pseudo instruction expansion pass'
H3AEF4966A271: 'RA 후 의사 명령어 확장 패스'
# 'PostRA Machine Instruction Scheduler'
H0087D700C0B6: 'PostRA 머신 명령어 스케줄러'
# 'PostRA Machine Sink'
H2B8A5A72B764: 'RA 후 머신 침강'
# 'Postfix to append to the import .jsop files.'
H00F609EA3C78: '수입 .jsop 파일에 추가할 접미사.'
# 'Potential PHI threshold per loop for PPC loop prep of DQ form'
HD78EEEDE2049: '각 루프당 DQ 형식의 PPC 루프 준비를 위한 잠재적 PHI 임계값'
# 'Potential PHI threshold per loop for PPC loop prep of DS form'
H88F3C7B998C1: 'PPC 루프 준비의 DS 형식을 위한 각 루프당 잠재적 PHI 임계값'
# 'Potential PHI threshold per loop for PPC loop prep of update form'
HFA306C3E0204: '업데이트 형식의 PPC 루프 준비를 위한 각 루프 당 잠재적 PHI 임계값'
# 'Potential common base number threshold per function for PPC loop prep'
H1CB6AA07DE6F: '함수 당 잠재적 공통 기반 숫자 임계값 (PPC 루프 준비용)'
# 'PowerPC Branch Selector'
H9BA07427B81D: 'PowerPC 분기 선택기'
# 'PowerPC CTR Loops Verify'
H6280529F23F2: 'PowerPC CTR 루프 검증'
# 'PowerPC CTR loops generation'
HFCFC8E19EA44: 'PowerPC CTR 루프 생성'
# 'PowerPC DAG->DAG Pattern Instruction Selection'
H52FD8AB73B79: 'PowerPC DAG->DAG 패턴 명령어 선택'
# 'PowerPC Early-Return Creation'
HFB276D43768D: 'PowerPC 조기 반환 생성'
# 'PowerPC Expand Atomic'
HE518E2C5903E: 'PowerPC 원자 연산 확장'
# 'PowerPC MI Peephole Optimization'
HD03B52E2308F: 'PowerPC MI 피리홀 최적화'
# 'PowerPC Pre-Emit Peephole'
H690293F011C6: 'PowerPC Pre-Emit 피프홀'
# 'PowerPC Reduce CR logical Operation'
H604BA96457F7: 'PowerPC CR 논리 연산 줄이기'
# 'PowerPC TLS Dynamic Call Fixup'
H754F83D11B51: 'PowerPC TLS 동적 호출 조정'
# 'PowerPC TOC Register Dependencies'
HBE3F61F91CCA: 'PowerPC TOC 레지스터 의존성'
# 'PowerPC VSX Copy Legalization'
HCE743C058611: 'PowerPC VSX 복사 합법화'
# 'PowerPC VSX FMA Mutation'
H934573D30FC1: 'PowerPC VSX FMA 변환'
# 'PowerPC VSX Swap Removal'
H61E16EA71951: 'PowerPC VSX 스왑 제거'
# 'Pre reg-alloc list scheduling direction'
HBAA66F24441A: '레지스터 할당 전 리스트 스케줄링 방향'
# 'Pre-ISel Intrinsic Lowering'
H2F5309EAAE70: 'Pre-ISel 내장 기능 하향 변환'
# 'Pre-RA optimizations'
H81B4ED48A8E1: '등록 할당 전 최적화'
# 'Pre-load dynamic libraries (e.g. language runtimes required by the ORC runtime)'
HDF44F8CD7956: '동적 라이브러리를 사전 로드(예: ORC 런타임에 필요한 언어 런타임 등)'
# 'Predicate conditions in read only loops'
H0D01A5F11CC3: '읽기 전용 루프 내의 조건식'
# 'Prefer add+cnt over addvl/inc/dec'
H791228095B74: 'add+cnt를 addvl/inc/dec 대신 사용하라'
# 'Prefer aligned allocation for C++ Coroutines'
HF3DEE91EAA7A: 'C++ 코루틴에 대해 정렬된 할당을 선호합니다'
# 'Prefer hex format for immediate values'
H5AF7A8CAAB05: '즉시 값에는 16진수 형식을 사용하는 것이 좋습니다'
# 'Prefer hex format when printing immediate values'
H641A692609DF: '즉시 값 출력 시 16진수 형식을 사용하는 것을 권장합니다'
# 'Prefer in-loop vector reductions, overriding the targets preference.'
HC3384EBFEDE5: '루프 내 벡터 감소를 선호하며, 타겟의 선호도를 무시합니다.'
# 'Prefer post-indexed addressing mode'
HFA137A1FDE64: '후 인덱싱 주소 지정 방식을 사용하는 것이 좋습니다'
# 'Prefer pre-indexed addressing mode'
HCF74AFA989EA: '전치 인덱싱 주소 모드를 선호하세요'
# 'Prefer predicated Move to CSEL'
H29D20CBEE6CD: '조건부 이동을 CSEL 대신 사용하는 것이 좋습니다.'
# 'Prefer predicating a reduction operation over an after loop select.'
HE552FE7410D6: '루프 이후의 선택보다 축소 연산에 조건을 걸기를 선호합니다.'
# 'Prefer translating all intrinsics into llvm.call_intrinsic instead of using dialect supported intrinsics'
H35AE35D12C89: '각 방언이 지원하는 인트리니크를 사용하는 대신 모든 인트리니크를 llvm.call_intrinsic으로 변환하는 것을 선호합니다.'
# 'Prefer whole register move for vector registers.'
HD64DE7AD7D41: '벡터 레지스터에 대해서는 전체 레지스터 이동을 선호합니다.'
# 'Prefetch write addresses'
HD84230748C7F: '쓰기 주소 미리 읽기'
# 'Prefix filenames with the main file'
HFC5DC735C294: '파일 이름 앞에 주 파일을 접두사로 추가하십시오'
# 'Prefix for feature names.'
H2B0C0B21A30C: '기능 이름 접두사.'
# 'Prefix for memory access callbacks'
H4F526B73B916: '메모리 접근 콜백의 접두사'
# 'Prefix of line code for repository.'
H1C11371CF193: '저장소를 위한 코드 라인 접두사입니다.'
# "Prefix to use for outputs (default: 'bugpoint')"
H51241093AFDE: "아웃풋에 사용할 접두사 (기본값: 'bugpoint')"
# "Prefix to use from check file (defaults to 'CHECK')"
HC4A6D5922731: "체크 파일에서 사용할 접두사 (기본값은 'CHECK')"
# "Prefixes for aliases that don't need to be renamed, separated by a comma"
H93C76DC96906: '리네임 되지 않아도 되는 별칭을 위한 접두사들, 콤마로 구분'
# "Prefixes for functions that don't need to be renamed, separated by a comma"
H8D84AAE61D99: '이름 변경이 필요 없는 함수들의 접두사, 쉼표로 구분'
# "Prefixes for global values that don't need to be renamed, separated by a comma"
H25F3716C6D6C: '리네이밍이 필요 없는 전역 값의 접두사들은 콤마로 구분됩니다'
# "Prefixes for structs that don't need to be renamed, separated by a comma"
HFF2FE350C63E: '변경되지 않아도 되는 struct의 접두어를 쉼표로 구분합니다'
# 'Preload commands from file and start interactive mode'
HF342699558DE: '파일에서 명령어를 미리 로드하고 인터랙티브 모드를 시작합니다'
# "Prepare '-aux-triple' only without populating '-aux-target-cpu' and '-aux-target-feature'."
H5F5A3F872C66: "옵션 '-aux-target-cpu'와 '-aux-target-feature'을 채우지 않고 '-aux-triple'만 준비합니다."
# 'Prepare DWARF exceptions'
H95C39A5915AA: 'DWARF 예외 준비'
# 'Prepare SjLj exceptions'
HCA47286F067B: 'SjLj 예외 준비'
# 'Prepare WebAssembly exceptions'
H90B1A43A5B08: 'WebAssembly 예외 준비'
# 'Prepare Windows exceptions'
H09ADD0F6BE1B: 'Windows 예외 준비'
# 'Prepare callbr'
H28D8A749A5F8: 'callbr 준비'
# 'Prepares for basic block sections, by splitting functions into clusters of basic blocks.'
H6AFC803DF7AB: '기본 블록 섹션을 준비하며, 함수를 기본 블록의 클러스터로 분할합니다.'
# 'Prepend header file paths with this prefix. If not specified, the files are considered to be relative to the header list file.'
HB8A4FB692FE7: '헤더 파일 경로 앞에 이 접두사를 추가합니다. 지정되지 않으면, 파일은 헤더 목록 파일에 상대적이라고 간주됩니다.'
# 'Preprocess to file'
HADD296905BBE: '파일로 사전 처리'
# 'Preprocess to stdout'
HB9E8D78ECAA1: '표준 출력으로 사전 처리'
# 'Preserve Comments in outputted assembly'
H6543E9060512: '출력된 어셈블리에 주석 유지'
# 'Preserve canonical loop structure (default = true)'
H9226DB4F030F: '정규적인 루프 구조를 유지합니다 (기본값 = true)'
# 'Preserve debug info in thunk when mergefunc transformations are made.'
HC15D6215FF01: 'mergefunc 변환이 이루어질 때 thunk 내의 디버그 정보를 보존합니다.'
# 'Preserve expressions in AST rather than dropping them when encountering semantic errors'
H606CF076FD66: 'AST에서 표현식을 유지하고 의미적 오류 발생 시 삭제하지 않음'
# 'Preserve line and column number when merging locations.'
H6B50620B43DC: '위치 병합 시 줄 및 열 번호를 유지합니다'
# 'Preserve line numbers'
HF7C338130FB4: '줄 번호 유지'
# 'Preserve order of LLVM use-lists when serializing'
HE297D90494BB: '시리얼화 시 LLVM 사용 목록의 순서를 유지합니다'
# 'Preserve path components'
HA8274603DA36: '경로 구성 요소 유지'
# 'Preserve subregisters in tied operands'
HB16CD82DFFE2: '바인드된 피연산자 내의 하위 레지스터를 보존하십시오'
# 'Preserve the type for recovery expressions when possible'
HB104FC8C2A4B: '가능한 경우 복구 표현式의 형을 유지하십시오'
# 'Preserve use-list order when writing LLVM assembly.'
HA8838E5FAEE3: 'LLVM 어셈블리를 작성할 때 use-list 순서를 유지합니다.'
# 'Preserve use-list order when writing LLVM bitcode.'
HED82044E4F6B: 'LLVM 비트코드를 작성할 때 사용 목록 순서를 유지합니다.'
# 'Pretend that scalable vectors are supported, even if the target does not support them. This flag should only be used for testing.'
HE0B0560A96EA: '확장 벡터를 지원하는 것처럼 가장합니다. 목표 플랫폼이 지원하지 않더라도. 이 플래그는 테스트 목적으로만 사용되어야 합니다.'
# 'Pretty print debug locations of instructions when dumping'
HFD520C9CFE2C: '덤피ング 중 명령문의 디버그 위치를 예쁘게 출력'
# 'Pretty print perf data (branch weights, etc) when dumping'
H25D67F8F93BF: 'dump할 때 성능 데이터(분기 가중치 등)를 예쁘게 출력'
# 'Pretty-print JSON'
HED0E5D700CC6: 'JSON 예쁘게 출력'
# 'Pretty-print JSON output'
HF19F323787A0: 'JSON 출력을 예쁘게 인쇄'
# 'Pretty-print JSON output in the trace'
HE76D2162F789: '추적의 JSON 출력을 예쁘게 포맷팅합니다'
# 'Prevent expanding floating point division in AMDGPUCodeGenPrepare'
H5221E44BB247: 'AMDGPUCodeGenPrepare에서 부동 소수점 나눗셈 확장 방지'
# 'Prevent expanding integer division in AMDGPUCodeGenPrepare'
HA00F77EDC803: '정수 나눗셈의 확장을 방지합니다. (AMDGPUCodeGenPrepare)'
# 'Prevent function(s) from being devirtualized'
HF36ABB428107: '함수(들)가 가상화되지 않도록 방지합니다'
# 'Prevent misexpect diagnostics from being output if the profile counts are within N% of the expected. '
HAB811F421D71: '프로파일 카운트가 예상값의 N% 범위 내에 있을 경우, 미스익스펙트 진단이 출력되는 것을 방지합니다.'
# "Prevent optimization remarks from being output if they do not have at least this profile count. Use 'auto' to apply the threshold from profile summary"
H80EFE9F96F6F: "최적화 주석이 이 프로파일 카운트보다 낮은 경우 출력을 방지합니다. 프로파일 요약에서 임계값을 적용하려면 'auto'를 사용하세요"
# 'Prevents emitting diagnostics when profile counts are within N% of the threshold..'
H77AE0CC1048E: '프로파일 카운트가 임계값의 N% 이내인 경우 진단 정보를 방출하지 않습니다..'
# 'Primary key when ordering logical view (default: line).'
H7BB0C9861C88: '논리적 뷰를 정렬할 때 기본 키(기본값: line).'
# 'Print (but do not run) the commands to run for this compilation'
HCEF688AF1304: '이 컴파일에 대한 실행 명령을 출력(실행은 하지 않음)'
# "Print Attributor's internal call graph"
H256F97E689ED: 'Attributor의 내부 호출 그래프 출력'
# 'Print DenseElementsAttrs with a hex string that have more elements than the given upper limit (use -1 to disable)'
H4B4EB65A8AF9: '주어진 상한보다 더 많은 요소가 있는 16진수 문자열로 DenseElementsAttrs를 출력 (비활성화하려면 -1을 사용하세요)'
# 'Print Enum list for this class'
HB3042274A9F1: '이 클래스의 Enum 목록 출력'
# 'Print ExecutionSession state after resolving entry point'
HA2AA771729BC: 'entry point를 해결한 후 ExecutionSession 상태 출력'
# 'Print ExecutionSession state before resolving entry point'
H66A839FE6545: '실행 세션 상태를 엔트리 포인트 해결 전에 출력'
# 'Print IR after each pass'
HA5EFB8CE8B9F: '각 패스 후 IR 출력'
# 'Print IR after specified passes'
H3D9D708F1675: '지정된 패스 이후 IR 출력'
# 'Print IR after the pass with this number as reported by print-pass-numbers'
HB20A8CE7B1FD: 'print-pass-numbers로 보고된 숫자를 사용하여 해당 패스 후에 IR을 출력합니다'
# 'Print IR before each pass'
HDA98FFA60DB4: '각 패스 전 IR을 출력'
# 'Print IR before specified passes'
H328B86DC8BAB: '지정된 패스 전에 IR을 출력'
# 'Print IR before the pass with this number as reported by print-pass-numbers'
H67F2CC34678A: '패스 실행 전 IR을 print-pass-numbers로 보고된 이 숫자와 함께 출력합니다'
# 'Print IR to path when opt-bisect-limit is reached'
H1CC46248A49A: 'opt-bisect-limit가 도달했을 때 경로에 IR을 출력'
# 'Print LLVM IR input to isel pass'
HB1E12014CD83: 'isel 패스에 대한 LLVM IR 입력을 출력합니다'
# 'Print MIR debug-locations'
H23CF1A75AA16: 'MIR 디버그-위치 출력'
# 'Print Machine Cycle Info Analysis'
H9577B97D25AE: '머신 사이클 정보 분석을 출력합니다.'
# 'Print Machine Uniformity Info Analysis'
HFCF3D928DF44: '머신 균일성 정보 분석 출력'
# 'Print Options'
H183A70DB44AF: '출력 옵션'
# 'Print SSA IDs using NameLocs as prefixes'
H17EB8F4CEEED: 'NameLocs를 접두사로 사용하여 SSA IDs 출력'
# "Print a '-passes' compatible string describing the pipeline (best-effort only)."
H4C4CBF86A7C9: "파이프라인을 설명하는 '-passes' 호환 문자열을 출력합니다(최선을 다하는 경우에만)."
# 'Print a template comparison tree for differing templates'
H94B203D5EC04: '다른 템플릿에 대해 템플릿 비교 트리를 출력합니다'
# 'Print absolute paths in diagnostics'
H3475474B9AF0: '진단 메시지에 절대 경로 출력'
# 'Print addresses of MachineInstrs when dumping'
H3F08CE170EBB: 'Dump 시 MachineInstrs의 주소를 출력합니다'
# 'Print addresses of instructions when dumping'
HF2156C7D4A91: 'Dump할 때 명령문의 주소를 출력합니다'
# 'Print all GPUs (default)'
HBE69208AFD33: '모든 GPU 출력 (기본값)'
# 'Print all cost kinds'
HCAA4E47DE719: '모든 비용 종류 출력'
# 'Print all hardware statistics'
H14BBD9376F77: '모든 하드웨어 통계를 출력'
# "Print all of Clang's warning options"
HF45E26CFBC96: 'Clang의 모든 경고 옵션을 출력합니다'
# 'Print all option values after command line parsing'
HB0F721DC4298: '명령행 해석 후 모든 옵션 값을 출력'
# 'Print all records to stdout (default)'
H8BF745CB973A: '표준 출력에 모든 레코드 출력 (기본값)'
# 'Print all results from files matching this regular expression.'
H37B62E065C22: '이 정규 표현식과 일치하는 파일의 모든 결과를 출력합니다.'
# 'Print all views including hardware statistics'
H8A87BEED0121: '하드웨어 통계를 포함한 모든 뷰를 출력합니다'
# 'Print allocation requests made to the memory manager by RuntimeDyld'
H36E2ACD7E011: 'RuntimeDyld에 의해 메모리 매니저에 요청된 할당 요청을 출력합니다'
# 'Print any external commands that are to be executed instead of actually executing them - for testing purposes.\n'
HF77F09852A60: '실행될 외부 명령어를 실제로 실행하는 대신에 출력합니다. - 테스트 목적으로.\n'
# 'Print architectural register names rather than the ABI names (such as r14 instead of sp)'
H9E57937A3E1F: '아키텍처 레지스터 이름을 ABI 이름 대신 출력합니다 (예: r14 대신 sp)'
# 'Print assembly as linked'
HF50C5F3BF962: '링크된 상태의 어셈블리 출력'
# 'Print assembly as parsed'
H75C25DD05B7B: '해석된 어셈블리를 출력합니다'
# 'Print attribute dependencies'
HDE5247667B07: 'attribute 의존성 출력'
# 'Print available passes that can be specified in -passes=foo and exit'
HE05D65950FB2: '사용 가능한 패스 중 -passes=foo 옵션으로 지정할 수 있는 목록을 출력하고 종료합니다'
# 'Print before passes that change them'
HAEB698616AF4: '변경하는 패스 이전에 출력'
# 'Print binary blobs using hex escapes'
H0160E60E08F5: '16진수 이스케이프를 사용하여 이진 블롭 출력'
# 'Print binary load events.'
H2F65BD41A1E8: '바이너리 로드 이벤트를 출력합니다.'
# "Print call graph to 'dot' file"
H699252A05887: "호출 그래프를 'dot' 파일에 출력합니다"
# 'Print canonical function name.'
H39DE0BCE8940: '정형化的 함수 이름을 출력합니다.'
# 'Print changed IRs'
HB7CE030FBB95: '변경된 IR 출력'
# 'Print cl.exe style /showIncludes to stdout'
H84DEF3CD15ED: '표준 출력에 cl.exe 스타일 /showIncludes를 출력합니다'
# 'Print command line.'
H1C5C42AF6D29: '명령 줄을 출력합니다.'
# 'Print critical path length to stdout'
H8F78BF714145: '표준 출력으로 critical path 길이 출력'
# 'Print debug info in MLIR output'
H6859C4B3FF46: 'MLIR 출력에 디버그 정보를 출력합니다'
# 'Print debug information.\n'
HB8A507E6D179: '디버그 정보를 출력합니다.\n'
# 'Print demangled function name'
HC4B0C0E810C3: '데멀글된 함수 이름 출력'
# 'Print detailed output about what is being run to stderr.'
HE984DCC7A8C4: '실행 중인 내용에 대한 상세한 출력을 stderr로 표시합니다.'
# 'Print diagnostic category'
HCF5E624088CE: '진단 범주 출력'
# 'Print directive pattern matches, or add them to the input dump\nif enabled.\n'
H928F89E57268: '디렉티브 패턴 일치 항목을 출력하거나 입력 덤프에 추가합니다.\n활성화 되었을 경우.\n'
# 'Print disassembled code.'
HDACEC7EBFD41: '디스어셈블된 코드를 출력합니다.'
# 'Print dispatch statistics'
H2DF0F56E2112: '디스패치 통계를 출력합니다'
# "Print dominance tree of function to 'dot' file"
HFDEAF60A0F86: "함수의 우세 트리를 'dot' 파일에 출력합니다"
# "Print dominance tree of function to 'dot' file (with no function bodies)"
H255806455D28: "함수의 도미네이스 트리를 'dot' 파일에 출력 (함수 바디 없음)"
# 'Print embed directives in -E mode in addition to normal output'
HA988C571D048: '일반 출력과 함께 -E 모드에서 임베드 지시문을 출력합니다'
# 'Print encoding information in the instruction info view'
HDDF771C744F8: '명령 정보 보기에서 인코딩 정보를 출력합니다'
# 'Print extra debugging information'
HFF9ED81B933D: '추가 디버깅 정보를 출력합니다'
# 'Print extra information about adaptors and pass managers'
H8E608CF10762: 'adaptors 및 pass managers에 대한 추가 정보를 출력합니다'
# 'Print final code'
H91C18F74D9CF: '최종 코드 출력'
# 'Print fix-its in machine parseable form'
H8FDA449E8857: '머신 파서 가능 형식으로 fix-its 출력'
# 'Print function to stderr'
H4E08D51481D2: '함수를 stderr로 출력'
# 'Print graphs around indirect CF instructions in DOT format.'
HF75F04A7E3C5: '간접 제어 흐름 명령문 주위의 그래프를 DOT 형식으로 출력합니다.'
# 'Print imported functions'
H3746D79A84CE: '수입된 함수 출력'
# 'Print include directives in -E mode in addition to normal output'
HD07C75D32665: '정상 출력에 더해 -E 모드에서 include 지시문을 출력합니다'
# 'Print index-based devirtualization messages'
HBF58405294ED: '인덱스 기반 디바이추얼리제이션 메시지를 출력합니다'
# 'Print info about included files to stderr'
H622C6A0F6DB5: '포함된 파일에 대한 정보를 stderr로 출력합니다'
# 'Print information about actions taken'
H1ED18B4AD272: '동작에 대한 정보를 출력합니다'
# 'Print information about the activities of Polly'
HCF30D81D0973: 'Polly의 활동에 대한 정보를 출력합니다'
# 'Print information for functions rejected for importing'
HBD21C28A83D7: '수입을 위해 거부된 함수에 대한 정보를 출력합니다'
# 'Print information helpful in diagnosing internal FileCheck\nissues, or add it to the input dump if enabled.  Implies\n-v.\n'
H651EBEE00CDE: '내부 FileCheck 문제 진단에 도움이 되는 정보를 출력하거나, 활성화 시 입력 덤프에 추가합니다. -v 옵션과 동일합니다.'
# 'Print instruction latencies as verbose asm comments'
HD27FB6BC6036: '명령어 레이턴시를 상세한 어셈블리 주석으로 출력'
# 'Print instruction tables'
H2620BE69E6DD: '명령어 테이블을 출력합니다'
# 'Print instruction tables with additional information: bypass latency, LLVM opcode, used resources'
HFB383E77CA64: '명령어 테이블에 추가 정보를 출력: 바이패스 지연 시간, LLVM opcode, 사용된 리소스'
# "Print instructions that the allocator wants to fuse, but the X86 backend currently can't"
HE530C7C7214A: '할당기가 융합하고 싶어 하는 지시문 중 X86 백엔드가 현재는 융합할 수 없는 것들을 출력합니다'
# 'Print internal analyzer statistics.'
HAE4856542BC1: '내부 분석기 통계 정보를 출력합니다.'
# 'Print legacy PassManager debugging information'
HDFED9BD864B2: '레거시 PassManager 디버깅 정보를 출력합니다'
# 'Print list of delta passes, passable to --delta-passes as a comma separated list'
H93E693FB4735: 'delta 패스 목록을 출력합니다. --delta-passes 옵션에 콤마(,)로 구분된 목록으로 전달할 수 있습니다'
# 'Print machine instrs after ISel'
H555E49FB33C1: 'ISel 후에 머신 명령어 출력'
# 'Print machine verifier errors on invalid reduction attempts triple'
HE100DF904ED4: '무효한 축소 시도 트리플 발생 시 머신 검증기 오류 출력'
# 'Print macro definitions in -E mode in addition to normal output'
H0486B7210917: '정상 출력과 함께 -E 모드에서 매크로 정의를 출력'
# 'Print macro definitions in -E mode instead of normal output'
HB1EFD9100CC5: '-E 모드에서 일반 출력 대신 매크로 정의를 출력합니다'
# "Print matching stats for each allocation context in this module's profiles"
H8ED3695B4B5D: '이 모듈의 프로파일에서 각 할당 컨텍스트에 대한 매칭 통계를 출력합니다.'
# 'Print memory access functions'
H2D490B90F012: '메모리 액세스 함수 출력'
# 'Print memory barrier information in the instruction info view'
H565E0827BDFD: '명령어 정보 보기에서 메모리 밸리드 정보를 출력합니다'
# 'Print module to stderr'
HFFEB1D6642AE: 'stderr에 모듈을 출력합니다'
# 'Print more information to dbgs about GlobalISel legalizer rules being verified'
H00897DED79CD: 'GlobalISel 정규화기 규칙 검증에 대한 추가 정보를 dbgs에 출력합니다'
# 'Print name of local stack variable'
H5190847365AF: '로컬 스택 변수의 이름 출력'
# 'Print non-default options after command line parsing'
HEA27B7232530: '명령행 해석 후 기본값이 아닌 옵션 출력'
# 'Print numeric register names rather than the ABI names (such as $r0 instead of $zero)'
H165530C50853: '수치형 레지스터 이름을 ABI 이름 대신 출력합니다(예: $zero 대신 $r0를 사용함)'
# 'Print only the CFG without blocks body'
H75782D2B7733: '블록 바디 없이 CFG만 출력'
# 'Print option name with mappable diagnostics'
H158CBF9FD24C: '매핑 가능한 진단과 함께 옵션 이름을 출력'
# 'Print out debug counter info after all counters accumulated'
H2CE0455E9D85: '모든 카운터가 누적된 후 디버그 카운터 정보를 출력합니다'
# 'Print out debug counter information after all counters have been accumulated'
H94A5B1103F3F: '모든 카운터가 누적된 후 디버그 카운터 정보를 출력합니다'
# 'Print out mismatched BFI counts after setting profile metadata The print is enabled under -Rpass-analysis=pgo, or internal option -pass-remarks-analysis=pgo.'
H3025AA257D2E: '프로파일 메타데이터를 설정한 후 불일치한 BFI 카운트를 출력합니다. 이 프린트는 -Rpass-analysis=pgo 옵션 또는 내부 옵션 -pass-remarks-analysis=pgo를 사용할 때 활성화됩니다.'
# 'Print out the non-match BFI count if a hot raw profile count becomes non-hot, or a cold raw profile count becomes hot. The print is enabled under -Rpass-analysis=pgo, or internal option -pass-remarks-analysis=pgo.'
HDD8F14466662: '핫 원시 프로파일 카운트가 노온해지거나, 콜드 원시 프로파일 카운트가 핫이 되는 경우 비일치 BFI 카운트를 출력합니다. 이 출력은 -Rpass-analysis=pgo 또는 내부 옵션 -pass-remarks-analysis=pgo 아래에서 활성화됩니다.'
# 'Print out the parsed ODS information from the input file'
H863FE61CF758: '입력 파일로부터 분석된 ODS 정보를 출력합니다'
# 'Print pass management debugging information'
H639A1D9CCF1A: '패스 관리 디버깅 정보를 출력합니다'
# 'Print pass names and their ordinals'
H333E30843F56: '패스 이름과 그 순번을 출력합니다'
# 'Print performance metrics and statistics'
HE4EAA5755D11: '성능 메트릭 및 통계 정보를 출력합니다'
# "Print postdominance tree of function to 'dot' file"
HB29C66E944CC: "함수의 포스트 도미넌스 트리를 'dot' 파일에 출력"
# "Print postdominance tree of function to 'dot' file (with no function bodies)"
HD6176265DDFA: "함수의 포스트 도미네이스 트리를 'dot' 파일에 출력 (함수 본문 없이)"
# 'Print pretty debug info in MLIR output'
H1D9ED83CA568: 'MLIR 출력에 보기 좋은 디버그 정보 표시'
# 'Print pseudo probe section and disassembled info.'
H32640273947C: '가짜 프로브 섹션과 디아셈블된 정보 출력'
# "Print regions of function to 'dot' file"
HA2F7AC936E9B: "'dot' 파일에 함수의 영역을 출력합니다"
# "Print regions of function to 'dot' file (with no function bodies)"
HB4D8B8B65FF0: "함수의 영역을 'dot' 파일에 출력(함수 바디 없음)"
# 'Print register file statistics'
HD3E0FCA5570D: '등록 파일 통계 정보 출력'
# 'Print registered symbol, section, got and stub addresses'
H4788FF394730: '등록된 심볼, 섹션, GOT 및 스탁의 주소를 출력합니다'
# 'Print retire control unit statistics'
HD5CFA03245CF: '리타이어 컨트롤 유닛 통계 출력'
# 'Print schedule DAGs'
HCD1F3A6E0736: '스케줄 DAG 목록 출력'
# 'Print scheduler statistics'
HEAC85495C43E: '스케줄러 통계를 출력합니다'
# 'Print setting flow sensitive branch probabilities'
H93BFBD2C1FA2: '플로우 감도 분기 확률 설정을 출력'
# 'Print source locations.'
H1D581A019738: '소스 위치를 출력합니다.'
# 'Print source range spans in numeric form'
H6EBB5160F7AF: '수치 형식으로 소스 범위 스팬을 출력합니다'
# 'Print statistic for the index in every input files'
H269BBBFD3979: '각 입력 파일의 인덱스에 대한 통계를 출력합니다'
# 'Print subprocess statistics'
HFA43D801ECBB: '부하 프로세스 통계 정보 출력'
# 'Print summary view (enabled by default)'
HC78BAF3172BC: '요약 뷰를 출력합니다 (기본 설정에서 활성화됨)'
# 'Print supported -march extensions (RISC-V, AArch64 and ARM only)'
HFE614E88285A: '지원되는 -march 확장 기능을 출력 (RISC-V, AArch64 및 ARM만 해당)'
# 'Print supported cpu models for the given target (if target is not specified,it will print the supported cpus for the default target)'
H83F7E7816369: '지정된 타겟에 대한 지원되는 CPU 모델을 출력합니다(타겟이 지정되지 않았다면 기본 타겟에 대한 지원 CPU를 출력합니다)'
# 'Print symbolic changes'
HEBF2FA11F574: '심볼릭 변경 내용 출력'
# 'Print the "preamble" of a file, which is a candidate for implicit precompiled headers.'
H70A29FD77B18: '파일의 "preamble"을 출력합니다. 이는 암시적 사전 컴파일 헤더의 후보가 됩니다.'
# 'Print the blame context (if possible) for BAD instructions. This specifies the number of lines of context to include, where zero disables this feature.'
HBD7D1281AF22: 'BAD 명령문에 대한 블레임 컨텍스트(가능한 경우)를 출력합니다. 이는 포함할 컨텍스트 라인 수를 지정하며, 0은 이 기능을 비활성화합니다.'
# 'Print the block frequency info.'
HC5D2B22203B4: '블록 빈도 정보를 출력합니다'
# 'Print the branch probability info.'
H9D987607E791: '분기 확률 정보를 출력합니다.'
# 'Print the canonical YAML for this file.'
HE1A3AA010C12: '이 파일의 표준 YAML을 출력합니다.'
# 'Print the compiler version'
HB74950BD8E88: '컴파일러 버전을 출력합니다'
# 'Print the current module after OpenMP optimizations.'
HF02AEAC96CD7: 'OpenMP 최적화 후 현재 모듈을 출력합니다.'
# 'Print the current module before OpenMP optimizations.'
H8661FCFF114F: 'OpenMP 최적화 전 현재 모듈을 출력합니다.'
# "Print the directory pathname containing Clang's runtime libraries"
HCF6BD300D146: 'Clang의 런타임 라이브러리가 들어 있는 디렉토리 경로를 출력합니다'
# 'Print the effective target triple'
H651D58C4EE40: '유효한 타겟 트리플을 출력합니다'
# 'Print the extensions enabled by the given target and -march/-mcpu options. (AArch64 and RISC-V only)'
HBF8F8BB9DED1: '지정된 타겟과 -march/-mcpu 옵션으로 활성화된 확장 기능을 출력합니다. (AArch64 및 RISC-V 전용)'
# 'Print the flags used for selecting multilibs (experimental)'
H99D8793DE319: '멀티리브 선택에 사용되는 플래그를 출력 (실험적)'
# 'Print the full library path of <file>'
H996FD2BF6EA4: '파일의 전체 라이브러리 경로를 출력합니다'
# 'Print the full program path of <name>'
H6425BA00826B: '이름의 전체 프로그램 경로를 출력합니다'
# 'Print the generic op form'
H393E4B90F6FC: '일반적인 연산자 형식을 출력합니다'
# 'Print the global id for each value when reading the module summary'
H017C8976AB50: '모듈 요약을 읽을 때 각 값에 대한 전역 ID를 출력합니다.'
# 'Print the instruction info view (enabled by default)'
HFDE24D0249FD: '명령어 정보 뷰를 출력합니다(기본값으로 활성화됨)'
# 'Print the internal representation of the AST as JSON.'
H4463E0E4D8B4: 'AST의 내부 표현을 JSON 형식으로 출력합니다.'
# 'Print the internal representation of the AST.'
H034FD53E1499: 'AST의 내부 표현을 출력합니다.'
# 'Print the last form of the IR before crash (use -print-on-crash-path to dump to a file)'
H05148AD74D0F: 'クラ시 전의 IR 최종 형태를 출력 (파일에 덤프하려면 -print-on-crash-path 옵션을 사용)'
# 'Print the last form of the IR before crash to a file'
H41B3ECBC245F: 'crash 직전의 IR 최종 형태를 파일에 출력합니다'
# 'Print the library path for the currently used compiler runtime library ("libgcc.a" or "libclang_rt.builtins.*.a")'
H1C5056AC3308: '현재 사용 중인 컴파일러 런타임 라이브러리의 라이브러리 경로를 출력합니다. (libgcc.a 또는 libclang_rt.builtins.*.a)'
# 'Print the list of headers to insert and remove'
H9F64205F2D86: '삽입 및 제거할 헤더 목록을 출력합니다'
# 'Print the list of registered dialects and exit'
H8D48045AF8B2: '등록된 방언 목록을 출력하고 종료합니다'
# 'Print the list of registered passes and exit'
HC59B7DDDC5DA: '등록된 패스 목록을 출력하고 종료합니다'
# 'Print the machine block frequency info.'
HD84FA75ACBC1: '머신 블록 빈도 정보를 출력합니다.'
# 'Print the matched nodes.'
H4BB21D1928B8: '일치하는 노드를 출력합니다.'
# 'Print the name of each compiled file'
HDCE85FDCBE9D: '각 컴파일된 파일의 이름을 출력합니다'
# 'Print the normalized target triple'
H96ECE7DAB2DE: '정규화된 타겟 트리플을 출력합니다'
# 'Print the output in json format'
H7346664F1361: 'JSON 형식으로 출력을 표시합니다'
# 'Print the output of crashing program'
H8E49BCDD2D2A: 'crashing program의 출력을 표시합니다'
# 'Print the output of the dependency directives source minimizer'
HF8EAF7DCE928: '의존성 지시문 소스 최소화기의 출력을 표시합니다'
# 'Print the overhead of checks matching this glob'
HC2F8104B88AF: '이 글로브에 해당하는 체크의 오버헤드를 출력합니다'
# 'Print the path for the C++ Standard library module manifest'
H8EDB3804EDF6: 'C++ 표준 라이브러리 모듈 매니페스트 경로 출력'
# 'Print the paths used for finding ROCm installation'
H5DE6FB91D815: 'ROCm 설치 경로를 찾기 위해 사용되는 경로를 출력합니다'
# 'Print the paths used for finding libraries and programs'
H88A6C4296147: '사용되는 라이브러리 및 프로그램을 찾기 위해 사용되는 경로를 출력합니다'
# 'Print the pipeline that will be run'
HB9A00F6CD048: '실행될 파이프라인을 출력합니다'
# 'Print the registered targets'
H0D2C6AE9215B: '등록된 타겟을 출력합니다'
# 'Print the resource directory pathname'
HA37C029422E4: '리소스 디렉토리 경로 이름을 출력합니다'
# 'Print the resource directory pathname that contains lib and include directories with the runtime libraries and MODULE files.'
HA7ED2E95EC04: '실행 시스템 라이브러리와 MODULE 파일이 있는 lib 및 include 디렉토리를 포함하는 리소스 디렉토리 경로명을 출력합니다.'
# 'Print the resource pressure view (enabled by default)'
HEECE83A65DB5: '리소스 압력 뷰를 출력합니다 (기본적으로 활성화됨)'
# 'Print the summary only.'
H174D6B098765: '요약 정보만 출력합니다.'
# 'Print the symbol being queried and all its relevant headers in\nJSON format to stdout:\n  {\n    "FilePath": "/path/to/foo.cc",\n    "QuerySymbolInfos": [\n       {"RawIdentifier": "foo",\n        "Range": {"Offset": 0, "Length": 3}}\n    ],\n    "HeaderInfos": [ {"Header": "\\"foo_a.h\\"",\n                      "QualifiedName": "a::foo"} ]\n  }'
H5CB3BBFB3D04: '조회한 심볼 및 관련 헤더 정보를 JSON 형식으로 표준 출력에 출력합니다:\n  {\n    "FilePath": "/path/to/foo.cc",\n    "QuerySymbolInfos": [\n       {"RawIdentifier": "foo",\n        "Range": {"Offset": 0, "Length": 3}}\n    ],\n    "HeaderInfos": [ {"Header": "\\"foo_a.h\\"",\n                      "QualifiedName": "a::foo"} ]\n  }'
# 'Print the timeline view'
H7E4B03837F1C: '타임라인 뷰를 출력합니다'
# 'Print the tokenization of the file.'
H0F40582164F4: '파일의 토큰화를 출력합니다.'
# 'Print to stdout'
H002EC692CF47: '표준 출력에 출력합니다'
# 'Print type inference debug logs'
H97D56E58C1ED: '타입 추론 디버그 로그를 출력합니다'
# 'Print unique SSA ID numbers for values, block arguments and naming conflicts across all regions'
H3CF739160E73: '모든 영역에 걸쳐 값, 블록 인수 및 이름 충돌에 대한 유니크 SSA ID 번호를 출력합니다'
# 'Print unique element ID'
H4EAB338925EE: '유일한 요소 ID 출력'
# 'Print users of operation results and block arguments as a comment'
HFE8B9CDAE8D0: '연산 결과 및 블록 인수의 사용자를 주석으로 출력'
# 'Print version information'
H2471C1D1E728: '버전 정보를 출력합니다'
# 'Print warnings as well as errors'
H5031BC87FCBE: '경고 메시지도 함께 표시합니다'
# 'Print with local scope and inline information (eliding aliases for attributes, types, and locations)'
H7DD376461997: '로컬 범위와 인라인 정보를 출력 (속성, 유형, 위치의 별칭을 생략함)'
# 'Printing a logical representation of low-level debug information.\n'
HC0290F8303A5: '저수준 디버그 정보의 논리적 표현을 출력합니다.\n'
# "Prints 'unknown' instructions that were handled heuristically. Use -msan-dump-strict-instructions to print instructions that could not be handled explicitly nor heuristically."
HBC7AE3CB843B: "히스토리컬하게 처리된 '알 수 없는' 명령어를 출력합니다. 명시적으로나 히스토리컬하게 처리할 수 없는 명령어를 출력하려면 -msan-dump-strict-instructions를 사용하십시오."
# 'Prints comments for instruction based on inline cost analysis'
H8F93FDBF8523: '인라인 비용 분석에 기반한 명령에 대한 주석을 출력합니다'
# 'Prints debug information for the new pass manager'
H2612FCB765F4: '새 패스 매니저에 대한 디버그 정보를 출력합니다'
# 'Prints full register names with percent'
HE6A6B46C9FA7: '퍼센트 기호와 함께 전체 레지스터 이름을 출력합니다'
# 'Prints full register names with vs{31-63} as v{0-31}'
HBBE64D4048A6: '전체 레지스터 이름을 표시하며 vs{31-63}을 v{0-31}로 표시합니다'
# 'Prints the blame context (if possible) for ALL instructions. This specifies the number of lines of context for non-BAD instructions (see --blame-context). If --blame-context is unspecified, it prints this number of contextual lines for BAD instructions as well.'
H1C7BC51D6E48: '모든 명령어에 대해 가능한 경우 blame 컨텍스트를 출력합니다. 이 옵션은 BAD가 아닌 명령어에 대한 컨텍스트 줄 수를 지정합니다 (참조: --blame-context). --blame-context가 지정되지 않았을 경우, BAD 명령어에 대해서도 이 수의 컨텍스트 줄을 출력합니다.'
# 'Prints the combined library module before the output'
HF27FB27BCDA7: '출력 전에 결합된 라이브러리 모듈을 출력합니다'
# 'Prints the pass pipeline and returns.'
HB0A215EA899E: '패스 파이프라인을 출력하고 반환합니다.'
# 'Prioritize loop cache cost'
H567449F48120: '루프 캐시 비용 우선'
# 'Prioritize the IVs order of each instruction'
HC3D79764BA67: '각 명령문의 IVs 순서 우선'
# 'Prioritize vectorization'
H12B49F99EBF6: '벡터화 우선'
# 'Probability value in the range [0.0, 1.0] of unconditional pseudo-random checks.'
HE60D8EB808AB: '0.0과 1.0 사이의 범위를 가진 조건 없는 의사 난수 검사의 확률 값.'
# 'Probability value in the range [0.0, 1.0] to keep instrumentation of a function. Note: instrumentation can be skipped randomly OR because of the hot percentile cutoff, if both are supplied.'
H055D3EE8123A: '함수의 인스트루먼테이션을 유지하기 위해 [0.0, 1.0] 범위의 확률 값입니다. 참고: 두 가지 모두가 제공될 경우, 인스트루먼테이션이 무작위로 건너뛸 수 있거나 뜨거운 백분위 절단으로 인해 건너뛸 수 있습니다.'
# 'Proceed with Loop Idiom Vectorize Pass, but do not convert byte-compare loop(s).'
H5DD9E25ED00B: 'Loop Idiom Vectorize Pass를 진행하지만, byte 비교 루프를 변환하지 않습니다.'
# 'Proceed with loop idiom recognize pass, but do not convert loop(s) to memcpy.'
H0FF75025AEC2: '루프 패턴 인식 패스를 진행하지만, 루프(들)를 memcpy로 변환하지는 않습니다.'
# 'Proceed with loop idiom recognize pass, but do not convert loop(s) to memset.'
H5ED765213633: '루프 아이디엄 인식 패스를 실행하지만, memset으로 루프(들)를 변환하지 않습니다.'
# 'Proceed with loop idiom recognize pass, but do not convert loop(s) to strlen.'
HF94C8F5C3643: '루프 아이디엄 인식 패스를 진행하지만, 루프(들)을 strlen으로 변환하지 않습니다.'
# 'Proceed with loop idiom recognize pass, enable conversion of loop(s) to wcslen.'
H3D374F7E71F0: '루프 아이디어 인식 패스를 진행합니다. wcslen으로의 루프 변환을 활성화합니다.'
# 'Process Id for the profiled executable binary.'
HEAA24D9E11FE: '프로파일링된 실행 파일의 프로세스 ID입니다.'
# 'Process Implicit Definitions'
H436E5B2FC994: '암시적 정의 처리'
# 'Process functions in a top-down order defined by the profiled call graph when -sample-profile-top-down-load is on.'
HCCB8730D9A20: '-sample-profile-top-down-load 옵션이 활성화되었을 때 프로파일링된 호출 그래프에 의해 정의된 상향식 순서에 따라 함수를 처리합니다.'
# 'Process scops that are unlikely to benefit from Polly optimizations.'
H97882415014C: 'Polly 최적화에서 혜택을 받기 어려운 scops를 처리합니다.'
# 'Process source files in fixed form'
H83D6F8A6F254: '고정 형식의 소스 파일 처리'
# 'Process source files in free form'
H00F60A25C21E: '프로세스 소스 파일을 free form 형식으로 처리합니다'
# 'Process trigraph sequences'
HE92D60C3DD89: '삼중문자 시퀀스 처리'
# 'Processor register names.'
H69E6140DD062: '프로세서 레지스터 이름.'
# 'Produce a faster access sequence for local-dynamic TLS variables where the offset from the TLS base is encoded as an immediate operand (AIX 64-bit only). This access sequence is not used for variables larger than 32KB.'
H96608A9C1D3A: '로컬-다이내믹 TLS 변수에 대해 TLS 기반에서의 오프셋이 즉시 연산자로 인코딩되는 더 빠른 접근 시퀀스를 생성 (AIX 64비트 전용). 이 접근 시퀀스는 32KB보다 큰 변수에는 사용되지 않습니다.'
# 'Produce a faster access sequence for local-exec TLS variables where the offset from the TLS base is encoded as an immediate operand (AIX 64-bit only). This access sequence is not used for variables larger than 32KB.'
HDB020B6BCE8A: 'local-exec TLS 변수에 대해 TLS 베이스로부터의 오프셋이 즉시 피연산자로 인코딩되는 경우 더 빠른 액세스 시퀀스를 생성합니다 (AIX 64비트 전용). 이 액세스 시퀀스는 32KB보다 큰 변수에는 사용되지 않습니다.'
# 'Produce gcov notes files (*.gcno)'
HA873BCAA45B3: 'gcov 노트 파일 생성 (*.gcno)'
# 'Produce progress indicator when performing measurements'
H2B5CD09D6FEE: '측정을 수행할 때 진행 표시기를 생성합니다'
# 'Produce relaxation hints for linkers to try optimizing PIC call sequences into direct calls (MIPS only)'
HA18E999EA6E6: '링커가 PIC 호출 시퀀스를 직접 호출로 최적화하려고 시도할 수 있도록 리랙시레이션 힌트를 생성 (MIPS만 해당)'
# "Produced object files can use all ELF features supported by this binutils version and newer. If -fno-integrated-as is specified, the generated assembly will consider GNU as support. 'none' means that all ELF features can be used, regardless of binutils support. Defaults to 2.26."
H0EBB90A612ED: "생성된 오브젝트 파일은 이 binutils 버전 및 이후 버전에서 지원하는 모든 ELF 기능을 사용할 수 있습니다. -fno-integrated-as가 지정되면 생성된 어셈블리가 GNU as 지원을 고려합니다. 'none'은 binutils 지원 여부와 관계없이 모든 ELF 기능을 사용할 수 있음을 의미합니다. 기본값은 2.26입니다."
# "Produced object files can use all ELF features supported by this binutils version and newer.If -no-integrated-as is specified, the generated assembly will consider GNU as support.'none' means that all ELF features can be used, regardless of binutils support"
H1E14DD582B2D: "생성된 객체 파일은 이 버전의 binutils 및 이후 버전에서 지원하는 모든 ELF 기능을 사용할 수 있습니다. -no-integrated-as 옵션이 지정된 경우, 생성된 어셈블리 코드는 GNU 어셈블러의 지원 여부를 반영합니다. 'none'은 binutils의 지원 여부와 무관하게 모든 ELF 기능을 사용할 수 있음을 의미합니다"
# 'Produces individual indexes for distributed backends.'
H3927BD641AFE: '분산 백엔드를 위한 개별 인덱스를 생성합니다.'
# 'ProfGen Options'
HA88661D355E6: 'ProfGen 옵션'
# "Profile action execution to a file, or stderr if  '-' is passed"
HF893EEFBCD55: "파일에 프로파일 실행 작업을 수행하거나, '-'가 지정되면 stderr로 출력합니다"
# 'Profile file loaded by -sample-profile'
HD83B6219FC6C: '프로파일 파일이 -sample-profile 옵션으로 로드되었습니다'
# 'Profile kind supported by show:'
H1EF9A7F6A57E: 'show가 지원하는 프로필 유형:'
# 'Profile kind:'
H8083370A6330: '프로파일 종류:'
# 'Profile remapping file loaded by -sample-profile'
H0C4B9EDC4542: '프로파일 리매핑 파일이 -sample-profile로 로드되었습니다'
# 'Profile summary info'
H60C73C1F9C77: '프로파일 요약 정보'
# 'Profile uses flow sensitive discriminators'
H238CF0A82CE7: '프로파일은 흐름 감도 구분자를 사용합니다'
# 'Profile with nested inlinee flatten out'
HDCD21980624B: '내재된 인라인 함수가 평평해진 프로파일'
# 'Prologue end.'
HCA56411EA86A: '프롤로그 종료.'
# 'Prologue/Epilogue Insertion'
H8D5DD8D22319: '프롤로그/에필로그 삽입'
# 'Prologue/Epilogue Insertion & Frame Finalization'
HA5A6E86B1573: '프롤로그/에필로그 삽입 및 프레임 최종화'
# 'Promote Memory to Register'
H8DCCB244621C: '메모리를 레지스터로 승격'
# 'Promote all vector constants'
HC242F7743ACD: '모든 벡터 상수 확장'
# 'Propagate attributes in index'
HA59CB2A030BF: '인덱스 내 속성 전파'
# 'Propagate labels from condition values of select instructions to results.'
H2CDE89FF2376: 'select 명령문의 조건 값에서 레이블을 전파하여 결과에 적용합니다.'
# 'Propagate non floating-point const stores as floating point values.For debugging purposes only'
HE1F8858006F6: '비 부동소수점 const 저장을 부동소수점 값으로 전파합니다. 디버깅 용도로만 사용합니다'
# 'Provide additional constraints on the context parameters'
H7259373CFB29: '컨텍스트 매개변수에 대한 추가 제약을 제공하십시오'
# 'Provide information about a particular module file'
HA7807B5E312C: '특정 모듈 파일에 대한 정보를 제공합니다'
# 'Provide minimal debug info in the object/executable to facilitate online symbolication/stack traces in the absence of .dwo/.dwp files when using Split DWARF'
HD5C39FAF7423: 'Split DWARF를 사용할 때 .dwo/.dwp 파일이 없는 경우 온라인 심볼화/스택 추적을 용이하게 하기 위해 객체/실행 파일에 최소한의 디버그 정보를 제공합니다'
# 'Provide the index produced by a ThinLink, required to perform the promotion and/or importing.'
HF72EED5DEBD8: 'ThinLink에 의해 생성된 인덱스를 제공해야 합니다. 이 인덱스는 승격(promotion)과/또는 가져오기(importing)를 수행하기 위해 필요합니다.'
# 'Prune dependences between unrelated Phi nodes.'
HF00163550893: '관련 없는 Phi 노드 간의 의존성을 제거합니다.'
# 'Prune loop carried order dependences.'
H49F00DC5D681: '루프 전달 순서 종속성 제거.'
# 'Put MODULE files in <dir>'
HEED5CC89CC67: 'MODULE 파일을 <dir>에 넣어주세요'
# 'Put crash-report files in <dir>'
H837FCDFF092D: 'crash 보고서 파일을 <dir>에 저장합니다.'
# 'Put each data item in its own section'
HF905C168CBCB: '각 데이터 항목을 각각의 섹션에 배치하십시오'
# 'Put each function in its own section'
H169F18C51BFF: '각 함수를 각각의 섹션에 넣어라'
# 'Put global and static data smaller than the limit into a special section'
H7B737FFA3469: '제한보다 작은 전역 및 정적 데이터를 특별한 섹션에 배치합니다'
# 'Put objects of at most <size> bytes into small data section (MIPS / Hexagon)'
HB5EE66FF14A5: '최대 <size> 바이트 크기의 객체를 소데이터 섹션에 배치합니다 (MIPS/Hexagon)'
# 'Putting Jump Table in function section'
H0F2B2856EA39: '함수 섹션에 점프 테이블을 배치합니다.'
# 'Qualified name of the symbol being queried.'
H4AFFA7C26BA4: '조회되는 심볼의 완전한 이름.'
# 'Qualified name to look up.'
H93CF54DB05CD: '조회할 자격 증명 이름.'
# 'Queries LTOModule::hasCtorDtor() on each IR file'
HDD169C16F456: '각 IR 파일에서 LTOModule::hasCtorDtor()을 조회합니다'
# 'Query a given symbol (e.g. "a::b::foo") in\ndatabase directly without parsing the file.'
H8F2B84E16EA3: '지정된 심볼(예: "a::b::foo")을 데이터베이스에서 직접 조회하며 파일을 분석하지 않습니다.'
# 'Query string to be fuzzy-matched'
HA5E343EDC113: '퍼지 매칭에 사용될 쿼리 문자열'
# 'Quotient that is obtained by dividing Nc, the parameter of themacro-kernel, by Nr, the parameter of the micro-kernel'
HFC3149B97C2A: 'Nc(마크로 커널의 매개 변수)를 Nr(마이크로 커널의 매개 변수)로 나눈 결과로 얻은 몫'
# 'R600 Clause Merge'
HFCF9C3C3445E: 'R600 절 병합'
# 'R600 Control Flow Finalizer'
H19DB6E58B0FB: 'R600 제어 흐름 최종 처리기'
# 'R600 Emit Clause Markers'
H668E900B8AFA: 'R600 절 마커 생성'
# 'R600 Expand Special Instrs'
H12D8DBCC740A: 'R600 특수 명령어 확장'
# 'R600 Packetizer'
H38622892495A: 'R600 패킷화기'
# 'R600 Vector Reg Merger'
H9C6C89BC6C1D: 'R600 벡터 레지스터 병합'
# 'R600ExpandSpecialInstrs'
HD068997DE698: 'R600특수명령어확장'
# "RISC-V 'interrupt' attribute '%0' requires extension '%1'"
H8A25210ABAD4: "RISC-V 'interrupt' 속성 '%0'은(는) 확장 '%1'이 필요합니다."
# "RISC-V 'interrupt' attribute contains invalid combination of interrupt types"
H3F0F8D14C6DB: "RISC-V 'interrupt' 속성이 잘못된 인터럽트 유형 조합을 포함하고 있습니다."
# 'RISC-V Assembly Printer'
H9361560AFA27: 'RISC-V 어셈블리 프린터'
# 'RISC-V CodeGenPrepare'
H405FA7A845BC: 'RISC-V 코드 생성 준비'
# 'RISC-V DAG->DAG Pattern Instruction Selection'
H1C9181DFD79E: 'RISC-V DAG->DAG 패턴 명령 선택'
# 'RISC-V Dead register definitions'
HC73090960463: 'RISC-V 사용되지 않는 레지스터 정의'
# 'RISC-V Fold Masks'
H0F357F81783D: 'RISC-V 마스크 접기'
# 'RISC-V Fold Memory Offset'
HBC0E6B2D64FC: 'RISC-V 메모리 오프셋 접기'
# 'RISC-V Indirect Branch Tracking'
H10B581240D72: 'RISC-V 간접 분기 추적'
# 'RISC-V Insert Read/Write CSR Pass'
H05452489D81B: 'RISC-V 읽기/쓰기 CSR 삽입 패스'
# 'RISC-V Insert VSETVLI pass'
H38C90053B8F4: 'RISC-V VSETVLI 삽입 패스'
# 'RISC-V Insert Write VXRM Pass'
H73DBEFBC725F: 'RISC-V 삽입 쓰기 VXRM 패스'
# 'RISC-V Landing Pad Setup'
HAD75D026A39E: 'RISC-V 랜딩 패드 설정'
# 'RISC-V Late Branch Optimisation Pass'
HED8417E9F658: 'RISC-V 늦은 분기 최적화 패스'
# 'RISC-V Load / Store Optimizer'
H10B62FA90EDD: 'RISC-V 로드/스토어 최적화'
# 'RISC-V Make Compressible'
H0497794478D9: 'RISC-V를 압축 가능하게 만들기'
# 'RISC-V Merge Base Offset'
HA38F1E005B04: 'RISC-V 병합 기준 오프셋'
# 'RISC-V Optimize W Instructions'
H2B91D1998005: 'RISC-V W 명령어 최적화'
# 'RISC-V Redundant Copy Elimination'
HD915B17CC89F: 'RISC-V 중복된 복사 제거'
# 'RISC-V VL Optimizer'
H811C35753CA5: 'RISC-V 변수 길이 최적화기'
# 'RISC-V VMV0 Elimination'
H474A6943E72F: 'RISC-V VMV0 제거'
# 'RISC-V Zacas ABI fix'
HF1D5344F95CB: 'RISC-V Zacas ABI 수정'
# 'RISC-V Zcmp Push/Pop optimization pass'
HD89E7CCB5461: 'RISC-V Zcmp Push/Pop 최적화 패스'
# 'RISC-V Zcmp move merging pass'
H9FBA8B3D1AEE: 'RISC-V Zcmp 이동 병합 패스'
# 'RISC-V atomic pseudo instruction expansion pass'
H3692DAF330DE: 'RISC-V 원자적 의사 명령어 전개 패스'
# 'RISC-V gather/scatter lowering pass'
H05AC68772FF6: 'RISC-V gather/scatter 변환 패스'
# 'RISC-V post-regalloc pseudo instruction expansion pass'
H7D576AB43EFF: 'RISC-V 등록 배정 후 의사 명령어 확장 패스'
# 'RISC-V pseudo instruction expansion pass'
H0A43861EEE99: 'RISC-V 의사 명령어 확장 패스'
# "RISC-V type %0 requires the '%1' extension"
HD2DE400562E4: "RISC-V 형식 %0은 '%1' 확장이 필요합니다"
# 'ROCm device library path. Alternative to rocm-path.'
H671F96D79AC7: 'ROCm 장치 라이브러리 경로. rocm-path의 대안입니다.'
# 'ROCm installation path, used for finding and automatically linking required bitcode libraries.'
HF802D566C208: 'ROCm 설치 경로로, 필요한 비트코드 라이브러리를 찾고 자동으로 연결하는 데 사용됩니다.'
# 'ROPI is not compatible with c++'
HF729D02F7368: 'ROPI는 c++와 호환되지 않습니다'
# 'RTDyld Options'
HE939F729D84E: 'RTDyld 옵션'
# 'Random hotness seed to use (0 to generate new seed)'
H8A5B93398F3C: '사용할 랜덤 해트니스 시드 (0을 지정하면 새로운 시드 생성)'
# 'Range reduction is disabled for complex arithmetic operations'
H2F5A5383A90A: '범위 축소는 복소수 산술 연산에 대해 비활성화되었습니다'
# 'Range reduction is enabled for complex arithmetic operations.'
H9F0817B3FD56: '복소 산술 연산에 대해 범위 감소가 활성화되었습니다.'
# 'Range to search for II'
HFC1D9F881BD5: 'II를 찾을 범위'
# 'Ratio of VGPRs to budget for promoting alloca to vectors'
H825278A853D1: 'alloca를 벡터로 승격시키기 위한 VGPR와 예산의 비율'
# 'Re-materialize load from stub in PIC mode'
H3683BABDE7E9: 'PIC 모드에서 스텁 로드 재물질화'
# 'ReachingDefAnalysis'
H10A4CB1F102D: '도달 정의 분석'
# 'Read commands from file'
HDC06C8ECE255: '파일에서 명령어를 읽음'
# 'Read function map names in indexed CodeGenData. Can be disabled to save memory and time for final consumption of the indexed CodeGenData in production.'
H1E1056B753A2: '인덱싱된 CodeGenData에서 함수 맵 이름을 읽습니다. 프로덕션 환경에서 인덱싱된 CodeGenData의 최종 소비 시 메모리와 시간을 절약하기 위해 비활성화할 수 있습니다.'
# 'Read specified document from input (default = 1)'
H289DB22297D5: '입력에서 지정된 문서를 읽음 (기본값 = 1)'
# 'Read summary from given YAML file before running pass'
HA5D8047CC861: '패스를 실행하기 전에 지정된 YAML 파일에서 요약 정보를 읽기'
# 'Read summary from given bitcode or YAML file before running pass'
HF2C570D041A3: '패스 실행 전 주어진 bitcode 또는 YAML 파일에서 요약 정보를 읽음'
# 'Read-write data relocatable, accessed relative to static base'
HDB933E15EC9A: '읽기-쓰기 데이터 재배치 가능, 정적 기반에 대한 상대적 접근'
# 'Reads and parses a basic block sections profile.'
HB98EF81EB7F2: '기본 블록 섹션 프로파일을 읽고 분석합니다.'
# 'Realign stack to the value of this flag (power of two)'
H85DCE488EFC2: '이 플래그 값(2의 거듭제곱)에 맞춰 스택을 재정렬합니다'
# 'Reassociate expressions'
H525BB5A9D397: '표현식 재결합'
# 'Rebalance address calculation trees to improve instruction selection'
HD14562B4E0A1: '주소 계산 트리를 재균형화하여 명령어 선택을 개선합니다'
# 'Rebalance address tree only if it is imbalanced'
HB25FBDDE88D4: '주소 트리가 불균형일 경우에만 재균형화합니다'
# 'Rebalance address tree only if this allows optimizations'
H15A2B09D172E: '최적화를 가능하게 하는 경우에만 주소 트리를 재균형화합니다'
# 'Reciprocal throughput'
H5BE31D7872D9: '역수 처리량'
# 'Recognize Hexagon-specific loop idioms'
H0CB87B633349: 'Hexagon 고유의 루프 패턴을 인식합니다'
# 'Recognize and construct Pascal-style string literals'
HA6AC1DFB5663: '파스칼 형식 문자열 리터럴 인식 및 생성'
# 'Recognize reduction patterns.'
H8EBBA21EF01B: '줄이기 패턴을 인식합니다.'
# 'Record GlobalISel rule coverage files of this prefix if instrumentation was generated'
HB262A353ECFE: '인스트루먼테이션이 생성되었을 경우 이 접두사의 GlobalISel 룰 커버리지 파일을 기록합니다'
# 'Record stack frames with tagged allocations in a thread-local ring buffer'
H1B5FE744704A: '태그가 있는 할당으로 스택 프레임을 기록하고 스레드 로컬 린 버퍼에 저장합니다'
# 'Record time trace'
H572EF7DA605F: '시간 추적 기록'
# 'Recursively extract all called functions'
H04C195C76643: '재귀적으로 모든 호출된 함수 추출'
# 'Redirect output to the specified file.'
H7E10ABCF17E8: '지정된 파일로 출력을 리다이렉트합니다.'
# 'Reduce named metadata without taking its type into account'
H057F6A50F385: '이름이 지정된 메타데이터를 그 유형을 고려하지 않고 줄이기'
# 'Reduce terminal output'
H77FB68186DA4: '터미널 출력 줄이기'
# 'Reduce the number of instrumented blocks'
HCA859F9847BF: '측정된 블록의 수를 줄입니다'
# 'Reduced priority compared to interactive work.'
H7591B998C026: '인터랙티브 작업과 비교했을 때 우선순위가 낮아졌습니다.'
# 'Refactoring options'
HF98C4D962B99: '리팩터링 옵션'
# 'Reference type.'
HECBDD73B4748: '참조 타입입니다.'
# 'Refrain from using FP whenever possible'
H567347A5F936: '가능한 한 FP 사용을 삼가해 주세요'
# 'Regalloc eviction policy'
HF2E6FE69E8A8: '레지스터 할당 이방 정책'
# 'Regalloc priority policy'
H20E1A4B298F4: 'Regalloc 우선순위 정책'
# 'Regard unreachable functions as possible devirtualize targets.'
HC7FBD9EBE035: '도달할 수 없는 함수를 가능한 가상화 해제 대상으로 간주합니다.'
# "Regex of name of op's to exclude (no filter if empty)"
HA7F3D7BB58EA: '제외할 연산자의 이름 정규 표현식 (빈 값일 경우 필터링하지 않음)'
# "Regex of name of op's to include (no filter if empty)"
H5284DD90C012: '포함할 연산자의 이름의 정규 표현식 (빈 값일 경우 필터 없음)'
# 'Register Allocation Scoring Pass'
H4ED04651AE8B: '리지스터 할당 스코어링 패스'
# 'Register Coalescer'
HAC4DFBDFBBCC: '레지스터 결합기'
# 'Register Usage Information Collector'
HE69ABB0B3B23: '레지스터 사용 정보 수집기'
# 'Register Usage Information Propagation'
H3B0328B5CFCB: '레지스터 사용 정보 전파'
# 'Register Usage Information Storage'
H9CFCD5C04174: '리지스터 사용 정보 저장'
# 'Register allocator to use'
H01245B8A9746: '사용할 레지스터 할당기'
# 'Register allocator to use for RVV register.'
H16A5AC5915C9: 'RVV 레지스터에 사용할 레지스터 할당기.'
# 'Register allocator to use for SGPRs'
H14FE52F5159B: 'SGPRs에 사용할 레지스터 할당기'
# 'Register allocator to use for VGPRs'
HB6E601BA3FB0: 'VGPR에 사용할 리지스터 할당기'
# 'Register allocator to use for WWM registers'
H2FF0F90865DC: 'WWM 레지스터에 사용할 레지스터 할당기'
# 'Register allocator to use for new pass manager'
H2F824F849DFC: '새 패스 매니저에 사용할 레지스터 할당기'
# 'Reject specializations whose codesize savings are less than this much percent of the original function size'
H6EAED91C8037: '원본 함수 크기의 이 퍼센트 미만인 코드 크기 절감량을 가진 특정화를 거부합니다'
# 'Reject specializations whose inlining bonus is less than this much percent of the original function size'
H6A8C88532B88: '원래 함수 크기의 이 백분율보다 적은 인라인 보너스를 가진 특수화를 거부함'
# 'Reject specializations whose latency savings are less than this much percent of the original function size'
H289ADC17A173: '지연 시간 절약량이 원본 함수 크기의 이 값의 백분율보다 적은 특수화를 거부합니다'
# 'Reject the profile if the mismatch percent is higher than the given number.'
H8455CF01EC30: '불일치 비율이 지정된 숫자보다 높으면 프로파일을 거부합니다.'
# 'Relation kind for the predicate.'
HA372CC9D1BF6: '예측에 대한 관계 유형.'
# 'Relative error tolerated'
HA4C6C4674C77: '허용되는 상대 오류'
# 'Relative frequency of outline region to the entry block'
H22B3E2A06E70: '엔트리 블록에 대한 아웃라인 영역의 상대 빈도'
# 'Relative hotness percentage threshold for indirect call promotion in proirity-based sample profile loader inlining.'
H046C25DB3427: '우선순위 기반 샘플 프로파일 로더 인라인 처리에서 간접 호출 승격을 위한 상대적 사용 빈도 백분율 임계값.'
# 'Relax checks of new-value validity'
H6708AC4FB40C: '신규 값 유효성 검사 완화'
# "Relax language rules and try to match the behavior of the target's native float-to-int conversion instructions"
HC867ACE28A09: '언어 규칙을 완화하고 타겟의 원래 부동소수점-정수 변환 명령어의 동작을 일치하도록 시도하라'
# 'Relax occupancy targets for kernels which are memory bound (amdgpu-membound-threshold), or Wave Limited (amdgpu-limit-wave-threshold).'
HF2EE3E994ED5: '메모리 제한(memory bound)인 커널 또는 웨이브 제한(Wave Limited)인 커널의 점유율 목표를 완화합니다 (amdgpu-membound-threshold, amdgpu-limit-wave-threshold).'
# 'Relax out of range conditional branches'
H0294D6B1AD74: '범위를 벗어난 조건부 분기를 완화합니다'
# 'Relocatable external references, non-relocatable code'
H5C17064AB794: '재배치 가능한 외부 참조, 재배치 불가능한 코드'
# 'Remapping file'
H3732B171A6F4: '파일 재매핑'
# 'Remark file utilities\n'
HF16F906278C7: '비고 파일 유틸리티\n'
# 'Remote execution (rsh/ssh) extra options'
H866585C76383: '원격 실행(rsh/ssh) 추가 옵션'
# 'Remote execution (rsh/ssh) host'
HBAFCAFBDA09E: '원격 실행 (rsh/ssh) 호스트'
# 'Remote execution (rsh/ssh) port'
HF897190244A2: '원격 실행(rsh/ssh) 포트'
# 'Remote execution (rsh/ssh) user id'
H34FEDDEF1D08: '원격 실행(rsh/ssh) 사용자 ID'
# 'Remote execution client (rsh/ssh)'
H9FB0D35F3462: '원격 실행 클라이언트 (rsh/ssh)'
# 'Remove .symtab section'
HDFF82FC1A75B: '.symtab 섹션 제거'
# "Remove CUDA/HIP offloading device architecture (e.g. sm_35, gfx906) from the list of devices to compile for. 'all' resets the list to its default value."
HC1BC07C832AB: "CUDA/HIP 오프로딩 장치 아키텍처(예: sm_35, gfx906)를 컴파일 대상 장치 목록에서 제거합니다. 'all'은 목록을 기본값으로 재설정합니다."
# 'Remove Loads Into Fake Uses'
H633E035AD42E: '가짜 사용으로 로드 제거'
# 'Remove Redundant DEBUG_VALUE analysis'
H9B54876630EC: '중복된 DEBUG_VALUE 분석 제거'
# 'Remove Sign and Zero Extends for Args'
H7F0FDF466871: '인수에 대한 부호 및 제로 확장 제거'
# "Remove an attribute from a function. This can be a pair of 'function-name:attribute-name' to remove an attribute from a specific function. For example -force-remove-attribute=foo:noinline. Specifying only an attribute will remove the attribute from all functions in the module. This option can be specified multiple times."
HC96183D47DE8: "함수에서 속성을 제거합니다. 특정 함수의 속성을 제거하려면 '함수 이름:속성 이름' 쌍을 지정할 수 있습니다. 예를 들어 -force-remove-attribute=foo:noinline를 지정할 수 있습니다. 속성만 지정하면 모듈 내 모든 함수에서 해당 속성이 제거됩니다. 이 옵션은 여러 번 지정할 수 있습니다."
# 'Remove dead machine instructions'
H849DB0ECAC7B: '사용되지 않는 머신 명령문을 제거합니다'
# 'Remove duplicate DecoderTable entries generated due to HwModes'
HA7463EA0ACB3: 'HwModes로 인해 생성된 중복된 DecoderTable 항목 제거'
# 'Remove pseudo-probe after sample profile annotation.'
H6C8C4BABBDBA: '샘플 프로파일 주석 후 의사 프로브 제거.'
# 'Remove redundant Address-Size override prefix'
H8CDB6DE4DE72: '중복된 Address-Size 오버라이드 접두사 제거'
# 'Remove redundant instructions'
HC432DEAE7361: '중복된 명령문을 제거하십시오'
# 'Remove the change description files regardless of successful\nmerging/replacing.'
HE8F5AA354FF8: '성공적인 통합/대체 여부와 관계없이 변경 설명 파일들을 제거합니다.'
# 'Remove unreachable blocks from the CFG'
H71C9E890BAC6: 'CFG에서 도달할 수 없는 블록을 제거합니다'
# 'Remove unreachable machine basic blocks'
H6EBEC50FE707: '도달할 수 없는 머신 기본 블록을 제거합니다'
# 'Removes debug compile units which reference to non-existing global constants'
HEC2FF74E6087: '사용되지 않는 전역 상수를 참조하는 디버그 컴파일 단위를 제거합니다'
# 'Removes empty basic blocks and redirects their uses to their fallthrough blocks.'
H1E3948BB5559: '비어 있는 기본 블록들을 제거하고, 그들의 사용처를 fallthrough 블록으로 재지정합니다.'
# 'Removes irreducible control flow'
HD2920C925B96: '비가역적 제어 흐름을 제거합니다'
# 'Removes range checks and sets br_table default targets'
H2B9F2567CD82: '범위 검사를 제거하고 br_table 기본 대상 설정합니다'
# 'Rename Independent Subregisters'
HE4B797E90A33: '독립 서브 레지스터 이름 변경'
# 'Rename Register Operands'
H1AB17AA29EA4: '레지스터 오퍼랜드 이름 변경'
# 'Rename Register Operands Canonically'
H9BD8A9C1263B: '정규적으로 레지스터 오퍼ænd를 재지정'
# 'Rename counter variable of a comdat function based on cfg hash'
HB71CC1C2B75A: 'cfg 해시를 기반으로 comdat 함수의 카운터 변수 리네임'
# 'Reorder instructions to use the WebAssembly value stack'
H6D195AC096F5: '명령어를 재정렬하여 WebAssembly 값 스택을 사용하십시오'
# 'Reorders blocks in topological order'
H903DAE6FC729: '위상 정렬 순서로 블록들을 재정렬합니다'
# 'Repack arrays that are non-contiguous in any dimension. If set to false, only the arrays non-contiguous in the leading dimension will be repacked'
H16B0416B17A1: '어떤 차원에서든 non-contiguous인 배열을 재구성합니다. 설정이 false로 되어 있으면, leading dimension에서 non-contiguous인 배열만 재구성됩니다'
# 'Repeat compilation N times for timing'
HD8053595EBB4: '시간 측정을 위해 N회 컴파일 반복'
# "Replace 'mul x, Const' with more effective instructions like SHIFT, LEA, etc."
HC54A5626311D: '‘mul x, Const’를 SHIFT, LEA 등과 같은 더 효율적인 명령어로 대체하세요.'
# 'Replace ARM non-local ADR instructions with ADRP'
H4558533FD5F3: 'ARM 비로컬 ADR 명령어를 ADRP로 대체합니다'
# 'Replace PHIs by their incoming values'
H49377A409B02: 'PHIs를 들어오는 값으로 대체'
# 'Replace all memory allocation / deallocation calls with hipManagedMalloc / hipFree equivalents'
HC778D804F89A: '메모리 할당/해제 호출을 모두 hipManagedMalloc/hipFree 대응 함수로 변경하세요'
# 'Replace intrinsics with calls to vector library'
H4BF82E4A463A: '인트리니크를 벡터 라이브러리 호출로 교체합니다'
# 'Replace narrow shifts with wider shifts.'
HF4525F5A5F2E: 'Replace narrow shifts with wider shifts.'
# 'Replace occurrences of __nvvm_reflect() calls with 0/1'
H9A0C0F0562E0: '__nvvm_reflect() 호출의 발생한 모든 경우를 0 또는 1로 교체합니다'
# 'Replace physical registers with virtual registers'
H2480E837105C: '물리 레지스터를 가상 레지스터로 대체합니다'
# 'Replace pointer out arguments with struct returns for non-private address space'
H8307543C4AE7: '비개인 주소 공간의 경우 포인터 아웃 인수를 struct 반환으로 교체'
# 'Replace returns with jumps to ``__x86_return_thunk`` (x86 only, error otherwise)'
H59B021D12978: '리턴을 ``__x86_return_thunk``로의 점프로 대체 (x86만 해당되며, 그렇지 않은 경우 오류)'
# 'Replace string for rename'
H722DD7E4F6B2: '이름 변경을 위한 문자열 대체'
# 'Replace target triples in input files with this triple'
H1FCD419A56EC: '입력 파일의 타겟 트리플을 이 트리플로 대체합니다'
# 'Replace the contents of the <from> file with the contents of the <to> file'
H96ECB37ACA86: 'from 파일의 내용을 to 파일의 내용으로 대체합니다'
# 'Replace unspecified target triples in input files with this triple'
H1555B263A14F: '입력 파일의 미지정 타겟 트리플을 이 트리플로 대체합니다'
# 'Replacement Options'
H70C1BA182651: '치환 옵션'
# 'Replay on functions that have remarks associated with them (default)'
H318EBF2AE0C8: '주석이 연결된 함수에 재생 적용 (기본값)'
# 'Replay on the entire module'
H7E3D6FBCD48C: '모듈 전체 재생'
# 'Replay previous inlining and adjust context profile accordingly'
HC992566EB323: '이전 인라인을 재생성하고 상황 프로필을 적절히 조정하라'
# 'Report Options'
HB03D5D95141E: '리포트 옵션'
# 'Report host JIT support'
HD82BFA66FA55: '호스트 JIT 지원 보고'
# 'Report missed transformations by optimization passes whose name matches the given POSIX regular expression'
H38AEDA823701: '최적화 패스 중 이름이 지정된 POSIX 정규식과 일치하는 항목의 놓친 변환을 보고합니다'
# 'Report top stacks within each thread id'
H9AC494BD87C5: '각 쓰레드 ID 내의 상위 스택 보고'
# 'Report top/bottom cycles when dumping SUnit instances'
H06A96EFDD1F5: 'SUnit 인스턴스를 dump할 때 상단/하단 사이클을 보고합니다'
# 'Report total allocation sizes of hinted allocations'
H900F23D3261D: '힌트된 할당의 전체 할당 크기 보고'
# 'Report transformation analysis from optimization passes whose name matches the given POSIX regular expression'
HB0E9E547E094: '최적화 패스 이름이 지정된 POSIX 정규 표현식과 일치하는 변환 분석을 보고합니다'
# 'Report transformations performed by optimization passes whose name matches the given POSIX regular expression'
H815014839294: '지정된 POSIX 정규 표현식과 일치하는 이름을 가진 최적화 패스에 의해 수행된 변환을 보고합니다'
# 'Reports layout used for print, compare and select.'
HF32D32507443: '출력, 비교 및 선택에 사용되는 레이아웃을 보고합니다.'
# 'Require & in extract patterns'
H9F971AAB4945: '추출 패턴에 &가 필요합니다'
# 'Require all positive matches to cover an entire input line.\nAllows leading and trailing whitespace if --strict-whitespace\nis not also passed.'
HA9004341F6EF: '모든 긍정 매치가 입력 줄 전체를 커버하도록 필요로 합니다.\n--strict-whitespace 옵션이 함께 전달되지 않았을 경우 선두와 후미의 공백을 허용합니다.'
# 'Require declaration of modules used within a module'
HE82DE2BF2262: '모듈 내에서 사용되는 모듈의 선언이 필요합니다'
# 'Require math functions to indicate errors by setting errno'
HE643AF2E91DD: '수학 함수가 오류를 표시하기 위해 errno를 설정해야 합니다'
# 'Require member pointer base types to be complete if they would be significant under the Microsoft ABI'
HF98EE3CAFBC8: 'Microsoft ABI 하에서 의미가 있는 경우 멤버 포인터 기반 유형은 완전해야 합니다'
# 'Require target function definition when promoting indirect calls'
H559562EE460E: '간접 호출을 최적화할 때 대상 함수 정의가 필요합니다'
# 'Reserve application registers (%g2-%g4)'
H9C435D2EFFB6: '애플리케이션 레지스터(%g2-%g4) 예약'
# "Reserve physical registers, so they can't be used by register allocator. Should only be used for testing register allocator."
HB426310B498F: '물리 레지스터를 할당 보류하여 레지스터 할당기에서 사용되지 않도록 합니다. 레지스터 할당기 테스트 용도로만 사용해야 합니다.'
# 'Reserve register r19 (Hexagon only)'
HDD745592B167: 'r19 레지스터 예약 (Hexagon 전용)'
# 'Reserve the G1 register (SPARC only)'
H20A9F2798EED: 'G1 레지스터를 예약합니다 (SPARC 전용)'
# 'Reserve the G2 register (SPARC only)'
HF2BF8B6A9338: 'G2 레지스터를 예약합니다 (SPARC 전용)'
# 'Reserve the G3 register (SPARC only)'
HEFD5459112F2: 'G3 레지스터를 예약합니다 (SPARC 전용)'
# 'Reserve the G4 register (SPARC only)'
HED0501965935: 'G4 레지스터를 할당합니다 (SPARC 전용)'
# 'Reserve the G5 register (SPARC only)'
H484BE92A9AAA: 'G5 레지스터 예약 (SPARC 전용)'
# 'Reserve the G6 register (SPARC only)'
H3E53244E7E33: 'G6 레지스터를 예약합니다 (SPARC 전용)'
# 'Reserve the G7 register (SPARC only)'
H8A30A1691BA0: 'G7 레지스터 예약 (SPARC 전용)'
# 'Reserve the I0 register (SPARC only)'
H42D22EDC8263: 'I0 레지스터를 예약합니다 (SPARC 전용)'
# 'Reserve the I1 register (SPARC only)'
HDC1C8763F288: 'I1 레지스터 예약 (SPARC 전용)'
# 'Reserve the I2 register (SPARC only)'
HF4C9D78BA277: 'I2 레지스터 할당 (SPARC 전용)'
# 'Reserve the I3 register (SPARC only)'
H6F74928ECDE5: 'I3 레지스터를 예약합니다 (SPARC 전용)'
# 'Reserve the I4 register (SPARC only)'
H96A8F3461A2B: 'I4 레지스터 할당 (SPARC 전용)'
# 'Reserve the I5 register (SPARC only)'
H2CC0E7760C25: 'I5 레지스터를 예약합니다 (SPARC 전용)'
# 'Reserve the L0 register (SPARC only)'
HE5E9B59351B3: 'L0 레지스터를 할당합니다 (SPARC 전용)'
# 'Reserve the L1 register (SPARC only)'
HC7B2711CCD38: 'L1 레지스터를 예약합니다 (SPARC 전용)'
# 'Reserve the L2 register (SPARC only)'
HE3E6D3620DCE: 'L2 레지스터를 예약합니다 (SPARC 전용)'
# 'Reserve the L3 register (SPARC only)'
H2079C316B58D: 'L3 레지스터를 예약합니다 (SPARC 전용)'
# 'Reserve the L4 register (SPARC only)'
HFDCEA5E83E9A: 'L4 레지스터를 예약합니다 (SPARC 전용)'
# 'Reserve the L5 register (SPARC only)'
H0DAAEFB046EA: 'L5 레지스터를 예약합니다 (SPARC 전용)'
# 'Reserve the L6 register (SPARC only)'
HA3AB8DC9562A: 'L6 레지스터를 예약 (SPARC 전용)'
# 'Reserve the L7 register (SPARC only)'
HCB368E5B3769: 'L7 레지스터를 예약합니다 (SPARC 전용)'
# 'Reserve the O0 register (SPARC only)'
H23D89F231DEE: 'O0 레지스터를 예약합니다 (SPARC 전용)'
# 'Reserve the O1 register (SPARC only)'
H565A40459A05: 'O1 레지스터를 예약합니다 (SPARC 전용)'
# 'Reserve the O2 register (SPARC only)'
H36A0BD878A7A: 'O2 레지스터를 예약합니다 (SPARC 전용)'
# 'Reserve the O3 register (SPARC only)'
H254E112FF4DF: 'O3 레지스터를 예약합니다 (SPARC 전용)'
# 'Reserve the O4 register (SPARC only)'
H1284739ABBC2: 'O4 레지스터를 예약합니다 (SPARC 전용)'
# 'Reserve the O5 register (SPARC only)'
H855A27DC8B76: 'O5 레지스터를 예약합니다 (SPARC 전용)'
# 'Reserve the a0 register (M68k only)'
HC6CC635B6FFE: 'a0 레지스터를 예약합니다 (M68k 전용)'
# 'Reserve the a1 register (M68k only)'
H1017DAEE99AB: 'a1 레지스터 예약 (M68k 전용)'
# 'Reserve the a2 register (M68k only)'
H7621CB376F01: 'a2 레지스터를 예약합니다 (M68k 전용)'
# 'Reserve the a3 register (M68k only)'
HE22C009182A1: 'a3 레지스터를 예약합니다 (M68k 전용)'
# 'Reserve the a4 register (M68k only)'
H3178F7022236: 'a4 레지스터를 예약합니다 (M68k 전용)'
# 'Reserve the a5 register (M68k only)'
HA629301B0BC6: 'a5 레지스터를 예약합니다 (M68k 전용)'
# 'Reserve the a6 register (M68k only)'
H94D9B1D39C5A: 'a6 레지스터를 예약합니다 (M68k 전용)'
# 'Reserve the d0 register (M68k only)'
H9890925E1B8B: 'd0 레지스터를 할당합니다 (M68k 전용)'
# 'Reserve the d1 register (M68k only)'
H9D44B760CA90: 'd1 레지스터를 예약합니다 (M68k 전용)'
# 'Reserve the d2 register (M68k only)'
H7A1C1C89C2E5: 'd2 레지스터를 예약합니다 (M68k 전용)'
# 'Reserve the d3 register (M68k only)'
H2D88664BB126: 'd3 레지스터를 예약합니다 (M68k 전용)'
# 'Reserve the d4 register (M68k only)'
HA604540B0E07: 'd4 레지스터를 예약합니다 (M68k 전용)'
# 'Reserve the d5 register (M68k only)'
H90F714B743C6: 'd5 레지스터 예약 (M68k 전용)'
# 'Reserve the d6 register (M68k only)'
H39C48EDA520F: 'd6 레지스터를 예약합니다 (M68k 전용)'
# 'Reserve the d7 register (M68k only)'
H02BEF5875762: 'd7 레지스터 예약 (M68k 전용)'
# 'Reserve the r9 register (ARM only)'
H32BC76F3A5B8: 'r9 레지스터를 예약합니다 (ARM 전용)'
# 'Reserve the x1 register (AArch64/RISC-V only)'
H017A3C6C7049: 'x1 레지스터를 예약합니다 (AArch64/RISC-V 전용)'
# 'Reserve the x10 register (AArch64/RISC-V only)'
H2D00D0C6D8F6: 'x10 레지스터를 예약합니다 (AArch64/RISC-V 전용)'
# 'Reserve the x11 register (AArch64/RISC-V only)'
H22733F8F5483: 'x11 레지스터를 예약합니다 (AArch64/RISC-V 전용)'
# 'Reserve the x12 register (AArch64/RISC-V only)'
HAA70056FA5B7: 'x12 레지스터 예약 (AArch64/RISC-V 전용)'
# 'Reserve the x13 register (AArch64/RISC-V only)'
H50BB54A67F09: 'x13 레지스터를 할당합니다 (AArch64/RISC-V 전용)'
# 'Reserve the x14 register (AArch64/RISC-V only)'
HE826489CFC34: 'x14 레지스터를 예약합니다 (AArch64/RISC-V 전용)'
# 'Reserve the x15 register (AArch64/RISC-V only)'
HC23E86C037A9: 'x15 레지스터 예약 (AArch64/RISC-V 전용)'
# 'Reserve the x16 register (AArch64/RISC-V only)'
H86953DAD10E7: 'x16 레지스터 예약(AArch64/RISC-V 전용)'
# 'Reserve the x17 register (AArch64/RISC-V only)'
HE02356B0C142: 'x17 레지스터를 예약합니다 (AArch64/RISC-V 전용)'
# 'Reserve the x18 register (AArch64/RISC-V only)'
HF2317F641E49: 'x18 레지스터를 예약합니다 (AArch64/RISC-V 전용)'
# 'Reserve the x19 register (AArch64/RISC-V only)'
H8F6A7020EC68: 'x19 레지스터를 예약합니다 (AArch64/RISC-V 전용)'
# 'Reserve the x2 register (AArch64/RISC-V only)'
HDEC6D50548DB: 'x2 레지스터를 예약합니다 (AArch64/RISC-V 전용)'
# 'Reserve the x20 register (AArch64/RISC-V only)'
H45338EFD5444: 'x20 레지스터 예약 (AArch64/RISC-V 전용)'
# 'Reserve the x21 register (AArch64/RISC-V only)'
HA93990937323: 'x21 레지스터를 예약합니다 (AArch64/RISC-V 전용)'
# 'Reserve the x22 register (AArch64/RISC-V only)'
H26B62228E618: 'x22 레지스터 예약 (AArch64/RISC-V 전용)'
# 'Reserve the x23 register (AArch64/RISC-V only)'
HF22114CBFC6D: 'x23 레지스터를 보존 (AArch64/RISC-V 전용)'
# 'Reserve the x24 register (AArch64/RISC-V only)'
H83F65EC51004: 'x24 레지스터를 예약합니다 (AArch64/RISC-V 전용)'
# 'Reserve the x25 register (AArch64/RISC-V only)'
H2B3946E5495E: 'x25 레지스터를 예약합니다 (AArch64/RISC-V 전용)'
# 'Reserve the x26 register (AArch64/RISC-V only)'
H094A3CECAC3C: 'x26 레지스터를 예약합니다 (AArch64/RISC-V 전용)'
# 'Reserve the x27 register (AArch64/RISC-V only)'
H061585C0784C: 'x27 레지스터를 예약합니다 (AArch64/RISC-V 전용)'
# 'Reserve the x28 register (AArch64/RISC-V only)'
H1DF10547E904: 'x28 레지스터를 예약합니다 (AArch64/RISC-V 전용)'
# 'Reserve the x29 register (AArch64/RISC-V only)'
H87F78D168B6D: 'x29 레지스터 예약 (AArch64/RISC-V에서만)'
# 'Reserve the x3 register (AArch64/RISC-V only)'
H725FF72DC894: 'x3 레지스터를 예약합니다 (AArch64/RISC-V 전용)'
# 'Reserve the x30 register (AArch64/RISC-V only)'
H59143D663AD6: 'x30 레지스터를 예약합니다 (AArch64/RISC-V 전용)'
# 'Reserve the x31 register (AArch64/RISC-V only)'
HFFDF93DA3671: 'x31 레지스터를 예약합니다 (AArch64/RISC-V 전용)'
# 'Reserve the x4 register (AArch64/RISC-V only)'
H9F239EBCD413: 'x4 레지스터를 예약합니다 (AArch64/RISC-V 전용)'
# 'Reserve the x5 register (AArch64/RISC-V only)'
H2EA831621531: 'x5 레지스터 할당 (AArch64/RISC-V 전용)'
# 'Reserve the x6 register (AArch64/RISC-V only)'
HCE48DE527FE3: 'x6 레지스터를 예약합니다 (AArch64/RISC-V에서만 사용 가능합니다)'
# 'Reserve the x7 register (AArch64/RISC-V only)'
HD802526DCF57: 'x7 레지스터를 예약합니다 (AArch64/RISC-V 전용)'
# 'Reserve the x8 register (AArch64/RISC-V only)'
H37CBBA5AD749: 'x8 레지스터를 예약합니다 (AArch64/RISC-V 전용)'
# 'Reserve the x9 register (AArch64/RISC-V only)'
H0CB86AACC5EE: 'x9 레지스터를 예약합니다 (AArch64/RISC-V에서만 사용 가능)'
# 'Reset machine function if ISel failed'
H7A45CC070EB3: 'ISel이 실패한 경우 머신 함수를 재설정합니다'
# 'Resolution-based LTO test harness'
HFC41C14199C7: '해상도 기반 LTO 테스트 허브'
# 'Resolve file paths relative to the specified directory'
HB397A2AE991E: '지정된 디렉토리를 기준으로 파일 경로를 해결합니다'
# 'Restore original linkage of globals prior to CodeGen'
H30AC23ACCA7B: 'CodeGen 이전에 글로벌의 원래 링크를 복구합니다.'
# 'Restore the default behavior of not embedding source text in DWARF debug sections'
H98E5316CC560: 'DWARF 디버그 섹션에 소스 텍스트를 내장하지 않는 기본 동작을 복원합니다'
# 'Restore the default behaviour of not generating long calls'
H49E0BF0F6145: '기본 동작을 복원하여 긴 호출을 생성하지 않음'
# 'Restrict DWARF features to those defined in the specified version, avoiding features from later versions.'
H3EFE36E674FA: '지정된 버전에 정의된 DWARF 기능만 사용하고, 이후 버전의 기능을 피합니다.'
# 'Restrict all prior -I flags to double-quoted inclusion and remove current directory from include path'
H3D88078880FD: '이전 모든 -I 플래그를 이중 따옴표 포함에 한정하고 현재 디렉토리를 인클루드 경로에서 제거합니다'
# 'Restrict code to those available for App Extensions'
H187919D11FCC: '앱 확장용으로 사용 가능한 코드만 제한합니다'
# 'Restrict range of B instructions (DEBUG)'
HC083C6F4C8EE: 'B 명령어 범위 제한 (DEBUG)'
# 'Restrict range of BPcc/FBPfcc instructions (DEBUG)'
H85B5CACDDD43: 'BPcc/FBPfcc 명령어의 범위 제한 (DEBUG)'
# 'Restrict range of BPr instructions (DEBUG)'
H0FAB44C44A31: 'BPr 명령어의 범위 제한 (DEBUG)'
# 'Restrict range of Bcc instructions (DEBUG)'
H400749DA0205: 'Bcc 명령어 범위 제한 (DEBUG)'
# 'Restrict range of CB instructions (DEBUG)'
HE052E990A1F8: 'CB 명령문의 범위 제한 (DEBUG)'
# 'Restrict range of CB[N]Z instructions (DEBUG)'
HCAA4E790CDDA: 'CB[N]Z 명령어의 범위를 제한합니다 (DEBUG)'
# 'Restrict range of TB[N]Z instructions (DEBUG)'
H8319D33A4041: 'TB[N]Z 명령어의 범위 제한 (DEBUG)'
# 'Restrict range of branch instructions (DEBUG)'
H80C66F8F6D0A: '분기 명령어의 범위 제한 (DEBUG)'
# 'Restrict range of loopN instructions (testing only)'
HDC7B8D8739B5: 'loopN 명령어의 범위 제한 (테스트 전용)'
# 'Restrict remat for statepoint operands'
H915A155B8538: 'statepoint 오퍼랜드에 대한 remat 제한'
# 'Restrict sanitizer coverage instrumentation exclusively to modules and functions that match the provided special case list, except the blocked ones'
HF665154F84D1: '샌타이저 커버리지 인스트루먼테이션을 차단된 항목을 제외하고 제공된 특수 사례 목록과 일치하는 모듈과 함수에 한정합니다'
# 'Restrict specifier.'
H0429709567D5: 'restrict 지정자.'
# 'Restrict to vendor:'
H32644C5851E5: '제한할 벤더:'
# 'Resume compilation after a specific pass'
H0C491338806A: '특정 패스 후 컴파일을 재개합니다'
# 'Resume compilation before a specific pass'
H1BE82678A264: '특정 패스 이전에 컴파일을 재개합니다'
# 'Retain macro definitions in /E mode'
HED02F9B02911: 'E 옵션에서 매크로 정의 유지'
# 'Return all structs in memory (PPC32 only)'
H1FA38C42BEE4: '메모리에 있는 모든 구조체를 반환 (PPC32 전용)'
# 'Return small structs in registers (PPC32 only)'
H2418E605C08F: '작은 구조체를 레지스터에 리턴 (PPC32 전용)'
# 'Reverse allocation order of local live ranges, such that shorter local live ranges will tend to be allocated first'
HB6873693AAD6: '로컬 라이브 레인지의 할당 순서를 역순으로 변경하여, 더 짧은 로컬 라이브 레인지가 먼저 할당될 가능성이 높아집니다'
# 'Rewrite Legacy Objective-C source to C++'
H756144AF61D7: '기존 Objective-C 소스를 C++로 재작성합니다'
# 'Rewrite Objective-C source to C++'
H97D2AC714B44: 'Objective-C 소스를 C++로 다시 작성'
# 'Rewrite Partial Register Uses'
HCE6FCECEDA90: '부분 레지스터 사용 재작성'
# 'Rewrite unaligned loads as a pair of aligned loads'
HB7B2CD3A9808: 'unaligned 로드를 aligned 로드의 쌍으로 재작성'
# 'Rewrite undef for PHI'
HD99A47BCF5A8: 'PHI를 위한 undef 재작성'
# 'Rewriter playground'
HE6E28450C65C: '리라이터 플레이그라운드'
# 'Rewriter to run'
HD27186628DE0: '실행할 리라이터'
# 'Right before the vectorizer'
HE1F20E3A6191: '벡터라이저 바로 직전'
# 'Root for relative input paths'
H44AB7F76C38B: '상대 입력 경로의 루트'
# 'Root.'
H81747C7D336A: '루트'
# "Roughly estimate the number of cycles that 'long latency' instructions take for targets with no itinerary"
HEEDD34050A74: '이터리너리가 없는 타겟에 대해 장 레이턴시 명령어가 소요하는 클럭 사이클 수를 대략적으로 추정합니다.'
# 'Round section sizes up to the section alignment'
HE0CCC8143863: '섹션 크기를 섹션 정렬까지 올림'
# 'Round-trip the IR after parsing and ensure it succeeds'
HB85D02D3E83D: '파싱 후 IR을 반복 처리하고 성공 여부를 확인합니다'
# 'Run GCN iterative scheduler for ILP scheduling (experimental)'
H1C7DB026D127: '실험용 GCN 반복 스케줄러로 ILP 스케줄링을 수행합니다'
# 'Run GCN iterative scheduler for minimal register usage (experimental)'
HEE1CE35E76A1: 'GCN 반복 스케줄러를 실행하여 최소 레지스터 사용량 (실험적)'
# 'Run GCN scheduler to maximize ilp'
HFF1542675A34: 'GCN 스케줄러 실행하여 ILP 최대화'
# 'Run GCN scheduler to maximize memory clause'
H7E5277DF8B56: 'GCN 스케줄러 실행하여 메모리 효율성 최대화'
# 'Run GCN scheduler to maximize occupancy'
H55CABD9DC534: 'GCN 스케줄러를 실행하여 점유율을 최대화합니다'
# 'Run GCN scheduler to maximize occupancy (experimental)'
H2546364E49BB: 'GCN 스케줄러를 실행하여 점유율을 최대화합니다 (실험용)'
# "Run Hexagon's custom scheduler"
HD930CA19D3B9: 'Hexagon의 커스텀 스케줄러 실행'
# 'Run MachineScheduler post regalloc (independent of preRA sched)'
H2FBC06B95112: 'MachineScheduler를 레지스터 할당 후 실행합니다 (preRA 스케줄러와 독립적입니다)'
# 'Run PGO context sensitive IR instrumentation'
HF2D51A482F76: 'PGO 컨텍스트-감도 IR 인스트루먼테이션 실행'
# 'Run Partial inlining pass'
H67505263F683: '부분 인라인 패스 실행'
# 'Run PowerPC PostRA specific scheduler'
H78B21F1324B5: 'PowerPC PostRA 전용 스케줄러 실행'
# 'Run PowerPC PreRA specific scheduler'
H394DF3D974FB: 'PowerPC PreRA 전용 스케줄러 실행'
# "Run R600's custom scheduler"
H72CC1BA879B5: 'R600의 맞춤형 스케줄러 실행'
# "Run SI's custom scheduler"
HD076B4B4194B: 'SI의 커스텀 스케줄러 실행'
# 'Run SimplifyCFG after expanding atomic operations to make use of cmpxchg flow-based information'
H0C90ACC17582: '원자 연산을 확장한 후 SimplifyCFG를 실행하여 cmpxchg 흐름 기반 정보를 활용하십시오'
# 'Run a global pre-inliner to merge context profile based on estimated global top-down inline decisions'
H5BFD65B47642: '전역 사전 인라인기를 실행하여 추정된 전역 상향식 인라인 결정에 기반하여 컨텍스트 프로파일을 병합합니다'
# 'Run a quick verification useful for regression testing'
H47645E615F6C: '리그레션 테스트에 유용한 빠른 검증을 실행합니다'
# 'Run all passes twice, re-using the same pass manager (legacy PM only).'
HD061B5F25379: '모든 패스를 두 번 실행하며 동일한 패스 매니저를 재사용합니다 (LEGACY PM만 해당).'
# 'Run amdgpu-regbankselect and amdgpu-regbanklegalize instead of regbankselect'
H5E9AEFE2CEF6: 'regbankselect 대신 amdgpu-regbankselect 및 amdgpu-regbanklegalize를 실행하십시오'
# 'Run an early inliner pass before Polly'
H54AEF889D7EF: 'Polly 전에 조기 인라인 패스 실행'
# 'Run analysis on specific function (for C++ include parameters in name)'
H3C6F4C08F518: '특정 함수에 분석을 실행 (C++의 경우 이름에 매개변수 포함)'
# 'Run asan instrumentation on LDS instructions lowered to global memory'
H9EB47AECF813: 'LDS 명령어가 전역 메모리로 변환될 때 asan 인스트루먼테이션 실행'
# 'Run cc1 in-process'
H9A5B5F4BB70B: '프로세스 내에서 cc1을 실행합니다'
# 'Run cleanup optimization passes after vectorization'
HD6645D1D40DA: '벡터화 후 정리 최적화 패스 실행'
# 'Run code-completion at each point (slow)'
HF356338EEEA8: '각 지점에서 코드 완성 실행(느림)'
# 'Run compiler only for specified passes (comma separated list)'
H08D41AC776F1: '지정된 패스에 대해서만 컴파일러를 실행합니다(쉼표로 구분된 목록)'
# 'Run early if-conversion'
H7D7CDDBB010E: '조기 if 변환 실행'
# 'Run everything twice, re-using the same pass manager and verify the result is the same.'
H7032E14A02BE: '동일한 패스 매니저를 재사용하여 모든 것을 두 번 실행하고, 결과가 동일함을 확인하세요.'
# 'Run in quiet mode'
HE4D4F6750673: '침묵 모드로 실행'
# 'Run indirect-call promotion for call instructions only'
H8967C75A35F7: '호출 명령문에 한하여 간접 호출 승격을 실행합니다'
# 'Run indirect-call promotion for invoke instruction only'
H4BE6E5960D01: '인보크 명령문에 한해서만 간접 호출 승격을 실행합니다'
# 'Run indirect-call promotion in LTO mode'
HD86948C0B3ED: 'LTO 모드에서 간접 호출 프로모션을 실행합니다'
# 'Run indirect-call promotion in SamplePGO mode'
HFD50D337E7CB: 'SamplePGO 모드에서 간접 호출 프로모션을 실행합니다'
# 'Run instrumented parse and dump the parsing log'
HB71F9FFCCF1A: '인스트루먼트된 파싱을 실행하고 파싱 로그를 덤프합니다'
# 'Run live interval analysis earlier in the pipeline'
H35280A9E9FE7: '파이프라인의 이른 단계에서 활성 구간 분석을 실행하십시오'
# 'Run loop-rotation in the prepare-for-lto stage. This option should be used for testing only.'
HF3A983596CA9: 'prepare-for-lto 단계에서 loop-rotation을 실행합니다. 이 옵션은 테스트 용도로만 사용해야 합니다.'
# 'Run many different optimization sequences on program to find bugs'
H612ED68363A4: '프로그램에 다양한 최적화 시퀀스를 적용하여 버그를 찾습니다'
# 'Run on all functions guaranteed to be beneficial'
HE1FEAE7130C4: '모든 함수에 대한 실행이 보장되는 이점이 있는 경우 실행'
# 'Run only CodeGen passes and translate FIR to LLVM IR'
H1A5B7B8CBB9C: 'CodeGen 패스만 실행하고 FIR을 LLVM IR로 변환합니다.'
# 'Run opt passes and codegen at O0'
H81E08FD2A09C: 'O0 최적화 수준에서 최적화 패스 실행 및 코드 생성을 수행합니다'
# 'Run opt passes and codegen at O1'
H474C4A7BA297: 'O1에서 opt 패스와 codegen을 실행합니다'
# 'Run opt passes and codegen at O2'
H3F347B539B5D: 'O2 최적화 수준에서 옵티마이저 패스와 코드 생성 실행'
# 'Run opt passes and codegen at O3'
H59E1D82AC2DB: 'O3 최적화 단계에서 opt 패스와 코드 생성기를 실행합니다'
# 'Run optimizations through valgrind'
HE1CE530E789B: 'valgrind를 통해 최적화를 수행합니다'
# 'Run pre-RA exec mask optimizations'
H3C26C74A3208: 'RA 전 실행 마스크 최적화를 실행합니다'
# 'Run pre-emit peephole optimizations.'
H4E182C271921: '이벤트 발생 전 피히OLE 최적화 실행'
# 'Run preprocessor, dump internal rep of tokens'
H45922516F2A2: '프리프로세서 실행, 토큰의 내부 표현을 내보내기'
# 'Run program Just-In-Time'
H7E1CCE7CE553: '즉시 실행(Just-In-Time)으로 프로그램 실행'
# 'Run static analysis engine'
H84EF43F50B25: '정적 분석 엔진 실행'
# 'Run the Fast mode (default mapping)'
HFFDBC5733152: '빠른 모드 실행 (기본 매핑)'
# 'Run the InputOuputTest action. Use for development and testing only.'
H0B55FCB86E0F: 'InputOuputTest 작업을 실행합니다. 개발 및 테스트 용도로만 사용합니다.'
# 'Run the LLVM verifier after every LLVM pass'
H136DF2CC2C10: 'LLVM 패스마다 LLVM 검증기를 실행합니다'
# 'Run the Loop vectorization passes'
H593612B18031: '루프 벡터화 패스 실행'
# 'Run the NewGVN pass'
HB971140FD767: 'NewGVN 패스를 실행합니다.'
# 'Run the SLP vectorization passes'
H568F60BAF50F: 'SLP 벡터화 패스를 실행합니다'
# 'Run the dead code elimination'
H072ED3EF8554: '데드 코드 제거를 실행합니다'
# 'Run the loop rotation transformation after PGO instrumentation'
H99F728F7A8D4: 'PGO 측정 도구 삽입 후 루프 회전 변환을 실행합니다'
# 'Run the pipeline stored in the reproducer'
HE376D46CB8F5: 'reproducer에 저장된 파이프라인을 실행합니다.'
# 'Run the preprocessor, parser and semantic analysis stages'
HC4E9B82FB80F: '프리프로세서, 파서 및 세미안틱 분석 단계를 실행합니다'
# 'Run the static analyzer'
H12842C536C2E: '정적 분석기를 실행합니다'
# "Run the vectorizer only on file paths that match any in the list of comma-separated regex's."
H4461671734B6: '콤마로 구분된 정규 표현식 목록 중 하나와 일치하는 파일 경로에 대해서만 벡터라이저를 실행합니다.'
# 'Run the verifier after each transformation pass'
H1D9EDA842E47: '각 변환 패스 후에 검증기를 실행합니다'
# 'Runs certain features (e.g. hover) at each point in the file. Somewhat slow.'
H5799AB4D2B8E: '파일의 각 위치에서 특정 기능(예: 호버)을 실행합니다. 약간 느립니다.'
# 'Runtime determined (OMP_SCHEDULE)'
H89C96D1C59A0: '런타임 결정 (OMP_SCHEDULE)'
# 'RuntimeDyld'
HB046756B987A: '런타임Dyld'
# 'Rvalue reference.'
H1006B6835AD7: 'rvalue 참조.'
# 'SCE targets (e.g. PS4)'
H24C3BD16186C: 'SCE 타겟 (예: PS4)'
# "SDK does not contain 'libarclite' at the path '%0'; try increasing the minimum deployment target"
HBB626BB3124D: "SDK 경로 '%0'에 'libarclite'가 없습니다; 최소 배포 대상을 높이십시오"
# "SDK settings were ignored as 'SDKSettings.json' could not be parsed"
HF609237E0BEB: "SDK 설정은 'SDKSettings.json' 파일을 해석하지 못했기 때문에 무시되었습니다"
# "SEH '__try' is not supported on this target"
H06D89FCA39AA: "SEH '__try'는 이 타겟에서 지원되지 않습니다."
# 'SI Fix SGPR copies'
HDB9A9026CAAF: 'SI SGPR 복사 수정'
# 'SI Fix VGPR copies'
H0BCE6618F46C: 'SI 수정 VGPR 복사'
# 'SI Fold Operands'
H2A817B2075A4: 'SI 피연산자 접기'
# 'SI Form memory clauses'
H4B75CB116FD5: 'SI 형식 메모리 절'
# 'SI Insert Hard Clauses'
H0DD59BBBCDBF: 'SI 강한 조건문 삽입'
# 'SI Insert Waitcnts'
HE04885DD4D00: 'SI Waitcnt 삽입'
# 'SI Load Store Optimizer'
H267BF961C532: 'SI 로드 스토어 최적화기'
# 'SI Lower WWM Copies'
HEE5F5720909B: 'SI WWM 복사 변환'
# 'SI Lower i1 Copies'
H5A7C0C9EA184: 'SI i1 복사 최적화'
# 'SI Memory Legalizer'
H0FE7146D147C: 'SI 메모리 합법화기'
# 'SI Optimize VGPR LiveRange'
H8E8730AB73D6: 'SI 최적화 VGPR 활성 범위'
# 'SI Peephole SDWA'
H2175B3F2C8E1: 'SI 피upil SDWA'
# 'SI Pre-allocate WWM Registers'
H4206E704E134: 'SI 사전 할당 WWM 레지스터'
# 'SI Shrink Instructions'
HBAF7A342AB3A: 'SI 축소 지시문'
# 'SI Whole Quad Mode'
HFFEC46D8FF13: 'SI 전체 쿼드 모드'
# 'SI insert s_cbranch_execz instructions'
HDC4FDC149030: 'SI s_cbranch_execz 명령어 삽입'
# 'SI lower SGPR spill instructions'
H3F5058866166: 'SI가 SGPR 스파일 명령어를 하향 변환합니다'
# 'SI lower control flow'
H9237847AA8B8: 'SI 제어 흐름 축소'
# 'SI optimize exec mask operations'
H3185D5441AB0: 'SI 실행 마스크 연산 최적화'
# 'SI optimize exec mask operations pre-RA'
H08D9A111CF96: 'SI 최적화: RA 전 실행 마스크 연산'
# 'SI peephole optimizations'
H1E6ED6F3445E: 'SI 미니홀 최적화'
# 'SI post-RA bundler'
H6FF7F01FEB53: 'SI 포스트-RA 결합기'
# 'SIMD Library for Evaluating Elementary Functions'
H4F65620685F5: 'SIMD 라이브러리: 기본 함수 평가를 위한'
# 'SME Peephole Optimization'
HB6505176089D: 'SME 피홀 최적화'
# 'SOURCEFILE'
H4695CE0F3CCA: '소스 파일'
# 'SPARC DAG->DAG Pattern Instruction Selection'
HEB1F489D0073: 'SPARC DAG→DAG 패턴 인스트럭션 선택'
# 'SPIR-V Regularizer'
HA3F8831A4FED: 'SPIR-V 정규화기'
# 'SPIR-V Shader capability'
H3F602E05A4A8: 'SPIR-V 쉐이더 기능'
# 'SPIR-V Translator compatibility mode'
HF7AF8DE76675: 'SPIR-V 번역기 호환 모드'
# 'SPIR-V capabilities to avoid if there are other options enabling a feature'
H9E1D87EB2349: '특정 기능을 활성화하는 다른 옵션이 있을 경우 피해야 할 SPIR-V 기능'
# 'SPIRV Assembly Printer'
H86AC0377A655: 'SPIRV 어셈블리 프린터'
# 'SPIRV NonSemantic.Shader.DebugInfo.100 emitter'
H16A3D5391B31: 'SPIRV 비어셈블리.Shader.DebugInfo.100 생성기'
# 'SPIRV convergence regions analysis'
HB13555632C11: 'SPIRV 수렴 영역 분석'
# 'SPIRV emit intrinsics'
H98E5DCAE36C2: 'SPIRV 내장 함수 생성'
# 'SPIRV legalize bitcast pass'
H9940486F0CC0: 'SPIRV 비트캐스트 적용 패스'
# 'SPIRV module analysis'
HD4BE1FB1BEF1: 'SPIRV 모듈 분석'
# 'SPIRV post legalizer'
HF7EB3FED68B9: 'SPIRV 후 합법화 단계'
# 'SPIRV pre legalizer'
HD74E28A77753: 'SPIRV 사전 합법화기'
# 'SPIRV prepare functions'
H17164FF97DDE: 'SPIRV 준비 함수'
# 'SPIRV split region exit blocks'
H2A782FAE48E8: 'SPIRV 영역 종료 블록 분할'
# 'SPIRV strip convergent intrinsics'
HDA93080C3642: 'SPIRV 수렴성 인트린스틱 제거'
# 'STOKE pass options'
H4008C64D6703: 'STOKE 패스 옵션'
# "SUBCOMMAND '"
H49B0CF838F29: "서브 명령 '"
# 'SUBCOMMANDS:\n\n'
H5B04A2FD12F5: '서브커맨드:\n\n'
# 'SVE vector type %0 cannot be used in a non-streaming function'
H9A5DD8A133CA: 'SVE 벡터 유형 %0는 스트리밍되지 않은 함수에서 사용할 수 없습니다'
# 'SVE vector type %0 cannot be used in a target without sve'
H9A595E01748A: 'SVE 벡터 유형 %0는 SVE가 없는 대상에서 사용할 수 없습니다'
# 'SYCL host compilation'
H61E19C960525: 'SYCL 호스트 컴파일'
# 'SYCL language standard to compile for.'
HD9004BF51D18: 'SYCL 언어 표준을 컴파일 목적으로 사용합니다.'
# 'Safe Stack instrumentation pass'
H90200C1EBE5D: 'Safe Stack 악기화 패스'
# 'Safepoint IR Verifier'
H55862F19A9A2: '안전 포인트 IR 검증기'
# 'Salvage stale MemProf profile'
H99E23DAB6376: '유효하지 않은 MemProf 프로파일 복구'
# 'Salvage stale profile by fuzzy matching and use the remapped location for sample profile query.'
H5090826C05A6: '퍼지 매칭을 통해 지난 프로파일을 회수하고, 샘플 프로파일 쿼리에 재매핑된 위치를 사용합니다.'
# 'Salvage unused profile by matching with new functions on call graph.'
H21FAAE36AF70: '사용되지 않은 프로파일을 호출 그래프의 새 함수와 매칭하여 회수합니다.'
# 'Same as "/diasdkdir <dir>/DIA SDK" /vctoolsdir <dir>/VC/Tools/MSVC/<vctoolsversion> "/winsdkdir <dir>/Windows Kits/10"'
HEB5E99FA660E: '다음과 동일합니다: "/diasdkdir <dir>/DIA SDK", /vctoolsdir <dir>/VC/Tools/MSVC/<vctoolsversion>, "/winsdkdir <dir>/Windows Kits/10"'
# 'Same as /Ob2'
H8A3F940C0EB5: '/Ob2와 동일합니다'
# 'Same as prepare-and-assemble-snippet, but also creates the full sequence that can be dumped to a file using --dump-object-to-disk'
H77B67B5A93B5: 'prepare-and-assemble-snippet와 동일하지만, --dump-object-to-disk 옵션을 사용하여 파일에 덤프할 수 있는 전체 시퀀스도 생성합니다'
# 'Same as prepare-measured-code, but also runs the measurement (default)'
H1BADD228E79D: 'prepare-measured-code와 동일하지만 측정을 실행합니다 (기본값)'
# 'Same as prepare-snippet, but also dumps an excerpt of the sequence (hex encoded)'
H329F8CE6355E: 'prepare-snippet와 동일하지만, 시퀀스의 일부(16진수 인코딩)를 덤프합니다'
# 'Same priority as other clangd work.'
H91A607AFE9B7: 'clangd의 다른 작업과 동일한 우선순위입니다.'
# 'Sample profile'
H06DF786C2443: '샘플 프로파일'
# 'Sanitize loads from memory.'
H0BDA70010B81: '메모리 로드 정화.'
# 'Sanitize loads from memory. When disable, no significant security is provided.'
H6827B410126B: '메모리 로드를 검증합니다. 비활성화 시, 중요한 보안 기능이 제공되지 않습니다.'
# 'Sanitizer Coverage. 0: none, 1: entry block, 2: all blocks, 3: all blocks and critical edges'
H6153504BE2F9: '샌타이저 커버리지. 0: 없음, 1: 엔트리 블록, 2: 모든 블록, 3: 모든 블록 및 비판적 엣지'
# 'Sanitizer Statistics Processing Tool'
H8F91AACBD96D: '정화기 통계 처리 도구'
# 'Sanitizer coverage type'
HB92F228F8C30: '샌타이저 커버리지 유형'
# 'Save ThinLTO generated object files using filenames created in the given directory.'
HC53E73C90B26: '지정된 디렉토리에서 생성된 파일명을 사용하여 ThinLTO로 생성된 객체 파일을 저장합니다.'
# 'Save ThinLTO temp files using filenames created by adding suffixes to the given file path prefix.'
H2E31524DF75E: '지정된 파일 경로 접두사에 접미사를 추가하여 생성된 파일 이름을 사용하여 ThinLTO 일시 파일을 저장합니다.'
# 'Save arguments passed by registers to ABI-defined stack positions'
H9D88220945B3: 'ABI에 정의된 스택 위치에 레지스터를 통해 전달된 인수 저장'
# "Save intermediate compilation results. <arg> can be set to 'cwd' for current working directory, or 'obj' which will save temporary files in the same directory as the final output file"
H353A183FAD67: "중간 컴파일 결과를 저장합니다. <arg>는 'cwd'를 현재 작업 디렉토리, 또는 'obj'를 최종 출력 파일과 동일한 디렉토리에 일시 파일을 저장하도록 설정할 수 있습니다."
# 'Save intermediate module file results when compiling a standard C++ module unit.'
HC4664B3AE862: '표준 C++ 모듈 단위를 컴파일할 때 중간 모듈 파일 결과를 저장합니다.'
# 'Save llvm statistics.'
H5CC2FF1F8C02: 'LLVM 통계 저장'
# 'Save selected temporary files. Cannot be specified together with -save-temps'
H9B274443882B: '선택된 일시 파일을 저장합니다. -save-temps와 함께 지정할 수 없습니다'
# 'Save statistics to the specified file'
H869C572478B5: '지정된 파일에 통계 정보를 저장합니다'
# 'Save subprocess statistics to the given file'
HBB6AB7F311A5: '지정된 파일에 서브프로세스 통계 정보를 저장합니다'
# 'Save temp files'
H4A37FEDB9D14: '임시 파일 저장'
# 'Save temporary files'
H57B3E4133626: '임시 파일을 저장합니다.'
# "Save temporary labels in the symbol table. Note this may change .s semantics and shouldn't generally be used on compiler-generated code."
H93DB00E1BEA2: '임시 레이블을 심볼 테이블에 저장합니다. 주의: 이는 .s 세마N틱스를 변경할 수 있으며, 일반적으로 컴파일러가 생성한 코드에 사용되어서는 안 됩니다.'
# 'Save the IR before running optimizations'
H4A2342002AC8: '최적화를 실행하기 전에 IR을 저장합니다'
# 'Save the device memory output of the replayed kernel execution.'
H6C85C6C553C1: '재생성된 커널 실행의 디바이스 메모리 출력을 저장합니다.'
# 'Scalable vectorization is available and favored when the cost is inconclusive.'
H66BDF3C7947B: '확장 가능한 벡터화는 비용이 명확하지 않을 때 사용 가능하며 선호됩니다.'
# 'Scalable vectorization is disabled.'
HEDA81875966D: '확장 벡터화가 비활성화되었습니다.'
# 'Scalar Evolution Analysis'
H8691C6809389: '스칼라 진보 분석'
# 'Scalar Replacement Of Aggregates'
HC922609C7C15: '집합体型의 Scalar 교체'
# 'Scalar independence heuristic'
H6DBF46490571: '스칼라 독립성 휴리스틱'
# 'ScalarEvolution-based Alias Analysis'
HB1C967D70FE5: '스칼라 진보 기반 별칭 분석'
# 'Scalarize unsupported masked memory intrinsics'
H4C20D577FF69: '지원되지 않는 마스킹된 메모리 인트린식을 스칼라화'
# 'Scalarize vector operations'
H31C547703795: '벡터 연산을 스칼래라이즈합니다'
# 'Scale the memop size counts using the basic  block count value'
H77E1E3932329: '기본 블록 카운트 값으로 memop 크기 카운트를 조정합니다'
# 'Scale to limit the cost of inline deferral'
HEB04CD55185A: '인라인 연기 비용 제한을 위한 비율 조정'
# 'Scavenge virtual registers inside basic blocks'
HDFF735ACD536: '기본 블록 내 가상 레지스터 재활용'
# 'Schedule VSX FMA instruction mutation early'
HCC0329BA7D34: 'VSX FMA 명령문 변형을 조기 스케줄링'
# 'Schedule bottom-up for max ILP'
HD1699FACAF31: '최대 ILP를 위해 하향식 스케줄링'
# 'Schedule bottom-up for min ILP'
H10AC8BD5ECDA: '최소 ILP를 위해 하향식 일정 처리'
# 'Scheduling type of parallel OpenMP for loops'
H999BCCD4C603: '병렬 OpenMP for 루프의 스케줄링 유형'
# 'Scope contributions to the debug information.'
H9BF0B0DDBE12: '디버그 정보에 대한 범위 기여.'
# 'Scope kind to use when printing scopes.'
H494C78291AB2: '스코프를 출력할 때 사용할 스코프 유형.'
# 'Scope of graph to export to dot'
H9536D6B1D873: 'dot에 내보낼 그래프의 범위'
# 'Scoped NoAlias Alias Analysis'
HB6BD5D72C4B3: '범위별 별칭 없음 별칭 분석'
# 'Scopes.'
H4E6EE0359B5C: '범위.'
# 'Search $prefix$file for executables, libraries, and data files. If $prefix is a directory, search $prefix/$file'
H6DC87438E4A7: '실행 파일, 라이브러리 및 데이터 파일을 찾기 위해 $prefix$file을 검색합니다. $prefix가 디렉토리인 경우 $prefix/$file을 검색합니다.'
# 'Search elements matching the given pattern.'
H98914CD94E9A: '지정된 패턴과 일치하는 요소를 검색합니다.'
# 'Search even non-imported modules to resolve references'
H1FD982ACF76B: '참조를 해결하기 위해 import되지 않은 모듈까지 검색합니다'
# 'Search for the GCC installation with the specified triple.'
H74F06477D6B9: '지정된 triple과 일치하는 GCC 설치를 검색합니다.'
# 'Section-specific Dump Options'
H9E36553E678B: '섹션별 덤프 옵션'
# 'Seed for the random number generator'
H9C3EECBF2BE5: '난수 생성기의 시드'
# 'Seed used for randomness'
H228A43C8FFBC: '난수 생성에 사용된 시드'
# 'Select DPP or Iterative strategy for scan'
HE53499864EE5: '스캔을 위한 DPP 또는 Iterative 전략을 선택하세요'
# 'Select Options'
HD84BE9DE2F9E: '옵션 선택'
# 'Select Windows run-time library'
HAC106D381AC2: 'Windows 런타임 라이브러리 선택'
# 'Select custom AMDGPU scheduling strategy.'
H64E4378BB72D: '사용자 지정 AMDGPU 스케줄링 전략을 선택합니다.'
# 'Select label scheme for branch control-flow architecture protection'
H7B3CA40CA6B3: '분기 제어 흐름 아키텍처 보호를 위한 라벨 스키마를 선택하세요'
# "Select math operations' runtime behavior:"
HBD0952A00DD6: '수학 연산의 런타임 동작을 선택합니다:'
# 'Select return address signing scope'
H4F99B374ECF5: '리턴 어드레스 서명 범위 선택'
# 'Select straight-line speculation hardening scope (ARM/AArch64/X86 only). <arg> must be: all, none, retbr(ARM/AArch64), blr(ARM/AArch64), comdat(ARM/AArch64), nocomdat(ARM/AArch64), return(X86), indirect-jmp(X86)'
H7FE74692FDC9: '직선형 추측 강화 범위를 선택합니다 (ARM/AArch64/X86 전용). <arg>는 다음 중 하나여야 합니다: all, none, retbr(ARM/AArch64), blr(ARM/AArch64), comdat(ARM/AArch64), nocomdat(ARM/AArch64), return(X86), indirect-jmp(X86)'
# 'Select target instructions out of generic instructions'
H687BF304766B: '일반적인 명령문 중에서 타겟 명령문을 선택합니다'
# 'Select the HWAddressSanitizer ABI to target (interceptor or platform, default interceptor). This option is currently unused.'
H2E53C4CE5E14: 'HWAddressSanitizer ABI를 선택합니다 (interceptor 또는 platform, 기본값 interceptor). 이 옵션은 현재 사용되지 않습니다.'
# "Select the SIMD extension(s) to be enabled in LoongArch either 'none', 'lsx', 'lasx'."
H58773894FD9F: "LoongArch에서 활성화할 SIMD 확장 기능을 선택하십시오. 'none', 'lsx', 'lasx' 중 하나를 선택할 수 있습니다."
# 'Select the asm variant (integer) to use for output (3: unspecified)'
H269BE00B3354: '출력에 사용할 asm variant(정수)를 선택하세요 (3: 지정되지 않음)'
# 'Select the assembly style for input'
HC379BD26B358: '입력에 사용할 어셈블리 스타일을 선택합니다'
# "Select the container format for clang modules and PCH. Supported options are 'raw' and 'obj'."
H35A81EACF6D7: "clang 모듈과 PCH를 위한 컨테이너 형식을 선택하세요. 지원되는 옵션은 'raw'와 'obj'입니다."
# 'Select the frame chain model used to emit frame records (Arm only).'
H6E15DFB39F91: '프레임 레코드 생성에 사용되는 프레임 체인 모델 선택 (Arm 전용)'
# 'Select the kind of output desired'
H4B7026DCAB45: '원하는 출력 형식을 선택해 주세요'
# 'Select the mode of detecting stack use-after-return in AddressSanitizer'
H18AC10CFE63E: 'AddressSanitizer에서 스택 use-after-return 감지 모드를 선택하세요'
# 'Select the scheduling optimizer'
HF3643F4F750F: '스케줄링 최적화기 선택'
# 'Select the vectorization strategy'
HF0DE7753D578: '벡터화 전략을 선택합니다'
# 'Select tutorial version'
HA1F9E472551C: '튜토리얼 버전을 선택하세요'
# 'Select underlying type for wchar_t'
H871CFB3D3DBF: 'wchar_t의 기본 형식을 선택합니다'
# "Select which XRay instrumentation points to emit. Options: all, none, function-entry, function-exit, function, custom. Default is 'all'.  'function' includes both 'function-entry' and 'function-exit'."
HF1CF9325D610: "XRay 앤스트루먼테이션 포인트 중 어떤 것을 생성할지 선택합니다. 옵션: all, none, function-entry, function-exit, function, custom. 기본값은 'all'입니다. 'function'은 'function-entry'와 'function-exit'을 모두 포함합니다."
# 'Select which denormal numbers the code is permitted to require'
H2AC882EF26F4: '코드가 요구할 수 있는 비정상 소수를 선택합니다'
# 'Select which denormal numbers the code is permitted to require for float'
HE697FDB681DE: 'float에 대해 코드가 요구할 수 있는 비정상 소수의 종류를 선택합니다'
# 'Selected elements are displayed in a tabular format.'
HEA919FEE4B68: '선택된 요소들이 표 형식으로 표시됩니다.'
# 'Selected elements are displayed in a tree view (Include children)'
H177003785A78: '선택된 요소들은 트리 뷰에 표시됩니다 (자식 포함)'
# 'Selected elements are displayed in a tree view. (Include parents)'
HDF9A5F80B1E1: '선택된 요소들은 트리 뷰에 표시됩니다. (부모 포함)'
# 'Selects the execution mode to use for running snippets'
HD1AD171EDC3B: '스니펫 실행에 사용할 실행 모드를 선택합니다'
# 'Serialize compiler diagnostics to a file'
HDAE0DE265E80: '컴파일러 진단 정보를 파일에 직렬화합니다'
# 'Set CPU for optimization without affecting instruction set'
H4812860590FE: '최적화를 위한 CPU를 지정하지만 명령 집합에 영향을 주지 않음'
# 'Set DWARF fission mode'
HA6B185D6C1A5: 'DWARF 분할 모드 설정'
# 'Set EABI type (default depends on triple):'
HE8D11354B2F8: 'EABI 유형을 설정 (기본값은 triple에 따라 결정됨):'
# 'Set EABI type. Default depends on triple)'
H10E2EAF33A04: 'EABI 유형을 설정합니다. 기본값은 triple에 따라 결정됩니다)'
# 'Set Fuchsia API level'
H6549E92FCDF2: 'Fuchsia API 레벨을 설정합니다'
# 'Set Hexagon Vector Length'
H7AAC4AA29051: 'Hexagon 벡터 길이 설정'
# 'Set LTO mode'
HC407FF843F6C: 'LTO 모드 설정'
# 'Set LTO mode for offload compilation'
HAFC85CCA6F44: '오프로드 컴파일을 위한 LTO 모드 설정'
# 'Set OpenMP version (e.g. 45 for OpenMP 4.5, 51 for OpenMP 5.1). Default value is 31 for Flang'
H4AABB415543E: 'OpenMP 버전 설정 (예: OpenMP 4.5는 45, OpenMP 5.1는 51. Flang의 기본값은 31)'
# 'Set OpenMP version (e.g. 45 for OpenMP 4.5, 51 for OpenMP 5.1). Default value is 51 for Clang'
H81EB65FB7662: 'OpenMP 버전을 설정합니다(예: 45는 OpenMP 4.5, 51는 OpenMP 5.1에 해당). Clang의 기본 값은 51입니다'
# 'Set ThinLTO cache entry expiration time.'
HAC92585FAE36: 'ThinLTO 캐시 항목의 만료 시간을 설정합니다.'
# 'Set ThinLTO cache pruning directory maximum number of files.'
H5D4AE530977A: 'ThinLTO 캐시 정리 디렉토리 최대 파일 수를 설정합니다.'
# 'Set ThinLTO cache pruning directory maximum size in bytes.'
H28BB199174A5: 'ThinLTO 캐시 정리 디렉토리의 바이트 단위 최대 크기를 설정합니다.'
# 'Set ThinLTO cache pruning interval.'
H4990BDC788D5: 'ThinLTO 캐시 정리 간격을 설정합니다.'
# 'Set __cdecl as a default calling convention'
H0DA21BF93B54: '기본 호출 규약으로 __cdecl를 지정합니다'
# 'Set __fastcall as a default calling convention'
H407DDA0187F9: '기본 호출 규칙으로 __fastcall을 설정합니다'
# 'Set __regcall as a default calling convention'
HBA376537ABE7: '등록 호출 규약의 기본 값으로 __regcall을 설정합니다'
# 'Set __regcall4 as a default calling convention to respect __regcall ABI v.4'
H58F2490637FE: '__regcall4를 기본 호출 규약으로 설정하여 __regcall ABI v.4를 준수합니다'
# 'Set __stdcall as a default calling convention'
HE1D6B80E6229: '__stdcall을 기본 호출 규약으로 설정합니다'
# 'Set __vectorcall as a default calling convention'
H37C4705F7696: '기본 호출 규약으로 __vectorcall을 설정합니다'
# 'Set architecture for code generation'
HAC7DFD303E5D: '코드 생성을 위한 아키텍처 설정'
# 'Set assembly output file name (with /FA)'
H342E214704DE: '어셈블리 출력 파일 이름을 설정합니다 (with /FA)'
# 'Set build target to arm64ec'
H05FB1FB7BA76: '빌드 타겟을 arm64ec로 설정합니다'
# 'Set default AMDHSA Code Object Version (module flag or asm directive still take priority if present)'
H146533C17448: '디폴트 AMDHSA 코드 오브젝트 버전을 설정합니다 (모듈 플래그 또는 asm 지시문이 존재할 경우 우선 적용됩니다)'
# "Set default MTE mode to 'sync' (default) or 'async'"
H20B84E4CC1C3: "기본 MTE 모드를 'sync' (기본값) 또는 'async'로 설정합니다"
# 'Set default calling convention'
HDE29EF09B114: '기본 호출 규약을 설정합니다'
# 'Set default maximum struct packing alignment'
HB9DF8419AE20: '구조体型의 패킹 정렬 기본 최대값을 설정'
# 'Set default maximum struct packing alignment to 1'
H4F682E117F17: '구조체 팩킹 정렬의 기본 최대값을 1로 설정'
# 'Set directory to SYSTEM include search path with prefix'
H68EB156B894F: '프리픽스를 사용하여 SYSTEM include 검색 경로에 디렉토리를 설정합니다'
# 'Set directory to include search path with prefix'
H949A45EF9093: '프리픽스를 사용하여 헤더 파일 검색 경로에 디렉토리를 설정합니다'
# 'Set endian conversion of data for unformatted files'
H5882EA320C88: '비포맷 파일에 대한 데이터의 엔디언 변환을 설정합니다'
# 'Set exception handling model'
HBE5ECEAC70BC: '예외 처리 모델을 설정합니다'
# 'Set filename used to determine the language and to find\n.clang-format file.\nOnly used when reading from stdin.\nIf this is not passed, the .clang-format file is searched\nrelative to the current working directory when reading stdin.\nUnrecognized filenames are treated as C++.\nsupported:\n  CSharp: .cs\n  Java: .java\n  JavaScript: .js .mjs .cjs .ts\n  Json: .json .ipynb\n  Objective-C: .m .mm\n  Proto: .proto .protodevel\n  TableGen: .td\n  TextProto: .txtpb .textpb .pb.txt .textproto .asciipb\n  Verilog: .sv .svh .v .vh'
H13B2BD633E05: '표준 입력을 읽을 때 언어를 결정하고 .clang-format 파일을 찾는 데 사용되는 파일명을 지정합니다.\n만약 이 옵션이 전달되지 않으면 .clang-format 파일은 현재 작업 디렉토리에 상대적으로 검색됩니다.\n알 수 없는 파일명은 C++로 처리됩니다.\n지원되는 확장자:\n  CSharp: .cs\n  Java: .java\n  JavaScript: .js .mjs .cjs .ts\n  Json: .json .ipynb\n  Objective-C: .m .mm\n  Proto: .proto .protodevel\n  TableGen: .td\n  TextProto: .txtpb .textpb .pb.txt .textproto .asciipb\n  Verilog: .sv .svh .v .vh'
# 'Set hexagon hvx loop upper bound align limit'
HE4A380690C61: 'hexagon hvx 루프 상한 정렬 제한을 설정합니다'
# 'Set hexagon loop align bundle limit'
H16F9FCEB4FD8: 'HEXAGON 루프 정렬 번들 제한 설정'
# 'Set hexagon loop align edge threshold'
HB0E799C9958F: 'HEXAGON 루프 정렬 엣지 임계값 설정'
# 'Set hexagon loop lower bound align limit'
H191108F43D31: 'hexagon 루프 하한 정렬 제한 설정'
# 'Set hexagon loop upper bound align limit'
HAC06445A5323: '헥사곤 루프 상한 경계 정렬 제한을 설정합니다'
# 'Set hexagon tiny-core loop align bundle limit'
HC2C9248FD7B4: 'hexagon tiny-core 루프 정렬 묶음 제한 설정'
# 'Set hexagon tiny-core loop upper bound align limit'
HB3D8449C583E: '헥사곤 티니-코어 루프 상한 경계 정렬 제한을 설정합니다'
# 'Set how to use window scheduling algorithm.'
H38DFCE09E411: '윈도우 스케줄링 알고리즘 사용 방법을 설정합니다.'
# 'Set iOS deployment target'
HF07609B74103: 'iOS 배포 대상 설정'
# 'Set inclusive limit count of TLS local-dynamic access(es) in a function to use initial-exec'
H219EA990A3B9: '함수 내에서 초기-실행을 사용하기 위해 TLS 로컬-다이내믹 액세스의 포함된 제한 수를 설정'
# 'Set language version (c++14,c++17,c++20,c++23preview,c++latest,c11,c17)'
H7E89784949AD: '언어 버전 설정 (C++14,C++17,C++20,C++23preview,C++latest,C11,C17)'
# 'Set lazy loading to pretend to import a module'
H618CB094A526: '지연 로딩을 가상으로 모듈을 가져오도록 설정합니다'
# 'Set level of crash diagnostic reporting, (option: off, compiler, all)'
HCE18F9865CAD: 'crash 진단 보고 수준을 설정합니다, (옵션: off, compiler, all)'
# 'Set macOS deployment target'
H19A10025F765: 'macOS 배포 대상 설정'
# 'Set max number of processed functions per pass.'
HEC89F562858B: '각 패스당 처리할 함수의 최대 수를 설정합니다.'
# 'Set maximum number of loads used in expanded memcmp'
HB5230B1550BF: '확장된 memcmp에서 사용되는 로드의 최대 개수 설정'
# 'Set maximum number of loads used in expanded memcmp for -Os/Oz'
H8B44477BDB6F: '확장된 memcmp에서 -Os/Oz 옵션에 사용되는 로드의 최대 개수를 설정합니다'
# 'Set maximum offset for global merge pass'
HC56716718D87: '전역 병합 패스의 최대 오프셋 설정'
# 'Set maximum runtime in seconds. Defaults to infinite.'
HF2324CC71F76: '초 단위로 최대 실행 시간을 설정합니다. 기본값은 무한대로 설정됩니다.'
# 'Set maximum size of jump tables.'
H8A331A3A6A26: 'jump tables의 최대 크기를 설정합니다.'
# 'Set minimum jump tables'
H5B26E9EE289B: '최소 점프 테이블 설정'
# 'Set minimum mem intrinsic size to expand in IR'
H0E2DA83065C4: 'IR에서 확장하기 위한 최소 메모리 내재 크기 설정'
# 'Set minimum number of entries to use a jump table on AArch64'
H5D2DDCBDE91E: 'AArch64에서 점프 테이블을 사용하기 위한 최소 항목 수를 설정합니다'
# 'Set minimum number of entries to use a jump table on PPC'
H695C03675C01: 'PPC에서 jump table을 사용하기 위한 최소 항목 수를 설정합니다'
# 'Set minimum number of entries to use a jump table on RISCV'
H747561D1A3EA: 'RISCV에서 점프 테이블을 사용하기 위한 최소 항목 수를 설정합니다'
# 'Set minimum number of entries to use a jump table.'
HB0CDB46F3718: '점프 테이블을 사용하기 위한 최소 항목 수를 설정합니다.'
# "Set multiple /O flags at once; e.g. '/O2y-' for '/O2 /Oy-'"
HEBA0D85CE2CB: "한 번에 여러 개의 /O 플래그를 설정합니다; 예: '/O2y-'를 '/O2 /Oy-'로 사용"
# 'Set output executable file name'
H82C970101BA4: '실행 파일의 이름을 출력으로 설정합니다'
# 'Set output object file (with /c)'
HBAF5373A221F: '출력 오브젝트 파일을 설정합니다 (with /c)'
# 'Set page size for slab (requires -slab-allocate and -noexec)'
H674467BA0F71: '슬랩의 페이지 크기를 설정(옵션 -slab-allocate 및 -noexec 필요)'
# 'Set pch file name (with /Yc and /Yu)'
H0833DDB5ABF7: 'pch 파일 이름을 설정 (/Yc와 /Yu와 함께)'
# 'Set preprocess output file name (with /P)'
H13AACC04AA24: '전처리 출력 파일 이름을 설정합니다 (옵션 /P 사용 시)'
# 'Set project title for the coverage report'
HBA2F951324E5: '커버리지 보고서를 위한 프로젝트 제목 설정'
# 'Set runtime encoding, supports only UTF-8'
HE66D162F5CCB: '런타임 인코딩을 설정합니다. UTF-8만을 지원합니다.'
# 'Set slab target address (requires -slab-allocate and -noexec)'
H20F55BE4E6F3: '슬래브 대상 주소 설정 (다음 옵션이 필요합니다: -slab-allocate 및 -noexec)'
# 'Set source and runtime encoding to UTF-8 (default)'
H652EEA8353CA: '소스 및 런타임 인코딩을 UTF-8로 설정합니다 (기본값)'
# 'Set source encoding, supports only UTF-8'
H3F8729E6E52F: '소스 인코딩을 설정합니다. UTF-8만 지원합니다'
# 'Set stack probe size (default 4096)'
HD0B9F95D20C7: '스택 프로브 크기 설정 (기본값 4096)'
# 'Set tab expansion size for html coverage reports (default = 2)'
H020BCDC65A3D: 'HTML 커버리지 보고서에 대한 탭 확장 크기를 설정합니다 (기본값 = 2)'
# 'Set target profile'
H5E78CA7AD76D: '타겟 프로파일 설정'
# 'Set the -iwithprefix/-iwithprefixbefore prefix'
HE253558596E6: '옵션 접두사를 설정합니다: -iwithprefix/-iwithprefixbefore'
# 'Set the Data Stream Control Register.'
H13FF9AB8D2D0: '데이터 스트림 제어 레지스터를 설정합니다.'
# 'Set the case probability threshold for peeling the case from a switch statement. A value greater than 100 will void this optimization'
H4CFCB81E6294: 'switch 문에서 case를 분리하기 위한 case 확률 임계값을 설정합니다. 100보다 큰 값은 이 최적화를 무효로 합니다'
# 'Set the count value cutoff. Functions with the maximum count less than this value will not be printed out. (Default is 0)'
H314CB3F4FF30: 'count 값의 임계값을 설정합니다. 최대 count가 이 값보다 작은 함수들은 출력되지 않습니다. (기본값은 0입니다)'
# 'Set the default double precision kind to an 8 byte wide type'
H826E52CBA80A: '기본 더블 정밀도 유형을 8바이트 너비의 유형으로 설정합니다'
# 'Set the default integer and logical kind to an 8 byte wide type'
HBB03F45115A1: '8바이트 너비 형식으로 기본 정수 및 논리형 종류를 설정합니다'
# 'Set the default most-general representation to multiple inheritance'
H4BB3649A0500: '다중 상속을 기본 가장 일반적인 표현 방식으로 설정합니다'
# 'Set the default most-general representation to single inheritance'
HD5A0F69F41ED: '기본값으로 가장 일반적인 표현 방식을 단일 상속으로 설정합니다'
# 'Set the default most-general representation to virtual inheritance'
H106974060665: '가장 일반적인 표현 방식을 가상 상속으로 설정합니다'
# 'Set the default real kind to an 8 byte wide type'
H7B0DABF8B0EB: '기본 real 형식의 종류를 8바이트 넓이 타입으로 설정합니다'
# 'Set the default structure layout to be compatible with the Microsoft compiler standard'
H10F147D00248: '기본 구조체 레이아웃을 Microsoft 컴파일러 표준과 호환되도록 설정합니다'
# 'Set the default symbol visibility for all global definitions'
HFCD98D3F8272: '모든 글로벌 정의에 대한 기본 심볼 가시성을 설정합니다'
# 'Set the deployment target to be the specified OS and OS version'
H814D918A5F74: '지정된 OS 및 OS 버전으로 배포 대상을 설정합니다'
# 'Set the device id.'
H4C967743D4CC: '장치 ID를 설정합니다.'
# "Set the driver mode to either 'gcc', 'g++', 'cpp', 'cl' or 'flang'"
HD0838A0BABB3: '드라이버 모드를 gcc, g++, cpp, cl 또는 flang 중 하나로 설정합니다'
# 'Set the kind of module destructors emitted by AddressSanitizer instrumentation. These destructors are emitted to unregister instrumented global variables when code is unloaded (e.g. via `dlclose()`).'
H83083E1D2A16: 'AddressSanitizer 인스트루먼트에 의해 생성되는 모듈 소멸자의 종류를 설정합니다. 이러한 소멸자는 코드가 언로드될 때 (예: `dlclose()`를 통해) 인스트루먼트된 전역 변수의 등록을 해제하기 위해 생성됩니다.'
# 'Set the loop counter bitwidth'
H9F5F138BD1EC: '루프 카운터 비트 폭을 설정합니다'
# 'Set the loop decrement value'
H5680DA5C48FB: '루프 감소값을 설정합니다'
# 'Set the lower bound of a trip count to decide on vectorization while tail-folding.'
H098C7B4E7AF1: 'tail-folding를 수행할 때 벡터화를 결정하기 위해 반복 횟수의 하한을 설정합니다.'
# 'Set the max unroll count for full unrolling, for testing purposes'
HF7A0139ED19B: '테스트 목적으로 완전한 언롤링을 위한 최대 언롤 카운트를 설정합니다'
# 'Set the max unroll count for partial and runtime unrolling, fortesting purposes'
H9B56B49168A1: '부분 및 런타임 언롤링을 위한 최대 언롤 횟수를 설정합니다. 테스트 목적으로 사용됩니다'
# 'Set the maximum bitwidth for _BitInt (this option is expected to be removed in the future)'
HA5D88B68C72D: '_BitInt의 최대 비트폭을 설정합니다 (이 옵션은 향후 제거될 예정입니다)'
# 'Set the maximum depth of recursive constexpr function calls'
HBB90EC0111F9: '재귀 constexpr 함수 호출의 최대 깊이를 설정합니다'
# 'Set the maximum depth of recursive template instantiation'
H80FAEB4CB009: '재귀 템플릿 인스턴스화의 최대 깊이를 설정합니다'
# 'Set the maximum number of clang-format errors to emit\nbefore stopping (0 = no limit).\nUsed only with --dry-run or -n'
HCC14B05C0F0B: '중지하기 전에 표시할 clang-format 오류의 최대 개수를 설정합니다 (0 = 제한 없음).\n--dry-run 또는 -n 옵션과 함께 사용됩니다'
# 'Set the maximum number of entries to print in a constexpr evaluation backtrace (0 = no limit)'
H894E58266D5D: 'constexpr 평가 백트레이스에서 출력할 최대 항목 수를 설정합니다 (0 = 제한 없음)'
# 'Set the maximum number of entries to print in a macro expansion backtrace (0 = no limit)'
H41EB48896694: '매크로 확장 백트레이스에서 표시할 최대 항목 수를 설정(0 = 제한 없음)'
# 'Set the maximum number of entries to print in a template instantiation backtrace (0 = no limit)'
H0B1001101AD7: '템플릿 인스턴스화 추적에서 표시할 최대 항목 수를 설정합니다 (0 = 제한 없음)'
# 'Set the maximum number of errors to emit before stopping (0 = no limit).'
H4B9FB4A77BFC: '중지하기 전에 표시할 오류의 최대 수를 설정합니다 (0 = 제한 없음).'
# 'Set the maximum number of outgoing blocks for using a boolean value to record the exiting block in the ControlFlowHub.'
H72D58573A0FE: 'ControlFlowHub에서 출구 블록을 불리언 값으로 기록하는 데 사용되는 출발 블록의 최대 수를 설정합니다.'
# 'Set the maximum number of source lines to show in a caret diagnostic (0 = no limit).'
H501810E09B46: '-caret 진단에서 표시할 최대 소스 라인 수를 설정합니다(0 = 제한 없음).'
# 'Set the maximum number of steps in constexpr function evaluation'
H220ED2A089D9: 'constexpr 함수 평가에서 허용하는 최대 단계 수를 설정합니다'
# 'Set the maximum number of times to perform spell checking on unrecognized identifiers (0 = no limit)'
HAFFC709D0C08: '인식되지 않은 식별자에 맞춤법 검사를 수행하는 최대 횟수를 설정합니다 (0 = 제한 없음)'
# 'Set the maximum path length when checking whether a basic block is followed by a block that either has a terminating deoptimizing call or is terminated with an unreachable'
H332DCFF60584: '기본 블록 다음에 오는 블록이 종료하는 deoptimizing 호출을 포함하거나 unreachable로 종료되는지 확인할 때 최대 경로 길이를 설정합니다'
# 'Set the minimum number of repetitions of a divisor to allow transformation to multiplications by the reciprocal'
HC1FEBC49F8C7: '제수의 최소 반복 횟수를 설정하여 역수 곱셈으로 변환할 수 있도록 합니다.'
# 'Set the mode for address space map based mangling; OpenCL testing purposes only'
HD09BAE7AD91C: '주소 공간 맵 기반 매그링 모드를 설정합니다; OpenCL 테스트 목적만을 위해'
# 'Set the number of scavenger slots'
H180660FD5B55: '수거 슬롯의 개수를 설정합니다'
# 'Set the number of teams.'
H7688CE2C3ADF: '팀 수를 설정합니다.'
# 'Set the number of threads.'
H6EBBEB07E8B0: '스레드 수를 설정합니다.'
# 'Set the out-of-process executor'
HAF02B074B342: '프로세스 외부 실행기를 설정합니다'
# 'Set the output <file> for debug infos'
HA5E541919277: '디버그 정보를 출력할 <file>을 설정합니다'
# 'Set the p2align operands for WebAssembly loads and stores'
H7736F9C56939: 'WebAssembly 로드 및 저장을 위한 p2align 연산자를 설정합니다'
# 'Set the parallelization strategy'
HF0A794612D46: '병렬화 전략을 설정합니다'
# "Set the profile instrumentation burst duration, which can range from 1 to the value of 'sampled-instr-period' (0 is invalid). This number of samples will be recorded for each 'sampled-instr-period' count update. Setting to 1 enables simple sampling, in which case it is recommended to set 'sampled-instr-period' to a prime number."
H5CA10C80C24A: "프로파일링 기기 터지기 지속 시간을 설정합니다. 이 값은 1부터 'sampled-instr-period' 값까지 범위를 가집니다 (0은 무효입니다). 각 'sampled-instr-period' 카운트 업데이트마다 이 샘플 수가 기록됩니다. 1로 설정하면 단순 샘플링이 활성화되며, 이 경우 'sampled-instr-period'를 소수로 설정하는 것이 권장됩니다."
# "Set the profile instrumentation sample period. A sample period of 0 is invalid. For each sample period, a fixed number of consecutive samples will be recorded. The number is controlled by 'sampled-instr-burst-duration' flag. The default sample period of 65536 is optimized for generating efficient code that leverages unsigned short integer wrapping in overflow, but this is disabled under simple sampling (burst duration = 1)."
HC029DE20A3E1: "프로파일 기기 샘플 주기를 설정합니다. 0인 샘플 주기는 무효합니다. 각 샘플 주기마다 일정 수의 연속 샘플이 기록되며, 이 수치는 'sampled-instr-burst-duration' 플래그로 제어됩니다. 기본 샘플 주기 65536은 오버플로우 시 부호 없는 단정수 감싸기를 활용해 효율적인 코드 생성을 최적화하지만, 단순 샘플링(버스트 지속 시간 = 1)에서는 이 기능이 비활성화됩니다."
# "Set the rsp quoting to either 'posix', or 'windows'"
HFF7A11383873: "rsp의 쿼팅 형식을 'posix' 또는 'windows' 중 하나로 설정합니다"
# 'Set the stack alignment'
HAAE3F7EC9ADE: '스택 정렬을 설정합니다'
# 'Set the stack probe size'
H188751A74B18: '스택 프로브 크기를 설정합니다'
# 'Set the system root directory (usually /)'
H9329C47A6507: '시스템 루트 디렉토리를 설정합니다(보통 /)'
# 'Set the tab stop distance.'
HC9DBC229821F: '탭 정지 거리를 설정합니다.'
# 'Set the target triple'
H886553395ADD: '타겟 트리플을 설정합니다'
# 'Set the threshold for pgo-verify-bfi:  only print out mismatched BFI if the difference percentage is greater than this value (in percentage).'
H467C6DAEB903: 'pgo-verify-bfi의 임계값을 설정합니다: 차이 퍼센트가 이 값보다 클 경우 불일치한 BFI만 출력합니다 (퍼센트 단위).'
# 'Set the threshold for pgo-verify-bfi: skip the counts whose profile count value is below.'
HCF37C352FCE6: 'pgo-verify-bfi의 임계값을 설정합니다: 프로파일 카운트 값이 하한선 이하인 카운트를 건너뜁니다.'
# 'Set the unroll peeling count, for testing purposes'
H00413175E081: '테스트를 위한 언롤 피닝 카운트를 설정합니다'
# 'Set the z/OS release of the runtime environment'
HD212DAE31048: '런타임 환경의 z/OS 릴리즈를 설정합니다'
# 'Set up preprocessor for static analyzer (done automatically when static analyzer is run).'
HE7E0E6B1AE87: '정적 분석기용 프리프로세서 설정 (정적 분석기가 실행될 때 자동으로 수행됩니다).'
# 'Set update method of profile counters'
HA14B65C6D0B2: '프로파일 카운터의 업데이트 방법을 설정합니다.'
# 'Set upper limit for the number of transformations performed during a single round of hoisting the reassociated expressions.'
HC739332F82AA: '재결합된 표현식의 호이스팅 단일 라운드 동안 수행된 변환의 수에 대한 상한을 설정합니다.'
# 'Set wave priority'
HBB7FE34C07C2: '웨이브 우선순위 설정'
# 'Set width of the columns showing resource booking.'
HC849BD248519: '리소스 예약을 표시하는 열의 너비를 설정합니다.'
# 'Set width of the columns with the resources and schedule units'
H67C4E5790866: '리소스와 스케줄 유닛 열의 너비를 설정합니다'
# 'Sets the ASan constructor kind'
H7243B87BA43D: 'ASan 생성자 유형을 설정합니다'
# 'Sets the ASan destructor kind. The default is to use the value provided to the pass constructor'
H3151987CC244: 'ASan 소멸자 유형을 설정합니다. 기본값은 패스 생성자에 제공된 값이 사용됩니다'
# 'Sets the IEEE bit in the expected default floating point  mode register. Floating point opcodes that support exception flag gathering quiet and propagate signaling NaN inputs per IEEE 754-2008. This option changes the ABI. (AMDGPU only)'
H40BE9F55402A: '예상 기본 부동 소수점 모드 레지스터의 IEEE 비트를 설정합니다. IEEE 754-2008에 따라 예외 플래그 수집 및 신호 NaN 입력 전파를 지원하는 부동 소수점 명령어. 이 옵션은 ABI를 변경합니다. (AMDGPU 전용)'
# 'Sets the SIMD width. Zero is autoselect.'
HA8F45CFC1E01: 'SIMD 너비를 설정합니다. 0은 자동 선택입니다.'
# 'Sets the bias which adds weight to occupancy vs latency. Set it to 100 to chase the occupancy only.'
HDE531962A442: '작업률 대비 지연 시간에 가중치를 부여하는 편향을 설정합니다. 작업률만을 추구하기 위해 100으로 설정합니다.'
# 'Sets the cost threshold for when multiple conditionals will be merged into one branch versus be split in multiple branches. Merging conditionals saves branches at the cost of additional instructions. This value sets the instruction cost limit, below which conditionals will be merged, and above which conditionals will be split. Set to -1 to never merge branches.'
H908B80F5C5DD: '조건문 병합 여부를 결정하는 비용 임계값을 설정합니다. 조건문을 병합하면 분기를 줄일 수 있지만 추가 명령문이 필요합니다. 이 값은 명령문 비용의 한계를 설정하며, 이 임계값 미만일 경우 조건문을 병합하고 초과할 경우 분리합니다. -1로 설정하면 분기를 결코 병합하지 않습니다.'
# 'Sets the default matrix layout'
HB552288B1A94: '기본 행렬 레이아웃을 설정합니다'
# 'Sets the maximum allowed output size (0 means no limit) [ELF only]'
H7FE764745013: '허용되는 최대 출력 크기를 설정합니다 (0은 제한 없음을 의미함) [ELF 전용]'
# 'Sets the minimum function size to instrument with XRay'
HF47DF90C1776: 'XRay로 악기화할 최소 함수 크기를 설정합니다'
# 'Sets the mode of detection for stack-use-after-return.'
H3FEDDC9474EF: '스택 사용 후 리턴 감지를 위한 모드를 설정합니다.'
# 'Sets the preferable loop alignment for experiments (as log2 bytes) for innermost loops only. If specified, this option overrides alignment set by x86-experimental-pref-loop-alignment.'
H0A768F10FB45: '실험을 위한 선호하는 루프 정렬(로그2 바이트 단위)을 가장 내부 루프에만 설정합니다. 이 옵션이 지정되면 이 옵션은 x86-experimental-pref-loop-alignment에서 설정한 정렬을 대체합니다.'
# 'Sets the vectorization interleave count. Zero is autoselect.'
H0275ABE673BB: '벡터화 교차 카운트를 설정합니다. 0은 자동 선택됩니다.'
# 'Sets various macros to claim compatibility with the given GCC version (default is 4.2.1)'
HF256B239FB01: '다양한 매크로를 설정하여 지정된 GCC 버전과의 호환성을 선언합니다 (기본값은 4.2.1입니다)'
# 'Shadow Stack GC Lowering'
H04B76D4FEDB5: '그림자 스택 GC 하향 변환'
# 'Should __STATIC__ be defined'
H46691D14FB8F: '__STATIC__를 정의해야 하나요?'
# 'Should a closed world be assumed, or not. Default if not set.'
H5AB58A4464B6: '폐쇄된 세계를 가정할 것인지 여부입니다. 설정되지 않았을 경우 기본값이 사용됩니다.'
# 'Should enable CSE in Legalizer'
H77887DE8DF92: 'CSE를 Legalizer에서 활성화해야 합니다'
# 'Should enable CSE in irtranslator'
H91C4D8FE802C: 'CSE를 irtranslator에서 활성화해야 합니다'
# 'Should mir-strip-debug only strip debug info from debugified modules by default'
H3DC291F161A1: 'mir-strip-debug는 기본적으로 디버그화된 모듈에서만 디버그 정보를 제거해야 하나요?'
# 'Should we attempt to sink negations?'
HA914A0DB2603: '부정을 가라앉히려고 시도해야 하나요?'
# 'Show FailedToMaterialize errors'
HE9058727A1A0: 'FailedToMaterialize 오류 표시'
# 'Show MCDC statistics in summary table'
HC702D8A97A6E: '요약 표에 MCDC 통계를 표시합니다'
# 'Show True/False counts'
HFE8C8190B143: 'True/False 개수 표시'
# 'Show True/False percent'
H07C8D556E1B3: 'True/False 비율 표시'
# 'Show binary counters (1/0) in lines and branches instead of integer execution counts'
HB45D3670503F: '라인과 분기에서 정수 실행 카운트 대신 이진 카운터(1/0)를 표시합니다'
# 'Show binary ids in the profile. '
HB609CBDF46B1: '프로파일의 이진 ID를 표시합니다. '
# 'Show bindings of tools to actions'
H25DE8385EB09: '도구와 작업 간의 바인딩을 표시합니다'
# 'Show branch condition statistics in summary table'
H231A08B7A99F: '브랜치 조건 통계를 요약 표에 표시'
# 'Show call-multigraph (do not remove parallel edges)'
HCC8B57A6B12A: '호출 다중 그래프 표시 (병렬 엣지 제거하지 않음)'
# 'Show code coverage only for functions listed in the given file'
H0D504442CF50: '주어진 파일에 나열된 함수에 한해서 코드 커버리지를 표시합니다'
# 'Show code coverage only for functions that match the given regular expression'
H6E2F7500DDDA: '주어진 정규 표현식과 일치하는 함수에 대해서만 코드 커버리지를 표시합니다'
# 'Show code coverage only for functions with line coverage greater than the given threshold'
H6945238A4869: '주어진 임계값보다 라인 커버리지가 높은 함수에 대해서만 코드 커버리지를 표시합니다'
# 'Show code coverage only for functions with line coverage less than the given threshold'
H1A772B15E654: '지정된 임계값 미만의 라인 커버리지를 가지는 함수에 한해 코드 커버리지를 표시합니다'
# 'Show code coverage only for functions with region coverage greater than the given threshold'
HF06D994C900A: '지정된 임계값보다 큰 영역 커버리지를 가진 함수에 대해서만 코드 커버리지를 표시합니다'
# 'Show code coverage only for functions with region coverage less than the given threshold'
H4FA285578577: '지정된 문턱값 미만의 지역 커버리지를 가진 함수에 한해 코드 커버리지를 표시합니다'
# 'Show code coverage only for functions with the given name'
H9786810746F0: '지정된 이름을 가진 함수에 대해서만 코드 커버리지를 표시합니다'
# 'Show commands to run and use verbose output'
HE1D432762909: '실행 및 상세 출력 사용을 위한 명령어 표시'
# 'Show context sensitive counts'
HE2280C2DDA17: '문맥 감도 있는 카운트 표시'
# 'Show counter values for shown functions'
H129F56F5FD53: '표시된 함수의 카운터 값을 보여줍니다'
# 'Show coverage for branch conditions'
HC96F564B6A82: '분기 조건의 커버리지를 표시'
# 'Show coverage for each function'
H3CCABA0A8100: '각 함수별 커버리지를 표시'
# 'Show coverage summaries for each function'
HBAF14E467A0F: '각 함수별 커버리지 요약을 표시'
# 'Show created time for each page.'
H321E973C4182: '각 페이지의 생성 시간을 표시합니다.'
# 'Show detailed profile summary'
HEDDF2BF2C691: '자세한 프로파일 요약 표시'
# 'Show detailed warning message.'
H9E7102D900DA: '상세한 경고 메시지를 표시합니다.'
# 'Show details of invoking getNextResoufceCycle.'
HA4F0023B8FF3: 'getNextResoufceCycle을 호출할 때의 세부 정보를 표시합니다.'
# 'Show directory coverage'
H83933D919BBD: '디렉토리 커버리지 표시'
# 'Show edges labeled with weights'
H376FB60A851E: '가중치로 표시된 엣지들을 표시합니다'
# 'Show encoding in .s output'
HB528C74F2189: '출력 .s에 인코딩 표시'
# 'Show expanded source regions'
H387D478FCAFF: '확장된 소스 영역을 표시합니다'
# 'Show function instantiations'
HCFC0922F8DE2: '함수 인스턴스화 표시'
# 'Show header includes and nesting depth'
HFC379692A313: '헤더 포함 파일과 중첩 깊이 표시'
# 'Show heat colors in CFG'
HF38DE9931AB9: 'CFG에서 히트 색상을 표시합니다'
# 'Show heat colors in call-graph'
HDDDF3F1C338F: '호출 그래프에 히트 색상 표시'
# 'Show indirect call site target values for shown functions'
H4D99B80D7C36: '표시된 함수의 간접 호출 위치 타겟 값을 표시'
# 'Show instantiation statistics in summary table'
HAD4D78E39FA9: '요약 표에서 인스턴스화 통계를 표시'
# 'Show instr profile data in text dump format'
HE77B1EB739B5: '텍스트 덤프 형식으로 instr 프로필 데이터 표시'
# 'Show instruction encoding information in transliterate mode'
H15214D90288C: '전철자 모드에서 명령어 인코딩 정보 표시'
# 'Show instruction encodings'
H76A361C43AC1: '명령어 인코딩을 표시합니다'
# 'Show instructions operands as parsed'
HE4EAD3961196: '해석된 대로 명령문의 연산자를 표시합니다'
# 'Show internal debug dump'
H79FC9F317159: '내부 디버그 덤프 표시'
# 'Show internal instruction representation'
H969E08C4B063: '내부 명령어 표현을 표시합니다'
# 'Show internal instruction representation in transliterate mode'
HCF07E4857D2B: 'transliterate 모드에서 내부 명령 표현을 표시'
# 'Show lexical and class parents'
H2CD760A9C080: '문법적 및 클래스 부모 표시'
# 'Show line numbers in diagnostic code snippets'
H08938EFDB15B: '진단 코드 스니펫에 줄 번호 표시'
# 'Show only simple regions in the graphviz viewer'
H09E6F5F4BBB1: '그래프비 뷰어에서 단순한 영역만 표시'
# 'Show only the configs matching this regex'
H2BD050A28852: '이 정규식과 일치하는 설정만 표시'
# 'Show only the functions that have been executed.'
HD6154133C806: '실행된 함수만 표시합니다.'
# 'Show profile summary of a list of hot functions'
H0361C5298777: '핫 함수 목록의 프로파일 요약을 표시합니다'
# 'Show profile symbol list if it exists in the profile. '
HC84B87BCF81B: '프로파일에 존재하면 프로파일 심볼 목록을 표시합니다. '
# 'Show profile version. '
HD8D6C82AA426: '프로필 버전을 표시합니다. '
# 'Show region statistics in summary table'
H3D65F3DC6E98: '요약 표에 영역 통계를 표시'
# 'Show sample profile data in the JSON format (deprecated, please use --show-format=json)'
H828A9B7D7ACC: 'JSON 형식으로 샘플 프로파일 데이터를 표시 (사용되지 않음, --show-format=json을 사용해 주세요)'
# 'Show skipped includes in -H output.'
H2CB52D019FEC: '-H 출력에 건너뛴 포함 파일을 표시합니다.'
# 'Show temporal profile traces in the profile.'
H72096941B959: '프로파일에 일시적 프로파일 추적을 표시합니다.'
# 'Show the MCDC Coverage for each applicable boolean expression'
HD1B4BD4AF9D7: '적용 가능한 각 부울 표현에 대한 MCDC 커버리지를 표시합니다'
# 'Show the Polly CFG right after code generation'
H029F6C967468: '코드 생성 직후의 Polly CFG를 표시'
# 'Show the collected coverage object files'
H31D89D92BF30: '수집된 커버리지 오브젝트 파일을 표시합니다'
# 'Show the collected paths to source files'
H26A34004C8C4: '수집된 소스 파일 경로를 표시합니다'
# 'Show the execution counts for each line'
HBDA134A1E3B8: '各行에 대한 실행 횟수를 표시합니다'
# 'Show the execution counts for each line, or the execution counts for each region on lines that have multiple regions'
H9AF77074F9BE: '각 줄의 실행 횟수를 표시하거나, 여러 개의 지역을 가진 줄의 각 지역별 실행 횟수를 표시합니다'
# 'Show the execution counts for each region'
HE82C34C08B90: '각 영역별 실행 횟수를 표시합니다'
# 'Show the information of each section in the sample profile. The flag is only usable when the sample profile is in extbinary format'
HF5346C9B396B: '샘플 프로파일의 각 섹션의 정보를 표시합니다. 이 플래그는 샘플 프로파일이 extbinary 형식일 때만 사용 가능합니다'
# 'Show the list of functions with the largest internal counts'
HDB413363F895: '가장 큰 내부 카운트를 가진 함수 목록을 표시합니다'
# 'Show the profiled sizes of the memory intrinsic calls for shown functions'
HEACDF1B2720A: '표시된 함수의 메모리 인트리니크 호출에 대한 프로파일 크기를 표시합니다'
# 'Show the sizes of all debug sections, expressed in bytes.'
H78A0DAA47053: '모든 디버그 섹션의 크기를 바이트 단위로 표시합니다.'
# 'Show the sources across all compilation units.'
H9382C23DCF90: '모든 컴파일 유닛의 소스를 표시합니다.'
# 'Show times for llvm-jitlink phases'
HD3302520BB6D: 'llvm-jitlink 단계의 실행 시간을 표시합니다'
# 'Show times for llvm-rtdyld phases'
HB7BC3C6A17C2: 'llvm-rtdyld 단계의 시간 표시'
# 'Show verbose output when opt-bisect-limit is set'
H8536EE8B8C8C: 'opt-bisect-limit가 설정되면 상세한 출력을 표시합니다'
# 'Show vtable names for shown functions'
H79407841F063: '표시된 함수에 대한 vtable 이름 표시'
# 'Shrink Wrap Pass'
HE4743C131F02: '축소 래핑 패스'
# 'Shuffle machine instructions alternating directions'
H3D7E0E8AF77B: '교차 방향으로 머신 명령어 재배치'
# 'Silence ObjC rewriting warnings'
HDDBF5BEB68D8: 'ObjC 리라이팅 경고 무시'
# 'Similar completion items (e.g. function overloads) are combined. Type information shown where possible'
H1DEA188ACC34: '유사한 완성 항목(예: 함수 오버로드)은 결합됩니다. 가능한 경우 타입 정보가 표시됩니다'
# 'Similar to -ftime-trace. Specify the JSON file or a directory which will contain the JSON file'
H53211B2FCAB2: '-ftime-trace와 유사합니다. JSON 파일 또는 해당 파일이 들어갈 디렉토리를 지정합니다'
# 'Similar to data-and-control, but remove the runtime check'
HDAE5253998D0: 'data-and-control과 유사하지만 실행 시 점검을 제거합니다'
# 'Similar to list-burr but schedules in source order when possible'
H322EBF2ED613: 'list-burr와 비슷하지만 가능한 경우 소스 코드 순서대로 스케줄링합니다'
# 'Simple speculation'
H736302864F3E: '단순 추측'
# 'Simplify DDG by merging nodes that have less interesting edges.'
H140319D98680: 'DDG를 간소화하기 위해 덜 중요한 간선을 가진 노드를 병합합니다.'
# 'Simplify SCoP after optimizations'
H9435BBE6A7ED: '최적화 후 SCoP 단순화'
# 'Simplify the CFG'
H3F01631183F4: 'CFG를 단순화하세요'
# 'Simplify the CFG after atomic expansion pass'
H4B39E0A8393B: '원자 확장 패스 이후 CFG 간소화'
# 'Simply drop type test sequences'
H6F563FE46789: '타입 테스트 시퀀스를 제거하십시오.'
# 'Simulate installation in the given directory'
H2E8832D0BC0E: '지정된 디렉토리에서 설치를 시뮬레이션합니다'
# 'Single thread model'
H0A1A3414EA60: '단일 스레드 모델'
# 'Sink common instructions (default = false)'
H458310DD7CCF: '공통 명령을 하향 처리(기본값 = false)'
# 'Sink common instructions down to the end block'
HB6833655C393: '공통 명령문을 end 블록 끝으로 하강시키기'
# 'Sink instructions into cycles to avoid register spills'
HA19B07EB7A73: '명령어를 순환 구조에 내려서 리지스터 스파일을 피합니다'
# 'Size limit for the MII.'
HFE4E64539F6A: 'MII의 크기 제한.'
# 'Size limit in Hexagon early if-conversion'
HEE45F9DDA387: 'Hexagon 조기 if-conversion의 크기 제한'
# 'Size of the expression which is considered huge'
H4AAD9C3152F7: '표현식의 크기가 매우 크다고 간주되는 경우'
# 'Size of the load queue'
H51731E4081C2: '로드 대기열의 크기'
# 'Size of the store queue'
H7CD5021D4D3E: '스토어 큐의 크기'
# 'Size-specialize memcmp and bcmp calls'
H4D487410E126: 'memcmp와 bcmp 호출을 크기별 특수화'
# 'SjLj exception handling'
HA2DEA63BE575: 'SjLj 예외 처리'
# 'Skip 64-bit divide for dynamic 32-bit values'
HBC981EB66354: '동적 32비트 값에 대한 64비트 나눗셈 건너뛰기'
# 'Skip Callsite up to this number for this compilation'
HD2D3E00B6C18: '이 컴파일 시 이 번호까지의 Callsite 건너뛰기'
# 'Skip Cost Analysis'
HEBC9E235FCC3: '성능 분석 건너뛰기'
# 'Skip ODR checks for decls in the global module fragment.'
H3261F074F5AE: '글로벌 모듈 프래그먼트 내의 선언에 대한 ODR 검사를 건너뜁니다.'
# 'Skip checks for relocated modules when loading PCM files'
HD81AE42FB9F0: 'PCM 파일을 로드할 때 재배치된 모듈에 대한 검사를 생략합니다'
# "Skip emitting basic block entries in the SHT_LLVM_BB_ADDR_MAP section. It's used to save binary size when BB entries are unnecessary for some PGOAnalysisMap features."
H71707934B534: 'SHT_LLVM_BB_ADDR_MAP 섹션에서 기본 블록 항목의 생성을 생략합니다. 이는 특정 PGOAnalysisMap 기능에서 BB 항목이 필요하지 않을 때 바이너리 크기를 절약하기 위해 사용됩니다.'
# 'Skip function bodies when possible'
HC6384E72882E: '가능한 경우 함수 본문 건너뛰기'
# 'Skip instructions on input which lack scheduling information'
H0CA4A6B1674E: '입력에서 스케줄링 정보가 없는 지시문을 건너뜁니다'
# 'Skip instructions or lines on input which are unsupported for any reason'
H66EA3C6B0D85: '지원되지 않는 입력의 명령문 또는 라인을 건너뜁니다'
# 'Skip lines on the input which fail to parse for any reason'
HF1FE9D6E74D2: '입력에서 어떤 이유로든 해석에 실패한 줄을 건너뜁니다'
# 'Skip merging empty blocks if (frequency of empty block) / (frequency of destination block) is greater than this ratio'
HD3ACA543F291: '공백 블록의 빈도를 목표 블록의 빈도로 나눈 값이 이 비율보다 크면 공백 블록 병합을 생략합니다'
# 'Skip merging functions with no parameters.'
H4C33F6695ED3: '매개변수가 없는 함수의 병합을 건너뜁니다.'
# 'Skip op verification when using custom printers'
HE99716DCF0A6: '커스텀 프린터를 사용할 때 연산 검증을 건너뛰기'
# 'Skip pass list reduction steps'
H94E9DA2F7021: '패스 목록 축소 단계 건너뛰기'
# 'Skip printing info about analyses'
H89B96A0AA8C3: '분석에 대한 정보 출력을 건너뛰기'
# 'Skip regions when printing ops.'
HE9909BB5AB83: '연산을 출력할 때 영역을 건너뜁니다.'
# 'Skip relative hotness check for ICP up to given number of targets.'
H1CF24D29FE78: '지정된 수의 타겟까지 ICP에 대한 상대적 뜨거운도 검사를 건너뜁니다.'
# 'Skip setting up RAX register when passing variable arguments (x86 only)'
H88536767AEC5: '가변 인수를 전달할 때 RAX 레지스터 설정을 건너뛰기 (x86 전용)'
# 'Skip source code files with file paths that match the given regular expression'
HF5248544A184: '지정된 정규식과 일치하는 파일 경로를 가진 원본 코드 파일을 건너뜁니다'
# 'Skip the check if the number of hot functions is smaller than the specified number.'
HC72D43FB0410: '핫 함수의 수가 지정된 수보다 작으면 확인을 건너뜁니다.'
# 'Skip the dependency check for pragma-based transformations'
H9266BB52380C: 'pragma 기반 변환에 대한 종속성 검사를 건너뛰기'
# 'Slot index numbering'
H25CDF44B807D: '슬롯 인덱스 번호 지정'
# 'Small code model'
HDBB10FAFE07D: '소형 코드 모델'
# 'Small data and bss section threshold size (default=0)'
HCE054C60032A: '작은 데이터 및 BSS 섹션의 임계 크기 (기본값=0)'
# 'Small data and bss section threshold size (default=8)'
HD23849593CCC: '작은 데이터 및 BSS 섹션 임계 크기 (기본값=8)'
# 'Soft float ABI (implied by -soft-float)'
HC0C86A6BE8AC: '소프트 플로트 ABI (옵션 -soft-float로 지정됨)'
# 'Sort by element kind.'
H873DE05DDF9E: '요소 유형별로 정렬합니다.'
# 'Sort by element line number.'
HE0D755567860: '요소 라인 번호에 따라 정렬합니다.'
# 'Sort by element name.'
H0C2C0BB04670: '요소 이름에 따라 정렬합니다.'
# 'Sort by element offset.'
HAEFFB6AFF193: '요소 오프셋에 따라 정렬합니다.'
# 'Sort classes by amount of immediate padding'
HC0D1B98A168E: '즉시 패딩의 양에 따라 클래스를 정렬합니다'
# 'Sort classes by amount of padding'
H6740525F2A73: '패딩 양에 따라 클래스 정렬'
# 'Sort classes by name'
H525546C671ED: '클래스를 이름으로 정렬'
# 'Sort classes by percentage of space consumed by immediate padding'
H807712AAABEC: '즉시 패딩에 의한 공간 소비 비율에 따라 클래스를 정렬합니다'
# 'Sort classes by percentage of space consumed by padding'
H2970C3CE6488: '패딩으로 인한 공간 차지 비율에 따라 클래스 정렬'
# 'Sort classes by size'
H4175309835B2: '크기별로 클래스 정렬'
# 'Sort profiled recursion by edge weights.'
HDC0AFFCFAE60: '프로파일링된 재귀를 엣지 가중치로 정렬합니다.'
# 'Sort symbols by name'
HEF9C9A551533: '이름으로 심볼 정렬'
# 'Sort symbols by size'
H194BBF71E1B6: '크기별로 기호 정렬'
# 'Sort the resources printed in the dump trace'
H66B4BBE5718F: 'dump 추적에 표시된 리소스를 정렬합니다'
# 'Source Code Analysis - Dead Symbol Removal Frequency'
H658C75F7C985: '소스 코드 분석 - 사용되지 않는 심볼 제거 빈도'
# 'Source Code Analysis - Output Options'
H418F37A89230: '소스 코드 분석 - 출력 옵션'
# 'Source Code Analysis - Symbolic Constraint Engines'
HD8341B8B44B5: '소스 코드 분석 - 기호적 제약 엔진'
# 'Source language name.'
HE1B71BB29701: '소스 언어 이름.'
# 'Source prefix to elide'
HF556E14613B2: '이제까지의 소스 접두사 생략'
# "Source-level compatibility for Altivec vectors (for PowerPC targets). This includes results of vector comparison (scalar for 'xl', vector for 'gcc') as well as behavior when initializing with a scalar (splatting for 'xl', element zero only for 'gcc'). For 'mixed', the compatibility is as 'gcc' for 'vector bool/vector pixel' and as 'xl' for other types. Current default is 'mixed'."
HCF923B012626: 'Altivec 벡터의 소스 레벨 호환성 (PowerPC 타겟용). 이는 벡터 비교의 결과(‘xl’은 스칼라, ‘gcc’는 벡터)를 포함하며, 스칼라로 초기화할 때의 동작(‘xl’은 스플래팅, ‘gcc’는 요소 0만)도 포함됩니다. ‘mixed’일 경우, ‘vector bool/vector pixel’은 ‘gcc’와 호환되고, 다른 타입은 ‘xl’과 호환됩니다. 현재 기본값은 ‘mixed’입니다.'
# 'SourceLocation in file %0 at offset %1 is invalid'
H2A6519004798: '파일 %0의 오프셋 %1 위치의 SourceLocation이 유효하지 않습니다'
# 'Sparc Assembly Printer'
H91EE11A0F136: 'Sparc 어셈블리 프린터'
# 'Spawn a separate process for each cc1'
H4079AEA987DF: '각 cc1에 대해 별도의 프로세스를 생성합니다'
# 'Spawns a subprocess for each snippet execution, allows for the use of memory annotations'
HB0B29965076D: '각 코드 조각 실행마다 서브프로세스를 생성하며, 메모리 어노테이션 사용을 허용합니다'
# 'Specifies PowerPC native vector element order (default)'
HE6ABC638069C: 'PowerPC 네이티브 벡터 요소 순서를 지정합니다 (기본값)'
# 'Specifies PowerPC non-native vector element order'
H1D9287995DAC: 'PowerPC 비네이티브 벡터 요소 순서를 지정합니다'
# 'Specifies a list of variables to be exempt from the TOC data transformation.'
HAF01AE884575: 'TOC 데이터 변환에서 제외할 변수 목록을 지정합니다.'
# 'Specifies a list of variables to which the TOC data transformation will be applied.'
H33958769FAEF: 'TOC 데이터 변환이 적용될 변수 목록을 지정합니다.'
# "Specifies preferred vector width for auto-vectorization. Defaults to 'none' which allows target specific decisions."
H30D4DB622AB0: "자동 벡터화에 사용할 선호하는 벡터 너비를 지정합니다. 기본값은 'none'이며, 이는 타겟별 최적화를 허용합니다."
# 'Specifies that the sample profile is accurate'
H3A3F53CE7955: '샘플 프로파일이 정확함을 지정합니다'
# 'Specifies the JITDylib to be used for any subsequent -extra-module arguments.'
HFDCED35F4977: '이후 -extra-module 인수에 사용될 JITDylib를 지정합니다.'
# 'Specifies the JITDylib to be used for any subsequent input file, -L<seacrh-path>, and -l<library> arguments'
H72683DE0AF39: '후속 입력 파일, -L<seacrh-path>, 및 -l<library> 인수에 사용할 JITDylib를 지정합니다'
# "Specifies the debug info's compilation dir"
H64EB79AAF220: '디버그 정보의 컴파일 디렉토리를 지정합니다'
# 'Specifies the evaluation method to use for floating-point arithmetic.'
HB1694AF39E4A: '부동소수점 산술에 사용할 평가 방법을 지정합니다.'
# 'Specifies the exception behavior of floating-point operations.'
HF7A17A05FFEE: '부동소수점 연산의 예외 동작을 지정합니다.'
# "Specifies the largest alignment guaranteed by '::operator new(size_t)'"
H7C74E7BEFD7B: "'::operator new(size_t)'에 의해 보장되는 가장 큰 정렬을 지정합니다."
# 'Specifies the name we should consider the input file'
H048BF6366B06: '입력 파일의 이름을 지정합니다'
# 'Specifies the size of batches for processing CUs. Higher number has better performance, but more memory usage. Default value is 1.'
HE1BE8B43F7F0: 'CU 처리를 위한 배치의 크기를 지정합니다. 숫자가 클수록 성능이 좋아지지만, 메모리 사용량이 더 증가합니다. 기본값은 1입니다.'
# 'Specify "safe" i.e. known-good backend:'
H8A9DA72ACD37: '안전한, 즉 알려진 양호한 백엔드를 지정하세요:'
# "Specify <function, basic block1[;basic block2...]> pairs to extract.\nEach pair will create a function.\nIf multiple basic blocks are specified in one pair,\nthe first block in the sequence should dominate the rest.\nIf an unnamed basic block is to be extracted,\n'%' should be added before the basic block variable names.\neg:\n  --bb=f:bb1;bb2 will extract one function with both bb1 and bb2;\n  --bb=f:bb1 --bb=f:bb2 will extract two functions, one with bb1, one with bb2.\n  --bb=f:%1 will extract one function with basic block 1;"
H5393854BACA7: "추출할 <함수, 기본 블록1[;기본 블록2...]> 쌍을 지정하십시오.\n각 쌍은 하나의 함수를 생성합니다.\n하나의 쌍에 여러 기본 블록을 지정할 경우,\n첫 번째 블록이 나머지 블록을 지배해야 합니다.\n명명되지 않은 기본 블록을 추출할 경우,\n'%'가 기본 블록 변수 이름 앞에 추가되어야 합니다.\n예:\n  --bb=f:bb1;bb2는 bb1과 bb2를 모두 포함하는 하나의 함수를 추출합니다;\n  --bb=f:bb1 --bb=f:bb2는 각각 bb1과 bb2를 포함하는 두 개의 함수를 추출합니다.\n  --bb=f:%1은 기본 블록 1을 포함하는 하나의 함수를 추출합니다;"
# 'Specify <script> as linker script'
HE790F52CC3F0: '링커 스크립트로 <script> 지정'
# 'Specify CU wavefront execution mode (AMDGPU only)'
H0AC391ACF1B8: 'CU 웨이브프론트 실행 모드를 지정합니다 (AMDGPU 전용)'
# 'Specify O2(not Os) spill func threshold'
HEC690666E75E: 'O2(而非 Os) 스파일 함수 임계값을 지정하십시오.'
# 'Specify Os spill func threshold'
H2796D0A3FC8E: 'Os 스피ル 함수 임계값 지정'
# 'Specify WGP wavefront execution mode (AMDGPU only)'
H1A9B58D9172E: 'WGP 웨이브프론트 실행 모드를 지정합니다 (AMDGPU 전용)'
# 'Specify a SamplePGO profile file'
H5B1BF8C410B3: 'SamplePGO 프로파일 파일을 지정하십시오'
# 'Specify a context sensitive PGO profile file'
H6CD3C27C7374: '컨텍스트에 민감한 PGO 프로파일 파일을 지정하십시오'
# "Specify a default target triple when it's not available in the module"
H8905580ACB2D: '모듈에 타겟 트리플이 지정되지 않았을 때 기본 타겟 트리플을 지정하세요'
# "Specify a directory where Clang can find 'include' and 'lib{,32,64}/gcc{,-cross}/$triple/$version'. Clang will use the GCC installation with the largest version"
H5F9EC5F91118: "Clang가 'include'와 'lib{,32,64}/gcc{,-cross}/$triple/$version'을 찾을 수 있는 디렉토리를 지정해 주세요. Clang는 가장 큰 버전의 GCC 설치를 사용합니다"
# "Specify a directory where Flang can find 'lib{,32,64}/gcc{,-cross}/$triple/$version'. Flang will use the GCC installation with the largest version"
H59AA0290DBA6: "Flang이 'lib{,32,64}/gcc{,-cross}/$triple/$version'을 찾을 수 있는 디렉토리를 지정합니다. Flang은 가장 큰 버전의 GCC 설치를 사용합니다"
# 'Specify a plugin to optimize LFENCE insertion'
H749CB0E11874: 'LFENCE 삽입을 최적화할 플러그인을 지정하십시오'
# 'Specify a reference program output (for miscompilation detection)'
H7D6525B849BF: '잘못된 컴파일 감지를 위한 참조 프로그램 출력을 지정합니다'
# 'Specify a symbol resolution: filename,symbolname,resolution\nwhere "resolution" is a sequence (which may be empty) of the\nfollowing characters:\n p - prevailing: the linker has chosen this definition of the\n     symbol\n l - local: the definition of this symbol is unpreemptable at\n     runtime and is known to be in this linkage unit\n x - externally visible: the definition of this symbol is\n     visible outside of the LTO unit\nA resolution for each symbol must be specified'
HFA08A87A55A4: '기호 해결을 지정합니다: filename,symbolname,resolution\n여기서 "resolution"은 다음 문자들로 이루어진 시퀀스(비어 있을 수 있음)입니다:\n p - 주류: 링커가 이 기호의 정의를 선택했습니다\n l - 지역: 이 기호의 정의는 런타임에서 대체되지 않고 이 링크 단위에 존재함이 알려져 있습니다\n x - 외부 가시성: 이 기호의 정의는 LTO 단위 외부에서 가시적입니다\n각 기호에 대해 해결 방법을 지정해야 합니다'
# 'Specify alias to extract'
H4D5920CD11AC: '추출할 별칭을 지정하십시오'
# 'Specify alias(es) to extract using a regular expression'
H5A885E78EEAE: '정규 표현식을 사용하여 추출할 별칭(들)을 지정합니다'
# "Specify an offloading device architecture for CUDA, HIP, or OpenMP. (e.g. sm_35). If 'native' is used the compiler will detect locally installed architectures. For HIP offloading, the device architecture can be followed by target ID features delimited by a colon (e.g. gfx908:xnack+:sramecc-). May be specified more than once."
H03D163E89A58: "CUDA, HIP 또는 OpenMP용 오프로딩 디바이스 아키텍처를 지정합니다. (예: sm_35). 'native'를 사용하면 컴파일러는 로컬에 설치된 아키텍처를 감지합니다. HIP 오프로딩의 경우 디바이스 아키텍처 뒤에 콜론(:)으로 구분된 타겟 ID 특성이 추가될 수 있습니다(예: gfx908:xnack+:sramecc-). 여러 번 지정할 수 있습니다."
# 'Specify an output filename for an HTML report. This describes both recommendations and reasons for changes.'
H8B1F64A00015: 'HTML 보고서를 위한 출력 파일 이름을 지정합니다. 이는 변경 사항의 권장 사항과 이유를 함께 설명합니다.'
# 'Specify bit size of immediate TLS offsets (AArch64 ELF only): 12 (for 4KB) | 24 (for 16MB, default) | 32 (for 4GB) | 48 (for 256TB, needs -mcmodel=large)'
H26411589DDDC: '즉각 TLS 오프셋의 비트 크기를 지정합니다 (AArch64 ELF 전용): 12 (4KB를 위해) | 24 (16MB를 위해, 기본값) | 32 (4GB를 위해) | 48 (256TB를 위해, -mcmodel=large 옵션이 필요합니다)'
# 'Specify code object ABI version. Defaults to 6. (AMDGPU only)'
HA8698B7A4F07: '코드 객체 ABI 버전을 지정하세요. 기본값은 6입니다. (AMDGPU 전용)'
# 'Specify comma-separated list of offloading target triples (CUDA and HIP only)'
H4646687E209A: 'CUDA 및 HIP만을 위한 대상 트리플의 쉼표로 구분된 목록을 지정하세요'
# 'Specify comma-separated list of triples OpenMP offloading targets to be supported'
H3568A2B2B198: '쉼표로 구분된 triple 형식의 OpenMP 오프로딩 타겟 목록을 지정하십시오'
# 'Specify command to run'
H1E332E02D801: '실행할 명령을 지정하십시오.'
# 'Specify configuration file'
HF189739D324B: '구성 파일을 지정하십시오'
# "Specify default stream. The default value is 'legacy'. (CUDA/HIP only)"
H9CAF3E629210: "기본 스트림을 지정합니다. 기본값은 'legacy'입니다. (CUDA/HIP만 해당됩니다.)"
# 'Specify file to retrieve coverage information from'
HF677E8D618FB: '커버리지 정보를 가져올 파일을 지정하십시오'
# 'Specify file to retrieve the list of functions to apply CHR to'
H43EA914C6AE3: 'CHR을 적용할 함수 목록을 가져올 파일을 지정하십시오'
# 'Specify file to retrieve the list of modules to apply CHR to'
HB6D52312D695: 'CHR를 적용할 모듈 목록을 가져올 파일을 지정하세요'
# 'Specify frame pointer elimination optimization'
HCB5E3F71D5CB: '프레임 포인터 제거 최적화를 지정합니다'
# 'Specify function to extract'
H6994C514E482: '추출할 함수를 지정'
# 'Specify function(s) to extract using a regular expression'
H807560CFE84D: '정규 표현식을 사용하여 추출할 함수(들)을 지정합니다'
# 'Specify global to extract'
HDBAFDC1CCA62: '추출할 global을 지정해야 합니다'
# 'Specify global(s) to extract using a regular expression'
H3D4D2BF99055: '정규 표현식을 사용하여 추출할 전역 변수(들)를 지정하십시오.'
# 'Specify gotol lower bound'
H0CEAACB24E44: 'gotol 하한을 지정하세요'
# 'Specify how to interpret the input file'
H8145E9D12D4E: '입력 파일을 어떻게 해석할지 지정합니다'
# 'Specify input format'
H2E3E293CB7F2: '입력 형식을 지정하십시오.'
# 'Specify list of enabled SPIR-V extensions'
H3D0774E8209D: '활성화된 SPIR-V 확장 목록을 지정합니다'
# 'Specify lowering strategy for function LDS access:'
H5D945C2F2C1F: '함수 LDS 접근에 대한 변환 전략을 지정합니다:'
# 'Specify maximum number of prefixes to use for padding'
H3374CFFFC8CB: '패딩에 사용할 접두사 최대 개수를 지정합니다'
# 'Specify name of main file output in depfile'
HA7D009581C27: 'depfile에 기록할 메인 파일 이름을 지정합니다'
# 'Specify name of main file output to quote in depfile'
H50F02814EC9E: 'depfile에 기록할 메인 파일 출력의 이름을 지정합니다'
# 'Specify output filename'
H1761FE158718: 'Specify output filename'
# 'Specify remark argument/s to count (accepts regular expressions).'
H822EAE5D54AB: '세기 위해 remark 인수를 지정하세요 (정규 표현식을 사용할 수 있음).'
# 'Specify remark argument/s to count by.'
HAEE8EE4F6186: '리마크 인수를 카운트할 때 사용할 값을 지정하십시오.'
# 'Specify target SDNode namespace (default=<Target>ISD)'
H929FE737DC80: '타겟 SDNode 네임스페이스 지정 (기본값=<Target>ISD)'
# 'Specify target triple (e.g. i686-apple-darwin9)'
HB87754B01AFD: '타겟 트리플을 지정해 주세요 (예: i686-apple-darwin9)'
# 'Specify that backslash in string introduces an escape character'
H5D6C9DDA7494: '문자열 내 백슬래시가 탈출 문자를 나타내도록 지정합니다'
# 'Specify that floating-point optimizations are not allowed that assume arguments and results are not +-inf.'
H8BEEB06E6F67: '인수와 결과가 ±무한대가 아님을 가정하는 부동소수점 최적화를 허용하지 않음을 지정합니다.'
# 'Specify that floating-point optimizations are not allowed that assume arguments and results are not NANs.'
H8FA0A762F433: '플로팅 포인트 최적화가 인수와 결과가 NAN가 아니라고 가정하는 것은 허용되지 않음을 지정합니다.'
# 'Specify that kernel argument names are preserved (HIP only)'
H623A10E0D7BD: '커널 인수 이름을 보존하도록 지정합니다 (HIP 전용)'
# 'Specify that single precision floating-point divide and sqrt used in the program source are correctly rounded (HIP device compilation only)'
H6D7A7AAF7A65: '단일 정밀도 부동소수점 나눗셈과 제곱근이 프로그램 소스에 사용되었을 때 올바르게 반올림되었음을 지정합니다 (HIP 디바이스 컴파일 전용)'
# 'Specify that the assembler should encode SSE instructions with VEX prefix'
HE1B00D0701B9: '어셈블러가 VEX 접두사를 사용하여 SSE 명령어를 인코딩하도록 지정합니다'
# 'Specify the "test" i.e. suspect back-end:'
HECCC4473972C: '"test"(즉, 의심되는 백엔드)를 지정하십시오:'
# 'Specify the BPF stack size limit'
HDC6898D3AB44: 'BPF 스택 크기 제한을 지정합니다'
# 'Specify the Swift version to use when filtering API notes'
HC09727464228: 'API 노트 필터링 시 사용할 Swift 버전을 지정합니다'
# 'Specify the available SPIR-V extensions. If this option is not specified, then all extensions are available.'
HA471B42FD9F7: '사용 가능한 SPIR-V 확장자를 지정합니다. 이 옵션을 지정하지 않으면 모든 확장자가 사용 가능합니다.'
# "Specify the boundary's size to align branches"
H7FCB2E0E7262: '분기점을 정렬하기 위해 경계의 크기를 지정하십시오'
# 'Specify the class to use for constant Objective-C string objects.'
H3B4E080AFF98: '상수 Objective-C 문자열 객체에 사용할 클래스를 지정합니다.'
# 'Specify the compression level (integer)'
HA372218D9884: '압축 수준을 지정하세요 (정수)'
# 'Specify the current profile is used as a partial profile.'
H3B5AA73241EA: '현재 프로파일이 부분 프로파일로 사용됨을 지정합니다.'
# 'Specify the darwin target variant triple'
H1C214E10868A: 'darwin 대상 변이 triple을 지정합니다'
# 'Specify the default character set for source files'
H23A2C73FDF8A: '소스 파일의 기본 문자 집합을 지정합니다'
# 'Specify the default maximum struct packing alignment'
HA57D1AA26D37: '기본 최대 struct 패킹 정렬을 지정합니다'
# "Specify the entry function (default = 'main') of the executable"
H95F6DBF9D7B0: "실행 파일의 진입 함수를 지정하십시오 (기본값 = 'main')"
# 'Specify the filename of the process to launch for remote MCJIT execution.  If none is specified,\n\tremote execution will be simulated in-process.'
HB6260E716DE3: '원격 MCJIT 실행을 위해 시작할 프로세스의 파일 이름을 지정합니다. 지정하지 않을 경우,\n\t원격 실행은 프로세스 내에서 시뮬레이션 됩니다.'
# 'Specify the function selection heuristic used during inlining'
H700459284955: '인라인 시 사용되는 함수 선택 휴리스틱을 지정합니다'
# 'Specify the function to be called on overflow'
H514658550A0D: '오버플로우 발생 시 호출할 함수를 지정하십시오'
# 'Specify the interval (in seconds) after which a module file will be considered unused'
H7EDAFDC5BFCC: '초 단위로 모듈 파일이 미사용으로 간주되기까지의 시간 간격을 지정합니다'
# 'Specify the interval (in seconds) between attempts to prune the module cache'
HC07FD162EBA7: '모듈 캐시를 정리하는 시도 사이의 간격(초 단위)을 지정하세요'
# 'Specify the mapping of module name to precompiled module file, or load a module file if name is omitted.'
H9433E5C683C8: '모듈 이름을 사전 컴파일된 모듈 파일에 매핑하도록 지정하거나, 이름이 생략되면 모듈 파일을 로드합니다.'
# 'Specify the maximum alignment to enforce on pointers lacking an explicit alignment'
H46AC799A7735: '명시적인 정렬을 지정하지 않은 포인터들에 대해 강제 적용할 최대 정렬을 지정하세요'
# 'Specify the maximum amount of instructions to inspect when searching for a conditional branch from an indirect control flow.'
H6CFBC17F5A5D: '간접 제어 흐름에서 조건부 분기를 찾을 때 검사할 명령문의 최대 수량을 지정하십시오.'
# 'Specify the maximum amount of instructions to inspect when searching for an undefined instruction from a conditional branch.'
HBCCACE2ACD35: '조건부 분기문에서 정의되지 않은 명령문을 찾을 때 검사할 명령문의 최대 수량을 지정합니다.'
# 'Specify the module cache path'
H2FE40A911909: '모듈 캐시 경로를 지정하십시오.'
# 'Specify the module user build path'
HE6E81535FDBA: '모듈 사용자 빌드 경로를 지정하십시오'
# 'Specify the name of an IR file to load for function definitions'
H66FD8DF154C5: '함수 정의를 로드하기 위한 IR 파일의 이름을 지정하세요'
# 'Specify the name of the .dwo file to encode in the DWARF output'
HFD25A07F8173: 'DWARF 출력에 인코딩할 .dwo 파일의 이름을 지정해 주세요'
# 'Specify the name of the module to build'
HC274D886E608: '빌드할 모듈의 이름을 지정하세요'
# 'Specify the name of the root module.'
H385C12B5E6FA: '루트 모듈의 이름을 지정하십시오.'
# 'Specify the number of threads to use for device offloading tasks during compilation.'
H1A088440B2D0: '구성 시 디바이스 오프로딩 작업에 사용할 스레드 수를 지정합니다'
# "Specify the output file type ('asm', 'null', or 'obj')"
H908E78C67406: "출력 파일 유형을 지정합니다('asm', 'null' 또는 'obj')"
# 'Specify the output file. default: reduced.ll|.bc|.mir'
HDB7BE70A48BF: '출력 파일을 지정하세요. 기본값: reduced.ll|.bc|.mir'
# 'Specify the output filename'
H3C3BD1616514: '출력 파일 이름을 지정하세요'
# 'Specify the output name of the file containing the optimization remarks. Implies -fsave-optimization-record. On Darwin platforms, this cannot be used with multiple -arch <arch> options.'
HD73FD36131DB: '최적화 주석이 포함된 파일의 출력 이름을 지정합니다. 이는 -fsave-optimization-record를 함의합니다. Darwin 플랫폼에서는 이 옵션을 여러 개의 -arch <arch> 옵션과 함께 사용할 수 없습니다.'
# 'Specify the overflow patterns to exclude from arithmetic sanitizer instrumentation'
H317E2D4E0BC0: '산술 정화 도구의 인스트루멘테이션에서 제외할 오버플로 패턴을 지정합니다'
# 'Specify the path of profile data file. This is mainly for test purpose.'
HE901E0A55767: '프로파일 데이터 파일 경로를 지정합니다. 이 옵션은 주로 테스트 목적으로 사용됩니다.'
# 'Specify the path of profile remapping file. This is mainly for test purpose.'
H853E5B17061C: '프로파일 재지정 파일의 경로를 지정하십시오. 이는 주로 테스트 목적으로 사용됩니다.'
# 'Specify the path prefix of the MemProf dot files.'
H5392A6A236E7: 'MemProf dot 파일의 경로 접두사를 지정합니다.'
# 'Specify the path to the "safe" backend program'
HD696058226F4: '안전한 백엔드 프로그램 경로를 지정하십시오'
# 'Specify the prebuilt module path'
H3FAB39F2C50D: '미리 생성된 모듈 경로를 지정하십시오'
# 'Specify the printf lowering scheme (AMDGPU only), allowed values are "hostcall"(printing happens during kernel execution, this scheme relies on hostcalls which require system to support pcie atomics) and "buffered"(printing happens after all kernel threads exit, this uses a printf buffer and does not rely on pcie atomic support)'
H36B6C5D95ECD: 'printf 레이징 스키마를 지정합니다 (AMDGPU 전용). 허용되는 값은 "hostcall"(프린트가 커널 실행 중에 이루어집니다. 이 스키마는 시스템이 pcie 원자 지원을 제공해야 하는 hostcalls에 의존합니다)과 "buffered"(프린트가 모든 커널 스레드가 종료된 후에 이루어집니다. 이는 printf 버퍼를 사용하며 pcie 원자 지원을 필요로 하지 않습니다)입니다'
# 'Specify the profile path in PGO use compilation'
H383968EDB0F3: 'PGO 사용 컴파일 시 프로파일 경로를 지정하십시오.'
# 'Specify the property to collect remarks by.'
H8278427A48F9: '비고를 수집하기 위해 사용할 속성을 지정하십시오.'
# 'Specify the property to group remarks by.'
HE59A5BD76AE3: '주석을 그룹화하는 속성을 지정하십시오.'
# 'Specify the size in bits of an RVV vector register'
H0AB4126F0C29: '비트 단위로 RVV 벡터 레지스터의 크기를 지정해 주세요'
# 'Specify the size in bits of an SVE vector register. Defaults to the vector length agnostic value of "scalable". (AArch64 only)'
H2F3DFF504736: '비트 단위로 SVE 벡터 레지스터의 크기를 지정합니다. 기본값은 벡터 길이 무관 값인 "scalable"입니다. (AArch64 전용)'
# 'Specify the source file identifier for -funique-source-file-names; uses the source file path if not specified'
H0140BA1E31AB: '-funique-source-file-names에 사용할 소스 파일 식별자를 지정합니다. 소스 파일 경로가 지정되지 않은 경우 기본값으로 사용됩니다.'
# 'Specify the stackmap encoding version (default = 3)'
H7CF270813613: 'stackmap 인코딩 버전을 지정합니다. (기본값 = 3)'
# 'Specify the target Objective-C runtime kind and version'
HFE1F1D7E8E7B: '타겟 Objective-C 런타임의 유형과 버전을 지정하십시오.'
# 'Specify the target environment'
H62189CA73425: '타겟 환경을 지정하십시오.'
# 'Specify the type of coverage instrumentation for Sanitizers'
HCCE91ECD2AD5: 'Sanitizers를 위한 커버리지 인스트루먼테이션 유형을 지정하십시오'
# 'Specify the type of metadata to emit for binary analysis sanitizers'
HCEF5AB90855A: '바이너리 분석 세이프티 툴을 위해 생성할 메타데이터 유형을 지정하십시오'
# 'Specify the types of comparisons to emit GPR-only code for.'
HDBA609305F00: 'GPR-only 코드를 생성할 비교 유형을 지정합니다.'
# 'Specify the version of the memprof format to use'
H1B82817FBBA6: '사용할 memprof 포맷의 버전을 지정하십시오'
# 'Specify the vscale maximum. Defaults to the vector length agnostic value of "0". (AArch64/RISC-V only)'
HA66591A80BFB: 'vscale 최대 값을 지정합니다. 기본값은 벡터 길이 무관 값인 "0"입니다. (AArch64/RISC-V 전용)'
# 'Specify the vscale minimum. Defaults to "1". (AArch64/RISC-V only)'
H0C205532C01D: 'vscale 최소값을 지정합니다. 기본값은 "1"입니다. (AArch64/RISC-V 전용)'
# 'Specify time trace file destination'
HC99CB0CDDE38: '시간 추적 파일 목적지 지정'
# 'Specify types of branches to align'
H8693C7688390: '정렬할 분기 유형을 지정하십시오'
# 'Specify types of branches to align (plus separated list of types):\njcc      indicates conditional jumps\nfused    indicates fused conditional jumps\njmp      indicates direct unconditional jumps\ncall     indicates direct and indirect calls\nret      indicates rets\nindirect indicates indirect unconditional jumps'
H3D330EC77559: '정렬할 분기 타입 지정 (플러스 기호로 구분된 타입 목록):\njcc      조건부 점프를 나타냅니다\nfused    결합된 조건부 점프를 나타냅니다\njmp      직접 무조건적 점프를 나타냅니다\ncall     직접 및 간접 호출을 나타냅니다\nret      ret 명령어를 나타냅니다\nindirect 간접 무조건적 점프를 나타냅니다'
# 'Specify wavefront size 32 mode (AMDGPU only)'
HA9AC5ACEB8A1: '32 크기 웨이브프런트 모드 지정 (AMDGPU 전용)'
# 'Specify wavefront size 64 mode (AMDGPU only)'
H33E655B3FFCB: '웨이브프론트 크기 64 모드 지정 (AMDGPU 전용)'
# 'Specify where to find the compiled intrinsic modules'
H60F443A1A2B8: '컴파일된 내장 모듈을 찾을 위치를 지정합니다'
# 'Specify which frame pointers to retain.'
H899F4C930DBE: '프레임 포인터를 유지할지 여부를 지정합니다.'
# 'Speculate that non-constant strides are unit in LAA'
HD4B90FE88764: 'LAA에서 비상수 스트라이드가 단위(1)라고 추정합니다'
# 'Speculate unpredictable branches (default = false)'
HBDC5587A6F17: '예측 불가능한 분기를 추측합니다 (기본값 = false)'
# 'Speculative execution is applied only to targets with divergent branches, even if the pass was configured to apply only to all targets.'
HA74AC4F303A4: '예측 실행은 분기 지점이 있는 타겟에만 적용되며, 패스가 모든 타겟에 적용되도록 구성되더라도 마찬가지입니다.'
# 'Speculative execution is not applied to basic blocks where the cost of the instructions to speculatively execute exceeds this limit.'
HE2B4F7F554AA: '예측 실행은 예측 실행을 수행하는 명령어의 비용이 이 제한을 초과하는 기본 블록에는 적용되지 않습니다.'
# 'Speculative execution is not applied to basic blocks where the number of instructions that would not be speculatively executed exceeds this limit.'
H9EB9A3987580: '예측 실행되지 않을 명령문의 수가 이 한도를 초과하는 기본 블록에는 예측 실행이 적용되지 않습니다.'
# 'SpeculativeJIT'
H6F038D1D3644: '예측 JIT'
# 'Speculatively execute instructions'
HF1EBCFA9992F: '예측적으로 명령어를 실행합니다'
# 'Spill Code Placement Analysis'
HC707A69CEDE9: '스pill 코드 배치 분석'
# 'Spill mode for splitting live ranges'
H33C680059059: '활성 범위 분할을 위한 Spill 모드'
# 'Split GEPs to a variadic base and a constant offset for better CSE'
HCB9C6A238522: 'GEP를 가변 기본과 상수 오프셋으로 분리하여 CSE를 개선합니다'
# 'Split Options'
H33A61DDF11E4: '옵션 분할'
# 'Split all critical edges during PHI elimination'
H4A2C55331EC3: 'PHI 제거 과정에서 모든 중요 엣지 분할'
# 'Split all partitions'
H2671573A0660: '모든 파티션 분할'
# 'Split critical edges during machine sinking'
H4AC49C950879: '머신 싱킹 중 중요 엣지 분할'
# 'Split machine functions using profile information'
HD03C9F1F9730: '프로파일 정보를 사용한 머신 함수 분할'
# 'Split marker to use for merging the ouput'
H5ED0DBD3456A: '출력 병합을 위해 사용할 분할 마커'
# 'Split out cold basic blocks from machine functions based on profile information'
H1074CBD18EC9: '프로파일 정보에 기반하여 머신 함수에서 콜드 기본 블록을 분리합니다'
# 'Split out cold blocks from machine functions based on profile information.'
H59A610956F3E: '프로파일 정보를 기반으로 머신 함수에서 희귀 블록을 분리합니다.'
# 'Split static data'
HAD68510283FA: '정적 데이터 분할'
# 'Split static data sections into hot and cold sections using profile information'
H0855E4DC6A4D: '프로파일 정보를 사용하여 정적 데이터 섹션을 핫 섹션과 콜드 섹션으로 분할합니다'
# 'Split the input file into chunks using the given or default marker and process each chunk independently'
H630FB595F295: '입력 파일을 지정된 마커나 기본 마커를 사용하여 조각으로 분할하고 각 조각을 독립적으로 처리합니다'
# 'Split the output by Compile Units.'
H6C6E1FDA7719: '컴파일 유닛별로 출력을 분할합니다.'
# 'Split the profile to two sections with one containing sample profiles with inlined functions and the other without (only meaningful for -extbinary)'
H4FBB422A3FD9: '프로파일을 두 섹션으로 분할합니다. 하나는 인라인 함수가 포함된 샘플 프로파일을 포함하고, 다른 하나는 포함하지 않도록 합니다 (단, -extbinary 옵션에서만 의미가 있습니다)'
# 'Split without externalizing locals'
H8A331352F2E7: '로컬 변수를 외부화하지 않고 분할'
# "Splits all EH code and it's descendants by default."
HA93F604541F1: '기본적으로 모든 EH 코드 및 그 하위 항목을 분할합니다.'
# 'Stable  ABI instrumentation for sanitizer runtime. Default: Conventional'
H1B5D3202D1AE: '샌타이저 런타임용 안정적 ABI 도구. 기본값: 전통적'
# 'Stack Frame Layout'
H33A25E80B45A: '스택 프레임 레이아웃'
# 'Stack Slot Coloring'
H85960DF4AF9A: '스택 슬롯 칼라링'
# 'StackMap Liveness Analysis'
H6CCE8B66D5C3: 'StackMap 활성 분석'
# 'Standard converging scheduler.'
HA7AD7FEE5D0B: '표준 수렴 스케줄러.'
# 'Start each pass with collecting and end it with checking of debug info preservation.'
H3F51E578F392: '각 패스는 수집으로 시작하고 디버그 정보 보존 확인으로 끝내야 합니다.'
# 'Start each pass with debugify and end it with check-debugify'
H2D5ADDBBEEF2: '각 패스를 debugify로 시작하고 check-debugify로 끝내십시오'
# 'Start emitting warnings for unused driver arguments'
HE346B2A53C42: '미사용 드라이버 인수에 대한 경고를 시작합니다'
# 'Start the pipeline with collecting and end it with checking of debug info preservation.'
HE5F5305CC00C: '파이프라인을 수집 단계로 시작하고 디버그 정보 보존 검사를 통해 종료합니다.'
# 'Start the pipeline with debugify and end it with check-debugify'
H0175081FA86E: '파이프라인을 debugify로 시작하고 check-debugify로 종료해야 합니다'
# 'Statement-level analysis'
H08A2201C3BBE: '문장 수준 분석'
# 'Static Data Annotator'
H8F3F11306A56: '정적 데이터 주석기'
# 'Static Data Profile Info'
H42C5E08B9C8C: '정적 데이터 프로파일 정보'
# 'Static analyzer report output format (html|plist|plist-multi-file|plist-html|sarif|sarif-html|text).'
HA5BB1BCA30A0: '정적 분석기 보고서 출력 형식 (html|plist|plist-multi-file|plist-html|sarif|sarif-html|text).'
# 'Static scheduling'
H9688287692D9: '정적 스케줄링'
# 'Statically link the sanitizer runtime (Not supported for ASan, TSan or UBSan on darwin)'
H5D51614B7830: '샌타이저 런타임을 정적 링크(darwin에서 ASan, TSan 또는 UBSan에는 지원되지 않음)'
# 'Statically resolve calls to versioned functions from non-versioned callers.'
HDACBD3DAB33D: '비버전화된 호출자로부터 버전화된 함수에 대한 호출을 정적으로 해결합니다.'
# 'Stop PCH generation after including this file.  When using a PCH, skip tokens until after this file is included.'
HEE422676F0B0: '이 파일을 포함한 후 PCH 생성을 중지합니다. PCH를 사용할 때는 이 파일이 포함될 때까지 토큰을 건너뜁니다.'
# 'Stop compilation after a specific pass'
HD6BD4366BCBC: '특정 패스 이후에 컴파일을 중단합니다'
# 'Stop compilation before a specific pass'
H50FA55AE29C2: '특정 패스 전에 컴파일을 중지합니다'
# 'Stop inferring nofree attribute during function-attrs pass'
HAF941AF0C8A5: 'function-attrs 패스 중 nofree 속성 추론을 중단합니다'
# 'Stop inferring nounwind attribute during function-attrs pass'
H8B6C2FE67EDE: '함수 특성 패스 중 nounwind 속성 추론 중지'
# 'Stop initializing trivial automatic stack variables after the specified number of instances'
H023CB238F8AC: '지정된 인스턴스 수 이후에 trivial 자동 스택 변수의 초기화 중단'
# 'Stop initializing trivial automatic stack variables if var size exceeds the specified number of instances (in bytes)'
HFF75ED2CDFB4: '변수 크기가 지정된 바이트 수를 초과하는 경우 단순 자동 스택 변수의 초기화를 중지합니다'
# 'Stop processing after parsing rules and dump state'
HC94659F6E6B6: '규칙을 파싱한 후 처리를 중단하고 상태를 덤프합니다'
# 'Stop removing an empty block if removing it will introduce more than this number of phi entries in its successor'
H9A65443D39E6: '후속 블록에서 이 숫자보다 많은 phi 엔트리를 생성하는 경우 해당 빈 블록의 제거를 중단합니다'
# 'Stop scheduling after N instructions'
H9C405DA9723C: 'N 명령어 후 스케줄링 중지'
# 'Store string literals as writable data'
HAB4FC207616D: '문자열 리터럴을 쓰기 가능한 데이터로 저장합니다'
# 'Store-level granularity'
H6039083A6A50: 'Store 수준의 세분화'
# 'Straight line strength reduction'
H31FF5C722167: '직선 강도 감소'
# 'Stress Options'
HB2B1AD1DE1DF: '스트레스 옵션'
# 'Stress test LSR IV chains'
H1CC9D49F4B69: 'LSR IV 체인에 대한 스트레스 테스트'
# 'Stress test ext(promotable(ld)) -> promoted(ext(ld)) optimization in CodeGenPrepare'
HB72AD83333E7: 'CodeGenPrepare에서 ext(promotable(ld)) -> promoted(ext(ld)) 최적화의 스트레스 테스트'
# 'Stress test instruction scheduling'
HA55B8E05F17D: '스트레스 테스트 명령어 일정표 작성'
# 'Stress test store(extract) optimizations in CodeGenPrepare'
HBA93839DF706: 'CodeGenPrepare 단계에서 저장(추출) 최적화를 스트레스 테스트합니다'
# 'String Table (DEBUG_S_STRINGTABLE subsection) (not typically present in PDB file)'
H346701412AE3: '문자열 테이블 (DEBUG_S_STRINGTABLE subsection) (일반적으로 PDB 파일에 존재하지 않음)'
# 'String to initialize the database'
H3CBC3A337427: '데이터베이스를 초기화하기 위한 문자열'
# 'Strip (or keep only, if negative) a given number of path components when emitting check metadata.'
H95EB3AD2C385: '체크 메타데이터를 생성할 때 경로 구성 요소를 지정된 수만큼 제거합니다(부호가 음수이면 그 수만큼만 유지합니다).'
# 'Strip debugger symbol info from translation unit'
HE92E5C253ED7: '번역 단위에서 디버거 심볼 정보를 제거합니다'
# 'Strip module-level named metadata'
HDD827ABBE60A: '모듈 수준 이름 있는 메타데이터 제거'
# 'Strip names from Value during LTO (other than GlobalValue).'
HC04AE0DCC2F5: 'LTO 중 Value에서 이름을 제거(단, GlobalValue 제외)'
# 'Strip prefix of the fully qualified names'
HC496A1D3FAD4: '전체 자격 증명 이름의 접두사 제거'
# 'Strip specified level of directory name from source path in the profile counter name for static functions.'
HB9A6EFA2E4BB: '정적 함수의 프로파일 카운터 이름에서 소스 경로의 지정된 레벨의 디렉토리 이름을 제거합니다.'
# 'Strip-mine outer loops for the loop-vectorizer to trigger'
HA84FED7AAA88: '외부 루프를 스트립 마이닝하여 루프 벡터라이저를 트리거합니다'
# 'Structure.'
H12CCB9A83FCE: '구조体型.'
# 'Structurize the CFG'
H86D5CD019397: 'CFG 구조화'
# 'Stuff'
H226D042D922D: '내용'
# 'Subprogram.'
H5A13F062C508: '서브 프로그램.'
# 'Subrange encoding information for arrays.'
H9B8612490EAE: '배열에 대한 Subrange 인코딩 정보'
# 'Summary of elements missing/added/matched/printed.'
HE867CEA332FA: '누락된/추가된/일치하는/출력된 요소들의 요약.'
# 'Supplement an instr profile with sample profile, to correct the profile unrepresentativeness issue. The sample profile is the input of the flag. Output will be in instr format (The flag only works with -instr)'
HB26399824318: 'instr 프로파일에 샘플 프로파일을 보충하여, 프로파일의 대표성 결여 문제를 수정합니다. 샘플 프로파일은 플래그의 입력입니다. 출력은 instr 형식으로 생성됩니다 (플래그는 -instr와 함께 사용시에만 동작합니다)'
# 'Support POSIX threads in generated code'
H519A7A85C373: '생성된 코드에서 POSIX 스레드 지원'
# 'Suppress STP for AArch64'
H0D98334CA140: 'AArch64에 대한 STP 억제'
# 'Suppress all deprecated warnings'
HE5E64D48AF93: '모든 deprecated 경고 숨기기'
# 'Suppress all linking warnings'
H012398BE48C2: '링크 경고를 모두 숨김'
# 'Suppress all warnings'
HE2E5B3B89DBD: '경고를 모두 숨김'
# 'Suppress counter promotion if exit blocks contain ret.'
H69AEA135B910: '종료 블록(exit blocks)이 ret를 포함할 경우 카운터 상향(counter promotion)을 억제합니다.'
# 'Suppress duplication of instrs into per-HwMode decoder tables'
HC365469D96E4: '각 HwMode 디코더 테이블에 instrs의 중복 삽입 억제'
# 'Suppress inlining of functions whose stack size exceeds the given value'
H25336627EFCB: '스택 크기가 주어진 값을 초과하는 함수의 인라인을 억제합니다'
# 'Suppress output of running passes (both stdout and stderr)'
H777CD18B4BD8: '실행 중인 패스의 출력을 숨김 (stdout과 stderr 모두)'
# 'Suppress rematerialization of dynamic shadow address by passing it through inline asm in prologue.'
H9476840CC1D4: '프롤로그에서 인라인 어셈블리를 통해 전달함으로써 동적 그림자 주소의 재물질화를 방지합니다.'
# 'Suppress slot sharing during stack coloring'
H734CB119B295: '스택 색칠 중 슬롯 공유 억제'
# 'Suppress type errors (Wasm)'
H63BEE3B3DE32: '타입 오류 무시 (Wasm)'
# 'Suppress verbose debugify output'
H650FEBD3E6CA: '상세한 디버그화 출력 억제'
# 'Swap add and addi in cases where the add may be combined with a shift'
HB791E099C036: 'add가 시프트와 결합될 수 있는 경우 add와 addi를 교환'
# 'Swap target blocks of a conditional branch for MVE expander'
H6042CB5BEBAE: 'MVE 확장기용 조건 분기 대상 블록 교환'
# 'Switch to fast cluster algorithm with the lost of some fusion opportunities'
H3997C1BEC2C0: '일부 융합 기회를 손실하더라도 빠른 클러스터 알고리즘으로 전환'
# 'Symbol ID of the symbol being queried (hex).'
H06F2A7E436A9: '조회되는 심볼의 ID (16진수 형식).'
# 'Symbol ID to look up (hex)'
H98F75068720A: '조회할 기호 ID (hex)'
# 'Symbol Options'
HBFC1F4F0A88E: '기호 옵션'
# 'Symbol Rewrite Map'
H1CDA542441BA: '기호 재작성 매핑'
# 'Symbol Type Options'
H035FC129AB6C: '기호 유형 옵션'
# 'Symbol kind to use when printing symbols.'
HB4C2F9BD84AD: '기호를 출력할 때 사용할 기호 종류.'
# 'Symbol location coverage.'
H80C30D273074: '기호 위치 커버리지.'
# 'Symbol remapping file'
H3423735D2CB7: '기호 재매핑 파일'
# 'Symbol to call as main entry point'
H39AD275C387D: '메인 진입점으로 호출할 기호'
# 'Symbol to put in the symtab in the resulting dso'
HFB4EE7AEFE5C: '결과 동적 공유 객체의 symtab에 넣을 기호'
# 'Symbols (DEBUG_S_SYMBOLS subsection) (not typically present in PDB file)'
HDB1B5EBB0319: '기호 (DEBUG_S_SYMBOLS 하위 섹션) (PDB 파일에 일반적으로 포함되지 않음)'
# 'Symbols (Variable, Members, etc.).'
HE394D83CA76F: '기호 (변수, 멤버 등).'
# 'Symbols.'
H73E0811A7FD7: '기호.'
# 'Syntax variant to use for output printing'
HDCC1F5EAEC7B: '출력 형식에 사용할 구문 변형'
# 'Synthesize retain and release calls for Objective-C pointers'
H40E12820EB61: 'Objective-C 포인터에 대한 retain 및 release 호출을 자동으로 생성합니다'
# 'System directory for configuration files'
H2B1CA8129B49: '구성 파일을 위한 시스템 디렉토리'
# 'SystemZ Assembly Printer'
HF4545950D35C: 'SystemZ 어셈블리 프린터'
# 'SystemZ Comparison Elimination'
HA6D4515C513E: 'SystemZ 비교 제거'
# 'SystemZ Copy Physregs'
HBF6729EB5D82: 'SystemZ 물리 레지스터 복사'
# 'SystemZ DAG->DAG Pattern Instruction Selection'
H66AEC705D460: 'SystemZ DAG→DAG 패턴 명령 선택'
# 'SystemZ Instruction Shortening'
H75E7D5BFB7B2: 'SystemZ 명령 단축'
# 'SystemZ Local Dynamic TLS Access Clean-up'
H860F0223FC41: 'SystemZ 로컬 동적 TLS 접근 정리'
# 'SystemZ Long Branch'
H20A34CC2B958: 'SystemZ 장 구간 분기'
# 'SystemZ Post Rewrite pass'
H26F388ADE65D: 'SystemZ 후 재작성 패스'
# 'SystemZ Test Data Class optimization'
H7C47CE39188C: 'SystemZ 테스트 데이터 클래스 최적화'
# 'TableGen LSP Language Server'
H927DAB993B40: 'TableGen LSP 언어 서버'
# 'Tail Call Elimination'
H783C2FABF530: '꼬리 호출 제거'
# 'Tail Duplication'
H71C746D731D5: '꼬리 복제'
# 'Tail-folding and predication preferences over creating a scalar epilogue loop.'
HC5BDD1DF7A2D: '테일 폴딩(Tail-folding)과 예측화(predication)는 스칼라 에필로그 루프 생성보다 선호됩니다.'
# 'Take more precise inbounds assumptions (do not scale well)'
H08762D9FA006: '더 정밀한 inbounds 가정을 사용 (확장성 문제가 있음)'
# 'Take raw hexadecimal bytes as input for disassembly. Whitespace is ignored'
H21819087D66E: '디스어셈블리 입력으로 원시 16진수 바이트를 사용합니다. 공백은 무시됩니다.'
# 'Takes a posix regex and prints the link graphs of all files matching that regex after fixups have been applied'
HB3F945A20F78: 'POSIX 정규 표현식을 입력으로 받아 그 정규 표현식과 일치하는 모든 파일에 대한 수정이 적용된 후의 링크 그래프를 출력합니다'
# 'Target CPU, ignored if --mtriple is not used'
H9C0D15DCF3BD: '타겟 CPU, --mtriple이 사용되지 않을 경우 무시됨'
# 'Target Library Information'
H5C80DD9524F8: '타겟 라이브러리 정보'
# 'Target Pass Configuration'
HE8EFE346FCF6: '타겟 패스 구성'
# 'Target Transform Information'
H381DDCC824B8: '타겟 변환 정보'
# 'Target a particular ABI type'
H8CB1D450BB9C: 'ABI 유형을 지정합니다'
# 'Target a specific auxiliary cpu type'
HC63DF9647BBE: '특정 보조 CPU 유형을 지정합니다'
# 'Target a specific cpu type'
HA6E72D889CDB: '특정 CPU 유형 지정'
# 'Target a specific cpu type (-mcpu=help for details)'
HB995589A2608: '특정 CPU 유형을 지정합니다 (-mcpu=help를 참고해 자세한 내용을 확인하세요)'
# 'Target arch to assemble for, see -version for available targets'
H6A0D4D1161C4: '어셈블할 대상 아키텍처를 지정합니다. 사용 가능한 대상 목록은 -version 옵션을 참고하세요'
# 'Target architecture. See -version for available targets'
HDD6FE0D72BD5: '타겟 아키텍처. 사용 가능한 타겟 목록은 -version 옵션을 참고하세요.'
# 'Target cost kind'
HDAD667E32250: '타겟 비용 유형'
# 'Target default float ABI type'
HEAFE690D5657: '타겟 기본 부동소수점ABI 유형'
# 'Target linker version'
H57EDF14C8F4F: '타겟 링커 버전'
# 'Target specific attributes'
H8E47E4436FE2: '타겟 전용 속성'
# 'Target specific attributes (-mattr=help for details)'
HAB90F22130BF: '특정 타겟 속성 (세부 정보: -mattr=help)'
# 'Target specific auxiliary attributes'
H2BA14C72345A: '타겟별 보조 속성'
# 'Target triple for disassembler'
H83C90E391152: '디어셈블러용 타겟 트리플'
# 'Target triple to assemble for, see -version for available targets'
HC643C7A09170: '어셈블할 타겟 트리플을 지정합니다. 사용 가능한 타겟 목록은 -version 옵션을 참고하세요'
# 'Target triple. See -version for available targets'
H3857DE6DE1E0: '타겟 triple. 사용 가능한 타겟 목록은 -version 옵션을 참고하세요.'
# 'Target triple. When present, a TargetMachine is created and TargetMachine::splitModule is used instead of the common SplitModule logic.'
H2B7CF41128A9: '타겟 트리플. 지정되면 TargetMachine이 생성되고 TargetMachine::splitModule이 일반적인 SplitModule 로직 대신 사용됩니다.'
# 'Template Parameter.'
HF63F96014E9F: '템플릿 매개변수.'
# 'Template alias.'
H3C8CFAE8AE20: '템플릿 별칭.'
# 'Template arguments encoded in the template name.'
H1C3D42D15648: '템플릿 이름에 인코딩된 템플릿 아규먼트입니다.'
# 'Template functions or specializations without host, device and global attributes have implicit host device attributes (CUDA/HIP only)'
HA4C9090C9925: '템플릿 함수나 특수화가 host, device 및 global 속성을 갖지 않을 경우, 암시적으로 host device 속성을 갖습니다 (CUDA/HIP 전용)'
# 'Template pack.'
HA1E3326A0AE4: '템플릿 팩.'
# 'Template parameters replaced by its arguments.'
H2B376AF57DB4: '템플릿 매개변수는 그 인수에 의해 대체되었습니다.'
# 'Template template parameter.'
HB1F99591F368: '템플릿 템플릿 매개변수.'
# 'Template type parameter.'
H16F66C4F3D61: '템플릿 형식 매개변수.'
# 'Template value parameter.'
H128B1A19518C: '템플릿 값 매개변수.'
# 'Template.'
H0518E81F03C2: '템플릿.'
# 'Temporary development switch used to gradually uplift SimplifyCFG into preserving DomTree,'
HBE52749BCFE7: '도미네이션 트리를 유지하기 위해 SimplifyCFG를 서서히 개선하는 데 사용되는 일시적인 개발 스위치,'
# 'Terminate process if it loads user32.dll.'
H3BC023827DF8: '프로세스가 user32.dll을 로드하면 종료합니다.'
# 'Test harness files'
HA4814F3A55AD: '테스트 환경 파일'
# 'Text encoding'
H104683D616E5: '텍스트 인코딩'
# 'Text output'
H722885D8D390: '텍스트 출력'
# 'Textual description of the function type to be called'
HFA8DBC9DB008: '호출할 함수 유형의 텍스트 설명'
# 'Textual description of the pass pipeline to run'
HE98FE702D92A: '실행할 패스 파이프라인의 텍스트 설명'
# 'The CPU number that the benchmarking process should executon on'
H67AECA2CBAEE: '벤치마크 프로세스가 실행되어야 하는 CPU 번호'
# 'The InteractiveModelRunner will echo back to stderr the data received from the host (for debugging purposes).'
HA27F90224438: 'InteractiveModelRunner는 호스트에서 받은 데이터를 디버깅을 위해 표준 오류(stderr)로 되돌려 보냅니다.'
# 'The LMUL to use for getRegisterBitWidth queries. Affects LMUL used by autovectorized code. Fractional LMULs are not supported.'
H065EFBB6A92E: 'getRegisterBitWidth 쿼리에 사용할 LMUL입니다. autovectorized 코드에서 사용되는 LMUL에 영향을 줍니다. 분수 LMUL은 지원되지 않습니다.'
# 'The OOO window for processor resources during scheduling.'
H7F8CE8011253: '스케줄링 중 프로세서 자원을 위한 OOO 윈도우.'
# 'The alignment to use when accessing the buffers\nDefault is unaligned\nUse 0 to disable address randomization'
H9D92202DC06A: '버퍼에 접근할 때 사용할 정렬을 지정합니다.\n기본값은 미정렬입니다.\n주소 무작위화를 비활성화하려면 0을 사용하세요'
# 'The amount of branches that we are willing to explore withthe exact algorithm before giving up.'
H46BDE8E006FD: '정확한 알고리즘으로 포기하기 전까지 탐색하려는 가지의 수.'
# 'The associativity of the first cache level.'
H091472E28B2B: '첫 번째 캐시 레벨의 연관성입니다.'
# 'The associativity of the second cache level.'
HEE9D38673E97: '두 번째 캐시 레벨의 결합도입니다.'
# 'The average lifetime (s) for an allocation to be considered cold'
H31CAA2FC4467: '할당이 차가운 것으로 간주되기 위한 평균 수명 (초)'
# 'The average number of profile counters allocated per value profiling site.'
H3EFF8568FB96: '값 프로파일링 사이트당 할당된 프로파일 카운터의 평균 개수입니다.'
# 'The base class for the ops in the dialect we are planning to emit'
HA507EEDE87C4: '이 방언에서 생성할 계획인 연산들의 기본 클래스'
# 'The bonus weight of users of allocas within loop when sorting profitable allocas'
HBDF3A84E4987: '유리한 allocas 정렬 시 루프 내 allocas 사용자의 보너스 가중치'
# 'The clause simdlen must fit the %0-bit lanes in the architectural constraints for SVE (min is 128-bit, max is 2048-bit, by steps of 128-bit)'
H637FD9B0F74C: 'simdlen 절은 SVE의 아키텍처 제약 조건에 맞는 %0비트 레인을 가져야 합니다(최소 128비트, 최대 2048비트, 128비트 단위로 증가해야 함)'
# 'The clause simdlen(1) has no effect when targeting aarch64.'
H28E8D9873AFA: 'simdlen(1) 절은 aarch64를 대상으로 할 때 무효입니다.'
# 'The code working set size is considered huge if the number of blocks required to reach the -profile-summary-cutoff-hot percentile exceeds this count.'
H1D058B3A0D64: '코드 워킹 세트 크기는, -profile-summary-cutoff-hot 백분위까지 도달하기 위해 필요한 블록 수가 이 개수를 초과할 경우 매우 큰 것으로 간주됩니다.'
# 'The code working set size is considered large if the number of blocks required to reach the -profile-summary-cutoff-hot percentile exceeds this count.'
H0799198BEFDB: '코드 작업 세트 크기는 다음 조건을 충족하면 큰 것으로 간주됩니다: -profile-summary-cutoff-hot 백분위까지 도달하기 위해 필요한 블록 수가 이 카운트를 초과할 경우'
# 'The coefficient used when initializing II in the window algorithm.'
H8ABBDA1465FF: '창 알고리즘에서 II를 초기화할 때 사용되는 계수입니다.'
# 'The compilation directory to embed in the coverage mapping.'
HC40AB6D0A1C3: '커버리지 매핑에 내장할 컴파일 디렉토리.'
# 'The compilation directory to embed in the debug info'
H7AE615281122: '디버그 정보에 내장할 컴파일 디렉토리'
# 'The compilation directory to embed in the debug info and coverage mapping.'
HAD4DB13A434F: '디버그 정보와 커버리지 매핑에 내장될 컴파일 디렉토리'
# 'The cost of a histcnt instruction'
HC55AE2001899: 'histcnt 명령어의 비용'
# "The cost of a loop that is considered 'small' by the interleaver."
HF5F932DA0017: "인터리버에 의해 '작은' 것으로 간주되는 루프의 비용."
# 'The cost of a step in a different basic block than the killing MemoryDef(default = 5)'
H38215D7CEF6B: '기본 블록 외의 다른 블록에서 발생한 단계의 비용(killing MemoryDef 기본값 = 5)'
# 'The cost of a step in the same basic block as the killing MemoryDef(default = 1)'
HA3C397AE67B6: '동일한 기본 블록 내 killing MemoryDef 단계의 비용(기본값 = 1)'
# 'The cost of decreasing a block count by one.'
HBA666F36C915: '블록 카운트를 1 감소시킬 때의 비용.'
# "The cost of decreasing a block's count by one."
H9FCF3A04FBC3: '블록의 카운트를 1씩 줄이는 비용.'
# 'The cost of decreasing a jump count by one.'
H01994AC78D25: '점프 카운트를 1 감소시킬 때의 비용.'
# "The cost of decreasing the entry block's count by one."
HCE46A7F305CE: '엔트리 블록의 카운트를 1 감소시킨 비용.'
# 'The cost of increasing a block count by one.'
HAE44BF594D73: '블록 카운트를 1 증가시키는 비용.'
# "The cost of increasing a block's count by one."
H35BD66941EB2: '블록의 카운트를 1 증가시키는 비용.'
# 'The cost of increasing a count of zero-weight block by one.'
H15D3659B2D6D: '무게가 없는 블록의 개수를 1 증가시키는 비용.'
# 'The cost of increasing a jump count by one.'
HBEF3551C10D0: '점프 카운트를 1 증가시키는 비용.'
# 'The cost of increasing an unknown block count by one.'
H70FD1895A2F3: '알 수 없는 블록 카운트를 1 증가시키는 비용.'
# "The cost of increasing an unknown block's count by one."
H058C9FB6BA79: '알 수 없는 블록의 카운트를 1 증가시키는 비용.'
# 'The cost of increasing an unknown fall-through jump count by one.'
H8E3789B6B289: '알 수 없는 fall-through 점프 카운트를 1 증가시키는 비용.'
# 'The cost of increasing an unknown jump count by one.'
H08B8AF9F180A: '알 수 없는 점프 카운트를 1 증가시키는 비용.'
# "The cost of increasing the entry block's count by one."
H199FDB30E747: '엔트리 블록의 카운트를 1 증가하는 비용.'
# 'The cost threshold for call sites that get inlined without the cost-benefit analysis'
HBDFEA6BEED2A: '비용-효용 분석 없이 인라인되는 호출 위치의 비용 임계값'
# 'The cost threshold for loop unrolling'
H4E87362F1A39: '루프 언롤링을 위한 비용 임계값'
# 'The cost threshold for loop unrolling when optimizing for size'
H3ADA25107614: '크기 최적화 시 루프 언롤링을 위한 비용 임계값'
# 'The cost threshold for partial loop unrolling'
H467DE32D1CDF: '부분 루프 언롤링을 위한 비용 임계값'
# 'The cost threshold for unswitching a loop.'
HEDD158AF26CA: '루프 언스위칭을 위한 비용 임계값입니다.'
# 'The current shard index'
H876C17A38CA1: '현재 샤드 인덱스'
# 'The default 2nd-level tile size (if not enough were provided by --polly-2nd-level-tile-sizes)'
H1853EDCB107B: '2차 레벨 블록 크기의 기본값 (충분히 제공되지 않았을 경우 --polly-2nd-level-tile-sizes에서 지정됨)'
# 'The default address space is assumed as the flat address space. This is mainly for test purpose.'
HE348DDF306A6: '기본 주소 공간은 플랫 주소 공간으로 가정됩니다. 이는 주로 테스트 용도입니다.'
# 'The default associativity of the first cache level (if not enough were provided by the TargetTransformInfo).'
HCCD8A81B4765: '첫 번째 캐시 레벨의 기본 결합도 (TargetTransformInfo에서 제공된 것이 충분하지 않은 경우).'
# 'The default associativity of the second cache level (if not enough were provided by the TargetTransformInfo).'
HEEAD0D6C75FB: '두 번째 캐시 레벨의 기본 결합도(TargetTransformInfo에서 충분히 제공되지 않았을 경우)'
# 'The default maximum header size for automatic loop rotation'
HF0260F4FDAA5: '자동 루프 회전에 대한 기본 최대 헤더 크기'
# 'The default memprof options'
H38DAB40B2AAC: 'memprof 기본 옵션'
# 'The default register tile size (if not enough were provided by --polly-register-tile-sizes)'
H64576F36AC63: '등록 타일 크기의 기본값 (옵션 --polly-register-tile-sizes로 충분히 제공되지 않았을 경우)'
# 'The default size of the first cache level specified in bytes (if not enough were provided by the TargetTransformInfo).'
H868C869C4E16: '바이트 단위로 지정된 첫 번째 캐시 레벨의 기본 크기 (TargetTransformInfo에서 제공된 값이 충분하지 않을 경우)'
# 'The default size of the second cache level specified in bytes (if not enough were provided by the TargetTransformInfo).'
HD12A54581382: '바이트 단위로 지정된 두 번째 캐시 레벨의 기본 크기(TargetTransformInfo가 제공한 값이 충분하지 않은 경우).'
# 'The default tile size (if not enough were provided by --polly-tile-sizes)'
HE4A483AAF938: '기본 타일 크기 (만약 --polly-tile-sizes에서 충분히 제공되지 않았을 경우)'
# 'The desired fields order.'
HFD5615C7395D: '원하는 필드 순서.'
# 'The dialect to gen for'
H28E806FCDC03: '생성할 방언'
# 'The dialect to run the generator for'
H6FB81B13F4F4: '생성기를 실행하기 위한 방언'
# 'The directory to import the .jscop files from.'
H46C31664F90D: 'jscop 파일을 가져올 디렉토리'
# 'The directory which holds the compiler resource files'
HD211B444AC1B: '컴파일러 리소스 파일을 보관하는 디렉토리'
# 'The element type include parents in its name.'
H2A080E537B74: '요소 유형은 이름에 부모를 포함합니다.'
# 'The estimated size of the generated function (# of instrs)'
HF9641D0FB6D1: '생성된 함수의 추정 크기 (명령문 개수)'
# 'The exception model'
HE9B3D391FF5A: '예외 모델'
# 'The file offset to explain'
HBBF973A12DBA: '설명할 파일 오프셋'
# 'The file to write the stream to'
HCE306C17C319: '스트림을 쓰기 위한 파일'
# 'The float ABI to use'
HD1594C861A1C: '사용할 float ABI'
# 'The format of the remarks.'
H4E4CD6B16734: '비고의 포맷입니다.'
# 'The format that output stacks should be output in. Only applies with all-stacks.'
H212557A1C0DC: '출력할 스택들의 형식을 지정합니다. all-stacks와 함께 사용될 때만 적용됩니다.'
# 'The format used for serializing remarks (default: YAML)'
H5541A330FC11: '비고를 시리얼라이즈하는 데 사용되는 포맷 (기본값: YAML)'
# 'The function to be called'
H3E644E558FC4: '호출할 함수'
# 'The gcc binary to use.'
H0F09D1C4ABDE: '사용할 gcc 이진 파일입니다.'
# 'The index or name of the stream whose contents to export'
H516360D4E007: '내용을 내보낼 스트림의 색인 또는 이름'
# 'The isl scheduling optimizer'
H0188CDF20DCD: 'isl 스케줄링 최적화기'
# 'The kind of context sensitive profile guided optimization'
H057E88E7BF63: '컨텍스트 민감 프로파일 지도 최적화의 유형'
# 'The kind of dependence analysis to use'
HAC9C6B2E0446: '사용할 의존성 분석 유형'
# 'The kind of profile guided optimization'
H930EACDC046E: '프로파일 지도 최적화의 종류'
# 'The level of dependence analysis'
HDB7D1F3D8221: '의존성 분석 수준'
# 'The limit on recursion depth for LSRs setup cost'
H429ADCFB8F2B: 'LSRs 설정 비용에 대한 재귀 깊이 제한'
# 'The limit to use while constructing the DAG prior to scheduling, at which point a trade-off is made to avoid excessive compile time.'
H7C463E6FF16B: 'DAG를 구성하는 동안 스케줄링 전에 사용하는 제한으로, 과도한 컴파일 시간을 피하기 위해 타협점을 마련하는 시점입니다.'
# 'The list of function names in which Emscripten-style exception handling is enabled (see emscripten EMSCRIPTEN_CATCHING_ALLOWED options)'
H0AFF9B181379: 'Emscripten 스타일 예외 처리가 활성화된 함수 이름 목록 (emscripten EMSCRIPTEN_CATCHING_ALLOWED 옵션 참조)'
# 'The list of the names of classes being moved, e.g. "Foo,a::Foo,b::Foo".'
HC13468BE141E: '이동 중인 클래스의 이름 목록, 예: "Foo,a::Foo,b::Foo".'
# 'The lower bound of size growth limit for proirity-based sample profile loader inlining.'
HA4426ABB67AB: '우선순위 기반 샘플 프로파일 로더 인라인을 위한 크기 성장 한계의 하한'
# 'The lower limit of the difference between best II and base II in the window algorithm. If the difference is smaller than this lower limit, window scheduling will not be performed.'
H2D09F1B7EEED: '윈도우 알고리즘에서 최적 II와 기준 II 사이의 차이의 하한값입니다. 차이가 이 하한값보다 작을 경우, 윈도우 스케줄링은 수행되지 않습니다.'
# 'The lower limit of the scheduling region in the window algorithm.'
H40693E0BEF44: '윈도우 알고리즘에서 스케줄링 영역의 하한 값.'
# 'The max number of exiting blocks of a loop to allow  speculative counter promotion'
H126EBD7EDF69: '추측적 카운터 프로모션을 허용하기 위한 루프의 종료 블록 최대 개수'
# 'The max number of instructions to consider hoisting loads over (the algorithm is quadratic over this number)'
HB921741F8462: 'hoisting을 고려할 로드의 최대 명령문 수 (이 알고리즘은 이 수에 대해 2차 시간 복잡도를 가집니다)'
# 'The max number of iteration for converge'
HD528CDF78026: '수렴을 위한 반복 최대 횟수'
# 'The max of trip count upper bound that is considered in unrolling'
HD5BFA5564179: '언롤링에서 고려되는 트립 카운트 상한의 최대값'
# 'The max version for the optimized memory  intrinsic calls'
H2E88F9E75F60: '최적화된 메모리 intrinsic 호출의 최대 버전'
# 'The maximal coefficient allowed (-1 is unlimited)'
H09B28C36A559: '허용되는 최대 계수 (-1은 제한 없음)'
# 'The maximal constant term allowed (-1 is unlimited)'
HF9153E8F373E: '허용되는 최대 상수 항 (-1은 제한 없음)'
# 'The maximal number of arrays to compare in each alias group.'
HE46CCE04E50E: '각 별칭 그룹에서 비교할 배열의 최대 수입니다.'
# 'The maximal number of disjunts allowed in memory accesses to to build RTCs.'
H810D09DBDCF0: '메모리 접근을 통해 RTC를 생성하기 위해 허용되는 disjuncts의 최대 개수입니다.'
# 'The maximal number of parameters allowed in RTCs.'
HD93322BFBD09: 'RTCs에서 허용되는 매개변수의 최대 개수입니다.'
# "The maximum 'boost' (represented as a percentage >= 100) applied to the threshold when aggressively unrolling a loop due to the dynamic cost savings. If completely unrolling a loop will reduce the total runtime from X to Y, we boost the loop unroll threshold to DefaultThreshold*std::min(MaxPercentThresholdBoost, X/Y). This limit avoids excessive code bloat."
H02A5B75E496D: "동적 비용 절감으로 인해 적극적으로 루프를 펼칠 때 闽reshold에 적용되는 최대 'boost' (100 이상의 백분율로 표현됨)입니다. 만약 루프를 완전히 펼쳐 총 실행 시간을 X에서 Y로 줄일 경우, 우리는 루프 언롤 임계값을 DefaultThreshold*std::min(MaxPercentThresholdBoost, X/Y)로 증가시킵니다. 이 제한은 과도한 코드 팽창을 방지합니다."
# 'The maximum LMUL value to use for fixed length vectors. Fractional LMUL values are not supported.'
H8B177E0FA80A: '고정 길이 벡터에 사용할 최대 LMUL 값입니다. 분수 LMUL 값은 지원되지 않습니다.'
# 'The maximum allowed number of runtime memory checks'
HF580EDA4AA2E: '런타임 메모리 검사의 허용 최대 수'
# 'The maximum cost used for building integers.'
H61DA215B1301: '정수를 구성하는 데 사용되는 최대 비용.'
# 'The maximum distance (in bytes) of a backward jump for ExtTSP'
H1AADC32AA7A5: 'ExtTSP의 후진 점프에 대한 최대 거리(바이트 단위)'
# 'The maximum distance (in bytes) of a forward jump for ExtTSP'
H8BF30ACF7ADE: 'ExtTSP에 대한 앞쪽 점프의 최대 거리(바이트 단위로)'
# 'The maximum distance (in bytes) of backward jumps for ExtTSP value'
H7CD48ED835E9: 'ExtTSP 값에 대한 역방향 점프의 최대 거리(바이트 단위)'
# 'The maximum interleave count to use when interleaving a scalar reduction in a nested loop.'
H672121274D43: '중첩 루프에서 스칼라 축소를 중첩할 때 사용할 최대 중첩 횟수입니다.'
# 'The maximum length of a constant string for a builtin string cmp call eligible for inlining. The default value is 3.'
H6551F5EAB050: '인라인 가능한 내장 문자열 비교 호출에 사용되는 상수 문자열의 최대 길이입니다. 기본 값은 3입니다.'
# 'The maximum length of a constant string to inline a memchr call.'
HAAA048CEEC02: 'memchr 호출을 인라인하기 위한 상수 문자열의 최대 길이입니다.'
# 'The maximum length of a single temporal profile trace (default: 10000)'
HFAF4CED9A0E5: '단일 시간 프로파일 추적의 최대 길이 (기본값: 10000)'
# 'The maximum levels the DFS-based missing frame search should go with'
H45092EF73D81: 'DFS 기반 누락 프레임 검색이 수행해야 하는 최대 레벨 수'
# 'The maximum look-ahead depth for operand reordering scores'
H3909DC008995: '작업자 재정렬 점수를 위한 최대 전방 탐색 깊이'
# 'The maximum look-ahead depth for searching best rooting option'
H23AE19C8EFE0: '가장 좋은 루팅 옵션을 찾는 데 사용되는 최대 예측 깊이'
# 'The maximum nesting depth allowed for assembly macros.'
H59D58A80D82C: '어셈블리 매크로에 허용되는 최대 중첩 깊이.'
# 'The maximum number candidates that only partially overwrite the killing MemoryDef to consider (default = 5)'
HF74C3F17FA82: 'killing MemoryDef를 부분적으로 덮어쓰는 것만 고려할 최대 후보 수 (기본값 = 5)'
# 'The maximum number of SCEV checks allowed for Loop Distribution'
H6ED62802FFA5: 'Loop 분배를 위한 허용 SCEV 검사의 최대 개수'
# 'The maximum number of SCEV checks allowed for Loop Distribution for loop marked with #pragma clang loop distribute(enable)'
H4DE7DF87A45B: '루프가 #pragma clang loop distribute(enable)로 지정된 루프에 대해 Loop Distribution을 위한 SCEV 확인의 최대 수'
# 'The maximum number of SCEV checks allowed for Loop Load Elimination'
H7F641B62EEBD: 'Loop Load Elimination에 허용되는 SCEV 검사의 최대 개수'
# 'The maximum number of SCEV checks allowed with a vectorize(enable) pragma'
H4BEEB9147A41: '벡터화(enable) pragma로 허용되는 SCEV 검사의 최대 수'
# 'The maximum number of SCEV checks allowed.'
HAB10FFD86827: '허용되는 SCEV 확인의 최대 수.'
# 'The maximum number of blocks to check when trying to prove that all paths to an exit go through a killing block (default = 50)'
HE588309A8379: '킬 블록을 거쳐 종료 지점으로 가는 모든 경로를 증명하려고 할 때 검사할 블록의 최대 수 (기본값 = 50)'
# 'The maximum number of callsites in a function, above which stale profile matching will be skipped.'
H22730C5AA352: '함수 내 호출 지점의 최대 수를 초과하면 오래된 프로파일 매칭이 건너뜁니다.'
# 'The maximum number of clones allowed for a single function specialization'
H9DEE4E0B8275: '단일 함수 특수화에 허용되는 클론의 최대 개수'
# 'The maximum number of functions to track per lattice value'
HCD37A486700C: '각 격자 값마다 추적할 함수의 최대 수'
# 'The maximum number of heap allocations to consider in one function before skipping (to save compilation time). Set to 0 for no limit.'
H9E920C5F07AD: '한 함수에서 건너뛰기 전에 고려할 힙 할당의 최대 수 (컴파일 시간을 절약하기 위해). 0으로 설정하면 제한이 없습니다.'
# 'The maximum number of incoming values a PHI node can have to be considered during the specialization bonus estimation'
H03E2B05D3E4E: '특수화 보너스 추정 시 고려되는 PHI 노드의 최대 들어오는 값 개수'
# 'The maximum number of instructions considered for cycle sinking.'
HEC82079C9F71: '사이클 싱킹을 위해 고려되는 명령문의 최대 수입니다.'
# 'The maximum number of iterations allowed when searching for transitive phis'
H0F558354650E: '전이적 피 노드를 찾을 때 허용되는 반복 횟수의 최대치'
# 'The maximum number of iterations function specialization is run'
H8854F37807C4: '함수 특수화가 실행되는 반복의 최대 수'
# 'The maximum number of parameters allowed when merging functions.'
H24D089F01734: '함수 병합 시 허용되는 매개변수의 최대 개수.'
# 'The maximum number of predecessors a basic block can have to be considered during the estimation of dead code'
HFD5552B5CF15: '사용되지 않는 코드 추정 시 고려되는 기본 블록이 가질 수 있는 최대 이전 블록 수'
# 'The maximum number of scheduling group conflicts which we attempt to solve with the exponential time exact solver. Problem sizes greater than this willbe solved by the less accurate greedy algorithm. Selecting solver by size is superseded by manually selecting the solver (e.g. by amdgpu-igrouplp-exact-solver'
H071D666725DB: '지수 시간 정확한 솔버로 해결하려고 시도하는 스케줄링 그룹 충돌의 최대 수입니다. 이보다 큰 문제 크기는 덜 정확한 그리디 알고리즘으로 해결됩니다. 크기로 솔버를 선택하는 것은 솔버를 수동으로 선택하는 것(예: amdgpu-igrouplp-exact-solver)에 의해 대체됩니다.'
# 'The maximum number of steps while walking upwards to find MemoryDefs that may be killed (default = 90)'
HA207F5C7ADD1: '위쪽으로 이동하면서 제거될 수 있는 MemoryDefs를 찾는 동안의 최대 단계 수(기본값 = 90)'
# 'The maximum number of stored temporal profile traces (default: 100)'
H6A4CCB113506: '저장된 시간적 프로파일 추적의 최대 수 (기본값: 100)'
# 'The maximum number of stores/phis MemorySSAwill consider trying to walk past (default = 100)'
H0C4FBDD67710: 'MemorySSA가 통과하려고 시도할 때 고려하는 저장/phi의 최대 수(기본값 = 100)'
# 'The maximum number of times a live range can be evicted before preventing it from being evicted'
HEF28AF0C80C6: '생존 범위가 강제 이동을 막기 전까지 강제 이동될 수 있는 최대 횟수'
# 'The maximum number of times the analyzer will go through a loop'
H82DC4EFFB765: '분석기가 루프를 반복하는 최대 횟수'
# 'The maximum number of vtable for the last candidate.'
H839DD45E9E74: '마지막 후보에 대한 vtable의 최대 개수.'
# 'The maximum number of warnings to emit when correlating profile from debug info (0 = no limit)'
H710123CD3CA7: '디버그 정보에서 프로필을 연결할 때 발생시키는 경고의 최대 수 (0 = 제한 없음)'
# 'The maximum ratio between densities of two chains for merging'
H459D99ED8D7D: '병합을 위한 두 체인의 밀도 비율 최댓값'
# "The maximum size of a callee that get's inlined without sufficient cycle savings"
H37B172BFF744: '충분한 사이클 절약 없이 인라인되는 호출된 함수의 최대 크기'
# 'The maximum size of a chain to apply splitting'
H74E01FDFE4C4: '분할을 적용하기 위한 체인의 최대 크기'
# 'The maximum size of a chain to create'
H29DFAD1C81AC: '생성할 사슬의 최대 크기'
# 'The maximum size of a function to consider for inference.'
HEC9218936482: '추론을 위해 고려하는 함수의 최대 크기.'
# 'The maximum size of an object in the sdata section'
HE9CFD8856EDF: 'sdata 섹션의 객체의 최대 크기'
# 'The maximum size to use in sweep-mode'
HC4DABE2321EB: '스윕 모드에서 사용할 최대 크기'
# 'The maximum stride, considered to be profitable.'
H091F45C95DD9: '효과적이라고 간주되는 최대 스트라이드.'
# 'The maximum total number of memory locations alias sets may contain before degradation'
H926FBF01198C: '성능 저하 전까지 메모리 위치 별칭 집합이 포함할 수 있는 최대 총 수량'
# 'The minimal number of cycles between issuing two dependent consecutive vector fused multiply-add instructions.'
H4AA5B2DBB66A: '의존적인 연속 벡터 퓨지드 멀티플라이-어드 명령문을 실행하는 사이의 최소 사이클 수입니다.'
# 'The minimal number of per-loop instructions before a single loop region is considered profitable'
H4CE0D632999A: '단일 루프 영역이 수익성 있는 것으로 간주되기 전에 각 루프당 명령문의 최소 수'
# 'The minimum TotalLifetimeAccessDensity / AllocCount for an allocation to be considered hot'
HA94E6199F898: '할당을 hot으로 간주하기 위한 최소 TotalLifetimeAccessDensity / AllocCount 값'
# 'The minimum count to optimize memory intrinsic calls'
HEF63EC815D8B: '메모리 인트리니크 호출을 최적화하기 위한 최소 횟수'
# 'The minimum instruction count required when merging functions.'
HB052AF91D102: '함수를 병합할 때 필요한 최소 명령문 수입니다.'
# 'The minimum number of arguments a function call must have before it is considered having many arguments.'
H384F6CF79650: '함수 호출이 많은 인수를 가진 것으로 간주되기 전에 필요한 최소 인수 개수입니다.'
# 'The minimum number of basic blocks required for a function to run stale profile call graph matching.'
H6DFC7FF9B6F4: '함수가 오래된 프로파일 호출 그래프 매칭을 실행하기 위해 필요한 기본 블록의 최소 개수입니다.'
# 'The minimum number of call anchors required for a function to run stale profile call graph matching.'
HA0900373C45C: '함수가 실행되기 위해 고장난 프로파일 호출 그래프 일치를 위해 필요한 호출 앵커의 최소 수'
# 'The minimum number of instructions a basic block should contain before being considered big.'
H35A15684714E: '기본 블록이 큰 것으로 간주되기 전에 포함해야 하는 명령문의 최소 수.'
# 'The minimum number of instructions a basic block should contain before being considered medium-sized.'
HE3CFEDACCE84: '기본 블록이 중간 크기로 간주되기 전에 포함해야 하는 명령문의 최소 수입니다.'
# 'The minimum number of instructions that are outlined in a frame helper (default = 2)'
HDCE9324580BB: '프레임 헬퍼에 명시된 명령문의 최소 개수 (기본값 = 2)'
# 'The minimum number of instructions that should be included in the snippet'
HD8B3E130AB22: '스니펫에 포함되어야 하는 명령문의 최소 수'
# 'The minimum number of loads, which should be considered strided, if the stride is > 1 or is runtime value'
HA691E257E6C6: '스트라이드가 1보다 크거나 런타임 값인 경우 스트라이드 로드로 간주할 로드의 최소 개수'
# 'The minimum size in bytes before an outlining candidate is accepted'
H382DFDE541E3: '아웃라인 후보가 수락되기 전에 요구되는 바이트 단위의 최소 크기'
# 'The minimum size in bytes of each global that should considered in merging.'
HAE0FA4D9E816: '결합 시 고려되어야 하는 각 전역 객체의 바이트 단위 최소 크기입니다.'
# 'The minimum size to use in sweep-mode'
HA2F6EC5B505C: 'sweep-mode에서 사용할 최소 크기'
# 'The model being trained for register allocation eviction'
H7FEA0D631D24: '훈련 중인 레지스터 할당 제거 모델'
# 'The model being trained for register allocation priority'
H417CF14D5A6E: '레지스터 할당 우선순위를 위해 훈련 중인 모델'
# 'The name for this study'
H400FDCCEAC14: '이 연구의 이름'
# 'The name of a function (or its substring) whose CFG is viewed/printed.'
HD3E3246593FE: 'CFG가 표시되거나 출력되는 함수의 이름(또는 그 부분 문자열).'
# 'The name of a validation counter to run concurrently with the main counter to validate benchmarking assumptions'
HABCFB9B683CF: '벤치마크 가정을 검증하기 위해 메인 카운터와 동시에 실행할 검증 카운터의 이름'
# 'The name of the ABI to be targeted from the backend.'
H3EC72F95FC35: '백엔드에서 지정할 ABI의 이름입니다.'
# 'The name of the distribution to use'
HF09A01C5BE8E: '사용할 분포의 이름'
# 'The name of the executor to use.'
H9A67A8D34CB5: '사용할 실행기(executor)의 이름입니다.'
# "The name of the predefined style used as a\nfallback in case clang-format is invoked with\n-style=file, but can not find the .clang-format\nfile to use. Defaults to 'LLVM'.\nUse -fallback-style=none to skip formatting."
H605E77115F2D: "미리 정의된 스타일 중에서 사용되는 이름\nclang-format이 -style=file 옵션으로 호출되었을 때\n사용할 수 있는 .clang-format 파일을 찾을 수 없을 때 대체됩니다.\n기본값은 'LLVM'입니다.\n-fallback-style=none 옵션을 사용하면 포맷팅을 건너뛸 수 있습니다."
# 'The name of the struct/class.'
HA728CE8CB2EB: '구조체/클래스의 이름입니다.'
# 'The name of this group of passes'
HE53A929D4575: '이 패스 그룹의 이름'
# 'The number of MemoryDefs we consider as candidates to eliminated other stores per basic block (default = 5000)'
HB4E81F98BD76: '기본 블록당 다른 저장을 제거하기 위해 후보로 고려하는 MemoryDefs의 수 (기본값 = 5000)'
# 'The number of benchmarks run to perform'
H643296C3A4C1: '실행하기 위해 수행된 벤치마크의 수'
# 'The number of blocks to scan during memory dependency analysis (default = 200)'
HD2242DBDE5D7: '메모리 종속성 분석 중 스캔할 블록의 수(기본값 = 200)'
# 'The number of instructions to scan in a block in memory dependency analysis (default = 100)'
H2BC6010D3D27: '메모리 종속성 분석에서 블록당 스캔할 명령문의 수 (기본값 = 100)'
# 'The number of instructions to search for a redundant dmb'
HD7126DC70D5E: '중복된 dmb를 찾기 위해 검색할 명령어의 수'
# 'The number of loads per basic block for inline expansion of memcmp that is only being compared against zero.'
HE7402F9BFD73: '0과만 비교되는 memcmp의 인라인 확장에 대한 기본 블록당 로드 수'
# 'The number of loop iterations to strip-mine for pre-vectorization'
H73D394A3273E: 'pre-vectorization을 위해 스트립 마이닝하는 루프 반복 횟수'
# 'The number of memory instructions to scan for dead store elimination (default = 150)'
H0D792B752EF6: '사용되지 않은 저장 제거를 위해 스캔하는 메모리 명령문의 수 (기본값 = 150)'
# 'The number of precise steps between two approximating iterations. (A value of -1 schedules another approximation stage before the actual dead code elimination.'
H795458185A22: '두 근사 반복 사이의 정확한 단계 수입니다. (값이 -1인 경우 실제 죽은 코드 제거 이전에 추가적인 근사 단계를 실행합니다.'
# 'The number of predecessors to search for a stronger condition to use to thread over a weaker condition'
H7527D41A84C6: '약한 조건을 대신 사용할 강력한 조건을 찾기 위해 검색할 이전 노드의 수'
# 'The number of searches per loop in the window algorithm. 0 means no search number limit.'
H1DDD94D0908A: '창 알고리즘에서 각 루프당 검색 횟수. 0은 검색 횟수 제한이 없음을 의미합니다.'
# 'The number of shards into which the op classes will be divided'
H2AD8480DFFBC: '연산 클래스가 분할될 쉐이드(shard)의 수'
# 'The number of threads used to process all files in parallel. Set to 0 for hardware concurrency. This flag only applies to all-TUs.'
H14270C0E6B74: '병렬로 모든 파일을 처리하는 데 사용되는 스레드의 수입니다. 하드웨어 동시성을 사용하려면 0으로 설정합니다. 이 플래그는 all-TUs에만 적용됩니다.'
# 'The number of times to repeat measurements on the benchmark k before aggregating the results'
HEB3E720640C3: '결과를 집계하기 전에 벤치마크 k에 대해 측정을 반복하는 횟수'
# 'The option is used to turn on/off warnings about hash mismatch for comdat or weak functions.'
HB9E7F6492359: '이 옵션은 comdat 또는 weak 함수에 대한 해시 불일치 경고를 켜거나 끌 수 있습니다.'
# 'The option to specify the name of the function whose CFG will be displayed.'
H14BF30CA9694: 'CFG가 표시될 함수 이름을 지정하는 옵션입니다.'
# 'The option to specify the name of the function whose block frequency info is printed.'
H669D97AE9C69: '블록 빈도 정보를 출력할 함수의 이름을 지정하는 옵션입니다.'
# 'The option to specify the name of the function whose branch probability info is printed.'
H64FA83ADF33F: '분기 확률 정보를 출력하는 함수의 이름을 지정하는 옵션입니다.'
# 'The option to specify the name of the functions to verify.'
H99F22C3FC88F: '검증할 함수의 이름을 지정하는 옵션입니다.'
# 'The overhead cost associated with each function call when merging functions.'
HFC522517EF09: '함수를 병합할 때 각 함수 호출에 대한 오버헤드 비용.'
# 'The overhead cost associated with each instruction when lowering to machine instruction.'
H77BF5CB5FA41: '머신 명령어로 변환할 때 각 명령어와 연관된 오버헤드 비용.'
# 'The overhead cost associated with each parameter when merging functions.'
H1DB7993015A4: '함수 병합 시 각 매개변수와 관련된 오버헤드 비용.'
# 'The page size of the target in bytes'
H1B53A7D2781D: '타겟의 페이지 크기(바이트 단위)'
# 'The percentage threshold against remaining unpromoted indirect call count for the promotion'
HE86B36D2F491: '프로모션을 위해 남아 있는 프로모션되지 않은 간접 호출 수 대비 퍼센트 임계값'
# 'The percentage threshold against remaining unpromoted indirect call count for the promotion for calls'
H781076CED89A: '호출 프로모션을 위해 남아 있는 비프로모션된 간접 호출 수에 대한 퍼센트 임계값'
# 'The percentage threshold against remaining unpromoted indirect call count for the promotion for jump tables'
H136B41571D6C: '점프 테이블을 위한 프로모션에 대한 남아 있는 프로모션되지 않은 간접 호출 수에 대한 퍼센트 임계값'
# 'The percentage threshold against total count for the promotion'
H6676D5E1FF86: '프로모션에 대한 총 카운트 대비 퍼센트 임계값'
# 'The percentage threshold against total count for the promotion for calls'
H48EACF9E7526: '호출을 위한 프로모션에 대한 총 카운트 대비 퍼센트 임계값'
# 'The percentage threshold against total count for the promotion for jump tables'
HA1920C4CE7DC: '점프 테이블의 프로모션을 위한 전체 카운트 대비 퍼센트 임계값'
# 'The percentage threshold for the memory intrinsic calls optimization'
HED02E6485AF5: '메모리 고유 함수 호출 최적화를 위한 백분율 임계값'
# 'The percentage threshold of vtable-count / function-count for cost-benefit analysis.'
H65D337CD6C45: '비용-효용 분석을 위한 vtable-count / function-count의 백분율 임계값.'
# 'The position of the cursor when invoking\nclang-format from an editor integration'
H2456492C399B: '에디터 통합을 통해 clang-format을 호출할 때 커서의 위치'
# 'The power exponent for the distance-based locality'
HE2E30EB8297B: '거리 기반 지역성의 지수'
# 'The prefix of the dialect extension'
HB374D232EB61: '방언 확장의 접두사'
# 'The prefix to use for this group of passes. The form will be mlirCreate<prefix><passname>, the prefix can avoid conflicts across libraries.'
HDCE2477640BC: '이 패스 그룹에 사용할 접두사입니다. 형식은 mlirCreate<prefix><passname>이 되며, 이 접두사는 라이브러리 간 충돌을 피할 수 있습니다.'
# 'The prefix used for the CFG dot file names.'
H3299C4982B02: 'CFG dot 파일 이름에 사용되는 접두사.'
# 'The prefix used for the CallGraph dot file names.'
HAC819E10CA1B: 'CallGraph dot 파일 이름에 사용되는 접두사.'
# 'The prefix used for the DDG dot file names.'
HF593C1E1F184: 'DDG dot 파일 이름에 사용되는 접두사.'
# 'The prefix used for the Machine CFG dot file names.'
H54988740C957: '머신 CFG 도트 파일 이름에 사용되는 접두사입니다.'
# 'The probability of a guard failing is assumed to be the reciprocal of this value (default = 1 << 20)'
H54F7AFA0E05B: '가드가 실패할 확률은 이 값의 역수로 가정됩니다 (기본값 = 1 << 20)'
# 'The probability threshold of enabling branch hint.'
HDA416C9E705B: '브랜치 힌트를 활성화하는 데 사용되는 확률 임계값.'
# 'The profile guided size optimization profile summary cutoff for instrumentation profile.'
H416C25DD1085: '프로파일 가이드 사이즈 최적화 프로파일 요약 절단값을 인스트루먼테이션 프로파일에 적용합니다.'
# 'The profile guided size optimization profile summary cutoff for sample profile.'
H7CFAC61196B3: '샘플 프로파일의 프로파일 가이드 크기 최적화 프로파일 요약 잘림 임계값.'
# 'The ratio of searches per loop in the window algorithm. 100 means search all positions in the loop, while 0 means not performing any search.'
H69F36D760102: '윈도우 알고리즘에서 각 루프 당 검색 비율입니다. 100은 루프 내 모든 위치를 검색하는 것을 의미하고, 0은 검색을 전혀 수행하지 않는 것을 의미합니다.'
# 'The relative/absolute file path of new cc.'
HE0F45871CC31: '새로운 cc의 상대/절대 파일 경로.'
# 'The relative/absolute file path of new header.'
H4D4C2CCB6DC7: '새 헤더 파일의 상대/절대 파일 경로.'
# 'The relative/absolute file path of old cc.'
H9627E5223A5E: '구 버전의 cc의 상대/절대 파일 경로'
# 'The relative/absolute file path of old header.'
H13E40B3B27E1: '구 헤더의 상대/절대 파일 경로입니다.'
# 'The relocation model to use'
H8DE955C1B327: '사용할 리로케이션 모델'
# 'The sample period (nbranches/sample), used for LBR sampling'
H61D3CFB88363: '샘플링 주기(nbranches/sample), LBR 샘플링에 사용됩니다'
# 'The scale factor for the frequency-based locality'
H4C2907D8364D: '주파수 기반 로컬리티의 스케일 요소'
# 'The scale factor used to scale the working set size of the partial sample profile along with the partial profile ratio. This includes the factor of the profile counter per block and the factor to scale the working set size to use the same shared thresholds as PGO.'
H7BF4A788068D: '부분 샘플 프로파일의 작업 집합 크기와 함께 부분 프로파일 비율을 조정하는 데 사용되는 스케일 요인입니다. 이는 블록당 프로파일 카운터의 인자 및 PGO와 동일한 공유 임계값을 사용하기 위해 작업 집합 크기를 조정하는 인자를 포함합니다.'
# 'The seed used by the randomize structure layout feature'
H3D8BA8E60ECF: '구조체 레이아웃 무작위화 기능에 사용되는 시드'
# 'The selected source range in which the refactoring should be initiated (<file>:<line>:<column>-<line>:<column> or <file>:<line>:<column>)'
H9B806B9A88F2: '리팩토링을 시작할 선택된 소스 범위 (<파일>:<줄>:<열>-<줄>:<열> 또는 <파일>:<줄>:<열>)'
# 'The size growth ratio limit for proirity-based sample profile loader inlining.'
H93A8BBE0A03D: '우선순위 기반 샘플 프로파일 로더 인라인에 대한 크기 증가 비율 제한.'
# "The size in bits of a vector register (if not set, this information is taken from LLVM's target information."
H4457D4EEB097: '벡터 레지스터의 크기(비트 단위)입니다(설정되지 않았을 경우 이 정보는 LLVM의 타겟 정보에서 가져옵니다).'
# 'The size of a line in the cache'
H3FC377B654FB: '캐시 라인의 크기'
# 'The size of the cache'
H1AFA9403E784: '캐시의 크기'
# 'The size of the first cache level specified in bytes.'
H79C5863504EE: '바이트로 지정된 첫 번째 캐시 레벨의 크기입니다.'
# 'The size of the first level cache line size specified in bytes.'
H0A19D3F7EF60: '바이트 단위로 지정된 첫 번째 레벨 캐시 라인 크기입니다.'
# 'The size of the second level specified in bytes.'
HE64C9129467C: '바이트 단위로 지정된 두 번째 레벨의 크기'
# 'The string to embed in the .LLVM.command.line section.'
H96651B0831DF: 'LLVM.command.line 섹션에 삽입할 문자열입니다.'
# 'The string to embed in the Dwarf debug AT_producer record.'
H309333DFFAC0: 'DWARF 디버그 AT_producer 레코드에 내장할 문자열입니다.'
# 'The string to embed in the Dwarf debug flags record.'
H8A887C2C292E: 'DWARF 디버그 플래그 레코드에 삽입할 문자열입니다.'
# 'The style name used for reformatting.'
H6C1DBF661954: '리포맷에 사용되는 스타일 이름입니다.'
# 'The style name used for reformatting. Default is "llvm"'
H6E46319C3C34: '재포맷에 사용되는 스타일 이름입니다. 기본값은 "llvm"입니다'
# 'The summary file to use for function importing.'
H956C0535484D: '함수 가져오기에 사용할 요약 파일입니다.'
# 'The target Objective-C runtime supports ARC weak operations'
HDFF376EEF6B3: '목표 Objective-C 런타임은 ARC 약한 연산을 지원합니다'
# 'The text prefix to use for cold basic block clusters'
H9A41E3E09F36: 'cold basic block 클러스터에 사용할 텍스트 접두사'
# "The thread model to use. Defaults to 'posix')"
HBBA4CDE4A320: "사용할 스레드 모델. 기본값은 'posix'입니다)"
# 'The threshold (unit M) for flushing LLVM bitcode.'
H38AA697B02D6: 'LLVM 비트코드를 플러싱하는 임계값 (단위 M).'
# 'The threshold for fast cluster'
HC068F875B090: '빠른 클러스터를 위한 임계값'
# 'The threshold for splitting a virtual register with a hint, in percentage'
H722FAD4D0C5E: '힌트가 있는 가상 레지스터를 분할하는 데 사용되는 임계값(퍼센트 단위)'
# 'The threshold the lifetime access density (accesses per byte per lifetime sec) must be under to consider an allocation cold'
HDA979A1E26A3: '생명 주기 접근 밀도(바이트당 생명 주기 초당 접근 수)가 할당을 cold로 판단하기 위해 넘지 않아야 하는 임계값'
# 'The type of aggregation to do on call stacks.'
H148D7C9D6F12: '콜 스택에 적용할 집계 유형.'
# 'The type of output desired'
HD9FFCDBCB5F5: '원하는 출력 형식'
# 'The upper bound of size growth limit for proirity-based sample profile loader inlining.'
H4AEDA738C805: '프라이어리티 기반 샘플 프로필 로더 인라인에 대한 크기 성장 한계의 상한 값.'
# 'The upper limit of II in the window algorithm.'
H6259F5DF8819: '윈도 알고리즘에서 II의 상한입니다.'
# 'The value specified in simdlen must be a power of 2 when targeting Advanced SIMD.'
HAAC03787F717: 'simdlen에 지정된 값은 Advanced SIMD를 대상으로 할 때 2의 거듭제곱이어야 합니다.'
# 'The vectorization factor for byte-compare patterns.'
H892AED0C291C: '바이트 비교 패턴에 대한 벡터화 계수.'
# 'The vectorization style for loop idiom transform.'
HEB4892D4C0B2: '루프 아이디오 변환을 위한 벡터화 스타일입니다.'
# 'The version of darwin target variant SDK used for compilation'
H11C241DE938D: '컴파일에 사용된 Darwin 타겟 변종 SDK의 버전'
# 'The version of target SDK used for compilation'
H4C1FC7BD91CD: '컴파일에 사용된 타겟 SDK의 버전'
# 'The visibility for definitions without an explicit DLL storage class. If Keep is specified the visibility is not adjusted [-fvisibility-from-dllstorageclass]'
H5B42685299F4: '명시적인 DLL 저장 클래스가 없는 정의의 가시성입니다. Keep가 지정되면 가시성이 조정되지 않습니다. [-fvisibility-from-dllstorageclass]'
# 'The visibility for dllexport definitions. If Keep is specified the visibility is not adjusted [-fvisibility-from-dllstorageclass]'
H89FA30D717F3: 'dllexport 정의의 visibility입니다. Keep가 지정되면 visibility가 조정되지 않습니다. [-fvisibility-from-dllstorageclass]'
# 'The visibility for dllimport external declarations. If Keep is specified the visibility is not adjusted [-fvisibility-from-dllstorageclass]'
H67F478EEEC59: 'dllimport 외부 선언의 가시성입니다. Keep이 지정되면 가시성이 조정되지 않습니다. [-fvisibility-from-dllstorageclass]'
# 'The visibility for external declarations without an explicit DLL storage class. If Keep is specified the visibility is not adjusted [-fvisibility-from-dllstorageclass]'
H64D964A1CD05: '명시적인 DLL 저장 클래스가 없는 외부 선언에 대한 가시성입니다. Keep 옵션이 지정되면 가시성이 조정되지 않습니다. [-fvisibility-from-dllstorageclass]'
# "The visibility for global C++ operator new and delete declarations. If 'source' is specified the visibility is not adjusted"
H9A7A28615088: "C++ 전역 operator new 및 delete 선언의 가시성입니다. 'source'가 지정되면 가시성은 조정되지 않습니다"
# 'The weight of backward jumps for ExtTSP value'
H0E7F2365F191: 'ExtTSP 값에 대한 후진 점프의 가중치'
# 'The weight of conditional backward jumps for ExtTSP value'
H1A51FA791B5C: 'ExtTSP 값에 대한 조건부 뒤로 점프의 가중치'
# 'The weight of conditional fallthrough jumps for ExtTSP value'
H17243DA21A4A: 'ExtTSP 값에 대한 조건부 통과 점프의 가중치'
# 'The weight of conditional forward jumps for ExtTSP value'
H37AE1F715474: 'ExtTSP 값에 대한 조건부 전방 점프의 가중치'
# 'The weight of unconditional backward jumps for ExtTSP value'
HF65A2E202044: 'ExtTSP 값에 대한 조건 없는 후방 점프의 가중치'
# 'The weight of unconditional fallthrough jumps for ExtTSP value'
HAE55A03F6662: 'ExtTSP 값에 대한 조건 없는 fallthrough 점프의 가중치'
# 'The weight of unconditional forward jumps for ExtTSP value'
HAB44DC9D2D01: 'ExtTSP 값에 대한 비조건부 앞으로 점프의 가중치'
# 'These control extra attributes that are added when the element is printed.'
HB2159F65700A: '이 옵션들은 요소가 출력될 때 추가되는 속성들을 제어합니다.'
# 'These control how the elements are printed.'
H28147009F248: '이것들은 요소들이 어떻게 출력되는지 제어합니다.'
# 'These control the generated warnings.'
H7F9E68DBF772: '이 옵션들은 생성된 경고를 제어합니다.'
# 'These control the output generated.'
HFE9BA932DCA9: '이 옵션들은 생성되는 출력을 제어합니다.'
# 'These control the view comparison.'
H014A13BA2172: '이 옵션들은 뷰 비교를 제어합니다.'
# 'These control which elements are printed.'
H47E80A7E5CE7: '이 옵션들은 출력할 요소를 제어합니다.'
# 'These control which elements are selected.'
H093D8C9A169D: '이 옵션들은 선택되는 요소를 제어합니다.'
# 'These control which sections are dumped. Where applicable these parameters take an optional =<offset> argument to dump only the entry at the specified offset.'
H4A05AC913F89: '이 옵션들은 덤프되는 섹션을 결정합니다. 적용 가능한 경우 이 파라미터들은 선택적 =<offset> 인수를 받아 지정된 오프셋의 항목만 덤프합니다.'
# 'ThinLink: produces the index by linking only the summaries.'
H0F627A52D002: 'ThinLink: 요약만 연결하여 인덱스를 생성합니다.'
# "This appends the content hash to the globally outlined function name. It's beneficial for enhancing the precision of the stable hash and for ordering the outlined functions."
H53B60C3E684B: '이 기능은 내용 해시를 전역에 정의된 함수 이름에 추가합니다. 이는 안정된 해시의 정확도를 향상시키고 작성된 함수를 정렬하는 데 도움이 됩니다.'
# 'This argument does not take a value.\n\tInstead, it consumes any positional arguments until the next recognized option.'
H3C3E5BFE7ADE: '이 인수는 값이 없습니다.\n\t대신, 다음에 인식되는 옵션까지 모든 위치 인수를 사용합니다.'
# 'This checks if there is a fdo instr. profile hash mismatch for this function'
HFBA287CE45D4: '이 함수에 대한 FDO instr. 프로필 해시 불일치가 있는지 확인합니다'
# 'This compilation is part of building a PCH with corresponding object file.'
H26F9EC33106E: '이 컴파일은 해당 오브젝트 파일과 함께 PCH를 생성하는 과정의 일부입니다.'
# 'This flag controls the behaviour of fcmp equality comparisons.For equality comparisons such as `x == 0.0f`, we can perform the '
HF143A3F023BD: '이 플래그는 fcmp 동등 비교의 동작을 제어합니다. 예를 들어 `x == 0.0f`와 같은 동등 비교의 경우, 수행할 수 있습니다.'
# 'This is the default. TOC data transformation is not applied to any variables. Only variables specified explicitly in -mtocdata= will have the TOC data transformation.'
HEF7B686F6202: '이것이 기본값입니다. TOC 데이터 변환은 어떠한 변수에도 적용되지 않습니다. 명시적으로 -mtocdata= 옵션에 지정된 변수만 TOC 데이터 변환이 적용됩니다.'
# 'This option is for testing purposes only. It forces BOLT to convert low_pc/high_pc to ranges always.'
H46D236F6D0BE: '이 옵션은 테스트 목적으로만 사용됩니다. 이 옵션은 BOLT가 low_pc/high_pc를 항상 범위로 변환하도록 강제합니다.'
# "Thread pointer access method. For AArch32: 'soft' uses a function call, or 'tpidrurw', 'tpidruro' or 'tpidrprw' use the three CP15 registers. 'cp15' is an alias for 'tpidruro'. For AArch64: 'tpidr_el0', 'tpidr_el1', 'tpidr_el2', 'tpidr_el3' or 'tpidrro_el0' use the five system registers. 'elN' is an alias for 'tpidr_elN'."
H7A1A2BC28705: "쓰레드 포인터 접근 방법. AArch32 아키텍처에서는: 'soft'는 함수 호출을 사용하며, 'tpidrurw', 'tpidruro' 또는 'tpidrprw'는 세 개의 CP15 레지스터를 사용합니다. 'cp15'는 'tpidruro'의 별칭입니다. AArch64 아키텍처에서는: 'tpidr_el0', 'tpidr_el1', 'tpidr_el2', 'tpidr_el3' 또는 'tpidrro_el0'는 다섯 개의 시스템 레지스터를 사용합니다. 'elN'은 'tpidr_elN'의 별칭입니다."
# 'Threshold (in bytes) for the runtime check guarding the memmove.'
HD35FCD3FC79E: 'memmove를 보호하는 런타임 검사의 임계값（바이트 단위）.'
# 'Threshold (in bytes) to perform the transformation, if the runtime loop count (mem transfer size) is known at compile-time.'
H1AD5098411FA: '변환을 수행하기 위한 임계값(바이트 단위)으로, 런타임 루프 카운트(메모리 전송 크기)가 컴파일 타임에 알려지면 사용됩니다.'
# 'Threshold (max size of unrolled loop) to use in aggressive (O3) optimizations'
H18A6C6D55082: '공격적(O3) 최적화에서 사용할 임계값(언롤된 루프의 최대 크기)'
# 'Threshold for hot callsites '
H362D13EBB118: '핫 콜 사이트를 위한 임계값 '
# 'Threshold for inlining addition operands into a SCEV'
HB303871617D0: 'SCEV에 덧셈 피연산자를 인라인하는 데 사용되는 임계값'
# 'Threshold for inlining cold callsites'
H250BE680BE10: '인라인 처리를 위한 콜드 콜 사이트의 임계값'
# 'Threshold for inlining functions with cold attribute'
H574FD1578D90: '콜드 속성이 있는 함수에 대한 인라인 임계값'
# 'Threshold for inlining functions with inline hint'
H393692A6F6FF: 'inline 힌트가 있는 함수 인lining 임계값'
# 'Threshold for inlining multiplication operands into a SCEV'
H07C5BF953E30: 'SCEV에 곱셈 피연산자를 인라인하는 데 사용되는 임계값'
# 'Threshold for locally hot callsites '
H1A9D72E0CF73: '로컬에서 자주 호출되는 호출 위치의 임계값 '
# 'Threshold for partial unrolling'
H6543FABE0767: '부분 언롤링의 임계값'
# 'Threshold for switching to iteratively computing SCEV ranges'
H887AD3A95DC6: '반복적으로 SCEV 범위를 계산하도록 전환하기 위한 임계값'
# 'Threshold for the size of CSUses'
H30C9036D7937: 'CSUses 크기의 임계값'
# 'Threshold for triggering vextract replacement'
HF1A005DB3C4F: 'vextract 대체를触发하는 임계값'
# 'Threshold to use for inner loop when doing unroll and jam.'
HE4FFB8758E97: '내부 루프를 개방 및 결집할 때 사용할 임계값.'
# 'Thumb IT blocks insertion pass'
HD5E87C90A3F2: 'Thumb IT 블록 삽입 패스'
# 'Thumb2 instruction size reduce pass'
HDFB1F7BB57C2: 'Thumb2 명령어 크기 감소 패스'
# 'Tile Copy Lowering'
HD512AA776C9C: '타일 복사 하향'
# 'Tile Register Configure'
HE55B620CE39A: '타일 레지스터 구성'
# 'Tile Register Pre-configure'
H093374BD2768: 'Tile 레지스터 사전 구성'
# 'Tile size for matrix instruction fusion using square-shaped tiles.'
H77BEE628E9E0: '정사각형 모양의 타일을 사용한 매트릭스 명령어 융합을 위한 타일 크기.'
# 'Tilikum Crossing Optimizer\n'
H56081A939218: 'Tilikum Crossing 최적화기\n'
# 'Time each pass run, printing elapsed time for each run on exit'
H9DEAE5CE8A5D: '각 패스 실행 시간을 측정하고 종료 시 각 실행의 경과 시간을 출력합니다'
# 'Time each pass, printing elapsed time for each on exit'
H6752B4F3ED5A: '각 패스의 경과 시간을 측정하고 종료 시 각각의 시간을 출력합니다'
# 'Time individual commands'
H84A9CD566359: '개별 명령어 시간 측정'
# 'Time phases of parser and backend'
HC89B41C0C2D0: '파서 및 백엔드의 단계별 시간 측정'
# 'Time to be used in __DATE__, __TIME__, and __TIMESTAMP__ macros'
H972ECB48D75B: '__DATE__, __TIME__, __TIMESTAMP__ 매크로에서 사용될 시간'
# 'Time when the current build session started'
H702F4D424F4D: '현재 빌드 세션이 시작된 시간'
# 'Tiny code model'
H84F95E67A022: '작은 코드 모델'
# 'Tool Options'
HCB6E15CE20D4: '도구 옵션'
# 'Tool options'
H6AA40067A445: '도구 옵션'
# 'Tool used for detecting AMD GPU arch in the system.'
HF986F57FE389: '시스템에서 AMD GPU 아키텍처를 탐지하는 데 사용되는 도구.'
# 'Tool used for detecting NVIDIA GPU arch in the system.'
H3CE78A0FD186: '시스템에서 NVIDIA GPU 아키텍처를 감지하는 데 사용되는 도구.'
# 'Toolchain identification name.'
H577F665D266E: '도구 사슬 식별 이름.'
# 'Toplevel siblings divisor for cost multiplier.'
H47B1D12D6302: '최상위 형제 분모 비용 곱셈자'
# 'Total samples cutoff for functions used to calculate profile density.'
H4F0CF57C68FB: '프로파일 밀도를 계산하기 위해 사용되는 함수의 전체 샘플 절단값.'
# 'Total size of all blocks (including zero-fill) in all graphs (post-fixup)'
HA9F2ACABE207: '모든 그래프(패치 후) 내의 모든 블록(0으로 채워진 부분을 포함한)의 전체 크기'
# 'Total size of all blocks (including zero-fill) in all graphs (pre-pruning)'
H33F7C5E01044: '모든 그래프(프루닝 전)에서 모든 블록( zero-fill 포함 )의 총 크기'
# 'Trace global value placement'
H3F11F16F204E: '전역 값 배치 추적'
# 'Trace the hash of the function with this name.'
H2FA3F2871F69: '이 이름을 가진 함수의 해시를 추적합니다.'
# 'Traces to enable.'
H5DD3783FD8E4: '활성화할 추적 정보입니다.'
# 'Tracing of CMP and similar instructions'
H46B2C1DD8A24: 'CMP 및 유사 명령어 추적'
# 'Tracing of DIV instructions'
H6C4B7FBBDB1C: 'DIV 명령어 추적'
# 'Tracing of GEP instructions'
H9495E0A41197: 'GEP 명령어 추적'
# 'Tracing of load instructions'
H9296E34AACB7: '로드 명령어 추적'
# 'Tracing of store instructions'
HD37453D2BD66: '저장 명령어 추적'
# 'Track failure strings in detecting scop regions'
HA2AAD146A60C: 'scop 영역 탐지 중 실패 문자열 추적'
# 'Track origins (allocation sites) of poisoned memory'
H3D9C4DED10A1: '오염된 메모리의 원본(할당 위치) 추적'
# 'Track origins of labels'
H6DEEA7E74FFD: '레이블의 원본 추적'
# 'Track reg pressure and switch priority to in-depth'
HD40E656EBBE9: '레지스터 압력 추적 및 우선순위를 심층 분석으로 전환'
# 'Track the overflow bit if requested.'
H6AA670469C83: '요청 시 오버플로 비트를 추적합니다.'
# 'Training log for the register allocator eviction model'
H6E2B0424977E: '레지스터 할당기 제거 모델을 위한 훈련 로그'
# 'Training log for the register allocator priority model'
HDBA649A1B080: '레지스터 할당기 우선순위 모델 훈련 로그'
# 'Transform functions to use DSP intrinsics'
H926BA6FE32A4: 'DSP intrinsic을 사용하도록 함수 변환'
# "Transitional flag to turn off NVPTX's requirement on preserving structured CFG. The requirement should be disabled only when unexpected regressions happen."
H280C497E1DC8: 'NVPTX의 구조화된 CFG 유지 요구사항을 비활성화하는 과도기적 플래그입니다. 이 요구사항은 예상치 못한 회귀가 발생할 경우에만 비활성화해야 합니다.'
# 'Translations to perform'
HD6F4D5A5B7BD: '번역할 작업'
# 'Trap on integer division by zero.'
HDD1ADB807B39: '정수 나누기에서 0으로 나눌 경우 트랩합니다.'
# 'Trap on integer overflow'
H912BF1C6F685: '정수 오버플로에서 트랩'
# 'Trap when incorrect'
H9EC2646A38E0: '잘못되었을 때 트랩 발생'
# 'Treat <file> as C source file'
H5AAFC1A35AEE: '파일을 C 소스 파일로 간주합니다'
# 'Treat <file> as C++ source file'
H467B7FCAE3B7: '파일 <file>을 C++ 소스 파일로 처리합니다'
# 'Treat INCLUDE lines like #include directives in -E mode'
H8BB5A80B42A6: 'E 모드에서 INCLUDE 라인을 #include 지시문처럼 처리합니다.'
# 'Treat all #include paths starting with <prefix> as including a system header.'
H4CD79E350724: '프리픽스로 시작하는 모든 #include 경로를 시스템 헤더를 포함하는 것으로 처리합니다.'
# 'Treat all #include paths starting with <prefix> as not including a system header.'
H7FC347478B10: '#include 경로 중 <prefix>로 시작하는 모든 경로를 시스템 헤더가 아닌 것으로 처리합니다.'
# 'Treat all parameters to functions that are pointers as dereferencible. This is useful for invariant load hoisting, since we can generate less runtime checks. This is only valid if all pointers to functions are always initialized, so that Polly can choose to hoist their loads. '
H01E314D59C27: '함수의 포인터인 모든 매개변수를 참조 가능한 것으로 처리합니다. 불변 로드 후킹에 유용하며, 런타임 체크를 덜 생성할 수 있습니다. 이 옵션은 모든 함수 포인터가 항상 초기화되어 있어야 유효하며, 이는 Polly가 그들의 로드를 후킹할 수 있도록 합니다.'
# 'Treat all source files as C'
H55FA85BDA2A5: '모든 소스 파일을 C로 처리합니다'
# 'Treat all source files as C++'
H7EEC5BB50052: '모든 소스 파일을 C++로 처리합니다'
# 'Treat any <pattern> strings as regular expressions when selecting instead of just as an exact string match.'
HB8CFB19C5C18: '선택 시 모든 <pattern> 문자열을 정규 표현식으로 처리하며, 단순한 정확한 문자열 일치가 아니라.'
# 'Treat each comma separated argument in <arg> as a documentation comment block command'
HCB49DF1FFB5A: '각 쉼표로 구분된 <arg> 내의 인자를 문서 주석 블록 명령어로 처리합니다'
# 'Treat editor placeholders as valid source code'
H5F226C718000: '에디터 플레이스홀더를 유효한 소스 코드로 간주합니다'
# "Treat fixed form lines with 'd' or 'D' in the first column as blank."
HADC0D4FE88CA: "첫 번째 열에 'd' 또는 'D'가 있는 고정 형식 라인을 공백으로 처리합니다."
# "Treat fixed form lines with 'd' or 'D' in the first column as comments."
H3F2B7A8C2293: "고정 형식 라인에서 첫 번째 칸에 'd' 또는 'D'가 있는 경우 주석으로 처리합니다."
# 'Treat hip and hipv4 offload kinds as compatible with openmp kind, and vice versa.\n'
HC9954ACD9B9E: 'hip 및 hipv4 오프로드 종류를 openmp 종류와 호환되도록 간주하며, 그 반대의 경우도 마찬가지입니다.\n'
# 'Treat input as a PDB file (default)'
H24602D862E82: '입력 파일을 PDB 파일로 처리 (기본값)'
# 'Treat input as raw contents of /names named stream'
H2F74766FAAE9: '입력을 /names라는 이름의 스트림의 원시 내용으로 처리합니다'
# 'Treat input as raw contents of DBI stream'
H56798B0B0190: '입력을 DBI 스트림의 원시 내용으로 간주합니다'
# 'Treat input as raw contents of PDB stream'
H6E74D779FAE8: '입력을 PDB 스트림의 원시 내용으로 간주합니다'
# 'Treat input as raw contents of a module stream'
H720BDBA3C128: '모듈 스트림의 원시 내용으로 입력을 처리합니다'
# 'Treat issues where a fixed-width property is requested from a scalable type as a warning, instead of an error'
HE3ED92F98BA0: '확장 가능 타입에서 고정 너비 속성을 요청하는 문제를 오류 대신 경고로 처리합니다'
# "Treat pointer overflow as two's complement"
HF00886F33282: '포인터 오버플로우를 2의 보수로 처리합니다'
# "Treat signed integer overflow as two's complement"
H1BAF0BBFDBF6: '부호 있는 정수 오버플로우를 2의 보수로 처리합니다'
# 'Treat source input files as Objective-C inputs'
H10D7DE6018B0: '소스 입력 파일을 Objective-C 입력 파일로 간주합니다'
# 'Treat source input files as Objective-C++ inputs'
HF4443D8F9187: '소스 입력 파일을 Objective-C++ 입력 파일로 간주합니다'
# 'Treat stack lifetimes as starting on first use, not on START marker.'
H1D5DFE08E7A8: '스택 생명주기를 START 마커가 아닌 첫 사용 시 시작되는 것으로 처리합니다.'
# 'Treat string literals as const'
H79E1F4486D77: '문자열 리터럴을 const로 간주합니다'
# 'Treat subsequent input files as having type <language>'
HC2DB15026570: '이후 입력 파일을 <language> 유형으로 처리합니다'
# 'Treat the given module as-if it were containing the post-thinlink module containing the root'
H678738B3F81B: '지정된 모듈을 루트를 포함하는 post-thinlink 모듈을 포함하는 것으로 처리합니다'
# 'Treat usage of null pointers as undefined behavior (default)'
HEF76E5F5F913: '널 포인터 사용을 정의되지 않은 동작으로 처리(기본값)'
# 'Treat warnings as errors'
H518C417B2786: '경고를 오류로 처리'
# 'Trim cold functions until profile size is below specified limit in bytes. This uses a heursitic and functions may be excessively trimmed'
H9C86C77C9C88: '프로파일 크기가 지정된 바이트 수 제한 이하가 될 때까지 차가운 함수를 잘라냅니다. 이는 휴리스틱을 사용하며, 함수가 과도하게 잘려날 수 있습니다.'
# 'Trim context sample profiles whose count is below cold threshold'
HD98B893B0D67: '개수가 cold threshold 미만인 컨텍스트 샘플 프로파일을 제거합니다'
# 'Triple default EABI version'
H929ED20C3916: 'Triple 기본 EABI 버전'
# 'Triple to use to serialize to cubin.'
HCE48A7F9471E: 'cubin으로 직렬화할 때 사용할 Triple.'
# 'Try emitting Compact-Unwind for non-canonical entries. Maybe overridden by other constraints'
H3E74499232A9: '비표준 항목에 대해 Compact-Unwind를 생성해 보려고 합니다. 다른 제약 조건에 의해 무시될 수 있습니다'
# 'Try hoisting constant gep expressions'
HEBF48C3AF674: '상수 gep 표현식을 hoisting 해 보십시오'
# 'Try to avoid heapifying local blocks'
HD9B64861AC5A: '지역 블록의 힙화를 피하려고 시도합니다'
# 'Try to avoid reuse of byte array addresses using aliases'
HD4627CAE2B4C: '별칭을 사용하여 바이트 배열 주소의 재사용을 피하려고 노력하세요'
# 'Try to construct schedules where the outer member of each band satisfies the coincidence constraints (yes/no)'
H60DF39720CB5: '각 띠표의 외부 구성원이 동시 발생 제약 조건을 충족하는 일정을 구성하려고 시도하세요 (예/아니오)'
# 'Try to delinearize array references.'
H2EA0163561FB: '배열 참조를 비일차원화하려고 시도합니다.'
# 'Try to evenly distribute flow when there are multiple equally likely options.'
HAEBC34FD2276: '여러 가능성 있는 옵션이 있을 때 흐름을 균등하게 분배하려고 시도하세요.'
# 'Try to map `do concurrent` loops to OpenMP [none|host|device]'
H0998E6C983F8: 'OpenMP에 `do concurrent` 루프를 매핑하려 시도 [none|host|device]'
# 'Try to propagate nonnull argument attributes from callsites to caller functions.'
H020E4D562B19: '호출 지점에서의 nonnull 인자 어트리뷰트를 호출한 함수로 전파하려고 시도합니다.'
# 'Try to simplify all loads.'
HBDC33CA86746: '모든 로드를 단순화하려고 시도합니다.'
# 'Try to vectorize with non-power-of-2 number of elements.'
H0125A5F09D1C: '2의 제곱수가 아닌 요소 수로 벡터화를 시도했습니다.'
# 'Try wider VFs if they enable the use of vector variants'
H26EA4E292B56: '더 넓은 VFs를 시도해 보세요. 벡터 변형 사용을 활성화할 경우'
# 'Tune debug info for a particular debugger'
H77BC7AA0BB02: '특정 디버거를 위한 디버그 정보 최적화'
# 'Tune for a specific cpu type'
H3345FF3520DA: '특정 CPU 유형을 최적화합니다'
# 'Turn all knobs to 11'
H1AC91DEDAC4E: '모든 노브를 11로 설정합니다'
# 'Turn fastcc calls into tail calls by (potentially) changing ABI.'
HF62148DE9C4D: 'ABI 변경을 통해 (필요에 따라) fastcc 호출을 꼬리 호출로 변환합니다.'
# 'Turn off Type Based Alias Analysis'
H63440B325F63: '유형 기반 별칭 분석을 비활성화합니다'
# 'Turn off loop unroller'
H0C19FC5B8215: '루프 개방기 끄기'
# 'Turn off sparse parallelization.'
H32757C1F23A6: '희소 병렬화를 끕니다.'
# 'Turn off struct-path aware Type Based Alias Analysis'
H8E0ED82C6CEB: '구조体型 경로 인식 타입 기반 별칭 분석을 비활성화합니다'
# 'Turn off window algorithm.'
H6D475479FF1D: '윈도우 알고리즘 끄기.'
# 'Turn on DominatorTree and LoopInfo verification after Loop Distribution'
H14C9F8E485D6: '루프 분포 후에 DominatorTree 및 LoopInfo 검증을 활성화합니다'
# 'Turn on loop unroller'
H189401528396: '루프 언롤링 활성화'
# 'Turn on module map output and specify output path or file name. If no path is specified and if prefix option is specified, use prefix for file path.'
H6B0988247E72: '모듈 맵 출력을 켜고 출력 경로 또는 파일 이름을 지정합니다. 경로가 지정되지 않았고 접두사 옵션이 지정되었을 경우 접두사를 파일 경로에 사용합니다.'
# 'Turn on runtime checks for various forms of undefined or suspicious behavior. See user manual for available checks'
H44BD445B1D2C: '정의되지 않거나 의심스러운 다양한 형태의 동작에 대한 런타임 검사를 활성화합니다. 사용자 매뉴얼을 참조하여 사용 가능한 검사 항목을 확인하세요'
# 'Turn on time profiler. Generates JSON file based on output filename.'
H605BD513ED60: '시간 프로파일러를 켭니다. 출력 파일 이름을 기반으로 JSON 파일을 생성합니다.'
# 'Turns on stale matching with block pseudo probes.'
HFFCF05795EA6: '블록 가상 프로브를 사용하여 stale 매칭을 활성화합니다.'
# 'Two-Address instruction pass'
HD8164AEBCCB3: '두 주소 명령어 패스'
# 'Type Options'
H7C8D98E334E0: '유형 옵션'
# 'Type Promotion'
H4F87D1DD8D47: '타입 프로모션'
# 'Type Record Options'
H979D586C9237: '유형 기록 옵션'
# 'Type definition.'
H37A26D2D1A2C: '유형 정의.'
# 'Type kind to use when printing types.'
H3F4786926275: '타입을 출력할 때 사용할 타입 종류입니다.'
# 'Type of checking for incorrect devirtualizations'
HB2F8536F04B5: '잘못된 가상화 해제에 대한 검사 유형'
# 'Type of symbols to dump (default all)'
HDEE9A9BDCFC8: '덤프할 기호의 유형 (기본값 all)'
# 'Type of the files to be bundled/unbundled.\nCurrent supported types are:\n  i    - cpp-output\n  ii   - c++-cpp-output\n  cui  - cuda-cpp-output\n  hipi - hip-cpp-output\n  d    - dependency\n  ll   - llvm\n  bc   - llvm-bc\n  s    - assembler\n  o    - object\n  a    - archive of objects\n  gch  - precompiled-header\n  ast  - clang AST file'
H23DE32DB4F4F: '번들링/언번들링할 파일 유형입니다.\n현재 지원하는 유형은 다음과 같습니다:\n  i    - C++ 프리프로세서 출력\n  ii   - C++ 프리프로세서 출력\n  cui  - CUDA C++ 프리프로세서 출력\n  hipi - HIP C++ 프리프로세서 출력\n  d    - 종속성 파일\n  ll   - LLVM 중간 언어 파일\n  bc   - LLVM 바이트코드 파일\n  s    - 어셈블리어 파일\n  o    - 객체 파일\n  a    - 객체 아카이브\n  gch  - 사전 컴파일 헤더\n  ast  - Clang 추상 구문 트리 파일'
# 'Type sizes.'
H42125920C0CF: '형식 크기.'
# 'Type-Based Alias Analysis'
H432902366273: '타입 기반 Alias 분석'
# 'Types (Pointer, Reference, etc.).'
H09ADEF8BEED1: '유형 (포인터, 참조 등).'
# 'Types.'
H1145E1A9F2E2: '형식.'
# 'UNKOWN'
HD91DF451ADF1: '알 수 없음'
# 'USAGE: '
H4060E2625813: '사용법: '
# 'Unbundle bundled file into several output files.\n'
H1DD69F0F0D6F: '번들 파일을 여러 개의 출력 파일로 분리합니다.\n'
# 'Unconditionally apply unchecked-ld-st optimization (even for large stack frames, or in the presence of variable sized allocas).'
H26BF316F7B25: '무조건적으로 체크되지 않은 ld-st 최적화를 적용(큰 스택 프레임에도 또는 가변 크기의 allocas가 있는 경우에도).'
# 'UndName Options'
H2ACB6A59624D: 'UndName 옵션'
# 'Undefine macro'
H85ECFBA229C4: '매크로 정의 해제'
# 'Undefine macro <macro>'
HE9FB0C5A98C8: '매크로 <macro> 정의 해제'
# 'Undefined / no particular sort order'
H2DF8FA5D8D5C: '정의되지 않음 / 특정 정렬 순서 없음'
# 'Undefines the __DEPRECATED macro'
HFAB714AB2388: '__DEPRECATED 매크로를 취소 정의합니다'
# 'Underlying type for type definitions.'
HE810C104AEFC: '형식 정의의 기반 형식.'
# 'Unexpected vftable component type %0 for component number %1'
H40151C08E668: '구성 요소 번호 %1에 대한 vftable 구성 요소 형식 %0이 예상되지 않았습니다'
# 'Uniformity Analysis'
H18CD82918982: '일관성 분석'
# 'Unify divergent function exit nodes'
H8B72079558B4: '다IVERGENT한 함수 종료 노드 통합'
# 'Unify function instantiations'
H7D11BF20733C: '함수 인스턴스화 통합'
# 'Unify multiple OpenCL metadata due to linking'
H1E880963D2AC: '링크로 인해 여러 OpenCL 메타데이터 통합'
# 'Union.'
H8AC81596AB6F: '유니언.'
# 'Uniqueify Internal Linkage Symbol Names by appending the MD5 hash of the module path'
HE20B29760EEF: '내부 링크지 기호 이름을 모듈 경로의 MD5 해시를 추가하여 유니크화합니다'
# 'Unpack machine instruction bundles'
H6975BC91D598: '머신 인스트럭션 번들 풀기'
# 'Unparse and stop (skips the semantic checks)'
HB65257706E07: '해석 중단 및 종료 (구문 분석 검사 건너뛰기)'
# 'Unparse and stop.'
H8A6570E46B2D: '해체 분석하고 중단합니다.'
# 'Unparse with dependent modules and stop.'
HDFEBDFAE4C78: '의존 모듈과 함께 언패싱을 중단합니다.'
# 'Unparse with symbols and stop.'
H0D9F89477381: '기호를 해석하지 않고 중단합니다.'
# 'Unroll factor (affecting 4x32-bit operations) to use for memory operations when lowering memcpy as a loop'
HE43C43B147A4: 'memcpy를 루프로 변환할 때 메모리 연산에 사용할 언롤 인자(4x32비트 연산에 영향을 미침)'
# 'Unroll loops'
H14907BD20FBA: '루프 펼치기'
# 'Unroll loops with run-time trip counts'
H094122EA378B: '실행 시 반복 횟수를 가진 루프를 펼칩니다'
# 'Unroll threshold for AMDGPU if local memory used in a loop'
H9E766FE7E2B8: 'AMDGPU에서 루프에 로컬 메모리가 사용될 경우의 언롤 임계값'
# 'Unroll threshold for AMDGPU if private memory used in a loop'
HAC396B9BAD8B: 'AMDGPU에서 개인 메모리가 루프 내 사용될 경우 언롤 임계값'
# 'Unroll threshold increment for AMDGPU for each if statement inside loop'
H93579CFAA697: 'AMDGPU를 위한 루프 내 각 if 문마다 언롤 임계값 증가량'
# 'Unrolled size limit for loops with an unroll(full) or unroll_count pragma.'
H455348AAE5AE: 'unroll(full) 또는 unroll_count pragma를 가진 루프의 언롤된 크기 제한.'
# 'Unrolled size limit for loops with an unroll_and_jam(full) or unroll_count pragma.'
H83703E1D1FC8: 'unroll_and_jam(full) 또는 unroll_count pragma가 있는 루프의 펼침 크기 제한'
# 'Unspecified parameter.'
H12B0F3A3DD19: '지정되지 않은 매개변수입니다.'
# 'Unspecified type.'
HEE55D6208E96: '미지정 형식.'
# 'Unwind library to use'
HAF3990494241: '사용할 언윈드 라이브러리'
# 'Uop Decomposition'
H84228E8F31C8: 'Uop 분해'
# 'Update pseudo probe distribution factor'
H95A61EF626F6: '가짜 프로브 분포 인자를 업데이트합니다'
# 'Update total samples by accumulating all its body samples.'
H4ABB921FD931: '전체 샘플을 모든 본문 샘플을 누적하여 업데이트합니다.'
# 'Use #line in preprocessed output'
H61A0DD59549D: '전처리된 출력에서 #line을 사용하세요'
# "Use 'mips.ccmov' instruction"
HDC01AC60098B: "'mips.ccmov' 명령어를 사용하세요."
# 'Use -compile-command to define a command to compile the bitcode. Useful to avoid linking.'
H45B889E18E9F: '-compile-command 옵션을 사용하여 비트코드를 컴파일하는 명령을 정의합니다. 링킹을 피하기 위해 유용합니다.'
# 'Use -exec-command to define a command to execute the bitcode. Useful for cross-compilation.'
HBBC97C4993AA: '-exec-command 옵션을 사용하여 비트코드를 실행하는 명령어를 정의합니다. 크로스 컴파일에 유용합니다.'
# 'Use .ctors instead of .init_array.'
HEFD53B18D4A2: '.init_array 대신 .ctors를 사용하세요.'
# 'Use .ctors/.dtors instead of .init_array/.fini_array'
H89195E513795: '.init_array/.fini_array 대신에 .ctors/.dtors를 사용하십시오'
# 'Use .file directives with an explicit directory'
H9DEC86EE53C8: '명시적인 디렉토리를 사용하는 .file 지시문을 사용하십시오.'
# 'Use 16-bit hardware multiplier'
HE39242B4C409: '16비트 하드웨어 멀티플라이어 사용'
# 'Use 32-bit floating point registers (MIPS only)'
HE9E46E3267C7: '32비트 부동소수점 레지스터 사용 (MIPS 전용)'
# 'Use 32-bit hardware multiplier'
H48A0735D6EC9: '32비트 하드웨어 멀티플라이어를 사용하십시오'
# 'Use 32-bit pointers for accessing const/local/shared address spaces'
HEBB1FFB0999C: 'const/local/shared 주소 공간에 접근할 때 32비트 포인터를 사용하세요'
# 'Use 32-bit pointers for accessing const/local/shared address spaces.'
H1C423A27FAD4: '32비트 포인터를 사용하여 const/local/shared 주소 공간에 접근하십시오.'
# 'Use 64-bit floating point registers (MIPS only)'
H4492AB59FFA0: '64비트 부동소수점 레지스터를 사용하십시오 (MIPS 전용)'
# 'Use <dumpfpx> as a prefix to form auxiliary and dump file names'
H3DFDBA26A67C: '보조 및 덤프 파일 이름을 생성하려면 <dumpfpx>를 접두사로 사용하십시오.'
# 'Use <suffix> as the suffix for module files (the default value is `.mod`)'
H0754CF14DB5E: '모듈 파일의 접미사로 <suffix>를 사용합니다 (기본값은 `.mod`입니다)'
# 'Use <value> as character line width in fixed mode'
HAF90606EAD0C: '고정 모드에서 문자 라인 너비로 <value>를 사용합니다'
# 'Use ANSI escape codes for diagnostics'
HF4E88E8746F8: '진단 메시지에 ANSI 이스케이프 코드 사용'
# "Use Apple's kernel extensions ABI"
H707C74B2A986: 'Apple의 커널 확장 ABI를 사용하세요.'
# 'Use CREL relocation format for ELF'
H01BA06F9BEE0: 'ELF용 CREL 재배치 형식을 사용하십시오.'
# "Use ConstantFP's native fixed-length vector splat support."
H45D6CB612C50: 'ConstantFP의 원래 고정 길이 벡터 splat 기능을 사용하십시오.'
# "Use ConstantFP's native scalable vector splat support."
H019F3DB4B516: 'ConstantFP의 내장된 scalable vector splat 지원을 사용하십시오.'
# "Use ConstantInt's native fixed-length vector splat support."
HEE201C750BB5: 'ConstantInt의 내장된 고정 길이 벡터 splat 지원을 사용하십시오.'
# "Use ConstantInt's native scalable vector splat support."
H205BD3049DE6: 'ConstantInt의 네이티브 확장 벡터 splat 지원을 사용하십시오.'
# 'Use DLL debug run-time'
H09CE8A3B2FF2: 'DLL 디버그 런타임을 사용하십시오'
# 'Use DLL run-time'
HFFC5F85F16E2: 'DLL 런타임을 사용하십시오'
# 'Use DPP operations for scan'
HA25C31D46A88: '스캔을 위해 DPP 연산을 사용하십시오'
# 'Use DWARF base address selection entries in .debug_ranges'
H785682C5C939: 'DWARF 기본 주소 선택 항목을 .debug_ranges에 사용하라'
# 'Use DWARF style exceptions'
H37CB53594E9C: 'DWARF 스타일 예외를 사용하십시오.'
# 'Use Decision Forest model to rank completion items'
H05DCA5EC7686: '결정 숲 모델을 사용하여 완성 항목을 순위 매기기'
# 'Use EH-safe code when synthesizing retains and releases in -fobjc-arc'
H36FC7089F28D: 'ARC 옵션에서 retains와 releases를 합성할 때 예외 처리 안전 코드를 사용하십시오.'
# 'Use F5 series hardware multiplier'
H2733E473C4B3: 'F5 시리즈 하드웨어 멀티플라이어 사용'
# 'Use GC exclusively for Objective-C related memory management'
H2B28F501A8B5: 'GC를 오브젝티브-C 관련 메모리 관리에 전적으로 사용하라'
# "Use GCC installation in the specified directory. The directory ends with path components like 'lib{,32,64}/gcc{,-cross}/$triple/$version'. Note: executables (e.g. ld) used by the compiler are not overridden by the selected GCC installation"
HA7E84A833041: "지정된 디렉토리에 있는 GCC 설치를 사용합니다. 디렉토리는 'lib{,32,64}/gcc{,-cross}/$triple/$version'과 같은 경로 구성 요소로 끝납니다. 참고: 컴파일러에서 사용하는 실행 파일(예: ld)은 선택한 GCC 설치로 대체되지 않습니다."
# 'Use GCNDownwardRPTracker for GCNRegPressurePrinter pass'
HC666D46EACA0: 'GCNRegPressurePrinter 패스에 GCNDownwardRPTracker를 사용하십시오'
# 'Use GOT indirection instead of PLT to make external function calls (x86 only)'
H813651BE1DF2: 'GOT 간접 참조를 PLT 대신에 외부 함수 호출에 사용 (x86 전용)'
# 'Use GOT indirection to reference external data symbols'
H9C63E198FEC5: 'GOT 간접 참조를 사용하여 외부 데이터 심벌을 참조합니다'
# 'Use GP relative accesses for symbols known to be in a small data section (MIPS)'
H16E3D5EA2597: '소데이터 섹션에 위치하는 심볼에 대해 GP 상대 접근을 사용합니다 (MIPS)'
# 'Use GPR indexing mode instead of movrel for vector indexing'
H65B8C362AD34: '벡터 인덱싱에 movrel 대신 GPR 인덱싱 모드를 사용하십시오'
# 'Use GlobalISel desired legality, rather than try to userules compatible with selection patterns'
HCD3F9F572B30: '선택 패턴과 호환되는 규칙을 사용하려고 시도하는 대신 GlobalISel의 원하는 적법성을 사용하십시오.'
# 'Use HLFIR lowering (experimental)'
HBF33CE828D70: 'HLFIR 변환 사용 (실험적)'
# 'Use IEEE 754 quadruple-precision for long double'
H52864CA1A557: 'long double에 대해 IEEE 754 사중 정밀도를 사용하라'
# 'Use IEEE Compliant F32 div.rnd if available (default)'
H2BB28E9D2AB7: '사용 가능한 경우 IEEE 준수 F32 div.rnd 사용 (기본값)'
# 'Use IEEE Compliant F32 div.rnd if available, no FTZ'
HBC0417BA3204: '사용 가능한 경우 IEEE 준수 F32 div.rnd 사용, FTZ 없음'
# 'Use INTEGER(KIND=8) for the result type in size-related intrinsics'
H31BCF654D576: '크기 관련 고유 함수에서 결과 유형으로 INTEGER(KIND=8)를 사용하십시오'
# 'Use InstrItineraryData for latency lookup'
HE819C1D764CF: 'InstrItineraryData를 지연 시간 조회에 사용하십시오'
# 'Use Intel MCU ABI'
H047785ECB956: '인텔 MCU ABI를 사용하십시오'
# 'Use Iterative approach for scan'
HB2B560B747FE: '반복 접근 방식을 사용하여 스캔'
# 'Use JSON as the output format.'
H22CC5D346911: 'JSON을 출력 형식으로 사용합니다.'
# 'Use LFENCE along each conditional edge to harden against speculative loads rather than conditional movs and poisoned pointers.'
H417B6B21B3DF: '각 조건부 간선마다 LFENCE를 사용하여 조건부 mov와 중독된 포인터 대신 스펙ulative 로드에 대비해 강화하라.'
# 'Use LLJITGenericIRPlatform'
H25BF0FFFB5D6: 'LLJITGenericIRPlatform을 사용하십시오.'
# 'Use LLVM-IR names when deriving statement names'
H7614196F2CF1: '문장 이름을 파생할 때 LLVM-IR 이름을 사용하십시오'
# 'Use LLVM/Offload as portable offloading runtime.'
HE33C03962BCE: 'LLVM/Offload를 이식 가능한 오프로딩 런타임으로 사용하라.'
# 'Use MD5 for file checksums in debug info (default)'
H96424B977A6D: '디버그 정보에서 파일 체크섬에 MD5 사용 (기본값)'
# 'Use ML.'
HFB1C0C51C398: 'ML을 사용하십시오.'
# 'Use NMake/Jom format for the depfile'
H2770540BA1FF: '의존성 파일에 NMake/Jom 형식을 사용하십시오'
# 'Use ORC runtime from given path'
H0B3C6C26BF5D: '지정된 경로에서 ORC 런타임을 사용합니다'
# 'Use SEH style exceptions'
HF73D39350799: 'SEH 스타일의 예외를 사용하십시오.'
# 'Use SHA1 for file checksums in debug info'
H18018B318301: '디버그 정보에서 파일 체크섬에 SHA1을 사용합니다'
# 'Use SHA256 for file checksums in debug info'
HF98F43EAE9BB: '디버그 정보에서 파일 체크섬에 SHA256을 사용하십시오'
# 'Use Section instead of __patchable_function_entries'
H2F6710F2BEEF: '__patchable_function_entries 대신 Section을 사용합니다'
# 'Use SjLj style exceptions'
H44AA3EF8F7F8: 'SjLj 스타일 예외를 사용하세요'
# 'Use Stable Hashing for MIR VReg Renaming'
H093C21DF7C9E: 'MIR VReg 재명명을 위해 안정성 해싱 사용'
# 'Use Stack Safety analysis results'
HCE2D7641DBD9: '스택 안전성 분석 결과를 사용하십시오'
# 'Use StructurizeCFG IR pass'
HA25675EEF575: 'StructurizeCFG IR 패스를 사용하십시오'
# 'Use TLS'
HF5C26334C370: 'TLS 사용'
# 'Use TargetSchedModel for latency lookup'
HC9F59D7F1E0C: 'TargetSchedModel을 latency 조회에 사용합니다'
# 'Use TargetTransformInfo::getInstructionCost'
H4974E1B043EE: 'TargetTransformInfo::getInstructionCost를 사용하십시오'
# 'Use TargetTransformInfo::getIntrinsicInstrCost'
H85A8617C4E16: 'TargetTransformInfo::getIntrinsicInstrCost를 사용하세요'
# 'Use VP intrinsics'
H7B0B6BAFD1AA: 'VP 인트린식을 사용하세요.'
# 'Use WebAssembly style exceptions'
H0F092371B645: 'WebAssembly 스타일 예외를 사용하십시오'
# 'Use a best-case representation method for member pointers'
H7AE6BEFD1C8A: '멤버 포인터에 대해 최적의 표현 방법을 사용하십시오'
# 'Use a const qualified type for string literals in C and ObjC'
HBFF97FAA6C53: 'C 및 ObjC에서 문자열 리터럴에 const 자격 증명된 형식을 사용하십시오.'
# 'Use a diagnostic handler to test the handler interface'
H3C822F398929: '핸들러 인터페이스를 테스트하기 위해 진단 처리기를 사용하라'
# 'Use a fake address space map; OpenCL testing purposes only'
H9DCA916816C8: '가짜 주소 공간 맵 사용; OpenCL 테스트 목적으로만'
# 'Use a free form text output.'
HA312842C43C5: '자유 형식 텍스트 출력을 사용하십시오.'
# 'Use a full speculation fence to harden both call and ret edges rather than a lighter weight mitigation.'
H600ECC7683CF: '더 가벼운 완화 대신 호출과 반환 간선을 모두 강화하기 위해 전체 추측 장벽을 사용하십시오.'
# 'Use a most-general representation for member pointers'
H0E7635ED3666: '멤버 포인터에 대해 가장 일반적인 표현을 사용해야 합니다'
# 'Use a rematerializable pseudoinstruction for 2 instruction constant materialization'
H3A40020AE1F7: '2개의 명령어 상수 재구성을 위해 재구성 가능한 가상 명령어를 사용하십시오'
# 'Use a signed type for wchar_t'
H48F702933B27: 'wchar_t에 대한 부호 있는 형식을 사용하십시오'
# 'Use a single TBAA tree for all functions and do not use the FIR alias tags pass'
HC642932368D3: '모든 함수에 대해 단일 TBAA 트리를 사용하고 FIR alias tags 패스를 사용하지 마십시오'
# 'Use absolute paths for invoking subcommands (default)'
HFDEA884CA19F: '서브 명령 실행 시 절대 경로 사용 (기본값)'
# 'Use addrx+offset extension form for any address with a prior base address'
H5B85C96D3B22: '이전 기본 주소를 가진 모든 주소에는 addrx+offset 확장 형태를 사용하십시오'
# 'Use all available analyses'
H8DB3578A8858: '사용 가능한 모든 분석을 사용하십시오'
# 'Use all discriminator bits (default)'
H568FAF6786A5: '디스크리미네이터 비트를 모두 사용 (기본값)'
# 'Use an unsigned type for wchar_t'
HE6D72C7A4E59: 'wchar_t에 대한 unsigned 타입을 사용하십시오.'
# 'Use approximate transcendental functions'
HC80164348ADD: '근사하는 초월함수를 사용하십시오'
# 'Use arc callee save/restore functions'
HDC1738B5E10F: 'ARC callee 저장/복원 함수를 사용하십시오'
# 'Use atexit or __cxa_atexit to register global destructors'
HD6A435F1A848: '글로벌 소멸자를 등록하려면 atexit 또는 __cxa_atexit를 사용하십시오.'
# 'Use atomic fetch add for first counter in a function (usually the entry counter)'
HE1A472AB0CD6: '함수 내 첫 번째 카운터(보통은 entry counter)에 대해 원자적 fetch add를 사용하십시오.'
# 'Use base address specifiers in debug_ranges'
H16F9B262870C: '디버그_레인지에서 기반 주소 지정자를 사용하십시오'
# 'Use base and pass 1 discriminators'
HFD9F1E3E9AB6: '기반을 사용하고 1번 구분자를 전달하십시오'
# 'Use base and pass 1-2 discriminators'
H8235CCC718A7: '기반을 사용하고 1-2 판별자를 전달하십시오'
# 'Use base and pass 1-3 discriminators'
HF4182389B253: 'base를 사용하고 1-3 discriminators를 전달하십시오'
# 'Use base discriminators only'
HF3EBCD1C0036: '기반 구분자만 사용하십시오'
# 'Use best guess'
H868B8A8130DA: '가장 정확한 추측을 사용하세요'
# 'Use binary to correlate'
H72FD9C9D9781: '바이너리를 사용하여 상관관계를 고려하십시오'
# 'Use block frequency info to find successors to sink'
H76D3FF42212F: '블록 빈도 정보를 사용하여 sink로 내리기 위해 후속 노드를 찾습니다'
# 'Use cache manager to save/load modules'
HA5972065E561: '캐시 매니저를 사용하여 모듈을 저장/로드하세요'
# 'Use call site prioritized inlining for sample profile loader. Currently only CSSPGO is supported.'
H91095FED309C: '샘플 프로파일 로더에 호출 위치 우선 인라인을 사용합니다. 현재 CSSPGO만 지원됩니다.'
# 'Use callback for max stack depth tracing with minimum stack depth M'
H90D68B59D6FC: '최소 스택 깊이 M으로 최대 스택 깊이 추적을 위한 콜백 사용'
# 'Use callbacks instead of inline instrumentation sequences.'
H3EC6C04656EA: '인라인 인스트루먼트 시퀀스 대신 콜백을 사용하십시오.'
# 'Use callee size priority.'
H959C69EC2106: 'callee 크기 우선 순위를 사용하십시오.'
# 'Use case-insensitive matching'
HCBB3CB058AC9: '대소문자를 구분하지 않고 일치시킴을 사용하십시오.'
# 'Use codegen data read from default.cgdata to optimize the binary'
HEFC973859186: 'default.cgdata에서 읽은 코드 생성 데이터를 사용하여 이진 파일을 최적화합니다'
# 'Use codegen data read from the specified <path>.'
HA873FDC06A7F: '지정된 <path>에서 읽은 코드 생성 데이터를 사용합니다.'
# 'Use colors in detailed AST output. If not set, colors\nwill be used if the terminal connected to\nstandard output supports colors.'
H3428909B1528: '상세한 AST 출력에 색상을 사용합니다. 설정되지 않았을 경우 표준 출력에 연결된 터미널이 색상을 지원하면 색상을 사용합니다.\n터미널이 색상 지원 여부에 따라 자동으로 결정됩니다'
# 'Use colors in output (default=autodetect)'
H036C59DCDCFA: '출력에 색상을 사용 (기본값=자동 감지)'
# 'Use column-major layout'
H798E10981CB2: '열 우선 레이아웃을 사용하라'
# 'Use compact approach for aligning functions'
H53E4E0949D55: '함수 정렬을 위한 컴팩트 접근 방식을 사용하십시오'
# 'Use compact branches where appropriate (default).'
HE80CC6815708: '적절한 경우에 컴팩트 분기를 사용합니다(기본값).'
# 'Use compressed jump tables in Thumb-1 by synthesizing an equivalent to the TBB/TBH instructions'
H2165E804582A: 'Thumb-1에서 TBB/TBH 명령어와 동등한 것을 합성하여 압축된 점프 테이블을 사용합니다'
# 'Use constructor homing if we are using limited debug info already'
H62F93DEE0ADD: '만약 이미 제한된 디버그 정보를 사용하고 있다면 생성자 호밍을 사용하십시오'
# 'Use context'
H3D56A8B500FF: '컨텍스트를 사용하십시오'
# 'Use context-sensitive byte size cost for preinliner decisions'
H7FD64165B9B4: 'preinliner 결정에 컨텍스트에 민감한 바이트 크기 비용을 사용합니다'
# 'Use cost-benefit ratio.'
H9D7EE37E6691: '비용 대 이익 비율을 사용하십시오.'
# 'Use debug info or binary file to correlate profiles.'
H2E074CAAD7C0: '디버그 정보나 바이너리 파일을 사용하여 프로파일을 상관시켜야 합니다.'
# 'Use debug info to correlate'
HEC4020684722: '디버그 정보를 사용하여 연관시키십시오'
# 'Use debug info to correlate profiles. (Deprecated, use -profile-correlate=debug-info)'
H3760EBF147CB: '디버그 정보를 사용하여 프로파일을 상호 연관시킵니다. (사용 중지됨, -profile-correlate=debug-info 옵션을 사용하세요)'
# 'Use debug-info or binary correlation to correlate profiles with build id fetcher'
HE51EAC7876DD: '디버그 정보 또는 이진 파일 상관 관계를 사용하여 프로파일을 빌드 ID 수집기와 연관지십시오'
# 'Use debuginfod to look up object files from profile'
HF7500F4663E6: '프로파일에서 오브젝트 파일을 조회하려면 debuginfod를 사용하십시오'
# 'Use default code inlining logic for the address sanitizer'
HB70EC9805527: '주소 소제제기에 대한 기본 코드 인라인 논리를 사용합니다'
# 'Use development mode (runtime-loadable model)'
H1078C08F764F: '개발 모드 사용 (실행 시 로드 가능한 모델)'
# 'Use directory as the C++ standard library include path'
H323DACFD356C: '디렉토리를 C++ 표준 라이브러리 인클루드 경로로 사용하라'
# 'Use distinct LTO pipelines'
H5CC3AC1C99CE: '구분된 LTO 파이프라인을 사용하십시오'
# 'Use div.approx'
H83DB5654E52E: 'div.approx 사용'
# 'Use div.full'
H982A66A56BFC: 'div.full 사용'
# 'Use div.w[u] and mod.w[u] instructions with input not sign-extended.'
HCBB92DFD904B: '부호 확장되지 않은 입력을 사용하여 div.w[u] 및 mod.w[u] 명령어를 사용했습니다.'
# 'Use dot format instead of plain text when dumping VPlans'
HE98D975C012B: 'VPlans를 덤프할 때 일반 텍스트 대신 dot 형식을 사용합니다'
# 'Use dwarf for profile correlation even when binary contains pseudo probe.'
HB77EAFFEBB88: '바이너리에 가상 프로브가 포함되어 있을 때도 프로파일 상관 관계에 dwarf를 사용합니다.'
# 'Use dynamic alloca to represent stack variables'
H0BD8D88B6D44: '스택 변수를 표현하기 위해 동적 alloca를 사용하십시오'
# 'Use emulated TLS model'
H1BBC4DA9A238: '가상화된 TLS 모델을 사용합니다'
# 'Use emutls functions to access thread_local variables'
HF38CD5C8C963: 'emutls 함수를 사용하여 thread_local 변수에 액세스하십시오.'
# 'Use experimental new value-tracking variable locations'
H5A1E1B70E9BC: '실험적인 새로운 값 추적 변수 위치 사용'
# 'Use exprloc addrx+offset expressions for any address with a prior base address'
H8B37A6DB17E6: '이전 기반 주소가 있는 모든 주소에 대해 exprloc addrx+offset 표현식을 사용하십시오'
# 'Use ext-tsp for size-aware block placement.'
H6EBF1A8427C5: 'ext-tsp를 크기 인식 블록 배치를 위해 사용하십시오.'
# 'Use external machine object code emitter.'
H863F828BD310: '외부 머신 오브젝트 코드 생성기를 사용하십시오.'
# 'Use fast short rep mov in memcpy lowering'
H51A6C031B64D: 'memcpy 최적화 시 빠른 짧은 rep mov 사용'
# 'Use filesystem locks for implicit modules builds to avoid duplicating work in competing clang invocations.'
H0BC43223C7F4: '암시적 모듈 빌드에 파일 시스템 락을 사용하여 경쟁하는 clang 실행에서 작업 중복을 피합니다.'
# 'Use first loadable segment address as base address for offsets in unsymbolized profile. By default first executable segment address is used'
H4F1992DBF3B6: '언심볼라이즈된 프로파일의 오프셋을 위한 기반 주소로 첫 번째 로드 가능한 세그먼트 주소를 사용합니다. 기본적으로는 첫 번째 실행 가능 세그먼트 주소가 사용됩니다'
# 'Use full module build paths in the profile counter names for static functions.'
H8EE12193DAD1: '정적 함수의 프로파일 카운터 이름에 모듈 빌드 경로 전체를 사용합니다.'
# 'Use full register names when printing assembly'
HCA77C0C5AF9C: '어셈블리 출력 시 전체 레지스터 이름을 사용하십시오'
# 'Use full register names when writing assembly output'
H3BE94F5363AA: '어셈블리 출력을 작성할 때 전체 레지스터 이름을 사용하십시오.'
# 'Use global'
HB9509FD003D3: '전역을 사용하라'
# 'Use global constructors'
HF07EDAA4A037: '전역 생성자를 사용하십시오'
# 'Use global destructors'
HDD719F630B29: '전역 소멸자를 사용하십시오'
# 'Use hardened lowering for jump-table dispatch'
H7DCC0D09290B: '점프 테이블 디스패치에 대한 보안 강화된 하위 변환 사용'
# 'Use heuristics to rank code completion items'
HDEA303833606: '휴리스틱을 사용하여 코드 완성 항목을 순위 매기기'
# 'Use if conversion pass'
HBFF84704F0B4: 'if 변환 패스 사용'
# 'Use ifunc global'
H9FA2DD7E729C: 'ifunc 전역 변수를 사용하십시오.'
# 'Use indirect register addressing for divergent indexes'
HF60A83099C5E: '다IVERGENT 인덱스에 대해 간접 레지스터 주소 지정을 사용하십시오.'
# 'Use inline cost priority.'
H496F98AFF787: '인라인 비용 우선순위를 사용하십시오.'
# 'Use inlined strings rather than string section.'
H7753024EA72C: '인라인 문자열을 문자열 섹션 대신 사용하십시오.'
# 'Use instruction-ref based LiveDebugValues with normal DBG_VALUE inputs'
H2DC2FFE65115: '명령문-참조 기반 LiveDebugValues와 일반적인 DBG_VALUE 입력을 사용하십시오'
# 'Use instrumentation data for profile-guided optimization'
H9DC257CB2810: '프로파일 기반 최적화를 위해 인스트루먼테이션 데이터를 사용하십시오'
# 'Use instrumentation data for profile-guided optimization. If pathname is a directory, it reads from <pathname>/default.profdata. Otherwise, it reads from file <pathname>.'
HDBC8B9085819: '프로파일 기반 최적화를 위해 인스트루먼테이션 데이터를 사용합니다. pathname이 디렉토리인 경우 <pathname>/default.profdata 파일에서 읽습니다. 그렇지 않은 경우 file <pathname> 파일에서 읽습니다.'
# 'Use instrumented (context sensitive) profile to guide PGO.'
HF618D20FE941: '기기 테스트된 (컨텍스트 감지형) 프로파일을 PGO 안내에 사용합니다.'
# 'Use instrumented profile to guide PGO.'
H479023987FBB: '프로파일링을 통해 PGO를 유도하기 위해 인스트루먼테이션된 프로파일을 사용하십시오.'
# 'Use internal machine object code emitter.'
H45C76DB103C3: '내부 머신 오브젝트 코드 엠프터를 사용합니다.'
# 'Use jump tables for lowering switches'
HFFDBCF7C79DB: '점프 테이블을 사용하여 스위치를 최적화합니다'
# 'Use large decoder table format. This uses 24 bits for offset\nin the table instead of the default 16 bits.'
H7EEE365A819D: '대형 디코더 테이블 형식을 사용합니다. 기본값 16비트 대신 테이블 오프셋에 24비트를 사용합니다'
# 'Use large-integer access for consecutive bitfield runs.'
HAFC147F2F63A: '연속된 비트필드 실행에 대해 큰 정수 접근을 사용하십시오.'
# 'Use linker features to support dead code stripping of globals'
H25F0988FF38D: '링커 기능을 사용하여 전역 변수의 사망 코드 제거를 지원하십시오'
# 'Use loop idiom recognition code size heuristics when compiling with -Os/-Oz'
H16B2DB694C4C: '-Os/-Oz로 컴파일할 때 루프 패턴 인식 코드 크기 휴리스틱을 사용합니다'
# 'Use masked vector intrinsics'
HD66DB2015BA3: '마스킹된 벡터 인트리니시스를 사용하세요'
# 'Use md5 to represent function names in the output profile (only meaningful for -extbinary)'
HE791F5E32608: 'md5를 사용하여 함수 이름을 나타냅니다 (다음 경우에만 의미가 있습니다: -extbinary)'
# 'Use memory profile for profile-guided memory optimization'
H5A1906ADE19C: '프로파일 기반 메모리 최적화를 위해 메모리 프로파일을 사용합니다'
# 'Use more powerful methods of sharpening expression ranges. May be costly in terms of compile time'
HD0AB27E80870: '표현식 범위를 더 세밀하게 하는 더 강력한 방법을 사용합니다. 컴파일 시간 측면에서 비용이 많이 들 수 있습니다'
# 'Use native PDB reader instead of DIA'
H9315B56556F2: 'DIA 대신 네이티브 PDB 리더를 사용하세요.'
# 'Use new kernel launching API for HIP'
HB4F88B0BE07A: 'HIP를 위한 새로운 커널 런칭 API를 사용하십시오'
# 'Use odr indicators to improve ODR reporting'
H74C4F000003D: 'ODR 표시자를 사용하여 ODR 보고를 개선하십시오'
# 'Use old-style Thumb2 if-conversion heuristics'
H98BE9934D232: '구식 Thumb2 if 변환 휴리스틱을 사용합니다'
# 'Use one trap block per function'
HAC8964692418: '함수당 트랩 블록을 하나씩 사용하십시오'
# 'Use only doxygen-style comments to generate docs.'
H609A25655FBA: '문서를 생성하려면 오직 Doxygen 스타일 주석만 사용하십시오.'
# 'Use only register numbers when writing assembly output'
H3A4857A621C3: '어셈블리 출력을 작성할 때 레지스터 번호만 사용하십시오.'
# "Use optimistic attributes describing 'as-if' properties of runtime calls."
H4E943E97F387: "런타임 호출의 'as-if' 속성을 설명하는 낙관적 속성을 사용하십시오."
# 'Use packed stack layout (SystemZ only).'
HD83EA715FFB0: '압축된 스택 레이아웃 사용 (SystemZ 전용).'
# 'Use page aliasing in HWASan'
H4A8E0010EDA7: 'HWASan에서 페이지 별칭 사용'
# 'Use pipes between commands, when possible'
HE3D5879BAE89: '가능한 경우 명령어 사이에 파이프를 사용하십시오'
# 'Use post increment control-dependent ranges in IndVarSimplify'
H911B15838A45: 'IndVarSimplify에서 포스트 인크리먼트 제어 종속적 범위를 사용하십시오'
# 'Use predicated EVL instructions for tail folding. If EVL is unsupported, fallback to data-without-lane-mask.'
HED0757D8A6A8: '꼬리 접기(tail folding)를 위해 예측된 EVL 명령어를 사용합니다. EVL이 지원되지 않는 경우, 데이터-레인 마스크 없이 대체합니다.'
# 'Use preferred fixed label for all labels'
H89BB5704EA97: '모든 레이블에 추천되는 고정 레이블을 사용하세요'
# 'Use prefix for memory intrinsics in KASAN mode'
HA3237877312E: 'KASAN 모드에서 메모리 인트리니스틱스에 프리픽스를 사용하라'
# 'Use private aliases for global variables'
H7796ADF97BE6: '전역 변수에 대해 private 별칭을 사용하십시오'
# 'Use profi to infer block and edge counts'
H65DAA2E87B9C: 'profi를 사용하여 블록과 엣지 카운트를 추론하십시오'
# 'Use profi to infer block and edge counts.'
H8CD455D93A81: 'profi를 사용하여 블록과 엣지 카운트를 추론하십시오.'
# 'Use profile info to add section prefix for hot/cold functions'
HC0D88E37E898: '프로파일 정보를 사용하여 hot/cold 함수에 섹션 접두사를 추가합니다'
# 'Use pseudo probes in profile generation'
H0886E88805AB: '프로파일 생성에 가상 탐지점을 사용합니다'
# 'Use public LTO visibility for classes in std and stdext namespaces'
H0471C4CC8A6A: 'std 및 stdext 네임스페이스의 클래스에 대해 공개 LTO 가시성을 사용해야 합니다'
# 'Use raw weights for labels. Use percentages as default.'
H84E197A50BE8: '레이블에 원시 가중치를 사용하십시오. 기본값으로 백분율을 사용합니다.'
# 'Use register sized accesses to bit-fields, when possible.'
HEC8949CF52C8: '가능한 경우 레지스터 크기의 접근을 비트 필드에 사용하십시오.'
# 'Use relative paths for invoking subcommands'
HF3DBC88EA771: '하위 명령어를 실행할 때 상대 경로를 사용하세요'
# 'Use release mode (AOT-compiled model)'
H3C1DD2917917: '릴리즈 모드 사용 (AOT-컴파일된 모델)'
# 'Use ring buffer for stack allocations'
H1D67F21B8816: '스택 할당에 링 버퍼 사용'
# 'Use rnglists for contiguous ranges if that allows using a pre-existing base address'
H0FA2B904A3EB: '연속적인 범위에 rnglists를 사용하여 이미 존재하는 기본 주소를 사용할 수 있다면 그렇게 하십시오'
# 'Use round-robin distribution of functions to modules instead of the default name-hash-based one'
H2DC1323199D5: '기본 이름-해시 기반 대신 모듈에 함수를 라운드-로빈 방식으로 분배합니다'
# 'Use row-major layout'
HE68D3A295C31: '행 우선 레이아웃을 사용하십시오'
# 'Use runtime alias checks to resolve possible aliasing.'
H74ED44C8AB6B: '런타임 별칭 검사를 사용하여 가능한 별칭 문제를 해결합니다.'
# 'Use sampled profile to guide PGO.'
H83EE2F7AD7E3: 'PGO에 표본 프로파일을 사용합니다.'
# 'Use sections+offset as references rather than labels.'
HC0250DDB1574: '구역+offset을 참조로 사용해야 합니다. 라벨 대신에'
# 'Use segment set for the computation of the live ranges of physregs.'
H297ADEEDAC19: '물리 레지스터의 활성 범위 계산에 세그먼트 세트를 사용하십시오.'
# 'Use segmented stack'
H45E75CED74E8: '세그먼트 스택을 사용하십시오.'
# 'Use separate accesses for consecutive bitfield runs with legal widths and alignments.'
HDAEB15795B56: '유효한 너비와 정렬을 가진 연속적인 비트필드 런에 대해 개별 접근을 사용하십시오.'
# 'Use separate unique sections for named sections'
HBA19BDB53714: '이름이 있는 섹션에 대한 고유한 별도 섹션 사용'
# 'Use separate unique sections for named sections (ELF Only)'
H966D46021E86: '이름 있는 섹션에 대해 별도의 고유 섹션 사용 (ELF만 해당)'
# 'Use shared memory to transfer generated code and data'
H5DE48C3CC472: '공유 메모리를 사용하여 생성된 코드 및 데이터를 전송합니다'
# 'Use simple template names in DWARF, or include the full template name with a modified prefix for validation'
HCADD22C917E1: 'DWARF에서 단순한 템플릿 이름을 사용하거나, 검증을 위해 접두사를 수정한 전체 템플릿 이름을 포함하십시오'
# 'Use smallest entry possible for jump tables'
H51B906CF7E2B: '가능한 가장 작은 항목을 점프 테이블에 사용하십시오'
# 'Use software floating point'
HE54F4CA19BBF: '소프트웨어 부동소수점 사용'
# 'Use specified bytecode when generating output'
H6F1FA0ED25C1: '지정된 바이트코드를 출력 생성 시 사용합니다.'
# 'Use stack probes (default)'
HBB884418570D: '스택 프로브 사용 (기본값)'
# 'Use static debug run-time'
HC2C965E8960E: '정적 디버그 런타임을 사용하십시오'
# 'Use static run-time'
H53E3F295A611: '정적 런타임을 사용하세요'
# 'Use target platform default'
H1C5D924DE4CE: '타겟 플랫폼 기본값 사용'
# 'Use text-based completion if the parser is not ready'
H2FD4CB6E479F: '파서가 준비되지 않았을 경우 텍스트 기반 완성을 사용하십시오'
# 'Use the AMDGPU specific RPTrackers during scheduling'
HA779151F216B: '스케줄링 중 AMDGPU 고유의 RPTrackers를 사용하십시오'
# 'Use the AST -> LLVM pipeline to compile'
H4DBFD65A7D65: 'AST -> LLVM 파이프라인을 사용하여 컴파일하세요.'
# 'Use the BLOCK_INFO from the given file'
HF8FF5F8C2E3C: '지정된 파일에서 BLOCK_INFO를 사용하십시오'
# 'Use the ClangIR pipeline to compile'
H3E61FEC2858B: 'ClangIR 파이프라인을 사용하여 컴파일하십시오.'
# 'Use the DFA based hazard recognizer.'
HB08DE21B4CC4: 'DFA 기반 위험 인식기를 사용하십시오.'
# 'Use the FDPIC ABI'
HAD67F08A6522: 'FDPIC ABI를 사용하십시오.'
# 'Use the Greedy mode (best local mapping)'
H86402D6079EC: '탐욕스러운 모드(Greedy mode)를 사용하십시오 (가장 우수한 지역 매핑)'
# 'Use the LLVM representation for assembler and object files'
H598F01E104A3: 'LLVM 표현을 어셈블리 및 오브젝트 파일에 사용합니다'
# 'Use the MVE code generator for software pipelining'
H07D34F141A55: '소프트웨어 파이프라인을 위해 MVE 코드 생성기를 사용하십시오'
# "Use the basic-block-sections profile to determine the text section prefix for hot functions. Functions with basic-block-sections profile will be placed in `.text.hot` regardless of their FDO profile info. Other functions won't be impacted, i.e., their prefixes will be decided by FDO/sampleFDO profiles."
H7751642AFC12: 'basic-block-sections 프로필을 사용하여 hot 함수의 텍스트 섹션 접두사를 결정합니다. basic-block-sections 프로필을 가진 함수는 FDO 프로필 정보와 무관하게 `.text.hot`에 배치됩니다. 다른 함수는 영향을 받지 않으며, 즉, 그 접두사는 FDO/sampleFDO 프로필에 의해 결정됩니다.'
# 'Use the current working directory as the base directory of compiled module files.'
HC4A3722E1C1D: '컴파일된 모듈 파일들의 기본 디렉토리로 현재 작업 디렉토리를 사용합니다.'
# 'Use the current working directory as the home directory of module maps specified by -fmodule-map-file=<FILE>'
H8AE9B0359BD7: '모듈 맵이 -fmodule-map-file=<FILE> 옵션으로 지정될 때 현재 작업 디렉토리를 모듈 맵의 홈 디렉토리로 사용합니다'
# 'Use the dependence analysis interface'
HDF3A2E881A47: '의존성 분석 인터페이스를 사용하십시오'
# 'Use the experimental C++ class ABI for classes with virtual tables'
HBFD90D3B3FDE: '가상 테이블을 가진 클래스에 대해 실험적인 C++ 클래스 ABI를 사용하십시오'
# 'Use the experimental OpenMP-IR-Builder codegen path.'
H0A44AF245C92: '실험적인 OpenMP-IR-Builder CodeGen 경로를 사용하십시오.'
# 'Use the experimental peeling code generator for software pipelining'
H14186C9F73CB: '실험적 피리링 코드 생성기를 소프트웨어 파이프라인에 사용합니다'
# 'Use the first input module as the merged module'
H8EEE69848E3D: '첫 번째 입력 모듈을 병합된 모듈로 사용합니다'
# 'Use the full schema for serialization'
HFE88B8373E59: '직렬화에 전체 스키마를 사용하십시오'
# 'Use the given guard (global, tls) for addressing the stack-protector guard'
H1CBDB2D23600: '지정된 가드(글로벌, tls)를 스택-프로텍터 가드 주소 지정에 사용합니다'
# 'Use the given offset for addressing the stack-protector guard'
H5EC45CECD53A: '스택 보호기 가드를 위해 주어진 오프셋을 사용하라'
# 'Use the given reg for addressing the stack-protector guard'
H2907454E4058: '주어진 reg 레지스터를 스택 보호기의 주소 지정에 사용합니다.'
# 'Use the given symbol for addressing the stack-protector guard'
HB4E7196A5294: '스택 보호기(guard)를 지정하기 위해 주어진 심볼을 사용합니다'
# 'Use the given vector functions library'
H8A7DC0CD5F6E: '지정된 벡터 함수 라이브러리를 사용합니다'
# 'Use the given vector functions library. Note: -fveclib={ArmPL,SLEEF} implies -fno-math-errno'
HB6448F1B4907: '지정된 벡터 함수 라이브러리를 사용합니다. 참고: -fveclib={ArmPL,SLEEF}는 -fno-math-errno를 의미합니다.'
# 'Use the gnu89 inline semantics'
H86341C44D7F1: 'gnu89 inline 시맨틱을 사용하십시오'
# "Use the host's platform-specific path separator character when expanding the __FILE__ macro"
H19B5E5B63186: '호스트의 플랫폼별 경로 구분 문자를 __FILE__ 매크로를 확장할 때 사용하십시오'
# 'Use the implementation defaults'
H46CDBE8DC11A: '구현 기본값을 사용하십시오'
# 'Use the last modification time of <file> as the build session timestamp'
HC4A79FF67275: '파일의 마지막 수정 시간을 빌드 세션 타임스탬프로 사용합니다'
# 'Use the llvm.experimental.noalias.scope.decl intrinsic during inlining.'
H9063D587CE9C: '인라인 중에 llvm.experimental.noalias.scope.decl 인트린식을 사용하십시오.'
# 'Use the named plugin action in addition to the default action'
H2C8F63F64ACF: '기본 작업에 추가로 지정된 플러그인 작업을 사용하라'
# 'Use the named plugin action instead of the default action (use "help" to list available options)'
HEB1C020DB399: '기본 액션 대신 지정된 플러그인 액션을 사용하세요 (옵션 목록을 보기 위해서는 "help"를 입력하세요)'
# 'Use the native __fp16 type for arguments and returns (and skip ABI-specific lowering)'
H638090B7484A: '인수 및 반환 값에 원시 __fp16 형식을 사용 (ABI 특정 하위 호환 처리를 건너뛰기)'
# 'Use the native half type for __fp16 instead of promoting to float'
HF8914EF176E5: '__fp16에 대해 float로 승격하는 대신 네이티브 half 형을 사용하라'
# 'Use the native platform for the executor.Requires -orc-runtime'
HA522D7482E1A: '실행기용 네이티브 플랫폼을 사용합니다. -orc-runtime 옵션이 필요합니다'
# 'Use the new driver for OpenMP offloading.'
H4FEA64EFDBD7: 'OpenMP 오프로딩에 새 드라이버를 사용하십시오.'
# 'Use the new driver for offloading compilation.'
H2C38A94F0FE6: '오프로딩 컴파일을 위해 새로운 driver를 사용하십시오.'
# 'Use the new method of lowering partial reductions.'
H67B6026FF0E7: '새로운 부분 감소 하향 변환 방법을 사용하십시오.'
# 'Use the new offloading linker to perform the link job.'
HBE633D219689: '새 오프로딩 링커를 사용하여 링크 작업을 수행합니다.'
# 'Use the old (incorrect) instruction latency calculation'
H2E61A14D081C: '구(잘못된) 명령어 지연 계산을 사용합니다'
# 'Use the preinliner decisions stored in profile context.'
HD0A0D412FA60: '프로파일 컨텍스트에 저장된 preinliner 결정 사항을 사용하십시오.'
# 'Use the remappings described in <file> to match the profile data against names in the program'
HD47D317FB40F: '프로파일 데이터를 프로그램의 이름과 일치시키기 위해 <file>에 설명된 재매핑을 사용합니다'
# 'Use the scalar evolution interface'
HD228C1FFC83E: '스칼라 진보 인터페이스를 사용하십시오'
# 'Use the specified contextual profile file'
H21441E080C2A: '지정된 컨텍스트 프로파일 파일을 사용하라.'
# 'Use the static host OpenMP runtime while linking.'
H409015ECE8E9: '링킹 시 정적 호스트 OpenMP 런타임을 사용합니다.'
# "Use the target's default scheduler choice."
HEF05D039293B: '타겟의 기본 스케줄러 선택을 사용하십시오.'
# "Use the target's platform-specific path separator character when expanding the __FILE__ macro"
H7C74BA846E17: '__FILE__ 매크로를 확장할 때 타겟 플랫폼의 경로 구분자 문자를 사용하십시오'
# 'Use the unified LTO pipeline'
H95AFD66F1EAB: '통합된 LTO 파이프라인을 사용하십시오'
# 'Use this option to enable basic block coverage instrumentation'
H0CDE08096A2C: '이 옵션을 사용하여 기본 블록 커버리지 인스트루먼테이션을 활성화합니다'
# 'Use this option to enable function entry coverage instrumentation.'
HD78AD2BC6F5D: '이 옵션을 사용하여 함수 진입 커버리지 인스트루먼트를 활성화합니다.'
# 'Use this option to enable temporal instrumentation'
HAB3379855655: '이 옵션을 사용하여 시간적 인스트루먼트 활성화'
# 'Use this option to turn off/on warnings about function with samples but without debug information to use those samples. '
H511084B41E5F: '이 옵션을 사용하여 샘플이 있지만 디버그 정보가 없는 함수(이 샘플을 사용하기 위한)에 대한 경고를 끄거나 켜세요.'
# 'Use this option to turn off/on warnings about profile cfg mismatch.'
H1D04CE0F6A8E: '프로파일 CFG 불일치에 대한 경고를 끄거나 켜는 옵션을 사용합니다.'
# 'Use this option to turn on/off SELECT instruction instrumentation. '
HDC5EDE7DE3E2: '이 옵션을 사용하여 SELECT 명령어의 인스트루먼테이션을 켜거나 끌 수 있습니다. '
# 'Use this option to turn on/off memory intrinsic size profiling.'
HF19744FEF2C8: '이 옵션을 사용하여 메모리 인트린식 크기 프로파일링을 켜거나 끕니다.'
# 'Use this option to turn on/off warnings about incorrect usage of llvm.expect intrinsics.'
H3723F53142CC: '이 옵션을 사용하여 llvm.expect 인트린스의 잘못된 사용에 대한 경고를 켜거나 끕니다.'
# 'Use this option to turn on/off warnings about missing profile data for functions.'
H78D4B914E121: '이 옵션을 사용하여 함수에 대한 누락된 프로파일 데이터에 대한 경고를 켜고 끌 수 있습니다.'
# 'Use this to override the target cache line size when specified by the user.'
H43C33F17EAA5: '사용자가 지정할 때 대상 캐시 라인 크기를 재정의하기 위해 이것을 사용합니다.'
# "Use this to override the target's minimum page size."
HEA1997AE00E5: '이 옵션을 사용하여 타겟의 최소 페이지 크기를 재정의합니다.'
# "Use this to override the target's predictable branch threshold (%)."
H9102D958180E: '이 옵션을 사용하여 대상의 예측 가능한 분기 임계값을 재정의합니다 (%).'
# 'Use this to skip inserting cache invalidating instructions.'
HE32E1CC26F2E: '이 옵션을 사용하면 캐시 무효화 명령어의 삽입을 건너뛸 수 있습니다.'
# 'Use this to specify the default maximum number of instructions to scan backward from a given instruction, when searching for available loaded value'
H673F71583921: '이 옵션을 사용하여 특정 명령문에서 역방향으로 스캔하기 위해 기본 최대 명령문 수를 지정합니다. 이는 사용 가능한 로드된 값이 있을 때 탐색 시에 사용됩니다.'
# 'Use this to specify the default trip count of a loop'
HEB778E135667: '이 옵션을 사용하여 루프의 기본 반복 횟수를 지정합니다'
# 'Use this to specify the max. distance between array elements accessed in a loop so that the elements are classified to have temporal reuse'
HABE5835F827F: '이 옵션을 사용하여 루프 내에서 접근된 배열 요소 사이의 최대 거리를 지정하여 해당 요소들이 임시 재사용을 갖도록 분류되도록 합니다'
# 'Use this unroll count for all loops including those with unroll_and_jam_count pragma values, for testing purposes'
HD799D9D7B870: '테스트 목적을 위해 모든 루프에 이 펼침 수 사용 (unroll_and_jam_count pragma 값이 있는 루프 포함)'
# 'Use this unroll count for all loops including those with unroll_count pragma values, for testing purposes'
HEF3DD1B9175D: '이 언롤 카운트를 모든 루프에 적용하며, unroll_count pragma 값이 있는 루프도 포함합니다. 테스트 목적으로 사용'
# 'Use together with -emit-llvm to get pristine LLVM IR from the frontend by not running any LLVM passes at all'
H80E48E5F4285: '-emit-llvm와 함께 사용하여 프론트엔드에서 LLVM 패스를 전혀 실행하지 않음으로써 원시 LLVM IR을 얻습니다'
# 'Use undef when generating programs.'
HD1F883A2CCED: '프로그램 생성 시 undef를 사용하십시오.'
# 'Use unified LTO piplines. Ignored unless -thinlto-bc is also specified.'
H84A36B27E595: '통합된 LTO 파이플라인을 사용합니다. -thinlto-bc도 지정되지 않는 한 무시됩니다.'
# 'Use unique names for basic block sections (ELF Only)'
HDE45C38B60C6: '기본 블록 섹션에 고유한 이름을 사용하십시오 (ELF만 해당)'
# 'Use verbose output'
H579A705CE0A4: '상세 출력 사용'
# 'Use window algorithm after SMS algorithm fails.'
H29FAE7BBDC36: 'SMS 알고리즘이 실패한 후에 창 알고리즘을 사용하십시오.'
# 'Use window algorithm instead of SMS algorithm.'
H0091F49C954B: 'SMS 알고리즘 대신 윈도우 알고리즘을 사용하세요.'
# 'Use with -ast-dump or -ast-print to dump/print only AST declaration nodes having a certain substring in a qualified name. Use -ast-list to list all filterable declaration node names.'
H03F2BB85517F: '특정 서브스트링을 포함하는 자격 증명 이름을 가진 AST 선언 노드만 출력하기 위해 -ast-dump 또는 -ast-print와 함께 사용합니다. 필터 가능한 모든 선언 노드 이름을 열거하려면 -ast-list를 사용하세요.'
# 'Use zlib'
H7267EE40AF01: 'zlib를 사용하십시오.'
# 'Use zstd'
HADE0CBD533EE: 'zstd 사용'
# 'Used for test purpuses'
H143A636D4E4C: '테스트 목적으로 사용됨'
# 'User directory for configuration files'
HD1D0604448D4: '사용자 구성 파일 디렉토리'
# 'User specified cold threshold for instr profile which will override the cold threshold got from profile summary. '
H921527455582: '사용자가 instr 프로파일의 cold threshold를 지정하여 프로파일 요약에서 얻은 cold threshold를 덮어씁니다. '
# 'User supplied asset path to override the default css and js files for html output'
H11CFB81E3E7B: '사용자가 제공한 리소스 경로를 사용하여 HTML 출력에 대한 기본 CSS 및 JS 파일을 재정의합니다'
# 'Uses the source file name instead of the Module hash. This requires that the source filename has a unique name / path to avoid name collisions.'
HEFB279BA9297: '소스 파일 이름을 모듈 해시 대신 사용합니다. 이름 충돌을 피하기 위해 소스 파일 이름이 유일한 이름/경로를 가져야 합니다.'
# 'VALU instruction count threshold for adjusting wave priority'
H323BECA8255D: '웨이브 우선순위 조정을 위한 VALU 명령어 수 임계값'
# 'VE Assembly Printer'
H35AB8A791661: 'VE 어셈블리 프린터'
# 'VE DAG->DAG Pattern Instruction Selection'
H31A1129B2EDC: 'VE DAG→DAG 패턴 명령어 선택'
# 'VLIW scheduler'
H04220C47ABF0: 'VLIW 스케줄러'
# 'Validate PCH input files based on content if mtime differs'
H5B0B3696A2CD: 'mtime이 다를 경우 내용을 기반으로 PCH 입력 파일 검증'
# 'Validate PCM input files based on content if mtime differs'
HE7966DE5A8B2: 'mtime이 다를 경우 내용을 기반으로 PCM 입력 파일 검증'
# 'Validate that all vtables have type infos in LTO'
H66B413E67029: '모든 vtables가 LTO에서 타입 정보를 가지고 있는지 검증합니다'
# 'Validate the system headers that a module depends on when loading the module'
HEE36D448D56F: '모듈을 로드할 때 해당 모듈이 의존하는 시스템 헤더를 검증합니다'
# 'Value for __PIC__'
H760023C619A3: '__PIC__의 값'
# 'Value to pass to hot/cold operator new for cold allocation'
H6DAF60C415A6: 'hot/cold operator new에 전달할 cold 할당의 값'
# 'Value to pass to hot/cold operator new for hot allocation'
HD1597DC64127: 'hot/cold operator new에 전달할 hot 할당을 위한 값'
# 'Value to pass to hot/cold operator new for notcold (warm) allocation'
HE0D30EC39F19: 'hot/cold operator new에 전달할 notcold (warm) 할당을 위한 값'
# 'Variable.'
H7236856976D0: '변수.'
# 'Vector functions library'
H22962FC6DC51: '벡터 함수 라이브러리'
# 'Vectorization cost threshold.'
HCD21FCE9A5E0: '벡터화 비용 임계값.'
# 'Vectorize if the invocation count is < than this. 0 disables vectorization.'
H282E25ADE422: '호출 횟수가 이 값보다 작으면 벡터화합니다. 0은 벡터화를 비활성화합니다.'
# 'Vectorize load and Store instructions'
HC110C6BBCB5B: '로드 및 스토어 명령어 벡터화'
# 'Vectorize load and store instructions'
HBBECD678BBBC: '로드 및 스토어 명령어 벡터화'
# 'Vectorize up to this many bundles.'
H5F30F00C03B7: '이렇게 많은 번들까지 벡터화합니다.'
# 'Verbosity level of the contextual profile printer pass.'
H635358C62DFB: '컨텍스트 프로파일 프린터 패스의 자세도 수준.'
# 'Verbosity of log messages written to stderr'
H2E24D6564DA8: '표준 에러 출력에 쓰여진 로그 메시지의 상세도'
# 'Verfiy VPlans after VPlan transforms.'
HE7FC42CC42C7: 'VPlan 변환 후 VPlans 검증합니다.'
# 'Verify AMDGPU HSA Metadata'
H65A2759AA257: 'AMDGPU HSA 메타데이터 검증'
# 'Verify Call Frame Information instructions'
H027197CC37B3: '호출 프레임 정보 지시문 검증'
# 'Verify IR correctness when making sensitive SCEV queries (slow)'
H42A1AB630381: '민감한 SCEV 쿼리를 수행할 때 IR 정확성을 검증합니다 (느림)'
# 'Verify PredicateInfo in legacy printer pass.'
H799D5E295653: '고전적 프린터 패스에서 PredicateInfo 검증'
# "Verify ScalarEvolution's backedge taken counts (slow)"
HA5864D8AB4F8: '스칼라 진보(ScalarEvolution)의 백엣지(Backedge) 실행 횟수 검증 (느림)'
# 'Verify after each transform'
H357D460E1502: '각 변환 후 검증'
# 'Verify device memory post execution against the original output.'
HE16F0A0EAC54: '실행 후 디바이스 메모리를 원본 출력과 비교하여 검증합니다.'
# 'Verify diagnostic output using comment directives that start with prefixes in the comma-separated sequence <prefixes>'
HC54A2E24270E: '<prefixes>의 쉼표로 구분된 시퀀스에 있는 접두사로 시작하는 주석 지시문을 사용하여 진단 출력을 확인하십시오.'
# 'Verify dominator info (time consuming)'
H7265FCA24E7A: '제어 도미네이터 정보 검증 (시간 소모적)'
# 'Verify domtree after unrolling'
H9FB6F655E747: '언롤링 후 dom 트리 검증'
# 'Verify during register allocation'
HA235BE2313EF: '레지스터 할당 중 검증'
# 'Verify generated machine code'
HAB7C952A6204: '생성된 머신 코드 검증'
# 'Verify legalizations'
H442690F32499: '허용 사항 검증'
# 'Verify legalizations and artifact combines'
H810B83C40C92: '합법화 단계 및 아티팩트 결합 검증'
# 'Verify loop info (time consuming)'
H7C86EDFCE360: '루프 정보 확인 (시간이 많이 소요됨)'
# 'Verify loop lcssa form (time consuming)'
H0CAAF184E14A: '루프 LCSSA 형식 검증(시간 소모적)'
# 'Verify loopinfo after unrolling'
H03E2A3EBA62D: '언롤링 후 루프 정보 검증'
# 'Verify loops generated Loop Idiom Vectorize Pass.'
H8FE13960BD12: 'Loop Idiom Vectorize 패스에서 생성된 루프 검증'
# 'Verify machine code after expanding ARM pseudos'
H4928DCB0BD05: 'ARM 의사 명령을 확장한 후 머신 코드 검증'
# 'Verify machine dominator info (time consuming)'
H7DB30C69D5DA: '머신 도미네이터 정보 검증 (시간 소모적)'
# 'Verify machine instrs before and after machine scheduling'
H13FA77C833AC: '머신 스케줄링 전후의 머신 명령어를 검증합니다'
# 'Verify machine instrs before and after register coalescing'
HDD83DA18C7C7: '레지스터 코얼싱 전후의 머신 명령어 검증'
# 'Verify region info (time consuming)'
H9292DD1C4B56: '영역 정보 검증(시간이 많이 소요됨)'
# 'Verify sanity of PHI instructions during taildup'
H0D6EE6D76E64: 'taildup 중 PHI 명령문의 정상성을 검증합니다'
# 'Verify that computeKnownBits() and SimplifyDemandedBits() are consistent'
HD464B311F8B5: 'computeKnownBits()와 SimplifyDemandedBits()가 일관성 있는지 확인하십시오'
# 'Verify that debug locations are handled'
H5157BEF03DC8: '디버그 위치가 올바르게 처리되었는지 확인합니다'
# 'Verify that narrow int args are properly extended per the SystemZ ABI.'
H7B81C58E5DE9: 'SystemZ ABI에 따라 narrow int args가 적절히 확장되었는지 확인합니다.'
# 'Verify that the generated patterns are ordered by increasing latency'
HB35BF620F949: '생성된 패턴들이 지연 시간이 증가하는 순서대로 정렬되어 있는지 확인하십시오.'
# 'Verify the binary representation of debug output'
HD5EDEFE1C648: '디버그 출력의 바이너리 표현을 검증합니다'
# 'Verify the detected SCoPs after each transformation'
H577B4C82C33A: '각 변환 후 감지된 SCoPs를 검증합니다'
# 'Verify the function generated by Polly'
H36FACBAA370A: 'Polly가 생성한 함수를 검증하십시오'
# 'Verify this pass produces no dead code'
HD157362652B5: '이 패스가 죽은 코드를 생성하지 않는지 검증합니다'
# 'Version loops if flattened loop could overflow'
H2ED0232BC13B: '버전 루프가 평탄화된 루프가 오버플로우될 경우 실행됩니다'
# 'View BFI after MIR loader'
H70176654BA61: 'MIR 로더 이후 BFI 보기'
# 'View BFI before MIR loader'
HD24CF0251C0D: 'BFI를 MIR 로더 전에 보기'
# 'View Options'
HDA1AEDD5C0C0: '보기 옵션'
# 'View call graph'
HC3CF5708A682: '호출 그래프 보기'
# 'View dominance tree of function'
H8CAAE8FCD27E: '함수의 우세 트리 보기'
# 'View dominance tree of function (with no function bodies)'
HB12C18D29169: '함수의 도미네이스 트리 보기 (함수 본문을 포함하지 않음)'
# 'View postdominance tree of function'
H5144E7801A69: '함수의 포스트 도미네이스 트리 보기'
# 'View postdominance tree of function (with no function bodies)'
H6016FE3E7B20: '함수의 포스트도미네이스 트리 보기 (함수 본문 없음)'
# 'View regions of function'
HC65478A71B23: '함수의 영역 보기'
# 'View regions of function (with no function bodies)'
H5ECE0F8FFA1A: '함수의 영역 보기 (함수 본문 없음)'
# 'View the CFG before DFA Jump Threading'
H7CED97AC3765: 'DFA 점프 스레딩 전 제어 흐름 그래프 보기'
# 'View the dependency graph.'
H4CD0E62026DC: '의존성 그래프를 확인하십시오.'
# 'Viewing options'
H4109B1BD7A45: '보기 옵션'
# 'Virtual Register Map'
HBAB873C35568: '가상 레지스터 맵'
# 'Virtual Register Rewriter'
H70230BEE99F4: '가상 레지스터 재작성기'
# 'Volatile loads and stores have acquire and release semantics'
HA2D66EAC62AA: 'Volatile 로드와 스토어는 어쿼이어 및 릴리즈 세마틱스를 갖습니다'
# 'Volatile loads and stores have standard semantics'
H3FC4BC9157CA: 'Volatile 로드와 스토어는 표준 의미론을 가집니다'
# 'Volatile specifier.'
H5BCC57A6F6B7: 'Volatile 지정자.'
# 'Vreg distance cutoff for insert generation.'
HE65C5AFBE2C8: '삽입 생성을 위한 Vreg 거리 기준값'
# 'Vreg# cutoff for insert generation.'
H69051D37244E: '삽입 생성을 위한 가상 레지스터 번호의 임계값.'
# 'WARNING: This option will replace your input file with the reduced version!'
HA6B4706DBC98: '경고: 이 옵션은 입력 파일을 축소된 버전으로 대체합니다!'
# "WARNING: You're attempting to print out a bitcode file.\nThis is inadvisable as it may cause display problems. If\nyou REALLY want to taste LLVM bitcode first-hand, you\ncan force output with the `-f' option.\n\n"
HD29B4F840F03: "경고: 비트코드 파일을 출력하려고 시도하고 있습니다.\n이 작업은 표시 문제가 발생할 수 있어 권장하지 않습니다. 만약\n정말로 LLVM 비트코드를 직접 확인하고 싶다면 `-f' 옵션을\n강제로 사용할 수 있습니다.\n\n"
# 'Wait for user input before entering JITed code'
HE997D4A27F4E: '실행 전 사용자 입력을 기다리는 JIT 코드'
# 'Wait until all forks of instrumented process will finish (use with instrumentation-sleep-time option)'
H29419FC27D66: '측정된 프로세스의 모든 포크가 종료될 때까지 기다립니다 (instrumentation-sleep-time 옵션과 함께 사용하세요)'
# 'Warn for mismatching a signed and unsigned value'
H2A8E011548FA: '부호 있는 값과 부호 없는 값이 서로 일치하지 않을 때 경고'
# 'Warn for missing parenthesis around predicate registers'
HE7943720E0D3: '조건 레지스터 주위에 괄호가 누락되었을 때 경고'
# "Warn for register names that aren't contigious"
HFB31626439DD: '연속적이지 않은 레지스터 이름에 대해 경고합니다'
# 'Warn if a function definition returns or accepts an object larger in bytes than a given value'
H8990A87A623D: '함수 정의가 지정된 바이트 수보다 큰 객체를 반환하거나 수락할 경우 경고합니다'
# 'Warn in ARM, emit implicit ITs in Thumb'
HC57002E0EFBF: 'ARM에서 경고, Thumb에서 암시적 IT를 생성합니다'
# 'Warn in ARM, reject in Thumb'
H4EFFA07355E3: 'ARM에서 경고, Thumb에서 거부'
# 'Warn on equivalent symbols in the output symbol list'
H88E497B15A1B: '출력 심볼 목록에서 동일한 심볼이 있을 경우 경고'
# 'Warn on input symbols missing from output symbol list'
HE4D0B0A892DF: '입력 심볼이 출력 심볼 목록에 없을 경우 경고'
# 'Warn on language extensions'
HCCA103ACA6B2: '언어 확장에 대한 경고'
# 'Warn on use'
HE0ABF7E28126: '사용 시 경고'
# 'Warning Options'
HEA0EF30FD9BD: '경고 옵션'
# 'Warnings about individual formatting changes needed. Used only with --dry-run or -n'
HA24BD5E41E3E: '개별 형식 변경이 필요한 경고. --dry-run 또는 -n 옵션과 함께 사용됩니다'
# 'Warnings detected.'
H9BB1C52DB1D8: '경고가 감지되었습니다.'
# 'Warnings to generate.'
H0499BE5B2273: '생성할 경고 항목.'
# 'Weakly link in the blocks runtime'
H32E4B9C0D02B: '블록 런타임을 약하게 연결합니다'
# 'WebAssembly Assmebly Printer'
H618A8F3DD855: 'WebAssembly 어셈블리 프린터'
# 'WebAssembly Clean Code After Trap'
H5004FAB71B78: 'WebAssembly 트랩 후 코드 정리'
# 'WebAssembly Emscripten-style exception handling'
HB909CEF50795: 'WebAssembly Emscripten 방식 예외 처리'
# 'WebAssembly Emscripten-style setjmp/longjmp handling'
HB327E2AC0CF6: 'WebAssembly Emscripten 스타일의 setjmp/longjmp 처리'
# 'WebAssembly Exception Information'
HB914447C6B3D: 'WebAssembly 예외 정보'
# 'WebAssembly Instruction Selection'
H6897B43BD95A: 'WebAssembly 명령어 선택'
# 'WebAssembly Late Exception Preparation'
H2CE3575C6DB6: 'WebAssembly 늦은 예외 준비'
# 'WebAssembly Lower Emscripten Exceptions / Setjmp / Longjmp'
HBA47203A675C: 'WebAssembly Emscripten 예외/Setjmp/Longjmp를 하위 변환'
# 'WebAssembly Lower RefTypes Int-Ptr Conversions'
HFE0286340D39: 'WebAssembly RefTypes 정수-포인터 변환을 하위 변환'
# 'WebAssembly Nullify DBG_VALUE_LISTs'
HA5294064B53B: 'WebAssembly DBG_VALUE_LISTs 초기화'
# 'WebAssembly exception handling'
H886CFE14EC29: 'WebAssembly 예외 처리'
# 'WebAssembly exception handling (legacy)'
H7E31087C50F3: 'WebAssembly 예외 처리 (LEGACY)'
# 'WebAssembly peephole optimizations'
H430AF441595E: 'WebAssembly 피스홀 최적화'
# 'WebAssembly reference type not allowed in exception specification'
H14B705277A94: 'WebAssembly 참조 유형은 예외 지정에 허용되지 않습니다.'
# 'WebAssembly setjmp/longjmp handling'
H9F0C3575883B: 'WebAssembly setjmp/longjmp 처리'
# 'WebAssembly table cannot be declared within a function'
H085E37C320EB: 'WebAssembly 테이블은 함수 내에서 선언될 수 없습니다'
# 'WebAssembly table must be static'
H23C0F2D20589: 'WebAssembly 테이블은 정적일 수만 있습니다'
# 'WebAssembly: Disable EH pad-first sort order. Testing purpose only.'
HBC8CFE10E3BC: 'WebAssembly: EH 패드-퍼스트 정렬 순서 비활성화. 테스트 용도만.'
# 'WebAssembly: Disable fallthrough-return optimizations.'
H8B46242EE529: 'WebAssembly: fallthrough-return 최적화를 비활성화합니다.'
# 'WebAssembly: output implicit locals in instruction output for test purposes only.'
HBD0CCB517ABD: 'WebAssembly: 테스트 목적으로만 명령어 출력에 암시적 로컬 변수를 표시합니다.'
# 'WebAssembly: output stack registers in instruction output for test purposes only.'
HCAF0317DF2F0: 'WebAssembly: 테스트 목적으로만 instruction 출력에 스택 레지스터를 포함합니다.'
# 'Weight for argument embeddings'
H6E245963349C: '매개변수 임베딩 가중치'
# 'Weight for opcode embeddings'
HAF6B081C42AD: '오퍼코드 임베딩 가중치'
# 'Weight for type embeddings'
HAD8C8AF4F1BA: '타입 임베딩 가중치'
# 'Weight of the branch likely to be taken (default = 2000)'
H39B8B6D520C6: '취해질 것으로 예상되는 분기의 가중치 (기본값 = 2000)'
# 'Weight of the branch unlikely to be taken (default = 1)'
H2A04B39F2CCF: '발생 가능성이 낮은 브랜치의 가중치(기본값 = 1)'
# 'What is the maximal lookup depth when trying to check for viability of negation sinking.'
H7F1CA4DE1A48: '부정 하강의 유효성을 확인하려고 시도할 때 최대 탐색 깊이는 무엇인가?'
# 'What length to truncate vertex labels to '
H3DED4F5FCF91: '정점 레이블을 잘라내는 길이는 얼마인가? '
# 'What to do with the summary when running this pass'
H42E595F78536: '이 패스를 실행할 때 요약 정보를 어떻게 처리할지'
# "When -frepack-arrays is in effect, 'whole' enables repacking for arrays that are non-contiguous in any dimension, 'innermost' enables repacking for arrays that are non-contiguous in the innermost dimension (the default)"
H20A445368AD8: "'whole'는 모든 차원이 비연속인 배열에 대한 재패킹을 활성화하며, 'innermost'는 가장 내부 차원이 비연속인 배열에 대한 재패킹을 활성화합니다 (기본값)"
# 'When -fvisibility-inlines-hidden is enabled, static variables in inline C++ member functions will also be given hidden visibility by default'
HC9E644F8BF87: '-fvisibility-inlines-hidden 옵션이 활성화되면, 인라인 C++ 멤버 함수 내의 정적 변수들도 기본적으로 숨겨진 가시성을 부여받습니다'
# 'When a diagnostic is emitted on an operation, also print the operation as an attached note'
H2ECC08973193: '연산에 대한 진단이 발생하면 해당 연산을 첨부된 참고 메시지로 함께 출력합니다'
# 'When a diagnostic is emitted, also print the stack trace as an attached note'
H76C424E9438C: '진단이 발생될 때, 스택 추적을 부착된 참고 메시지로 함께 출력합니다'
# 'When creating a PCH, stop PCH generation after #pragma hdrstop.'
HD38248648BFF: 'PCH를 생성할 때, #pragma hdrstop 이후에 PCH 생성을 중지합니다.'
# 'When dfsan-combine-offset-labels-on-gep and/or dfsan-combine-pointer-labels-on-load are false, this flag can be used to re-enable combining offset and/or pointer taint when loading specific constant global variables (i.e. lookup tables).'
H081A797A7BB7: 'dfsan-combine-offset-labels-on-gep 및/또는 dfsan-combine-pointer-labels-on-load가 거짓일 때, 이 플래그는 특정 상수 전역 변수(예: 조회 테이블)를 로드할 때 오프셋과/또는 포인터 타인트 결합을 다시 활성화하는 데 사용할 수 있습니다.'
# 'When discriminating instructions with memory operands, ignore prefetch instructions. This ensures the other memory operand instructions have the same identifiers after inserting prefetches, allowing for successive insertions.'
H7E4D0664626F: '메모리 오퍼랜드를 가진 명령어를 구분할 때 프리패치 명령어를 무시합니다. 이렇게 하면 프리패치를 삽입한 후 다른 메모리 오퍼랜드 명령어들이 동일한 식별자를 가지게 되어 연속적인 삽입을 가능하게 합니다.'
# 'When displaying an injected source, display the file content'
H3DDBC39BBF92: '주입된 소스를 표시할 때 파일 내용을 표시합니다'
# 'When dumping a SymIndexId, dump the full details of the corresponding record'
HE9EC08CB2E15: 'SymIndexId를 덤프할 때, 해당 레코드의 전체 세부 정보를 덤프하라'
# 'When dumping debug chunks, show a different section for each chunk'
HFD526CCFAF68: '디버그 조각을 덤프할 때 각 조각마다 다른 섹션을 표시합니다'
# "When dumping type records for classes, unions, enums, and structs, don't try to resolve forward references"
HBD90D91A2AFF: '클래스, 유니온, 열거형, 구조체에 대한 타입 레코드를 덤프할 때, 전방 참조를 해결하려고 시도하지 마세요'
# 'When epilogue vectorization is enabled, and a value greater than 1 is specified, forces the given VF for all applicable epilogue loops.'
H9B19DBFD9697: '에필로그 벡터화가 활성화되고 1보다 큰 값이 지정되면, 적용 가능한 모든 에필로그 루프에 지정된 VF를 강제합니다.'
# 'When generating a crash reproducer, attempt to generated a reproducer with the smallest pipeline.'
H527701909117: 'crash 재현 파일을 생성할 때 가장 작은 파이프라인으로 재현 파일을 생성하려고 시도합니다.'
# 'When generating nested context-sensitive profiles, always generate extra base profile for function with all its context profiles merged into it.'
H4E82789DA6E1: '중첩된 컨텍스트-감수성 프로파일을 생성할 때는 해당 함수의 모든 컨텍스트 프로파일을 병합한 추가 기본 프로파일을 항상 생성하십시오.'
# 'When merging conditional stores, do so even if the resultant basic blocks are unlikely to be if-converted as a result'
H33EB082F4E55: '조건부 저장을 병합할 때, 결과적으로 생성되는 기본 블록들이 if-변환이 불가능하더라도 계속 진행하라'
# 'When performing SCEV expansion only if it is cheap to do, this controls the budget that is considered cheap (default = 4)'
H6E8B9FA2EB34: 'SCEV 확장을 수행할 때 수행 비용이 적을 경우에만 수행할 때, 이 옵션이 "저렴하다"고 간주되는 예산을 제어합니다 (기본값 = 4)'
# 'When performing memory disambiguation checks at runtime do not generate more than this number of comparisons (default = 8).'
HBB48DD13984F: '실행 시 메모리 해체 검사를 수행할 때 이 숫자보다 많은 비교를 생성하지 마세요 (기본값 = 8).'
# 'When printing IR for print-[before|after]{-all} always print a module IR'
HEE9A6FDE189D: 'print-[before|after]{-all}에 대한 IR 출력 시 항상 모듈 IR을 출력합니다'
# 'When printing IR for print-[before|after]{-all} for a loop pass, always print function IR'
HD8F4D915AAB6: 'print-[before|after]{-all} 루프 패스에 대한 IR을 출력할 때마다, 항상 함수 IR을 출력합니다'
# 'When printing IR for print-ir-[before|after]{-all} always print the top-level operation'
H58BBC34B4C5E: 'IR을 출력할 때 print-ir-[before|after]{-all} 옵션을 사용할 때는 항상 최상위 레벨 오퍼레이션을 출력합니다'
# 'When printing analysis, include information on every instruction'
H27AFC0602C62: '분석을 출력할 때 모든 명령에 대한 정보를 포함합니다'
# 'When printing machine IR, annotate instructions and blocks with SlotIndexes when available'
H8B62DF7E25E7: '머신 IR을 출력할 때 SlotIndexes가 사용 가능한 경우 인스트럭션과 블록에 주석을 추가합니다'
# 'When printing the IR after a pass, only print if the IR changed'
H0B8C96DE116C: '패스 실행 후 IR을 출력할 때는 IR이 변경된 경우에만 출력합니다'
# 'When printing the IR after a pass, only print if the pass failed'
H42128FB51A38: '패스 후 IR을 출력할 때는 패스가 실패했을 경우에만 출력합니다'
# 'When printing the IR before/after a pass, print file tree rooted at this directory. Use in conjunction with mlir-print-ir-* flags'
HC069026BC657: '패스 전후에 IR을 출력할 때, 이 디렉토리를 루트로 하는 파일 트리를 출력합니다. mlir-print-ir-* 플래그와 함께 사용하십시오.'
# 'When set to true, const objects with relocatable address values are put into the RO data section.'
H66324957E3F0: 'true로 설정되면, 재배치 가능한 주소 값을 가지는 const 객체는 RO 데이터 섹션에 배치됩니다.'
# 'When stubbing functions, replace all uses will null'
HBC6C3A0A1E4B: '함수를 스터빙할 때 모든 사용처를 null로 변경합니다'
# 'When the basic block contains not more than this number of PHI nodes, perform a (faster!) exhaustive search instead of set-driven one.'
H95DC35D4BF29: '기본 블록에 PHI 노드의 수가 이 수 이하일 때, 세트 기반 방식 대신 (더 빠른!) 완전 탐색을 수행합니다.'
# 'When the option is false, if the target block is in a loop, the promotion will be disallowed unless the promoted counter  update can be further/iteratively promoted into an acyclic  region.'
HFCDA16D52A31: '옵션이 거짓일 경우, 타겟 블록이 루프 내에 있을 때 프로모션이 허용되지 않습니다. 단, 프로모된 카운터 업데이트를 비순환 영역으로 추가/반복적으로 프로모션할 수 있는 경우는 제외됩니다.'
# 'When this option is on, the annotated branch probability will be emitted as optimization remarks: -{Rpass|pass-remarks}=pgo-instrumentation'
H5E55F3D7A2DD: '이 옵션이 활성화되면 주석이 달린 분기 확률을 최적화 메모로 표시합니다: -{Rpass|pass-remarks}=pgo-instrumentation'
# 'When to emit DWARF unwind (EH frame) info'
H0DBCF1BE684C: 'DWARF 언윈드 (EH 프레임) 정보를 언제 생성할지'
# 'When to use colors in diagnostics'
HBE3593F16E43: '진단 메시지에서 색상을 언제 사용하는지'
# 'When true, SLP vectorizer bypasses profitability checks based on heuristics and makes vectorization decision via cost modeling.'
H05B0C2731561: '참일 경우, SLP 벡터라이저는 휴리스틱 기반의 수익성 검사를 우회하고 비용 모델링을 통해 벡터화 결정을 내립니다.'
# 'When used with filetype=obj, emit an object file which can be used with an incremental linker'
HE96BEC53314D: 'filetype=obj와 함께 사용될 때, 증분 링커와 호환되는 오브젝트 파일을 생성합니다'
# 'When used with filetype=obj, relax all fixups in the emitted object file'
H167CB844A0DE: 'filetype=obj와 함께 사용할 때 생성된 오브젝트 파일의 모든 수정사항을 완화합니다'
# 'When using -fxray-function-groups, select which group of functions to instrument. Valid range is 0 to fxray-function-groups - 1'
H763EF25FAB59: '-fxray-function-groups 옵션을 사용할 때 트레이스할 함수 그룹을 선택합니다. 유효한 범위는 0부터 fxray-function-groups - 1까지입니다'
# 'When using a PCH, skip tokens until after a #pragma hdrstop.'
H0A2ABCA96B55: 'PCH를 사용할 때는 #pragma hdrstop 이후까지 토큰을 건너뜁니다.'
# 'Where to run polly in the pass pipeline'
H9B2F95971D75: '패스 파이프라인에서 polly를 실행할 위치'
# 'Whether has closed-world assumption at link time'
H99F1999EDDBD: '링 타임에 closed-world 가정이 있는지 여부'
# 'Whether inline replay should be applied to the entire Module or just the Functions (default) that are present as callers in remarks during cgscc inlining.'
HD26538F942D7: '인라인 재생성(replay)을 전체 모듈에 적용할지, 또는 기본값인 cgscc 인라인 중 주석(remarks)에서 호출자로 나타나는 함수들만 적용할지 여부.'
# 'Whether inline replay should be applied to the entire Module or just the Functions (default) that are present as callers in remarks during sample profile inlining.'
H694D5B29DF1C: '샘플 프로파일 인라인 중 주석의 호출자로 존재하는 전체 모듈에 적용할지, 아니면 기본값인 해당 함수에만 적용할지를 결정합니다.'
# 'Whether new header will depend on old header. If true, clang-move will add #include of old header to new header.'
HEAD603DC16D2: '새 헤더가 옛 헤더에 의존할지 여부입니다. 참일 경우 clang-move는 새 헤더에 옛 헤더의 #include를 추가합니다.'
# 'Whether old header will depend on new header. If true, clang-move will add #include of new header to old header.'
H3B1BCC2BCADE: '기존 헤더가 새 헤더에 종속되는지 여부입니다. true인 경우, clang-move는 새 헤더의 #include를 기존 헤더에 추가합니다.'
# 'Whether or not to compute detailed function properties.'
H665EA58EEFEB: '세부 함수 속성을 계산할지 여부입니다.'
# 'Whether or not to enable features under development for the ML regalloc advisor'
HF0690434B74D: 'ML regalloc advisor에 대한 개발 중인 기능들을 활성화할지 여부'
# 'Whether or not we should insert assumes of conditions of predicated guards'
H825B30E48FC9: '조건의 predicated guards의 조건에 대한 가정을 삽입할지 여부'
# 'Whether or not we should predicate guards expressed as widenable branches to deoptimize blocks'
H3D40391D0BD5: '확장 가능한 분기로 표현된 가드를 최적화 해제 블록에 적용할지 여부'
# 'Whether or not we should widen guards  expressed as branches by widenable conditions'
HFD8C2DB7CA08: '확장 가능한 조건에 의해 가지치기 형태로 표현된 가드를 확장할지 여부'
# 'Whether to apply ext-tsp placement for instances w/o profile'
H77F1EF844B16: '프로파일이 없는 인스턴스에 ext-tsp 배치를 적용할지 여부'
# 'Whether to build a relocatable precompiled header'
HB03E5614FB01: '재배치 가능한 사전 컴파일 헤더를 생성할지 여부'
# 'Whether to distribute into a loop that may not be if-convertible by the loop vectorizer'
HB249A06C5F2F: '루프 벡터라이저에 의해 if-convertible이 될 수 없는 루프에 분할할지 여부'
# 'Whether to emit DWARF EH frame entries.'
HDDECD32989A5: 'DWARF EH 프레임 항목을 생성할지 여부'
# 'Whether to generate default bounds for arrays.'
HA8699205DACC: '배열에 대한 기본 경계를 생성할지 여부.'
# 'Whether to include the lower dimensions extents in the stride.'
H4245438632CE: 'stride에 하위 차원의 범위를 포함할지 여부'
# 'Whether to minimize added include paths'
HC7C82427C36C: '추가된 include 경로를 최소화할지 여부'
# 'Whether to perform binary concatenation'
H4B115FCD938B: '바이너리 연결을 진행할지 여부'
# 'Whether to perform binary extraction'
H9D6252A4435A: '바이너리 추출을 수행할지 여부'
# 'Whether to try to emit Compact Unwind for non canonical entries.'
H55500B1ACFA7: '비정형 항목에 대해 Compact Unwind를 생성하려고 시도할지 여부입니다.'
# 'Whether to use the address from fix.box in data clause operations.'
H17A5E7DCB500: '데이터 절 연산에서 fix.box의 주소를 사용할지 여부'
# 'Whether to use the bareptr calling convention on the host (warning this should be false until the GPU layering is fixed)'
HEF14896C6BC2: '호스트에서 bareptr 호출 규약을 사용할지 여부 (경고: GPU 계층이 수정될 때까지 이 값은 false여야 합니다)'
# 'Whether to use the bareptr calling convention on the kernel (warning this should be false until the GPU layering is fixed)'
H99F227DA714B: '커널에서 bareptr 호출 규칙을 사용할지 여부 (경고: GPU 계층이 수정될 때까지 이 값은 false여야 합니다)'
# 'Whether to use the cost heuristic to make choices as we traverse the search space using the exact solver. Defaulted to on, and if turned off, we will use the node order -- attempting to put the later nodes in the later sched groups. Experimentally, results are mixed, so this should be set on a case-by-case basis.'
HF1BAF3533D97: '정확한 솔버를 사용하여 탐색 공간을 탐색하면서 선택을 할 때 비용 휴리스틱을 사용할지 여부입니다. 기본값은 켜짐이며, 꺼지면 노드 순서를 사용하여 후속 노드를 후속 스케줄 그룹에 배치하려고 시도합니다. 실험적으로 결과는 혼합되어 있으며, 이 옵션은 사례별로 설정해야 합니다.'
# 'Whether to use the exponential time solver to fit the instructions to the pipeline as closely as possible.'
H086A0DF8B27C: '지수 시간 솔버를 사용하여 명령문을 파이프라인에 최대한 가깝게 조정할지 여부입니다.'
# 'Whether we should inject new invariants and unswitch them to eliminate some existing (non-invariant) conditions.'
H3C32643D02A0: '새로운 불변식을 주입하고 이를 unswitch하여 존재하는 (비불변식인) 조건들을 제거할지 여부'
# 'Which DWARF linkage-name attributes to emit.'
H09FB4F2415AD: '생성할 DWARF 연결 이름 속성을 지정합니다.'
# 'Which dependence analysis should loop fusion use?'
HAD495CD6F62E: '루프 융합에 사용할 의존성 분석 유형을 지정합니다.'
# "Which overload candidates to show when overload resolution fails. Defaults to 'all'"
H3E34CE4DE5D1: "오버로드 해상이 실패할 때 표시할 오버로드 후보를 선택합니다. 기본값은 'all'입니다"
# 'Which thread-local storage dialect to use for dynamic accesses of TLS variables'
H811A2F4F5EAE: '동적 접근을 수행하는 TLS 변수에 사용할 스레드 로컬 저장소(TLS) 방언을 선택합니다.'
# 'Which unit to use for fp math'
HE5F83035EE94: 'fp 수학에 사용할 단위 지정'
# 'Widen sub-dword constant address space loads in AMDGPUCodeGenPrepare'
HA61656982921: 'AMDGPUCodeGenPrepare에서 서브-드워드 상수 주소 공간 로드를 확장'
# 'Widen sub-dword constant address space loads in AMDGPULateCodeGenPrepare'
H16C37A921AE2: 'AMDGPULateCodeGenPrepare에서 하위 dword 상수 주소 공간 로드를 확장합니다'
# "Widen the loop induction variables, if possible, so overflow checks won't reject flattening"
HF84F6515DE2A: '가능한 경우 루프 인덕션 변수를 확장하여 오버플로 검사가 평탄화를 거부하지 않도록 합니다'
# 'Widen uniform 16-bit instructions to 32-bit in AMDGPUCodeGenPrepare'
H46D2473C38FB: 'AMDGPUCodeGenPrepare에서 균일한 16비트 명령어를 32비트로 확장합니다'
# 'Windows exception model'
H86EB91F51633: 'Windows exception 모델'
# 'With -globals, only dump globals whose name matches the given value'
H08E7C52DD63F: '-globals 옵션을 사용하면, 지정된 값과 이름이 일치하는 글로벌만 출력합니다'
# 'With PGO, include profile count in optimization remarks'
HA68492B41822: 'PGO를 사용할 때 최적화 메모에 프로파일 카운트를 포함하라'
# 'Work around Cortex-A57 Erratum 1742098 (ARM only)'
H2CF5C8E79954: 'Cortex-A57 오류 1742098 우회 (ARM 전용)'
# 'Work around Cortex-A72 Erratum 1655431 (ARM only)'
HB9954D8E1844: 'Cortex-A72 Erratum 1655431 우회 (ARM 전용)'
# 'Work around VLLDM erratum CVE-2021-35465 (ARM only)'
H6484FD8B0341: 'VLLDM 오류 CVE-2021-35465 (ARM 전용)을 회피합니다'
# 'Work with `--skip-symbolization` or `--unsymbolized-profile` to write/read the offset instead of virtual address.'
H1CA65028F454: ' `--skip-symbolization` 또는 `--unsymbolized-profile` 옵션을 사용하여 가상 주소 대신 오프셋을 쓰거나 읽으세요.'
# 'Workaround Cortex-A53 erratum 835769 (AArch64 only)'
H479486F0F64D: 'Cortex-A53 오류 835769 회피 방법 (AArch64 전용)'
# "Wouldn't use segmented stack"
HF45022A557BC: '세그먼트 스택을 사용하지 않을 것입니다'
# 'Write Bitcode'
H6EB243E1EECC: '비트코드 작성'
# 'Write a compilation database entry per input'
H69BE4C131EAE: '각 입력에 대한 컴파일 데이터베이스 항목을 작성합니다'
# 'Write a depfile containing user and system headers'
HDB1957B0249A: '사용자 및 시스템 헤더를 포함한 depfile을 작성합니다'
# 'Write a depfile containing user headers'
H294C0D501665: '사용자 헤더를 포함하는 의존성 파일을 작성하세요'
# 'Write assembly to file for input to assemble jobs'
H7C079FE214C7: '어셈블리 코드를 조립 작업의 입력으로 사용하기 위해 파일에 작성'
# 'Write current time into COFF output (default)'
HF98DECE931FC: 'COFF 출력에 현재 시간을 기록 (기본값)'
# 'Write depfile output from -MMD, -MD, -MM, or -M to <file>'
H7F1DEF2B183F: '의존성 파일 출력을 -MMD, -MD, -MM 또는 -M 옵션으로부터 <file>에 작성합니다'
# 'Write extracted files to a static archive'
H167164B5BAE5: '추출된 파일을 정적 아카이브에 씁니다'
# 'Write lazy-function executions to a CSV file as (JITDylib, function) pairs'
HEA5DEA15DFD8: '지연 함수 실행을 (JITDylib, function) 쌍으로 CSV 파일에 기록합니다'
# 'Write linked LTO module to file before optimize'
HCE5CCE000DB8: '최적화 전 연결된 LTO 모듈을 파일에 작성'
# 'Write merged LTO module to file before CodeGen'
HD65008F3EA67: 'CodeGen 이전에 병합된 LTO 모듈을 파일에 작성'
# 'Write minimized bitcode to <file> for the ThinLTO thin link only'
H675031C72335: 'ThinLTO 희소 링크에 대한 최소화된 비트코드를 <file>에 작성합니다'
# 'Write out individual imports files via InProcessThinLTO. Has no effect unless specified with -thinlto-emit-indexes or -thinlto-distributed-indexes'
H19E7DA782B06: 'InProcessThinLTO를 통해 개별 import 파일을 작성합니다. -thinlto-emit-indexes 또는 -thinlto-distributed-indexes 옵션과 함께 지정되지 않으면 효과가 없습니다'
# 'Write out individual index and import files for the distributed backend case'
H2A414F2C0CA7: '분산 백엔드 케이스를 위한 개별 인덱스 및 import 파일을 작성합니다'
# 'Write out individual index files via InProcessThinLTO'
H04EFB23839D1: 'InProcessThinLTO를 통해 개별 인덱스 파일을 출력합니다'
# 'Write output as LLVM assembly'
HC401168D9C72: 'LLVM 어셈블리로 출력을 작성'
# 'Write output as ThinLTO-ready bitcode'
H81BE69D83D3F: 'ThinLTO 준비된 비트코드로 출력을 작성합니다'
# 'Write output to <file>'
HCABB93CE5040: '출력을 <file>에 작성합니다'
# 'Write output to <file>.'
HA5CAFFC7A76E: '파일에 출력을 작성합니다.'
# 'Write relative block frequency to function summary '
H61EDFA1BBE67: '함수 요약에 상대 블록 빈도를 기록합니다 '
# 'Write summary to given YAML file after running pass'
H2786584E85AF: '패스 실행 후 지정된 YAML 파일에 요약을 작성합니다'
# 'Write summary to given bitcode or YAML file after running pass. Output file format is deduced from extension: *.bc means writing bitcode, otherwise YAML'
HF422AA3A57C9: '패스 실행 후 주어진 bitcode 또는 YAML 파일에 요약을 작성합니다. 출력 파일 형식은 확장자에서 결정됩니다: *.bc는 bitcode 형식, 나머지는 YAML 형식입니다.'
# 'Write the previous version of indexed format, to enable some forward compatibility.'
H214BE48CC62F: '지수 형식의 이전 버전을 작성하여 일부 앞으로의 호환성을 허용합니다.'
# 'Writes always set the type'
H90F97A092B90: '쓰기는 항상 형식을 설정합니다'
# 'X86 Assembly Printer'
HD5F043986D92: 'X86 어셈블리 프린터'
# 'X86 Call Frame Optimization'
H6C1AD91D1BC8: 'X86 호출 프레임 최적화'
# 'X86 DAG->DAG Instruction Selection'
H7AF1958AB670: 'X86 DAG->DAG 명령어 선택'
# 'X86 Domain Reassignment Pass'
H208A2EDE1B82: 'X86 영역 재할당 패스'
# 'X86 DynAlloca Expander'
H1CB6E843E202: 'X86 동적 Alloca 확장기'
# 'X86 EFLAGS copy lowering'
H478602C51D49: 'X86 EFLAGS 복사 하향식 변환'
# 'X86 Execution Domain Fix'
HB1A8033FDC96: 'X86 실행 도메인 수정'
# 'X86 FP Stackifier'
HB70E458DAF08: 'X86 부동소수점 스택 처리기'
# 'X86 LVI load hardening'
HE886300056CC: 'X86 LVI 로드 강화'
# 'X86 LVI ret hardener'
H7BB1121F99C0: 'X86 LVI 리턴 경화 장치'
# 'X86 Partial Reduction'
H71421E3EAECA: 'X86 부분 감소'
# 'X86 Return Thunks'
HB7A0BD877623: 'X86 리턴Thunk'
# 'X86 Speculative Execution Side Effect Suppression'
HAC95FD71C1F3: 'X86 예측 실행 부작용 억제'
# 'X86 Suppress APX features for relocation'
H1A67E3308F3A: 'X86 재배치를 위한 APX 기능 억제'
# 'X86 cmov Conversion'
H459397A41EF1: 'X86 cmov 변환'
# 'X86 optimize LEA pass'
HA2592D9DB191: 'X86 LEA 최적화 패스'
# 'X86 pseudo instruction expansion pass'
H90C7B8C811FD: 'X86 의사 명령어 전개 패스'
# 'X86 speculative load hardener'
H2A7987566821: 'X86 예측 로드 강화기'
# 'X86: Disable LEA optimizations.'
H9A76B9360F40: 'X86: LEA 최적화를 비활성화합니다.'
# 'X86: Disable Store Forwarding Blocks fixup.'
H182CD9732E25: 'X86: 스토어 포워딩 블록 수정 비활성화.'
# 'X86: Disable Virtual Register Reassignment.'
H12CE3299B81B: 'X86: 가상 레지스터 재할당 비활성화.'
# 'X86: Number of instructions backward to inspect for store forwarding blocks.'
HEFF525BFF565: 'X86: 스토어 포워딩 블록을 검사하기 위해 뒤로 가는 명령문의 수.'
# 'X86: enable AMX scalarizition.'
HCECBA05C8A45: 'X86: AMX 스칼라화 활성화.'
# 'XCore Assembly Printer'
H1AA113AD0A3E: 'XCore 어셈블리 프린터'
# 'XCore DAG->DAG Pattern Instruction Selection'
H581ED762EAE6: 'XCore DAG->DAG 패턴 명령어 선택'
# 'XRay Tools\n\n  This program consolidates multiple XRay trace processing tools for convenient access.\n'
HFB113E3ACE56: 'XRay 도구\n\n  이 프로그램은 편리한 접근을 위해 여러 XRay 추적 처리 도구를 통합합니다.\n'
# 'Xtensa Assembly Printer'
H1172BF988F99: 'Xtensa 어셈블리 프린터'
# 'YAML'
HFFBCB202B09D: 'YAML'
# 'Yaml database created by find-all-symbols'
H338C17AD7D21: 'YAML 데이터베이스는 find-all-symbols에 의해 생성되었습니다.'
# 'Yaml database, with fuzzy-matched names'
H858A2F00C528: 'YAML 데이터베이스, 퍼지 매칭된 이름 포함'
# 'Zero initialize globals without default initialization'
H16BF774B86E6: '기본 초기화 없이 글로벌 변수를 0으로 초기화합니다'
# 'Zero initialize globals without default initialization (default)'
H49398887AE1B: '디폴트 초기화 없이 글로벌 변수를 0으로 초기화 (기본값)'
# 'Zero line numbers.'
HBDDF04B8DE1F: '라인 번호가 없습니다.'
# 'Zero out the discriminator bits for the FS discrimiantor pass beyond this value. The enum values are defined in Support/Discriminator.h'
H86161643B09B: '이 값 이후에 FS discrimiantor 패스에 대한 디스크리미안토르 비트를 0으로 설정합니다. 열거형 값은 Support/Discriminator.h에 정의되어 있습니다.'
# '[<input file>,...] (deprecated)'
HBAF2C191067E: '[<입력 파일>,...] (사용 중지 예정)'
# '[<offload kind>-<target triple>,...]'
HE5C00640F67F: '[<오프로드 유형>-<타겟 트리플>,...]'
# '[<output file>,...] (deprecated)'
H701132FD6E40: '[<output file>,...] (지원 중단됨)'
# '[@<file>] [<file> ...]'
HA0A725D8D937: '[@<파일>] [<파일> ...]'
# '[LICM & MemorySSA] When MSSA in LICM is disabled, this has no effect. When MSSA in LICM is enabled, then this is the maximum number of accesses allowed to be present in a loop in order to enable memory promotion.'
H15A8950FC7AE: '[LICM & MemorySSA] LICM에서 MSSA가 비활성화되면 이 옵션은 아무 영향을 미치지 않습니다. MSSA가 활성화된 경우, 이 값은 메모리 프로모션을 활성화하기 위해 루프 내에서 허용되는 접근 수의 최대값을 지정합니다.'
# '[WIP] Tries to hide the latency of host to device memory transfers'
HC6732C3722E0: '[WIP] 호스트에서 디바이스 메모리 전송의 지연 시간을 숨기려 시도합니다'
# '[[]] attributes are a C++11 extension'
H8246F8EB1C38: '[[]] 속성은 C++11 확장입니다'
# '[[]] attributes are a C23 extension'
H65C81736C143: '[[]] 속성은 C23 확장 기능입니다'
# '[[]] attributes are incompatible with C standards before C23'
HFCBAAA359BD9: '[[]] 속성은 C23 이전의 C 표준과 호환되지 않습니다'
# '[[]] attributes are incompatible with C++ standards before C++11'
H963EC793AF1E: '[[]] 특성은 C++11 이전의 C++ 표준과 호환되지 않습니다'
# '[code to run]'
HBFD9181194E0: '[실행할 코드]'
# '[ignorelist file]'
H5547568B1A46: '[무시 목록 파일]'
# '[input bitcode]...'
H8C715EEC26A7: '[입력 비트코드]...'
# '[no]neon is not accepted as modifier, please use [no]simd instead'
H34DCBA8F9AA1: '[no]neon은 수정자로 허용되지 않습니다. 대신 [no]simd를 사용해 주세요'
# '\\%0 used with no following hex digits'
H4ACD9688DA19: '\\%0가 사용되었지만 뒤따라오는 16진수 자릿수가 없습니다.'
# "\\%0 used with no following hex digits; treating as '\\' followed by identifier"
H34C9A007F8A0: "\\%0에 따라오는 16진수 숫자가 없습니다; '\\'를 따르는 식별자로 처리합니다"
# '^^ is a reserved operator in OpenCL'
H0C0A23A57F10: '^^는 OpenCL에서 예약된 연산자입니다.'
# '_Atomic cannot be applied to %select{incomplete |array |function |reference |atomic |qualified |sizeless ||integer |}0type %1 %select{|||||||which is not trivially copyable||in C23}0'
H323CC2CB8E5D: '_Atomic은 %select{불완전한 |배열 |함수 |참조 |원자형 |지정된 |크기 없는 ||정수형 |}0 형식 %1 %select{|||||||복사가 가능한 형식이 아닙니다||C23에서}0 적용할 수 없습니다'
# '_GLOBAL_OFFSET_TABLE_'
HE310DB69A9CE: '_GLOBAL_OFFSET_TABLE_'
# '_Pragma takes a parenthesized string literal'
HC3D115F3D6CB: '_Pragma는 괄호로 감싸진 문자열 리터럴을 취합니다'
# '__CUDA_ARCH'
H640861EF7CBB: '__CUDA_ARCH'
# '__DATA'
H6F22B9326AE7: '__DATA'
# '__LINKEDIT'
H1EA417FFF11E: '링크 편집'
# '__VA_ARGS__ can only appear in the expansion of a C99 variadic macro'
HA5D98E4DA6FF: '__VA_ARGS__는 C99 가변 인자 매크로의 확장 시에만 사용될 수 있습니다'
# '__VA_OPT__ can only appear in the expansion of a variadic macro'
HCDC494FE863F: '__VA_OPT__는 가변형 매크로의 확장 시에만 사용될 수 있습니다'
# '__VA_OPT__ cannot be nested within its own replacement tokens'
H7C3979F48311: '__VA_OPT__는 자신의 대체 토큰 내부에서 중첩할 수 없습니다'
# '__arm_agnostic("sme_za_state") cannot share ZA state with its caller'
H3F5679E58734: '__arm_agnostic("sme_za_state")는 호출자와 ZA 상태를 공유할 수 없습니다'
# '__arm_agnostic("sme_za_state") is not supported together with __arm_new("za") or __arm_new("zt0")'
H1551D9BB8B08: '__arm_agnostic("sme_za_state")은 __arm_new("za") 또는 __arm_new("zt0")와 함께 사용되지 않음'
# '__asm used with no assembly instructions'
H8FE87A3A5F53: '어셈블리 명령어 없이 __asm 사용'
# '__block attribute not allowed on declaration with a variably modified type'
H10FB78A8E9A5: '__block attribute는 가변적으로 수정된 형식을 가지는 선언에 사용할 수 없습니다.'
# '__block attribute not allowed, only allowed on local variables'
HE188099287CD: '__block 속성은 허용되지 않습니다. 로컬 변수에만 허용됩니다.'
# '__block variable %0 cannot be captured in a %select{lambda expression|captured statement}1'
HD7DB9752FAAD: '__block 변수 %0은 %select{람다 표현식|캡쳐된 문}1에서 캡쳐될 수 없습니다'
# '__builtin_btf_type_id argument %0 not a constant'
H48F1BECDC866: '__builtin_btf_type_id의 인수 %0가 상수가 아닙니다'
# '__builtin_get_vtable_pointer requires an argument of%select{| polymorphic}0 class pointer type, but %1 %select{was provided|has no virtual methods}0'
H6F5E8AE6B1DC: '__builtin_get_vtable_pointer는 %select{|다형적}0 클래스 포인터 타입의 인수를 필요로 하지만, %1은 %select{제공되었습니다|가상 메서드가 없습니다}0'
# '__builtin_get_vtable_pointer requires an argument with a complete type, but %0 is incomplete'
HC06F79966A72: '__builtin_get_vtable_pointer는 완전한 타입의 인수를 필요로 하지만, %0은 불완전합니다'
# '__builtin_longjmp is not supported for the current target'
H53A6EFDFCD17: '__builtin_longjmp는 현재 타겟에서 지원되지 않습니다.'
# "__builtin_mul_overflow does not support 'signed _BitInt' operands of more than %0 bits"
H24B9AB05270A: "__builtin_mul_overflow는 %0 비트보다 많은 비트를 가진 'signed _BitInt' 피연산자를 지원하지 않습니다"
# '__builtin_preserve_enum_value argument %0 invalid'
H341194DCABD7: '__builtin_preserve_enum_value 인자 %0 무효입니다'
# '__builtin_preserve_enum_value argument %0 not a constant'
HCADD1D27CE0B: '__builtin_preserve_enum_value 인수 %0는 상수 값이 아닙니다'
# '__builtin_preserve_field_info argument %0 not a constant'
HA3DE67421A5E: '__builtin_preserve_field_info 인수 %0는 상수가 아닙니다'
# '__builtin_preserve_field_info argument %0 not a field access'
H153927D1D427: '__builtin_preserve_field_info 인수 %0는 필드 접근이 아닙니다'
# '__builtin_preserve_type_info argument %0 invalid'
H92B5B29F2F9A: '__builtin_preserve_type_info 인수 %0가 유효하지 않음'
# '__builtin_preserve_type_info argument %0 not a constant'
H57FE08B33075: '__builtin_preserve_type_info 인수 %0는 상수 값이 아닙니다'
# '__builtin_setjmp is not supported for the current target'
H08E9B75B93D5: '__builtin_setjmp는 현재 타겟에서 지원되지 않습니다'
# '__constant__, __device__, and __managed__ are not allowed on non-static local variables'
H4A2DC7998EB3: '__constant__, __device__, 및 __managed__는 비정적 지역 변수에 사용할 수 없습니다'
# '__constant__, __device__, and __shared__ variables must use default address space'
HE599218FA9CA: '__constant__, __device__, __shared__ 변수는 기본 주소 공간을 사용해야 합니다'
# '__declspec attribute %0 is not supported'
H4B7BDD3DADC0: '__declspec attribute %0는 지원되지 않습니다'
# '__declspec attributes must be an identifier or string literal'
HBBCBBEE3784E: '__declspec 속성은 식별자 또는 문자열 리터럴이어야 합니다'
# '__final is a GNU extension, consider using C++11 final'
H9019DE700CF0: '__final은 GNU 확장입니다, C++11 final을 사용하는 것을 고려하세요'
# '__grid_constant__ is only allowed on const-qualified kernel parameters'
HDE081328BF07: '__grid_constant__는 const-qualified 커널 매개변수에서만 허용됩니다'
# '__has_warning expected option name (e.g. "-Wundef")'
H96068DA3D4D1: '__has_warning 매크로는 옵션 이름이 필요합니다 (예: "-Wundef")'
# '__shared__ local variables not allowed in %select{__device__|__global__|__host__|__host__ __device__}0 functions'
H0BA8A02BD0B3: '__shared__ 로컬 변수는 %select{__device__|__global__|__host__|__host__ __device__}0 함수에서 허용되지 않습니다'
# "__shared__ variable %0 cannot be 'extern'"
H76DC43AF246B: "__shared__ 변수 %0는 'extern'로 지정할 수 없습니다"
# '__spirv_backend_service_fun'
HEC37DE49A8CD: '__spirv_backend_service_fun'
# '__sync builtin operation must have natural alignment (consider using __atomic)'
HFAE067F4A98D: '__sync 내장 연산은 자연 대齐를 가져야 합니다 ( __atomic을 사용하는 것을 고려하세요 )'
# '__weak attribute cannot be specified on a field declaration'
HAD92983EAEB2: '__weak 어트리뷰트는 필드 선언에 지정할 수 없습니다.'
# '__weak attribute cannot be specified on an automatic variable when ARC is not enabled'
HC15AE9021482: '__weak 속성은 ARC가 활성화되어 있지 않을 때 자동 변수에 지정할 수 없습니다'
# '`#pragma const_seg` for section %1 will not apply to %0 due to the presence of a %select{mutable field||non-trivial constructor|non-trivial destructor}2'
H8811D5F6122A: '`#pragma const_seg` 섹션 %1에 대한 %0에는 적용되지 않습니다.这是因为 %select{가변 필드||비자명 생성자|비자명 소멸자}2가 존재하기 때문입니다.'
# '`interrupt_save_fp` only applies to targets that have a VFP unit enabled for this compilation; this will be treated as a regular `interrupt` attribute'
HB2C8A1373FD2: '`interrupt_save_fp`는 해당 컴파일에 VFP 유닛이 활성화된 타겟에만 적용되며, 이는 일반 `interrupt` 속성으로 처리됩니다'
# 'a %select{function|block}0 declaration without a prototype is deprecated %select{in all versions of C|}0'
HA427D7F1B8D9: '%select{함수|블록}0의 프로토타입이 없는 선언은 %select{C의 모든 버전에서|}0 비추천 됩니다'
# "a %select{pack indexing|'decltype'}0 specifier cannot be used in a declarative nested name specifier"
H505B17716528: "%select{pack indexing|'decltype'}0 지정자는 선언적 중첩 이름 지정자에서 사용할 수 없습니다"
# 'a concept definition cannot refer to itself'
H3304727AB46C: '컨셉 정의는 자신을 참조할 수 없습니다'
# 'a constant expression cannot modify an object that is visible outside that expression'
H91A285505D66: '상수 표현식에서는 해당 표현식 외부에서 접근 가능한 객체를 수정할 수 없습니다'
# 'a declarative nested name specifier cannot name an alias template'
H09803710CDAC: '선언적 중첩 이름 지정자는 별칭 템플릿을 지정할 수 없습니다'
# 'a firstprivate variable with incomplete type %0'
H893794AB5FB9: 'firstprivate 변수 %0는 미완결 형식을 가집니다'
# 'a friend declaration that befriends a template must contain exactly one type-specifier'
HDEE648B4A187: '템플릿과 친구 관계를 맺는 친구 선언은 정확히 하나의 타입 지정자를 포함해야 합니다'
# 'a function %select{declaration|definition}0 without a prototype is deprecated in all versions of C %select{and is not supported in C23|and is treated as a zero-parameter prototype in C23, conflicting with a %select{previous|subsequent}2 %select{declaration|definition}3}1'
HB3E1938E8933: '프로토타입이 없는 %select{선언|정의}0 함수는 모든 C 버전에서 비권장되었으며 %select{C23에서도 지원되지 않습니다|C23에서는 0개 인자 프로토타입으로 처리됩니다, 이는 %select{이전|이후}2 %select{선언|정의}3과 충돌합니다}1'
# 'a function type is not allowed here'
HE650A35390C3: '이 위치에는 함수 타입이 허용되지 않습니다.'
# 'a getter method is needed to perform a compound assignment on a property'
HEDE5FCF91532: '프로퍼티에 대한 복합 할당을 수행하려면 getter 메서드가 필요합니다'
# 'a lambda expression cannot appear in this context'
H979A7AF92A65: '람다 표현식은 이 컨텍스트에서 사용할 수 없습니다'
# 'a lambda expression may not appear inside of a constant expression'
HB0755DD5F929: '람다 표현식은 상수 표현식 내부에 등장할 수 없습니다'
# 'a lambda parameter cannot shadow an explicitly captured entity'
H65FE428CB516: '람다 매개변수는 명시적으로 캡처된 변수를 가릴 수 없습니다'
# 'a lambda with an explicit object parameter cannot be mutable'
HF1252DDC6E4B: '명시적 객체 매개변수를 가진 람다는 mutable일 수 없습니다'
# 'a lastprivate variable with incomplete type %0'
H8324467E21DA: 'lastprivate 변수 %0는 불완전한 타입입니다'
# 'a linear variable with incomplete type %0'
HE61951ED0B99: '선형 변수 %0는 완전하지 않은 형식을 갖추지 않았습니다.'
# 'a module can only be re-exported as another top-level module'
H272C723A8726: '모듈은 다른 최상위 모듈로만 재수출될 수 있습니다.'
# 'a non-type template parameter cannot have type %0'
H4D4081CB8796: '비형식 템플릿 매개변수는 %0 형식을 가질 수 없습니다'
# 'a non-type template parameter cannot have type %0 before C++20'
HEEE0AA3066FD: 'C++20 이전에는 비유형 템플릿 매개변수는 %0 형식을 가질 수 없습니다'
# 'a parameter list without types is only allowed in a function definition'
H52BB0DED62AC: '타입이 없는 매개변수 목록은 함수 정의에서만 허용됩니다'
# 'a parameter pack may not be accessed at an out of bounds index'
H3E85B76262B3: '매개변수 패키지는 경계를 벗어난 인덱스에서 접근할 수 없습니다'
# 'a private variable with incomplete type %0'
H0A7C86E8874A: '비공개 변수에 불완전한 형식 %0가 있습니다'
# 'a randomized struct can only be initialized with a designated initializer'
H4615845B3A9F: '랜덤화된 구조体型은 지정 초기자로만 초기화될 수 있습니다.'
# 'a reduction list item with incomplete type %0'
H06AA7BC953CB: '불완전한 형식의 리덕션 목록 항목 %0'
# 'a requires expression cannot have an explicit object parameter'
H86B74E3E67C6: 'requires 표현식은 명시적 객체 매개변수를 가질 수 없습니다'
# 'a requires expression must contain at least one requirement'
HA35998709F70: '요구 조건 표현식은 최소한 하나의 요구 조건을 포함해야 합니다'
# "a space is required between a right angle bracket and an equals sign (use '> =')"
H9BFA1E21C4F4: "오른쪽 각괄호와 등호 사이에 공백이 필요합니다 ( '> = '를 사용하세요)"
# "a space is required between consecutive right angle brackets (use '> >')"
H529B67153B9E: "연속된 오른쪽 각 대괄호 사이에는 공백이 필요합니다( '> >'를 사용하세요)"
# 'a static lambda cannot have any captures'
H2E5388A18076: '정적 람다는 어떤 캡처도 가질 수 없습니다'
# 'a static_assert declaration cannot be a template'
HA1124669302F: 'static_assert 선언은 템플릿일 수 없습니다'
# 'a template argument list is expected after a name prefixed by the template keyword'
HF4A21ADFAB4E: '템플릿 키워드로 시작된 이름 뒤에는 템플릿 인수 목록이 필요합니다'
# 'a type named %0 is hidden by a declaration in a different namespace'
H26CC1C864C4C: '이름이 %0인 타입은 다른 네임스페이스의 선언에 의해 숨겨졌습니다'
# 'a type specifier is required for all declarations'
HA2239D7DA67E: '모든 선언에는 타입 지정자가 필요합니다'
# 'a typedef cannot be a template'
H878607247E5C: 'typedef는 템플릿이 될 수 없습니다'
# 'absolute value function %0 given an argument of type %1 but has parameter of type %2 which may cause truncation of value'
H2B4AC1EEC989: '절대값 함수 %0에 %1 형식의 인수가 전달되었지만 %2 형식의 매개변수가 있어 값의 절삭이 발생할 수 있습니다'
# "abstract class is marked '%select{final|sealed}0'"
H9546D737D23E: "추상 클래스가 '%select{final|sealed}0'로 표시되었습니다."
# 'access declarations are deprecated; use using declarations instead'
H3431BA5113E5: '액세스 선언은 더 이상 권장되지 않습니다; using 선언을 대신 사용하십시오'
# 'access qualifier %0 cannot be used for %1 %select{|prior to OpenCL C version 2.0 or in version 3.0 and without __opencl_c_read_write_images feature}2'
HC43552CB1BAC: '액세스 지정자 %0는 %1에 사용할 수 없습니다 %select{|OpenCL C 버전 2.0 이전 또는 버전 3.0에서 __opencl_c_read_write_images 기능이 없을 경우}2'
# 'access qualifier can only be used for pipe and image type'
HCF9598AD42BA: '액세스 수식어는 파이프 및 이미지 유형에서만 사용할 수 있습니다'
# 'access specifier can only have annotation attributes'
H00A8BDFCED49: '접근 지정자는 주석 어트리뷰트만 가질 수 있습니다.'
# 'access specifiers are a clang HLSL extension'
H23D01BBD184F: '액세스 지정자는 Clang HLSL 확장 기능입니다.'
# 'accessing a member of an atomic structure or union is undefined behavior'
H1C0790EC0EC6: '원자적 구조체 또는 공용体型의 멤버에 접근하는 것은 정의되지 않은 동작입니다'
# 'accessing inaccessible direct base %0 of %1 is a Microsoft extension'
H76AFA5796E64: '클래스 %1의 접근할 수 없는 직접 기반 클래스 %0에 접근하는 것은 Microsoft 확장 기능입니다'
# "acquiring %0 '%1' requires negative capability '%2'"
HC095E2CF1B84: "%0 '%1'을(를) 획득하기 위해 부정 능력 '%2'가 필요합니다"
# "acquiring %0 '%1' that is already held"
H4DA573668147: "획득하려는 %0 '%1'이 이미 획득된 상태입니다"
# 'action %0 not compiled in'
HA82E8BAC3ED2: '동작 %0는 컴파일되지 않았습니다'
# "active '%0' clause defined here"
H5264E053D9D8: "활성 '%0' 절이 여기서 정의되었습니다"
# 'add \'__arm_preserves("za")\' to the callee if it preserves ZA'
HD939B5A83F36: 'ZA를 보존하는 경우 호출받는 함수에 \'__arm_preserves("za")\'를 추가하십시오'
# "add 'constexpr'"
H48500D7C1CF8: '‘constexpr’을 추가합니다'
# "add 'export' here if this is intended to be a module interface unit"
H8499B2C3202C: "이 부분에 'export'를 추가해야 합니다(이 파일이 모듈 인터페이스 단위를 의미하는 경우)"
# "add 'module;' to the start of the file to introduce a global module fragment"
H1399A9153C66: "파일의 시작 부분에 'module;'을 추가하여 전역 모듈 조각을 도입하십시오"
# "add 'typename' to treat this using declaration as a type"
H2514B140BEE5: 'typename을 추가하여 이 using 선언을 타입으로 처리하려면'
# "add 'u8' prefix to form a 'char8_t' string literal"
H8C73CF0B8333: "'u8' 접두사를 추가하여 'char8_t' 문자열 리터럴을 형성하세요"
# "add 'void' to the parameter list to turn an old-style K&R function declaration into a prototype"
H460C61046151: "매개변수 목록에 'void'를 추가하여 K&R 스타일의 오래된 함수 선언을 프로토타입으로 전환하려면"
# "add a '@synthesize' directive"
H11A117C94448: '‘@synthesize’ 지시문을 추가하십시오'
# 'add a deduction guide to suppress this warning'
H4B93D4018373: '추론 가이드를 추가하여 이 경고를 숨기십시오'
# 'add a deprecation attribute to the declaration to silence this warning'
HE29FCC14DCE0: '이 경고를 무시하려면 이 선언에 비추천 특성을 추가하십시오.'
# 'add a pair of parentheses to declare a variable'
H9B65CA134C28: '변수를 선언하려면 괄호 쌍을 추가하세요'
# 'add a super class to fix this problem'
HD3A4A44147E8: '초 클래스를 추가하여 이 문제를 수정하십시오'
# 'add a variable name to declare a %0 initialized with %1'
HBF079F80BA92: '변수 이름을 %0 타입으로 %1로 초기화하여 선언하려면 변수 이름을 추가하세요'
# "add an explicit capture of 'this' to capture '*this' by reference"
H44758706CE87: '‘*this’를 참조로 캡처하려면 ‘this’를 명시적으로 캡처해야 합니다.'
# 'add an explicit instantiation declaration to suppress this warning if %q0 is explicitly instantiated in another translation unit'
HA69020D4B8A0: '다른 번역 단위에서 %q0를 명시적으로 인스턴스화하는 경우 이 경고를 억제하려면 명시적 인스턴스화 선언을 추가하세요'
# 'add any string to tag this execution in the output binary via bolt info section'
HF4F001FFA024: 'bolt 정보 섹션을 통해 출력 이진 파일에 이 실행을 태그하기 위해 문자열을 추가하세요'
# 'add basic block instructions as tool tips on nodes'
H4A2F65627544: '노드에 기본 블록 지시문을 툴팁으로 추가합니다'
# 'add enclosing parentheses to perform a function-style cast'
H3C4C77285B3F: '함수 스타일 캐스트를 수행하려면 포함하는 괄호를 추가하세요'
# 'add explicit braces to avoid dangling else'
H912E67080844: '명시적인 중괄호를 추가하여 의존 없는 else를 피하세요'
# 'add masking cost for i1 vectors'
H3E72A2897B81: 'i1 벡터에 마스킹 비용 추가'
# "add parentheses after the '!' to evaluate the %select{comparison|bitwise operator}0 first"
H7D8E708D64E0: "'!' 뒤에 괄호를 추가하여 %select{비교|비트 연산자}0를 먼저 평가하십시오."
# 'add parentheses around left hand side expression to silence this warning'
HB1B6850C2A11: '왼쪽 표현식 주위에 괄호를 추가하여 이 경고를 없애려면'
# "add the %select{'require_constant_initialization' attribute|'constinit' specifier}0 to the initializing declaration here"
HFE1D4C8144BF: "여기 초기화 선언에 %select{'require_constant_initialization' attribute|'constinit' specifier}0 을 추가해 주세요"
# 'adding %0 to %1 might cause circular dependency in container'
H157957572465: '%0을 %1에 추가하면 컨테이너에서 순환 종속성이 발생할 수 있습니다.'
# 'adding %0 to a string does not append to the string'
H98175222693E: '문자열에 %0을 추가하면 문자열에 연결되지 않습니다'
# 'adding %0 to a string pointer does not append to the string'
HE53429791B46: '문자열 포인터에 %0을 더하더라도 문자열에 추가하지 않습니다'
# 'addition of default argument on redeclaration makes this constructor a %select{default|copy|move}0 constructor'
H540EC7EBFA01: '재선언에서 기본 인수를 추가하면 이 생성자가 %select{기본|복사|이동}0 생성자가 됩니다.'
# 'address argument to %select{atomic|__sync}0 operation must be a pointer to a non address discriminated type (%1 invalid)'
H2613F565B379: '%select{atomic|__sync}0 연산의 address 인수는 주소 구분 유형이 아닌 포인터여야 합니다 (%1이 유효하지 않음)'
# 'address argument to atomic builtin cannot be const-qualified (%0 invalid)'
H05DD72B70C0D: '원자적 내장 함수의 주소 인수는 const-qualified로 지정될 수 없습니다 (%0 유효하지 않음)'
# 'address argument to atomic builtin must be a pointer %select{|to a non-zero-sized object }1(%0 invalid)'
H25FC8322E786: '원자 내장 함수의 주소 인수는 포인터%select{|가 크기가 영이 아닌 객체를 가리켜야 합니다 }1(%0이(가) 무효입니다)'
# 'address argument to atomic builtin must be a pointer to 1,2,4,8 or 16 byte type (%0 invalid)'
H8F0926664FBC: '원자 내장 함수의 주소 인수는 1, 2, 4, 8 또는 16바이트 유형으로 가리키는 포인터여야 합니다 (%0 무효)'
# 'address argument to atomic builtin must be a pointer to integer or pointer (%0 invalid)'
H05518FC9E223: '어트وم닉 내장 함수의 주소 인수는 정수 또는 포인터를 가리키는 포인터여야 합니다. (%0이/가 무효합니다)'
# 'address argument to atomic builtin must be a pointer to integer, floating-point or pointer (%0 invalid)'
H4BE1CF542714: '원자형 내장 함수의 주소 인수는 정수, 부동 소수점 또는 포인터 타입의 포인터여야 합니다. (%0이/가 유효하지 않음)'
# 'address argument to atomic operation must be a pointer to %select{|atomic }0integer (%1 invalid)'
H45F0D7833F1F: '어토믹 연산의 주소 인수는 %select{|atomic }0정수 포인터여야 합니다 (%1 유효하지 않음)'
# 'address argument to atomic operation must be a pointer to %select{|atomic }0integer or pointer (%1 invalid)'
HD792403A7931: '원자 연산에 대한 주소 인수는 %select{|원자적 }0정수형 또는 포인터 타입의 포인터여야 합니다 (%1 무효)'
# 'address argument to atomic operation must be a pointer to %select{|atomic }0integer or supported floating point type (%1 invalid)'
H645D002EEC1B: '원자 연산의 주소 인수는 %select{|원자 }0정수형 또는 지원되는 부동 소수점 형식의 포인터여야 합니다 (%1이(가) 유효하지 않습니다)'
# 'address argument to atomic operation must be a pointer to %select{|atomic }0integer, pointer or supported floating point type (%1 invalid)'
HF8B6B0144FE9: '원자 연산의 주소 인수는 %select{|atomic }0정수, 포인터 또는 지원하는 부동 소수점 형식 포인터여야 합니다. (%1 잘못됨)'
# 'address argument to atomic operation must be a pointer to _Atomic type (%0 invalid)'
HED971913A5AB: '원자 연산의 주소 인수는 _Atomic 타입 포인터여야 합니다 (%0 무효)'
# 'address argument to atomic operation must be a pointer to a trivially-copyable type (%0 invalid)'
H0F2B276FBFF5: '원자 연산의 주소 인수는 trivially-copyable 타입 포인터여야 합니다. (%0이 유효하지 않음)'
# 'address argument to atomic operation must be a pointer to non-%select{const|constant}0 _Atomic type (%1 invalid)'
H77D9C30AD097: '원자 연산의 주소 인수는 비-%select{const|constant}0 _Atomic 형식 포인터여야 합니다 (%1 유효하지 않음)'
# 'address argument to atomic operation must be a pointer to non-const type (%0 invalid)'
HA961ACF648B8: '원자 연산의 주소 인수는 const가 아닌 타입의 포인터여야 합니다. (%0이 유효하지 않음)'
# 'address argument to load or store exclusive builtin must be a pointer to 1,2,4 or 8 byte type (%0 invalid)'
H7473631C7DCE: '배타적 내장 함수 로드 또는 스토어의 주소 인수는 1, 2, 4 또는 8 바이트 형식의 포인터여야 합니다 (%0 무효)'
# 'address argument to nontemporal builtin must be a pointer (%0 invalid)'
H15C0E2A98779: 'nontemporal 내장 함수의 address 인수는 포인터여야 합니다. (%0 유효하지 않음)'
# 'address argument to nontemporal builtin must be a pointer to integer, float, pointer, or a vector of such types (%0 invalid)'
H411242986562: 'nontemporal builtin의 address 인수는 정수, 부동소수점, 포인터, 또는 이러한 유형의 벡터를 가리키는 포인터여야 합니다 (%0이 유효하지 않습니다)'
# "address of %select{'%1'|function '%1'|array '%1'|lambda function pointer conversion operator}0 will always evaluate to 'true'"
H17F3EBE2635E: "주소가 %select{'%1'|함수 '%1'|배열 '%1'|람다 함수 포인터 변환 연산자}0인 값은 항상 'true'로 평가됩니다"
# 'address of %select{bit-field|vector element|property expression|register variable|matrix element}0 requested'
HD8B1334D046A: '0이 선택된 %select{비트 필드|벡터 요소|속성 표현식|레지스터 변수|행렬 요소}0의 주소가 요청되었습니다'
# "address of non-static constexpr variable %0 may differ on each invocation of the enclosing function; add 'static' to give it a constant address"
HE51DD27041F6: "비정적 constexpr 변수 %0의 주소는 포함하는 함수가 각각 호출될 때마다 다를 수 있습니다; 'static'을 추가하여 상수 주소를 줄 수 있습니다"
# 'address of overloaded function %0 cannot be cast to type %1'
H358904EBF6FD: '오버로드된 함수 %0의 주소는 %1 타입으로 캐스팅할 수 없습니다'
# 'address of overloaded function %0 cannot be converted to type %1'
HCCA08BC04209: '오버로드된 함수 %0의 주소는 형식 %1로 변환될 수 없습니다'
# 'address of overloaded function %0 cannot be static_cast to type %1'
HE4591559B0BB: '오버로드된 함수 %0의 주소를 %1 형으로 static_cast할 수 없습니다'
# 'address of overloaded function %0 does not match required type %1'
H11264D1F1C79: '오버로드된 함수 %0의 주소는 필요한 형식 %1과 일치하지 않습니다'
# 'address of overloaded function %0 is ambiguous'
H33C49268724E: '오버로드된 함수 %0의 주소를 정확히 결정할 수 없습니다'
# 'address space is larger than the maximum supported (%0)'
HFA6456E815BE: '주소 공간이 지원되는 최대 크기(%0)보다 큽니다.'
# 'address space is negative'
H7DA3DAA44B98: '주소 공간이 음수입니다'
# 'address taken in non-type template argument for template parameter of reference type %0'
HD465BC48688F: '참조 형식의 템플릿 매개변수에 대한 비형식 템플릿 인자에서 주소가 취해졌습니다 %0'
# 'address-of operator cannot be applied to a call to a function with unknown return type'
HA9D761CAF77E: '& 연산자는 알 수 없는 반환 형식을 갖는 함수의 호출에 적용할 수 없습니다'
# 'adjust block counts based on outgoing branch counts'
H117EF7587146: '출구 분기 횟수에 따라 블록 카운트 조정'
# 'adjust function counts based on basic blocks execution count'
H14DEF224A29B: '기본 블록 실행 횟수에 기반하여 함수 카운트 조정'
# 'adjust function profile after inlining'
HDCFC372259BA: '인라인 후 함수 프로필 조정'
# "after modifying system headers, please delete the module cache at '%0'"
H01FFB29D96B3: "시스템 헤더를 수정한 후에는 '%0' 위치의 모듈 캐시를 삭제해 주세요"
# 'aggregate basic samples (without LBR info)'
H9B9419C851BC: '기본 샘플 집계 (LBR 정보 없음)'
# 'aggregate initialization of type %0 from a parenthesized list of values is a C++20 extension'
H6B5CF381E65A: '형 %0의 집합체 초기화를 괄호로 감싼 값 목록에서 하는 것은 C++20의 확장 기능입니다'
# 'aggregate initialization of type %0 with user-declared constructors is incompatible with C++20'
HC24621DDDD5F: '사용자 선언된 생성자가 있는 %0 형식의 집합체 초기화는 C++20과 호환되지 않습니다'
# 'aggressive strategy'
H5CB7E66C0F79: '공격적인 전략'
# 'aggressively inline everything'
HF506129362A1: '극단적으로 모든 것을 인라인 처리합니다'
# 'aggressively split jump tables section based on usage of the tables'
HF15D48A1547F: '테이블의 사용량에 따라 점프 테이블 섹션을 강하게 분할'
# 'algorithm used to reorder data sections'
H5E8D0AEA074C: '데이터 섹션 재정렬에 사용되는 알고리즘'
# 'alias declaration cannot be a pack expansion'
H7E12EB8475DC: 'алиас 선언은 패키지 확장일 수 없습니다'
# 'alias declaration in this context is a C++23 extension'
H91EDBE36B117: '이 컨텍스트에서의 alias 선언은 C++23 확장 기능입니다'
# 'alias declaration in this context is incompatible with C++ standards before C++23'
HC4280923DB99: '이 맥락에서의 alias 선언은 C++23 이전 C++ 표준과 호환되지 않습니다'
# 'alias declarations are a C++11 extension'
HE9649A76CF28: '별칭 선언은 C++11 확장 기능입니다.'
# 'alias declarations are incompatible with C++98'
H47305448BB21: '별칭 선언문은 C++98과 호환되지 않습니다'
# 'alias definition of %0 after tentative definition'
HBC2E292F4F78: '%0의 alias 정의가 잠정 정의 이후에 있습니다.'
# 'alias for --icp-jump-tables-targets'
H3295D8EF4BCC: '--icp-jump-tables-targets의 별칭입니다'
# 'alias for --indirect-call-promotion-calls-topn'
H056F07540EAC: '--indirect-call-promotion-calls-topn의 별칭'
# 'alias for --indirect-call-promotion-jump-tables-topn'
H48FD0DD2A352: '의 별칭: --indirect-call-promotion-jump-tables-topn'
# 'alias for --indirect-call-promotion-mispredict-threshold'
H69D659FF6417: '--indirect-call-promotion-mispredict-threshold 옵션의 별칭'
# 'alias for --indirect-call-promotion-topn'
H2CDF1F6846ED: '--indirect-call-promotion-topn의 별칭'
# 'alias for --indirect-call-promotion-use-mispredicts'
H6632963673FD: '미스프리딕션 사용을 위한 간접 호출 증폭 옵션의 별칭'
# 'alias for -aarch64-streaming-hazard-size'
H6DD0A61F8614: '무효한 값 %d가 -aarch64-sve2-groupbitmask 옵션에 지정되었습니다. 허용되는 값은 0 또는 1..8입니다'
# 'alias for -data'
H18AAC29B91E1: '데이터 옵션의 별칭'
# 'alias for -instr_map'
H8C404A340D69: '특정 옵션의 별칭'
# 'alias for -perfdata'
H4AA3F61C654A: '-perfdata의 별칭'
# 'alias for -symbolize'
HF105886B4E32: '-symbolize 옵션의 별칭'
# 'alias to a variable in a common section is not allowed'
H93F6002973E0: '커먼 섹션에 있는 변수의 별칭은 허용되지 않습니다'
# 'aliases are not supported on darwin'
H41CBE942EE33: 'aliases는 Darwin에서 지원되지 않습니다'
# 'align basic blocks'
H546676202A2D: '기본 블록 정렬'
# 'align functions at a given value (relocation mode)'
HA06778A68136: '지정된 값에서 함수 정렬 (재정렬 모드)'
# 'align only blocks with frequency larger than containing function execution frequency specified in percent. E.g. 1000 means aligning blocks that are 10 times more frequently executed than the containing function.'
H9CD01CD0B966: '지정된 백분율보다 포함된 함수 실행 빈도보다 높은 빈도를 가진 블록만 정렬합니다. 예를 들어, 1000은 포함된 함수보다 10배 더 자주 실행되는 블록을 정렬한다는 의미입니다.'
# "aligned %select{allocation|deallocation}0 function of type '%1' is %select{only|not}4 available on %2%select{ %3 or newer|}4"
H9703DDF7875E: "정렬된 %select{할당|할당 해제}0 함수 타입 '%1'은 %2%select{ %3 또는 더 새로운 버전에서만|}4 %select{오직|아니라}4 사용 가능합니다."
# 'aligned clause will be ignored because the requested alignment is not a power of 2'
HC3A503B9038C: '요청된 alignment가 2의 거듭제곱이 아니기 때문에 aligned 절이 무시됩니다'
# 'alignment (%0) of thread-local variable %1 is greater than the maximum supported alignment (%2) for a thread-local variable on this target'
H9951DC0F93CA: 'thread-local 변수 %1의 정렬(%0)은 이 타겟에서 thread-local 변수에 대한 지원되는 최대 정렬(%2)보다 큽니다'
# "alignment is not a power of 2 in '%0'"
HB7B2FF437212: "정렬이 2의 거듭제곱이 아닙니다: '%0'"
# 'alignment of .text section'
H7D89ABD80F0F: '텍스트 섹션의 정렬'
# 'alignment of 16 bytes for a struct member is not binary compatible with IBM XL C/C++ for AIX 16.1.0 or older'
H79A5A88D17D7: '16바이트 정렬은 IBM XL C/C++ for AIX 16.1.0 또는 이전 버전과 구조체 멤버에 대한 바이너리 호환을 지원하지 않습니다'
# 'alignof expressions are incompatible with C++98'
H5F21C338A420: 'alignof 표현식은 C++98과 호환되지 않습니다'
# 'all paths through this function will call itself'
H40E0BDFB048F: '이 함수를 거치는 모든 경로는 자신을 호출합니다'
# "allocate directive specifies %select{default|'%1'}0 allocator while previously used %select{default|'%3'}2"
HC639234B285B: '할당 지시문은 %select{기본|%1}0 할당기를 지정했습니다 이전에 사용된 %select{기본|%3}2와 충돌합니다'
# 'allocated size %0 is not a multiple of size %1 of element type %2'
H279696362CDE: '할당된 크기 %0은 요소 유형 %2의 크기 %1의 배수가 아닙니다'
# "allocated with 'new%select{[]|}0' here"
H1AA44259E5AA: "여기서 'new%select{[]|}0'로 할당되었습니다"
# 'allocating an object of abstract class type %0'
H07CDBA71F9A5: '추상 클래스 형식의 %0 객체를 할당 중입니다'
# 'allocation of %select{incomplete|sizeless}0 type %1'
HD40A80B2E772: '할당 %select{미완성|사이즈 없는}0 타입 %1'
# 'allocation performed here was not deallocated%plural{0:|: (along with %0 other memory leak%s0)}0'
H04A2F923450C: '이 곳에서 수행된 할당이 해제되지 않았습니다%plural{0:|: (또 다른 %0 메모리 누수%s0과 함께)}0'
# "allocator must be specified in the 'uses_allocators' clause"
H6A6EDC2E2834: "allocator는 'uses_allocators' 절에서 지정되어야 합니다"
# "allocator with the 'thread' trait access has unspecified behavior on '%0' directive"
HDC686C65C1AA: "스레드 트래이트 접근을 가진 할당기는 '%0' 지시문에서 명시되지 않은 동작을 합니다"
# "allocators used in 'uses_allocators' clause cannot appear in other data-sharing or data-mapping attribute clauses"
H3D9F65EE1204: "'uses_allocators' 절에서 사용된 할당기들은 다른 데이터 공유 또는 데이터 매핑 속성 절에 나타날 수 없습니다"
# 'allow processing of stripped binaries'
H7C4A1D362E89: '스트립된 바이너리 처리를 허용합니다'
# 'allow to snippet generator to generate at most that many configs'
H8A45202314E0: '스니펫 생성기가 최대 그 수만큼의 설정을 생성할 수 있도록 허용'
# "allowable client missing from %0: '%1'"
H1792F22F4481: "허용되는 클라이언트가 %0에서 누락됨: '%1'"
# "allowable clients do not match: '%0' (provided) vs '%1' (found)"
H73C7C1046F8D: "허용되는 클라이언트가 일치하지 않습니다: '%0' (제공됨) vs '%1' (발견됨)"
# "already inside '#pragma clang arc_cf_code_audited'"
H490BE327E34C: "이미 '#pragma clang arc_cf_code_audited' 내부에 있습니다"
# "already inside '#pragma clang assume_nonnull'"
H59F0A861C85D: "이미 '#pragma clang assume_nonnull' 안에 있습니다"
# "already inside '#pragma unsafe_buffer_usage'"
H94EE60235FE3: "이미 '#pragma unsafe_buffer_usage' 안에 있습니다."
# 'also accessed here'
H4EBEB7641C26: '여기서도 참조되었습니다'
# 'also found'
HAE6F7F952B68: '또 찾음'
# 'always apply unchecked-ld-st'
HA7AE478F69D8: '항상 unchecked-ld-st 적용'
# 'always perform sctc'
H55817EEE47EB: '항상 sctc 수행'
# 'always replace exit value whenever possible'
H0EF1BA8B58B0: '항상 가능할 때마다 종료 값을 대체합니다'
# 'always use long jumps/nops for Linux kernel static keys'
H61DBDABC6D73: 'Linux 커널 정적 키(static keys)를 위해 항상 long jumps/nops를 사용하십시오'
# 'always_inline function %0 has new za state'
H42D69F5E4613: 'always_inline 함수 %0에 새로운 za 상태가 있습니다'
# 'always_inline function %0 has new zt0 state'
HC0C33866F167: 'always_inline 함수 %0가 새로운 zt0 상태를 갖습니다'
# 'always_inline function %1 and its caller %0 have mismatching %2 attributes'
H623539F9CF4D: 'always_inline 함수 %1와 그 호출자 %0는 %2 어트리뷰트가 일치하지 않습니다'
# 'always_inline function %1 and its caller %0 have mismatching %2 attributes, inlining may change runtime behaviour'
H784367C8E6F8: '항상 인라인 함수 %1과 그 호출자 %0의 %2 속성이 일치하지 않습니다, 인라인은 런타임 동작을 변경할 수 있습니다'
# "always_inline function %1 requires target feature '%2', but would be inlined into function %0 that is compiled without support for '%2'"
H6E58755C709F: "always_inline 함수 %1은 대상 기능 '%2'를 요구하지만, '%2'를 지원하지 않는 함수 %0에 인라인될 것입니다"
# 'ambiguity is between a regular call to this operator and a call with the argument order reversed'
H5C4216FCB55D: '이 연산자의 일반적인 호출과 인수 순서가 뒤바뀐 호출 사이에 모호성이 있습니다'
# 'ambiguous candidate function with reversed arguments'
H1A80B7778D2B: '분명하지 않은 후보 함수와 뒤바뀐 인수'
# 'ambiguous cast from base %0 to derived %1:%2'
H7F294DF4B6DC: '기반 %0에서 파생 %1로의 애매모호한 캐스트:%2'
# 'ambiguous constructor call when %select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1'
H33854A224B06: '타입 %1의 %select{변수 복사|파라미터 복사|템플릿 파라미터 초기화|객체 반환|문장 표현식 결과 초기화|예외 객체 던지기|멤버 하위 객체 복사|배열 요소 복사|객체 할당|임시 객체 복사|기반 하위 객체 초기화|벡터 요소 초기화|값 캡처}0 시 생성자 호출이 애매합니다'
# 'ambiguous conversion for %select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2'
H1B069BDA73DD: '모호한 변환: %select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0에서 %1에서 %2로의 변환'
# 'ambiguous conversion from derived class %0 to base class %1:%2'
H64259C430314: '파생 클래스 %0에서 기반 클래스 %1로의 모호한 변환:%2'
# 'ambiguous conversion from pointer to member of %select{base|derived}0 class %1 to pointer to member of %select{derived|base}0 class %2:%3'
H3B96453BA992: '클래스 %select{기반|파생}0의 멤버 포인터 %1에서 클래스 %select{파생|기반}0의 멤버 포인터 %2로의 변환이 모호합니다: %3'
# 'ambiguous conversion from type %0 to an integral or unscoped enumeration type'
H78D40490F0F2: '형 %0에서 정수형 또는 비 스코프 열거형 타입으로의 모호한 변환'
# 'ambiguous conversion of array size expression of type %0 to an integral or enumeration type'
H568A4E6CFAC2: '배열 크기 표현식의 유형 %0을 정수형 또는 열거형 유형으로의 변환이 모호합니다'
# 'ambiguous conversion of delete expression of type %0 to a pointer'
HCF8DE9DD6D85: '유형 %0의 delete 표현식을 포인터로 변환하는 것이 모호합니다'
# 'ambiguous deduction for template arguments of %0'
HE14C8899D7D7: '템플릿 인수 %0에 대한 모호한 추론'
# 'ambiguous expansion of macro %0'
H401A5AED8233: '매크로 %0의 애매한 확장'
# "ambiguous marker '%0' is defined here"
HF269BA6422ED: "정의가 모호한 마커 '%0'는 여기서 정의되었습니다"
# 'ambiguous member function specialization %q0 of %q1'
H6A3405722F76: '중복된 멤버 함수 특수화 %q0의 %q1'
# 'ambiguous partial specializations of %0'
HDEE2005B7D3C: '모호한 %0의 부분 특수화'
# "ambiguous reference to placeholder '_', which is defined multiple times"
HBD26597B24D2: "플레이스홀더 '_'가 여러 번 정의되어 애매한 참조가 발생했습니다"
# 'ambiguous use of internal linkage declaration %0 defined in multiple modules'
HE31133550012: '내부 링크지 선언 %0가 여러 모듈에서 정의되어 모호하게 사용되었습니다.'
# 'ambiguous vftable component for %0 introduced via covariant thunks; this is an inherent limitation of the ABI'
HB0361B37BEF3: 'covariant thunks를 통해 도입된 %0에 대한 불명확한 vftable 성분; 이는 ABI의 고유한 한계입니다'
# 'an array type is not allowed here'
HCA0201F3FA96: '여기에는 배열 형식이 허용되지 않습니다'
# 'an attribute list cannot appear here'
H49F3FA1B7ED5: '속성 목록은 여기에 사용될 수 없습니다'
# 'an attribute specifier sequence attached to a structured binding declaration is a C++2c extension'
H9EBA62889A30: '구조화된 바인딩 선언에 연결된 특성 지정자 시퀀스는 C++2c 확장입니다'
# 'an attribute specifier sequence attached to a structured binding declaration is incompatible with C++ standards before C++2c'
H3AB5357520EE: '구조화된 바인딩 선언에 부착된 속성 지정자 시퀀스는 C++2c 이전의 C++ 표준과 호환되지 않습니다'
# 'an explicit object parameter can only appear as the first parameter of a member function'
HB251EBFE2CF5: '명시적 객체 매개변수는 멤버 함수의 첫 번째 매개변수로만 나타날 수 있습니다'
# 'an explicit object parameter can only appear as the first parameter of the %select{function|lambda}0'
H7FA58E3ABF3F: '명시적 객체 매개변수는 %select{함수|lambda}0의 첫 번째 매개변수로만 나타날 수 있습니다'
# 'an explicit object parameter cannot appear in a %select{constructor|destructor}0'
H75A07B3C23F5: 'explicit 객체 매개변수는 %select{생성자|소멸자}0에 존재할 수 없습니다'
# 'an explicit object parameter cannot appear in a %select{static|virtual|non-member}0 %select{function|lambda}1'
HF679F4DDA00F: '명시적 객체 매개변수는 %select{정적|가상|비멤버}0 %select{함수|람다}1에 나타날 수 없습니다'
# "an explicitly-defaulted %select{copy|move}0 assignment operator may not have 'const'%select{, 'constexpr'|}1 or 'volatile' qualifiers"
HC61798127DDC: "명시적으로 기본화된 %select{copy|move}0 할당 연산자는 'const'%select{, 'constexpr'|}1 또는 'volatile' 자격 증명을 가질 수 없습니다"
# 'an explicitly-defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot be variadic'
HE8693CE23671: '명시적으로 기본화된 %select{기본 생성자|복사 생성자|이동 생성자|복사 할당 연산자|이동 할당 연산자|소멸자}0는 가변 인자 형식일 수 없습니다'
# 'an explicitly-defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot have default arguments'
H41B0D6AF186A: '명시적으로 기본값 지정된 %select{디폴트 생성자|복사 생성자|이동 생성자|복사 할당 연산자|이동 할당 연산자|소멸자}0은 기본 인수를 가질 수 없습니다'
# 'an initializer for a delegating constructor must appear alone'
H5506BF1F155E: '대리 생성자의 초기화자는 단독으로 출현해야 합니다'
# 'an inline asm block cannot have an operand which is a bit-field'
HD4AB7ACF49E9: '인라인 어셈블리 블록에는 비트필드로 된 피연산자를 가질 수 없습니다.'
# 'an unevaluated string literal cannot be a user-defined literal'
H7294D821E112: '평가되지 않은 문자열 리터럴은 사용자 정의 리터럴이 될 수 없습니다.'
# 'an unevaluated string literal cannot have an encoding prefix'
HFC8ECFF25368: '평가되지 않은 문자열 리터럴에는 인코딩 접두사가 있을 수 없습니다.'
# "analyzer constraint manager 'z3' is only available if LLVM was built with -DLLVM_ENABLE_Z3_SOLVER=ON"
H156EC948497C: "분석기 제약 관리자 'z3'는 LLVM을 -DLLVM_ENABLE_Z3_SOLVER=ON 옵션으로 빌드했을 때만 사용할 수 있습니다."
# "analyzer-config option '%0' has a key but no value"
H5FB74FAA9043: "분석기 구성 옵션 '%0'에는 키가 있지만 값이 없습니다"
# "analyzer-config option '%0' should contain only one '='"
HC4A2A9D28ED1: "analyzer-config 옵션 '%0'에는 =가 하나만 포함되어야 합니다."
# 'angle brackets contain both a %select{type|protocol}0 (%1) and a %select{protocol|type}0 (%2)'
H6C951E1E776A: '각도기호에는 %select{type|protocol}0 (%1)과 %select{protocol|type}0 (%2)를 모두 포함하고 있습니다'
# 'angle-bracketed include <%0> cannot be aliased to double-quoted include "%1"'
H6DC7B4C3CA94: '각도 괄호로 감싼 include <%0>는 쌍따옴표로 감싼 include "%1"로 대체될 수 없습니다'
# 'annotate %select{%1|anonymous %1}0 with an availability attribute to silence this warning'
H1B283AC48C5C: '이 경고를 제거하려면 %select{%1|익명의 %1}0을(를) 사용 가능 여부 특성으로 어노테이션 하세요'
# "annotating the 'if %select{constexpr|consteval}0' statement here"
HE2CC6E318B60: "여기에서 'if %select{constexpr|consteval}0' 문에 주석을 추가합니다"
# 'annotating the infinite loop here'
H4CC614D1531D: '이 무한 루프를 여기에 표시합니다'
# 'annotation-type remark to collect count for'
HF59035A1D641: 'annotation-type 참고 카운트 수집을 위한'
# 'anonymous %select{structs|structs and classes}0 must be %select{struct or union|class}0 members'
HFBD532892EC0: '익명 %select{구조体型|구조体型과 클래스}0은 %select{struct 또는 union|class}0의 멤버여야 합니다'
# 'anonymous %select{structs|unions}0 are a Microsoft extension'
HFF401250AB40: '익명의 %select{구조체|공용体型}0는 Microsoft의 확장 기능입니다'
# 'anonymous %select{struct|union}0 can only contain non-static data members'
H31B46249C247: '익명 %select{struct|union}0는 정적 멤버가 아닌 데이터 멤버만 포함할 수 있습니다'
# "anonymous %select{struct|union}0 cannot be '%1'"
HF58A2EC09112: "익명의 %select{struct|union}0은 '%1'일 수 없습니다."
# 'anonymous %select{struct|union}0 cannot contain a %select{private|protected}1 data member'
HA1E08BDB3E65: '익명 %select{struct|union}0은 %select{private|protected}1 데이터 멤버를 포함할 수 없습니다'
# 'anonymous bit-field cannot have a default member initializer'
H71090C776F50: '익명 비트필드는 기본 멤버 초기화자를 가질 수 없습니다.'
# 'anonymous bit-field cannot have qualifiers'
H6D3AB87CE804: '익명 비트필드는 자격 증명자를 가질 수 없습니다.'
# 'anonymous bit-field has negative width (%0)'
HFC2DC27C32DA: '이름 없는 비트 필드는 음수 너비(%0)를 가집니다'
# 'anonymous bit-field has non-integral type %0'
HCAEF6F6FBF6D: '익명 비트 필드가 정수형이 아닌 타입 %0을 가집니다'
# 'anonymous namespace begins here'
H131F22F8B917: '익명 네임스페이스가 여기서 시작됩니다'
# 'anonymous namespaces cannot be exported'
HD9CECEFAA4C6: '익명 네임스페이스는 내보낼 수 없습니다'
# 'anonymous non-C-compatible type given name for linkage purposes by %select{typedef|alias}0 declaration after its linkage was computed; add a tag name here to establish linkage prior to definition'
H4E07DEF6B927: 'linkage가 계산된 후 %select{typedef|alias}0 선언에 의해 linkage를 위해 이름이 부여받은 익명의 C 호환되지 않는 타입입니다. 정의 전에 linkage를 설정하려면 여기에 태그 이름을 추가하십시오.'
# 'anonymous non-C-compatible type given name for linkage purposes by %select{typedef|alias}0 declaration; add a tag name here'
H5233EEEB5041: 'C와 호환되지 않는 익명 형식이 링크 목적으로 %select{typedef|alias}0 선언문에 이름이 지정되었습니다; 여기에 태그 이름을 추가하세요'
# 'anonymous property is not supported'
HBEA1F99304A4: '익명 속성은 지원되지 않습니다'
# 'anonymous structs are a C11 extension'
H1E3F733CCCB4: '익명 구조체는 C11 확장 기능입니다'
# 'anonymous structs are a GNU extension'
H006E53420443: '익명 struct는 GNU 확장 기능입니다'
# 'anonymous types declared in an anonymous %select{struct|union}0 are an extension'
H3F386C85263B: '익명 %select{struct|union}0 내에 선언된 익명 형식은 확장 기능입니다'
# 'anonymous union at class scope must not have a storage specifier'
H7518631D05B0: '클래스 범위에서의 이름 없는 union은 저장 지정자를 가질 수 없습니다'
# 'anonymous unions are a C11 extension'
HDFE9E6E6FE09: '익명 유니언은 C11 확장 기능입니다'
# "anonymous unions at namespace or global scope must be declared 'static'"
H3FE1C37A16FD: "네임스페이스나 글로벌 범위에 있는 익명 유니온은 'static'으로 선언해야 합니다"
# 'append PID to saved profile file name (default: false)'
HFDE8729E14B7: '저장된 프로파일 파일 이름에 PID를 추가 (기본값: false)'
# "application of '%select{alignof|sizeof}1' to interface %0 is not supported on this architecture and platform"
H7F7758BA5771: "인터페이스 %0에 '%select{alignof|sizeof}1'을 적용하는 것은 이 아키텍처와 플랫폼에서 지원되지 않습니다"
# 'apply additional analysis to remove stores (experimental)'
H0FDD6748AD67: '추가 분석을 적용하여 stores 제거 (실험적)'
# 'apply unchecked-ld-st when the target is definitely within range'
H75826487B47E: '목표가 확실히 범위 내에 있을 때 unchecked-ld-st 적용'
# 'applying attribute %0 to a declaration is deprecated; apply it to the type instead'
H1F568760A093: '선언에 %0 속성을 적용하는 것은 더 이상 권장되지 않습니다; 대신 타입에 적용해 주세요'
# "architecture '%0' does not support '%1' execution mode"
H341F2DD78603: "아키텍처 '%0'는 '%1' 실행 모드를 지원하지 않습니다"
# "architectures do not match: '%0' (provided) vs '%1' (found)"
H1E0CF63FB0D6: "아키텍처가 일치하지 않습니다: '%0' (제공됨) vs '%1' (검색됨)"
# 'architectures of the coverage mapping binaries'
HC4DF8B556ACB: '커버리지 매핑 바이너리의 아키텍처'
# 'argument %0 is not an unqualified class type'
H5DB23C0A38DF: '인수 %0는 자격 증명이 없는 클래스 형식이 아닙니다'
# 'argument %0 must be constant integer 1 or -1'
H4812A4DC04E0: '인자 %0는 상수 정수 1 또는 -1이어야 합니다'
# 'argument %0 of type %1 with mismatched bound'
HDE368B7DDAF1: '인수 %0의 타입 %1에 일치하지 않는 경계가 있습니다.'
# 'argument %0 to %1 must be a 2-bit unsigned literal (i.e. 0, 1, 2 or 3)'
HD2DEDD810BB8: '인수 %0에 %1은 2비트 부호 없는 리터럴이어야 합니다(즉, 0, 1, 2 또는 3)'
# "argument %0 to 'preferred_name' attribute is not a typedef for a specialization of %1"
H873B3444BA19: "인수 %0은 'preferred_name' 속성의 %1의 특수화에 대한 typedef가 아닙니다"
# 'argument %0 value should represent a contiguous bit field'
H004B84FF9E91: '인수 %0 값은 연속된 비트 필드를 나타내야 합니다'
# "argument '%0' is deprecated%select{|, use '%2' instead}1"
H549CE16A2419: "인수 '%0'은(는) 더 이상 사용되지 않습니다%select{|, '%2'를 대신 사용하세요}1"
# "argument '%0' is deprecated, %1"
HFF8BB35E32E8: "'%0' 인수는 더 이상 권장되지 않습니다, %1"
# "argument '%0' requires profile-guided optimization information"
HE99C51820EC7: "인수 '%0'는 프로파일 기반 최적화 정보가 필요합니다"
# "argument '%select{X|Y|Z}0' to numthreads attribute cannot exceed %1"
H50D13BA82E10: "numthreads 속성의 '%select{X|Y|Z}0' 인수는 %1을 초과할 수 없습니다"
# "argument '-Ofast' is deprecated; use '-O3 -ffast-math -fstack-arrays' for the same behavior, or '-O3 -fstack-arrays' to enable only conforming optimizations"
HBBD3AEA705D1: "인수 '-Ofast'는 더 이상 권장되지 않습니다. 동일한 동작을 위해서는 '-O3 -ffast-math -fstack-arrays'를 사용하거나, '-O3 -fstack-arrays'를 사용하여 단순히 준수하는 최적화만 활성화하십시오."
# "argument '-Ofast' is deprecated; use '-O3 -ffast-math' for the same behavior, or '-O3' to enable only conforming optimizations"
H9474F0404E53: "인수 '-Ofast'는 deprecated되었습니다; 동일한 동작을 원하시면 '-O3 -ffast-math'를 사용하거나, '-O3'을 사용하여 표준에 부합하는 최적화만 활성화하세요"
# "argument may not have 'void' type"
HC935448BE70B: "인수는 'void' 형식을 가질 수 없습니다"
# 'argument must be a function'
H4B920E91F120: '인수는 함수여야 합니다'
# 'argument must be a string literal%select{| of char type}0'
HE9E2C9450B76: '인수는 문자열 리터럴%select{| char 형식의}0로 되어야 합니다.'
# "argument not in expected state; expected '%0', observed '%1'"
H081944E631B6: "인수가 예상한 상태가 아닙니다; 예상된 '%0', 관측된 '%1'"
# "argument of OpenMP clause '%0' must reference the same object in all threads"
HD18A730DC43E: "OpenMP 절 '%0'의 인수는 모든 스레드에서 동일한 객체를 참조해야 합니다"
# 'argument of a linear clause should be of integral or pointer type, not %0'
HDE23CDEBD40A: '선형 절의 인수는 정수형 또는 포인터 형식이어야 합니다. %0는 허용되지 않습니다.'
# 'argument of a reduction clause of a %0 construct must not appear in a firstprivate clause on a task construct'
HE3DB6952581D: '%0 구조의 reduction 절의 인수는 task 구조의 firstprivate 절에 등장해서는 안 됩니다'
# 'argument of aligned clause should be array%select{ or pointer|, pointer, reference to array or reference to pointer}1, not %0'
H3A22487A8E2A: 'aligned 절의 인수는 배열%select{ 또는 포인터|, 포인터, 배열 참조 또는 포인터 참조}1이어야 하며, %0가 아닙니다'
# 'argument required after attribute'
HE013B38B3C7C: '속성 뒤에 인수가 필요합니다'
# 'argument sensitivity is %select{unspecified|private|public|sensitive}0, but it should be %select{unspecified|private|public|sensitive}1'
H086D890B37E5: '인수의 감도성은 %select{unspecified|private|public|sensitive}0입니다만, %select{unspecified|private|public|sensitive}1이어야 합니다'
# 'argument should be a multiple of %0'
H17E1DE63FD3F: '인수는 %0의 배수여야 합니다'
# 'argument should be a power of 2'
H41CDA1F42637: '인수는 2의 거듭제곱이어야 합니다'
# 'argument should be an 8-bit value shifted by a multiple of 8 bits'
H3C662F06BF97: '인수는 8비트 값으로 8의 배수 비트만큼 이동되어야 합니다.'
# 'argument should be an 8-bit value shifted by a multiple of 8 bits, or in the form 0x??FF'
H188AFDB4C91E: '인수는 8비트 값이 8의 배수 비트만큼 이동된 것 또는 0x??FF 형식이어야 합니다'
# 'argument should be the value 0, 90, 180 or 270'
H8AAE066502E7: '인수는 0, 90, 180 또는 270 값 중 하나여야 합니다'
# 'argument should be the value 90 or 270'
HE33BB0F80B1B: '인수는 값 90 또는 270이어야 합니다'
# 'argument to #pragma section is not valid for this target: %0'
HC2C201A8E9D6: '#pragma section의 인수가 이 타겟에 유효하지 않습니다: %0'
# 'argument to %0 must be a constant integer'
H66325C1A3398: '인수 %0는 상수 정수여야 합니다.'
# "argument to %select{'code_seg'|'section'}1 attribute is not valid for this target: %0"
H35898B1EF5C2: "특성 %select{'code_seg'|'section'}1의 인수가 이 타겟에 유효하지 않습니다: %0"
# "argument to '#pragma unroll' should not be in parentheses in CUDA C/C++"
HBE77A0717D85: "CUDA C/C++에서 '#pragma unroll'의 인수는 괄호 안에 넣지 않아야 합니다."
# "argument to '%0' clause must be a %select{non-negative|strictly positive}1 integer value"
H93740956E9C9: "클라우스 '%0'에 대한 인수는 %select{음수가 아닌|정확히 양수}1 정수 값이어야 합니다"
# "argument to '%0' clause requires a value that can be represented by a 64-bit"
H628A3A124E33: "'%0' 절의 인수는 64비트로 표현 가능한 값이어야 합니다"
# "argument to '%0' is missing (expected %1 value%s1)"
HEA17C0D34C2C: "인수 '%0'에 대한 인자가 누락됨 (예상 %1 값%s1이 필요함)"
# "argument to '__ptrauth' must be an integer constant expression"
H06E460DF36C3: '__ptrauth의 인수는 정수 상수 표현식이어야 합니다'
# "argument to 'gang' clause dimension must be %select{a constant expression|1, 2, or 3: evaluated to %1}0"
H970EFD35B5B1: 'gang 절 차원의 인수는 %select{상수 표현식|1, 2 또는 3: %1로 평가됨}0이어야 합니다'
# "argument to 'operator<=>' %select{cannot be narrowed from type %1 to %2|evaluates to %1, which cannot be narrowed to type %2}0"
HAE154D16E74A: 'operator<=>의 인수는 %select{타입 %1에서 %2로 좁혀지면 안 됩니다.|값이 %1로 평가되지만, 이는 %2로 좁혀지면 안 됩니다.}0'
# "argument to 'sizeof' in %0 call is the same pointer type %1 as the %select{destination|source}2; expected %3 or an explicit length"
H35BB4F2B1E83: "'sizeof' 연산자의 %0 호출에서 전달된 인수는 %select{목적지|소스}2와 동일한 %1 포인터 타입입니다. %3 또는 명시적인 길이가 필요합니다."
# 'argument to __builtin_longjmp must be a constant 1'
HE5F0C7B028D7: '__builtin_longjmp에 전달된 인수는 상수 1이어야 합니다'
# 'argument to __builtin_verbose_trap must %select{be a pointer to a constant string|not contain $}0'
HADE59279CC5F: '__builtin_verbose_trap 인수는 %select{상수 문자열 포인터여야 합니다| $를 포함하지 않아야 합니다}0'
# "argument to atomic builtin of type '_BitInt' is not supported"
HB64B7DD3183B: "타입 '_BitInt'의 원시 내장 함수에 대한 인수는 지원되지 않습니다"
# 'argument to ptrauth_sign_constant must refer to a global variable or function'
HC3F35A99F4A4: 'ptrauth_sign_constant의 인수는 전역 변수나 함수를 참조해야 합니다'
# "argument type %0 doesn't match specified %1 type tag %select{that requires %3|}2"
H3BF4CB740E62: '인수 형식 %0는 지정된 %1 타입 태그 %select{가 %3를 요구합니다|}2와 일치하지 않습니다'
# 'argument type %0 is incomplete'
HAB2CACB541C5: '인수 유형 %0는 완성되지 않았습니다'
# 'argument type %0 is not a real floating point type'
H00F62D550C19: '인수 유형 %0는 실수 부동소수점 유형이 아닙니다'
# "argument unused during compilation: '%0'"
HA1050D6985F0: "컴파일 중 사용되지 않은 인수: '%0'"
# 'argument value %0 is outside the valid range [%1, %2]'
HB96DE207738E: '인수 값 %0는 유효 범위 [%1, %2]를 벗어났습니다.'
# 'argument value %0 will result in undefined behaviour'
H274A3E69FEAC: '인수 값 %0는 정의되지 않은 동작을 초래합니다'
# 'arguments are of different types%diff{ ($ vs $)|}0,1'
HE1B214C1584C: '인수가 서로 다른 형식입니다%diff{ ($ vs $)|}0,1'
# "arguments of '#pragma omp %0' cannot be of reference type %1"
HF10A8B7C87FB: "'#pragma omp %0'의 인수는 참조 형식 %1일 수 없습니다."
# "arguments of '#pragma omp %0' must have %select{global storage|static storage duration}1"
H6F3268D97079: "'#pragma omp %0'의 인수는 반드시 %select{전역 저장소|정적 저장 기간}1을 가져야 합니다"
# "arguments of OpenMP clause '%0' for 'min' or 'max' must be of %select{scalar|arithmetic}1 type"
HCCCABB9B57BC: "OpenMP 절 '%0'의 min 또는 max에 사용되는 인수는 %select{스칼라|산술}1 유형이어야 합니다"
# "arguments of OpenMP clause '%0' in '#pragma omp %2' directive cannot be of variably-modified type %1"
HCB3B0D762A59: "'%0' OpenMP 절의 인수는 '#pragma omp %2' 지시문에서 변동형식 %1일 수 없습니다."
# "arguments of OpenMP clause '%0' with bitwise operators cannot be of floating type"
H7CE92A7D3184: "OpenMP 절 '%0'의 인수는 비트별 연산자를 사용할 때 부동소수점 형식일 수 없습니다"
# 'arguments to __annotation must be wide string constants'
H123CD58AB412: '__annotation의 인수는 wide 문자열 상수여야 합니다.'
# "arithmetic involving unrelated objects '%0' and '%1' has unspecified value"
H620CC2CD5C97: "관련되지 않은 객체 '%0'와 '%1'이 포함된 산술 연산은 미지정된 값을 가집니다"
# 'arithmetic on a null pointer treated as a cast from integer to pointer is a GNU extension'
HBFE8701B60FF: 'null 포인터에 대한 산술 연산을 정수에서 포인터로의 캐스트로 간주하는 것은 GNU 확장 기능입니다'
# 'arithmetic on a pointer to %select{an incomplete|sizeless}0 type %1'
H81F0120B9A69: '포인터 %select{완전하지 않은|크기 없는}0 타입 %1에 대한 산술 연산'
# 'arithmetic on addresses of potentially overlapping literals has unspecified value'
H84236342B8A2: '중첩될 수 있는 리터럴들의 주소에 대한 산술 연산은 결과 값이 미지정됩니다.'
# 'arithmetic on pointer to interface %0, which is not a constant size for this architecture and platform'
H9C9B045DAD4E: '인터페이스 %0에 대한 포인터에 산술 연산을 수행했습니다. 이는 이 아키텍처 및 플랫폼에서 고정 크기가 아닙니다.'
# 'arithmetic on%select{ a|}0 pointer%select{|s}0 to void'
H58D09A5B5E7F: 'void 형 포인터%select{|s}0%select{에|들에}0 수행된 산술 연산'
# 'arithmetic on%select{ a|}0 pointer%select{|s}0 to void is a GNU extension'
HB4BACD25A732: 'void 형 포인터%select{|s}0%select{에|들에}0 수행된 산술 연산은 GNU 확장 기능입니다'
# 'arithmetic on%select{ a|}0 pointer%select{|s}0 to%select{ the|}2 function type%select{|s}2 %1%select{| and %3}2'
H1FD9A476B84E: '산술이%select{ 한|}0 포인터%select{|}0 에 대한%select{ 해당 |}2 함수 유형%select{|}2 %1%select{| 및 %3}2 에 적용되었습니다'
# 'arithmetic on%select{ a|}0 pointer%select{|s}0 to%select{ the|}2 function type%select{|s}2 %1%select{| and %3}2 is a GNU extension'
H94DE585BA344: '산술 연산이%select{ 한|}0 포인터%select{|들}0 에 대한%select{ 의|}2 함수 타입%select{|들}2 %1%select{|와 %3}2 는 GNU 확장입니다'
# 'array %0 declared here'
HD94D934376D0: '여기에서 선언된 배열 %0'
# "array 'new' cannot have initialization arguments"
H5708CAC5AB7B: "배열 'new'에는 초기화 인수가 지정될 수 없습니다"
# 'array argument is too small; %select{contains %0 elements|is of size %0}2, callee requires at least %1'
H8A66ED6F9EE3: '배열 인수는 너무 작습니다; %select{포함하는 요소 %0|크기 %0}2, 호출 받는 함수는 적어도 %1을 필요로 합니다'
# 'array backing %select{initializer list subobject of the allocated object|the allocated initializer list}0 will be destroyed at the end of the full-expression'
H7FC8ADC3508D: '배열 기반이 %select{할당된 객체의 초기화자 목록 서브 객체|할당된 초기화자 목록}0는 전체 표현식의 끝에서 파괴될 것입니다'
# 'array bound cannot be deduced from a default member initializer'
H6E170EF5C23C: '배열 크기는 디폴트 멤버 초기화자에서 추론할 수 없습니다'
# 'array designator cannot initialize non-array type %0'
H0BB48B48E929: '배열 지정자는 배열이 아닌 형식 %0를 초기화할 수 없습니다'
# 'array designator index (%0) exceeds array bounds (%1)'
HF8952A3F237D: '배열 지정자 인덱스 (%0)가 배열 경계(%1)를 초과했습니다.'
# 'array designator range [%0, %1] is empty'
HFAC24EA6FC3D: '배열 지정자 범위 [%0, %1]은 비어 있습니다'
# "array designator value '%0' is negative"
H02A61A71BE5A: "배열 지정자 값 '%0'이 음수입니다"
# 'array designators are a C99 extension'
H09604E6E8FF6: '배열 지정자는 C99 확장 기능입니다'
# 'array has %select{incomplete|sizeless}0 element type %1'
H513D9739D1E9: '배열의 요소 유형이 %select{완전하지 않은|크기 없는}0 입니다 %1'
# 'array index %0 is before the beginning of the array'
HE66AD6A3EEDD: '배열 인덱스 %0가 배열의 시작보다 앞에 있습니다'
# 'array index %0 is past the end of the array (that has type %1%select{|, cast to %3}2)'
HB32CD52AC2F7: '배열 인덱스 %0가 배열의 끝을 넘어섭니다 (타입 %1%select{|, 형변환 %3}2인 배열입니다)'
# 'array index %0 refers past the last possible element for an array in %1-bit address space containing %2-bit (%3-byte) elements (max possible %4 element%s5)'
H8C89DC3E13D9: '배열 인덱스 %0는 %1비트 주소 공간에 있는 %2비트 (%3바이트) 요소를 포함하는 배열의 마지막으로 가능한 요소를 넘어 가리킵니다 (최대 %4 요소%s5 가능)'
# 'array initializer must be an initializer list%select{| or string literal| or wide string literal}0'
H4C9486DBC430: '배열 초기식은 초기식 목록%select{| 또는 문자열 리터럴| 또는 와이드 문자열 리터럴}0이어야 합니다.'
# 'array is too large (%0 elements)'
H898DDC47DE13: '배열이 너무 큽니다 (%0 요소)'
# 'array of %0 type is invalid in OpenCL'
H394630398D52: 'OpenCL에서 %0 유형의 배열은 유효하지 않습니다'
# 'array of abstract class type %0'
HD205577BDFE7: '추상 클래스 형식 %0의 배열'
# 'array of interface %0 is invalid (probably should be an array of pointers)'
H26CB6BC11BB2: '인터페이스 %0의 배열이 유효하지 않습니다(가능성 높은 해결 방법: 포인터 배열을 사용해야 합니다)'
# 'array parameter is missing a nullability type specifier (_Nonnull, _Nullable, or _Null_unspecified)'
HF62708756DE6: '배열 매개변수에 nullability 유형 지정자 (_Nonnull, _Nullable 또는 _Null_unspecified)가 누락되었습니다'
# 'array section %select{lower bound|length}0 is not an integer'
H54C64A3BE980: '배열 섹션 %select{하한|길이}0은 정수 값이 아닙니다'
# "array section %select{lower bound|length}0 is of type 'char'"
H553F40D88798: "배열 섹션 %select{하단 경계|길이}0은 'char' 형식입니다"
# 'array section does not specify contiguous storage'
HD0B03CAA79AA: '배열 섹션이 연속된 저장 영역을 지정하지 않았습니다'
# 'array section does not specify length for outermost dimension'
HDEBFF7152057: '배열 섹션에서 가장 바깥쪽 차원의 길이가 지정되지 않았습니다.'
# 'array section must be a subset of the original array'
H9DAB88506A15: '배열 섹션은 원본 배열의 부분 집합이어야 합니다'
# 'array shaping dimension is evaluated to a non-positive value %0'
H6C186AF92991: '배열 차원 크기는 양수가 아닌 값 %0으로 계산되었습니다'
# 'array shaping operation dimension is not an integer'
H521C171EF9F9: '배열 형태 변환 연산의 차원이 정수가 아닙니다.'
# 'array size expression has incomplete class type %0'
H48253C816CFD: '배열 크기 식이 미완성 클래스 형식 %0를 갖습니다'
# 'array size expression must have integral or %select{|unscoped }0enumeration type, not %1'
H46181D36F61E: '배열 크기 표현식은 정수형 또는 %select{|비범위 지정 }0열거 형식이어야 합니다. %1이 아닙니다'
# 'array size expression of type %0 requires explicit conversion to type %1'
H08A74EE986A3: '타입 %0의 배열 크기 표현식은 타입 %1로의 명시적 변환이 필요합니다'
# 'array size is negative'
H2357C6CBC81F: '배열 크기가 음수입니다'
# 'array size must be specified in new expression with no initializer'
HC377DBA39626: 'new 표현식에서 초기화자가 없을 때 배열 크기를 지정해야 합니다'
# 'array subscript is not an integer'
HCA57C5D6E89C: '배열 서브스크립트가 정수가 아닙니다'
# "array subscript is of type 'char'"
HF94CCD2B1ECE: "배열 인덱서는 'char' 형식입니다"
# 'array type %0 is not assignable'
H89C95FEC605F: '배열 형식 %0는 할당할 수 없습니다.'
# 'array types cannot be value-initialized'
HA2673E710254: '배열 형식은 값 초기화될 수 없습니다'
# 'array-to-pointer decay of array member without known bound is not supported'
HAB3F18D32404: '크기 정보가 없는 배열 멤버의 배열-포인터 변환은 지원되지 않습니다'
# "as specified in %select{'collapse'|'ordered'|'collapse' and 'ordered'}0 clause%select{||s}0"
H1ABDD2AD30EB: "에 따라 명시된 %select{'COLLAPSE'|'ORDERED'|'COLLAPSE 및 ORDERED'}0 절%select{||s}0"
# 'ascending'
HF393CC9965C7: '오름차순'
# 'asm constraint has an unexpected number of alternatives: %0 vs %1'
HF38699D505AA: 'asm 제약이 예상하지 못한 대안의 수를 가집니다: %0 vs %1'
# 'asm operand has incomplete type %0'
HAA2952BA222F: '어셈블리 연산자는 완전하지 않은 유형 %0를 가집니다.'
# 'asm operand name "%0" first referenced here'
H8FB938C946B0: 'asm 옵랜드 이름 "%0"이 여기서 처음 참조되었습니다.'
# 'asm-specifier for input or output variable conflicts with asm clobber list'
H99E324C19D00: '입력 또는 출력 변수에 대한 asm 지정자가 asm clobber 목록과 충돌합니다'
# 'assertion failed during evaluation of constant expression'
H0BDBA0DDBFCA: '상수식 평가 중 단언 실패'
# 'assigning %select{array literal|dictionary literal|numeric literal|boxed expression|<should not happen>|block literal}0 to a weak %select{property|variable}1; object will be released after assignment'
H8FFA1E619C25: '약한 %select{프로퍼티|변수}1에 %select{배열 리터럴|딕셔너리 리터럴|수치 리터럴|박싱 표현식|예상되지 않는 상태|블록 리터럴}0을 할당; 할당 후 객체가 해제됩니다'
# 'assigning %select{field|instance variable}0 to itself'
H9230F521B121: '자기 자신에게 %select{필드|인스턴스 변수}0를 할당했습니다'
# 'assigning retained object to %select{weak|unsafe_unretained}0 %select{property|variable}1; object will be released after assignment'
H250CD1E6F903: '리텐드 객체를 %select{weak|unsafe_unretained}0 %select{property|variable}1에 할당 중입니다; 할당 후 객체가 해제될 것입니다'
# 'assigning retained object to unsafe property; object will be released after assignment'
H8135CA913359: '안전하지 않은 프로퍼티에 보유된 객체를 할당; 할당 후 객체가 해제될 것입니다'
# "assigning to 'readonly' return result of an Objective-C message not allowed"
H87457323E0B9: "'readonly' 반환 결과에 Objective-C 메시지의 반환 값을 할당하는 것은 허용되지 않습니다"
# 'assigning value of preferred signed enum type %1 to unsigned bit-field %0; negative enumerators of enum %1 will be converted to positive values'
H20F4D35FCD03: '선호되는 부호付き enum 유형 %1의 값이 부호 없는 비트 필드 %0에 할당됨; enum %1의 음수 열거자는 양수 값으로 변환됩니다'
# 'assigning value of signed enum type %1 to unsigned bit-field %0; negative enumerators of enum %1 will be converted to positive values'
H03B45829D6A4: '부호 있는 열거형 타입 %1의 값을 부호 없는 비트 필드 %0에 대입; enum %1의 음수 열거자들은 양수 값으로 변환될 것입니다'
# 'assignment of a weak-unavailable object to a __weak object'
H270A68B29DDC: '약한 사용 불가능 객체를 __weak 객체에 할당'
# "assignment to Objective-C's isa is deprecated in favor of object_setClass()"
H4989286009CB: 'Objective-C의 isa에 대한 할당은 object_setClass() 사용으로 대체되어 이제는 사용하지 않도록 권고됩니다.'
# 'assignment to cast is illegal, lvalue casts are not supported'
HADC1B6BE18D9: '캐스팅에 대한 할당은 불법입니다, lvalue 캐스팅은 지원되지 않습니다'
# 'assignment would change active union member during the initialization of a different member of the same union'
HE419D89C08F2: '대입은 동일한 유니온의 다른 멤버 초기화 중 활성 유니온 멤버를 변경하려고 합니다'
# 'assume the ABI is never violated'
H2875C70D4F37: 'ABI가 위반되지 않았다고 가정합니다'
# 'assumption evaluated to false'
H4B3BD75DFF9D: '가정이 거짓으로 평가되었습니다'
# 'assumption is ignored because it contains (potential) side-effects'
H2E58C9356572: '가정이 (잠재적인) 부작용을 포함하기 때문에 무시되었습니다.'
# 'at least one argument of MTE builtin function must be a pointer (%0, %1 invalid)'
H9293CC0B9621: 'MTE 내장 함수의 인수 중 적어도 하나는 포인터여야 합니다 (%0, %1 유효하지 않음)'
# 'at most one defaultmap clause for each variable-category can appear on the directive'
H95E39CFC8758: '각각의 변수-카테고리마다 지시문에 나타날 수 있는 defaultmap 절은 최대 한 개만 있습니다.'
# "at most one overload for a given name may lack the 'overloadable' attribute"
H9206D4731FC1: "주어진 이름에 대한 오버로드 중 최대 한 개만 'overloadable' 속성이 없을 수 있습니다"
# "at most three expressions are allowed in '%0' clause in 'target teams ompx_bare' construct"
HC1194A65DC15: "target teams ompx_bare 구문의 '%0' 절 내에서는 최대 3개의 표현식만 허용됩니다."
# 'atomic %select{load|store}0 requires runtime support that is not available for this target'
HD7BAEC48A8AF: '원자 %select{load|store}0은(는) 이 타겟에 사용할 수 없는 런타임 지원을 필요로 합니다'
# "atomic by default property %0 has a user defined %select{getter|setter}1 (property should be marked 'atomic' if this is intended)"
H5A9A236EC6A5: "기본적으로 atomic인 속성 %0에 사용자 정의 %select{getter|setter}1이 있습니다 (이를 의도한 경우 속성을 'atomic'으로 표시해야 합니다)"
# "atomic constraint must be of type 'bool' (found %0)"
H69DAA34C1AB6: "원자 제약조건은 유형이 'bool'이어야 합니다 (%0이 발견됨)"
# 'atomic memory operand must have a power-of-two size'
HB13C6FA40316: '원자 메모리 피연산자는 2의 거듭제곱 크기를 가져야 합니다'
# 'atomic property of reference type %0 cannot have non-trivial assignment operator'
HFC34A950A835: '참조 형식 %0의 원자적 속성은 비자명 할당 연산자를 가질 수 없습니다'
# "atomic types are not supported in '%0'"
H97C63071B5D3: "원자형은 '%0'에서 지원되지 않습니다"
# 'atomic variable can be %select{assigned|initialized}0 to a variable only in global address space'
HCB0951EAACB6: '원자 변수는 %select{할당|초기화}0을 전역 주소 공간에 있는 변수에만 할 수 있습니다.'
# 'attempt to call %0 on non-heap %select{object %2|object: block expression|object: lambda-to-function-pointer conversion}1'
H6E5B5738458E: '비힙 %select{객체 %2|블록 표현식 객체|람다-함수 포인터 변환 객체}1에 대해 %0를 호출하려고 했습니다'
# 'attempt to specialize declaration here'
HF06CAF52936D: '이 위치에서 선언을 특수화하려고 시도했습니다'
# 'attempt to use a deleted function%select{|: %1}0'
HA9C947D267C4: '삭제된 함수를 사용하려고 시도했습니다%select{|: %1}0'
# 'attempt to use a poisoned identifier'
H3643F70789A4: '사용 금지된 식별자를 사용하려는 시도'
# 'attempting to use the forward class %0 as superclass of %1'
H994AA508EDDF: '전방 선언 클래스 %0을 %1의 superclass로 사용하려고 시도했습니다'
# 'attribute %0 after definition is ignored'
H5CD4712D502F: '정의 이후의 %0 속성은 무시됩니다'
# 'attribute %0 can be used only on HLSL intangible type %1'
HF8261011AFDE: '속성 %0는 HLSL 비구체형 %1에만 사용될 수 있습니다'
# 'attribute %0 can only be applied to @protocol definitions, not forward declarations'
H308DB757AA67: '%0 속성은 @protocol 정의에만 적용될 수 있으며, 포워드 선언에는 적용할 수 없습니다'
# 'attribute %0 can only be applied to an OpenCL kernel function'
HCB6BF3FC512F: '속성 %0은 OpenCL 커널 함수에만 적용될 수 있습니다'
# 'attribute %0 cannot appear more than once on a declaration'
HB715D0AA3201: '속성 %0는 선언에 한 번 이상 나타날 수 없습니다.'
# 'attribute %0 cannot be applied to %1'
H3AE597187391: '특성 %0은 %1에 적용될 수 없습니다.'
# 'attribute %0 cannot be applied to %select{functions|Objective-C method}1 without return value'
H1C83B6EE306A: '특성 %0는 %select{함수|Objective-C 메소드}1에 리턴 값이 없는 경우 적용될 수 없습니다'
# "attribute %0 cannot be applied to a 'void' parameter"
H6A5920736ACF: "속성 %0은 'void' 타입의 매개변수에 적용할 수 없습니다"
# 'attribute %0 cannot be used as an attribute pack'
HE6BA361D74BF: '속성 %0는 속성 팩으로 사용할 수 없습니다'
# 'attribute %0 cannot have an argument list'
HA4D8BF32DC8E: '속성 %0는 인자 목록을 가질 수 없습니다'
# 'attribute %0 does not support argument pack expansion'
H09CC6A21F4B4: '특성 %0는 인수 팩 확장을 지원하지 않습니다'
# "attribute %0 has no effect when annotating an 'if %select{constexpr|consteval}1' statement"
H409C4714E4F9: "특성 %0는 'if %select{constexpr|consteval}1' 문을 주석으로 표시할 때는 영향을 주지 않습니다"
# 'attribute %0 has no effect when annotating an infinite loop'
HB06D2414EAF4: 'attribute %0는 무한 루프를 주석으로 표시할 때 효과가 없습니다'
# 'attribute %0 here'
HC3F98113517C: '속성 %0 여기'
# 'attribute %0 ignored, because it cannot be applied to a type'
H5708F2759194: '속성 %0가 무시됨, 이는 이 속성이 타입에 적용될 수 없기 때문입니다'
# 'attribute %0 ignored, because it cannot be applied to omitted return type'
H547B25BBFFDA: '속성 %0가 생략된 반환 형식에 적용할 수 없기 때문에 무시되었습니다.'
# 'attribute %0 ignored, because it is not attached to a declaration'
H14902C950EC7: '속성 %0는 선언에 연결되지 않았기 때문에 무시되었습니다'
# 'attribute %0 is already applied'
HC7BD790A19A9: '속성 %0는 이미 적용되었습니다'
# 'attribute %0 is already applied with different arguments'
H11C03822A58E: '속성 %0는 이미 다른 인수로 적용되었습니다'
# 'attribute %0 is ignored, place it after "%select{class|struct|interface|union|enum|enum class|enum struct}1" to apply attribute to type declaration'
HB89779883F0D: '속성 %0는 무시되었습니다. 유형 선언에 속성을 적용하려면 %select{class|struct|interface|union|enum|enum class|enum struct}1 뒤에 배치하세요'
# "attribute %0 is not supported by '#pragma clang attribute'"
H38205446BD5C: "%0 속성은 '#pragma clang attribute'에서 지원되지 않습니다."
# 'attribute %0 is supported in the OpenCL version %1%select{| onwards}2'
H50454061E7F3: '특성 %0는 OpenCL 버전 %1%select{| 이후}2에서 지원됩니다'
# "attribute %0 is unsupported in '%1' shaders, requires %select{|one of the following: }2%3"
HFE781A72AFCA: "속성 %0은 '%1' 셰이더에서 지원되지 않습니다. %select{|다음 중 하나를 지정해야 합니다: }2%3"
# 'attribute %0 only applies to %1'
HC6318570485F: '%0 속성은 %1에만 적용됩니다'
# "attribute %0 only applies to a field or parameter of type '%1'"
H552F45F43B85: "속성 %0는 '%1' 타입의 필드나 매개변수에만 적용됩니다."
# 'attribute %0 requires shader model %1 or greater'
H06BEB9F659D8: '특성 %0는 쉐이더 모델 %1 이상이 필요합니다'
# 'attribute %0 with %1 arguments requires shader model %2 or greater'
H51393292A866: '특성 %0은 %1 인수를 사용하며, 쉐이더 모델 %2 이상이 필요합니다'
# 'attribute %q0 cannot be applied to a deleted function'
HCB37B8A40CF9: '특성 %q0는 삭제된 함수에 적용할 수 없습니다'
# 'attribute %q0 cannot be applied to member of %q1 class'
HFBD033ADD565: '특성 %q0는 %q1 클래스의 멤버에 적용할 수 없습니다'
# "attribute '%0' on function does not match previous declaration"
HF59632E17268: "함수에 지정된 속성 '%0'이 이전 선언과 일치하지 않습니다."
# "attribute '%0' on overriding function does not match base declaration"
H19F6EB5D2707: "오버라이딩 함수의 attribute '%0'은 기반 선언과 일치하지 않습니다"
# "attribute '%0' should not be added via type conversion"
HD3474317FB81: "속성 '%0'는 타입 변환을 통해 추가되어서는 안 됩니다"
# "attribute '%select{|target|cpu_specific|cpu_dispatch|target_clones|target_version}0' multiversioned functions do not yet support %select{function templates|virtual functions|deduced return types|constructors|destructors|deleted functions|defaulted functions|constexpr functions|consteval function|lambdas}1"
HF5E6CA9178D8: "속성 '%select{ |타겟|CPU 특정|CPU 디스패치|타겟 클로너스|타겟 버전}0'을 가진 다중 버전 함수는 아직 %select{함수 템플릿|가상 함수|추론된 반환 타입|생성자|소멸자|삭제된 함수|기본화된 함수|constexpr 함수|consteval 함수|람다}1를 지원하지 않습니다"
# "attribute '%select{|target|cpu_specific|cpu_dispatch|target_clones|target_version}0' multiversioning cannot be combined with attribute %1"
HA264FE94729F: "속성 '%select{|target|cpu_specific|cpu_dispatch|target_clones|target_version}0'의 멀티버전화는 속성 %1과 결합할 수 없습니다"
# "attribute 'msvc::constexpr' cannot be applied to the %select{constexpr|consteval|virtual}0 function %1"
HAC0996F3C628: "특성 'msvc::constexpr'은 %select{constexpr|consteval|virtual}0 함수 %1에 적용할 수 없습니다"
# "attribute 'readonly' of property %0 restricts attribute 'readwrite' of property inherited from %1"
HEB32CB97F1A3: "속성 'readonly'의 %0 속성이 %1로부터 상속받은 속성 'readwrite'의 속성을 제한합니다"
# 'attribute declaration must precede definition'
H83850ED606E9: '속성 선언은 정의보다 먼저 와야 합니다.'
# 'attribute is here'
HD14867328E83: '속성은 여기에 있습니다'
# "attribute is ignored on this statement as it only applies to functions; use '%0' on statements"
H8C71964DA95C: "이 속성은 함수에만 적용되므로 이 문장에는 무시됩니다; 문장에는 '%0'을 사용하십시오."
# 'attribute only applies to output parameters'
H05F9B2ABFA42: '특성은 출력 매개변수에만 적용됩니다'
# 'attribute with scope specifier cannot follow default scope specifier'
HFC36C268C353: 'attribute에 scope specifier가 있으면 기본 scope specifier 뒤에 오면 안 됩니다.'
# 'attributes \'%0("%2")\' and \'%1("%2")\' are mutually exclusive'
H56F1BA7862B2: '속성 \'%0("%2")\'와 \'%1("%2")\'는 상호 배제적입니다'
# 'attributes cannot be specified on a nested namespace definition'
H4264DC0CBC46: '특성은 중첩된 namespace 정의에 지정할 수 없습니다.'
# 'attributes cannot be specified on namespace alias'
H4F2E4C4430E8: '네임스페이스 별칭에 속성을 지정할 수 없습니다'
# 'attributes on %select{a namespace|an enumerator}0 declaration are a C++17 extension'
H034995816099: '%select{네임스페이스|열거자}0 선언에 대한 속성은 C++17 확장입니다'
# 'attributes on %select{a namespace|an enumerator}0 declaration are incompatible with C++ standards before C++17'
H8BB41AEA1EC6: '%select{네임스페이스|열거자}0 선언에 대한 속성은 C++17 이전 표준과 호환되지 않습니다'
# 'authenticating a null pointer will almost certainly trap'
HB0AE642AC2E4: 'NULL 포인터를 인증하면 거의 확실히 트랩이 발생합니다'
# 'auto property synthesis is synthesizing property not explicitly synthesized'
H0B109C7F8F74: '자동 프로퍼티 생성이 명시적으로 생성되지 않은 프로퍼티를 생성 중입니다'
# 'auto property synthesis will not synthesize property %0 because it cannot share an ivar with another synthesized property'
HB5E0DEB40CE6: '자동 프로퍼티 합성이 %0 프로퍼티를 합성하지 않을 것입니다. 다른 합성된 프로퍼티와 ivar를 공유할 수 없기 때문입니다.'
# "auto property synthesis will not synthesize property %0 because it is 'readwrite' but it will be synthesized 'readonly' via another property"
H2BD61AD864B9: "자동 프로퍼티 시너지(auto property synthesis)는 %0 프로퍼티를 생성하지 않습니다. 이 프로퍼티가 'readwrite'이지만 다른 프로퍼티를 통해 'readonly'로 시너지되기 때문입니다."
# 'auto property synthesis will not synthesize property %0 declared in protocol %1'
HA0C341D1A812: '자동 프로퍼티 합성은 프로토콜 %1에 선언된 프로퍼티 %0을(를) 합성하지 않습니다'
# 'auto property synthesis will not synthesize property %0; it will be implemented by its superclass, use @dynamic to acknowledge intention'
H0457D53851AF: '자동 속성 합성은 %0 속성을 합성하지 않을 것입니다; 이는 슈퍼클래스에 의해 구현될 것이며, 의도를 명시하기 위해 @dynamic을 사용하십시오'
# 'automatic variable qualified with an%select{| invalid}0 address space'
H122ACAE25198: '자동 변수에%select{| 무효한}0 주소 공간 자격이 부여되었습니다'
# 'autosynthesized property %0 will use %select{|synthesized}1 instance variable %2, not existing instance variable %3'
H4495EA68D322: '자동 생성된 속성 %0는 %select{|합성된}1 인스턴스 변수 %2를 사용할 것입니다. 존재하지 않는 인스턴스 변수 %3는 사용하지 않습니다'
# 'availability does not match previous declaration'
H583F2A1BC062: '가용성은 이전 선언과 일치하지 않습니다'
# 'available multilibs are:%0'
H0F052B7170DD: '사용 가능한 멀티리브는:%0'
# "backend data layout '%0' does not match expected target description '%1'"
H82DEBC38BED7: "백엔드 데이터 레이아웃 '%0'은 예상된 타겟 설명 '%1'과 일치하지 않습니다"
# 'backslash and newline separated by space'
HD4F9A252F950: '역슬래시와 줄바꿈이 공백으로 구분됨'
# 'bad receiver type %0'
HE40F679E3605: '잘못된 수신자 형식 %0'
# "base %0 is marked '%select{final|sealed}1'"
HE6BCB4D05CEC: "기반 %0는 '%select{final|sealed}1'로 지정되어 있습니다"
# 'base class %0 has %select{private|protected}1 destructor'
HEB04CB913679: '기반 클래스 %0에는 %select{private|protected}1 소멸자가 있습니다.'
# 'base class %0 has a flexible array member'
HD71C5E7037F5: '기반 클래스 %0는 유연한 배열 멤버를 가지고 있습니다'
# 'base class %0 is uninitialized when used here to access %q1'
H6E433F27AF21: '기반 클래스 %0는 여기서 %q1에 접근하기 위해 사용될 때 초기화되지 않았습니다'
# 'base class %0 specified here'
HE35763C73750: '기반 클래스 %0 여기서 지정됨'
# 'base class %0 specified more than once as a direct base class'
HC14516852948: '기반 클래스 %0이 직계 기반 클래스로 한 번 이상 지정되었습니다'
# 'base class has incomplete type'
H4B76670DCEA2: '기반 class가 완성되지 않은 형식입니다.'
# 'base class initializer %0 names both a direct base class and an inherited virtual base class'
HAE21C251743B: '기반 클래스 초기화자 %0는 직접 기반 클래스와 상속된 가상 기반 클래스 모두를 지정합니다'
# 'base of member reference is a function; perhaps you meant to call it%select{| with no arguments}0?'
H224FA72A413F: '멤버 참조의 밑 객체는 함수입니다%select{| 인수 없이}0 호출하려는 의도였을까요?'
# 'base specifier must name a class'
HBDBF7667EBAE: '기반 지정자는 클래스 이름을 지정해야 합니다'
# 'basic register allocator'
HFEA9765B5A50: '기본 레지스터 할당기'
# 'basic statistics'
HAA78894D50F2: '기본 통계'
# 'because %select{base class of |field of |}0type %1 has a user-provided %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}2'
HA75BA84DF85B: '원인: %select{기반 클래스의 |필드의 |}0타입 %1에 사용자 제공된 %select{기본 생성자|복사 생성자|이동 생성자|복사 대입 연산자|이동 대입 연산자|소멸자}2가 있습니다'
# 'because %select{base class of |field of |}0type %1 has no default constructor'
HC07ABEF26326: '왜냐하면 %select{기반 클래스의 |필드의 |}0타입 %1에는 기본 생성자가 없습니다'
# 'because field %0 has an initializer'
H7DB53EF856A5: '왜냐하면 필드 %0가 초기화자를 가지고 있기 때문입니다'
# 'because it %select{is a reference type|is const|is volatile|has an ARC lifetime qualifier|is a variably-modified type|has a virtual base %1|not %select{a|an array of objects of}1 scalar or class type|has a non-trivially-relocatable base %1|has a non-trivially-relocatable member %1 of type %2|has a non-replaceable base %1|has a non-replaceable member %1 of type %2|has a non-trivially-copyable base %1|has a non-trivially-copyable member %1 of type %2|has a %select{deleted|user-provided}1 destructor|has a user provided %select{copy|move}1 constructor|has a deleted %select{copy|move}1 constructor|has a user provided %select{copy|move}1 assignment operator|has a deleted %select{copy|move}1 assignment operator|is a union with a user-declared %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}1|is a function type|is a cv void type|is an incomplete array type}0'
HF88804C54D6A: '因为它 %select{참조 형식입니다|const입니다|volatile입니다|ARC 수명 한정자가 있습니다|가변 수정 형식입니다|가상 기본 클래스 %1이(가) 있습니다|not %select{스칼라 또는 클래스 형식이 아닌|객체 배열의}1 형식입니다|비-트리비얼하게 재배치 가능한 기본 클래스 %1이(가) 있습니다|형식 %2의 비-트리비얼하게 재배치 가능한 멤버 %1이(가) 있습니다|교체 불가능한 기본 클래스 %1이(가) 있습니다|형식 %2의 교체 불가능한 멤버 %1이(가) 있습니다|비-트리비얼하게 복사 가능한 기본 클래스 %1이(가) 있습니다|형식 %2의 비-트리비얼하게 복사 가능한 멤버 %1이(가) 있습니다|%select{삭제된|사용자가 제공한}1 소멸자가 있습니다|사용자가 제공한 %select{복사|이동}1 생성자가 있습니다|삭제된 %select{복사|이동}1 생성자가 있습니다|사용자가 제공한 %select{복사|이동}1 할당 연산자가 있습니다|삭제된 %select{복사|이동}1 할당 연산자가 있습니다|사용자가 선언한 %select{기본 생성자|복사 생성자|이동 생성자|복사 할당 연산자|이동 할당 연산자|소멸자}1이(가) 있는 유니언입니다|함수 형식입니다|cv void 형식입니다|불완전한 배열 형식입니다}0'
# 'because it has a default argument'
H4C6DC4DA1E45: '기본 인수가 있기 때문에'
# 'because it is a variadic function'
H640DA969741B: '가변 인자 함수이기 때문에'
# 'because its parameter is %diff{of type $, not $|of the wrong type}2,3'
H5CB13170AE2B: '인수의 타입이 %diff{타입이 $이지만, $가 아닙니다.|잘못된 타입입니다}2,3 이기 때문입니다.'
# 'because no %select{<<ERROR>>|constructor|constructor|assignment operator|assignment operator|<<ERROR>>}2 can be used to %select{<<ERROR>>|copy|move|copy|move|<<ERROR>>}2 %select{base class|field|an object}0 of type %3'
HD9E44C137738: '사용할 수 있는 %select{<<ERROR>>|생성자|생성자|할당 연산자|할당 연산자|<<ERROR>>}2가 없어서, %3 형식의 %select{기반 클래스|필드|객체}0을 %select{<<ERROR>>|복사|이동|복사|이동|<<ERROR>>}2 할 수 없습니다'
# 'because of ambiguity in conversion %diff{of $ to $|between types}0,1'
HB064B974A1C3: '변환 %diff{의 $에서 $|타입 사이}0,1 의 애매함 때문에'
# 'because substituted constraint expression is ill-formed%0'
H708967A94C80: '치환된 제약 표현이 유효하지 않기 때문에%0'
# 'because the function selected to %select{construct|copy|move|copy|move|destroy}2 %select{base class|field}0 of type %1 is not trivial'
H1F152D129667: '선택된 %select{construct|copy|move|copy|move|destroy}2 %select{base class|field}0 의 형식 %1 함수가 trivial하지 않습니다'
# 'because type %0 has a member with %select{no|no|__strong|__weak|__autoreleasing}1 ownership'
HE992EBFC669B: '타입 %0가 %select{no|no|__strong|__weak|__autoreleasing}1 소유권을 가진 멤버를 가지고 있기 때문입니다'
# 'because type %0 has a virtual %select{member function|base class}1'
H45351AACBEF7: '타입 %0가 가상의 %select{멤버 함수|기반 클래스}1을 가지고 있기 때문입니다'
# "befriending %1 without '%select{struct|interface|union|class|enum}0' keyword is incompatible with C++98"
HDE958FBB8995: "C++98과 호환되지 않습니다: '%select{struct|interface|union|class|enum}0' 키워드 없이 %1를 친구로 지정했습니다."
# 'binary RIFF format'
H555066C6C2A6: '바이너리 RIFF 형식'
# 'binary fold expression has unexpanded parameter packs in both operands'
HBE3AEFF67350: '이항 폴드 표현식(binary fold expression)의 양쪽 피연산자에 전개되지 않은 매개변수 팩(unexpanded parameter packs)이 있습니다'
# 'binary integer literals are a C++14 extension'
H12BBB01421DF: '2진 정수 리터럴은 C++14 확장 기능입니다'
# 'binary integer literals are a C23 extension'
HC848A482B4CC: '2진 수 리터럴은 C23 확장 기능입니다'
# 'binary integer literals are incompatible with C standards before C23'
H60CB9502C648: '2진 정수 리터럴은 C23 이전의 C 표준과 호환되지 않습니다'
# 'binary integer literals are incompatible with C++ standards before C++14'
H039AFCF983A6: '2진수 정수 리터럴은 C++14 이전의 C++ 표준과 호환되지 않습니다'
# 'binary operator not supported, only +, *, -, /, &, ^, |, <<, or >> are permitted'
H947D153F3B10: '이진 연산자가 지원되지 않습니다. 허용되는 연산자만 사용해 주세요: +, *, -, /, &, ^, |, <<, 또는 >>'
# 'binary with the instrumentation map, or a separate instrumentation map'
HC4FD0057C615: '인스트루먼테이션 맵이 있는 바이너리 또는 별도의 인스트루먼테이션 맵'
# 'binary with the instrumentation map, or a separate instrumentation map for graph'
H2CC2C500D553: '인스트루먼테이션 맵이 포함된 바이너리 또는 그래프용 별도의 인스트루먼테이션 맵'
# 'binary with the instrumentation map, or a separate instrumentation map for graph 1'
HAEE5C542170E: '인스트루먼테이션 맵을 갖는 바이너리 또는 그래프 1을 위한 별도의 인스트루먼테이션 맵'
# 'binary with the instrumentation map, or a separate instrumentation map for graph 2'
HC231E43E4B06: '인스트루먼테이션 맵이 있는 이진 파일 또는 그래프 2에 대한 별도의 인스트루먼테이션 맵'
# 'binary with the instrumrntation map, or a separate instrumentation map'
H0A39B12683BE: '인스트루먼테이션 맵을 사용한 바이너리 또는 별도의 인스트루먼테이션 맵'
# 'binding %0 cannot appear in the initializer of its own decomposition declaration'
H672061929029: '바인딩 %0는 자체의 분해 선언 초기화자에 출현할 수 없습니다'
# 'binding dereferenced null pointer to reference has undefined behavior'
H95EC0F6A8A66: '역참조된 null 포인터를 참조로 바인딩하는 것은 정의되지 않은 동작을 유발합니다'
# 'binding reference %diff{of type $ to value of type $|to value}0,1 %select{drops %3 qualifier%plural{1:|2:|4:|:s}4|changes address space|not permitted due to incompatible qualifiers}2'
H55C0D80172E9: '참조 %diff{타입 $의 값 $에 바인딩|값에 바인딩}0,1 이 %select{질의자 %3를 제거%plural{1:|2:|4:|:s}4|주소 공간 변경|호환되지 않는 질의자 때문에 허용되지 않음}2'
# 'binding reference member %0 to stack allocated %select{variable|parameter}2 %1'
H6CEDF6C3E571: '참조 멤버 %0를 스택에 할당된 %select{변수|매개변수}2 %1에 바인딩함'
# "binding type '%0' is invalid"
HD0FB3A3589D6: "바인딩 유형 '%0'은 무효입니다"
# "binding type '%select{t|u|b|s|c|i}0' cannot be applied more than once"
H9FC4B2C35AB9: "바인딩 유형 '%select{t|u|b|s|c|i}0'은(는) 한 번 이상 적용될 수 없습니다"
# "binding type '%select{t|u|b|s|c}0' only applies to %select{SRV resources|UAV resources|constant buffer resources|sampler state|numeric variables in the global scope}0"
H9DB6D490A30A: "바인딩 유형 '%select{SRV|UAV|상수 버퍼|샘플러 상태|전역 숫자 변수}0'은 %select{셰이더 리소스 뷰 리소스|업데이트 가능한 리소스 뷰 리소스|상수 버퍼 리소스|샘플러 상태|전역 범위의 숫자 변수}0에만 적용됩니다."
# "binding type '%select{t|u|b|s|c}0' only applies to types containing %select{SRV resources|UAV resources|constant buffer resources|sampler state|numeric types}0"
H1CE73AE71EA5: "바인딩 유형 '%select{t|u|b|s|c}0'은 %select{SRV 리소스|UAV 리소스|상수 버퍼 리소스|샘플러 상태|수치 형식}0를 포함하는 유형에만 적용됩니다"
# "binding type 'b' only applies to constant buffers. The 'bool constant' binding type is no longer supported"
HC83E5E495198: "바인딩 유형 'b'는 상수 버퍼에만 적용됩니다. 'bool constant' 바인딩 유형은 더 이상 지원되지 않습니다"
# "binding type 'c' ignored in buffer declaration. Did you mean 'packoffset'?"
H937D8317B6A5: "바인딩 형식 'c'는 버퍼 선언에서 무시되었습니다. 'packoffset'을 의도한 것이었는지 확인해 주세요?"
# "binding type 'i' ignored. The 'integer constant' binding type is no longer supported"
H2F0190E0856D: "바인딩 형식 'i' 무시됨. '정수 상수' 바인딩 형식은 더 이상 지원되지 않습니다."
# "bit fields cannot be used to specify storage in a '%0' clause"
H5C9BE7997F9C: "비트 필드는 '%0' 절에서 저장 공간을 지정하는 데 사용할 수 없습니다"
# 'bit-field %0 has bit-width %1 here'
H38A912E965D9: '비트필드 %0의 비트 너비는 여기서 %1입니다'
# 'bit-field %0 has negative width (%1)'
HA6B3D52AF212: '비트 필드 %0의 너비가 음수입니다 (%1)'
# 'bit-field %0 has non-integral type %1'
H1F66B27F57D3: '비트 필드 %0는 정수형이 아닌 형식 %1를 가집니다'
# 'bit-field %0 is not wide enough to store all enumerators of %1'
H1E7885609E9C: '비트 필드 %0는 %1의 모든 열거자를 저장하기에 충분히 넓지 않습니다'
# 'bit-field %0 is not wide enough to store all enumerators of preferred type %1'
H0D56F6137EF8: '비트 필드 %0는 선호되는 유형 %1의 모든 열거자를 저장하기에 충분한 너비가 없습니다'
# 'bit-field %0 of type %1 has a different storage size than the preceding bit-field (%2 vs %3 bytes) and will not be packed under the Microsoft ABI'
H9DAB2952ED10: '형식 %1의 비트필드 %0은(는) 이전 비트필드와 다른 저장 공간 크기를 가지며(%2 대 %3 바이트), Microsoft ABI에서 패킹되지 않을 것입니다.'
# 'bit-field is declared here'
HE5CFF566169E: '비트 필드가 여기에서 선언되었습니다'
# 'bit-fields are not supported in OpenCL'
H752654865932: 'OpenCL에서는 비트 필드가 지원되지 않습니다'
# 'bit_cast %select{from|to}0 a %select{|type with a }1%select{union|pointer|member pointer|volatile|reference}2 %select{type|member}1 is not allowed in a constant expression'
H0C9C7C0B5093: 'bit_cast %select{from|to}0 a %select{|type with a }1%select{union|pointer|member pointer|volatile|reference}2 %select{type|member}1은 상수 표현식에서 허용되지 않습니다'
# 'bit_cast involving type %0 is not allowed in a constant expression; element size %1 * element count %2 is not a multiple of the byte size %3'
H3BD534784507: '비트 캐스트가 형식 %0를 포함하는 상수 표현식에서 허용되지 않습니다; 요소 크기 %1 * 요소 개수 %2는 바이트 크기 %3의 배수가 아닙니다'
# "bitcode library '%0' does not exist"
H551B33870D5D: "비트코드 라이브러리 '%0'가 존재하지 않습니다"
# 'bitmasking for introspection of Objective-C object pointers is strongly discouraged'
H7CE8DAA0A6CB: 'Objective-C 객체 포인터의 내부 검사용 비트마스킹은 강력히 권장하지 않습니다'
# 'bitwise comparison always evaluates to %select{false|true}0'
H8A4398170F46: '비트별 비교는 항상 %select{false|true}0으로 평가됩니다'
# "bitwise negation of a boolean expression%select{;| always evaluates to 'true';}0 did you mean logical negation?"
HE532D6128324: "부울 표현식의 비트 단위 부정%select{;| 항상 'true'로 평가됩니다;}0 논리 부정을 의미하셨나요?"
# 'bitwise or with non-zero value always evaluates to true'
H6F8F36ACC41B: '0이 아닌 값과의 비트 OR 연산은 항상 참으로 평가됩니다'
# 'block cannot return %select{array|function}0 type %1'
H91AB8D594327: '블록은 %select{배열|함수}0 유형 %1을 반환할 수 없습니다'
# 'block captures an autoreleasing out-parameter, which may result in use-after-free bugs'
H835D51AA87F3: '블록이 자동 해제되는 아웃 매개변수를 포획하여, 이는 해제 후 사용 오류를 일으킬 수 있습니다'
# "block could be declared with attribute 'noreturn'"
H9307EF042F77: "블록은 'noreturn' 속성을 사용하여 선언될 수 있습니다"
# "block implicitly retains 'self'; explicitly mention 'self' to indicate this is intended behavior"
H094C5FEF2D2A: "블록이 'self'를 암묵적으로 유지합니다; 의도한 동작임을 표시하기 위해 'self'를 명시적으로 언급하십시오."
# 'block pointer to non-function type is invalid'
H9EFC2777265D: '비함수 타입에 대한 블록 포인터는 유효하지 않습니다'
# 'block pointer variable %0 is %select{uninitialized|null}1 when captured by block'
H5DFD2F29C16B: '블록 포인터 변수 %0는 블록에 포착될 때 %select{초기화되지 않음|null}1입니다.'
# 'block type cannot be used as expression in ternary expression in OpenCL'
HE91DFBCBC336: 'block type은 OpenCL의 삼항 표현식에서 표현식으로 사용될 수 없습니다'
# 'block will be retained by %select{the captured object|an object strongly retained by the captured object}0'
H659E73E5BC81: '블록은 %select{포착된 객체에 의해|포착된 객체에 의해 강하게 보유된 객체에 의해}0 보관됩니다'
# 'blocks support disabled - compile with -fblocks or %select{pick a deployment target that supports them|for OpenCL C 2.0 or OpenCL C 3.0 with __opencl_c_device_enqueue feature}0'
H870F6FD76494: '블록 지원이 비활성화되었습니다 - -fblocks 플래그로 컴파일하거나 %select{블록을 지원하는 배포 대상을 선택하세요|OpenCL C 2.0 또는 __opencl_c_device_enqueue 기능을 갖춘 OpenCL C 3.0을 사용하세요}0'
# "blocks used in enqueue_kernel call are expected to have parameters of type 'local void*'"
H5A1C0A69E254: "enqueue_kernel 호출에서 사용되는 블록은 'local void*' 형식의 매개변수를 가져야 합니다"
# 'blocks with parameters are not accepted in this prototype of enqueue_kernel call'
H6F73FE38020E: '이 enqueue_kernel 호출의 프로토타입에서는 매개변수가 있는 블록은 허용되지 않습니다'
# 'body of cpu_dispatch function will be ignored'
H8CCA48E04008: 'cpu_dispatch 함수의 본문은 무시됩니다'
# "bool literal returned from 'main'"
H65A070E22BD6: "'main'에서 bool 리터럴 반환"
# 'both arms of conditional operator are unable to produce a constant expression'
H42234192A750: '조건 연산자의 두 가지 분기 모두가 상수 표현식을 생성할 수 없습니다'
# 'boundary to use for alignment of basic blocks'
H8D491EEC35CA: 'basic blocks의 정렬에 사용할 경계'
# 'brace elision for designated initializer is a C99 extension'
H98B26CB02BEA: '지정 초기자에 대한 중괄호 생략은 C99 확장 기능입니다'
# 'braces around %select{scalar |}0initializer'
H5FA1CA5D46EC: '%select{스칼라 |}0초기식 주위의 중괄호'
# 'bracket nesting level exceeded maximum of %0'
HAE0DB07D013C: '괄호 중첩 수준이 최댓값 %0를 초과했습니다.'
# 'brackets are not allowed here; to declare an array, place the brackets after the %select{identifier|name}0'
H9FD98F06E7EB: '여기에는 괄호가 허용되지 않습니다; 배열을 선언하려면 괄호를 %select{identifier|name}0 뒤에 배치해야 합니다'
# 'branch probability threshold in percentage to be considered very likely'
H4385A55B36C8: '분기 확률 임계값(%)로 매우 가능으로 판단되는 문턱값'
# 'branch probability threshold in percentage to be considered very likely when profile is available'
H7FFFD5CE40B4: '프로파일이 있을 때 매우 가능하다고 간주하기 위한 분기 확률의 퍼센티지 임계값'
# 'branch relax asm'
HC2E42E8DC7A2: '가지 완화 asm'
# "build a shadowed submodule '%0'"
H9D79CC95EF50: "덮인 서브모듈 '%0'을(를) 빌드합니다."
# "building module '%0' as '%1'"
H765D28E7D6EF: "모듈 '%0'을(를) '%1'로 생성 중"
# 'built-in candidate %0'
H70FA60F84316: '내장 후보 %0'
# 'builtin %0 is deprecated; use %1 instead'
H3145BB7C5706: '내장 함수 %0는 지원 중단됨; %1을 대신 사용하세요'
# 'builtin call is not valid when calling from a function without active ZA state'
H7B974CCBB78F: '내장 호출은 ZA 상태가 활성화되지 않은 함수에서 호출할 때 유효하지 않습니다'
# 'builtin call is not valid when calling from a function without active ZT0 state'
H1B7C49833DEE: 'ZT0 상태가 활성화되지 않은 함수에서 호출할 때 빌트인 호출은 유효하지 않습니다.'
# 'builtin can only be called from a %0 function'
H2DDDDEB70C80: 'builtin은 오직 %0 함수에서만 호출될 수 있습니다'
# 'builtin feature check macro requires a parenthesized identifier'
HA88BFEE47095: '내장 기능 확인 매크로는 괄호로 감싸인 식별자를 필요로 합니다'
# 'builtin functions must be directly called'
HABBC844A5E58: '내장 함수는 직접 호출되어야 합니다'
# 'builtin headers belong to system modules, and _Builtin_ modules are ignored for cstdlib headers'
HFC2F5B50372D: '빌트인 헤더는 시스템 모듈에 속하며, _Builtin_ 모듈은 cstdlib 헤더에 대해 무시됩니다'
# 'builtin is not supported on this target'
H6C31A7E5443F: '이 타겟에서 built-in은 지원되지 않습니다'
# 'builtin requires %select{spirv|spirv32 or spirv64}0 target'
HB951F2F94853: '내장 함수는 %select{spirv|spirv32 또는 spirv64}0 타겟이 필요합니다.'
# 'builtin requires%select{| at least one of the following extensions}0: %1'
HBE3E35E72C33: '내장 함수는%select{ | 다음 중 적어도 하나의 확장 기능을 지정해야 합니다}0: %1'
# "but in %select{'%1'|definition here}0 found %select{%3 referenced %plural{1:protocol|:protocols}3|%ordinal3 referenced protocol with different name %4}2"
HD3683C05282A: "하지만 %select{'%1'|정의 위치 여기}0에서 %select{%3이 참조한 %plural{1:프로토콜|:프로토콜들}3|%ordinal3 참조된 프로토콜 이름이 다른 %4}2를 발견했습니다."
# "but in %select{'%1'|definition here}0 found %select{%select{method %4|constructor|destructor}3 that has %5 parameter%s5|%select{method %4|constructor|destructor}3 with %ordinal5 parameter of type %6%select{| decayed from %8}7|%select{method %4|constructor|destructor}3 with %ordinal5 parameter named %6}2"
HF69A42480F6D: "하지만 %select{'%1'|정의 위치}0에서 다음을 발견했습니다: %select{%select{메서드 %4|생성자|소멸자}3에 %5 parameter%s5가 있습니다|%select{메서드 %4|생성자|소멸자}3의 %ordinal5번째 매개변수 타입 %6%select{|에서 변환된 %8}7|%select{메서드 %4|생성자|소멸자}3의 %ordinal5번째 매개변수 %6이 있습니다}2"
# "but in %select{'%1'|definition here}0 found %select{%select{no super class|super class with type %4}3|instance variable '%3' access control is %select{|@private|@protected|@public|@package}4}2"
H07A5F408116E: "하지만 %select{'%1'|여기 정의}0에서 %select{%select{슈퍼 클래스 없음|유형 %4를 가진 슈퍼 클래스}|접근 제어는 %select{|@private|@protected|@public|@package}4인 인스턴스 변수 '%3'}2를 찾았습니다"
# "but in %select{'%1'|definition here}0 found %select{end of class|public access specifier|private access specifier|protected access specifier|static assert|field|method|type alias|typedef|data member|friend declaration|function template|method|instance variable|property}2"
H901B5EFBD082: "그러나 %select{'%1'|이 부분의 정의}0에서 %select{클래스 끝|공개 액세스 지정자|비공개 액세스 지정자|보호 액세스 지정자|정적 검증|필드|메서드|타입 별칭|typedef|데이터 멤버|친구 선언|함수 템플릿|메서드|인스턴스 변수|속성}2를 찾았습니다"
# "but in %select{'%1'|definition here}0 found %select{field %3|field %3 with type %4|%select{non-|}4bit-field %3|bit-field %3 with different width expression|%select{non-|}4mutable field %3|field %3 with %select{no|an}4 initializer|field %3 with a different initializer}2"
H4C900A5437EA: "하지만 %select{'%1'|정의 위치}0에서는 %select{필드 %3|타입 %4인 필드 %3|%select{비트필드가 아닌 필드 |비트필드 }4%3|너비 표현이 다른 비트필드 %3|%select{가변이 아닌 |가변 }4필드 %3|%select{초기화자가 없는 |초기화자를 가진 }4필드 %3|다른 초기화자를 가진 필드 %3}2를 찾았습니다."
# "but in %select{'%1'|definition here}0 found %select{method %3 with different return type %4|method %3 as %select{class|instance}4 method|%select{no|'required'|'optional'}3 method control|method %3 with %select{no designated initializer|designated initializer}4|%select{regular|direct}4 method %3|different method %3}2"
H9C08666CA7C3: "하지만 %select{'%1'|정의 부분}0에서 %select{%3 메서드가 다른 반환 형식 %4를 가집니다| %3 메서드를 %select{class|인스턴스}4 메서드로|%select{없음|'필수'|'선택'}3 메서드 제어| %3 메서드가 %select{지정된 초기화자가 없음|지정된 초기화자}4| %select{일반|직접}4 메서드 %3| 다른 %3 메서드}2를 발견했습니다."
# "but in %select{'%1'|definition here}0 found %select{property %3|property %3 with type %4|%select{no|'required'|'optional'}3 property control|property %3 with different '%select{none|readonly|getter|assign|readwrite|retain|copy|nonatomic|setter|atomic|weak|strong|unsafe_unretained|nullability|null_resettable|class|direct}4' attribute}2"
HFF656A371ACE: "그러나 %select{'%1'|정의 위치}0에서 %select{속성 %3|속성 %3과 유형 %4|%select{없음|'필수'|'옵셔널'}3 속성 제어|다른 '%select{none|readonly|getter|assign|readwrite|retain|copy|nonatomic|setter|atomic|weak|strong|unsafe_unretained|nullability|null_resettable|class|direct}4' 속성이 있는 속성 %3}2를 발견했습니다"
# "but in %select{'%1'|definition here}0 found %select{||||different static assert|different field|different method|different type alias|different typedef|different data member|different friend declaration|different function template|different method|different instance variable|different property|another unexpected decl}2"
HF376197A4A03: "하지만 %select{'%1'|정의가 여기에 있습니다}0에서 %select{||||다른 정적 암시|다른 필드|다른 메서드|다른 타입 별칭|다른 typedef|다른 데이터 멤버|다른 프렌드 선언|다른 함수 템플릿|다른 메서드|다른 인스턴스 변수|다른 속성|예상하지 못한 다른 선언}2을 발견했습니다"
# "but in '%0' found %select{%2 base %plural{1:class|:classes}2|%2 virtual base %plural{1:class|:classes}2|%ordinal2 base class with different type %3|%ordinal2 %select{non-virtual|virtual}3 base class %4|%ordinal2 base class %3 with %select{public|protected|private|no}4 access specifier}1"
H86407D9382F4: "하지만 '%0'에서 %select{%2 기반 %plural{1:클래스|:클래스}2|%2 가상 기반 %plural{1:클래스|:클래스}2|%ordinal2 기반 클래스와 다른 형 %3|%ordinal2 %select{비가상|가상}3 기반 클래스 %4|%ordinal2 기반 클래스 %3에 %select{공개|보호|비공개|없음}4 접근 지정자가 있습니다.}1을(를) 발견했습니다."
# "but in '%0' found %select{%select{typedef|type alias}2 name %3|%select{typedef|type alias}2 %3 with different underlying type %4}1"
H5285292325BC: "하지만 '%0'에서 %select{%select{typedef|type alias}2 이름 %3|%select{typedef|type alias}2 %3는 다른 기본 형식 %4를 가집니다}1을 발견했습니다"
# "but in '%0' found %select{data member with name %2|data member %2 with different type %3|data member %2 with%select{out|}3 an initializer|data member %2 with a different initializer|data member %2 %select{is constexpr|is not constexpr}3}1"
HB02EC39C6642: "하지만 '%0'에서 다음을 발견했습니다: %select{이름 %2를 가진 데이터 멤버|데이터 멤버 %2가 다른 형식 %3을 가집니다|데이터 멤버 %2가 초기화자%select{ 없음|}3을 가집니다|데이터 멤버 %2가 다른 초기화자를 가집니다|데이터 멤버 %2 %select{ constexpr입니다| constexpr가 아닙니다}3}1"
# "but in '%0' found %select{different return type %2|%ordinal2 parameter with name %3|%ordinal2 parameter with type %3%select{| decayed from %5}4|%ordinal2 parameter with%select{out|}3 a default argument|%ordinal2 parameter with a different default argument|a different body}1"
H926097C3EBA4: "하지만 '%0'에서 %select{다른 반환 형 %2|%ordinal2 매개변수의 이름 %3|%ordinal2 매개변수의 형 %3%select{| %5로 변환됨}4|%ordinal2 매개변수에 %select{out|}3 기본 인수가 있음|%ordinal2 매개변수의 기본 인수가 다름|다른 본문}1을 찾았습니다"
# "but in '%0' found %select{enum that is %select{not scoped|scoped}2|enum scoped with keyword %select{struct|class}2|enum %select{without|with}2 specified type|enum with specified type %2|enum with %2 element%s2|%ordinal2 element has name %3|%ordinal2 element %3 %select{has|does not have}4 an initializer|%ordinal2 element %3 has different initializer|}1"
H44D066860BB7: "하지만 '%0'에서 %select{유형 %select{범위 지정되지 않음|범위 지정됨}2인 enum|유형 %select{struct|class}2 키워드로 범위 지정된 enum|%select{없는|있는}2 지정된 enum 유형|지정된 유형 %2인 enum|%2 요소%s2|%ordinal2 요소 이름 %3|%ordinal2 요소 %3 %select{가|가 아님}4 초기화자 있음|%ordinal2 요소 %3가 다른 초기화자 있음|}1을 찾았습니다"
# "but in '%0' found %select{static assert with different condition|static assert with different message|static assert with %select{|no }2message|%select{method %3|constructor|destructor}2|%select{method %3|constructor|destructor}2 is %select{not deleted|deleted}4|%select{method %3|constructor|destructor}2 is %select{not defaulted|defaulted}4|%select{method %3|constructor|destructor}2 is %select{|pure }4%select{not virtual|virtual}5|%select{method %3|constructor|destructor}2 is %select{not static|static}4|%select{method %3|constructor|destructor}2 is %select{not volatile|volatile}4|%select{method %3|constructor|destructor}2 is %select{not const|const}4|%select{method %3|constructor|destructor}2 is %select{not inline|inline}4|%select{method %3|constructor|destructor}2 with %ordinal4 parameter with%select{out|}5 a default argument|%select{method %3|constructor|destructor}2 with %ordinal4 parameter with a different default argument|%select{method %3|constructor|destructor}2 with %select{no |}4template arguments|%select{method %3|constructor|destructor}2 with %4 template argument%s4|%select{method %3|constructor|destructor}2 with %4 for %ordinal5 template argument|%select{method %3|constructor|destructor}2 with %select{no body|body}4|%select{method %3|constructor|destructor}2 with different body|friend %select{class|function}2|friend %2|friend function %2|function template %2 with %3 template parameter%s3|function template %2 with %ordinal3 template paramter being a %select{type|non-type|template}4 template parameter|function template %2 with %ordinal3 template parameter %select{with no name|named %5}4|function template %2 with %ordinal3 template parameter with %select{no |}4default argument|function template %2 with %ordinal3 template parameter with default argument %4|function template %2 with %ordinal3 template parameter with different type|function template %2 with %ordinal3 template parameter %select{not |}4being a template parameter pack|}1"
H650FCD73F7BC: "하지만 '%0'에서 %select{조건이 다른 정적 어설트|메시지가 다른 정적 어설트|%select{없는|있는}2 메시지 정적 어설트|%select{메서드 %3|생성자|소멸자}2|%select{메서드 %3|생성자|소멸자}2가 %select{삭제되지 않음|삭제됨}4|%select{메서드 %3|생성자|소멸자}2가 %select{기본화되지 않음|기본화됨}4|%select{메서드 %3|생성자|소멸자}2가 %select{|순수 }4%select{비가상|가상}5|%select{메서드 %3|생성자|소멸자}2가 %select{비정적|정적}4|%select{메서드 %3|생성자|소멸자}2가 %select{비휘발성|휘발성}4|%select{메서드 %3|생성자|소멸자}2가 %select{비const|const}4|%select{메서드 %3|생성자|소멸자}2가 %select{비인라인|인라인}4|%select{메서드 %3|생성자|소멸자}2의 %ordinal4 매개변수 %select{기본 인자가 없음|기본 인자가 있음}5|%select{메서드 %3|생성자|소멸자}2의 %ordinal4 매개변수 기본 인자가 다름|%select{메서드 %3|생성자|소멸자}2의 %select{템플릿 매개변수가 없음|템플릿 매개변수가 있음}4|%select{메서드 %3|생성자|소멸자}2의 %4 템플릿 매개변수%s4|%select{메서드 %3|생성자|소멸자}2의 %4가 %ordinal5 템플릿 매개변수|%select{메서드 %3|생성자|소멸자}2의 %select{없는|있는}4 본문|%select{메서드 %3|생성자|소멸자}2의 본문이 다름|friend %select{클래스|함수}2|friend %2|friend 함수 %2|템플릿 함수 %2 %3 템플릿 매개변수%s3|템플릿 함수 %2의 %ordinal3 템플릿 매개변수 유형 %select{type|non-type|template}4|템플릿 함수 %2의 %ordinal3 템플릿 매개변수 %select{이름 없음|이름 %5 있음}4|템플릿 함수 %2의 %ordinal3 템플릿 매개변수 %select{기본 인자가 없음|기본 인자 있음}4|템플릿 함수 %2의 %ordinal3 템플릿 매개변수 기본 인자 %4|템플릿 함수 %2의 %ordinal3 템플릿 매개변수 유형 다름|템플릿 함수 %2의 %ordinal3 템플릿 매개변수 %select{아님|}4 템플릿 매개변수 팩|}1을 찾았습니다"
# "but in '%0' found %select{unnamed template parameter %2|template parameter %3|template parameter with %select{no |}2default argument|template parameter with different default argument}1"
HA18966A0FC1B: "하지만 '%0'에서 %select{이름이 지정되지 않은 템플릿 매개변수 %2|템플릿 매개변수 %3|템플릿 매개변수에 기본 인자가 %select{없는 |}2|다른 기본 인자가 있는 템플릿 매개변수}1을 발견했습니다."
# "by value capture of '*this' is incompatible with C++ standards before C++17"
H60BDFA125D23: "C++17 이전의 C++ 표준과 'this'를 값으로 캡처하는 것은 호환되지 않습니다."
# 'by-copy capture of value of abstract type %0'
H69470A21D7A2: '추상 형식 %0의 값에 대한 복사 포착'
# 'by-copy capture of variable %0 with %select{incomplete|sizeless}1 type %2'
H0B21D37A79AB: '변수 %0을 복사로 캡처할 때 %select{미완성|크기 없는}1 형식 %2를 사용했습니다.'
# 'cache-aware duplication strategy'
HF9F924A27610: '캐시 인식형 중복 전략'
# 'calculate and print various metrics for instruction cache'
HE98D77A3BA25: '명령 캐시에 대한 다양한 메트릭을 계산하고 출력합니다'
# 'call to %0 implicitly required by coroutine function here'
H58DB024E2029: '%0 호출은 코루틴 함수에 의해 여기서 암시적으로 필요합니다'
# 'call to %0 is ambiguous'
HE4A087079576: '함수 %0 호출이 모호합니다'
# 'call to %select{immediate|consteval}1 function %q0 is not a constant expression'
H00D075778CD9: '함수 %select{즉시|consteval}1 %q0의 호출은 상수 표현식이 아닙니다'
# 'call to %select{non-static|explicit}0 member function without an object argument'
H63B47EF20C66: '객체 인수가 없는 %select{non-static|explicit}0 멤버 함수 호출'
# 'call to %select{placement|class-specific}0 %1'
H295DBDE7B5BD: '%select{배치|클래스별}0 %1 호출'
# "call to '%0' declared with 'error' attribute: %1"
HDBB58BF71CEC: "‘error’ 속성으로 선언된 '%0'에 대한 호출: %1"
# "call to '%0' declared with 'warning' attribute: %1"
H3865B6C0D901: "함수 '%0'에 'warning' 속성이 지정되었습니다: %1"
# "call to '%select{__builtin_operator_new|__builtin_operator_delete}0' selects non-usual %select{allocation|deallocation}0 function"
H676581AF4E96: "함수 호출 '%select{__builtin_operator_new|__builtin_operator_delete}0'는 비정형 %select{할당|해제}0 함수를 선택합니다"
# "call to '%select{initial_suspend|final_suspend}0' implicitly required by the %select{initial suspend point|final suspend point}0"
H1C6B1E5ADCED: "'%select{초기_정지|최종_정지}0' 호출이 %select{초기 정지 지점|최종 정지 지점}0에 의해 암시적으로 필요합니다"
# "call to 'await_transform' implicitly required by 'co_await' here"
HA0503466B398: "여기서 'co_await'에 의해 'await_transform' 호출이 암시적으로 필요합니다"
# "call to a function that shares state other than 'za' from a function that has live 'za' state requires a spill/fill of ZA, which is not yet implemented"
H8FF6C74595CF: "za 외의 상태를 공유하는 함수를 활성화된 'za' 상태를 가진 함수에서 호출하는 것은 ZA의 스팸/필이 필요하지만, 아직 구현되지 않았습니다"
# 'call to a shared ZA function requires the caller to have ZA state'
H755688EF43BB: '공유 ZA 함수에 대한 호출은 호출자가 ZA 상태를 가져야 합니다'
# 'call to a shared ZT0 function requires the caller to have ZT0 state'
H89ACEBE543C2: 'ZT0 함수에 대한 호출은 호출자가 ZT0 상태를 가져야 합니다'
# "call to a streaming function requires 'sme'"
H41309CFB27F8: "스트리밍 함수 호출에는 'sme'가 필요합니다"
# 'call to constructor of %0 is ambiguous'
H00A38B0315FF: '%0의 생성자 호출이 모호합니다'
# 'call to deleted constructor of %0%select{|: %2}1'
HAA8E5FBCBA79: '%0의 삭제된 생성자를 호출했습니다%select{|: %2}1'
# 'call to deleted function call operator in type %0%select{|: %2}1'
H8F857BEAC26F: '유형 %0%select{ |: %2}1의 삭제된 함수 호출 연산자를 호출했습니다'
# 'call to deleted%select{| member}0 function %1%select{|: %3}2'
H6B002A51A7D4: '삭제된%select{| 멤버}0 함수 %1%select{|: %3}2'
# 'call to function %0 that is neither visible in the template definition nor found by argument-dependent lookup'
H225588528963: '템플릿 정의에서 가시적이也不是也不是인자 의존 탐색에 의해 발견되지 않은 함수 %0에 대한 호출'
# 'call to global function %0 not configured'
HC08574A55FB5: '전역 함수 %0를 호출할 수 없습니다: 구성되지 않았습니다'
# 'call to implicitly-deleted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|function}0 of %1'
H4C623CF7C837: '암시적으로 삭제된 %select{기본 생성자|복사 생성자|이동 생성자|복사 대입 연산자|이동 대입 연산자|소멸자|함수}0의 %1에 대한 호출'
# 'call to member function %0 is ambiguous'
H60EE3A6ABF6A: '멤버 함수 %0에 대한 호출이 애매합니다'
# 'call to object of type %0 is ambiguous'
H3783B2A8DBDC: '타입 %0의 객체에 대한 호출이 모호합니다'
# "call to pointer to member function of type %0 drops '%1' qualifier%s2"
HC75C3E40313D: "%0 형식의 멤버 함수 포인터 호출이 '%1' 자격 증명%s2를 제거합니다"
# 'call to pseudo-destructor cannot have any arguments'
H6ECE40631FC9: '가짜 소멸자의 호출에는 인수를 가질 수 없습니다'
# 'call to pure virtual member function %0 has undefined behavior; overrides of %0 in subclasses are not available in the %select{constructor|destructor}1 of %2'
HDC8AD43C5C1C: '순수 가상 멤버 함수 %0에 대한 호출은 정의되지 않은 동작을 가집니다; 하위 클래스에서의 %0의 오버라이드는 %2의 %select{생성자|소멸자}1에서 사용할 수 없습니다'
# 'call to subscript operator of type %0 is ambiguous'
H1E29AAB6AD84: '%0 유형의 구독 연산자의 호출이 모호합니다'
# 'call to undeclared function %0; ISO C99 and later do not support implicit function declarations'
HEBF384E2E2A6: '%0라는 선언되지 않은 함수를 호출했습니다; ISO C99 및 이후 버전은 암시적 함수 선언을 지원하지 않습니다'
# "call to undeclared library function '%0' with type %1; ISO C99 and later do not support implicit function declarations"
HF288A58FA40B: "미선언된 라이브러리 함수 '%0'를 호출했습니다; 형식은 %1입니다. ISO C99 및 이후 버전은 암시적 함수 선언을 지원하지 않습니다"
# 'call to unsupported expression with unknown type'
H239ACE39DA12: '지원되지 않는 표현식에 대한 호출: 알려지지 않은 형식'
# 'called by %0'
HDC9A013B796D: '%0에 의해 호출됨'
# 'called object type %0 is not a function or function pointer'
H5E3F97BDB14E: '호출된 객체 유형 %0는 함수나 함수 포인터가 아닙니다'
# 'callee declares array parameter as static here'
H80DA3F678F9A: '호출받는 함수가 여기서 배열 매개변수를 static으로 선언합니다'
# "calling %0 is a violation of trusted computing base '%1'"
HF890EA6739C7: "'%1' 신뢰 컴퓨팅 기반을 위반했습니다: %0를 호출했습니다"
# 'calling %0 with incomplete return type %1'
H218BBBD759BD: '불완전한 반환 형식 %1로 %0를 호출했습니다'
# "calling '%0' with a nonzero argument is unsafe"
H373CF9276563: "'%0'을(를) 0이 아닌 인수로 호출하는 것은 위험합니다."
# 'calling a %select{private|protected}0 constructor of class %2'
H1D7B9B5BEE0D: '클래스 %2의 %select{비공개|보호}0 생성자를 호출하는'
# 'calling a %select{private|protected}1 destructor of class %0'
H2870B0B82BD7: '클래스 %0의 %select{private|protected}1 소멸자를 호출 중입니다'
# "calling function %0 requires negative capability '%1'"
HB81388BC5C94: "함수 %0를 호출하려면 '%1' 부정 능력이 필요합니다"
# "calling function %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
HF6312AC18647: "함수 %1을 호출하려면 %0을 %select{'%2'|'%2' exclusively}3 확보해야 합니다."
# 'calling function with incomplete return type %0'
H47066D05EDB3: '불완전한 반환 형식을 가진 함수를 호출하는 중 %0'
# 'calls the given entry-point on a new thread (jit-kind=orc-lazy only)'
HD909298BB334: '지정된 entry-point를 새 스레드에서 호출합니다 (jit-kind=orc-lazy만 적용됨)'
# 'calls to OpenMP runtime API are not allowed within a region that corresponds to a construct with an order clause that specifies concurrent'
HF0FE255D765C: 'OpenMP 런타임 API의 호출은 order 절이 concurrent를 지정한 구조에 해당하는 구역 내에서 허용되지 않습니다.'
# 'can only access this member on an object of type %0'
H97DBB9710EB7: '이 멤버에 접근하려면 %0 유형의 객체에서만 가능합니다'
# 'can only poison identifier tokens'
HBA757282B22F: '식별자 토큰만 중독시킬 수 있습니다.'
# 'can only provide an explicit specialization for a class template, function template, variable template, or a member function, static data member, %select{or member class|member class, or member enumeration}0 of a class template'
H705307E2F906: '명시적 특수화를 제공할 수 있는 것은 클래스 템플릿, 함수 템플릿, 변수 템플릿, 또는 멤버 함수, 정적 데이터 멤버, %select{또는 멤버 클래스|멤버 클래스, 또는 멤버 열거형}0의 클래스 템플릿만입니다.'
# "can only use 'init_priority' attribute on file-scope definitions of objects of class type"
H2C248D12A320: "클래스 형식의 객체의 파일 범위 정의에만 'init_priority' 속성을 사용할 수 있습니다."
# 'candidate %select{constructor|template}0 ignored: inherited constructor cannot be used to %select{copy|move}1 object'
HA2E8E747932F: '후보 %select{constructor|template}0 무시됨: 상속된 생성자는 %select{copy|move}1 객체를 사용할 수 없습니다'
# 'candidate %select{constructor|template}0 ignored: instantiation %select{takes|would take}0 its own class type by value'
H5F81F51806D8: '후보 %select{생성자|템플릿}0 무시됨: 인스턴스화 %select{받는다|받을 것}0 자신의 클래스 타입을 값으로 전달'
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 has been %select{explicitly made unavailable|explicitly deleted|implicitly deleted}3"
HDF3920A3A1F2: "후보 %select{함수|함수|매개변수 순서가 반전된 함수|생성자|생성자 (암시적 기본 생성자)|생성자 (암시적 복사 생성자)|생성자 (암시적 이동 생성자)|함수 (암시적 복사 대입 연산자)|함수 (암시적 이동 대입 연산자)|함수 (이 'operator<=>'를 위한 암시적 'operator==')|상속된 생성자}0%select{ | 템플릿| %2}1는 %select{명시적으로 사용 불가능 처리됨|명시적으로 삭제됨|암시적으로 삭제됨}3"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %ordinal5 argument (%3) would lose %select{const|restrict|const and restrict|volatile|const and volatile|volatile and restrict|const, volatile, and restrict}4 qualifier%select{||s||s|s|s}4"
H95E4AEB3B23E: "%select{함수|함수|매개변수 순서 반전된 함수|생성자|기본 생성자(암시적)|복사 생성자(암시적)|이동 생성자(암시적)|복사 할당 연산자(암시적)|이동 할당 연산자(암시적)|'operator<=>'에 대한 'operator=='(암시적)|상속 생성자}0%select{| 템플릿| %2}1는 적용할 수 없음: %ordinal5 매개변수(%3)가 %select{const|restrict|const 및 restrict|volatile|const 및 volatile|volatile 및 restrict|const, volatile, restrict}4 자격 증명%select{||s||s|s|s}4를 잃게 됩니다"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %ordinal8 argument (%3) has %select{no '__ptrauth'|%5}4 qualifier, but parameter has %select{no '__ptrauth'|%7}6 qualifier"
HD856C23A94D5: "후보 %select{함수|함수|파라미터 순서가 반전된 함수|생성자|암시적 기본 생성자|암시적 복사 생성자|암시적 이동 생성자|암시적 복사 할당 연산자|암시적 이동 할당 연산자|operator<=>를 사용한 'operator=='의 암시적 함수|상속된 생성자}0%select{| 템플릿| %2}1 적합하지 않음: %ordinal8 번째 인수 (%3)는 %select{__ptrauth 없음|%5}4 자격을 갖추지 않았지만, 매개변수는 %select{__ptrauth 없음|%7}6 자격을 갖추고 있습니다"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %select{%ordinal7|'this'}6 argument (%3) has %select{no|__unsafe_unretained|__strong|__weak|__autoreleasing}4 ownership, but parameter has %select{no|__unsafe_unretained|__strong|__weak|__autoreleasing}5 ownership"
H8D414CDC2F4E: "후보 %select{함수|함수|파라미터 순서가 반전된 함수|생성자|암시적 기본 생성자|암시적 복사 생성자|암시적 이동 생성자|암시적 복사 대입 연산자 함수|암시적 이동 대입 연산자 함수|'operator<=>'에 대한 암시적 'operator==' 함수|상속된 생성자}0%select{| 템플릿| %2}1 적합하지 않음: %select{%ordinal7|'이'/'该项'}6 인수 (%3)는 %select{없음|__unsafe_unretained|__strong|__weak|__autoreleasing}4 소유권을 가지고 있지만, 파라미터는 %select{없음|__unsafe_unretained|__strong|__weak|__autoreleasing}5 소유권을 가집니다"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %select{%ordinal7|'this'}6 argument (%3) has %select{no|__weak|__strong}4 ownership, but parameter has %select{no|__weak|__strong}5 ownership"
HFD1E148AC849: "%select{함수|함수|매개변수 순서 반전된 함수|생성자|기본 생성자(암시적)|복사 생성자(암시적)|이동 생성자(암시적)|복사 할당 연산자(암시적)|이동 할당 연산자(암시적)|'operator<=>'에 대한 'operator=='(암시적)|상속 생성자}0%select{| 템플릿| %2}1는 적용할 수 없음: %select{%ordinal7|'this'}6 매개변수(%3)가 %select{없음|__weak|__strong}4 소유권을 가졌으나 매개변수는 %select{없음|__weak|__strong}5 소유권을 가집니다"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %select{cannot convert initializer list|too few initializers in list|too many initializers in list}7 argument to %4"
H4C57102C9323: "후보 %select{함수|함수|함수 (파라미터 순서가 반대)|생성자|생성자 (암시적 기본 생성자)|생성자 (암시적 복사 생성자)|생성자 (암시적 이동 생성자)|함수 (암시적 복사 대입 연산자)|함수 (암시적 이동 대입 연산자)|함수 (이 'operator<=>'에 대한 암시적 'operator==')|상속된 생성자}0%select{| 템플릿| %2}1 적합하지 않음: %select{초기화자 목록을 변환할 수 없음|목록에 초기화자가 너무 적음|목록에 초기화자가 너무 많음}7 %4 인수"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %select{requires at least|allows at most single|requires single}3 %select{|non-object }6argument %4, but %plural{0:no|:%5}5 arguments were provided"
H8AD4B8B6097C: "후보 %select{함수|함수|매개변수 순서가 반전된 함수|생성자|암시적 기본 생성자|암시적 복사 생성자|암시적 이동 생성자|암시적 복사 대입 연산자|암시적 이동 대입 연산자|'operator<=>'에 대한 암시적 'operator=='|상속된 생성자}0%select{ | 템플릿| %2}1 적합하지 않음: %select{최소|최대 단일|단일}3 %select{ |비객체 }6인수 %4가 필요하지만, %plural{0:인수가 없음|:%5}5 인수가 제공되었습니다"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: 'this' argument has type %3, but method is not marked %select{const|restrict|const or restrict|volatile|const or volatile|volatile or restrict|const, volatile, or restrict}4"
HE6BBB39EEE68: "후보 %select{함수|함수|매개변수 순서가 반대로 된 함수|생성자|암시적 기본 생성자|암시적 복사 생성자|암시적 이동 생성자|암시적 복사 할당 연산자|암시적 이동 할당 연산자|'operator<=>'에 대한 암시적 'operator=='|상속된 생성자}0%select{| 템플릿| %2}1 적합하지 않음: 'this' 인수의 유형은 %3이지만, 메서드가 %select{const|restrict|const 또는 restrict|volatile|const 또는 volatile|volatile 또는 restrict|const, volatile 또는 restrict}4로 표시되지 않음"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: 'this' object is in %3, but method expects object in %4"
H7EDBF536C9E0: "후보 %select{함수|함수|매개변수 순서가 반전된 함수|생성자|생성자 (암시적 기본 생성자)|생성자 (암시적 복사 생성자)|생성자 (암시적 이동 생성자)|함수 (암시적 복사 대입 연산자)|함수 (암시적 이동 대입 연산자)|함수 (이 'operator<=>'를 위한 암시적 'operator==')|상속된 생성자}0%select{ | template| %2}1 적합하지 않음: 'this' 객체는 %3에 있으나, 메서드는 %4에 있는 객체를 요구합니다"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: call to %select{__device__|__global__|__host__|__host__ __device__|invalid}3 function from %select{__device__|__global__|__host__|__host__ __device__|invalid}4 function"
HB286FD7ADB16: "후보 %select{함수|함수|역순 매개변수 인수의 함수|생성자|암시적 기본 생성자|암시적 복사 생성자|암시적 이동 생성자|암시적 복사 대입 연산자|암시적 이동 대입 연산자|이 'operator<=>'를 위한 암시적 'operator=='|상속된 생성자}0%select{| 템플릿| %2}1 유효하지 않음: %select{__device__|__global__|__host__|__host__ __device__|잘못된}3 함수에서 %select{__device__|__global__|__host__|__host__ __device__|잘못된}4 함수 호출"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: cannot %select{convert from|convert from|bind}3 %select{base class pointer|superclass|base class object of type}3 %4 to %select{derived class pointer|subclass|derived class reference}3 %5 for %ordinal6 argument"
H9EF538024430: "후보 %select{함수|함수|파라미터 순서가 반전된 함수|생성자|암시적 기본 생성자|암시적 복사 생성자|암시적 이동 생성자|암시적 복사 대입 연산자|암시적 이동 대입 연산자|'operator<=>'에 대한 암시적 'operator=='|상속된 생성자}0%select{| 템플릿| %2}1 적합하지 않음: %ordinal6 인자에서 %select{기초 클래스 포인터|상위 클래스|기초 클래스 객체 형식}3 %4를 %select{파생 클래스 포인터|하위 클래스|파생 클래스 참조}3 %5로 %select{변환|변환|바인딩}3할 수 없음"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: cannot %select{pass pointer to|bind reference in}5 %3 %select{as a pointer to|to object in}5 %4 in %ordinal6 argument"
HEE13EA6B12B0: "후보 %select{함수|함수|함수 (매개변수 순서 반전)|생성자|암시적 기본 생성자|암시적 복사 생성자|암시적 이동 생성자|암시적 복사 대입 연산자|암시적 이동 대입 연산자|암시적 'operator==' (operator<=>에 대한)|상속된 생성자}0%select{ | 템플릿| %2}1 적합하지 않음: %select{포인터를 전달할 수 없음|리퍼런스를 바인드할 수 없음}5 %3 %select{포인터로 | 객체로}5 %4 %ordinal6 인자"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: cannot convert argument of incomplete type %diff{$ to $|to parameter type}3,4 for %select{%ordinal6 argument|object argument}5%select{|; dereference the argument with *|; take the address of the argument with &|; remove *|; remove &}7"
H3F2CD3D64E80: "후보 %select{함수|함수|매개변수 순서가 반대인 함수|생성자|암시적 기본 생성자|암시적 복사 생성자|암시적 이동 생성자|암시적 복사 대입 연산자 함수|암시적 이동 대입 연산자 함수|이 'operator<=>'에 대한 'operator=='의 암시적 함수|상속된 생성자}0%select{| 템플릿| %2}1 유효하지 않음: 불완전한 형식의 인수를 %diff{$를 $로 |매개변수 형식으로}3,4로 변환할 수 없음 %select{%ordinal6 인자|객체 인자}5%select{|; 인수에 별칭을 적용하세요|; 인수에 & 연산자를 적용하세요|; *를 제거하세요|; &를 제거하세요}7"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: cannot implicitly convert argument %diff{of type $ to $|type to parameter type}3,4 for %select{%ordinal6 argument|object argument}5 under ARC"
H2B5B49758162: "후보 %select{함수|함수|매개변수 순서가 반전된 함수|생성자|암시적 기본 생성자|암시적 복사 생성자|암시적 이동 생성자|암시적 복사 할당 연산자|암시적 이동 할당 연산자|이 'operator<=>'에 대한 암시적 'operator=='|상속된 생성자}0%select{| 템플릿| %2}1 사용할 수 없음: %diff{타입 $를 $로 암시적으로 변환할 수 없음|매개변수 타입으로의 타입 변환 실패}3,4 %select{%ordinal6 인자|객체 인자}5에 적용됨 (ARC 하에서)"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: constraints not satisfied"
H01514E19EB13: "%select{함수|함수|매개변수 순서 반전된 함수|생성자|기본 생성자(암시적)|복사 생성자(암시적)|이동 생성자(암시적)|복사 할당 연산자(암시적)|이동 할당 연산자(암시적)|'operator<=>'에 대한 'operator=='(암시적)|상속 생성자}0%select{| 템플릿| %2}1는 적용할 수 없음: 제약 조건이 충족되지 않았습니다"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: expects an %select{lvalue|rvalue}5 for %select{%ordinal4 argument|object argument}3"
H5778CD649B7A: "후보 %select{함수|함수|역순 매개변수를 가진 함수|생성자|암시적 기본 생성자|암시적 복사 생성자|암시적 이동 생성자|암시적 복사 대입 연산자|암시적 이동 대입 연산자|암시적 'operator==' (operator<=>를 위해)|상속된 생성자}0%select{| 템플릿| %2}1 사용 불가: %select{%ordinal4 인자|객체 인자}3로 %select{왼쪽값|오른쪽값}5가 필요합니다"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: no known conversion %diff{from $ to $|from argument type to parameter type}3,4 for %select{%ordinal6 argument|object argument}5%select{|; dereference the argument with *|; take the address of the argument with &|; remove *|; remove &}7"
H2C02021665E8: "후보 %select{함수|함수|파라미터 순서가 반전된 함수|생성자|암시적 기본 생성자|암시적 복사 생성자|암시적 이동 생성자|암시적 복사 대입 연산자 함수|암시적 이동 대입 연산자 함수|operator<=>를 위한 암시적 'operator==' 함수|상속된 생성자}0%select{| 템플릿| %2}1 사용 불가: %diff{ $에서 $로 |인수 유형에서 매개변수 유형으로}3,4 형변환이 존재하지 않습니다 %select{%ordinal6 인수|객체 인수}5에 대해 %select{|; 인수에 *로 deference 하세요|; & 연산자로 인수의 주소를 취하세요|; *를 제거하세요|; &를 제거하세요}7"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: no overload of %4 matching %3 for %ordinal5 argument"
H327F9AFBF1B4: "후보 %select{함수|함수|함수 (매개변수 순서 반전)|생성자|생성자 (암시적 기본 생성자)|생성자 (암시적 복사 생성자)|생성자 (암시적 이동 생성자)|함수 (암시적 복사 대입 연산자)|함수 (암시적 이동 대입 연산자)|함수 (이 'operator<=>'에 대한 암시적 'operator==')|상속된 생성자}0%select{ | 템플릿| %2}1 적합하지 않음: 오버로드 %4 중 %3과 일치하는 %ordinal5번째 인자에 대한 것이 없습니다."
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: requires%select{ at least| at most|}3 %4 %select{|non-object }6argument%s4, but %5 %plural{1:was|:were}5 provided"
HE70B20B055FA: "후보 %select{함수|함수|매개변수 역순인 함수|생성자|암시적 기본 생성자|암시적 복사 생성자|암시적 이동 생성자|암시적 복사 대입 연산자|암시적 이동 대입 연산자|operator<=>의 암시적 'operator=='|상속된 생성자}0%select{| 템플릿| %2}1은 적용되지 않음: %select{최소|최대|}3 %4 %select{|비객체 }6인자%s4가 필요하지만 %5 %plural{1:는|:들은}5 제공되었습니다"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %3}1%select{| has different class%diff{ (expected $ but has $)|}5,6| has different number of parameters (expected %5 but has %6)| has type mismatch at %ordinal5 parameter%diff{ (expected $ but has $)|}6,7| has different return type%diff{ ($ expected but has $)|}5,6| has different qualifiers (expected %5 but found %6)| has different exception specification}4"
H8C85DA7348D1: "후보 %select{함수|함수|매개변수 순서가 반대인 함수|생성자|암시적 기본 생성자|암시적 복사 생성자|암시적 이동 생성자|암시적 복사 대입 연산자|암시적 이동 대입 연산자|암시적 'operator<=>'에 대한 'operator=='|상속된 생성자}0%select{ | 템플릿 | %3}1%select{ | 다른 클래스를 가짐%diff{ (기대한 $ 대신 $ 가 있음)|}5,6 | 매개변수 개수가 다름 (예상 %5개 대신 %6개 있음)| %ordinal5 번째 매개변수 타입 불일치%diff{ (기대한 $ 대신 $ 가 있음)|}6,7| 반환 타입이 다름%diff{ ($ 예상됨이 $ 로 있음)|}5,6| 형식 지정자가 다름 (예상 %5 이었으나 %6 발견)| 예외 지정식이 다름}4"
# 'candidate address cannot be taken because parameter %0 has pass_object_size attribute'
H9C284929AC5A: '후보 주소를 얻을 수 없습니다. 매개변수 %0가 pass_object_size 속성을 가지고 있기 때문입니다.'
# 'candidate constructor ignored: cannot be used to construct an object in address space %0'
H02A4FA176268: '후보 생성자가 무시됨: 주소 공간 %0에 객체를 생성하는 데 사용될 수 없습니다'
# 'candidate disabled: %0'
H7028C3991AD2: '후보가 비활성화됨: %0'
# 'candidate found by name lookup is %q0'
H25F5CFEAA3CA: '이름 검색을 통해 찾은 후보는 %q0입니다'
# 'candidate function made ineligible by enable_if'
HF67E18BC374D: 'enable_if로 인해 부적격이 된 후보 함수'
# 'candidate function with non-reversed arguments'
H8514B0198804: '역순이 아닌 인수를 가진 후보 함수'
# 'candidate ignored: %select{not a function template|not a member of the enclosing %select{class template|namespace; did you mean to explicitly qualify the specialization?}1}0'
H46E51FE9BF5C: '후보가 무시되었습니다: %select{함수 템플릿이 아닙니다|포함하는 %select{클래스 템플릿|네임스페이스; 특수화를 명시적으로 지정하려는 것이면?}1의 멤버가 아닙니다}0'
# 'candidate template ignored: cannot deduce a type for %0 that would make %2 equal %1'
H7E4350C35AB8: '후보 template 무시됨: %0에 대한 타입을 유추할 수 없어 %2가 %1과 같도록 할 수 없습니다'
# 'candidate template ignored: constraints not satisfied%0'
H6E9C2A6AF9DA: '템플릿 후보가 무시됨: 제약 조건이 충족되지 않음%0'
# 'candidate template ignored: could not match %diff{$ against $|types}0,1'
HBFC6A5130527: '템플릿 후보 무시됨: %diff{$와 $를 매칭할 수 없음|형식}1,0을 일치시킬 수 없습니다'
# 'candidate template ignored: could not match %q0 against %q1'
H95615A85BC94: '후보 템플릿 무시됨: %q0을(를) %q1과(와) 일치시키지 못했습니다'
# "candidate template ignored: couldn't infer template argument %0"
H0865F809FC7F: '후보 템플릿이 무시됨: %0 템플릿 인수를 추론할 수 없음'
# 'candidate template ignored: deduced %select{conflicting types|conflicting values|conflicting templates|packs of different lengths}0 for parameter %1%diff{ ($ vs. $)|}2,3'
HC96827B6C1DA: '후보 템플릿 무시됨: 매개변수 %1에 대한 추론된 %select{충돌하는 유형|충돌하는 값|충돌하는 템플릿|길이가 다른 패키지}0%diff{ ($ 와 $ 의 충돌)|}2,3'
# 'candidate template ignored: deduced too few arguments for expanded pack %0; no argument for %ordinal1 expanded parameter in deduced argument pack %2'
HCCA72493BB47: '후보 템플릿 무시됨: 확장된 패키지 %0에 대해 추론된 인자가 너무 적음; 추론된 인자 패키지 %2에서 %ordinal1 확장 매개변수에 대한 인자가 없음'
# 'candidate template ignored: deduced type %diff{$ of %select{|element of }4%ordinal0 parameter does not match adjusted type $ of %select{|element of }4argument|of %select{|element of }4%ordinal0 parameter does not match adjusted type of %select{|element of }4argument}1,2%3'
HF6006A393B95: '템플릿 후보 무시됨: %diff{$ %select{|요소의 }4%ordinal0 매개변수가 조정된 %select{|요소의 }4인수 유형 $와 일치하지 않음|의 %select{|요소의 }4%ordinal0 매개변수가 조정된 %select{|요소의 }4인수 유형과 일치하지 않음}1,2%3'
# 'candidate template ignored: deduced values %diff{of conflicting types for parameter %0 (%1 of type $ vs. %3 of type $)|%1 and %3 of conflicting types for parameter %0}2,4'
H300B96CC7A66: '후보 템플릿 무시됨: 매개변수 %0의 모순된 타입의 추론 값 %diff{(%1의 타입 $와 %3의 타입 $ 사이의 비교)|%1과 %3이 매개변수 %0에 대해 모순된 타입}2,4'
# 'candidate template ignored: disabled by %0%1'
H0A4EC193E9D6: '후보 템플릿 무시됨: %0%1에 의해 비활성화됨'
# 'candidate template ignored: failed template argument deduction'
HF2D6EBE56EA1: '후보 템플릿 무시됨: 템플릿 인수 추론 실패'
# 'candidate template ignored: invalid explicitly-specified argument for %ordinal0 template parameter'
H7C80ECA5E832: '후보 템플릿 무시됨: %ordinal0 템플릿 매개변수에 대한 잘못된 명시적으로 지정된 인자'
# 'candidate template ignored: invalid explicitly-specified argument for template parameter %0'
HEDC828688F33: '후보 템플릿이 무시되었습니다: 템플릿 매개변수 %0에 대한 유효하지 않은 명시적으로 지정된 인수'
# "candidate template ignored: requirement '%0' was not satisfied%1"
HB155E3417C9D: "후보 템플릿이 무시됨: '%0' 조건이 충족되지 않았습니다%1"
# 'candidate template ignored: substitution exceeded maximum template instantiation depth'
H6065ACD0EE36: '후보 템플릿 무시됨: 대체 과정에서 최대 템플릿 인스턴스화 깊이 초과'
# 'candidate template ignored: substitution failure%0%1'
HF32FE861D856: '후보 템플릿 무시됨: 치환 실패%0%1'
# 'candidate template ignored: target attributes do not match'
H8F2E4648A7AB: '후보 템플릿 무시됨: 타겟 속성이 일치하지 않음'
# "cannot %select{#include files|import headers}0 inside '#pragma clang arc_cf_code_audited'"
HE8C6864AFFBD: "'#pragma clang arc_cf_code_audited' 안에서 %select{#include 파일을 포함|헤더를 가져오기}0할 수 없습니다"
# "cannot %select{#include files|import headers}0 inside '#pragma clang assume_nonnull'"
H5A02E21DB221: " '#pragma clang assume_nonnull' 내부에서 %select{#include 파일|#import 헤더}0는 사용할 수 없습니다"
# 'cannot %select{access base class of|access derived class of|access field of|access array element of|ERROR|access real component of|access imaginary component of}0 pointer past the end of object'
HBEBB0813D273: '객체의 끝을 넘어가는 포인터에 %select{기반 클래스의|파생 클래스의|필드의|배열 요소의|ERROR|실수 성분의|허수 성분의}0 접근할 수 없습니다'
# 'cannot %select{access base class of|access derived class of|access field of|access array element of|perform pointer arithmetic on|access real component of|access imaginary component of}0 null pointer'
H2E784B2C1B28: '널 포인터의 %select{기반 클래스를 액세스|파생 클래스를 액세스|필드를 액세스|배열 요소를 액세스|포인터 산술을 수행|실수 성분을 액세스|허수 성분을 액세스}0할 수 없습니다.'
# "cannot %select{assign to %select{object|'%1'}2 with|pass argument to %select{parameter|parameter '%1'}2 with|return|convert to|%select{|implicitly }3initialize %select{object|'%1'}2 with|pass argument to parameter with|cast to|pass argument to parameter with}0 '%5' attributed type %4 because the pointee type %6 is incomplete"
H1CA72EC4A20B: "특성 유형 %4인 '%5'로 %select{ %select{객체|'%1'}2에 할당하여 | %select{매개변수|매개변수 '%1'}2에 인수 전달하여 | 반환하여 | 변환하여 | %select{|암시적으로 }3%select{객체|'%1'}2 초기화하여 | 매개변수에 인수 전달하여 | 형 변환하여 | 매개변수에 인수 전달하여 }0 할 수 없습니다. 포인티 타입 %6은 완전하지 않기 때문입니다."
# 'cannot %select{assign|return|throw|subscript}0 a WebAssembly table'
H1D574B1BA9C6: 'WebAssembly 테이블에 %select{할당|반환|던지|인덱싱}0할 수 없습니다.'
# 'cannot %select{capture|take address of}0 WebAssembly reference'
H1706BDA5F276: 'WebAssembly 참조를 %select{포획할 수 없습니다|주소를 취할 수 없습니다}0'
# 'cannot %select{decrement|increment}0 expression of enum type %1'
H9709AF91935B: 'enum 형식 %1의 식을 %select{감소|증가}0할 수 없습니다.'
# 'cannot %select{decrement|increment}1 value of type %0'
H7C6ED23E2E9F: '형식 %0의 값을 %select{감소|증가}1할 수 없습니다.'
# 'cannot %select{throw|catch}0 a WebAssembly reference type'
H3CB66A7D1B81: 'WebAssembly 참조 형식을 %select{throw|catch}0할 수 없습니다.'
# "cannot %select{use '%1' with '%4' attributed|call '%1' with '%4' attributed return}0 type %2 because the pointee type %3 is incomplete"
HF83C2ECBEF93: "완전하지 않은 포인티 타입 %3 때문에 %select{'%1'에 '%4' 속성을 가진|'%1'에 '%4' 속성을 가진 반환값 호출}0 타입 %2를 사용할 수 없습니다"
# "cannot %select{use builtin operator '<=>'|default 'operator<=>'}1 because type '%0' was not found; include <compare>"
H40A5A6DFAC87: "타입 '%0'이 발견되지 않아 %select{builtin 연산자 '<=>'을 사용할 수 없음|기본 'operator<=>'을 사용할 수 없음}1입니다; <compare> 헤더를 포함하세요"
# 'cannot %select{use type %1 for a function/method parameter|use type %1 for function/method return|default-initialize an object of type %1|declare an automatic variable of type %1|copy-initialize an object of type %1|assign to a variable of type %1|construct an automatic compound literal of type %1|capture a variable of type %1|cannot use volatile type %1 where it causes an lvalue-to-rvalue conversion}3 since it %select{contains|is}2 a union that is non-trivial to %select{default-initialize|destruct|copy}0'
H72F7777296D1: '%select{함수/메서드 매개변수에 유형 %1을 사용할 수 없습니다|함수/메서드 반환 값에 유형 %1을 사용할 수 없습니다|유형 %1의 개체를 기본 초기화할 수 없습니다|유형 %1의 자동 변수를 선언할 수 없습니다|유형 %1의 개체를 복사 초기화할 수 없습니다|유형 %1의 변수에 할당할 수 없습니다|유형 %1의 자동 복합 리터럴을 생성할 수 없습니다|유형 %1의 변수를 캡처할 수 없습니다|volatile 유형 %1을 lvalue-to-rvalue 변환을 유발하는 위치에서 사용할 수 없습니다}3는 이 유형이 %select{포함합니다|입니다}2 비平凡(non-trivial)인 %select{기본 초기화|해제|복사}0 때문입니다'
# 'cannot %select{||reinterpret_cast||C-style cast||}0 from member pointer type %1 to member pointer type %2 of different size'
H4DC29F600065: '멤버 포인터 형식 %1에서 다른 크기의 멤버 포인터 형식 %2로 %select{||reinterpret_cast||C-style cast||}0 할 수 없습니다'
# "cannot add 'abi_tag' attribute in a redeclaration"
H48F70104AB1E: "재선언에서 'abi_tag' 속성을 추가할 수 없습니다."
# 'cannot add a default template argument to the definition of a member of a class template'
H770ED38EE4A2: '클래스 템플릿의 멤버 정의에 기본 템플릿 인수를 추가할 수 없습니다'
# 'cannot allocate %select{function|reference}1 type %0 with new'
HA111D2195E5D: 'new 연산자를 사용하여 %select{함수|참조}1 타입 %0을 할당할 수 없습니다'
# "cannot allocate array of 'auto'"
H63BE6FF3ACD1: 'auto 형 배열을 할당할 수 없습니다.'
# "cannot allocate array; evaluated array bound %0 exceeds the limit (%1); use '-fconstexpr-steps' to increase this limit"
H786F30B07D61: "배열을 할당할 수 없습니다; 계산된 배열 경계 %0이 한계값 (%1)을 초과했습니다; '-fconstexpr-steps' 옵션을 사용하여 이 한계값을 늘릴 수 있습니다"
# 'cannot allocate array; evaluated array bound %0 is negative'
H5D0D0D0008CA: '배열을 할당할 수 없습니다; 계산된 배열 크기 %0가 음수입니다'
# 'cannot allocate array; evaluated array bound %0 is too large'
H7762F6A6D3EC: '배열을 할당할 수 없습니다; 계산된 배열 경계 %0이 너무 큽니다'
# 'cannot allocate array; evaluated array bound %0 is too small to hold %1 explicitly initialized elements'
H33075FED0F6C: '배열을 할당할 수 없습니다; 계산된 배열 경계 %0는 %1개의 명시적으로 초기화된 요소를 저장하기에는 너무 작습니다'
# 'cannot allocate memory of %select{incomplete|function}0 type %1'
H1CE3476A2AA9: '부분 완성된 타입 또는 함수 타입과 같은 %select{incomplete|function}0 타입 %1의 메모리를 할당할 수 없습니다'
# "cannot allocate untyped memory in a constant expression; use 'std::allocator<T>::allocate' to allocate memory of type 'T'"
H659085361859: "상수 표현식에서 타입이 지정되지 않은 메모리를 할당할 수 없습니다; 'std::allocator<T>::allocate'를 사용하여 'T' 형식의 메모리를 할당하세요."
# "cannot apply AST actions to LLVM IR file '%0'"
HB65858D558EB: "LLVM IR 파일 '%0'에 AST 작업을 적용할 수 없습니다"
# 'cannot apply asm label to %select{variable|function}0 after its first use'
H75A6849C042D: 'cannot apply asm label to %select{변수|함수}0 after its first use'
# "cannot assign to 'self' in a class method"
HA56E4ED9D1F5: "클래스 메서드 내에서 'self'에 대입할 수 없습니다"
# "cannot assign to 'self' outside of a method in the init family"
HC5091C795252: "init 가족 메서드 외부에서는 'self'에 할당할 수 없습니다"
# 'cannot assign to a variable captured by copy in a non-mutable lambda'
H135A3A08A93B: '비가변 람다에서 복사로 캡처된 변수에 할당할 수 없습니다.'
# 'cannot assign to class object (%0 invalid)'
H25AF70C115F7: 'class 객체에 할당할 수 없습니다 (%0 무효입니다)'
# "cannot assign to this %select{dictionary|array}1 because assigning method's 2nd parameter of type %0 is not an Objective-C pointer type"
H33D10E761543: '이 %select{dictionary|array}1에 할당할 수 없습니다. 할당하는 메서드의 두 번째 매개변수 %0 형식이 Objective-C 포인터 형식이 아니기 때문입니다'
# 'cannot befriend target of using declaration'
H72752EB56616: 'using 선언문의 대상을 친구로 지정할 수 없습니다'
# 'cannot bind non-lvalue argument %0 to %select{|in}1out paramemter'
HD7C1DD47E42B: 'lvalue가 아닌 인수 %0을/를 %select{|입력}1출력 매개변수에 바인딩할 수 없습니다.'
# 'cannot build range expression with array function parameter %0 since parameter with array type %1 is treated as pointer type %2'
H882392B5B8E6: '배열 형식의 함수 매개변수 %0를 사용해 범위 표현식을 생성할 수 없습니다. 매개변수 %1의 배열 형식은 %2 포인터 형식으로 간주되기 때문입니다'
# "cannot call function '%1' while %0 '%2' is held"
HE0B68C2EF3F0: "while %0 '%2' 보유 중일 때 %1 함수를 호출할 수 없습니다"
# 'cannot call operator __uuidof on a type with multiple GUIDs'
H6DB6EE36C688: '여러 개의 GUID를 가진 타입에 __uuidof 연산자를 호출할 수 없습니다.'
# 'cannot call operator __uuidof on a type with no GUID'
HCAE7CA56FF69: 'GUID가 없는 형식에 __uuidof 연산자를 호출할 수 없습니다'
# 'cannot capture __autoreleasing variable in a %select{block|lambda by copy}0'
H9DA2D963C91D: '복사로 %select{블록|람다}0에서 __autoreleasing 변수를 포착할 수 없습니다'
# 'cannot cast %0 to %1 via virtual base %2'
H794ABE3B9398: '가상 기반 클래스 %2를 통해 %0에서 %1로 형변환할 수 없습니다'
# 'cannot cast %0 to its %select{private|protected}2 base class %1'
H7E4D1C189883: '형 변환할 수 없습니다: %0를 %select{비공개|보호}2 기반 클래스 %1로'
# 'cannot cast %select{private|protected}2 base class %1 to %0'
HEB1FE12D1532: '%select{비공개|보호된}2 기반 클래스 %1을 %0로 형 변환할 수 없습니다'
# 'cannot cast %select{to|from}0 a WebAssembly table'
H608D936A86AA: 'WebAssembly 테이블 %select{으로|에서}0 캐스트할 수 없습니다'
# "cannot cast 'super' (it isn't an expression)"
H77DA1D89D4EF: '‘super’는 형 변환할 수 없습니다(이것은 표현식이 아닙니다)'
# "cannot cast an object of type %select{'nullptr_t' to %1|%1 to 'nullptr_t'}0"
H379020AFC623: "형식 %select{'nullptr_t'를 %1로|%1을 'nullptr_t'로}0 캐스팅할 수 없습니다"
# 'cannot cast from lvalue of type %1 to rvalue reference type %2; types are not compatible'
HD498E8671ADF: '타입 %1의 lvalue에서 타입 %2의 rvalue 참조 형식으로 형 변환할 수 없습니다; 타입이 호환되지 않습니다'
# 'cannot cast from rvalue of type %1 to rvalue reference type %2; types are not compatible'
H81F8D1E74E50: '형변환이 불가능합니다: %1 형식의 오른쪽 값에서 %2 오른쪽 값 참조 형식으로; 타입이 호환되지 않습니다'
# 'cannot cast from type %1 to member pointer type %2'
HC0F42A4D9625: '형 %1을 멤버 포인터 타입 %2로 캐스팅할 수 없습니다'
# 'cannot cast from type %1 to pointer type %2'
H1C20AF9781FF: '형 %1을(를) 포인터 형 %2로 캐스팅할 수 없습니다.'
# "cannot cast non-zero value '%0' to 'event_t'"
HB63F6FC3F823: "0이 아닌 값 '%0'을 'event_t'로 캐스팅할 수 없습니다"
# 'cannot cast object of dynamic type %0 to type %1'
H29A99B2195B9: '동적 타입 %0인 객체를 타입 %1로 형변환이 불가능합니다'
# "cannot cast to '__ptrauth'-qualified type %0"
H6496D0FA4BB0: "'__ptrauth'-qualifier가 있는 타입 %0로 캐스팅할 수 없습니다"
# 'cannot catch %select{|reference to }0sizeless type %1'
HFDB51E9BFE05: '크기 없는 타입 %1을 %select{참조 |}0로 잡을 수 없습니다'
# 'cannot catch an Objective-C object by value'
HE53524ADBBC8: '값으로 Objective-C 객체를 잡을 수 없습니다'
# 'cannot catch an exception thrown with @throw in C++ in the non-unified exception model'
HA5FD18981E9C: '비일원화 예외 모델에서 C++의 @throw로 던진 예외를 잡을 수 없습니다.'
# 'cannot catch exceptions by rvalue reference'
H5BF423F821AB: 'rvalue 참조로 예외를 잡을 수 없습니다.'
# 'cannot catch incomplete type %0'
H712DCF7BC1DF: '불완전한 형식 %0를 잡을 수 없습니다'
# 'cannot catch pointer to incomplete type %0'
H555C8CE71019: '%0 완전하지 않은 형식의 포인터를 잡을 수 없습니다.'
# 'cannot catch reference to incomplete type %0'
HAB26C8BE4E6D: '완성되지 않은 형식 %0에 대한 참조를 잡을 수 없습니다'
# 'cannot catch variably modified type %0'
H3E0D097A06D0: '가변 길이 타입 %0을 잡을 수 없습니다'
# 'cannot combine GNU and %select{SVE|RVV}0 vectors in expression, result is ambiguous (%1 and %2)'
H6D9DAA9A57DC: '표현식에서 GNU와 %select{SVE|RVV}0 벡터를 결합할 수 없습니다. %1과 %2로 인해 결과가 모호합니다'
# 'cannot combine fixed-length and sizeless %select{SVE|RVV}0 vectors in expression, result is ambiguous (%1 and %2)'
H3EDDFBE7A4DF: '고정 길이와 크기 없는 %select{SVE|RVV}0 벡터는 표현식에서 결합할 수 없습니다. 결과가 모호합니다 (%1과 %2)'
# "cannot combine with previous '%0' declaration specifier"
H4EE2F7A93C38: "이전의 '%0' 선언 지정자와 결합할 수 없습니다"
# "cannot combine with previous '%0' declaration specifier. '__vector' must be first"
H856686567DB2: "이전 '%0' 선언 지정자와 결합할 수 없습니다. '__vector'는 첫 번째로 지정되어야 합니다"
# 'cannot compile this %0 yet'
H395022428A23: '이 %0은 아직 컴파일할 수 없습니다'
# 'cannot compress debug sections (%0 not enabled)'
HB2DFAB48BA84: '디버그 섹션을 압축할 수 없습니다 (%0이 활성화되지 않았습니다)'
# 'cannot compute offset of bit-field %0'
H55C2FB73C827: '비트 필드 %0의 오프셋을 계산할 수 없습니다'
# "cannot constant evaluate '%select{memcpy|memmove}0' between objects of incomplete type %1"
H474B41288CFB: "완전하지 않은 형식 %1의 객체 사이에서 '%select{memcpy|memmove}0'를 상수 평가할 수 없습니다"
# "cannot constant evaluate '%select{memcpy|memmove}0' between objects of non-trivially-copyable type %1"
H4AA44A4233D2: "상수 평가할 수 없습니다 '%select{memcpy|memmove}0': 비 단순 복사 가능 형식의 객체 사이에서 %1"
# "cannot constant evaluate '%select{memcpy|memmove}0' from object of type %1 to object of type %2"
H6FAB8AA1F441: "상수 평가할 수 없습니다 '%select{memcpy|memmove}0'를 형식 %1의 객체에서 형식 %2의 객체로"
# 'cannot constant evaluate the result of adjusting alignment to %0'
H8F0F0485C85D: '정렬을 %0로 조정한 결과를 상수 평가할 수 없습니다.'
# 'cannot constant evaluate whether run-time alignment is at least %0'
H8DC5B278E189: '실행 시 정렬이 최소 %0인지 상수 평가할 수 없습니다'
# 'cannot construct object of type %0 with virtual base class in a constant expression'
H7DD1FDBBEF06: '상수 표현식 내에서 가상 기반 클래스를 갖는 %0 형식의 객체를 생성할 수 없습니다'
# 'cannot convert %0 token to an identifier'
H18B9F6746EBF: '%%0 토큰을 식별자로 변환할 수 없습니다'
# 'cannot convert %1 to %2 without a conversion operator'
H703415593D2A: '변환 연산자를 사용하지 않고 %1을 %2로 변환할 수 없습니다'
# 'cannot convert between %select{scalar|vector}0 type %1 and vector type %2 as implicit conversion would cause truncation'
HF046F296A9B0: '%select{스칼라|벡터}0 형 %1과 벡터 형 %2 사이의 암시적 변환은 트림을 유발하므로 변환할 수 없습니다'
# 'cannot convert between vector and non-scalar values (%0 and %1)'
HD81F5D7E2B16: '벡터와 비스칼라 값 사이에 변환할 수 없습니다. (%0과 %1)'
# 'cannot convert between vector values of different size (%0 and %1)'
H8810EF643AA5: '다른 크기의 벡터 값 사이에 변환할 수 없습니다. (%0과 %1)'
# 'cannot create __weak reference because the current deployment target does not support weak references'
H54D605FEB00B: '현재 배포 대상이 weak references를 지원하지 않아 __weak reference를 생성할 수 없습니다'
# 'cannot create __weak reference in file using manual reference counting'
H98AD8AE899EB: '파일에서 수동 참조 카운팅을 사용 중이므로 __weak 참조를 생성할 수 없습니다'
# 'cannot create a non-constant pointer to member function'
H909CEC9754E8: '멤버 함수에 대한 비상수 포인터를 생성할 수 없습니다'
# 'cannot create includes file for module %0: %1'
H521EA5757B62: '모듈 %0에 대한 인클루드 파일을 생성할 수 없습니다: %1'
# 'cannot create object of function type %0'
HB6BCDD252F4D: '함수 형식 %0의 객체를 생성할 수 없습니다.'
# 'cannot declare a class template with no name'
H86275B9FD8C9: '이름이 없는 클래스 템플릿을 선언할 수 없습니다'
# 'cannot declare an explicit specialization in a friend'
H8E19851C2991: '친구 내에서 명시적 특수화를 선언할 수 없습니다'
# 'cannot declare class extension for %0 after class implementation'
H472ADAE23CEA: '클래스 구현 후 %0의 클래스 확장 선언은 불가능합니다.'
# "cannot declare implementation of a class declared with the 'objc_class_stub' attribute"
H831B35F688CB: 'objc_class_stub 어트리뷰트로 선언된 클래스의 구현을 선언할 수 없습니다'
# "cannot declare the namespace 'std' to be inline"
H1345EF64CB88: "네임스페이스 'std'를 인라인으로 선언할 수 없습니다"
# 'cannot declare variable inside @interface or @protocol'
H11D626BF5B37: '@interface 또는 @protocol 내부에서 변수를 선언할 수 없습니다'
# 'cannot decompose %select{private|protected}0 member %1 of %3'
HAF5B2F15564E: '%select{프라이빗|프로텍티드}0 멤버 %1의 %3를 분해할 수 없습니다'
# 'cannot decompose %select{union|non-class, non-array}1 type %2'
HD213477C2A3A: '분해할 수 없는 %select{유니온|비클래스, 비배열}1 형식 %2'
# 'cannot decompose class type %0 because it has an anonymous %select{struct|union}1 member'
H687FA194A579: '클래스 타입 %0를 분해할 수 없습니다. 익명의 %select{struct|union}1 멤버가 있기 때문입니다'
# 'cannot decompose class type %1: %select{its base classes %2 and|both it and its base class}0 %3 have non-static data members'
HBC0288C04290: '클래스 유형 %1을 분해할 수 없습니다: %select{기반 클래스 %2와|그 자체와 그 기반 클래스}0 %3가 static이 아닌 데이터 멤버를 가지고 있습니다'
# 'cannot decompose lambda closure type'
H3C6B1EAC26ED: 'lambda 클로저 유형을 분해할 수 없습니다.'
# 'cannot decompose members of ambiguous base class %1 of %0:%2'
HE08DBE349649: '정의되지 않은 베이스 클래스 %1의 %0:%2 멤버를 분해할 수 없습니다'
# 'cannot decompose members of inaccessible base class %1 of %0'
HA6ED46C6B298: '클래스 %0의 접근 불가능한 기반 클래스 %1의 멤버를 분해할 수 없습니다'
# "cannot decompose this type; 'std::tuple_element<%0>::type' does not name a type"
H4AD140BFCF3D: "이 형식을 분해할 수 없습니다; 'std::tuple_element<%0>::type'은 유효한 형식을 지정하지 않습니다."
# "cannot decompose this type; 'std::tuple_size<%0>::value' is not a valid integral constant expression"
HE140F3EE6033: "이 형식을 분해할 수 없습니다; 'std::tuple_size<%0>::value'는 유효한 정수 상수 표현식이 아닙니다"
# 'cannot decrement expression of type bool'
H9DABD4A4074A: 'bool 타입의 표현식은 감소시킬 수 없습니다'
# "cannot deduce 'decltype(auto)' from initializer list"
H0294CF60338E: "'decltype(auto)'의 초기화자 목록을 추론할 수 없습니다"
# 'cannot deduce actual type for %1 from %select{parenthesized|nested}0 initializer list'
H1C99EC9B7047: '%1의 %select{parenthesized|nested}0 initializer list에서 실제 타입을 추론할 수 없습니다'
# 'cannot deduce actual type for variable %0 with type %1 from initializer list'
HA7FCCDD3352E: '초기화 리스트에서 %0 변수의 타입 %1로 실제 타입을 추론할 수 없습니다.'
# 'cannot deduce implicit triple value for -Xopenmp-target, specify triple using -Xopenmp-target=<triple>'
HBB4FDAD01556: '-Xopenmp-target에 대한 암시적 triple 값이 추론되지 않았습니다. -Xopenmp-target=<triple> 옵션을 사용하여 triple을 지정해 주세요'
# 'cannot deduce lambda return type from initializer list'
HBF4499B07FAC: '초기화자 목록에서 람다 반환 형식을 추론할 수 없습니다'
# 'cannot deduce return type %0 for function with no return statements'
H4A0B0541DA05: '리턴 문이 없는 함수에 대해 %0 반환 형식을 추론할 수 없습니다'
# 'cannot deduce return type %0 from omitted return expression'
HF76745F04CDD: '생략된 리턴 표현식에서 %0 리턴 타입을 추론할 수 없습니다.'
# 'cannot deduce return type %0 from returned value of type %1'
HFF6A0873771C: '리턴 타입 %0을 반환 값의 타입 %1로부터 유추할 수 없습니다'
# 'cannot deduce return type from initializer list'
HD33E533A8026: '초기화자 목록에서 반환 형식을 추론할 수 없습니다'
# 'cannot deduce template arguments for %0 from %1'
H59FFC4EE513D: '%0에 대한 템플릿 인수를 %1에서 추론할 수 없습니다'
# 'cannot deduce type for lambda capture %0 from initializer list'
HD1B46B897454: '초기화자 목록에서 람다 캡처 %0의 유형을 추론할 수 없습니다'
# 'cannot deduce type for lambda capture %0 from initializer of type %2'
H5BED86131FDB: '람다 캡처 %0의 타입을 타입 %2의 초기화자로부터 유추할 수 없습니다'
# 'cannot deduce type for lambda capture %1 from %select{parenthesized|nested}0 initializer list'
HBAF719ACD121: '람다 캡처 %1의 유형을 %select{괄호로 감싸진|중첩된}0 초기화 목록에서 추론할 수 없습니다'
# 'cannot deduce type for variable %1 with type %2 from %select{parenthesized|nested}0 initializer list'
HDBF6BFDD94D3: '변수 %1의 타입 %2를 %select{괄호로 묶인|중첩된}0 초기화 목록으로부터 추론할 수 없습니다'
# 'cannot deduce type of initializer list because std::initializer_list was not found; include <initializer_list>'
H61AB50323785: '초기화자 목록의 유형을 추론할 수 없습니다. std::initializer_list가 발견되지 않았습니다. <initializer_list> 헤더를 포함해 주세요.'
# 'cannot define %select{category|class extension}0 for undefined class %1'
H075CA56C0949: '정의되지 않은 클래스 %1에 대해 %select{카테고리|클래스 확장}0를 정의할 수 없습니다.'
# 'cannot define a type in a friend declaration'
H90F602DED3B4: '친구 선언에서 타입을 정의할 수 없습니다'
# 'cannot define friend function %0 in a local class definition; did you mean %3?'
H40B3F3B5FBB1: '로컬 클래스 정의에서 친구 함수 %0을 정의할 수 없습니다; %3을 의미하지는 않았나요?'
# 'cannot define friend function in a local class definition'
HB60D03F3A5C5: '로컬 클래스 정의 내에서는 친구 함수를 정의할 수 없습니다'
# 'cannot define non-inline dllimport template specialization'
HF67617A49B06: '인라인되지 않은 dllimport 템플릿 특수화를 정의할 수 없습니다'
# 'cannot define or redeclare %0 here because namespace %1 does not enclose namespace %2'
HFA38E82744C2: '%0를 여기서 정의하거나 재선언할 수 없습니다. 네임스페이스 %1는 네임스페이스 %2를 포함하지 않기 때문입니다'
# 'cannot define the implicit copy assignment operator for %0, because non-static %select{reference|const}1 member %2 cannot use copy assignment operator'
H50812469123A: '암시적 복사 할당 연산자를 %0에 정의할 수 없습니다. 비정적 %select{reference|const}1 멤버 %2는 복사 할당 연산자를 사용할 수 없기 때문입니다'
# 'cannot delete expression of type %0'
H8F9B57A837EE: '타입 %0의 표현식을 삭제할 수 없습니다.'
# "cannot delete expression with pointer-to-'void' type %0"
HCCFA093E9DE2: 'void 포인터 형식의 표현식은 삭제할 수 없습니다 %0'
# 'cannot delete pointer to incomplete type %0'
H7E32F7F5C2AD: '완전하지 않은 타입 %0의 포인터를 삭제할 수 없습니다'
# "cannot determine %0 architecture: %1; consider passing it via '%2'; environment variable CLANG_TOOLCHAIN_PROGRAM_TIMEOUT specifies the tool timeout (integer secs, <=0 is infinite)"
H9E1578DA83DB: "%0 아키텍처를 구할 수 없습니다: %1; '%2'를 통해 전달하는 것을 고려해 보십시오; 환경 변수 CLANG_TOOLCHAIN_PROGRAM_TIMEOUT은 도구 타임아웃을 지정합니다(정수 초, <=0은 무한대)"
# 'cannot determine allocated array size from initializer'
H3573086C6F39: '초기화자에서 할당된 배열 크기를 결정할 수 없습니다.'
# 'cannot determine number of elements for sizeless vectors in a constant expression'
HAFC6AFA63009: '상수 표현식에서 크기 없는 벡터의 요소 수를 결정할 수 없습니다'
# 'cannot determine underlying type of incomplete enumeration type %0'
H486DE8FE7D9E: '불완전한 열거 형식의 밑바탕 형식을 결정할 수 없습니다 %0'
# 'cannot emit module %0: %select{size|mtime}1 must be explicitly specified for missing header file "%2"'
H4AFEE6C7D624: '모듈 %0를 생성할 수 없습니다: %select{크기|mtime}1는 누락된 헤더 파일 "%2"에 대해 명시적으로 지정해야 합니다'
# 'cannot evaluate call to virtual function in a constant expression in C++ standards before C++20'
HC06FC1196550: 'C++20 이전의 C++ 표준에서 상수 표현식에서 가상 함수 호출을 평가할 수 없습니다'
# 'cannot evaluate this expression if rounding mode is dynamic'
HC673B661CF5A: '반올림 모드가 동적일 경우 이 표현식을 평가할 수 없습니다.'
# 'cannot export %0 as it is not at namespace scope'
H49EEB2061C19: '%0는 네임스페이스 범위에 있지 않기 때문에 export할 수 없습니다'
# 'cannot export redeclaration %0 here since the previous declaration %select{is not exported|has internal linkage|has module linkage}1'
H805545AFF107: '여기서 %0의 재선언을 내보낼 수 없습니다. 이전 선언은 %select{내보내지 않았습니다|내부 링크지가 있습니다|모듈 링크지가 있습니다}1'
# "cannot find CUDA installation; provide its path via '--cuda-path', or pass '-nocudainc' to build without CUDA includes"
H483DC86F4594: "CUDA 설치 디렉토리를 찾을 수 없습니다. '--cuda-path' 옵션을 통해 경로를 지정하거나 '-nocudainc' 옵션을 전달하여 CUDA 헤더를 포함하지 않고 빌드할 수 있습니다."
# "cannot find HIP Standard Parallelism Acceleration library; provide it via '--hipstdpar-path'"
H20ABDE201926: "HIP 표준 병렬 가속화 라이브러리를 찾을 수 없습니다; '--hipstdpar-path'를 통해 제공해 주세요"
# "cannot find HIP device library%select{| for %1}0; provide its path via '--hip-path' or '--hip-device-lib-path', or pass '-nogpulib' to build without HIP device library"
H74B6BE24033A: "HIP 디바이스 라이브러리를 찾을 수 없습니다%select{| %1에 대해}0; 경로를 '--hip-path' 또는 '--hip-device-lib-path'를 통해 제공하거나, '-nogpulib'를 전달하여 HIP 디바이스 라이브러리를 사용하지 않고 빌드할 수 있습니다"
# "cannot find HIP runtime; provide its path via '--rocm-path', or pass '-nogpuinc' to build without HIP runtime"
H11EBFA045BE3: "HIP 런타임을 찾을 수 없습니다; '--rocm-path'를 통해 경로를 제공하거나 '-nogpuinc'를 전달하여 HIP 런타임 없이 빌드할 수 있습니다."
# "cannot find ROCm device library%select{| for %1| for ABI version %1%select{|, which requires ROCm %3 or higher}2}0; provide its path via '--rocm-path' or '--rocm-device-lib-path', or pass '-nogpulib' to build without ROCm device library"
H66C4B1DCC978: "ROCM 장치 라이브러리%select{| %1에 대한| ABI 버전 %1%select{|, %3 이상의 ROCm 버전이 필요합니다}2}0을 찾을 수 없음: '--rocm-path' 또는 '--rocm-device-lib-path'를 통해 경로를 제공하거나 '-nogpulib'를 전달하여 ROCm 장치 라이브러리 없이 빌드하세요"
# 'cannot find a valid user-defined mapper for type %0 with name %1'
H0907A5973C27: '형 %0에 이름 %1이 있는 유효한 사용자 정의 매퍼를 찾을 수 없습니다'
# "cannot find end ('%1') of expected %0"
H53A2AE90D9C0: "예상한 %0의 끝 '%1'을 찾을 수 없습니다"
# 'cannot find interface declaration for %0'
H7325D139C40F: '인터페이스 선언을 찾을 수 없습니다: %0'
# 'cannot find interface declaration for %0, superclass of %1'
HDDF90FE7BE8F: '초 클래스 %1의 %0 인터페이스 선언을 찾을 수 없습니다'
# 'cannot find interface declaration for %0, superclass of %1; did you mean %2?'
H691319D1E232: '클래스 %1의 슈퍼클래스인 %0 인터페이스의 선언을 찾을 수 없습니다; %2를 의미하시는 건가요?'
# 'cannot find interface declaration for %0; did you mean %1?'
H3FD5BD5869C6: '인터페이스 선언 %0을 찾을 수 없습니다; %1 의 뜻이었는지 확인해 주세요?'
# "cannot find libdevice for %0; provide path to different CUDA installation via '--cuda-path', or pass '-nocudalib' to build without linking with libdevice"
H9C8FBD27D916: "libdevice를 찾을 수 없습니다: %0; 다른 CUDA 설치 경로는 '--cuda-path'를 통해 지정하거나, '-nocudalib'를 전달하여 libdevice 연결 없이 빌드할 수 있습니다."
# 'cannot find protocol declaration for %0'
H8559765777E9: '프로토콜 선언을 찾을 수 없습니다: %0'
# 'cannot find protocol declaration for %0; did you mean %1?'
H39967D7F0C23: '프로토콜 선언을 찾을 수 없습니다: %0; %1을(를) 의미하시는 건 아닌가요?'
# 'cannot find protocol definition for %0'
H30EC809C2E8C: '프로토콜 정의를 찾을 수 없습니다: %0'
# "cannot find re-exported %select{framework|library}0: '%1'"
HFF74F7CAAAC8: "재수출된 %select{프레임워크|라이브러리}0을 찾을 수 없습니다: '%1'"
# "cannot find rocPrim, which is required by the HIP Standard Parallelism Acceleration library; provide it via '--hipstdpar-prim-path'"
H7420A8DBF79F: "rocPrim을 찾을 수 없습니다. 이는 HIP 표준 병렬 가속 라이브러리에 의해서 필요로 하는 것이므로, '--hipstdpar-prim-path'를 통해 제공해 주세요"
# "cannot find rocThrust, which is required by the HIP Standard Parallelism Acceleration library; provide it via '--hipstdpar-thrust-path'"
HF20DC196E1CB: "HIP 표준 병렬 처리 가속 라이브러리에 의해 필요로 하는 rocThrust를 찾을 수 없습니다; '--hipstdpar-thrust-path'를 통해 제공해 주십시오"
# "cannot find start ('{{') of expected %0"
H727EB43115FC: "예상된 %0의 시작('{{')을 찾을 수 없습니다"
# "cannot find start of regex ('{{') in %0"
HD5BDA70A3617: "정규식('{{')의 시작을 %0에서 찾을 수 없습니다."
# 'cannot find suitable %select{getter|setter}0 for property %1'
H0F811370E791: '프로퍼티 %1에 대한 적절한 %select{getter|setter}0를 찾을 수 없습니다'
# 'cannot form %select{pointer to|reference to|array of|function returning}0 deduced class template specialization type'
H0C20361BB556: '연결된 클래스 템플릿 특수화 유형에 대한 %select{포인터|참조|array|함수 리턴}0을 만들 수 없습니다'
# "cannot form %select{pointer to|reference to|array of}0 'decltype(auto)'"
H7F41F0A9CCC7: 'decltype(auto)의 %select{포인터|참조|array}0을 형성할 수 없습니다'
# 'cannot form a %select{pointer|reference}0 to a WebAssembly table'
H3C39E76E28BC: 'WebAssembly 테이블에 %select{포인터|참조}0를 만들 수 없습니다'
# 'cannot form a pointer-to-member to member %0 of reference type %1'
H45A1DB7A6AF3: '멤버 %0는 참조 형식 %1이므로 멤버 포인터를 형성할 수 없습니다.'
# "cannot form a reference to 'void'"
H6E82068C4FE4: '‘void’ 형식에 대한 참조를 형성할 수 없습니다.'
# "cannot form member pointer of type %0 without '&' and class name"
HA98A1BC7CEC4: '클래스 이름과 &를 사용하지 않고 %0 형식의 멤버 포인터를 만들 수 없습니다.'
# 'cannot generate code for reduction on %select{|array section, which requires a }0variable length array'
H328E15AAC013: '가변 길이 배열에 대한 감소(reduction)를 위한 코드를 생성할 수 없습니다: %select{|배열 섹션, 필요로 하는 }0'
# 'cannot have both throw() and noexcept() clause on the same function'
H93A58AAAE480: '같은 함수에 throw()와 noexcept() 절을 동시에 사용할 수 없습니다'
# 'cannot implement a category for class %0 that is only visible via the Objective-C runtime'
H93EA111FC5EC: 'Objective-C 런타임을 통해만 접근 가능한 클래스 %0의 카테고리를 구현할 수 없습니다'
# 'cannot implement subclass %0 of a superclass %1 that is only visible via the Objective-C runtime'
H0C79ADD5940E: '상위 클래스 %1은 Objective-C 런타임을 통해만 가시적이므로 하위 클래스 %0를 구현할 수 없습니다.'
# 'cannot import unsupported AST node %0'
H4E75F3A5019B: '지원되지 않는 AST 노드를 가져올 수 없습니다. %0'
# 'cannot initialize %select{a variable|a parameter|template parameter|return object|statement expression result|an exception object|a member subobject|an array element|a new value|a value|a base class|a constructor delegation|a vector element|a block element|a block element|a complex element|a lambda capture|a compound literal initializer|a related result|a parameter of CF audited function|a structured binding|a member subobject}0 %diff{of type $ with an %select{rvalue|lvalue}2 of type $|with an %select{rvalue|lvalue}2 of incompatible type}1,3%select{|: different classes%diff{ ($ vs $)|}5,6|: different number of parameters (%5 vs %6)|: type mismatch at %ordinal5 parameter%diff{ ($ vs $)|}6,7|: different return type%diff{ ($ vs $)|}5,6|: different qualifiers (%5 vs %6)|: different exception specifications}4'
H5225AD7ABD6B: '%select{변수|매개변수|템플릿 매개변수|반환 객체|문 표현식 결과|예외 객체|멤버 서브오브젝트|배열 요소|새로운 값|값|베이스 클래스|생성자 위임|벡터 요소|블록 요소|블록 요소|복합 요소|람다 캡처|복합 리터럴 초기화자|관련된 결과|CF 검사된 함수의 매개변수|구조화된 바인딩|멤버 서브오브젝트}0를 초기화할 수 없습니다. %diff{타입 $의 %select{rvalue|lvalue}2 타입 $와 | 호환되지 않는 타입의 %select{rvalue|lvalue}2와}1,3%select{ |: 다른 클래스%diff{ ($ vs $)|}5,6 |: 다른 매개변수 개수 (%5 vs %6) |: %ordinal5 번째 매개변수에서 타입 불일치%diff{ ($ vs $)|}6,7 |: 다른 반환 타입%diff{ ($ vs $)|}5,6 |: 다른 자격 증명자 (%5 vs %6) |: 다른 예외 지정 }4'
# 'cannot initialize %select{non-class|reference}0 type %1 with a parenthesized initializer list'
HE63727C8C08B: '%select{비클래스|참조}0 형식 %1을(를) 괄호로 감싸인 초기화 목록으로 초기화할 수 없습니다'
# 'cannot initialize Objective-C class type %0'
HA709360A8ABC: 'Objective-C 클래스 형식 %0을(를) 초기화할 수 없습니다'
# 'cannot initialize array %diff{of type $ with array of type $|with different type of array}0,1'
HA759EFFA1CC7: '배열을 초기화할 수 없습니다. %diff{형식 $의 배열을 형식 $의 배열로|타입이 다른 배열로}0,1'
# 'cannot initialize array %diff{of type $ with non-constant array of type $|with different type of array}0,1'
HAEED299DACD1: '배열을 초기화할 수 없습니다: %diff{형식 $의 배열을 상수 배열이 아닌 형식 $의 배열로|다른 형식 $의 배열로}0,1 초기화할 수 없습니다'
# 'cannot initialize object parameter of type %0 with an expression of type %1'
H01F0C7FE2242: '타입 %0인 객체 매개변수를 타입 %1인 표현식으로 초기화할 수 없습니다.'
# 'cannot instantiate %0 yet'
H3C23130222AC: '현재 %0를 인스턴스화할 수 없습니다'
# 'cannot jump from switch statement to this case label'
H0147E81C1C5E: 'switch 문에서 이 case 레이블로 점프할 수 없습니다'
# 'cannot jump from this %select{indirect|asm}0 goto statement to one of its possible targets'
HA7FDD21785F4: '이 %select{indirect|asm}0 goto 문에서 가능한 타겟 중 하나로 점프할 수 없습니다'
# 'cannot jump from this continue statement to the loop increment; jump bypasses initialization of loop condition variable'
HF65BBB33CB19: '이 continue 문에서 loop increment로 점프할 수 없습니다; 점프가 loop condition variable의 초기화를 건너뜁니다'
# 'cannot jump from this goto statement to its label'
HF7AC509BA0D6: '이 goto 문에서 해당 라벨로 점프할 수 없습니다.'
# 'cannot jump from this goto statement to label %0 inside an inline assembly block'
HBD667F79ECB9: '이 goto 문에서 인라인 어셈블리 블록 내의 라벨 %0로 점프할 수 없습니다'
# "cannot link module '%0': %1"
H957779E89D24: "모듈 '%0'을 연결할 수 없습니다: %1"
# 'cannot locate code-completion file %0'
H00AA0E96170A: '코드 완성 파일 %0를 찾을 수 없습니다'
# 'cannot mangle fixed point literals yet'
H175F8CE0FB1D: '아직 고정 소수점 리터럴의 이름 망글링을 할 수 없습니다'
# 'cannot mangle this %0 %1 yet'
H50F33B0E4B4E: '이 %0 %1은 아직 mangle할 수 없습니다'
# 'cannot mangle this %0 yet'
H1C98A95C714E: '이 %0은(는) 아직 맴글링할 수 없습니다'
# 'cannot mangle this dependent fixed-length RVV vector type yet'
H01F50B3350B7: '이 종속 고정 길이 RVV 벡터 타입은 아직 망글 수 없습니다'
# 'cannot mangle this dependent fixed-length SVE vector type yet'
H53C22EA00769: '이 의존적인 고정 길이 SVE 벡터 타입은 아직 매길 수 없습니다'
# 'cannot mangle this dependent neon vector type yet'
H566B620CDB5E: '이 의존형 Neon 벡터 형식을 아직 변환할 수 없습니다'
# 'cannot mangle this requires-expression containing a substitution failure'
H9EEE8BF3FF53: '치환 실패가 포함된 이 requires-expression을 변환할 수 없습니다'
# 'cannot mangle this unnamed union NTTP yet'
HC67F1942B567: '이름 없는 union NTTP는 아직 mangling할 수 없습니다'
# 'cannot mix packoffset elements with nonpackoffset elements in a cbuffer'
H5F5AED65EDDB: 'cbuffer에 packoffset 요소와 nonpackoffset 요소를 혼합할 수 없습니다.'
# 'cannot mix positional and non-positional arguments in format string'
HC2203B0385F9: '포맷 문자열에서 위치 인자와 비위치 인자를 혼합할 수 없습니다'
# 'cannot mix vectors and extended vectors in a vector conditional'
H0C69F5DF40B4: '벡터와 확장 벡터를 벡터 조건문에서 혼합할 수 없습니다'
# "cannot nest 'critical' regions having the same name %0"
HB0FDA4DB5B6B: "동일한 이름 %0를 가진 'critical' 영역을 중첩할 수 없습니다."
# "cannot open file '%0': %1"
H7B318395BD4F: "파일 '%0'을 열 수 없습니다: %1"
# "cannot overload a member function %select{without a ref-qualifier|with ref-qualifier '&'|with ref-qualifier '&&'}0 with a member function %select{without a ref-qualifier|with ref-qualifier '&'|with ref-qualifier '&&'}1"
H3E720DF8A96F: "참조 자격자를 가지지 않은 멤버 함수 %select{참조 자격자를 가지지 않은|참조 자격자 '&'를 가진|참조 자격자 '&&'를 가진}0와 참조 자격자를 가지지 않은 멤버 함수 %select{참조 자격자를 가지지 않은|참조 자격자 '&'를 가진|참조 자격자 '&&'를 가진}1을 오버로드할 수 없습니다"
# 'cannot override a method that is declared direct by a superclass'
H8D083337F734: '상위 클래스에 의해 직접 선언된 method를 오버라이드할 수 없습니다'
# 'cannot parenthesize the name of a method when forming a member pointer'
H733C76C89DE9: '멤버 포인터를 생성할 때 메서드의 이름에 괄호를 씌울 수 없습니다'
# 'cannot pass %select{expression of type %1|initializer list}0 to variadic %select{function|block|method|constructor}2'
H25763FEA732A: '%select{%1 형 표현식|초기화 목록}0를 가변 %select{함수|블록|메서드|생성자}2에 전달할 수 없습니다'
# 'cannot pass %select{expression of type %1|initializer list}0 to variadic %select{function|block|method|constructor}2; expected type from format string was %3'
H6A81C62CC358: '%select{%1 형 표현식|초기화 목록}0를 가변 %select{함수|블록|메서드|생성자}2에 전달할 수 없습니다; 형식 문자열에서 예상된 형은 %3입니다'
# 'cannot pass %select{non-POD|non-trivial}0 object of type %1 to variadic %select{function|block|method|constructor}2; expected type from format string was %3'
HB3C416B2C325: '%select{non-POD|non-trivial}0 형 %1의 객체를 가변 %select{함수|블록|메서드|생성자}2에 전달할 수 없습니다; 형식 문자열에서 예상된 형은 %3입니다'
# 'cannot pass a pointer-to-member through register-constrained inline assembly parameter'
H1A2FFC7DC3D0: '레지스터 제약이 있는 인라인 어셈블리 매개변수를 통해 멤버 포인터를 전달할 수 없습니다'
# 'cannot pass bit-field as __auto_type initializer in C'
HC2EE224C8229: 'C에서 비트 필드를 __auto_type 초기화자로 전달할 수 없습니다'
# 'cannot pass non-trivial C object of type %0 by value to variadic %select{function|block|method|constructor}1'
H2C5461696894: '비기본 C 객체의 타입 %0을 값으로 가변 %select{함수|블록|메서드|생성자}1에 전달할 수 없습니다.'
# 'cannot pass object of %select{non-POD|non-trivial}0 type %1 through variadic %select{function|block|method|constructor}2; call will abort at runtime'
H03C685EEC43F: '%select{non-POD|non-trivial}0 형 %1의 객체를 가변 %select{함수|블록|메서드|생성자}2에 전달할 수 없습니다; 실행 시 호출이 중단됩니다'
# 'cannot pass object with interface type %0 by value through variadic %select{function|block|method|constructor}1'
HFFB4BE108833: '인터페이스 형식의 객체 %0를 값으로 가변 %select{함수|블록|메서드|생성자}1을 통해 전달할 수 없습니다.'
# 'cannot pass object with interface type %1 by value to variadic %select{function|block|method|constructor}2; expected type from format string was %3'
HFCF01B48F1C2: '인터페이스 형식 %1의 객체를 값으로 가변 매개변수 %select{함수|블록|메서드|생성자}2에 전달할 수 없습니다; 포맷 문자열에서 예상된 형식은 %3입니다'
# "cannot pass undiscriminated type %0 to '__builtin_ptrauth_type_discriminator'"
HCF5D52D0F4BA: "구분되지 않은 타입 %0를 '__builtin_ptrauth_type_discriminator'에 전달할 수 없습니다"
# 'cannot perform a tail call %select{from|to}0 a %select{constructor|destructor}1'
H92D6BE5E0D10: '꼬리 호출을 %select{에서|로}0 %select{생성자|소멸자}1로 수행할 수 없습니다'
# 'cannot perform a tail call from this return statement'
HD566EFBB0F10: '이 return 문에서 tail call을 수행할 수 없습니다'
# 'cannot perform a tail call to function%select{| %1}0 because it uses an incompatible calling convention'
H32E425482ACE: '함수%select{| %1}0로의 꼬리 호출을 수행할 수 없습니다. 이 함수는 호환되지 않는 호출 규약을 사용하기 때문입니다'
# 'cannot perform a tail call to function%select{| %1}0 because its signature is incompatible with the calling function'
HB6791E3481C6: '테일 콜을 수행할 수 없습니다: 함수%select{| %1}0의 시그니처가 호출하는 함수와 호환되지 않습니다'
# 'cannot perform atomic operation on a pointer to type %0: type has non-trivial ownership'
H33A9E57472E9: '타입 %0에 대한 포인터에서 원자 연산을 수행할 수 없습니다: 해당 타입은 비平凡 소유권을 가지고 있습니다.'
# "cannot read configuration file '%0': %1"
H0AF7279B0969: "구성 파일 '%0'을 읽을 수 없습니다: %1"
# "cannot read randomize layout seed file '%0'"
H97BBD89360BC: "레이아웃 시드 파일 '%0'을 읽을 수 없습니다."
# "cannot rebuild module '%0' as it is already finalized"
H80C2AA3A79E5: "모듈 '%0'을 다시 빌드할 수 없습니다. 이미 최종화되었기 때문입니다"
# 'cannot redeclare builtin function %0'
HC3E811B65243: '빌트인 함수 %0를 재선언할 수 없습니다'
# 'cannot refer to a block inside block'
HEC4D55F7E1FA: '블록 내부의 블록에 대한 참조는 불가능합니다'
# 'cannot refer to a non-static member from the handler of a %select{constructor|destructor}0 function try block'
H7C221E1899F1: '함수 트라이 블록의 %select{생성자|소멸자}0 핸들러에서 정적 멤버가 아닌 멤버를 참조할 수 없습니다'
# 'cannot refer to declaration of structure variable with flexible array member inside block'
H861E195F8EA8: '블록 내에서 유연한 배열 멤버를 가진 구조체 변수의 선언을 참조할 수 없습니다'
# 'cannot refer to declaration with a variably modified type inside block'
H3ACCC42BDE35: '블록 내부에서 변동형 타입을 가진 선언을 참조할 수 없습니다.'
# 'cannot refer to declaration with an array type inside block'
HBA9381EF3C23: '블록 내부에서 배열 형식의 선언에 접근할 수 없습니다'
# 'cannot refer to element %0 of %select{array of %2 element%plural{1:|:s}2|non-array object}1 in a constant expression'
H97B7B294ED7C: '상수 표현식에서 %select{배열 %2 요소%plural{1:|:s}2|비배열 개체}1의 %0 요소를 참조할 수 없습니다'
# "cannot refer to member %0 in %1 with '%select{.|->}2'"
HF25CD96D4723: "멤버 %0를 %1에서 '%select{.|->}2'로 참조할 수 없습니다."
# "cannot refer to type member %0 in %1 with '%select{.|->}2'"
H982BCA02E9FD: "타입 멤버 %0를 %1에서 '%select{.|->}2'로 참조할 수 없습니다"
# 'cannot reference member of primary template because deduced class template specialization %0 is %select{instantiated from a partial|an explicit}1 specialization'
HF04074EDD691: '주 템플릿의 멤버에 접근할 수 없습니다. 추론된 클래스 템플릿 특수화 %0가 %select{부분 특수화에서 생성된|명시적인}1 특수화이기 때문입니다'
# 'cannot resolve lock expression'
H9831838AB057: 'lock 표현식을 해결할 수 없습니다'
# 'cannot return from %0'
HDE7181BDC39D: '%0에서 반환할 수 없습니다'
# 'cannot set vtable pointer authentication on %0 which is a subclass of polymorphic type %1'
H8615F820D27E: '다형성 타입 %1의 하위 클래스인 %0에는 vtable 포인터 인증을 설정할 수 없습니다'
# 'cannot set vtable pointer authentication on an incomplete type %0'
H50389542B8AD: '불완전한 형식 %0에 vtable pointer authentication을 설정할 수 없습니다.'
# 'cannot set vtable pointer authentication on monomorphic type %0'
H365AD22227CA: '단모폴리피크 타입 %0에 vtable 포인터 인증을 설정할 수 없습니다'
# "cannot specialize %select{|(with 'template<>') }0a member of an unspecialized template"
H21C951459621: "비특수화 템플릿의 멤버는 특수화할 수 없습니다 %select{|(with 'template<>') }0"
# 'cannot specialize a %select{dependent template|template template parameter}0'
HC5BFF931F55D: '%select{종속 템플릿|템플릿 템플릿 매개변수}0를 특수화할 수 없습니다'
# "cannot specify '%0%1' when compiling multiple source files"
HFD3172559132: "복수의 소스 파일을 컴파일할 때 '%0%1'을 지정할 수 없습니다"
# "cannot specify '%1' along with '%0'"
H9F94923DAC7E: "‘%1’과 '%0'을 함께 지정할 수 없습니다"
# 'cannot specify -o when generating multiple output files'
HE249C344BFD2: '복수의 출력 파일을 생성할 때 -o를 지정할 수 없습니다'
# 'cannot specify a default vtable pointer authentication %select{key|address discrimination mode|discriminator}0 with no default set'
H3A1B9264D760: '기본값이 설정되지 않았을 때 기본 vtable 포인터 인증 %select{키|주소 구분 모드|구분자}0를 지정할 수 없습니다'
# "cannot specify any part of a return type in the declaration of a conversion function%select{; put the complete type after 'operator'|; use a typedef to declare a conversion to %1|; use an alias template to declare a conversion to %1|}0"
HAA40A3FFF9F4: '변환 함수의 선언에서 반환 타입의 일부를 지정할 수 없습니다%select{; operator 키워드 뒤에 완전한 타입을 지정하세요|; %1으로의 변환을 선언하려면 typedef를 사용하세요|; %1으로의 변환을 선언하려면 alias 템플릿을 사용하세요|}0'
# 'cannot specify any part of a return type in the declaration of a deduction guide'
H390B6E7B14DB: '추론 가이드의 선언에서 반환 형식의 어떤 부분도 지정할 수 없습니다'
# 'cannot specify deduction guide for %select{<error>|function template|variable template|alias template|template template parameter|concept|dependent template name}0 %1'
H8A234F5E78B1: '추론 가이드를 %select{<error>|함수 템플릿|변수 템플릿|ALIAS 템플릿|템플릿 템플릿 매개변수|컨셉|종속 템플릿 이름}0 %1에 지정할 수 없습니다'
# "cannot specify parameter '%0' twice in the same '#embed' directive"
HD1DC8056B121: "같은 '#embed' 디렉티브에서 매개변수 '%0'를 두 번 지정할 수 없습니다."
# 'cannot store matrix to read-only pointer'
H425886F44B36: '읽기 전용 포인터에 행렬을 저장할 수 없습니다.'
# "cannot subclass a class that was declared with the 'objc_subclassing_restricted' attribute"
H5638A6FF93B7: "'objc_subclassing_restricted' 속성으로 선언된 클래스는 서브클래싱할 수 없습니다"
# 'cannot synthesize property %0 with incomplete type %1'
H71A1173D4045: '완전하지 않은 형식 %1을 가지는 %0 속성을 합성할 수 없습니다'
# 'cannot synthesize weak property because the current deployment target does not support weak references'
H38DCEFEFA216: 'weak 속성을 자동 생성할 수 없습니다. 현재 배포 대상이 weak 참조를 지원하지 않기 때문입니다'
# 'cannot synthesize weak property in file using manual reference counting'
H0734CFB3421A: '수동 참조 카운팅을 사용하는 파일에서 약한 속성을 합성할 수 없습니다'
# 'cannot take address of %select{immediate|consteval}2 %select{function|call operator of}1 %0 outside of an immediate invocation'
H530D63A21A7A: '즉시 호출 외부에서 %select{즉시|consteval}2 %select{함수|호출 연산자의}1 %0 의 주소를 취할 수 없습니다'
# 'cannot take address of function %0 because it has one or more non-tautological enable_if conditions'
H23DB8FEDBD81: '함수 %0의 주소를 취할 수 없습니다. 비 자명한 enable_if 조건이 하나 이상 있기 때문입니다.'
# 'cannot take address of function %0 because its constraints are not satisfied'
H4014F85A3BA5: '함수 %0의 주소를 취할 수 없습니다.因为它의 제약 조건이 충족되지 않았습니다.'
# 'cannot take address of function %0 because parameter %1 has pass_object_size attribute'
H6872B0BADEA4: '%0 함수의 주소를 가져올 수 없습니다. 매개변수 %1이 pass_object_size 속성을 가지기 때문입니다'
# 'cannot take an address of a virtual member function if its return or argument types are incomplete'
HF3A5696A9EB7: '가상 멤버 함수의 주소를 가져올 수 없습니다. 반환 타입 또는 인자 타입이 완전히 정의되지 않았을 경우'
# 'cannot take the address of an rvalue of type %0'
H60F39E1B8F38: '%0 형식의 rvalue의 주소를 가져올 수 없습니다'
# 'cannot template a using %select{directive|declaration}0'
H7E5220347031: 'using %select{디렉티브|선언}0로 템플릿을 할 수 없습니다'
# 'cannot throw an object of abstract type %0'
H1AA71488C1EF: '추상 타입 %0의 객체를 throw할 수 없습니다'
# 'cannot throw object of incomplete type %0'
H5A0A40D72DE8: '비완전한 형식의 객체를 던질 수 없습니다. %0'
# 'cannot throw object of sizeless type %0'
HA8B5689740C7: '크기 없는 타입의 객체를 throw할 수 없습니다 %0'
# 'cannot throw object of type %0 with a potentially-throwing destructor'
HC355469628A0: '타입 %0의 객체는 예외를 던질 가능성이 있는 소멸자를 가지므로 throw할 수 없습니다.'
# 'cannot throw pointer to object of incomplete type %0'
H079B08EA2D25: '불완전한 타입 %0의 객체 포인터를 throw할 수 없습니다'
# 'cannot type cast @selector expression'
H485C835C56BA: '형식 캐스트가 @selector 표현식에서 지원되지 않습니다.'
# "cannot use %select{'auto'|<ERROR>|'__auto_type'}0 with %select{initializer list|array}1 in C"
HE2E4F9E6D620: "%select{'auto'|<ERROR>|'__auto_type'}0을(를) %select{초기화자 목록|array}1과 함께 C에서 사용할 수 없습니다."
# "cannot use %select{C++ 'try'|Objective-C '@try'}0 in the same function as SEH '__try'"
H455974313E2A: "%select{C++ 'try'|Objective-C '@try'}0를 SEH '__try'와 같은 함수에서 사용할 수 없습니다"
# 'cannot use %select{dot|arrow}0 operator on a type'
H546BD63E07E0: '타입에 %select{점|화살표}0 연산자를 사용할 수 없습니다.'
# "cannot use %select{unicode|wide}0 string literal in 'asm'"
HD3FDC775E04A: "%select{유니코드|와이드}0 문자열 리터럴은 'asm'에서 사용할 수 없습니다"
# "cannot use '%0' in %select{__device__|__global__|__host__|__host__ __device__}1 function"
H92A38A76E58C: '‘%0’을 %select{__device__|__global__|__host__|__host__ __device__}1 함수에서 사용할 수 없습니다'
# "cannot use '%0' output with multiple -arch options"
H1A59A50BBDD4: "여러 개의 -arch 옵션과 '%0' 출력을 함께 사용할 수 없습니다"
# "cannot use '%0' with '__vector bool'"
HB212313EEF9A: '‘%0’를 ‘__vector bool’과 함께 사용할 수 없습니다'
# "cannot use '%0' with Objective-C exceptions disabled"
H633899DC0353: "Objective-C 예외 처리가 비활성화된 상태에서는 '%0'을 사용할 수 없습니다"
# "cannot use '%0' with exceptions disabled"
H0F6B73A63960: "예외가 비활성화 되었을 때 '%0'를 사용할 수 없습니다."
# "cannot use '_Complex' with '__vector'"
HCFEB59CAC054: "'_Complex'를 '__vector'와 함께 사용할 수 없습니다."
# "cannot use 'float' with '__vector'"
H8772A8A87C32: 'float는 __vector와 함께 사용할 수 없습니다.'
# "cannot use 'long double' with '__vector'"
HD41E42BADD92: "'long double'은 '__vector'와 함께 사용할 수 없습니다."
# "cannot use 'long' with '__vector'"
H0DD309217BB4: "'long'을 '__vector'와 함께 사용할 수 없습니다"
# "cannot use SEH '__try' in a coroutine when C++ exceptions are enabled"
H0484D634DF37: "C++ 예외가 활성화되었을 때 코루틴 내에서 SEH '__try'를 사용할 수 없습니다"
# "cannot use SEH '__try' in blocks, captured regions, or Obj-C method decls"
HAED8CA9442A3: "SEH '__try'를 블록, 캡처된 영역 또는 Obj-C 메서드 선언에서 사용할 수 없습니다."
# 'cannot use WebAssembly table as a function parameter'
H70C162E9FD41: 'WebAssembly 테이블을 함수 매개변수로 사용할 수 없습니다'
# 'cannot use a WebAssembly table within a branch of a conditional expression'
H4CC748CB0567: '조건 표현식의 분기 내에서는 WebAssembly 테이블을 사용할 수 없습니다.'
# "cannot use a protocol declared 'objc_non_runtime_protocol' in a @protocol expression"
H22D18CFED6B9: 'objc_non_runtime_protocol로 선언된 프로토콜을 @protocol 표현식에서 사용할 수 없습니다.'
# "cannot use an empty string literal in 'asm'"
H9269C6D18FCF: 'asm에서 빈 문자열 리터럴을 사용할 수 없습니다'
# 'cannot use dynamic_cast to convert from %0 to %1'
H5749CC5204B8: 'dynamic_cast를 사용하여 %0에서 %1로 변환할 수 없습니다'
# 'cannot use incomplete type %0 as a range'
H779605C5A805: '미완성 형식 %0을(를) 범위로 사용할 수 없습니다'
# 'cannot use initializer list at the beginning of a macro argument'
HFB12BDAF6D6F: '매크로 인수의 시작 부분에서 initializer list를 사용할 수 없습니다'
# 'cannot use type %0 as a range'
H9F644F56E9E3: '타입 %0을(를) 범위로 사용할 수 없습니다.'
# 'cannot use type %0 as an iterator'
H45599EAAF2D8: '%0 형식을 반복기로 사용할 수 없습니다'
# "cannot use type '%0' within '#pragma clang fp eval_method'; type is set according to the default eval method for the translation unit"
HD91CCA267FD1: "'#pragma clang fp eval_method' 내부에서 유형 '%0'를 사용할 수 없습니다; 해당 유형은 번역 단위의 기본 평가 방법에 따라 설정됩니다"
# 'cannot use variable %1 in collapsed imperfectly-nested loop %select{init|condition|increment}0 statement'
H40887EDB8E4A: '변수 %1을(를) 합쳐진 불완전히 중첩된 루프의 %select{초기화|조건|증분}0 문에서 사용할 수 없습니다.'
# 'cannot use variable-length arrays in %select{__device__|__global__|__host__|__host__ __device__}0 functions'
H33A7639314BD: '가변 길이 배열을 %select{__device__|__global__|__host__|__host__ __device__}0 함수에서 사용할 수 없습니다'
# "cannot write file '%0': %1"
H57D82DC5A945: "파일 '%0'을 작성할 수 없습니다: %1"
# 'cannot yet @encode type %0'
H5CF1C5265DEE: '아직 @encode 형식으로 %0 타입을 인코딩할 수 없습니다'
# 'cannot yet compile %0 in this ABI'
H7B123038B924: '이 ABI에서 %0을(를) 아직 컴파일할 수 없습니다'
# 'cannot yet mangle %0 expression'
HA255CBB16444: '아직 %0 표현식을 매길 수 없습니다'
# 'cannot yet mangle OpenACC Asterisk Size expression'
H2D31700B7C49: '아직 OpenACC 별표 크기 표현식을 매길 수 없습니다'
# 'cannot yet mangle expression type %0'
HF4D45A826D3A: '표현식 유형 %0을(를) 아직 메이링할 수 없습니다'
# 'capture %0 by %select{value|reference}1'
HD0ACA3E1F2BB: '값 또는 참조로 %0를 %select{값|참조}1 캡처함'
# 'capture default must be first'
HBD6F708D5FEC: '캡처 기본값은 첫 번째로 와야 합니다'
# 'capture host side class data member by this pointer in device or host device lambda function may result in invalid memory access if this pointer is not accessible on device side'
HA00333F0A82E: 'this 포인터로 호스트 측 클래스 데이터 멤버를 캡처하는 디바이스 또는 호스트 디바이스 람다 함수는 this 포인터가 디바이스 측에서 접근 불가능할 경우 무효 메모리 접근이 발생할 수 있습니다'
# 'capture host variable %0 by reference in device or host device lambda function'
H4218AAE93F26: '디바이스 또는 호스트 디바이스 람다 함수에서 호스트 변수 %0를 참조로 포착했습니다'
# "capture of '*this' by copy is a C++17 extension"
H9C3948693023: "복사로 '*this'를 포착하는 것은 C++17 확장 기능입니다."
# "capture of variable '%0' as type %1 calls %select{private|protected}3 %select{default |copy |move |*ERROR* |*ERROR* |*ERROR* |}2constructor"
H6489D0544330: "변수 '%0'를 %1 형식으로 캡처할 때 %select{프라이빗|프로텍티드}3 접근성의 %select{기본|복사|이동|*ERROR*|*ERROR*|*ERROR*|}2 생성자를 호출합니다"
# 'captured structured bindings are a C++20 extension'
HED60DD4C6A62: '포착된 구조화 바인딩은 C++20 확장 기능입니다'
# 'captured structured bindings are incompatible with C++ standards before C++20'
HA1967A579A6F: '구조화된 바인딩은 C++20 이전의 C++ 표준과 호환되지 않습니다'
# 'capturing %0 strongly in this block is likely to lead to a retain cycle'
H495EA167E92F: '이 블록에서 %0를 강하게 포획하면 retain cycle을 유발할 가능성이 있습니다'
# 'capturing a structured binding is not yet supported in OpenMP'
H3DD2898A017E: 'OpenMP에서 구조화된 바인딩 캡처를 아직 지원하지 않습니다'
# 'case ranges are a C2y extension'
H022E1C3F4097: 'case 범위는 C23 확장입니다'
# 'case ranges are a GNU extension'
H0ADA830DF441: 'case 범위는 GNU 확장 기능입니다'
# 'case ranges are incompatible with C standards before C2y'
H94092A9759CB: 'C2y 이전의 C 표준과 case 범위는 호환되지 않습니다.'
# 'case value not in enumerated type %0'
H4866E4105494: 'case 값이 열거형 타입 %0에 없습니다'
# 'cast %diff{from $ to $ |}0,1converts to incompatible function type'
HAE54FE7B3C1C: '타입 캐스팅에서 $0을 $1로 변환하면 호환되지 않는 함수 타입으로 변환됩니다 %diff{from $0 to $1 |}0,1'
# "cast between incompatible calling conventions '%0' and '%1'; calls through this pointer may abort at runtime"
HB4A395B83746: "호출 규칙이 호환되지 않는 '%0'과 '%1' 사이의 캐스트; 이 포인터를 통해 호출하는 것은 실행 시 중단될 수 있습니다"
# 'cast between pointer-to-function and pointer-to-object is an extension'
H276B46B48964: '함수 포인터와 객체 포인터 간의 캐스트는 확장 기능입니다'
# 'cast between pointer-to-function and pointer-to-object is incompatible with C++98'
HD37948261117: '함수 포인터와 객체 포인터 간의 캐스트는 C++98과 호환되지 않습니다'
# 'cast expression to void to silence warning'
H1D7499C23CFE: '표현식을 void로 캐스팅하여 경고를 잠재우십시오'
# 'cast from %0 is not allowed in a constant expression %select{in C++ standards before C++2c|because the pointed object type %2 is not similar to the target type %3}1'
H542ED6DEC45B: '상수 표현식에서 %0으로의 캐스트는 허용되지 않습니다 %select{C++2c 이전의 C++ 표준에서|지정된 객체 유형 %2가 타겟 유형 %3과 유사하지 않기 때문}1'
# 'cast from %0 to %1 drops %select{const and volatile qualifiers|const qualifier|volatile qualifier}2'
HA3B03023258D: '형 변환 중 %0에서 %1로 변환 시 %select{const와 volatile 자격 증명|const 자격 증명|volatile 자격 증명}2가 제거됩니다'
# 'cast from %0 to %1 increases required alignment from %2 to %3'
H4A02BB23383F: '형변환을 %0에서 %1로 하면 필요 최소 정렬이 %2에서 %3으로 증가합니다'
# 'cast from %0 to %1 must have all intermediate pointers const qualified to be safe'
HB7DFA89AF07B: '%0에서 %1로 캐스팅할 때 모든 중간 포인터가 const 자격을 가져야 안전합니다'
# 'cast from function call of type %0 to non-matching type %1'
H8CE3B0EB72DC: '함수 호출의 타입 %0에서 맞지 않는 타입 %1로 캐스팅했습니다'
# 'cast from pointer to smaller type %2 loses information'
H60D928000B5D: '포인터에서 더 작은 자료형 %2로 형 변환하면 정보가 손실됩니다'
# 'cast of %select{Objective-C|block|C}0 pointer type %1 to %select{Objective-C|block|C}2 pointer type %3 cannot use %select{__bridge|__bridge_transfer|__bridge_retained}4'
H2F5F45B60576: '%select{Objective-C|block|C}0 포인터 타입 %1을 %select{Objective-C|block|C}2 포인터 타입 %3으로 캐스팅할 때 %select{__bridge|__bridge_transfer|__bridge_retained}4를 사용할 수 없습니다'
# 'cast of type %0 to %1 is deprecated; use sel_getName instead'
HC7428E5162D0: '형 %0을 %1로의 캐스트는 더 이상 권장되지 않습니다; 대신 sel_getName을 사용하십시오'
# 'cast one or both operands to int to silence this warning'
H49949EF0EEB5: 'int로 피연산자를 한 개 또는 두 개 모두 형변환하면 이 경고를 없앨 수 있습니다.'
# 'cast to %1 from smaller integer type %0'
HF29EC08A2098: '%0에서 %1로의 형 변환 (더 작은 정수 형식에서의 변환)'
# 'cast to incomplete type %0'
HB29014F052FD: '%0 형식이 완성되지 않았습니다.'
# 'cast to smaller integer type %1 from %0'
H3EAB0F6AAF90: '더 작은 정수 형식 %1로 %0에서 형 변환'
# 'cast to union type from type %0 not present in union'
H26129A704E2A: '유니온 유형으로 변환하려는 %0 유형이 유니온에 존재하지 않습니다'
# 'cast to union type is a GNU extension'
H07ADEAB6CDD8: '유니온 타입으로 캐스트는 GNU 확장 기능입니다'
# 'casting from randomized structure pointer type %0 to %1'
H760D7A3D8C24: '랜덤화된 구조체 포인터 타입 %0에서 %1로의 형 변환'
# "casting to dereferenceable pointer removes 'noderef' attribute"
H435CE65222D6: "데퍼런스 가능한 포인터로 캐스팅하면 'noderef' 속성이 제거됩니다"
# 'casting to type %0 is not allowed'
H05073823504A: '형 %0로의 캐스팅은 허용되지 않습니다'
# 'catch-all handler must come last'
H18423565AC35: 'catch-all 처리기는 마지막에 와야 합니다.'
# 'category is implementing a method which will also be implemented by its primary class'
H12CCDCE8A3DF: '카테고리는 주 클래스가 또한 구현할 메소드를 구현하고 있습니다'
# "chained comparison 'X %0 Y %1 Z' does not behave the same as a mathematical expression"
HF2403FB0CB87: "연쇄 비교 'X %0 Y %1 Z'는 수학 표현과 동일한 동작을 하지 않습니다"
# 'change layout of basic blocks in a function'
HFA932943E87E: '함수 내 기본 블록의 레이아웃 변경'
# "change return type to 'int'"
H2DD08C8E9ADD: "리턴 타입을 'int'로 변경하시오"
# 'change size argument to be the size of the destination'
HC31A5632ABB1: 'size 인수를 대상의 크기로 변경하십시오'
# 'change the argument to be the free space in the destination buffer minus the terminating null byte'
H66702CDAA7E2: '인수를 목적지 버퍼의 사용 가능한 공간에서 종료 null 바이트를 제외한 값을 사용하십시오.'
# "change this ',' to a ';' to call %0"
H5A1EAB3B7F87: "이 ','를 ';'으로 바꿔 %0를 호출하세요."
# "change type of %0 to '%select{std::span' to preserve bounds information|std::array' to label it for hardening|std::span::iterator' to preserve bounds information}1%select{|, and change %2 to '%select{std::span|std::array|std::span::iterator}1' to propagate bounds information between them}3"
H1123F3B73559: "변수 %0의 형을 '%select{std::span'으로 바꾸어 경계 정보를 보존|std::array'으로 지정하여 강화를 위해 표시|std::span::iterator'으로 바꾸어 경계 정보를 보존}1%select{|, 그리고 %2를 '%select{std::span|std::array|std::span::iterator}1'로 바꾸어 경계 정보를 서로 전달}3"
# "change type of %0 to '%select{std::span' to preserve bounds information|std::array' to label it for hardening|std::span::iterator' to preserve bounds information}1%select{|, and change %2 to safe types to make function %4 bounds-safe}3"
H9C76AEF6C221: "%0의 형식을 '%select{std::span'을 사용하여 경계 정보를 보존하기 위해|std::array'를 사용하여 강화를 위해 라벨링하려면|std::span::iterator'을 사용하여 경계 정보를 보존하기 위해}1%select{|, 그리고 %2를 안전한 형식으로 변경하여 함수 %4가 경계 안전해지도록}3으로 변경하세요"
# 'char is signed'
H28989E053B4F: 'char는 부호가 있습니다'
# 'char is unsigned'
H2C9C5C4D7121: 'char는 부호가 없습니다'
# "character '%0' cannot be specified by a universal character name"
H9FDECB7636A6: "문자 '%0'은 보편 문자 이름으로 지정할 수 없습니다"
# 'character <U+%0> not allowed %select{in|at the start of}1 an identifier'
H0604F74F1073: '문자 <U+%0>는 %select{내부에서|시작 부분에}1 식별자에서 허용되지 않습니다'
# 'character constant too long for its type'
H99E005D8F34A: '문자 상수의 유형에 비해 너무 깁니다'
# 'character literal with user-defined suffix cannot be used here'
HB73A18549E7B: '사용자 정의 접미사를 가진 문자 리터럴은 여기서 사용할 수 없습니다'
# 'character too large for enclosing character literal type'
HFC3FA51117BB: '포함하는 문자 리터럴 형식에 너무 큰 문자입니다'
# 'characters names in Unicode escape sequences are sensitive to case and whitespaces'
H6FEF0F08A2BB: '유니코드 이스케이프 시퀀스에서 문자 이름들은 대소문자 및 공백에 민감합니다'
# 'charizing operator #@ is a Microsoft extension'
H374F252BD0E9: '#@ 연산자는 Microsoft 확장입니다'
# 'check arguments and return values at function call boundaries'
H68B4A050C0B9: '함수 호출 경계에서 인수와 반환 값을 검사합니다'
# "checker '%0' has no option called '%1'"
H473E877D384D: "checker '%0'에는 '%1'이라는 옵션이 없습니다."
# "checker cannot be enabled with analyzer option '%0' == %1"
H9705343670F8: "체커는 분석기 옵션 '%0'이 %1과 같을 때 활성화할 수 없습니다"
# "checker plugin '%0' is not compatible with this version of the analyzer"
H6AAE762D0724: "체커 플러그인 '%0'은 이 분석기 버전과 호환되지 않습니다"
# 'chosen constructor is explicit in copy-initialization'
H0B94DB59D2D8: '선택된 생성자는 copy-initialization에서 명시적입니다'
# 'circular pointer delegation detected'
H16A98512E3BA: '순환 포인터 대리가 감지되었습니다'
# 'clang LLVM compiler'
HFB02B9C0A298: 'Clang LLVM 컴파일러'
# 'clang-check options'
HEBD1BCAEB597: 'clang-check 옵션'
# 'clang-diff options'
HC57563571B39: 'clang-diff 옵션'
# 'clang-doc options'
H711FBA0260F1: 'clang-doc 옵션'
# 'clang-extdefmapgen options'
HD98304B7C5E5: 'clang-extdefmapgen 옵션'
# 'clang-move options'
H51D1273C1656: 'clang-move 옵션'
# 'clang-offload-bundler options'
H2BBBC154A925: 'clang-offload-bundler 옵션'
# 'clang-offload-packager options'
HBBA0DBA3D90F: 'clang-offload-packager 옵션'
# 'clang-query options'
HEE4551CABF87: 'clang-query 옵션'
# 'clang-rename could not find symbol %0'
H72B95322F623: 'clang-rename은 심볼 %0을 찾을 수 없습니다'
# 'clang-rename could not find symbol (offset %0)'
H9B2484C454C5: 'clang-rename은 기호를 찾을 수 없습니다 (오프셋 %0)'
# 'clang-reorder-fields options'
HB5EDCC7DF359: 'clang-reorder-fields 옵션'
# 'clang-tidy options'
H123FF2E74AC8: 'clang-tidy 옵션'
# 'clangd compilation flags options'
H9BB98137F26A: 'clangd 컴파일 플래그 옵션'
# 'class %0 defined without specifying a base class'
H3A2FB228D84B: 'class %0는 기반 클래스를 지정하지 않고 정의되었습니다'
# 'class %0 has incompatible superclasses'
HAE8DDB1E1535: '클래스 %0는 호환되지 않는 기반 클래스가 있습니다'
# 'class %0 previously declared with type parameters'
H5BCC48BDFD6B: 'class %0 이전에 형식 매개변수로 선언됨'
# "class already marked '%0'"
HCB141E8798E7: "클래스는 이미 '%0'로 표시되었습니다."
# "class already marked '%select{trivially_relocatable_if_eligible|replaceable_if_eligible}0'"
H5024671CC38B: "클래스가 이미 '%select{trivially_relocatable_if_eligible|replaceable_if_eligible}0'로 표시되어 있습니다."
# 'class extension has no primary class'
H14396A81AB6D: '클래스 확장에 기본 클래스가 없습니다.'
# 'class has %0 base %plural{1:class|:classes}0'
HD719F68B2E7D: '클래스는 %0개의 기본 %plural{1:클래스|클래스}0가 있습니다'
# 'class has base type %0'
H55F5972959B4: '이 클래스는 기반 타입 %0를 가집니다.'
# 'class implementation is declared here'
HFDD816FBE31D: '클래스 구현이 여기서 선언되었습니다'
# 'class implementation may not have super class'
HF88305654764: '클래스 구현은 슈퍼 클래스를 가질 수 없습니다'
# 'class is declared here'
H1CB72009FE78: 'class는 여기에서 선언되었습니다'
# 'class is incompatible with __weak references'
H5D4A2732A59E: '클래스는 __weak 참조와 호환되지 않습니다'
# 'class member %0 cannot appear in capture list as it is not a variable'
HB01A6BF35CAF: '클래스 멤버 %0는 변수가 아니므로 캡처 목록에 나타날 수 없습니다'
# "class member already marked '%0'"
H8651C68C3085: "클래스 멤버가 이미 '%0'로 지정되었습니다."
# 'class member cannot be redeclared'
H011ED139495E: '클래스 멤버는 재선언할 수 없습니다'
# "class method %objcclass0 not found (return type defaults to 'id')"
HA1F101EC915B: "클래스 메서드 %objcclass0를 찾을 수 없습니다 (리턴 타입은 기본값 'id'로 설정됩니다)"
# "class method %objcclass0 not found (return type defaults to 'id'); did you mean %objcclass2?"
H4EC4BD008AC8: "클래스 메서드 %objcclass0를 찾을 수 없음 (리턴 타입은 기본값 'id'로 설정됨); 의미하는 건 %objcclass2일까요?"
# 'class property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this category'
H70F68CFFF089: '클래스 속성 %0는 %1 메서드가 정의되어야 합니다 - @dynamic 속성을 사용하거나 이 카테고리에서 메서드 구현을 제공하십시오'
# 'class property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this class implementation'
HC6D0854C646B: 'class 속성 %0는 메서드 %1를 정의해야 합니다 - @dynamic을 사용하거나 이 클래스 구현에서 메서드 구현을 제공하십시오'
# 'class template %0 was explicitly specialized here'
HAF7828F4534C: 'class 템플릿 %0는 여기서 명시적으로 특수화되었습니다'
# 'class template %0 was instantiated here'
H67A993394D9A: '클래스 템플릿 %0가 여기서 인스턴스화되었습니다'
# 'class template argument deduction for %0 selected a deleted constructor'
H2F3153B3F0E2: '클래스 템플릿 인수 추론이 %0에서 삭제된 생성자를 선택했습니다'
# 'class template argument deduction for %0 selected an explicit %select{constructor|deduction guide}1 for copy-list-initialization'
HC409A532BB3A: '클래스 템플릿 인수 추론은 %0 복사-리스트 초기화를 위해 명시적인 %select{생성자|추론 가이드}1을 선택했습니다'
# 'class template argument deduction for alias templates is a C++20 extension'
HDC66CA6F51E2: '.alias 템플릿에 대한 클래스 템플릿 인수 추론은 C++20 확장 기능입니다'
# 'class template argument deduction for alias templates is incompatible with C++ standards before C++20'
H0A109AC10809: '별칭 템플릿에 대한 클래스 템플릿 인수 추론은 C++20 이전의 C++ 표준과 호환되지 않습니다.'
# 'class template argument deduction is incompatible with C++ standards before C++17%select{|; for compatibility, use explicit type name %1}0'
HCFEDA0AEF7C1: '클래스 템플릿 인수 추론은 C++17 이전의 C++ 표준과 호환되지 않습니다%select{|; 호환성을 위해 명시적인 타입 이름을 사용하십시오 %1}0'
# 'class template partial specialization %0 cannot be redeclared'
HD6C67286FA78: 'class 템플릿 부분 전문화 %0는 재선언될 수 없습니다'
# "class with destructor marked '%select{final|sealed}0' cannot be inherited from"
H8F6FAE53F32D: "소멸자가 '%select{final|sealed}0'로 지정된 클래스는 상속될 수 없습니다."
# 'class with specified objc_requires_property_definitions attribute is declared here'
H42C6E2F16E82: 'objc_requires_property_definitions 속성이 지정된 클래스가 여기서 선언되었습니다'
# 'cmse is not compatible with %select{RWPI|ROPI}0'
HC391A16C0EBD: 'CMSE는 %select{RWPI|ROPI}0와 호환되지 않습니다'
# "code model '%0' is not supported on this target"
HCF39144044A7: "'%0' 코드 모델은 이 타겟에서 지원되지 않습니다"
# 'code snippets to measure'
HC114C78CBCD4: '측정을 위한 코드 조각'
# 'code will never be executed'
H2586D13FCD3D: '이 코드는 절대로 실행되지 않습니다'
# 'collect control flow for each function'
H88E591AFCC3E: '각 함수의 제어 흐름을 수집'
# 'collection element of type %0 is not an Objective-C object'
H8FFDEDA7A274: '형식 %0의 콜렉션 요소는 Objective-C 개체가 아닙니다'
# 'collection expression type %0 is a forward declaration'
HDDCD4086A7F8: '수집 표현의 형식 %0은 전방 선언입니다'
# 'collection expression type %0 may not respond to %1'
H8F39224B1450: '콜렉션 표현 형식 %0는 %1에 응답하지 않을 수 있습니다'
# 'comma expressions are not allowed as indices in matrix subscript expressions'
H3F02FDCEC720: '콤마 표현식은 행렬 서브스크립트 표현식의 인덱스로 허용되지 않습니다'
# 'comma operator in operand of #if'
HDC042AF8F218: 'if #if의 피연산자에서 콤마 연산자 사용'
# 'comma separating Objective-C messaging arguments'
HAB4747C7C927: 'Objective-C 메시징 인수를 구분하는 콤마'
# 'comma-separated list of OpenMP offloading triples'
HB9DA81E6157C: '쉼표로 구분된 OpenMP 오프로딩 트리플 목록'
# 'comma-separated list of opcodes to measure, by name'
HC296D61A5AC3: '이름으로 쉼표로 구분된 Opcode 목록을 측정'
# 'comma-separated list of target architecture features'
H115643195B7E: '쉼표로 구분된 타겟 아키텍처 기능 목록'
# 'command line argument'
H13C820D51A04: '명령 줄 인수'
# 'commas at the end of enumerator lists are a C++11 extension'
H2EA69DF0ADB4: '열거자 목록의 끝에 있는 쉼표는 C++11 확장 기능입니다'
# 'commas at the end of enumerator lists are a C99-specific feature'
H1F877ED68177: '열거자 목록의 끝에 쉼표를 사용하는 것은 C99 고유의 기능입니다.'
# 'commas at the end of enumerator lists are incompatible with C++98'
H28609FC0503F: '열거자 목록 끝에 쉼표는 C++98과 호환되지 않습니다'
# 'comparing a pointer to a null character constant; did you mean to compare to %select{NULL|(void *)0}0?'
H5D12051B65A0: '포인터를 NULL 또는 (void*)0과 비교 중입니다; 비교하려는 의도는 %select{NULL|(void *)0}0이었나요?'
# 'comparing floating point with == or != is unsafe'
H1DE5EF3912E1: '부동소수점을 == 또는 != 연산자로 비교하는 것은 안전하지 않습니다'
# "comparing values of different Unicode code unit types %0 and %1 compares unrelated code units '%2' and '%3'"
H8DCD3F2A59F0: "다른 유니코드 코드 유닛 형식 %0과 %1의 값을 비교하면 관련 없는 코드 유닛 '%2'와 '%3'을(를) 비교합니다."
# 'comparing values of different Unicode code unit types %0 and %1 may compare different code points'
H29AC22B06621: '다른 유니코드 코드 유닛 형식 %0과 %1의 값을 비교하면 서로 다른 코드 포인트를 비교할 수 있습니다.'
# 'comparing with this %select{specifier|format string}0'
H0EA8BCD476F7: '이 %select{지정자|포맷 문자열}0과 비교 중입니다.'
# "comparison against address of weak declaration '%0' can only be performed at runtime"
H3C6EE2D92685: "약한 선언 '%0'의 주소와의 비교는 실행 시에만 수행될 수 있습니다"
# "comparison against opaque constant address '%0' can only be performed at runtime"
HAC7288F66309: "실행 시에만 수행할 수 있습니다: 불투명 상수 주소 '%0'와의 비교"
# "comparison against pointer '%0' that points past the end of a complete object has unspecified value"
H3D15A3D98DF0: "완전한 객체의 끝을 넘어 가리키는 포인터 '%0'와의 비교는 미지정 값이 있습니다"
# 'comparison against pointer to weak member %q0 can only be performed at runtime'
HFCA39B812783: '약한 멤버 포인터와의 비교는 런타임에서만 수행할 수 있습니다. %q0'
# 'comparison between NULL and non-pointer %select{(%1 and NULL)|(NULL and %1)}0'
H20F85EBECAC2: 'NULL과 비포인터 간의 비교 %select{(%1과 NULL)|(NULL과 %1)}0'
# 'comparison between pointer and integer (%0 and %1)'
H9205163E9BD4: '포인터와 정수(%0 및 %1) 간의 비교'
# "comparison between pointers to unrelated objects '%0' and '%1' has unspecified value"
H722AC288816C: "관련되지 않은 객체 포인터 '%0'과 '%1' 사이의 비교 결과는 정의되지 않았습니다."
# "comparison between two arrays compare their addresses and will be deprecated in c++20; to compare array addresses, use unary '+' to decay operands to pointers"
H5D551E6212F9: "두 배열 간의 비교는 그들의 주소를 비교하며, C++20에서 사용 중지될 예정입니다; 배열 주소를 비교하려면 단항 '+' 연산자를 사용하여 피연산자를 포인터로 약화시키세요"
# "comparison between two arrays is deprecated; to compare array addresses, use unary '+' to decay operands to pointers"
H4D3F55AAB37F: "두 배열 간 비교는 더 이상 권장되지 않음; 배열 주소를 비교하려면 단항 '+' 연산자를 사용하여 피연산자를 포인터로 암시적으로 변환하십시오"
# "comparison between two arrays is ill-formed in C++26; to compare array addresses, use unary '+' to decay operands to pointers"
H20B4EE22A6C2: "C++26에서 두 개의 배열 간 비교는 유효하지 않은 구문입니다; 배열 주소를 비교하려면 단항 '+' 연산자를 사용하여 피연산자를 포인터로 삭감시키세요"
# "comparison in fold expression would evaluate to '(X %0 Y) %0 Z' which does not behave the same as a mathematical expression"
HEA2CC1542868: "폴드 표현식의 비교는 '(X %0 Y) %0 Z'로 계산되며, 이는 수학 표현식과 동일하게 작동하지 않습니다."
# "comparison of %select{address of|function|array}0 '%1' %select{not |}2equal to a null pointer is always %select{true|false}2"
H61B7557646A7: "%select{주소의|함수|array}0 '%1'이 %select{아니 |}2NULL 포인터와 같다는 비교는 항상 %select{참|거짓}2입니다"
# 'comparison of address of base class subobject %0 of class %1 to field %2 has unspecified value'
HCEA4BEB9DFF0: '클래스 %1의 기반 클래스 서브오브젝트 %0의 주소와 %2 필드 간의 비교는 미지정 값이 있습니다'
# 'comparison of address of fields %0 and %2 of %4 with differing access specifiers (%1 vs %3) has unspecified value'
H30BB5DCF7738: '필드 %0과 %2의 주소 비교: %4의 접근 지정자가 다름(%1 vs %3)으로 값이 미지정 됨'
# 'comparison of addresses of potentially overlapping literals has unspecified value'
H59EF9C14B9AF: '중첩될 수 있는 리터럴의 주소 비교는 미지정 값입니다'
# 'comparison of addresses of subobjects of different base classes has unspecified value'
HA10192E66EB6: '다른 기반 클래스의 부객체 주소 비교는 값이 미지정되어 있습니다'
# 'comparison of different enumeration types in switch statement%diff{ ($ and $)|}0,1'
H820D2D4F7522: 'switch 문에서 다른 열거형 유형 간 비교%diff{ ($0와 $1)|}'
# 'comparison of distinct block types%diff{ ($ and $)|}0,1'
HA2CFC62DE473: '구분되는 블록 유형 간의 비교%diff{ ($와 $)|}0,1'
# 'comparison of distinct pointer types%diff{ ($ and $)|}0,1'
H1D24D97A54FF: '다른 포인터 유형 간 비교%diff{ ($와 $)|}0,1'
# 'comparison of integers of different signs: %0 and %1'
H8C3AA027FA1B: '부호가 다른 정수의 비교: %0과 %1'
# "comparison of nonnull %select{function call|parameter}0 '%1' %select{not |}2equal to a null pointer is '%select{true|false}2' on first encounter"
H9EDFDB49F3E3: "비_NULL 값과의 비교: '%select{함수 호출|매개변수}0' '%1' %select{와 같지 않은 |와의}2 비교는 첫 접근 시 '%select{true|false}2'로 평가됩니다"
# "comparison of numeric address '%0' with pointer '%1' can only be performed at runtime"
HFBF28443EB32: "수치형 주소 '%0'과 포인터 '%1'의 비교는 런타임에서만 수행될 수 있습니다"
# 'comparison of pointer to virtual member function %0 has unspecified value'
HDF5F345093AE: '가상 멤버 함수 포인터 %0의 비교는 정의되지 않은 값입니다'
# "comparison of pointers '%0' and '%1' to unrelated zero-sized objects"
H0C0F9C2F76E9: "관련 없는 크기 0 객체를 가리키는 포인터 '%0'와 '%1'의 비교"
# 'comparison operator template cannot be defaulted'
HC75525ADCB07: '비교 연산자 템플릿은 디폴트로 지정할 수 없습니다'
# "compatibility_version does not match: '%0' (provided) vs '%1' (found)"
H96AD79FF790D: "호환성 버전이 일치하지 않습니다: '%0' (제공된) vs '%1' (검색된)"
# 'compatible type %0 specified here'
HA0D702990A9A: '호환되는 타입 %0가 여기에 지정되었습니다'
# "compilation database '%0' could not be opened: %1"
H55D78247B7D8: "컴파일 데이터베이스 '%0'를 열 수 없습니다: %1"
# 'compile time floating point arithmetic suppressed in strict evaluation modes'
H1CBDE348A919: '엄격한 평가 모드에서 컴파일 타임 플로팅 포인트 산술 연산이 억제되었습니다'
# "compiled from '%0' and '%1'"
H27BB14892FCB: "'%0'와 '%1'에서 컴파일됨"
# 'compiler has implicitly changed method %0 return type'
HA0BE2730FEEE: '컴파일러가 암시적으로 %0 메소드의 반환 형식을 변경했습니다'
# 'completion handler is called twice'
HA50FDB30A90B: '완료 핸들러가 두 번 호출되었습니다'
# 'completion handler is never %select{used|called}1 when %select{taking true branch|taking false branch|handling this case|none of the cases applies|entering the loop|skipping the loop|taking one of the branches}2'
HF3977C617098: '완료 핸들러는 %select{사용되|호출되}1 %select{참 분기 시|거짓 분기 시|이 경우를 처리할 때|어떤 경우에도 해당되지 않을 때|루프에 진입할 때|루프를 건너뛸 때|분기 중 하나를 선택할 때}2에 절대 발생하지 않습니다'
# 'complex initialization specifying real and imaginary components is an extension'
H4D2B224EF174: '실수부와 허수부를 지정하는 복소수 초기화는 확장 기능입니다'
# 'complex integer types are a GNU extension'
H69724ED89FCA: '복합 정수 유형은 GNU 확장 기능입니다'
# 'complex numbers are an extension in a freestanding C99 implementation'
HC53143A84579: '복소수는 자립형 C99 구현체에서의 확장 기능입니다'
# 'compound binary operator not supported, only +=, *=, -=, /=, &=, ^=, |=, <<=, or >>= are permitted'
H7DD0E2130464: '복합 이진 연산자는 지원되지 않습니다. 허용되는 연산자는 +=, *=, -=, /=, &=, ^=, |=, <<=, 또는 >>= 만입니다'
# 'compound literal cannot be of variable-length array type'
H35B29277CD5B: '복합 리터럴은 가변 길이 배열 형식일 수 없습니다'
# 'compound literal in function scope may not be qualified with an address space'
H5D92A895F54C: '함수 범위 내의 복합 리터럴은 주소 공간을 지정할 수 없습니다'
# 'compound literals are a C99-specific feature'
H89109EF1C578: '복합 리터럴은 C99의 고유 기능입니다'
# 'concatenated NSString literal for an NSArray expression - possibly missing a comma'
H05B938722790: 'NSArray 표현식에 대한 연결된 NSString 리터럴 - 쉼표 누락 가능성'
# 'concept cannot have associated constraints'
H2D3AA7366D73: '개념에는 연결된 제약 조건이 있을 수 없습니다'
# 'concept declarations may only appear in global or namespace scope'
HC471DCAA93F1: '컨셉 선언은 글로벌 또는 네임스페이스 스코프에만 나타날 수 있습니다'
# 'concept named in type constraint is not a type concept'
H745ADE930837: '타입 제약에서 지정된 concept은 타입 concept이 아닙니다'
# 'concept template parameter list must have at least one parameter; explicit specialization of concepts is not allowed'
HBDA562F258A9: 'concept 템플릿 매개변수 목록은 적어도 하나의 매개변수가 필요합니다; concepts의 명시적 특수화는 허용되지 않습니다'
# "condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', %select{or '>='|'>=', or '!='}0) of loop variable %1"
H8BF46A7D7B10: "OpenMP for 루프의 조건은 루프 변수 %1에 대한 관계 비교('<', '<=', '>', %select{또는 '>='|'>=', 또는 '!='}0)여야 합니다"
# 'conditional expression is ambiguous; %diff{$ and $|types}0,1 can be converted to several common types'
H9909B5566589: '조건식이 불분명합니다; %diff{$ 및 $|types}0,1은 여러 가지 공통된 유형으로 변환될 수 있습니다'
# 'conditional expression is ambiguous; %diff{$ can be converted to $ and vice versa|types can be convert to each other}0,1'
HD6EF4047D3B6: '조건부 표현식이 모호합니다; %diff{첫 번째 타입은 두 번째 타입으로 변환될 수 있으며 그 반대도 마찬가지입니다|타입들은 서로 변환될 수 있습니다}0,1'
# "configuration file '%0' cannot be found"
HF43B1D62E529: "구성 파일 '%0'를 찾을 수 없습니다"
# "configuration file '%0' cannot be opened: %1"
H91238BB29F2B: "설정 파일 '%0'을(를) 열 수 없습니다: %1"
# 'configuration macros are only allowed in top-level modules'
HC1EFBD1A6AB2: '구성 매크로는 최상위 모듈에서만 허용됩니다'
# 'conflicting %0 here'
H178724C0754B: '여기에서 %0와 충돌'
# 'conflicting __device__ function declared here'
H6D42767A98E2: '여기서 선언된 __device__ 함수와 충돌합니다'
# 'conflicting address space qualifiers are provided between types %0 and %1'
HA444D7C677AE: '유형 %0과 %1 사이에 제공된 주소 공간 지정자가 충돌합니다'
# 'conflicting asm label'
H08C5ACC499B8: '충돌하는 asm 레이블'
# 'conflicting attribute is here'
HB210D5E7919C: '충돌하는 속성이 여기 있습니다'
# 'conflicting attributes %0 are ignored'
H43DE73EC415F: '충돌하는 속성 %0는 무시됩니다'
# "conflicting attributes for state '%0'"
H30B7C9BA9F57: "상태 '%0'에 대한 충돌하는 속성"
# 'conflicting code segment specifiers'
HF81F9823233E: '충돌하는 코드 섹션 지정자들'
# 'conflicting declaration'
H9D2B5D5AA66E: '衝突하는 선언'
# 'conflicting deduction %diff{$ against $|types}0,1 for parameter'
H0919F4EB4F97: '매개변수에 대한 %diff{ $와 $ 간의 충돌 | 타입 }0,1의 추론이 충돌합니다'
# "conflicting deployment targets, both '%0' and '%1' are present in environment"
H8F50D7638091: "배포 대상 간 충돌: 환경에 '%0'과 '%1'이 모두 존재합니다"
# 'conflicting distributed object modifiers on parameter type in declaration of %0'
H4CB94BB5639A: '선언 %0의 매개변수 타입에서 분산 객체 수정자가 충돌합니다.'
# 'conflicting distributed object modifiers on parameter type in implementation of %0'
HA9E88E86F6C2: '구현 %0의 매개변수 유형에 대한 분산 객체 수정자 간의 충돌'
# 'conflicting distributed object modifiers on return type in declaration of %0'
HBE23CBB42FFE: '리턴 타입에 대한 분산 객체 수정자가 충돌합니다: %0의 선언에서'
# 'conflicting distributed object modifiers on return type in implementation of %0'
HBB60CEE9C2B2: '리턴 타입에 대한 분산 객체 모디파이어가 %0 구현에서 충돌합니다'
# 'conflicting instance variable names: %0 vs %1'
H088E6A0E59D6: '충돌하는 인스턴스 변수 이름: %0 vs %1'
# 'conflicting loop attribute %0'
H69465530AFA7: '충돌하는 루프 속성 %0'
# 'conflicting nullability specifier on parameter types, %0 conflicts with existing specifier %1'
H11AC0D03E320: '매개변수 유형의 null 가능 지정자가 충돌합니다: %0은 기존 지정자 %1과 충돌합니다'
# 'conflicting nullability specifier on return types, %0 conflicts with existing specifier %1'
H9D01BC58F478: '반환 유형의 null 가능성 지정자가 충돌했습니다: %0은 기존의 지정자 %1과 충돌합니다'
# "conflicting option '-fcoro-aligned-allocation' and '-fno-aligned-allocation'"
HD53AB264ABE6: "충돌하는 옵션 '-fcoro-aligned-allocation'과 '-fno-aligned-allocation'"
# 'conflicting parameter qualifier %0 on parameter %1'
HC7B786535E39: '매개변수 %1의 자격 지정자 %0이 충돌합니다'
# 'conflicting parameter types in declaration of %0%diff{: $ vs $|}1,2'
HCBD5D6ED758A: '%0의 선언에서 충돌하는 매개변수 유형%diff{: $ vs $|}1,2'
# 'conflicting parameter types in declaration of %0: %1 vs %2'
HF405BA99A067: '%0의 선언에서 충돌하는 매개변수 유형: %1 vs %2'
# 'conflicting parameter types in implementation of %0%diff{: $ vs $|}1,2'
H64F50A39ECB1: '구현체에서 %0%diff{: $와 $|}1,2의 매개변수 형식이 충돌합니다'
# 'conflicting parameter types in implementation of %0: %1 vs %2'
HC0C8356B7475: '구현 %0에서 매개변수 유형 충돌: %1 vs %2'
# 'conflicting pass_object_size attributes on parameters'
H99CE421CA443: '매개변수에 대한 pass_object_size 속성 간 충돌'
# 'conflicting prototype is here'
HF896EFD79698: '충돌하는 프로토타입은 여기에 있습니다'
# "conflicting re-export of module '%0' as '%1' or '%2'"
H8B0F3A29C0A1: "모듈 '%0'을 '%1' 또는 '%2'로 재수출하는 충돌"
# 'conflicting return type in declaration of %0%diff{: $ vs $|}1,2'
H2BB3153B6C50: '%0의 선언에서 반환 타입이 충돌합니다%diff{: $와 $|}1,2'
# 'conflicting return type in declaration of %0: %1 vs %2'
H5D783A189DCF: '선언 %0의 반환 타입이 충돌했습니다: %1 대 %2'
# 'conflicting return type in implementation of %0%diff{: $ vs $|}1,2'
HEB354C372ED1: '구현 %0에서 반환 형식이 충돌했습니다%diff{: $ 대 $|}1,2'
# 'conflicting return type in implementation of %0: %1 vs %2'
H5C54E8625E6A: '%0의 구현에서 반환 형식이 충돌했습니다: %1 대 %2'
# 'conflicting super class name %0'
HF493EF2E1E41: '衝突하는 슈퍼 클래스 이름 %0'
# 'conflicting types for %0'
H5E0475C2D7BC: '형식이 충돌하는 %0'
# 'conflicting types for alias %0'
HCE7DAE70AA85: '_ALIAS %0에 대한 충돌하는 유형'
# 'conflicting variadic declaration of method and its implementation'
H2A0A12EA2AF3: '메서드의 가변 인자 선언과 그 구현이 충돌합니다'
# 'conformance of forward class %0 to protocol %1 cannot be confirmed'
H978A4E78BB8C: '포워드 클래스 %0가 프로토콜 %1을 준수할 수 없습니다'
# "consecutive right angle brackets are incompatible with C++98 (use '> >')"
H77515E521F08: "연속된 우각형 괄호( '> >')는 C++98과 호환되지 않습니다( '> >'를 사용하십시오)"
# 'conservative handling of inline assembly'
H316430B34522: '인라인 어셈블리에 대한 보수적 처리'
# "consider adding '%0' to the header search path"
HCE15ED850DE4: "헤더 검색 경로에 '%0'을 추가하는 것을 고려해 보십시오."
# "consider defining %0 with the '%1' calling convention"
H6A4F6FD30F2D: "%0를 '%1' 호출 규약으로 정의하는 것을 고려해 보십시오"
# 'consider making the bit-field type %select{unsigned|signed}0'
HDAE81431A685: '비트 필드 유형을 %select{unsigned|signed}0로 변경하는 것을 고려해 보세요.'
# 'consider providing a complete definition for %0'
H2F6F79E2A183: '%0에 대한 완전한 정의를 제공하는 것을 고려하세요'
# "consider using '__sized_by%select{|_or_null}0' instead of '__counted_by%select{|_or_null}0'"
H40017362835A: "'__counted_by%select{|_or_null}0' 대신 '__sized_by%select{|_or_null}0'을 사용하는 것을 고려하세요"
# "consider using __builtin_trap() or qualifying pointer with 'volatile'"
H002E765592F2: '__builtin_trap()를 사용하거나 포인터를 volatile로 지정하도록 고려해 보세요'
# 'consider using vld1_%0%1() to initialize a vector from memory, or vcreate_%0%1() to initialize from an integer constant'
H3E54619F1458: '메모리에서 벡터를 초기화하려면 vld1_%0%1()을 사용하거나, 정수 상수에서 초기화하려면 vcreate_%0%1()을 사용해 보세요'
# 'consider using vld1q_%0%1() to initialize a vector from memory, or vcombine_%0%1(vcreate_%0%1(), vcreate_%0%1()) to initialize from integer constants'
H0B91FFD90BE8: '메모리에서 벡터를 초기화하려면 vld1q_%0%1()을 사용하거나, 정수 상수에서 초기화하려면 vcombine_%0%1(vcreate_%0%1(), vcreate_%0%1())을 사용을 고려하세요'
# 'const variable cannot be emitted on device side due to dynamic initialization'
H2D4E40F2FA4A: 'const 변수는 동적 초기화 때문에 디바이스 측에서 발생시킬 수 없습니다'
# 'const-qualified list item cannot be %0'
HABDF81BBC813: 'const 자격 증명이 있는 리스트 항목은 %0일 수 없습니다'
# 'const-qualified variable cannot be %0'
H02E8DDC8D310: 'const로 선언된 변수는 %0할 수 없습니다.'
# 'const-qualified variable without mutable fields cannot be %0'
HF38DA802B6DD: '가변 필드가 없는 const 자격 지정된 변수는 %0 될 수 없습니다'
# 'constant evaluation of %0 between arrays of types %1 and %2 is not supported; only arrays of narrow character types can be compared'
H42EAC15FC487: '유형 %1과 %2의 배열 사이에서 %0의 상수 평가는 지원되지 않습니다; 좁은 문자 유형의 배열만 비교할 수 있습니다'
# 'constant evaluation of %0 on array of type %1 is not supported; only arrays of narrow character types can be searched'
HCF9A8296188E: '형식 %1의 배열에 대한 %0의 상수 평가는 지원되지 않습니다; 좁은 문자 형식의 배열만 평가할 수 있습니다'
# 'constant expression evaluates to %0 which cannot be narrowed to type %1'
HE08100927247: '상수 표현식이 %0으로 평가되나, %1 타입으로 좁혀지지 않습니다'
# 'constant expression evaluates to %0 which cannot be narrowed to type %1 in C++11'
H3A70E9ED4BE6: '상수 표현식이 %0으로 평가되었으나, C++11에서 타입 %1로 좁혀지지 않습니다'
# 'consteval function %0 cannot override a non-consteval function'
HD9788F98961F: 'consteval 함수 %0는 non-consteval 함수를 오버라이드할 수 없습니다.'
# 'consteval if is a C++23 extension'
H32DA4F52DDFE: 'consteval if는 C++23 확장 기능입니다'
# 'consteval if is always true in an %select{unevaluated|immediate}0 context'
HFA38139DBCC5: 'consteval if는 %select{평가되지 않은|즉각적인}0 컨텍스트에서 항상 참입니다'
# 'consteval if is incompatible with C++ standards before C++23'
H3BF3B6976984: 'consteval if는 C++23 이전의 C++ 표준과 호환되지 않습니다'
# 'constexpr %select{member function|constructor}0 not allowed in %select{struct|interface|class}1 with virtual base %plural{1:class|:classes}2'
HA87030D3447E: 'constexpr %select{멤버 함수|생성자}0은 %select{구조체|인터페이스|클래스}1에 가상 기반 클래스%plural{1:class|:classes}2가 있는 경우 허용되지 않습니다'
# 'constexpr bit cast involving type %0 is not yet supported'
H93DC3AD734F6: '유형 %0를 포함하는 constexpr 비트 캐스트는 아직 지원되지 않습니다'
# 'constexpr bit_cast involving bit-field is not yet supported'
HCF05A23F6C40: 'constexpr bit_cast가 비트 필드를 포함하는 경우는 아직 지원하지 않습니다'
# 'constexpr constructor that does not initialize all members is a C++20 extension'
H6D6AAEF0CE01: 'constexpr 생성자가 모든 멤버를 초기화하지 않으면 C++20 확장 기능입니다'
# 'constexpr constructor that does not initialize all members is incompatible with C++ standards before C++20'
H6CD8A3688EC0: 'constexpr 생성자가 모든 멤버를 초기화하지 않으면 C++20 이전의 C++ 표준과 호환되지 않습니다'
# 'constexpr evaluation exceeded maximum depth of %0 calls'
H71A1AF77C8D7: 'constexpr 평가가 %0 호출의 최대 깊이를 초과했습니다'
# 'constexpr evaluation hit maximum call limit'
H2D336AD5FC66: 'constexpr 평가가 최대 호출 제한을 초과했습니다'
# 'constexpr evaluation hit maximum heap allocation limit'
HEA6F0C77C92E: 'constexpr 평가는 최대 힙 할당 한도를 초과했습니다.'
# 'constexpr evaluation hit maximum step limit; possible infinite loop?'
H3A9C6A5C602B: 'constexpr 평가가 최대 단계 한도를 초과했습니다; 무한 루프일 가능성이 있습니다'
# 'constexpr function %0 without __host__ or __device__ attributes cannot overload __device__ function with the same signature; add a __host__ attribute, or build with -fno-cuda-host-device-constexpr'
HAF2225A9BAA0: '__host__ 또는 __device__ 속성이 없는 constexpr 함수 %0는 같은 시그니처를 가진 __device__ 함수와 오버로드할 수 없습니다. __host__ 속성을 추가하거나, -fno-cuda-host-device-constexpr로 빌드하세요.'
# 'constexpr function with no return statements is incompatible with C++ standards before C++14'
H60A27D48D081: '리턴 문이 없는 constexpr 함수는 C++14 이전의 C++ 표준과 호환되지 않습니다'
# 'constexpr if condition is not a constant expression'
H9AC357BF4F5E: 'constexpr if 조건은 상수 표현식이 아닙니다'
# 'constexpr if is a C++17 extension'
H8C78EE861C25: 'constexpr if는 C++17 확장 기능입니다'
# 'constexpr if is incompatible with C++ standards before C++17'
H518345725A13: 'C++17 이전의 C++ 표준과 호환되지 않는 constexpr if 문입니다.'
# 'constexpr initializer evaluates to %0 which is not exactly representable in type %1'
HFD7668DF8CE8: 'constexpr 초기화자는 %0으로 평가되나, 이 값은 %1 타입에 정확히 표현될 수 없습니다'
# 'constexpr initializer for type %0 is of type %1'
H57EA50C1B712: '유형 %0의 constexpr 초기식은 유형 %1입니다'
# 'constexpr on lambda expressions is incompatible with C++ standards before C++17'
H2F64715F9E19: '람다 표현식에 적용된 constexpr은 C++17 이전의 C++ 표준과 호환되지 않습니다'
# 'constexpr pointer initializer is not null'
HA90F435C9DCD: 'constexpr 포인터 초기화자는 null이 아닙니다'
# 'constexpr union constructor that does not initialize any member is a C++20 extension'
HDA9656DF3125: 'constexpr 연합 생성자 중 아무 멤버도 초기화하지 않는 것은 C++20 확장 기능입니다'
# 'constexpr union constructor that does not initialize any member is incompatible with C++ standards before C++20'
H42AB5A6736FE: 'constexpr 유니온 생성자가 아무 멤버도 초기화하지 않으면 C++20 이전의 C++ 표준과 호환되지 않습니다'
# 'constexpr variable %0 must be initialized by a constant expression'
H22D6867A6C46: 'constexpr 변수 %0는 상수 표현식으로 초기화되어야 합니다'
# 'constexpr variable %0 must have constant destruction'
H0CB1A9F457E9: 'constexpr 변수 %0는 상수 소멸을 가져야 합니다'
# 'constexpr variable cannot have non-literal type %0'
H8CA68B10BD1E: 'constexpr 변수는 비리터럴 형식 %0을 가질 수 없습니다'
# 'constexpr variable cannot have type %0'
H9CBE3FDAF244: 'constexpr 변수는 %0 형식을 가질 수 없습니다'
# 'constexpr variable declaration must be a definition'
H28D5C206A058: 'constexpr 변수 선언은 정의여야 합니다'
# 'constrained by %select{|implicitly }1%select{private|protected}0 inheritance here'
HA215ECA901D4: '제약됨: 여기서 %select{|암시적으로 }1%select{private|protected}0 상속에 의해'
# "constrained placeholder types other than simple 'auto' on non-type template parameters not supported yet"
HA5CE432D2BF4: "비유형 템플릿 매개변수에서 단순한 'auto' 제외된 제약된 플레이스홀더 형식은 아직 지원되지 않았습니다"
# "constraint '%0' is already present here"
HDBC0B5C441D3: "제약 조건 '%0'은 이미 여기에 존재합니다"
# 'constraint depends on a previously diagnosed expression'
HE3836E579C9B: '제약은 이전에 진단된 표현에 의존합니다'
# 'constraints not satisfied for %select{class template|function template|variable template|alias template|template template parameter|template}0 %1%2'
H81A668F064ED: '제약 조건이 충족되지 않았습니다: %select{클래스 템플릿|함수 템플릿|변수 템플릿|별칭 템플릿|템플릿 템플릿 매개변수|템플릿}0 %1%2'
# "construct '%0' not allowed in a region associated with a directive with 'order' clause"
HC4C995E5BA30: "구문 '%0'는 'order' 절을 갖는 디렉티브와 연관된 영역에서 허용되지 않습니다"
# 'construction of individual component of complex number is not yet supported in constant expressions'
H0E4CD910394F: '복소수의 개별 구성 요소 생성은 상수 표현식에서 아직 지원되지 않습니다'
# 'constructor call from initializer list is incompatible with C++98'
HB192963D1DEE: '초기화자 목록에서 생성자 호출은 C++98와 호환되지 않습니다'
# "constructor cannot be declared '%0'"
HC6A3768462FF: "생성자는 '%0'로 선언할 수 없습니다."
# 'constructor cannot be redeclared'
H55F24B0BC81F: '생성자는 재선언할 수 없습니다'
# 'constructor cannot have a return type'
H859AAE558539: '생성자는 반환 타입을 가질 수 없습니다'
# 'constructor for %0 creates a delegation cycle'
H475456925F83: '생성자 %0에 대한 생성자가 대리 순환을 생성합니다'
# 'constructor from base class %0 inherited here'
H1711561364CF: '기반 클래스 %0에서 상속된 생성자'
# 'constructor inherited by %0 from base class %1 is implicitly deleted'
H97CFC0CC7D39: '클래스 %0가 기반 클래스 %1으로부터 상속받은 생성자가 암시적으로 삭제되었습니다'
# 'constructor inherited from base class %0 cannot be used in a constant expression; derived class cannot be implicitly initialized'
HC12464115FAE: '기반 클래스 %0에서 상속받은 생성자는 상수 표현식에서 사용할 수 없습니다; 파생 클래스는 암시적으로 초기화될 수 없습니다'
# 'constructor initializer %0 does not name a class'
HCFC849237163: '생성자 초기화자 %0은 클래스 이름이 아닙니다'
# 'constructor of %0 inherited from multiple base class subobjects'
HC9F4CC1EE50E: '%0의 생성자가 다중 기반 클래스 서브 오브젝트에서 상속되었습니다'
# 'constructor of base class %0 is not called'
H3174F7100ABA: '기반 클래스 %0의 생성자가 호출되지 않았습니다'
# 'constructor parameter %0 shadows the field %1 of %2'
H11CEF1CBDAF0: '생성자 매개변수 %0은 %2의 필드 %1을 그림자 변수로 만듭니다.'
# "constructs with the same name must have a 'hint' clause with the same value"
H0760234C4455: "같은 이름을 가진 구조체는 'hint' 절에 동일한 값을 가져야 합니다."
# "consumed analysis attribute is attached to member of class %0 which isn't marked as consumable"
H05C072713E0E: '소비 분석 속성이 class %0의 멤버에 부착되었지만, 해당 클래스는 소비 가능하도록 표시되지 않았습니다'
# 'container access result unused - container access should not be used for side effects'
H8AF2586DAD21: '컨테이너 액세스 결과 사용되지 않음 - 컨테이너 액세스는 부작용을 위해 사용되어서는 안 됨'
# 'context %select{set|selector|property}0 options are: %1'
H10E910F395AC: '컨텍스트 %select{set|selector|property}0 옵션은: %1'
# 'continue even if build-ids in input binary and perf.data mismatch'
HF64C3EBD8AC2: '입력 바이너리 및 perf.data의 빌드 ID가 불일치하더라도 계속 진행합니다'
# 'control flows through the definition of a %select{static|thread_local}0 variable'
HBD024CE03438: '제어 흐름이 %select{정적|thread_local}0 변수의 정의를 통과합니다'
# 'control reached end of constexpr function'
HE6815340E241: 'constexpr 함수의 끝 부분에 제어 흐름이 도달했습니다.'
# 'controlling expression type %0 compatible with %1 generic association types'
HB8A1ADD97071: '제어 표현식 유형 %0는 %1 제네릭 연관 유형과 호환됩니다.'
# 'controlling expression type %0 not compatible with any generic association type'
H55E9ACCD45B7: '제어 표현식 형식 %0가 어떤 일반적 연관 형식과도 호환되지 않습니다.'
# "convenience initializer missing a 'self' call to another initializer"
HF14170AD5005: "편의 초기화자가 다른 초기화자에 대한 'self' 호출이 누락되었습니다"
# "convenience initializer should not invoke an initializer on 'super'"
HA39139A75170: "편의 초기화자는 'super'의 초기화자를 호출해서는 안 됩니다"
# 'conversion %diff{from $ to $|between types}0,1 is ambiguous'
HDD7803D6F7A1: '전환 %diff{에서 $로 $|형식 사이}0,1은 애매합니다'
# 'conversion between fixed point and %0 is not yet supported'
HF68AF1DBEB64: '고정 소수점과 %0 간의 변환이 아직 지원되지 않습니다'
# 'conversion between matrix type %0 and incompatible type %1 is not allowed'
H499A22E2DD8F: '행렬 유형 %0과 호환되지 않는 유형 %1 간의 변환은 허용되지 않습니다'
# 'conversion between matrix types%diff{ $ and $|}0,1 of different size is not allowed'
H82DF9F4CF265: '다른 크기를 가진 행렬 유형%diff{ $와 $|}0,1 간의 변환은 허용되지 않습니다'
# 'conversion candidate %0 not viable: constraints not satisfied'
H1A87D3FA633E: '변환 후보 %0는 적합하지 않음: 제약 조건이 충족되지 않음'
# 'conversion candidate of type %0'
H1704891C4D79: '%0 유형의 변환 후보'
# 'conversion from %0 to %1 in converted constant expression would bind reference to a temporary'
H22C174FA2D9C: '변환된 상수 표현식 내에서 %0에서 %1로의 변환은 일시적 객체에 대한 참조를 바인딩하게 됩니다'
# 'conversion from %0 to %1 is not allowed in a converted constant expression'
H64DA1E381CAE: '변환된 상수 표현식에서 %0에서 %1로의 변환은 허용되지 않습니다'
# 'conversion from pointer to member of class %0 to pointer to member of class %1 via virtual base %2 is not allowed'
HC6DC2FD11DE6: '클래스 %0의 멤버 포인터에서 클래스 %1의 멤버 포인터로 가상 기반 %2를 통해 변환하는 것은 허용되지 않습니다'
# 'conversion from string literal to %0 is deprecated'
H1DEAC81E3C65: '문자열 리터럴에서 %0로의 변환은 사용하지 않도록 권고됨'
# 'conversion function %diff{from $ to $|between types}0,1 invokes a deleted function%select{|: %3}2'
H302A0E48B3BA: '형 변환 함수 %diff{에서 $로|타입 간}0,1이 삭제된 함수를 호출합니다%select{|: %3}2'
# 'conversion function cannot be redeclared'
HA31D9D61E048: '변환 함수는 재선언 될 수 없습니다'
# 'conversion function cannot be variadic'
H28A6D9FD4C07: '변환 함수는 가변 인자 함수일 수 없습니다'
# 'conversion function cannot convert to a function type'
H61F51031942B: '변환 함수는 함수 형식으로 변환할 수 없습니다'
# 'conversion function cannot convert to an array type'
H431E774C8920: '변환 함수는 배열 타입으로 변환할 수 없습니다'
# 'conversion function cannot have a return type'
H846A21D09489: '형 변환 함수는 반환 형식을 가질 수 없습니다'
# 'conversion function cannot have any parameters'
H9E24A8535723: '변환 함수는 매개변수를 가질 수 없습니다'
# 'conversion function converting %0 to %1 will never be used'
H960F42AADA51: '변환 함수가 %0을 %1로 변환하는 것은 사용되지 않을 것입니다'
# 'conversion function converting %0 to its base class %1 will never be used'
H1FE504FD028F: '변환 함수 %0을 기반 클래스 %1로 변환하는 것은 결코 사용되지 않을 것입니다'
# 'conversion function converting %0 to itself will never be used'
HC22DB2DAD0D5: '%0를 자기 자신으로 변환하는 변환 함수는 사용되지 않을 것입니다'
# 'conversion function must be a non-static member function'
HCACC98687D9A: '변환 함수는 비정적 멤버 함수여야 합니다'
# 'conversion to %select{integral|enumeration}0 type %1'
H52D400CB1F4D: '형식 %select{정수형|열거형}0 %1로의 변환'
# 'conversion to %select{integral|enumeration}0 type %1 declared here'
H126F1D6252B2: '정수형 또는 열거형으로의 형 변환 %select{정수형|열거형}0 유형 %1 여기서 선언됨'
# 'conversion to pointer type %0'
H88631D898FE3: '포인터 형식 %0로의 변환'
# 'convert moves with rbp stack memory operand (unsafe, must be off for binaries compiled with -fomit-frame-pointer)'
H9F1E879B6ED5: 'rbp 스택 메모리 연산자를 사용한 이동 변환 (안전하지 않음, -fomit-frame-pointer 옵션으로 컴파일된 바이너리에서는 사용하지 않아야 함)'
# 'convert moves with stack memory operand (potentially unsafe)'
HC5050FEB738B: '스택 메모리 피연산자를 가진 이동 변환(잠재적으로 위험할 수 있음)'
# 'converting delete expression from type %0 to type %1 invokes an explicit conversion function'
HFA594BB552D0: 'delete 표현식을 %0 형식에서 %1 형식으로 변환하면 명시적 변환 함수가 호출됩니다'
# 'converting the enum constant to a boolean'
HC26D67935F61: 'enum 상수를 불리언으로 변환 중입니다'
# "converting the result of '<<' to a boolean always evaluates to %select{false|true}0"
H66F90B0804A0: "연산자 '<<'의 결과를 불리언으로 변환하면 항상 %select{false|true}0으로 평가됩니다"
# "converting the result of '<<' to a boolean; did you mean to compare with '0'?"
H2022F6B0CFBA: "'<<' 결과를 불리언으로 변환하고 있습니다; '0'과 비교하려는 것이었나요?"
# "converting the result of '?:' with integer constants to a boolean always evaluates to 'true'"
H0B52D2457927: "정수 상수와 함께 '?:'의 결과를 불리언으로 변환하면 항상 'true'로 평가됩니다"
# 'converting to boxing syntax requires casting %0 to %1'
HDE90319BAAF3: '박싱 문법으로 변환하려면 %0을 %1로 캐스팅해야 합니다'
# 'coprocessor %0 must be configured as %select{GCP|CDE}1'
H4C456D50EC55: '코프로세서 %0는 %select{GCP|CDE}1로 구성해야 합니다'
# 'copy %select{constructor|assignment operator}0 is implicitly deleted because %1 has a user-declared move %select{constructor|assignment operator}2'
HBE99D1D6F119: '복사 %select{생성자|할당 연산자}0는 %1이 사용자 선언된 이동 %select{생성자|할당 연산자}2를 가지고 있어서 암묵적으로 삭제되었습니다'
# 'copy constructor must pass its first argument by reference'
H3ABFF716FBF3: '복사 생성자는 첫 번째 인수를 참조로 전달해야 합니다'
# 'copy constructor of %0 is implicitly deleted because field %1 is of rvalue reference type %2'
H5B9C818EF5D6: '복사 생성자 %0는 필드 %1이 rvalue 참조 유형 %2이기 때문에 암시적으로 삭제되었습니다'
# 'copying a temporary object of incomplete type %0'
H4C050E15C304: '%0 완전하지 않은 형식의 일시적인 객체 복사'
# "coroutine %0 cannot be declared 'noreturn' as it always returns a coroutine handle"
H7F1772343EA2: "코루틴 %0는 'noreturn'로 선언될 수 없습니다. 이 코루틴은 항상 코루틴 핸들을 반환하기 때문입니다"
# "could not acquire lock file for module '%0': %1"
H0C3259D0CAD4: "모듈 '%0'에 대한 lock 파일을 획득할 수 없습니다: %1"
# "could not build module '%0'"
H0F4C1C79774B: "모듈 '%0'을 생성할 수 없습니다"
# "could not calculate number of iterations calling 'operator-' with upper and lower loop bounds"
H55F92FED58CA: "상한과 하한 루프 경계를 사용하여 'operator-'를 호출할 때 이터레이션 수를 계산할 수 없습니다"
# 'could not determine the original source location for %0:%1:%2'
H596D1B547578: '원본 소스 위치를 %0:%1:%2에 대해 확인할 수 없습니다'
# "could not find ';' after @import"
H808D2C4625A0: "import 뒤에 ';'를 찾을 수 없습니다"
# 'could not find Objective-C class %0 to convert %1 to %2'
H8A434A2F54F7: 'Objective-C 클래스 %0를 찾을 수 없습니다. %1을 %2로 변환하기 위해'
# 'could not match %diff{$ against $|types}0,1'
HB17669DA1C41: '타입 %diff{$과 $ 매칭 실패|}0,1'
# "could not open '%0' for embedding"
HF452E067B4E2: "임베딩을 위해 '%0'을(를) 열 수 없습니다"
# "could not read %0 input list '%1': %2"
H67879BBD7E88: "입력 목록 %0 '%1'을 읽을 수 없습니다: %2"
# "could not read directory '%0': %1"
HBA8BA2C7E279: "디렉토리 '%0'을 읽을 수 없습니다: %1"
# "could not remap file '%0' to the contents of file '%1'"
H154079BD4163: "파일 '%0'을 '%1' 파일의 내용으로 재매핑할 수 없습니다."
# 'covariant thunk required by %0'
H96E8ACBA5464: '공변Thunk가 %0에 의해 필요합니다'
# "cpu '%0' does not support rv%select{32|64}1"
HB22CC79010F2: "CPU '%0'는 rv%select{32|64}1을 지원하지 않습니다."
# 'create a static PC table'
HA9821FD0C9F2: '정적 PC 테이블을 생성합니다'
# "current API version is '%0', but plugin was compiled with version '%1'"
H399ED19E4A74: "현재 API 버전은 '%0'이지만, 플러그인은 버전 '%1'로 컴파일되었습니다"
# 'current file is older than dependency %0'
HCE89B30434E7: '현재 파일은 의존성 %0보다 더 오래되었습니다'
# "current handling of vector bool and vector pixel types in this context are deprecated; the default behaviour will soon change to that implied by the '-altivec-compat=xl' option"
H2144886C992F: "이 컨텍스트에서 벡터 bool 및 벡터 픽셀 형식의 현재 처리 방식은 deprecated 됐습니다; 기본 동작은 곧 '-altivec-compat=xl' 옵션에 의해 암시되는 동작으로 변경될 예정입니다"
# "current_version does not match: '%0' (provided) vs '%1' (found)"
H84F45A8B13FB: "current_version이 일치하지 않습니다: '%0' (제공됨) 대비 '%1' (발견됨)"
# "cycle in acquired_before/after dependencies, starting with '%0'"
HCB49175AA5FC: "acquired_before/after 의존성 내에서 순환이 발생했습니다, 시작점: '%0'"
# "cyclic dependency in module '%0': %1"
H2C783846485B: "모듈 '%0'에 순환 종속성 발생: %1"
# 'd'
H3C363836CF4E: 'd'
# 'data argument not used by format string'
HB79E446EA7A1: '포맷 문자열에 사용되지 않은 데이터 인수'
# "data argument position '%0' exceeds the number of data arguments (%1)"
H3A25FAA1F4B4: "데이터 인수 위치 '%0'가 데이터 인수의 총 개수(%1)를 초과했습니다"
# 'data layout string to use'
HBFBB6DFFCFDF: '사용할 데이터 레이아웃 문자열'
# 'data member instantiated with function type %0'
HE2AF1A6B9D7C: '데이터 멤버가 함수 유형 %0으로 인스턴스화되었습니다'
# "data-sharing attribute '%0' in '%1' clause requires OpenMP version %2 or above"
H12FB4E840EF7: "데이터 공유 속성 '%0'이 '%1' 절에서 사용되려면 OpenMP %2 버전 이상이 필요합니다"
# 'dbx'
H362301DA6431: 'dbx'
# "dealloc return type must be correctly specified as 'void' under ARC, instead of %0"
HF5C8E84C253E: "ARC 하에서는 dealloc의 반환 타입이 'void'로 올바르게 지정되어야 합니다. %0 대신"
# 'debug'
H32FAAECAC742: '디버그'
# "debug information option '%0' is not supported for target '%1'"
H53B68E933A49: "디버그 정보 옵션 '%0'은(는) 대상 '%1'에서 지원되지 않습니다"
# "debug information option '%0' is not supported; requires DWARF-%2 but target '%1' only provides DWARF-%3"
HBD9D2872B134: "디버그 정보 옵션 '%0'은(는) 지원되지 않습니다; DWARF-%2가 필요하지만 타겟 '%1'은(는) DWARF-%3만 제공합니다"
# 'debug print callable symbols defined by materialization units'
H976885EE0BAB: '재료화 단위에서 정의된 호출 가능한 심볼을 디버그 출력합니다'
# 'debug print data symbols defined by materialization units'
H68EF51B0D840: '디버그 프린트 데이터 심볼: materialization 유닛에 의해 정의된'
# 'debug print hidden symbols defined by materialization units'
H29FF2691850E: '디버그 출력: 물질화 단위에 의해 정의된 숨겨진 심벌'
# 'debug stack'
HF8D202225993: '디버그 스택'
# "declaration %0 attached to named module '%1' cannot be attached to other modules"
H238E4BEFC413: "선언 %0는 '%1' 이름 모듈에 첨부된 상태로 다른 모듈에 첨부될 수 없습니다"
# "declaration %0 is detected to be defined in multiple module units, first is from '%1' and second is from '%2'; the compiler may not be good at merging the definitions. "
H96F07A99E632: "선언 %0가 여러 모듈 단위에서 정의된 것으로 감지되었습니다. 첫 번째 정의는 '%1'에서, 두 번째 정의는 '%2'에서 발견되었습니다; 컴파일러가 이러한 정의를 병합하는 데 어려움을 겪을 수 있습니다."
# "declaration '%0' is %select{weak defined|thread local}1, but symbol is not in dynamic library"
HFB32CBE0F1C5: "선언 '%0'은 %select{weak defined|thread local}1이지만, 심볼이 동적 라이브러리에 없습니다"
# "declaration '%0' is marked %select{available|unavailable}1, but symbol is %select{not |}2exported in dynamic library"
H01B92D3A7F34: "선언 '%0'은 %select{사용 가능|사용 불가능}1로 지정되었지만, 심볼이 동적 라이브러리에서 %select{비|}2수출되지 않았습니다"
# "declaration cannot be inferred '%0' because it has no definition in this translation unit"
HFACBBC5D211B: "선언 '%0'은 이번 번역 단위에 정의가 없기 때문에 추론될 수 없습니다"
# 'declaration conflicts with target of using declaration already in scope'
HF0A04A0DD736: '선언이 범위 내에 이미 존재하는 using 선언의 대상과 충돌합니다'
# 'declaration does not declare a parameter'
HAB6C8E5E5B42: '선언이 매개변수를 선언하지 않습니다'
# 'declaration does not declare anything'
HCF31319302C2: '선언문이 아무것도 선언하지 않습니다'
# "declaration has external linkage, but dynamic library doesn't have symbol '%0'"
H867521795963: "선언이 외부 링크지성을 가집니다. 하지만 동적 라이브러리에는 '%0' 심볼이 없습니다"
# "declaration has external linkage, but symbol has internal linkage in dynamic library '%0'"
H51741F52DD27: "선언은 외부 링크지성을 가지지만, 동적 라이브러리 '%0'에서 심볼은 내부 링크지성을 가집니다."
# 'declaration hides type'
HBEC56FF31D60: '선언이 유형을 가리고 있습니다'
# 'declaration in interface'
HA49C5D70160C: '인터페이스 내 선언'
# "declaration in interface is not in the '%select{alloc|copy|init|new}0' family because %select{its result type is not an object pointer|its result type is unrelated to its receiver type}1"
H135EF0608D60: "인터페이스의 선언이 '%select{alloc|copy|init|new}0' 계열에 속하지 않음은 %select{그 결과 타입이 객체 포인터가 아님|그 결과 타입이 수신자 타입과 관련이 없음}1"
# "declaration is marked with '%select{\\|@}0deprecated' command but does not have a deprecation attribute"
H7C7F3BB153A5: "선언에 '%select{\\|@}0deprecated' 명령어가 지정되었지만 deprecation 특성이 없습니다"
# 'declaration is not declared in any declare target region'
H519107FB97C7: '선언이 어떤 declare 타겟 영역에도 선언되지 않았습니다'
# 'declaration marked as declare target after first use, it may lead to incorrect results'
HB5487BD38E68: '선언이 첫 사용 후 declare target으로 표시되었으므로 잘못된 결과가 발생할 수 있습니다'
# "declaration missing '[[carries_dependency]]' attribute is here"
H0D046CE0EB0D: "선언에 '[[carries_dependency]]' 속성이 빠져 있는 부분은 여기에 있습니다"
# 'declaration of %0 does not match'
H12CB12FACAA5: '선언 %0는 일치하지 않습니다'
# 'declaration of %0 has a different language linkage'
HB8AA7E6F59F0: '%0의 선언은 다른 언어 결합을 가집니다'
# 'declaration of %0 in %select{the global module|module %2}1 follows declaration in %select{the global module|module %4}3'
HCB7EF6CCFFAA: '선언 %0의 %select{전역 모듈에서 | 모듈 %2에서}1은 %select{전역 모듈의 | 모듈 %4의}3 선언을 따릅니다.'
# 'declaration of %0 is missing in %1 class'
HCE379B9B6B0B: '클래스 %1에서 %0의 선언이 누락되었습니다.'
# "declaration of %0 overrides a '%select{final|sealed}1' function"
H49FDD9D92060: "선언 %0가 '%select{final|sealed}1' 함수를 재정의합니다"
# 'declaration of %0 shadows template parameter'
HB1AA8E00948E: '템플릿 매개변수를 가린 채 %0의 선언'
# 'declaration of %0 will not be visible outside of this function'
H1E299D7E36E1: '%0의 선언은 이 함수 밖에서는 가시적이지 않을 것입니다'
# 'declaration of %0 with internal linkage cannot be exported'
HB1BC44F22B13: '%0의 내부 링크지정을 가진 선언은 수출될 수 없습니다'
# 'declaration of %1 %select{with C language linkage|in global scope}0 conflicts with declaration %select{in global scope|with C language linkage}0'
HADF36ADC7505: '선언문 %1 %select{C 언어 연결성으로|전역 범위에서}0은 %select{전역 범위에서|C 언어 연결성으로}0의 선언문과 충돌합니다'
# "declaration of a variadic function without a comma before '...' is deprecated"
HF12988516A95: "가변 인자 함수의 선언에서 '...' 앞에 콤마가 없는 것은 비추천 됩니다."
# 'declaration of anonymous %0 must be a definition'
H1EBFCC5461F9: '이름 없는 %0의 선언은 정의여야 합니다'
# 'declaration of block scope identifier with linkage cannot have an initializer'
HDD3AC9280BE3: '링크지가 있는 블록 범위 식별자의 선언은 초기화자를 가질 수 없습니다'
# "declaration of built-in function '%0' requires the declaration of the 'jmp_buf' type, commonly provided in the header <setjmp.h>"
H8F1CDE7D22C0: "내장 함수 '%0'의 선언은 'jmp_buf' 형식의 선언을 필요로 하며, 이는 일반적으로 헤더 <setjmp.h>에 제공됩니다."
# "declaration of built-in function '%1' requires inclusion of the header <%0>"
H059DBCAF4C02: "내장 함수 '%1'의 선언은 헤더 <%0>을 포함해야 합니다"
# 'declaration of constexpr static data member %0 requires an initializer'
HCFAE74ED9FCD: 'constexpr static 데이터 멤버 %0의 선언은 초기화자를 필요로 합니다'
# 'declaration of instance variables in the interface is deprecated'
HF2C25CBD493E: '인터페이스에서 인스턴스 변수를 선언하는 것은 더 이상 권장되지 않습니다.'
# "declaration of non-local variable in 'for' loop"
HBFAC0B86B48E: 'for 루프 내에서 비지역 변수의 선언'
# "declaration of non-local variable in 'for' loop is a C23 extension"
H82E18D14C9A2: "비로컬 변수의 선언이 'for' 루프에서 C23 확장입니다"
# "declaration of non-local variable in 'for' loop is incompatible with C standards before C23"
H1C8715C3541C: 'for 반복문 내의 비로컬 변수 선언은 C23 이전의 C 표준과 호환되지 않습니다'
# 'declaration of reference variable %0 requires an initializer'
H8635EDA9A8C6: '참조 변수 %0을 선언하려면 초기화자를 지정해야 합니다'
# 'declaration of type aware %0 in %1 must have matching type aware %2'
HC35A59FCABD4: '%1 내 %0의 형식 인식 선언은 일치하는 형식 인식 %2를 가져야 합니다'
# 'declaration of variable %0 with deduced type %1 requires an initializer'
H737154EADE2A: '변수 %0를 추론된 형식 %1로 선언하려면 초기화자를 지정해야 합니다'
# 'declaration requires a global constructor'
H55DC760EFFEA: '선언은 전역 생성자를 필요로 합니다'
# 'declaration requires a global destructor'
H7852FAA15ED5: '선언은 전역 소멸자가 필요합니다'
# 'declaration requires an exit-time destructor'
H86CA276EEC00: '선언은 종료 시 소멸자를 필요로 합니다'
# 'declaration shadows a %select{local variable|variable in %2|static data member of %2|field of %2|typedef in %2|type alias in %2|structured binding}1'
H68CDFAD663DD: '선언이 %select{지역 변수|%2의 변수|%2의 정적 데이터 멤버|%2의 필드|typedef %2 내의|type alias %2 내의|구조화된 바인딩}1 을(를) 가리고 있습니다'
# 'declaration uses __weak, but ARC is disabled'
H1C8188316ADE: '선언에 __weak가 사용되었지만 ARC가 비활성화되었습니다'
# 'declaration uses __weak, which the current deployment target does not support'
HEB22F5D20508: '선언에서 __weak를 사용했지만 현재 배포 대상은 이를 지원하지 않습니다'
# "declaration uses identifier '%0', which is %select{a reserved identifier|not a reserved identifier|reserved in the global namespace}1"
HCBB59D1E323D: '선언은 %0 식별자를 사용하며, 이 식별자는 %select{예약된 식별자|예약되지 않은 식별자|전역 네임스페이스에서 예약됨}1입니다'
# 'declaration uses type that is ill-formed in ARC'
H522AD27CDFBF: '宣言은 ARC에서 잘못된 형식인 유형을 사용합니다'
# 'declarator requires an identifier'
HB85D316E7D82: '선언자에는 식별자가 필요합니다'
# "declare 'static' if the %select{variable|function}0 is not intended to be used outside of this translation unit"
H5D50A42530DC: '%select{변수|함수}0가 번역 단위 밖에서 사용되지 않는다면 "static"을 선언하세요'
# 'declare the parameter __strong or capture a __block __strong variable to keep values alive across autorelease pools'
H9B7134A463BB: 'autorelease 풀을 통해 값이 유지되도록 하려면 매개변수에 __strong을 선언하거나 __block __strong 변수를 캡처하세요'
# "declared %select{'returns_nonnull'|'nonnull'}0 here"
H9D136543BAF2: "여기서 %select{'반환 값이 NULL이 아님'|'NULL이 아님'}0으로 선언되었습니다"
# 'declared %select{in global scope|with C language linkage}0 here'
H3DB72872F2B8: '여기서 %select{전역 범위에서|C 언어 링크지정으로}0 선언됨'
# 'declared as a non-template here'
H65BA70C7322E: '여기서 템플릿이 아닌 것으로 선언되었습니다'
# 'declared here'
HA1E35E29C81D: '여기서 선언됨'
# 'declared here with type %0'
H880F1F3D3828: '%0 형으로 여기에서 선언되었습니다.'
# "declared here%select{ in module '%1'|}0"
HD4C36AE9FEF2: "여기서 선언되었습니다%select{ 모듈 '%1'에서|}0"
# 'declared with %0 attribute here'
H98D954FCA941: '여기에서 %0 속성으로 선언되었습니다'
# "declared with class '%0' here"
HA2F652501D84: "여기서 '%0' 클래스로 선언되었습니다"
# 'declared with index %0 here'
H29E8DAE209C5: '여기서 %0 인덱스로 선언되었습니다'
# 'declaring function parameter of type %0 is not allowed%select{; did you forget * ?|}1'
H45BA30613376: '타입 %0의 함수 매개변수를 선언하는 것은 허용되지 않습니다%select{; ※ *을(를) 잊은 게 아닙니까?|}1'
# 'declaring function return value of type %0 is not allowed %select{; did you forget * ?|}1'
HC0F56D942DA5: '함수 반환 값의 타입 %0는 허용되지 않습니다 %select{; *를 잊으셨나요?|}1'
# "declaring overloaded %0 as 'static' is a C++23 extension"
H3416DF62F662: "오버로드된 %0를 'static'으로 선언하는 것은 C++23 확장 기능입니다"
# "declaring overloaded %0 as 'static' is incompatible with C++ standards before C++23"
HE846DD4F137C: "오버로드된 %0을 'static'으로 선언하는 것은 C++23 이전의 표준과 호환되지 않습니다"
# 'declaring variable of type %0 is not allowed'
HCC1ADB51903E: '유형 %0의 변수 선언은 허용되지 않습니다'
# 'decode probes section from binary'
H61AE631A7106: '이진 파일의 프로브 섹션을 디코딩합니다'
# 'decomposition declaration %0 requires an initializer'
H745CF12AB2DC: '구조 분해 선언 %0는 초기화자를 필요로 합니다'
# 'decomposition declaration cannot be a template'
H12444CAF9EB2: '분해 선언은 템플릿이 될 수 없습니다'
# "decomposition declaration cannot be declared %plural{1:'%1'|:with '%1' specifiers}0"
HEDAF4E9407D4: "구조 분해 선언은 %plural{1:'%1 지정자와 함께'|:'%1' 지정자와 함께}0 선언할 수 없습니다"
# "decomposition declaration cannot be declared with constrained 'auto'"
H33CAEB57113F: "분해 선언은 제약된 'auto'로 선언될 수 없습니다"
# 'decomposition declaration cannot be declared with parentheses'
H02314396E4F0: '분해 선언은 괄호로 선언될 수 없습니다'
# "decomposition declaration cannot be declared with type %0; declared type must be 'auto' or reference to 'auto'"
H3DD0947995B7: "분해 선언은 %0 타입으로 선언할 수 없습니다. 선언된 타입은 'auto' 또는 'auto' 참조여야 합니다."
# "decomposition declaration declared %plural{1:'%1'|:with '%1' specifiers}0 is a C++20 extension"
HED6397EE7170: "구조 분해 선언이 %plural{1:'%1'|:'%1' 지정자와}0 선언된 것은 C++20 확장 기능입니다"
# "decomposition declaration declared %plural{1:'%1'|:with '%1' specifiers}0 is incompatible with C++ standards before C++20"
H3B1B7DD7D4A6: "구조 분해 선언이 %plural{1:'%1'|: '%1' 지정자와}0 선언된 것은 C++20 이전 표준과 호환되지 않습니다"
# 'decomposition declaration must be the only declaration in its group'
H36F7861E46A5: '분해 선언은 그 그룹에서 유일한 선언이어야 합니다'
# 'decomposition declaration not permitted in this context'
HE332CBDAE8B6: '이 맥락에서는 구조 분해 선언을 허용하지 않습니다.'
# 'decomposition declarations are a C++17 extension'
H41B58BACEDBD: '구조 분해 선언은 C++17의 확장 기능입니다'
# 'decomposition declarations are incompatible with C++ standards before C++17'
H6F6939D7899C: '구조 분해 선언은 C++17 이전의 C++ 표준과 호환되지 않습니다.'
# 'deduced conflicting types %diff{($ vs $) |}0,1for initializer list element type'
H41EB8FB5647B: '초기화 리스트 요소 형식에 대해 추론된 충돌하는 형식들 %diff{($와 $) |}0,1'
# 'deduced incomplete pack %0 for template parameter %1'
H03080CBC4C1A: '템플릿 매개변수 %1에 대해 추론된 미완결한 팩 %0'
# 'deduced non-type template argument does not have the same type as the corresponding template parameter%diff{ ($ vs $)|}0,1'
H6489085BE16C: '추론된 비유형 템플릿 인수는 대응하는 템플릿 매개변수와 같은 유형을 가지고 있지 않습니다.%diff{ ($ vs $)|}0,1'
# "deduced return type for defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator must be 'auto', not %1"
H209B0E7EFC40: "기본화된 %select{<ERROR>|동등성|세방향|동등성|관계}0 비교 연산자의 유추된 반환 형식은 'auto'여야 하며 %1이(가) 아니어야 합니다"
# 'deduced return types are a C++14 extension'
HB07F9BCAC63A: '추론된 반환 형식은 C++14 확장 기능입니다'
# 'deduced type %0 does not satisfy %1'
H9431BF910A33: '추론된 형식 %0는 %1를 만족하지 않습니다'
# 'deduced type %1 of deduction guide is not %select{|written as }2a specialization of template %0'
H902D2FE80122: '템플릿 %0의 특정화가 아닌 %select{ |문자열로 표현되지 않은 }2추론 가이드 %1의 타입'
# 'deduction guide cannot be %select{explicitly instantiated|explicitly specialized}0'
HA3A632F69A86: '추론 가이드는 %select{명시적으로 인스턴스화된|명시적으로 특수화된}0이 될 수 없습니다'
# "deduction guide cannot be declared '%0'"
HF6365CFA8B89: "추론 가이드는 '%0'로 선언할 수 없습니다"
# 'deduction guide cannot have a function definition'
H7D3F7544A5EA: '추론 가이드는 함수 정의를 가질 수 없습니다'
# 'deduction guide declaration without trailing return type'
H4EE056EE4349: '뒤따르는 반환형이 없는 추론 가이드 선언'
# 'deduction guide declared %0 by intervening access specifier'
HBCF8F59E9812: '추론 가이드가 중간에 있는 접근 지정자에 의해 %0로 선언되었습니다'
# 'deduction guide has different access from the corresponding member template'
H1030B70A50CA: '추론 가이드의 접근 지정자가 해당 멤버 템플릿과 다릅니다.'
# 'deduction guide must be declared in the same scope as template %q0'
H1F6362B2A695: 'Deduction guide는 템플릿 %q0와 같은 범위 내에서 선언되어야 합니다'
# 'deduction guide template contains %select{a template parameter|template parameters}0 that cannot be deduced'
H9078590D8224: '추론 가이드 템플릿에 %select{템플릿 매개변수|템플릿 매개변수들}0가 추론할 수 없습니다'
# 'default %select{argument|non-type template argument}0 may not use a GNU statement expression'
HB2A0E2C3CEAE: '기본 %select{인수|비유형 템플릿 인수}0는 GNU 문 표현을 사용할 수 없습니다'
# 'default alignment for functions'
HDB8C50704025: '함수의 기본 정렬'
# 'default argument declared here'
HDD61CA193DBE: '기본 인수가 여기서 선언되었습니다'
# 'default argument not permitted on an explicit %select{instantiation|specialization}0 of function %1'
HA5116018194A: '기본 인자는 함수 %1의 명시적 %select{인스턴스화|특수화}0에 허용되지 않습니다'
# "default argument references 'this'"
H743C3B172B68: "기본 인자가 'this'를 참조합니다"
# 'default argument references local variable %0 of enclosing function'
HAA8CD5949FC3: '디폴트 인수가 둘러싼 함수의 지역 변수 %0를 참조합니다'
# 'default argument references parameter %0'
H573EB7C93602: '기본 인수는 매개변수 %0를 참조합니다'
# 'default argument used here'
H2C2A14271D90: '기본 인수가 여기에서 사용되었습니다'
# 'default arguments can only be specified for parameters in a function declaration'
H910FAD8C4EA4: '디폴트 인수는 함수 선언의 매개변수에만 지정될 수 있습니다'
# 'default arguments cannot be added to a function template that has already been declared'
H2AD8ADEE046B: '기본 인수는 이미 선언된 함수 템플릿에 추가될 수 없습니다'
# 'default arguments cannot be added to an out-of-line definition of a member of a %select{class template|class template partial specialization|nested class in a template}0'
H2A1897D12086: '기본 인수는 %select{클래스 템플릿|클래스 템플릿 부분 특수화|템플릿 내의 중첩 클래스}0의 멤버에 대한 외부 정의에 추가할 수 없습니다'
# 'default arguments not allowed for parameters of a requires expression'
H8AAADF6A99AF: 'requires 표현식의 매개변수에 기본 인수는 허용되지 않습니다'
# 'default assign attribute on property %0 which implements NSCopying protocol is not appropriate with -fobjc-gc[-only]'
H8248EDB07821: 'NSCopying 프로토콜을 구현하는 속성 %0에 기본 할당 속성을 사용하는 것은 -fobjc-gc[-only]와 호환되지 않습니다.'
# 'default capture by %select{value|reference}0'
H472BB89BA278: '기본 캡처 방식은 %select{값|참조}0'
# 'default constructed field %0 declared here'
H948E9DA6EBAF: '기본 생성된 필드 %0가 여기서 선언되었습니다'
# 'default exception handling model'
H9659057B9931: '기본 예외 처리 모델'
# 'default initialization of an object of const type %0%select{| without a user-provided default constructor}1'
H303212CBDF84: 'const 형식 %0의 객체에 대한 기본 초기화%select{ | 사용자 정의 기본 생성자가 없이}1'
# 'default initialization of an object of const type %0%select{| without a user-provided default constructor}1 is a Microsoft extension'
H48E5A1B64C89: 'const 형식의 객체 %0%select{| 사용자 제공 기본 생성자가 없이}1의 기본 초기화는 마이크로소프트 확장입니다'
# 'default initialization of an object of type %0 is incompatible with C++'
H6366610D5A2C: '형식 %0의 객체 기본 초기화는 C++과 호환되지 않습니다.'
# 'default initialization of an object of type %0 leaves the object uninitialized%select{| and is incompatible with C++}1'
H925C796D0E64: '형식 %0의 객체 기본 초기화는 객체를 초기화하지 않은 상태로 두며%select{| 그리고 C++과 호환되지 않습니다}1'
# 'default initialization of an object of type %0 with const member is incompatible with C++'
H4DB5E81E949B: '형식 %0(const 멤버 포함)의 객체 기본 초기화는 C++과 호환되지 않습니다.'
# 'default initialization of an object of type %0 with const member leaves the object uninitialized%select{| and is incompatible with C++}1'
H08A6BE1665E0: '형식 %0(const 멤버 포함)의 객체 기본 초기화는 객체를 초기화하지 않은 상태로 두며%select{| 그리고 C++과 호환되지 않습니다}1'
# 'default label in switch which covers all enumeration values'
HF1A67825B6F5: 'switch 내의 default 레이블은 모든 열거형 값을 커버합니다'
# 'default member initializer declared here'
H09B30FC3540B: '여기에서 기본 멤버 초기화자가 선언되었습니다'
# 'default member initializer for %0 uses itself'
H62A9561A4498: '디폴트 멤버 초기화자 %0가 자신을 사용했습니다'
# 'default member initializer for %1 needed within definition of enclosing class %0 outside of member functions'
HB4FBDC93A96D: '포함 클래스 %0의 정의 내에서 멤버 함수 밖에서 %1에 대한 기본 멤버 초기화자가 필요합니다'
# 'default member initializer for bit-field is a C++20 extension'
H960B2B591D79: '비트 필드의 기본 멤버 초기화자는 C++20 확장 기능입니다.'
# 'default member initializer for bit-field is incompatible with C++ standards before C++20'
H85717DD87366: '비트 필드에 대한 디폴트 멤버 초기화자는 C++20 이전의 C++ 표준과 호환되지 않습니다'
# 'default member initializer for non-static data member is a C++11 extension'
HB1974A6508C8: '비정적 데이터 멤버의 디폴트 멤버 초기화자는 C++11 확장 기능입니다'
# 'default member initializer for non-static data members is incompatible with C++98'
H75DECF5B5D30: '정적 멤버가 아닌 데이터 멤버에 대한 기본 멤버 초기화자는 C++98과 호환되지 않습니다'
# "default property attribute 'assign' not appropriate for object"
HBAC11B3F8368: "기본 속성 속성 'assign'은 객체에 적절하지 않습니다"
# 'default scope specifier for attributes is a C++17 extension'
H9959B28B39FE: '특성에 대한 기본 범위 지정자는 C++17 확장 기능입니다'
# 'default scope specifier for attributes is incompatible with C++ standards before C++17'
HCB10ABA8102F: '속성에 대한 기본 스코프 지정자는 C++17 이전의 C++ 표준과 호환되지 않습니다'
# 'default template argument for a template template parameter must be a class template'
H3FA43EDB90ED: '템플릿 템플릿 매개변수에 대한 기본 템플릿 인수는 클래스 템플릿이어야 합니다'
# 'default template argument in a class template partial specialization'
H57E58A1F67E6: '클래스 템플릿 부분 특수화에서 기본 템플릿 인수'
# 'default template argument not permitted on a friend template'
H1B3D975772BB: '친구 템플릿에 템플릿 기본 인자는 허용되지 않습니다.'
# 'default template arguments for a function template are a C++11 extension'
H94B1EDF48980: '함수 템플릿에 대한 기본 템플릿 인수는 C++11 확장 기능입니다'
# 'default template arguments for a function template are incompatible with C++98'
H688888558286: '함수 템플릿의 기본 템플릿 인수는 C++98과 호환되지 않습니다'
# 'defaulted %0 is implicitly deleted because %2 is a %select{union-like class|union}1 with variant members'
HAADBD633A7F2: '디폴트된 %0은 %2가 variant 멤버를 가진 %select{union-like class|union}1이기 때문에 암묵적으로 삭제되었습니다'
# 'defaulted %0 is implicitly deleted because a builtin comparison function using this conversion would be the best match for the comparison'
H6F959181B71C: '디폴트로 설정된 %0는 이 변환을 사용하는 빌트인 비교 함수가 비교에 가장 적합한 매치가 될 경우 암묵적으로 삭제됩니다'
# 'defaulted %0 is implicitly deleted because class %1 has a reference member'
HDDAEEF62F6DD: '디폴트로 정의된 %0은 class %1이 참조 멤버를 가지고 있기 때문에 암묵적으로 삭제되었습니다'
# 'defaulted %0 is implicitly deleted because defaulted comparison of vector types is not supported'
H62937001BFCD: '기본 생성된 %0은(는) 벡터 형식의 기본 비교가 지원되지 않기 때문에 암시적으로 삭제됩니다.'
# "defaulted %0 is implicitly deleted because implied %select{|'==' |'<' }1comparison %select{|for member %3 |for base class %3 }2is ambiguous"
H8204A4BEFE67: "디폴트된 %0은/는 암시적으로 정의된 %select{|'==' |'<' }1 비교 %select{|멤버 %3을/를 위한 |기반 클래스 %3을/를 위한 }2가 모호하기 때문에 암시적으로 삭제되었습니다"
# 'defaulted %0 is implicitly deleted because it would invoke a %select{private|protected}3 %4%select{ member of %6| member of %6 to compare member %2| to compare base class %2}1'
HA2763C071EBA: '기본으로 정의된 %0은(는) 암묵적으로 삭제되었습니다.这是因为它会调用 %select{private|protected}3 %4%select{ 의 %6 멤버| %6의 %2 멤버와 비교하기 위해| %2 기반 클래스와 비교하기 위해}1'
# 'defaulted %0 is implicitly deleted because it would invoke a deleted comparison function%select{| for member %2| for base class %2}1'
H73AE2279ECF2: '디폴트로 지정된 %0는 삭제된 비교 함수를 호출할 것이기 때문에 암묵적으로 삭제됨%select{| 멤버 %2| 기반 클래스 %2}1'
# "defaulted %0 is implicitly deleted because there is no viable %select{three-way comparison function|'operator=='}1 for %select{|member |base class }2%3"
HC9957DD8DD53: "디폴트된 %0는 %select{세-way 비교 함수|'operator=='}1이 %select{ |멤버 |기반 클래스 }2%3에 대해 사용 가능하지 않아 암묵적으로 삭제되었습니다"
# 'defaulted %0 is implicitly deleted because this non-rewritten comparison function would be the best match for the comparison'
H5A66B2776E93: '디폴트된 %0는 이 비교 함수가 비교에서 가장 적합한 것으로 판단되므로 암시적으로 삭제되었습니다'
# 'defaulted comparison function must not be volatile'
H50500CCE550F: '기본값으로 정의된 비교 함수는 volatile일 수 없습니다.'
# 'defaulted comparison operators are a C++20 extension'
H17EA10D2ACC2: '디폴트화된 비교 연산자는 C++20의 확장 기능입니다.'
# 'defaulted comparison operators are incompatible with C++ standards before C++20'
H38C2AF56B86F: '디폴트로 정의된 비교 연산자는 C++20 이전의 C++ 표준과 호환되지 않습니다'
# "defaulted definition of %select{%select{<ERROR>|equality|three-way|equality|relational}1 comparison operator|three-way comparison operator}0 cannot be declared %select{constexpr|consteval}2 because %select{it|for which the corresponding implicit 'operator==' }0 invokes a non-constexpr comparison function"
HDA596C603C53: "기본적으로 정의된 %select{%select{<ERROR>|동등성|세이웨이|동등성|관계성}1 비교 연산자|세이웨이 비교 연산자}0 는 %select{constexpr|consteval}2 로 선언될 수 없습니다. 왜냐하면 %select{그것이|동일한 임플리시트 'operator==' 를 위해 }0 비 constexpr 비교 함수를 호출하기 때문입니다"
# 'defaulted definition of %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot be marked %select{constexpr|consteval}1 before C++23'
H5C1B0C179374: 'C++23 이전에는 %select{constexpr|consteval}1로 표시할 수 없습니다: 디폴트로 정의된 %select{디폴트 생성자|복사 생성자|이동 생성자|복사 할당 연산자|이동 할당 연산자|소멸자}0'
# 'defaulted member %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator must be const-qualified'
H8A22F945F946: '디폴트로 지정된 멤버 %select{<오류>|등호 비교|세-way 비교|등호 비교|관계 비교}0 비교 연산자는 const 자격을 가져야 합니다'
# 'defaulted move assignment operator of %0 will move assign virtual base class %1 multiple times'
HC302B71D801C: '%0의 디폴트로 생성된 이동 할당 연산자가 가상 기반 클래스 %1을 여러 번 이동 할당합니다'
# "defaulting %select{this %select{<ERROR>|equality|three-way|equality|relational}1 comparison operator|the corresponding implicit 'operator==' for this defaulted 'operator<=>'}0 would delete it after its first declaration"
HCBD1D13B7A08: "디폴트로 지정하는 %select{이 %select{<ERROR>|equality|three-way|equality|relational}1 비교 연산자 | 이 디폴트된 'operator<=>'에 해당하는 암시적 'operator=='}0 는 첫 번째 선언 후에 이를 삭제할 것입니다"
# 'defaulting this %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator is not allowed because it was already declared outside the class'
H21E3B4CFF46D: '이 %select{<오류>|등가성|세 방향|등호|관계성}0 비교 연산자의 기본값을 사용하는 것은 클래스 외부에서 이미 선언되었기 때문에 허용되지 않습니다.'
# 'defaulting this %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 would delete it after its first declaration'
H7E7544692CE2: '이 %select{디폴트 생성자|복사 생성자|이동 생성자|복사 할당 연산자|이동 할당 연산자|소멸자}0를 기본값으로 설정하면, 첫 번째 선언 후에 이를 삭제합니다'
# 'defined as %0'
H95D82B9347CA: '을(를) %0로 정의되었습니다'
# "defining a type within '%select{__builtin_offsetof|offsetof}0' is a C23 extension"
HB6CCA72E4AE1: "'%select{__builtin_offsetof|offsetof}0 내부에서 타입을 정의하는 것은 C23 확장 기능입니다'"
# 'definition %0 cannot also be an %select{alias|ifunc}1'
HEAC49AC815B1: '정의 %0는 또한 %select{별칭|인터프}1일 수 없습니다'
# 'definition has no member %0'
HF2870D3EBBD2: '정의에 멤버 %0가 없습니다'
# "definition in module '%0' is here"
HD03996A6AE5C: "모듈 '%0'의 정의는 여기 있습니다"
# "definition of %0 is not complete until the closing '}'"
H6A431AA48FA1: "%0의 정의는 닫는 '}'까지 완료되지 않았습니다."
# 'definition of a %select{static|thread_local}1 variable in a constexpr %select{function|constructor}0 is a C++23 extension'
H398F375C6A6A: 'constexpr %select{function|constructor}0 안에서 %select{static|thread_local}1 변수의 정의는 C++23 확장 기능입니다'
# 'definition of a %select{static|thread_local}1 variable in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++23'
HE9C5585842AA: 'constexpr %select{function|constructor}0 내의 %select{static|thread_local}1 변수 정의는 C++23 이전의 C++ 표준과 호환되지 않습니다'
# 'definition of a variable of non-literal type in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++23'
H53017D331C6A: '리터럴 타입이 아닌 변수의 정의가 constexpr %select{함수|생성자}0 내에서는 C++23 이전 표준과 호환되지 않습니다'
# 'definition of builtin function %0'
HC9CC697C220C: '내장 함수 %0의 정의'
# 'definition of class %0 must be available to use Objective-C %select{array literals|dictionary literals|numeric literals|boxed expressions|string literals}1'
H852A8FF09E04: '클래스 %0의 정의가 사용 가능해야 Objective-C %select{배열 리터럴|딕셔너리 리터럴|수치 리터럴|박싱 표현식|문자열 리터럴}1을 사용할 수 있습니다'
# 'definition of dllimport data'
HBDC4BCE4EB33: 'dllimport 데이터의 정의'
# 'definition of dllimport static field'
H64DF6CE31868: 'dllimport static 필드의 정의'
# 'definition of dllimport static field not allowed'
H8C1897964645: 'dllimport static 필드의 정의는 허용되지 않습니다'
# 'definition of explicitly defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|function}0'
H1522F98BEB4D: '명시적으로 기본으로 지정된 %select{기본 생성자|복사 생성자|이동 생성자|복사 할당 연산자|이동 할당 연산자|소멸자|함수}0의 정의'
# 'definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-declared copy %select{assignment operator|constructor}1'
H069CBC304A15: '클래스 %0에 대한 암시적 복사 %select{생성자|대입 연산자}1의 정의는 사용자 선언된 복사 %select{대입 연산자|생성자}1 때문에 사용 중지되었습니다.'
# 'definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-declared destructor'
H423281D39FA7: '암시적 복사 %select{constructor|assignment operator}1의 정의가 %0에 대해 사용자 선언된 소멸자가 있기 때문에 비추천 됩니다'
# 'definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-provided copy %select{assignment operator|constructor}1'
H3C23BCA5B3D2: '암시적 복사 %select{생성자|대입 연산자}1의 정의가 %0에 대해 비추천 됩니다. 이는 사용자가 제공한 복사 %select{대입 연산자|생성자}1이 있기 때문입니다.'
# 'definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-provided destructor'
H396EB4CE9202: '정의가 암시적 복사 %select{생성자|대입 연산자}1에 대한 %0는 사용자 제공 소멸자가 있기 때문에 비추천 됩니다'
# 'definition of implicitly declared %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|function}1'
H86596A04E020: '암시적으로 선언된 %select{기본 생성자|복사 생성자|이동 생성자|복사 대입 연산자|이동 대입 연산자|소멸자|함수}1의 정의'
# 'definition of macro %0 does not match definition in precompiled header'
H79B9B4BA8FFF: '매크로 %0의 정의가 미리 컴파일된 헤더의 정의와 일치하지 않습니다'
# "definition of macro '%0' differs between the precompiled file '%3' ('%1') and the command line ('%2')"
HF4FF588C4EAE: "매크로 '%0'의 정의가 사전 컴파일된 파일 '%3'('%1')과 명령행('%2')에서 다릅니다."
# "definition of module '%0' is not available; use -fmodule-file= to specify path to precompiled module interface"
H1ED33479DE5D: "모듈 '%0'의 정의가 사용할 수 없습니다; -fmodule-file= 옵션으로 미리 컴파일된 모듈 인터페이스 경로를 지정해 주세요"
# 'definition of type %0 conflicts with %select{typedef|type alias}1 of the same name'
H5C3C4CCA94AB: '%0 이름의 %select{typedef|타입 별칭}1과 유형 정의가 충돌합니다'
# 'definition of variable with array type needs an explicit size or an initializer'
H79E09A4784DB: '배열 형식 변수의 정의에는 명시적인 크기 또는 초기화자가 필요합니다'
# 'definition or redeclaration of %0 cannot name the global scope'
H3AC58FC9EA5A: '정의나 재선언의 %0는 전역 범위를 명명할 수 없습니다'
# 'definition or redeclaration of %0 not allowed inside a block'
HD4328CF55600: '블록 내에서 %0의 정의나 재선언은 허용되지 않습니다'
# 'definition or redeclaration of %0 not allowed inside a function'
H26DE3CAC54F0: '함수 내부에서 %0의 정의나 재선언은 허용되지 않습니다'
# "definition with same mangled name '%0' as another definition"
H9CD626C8B999: "동일한 꼬임 이름 '%0'을 가진 다른 정의와 충돌합니다"
# 'defsym must be of the form: sym=value: %0'
H633B95A139C3: 'defsym은 다음 형식이어야 합니다: sym=value: %0'
# 'delegating constructors are incompatible with C++98'
H57A554A5A2B8: '델리게이팅 생성자는 C++98과 호환되지 않습니다'
# 'delegating constructors are permitted only in C++11'
H859BD39058E0: 'delegating constructors는 오직 C++11에서만 허용됩니다'
# 'delete of object with dynamic type %1 through pointer to base class type %0 with non-virtual destructor'
H2817C3914B5E: '동적 타입 %1인 객체를 비가상 소멸자를 가진 기반 클래스 타입 %0의 포인터를 통해 삭제'
# "delete of pointer '%0' that does not point to a heap-allocated object"
H8B4F3ED0F000: '%0 포인터에 대한 delete 연산자가 힙에서 할당된 개체를 가리키지 않습니다'
# 'delete of pointer that has already been deleted'
H42BC8DFBCECC: '이미 삭제된 포인터에 대한 delete 연산자 사용'
# "delete of pointer%select{ to subobject|}1 '%0' %select{|that does not point to complete object}1"
H4DFF941C0746: '%select{부분 객체 포인터|}1 "%0" %select{|이 완전 객체를 가리키지 않음}1의 delete 연산'
# 'deleted definition must be first declaration'
H0F602982588E: '삭제된 정의는 첫 번째 선언이어야 합니다'
# 'deleted function %0 cannot override a non-deleted function'
H3FCDC44C217B: '삭제된 함수 %0는 삭제되지 않은 함수를 대체할 수 없습니다'
# 'deleting incomplete class type %0; no conversions to pointer type'
H9074591E0AF3: '미완성 클래스 형식 %0를 삭제 중; 포인터 형식으로의 변환 없음'
# 'deleting pointer to incomplete type %0 is incompatible with C++2c and may cause undefined behavior'
H0FC4BDC8CA1F: '부분적으로 완성되지 않은 유형 %0의 포인터를 삭제하는 것은 C++2c 표준과 호환되지 않을 수 있으며 미정행동을 유발할 수 있습니다'
# 'delimited escape sequence cannot be empty'
H5E38AA141B13: '구분 기호가 있는 탈출 시퀀스는 비어있을 수 없습니다'
# 'delimited escape sequences are incompatible with C standards before C2y'
H21BCF42E1D91: '구분자로 구분된 탈출 시퀀스는 C2y 이전의 C 표준과 호환되지 않습니다'
# 'delinearize'
HB90F234569ED: '선형화 해제'
# 'demangle symbols (default)'
H49846FF32EAF: '심볼을 디멀지ング (기본)'
# 'denormals are flushed to positive zero'
H38FDA7EF72DB: 'denormal 값들이 양의 영으로 강제로 설정됩니다'
# 'denormals have unknown treatment'
HBDD387FC03A4: '비정상 소수의 처리 방법이 알려지지 않음'
# 'dense YAML representation'
HA97D8413D319: '밀집 YAML 표현'
# "depend modifier cannot be used with 'sink' or 'source' depend type"
H92A125FCC1F2: "의존 모디파이어는 'sink' 또는 'source' 의존 형식과 함께 사용할 수 없습니다"
# 'dependent %select{__if_not_exists|__if_exists}0 declarations are ignored'
H7E0205C30EB0: '종속적인 %select{__if_not_exists|__if_exists}0 선언들은 무시됩니다'
# 'dependent nested name specifier %0 for friend class declaration is not supported; turning off access control for %1'
H6C7EBDCCA541: '의존적 중첩 이름 지정자 %0을 사용한 프렌드 클래스 선언은 지원되지 않습니다; %1에 대한 접근 제어를 비활성화합니다'
# 'dependent nested name specifier %0 for friend template declaration is not supported; ignoring this friend declaration'
H5BCC077F4A6E: '의존적 중첩 이름 지정자 %0가 friend 템플릿 선언에 지원되지 않아; 이 friend 선언을 무시합니다'
# "dependent using declaration resolved to type without 'typename'"
H9473A34B51B9: "의존성 있는 using 선언이 'typename' 없이 타입으로 해결되었습니다."
# 'dereference of pointer to incomplete type %0'
H2DF43C211998: '미완성 타입 %0 포인터의 해제'
# 'dereference of type %1 that was reinterpret_cast from type %0 has undefined behavior'
H90FCF362143A: '타입 %1의 참조 해제가 타입 %0에서 reinterpret_cast된 경우 정의되지 않은 동작이 발생합니다'
# 'dereferenced pointer past the end of %select{|subobject of }0%select{temporary|%2}1 is not a constant expression'
H22AD60D3A378: '포인터가 %select{|부분 객체의 }0%select{일시적|%2}1의 끝을 넘어 해제된 것은 상수 표현식이 아닙니다'
# "dereferencing %0; was declared with a 'noderef' type"
H77B30DE9BC36: "%0 참조 해제 중; 'noderef' 형식으로 선언되었습니다."
# 'dereferencing a __weak pointer is not allowed due to possible null value caused by race condition, assign it to strong variable first'
H69A87CE8BA55: '레이스 조건으로 인해 발생할 수 있는 null 값 때문에 __weak 포인터의 해제는 허용되지 않습니다. 먼저 강한 변수에 할당해야 합니다.'
# "dereferencing expression marked as 'noderef'"
HB6D67B14D60F: 'noderef로 표시된 표현식을 참조했습니다.'
# 'derived class must specify the same code segment as its base classes'
HF7C9EF85294D: '파생 클래스는 기반 클래스들과 동일한 코드 섹션을 지정해야 합니다'
# 'descending'
H486093918FF3: '내림차순'
# 'designated initializer invoked a non-designated initializer'
H504DCC34F2E8: '지정 초기화자가 비지정 초기화자를 호출했습니다'
# "designated initializer missing a 'super' call to a designated initializer of the super class"
H94AB45A96460: "지정된 초기화자가 상위 클래스의 지정된 초기화자에 대한 'super' 호출을 누락했습니다."
# "designated initializer should only invoke a designated initializer on 'super'"
H2306DCB92F88: "지정 초기화자는 'super'에서만 지정 초기화자를 호출해야 합니다"
# 'designated initializers are a C++20 extension'
H868FB6A7DCFA: '지정 초기자들은 C++20 확장 기능입니다.'
# 'designated initializers are a C99 feature'
HCE690B2EFB92: '지정 초기화자는 C99의 기능입니다'
# 'designated initializers are incompatible with C++ standards before C++20'
HB212F1F17A19: '지정 초기자자는 C++20 이전의 C++ 표준과 호환되지 않습니다'
# 'designator in initializer for %select{scalar|indivisible sizeless}0 type %1'
HDC0C952FB90A: '초기화자 내의 %select{스칼라|분할 불가능한 크기 없는}0 유형 %1에 대한 지정자'
# 'designator into flexible array member subobject'
H596716C96072: '유연한 배열 멤버 부 객체에 디자이네이터 사용'
# 'destroying delete is not permitted to be type aware'
HBF72010CD873: '형식 인식 삭제 연산자는 허용되지 않습니다'
# "destroying object '%0' whose lifetime has already ended"
H480FFC7A6CDF: "생명 주기가 이미 종료된 객체 '%0'를 소멸시키는 중입니다"
# 'destroying operator delete can have only an optional size and optional alignment parameter'
H05866AB32F25: '소멸 중인 operator delete는 오직 선택적 size 및 alignment 매개변수만 가질 수 있습니다'
# 'destruction of individual component of complex number is not yet supported in constant expressions'
H6533BAA0653D: '복소수의 개별 구성 요소의 해체는 상수 표현식에서 아직 지원되지 않습니다'
# 'destruction of object that is already being destroyed'
HBC86CD58BD53: '이미 파괴 중인 개체의 파괴'
# 'destructor cannot be declared %select{<ERROR>|constexpr|consteval|constinit}0'
H39B25D41B01F: '소멸자는 %select{<ERROR>|constexpr|consteval|constinit}0로 선언될 수 없습니다'
# 'destructor cannot be declared %select{<ERROR>|constexpr|consteval|constinit}0 because %select{data member %2|base class %3}1 does not have a constexpr destructor'
HEA62090F1654: '소멸자는 %select{<ERROR>|constexpr|consteval|constinit}0로 선언될 수 없습니다因为在 %select{데이터 멤버 %2|기반 클래스 %3}1은 constexpr 소멸자를 갖지 않습니다'
# "destructor cannot be declared '%0'"
H18788E54B072: "소멸자는 '%0'로 선언될 수 없습니다"
# 'destructor cannot be declared as a template'
H2A9016676C0B: '소멸자는 템플릿으로 선언될 수 없습니다.'
# 'destructor cannot be declared using a %select{typedef|type alias}1 %0 of the class name'
HD2E86EDB043A: '소멸자는 클래스 이름의 %select{typedef|type alias}1 %0을 사용하여 선언될 수 없습니다'
# 'destructor cannot be redeclared'
H7C102E557BD9: '소멸자는 재선언할 수 없습니다'
# 'destructor cannot be variadic'
H3060C3D6CE56: '소멸자는 가변 인자일 수 없습니다.'
# 'destructor cannot have a return type'
HB61BE667BB0D: '소멸자는 반환 형식을 가질 수 없습니다'
# 'destructor cannot have any parameters'
H27289F072FC5: '소멸자는 매개변수를 가질 수 없습니다'
# 'destructor for %0 is not trivial because it is virtual'
H695A7FB4C51A: '%0의 소멸자는 virtual이기 때문에 trivial하지 않습니다'
# 'destructor must be a non-static member function'
HE5AA51DEFC74: '소멸자는 비정적 멤버 함수여야 합니다'
# 'destructor name %0 does not refer to a template'
H6A0A4776F7D0: '소멸자 이름 %0는 템플릿을 가리키지 않습니다'
# 'destructor of class %0 is ambiguous'
H29DC1463BFE1: '클래스 %0의 소멸자가 모호합니다'
# 'destructor type %0 in object destruction expression does not match the type %1 of the object being destroyed'
HCA02CE698CF6: '객체 파괴 표현식 내에서 소멸자의 유형 %0은 파괴 중인 객체의 유형 %1과 일치하지 않습니다'
# 'detect use after scope within function'
H76CE675503B0: '함수 내 범위 이후 사용 감지'
# 'detected while default synthesizing properties in class implementation'
HDACD480D581B: '클래스 구현에서 기본적으로 속성을 합성하는 중에 감지되었습니다'
# 'determine if lfence instruction should exist in the retpoline'
HC723EAB1C806: 'lfence 명령어가 retpoline에 존재해야 하는지 확인합니다'
# 'determine the availability of r11 before indirect branches'
H095D2FB8BA79: '간접 분기 전에 r11의 가용성을 확인합니다'
# 'determines whether to demangle function name when symbolizing function ids from the input log'
H55938C1F7AEA: '입력 로그에서 함수 ID를 심볼화할 때 함수 이름을 덤플링할지 여부를 결정합니다'
# 'determines whether to sort input log records by timestamp'
HF854EBCB0FF7: '입력 로그 레코드를 타임스탐프로 정렬할지 여부를 결정합니다'
# "device clause with ancestor device-modifier used without specifying 'requires reverse_offload'"
H7C03F0398F87: "조상 디바이스 수정자를 사용한 디바이스 절은 'requires reverse_offload'를 지정하지 않았습니다"
# "device files are not yet supported by '#embed' directive"
H3E3F85E899CB: '#embed 지시문은 장치 파일을 지원하지 않습니다'
# 'diagnostic formatting in SARIF mode is currently unstable'
HADEECC0D1814: 'SARIF 모드에서의 진단 형식화는 현재 불안정합니다'
# 'diagnostic msg: %0'
H1318B5E4A90B: '진단 메시지: %0'
# 'diagtool find-diagnostic-id options'
H0E16FA84CCEE: 'diagtool 진단-아이디 찾기 옵션'
# "did not expect %0 '%2' to be managed by '%1'"
H41E6876DEC05: " '%2' 가 '%1' 에 의해 %0 되는 것을 기대하지 않았습니다."
# "did not find header '%0' in framework '%1' (loaded from '%2')"
H33EA4C9E31A5: "프레임워크 '%1'에서 헤더 '%0'를 찾을 수 없습니다 (%2에서 로드됨)"
# "did not specify mandatory parameter '%0'"
H3CB9D79D973B: "필수 매개변수 '%0'을(를) 지정하지 않았습니다."
# "did you forget ';'?"
H5762CA5BE293: "';'를 잊으셨는지요?"
# "did you intend to use '#pragma pack (pop)' instead of '#pragma pack()'?"
H38F2C3CF1911: "'#pragma pack (pop)' 대신 '#pragma pack()'을 사용하려는 의도였는지 모르겠습니다."
# "did you mean %0 ('%2' U+%1)?"
H034E19BAF4DB: "당신은 %0 ('%2' U+%1)을 의도하셨나요?"
# 'did you mean %0?'
H0AFE75F407BD: '%0를 의미하지는 않으셨나요?'
# 'did you mean %select{struct|interface|class}0 here?'
H2F94B54CE3AD: '여기에 %select{struct|interface|class}0 의도하셨나요?'
# "did you mean '%0'?"
HC2D29273BC0C: "'%0'을(를) 의미하시는 건가요?"
# "did you mean 'using namespace'?"
H7384271A4FC4: "의도한 것은 'using namespace'이었나요?"
# "did you mean to %select{dereference the argument to 'sizeof' (and multiply it by the number of elements)|remove the addressof in the argument to 'sizeof' (and multiply it by the number of elements)|provide an explicit length}0?"
H206E38ACCE90: '의도하셨나요? %select{sizeof의 인수를 dereference 하셨나요? (요소 개수로 곱해야 합니다)|sizeof의 인수에서 addressof를 제거하셨나요? (요소 개수로 곱해야 합니다)|명시적인 길이를 제공하셨나요?}0'
# 'did you mean to call the %0 method?'
H0FF3D4ADDC94: '%0 메서드를 호출하려는 의도였나요?'
# 'did you mean to compare the result of %0 instead?'
HA27A0B6056FB: '대신 %0의 결과를 비교하려는 의도였나요?'
# "did you mean to use '%0'?"
H18F66684E290: "사용하시려는 건 '%0'이었나요?"
# "did you mean to use '.' instead?"
HE2F23CD42B59: "대신 '.'을 사용하려는 것이었나요?"
# "did you mean to use '\\u'?"
H8EB1B38F64B3: '사용하려는 게 \\u 였나요?'
# "did you mean to use 'typename'?"
HA177681AD789: '‘typename’을 사용하려고 하셨나요?'
# 'did you mean to use __block %0?'
H6A59F85FFA80: '변수 %0에 __block을 사용하려는 의도가 있으신가요?'
# "differing user-defined suffixes ('%0' and '%1') in string literal concatenation"
HD69068F6D5EE: "문자열 리터럴 연결 중에 다른 사용자 정의 접미사 ('%0'와 '%1')가 있습니다"
# 'digit separator cannot appear at %select{start|end}0 of digit sequence'
HC90158811A8B: '숫자 구분자는 숫자 시퀀스의 %select{시작|끝}0 위치에 출현할 수 없습니다'
# 'digit separators are incompatible with C standards before C23'
H45FD89D6E3CC: '숫자 분리자는 C23 이전의 C 표준과 호환되지 않습니다.'
# 'digit separators are incompatible with C++ standards before C++14'
H14907D30B29E: '숫자 구분자는 C++14 이전 표준들과 호환되지 않습니다'
# 'dimension expression does not evaluate to a constant unsigned int'
H7ABEC48E09A3: '차원 표현식의 평가 결과가 상수 unsigned int가 아닙니다'
# "direct access to Objective-C's isa is deprecated in favor of object_getClass()"
H9F7CC297D241: 'Objective-C의 isa에 대한 직접 접근은 object_getClass()를 대신 사용하도록 권장되지 않습니다.'
# 'direct attribute on property %0 ignored (not implemented by this Objective-C runtime)'
H4EFEDE46DF56: '프로퍼티 %0에 직접 지정된 속성이 무시됨 (이 Objective-C 런타임에서 지원되지 않음)'
# 'direct base %0 is inaccessible due to ambiguity:%1'
HB8D80890A48E: '직계 기반 %0는 애매함으로 인해 접근 불가능합니다:%1'
# 'direct comparison of %select{an array literal|a dictionary literal|a numeric literal|a boxed expression|}0 has undefined behavior'
HB492D0D3EB6E: '%select{배열 리터럴|사전 리터럴|수치 리터럴|박싱 표현식|}0의 직접 비교는 정의되지 않았습니다'
# 'direct comparison of a string literal has undefined behavior'
H32F54A871B25: '문자열 리터럴의 직접 비교는 정의되지 않은 동작을 일으킵니다'
# 'direct member declared here'
H29E544F12128: '여기서 선언된 직접 멤버'
# 'direct method %0 declared here'
HFC16D00B1613: '직접 메서드 %0는 여기서 선언되었습니다'
# 'direct method implementation was previously declared not direct'
HD4855D6E8730: '직접 메서드 구현은 이전에 직접적이지 않은 것으로 선언되었습니다.'
# 'direct method was declared in %select{the primary interface|an extension|a category}0 but is implemented in %select{the primary interface|a category|a different category}1'
HE6AB93C50673: '직접 메서드는 %select{주 인터페이스|확장|카테고리}0에서 선언되었지만 %select{주 인터페이스|카테고리|다른 카테고리}1에서 구현되었습니다.'
# 'direct property cannot be @dynamic'
HE7907E55F6FD: '직접 속성은 @dynamic일 수 없습니다.'
# "directive '#pragma omp %0' cannot contain more than one '%1' clause%select{| with '%3' name modifier| with 'source' dependence}2"
H4FF8713761CF: "지시문 '#pragma omp %0'에는 '%1' 절을 1개 이상 사용할 수 없습니다%select{ | '%3' 이름 수정자를 사용하여 | 'source' 종속성을 사용하여 }2"
# "directive '#pragma omp %0' cannot contain more than one 'seq_cst',%select{ 'relaxed',|}1 'acq_rel', 'acquire' or 'release' clause"
HAC63F783B13F: "'#pragma omp %0' 지시문은 'seq_cst',%select{ 'relaxed',|}1 'acq_rel', 'acquire' 또는 'release' 절을 한 개 이상 포함할 수 없습니다"
# "directive '#pragma omp %0' requires the '%1' clause"
H54115AA95D6F: "지시문 '#pragma omp %0'은 '%1' 절이 필요합니다"
# "directive '#pragma omp atomic%select{ %0|}1' cannot be used with '%2' clause"
H007A29406786: "'#pragma omp atomic%select{ %0|}1' 지시문은 '%2' 절과 함께 사용할 수 없습니다"
# "directive '#pragma omp atomic' cannot contain more than one 'read', 'write', 'update', 'capture', or 'compare' clause"
HE9B44E8E263B: "#pragma omp atomic 지시문은 'read', 'write', 'update', 'capture' 또는 'compare' 절을 하나 이상 포함할 수 없습니다"
# "directive '#pragma omp taskwait' cannot use 'nowait' clause without 'depend' clause"
H6E17817BFD4B: "‘#pragma omp taskwait’ 지시문은 'depend' 절이 없으면 'nowait' 절을 사용할 수 없습니다."
# 'directive may only be specified in protocols only'
H164583DA86CB: '지시문은 프로토콜 내에서만 지정될 수 있습니다'
# 'directive must be at file or namespace scope'
H1C3ABA756D9B: '지시문은 파일 또는 네임스페이스 범위에서 있어야 합니다'
# "directive name modifier '%0' is not allowed for '#pragma omp %1'"
H92E146113514: "디렉티브 이름 수정자 '%0'는 '#pragma omp %1'에 허용되지 않습니다"
# 'directory to dump objects to'
HD09DDF1651F9: '객체를 내려놓을 디렉토리'
# 'disable '
HEEBCA72FCF98: '비활성화 '
# 'disable P10 store forward-friendly conversion'
HB86702B7FAD9: 'P10 스토어 포워드 친화적 변환 비활성화'
# 'disable all inlining (overrides other inlining options)'
HFF8B88EEABDB: '인라인을 모두 비활성화 (다른 인라인 옵션을 덮어씀)'
# 'disable attaching TBAA tags to memory accessing operations to override default Flang behavior'
H90AD861FB58A: '메모리 접근 연산에 TBAA 태그를 부착하는 것을 비활성화하여 기본 Flang 동작을 재정의합니다'
# 'disable attributor runs'
H6B93977370B5: 'ATTRIBUTOR 실행을 비활성화합니다'
# 'disable automatically generated 32byte paired vector stores'
H37D64DB7E6AE: '자동으로 생성된 32바이트 페어드 벡터 저장을 비활성화합니다'
# 'disable constant hoisting on PPC'
H653549C49999: 'PPC에서 상수 이동을 비활성화합니다'
# 'disable debug output'
H9D7E26590F03: '디버그 출력을 비활성화합니다'
# 'disable generation of structured FIR'
H021ABE4FA052: '구조화된 FIR 생성을 비활성화'
# 'disable instrumentation optimizations that sacrifice profile accuracy (for debugging, default: false)'
H2E999F6F69E3: '프로파일 정확성을 희생시키는 인스트루먼트 최적화를 비활성화 (디버깅 용도, 기본값: false)'
# 'disable multithreading'
H29487A51C4F2: '멀티스레딩 비활성화'
# 'disable outlining indirect calls.'
H3A6314FB1E19: '간접 호출의 외부화를 비활성화합니다.'
# 'disable peepholes'
H199828204162: '피프홀 최적화 비활성화'
# 'disable preincrement load/store generation on PPC'
H137DF3A43000: 'PPC에서 사전 증가 로드/스토어 생성을 비활성화합니다.'
# 'disable setting the node scheduling preference to ILP on PPC'
H1F9B89B13D72: 'PPC에서 노드 스케줄링 우선순위를 ILP로 설정을 비활성화합니다'
# 'disable sibling call optimization on ppc'
HCCF134132CAF: 'ppc에서 형제 호출 최적화를 비활성화합니다.'
# 'disable similarity matching, and outlining, across branches for debugging purposes.'
H62E4BE9FF57F: '디버깅 목적으로 분기 간 유사성 일치 및 아웃라인을 비활성화합니다.'
# 'disable the default synthesis of Objective-C properties'
H72E5F763EC4E: 'Objective-C 속성의 기본 자동 생성을 비활성화합니다'
# 'disable the feature'
H89A827DA533D: '기능을 비활성화합니다'
# 'disable unaligned load/store generation on PPC'
H6B2367F2761C: 'PPC에서 비정렬 로드/스토어 생성을 비활성화합니다.'
# 'disable vector permute decomposition'
HB72EC10B2CEE: '벡터 재배열 분해 비활성화'
# 'disabled expansion of recursive macro'
H7E32A887A37D: '재귀 매크로 전개가 비활성화되었습니다'
# 'disables externalization of functions whose addresses are taken'
HA22CB7ECC7FF: '주소가 취해진 함수의 외부화를 비활성화합니다'
# 'disables externalization of global variable with local linkage; may cause globals to be duplicated which increases binary size'
HFB10DDFC11CF: '로컬 링크를 가진 전역 변수의 외부화를 비활성화합니다; 이로 인해 전역 변수가 중복되어 이진 파일 크기를 증가시킬 수 있습니다'
# 'discriminator argument to ptrauth_sign_constant must be a constant integer, the address of the global variable where the result will be stored, or a blend of the two'
H24D055782EF6: 'ptrauth_sign_constant의 discriminator 인수는 상수 정수, 결과가 저장될 전역 변수의 주소, 또는 둘의 결합이어야 합니다'
# 'display a graph using the fractional block frequency representation.'
H0E0DF92DD5CF: '분수형 블록 빈도 표현을 사용하여 그래프를 표시합니다.'
# 'display a graph using the raw integer fractional block frequency representation.'
H48B34855A7C6: '원시 정수형 분수 블록 빈도 표현을 사용하여 그래프를 표시합니다.'
# 'display a graph using the real profile count if available.'
H40F8C199B975: '실제 프로파일 카운트가 있으면 이를 사용하여 그래프를 표시합니다.'
# 'display the encoded probes in binary section'
H2AB55984C4D7: '바이너리 섹션에 인코딩된 프로브들을 표시합니다'
# 'display the results in JSON format'
H181ED368406C: 'JSON 형식으로 결과를 표시합니다'
# 'display the results in a list sorted by total time'
HD124AAE398C8: '전체 시간에 따라 정렬된 목록으로 결과를 표시합니다'
# 'display the results in a merged list sorted by pass name'
HD6270C003FAF: '패스 이름으로 정렬된 병합된 목록에 결과를 표시합니다'
# 'display the results in text format'
H5126F4AC6EE2: '텍스트 형식으로 결과를 표시합니다'
# 'display the results ina with a nested tree view'
H3B01C53C285F: '결과를 ina에 중첩 트리 뷰로 표시합니다'
# 'display the results with a nested pipeline view'
HD3FB89799811: '결과를 중첩 파이프라인 뷰로 표시'
# 'div and rem instructions on integers with more than <N> bits are expanded.'
H9085E8D323A2: '정수의 비트 수가 <N>을 초과하는 경우 div 및 rem 명령문은 확장됩니다.'
# 'division by zero'
H3658877899CE: '0으로 나누기'
# 'division by zero in preprocessor expression'
H312B477ACFDB: '프리프로세서 표현식에서 0으로 나누기'
# 'dllexport/dllimport inline member functions of dllexport/import classes (default)'
H138D0C477A7F: 'dllexport/dllimport inline 멤버 함수의 dllexport/import 클래스 (기본값)'
# 'dllimport cannot be applied to non-inline function definition'
H1B629BAD5F55: 'dllimport는 inline이 아닌 함수 정의에 적용할 수 없습니다'
# 'do not apply'
HB502CD3A2C1B: '적용하지 마십시오'
# 'do not diff functions whose contents have not been changed from one binary to another'
H30A32C42CDF9: '내용이 변경되지 않은 함수는 다른 바이너리 간에 비교하지 마세요'
# 'do not display graphs.'
H0D6F782C8BD3: '그래프를 표시하지 않습니다.'
# 'do not emit module ctors for global counters'
H4C00D7F83272: '전역 카운터에 대해 모듈 생성자(ctor)를 생성하지 마세요'
# 'do not infer Objective-C related result type based on method family'
HA72282825A47: '메서드 패밀리에 기반하여 Objective-C 관련 결과 타입을 추론하지 않음'
# 'do not optimize PLT calls'
H790DE86EF643: 'PLT 호출을 최적화하지 마십시오'
# 'do not optimize functions with jump tables'
HCB3EB74717E1: '점프 테이블이 있는 함수는 최적화하지 마세요'
# 'do not perform frame optimization'
HA057BC463383: '프레임 최적화를 수행하지 않습니다'
# 'do not perform indirect call promotion'
H868459C436A1: '간접 호출 프로모션을 수행하지 마'
# 'do not print merged data to stdout'
H7F153D59BE8A: 'stdout에 병합된 데이터를 출력하지 않습니다'
# 'do not print objects/functions'
H6FEA94329728: '객체/함수를 출력하지 않음'
# 'do not reorder basic blocks'
HDB47587E0803: '기본 블록을 재정렬하지 마십시오'
# 'do not reorder functions'
H80129F5CF747: '함수를 재정렬하지 마십시오'
# 'do not scan cold functions for external references (may result in slower binary)'
H06D0BAB57AFF: 'cold functions의 외부 참조를 스캔하지 않음 (더 느린 바이너리가 생성될 수 있음)'
# 'do not show.'
H410E3DC30FB6: '표시하지 않습니다.'
# 'domain argument %0 does not point to an NSString or CFString constant'
H04276D1D8088: '도메인 인수 %0는 NSString 또는 CFString 상수를 가리키지 않습니다'
# 'domain argument %select{|%1 }0does not refer to global constant'
H427CD3AEDAC3: '도메인 인수 %select{|%1 }0는 전역 상수를 참조하지 않습니다'
# "don't always align innermost loop to 32 bytes on ppc"
H8446540436C8: 'ppc에서 가장 내부 루프를 32바이트로 항상 정렬하지 않는 것이 좋습니다'
# "don't demangle symbols"
HFD596F32C278: '심볼을 데맨글링하지 마세요'
# "don't report bad accesses via pointers with this tag"
HC0582E9D5000: '이 태그를 사용하는 포인터를 통해 발생한 잘못된 접근을 보고하지 않습니다'
# "don't test for failure"
H2CD70DD9AB50: '실패 여부를 테스트하지 마십시오'
# 'double precision constant requires %select{cl_khr_fp64|cl_khr_fp64 and __opencl_c_fp64}0, casting to single precision'
H4D72ED1FA64B: '이중 정밀도 상수는 %select{cl_khr_fp64|cl_khr_fp64 및 __opencl_c_fp64}0를 필요로 합니다, 단일 정밀도로 캐스팅'
# 'double-quoted include "%0" cannot be aliased to angle-bracketed include <%1>'
H136E4A788F48: '이중 따옴표로 감싸인 include "%0"는 삼각 괄호로 감싸인 include <%1>로 별칭 지정할 수 없습니다'
# 'double-quoted include "%0" in framework header, expected angle-bracketed instead'
H2D4306614026: '프레임워크 헤더 파일에서 이중따옴표로 감싸진 include "%0"가 발견되었습니다. 대신 각도형 괄호(<>로 감싸야 합니다'
# 'due to %0 being dllexported%select{|; try compiling in C++11 mode}1'
HB6A4EDE022F4: 'dllexported인 %0로 인해%select{|; C++11 모드로 컴파일해 보십시오}1'
# 'due to lvalue conversion of the controlling expression, association of type %0 will never be selected because it is %select{of array type|qualified}1'
HE4CE0D7DDF88: '제어 식의 lvalue 변환으로 인해 %0 형식의 연관은 %select{배열 형식이기 때문에|수정자로 지정되었기 때문에}1 절대로 선택될 수 없습니다'
# 'dump CFG of functions with unknown control flow'
HDBCCF42DD8E1: '알려지지 않은 제어 흐름을 가진 함수의 CFG를 dump합니다'
# 'dump CodeView symbol record raw bytes'
HAEF5CAE11C43: 'CodeView 심볼 레코드의 원시 바이트를 덤프합니다'
# 'dump CodeView type record raw bytes from IPI stream'
H689D664ADF5F: 'IPI 스트림에서 CodeView 타입 레코드의 원시 바이트를 덤프합니다'
# 'dump CodeView type record raw bytes from TPI stream'
H0FC07B9E3139: 'CodeView 유형 기록의 원시 바이트를 TPI 스트림에서 dump'
# 'dump CodeView type records from IPI stream'
H7E10374C5E74: 'CodeView 타입 레코드를 IPI 스트림에서 덤프합니다'
# 'dump CodeView type records from TPI stream'
H4737840A6120: 'TPI 스트림에서 CodeView 타입 레코드를 출력합니다'
# 'dump FPO records'
H341F7F9C33EE: 'FPO 레코드 덤프'
# 'dump Globals hashes'
H39246A122E5B: '글로벌 해시 값을 덤프합니다'
# 'dump Globals symbol records'
H9634A6AB6723: '전역 심볼 레코드 덤프'
# 'dump Linux alternative instructions info'
H92A80825B346: 'Linux 대체 명령어 정보를 내보냅니다'
# 'dump Linux kernel PCI fixup table'
H0391F2419EB1: 'Linux 커널 PCI 수정 테이블을 dump합니다'
# 'dump Linux kernel SMP locks'
HF372737C565A: '리눅스 커널 SMP 락 덤프'
# 'dump Linux kernel exception table'
HD3701232B9AB: '리눅스 커널 예외 테이블 덤프'
# 'dump Linux kernel paravitual patch sites'
HAD29F02859C4: '리눅스 커널 파라비추얼 패치 사이트 덤프'
# 'dump Linux kernel static calls'
HBDFDCB9108E1: '리눅스 커널 정적 호출 덤프'
# 'dump Linux kernel static keys jump table'
HF51D39901B0D: '리눅스 커널 정적 키 점프 테이블 덤프'
# 'dump PDB String Table'
H21DF5A80DD1F: 'PDB 문자열 테이블 덤프'
# 'dump PDB String Table Details'
H5264906CCB27: 'PDB 문자열 테이블 세부사항 덤프'
# 'dump PDB named stream table'
HD3F8AEE8FAA4: 'PDB의 이름이 지정된 스트림 테이블을 덤프'
# 'dump Publics hashes and address maps'
H982F0D86E5A4: 'Publics 해시 및 주소 맵을 출력합니다'
# 'dump Publics stream data'
H77C736E1764D: 'Publics 스트림 데이터를 덤프합니다'
# 'dump all BAT tables'
H2473A7E7E1DA: '모든 BAT 테이블을 덤프합니다'
# 'dump backreferences'
H60EF9FD249CA: '백리퍼런스 덤프'
# 'dump callgraph to the given file'
H3F328C977475: '지정된 파일에 호출 그래프를 덤프합니다'
# 'dump compiland information'
H6229647CD528: '컴파일 대상 정보 덤프'
# 'dump cross module exports (DEBUG_S_CROSSSCOPEEXPORTS subsection)'
HBA659F46571B: '교차 모듈 내보내기 덤프 (DEBUG_S_CROSSSCOPEEXPORTS 부분)'
# 'dump cross module imports (DEBUG_S_CROSSSCOPEIMPORTS subsection)'
H26F5B6DD5D0E: '모듈 간 임포트 덤프 (DEBUG_S_CROSSSCOPEIMPORTS 하위 섹션)'
# 'dump file information'
HE35AD70400C4: '파일 정보 dump'
# 'dump file summary'
HBC127C99D732: '파일 요약 정보 출력'
# "dump function CFGs to graphviz format after each stage;enable '-print-loops' for color-coded blocks"
H790226C2A523: '각 단계별로 함수 CFG를 graphviz 형식으로 dump합니다;-print-loops 옵션을 활성화하면 색상 구분된 블록을 사용합니다'
# 'dump function into assembly'
H160A471B29E4: '함수를 어셈블리로 dump'
# 'dump id hashes and index offsets'
H45ABCE63A690: 'id 해시와 인덱스 오프셋을 내보내기'
# 'dump inlinee line information (DEBUG_S_INLINEELINES subsection)'
HD3FD0B06365E: '인라인된 라인 정보 출력 (DEBUG_S_INLINEELINES 서브섹션)'
# 'dump jitted objects'
HC6CCA4501C84: 'jit된 객체 dump'
# 'dump module symbols'
H1047966FD40D: '모듈 심볼을 출력합니다'
# 'dump parsed bolt data for debugging'
H1E6D3BB027F8: '디버깅을 위해 분석한 bolt 데이터를 덤프'
# 'dump public / global common record stream'
H582CCEB02839: '공용/전역 공통 레코드 스트림을 덤프합니다'
# 'dump raw ORC unwind information (sorted)'
H3C7746AFAC8F: 'ORC 언윈드 정보의 원시 데이터를 출력 (정렬됨)'
# 'dump section contributions'
HD1F222CEF84F: '섹션 기여 내용 덤프'
# 'dump section map'
H3816E8108BF5: '섹션 맵 덤프'
# 'dump source file/line information (DEBUG_S_LINES subsection)'
HD995BB7B3DC0: '소스 파일/라인 정보를 출력 (DEBUG_S_LINES subsection)'
# 'dump statistics on the number and size of types transitively referenced by symbol records'
H63F7F6E11F53: 'symbol records에 의해 간접적으로 참조된 타입의 수와 크기 통계를 dump합니다'
# "dump subsections from each module's debug stream"
HFC99948BE195: '각 모듈의 디버그 스트림에서 하위 섹션을 덤프합니다.'
# 'dump summary of the PDB streams'
H81F82DCB9C94: 'PDB 스트림의 요약 정보를 출력합니다'
# 'dump the Pre-FIR tree prior to FIR generation'
H1C6BBDF08715: 'FIR 생성 이전의 Pre-FIR 트리를 출력합니다'
# 'dump the preprocessed tokens'
H80F7445EE14A: '전처리된 토큰을 덤프합니다'
# 'dump the symbol table'
H8EF419A2DB2C: '심볼 테이블을 덤프합니다'
# "dump the symbols record's all children."
HB63145DD7309: '기호 기록의 모든 자식을 덤프합니다.'
# "dump the symbols record's all parents."
H7B31FDBBCCB3: '기호 레코드의 모든 부모를 출력합니다.'
# 'dump the syntax tree'
H63FBC9209EA6: '구문 트리를 출력합니다'
# 'dump type hashes and index offsets'
H02D59206CDC4: '타입 해시 및 인덱스 오프셋 덤프'
# 'dumps the generated benchmark object to disk and prints a message to access it'
H7BC6D646456E: '생성된 벤치마크 오브젝트를 디스크에 덤프하고 접근하는 데 사용할 메시지를 출력합니다'
# "duplicate %0 clause in an 'external_source_symbol' attribute"
H3523FE9C404F: "중복된 %0 절이 'external_source_symbol' 속성에 있습니다."
# "duplicate '%0' declaration specifier"
HD8ED5E5CBF0B: "중복된 '%0' 선언 지정자"
# "duplicate 'virtual' in base specifier"
HA0A16A07E97F: "기반 지정자에서 'virtual'이 중복되었습니다."
# "duplicate asm qualifier '%0'"
HE8EA4F072983: "중복된 asm 지정자 '%0'"
# "duplicate attribute subject matcher '%0'"
H1D5786B873EA: "중복된 속성 대상 매처 '%0'"
# "duplicate case value '%0'"
H4BDEA82874BB: "중복된 case 값 '%0'"
# "duplicate case value: '%0' and '%1' both equal '%2'"
HCE899F8A3E5C: "중복된 case 값: '%0'과 '%1'이 모두 '%2'와 같습니다"
# 'duplicate code segment specifiers'
HBEFD6978776A: '중복된 코드 섹션 지정자'
# 'duplicate declaration of %0 is invalid in C++'
H3F3D9A6BB48A: '%0의 중복 선언은 C++에서 유효하지 않습니다.'
# 'duplicate declaration of method %0'
HA0EF6CBBD7AC: '중복된 메서드 %0 선언'
# 'duplicate default generic association'
H2C51601AE456: '중복된 기본 제네릭 연관'
# 'duplicate definition of category %1 on interface %0'
HECFD78DC0BC9: '인터페이스 %0에서 범주 %1에 중복 정의입니다.'
# 'duplicate explicit instantiation of %0'
HDBC529CD9977: '중복된 %0의 명시적 인스턴스화'
# 'duplicate explicit instantiation of %0 ignored as a Microsoft extension'
HDA2A4AABFB51: '중복된 %0의 명시적 인스턴스화는 Microsoft 확장 기능으로 인해 무시됩니다.'
# 'duplicate interface definition for class %0'
H95CB7C0C6F7F: '클래스 %0에 대한 중복된 인터페이스 정의입니다.'
# 'duplicate key in dictionary literal'
H048B82F688D2: '사전 리터럴에 중복된 키가 있습니다'
# 'duplicate macro parameter name %0'
H066136189F8C: '중복된 매크로 매개변수 이름 %0'
# 'duplicate member %0'
HC0ECCD41D310: '중복된 멤버 %0'
# "duplicate modifier '%0' in '%1' clause"
HF11C4EF9CA32: "중복된 수정자 '%0'가 '%1' 절에서 사용되었습니다."
# "duplicate module file extension block name '%0'"
HCCAD463A8663: "중복된 모듈 파일 확장 블록 이름 '%0'"
# 'duplicate nullability specifier %0'
HBA9CD0A409AC: '중복된 nullability 지정자 %0'
# 'duplicate parameter modifier %0'
H6D49784340BA: '중복된 매개변수 수정자 %0'
# 'duplicate protocol definition of %0 is ignored'
HD20F74839349: '프로토콜 %0의 정의가 중복되어 무시됩니다'
# 'duplicate unconditional branches that cross a cache line'
H33FDED0520CF: '중복된 무조건적 분기: 캐시 라인을 횡단'
# 'duplicate use of asm operand name "%0"'
H3EAACD3C87CF: '어셈블리 연산자 이름 "%0"의 중복 사용'
# "duplicated command '%select{\\|@}0%1'"
H76B78FD8FF48: "중복된 명령어 '%select{\\|@}0%1'"
# 'during field initialization in %select{this|the implicit default}0 constructor'
H865BE3842864: '필드 초기화 중 %select{이|암시적 기본}0 생성자에서'
# 'during template argument deduction for %select{class|variable}0 template %select{partial specialization |}1%2 %3'
H7650D46B8E2E: '%select{클래스|변수}0 템플릿 %select{부분 특수화 |}1%2 %3 템플릿 인수 추론 중'
# 'dxc compatibility options.'
H3AF127D95E36: 'dxc 호환성 옵션.'
# 'dxv not found; resulting DXIL will not be validated or signed for use in release environment'
H6BC661D7D75A: 'dxv를 찾을 수 없습니다; 결과로 생성된 DXIL은 릴리즈 환경에서 사용하기 위해 검증 또는 서명되지 않을 것입니다'
# 'dynamic exception specifications are deprecated'
H37FC9EB13E92: '동적 예외 지정은 권장되지 않습니다.'
# 'dynamic exception specifications with types are currently ignored in wasm'
H3D36CC52AFBF: '타입을 포함한 동적 예외 지정은 현재 wasm에서 무시됩니다'
# 'dynamic initialization is not supported for __device__, __constant__, __shared__, and __managed__ variables'
H6251875A88D3: '동적 초기화는 __device__, __constant__, __shared__ 및 __managed__ 변수에서 지원되지 않습니다'
# "dynamic library symbol '%0' is %select{weak defined|thread local}1, but its declaration is not"
H876356229227: "동적 라이브러리 심볼 '%0'은 %select{약하게 정의됨|쓰레드 로컬}1이지만, 선언에는 그렇지 않습니다."
# 'dynamic memory allocation is not permitted in constant expressions until C++20'
H63A7F05406AD: 'C++20 이전에는 상수 표현식에서 동적 메모리 할당을 허용하지 않습니다.'
# 'dynamic property cannot have instance variable specification'
HD37DA789564D: '동적 속성은 인스턴스 변수 지정을 가질 수 없습니다'
# 'dynamic_cast will not work since RTTI data is disabled by %select{-fno-rtti-data|/GR-}0'
HBD4085CEECCB: 'dynamic_cast가 작동하지 않습니다. 이는 RTTI 데이터가 %select{-fno-rtti-data|/GR-}0로 비활성화되었기 때문입니다.'
# 'e'
H58E6B3A414A1: 'e'
# 'editor placeholder in source file'
H8455BF28630F: '소스 파일 내 에디터 플레이스홀더'
# "effects conflict when merging declarations; kept '%0', discarded '%1'"
H73408A047417: "선언을 병합할 때 효과가 충돌했습니다; '%0'을 유지했고 '%1'은 버려졌습니다"
# 'elaborated enum specifier cannot be declared as a friend'
H7321A1B2921E: '명시적 열거형 지정자는 친구로 선언될 수 없습니다.'
# 'element %0 also has value %1'
HFCF33BA58954: '요소 %0도 값 %1을 가지고 있습니다'
# 'element %0 has been implicitly assigned %1 which another element has been assigned'
H72D209AC7B7A: '요소 %0는 %1이 암묵적으로 할당되었는데, 다른 요소에도 동일한 값이 할당되었습니다'
# 'eliminate unreachable code'
H5CECE35D9DC9: '도달할 수 없는 코드 제거'
# 'ellipsis in pack %select{|init-}0capture must appear %select{after|before}0 the name of the capture'
H6C27D3CFC7C1: '팩 패키지의 %select{|초기화-}0캡처 내에서 ... (Ellipse)는 %select{이후|이전}0 캡처의 이름에 위치해야 합니다'
# 'embedded and GOT-based position independence are incompatible'
H471F7EE0F065: '임베디드 및 GOT 기반 위치 독립성은 호환되지 않습니다'
# 'embedding a #%0 directive within macro arguments is not supported'
HB9B077BA7EC9: '매크로 인수 내에 #%0 디렉티브를 포함하는 것은 지원되지 않습니다'
# 'embedding a directive within macro arguments has undefined behavior'
HD8530107105F: '매크로 인수 내부에 지시문을 내장하는 것은 정의되지 않은 동작입니다'
# 'emit JSON'
H65D5678CB372: 'JSON을 생성합니다'
# 'emit YAML'
H54F0FFD710F0: 'YAML 생성'
# 'emit normal text output (default)'
HED43B52325DA: '일반 텍스트 출력을 생성 (기본값)'
# 'emit warnings'
H020A72B2E05B: '경고 메시지를 생성합니다'
# 'empty %0 cannot be composed with named ones'
HE7EB612973FC: '비어 있는 %0는 이름이 지정된 것들과 함께 구성할 수 없습니다'
# 'empty %select{struct|union}0 is a GNU extension'
H758BF913FE7C: '빈 %select{struct|union}0은 GNU 확장 기능입니다'
# 'empty case range specified'
H15C9A1C7CC9D: '비어 있는 케이스 범위가 지정되었습니다'
# 'empty character constant'
H277FE12896EE: '빈 문자 상수'
# "empty delimited universal character name; treating as '\\' '%0' '{' '}'"
HF9BFC93E5104: "구분된 보편 문자 이름이 비어 있습니다; 따라서 '\\' '%0' '{' '}'로 간주합니다"
# "empty expression statement has no effect; remove unnecessary ';' to silence this warning"
HE7735A8B2ADE: "비어 있는 표현식 문은 영향을 주지 않습니다; 이 경고를 제거하려면 불필요한 ';'를 제거하십시오."
# 'empty filename'
H1CC4DB7178D7: '비어 있는 파일 이름'
# "empty initialization statement of '%select{if|switch|range-based for}0' has no effect"
HCB0D32A02160: '‘%select{if|switch|range-based for}0’의 초기화 문이 비어 있어 영향을 주지 않습니다'
# 'empty macro arguments are a C99 feature'
HD178344D06D5: '빈 매크로 인수는 C99의 기능입니다'
# 'empty macro arguments are incompatible with C++98'
HE94FA0985A16: '비어 있는 매크로 인수는 C++98과 호환되지 않습니다'
# 'empty modifier-specification-list is not allowed'
HB0857A4C55BC: '비어 있는 modifier-specification-list는 허용되지 않습니다'
# "empty paragraph passed to '%select{\\|@}0%1' command"
H38E7CAD895AE: "빈 단락이 '%select{\\|@}0%1' 명령어에 전달되었습니다"
# 'empty parentheses interpreted as a function declaration'
H058E44413EA1: '빈 괄호가 함수 선언으로 간주됩니다'
# 'empty symbolic operand name in inline assembly string'
H2DC9E2773A21: '인라인 어셈블리 문자열 내 빈 심볼릭 오퍼랜드 이름'
# 'enable '
H15F13B12A39B: '활성화 '
# 'enable CUDA Fortran'
H7782720B2BB2: 'CUDA Fortran 활성화'
# 'enable PC Relative linker optimization'
HB16456951215: 'PC 상대적 링커 최적화 활성화'
# 'enable all attributor runs'
HDC600719482C: '모든 attributor 실행을 활성화합니다'
# 'enable all debugging printout'
H74F2F5BCE1B3: '모든 디버깅 출력을 활성화합니다'
# 'enable all peephole optimizations'
HDB0605F9FA2D: '모든 피홀 최적화를 활성화합니다'
# 'enable call graph SCC attributor runs'
H3201C4D45BA3: '호출 그래프 SCC 어트리뷰터 실행 활성화'
# 'enable coalescing of duplicate branches for PPC'
HF8CFF517B8BE: 'PPC를 위한 중복 분기 결합 활성화'
# 'enable const and copy propagation after tail duplication'
H9919F0504195: '꼬리 복제 후 const 및 복사 전파를 활성화합니다'
# 'enable elimination of sign-extensions'
HF1685FA60FF7: '부호 확장 제거 활성화'
# 'enable elimination of zero-extensions'
H64FB2468ED4F: '제로 확장 제거 활성화'
# 'enable extended encoding of block type signature'
HCB2363578F85: '확장된 블록 유형 서명 인코딩을 활성화합니다'
# 'enable fixed form'
H94C246A27D7E: '고정 형식을 사용하도록 설정'
# 'enable load elimination using memory profiling data when performing ICP'
HF69B8E887DB3: 'ICP 수행 시 메모리 프로파일링 데이터를 이용하여 로드 제거를 활성화합니다'
# "enable memory profile parsing if it's present in the input data, on by default unless `--itrace` is set."
H015F6FD662F3: '입력 데이터에 메모리 프로파일 파싱이 존재하는 경우 활성화합니다. 기본적으로 활성화되어 있으며, `--itrace`가 설정된 경우에만 비활성화됩니다.'
# 'enable module-wide attributor runs'
H6A1678301319: '모듈 전체 attributor 실행 활성화'
# 'enable openacc'
HCDE854697CA7: 'openacc 기능을 활성화합니다'
# 'enable openmp'
H1CFA464A8305: 'OpenMP를 사용하도록 활성화합니다.'
# 'enable openmp GPU target codegen'
HFFBCDE42BA97: 'OpenMP GPU 타겟 코드 생성을 활성화합니다'
# 'enable openmp device compilation'
H87F22E3808C9: 'OpenMP 장치 컴파일 활성화'
# 'enable optimization of conditional traps'
HE76CA42D1102: '조건부 트랩 최적화 활성화'
# 'enable peephole optimizations'
HCB5CF649C604: '피치홀 최적화 활성화'
# 'enable preservation of all attributes. even those that are unlikely to be useful'
H13B51E3CE008: '모든 속성의 보존을 활성화합니다. 유용하지 않을 것 같은 것도 포함합니다'
# 'enable preservation of attributes throughout code transformation'
H580FCE5CF0E9: '코드 변환 과정 전반에 걸쳐 속성 유지 활성화'
# 'enable register pressure reduce in machine combiner pass.'
H357058DB4C32: '머신 콤바이너 패스에서 리지스트 압력 감소 활성화'
# 'enable safe stack coloring'
H95A282232AD0: '안전한 스택 색칠을 사용합니다'
# 'enable safe stack layout'
HCB2AFC2C2D37: '안전한 스택 레이아웃 활성화'
# 'enable software prefetching on PPC'
H5C8D5DA8AA2D: 'PPC에서 소프트웨어 예측 읽기를 활성화합니다.'
# 'enable splitting of the restore block if possible'
HFB2E82BFA087: '가능한 경우 복구 블록 분할을 활성화합니다'
# 'enable the feature when using profile data'
H983F48A83B4D: '프로파일 데이터를 사용할 때 기능을 활성화합니다'
# 'enable the feature with/wo profile data'
HA9F0B8DA8301: '프로파일 데이터를 사용하여/사용하지 않고 기능을 활성화합니다'
# 'enable the shrink-wrapping pass'
H7A4C304F5A12: 'shrink-wrapping 패스를 활성화합니다'
# 'enable use of redzone on AArch64'
H0CF57E62B75D: 'AArch64에서 레드존 사용을 활성화합니다'
# 'enable/disable all ARC Optimizations'
H0DFE6EE5AB14: '모든 ARC 최적화 활성화/비활성화'
# 'enclose %0 in %select{an @available|a __builtin_available}1 check to silence this warning'
HC0011ACD5CEF: '이 경고를 무시하려면 %0를 %select{@available|__builtin_available}1로 감싸세요'
# 'encoding of %0 type is incomplete because %1 component has unknown encoding'
HE63ED9F43B42: '타입 %0의 인코딩이 완성되지 않았습니다. %1 구성 요소가 알려지지 않은 인코딩을 가지기 때문입니다.'
# "encoding prefix '%0' on an unevaluated string literal has no effect%select{| and is incompatible with c++2c}1"
HFB264777D8F6: "인코딩 접두사 '%0'가 평가되지 않은 문자열 리터럴에 적용되어도 영향을 미치지 않습니다%select{|이며 C++2c와 호환되지 않습니다}1"
# 'end tag'
HE76165194C35: '종료 태그'
# "entering module '%0' due to this pragma"
H00CF7F723C1C: "이 pragma로 인해 '%0' 모듈에 진입합니다"
# 'enum %0 was explicitly specialized here'
H888313DD02EB: 'enum %0는 여기서 명시적으로 특수화되었습니다'
# 'enumeration %0 is incomplete'
HACD4B99390E7: '열거형 %0는 완전하지 않습니다'
# 'enumeration cannot be a template'
H0777CF5091AE: '열거형은 템플릿일 수 없습니다'
# 'enumeration previously declared as %select{un|}0scoped'
H979505490BD1: '열거형이 이전에 %select{비|}0범위 지정된으로 선언되었습니다'
# 'enumeration previously declared with %select{non|}0fixed underlying type'
H8C078F2C2E0F: '이전에 %select{비|}0고정된 기반 형식을 가진 열거형이 선언되었습니다'
# 'enumeration redeclared with different underlying type %0 (was %1)'
H67E555152513: '열거형이 다른 기본 형식 %0으로 재선언되었습니다 (이전 형식은 %1이었습니다)'
# 'enumeration type %0 is not allowed in a vector conditional'
H71F136014B3C: '열거형 타입 %0는 벡터 조건문에서 허용되지 않습니다'
# 'enumeration type in nested name specifier is incompatible with C++98'
HA088A8B3CD7F: '중첩된 이름 지정자 내의 열거형 타입은 C++98과 호환되지 않습니다.'
# 'enumeration types with a fixed underlying type are a C++11 extension'
HFFCCC841103E: '고정된 기본 타입을 가진 열거형 타입은 C++11 확장 기능입니다'
# 'enumeration types with a fixed underlying type are a C23 extension'
H463F9486C53D: '고정된 기본 타입을 가진 열거형 타입은 C23 확장입니다'
# 'enumeration types with a fixed underlying type are a Microsoft extension'
H6BC03602C783: '고정된 기본 타입을 가진 열거형 타입은 마이크로소프트 확장 기능입니다'
# 'enumeration types with a fixed underlying type are incompatible with C standards before C23'
H39FE50255F32: 'C23 이전의 C 표준과 호환되지 않는 고정된 기본 타입을 가진 열거형 타입입니다'
# 'enumeration types with a fixed underlying type are incompatible with C++98'
H73924A0CCAED: '고정된 기본 타입을 가진 열거형 타입은 C++98와 호환되지 않습니다'
# 'enumeration value %0 is out of range of flags in enumeration type %1'
H4F8DF0E727E1: '열거형 값 %0은 열거형 유형 %1의 플래그 범위를 벗어났습니다.'
# 'enumeration values exceed range of largest integer'
HC084754F6A8B: '열거형 값이 가장 큰 정수의 범위를 초과합니다'
# 'enumerations cannot be explicitly instantiated'
H997CA3993586: '열거형은 명시적으로 인스턴스화할 수 없습니다'
# 'enumerator %0 does not exist in instantiation of %1'
H3D7F75D140F9: 'enumerator %0는 %1의 인스턴스화에서 존재하지 않습니다'
# 'enumerator %0 with value %1 here'
HD8CCFA398CFA: '여기서 열거자 %0의 값은 %1입니다'
# 'enumerator value %0 is not representable in the underlying type %1'
HAB7EC95F417E: '열거형 값 %0는 기본 형식 %1에 표현할 수 없습니다'
# 'enumerator value is not representable in the underlying type %0'
H9CDAE4E68DA9: '열거형 값은 기본 형식 %0에 표현할 수 없습니다'
# 'enums in the Microsoft ABI are signed integers by default; consider giving the enum %0 an unsigned underlying type to make this code portable'
HB2071E0C6A67: '마이크로소프트 ABI에서 열거형은 기본적으로 부호 있는 정수입니다; %0 열거형에 부호 없는 기본 형식을 지정하여 이 코드를移植 가능하게 만들려면 고려해 보세요'
# "environment '%0' is not supported: '%1'"
H88874600742B: "환경 '%0'은 지원되지 않습니다: '%1'"
# "environment variable 'SOURCE_DATE_EPOCH' ('%0') must be a non-negative decimal integer <= %1"
H4F81D6E33B46: "환경 변수 'SOURCE_DATE_EPOCH' ('%0')는 %1 이하의 음이 아닌 십진 정수여야 합니다."
# 'environment variable CC_PRINT_HEADERS_%select{FORMAT|FILTERING}0 has invalid value %1'
H69C68EA8FAC0: '환경 변수 CC_PRINT_HEADERS_%select{FORMAT|FILTERING}0에 잘못된 값 %1이 지정되었습니다.'
# 'environment variable CC_PRINT_HEADERS_FORMAT=%0 requires a compatible value for CC_PRINT_HEADERS_FILTERING'
HFC634F31327F: '환경 변수 CC_PRINT_HEADERS_FORMAT=%0은(는) CC_PRINT_HEADERS_FILTERING에 호환 가능한 값을 요구합니다.'
# 'epsilon for benchmark point clustering'
HA3C9480C7F62: 'benchmark point 클러스터링을 위한 epsilon 값'
# 'epsilon for detection of when the cluster is different from the LLVM schedule profile values'
HBE4394643CF5: 'LLVM 스케줄 프로파일 값과 다른 클러스터를 감지하기 위한 에пси론'
# 'equality comparison between function pointer and void pointer (%0 and %1)'
HD61C2409F0EE: '함수 포인터와 void 포인터(%0 및 %1) 사이의 등식 비교'
# 'equality comparison with extraneous parentheses'
H461F5EF9D3AE: '중복된 괄호가 있는 등호 비교'
# 'error in backend: %0'
H5E9564F574A6: '백엔드 오류: %0'
# "error in loading module '%0' from prebuilt module path"
H9CB0C604EFA6: "미리 빌드된 모듈 경로에서 모듈 '%0'을 로드하는 중 오류가 발생했습니다."
# "error opening '%0': %1"
H14F257DDD829: "파일 '%0'을(를) 열 수 없습니다: %1"
# "error opening '%0': required by the CrossTU functionality"
HD1F59176156D: '‘%0’을(를) 열 수 없습니다: CrossTU 기능에 의해 필요합니다'
# "error opening file '%0': %1"
H36FA208EA1D0: "파일 '%0' 열기 오류: %1"
# "error parsing index file: '%0' line: %1 '<USR-Length>:<USR> <File-Path>' format expected"
HDAED7E913418: "인덱스 파일 해석 중 오류: '%0' 라인: %1 '<USR-Length>:<USR> <File-Path>' 형식이 예상됩니다"
# "error reading '%0': %1"
HB78815388E3E: '‘%0’ 읽기 오류: %1'
# 'error reading stdin: %0'
HFD3376140ADC: 'stdin 읽기 오류: %0'
# 'escaped newline between */ characters at block comment end'
H16A52D2449DE: '블록 주석 끝의 */ 문자 사이에 이스케이프된 줄바꿈'
# 'exact handling of relational integer ICmp'
H083F931E8E9B: '관계 정수 ICmp의 정확한 처리'
# "exactly one '%0' directive must appear in the loop body of an enclosing directive"
H3C9E45F0564B: "포함된 지시문의 루프 본문에 정확히 하나의 '%0' 지시문이 존재해야 합니다."
# "exactly one of 'depend', 'destroy', or 'update' clauses is expected"
H41134C7D7A6A: "정확히 'depend', 'destroy' 또는 'update' 절 중 하나가 필요합니다."
# "exactly one of 'inclusive' or 'exclusive' clauses is expected"
H43DE08BE23B9: "정확히 하나의 'inclusive' 또는 'exclusive' 절이 필요합니다"
# 'exception declarator cannot be qualified'
H9E73B1CE7174: 'exception declarator는 자격을 가질 수 없습니다'
# 'exception model'
HB1632BFA78F0: '예외 모델'
# 'exception object of type %0 has %select{private|protected}1 destructor'
H45EFA39B1650: '형식 %0의 예외 객체는 %select{private|protected}1 소멸자를 가지고 있습니다'
# 'exception of type %0 will be caught by earlier handler'
H63736AC525A3: '유형 %0의 예외는 이전 핸들러에 의해 처리될 것입니다'
# 'exception specification in declaration does not match previous declaration'
H02068091298F: '선언문에서의 예외 지정이 이전 선언문과 일치하지 않습니다'
# 'exception specification in explicit instantiation does not match instantiated one'
HB42947FF7AB7: '명시적 인스턴스화에서의 예외 지정이 인스턴스화된 것과 일치하지 않습니다'
# 'exception specification is not available until end of class definition'
HD568DD20B09E: '예외 사양은 class 정의의 끝까지 사용할 수 없습니다'
# 'exception specification needed for member of incomplete class %0'
H64C22CA14EC7: '미완성 클래스 %0의 멤버에 예외 지정이 필요합니다'
# 'exception specification of %0 uses itself'
H8B7B4ED4974B: '예외 지정 %0가 자신을 사용했습니다.'
# "exception specification of '...' is a Microsoft extension"
H50C368DB8633: "...'의 예외 지정은 마이크로소프트 확장 문법입니다"
# 'exception specification of overriding function is more lax than base version'
HBB63D54D7089: '오버라이딩 함수의 예외 지정은 기반이 되는 버전보다 더 느슨합니다'
# 'exception specifications are not allowed beyond a single level of indirection'
HB84B4B7EA104: '예외 사양은 단일 간접화 레벨을 초과하는 경우 허용되지 않습니다'
# 'exception specifications are not allowed in %select{typedefs|type aliases}0'
HBAC9EC08A3E9: '예외 지정은 %select{typedefs|타입 별칭}0에서 허용되지 않습니다'
# 'exception specifications of %select{return|argument}0 types differ'
H04931F9B5864: '예외 지정의 %select{리턴|인수}0 형식이 다릅니다'
# 'excess elements in %select{array|vector|scalar|union|struct}0 initializer'
H6B059251CDF0: '초과한 요소가 %select{배열|벡터|스칼라|유니온|구조체}0 초기화자에 있습니다'
# 'excess elements in char array initializer'
H65240A881DB2: 'char 배열 초기화자에 초과된 요소'
# 'excess elements in initializer for indivisible sizeless type %0'
HF6B0539A54ED: '초기화자에 초과 요소가 있는 분할 불가능한 크기 없는 타입 %0'
# 'excess precision is requested but the target does not support excess precision which may result in observable differences in complex division behavior%select{|, additional uses where the requested higher precision cannot be honored were found but not diagnosed}0'
H46192DCC4FC7: '초과 정밀도가 요청되었지만 대상은 초과 정밀도를 지원하지 않아 복소수 나눗셈의 동작에 관측 가능한 차이가 발생할 수 있습니다%select{|, 요청된 높은 정밀도를 충족시킬 수 없는 추가 사용 사례가 발견되었지만 진단되지 않았습니다}0'
# 'exe called with module IR after each pass that changes it'
H9DCF33C92D4F: 'exe는 각 패스가 이를 변경한 후 모듈 IR과 함께 호출됩니다'
# 'execute only is not supported for the %0 sub-architecture'
H355C6C44365F: '실행 전용은 %0 하위 아키텍처에서 지원되지 않습니다.'
# 'existing instance variable %1 for __weak property %0 must be __weak'
HBE1A4247ED95: '기존의 인스턴스 변수 %1은 __weak 프로퍼티 %0이므로 __weak여야 합니다'
# 'existing instance variable %1 for property %0 with %select{unsafe_unretained|assign}2 attribute must be __unsafe_unretained'
H45768C1508E1: '속성 %0에 대한 기존 인스턴스 변수 %1은 %select{unsafe_unretained|assign}2 속성으로 지정되어야 __unsafe_unretained여야 합니다'
# 'existing instance variable %1 for strong property %0 may not be %select{|__unsafe_unretained||__weak}2'
H98A6ABD1A54E: '강한 속성 %0의 기존 인스턴스 변수 %1는 %select{|__unsafe_unretained||__weak}2로 지정될 수 없습니다'
# 'existing instance variable %1 for strong property %0 may not be __weak'
HD554DEC7881B: '강한 속성 %0에 대한 기존 인스턴스 변수 %1은 __weak일 수 없습니다'
# 'exit after writing aggregated data file'
H8BF29D13B0F2: '집계 데이터 파일을 작성한 후 종료'
# 'expanding this definition of %0'
H5BA1B50B21D1: '이 %0의 정의를 확장 중입니다'
# 'expansion of date or time macro is not reproducible'
H816E771096AD: '날짜 또는 시간 매크로의 확장은 재현되지 않습니다'
# 'expansion of macro %0 requested here'
H97F2144252C9: '마크로 %0의 확장이 여기서 요청되었습니다'
# "expansion of predefined identifier '%0' to a string literal is a Microsoft extension"
H89888E84B8EB: "미리 정의된 식별자 '%0'을(를) 문자열 리터럴로 확장하는 것은 Microsoft 확장 기능입니다"
# 'expected "FILENAME" or <FILENAME>'
H6038B7E6D091: '“FILENAME” 또는 <FILENAME>이 예상됩니다'
# "expected #pragma pack parameter to be '1', '2', '4', '8', or '16'"
HA00C06644234: "#pragma pack 매개변수가 '1', '2', '4', '8', 또는 '16'이어야 합니다."
# 'expected %0'
H1C2353E37609: '%0가 필요합니다'
# 'expected %0 at end of module'
H0F6B0905AE5F: '모듈의 끝에 %0가 필요합니다'
# "expected %0 in OpenMP clause '%1'"
HC79E103ACDFE: "OpenMP 절 '%1'에서 %0을 기대했습니다."
# 'expected %0 or %1'
HC08F459555DA: '예상되는 %0 또는 %1'
# 'expected %0 to denote end of parameters, or, another valid parameter of %1'
H05DB43940E29: '%0가 매개변수 끝을 나타내거나 %1의 다른 유효한 매개변수를 기대했습니다'
# 'expected %0; %1 is a keyword in Objective-C++'
H62A445966708: '예상되지 %0; %1은 Objective-C++의 예약어입니다'
# 'expected %1 after %0'
H5879CE8F4818: 'after %0 뒤에 %1이 예상되었습니다.'
# "expected %select{'enable', 'disable', 'begin' or 'end'|'disable'}0 - ignoring"
H1B18CF6CA096: "예상되지 않은 %select{'enable', 'disable', 'begin' 또는 'end'|'disable'}0 - 무시됨"
# "expected %select{'match'|'match', 'adjust_args', or 'append_args'}0 clause on 'omp declare variant' directive"
HED7B3D66D419: "'omp declare variant' 지시문에 'match', 'adjust_args', 또는 'append_args' %select{중 하나|}0 절이 필요합니다"
# "expected %select{'val' modifier|one of 'ref', val' or 'uval' modifiers}0"
HCC26F8F297FB: "예상되지 않은 %select{'val' 수정자|'ref', 'val' 또는 'uval' 수정자 중 하나}0"
# 'expected %select{assignment|assignment, compound assignment, increment, or decrement}0 expression'
H2BC7EE32B904: '%select{할당|할당, 복합 할당, 증가, 또는 감소}0 표현식이 필요합니다'
# "expected %select{identifier after '.' in |}0module name"
HF095089F6D4D: "필요한 %select{마침표 '.' 이후 식별자|}0모듈 이름"
# 'expected %select{identifier|unqualified-id}0'
HC1969BE019B7: '예상되지 않은 %select{식별자|비정격화된-식별자}0'
# 'expected %select{library|framework}0 name as a string'
H5FD987168935: '예상되는 %select{library|framework}0 이름을 문자열로 지정해야 합니다'
# "expected %select{module exclusion with 'exclude'|'export *'}0"
H4175E9BAE37D: "예상되지 않음 %select{exclude를 사용한 모듈 제외|'export *'}0"
# "expected '#pragma omp end declare %select{target|variant}0'"
H7B3C6216417A: "'#pragma omp end declare' 지시문에 %select{target|variant}0이 기대됩니다"
# "expected '#pragma omp end declare target' at end of file to match '#pragma omp %0'"
H25BEC71CAA92: "파일 끝에서 '#pragma omp end declare target'이 기대되었으나 '#pragma omp %0'과 일치하지 않습니다."
# "expected '#pragma unused' argument to be a variable name"
HE4429A749432: "'#pragma unused' 인수는 변수 이름이어야 합니다"
# "expected '%0' after the %1; '%0' assumed"
HB08F71D9B939: "예상되는 '%0'가 %1 이후에 없습니다; '%0'가 생략되었다고 가정합니다"
# "expected '%0' clause with an argument on '#pragma omp %1' construct"
HA803E7993B4F: "'#pragma omp %1' 구조에 '%0' 절이 인수를 가질 것을 기대했습니다"
# "expected '(' after '%0'"
HA365863454FD: '“%0” 이후에 “(”가 기대되었습니다.'
# "expected '(' for function-style cast or type construction"
H95D0E6661AB2: "함수 스타일 캐스트나 타입 생성을 위해 '('가 필요합니다"
# "expected ')' after '%0'"
H068274655B04: "후 '%0'에 ')'가 기대됩니다"
# "expected ')' in preprocessor expression"
H9FA29BAED1EF: "프리프로세서 표현에서 ')'가 예상되지 않았습니다"
# "expected ')' or ',' after '%0'"
HD115318388CA: "'%0' 뒤에 ')' 또는 ','가 기대되었습니다"
# "expected ')' or ',' in '#pragma %0'"
H97FBD869E75F: " '#pragma %0' 내에서 ')' 또는 ','가 예상됩니다."
# "expected '+' or '-' operation"
H193C159A95C7: "'+' 또는 '-' 연산자를 기대했습니다"
# "expected ',' after conflicting module name"
H307B5FE6EEA1: "충돌하는 모듈 이름 다음에 ','가 필요합니다"
# "expected ',' after interop modifier"
HBE15766F267C: "interop modifier 이후에 ','가 필요합니다."
# "expected ',' in '#pragma %0'"
H80B3D004C35A: "#pragma %0 내에서 ','가 필요합니다."
# "expected ',' or ')' after iterator specifier"
H5B885E53A966: "반복자 지정자 뒤에 ',' 또는 ')'가 예상되었습니다"
# "expected ',' or ')' at end of property accessor list"
H90761748BDB7: "속성 접근자 목록의 끝에서 ',' 또는 ')'가 필요합니다"
# "expected ',' or ')' in '%0' %select{clause|directive}1"
H27E43F9D4E4C: '‘%0’ %select{구문|지시어}1에서 ‘,’ 또는 ‘)’가 필요합니다.'
# "expected ',' or '>' in template-parameter-list"
HE6FA48C9A81A: "템플릿 매개변수 목록에서 ',' 또는 '>'가 기대됩니다"
# "expected ',' or ']' in lambda capture list"
H01C14BB9E6E5: "lambda 캡처 목록에서 ',' 또는 ']'가 예상됩니다"
# "expected '->' before expression type requirement"
H25053402E92B: "표현식 유형 요구 사항 이전에 '->'가 예상되었습니다"
# "expected '.' after pragma attribute namespace %0"
H6D0DBF9112AD: "pragma attribute namespace %0 뒤에 '.'가 필요합니다."
# "expected '::' after '__super'"
HFBD8EE4CC424: "'__super' 이후에 '::'이 예상됩니다."
# "expected ';' after %0 statement"
H26F61B7787AD: "%0 문장 뒤에 ';'이(가) 예상되었습니다."
# "expected ';' after '%0'"
HC22BB7A01636: "';'가 '%0' 뒤에 있어야 합니다."
# "expected ';' after attribute list"
HC367299E9BFD: "속성 목록 뒤에 ';'가 필요합니다"
# "expected ';' after expression"
H26209FD52998: "표현식 뒤에 ';'가 필요합니다."
# "expected ';' after method prototype"
H4DCD5C7E2BCB: "메소드 프로토타입 후에 ';'가 예상됩니다"
# "expected ';' after module name"
H20B27913626E: "모듈 이름 뒤에 ';'가 필요합니다"
# "expected ';' after namespace name"
HAAD5C65924B6: "네임스페이스 이름 다음에 ';'가 예상됩니다"
# "expected ';' after private module fragment declaration"
H868380AB5A37: "private 모듈 프래그먼트 선언 후 ';'가 예상됩니다."
# "expected ';' after top level declarator"
H3A247DA7CE56: "최상위 선언자 다음에 ';'가 필요합니다"
# "expected ';' at end of declaration"
HA8E976B320DC: "선언의 끝에서 ';' 기대되었습니다"
# "expected ';' at end of declaration list"
HA684210D419F: "선언 목록의 끝에서 ';'가 예상됩니다"
# "expected ';' at end of requirement"
HDCCCFEC70AB1: "요구사항의 끝에 ';'가 필요합니다"
# "expected ';' in 'for' statement specifier"
H2C47358FD75D: "for 문의 지정자에서 ';'가 예상됩니다"
# "expected '<' after '%0'"
H1010291C9C7B: "“%0” 뒤에 '<'가 필요합니다"
# "expected '= constant-expression' or end of enumerator definition"
H01AC9A3D13F6: "'= 상수 표현식' 또는 열거자 정의의 끝을 기대합니다."
# "expected '=' after '%0'"
H46EA9025A033: "‘%0’ 뒤에 '='가 필요합니다"
# "expected '=' after diagnostic option"
HEF7733E47109: "진단 옵션 뒤에 '='가 기대됩니다"
# "expected '=' following '#pragma %select{align|options align}0' - ignored"
HCE08A9B54E2F: ",'#pragma %select{align|options align}0' 이후에 '='가 필요하지만 무시되었습니다"
# "expected '=' following '#pragma clang section %select{invalid|bss|data|rodata|text|relro}0'"
H5BC8FFE8057E: "'#pragma clang section %select{invalid|bss|data|rodata|text|relro}0' 뒤에 '='가 기대됩니다"
# "expected '=' for Objective-C getter"
H60371309B60A: "Objective-C 접근자(getter)에 대해 '='가 필요합니다."
# "expected '=' for Objective-C setter"
H8ACB8C307A32: "Objective-C 세터에서 '='가 기대됩니다"
# "expected '=' in iterator specifier"
H160A5CC58E68: "iterator specifier에서 '='가 필요합니다"
# "expected '=' or another designator"
H0EFFC0B249A7: "('=') 또는 다른 지정자가 필요합니다"
# "expected '==' operator for 'weak' clause"
H3CB2580D57FE: "weak 절에 '==' 연산자가 필요합니다"
# "expected 'ON' or 'OFF' or 'DEFAULT' in pragma"
HE0167BADEC73: "pragma에서 'ON' 또는 'OFF' 또는 'DEFAULT'를 예상했지만 찾을 수 없습니다"
# "expected ']' to close attribute"
H21FBE19AC5CE: "특성을 닫기 위해 ']'가 예상됩니다."
# "expected '__except' or '__finally' block"
HF5A94EBD6434: '‘__except’ 또는 ‘__finally’ 블록이 필요합니다'
# "expected 'align' following '#pragma options' - ignored"
H851698FD662C: "#pragma options 뒤에 'align'이 예상되었습니다 - 무시되었습니다"
# "expected 'auto' or 'decltype(auto)' after concept name"
H0C6E25C16A3C: "개념 이름 이후에 'auto' 또는 'decltype(auto)'가 예상됩니다"
# "expected 'begin' or 'end'"
HE7122B95D2E3: "예상되는 'begin' 또는 'end'"
# "expected 'bind' clause for 'loop' construct without an enclosing OpenMP construct"
H5C3B8520C88C: "포함되는 OpenMP 구조가 없는 'loop' 구조에 'bind' 절이 필요합니다."
# "expected 'case' keyword before expression"
H2E3235608C64: "표현식 앞에 'case' 키워드가 예상됩니다"
# "expected 'compare' clause with the '%0' modifier"
H19AACB74DA99: "비교 절에 '%0' 수정자가 필요합니다"
# "expected 'compiler', 'lib', 'user', or a string literal for the section name in '#pragma %0' - ignored"
H516A6D363B4D: "#pragma %0의 섹션 이름으로 'compiler', 'lib', 'user' 또는 문자열 리터럴이 예상됩니다. 무시됨"
# "expected 'get' or 'put' in property declaration"
HB1588A447E94: "프로퍼티 선언에서 'get' 또는 'put'이 예상됩니다."
# "expected 'introduced', 'deprecated', or 'obsoleted'"
HA5AD3805D7B0: "필요로 하는 '추가됨', '우려됨', 또는 '과시됨'"
# "expected 'language', 'defined_in', 'generated_declaration', or 'USR'"
HC6089B1E2A7C: "예상되는 'language', 'defined_in', 'generated_declaration', 또는 'USR'이어야 합니다"
# "expected 'push', 'pop', or '(' after '#pragma clang attribute'"
H6F226585166A: "#pragma clang attribute 뒤에 'push', 'pop', 또는 '('가 필요합니다."
# "expected 'reduction' clause with the 'inscan' modifier"
H2220AF809CD1: "reduction 절이 'inscan' 수정자와 함께 필요합니다"
# "expected 'this' following '*' in lambda capture list"
HAD95524E40D1: "람다 캡처 목록에서 '*' 다음에 'this'가 필요합니다"
# "expected 'this' subscript expression on map clause to be 'this[0]'"
HC4A77B8603BE: "map 절에서 'this' 인덱싱 표현식은 'this[0]'이어야 합니다."
# "expected 'volatile', 'inline', 'goto', or '('"
H4AA4A0DEF946: '‘volatile’, ‘inline’, ‘goto’ 또는 ‘(’가 필요합니다.'
# "expected 'while' in do/while loop"
H93A6CFE12887: "do/while 루프에서 'while'을 기대했습니다"
# "expected '{' after '\\%0' escape sequence"
H8BB332D21D67: "에스케이프 시퀀스 '\\%0' 이후에 '{'가 예상됩니다"
# "expected '{' after base class list"
HF135F437918B: "기반 클래스 목록 이후에 '{'가 필요합니다"
# "expected '{' in compound literal"
H19B6D0E23043: "복합 리터럴 내에서 '{'가 예상됩니다"
# "expected '{' to start inferred submodule"
H195C51C6292B: "추론된 하위 모듈을 시작하기 위해 '{'가 필요합니다."
# "expected '{' to start module '%0'"
H68A4A0E12840: "모듈 '%0'을 시작하기 위해 '{'가 기대되었습니다."
# "expected '}'"
HC6CF963022AD: "'}'가 기대되었습니다"
# 'expected HLSL Semantic identifier'
H26323C15C7D3: 'HLSL 세미어니티 식별자 기대됨'
# 'expected OpenACC directive'
HC6E13DDCDF20: 'OpenACC 지시문이 예상되었습니다.'
# "expected a 'float', 'double' or '__float128' for the first argument"
H4A7F993B766C: "첫 번째 인수에는 'float', 'double' 또는 '__float128'이 예상됩니다"
# 'expected a callable expression as %ordinal0 argument to %1, found %2'
H9D110F1CBE18: '호출 가능한 표현식을 %1의 %ordinal0 번째 인자로 예상했지만 %2를 발견했습니다'
# 'expected a clang compiler command'
HFF7E5AC24A63: 'clang 컴파일러 명령어가 필요합니다'
# "expected a class method selector with single argument, e.g., 'colorWithCGColor:'"
H747F5E4807D4: "클래스 메서드 선택자를 단일 인수와 함께 예상했습니다. 예: 'colorWithCGColor:'"
# "expected a class name after '~' to name a destructor"
H0B5DBF4FC4A5: "소멸자를 정의하려면 '~' 뒤에 클래스 이름이 필요합니다"
# 'expected a feature name'
H83F9EEF32768: '특징 이름이 필요합니다'
# "expected a field designator, such as '.field = 4'"
HE811DCDC9E5C: '필드 지정자(예: .field = 4)가 필요합니다'
# 'expected a foldable binary operator in fold expression'
H442801240371: '폴드 표현식에서 폴드 가능한 이항 연산자를 기대했습니다'
# "expected a for, while, or do-while loop to follow '%0'"
H6905E348753C: "for, while 또는 do-while 루프가 '%0' 뒤에 필요합니다."
# "expected a header attribute name ('size' or 'mtime')"
H7FCC0389B837: "헤더 속성 이름이 필요합니다 ('size' 또는 'mtime')"
# "expected a header name after '%0'"
HC5548A9AEA32: "뒤에 헤더 이름이 필요합니다 '%0'"
# 'expected a memory order clause'
H8A1509342CF4: '메모리 오더 절이 필요합니다'
# "expected a message describing the conflict with '%0'"
H3712B62CAC8D: '‘%0’과의 충돌을 설명하는 메시지가 필요합니다'
# 'expected a module map file name'
H34A1748EFBBA: '모듈 맵 파일 이름이 필요합니다'
# "expected a module name after '%select{module|import}0'"
H60B4E74C4DAA: "모듈 이름이 '%select{module|import}0' 뒤에 필요합니다."
# "expected a module name in '__building_module' expression"
H3E7D4309A80A: "'__building_module' 표현식에서 모듈 이름이 예상되었습니다"
# "expected a module name or '*'"
HA872E74CF2C8: "모듈 이름 또는 '*'을 기대합니다"
# 'expected a platform name here'
HB3E385166F04: '여기에는 플랫폼 이름이 필요합니다'
# "expected a platform name, e.g., 'macos'"
H451496142CA8: "플랫폼 이름이 예상됩니다. 예: 'macos'"
# 'expected a property name in @synthesize'
HFCD01091BCD1: 'synthesize 구문 내에서 속성 이름이 예상되었습니다'
# "expected a qualified name after 'typename'"
H3D60DB7C4A2E: "'typename' 이후에 격리된 이름이 필요합니다"
# "expected a reference to a parameter specified in a 'uniform' clause"
HE4C3AD103D8E: 'uniform 절에 지정된 매개변수에 대한 참조가 예상됩니다'
# 'expected a reference to an integer-typed parameter'
HD574D7423FC7: '정수 형식 매개변수에 대한 참조가 필요합니다'
# "expected a related Objective-C class name, e.g., 'NSColor'"
H1B15D42F8530: "관련된 Objective-C 클래스 이름이 필요합니다. 예를 들어 'NSColor'와 같은 형식입니다."
# "expected a stack label or a string literal for the section name in '#pragma %0' - ignored"
HC98188AB663C: "'#pragma %0' 지시문에서 섹션 이름을 위해 스택 라벨 또는 문자열 리터럴이 필요합니다 - 무시됨"
# "expected a string literal for the section name in '#pragma %0' - ignored"
HE785ABE9BD3E: '#pragma %0의 섹션 이름에 문자열 리터럴이 필요합니다 - 무시됨'
# 'expected a type'
HBF18848DB5D9: '타입이 예상되었습니다.'
# "expected a version of the form 'major[.minor[.subminor]]'"
HD227DA64159B: "지정된 형식의 버전이 필요합니다: 'major[.minor[.subminor]]'"
# 'expected access to data field'
HB984B4DED1F3: '데이터 필드에 대한 접근이 필요합니다'
# "expected action or ')' in '#pragma %0' - ignored"
HA826DA8C7E15: "#pragma %0 내에서 작업 또는 ')'가 예상되었습니다 - 무시됨"
# "expected addressable lvalue expression, array element%select{ or array section|, array section or array shaping expression}0%select{| of non 'omp_depend_t' type}1"
H064E98F2C05F: "주소 가능 lvalue 표현, array 요소%select{ 또는 array 섹션|, array 섹션 또는 array shaping 표현}0%select{|의 non 'omp_depend_t' 형식}1이 필요합니다."
# "expected addressable lvalue in '%0' clause"
H5CFFB735C83B: '‘%0’ 절에서 주소 가능 lvalue가 필요합니다'
# 'expected addressable reduction item for the task-based directives'
H317F6E6ED5F4: '작업 기반 지시문에 대한 주소 가능 감소 항목이 필요합니다'
# "expected an 'allocator' clause inside of the target region; provide an 'allocator' clause or use 'requires' directive with the 'dynamic_allocators' clause"
H22C155652414: "타겟 영역 내에서 'allocator' 절이 필요합니다; 'allocator' 절을 제공하거나 'requires' 지시어와 함께 'dynamic_allocators' 절을 사용하세요."
# "expected an Objective-C directive after '@'"
H89CC9A1752F3: "'@' 이후에 Objective-C 지시문을 기대했습니다."
# "expected an OpenMP 'directive' or 'sequence' attribute argument"
HB4C47A9C1389: "OpenMP 'directive' 또는 'sequence' 속성 인수가 필요합니다"
# 'expected an OpenMP directive'
H633B99B897DC: 'OpenMP 디렉티브가 예상되었습니다'
# "expected an allocator expression inside of the target region; provide an allocator expression or use 'requires' directive with the 'dynamic_allocators' clause"
H3E40EF451DD7: "타겟 영역 내부에서 할location 표현식이 기대되지 않았습니다; 할location 표현식을 제공하거나 'requires' 지시문에 'dynamic_allocators' 절을 사용하세요"
# "expected an attribute after '('"
H1D3F08841FED: "괄호 '(' 다음에 속성이 예상되었습니다"
# 'expected an attribute name'
HD93294E62460: '특성 이름이 기대되었습니다'
# "expected an attribute that is specified using the GNU, C++11 or '__declspec' syntax"
H022D0FCF0401: "GNU, C++11 또는 '__declspec' 구문을 사용하여 지정된 속성이 필요합니다"
# "expected an environment name, e.g., 'compute'"
HFC224EAC2A19: "환경 이름이 필요합니다 (예: 'compute')"
# "expected an identifier or template-id after '::'"
H640FB5DADE2C: " '::' 뒤에 식별자 또는 템플릿-id가 필요합니다."
# "expected an identifier that corresponds to an attribute subject matcher sub-rule; '%0' matcher %select{does not support sub-rules|supports the following sub-rules: %2|}1"
H9C057C572CE2: "특성 대상 매처 하위 규칙에 해당하는 식별자를 기대했습니다; '%0' 매처 %select{하위 규칙을 지원하지 않습니다|다음 하위 규칙을 지원합니다: %2|}1"
# 'expected an identifier that corresponds to an attribute subject rule'
H294E4D252009: '특성 주체 규칙에 해당하는 식별자가 예상됩니다'
# "expected an integer argument in '#pragma %0'"
H8B88B2FBB6B4: "'#pragma %0'에서 정수 인수가 필요합니다."
# "expected an integer or a pointer type of the outer loop counter '%0' for non-rectangular nests"
H7B769AB4785B: "비직사각형 네스트에 대해 외부 루프 카운터 '%0'의 정수형 또는 포인터 유형이 필요합니다"
# "expected at least one %0 clause for '#pragma omp %1'"
H7235197EF029: '#pragma omp %1에 %0 절이 적어도 하나 이상 있어야 합니다'
# "expected at least one %select{'enter' or 'link'|'enter', 'link' or 'indirect'}0 clause"
H068B5F15FD0D: "최소 하나 이상의 %select{'enter' 또는 'link'|'enter', 'link' 또는 'indirect'}0 절이 필요합니다"
# "expected at least one %select{'to' or 'link'|'to', 'link' or 'indirect'}0 clause"
HCCB831884601: "최소 하나의 %select{'to 또는 link'|'to', 'link 또는 indirect'}0 절이 필요합니다"
# "expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'"
HD1F834BB93F7: "'#pragma omp target update'에 적어도 하나의 'to' 절이나 'from' 절이 지정되어야 합니다"
# "expected at least one clause on '#pragma omp %0' directive"
HF2F95AA7B57B: "'#pragma omp %0' 지시문에서 최소한 하나의 절이 필요합니다"
# "expected attribute subject set specifier 'apply_to'"
H235FBF52B9D6: "속성 대상 집합 지정자 'apply_to'가 예상되었습니다."
# 'expected binary operation on right hand side of assignment operator'
H56333C6C1143: '할당 연산자의 오른쪽에는 이항 연산이 필요합니다'
# 'expected body of lambda expression'
HD20C4511EEC4: '람다 표현식 본문이 기대됩니다'
# "expected canonical name for private module '%0'"
H1D8AC0E6D7DF: "private 모듈 '%0'에 대한 정규 이름이 기대됩니다."
# 'expected catch'
H0CF63E912EE1: 'catch가 필요합니다'
# 'expected class member or base class name'
H3D5CC6CC3E58: '클래스 멤버 또는 기반 클래스 이름이 기대됩니다'
# 'expected class name'
HE76725D4157E: '클래스 이름이 필요합니다.'
# 'expected clause-list or newline in OpenACC directive'
H545847ADF7FD: 'OpenACC 지시문에서 clause-list 또는 줄바꿈이 예상되었습니다'
# 'expected comma in macro parameter list'
HDA341FE611DA: '매크로 매개변수 목록에서 쉼표가 예상됩니다'
# 'expected concept name with optional arguments'
H5D07B2CBA3F4: '선택적 인수를 가진 concept 이름이 필요합니다'
# "expected configuration macro name after ','"
HAB95DA27DF2F: '쉼표(,) 이후 구성 매크로 이름이 필요합니다'
# "expected constant sized array of 'omp_alloctrait_t' elements, not %0"
H05FAEDD71E4D: "상수 크기의 'omp_alloctrait_t' 요소 배열을 기대했습니다. %0가 아닙니다"
# "expected declarator on 'omp declare mapper' directive"
HB22F9750894D: 'omp declare mapper 지시문에서 declarator가 기대되었습니다'
# 'expected depobj expression'
HE3D01E0D4DF5: '의존 객체 표현식이 예상됩니다'
# 'expected end of directive in pragma'
HCC93595992BD: 'pragma 내에서 디렉티브의 끝이 예상되었습니다'
# 'expected end of line in preprocessor expression'
HD41DF7404CF0: '프리프로세서 표현식에서 줄 끝이 예상되었습니다'
# 'expected excluded module name'
H6CF70735EF8C: '제외된 모듈 이름이 필요합니다'
# 'expected expression'
HF6BF3F627CA1: '식이 필요합니다.'
# 'expected expression containing only member accesses and/or array sections based on named variables'
HB19E72D8D293: '이름이 지정된 변수를 기반으로 한 멤버 접근 및/또는 배열 접근만을 포함한 식이 예상됩니다'
# 'expected expression with a pointer to a complete type as a base of an array shaping operation'
HB89169C408E0: '배열 성형 연산의 기반으로 완전한 타입의 포인터를 갖는 표현식이 예상됩니다'
# 'expected external declaration'
HC14A3D6A28C9: '외부 선언을 기대했습니다'
# 'expected function body after function declarator'
HF961A21CDC61: '함수 선언자 뒤에 함수 본문이 필요합니다'
# "expected function or lambda declaration for 'routine' construct"
H6E72FAB495F6: "함수 또는 람다 선언이 필요합니다: 'routine' 구조를 위해"
# "expected identifier in '#pragma %0' - ignored"
H05B1FBF9EBC9: '#pragma %0에서 식별자를 기대했지만, 무시합니다'
# 'expected identifier in macro parameter list'
H94E463CD5EE5: '매크로 매개변수 목록에서 식별자가 예상됩니다'
# "expected identifier or one of the following operators: '+', '-', '*', '&', '|', '^', '&&', or '||'"
H7E170CC2FF20: "예상되는 식별자 또는 다음 연산자 중 하나: '+', '-', '*', '&', '|', '^', '&&', 또는 '||'"
# 'expected identifier or string literal describing a context %select{set|selector|property}0; %select{set|selector|property}0 skipped'
HE89AF4D1E70E: '컨텍스트 %select{세트|셀렉터|프로퍼티}0를 설명하는 식별자 또는 문자열 리터럴이 필요합니다; %select{세트|셀렉터|프로퍼티}0가 건너뛰어졌습니다'
# "expected identifier or string literal in OpenACC 'bind' clause"
H5985E2854824: "OpenACC 'bind' 절에서 식별자 또는 문자열 리터럴이 예상됨"
# "expected identifier specifying the name of the 'omp critical' directive"
HDAF324FC0746: 'omp critical 지시문의 이름을 지정하는 식별자가 필요합니다'
# 'expected identifier that represents an attribute name'
H4FF5B028471D: '속성 이름을 나타내는 식별자가 필요합니다'
# 'expected initializer'
HC06E564F6549: '초기화자가 필요합니다'
# "expected integer between %0 and %1 inclusive in '#pragma %2' - ignored"
HD3B45551DCCD: "'#pragma %2'에서 %0과 %1 사이의 정수를 기대했으나 무시됨"
# "expected integer literal as value for header attribute '%0'"
H664A6DF4E15C: "헤더 속성 '%0'의 값으로 정수 리터럴이 필요합니다"
# "expected integer or identifier in '#pragma pack' - ignored"
H76DF3F452A3B: "'#pragma pack'에서 정수 또는 식별자를 기대했으나 없어 무시됨"
# 'expected integral or pointer type as the iterator-type, not %0'
H630D7FF60D9F: '반복자 유형으로 정수형 또는 포인터 유형이 필요하지만 %0는 아닙니다'
# "expected interop type: 'target' and/or 'targetsync'"
H4B471B15641F: "예상되는 인터옵 타입: 'target'과/또는 'targetsync'"
# 'expected iterator specification as depend modifier'
HDCFF4384248D: '의존 수정자로 반복자 지정이 필요합니다'
# 'expected iterator specification as map modifier'
H1207336B4021: '맵 수정자로 반복자 지정이 필요합니다'
# "expected length on mapping of 'this' array section expression to be '1'"
HAB830A5B0BE8: "'this' array 섹션 표현식의 매핑에서 예상된 길이가 '1'이어야 합니다."
# "expected list item of scalar type in 'lastprivate' clause with 'conditional' modifier"
HA9ADDE114CE9: 'lastprivate 절에 conditional 수정자를 사용할 때 스칼라 타입의 리스트 항목이 필요합니다'
# 'expected loop invariant expression'
H5CDAE0534BDA: '루프 불변식 표현이 필요합니다'
# "expected loop invariant expression or '<invariant1> * %0 + <invariant2>' kind of expression"
HB9C142C1B0A5: "루프 불변 표현식 또는 '<invariant1> * %0 + <invariant2>' 형식의 표현식이 필요합니다."
# "expected lower bound on mapping of 'this' array section expression to be '0' or not specified"
H191C7ACE16C2: "이 배열 섹션 표현식의 매핑에 대한 하한이 '0'이거나 지정되지 않았어야 합니다."
# "expected lvalue expression%select{ of 'omp_depend_t' type, not %1|}0"
H766F59D547C6: '왼쪽 값 표현식(lvalue expression)이 필요합니다%select{ omp_depend_t 형식이어야 하는데 %1이 아닙니다|}0'
# "expected member name or ';' after declaration specifiers"
HB82CEE80D58C: "선언 지정자 뒤에 멤버 이름이나 ';'가 예상됩니다"
# "expected member name or ';' after declaration specifiers; %0 is a keyword in Objective-C++"
H44CFB0200081: "선언 지정자 이후에 멤버 이름이나 ';'가 예상됩니다; %0는 Objective-C++에서의 키워드입니다"
# 'expected method body'
HA77E865AEFEF: '메서드 본문이 필요합니다'
# 'expected method to %select{read|write}1 %select{dictionary|array}2 element not found on object of type %0'
H7AD9AA6CC51A: '타입 %0의 객체에 %select{읽기|쓰기}1 %select{딕셔너리|어레이}2 요소를 찾을 수 없습니다'
# "expected modifier in '%0' clause"
HCD7B280DF3B2: "'%0' 절에서 수정자를 기대했습니다."
# 'expected module declaration'
H01C99835EAB8: '모듈 선언이 예상됩니다'
# 'expected module name'
H1C43BA17D195: '모듈 이름이 예상됩니다'
# 'expected name of accessor method'
HC25216EA2EAE: '액세서 메서드의 이름이 예상됩니다'
# 'expected namespace name'
H4C29A4057DC9: '예상된 네임스페이스 이름이 필요합니다'
# "expected non-wide string literal in '#pragma %0'"
H47A50F5F135C: "'#pragma %0'에서 예상되는 너비 없는 문자열 리터럴이 없습니다"
# "expected one of [bss|data|rodata|text|relro] section kind in '#pragma %0'"
HD85488A58A29: "다음 섹션 유형 중 하나가 '#pragma %0' 내에서 필요합니다: [bss|data|rodata|text|relro]"
# "expected one of the predefined allocators for the variables with the static storage: 'omp_default_mem_alloc', 'omp_large_cap_mem_alloc', 'omp_const_mem_alloc', 'omp_high_bw_mem_alloc', 'omp_low_lat_mem_alloc', 'omp_cgroup_mem_alloc', 'omp_pteam_mem_alloc' or 'omp_thread_mem_alloc'"
H8611A8451129: "정적 저장소를 가진 변수에 대한 사전 정의된 할당자 중 하나가 예상됩니다: 'omp_default_mem_alloc', 'omp_large_cap_mem_alloc', 'omp_const_mem_alloc', 'omp_high_bw_mem_alloc', 'omp_low_lat_mem_alloc', 'omp_cgroup_mem_alloc', 'omp_pteam_mem_alloc' 또는 'omp_thread_mem_alloc'"
# 'expected parameter declarator'
HE400FE627646: '파라미터 선언자가 필요합니다'
# 'expected parentheses around type name in %0 expression'
H29C3C3BEE053: '표현식에서 유형 이름 주위에 괄호가 필요합니다: %0'
# "expected parenthesized parameter pack name in 'sizeof...' expression"
H872448706A49: 'sizeof... 표현식 내에서 괄호로 감싸진 매개변수 팩 이름이 예상됩니다.'
# "expected pointer in '%0' clause, type is %1"
HA28C1D2864FB: "'%0' 절에서 포인터가 필요합니다. 현재 유형은 %1입니다"
# "expected pointer or reference to pointer in 'use_device_ptr' clause"
H8CE170DA7DFD: "'use_device_ptr' 절에서 포인터 또는 포인터의 참조가 필요합니다."
# 'expected pointer to struct as %ordinal0 argument to %1, found %2'
H2E1D0CCC5B02: '구조체 포인터가 %1의 %ordinal0 번째 인자로 예상되나, %2가 발견되었습니다.'
# "expected pointer, array, reference to pointer, or reference to array in 'is_device_ptr clause'"
H529E9DB350DF: "'is_device_ptr 절'에서 포인터, 배열, 포인터 참조 또는 배열 참조가 필요합니다"
# 'expected property name'
H849B19CD5A49: '속성 이름이 예상되지만'
# "expected push, pop or a string literal for the section name in '#pragma %0' - ignored"
H4F1921BA3641: "'#pragma %0'의 섹션 이름에 push, pop 또는 문자열 리터럴이 기대되었습니다 - 무시됨"
# 'expected quoted string after equals sign'
H2D60229D01D0: '등호 (=) 뒤에 쌍따옴표로 감싸인 문자열이 예상됩니다'
# "expected reference to one of the parameters of function %0%select{| or 'this'}1"
HD78611AD5D12: "함수 %0%select{| 또는 'this'}1의 매개변수 중 하나에 대한 참조가 필요합니다"
# 'expected selector for Objective-C %select{setter|getter}0'
HFB2F00048645: 'Objective-C에 대한 %select{setter|getter}0 선택자를 기대했습니다'
# 'expected selector for Objective-C method'
HC4CCDD47D676: 'Objective-C 메서드에 대한 선택자를 기대했습니다'
# 'expected statement'
HFEEF58AA5565: '문장이 필요합니다.'
# "expected string literal %select{in %1|for diagnostic message in static_assert|for optional message in 'availability' attribute|for %select{language name|source container name|USR}1 in 'external_source_symbol' attribute|as argument of '%1' attribute}0"
HD61709E5D47F: "문자열 리터럴이 예상되었습니다 %select{in %1|static_assert의 진단 메시지에 대한|'availability' 속성의 선택적 메시지에 대한|%select{언어 이름|소스 컨테이너 이름|USR}1 in 'external_source_symbol' attribute에 대한|'%1' 속성의 인자로}0"
# "expected string literal %select{or parenthesized constant expression |}0in 'asm'"
H87FD9C867F0C: "문자열 리터럴 %select{또는 괄호로 감싸인 상수 표현식 |}0을 'asm'에서 기대했습니다."
# "expected string literal in '#pragma %0' - ignoring"
H0A31A7BE2E40: "'#pragma %0' 내에서 문자열 리터럴이 예상되었으나 누락됨 - 무시함"
# "expected string literal in 'clause %0' - ignoring"
H25BCA649E0CB: "문자열 리터럴이 필요합니다. '%0' 절에서 무시합니다."
# 'expected template'
H15B15916EEBA: '템플릿을 기대했는데'
# "expected template name after 'template' keyword in nested name specifier"
H49E8E5AAE6BB: "내포된 이름 지정자 내에서 'template' 키워드 다음에 템플릿 이름이 필요합니다."
# 'expected template parameter'
H112129FF4EB6: '템플릿 매개변수가 필요합니다'
# "expected the class name after '~' to name the enclosing class"
HD0B1F9262E8D: "클래스 이름이 '~' 뒤에 외부 클래스를 지칭해야 합니다"
# 'expected the name of a parameter pack'
H259207509382: '매개변수 패키지의 이름이 필요합니다'
# 'expected type parameter name'
H009E83554F48: '형식 매개변수 이름이 필요합니다'
# 'expected umbrella, header, submodule, or module export'
H13F866613F7D: 'umbrella, header, submodule 또는 module export를 예상했습니다'
# 'expected valid context selector in %0'
HF9402AD88CE1: '올바른 컨텍스트 선택자를 %0 내에서 기대했습니다.'
# 'expected value in expression'
HC052EF0BAA44: '표현식에서 값이 예상됩니다'
# 'expected variable name as a base of the array %select{subscript|section}0'
HBE410C345F41: '배열의 %select{인덱스|섹션}0 기반으로 변수 이름이 예상되었습니다'
# "expected variable name or 'this' in lambda capture list"
H9A94F049DF94: "lambda capture list에서 변수 이름 또는 'this'가 필요합니다"
# 'expected variable name%select{| or data member of current class}0'
H829F4F463842: '변수 이름%select{| 또는 현재 클래스의 데이터 멤버}0을 기대했지만'
# 'expected variable name%select{|, data member of current class}0, array element or array section'
HEAE159C816D1: '변수 이름%select{|, 현재 클래스의 데이터 멤버}0, 배열 요소 또는 배열 섹션이 필요합니다'
# 'expected variable of pointer type'
H396A94544855: '포인터 타입의 변수가 필요합니다'
# "expected variable of the '%0' type%select{|, not %2}1"
H3293A68C1535: "변수 '%0'의 타입%select{ |, %2가 아닙니다}1 것으로 예상되었습니다"
# "expected variable%select{| or static data member|, static data member, or non-static data member of current class}0 of type '%1'"
H54FC8A6038F8: "유형 '%1'의 변수%select{ | 또는 정적 데이터 멤버|, 정적 데이터 멤버 또는 현재 클래스의 비정적 데이터 멤버}0를 기대했지만"
# 'expected%select{| %1}0 loop iteration variable'
H9F489F0C181E: '기대되었습니다%select{| %1}0 루프 반복 변수'
# "expected%select{| non-const}0 variable of type 'omp_interop_t'"
H7FA31289BDF2: "필요한%select{| const가 아닌 }0 변수의 타입이 'omp_interop_t'여야 합니다"
# 'expected%select{| one of}0 %1 directive name modifier%select{|s}0'
HF9EF92E2746A: '기대했습니다%select{| 중 하나의}0 %1 디렉티브 이름 수정자%select{|s}0'
# "expecting %0 '%1' to be held at start of each loop%select{| with equal reentrancy depth}2"
HB151B2C16229: "%0 '%1'이(가) 각 루프 시작 시 유지되도록 예상됨%select{| 동일한 재진입 깊이를 가진}2"
# "expecting %0 '%1' to be held at the end of function"
H696ED076811B: "함수의 끝에서 %0 '%1'이 유지되기를 기대합니다"
# 'expecting a pointer argument to the generic address space'
HA58F994AB425: '일반 주소 공간에 대한 포인터 인수가 예상됨'
# 'explicit %select{constructor|conversion function|deduction guide}0 is not a candidate%select{| (explicit specifier evaluates to true)}1'
H1B61513FD8B6: 'explicit %select{생성자|변환 함수|추론 가이드}0은 후보가 아닙니다%select{| (explicit 지정자가 true로 평가됨)}1'
# 'explicit %select{constructor|deduction guide}0 declared here'
H110462FEE829: '명시적 %select{생성자|추론 안내}0 여기에 선언되었습니다'
# 'explicit %select{specialization|instantiation}0 of %select{non-|undeclared }3template %1 %2'
H3111D59957AC: '명시적인 %select{specialization|instantiation}0의 %select{비-|미선언된 }3template %1 %2'
# 'explicit call to +initialize results in duplicate call to +initialize'
H39AD5352EF13: '명시적 +initialize 호출은 +initialize에 대한 중복 호출을 일으킵니다.'
# 'explicit call to [super initialize] should only be in implementation of +initialize'
H9E99F53BFF8C: '[super initialize]의 명시적 호출은 +initialize의 구현체 내에서만 있을 수 있습니다.'
# "explicit capture of 'this' with a capture default of '=' is a C++20 extension"
HAF0F203BEF2F: "캡처 기본값이 '='일 때 'this'의 명시적 캡처는 C++20 확장 기능입니다"
# "explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++20"
H671AAB21DB7A: "포착 기본값이 '='인 경우 'this'의 명시적 포착은 C++20 이전의 C++ 표준과 호환되지 않습니다."
# 'explicit constructor calls are a Microsoft extension'
H07E486E825A8: '명시적 생성자 호출은 Microsoft 확장 기능입니다'
# 'explicit conversion functions are a C++11 extension'
H6D402C6A81B4: '명시적 변환 함수는 C++11 확장 기능입니다'
# 'explicit conversion functions are incompatible with C++98'
H325DB8CE82A7: '명시적 변환 함수는 C++98과 호환되지 않습니다.'
# 'explicit data sharing attribute requested here'
HC278594BF276: '명시적 데이터 공유 속성이 여기서 요청되었습니다'
# 'explicit data sharing attribute, data mapping attribute, or is_device_ptr clause requested here'
H5EF926721360: '명시적 데이터 공유 속성, 데이터 매핑 속성 또는 is_device_ptr 절이 여기에서 요청되었습니다'
# 'explicit initialization of field %1 will not be enforced in C++20 and later because %2 has a user-declared constructor, making the type no longer an aggregate'
HF3AC30340626: '필드 %1의 명시적 초기화는 %2에 사용자 선언된 생성자가 있어 해당 형식이 더 이상 집합체가 되지 않기 때문에 C++20 및 이후 버전에서는 더 이상 강제되지 않습니다'
# 'explicit instantiation candidate function %q0 template here %1'
H23B5BDCD19CC: '명시적 인스턴스화 후보 함수 %q0 템플릿 여기 %1'
# "explicit instantiation cannot be 'constexpr'"
H9A1E5AE786E4: "명시적 인스턴스화는 'constexpr'일 수 없습니다"
# "explicit instantiation cannot be 'inline'"
HD5DCEA693BA1: "명시적 인스턴스화는 'inline'일 수 없습니다."
# 'explicit instantiation cannot have a storage class'
H2C3AA857F69D: '명시적 인스턴스화는 저장 클래스를 가질 수 없습니다.'
# "explicit instantiation declaration (with 'extern') follows explicit instantiation definition (without 'extern')"
HB1AC2FFED2CF: '명시적 인스턴스화 선언(extern 사용)이 명시적 인스턴스화 정의(extern 미사용)에 이어出现了'
# 'explicit instantiation declaration of %0 with internal linkage'
HF062EFD01A1B: '명시적 인스턴스화 선언 %0의 내부 링크지로'
# 'explicit instantiation declaration requires a name'
HB6C2B5BBA7F4: '명시적 인스턴스화 선언은 이름이 필요합니다'
# "explicit instantiation declaration should not be 'dllexport'"
H2015D0FC9EDD: "명시적 인스턴스화 선언은 'dllexport'로 지정되어서는 안 됩니다."
# 'explicit instantiation definition is here'
H296BCB0F591A: '명시적 인스턴스화 정의는 여기에 있습니다'
# 'explicit instantiation has dependent template arguments'
H0CCD42687978: '명시적 인스턴스화에 종속 템플릿 인수가 있습니다'
# 'explicit instantiation of %0 does not refer to a function template, variable template, member function, member class, or static data member'
H33CB49EB02C6: '명시적 인스턴스화 %0는 함수 템플릿, 변수 템플릿, 멤버 함수, 멤버 클래스 또는 정적 데이터 멤버를 참조하지 않습니다'
# 'explicit instantiation of %0 in class scope'
HC730DBDD7AE4: '클래스 범위 내에서 %0의 명시적 인스턴스화'
# 'explicit instantiation of %0 must occur at global scope'
H0F240F08C055: '%0의 명시적 인스턴스화는 전역 범위에서 발생해야 합니다'
# 'explicit instantiation of %0 not in a namespace enclosing %1'
HE49D377AF72F: '명시적 인스턴스화 %0가 %1를 감싸는 네임스페이스 밖에 있습니다'
# 'explicit instantiation of %0 that occurs after an explicit specialization has no effect'
HB36244473793: '명시적 특수화 후에 발생하는 %0의 명시적 인스턴스화는 효과가 없습니다'
# 'explicit instantiation of %q0 must occur in namespace %1'
HB00768729F8E: '명시적 인스턴스화 %q0는 네임스페이스 %1에서 선언되어야 합니다'
# 'explicit instantiation of %q0 must specify a template argument list'
HE88FD9250BA0: '명시적 인스턴스화 %q0는 템플릿 인수 목록을 지정해야 합니다'
# 'explicit instantiation of non-templated type %0'
H31C2727CC2AA: '비템플릿 유형 %0에 대한 명시적 인스턴스화'
# 'explicit instantiation of typedef %0'
H2C42F0D827C6: 'typedef %0의 명시적 인스턴스화'
# 'explicit instantiation of undefined %select{member class|member function|static data member}0 %1 of class template %2'
HCF3C5A632D34: '클래스 템플릿 %2의 정의되지 않은 %select{멤버 클래스|멤버 함수|정적 데이터 멤버}0 %1의 명시적 인스턴스화'
# 'explicit instantiation of undefined function template %0'
H5300C0092131: '정의되지 않은 함수 템플릿 %0의 명시적 인스턴스화입니다'
# 'explicit instantiation of undefined variable template %q0'
H38D285C06249: '정의되지 않은 변수 템플릿 %q0의 명시적 인스턴스화입니다.'
# 'explicit instantiation refers here'
HBCDCC7E0C7EF: '명시적 인스턴스화가 여기를 가리킵니다'
# 'explicit instantiation refers to member function %q0 that is not an instantiation'
H500C2DC642A9: '명시적 인스턴스화는 인스턴스화가 아닌 멤버 함수 %q0를 참조합니다'
# 'explicit instantiation refers to static data member %q0 that is not an instantiation'
H07ED3DC3915D: '명시적 인스턴스화는 인스턴스화가 아닌 정적 데이터 멤버 %q0를 참조합니다'
# "explicit object parameter cannot have 'void' type"
H5DECA4F1B2FA: "명시적 객체 매개변수는 'void' 형식을 가질 수 없습니다"
# 'explicit object parameters are incompatible with C++ standards before C++2b'
H32F147DF3434: '명시적 객체 매개변수는 C++2b 이전 표준과 호환되지 않습니다'
# 'explicit ownership qualifier on cast result has no effect'
H3D013C01B086: '캐스트 결과에 명시적 소유권 지정자는 영향을 미치지 않습니다.'
# 'explicit qualification required to use member %0 from dependent base class'
H469187ADD22A: '종속적 기본 클래스의 멤버 %0를 사용하려면 명시적 자격 지정이 필요합니다'
# 'explicit specialization cannot have a storage class'
HADDD65B5ED76: '명시적 전문화는 저장 클래스를 가질 수 없습니다'
# 'explicit specialization of %0 after instantiation'
HDBBF37665EBE: '명시적 특수화 %0는 인스턴스화 후에 오면 안 됩니다'
# 'explicit specialization of %0 in function scope'
H4AB8E368275F: '함수 범위 내의 %0에 대한 명시적 특수화'
# "explicit template instantiation cannot have a definition; if this definition is meant to be an explicit specialization, add '<>' after the 'template' keyword"
H88A1F449C08B: "명시적 템플릿 인스턴스화는 정의를 가질 수 없습니다. 만약 이 정의가 명시적 특수화를 의미한다면 'template' 키워드 뒤에 '<>'를 추가하십시오"
# 'explicit template parameter list for lambdas is a C++20 extension'
HF9AE6F1B9252: 'lambda 함수에 대한 명시적 템플릿 매개변수 목록은 C++20 확장 기능입니다'
# 'explicit template parameter list for lambdas is incompatible with C++ standards before C++20'
H57BCAF2B0340: '람다에 대한 명시적 템플릿 매개변수 목록은 C++20 이전의 C++ 표준과 호환되지 않습니다'
# 'explicit(bool) is a C++20 extension'
H07C70F747BCD: 'explicit(bool)은 C++20 확장 기능입니다'
# 'explicit(bool) is incompatible with C++ standards before C++20'
H2A0E673F4AE0: 'explicit(bool)은 C++20 이전의 C++ 표준과 호환되지 않습니다'
# 'explicitly assigning value of variable of type %0 to itself%select{|; did you mean to assign to member %2?}1'
HB1C6DD04C662: '명시적으로 %0 형식의 변수 값을 자신自身에 할당하고 있음%select{|; %2 멤버에 할당할 의도였나요?}1'
# "explicitly capture 'this'"
HCF140BF35536: "'this'를 명시적으로 포착해야 합니다"
# 'explicitly cast the argument to size_t to silence this warning'
HBB0D273571B1: '인수를 size_t로 명시적으로 캐스트하여 이 경고를 없애세요'
# 'explicitly cast the pointer to silence this warning'
H8E24FB4D1062: '이 경고를 무시하려면 포인터를 명시적으로 캐스팅하세요'
# "explicitly declare getter %objcinstance0 with '%1' to return an 'unowned' object"
H4E2F7B8127D2: "비소유 상태의 객체를 반환하도록 getter %objcinstance0을 '%1'로 명시적으로 선언하십시오"
# 'explicitly defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator is implicitly deleted'
H811330B8F313: '명시적으로 기본화된 %select{<ERROR>|등가성|세 방향|등가성|관계성}0 비교 연산자는 암묵적으로 삭제되었습니다'
# 'explicitly defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 is implicitly deleted'
H4A686915F9DC: '명시적으로 기본화된 %select{기본 생성자|복사 생성자|이동 생성자|복사 할당 연산자|이동 할당 연산자|소멸자}0는 암시적으로 삭제되었습니다'
# 'explicitly defaulted function was implicitly deleted here'
HF8EF8D3E0A6F: '명시적으로 디폴트로 지정된 함수가 여기서 암묵적으로 삭제되었습니다'
# 'explicitly defaulting this %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 with a type different from the implicit type is incompatible with C++ standards before C++20'
H5E5EF3FDD4E3: '이 %select{기본 생성자|복사 생성자|이동 생성자|복사 대입 연산자|이동 대입 연산자|소멸자}0를 암시적 형식과 다른 형식으로 명시적으로 기본화하면 C++20 이전의 C++ 표준과 호환되지 않습니다'
# 'explicitly moving variable of type %0 to itself%select{|; did you mean to move to member %2?}1'
H35CC5A2B002D: '명시적으로 %0 형식의 변수를 자기 자신에게 이동%select{|; %2 멤버로 이동하는 것을 원하셨나요?}1'
# 'explicitly specialized declaration is here'
H0E01C428C014: '명시적으로 특수화된 선언이 여기에 있습니다'
# 'explicitly-defaulted %select{copy|move}0 assignment operator must return %1'
H36FB5B74F68A: '명시적으로 기본화된 %select{copy|move}0 할당 연산자는 %1을 반환해야 합니다'
# 'exponent has no digits'
H17C521E1F810: '지수에 숫자가 없습니다'
# 'export block begins here'
HBA4BC250A89B: 'export 블록이 여기서 시작됩니다'
# 'export declaration appears within anonymous namespace'
H2CCBA9D1C7AA: 'export 선언이 익명 네임스페이스 내에 나타납니다.'
# 'export declaration appears within another export declaration'
HECEB46AE53AF: 'export 선언이 다른 export 선언 내부에 위치했습니다'
# 'export declaration can only be used on functions'
H2A1BE3778EEF: 'export 선언은 함수에만 사용할 수 있습니다'
# 'export declaration can only be used within a module purview'
HA59173758635: 'export 선언은 모듈의 범위 내에서만 사용할 수 있습니다'
# 'export declaration cannot be empty'
H571FAB6A011E: 'export 선언은 비어 있을 수 없습니다'
# 'export declaration cannot be used in a private module fragment'
H22322B0D3EA4: 'export 선언은 private 모듈 프래그먼트에서 사용할 수 없습니다'
# 'exported templates are unsupported'
H6166D4F14CA1: '수출된 템플릿은 지원되지 않습니다'
# 'expose the ANDI glue bug on PPC'
HC579FD8E0F1D: 'PPC에서 ANDI 결합 버그를 폭로합니다'
# 'expression cannot be followed by a postfix %0 operator; add parentheses'
HBEECC801546A: '표현식 뒤에 후위 %0 연산자를 사용할 수 없습니다; 괄호를 추가하세요'
# 'expression does not compute the number of elements in this array; element type is %0, not %1'
H23C233069DBB: '표현식은 이 배열의 요소 수를 계산하지 않았습니다; 요소 유형은 %0이지 %1이 아닙니다'
# "expression evaluates to '%0 %1 %2'"
H64BCD859D7BF: "표현식이 '%0 %1 %2'로 평가됩니다."
# 'expression has incomplete class type %0'
H58E1F9927C3B: '표현식이 완전하지 않은 클래스 형식 %0을 가지고 있습니다'
# 'expression is not a string literal'
H3935D8B321FF: '표현식이 문자열 리터럴이 아닙니다'
# 'expression is not an %select{integer|integral}0 constant expression'
H03AFF9CF4CF8: '표현식은 %select{정수|정수형}0 상수 표현식이 아닙니다'
# 'expression is not an %select{integer|integral}0 constant expression; folding it to a constant is a GNU extension'
H5CBB867EA1E8: '표현식은 %select{정수|정수형}0 상수 표현식이 아닙니다; 이를 상수로 폴딩하는 것은 GNU 확장 기능입니다'
# 'expression is not assignable'
H5F8670A31719: '표현식은 할당 대상이 아닙니다'
# 'expression must have integral or unscoped enumeration type, not %0'
H17B3769F086B: '표현식은 정수형 또는 unscoped 열거형 타입이어야 합니다. %0가 아닙니다.'
# 'expression not permitted as operand of fold expression'
H291A77DD522F: '표현식이 fold 표현식의 피연산자로 허용되지 않습니다'
# 'expression requires explicit conversion from %0 to %1'
HB376E0297A16: '표현식은 %0에서 %1로의 명시적인 형변환이 필요합니다'
# 'expression result unused'
HC432FEDE1001: '표현식의 결과가 사용되지 않았습니다'
# 'expression result unused; assign into a variable to force a volatile load'
HB7AF8EB968E8: '표현식 결과가 사용되지 않았습니다. _VOLATILE 로드를 강제하려면 변수에 할당해 주십시오.'
# "expression result unused; should this cast be to 'void'?"
HBBF825FCCB8B: "표현식 결과가 사용되지 않음; 'void'로 캐스팅해야 하지 않나요?"
# 'expression which evaluates to zero treated as a null pointer constant of type %0'
H0240527F1E90: '0으로 평가되는 표현식이 %0 형식의 null 포인터 상수로 간주되었습니다'
# 'expression with side effects has no effect in an unevaluated context'
H186C82044D81: '부작용이 있는 표현식은 평가되지 않은 맥락에서 영향을 미치지 않습니다'
# "expression with side effects will be evaluated despite being used as an operand to 'typeid'"
H9C60337CD3B8: "부작용을 가지는 표현식은 'typeid'의 피연산자로 사용되더라도 평가될 것입니다."
# 'extension used'
HD363255C0A95: '확장 사용됨'
# 'extern "C" language linkage specification begins here'
H7A156727F19D: 'extern "C" 언어 연결 지정이 여기서 시작됩니다'
# 'extern declaration of %0 follows non-extern declaration'
HD31A31C8A91F: '%0의 외부 선언이 비외부 선언 뒤에 오면 안 됩니다'
# 'extern templates are a C++11 extension'
H1884BE10DDD8: '외부 템플릿은 C++11 확장 기능입니다'
# 'extern templates are incompatible with C++98'
H1796556A5B60: '외부 템플릿은 C++98과 호환되지 않습니다.'
# 'external function %0 declared with incompatible types in different translation units (%1 vs. %2)'
HE651F889FA02: '외부 함수 %0가 다른 번역 단위에서 호환되지 않는 형식으로 선언되었습니다 (%1 vs. %2)'
# 'external variable %0 declared with incompatible types in different translation units (%1 vs. %2)'
H15B2E1B8C6FC: '외부 변수 %0가 다른 번역 단위에서 호환되지 않는 유형으로 선언되었습니다 (%1 vs %2)'
# 'external variable %0 defined in multiple translation units'
H1F8D107DE885: '외부 변수 %0가 여러 개의 번역 단위에서 정의되었습니다'
# "extra '&' taking address of overloaded function"
H9A83B3B4D92C: "중복 정의된 함수의 주소를 취하는 데 추가적인 '&'가 있습니다."
# "extra ';' %select{outside of a function|inside a %1|inside instance variable list|after member function definition}0"
HE280E1BDB8CF: "추가적인 ';' %select{함수 밖에서|내부의 %1에서|인스턴스 변수 목록|멤버 함수 정의 후}0"
# "extra ';' after member function definition"
H3CA5397D9B51: "멤버 함수 정의 후 추가 ';'가 있음"
# "extra ';' outside of a function is a C++11 extension"
HEE30E6FFD401: "함수 외부에 있는 추가 ';'는 C++11 확장 기능입니다"
# "extra ';' outside of a function is incompatible with C++98"
HB50929FF19FE: "함수 바깥에 있는 추가적인 ';'는 C++98과 호환되지 않습니다."
# 'extra qualification on member %0'
HEB926F36FA1F: '멤버 %0에 대한 불필요한 자격 지정'
# "extra tokens after attribute in a '#pragma clang attribute push'"
H0F837D0B4BE4: " '#pragma clang attribute push'에서 속성 후에 추가 토큰이 있습니다"
# 'extra tokens at end of #%0 directive'
HBFAC5EAA75A7: '지시문 #%0 종료 직후에 추가 토큰이 있습니다'
# "extra tokens at end of '#pragma %0' - ignored"
H2F08FDE9AD4F: "'#pragma %0' 끝 부분에 추가 토큰이 있음 - 무시됨"
# "extra tokens at the end of '#pragma omp %0' are ignored"
HA0D9244B087C: "'#pragma omp %0' 끝에 있는 추가 토큰들은 무시됩니다"
# "extraneous '%0' before ';'"
H8BD122A76CFA: "';' 앞에서 '%0'가 초과 지정되었습니다."
# "extraneous ')' after condition, expected a statement"
HFFE185AD544D: "조건 후에 불필요한 ')'가 있습니다. 문을 기대했습니다."
# "extraneous 'template<>' in declaration of %0 %1"
HE8DEA9984DC2: "선언에 불필요한 'template<>'가 있습니다 %0 %1"
# "extraneous 'template<>' in declaration of member %0"
H828C24444273: "멤버 %0의 선언 시 불필요한 'template<>'"
# "extraneous 'template<>' in declaration of variable %0"
HFFC1753865A1: "변수 %0의 선언문에서 불필요한 'template<>'가 있습니다."
# "extraneous closing brace ('}')"
H3D189A013717: "불필요한 닫는 중괄호 ('}')"
# 'extraneous template parameter list in alias template declaration'
HAA68A1EAD59F: '에일리어스 템플릿 선언에 불필요한 템플릿 매개변수 목록이 있습니다'
# 'extraneous template parameter list in concept definition'
HE58F30339D76: '컨셉 정의에 불필요한 템플릿 매개변수 목록'
# 'extraneous template parameter list in template specialization'
H37A5BAADFAAC: '템플릿 특수화의 템플릿 매개변수 목록에 불필요한 항목이 있습니다.'
# 'extraneous template parameter list in template specialization or out-of-line template definition'
HBFB0FFADD00D: '템플릿 특수화 또는 라인 밖 템플릿 정의 내에서 REDUNDANT_ 템플릿 매개변수 목록'
# "failed requirement '%0'; 'enable_if' cannot be used to disable this declaration"
H6A26091751B1: "실패한 조건 '%0'; 'enable_if'를 사용하여 이 선언을 비활성화할 수 없습니다."
# "failed to deduce triple for target architecture '%0'; specify the triple using '-fopenmp-targets' and '-Xopenmp-target' instead"
HAEA08639936D: "타겟 아키텍처 '%0'에 대한 triple을 추론하지 못했습니다; 대신 '-fopenmp-targets'와 '-Xopenmp-target' 옵션을 사용하여 triple을 지정해 주세요"
# 'failed to expand response file: %0'
H14746831D212: '응답 파일을 확장하지 못했습니다: %0'
# "failed to find module file for module '%0'"
H265A065BBB4D: "모듈 '%0'에 대한 모듈 파일을 찾을 수 없습니다"
# "failed to hash content for '%0' because memory buffer cannot be retrieved"
H13A2DD939D67: "'%0'의 내용을 해시하는 데 실패했습니다. 메모리 버퍼를 가져올 수 없음"
# "failed to process suppression mapping file '%0': %1"
H61E7856A5801: "억제 매핑 파일 '%0'을 처리하는 데 실패했습니다: %1"
# "failing because %select{environment variable 'FORCE_CLANG_DIAGNOSTICS_CRASH' is set|'-gen-reproducer' is used}0"
HE0DD8241D56F: "실패했습니다: %select{환경 변수 'FORCE_CLANG_DIAGNOSTICS_CRASH'가 설정되어 있습니다|'-gen-reproducer' 옵션이 사용되었습니다}0"
# 'failure when lexing a character literal'
H36FAC94ACBBF: '문자 리터럴을 분석하는 중에 실패했습니다'
# 'failure when lexing a numeric literal'
H514A5139F05F: '수치 리터럴을 토큰화하는 중에 실패했습니다'
# 'failure when lexing a string literal'
H628F82057288: '문자열 리터럴을 분석하는 중에 실패했습니다'
# 'fallthrough annotation does not directly precede switch label'
H0941315663A3: 'fallthrough 어노테이션이 switch 레이블 직전에 위치하지 않습니다'
# 'fallthrough annotation in unreachable code'
HF1B980EE596A: '도달할 수 없는 코드에서 fallthrough 주석'
# 'fallthrough annotation is outside switch statement'
H1D7245256264: 'fallthrough 주석이 switch 문 밖에 있습니다.'
# 'fast enumeration variables cannot be modified in ARC by default; declare the variable __strong to allow this'
H0BD569725A75: 'ARC에서 기본적으로 빠른 열거 변수를 수정할 수 없습니다; 이를 허용하려면 변수를 __strong로 선언하세요'
# 'fast register allocator'
HD75005D5488A: '빠른 레지스터 할당기'
# 'feature %0 requires support of %1 feature'
HA4C52697EC12: '기능 %0는 %1 기능을 지원해야 합니다'
# 'feature cannot be %select{introduced|deprecated|obsoleted}0 in %1 version %2 before it was %select{introduced|deprecated|obsoleted}3 in version %4; attribute ignored'
H18649406044A: '특징은 %4 버전에서 %select{추가|폐지|고시}3 되기 전에 %1 %2 버전에서 %select{추가|폐지|고시}0 될 수 없습니다; 속성 무시됨'
# "feature flag '%0' is ignored since the feature is read only"
H67D49FF0C7F8: "기능 플래그 '%0'는 해당 기능이 읽기 전용이기 때문에 무시되었습니다"
# "feature flag '%0' must start with either '+' to enable the feature or '-' to disable it; flag ignored"
HE0833D141647: "플래그 '%0'는 기능을 활성화하려면 '+'로 시작하거나 비활성화하려면 '-'로 시작해야 합니다; 플래그가 무시되었습니다"
# 'field %0 can overwrite instance variable %1 with variable sized type %2 in superclass %3'
H6914F3D605AE: '필드 %0는 상위 클래스 %3의 인스턴스 변수 %1을 가변 크기 유형 %2로 덮어쓸 수 있습니다'
# 'field %0 declared as a function'
HEA705CD2A4BF: '필드 %0가 함수로 선언되었습니다'
# 'field %0 declared here'
HBC2A949CCB44: '필드 %0 여기서 선언됨'
# 'field %0 declared with incompatible types in different translation units (%1 vs. %2)'
H9B5B1B6B054E: '필드 %0가 서로 다른 번역 단위에서 호환되지 않는 유형으로 선언되었습니다 (%1 대신 %2)'
# 'field %0 has type %1 here'
H3B91A03ADD90: '필드 %0는 여기서 %1 타입입니다'
# "field %0 in '%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}1' not inside structure"
H161B48990AE3: "필드 %0이 '%select{개수로_지정된|크기로_지정된|개수로_지정된_또는_NULL|크기로_지정된_또는_NULL}1' 구조체 내부에 있지 않음"
# 'field %0 is not a bit-field'
H28FDD2B05CEC: '%0 필드는 비트-필드가 아님'
# 'field %0 is uninitialized when used here'
H215FDF8256E9: '필드 %0는 여기서 사용될 때 초기화되지 않았습니다'
# 'field %0 with variable sized type %1 is not at the end of class'
H33E4FFCBD3EE: '필드 %0는 가변 크기 타입 %1을 가지지만 클래스의 끝에 있지 않습니다'
# 'field %0 with variable sized type %1 is not visible to subclasses and can conflict with their instance variables'
HF18E29D99032: '필드 %0는 가변 크기 타입 %1을 가지며 하위 클래스에서 접근할 수 없고 그들의 인스턴스 변수와 충돌할 수 있습니다.'
# 'field %0 with variable sized type %1 not at the end of a struct or class is a GNU extension'
H4A43BA47311C: '가변 크기 타입 %1을 가지는 필드 %0는 구조체나 클래스의 끝에 있지 않으며, 이는 GNU 확장입니다'
# 'field %1 within %0 is less aligned than %2 and is usually due to %0 being packed, which can lead to unaligned accesses'
HA45C4FF93B3E: '필드 %1 내의 %0는 %2보다 덜 맞추어져 있으며, 이는 일반적으로 %0가 패키징된 데서 비롯되며, 이는 비정렬된 접근을 일으킬 수 있습니다'
# 'field %select{%1|in %1}0 requires explicit initialization but is not explicitly initialized'
H84C1F3A9AA55: '필드 %select{%1|에서 %1}0는 명시적 초기화가 필요하지만 명시적으로 초기화되지 않았습니다'
# 'field %select{width|precision}0 should have type %1, but argument has type %2'
H8AF459399447: '필드 %select{너비|정밀도}0는 %1 형식이어야 하지만 인수는 %2 형식입니다'
# 'field designator %0 does not refer to a non-static data member'
HC04EA556E581: '필드 지정자 %0는 비정적 데이터 멤버를 가리키지 않습니다'
# 'field designator %0 does not refer to any field in type %1'
H2BAA71F8012E: '필드 지정자 %0는 유형 %1의 어떤 필드에도 해당되지 않습니다'
# 'field designator %0 does not refer to any field in type %1; did you mean %2?'
HE8FCC93993E6: '필드 지정자 %0는 형식 %1의 어떤 필드에도 해당되지 않습니다; %2를 의미하셨나요?'
# 'field designator cannot initialize a %select{non-struct, non-union|non-class}0 type %1'
H22AF1F955E3D: '필드 지정자는 %select{구조체나 유니온이 아닌|클래스가 아닌}0 유형 %1을 초기화할 수 없습니다'
# 'field designator refers here'
H4EC4B8573557: '필드 지정자가 여기를 참조합니다'
# 'field has %select{incomplete|sizeless}0 type %1'
HAB06B0829266: '필드가 %select{완전하지 않은|크기 없는}0 형식 %1을 가집니다'
# 'field has name %0 here'
H5D746560C0CD: '이 필드는 여기에서 %0이라는 이름을 가집니다'
# 'field has non-trivial ownership qualification'
HC3F83642EF10: '필드가 비trivial 소유권 자격을 가집니다'
# 'field is non-trivial to %select{copy|default-initialize}0'
H1D2827B95FDF: '해당 필드는 %select{복사|기본 초기화}0하기가 비trivial합니다'
# 'field may not be qualified with an address space'
H8FECB3E29FF3: '필드는 주소 공간을 지정할 수 없습니다'
# 'field of illegal %select{type|pointer type}0 %1 declared here'
H7B96A2670B39: '잘못된 %select{형식|포인터 형식}0 %1의 필드가 여기서 선언되었습니다'
# 'field of type %0 has %select{private|protected}2 %select{default |copy |move |*ERROR* |*ERROR* |*ERROR* |}1constructor'
H3E9701CFFDEE: '타입 %0의 필드가 %select{프라이빗|프로텍티드}2 %select{기본 |복사 |이동 |*ERROR* |*ERROR* |*ERROR* |}1생성자를'
# 'field of type %1 has %select{private|protected}2 destructor'
H40B677C32C44: '타입 %1의 필드는 %select{비공개|보호}2 소멸자를 가집니다.'
# "fields must have a constant size: 'variable length array in structure' extension will never be supported"
H4D0FA4262CAB: "필드는 상수 크기를 가져야 합니다: '구조체 내 가변 길이 배열' 확장은 절대 지원되지 않을 것입니다"
# "file '%0' could not be located in expected %1"
H3AFCF68EDB4D: "파일 '%0'을(를) 예상한 %1에서 찾을 수 없습니다"
# "file '%0' from the precompiled header has been overridden"
H0CD8B8C2C117: "사전 컴파일된 헤더에서의 파일 '%0'이 재정의되었습니다"
# "file '%0' has been modified since the %select{precompiled header|module file|precompiled file}1 '%2' was built: %select{size|mtime|content}3 changed%select{| (was %5, now %6)}4"
HA383582927C4: "'%0' 파일은 %select{사전 컴파일된 헤더|모듈 파일|사전 컴파일된}1 '%2'가 생성된 이후 변경됨: %select{크기|수정 시간|내용}3 변경됨%select{| (이전 %5, 현재 %6)}4"
# "file '%0' is not a module file"
H5DD90DFEF976: "파일 '%0'은 모듈 파일이 아닙니다"
# "file '%0' is too large for Clang to process"
H9AA7CD92D17E: "파일 '%0'은 Clang가 처리할 수 없을 정도로 너무 큽니다"
# "file '%0' modified since it was first processed"
H1DA05AEA2D52: "파일 '%0'은 처음 처리된 후에 수정되었습니다."
# "file '%0' specified by '--extract-api-ignores=' not found"
HC79263152CF4: "옵션 '--extract-api-ignores='에서 지정된 파일 '%0'을 찾을 수 없습니다"
# "file '%0' specified by '-fmodules-embed-file=' not found"
HE609B0415A4D: "옵션 '-fmodules-embed-file='로 지정된 파일 '%0'를 찾을 수 없습니다"
# "file '%1' is not a valid %select{PCH|module|precompiled}0 file: %2"
H6C9F242B009C: "'%1' 파일은 유효한 %select{PCH|모듈|사전 컴파일된}0 파일이 아님: %2"
# 'file containing an ordered list of functions to use for function reordering'
HAA6E189FC7DA: '함수 재정렬에 사용할 순서가 지정된 함수들의 목록이 포함된 파일'
# 'file entered %0 time%s0 using %1B (%human1B) of space%plural{0:|: plus %2B (%human2B) for macro expansions}2'
H6D5FEB2AA58C: '파일이 %0번 사용하여 %1B (%human1B)의 공간을 차지했습니다.%plural{0:|: 플러스 %2B (%human2B)를 매크로 확장에 추가}2'
# 'file name for generated dot file'
H3426DAEC804D: '생성된 dot 파일의 파일 이름'
# 'file name where instrumented profile will be saved (default: /tmp/prof.fdata)'
H3FCF6422DD03: '측정된 프로파일을 저장할 파일 이름 (기본값: /tmp/prof.fdata)'
# 'file to dump the ordered list of functions to use for function reordering'
HA4F935C41DEC: '함수 재정렬에 사용할 순서된 함수 목록을 덤프하는 파일'
# 'file with list of functions to frame optimize'
H9B6AF2961BE8: '프레임 최적화를 위한 함수 목록이 포함된 파일'
# 'file with list of functions to optimize'
HE0011E0AAAF5: '최적화할 함수 목록이 들어 있는 파일'
# 'file with list of functions to optimize (non-regex)'
H03B4E7AB601D: '최적화할 함수 목록이 포함된 파일 (정규식 사용 안 함)'
# 'file with list of functions to skip'
HCF75D26C4EAE: '생략할 함수 목록이 포함된 파일'
# 'filter expression has non-integral type %0'
H8F952076C959: '필터 표현식의 타입이 정수형이 아닙니다: %0'
# 'final overrider of %q0 in %1'
H0C345A3BEA34: '%q0 in %1의 최종 오버라이더(final overrider)'
# 'find_all_symbols options'
H390ECCC2C1D8: 'find_all_symbols 옵션'
# "finished building module '%0'"
H243A4EC2890E: "모듈 '%0' 구축 완료"
# 'first argument in call to %0 is a pointer to non-trivially copyable type %1'
HD27C5E590173: '함수 %0 호출의 첫 번째 인자는 %1 타입의 비단순 복사 가능 포인터입니다'
# 'first argument to %0 must be a pipe type'
H3249D08A7B4F: '첫 번째 인수에 %0는 파이프 형식이어야 합니다'
# "first argument to 'swift_async' must be either 'none', 'swift_private', or 'not_swift_private'"
HF444E5B58050: "swift_async의 첫 번째 인수는 'none', 'swift_private', 또는 'not_swift_private' 중 하나여야 합니다"
# "first argument to 'va_arg' is of type %0 and not 'va_list'"
H18598D04D35B: "va_arg의 첫 번째 인수는 %0 형식이고 'va_list'가 아닙니다"
# 'first argument to __builtin_annotation must be an integer'
H2F65E4EF2060: '"__builtin_annotation"의 첫 번째 인수는 정수여야 합니다'
# 'first argument to __builtin_call_with_static_chain must be a non-member call expression'
HF21FFE70E0AD: '첫 번째 인수는 __builtin_call_with_static_chain에 비멤버 호출 표현식이어야 합니다'
# 'first argument to __builtin_call_with_static_chain must not be a block call'
HAAFE474DF4AA: '__builtin_call_with_static_chain의 첫 번째 인수는 블록 호출이어서는 안 됩니다'
# 'first argument to __builtin_call_with_static_chain must not be a builtin call'
HF06ABEE7311C: '__builtin_call_with_static_chain의 첫 번째 인수는 내장 호출일 수 없습니다'
# 'first argument to __builtin_call_with_static_chain must not be a pseudo-destructor call'
HFC90CCCE3212: '함수 __builtin_call_with_static_chain의 첫 번째 인수는 가상 소멸자 호출일 수 없습니다'
# 'first argument to __builtin_convertvector must be a vector'
HF416CD096831: '__builtin_convertvector의 첫 번째 인수는 벡터 타입이어야 합니다'
# 'first field of a transparent union cannot have %select{floating point|vector}0 type %1; transparent_union attribute ignored'
HCF8EE366AB6A: '명명된 유니온의 첫 번째 필드는 %select{부동소수점|벡터}0 타입 %1을 가질 수 없습니다; transparent_union 속성이 무시되었습니다'
# 'first non-designated initializer is here'
H3AA2DBB89701: '첫 번째 비지정 초기화자는 여기에 있습니다'
# 'first two arguments to __builtin_convertvector must have the same number of elements'
HF134017C1A48: "함수 '__builtin_convertvector'의 첫 번째 두 인수는 동일한 요소 수를 가져야 합니다"
# "first%select{||| and second}0 argument%select{|||s}0 to '__builtin_trivially_relocate' must be %select{a pointer|non-const|relocatable|of the same type}0"
H922BBD5C29FD: "첫 번째%select{||| 및 두 번째}0 인수%select{|||s}0가 '__builtin_trivially_relocate'의 %select{포인터|const가 아닌|재배치 가능한|동일한 유형의}0 유형이어야 함"
# "flag '%0' is ignored when flag '%1' is present"
H83C2C7BB9944: "플래그 '%0'는 플래그 '%1'이 존재할 때 무시됩니다"
# "flag '%0' results in undefined behavior with '%1' conversion specifier"
H3E280AED1AE3: "플래그 '%0'은 '%1' 변환 지정자와 함께 사용 시 정의되지 않은 동작을 유발합니다"
# 'flag value is neither a literal 0 nor a named value'
HD5CDE1D3FA16: '플래그 값은 리터럴 0도 아니고 명명된 값도 아님'
# 'flat namespace libraries are not supported'
H5F018FAC5A55: '플랫 네임스페이스 라이브러리는 지원되지 않습니다'
# 'flexible array initialization is a GNU extension'
H2B7FB7A2090E: '유연한 배열 초기화는 GNU 확장 기능입니다'
# 'flexible array initialization is not yet supported'
H4465FD687CED: '유연한 배열 초기화는 아직 지원되지 않습니다'
# 'flexible array member %0 in a union is a GNU extension'
H87BF69264D2B: '유니온 내의 유연한 배열 멤버 %0는 GNU 확장 기능입니다'
# 'flexible array member %0 in a union is a Microsoft extension'
HFF7472E02D1C: '유니온 내의 유연한 배열 멤버 %0는 마이크로소프트 확장 기능입니다'
# 'flexible array member %0 in otherwise empty %select{struct|interface|union|class|enum}1 is a GNU extension'
HADE10FBB32E9: '유연한 배열 멤버 %0가 다른 멤버가 없는 %select{struct|interface|union|class|enum}1에 있는 것은 GNU 확장 기능입니다'
# 'flexible array member %0 in otherwise empty %select{struct|interface|union|class|enum}1 is a Microsoft extension'
H9C2765356C50: '유연한 배열 멤버 %0이 %select{struct|interface|union|class|enum}1의 유일한 멤버인 경우는 마이크로소프트 확장 기능입니다'
# 'flexible array member %0 not allowed in %select{struct|interface|union|class|enum}1 which has a virtual base class'
HEF0666641494: '유연한 배열 멤버 %0은/는 가상 기반 클래스를 가진 %select{struct|interface|union|class|enum}1 내에서는 허용되지 않습니다'
# 'flexible array member %0 of type %1 with non-trivial destruction'
H07E92B7CB701: '유연한 배열 멤버 %0의 타입 %1은 비트리비얼 소멸을 가집니다.'
# 'flexible array member %0 with type %1 is not at the end of %select{struct|interface|union|class|enum}2'
HC60DC08C387B: '유연한 배열 멤버 %0는 유형 %1을 갖으며, %select{구조체|인터페이스|유니온|클래스|열거형}2의 마지막에 있지 않습니다'
# 'flexible array members are a C99 feature'
H04521DEE401E: '유연한 배열 멤버는 C99의 기능입니다.'
# 'flexible array requires brace-enclosed initializer'
H8CC54601E715: '가변 길이 배열은 중괄호로 감싸인 초기화자를 필요로 합니다'
# "float ABI '%0' is not supported by current library"
H4A77B1741C96: "플로트 ABI '%0'는 현재 라이브러리에서 지원되지 않습니다"
# 'float literal has a magnitude that is too small to be represented as a float type'
HFFD25AF4AD9F: '부동 소수점 리터럴의 크기가 float 형식으로 표현하기에는 너무 작음'
# 'floating point arithmetic produces %select{an infinity|a NaN}0'
HE17E4C75C5CF: '부동소수점 연산이 %select{무한대|NaN}0을 생성했습니다'
# 'floating point classification requires argument of floating point type (passed in %0)'
HD0C7777CBCB2: '부동소수점 분류에는 부동소수점 유형의 인수가 필요합니다 (전달된 위치: %0)'
# 'floating point literal in preprocessor expression'
HB66AC9BD4411: '프리프로세서 표현식에 부동소수점 리터럴이 있습니다'
# 'floating-point comparison is always %select{true|false}0; constant cannot be represented exactly in type %1'
HCE8BE2CDB468: '부동 소수점 비교는 항상 %select{true|false}0입니다; 상수는 %1 형식에서 정확히 표현될 수 없습니다'
# 'fold functions with identical code'
H57C9420813A5: '동일한 코드를 가진 함수 축소'
# 'fold jcc+mov into cmov'
H1F495E977B3A: 'jcc+mov를 cmov로 접는 최적화'
# 'for fuzzer data'
H8CC95526ECAB: 'fuzzer 데이터를 위한'
# 'for jump tables, optimize indirect jmp targets instead of indices'
H4D3A2CC709AA: 'jump tables 최적화 시, 간접 jmp 대상 대신 인덱스를 최적화합니다'
# 'for loop has empty body'
HE73C4C3A1FCE: 'for 루프가 빈 본문을 가집니다'
# 'for range declaration must declare a variable'
HCCF9CE851541: '범위 기반 for 문은 변수를 선언해야 합니다'
# 'for training'
H23FBBEB90B89: '훈련을 위한'
# 'for type %0'
HE30274CCC76F: 'for %0 유형'
# 'force openmp unified shared memory mode'
H98550220A417: 'forced openmp 통합 공유 메모리 모드'
# 'force patching of original entry points to ensure execution follows only the new/optimized code.'
HAA8249C8D974: '원본 엔트리 포인트에 강제 패치를 적용하여 실행이 새로운/최적화된 코드만을 따라가도록 보장합니다.'
# 'force relocations to data sections to always be processed'
H790511D970BB: '데이터 섹션의 relocations를 항상 처리되도록 강제합니다'
# 'force the body of a loop to execute at least once'
H6C72E59E822C: '루프의 본문을 최소한 한 번은 실행되게 강제합니다'
# 'force_cuda_host_device end pragma without matching force_cuda_host_device begin'
H8F7AF4F2F3B0: '일치하는 force_cuda_host_device begin이 없는 force_cuda_host_device end pragma'
# 'format argument is %select{a value|an indirect field width|an indirect precision|an auxiliary value}0, but it should be %select{a value|an indirect field width|an indirect precision|an auxiliary value}1'
H26324CE63C64: '포맷 인수는 %select{값|간접 필드 너비|간접 정밀도|보조 값}0이지만, %select{값|간접 필드 너비|간접 정밀도|보조 값}1여야 합니다'
# 'format argument modifies specifier at position %0, but it should modify specifier at position %1'
HE2EBF92B2A88: '포맷 인수가 위치 %0의 지정자를 수정합니다, 하지만 위치 %1의 지정자를 수정해야 합니다'
# 'format argument not a string type'
H84E99A867F54: '형식 인수는 문자열 유형이 아닙니다'
# 'format attribute cannot specify the implicit this argument as the format string'
H6DFBB5CF7F53: '포맷 속성은 포맷 문자열로 암시적 this 인수를 지정할 수 없습니다'
# "format specifier '%0' is incompatible with '%1'"
H4D29848904BC: "포맷 지정자 '%0'는 '%1'과 호환되지 않습니다"
# 'format specifies type %0 but the argument has %select{type|underlying type}2 %1'
H2B1918042742: '포맷 지정문이 %0 형식을 요구하지만, 인수는 %select{형식|기초 형식}2 %1을 가집니다'
# "format string contains '\\0' within the string body"
H262604652293: "포맷 문자열은 문자열 본문 내에 '\\0'을 포함할 수 없습니다"
# 'format string is defined here'
H2D8041B9330A: '포맷 문자열은 여기서 정의되었습니다'
# 'format string is empty'
HCF4821840281: '포맷 문자열이 비어 있습니다.'
# 'format string is not a string literal'
HA31C16ADFE78: '포맷 문자열이 문자열 리터럴이 아닙니다.'
# 'format string is not a string literal (potentially insecure)'
HC6BB1E1C18C5: '포맷 문자열이 문자열 리터럴이 아닙니다 (잠재적 보안 위험)'
# 'format string is not null-terminated'
H1BFF49AB9B87: '포맷 문자열이 null로 종료되지 않았습니다.'
# 'format string missing'
HF57059BFF07F: '포맷 문자열이 누락되었습니다'
# 'format string should not be a wide string'
H5D46A69914C2: '포맷 문자열은 와이드 문자열이어서는 안 됩니다'
# 'format to dump profile output in aggregation mode, default is fdata'
H4B4189014528: '집계 모드에서 프로필 출력을 덤프하는 형식을 지정합니다. 기본값은 fdata입니다'
# 'forward declaration of %0'
H9E3BA9144F24: '의 %0 전방 선언'
# 'forward declaration of %0 cannot have a nested name specifier'
HED9D019594EF: '%0의 전방 선언은 중첩된 이름 지정자를 가질 수 없습니다'
# 'forward declaration of class here'
H169D8B5BC4E6: '여기서 class의 전방 선언'
# 'forward declaration of non-parameterized class %0 cannot have type parameters'
H5EA8F1567F5D: '매개변수가 없는 클래스 %0의 전방 선언에는 타입 매개변수가 있을 수 없습니다'
# 'forward declaration of template entity is here'
H61734FDBAB98: '템플릿 엔티티의 전방 선언은 여기 있습니다'
# "forward references to 'enum' types are a Microsoft extension"
H747D15D3C5A0: 'enum 형식의 전방 참조는 Microsoft 확장 기능입니다'
# "found '<::' after a %select{template name|addrspace_cast|const_cast|dynamic_cast|reinterpret_cast|static_cast}0 which forms the digraph '<:' (aka '[') and a ':', did you mean '< ::'?"
HFDE68D3C1582: "%select{template name|addrspace_cast|const_cast|dynamic_cast|reinterpret_cast|static_cast}0 이후에 '<::'를 발견했습니다. 이는 digraph '<:' (즉 '[')와 ':'를 형성합니다. 혹시 '< ::'를 의미하셨나요?"
# "found near match '%0'"
HE96C9DD0F351: "가까운 일치 항목 '%0'을(를) 발견했습니다"
# 'fp convert instructions on integers with more than <N> bits are expanded.'
HBF7A8F526E5F: '비트가 <N>을 초과하는 정수에 대한 부동소수점 변환 명령문은 분해됩니다.'
# "friend cannot be declared in an explicit instantiation; if this declaration is meant to be a friend declaration, remove the 'template' keyword"
H2CA4FF8AC2DD: "friend는 명시적 인스턴스화에서 선언될 수 없습니다; 이 선언이 friend 선언을 의미하는 경우 'template' 키워드를 제거하십시오"
# 'friend declaration cannot be a concept'
HB24446765643: 'friend 선언은 concept일 수 없습니다.'
# 'friend declaration cannot have a pure-specifier'
HC11ADC45D1D2: 'friend 선언은 순수 지정자를 가질 수 없습니다'
# 'friend declaration expands pack %0 that is declared it its own template parameter list'
H7F18F2309FFC: '프렌드 선언은 자신의 템플릿 매개변수 목록에 선언된 %0 팩을 확장합니다'
# 'friend declaration naming a member of the declaring class is incompatible with C++98'
H785F5E24B496: '선언 중인 클래스의 멤버를 지정하는 friend 선언은 C++98과 호환되지 않습니다'
# 'friend declaration of %0 does not match any declaration in %1'
H31DFE021DF93: '%0의 friend 선언은 %1 내에서 일치하는 선언이 없습니다'
# 'friend declaration specifying a default argument must be a definition'
H55D4B490E76D: 'friend 선언에 기본 인수를 지정하는 경우 반드시 정의이어야 합니다'
# 'friend declaration specifying a default argument must be the only declaration'
H21926C78D225: '기본 인수를 지정하는 friend 선언은 유일한 선언이어야 합니다'
# 'friend declaration with a constraint that depends on an enclosing template parameter must be a definition'
HC3DC9462CF4B: '상위 템플릿 매개변수에 의존하는 제약 조건을 가진 friend 선언은 정의여야 합니다'
# 'friend declared here'
H4C2593C39E2F: 'friend 여기에서 선언되었습니다'
# 'friend function %0 retaining previous language linkage is an extension'
H45895F884047: '친구 함수 %0가 이전 언어 연결성을 유지하는 것은 확장 기능입니다'
# 'friend function %1 is a %select{private|protected}0 member of %3'
H559C2702128F: '프렌드 함수 %1은 %3의 %select{개인|보호}0 멤버입니다'
# 'friend function cannot be defined in a local class'
H01D22F1D90F1: '지역 클래스에서는 프렌드 함수를 정의할 수 없습니다'
# 'friend function definition cannot be qualified with %0'
H87D42EF13E75: '프렌드 함수 정의는 %0로 자격을 지정할 수 없습니다'
# 'friend function specialization cannot be defined'
HE48A55696A0C: '프렌드 함수 특수화는 정의될 수 없습니다'
# 'friend type templates must use an elaborated type'
H81BB485691B6: 'friend 템플릿 형식은 명시적 형식을 사용해야 합니다.'
# 'friends can only be classes or functions'
HABE505726BE2: '프랜드는 클래스나 함수만 될 수 있습니다'
# 'friends cannot be members of the declaring class'
H0C1CF26733ED: '친구는 선언하는 클래스의 멤버일 수 없습니다'
# "from 'diagnose_if' attribute on %0:"
HB7602983E09F: '‘diagnose_if’ 어트리뷰트가 %0에 있음으로부터:'
# 'func1,func2,func3,...'
H6E12F3399F53: 'func1,func2,func3 등...'
# "function %0 declared 'noreturn' should not return"
H05EC2FA28594: 'noreturn로 선언된 %0 함수는 반환하지 않아야 합니다'
# 'function %0 is unsafe'
H16AE74CB24AD: '함수 %0는 안전하지 않습니다'
# 'function %0 with deduced return type cannot be used before it is defined'
H55B75567CEBA: '함수 %0는 추론된 반환 형식을 가지므로 정의되기 전에는 사용할 수 없습니다'
# 'function %0 with unknown type must be given a function type'
H5580EE2709E6: '함수 %0는 알 수 없는 타입을 가졌으므로 함수 타입을 지정해야 합니다'
# 'function by that name is mangled as "%0"'
HD8E36422062F: '그 이름의 함수는 "%0"으로 mangling됩니다'
# 'function call counts'
HC411DF133023: '함수 호출 횟수'
# 'function cannot return %select{array|function}0 type %1'
H00D7FE6EC486: '함수는 %select{배열|함수}0 유형 %1을 반환할 수 없습니다'
# 'function cannot return qualified void type %0'
H6C0F9155F7F7: '함수는 수정된 void 형식 %0를 반환할 수 없습니다'
# 'function declaration cannot become a multiversioned function after first usage'
HC4FCD39E4392: '함수 선언은 첫 사용 후 다중 버전 함수로 변경할 수 없습니다'
# 'function declaration cannot have variably modified type'
HC763DB755E39: '함수 선언에는 가변 길이 형식을 가질 수 없습니다.'
# "function declaration is expected after 'declare %select{simd|variant}0' directive"
HCE4F7AEAC2D0: "함수 선언이 'declare %select{simd|variant}0' 디렉티브 뒤에 오기를 예상합니다"
# "function declaration is missing %select{'target'|'cpu_specific' or 'cpu_dispatch'|'target_version'}0 attribute in a multiversioned function"
H3FE487F1B347: "다중 버전화된 함수 내에서 함수 선언에 %select{'타겟'|'CPU 특정' 또는 'CPU 디스패치'|'타겟 버전'}0 속성이 누락되었습니다."
# 'function declared %0 was previously declared %1, which has different SME function attributes'
HF900531E932D: '%0로 선언된 함수는 이전에 %1로 선언되었으며, 이는 서로 다른 SME 함수 속성을 가지고 있습니다'
# "function declared '%0' here was previously declared %select{'%2'|without calling convention}1"
H2073EFB350A2: "이 함수는 여기서 '%0'로 선언되었는데, 이전에 %select{'%2'|호출 규약 없이}1로 선언되었습니다."
# "function declared in block scope cannot have 'static' storage class"
H60B5EC75E0B8: "블록 범위에서 선언된 함수는 'static' 저장 클래스를 가질 수 없습니다."
# 'function declared non-throwing here'
H03F3D9700027: '이 함수는 여기서 던지지 않는 것으로 선언되었습니다.'
# 'function declared with %0 attribute was previously declared without the %0 attribute'
H5B84619C2423: '함수는 %0 속성으로 선언되었지만, 이전에는 %0 속성이 없이 선언되었습니다'
# 'function declared with regparm(%0) attribute was previously declared %plural{0:without the regparm|:with the regparm(%1)}1 attribute'
HF6A7160FBDE6: 'regparm(%0) 속성으로 선언된 함수는 이전에 %plural{0:regparm 없이|1:regparm(%1)을 사용하여}1 선언되었습니다.'
# "function definition declared 'typedef'"
H4E2B82F177E3: "함수 정의에 'typedef'가 선언되었습니다."
# 'function definition does not declare parameters'
HD54A2FF99A28: '함수 정의에서 매개변수를 선언하지 않았습니다'
# 'function definition inside an Objective-C container is deprecated'
HE7254FE08BD0: 'Objective-C 컨테이너 내부의 함수 정의는 사용하지 않는 것이 좋습니다'
# 'function definition is not allowed here'
HE3336279F815: '이 곳에서는 함수 정의가 허용되지 않습니다.'
# 'function definition with pure-specifier is a Microsoft extension'
HDD1E7812B50D: 'pure-specifier를 사용한 함수 정의는 Microsoft의 확장 기능입니다'
# 'function does not return %0'
H7977746969A8: '이 함수는 %0를 반환하지 않습니다.'
# "function executed in streaming-SVE mode requires 'sme'"
H6F533435BD63: "스트리밍-SVE 모드에서 실행된 함수는 'sme'가 필요합니다"
# 'function id'
H68D2D6A5A6D7: '함수 ID'
# "function is a coroutine due to use of '%0' here"
H3E5959ADA928: "이 함수는 여기서 '%0'을 사용했기 때문에 코루틴입니다"
# 'function is implicitly deleted because its declared type does not match the type of an implicit %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0'
H2629CD02AC41: '함수는 선언된 유형과 암시적으로 생성된 %select{디폴트 생성자|복사 생성자|이동 생성자|복사 대입 연산자|이동 대입 연산자|소멸자}0의 유형이 일치하지 않아 암시적으로 삭제되었습니다'
# 'function multiversioning caused by this declaration'
HF2D62F7767DB: 'function multiversioning은 이 선언에 의해 발생했습니다.'
# "function multiversioning doesn't support %select{feature|architecture}0 '%1'"
H9210168C8D12: "함수 다중 버전화는 %select{feature|architecture}0 '%1'을(를) 지원하지 않습니다"
# 'function multiversioning is currently only supported on Linux'
H16DA1069458D: 'function multiversioning은 현재 Linux에서만 지원됩니다'
# 'function multiversioning is not supported on the current target'
H7E39D7302E01: '현재 대상에서 함수 다중버전화가 지원되지 않습니다.'
# "function name is not allowed in 'link' clause"
H0E47E3134914: "function name은 'link' 절 내에서는 허용되지 않습니다"
# 'function names'
HDC0A95620EA5: '함수 이름'
# 'function parameter %0 with unknown value cannot be used in a constant expression'
H01EB1CAEE1FB: '%0 함수 매개변수는 알 수 없는 값이 있어 상수 표현식에서 사용할 수 없습니다'
# 'function previously declared with an %select{explicit|implicit}0 exception specification redeclared with an %select{implicit|explicit}0 exception specification'
H74E61DFB1137: '함수는 이전에 %select{명시적|암시적}0 예외 지정으로 선언되었지만, %select{암시적|명시적}0 예외 지정으로 재선언되었습니다'
# 'function returns a type %0 marked with [[clang::coro_return_type]] but is neither a coroutine nor a coroutine wrapper; non-coroutines should be marked with [[clang::coro_wrapper]] to allow returning coroutine return type'
H6390B743719E: '함수는 [[clang::coro_return_type]]로 표시된 %0 타입을 반환하지만, 코루틴이거나 코루틴 래퍼가 아닙니다. 코루틴이 아닌 경우 반환 타입으로 코루틴 반환 타입을 허용하려면 [[clang::coro_wrapper]]로 표시해야 합니다.'
# 'function scope depth exceeded maximum of %0'
H7DB5DD972DEA: '함수 범위 깊이가 %0을 초과했습니다'
# "function static variables are not permitted in functions to which an OpenACC 'routine' directive applies"
HE3AED765A103: "OpenACC 'routine' 디렉티브가 적용된 함수에서는 함수 내 정적 변수를 사용할 수 없습니다."
# 'function template %q0 matches specialization %1'
HA3A32C570475: '함수 템플릿 %q0은 특수화 %1과 일치합니다'
# 'function template partial specialization is not allowed'
HA3F0ADD5EDBB: '함수 템플릿 부분 전문화는 허용되지 않습니다'
# 'function template specialization %0 ambiguously refers to more than one function template; explicitly specify%select{| additional}1 template arguments to identify a particular function template'
H64BC13156614: '함수 템플릿 특수화 %0가 복수의 함수 템플릿을 모호하게 참조합니다; 특정 함수 템플릿을 식별하기 위해 명시적으로%select{| 추가}1 템플릿 인수를 지정해야 합니다'
# "function template with 'sycl_kernel' attribute must have a 'void' return type"
HE8E9EA85C4E9: "sycl_kernel 속성이 있는 함수 템플릿은 'void' 반환 형식을 가져야 합니다"
# "function template with 'sycl_kernel' attribute must have a single parameter"
H852CD6495192: "함수 템플릿에 'sycl_kernel' 속성이 있다면 단일 매개변수를 가져야 합니다"
# 'function try block in constexpr %select{function|constructor}0 is a C++20 extension'
H5EFE05C3D7E9: 'constexpr %select{function|constructor}0 내의 function try block은 C++20 확장 기능입니다'
# 'function try block in constexpr %select{function|constructor}0 is incompatible with C++ standards before C++20'
HACF74D9C1B64: 'constexpr %select{함수|생성자}0 내의 함수 트라이 블록은 C++20 이전의 C++ 표준과 호환되지 않습니다'
# 'function type may not be qualified with an address space'
H193B814022E3: '함수 타입은 주소 공간 지정을 할 수 없습니다'
# 'function type with %0 attribute must have C linkage'
H39A9B5046A90: '함수 유형에 %0 속성을 가진 경우 C 링크가 있어야 합니다'
# "function using ZA state requires 'sme'"
H355762BCE254: "ZA 상태를 사용하는 함수는 'sme' 옵션이 필요합니다"
# "function using ZT0 state requires 'sme2'"
H00330EB861A8: "ZT0 상태를 사용하는 함수는 'sme2'가 필요합니다"
# "function with '#pragma omp declare variant' has a different %select{calling convention|return type|constexpr specification|inline specification|storage class|linkage}0"
H77243261DC29: "'#pragma omp declare variant'가 있는 함수는 다른 %select{호출 규칙|리턴 타입|constexpr 지정자|inline 지정자|저장 클래스|링크지정}0을 가지면 안 됩니다"
# "function with '#pragma omp declare variant' must have a prototype when 'append_args' is used"
H6A83415B36DA: "'#pragma omp declare variant'를 사용하는 함수는 'append_args'가 사용될 때 프로토타입을 가져야 합니다"
# "function with 'device_type(%0)' is not available on %select{device|host}1"
HB35512790F72: "'device_type(%0)'를 가진 함수는 %select{device|host}1에서 사용할 수 없습니다"
# 'function with deduced return type cannot be virtual'
H4BED7E854F85: '추론된 리턴 타입을 가진 함수는 가상 함수일 수 없습니다.'
# 'function with no prototype cannot use the %0 calling convention'
H83A590AC3D6C: '프로토타입이 없는 함수는 %0 호출 규칙을 사용할 수 없습니다'
# "function with trailing return type must specify return type 'auto', not %0"
HBA312AD67336: "뒤따르는 반환 형식을 가진 함수는 반환 형식으로 'auto'를 지정해야 하며, %0를 지정할 수 없습니다"
# 'function-like macro %0 is not defined'
H7F9F07CB89B9: '함수 형식 매크로 %0는 정의되지 않았습니다'
# 'function-style cast to a builtin type can only take one argument'
H5995CF0D518F: '함수 스타일 캐스트를 사용해 내장 형식으로 변환하는 것은 단일 인수만 받을 수 있습니다'
# 'functional-style cast to %0 has incompatible initializer of type %1'
H0F52DA9B703F: '형 %0로의 함수 스타일 캐스트에 호환되지 않는 형 %1의 초기화자가 있습니다.'
# 'functions cannot be declared in an anonymous %select{struct|union}0'
H50EACF1C1B1C: '함수는 익명 %select{struct|union}0 안에서 선언될 수 없습니다.'
# "functions may not be declared with 'cmse_nonsecure_call' attribute"
H21052FB1BA63: "함수는 'cmse_nonsecure_call' 속성으로 선언할 수 없습니다."
# 'functions that differ only in their return type cannot be overloaded'
H24E04D8DAB80: '리턴 타입만 다른 함수들은 오버로드될 수 없습니다'
# 'gdb'
H8EAD6354003C: 'gdb'
# 'generalized initializer lists are a C++11 extension'
HA239925474B5: '일반화된 초기화 목록은 C++11 확장 기능입니다'
# 'generalized initializer lists are incompatible with C++98'
HCEA06465013C: '일반화된 초기화 목록은 C++98과 호환되지 않습니다'
# 'generate a C++ source file containing the patterns for the input file'
H0E649CF6B515: '입력 파일의 패턴을 포함하는 C++ 소스 파일을 생성합니다'
# 'generate a list of function sections in a format suitable for inclusion in a linker script'
H26853D1AF334: '링커 스크립트에 포함하기 적합한 형식으로 함수 섹션의 목록을 생성합니다'
# 'generate code for binaries <128MB on AArch64'
H5478C82F0746: '128MB 미만의 이진 파일을 AArch64에서 생성하기 위한 코드를 생성합니다'
# 'generate loops for copy-in/copy-out of objects with descriptors'
HEE6A80E60F2B: '디스크립터가 있는 객체의 복사 입력/출력을 위한 루프 생성'
# 'generate new tags with runtime library calls'
HE354D1286E8B: '런타임 라이브러리 호출을 사용하여 새로운 태그 생성'
# 'generate the AST for the input file'
H8D81796BB792: '입력 파일의 AST를 생성합니다'
# 'generate the PDL MLIR for the input file'
H13DC370300BA: '입력 파일에 대한 PDL MLIR을 생성합니다'
# 'generated arguments #%0 in round-trip: %1'
H9232807EF50E: '반환 경로에서 생성된 인수 #%0: %1'
# 'generated arguments do not match in round-trip'
HDDB24B24E48C: '생성된 인수가 반환 전송에서 일치하지 않습니다.'
# 'generated arguments parse failed in round-trip'
HA646C4AED02A: '생성된 인수의 해석이 반환 경로에서 실패했습니다'
# 'generic lambdas are incompatible with C++11'
H0E2372801126: '일반화된 람다는 C++11과 호환되지 않습니다'
# 'getter name mismatch between property redeclaration (%1) and its original declaration (%0)'
HCB66D133764C: '속성 재선언(%1)과 그 원래 선언(%0) 간에 게터 이름 불일치'
# 'given <sectname>,<filename>[@<sym>=<offset>,...]  add the content of <filename> to <sectname>'
HB3C96722F67D: '지정된 <sectname>,<filename>[@<sym>=<offset>,...]에 따라 <filename>의 내용을 <sectname>에 추가합니다.'
# "glob '%0' did not match any header file"
H7F85F549D444: "지정된 헤더 파일과 일치하는 'glob '%0''가 없습니다."
# 'global sampler requires a const or constant address space qualifier'
H418F4CC80105: '글로벌 샘플러는 const 또는 constant 주소 공간 지정자를 필요로 합니다'
# 'granularity of memprof shadow mapping'
H3EDB20D758D1: 'memprof 그림자 매핑의 세분화 단위'
# 'greedy register allocator'
H682B2DF6B406: '탐욕스러운 레지스터 할당기'
# 'growRegion() does not scale with the number of BB edges, so limit its budget and bail out once we reach the limit.'
HA399861C464F: 'growRegion()는 BB 엣지의 수와 비례하지 않으므로 예산을 제한하고 한계에 도달하면 포기합니다.'
# 'guarded_by declared here'
H0D3E968182E3: 'guarded_by 여기서 선언됨'
# 'half precision constant requires cl_khr_fp16'
H4CC0B372F96B: '_HALF 정밀도 상수는 cl_khr_fp16이 필요합니다'
# 'hardware TLS register is not supported for the %0 sub-architecture'
HDE3B68F7C8A6: '하드웨어 TLS 레지스터는 %0 하위 아키텍처에서는 지원되지 않습니다'
# "header attribute '%0' specified multiple times"
H7E7CB9EE75BF: "헤더 속성 '%0'이 여러 번 지정되었습니다"
# "header file %0 (aka '%1') cannot be imported because it is not known to be a header unit"
H0A389CC3DB5F: "헤더 파일 %0 (aka '%1')은 헤더 유닛임이 알려지지 않았기 때문에 포함될 수 없습니다"
# "header file '%0' input '%1' does not match the type of prior input in api extraction; use '-x %2' to override"
HCC1F871B655D: "헤더 파일 '%0' 입력 '%1'은 API 추출 중 이전 입력의 유형과 일치하지 않습니다; '-x %2'를 사용하여 강제로 지정하려면"
# "header file '%0' input type '%1' does not match type of prior input in module compilation; use '-x %2' to override"
H089F6388D5E8: "헤더 파일 '%0' 입력 유형 '%1'이 모듈 컴파일에서 이전 입력의 유형과 일치하지 않습니다; '-x %2'를 사용하여 재정의할 수 있습니다"
# 'heap allocation performed here'
H3CBBD5C4CC88: '여기에서 힙 할당이 수행되었습니다'
# 'heatmap bucket size, optionally followed by zoom-out sizes for coarse-grained heatmaps (default 64B, 4K, 256K).'
H8DE740B4864F: '히트맵 버킷 크기, 이후 코어스 그레인드 히트맵을 위한 줌아웃 크기를 선택적으로 지정함 (기본값 64B, 4K, 256K).'
# 'hexadecimal floating %select{constant|literal}0 requires %select{an exponent|a significand}1'
HEA69D9247DD1: '16진수 부동소수점 %select{상수|리터럴}0는 %select{지수|유의수}1가 필요합니다.'
# 'hexadecimal floating constants are a C99 feature'
H42D5F9E3F4DF: '16진수 부동소수점 상수는 C99 표준의 기능입니다'
# 'hexadecimal floating literals are a C++17 feature'
H37A919BEDE1E: '16진수 부동소수점 리터럴은 C++17의 기능입니다'
# 'hexadecimal floating literals are incompatible with C++ standards before C++17'
HDD6000DF6583: '16진수 부동소수점 리터럴은 C++17 이전의 C++ 표준과 호환되지 않습니다'
# 'hidden overloaded virtual function %q0 declared here%select{|: different classes%diff{ ($ vs $)|}2,3|: different number of parameters (%2 vs %3)|: type mismatch at %ordinal2 parameter%diff{ ($ vs $)|}3,4|: different return type%diff{ ($ vs $)|}2,3|: different qualifiers (%2 vs %3)|: different exception specifications}1'
HAF71C2F007E8: '숨겨진 오버로드된 가상 함수 %q0 여기서 선언되었습니다%select{|: 다른 클래스%diff{ ($ vs $)|}2,3|: 매개변수 개수 불일치 (%2 vs %3)|: %ordinal2번째 매개변수 타입 불일치%diff{ ($ vs $)|}3,4|: 반환 타입 불일치%diff{ ($ vs $)|}2,3|: 수식어 차이 (%2 vs %3)|: 예외 사양 차이}1'
# "hidden visibility cannot be applied to 'dllexport' declaration"
HF663B246106D: "숨김 가시성은 'dllexport' 선언에 적용할 수 없습니다"
# 'higher order bits are zeroes after implicit conversion'
H69351DA797D5: '암시적 변환 후 고차 비트는 0으로 됩니다'
# 'hoist common instructions (default = false)'
HAA6396EA7649: '공통 명령어 상위로 hoist (기본값 = false)'
# 'host variable declared here'
H46B0F8E7BD93: '호스트 변수가 여기서 선언되었습니다.'
# 'hot data symbols support (relocation mode)'
H654F967DBBD4: '핫 데이터 심볼 지원 (재배치 모드)'
# 'how to repeat the instruction snippet'
HA06BE48BF68E: '지시문 조각을 반복하는 방법'
# 'hugify'
H4C1045D46DF7: '꾸며주기'
# 'human-readable YAML format'
HE74AE57FF6C4: '인간이 읽을 수 있는 YAML 형식'
# "identifier %0 after '~' in destructor name does not name a type"
H83FECEE0EB8D: "소멸자의 이름에서 '~' 뒤에 오는 식별자 %0은 타입을 지정하지 않습니다"
# 'identifier %0 conflicts with a C++ keyword'
HA06C7A563CB5: '%0 식별자가 C++ 키워드와 충돌함'
# 'identifier %0 in object destruction expression does not name a type'
H9BF7AFAC2ABF: '객체 소멸 표현식에서 식별자 %0는 타입을 지정하지 않았습니다'
# 'identifier %0 in object destruction expression does not name the type %1 of the object being destroyed'
H3AA5F97C4B64: '객체 소멸 표현식 내의 식별자 %0는 소멸 중인 객체의 유형 %1을 지정하지 않습니다'
# "identifier %0 is reserved because %select{<ERROR>|it starts with '_' at global scope|it starts with '_' and has C language linkage|it starts with '__'|it starts with '_' followed by a capital letter|it contains '__'}1"
HB25A0B12A970: "식별자 %0는 %select{오류|전역 범위에서 '_'로 시작합니다|C 언어 연계를 가집니다|'__'로 시작합니다|'_'에 이어 대문자를 가지기 때문|'__'를 포함합니다}1 때문에 예약되어 있습니다"
# 'identifier %0 preceded by whitespace in a literal operator declaration is deprecated'
H0DD590ABAF7E: '리터럴 연산자 선언에서 식별자 %0 앞에 공백이 있는 것은 사용 중단 예정입니다'
# 'identifier after literal will be treated as a reserved user-defined literal suffix in C++11'
HC12CCB91962D: '리터럴 다음에 오는 식별자는 C++11에서 예약된 사용자 정의 리터럴 접미사로 간주됩니다'
# 'identifier after literal will be treated as a user-defined literal suffix in C++11'
HBE6CD4B6A8AE: 'C++11에서 리터럴 다음에 오는 식별자는 사용자 정의 리터럴 접미사로 간주됩니다'
# 'identifier contains Unicode character <U+%0> that is invisible in some environments'
H5D7B884070AB: '식별자에 일부 환경에서 보이지 않을 수 있는 유니코드 문자 <U+%0>가 포함되었습니다'
# "identifier followed by '<' indicates a class template specialization but %0 %select{does not refer to a template|refers to a function template|<unused>|refers to a variable template|<unused>|<unused>|refers to a concept}1"
HAF5607DFBCE7: "식별자 뒤에 '<'가 있으면 클래스 템플릿 전문화를 나타내지만 %0 %select{템플릿을 참조하지 않습니다|함수 템플릿을 참조합니다|<unused>|변수 템플릿을 참조합니다|<unused>|<unused>|컨셉을 참조합니다}1"
# "if processing a memory profile, filter out stack or heap accesses that won't be useful for BOLT to reduce profile file size"
HECF8ECDF0776: '메모리 프로파일을 처리하는 경우 BOLT에 유용하지 않은 스택 또는 힙 접근을 필터링하여 프로파일 파일 크기를 줄입니다'
# 'if reorder-functions is used, order functions putting hottest last'
HD0E8BDE8B867: 'reorder-functions 옵션이 사용되면, 가장 뜨거운 함수를 마지막에 배치하여 함수 순서를 정렬합니다'
# 'if statement has empty body'
H1093D3B0523A: 'if 문의 본문이 비어 있습니다'
# 'if the caller is not cold'
H4C9CA904F4C7: '만약 호출자가 cold가 아니면'
# 'if the input is dwp file, parse .debug_info section and use it to populate DW_SECT_INFO contributions in cu-index. For DWARF5 it also populated TU Index.'
HEE68D0DE6C99: '입력이 dwp 파일인 경우 .debug_info 섹션을 해석하고 이를 cu-index의 DW_SECT_INFO 기여 항목에 추가합니다. DWARF5의 경우 TU Index도 추가합니다.'
# 'if there is more than one benchmark for an opcode, said benchmarks may end up not being clustered into the same cluster if the measured performance characteristics are different. by default all such opcodes are filtered out. this flag will instead show only such unstable opcodes'
H1E3EED942083: '만약 하나의 opcode에 대한 벤치마크가 여러 개 있다면, 측정된 성능 특성이 다르면 해당 벤치마크들이 같은 클러스터에 묶이지 않을 수 있습니다. 기본적으로 이러한 모든 opcode들은 필터링됩니다. 이 플래그는 대신 이러한 불안정한 opcode들만 표시합니다'
# 'if you see this diagnostic, a Clang developer has made a mistake'
H64B3C8B6BDD2: '이 진단 메시지를 본 경우, Clang 개발자가 실수를 했습니다'
# 'if you supply your own aligned allocation functions, use -faligned-allocation to silence this diagnostic'
H71B886D5B0E4: '자신만의 정렬된 할당 함수를 제공하는 경우, 이 진단을 숨기려면 -faligned-allocation을 사용하십시오'
# 'ifunc resolver function must return a pointer'
H3E2AB07FAA23: 'ifunc resolver 함수는 포인터를 반환해야 합니다'
# 'ignore failures to find derived type descriptors when translating FIR to LLVM'
H6805B42BCC88: 'FIR를 LLVM으로 번역할 때 파생된 타입 설명자를 찾지 못하는 실패를 무시합니다'
# 'ignore hash while reading function profile'
H414AB7A86B98: '함수 프로필을 읽을 때 해시 무시'
# 'ignore instructions that do not define a sched class'
H4673E599AC01: '스케줄 클래스를 정의하지 않는 명령을 무시합니다'
# 'ignore kernel interrupt LBR that happens asynchronously'
H65FF6B663DAF: '커널 인터럽트 LBR이 비동기적으로 발생하는 경우 무시'
# 'ignore lto_priv or const suffixes when matching functions'
H482A47671C74: '함수 일치 시 lto_priv 또는 const 접미사 무시'
# 'ignore recursive calls when constructing the call graph'
H79AFD225957D: '호출 그래프를 구성할 때 재귀 호출을 무시합니다'
# "ignored 'inline' attribute on kernel function %0"
HD7F59CCBC545: "커널 함수 %0의 'inline' 속성이 무시되었습니다."
# "ignored asm label '%0' on automatic variable"
H457253219067: "자동 변수에 대한 asm 레이블 '%0'이 무시되었습니다."
# 'ignored trigraph would end block comment'
HC0EDD32FEF14: '무시된 트리그라프가 블록 주석을 종료시킬 것입니다'
# 'ignoring %0 attribute because its argument is invalid'
H5CBA55A0FD5C: '유효하지 않은 인수가 있어 %0 속성을 무시합니다'
# 'ignoring %select{return value|temporary}0 of type %2 declared with %1 attribute%select{|: %4}3'
H18EB408CFE62: '%select{반환 값|임시 객체}0 유형 %2는 %1 속성으로 선언되어 무시됩니다%select{|: %4}3'
# "ignoring '%0' as it conflicts with that implied by '%1' (%2)"
HB9837B039EA4: '‘%0’을(를) ‘%1’에서 암시한 내용과 충돌되기 때문에 무시합니다. (%2)'
# "ignoring '%0' option as it cannot be used with %select{implicit usage of|}1 -mabicalls and the N64 ABI"
H17CC723C2497: "옵션이 %select{암시적 사용|}1 -mabicalls와 N64 ABI와 함께 사용할 수 없기 때문에 '%0' 옵션을 무시합니다"
# "ignoring '%0' option as it is not currently supported for processor '%1'"
H14E6B917A2E6: "프로세서 '%1'에서 현재 지원되지 않기 때문에 '%0' 옵션을 무시함"
# "ignoring '%0' option as it is not currently supported for target '%1'"
H4AA39F54EF26: "옵션 '%0'을 무시함因为它目前不支持目标 '%1' 타겟에서 지원되지 않기 때문입니다"
# "ignoring '%0' option for offload arch '%1' as it is not currently supported there. Use it with an offload arch containing '%2' instead"
H788152E08844: "오프로드 아키텍처 '%1'에 대한 '%0' 옵션을 무시합니다. 해당 아키텍처에서는 현재 지원되지 않기 때문에, 대신 '%2'를 포함하는 오프로드 아키텍처와 함께 사용하십시오"
# "ignoring '%select{static|inline}0' keyword on explicit template instantiation"
H8A80FA7727CA: "명시적 템플릿 인스턴스화 시 '%select{static|inline}0' 키워드를 무시함"
# "ignoring '-f%select{no-|}0raw-string-literals', which is only valid for C and C++ standards before C++11"
H135D75731B01: "'-f%select{no-|}0raw-string-literals' 옵션을 무시함, 이 옵션은 C 및 C++ 표준에서 C++11 이전에만 유효합니다"
# "ignoring '-mabs=2008' option because the '%0' architecture does not support it"
H5F88EE5F0A3D: " '%0' 아키텍처가 지원하지 않기 때문에 '-mabs=2008' 옵션을 무시합니다."
# "ignoring '-mabs=legacy' option because the '%0' architecture does not support it"
HE0FE9F3B46CA: "‘%0’ 아키텍처가 이 옵션을 지원하지 않기 때문에 '-mabs=legacy' 옵션을 무시합니다"
# "ignoring '-mcompact-branches=' option because the '%0' architecture does not support it"
H60C9F0D89DB6: "‘-mcompact-branches=’ 옵션을 무시함: '%0' 아키텍처는 이를 지원하지 않습니다"
# "ignoring '-mgpopt' option as it cannot be used with %select{|the implicit usage of }0-mabicalls"
H2A6F793FDFBC: "옵션 '-mgpopt'를 무시합니다.因为它不能与%select{ |암시적 사용 }0의 -mabicalls 함께 사용합니다."
# "ignoring '-mlong-calls' option as it is not currently supported with %select{|the implicit usage of }0-mabicalls"
HD076A9DC69A3: '-mlong-calls 옵션을 무시합니다. 이 옵션은 현재 %select{ |암시적 사용의 }0-mabicalls와 호환되지 않기 때문입니다.'
# "ignoring '-mnan=2008' option because the '%0' architecture does not support it"
H29C27F0049E3: "옵션 '-mnan=2008'을 무시함: '%0' 아키텍처가 지원하지 않음"
# "ignoring '-mnan=legacy' option because the '%0' architecture does not support it"
HADAF322768AC: "지정된 '%0' 아키텍처가 이 옵션을 지원하지 않기 때문에 '-mnan=legacy' 옵션을 무시합니다"
# 'ignoring -fapple-kext which is valid for C++ and Objective-C++ only'
H88A745D4B73F: "옵션 '-fapple-kext'는 C++ 및 Objective-C++에서만 유효하므로 무시합니다"
# 'ignoring -fdiscard-value-names for LLVM Bitcode'
HC86237F887FA: 'LLVM 비트코드에 대한 -fdiscard-value-names를 무시합니다'
# "ignoring -fverify-debuginfo-preserve-export=%0 because -fverify-debuginfo-preserve wasn't enabled"
H36FCA7FF86DB: '-fverify-debuginfo-preserve-export=%0 옵션을 무시합니다.这是因为 -fverify-debuginfo-preserve 옵션이 활성화되지 않았기 때문입니다.'
# 'ignoring __declspec(allocator) because the function return type %0 is not a pointer or reference type'
H6AAEF2701683: '__declspec(allocator)를 무시합니다. 함수 반환 형식 %0가 포인터나 참조 형식이 아니기 때문입니다'
# "ignoring availability attribute %select{on '+load' method|with constructor attribute|with destructor attribute}0"
H24871179ED63: '사용 가능성 속성을 무시함 %select{+load 메서드에 적용된|생성자 속성과 함께|소멸자 속성과 함께}0'
# "ignoring extension '%0' because the '%1' architecture does not support it"
HD131D7C5772F: "확장 '%0'를 '%1' 아키텍처가 지원하지 않아 무시합니다"
# "ignoring invalid -ftabstop value '%0', using default value %1"
H55F6E19B595A: "유효하지 않은 -ftabstop 옵션 값 '%0'을 무시하고 기본값 %1을 사용합니다"
# "ignoring invalid /arch: argument '%0'; for %select{64|32}1-bit expected one of %2"
HF5AE60D7E4BF: "유효하지 않은 /arch: 인자 '%0'를 무시합니다; %select{64|32}1-비트용으로는 %2 중 하나가 예상됩니다"
# 'ignoring redefinition of Objective-C qualifier macro'
HE01ADCD1C19E: 'Objective-C 자격 증명 매크로의 재정의를 무시함'
# 'ignoring return value of function declared with %0 attribute'
H0B36C4D66510: '지정된 %0 속성의 함수의 반환 값을 무시합니다.'
# 'ignoring return value of function declared with %0 attribute%select{|: %2}1'
H9DECD2C6A7A4: '반환 값을 무시함: %0 속성으로 선언된 함수%select{|: %2}1'
# 'ignoring temporary created by a constructor declared with %0 attribute%select{|: %2}1'
H0FFFAF84F31C: '%0 속성으로 선언된 생성자가 생성한 임시 객체를 무시함%select{ |: %2}1'
# "ignoring the 'branch-protection' attribute because the '%0' architecture does not support it"
HF5FC687425B2: "‘branch-protection’ 속성을 '%0' 아키텍처가 지원하지 않기 때문에 무시합니다."
# 'illegal OpenMP user-defined mapper identifier'
H4FE25A4B348F: '잘못된 OpenMP 사용자 정의 매퍼 식별자'
# 'illegal call to %0, expected %1 argument type'
H4DEE4185FC7F: '불법 호출 %0, 예상된 %1 인자 유형'
# 'illegal call to enqueue_kernel, incorrect argument types'
H96AA6DCB3DCC: 'enqueue_kernel에 대한 불법 호출, 잘못된 인자 유형'
# 'illegal call to enqueue_kernel, parameter needs to be specified as integer type'
H8F7144077DA2: 'enqueue_kernel에 대한 불법 호출입니다. 파라미터는 정수형으로 지정되어야 합니다.'
# 'illegal character encoding in character literal'
H44B6CA76305B: '문자 리터럴 내에서 잘못된 문자 인코딩이 있습니다.'
# 'illegal character encoding in string literal'
H2EE26865FBAD: '문자열 리터럴에서 잘못된 문자 인코딩'
# 'illegal device builtin %select{surface|texture}0 reference class template %1 declared here'
H7BB2FD0ACCED: '잘못된 장치 내장 %select{표면|텍스처}0 참조 클래스 템플릿 %1 여기서 선언되었습니다'
# 'illegal device builtin %select{surface|texture}0 reference type %1 declared here'
H1DEC140E0334: '잘못된 장치 내장 %select{표면|텍스쳐}0 참조 형식 %1이 여기에서 선언되었습니다'
# 'illegal initializer (only variables can be initialized)'
H371A1BFF13F4: '유효하지 않은 초기화기 (초기화할 수 있는 것은 변수만입니다)'
# 'illegal initializer type %0'
H000E8C02D9A4: '잘못된 초기식 타입 %0'
# 'illegal interface qualifier'
H247C18DEFCA4: '잘못된 인터페이스 수식자'
# 'illegal operation on Objective-C container subscripting'
H1CDC7C944B48: 'Objective-C 컨테이너 구독(subscripting) 연산에 대한 허용되지 않은 연산'
# 'illegal qualifiers on @catch parameter'
H2C6EDFE337AA: 'catch 매개변수에 잘못된 자격 지정이 있습니다.'
# "illegal redeclaration of 'readwrite' property in class extension %0 (perhaps you intended this to be a 'readwrite' redeclaration of a 'readonly' public property?)"
H77F956612F13: "클래스 확장 %0에서 'readwrite' 속성의 잘못된 재선언 (이것이 'readonly' 공용 속성의 'readwrite' 재선언을 원하셨는지 모르겠습니다)"
# "illegal redeclaration of property in class extension %0 (attribute must be 'readwrite', while its primary must be 'readonly')"
HA09E774D29B3: "클래스 확장의 속성 %0에 대한 잘못된 재선언 (속성은 'readwrite'여야 하며, 기본은 'readonly'여야 합니다)"
# 'illegal scalar extension cast on argument %0 to %select{|in}1out paramemter'
HF91E5CAEA96B: '인자 %0에 대한 %select{|in}1out paramemter로의 불법 스칼라 확장 캐스트'
# 'illegal storage class on file-scoped variable'
H601564466459: '파일 범위 변수에 대한 잘못된 storage class'
# 'illegal storage class on function'
H930E494BEBBE: '함수에 유효하지 않은 저장 클래스가 지정되었습니다'
# 'illegal type %0 used in a boxed expression'
H5782BEFABE5B: '박싱된 표현식에서 사용된 %0는 유효하지 않은 형식입니다'
# 'illegal vector component name %0'
H6F3BE393AEDE: '허용되지 않는 벡터 구성 요소 이름 %0'
# 'illegal visibility specification'
H39F781806C46: '잘못된 가시성 지정'
# 'imaginary constants are a C2y extension'
HAF201E910158: '허수 상수는 C2y 확장 기능입니다'
# 'imaginary constants are a GNU extension'
H539EC610843E: '허수 상수는 GNU 확장 기능입니다'
# 'imaginary constants are incompatible with C standards before C2y'
H8F7EDEA31FE9: '허수 상수는 C2y 이전의 C 표준과 호환되지 않습니다.'
# 'imaginary types are not supported'
H8AEF701858F7: '허구 타입은 지원되지 않습니다.'
# 'immediate function %0 used before it is defined'
H1A240E8F6E49: '즉각적인 함수 %0가 정의되기 전에 사용되었습니다'
# 'implementing deprecated %select{method|class|category}0'
H9AA979884A67: '비추천된 %select{method|class|category}0을 구현 중입니다'
# 'implementing unavailable method'
H0D7D4644123A: '사용할 수 없는 메서드를 구현 중입니다.'
# 'implicit %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 inferred target collision: call to both %select{__device__|__global__|__host__|__host__ __device__}1 and %select{__device__|__global__|__host__|__host__ __device__}2 members'
HDD95624FC57A: '암시적 %select{기본 생성자|복사 생성자|이동 생성자|복사 대입 연산자|이동 대입 연산자|소멸자}0 추론된 타겟 충돌: %select{__device__|__global__|__host__|__host__ __device__}1 및 %select{__device__|__global__|__host__|__host__ __device__}2 멤버 둘 다 호출'
# "implicit '0' return value from 'main' is a C99 extension"
HDE00C37DFBCC: "'main'에서의 암시적 '0' 반환 값은 C99 확장 기능입니다"
# 'implicit boolean conversion of Objective-C object literal always evaluates to true'
HFAC6148E9355: 'Objective-C 객체 리터럴의 암시적 불리언 형변환은 항상 true로 평가됩니다'
# "implicit capture of 'this' with a capture default of '=' is deprecated"
H7D01BFC1D4A1: "'=' 기본 캡처 설정과 함께 'this'를 암시적으로 캡처하는 것은 더 이상 사용되지 않습니다."
# 'implicit capture of lambda object due to conversion to block pointer here'
H9CBFA98934C5: '람다 객체의 암시적 캡처는 여기서 블록 포인터로의 변환으로 인해 발생했습니다'
# 'implicit cast from type %0 to type %1 drops __unaligned qualifier'
HBCE299280FC0: '타입 %0에서 타입 %1로의 암시적 캐스트가 __unaligned 지정자를 제거합니다'
# 'implicit conversion between pointer-to-function and pointer-to-object is a Microsoft extension'
HE1B9297E3DCF: '함수 포인터와 객체 포인터 간의 암시적 변환은 Microsoft 확장 기능입니다'
# "implicit conversion between vector types ('%0' and '%1') is deprecated; in the future, the behavior implied by '-fno-lax-vector-conversions' will be the default"
HD9008DAA3AF0: "벡터 유형 간의 암시적 변환('%0'과 '%1')은弃用됨; 미래에는 '-fno-lax-vector-conversions' 옵션에 의해 결정되는 동작이 기본이 될 것입니다"
# 'implicit conversion changes signedness: %0 to %1'
H2AEC008E19C8: '암시적 변환으로 부호가 바뀌었습니다: %0에서 %1로'
# 'implicit conversion discards imaginary component: %0 to %1'
H5E6175D2FC4A: '암시적 변환이 허수 부분을 제거합니다: %0에서 %1로'
# 'implicit conversion from %0 cannot fit within the range of values for %1'
HC3B95ADC5255: '%0에서의 암시적 변환은 %1의 범위 내에 맞지 않습니다'
# 'implicit conversion from %0 to %1 changes non-zero value from %2 to %3'
H5699AB9A4A11: '암시적 변환 %0에서 %1로 변환 시, 0이 아닌 값이 %2에서 %3으로 변경됩니다'
# "implicit conversion from %0 to %1 changes the meaning of the %select{code unit|code point}2 '%3'"
HB7C90A078D7A: "암시적 변환 %0에서 %1로 %select{코드 단위|코드 포인트}2 '%3'의 의미를 변경함"
# 'implicit conversion from %0 to %1 changes value from %2 to %3'
H3C62B43256C2: '암시적 변환으로 %0에서 %1로 변환 시 값이 %2에서 %3으로 변경됩니다'
# "implicit conversion from %0 to %1 discards 'cfi_unchecked_callee' attribute"
HA1DC9D474D83: "암시적 변환 %0에서 %1로 'cfi_unchecked_callee' 속성을 무시함"
# 'implicit conversion from %0 to %1 is not permitted in C++'
HD43915D50111: 'C++에서 %0에서 %1로의 암시적 변환은 허용되지 않습니다'
# 'implicit conversion from %0 to %1 may change the meaning of the represented code unit'
H9A77784FE5D1: '암시적 변환 %0에서 열거형 유형 %1로 표현된 코드 단위의 의미를 변경할 수 있음'
# 'implicit conversion from %0 to %1 may lose precision'
H1D559B11094C: '암시적 변환으로 %0에서 %1로 변환 시 정밀도가 손실될 수 있습니다'
# 'implicit conversion from %0 to %1 may lose precision and change the meaning of the represented code unit'
HA74C62CA22F2: '암시적 변환 %0에서 %1로 정밀도를 잃을 수 있으며 표현된 코드 단위의 의미를 변경할 수 있음'
# 'implicit conversion from %0 to enumeration type %1 is invalid in C++'
H1F403D06A877: 'C++에서 암시적 변환 %0에서 열거형 유형 %1로는 무효임'
# 'implicit conversion from %2 to %3 changes value from %0 to %1'
H9616CD29DFC9: '암시적 변환으로 %2에서 %3으로 변경 시 값이 %0에서 %1로 변경됩니다'
# 'implicit conversion from array size expression of type %0 to %select{integral|enumeration}1 type %2 is a C++11 extension'
H1C73815D89AE: '유형 %0인 배열 크기 표현식에서 %select{integral|enumeration}1 유형 %2로의 암시적 변환은 C++11 확장 기능입니다'
# 'implicit conversion from array size expression of type %0 to %select{integral|enumeration}1 type %2 is incompatible with C++98'
HBA0FE5371598: '배열 크기 표현식의 타입 %0에서 %select{정수형|열거형}1 타입 %2로의 암시적 형변환은 C++98과 호환되지 않습니다'
# "implicit conversion from constant value %0 to 'BOOL'; the only well defined values for 'BOOL' are YES and NO"
H9F3E57EE843E: '상수 값 %0을 ‘BOOL’로 암시적으로 변환했습니다; ‘BOOL’ 형식의 유일하게 정의된 값은 YES와 NO뿐입니다'
# 'implicit conversion from enumeration type %0 to different enumeration type %1'
HEE824DA3A047: '열거형 타입 %0에서 다른 열거형 타입 %1로의 암시적 변환'
# "implicit conversion from floating-point type %0 to 'BOOL'"
H4747E2EB6787: "부동 소수점 형식 %0에서 'BOOL'로의 암시적 변환"
# "implicit conversion from integral type %0 to 'BOOL'"
H2BF4B2ABD201: "정수 형식 %0에서 'BOOL'로의 암시적 변환"
# 'implicit conversion from nullable pointer %0 to non-nullable pointer type %1'
H2C9C47D2B30E: 'null 허용 포인터 %0에서 null 불가 포인터 형식 %1로의 암시적 변환'
# 'implicit conversion increases floating-point precision: %0 to %1'
HA48CBAE7D71E: '암시적 변환은 부동소수점 정밀도를 증가시킵니다: %0에서 %1으로'
# 'implicit conversion loses floating-point precision: %0 to %1'
H8151E8B82266: '암시적 변환으로 부동 소수점 정밀도가 손실됨: %0에서 %1로'
# 'implicit conversion loses integer precision: %0 to %1'
H7E75B58A91F6: '암시적 변환 시 정수 정밀도 손실: %0에서 %1로'
# 'implicit conversion loses integer precision: %0 to %1 on negation'
H166C8894D74F: '암시적 변환이 정수 정밀도를 잃음: 부정 시 %0에서 %1로'
# 'implicit conversion of %select{NULL|nullptr}0 constant to %1'
H81DB38ED2223: '%select{NULL|nullptr}0 상수를 %1 유형으로 암시적 변환'
# 'implicit conversion of out of range value from %0 to %1 is undefined'
H60829B0B819C: '범위를 벗어난 값의 %0에서 %1로의 암시적 변환은 정의되지 않았습니다'
# 'implicit conversion truncates vector: %0 to %1'
H678147335701: '암시적 변환으로 벡터가 절삭됩니다: %0에서 %1로'
# 'implicit conversion turns floating-point number into bool: %0 to %1'
HBD45EEBA1C30: '암시적 변환은 부동 소수점 값을 불 값으로 바꿉니다: %0에서 %1로'
# 'implicit conversion turns floating-point number into integer: %0 to %1'
H1859EAB52A1F: '암시적 변환이 부동 소수점 숫자를 정수로 변환합니다: %0에서 %1로'
# 'implicit conversion turns string literal into bool: %0 to %1'
H0BABC92466FD: '암시적 변환으로 문자열 리터럴을 bool로 변환합니다: %0에서 %1로'
# 'implicit conversion turns vector to scalar: %0 to %1'
HB2E373F67C4B: '암시적 변환으로 벡터가 스칼라로 변환됩니다: %0에서 %1로'
# 'implicit conversion when %select{%diff{assigning to $ from type $|assigning to type from type}0,1|%diff{passing $ to parameter of type $|passing type to parameter of type}0,1|%diff{returning $ from a function with result type $|returning type from a function with result type}0,1|<CLANG BUG IF YOU SEE THIS>|%diff{initializing $ with an expression of type $|initializing type with an expression of type}0,1|%diff{sending $ to parameter of type $|sending type to parameter of type}0,1|<CLANG BUG IF YOU SEE THIS>}2 is not permitted in C++'
H0D8004D76948: 'C++에서 다음의 암시적 변환이 허용되지 않음: %select{%diff{타입 $에서 $로 할당|타입에서 타입 $로 할당}0,1|%diff{타입 $의 매개변수에 $ 전달|타입의 매개변수에 타입 전달}0,1|%diff{결과 타입 $의 함수에서 $ 반환|결과 타입의 함수에서 타입 반환}0,1|<CLANG 버그 - 이 메시지를 본 경우>|%diff{타입 $로 $ 초기화|타입으로 타입 초기화}0,1|%diff{타입 $의 매개변수에 $ 전송|타입의 매개변수에 타입 전송}0,1|<CLANG 버그 - 이 메시지를 본 경우>}2'
# 'implicit conversion when assigning computation result loses floating-point precision: %0 to %1'
H063DB898AD67: '계산 결과를 할당하는 과정에서 암시적 변환으로 부동 소수점 정밀도를 잃어: %0에서 %1로'
# 'implicit conversions between vector types (%0 and %1) are not permitted'
HDD25DAA03F93: '벡터 유형 간의 암시적 변환(%0과 %1)은 허용되지 않습니다'
# 'implicit declaration introduced by elaborated type conflicts with a %select{non-struct type|non-class type|non-union type|non-enum type|typedef|type alias|template|type alias template|template template argument}0 of the same name'
H0AA0DBCCB1F5: '확장 형식에 의해 도입된 암묵적 선언이 동일한 이름을 가진 %select{구조体型이 아닌 형식|클래스型이 아닌 형식|유니온型이 아닌 형식|열거형이 아닌 형식|typedef|type alias|템플릿|타입 별칭 템플릿|템플릿 템플릿 인자}0과 충돌합니다'
# 'implicit declaration of function %0'
H1E9139CA3E1D: '함수 %0의 암시적 선언'
# "implicit deduction guide declared as '%0'"
H2EE915923496: "암시적 추론 가이드가 '%0'로 선언되었습니다"
# 'implicit default constructor suppressed by user-declared constructor'
H2B519469152F: '사용자가 선언한 생성자로 인해 암시적 기본 생성자가 억제되었습니다.'
# 'implicit instantiation of undefined member %0'
H2427990A2EAB: '정의되지 않은 멤버 %0의 암시적 실체화'
# 'implicit truncation from %2 to a one-bit wide bit-field changes value from %0 to %1'
H46C1BDEE4300: '%2에서 1비트 폭의 비트 필드로의 암시적 축소로 인해 값이 %0에서 %1로 변경됩니다'
# 'implicit truncation from %2 to bit-field changes value from %0 to %1'
HB32D8742297B: '암시적 잘림으로 %2에서 비트 필드로 변환하면 값이 %0에서 %1로 변경됩니다'
# 'implicit use of sequentially-consistent atomic may incur stronger memory barriers than necessary'
H162AB39C9F24: '암시적으로 순차적 일관성 원자를 사용하면 필요한 것보다 더 강한 메모리 베리어가 발생할 수 있습니다'
# "implicitly declaring library function '%0' with type %1"
H452F7C0F821A: "암시적으로 라이브러리 함수 '%0'를 타입 %1으로 선언 중입니다"
# 'implicitly determined as %0'
HD0131FA6D64A: '암시적으로 %0로 결정됨'
# "implicitly disabling vptr sanitizer because rtti wasn't enabled"
HABA9C105D8F8: 'rtti가 활성화되지 않았기 때문에 vptr 샌타이저를 암시적으로 비활성화합니다'
# "implicitly treating version as '%0'"
H5C5C4BA079A3: "암시적으로 버전을 '%0'으로 처리함"
# 'import %select{module|name}0 (%1) does not match the import %select{module|name}0 (%2) of the previous declaration'
HE913E2E83F88: 'import %select{모듈|이름}0 (%1)은 이전 선언의 import %select{모듈|이름}0 (%2)와 일치하지 않습니다'
# 'import %select{module|name}0 cannot be applied to a function with a definition'
HB24CB23A8286: 'import %select{모듈|이름}0는 정의가 있는 함수에는 적용할 수 없습니다'
# 'import of C++ module \'%0\' appears within extern "C" language linkage specification'
HDAEE51A4DB06: 'C++ 모듈 \'%0\'의 import가 extern "C" 언어 연결 지정 내부에 위치합니다'
# "import of module '%0' appears within %1"
H08448256C67A: "모듈 '%0'의 import가 %1 내부에 있습니다"
# "import of module '%0' appears within its own %select{interface|implementation}1"
HBF7F549ECBD5: "모듈 '%0'의 import가 자신의 %select{인터페이스|구현}1 내부에 위치합니다"
# "import of module '%0' appears within same top-level module '%1'"
H25D86D4DF122: "모듈 '%0'의 import가 같은 최상위 모듈 '%1' 내에서 발생합니다."
# "import of module '%0' imported non C++20 importable modules"
H861EDFB67C5B: "모듈 '%0'의 import 시 C++20 호환 모듈이 아닌 모듈을 가져왔습니다."
# "import of shadowed module '%0'"
HECE190C4501D: "蔕覆된 모듈 '%0'의 임포트"
# "imported AST from '%0' had been generated for a different target, current: %1, imported: %2"
H30A99270FD50: '‘%0’에서 가져온 AST는 다른 대상용으로 생성되었습니다. 현재: %1, 가져온 대상: %2'
# "imported by %select{|module '%2' in }1'%0'"
HBA6CF98B38A4: "%select{|모듈 '%2'의 }1'%0'에 의해 import 되었습니다"
# 'importing an implementation partition unit in a module interface is not recommended. Names from %0 may not be reachable'
H4BCD18B5E018: '모듈 인터페이스에서 구현 파티션 유닛을 가져오는 것은 권장되지 않습니다. %0의 이름들은 접근할 수 없을 수 있습니다'
# "importing module '%0'%select{| into '%3'}2 from '%1'"
HD074A7D9BA2D: "모듈 '%0'%select{ | '%3'으로 }2 '%1'에서 가져오고 있습니다"
# 'imports must immediately follow the module declaration'
H25C0CF982742: 'import 문은 모듈 선언 바로 다음에 와야 합니다'
# 'impossible constraint in asm: cannot store value into a register'
HEC9C616BA3F9: '어셈블리에서 불가능한 제약: 레지스터에 값을 저장할 수 없습니다'
# 'in %select{implicit|defaulted}0 %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}1 for %2 first required here'
H7F88B1ED021A: '%select{암시적|암시적 정의된}0 %select{기본 생성자|복사 생성자|이동 생성자|복사 할당 연산자|이동 할당 연산자|소멸자}1을 위한 %2에서 처음 요구됨'
# "in call to '%0'"
H5F44B6591F5A: "함수 호출 '%0'에서"
# "in call to printing function with arguments '(%0)' while dumping struct"
H5B10BE57CF69: "구조체를 dump하는 중에 인쇄 함수 호출 시 인자 '(%0)'를 사용하는 중입니다"
# 'in defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator for %1 first required here'
H41C2C013E2E2: '기본으로 지정된 %select{<ERROR>|등가성|세 방향|등가성|관계}0 비교 연산자에서 %1의 첫 번째 요구 사항이 여기서 필요합니다'
# 'in evaluating default argument here'
HA6EC671D8C49: '여기서 기본 인수를 평가하는 중'
# 'in evaluation of exception specification for %q0 needed here'
H94CE96486393: '%q0의 예외 지정 평가 중 여기에서 필요함'
# 'in first definition, possible difference is here'
HAF3474709EF4: '첫 번째 정의에서, 차이가 발생할 수 있는 부분입니다'
# "in implicit call to 'operator%select{!=|*|++}0' for iterator of type %1"
HA1274A4A4765: "타입 %1의 반복자에 대해 'operator%select{!=|*|++}0'의 암시적 호출 중"
# 'in implicit initialization for inherited constructor of %0'
HE4CCA87F39AA: '상속된 생성자의 %0에 대한 암시적 초기화 중'
# 'in implicit initialization of %select{array element %1 with omitted initializer|field %1 with omitted initializer|trailing array elements in runtime-sized array new}0'
HD4BCA75D333B: '%select{초기화자 누락된 배열 요소 %1|초기화자 누락된 필드 %1|런타임 크기 배열 new의 후미 배열 요소들}0의 암시적 초기화 중에'
# 'in implicit initialization of binding declaration %0'
H6B3B1A4A0790: '바인딩 선언 %0의 암시적 초기화 중'
# 'in initialization of temporary of type %0 created to list-initialize this reference'
H5C5815C0F326: '이 참조를 리스트 초기화하기 위해 생성된 %0 유형의 일시적 객체를 초기화하는 중에'
# "in instantiation of default argument for '%0' required here"
H920C89F748D0: "디폴트 인수 '%0'의 인스턴스화가 여기에서 필요합니다"
# "in instantiation of default function argument expression for '%0' required here"
H05CBF7F0C1EE: '‘%0’의 기본 함수 인수 표현식 인스턴스화 중 여기에서 필요합니다'
# 'in instantiation of default member initializer %q0 requested here'
HD2F44CDF38B1: '인스턴스화 중 기본 멤버 초기화자 %q0가 여기서 요청됨'
# 'in instantiation of enumeration %q0 requested here'
H6EB646EE227A: '열거형 %q0의 인스턴스화가 여기서 요청되었습니다'
# 'in instantiation of exception specification for %0 requested here'
H3C01A542E6EB: '인스턴스화 중 예외 사양 %0가 여기에서 요청되었습니다'
# 'in instantiation of function template specialization %q0 requested here'
HAEB9C4D2EE7B: '함수 템플릿 특수화 %q0의 인스턴스화가 여기서 요청되었습니다'
# 'in instantiation of member class %q0 requested here'
H5CE23327E7F1: '멤버 클래스 %q0의 인스턴시에이션이 여기에서 요청되었습니다'
# 'in instantiation of member function %q0 requested here'
H748A89FD0314: '멤버 함수 %q0의 인스턴스화가 여기에서 요청되었습니다'
# 'in instantiation of requirement here'
HE12670012001: '요구 조건의 인스턴스화 중 여기에서 발생'
# 'in instantiation of requirement parameters here'
HCD143B7FE64F: '요구 사항 매개변수 여기서 인스턴스화 중'
# 'in instantiation of static data member %q0 requested here'
H0491530140D7: '정적 데이터 멤버 %q0의 인스턴스화가 여기에서 요청되었습니다'
# 'in instantiation of template class %q0 requested here'
H65B85839EF55: '템플릿 클래스 %q0의 인스턴스화가 여기에서 요청되었습니다.'
# 'in instantiation of template type alias %0 requested here'
HAECA7764FC0E: '템플릿 타입 별칭 %0의 인스턴스화가 여기서 요청되었습니다'
# 'in instantiation of variable template specialization %q0 requested here'
H0FA1B781E861: '변수 템플릿 전문화 %q0의 인스턴스화가 여기서 요청되었습니다'
# 'in lowering create ArrayCoorOp instead of CoordinateOp'
H38357B1F88DE: 'lowering 시 ArrayCoorOp를 생성하고 CoordinateOp 대신 사용하십시오.'
# 'in non-LBR mode, guess edge counts using iterative technique'
H7372BDB68057: '비 LBR 모드에서는 반복 기법을 사용하여 에지 개수를 추정합니다'
# "in pattern '%1': %0"
H2F43FF1537BC: "패턴 '%1'에서: %0"
# 'in relocation mode trap upon entry to any function that uses AVX-512 instructions'
H082BA4E3D29F: '리로케이션 모드에서 AVX-512 명령어를 사용하는 모든 함수의 진입 시 트랩합니다.'
# 'in second definition, possible difference is here'
HEC9D50C16660: '두 번째 정의에서, 차이가 있을 수 있는 부분입니다'
# 'in template expansion here'
H1E2D3625EAB4: '여기에서 템플릿 확장 중'
# 'in the default initializer of %0'
H6D9691DC0D28: '기본 초기화자의 %0에서'
# 'in value-initialization of type %0 here'
H74E349C94BB1: '값 초기화(value-initialization) 중 %0 형식 유형에서 여기'
# 'in%select{| implicit}0 constructor here'
H24F20A5C047E: '이%select{ | 암시적 }0 생성자 여기'
# 'in-class initializer for static data member is not a constant expression'
H9B69A27F211E: '정적 데이터 멤버의 클래스 내 초기화자는 상수 표현식이 아닙니다'
# 'in-class initializer for static data member is not a constant expression; folding it to a constant is a GNU extension'
HA2848C2F37A8: '정적 데이터 멤버의 클래스 내부 초기화자는 상수 표현식이 아닙니다; 이를 상수로 폴딩하는 것은 GNU 확장 기능입니다'
# 'in-class initializer for static data member of type %0 is a GNU extension'
H46A5C414A183: '정적 데이터 멤버의 유형 %0에 대한 클래스 내 초기화자는 GNU 확장입니다.'
# "in-class initializer for static data member of type %0 requires 'constexpr' specifier"
H7E9F22B76B86: "정적 데이터 멤버의 %0 형식에 대한 클래스 내부 초기화자는 'constexpr' 지정자가 필요합니다"
# 'in_reduction variable must have the same reduction operation as in a task_reduction clause'
H7647CFB2C410: 'in_reduction 변수는 task_reduction 절의 것과 동일한 reduction operation을 가져야 합니다'
# 'include a detailed record of preprocessing actions'
H4B25771F85AC: '预处理 작업의 상세 기록을 포함하십시오.'
# "include location '%0' is unsafe for cross-compilation"
H62F3D6400A8A: "인클루드 위치 '%0'는 크로스 컴파일에 안전하지 않습니다"
# 'include module search paths'
HFFA588262B00: '인클루드 모듈 검색 경로'
# "include of non-modular header inside framework module '%0': '%1'"
H82B29FF5B7DD: "프레임워크 모듈 '%0' 내에서 비모듈 헤더 포함: '%1'"
# "include of non-modular header inside module '%0': '%1'"
H747C5EDF3216: "모듈 '%0' 내부에서 비모듈식 헤더를 포함했습니다: '%1'"
# "include path for libstdc++ headers not found; pass '-stdlib=libc++' on the command line to use the libc++ standard library instead"
H45B1E0C04AB4: "libstdc++ 헤더 파일을 위한 include 경로를 찾을 수 없음; 명령줄에 '-stdlib=libc++'을 전달하여 libc++ 표준 라이브러리를 대신 사용하십시오"
# 'include search path'
H43B868761DFC: '헤더 파일 검색 경로'
# "include the header <%0> or explicitly provide a declaration for '%1'"
HBFC18315E2CB: "헤더 <%0>를 포함하거나, 명시적으로 '%1'에 대한 선언을 제공하십시오"
# 'incompatible block pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2'
HA4D550DCCECE: '포인터 타입 호환성 오류 %select{%diff{변수 $에 $를 할당|다른 타입으로 할당}0,1|%diff{$를 $ 타입 매개변수에 전달|다른 타입 매개변수에 전달}0,1|%diff{결과 타입 $인 함수에서 $를 반환|다른 반환 타입 함수에서 반환}0,1|%diff{$를 $ 타입으로 변환|타입 간 변환}0,1|%diff{$ 타입 표현식으로 $ 초기화|다른 타입 표현식으로 초기화}0,1|%diff{$를 $ 타입 매개변수에 전송|다른 타입 매개변수에 전송}0,1|%diff{$를 $ 타입으로 캐스팅|타입 간 캐스팅}0,1}2'
# 'incompatible constant for this __builtin_neon function'
H338324E39A33: '이 __builtin_neon 함수에 대한 호환되지 않는 상수'
# 'incompatible function pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3'
H803DA0209C00: '포인터 형식 호환성 오류: %select{%diff{할당하는 $에서 $에 |다른 형식으로 할당}0,1|%diff{$ 형식의 매개변수에 $ 전달 |다른 형식의 매개변수에 전달}0,1|%diff{결과 형식이 $인 함수에서 $ 반환 |다른 반환 형식의 함수에서 반환}0,1|%diff{$를 $ 형식으로 변환 |형식 간 변환}0,1|%diff{$ 형식의 표현식으로 $ 초기화 |다른 형식의 표현식으로 초기화}0,1|%diff{$ 형식의 매개변수에 $ 전송 |다른 형식의 매개변수에 전송}0,1|%diff{$를 $ 형식으로 캐스팅 |형식 간 캐스팅}0,1}2%select{|; 포인터 해제를 위해 * 연산자 사용|; 주소 얻기 위해 & 연산자 사용|; * 제거|; & 제거}3'
# 'incompatible integer to pointer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3'
H48B50F4A5A68: 'incompatible integer to pointer conversion %select{%diff{ $에 $를 할당|다른 형식으로 할당 }0,1|%diff{ $를 $ 형식의 매개변수에 전달|다른 형식의 매개변수에 전달 }0,1|%diff{ $에서 결과 형식 $로 반환|다른 반환 형식으로 함수에서 반환 }0,1|%diff{ $를 형식 $로 변환|형식 간 변환 }0,1|%diff{ $를 형식 $ 표현식으로 초기화|다른 형식 표현식으로 초기화 }0,1|%diff{ $를 $ 형식의 매개변수에 전달|다른 형식의 매개변수에 전달 }0,1|%diff{ $를 형식 $로 캐스팅|형식 간 캐스팅 }0,1}2%select{|; 별호(*)로 해제|; &를 사용하여 주소 얻기|; 별호(*) 제거|; 앰퍼샌드(&) 제거}3'
# 'incompatible operand types (%0 and %1)'
HCEE400E94353: '호환되지 않는 피연산자 유형 (%0과 %1)'
# 'incompatible operand types%diff{ ($ and $)|}0,1'
H1FD3FD989888: '호환되지 않는 피연산자 유형%diff{ ($와 $)|}0,1'
# 'incompatible pointer to integer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3'
HFD878F5F2922: '포인터에서 정수로의 호환성 변환 오류 %select{%diff{ $1을 $2에서 할당|다른 타입으로 할당}0,1|%diff{ $1을 타입 $2의 매개변수에 전달|다른 타입의 매개변수로 전달}0,1|%diff{ $1을 결과 타입 $2인 함수에서 반환|반환 타입이 다른 함수에서 반환}0,1|%diff{ $1을 타입 $2로 변환|타입 간 변환}0,1|%diff{ $1을 타입 $2의 표현식으로 초기화|다른 타입의 표현식으로 초기화}0,1|%diff{ $1을 타입 $2의 매개변수에 전송|다른 타입의 매개변수로 전송}0,1|%diff{ $1을 타입 $2로 캐스팅|타입 간 캐스팅}0,1}2%select{|; 별호(*)로 해제하세요|; 주소를 &로 취득하세요|; 별호(*) 제거|; & 제거}3'
# 'incompatible pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3'
HBA7B4F7FCD76: '포인터 유형 불일치 %select{%diff{을 $에 할당함|다른 유형으로 할당함}0,1|%diff{유형 $ 매개변수에 전달함|다른 유형 매개변수에 전달함}0,1|%diff{결과 유형 $인 함수에서 $를 반환함|다른 반환 유형의 함수에서 반환함}0,1|%diff{유형 $로 변환함|유형 간 변환}0,1|%diff{유형 $ 표현식으로 $ 초기화|다른 유형 표현식으로 초기화}0,1|%diff{유형 $ 매개변수에 전송함|다른 유형 매개변수에 전송함}0,1|%diff{유형 $로 캐스팅|유형 간 캐스팅}0,1}2%select{|; 별(*)로 해제|; 앰퍼샌드(&)로 주소 취득|; 별(*) 제거|; 앰퍼샌드(&) 제거}3'
# 'incompatible pointer types passing retainable parameter of type %0to a CF function expecting %1 type'
H85C3F4475A3D: '호환되지 않는 포인터 유형: CF 함수가 %1 유형을 예상하는 데, %0 유형의 보존 가능한 매개변수를 전달했습니다.'
# 'incompatible redeclaration of library function %0'
H4DCB8A7133E4: '라이브러리 함수 %0의 호환되지 않는 재선언입니다'
# 'incompatible types casting %0 to %1 with a %select{__bridge|__bridge_transfer|__bridge_retained}2 cast'
HA70D951974C7: '호환되지 않는 형식: %0을 %1로 %select{__bridge|__bridge_transfer|__bridge_retained}2 캐스트로 캐스팅할 수 없습니다.'
# 'incompatible vector types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2'
H349444057F6C: '부적절한 벡터 타입 %select{%diff{를 에 할당함|타입이 다른 값 할당}0,1|%diff{매개변수 에 전달됨|타입이 다른 매개변수 전달}0,1|%diff{결과 타입 인 함수에서 반환됨|반환 타입이 다른 함수에서 반환}0,1|%diff{타입 에 변환|타입 간 변환}0,1|%diff{타입 의 표현식으로 초기화|타입이 다른 표현식으로 초기화}0,1|%diff{매개변수 에 전송|타입이 다른 매개변수 전송}0,1|%diff{타입 에 캐스팅|타입 간 캐스팅}0,1}2'
# 'incomplete definition of type %0'
H74F733EC60E9: '타입 %0의 정의가 완성되지 않았습니다'
# "incomplete delimited universal character name; treating as '\\' '%0' '{' identifier"
H45A3D640545C: "구분된 보편 문자 이름이 완전하지 않음; 대신 '\\' '%0' '{' 식별자로 처리함"
# 'incomplete format specifier'
HC2682570C017: '미완성 포맷 지정자'
# 'incomplete receiver type %0'
H6C117CF6E37A: '미완료 수신자 유형 %0'
# 'incomplete result type %0 in function definition'
HA8E1F3068B20: '함수 정의에서 불완전한 리턴 타입 %0'
# 'incomplete result type %0 in lambda expression'
H69E2641DED85: '람다 표현식에서 결과 타입 %0이(가) 완전하지 않습니다'
# "incomplete type %0 in a '_Generic' association is a C2y extension"
H7D3852AE4A16: "미완성 형식 %0가 '_Generic' 결합에 사용될 경우 C2y 확장 기능입니다"
# 'incomplete type %0 is not a literal type'
H8AFDEC1F2348: '미완성 형식 %0는 리터럴 형식이 아닙니다'
# 'incomplete type %0 is not assignable'
HF862B3215822: '완전하지 않은 타입 %0은 할당할 수 없습니다'
# 'incomplete type %0 named in nested name specifier'
HCA7665DF5910: '중첩된 이름 지정자에 이름이 지정된 미완성 형식 %0'
# 'incomplete type %0 used in a boxed expression'
HF426C73BD83F: '완전하지 않은 형 %0이 박싱된 표현식에서 사용되었습니다'
# 'incomplete type %0 used in type trait expression'
H4539C0CCBFB9: '완성되지 않은 형식 %0이 형식 특성 표현식에서 사용되었습니다'
# 'incomplete type %0 where a complete type is required'
H95C11FF1D056: '완전하지 않은 형식 %0가 완전한 형식이 필요한 위치에서 사용되었습니다'
# 'incomplete type in call to object of type %0'
HB57B0356D109: '형식 %0의 객체를 호출할 때 완전하지 않은 형식'
# 'incomplete universal character name'
H0184822E59BB: '완전하지 않은 보편 문자 이름'
# "incomplete universal character name; treating as '\\' followed by identifier"
H5B8C01DBAD90: '불완전한 유니버설 문자 이름; 백슬래시(\\) 뒤에 identifier로 간주함'
# 'inconsistent number of instance variables specified'
H7EB07F9DCA1E: '지정된 인스턴스 변수의 수가 일치하지 않습니다'
# "incorrect 'adjust_args' type, expected 'need_device_ptr'%select{|, 'need_device_addr',}0 or 'nothing'"
H1403BB6ED4C3: "잘못된 'adjust_args' 유형입니다. 'need_device_ptr'%select{|, 'need_device_addr',}0 또는 'nothing'이(가) 필요합니다"
# 'incorrect format for -preamble-bytes=N,END'
HD764A19076F3: '올바른 형식이 아닙니다: -preamble-bytes=N,END'
# "incorrect map type modifier, expected one of: 'always', 'close', 'mapper'%select{|, 'present'|, 'present', 'iterator'}0%select{|, 'ompx_hold'}1%select{|, 'self'}2"
H6BCE6C4F91C6: "잘못된 맵 타입 수정자, 다음 중 하나가 필요합니다: 'always', 'close', 'mapper'%select{|, 'present'|, 'present', 'iterator'}0%select{|, 'ompx_hold'}1%select{|, 'self'}2"
# "incorrect map type, expected one of 'to', 'from', 'tofrom', 'alloc', 'release', or 'delete'"
HFC0556B7E292: "올바르지 않은 맵 형식입니다. 다음 중 하나가 예상됩니다: 'to', 'from', 'tofrom', 'alloc', 'release', 또는 'delete'"
# 'incorrect number of bits in integer (expected %0 bits, have %1)'
H39F86512F6F1: '정수의 비트 수가 잘못되었습니다 (예상 %0 비트, 현재 %1 비트)'
# 'incorrect number of bits in vector operand (expected %select{|a multiple of}0 %1 bits, have %2)'
HDF4134C84931: '벡터 연산자의 비트 수가 올바르지 않습니다 (기대한 %select{|의 배수}0 %1 비트가 필요하지만, %2 비트가 있습니다)'
# "incorrect reduction identifier, expected one of '+', '*', '&', '|', '^', '&&', '||', 'min' or 'max' or declare reduction for type %0"
HD90D2B65D413: "올바르지 않은 reduction 식별자입니다. 다음 중 하나가 필요합니다: '+', '*', '&', '|', '^', '&&', '||', 'min' 또는 'max', 또는 %0 유형에 대한 reduction을 선언해야 합니다"
# "incorrect reduction identifier, expected one of '+', '-', '*', '&', '|', '^', '&&', '||', 'min' or 'max' or declare reduction for type %0"
HC80B58A26C84: "잘못된 축약 식별자입니다. 다음 중 하나가 필요합니다: '+', '-', '*', '&', '|', '^', '&&', '||', 'min' 또는 'max' 또는 %0 유형에 대한 축약을 선언하세요."
# 'incorrect use of #pragma clang force_cuda_host_device begin|end'
HB4E983FB1A7D: '#pragma clang force_cuda_host_device begin|end 지시문을 잘못 사용했습니다'
# "incorrect use of '#pragma fenv_access (on|off)' - ignored"
HB0DD6B333D8B: "'#pragma fenv_access (on|off)'의 잘못된 사용 - 무시됨"
# "incorrect use of '#pragma ms_struct on|off' - ignored"
HB1C2DABF7753: "'#pragma ms_struct on|off'의 잘못된 사용 - 무시됨"
# 'increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable %0'
H1F62FE8343E9: 'OpenMP for 루프의 증분 절은 루프 변수 %0에 단순한 덧셈 또는 뺄셈을 수행해야 합니다'
# 'increment expression must cause %0 to %select{decrease|increase}1 on each iteration of OpenMP for loop'
H6AE9805023F0: '증감 표현식은 OpenMP for 루프의 각 반복에서 %0을 %select{감소시키거나|증가시켜야 합니다}1'
# 'incremented enumerator value %0 is not representable in the largest integer type'
H33F55260A9EF: '증가된 열거형 값 %0는 가장 큰 정수형 유형에서 표현할 수 없습니다'
# 'incrementing expression of type bool is deprecated and incompatible with C++17'
HB438D9D07956: 'bool 형식의 증분 표현은 C++17과 호환되지 않으며 구식입니다.'
# 'increments 8-bit counter for every edge'
H286B107846BC: '8비트 카운터를 각 에지마다 증가시킵니다'
# "indeterminate value can only initialize an object of type 'unsigned char'%select{, 'char',|}1 or 'std::byte'; %0 is invalid"
H26C79B7B3090: "미결정 값은 'unsigned char'%select{, 'char',|}1 또는 'std::byte' 유형의 객체만 초기화할 수 있습니다; %0는 유효하지 않습니다"
# 'index %0 must appear exactly once in the permutation clause'
H907BCB3D7A64: '인덱스 %0는 순열 절 내에서 정확히 한 번 나타나야 합니다'
# 'index for __builtin_shufflevector must be a constant integer'
H2AA72873C8D9: '__builtin_shufflevector의 인덱스는 상수 정수여야 합니다'
# 'index for __builtin_shufflevector must be less than the total number of vector elements'
HDC5D16284BAC: '__builtin_shufflevector 인덱스는 벡터 요소의 총 수보다 작아야 합니다'
# 'index for __builtin_shufflevector not within the bounds of the input vectors; index of -1 found at position %0 is not permitted in a constexpr context'
H0F3D61BA78F9: '__builtin_shufflevector의 인덱스가 입력 벡터의 경계를 벗어났습니다; 위치 %0에서 -1 인덱스가 발견되었으며 constexpr 컨텍스트에서는 허용되지 않습니다'
# 'indexing expression is invalid because subscript type %0 has multiple type conversion functions'
H28D375C7CDB6: '인덱싱 표현식이 유효하지 않습니다: 서브스크립트 형식 %0가 여러 타입 변환 함수를 가집니다'
# 'indexing expression is invalid because subscript type %0 is not an Objective-C pointer'
H76E63693A71C: '인덱싱 표현식이 유효하지 않습니다. 서브스크립트 형식 %0는 Objective-C 포인터가 아니기 때문입니다'
# 'indexing expression is invalid because subscript type %0 is not an integral or Objective-C pointer type'
H5DB003FBDC67: '인덱싱 표현식은 유효하지 않습니다. 인덱스 타입 %0가 정수형 또는 Objective-C 포인터 형식이 아니기 때문입니다.'
# 'indexing of array without known bound is not allowed in a constant expression'
HE2B8FD1CE633: '알 수 없는 경계를 가진 배열의 인덱싱은 상수 표현식에서 허용되지 않습니다'
# 'indirect call promotion'
H63A9B36F7D0A: '간접 호출 강화'
# 'indirect goto in function with no address-of-label expressions'
H145FEAAFA432: '주소-라벨 표현이 없는 함수에서 간접 goto 사용'
# 'indirection not permitted on operand of type %0'
H2DF3DCAF7C13: '인디렉션이 %0 유형의 피연산자에서 허용되지 않습니다.'
# 'indirection of non-volatile null pointer will be deleted, not trap'
H016B5CE240D6: '비볼래블 null 포인터의 간접 접근은 삭제되어 트랩되지 않습니다'
# 'indirection requires pointer operand (%0 invalid)'
H17A67BCCC65A: '간접 참조는 포인터 연산자가 필요합니다 (%0 유효하지 않음)'
# 'infer execution count for fall-through blocks'
H5D8BF838CEAA: '폴스루 블록의 실행 횟수 추론'
# "inferred framework modules cannot be 'explicit'"
HAC0CEE5A9591: "추론된 프레임워크 모듈은 'explicit'일 수 없습니다"
# 'inferred submodule cannot be a framework submodule'
H3C9148B14284: '추론된 서브모듈은 프레임워크 서브모듈이 될 수 없습니다'
# 'inferred submodules require a module with an umbrella'
HB4F6C039EA5A: '추론된 서브모듈은 아우터카 모듈이 필요로 합니다.'
# "inferring '_Nonnull' for pointer type within %select{array|reference}0 is deprecated"
H0BCF4D33599B: '_Nonnull 추론이 %select{배열|참조}0 내 포인터 형식에서 폐지되었습니다'
# 'inheritance model does not match %select{definition|previous declaration}0'
H6F4F77A5056C: '상속 모델이 %select{정의|이전 선언}0과 일치하지 않습니다'
# 'inheritance model ignored on %select{primary template|partial specialization}0'
H5E5E4985C4D2: '상속 모델이 %select{주요 템플릿|부분 특수화}0에서 무시되었습니다.'
# 'inherited from base class %0 here'
H942CB9135C88: '여기서 기반 클래스 %0에서 상속 받음'
# 'inherited virtual base class %1 has %select{private|protected}2 destructor'
HC776172C0FE5: '상속된 가상 기본 클래스 %1에는 %select{private|protected}2 소멸자가 있습니다'
# 'inheriting constructors are incompatible with C++98'
H811CC4188AC3: '상속되는 생성자는 C++98과 호환되지 않습니다'
# 'inherits from superclass %0 here'
HFC19FC83A6FB: '여기서 %0 슈퍼클래스를 상속받습니다'
# 'init method must return a type related to its receiver type'
HE0B5DF2EAC96: 'init 메서드는 수신자 유형과 관련된 유형을 반환해야 합니다'
# 'init methods must return a type related to the receiver type'
H77EF2E241D1F: '초기화 메서드는 리시버 타입과 관련된 타입을 반환해야 합니다'
# 'init methods must return an object pointer type, not %0'
HA49BF476668F: '초기화 메서드는 객체 포인터 타입을 반환해야 합니다. %0가 아닌 타입을 반환할 수 없습니다'
# "initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')"
H55BD0EE327C7: "OpenMP for 루프의 초기화 절은 표준 형식('var = init' 또는 'T var = init')이 아닙니다"
# 'initialization is not supported for __shared__ variables'
H36A01643C5A6: '__shared__ 변수에 대한 초기화는 지원되지 않습니다.'
# 'initialization of %0 may run twice when built into a shared library: it has hidden visibility and external linkage'
H8FC0CAE3AC23: '%0의 초기화가 공유 라이브러리로 빌드될 때 두 번 실행될 수 있습니다: 숨겨진 가시성과 외부 결합을 가지고 있습니다'
# "initialization of %select{|signed }0char array with UTF-8 string literal is not permitted by %select{'-fchar8_t'|C++20}1"
H2A8B3176C3CF: "%select{|signed }0char 배열의 초기화에 UTF-8 문자열 리터럴을 사용하여는 %select{'-fchar8_t'|C++20}1에 의해 허용되지 않습니다"
# 'initialization of an array %diff{of type $ from a compound literal of type $|from a compound literal}0,1 is a GNU extension'
HA729653B7153: '배열 초기화 %diff{타입 $의 복합 리터럴 타입의|복합 리터럴의}0,1 은 GNU 확장입니다'
# 'initialization of flexible array member is not allowed'
H080F42BFBE3B: '유연한 배열 멤버의 초기화는 허용되지 않습니다'
# 'initialization of incomplete type %0'
H8382A60542C7: '미완료 타입 %0의 초기화'
# 'initialization of initializer_list object is incompatible with C++98'
HB868A7DFE86A: 'initializer_list 객체의 초기화는 C++98과 호환되지 않습니다'
# 'initialization of non-aggregate type %0 with a designated initializer list'
HD9BEB3E28681: '비집합 타입 %0를 지정된 초기화자 목록으로 초기화했습니다.'
# 'initialization of non-aggregate type %0 with an initializer list'
HD61976EAB0C6: '비집합 형식 %0을(를) 초기화자 목록으로 초기화 함'
# 'initialization of pointer of type %0 to null from a constant boolean expression'
HF7B6BD10B980: '유형 %0 포인터의 null 초기화는 상수 불리언 표현식에서 이루어졌습니다'
# 'initialization statement is not supported when iterating over Objective-C collection'
H6990A52E0D21: 'Objective-C 컬렉션을 반복할 때 초기화 문은 지원되지 않습니다.'
# 'initialize the variable %0 to silence this warning'
HFBFEA45EAD29: '변수 %0을 초기화하여 이 경고를 제거하세요'
# 'initialized flexible array member %0 is here'
H040CBD4967B6: '초기화된 유연한 배열 멤버 %0가 여기에 있습니다'
# 'initialized here %0'
H6E543F660366: '이 곳에서 초기화 됨 %0'
# 'initialized lambda capture packs are incompatible with C++ standards before C++20'
H4508A321B7A7: '초기화된 람다 캡처 패키지는 C++20 이전의 C++ 표준과 호환되지 않습니다.'
# 'initialized lambda captures are a C++14 extension'
HE17291BEDE3D: '초기화된 람다 캡처는 C++14 확장 기능입니다'
# 'initialized lambda captures are incompatible with C++ standards before C++14'
H4B4A5D06C778: 'C++14 이전의 C++ 표준과 호환되지 않는 초기화된 람다 캡처입니다'
# 'initialized lambda pack captures are a C++20 extension'
H7BA4847E4BDF: '초기화된 람다 패키지 캡처는 C++20 확장 기능입니다'
# 'initializer %0 does not name a non-static data member or base class; did you mean the %select{base class|member}1 %2?'
HBFA8CB0E43F8: '초기화자 %0는 비정적 데이터 멤버 또는 기반 클래스를 지정하지 않았습니다; 의도한 것은 %select{기반 클래스|멤버}1 %2일까요?'
# 'initializer %select{partially |}0overrides prior initialization of this subobject'
H5DE4CB24B2D2: '초기화자 %select{부분적으로 |}0이 부분 객체의 이전 초기화를 대체합니다'
# 'initializer element is not a compile-time constant'
H132D68BCCE73: '초기식 요소는 컴파일 타임 상수가 아닙니다.'
# 'initializer for aggregate is not a compile-time constant'
H6A5ECCAF1E62: '집합体型의 초기화자가 컴파일 타임 상수가 아닙니다'
# 'initializer for aggregate with no elements requires explicit braces'
H2820D73AEF2F: '요소가 없는 집합체를 위한 초기화자는 명시적인 중괄호가 필요합니다'
# 'initializer for functional-style cast to %0 contains multiple expressions'
H98881129A20C: '함수 스타일 캐스트에 사용되는 %0의 초기화자가 여러 식을 포함합니다'
# 'initializer for functional-style cast to %0 is empty'
H4EA4C8E23F55: '함수 스타일 형변환 %0에 대한 초기화자가 비어 있습니다'
# 'initializer for lambda capture %0 contains multiple expressions'
H66A3A7273E8A: '람다 캡처 %0의 초기화자에 여러 개의 표현식이 포함되었습니다'
# 'initializer for sizeless type %0 cannot be empty'
H8FFA617F38FD: '크기 없는 형 %0의 초기화자는 빈 값일 수 없습니다'
# 'initializer for thread-local variable must be a constant expression'
HD7C0523C87D0: '쓰레드 로컬 변수의 초기화자는 상수 표현식이어야 합니다.'
# 'initializer for variable %0 with type %1 contains multiple expressions'
HA7D83169E121: '초기화자에 변수 %0 (형 %1)에 여러 표현식이 포함되었습니다'
# 'initializer for variable %0 with type %1 is empty'
HD6A61B62F49C: '변수 %0의 타입 %1에 대한 초기화자가 비어 있습니다'
# 'initializer for virtual base class %0 of abstract class %1 will never be used'
H377D13F4BA4B: '추상 클래스 %1의 가상 기반 클래스 %0의 초기화자는 절대로 사용되지 않을 것입니다'
# "initializer list cannot be used on the %select{left|right}0 hand side of operator '%1'"
H08A1BB46A564: "초기화 목록은 연산자 '%1'의 %select{왼쪽|오른쪽}0 쪽에 사용될 수 없습니다"
# 'initializer missing for lambda capture %0'
H362962332DA4: '람다 캡처 %0의 초기화자가 누락되었습니다.'
# 'initializer of %0 is not a constant expression'
HF34500BAECA9: '%0의 초기화자는 상수 표현식이 아닙니다'
# 'initializer of %0 is unknown'
H4815D272C20B: '%0의 초기화자는 알 수 없습니다'
# 'initializer of weak variable %0 is not considered constant because it may be different at runtime'
HBD6BC73EA44F: '약 변수 %0의 초기화자는 실행 시 다를 수 있기 때문에 상수로 간주되지 않습니다'
# 'initializer on function does not look like a pure-specifier'
H79A85F4AF5C7: '함수의 초기화자는 순수 지정자처럼 보이지 않습니다.'
# 'initializer order does not match the declaration order'
HBA21FCA776B9: '초기화자의 순서가 선언 순서와 일치하지 않습니다'
# 'initializer priorities are not supported in HLSL'
HFAA073E424F4: '초기화 우선순위는 HLSL에서 지원되지 않습니다'
# 'initializer would partially override prior initialization of object of type %1 with non-trivial destruction'
H52C4E394B1C2: '초기화자는 비자명 소멸자를 가진 타입 %1의 객체에 대한 이전 초기화를 부분적으로 덮어쓰려고 합니다.'
# 'initializer-string for char array is too long'
HF948F6263A8D: 'char 배열에 대한 초기화 문자열이 너무 깁니다'
# 'initializer-string for char array is too long, array size is %0 but initializer has size %1 (including the null terminating character)'
H17CD335B9F9F: 'char 배열의 초기화 문자열이 너무 깁니다. 배열 크기는 %0이지만 초기화자 크기는 %1입니다(널 종료 문자를 포함합니다)'
# 'initializer-string for character array is too long for C++, array size is %0 but initializer has size %1 (including the null terminating character)'
H1C3EADBC5750: 'C++에서 문자 배열 초기화 문자열이 너무 깁니다. 배열 크기는 %0이(가) 있지만 초기화자의 크기는 %1입니다(널 종결 문자 포함)'
# "initializer-string for character array is too long, array size is %0 but initializer has size %1 (including the null terminating character); did you mean to use the 'nonstring' attribute?"
H4D31F68C37C8: "문자 배열 초기화 문자열이 너무 깁니다. 배열 크기는 %0이(가) 있지만 초기화자의 크기는 %1입니다(널 종결 문자 포함); 'nonstring' 속성을 사용하시겠습니까?"
# 'initializing %0 from an empty initializer list is incompatible with C++98'
H822723DC0E42: '초기화자 목록이 비어 있는 것으로 %0을 초기화하는 것은 C++98과 호환되지 않습니다'
# "initializing 'char8_t' array with plain string literal"
H1EA4AB240813: "일반 문자열 리터럴로 'char8_t' 배열 초기화"
# 'initializing an array from a %0 predefined identifier is a Microsoft extension'
HF1EC87683FC5: '마이크로소프트 확장 기능을 사용하여 %0 예정된 식별자를 통해 배열 초기화'
# 'initializing char array with wide string literal'
H698D73717CFB: 'char 배열을 와이드 문자열 리터럴로 초기화 중'
# 'initializing field %0 with default member initializer'
HC1BC6A14F9CB: '기본 멤버 초기화자를 사용하여 %0 필드를 초기화 중입니다'
# 'initializing multiple members of union'
HC7C97F10525A: '유니온의 여러 멤버 초기화'
# 'initializing parameter %0 with default argument'
H20102CE039A6: '기본 인수로 매개변수 %0를 초기화하는 중'
# 'initializing pointer member %0 to point to a temporary object whose lifetime is shorter than the lifetime of the constructed object'
H705DCA77F9DC: '생성된 객체의 생명 주기보다 더 짧은 생명 주기를 가진 일시적인 객체를 가리키도록 포인터 멤버 %0을 초기화합니다'
# 'initializing pointer member %0 with the stack address of %select{variable|parameter}2 %1'
HF09BD5727610: '포인터 멤버 %0를 %select{변수|매개변수}2 %1의 스택 주소로 초기화 중입니다'
# 'initializing wide char array with incompatible wide string literal'
HA0905D8F9102: '와이드 문자 배열을 호환되지 않는 와이드 문자열 리터럴로 초기화 중입니다'
# 'initializing wide char array with non-wide string literal'
H708EA2B0EAB3: '와이드 문자 배열을 일반 문자열 리터럴로 초기화'
# 'inline all checks'
HF0EA4880CACC: '모든 확인을 내부로 포함'
# 'inline all functions'
HEE76F6E2509B: '모든 함수를 inline 처리'
# 'inline assembly label %0 declared here'
H1FAD9492270E: '인라인 어셈블리 레이블 %0 여기에서 선언됨'
# 'inline declaration of %0 follows non-inline definition'
H9E262DCDBF26: '인라인 선언 %0가 비인라인 정의에 이어집니다'
# 'inline declaration of %0 not allowed in block scope'
H0812ED282234: '블록 범위에서 %0의 inline 선언은 허용되지 않습니다'
# 'inline function %q0 is not defined'
HC9FA92373F42: '인라인 함수 %q0는 정의되지 않았습니다'
# 'inline function not defined%select{| before the private module fragment}0'
H195EBE25939A: 'inline 함수가 정의되지 않았습니다%select{| private 모듈 프래그먼트 이전에}0'
# 'inline function performs a conversion which is forbidden in ARC'
H46AB09EDECD4: '인라인 함수가 ARC에서 금지된 변환을 수행합니다'
# 'inline functions based on how much of the function is a scop.'
H1DDDFC8B898C: '인라인 함수는 함수의 어느 정도가 SCoP인가에 따라 결정됩니다.'
# 'inline functions if increase in size is less than defined by -inline-small-functions-bytes'
HF2FBAE9C268E: '크기가 -inline-small-functions-bytes로 지정된 값보다 적게 증가하는 경우 인라인 함수 사용'
# 'inline functions with CFI programs (can break exception handling)'
H6C3FCE1081BE: '인라인 함수와 CFI 프로그램 (예외 처리를 방해할 수 있음)'
# 'inline leaf functions with CFI programs (can break unwinding)'
H8B9275AE6FE3: 'CFI 프로그램과 함께 리프 함수 인라인 (언윈딩을 방해할 수 있음)'
# "inline memcpy using 'rep movsb' instruction (X86-only)"
H1E31B40E5C1D: '‘rep movsb’ 명령어를 사용한 memcpy 인라인 (X86 전용)'
# 'inline namespace reopened as a non-inline namespace'
H46A1E728D683: '인라인 네임스페이스가 비인라인 네임스페이스로 다시 열림'
# 'inline namespaces are a C++11 feature'
H39D356D1A5FD: '인라인 네임스페이스는 C++11의 기능입니다'
# 'inline namespaces are incompatible with C++98'
HFE4E3495E8EA: '인라인 네임스페이스는 C++98와 호환되지 않습니다'
# 'inline nested namespace definition is a C++20 extension'
HF12053D31358: '인라인 중첩 네임스페이스 정의는 C++20 확장 기능입니다'
# 'inline nested namespace definition is incompatible with C++ standards before C++20'
HDC23554C291A: '인라인 중첩 네임스페이스 정의는 C++20 이전의 C++ 표준과 호환되지 않습니다'
# 'inline variable %q0 is not defined'
H2B60738BBC75: '인라인 변수 %q0는 정의되지 않았습니다'
# 'inline variables are a C++17 extension'
H427269D7064C: '인라인 변수는 C++17 확장 기능입니다'
# 'inline variables are incompatible with C++ standards before C++17'
HCE89C300F33E: '인라인 변수는 C++17 이전의 C++ 표준과 호환되지 않습니다'
# "inner loops must be tightly nested inside a '%0' clause on a '%1' construct"
HE18366CA8367: "내부 루프는 '%1' 구조 내의 '%0' 절 안에 밀접하게 중첩되어야 합니다"
# 'input bitcode file which can override previously defined symbol(s)'
HDFE5316187C5: '이전에 정의된 심볼(들을) 재정의할 수 있는 입력 비트코드 파일'
# 'input conversion stopped due to an input byte that does not belong to the input codeset UTF-8'
HC2B0606B1239: '인풋 변환이 입력 바이트가 입력 코드셋 UTF-8에 속하지 않아 중지되었습니다'
# 'input files'
H69B53967F9CE: '입력 파일'
# "input is not a PCH file: '%0'"
H0BA9CA2C72E0: "입력은 PCH 파일이 아닙니다: '%0'"
# 'input objects'
H6ADBB11C54B0: '입력 개체'
# "insert '%0;' to silence this warning"
H7C4DAFCB5A75: "이 경고를 제거하려면 '%0;'을 삽입하십시오."
# "insert '%select{_Nonnull|_Nullable|_Null_unspecified}0' if the %select{pointer|block pointer|member pointer|array parameter}1 %select{should never be null|may be null|should not declare nullability}0"
H95F6AD57B128: '‘%select{_Nonnull|_Nullable|_Null_unspecified}0’을 삽입해야 합니다. %select{포인터|블록 포인터|멤버 포인터|array 매개변수}1이 %select{절대로 null이 아니어야 한다|null일 수 있다|nullability를 선언하지 않아야 한다}0 경우에'
# "insert ',' before '...' to silence this warning"
H84706E906BF0: "','을 '...' 앞에 삽입하여 이 경고를 제거하세요"
# "insert 'break;' to avoid fall-through"
H4EC7EA05AEDF: 'break;를 삽입하여 fall-through를 피하세요'
# 'insert an explicit cast to silence this issue'
H21D74C2B0346: '이 문제를 억제하기 위해 명시적인 캐스팅을 삽입하세요.'
# 'insert tail call traps'
H8C2E3910BD93: '꼬리 호출 트랩 삽입'
# 'insert traps in old function bodies (relocation mode)'
H625478AB58CF: '구 함수 본체에 트랩 삽입 (재배치 모드)'
# "install_name does not match: '%0' (provided) vs '%1' (found)"
H748B1AE34A35: "install_name이 일치하지 않습니다: '%0' (제공됨) vs '%1' (발견됨)"
# 'instance method %0 found instead of class method %1'
H1FCFE23050D1: '인스턴스 메서드 %0가 클래스 메서드 %1 대신 발견됨'
# "instance method %0 is being used on 'Class' which is not in the root class"
H214A12BD7783: "'Class'에 %0 인스턴스 메서드가 사용되고 있지만, 이 클래스는 루트 클래스에 속하지 않습니다."
# "instance method %objcinstance0 not found (return type defaults to 'id')"
HAFE085EFCB1C: "인스턴스 메서드 %objcinstance0을 찾을 수 없음 (리턴 타입은 기본값으로 'id'로 설정됨)"
# "instance method %objcinstance0 not found (return type defaults to 'id'); did you mean %objcinstance2?"
H44E31EFE4C27: "인스턴스 메서드 %objcinstance0을 찾을 수 없습니다(리턴 타입은 기본값 'id'로 설정됨); %objcinstance2 의 뜻이었는지 확인해 주세요"
# 'instance variable %0 accessed in class method'
H3EADF48ACA9A: '인스턴스 변수 %0가 클래스 메서드에서 접근되었습니다'
# 'instance variable %0 declared with incompatible types in different translation units (%1 vs. %2)'
HBFCDBA937742: '인스턴스 변수 %0가 서로 다른 번역 단위에서 호환되지 않는 유형으로 선언되었습니다 (%1 vs. %2)'
# 'instance variable %0 has conflicting bit-field width'
H2B77404519CC: '인스턴스 변수 %0의 비트 필드 너비가 충돌합니다'
# 'instance variable %0 has conflicting type%diff{: $ vs $|}1,2'
H9D5CF719769D: '인스턴스 변수 %0는 충돌하는 형식%diff{: $1 대 $2|}1,2를 가집니다.'
# 'instance variable %0 is being directly accessed'
H3F2D0ABA6990: '인스턴스 변수 %0가 직접 접근되고 있습니다'
# 'instance variable %0 is private'
HDB3564656CA2: '인스턴스 변수 %0는 private 입니다'
# 'instance variable %0 is protected'
HD16F20CBE669: '%0 인스턴스 변수는 protected입니다'
# 'instance variable is already declared'
H801D25BC5C9A: '인스턴스 변수가 이미 선언되었습니다'
# 'instance variable is declared here'
H1FC75F163FBE: '인스턴스 변수가 여기서 선언되었습니다'
# 'instance variable of type %0 has %select{private|protected}1 destructor'
HA9F26F512B98: '타입 %0의 인스턴스 변수가 %select{private|protected}1 소멸자를 가지고 있습니다'
# 'instance variables cannot be of reference type'
HCCF4E9A4856E: '인스턴스 변수는 참조 형식일 수 없습니다'
# 'instance variables may not be placed in %select{categories|class extension}0'
H0D800B785119: '인스턴스 변수는 %select{카테고리|클래스 확장}0에 배치할 수 없습니다'
# 'instance variables must have a constant size'
H99AB003B5614: '인스턴스 변수는 상수 크기를 가져야 합니다'
# 'instantiated into assembly here'
H396FFF689BB5: '여기에서 어셈블리로 인스턴스화되었습니다'
# 'instantiating fold expression with %0 arguments exceeded expression nesting limit of %1'
H467EDA4122CE: '폴드 표현식을 인스턴스화하는 중 %0 인수를 사용하여 표현식 중첩 제한 %1을 초과했습니다'
# 'instantiation of %q0 is different in different modules'
H7179BAA1427A: '다른 모듈에서 %q0의 인스턴스화가 서로 다릅니다'
# "instantiation of '%0' not supported yet"
H5578212F4DA3: "인스턴스화 '%0'는 아직 지원되지 않습니다"
# 'instantiation of function %q0 required here, but no definition is available'
H88BC3AB38294: '함수 %q0의 인스턴스화가 여기서 필요하지만 정의가 없습니다'
# 'instantiation of variable %q0 required here, but no definition is available'
H4C7FC0EFFE4E: '변수 %q0의 인스턴스화가 여기에서 필요하지만 정의가 없습니다'
# 'instrument atomic instructions (rmw, cmpxchg)'
H9BDE4655B194: '원자 명령어를 트레이스합니다 (rmw, cmpxchg)'
# 'instrument byval arguments'
H6881238D18AA: 'byval 인수를 인스트루먼트 합니다'
# 'instrument byval call arguments'
H6F6BC27C3374: 'byval 호출 인수를 추적합니다'
# 'instrument code to generate accurate profile data'
HE308C13DB62F: '정확한 프로파일 데이터 생성을 위해 코드에 도구를 삽입'
# 'instrument dynamic allocas'
HBD70EB33F966: '동적 alloca 기록'
# 'instrument landing pads'
HEB0B3F6EFDA4: '인스트루먼트 랜딩 패드'
# 'instrument memory intrinsics'
HA6D9147CFA12: '메모리 인트린스틱에 측정 도구 삽입'
# 'instrument personality functions'
HD5594587E387: '개체 함수 측정'
# 'instrument read instructions'
H064E58E10C74: '읽기 명령어 삽입'
# 'instrument reads and writes with callbacks'
H29E9BA5B8A64: '콜백으로 읽기와 쓰기를 기록합니다'
# 'instrument stack (allocas)'
HD0DD117BE7BA: '스택 (allocas) 추적'
# 'instrument write instructions'
HA31AFF85F744: '실험을 위한 쓰기 명령어 삽입'
# 'instrumentation map used to identify function ids. Currently supports elf file instrumentation maps.'
HABD136211445: '인스트루먼테이션 맵은 함수 ID를 식별하기 위해 사용됩니다. 현재는 ELF 파일 인스트루먼테이션 맵을 지원합니다.'
# 'integer constant expression evaluates to value %0 that cannot be represented in a %1-bit %select{signed|unsigned}2 integer type'
HA689EA8A19CC: '정수 상수 표현식의 계산 결과 값 %0는 %1비트 %select{부호 있음|부호 없음}2 정수 유형으로 표현할 수 없습니다'
# 'integer constant not in range of enumerated type %0'
H38F9A13FA923: '정수 상수는 열거형 타입 %0의 범위를 벗어납니다'
# 'integer literal is too large to be represented in a signed integer type, interpreting as unsigned'
H510046C2B2ED: '정수 리터럴이 부호 있는(signed) 정수 형식으로 표현할 수 없을 정도로 크므로, 부호 없는(unsigned) 형식으로 해석합니다'
# 'integer literal is too large to be represented in any %select{signed |}0integer type'
H586D057CD6B8: '정수 리터럴은 어떤 %select{부호 있는 |}0정수 형식에도 표현할 수 없습니다'
# "integer literal is too large to be represented in type 'long' and is subject to undefined behavior under C++98, interpreting as 'unsigned long'; this literal will %select{have type 'long long'|be ill-formed}0 in C++11 onwards"
H84C22AB83CDC: "정수 리터럴은 'long' 형식으로 표현하기에 너무 크며, C++98에서는 미정의 동작의 대상이며 'unsigned long'로 해석됩니다; 이 리터럴은 C++11 이후에 %select{long long 형식을 가집니다|잘못된 형식이 됩니다}0"
# "integer literal is too large to be represented in type 'long', interpreting as 'unsigned long' per C++98; this literal will %select{have type 'long long'|be ill-formed}0 in C++11 onwards"
H4C2C8A72E536: "정수 리터럴은 'long' 형식으로 표현하기에 너무 큽니다. C++98에 따라 'unsigned long'로 해석합니다; 이 리터럴은 C++11 이후에는 %select{ 'long long' 형식을 가집니다 | 유효하지 않은 표현식이 됩니다 }0"
# "integer literal is too large to be represented in type 'long', interpreting as 'unsigned long' per C89; this literal will %select{have type 'long long'|be ill-formed}0 in C99 onwards"
H58DBBF3A9BD1: "정수 리터럴이 형 'long'에 표현될 수 없어 C89 규정에 따라 'unsigned long'로 해석됩니다; C99 이후 표준에서는 이 리터럴이 %select{'long long' 타입이 될|문법 오류가 될}0 합니다"
# 'integer overflow in preprocessor expression'
H24214C6EA913: '프리프로세서 표현식에서 정수 오버플로우'
# 'integer sequences must have integral element type'
H16392B2B25B5: '정수 시퀀스는 요소 형식이 정수형이어야 합니다'
# 'integer sequences must have non-negative sequence length'
HC3DBF19F94A9: '정수 시퀀스는 비음수 시퀀스 길이를 가져야 합니다.'
# 'integer value %0 is outside the valid range of values [%1, %2] for the enumeration type %3'
HB6C02E17F94C: '정수 값 %0은 열거 형식 %3의 유효한 범위 [%1, %2]를 벗어났습니다'
# 'integral constant expression has incomplete class type %0'
H52768B5A0D44: '정수 상수 표현식은 미완전한 클래스 형식 %0를 가집니다'
# 'integral constant expression requires explicit conversion from %0 to %1'
H482F498F126E: '정수 상수 표현식은 %0에서 %1로 변환하기 위해 명시적인 변환이 필요합니다'
# 'interface type %1 cannot be %select{returned|passed}0 by value; did you forget * in %1?'
H5F16699831A7: '인터페이스 형식 %1은 값으로 %select{returned|passed}0될 수 없습니다; %1에 *를 까먹은 게 아닐까요?'
# 'interface type cannot be statically allocated'
HFB7A102C4547: '인터페이스 형식은 정적 할당될 수 없습니다'
# 'interface type cannot inherit from %select{struct|non-public interface|class}0 %1'
HE603DB4B7CDD: '인터페이스 형식은 %select{struct|비공개 인터페이스|class}0 %1에서 상속받을 수 없습니다.'
# "interface types cannot specify '%select{private|protected}0' access"
H5BB34D1AC02B: "인터페이스 타입은 '%select{private|protected}0' 접근 지정자를 지정할 수 없습니다."
# "interop type '%0' cannot be specified more than once"
H92EFF909211E: "인터옵 타입 '%0'은 한 번 이상 지정될 수 없습니다"
# 'interop variable %0 used in multiple action clauses'
H6D1E048E9343: '인터옵 변수 %0가 여러 개의 작업 절에서 사용되었습니다'
# "interop variable must be of type 'omp_interop_t'"
H4EE913CC5003: "interop 변수는 'omp_interop_t' 형식이어야 합니다"
# 'interrupt service routine cannot be called directly'
H0EEEBB03E095: '인터럽트 서비스 루틴은 직접 호출할 수 없습니다'
# "interrupt service routine with vfp enabled may clobber the interruptee's vfp state; consider using the `interrupt_save_fp` attribute to prevent this behavior"
HBC940BDF20A5: 'vfp 활성화된 인터럽트 서비스 루틴은 인터럽티의 vfp 상태를 손상시킬 수 있습니다; 이 동작을 방지하기 위해 `interrupt_save_fp` 속성을 사용하십시오'
# 'interval between profile writes (default: 0 = write only at program end).  This is useful for service workloads when you want to dump profile every X minutes or if you are killing the program and the profile is not being dumped at the end.'
H3081FD16F975: '프로파일 작성 간격 (기본값: 0 = 프로그램 종료 시만 작성). 이 옵션은 서비스 워크로드에서 X 분마다 프로파일을 덤프하고 싶을 때, 또는 프로그램을 강제 종료하여 프로파일이 종료 시 덤프되지 않을 경우 유용합니다.'
# 'intrinsic module directory'
H68E291291712: '인트리니시크 모듈 디렉토리'
# 'intrinsic module search paths'
H9C8DEF0487D6: '내장 모듈 검색 경로'
# 'introduce a module file extension for testing purposes. The argument is parsed as blockname:major:minor:hashed:user info'
HC4A3048AAD1F: '테스트 용도로 모듈 파일 확장자를 도입합니다. 인수는 blockname:major:minor:hashed:사용자 정보 형식으로 해석됩니다.'
# 'introduce a parameter name to make %0 part of the selector'
HF88F126D64B8: '매개변수 이름을 추가하여 %0를 선택자의 일부로 만듭니다'
# 'invalid #ident directive'
H33DD8376B05A: '유효하지 않은 #ident 지시문'
# 'invalid %% escape in inline assembly string'
HDBE197B56289: '인라인 어셈블리 문자열 내에서 잘못된 %% 이스케이프입니다.'
# "invalid %0 at end of declaration; did you mean '='?"
H6911F0CCF565: "잘못된 %0 선언의 끝에서; '=' 의도하셨나요?"
# "invalid %1 version '%0' in availability attribute"
HB3CB22885AD2: "%1 버전 '%0'이(가) 사용 가능 속성에서 잘못되었습니다"
# 'invalid %select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 %select{floating-point|enumeration}1 type %2 %plural{2:with|4:from|:and}0 %select{enumeration|floating-point}1 type %3'
H06A881D8D9FE: '잘못된 %select{산술 연산 사이|비트 연산 사이|비교|조건 표현식 사이|복합 할당}0 %select{부동소수점|열거형}1 유형 %2 %plural{2:와|4:에서|:와}0 %select{열거형|부동소수점}1 유형 %3'
# 'invalid %select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2'
H796D4C8F35F6: '다른 열거 형식 간의 %select{산술 연산 사이|비트 연산 사이|비교|조건 표현식 사이|복합 할당}0이 유효하지 않습니다%diff{ ($ 및 $)|}1,2'
# 'invalid %select{branch|return|throw}0 %select{out of|into}1 OpenACC Compute/Combined Construct'
H898CA374F6B7: '무효한 %select{branch|return|throw}0 %select{밖으로|안으로}1 OpenACC 계산/결합 구조'
# 'invalid %select{constructor|destructor}0 declaration'
HDEF8993ADCB9: '잘못된 %select{생성자|소멸자}0 선언'
# "invalid 'this' expression on 'map' clause"
H008D791665EC: "유효하지 않은 'this' 표현식이 'map' 절에서 사용되었습니다."
# "invalid -Xopenmp-target argument: '%0', options requiring arguments are unsupported"
H705427655A77: "잘못된 -Xopenmp-target 인수: '%0', 인수를 요구하는 옵션들은 지원되지 않습니다"
# "invalid C++ ABI name '%0'"
H8F1C2E5DB890: "잘못된 C++ ABI 이름 '%0'"
# "invalid CoreFoundation Runtime ABI '%0'; must be one of 'objc', 'standalone', 'swift', 'swift-5.0', 'swift-4.2', 'swift-4.1'"
H91493C3284DF: "올바르지 않은 CoreFoundation 런타임 ABI '%0'; 다음 중 하나여야 합니다: 'objc', 'standalone', 'swift', 'swift-5.0', 'swift-4.2', 'swift-4.1'"
# 'invalid Darwin version number: %0'
HA0C57A49CA76: '올바르지 않은 Darwin 버전 번호: %0'
# 'invalid LLVM IR input: %0'
H196A3B80B48D: '잘못된 LLVM IR 입력: %0'
# "invalid OS value '%0' in '%1'"
H00BD3F016742: "무효한 OS 값 '%0'은 '%1'에서 지정되었습니다"
# 'invalid OpenACC clause %0'
HA3099393E590: '유효하지 않은 OpenACC 절 %0'
# "invalid OpenACC directive %select{%1|'%1 %2'}0"
H74A42ADBF419: "잘못된 OpenACC 지시문 %select{%1|'%1 %2'}0"
# 'invalid PCS type'
H696D824B4D2C: '잘못된 PCS 형식'
# "invalid RVV vector size '%0', expected size is '%1' based on LMUL of type and '-mrvv-vector-bits'"
H96A03531A0AD: "잘못된 RVV 벡터 크기 '%0', 유형의 LMUL 및 '-mrvv-vector-bits'에 따라 기대되는 크기는 '%1'입니다"
# "invalid SVE vector size '%0', must match value set by '-msve-vector-bits' ('%1')"
HF993CA8A3093: "잘못된 SVE 벡터 크기 '%0'입니다. '-msve-vector-bits' 옵션에 지정된 값('%1')과 일치해야 합니다."
# 'invalid UTF-8 in comment'
H58EB41DE8F48: '주석에 유효하지 않은 UTF-8이 있습니다.'
# "invalid Xarch argument: '%0', not all driver options can be forwared via Xarch argument"
HA12658A01ACA: "잘못된 Xarch 인수: '%0', 모든 드라이버 옵션이 Xarch 인수를 통해 전달될 수는 없습니다"
# "invalid Xarch argument: '%0', options requiring arguments are unsupported"
H7917BEC4B42C: "잘못된 Xarch 인수: '%0', 인수를 요구하는 옵션들은 지원되지 않습니다"
# 'invalid __hlsl_resource_t type attributes'
H9A97FF7B54BE: '유효하지 않은 __hlsl_resource_t 형식 특성'
# "invalid address discrimination flag '%0'; '__ptrauth' requires '0' or '1'"
H3802C33B9837: "__ptrauth 주소 판별 플래그 '%0'가 유효하지 않음; '__ptrauth'는 '0' 또는 '1'이 필요합니다"
# 'invalid address discrimination mode %0'
H1D217687F248: '잘못된 주소 구분 모드 %0'
# "invalid alignment option in '#pragma %select{align|options align}0' - ignored"
H410475644E70: "잘못된 alignment 옵션 '#pragma %select{align|options align}0'에서 - 무시됨"
# "invalid application of '%0' to %select{an incomplete|sizeless}1 type %2"
H3984632B643A: "‘%0’를 '%select{완전하지 않은|크기 없는}1 유형 %2'에 적용하는 것이 유효하지 않습니다"
# "invalid application of '%0' to WebAssembly table"
HA443432F106F: "WebAssembly 테이블에 '%0'를 적용하는 것이 유효하지 않습니다."
# "invalid application of '%0' to a function type"
HFD1A077F0D84: "함수 유형에 '%0'을 적용할 수 없습니다."
# "invalid application of '%0' to a void type"
H3290D1C688B6: "void 형식에 '%0'을(를) 적용하는 것은 유효하지 않습니다"
# "invalid application of '%select{sizeof|alignof|typeof|typeof_unqual}0' to bit-field"
H4D97635BE644: "비트 필드에 '%select{sizeof|alignof|typeof|typeof_unqual}0'을 적용하는 것은 유효하지 않습니다"
# "invalid application of '__builtin_omp_required_simd_align' to an expression, only type is allowed"
H0F35C466B34C: "표현식에 '__builtin_omp_required_simd_align'을 적용할 수 없습니다. 타입만 허용됩니다."
# "invalid application of 'alignof' to a field of a class still being defined"
H584C8A2541E4: "정의 중인 클래스의 필드에 'alignof'를 적용하는 것은 유효하지 않습니다."
# "invalid application of 'offsetof' to a field of a virtual base"
H7E5DD90FD952: "가상 기반 클래스의 필드에 'offsetof'의 유효하지 않은 적용입니다"
# "invalid arch name '%0'"
H053EB6DE40C8: "잘못된 아키텍처 이름 '%0'"
# "invalid arch name '%0', %1"
HAF3A77CFBCF8: "잘못된 아키텍처 이름 '%0', %1"
# 'invalid argument %0 to function: %1, expecting a generic pointer argument'
H45B49DB90594: '함수 %1의 %0 인수에 잘못된 인수가 전달되었습니다: 일반 포인터 인수를 기대했습니다'
# "invalid argument '%0' not allowed with '%1'"
H5F814EC912CC: "잘못된 인수 '%0'는 '%1'과 함께 사용할 수 없습니다"
# "invalid argument '%0' only allowed with '%1'"
HCD365CC8E5D4: "잘못된 인자 '%0'은 '%1'과 함께 사용될 때만 허용됩니다"
# "invalid argument '%0' to -%1"
H8405E80D8137: "유효하지 않은 인수 '%0'을(를) -%1 옵션에 전달했습니다."
# "invalid argument '%0' to -malign-branch=; each element must be one of: %1"
H20657E1CDBBF: "-malign-branch= 옵션에 '%0' 잘못된 인자; 각 요소는 다음 중 하나여야 합니다: %1"
# "invalid argument '%0' to -mfpu=; must be one of: 64, 32, none, 0 (alias for none)"
HF131652C4C29: "잘못된 인수 '%0'가 -mfpu=에 전달되었습니다; 다음 중 하나여야 합니다: 64, 32, none, 0 (none의 별칭)"
# "invalid argument '%0' to -msimd=; must be one of: none, lsx, lasx"
H2BA112BC46B6: "유효하지 않은 인수 '%0'가 -msimd= 옵션에 전달되었습니다; 반드시 다음 중 하나여야 합니다: none, lsx, lasx"
# "invalid argument '%0' to atomic attribute; valid options are: 'remote_memory', 'fine_grained_memory', 'ignore_denormal_mode' (optionally prefixed with 'no_')"
H438B1A442EF4: "atomic 속성에 대한 '%0'은 유효하지 않은 인수입니다. 유효한 옵션은 'remote_memory', 'fine_grained_memory', 'ignore_denormal_mode'이며, 선택적으로 'no_' 접두사가 포함될 수 있습니다."
# "invalid argument '-mno-amdgpu-ieee' only allowed with relaxed NaN handling"
H507F0448DDCC: "잘못된 인수 '-mno-amdgpu-ieee'는 relaxed NaN 처리와 함께만 허용됩니다"
# "invalid argument in '%0', only integer or 'auto' is supported"
H40210717B247: "‘%0’에서 잘못된 인수가 지정되었습니다. 정수 또는 'auto'만 지원됩니다."
# "invalid argument in '%0', only integers are supported"
H7CC5EAE0927D: '‘%0’에서 무효한 인자입니다. 정수만 지원됩니다.'
# 'invalid argument of type %0; expected an integer type'
HDC97D348BCF9: '타입 %0인 인수가 유효하지 않습니다; 정수 타입이 예상됩니다'
# 'invalid argument to convert to character'
H035CE8B39D0F: '문자로 변환할 수 없는 인수입니다'
# 'invalid argument type %0 to unary expression'
HB7A2329B026C: '일항 표현식에 대한 인수 형식 %0이 잘못되었습니다.'
# 'invalid argument type to function %0 (expecting %1 having %2)'
H740D8FB32D84: '함수 %0에 대한 잘못된 인자 타입(기대하는 %1이 %2를 가져야 함)'
# 'invalid argument: symbol must be a device-side function or global variable'
HB29E0DD1BCB5: '잘못된 인수: 기호는 device-side function 또는 global variable이어야 합니다'
# "invalid argument; expected 'disable'"
H14256C1A2363: "잘못된 인수; 'disable'이 예상되었습니다"
# "invalid argument; expected 'enable'%select{|, 'full'}0%select{|, 'assume_safety'}1 or 'disable'"
H369903756AB7: "잘못된 인수; 'enable'%select{|, 'full'}0%select{|, 'assume_safety'}1 또는 'disable'을 예상했습니다"
# 'invalid authentication key %0'
H1380B8ED725A: '올바르지 않은 인증 키 %0'
# 'invalid block pointer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2'
H1E4447440EDF: '잘못된 블록 포인터 변환 %select{%diff{를 $에서 $로 할당 중|다른 형식으로 할당}0,1|%diff{를 $1 형식의 매개변수에 전달 중|매개변수에 다른 형식 전달}0,1|%diff{결과 형식이 $1인 함수에서 $0을 반환 중|함수에서 다른 반환 형식 반환}0,1|%diff{를 $1 형식으로 변환 중|형식 간 변환}0,1|%diff{를 $1 형식의 표현식으로 초기화 중|표현식의 다른 형식으로 초기화}0,1|%diff{를 $1 형식의 매개변수에 전송 중|매개변수에 다른 형식 전송}0,1|%diff{를 $1 형식으로 캐스팅 중|형식 간 캐스팅}0,1}2'
# 'invalid block variable declaration - must be %select{const qualified|initialized}0'
HF892D907A5A7: '유효하지 않은 블록 변수 선언 - 반드시 %select{const qualified|initialized}0이어야 합니다'
# "invalid block variable declaration - using 'extern' storage class is disallowed"
H2029EAB9FA9A: "유효하지 않은 블록 변수 선언 - 'extern' 저장 클래스 사용은 허용되지 않습니다"
# 'invalid branch into OpenACC Compute/Combined Construct'
HC49FDF0B5C89: '유효하지 않은 분기: OpenACC Compute/Combined 구성 요소 내부로'
# 'invalid branch out of OpenACC Compute/Combined Construct'
H921800904C81: 'OpenACC Compute/Combined Construct에서 벗어나는 잘못된 분기'
# "invalid branch protection option '%0' in '%1'"
H69A222420F22: "잘못된 가지치기 보호 옵션 '%0'이 '%1'에서 발견되었습니다"
# "invalid case style for %0 '%1'"
H3DD07CA4DE69: "%0 '%1'에 대한 유효하지 않은 케이스 스타일"
# "invalid character '%0' in raw string delimiter; use PREFIX( )PREFIX to delimit raw string"
H82170E32D0E4: "원시 문자열 구분자에서 '%0'라는 잘못된 문자가 있습니다. 원시 문자열을 구분하려면 PREFIX( )PREFIX를 사용하십시오."
# "invalid comparison flag %0; use 'layout_compatible' or 'must_be_null'"
H677EA1A68EB0: "잘못된 비교 플래그 %0; 'layout_compatible' 또는 'must_be_null'을 사용하십시오"
# "invalid component '%0' used; expected 'x', 'y', 'z', or 'w'"
H32632D0CDE2F: "유효하지 않은 구성요소 '%0'가 사용되었습니다; x, y, z 또는 w가 예상됩니다"
# 'invalid constructor from class in system header, should not be explicit'
HEFC602372E3E: '시스템 헤더 내의 클래스로부터의 생성자는 explicit로 선언되어서는 안 됩니다'
# 'invalid conversion between ext-vector type %0 and %1'
H4E43BF77A891: 'ext-vector 유형 %0과 %1 사이의 유효하지 않은 변환'
# 'invalid conversion between vector type %0 and integer type %1 of different size'
HAD5A2EB8C76E: '크기 다른 벡터 형식 %0과 정수 형식 %1 사이의 무효한 변환이 감지되었습니다'
# 'invalid conversion between vector type %0 and scalar type %1'
H0E21BE8324C1: '유효하지 않은 변환: 벡터 형식 %0와 스칼라 형식 %1 사이의 변환'
# 'invalid conversion between vector type%diff{ $ and $|}0,1 of different size'
H62FB40425AFD: '크기 다른 벡터 유형 간의 유효하지 않은 변환: %diff{ $와 $|}0,1'
# "invalid conversion specifier '%0'"
H36DE3CE25255: "잘못된 형식 지정자 '%0'"
# 'invalid covariant return for virtual function: %1 is a %select{private|protected}2 base class of %0'
HB307942D226E: '무효한 가상 함수의 공변 반환 타입: %1은 %0의 %select{private|protected}2 기반 클래스입니다'
# 'invalid cpu feature string for builtin'
H63D2023D3150: '내장용 CPU 기능 문자열이 유효하지 않습니다'
# 'invalid cpu name for builtin'
HD2B5E0F427CF: '내장 함수에 대한 유효하지 않은 cpu 이름입니다'
# 'invalid custom discrimination'
HBF55CC3D0D6C: '잘못된 사용자 지정 구분'
# 'invalid declaration inside %select{tbuffer|cbuffer}0'
H75299BE36932: '잘못된 선언이 %select{tbuffer|cbuffer}0 내부에서 발견되었습니다.'
# 'invalid declaration specifier in template non-type parameter'
HE0A0675789D7: '템플릿 비형식 매개변수의 선언 지정자가 유효하지 않습니다'
# 'invalid diagnostic type for \'diagnose_if\'; use "error" or "warning" instead'
HD2E5D476D869: "유효하지 않은 'diagnose_if' 진단 유형; 대신 'error' 또는 'warning'을 사용해야 합니다"
# "invalid digit '%0' in %select{decimal|octal|binary}1 constant"
H6F9BD80EC0BE: "잘못된 숫자 '%0'가 %select{십진수|팔진수|이진수}1 상수에 있습니다"
# "invalid digit '%0' in escape sequence"
HF729B18CD0D2: "에스케이프 시퀀스에서 유효하지 않은 숫자 '%0'"
# "invalid escape sequence '%0' in an unevaluated string literal"
HF58F976119B7: "유효하지 않은 이스케이프 시퀀스 '%0'가 평가되지 않은 문자열 리터럴 내에 있습니다"
# "invalid exception model '%select{none|sjlj|seh|dwarf|wasm}0' for target '%1'"
H00FCEE8853CC: "잘못된 예외 모델 '%select{none|sjlj|seh|dwarf|wasm}0'을 타겟 '%1'에 사용할 수 없습니다"
# 'invalid expected %0: %1'
HE0DC8B702320: '잘못된 예상 %0: %1'
# 'invalid explicit object parameter type %0 in lambda with capture; the type must be the same as, or derived from, the lambda'
H98E01B807F8E: '유효하지 않은 명시적 객체 매개변수 유형 %0가 캡처가 있는 람다 표현식에서 발견되었습니다; 이 유형은 람다와 동일하거나, 람다에서 파생된 클래스여야 합니다'
# 'invalid explicit object parameter type %0 in lambda with capture; the type must derive publicly from the lambda'
H607716F86E02: '유효하지 않은 명시적 객체 매개변수 유형 %0이(가) 캡처를 가진 람다에서 발견됨; 해당 유형은 람다로부터 공개적으로 파생되어야 합니다'
# 'invalid extra discrimination selection %0'
HAC5AAEAB2B1D: '잘못된 추가 선택 구분 %0'
# "invalid extra discriminator flag '%0'; '__ptrauth' requires a value between '0' and '%1'"
HBC87DBE11994: "__ptrauth 추가 판별 플래그 '%0'가 유효하지 않음; '__ptrauth'는 '0'과 '%1' 사이의 값을 필요로 합니다"
# 'invalid feature combination: %0'
H53E34DDB7754: '잘못된 기능 조합: %0'
# 'invalid field is here'
H6F033E1FBEC9: '잘못된 필드가 여기에 있습니다'
# 'invalid filename for #line directive'
H5BFFCF48D855: '올바르지 않은 #line 지시문용 파일 이름입니다.'
# 'invalid filename for line marker directive'
H6AF3C8643D27: '올바르지 않은 라인 마커 지시문에 대한 파일 이름'
# 'invalid flag line marker directive'
H5CC65A10A5E0: '잘못된 flag 라인 마커 지시문'
# "invalid float ABI '%0'"
H606FAE3A11E2: "유효하지 않은 부동소수점 ABI '%0'"
# "invalid iOS deployment version '%0', iOS 10 is the maximum deployment target for 32-bit targets"
HD422F25540A2: "올바르지 않은 iOS 배포 버전 '%0', 32비트 대상의 최대 배포 대상은 iOS 10입니다"
# 'invalid index %0 for pack %1 of size %2'
H1627FB393F43: '잘못된 인덱스 %0: 팩 %1의 크기 %2를 초과했습니다.'
# "invalid input constraint '%0' in asm"
H09D927559067: "어셈블리에서 유효하지 않은 입력 제약 '%0'"
# "invalid input for analyzer-config option '%0', that expects %1 value"
HB14EB9C7A93F: "analyzer-config 옵션 '%0'에 대한 잘못된 입력, %1 값이 필요합니다"
# "invalid input for checker option '%0', that expects %1"
H784B521FDFA9: "체커 옵션 '%0'에 대한 잘못된 입력, 해당 옵션이 %1을 필요로 합니다"
# "invalid input size for constraint '%0'"
H8F6CDB6F0449: "제약조건 '%0'에 대한 입력 크기가 유효하지 않습니다."
# "invalid integral value '%1' in '%0'"
H6E04ED0681B7: "'%0' 내의 '%1'은(는) 무효한 정수 값입니다."
# "invalid invocation of method '%0' on a temporary object while it is in the '%1' state"
H6C0DF8705FCA: "임시 객체가 '%1' 상태일 때 메서드 '%0'에 대한 잘못된 호출입니다"
# "invalid invocation of method '%0' on object '%1' while it is in the '%2' state"
HD38690B94C13: "객체 '%1'에 대한 메서드 '%0'의 호출이 '%2' 상태일 때 유효하지 않습니다"
# "invalid library name in argument '%0'"
H64F3D932433A: "잘못된 라이브러리 이름이 인수 '%0'에 있습니다"
# "invalid line marker flag '2': cannot pop empty include stack"
H37DFD44E19FB: "잘못된 라인 마커 플래그 '2': 비어 있는 include 스택에서 pop할 수 없습니다"
# "invalid linker name in argument '%0'"
HC2FCA31CF12C: "인자 '%0'에서 무효한 링커 이름이 지정되었습니다."
# 'invalid literal operator parameter type %0, did you mean %1?'
H0C90111229B8: '유효하지 않은 리터럴 연산자 매개변수 유형 %0, 의 뜻이 %1이었나요?'
# "invalid lvalue in asm input for constraint '%0'"
H2CA59C9EF59C: "제약 조건 '%0'에 대한 asm 입력에서 유효하지 않은 lvalue가 있습니다."
# 'invalid lvalue in asm output'
HED6C7D31AA01: 'asm 출력에 유효하지 않은 lvalue'
# 'invalid matrix element type %0'
H9CDCD6DAE3BE: '유효하지 않은 행렬 요소 유형 %0'
# 'invalid newline character in raw string delimiter; use PREFIX( )PREFIX to delimit raw string'
HF6C358E90110: '원시 문자열 구분자에 유효하지 않은 개행 문자가 있습니다. 원시 문자열을 구분하기 위해 PREFIX( )PREFIX를 사용하십시오'
# 'invalid number of arguments to function: %0'
H3D5EA8973A6F: '함수에 전달된 인자 개수가 잘못되었습니다: %0'
# "invalid offload arch combinations: '%0' and '%1' (for a specific processor, a feature should either exist in all offload archs, or not exist in any offload archs)"
H92F337A26551: "유효하지 않은 오프로드 아키텍처 조합: '%0'과 '%1' (특정 프로세서에 대해, 어떤 기능은 모든 오프로드 아키텍처에 존재해야 하거나, 어떤 오프로드 아키텍처에도 존재하지 않아야 합니다)"
# 'invalid operand number in inline asm string'
H3DCCD1026997: '인라인 어셈블리 문자열에서 유효하지 않은 피연산자 번호입니다'
# 'invalid operand of type %0 where %1 or a vector of such type is required'
HD52C15C02D70: '형식 %0인 유효하지 않은 연산자입니다. %1 또는 해당 형식의 벡터가 필요합니다'
# 'invalid operand of type %0 where floating, complex or a vector of such types is required'
HC1A341FFC462: '잘못된 %0 유형의 피연산자; 부동소수점, 복소수 또는 이러한 유형의 벡터가 필요합니다'
# 'invalid operand of type %0%select{| where a scalar or vector is required}1'
H848780E5A063: '잘못된 형식의 피연산자 %0%select{| 스칼라 또는 벡터가 필요합니다}1'
# 'invalid operands to binary expression (%0 and %1)'
HC5560B091967: '이진 식의 유효하지 않은 피연산자 (%0과 %1)'
# "invalid option '%0' for %select{cpu_specific|cpu_dispatch}1"
HEFAAB35E81AF: "잘못된 옵션 '%0'입니다: %select{CPU 특정|CPU 디스패치}1"
# "invalid option '%0' not of the form <from-file>;<to-file>"
HCB5BB85712F1: "잘못된 옵션 '%0' 형식 '<from-file>;<to-file>'이 아닙니다"
# 'invalid option combination; LASX depends on LSX'
H7E946D645C29: '잘못된 옵션 조합; LASX는 LSX에 의존합니다'
# "invalid or misplaced branch protection specification '%0'"
H9377B8FCDAC3: "잘못된 또는 잘못된 위치의 분기 보호 지정 '%0'"
# "invalid or unsupported offload target: '%0'"
H4E7457AF1786: "유효하지 않은 또는 지원하지 않는 오프로드 대상: '%0'"
# "invalid or unsupported rounding mode in '#pragma STDC FENV_ROUND' - ignored"
HDB0B7F11E503: " '#pragma STDC FENV_ROUND'에서 잘못된 또는 지원되지 않는 반올림 모드 - 무시됨"
# "invalid output constraint '%0' in asm"
H686C32E03A9D: "asm 내에서 무효한 출력 제약 '%0'"
# "invalid output size for constraint '%0'"
HA9017C3CAD23: "제약 조건 '%0'에 대한 잘못된 출력 크기입니다."
# "invalid output type '%0' for use with gcc tool"
H1AE0ECD8B562: "잘못된 출력 형식 '%0'은 gcc 도구와 함께 사용할 수 없습니다"
# "invalid parameter name: '%0' is a keyword"
HBA4C66D8A8AA: "잘못된 매개변수 이름: '%0'는 키워드입니다"
# 'invalid parameter type for defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator; found %1, expected %2%select{| or %4}3'
H1333988BA8FC: '초기화자(defaulted)에 대한 잘못된 매개변수 유형; %select{<ERROR>|등가성|세 방향|등가성|관계성}0 비교 연산자; 발견된 %1, 예상된 %2%select{| 또는 %4}3'
# 'invalid parameter type for non-member defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator; found %1, expected class or reference to a constant class'
HEB967961C960: '비멤버 기본값 지정 %select{<ERROR>|등가성|세방향|등가성|관계성}0 비교 연산자의 잘못된 매개변수 유형; 발견된 유형: %1, 예상된 유형: 클래스 또는 상수 클래스에 대한 참조'
# 'invalid pipe access modifier (expecting %0)'
HA4FFF117B821: '잘못된 파이프 접근 수정자(예상: %0)'
# 'invalid position specified for %select{field width|field precision}0'
H5DF564C1B18C: '잘못된 위치가 %select{필드 너비|필드 정밀도}0에 지정되었습니다'
# "invalid preprocessing directive%select{|, did you mean '#%1'?}0"
H852ECDD7D2C3: "잘못된 preprocessing 지시문입니다%select{|, '#%1'을(를) 의미하는 것이었나요?}0"
# 'invalid profile : %0'
H35AB0F2CB838: '무효한 프로파일 : %0'
# 'invalid protocol qualifiers on non-ObjC type'
H3723A726B37F: '비_ObjC 형식에 유효하지 않은 프로토콜 지정자가 있습니다.'
# 'invalid prototype, variadic arguments are not allowed in OpenCL'
H5E1888FFA26E: '올바르지 않은 프로토타입입니다. OpenCL에서는 가변 인수가 허용되지 않습니다.'
# "invalid range expression of type %0; did you mean to dereference it with '*'?"
H1FCBEB4D2213: "타입 %0의 잘못된 범위 표현; 포인터 해제('*')를 하려는 의도는 없었나요?"
# "invalid range expression of type %0; no viable '%select{begin|end}1' function available"
H76B630AFA57F: "유효하지 않은 %0 형식의 범위 표현식; 사용 가능한 '%select{begin|end}1' 함수가 없습니다"
# "invalid range following '-' in expected %0"
H99FD9B7E0352: "예상된 %0에서 '-' 이후에 유효하지 않은 범위입니다."
# "invalid reduction operator,  expected '+', '*', 'max', 'min', '&', '|', '^', '&&', or '||'"
H3407BE2F5E5D: "잘못된 감소 연산자, '+', '*', 'max', 'min', '&', '|', '^', '&&', 또는 '||' 중 하나가 예상됩니다"
# 'invalid reference to function %0: constraints not satisfied'
H9E6FAF3D6010: '유효하지 않은 함수 %0의 참조: 제약 조건이 충족되지 않았습니다.'
# 'invalid reinterpretation: sizes of %0 and %1 must match'
HC6E0606A101D: '유효하지 않은 재해석: %0과 %1의 크기가 일치해야 합니다'
# "invalid resource class specifier '%0' for packoffset, expected 'c'"
H2B96C40BB1F0: "packoffset에 대한 잘못된 리소스 클래스 지정자 '%0', 기대한 값은 'c'입니다"
# 'invalid rounding argument'
HD77BD554C068: '올바르지 않은 반올림 인수'
# "invalid runtime library name in argument '%0'"
HCC4F20591ADF: "인수 '%0'에 잘못된 런타임 라이브러리 이름이 있습니다."
# 'invalid size value'
H41C03C7DB477: '올바르지 않은 크기 값'
# "invalid space specifier '%0' used; expected 'space' followed by an integer, like space1"
HB8CFB0AAB2CD: "잘못된 space 지정자 '%0'가 사용되었습니다; 'space' 뒤에 정수를 넣어야 합니다, 예를 들어 space1처럼"
# 'invalid special register for builtin'
H26E533E2D360: '내부 함수에 대한 유효하지 않은 특수 레지스터'
# 'invalid storage class specifier in function declarator'
HF2FD2E42B318: '함수 선언자에 유효하지 않은 저장 클래스 지정자가 사용되었습니다'
# "invalid string literal, ignoring final '\\'"
H550F921F116D: "올바르지 않은 문자열 리터럴입니다, 마지막 '\\'를 무시합니다."
# "invalid suffix '%0' on %select{integer|floating|fixed-point}1 constant"
HFE61994BB7A3: "잘못된 접미사 '%0'가 %select{integer|floating|fixed-point}1 상수에 있습니다"
# 'invalid suffix on literal; C++11 requires a space between literal and identifier'
H3AC3DC712C63: '리터럴에 유효하지 않은 접미사; C++11은 리터럴과 식별자 사이에 공백이 필요합니다'
# "invalid tag %0 on '%1' %select{directive|clause}2"
HB6EF4B837656: "잘못된 태그 %0이 '%1' %select{디렉티브|클라우스}2에 있습니다"
# "invalid target ID '%0'; format is a processor name followed by an optional colon-delimited list of features followed by an enable/disable sign (e.g., 'gfx908:sramecc+:xnack-')"
HF2F065F66FFD: "잘못된 타겟 ID '%0'; 형식은 프로세서 이름 다음에 선택적으로 콜론으로 구분된 기능 목록과 enable/disable 기호가 옵니다(예: 'gfx908:sramecc+:xnack-')"
# 'invalid target type %0 for dynamic_cast; target type must be a reference or pointer type to a defined class'
HFE4D2B7D8E06: 'dynamic_cast에 대한 유효하지 않은 타겟 타입 %0입니다. 타겟 타입은 정의된 클래스의 참조 또는 포인터 타입이어야 합니다'
# "invalid thread model '%0' in '%1' for this target"
HE75965380195: "유효하지 않은 스레드 모델 '%0'이/가 '%1'에서 이 타겟에 대해 발견되었습니다"
# "invalid thread pointer reading mode '%0'"
H602D0823E0FB: "잘못된 스레드 포인터 읽기 모드 '%0'"
# 'invalid token at start of a preprocessor expression'
HAAFAB4DB043C: '프리프로세서 표현식의 시작 부분에 잘못된 토큰이 있습니다.'
# 'invalid token in macro parameter list'
HA6A8BDC08D89: '마크로 매개변수 목록에서 유효하지 않은 토큰'
# 'invalid transaction abort code'
H75E4D8742736: '무효한 트랜잭션 중단 코드'
# 'invalid type %0 as argument of iboutletcollection attribute'
HE41F37E3851B: 'iboutletcollection 속성의 인수로 지정된 %0 형식이 유효하지 않습니다'
# 'invalid type %0 in asm %select{input|output}1'
H2A71CC82E6A7: '어셈블리 %select{입력|출력}1에서 %0의 형식이 잘못되었습니다.'
# "invalid type %0 in asm input for constraint '%1'"
H1E6A37C4D619: "어셈블리 입력의 제약 '%1'에 유효하지 않은 유형 %0가 있습니다."
# 'invalid type %0 is a %select{member|base}1 of %2'
HB6D9D0DC110A: '잘못된 형식 %0는 %2의 %select{멤버|기반}1입니다'
# 'invalid type %0 to %1 operator'
H4C8C1A65C2A4: '잘못된 형식 %0을 %1 연산자로 사용할 수 없습니다.'
# 'invalid universal character'
H73C6676CA247: '유효하지 않은 보편적 문자'
# "invalid unwind library name in argument '%0'"
HD675186A50F6: "잘못된 언윈드 라이브러리 이름이 인수 '%0'에 있습니다"
# "invalid use of '__funcref' keyword outside the WebAssembly triple"
H5B018C340841: "'__funcref' 키워드를 WebAssembly 트리플 외부에서 사용하는 것은 유효하지 않습니다."
# "invalid use of '__super', %0 has no base classes"
HC8BFC8F3D816: '‘__super’를 잘못 사용했습니다: %0에는 기반 클래스가 없습니다'
# "invalid use of '__super', this keyword can only be used inside class or member function scope"
H02BB07D5882C: "올바르지 않은 '__super' 사용입니다. 이 키워드는 클래스나 멤버 함수 범위 내에서만 사용할 수 있습니다."
# "invalid use of 'this' %select{outside of a non-static member function|in a function with an explicit object parameter}0"
H9633100217CB: "올바르지 않은 'this' 사용 %select{비정적 멤버 함수 밖에서|명시적 객체 매개변수가 있는 함수에서}0"
# 'invalid use of PPC MMA type'
H23BD562DB2DF: 'PPC MMA 타입의 사용이 잘못되었습니다.'
# 'invalid use of a cast in an inline asm context requiring an lvalue'
H5D073F64410B: '인라인 어셈블리 컨텍스트에서 lvalue가 필요한 상황에서의 캐스트 사용은 유효하지 않습니다'
# 'invalid use of incomplete type %0'
H7FE8554F5009: '완성되지 않은 형식 %0의 잘못된 사용'
# 'invalid use of member %0 in %select{static|explicit object}1 member function'
H50EBCD910232: '%select{정적 멤버 함수|명시적 객체 멤버 함수}1 내에서 멤버 %0의 잘못된 사용'
# 'invalid use of non-static data member %0'
H59D616D352F1: '비정적 데이터 멤버의 잘못된 사용 %0'
# 'invalid use of pointer to member type after %select{.*|->*}0'
H48A2AD1643D5: '%select{.*|->*}0 뒤에 멤버 유형 포인터의 잘못된 사용'
# 'invalid validator version : %0; format of validator version is "<major>.<minor>" (ex:"1.4")'
H4B1AA82F67A0: '유효하지 않은 검증기 버전 : %0; 검증기 버전 형식은 "<메이저>.<마이너>" (예:"1.4")'
# 'invalid validator version : %0; if validator major version is 0, minor version must also be 0'
HD365448B0579: '무효한 검증기 버전: %0; 메이저 버전이 0인 경우, 마이너 버전도 0이어야 합니다'
# 'invalid validator version : %0; validator version must be less than or equal to current internal version'
HED613B352B91: '잘못된 검증기 버전: %0; 검증기 버전은 현재 내부 버전보다 작거나 같아야 합니다.'
# "invalid value %0 in '%1' clause; valid values are %2"
H70463648CF58: "'%1' 절의 값 %0은(는) 유효하지 않습니다; 유효한 값은 %2입니다"
# "invalid value '%1' in '%0'"
H7E000E39503F: " '%0'에서 '%1'은 유효하지 않은 값입니다"
# "invalid value '%1' in '%0', expected one of: %2"
H22924648CBBA: "옵션 '%0'에서 유효하지 않은 값 '%1'이 지정되었습니다. 다음 중 하나를 사용해야 합니다: %2"
# "invalid value '%1' in '%0', value must be '%2' or greater"
H38383851595E: "잘못된 값 '%1'이 '%0'에 있으며, 값은 '%2' 이상이어야 합니다"
# "invalid value '%1' in '%0', value must be 'none' or a positive integer"
H9E8659EA6C7E: "'%0' 내의 값 '%1'은 유효하지 않습니다. 'none' 또는 양의 정수여야 합니다"
# "invalid value '%1' in '%0'; alignment must be a power of 2"
H2DA82E98A2A4: "유효하지 않은 값 '%1'이 '%0'에 있습니다; 정렬은 2의 거듭제곱이어야 합니다"
# 'invalid value for %select{storage class}0 argument'
H53A1EFEC052F: '%select{저장소 클래스}0 인수의 값이 잘못되었습니다'
# "invalid value for 'default' clause; expected 'present' or 'none'"
H8D0169FE239F: "유효하지 않은 'default' 절의 값; 'present' 또는 'none'이 예상됩니다"
# 'invalid vector element type %0'
HEFB9A08F90A0: '유효하지 않은 벡터 요소 유형 %0'
# "invalid version number '%0' inferred from '%1'"
H04EAF3982B06: "'%1'에서 유추된 버전 번호 '%0'이(가) 잘못되었습니다"
# "invalid version number in '%0'"
H561E007CCA86: "올바른 버전 번호가 아닙니다: '%0'"
# "invalid virtual filesystem overlay file '%0'"
HBFF79FC3240A: "무효한 가상 파일 시스템 오버레이 파일 '%0'"
# "invoking a pointer to a 'const &' member function on an rvalue is a C++20 extension"
HDCED919CDE9E: 'rvalue에 대해 상수 참조(const &) 멤버 함수 포인터를 호출하는 것은 C++20 확장 기능입니다'
# "invoking a pointer to a 'const &' member function on an rvalue is incompatible with C++ standards before C++20"
H06659E61779A: 'C++20 이전의 C++ 표준과 호환되지 않습니다: const & 멤버 함수 포인터를 rvalue에 호출했습니다.'
# "isa trait '%0' is not known to the current target; verify the spelling or consider restricting the context selector with the 'arch' selector further"
H0ED9A7F36C30: "isa 특성 '%0'는 현재 타겟에 알려져 있지 않습니다; 철자를 확인하거나 'arch' 선택기를 사용해 컨텍스트 선택기를 추가로 제한해 보세요"
# "it could also be property %select{of type %1|without attribute '%1'|with attribute '%1'|with getter %1|with setter %1}0 declared here"
H91A939A34A63: "또는 여기서 선언된 %select{유형 %1의|속성 '%1' 없이|속성 '%1'과|getter %1과|setter %1과}0 속성일 수도 있습니다"
# 'it delegates to'
H01E41C702CFA: '그것은 ...로 위임합니다'
# 'it is possible to stop the benchmarking process after some phase'
H3F4A63E67588: '특정 단계 후 벤치마킹 프로세스를 중단할 수 있습니다'
# 'iterator step expression %0 evaluates to 0'
H68A0F13C3B50: '반복자 단계 표현식 %0이 0으로 평가됩니다'
# 'iterator step expression %0 is not the integral expression'
H5E0FE51F5C8D: '반복자 단계 표현식 %0은 정수 표현식이 아닙니다.'
# "ivar %0 which backs the property is not referenced in this property's accessor"
HB68211D86C75: '%0라는 속성을 지원하는 iVar는 이 속성의 액세서에서 참조되지 않았습니다'
# "joined argument expects additional value: '%0'"
H67B5A91D2948: "결합된 인수는 추가 값이 필요합니다: '%0'"
# "joined argument treated as '%0'; did you mean '%1'?"
HAC9E756384DA: "결합된 인수가 '%0'로 처리됨; 의미하신 게 '%1'이었나요?"
# 'jump bypasses OpenMP structured block'
H38D141B68E15: '점프가 OpenMP 구조화된 블록을 건너뜁니다.'
# 'jump bypasses auto release push of @autoreleasepool block'
H673B2CE5E964: '점프가 @autoreleasepool 블록의 자동 해제 스택 추가를 회피합니다'
# 'jump bypasses initialization of @catch block'
HBE63405914D4: '점프가 @catch 블록의 초기화를 회피합니다'
# 'jump bypasses initialization of @finally block'
HC258EB27DC7D: '제어 이동이 @finally 블록의 초기화를 건너뜁니다'
# 'jump bypasses initialization of @synchronized block'
HB49518EF658F: '점프가 @synchronized 블록의 초기화를 건너뜁니다'
# 'jump bypasses initialization of @try block'
H4F2203657B83: '제어 이동은 @try 블록의 초기화를 건너뜁니다.'
# 'jump bypasses initialization of VLA type alias'
H06AE800C9022: '점프가 VLA 타입 별칭의 초기화를 건너뜁니다'
# 'jump bypasses initialization of VLA typedef'
H539D32051794: '점프가 VLA typedef의 초기화를 우회합니다'
# 'jump bypasses initialization of __except block'
H8945BA31631C: '점프가 __except 블록의 초기화를 건너뜁니다'
# 'jump bypasses initialization of __finally block'
HDC8606BFB8A0: '점프가 __finally 블록의 초기화를 건너뜁니다'
# 'jump bypasses initialization of __strong variable'
H4091D3DFA80B: '점프가 __strong 변수의 초기화를 건너뜁니다'
# 'jump bypasses initialization of __try block'
H17A1FDC40633: '점프가 __try 블록의 초기화를 회피합니다'
# 'jump bypasses initialization of __weak variable'
H2D2E5414450F: '점프가 __weak 변수의 초기화를 건너뛰었습니다'
# 'jump bypasses initialization of catch block'
H1AD4DA299533: 'catch 블록의 초기화를 우회하는 제어 이동입니다'
# 'jump bypasses initialization of non-POD variable'
H7894E3C8480C: '점프가 비POD 변수의 초기화를 건너뜁니다'
# 'jump bypasses initialization of try block'
H35C99F3D2CF6: 'jump가 try 블록의 초기화를 건너뜁니다'
# 'jump bypasses initialization of variable length array'
HD2CC21B5B2B9: '점프가 가변 길이 배열의 초기화를 건너뜁니다'
# 'jump bypasses initialization of variable of non-trivial C struct type'
H8DC117DB27D9: '점프가 비트리벌 C 구조체 타입의 변수 초기화를 우회합니다'
# 'jump bypasses initialization of variable with __attribute__((cleanup))'
H816408F197AB: '제어 이동이 __attribute__((cleanup))를 가진 변수의 초기화를 건너뜁니다'
# 'jump bypasses setup of __block variable'
H8FF055D54D20: '__block 변수의 설정을 건너뛰는 점프'
# 'jump bypasses variable initialization'
HDE484302CFDD: '점프가 변수 초기화를 건너ступ니다'
# 'jump bypasses variable with a non-trivial destructor'
H65EAD2757089: '제어 이동이 비平凡한 소멸자를 가진 변수를 건너뜁니다'
# 'jump enters Objective-C fast enumeration loop'
H0B68A5227D3D: 'ジャン프가 Objective-C의 빠른 열거 루프에 진입합니다'
# 'jump enters a statement expression'
HAF0C1FFF2BB0: '점프가 문장 표현으로 들어갑니다'
# 'jump enters controlled statement of consteval if'
H9FCC3E0998D5: '점프가 consteval if 제어문에 진입합니다.'
# 'jump enters controlled statement of constexpr if'
H53B0DD3B4BCF: 'jump가 constexpr if 제어문의 제어되는 문에 진입합니다'
# 'jump enters controlled statement of if available'
H0D6B49E1C06A: '점프가 if 조건이 사용 가능한 제어문에 진입합니다'
# 'jump enters lifetime of a compound literal that is non-trivial to destruct'
H84D2F4FDA1F2: 'jump가 비트리블 소멸자를 가지는 복합 리터럴의 생명주기에 진입합니다'
# 'jump enters lifetime of block which captures a C struct that is non-trivial to destroy'
HB60961C86BE4: '점프가 비상수 파괴가 가능한 C 구조체를 포획한 블록의 생명 주기 내부로 진입했습니다'
# 'jump enters lifetime of block which captures a destructible C++ object'
HFA59EFDF1B62: '제어 흐름이 파괴 가능한 C++ 객체를 포착하는 블록의 유효 기간에 진입합니다'
# 'jump enters lifetime of block which strongly captures a variable'
H2E28FE1D13B9: 'jump가 변수를 강하게 캡처하는 블록의 생명주기로 이동합니다'
# 'jump enters lifetime of block which weakly captures a variable'
H8ED7B1ED0204: '점프가 약하게 캡처한 변수를 갖는 블록의 생명 주기에 진입합니다'
# 'jump exits @catch block'
H00823EBB1453: '점프가 catch 블록을 탈출합니다'
# 'jump exits @finally block'
HDE9FECD28D12: '점프가 @finally 블록을 벗어납니다'
# 'jump exits @synchronized block'
H2C2C500585D3: 'jump는 @synchronized 블록에서 벗어납니다'
# 'jump exits @try block'
H60631B3B104F: '점프가 @try 블록을 벗어납니다'
# 'jump exits __except block'
HF0ECDC1D667A: '점프가 __except 블록을 이탈합니다'
# 'jump exits __finally block'
HEF15A26AC2B4: '점프가 __finally 블록을 벗어납니다'
# 'jump exits __try block'
HA371EC6EABEF: '점프가 __try 블록을 벗어납니다'
# 'jump exits autoreleasepool block'
HFA1102E13121: '점프가 autoreleasepool 블록을 벗어납니다'
# 'jump exits catch block'
HB15A540E97C0: 'jump catch 블록을 벗어납니다'
# 'jump exits lifetime of a compound literal that is non-trivial to destruct'
H581CCAF33BA1: '점프가 소멸하기에 비平凡적인 복합 리터럴의 수명 주기를 벗어납니다'
# 'jump exits lifetime of block which captures a C struct that is non-trivial to destroy'
H145F09CDB728: 'jump가 비트리벌한 파괴를 가진 C 구조체를 포착한 블록의 lifetime을 벗어납니다'
# 'jump exits lifetime of block which captures a destructible C++ object'
HFD90BDF2A71A: '점프가 파괴 가능한 C++ 객체를 캡처한 블록의 생명주기를 벗어납니다'
# 'jump exits lifetime of block which strongly captures a variable'
H633C0158D8CE: 'jump가 변수를 강하게 캡처하는 블록의 라이프타임을 벗어납니다'
# 'jump exits lifetime of block which weakly captures a variable'
H3C3B445ACF96: '점프가 약하게 변수를 캡쳐한 블록의 생명 주기를 벗어납니다'
# 'jump exits scope of OpenMP structured block'
H3960249ABF56: '점프가 OpenMP 구조화된 블록의 범위를 벗어납니다'
# 'jump exits scope of __block variable'
HCAFFF794B0B7: '점프가 __block 변수의 스코프를 벗어납니다'
# 'jump exits scope of __strong variable'
H09130C2189DF: '점프가 __strong 변수의 범위를 벗어납니다'
# 'jump exits scope of __weak variable'
H425A195D6F14: 'jump는 __weak 변수의 범위를 벗어납니다'
# 'jump exits scope of lifetime-extended temporary with non-trivial destructor'
H18BAD42D7AAF: '점프가 비트리비얼 소멸자를 가진 생존 기간이 연장된 임시 객체의 스코프를 벗어납니다'
# 'jump exits scope of variable with __attribute__((cleanup))'
H4BF0CCE50F51: '제어 흐름이 __attribute__((cleanup)) 속성을 가진 변수의 범위를 벗어납니다'
# 'jump exits scope of variable with non-trivial destructor'
HD66C6E5AB564: '점프가 비트리비얼 소멸자를 가진 변수의 스코프를 벗어납니다'
# 'jump exits try block'
HE15267C61E24: '점프가 try 블록을 벗어납니다'
# 'jump from switch statement to this case label is incompatible with C++'
H65E63DA93A2A: 'switch 문에서 이 case 라벨로의 점프는 C++과 호환되지 않습니다'
# 'jump from switch statement to this case label is incompatible with C++98'
HFD45DFD4341B: 'switch 문에서 이 case 라벨로의 점프는 C++98와 호환되지 않습니다'
# 'jump from this %select{indirect|asm}0 goto statement to one of its possible targets is incompatible with C++'
HCA1B45FA0F11: '이 %select{간접|어셈블리}0 goto 문에서 가능한 대상 중 하나로의 점프는 C++과 호환되지 않습니다'
# 'jump from this %select{indirect|asm}0 goto statement to one of its possible targets is incompatible with C++98'
H6B5196F09490: '이 %select{indirect|asm}0 goto 문에서 가능한 대상 중 하나로의 점프는 C++98과 호환되지 않습니다'
# 'jump from this goto statement to its label is a Microsoft extension'
HF443D2C187C8: '이 goto 문에서 레이블로의 점프는 Microsoft 확장 기능입니다'
# 'jump from this goto statement to its label is incompatible with C++'
HCF98C797091F: '이 goto 문에서 해당 라벨로의 점프는 C++과 호환되지 않습니다'
# 'jump from this goto statement to its label is incompatible with C++98'
H91A60091F523: '이 goto 문에서 이 레이블로의 점프는 C++98과 호환되지 않습니다'
# 'jump out of __finally block has undefined behavior'
HC63318A29EFB: 'finally 블록에서 벗어나는 점프는 정의되지 않은 동작을 유발합니다'
# 'jump tables support (default=basic)'
H004CDF2FB54A: '점프 테이블 지원 (default=basic)'
# 'just the yaml representation of the profile'
H77CB9F525531: '프로필의 YAML 표현만'
# 'keep going after reporting a UMR'
H5D280A550689: 'UMR을 보고한 후 계속 진행'
# 'keep no-op instructions. By default they are removed.'
H5294B5B42559: 'noop 명령문을 유지합니다. 기본적으로는 제거됩니다.'
# 'keep or generate .debug_aranges section if .gdb_index is written'
HF46D8AA36DF8: '만약 .gdb_index가 작성되면 .debug_aranges 섹션을 유지하거나 생성합니다.'
# 'kernel call to non-global function %0'
HE2C1F06E4669: '커널 호출에 전역이 아닌 함수 %0가 사용되었습니다'
# 'kernel function %0 is a member function; this may not be accepted by nvcc'
H6C2BA696CEAF: '커널 함수 %0는 멤버 함수입니다; 이는 nvcc에 의해 허용되지 않을 수 있습니다'
# 'kernel function %0 must be a free function or static member function'
H16FEF3B5D436: '커널 함수 %0는 일반 함수이거나 정적 멤버 함수여야 합니다'
# 'kernel function type %0 must have void return type'
H95AC5DFCBCA0: '커널 함수 유형 %0는 void 반환 형식을 가져야 합니다'
# 'kernel functions cannot be class members'
H49F7A4460E40: '커널 함수는 클래스 멤버일 수 없습니다.'
# 'kernel functions cannot be declared static'
H4969597F9236: '커널 함수는 static으로 선언될 수 없습니다'
# 'kernel functions cannot be used in a template declaration, instantiation or specialization'
HD5AD84DAA9C6: '커널 함수는 템플릿 선언, 인스턴스화 또는 특수화에서 사용할 수 없습니다.'
# 'kernel must have void return type'
H2245CF70F0F9: '커널은 void 반환 형식을 가져야 합니다'
# 'kernel parameter cannot be declared as a pointer to a pointer'
HA03E5339986E: '커널 매개변수는 포인터의 포인터로 선언될 수 없습니다'
# "keyword '%0' will be made available as an identifier %select{here|for the remainder of the translation unit}1"
HB2136B9BC89D: "키워드 '%0'가 식별자로 %select{여기서|번역 단위의 나머지 부분에서}1 사용 가능하게 됩니다"
# 'keyword is hidden by macro definition'
HB53596605CAF: '키워드는 매크로 정의에 의해 숨겨집니다'
# 'kind mapping string to set kind precision'
HE046AE1AA112: '종류 매핑 문자열을 사용하여 종류 정밀도 설정'
# "known but unsupported action '%1' for '#pragma %0' - ignored"
H07B6796F45BE: "알려져 있지만 지원되지 않는 '#pragma %0'의 동작 '%1' - 무시됨"
# "label '%0' is reserved: use a different label name for -X<label>"
H0A75EFF64B4C: "라벨 '%0'은 예약되었습니다: -X<label> 옵션에 사용할 다른 라벨 이름을 사용하세요"
# 'label at end of compound statement is a C++23 extension'
H696C9202732B: '레이블이 복합 문의 끝에 오는 것은 C++23 확장 기능입니다'
# 'label at end of compound statement is a C23 extension'
H24E471EE8FE1: '레이블이 복합문의 끝에 있는 것은 C23 확장입니다'
# 'label at end of compound statement is incompatible with C standards before C23'
H8E280A51EBD5: '복합 문의 끝에 위치한 레이블은 C23 이전의 C 표준과 호환되지 않습니다'
# 'label at end of compound statement is incompatible with C++ standards before C++23'
H1F208E16CB25: '복합문의 끝에 위치한 라벨은 C++23 이전의 C++ 표준과 호환되지 않습니다'
# 'label followed by a declaration is a C23 extension'
HE476C0C2BE2F: '레이블이 선언을 따라오면 C23 확장 기능입니다'
# 'label followed by a declaration is incompatible with C standards before C23'
H8299673D895A: 'C23 이전의 C 표준과 호환되지 않는 레이블 뒤에 선언'
# 'lambda %0 is inaccessible due to ambiguity:%1'
H165915C96E61: 'lambda %0는 모호성으로 인해 접근할 수 없습니다:%1'
# 'lambda call operator should not be explicitly specialized or instantiated'
H3541695AB458: '람다 호출 연산자는 명시적으로 특수화되거나 인스턴스화되어서는 안 됩니다'
# 'lambda cannot be both mutable and static'
H057D935E257D: 'lambda는 mutable과 static 속성을 동시에 가질 수 없습니다'
# 'lambda cannot be declared %0'
H523BA4919111: '람다 표현식은 %0로 선언될 수 없습니다'
# 'lambda capture %0 is not %select{used|required to be captured for this use}1'
HED12D4324492: '람다 캡처 %0는 %select{사용되지 않았습니다|이 사용을 위해 캡처되어야 합니다}1'
# 'lambda closure types are non-literal types before C++17'
H3BDD817E383F: '람다 클로저 유형은 C++17 이전에는 리터럴이 아닌 유형입니다'
# 'lambda expression begins here'
H0582B6A6C9FD: '람다 표현식이 여기서 시작됩니다'
# 'lambda expression in an unevaluated operand'
H2B5A38CCEDAB: '미평가 피연산자 내 람다 표현식'
# 'lambda expression in default argument cannot capture any entity'
H31423DFF8FC2: '기본 인수의 람다 표현식은 어떤 개체도 캡처할 수 없습니다'
# 'lambda expressions are incompatible with C++98'
HAE0AFEA72154: '람다 표현식은 C++98과 호환되지 않습니다'
# 'lambda template parameter list cannot be empty'
H33C909CD1D80: 'lambda 템플릿 매개변수 목록은 비어 있을 수 없습니다'
# 'lambda without a parameter clause is a C++23 extension'
HD70498A5F3EC: 'lambda 매개변수 절이 없는 것은 C++23 확장 기능입니다'
# 'lambdas are a %select{C++11|clang HLSL}0 extension'
HD58884723190: '람다 표현식은 %select{C++11|clang HLSL}0 확장 기능입니다'
# "language not recognized: '%0'"
H102C1DB9CB0E: "알 수 없는 언어: '%0'"
# 'large atomic operation may incur significant performance penalty; the access size (%0 bytes) exceeds the max lock-free size (%1 bytes)'
H31655F77BD73: '대규모 원자 연산은 성능 패널티를 유발할 수 있습니다; 접근 크기 (%0 바이트)가 최대 lock-free 크기 (%1 바이트)를 초과합니다'
# 'layout blocks in reverse order'
H19EE0FFEC518: '레이아웃 블록을 역순으로 배치합니다'
# 'lcov tracefile output'
HCE669C9CA888: 'lcov 추적 파일 출력'
# 'left hand operand of type %0 to compound assignment cannot be truncated when used with right hand operand of type %1'
H00D9FE7F4F87: '복합 할당의 왼쪽 피연산자 타입 %0는 오른쪽 피연산자 타입 %1과 함께 사용될 때 잘림을 허용할 수 없습니다'
# 'left hand operand to %0 must be a %select{|pointer to }1class compatible with the right hand operand, but is %2'
HE8A81161D486: '왼쪽 피연산자 %0는 오른쪽 피연산자와 호환되는 %select{포인터|}1class여야 하지만, %2입니다'
# 'left hand side of assignment operation(%0) must match one side of the sub-operation on the right hand side(%1 and %2)'
HEDD23F979FED: '할당 연산의 좌측(%0)은 우측 하위 연산의 한쪽(%1과 %2)과 일치해야 합니다'
# 'left operand of comma operator has no effect'
H1D36CC5E4D5A: '콤마 연산자의 왼쪽 피연산자의 결과가 사용되지 않습니다'
# 'left shift of negative value %0'
HF788BD55C118: '왼쪽 시프트 연산에 음의 값 %0 사용'
# "length modifier '%0' results in undefined behavior or no effect with '%1' conversion specifier"
HDCB24BE7C9E8: "길이 수정자 '%0'를 '%1' 변환 지정자와 함께 사용하면 정의되지 않은 동작이 발생하거나 효과가 없습니다"
# 'libclc builtin preparation tool\n'
H8679FDE4DA62: 'libclc 내장 준비 도구\n'
# 'limit number of targets to consider when doing indirect call promotion on calls. 0 = no limit'
HD2EF861DC5DB: '간접 호출 프로모션을 수행할 때 고려할 대상 수를 제한합니다. 0 = 제한 없음'
# 'limit number of targets to consider when doing indirect call promotion on jump tables. 0 = no limit'
H039F79707FDF: '점프 테이블에서 간접 호출 승격을 할 때 고려할 대상의 수를 제한합니다. 0 = 제한 없음'
# 'limit number of targets to consider when doing indirect call promotion. 0 = no limit'
H5880E8C77FBD: '간접 호출 프로모션을 수행할 때 고려할 대상의 수를 제한합니다. 0 = 제한 없음'
# 'limit optimizations to functions from the list'
HF1AAD3BC1D5B: '리스트에 있는 함수에 최적화를 제한합니다'
# 'limit optimizations to functions from the list (non-regex)'
H4820DAC9F83B: '리스트에 있는 함수들에 최적화를 제한합니다 (정규 표현식이 아닌)'
# 'line marker directive requires a positive integer argument'
H8A0833C758AF: '라인 마커 지시문은 양의 정수 인수를 필요로 합니다'
# 'line splicing in Doxygen comments are not supported'
HD6510289D84D: 'Doxygen 주석에서의 줄 이어 쓰기는 지원되지 않습니다'
# "linking module '%0': %1"
H78786E2D2737: "모듈 '%0'을 링크 중: %1"
# 'linking options'
H1E4F081C74A1: '링크 옵션'
# 'list item of type %0 is not valid for specified reduction operation: unable to provide default initialization value'
H5FEA755CA374: '타입 %0인 목록 항목은 지정된 감소 연산에 유효하지 않습니다: 기본 초기화 값을 제공할 수 없습니다'
# 'list of functions to always consider for inlining'
H00FB00D60661: '인라인을 위해 항상 고려할 함수 목록'
# 'list of functions to apply frame opts'
H723CBEBF937F: '프레임 옵션을 적용할 함수 목록'
# 'list of functions to core dump on (debugging)'
HFF95EE476741: '코어 덤프 발생 함수 목록 (디버깅)'
# 'list of functions to enable ICP for'
H4EBB92971A75: 'ICP를 활성화하기 위한 함수 목록'
# 'list of functions to never consider for inlining'
HE127B8F1CD43: '인라인 처리 대상으로 고려하지 않는 함수 목록'
# 'list of functions to pad with amount of bytes'
H296C1F5DDCF1: '바이트 양으로 패딩할 함수 목록'
# 'list of functions to print'
H1C3AE7A6EC95: '출력할 함수 목록'
# 'list of functions to skip'
HED4CB34A956C: '건너뛸 함수 목록'
# 'list of functions with call sites for which to specialize memcpy() for size 1'
HD7F5B54EFF49: 'memcpy()를 크기 1에 대해 특수화하기 위한 호출 위치를 가진 함수 목록'
# "list of sections containing functions used for hugifying hot text. BOLT makes sure these functions are not placed on the same page as the hot text. (default='.stub,.mover')."
H07A4ADB5443D: "hot text를 위해 사용되는 함수를 포함하는 섹션 목록입니다. BOLT는 이러한 함수가 hot text와 같은 페이지에 배치되지 않도록 보장합니다. (기본값='.stub,.mover')."
# 'list of sections to reorder'
HE8B5B16B7FA7: '재정렬할 섹션 목록'
# 'list of symbol names that can be reordered'
H6F9EE9EC82ED: '재정렬할 수 있는 심볼 이름 목록'
# 'list of symbol names that cannot be reordered'
H9016DB56BAB4: '재정렬할 수 없는 기호 이름 목록'
# 'literal construction method %0 has incompatible signature'
H9A98E6827407: '리터럴 생성 메서드 %0는 호환되지 않는 시그니처를 가지고 있습니다.'
# 'literal operator %0 must be in a namespace or global scope'
H6F0C93D8CF92: '리터럴 연산자 %0는 네임스페이스 또는 글로벌 스코프에 있어야 합니다'
# 'literal operator cannot have a default argument'
H2D253A373F0C: '리터럴 연산자는 기본 인수를 가질 수 없습니다'
# 'literal operator must have C++ linkage'
HACF64718BD51: '리터럴 연산자는 C++ 링크지정을 가져야 합니다.'
# 'literal operator template cannot have any parameters'
HDB57FAFF64D9: '리터럴 연산자 템플릿은 매개변수를 가질 수 없습니다'
# 'literal operators are incompatible with C++98'
HC63AE1FBA425: '리터럴 연산자는 C++98와 호환되지 않습니다'
# 'lldb'
H23F2598B46BF: 'LLDB'
# 'llvm .bc -> .bc modular optimizer and analysis printer\n'
H5E0E5487AF50: 'LLVM .bc -> .bc 모듈 최적화 및 분석 프린터\n'
# 'llvm .bc -> .ll disassembler\n'
H6C7F6E9C06C4: 'llvm .bc → .ll 디아셈블러\n'
# 'llvm .ll -> .bc assembler\n'
HD4712D9BC53E: 'llvm .ll -> .bc 어셈블러\n'
# 'llvm LTO linker\n'
H2892DC655E08: 'LLVM LTO 링커\n'
# 'llvm MC-JIT tool\n'
H06636F581609: 'LLVM MC-JIT 도구\n'
# 'llvm SPGO profile generator\n'
H701BD947180F: 'LLVM SPGO 프로필 생성기\n'
# 'llvm codegen stress-tester\n'
HA26868605BE5: 'llvm codegen 스트레스-테스터\n'
# 'llvm extractor\n'
HFF048809A3CA: 'llvm 추출기\n'
# 'llvm host machine instruction characteristics measurment and analysis.\n'
HF3F3BF01E352: 'LLVM 호스트 머신 명령어 특성 측정 및 분석.\n'
# 'llvm interpreter & dynamic compiler\n'
H0649CD7E70C5: 'LLVM 인터프리터 & 동적 컴파일러\n'
# 'llvm jit event listener test utility\n'
HC7AAB55CF667: 'llvm jitlink 도구'
# 'llvm jitlink tool'
H2709B44451E8: 'llvm jitlink 도구'
# 'llvm linker\n'
HC9DC12DE7069: 'LLVM 링커\n'
# 'llvm machine code performance analyzer.\n'
H684FDD543DA3: 'LLVM 머신 코드 성능 분석기.\n'
# 'llvm machine code playground\n'
H2F51084FBDF0: 'LLVM 머신 코드 플레이그라운드\n'
# 'llvm system compiler\n'
H8181CA7521BB: 'LLVM 시스템 컴파일러\n'
# 'llvm tool to verify use-list order\n'
HAC60F05F36A9: 'LLVM 도구를 사용하여 use-list 순서 검증\n'
# 'llvm-as Options'
HCEBF82BEB0E9: 'llvm-as 옵션'
# 'llvm-bcanalyzer file analyzer\n'
HECC62C366128: 'llvm-bcanalyzer 파일 분석기\n'
# 'llvm-boltdiff - BOLT binary diff tool\n\nEXAMPLE: llvm-boltdiff -data=a.fdata -data2=b.fdata exec1 exec2\n'
HB49452FEF405: 'llvm-boltdiff - BOLT 바이너리 차이 도구\n\n예제: llvm-boltdiff -data=a.fdata -data2=b.fdata exec1 exec2\n'
# 'llvm-cat Options'
H3A2E2CA997D5: 'llvm-cat 옵션'
# 'llvm-exegesis analysis options'
H89DF2607CBEA: 'llvm-exegesis 분석 옵션'
# 'llvm-exegesis benchmark options'
HC43701CE0D82: 'llvm-exegesis 벤치마크 옵션'
# 'llvm-exegesis options'
HAF6D3F27C196: 'llvm-exegesis 옵션'
# 'llvm-extract Options'
H25F0C853A66B: 'llvm-extract 옵션'
# 'llvm-omp-kernel-replay Options'
H90111C7D3334: 'llvm-omp-kernel-replay 옵션'
# 'llvm-opt-report options'
HCF4237251086: 'llvm-opt-report 옵션'
# 'llvm-reduce options'
H9B15C3D059EC: 'llvm-reduce 옵션'
# 'load the input file as a Toy source.'
H8076D5B81C5F: '입력 파일을 Toy 소스로 로드합니다.'
# 'load the input file as an MLIR file'
HAC00602D295B: '입력 파일을 MLIR 파일로 로드합니다'
# "loaded module file '%0' conflicts with imported file '%1'"
H758569B6F13F: "로드된 모듈 파일 '%0'이(가) 가져온 파일 '%1'과(와) 충돌됩니다"
# 'loader options'
HA2203CDD473C: '로더 옵션'
# "loading modulemap '%0'"
HB01A5C3EDED8: "'%0' 모듈 맵을 로딩 중입니다"
# "loading parsed module '%0'"
H71E4776B6574: "구문 분석된 모듈 '%0'을(를) 로딩 중입니다"
# 'local %select{struct|interface|union|class|enum}0 cannot be declared __module_private__'
H4E0562614A60: '로컬 %select{struct|interface|union|class|enum}0은(는) __module_private__로 선언할 수 없습니다'
# 'local declaration nearly matches'
HA030BEFE649C: '로컬 선언이 거의 일치합니다'
# 'local declaration of %0 hides instance variable'
H09900D49A0E3: '지역 변수 선언 %0가 인스턴스 변수를 가리고 있습니다'
# 'local type %0 as template argument is incompatible with C++98'
H6116FD3EFF04: '지역 타입 %0를 템플릿 인자로 사용하면 C++98과 호환되지 않습니다'
# "local variable '%0' should not be used in 'declare target' directive;"
HF2D2B034481C: "지역 변수 '%0'은 'declare target' 지시어에서 사용되어서는 안 됩니다;"
# "local variable cannot be declared 'constinit'"
HE35DCF249418: "로컬 변수는 'constinit'로 선언할 수 없습니다"
# "locking '%0' to build module '%1'"
H36ABFAB03219: " '%0'을 모듈 '%1' 빌드를 위해 잠급니다."
# 'logical expression with vector %select{type %1 and non-vector type %2|types %1 and %2}0 is only supported in C++'
H1200F428FBB0: '벡터 %select{유형 %1과 비벡터 유형 %2|유형 %1과 %2}0를 가진 논리 표현식은 C++에서만 지원됩니다'
# 'logical not is only applied to the left hand side of this %select{comparison|bitwise operator}0'
H9E8ECD267F25: '논리적 부정은 이 %select{비교|비트 연산자}0의 왼쪽 피연산자에만 적용됩니다.'
# 'lookup from the current scope refers here'
H9AFA3EAEA36F: '현재 스코프에서의 참조가 여기를 가리킵니다'
# 'lookup in the object type %0 refers here'
H3FD57FB46E2B: '객체 타입 %0의 조회가 여기를 가리킵니다'
# 'lookup of %0 in member access expression is ambiguous'
H52F57D0BB44E: '멤버 접근 표현식에서 %0의 조회가 모호합니다'
# 'lookup of %0 in member access expression is ambiguous; using member of %1'
H632E112FD2AD: '멤버 접근 표현식에서 %0을 찾는 것이 애매합니다; %1의 멤버를 사용합니다'
# "loop iteration variable in the associated loop of 'omp %1' directive may not be %0, predetermined as %2"
H777624FA6F75: 'omp %1 지시문의 관련된 루프에서 루프 반복 변수는 미리 결정된 %2로 지정되어야 하므로 %0일 수 없습니다'
# 'loop step is expected to be %select{negative|positive}0 due to this condition'
HF9B9B19EF744: '루프 단계는 이 조건으로 인해 %select{negative|positive}0이어야 합니다'
# 'loop to be fully unrolled must have a constant trip count'
HF58CAD452050: '완전히 언롤링되기 위한 루프는 상수 트립 카운트를 가져야 합니다'
# 'loop variable %0 %diff{of type $ binds to a temporary constructed from type $|binds to a temporary constructed from a different type}1,2'
H8E540E772339: '루프 변수 %0 %diff{유형 $인 변수가 유형 $로 생성된 일시 객체에 바인딩됩니다|다른 유형으로 생성된 일시 객체에 바인딩됩니다}1,2'
# 'loop variable %0 binds to a temporary value produced by a range of type %1'
HDD2F7E9780FE: '루프 변수 %0는 %1 형식의 범위에 의해 생성된 임시 값에 바인딩됩니다'
# 'loop variable %0 creates a copy from type %1'
H0EB738A6DA64: '루프 변수 %0는 타입 %1로부터 복사본을 생성합니다'
# "loop variable %0 may not be declared %select{'extern'|'static'|'__private_extern__'|'auto'|'register'|'constexpr'|'thread_local'}1"
HD1C2B82FE9FA: "루프 변수 %0는 %select{'extern'|'static'|'__private_extern__'|'auto'|'register'|'constexpr'|'thread_local'}1로 선언될 수 없습니다"
# "loop variable of loop associated with an OpenACC '%0' construct must be of integer, pointer, or random-access-iterator type (is %1)"
HDE685F11E1FA: "OpenACC '%0' 구조와 연관된 루프의 루프 변수는 정수, 포인터 또는 random-access-iterator 유형이어야 합니다 (현재 %1 유형입니다)"
# 'loop will run at most once (loop increment never executed)'
H41A7771F3080: '루프는 최대 한 번만 실행됩니다 (루프 증분이 실행되지 않았습니다)'
# "loop with a '%0' clause may not exist in the region of a '%1' clause%select{| on a '%3' construct}2"
H31D69B81DD7A: "'%0' 절이 '%1' 절의 영역 내에 존재할 수 없습니다%select{| '%3' 구조에서}2"
# 'lower transpose without using a runtime call'
H1DC7FFF629C0: '런타임 호출을 사용하지 않고 전치 변환'
# 'mac68k alignment pragma is not supported on this target'
H13A22B895D9E: '이 타겟에서는 mac68k 정렬 pragma가 지원되지 않습니다'
# 'macro %0 defined here'
H224BD0DEAAD4: '매크로 %0 여기에서 정의되었습니다'
# 'macro %0 has been marked as deprecated%select{|: %2}1'
HB9E9BBB38434: '매크로 %0는 비추천됨으로 표시되었습니다%select{|: %2}1'
# 'macro %0 has been marked as final and should not be %select{undefined|redefined}1'
H416ADCAF4BDC: '매크로 %0는 최종적으로 표시되었으며 %select{정의되지 않았거나|재정의되거나}1해서는 안 됩니다'
# 'macro %0 has been marked as unsafe for use in headers%select{|: %2}1'
H0BD2BA6647E5: '매크로 %0는 헤더 파일에서 사용하지 않도록 표시되었습니다%select{|: %2}1'
# "macro '%0' contains embedded newline; text after the newline is ignored"
HCA29C3134207: "매크로 '%0'에 내장된 개행문자가 포함되었습니다; 개행문자 이후의 텍스트는 무시됩니다"
# "macro '%0' was %select{defined|undef'd}1 in the precompiled file '%2' but %select{undef'd|defined}1 on the command line"
H4EEB08267D43: "매크로 '%0'이(가) 사전 컴파일 파일 '%2'에서 %select{정의됨|제거됨}1이(가) 있지만 명령줄에서는 %select{제거됨|정의됨}1입니다"
# "macro expansion producing 'defined' has undefined behavior"
H6CE80CBEAD13: "매크로 확장이 'defined'를 생성하는 것은 미정의 동작입니다"
# 'macro is not used'
HB7A93ECCBE4F: '매크로가 사용되지 않았습니다'
# "macro marked '%select{deprecated|restrict_expansion|final}0' here"
H36EC3D2C5C8F: "매크로가 여기에 '%select{비추천됨|확장 제한|최종}0'로 표시되었습니다"
# 'macro name is a reserved identifier'
H75F2505E76F7: '매크로 이름은 예약된 식별자입니다.'
# 'macro name missing'
H64036DCA4179: '매크로 이름 누락'
# 'macro name must be an identifier'
HA83E076252EC: '매크로 이름은 식별자여야 합니다'
# "macro was %select{defined|#undef'd}0 here"
H90411BE5521B: '매크로가 %select{정의됨|#undef 처리됨}0 이 위치에서'
# 'magnitude of floating-point constant too large for type %0; maximum is %1'
HC45BAE211EEF: '부동소수점 상수의 크기가 %0 유형에 너무 큽니다; 최대값은 %1입니다'
# 'magnitude of floating-point constant too small for type %0; minimum is %1'
H77948F2AADFE: '부동소수점 상수의 크기가 %0 유형에 너무 작습니다; 최소값은 %1입니다'
# 'main cannot be declared as a variable %select{in the global scope|with C language linkage}0'
HDFAAFDDA66C4: 'main은 변수로 선언될 수 없습니다 %select{전역 범위에서|C 언어 연결성과 함께}0'
# 'main file cannot be included recursively when building a preamble'
HFA8D0D05FC55: '주 파일은 프리에이블을 생성할 때 재귀적으로 포함될 수 없습니다'
# 'make jump tables size smaller at the cost of using more instructions at jump sites'
HFB74BDFA805D: '점프 테이블의 크기를 작게 하기 위해 점프 위치에서 더 많은 명령문을 사용합니다'
# 'make the interpreter print every volatile load and store'
H89B411120801: '인터프리터가 모든 volatile 로드와 스토어를 출력하게 함'
# "malformed block record in PCH file: '%0'"
H89FF1C99B4CC: "PCH 파일의 손상된 블록 레코드: '%0'"
# "malformed or corrupted precompiled file: '%0'"
H32ACB7141453: "잘못된 형식 또는 손상된 사전 컴파일 파일: '%0'"
# "malformed sanitizer coverage allowlist: '%0'"
HA08307F61916: "잘못된 형식의 정화 커버리지 허용 목록: '%0'"
# "malformed sanitizer coverage ignorelist: '%0'"
HF4CE0A42147C: "잘못된 형식의 sanitizer coverage ignorelist: '%0'"
# "malformed sanitizer ignorelist: '%0'"
H98473149CB24: "잘못된 형식의 sanitizer 무시 목록: '%0'"
# "malformed sanitizer metadata ignorelist: '%0'"
H7E49790904E8: "잘못된 sanitizer 메타데이터 ignorelist: '%0'"
# 'mangled name of %0 will change in C++17 due to non-throwing exception specification in function signature'
HC8027193700F: 'C++17에서 함수 서명의 non-throwing 예외 지정으로 인해 %0의 mangling 이름이 변경됩니다'
# "map type '%0' is previous specified here"
H3204C79CA043: "맵 형식 '%0'는 이미 여기에서 지정되었습니다"
# 'map type is already specified'
HF4D36EA9229E: '맵 형식은 이미 지정되었습니다'
# "map type modifier '%0' is not allowed for '#pragma omp %1'"
H5A1E07271479: "매핑 유형 수정자 '%0'는 '#pragma omp %1'에 허용되지 않습니다"
# 'mapper type must be of struct, union or class type'
H3D3958379C94: 'mapper 형식은 struct, union 또는 class 형식이어야 합니다'
# 'mapping of union members is not allowed'
HD27CBEC61BC1: '유니언 멤버의 매핑은 허용되지 않습니다'
# "mark %0 as '%select{final|sealed}1' to silence this warning"
HF7273FC85EE1: "%0를 '%select{final|sealed}1'로 지정하여 이 경고를 무시하십시오"
# "mark 'operator==' as const or add a matching 'operator!=' to resolve the ambiguity"
H5A25A1F05320: 'operator==을 const로 표시하거나 일치하는 operator!=을 추가하여 모호함을 해결하십시오.'
# "mark function boundaries with break instruction to make sure we accidentally don't cross them"
H5B830E6175D2: 'break 명령어로 함수 경계를 표시하여 의도하지 않게 넘어가지 않도록 합니다'
# 'marked %0 here'
HE33E97AC0225: '%0가 여기에서 표시됨'
# "marked as 'declare variant' here"
H721AFFF82622: "여기서 'declare variant'로 지정되었습니다."
# "marked as 'device_type(%0)' here"
HF283C800233B: "여기서 'device_type(%0)'로 지정되었습니다"
# 'mask type size must be between 1-byte and 8-bytes'
HA5CB60FF0FBF: '마스크 유형 크기는 1바이트와 8바이트 사이여야 합니다'
# 'match functions in binary 2 to binary 1 if they have the same hash of a function in binary 1'
HAF6822E35564: '1번 바이너리의 함수와 동일한 해시값을 가진 경우 2번 바이너리의 함수들을 1번 바이너리와 매치합니다'
# "math errno enabled by '%0' after it was implicitly disabled by '%1', this may limit the utilization of the vector library"
HE93B3822306D: "math errno가 '%1'에 의해 암시적으로 비활성화된 후 '%0'에 의해 활성화되었습니다. 이는 벡터 라이브러리의 활용을 제한할 수 있습니다"
# 'mathematical notation character <U+%0> in an identifier is a Clang extension'
H0378BC9B5A74: '식별자에 수학 표기법 문자 <U+%0>는 Clang 확장 기능입니다'
# 'matrix %select{row|column}0 index is not an integer'
H46FD8A206DB4: '행렬 %select{row|column}0 인덱스가 정수가 아닙니다'
# 'matrix %select{row|column}0 index is outside the allowed range [0, %1)'
H847B8076D2C2: '행렬 %select{행|열}0 인덱스가 허용 범위 [0, %1)을 벗어났습니다.'
# 'matrix row and column subscripts cannot be separated by any expression'
H5ED6E19FD5C5: '행렬의 행과 열 인덱스는 어떤 표현식으로도 구분될 수 없습니다'
# 'matrix types extension is disabled. Pass -fenable-matrix to enable it'
H4F1847B4A9E6: 'matrix types extension은 비활성화 되었습니다. -fenable-matrix 옵션을 전달하여 활성화할 수 있습니다'
# 'max depth when checking alias info in GatherAllAliases()'
HB91994902F54: 'GatherAllAliases() 내에서 알리아스 정보를 확인할 때의 최대 깊이'
# 'max number of bytes for the function to be considered small for inlining purposes'
H5D6C3AFD428B: '인라인 목적으로 함수가 작다고 간주되기 위한 바이트의 최대 수'
# 'max stack depth tracing'
H293E22C2DAE9: '최대 스택 깊이 추적'
# 'max stack depth tracing should use callback and only when stack depth more than specified'
HD415B8718378: '최대 스택 깊이 추적은 콜백을 사용해야 하며 스택 깊이가 지정된 값보다 클 때만 사용해야 합니다'
# 'maxclusterrank requires sm_90 or higher, CUDA arch provided: %0, ignoring %1 attribute'
H49A2942ECE44: 'maxclusterrank는 sm_90 이상이 필요합니다. 제공된 CUDA 아키텍처: %0, %1 속성을 무시합니다'
# 'maximal number of instructions to instrument in any given BB'
H65055BD64342: '어떤 주어진 BB 내에서 인스트루먼트할 수 있는 명령문의 최대 수'
# 'maximum address considered valid for heatmap (default 4GB)'
H617E4DDA7E48: '히트맵에서 유효한 것으로 간주되는 최대 주소 (기본값 4GB)'
# 'maximum function durations'
H6F70690AFB07: '최대 함수 지속 시간'
# 'maximum number of bytes to reorder'
H584FBF1D94C1: '재정렬할 최대 바이트 수'
# 'maximum number of bytes to use to align functions'
H20C9D30AEBA6: '함수 정렬에 사용할 최대 바이트 수'
# 'maximum number of call sites to inline'
H4BA4C864A650: '인라인 할 수 있는 최대 호출 위치 수'
# 'maximum number of data relocations to process'
HD03C0F0EA38B: '처리할 데이터 재배치의 최대 수'
# 'maximum number of functions to print in top called functions section'
HB5333D52E6C6: '가장 많이 호출된 함수 섹션에 출력할 함수의 최대 개수'
# 'maximum number of functions to process'
H09D081159F9B: '프로세스할 함수의 최대 개수'
# 'maximum number of hot basic blocks in a function for which to use a precise TSP solution while re-ordering basic blocks'
HA8A2B1281362: '함수 내에서 기본 블록 재정렬 시 정확한 TSP 솔루션을 사용하기 위해 허용되는 최대 핫 기본 블록 수'
# 'maximum number of inline iterations'
HF9B3A8E58122: 'inline 반복의 최대 수'
# 'maximum number of samples to read from LBR profile'
H39D9A5AFA87A: 'LBR 프로파일에서 읽을 샘플의 최대 수'
# 'maximum number of symbols to reorder'
HB1688A460BA8: '재정렬할 최대 심볼 수'
# 'maximum percentage of stale functions to tolerate (default: 100)'
H9341327D8697: '용인할 수 있는 stale 함수의 최대 비율 (기본값: 100)'
# 'maximum search depth. 0 forces a greedy approach. warning: the algorithm is up to O(2^N), where N is the max depth.'
H61B898BD8A31: '최대 탐색 깊이. 0은 탐욕 알고리즘을 강제합니다. 경고: 알고리즘은 N이 최대 깊이일 때 최대 O(2^N)입니다.'
# "meaningless '%0' on asm outside function"
H7C9CC9A0FF49: "함수 밖의 asm에서 '%0'는 의미가 없습니다."
# 'median function durations'
H4412290B83EA: '중앙값 함수 지속 시간'
# 'member %0 cannot have template arguments'
H7530E8235E69: '멤버 %0는 템플릿 인수를 가질 수 없습니다'
# "member %0 declared 'const' here"
H320C50D376E4: "멤버 %0이(가) 여기서 'const'로 선언되었습니다"
# 'member %0 declared here'
H523D63E160D3: '멤버 %0 여기서 선언되었습니다'
# 'member %0 first declared here'
H53F314C373D4: '멤버 %0 처음 여기서 선언됨'
# 'member %0 found in multiple base classes of different types'
HE96F2F88498F: '%0 멤버가 서로 다른 유형의 기반 클래스에서 여러 번 발견되었습니다'
# 'member %0 has the same name as its class'
HBDCB2F361AEB: '클래스와 동일한 이름을 가진 멤버 %0입니다'
# 'member %0 of %1 is not a template; did you mean %select{|simply }2%3?'
H88F478FC5C17: '멤버 %0은 %1의 템플릿이 아닙니다; 의도한 바는 %select{|단순히 }2%3이었나요?'
# 'member %0 used before its declaration'
H21EA4914C844: '멤버 %0는 선언 전에 사용되었습니다'
# 'member access into incomplete type %0'
H3F51F529F796: '완전하지 않은 형식 %0에 대한 멤버 접근'
# 'member declaration does not match because it %select{is|is not}0 const qualified'
HB51C7FC5370B: '멤버 선언이 일치하지 않습니다.因为它 %select{const 자격을 갖추었습니다|const 자격을 갖추지 않았습니다}0 때문입니다'
# 'member declaration nearly matches'
HA07B45D5B59A: '멤버 선언이 거의 일치합니다'
# 'member found by ambiguous name lookup'
H1816E255A34E: '모호한 이름 조회를 통해 발견된 멤버'
# 'member function %0 is not needed and will not be emitted'
HC39E7B7627B2: '멤버 함수 %0는 필요하지 않아 생략됩니다'
# 'member function specialization matches %0'
HCDF99A0E6C9D: '멤버 함수 특수화가 %0와 일치합니다'
# 'member initializer %0 does not name a non-static data member or base class'
H35E3E12D1C39: '멤버 초기화자 %0는 비정적 데이터 멤버 또는 기반 클래스를 지정하지 않았습니다'
# 'member is declared here'
H08E5DDE7EA19: 'member는 여기서 선언되었습니다'
# "member is not a candidate because range type %0 has no '%select{end|begin}1' member"
HE822EBF784D6: "멤버가 후보가 아닙니다. %0 범위 형식은 '%select{end|begin}1' 멤버를 가지지 않기 때문입니다"
# 'member not initialized by constructor'
H26EC51B7C7A4: '멤버가 생성자에 의해 초기화되지 않았습니다'
# 'member of anonymous %select{struct|union}0 redeclares %1'
H9C0924E1182A: '익명 %select{struct|union}0의 멤버가 %1을 재선언합니다'
# 'member pointer has incomplete base type %0'
H9CA90CC9D193: '멤버 포인터의 기본 형식 %0는 불완전합니다'
# 'member pointer representation requires a complete class type for %0 to perform this expression'
HA14D1B995CD2: '멤버 포인터 표현은 이 표현을 수행하기 위해 %0에 대해 완전한 클래스 형식이 필요합니다'
# 'member reference base type %0 is not a structure or union'
HDDC7E94D7C4D: '멤버 참조 기반 타입 %0는 구조体型이나 공용体型이 아닙니다'
# "member reference type %0 is %select{a|not a}1 pointer; did you mean to use '%select{->|.}1'?"
HCE4396C30D63: "%0 유형은 %select{포인터입니다|포인터가 아닙니다}1; '%select{->|.}1' 연산자를 사용하려는 것이었나요?"
# 'member reference type %0 is not a pointer'
H1067A041C0C1: '멤버 참조 형식 %0는 포인터가 아닙니다'
# 'member template declared %0 here'
H81FEA7456BEB: '멤버 템플릿이 %0 여기에서 선언되었습니다'
# 'member type %0 found by ambiguous name lookup'
H1BDBA1C8E5BA: '멤버 타입 %0가 모호한 이름 검색에 의해 발견됨'
# 'member using declaration naming a non-member enumerator is incompatible with C++ standards before C++20'
HFDD47D4DEC61: 'C++20 이전 표준과 호환되지 않는 비멤버 열거자를 명명하는 멤버 using 선언문입니다'
# "member using declaration naming non-class '%0' enumerator is incompatible with C++ standards before C++20"
H3AC79AC99394: "비클래스 '%0' 열거자를 가리키는 멤버 using 선언은 C++20 이전의 C++ 표준과 호환되지 않습니다"
# 'memory order argument to atomic operation is invalid'
H10A1EB7E5921: '원자 연산의 메모리 주문 인수가 유효하지 않습니다'
# "memory order clause '%0' is specified here"
HEB7229373BDB: "메모리 순서 절 '%0'이 여기에서 지정되었습니다"
# 'merge multiple fdata into a single file'
H166CAC1CDA7E: '여러 fdata를 단일 파일로 병합'
# 'merge settag instruction in function epilog'
H69388C044859: '함수 에필로그에서 settag 명령어 합치기'
# 'merge stack variable initializers with tagging when possible'
H3914158550BF: '가능한 경우 태깅을 통한 스택 변수 초기화자 통합'
# 'merge-fdata options'
H84D7D36EDADD: 'fdata 병합 옵션'
# 'messages delimited by --- lines, with # comment support'
H35F2755289E5: '---\n메시지들은 --- 라인으로 구분되며 # 주석을 지원합니다\n---'
# 'messages delimited by `// -----` lines, with // comment support'
HFC97CA453D6E: '메시지 `// -----` 줄로 구분, // 주석 지원'
# 'messaging a Class with a method that is possibly direct'
H3E9374E93BAC: '직접 메서드가 있을 수 있는 클래스에 메시지를 전송합니다'
# 'messaging super with a direct method'
H76B5A067ADF0: '슈퍼에 직접 메서드로 메시지를 전송했습니다.'
# 'messaging unqualified id'
H25CF081972C3: '비정규화된 식별자 메시징'
# 'messaging unqualified id with a method that is possibly direct'
H52C4ECCB3445: '비限定된 id에 직접 호출될 수 있는 메서드와의 메시징'
# 'method %0 declared here'
H0A29C282008D: '메서드 %0 여기에서 선언되었습니다'
# 'method %0 in protocol %1 not implemented'
H3B6F9A4CA03E: '프로토콜 %1의 메서드 %0가 구현되지 않았습니다'
# 'method %0 is used for the forward class'
H9C1FB20B5554: '메서드 %0는 전방 클래스에 사용됩니다'
# 'method %0 that returns %1 declared here'
H81FA72B87C9D: '여기서 선언된 %0 메소드는 %1을 반환합니다'
# 'method definition for %0 not found'
H2A6463515852: '메서드 정의가 %0에 없습니다'
# 'method for accessing %select{dictionary|array}1 element must have Objective-C object return type instead of %0'
H2A6E5DD7828B: '%select{사전|array}1 요소에 접근하는 방법은 %0 대신 Objective-C 객체 반환 형식을 사용해야 합니다'
# "method has no return type specified; defaults to 'id'"
HD11D99B1C083: "메서드에 반환 타입이 지정되지 않았습니다; 'id'로 기본값이 지정됩니다"
# 'method implementation does not match its declaration'
H2D5D386F5AFB: '메소드 구현이 선언과 일치하지 않습니다'
# 'method index parameter type %0 is not integral type'
H630B60C086B7: '메서드 인덱스 매개변수 형식 %0는 정수 형식이 아닙니다'
# 'method is expected to return an instance of its class type %diff{$, but is declared to return $|, but is declared to return different type}0,1'
H4EBF90DD6088: '메소드는 클래스 타입의 인스턴스를 반환해야 합니다 %diff{, 하지만 $로 선언되어 있습니다|, 하지만 다른 타입으로 선언되어 있습니다}0,1'
# 'method key parameter type %0 is not object type'
H93D8788321DF: 'method key parameter type %0는 객체 유형이 아닙니다'
# 'method marked as designated initializer of the class here'
H6D873EC57BBB: '이 클래스의 지정된 초기화자로 여기서 표시된 메서드입니다'
# "method name referenced in property setter attribute must end with ':'"
H48FC25BCA089: "프로퍼티 세터 속성에 참조된 메서드 이름은 ':'로 끝나야 합니다"
# 'method object parameter type %0 is not object type'
H7C5EC09F4D4E: '메서드 객체 매개변수 형식 %0는 객체 형식이 아닙니다'
# 'method override for the designated initializer of the superclass %objcinstance0 not found'
H353D09FC8C8A: '슈퍼 클래스의 지정 초기화자 %objcinstance0에 대한 메소드 재정의를 찾을 수 없습니다'
# 'method parameter of type %0 with no explicit ownership'
H012CAADA6E5A: '명시적인 소유권이 없는 유형 %0의 메서드 매개변수'
# 'method parameter type %diff{$ does not match super class method parameter type $|does not match super class method parameter type}0,1'
H52F29D4B5323: '메서드 매개변수 유형 %diff{$는 상위 클래스 메서드 매개변수 유형 $와 일치하지 않습니다|상위 클래스 메서드 매개변수 유형과 일치하지 않습니다}0,1'
# 'method possibly missing a [super %0] call'
HF2DE0E720AA4: '메서드가 [super %0] 호출을 누락했을 수 있습니다'
# 'method returns unexpected type %0 (should be an object type)'
HDA228B7E04A3: '메서드가 예상하지 않은 타입 %0을 반환합니다(객체 타입이어야 합니다)'
# "method type specifier must start with '-' or '+'"
H60683402DB43: "메서드 형식 지정자는 '-' 또는 '+'로 시작해야 합니다"
# "method was declared as %select{an 'alloc'|a 'copy'|an 'init'|a 'new'}0 method, but its implementation doesn't match because %select{its result type is not an object pointer|its result type is unrelated to its receiver type}1"
H0332DF98668A: '메서드는 %select{alloc|copy|init|new}0 메서드로 선언되었지만, 구현이 맞지 않아서 %select{결과 타입이 객체 포인터가 아닙니다|결과 타입이 수신자 타입과 관련이 없습니다}1'
# 'methods that %select{override superclass methods|implement protocol requirements}0 cannot be direct'
H10E1F7CDD559: '%select{상위 클래스 메서드를 재정의하는|프로토콜 요구사항을 구현하는}0 메서드는 직접 메서드로 선언할 수 없습니다'
# "micromips is not supported for target CPU '%0'"
H17AAF1CF7567: "micromips는 대상 CPU '%0'에서 지원되지 않습니다."
# 'minimal size of the basic block that should be aligned'
H9310AFA3C7C1: '정렬되어야 하는 기본 블록의 최소 크기'
# 'minimum address considered valid for heatmap (default 0)'
HB0C898B37318: '히트맵에서 유효한 최소 주소 (기본값 0)'
# 'minimum condition bias (pct) to perform a CMOV conversion, -1 to not account bias'
HF9B056CCAAE3: 'CMOV 변환을 수행하기 위한 최소 조건 편향(백분율), -1을 지정하면 편향을 고려하지 않음'
# 'minimum function durations'
H9FA9BE32CDEF: '최소 함수 지속 시간'
# 'minimum misprediction rate (pct) to perform a CMOV conversion, -1 to not account misprediction rate'
H0816E5149451: 'CMOV 변환을 수행하기 위한 최소 예측 실패율 (pct), -1을 지정하면 예측 실패율을 고려하지 않음'
# 'minimum number of points in an analysis cluster (dbscan only)'
H24AF23851D8A: '분석 클러스터 내의 최소 점 개수 (DBSCAN 전용)'
# 'minimum offset needed between block and successor to allow duplication'
H75F42A78BFD9: '복제를 허용하기 위해 블록과 후속자 사이에 필요한 최소 오프셋'
# 'minimum vscale must be an unsigned integer greater than 0'
H97D216C9F9DC: '최소 vscale는 0보다 큰 부호 없는 정수여야 합니다'
# 'minus(-) operator for reductions is deprecated; use + or user defined reduction instead'
HB503599C3686: '감소를 위한 마이너스(-) 연산자는 더 이상 사용되지 않습니다; 대신 + 연산자 또는 사용자 정의 감소를 사용하세요'
# 'misaligned atomic operation may incur significant performance penalty; the expected alignment (%0 bytes) exceeds the actual alignment (%1 bytes)'
HB642C05FEFCE: '정렬되지 않은 원자 연산은 성능 저하를 초래할 수 있습니다; 예상된 정렬 값(%0 바이트)이 실제 정렬 값(%1 바이트)보다 큽니다'
# "misleading indentation; statement is not part of the previous '%select{if|else|for|while}0'"
H2D720E07A9B5: " الخلط을 일으키는 들여쓰기; 문은 이전 '%select{if|else|for|while}0'의 부분이 아닙니다"
# "mismatch between architecture and environment in target triple '%0'; did you mean '%1'?"
HFB1C45E0F3D8: "타겟 트리플 '%0'의 아키텍처와 환경이 일치하지 않습니다; 의도한 값은 '%1'이었는지요?"
# 'mismatch in number of block parameters and local size arguments passed'
H297CC009BE30: '블록 매개변수의 수와 전달된 로컬 크기 인수의 수가 일치하지 않음'
# 'misplaced %0; expected %0 here'
H6EEF8ABBCBBD: '잘못된 위치의 %0; 여기서 %0이 필요합니다'
# 'misplaced attributes; expected attributes here'
H71DF23AD8094: '잘못된 속성 위치; 속성이 필요한 위치에 없습니다'
# 'misprediction threshold for skipping ICP on an indirect call'
H2799B1202BB8: '간접 호출에서 ICP 건너뛰기의 예측 오류 임계값'
# 'missing %1 after %0'
H71A0939C10D8: '%0 이후에 %1이 누락되었습니다.'
# "missing '(' after '#pragma %0' - ignoring"
H9BCF4D2D832C: "'#pragma %0' 이후에 '('가 누락되었습니다. 무시합니다"
# "missing '(' following __VA_OPT__"
HFEF64C94E397: "__VA_OPT__ 뒤에 '('가 누락되었습니다"
# "missing ')' after '#pragma %0' - ignoring"
HD628B31A25D9: "'#pragma %0' 이후에 누락된 ')' - 무시합니다"
# "missing ')' in macro parameter list"
HBA1269832ABB: "매크로 매개변수 목록에서 누락된 ')'"
# "missing '*' in type bound %0 for type parameter %1"
H0FC1C4510683: "형식 매개변수 %1의 형식 경계 %0에서 '*'가 누락되었습니다."
# "missing ',' after %0"
H36D833E1BE2F: '’,’이 %0 이후에 누락되었습니다.'
# "missing ',' between base or member initializers"
HC0E2DA10BD59: "기반 클래스 또는 멤버 초기화자 사이에 ','가 누락되었습니다"
# "missing ',' between enumerators"
H3BCFAD409136: '열거자 사이에 쉼표(,)가 누락되었습니다.'
# "missing ':' after %0 - ignoring"
H6D49C0F56471: "':''가 %0 이후에 누락됨 - 무시합니다"
# "missing ':' after %0 modifier"
H1C42316D6361: "수정자 %0 뒤에 ':'가 누락되었습니다."
# "missing ':' in %0"
HB39748BAFE7C: "':'가 누락되었습니다. %0 내에서"
# "missing ':' or ')' after %0 - ignoring"
HA24B4C500D05: "':', ')'가 누락됨: %0 이후에 무시함"
# "missing '@end'"
H91CC5F3C7087: '‘@end’가 누락되었습니다.'
# "missing '[' at start of message send expression"
H352486DC1A63: "메시지 전송 표현식의 시작 부분에 '['가 누락되었습니다."
# "missing 'export module' declaration in module interface unit"
H43BE56C41167: "모듈 인터페이스 유닛에서 'export module' 선언이 누락되었습니다"
# "missing 'export' specifier in module declaration while building module interface"
H73E9D7F0EE4B: "모듈 인터페이스를 빌드할 때 모듈 선언에 'export' 지정자가 누락되었습니다."
# "missing 'get=' or 'put='"
H5BBBF3CA84C4: '‘get=’ 또는 ‘put=’이 없습니다.'
# "missing 'module' declaration at end of global module fragment introduced here"
HECF75AD1494B: "여기서 시작된 글로벌 모듈 조각의 끝에서 'module' 선언이 누락되었습니다"
# "missing 'template' keyword prior to dependent template name %0"
H6110BBE085CA: "종속 템플릿 이름 %0 앞에 'template' 키워드가 누락되었습니다."
# "missing 'typename' prior to dependent type name %0"
H1584997CE5DB: "의존적 타입 이름 %0 앞에 'typename'이 누락되었습니다"
# "missing 'typename' prior to dependent type name %0 is a C++20 extension"
HA061A76A5828: "종속형 이름 %0 앞에 'typename'이(가) 누락되었습니다. 이는 C++20 확장 기능입니다"
# "missing 'typename' prior to dependent type name %0 is incompatible with C++ standards before C++20"
HCDF9EEE90AEA: "종속형 이름 %0 앞에 'typename'이(가) 누락되었습니다. 이는 C++20 이전의 C++ 표준과 호환되지 않습니다"
# "missing 'typename' prior to dependent type template name %0"
HB65342C255DD: "종속 형식 템플릿 이름 %0 앞에 'typename'이 누락되었습니다"
# "missing '}' at end of definition of %q0"
HAF73F9C8E8E7: "%q0의 정의 끝에서 '}'가 누락되었습니다"
# 'missing actual type specifier for pipe'
H369BCA42F29A: '파이프에 대한 실제 타입 지정자가 누락되었습니다.'
# "missing argument to '#pragma %0'%select{|; expected %2}1"
H85D43DEA45AB: '#pragma %0에 인수가 부족했습니다%select{ |; %2가 필요합니다}1'
# "missing argument to '%0'"
H52AC6CD34BC9: "'%0'에 필요한 인수가 누락되었습니다"
# "missing argument to debug command '%0'"
H68E5FEB79890: "디버그 명령어 '%0'에 인수가 누락되었습니다."
# "missing argument; expected %select{an integer value|'enable'%select{|, 'full'}1%select{|, 'assume_safety'}2 or 'disable'}0"
H6DC6E5CF70F4: "결측된 인수; 다음 중 하나가 필요합니다: %select{정수 값|'enable'%select{|, 'full'}1%select{|, 'assume_safety'}2 또는 'disable'}0"
# 'missing context for method declaration'
HDB791FF5D00C: '메서드 선언을 위한 맥락이 누락되었습니다'
# 'missing context for property implementation declaration'
HB2B46E5EAE97: '프로퍼티 구현 선언을 위한 컨텍스트가 없습니다.'
# 'missing custom discrimination'
H8E91DD601C8B: '사용자 정의 판별자 누락'
# 'missing debug command'
HC4112B242494: '디버그 명령이 누락되었습니다.'
# 'missing default argument on parameter'
H8EC917CC5F93: '매개변수에 기본 인수가 없습니다'
# 'missing default argument on parameter %0'
H8F4C6F0521D4: '매개변수 %0에 기본 인수가 없습니다'
# 'missing field %0 initializer'
HBCFF05CA88FD: '필드 %0의 초기화자가 누락되었습니다'
# 'missing map type'
H4AA13FCA7666: '맵 타입 누락'
# 'missing map type modifier'
H60251948404E: '맵 형식 지정자가 누락되었습니다.'
# 'missing numthreads attribute for %0 shader entry'
HFADE160C1BC1: 'numthreads 속성이 %0 셰이더 엔트리에 없습니다'
# 'missing object format flag'
HD57D82290D05: '누락된 오브젝트 형식 플래그'
# "missing or invalid line number following '@' in expected %0"
H296CBDA95848: "예상된 %0 내에서 '@' 뒤에 라인 번호가 누락되거나 잘못되었습니다."
# 'missing parentheses around the size of parameter pack %0'
HA558CBB9F294: '매개변수 패킹 %0의 크기 주위에 괄호가 없습니다.'
# 'missing plugin argument for plugin %0 in %1'
H8600AE8C89F9: '플러그인 %0에 대한 인수가 %1에 없습니다.'
# 'missing plugin name in %0'
H4A2F8D6C22D3: '%0에 플러그인 이름이 누락되었습니다.'
# "missing reduction operator, expected '+', '*', 'max', 'min', '&', '|', '^', '&&', or '||', follwed by a ':'"
H9DF20C9098D2: "축소 연산자가 누락되었습니다. '+' '+' '*' 'max' 'min' '&' '|' '^' '&&' 또는 '||' 뒤에 ':'가 필요합니다."
# 'missing return type for function %0; did you mean the constructor name %1?'
H0096A8359309: '함수 %0에 반환 타입이 누락되었습니다. 생성자 이름 %1을 의미하시는 건가요?'
# "missing sanitizer ignorelist: '%0'"
HE7971DD1E969: "샌타이저 무시 목록 누락: '%0'"
# 'missing sentinel in %select{function call|method dispatch|block call}0'
H10D39CEB9167: '초과자 누락됨 %select{함수 호출|메서드 분배|블록 호출}0'
# 'missing state for %0'
HCF224168FF82: '%0의 상태가 누락되었습니다'
# "missing submodule '%0'"
H4FF2783EAA28: "서브모듈 '%0'이 누락되었습니다"
# 'missing symbol graph output directory, defaulting to working directory'
H1ACFD82E27C5: '심볼 그래프 출력 디렉토리가 지정되지 않아 작업 디렉토리를 기본값으로 사용합니다'
# 'missing terminating %select{\'|\'"\'}0 character'
HC91AE5B6C664: '종료하는 %select{\'|\'"\'}0 문자가 누락되었습니다'
# "missing terminating ')' character"
H110B9B84BD50: "종료하는 ')' 문자가 누락되었습니다."
# 'missing type bound %0 for type parameter %1 in %select{@interface|@class}2'
HCB937BA83DD0: '타입 매개변수 %1에 대한 %0의 타입 경계가 %select{@interface|@class}2에 누락되었습니다'
# "missing version number in '%0'"
H5280152B38E3: "'%0' 내 버전 번호가 누락되었습니다"
# 'mixed CUDA and HIP compilation is not supported'
HDE7D3706C5B5: '혼합된 CUDA와 HIP 컴파일은 지원되지 않습니다'
# "mixing 'target_clones' specifier mechanisms is permitted for GCC compatibility; use a comma separated sequence of string literals, or a string literal containing a comma-separated list of versions"
H65625B3622E8: "GCC 호환성을 위해 'target_clones' 지정자 메커니즘을 혼합하는 것이 허용됩니다; 쉼표로 구분된 문자열 리터럴 시퀀스를 사용하거나, 버전 목록이 쉼표로 구분된 문자열 리터럴을 사용하십시오"
# 'mixing declarations and code is a C99 extension'
H509E36ADC1D7: '선언과 코드를 혼합하는 것은 C99 확장 기능입니다'
# 'mixing declarations and code is incompatible with standards before C99'
HD580E194E35D: '선언과 코드를 혼합하는 것은 C99 이전 표준과 호환되지 않습니다'
# 'mixture of designated and non-designated initializers in the same initializer list is a C99 extension'
H29C32AE72D18: '동일한 초기화자 목록에서 지정 초기화와 비지정 초기화의 혼합은 C99 확장입니다'
# 'mlir-query options'
HE19598DC2C40: 'mlir-query 옵션'
# 'mlir-reduce options'
H3CAB90C0AD8E: 'mlir-reduce 옵션'
# 'mode %0 is not supported for enumeration types'
H9D1986A84BDA: '%0 모드는 열거형 타입에 대해 지원되지 않습니다'
# 'mode attribute only supported for integer and floating-point types'
H759A20BD1268: '모드 속성은 정수형 및 부동소수점 유형에만 지원됩니다'
# 'mode for simplify conditional tail calls'
H7E2CD8BDAB86: '조건부 꼬리 호출을 단순화하는 모드'
# 'moderate strategy'
H73892DAB539F: '중간 전략'
# 'modification of object of const-qualified type %0 is not allowed in a constant expression'
H403821CE466D: 'const-qualifier가 적용된 타입 %0의 객체를 상수 표현식에서 수정하는 것은 허용되지 않습니다.'
# "modifier '%0' cannot be used along with modifier '%1'"
HDE467CEB2037: "'%0' 수정자와 '%1' 수정자를 동시에 사용할 수 없습니다."
# 'modifying constructor parameter %0 that shadows a field of %1'
H1430708B59D6: '생성자 매개변수 %0를 %1의 필드를 가리면서 수정 중입니다'
# 'modularize.\n'
HA1E9FFD28E50: '모듈화.\n'
# "module %0 does not depend on a module exporting '%1'"
H85DEF90A3AE0: "모듈 %0는 '%1'을 내보내는 모듈에 의존하지 않습니다."
# "module %0 does not directly depend on a module exporting '%1', which is part of indirectly-used module %2"
H9D50309367F5: "모듈 %0는 직접적으로 '%1'을 내보내는 모듈에 의존하지 않습니다. 이는 간접적으로 사용되는 모듈 %2의 일부입니다"
# "module '%0' %select{in|imported by}4 precompiled file '%1' found in a different module map file (%2) than when the importing precompiled file was built (%3)"
H9B94DD93868B: "모듈 '%0'%select{에 포함됨|에 의해 가져옴}4된 사전 컴파일 파일 '%1'이(가) 다른 모듈 맵 파일(%2)에서 발견되었습니다. 이는 가져오는 사전 컴파일 파일이 빌드될 때의 모듈 맵 파일(%3)과 다릅니다."
# "module '%0' %select{is incompatible with|requires}1 feature '%2'"
H4440A0170E90: "모듈 '%0'은 %select{호환되지 않는|필요한}1 기능 '%2'입니다"
# "module '%0' %select{uses|does not use}1 additional module map '%2'%select{| not}1 used when the module was built"
HAC53C3FABCDA: "모듈 '%0'이 %select{사용합니다|사용하지 않습니다}1 추가 모듈 맵 '%2' %select{사용되었습니다|사용되지 않았습니다}1 빌드될 때"
# "module '%0' already re-exported as '%1'"
H6556B7A46703: "모듈 '%0'은 이미 '%1'로 재수출되었습니다"
# "module '%0' conflicts with already-imported module '%1': %2"
HED958876B86C: "모듈 '%0'은 이미 가져온 모듈 '%1'과 충돌합니다: %2"
# "module '%0' in precompiled file '%1' %select{(imported by precompiled file '%2') |}4is not defined in any loaded module map file; maybe you need to load '%3'?"
HDC91DE6A026C: "사전 컴파일 파일 '%1'의 모듈 '%0'%select{(사전 컴파일 파일 '%2'에 의해 가져옴) |}4이(가) 로드된 모듈 맵 파일에서 정의되지 않았습니다. '%3'을(를) 로드해야 할 수도 있습니다."
# "module '%0' is defined in both '%1' and '%2'"
H9937FAC6E395: "모듈 '%0'은 '%1'과 '%2'에서 모두 정의되었습니다"
# "module '%0' is needed but has not been provided, and implicit use of module files is disabled"
H8C7DAF453831: "모듈 '%0'이 필요하지만 제공되지 않았고, 모듈 파일의 암시적 사용이 비활성화되었습니다."
# "module '%0' not found"
H55DF0ED78DC5: "모듈 '%0'을 찾을 수 없습니다."
# "module '%0' was built in directory '%1' but now resides in directory '%2'"
H38AD29640B23: "모듈 '%0'은(는) '%1' 디렉토리에서 빌드되었지만, 현재 '%2' 디렉토리에 있습니다"
# "module compilation requires '-fmodules'"
H6A96D77D9F41: "모듈 컴파일에는 '-fmodules'가 필요합니다."
# 'module declaration can only appear at the top level'
HB03E6C215813: '모듈 선언은 최상위 레벨에서만 나타날 수 있습니다'
# 'module declaration must occur at the start of the translation unit'
HA7783A63FE0B: '모듈 선언은 번역 단위의 시작 부분에 있어야 합니다'
# 'module defined here'
HDB50FF2BF5A8: 'module 여기서 정의되었습니다'
# 'module file %0 cannot be loaded due to a configuration mismatch with the current compilation'
H469015AF9879: '모듈 파일 %0은 현재 컴파일과의 구성 불일치로 인해 로드할 수 없습니다'
# "module file '%0' is missing its top-level submodule"
HFA537775278A: "모듈 파일 '%0'의 최상위 하위 모듈이 누락되었습니다."
# "module file '%0' was validated as a system module and is now being imported as a non-system module; any difference in diagnostic options will be ignored"
H13B637DDA3AA: "모듈 파일 '%0'은 시스템 모듈로 검증되었으나 이제 비시스템 모듈로 임포트되고 있습니다; 진단 옵션의 차이는 무시됩니다"
# 'module file suffix override'
H69E50E2734CF: '모듈 파일 접미사 대체'
# "module header file '%0' not found"
HDA48886085ED: "모듈 헤더 파일 '%0'을(를) 찾을 수 없습니다."
# 'module imported here'
HA3A8055B303E: '이 곳에서 모듈이 임포트되었습니다'
# "module interface compilation requires '-std=c++20'"
HA34462B55274: "모듈 인터페이스 컴파일은 '-std=c++20'이 필요합니다"
# "module loaded from '%0'"
H07E2BBCF1C1E: "모듈이 '%0'에서 로드됨"
# "module map file '%0' not found"
HD693305F9871: "모듈 맵 파일 '%0'을 찾을 수 없습니다"
# "module name '%0' specified on command line does not match name of module"
H0F48D36629AC: "명령 줄에 지정된 모듈 이름 '%0'이 모듈 이름과 일치하지 않습니다"
# 'module output directory (default .)'
H445A6DEE34DF: '모듈 출력 디렉토리 (기본값 .)'
# 'module partition implementations cannot be exported'
HFE1B8CB7B1E9: '모듈 파티션 구현은 수출할 수 없습니다'
# 'module partition imports must be within a module purview'
H99C430D138F5: 'module partition imports는 모듈 범위 내에 있어야 합니다'
# 'module partitions are only supported for C++20 onwards'
HB98F31FF7B9A: '모듈 분할은 C++20부터만 지원됩니다'
# 'module search directory'
H3FAA97FDA5D1: '모듈 검색 디렉토리'
# 'module%select{| partition}0 imports cannot be in the %select{global|private}1 module fragment'
HE6F2588D0369: 'module%select{ | 파티션}0 임포트는 %select{global|private}1 모듈 프래그먼트에 있을 수 없습니다'
# "more '%%' conversions than data arguments"
H9766AC9D490A: "데이터 인수가 충분하지 않습니다. '%%' 변환이 더 많습니다."
# "more than one 'device_type' clause is specified"
H018E0AE39152: "한 개 이상의 'device_type' 절이 지정되었습니다"
# "more than one for-loop in a loop associated with OpenACC '%0' construct with a '%1' clause"
H30D49A113B6A: "OpenACC '%0' 구조에 '%1' 절과 연관된 루프 내에 for 루프가 하나 이상 있습니다."
# 'more than one framework/dynamic library found'
H611E8232270A: '프레임워크/동적 라이브러리가 하나 이상 발견되었습니다'
# "more than one input constraint matches the same output '%0'"
H4D494A49ED15: "하나 이상의 입력 제약 조건이 동일한 출력 '%0'과 일치합니다"
# 'move jump tables to a separate section'
HC21B261E02F6: 'jump tables를 별도 섹션으로 이동합니다'
# 'moving a local object in a return statement prevents copy elision'
H928AEBBA3589: '리턴 문에서 지역 객체를 이동시키면 복사 생략이 방지됩니다'
# 'moving a temporary object prevents copy elision'
H7FCDBDAE9C59: '임시 객체를 이동하면 복사 생략이 방지됩니다'
# 'ms_struct may not produce Microsoft-compatible layouts for classes with base classes or virtual functions'
H0D36DB1654BA: 'ms_struct는 기반 클래스나 가상 함수를 가진 클래스에 대해 Microsoft 호환 레이아웃을 생성할 수 없습니다'
# "ms_struct may not produce Microsoft-compatible layouts with fundamental data types with sizes that aren't a power of two"
H9013C05CB59B: 'ms_struct는 2의 거듭제곱이 아닌 크기를 가진 기본 데이터 유형과 함께 마이크로소프트 호환 레이아웃을 생성할 수 없습니다'
# 'mtriple'
H7584397F39BE: '타겟 트리플'
# 'multi-character character constant'
H8914BC0B6E30: '다중 문자를 포함하는 문자 상수'
# 'multi-dimensional arrays of WebAssembly references are not allowed'
HDC4921C402A6: 'WebAssembly 참조의 다차원 배열은 허용되지 않습니다'
# 'multi-line // comment'
HC0A7D2EE8599: '다중 라인 // 주석'
# 'multilib configuration error: %0'
H51BCFF1832A0: 'multilib 구성 오류: %0'
# "multiple %0 architectures are detected: %1; only the first one is used for '%2'"
HF49114F051BF: "여러 개의 %0 아키텍처가 검출되었습니다: %1; 첫 번째 항목만 '%2'에 사용됩니다"
# "multiple %select{'step size'|'linear modifier'}0 found in linear clause"
H6C58F45C9F56: "선형 절에서 %select{'스텝 크기'|'선형 수정자'}0가 여러 개 발견되었습니다"
# "multiple 'callback' attributes specified"
H9EF4CEF4A9C0: "복수의 'callback' 속성이 지정되었습니다"
# "multiple 'cpu_specific' functions cannot specify the same CPU: %0"
H3B8B7713681E: "여러 개의 'cpu_specific' 함수가 동일한 CPU를 지정할 수 없습니다: %0"
# "multiple 'lifetime_capture' attributes specified"
H42096CECC49E: "다중 'lifetime_capture' 속성이 지정되었습니다"
# "multiple 'routine' directives with 'bind' clauses are not permitted to refer to the same function"
HDA1D710FAA21: "중복된 'routine' 지시문에 'bind' 절은 같은 함수를 참조할 수 없습니다"
# 'multiple access qualifiers'
HA0304D566382: '중복된 접근 지정자'
# 'multiple address spaces specified for type'
H4075C38BB93B: '형식에 대해 중복된 주소 공간이 지정되었습니다'
# 'multiple array elements associated with the same variable are not allowed in map clauses of the same construct'
H289BE95E22C4: '동일한 구조의 map 절 내에서 동일한 변수와 연관된 여러 개의 배열 요소는 허용되지 않습니다'
# 'multiple conversions from expression type %0 to an integral type'
H80B8D963ECA1: '표현식 유형 %0에서 정수 유형으로의 다중 변환'
# 'multiple conversions from switch condition type %0 to an integral or enumeration type'
H23301D5B9A53: 'switch 조건 타입 %0에서 정수형 또는 열거형 타입으로의 변환이 여러 번 발생했습니다'
# 'multiple declarations of method %0 found and ignored'
HA50D97FB9EC5: '메소드 %0의 중복 선언이 발견되어 무시되었습니다'
# 'multiple default labels in one switch'
H1F979F2765D2: 'switch 문에 중복된 기본 레이블이 있습니다'
# 'multiple definitions are found for the same key in index '
HBED55B0B868B: '인덱스 내 동일한 키에 대한 중복 정의가 발견되었습니다.'
# 'multiple ellipses in pack capture'
H2EAABC9D1825: '팩 포획에 여러 개의 Ellipsis가 있습니다'
# 'multiple garbage collection attributes specified for type'
H8DF299790474: '타입에 대한 가비지 컬렉션 속성이 중복 지정되었습니다.'
# 'multiple identical address spaces specified for type'
H2A39AD934787: '형식에 동일한 주소 공간이 여러 번 지정되었습니다'
# 'multiple initializations given for base %0'
H6C502C93AC06: '기반 %0에 대한 중복 초기화가 지정되었습니다'
# 'multiple initializations given for non-static member %0'
HF2A12907FBDA: '비정적 멤버 %0에 여러 초기화가 주어졌습니다'
# "multiple inputs are not valid for header units (first extra '%0')"
H85058EEFACAE: "헤더 유닛에는 다중 입력이 유효하지 않습니다 (첫 번째 추가 '%0')"
# 'multiple methods named %0 found'
H170992E437FC: '이름이 %0인 메서드가 여러 개 발견되었습니다'
# 'multiple methods named %0 found with mismatched result, parameter type or attributes'
HB7ACC94E443E: '%0 이름의 메서드가 여러 개 발견되었지만 결과, 매개변수 타입 또는 속성이 일치하지 않습니다'
# 'multiple overloads of %0 instantiate to the same signature %1'
H3B92DD0A02C5: '%0의 여러 오버로드가 동일한 시그니처 %1로 인스턴스화됩니다'
# 'multiple packs in structured binding declaration'
HFE5E55E2957C: '구조화된 바인딩 선언에 여러 팩이 있습니다'
# 'multiple return statements in constexpr function is a C++14 extension'
H4582B1A35055: 'constexpr 함수 내에서 여러 개의 return 문은 C++14 확장 기능입니다.'
# 'multiple return statements in constexpr function is incompatible with C++ standards before C++14'
H4061EC95BBA4: 'constexpr 함수 내의 다중 return 문은 C++14 이전의 C++ 표준과 호환되지 않습니다'
# "multiple suitable %0 functions for %1; no 'operator delete' function will be invoked if initialization throws an exception"
HB304821CF54E: "적합한 %0 함수가 %1에 대해 여러 개 존재합니다; 초기화 중 예외가 발생할 경우 'operator delete' 함수가 호출되지 않습니다"
# 'multiple suitable %0 functions in %1'
H04588097A2D5: '적절한 여러 %0 함수들이 %1에 있습니다'
# 'multiple unsequenced modifications to %0'
HBE9DFDF729B3: '복수의 순서가 정의되지 않은 %0에 대한 수정'
# 'multiple vtable pointer authentication policies on %0'
H64E76C32EB13: '복수의 vtable 포인터 인증 정책이 %0에 지정되었습니다.'
# 'multiversioned function declaration has a different %select{calling convention|return type|constexpr specification|inline specification|linkage|language linkage}0'
H037AEBCE675B: '다중 버전 함수 선언이 다른 %select{호출 규약|리턴 타입|constexpr 지정자|인라인 지정자|링크지|언어 링크지}0을 가지고 있습니다.'
# 'multiversioned function must have a prototype'
HC2FE50BE244F: '다중 버전 함수는 프로토타입을 가져야 합니다'
# 'multiversioned function redeclarations require identical target attributes'
H21088B0A235D: '다중 버전화된 function 재선언은 동일한 target attributes가 필요합니다'
# 'multiversioning attributes cannot be combined'
HB5E9464B0FCA: '멀티버전 속성은 결합될 수 없습니다'
# "must be declared with 'noexcept'"
H987DB13AD301: "'noexcept'로 선언되어야 합니다"
# 'must be specified at least once!'
H226887FCC25B: '최소 한 번 이상 지정되어야 합니다!'
# 'must explicitly describe intended ownership of an object array parameter'
H94C16C029EFB: '객체 배열 매개변수의 의도된 소유권을 명시적으로 기술해야 합니다'
# 'must explicitly qualify name of member function when taking its address'
H10EC7DC2756E: '멤버 함수의 이름을 주소를 취할 때는 명시적으로 범위를 지정해야 합니다'
# "must handle potential future platforms with '*'"
H52CBF98EE88A: "미래 플랫폼에서 '*'를 처리해야 합니다"
# 'must name member using the type of the current context %0'
H0A063C055ADE: '현재 컨텍스트의 타입을 사용하여 %0 멤버를 지정해야 합니다'
# "must pass in an explicit %0 gpu architecture to '%1'"
H748BF240D8AC: "명시적인 %0 GPU 아키텍처를 '%1'에 전달해야 합니다"
# "must provide a symbol graph output directory using '--symbol-graph-dir=<directory>'"
H7FEC01DD8141: "'--symbol-graph-dir=<directory>' 옵션을 사용하여 기호 그래프 출력 디렉토리를 지정해야 합니다"
# 'must qualify identifier to find this declaration in dependent base class'
HB8E730405435: '의존적 기반 클래스의 선언을 찾으려면 식별자를 명시적으로 지정해야 합니다.'
# "must specify '-fmodule-name=%0' to enter %select{|submodule of }1this module%select{ (current module is %3)|}2"
HF0DE733FAF70: "옵션 '-fmodule-name=%0'을 지정해야 %select{|의 서브모듈 }1이 모듈%select{ (현재 모듈은 %3)|}2에 진입할 수 있습니다."
# 'must specify system root with -isysroot when building a relocatable PCH file'
H530DD8BE4BB8: '이동 가능한 PCH 파일을 빌드할 때는 -isysroot로 시스템 루트를 지정해야 합니다'
# "must use '%1' tag to refer to type %0%select{| in this scope}2"
H25B19F90B2A8: "유형 %0을 참조하려면 '%1' 태그를 사용해야 합니다%select{| 현재 스코프에서}2"
# 'my-tool options'
H6F25BE7781B0: '이 도구 옵션'
# 'n'
HD1854CAE891E: 'n'
# 'name defined in alias declaration must be an identifier'
HF20E175DA10B: '_ALIAS 선언에서 정의된 이름은 아이덴티파이어여야 합니다'
# 'name defined in concept definition must be an identifier'
H9F376A6B25D8: '컨셉 정의에서 정의된 이름은 식별자여야 합니다.'
# 'named bit-field %0 has zero width'
HB27FCD740169: '이름이 있는 비트 필드 %0의 너비가 0입니다'
# 'named variadic macros are a GNU extension'
H4A2738C3ADE2: '이름이 있는 가변 매크로는 GNU 확장 기능입니다'
# 'namespace %0 defined here'
H6C2973533802: 'namespace %0는 여기서 정의되었습니다'
# 'namespace alias cannot be inline'
H69290D9B2469: '네임스페이스 별칭은 inline일 수 없습니다'
# 'namespace alias must be a single identifier'
HA11E2A62D886: '네임스페이스 별칭은 단일 식별자여야 합니다'
# "namespace can only apply to 'push' or 'pop' directives"
H6F30E709453F: "namespace는 'push' 또는 'pop' 지시문에만 적용될 수 있습니다"
# 'namespaces can only be defined in global or namespace scope'
HDB4E6C24AE7F: '네임스페이스는 전역 범위 또는 네임스페이스 범위에서만 정의할 수 있습니다'
# "negated attribute subject matcher sub-rule '%0' contradicts sub-rule '%1'"
H92B926B255DE: "부정된 속성 대상 매처 하위 규칙 '%0'은 하위 규칙 '%1'과 모순됩니다"
# 'negative shift count %0'
HC6E4102E7BA3: '음수 이동 카운트 %0'
# "nested OpenMP context selector contains duplicated trait '%0' in selector '%1' and set '%2' with different score"
HC583359DCCE0: "중첩된 OpenMP 컨텍스트 선택기가 선택기 '%1'과 세트 '%2'에서 다른 점수를 가진 중복된 속성 '%0'을 포함했습니다"
# 'nested designators are a C99 extension'
H97E72072881F: '중첩된 지정자는 C99 확장입니다.'
# 'nested name specifier %0 for declaration does not refer into a class, class template or class template partial specialization'
H326DE285E8C5: '선언에 대한 중첩된 이름 지정자 %0는 클래스, 클래스 템플릿 또는 클래스 템플릿 부분 특화 내로 가리키지 않습니다'
# 'nested name specifier for a declaration cannot depend on a template parameter'
H87A0C3C18BC3: '선언에 대한 중첩된 이름 지정자는 템플릿 매개변수에 의존할 수 없습니다'
# "nested namespace definition cannot be 'inline'"
HB262A63F161A: "중첩 네임스페이스 정의는 'inline'일 수 없습니다."
# 'nested namespace definition is a C++17 extension; define each namespace separately'
HEFB4B9AD8E01: '중첩 네임스페이스 정의는 C++17 확장 기능입니다; 각 네임스페이스를 따로 정의하세요'
# 'nested namespace definition is incompatible with C++ standards before C++17'
H0E35039F1D67: '중첩 네임스페이스 정의는 C++17 이전 표준과 호환되지 않습니다'
# 'nested parentheses not permitted in %0'
H34953581058C: '중첩된 괄호는 %0에서 허용되지 않습니다.'
# 'nested redefinition of %0'
H0AC10F45C385: '중첩된 %0의 재정의'
# 'nested teams construct here'
HF6BEE2475F61: '여기에서 중첩된 teams 구조'
# 'nested user conditions in OpenMP context selector not supported (yet)'
H4C0B107BB3D4: 'OpenMP 컨텍스트 선택기 내에서 중첩된 사용자 조건은 지원되지 않습니다(아직)'
# 'never apply unchecked-ld-st'
HBB179F0E1AB0: '미체크된 ld-st를 절대로 적용하지 마세요'
# 'never print'
H669835729B5F: '출력하지 않음'
# 'never replace exit value'
H0750F0A2D157: '종료 값을 절대 대체하지 마십시오'
# 'new expression for type %0 contains multiple constructor arguments'
H0D34CDEC5737: '타입 %0의 new 표현식에 생성자 인수가 여러 개 포함되어 있습니다.'
# 'new expression for type %0 has incompatible constructor argument of type %1'
H8E7FF8B53FFB: '타입 %0에 대한 new 표현식은 타입 %1의 호환되지 않는 생성자 인자를 가집니다'
# 'new expression for type %0 requires a constructor argument'
H55FA18FEEE0E: '타입 %0에 대한 new 표현식은 생성자 인수가 필요합니다'
# 'next %select{instance variable declaration|synthesized instance variable}0 is here'
H6502100189C0: '다음 %select{인스턴스 변수 선언|합성된 인스턴스 변수}0이 여기 있습니다'
# 'next field declaration is here'
H589A37214DA3: '다음 필드 선언이 여기 있습니다'
# 'no %select{getter|setter}0 defined for property %1'
HDA010EA6C052: '프로퍼티 %1에 대한 %select{getter|setter}0가 정의되지 않았습니다.'
# 'no %select{struct|interface|union|class|enum}0 named %1 in %2'
HCA856DA687CE: '%select{구조체|인터페이스|유니온|클래스|열거형}0 이름 %1는 %2 내에 존재하지 않습니다'
# "no 'assign', 'retain', or 'copy' attribute is specified - 'assign' is assumed"
H5D9A45CF4470: '‘assign’, ‘retain’ 또는 ‘copy’ 속성이 지정되지 않았습니다 - ‘assign’이 기본으로 사용됩니다'
# 'no @interface declaration found in class messaging of %0'
H39108401F4F8: '%0 클래스의 메시징 중 @interface 선언을 찾을 수 없습니다'
# "no MCU device specified, but '-mhwmult' is set to 'auto', assuming no hardware multiply; use '-mmcu' to specify an MSP430 device, or '-mhwmult' to set the hardware multiply type explicitly"
HF3E9B95BB7DD: "MCU 장치가 지정되지 않았지만, '-mhwmult'이 'auto'로 설정되었습니다. 하드웨어 곱셈이 없음을 가정합니다; '-mmcu'를 사용하여 MSP430 장치를 지정하거나, '-mhwmult'를 사용하여 하드웨어 곱셈 유형을 명시적으로 설정할 수 있습니다"
# 'no PowerPC native vector element order.'
H49C9870074B0: 'PowerPC 네이티브 벡터 요소 순서가 없습니다.'
# "no analyzer checkers or packages are associated with '%0'"
H8B728EEF35B9: "분석기 체커나 패키지가 '%0'와 연관되어 있지 않습니다."
# 'no avr-libc installation can be found on the system, cannot link standard libraries'
H5206EA6489A5: '시스템에서 avr-libc 설치를 찾을 수 없습니다, 표준 라이브러리를 링크할 수 없습니다'
# 'no candidate function template was found for dependent %select{member|friend}0 function template specialization'
HC620314BA8FA: '의존성 %select{멤버|프렌드}0 함수 템플릿 특수화에 대한 후보 함수 템플릿이 발견되지 않았습니다'
# "no case matching constant switch condition '%0'"
HBFE1788B232F: "일치하는 case가 없습니다: 상수 switch 조건 '%0'"
# "no closing ']' for '%%[' in scanf format string"
H5E8D81CB9C26: "scanf 포맷 문자열에서 '%%['에 대한 닫는 ']'가 없습니다"
# 'no corresponding base class here'
HBBF529A4447F: '여기에는 해당하는 기본 클래스가 없습니다.'
# 'no corresponding enumerator here'
HCF6777617E14: '여기에는 대응하는 열거자가 없습니다'
# 'no corresponding field here'
H8BC5689EEC5A: '해당하는 필드가 없습니다.'
# 'no corresponding friend here'
H0544B78403CC: '여기에는 해당하는 friend가 없습니다.'
# 'no corresponding superclass here'
HE11938993661: '여기에는 해당하는 슈퍼 클래스가 없습니다'
# "no declaration found for exported symbol '%0' in dynamic library"
H247D438751B2: "동적 라이브러리에서 수출된 심볼 '%0'의 선언이 발견되지 않았습니다"
# "no declaration was found for exported symbol '%0' in dynamic library"
H01E907352618: "동적 라이브러리에서 수출된 심볼 '%0'에 대한 선언을 찾을 수 없습니다."
# "no expected directives found: consider use of '%0-no-diagnostics'"
H60C61DB5DCD2: "예상된 디렉티브가 발견되지 않았습니다: '%0-no-diagnostics' 옵션을 사용하는 것을 고려해 보세요"
# 'no function template matches function template specialization %0'
H783C344DF4FC: '함수 템플릿 특수화 %0에 일치하는 함수 템플릿이 없습니다'
# 'no getter method %1 for %select{increment|decrement}0 of property'
H27A03BEFDE9D: '속성의 %select{increment|decrement}0에 대한 %1 접근자 메서드가 없습니다.'
# 'no getter method for read from property'
HC653B7766A2E: '프로퍼티에서 읽기 위해 게터 메소드가 없습니다'
# "no handler registered for module format '%0'"
H54F9399D659E: "모듈 형식 '%0'에 대한 등록된 핸들러가 없습니다."
# 'no input files'
HFFB86B2450DC: '입력 파일이 없습니다'
# 'no install name specified: add -install_name <path>'
H183DF472D6DF: '설치 이름이 지정되지 않았습니다: -install_name <path>를 추가하세요.'
# 'no known %select{instance|class}1 method for selector %0'
H41C44394DC27: '선택자 %0에 대한 알려진 %select{인스턴스|클래스}1 메서드가 없습니다'
# "no known method %select{%objcinstance1|%objcclass1}0; cast the message send to the method's return type"
HD141497E30B9: '알 수 없는 메서드 %select{%objcinstance1|%objcclass1}0; 메서드의 반환 형식으로 메시지 전송을 캐스팅하세요'
# "no library '%0' found in the default clang lib directory or in LIBRARY_PATH; use '--libomptarget-%1-bc-path' to specify %1 bitcode library"
H56082C491F7D: "기본 clang 라이브러리 디렉토리나 LIBRARY_PATH에서 라이브러리 '%0'를 찾을 수 없습니다; %1 비트코드 라이브러리를 지정하려면 '--libomptarget-%1-bc-path' 옵션을 사용하세요"
# 'no macro named %0'
HDBF2015FF73B: '이름이 %0인 매크로가 없습니다.'
# 'no matching %0 function for non-allocating placement new expression; include <new>'
H7020E0B0AF12: '할당하지 않는 placement new 표현식에 대한 일치하는 %0 함수가 없습니다; new 헤더를 포함하세요'
# "no matching '#pragma clang module begin' for this '#pragma clang module end'"
HCC39D351076F: "이 '#pragma clang module end'에 대한 일치하는 '#pragma clang module begin'이 없습니다"
# "no matching '#pragma clang module end' for this '#pragma clang module begin'"
H688037E203CF: "이 '#pragma clang module begin'에 대한 일치하는 '#pragma clang module end'가 없습니다"
# "no matching '#pragma clang module endbuild' for this '#pragma clang module build'"
H4D6A2C63F3F1: "이 '#pragma clang module build'에 대한 대응하는 '#pragma clang module endbuild'가 없습니다"
# 'no matching constructor for initialization of %0'
H60A16B350ED3: '초기화에 사용할 일치하는 생성자가 없습니다: %0'
# 'no matching conversion for %select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2'
HB6FD5E96FCBB: '%select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|함수 스타일 cast|}0에서 %1을(를) %2로 변환할 수 없습니다'
# 'no matching function for call to %0'
HF7D6FEC7B803: '함수 %0에 대한 매칭되는 함수가 없습니다'
# 'no matching function for call to object of type %0'
H4AB0B7C8D656: '호출된 객체의 형 %0에 대한 매칭되는 함수가 없습니다.'
# "no matching literal operator for call to %0%select{| with argument of type %2| with arguments of types %2 and %3}1%select{| or 'const char *'}4%select{|, and no matching literal operator template}5"
H1F7F02224823: "호출에 맞는 리터럴 오퍼레이터가 없습니다: %0%select{| 인수 유형 %2의| 인수 유형 %2와 %3의}1%select{| 또는 'const char *'}4%select{|, 일치하는 리터럴 오퍼레이터 템플릿도 없습니다}5"
# 'no matching member function for call to %0'
HACEA313A920D: '호출 %0에 대해 일치하는 멤버 함수가 없습니다'
# "no matching target found for target variant '%0'"
H2CC48DEFF159: "타겟 변형 '%0'에 대한 일치하는 타겟이 발견되지 않았습니다"
# 'no member %0 in %1; it has not yet been instantiated'
H6800794A683C: '%1에 %0 멤버가 없습니다; 아직 인스턴스화되지 않았습니다'
# 'no member named %0 in %1'
H85214E062B3A: '이름이 %0인 멤버가 %1에 없습니다'
# 'no member named %0 in %1; did you mean %select{|simply }2%3?'
H5B97925635DE: '%1의 멤버에 %0라는 이름이 없습니다; 의도한 이름은 %select{|단순히 }2%3인가요?'
# "no member named %0 in %1; did you mean to use '->' instead of '.'?"
HBE0974E3EE78: "%1에는 %0라는 멤버가 없습니다; '.' 대신 '->'를 사용해야 하는 게 아닐까요?"
# 'no method with selector %0 is implemented in this translation unit'
H0CDD4F98E18F: '선택자 %0를 가진 메서드가 이 번역 단위에 구현되지 않았습니다'
# 'no module map available for module %0'
HF688B8490C1B: '모듈 %0에 사용할 수 있는 모듈 맵이 없습니다.'
# 'no module name provided; specify one with -fmodule-name='
H99A7BF8D2824: '모듈 이름이 제공되지 않았습니다; 명령 줄 옵션 -fmodule-name으로 지정해 주세요'
# "no module named '%0' %select{found|in '%2'}1, parent module must be defined before the submodule"
H86A38EF918F2: "모듈 '%0' %select{발견됨|'%2'에 없음}1, 부모 모듈은 서브모듈보다 먼저 정의되어야 합니다"
# "no module named '%0' declared in module map file '%1'"
HABF2F4633281: "모듈 '%0'이(가) 모듈 맵 파일 '%1'에 선언되지 않았습니다."
# "no module named '%0' in '%1'"
H658500ACD8C1: "모듈 '%0'이 '%1'에 없습니다"
# "no module named '%0' visible from '%1'"
HA7094B5AEB21: "이름이 '%0'인 모듈이 '%1'에서 접근 가능하지 않습니다"
# "no more 'if' clause is allowed"
H8F7A1C6703AA: "더 이상 'if' 절이 허용되지 않습니다"
# "no more than one option '--config' is allowed"
H3089388E4475: "최대 한 개의 옵션 '--config'만 허용됩니다"
# 'no multilib found matching flags: %0'
HCDE4340CFBD3: '일치하는 플래그를 가진 multilib을 찾을 수 없습니다: %0'
# 'no namespace named %0 in %1; did you mean %select{|simply }2%3?'
HF6FEAE5E55D9: '%1 내에 이름이 %0인 네임스페이스가 없습니다; %select{|단순히 }2%3을(를) 의도하셨나요?'
# 'no namespace named %0; did you mean %1?'
H81CE4465B841: '이름이 %0인 네임스페이스가 없습니다; %1 의 의미였나요?'
# 'no newline at end of file'
HC3F31DC1712E: '파일의 끝에 개행문자가 없습니다'
# 'no output file specified'
HA94EBB9ACB5A: '출력 파일이 지정되지 않았습니다'
# 'no previous extern declaration for non-static variable %0'
H8B284B72F880: '비정적 변수 %0에 대한 이전 외부 선언이 없습니다'
# 'no previous prototype for function %0'
H03B77D9B5049: '함수 %0에 대한 이전 프로토타입이 없습니다'
# 'no profile data available for file "%0"'
H59152796471E: '파일 "%0"에 대한 프로파일 데이터가 없습니다.'
# 'no return statement in %select{constexpr|consteval}0 function'
H6CABFAB2482E: '%select{constexpr|consteval}0 함수에 반환 문이 없습니다'
# "no submodule named %0 in module '%1'"
H2B7BA310F788: "모듈 '%1'에 이름이 %0인 하위 모듈이 없습니다"
# "no submodule named %0 in module '%1'; did you mean '%2'?"
H7D6A5E92FB55: "모듈 '%1'에 이름이 %0인 하위 모듈이 없습니다; '%2'를 의미하셨는지요?"
# "no submodule named %0 in module '%1'; using top level '%2'"
H5C502E1660AA: "모듈 '%1' 내에서 %0이라는 하위 모듈을 찾을 수 없습니다; 상위 레벨 '%2'를 사용합니다"
# "no such %select{public|private|project}1 header file: '%0'"
H6EFAEBB81765: "해당하는 %select{공개|프라이빗|프로젝트}1 헤더 파일이 없습니다: '%0'"
# "no such excluded %select{public|private}0 header file: '%1'"
HED06FD077272: "제외된 %select{public|private}0 헤더 파일이 없습니다: '%1'"
# "no such file or directory: '%0'"
HE170FBCF53FC: "해당 파일이나 디렉토리가 없습니다: '%0'"
# "no such file or directory: '%0'; did you mean '%1'?"
HE112F2418E57: "해당 파일 또는 디렉토리 없음: '%0'; '%1'을(를) 의미하시는 건가요?"
# "no such include directory: '%0'"
H7E37FF613F8F: "해당하는 include 디렉토리가 없습니다: '%0'"
# "no such sysroot directory: '%0'"
H7EBC246FEEA8: "지정된 sysroot 디렉토리가 없습니다: '%0'"
# 'no suitable member %0 in %1'
H3750344F18EF: '적합한 %0 멤버가 %1 안에 없습니다'
# "no suitable precompiled header file found in directory '%0'"
HC9D05A0684EB: "적합한 미리 컴파일된 헤더 파일이 디렉토리 '%0'에서 발견되지 않았습니다"
# 'no target microcontroller specified, please pass -mmcu=<mcu name>'
H861E68DCEBF9: '목표 마이크로컨트롤러가 지정되지 않았습니다. -mmcu=<mcu 이름>을 전달해 주세요'
# 'no template named %0'
HFC0C70B06D89: '이름이 %0인 템플릿이 없습니다'
# 'no template named %0 in %1'
H16DB7E6BC24D: '이름이 %0인 템플릿이 %1 내에 없습니다'
# 'no template named %0 in %1; did you mean %select{|simply }2%3?'
HCDFE5581F7D6: '템플릿 %0이 %1에 없습니다; 의도한 이름은 %select{ |단순히 }2%3인가요?'
# 'no template named %0; did you mean %1?'
H32AFF6E21FDC: '이름이 %0인 템플릿이 없습니다; 의도하신 게 %1이었나요?'
# 'no type named %0 in %1'
H6E87E8CAFF42: '이름이 %0인 타입이 %1 안에서 없습니다'
# 'no type named %0 in %1; did you mean %select{|simply }2%3?'
H014C7B262D03: '%1 안에 %0 이름의 타입이 없습니다; %select{|단순히 }2%3를 의도하셨나요?'
# "no type named 'type' in %0; 'enable_if' cannot be used to disable this declaration"
H03B3775679FC: "%0에 이름이 'type'인 타입이 없습니다; 'enable_if'를 사용하여 이 선언을 비활성화할 수 없습니다"
# 'no type or protocol named %0'
HFF0D89AB2752: '이름이 %0인 타입 또는 프로토콜이 없습니다.'
# "no valid clauses specified in OpenACC 'declare' directive"
H136795D57206: "OpenACC 'declare' 디렉티브에 유효한 절이 지정되지 않았습니다"
# 'no variable template matches specialization; did you mean to use %0 as function template instead?'
H702E78FBEC31: '변수 템플릿의 특수화에 맞는 것이 없습니다; %0을 대신 함수 템플릿으로 사용하려는 의도였나요?'
# 'no variable template matches%select{| partial}0 specialization'
H0903C7695A91: '변수 템플릿과 일치하는%select{| 부분 }0 특수화가 없습니다'
# 'no viable candidate for explicit instantiation of %0'
HAEBC7520AFB0: '%0의 명시적 인스턴스화에 적합한 후보가 없습니다'
# 'no viable constructor %select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1'
HC9B75808C9E9: '사용할 수 있는 생성자가 없습니다: %select{변수 복사|매개변수 복사|템플릿 매개변수 초기화|객체 반환|표현식 결과 초기화|예외 객체 던짐|멤버 부분 객체 복사|배열 요소 복사|객체 할당|임시 객체 복사|기반 부분 객체 초기화|벡터 요소 초기화|값 캡처}0 타입 %1의'
# 'no viable constructor %select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1; C++98 requires a copy constructor when binding a reference to a temporary'
HBD2DEF3D3EA1: '사용 가능한 생성자가 없습니다 %select{변수 복사|매개변수 복사|템플릿 매개변수 초기화|객체 반환|문 표현식 결과 초기화|객체 던지기|멤버 서브오브젝트 복사|배열 요소 복사|객체 할당|임시 객체 복사|기반 서브오브젝트 초기화|벡터 요소 초기화|값 포착}0 유형 %1; C++98 표준은 임시 객체에 대한 참조를 바인딩할 때 복사 생성자를 요구합니다'
# 'no viable constructor or deduction guide for deduction of template arguments of %0'
HECA595B57B5C: '템플릿 인자 %0의 추론을 위한 사용 가능한 생성자나 추론 가이드가 없습니다'
# 'no viable conversion%diff{ from $ to incomplete type $|}0,1'
H0DDC152C267D: '사용 가능한 변환이 없습니다%diff{ 형 $를 불완전한 형식 $로|}0,1'
# 'no viable conversion%select{%diff{ from $ to $|}1,2|%diff{ from returned value of type $ to function return type $|}1,2}0'
H742AD0829398: '적합한 변환이 없습니다%select{%diff{ 에서 에 변환할 수 없습니다|}1,2|%diff{ 리턴 값의 타입 에서 함수 리턴 타입 으로 변환할 수 없습니다|}1,2}0'
# 'no viable destructor found for class %0'
HE8AA8B1D9E66: '클래스 %0에 대한 유효한 소멸자가 발견되지 않았습니다.'
# "no viable overloaded '%0'"
H85F4D23A3BAD: "사용 가능한 오버로드된 '%0'가 없습니다."
# 'no viable overloaded operator[] for type %0'
H2EF71DBEE631: '%0 유형에 대해 사용 가능한 오버로드된 operator[]가 없습니다.'
# 'no visible @interface for %0 declares the selector %1'
HF35FE2A8D9B7: '가시적인 @interface for %0에는 선택자 %1가 선언되어 있지 않습니다'
# 'noexcept expressions are incompatible with C++98'
H770DCD42AD88: 'noexcept 표현식은 C++98과 호환되지 않습니다'
# 'noexcept specifications are incompatible with C++98'
HCDFCAD5EB464: 'noexcept 지정은 C++98과 호환되지 않습니다'
# 'non-ASM statement in naked function is not supported'
H13FAFC759C77: 'ASM이 아닌 문을 голый 함수 내에서 사용하는 것은 지원되지 않습니다'
# 'non-class friend type %0 is a C++11 extension'
HD60A5C8C49AC: '클래스가 아닌 친구 형식 %0는 C++11 확장 기능입니다'
# 'non-class friend type %0 is incompatible with C++98'
H4D0DB388513A: '%0 클래스가 아닌 친구 타입은 C++98 표준과 호환되지 않습니다'
# 'non-const static data member must be initialized out of line'
HFA5187DD3DCB: 'const가 아닌 static 데이터 멤버는 클래스 외부에서 초기화해야 합니다'
# 'non-constant static local variable in inline function may be different in different files'
HDAC621E8867A: 'inline 함수 내의 상수로 선언되지 않은 static 지역 변수는 다른 파일에서 다른 값이 될 수 있습니다'
# 'non-constant-expression cannot be narrowed from type %0 to %1 in initializer list'
H48217DABAA7D: '상수 표현식이 아닌 값은 초기화자 목록에서 %0에서 %1로 좁혀지지 않습니다'
# 'non-constant-expression cannot be narrowed from type %0 to %1 in initializer list in C++11'
H996365ACA997: 'C++11의 초기화 목록에서 상수 표현식이 아닌 표현식이 타입 %0에서 %1로 좁아질 수 없습니다'
# 'non-consteval function %0 cannot override a consteval function'
H3BE45C7BF2C1: 'consteval이 아닌 함수 %0는 consteval 함수를 오버라이드할 수 없습니다'
# 'non-constexpr comparison function declared here'
H6CDFA8CCBBD8: '비 constexpr 비교 함수가 여기에서 선언되었습니다.'
# 'non-constexpr comparison function would be used to compare %select{|member %1|base class %1}0'
HFFB83E06B051: '%select{|멤버 %1|기반 클래스 %1}0을 비교할 때 constexpr 비교 함수가 사용되지 않을 것입니다'
# 'non-deducible template parameter %0'
HD419F387C770: '추론 불가능한 템플릿 매개변수 %0'
# 'non-default #pragma pack value changes the alignment of struct or union members in the included file'
H2C52662649BE: '기본값이 아닌 #pragma pack 값은 포함된 파일의 struct 또는 union 멤버 정렬을 변경합니다'
# "non-default visibility cannot be applied to 'dllimport' declaration"
H2A9EC7D43705: "비 기본 가시성은 'dllimport' 선언에 적용할 수 없습니다"
# 'non-defining declaration of enumeration with a fixed underlying type is only permitted as a standalone declaration%select{|; missing list of enumerators?}0'
H4D151B6B2BF9: '고정된 기본 형식을 가진 열거형의 정의하지 않는 선언은 독립된 선언으로만 허용됩니다%select{|; 열거자 목록이 누락되었나요?}0'
# 'non-deleted function %0 cannot override a deleted function'
H2F21A881D5B2: '삭제되지 않은 함수 %0는 삭제된 함수를 대체할 수 없습니다'
# 'non-extern declaration of %0 follows extern declaration'
H7E386503A2B6: 'extern이 아닌 %0의 선언이 extern 선언 뒤에 올 수 없습니다'
# 'non-friend class member %0 cannot have a qualified name'
H01BBFAF999D6: '비친구 클래스 멤버 %0는 완전 자격 이름을 가질 수 없습니다'
# 'non-inline external definitions are not permitted in C++ header units'
H0E67412E5EDC: '인라인되지 않은 외부 정의는 C++ 헤더 유닛 내에서 허용되지 않습니다'
# 'non-inline namespace cannot be reopened as inline'
H43CE8E47A824: '비인라인 namespace는 인라인으로 다시 열 수 없습니다'
# 'non-literal type %0 cannot be used in a constant expression'
HFCBBB3F7D771: '리터럴 형이 아닌 형 %0는 상수 표현식에서 사용할 수 없습니다'
# 'non-local lambda expression cannot have a capture-default'
H2B075ACEF012: '비지역 람다 표현식에는 포착 기본값을 가질 수 없습니다.'
# 'non-local variable with sizeless type %0'
H92600D86A0C5: '크기 없는 형식의 비로컬 변수 %0'
# 'non-namespace scope %0 cannot have a literal operator member'
H266845A5FE4C: '네임스페이스 외부 범위 %0는 리터럴 연산자 멤버를 가질 수 없습니다'
# 'non-object type %0 is not assignable'
H8FB33F67F675: '%0 타입은 객체 타입이 아니므로 할당할 수 없습니다'
# "non-pointer argument to '__builtin_assume_aligned' is not allowed"
HD960D71E3301: "포인터가 아닌 인수를 '__builtin_assume_aligned'에 전달할 수 없습니다"
# 'non-pointer operand type %0 incompatible with %select{NULL|nullptr}1'
H90B6AFB986DF: '포인터가 아닌 연산자 유형 %0은 %select{NULL|nullptr}1와 호환되지 않습니다.'
# "non-portable path to file '%0'; specified path differs in case from file name on disk"
H43FE55A52897: "비이식 가능한 파일 경로 '%0'; 지정된 경로의 대소문자가 디스크에 있는 파일 이름과 다릅니다"
# 'non-predefined allocator must have traits specified'
HFFB74BA64E52: '사전 정의되지 않은 allocator는 traits를 지정해야 합니다'
# 'non-static data member %0 cannot be declared as a template'
HEE38B2049618: '비정적 데이터 멤버 %0는 템플릿으로 선언할 수 없습니다'
# 'non-static data member cannot be constexpr%select{; did you intend to make it %select{const|static}0?|}1'
H19D13A6885F4: '비정적 데이터 멤버는 constexpr일 수 없습니다%select{; %select{const|정적}0으로 지정해야 할까요?|}'
# 'non-static data member defined out-of-line'
HC4D58BAF82DF: '비정적 데이터 멤버가 라인 외부에서 정의됨'
# 'non-static declaration of %0 follows static declaration'
H25169BF9CE09: '정적 선언 뒤에 오는 %0의 비정적 선언'
# 'non-static member %0 found in multiple base-class subobjects of type %1:%2'
H1D1EE8E2CCD9: '비정적 멤버 %0가 %1 유형의 여러 기반 클래스 서브오브젝트에서 발견되었습니다:%2'
# 'non-template declaration found by name lookup'
HF380F2D95EAA: '이름 검색에 의해 템플릿이 아닌 선언이 발견되었습니다.'
# 'non-template friend declaration with a requires clause must be a definition'
H95DF301285CD: '템플릿이 아닌 프렌드 선언이 requires 절을 갖는 경우 반드시 정의여야 합니다'
# 'non-template literal operator must have one or two parameters'
HAB8D25BD0598: '템플릿이 아닌 리터럴 연산자는 하나 또는 두 개의 매개변수를 가져야 합니다'
# 'non-templated declaration is here'
H5E1276462F94: '템플릿이 아닌 선언이 여기에 있습니다'
# 'non-templated function cannot have a requires clause'
H82190871139C: '템플릿이 아닌 함수에는 requires 절을 가질 수 없습니다'
# 'non-thread-local declaration of %0 follows thread-local declaration'
H015D893F1487: 'thread-local 선언 뒤에 %0의 non-thread-local declaration이 있습니다.'
# 'non-trivial destruction of lifetime-extended temporary with type %0 used in the result of a constant expression is not yet supported'
HD2339C077B90: '상수 표현식의 결과에 사용된 유형 %0의 라이프타임 연장된 일시적 객체의 비ivial 소멸은 아직 지원되지 않았습니다'
# 'non-trivial destruction of type %0 in a constant expression is not supported'
HE2CD4D9E53E2: '타입 %0의 비平凡한 소멸은 상수 표현식에서 지원되지 않습니다'
# 'non-trivially copyable type %0 cannot be used in a boxed expression'
HB2216F42639D: '비-트리비얼 복사 가능 형식 %0는 박싱 표현식에서 사용할 수 없습니다'
# 'non-type declaration found by destructor name lookup'
HB02DCE8A7FF1: '비타입 선언이 소멸자 이름 검색을 통해 발견되었습니다'
# "non-type template argument '%0' is invalid"
H2399CD2B5610: "비형식 템플릿 인자 '%0'은 유효하지 않습니다"
# 'non-type template argument containing a dereference operation is a Microsoft extension'
HD4EF29A775AB: '비유형 템플릿 인자에 디레퍼런스 연산이 포함되었습니다. 이는 Microsoft 확장 기능입니다'
# 'non-type template argument does not refer to an object or function'
HE77C0A012513: '비형식 템플릿 인수는 객체나 함수를 가리키지 않습니다'
# 'non-type template argument does not refer to any declaration'
HB25807F91411: '비유형 템플릿 인수는 어떤 선언에도 참조되지 않았습니다'
# 'non-type template argument for template parameter of pointer type %0 must have its address taken'
H8D4CDD97C49D: '템플릿 매개변수가 포인터 유형 %0인 비유형 템플릿 인자는 주소가 취해져야 합니다'
# 'non-type template argument is not a pointer to member constant'
HDC21F0C558EB: '비타입 템플릿 인수는 멤버 상수 포인터가 아닙니다.'
# 'non-type template argument of reference type %0 is not an object'
H50574CDA0DAD: '참조 형식 %0인 템플릿의 비유형 인수는 객체가 아닙니다'
# 'non-type template argument of type %0 cannot be converted to a value of type %1'
HDF1742D8033F: '형식 %0의 비형식 템플릿 인수는 형식 %1의 값으로 변환될 수 없습니다'
# 'non-type template argument of type %0 is not a constant expression'
H075FB8D7A63A: '타입 %0의 비형식 템플릿 인수는 상수 표현식이 아닙니다'
# 'non-type template argument of type %0 is not an integral constant expression'
HE2EA0C6B3858: '유형이 %0인 비유형 템플릿 인자는 정수 상수 표현式이 아닙니다'
# 'non-type template argument of type %0 must have an integral or enumeration type'
H06D35F5E0195: '비형식 템플릿 인수의 유형이 %0인 경우 정수형 또는 열거형 타입이어야 합니다'
# 'non-type template argument referring to %select{function|object}0 %1 with internal linkage is a C++11 extension'
HEFF3308ED7FE: '비유형 템플릿 인수가 %select{함수|객체}0 %1에 내부 링크지를 참조하는 것은 C++11 확장입니다'
# 'non-type template argument referring to %select{function|object}0 %1 with internal linkage is incompatible with C++98'
H2F0100862103: '비타입 템플릿 인수가 내부 링크지정을 가진 %select{함수|객체}0 %1을 참조하기 때문에 C++98과 호환되지 않습니다'
# 'non-type template argument refers here'
HA953EF53E7DD: '비형식 템플릿 인자가 여기를 참조합니다'
# 'non-type template argument refers to %select{function|object}0 %1 that does not have linkage'
H600BCDFEE43D: '비유형 템플릿 인자가 연결이 없는 %select{함수|객체}0 %1을 참조합니다'
# 'non-type template argument refers to %select{function|object}0 here'
H9ED37B3451CC: '비형식 템플릿 인수는 여기서 %select{함수|객체}0을 참조합니다'
# 'non-type template argument refers to non-static data member %0'
H2465AB2AA5B5: '비형식 템플릿 인자가 비정적 데이터 멤버 %0를 참조합니다'
# 'non-type template argument refers to non-static member function %0'
H6A037F433017: '비형식 템플릿 인자는 비정적 멤버 함수 %0를 가리킬 수 없습니다'
# "non-type template argument refers to subobject '%0'"
HD30CEA1C7504: "비유형 템플릿 인자는 '%0'라는 부분 객체를 가리킬 수 없습니다"
# 'non-type template argument refers to thread-local object'
H1DFBA6B66CEF: '비형식 템플릿 인수는 스레드 로컬 객체를 참조합니다'
# 'non-type template argument specializes a template parameter with dependent type %0'
H77D31AA373EF: '형식이 아닌 템플릿 인자가 의존 형식 %0를 갖는 템플릿 매개변수를 특수화합니다'
# "non-type template argument value '%0' truncated to '%1' for template parameter of type %2"
H5466021B086C: "비형식 템플릿 인자 값 '%0'가 %2 타입의 템플릿 매개변수에 대해 '%1'로 잘려졌습니다"
# "non-type template argument with value '%0' converted to '%1' for unsigned template parameter of type %2"
H4635C03C8C36: "비유형 템플릿 인자의 값 '%0'가 형식 %2의 부호 없는 템플릿 매개변수를 위해 '%1'로 변환되었습니다"
# 'non-type template parameter %0 with type %1 has incompatible initializer of type %2'
H36B37E5D284B: '형식이 아닌 템플릿 매개변수 %0는 %1 형식으로, 호환되지 않는 %2 형식의 초기화자가 있습니다'
# 'non-type template parameter declared with incompatible types in different translation units (%0 vs. %1)'
H349C88186DB6: '비형식 템플릿 매개변수가 다른 번역 단위에서 호환되지 않는 형으로 선언되었습니다 (%0 vs. %1)'
# 'non-type template parameter has incomplete type %0'
H67B9597CFD9A: '비유형 템플릿 매개변수는 미완료 형식 %0을 가집니다'
# 'non-type template parameter has non-literal type %0'
H271C87C2E376: '비형식 템플릿 매개변수는 리터럴이 아닌 형식 %0를 가집니다'
# 'non-type template parameter has rvalue reference type %0'
H8258CBB4119D: '비형식 템플릿 매개변수가 rvalue 참조 형식 %0을 갖습니다'
# 'non-type template parameter of reference type %diff{$ cannot bind to template argument of type $|cannot bind to template of incompatible argument type}0,1'
H4F089D7DCBD1: '비유형 템플릿 매개변수의 참조 유형 %diff{템플릿 인수의 유형 $0에 바인딩할 수 없습니다.|호환되지 않는 인수 유형의 템플릿에 바인딩할 수 없습니다.}0,1'
# 'non-type template parameter of type %0 is incompatible with C++ standards before C++20'
H76F7D38734C2: 'C++20 이전의 C++ 표준과 호환되지 않는 %0 형식의 형식이 아닌 템플릿 매개변수'
# 'non-type template parameter of variably modified type %0'
HDB7696E83E21: '가변적 형식의 비유형 템플릿 매개변수 %0'
# 'non-type template parameters declared with %0 are incompatible with C++ standards before C++17'
H4034BC5F4762: '%0로 선언된 비형식 템플릿 매개변수는 C++17 이전의 C++ 표준과 호환되지 않습니다'
# 'non-usual %0 declared here'
H9B44D0E82E0B: '일반적이지 않은 %0이 여기서 선언되었습니다'
# "non-variable declaration in 'for' loop"
HE2801E92B8D8: 'for 루프에서 변수 선언이 아닌 문'
# "non-variable declaration in 'for' loop is a C23 extension"
H861D242B28D2: "변수 선언이 아닌 선언을 'for' 루프 내에서 사용하는 것은 C23 확장 기능입니다"
# "non-variable declaration in 'for' loop is incompatible with C standards before C23"
H1A5C6F3C6A58: "C23 이전의 C 표준과 호환되지 않는 'for' 루프 내의 비변수 선언"
# "non-virtual member function marked '%0' hides virtual member %select{function|functions}1"
H6156F12DC3F9: "비가상 멤버 함수가 '%0'로 표시되어 가상 멤버 %select{함수|함수들}1를 숨기고 있습니다"
# 'non-void %select{constexpr|consteval}1 function %0 should return a value'
HCF55E17BA989: '비,void가 아닌 %select{constexpr|consteval}1 함수 %0는 값을 반환해야 합니다'
# 'non-void %select{function|block|lambda|coroutine}0 does not return a value%select{| in all control paths}1'
H75EE618D1AA4: '비_VOID %select{함수|블록|람다|코루틴}0는 값을 반환하지 않습니다%select{| 모든 제어 경로에서}1'
# 'non-void %select{function|method}1 %0 should return a value'
HEE95067001EB: '비_VOID %select{함수|메소드}1 %0는 값 반환을 해야 합니다'
# 'non-void block should return a value'
H66594B013217: '비:void 블록은 값을 반환해야 합니다'
# "nonnull %select{function call|parameter}0 '%1' will evaluate to 'true' on first encounter"
H925BCFBBE426: "nonnull %select{함수 호출|파라미터}0 '%1'은 첫 번째 접근 시 '참'으로 평가됩니다"
# 'not a Doxygen trailing comment'
HB02E938B9DEC: 'Doxygen 후행 주석이 아닙니다'
# "not currently inside '#pragma clang arc_cf_code_audited'"
HD79C4D940185: "현재 '#pragma clang arc_cf_code_audited' 내부에 있지 않습니다"
# "not currently inside '#pragma clang assume_nonnull'"
HF77D5E6601B3: "현재 '#pragma clang assume_nonnull' 지시문 내부에 있지 않습니다."
# "not currently inside '#pragma unsafe_buffer_usage'"
H658512A345D7: "현재 '#pragma unsafe_buffer_usage' 안쪽에 있지 않습니다"
# 'not eliding copy on return'
H0FB30CAF71B6: '리턴 시 복사 생략하지 않음'
# 'not enough variable arguments in %0 declaration to fit a sentinel'
H9930B56495BC: '시네일을 맞추기에 %0 선언에 변수 인자가 충분하지 않습니다'
# 'not packing field %0 as it is non-POD for the purposes of layout'
H7FBA81FDAA18: '레이아웃을 위한 목적으로 non-POD이기 때문에 필드 %0을(를) 패킹하지 않습니다.'
# 'not-yet-instantiated member is declared here'
HACFD1F41F676: '이 멤버는 아직 인스턴스화되지 않았습니다'
# 'null character ignored'
H6B4B3A47C8AC: '널 문자 무시됨'
# 'null character(s) preserved in %select{char|string}0 literal'
H062C86F6116B: '널 문자가 %select{char|string}0 리터럴에 유지되었습니다'
# 'null non-type template argument must be cast to template parameter type %0'
HDDA635486EF3: 'null 비형식 템플릿 인수는 템플릿 매개변수 유형 %0로 캐스팅되어야 합니다'
# 'null non-type template argument of type %0 does not match template parameter of type %1'
HCF293B48A07C: 'NULL인 %0 형식의 형식이 아닌 템플릿 인자는 %1 형식의 템플릿 매개변수와 일치하지 않습니다.'
# 'null passed to a callee that requires a non-null argument'
H5F7D096FCE08: 'null이 비어있지 않은 인자를 요구하는 호출 대상에 전달되었습니다'
# 'null returned from %select{function|method}0 that requires a non-null return value'
HEA9F26CD4560: 'null 값이 %select{함수|메소드}0에서 null이 아닌 반환 값을 요구하는 곳으로 반환되었습니다'
# 'nullability keyword %0 cannot be applied to multi-level pointer type %1'
H9F63F0EFF7CC: 'nullability 키워드 %0는 다중 레벨 포인터 타입 %1에 적용할 수 없습니다'
# 'nullability specifier %0 cannot be applied to non-pointer type %1'
HA1F5D87BE3DF: 'nullability 지정자 %0는 포인터가 아닌 형식 %1에 적용할 수 없습니다'
# 'nullability specifier %0 cannot be applied to non-pointer type %1; did you mean to apply the specifier to the %select{pointer|block pointer|member pointer|function pointer|member function pointer}2?'
H3E269F064E84: 'nullability specifier %0는 포인터 형식이 아닌 %1에 적용될 수 없습니다; 지정자를 %select{포인터|블록 포인터|멤버 포인터|함수 포인터|멤버 함수 포인터}2에 적용하려는 것이었는지 확인하세요.'
# 'nullability specifier %0 conflicts with existing specifier %1'
H4421DC48369F: '비필수 지정자 %0은 기존의 지정자 %1과 충돌합니다'
# 'number of elements must be either one or match the size of the vector'
H2A474F4275FA: '요소의 수는 1이거나 벡터의 크기와 일치해야 합니다'
# 'number of entries per line (default 256)'
H7D63977C73C8: '라인당 항목 수 (기본값 256)'
# 'number of functions to display when printing the top largest differences in function activity'
H4322F776E088: '함수 활동에서 상위 가장 큰 차이를 출력할 때 표시할 함수의 수'
# 'number of hottest functions to print aggregated profile quality stats of.'
H5B5E76B4AA88: '출력할 가장 뜨거운 함수의 수(개): 집계된 프로파일 품질 통계를 위한.'
# 'number of tasks to be created per thread'
HE2569802814C: '스레드당 생성할 작업의 수'
# 'number of threads'
HE591548912FE: '쓰레드 개수'
# 'numeric literal with user-defined suffix cannot be used here'
H6D6640DAD12D: '사용자 정의 접미사를 가진 수치 리터럴은 여기서 사용할 수 없습니다'
# "nvcc does not allow '__%0__' to appear after the parameter list in lambdas"
H052A23E5C9DE: "nvcc는 람다의 매개변수 목록 후에 '__%0__'가 나타나는 것을 허용하지 않습니다"
# 'obj2yaml Options'
HDEB46CD09A6E: 'obj2yaml 옵션'
# 'objc_precise_lifetime is not meaningful for %select{__unsafe_unretained|__autoreleasing}0 objects'
H3B4A7538E1D6: '%select{__unsafe_unretained|__autoreleasing}0 개체에 대해 objc_precise_lifetime은 의미가 없습니다'
# 'objc_precise_lifetime only applies to retainable types; type here is %0'
HCB888D9DBEF6: 'objc_precise_lifetime은 보존 가능 유형에만 적용됩니다; 여기서의 유형은 %0입니다'
# 'objc_root_class attribute may only be specified on a root class declaration'
H8B7E866F5F47: 'objc_root_class 속성은 오직 루트 클래스 선언에만 지정할 수 있습니다'
# 'object backing %select{|the pointer }0%1 will be destroyed at the end of the full-expression'
H4CCEF5B24A9C: '객체의 백킹 %select{|the pointer }0%1는 전체 표현식의 끝에서 파괴됩니다'
# 'object backing the pointer %0 will be destroyed at the end of the full-expression'
H4314D747B320: '포인터 %0를 뒷받침하는 객체는 전체 표현식의 끝에서 파괴됩니다'
# 'object backing the pointer will be destroyed at the end of the full-expression'
HCBDFA4406EFB: '포인터를 뒤받침하는 객체는 전체 표현식의 끝에서 소멸될 것입니다'
# 'object expression of non-scalar type %0 cannot be used in a pseudo-destructor expression'
H8E297F831414: '비스칼라 형식의 객체 표현식 %0은 의사 소멸자 표현식에서 사용될 수 없습니다'
# "object format flags cannot be used with '%0' conversion specifier"
HAF558B2410E4: "객체 형식 플래그는 '%0' 변환 지정자와 함께 사용할 수 없습니다"
# 'object of type %0 cannot be %select{constructed|copied|moved|assigned|assigned|destroyed}1 because its %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}1 is implicitly deleted'
H828A944AA309: '타입 %0의 객체는 %select{생성|복사|이동|할당|할당|소멸}1될 수 없습니다.因为它의 %select{디폴트 생성자|복사 생성자|이동 생성자|복사 할당 연산자|이동 할당 연산자|소멸자}1가 암묵적으로 삭제되어 있습니다'
# 'object of type %0 cannot be compared because its %1 is implicitly deleted'
H4465935A9154: '%0 형 객체는 %1이(가) 암시적으로 삭제되어 비교할 수 없습니다'
# 'object of type %0 cannot be placed in read-only memory'
HD27A532EA3C9: '%0 유형의 객체는 읽기 전용 메모리에 배치될 수 없습니다'
# 'object of type %0 is not compatible with %select{array element type|dictionary key type|dictionary value type}1 %2'
HBDF524B06F4F: '%0 유형의 객체는 %select{배열 요소 유형|사전 키 유형|사전 값 유형}1 %2와 호환되지 않습니다'
# 'object whose reference is captured by %0 will be destroyed at the end of the full-expression'
H79F166A683BE: '%0에 의해 참조가 캡처된 객체는 전체 표현식의 끝에서 파괴됩니다'
# 'object whose reference is captured will be destroyed at the end of the full-expression'
H04404B93E557: '참조가 캡처된 객체는 전체 표현식의 끝에서 파괴될 것입니다'
# 'octal integer literals are a C2y extension'
HCB95FC190C42: '8진 정수 리터럴은 C2y 확장 기능입니다'
# 'octal integer literals are a Clang extension'
H0A7A0AD8FA23: '8진 정수 리터럴은 Clang의 확장 기능입니다'
# 'octal integer literals are incompatible with standards before C2y'
HFF58B98B1092: '8진 정수 리터럴은 C2y 이전의 표준과 호환되지 않습니다'
# "octal literals without a '0o' prefix are deprecated"
H297C91C7799F: '0o 접두사가 없는 8진 리터럴은 사용 중지되었습니다'
# 'offload-arch options'
H7186B8C146CF: '오프로드 아키텍처 옵션'
# 'offset of asan shadow mapping [EXPERIMENTAL]'
HB87160E3C269: 'asan 샤도우 매핑의 오프셋 [실험적]'
# 'offset-based plaintext format'
H4A173EEFA114: '오프셋 기반 plaintext 포맷'
# 'offsetof of incomplete type %0'
H01B4054FE86A: 'offsetof 매크로는 완전히 정의되지 않은 형식 %0를 사용할 수 없습니다.'
# 'offsetof requires array type, %0 invalid'
H72E546984F9B: 'offsetof는 배열 형식이 필요합니다. %0은(는) 무효입니다'
# 'offsetof requires struct, union, or class type, %0 invalid'
H1EED7971DB36: 'offsetof은 구조체, 유니온 또는 클래스 형식이 필요합니다, %0는 무효입니다'
# "old syntax '%0' on '%1' clause was deprecated, use new syntax '%2'"
H62AFC50986BB: "구 구문 '%0'은 '%1' 절에서 지원 중단되었으니, 새 구문 '%2'를 사용하세요."
# 'omit the namespace to add attributes to the most-recently pushed attribute group'
H33451023019A: '네임스페이스를 생략하면 가장 최근에 추가된 속성 그룹에 속성을 추가합니다'
# 'omitting the parameter name in a function definition is a C23 extension'
H239CD59B1E97: '함수 정의에서 매개변수 이름을 생략하는 것은 C23 확장 기능입니다'
# 'on M-profile architectures %0 attribute is not supported on targets missing %1; specify an appropriate -march= or -mcpu='
HF63DAE65A9BA: 'M-profile 아키텍처에서 %0 속성은 %1이 누락된 타겟에서 지원되지 않습니다. 적절한 -march= 또는 -mcpu= 옵션을 지정하세요.'
# 'one cluster per opcode'
H571A5AC320D2: '각 opcode당 하나의 클러스터'
# "one of 'for', 'parallel', 'sections' or 'taskgroup' is expected"
HA318D6E65846: "다음 중 하나가 필요합니다: 'for', 'parallel', 'sections' 또는 'taskgroup'"
# 'one possibility'
HF5AE3D1F7A2D: '가능성 중 하나'
# "only %select{'omp_priv' or 'omp_orig'|'omp_in' or 'omp_out'}0 variables are allowed in %select{initializer|combiner}0 expression"
HBFBFE733ACC9: "오직 %select{'omp_priv' 또는 'omp_orig'|'omp_in' 또는 'omp_out'}0 변수만이 %select{초기화자|조합자}0 표현식에서 허용됩니다"
# "only '*' can be exported from an inferred submodule"
HB1E7869E1AA8: "추론된 하위 모듈에서 수출할 수 있는 것은 오직 '*'만입니다"
# "only 'device_type(any)' clause is allowed with indirect clause"
H60FE040D9778: "indirect clause와 함께 'device_type(any)' 구문만 허용됩니다."
# "only 'unavailable' and 'deprecated' are supported for Swift availability"
H711C14834055: "Swift 가용성은 'unavailable' 및 'deprecated'만 지원됩니다."
# 'only a single match extension allowed per OpenMP context selector'
H54ED4E173E0C: 'OpenMP 컨텍스트 선택자당 하나의 매칭 확장만 허용됩니다'
# 'only allow matching call instructions if the name and type signature match.'
HA22B2A05D450: '이름과 타입 시그니처가 일치하는 경우에만 해당 호출 지시문을 허용합니다.'
# 'only apply branch boundary alignment in hot code'
H486A9C1A43ED: '핫 코드에서만 분기 경계 정렬을 적용합니다.'
# 'only constructors take base initializers'
HDB605C258726: '기반 클래스 초기화자는 생성자(constructor)에서만 사용할 수 있습니다.'
# 'only dump ids with the specified hexadecimal type index'
H5475CDF64D0B: '지정된 16진수 유형 인덱스를 가진 ID만 내보냅니다'
# 'only dump symbol record with the specified symbol offset'
H990FE7E1637C: '지정된 기호 오프셋을 가진 기호 레코드만 덤프합니다'
# 'only dump types with the specified hexadecimal type index'
HF6EF25D1A99D: '지정된 16진수 형식 인덱스를 가진 유형만 덤프합니다'
# 'only enumeration types have underlying types'
H35007289C6D1: '열거형 타입만 기초 타입을 갖습니다'
# 'only function and template parameters can be parameter packs'
HE058E90890AE: '함수와 템플릿 매개변수만 매개변수 팩일 수 있습니다.'
# 'only functions can have deleted definitions'
H0BDC0C1C20D8: '삭제된 정의는 함수만 가질 수 있습니다.'
# 'only insert instrumentation on hot functions (needs profile, default: false)'
H6921A5326E9E: '핫 함수에만 인스트루먼테이션을 삽입합니다. (프로파일이 필요하며 기본값은 false입니다)'
# "only loop iteration variables are allowed in 'lastprivate' clause in 'omp %0' directives"
H93109DDAC062: "omp %0 디렉티브의 'lastprivate' 절에서는 루프 반복 변수만 허용됩니다"
# "only loop iteration variables are allowed in 'linear' clause in distribute directives"
HB4FBF6AB0B0A: "분배 지시문의 'linear' 절에서 루프 반복 변수만 허용됩니다."
# 'only one %0 clause can appear on a requires directive in a single translation unit'
H67EC4B23D848: '단일 번역 단위에서 requires 지시문에 %0 절은 단 하나만 등장할 수 있습니다'
# 'only one element declaration is allowed'
HB7E0C8F27CB5: '요소 선언은 하나만 허용됩니다.'
# "only one expression allowed in '%0' clause"
H200100A1AF70: "표현식은 '%0' 절 내에서 하나만 허용됩니다"
# 'only one offload target is supported'
H36578B307452: '오프로드 대상은 하나만 지원됩니다.'
# "only one parameter on 'main' declaration"
H09469DD0E50E: '메인 선언에 파라미터는 하나만 허용됩니다'
# 'only perform sctc when branch direction is preserved'
HF40E26771C18: '분기 방향이 유지되는 경우에만 sctc를 수행합니다.'
# 'only promote call targets eligible for inlining'
H48B4D984BB43: '인라인 가능한 호출 대상만 강화합니다'
# 'only recurse to a depth of N when displaying children of a symbol record.'
H9AF5A4C86831: '기호 레코드의 자식을 표시할 때 최대 깊이 N까지 재귀 호출합니다.'
# 'only recurse to a depth of N when displaying parents of a symbol record.'
HFD73DE6E2DEF: '심볼 레코드의 부모를 표시할 때 재귀 깊이를 N까지만 적용합니다.'
# 'only rename the instructions in the function'
H255C85A34C1B: '함수 내의 명령문들만 이름을 변경하세요.'
# 'only replace exit value when it is an unused induction variable in the loop and has cheap replacement cost'
H4F514B4EF001: '루프 내에서 사용되지 않은 인도션 변수이고 대체 비용이 낮을 때만 종료 값을 대체합니다'
# 'only replace exit value when the cost is cheap'
H8C5F857AAD22: '비용이 낮을 때만 종료 값을 대체합니다'
# 'only replace exit values when loop def likely dead'
H1F90A0F5DC05: '루프 정의가 확실히 죽은 경우에만 출구 값을 대체합니다'
# 'only show the top N results'
H31C65CA913F9: '상위 N개 결과만 표시합니다'
# 'only special member functions %select{|and comparison operators }0may be defaulted'
H7676F4E831FD: '특수 멤버 함수들만 %select{|비교 연산자와 }0기본 구현으로 지정할 수 있습니다.'
# 'only submodules and framework modules may be inferred with wildcard syntax'
HB41F304027AC: '서브 모듈과 프레임워크 모듈만이 와일드카드 구문을 사용하여 추론될 수 있습니다'
# 'only the first dimension of an allocated array may have dynamic size'
HCC4AF93D4D25: '할당된 배열의 차원 중에서 첫 번째 차원만 동적 크기를 가질 수 있습니다'
# 'only top-level modules can be re-exported as public'
H35599F0992E5: '공개로 재수출할 수 있는 모듈은 최상위 레벨 모듈만 가능합니다'
# 'only use samples from process with specified PID'
HE4657121A5A3: '지정된 PID를 가진 프로세스에서만 샘플을 사용합니다'
# "only variable %0 is allowed in map clauses of this 'omp declare mapper' directive"
HCD77D6699FCF: "이 'omp declare mapper' 지시어의 map 절에서는 변수 %0만 허용됩니다."
# "only variables can be arguments to '#pragma unused'"
H454069F49B2C: " '#pragma unused'의 인수로는 변수만 사용할 수 있습니다."
# "only virtual member functions can be marked '%0'"
H88BCFFA5846F: "가상 멤버 함수만 '%0'로 표시할 수 있습니다."
# 'only zero-length WebAssembly tables are currently supported'
H834ECF2F9D5B: '현재는 길이가 0인 WebAssembly 테이블만 지원됩니다'
# 'opcode to measure, by index, or -1 to measure all opcodes'
H04C71CF551B6: '측정할 opcode의 인덱스를 지정하거나, -1을 입력하면 모든 opcode를 측정합니다'
# "operand argument to %select{overflow builtin|checked integer operation}0 must be an integer type %select{|other than plain 'char', 'bool', bit-precise, or an enumeration }0(%1 invalid)"
H232C02FD2560: "операнд 인수는 %select{overflow builtin|checked integer operation}0에 대해 정수 형이어야 하며, %select{ | 'char', 'bool', 비트 정밀도 또는 열거형 등이 아닌 }0(%1이 유효하지 않음)"
# 'operand of ? changes signedness: %0 to %1'
H034F94202BD7: '삼항 연산자 ?의 피연산자가 부호 변경: %0에서 %1으로'
# 'operand of type %0 cannot be cast to a pointer type'
H39550A20AC28: '%0 형식의 피연산자는 포인터 형식으로 캐스팅할 수 없습니다'
# 'operand of type %0 where arithmetic or pointer type is required'
H73F559724DF8: '산술 또는 포인터 형식이 필요한 %0 형식의 피연산자'
# 'operands to conditional of types%diff{ $ and $|}0,1 are incompatible in ARC mode'
HA7936DDDD636: '조건부 연산자의 피연산자의 유형%diff{ $와 $|}0,1은 ARC 모드에서 호환되지 않습니다'
# "operator '%0' has lower precedence than '%1'; '%1' will be evaluated first"
H7655BF3550EE: "연산자 '%0'는 '%1'보다 우선순위가 낮아 '%1'이 먼저 평가됩니다"
# "operator '?:' has lower precedence than '%0'; '%0' will be evaluated first"
HFCE2B46187B8: "연산자 '?:'는 '%0'보다 우선순위가 낮아 '%0'가 먼저 계산됩니다"
# 'operators in fold expression must be the same'
H1479CC2CDE54: '폴드 표현식 내의 연산자는 모두 같아야 합니다'
# 'opt-like flags'
H2AE16EED276B: 'opt 유사 플래그'
# "optimization flag '%0' is not supported"
HED6E92EF31B3: "최적화 플래그 '%0'는 지원되지 않습니다"
# "optimization flag '%0' is not supported for target '%1'"
H7BA15DDB49BE: "옵티마이제이션 플래그 '%0'은(는) 대상 '%1'에서 지원되지 않습니다"
# "optimization level '%0' is not supported; using '%1%2' instead"
H6D18AF90D4BB: "옵티마이제이션 레벨 '%0'은 지원되지 않습니다; 대신 '%1%2'를 사용합니다"
# 'optimize PLT calls (requires linking with -znow)'
H1C6C02B1FC92: 'PLT 호출 최적화 (링킹 시 -znow 옵션과 함께 연결 필요)'
# 'optimize all PLT calls'
H729D15249489: '모든 PLT 호출 최적화'
# 'optimize executed (hot) PLT calls'
HB328EE466E4E: '최적화 실행 (hot) PLT 호출'
# 'optimize functions with jump tables'
H1F9747FD82E4: '점프 테이블을 사용하는 함수 최적화'
# 'optimize hottest calls until at least this percentage of all indirect calls frequency is covered. 0 = all callsites'
H770180548F4F: '가장 뜨거운 호출을 최적화하여 전체 간접 호출 빈도의 이 비율 이상이 달성될 때까지. 0 = 모든 호출 위치'
# 'optimize stack frame accesses'
H72DEC23B9CC3: '스택 프레임 액세스 최적화'
# "option '%0' cannot be specified on this target"
H1BE1A4C28B5B: "옵션 '%0'은(는) 이 타겟에 지정할 수 없습니다."
# "option '%0' cannot be specified with '%1'"
H70F63315B132: "옵션 '%0'은 '%1'과 함께 지정할 수 없습니다."
# "option '%0' cannot be specified with '%1' for the %2 sub-architecture"
HBBDD552F5F1A: "옵션 '%0'은 '%1'과 함께 %2 서브 아키텍처에서 지정할 수 없습니다"
# "option '%0' cannot be specified without '%1'"
H583C3C9DA6E7: "옵션 '%0'은 '%1' 없이 지정할 수 없습니다"
# "option '%0' requires input to be LLVM bitcode"
HA5B4E61775E4: "옵션 '%0'은 입력이 LLVM bitcode여야 합니다"
# "option '%0' was ignored by the %1 toolchain, using '-fPIC'"
H22B2E1051C0B: "옵션 '%0'가 %1 툴체인에 의해 무시되어 '-fPIC'를 사용합니다"
# "option '-MG' requires '-M' or '-MM'"
HCCC4BA63CA80: "옵션 '-MG'는 '-M' 또는 '-MM'이 필요합니다"
# "option '-ffine-grained-bitfield-accesses' cannot be enabled together with a sanitizer; flag ignored"
H4FD110105D82: "옵션 '-ffine-grained-bitfield-accesses'는 샌타이저와 동시에 사용할 수 없습니다; 플래그 무시됨"
# "option '-fmodule-output' cannot be used with multiple arch options"
H67AC45523A0C: "옵션 '-fmodule-output'은 여러 개의 arch 옵션과 함께 사용할 수 없습니다"
# "option '-fmodules-validate-once-per-build-session' requires '-fbuild-session-timestamp=<seconds since Epoch>' or '-fbuild-session-file=<file>'"
H5685B0FE4474: "옵션 '-fmodules-validate-once-per-build-session'은 '-fbuild-session-timestamp=<seconds since Epoch>' 또는 '-fbuild-session-file=<file>'이 필요합니다"
# "option 'ffp-eval-method' cannot be used with option %select{'fapprox-func'|'mreassociate'|'freciprocal'}0"
H1D986A148023: "옵션 'ffp-eval-method'는 옵션 %select{'fapprox-func'|'mreassociate'|'freciprocal'}0와 함께 사용할 수 없습니다"
# 'options %0 and %1 are set to different values'
H15DAE6B37541: '옵션 %0과 %1이 서로 다른 값으로 설정되었습니다'
# 'or because setter is declared here, but no getter method %0 is found'
H9306685E39B6: '또는 setter가 여기에 선언되었지만, 대응하는 getter 메서드 %0가 발견되지 않았기 때문입니다'
# "or insert whitespace before ':' to use %0 as parameter name and have an empty entry in the selector"
H09DF98AB0B6F: "또는 ':' 앞에 공백을 삽입하여 %0를 매개변수 이름으로 사용하고 셀렉터에 빈 항목을 포함할 수 있습니다"
# 'order by execution count'
H7EA3A097FEC2: '실행 횟수에 따라 정렬'
# 'ordered compare requires two args of floating point type%diff{ ($ and $)|}0,1'
HC6DBD7D802C7: '정렬 비교는 부동소수점 유형의 두 인수를 필요로 합니다%diff{ ($ 및 $)|}0,1'
# 'ordered comparison between pointer and integer (%0 and %1)'
HCE8E7EA44A15: '포인터와 정수 사이의 순서 비교 (%0과 %1)'
# 'ordered comparison between pointer and zero (%0 and %1)'
H08DE668CB79E: '포인터와 0 사이의 순서 비교 (%0 및 %1)'
# 'ordered comparison between pointer and zero (%0 and %1) is an extension'
HEFA21113E58A: '포인터와 0 사이의 순서 비교(%0과 %1)는 확장 기능입니다'
# 'ordered comparison of function pointers (%0 and %1)'
H6623D571A716: '함수 포인터(%0과 %1)의 순서 비교'
# 'original arguments in round-trip: %0'
H88D576AD9392: '반전송 중인 원본 인수: %0'
# 'original arguments parse failed, then succeeded in round-trip'
H4354C394D0BE: '원래 인수 해석 실패 후, 원본 복구에 성공'
# 'original storage of expression in data environment is shared but data environment do not fully contain mapped expression storage'
H8588EE9D0D77: '데이터 환경 내 표현식의 원래 저장소는 공유되고 있지만, 데이터 환경은 매핑된 표현식 저장소를 완전히 포함하지 않습니다'
# "orphaned 'omp %0' directives are prohibited; perhaps you forget to enclose the directive into a %select{|||target |teams|for, simd, for simd, parallel for, or parallel for simd }1region?"
H09B89CE1DDFB: "고아인 'omp %0' 지시문은 허용되지 않습니다; 지시문을 %select{|||target |teams|for, simd, for simd, parallel for, or parallel for simd }1 영역 안에 포함하지 않아서 그런 것일까요?"
# "os '%0' is not supported: '%1'"
HD285B7E47AB6: "os '%0'는 지원되지 않습니다: '%1'"
# "os_log() '%%n' format specifier is not allowed"
HA308C5A1A678: "os_log() '%%n' 포맷 지정자는 허용되지 않습니다"
# 'os_log() argument %0 is too big (%1 bytes, max %2)'
H93B7553E2DE5: 'os_log() 인수 %0은 너무 큽니다(%1 바이트, 최대 %2)'
# 'os_log() format argument is not a string constant'
H6ABC3AD79FAA: 'os_log() 포맷 인수는 문자열 상수가 아닙니다'
# 'other definition of %0'
HFB23FE3FA4F8: '%0의 다른 정의'
# 'out-of-line %select{declaration|definition}2 of %0 does not match any declaration in %1'
HC3CEC6EF88DD: '선언과 분리된 %select{선언|정의}2인 %0는 %1에 있는 어떤 선언과도 일치하지 않습니다'
# 'out-of-line %select{declaration|definition}2 of %0 does not match any declaration in %1; did you mean %3?'
H6724D4146D60: 'out-of-line %select{선언|정의}2 of %0는 %1 안의 어떤 선언과도 일치하지 않습니다; %3 의 오타일까요?'
# 'out-of-line constructor for %0 cannot have template arguments'
H33FE02CBF6A6: '라인 밖 생성자 %0는 템플릿 인수를 가질 수 없습니다'
# 'out-of-line declaration of a member must be a definition'
HBCC796880D79: '멤버의 클래스 외부 선언은 정의여야 합니다'
# 'out-of-line definition of %0 from class %1 without definition'
H3397C2717560: '클래스 %1의 %0에 대한 외부 정의가 정의되지 않았습니다.'
# 'out-of-line definition of constexpr static data member is redundant in C++17 and is deprecated'
HF4242355CFAD: 'C++17에서 constexpr 정적 데이터 멤버의 라인 외 정의는 중복적이며, 폐기 예정입니다'
# 'outline as many cold basic blocks as possible'
HA720A2B172BB: '가능한 한 많은 콜드 기본 블록을 추출합니다'
# "output data (.csv) for Stoke's use"
H566F7B66D7EF: 'Stoke의 사용을 위한 출력 데이터 (.csv)입니다'
# 'output file to write out a summary of the partitions created for each module'
H9036C41EDFF6: '각 모듈별로 생성된 파티션의 요약 정보를 작성하기 위해 사용할 출력 파일'
# 'output file to write out the dotgraph representation of the input module'
H491BF84F04E2: '입력 모듈의 dotgraph 표현을 작성할 출력 파일'
# "output file; use '-' for stdout"
H239A9905E956: "출력 파일; stdout로 사용하려면 '-'를 사용하세요"
# 'output format'
H8D3CACC9A576: '출력 형식'
# 'output in binary'
HF1C94F4E5F08: '2진수로 출력'
# 'output in yaml'
HFFA9E62F70D8: 'YAML 형식으로 출력'
# 'output the AST dump'
HE5094C7EDA7B: 'AST dump를 출력합니다'
# 'output the LLVM IR dump'
H722A785E838D: 'LLVM IR 덤프 출력'
# 'output the MLIR dump'
H5AB21662EF6D: 'MLIR 덤프를 출력합니다'
# 'output the MLIR dump after affine lowering'
H412D35179012: 'affine lowering 이후 MLIR 덤프 출력'
# 'output the MLIR dump after llvm lowering'
H5560C4070D86: 'llvm lowering 이후 MLIR 덤프 출력'
# 'overflow converting case value to switch condition type (%0 to %1)'
HF36747707003: '오버플로우: case 값의 값을 switch 조건 유형으로 변환하는 중 (%0에서 %1로)'
# 'overflow in expression; result is %0 with type %1'
H5FE3FC44898D: '표현식에서 오버플로 발생; 결과 값은 %0 형식 %1입니다'
# "overload resolution selected deleted operator '%0'%select{|: %2}1"
HB844E51E83EA: "오버로드 해결 과정에서 삭제된 연산자 '%0'%select{|: %2}1가 선택되었습니다"
# 'overloaded %0 cannot be a static member function'
HE25D37D77FD9: '오버로드된 %0는 정적 멤버 함수일 수 없습니다.'
# 'overloaded %0 cannot be variadic'
H49C83B8BBB4E: '오버로드된 %0는 가변인자일 수 없습니다'
# 'overloaded %0 cannot have %select{no|a defaulted|more than one}1 parameter before C++23'
H1FC62986EC90: '중복된 %0는 C++23 이전에는 %select{없을 수 없습니다|기본값을 가진 것을 가질 수 없습니다|한 개 이상을 가질 수 없습니다}1 매개변수를 가질 수 없습니다'
# 'overloaded %0 must be a %select{unary|binary|unary or binary}2 operator (has %1 parameter%s1)'
HA142B5DEA04D: '오버로드된 %0는 반드시 %select{일항|이항|일항 또는 이항}2 연산자여야 합니다 (파라미터가 %1개 있습니다)'
# 'overloaded %0 must be a non-static member function'
H359B48F5CEFF: '오버로드된 %0는 비정적 멤버 함수여야 합니다'
# 'overloaded %0 must have at least one parameter of class or enumeration type'
H329B9199B7C8: '과부하된 %0는 클래스 또는 열거형 유형의 매개변수를 최소 하나 이상 포함해야 합니다'
# 'overloaded %0 with %select{no|a defaulted|more than one}1 parameter is a C++23 extension'
H9DE4D96FF9C0: '오버로드된 %0에 %select{없는|기본값을 가진|한 개 이상의}1 매개변수가 있는 것은 C++23 확장 기능입니다'
# 'overloaded operator %select{>>|<<}0 has higher precedence than comparison operator'
H3D68DF30B083: '중복 정의된 연산자 %select{>>|<<}0는 비교 연산자보다 우선 순위가 높습니다'
# 'overridden method is here'
H33E209C67E48: '오버라이드된 메서드가 여기에 있습니다'
# 'overridden method returns an instance of its class type'
HA983C03A495A: '오버라이드된 메서드는 자신의 클래스 유형의 인스턴스를 반환합니다'
# 'overridden virtual function is here'
HFA2BCE5F4E2A: '재정의된 가상 함수는 여기에서 정의됨'
# 'override the name of the default PROGRAM entry (may be helpful for using other runtimes)'
HDBB3DF8CB32F: '기본 PROGRAM 항목의 이름을 덮어쓰기(다른 런타임을 사용하는 데 유용할 수 있습니다)'
# 'overrides DW_AT_comp_dir, and provides an alternative base location, which is used with DW_AT_dwo_name to construct a path to *.dwo files.'
HB19702484022: 'DW_AT_comp_dir를 재정의하고, 대체 기본 위치를 제공하며, 이는 DW_AT_dwo_name와 함께 사용되어 *.dwo 파일의 경로를 구성합니다.'
# "overriding '%0' option with '%1'"
H0BEA2CFA1C71: "옵션 '%0'을 '%1'로 덮어씁니다."
# 'overriding currently unsupported rounding mode on this target'
HE764C7911186: '현재 지원되지 않는 반올림 모드를 이 타겟에서 오버라이딩 중'
# 'overriding currently unsupported use of floating point exceptions on this target'
H4E019EDC5E1E: '이 타겟에서 현재 지원되지 않는 부동소수점 예외 사용을 재정의 중입니다'
# "overriding deployment version from '%0' to '%1'"
H3B5CC52823D1: "배포 버전을 '%0'에서 '%1'로 재정의"
# 'overriding method has mismatched ns_consumed attribute on its parameter'
H94209C3B1D29: '오버라이딩 메서드의 매개변수에 적용된 ns_consumed 속성이 일치하지 않습니다'
# 'overriding method has mismatched ns_returns_%select{not_retained|retained}0 attributes'
HFA26D6769DAD: '오버라이딩된 메서드가 ns_returns_%select{not_retained|retained}0 속성과 일치하지 않습니다'
# 'overriding the module target triple with %0'
H7A3B62788722: '%0로 모듈 타겟 triple을 재정의합니다'
# 'overriding virtual function must specify the same code segment as its overridden function'
HD38E3F8D7591: '가상 함수를 재정의하는 함수는 재정의되는 함수와 동일한 코드 세그먼트를 지정해야 합니다'
# 'p'
H516B9783FCA5: 'p'
# 'pac-ret: return address protection (subset of "pauth")'
H35B2314AE83E: 'pac-ret: 리턴 주소 보호 (pauth의 하위 집합)'
# 'pack declaration outside of template'
HDF7BB0B67932: '템플릿 외부에서 패킹 선언'
# 'pack expansion contains parameter pack %0 that has a different length (%1 vs. %select{|at least }2%3) from outer parameter packs'
H41600DB01010: '패키지 확장에 포함된 매개변수 패키지 %0의 길이가 (%1 대비 %select{|최소 }2%3) 외부 매개변수 패키지와 다릅니다'
# 'pack expansion contains parameter pack %0 that has a different length (at least %1 vs. %2) from outer parameter packs'
H477211AA8361: '패킹 확장에 외부 매개변수 패킹과 다른 길이(최소 %1 대 %2)를 가진 매개변수 패킹 %0가 포함되었습니다.'
# 'pack expansion contains parameter packs %0 and %1 that have different lengths (%2 vs. %select{|at least }3%4)'
H4F8FA8F98117: '패킹 확장은 서로 다른 길이의 매개변수 팩 %0과 %1을 포함합니다 (%2 대신 %select{|최소 }3%4)'
# 'pack expansion does not contain any unexpanded parameter packs'
H8BAD94174D96: '패킹 확장에 확장되지 않은 매개변수 팩이 포함되지 않았습니다'
# 'pack expansion for initialization of member %0'
HBD2872B50273: '멤버 %0의 초기화를 위한 팩 확장'
# 'pack expansion of using declaration is a C++17 extension'
H1BE8FC7C5774: 'using 선언의 패키지 확장은 C++17 확장 기능입니다'
# 'pack expansion used as argument for non-pack parameter of %select{alias template|concept}0'
HBF85ED181091: '패키지 확장이 %select{별칭 템플릿|개념}0의 비패키지 매개변수에 대한 인수로 사용되었습니다'
# 'pack expansion using declaration is incompatible with C++ standards before C++17'
HFDB9F5A38038: '사용 선언을 통한 팩 확장은 C++17 이전의 C++ 표준과 호환되지 않습니다'
# 'pack fold expression is a C++17 extension'
H7820808CC9E4: '패킹 폴드 표현은 C++17 확장 기능입니다'
# 'pack fold expression is incompatible with C++ standards before C++17'
H2F52B697F3BE: 'pack fold expression은 C++17 이전의 C++ 표준과 호환되지 않습니다'
# 'pack indexing is a C++2c extension'
H1086B8F449EB: '패키지 인덱싱은 C++2c 확장 기능입니다'
# 'pack indexing is incompatible with C++ standards before C++2c'
H9DAE09EBBEA1: '패키지 인덱싱은 C++2c 이전의 C++ 표준과 호환되지 않습니다'
# 'packed attribute is unnecessary for %0'
H08493DD022D1: 'packed 속성은 %0에 불필요합니다'
# "packoffset at 'y' not match alignment %0 required by %1"
H1D68367EC4D7: 'y 위치의 packoffset이 %1에 의해 요구되는 %0 정렬과 일치하지 않습니다'
# 'packoffset cannot cross register boundary'
HA00AFB61162C: 'packoffset은 레지스터 경계를 넘을 수 없습니다'
# 'packoffset overlap between %0, %1'
H8FBBA6B5715E: 'packoffset이 %0과 %1 사이에서 겹칩니다.'
# 'padding %select{struct|interface|class}0 %1 with %2 %select{byte|bit}3%s2 to align %4'
HB4806E10E325: '%select{struct|interface|class}0 %1의 패딩을 %2 %select{byte|bit}3%s2를 사용하여 %4 정렬에 맞추기 위해'
# 'padding %select{struct|interface|class}0 %1 with %2 %select{byte|bit}3%s2 to align anonymous bit-field'
HE333A36DBC3C: '패딩 %select{구조体型|인터페이스|클래스}0 %1을 %2 %select{바이트|비트}3%s2로 익명 비트 필드 정렬을 위해'
# 'padding %select{struct|interface|class}0 %1 with %2 %select{byte|bit}3%s2 to align anonymous field'
H1B5890218438: '패딩 %select{구조체|인터페이스|클래스}0 %1을 %2 %select{바이트|비트}3%s2로 채워 익명 필드를 정렬합니다'
# 'padding size of %0 with %1 %select{byte|bit}2%s1 to alignment boundary'
H5BCCA44B6E5B: '%0의 패딩 크기를 %1 %select{바이트|비트}2%s1로 정렬 경계까지 채움'
# 'parameter %0 must have a complete type to use function %1 with the %2 calling convention'
H35B9EA765265: '매개변수 %0는 %2 호출 규칙을 사용하여 함수 %1을 사용하려면 완전한 타입을 가져야 합니다'
# 'parameter %0 set but not used'
HB6BB1AF1B37E: '매개변수 %0 설정되었지만 사용되지 않음'
# "parameter %0 was not declared, defaults to 'int'; ISO C99 and later do not support implicit int"
H41790618129F: "%0 매개변수가 선언되지 않았습니다. 기본값은 'int'로 설정됩니다; ISO C99 및 이후 버전에서는 암시적 int가 지원되지 않습니다"
# "parameter '%0' is already documented"
HF9B7DF355428: "파라미터 '%0'는 이미 문서화 되었습니다"
# "parameter '%0' not found in the function declaration"
HD7CC3BBE6634: "매개변수 '%0'가 함수 선언문에서 발견되지 않았습니다"
# "parameter '%0' not in expected state when the function returns: expected '%1', observed '%2'"
H6EE5C60DD591: "함수 반환 시 파라미터 '%0'의 상태가 예상된 '%1'이 아닌 '%2'로 관측되었습니다."
# "parameter cannot be named '%select{global|unknown}0' while using 'lifetime_capture_by(%select{global|unknown}0)'"
H56545E5909EB: "lifetime_capture_by(%select{global|unknown}0)을 사용할 때 매개변수는 '%select{global|unknown}0'로 이름을 지을 수 없습니다."
# 'parameter declarator cannot be qualified'
HEB6B080E8792: '매개변수 선언자는 자격 증명을 가질 수 없습니다'
# 'parameter kind mismatch; parameter is %select{not a|a}0 parameter pack'
H53E71EC45244: '매개변수 유형 불일치; 매개변수는 %select{매개변수 패킹이 아닙니다|매개변수 패킹입니다}0'
# 'parameter may not be qualified with an address space'
HFB13BD25F7E6: '매개변수에는 주소 공간 자격을 지정할 수 없습니다'
# 'parameter name cannot have template arguments'
H4AE4E444760E: '매개변수 이름에는 template 인수가 올 수 없습니다'
# 'parameter named %0 is missing'
HE41EE5512047: '이름이 %0인 매개변수가 누락되었습니다'
# "parameter of %0 attribute must be 'id' when used on a typedef"
H95DFECC378EF: "typedef에서 %0 속성에 사용되는 매개변수는 'id'여야 합니다"
# 'parameter of %0 attribute must be a single name of an Objective-C %select{class|protocol}1'
H6E3911EE67CF: '%0 속성의 매개변수는 Objective-C %select{클래스|프로토콜}1의 단일 이름이어야 합니다'
# 'parameter of %0 cannot have a default argument'
H9997206462BD: '매개변수 %0에는 기본 인수가 있을 수 없습니다'
# "parameter of literal operator must have type 'unsigned long long', 'long double', 'char', 'wchar_t', 'char16_t', 'char32_t', or 'const char *'"
H18EF0BD0BEB6: "리터럴 연산자의 매개변수는 'unsigned long long', 'long double', 'char', 'wchar_t', 'char16_t', 'char32_t', 또는 'const char *' 중 하나의 타입을 가져야 합니다"
# 'parameter of overloaded %0 cannot have a default argument'
H31033CF29CE2: '오버로드된 %0의 매개변수에는 기본 인수가 있을 수 없습니다'
# "parameter of overloaded post-%select{increment|decrement}1 operator must have type 'int' (not %0)"
H42A579D6B7B0: "오버로드된 후위 %select{증가|감소}1 연산자의 매개변수는 'int' 형식이어야 합니다(현재 %0입니다)"
# 'parameter of overridden method is annotated with __attribute__((noescape))'
H1DC2A8B6BA41: '오버라이드된 메서드의 매개변수에 __attribute__((noescape)) 애노테이션이 지정되었습니다'
# 'parameter of overriding method should be annotated with __attribute__((noescape))'
HD9E0E2EF69AC: '오버라이딩 메서드의 매개변수는 __attribute__((noescape)) 어노테이션으로 지정되어야 합니다'
# "parameter of the 'collapse' clause"
H978C7D7597CF: '‘collapse’ 절의 매개변수'
# 'parameter of type %0 is declared here'
HB0D7D36BAAD5: '형식 %0의 매개변수는 여기서 선언되었습니다'
# 'parameter pack %0 declared here'
HF649CEA110D0: '매개변수 팩트 %0 여기서 선언되었습니다'
# 'parameter pack cannot have a default argument'
H220429408CBD: '매개변수 패킹에는 기본 인수가 있을 수 없습니다'
# 'parameter references not allowed in naked functions'
HE9A90AF8CF8F: 'naked 함수에서는 매개 변수 참조가 허용되지 않습니다'
# "parameterized class %0 already conforms to the protocols listed; did you forget a '*'?"
H0F239CE68A40: '템플릿 클래스 %0는 이미 지정된 프로토콜을 준수합니다; *를 빠트리지 않았나요?'
# 'parameters for defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator must have the same type%diff{ (found $ vs $)|}1,2'
H34C46A5FC53A: '기본값이 지정된 %select{<ERROR>|동일성|세방향|동일성|관계}0 비교 연산자의 매개변수는 동일한 타입을 가져야 합니다%diff{ ($ vs $를 발견함)|}1,2'
# "parent region for 'omp %select{cancellation point|cancel}0' construct cannot be nowait"
H10627ACFF3E1: 'OMP %select{cancellation point|cancel}0 지시어 구조의 부모 영역은 nowait일 수 없습니다'
# "parent region for 'omp %select{cancellation point|cancel}0' construct cannot be ordered"
H2F8AAD55F0CC: "상위 영역은 'omp %select{cancellation point|cancel}0' 구조가 정렬될 수 없습니다"
# "parent umbrella does not match: '%0' (provided) vs '%1' (found)"
H38C90C7CC02F: "상위 우산 디렉토리가 일치하지 않습니다: '%0' (제공된) vs '%1' (찾은)"
# "parent umbrella missing from %0: '%1'"
HCD77F7184E7F: "상위 우산 헤더가 %0에서 누락되었습니다: '%1'"
# 'parentheses are required around macro argument containing braced initializer list'
H41A73FF55953: '매크로 인자에 중괄호 초기화자 목록이 포함되면 괄호가 필요합니다'
# 'parentheses are required around this expression in a requires clause'
H8DF4B4E0E5BD: 'requires 절에서 이 표현 주위에 괄호가 필요합니다'
# 'parentheses around address non-type template argument are a C++11 extension'
H55DF42498A9B: '주소 비형식 템플릿 인자 주위의 괄호는 C++11 확장 기능입니다'
# 'parentheses around address non-type template argument are incompatible with C++98'
H8ACABCA7F85D: '주소 비타입 템플릿 인자 주위의 괄호는 C++98와 호환되지 않습니다'
# "parentheses must be omitted if %0 attribute's argument list is empty"
H90F4FD29334C: '%0 속성의 인자 목록이 비어 있으면 괄호를 생략해야 합니다'
# 'parentheses were disambiguated as a function declaration'
H329AE7B68E6C: '괄호가 함수 선언으로 해석되었습니다.'
# 'parentheses were disambiguated as redundant parentheses around declaration of variable named %0'
H911B6F6318F6: '괄호가 %0라는 이름의 변수 선언 주위의 중복 괄호로 이歧해가 해결되었습니다'
# 'parenthesize the second argument to silence'
HB3431A17CC77: '두 번째 인수를 괄호로 묶어 경고를 피하세요'
# 'parenthesized initialization of a member array is a GNU extension'
HD07F8AE496CA: '멤버 배열의 괄호로 감싼 초기화는 GNU 확장 기능입니다'
# 'parse the input, create a PFT, dump it, and exit'
H8632144C8313: '입력을 분석하고 PFT를 생성한 다음 덤프한 후 종료합니다'
# "parsing modulemap '%0'"
HAF9932C8E4DC: "모듈맵 '%0' 구문 분석"
# 'partial ordering for explicit instantiation of %0 is ambiguous'
HE38D1382AB5B: '명시적 인스턴스화 %0의 부분적 순서매김이 불분명합니다'
# 'partial specialization cannot be declared as a friend'
HA147DDFF5AB9: '부분 특수화는 친구로 선언될 수 없습니다'
# 'partial specialization matches %0'
HA30AC1C7D740: '부분 특수화가 %0와 일치합니다'
# 'partial specialization of %0 does not use any of its template parameters'
H84CBC790F3FB: '%0의 부분 전문화에서 템플릿 매개변수 중 하나도 사용되지 않았습니다'
# 'pass -fsafe-buffer-usage-suggestions to receive code hardening suggestions'
HB623B7D5D4C9: '옵션을 지정하여 코드 강화 제안을 받으려면 -fsafe-buffer-usage-suggestions를 전달하십시오.'
# 'passing %0-byte aligned argument to %1-byte aligned parameter %2%select{| of %4}3 may result in an unaligned pointer access'
H8E7373BFAB19: '%0바이트 맞춤 인수를 %1바이트 맞춤 매개변수 %2%select{|의 %4}3에 전달하면 비정렬 포인터 접근이 발생할 수 있습니다.'
# 'passing %select{address of|reference to}0 local temporary object to musttail function'
H185CAE78405D: '로컬 임시 객체의 %select{주소를|참조를}0 musttail 함수에 전달함'
# "passing %select{an object that undergoes default argument promotion|an object of reference type|a parameter declared with the 'register' keyword}0 to 'va_start' has undefined behavior"
H71043E0BAFE6: "'va_start'에 %select{디폴트 인자 승격을 받는 객체|참조 형식의 객체|'register' 키워드로 선언된 매개변수}0을 전달하는 것은 정의되지 않은 동작입니다"
# "passing '%0' format string where '%1' format string is expected"
HB0DCC631BCB0: "'%0' 포맷 문자열을 '%1' 포맷 문자열이 예상되는 곳에 전달했습니다"
# "passing a type argument as the first operand to '_Generic' is a C2y extension"
H9B0C1A1B2AAD: "'_Generic'의 첫 번째 연산자로 타입 인수를 전달하는 것은 C2y 확장 기능입니다"
# "passing a type argument as the first operand to '_Generic' is incompatible with C standards before C2y"
H0B03D58A8538: "'_Generic'의 첫 번째 인수로 타입 인수를 전달하는 것은 C2y 이전의 C 표준과 호환되지 않습니다"
# 'passing address of %select{non-local|non-scalar}0 object to __autoreleasing parameter for write-back'
H8F97A19F11B3: '%select{비로컬|비스칼라}0 객체의 주소를 __autoreleasing 매개변수에 전달하여 쓰기'
# 'passing argument to parameter %0 here'
H30E4C5FD05FE: '매개변수 %0에 인수를 여기서 전달 중입니다'
# 'passing argument to parameter here'
HC7C3DD07B432: '매개변수에 인수를 전달하는 위치입니다'
# 'passing arguments to %select{a function|%1}0 without a prototype is deprecated in all versions of C and is not supported in C23'
H192BBFFB4918: '프로토타입 없이 %select{a function|%1}0에 인수를 전달하는 것은 모든 C 버전에서 사용 중지되었으며 C23에서는 지원되지 않습니다'
# 'passing byval argument %0 with potentially incompatible alignment here'
H730F797EFCA9: '여기서 호환되지 않을 수 있는 정렬을 가진 byval 인수 %0를 전달합니다'
# "passing no argument for the '...' parameter of a variadic macro is a C++20 extension"
H6D5DB0C5BBB6: "가변 매크로의 '...' 매개변수에 인자를 전달하지 않는 것은 C++20 확장 기능입니다"
# "passing no argument for the '...' parameter of a variadic macro is a C23 extension"
H0F0C361742D6: "가변 인수 매크로의 '...' 매개변수에 인수를 전달하지 않는 것은 C23 확장 기능입니다."
# "passing no argument for the '...' parameter of a variadic macro is incompatible with C standards before C23"
HCA1A72FB669A: "가변 매크로의 '...' 매개변수에 인자를 전달하지 않으면 C23 이전의 C 표준과 호환되지 않습니다"
# "passing no argument for the '...' parameter of a variadic macro is incompatible with C++ standards before C++20"
H2B8F35860B3B: "가변 매크로의 '...' 매개변수에 인자를 전달하지 않는 것은 C++20 이전의 C++ 표준과 호환되지 않습니다"
# 'passing non-generic address space pointer to %0 may cause dynamic conversion affecting performance'
HAEF068C749A4: '일반적이지 않은 주소 공간 포인터를 %0에 전달하면 동적 변환이 발생해 성능에 영향을 줄 수 있습니다'
# "passing object of class type %0 through variadic %select{function|block|method|constructor}1%select{|; did you mean to call '%3'?}2"
H39C1EFFB876B: "클래스 형식 %0의 객체를 가변 %select{함수|블록|메소드|생성자}1%select{ |; '%3'를 호출하려는 건가요?}2을 통해 전달 중입니다"
# 'passing object of trivial but non-POD type %0 through variadic %select{function|block|method|constructor}1 is incompatible with C++98'
HD5D2FE67C0FC: 'trivial하지만 POD가 아닌 형식의 객체 %0를 가변 인자 %select{함수|블록|메서드|생성자}1을 통해 전달하는 것은 C++98과 호환되지 않습니다'
# "passing only one argument to 'va_start' is incompatible with C standards before C23"
H0DFF95F6ABB1: 'va_start에 단일 인자를 전달하는 것은 C23 이전의 C 표준과 호환되지 않습니다'
# "passing pointer %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
H9E268E19A549: "포인터 %1을 전달하려면 %0 %select{'%2'|'%2 전용으로}3를 획득해야 합니다"
# "passing pointer to variable %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
H0E1F82092409: "변수 %1에 대한 포인터를 전달하려면 %0 %select{'%2'|'%2' 전용으로}3를 보유해야 합니다"
# "passing the value that %1 points to by reference requires holding %0 %select{'%2'|'%2' exclusively}3"
HFB2B4F9A02B6: "%1이 가리키는 값에 대한 참조를 전달하려면 %0를 %select{'%2'|'%2 독점적으로'}3 유지해야 합니다"
# 'passing union across security boundary via %select{parameter %1|return value}0 may leak information'
HA1E50C08E561: '보안 경계를 넘어 유니온을 %select{매개변수 %1|리턴 값}0을 통해 전달하면 정보 누출이 발생할 수 있습니다'
# "passing variable %1 by reference requires holding %0 %select{'%2'|'%2' exclusively}3"
HB011E968C37B: "변수 %1을 참조로 전달하려면 %0 를 %select{'%2'|'%2 독점적으로'}3 유지해야 합니다"
# "pasting formed '%0', an invalid preprocessing token"
H17B929BA26C6: "붙이기로 형성된 '%0'는 유효하지 않은 사전처리 토큰입니다"
# "pasting two '/' tokens into a '//' comment is a Microsoft extension"
HBFF0AAF786C4: "두 개의 '/' 토큰을 '//' 주석에 붙여 넣는 것은 마이크로소프트 확장 기능입니다"
# 'path to a pass plugin for HIP to SPIR-V passes.'
HF42DFD9FA413: 'HIP에서 SPIR-V 패스를 위한 플러그인 경로를 지정합니다.'
# 'path to instrumented binary in case if /proc/self/map_files is not accessible due to access restriction issues'
H9C547FEDA325: '접근 제한 문제로 인해 /proc/self/map_files에 접근할 수 없는 경우에 사용할 인스트루먼테된 바이너리의 경로'
# 'pc tracing with a guard'
H66AAE93ED197: '가드를 사용한 프로그래밍 카운터 추적'
# 'perf2bolt - BOLT data aggregator\n\nEXAMPLE: perf2bolt -p=perf.data executable -o data.fdata\n'
H64C11174A75F: 'perf2bolt - BOLT 데이터 집계 도구\n\n예시: perf2bolt -p=perf.data executable -o data.fdata\n'
# 'perform FOP on all functions'
H2A14A47C13E8: '모든 함수에 대해 FOP 수행'
# 'perform FOP on hot functions'
H4C1838B87112: '핫 함수에 FOP 수행'
# 'perform ICP on calls and jump tables'
H58DE93FE6F76: '호출과 점프 테이블에 ICP를 수행합니다'
# 'perform ICP on indirect calls'
HBCFC7E630187: '간접 호출에 대해 ICP를 수행'
# 'perform ICP on jump tables'
HF431F48B1DC7: '점프 테이블에 대해 ICP 수행'
# 'perform layout optimizing I-cache behavior'
H978D4EED4690: 'I-cache 동작을 최적화하는 레이아웃 수행'
# 'perform optimal layout based on profile'
HC1766F39AC7E: '프로파일을 기반으로 최적의 레이아웃을 수행합니다'
# 'perform optimal layout prioritizing I-cache behavior'
HBDF007516F2C: 'I-캐시 동작을 우선으로 하는 최적 레이아웃 수행'
# 'perform optimal layout prioritizing branch predictions'
HB3E593E231FA: '가지치기 예측을 최우선으로 하는 최적의 레이아웃을 수행합니다'
# 'perform profiling accuracy-sensitive optimizations only if function execution count >= the threshold (default: 0)'
HFF64335273A6: '함수 실행 횟수가 임계값 이상인 경우에만 프로파일링 정확성에 민감한 최적화를 수행 (기본값: 0)'
# 'perform random layout of clusters'
H7C7C380E5354: '클러스터의 레이아웃을 무작위로 수행합니다'
# 'perform verification of LLVM instruction encoding/decoding. Every instruction in the input is decoded and re-encoded. If the resulting bytes do not match the input, a warning message is printed.'
H52D0672FF953: 'LLVM 명령어 인코딩/디코딩을 검증합니다. 입력의 모든 명령어를 디코딩하고 다시 인코딩합니다. 결과 바이트가 입력과 일치하지 않으면 경고 메시지가 출력됩니다.'
# 'performSelector may cause a leak because its selector is unknown'
H653C9447EE92: 'performSelector는 선택자가 알려지지 않아 메모리 누출을 일으킬 수 있습니다'
# 'performSelector names a selector which retains the object'
HF51E4C8347B0: 'performSelector는 객체를 보유하는 셀렉터를 지정합니다'
# 'performing pointer arithmetic on a null pointer has undefined behavior%select{| if the offset is nonzero}0'
HA288389E9F6A: '널 포인터에 포인터 산술을 수행하는 것은 정의되지 않은 동작입니다%select{| 오프셋이 0이 아닌 경우}0'
# 'performing pointer subtraction with a null pointer %select{has|may have}0 undefined behavior'
HB725A707608F: '널 포인터와 포인터 감산을 수행함: %select{가집니다|가질 수 있습니다}0 정의되지 않은 동작'
# 'performs disassembly sequentially'
HDD6DFBE032D2: '디셈블리를 순차적으로 수행합니다'
# 'permutation index must be at least 1 and at most %0'
H0297CCE3F38F: '순열 인덱스는 최소 1 이상이고 최대 %0 이하여야 합니다.'
# 'pick register allocator based on -O option'
H46CB03DD1B68: '레지스터 할당기를 -O 옵션에 따라 선택합니다'
# 'pipes packet types cannot be of reference type'
H354A6AC50D78: '파이프 패킷 타입은 참조 타입일 수 없습니다'
# "place '...' %select{immediately before declared identifier|here}0 to declare a function parameter pack"
HD82CBB258C12: "'...'을 %select{선언된 식별자 바로 앞에|여기에}0 위치시켜 함수 매개변수 패킹을 선언하십시오"
# 'place all array allocations more than <size> elements on the heap'
H7583F9BA4C9F: '요소 수가 <size>보다 큰 모든 배열 할당을 힙에 배치합니다'
# 'place all array allocations of dynamic size on the heap'
H1E67C0E84EC2: '동적 크기의 모든 배열 할당을 힙에 배치하십시오'
# 'place parentheses around comparison expression to evaluate it first'
H1021BF49A48F: '비교 표현식 주위에 괄호를 넣어 먼저 계산하십시오'
# 'place parentheses around the %0 expression to evaluate it first'
HD79F2195D659: '괄호를 %0 표현식 주위에 둘러서 먼저 평가하세요'
# 'place parentheses around the %quoted0 expression to silence this warning'
HFD7FB705EA72: '%quoted0 표현식에 괄호를 추가하여 이 경고를 무시할 수 있습니다'
# "place parentheses around the '?:' expression to evaluate it first"
H9605DB1A560A: "': 연산자를 괄호로 감싸 먼저 평가하세요"
# 'place parentheses around the assignment to silence this warning'
HE705E4D071BD: '이 경고를 제거하려면 할당에 괄호를 추가하세요.'
# 'place parentheses around the string literal to silence warning'
H876899527936: '문자열 리터럴 주위에 괄호를 추가하여 경고를 제거하세요'
# 'placeholder declared here'
H7E34AEC856E5: '여기에서 선언된 플레이스홀더'
# 'placeholder variables are a C++2c extension'
H4C0235C28642: '플레이스홀더 변수들은 C++2c 확장 기능입니다'
# 'placeholder variables are incompatible with C++ standards before C++2c'
H6BE10CEEDF1B: '플레이스홀더 변수는 C++2c 이전의 C++ 표준과 호환되지 않습니다'
# 'placement new would change type of storage from %0 to %1'
H83FB1C107237: 'placement new를 사용하면 저장 공간의 형식이 %0에서 %1로 변경됩니다'
# "plain '_Complex' requires a type specifier; assuming '_Complex double'"
HBC4E2F0D8FF6: "순 '_Complex'는 형식 지정자가 필요합니다; 기본값으로 '_Complex double'을 가정합니다"
# "platform does not match: '%0' (provided) vs '%1' (found)"
H5C64A2FB6312: "플랫폼이 일치하지 않습니다: '%0' (제공됨) vs '%1' (발견됨)"
# "please rebuild precompiled file '%0'"
HC5036CB84980: "사전 컴파일된 파일 '%0'을(를) 다시 빌드하십시오"
# 'plt'
H8B8091C3AD1A: '프로시저 링크지 테이블 (PLT)'
# 'pointer %0 declared here'
H22E4F3576FCE: '포인터 %0가 여기서 선언되었습니다'
# "pointer arguments to kernel functions must reside in '__global', '__constant' or '__local' address space"
HEE966568F6BF: "커널 함수의 포인터 인수는 반드시 '__global', '__constant' 또는 '__local' 주소 공간에 존재해야 합니다"
# 'pointer cannot be cast to type %0'
H0546695B4A22: '포인터는 %0 타입으로 캐스팅할 수 없습니다.'
# 'pointer cannot be mapped along with a section derived from itself'
HAF06E92DEBA3: '포인터는 자신으로부터 유래된 섹션과 함께 매핑될 수 없습니다'
# 'pointer comparisons before C11 need to be between two complete or two incomplete types; %0 is %select{|in}2complete and %1 is %select{|in}3complete'
H4DB22EDB67C8: 'C11 이전의 포인터 비교는 두 개의 완전한 형식 또는 두 개의 불완전한 형식 사이여야 합니다; %0는 %select{|in}2완전한 형식이고 %1는 %select{|in}3완전한 형식입니다'
# "pointer to function type %0 may not be 'restrict' qualified"
H909D3E85FCFF: "함수 타입 %0 포인터는 'restrict'로 지정될 수 없습니다"
# 'pointer to type %0 is invalid in OpenCL'
HEF9B07C9C640: '타입 %0의 포인터는 OpenCL에서 유효하지 않습니다'
# 'pointer type mismatch%diff{ ($ and $)|}0,1'
H8EAA8DFC686A: '포인터 타입 불일치%diff{ ($와 $)|}0,1'
# 'pointer-to-member function type %0 can only be called on an %select{rvalue|lvalue}1'
H08EA28E0562A: '포인터-투-멤버 함수 유형 %0은 오직 %select{rvalue|lvalue}1에만 호출될 수 있습니다'
# 'pointer/integer type mismatch in conditional expression%diff{ ($ and $)|}0,1'
HC15C6EF198BF: '조건 표현식에서 포인터/정수 형식 불일치%diff{ ($0 와 $1)|}0,1'
# 'poison on failure'
HE44AF8732393: '실패 시 독약 적용'
# 'poison undef temps'
H7A7B675BE411: '미정의 값이 포함된 임시 변수 중독'
# 'poison uninitialized stack variables'
H47518342CB8C: '초기화되지 않은 스택 변수를 중독 처리합니다'
# 'poison uninitialized stack variables with a call'
H429653491DDF: '초기화되지 않은 스택 변수에 호출을 사용하여 중독시키기'
# 'poison uninitialized stack variables with the given pattern'
H338B60F2873D: '지정된 패턴으로 초기화되지 않은 스택 변수를 오염시킵니다'
# 'poisoning existing macro'
HDD8F2D4A6FAB: '기존 매크로 무력화'
# 'position arguments in format strings start counting at 1 (not 0)'
HC64922328C30: '포맷 문자열의 위치 인수는 0이 아닌 1부터 시작합니다'
# "position-independent code requires '-mabicalls'"
H69FA922C5B49: "위치 독립 코드는 '-mabicalls' 옵션이 필요합니다"
# 'positional arguments are not supported by ISO C'
HE496161E3DDA: 'ISO C에서는 위치 인수가 지원되지 않습니다'
# 'possible misuse of comma operator here'
H0A8E98669706: '콤마 연산자를 오용했을可能性이 있습니다.'
# 'possible target for call'
H16BA315A6C23: '호출 대상 후보'
# 'possible target of %select{indirect|asm}0 goto statement'
H03DE80F51E17: '%select{간접|어셈블리}0 goto 문의 대상 후보'
# 'postfix attributes are not allowed on Objective-C directives'
HA57AC12B1C85: 'Objective-C 지시문에서 후위 속성은 허용되지 않습니다'
# "postfix attributes are not allowed on Objective-C directives, place them in front of '%select{@interface|@protocol}0'"
H83C11CD38B50: "Objective-C 지시자에 후위 속성은 허용되지 않습니다. '%select{@interface|@protocol}0' 앞에 배치해 주세요."
# 'potential performance regression from use of __builtin_expect(): annotation was correct on %0 of profiled executions'
HD6474E353C24: '__builtin_expect() 사용으로 인한 성능 퇴보 가능성: 프로파일링된 실행 횟수 중 %0에서 어노테이션이 정확했습니다'
# 'pp-trace options'
H87829B6B5E89: 'pp-trace 옵션'
# 'pragma %0 requires a parenthesized string'
H25DF715FB71D: 'pragma %0는 괄호로 감싸인 문자열이 필요합니다'
# 'pragma %select{message|warning|error}0 requires parenthesized string'
H58AE415DBC7A: 'pragma %select{message|warning|error}0는 괄호 안 문자열이 필요합니다'
# 'pragma STDC FENV_ROUND is not supported'
HF7A928CE98B4: 'pragma STDC FENV_ROUND는 지원되지 않습니다'
# 'pragma comment requires parenthesized identifier and optional string'
HD6BA08D64805: 'pragma comment는 괄호로 묶인 식별자와 선택적인 문자열이 필요합니다'
# 'pragma detect_mismatch is malformed; it requires two comma-separated string literals'
H82A7E617FBD6: 'pragma detect_mismatch는 잘못된 형식입니다; 두 개의 콤마로 구분된 문자열 리터럴이 필요합니다'
# "pragma diagnostic expected 'error', 'warning', 'ignored', 'fatal', 'push', or 'pop'"
HD2286608AABA: "pragma diagnostic은 'error', 'warning', 'ignored', 'fatal', 'push', 또는 '팝'을 기대합니다."
# 'pragma diagnostic expected option name (e.g. "-Wundef")'
HF5C6654FAE5F: 'pragma 진단 옵션 이름이 필요합니다 (예: -Wundef)'
# 'pragma diagnostic pop could not pop, no matching push'
H6F8E683545E5: 'pragma diagnostic pop 명령어를 실행할 수 없음: 매칭되는 push가 없습니다'
# "pragma float_control is malformed; use 'float_control({push|pop})' or 'float_control({precise|except}, {on|off} [,push])'"
HDD83603CAD05: "pragma float_control이 잘못된 형식입니다. 'float_control({push|pop})' 또는 'float_control({precise|except}, {on|off} [,push])'을 사용하십시오."
# "pragma include_alias expected '%0'"
H01DD8237CC21: "pragma include_alias에서 '%0'이 예상되었습니다."
# 'pragma include_alias expected include filename'
H08BDBEAABFC9: 'pragma include_alias include 파일 이름이 필요합니다'
# "pragma pop_macro could not pop '%0', no matching push_macro"
HF67398D54EBA: "pragma pop_macro가 '%0'을(를) pop할 수 없습니다, 대응하는 push_macro가 없습니다"
# "preceding '...' declares a function parameter pack"
HB271FF2CAE5F: "이전에 오는 '...'은 함수 매개변수 팩을 선언합니다"
# 'preceding bit-field %0 declared here with type %1'
H8E483BDFCE6F: '이전 비트 필드 %0이(가) 여기서 유형 %1으로 선언됨'
# 'precompiled'
H5B5680CDE56B: '미리 컴파일된'
# "precompiled file '%0' was compiled for the %1 '%2' but the current translation unit is being compiled for target '%3'"
H1980F89A839A: "사전 컴파일된 파일 '%0'은(는) %1 '%2'용으로 컴파일되었으나 현재 번역 단위는 대상 '%3'으로 컴파일 중입니다"
# "precompiled file '%0' was not built as a module"
H45336ACA964E: "사전 컴파일된 파일 '%0'은(는) 모듈로 빌드되지 않았습니다"
# "precompiled file '%2' was compiled with module cache path '%0', but the path is currently '%1'"
HD917C02B86F6: "사전 컴파일된 파일 '%2'는 모듈 캐시 경로 '%0'으로 컴파일되었으나 현재 경로는 '%1'입니다"
# "precompiled header '%0' was ignored because '%1' is not first '-include'"
H47051C658E08: "전처리된 헤더 '%0'는 '%1'이(가) 첫 번째 '-include' 옵션이 아니기 때문에 무시되었습니다"
# "precompiled header '%0' was ignored because it is not a clang PCH file"
HC110D52BBD02: "미리 컴파일된 헤더 '%0'는 clang PCH 파일이 아니기 때문에 무시되었습니다"
# "precompiled header directory '%0' was ignored because it contains no clang PCH files"
H3E91139CDF42: "사전 컴파일된 헤더 디렉토리 '%0'는 clang PCH 파일이 없기 때문에 무시되었습니다"
# 'predefined allocator cannot have traits specified'
H8666F51519BE: '미리 정의된 할당기는 특성을 지정할 수 없습니다'
# 'predefined identifier is only valid inside function'
HF82196FF10EA: '미리 정의된 식별자는 함수 내부에서만 유효합니다'
# "predefined trait '%0' used here"
H55566D31A8B9: "사전 정의된 속성 '%0' 여기서 사용됨"
# 'predetermined as a firstprivate in a task construct here'
H405D7D760401: '여기서 작업 구조에서 firstprivate로 미리 지정되었습니다'
# 'prefer tail-folding, create scalar epilogue if tail folding fails.'
HD0E4E0A8CB08: '테일 폴딩을 선호하며, 테일 폴딩이 실패할 경우 스칼라 에필로그를 생성합니다.'
# 'prefer update form when ds form is also a update form'
HEA9A1D5F496C: 'ds 형식이 또한 갱신 형식인 경우 갱신 형식을 선호하라'
# 'prefer_list item must be a string literal or constant integral expression'
HCAFE9C287B6C: 'prefer_list 항목은 문자열 리터럴 또는 상수 정수 표현식이어야 합니다'
# 'preferred type for bit-field %0 specified here'
H89CF4480AE9D: '비트 필드 %0에 대한 선호 유형이 여기에서 지정되었습니다'
# "prefers tail-folding, don't attempt vectorization if tail-folding fails."
H12E0DCDDA093: '꼬리 접기를 선호하며, 꼬리 접기가 실패하면 벡터화를 시도하지 않습니다.'
# 'prefix attribute must be followed by an interface, protocol, or implementation'
H129BA69DE7F2: 'prefix 속성은 인터페이스, 프로토콜 또는 구현이 뒤따라야 합니다'
# 'prefix with the address-of operator to silence this warning'
H51278B3A983C: '주소 연산자(&)로 접두사로 추가하여 이 경고를 무시하십시오'
# 'prepare update form when the load/store increment is a loop invariant non-const value.'
H7F0464394BFE: '로드/스토어 인크리먼트가 루프 불변 non-const 값일 때 업데이트 형식을 준비합니다.'
# 'preserve intermediate .o file'
HBCF9A92B45C8: '중간 .o 파일 유지'
# 'pretty-print DWARF debug information in object files and debug info archives.\n'
HFF4E6027BC6C: '객체 파일 및 디버그 정보 아카이브에서 DWARF 디버그 정보를 정리된 형식으로 출력합니다.\n'
# 'previous %select{template type|non-type template|template template}0 parameter%select{| pack}1 declared here'
HEDFC0D57E1AE: '이전 %select{템플릿 형식|비-형식 템플릿|템플릿 템플릿}0 매개변수%select{| 패키지}1 여기서 선언됨'
# 'previous %select{unmarked |}0overload of function is here'
HAE3E66A916BE: '함수의 이전 %select{표시되지 않은 |}0 오버로드가 여기 있습니다'
# "previous '#pragma pack' directive that modifies alignment is here"
H39F3F82E0571: "이전 '#pragma pack' 디렉티브가 정렬을 수정하는 부분은 여기에 있습니다"
# "previous '%0' clause is here"
HDC66D6DA5D75: "이전 '%0' 절이 여기에 있습니다"
# "previous '%0' directive used here"
HE7A8B08DD5DE: "이전 '%0' 지시문이 여기서 사용되었습니다"
# "previous 'critical' region starts here"
H3FBC82C6CFEF: "이전 'critical' 영역이 여기서 시작되었습니다"
# 'previous allocator is specified here'
H065261987D15: '이전 할당자가 여기서 지정되었습니다'
# 'previous attribute is here'
H6E32F6609895: '이전 속성이 여기에 있습니다'
# 'previous binding pack specified here'
H720F62C2E50B: '이전 binding pack이 여기서 지정되었습니다'
# 'previous call is here%select{; set to nil to indicate it cannot be called afterwards|}0'
HE8A56E8F5AF3: '이전 호출은 여기에 있습니다%select{; nil로 설정하여 이후에 호출할 수 없음을 표시하십시오|}0'
# 'previous case defined here'
H67B17B33B89D: '이전 case가 여기에서 정의되었습니다'
# 'previous clause with directive name modifier specified here'
H59743B40EF38: '이전 절에 여기서 지정된 디렉티브 이름 수정자'
# "previous command '%select{\\|@}0%1' (an alias of '\\%2') here"
HE969B475A653: "이전 명령어 '%select{\\|@}0%1' (\\%2의 별칭입니다) 여기에서"
# "previous command '%select{\\|@}0%1' here"
H5B43AF8F451D: "이전 명령문 '%select{\\|@}0%1' 여기에 있습니다"
# 'previous declaration is here'
H9CAB5B6B1715: '이전 선언은 여기에 있습니다'
# 'previous declaration of class template partial specialization %0 is here'
H8EF5BDE072C8: '이전 클래스 템플릿 부분 특수화 %0의 선언은 여기 있습니다'
# 'previous declaration of variable template partial specialization is here'
H5A936ED6E7F5: '변수 템플릿 부분 특수화의 이전 선언은 여기에 있습니다'
# 'previous default generic association is here'
H5A119A508D2B: '이전 기본 제네릭 연관이 여기에 있습니다'
# 'previous default template argument defined here'
H828BBDD8C7F9: '이전 기본 템플릿 인수가 여기서 정의되었습니다'
# 'previous default template argument defined in module %0'
H2F92B57F5F02: '이전 모듈 %0에서 정의된 기본 템플릿 인수'
# 'previous definition is here'
H0AC845A11A85: '이전 정의는 여기에 있습니다'
# 'previous documentation'
H8053B03861AE: '이전 문서'
# 'previous equal key is here'
H916F7D758598: '이전 동일한 키가 여기 있습니다'
# 'previous explicit instantiation is here'
HCA86CACA9800: '이전의 명시적 인스턴스화는 여기에 있습니다'
# 'previous expression is here'
H72EA4DC42083: '이전 표현식은 여기에 있습니다'
# 'previous implicit declaration is here'
H2F8B22E01C4A: '이전 암묵적 선언은 여기에 있습니다'
# 'previous inheritance model specified here'
HDD10F14D9687: '이 위치에서 이전 상속 모델이 지정되었습니다'
# 'previous initialization %select{|with side effects }0is here%select{| (side effects will not occur at run time)}0'
HFE059F4FA2A1: '이전 초기화 %select{|부작용이 있는 }0여기 있습니다%select{| (실행 시 부작용이 발생하지 않습니다)}0'
# 'previous initialization for field %0 is here'
HEF0E98EA391B: '필드 %0의 이전 초기화는 여기에 있습니다'
# 'previous module declaration is here'
HD052ACC784A7: '이전 모듈 선언은 여기에 있습니다'
# 'previous non-type template parameter with type %0 is here'
H5A88D83E2220: '이전의 유형 %0인 non-type 템플릿 매개변수가 여기 있습니다'
# 'previous reference is here'
HEFAE6804D795: '이전 참조 위치입니다'
# 'previous return statement is here'
H147041BC8FB0: '이전 반환 문은 여기에 있습니다'
# 'previous statement is here'
H94AB14DFE365: '이전 문은 여기에 있습니다'
# 'previous template %select{declaration|template parameter}0 is here'
H94CA97347769: '이전 템플릿 %select{선언|템플릿 매개변수}0는 여기 있습니다'
# 'previous template specialization is here'
H0FDA24AE451B: '이전 템플릿 특수화는 여기에 있습니다'
# 'previous use is here'
H39A31F8B143F: '이전 사용은 여기에 있습니다'
# 'previous uuid specified here'
H8206D7044433: '초기화자 요소가 집합 유형과 호환되지 않습니다'
# "previously declared '%0' here"
H4ECE9D2CF70E: "이전에 여기에서 '%0'로 선언됨"
# "previously declared '%1' here"
H6BFF38DE7EEF: "이전에 '%1' 여기서 선언되었습니다"
# 'previously declared as %0 here'
HEA5BCF07D9E2: '이전에 여기에서 %0로 선언되었습니다'
# 'previously defined as an alias for %0'
HC8CE8DE52E3E: '이전에 %0의 별칭으로 정의되었습니다.'
# 'previously defined here'
H0787B53F4571: '이미 여기서 정의되었습니다'
# 'previously marked as task_reduction with different reduction operation'
HFE3CA309C947: '이전에 다른 축소 연산을 가진 task_reduction으로 지정되었습니다'
# 'previously referenced here'
H8ADE478F0E44: '이전에 여기서 참조되었습니다'
# 'primary property declaration is implicitly strong while redeclaration in class extension is weak'
H331A66416F47: '주 프로퍼티 선언은 암묵적으로 strong이지만 클래스 확장에서의 재선언은 weak입니다'
# 'print ORC unwind information for instructions'
H4E31B5E474E7: '명령문에 대한 ORC 언윈드 정보 출력'
# 'print aliases when printing objects'
HF92219983E87: '객체를 출력할 때 별칭을 출력합니다'
# 'print all SDT markers'
H98709AE1B551: '모든 SDT 마커를 출력합니다'
# 'print all proposals received and whether they were rejected or accepted'
H04A22263A041: 'print 수신된 모든 제안서와 그들이 거부되었는지 승인되었는지 여부를 출력합니다'
# 'print all registered sections'
H8FAB43011447: '등록된 모든 섹션 출력'
# 'print clusters'
H9B37594EE600: '클러스터를 출력합니다'
# 'print debug info when printing functions'
HFF8256E364B3: '함수를 출력할 때 디버그 정보를 출력합니다'
# 'print dyno stats after each stage'
H9275B8D7E627: '각 단계별로 dyno 통계를 출력합니다'
# 'print everything - most verbose'
H1BEA0BEF5E2F: '모든 내용 출력 - 가장 상세한'
# 'print exception handling data'
H8F7DF5B5AC2D: '예외 처리 데이터 출력'
# 'print execution info based on profile'
H93C84C9D44B9: '프로파일에 기반한 실행 정보를 출력'
# 'print function after CFG is finalized'
H87F7D6E5ADA5: 'CFG가 최종화된 후 함수를 출력'
# 'print function after disassembly'
H6524D80C8BFA: '디어셈블리 후 함수 출력'
# 'print function after edge counts are set for no-LBR profile'
H3061E9C9E191: '엣지 카운트가 설정된 후 LBR을 사용하지 않는 프로파일에 대한 함수 출력'
# 'print function after fixing local branches'
H1402AC66D1C0: '로컬 브랜치 수정 후 프린트 함수 출력'
# 'print function after instruction lowering'
H612727DB3C18: '인스트럭션 낮추기 이후 프린트 함수 출력'
# 'print function after jt-footprint-reduction pass'
HDF747925B28E: 'jt-footprint-reduction 패스 후 함수 출력'
# 'print functions after ADR Relaxation pass'
H380909F95FC6: 'ADR Relaxation 패스 후의 함수 출력'
# 'print functions after CFG construction'
HCF99E2AF5C10: 'CFG 구조체 생성 후 함수 출력'
# 'print functions after CFG is normalized'
H52A0761BF0A3: '정규화된 CFG 이후에 함수를 출력합니다'
# 'print functions after ICF optimization'
H0BC917F969E4: 'ICF 최적화 후의 함수 출력'
# 'print functions after PLT optimization'
HF2CB032C6433: 'PLT 최적화 후 함수 출력'
# 'print functions after attaching profile'
HD8A5C41FAD15: '프로파일을 연결한 후의 함수를 출력합니다'
# 'print functions after bodyless optimization'
HBA38B0532A13: '본체 없는 최적화 이후 print 함수 출력'
# 'print functions after clustering'
H867D3C181C5B: '클러스터링 후 함수 출력'
# 'print functions after code splitting'
HFFE83E7C36B6: '코드 분할 후에 함수를 출력합니다'
# 'print functions after conditional tail call simplification'
H0EFD18F8B1CE: '조건부 테일 콜 간소화 이후에 함수 출력'
# 'print functions after each stage'
H6F2DBD4C3BE5: '각 단계 후에 함수 출력'
# 'print functions after fix RISCV calls pass'
HA11DE9F7CABB: 'RISCV 호출 패스 수정 후에 함수 출력'
# 'print functions after fix relaxations pass'
H9A6C75CABE6B: 'fix relaxations 패스 이후의 함수 출력'
# 'print functions after frame optimizer pass'
H37293007159E: '프레임 최적화 패스 후 함수 출력'
# 'print functions after indirect call promotion'
H6777ED6D8688: '간접 호출 프로모션 이후에 있는 함수들을 출력'
# 'print functions after inlining optimization'
H849DB929CE9A: '인라인 최적화 후의 함수 출력'
# 'print functions after layout optimization'
H1EAABA34176F: '레이아웃 최적화 후 함수 출력'
# 'print functions after longjmp pass'
H2C02F65E2B10: 'longjmp 패스 이후에 있는 함수 출력'
# 'print functions after peephole optimization'
HF6F27EE243F4: '피치홀 최적화 후 함수 출력'
# 'print functions after regreassign pass'
H205E59625248: 'regreassign 패스 후 함수 출력'
# 'print functions after retpoline insertion pass'
H348587451657: 'retpoline 삽입 패스 후에 함수 출력'
# 'print functions after simplification of RO data loads'
HA796FD5DA60B: 'RO 데이터 로드 간소화 후 함수 출력'
# 'print functions after stoke analysis'
H090E8674EC1A: '스토크 분석 후 함수 출력'
# 'print functions after unreachable code elimination'
HC31930E74334: '도달할 수 없는 코드 제거 후 함수 출력'
# 'print functions after veneer elimination pass'
HD9F864AE57D7: '비네어 제거 패스 후 함수 출력'
# 'print functions of binary 2 that were not matched to any function in binary 1'
H74494F9D492B: '2번 이진 파일의 함수 중에서 1번 이진 파일의 어떤 함수와도 매칭되지 않은 함수들을 출력합니다'
# 'print functions sorted by execution count'
HB0992E5F3DD7: '실행 횟수로 정렬된 함수들을 출력합니다'
# 'print functions sorted by order of dyno stats'
H0A27E3FA15F0: 'dyno 통계 순서대로 정렬된 함수 출력'
# 'print functions sorted by total branch count'
H58EE9BACA77C: '전체 브랜치 수에 따라 정렬된 함수들을 출력합니다'
# 'print functions that could not be overwritten due to excessive size'
H64A4A3141F70: '과도한 크기로 인해 덮어쓰지 못한 함수들을 출력'
# 'print functions that have profile in binary 1 but do not in binary 2'
H8FB878E6408D: 'print 바이너리 1에 프로필이 있지만 바이너리 2에는 없는 함수들'
# 'print global symbols after disassembly'
H6F71EE919FF4: '디셈블리 후 글로벌 심볼 출력'
# 'print heatmap to a given file'
HF4CFE90F13C4: '히트맵을 지정된 파일에 출력'
# 'print jump tables'
HE7814FCDE82F: '점프 테이블 출력'
# 'print loop related information'
H1CC87F1B29B5: '루프 관련 정보 출력'
# 'print mappings in the legend, between characters/blocks and text sections (default false)'
HAB49FA127C23: '범례에 문자/블록과 텍스트 섹션 간의 매핑을 출력합니다 (기본값: false)'
# 'print memory data annotations when printing functions'
HE37470A2DD9C: '함수를 출력할 때 메모리 데이터 어노테이션을 출력합니다'
# 'print names of functions with unknown control flow'
H02687E68D720: '알 수 없는 제어 흐름을 가진 함수의 이름을 출력합니다'
# 'print no details'
HE1459B6CBBDF: '상세 내용을 출력하지 않음'
# 'print out instructions with default strict semantics i.e.,check that all the inputs are fully initialized, and mark the output as fully initialized. These semantics are applied to instructions that could not be handled explicitly nor heuristically.'
H49408DBFABD2: '기본 엄격한 의미 체계(즉, 모든 입력이 완전히 초기화되었는지 확인하고 출력을 완전히 초기화된 것으로 표시함)로 명령어를 출력합니다. 이러한 의미 체계는 명시적으로나 휴리스틱하게 처리할 수 없는 명령어에 적용됩니다.'
# 'print output address range for each basic block in the function whenBinaryFunction::print is called'
H4D2F05339EF5: '함수 내 각 기본 블록에 대한 출력 주소 범위를 whenBinaryFunction::print가 호출될 때 출력'
# "print pass arguments to pass to 'opt'"
H6E943315CBC7: "패스 인수를 'opt'에 전달하여 출력합니다"
# 'print pass details when it is executed'
H76B02F3EE5E5: '실행 시 패스 세부 정보를 출력'
# 'print pass name before it is executed'
H741AF7A7B7D4: '패스 이름을 실행하기 전에 출력합니다'
# 'print pass structure before run()'
HF0D6992C747F: '실행 전 패스 구조를 출력합니다'
# 'print per instruction opcode dyno stats and the functionnames:BB offsets of the nth highest execution counts'
HED6C36296EF9: '명령어별 오피코드 동적 통계와 n번째로 높은 실행 횟수의 함수명:BB 오프셋을 출력합니다'
# 'print profile quality/bias analysis'
H2BA901542885: '프로파일 품질/편향 분석 출력'
# 'print pseudo probe info'
H497835ACD698: '가짜 프로브 정보 출력'
# 'print regions in detail with block_iterator'
HC53F268C8D37: '블록_이터레이터를 사용하여 지역을 상세하게 출력합니다'
# 'print regions in detail with element_iterator'
HEED2CD6BB906: '상세한 영역을 element_iterator를 사용하여 출력'
# 'print register usage details collected for analysis.'
H852E76ABE034: '분석을 위해 수집된 레지스터 사용 세부 정보를 출력합니다.'
# 'print relocations when printing functions/objects'
HC7882ECBD016: '함수/객체를 출력할 때 재정의를 출력합니다'
# 'print section contents after reordering'
HBFCEFB46E060: '재정렬 후 섹션 내용 출력'
# 'print statistics about basic block ordering'
HD0B0C3B01A36: '기본 블록 순서에 대한 통계 정보 출력'
# 'print the CFG of important functions that changed in binary 2'
H50C9F66DBC43: '바이너리 2에서 변경된 중요한 함수의 CFG를 출력합니다'
# 'print the basic blocks showed in top differences'
H1DA154B840C3: '상위 차이에서 표시된 기본 블록을 출력합니다'
# 'print the list of functions with stale profile'
HE912214BA092: '과시기적 프로파일을 가진 함수 목록을 출력합니다'
# 'print the list of objects with count to stderr'
H2C756772AFAF: 'stderr로 개수와 함께 객체 목록을 출력합니다'
# 'print time spent constructing binary functions'
H5978E6E15455: '이진 함수 생성에 소요된 시간을 출력'
# 'print time spent in each optimization'
H0BBB239D4108: '각 최적화 단계에서 소요된 시간을 출력합니다'
# 'print time spent in rewriting passes'
H40857EC64F6B: '리라이팅 패스에서 소요된 시간 출력'
# 'print top <uint> functions with suboptimal code layout on input'
HBFD8DED23E2E: '입력 시 최적화되지 않은 코드 레이아웃을 가진 상위 <uint>개 함수를 출력'
# 'printing of statistics for each inlined function'
HCEA14F1643A5: '각 인라인된 함수에 대한 통계 정보 출력'
# 'prints out offsets for abbrev and debug_info of Skeleton CUs that get patched.'
H71912C66C3FC: '패치되는 Skeleton CUs의 abbrev 및 debug_info에 대한 오프셋을 출력합니다.'
# 'prioritize low virtual register numbers for test and debug'
H0A6C1C201BCE: '테스트와 디버깅을 위해 낮은 가상 레지스터 번호를 우선시합니다'
# "private API notes file for module '%0' should be named '%0_private.apinotes', not '%1'"
HB68113D2F79A: "모듈 '%0'의 private API 노트 파일은 '%0_private.apinotes'로 이름을 지어야 합니다. '%1'이(가) 아닙니다"
# 'private field %0 is not used'
H3584A3B50C2A: '사용되지 않은 private 필드 %0'
# 'private module fragment begins here'
H3A617A73B3A6: 'private module fragment begins here'
# 'private module fragment declaration with no preceding module declaration'
H1202B7565A2E: 'private 모듈 프래그먼트 선언에 이전 모듈 선언이 없습니다'
# 'private module fragment in module implementation unit'
H48CE0D8A14BD: '모듈 구현 단위 내의 private 모듈 프래그먼트'
# 'private module fragment redefined'
H1427CFAECC58: '비공개 모듈 조각이 재정의되었습니다'
# "private submodule '%0' in private module map, expected top-level module"
HCB6CC643EA83: "비공개 모듈 맵 내의 비공개 서브모듈 '%0', 최상위 모듈이 예상되었습니다"
# 'probability argument to __builtin_expect_with_probability is outside the range [0.0, 1.0]'
HFB32BCF3AB99: '확률 인수가 __builtin_expect_with_probability의 [0.0, 1.0] 범위를 벗어났습니다'
# 'probability argument to __builtin_expect_with_probability must be constant floating-point expression'
H828E266CB5B1: "함수 '__builtin_expect_with_probability'의 확률 인수는 상수 부동소수점 표현식이어야 합니다"
# 'process functions with stack pointer arithmetic'
H56D80573022C: '스택 포인터 산술을 사용하는 함수 처리'
# 'profile data may be incomplete: of %0 function%s0, %1 %plural{1:has|:have}1 no data'
H8ACA9571B75F: '프로필 데이터가 불완전할 수 있습니다: %0 함수%s0 중 %1개는 %plural{1:데이터가|:데이터가}1 없습니다'
# 'profile data may be out of date: of %0 function%s0, %1 %plural{1:has|:have}1 mismatched data that will be ignored'
HBED3698588C8: '프로파일 데이터가 오래되었습니다: %0 함수%s0 중 %1 %plural{1:개의|:개의}1 데이터가 일치하지 않아 무시됩니다'
# 'propagate shadow through ICmpEQ and ICmpNE'
HB09C108C7674: 'ICmpEQ와 ICmpNE를 통해 그림자를 전파'
# 'propagating dll attribute to %select{already instantiated|explicitly specialized}0 base class template without dll attribute is not supported'
H6A4E6175A865: 'DLL 속성을 갖지 않은 %select{이미 인스턴스화된|명시적으로 특수화된}0 기본 클래스 템플릿에 DLL 속성을 전파하는 것은 지원되지 않습니다'
# 'property %0 attempting to use instance variable %1 declared in super class %2'
HDDED40707D8D: '프로퍼티 %0가 상위 클래스 %2에서 선언된 인스턴스 변수 %1를 사용하려 함'
# 'property %0 cannot be found in forward class object %1'
H503270AA1975: 'property %0는 forward class 객체 %1에서 찾을 수 없습니다'
# 'property %0 declared with incompatible types in different translation units (%1 vs. %2)'
H2F559B93D7CB: '%0 프로퍼티가 다른 번역 단위에서 호환되지 않는 유형으로 선언되었습니다 (%1 vs. %2)'
# 'property %0 found on object of type %1; did you mean to access it with the "." operator?'
H0A371D1A94C3: "객체 유형 %1의 프로퍼티 %0가 발견되었습니다; '.' 연산자를 사용하여 접근했어야 하지 않았나요?"
# 'property %0 has a variably modified type'
H81C9932A69B3: '속성 %0는 가변 길이 형식을 가집니다'
# "property %0 is a class property; did you mean to access it with class '%1'?"
HFC5FD97AFD4C: "프로퍼티 %0는 클래스 프로퍼티입니다. 클래스 '%1'을(를) 사용하여 접근하려는 의도였나요?"
# 'property %0 is already implemented'
H4ECC248CA95F: '속성 %0는 이미 구현되었습니다'
# 'property %0 is declared %select{deprecated|unavailable|partial}1 here'
HC2D276377832: '속성 %0는 여기서 %select{비추천됨|사용 불가능|부분적}1로 선언되었습니다.'
# 'property %0 is implemented with %select{@synthesize|@dynamic}1 here'
H43FFE47B4C6F: '속성 %0는 여기서 %select{@synthesize|@dynamic}1을 통해 구현되었습니다'
# 'property %0 is implemented with %select{@synthesize|@dynamic}1 in one translation but %select{@dynamic|@synthesize}1 in another translation unit'
H7C85E91BA02D: '속성 %0는 한 번역 단위에서는 %select{@synthesize|@dynamic}1로 구현되었지만 다른 번역 단위에서는 %select{@dynamic|@synthesize}1로 구현되었습니다'
# 'property %0 is synthesized to different ivars in different translation units (%1 vs. %2)'
HE49921A78EC2: '프로퍼티 %0는 다른 번역 단위에서 서로 다른 인스턴스 변수로 합성되었습니다 (%1 vs. %2)'
# 'property %0 not found on object of type %1'
H2822C5946CF1: '속성 %0는 유형 %1의 객체에 없습니다'
# 'property %0 not found on object of type %1; did you mean %2?'
HBDBDE3E27B96: '속성 %0가 %1 형식의 객체에 존재하지 않습니다; %2 의도하셨나요?'
# 'property %0 not found on object of type %1; did you mean to access instance variable %2?'
H8C5C6406F710: '속성 %0는 유형 %1의 객체에 존재하지 않습니다; 인스턴스 변수 %2에 접근하려는 의도는 없으신가요?'
# 'property %0 not found on object of type %1; did you mean to access property %2?'
H9C85D93EEE02: '프로퍼티 %0는 %1 형식의 객체에 없습니다; %2 프로퍼티에 접근하시려는 건가요?'
# 'property %0 refers to an incomplete Objective-C class %1 (with no @interface available)'
H5BDCDB941EFA: '속성 %0는 완성되지 않은 Objective-C 클래스 %1(사용 가능한 @interface가 없습니다)를 참조합니다'
# 'property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this category'
HD9354003F0AB: '프로퍼티 %0는 메소드 %1가 정의되어야 합니다 - @dynamic을 사용하거나 이 카테고리에서 메소드 구현을 제공하십시오'
# 'property %0 requires method %1 to be defined - use @synthesize, @dynamic or provide a method implementation in this class implementation'
HD343415F7FA6: '프로퍼티 %0는 메소드 %1를 정의해야 합니다 - @synthesize, @dynamic을 사용하거나 이 클래스 구현에서 메소드 구현을 제공하세요'
# "property %select{of type %1|with attribute '%1'|without attribute '%1'|with getter %1|with setter %1}0 was selected for synthesis"
HAD70544BC938: "속성 %select{타입 %1인|특성 '%1'을 갖는|특성 '%1'을 갖지 않는|getter %1을 갖는|setter %1을 갖는}0이(가) 합성에 선택되었습니다"
# 'property access is using %0 method which is deprecated'
HC446F861F2EE: '프로퍼티 접근은 비추천된 %0 메서드를 사용하고 있습니다'
# 'property access is using %0 method which is unavailable'
H61B587B99038: '프로퍼티 접근은 사용할 수 없는 %0 메서드를 사용하고 있습니다'
# 'property access result unused - getters should not be used for side effects'
H1D3B4CAFB27A: '속성 접근 결과가 사용되지 않음 - 접근자(getter)는 부작용을 위해 사용되지 않아야 함'
# 'property attribute in class extension does not match the primary class'
H928CE0C5C480: '클래스 확장에서의 프로퍼티 속성이 주 클래스와 일치하지 않습니다.'
# "property attributes '%0' and '%1' are mutually exclusive"
H4A7BE0C59F5F: "속성 '%0'과 '%1'은 호환되지 않습니다"
# 'property cannot have array or function type %0'
HE68B6C09E364: '속성은 배열 또는 함수 타입을 가질 수 없습니다. %0'
# 'property declaration cannot have a default member initializer'
H5272D8E5D57E: '속성 선언은 default member initializer를 가질 수 없습니다'
# "property declaration specifies '%0' accessor twice"
H0E68E4E4BA05: "속성 선언에서 '%0' 액세서를 두 번 지정했습니다"
# 'property declared as returning non-retained objects; getter returning retained objects'
H53034807D818: '속성이 non-retained 객체 반환으로 선언되었습니다; getter는 retained 객체를 반환합니다'
# 'property declared here'
H69D70856EBD1: '여기서 선언된 속성'
# 'property declared in category %0 cannot be implemented in class implementation'
H04FE1B1065E1: '카테고리 %0에서 선언된 프로퍼티는 클래스 구현에서 구현할 수 없습니다.'
# 'property does not specify a getter or a putter'
HD0F5818FB6C8: '프로퍼티에 게터 또는 풋터가 지정되지 않았습니다'
# "property follows Cocoa naming convention for returning 'owned' objects"
HEBB6CB98CE86: "property는 '소유된' 객체를 반환하는 Cocoa 네이밍 컨벤션을 따릅니다"
# 'property has a previous declaration'
H28BB0E9D9F7A: 'property는 이전에 선언되었습니다.'
# 'property implementation in a category with no category declaration'
HF42022DEA14A: '카테고리 선언이 없는 카테고리 내에서의 프로퍼티 구현'
# 'property implementation must be in a class or category implementation'
HD59CD2B75162: '프로퍼티 구현은 클래스나 카테고리 구현体内에 있어야 합니다'
# 'property implementation must have its declaration in interface %0 or one of its extensions'
HFCF842D4EB86: '프로퍼티 구현은 인터페이스 %0 또는 그 확장 중 하나에 선언이 있어야 합니다'
# 'property implementation must have its declaration in the category %0'
H761B0BB38838: 'property 구현은 해당 선언을 반드시 카테고리 %0에 포함해야 합니다.'
# 'property is assumed atomic by default'
H2882A0CD4FD8: 'property는 기본적으로 atomic으로 간주됩니다'
# 'property is assumed atomic when auto-synthesizing the property'
HC5E58A6AB217: '프로퍼티가 자동 생성될 때 해당 프로퍼티는 원자적이라고 가정됩니다'
# 'property is synthesized to ivar %0 here'
H7E91E310D399: 'property는 여기서 ivar %0로 합성되었습니다'
# 'property name cannot be a bit-field'
H8E1C0549C2E5: '프로퍼티 이름은 비트 필드일 수 없습니다'
# 'property requires fields to be named'
H9C4AAD2700BB: '속성은 필드에 이름이 지정되어야 합니다'
# 'property should be changed to be readwrite'
H32DF2D479322: '프로퍼티는 읽기/쓰기 가능으로 변경해야 합니다.'
# 'property synthesized here'
H0BB379E6C96C: '이 위치에서 속성이 합성되었습니다.'
# 'property type %0 is incompatible with type %1 inherited from %2'
HDE3695134102: '속성 유형 %0은 %2에서 상속받은 %1 유형과 호환되지 않습니다'
# "property with '%0' attribute must be of object type"
H44EF18C35C26: '‘%0’ 속성을 가진 프로퍼티는 객체 형식이어야 합니다'
# 'protected %select{constructor|destructor}0 can only be used to %select{construct|destroy}0 a base class subobject'
H8490EFD629C0: 'protected %select{생성자|소멸자}0은 기반 클래스 서브 오브젝트를 %select{생성|소멸}0하는 데에만 사용될 수 있습니다'
# 'protocol %0 has no definition'
H3F201B2D647A: '프로토콜 "%0"에는 정의가 없습니다'
# 'protocol has circular dependency'
HBFCB55FB9C5B: '프로토콜이 순환 의존성을 가집니다'
# "protocol has no object type specified; defaults to qualified 'id'"
H79AE64D3788F: "프로토콜에 객체 유형이 지정되지 않았습니다; 기본값은 자격 증명된 'id'입니다"
# 'protocol is declared here'
H63C66770E070: '프로토콜은 여기에 선언되었습니다'
# 'protocol method is expected to return an instance of the implementing class, but is declared to return %0'
HCECBCE2ED619: '프로토콜 메서드는 구현 클래스의 인스턴스를 반환해야 하지만, %0를 반환한다고 선언되었습니다'
# 'protocol method is here'
H850DBE7D30DB: '프로토콜 메소드가 여기에 있습니다'
# 'protocol qualifiers must precede type arguments'
HE1585F9267E6: '프로토콜 수식자는 타입 인수보다 앞에 와야 합니다.'
# "provided host compiler IR file '%0' is required to generate code for OpenMP target regions but cannot be found"
H4ECB10C5BABB: "제공된 호스트 컴파일러 IR 파일 '%0'은 OpenMP 대상 영역을 위한 코드를 생성하기 위해 필요하지만 찾을 수 없습니다"
# 'pseudo-destructor call is not permitted in constant expressions until C++20'
HFC660C022DFD: '가짜 소멸자 호출은 C++20까지 상수 표현식에서 허용되지 않습니다'
# 'pseudo-destructor destroys object of type %0 with inconsistently-qualified type %1'
HFC3306882505: '의사 소멸자가 일관되지 않은 자격 증명 형식 %1로 %0 형식의 객체를 파괴합니다'
# 'pseudo-destructors on type void are a Microsoft extension'
H6C76EC18D3A0: 'void 유형에 대한 의사소멸자는 마이크로소프트 확장 기능입니다'
# "public framework header includes private framework header '%0'"
H7F0AEF01704E: "공개 프레임워크 헤더가 비공개 프레임워크 헤더 '%0'를 포함합니다"
# 'pure virtual function %q0 called'
H3187DE144A64: '순수 가상 함수 %q0가 호출되었습니다'
# 'put the semicolon on a separate line to silence this warning'
HD2A85AED0A2F: '세미콜론을 별도의 줄에 넣어 이 경고를 없애세요'
# "putter for property must be specified as 'put', not 'set'"
H65FA70517FA4: "속성의 putter는 'set'이 아닌 'put'로 지정해야 합니다"
# 'qualified call to %0::%1 is treated as a virtual call to %1 due to -fapple-kext'
HAEBB9D60FCD1: '격자를 사용한 %0::%1 호출은 -fapple-kext 옵션 때문에 %1의 가상 호출로 처리됩니다'
# 'qualified destructor name only found in lexical scope; omit the qualifier to find this type name by unqualified lookup'
H95040EDE1833: '격이 붙은 소멸자 이름은 문법적 범위에서만 찾을 수 있습니다; 비격정 검색을 통해 이 타입 이름을 찾으려면 격자를 생략하십시오.'
# 'qualified member access refers to a member in %0'
H69C8244E4885: '정격화된 멤버 접근은 %0의 멤버를 참조합니다'
# 'qualified module name can only be used to define modules at the top level'
HCDFABF1A81DD: '자격화된 모듈 이름은 상위 레벨에서 모듈을 정의할 때만 사용할 수 있습니다'
# 'qualified name refers into a specialization of %select{function|variable}0 template %1'
H4C7D694E4A70: '격식을 갖춘 이름이 %select{함수|변수}0 템플릿 %1의 특수화에 들어갑니다'
# 'qualified reference to %0 is a constructor name rather than a %select{template name|type}1 in this context'
H08AE31B94F15: '이 맥락에서 %0의 격자 지정된 참조는 %select{템플릿 이름|형식}1이 아닌 생성자 이름입니다'
# "qualifier 'const' is needed for variables in address space '%0'"
HADB69D493623: "주소 공간 '%0'의 변수에는 'const' 지정자가 필요합니다"
# 'qualifier in explicit instantiation of %q0 requires a template-id (a typedef is not permitted)'
HB21409C3C5FB: '명시적 인스턴스화에서 %q0의 자격 증명은 템플릿 ID가 필요합니다 (typedef는 허용되지 않습니다)'
# 'qualifiers after comma in declarator list are ignored'
H09D49C9D12E0: '선언자 목록의 콤마 다음에 온 수정자는 무시됩니다'
# 'qualify call to silence this warning'
HDB3D8B807347: '이 경고를 제거하기 위해 호출을 자격 증명하십시오.'
# 'r11 available before calls and jumps'
H69431C8A884E: 'r11은 호출 및 점프 이전에 사용 가능합니다'
# 'r11 available before calls but not before jumps'
HAF3B1E936CB4: 'r11은 호출 전에는 사용 가능하지만 점프 전에는 사용 불가능합니다'
# 'r11 not available'
HD51A31809CB5: 'r11 사용 불가'
# "range-based 'for' statement uses ':', not '='"
HC53E3757D97C: "range 기반 'for' 문은 ':'를 사용해야 하며 '='를 사용하지 않습니다"
# 'range-based for loop has empty body'
H2C4FFAA3CE47: '범위 기반 for 루프가 비어 있는 본문을 가집니다'
# 'range-based for loop initialization statements are a C++20 extension'
H77FF5523C4B8: '범위 기반 for 루프 초기화 문은 C++20 확장 기능입니다'
# 'range-based for loop initialization statements are incompatible with C++ standards before C++20'
H529EE263FDB4: '범위 기반 for 루프 초기화 문은 C++20 이전의 C++ 표준과 호환되지 않습니다'
# 'range-based for loop is a C++11 extension'
HE56D92957A6D: '범위 기반 for 루프는 C++11 확장입니다'
# 'range-based for loop is incompatible with C++98'
H2229A30F511E: 'C++98과 호환되지 않는 range-based for 루프입니다.'
# 'range-based for loop requires type for loop variable'
H07E32C6E46BC: 'range-based for 문은 루프 변수의 유형을 지정해야 합니다'
# 'raw string delimiter longer than 16 characters; use PREFIX( )PREFIX to delimit raw string'
H00B2DC6A7B32: '원시 문자열 구분자가 16자를 초과합니다; 원시 문자열을 구분하기 위해 PREFIX( )PREFIX를 사용하십시오'
# 'raw string literals are incompatible with C++98'
H1C93D8A83CA2: '원시 문자열 리터럴은 C++98과 호환되지 않습니다'
# 'raw string missing terminating delimiter )%0"'
H7FD087037BE3: '원시 문자열의 종료 구분자가 누락되었습니다 )%0'
# "re-exported libraries do not match: '%0' (provided) vs '%1' (found)"
H6C320DEC171A: "재수출된 라이브러리가 일치하지 않습니다: '%0' (제공됨) 대 '%1' (검색됨)"
# "re-exported library missing from %0: '%1'"
H552D4BA598A3: "재수출된 라이브러리가 %0에 누락되었습니다: '%1'"
# 're-use space in old .text if possible (relocation mode)'
H05BFF380B5E6: '가능한 경우 재배치 모드에서 구 .text 섹션의 공간을 재사용합니다 (relocation mode)'
# 'read of incomplete type %0 is not allowed in a constant expression'
HCA641211FEEB: '상수 표현식에서 미완성 타입 %0의 읽기는 허용되지 않습니다'
# 'read of non-const variable %0 is not allowed in a constant expression'
HD99D6E4F37A4: 'non-const 변수 %0의 읽기는 상수 표현식에서 허용되지 않습니다.'
# 'read of non-constexpr variable %0 is not allowed in a constant expression'
HF3D92222C519: 'constexpr이 아닌 변수 %0의 읽기는 상수 표현식 내에서 허용되지 않습니다.'
# 'read of variable %0 of non-integral, non-enumeration type %1 is not allowed in a constant expression'
H33BFBE7CF01D: '상수 표현식에서 정수형이거나 열거형이 아닌 타입 %1의 변수 %0을 읽는 것은 허용되지 않습니다.'
# "readonly IBOutlet property %0 when auto-synthesized may not work correctly with 'nib' loader"
H582EA0DF024A: 'readonly IBOutlet 속성 %0는 자동으로 합성될 때 Nib 로더와 함께 정상적으로 동작하지 않을 수 있습니다'
# 'reassign registers so as to avoid using REX prefixes in hot code'
HE2FFC9EC6F02: '핫 코드에서 REX 접두사 사용을 피하기 위해 레지스터를 재할당합니다'
# 'received warning after diagnostic serialization teardown was underway: %0'
H60ECB032353D: '진단 직렬화 해체가 진행 중일 때 경고를 받았습니다: %0'
# 'receiver %0 for class message is a forward declaration'
HAE87B957CEBD: '클래스 메시지의 %0 수신자는 전방 선언입니다'
# 'receiver %0 is a forward class and corresponding @interface may not exist'
H2EFCADD231BF: '리시버 %0는 포워드 클래스이며, 해당하는 @interface가 존재하지 않을 수 있습니다.'
# 'receiver expression is here'
H16AA23E5E187: '리시버 표현식이 여기에 있습니다'
# 'receiver is instance of class declared here'
H063C50E49E8E: '리시버는 여기서 선언된 클래스의 인스턴스입니다'
# "receiver is treated with 'id' type for purpose of method lookup"
H23B037191711: "메서드 탐색을 위해 수신자를 'id' 형식으로 처리합니다."
# 'receiver type %0 for instance message is a forward declaration'
H4107B7B01A42: '인스턴스 메시지의 수신자 유형 %0는 전방 선언입니다'
# "receiver type %0 is not 'id' or interface pointer, consider casting it to 'id'"
HC44380DEE815: "수신자 형식 %0은 'id' 또는 인터페이스 포인터가 아닙니다, 'id'로 캐스팅하는 것을 고려하세요"
# 'receiver type %0 is not an Objective-C class'
HDF1E1AF5B7B2: '리시버 타입 %0는 Objective-C 클래스가 아닙니다'
# 'record profile for inter-function control flow activity (default: true)'
HB3410F96E4B8: '인터함수 제어 흐름 활동에 대한 프로필 기록 (기본값: true)'
# 'recursive evaluation of default argument'
H9D22EE24805A: '기본 인수의 재귀적 평가'
# 'recursive template instantiation exceeded maximum depth of %0'
H9F7DB4D308D0: '재귀 템플릿 인스턴스화가 최대 깊이 %0를 초과했습니다'
# "redeclaration cannot add 'loader_uninitialized' attribute"
H70EFB9FBF448: "재선언에서는 'loader_uninitialized' 속성을 추가할 수 없습니다"
# 'redeclaration has different alignment requirement (%1 vs %0)'
H2965974DE860: '재선언은 다른 정렬 요구사항을 가지고 있습니다 (%1 vs %0)'
# "redeclaration of %0 must %select{not |}1have the 'overloadable' attribute"
H9C609286F3D1: "%0의 재선언은 %select{가져서는 안 되며 |}1'overloadable' 속성을 가져야 합니다"
# 'redeclaration of %0 with a different type%diff{: $ vs $|}1,2'
HEB05B74B4F52: '다른 형식으로 %0의 재선언%diff{: $ vs $|}1,2'
# 'redeclaration of %q0 cannot add %q1 attribute'
H437273BF8230: '%q0의 재선언은 %q1 속성을 추가할 수 없습니다'
# 'redeclaration of %q0 should not add %q1 attribute'
HBC3EEF68F79F: '%q0의 재선언에서 %q1 attribute를 추가하지 않아야 합니다'
# "redeclaration of C++ built-in type 'bool'"
H4DE1B64751F8: "C++ 내장 형식 'bool'의 재선언"
# 'redeclaration of already-defined enum %0 is a GNU extension'
H3B72AE37DEEE: '이미 정의된 enum %0의 재선언은 GNU 확장 기능입니다'
# 'redeclaration of deduction guide'
H6C137FDA5914: '유추 가이드의 재선언'
# 'redeclaration of method parameter %0'
H0D9F6CE9B2EA: '메서드 매개변수 %0의 재선언'
# 'redeclaration of type parameter %0'
HC29DAC039CAB: '%0의 유형 매개변수 재선언'
# 'redeclaration of using declaration'
H96E43918A485: 'using 선언의 재선언'
# 'redeclaration of using-enum declaration'
H7EA3B309B6C8: 'using-enum 선언의 재선언'
# 'redeclaring non-static %0 as static is a Microsoft extension'
H853738CC6C0D: '정적 멤버가 아닌 %0을 정적으로 재선언하는 것은 Microsoft 확장입니다'
# 'redefining builtin macro'
H6021415EA4BB: '빌트인 매크로 재정의'
# 'redefinition of %0'
HB70C986DD184: '정의 재정의: %0'
# 'redefinition of %0 as an alias for a different namespace'
H97345A757B2F: '다른 네임스페이스의 별칭으로 %0의 재정의'
# 'redefinition of %0 as different kind of symbol'
H9380CBD04275: '다른 종류의 심벌로 %0의 재정의'
# 'redefinition of %0 will not be visible outside of this function'
H6605A7137B7E: '재정의된 %0는 이 함수 밖에서는 접근할 수 없습니다'
# 'redefinition of %0 with a different type%diff{: $ vs $|}1,2'
HB1C0A119B95E: '%0의 다른 형식으로 재정의되었습니다%diff{: $와 $ 비교|}1,2'
# 'redefinition of %select{typedef|type alias}0 for variably-modified type %1'
HB599B51A5F4D: 'variably-modified type %1에 대한 %select{typedef|type alias}0의 재정의입니다'
# "redefinition of a 'extern inline' function %0 is not supported in %select{C99 mode|C++}1"
HF158368144B8: '‘extern inline’ 함수 %0의 재정의는 %select{C99 모드|C++}1에서 지원되지 않습니다'
# 'redefinition of concept %0 with different template parameters or requirements'
H4C4283523181: '개념 %0의 재정의는 다른 템플릿 매개변수 또는 요구 조건으로 이루어졌습니다'
# 'redefinition of default argument'
H6507C3F7227D: '기본 인수 재정의'
# 'redefinition of enumerator %0'
H1EE462BB5E46: '열거자 %0의 재정의입니다'
# 'redefinition of forward class %0 of a typedef name of an object type is ignored'
H06040CF8C316: '객체 형식의 typedef 이름의 포워드 클래스 %0의 재정의는 무시됩니다'
# 'redefinition of inferred submodule'
H43BB40E423BF: '추론된 하위 모듈의 재정의'
# 'redefinition of label %0'
HD4F4A928D72C: '레이블 %0의 재정의'
# 'redefinition of method parameter %0'
HE18AEF27C9A1: '메소드 매개변수 %0의 재정의'
# "redefinition of module '%0'"
H6249FB58D003: "모듈 '%0'의 재정의"
# 'redefinition of parameter %0'
H88BE534E3F7A: '매개변수 %0의 재정의'
# 'redefinition of typedef %0 is a C11 feature'
H8B88EC5F6F5C: 'typedef %0의 재정의는 C11 기능입니다'
# 'redefinition of user-defined mapper for type %0 with name %1'
HADE614C371DA: '사용자 정의 매핑기의 재정의: %0 형식에 이름 %1이 있습니다.'
# 'redefinition of user-defined reduction for type %0'
H4B307482E8CD: '유형 %0의 사용자 정의 리덕션 재정의'
# 'redirect journaling to a file instead of stdout/stderr'
H5FEA9D013494: 'stdout/stderr 대신 파일로 journaling을 리다이렉트합니다'
# "reduction type cannot be %select{qualified with 'const', 'volatile' or 'restrict'|a function|a reference|an array}0 type"
H2D2C74F27FDF: '리덕션 형식은 %select{const, volatile 또는 restrict로 자격이 지정된|함수|참조|배열}0 형식일 수 없습니다'
# 'reduction variables may not be accessed in an explicit task'
H233496630504: '감소 변수는 명시적인 작업에서 참조할 수 없습니다'
# "redundant #include of module '%0' appears within %1"
H3B45950DD3A3: "모듈 '%0'의 중복된 #include가 %1 내부에 있습니다"
# 'redundant %0 availability change; only the last specified change will be used'
HE2065BD86C26: '사용 가능한 %0 변경이 중복되었습니다; 지정된 변경 중 마지막 변경만 사용됩니다'
# "redundant 'sycl_kernel_entry_point' attribute"
H89B952CF4093: "중복된 'sycl_kernel_entry_point' 속성"
# "redundant attribute subject matcher sub-rule '%0'; '%1' already matches those declarations"
HE12FF717092C: "중복된 속성 주체 매처 하위 규칙 '%0'; '%1'은 이미 해당 선언들을 일치시킵니다"
# 'redundant move in return statement'
HC34A9F2066D1: '리턴 문에서 중복된 이동'
# 'redundant parentheses surrounding declarator'
H47E8307AF60E: '데클래레이터를 둘러싼 중복된 괄호'
# "ref-qualifier '%select{&&|&}0' is not allowed on a constructor"
H5FB2827C1F13: "생성자에 '%select{&&|&}0' 참조 자격자가 허용되지 않습니다"
# "ref-qualifier '%select{&&|&}0' is not allowed on a destructor"
H0C7698A4B274: "참조 자격자 '%select{&&|&}0'는 소멸자에는 허용되지 않습니다"
# "ref-qualifier '&&' is not allowed on a defaulted comparison operator"
HE95322EAF78E: "참조 자격자 '&&'는 디폴트된 비교 연산자에 허용되지 않습니다."
# 'refactoring action cannot be initiated without a selection'
H24ED847BB22A: '리팩토링 작업은 선택 없이는 시작할 수 없습니다'
# 'reference %0 is not yet bound to a value when used here'
HF3E8D22129FD: '참조 %0는 여기에서 사용될 때 아직 값에 바인드되지 않았습니다'
# 'reference %0 is not yet bound to a value when used within its own initialization'
HB4996BB1A27E: '참조 %0는 자기 자신의 초기화 내에서 사용될 때 아직 값에 바인딩되지 않았습니다'
# 'reference %diff{to %select{type|incomplete type}1 $ could not bind to an %select{rvalue|lvalue}2 of type $|could not bind to %select{rvalue|lvalue}2 of incompatible type}0,3'
HFAC2C332E9F4: '참조 %diff{가 %select{타입|완전하지 않은 타입}1 $에 바인딩할 수 없습니다. %select{rvalue|lvalue}2 형식의 $|%select{rvalue|lvalue}2의 호환되지 않는 타입으로 바인딩할 수 없습니다}0,3'
# 'reference binding of non-type template parameter %diff{of type $ to template argument of type $|to template argument}0,1 ignores qualifiers'
H093001BBE364: '비유형 템플릿 매개변수의 참조 바인딩 %diff{ $ 유형의 템플릿 인자로의 $ | 템플릿 인자로의 }0,1 자격 증명을 무시합니다'
# 'reference cannot be bound to dereferenced null pointer in well-defined C++ code; comparison may be assumed to always evaluate to %select{true|false}0'
H136F139EE8E6: '정의된 C++ 코드에서 해제된 널 포인터에 참조를 바인딩할 수 없습니다; 비교 연산이 항상 %select{true|false}0로 평가된다고 가정될 수 있습니다.'
# 'reference cannot be bound to dereferenced null pointer in well-defined C++ code; pointer may be assumed to always convert to true'
H5320A7915E7F: '정의된 C++ 코드에서 참조는 해제된 null 포인터에 바인딩될 수 없습니다; 포인터는 항상 true로 변환될 수 있습니다'
# 'reference cannot be initialized with multiple values'
HE7DB5FCEC436: '참조는 여러 값으로 초기화될 수 없습니다'
# 'reference cannot bind to bit-field in converted constant expression'
HF5063530D4A6: '변환된 상수 표현식 내의 비트 필드에 참조를 바인딩할 수 없습니다'
# 'reference dynamic_cast failed: %select{static type %1 of operand is a non-public base class of dynamic type %2|dynamic type %2 of operand does not have a base class of type %3|%3 is an ambiguous base class of dynamic type %2 of operand|%3 is a non-public base class of dynamic type %2 of operand}0'
H4859449FAD67: '동적 형변환 dynamic_cast 실패: %select{연산자의 정적 타입 %1은 동적 타입 %2의 비공개 기반 클래스입니다|연산자의 동적 타입 %2는 타입 %3의 기반 클래스를 갖지 않습니다|%3은 동적 타입 %2의 연산자에서 모호한 기반 클래스입니다|%3은 동적 타입 %2의 연산자에서 비공개 기반 클래스입니다}0'
# 'reference initialization of type %0 with initializer of type %1 is ambiguous'
HB988A3E86777: '타입 %0의 레퍼런스 초기화에 타입 %1의 초기화자가 사용되어 모호합니다'
# 'reference initialized from initializer list is incompatible with C++98'
HCD4C182EF998: '초기화 리스트로 초기화된 참조는 C++98과 호환되지 않습니다'
# 'reference member of type %0 uninitialized'
HC2805DCE0AFC: '%0 형식의 참조 멤버가 초기화되지 않았습니다'
# 'reference of type %0 cannot bind to a temporary object because of address space mismatch'
HF0C3B633C49A: '%0 형식의 참조는 주소 공간 불일치로 인해 임시 객체에 바인딩할 수 없습니다'
# 'reference qualifiers on functions are a C++11 extension'
H41B9EC19F32B: '함수의 참조 자격자는 C++11 확장입니다'
# 'reference qualifiers on functions are incompatible with C++98'
HF044E58F9C25: '함수의 참조 자격 증명은 C++98와 호환되지 않습니다'
# 'reference to %0 is ambiguous'
H97A6825DEB56: '참조 %0가 모호합니다'
# 'reference to %select{__device__|__global__|__host__|__host__ __device__}0 %select{function|variable}1 %2 in %select{__device__|__global__|__host__|__host__ __device__}3 function'
H43094BC1789F: '의 %select{__device__|__global__|__host__|__host__ __device__}0 %select{함수|변수}1 %2 %select{__device__|__global__|__host__|__host__ __device__}3 함수 내부 참조'
# 'reference to %select{__device__|__global__|__host__|__host__ __device__}0 function %1 in global initializer'
H76762B8F478F: '전역 초기화자에서 %select{__device__|__global__|__host__|__host__ __device__}0 함수 %1에 대한 참조'
# 'reference to %select{destructor|pseudo-destructor}0 must be called%select{|; did you mean to call it with no arguments?}1'
H3484C551C20A: '%select{소멸자|의사 소멸자}0의 참조는 호출되어야 합니다%select{|; 인수 없이 호출하려는 의도는 없었나요?}1'
# 'reference to %select{overloaded|multiversioned}1 function could not be resolved; did you mean to call it%select{| with no arguments}0?'
HA7DE06C12730: '오버로드되거나 다중 버전화된 %select{함수|생성자}1에 대한 참조를 해결할 수 없습니다; %select{| 인수 없이 호출하려는 의도였나요}0?'
# "reference to a %select{bit-field|vector element|global register variable}0 in asm %select{input|output}1 with a memory constraint '%2'"
HCCFE4F550EEB: "asm %select{입력|출력}1의 메모리 제약 '%2'에 %select{비트 필드|벡터 요소|글로벌 레지스터 변수}0의 참조가 있습니다."
# "reference to enumeration must use 'enum' not 'enum %select{struct|class}0'"
HDC33545DFD9E: "열거형에 대한 참조는 'enum'을 사용해야 하며 'enum %select{struct|class}0'을 사용하지 마십시오."
# 'reference to local %select{variable|binding}1 %0 declared in enclosing %select{%3|block literal|lambda expression|context}2'
H9B72122A433C: '지역 %select{변수|바인딩}1 %0은 포함된 %select{%3|블록 리터럴|람다 표현식|컨텍스트}2에서 선언되었습니다'
# "reference to marker '%0' is ambiguous"
HD452BD6D3FB0: "마커 '%0'에 대한 참조가 모호합니다"
# 'reference to non-static member function must be called%select{|; did you mean to call it with no arguments?}0'
H472EE5EB17CD: '비정적 멤버 함수에 대한 참조는 호출되어야 합니다%select{|; 인수 없이 호출하려는 의도였나요?}0'
# 'reference to type %0 cannot bind to an initializer list'
H9194F3CD2BD5: '형식 %0의 참조는 초기화자 목록에 바인딩할 수 없습니다'
# 'reference to type %0 requires an initializer'
HD97076E9024C: '%0 유형에 대한 참조는 초기화자를 필요로 합니다.'
# 'reference to unresolved using declaration'
H4256A6DE4B09: '해결되지 않은 using 선언에 대한 참조'
# 'referenced %0 is declared here'
HE1EBB7B8DBAD: '참조된 %0은 여기서 선언되었습니다'
# 'referenced member %0 is declared here'
H8DB9210452D3: '참조된 멤버 %0는 여기서 선언되었습니다'
# "referring to 'main' within an expression is a Clang extension"
H5EC3F4017EE7: "표현식 내에서 'main'을 참조하는 것은 Clang의 확장 기능입니다"
# "region cannot be%select{| closely}0 nested inside '%1' region%select{|; perhaps you forget to enclose 'omp %3' directive into a parallel region?|; perhaps you forget to enclose 'omp %3' directive into a for or a parallel for region with 'ordered' clause?|; perhaps you forget to enclose 'omp %3' directive into a target region?|; perhaps you forget to enclose 'omp %3' directive into a teams region?|; perhaps you forget to enclose 'omp %3' directive into a for, simd, for simd, parallel for, or parallel for simd region?}2"
H9F4A9870BA07: "해당 영역은 %select{|밀접하게}0 '%1' 영역 내에 중첩될 수 없습니다.%select{| 'omp %3' 디렉티브를 병렬 영역 안에 감싸지 않았을 수도 있습니다.| 'omp %3' 디렉티브를 for 또는 ordered 절을 가진 parallel for 영역 안에 감싸지 않았을 수도 있습니다.| 'omp %3' 디렉티브를 target 영역 안에 감싸지 않았을 수도 있습니다.| 'omp %3' 디렉티브를 teams 영역 안에 감싸지 않았을 수도 있습니다.| 'omp %3' 디렉티브를 for, simd, for simd, parallel for 또는 parallel for simd 영역 안에 감싸지 않았을 수도 있습니다.}2"
# "register '%0' unsuitable for global register variables on this target"
HAC3AEFE8413B: "register '%0'은 이 타깃에서 글로벌 레지스터 변수에 적합하지 않습니다"
# 'register number should be an integer'
H932EE02D1B8E: '레지스터 번호는 정수여야 합니다'
# 'register pressure factor for the transformations.'
H44776CA40899: '변환의 레지스터 압력 요소'
# 'register space cannot be specified on global constants'
H7D24E3150A81: '전역 상수에 register 공간을 지정할 수 없습니다'
# 'reimplementation of category %1 for class %0'
H30BD90819E63: '클래스 %0의 카테고리 %1 재구현'
# 'reimplementation of class %0'
HD4142B86FCD9: '클래스 %0의 재구현'
# 'reinterpret_cast cannot resolve overloaded function %0 to type %1'
H60D5F589023C: 'reinterpret_cast는 오버로드된 함수 %0을 타입 %1로 변환할 수 없습니다'
# 'reinterpret_cast from %0 to %1 has undefined behavior'
H1A1328A6B1E4: 'reinterpret_cast를 %0에서 %1로 변환하는 것은 정의되지 않은 동작입니다'
# 'reinterpret_cast of a %0 to %1 needs its address, which is not allowed'
H8633F993884D: 'reinterpret_cast를 %0에서 %1로 하는 것은 그 주소가 필요하지만, 이는 허용되지 않습니다'
# "releasing %0 '%1' that was not held"
HD16686A7FEA7: "해제 중인 %0 '%1'은 잡혀있지 않았습니다"
# "releasing %0 '%1' using %select{shared|exclusive}2 access, expected %select{shared|exclusive}3 access"
H2106963D41B0: "%0 '%1'을 %select{shared|exclusive}2 액세스를 사용하여 해제 중입니다. %select{shared|exclusive}3 액세스가 예상되었습니다"
# 'remainder by zero in preprocessor expression'
HE098B5222CAD: '사전 처리기 표현에서 0으로 나눈 나머지'
# 'remaining %0 candidate%s0 omitted; pass -fshow-overloads=all to show them'
HD0784BB8E50F: '남은 %0 후보%s0이 생략됨; -fshow-overloads=all 옵션을 전달하여 표시할 수 있습니다'
# 'remap file source paths <old> to <new> in coverage mapping. If there are multiple options, prefix replacement is applied in reverse order starting from the last one'
HD493DCAA04BC: '커버리지 매핑에서 파일 소스 경로를 <old>에서 <new>로 재지정합니다. 여러 옵션이 있는 경우, 접두사 교체는 마지막 옵션부터 거꾸로 적용됩니다'
# 'remap file source paths in debug info, coverage mapping, predefined preprocessor macros and __builtin_FILE(). Implies -ffile-reproducible.'
HD15C7DEA6A6F: '디버그 정보, 커버리지 매핑, 사전 정의된 전처리기 매크로 및 __builtin_FILE()에서 파일 소스 경로를 재 지정합니다. -ffile-reproducible 옵션을 암시합니다.'
# 'remap file source paths in predefined preprocessor macros and __builtin_FILE(). Implies -ffile-reproducible.'
H6FA3D7D85AF9: '사전 정의된 преп로세서 매크로 및 __builtin_FILE()의 파일 소스 경로를 재 지정합니다. 이 옵션은 -ffile-reproducible을 포함합니다.'
# 'remarks_a'
H1F5563CE509E: '주석_a'
# 'remarks_b'
H40EB09D856D2: '리마크_b'
# "remove '_Noreturn'"
H4CD6C2426BE8: '’_Noreturn’을 제거하세요'
# "remove 'enum%select{| struct| class}0' to befriend an enum"
H9CF5F9198489: 'enum%select{| struct| class}0를 제거하여 enum을 친구로 선언하십시오'
# "remove 'u8' prefix to avoid a change of behavior; Clang encodes unprefixed narrow string literals as UTF-8"
H40BFCE51D12C: "동작의 변경을 피하려면 'u8' 접두사를 제거하세요; Clang은 접두사가 없는 좁은 문자열 리터럴을 UTF-8로 인코딩합니다"
# 'remove call to max function and unsigned zero argument'
H746EE2CAAC37: 'max 함수 호출을 제거하고 부호 없는 제로 인수를 제거하십시오'
# 'remove constant to silence this warning'
H8233E14B9765: '상수를 제거하여 이 경고를 제거하세요'
# 'remove double jumps when able'
H144AFE550114: '가능할 때 이중 점프 제거'
# 'remove extraneous parentheses around the comparison to silence this warning'
H7C576B6A85C7: '비교 주위에 있는 불필요한 괄호를 제거하여 이 경고를 제거하세요'
# 'remove parentheses to declare a variable'
H29AB7F8F0D04: '변수를 선언하려면 괄호를 제거하십시오'
# 'remove parentheses to silence this warning'
HBB1C1AF59745: '이 경고를 무시하려면 괄호를 제거하세요'
# 'remove std::move call here'
H87B3A4171A2A: '여기에서 std::move 호출을 제거하세요'
# "remove the %select{'%1' if its condition|condition if it}0 is always %select{false|true}2"
HE5C66C3841AD: "조건이 항상 %select{false|true}2이므로 %select{'%1'의 조건|조건이 있다면}0을 제거하십시오"
# "remove the call to '%0' since unsigned values cannot be negative"
H3BE7257796E7: "부호 없는 값은 음수일 수 없기 때문에 '%0'의 호출을 제거합니다"
# 'remove the kernel-info pass at the end of the full LTO pipeline'
HE9CC6C17C11E: '전체 LTO 파이프라인의 끝에서 kernel-info 패스를 제거합니다'
# 'remove useless conditional branches'
H7F773F483924: '사용되지 않는 조건부 브랜치 제거'
# "rename '%0' to ensure it can be found by name"
H730151DC5720: "이름 '%0'을(를) 변경하여 이름으로 찾을 수 있도록 하십시오"
# 'reorder and cluster functions (works only with relocations)'
HB96EDA278BFF: '함수 재정렬 및 그룹화(재배치가 필요한 경우에만 작동합니다)'
# 'reorder data sections in place'
HCACEBAE7CFC3: '데이터 섹션을 원래 위치에서 재정렬'
# 'reorder functions randomly'
HA61C4AF88653: '임의 순서로 함수 재정렬'
# 'reorder three way branches'
HF6331B33926D: '세 가지 방향 분기를 재정렬합니다'
# 'reorder unconditional jump instructions in loops optimization'
H61D641F1F0CA: '루프 최적화에서 조건 없는 점프 명령어의 순서를 재정렬합니다'
# "repeated RISC-V 'interrupt' attribute"
HE9564BE7AF0F: "반복된 RISC-V 'interrupt' 속성"
# "repeated RISC-V 'interrupt' attribute is here"
H2C65B1A1835B: "반복된 RISC-V 'interrupt' 속성이 이 위치에 있습니다"
# 'repeated evaluation of the same literal expression can produce different objects'
H816EF14DCA64: '같은 리터럴 표현식을 반복 평가하면 다른 객체가 생성될 수 있습니다'
# "replace 'default' with 'delete'"
H6143A5F8A323: "표준 구문 'default' 대신 'delete' 키워드를 사용해야 합니다"
# "replace expression with '%0' %select{|or use 'xor' instead of '^' }1to silence this warning"
H8BD6D24EAB4A: "표현식을 '%0'로 대체하거나 %select{|'xor' 대신 '^'를 사용하여 }1경고를 제거하세요"
# 'replace parentheses with an initializer to declare a variable'
H1CB1AEAC6164: '괄호를 초기화자로 대체하여 변수를 선언하십시오.'
# "replacement function %0 cannot be declared 'inline'"
H8E774898376D: "대체 함수 %0는 'inline'으로 선언할 수 없습니다"
# 'report accesses through a pointer which has poisoned shadow'
HDB29EEB5BF15: '중독된 그림자를 가진 포인터를 통해 액세스한 내용 보고'
# 'report stats in csv'
H4FBFD3CEA227: 'CSV 형식으로 통계 보고'
# 'report stats in text'
HDFF33DBA8938: '텍스트로 통계 보고'
# "requested 'init_priority' %0 is reserved for internal use"
H2E025E570ED5: "요청하신 'init_priority' %0은 내부 사용을 위해 예약되었습니다"
# 'requested alignment %0 is not a positive power of two'
H9C01C430B004: '요청된 정렬 %0은 양의 2의 거듭제곱이 아닙니다'
# 'requested alignment is dependent but declaration is not dependent'
H9D546DA38E42: '요청된 정렬은 의존적이지만 선언은 의존적이지 않습니다'
# 'requested alignment is less than minimum alignment of %1 for type %0'
H9E0857E89F1F: '요청된 정렬이 %0 형식에 대한 %1의 최소 정렬보다 작습니다.'
# 'requested alignment is not a power of 2'
HC6B6240D895B: '요청된 정렬 값이 2의 거듭제곱이 아닙니다'
# 'requested alignment must be %0 bytes or smaller'
H7B9D334BA24B: '요청된 정렬은 %0 바이트 이하여야 합니다'
# 'requested alignment must be %0 bytes or smaller; maximum alignment assumed'
HCDB68D900AC4: '요청된 alignment는 %0 bytes 이하여야 합니다; 최대 alignment 가정됨'
# 'requested alignment must be %0 or greater'
H097A66E5C9B7: '요청된 정렬은 %0 이상이어야 합니다'
# 'requested alignment must be %0 or less for type %1; %2 is invalid'
H6B97FB634040: '요청된 정렬은 %1 형식에 대해 %0 이하여야 합니다; %2는 유효하지 않습니다'
# 'requested alignment must be %0 or smaller'
HEC3786C66ADB: '요청된 정렬은 %0 이하여야 합니다'
# 'requested shift is a vector of type %0 but the first operand is not a vector (%1)'
H149741EFCCA5: '요청된 shift는 %0 유형의 벡터이지만 첫 번째 연산자는 벡터가 아닙니다 (%1)'
# 'required alignment of type %0 (%1 bytes) is larger than the supported alignment of C++ exception objects on this target (%2 bytes)'
HFFCA5AAB79EE: '타입 %0의 필요한 정렬값 (%1 바이트)은 해당 타겟에서 C++ 예외 객체가 지원하는 정렬값 (%2 바이트)보다 큽니다.'
# "required by %select{'require_constant_initialization' attribute|'constinit' specifier}0 here"
H669C2D015B6E: "%select{'require_constant_initialization' 속성|'constinit' 지정자}0 에 의해 여기서 필요합니다."
# 'requires clause differs in template redeclaration'
H3C91EEDA34FA: '템플릿 재선언에서 requires 절이 다릅니다'
# "requires expression in requirement body; did you intend to place it in a nested requirement? (add another 'requires' before the expression)"
H818E1323CB5B: "요구 조건 본문에 requires 표현식이 필요합니다; 이것을 중첩된 요구 조건에 배치하려는 것이었나요? (표현식 앞에 다른 'requires'를 추가하세요)"
# "reserved locator 'omp_all_memory' cannot be specified more than once"
HBB5542941955: "예약된 지정자 'omp_all_memory'는 한 번 이상 지정할 수 없습니다"
# "reserved locator 'omp_all_memory' requires 'out' or 'inout' dependency types"
H98614BF4F5B5: "예약된 위치 지정자 'omp_all_memory'는 'out' 또는 'inout' 의존성 유형이 필요합니다"
# 'resolve all otherwise unresolved externals to null'
H0D8FB57C5D95: '다른 방법으로 해결되지 않은 모든 외부 심볼을 null로 해결합니다'
# 'resource has implicit register binding'
H2038E0629D14: '리소스가 암시적 레지스터 결합을 가집니다'
# 'respect alignment requirements provided by input IR'
H3C9B5ECCDE76: '입력 IR에 의해 제공되는 정렬 요구사항을 준수하십시오.'
# 'restrict requires a pointer or reference'
H044B0871CB3F: 'restrict는 포인터 또는 참조가 필요합니다'
# 'restrict requires a pointer or reference (%0 is invalid)'
HB4AA3977DC42: 'restrict는 포인터나 참조가 필요합니다 (%0은 유효하지 않습니다)'
# "result argument to %select{overflow builtin|checked integer operation}0 must be a pointer to a non-const integer type %select{|other than plain 'char', 'bool', bit-precise, or an enumeration }0(%1 invalid)"
HD81ECBB4661A: "result 인수에 %select{overflow builtin|체크된 정수 연산}0을 전달할 때는 비)const 정수 유형 포인터가 필요합니다 %select{|plain 'char', 'bool', 비트 정밀도, 또는 열거 형식은 제외}0(%1이 유효하지 않음)"
# "result of '%0' is %1; did you mean '%2' (%3)?"
H369683737B3D: "“%0”的 결과는 %1입니다; '%2' (%3)를 의도하셨나요?"
# "result of '%0' is %1; did you mean '%2'?"
H1B6516041439: '‘%0’의 결과는 %1입니다; ‘%2’를 의미하셨는지요?'
# "result of '%0' is %1; did you mean exponentiation?"
H6BDF285BA0FF: '%0의 결과는 %1입니다. 지수 연산을 하려는 게 아니었나요?'
# 'result of comparison %select{%3|%1}0 %2 %select{%1|%3}0 is always %4'
H3D76D2CD2831: '비교 %select{%3|%1}0 %2 %select{%1|%3}0의 결과는 항상 %4입니다'
# 'result of comparison against %select{a string literal|@encode}0 is unspecified (use an explicit string comparison function instead)'
H42F5B6822163: '%select{문자열 리터럴|@encode}0와의 비교 결과는 미지정됨 (명시적 문자열 비교 함수를 사용해야 합니다)'
# 'result of comparison of %select{%3|char expression}0 %2 %select{char expression|%3}0 is always %4, since char is interpreted as unsigned'
H2652DE195D69: '비교의 결과 %select{%3|char 표현식}0 %2 %select{char 표현식|%3}0은 항상 %4입니다. char은 부호 없는 값으로 해석되기 때문입니다'
# 'result of comparison of %select{%3|unsigned enum expression}0 %2 %select{unsigned enum expression|%3}0 is always %4'
H86DA5A0E3154: '비교의 결과는 %select{%3|부호 없는 열거 식}0 %2 %select{부호 없는 열거 식|%3}0이 항상 %4입니다'
# 'result of comparison of %select{%3|unsigned expression}0 %2 %select{unsigned expression|%3}0 is always %4'
HABA37A2C23DF: '비교의 결과 %select{%3|부호 없는 표현식}0 %2 %select{부호 없는 표현식|%3}0은 항상 %4입니다'
# 'result of comparison of %select{%4|%1-bit %select{signed|unsigned}2 value}0 %3 %select{%1-bit %select{signed|unsigned}2 value|%4}0 is always %5'
H3E54DBA92461: '비교의 결과 %select{%4|%1비트 %select{부호 있는|부호 없는}2 값}0 %3 %select{%1비트 %select{부호 있는|부호 없는}2 값|%4}0는 항상 %5입니다'
# 'result of comparison of %select{constant %0|true|false}1 with %select{expression of type %2|boolean expression}3 is always %4'
H0604EEA5685E: '%select{상수 %0|참|거짓}1과 %select{유형 %2 표현식|불리언 표현식}3의 비교 결과는 항상 %4입니다'
# "result of comparison of constant %0 with expression of type 'BOOL' is always %1, as the only well defined values for 'BOOL' are YES and NO"
H641A75823917: "상수 %0과 형식 'BOOL'의 표현식 간 비교의 결과는 항상 %1입니다. 왜냐하면 'BOOL' 형식의 유일한 정의된 값은 YES와 NO이기 때문입니다"
# "retain'ed block property does not copy the block - use copy attribute instead"
HD7F1D5C5B0F0: 'retain된 블록 프로퍼티는 블록을 복사하지 않습니다 - copy 어트리뷰트를 사용하십시오'
# 'return in the catch of a function try block of a constructor is illegal'
HBC7FDA21A80E: '생성자의 함수 시도 블록 내 catch 블록에서 return 문을 사용하는 것은 허용되지 않습니다'
# "return state set for an unconsumable type '%0'"
H2753EF9C9B3B: "리턴 상태 설정이 소비 불가능한 형식 '%0'에 설정되었습니다."
# "return statement not allowed in coroutine; did you mean 'co_return'?"
HD15AAC2A320B: '코루틴 내에서는 return 문을 사용할 수 없습니다; co_return을 의미하지는 않으셨나요?'
# "return type %0 of selected 'operator==' function for rewritten '%1' comparison is not 'bool'"
HC9853B2276CB: "선택된 'operator==' 함수의 반환 타입 %0은 %1로 재작성된 비교에 대해 'bool'이 아닙니다"
# 'return type cannot be qualified with address space'
H90249355EB7F: '리턴 타입은 주소 공간을 사용한 자격 지정을 할 수 없습니다'
# 'return type deduction is incompatible with C++ standards before C++14'
HB4A5F5EFADA6: '리턴 타입 추론은 C++14 이전의 C++ 표준과 호환되지 않습니다'
# "return type for defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator must be 'bool', not %1"
H2EF639AB940D: "기본화된 %select{<ERROR>|등가성|세방향|등가성|관계}0 비교 연산자의 반환 형식은 'bool'이어야 합니다. %1이(가) 아닙니다."
# "return type of 'await_ready' is required to be contextually convertible to 'bool'"
H043CECD8EB91: 'await_ready의 반환 타입은 bool로 맥락적 변환이 가능해야 합니다'
# "return type of 'await_suspend' is required to be 'void' or 'bool' (have %0)"
H64AB2C323A61: "'await_suspend'의 반환 형식은 'void' 또는 'bool'이어야 합니다 (현재 %0)"
# "return type of 'coroutine_handle<>::address should be 'void*' (have %0) in order to get capability with existing async C API"
HA713CB41D910: "coroutine_handle<>::address의 반환 타입은 'void*'여야 합니다(현재 %0). 기존 비동기 C API와 호환성을 위해"
# "return type of 'main' is not 'int'"
HFBAC240E8034: '메인의 반환 타입이 int가 아닙니다.'
# "return type of defaulted 'operator<=>' cannot be deduced because return type %2 of three-way comparison for %select{|member|base class}0 %1 is not a standard comparison category type"
H424FC8A53CC9: "암시적으로 정의된 'operator<=>'의 반환 유형은 %select{|멤버|기반 클래스}0 %1의 세-way 비교에 대한 반환 유형 %2가 표준 비교 범주 유형이 아니므로 추론할 수 없습니다"
# "return type of defaulted 'operator<=>' cannot be deduced because three-way comparison for %select{|member|base class}0 %1 has a deduced return type and is not yet defined"
H0105A22E2A8D: "기본 제공된 'operator<=>'의 반환 형식을 추론할 수 없습니다. %select{ |멤버|기반 클래스 }0 %1의 3방향 비교가 추론된 반환 형식을 가지고 있으며 아직 정의되지 않았기 때문입니다."
# 'return type of out-of-line definition of %q0 differs from that in the declaration'
H469315680A98: '%q0의 inline이 아닌 정의의 반환 타입이 선언과 다릅니다'
# 'return type of virtual function %0 is not covariant with the return type of the function it overrides (%1 has different qualifiers than %2)'
H00BA4129869D: '가상 함수 %0의 반환 타입은 오버라이딩한 함수의 반환 타입과 공변이 아닙니다 (%1이 %2와 다른 자격 증명자를 가지고 있습니다)'
# 'return type of virtual function %0 is not covariant with the return type of the function it overrides (%1 is incomplete)'
HE8582E3BF357: '가상 함수 %0의 리턴 타입은 오버라이드하는 함수의 리턴 타입과 공변하지 않습니다 (%1가 완전하지 않습니다)'
# 'return type of virtual function %0 is not covariant with the return type of the function it overrides (%1 is not derived from %2)'
H5A21B37900C4: '가상 함수 %0의 반환 타입은 오버라이딩한 함수의 반환 타입과 공변이 아닙니다. (%1은 %2를 상속받지 않았습니다)'
# 'return type of virtual function %0 is not covariant with the return type of the function it overrides (class type %1 does not have the same cv-qualification as or less cv-qualification than class type %2)'
H2AB9EE663373: '가상 함수 %0의 리턴 타입은 오버라이드한 함수의 리턴 타입과 공변하지 않습니다 (클래스 타입 %1은 클래스 타입 %2와 같은 cv 자격을 가지고 있거나, 그보다 적은 cv 자격을 가지고 있지 않습니다)'
# 'return type of virtual function %3 is not covariant with the return type of the function it overrides (ambiguous conversion from derived class %0 to base class %1:%2)'
H94F1AF985110: '가상 함수 %3의 반환 형식은 오버라이드하는 함수의 반환 형식과 공변적이지 않습니다 (파생 클래스 %0에서 기반 클래스 %1로의 모호한 형변환: %2)'
# "return value not in expected state; expected '%0', observed '%1'"
H8EF54209E2EA: "return 값이 예상한 상태가 아닙니다; 예상된 값 '%0', 관측된 값 '%1'"
# 'return value of %0 is a large (%1 bytes) pass-by-value object; pass it by reference instead ?'
HA1B074D05D38: '리턴 값 %0는 %1 바이트 크기의 큰 값으로 전달되는 객체입니다; 대신 참조를 통해 전달하는 것이 좋지 않나요?'
# 'returning %select{address of|reference to}0 local temporary object'
H0D9CD7C30605: '지역 임시 객체의 %select{주소|참조}0을 반환합니다'
# 'returning address of label, which is local'
H7C6FDC7A79CE: '지역인 라벨의 주소를 반환합니다'
# 'returning block that lives on the local stack'
HFB5C6DCAD180: '로컬 스택에 위치한 블록을 반환합니다'
# "returning pointer %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
H524B3D4E5221: "포인터 %1을 반환할 때는 %0 %select{'%2'|'%2를 독점적으로'}3를 유지해야 합니다"
# "returning pointer to variable %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
HC47B423E80E3: "변수 %1에 대한 포인터를 반환하려면 %0 %select{'%2'|'%2만'}3를 유지해야 합니다"
# 'returning reference to local temporary object'
H3C7B38DADD40: '로컬 임시 객체에 대한 참조를 반환합니다'
# "returning the value that %1 points to by reference requires holding %0 %select{'%2'|'%2' exclusively}3"
HDFB7294684C5: "%1이 가리키는 값을 참조로 반환하는 것은 %0을 %select{'%2'|'%2' 전용으로}3 획득해야 합니다"
# "returning variable %1 by reference requires holding %0 %select{'%2'|'%2' exclusively}3"
H5E5D0E85F387: "변수 %1을 참조로 반환하려면 %0 %select{'%2'|'%2' 전용으로}3를 보유해야 합니다"
# "rewriter doesn't support user-specified control flow semantics for @try/@finally (code may not execute properly)"
H9C522D3EEF6D: '리라이터는 @try/@finally에 대한 사용자 지정 제어 흐름 세마닉스를 지원하지 않습니다(코드가 제대로 실행되지 않을 수 있습니다)'
# 'rewriting block literal declared in global scope is not implemented'
HC8DC37202696: '전역 범위에서 선언된 블록 리터럴의 재작성은 지원되지 않았습니다'
# 'rewriting sub-expression within a macro (may not be correct)'
H72B7281F7712: '매크로 내의 하위 표현식 재작성(정확하지 않을 수 있음)'
# 'right hand operand to %0 has non-pointer-to-member type %1'
H53A963FA3084: '오른쪽 피연산자 %0은 멤버 포인터가 아닌 유형 %1을 가지고 있습니다.'
# "right shifting a 'bool' implicitly converts it to 'int'"
HEDBEE20D2831: 'bool에 우측 시프트 연산을 적용하면 암시적으로 int로 변환됩니다.'
# 'rocPrim path, required by the HIP Standard Parallel Algorithm Acceleration library, used to implicitly include the rocPrim library'
HD40BA7FFEFEE: 'rocPrim 경로, HIP 표준 병렬 알고리즘 가속화 라이브러리에 의해 필요로 하며, rocPrim 라이브러리를 암시적으로 포함하기 위해 사용됩니다'
# 'rocThrust path, required by the HIP Standard Parallel Algorithm Acceleration library, used to implicitly include the rocThrust library'
H2F4B1626A7F1: 'rocThrust 경로는 HIP 표준 병렬 알고리즘 가속 라이브러리에 의해 필요하며, rocThrust 라이브러리를 암시적으로 포함시키기 위해 사용됩니다'
# 'run retpoline insertion pass'
H57D5B6539CD2: '리트폴린 삽입 패스 실행'
# 'run veneer elimination pass'
HC2BE3F62417A: '바니어 제거 패스 실행'
# "runpath search paths do not match: '%0' (provided) vs '%1' (found)"
H2CB428691FF3: "runpath 검색 경로가 일치하지 않습니다: '%0' (제공됨) vs '%1' (발견됨)"
# "runpath search paths missing from %0: '%1'"
H427437B03484: "실행 경로 검색 경로가 %0에서 누락되었습니다: '%1'"
# 'rvalue reference %diff{to type $ cannot bind to lvalue of type $|cannot bind to incompatible lvalue}0,1'
H5D62614FC181: 'rvalue 참조 %diff{형식 $의 rvalue 참조는 형식 $의 lvalue에 결합할 수 없습니다.|호환되지 않는 lvalue에 결합할 수 없습니다.}0,1'
# 'rvalue reference type %0 is not allowed in exception specification'
H63B188C37A7C: 'rvalue reference type %0는 예외 지정식에서 허용되지 않습니다'
# 'rvalue references are a C++11 extension'
HE6F99D294F8D: 'rvalue 참조는 C++11 확장입니다'
# 'rvalue references are incompatible with C++98'
HBB045EE53C13: 'rvalue 참조는 C++98과 호환되지 않습니다'
# 's'
HA0F1490A20D0: 's'
# 'safe buffers debug: %0'
H6B8774B1FDA7: '안전한 버퍼 디버그: %0'
# 'safety buffer size'
H48F48464759C: '안전 버퍼 크기'
# 'same map type modifier has been specified more than once'
HE40C50BE338F: '같은 맵 타입 수정자가 여러 번 지정되었습니다'
# 'same motion modifier has been specified more than once'
H855EE2722E18: '같은 motion modifier가 여러 번 지정되었습니다'
# 'same pointer dereferenced in multiple different ways in map clause expressions'
H176F03468FDB: '맵 절 표현식에서 동일한 포인터가 여러 가지 다른 방식으로 접근되었습니다'
# 'sampler initializer has invalid %0 bits'
H18D45D49E7B9: '샘플러 초기화자는 유효하지 않은 %0 비트를 가집니다.'
# 'sampler type cannot be used with the __local and __global address space qualifiers'
H2695DF30EE8D: '샘플러 유형은 __local 및 __global 주소 공간 자격어와 함께 사용할 수 없습니다'
# 'sampler_t initialization requires 32-bit integer, not %0'
HB7C873D08ECC: 'sampler_t 초기화에는 32비트 정수가 필요하며, %0는 사용할 수 없습니다'
# 'sampler_t variable required - got %0'
H54F7785F9F3D: 'sampler_t 변수가 필요합니다 - %0가 제공됨'
# 'sanstats Options'
H8526EFD0A943: 'sanstats 옵션'
# 'satisfaction of constraint %0 depends on itself'
H172A48B0FE13: '제약 조건 %0의 충족 여부가 자신에게 의존합니다'
# 'save recorded profile to a file'
H0DD7B7A894BB: '기록된 프로필을 파일에 저장합니다'
# 'scalar initialized from empty initializer list is incompatible with C++98'
H4040E7512491: '스칼라 변수가 빈 초기화자 목록으로 초기화되면 C++98과 호환되지 않습니다'
# 'scalar initializer cannot be empty'
HD3067EEE76AC: '스칼라 초기자는 비워둘 수 없습니다'
# 'scalar operand type has greater rank than the type of the vector element. (%0 and %1)'
H2C50DCFF8689: '스칼라 피연산자의 형식이 벡터 요소의 형식보다 더 높은 계층을 가집니다. (%0과 %1)'
# 'scale argument must be 1, 2, 4, or 8'
H325DB8FF3A78: '스케일 인수는 1, 2, 4 또는 8이어야 합니다'
# 'scale factor for the latch probability. Value should be greater than 1. Lower values are ignored'
HAACE1BBE5003: '락치 확률의 스케일 인자입니다. 값은 1보다 커야 합니다. 작은 값들은 무시됩니다'
# 'scale of asan shadow mapping'
H538257B2498C: 'ASAN 샤도우 매핑의 비율'
# 'scale of memprof shadow mapping'
H256DA014D3E2: '메모리 프로파일링 쉐이도우 매핑의 범위'
# 'scale to be applied while reporting dyno stats'
H9327CA23C998: '다이노 통계를 보고할 때 적용되는 스케일'
# 'scoped enumeration requires a name'
H38F857947248: '범위 지정 열거형은 이름이 필요합니다'
# 'scoped enumerations are a C++11 extension'
H880FA70730D4: '범위 제한 열거형은 C++11 확장 기능입니다'
# 'scoped enumerations are incompatible with C++98'
H8FFFE671E01D: '범위 지정 열거형은 C++98과 호환되지 않습니다'
# 'score expressions in the OpenMP context selector need to be constant; %0 is not and will be ignored'
HBAE673BA4B11: 'OpenMP 컨텍스트 선택기에서 점수 표현식은 상수여야 합니다; %0는 그렇지 않아서 무시될 것입니다'
# "search path used: '%0'"
H5005F53FE066: "사용된 검색 경로: '%0'"
# "second argument to 'va_arg' is of ARC ownership-qualified type %0"
H5B02CB112F2F: 'va_arg 함수의 두 번째 인자는 ARC 소유권 지정 타입 %0입니다.'
# "second argument to 'va_arg' is of abstract type %0"
HB0CBA3C6712C: 'va_arg의 두 번째 인자는 추상 타입입니다: %0'
# "second argument to 'va_arg' is of array type %0; this va_arg has undefined behavior because arguments will never be compatible with array type"
H0271D72D02D0: 'va_arg의 두 번째 인자는 배열 형식 %0입니다. 이는 인수가 배열 형식과 호환될 수 없기 때문에 미정의 동작을 일으킵니다'
# "second argument to 'va_arg' is of incomplete type %0"
HBAB6DD203AC7: 'va_arg의 두 번째 인수는 완전하지 않은 형식 %0입니다'
# "second argument to 'va_arg' is of non-POD type %0"
H6E23523199DB: 'va_arg의 두 번째 인수의 타입이 비POD 타입 %0입니다'
# "second argument to 'va_arg' is of promotable type %0; this va_arg has undefined behavior because arguments will be promoted to %1"
HD77AAC429CAF: 'va_arg의 두 번째 인수는 %0epromotable 형식입니다; 인수가 %1으로 프로모트되기 때문에 이 va_arg는 정의되지 않은 동작을 합니다'
# "second argument to 'va_start' is not the last non-variadic parameter"
H37CA82AB0144: 'va_start의 두 번째 인수가 가변 인자가 아닌 마지막 매개변수가 아닙니다'
# 'second argument to __builtin_alloca_with_align is supposed to be in bits'
HF3ADBC91450B: '두 번째 인수는 __builtin_alloca_with_align의 비트 단위여야 합니다'
# 'second argument to __builtin_annotation must be a non-wide string constant'
HB28F8D41E677: '두 번째 인수는 너비 없는 문자열 상수여야 합니다'
# 'second argument to __builtin_call_with_static_chain must be of pointer type'
H9D3B291ADD1F: '__builtin_call_with_static_chain의 두 번째 인수는 포인터 타입이어야 합니다'
# "section argument to 'patchable_function_entry' attribute is not valid for this target: %0"
HBEBC9A622C36: "'patchable_function_entry' 속성의 섹션 인수는 이 타겟에 유효하지 않습니다: %0"
# 'section attribute is specified on redeclared variable'
H4BE9B9505588: 'section attribute가 재선언된 변수에 지정되었습니다.'
# 'section length is evaluated to a negative value %0'
HDAA24A68E89D: '섹션 길이는 음수 값 %0로 평가되었습니다'
# 'section length is unspecified and cannot be inferred because subscripted value is %select{not an array|an array of unknown bound}0'
HD324F8149A40: '섹션 길이가 지정되지 않았고 추론할 수 없습니다. 왜냐하면 서브스크립트된 값이 %select{배열이 아닙니다|경계가 알려지지 않은 배열}0이기 때문입니다.'
# 'section of pointer to function type %0'
HDFC73840E7DC: '함수 타입 포인터의 섹션 %0'
# 'section of pointer to incomplete type %0'
HFA4996C0EBB1: '불완전한 타입 %0 포인터의 섹션'
# 'section stride is evaluated to a non-positive value %0'
H2C7B2A05B911: '섹션 스트라이드가 음의 값인 %0로 계산되었습니다.'
# 'see attribute on parameter here'
HDD0675B1BF06: '이 매개변수의 속성 참조하세요'
# 'seed for randomization'
HD63DCBC599F4: '난수 생성을 위한 시드'
# "selected '%select{begin|end}0' %select{function|template }1%2 with iterator type %3"
H752B6650220E: "선택된 '%select{begin|end}0' %select{함수|템플릿 }1%2 반복자 유형 %3과 함께"
# "selected 'operator<=>' for %select{|member|base class}0 %1 declared here"
H810A0D73AD55: "선택된 'operator<=>'를 %select{ |멤버|기반 클래스 }0 %1에서 여기서 선언되었습니다"
# 'selector element is not a valid lvalue'
H0BFE26B0616A: '선택자 요소는 유효한 lvalue가 아닙니다.'
# 'selector element of type %0 cannot be a constant lvalue expression'
H9F3EFE55FA69: '타입 %0의 선택자 요소는 상수 좌辺값 표현式일 수 없습니다'
# 'selector element type %0 is not a valid object'
HED5168FB3348: '선택기 요소 유형 %0는 유효한 개체 유형이 아닙니다'
# 'semantic annotations must be present for all parameters of an entry function or patch constant function'
H8F1EA44B7AC0: '의미적 주석은 진입 함수 또는 패치 상수 함수의 모든 매개변수에 있어야 합니다'
# 'semicolon before method body is ignored'
H600E31190711: '메소드 본문 앞의 세미콜론은 무시됩니다'
# 'semicolon terminating header import declaration cannot be produced by a macro'
HD5CFDD7201E4: '세미콜론으로 종료되는 헤더 임포트 선언은 매크로로 생성될 수 없습니다.'
# 'set format in which header info is emitted'
H2BE1FC27A3B2: '헤더 정보가 출력되는 형식을 설정합니다'
# 'set the flag that enables filtering header information'
H433BB7B2C953: '헤더 정보 필터링을 활성화하는 플래그를 설정합니다'
# 'set the incremental array construction buffer size (default=32)'
H062EDCFEADF9: '인크리멘탈 배열 생성 버퍼 크기를 설정합니다 (기본값=32)'
# 'set verbosity level for diagnostic output'
HA7F31A34A582: '진단 출력의 상세도 수준을 설정합니다'
# 'sets a boolean flag for every edge'
H5B3492ACEF7D: '모든 edge에 대해 boolean 플래그를 설정합니다'
# 'setter and getter must both be synthesized, or both be user defined, or the property must be nonatomic'
H13B288111B84: 'setter와 getter는 모두 자동 생성되거나, 모두 사용자 정의되거나, 해당 속성이 nonatomic이어야 합니다'
# 'setter cannot be specified for a readonly property'
H0B75386E5DBF: 'setter는 읽기 전용 속성에 지정할 수 없습니다'
# 'setting the floating point evaluation method to `source` on a target without SSE is not supported'
H3CBE26190DE7: 'SSE가 없는 대상에서 부동소수점 평가 방법을 `source`로 설정하는 것은 지원되지 않습니다'
# 'several methods with selector %0 of mismatched types are found for the @selector expression'
H992F0A773FBB: '@selector 표현식에서 %0 선택자를 가진 타입이 서로 맞지 않는 여러 메서드가 발견되었습니다'
# 'share stubs across functions'
H4D76BB47577B: '함수 간에 스텁을 공유하다'
# 'shift count %0 >= width of type %1 (%2 bit%s2)'
HF6F9C4B1183E: '비트 시프트 카운트 %0가 %1 타입의 너비(%2비트) 이상입니다'
# 'shift count >= width of type'
H64BC6739BC0B: '비트 시프트 카운트가 타입의 크기 이상입니다'
# 'shift count is negative'
H49401E14D24E: 'シ프트 카운트가 음수입니다'
# 'shifting a negative signed value is undefined'
H08F0D0D67884: '부호 있는 음의 값을 시프트하는 것은 정의되지 않은 동작입니다'
# 'shorten instructions'
H31FAC4015C01: '명령문을 단축하십시오'
# 'show a graph.'
HDBFEE5F65752: '그래프를 표시합니다.'
# 'show execution count of functions in binary 2 as a ratio of the total samples in binary 1 - make sure both profiles have equal collection time and sampling rate for this to make sense'
H7302A3496B1D: '이진 파일 2의 함수 실행 횟수를 이진 파일 1의 전체 샘플 수 대비 비율로 표시 - 이 비교가 의미가 있도록 두 프로파일이 동일한 수집 시간과 샘플링 속도를 갖는지 확인하십시오'
# 'show in text.'
H8201270E0209: '문서에서 표시합니다.'
# 'show profile density details'
HA588BE6E194B: '프로파일 밀도 세부 사항을 표시합니다'
# 'show section contents after fixups have been applied'
HF6C65D702470: '수정이 적용된 후의 섹션 내용을 표시'
# 'signed bit-field %0 needs an extra bit to represent the largest positive enumerators of %1'
HE118008121A9: '부호 있는 비트 필드 %0는 %1의 가장 큰 양의 열거자를 표현하기 위해 추가 비트가 필요합니다'
# 'signed bit-field %0 needs an extra bit to represent the largest positive enumerators of preferred type %1'
H16B76E9FE00B: '선호 유형 %1의 가장 큰 양수 열거자를 표현하기 위해 부호 있는 비트 필드 %0는 추가 비트가 필요합니다'
# 'signed left shift discards bits'
HD469BF80AF3C: '부호 있는 왼쪽 시프트 연산이 비트를 무시합니다'
# 'signed shift result (%0) requires %1 bits to represent, but %2 only has %3 bits'
HC5B9F5083ED5: '부호 있는 시프트 결과 (%0)를 표현하려면 %1 비트가 필요하지만 %2는 %3 비트 밖에 없습니다'
# "signed shift result (%0) sets the sign bit of the shift expression's type (%1) and becomes negative"
H95CD10E060D8: '부호 있는 시프트 결과 (%0)는 시프트 표현식의 타입 (%1)의 부호 비트를 설정하고 음수가 됩니다'
# "signedness of format specifier '%0' is incompatible with '%1'"
H0E3D0B14B46F: "포맷 지정자의 부호화 '%0'는 '%1'과 호환되지 않습니다"
# 'signing a null pointer will yield a non-null pointer'
H25C3D501EB46: 'null 포인터를 서명하면 non-null 포인터가 생성됩니다'
# 'silence by adding parentheses to mark code as explicitly dead'
H99754744B060: '괄호를 추가하여 코드를 명시적으로 사망한 것으로 표시하여 경고를 무시할 수 있습니다'
# 'similar constraint expression here'
HC25A9009F181: '여기에도 유사한 제약 표현이 있습니다'
# 'similar constraint expressions not considered equivalent; constraint expressions cannot be considered equivalent unless they originate from the same concept'
H671259A4BAC3: '유사한 제약 표현식은 동등하지 않다고 간주되지 않습니다; 제약 표현식은 동일한 개념에서 비롯되지 않는 한 동등하지 않다고 간주될 수 없습니다'
# "similar to '-lite-threshold-pct' but specify threshold using absolute function call count. I.e. limit processing to functions executed at least the specified number of times."
HAE7D7FD96C23: "'-lite-threshold-pct'와 유사하지만 절대 함수 호출 횟수를 사용하여 임계값을 지정합니다. 즉, 지정된 횟수 이상 실행된 함수에 한해 처리를 제한합니다."
# 'simple ddg dot graph'
H18F32B7E23D9: '단순한 DDG DOT 그래프'
# 'simple-rename options'
H99366DD6F3BD: '단순-리네임 옵션'
# 'simplify conditional tail calls by removing unnecessary jumps'
H041707E8A1C3: '필요없는 점프를 제거하여 조건부 테일 콜을 간소화합니다'
# 'simplify loads from read-only sections by replacing the memory operand with the constant found in the corresponding section'
H05E90663FB35: '읽기 전용 섹션에서의 로드를 단순화하기 위해 메모리 연산자를 해당 섹션에서 찾은 상수로 대체합니다'
# "single declaration is expected after 'declare %select{simd|variant}0' directive"
H178440D95E1D: 'declare %select{simd|variant}0 지시문 이후에 단일 선언이 요구됩니다'
# 'single subscript expressions are not allowed for matrix values'
H6751A19F6DB9: '행렬 값에 대해서는 단일 서브스크립트 표현식이 허용되지 않음'
# 'size argument in %0 call appears to be size of the source; expected the size of the destination'
HA69933A2CC96: '%0 호출에서 size 인수가 소스의 크기로 보입니다; 목적지의 크기를 기대했습니다'
# 'size argument in %0 call is a comparison'
HAC4E42C8E89B: '인수 %0 호출에서 size 인수가 비교 연산식입니다'
# "size argument in 'strncat' call appears to be size of the source"
HBE6DF8480F3A: 'strncat 호출의 size 인수는 출처의 크기인 것 같습니다'
# 'size must be %select{1, 2, or 4|1, 2, 4, 12 or 16}0'
H5666676F632D: '크기는 %select{1, 2 또는 4|1, 2, 4, 12 또는 16}0 중 하나여야 합니다.'
# "size of '__builtin_bit_cast' source type %0 does not match destination type %1 (%2 vs %3 bytes)"
HE2800B62712B: "'__builtin_bit_cast' 소스 타입 %0의 크기가 목적지 타입 %1과 일치하지 않습니다 (%2 vs %3 바이트)"
# "size of array element of type %0 (%1 bytes) isn't a multiple of its alignment (%2 bytes)"
H64B3D7C6AA54: '타입 %0의 배열 요소 크기(%1 바이트)가 정렬 크기(%2 바이트)의 배수가 아닙니다'
# 'size of array has non-integer type %0'
HE09F852059B1: '배열의 크기가 정수가 아닌 %0 타입입니다.'
# 'size of feature field in .altinstructions'
H2B6C1D1A943E: '.altinstructions 내 feature 필드의 크기'
# "size of register '%0' does not match variable size"
HECA9BDA68860: "레지스터 '%0'의 크기가 변수 크기와 일치하지 않습니다"
# 'sizeof on array function parameter will return size of %0 instead of %1'
HFA0A8C5A6400: '배열 형식의 함수 매개변수에 sizeof를 적용하면 %0 대신 %1의 크기를 반환합니다'
# 'sizeof on pointer operation will return size of %0 instead of %1'
H23C83EADD90C: '포인터 연산에 sizeof를 적용하면 %1 대신 %0의 크기를 반환합니다'
# 'skip access specifiers'
HB22E60CB51DB: '접근 지정자를 건너뛰기'
# 'skip calling convention'
HA89A2E2093C7: '호출 규약 건너뛰기'
# 'skip member types'
HE3F86CF4D54B: '멤버 형식 건너뛰기'
# 'skip non-simple functions in reporting'
H7F9F6F20766F: '보고 시 비단순 함수 건너뛰기'
# 'skip perf and read data from a pre-aggregated file format'
H38F758DFB377: 'perf를 건너뛰고 이미 집계된 파일 형식에서 데이터를 읽기'
# 'skip perf event collection by supplying a perf-script output in a textual format'
HD6505A3AF86B: 'perf 이벤트 수집을 건너뛰려면 텍스트 형식의 perf 스크립트 출력을 제공하세요.'
# 'skip processing of cold functions'
H2FAB1AD4A339: '콜드 함수의 처리를 건너뛰기'
# 'skip return types'
H3988159D97D2: '리턴 타입 무시'
# 'skip variable types'
H1C4CB11B7B2B: '변수 유형을 건너뛰기'
# "skipping '%0' because module declaration of '%1' lacks the 'framework' qualifier"
H07A078D1E04E: "'%0'을(를) '%1'의 모듈 선언에 'framework' 지정자가 없어서 건너뜁니다."
# 'skipping stray token'
HF5D19BFCA4A8: '고아진 토큰 건너뛰기'
# 'sort hot data by hot function usage and count'
H35D38C633287: '핫 함수 사용량과 카운트에 따라 핫 데이터를 정렬합니다'
# 'sort hot data by read counts'
HC3E7276E6170: '읽기 카운트로 인기 데이터 정렬'
# 'sort ordering'
HE318259881C5: '정렬 순서'
# 'sort output by this field'
H610F666D308E: '이 필드로 출력을 정렬합니다'
# 'sort stack allocations'
HB4DFBCC44FE6: '스택 할당 정렬'
# 'sorted by all names'
H8915B99CE6ED: '모든 이름에 따라 정렬'
# 'source file is not valid UTF-8'
HDC95C446AFAD: '소스 파일이 유효한 UTF-8이 아닙니다.'
# 'source manager location address space usage:'
H7D02F3625956: '소스 관리기 위치 주소 공간 사용:'
# 'specialization of member %q0 does not specialize an instantiated member'
H7EB7CDEAD3CD: '멤버 %q0의 특수화는 인스턴스화된 멤버를 특수화하지 않습니다'
# 'specified %0 type tag requires a null pointer'
HEFCCEFE3C17F: '지정된 %0 유형 태그는 null 포인터가 필요합니다'
# "specified the same parameter '%0' multiple times"
HA300C97F904A: "동일한 매개변수 '%0'을(를) 여러 번 지정했습니다"
# 'specifies thread count for the multithreading for updating DWO debug info'
H230218760941: 'DWO 디버그 정보 업데이트를 위한 멀티스레딩에 사용되는 스레드 수를 지정합니다'
# 'specify a target CPU'
H6DAAF9946704: '목표 CPU를 지정하십시오'
# 'specify a target triple'
H91E21A4D2F5C: '타겟 트리플을 지정하십시오.'
# 'specify a tune CPU'
H484461AF94A8: '튜닝 대상 CPU를 지정하세요'
# 'specify path of the runtime hugify library'
H05DF4B0878FF: '런타임 hugify 라이브러리 경로를 지정하세요'
# 'specify path of the runtime instrumentation library'
HC0D79561313D: '런타임 인스트루먼테이션 라이브러리의 경로를 지정하십시오'
# 'specify that .altinstructions has padlen field'
H09DED786C540: 'padlen 필드가 있는 .altinstructions를 지정합니다'
# 'specify the target features'
H68C8195F1EB5: '타겟 특성을 지정하세요.'
# "specifying 'uuid' as an ATL attribute is deprecated; use __declspec instead"
H12B975086F19: "ATL 속성으로 'uuid'를 지정하는 것은 비추천 됩니다; 대신 __declspec을 사용하세요"
# 'specifying OpenMP directives with [[]] is an OpenMP 5.1 extension'
H4B0556017370: ' [[]]을 사용하여 OpenMP 지시문을 지정하는 것은 OpenMP 5.1 확장 기능입니다'
# 'specifying OpenMP directives with [[]] is incompatible with OpenMP standards before OpenMP 5.1'
H8022C700FE36: 'OpenMP 지시문을 [[]]로 지정하는 것은 OpenMP 5.1 이전의 OpenMP 표준과 호환되지 않습니다'
# 'specifying an identifier within `#pragma pack` is not supported on this target'
H6F2B8F9FE9C4: '`#pragma pack` 내부에서 식별자 지정은 이 타겟에서는 지원되지 않습니다'
# "specifying both a name and alignment to 'pop' is undefined"
HC71C880E8806: "이름과 정렬을 모두 'pop'에 지정하는 것은 정의되지 않았습니다"
# "specifying character '%0' with a universal character name is incompatible with C standards before C23"
H9E4A97D8B259: "유니버설 캐릭터 이름을 사용하여 '%0' 문자를 지정하는 것은 C23 이전의 C 표준과 호환되지 않습니다"
# "specifying character '%0' with a universal character name is incompatible with C++98"
H2678BC1F681E: "유니버설 캐릭터 네임으로 '%0' 문자를 지정하는 것은 C++98과 호환되지 않습니다."
# "specifying vector types with the 'mode' attribute is deprecated; use the 'vector_size' attribute instead"
H29212F917029: "벡터 유형을 'mode' 속성으로 지정하는 것은 더 이상 권장되지 않습니다. 대신 'vector_size' 속성을 사용하세요"
# 'speculative load hardening does not protect functions with asm goto'
H95EDE5332D8C: '예측 로드 강화는 asm goto가 있는 함수를 보호하지 않습니다'
# 'spirv.$TypedPointerType'
HDE833BFC0A0D: 'spirv.$TypedPointerType'
# 'split C++ exception handling code'
H77F537E188DE: 'C++ 예외 처리 코드 분할'
# 'split all basic blocks of each function into fragments such that each fragment contains exactly a single basic block'
H4736D758A4A7: '각 함수의 모든 기본 블록을 프래그먼트로 분할하여 각 프래그먼트가 정확히 하나의 기본 블록을 포함되도록 합니다'
# 'split each function into N fragments at a randomly chosen split points (ignoring any available profiling information)'
H5EA52FAFF0B6: '각 함수를 N개의 조각으로 분할하며, 무작위로 선택된 분할 지점에서 수행합니다 (사용 가능한 프로파일링 정보를 무시함)'
# 'split each function into a hot and cold fragment at a randomly chosen split point (ignoring any available profiling information)'
H2575993535E9: '각 함수를 무작위로 선택된 분할 지점으로 hot과 cold 프래그먼트로 분할(사용 가능한 프로파일링 정보를 무시함)'
# 'split each function into a hot and cold fragment using profiling information'
H6FB4CEE61F8E: '프로파일링 정보를 사용하여 각 함수를 핫과 콜드 프래그먼트로 분할합니다'
# 'split each function into a hot, warm, and cold fragment using profiling information'
H39753BA1C3E6: '프로파일링 정보를 사용하여 각 함수를 hot, warm 및 cold 프래그먼트로 분할합니다'
# 'split function only if its main size is reduced by more than given amount of bytes. Default value: 0, i.e. split iff the size is reduced. Note that on some architectures the size can increase after splitting.'
H80577181729E: '주 크기가 지정된 바이트 수보다 감소한 경우에만 함수를 분할합니다. 기본 값: 0, 즉 크기가 감소한 경우에만 분할합니다. 참고로, 일부 아키텍처에서는 분할 후 크기가 증가할 수 있습니다.'
# 'split functions into fragments'
HE833096B1246: '함수를 조각으로 분할합니다'
# 'split jump tables section into hot and cold based on function execution frequency'
H593FAF497273: '함수 실행 빈도에 따라 점프 테이블 섹션을 hot과 cold로 분할합니다'
# 'split-file Options'
HDBFADA679092: 'split-file 옵션'
# "stack frame size (%0) exceeds limit (%1) in '%2'"
HCF0AF62F4A65: "스택 프레임 크기(%0)가 제한(%1)을 초과했습니다. '%2'에서 발생했습니다"
# 'stack nearly exhausted; compilation time may suffer, and crashes due to stack overflow are likely'
HD310C1B31961: '스택이 거의 소진되었습니다; 컴파일 시간이 증가할 수 있으며, 스택 오버플로로 인한 프로그램 중단이 발생할 가능성이 있습니다'
# "standard library implementation of %0 is not supported; %select{member '%2' does not have expected form|member '%2' is missing|the type is not trivially copyable|the type does not have the expected form}1"
H8A51A30A514F: '표준 라이브러리 구현의 %0은 지원되지 않습니다; %select{%2 멤버가 예상한 형식과 다릅니다|%2 멤버가 없습니다|이 타입은 단순 복사 가능(trivially copyable)이 아닙니다|이 타입은 예상한 형식과 다릅니다}1'
# 'standard library not linked and so no interrupt vector table or compiler runtime routines will be linked'
H3B6E22A7AD97: '표준 라이브러리가 연결되지 않았기 때문에 인터럽트 벡터 테이블이나 컴파일러 러타임 루틴들이 연결되지 않을 것입니다'
# 'star modifier used outside of function prototype'
HA2B9806ED1A1: '별표 수식자가 함수 프로토타입 밖에서 사용되었습니다'
# "state of variable '%0' must match at the entry and exit of loop"
H7D285ABC5B72: "변수 '%0'의 상태는 루프의 진입점과 출구에서 일치해야 합니다"
# "statement after '#pragma omp dispatch' must be a direct call to a target function or an assignment to one"
H172FE1A4272E: "'#pragma omp dispatch' 지시문 이후의 문은 타겟 함수에 대한 직접 호출 또는 해당 함수에 대한 할당이어야 합니다"
# "statement associated with OpenACC 'atomic%select{| %1}0' directive is invalid"
H42056AC9B64A: "OpenACC 'atomic%select{| %1}0' 지시문과 연결된 문이 유효하지 않습니다"
# "statement attribute %0 has higher precedence than function attribute '%select{always_inline|flatten|noinline}1'"
H0AF92FCED836: "문장 속성 %0은 함수 속성 '%select{always_inline|flatten|noinline}1'보다 높은 우선순위를 가집니다"
# 'statement expression not allowed at file scope'
HB4FE90B7D7C8: '파일 범위에서 문 표현을 사용할 수 없습니다.'
# "statement in 'omp %0' directive must be enclosed into a section region"
H69791FF123D5: 'omp %0 디렉티브 내의 문은 섹션 영역 내에 포함되어야 합니다'
# 'statement not allowed in %select{constexpr|consteval}1 %select{function|constructor}0'
HD56C75E5841E: '%select{constexpr|consteval}1 %select{function|constructor}0 내부에서는 문장이 허용되지 않습니다.'
# 'statement requires expression of integer type (%0 invalid)'
H752828F0ECD0: '문장은 정수형 표현식이 필요합니다 (%0 유효하지 않음)'
# 'statement requires expression of scalar type (%0 invalid)'
HFBBF3A578FA4: '문은 스칼라 타입의 표현식을 필요로 합니다. (%0이 유효하지 않습니다.)'
# 'static %0 runtime is not supported on darwin'
H52FFB37B4DFA: 'static %0 런타임은 darwin에서 지원되지 않습니다'
# 'static %select{function|variable}0 %1 is used in an inline function with external linkage'
HBAA29A669BB7: '정적 %select{function|variable}0 %1은 외부 링크지정을 가진 인라인 함수에서 사용되었습니다'
# 'static and non-static member functions with the same parameter types cannot be overloaded'
H455410FE204F: 'static 및 non-static 멤버 함수는 동일한 매개변수 유형으로 오버로딩할 수 없습니다'
# 'static assertion expression is not an integral constant expression'
H4896ABC370E3: '정적 단언 표현식은 정수 상수 표현식이 아닙니다'
# "static assertion failed due to requirement '%0'%select{: %2|}1"
H3D43CA56F16F: "정적 암시가 요구사항 '%0'%select{ : %2|}1로 인해 실패했습니다."
# 'static assertion failed%select{: %1|}0'
H4F7EABF6B0DD: '정적 단언이 실패했습니다%select{: %1|}0'
# 'static const volatile data member must be initialized out of line'
H407C919E04E8: '정적 상수 volatile 데이터 멤버는 라인 외부에서 초기화해야 합니다'
# 'static data member %0 already has an initializer'
H6ACB0F956377: '정적 데이터 멤버 %0는 이미 초기화자가 있습니다'
# 'static data member %0 in union is a C++11 extension'
HA330F37BE63B: '유니온의 정적 데이터 멤버 %0는 C++11 확장 기능입니다'
# 'static data member %0 in union is incompatible with C++98'
HEBF9EACD8366: '유니온 내의 정적 데이터 멤버 %0는 C++98와 호환되지 않습니다'
# 'static data member %0 not allowed in anonymous %select{struct|interface|union|class|enum}1'
HC964FFEFDD87: '익명 %select{struct|interface|union|class|enum}1에 정적 데이터 멤버 %0는 허용되지 않습니다'
# 'static data member %0 not allowed in local %select{struct|interface|union|class|enum}2 %1'
HA56CE2DF143E: '로컬 %select{struct|interface|union|class|enum}2 %1에 정적 데이터 멤버 %0는 허용되지 않습니다'
# 'static data member definition cannot specify a storage class'
HF3222609AACF: '정적 데이터 멤버 정의에서는 저장 클래스 지정자를 지정할 수 없습니다'
# 'static data member of type %0 must be initialized out of line'
H4598A36D5110: '타입 %0인 정적 데이터 멤버는 클래스 바깥에서 초기화되어야 합니다'
# 'static declaration of %0 follows non-static declaration'
H2C721D0B8C3C: '%0의 static 선언이 non-static 선언 뒤에 위치합니다'
# 'static lambdas are a C++23 extension'
H0728106ADDA2: '정적 람다는 C++23 확장 기능입니다'
# 'static lambdas are incompatible with C++ standards before C++23'
H81C85F6C724E: '정적 람다는 C++23 이전의 C++ 표준과 호환되지 않습니다'
# 'static member %0 cannot be a bit-field'
HDFCBA261B7FE: '정적 멤버 %0는 비트 필드일 수 없습니다'
# 'static members cannot be declared in an anonymous %select{struct|union}0'
HF2CC0A1A3C82: '정적 멤버는 이름 없는 %select{구조체|유니온}0에 선언할 수 없습니다'
# 'static variable %0 is suspiciously used within its own initialization'
H1CCD7A0167D8: '정적 변수 %0는 자신의 초기화 과정에서 의심스럽게 사용되고 있습니다'
# 'static_cast between pointer-to-function and pointer-to-object is a Microsoft extension'
H747267A37B70: 'static_cast을 함수 포인터와 객체 포인터 사이에서 사용하는 것은 Microsoft의 확장 기능입니다'
# 'std::%0 must be a class template with a single type parameter'
HAA8558BD9D00: 'std::%0는 단일 유형 매개변수를 갖는 클래스 템플릿이어야 합니다'
# "std::coroutine_handle isn't a class template"
H20FD07579F32: 'std::coroutine_handle은 클래스 템플릿이 아닙니다'
# "std::coroutine_handle must have a member named '%0'"
HC01B7EC5D8D7: "std::coroutine_handle는 '%0'이라는 이름의 멤버를 가져야 합니다"
# "std::coroutine_traits isn't a class template"
H3D3F8F520E5F: 'std::coroutine_traits는 클래스 템플릿이 아닙니다'
# 'std::nothrow must be a valid variable declaration'
H81985EEDEA6B: 'std::nothrow는 유효한 변수 선언이어야 합니다'
# 'std::nothrow was not found; include <new> before defining a coroutine which uses get_return_object_on_allocation_failure()'
H553185766FEB: 'std::nothrow가 발견되지 않았습니다; get_return_object_on_allocation_failure()를 사용하는 코루틴을 정의하기 전에 <new>를 포함시켜야 합니다'
# "step simple modifier is exclusive and cannot be use with 'val', 'uval' or 'ref' modifier"
H61FE9B0F27A0: "step 단순 수정자는 배타적이며 'val', 'uval' 또는 'ref' 수정자와 함께 사용할 수 없습니다"
# 'still within definition of %q0 here'
HE0627D20A1B5: '여전히 여기서 %q0의 정의 내부에 있습니다'
# 'stop processing once we have enough to compare two binaries'
H5E734E25A522: '충분한 정보를 얻었을 때 두 바이너리를 비교하기 위해 처리를 중단합니다'
# 'storage class specified for a member declaration'
HE2F76CA3682F: '멤버 선언에 저장 클래스가 지정되었습니다'
# 'store PCHs in memory'
HAE2E8E366E23: '메모리에 PCHs 저장'
# 'store PCHs on disk'
HB5252992D5B4: '디스크에 PCH 저장'
# 'strategy used to partition blocks into fragments'
H892362B1790A: '블록을 프래그먼트로 분할하는 데 사용되는 전략'
# 'stress rotate selection in aggressive ppc isel for bit permutations'
HAC5B66207D31: '공격적인 ppc isel에서 비트 순열을 위한 스트레스 회전 선택'
# 'strftime format attribute requires 3rd parameter to be 0'
H48F53118805C: 'strftime 포맷 속성은 세 번째 매개변수가 0이어야 합니다'
# 'stride must be greater or equal to the number of rows'
H8F8F20EB9F60: 'stride는 행의 수 이상이어야 합니다'
# 'string is ill-formed as UTF-8 and will become a null %0 when boxed'
H978281414E51: '문자열이 UTF-8 형식으로 유효하지 않으며, 박싱될 때 null %0 값이 됩니다'
# "string literal after 'operator' cannot have an encoding prefix"
HE2D46EB90348: 'operator 뒤의 문자열 리터럴에는 인코딩 접두사가 올 수 없습니다.'
# 'string literal after \'operator\' must be \'""\''
HB2C541BB7B81: 'operator 뒤에 오는 문자열 리터럴은 ""로 되어야 합니다.'
# 'string literal of length %0 exceeds maximum length %1 that %select{C90|ISO C99|C++}2 compilers are required to support'
H446F1FE51F67: '길이가 %0인 문자열 리터럴은 %select{C90|ISO C99|C++}2 컴파일러가 지원해야 하는 최대 길이 %1을 초과합니다'
# 'string literal operator templates are a GNU extension'
HC7C4AAEBD81D: '문자열 리터럴 연산자 템플릿은 GNU 확장 기능입니다'
# 'string literal with user-defined suffix cannot be used here'
H0A403620271A: '사용자 정의 접미사를 가진 문자열 리터럴은 여기서 사용할 수 없습니다'
# 'string literals that exceed this length will use a hash value as their symbol name'
HA27BA101BC94: '이 길이를 초과하는 문자열 리터럴은 그 기호 이름으로 해시 값을 사용합니다'
# 'string to set default kind values'
H7121B365791A: '기본 종류 값 설정을 위한 문자열'
# "strip 'repz' prefix from 'repz retq' sequence (on by default)"
H5E0A0D55638D: "repz 접두사 제거 'repz retq' 시퀀스 (기본 설정에서 활성화됨)"
# 'structured binding declaration in a condition is a C++2c extension'
H7AF1E5D1A2D0: '조건 내에서의 구조체 바인딩 선언은 C++2c 확장 기능입니다'
# 'structured binding declaration in a condition is incompatible with C++ standards before C++2c'
HD456E18D0B36: '구조화된 바인딩 선언을 조건에서 사용하는 것은 C++2c 이전의 C++ 표준과 호환되지 않습니다'
# 'structured binding packs are a C++2c extension '
H041F82FB15BE: '구조화 바인딩 팩은 C++2c 확장 기능입니다'
# 'structured binding packs are incompatible with C++ standards before C++2c'
HD48DDFF6186B: '구조화된 바인딩 팩은 C++2c 이전의 C++ 표준과 호환되지 않습니다.'
# 'structurize SPIRV'
H886FBF76EA85: 'SPIRV 구조화'
# 'style of printing regions'
H063C50F12566: '프린팅 영역의 스타일'
# 'subcommand'
H146947FFD26E: '서브 명령어'
# 'subexpression not valid in a constant expression'
H9779A11486AE: '상수 표현식에서 유효하지 않은 하위 표현식'
# 'submodule %0.%1 not declared in module map'
H1DA53EDBF661: '모듈 맵에 선언되지 않은 하위 모듈 %0.%1'
# "submodule of top-level module '%0' implicitly imported here"
HDAE6F5126C46: "최상위 모듈 '%0'의 하위 모듈이 여기에서 암시적으로 임포트되었습니다"
# 'subobject %select{of type |}0%1 is not initialized'
HF2C7BC6C2C0D: '부객체 %select{형식 |}0%1이 초기화되지 않았습니다'
# 'subobject declared here'
H554F161157BC: '부 객체가 여기서 선언되었습니다'
# 'subscript of a pointer to void is a GNU extension'
H3CC7AA95FFD8: 'void 포인터에 대한 인덱싱은 GNU 확장 기능입니다'
# 'subscript of pointer to %select{incomplete|sizeless}0 type %1'
H1AFEC4E5E6B6: '포인터의 %select{incomplete|sizeless}0 타입에 대한 인덱싱 %1'
# 'subscript of pointer to function type %0'
H768DEE928692: '함수 타입 포인터의 서브스크립트 %0'
# 'subscript of svbool_t is not allowed'
H8F54745267C0: 'svbool_t의 서브스크립트는 허용되지 않습니다'
# 'subscript requires size of interface %0, which is not constant for this architecture and platform'
H10B94DBD4388: '구문 %0의 인터페이스 크기가 필요하지만, 이 아키텍처 및 플랫폼에서는 상수로 결정되지 않았습니다'
# 'subscripted value is not an array or pointer'
HFC1E308C6B30: '인덱싱된 값이 배열 또는 포인터가 아닙니다'
# 'subscripted value is not an array, pointer, or vector'
H1F892D50B541: '인덱싱된 값은 배열, 포인터 또는 벡터가 아닙니다'
# 'substitution failure due to access control is incompatible with C++98'
H09899E5F733A: '접근 제어로 인한 대입 실패는 C++98와 호환되지 않습니다'
# 'substitution into constraint expression resulted in a non-constant expression'
H0CC3DD33E92E: '제약 표현에 대한 치환이 상수 표현이 아닌 결과를 생성했습니다'
# 'subtracted pointers are not elements of the same array'
HBF5BC0994673: '뺄셈을 한 포인터들이 같은 배열의 요소가 아닙니다'
# 'subtraction of pointers to type %0 of zero size'
HAE88E507C99F: '크기가 0인 타입 %0의 포인터 간 뺄셈'
# 'subtraction of pointers to type %0 of zero size has undefined behavior'
H238100FAEBF4: '크기가 0인 %0 타입의 포인터의 뺄셈은 미정行为를 초래합니다'
# 'suffix with parentheses to turn this into a function call'
HBA5C36C9B0F9: '괄호를 추가하여 이를 함수 호출로 만들기'
# 'suggest braces around initialization of subobject'
H122DA545D844: '하위 객체의 초기화에 중괄호를 사용하도록 권장합니다'
# 'sum of call durations'
H97819C630794: '호출 지속 시간의 합'
# "support for '/Yc' and '/Yu' with different filenames not implemented yet; flags ignored"
HC924164CBDE2: "다른 파일 이름과 함께 '/Yc' 및 '/Yu' 옵션 지원은 아직 구현되지 않았습니다; 플래그 무시됨"
# "support for '/Yc' with more than one source file not implemented yet; flag ignored"
H7450874B7BA1: "1개 이상의 소스 파일과 함께 '/Yc' 옵션에 대한 지원은 아직 구현되지 않았습니다; 플래그가 무시됩니다."
# 'support for HLSL language version %0 is incomplete, recommend using %1 instead'
H68BB4F93A02C: 'HLSL 언어 버전 %0에 대한 지원이 미완성입니다. 대신 %1을 사용하는 것을 추천합니다'
# "support for linking stdlibs for microcontroller '%0' is not implemented"
H8995E8434A04: "마이크로컨트롤러 '%0'의 표준 라이브러리 연결을 위한 지원이 구현되지 않았습니다"
# "support for passing the data section address to the linker for microcontroller '%0' is not implemented"
H870D8231D796: "마이크로컨트롤러 '%0'의 데이터 섹션 주소를 링커에 전달하는 기능이 구현되지 않았습니다"
# 'surrounding namespace with visibility attribute ends here'
H4297D0DA8CEA: '가시성 속성을 가진 주변 네임스페이스는 여기서 끝납니다'
# 'surrounding namespace with visibility attribute starts here'
HA543A7B12EEA: '주변 네임스페이스의 가시성 속성 시작점입니다'
# 'suspicious concatenation of string literals in an array initialization; did you mean to separate the elements with a comma?'
HE00F78FF32CA: '배열 초기화에서 문자열 리터럴의 연결이 의심스럽습니다; 콤마로 요소를 구분하려는 의도였는지 확인하세요.'
# 'switch condition has boolean value'
HA563E9019204: '스위치 조건이 부울 값을 가집니다.'
# 'switch condition has incomplete class type %0'
HD68BA6071310: 'switch 조건이 완성되지 않은 클래스 형식을 갖습니다 %0'
# 'switch condition type %0 requires explicit conversion to %1'
HF719378BC596: 'switch 조건 타입 %0는 %1로 명시적 변환이 필요합니다'
# 'switch statement has empty body'
HD379C27E8554: 'switch 문의 본문이 비어 있습니다'
# "symbol exported in dynamic library, but marked hidden in declaration '%0'"
H493627372D47: "동적 라이브러리에서 기호가 수출되었지만, 선언 '%0'에서 hidden으로 지정되었습니다."
# 'symbol sort order'
H13E171348CDC: '기호 정렬 순서'
# 'symbolize function ids from the input log'
HBDC90FB5E310: '입력 로그에서 함수 ID를 기호화합니다'
# 'symbolize functions'
H4B741D643A7C: '기호화 함수'
# 'synchronization scope argument to atomic operation is invalid'
HE1E237FB50C9: '원자 연산에 대한 동기화 범위 인수가 유효하지 않습니다.'
# 'synthesized properties %0 and %1 both claim instance variable %2'
H9EA52B48540E: '합성된 속성 %0과 %1이 모두 인스턴스 변수 %2를 사용하려고 합니다'
# 'synthesized properties %0 and %1 both claim setter %2 - use of this setter will cause unexpected behavior'
HA9255CAB38EC: '자동 생성된 속성 %0과 %1이 모두 세터 %2를 선언하고 있습니다 - 이 세터를 사용하면 예상치 못한 동작이 발생할 수 있습니다'
# 'synthesized property %0 must either be named the same as a compatible instance variable or must explicitly name an instance variable'
HC10D22B3B816: '합성된 속성 %0는 호환 가능한 인스턴스 변수와 동일한 이름을 가져야 하거나 명시적으로 인스턴스 변수를 지정해야 합니다'
# 'synthesized property with variable size type %0 requires an existing instance variable'
H594CC555D195: '가변 크기 유형 %0를 갖는 자동 생성된 속성은 기존 인스턴스 변수가 필요합니다'
# 'synthesized setter %0 for null_resettable property %1 does not handle nil'
H95960177BFF3: 'null_resettable 속성 %1에 대한 자동 생성된 세터 %0는 nil을 처리하지 않습니다'
# 'synthesizing __weak instance variable of type %0, which does not support weak references'
H1E4EBACF7211: '타입 %0의 __weak 인스턴스 변수를 합성 중입니다. 이 타입은 약한 참조를 지원하지 않습니다'
# 'system diff used by change reporters'
HBA4E429740F6: '변경 보고자에 의해 사용되는 시스템 차이'
# 'system dot used by change reporters'
H9A7274B114C8: '변경 보고자에 의해 사용되는 시스템 도트'
# 'tail blocks whose size (in bytes) exceeds the value are never duplicated'
HDC606CA00EBA: 'tail blocks의 크기(바이트 단위)가 지정된 값보다 크면 절대 복제되지 않습니다'
# 'tail blocks with size (in bytes) not exceeding the value are always duplicated'
H2F3A5FED8EF0: '크기가 지정된 값(바이트 단위)보다 작거나 같은 꼬리 블록은 항상 복제됩니다'
# 'tail call required by %0 attribute here'
H9FB91CA4B73B: '이 %0 속성에 의해 여기서 꼬리 호출이 필요합니다'
# 'tail call requires that the return value, all parameters, and any temporaries created by the expression are trivially destructible'
HE303C40B04A3: '테일 콜은 리턴 값, 모든 매개변수, 그리고 표현식에 의해 생성된 임시 객체가 모두 trivial하게 소멸 가능해야 합니다'
# 'taking address of a capture is not allowed'
H35418F9DEF58: '캡처의 주소를 취하는 것은 허용되지 않습니다'
# 'taking address of function is not allowed'
H4A30B839C6AB: '함수의 주소를 취하는 것은 허용되지 않습니다'
# 'taking address of non-addressable standard library function'
H3ACD682CFC45: '주소를 가질 수 없는 표준 라이브러리 함수의 주소를 취했습니다'
# 'taking address of non-addressable standard library function is incompatible with C++20'
H888C6C415192: '주소를 취할 수 없는 표준 라이브러리 함수의 주소를 취하는 것은 C++20과 호환되지 않습니다.'
# 'taking address of packed member %0 of class or structure %q1 may result in an unaligned pointer value'
HD700C27ED0FC: '클래스나 구조체 %q1의 packed 멤버 %0의 주소를 취하는 것은 불일치된 포인터 값이 발생할 수 있습니다'
# 'taking the absolute value of %select{pointer|function|array}0 type %1 is suspicious'
HDEB21F2512CF: '%select{포인터|함수|배열}0 유형 %1의 절댓값을 취하는 것은 의심스러울 수 있습니다'
# 'taking the absolute value of unsigned type %0 has no effect'
H8F6DAEC8BECD: '부호없는 %0 타입의 절댓값을 취하는 것은 아무 효과도 없습니다'
# 'taking the address of a destructor'
H7B853F7C78AC: '소멸자의 주소를 취하는 중'
# 'taking the address of a temporary object of type %0'
HD39DC5626A0A: '%0 형식의 일시적 객체의 주소를 취합니다'
# 'taking the max of %select{a value and unsigned zero|unsigned zero and a value}0 is always equal to the other value'
H75EF0725015B: '%select{값과 부호 없는 영의 최대값|부호 없는 영과 값의 최대값}0은 항상 다른 값과 같습니다'
# 'target %select{constructor|destructor}0 is declared here'
HD59E728E618B: '타겟 %select{constructor|destructor}0는 여기에서 선언되었습니다'
# "target '%0' does not support exception handling; 'catch' block is ignored"
H06DD0F5375FE: "타겟 '%0'은 예외 처리를 지원하지 않아 'catch' 블록이 무시됩니다"
# "target '%0' does not support exception handling; 'throw' is assumed to be never reached"
H29FDCCFA5847: "타겟 '%0'은(는) 예외 처리를 지원하지 않습니다; 'throw'는 도달되지 않을 것으로 가정됩니다"
# "target '%0' is not a supported OpenMP host target"
H6B6204612E53: "타겟 '%0'은(는) 지원되지 않는 OpenMP 호스트 타겟입니다"
# "target '%0' is unsupported by -fsanitize-kcfi-arity"
HCFEF0540C5A0: "타겟 '%0'은(는) -fsanitize-kcfi-arity에 의해 지원되지 않습니다"
# 'target construct with nested teams region contains statements outside of the teams construct'
HB05FDB001094: '타겟 구문에 중첩된 팀스 영역이 팀스 구문 외부에 문장이 포함되었습니다'
# "target does not support 'protected' visibility; using 'default'"
H9354CE031F68: "타겟이 'protected' 가시성을 지원하지 않습니다; 'default'를 사용합니다"
# 'target exception specification is not superset of source'
H14AD31786EFD: '대상 예외 사양이 원본의 초집합이 아닙니다'
# 'target function %select{is a member of different class%diff{ (expected $ but has $)|}1,2|has different number of parameters (expected %1 but has %2)|has type mismatch at %ordinal3 parameter%diff{ (expected $ but has $)|}1,2|has different return type%diff{ ($ expected but has $)|}1,2}0'
HFEFD6F95E799: 'target function %select{다른 클래스의 멤버입니다%diff{ (예상: $ 이지만 $ 가 있음)|}1,2|매개변수 개수가 다릅니다 (예상: %1개 이지만 %2개 있음)|%ordinal3 번째 매개변수에서 타입 불일치가 있습니다%diff{ (예상: $ 이지만 $ 가 있음)|}1,2|반환 타입이 다릅니다%diff{ ($ 예상 이지만 $ 가 있음)|}1,2}0'
# 'target function has calling convention %1 (expected %0)'
HE7D037C49FE5: '대상 함수가 호출 규칙 %1을 가집니다 (예상한 값은 %0입니다)'
# 'target of using declaration'
HCB1C9C62D72D: 'using 선언의 대상'
# 'target of using declaration conflicts with declaration already in scope'
H5C1974A3FA23: 'using 선언의 대상이 이미 스코프에 존재하는 선언과 충돌합니다'
# 'target profile option (-T) is missing'
HD96117F3AEE8: '타겟 프로파일 옵션(-T)이 누락되었습니다'
# 'target-attribute based function overloads are not supported by NVCC and will be treated as a function redeclaration:new declaration is %select{__device__|__global__|__host__|__host__ __device__}0 function, old declaration is %select{__device__|__global__|__host__|__host__ __device__}1 function'
H48B3A7876AE7: '타겟 속성 기반 함수 오버로드는 NVCC에서 지원하지 않으며 함수 재선언으로 처리됩니다: 새 선언은 %select{__device__|__global__|__host__|__host__ __device__}0 함수이고, 기존 선언은 %select{__device__|__global__|__host__|__host__ __device__}1 함수입니다'
# 'tbd'
H1D9C8AC0B205: '처리 예정'
# 'template %0 has no definition and no %select{|viable }1deduction guides for deduction of template arguments'
H39A2D17F6485: 'template %0에 정의가 없고, %select{|사용 가능한 }1추론 가이드도 없어 템플릿 인수 추론이 불가능합니다'
# 'template argument / label address difference / what did you expect?'
H4022196FB5B0: '템플릿 인수 / 레이블 주소 차이 / 예상한 것을 말해주세요?'
# 'template argument does not refer to a class or alias template, or template template parameter'
H10B27B45B43C: '템플릿 인수는 클래스, 별칭 템플릿, 또는 템플릿 템플릿 매개변수를 참조하지 않습니다'
# 'template argument for non-type template parameter is treated as function type %0'
HF7C463216541: '비유형 템플릿 매개변수의 템플릿 인자는 함수 유형 %0으로 간주됩니다'
# 'template argument for non-type template parameter must be an expression'
HA6F518CB9F6F: '비유형 템플릿 매개변수의 템플릿 인수는 반드시 표현식이어야 합니다'
# 'template argument for template template parameter must be a class template%select{| or type alias template}0'
H4605CB1853A3: '템플릿 템플릿 매개변수에 대한 템플릿 인수는 클래스 템플릿%select{| 또는 타입 별칭 템플릿}0이어야 합니다'
# 'template argument for template type parameter must be a type'
H9FFBB255FD4F: '템플릿 형식 매개변수에 대한 템플릿 인수는 형식이어야 합니다.'
# "template argument for template type parameter must be a type; did you forget 'typename'?"
H477EE50BCF4B: '템플릿 유형 매개변수에 대한 템플릿 인수는 유형이어야 합니다; ‘typename’을 누락되었나요?'
# "template argument for template type parameter must be a type; omitted 'typename' is a Microsoft extension"
H0CC2569F4810: "템플릿 형식 매개변수에 대한 템플릿 인수는 형식이어야 합니다; 생략된 'typename'은 Microsoft의 확장 기능입니다"
# 'template argument is the type of an unresolved overloaded function'
H1DDFBAF8CEBB: '템플릿 인자는 해결되지 않은 오버로드된 함수의 유형입니다'
# 'template argument refers to function template %0, here'
H59E0A4B6EEC0: '템플릿 인수는 여기에서 함수 템플릿 %0를 참조합니다'
# 'template argument uses local type %0'
H8CFAA5F55F9C: '템플릿 인수에 지역 형식 %0가 사용되었습니다'
# 'template argument uses unnamed type'
H1A9FF29A8094: '템플릿 인수가 이름이 없는 형식을 사용합니다'
# 'template declaration from hidden source: %0'
H607A13711E91: '숨겨진 소스의 template 선언: %0'
# 'template is declared here'
H8B583108C6ED: '템플릿이 여기서 선언되었습니다'
# 'template name refers to non-type template %0'
HD8E4D2A7EC89: '템플릿 이름은 비유형 템플릿 %0를 가리킵니다'
# 'template non-type parameter has a different type %0 in template %select{|template parameter }1redeclaration'
H29D49A380D2B: '템플릿 비형식 매개변수의 타입이 템플릿 내에서 %0과 다릅니다%select{ | 템플릿 매개변수 }1 재선언'
# 'template non-type parameter has a different type %0 in template argument'
H83C8844C296B: '템플릿 비유형 매개변수가 템플릿 인수에서 다른 형식 %0을 가지고 있습니다'
# "template parameter '%0' is already documented"
H4188A9C61053: "템플릿 매개변수 '%0'는 이미 문서화되었습니다"
# "template parameter '%0' not found in the template declaration"
H1A80B68DAC8D: "템플릿 매개변수 '%0'가 템플릿 선언에 없습니다"
# 'template parameter declared here'
HC6CFA91EE1C1: '템플릿 매개변수가 여기서 선언되었습니다'
# 'template parameter default argument is inconsistent with previous definition'
H6440E4D1834B: '템플릿 매개변수 기본 인수는 이전 정의와 일치하지 않습니다'
# 'template parameter from hidden source: %0'
HE652270F3F6D: '숨겨진 소스의 템플릿 매개변수: %0'
# 'template parameter has a different kind in template %select{|template parameter }0redeclaration'
HBF82CEEA37C8: '템플릿 매개변수의 형식이 템플릿 %select{ | 템플릿 매개변수 }0 재선언에서 다릅니다'
# 'template parameter has a different kind in template argument'
H8F8F50E907A1: '템플릿 매개변수의 종류가 템플릿 인자와 다릅니다'
# 'template parameter has different kinds in different translation units'
H8BA5D6787AFF: '템플릿 매개변수가 다른 번역 단위에서 다른 종류를 가지고 있습니다'
# 'template parameter is declared here'
H6B3C8DC0FA6A: '템플릿 매개변수가 여기서 선언되었습니다'
# 'template parameter is used in default argument declared here'
HF0F9ED98885D: '템플릿 매개변수가 여기서 선언된 기본 인수에서 사용되었습니다'
# 'template parameter list also declared here'
H1F8E29374B19: '템플릿 매개변수 목록도 여기에 선언되었습니다'
# "template parameter list for literal operator must be either 'char...' or 'typename T, T...'"
H409CCC2DB745: "리터럴 연산자의 템플릿 매개변수 목록은 'char...' 또는 'typename T, T...'여야 합니다."
# "template parameter list matching the non-templated nested type %0 should be empty ('template<>')"
HE4D93F6B6699: "템플릿 매개변수 목록이 템플릿이 아닌 중첩된 형식 %0와 일치하는 경우 비어 있어야 합니다 ('template<>')"
# 'template parameter lists have a different number of parameters (%0 vs %1)'
HB5785F1417CF: '템플릿 매개변수 목록의 매개변수 개수가 다릅니다 (%0 vs %1)'
# 'template parameter missing a default argument'
H5BFE290A5AC0: '템플릿 매개변수에 기본 인수가 없습니다'
# "template parameter of a function template with the 'sycl_kernel' attribute cannot be a non-type template parameter"
H7625BE567F07: "함수 템플릿의 'sycl_kernel' 특성과 함께 사용되는 템플릿 파라미터는 비타입 템플릿 파라미터일 수 없습니다"
# 'template parameter pack cannot have a default argument'
HD1F9E9063EB7: '템플릿 매개변수 팩은 기본 인자를 가질 수 없습니다'
# 'template parameter pack must be the last template parameter'
HD5749F5C7756: '템플릿 매개변수 팩은 마지막 템플릿 매개변수여야 합니다.'
# 'template parameter redefines default argument'
H8C66CF577C62: '템플릿 매개변수가 기본 인수를 재정의했습니다'
# 'template specialization declaration cannot be a friend'
HA8ECAC04AF8C: '템플릿 특수화 선언은 친구로 지정할 수 없습니다'
# 'template specialization or definition requires a template parameter list corresponding to the nested type %0'
HC868EA3957FF: '템플릿 특수화 또는 정의는 내포된 형식 %0와 일치하는 템플릿 매개변수 목록이 필요합니다'
# "template specialization requires 'template<>'"
H1ADEE7A736DF: "템플릿 특수화는 'template<>'를 요구합니다."
# 'template template argument %0 is more constrained than template template parameter %1'
HE3F8D9BFA908: '템플릿 템플릿 인자 %0는 템플릿 템플릿 매개변수 %1보다 더 제약 조건이 엄격합니다'
# 'template template argument has different template parameters than its corresponding template template parameter'
HB7542BD3C1FF: '템플릿 템플릿 인수는 해당하는 템플릿 템플릿 매개변수와 다른 템플릿 매개변수를 가집니다'
# 'template template parameter must have its own template parameters'
H2E8B286B021F: '템플릿 템플릿 매개변수는 자신의 템플릿 매개변수를 가져야 합니다'
# "template template parameter requires 'class'%select{| or 'typename'}0 after the parameter list"
HC7B5002008B5: "템플릿 템플릿 매개변수는 매개변수 목록 다음에 'class'%select{| 또는 'typename'}0이 필요합니다"
# "template template parameter using 'typename' is a C++17 extension"
HD13D228AA386: "템플릿 템플릿 매개변수에 'typename'을 사용하는 것은 C++17 확장 기능입니다"
# "template template parameter using 'typename' is incompatible with C++ standards before C++17"
H2724DAD0662B: "C++17 이전의 C++ 표준과 호환되지 않는 템플릿 템플릿 매개변수에 'typename'을 사용했습니다."
# 'templates can only be declared in namespace or class scope'
H549BBF1A776B: '템플릿은 namespace 또는 class 범위에서만 선언될 수 있습니다'
# 'templates cannot be declared inside of a local class'
H9817A58D9951: '템플릿은 지역 클래스 내부에서 선언될 수 없습니다.'
# 'templates must have C++ linkage'
H7DA4A8DB6A41: '템플릿은 C++ 언어 연결 지정이 있어야 합니다.'
# 'temporary bound to reference member of allocated object will be destroyed at the end of the full-expression'
H013054578BC3: '할당된 객체의 참조 멤버에 바인드된 임시 객체는 전체 표현식의 끝에서 파괴됩니다'
# 'temporary created here'
H6CF924D32FF7: '여기서 생성된 임시 객체'
# 'temporary of type %0 has %select{private|protected}1 destructor'
HA776568AF253: '형 %0의 임시 객체가 %select{private|protected}1 소멸자를 가집니다'
# 'tentative array definition assumed to have one element'
H1578DBDB8944: '잠정 배열 정의가 1개 요소를 가진 것으로 가정됩니다'
# 'tentative definition has type %0 that is never completed'
H2533423DBC92: '임시 정의는 완료되지 않은 %0 타입을 가집니다'
# 'tentative definition of variable with internal linkage has incomplete %select{non-array|array}0 type %1'
H23883C0A0522: '내부 링크를 갖는 변수의 임시 정의는 완성되지 않은 %select{배열이 아닌|array}0 유형 %1을 가집니다'
# 'tenths of percents of main entry frequency to use as a threshold when evaluating whether a basic block is cold (0 means it is only considered cold if the block has zero samples). Default: 0 '
HB4A505AFFDA6: '메인 엔트리 빈도의 퍼센트의 10분의 1을 임계값으로 사용할 때 기본 블록이 희소한지 평가하는 데 사용합니다. (0은 블록이 0 샘플을 가질 경우에만 희소하다고 간주함) 기본값: 0'
# "test module file extension '%0' has different version (%1.%2) than expected (%3.%4)"
HD419260C8BE7: "테스트 모듈 파일 확장자 '%0'의 버전 (%1.%2)은 예상된 (%3.%4)과 다릅니다."
# 'the #__include_macros directive is only for internal use by -imacros'
H1FBDC6FD510E: '__include_macros 디렉티브는 내부적으로 -imacros에 의해 사용될 목적으로만 존재합니다'
# 'the %0 sub-architecture does not support unaligned accesses'
H8EEF78B6F581: '서브 아키텍처 %0는 비정렬 액세스를 지원하지 않습니다'
# 'the %0 type cannot be used to declare a program scope variable'
HCC2A02E45E01: '%0 유형은 프로그램 범위 변수를 선언할 수 없습니다'
# 'the %0 type cannot be used to declare a structure or union field'
H3AA824360E4A: '%0 타입은 구조체 또는 유니온 필드를 선언하는 데 사용할 수 없습니다'
# 'the %select{1st|2nd|3rd}1 template parameter of %0 needs to be %select{a type|an integer or enum value}2'
HC15D25E5BA46: '%0의 %select{첫 번째|두 번째|세 번째}1 템플릿 매개변수는 %select{형|정수 값 또는 열거형 값}2이어야 합니다'
# 'the %select{function or variable|function}0 specified in an %select{alias|ifunc}1 must refer to its mangled name'
H2A963C3F164E: '%select{함수 또는 변수|함수}0가 %select{_ALIAS|IFUNC}1에 지정된 경우, 해당 매angled 이름을 참조해야 합니다'
# "the %select{message|string}0 object in %select{this static assertion|this asm operand}0 is missing %select{a 'size()' member function|a 'data()' member function|'data()' and 'size()' member functions}1"
HF8EFF7FCD3A1: '%select{메시지|문자열}0 객체가 %select{이 정적 검증|이 어셈블리 연산자}0에서 %select{size() 멤버 함수|data() 멤버 함수|data()와 size() 멤버 함수}1이 누락되었습니다'
# "the '%0' unit is not supported with this instruction set"
H66612647AED8: "이 '%0' 유닛은 이 인스트럭션 세트에서 지원되지 않습니다"
# "the '%select{&|*|->}0' operator is unsupported in HLSL"
H831B25ED6E8C: "HLSL에서 '%select{&|*|->}0' 연산자는 지원되지 않습니다"
# "the '[[_Noreturn]]' attribute spelling is deprecated in C23; use '[[noreturn]]' instead"
H584C1C164ECE: "C23에서 '[[_Noreturn]]' 속성 표기법은 비추천됨; 대신 '[[noreturn]]'을 사용하십시오"
# "the 'copyprivate' clause must not be used with the 'nowait' clause"
H026F61D558F6: '‘copyprivate’ 절은 ‘nowait’ 절과 함께 사용할 수 없습니다'
# "the 'static' modifier for the array size is not legal in new expressions"
H285525BB6E11: "배열 크기의 'static' 수식어는 new 표현식에서 유효하지 않습니다"
# "the ApplicationExtensionSafe flag does not match: '%0' (provided) vs '%1' (found)"
H74ECAC68920E: "ApplicationExtensionSafe 플래그가 일치하지 않습니다: '%0' (지정됨) vs '%1' (검출됨)"
# 'the GNU address of label extension is not allowed in coroutines'
HEE9FFF3C021C: 'GNU 레이블 주소 확장은 코루틴에서 허용되지 않습니다'
# "the NotForDyldSharedCache flag does not match: '%0' (provided) vs '%1' (found)"
HAD9256F7D2F3: "NotForDyldSharedCache 플래그가 일치하지 않습니다: '%0' (제공됨) vs '%1' (검색됨)"
# 'the __block storage type is not permitted'
H2951C6144658: '__block 저장 형식은 허용되지 않습니다'
# 'the address of a declaration with unknown type can only be cast to a pointer type'
H6D4B76B01E9C: '알 수 없는 형식의 선언의 주소는 포인터 형식으로만 캐스팅할 수 있습니다'
# "the argument '%0' is not supported for option '%1'. Mapping to '%1%2'"
HA4EFCA49DC99: "인수 '%0'은(는) 옵션 '%1'에 지원되지 않습니다. 대신 '%1%2'로 설정됩니다"
# 'the argument to vk::Literal must be a vk::integral_constant'
HAA2FE1B1AE05: 'vk::Literal의 인수는 vk::integral_constant여야 합니다'
# "the clang compiler does not support '%0'"
HCB0DF6FD34A3: "Clang 컴파일러는 '%0'를 지원하지 않습니다."
# "the clang compiler does not support '%0' for C++ on Darwin/i386"
HAB9E0C38E134: "clang 컴파일러는 Darwin/i386에서 C++에 대해 '%0'을(를) 지원하지 않습니다"
# "the clang compiler does not support '%0', %1"
H70791B1776AF: "clang 컴파일러는 '%0'을(를) 지원하지 않습니다, %1"
# 'the clang compiler does not support -pg option on %select{Darwin|versions of OS X 10.9 and later}0'
HEC221F97986E: 'clang 컴파일러는 %select{Darwin|OS X 10.9 이상 버전}0에서 -pg 옵션을 지원하지 않습니다'
# 'the clustering algorithm to use'
HEE034B797939: '사용할 클러스터링 알고리즘'
# "the combination of '%0' and '%1' is incompatible"
H04D1D2EB3A72: "'%0'과 '%1'의 조합은 호환되지 않습니다"
# "the context %select{set|selector|property}0 '%1' was used already in the same 'omp declare variant' directive; %select{set|selector|property}0 ignored"
H6268D8504255: "컨텍스트 %select{set|selector|property}0 '%1'은(는) 동일한 'omp declare variant' 지시문에서 이미 사용되었습니다; %select{set|selector|property}0 무시됨"
# "the context property '%0' can be nested in the context selector '%1' which is nested in the context set '%2'; try 'match(%2={%1(%0)})'"
HAA758F7206BE: "컨텍스트 프로퍼티 '%0'는 컨텍스트 셋 '%2'에 중첩된 컨텍스트 셀렉터 '%1' 내에 중첩될 수 있습니다; 대신 'match(%2={%1(%0)})' 형식을 사용해 보십시오."
# "the context property '%0' is not valid for the context selector '%1' and the context set '%2'; property ignored"
H88A5B848CED9: "컨텍스트 속성 '%0'은 컨텍스트 선택기 '%1' 및 컨텍스트 세트 '%2'에 유효하지 않음; 속성 무시됨"
# "the context selector '%0' can be nested in the context set '%1'; try 'match(%1={%0%select{|(property)}2})'"
HDD6FFFA1FE6E: "맥락 선택기 '%0'는 맥락 세트 '%1' 안에 중첩될 수 있습니다; 다음과 같이 시도해 보세요: 'match(%1={%0%select{|(property)}2})'"
# "the context selector '%0' in context set '%1' requires a context property defined in parentheses; selector ignored"
H4359A48C4F70: "컨텍스트 세트 '%1' 내의 컨텍스트 선택기 '%0'은 괄호 안에 정의된 컨텍스트 속성이 필요합니다; 선택기를 무시합니다"
# "the context selector '%0' in the context set '%1' cannot have a score (%quoted2); score ignored"
H3FAFFF7C5EF8: "맥락 집합 '%1'의 맥락 선택자 '%0'는 점수(%quoted2)를 가질 수 없습니다; 점수 무시됨"
# "the context selector '%0' is not valid for the context set '%1'; selector ignored"
HDF7A50F1E9D4: "컨텍스트 선택기 '%0'은 컨텍스트 세트 '%1'에 유효하지 않으므로 선택기가 무시됩니다"
# "the coroutine promise type %0 declares both 'return_value' and 'return_void'"
H089B386C28E8: "코루틴 프로미스 유형 %0는 'return_value'와 'return_void'를 모두 선언합니다"
# 'the current #pragma pack alignment value is modified in the included file'
H1259B6694648: '현재의 #pragma pack 정렬 값이 포함된 파일에서 수정되었습니다'
# 'the event_t type can only be used with __private address space qualifier'
HF7753CC750DA: 'event_t 타입은 __private 주소 공간 지정자와 함께만 사용할 수 있습니다.'
# 'the experimental clang interpreter failed to evaluate an expression'
H0E50C442ED03: '실험적인 clang 인터프리터가 표현식을 평가하지 못했습니다'
# 'the explicit object parameter cannot be a function parameter pack'
HAC332D9FE6A2: '명시적 객체 매개변수는 함수 매개변수 패키지일 수 없습니다'
# 'the explicit object parameter cannot have a default argument'
HEF646D36FD87: '명시적 객체 매개변수는 기본 인수를 가질 수 없습니다'
# "the expression 'co_await __promise.final_suspend()' is required to be non-throwing"
HBE8E0E1AD063: "표현식 'co_await __promise.final_suspend()'는 예외를 던지지 않아야 합니다"
# "the flag '%0' has been deprecated and will be ignored"
H97F3754670BE: "플래그 '%0'는 폐지되어 무시됩니다"
# "the form '-fmodule-file=<BMI-path>' is deprecated for standard C++ named modules; consider to use '-fmodule-file=<module-name>=<BMI-path>' instead"
H9E11832D49AD: "'-fmodule-file=<BMI-path>' 형식은 표준 C++ 명명 모듈에 대해 사용 중지되었습니다. 대신 '-fmodule-file=<module-name>=<BMI-path>'를 사용하는 것을 고려하세요."
# "the given MCU does not support hardware multiply, but '-mhwmult' is set to %0"
HBC73BCBB2AD5: "지정된 MCU는 하드웨어 곱셈을 지원하지 않지만 '-mhwmult'이 %0로 설정되었습니다"
# "the given MCU supports %0 hardware multiply, but '-mhwmult' is set to %1"
H33683D593A85: "지정된 MCU는 %0 하드웨어 곱셈을 지원하지만, '-mhwmult' 옵션이 %1로 설정되었습니다"
# 'the host cannot update a declare target variable that is not externally visible'
H626F4DD8E816: '호스트는 외부에서 가시적이지 않은 declare된 타겟 변수를 업데이트할 수 없습니다'
# 'the ignored %select{set|selector|property}0 spans until here'
H78F2F2873540: '무시된 %select{set|selector|property}0가 이 위치까지 확장됩니다'
# 'the ignored tokens spans until here'
HE724FD8D9E24: '무시된 토큰들이 여기까지 이어집니다'
# 'the implementation of header units is in an experimental phase'
H822B183C153E: '헤더 유닛의 구현은 실험 단계에 있습니다'
# "the implicit output of reduced BMI may be overrided by the output file specified by '--precompile'. please consider use '-fmodule-output=' to specify the output file for reduced BMI explicitly"
HC77BA90C9A9E: "축소된 BMI의 암시적 출력은 '--precompile'로 지정된 출력 파일에 의해 덮어씌여질 수 있습니다. 축소된 BMI의 출력 파일을 명시적으로 지정하려면 '-fmodule-output=' 옵션을 사용해 주세요"
# "the inscan reduction list item must appear as a list item in an 'inclusive' or 'exclusive' clause on an inner 'omp scan' directive"
H5A6903CB5B88: "inscan 감소 목록 항목은 내부 'omp scan' 지시문의 'inclusive' 또는 'exclusive' 절에 있는 목록 항목으로 나타나야 합니다"
# "the last '/TC' or '/TP' option takes precedence over earlier instances"
H1D4C07143ED6: "마지막으로 지정된 '/TC' 또는 '/TP' 옵션이 이전 옵션들을 우선합니다"
# "the library '%0=%1' is not supported, OpenMP will not be enabled"
H8332E220148A: "라이브러리 '%0=%1'은(는) 지원되지 않습니다. OpenMP가 활성화되지 않을 것입니다"
# "the list item must appear in 'reduction' clause with the 'inscan' modifier of the parent directive"
H331559E5A96C: "리스트 항목은 상위 디렉티브의 'inscan' 수정자와 함께 'reduction' 절에 나타나야 합니다."
# 'the loop %select{initializer|condition}0 expression depends on the current loop control variable'
H092C392BA41E: '루프 %select{initializer|condition}0 표현식이 현재 루프 제어 변수에 의존합니다'
# 'the maximum number of instructions analyzed for may throw during attribute inference in inlined body'
HDB567B6559C9: '속성 추론 중 인라인된 본문에서 예외를 던질 수 있는 경우 분석한 최대 명령문 수'
# 'the mode to run'
H1067F4A3FF41: '실행 모드'
# 'the name of the PDB file to write'
H3B634F1D4C6F: '작성할 PDB 파일의 이름'
# "the name of the construct must be specified in presence of 'hint' clause"
HF664729B6FC3: 'hint 절이 있는 경우 구조체의 이름을 지정해야 합니다'
# 'the number of preprocessor source tokens (%0) exceeds this token limit (%1)'
H205DE1F2F79F: '프리프로세서 소스 토큰의 수(%0)가 토큰 제한(%1)을 초과했습니다'
# 'the object size sanitizer has no effect at -O0, but is explicitly enabled: %0'
H314C428C1C64: '오브젝트 사이즈 산타이저는 -O0에서 효과가 없지만 명시적으로 활성화되었습니다: %0'
# "the option '-flto=thin' is a work in progress"
H5F57C367214A: "옵션 '-flto=thin'은 아직 개발 중입니다"
# "the other acquisition of %0 '%1' is here"
HF9475FC44959: "다른 %0 '%1'의 획득이 여기 있습니다"
# 'the parameter for an explicitly-defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 may not be volatile'
HEAA7EB9FB2E0: '명시적으로 기본값으로 지정된 %select{디폴트 생성자|복사 생성자|이동 생성자|복사 대입 연산자|이동 대입 연산자|소멸자}0의 매개변수는 volatile일 수 없습니다'
# 'the parameter for an explicitly-defaulted copy assignment operator must be an lvalue reference type'
H7CAB648A4737: '명시적으로 기본값으로 지정된 복사 대입 연산자의 매개변수는 lvalue 참조 형식이어야 합니다'
# 'the parameter for an explicitly-defaulted move %select{constructor|assignment operator}0 may not be const'
H34E3C1F201FC: '명시적으로 기본값이 지정된 move %select{constructor|assignment operator}0의 매개변수는 const 일 수 없습니다'
# 'the parameter for this explicitly-defaulted copy %select{constructor|assignment operator}0 is const, but a member or base requires it to be non-const'
H7307965D0004: '이 명시적으로 기본값이 지정된 복사 %select{생성자|대입 연산자}0의 매개변수는 const이지만, 멤버나 기반 클래스는 const가 아닌 것을 요구합니다'
# "the parameter of the 'ordered' clause must be greater than or equal to the parameter of the 'collapse' clause"
H21ACD6E7D4C2: 'ordered 절의 매개변수는 collapse 절의 매개변수보다 크거나 같아야 합니다'
# 'the pointee of the 2nd argument must match the element type of the 1st argument (%0 != %1)'
H13AC040EDF7B: '두 번째 인수의 포인터가 가리키는 타입은 첫 번째 인수의 요소 타입과 일치해야 합니다. (%0 != %1)'
# 'the pointer decremented by %0 refers before the beginning of the array'
H9FD5D86B7BD7: '포인터가 %0만큼 감소된 후 배열의 시작 이전을 가리킵니다'
# 'the pointer incremented by %0 refers past the end of the array (that has type %1)'
H2098AEB20194: '포인터가 %0만큼 증가된 후 배열의 끝을 넘어 참조합니다 (배열의 타입은 %1입니다)'
# 'the pointer incremented by %0 refers past the last possible element for an array in %1-bit address space containing %2-bit (%3-byte) elements (max possible %4 element%s5)'
H85FE07542C80: '%0만큼 증가된 포인터가 %1비트 주소 공간에 있는 %2비트 (%3바이트) 요소를 포함한 배열의 마지막으로 가능한 요소 다음을 가리킵니다 (최대 가능 요소 개수: %4 요소%s5)'
# "the previous context %select{set|selector|property}0 '%1' used here"
H995F32331A92: "이전 컨텍스트 %select{set|selector|property}0 '%1'이 여기서 사용되었습니다"
# 'the provided selection does not overlap with the AST nodes of interest'
H10756E8D2178: '제공된 선택이 관심 있는 AST 노드와 중첩되지 않습니다'
# 'the referenced item is not found in any private clause on the same directive'
HBDA357C86E91: '참조된 항목이 같은 지시문의 어떤 private 절에도 발견되지 않았습니다.'
# "the result of a delegate init call must be immediately returned or assigned to 'self'"
HA6A6824B2746: "델리게이트 init 호출의 결과는 즉시 반환되거나 'self'에 할당되어야 합니다"
# 'the resulting value is always non-negative after implicit conversion'
H9908ECBF3885: '암시적 변환 후 결과 값은 항상 음수가 아닌 값이 됩니다'
# "the second argument of '-fpatchable-function-entry' must be smaller than the first argument"
HEC0EC1D581E8: "'-fpatchable-function-entry'의 두 번째 인수는 첫 번째 인수보다 작아야 합니다"
# "the selected code is not a part of a function's / method's body"
H09129ED39DF9: '선택한 코드는 함수 또는 메서드의 본문의 일부가 아닙니다.'
# 'the selected expression cannot be extracted'
HC3B7DF91CF84: '선택된 표현식을 추출할 수 없습니다'
# 'the selected expression is too simple to extract'
HEFB1186DBBA0: '선택된 표현은 추출하기에는 너무 단순합니다'
# 'the semantics of this intrinsic changed with GCC version 4.4 - the newer semantics are provided here'
H1D55F6813757: '이 intrinsic의 의미 체계는 GCC 버전 4.4에서 변경되었습니다 - 새로운 의미 체계가 여기에 제공됩니다'
# 'the sign of a  flushed-to-zero number is preserved in the sign of 0'
HE7436E3F21CE: '0으로 변환된 수의 부호는 0의 부호에 유지됩니다'
# 'the specified comparator type does not provide a viable const call operator'
H327A107A2A90: '지정된 비교자 타입은 사용할 수 있는 const 호출 연산자를 제공하지 않습니다'
# 'the specified hash functor does not provide a viable const call operator'
H7B4F603F77A3: '지정된 해시 펀ktor는 사용 가능한 const 호출 연산자를 제공하지 않습니다'
# "the statement for '#pragma omp %0' must be a compound statement"
H8597FC2B3D8A: "'#pragma omp %0'에 대한 문은 복합 문이어야 합니다"
# "the statement for 'atomic capture' must be a compound statement of form '{v = x; x binop= expr;}', '{x binop= expr; v = x;}', '{v = x; x = x binop expr;}', '{v = x; x = expr binop x;}', '{x = x binop expr; v = x;}', '{x = expr binop x; v = x;}' or '{v = x; x = expr;}', '{v = x; x++;}', '{v = x; ++x;}', '{++x; v = x;}', '{x++; v = x;}', '{v = x; x--;}', '{v = x; --x;}', '{--x; v = x;}', '{x--; v = x;}' where x is an lvalue expression with scalar type"
H0E1E5BD56218: "원자성 포획을 위한 문은 x가 스칼라 형식을 가진 lvalue 표현式인 경우 다음 형식 중 하나인 복합 문이어야 합니다: '{v = x; x binop= expr;}', '{x binop= expr; v = x;}', '{v = x; x = x binop expr;}', '{v = x; x = expr binop x;}', '{x = x binop expr; v = x;}', '{x = expr binop x; v = x;}' 또는 '{v = x; x = expr;}', '{v = x; x++;}', '{v = x; ++x;}', '{++x; v = x;}', '{x++; v = x;}', '{v = x; x--;}', '{v = x; --x;}', '{--x; v = x;}', '{x--; v = x;}'"
# "the statement for 'atomic capture' must be an expression statement of form 'v = ++x;', 'v = --x;', 'v = x++;', 'v = x--;', 'v = x binop= expr;', 'v = x = x binop expr' or 'v = x = expr binop x', where x and v are both lvalue expressions with scalar type"
H47D428195CE9: "원자 캡처를 위한 문은 다음 형식 중 하나인 표현식 문이어야 합니다: 'v = ++x;', 'v = --x;', 'v = x++;', 'v = x--;', 'v = x binop= expr;', 'v = x = x binop expr' 또는 'v = x = expr binop x', 여기서 x와 v는 모두 스칼라 형식의 lvalue 표현식입니다"
# "the statement for 'atomic compare capture' must be a compound statement of form '{v = x; cond-up-stmt}', ''{cond-up-stmt v = x;}', '{if(x == e) {x = d;} else {v = x;}}', '{r = x == e; if(r) {x = d;}}', or '{r = x == e; if(r) {x = d;} else {v = x;}}', where 'cond-update-stmt' can have one of the following forms: 'if(expr ordop x) {x = expr;}', 'if(x ordop expr) {x = expr;}', 'if(x == e) {x = d;}', or 'if(e == x) {x = d;}' where 'x', 'r', and 'v' are lvalue expressions with scalar type, 'expr', 'e', and 'd' are expressions with scalar type, and 'ordop' is one of '<' or '>'"
H09C6A6DB560B: "'원자적 비교 포착(atomic compare capture)'을 위한 문장은 다음 형식 중 하나의  backet 문장이어야 합니다: '{v = x; cond-up-stmt}', '{cond-up-stmt v = x;}', '{if(x == e) {x = d;} else {v = x;}}', '{r = x == e; if(r) {x = d;}}', 또는 '{r = x == e; if(r) {x = d;} else {v = x;}}' 여기서 'cond-update-stmt'는 다음 형식 중 하나를 가질 수 있습니다: 'if(expr ordop x) {x = expr;}', 'if(x ordop expr) {x = expr;}', 'if(x == e) {x = d;}', 또는 'if(e == x) {x = d;}' 여기서 'x', 'r', 'v'는 스칼라 형식의 lvalue 표현식이며, 'expr', 'e', 'd'는 스칼라 형식의 표현식입니다. 또한 'ordop'는 '<' 또는 '>' 중 하나여야 합니다"
# "the statement for 'atomic compare' must be a compound statement of form '{x = expr ordop x ? expr : x;}', '{x = x ordop expr? expr : x;}', '{x = x == e ? d : x;}', '{x = e == x ? d : x;}', or 'if(expr ordop x) {x = expr;}', 'if(x ordop expr) {x = expr;}', 'if(x == e) {x = d;}', 'if(e == x) {x = d;}' where 'x' is an lvalue expression with scalar type, 'expr', 'e', and 'd' are expressions with scalar type, and 'ordop' is one of '<' or '>'"
H4091D9BED6D2: "원자 비교(atomic compare)를 위한 문장은 '{x = expr ordop x ? expr : x;}', '{x = x ordop expr ? expr : x;}', '{x = x == e ? d : x;}', '{x = e == x ? d : x;}', 'if(expr ordop x) {x = expr;}', 'if(x ordop expr) {x = expr;}', 'if(x == e) {x = d;}', 또는 'if(e == x) {x = d;}' 형식의 복합 문장이어야 합니다. 여기서 'x'는 스칼라 형식을 가진 좌변 표현식(lvalue expression)이며, 'expr', 'e', 'd'는 스칼라 형식을 가진 표현식이며, 'ordop'는 '<' 또는 '>' 중 하나여야 합니다."
# "the statement for 'atomic read' must be an expression statement of form 'v = x;', where v and x are both lvalue expressions with scalar type"
HDAD21CA5AD66: "원자적 읽기(atomic read)를 위한 문은 형식 'v = x;'의 표현식 문이어야 하며, 여기서 v와 x는 모두 스칼라 형식을 갖는 lvalue 표현식이어야 합니다"
# "the statement for 'atomic update' must be an expression statement of form '++x;', '--x;', 'x++;', 'x--;', 'x binop= expr;', 'x = x binop expr' or 'x = expr binop x', where x is an lvalue expression with scalar type"
H106E8810ABCE: "원자적 업데이트를 위한 문은 '++x;', '--x;', 'x++;', 'x--;', 'x binop= expr;', 'x = x binop expr' 또는 'x = expr binop x' 형식의 표현식 문이어야 하며, 여기서 x는 스칼라 형식을 가진 lvalue 표현식이어야 합니다"
# "the statement for 'atomic write' must be an expression statement of form 'x = expr;', where x is a lvalue expression with scalar type"
HAEE051C701D8: "원자적 쓰기(atomic write)를 위한 문은 'x = expr;' 형태의 표현식 문이어야 하며, 여기서 x는 스칼라 형식(scalar type)을 가진 lvalue 표현식이어야 합니다"
# "the statement for 'atomic' must be an expression statement of form '++x;', '--x;', 'x++;', 'x--;', 'x binop= expr;', 'x = x binop expr' or 'x = expr binop x', where x is an lvalue expression with scalar type"
H182C909CFBBD: "'atomic'에 대한 문은 '++x;', '--x;', 'x++;', 'x--;', 'x binop= expr;', 'x = x binop expr' 또는 'x = expr binop x' 형태의 표현식 문이어야 하며, 여기서 x는 스칼라 형식을 가지는 lvalue 표현식이어야 합니다"
# "the target architecture '%0' is not supported by the target '%1'"
H9EB5284C09D2: "목표 아키텍처 '%0'은(는) '%1' 타겟에 의해 지원되지 않습니다"
# 'the total number of preprocessor source tokens (%0) exceeds the token limit (%1)'
H8A02325A6920: '예처리기 소스 토큰의 총 수 (%0)가 토큰 제한 (%1)을 초과했습니다'
# 'the two-parameter std::span construction is unsafe as it can introduce mismatch between buffer size and the bound information'
HB6B2C19333E2: '두 매개변수 std::span 생성자는 버퍼 크기와 경계 정보 사이의 불일치를 일으킬 수 있으므로 안전하지 않습니다'
# 'the type %0 is already explicitly ownership-qualified'
H462F56962031: '유형 %0는 이미 명시적으로 소유권 자격이 부여되었습니다'
# 'the type %0 is not a pointer to a fast-enumerable object'
HF043D197C95F: '형식 %0는 빠른 열거가 가능한 객체 포인터가 아닙니다'
# 'the type of object expression %diff{($) does not match the type being destroyed ($)|does not match the type being destroyed}0,1 in pseudo-destructor expression'
HF8245CD4DD36: '객체 표현식의 유형 %diff{($)는 파괴되는 유형과 일치하지 않습니다 ($)|일치하지 않습니다}0,1인 의사 소멸자 표현식에서'
# 'the type of the explicit object parameter of an explicitly-defaulted %select{copy|move}0 assignment operator should be reference to %1'
H48B3F2D609BF: '명시적으로 기본화된 %select{copy|move}0 할당 연산자의 명시적 객체 매개변수의 타입은 %1의 참조 형식이어야 합니다'
# 'the type of variable template specialization %0 declared with deduced type %1 depends on itself'
HA37293515585: '유추된 유형 %1로 선언된 변수 템플릿 특수화 %0의 유형이 자기 자신에 의존합니다'
# 'the user condition in the OpenMP context selector needs to be constant; %0 is not'
H518CAE3CEA63: 'OpenMP 컨텍스트 선택기의 사용자 조건은 상수이어야 합니다; %0는 상수가 아닙니다'
# "the value of 'simdlen' parameter must be less than or equal to the value of the 'safelen' parameter"
H05F684C1DEC1: "'simdlen' 매개변수의 값은 'safelen' 매개변수의 값보다 작거나 같아야 합니다"
# "the value of the size argument in 'strncat' is too large, might lead to a buffer overflow"
H7CBEE5BA8363: 'strncat의 size 인수 값이 너무 큽니다. 버퍼 오버플로우가 발생할 수 있습니다'
# "the value of the size argument to 'strncat' is wrong"
H10EE22A40549: 'strncat에 전달된 size 인수의 값이 잘못되었습니다'
# 'the vecreturn attribute can only be used on a POD (plain old data) class or structure (i.e. no virtual functions)'
HB24B6E1BF839: 'vecreturn 속성은 POD(Plain Old Data) 클래스 또는 구조체(즉, 가상 함수가 없는 것)에만 사용할 수 있습니다.'
# 'the vecreturn attribute can only be used on a class or structure with one member, which must be a vector'
H91431B029CC5: 'vecreturn 속성은 한 개의 멤버를 가진 클래스나 구조체에만 사용할 수 있으며, 그 멤버는 반드시 벡터여야 합니다'
# "the warning option '-%0' is not supported"
H961C96696067: "경고 옵션 '-%0'은 지원되지 않습니다"
# 'there is no external assembler that can be used on this platform'
H36CA569B9742: '이 플랫폼에서 사용할 수 있는 외부 어셈블러가 없습니다'
# 'there is no symbol at the given location'
H99C4AECFC4C8: '지정된 위치에 해당하는 심볼이 없습니다'
# 'this builtin is available only on AIX 7.2 and later operating systems'
H6E604B084F43: '이 내장 함수는 AIX 7.2 및 이후 운영 체제에서만 사용할 수 있습니다'
# 'this builtin is only available on 32-bit targets'
H56D31FAC556E: '이 내장 기능은 32비트 대상 플랫폼에서만 사용할 수 있습니다'
# 'this builtin is only available on 64-bit targets'
HC0C706B2D8E7: '이 내장 함수는 64비트 타겟에서만 사용할 수 있습니다'
# 'this builtin is only available on x86-64 and aarch64 targets'
H81BF150D8949: '이 내장 함수는 x86-64 및 aarch64 타겟에서만 사용할 수 있습니다'
# "this builtin requires 'dsp r2' ASE, please use -mdspr2"
HF59F7FBACC6E: "이 빌트인은 'dsp r2' ASE를 필요로 합니다. -mdspr2 옵션을 사용하십시오"
# "this builtin requires 'dsp' ASE, please use -mdsp"
H2B317AB4FDC4: "이 내장 함수는 'dsp' ASE를 필요로 하므로 -mdsp 옵션을 사용하십시오."
# "this builtin requires 'msa' ASE, please use -mmsa"
H25EA8026E312: "이 내장 함수는 'msa' ASE를 필요로 하므로 -mmsa 옵션을 사용해 주세요"
# 'this builtin requires ABI -mabi=%0'
H6643558E97E9: '이 내장 기능은 ABI -mabi=%0이 필요합니다'
# 'this coroutine may be split into pieces; not every piece is guaranteed to be inlined'
HEF5E3EA3F783: '이 코루틴은 조각으로 분할될 수 있으며; 모든 조각이 인라인 처리될 보장은 없습니다'
# "this declaration is not a prototype; add %select{'void'|parameter declarations}0 to make it %select{a prototype for a zero-parameter function|one}0"
HDD90A70940A7: "이 선언은 프로토타입이 아닙니다; %select{'void'|매개변수 선언들}0을 추가하여 %select{인자가 없는 함수의 프로토타입|한 가지}0으로 만들 수 있습니다"
# 'this expression will be parsed as explicit(bool) in C++20'
HE2974A48FA92: '이 표현식은 C++20에서 explicit(bool)로 해석됩니다'
# 'this function cannot be a coroutine: %0 is an incomplete type'
HEB887A198DFF: '이 함수는 코루틴으로 될 수 없습니다: %0는 완전하지 않은 형식입니다'
# 'this function cannot be a coroutine: %0 is not a class'
HF896DD5CD9DB: '이 함수는 코루틴일 수 없습니다: %0은(는) 클래스가 아닙니다'
# "this function cannot be a coroutine: %q0 has no member named 'promise_type'"
HAD42B5488901: "이 함수는 코루틴일 수 없습니다: '%q0'에는 'promise_type'이라는 멤버가 없습니다"
# 'this function cannot be a coroutine: missing definition of specialization %0'
HFC5D41C5C0FA: '이 함수는 코루틴으로 될 수 없습니다: 전문화 %0의 정의가 누락되었습니다'
# 'this placement new expression is not supported in constant expressions %select{|before C++2c}0'
HFED2CB8F9A5D: '이 placement new 표현식은 상수 표현식에서 %select{|C++2c 이전에}0 지원되지 않습니다'
# 'this pragma cannot appear in %0 declaration'
HCE58A657A4E9: '이 pragma는 %0 선언에서 나타날 수 없습니다'
# 'this style of line directive is a GNU extension'
H0B9D785486F6: '이런 스타일의 라인 디렉티브는 GNU 확장 기능입니다'
# 'this target does not support pointer authentication'
HB298CA51FDBD: '이 타겟은 포인터 인증을 지원하지 않습니다.'
# 'this type tag was not designed to be used with this function'
H6E259EADA90E: '이 타입 태그는 이 함수와 함께 사용하기 위해 설계되지 않았습니다'
# 'this use of statement expressions is not supported in a constant expression'
H15F3A7193C9C: '이렇게 statement expressions을 사용하는 것은 상수 표현식에서 지원되지 않습니다'
# 'this value is too large for this fixed point type'
HC641D92F0E57: '이 값은 이 고정 소수점 형식에 너무 큽니다'
# 'this warning is no longer in use and will be removed in the next release'
H0EF268B5B2F9: '이 경고는 더 이상 사용되지 않으며 다음 릴리즈에서 제거될 것입니다'
# 'thread safety beta warning'
HB0419777F950: '스레드 안전성 베타 경고'
# 'thread safety verbose warning'
H313BE85969C3: '쓰레드 안전성 상세 경고'
# 'thread warning in function %0'
H36B44B602302: '스레드 경고: 함수 %0에서'
# 'thread-local declaration of %0 follows non-thread-local declaration'
HEFF70126975B: '%0의 스레드 로컬 선언이 비스레드 로컬 선언 뒤에 오고 있습니다.'
# 'thread-local declaration of %0 with %select{static|dynamic}1 initialization follows declaration with %select{dynamic|static}1 initialization'
H912C45CDB374: '스레드 로컬 변수 %0의 %select{static|dynamic}1 초기화가 있는 선언이 %select{dynamic|static}1 초기화가 있는 선언 뒤에 오면 안 됩니다'
# 'thread-local storage is not supported for the current target'
H98D675ADC45A: '현재 타겟에서 스레드 로컬 저장소를 지원하지 않습니다'
# 'thread-local variable has non-trivial ownership: type is %0'
H6F11C930F55E: '쓰레드 로컬 변수가 비기본 소유권을 가집니다: 타입은 %0입니다'
# 'threadprivate variable with incomplete type %0'
HCB733257A55A: 'threadprivate 변수의 형식 %0이 완전하지 않습니다.'
# "threadprivate variables are not allowed in '%0' clause"
HEEB356882606: '‘%0’ 절에서 threadprivate 변수는 허용되지 않습니다.'
# 'threadprivate variables cannot be used in target constructs'
HB21F31B22998: 'threadprivate 변수는 target 구문에서 사용할 수 없습니다.'
# 'three-way comparison between pointer and zero'
HD3520571E10A: '포인터와 0 간의 세 가지 방향 비교'
# 'three-way comparison between vectors is not supported'
H00B5B249986A: '벡터 간의 세 방법 비교는 지원되지 않습니다'
# "three-way comparison cannot be synthesized because there is no viable function for %select{'=='|'<'}0 comparison"
H6263B6389D1C: "세방향 비교를 합성할 수 없습니다. %select{'=='|'<'}0 비교에 사용 가능한 함수가 없기 때문입니다"
# 'threshold (in percent) for selecting functions to process in lite mode. Higher threshold means fewer functions to process. E.g threshold of 90 means only top 10 percent of functions with profile will be processed.'
HC3919B9CBB6D: 'threshold (퍼센트 단위)는 라이트 모드에서 처리할 함수를 선택하는 데 사용됩니다. 임계값이 높을수록 처리할 함수의 수가 줄어듭니다. 예를 들어, 임계값이 90인 경우 프로파일이 있는 함수 중 상위 10퍼센트만 처리됩니다.'
# 'tile arguments must refer to different tiles'
HC74F5110780C: '타일 인수는 서로 다른 타일을 참조해야 합니다'
# 'time BOLT aggregator'
H034122EC1DF6: '시간 BOLT 집계기'
# 'time frame analysis steps'
H18422D3F506F: '시간 프레임 분석 단계'
# 'time icf steps'
H17EA53E3423A: 'ICF 단계 시간 측정'
# "timed out waiting to acquire lock file for module '%0'"
HD7ADFA168199: "모듈 '%0'의 lock 파일을 획득하기 위해 대기하다가 시간 초과되었습니다."
# 'tls_model must be "global-dynamic", "local-dynamic", "initial-exec" or "local-exec"'
H2BCDC88FA47E: 'tls_model은 "global-dynamic", "local-dynamic", "initial-exec" 또는 "local-exec" 중 하나여야 합니다'
# 'to match this %0'
HDA13A5D2D868: '이 %0와 일치해야 합니다'
# "to match this ']'"
HEF9A1EC0D665: "이 ']'와 일치합니다."
# "to match this '{'"
H013B6E508561: "이 '{'와 일치시키기 위해"
# 'token is not a valid binary operator in a preprocessor subexpression'
H93EB0C533EDF: '토큰은 프리프로세서 하위 표현식에서 유효한 이항 연산자가 아닙니다'
# "token pasting of ',' and __VA_ARGS__ is a GNU extension"
H13889DCFA50D: "','와 '__VA_ARGS__'의 토큰 결합은 GNU 확장 기능입니다."
# 'too %select{few|many}0 arguments in call to %1'
H55C9E37AE906: '호출 %1에서 인수가 %select{너무 적습니다|너무 많습니다}0'
# 'too %select{few|many}0 initializers in list for type %1 (expected %2 but found %3)'
HD545C2517E80: '목록에 %select{적음|많음}0 초기화자가 %1 형식에 맞지 않습니다 (예상 %2개지만 %3개 발견됨)'
# 'too %select{few|many}0 parameters in the signature specified by the %1 attribute (expected %2; got %3)'
H6F4276FDBDF1: '지정된 %1 속성의 시그니처에 너무 %select{적은|많은}0 매개변수가 있습니다 (기대: %2개; 입력: %3개)'
# 'too %select{many|few}0 type arguments for class %1 (have %2, expected %3)'
H35A08DFD5F2A: '클래스 %1에 대한 형식 인수가 너무 %select{많은|적은}0 (현재 %2개, 예상 %3개)'
# 'too few %select{|||execution configuration }0%select{|non-object }2arguments to %select{function|block|method|kernel function}0 call, at least argument %1 must be specified'
HF6BA10037D33: '인수 개수가 너무 적습니다: %select{|||실행 구성 }0%select{|비객체 }2%select{함수|블록|메서드|커널 함수}0 호출은 최소 %1 인수를 지정해야 합니다'
# 'too few %select{|||execution configuration }0%select{|non-object }2arguments to %select{function|block|method|kernel function}0 call, single argument %1 was not specified'
H9CA8A408A5C7: '%select{|||실행 구성 }0%select{|비객체 }2인수가 너무 적습니다; 단일 %select{함수|블록|메소드|커널 함수}0 호출에 대한 인수 %1이 지정되지 않았습니다'
# 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2'
H5939FAB31ED6: '인수가 너무 적습니다 %select{|||실행 구성 }0%select{|비객체 }3인 %select{함수|블록|메서드|커널 함수}0 호출에, 기대한 %1개, %2개 있음'
# 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2; did you mean %4?'
HF20F679C52F2: '인수가 너무 적습니다: %select{|||실행 구성 }0%select{|비객체 }3인수 %select{함수|블록|메소드|커널 함수}0 호출에 %1개가 필요하지만 %2개가 있음; 의도한 것은 %4일까요?'
# 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at least %1, have %2'
HD24171A04B0B: '%select{|||실행 구성 }0%select{|비객체 }3인수가 너무 적습니다; %select{함수|블록|메소드|커널 함수}0 호출에 최소 %1개가 필요하지만 %2개가 있습니다'
# 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at least %1, have %2; did you mean %4?'
HD3BBC6D9EFC0: '%select{|||실행 구성 }0%select{|비객체 }3인수의 개수가 %select{함수|블록|메소드|커널 함수}0 호출에 전달된 것이 너무 적습니다. 최소 %1개가 필요하지만 %2개만 있습니다; %4를 의미하려는 건가요?'
# 'too few arguments provided to function-like macro invocation'
H1E346A7B8B3C: '함수 형식 매크로 호출에 제공된 인수가 너무 적습니다.'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2'
H90F884ECB318: '너무 많은 %select{|||실행 구성 }0%select{|비객체 }3인자를 %select{function|block|method|kernel function}0 호출에 전달했습니다. 예상된 인자는 %1개이지만, %2개가 있습니다.'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2; did you mean %4?'
HCA745DFE1FDF: '%select{|||실행 구성 }0%select{|비객체 }3인수가 너무 많습니다; %select{함수|블록|메소드|커널 함수}0 호출에 %1개가 필요하지만 %2개가 있습니다; %4를 의미했나요?'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at most %1, have %2'
H94A2619722A2: '너무 많은 %select{|||실행 구성 }0%select{|비객체 }3인수가 %select{함수|블록|메소드|커널 함수}0 호출에 전달되었습니다. 최대 %1개가 허용되나 %2개가 있습니다.'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at most %1, have %2; did you mean %4?'
HE9A38EF19888: '%select{|||실행 구성 }0%select{|비객체 }3인수가 너무 많습니다; %select{함수|블록|메소드|커널 함수}0 호출에 최대 %1개가 필요하지만 %2개가 있습니다; %4를 의미했나요?'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected single argument %1, have %2 arguments'
HDBD2C1E2CE61: '인수가 너무 많습니다. %select{|||실행 구성 }0%select{|비객체 }3인수 %select{함수|블록|메서드|커널 함수}0 호출에 전달되었습니다. 예상된 인수는 %1개지만, %2개가 전달되었습니다'
# 'too many %select{|||execution configuration }0arguments to %select{function|block|method|kernel function}0 call, expected at most single %select{|non-object }3argument %1, have %2%select{|non-object}3 arguments'
HDAC13624D426: '%select{|||실행 구성 }0인수가 너무 많습니다; %select{함수|블록|메소드|커널 함수}0 호출에 최대 %select{|비객체 }3인수 %1이 허용되나 %2%select{|비객체}3 인수가 있습니다'
# 'too many arguments provided to function-like macro invocation'
HBB5E8EFBFD08: '함수형 매크로 호출에 전달된 인수가 너무 많습니다'
# 'too many braces around %select{scalar |}0initializer'
H5C95D607138A: '중첩된 중괄호가 %select{스칼라 |}0초기식 주위에 너무 많습니다.'
# 'too many errors emitted, stopping now'
H208E3BCCF078: '발생한 오류가 너무 많아 중단합니다'
# 'too many function parameters; subsequent parameters will be ignored'
H803517A338E0: '함수 매개변수가 너무 많습니다; 이후 매개변수는 무시됩니다'
# "too many parameters (%0) for 'main': must be 0, 2, or 3"
H39E16B39631F: 'main 함수에 전달된 매개변수 개수가 너무 많습니다 (%0): 0, 2 또는 3이어야 합니다'
# 'tool-template options'
HBCF3F3069BB4: '도구 템플릿 옵션'
# 'top-level comma expression in array subscript is deprecated in C++20 and unsupported in C++23'
HE89EE6B0F334: '배열 서브스크립트의 최상위 콤마 표현식은 C++20에서 비추천 되며 C++23에서는 지원되지 않습니다'
# 'total number of threads cannot exceed %0'
H1884DB567221: '총 스레드 수는 %0를 초과할 수 없습니다'
# 'total token limit set here'
HC6BF74A3FD57: '여기에서 총 토큰 제한이 설정되었습니다'
# 'toy compiler\n'
H2EDD43662B08: '도구형 컴파일러\n'
# 'trailing requires clause can only be used when declaring a function'
H084306C3877A: '트레일링 requires 절은 함수를 선언할 때만 사용할 수 있습니다'
# 'trailing requires clause should be placed outside parentheses'
H548F58E8723A: '뒤따르는 requires 절은 괄호 밖에 배치되어야 합니다'
# 'trailing return type may not be nested within parentheses'
HC76578BE367C: '후행 반환 형식은 괄호 내에 중첩될 수 없습니다'
# 'trailing return type must appear before trailing requires clause'
HA5D12CC5013B: '후치 리턴 타입은 후치 requires 절보다 앞에 와야 합니다.'
# 'trailing return types are incompatible with C++98'
H32DC951D7875: '추적 반환 형식은 C++98과 호환되지 않습니다'
# 'translate addresses using BAT'
HDDEE1DC9B85A: 'BAT를 사용한 주소 변환'
# 'translation unit contains multiple module declarations'
HF895A4F45EF2: '번역 단위에 모듈 선언이 여러 개 있습니다.'
# 'translation unit is too large for Clang to process: ran out of source locations'
H8B3695BCDB65: '번역 단위가 Clang가 처리할 수 있는 크기를 초과했습니다: 소스 위치 자원이 부족했습니다'
# 'transparent union definition must contain at least one field; transparent_union attribute ignored'
H140F1B74DF83: '투명 유니언 정의는 적어도 하나의 필드를 포함해야 합니다; transparent_union 속성이 무시되었습니다'
# 'transparent_union attribute can only be applied to a union definition; attribute ignored'
HD786E3576B74: 'transparent_union 속성은 유니언 정의에만 적용될 수 있습니다; 속성이 무시됩니다'
# 'trap on failure'
H4518B36E2611: '실패 시 중단'
# 'treat the string as an argument to avoid this'
H276A4BE7C44E: '이 문제를 피하려면 문자열을 인수로 처리하십시오.'
# "treating #%select{include|import|include_next|__include_macros}0 as an import of module '%1'"
HCF878B660176: " #%select{include|import|include_next|__include_macros}0을 모듈 '%1'의 임포트로 처리합니다"
# "treating '%0' input as '%1' when in C++ mode, this behavior is deprecated"
H0FA024F7C782: "C++ 모드에서 '%0' 입력을 '%1'로 처리하는 동작은 deprecated 됩니다"
# 'treating Ctrl-Z as end-of-file is a Microsoft extension'
H2B9F3B693225: 'Ctrl-Z를 EOF로 처리하는 것은 Microsoft 확장 기능입니다'
# "treating Unicode character <U+%0> as an identifier character rather than as '%1' symbol"
H50914464E633: "유니코드 문자 <U+%0>를 '%1' 기호 대신 식별자 문자로 처리합니다."
# 'treating Unicode character as whitespace'
HF7B2E2527DE4: '유니코드 문자를 공백으로 처리함'
# "trigraph converted to '%0' character"
HED476D72F781: "삼각문자가 '%0' 문자로 변환되었습니다"
# 'trigraph ends block comment'
H52594FE74E90: '트리그라프가 블록 주석을 종료합니다'
# 'trigraph ignored'
H1C535A7D3139: '트리그래프가 무시되었습니다'
# 'trust the input to be from a well-formed source'
H9D6FAC2CFAB6: '입력을 잘 형성된 소스로부터 왔다고 믿습니다'
# "try 'match(%0={%1%2})'"
H766B462800CF: "다음과 같이 시도해 보세요: 'match(%0={%1%2})'"
# 'try to preserve basic block alignment'
H8B07C548FF85: '기본 블록 정렬을 유지하려고 시도합니다'
# 'trying to recursively use %0 as superclass of %1'
H22C1DF007CBE: '재귀적으로 %0을 %1의 슈퍼클래스로 사용하려고 합니다'
# 'turn on the stoke analysis'
H0C2490B9B2A0: '스토크 분석을 켭니다'
# 'type %0 can only be used as a function parameter in OpenCL'
H43CCACC05DF1: '타입 %0는 OpenCL에서 함수 매개변수로만 사용할 수 있습니다'
# 'type %0 cannot be decomposed'
HAD575CEF4CDD: '타입 %0는 분해할 수 없습니다'
# 'type %0 cannot be narrowed to %1 in initializer list'
HA66630D471E5: '형식 %0는 초기화자 목록에서 %1로 좁혀지지 않을 수 없습니다'
# 'type %0 cannot be narrowed to %1 in initializer list in C++11'
H121C0CF66257: 'C++11의 초기화자 목록에서 %0 타입은 %1로 좁아질 수 없습니다.'
# "type %0 cannot be used prior to '::' because it has no members"
HB29A2AE6A5EB: "타입 %0는 '::' 앞에 사용할 수 없습니다.因为它의 멤버가 없기 때문입니다."
# 'type %0 decomposes into %3 %plural{1:element|:elements}2, but %select{%plural{0:no|:only %1}1|%1}4 %plural{1:name was|:names were}1 provided'
HF59CA2FD696F: '%0 형식은 %3 %plural{1:요소|:요소들}2로 분해되지만, %select{%plural{0:없음|:단독 %1}1|%1}4 %plural{1:이름이|:이름들이}1 제공되었습니다'
# 'type %0 does not provide a %select{subscript|call}1 operator'
HCAF6714D32F7: '타입 %0는 %select{인덱싱|호출}1 연산자를 제공하지 않습니다'
# 'type %0 found by destructor name lookup'
H35BD375D3364: '소멸자 이름 검색을 통해 %0 형식이 발견되었습니다.'
# 'type %0 has %select{an attribute|a member with an attribute}1 which currently causes the types to be treated as though they are incompatible'
HAC4DA8103F8D: '유형 %0은(는) %select{속성을 가진|속성 있는 멤버}1을(를) 포함하며 현재 이는 유형을 호환되지 않는 것으로 간주하게 만듭니다'
# 'type %0 has incompatible definitions%select{| in different translation units}1'
HF1AFD0FA558D: '유형 %0은(는) 불일치하는 정의를 가집니다%select{| 다른 번역 단위에서}1'
# 'type %0 has unexpected layout'
H8C8909F11F0A: '형식 %0에는 예상치 못한 레이아웃이 있습니다.'
# 'type %0 in generic association compatible with previously specified type %1'
H1178A958ED5C: '제네릭 연관에서 %0 형식은 이전에 지정된 %1 형식과 호환됩니다'
# 'type %0 in generic association is a variably modified type'
HCA8F3A82743E: '제네릭 결합에서의 유형 %0는 가변적으로 수정된 유형입니다'
# 'type %0 in generic association not an object type'
H9CBDAFFFD0D2: '제네릭 연관에서의 유형 %0은 객체 유형이 아닙니다'
# "type %0 is already '__ptrauth'-qualified"
H046D04C84060: "형식 %0은(는) 이미 '__ptrauth'-한정자 처리되어 있습니다."
# 'type %0 is incomplete'
H68C687943CFB: '타입 %0는 완성되지 않았습니다'
# 'type %0 is not a direct or virtual base of %1'
HA6EFF9DEE3C5: 'type %0는 %1의 직계 또는 가상 기반 클래스가 아닙니다'
# 'type %0 is not trivially copyable and not guaranteed to be mapped correctly'
HA6A4CD2AE815: '유형 %0은 단순히 복사 가능하지 않으며 올바르게 매핑되도록 보장되지 않습니다'
# 'type %0 of function parameter pack does not contain any unexpanded parameter packs'
H5D64B61067E5: '함수 매개변수 패키지의 %0 형식은 확장되지 않은 매개변수 패키지를 포함하지 않습니다'
# 'type %0 of non-type template parameter is not a structural type'
H546F4F02218C: '비유형 템플릿 매개변수의 유형 %0는 구조적 유형이 아닙니다.'
# 'type %0 requires %1 bytes of alignment and the default allocator only guarantees %2 bytes'
H82A5F7C1A758: '타입 %0는 %1 바이트의 정렬을 필요로 하지만 기본 할당자는 %2 바이트만 보장합니다'
# 'type %2 of %select{explicit instantiation|explicit specialization|partial specialization|redeclaration}0 of %1 does not match expected type %3'
H34154FB5D28F: '유형 %2는 %1의 %select{명시적 인스턴스화|명시적 특수화|부분 특수화|재선언}0의 것으로 예상되는 유형 %3와 일치하지 않습니다'
# "type argument %0 cannot be qualified with '%1'"
HF21B2C8937B4: "형식 인수 %0는 '%1'로 자격을 부여할 수 없습니다"
# 'type argument %0 cannot explicitly specify nullability'
H1330164CF91E: '타입 인수 %0는 명시적으로 nullability를 지정할 수 없습니다.'
# 'type argument %0 does not satisfy the bound (%1) of type parameter %2'
H3669CF5C9A7D: '타입 인수 %0는 타입 매개변수 %2의 제약(%1)을 충족하지 않습니다.'
# 'type argument %0 is neither an Objective-C object nor a block type'
HC89732C094A1: '타입 인수 %0는 Objective-C 객체나 블록 타입 중 하나도 아닙니다'
# "type argument %0 must be a pointer (requires a '*')"
HF674997DE917: "형식 인수 %0는 포인터여야 합니다 ( '*'가 필요합니다)"
# 'type argument of iboutletcollection attribute cannot be a builtin type'
H26C24AC03DB8: 'iboutletcollection 속성의 유형 인수는 내장 유형일 수 없습니다'
# 'type arguments cannot be applied to already-specialized class type %0'
H67EB09767F26: '형식 인수는 이미 특수화된 class 형식 %0에 적용할 수 없습니다'
# 'type arguments cannot be applied to non-class type %0'
H41CCF55FF38B: '타입 인수는 non-class type %0에 적용될 수 없습니다'
# 'type arguments cannot be applied to non-parameterized class %0'
HC40C2F44A862: '형식 인수는 매개변수화되지 않은 클래스 %0에 적용할 수 없습니다'
# 'type aware %0 requires a matching type aware %select{|placement }1%2 to be declared in the same scope'
H9C477E0B6856: '유형 인식 %0는 같은 범위에서 선언된 일치하는 유형 인식 %select{|배치 }1%2가 필요합니다'
# 'type aware %0 will not be used for coroutine allocation'
H5B38A9DE0EAE: '유형 인식 %0는 코루틴 할당에 사용되지 않습니다'
# 'type aware allocators are a C++2c extension'
H55565F6468B1: '유형 인식 할당자는 C++2c 확장 기능입니다'
# 'type aware allocators are incompatible with C++ standards before C++2c'
H25EF1B0FAFC1: 'C++2c 이전 표준과는 타입 인식 할당자를 호환할 수 없습니다.'
# 'type bound %0 for type parameter %1 conflicts with %select{implicit|previous}2 bound %3%select{for type parameter %5|}4'
H7F10FC1165B9: '타입 매개변수 %1에 대한 타입 경계 %0이 %select{암시적|이전}2 경계 %3%select{타입 매개변수 %5에 대한|}4와 충돌합니다'
# 'type bound %0 for type parameter %1 is not an Objective-C pointer type'
H80B67C4F94CD: '유형 경계 %0는 유형 매개변수 %1에 대해 Objective-C 포인터 유형이 아닙니다'
# "type bound %1 for type parameter %0 cannot be qualified with '%2'"
H3CC7E562DE4D: "유형 매개변수 %0에 대한 형식 제한 %1은 '%2' 자격을 지정할 수 없습니다"
# 'type constraint differs in template redeclaration'
HA94E71A6CC7A: '템플릿 재선언에서 형식 제약이 다릅니다'
# 'type conversion function declared here'
H7B0CCA1F5818: '여기서 형 변환 함수가 선언되었습니다'
# 'type declaration hidden'
H161A31411076: '유형 선언이 숨겨졌습니다'
# 'type definition in a constexpr %select{function|constructor}0 is a C++14 extension'
HB61A32D40D4A: 'constexpr %select{function|constructor}0 내부의 타입 정의는 C++14 확장 기능입니다'
# 'type definition in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14'
H51291DDF6B58: 'constexpr %select{함수|생성자}0 내의 형식 정의는 C++14 이전의 C++ 표준과 호환되지 않습니다'
# 'type inference of a declaration other than a plain identifier with optional trailing attributes is a Clang extension'
HB4EF9FC7F52F: '일반 식별자가 아닌 선언에 선택적 후행 속성을 가진 경우의 타입 추론은 Clang 확장입니다'
# 'type is given name %0 for linkage purposes by this %select{typedef|alias}1 declaration'
HFEABA5A13E20: '이 %select{typedef|alias}1 선언문은 링크 목적으로 %0 이름을 타입에 지정합니다'
# 'type is not C-compatible due to this %select{base class|default member initializer|lambda expression|friend declaration|member declaration}0'
H8BEB926AC2A7: '유형은 이 %select{기본 클래스|멤버의 기본 초기화자|람다 표현식|친구 선언|멤버 선언}0 때문에 C 호환되지 않습니다.'
# 'type name does not allow %select{<ERROR>|constexpr|consteval|constinit}0 specifier to be specified'
H2BAC4BD9B411: '유형 이름은 %select{<ERROR>|constexpr|consteval|constinit}0 지정자를 지정할 수 없습니다'
# 'type name does not allow function specifier to be specified'
H63933758FA41: '유형 이름은 함수 지정자를 지정할 수 없습니다'
# 'type name does not allow storage class to be specified'
HD221C2943356: '타입 이름에는 저장 클래스를 지정할 수 없습니다'
# 'type name requires a specifier or qualifier'
H9BCBB335F47F: '형식 이름에는 지정자 또는 수식자가 필요합니다'
# 'type nullability specifier %0 is a Clang extension'
HFDBD8198839C: '타입 nullability 지정자 %0는 Clang의 확장 기능입니다'
# 'type of %ordinal0 parameter of local declaration does not match definition%diff{ ($ vs $)|}1,2'
HC35F751A0E20: '지역 선언의 %ordinal0 번째 매개변수의 형식이 정의와 일치하지 않습니다%diff{ ($ vs $)|}1,2'
# 'type of %ordinal0 parameter of member declaration does not match definition%diff{ ($ vs $)|}1,2'
H6D265791AD7D: '멤버 선언의 %ordinal0 번째 매개변수 유형이 정의와 일치하지 않습니다%diff{ ($ vs $)|}1,2'
# 'type of UTF-8 string literal will change from array of char to array of char8_t in C23'
HDD96729D3F80: 'UTF-8 문자열 리터럴의 유형이 C23에서 char 배열에서 char8_t 배열로 변경됩니다'
# 'type of UTF-8 string literal will change from array of const char to array of const char8_t in C++20'
H2FF4EC88FBDF: 'UTF-8 문자열 리터럴의 형식은 C++20에서 const char 배열에서 const char8_t 배열로 변경됩니다'
# 'type of machine mode does not match type of base type'
HCC37C6223BD0: '머신 모드의 유형과 기본 유형의 유형이 일치하지 않습니다'
# 'type of machine mode does not support base vector types'
HC82FE5FB775E: '이 머신 모드의 유형은 기본 벡터 유형을 지원하지 않습니다'
# 'type of property %0 (%1) does not match type of accessor %2 (%3)'
H588E7AE2B664: '속성 %0의 타입 (%1)은 접근자 %2의 타입 (%3)과 일치하지 않습니다'
# 'type of property %0 (%1) does not match type of instance variable %2 (%3)'
H73BAE4F8734B: '프로퍼티 %0 (%1)의 타입이 인스턴스 변수 %2 (%3)의 타입과 일치하지 않습니다'
# 'type of property %0 does not match type of accessor %1'
H270F876040C0: '속성 %0의 유형이 액세서 %1의 유형과 일치하지 않습니다'
# 'type of property %0 in class extension does not match property type in primary class'
H132F7594C298: '클래스 확장에서 %0 속성의 유형이 기본 클래스의 속성 유형과 일치하지 않습니다'
# 'type of setter must be void'
HD41AE4C60492: '세터의 타입은 void여야 합니다'
# 'type of specialized non-type template argument depends on a template parameter of the partial specialization'
HBDE8FF32FC3A: '특정화된 비유형 템플릿 인수의 형식이 부분 특수화의 템플릿 파라미터에 의존합니다'
# 'type of thread-local variable has non-trivial destruction'
H8E6776B80F65: '스레드 로컬 변수의 유형은 비트리비얼 소멸자를 가집니다.'
# "type operand %0 of 'typeid' cannot have '%1' qualifier"
HBE87B8BABE8E: "typeid 연산자의 %0 타입 피연산자는 '%1' 자격 증명을 가질 수 없습니다."
# 'type parameter %0 bound %1 cannot explicitly specify nullability'
H73C9FD2AB78B: '타입 매개변수 %0의 제약 %1에 nullability를 명시적으로 지정할 수 없습니다'
# 'type parameter %0 declared here'
HFF5B8C2A68FC: '형식 매개변수 %0 여기에서 선언되었습니다'
# "type specifier missing, defaults to 'int'"
H4B268E82A57A: "유형 지정자가 누락되었습니다. 기본값은 'int'입니다"
# "type specifier missing, defaults to 'int'; ISO C99 and later do not support implicit int"
H8CEE1B0F6CB9: "유형 지정자가 누락되었습니다; 기본값은 'int'로 설정되지만, ISO C99 및 이후 버전에서는 암시적 int를 지원하지 않습니다"
# 'type trait requires %0%select{| or more}1 argument%select{|s}2; have %3 argument%s3'
H5F2DEBC2DD6F: '타입 트레이트는 %0%select{| 또는 더 많은}1 인수%select{|들}2가 필요하지만 %3 인수%s3가 있습니다'
# 'type was declared read-only here'
HAFE8C580C1C1: '이 타입은 여기서 읽기 전용으로 선언되었습니다'
# 'type-id cannot have a name'
H0F4A38BF6BC0: 'type-id는 이름을 가질 수 없습니다'
# 'type-less parameter names in function declaration'
H4275A67CD2BD: '함수 선언에서 타입이 없는 매개변수 이름'
# 'typedef declarator cannot be qualified'
H13CBEB4EC130: 'typedef 선언자는 자격을 부여받을 수 없습니다'
# 'typedef member %0 cannot be a bit-field'
HF1C17DDE556A: 'typedef 멤버 %0는 비트 필드일 수 없습니다'
# 'typedef name must be an identifier'
H0FF9C8135AE0: 'typedef 이름은 식별자여야 합니다'
# 'typedef requires a name'
HD4A732841C3B: 'typedef은 이름이 필요합니다'
# 'typeid applied to expression of polymorphic type %0 is not allowed in a constant expression in C++ standards before C++20'
H56E5AEAEB4DB: 'typeid가 다형성 타입의 표현식 %0에 적용되는 것은 C++20 이전의 C++ 표준에서 상수 표현식 내에서는 허용되지 않습니다'
# 'typeid will not work since RTTI data is disabled by %select{-fno-rtti-data|/GR-}0'
H44DAF1F1B628: 'typeid는 RTTI 데이터가 %select{-fno-rtti-data|/GR-}0로 비활성화되어 동작하지 않습니다.'
# 'typename is allowed for identifiers only'
HEE2C4836DC27: 'typename은 식별자에만 사용할 수 있습니다'
# 'typename specifier refers to %select{class template|function template|variable template|alias template|template template parameter|template}0 member in %1; argument deduction not allowed here'
H15F65651B175: 'typename 지정자는 %select{클래스 템플릿|함수 템플릿|변수 템플릿|.alias 템플릿|템플릿 템플릿 매개변수|템플릿}0 멤버를 %1에 참조합니다; 여기서는 인수 추론이 허용되지 않습니다'
# 'typename specifier refers to %select{class template|function template|variable template|alias template|template template parameter|template}0; argument deduction not allowed here'
HDDA5FA8262A7: 'typename 지정자는 %select{클래스 템플릿|함수 템플릿|변수 템플릿|별칭 템플릿|템플릿 템플릿 매개변수|템플릿}0을 가리킵니다; 여기서는 인자 추론이 허용되지 않습니다'
# 'typename specifier refers to a dependent using declaration for a value %0 in %1'
HA4640204C28B: 'typename 지정자는 %1의 값 %0에 대한 의존적 using 선언문을 참조합니다'
# 'typename specifier refers to a non-type template'
HDA01E7DE1981: 'typename 지정자가 비유형 템플릿을 가리키고 있습니다'
# 'typename specifier refers to non-type %0'
H68FFAB15F6B4: 'typename 지정자가 비-타입 %0를 참조합니다'
# 'typename specifier refers to non-type member %0 in %1'
HAD3AB5D3DF5D: 'typename 지정자가 %1 내의 비형식 멤버 %0를 참조합니다'
# 'types cannot be declared in an anonymous %select{struct|union}0'
HB8A6E3596B04: '타입은 익명의 %select{struct|union}0 내에서 선언할 수 없습니다'
# 'types declared in an anonymous %select{struct|union}0 are a Microsoft extension'
H10CD33288972: '익명 %select{struct|union}0로 선언된 타입은 Microsoft 확장 기능입니다'
# 'types may not be defined in a for range declaration'
HA0579AB1E4A8: '유형은 범위 기반 for 문 선언 내에서 정의할 수 없습니다.'
# "types with 'sycl_special_class' attribute must have one and only one '__init' method defined"
H49F85977919C: "sycl_special_class 속성을 가진 유형은 '__init' 메서드를 정확히 하나만 정의해야 합니다."
# "umbrella directory '%0' not found"
H7F60E99942C1: "우산 디렉토리 '%0'을(를) 찾을 수 없습니다"
# "umbrella for module '%0' already covers this directory"
HAE8DEE1E4013: "모듈 '%0'의 우산은 이미 이 디렉토리를 포함합니다"
# "umbrella header for module '%0' does not include header '%1'"
H803B3F536D5A: "모듈 '%0'의 상사 헤더가 헤더 '%1'을 포함하지 않습니다"
# "unable to create target: '%0'"
H48D73D54C838: "타겟을 생성할 수 없습니다: '%0'"
# 'unable to execute command: %0'
H1274C3267D8B: '명령어를 실행할 수 없습니다: %0'
# "unable to find %0 directory, expected to be in '%1' found via %2"
HFA08DE02A86A: "지정된 %0 디렉토리를 찾을 수 없습니다, '%1' 위치에서 %2를 통해 찾았습니다"
# "unable to find %select{'::operator new(size_t, nothrow_t)'|'::operator new(size_t, align_val_t, nothrow_t)'}1 for %0"
HD53B43D38AB3: "지정된 %select{'::operator new(size_t, nothrow_t)'|'::operator new(size_t, align_val_t, nothrow_t)'}1 중 하나를 %0에 대해 찾을 수 없습니다"
# 'unable to find a Visual Studio installation; try running Clang from a developer command prompt'
HD5A60BEBFC34: 'Visual Studio 설치를 찾을 수 없습니다. 개발자 명령 프롬프트에서 Clang을 실행해 보십시오.'
# "unable to find module '%0'"
H4F4B8FBAA599: "모듈 '%0'를 찾을 수 없습니다"
# "unable to find plugin '%0'"
H694242203542: "플러그인 '%0'을 찾을 수 없습니다"
# "unable to handle compilation, expected exactly one compiler job in '%0'"
H0ED90FBA3001: "컴파일을 처리할 수 없습니다, '%0'에서 정확히 하나의 컴파일 작업을 예상했습니다"
# 'unable to interface with target machine'
H48913BEFE8AE: '타겟 머신과 인터페이스 할 수 없습니다'
# 'unable to load PCH file'
H0C8F5802F259: 'PCH 파일을 로드할 수 없습니다'
# "unable to load basic block sections function list: '%0'"
H3C61D53F0989: "기본 블록 섹션 함수 목록을 로드할 수 없음: '%0'"
# "unable to load plugin '%0': '%1'"
HEABDF34863F0: "플러그인 '%0'을 로드할 수 없습니다: '%1'"
# 'unable to make temporary file: %0'
HB69A4D68B994: '임시 파일을 만들 수 없습니다: %0'
# "unable to merge a subprocess's serialized diagnostics"
H0736A846C8D2: '서브프로세스의 직렬화된 진단 정보를 병합할 수 없습니다'
# 'unable to open CC_LOG_DIAGNOSTICS file: %0 (using stderr)'
H5386FA1E767C: 'CC_LOG_DIAGNOSTICS 파일을 열 수 없습니다: %0 (stderr를 사용함)'
# 'unable to open CC_PRINT_HEADERS file: %0 (using stderr)'
H9ABA30151CEC: 'CC_PRINT_HEADERS 파일을 열 수 없습니다: %0 (stderr을 사용함)'
# 'unable to open CC_PRINT_OPTIONS file: %0'
HEA741366E890: 'CC_PRINT_OPTIONS 파일을 열 수 없습니다: %0'
# 'unable to open file %0 for serializing diagnostics (%1)'
HD09A684B5E47: '진단 정보 직렬화를 위해 파일 %0을 열 수 없습니다 (%1)'
# "unable to open output file '%0': '%1'"
H1FD155FFBE98: "출력 파일 '%0'을(를) 열 수 없습니다: '%1'"
# "unable to open statistics output file '%0': '%1'"
HDC9884A86150: "통계 출력 파일 '%0'을(를) 열 수 없습니다: '%1'"
# 'unable to overwrite file %0: %1'
HF040F371E4DB: '파일 %0를 덮어쓰지 못했습니다: %1'
# 'unable to protect inline asm that clobbers stack pointer against stack clash'
H57F37138A9DF: '인라인 어셈블리가 스택 포인터를 파괴하는 것을 스택 충돌로부터 보호할 수 없습니다'
# "unable to read PCH file %0: '%1'"
H53BCE7FDE626: "PCH 파일 %0을 읽을 수 없습니다: '%1'"
# 'unable to remove file: %0'
HA87F741C0BFD: '파일을 삭제하지 못했습니다: %0'
# "unable to rename temporary '%0' to output file '%1': '%2'"
H621AA5D0DBAB: "임시 파일 '%0'을(를) 출력 파일 '%1'로 이름을 변경하지 못했습니다: '%2'"
# 'unable to resolve declare reduction construct for type %0'
H4CBC0B2EAEEC: '형 %0에 대한 declare reduction 구조를 해결할 수 없습니다.'
# 'unable to set working directory: %0'
H1915AC32A7BB: '작업 디렉터리를 설정할 수 없습니다: %0'
# 'unannotated fall-through between switch labels'
HD2F0C0FDF581: '어노테이션이 없는 switch 레이블 사이의 떨어짐'
# 'unannotated fall-through between switch labels in partly-annotated function'
H8BA6FF77BB8B: '부분 주석 처리된 함수 내 switch 라벨 간의 비주석 처리된 fall-through'
# "unary fold expression has empty expansion for operator '%0' with no fallback value"
HE62A3703EA3A: "단항 접합 표현식은 연산자 '%0'에 대한 확장이 비어 있고 대체값이 없습니다"
# 'unary operator not supported, only increment and decrement operations permitted'
HCFDDCEAA7D4F: '단항 연산자는 지원되지 않습니다. 오직 increment 및 decrement 연산자만 허용됩니다.'
# 'undeclared identifier %0 in destructor name'
H9E161BF60045: '소멸자 이름에 미선언된 식별자 %0'
# 'undeclared selector %0'
H76DFE4FB888F: '미선언된 선택자 %0'
# 'undeclared selector %0; did you mean %1?'
HFF50CB7951F9: '선언되지 않은 선택기 %0; %1을(를) 의도하셨는지요?'
# "undeclared variable %0 used as an argument for '#pragma unused'"
H1A926D40EA78: "선언되지 않은 변수 %0이 '#pragma unused'의 인수로 사용되었습니다"
# 'undef all system defines'
H5E817AACEB7A: 'undef 모든 시스템 defines'
# 'undefining builtin macro'
H855B9F8C6AE6: '내장 매크로 정의 해제'
# 'under -fcoro-aligned-allocation, the non-aligned allocation function for the promise type %0 has higher precedence than the global aligned allocation function'
H677A6074184D: '-fcoro-aligned-allocation 옵션 하에서, 프로미스 타입 %0의 비정렬된 할당 함수가 전역 정렬된 할당 함수보다 우선 순위가 높습니다'
# 'underaligned exception object thrown'
H67F3421C41BE: '미대齐렬된 예외 개체가 던져짐'
# "unelaborated friend declaration is a C++11 extension; specify '%select{struct|interface|union|class|enum}0' to befriend %1"
H85486A35A143: "명시되지 않은 친구 선언은 C++11 확장 기능입니다; %1을 친구로 지정하려면 '%select{구조체|인터페이스|유니온|클래스|열거형}0'을 지정해야 합니다"
# 'unexpected %0 in function call; perhaps remove the %0?'
HF91D5DDAC941: '함수 호출 중 예상치 못한 %0이 있습니다; %0을 제거해야 할 수도 있습니다'
# "unexpected %0, expected to see one of %select{|'best_case', 'full_generality', }1'single_inheritance', 'multiple_inheritance', or 'virtual_inheritance'"
H715E4C7A8362: "예상하지 못한 %0, %select{|'best_case', 'full_generality', }1'single_inheritance', 'multiple_inheritance', 또는 'virtual_inheritance' 중 하나가 예상되었습니다"
# "unexpected '#pragma acc ...' in program"
H1E1E01704393: "프로그램 내에서 예상치 않은 '#pragma acc ...'가 발견되었습니다."
# "unexpected '#pragma omp ...' in program"
H46D7021997C2: "프로그램 내에서 예상치 못한 '#pragma omp ...'가 있습니다"
# "unexpected '%0' clause, '%1' is specified already"
H5B200478E6AE: "예상치 못한 '%0' 절, '%1'은 이미 지정되었습니다"
# "unexpected '%0' clause, only %select{'device_type'|'enter' or 'link'|'enter', 'link' or 'device_type'|'device_type', 'indirect'|'enter', 'link', 'device_type' or 'indirect'}1 clauses expected"
H3763BE9D9C9F: "예상치 못한 '%0' 절입니다. 오직 %select{'device_type'|'enter 또는 link'|'enter, link 또는 device_type'|'device_type 또는 indirect'|'enter, link, device_type 또는 indirect'}1 절만 허용됩니다."
# "unexpected '%0' clause, only %select{'device_type'|'to' or 'link'|'to', 'link' or 'device_type'|'device_type', 'indirect'|'to', 'link', 'device_type' or 'indirect'}1 clauses expected"
H1A9F6651CC12: '"%0" 절이 예상되지 않았습니다. 다음 중 하나의 절만 예상됩니다: %select{\'device_type\'|\'to\' 또는 \'link\'|\'device_type\', \'link\' 또는 \'device_type\'|\'device_type\', \'indirect\'|\'to\', \'link\', \'device_type\' 또는 \'indirect\'}1'
# "unexpected '(', only 'to', 'link' or 'device_type' clauses expected for 'begin declare target' directive"
H5361030EF185: "기대하지 않은 '('입니다. 'begin declare target' 지시문에서는 'to', 'link', 또는 'device_type' 절만 예상됩니다."
# "unexpected ':' in nested name specifier; did you mean '::'?"
HC8B611B07937: "중첩된 이름 지정자 내 예상치 못한 ':'; '::'를 의미하는 것이었나요?"
# "unexpected ';' before %0"
H257D20769B88: "예상하지 못한 ';'이 %0 앞에 있습니다"
# "unexpected '@' in member specification"
HFD6F988E847A: "멤버 선언 중 예상치 못한 '@'가 있습니다."
# "unexpected '@' in program"
H0E6C2D976254: "예상치 않은 '@'가 프로그램에 있습니다"
# "unexpected 'enter' clause, use 'to' instead"
H005905027939: "예상하지 못한 'enter' 절입니다. 대신 'to'를 사용하세요."
# "unexpected 'execution' modifier in non-executable context"
HA6BB9CA468FA: "실행 가능한 컨텍스트가 아닌 곳에서 예상치 못한 'execution' 수정자를 발견했습니다"
# "unexpected 'to' clause, use 'enter' instead"
H48CD21AE4031: "예상하지 못한 'to' 절입니다. 대신 'enter'를 사용하세요."
# "unexpected OpenACC directive %select{|'#pragma acc %1'}0"
H996256861627: "예상치 못한 OpenACC 지시문 %select{|'#pragma acc %1'}0"
# "unexpected OpenMP clause '%0' in directive '#pragma omp %1'"
H1C5752C27ACF: "지시문 '#pragma omp %1'에서 예상치 못한 OpenMP 절 '%0'이 발견되었습니다."
# "unexpected OpenMP directive %select{|'#pragma omp %1'}0"
HEF8086A19118: "예상치 못한 OpenMP 지시문 %select{|'#pragma omp %1'}0"
# "unexpected argument '%0' to '#pragma %1'%select{|; expected %3}2"
HB8C385DE07A5: "'#pragma %1'에 예상치 못한 인자 '%0'이(가) 있습니다%select{|; %3이(가) 예상되었습니다}2"
# "unexpected argument '%0' to '#pragma clang attribute'; expected 'push' or 'pop'"
H3133E5143B09: "'#pragma clang attribute'에 대한 예상치 못한 인자 '%0'; 'push' 또는 'pop'이 예상됩니다"
# "unexpected argument '%0' to '#pragma clang fp %1'; expected %select{'fast' or 'on' or 'off'|'on' or 'off'|'on' or 'off'|'ignore', 'maytrap' or 'strict'|'source', 'double' or 'extended'}2"
H371571C43BD4: "예상하지 못한 인수 '%0'이 '#pragma clang fp %1'에 전달되었습니다; %select{'fast' 또는 'on' 또는 'off'|'on' 또는 'off'|'on' 또는 'off'|'ignore', 'maytrap' 또는 'strict'|'source', 'double' 또는 'extended'}2가 예상되었습니다"
# "unexpected argument '%0' to '#pragma clang optimize'; expected 'on' or 'off'"
H1485FAA86056: "'#pragma clang optimize'에 대한 예상하지 않은 인수 '%0'; 'on' 또는 'off'가 예상되었습니다"
# 'unexpected argument to debug command'
H3827CC068DE1: '디버그 명령어에 예상치 못한 인수가 전달되었습니다'
# 'unexpected character <U+%0>'
H5B9099D7894E: '예상치 못한 문자 <U+%0>'
# "unexpected clause after an implicit 'enter' clause"
H3710E8F80D5B: "암시적 'enter' 절 이후에 예상치 못한 절이 있습니다."
# "unexpected clause after an implicit 'to' clause"
H2010F6D7C809: "암시적인 'to' 절 이후에 예상치 못한 절이 있습니다"
# "unexpected debug command '%0'"
H8054F9A13F94: "예상치 못한 디버그 명령 '%0'"
# 'unexpected end of default argument expression'
H2637B90369AC: '예상치 않은 디폴트 인자 표현식의 끝'
# 'unexpected end of exception specification'
HE58D2A2E3875: '예외 지정에서 예상하지 않은 종료'
# 'unexpected expression: number of expressions is larger than the number of associated loops'
H7A04530C8247: '예상치 못한 표현: 표현식의 수가 관련된 루프의 수보다 큽니다'
# "unexpected extra argument '%0' to '#pragma clang optimize'"
HD169A0238D64: "'#pragma clang optimize'에 대한 예상치 못한 추가 인수 '%0'가 있음"
# 'unexpected extra tokens at end of @import declaration'
HC94D2D8555A6: '예상하지 못한 추가 토큰이 @import 선언문의 끝 부분에 있습니다'
# 'unexpected interface name %0: expected expression'
HD34771026F11: '예상치 못한 인터페이스 이름 %0: 표현식이 필요합니다'
# 'unexpected namespace name %0: expected expression'
HD2F7F8269F1D: '예상치 못한 네임스페이스 이름 %0: 표현식이 예상됨'
# 'unexpected namespace scope prior to decltype'
H276642EE3F52: 'decltype 이전에 예상하지 못한 네임스페이스 범위'
# "unexpected operation specified in 'append_args' clause, expected 'interop'"
H7343FC2DA837: "'append_args' 절에서 예상하지 못한 연산이 지정되었습니다. 'interop'가 예상되었습니다."
# "unexpected output symbol graph '%1'; please provide '--symbol-graph-dir=<directory>' instead"
H16E9C665ACBA: "예상치 못한 출력 심볼 그래프 '%1'; 대신 '--symbol-graph-dir=<디렉토리>'를 제공해 주세요"
# "unexpected parameter '%0' in availability attribute, not permitted in %select{HLSL|C/C++}1"
H3A2F294B2383: "availability 속성에 예상하지 못한 매개변수 '%0'가 있습니다. %select{HLSL|C/C++}1에서는 허용되지 않습니다."
# 'unexpected token after Objective-C string'
H279452517A7B: 'Objective-C 문자열 이후에 예상하지 못한 토큰이 있습니다.'
# 'unexpected token in pragma diagnostic'
HF7F8BD94B55D: 'pragma diagnostic에 예상되지 않은 토큰이 있습니다.'
# 'unexpected type name %0: expected expression'
H5096D6005D2D: '예상하지 않은 형식 이름 %0: 표현식이 예상되었습니다'
# 'unexpected type name %0: expected identifier'
HECE4BA85049C: '예상치 못한 타입 이름 %0: 식별자가 필요합니다'
# "unexpected value; use 'true' or 'false'"
HBC54A5A54D19: "예상치 못한 값; 'true' 또는 'false'를 사용하십시오"
# 'unguarded header; consider using #ifdef guards or #pragma once'
H1B291D4D56CA: '보호되지 않은 헤더입니다; #ifdef guards나 #pragma once를 사용하는 것을 고려하세요'
# 'unicode literals are incompatible with C standards before C23'
H7CE9D5273D56: '유니코드 리터럴은 C23 이전의 C 표준과 호환되지 않습니다'
# 'unicode literals are incompatible with C++ standards before C++17'
H41D963C4F029: '유니코드 리터럴은 C++17 이전의 C++ 표준과 호환되지 않습니다'
# 'unicode literals are incompatible with C++98'
H63FE9D503E73: 'unicode literals는 C++98과 호환되지 않습니다'
# 'unicode literals are incompatible with C99'
H413288F05A72: '유니코드 리터럴은 C99와 호환되지 않습니다.'
# 'unimplemented constexpr lambda feature: %0 (coming soon!)'
H49A46ED86D09: '구현되지 않은 constexpr 람다 기능: %0 (곧 추가될 예정입니다!)'
# 'unimplemented pure virtual method %0 in %1'
H6BCBAEFB56A1: '구현되지 않은 순수 가상 메서드 %0 in %1'
# 'uninitialized reference member is here'
HD2F77230D93D: '초기화되지 않은 참조 멤버가 여기 있습니다'
# 'uninitialized variable in a constexpr %select{function|constructor}0 is a C++20 extension'
HD0E4F93C0D47: 'constexpr %select{함수|생성자}0 내의 초기화되지 않은 변수는 C++20 확장 기능입니다'
# 'uninitialized variable in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++20'
HB023F58DC7FA: '초기화되지 않은 변수가 있는 constexpr %select{function|constructor}0는 C++20 이전의 C++ 표준과 호환되지 않습니다'
# 'union member %0 has reference type %1'
H0725C5FA90A3: 'union 멤버 %0는 reference type %1을 가집니다'
# 'union member %0 has reference type %1, which is a Microsoft extension'
H717E84EDF789: '유니언 멤버 %0는 참조 형식 %1을 가지며, 이는 Microsoft 확장 기능입니다'
# 'unions cannot be base classes'
H3537D21C3F62: '유니언은 기본 클래스로 사용할 수 없습니다'
# 'unions cannot have base classes'
HC69C8BA7958A: '유니온은 기반 클래스를 가질 수 없습니다'
# 'unions cannot have virtual functions'
HE6462B703CAB: '유니언은 가상 함수를 가질 수 없습니다.'
# 'universal character name referring to a control character is incompatible with C standards before C23'
H443795B4C160: '제어 문자를 가리키는 유니버설 문자 이름은 C23 이전의 C 표준과 호환되지 않습니다'
# 'universal character name referring to a control character is incompatible with C++98'
H441444D5A2FF: '제어 문자를 가리키는 유니버설 문자 이름은 C++98과 호환되지 않습니다'
# 'universal character name refers to a control character'
H0A302EE7A7D5: 'universal character name이 제어 문자를 가리킵니다'
# 'universal character name refers to a surrogate character'
H38343641D115: '유니버설 문자 이름은 서로대체 문자를 참조합니다'
# 'universal character names are only valid in C99 or C++'
H6C064E2FEAA1: '유니버설 문자 이름은 C99 또는 C++에서만 유효합니다'
# "universal character names are only valid in C99 or C++; treating as '\\' followed by identifier"
H57AF83D90AE3: "유니버설 문자 이름은 C99 또는 C++에서만 유효합니다. '\\'를 역슬래시로 처리하고 그 뒤에 오는 식별자를 사용합니다"
# "unknown %0 warning specifier: '%1'"
HE021FCA9FD45: "알 수 없는 %0 경고 지정자: '%1'"
# 'unknown %select{type|class}1 name %0; did you mean %2?'
H3C8376ED6B78: '알 수 없는 %select{type|class}1 이름 %0; %2를 의미하는 게 아닐까요?'
# "unknown %select{warning|remark}0 option '%1'%select{|; did you mean '%3'?}2"
HE86784D7A808: "알 수 없는 %select{경고|참고}0 옵션 '%1'%select{|; '%3'을(를) 원하셨나요?}2"
# "unknown '-mindirect-jump=' option '%0'"
H632D52B85B4D: "알 수 없는 '-mindirect-jump=' 옵션 '%0'"
# "unknown FP unit '%0'"
HC0D93947CA5F: "알 수 없는 FP 유닛 '%0'"
# 'unknown HLSL semantic %0'
H173D19A6AD63: '알 수 없는 HLSL semantic %0'
# "unknown action '%1' for '#pragma %0' - ignored"
HD5134EB4614C: "알 수 없는 액션 '%1'을 '#pragma %0'에 대해 무시했습니다"
# "unknown action for '#pragma %0' - ignored"
HC6ADA3F7938E: "알 수 없는 '#pragma %0' 동작 - 무시됨"
# "unknown analyzer-config '%0'"
H50FE6AD53FF0: "알 수 없는 분석기 구성 '%0'"
# "unknown argument '%0'; did you mean '%1'?"
HBDB4C2710C85: "알 수 없는 인수 '%0'; '%1'을(를) 의미하시는 건가요?"
# "unknown argument ignored in clang-cl '%0'; did you mean '%1'?"
HFC74C4C6226A: "clang-cl에서 알 수 없는 인수 '%0'가 무시되었습니다. '%1'을(를) 의도하셨는지 확인해 주세요?"
# "unknown argument ignored in clang-cl: '%0'"
HC759BFBE35F6: "clang-cl에서 인식하지 못한 인수 '%0'이 무시되었습니다."
# "unknown argument: '%0'"
HA16D3B1BF1E9: "알 수 없는 인수: '%0'"
# "unknown assumption string '%0' may be misspelled; attribute is potentially ignored, did you mean '%1'?"
H50CF8A7A4EC4: "알 수 없는 가정 문자열 '%0'이 있을 수 있으며, 오타일 수 있습니다. 해당 특성은 무시될 수 있으며, '%1'을(를) 의도했는지 확인하세요?"
# "unknown assumption string '%0'; attribute is potentially ignored"
H585A62063A9D: "알 수 없는 가정 문자열 '%0'; 속성이 무시될 수 있습니다"
# 'unknown attribute %0 ignored'
H2C00F439265B: '알 수 없는 속성 %0 무시됨'
# "unknown attribute %0 ignored; did you mean '%1'?"
H582EB59A2C0E: "알 수 없는 특성 %0은(는) 무시됩니다. '%1'을(를) 의미하나요?"
# "unknown attribute '%0'"
HB9EC0CD4D3F9: "알 수 없는 속성 '%0'"
# "unknown attribute subject rule '%0'"
H3D3386816A55: "알 수 없는 속성 대상 규칙 '%0'"
# 'unknown cast annotation __bridge_retain; did you mean __bridge_retained?'
H99CA4EEB19EE: "알 수 없는 캐스트 애너테이션 '__bridge_retain'; '__bridge_retained'를 의미하셨는지요?"
# 'unknown command tag name'
H11BCD33A99AD: '알 수 없는 명령어 태그 이름'
# "unknown command tag name '%0'; did you mean '%1'?"
H7FD2FDFA8A87: "알 수 없는 명령 태그 이름 '%0'; 의도하신 게 '%1'이었나요?"
# 'unknown diagnostic option'
HB8C73037AA51: '알 수 없는 진단 옵션'
# 'unknown environment %0 in availability macro'
HAEC8AEED3CAD: '사용 가능 매크로에서 알 수 없는 환경 %0'
# "unknown escape sequence '\\%0'"
H4849F8435E28: "알 수 없는 이스케이프 시퀀스 '\\%0'"
# 'unknown kind of pragma comment'
HA06D4573713E: '알 수 없는 pragma 주석 유형'
# 'unknown linkage language'
H6501D0DE4EA8: '알 수 없는 linkage 언어'
# "unknown module '%0'"
H99985C296846: "알 수 없는 모듈 '%0'"
# "unknown or ill-formed Objective-C runtime '%0'"
HDD07911A4A21: "알 수 없는 또는 형식이 잘못된 Objective-C 런타임 '%0'"
# 'unknown platform %0 in availability macro'
HD5C8076C5089: '사용 가능성 매크로에서 %0 플랫폼이 알려지지 않았습니다.'
# 'unknown platform, assuming -mfloat-abi=%0'
HE055695902FF: '알 수 없는 플랫폼입니다. -mfloat-abi=%0 옵션을 가정합니다.'
# 'unknown pragma ignored'
H2A263E84EA76: '알 수 없는 pragma는 무시되었습니다.'
# 'unknown pragma in STDC namespace'
HB8BAEB9D2633: 'STDC 네임스페이스 내에서 알려지지 않은 pragma'
# 'unknown property attribute %0'
HA552B52A5631: '알 수 없는 속성 특성 %0'
# 'unknown receiver %0; did you mean %1?'
HF53B2435A683: '알 수 없는 수신자 %0; 의도하신 게 %1인가요?'
# "unknown register name '%0' in asm"
H0A30B49D2F93: "asm에서 알 수 없는 레지스터 이름 '%0'"
# "unknown remark serializer format: '%0'"
H4745BF37BA54: "알 수 없는 주석 직렬화 형식: '%0'"
# "unknown sanitizer '%0' ignored"
H7A7513A62BEF: "알 수 없는 산타이저 '%0' 무시됨"
# "unknown state '%0'"
HBCA6965044DA: "알 수 없는 상태 '%0'"
# 'unknown symbolic operand name in inline assembly string'
HA556FD6AA91E: '인라인 어셈블리 문자열에 알 수 없는 심볼릭 오퍼랜드 이름이 있습니다'
# "unknown target ABI '%0'"
HCA5838C6F428: "알 수 없는 타겟 ABI '%0'"
# "unknown target CPU '%0'"
H70DCB9C1156C: "알 수 없는 대상 CPU '%0'"
# "unknown target triple '%0'"
HF45924A5A477: "알 수 없는 타겟 트리플 '%0'"
# 'unknown template name %0'
HF6FA1BD9E3B7: '알 수 없는 템플릿 이름 %0'
# 'unknown type name %0'
HE3210F6A77D6: '알 수 없는 유형 이름 %0'
# 'unknown type name %0; did you mean %1?'
H2AA39E457B1F: '알 수 없는 형 이름 %0; %1을(를) 의미하시는 건가요?'
# 'unknown visibility %0'
HD580631FB230: '알 수 없는 가시성 %0'
# "unknown warning group '%0'"
H8B8A3DBA2D6F: "알 수 없는 경고 그룹 '%0'"
# "unknown warning group '%0', ignored"
H9E42BAF52A2D: "알려지지 않은 경고 그룹 '%0', 무시됨"
# "unknown%select{ | embed}0 preprocessor parameter '%1'"
HD697EE356FF3: "알 수 없는%select{ | embed}0 프리프로세서 매개변수 '%1'"
# 'unmatched type aware %0 declared here'
HD5E243D80237: '일치하지 않는 타입 인식 %0이(가) 여기서 선언되었습니다.'
# 'unnamed enumeration must be a definition'
H4B9605BBAC49: '이름이 지정되지 않은 열거형은 정의여야 합니다'
# 'unnamed type as template argument is incompatible with C++98'
HCF539CBCF367: '이름 없는 타입을 template 인수로 사용하는 것은 C++98와 호환되지 않습니다'
# 'unnamed type used in template argument was declared here'
H766AB8914B51: '이름이 지정되지 않은 타입이 템플릿 인자에 사용되었습니다. 여기서 선언되었습니다.'
# 'unnamed variable cannot be implicitly captured in a lambda expression'
HC2AE531DDA32: '이름이 지정되지 않은 변수는 lambda 표현식에서 암묵적으로 캡처될 수 없습니다.'
# 'unparsed tokens following type'
H64EC0A0DBA9B: '유형 뒤에 해석되지 않은 토큰이 있습니다.'
# 'unqualified base initializer of class templates is a Microsoft extension'
H18E0D4547A36: '클래스 템플릿의 비정규화된 기반 초기화자는 마이크로소프트 확장 기능입니다'
# "unqualified call to '%0'"
HA083B268F3B3: "정격화되지 않은 호출 '%0'"
# 'unqualified friend declaration referring to type outside of the nearest enclosing namespace is a Microsoft extension; add a nested name specifier'
H99771505062C: '비정규화된 friend 선언으로 가장 가까운 포함 네임스페이스 밖의 형식을 참조하는 것은 Microsoft 확장 기능입니다; 중첩된 이름 지정자를 추가하세요'
# 'unreachable declaration of template entity is here'
H8957FB46EC11: '템플릿 엔티티의 도달할 수 없는 선언이 여기에 있습니다'
# "unrecognized parameter passing direction, valid directions are '[in]', '[out]' and '[in,out]'"
H451D99C06285: "인식할 수 없는 매개변수 전달 방향입니다. 유효한 방향은 '[in]', '[out]' 및 '[in,out]'입니다."
# 'unrecognized platform name %0'
H3352495501E4: '인식되지 않은 플랫폼 이름 %0'
# 'unsequenced modification and access to %0'
HF69B798309CF: '비순서화된 수정과 %0에 대한 접근'
# 'unsupported %0 gpu architecture: %1'
HFE203A3E528C: '지원되지 않는 %0 GPU 아키텍처: %1'
# "unsupported '%0' value '%1'; use 'ios-macabi' instead"
H4B7365627CB3: "지원되지 않는 '%0' 값 '%1'; 'ios-macabi'를 대신 사용해야 합니다"
# 'unsupported CUDA gpu architecture: %0'
HBDA907ABC960: '지원되지 않는 CUDA GPU 아키텍처: %0'
# 'unsupported MC/DC boolean expression; contains an operation with a nested boolean expression. Expression will not be covered'
H0E188D9916C4: '지원되지 않는 MC/DC 불리언 표현; 중첩된 불리언 표현을 포함하는 연산이 있습니다. 이 표현은 커버되지 않을 것입니다'
# 'unsupported MC/DC boolean expression; number of conditions (%0) exceeds max (%1). Expression will not be covered'
H97B49477D381: '지원되지 않는 MC/DC 부울 표현식; 조건 수 (%0)가 최대치 (%1)를 초과했습니다. 표현식이 커버되지 않을 것입니다'
# 'unsupported MC/DC boolean expression; number of test vectors (%0) exceeds max (%1). Expression will not be covered'
HA1952652ED2D: '지원되지 않는 MC/DC 불리언 표현; 테스트 벡터의 수(%0)가 최대값(%1)을 초과했습니다. 표현식이 커버되지 않을 것입니다'
# 'unsupported OpenACC extension clause %0'
H6EE2042EA6AA: '지원되지 않는 OpenACC 확장 절 %0'
# 'unsupported OpenCL extension %0 - ignoring'
H90715CF4E48F: '지원되지 않는 OpenCL 확장 %0 - 무시'
# "unsupported architecture '%0' for MS-style inline assembly"
H4CDA8CDAE447: "MS-style 내인라인 어셈블리에 대한 지원되지 않는 아키텍처 '%0'"
# "unsupported architecture '%0' for host compilation"
HF6B9D10A3CB2: "호스트 컴파일에 대한 지원되지 않는 아키텍처 '%0'"
# "unsupported argument '%1' to option '%0'"
HF8679865943E: "옵션 '%0'에 대한 지원되지 않는 인수 '%1'"
# "unsupported argument '%1' to option '%0' for target '%2'"
H4C786BC0FD2F: "옵션 '%0'의 지원되지 않는 인자 '%1' 타겟 '%2'에서"
# "unsupported branch protection specification '%0'"
H2A7469D4D5C2: "지원되지 않는 분기 보호 지정 '%0'"
# 'unsupported combination: -header-include-format=%0 and -header-include-filtering=%1'
HDE5448E6CD09: '지원하지 않는 조합: -header-include-format=%0와 -header-include-filtering=%1'
# 'unsupported combination: CC_PRINT_HEADERS_FORMAT=%0 and CC_PRINT_HEADERS_FILTERING=%1'
H2798CD78D9FC: '지원되지 않는 조합: CC_PRINT_HEADERS_FORMAT=%0 및 CC_PRINT_HEADERS_FILTERING=%1'
# 'unsupported expression with unknown type'
H3F334416D50C: '알 수 없는 형식을 가진 지원되지 않는 표현식'
# 'unsupported inline asm: input with type %diff{$ matching output with type $|}0,1'
HA68AF7F61C41: '지원되지 않는 내부 어셈블리: %diff{$와 일치하는 $ 출력 유형|}0,1의 입력 유형'
# 'unsupported non-standard concatenation of string literals'
H5B7E63184569: '지원되지 않는 비표준 문자열 리터럴의 결합'
# "unsupported option '%0'"
H76DA0BF83FA2: "지원되지 않는 옵션 '%0'"
# "unsupported option '%0' for language mode '%1'"
HFB2A15C316AA: "언어 모드 '%1'에 대한 지원되지 않는 옵션 '%0'"
# "unsupported option '%0' for target '%1'"
H3BBDE17AAC2A: "옵션 '%0'은(는) '%1' 타겟에서 지원되지 않습니다."
# "unsupported option '%0'; did you mean '%1'?"
H4AD874895A11: "지원되지 않는 옵션 '%0'; 원하시는 것은 '%1'이었나요?"
# "unsupported runtime library '%0' for platform '%1'"
HE43F5A0809F2: "플랫폼 '%1'에서 '%0' 런타임 라이브러리가 지원되지 않습니다."
# 'unsupported signature for %q0'
H15BCEB35CA2A: '지원되지 않는 시그니처입니다: %q0'
# "unsupported standard library implementation: 'std::%0' is not a class template"
HA2971F6C2CFB: "지원되지 않는 표준 라이브러리 구현체: 'std::%0'는 클래스 템플릿이 아닙니다"
# 'unsupported type for named register variable'
H1A238AEF63D8: '지원되지 않는 형식의 이름이 지정된 레지스터 변수'
# "unsupported unwind library '%0' for platform '%1'"
H36E9F0E6CE47: "플랫폼 '%1'에 대한 지원되지 않는 unwind 라이브러리 '%0'"
# 'unsupported vector cast from %0 to %1 in a constant expression'
H0EB0D2450B52: '상수 표현식 내에서 %0에서 %1로의 벡터 형 변환이 지원되지 않음'
# 'unsupported: anonymous type given name for linkage purposes by %select{typedef|alias}0 declaration after its linkage was computed; add a tag name here to establish linkage prior to definition'
H912212F218D9: '지원되지 않음: 링크 계산 후 %select{typedef|alias}0 선언에 의해 링크 목적으로 이름이 지정된 익명 타입; 정의 전에 링크를 설정하려면 여기에 태그 이름을 추가하십시오'
# "unterminated '#pragma clang attribute push' at end of file"
HAA76B77750A8: "파일 끝에서 미완결된 '#pragma clang attribute push'"
# "unterminated '#pragma pack (push, ...)' at end of file"
H95BE59428151: "파일 끝에서 미완성된 '#pragma pack (push, ...)'가 있습니다"
# 'unterminated /* comment'
H43A167D7F07E: '미완성된 /* 주석'
# 'unterminated conditional directive'
H9448FAFF2F9A: '미완료 조건부 지시문'
# 'unterminated function-like macro invocation'
HD9DD62FCE328: '미완료된 함수 형식 매크로 호출'
# 'unterminated symbolic operand name in inline assembly string'
HBE23072A59B4: '인라인 어셈블리 문자열 내에서 종료되지 않은 기호 연산자 이름이 있습니다.'
# 'unused %select{function|variable}0 template %1'
H1A13AD1AD99E: '사용되지 않은 %select{함수|변수}0 템플릿 %1'
# 'unused %select{typedef|type alias}0 %1'
HF81285298D17: '사용되지 않은 %select{typedef|type alias}0 %1'
# "unused attribute %0 in '#pragma clang attribute push' region"
HE033EC53FB54: "사용되지 않은 속성 %0 '#pragma clang attribute push' 영역에서"
# 'unused exception parameter %0'
H53C55F431BFF: '사용되지 않는 예외 매개변수 %0'
# 'unused function %0'
H452452A2578C: '사용되지 않은 함수 %0'
# 'unused label %0'
H876AC9FC8066: '사용되지 않은 레이블 %0'
# 'unused member function %0'
HCD85BCD73655: '사용되지 않은 멤버 함수 %0'
# 'unused parameter %0'
HA3441FCB7F5E: '사용되지 않은 매개변수 %0'
# 'unused variable %0'
HC6697F7C70D3: '사용되지 않은 변수 %0'
# 'unwind clobber cannot be used with asm goto'
HF66EC6AC58F5: 'unwind clobber는 asm goto와 함께 사용할 수 없습니다.'
# 'update DWARF debug sections of the executable'
HED8DED50ECC0: '실행 파일의 DWARF 디버그 섹션을 업데이트합니다'
# 'update address2ProbesMap with output block address'
H5AFCEC7A601F: '출력 블록 주소를 사용하여 address2ProbesMap을 업데이트합니다'
# 'use %select{__bridge_retained|CFBridgingRetain call}1 to make an ARC object available as a +1 %0'
H2F547772958A: 'ARC 객체를 +1 %0로 사용할 수 있게 하려면 %select{__bridge_retained|CFBridgingRetain 호출}1을 사용하십시오.'
# 'use %select{__bridge_transfer|CFBridgingRelease call}1 to transfer ownership of a +1 %0 into ARC'
HF8A351DB4284: '%select{__bridge_transfer|CFBridgingRelease 호출}1을 사용하여 +1 %0의 소유권을 ARC에 전달하세요.'
# 'use %select{an alias declaration|a typedef declaration|a reference|a const variable|a constexpr variable}0 instead'
H31FA52067035: '대신에 %select{alias 선언|typedef 선언|참조|const 변수|constexpr 변수}0를 사용하세요'
# "use '!=' to turn this compound assignment into an inequality comparison"
HFF11B4D027A3: "복합 할당을 부등호 비교로 바꾸려면 '!='를 사용하세요"
# "use '%0' for a bitwise operation"
HC5B930A30B61: "비트 연산에 '%0'을 사용하십시오"
# "use '%0' instead"
H3E25F181DE0F: "대신 '%0'을 사용하세요"
# "use '%0'%select{| or '%3'|, '%3', or '%4'|, '%3', '%4', or '%5'}2 for '%1' standard"
H8EF0F3BAA8D4: "'%1' 표준에 대해 '%0'%select{| 또는 '%3'|, '%3', 또는 '%4'|, '%3', '%4', 또는 '%5'}2를 사용하세요"
# "use '--' to treat subsequent arguments as filenames"
H6A626367FC6F: "후속 인수를 파일명으로 처리하려면 '--'를 사용하십시오"
# "use '=' to turn this equality comparison into an assignment"
H59DEE49ECF0A: "이 등식 비교를 할당으로 바꾸려면 '='를 사용하십시오"
# "use '==' to turn this assignment into an equality comparison"
H00083B312DD9: "이 할당을 등식 비교로 바꾸려면 '=='을 사용하세요"
# "use 'framework module' to declare module '%0'"
H4A41FDAB21BC: "'framework module'을 사용하여 모듈 '%0'을 선언하세요."
# "use 'isEqual:' instead"
H4DB59E9DD438: "대신 'isEqual:'를 사용하세요"
# "use 'static' to give inline function %0 internal linkage"
HFF537B0E0104: "인라인 함수 %0에 내부 링크지를 지정하려면 'static'을 사용하세요"
# "use 'static_cast' to adjust the pointer correctly while %select{upcasting|downcasting}0"
H11DA11C5BD86: "정확한 포인터를 조정하려면 %select{상위 형변환|하위 형변환}0 시 'static_cast'를 사용하세요."
# "use 'template' keyword to treat '%0' as a dependent template name"
H7991087B2538: "‘template’ 키워드를 사용하여 '%0'을 의존적 템플릿 이름으로 처리하려면"
# "use 'thread_local' to allow this"
H797BF646E244: '‘thread_local’을 사용하여 이것을 허용하십시오'
# "use '|=' to turn this inequality comparison into an or-assignment"
H080693EB5666: "부등호 비교를 or 할당문으로 바꾸려면 '|='를 사용하십시오."
# 'use -analyzer-disable-all-checks to disable all static analyzer checkers'
H352E7076CB09: '정적 분석 검사기를 모두 비활성화하려면 -analyzer-disable-all-checks 옵션을 사용하세요'
# 'use -fbracket-depth=N to increase maximum nesting level'
H336E5F530373: '옵션 -fbracket-depth=N을 사용하여 최대 중첩 수준을 증가시켜 주십시오'
# "use -foperator-arrow-depth=N to increase 'operator->' limit"
HF5AE9E6C2AED: 'operator-> 제한을 증가시키려면 -foperator-arrow-depth=N 옵션을 사용하세요'
# 'use -ftemplate-depth=N to increase recursive template instantiation depth'
HB6D1F29D249C: '재귀 템플릿 인스턴스화 깊이를 늘리려면 -ftemplate-depth=N 옵션을 사용하세요.'
# 'use /Tc or /Tp to set input type for standard input'
HA357D9386AFC: '표준 입력의 입력 유형을 설정하려면 /Tc 또는 /Tp를 사용하세요'
# 'use DBSCAN/OPTICS algorithm'
HD85FBF4157B0: 'DBSCAN/OPTICS 알고리즘을 사용하십시오'
# 'use DFS order for YAML profile'
H3B1260947C69: 'YAML 프로파일에 DFS 순서를 사용'
# 'use DFS ordering when using -icf option'
HBAAC1CA2D23D: 'icf 옵션을 사용할 때 DFS 순서를 사용합니다'
# 'use GNU_STACK program header for new segment (workaround for issues with strip/objcopy)'
H43641118D1BF: 'GNU_STACK 프로그램 헤더를 새 세그먼트에 사용 (strip/objcopy와의 문제 해결을 위한 대처법)'
# 'use Machine Branch Probability Info'
H2ADCBE6C2DCD: '머신 분기 확률 정보 사용'
# 'use Pettis-Hansen algorithm'
H5F85980D861E: '펫티스-헨센 알고리즘 사용'
# 'use __attribute__((visibility("hidden"))) attribute instead'
H69E62EF34DBF: '대신에 __attribute__((visibility("hidden"))) 속성을 사용하십시오'
# 'use __bridge to convert directly (no change in ownership)'
HF999F719DC1E: '__bridge를 사용하여 직접 변환하십시오（소유권 변경 없음）'
# 'use __bridge with C-style cast to convert directly (no change in ownership)'
H25381B224554: 'C 스타일 캐스트와 함께 __bridge를 사용하여 직접 변환하십시오 (소유권 변경 없음)'
# 'use __bridge_retained with C-style cast to make an ARC object available as a +1 %0'
H89038B186CBF: '__bridge_retained와 C 스타일 캐스트를 함께 사용하여 ARC 객체를 +1 %0로 사용 가능하게 하려면 __bridge_retained를 사용하십시오'
# 'use __bridge_transfer with C-style cast to transfer ownership of a +1 %0 into ARC'
H0BF38DCCAF48: 'C 스타일 캐스트와 __bridge_transfer를 사용하여 +1 %0의 소유권을 ARC로 이전하려면'
# "use a custom address at which new code will be put, bypassing BOLT's logic to detect where to put code"
H8BE27E21C6B2: '새 코드를 배치할 사용자 정의 주소를 사용하여 BOLT의 코드 배치 위치 탐지 로직을 우회합니다.'
# "use a function's hot size when doing clustering"
H10032CBF870F: '클러스터링을 수행할 때 함수의 핫 사이즈를 사용합니다'
# 'use a lock file so only one process in the system can run this pass at once. useful to avoid mangled debug output in multithreaded environments.'
H7CB74F0F7BF5: '락 파일을 사용하면 시스템에서 이 패스를 동시에 실행할 수 있는 프로세스가 하나만 됩니다. 멀티스레드 환경에서 엉킨 디버그 출력을 피하는 데 유용합니다.'
# 'use a modified clustering algorithm geared towards minimizing branches'
HFDD79DC87D1A: '가지 분기를 최소화하도록 맞춘 수정된 클러스터링 알고리즘을 사용하십시오.'
# 'use absolute jump tables on ppc'
H88706E2F52B2: 'ppc에서 절대 점프 테이블 사용'
# 'use aggressive ppc isel for bit permutations'
H99649C2F1B01: '비트 순열을 위한 공격적인 ppc isel 사용'
# 'use array indexing to silence this warning'
H85B32746AF01: '배열 인덱싱을 사용하여 이 경고를 없애세요'
# 'use ascending or descending order when printing functions ordered by dyno stats'
HF0A78325BB17: 'dyno stats로 정렬된 함수를 출력할 때 오름차순 또는 내림차순을 사용하세요.'
# 'use branch prediction data to control sctc'
H2D5E124AB149: '가지 예측 데이터를 사용하여 sctc를 제어합니다'
# 'use cache-directed sort'
H993E2A52F48B: '캐시 지향 정렬을 사용하십시오.'
# 'use constraint modifier "%0"'
H96B4F36A2D84: '제약 수정자 "%0"를 사용하라'
# 'use declarations are only allowed in top-level modules'
HB528050B8967: 'use 선언은 최상위 모듈에서만 허용됩니다'
# 'use edge count data when doing clustering'
H6F3C614822A7: '클러스터링을 할 때 에지 카운트 데이터를 사용합니다'
# 'use fast runtime behavior'
H2D5F50DA24D3: '빠른 런타임 동작 사용'
# "use function '%0' instead"
H30EA9A5A15F6: '‘%0’ 함수를 대신 사용하세요'
# 'use function order specified by -function-order'
H517260D51513: '지정된 -function-order 옵션의 함수 순서를 사용하십시오.'
# 'use hfsort algorithm'
H6D5DE1F47100: 'hfsort 알고리즘을 사용하십시오'
# 'use hot/cold data on basic blocks to determine hot sizes for call graph functions'
H898A061653FE: '기본 블록에 있는 hot/cold 데이터를 사용하여 호출 그래프 함수의 hot 크기를 결정합니다'
# 'use instrumentation with slow path for all accesses'
H244914CD834D: '모든 접근에 대해 느린 경로를 사용하는 인스트루먼테이션을 사용하라'
# 'use misprediction frequency for determining whether or not ICP should be applied at a callsite.  The -indirect-call-promotion-mispredict-threshold value will be used by this heuristic'
H3115132EB120: '불일치 예측 빈도를 사용하여 callsite에서 ICP를 적용할지 여부를 결정합니다. 이 휴리스틱은 -indirect-call-promotion-mispredict-threshold 값을 사용합니다'
# 'use non-reference type %0'
HE4A5CE8520B2: '비참조 형식 %0를 사용하십시오'
# 'use non-reference type %0 to make construction explicit or type %1 to prevent copying'
HAB8A2938766C: '비참조 형식 %0을 사용하여 생성을 명시적으로 하거나 형식 %1을 사용하여 복사를 방지하십시오'
# 'use nullability type specifier %0 to affect the innermost pointer type of %1'
HA9A4302606C7: '%0 nullability 형식 지정자를 사용하여 %1의 가장 안쪽 포인터 유형에 영향을 미치십시오'
# 'use of %0 with tag type that does not match previous declaration'
H4AAB2FCDDAB1: '이전 선언과 일치하지 않는 태그 타입을 가진 %0를 사용했습니다.'
# 'use of %select{class template|function template|variable template|alias template|template template parameter|concept|template}0 %1 requires template arguments'
H8F99144D2E34: '템플릿 %select{클래스 템플릿|함수 템플릿|변수 템플릿|템플릿 별칭|템플릿 템플릿 매개변수|컨셉|템플릿}0 %1을 사용하려면 템플릿 인수가 필요합니다'
# 'use of %select{infinity|NaN}0%select{| via a macro}1 is undefined behavior due to the currently enabled floating-point options'
H18AE2A8F681F: '현재 활성화된 부동소수점 옵션으로 인해 %select{무한대|NaN}0%select{| 매크로를 통해}1 사용은 정의되지 않은 동작입니다'
# 'use of %select{type|declaration}0 %1 requires %2 support'
H39DB55887936: '%select{유형|선언}0 %1를 사용하려면 %2 지원이 필요합니다'
# "use of '@import' in framework header is discouraged, including this header requires -fmodules"
H455C5312D820: "프레임워크 헤더에서 '@import'를 사용하는 것은 권장되지 않습니다. 이 헤더를 포함하려면 -fmodules 옵션이 필요합니다."
# "use of '@import' when modules are disabled"
HE80AA99C30B1: "모듈이 비활성화되었을 때 '@import'를 사용했습니다"
# "use of '__int128' with '__vector bool' requires VSX support enabled (on POWER10 or later)"
HBB36DE187BFD: "'__int128'을 '__vector bool'과 함께 사용하려면 VSX 지원이 활성화되어야 합니다 (POWER10 또는 그 이후 버전에서)"
# "use of '__int128' with '__vector' requires extended Altivec support (available on POWER8 or later)"
H02493A6B8143: '__int128과 __vector를 함께 사용하려면 POWER8 또는 그 이상 버전에서 사용 가능한 확장된 Altivec 지원이 필요합니다'
# "use of '__super' inside a lambda is unsupported"
H5812045C24A5: "람다 내부에서 '__super'를 사용하는 것은 지원되지 않습니다"
# "use of 'double' with '__vector' requires VSX support to be enabled (available on POWER7 or later)"
HFF794EBE240D: '‘double’과 ‘__vector’를 함께 사용하려면 VSX 지원을 활성화해야 합니다 (POWER7 이상에서 사용 가능)'
# "use of 'long long' with '__vector' requires VSX support (available on POWER7 or later) to be enabled"
HEDE074D6F05D: "'__vector'와 함께 'long long'을 사용하려면 POWER7 또는 그 이상의 프로세서에서 사용 가능한 VSX 지원을 활성화해야 합니다"
# "use of 'long' with '__vector' is deprecated"
H194F4A31DAD4: '‘long’을 ‘__vector’와 함께 사용하는 것은 권장되지 않습니다.'
# "use of 'operator->' on type %0 would invoke a sequence of more than %1 'operator->' calls"
HE55B12BF8DE6: "타입 %0에 'operator->'를 사용하면 %1개 이상의 연속된 'operator->' 호출이 발생합니다"
# "use of 'static_assert' without inclusion of <assert.h> is a Microsoft extension"
HFC681B3993FC: '‘static_assert’를 사용하면서 <assert.h>를 포함하지 않은 것은 마이크로소프트 확장 기능입니다.'
# "use of 'template' keyword outside of a template is incompatible with C++98"
HADE615C257C6: "템플릿 키워드 'template'을 템플릿 밖에서 사용하면 C++98과 호환되지 않습니다"
# 'use of @defs is not supported on this architecture and platform'
HA2315B23A421: '이 아키텍처 및 플랫폼에서는 @defs를 사용할 수 없습니다'
# 'use of C-style parameters in Objective-C method declarations is deprecated'
H124575A24936: 'Objective-C 메서드 선언문에서 C-style 매개변수를 사용하는 것은 더 이상 권장되지 않습니다'
# "use of GNU 'missing =' extension in designator"
HE3037B23921A: "디자이너에서 GNU '('= 누락 확장 기능을 사용했습니다."
# 'use of GNU ?: conditional expression extension, omitting middle operand'
H0DE762B90B0D: 'GNU ?: 조건식 확장 사용, 중간 피연산자 생략'
# 'use of GNU address-of-label extension'
HA7B26095AD53: 'GNU 주소-라벨 확장 기능 사용'
# 'use of GNU array range extension'
H678FC3DF1C6F: 'GNU 배열 범위 확장 기능을 사용했습니다.'
# 'use of GNU indirect-goto extension'
H3D429B23EFAC: 'GNU 간접 goto 확장 기능 사용'
# 'use of GNU old-style field designator extension'
H85575BE49C11: 'GNU 구식 필드 지정자 확장 기능을 사용했습니다.'
# 'use of GNU statement expression extension'
HD7924EDC2399: 'GNU 문장 표현 확장 기능을 사용했습니다'
# 'use of GNU statement expression extension from macro expansion'
HDFF296407839: '매크로 확장에서 GNU 문 표현 확장 사용'
# 'use of NULL in arithmetic operation'
H72A441293B63: '산술 연산에서 NULL 사용'
# 'use of Objective-C property in function nested in Objective-C container not supported, move function outside its container'
H1B2603FEAF82: 'Objective-C 컨테이너 내에 중첩된 함수에서 Objective-C 속성을 사용하는 것은 지원되지 않습니다. 함수를 컨테이너 밖으로 이동하십시오.'
# 'use of __private_extern__ on a declaration may not produce external symbol private to the linkage unit and is deprecated'
HC7A56E0EB4D2: '선언에 __private_extern__을 사용하면 링크 단위 내부에 private인 외부 심볼을 생성하지 않을 수 있으며, 이 기능은recated 됐습니다.'
# "use of a '#%select{<BUG IF SEEN>|elifdef|elifndef}0' directive is a C++23 extension"
H6A5DD5BE1302: '’#%select{<BUG IF SEEN>|elifdef|elifndef}0’ 지시어를 사용하는 것은 C++23 확장 기능입니다'
# "use of a '#%select{<BUG IF SEEN>|elifdef|elifndef}0' directive is a C23 extension"
H0BF82439932C: '‘#%%select{<BUG IF SEEN>|elifdef|elifndef}0’ 지시문의 사용은 C23 확장 기능입니다'
# "use of a '#%select{<BUG IF SEEN>|elifdef|elifndef}0' directive is incompatible with C standards before C23"
HDFCC088F181F: "C23 이전의 C 표준과 호환되지 않는 '#%select{<BUG IF SEEN>|elifdef|elifndef}0' 지시문을 사용했습니다"
# "use of a '#%select{<BUG IF SEEN>|elifdef|elifndef}0' directive is incompatible with C++ standards before C++23"
H16A663A66375: "'#%select{<BUG IF SEEN>|elifdef|elifndef}0' 지시문을 사용하는 것은 C++23 이전 표준과 호환되지 않습니다"
# 'use of address-of-label extension outside of a function body'
HEBDAFDF05EDA: '함수 본문 밖에서 라벨 주소 연산 확장 기능을 사용했습니다'
# 'use of an empty initializer is a C23 extension'
HD0F8B4BA3FB2: '비어 있는 초기화자를 사용하는 것은 C23 확장입니다'
# 'use of an empty initializer is incompatible with C standards before C23'
H28862631C8FD: '빈 초기화자를 사용하면 C23 이전의 C 표준과 호환되지 않습니다'
# "use of bitwise '%0' with boolean operands"
H3DCD98477290: "비트 연산자 '%0'을 불리언 피연산자와 함께 사용했습니다."
# 'use of default argument to function %0 that is declared later in class %1'
HBEFC6E561806: '클래스 %1에서 나중에 선언된 %0 함수에 기본 인수가 사용되었습니다'
# 'use of dynamic_cast requires -frtti'
HE86B35BE234A: 'dynamic_cast를 사용하려면 -frtti 옵션이 필요합니다.'
# 'use of empty enum'
H0A3EEAE0C204: '비어 있는 enum 사용'
# 'use of enumeration in a nested name specifier is a C++11 extension'
H9F1C227C8017: '중첩된 이름 지정자에서 열거형을 사용하는 것은 C++11 확장 기능입니다'
# 'use of function %0 is discouraged; there is no way to check for failure but failure may still occur, resulting in a possibly exploitable security vulnerability'
H123B46BAB412: '함수 %0의 사용은 권장되지 않습니다; 실패 여부를 확인할 수 없지만 실패가 여전히 발생할 수 있어 결과적으로 악용 가능한 보안 취약점이 될 수 있습니다'
# 'use of function template name with no prior declaration in function call with explicit template arguments is a C++20 extension'
H17E19DFB3C7C: '이전 선언이 없는 함수 템플릿 이름을 명시적 템플릿 인수를 가진 함수 호출에서 사용하는 것은 C++20 확장 기능입니다'
# 'use of function template name with no prior declaration in function call with explicit template arguments is incompatible with C++ standards before C++20'
H640DD80A631A: '명시적인 템플릿 인수를 사용하는 함수 호출에서 이전 선언이 없는 함수 템플릿 이름을 사용하는 것은 C++20 이전의 C++ 표준과 호환되지 않습니다.'
# "use of incomplete type %0 in a '_Generic' association is incompatible with C standards before C2y"
H805F57844181: "미완성 형식 %0를 '_Generic' 연관에서 사용하는 것은 C2y 이전의 C 표준과 호환되지 않습니다"
# "use of logical '%0' with constant operand"
H91174008E58D: "상수 피연산자와 함께 논리 연산자 '%0' 사용"
# 'use of member %0 before its declaration is a Microsoft extension'
HF1849841B9E7: '선언 전에 멤버 %0을 사용하는 것은 Microsoft 확장 기능입니다'
# 'use of member %0 found via unqualified lookup into dependent bases of class templates is a Microsoft extension'
H8CD447C8CC3A: '%0 멤버의 사용은 클래스 템플릿의 의존적 기반에 대한 비정규 탐색을 통해 발견되었으며, 이는 Microsoft 확장 기능입니다'
# 'use of multiple declarators in a single using declaration is a C++17 extension'
H82698382734A: '단일 using 선언에서 여러 선언자를 사용하는 것은 C++17 확장 기능입니다'
# 'use of multiple declarators in a single using declaration is incompatible with C++ standards before C++17'
HF5A1B33A1986: '단일 using 선언문에서 여러 declarators 사용은 C++17 이전의 C++ 표준과 호환되지 않습니다'
# "use of non-standard escape character '\\%0'"
H8F21313E1DFF: "비표준 이스케이프 문자 '\\%0'를 사용했습니다"
# 'use of non-static data member %0 in an unevaluated context is incompatible with C++98'
H47868E15CED8: '정적 멤버가 아닌 데이터 멤버 %0을(를) 평가되지 않은 맥락에서 사용하면 C++98과 호환되지 않습니다'
# 'use of null pointer as non-type template argument is incompatible with C++98'
H6944D3B803C2: 'NULL 포인터를 형식이 아닌 템플릿 인자로 사용하는 것은 C++98과 호환되지 않습니다'
# 'use of old-style cast'
H0C8605CE0E58: '구식 캐스트 사용'
# 'use of out-of-scope declaration of %0%select{| whose type is not compatible with that of an implicit declaration}1'
H9DFA1FDF94B0: '범위 밖의 선언 %0%select{ |의 유형은 암시적 선언의 유형과 호환되지 않습니다}1를 사용했습니다'
# "use of overloaded operator '%0' is ambiguous (operand type %1)"
H4300BB2DDBA6: "오버로드된 연산자 '%0'의 사용이 모호합니다 (피연산자 타입 %1)"
# "use of overloaded operator '%0' is ambiguous (with operand types %1 and %2)"
H792DBC228D1F: "오버로드된 연산자 '%0'의 사용이 모호합니다 (피연산자 타입 %1과 %2)"
# 'use of placement new requires explicit declaration'
H992499F64501: 'placement new를 사용하려면 명시적인 선언이 필요합니다'
# "use of private header from outside its module: '%0'"
H4B3CFE33871D: "모듈 외부에서 해당 모듈의 비공개 헤더를 사용했습니다: '%0'"
# 'use of reference outside its lifetime is not allowed in a constant expression'
H2C7D8C6358B3: '참조의 생명 주기가 끝난 후에 참조를 사용하는 것은 상수 표현식에서 허용되지 않습니다'
# 'use of result of assignment to object of volatile-qualified type %0 is deprecated'
H0FD6FA3111E8: 'volatile 자격을 가진 %0 타입의 객체에 대한 할당 결과를 사용하는 것은 사용 중지됨'
# "use of right-shift operator ('>>') in template argument will require parentheses in C++11"
H4B1C2F8BF668: "템플릿 인자에서 우측 시프트 연산자('>>')를 사용하면 C++11에서 괄호가 필요합니다"
# 'use of the %0 attribute is a C++14 extension'
HD7333826DEB8: '특성 %0의 사용은 C++14 확장 기능입니다'
# 'use of the %0 attribute is a C++17 extension'
H9D6E9F75124A: '%0 속성의 사용은 C++17 확장 기능입니다'
# 'use of the %0 attribute is a C++20 extension'
H85EE1317CADA: '특성 %0을 사용하는 것은 C++20 확장 기능입니다'
# 'use of the %0 attribute is a C++23 extension'
H3769FB94DD63: '특정 %0 어트리뷰트의 사용은 C++23 확장 기능입니다'
# 'use of this expression in an %0 attribute requires parentheses'
H4B6BF2EAA0DF: '이 표현을 %0 속성에서 사용하려면 괄호가 필요합니다'
# 'use of this statement in a constexpr %select{function|constructor}0 is a C++14 extension'
H009816A3B264: '이 문장을 constexpr %select{function|constructor}0에서 사용하는 것은 C++14 확장 기능입니다'
# 'use of this statement in a constexpr %select{function|constructor}0 is a C++20 extension'
H383EABB05A34: '이 constexpr %select{함수|생성자}0에서 이 문장을 사용하는 것은 C++20 확장 기능입니다'
# 'use of this statement in a constexpr %select{function|constructor}0 is a C++23 extension'
H3CD433F9DEED: 'constexpr %select{function|constructor}0 내에서 이 문장을 사용하는 것은 C++23 확장 기능입니다'
# 'use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14'
HDB9F101C6FD8: 'C++14 이전의 C++ 표준과 호환되지 않기 때문에 constexpr %select{함수|생성자}0 내에서 이 문장을 사용할 수 없습니다'
# 'use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++20'
H10E657C568DA: 'constexpr %select{함수|생성자}0 내에서 이 문장을 사용하는 것은 C++20 이전 표준과 호환되지 않습니다'
# 'use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++23'
HBB6862211968: 'constexpr %select{함수|생성자}0에서 이 문장을 사용하는 것은 C++23 이전 표준과 호환되지 않습니다'
# 'use of typeid requires -frtti'
H6516CAF74372: 'typeid를 사용하려면 -frtti 옵션이 필요합니다'
# 'use of unary operator that may be intended as compound assignment (%0=)'
H52686183E946: '단항 연산자의 사용이 복합 할당(%0=) 의도일 수 있습니다.'
# 'use of undeclared %0'
H4249B6D3D66A: '미선언된 %0을 사용했습니다'
# 'use of undeclared %0; did you mean %1?'
H152AECD0CF73: '미 선언된 %0를 사용했습니다; %1 의 뜻이었나요?'
# 'use of undeclared identifier %0'
H2DA2A4EF5956: '선언되지 않은 식별자 "%0"를 사용했습니다.'
# 'use of undeclared identifier %0; did you mean %1?'
H448AE4CE2F58: '미처 선언되지 않은 식별자 %0 사용; %1을(를) 의미하시는 게 아닌가요?'
# 'use of undeclared identifier %0; unqualified lookup into dependent bases of class template %1 is a Microsoft extension'
HB6A34859F540: '선언되지 않은 식별자 %0 사용; 클래스 템플릿 %1의 의존적 기반 클래스에 대한 무 자격 검색은 마이크로소프트 확장입니다'
# 'use of undeclared label %0'
H685C1928674B: '미선언된 레이블 %0 사용'
# "use of undefined marker '%0'"
HAEC3C6045C74: "정의되지 않은 마커 '%0'을 사용했습니다."
# 'use of unknown builtin %0'
HBFCE16721923: '알 수 없는 내장 함수 사용 %0'
# 'use old code sequence for promoted calls'
H27311E45E8D5: '프로모션된 호출을 위해 이전 코드 시퀀스를 사용합니다'
# 'use perf data directly when constructing the call graph for stale functions'
H9C843E88A00A: '과시된 함수의 호출 그래프를 작성할 때 perf 데이터를 직접 사용하라'
# 'use precise runtime behavior'
H864CB2EB7B9A: '정확한 런타임 동작을 사용하십시오.'
# 'use reference type %0 to prevent copying'
H96F12D2BC3F2: '참조 타입 %0를 사용하여 복사를 방지하십시오'
# 'use register liveness analysis to try to find more opportunities for -reg-reassign optimization'
H7BCD305B01BE: '레지스터 활성 분석을 사용하여 -reg-reassign 최적화를 위한 더 많은 기회를 찾습니다.'
# 'use regular size pages for code alignment'
H041AAF5448A5: '코드 정렬을 위해 일반 크기의 페이지를 사용합니다'
# 'use relaxed runtime behavior'
H386C9EF15D8D: '이완된 런타임 동작을 사용합니다'
# 'use relocations in the binary (default=autodetect)'
HA2145EBF1AF4: '바이너리에 재정렬을 사용 (기본값=자동 감지)'
# 'use same count for BBs that should have equivalent count (used in non-LBR and shrink wrapping)'
H2FCA1FC45D12: '동일한 카운트를 가질 필요가 있는 BB들에는 동일한 카운트를 사용해야 합니다 (non-LBR 및 shrink wrapping에서 사용됨)'
# "use same version number separators '_' or '.'; as in 'major[.minor[.subminor]]'"
H152CFF6748B3: "버전 번호 구분자로 '_' 또는 '.'를 일관되게 사용하십시오; 예: 'major[.minor[.subminor]]' 형식"
# 'use short granules in allocas and outlined checks'
H1D7871DD27F1: 'allocas와 분리된 검사에서 짧은 그레인을 사용하라'
# 'use strict dwarf'
HD69F3507E82F: '엄격한 dwarf 사용'
# 'use stricter verifier for FIR operations with volatile types'
H2542C8B1617A: '휘발성 형식의 FIR 작업에 대해 더 엄격한 검증기 사용'
# 'use stricter verifier for HLFIR intrinsic operations'
H7296989D6AE9: 'HLFIR 내장 연산에 대해 엄격한 검증기를 사용하십시오'
# "use the GNU '__attribute__' syntax"
H7DBF5BB23C34: "GNU '__attribute__' 구문을 사용하세요"
# 'used here'
H1359FF249380: '여기서 사용됨'
# 'used in initialization here'
H9614905D4DE2: '여기에서 초기화에 사용됨'
# 'used type %0 where __hlsl_resource_t is required'
HB0299AD4C891: '사용된 타입 %0는 __hlsl_resource_t가 필요한 위치에서 사용되었습니다'
# 'used type %0 where arithmetic or pointer type is required'
HEF054774D419: '산술 형식 또는 포인터 형식이 필요한 위치에서 %0 형식이 사용되었습니다'
# 'used type %0 where floating point type is not allowed'
HF095E0FB08EE: '부동 소수점 타입이 허용되지 않는 위치에서 %0 타입을 사용했습니다'
# 'used type %0 where integer is required'
HCD053F3A5F86: '정수형이 필요함에도 불구하고 %0 형을 사용했습니다'
# 'used type %0 where integer or floating point type is required'
H46DF1623ED73: '정수형 또는 부동소수점 형식이 필요한 위치에 %0 형식을 사용했습니다'
# 'used%select{| in pointer arithmetic| in buffer access}0 here'
H2D0FA9F859F9: '여기서 %select{| 포인터 산술| 버퍼 접근}0에서 사용되었습니다'
# "user-defined literal suffixes %select{<ERROR>|not starting with '_'|containing '__'}0 are reserved%select{; no literal will invoke this operator|}1"
H414028466FC2: "사용자 정의 리터럴 접미사 %select{<오류>|밑줄('_')로 시작하지 않는|밑줄 두 개 '__'를 포함하는}0는 예약되어 있습니다%select{; 이 연산자는 호출되지 않습니다|}1"
# 'using'
H92BD75EBD8FD: 'using'
# 'using %0 directive in %select{NSString|CFString}1 which is being passed as a formatting argument to the formatting %select{method|CFfunction}2'
HFA21A8452E12: '%select{NSString|CFString}1 내에서 %0 지시어가 포맷팅 %select{method|CFfunction}2에 전달되는 포맷팅 인수로 사용되었습니다'
# 'using %0 with a literal is redundant'
HA26F40AA0176: '%0를 리터럴과 함께 사용하는 것은 중복입니다'
# 'using %select{integer|floating point|complex}1 absolute value function %0 when argument is of %select{integer|floating point|complex}2 type'
H2A1C61EF88A1: '인수가 %select{integer|floating point|complex}2 형식인 경우 %0 %select{integer|floating point|complex}1 절댓값 함수를 사용 중입니다'
# "using '%%P' format specifier with an Objective-C pointer results in dumping runtime object structure, not object value"
H513C1ECC12E7: "'%%P' 포맷 지정자를 Objective-C 포인터와 함께 사용하면 오브젝트 값 대신 런타임 오브젝트 구조를 출력합니다"
# "using '%%P' format specifier without precision"
HE89A56274479: "정밀도 없이 '%P' 포맷 지정자 사용"
# "using '%0' format specifier annotation outside of os_log()/os_trace()"
H2CE6DDE79E74: "os_log()/os_trace() 함수 외부에서 '%0' 형식 지정자 어노테이션을 사용함"
# "using '%0' format specifier, but argument has boolean value"
HDDBB822724E7: "'%0' 포맷 지정자를 사용 중이지만, 인수에는 불리언 값이 있습니다"
# "using declaration annotated with 'using_if_exists' here"
HDB8ACBC0FBF5: "여기에서 'using_if_exists'로 주석으로 표시된 using declaration 사용 선언"
# 'using declaration cannot refer to a constructor'
HF62840A086D5: 'using 선언문은 생성자를 참조할 수 없습니다'
# 'using declaration cannot refer to a destructor'
HE836ECBAB540: 'using 선언문은 소멸자를 참조할 수 없습니다'
# 'using declaration cannot refer to a namespace'
H0DDDFEE0D0FD: 'using 선언문은 네임스페이스를 가리킬 수 없습니다'
# 'using declaration cannot refer to a template specialization'
H99346E56FD07: 'using 선언문은 템플릿 전문화를 참조할 수 없습니다'
# 'using declaration cannot refer to class member'
H667DB55E8D61: 'using 선언문은 클래스 멤버를 참조할 수 없습니다'
# 'using declaration in class refers into %0, which is not a class'
H703FE2D02B05: '클래스 내 사용 선언이 %0를 가리키지만 이는 클래스가 아닙니다'
# 'using declaration naming a scoped enumerator is a C++20 extension'
H5CF0B64CDA35: 'using declaration이 스코프 열거자를 지정하는 것은 C++20 확장 기능입니다'
# 'using declaration naming a scoped enumerator is incompatible with C++ standards before C++20'
H52802307DDAC: 'using declaration이 scoped enumerator를 지정하는 것은 C++20 이전의 C++ 표준과 호환되지 않습니다'
# 'using declaration pack expansion at block scope produces multiple values'
HFC5BC61E58BC: '블록 스코프에서 using 선언 팩 패션을 사용하면 여러 개의 값이 생성됩니다'
# 'using declaration referring to %1 with %select{internal|module|unknown}0 linkage cannot be exported'
HFDD1D0A3610E: '%1을 참조하는 using 선언문은 %select{내부|모듈|알 수 없는}0 연결로 출려할 수 없습니다'
# "using declaration referring to inaccessible member '%0' (which refers to accessible member '%1') is a Microsoft compatibility extension"
HA7AB89787DCC: "접근할 수 없는 멤버 '%0'을 참조하는 using declaration (이는 접근 가능한 멤버 '%1'을 가리킵니다)는 Microsoft 호환성 확장 기능입니다"
# 'using declaration refers into %0, which is not a base class of %1'
HE8EC9FE5FD16: 'using 선언이 %0을 참조하지만, 이는 %1의 기반 클래스가 아닙니다'
# 'using declaration refers to its own class'
H435B6D84F0D6: 'using 선언문이 자신의 클래스를 참조합니다'
# 'using declaration requires a qualified name'
H9CE75E7C4CF5: 'using 선언은 자격 증명된 이름이 필요합니다'
# "using directive refers to implicitly-defined namespace 'std'"
H5C8831D062A8: "using 지시문은 암시적으로 정의된 네임스페이스 'std'를 참조합니다."
# 'using enum %select{requires an enum or typedef name|does not permit an elaborated enum specifier}0'
H07DCC7345590: 'using enum %select{는 enum 또는 typedef 이름이 필요합니다|확장된 enum 지정자를 허용하지 않습니다}0'
# 'using enum declaration is a C++20 extension'
H30E94CBBC49F: 'using enum 선언은 C++20 확장 기능입니다'
# 'using enum declaration is incompatible with C++ standards before C++20'
HA6B3DF063338: 'using enum 선언은 C++20 이전의 C++ 표준과 호환되지 않습니다'
# "using length modifier '%0' with conversion specifier '%1' is not supported by ISO C"
HCAD96DA2A48D: "길이 모디파이어 '%0'와 변환 지정자 '%1'을 함께 사용하는 것은 ISO C에서 지원되지 않습니다."
# 'using namespace directive in global context in header'
HDFF3F4F00DD3: '헤더 파일에서 전역 컨텍스트에 using 네임스페이스 지시문을 사용했습니다.'
# "using sysroot for '%0' but targeting '%1'"
H23CBFE9436FA: "sysroot를 '%0'에 사용하지만 대상은 '%1'입니다"
# 'using the result of an assignment as a condition without parentheses'
HD808A1E3A9FB: '할당문의 결과를 조건으로 사용하면서 괄호를 사용하지 않았습니다'
# 'using the undeclared type %0 as a default template argument is a Microsoft extension'
H9BAAEE7535FA: '선언되지 않은 타입 %0을 기본 템플릿 인자로 사용하는 것은 마이크로소프트 확장 기능입니다'
# 'using unversioned Android target directory %0 for target %1; unversioned directories will not be used in Clang 19 -- provide a versioned directory for the target version or lower instead'
H120D3110B47A: '비버전화된 Android 타겟 디렉토리 %0을 타겟 %1에 사용 중입니다; Clang 19부터는 비버전화된 디렉토리를 사용하지 않습니다 -- 대신 타겟 버전 또는 그 이하 버전을 위한 버전화된 디렉토리를 제공해 주세요'
# 'using-enum cannot name a dependent type'
H3DC57F2168E8: 'using-enum는 의존 형식을 명명할 수 없습니다'
# 'usual LSP protocol'
H562B11D542B5: '일반적인 LSP 프로토콜'
# 'uuid attribute contains a malformed GUID'
H1FAF5254B686: 'uuid 속성에 형식이 잘못된 GUID가 포함되어 있습니다'
# 'uuid does not match previous declaration'
H1E8E115FA4D8: 'UUID는 이전 선언과 일치하지 않습니다'
# 'valid %0 clauses start with %1; %select{token|tokens}2 will be ignored'
HA977999237FF: '유효한 %0 절은 %1으로 시작해야 합니다; %select{토큰|토큰들}2는 무시됩니다'
# 'valid target CPU values are: %0'
HB573A028A656: '유효한 대상 CPU 값은 다음과 같습니다: %0'
# 'value %0 is outside the range of representable values of type %1'
H76B206381D68: '값 %0는 %1 유형에서 표현 가능한 값의 범위를 벗어났습니다'
# 'value %1 cannot be represented in type %0'
H0FCCEC09B538: '값 %1은 유형 %0에서 표현할 수 없습니다.'
# "value '%0' out of range for constraint '%1'"
H2964C78586A1: "값 '%0'은 제약 조건 '%1'의 범위를 벗어났습니다."
# 'value is not an integer: %0'
HDF6724275715: '값은 정수가 아닙니다: %0'
# 'value of #pragma pack(show) == %0'
H78F0B6172824: '#pragma pack(show) 값은 %0입니다.'
# 'value of the aligned pointer (%0) is not a multiple of the asserted %1 %plural{1:byte|:bytes}1'
HCBC69FE1B218: '정렬된 포인터(%0)의 값이 명시된 %1 %plural{1:byte|:bytes}1의 배수가 아닙니다'
# "value of type %0 is not contextually convertible to 'bool'"
H8D6D08CCD77E: "유형 %0의 값은 맥락적으로 'bool'로 변환할 수 없습니다"
# 'value of type %0 is not implicitly convertible to %1'
H7F07136EE80D: '타입 %0의 값은 %1로 암시적으로 변환되지 않습니다'
# "value returned by '__builtin_counted_by_ref' cannot be %select{assigned to a variable|passed into a function|returned from a function}0"
H0D53FCA7346F: '‘__builtin_counted_by_ref’에서 반환된 값은 %select{변수에 할당되거나|함수에 전달되거나|함수에서 반환되거나}0 수 없습니다.'
# "value returned by '__builtin_counted_by_ref' cannot be used in %select{an array subscript|a binary}0 expression"
H4F263548602C: '__builtin_counted_by_ref에서 반환된 값은 %select{an array subscript|a binary}0 표현식에서 사용할 수 없습니다'
# 'value size does not match register size specified by the constraint and modifier'
H45E5585EA0B2: '값의 크기는 제약 조건과 수정자에 의해 지정된 레지스터 크기와 일치하지 않습니다.'
# 'varargs not allowed in requires expression'
H65BA20F3C0FC: 'varargs는 requires 표현식 내에서 허용되지 않습니다.'
# "variable %0 cannot be declared both 'extern' and with the 'loader_uninitialized' attribute"
H66B3CD6187EF: "변수 %0는 'extern'과 'loader_uninitialized' 속성을 동시에 선언할 수 없습니다"
# 'variable %0 cannot be implicitly captured in a lambda with no capture-default specified'
H17BA614E3EF4: '변수 %0는 캡처 기본값이 지정되지 않은 lambda에서 암시적으로 캡처될 수 없습니다'
# 'variable %0 cannot be threadprivate because it is %select{thread-local|a global named register variable}1'
HF72C764C6D1B: '변수 %0는 threadprivate로 지정할 수 없습니다因为它은 %select{스레드 로컬|전역 이름 지정된 레지스터 변수}1이기 때문입니다.'
# 'variable %0 is %select{decremented|incremented}1 both in the loop header and in the loop body'
H5880C36D679C: '변수 %0는 루프 헤더와 본문 모두에서 %select{감소됩니다|증가됩니다}1'
# "variable %0 is %select{used|captured}1 uninitialized whenever %select{'%3' condition is %select{true|false}4|'%3' loop %select{is entered|exits because its condition is false}4|'%3' loop %select{condition is true|exits because its condition is false}4|switch %3 is taken|its declaration is reached|%3 is called}2"
H5B3E786190C7: "변수 %0는 %select{사용됨|포착됨}1 초기화되지 않았습니다. 언제든지 %select{'%3' 조건이 %select{참|거짓}4일 때|'%3' 루프가 %select{진입할 때|%의 조건이 거짓으로 인해 종료될 때}4|'%3' 루프의 %select{조건이 참일 때|%의 조건이 거짓으로 인해 종료될 때}4|switch %3가 선택될 때|선언 부분에 도달할 때|%3가 호출될 때}2 발생할 때마다"
# 'variable %0 is declared here'
H9C1D29CE922D: '변수 %0는 여기서 선언되었습니다'
# 'variable %0 is uninitialized when %select{used here|captured by block}1'
HC11F7DAD1A0E: '변수 %0는 %select{여기에서 사용될 때|블록에 캡처될 때}1 초기화되지 않았습니다'
# 'variable %0 is uninitialized when passed as a const reference argument here'
H12F79B618200: '변수 %0는 여기서 const 참조 인수로 전달될 때 초기화되지 않았습니다'
# 'variable %0 is uninitialized when used within its own initialization'
H9B3210B51205: '변수 %0는 자신의 초기화 과정 내에서 사용될 때 초기화되지 않았습니다'
# 'variable %0 is%select{| explicitly}1 captured here'
HC5A87C36FF05: '변수 %0는%select{ | 명시적으로 }1 여기서 포획되었습니다'
# 'variable %0 may be uninitialized when %select{used here|captured by block}1'
HC0A7D9F9078D: '변수 %0는 %select{여기에서 사용될 때|블록에 의해 캡처될 때}1에 초기화되지 않았을 수 있습니다'
# 'variable %0 must have explicitly specified data sharing attributes'
H9EFAEC625413: '변수 %0는 데이터 공유 속성을 명시적으로 지정해야 합니다'
# 'variable %0 must have explicitly specified data sharing attributes, data mapping attributes, or in an is_device_ptr clause'
H577354E45CD4: '변수 %0는 데이터 공유 속성, 데이터 매핑 속성 또는 is_device_ptr 절에 명시적으로 지정되어야 합니다'
# 'variable %0 set but not used'
H9EEEA592434A: '변수 %0은(는) 설정되었지만 사용되지 않았습니다'
# 'variable %0 with flexible array member cannot be captured in a lambda expression'
HEE231707A80F: '%0 변수는 유연한 배열 멤버를 가지므로 람다 표현식에 캡처할 수 없습니다'
# 'variable %0 with type %1 has incompatible initializer of type %2'
HECE6754B3154: '변수 %0의 유형 %1은 초기화자 유형 %2와 호환되지 않습니다.'
# 'variable %0 with unknown type cannot be given a function type'
HBD6B0E34602F: '알 수 없는 형식을 가진 변수 %0에는 함수 형식을 지정할 수 없습니다'
# 'variable %select{|in unary expression|on right hand side of assignment|on left hand side of assignment|on left hand side of compound assignment|on left hand side of assignment}2(%3) must match variable used %select{|in unary expression|on right hand side of assignment|<not possible>|on left hand side of compound assignment|on left hand side of assignment}0(%1) from the first statement'
HA70BF8F524C0: '변수 %3 (%select{|단항 표현식 내|할당 오른쪽 표현식|할당 왼쪽 표현식|복합 할당 왼쪽 표현식|할당 왼쪽 표현식}2)은 첫 번째 문에서 사용된 변수 %1 (%select{|단항 표현식 내|할당 오른쪽 표현식|<불가능>|복합 할당 왼쪽 표현식|할당 왼쪽 표현식}0)과 일치해야 합니다'
# 'variable already marked as mapped in current construct'
HA15930719644: '변수는 이미 현재 구조에서 매핑 되어 있음'
# "variable appearing in '%0' clause of OpenACC 'declare' directive must be in the same scope as the directive"
H32CD6FB44C7B: "변수가 OpenACC 'declare' 디렉티브의 '%0' 절에 등장하는 경우, 해당 변수는 디렉티브와 동일한 스코프 내에 위치해야 합니다"
# "variable can appear only once in OpenMP '%0' clause"
H084B181F0F6F: "변수는 OpenMP '%0' 절에서 한 번만 나타날 수 있습니다"
# "variable can appear only once in OpenMP 'target update' construct"
H78D2AF4A7A62: "변수는 OpenMP 'target update' 구조에서 한 번만 출현할 수 있습니다"
# 'variable captured in declare target region must appear in a to clause'
H2004C3E36B6D: 'declare 대상 영역에서 포착된 변수는 to 절에 나타나야 합니다.'
# 'variable declaration in a constexpr %select{function|constructor}0 is a C++14 extension'
H953C3A7294B8: 'constexpr %select{함수|생성자}0 내의 변수 선언은 C++14 확장 기능입니다'
# 'variable declaration in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14'
H5037F674FC7B: 'constexpr %select{함수|생성자}0 내부의 변수 선언은 C++14 이전의 C++ 표준과 호환되지 않습니다'
# 'variable declaration in condition cannot have a parenthesized initializer'
HA7027EDD1E14: '조건문 내에서의 변수 선언은 괄호로 감싼 초기화자를 가질 수 없습니다'
# 'variable declaration in condition must have an initializer'
H031DEC12DA47: '조건 내의 변수 선언은 초기화자를 가져야 합니다'
# 'variable declaration in for loop is a C99-specific feature'
HCED2B7B23919: 'for 루프 내 변수 선언은 C99 특정 기능입니다'
# 'variable declared constinit here'
HBD9CCEC96BCC: '여기서 constinit로 선언된 변수입니다'
# "variable declared with 'objc_externally_retained' cannot be modified in ARC"
H47C52BC3E77D: "ARC에서 'objc_externally_retained'로 선언된 변수는 수정할 수 없습니다"
# 'variable does not have a constant initializer'
HB267A973AA07: '변수는 상수 초기화자를 갖지 않습니다'
# 'variable has incomplete type %0'
HF07B48579A53: '변수 %0는 미완결한 형식을 가지고 있습니다'
# 'variable in constant address space must be initialized'
H66FDD0998C58: '상수 주소 공간에 있는 변수는 초기화되어야 합니다'
# 'variable is not assignable (missing __block type specifier)'
HAA0B269B98F3: '변수가 할당될 수 없습니다 (__block 형식 지정자가 누락되었습니다)'
# 'variable length array cannot be formed during template argument deduction'
HF26A880CF088: '템플릿 인자 추론 중에 가변 길이 배열을 형성할 수 없습니다'
# "variable length array declaration cannot have 'extern' linkage"
H2436B28C5991: "가변 길이 배열 선언은 'extern' 링크지음을 가질 수 없습니다"
# "variable length array declaration cannot have 'static' storage duration"
H9C9D3E1402A9: "가변 길이 배열 선언에는 'static' 저장 기간을 가질 수 없습니다"
# 'variable length array declaration not allowed at file scope'
H01CDB7349FFD: '파일 스코프에서 가변 길이 배열 선언은 허용되지 않습니다'
# 'variable length array folded to constant array as an extension'
H861F6896A4A9: '가변 길이 배열이 확장 기능으로 고정 길이 배열로 변환됨'
# 'variable length array must be bound in function definition'
HACDD33225FC5: '가변 길이 배열은 함수 정의에서 반드시 크기를 지정해야 합니다'
# 'variable length array used'
HFCB17814F664: '가변 길이 배열이 사용되었습니다'
# 'variable length arrays are a C99 feature'
H82A7E9913A2F: '가변 길이 배열은 C99의 기능입니다'
# "variable length arrays are not supported %select{for the current target|in '%1'}0"
H5707BCACEAC8: '가변 길이 배열은 %select{현재 타겟에서|‘%1’에서}0 지원되지 않습니다'
# 'variable length arrays are not supported for the current target'
H50B2A4B545B7: '현재의 타겟에서는 가변 길이 배열이 지원되지 않습니다'
# 'variable length arrays are not supported in OpenCL'
H201996231D1A: 'OpenCL에서는 가변 길이 배열이 지원되지 않습니다'
# "variable length arrays are not supported in OpenMP tasking regions with 'untied' clause"
H20FB8AB94029: "가변 길이 배열은 OpenMP 작업 영역에서 'untied' 절을 사용할 때 지원되지 않습니다"
# 'variable length arrays in C++ are a Clang extension'
HCD7C2CD01723: 'C++에서의 가변 길이 배열은 Clang의 확장 기능입니다'
# "variable length arrays in C++ are a Clang extension; did you mean to use 'static_assert'?"
H53E1EE683577: "C++에서 가변 길이 배열은 Clang의 확장 기능입니다; 'static_assert'를 사용하시려는 것이었나요?"
# 'variable length arrays in a coroutine are not supported'
HD279E72346CE: '코루틴 안의 가변 길이 배열은 지원되지 않습니다'
# 'variable must be of integer or %select{pointer|random access iterator}0 type'
H4F34EF5C94E2: '변수는 정수형 또는 %select{포인터|임의 접근 반복자}0 형이어야 합니다'
# "variable named 'main' with external linkage has undefined behavior"
H38BA25ED2BA1: "변수 이름이 'main'인 외부 링크지정 변수는 정의되지 않은 동작을 가집니다"
# 'variable of non-literal type %1 cannot be defined in a constexpr %select{function|constructor}0 before C++23'
H5F89C6201D7E: '리터럴 형식이 아닌 형식의 변수 %1은 C++23 이전에는 constexpr %select{함수|생성자}0 내에서 정의할 수 없습니다'
# "variable of non-reference type %0 can be used only with 'val' modifier, but used with '%1'"
HFF57CDDBE63D: "참조 형식이 아닌 %0 형식의 변수는 'val' 수정자만 사용할 수 있지만 '%1' 수정자로 사용되었습니다"
# 'variable of type %1 has %select{private|protected}2 destructor'
H8BC8C9632B1A: '타입 %1의 변수가 %select{private|protected}2 소멸자를 가집니다'
# "variable referenced by 'link' clause not in global or namespace scope must be marked 'extern'"
HF7968BA9CE92: "링크 절에서 참조된 변수가 전역 또는 네임스페이스 범위에 있지 않은 경우 'extern'으로 표시되어야 합니다"
# "variable referenced in '%0' clause of OpenACC 'declare' directive was already referenced"
H8FFABBD53A56: "OpenACC 'declare' 지시문의 '%0' 절에서 참조된 변수는 이미 참조되었습니다"
# 'variable template partial specialization %0 cannot be redefined'
HB5621CB8D5D4: '변수 템플릿 부분 특수화 %0는 재정의할 수 없습니다'
# 'variable templates are a C++14 extension'
H031A6133F773: '변수 템플릿은 C++14 확장 기능입니다'
# 'variable templates are incompatible with C++ standards before C++14'
HC36BFC632A54: '변수 템플릿은 C++14 이전의 C++ 표준과 호환되지 않습니다'
# "variable with 'loader_uninitialized' attribute cannot have an initializer"
H9908D11CFEF9: 'loader_uninitialized 속성을 가진 변수에는 초기화자를 가질 수 없습니다.'
# "variable with 'loader_uninitialized' attribute must have a trivial default constructor"
H30559420B01D: 'loader_uninitialized 속성을 가진 변수는 trivial 기본 생성자를 가져야 합니다'
# 'variable with local storage in initial value of threadprivate variable'
H06BE1F004442: 'threadprivate 변수의 초기값에 지역 저장 영역을 갖는 변수'
# 'variable%select{s| %1|s %1 and %2|s %1, %2, and %3|s %1, %2, %3, and %4}0 used in loop condition not modified in loop body'
H78CB81888F63: '변수%select{s| %1|s %1 및 %2|s %1, %2, 및 %3|s %1, %2, %3, 및 %4}0는 루프 조건에서 사용되었으나 루프 본문에서 수정되지 않았습니다'
# 'variable-sized object may not be initialized'
HF22D786D9F31: '가변 길이 객체는 초기화할 수 없습니다'
# 'variables in function scope cannot be declared static'
H588D8DBF6957: '함수 범위 내의 변수는 static으로 선언할 수 없습니다.'
# 'variables in the %0 address space can only be declared in the outermost scope of a kernel function'
H077534025BE2: '주소 공간 %0의 변수는 커널 함수의 가장 바깥쪽 범위에서만 선언될 수 있습니다'
# 'variably modified type %0 cannot be used as a template argument'
H43ADD4446C3D: '가변 길이 수정된 형식 %0는 템플릿 인수로 사용할 수 없습니다'
# "variably modified type declaration cannot have 'extern' linkage"
H31174A21A725: "가변 길이 형식 선언은 'extern' 링크지성을 가질 수 없습니다"
# 'variably modified type declaration not allowed at file scope'
H0326E5892284: '파일 범위에서 가변형 타입 선언은 허용되지 않습니다'
# 'variably-modified type %0 cannot be used in a constexpr %select{function|constructor}1'
HA78DFABA86CF: '가변 수정된 형식 %0는 constexpr %select{함수|생성자}1에서 사용할 수 없습니다'
# "variadic 'friend' declarations are a C++2c extension"
H3D2FFF66A145: "가변 'friend' 선언문은 C++2c 확장입니다."
# "variadic 'friend' declarations are incompatible with C++ standards before C++2c"
H365CB532BF3E: "가변 인자 'friend' 선언은 C++2c 이전의 C++ 표준과 호환되지 않습니다."
# 'variadic function cannot use %0 calling convention'
HEC894E082768: '가변 인자 함수는 %0 호출 규약을 사용할 수 없습니다'
# 'variadic macros are a C99 feature'
H6AA48F3D31FE: '가변형 매크로는 C99의 기능입니다'
# 'variadic macros are a Clang extension in OpenCL'
H1CAB7A29DC4C: '가변 매크로는 OpenCL에서 Clang의 확장 기능입니다'
# 'variadic macros are incompatible with C++98'
H4BD20CD6A5E1: '가변 인자 매크로는 C++98과 호환되지 않습니다'
# 'variadic templates are a C++11 extension'
H499FA3A280B8: '가변 템플릿은 C++11의 확장 기능입니다'
# 'variadic templates are incompatible with C++98'
H4B7B3608CF46: '가변 템플릿은 C++98과 호환되지 않습니다'
# "variant function in '#pragma omp declare variant' is itself marked as '#pragma omp declare variant'"
H82A01F59E7E3: "'#pragma omp declare variant' 지시문 안의 변이 함수가 자신을 '#pragma omp declare variant'로 지정했습니다."
# "variant in '#pragma omp declare variant' is the same as the base function"
HEC73C56687BA: "variant in '#pragma omp declare variant'는 기본 함수와 동일합니다"
# "variant in '#pragma omp declare variant' with type %0 is incompatible with type %1%select{| with appended arguments}2"
H443E0ACFD62A: "'#pragma omp declare variant'의 variant %0 형식은 %1%select{| 추가 인자와 함께}2 형식과 호환되지 않습니다."
# 'vector component access exceeds type %0'
HA6E77B2F0A3C: '벡터 구성 요소 액세스가 유형 %0를 초과했습니다'
# 'vector component access has invalid length %0; supported lengths are: 1,2,3,4,8,16'
HCB71F9B8CFBC: '벡터 구성 요소 접근의 길이 %0는 유효하지 않습니다; 지원되는 길이는 1, 2, 3, 4, 8, 16입니다'
# "vector component name '%0' is a feature from OpenCL version 3.0 onwards"
H6B53729D7A1D: "벡터 구성 요소 이름 '%0'은 OpenCL 버전 3.0부터의 기능입니다"
# 'vector condition type %0 and result type %1 do not have elements of the same size'
H9FFA8360C1AF: '벡터 조건 타입 %0과 결과 타입 %1은 동일한 크기의 요소를 가지고 있지 않습니다.'
# 'vector condition type %0 and result type %1 do not have the same number of elements'
H48693917C57D: '벡터 조건 타입 %0과 결과 타입 %1의 요소 수가 동일하지 않습니다'
# 'vector initializers are not compatible with NEON intrinsics in big endian mode'
H20E090504D21: '빅 엔디언 모드에서 벡터 초기화자는 NEON 인트리尼克스와 호환되지 않습니다'
# 'vector is not assignable (contains duplicate components)'
HA13B723E09E4: '벡터는 할당할 수 없습니다 (중복된 구성 요소가 있습니다)'
# 'vector operands do not have the same elements sizes (%0 and %1)'
H20CF2F14B1AB: '벡터 피연산자들의 요소 크기가 동일하지 않습니다. (%0 및 %1)'
# 'vector operands do not have the same number of elements (%0 and %1)'
H02E2D0489C4C: '벡터 피연산자의 요소 수가 같지 않습니다 (%0와 %1)'
# 'vector operands to the vector conditional must be the same type %diff{($ and $)|}0,1}'
HBD47DE4A7313: '벡터 조건부의 벡터 연산자는 같은 타입이어야 합니다 %diff{($0과 $1)|}0,1}'
# 'vector size not an integral multiple of component size'
H77E12186A8E0: '벡터 크기는 구성 요소 크기의 정수 배여야 합니다'
# "vectorize_width loop hint malformed; use vectorize_width(X, fixed) or vectorize_width(X, scalable) where X is an integer, or vectorize_width('fixed' or 'scalable')"
H52976DB4C3C0: "vectorize_width 루프 힌트 형식이 잘못되었습니다; 사용 방법: vectorize_width(X, fixed) 또는 vectorize_width(X, scalable) (X는 정수) 또는 vectorize_width('fixed' 또는 'scalable') 형식을 사용해야 합니다"
# "vendor '%0' is not supported: '%1'"
HEF7F8EFDE1D2: "제조사 '%0'은(는) 지원되지 않습니다: '%1'"
# 'verbose'
H3F73A838273F: '상세'
# 'verify structure of the log'
HA2B07D4BBAB9: '로그 구조 검증'
# 'verify the CFG after every pass'
H94E54A437791: '각 패스 이후 CFG를 검증합니다'
# 'verify-uselistorder Options'
HBF754C1F763D: 'verify-uselistorder 옵션'
# "version '%0' in target triple '%1' is invalid"
H638A2A1C27BA: "타겟 트리플 '%1'의 버전 '%0'이 유효하지 않습니다"
# 'version 1'
H58A74A7AA4A0: '버전 1'
# 'version 2'
H85DE840F8B53: '버전 2'
# 'version 3'
HA54E81A648CA: '버전 3'
# 'version 4'
H6BCF2142DE82: '버전 4'
# 'version control conflict marker in file'
H58D6C666A33F: '파일 내에서 버전 관리 충돌 표시자'
# "version for '%0' already specified"
HD1955B4EAF6D: "버전 '%0'은 이미 지정되었습니다"
# 'version list contains duplicate entries'
HDC1A5F99BC1B: '버전 목록에 중복 항목이 포함되어 있습니다'
# "version list contains entries that don't impact code generation"
H346B24B0B01F: '버전 목록에 코드 생성에 영향을 주지 않는 항목이 포함되어 있습니다'
# 'version number must have non-zero major, minor, or sub-minor version'
H32D5C8ECFF2D: '버전 번호는 0이 아닌 메이저, 마이너, 또는 서브마이너 버전을 반드시 포함해야 합니다'
# 'violations found for %0'
HC357EBB7E4D0: '위반 사항이 %0개 발견되었습니다'
# 'virtual base class declared here'
H2738AB0FED80: '가상 base 클래스가 여기서 선언되었습니다'
# 'virtual constexpr functions are incompatible with C++ standards before C++20'
H0CA73C06B6D5: '가상 constexpr 함수는 C++20 이전의 C++ 표준과 호환되지 않습니다'
# "virtual destructor requires an unambiguous, accessible 'operator delete'"
H23281750E023: "가상 소멸자는 명확하고 접근 가능한 'operator delete'가 필요합니다"
# "virtual filesystem overlay file '%0' not found"
H26F74FB8B8C2: "가상 파일 시스템 오버레이 파일 '%0'을(를) 찾을 수 없습니다"
# 'virtual function %0 has a different return type %diff{($) than the function it overrides (which has return type $)|than the function it overrides}1,2'
HD8B18D2DDADC: '가상 함수 %0는 오버라이드하는 함수와 다른 리턴 타입 %diff{$(을 가지고 있습니다. (원래 함수의 리턴 타입은 $))|을 가지고 있습니다}1,2'
# 'virtual function %0 has different attributes %diff{($) than the function it overrides (which has $)|than the function it overrides}1,2'
H105CB368BBFA: '가상 함수 %0는 다른 속성 %diff{ $를 가집니다 (오버라이드하는 함수는 $를 가집니다)|와 오버라이드하는 함수가 다릅니다}1,2'
# 'virtual function %0 has different calling convention attributes %diff{($) than the function it overrides (which has calling convention $)|than the function it overrides}1,2'
HB03FA37606B1: '가상 함수 %0는 오버라이드하는 함수(이 함수는 호출 규칙 $2를 가짐)와 다른 호출 규칙 속성 %diff{를 가집니다. ($1)|$2를 가집니다}1,2'
# 'virtual function %q0 has more than one final overrider in %1'
H80394FC58D1D: '가상 함수 %q0는 %1 내에서 최종 오버라이더가 한 개 이상 존재합니다'
# 'virtual function cannot be constexpr'
H01635D482A33: '가상 함수는 constexpr일 수 없습니다.'
# 'virtual function cannot have a requires clause'
H138054D4510B: '가상 함수에는 requires 절을 가질 수 없습니다'
# 'virtual functions are not supported in C++ for OpenCL'
H820F01CD9896: '가상 함수는 C++에서 OpenCL에 대해 지원되지 않습니다.'
# 'virtual functions are unsupported in HLSL'
H207695B65E04: '가상 함수는 HLSL에서 지원되지 않습니다'
# 'virtual inheritance is unsupported in HLSL'
H8C2B278220B7: '가상 상속은 HLSL에서 지원되지 않습니다'
# "virtual method %0 is inside a 'final' class and can never be overridden"
HAC30D95A1570: "가상 메서드 %0는 'final' 클래스 내부에 있으며 따라서 절대 오버라이드될 수 없습니다"
# 'visibility does not match previous declaration'
H17040BB5EC03: '가시성이 이전 선언과 일치하지 않습니다.'
# 'void %select{function|method|block}1 %0 should not return void expression'
HCA9EAB88160F: 'void %select{함수|메서드|블록}1 %0는 void 표현식을 반환해서는 안 됩니다'
# 'void block should not return a value'
H1C0762ECEC55: 'void 블록에는 반환 값이 있어선 안 됩니다'
# 'volatile %select{temporary created|object declared|member declared}0 here'
HBA1E3AEA8BE2: 'volatile %select{임시 생성|객체 선언|멤버 선언}0 여기'
# 'volatile qualifier in structured binding declaration is deprecated'
H8119BA6E8068: '구조체 바인딩 선언에서 volatile 자격 증명은 사용 중지 권고 됨'
# 'volatile-qualified parameter type %0 is deprecated'
H9F774F8B8E15: 'volatile-qualified 매개변수 유형 %0는 비추천 됨'
# 'volatile-qualified return type %0 is deprecated'
H34762436C2FA: 'volatile 자격 증명된 리턴 타입 %0는 사용되지 않도록 권장됨'
# 'warn on trailing characters'
H82F663F8D48C: '뒤따라오는 문자열에 대해 경고'
# 'warnings are errors'
HB9FCBCA0C7DE: '경고를 오류로 처리'
# 'was searched for in the directory: %0'
H4B8949005850: '다음 디렉토리에서 검색되었습니다: %0'
# 'wave good bye'
H29B5647E64A4: '작별 인사 흔들기'
# 'weak %select{variable|property|implicit property|instance variable}0 %1 is accessed multiple times in this %select{function|method|block|lambda}2 but may be unpredictably set to nil; assign to a strong variable to keep the object alive'
H7F2B64A607B2: '약한 %select{변수|속성|암시적 속성|인스턴스 변수}0 %1이(가) 이 %select{함수|메서드|블록|람다}2에서 여러 번 액세스 되지만 예측할 수 없게 nil로 설정될 수 있습니다; 강한 변수에 할당하여 객체를 유지하십시오'
# 'weak %select{variable|property|implicit property|instance variable}0 %1 may be accessed multiple times in this %select{function|method|block|lambda}2 and may be unpredictably set to nil; assign to a strong variable to keep the object alive'
H301C12832949: '약한 %select{variable|property|implicit property|instance variable}0 %1은(는) 이 %select{function|method|block|lambda}2에서 여러 번 접근될 수 있으며 예측할 수 없게 nil로 설정될 수 있습니다; 객체를 유지하려면 strong 변수에 할당하세요'
# 'weak attribute declared on a __strong type property in GC mode'
H088D436307D2: 'GC 모드에서 __strong 타입 속성에 weak 속성이 선언되었습니다'
# 'weak declaration cannot have internal linkage'
HC1895405FFA7: '약한 선언(weak declaration)은 내부 링크지정(internal linkage)을 가질 수 없습니다.'
# 'weak identifier %0 never declared'
H22A978739C8D: '약한 식별자 %0는 결코 선언되지 않았습니다'
# 'weakref declaration must have internal linkage'
H8016E3683340: '약한 참조 선언은 내부 링크지가 필요합니다'
# 'weakref declaration of %0 must also have an alias attribute'
H101799E65B31: '약한 참조 선언 %0는 반드시 alias 속성을 포함해야 합니다'
# 'weakref declaration of %0 must be in a global context'
HDA1EB6DAD24A: '약한 참조 선언 %0는 전역 컨텍스트에서 선언되어야 합니다.'
# 'webassembly: disables the fix  irreducible control flow optimization pass'
HA0B81E145B1D: '웹어셈블리: fix irreducible control flow optimization 패스를 비활성화합니다'
# 'when a function is considered for merging into a partition that already contains some of its callees, do the merge if at least n% of the code it can reach is already present inside the partition; e.g. 0.7 means only merge >70%'
HB679EAE1AA06: '함수가 이미 해당 함수의 일부 호출된 함수를 포함하는 분할에 병합 대상으로 고려될 때, 해당 함수가 접근 가능한 코드 중 최소 n%가 분할 내에 이미 존재하면 병합을 수행합니다. 예: 0.7은 70% 초과일 때만 병합'
# 'when applied to this declaration'
HA6DB04448955: '이 선언에 적용될 때'
# 'when deciding to split a function, apply this alignment while doing the size comparison (see -split-threshold). Default value: 2.'
HD6693F2AB0CA: '함수를 분할할 때 크기 비교를 수행하는 동안 이 정렬을 적용합니다 (-split-threshold 옵션 참조). 기본값: 2.'
# 'when emitting large string tables, prefer string literals over comma-separated char literals. This can be a readability and compile-time performance win, but upsets some compilers'
H2D23BA9375B5: '큰 문자열 테이블을 생성할 때는 쉼표로 구분된 문자 리터럴 대신 문자열 리터럴을 선호합니다. 이는 가독성과 컴파일 시간 성능을 향상시킬 수 있지만, 일부 컴파일러에서 문제가 될 수 있습니다'
# 'when implemented by class %0'
H9F7ED2DB900A: '클래스 %0에 의해 구현될 때'
# "when looking up '%select{begin|end}0' function for range expression of type %1"
HC4C870329421: "타입 %1의 범위 표현식을 위한 '%select{begin|end}0' 함수를 조회할 때"
# 'when max depth is reached and we can no longer branch out, this value determines if a function is worth merging into an already existing partition to reduce code duplication. This is a factor of the ideal partition size, e.g. 2.0 means we consider the function for merging if its cost (including its callees) is 2x the size of an ideal partition.'
HC50D6FBB78F2: '최대 깊이에 도달했을 때 더 이상 분기할 수 없으면, 이 값은 함수를 이미 존재하는 파티션에 병합해 코드 중복을 줄일 가치가 있는지 결정합니다. 이는 이상적인 파티션 크기의 인자입니다. 예를 들어, 2.0은 함수의 비용(호출자들을 포함하여)이 이상적인 파티션 크기의 2배라면 병합을 고려한다는 의미입니다.'
# 'when possible, poison scoped variables at the beginning of the scope (slower, but more precise)'
H00AA44541919: '가능한 경우, 범위의 시작 부분에서 범위 변수를 오염시킵니다. (더 느리지만 더 정확합니다.)'
# 'when repeating the instruction snippet by looping over it, duplicate the snippet until the loop body contains at least this many instruction'
HED512258C903: '루프를 통해 해당 지시문 스니펫을 반복하는 경우, 루프 본문에 최소 이만큼의 명령문이 포함될 때까지 스니펫을 복제하십시오.'
# 'when type is in parentheses, array cannot have dynamic size'
HBDE59C8D782B: '타입이 괄호 안에 있을 때, 배열은 동적 크기를 가질 수 없습니다.'
# 'which delegates to'
H90C5BED46FE0: '다음으로 위임합니다:'
# 'which gadget scanners to run'
HF9F26A96F310: '실행할 gadget 스캐너 목록'
# 'while building implicit deduction guide first needed here'
HD4658CE20D59: '암시적 추론 가이드 생성 중 여기에서 처음으로 필요함'
# 'while calculating associated constraint of template %0 here'
HD4CBA036E98A: 'template %0의 associated constraint를 계산하는 중 여기에서'
# 'while checking a default template argument used here'
H7E4F64D4A848: '이 위치에서 사용된 기본 템플릿 인수를 확인 중입니다'
# "while checking constraint satisfaction for class template partial specialization '%0' required here"
H190F26B4DB43: "클래스 템플릿 부분 전문화 '%0'의 제약 조건 충족을 확인 중에 여기서 필요함"
# "while checking constraint satisfaction for function '%0' required here"
H1A3A707B1D73: "함수 '%0'의 제약 조건 충족을 검사하는 중 여기서 필요합니다"
# "while checking constraint satisfaction for template '%0' required here"
H19BE8EB0741D: "템플릿 '%0'의 제약 조건 충족 여부를 확인하던 중 여기서 필요함"
# "while checking constraint satisfaction for variable template partial specialization '%0' required here"
HD73CEE0E62DB: "변수 템플릿 부분 특수화 '%0'의 제약 조건 충족을 확인하는 중 여기서 필요함"
# "while checking implicit 'delete this' for virtual destructor"
H738DE49AA679: "가상 소멸자에 대한 암시적 'delete this' 확인 중"
# "while checking the satisfaction of concept '%0' requested here"
HE2FF74B26A28: "여기서 요청된 개념 '%0'의 충족 여부를 확인하는 중"
# 'while checking the satisfaction of nested requirement requested here'
HE3D634694184: '중첩된 요구사항이 여기서 충족되었는지 확인하는 중'
# "while declaring the corresponding implicit 'operator==' for this defaulted 'operator<=>'"
H332A7297AC58: "이 디폴트된 'operator<=>'의 해당하는 암시적 'operator=='을 선언할 때"
# 'while declaring the implicit %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}1 for %0'
HAC5877F575DC: '암시적 %select{기본 생성자|복사 생성자|이동 생성자|복사 할당 연산자|이동 할당 연산자|소멸자}1을 선언할 때 %0에 대해'
# 'while loop has empty body'
H374FEF617D4F: 'while 문의 본문이 비어 있습니다'
# 'while loop outside of a function'
HAB96332E82A6: '함수 밖에서 while 루프를 사용했습니다.'
# 'while printing functions output dyno-stats and skip instructions'
HF414286E0A36: '함수를 출력할 때 dyno-stats를 출력하고 instructions를 건너뛰기'
# "while rewriting comparison as call to 'operator<=>' declared here"
H9A478A9E2AA1: "비교를 'operator<=>' 호출로 재작성하는 동안 여기에서 선언된 것입니다"
# 'while substituting deduced template arguments into function template %0 %1'
H4E16912522F9: '함수 템플릿 %0 %1에 추론된 템플릿 인자를 대입하는 중에'
# 'while substituting explicitly-specified template arguments into function template %0 %1'
H862C7E7129FA: '함수 템플릿 %0 %1에 명시적으로 지정된 템플릿 인수를 치환하는 중'
# 'while substituting into a lambda expression here'
H154EA9F3EDC1: '여기서 람다 표현식에 치환 중'
# 'while substituting into concept arguments here; substitution failures not allowed in concept arguments'
HAC706623FF86: '개념 인수에 대체 중 여기에서; 개념 인수에서 대체 실패는 허용되지 않습니다'
# 'while substituting prior template arguments into %select{non-type|template}0 template parameter%1 %2'
HF0EDCF82D09D: '템플릿 매개변수 %1 %2에 이전 템플릿 인수를 대입하는 중에 %select{비유형|템플릿}0 템플릿 매개변수에 대한'
# 'while substituting template arguments into constraint expression here'
H19C71987DC07: '템플릿 인수를 제약 표현에 대입하는 동안 여기서'
# 'whitespace is not allowed in parameter passing direction'
H82BD58AB277F: 'parameter의 전달 방향에 whitespace는 허용되지 않습니다'
# 'whitespace recommended after macro name'
H47F8347E0371: '마크로 이름 다음에 공백을 권장합니다'
# 'whitespace required after macro name'
H2F43B2E26F3A: '매크로 이름 뒤에 공백이 필요합니다'
# 'widen this field to %0 bits to store all values of %1'
HD1698255B212: '이 필드를 %0 비트로 확장하여 %1의 모든 값을 저장하십시오.'
# 'width of bit-field %0 (%1 bits) exceeds the width of its type; value will be truncated to %2 bit%s2'
H8896C13CC6D9: '비트 필드 %0의 너비 (%1 비트)는 해당 타입의 너비를 초과합니다; 값은 %2 비트로 잘려 나갈 것입니다'
# 'width of%select{ anonymous|}0 bit-field%select{| %1}0 (%2 bits) exceeds the %select{width|size}3 of its type (%4 bit%s4)'
H02B50746D7D1: '%select{익명 |}0 비트 필드%select{ | %1}0 (%2 비트)의 너비는 그 타입의 %select{너비|크기}3 (%4 비트)보다 큽니다'
# 'with jt-footprint-reduction, only process PIC jumptables and turn off other transformations that increase code size'
H3BB007DE5DDB: 'jt-footprint-reduction 옵션을 사용할 때, PIC 점프테이블만 처리하고 코드 크기를 증가시키는 다른 변환 기능들을 비활성화합니다'
# 'within field of type %0 declared here'
HEC6FDC220283: '타입 %0의 필드 내에서 여기서 선언됨'
# 'writable atomic property %0 cannot pair a synthesized %select{getter|setter}1 with a user defined %select{getter|setter}2'
HA65A16D8E26B: '쓰기 가능한 원자적 속성 %0는 합성된 %select{getter|setter}1을 사용자 정의 %select{getter|setter}2와 결합할 수 없습니다'
# 'write BOLT Address Translation tables'
H1540FEF77408: 'BOLT 주소 변환 테이블 작성'
# 'write bolt info section in the output binary'
H5BC44776C33F: '출력 바이너리에 bolt 정보 섹션을 작성'
# 'wrong argument format for hlsl attribute, use %0 instead'
H514518256D51: 'HLSL 속성에 대한 잘못된 인수 형식입니다. 대신 %0를 사용하세요'
# 'wrong fpu width; %select{LSX|LASX}0 depends on 64-bit FPU'
H65FC5C473561: '잘못된 FPU 너비; %select{LSX|LASX}0은 64비트 FPU에 의존합니다'
# 'yaml2obj Options'
H095AAC30EBC3: 'yaml2obj 옵션'
# "you need to include <typeinfo> before using the 'typeid' operator"
H64B8C0D4E612: 'typeid 연산자를 사용하기 전에 <typeinfo>를 포함해야 합니다'
# 'z/OS target level "%0" is discontinued'
HB5BA348592D3: 'z/OS 타겟 레벨 "%0"은(는) 지원이 중단되었습니다'
# 'z/OS target level "%0" is invalid'
H0080755EFA11: 'z/OS 대상 레벨 "%0"은 유효하지 않습니다'
# 'zero %0 size'
HF7816CFF7955: '제로 %0 크기'
# 'zero as null pointer constant'
H824A61FB1C48: '0을 NULL 포인터 상수로 사용'
# 'zero field width in scanf format string is unused'
H122ACCFBBD62: 'scanf 포맷 문자열에서 0인 필드 너비는 사용되지 않습니다'
# 'zero linear step (%0 %select{|and other variables in clause }1should probably be const)'
HDA0E059C273A: '선형 단계가 0입니다 (%0 %select{ | 및 절 내의 다른 변수들은 }1const로 선언하는 게 좋을 것입니다)'
# 'zero size arrays are an extension'
H49512BBF0CE4: '크기 0 배열은 확장 기능입니다'
# "zero-length array section is not allowed in 'depend' clause"
HC5FAF4CE6159: "길이가 0인 배열 섹션은 'depend' 절에서 허용되지 않았습니다"
# 'zero-length arrays are not permitted in %select{C++|SYCL device code|HIP device code}0'
H2F083F032372: '길이 0 배열은 %select{C++|SYCL 장치 코드|HIP 장치 코드}0에서 허용되지 않습니다'
