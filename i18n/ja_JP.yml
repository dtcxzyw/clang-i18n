# '\n********************\n\nPLEASE ATTACH THE FOLLOWING FILES TO THE BUG REPORT:\nPreprocessed source(s) and associated run script(s) are located at:'
H8F8E0E346199: '\n********************\n\nバグ報告書に以下のファイルを添付してください:\nプリプロセス済みソースファイルと関連スクリプトは以下に格納されています:'
# '\nDirectory where processed files are stored.\nLinks to definition locations will only be\ngenerated if the file is in this dir.'
H71324B3824F3: '\n処理済みファイルが格納されているディレクトリ。\n定義位置へのリンクはこのディレクトリ内にファイルが存在する場合のみ生成されます。'
# '\nThe directory for merging symbols.'
H41BC7E2887B5: '\nシンボルをマージするためのディレクトリ。'
# '\nThe output directory for saving the results.'
H9976AAF7AB83: '\n結果を保存するための出力ディレクトリ。'
# '\nURL of repository that hosts code.\nUsed for links to definition locations.'
HC00AE5E38B4C: '\nコードをホストするリポジトリのURL。\n定義位置へのリンク生成時に使用します。'
# '  Type "'
H1DFDE84EB693: '  タイプ "'
# " '%0 %select{sink:|source:}1' must be with '%select{omp_cur_iteration - 1|omp_cur_iteration}1'"
HCB22E641D2E6: " '%0 %select{sink:|source:}1' は '%select{omp_cur_iteration - 1|omp_cur_iteration}1' と共に使用する必要があります"
# " '%0' in a raw string literal delimiter is a C++2c extension"
H03B242298EB9: " 生文字列リテラルの区切り文字中に'%0'はC++2c拡張です"
# " '%0' in a raw string literal delimiter is incompatible with standards before C++2c"
HFCBE1727461C: " 生文字列リテラルの区切り文字中に'%0'はC++2cより前の規格では非互換です"
# ' (default: '
H6248B40D9879: ' （デフォルト: '
# ' <subcommand> --help" to get more help on a specific subcommand'
H386881D1E849: ' <サブコマンド> --help" を実行するとサブコマンド別の詳細が表示されます'
# ' BrainF compiler\n'
H25D59DE4A1CF: ' BrainFコンパイラ\n'
# ' [options]'
HE3EDA38172DD: ' [オプション]'
# ' [subcommand]'
HEBFEA7B72C8E: ' [サブコマンド]'
# ' positional argument'
HB552499219D4: ' ポジショナル引数'
# ' positional arguments: See: '
H847D7E575852: ' ポジショナル引数: 詳細は '
# '#else after #else'
H73FE4A6784FB: '#else は #else 後に使用できません'
# '#else without #if'
HF8F50363B288: '#else に #if がありません'
# '#embed is a %select{C23|Clang}0 extension'
H799E9AA4840E: '#embed は %select{C23|Clang}0 拡張です'
# '#embed is incompatible with C standards before C23'
H1AF95A3E3444: '#embed は C23 以前の規格では非互換です'
# '#endif without #if'
H56B14C401F16: 'endif マクロが #if なしで使用されました'
# '#ident is a language extension'
H45C329EC97BC: '#ident は言語拡張機能です'
# '#import is a language extension'
H8768B3DA6294: '#import は言語拡張機能です'
# '#import of type library is an unsupported Microsoft feature'
H1CFAB9C94AB6: '#import の型ライブラリ機能はサポートされていないマイクロソフトの機能です'
# '#include nested too deeply'
H21908EF6D74E: '#include が深くネストされています'
# "#include of '%0' not seen while attempting to %select{create|use}1 precompiled header"
H05355AF7456A: "#include '%0' が、プリコンパイルド ヘッダーを%select{作成|使用}1しようとした際に見つかりませんでした"
# '#include resolved using non-portable Microsoft search rules as: %0'
HE0D8871EA3B6: '#include は非移植性のあるマイクロソフト検索ルールを使用して解決されました: %0'
# '#include_next in file found relative to primary source file or found by absolute path; will search from start of include path'
H92850FB4B236: '#include_next が主ソースファイルからの相対パスか絶対パスで見つかったため、インクルードパスの先頭から検索されます'
# '#include_next in primary source file; will search from start of include path'
HA1F5AE68D4B4: '主ソースファイルの #include_next は、インクルードパスの先頭から検索されます'
# '#include_next is a language extension'
H924C2DCE9AC7: '#include_next は言語拡張機能です'
# '#line directive requires a positive integer argument'
H2EB091899FF1: '#line ディレクティブは正の整数引数が必要です'
# '#line directive with zero argument is a GNU extension'
H05235496C826: '#line ディレクティブの引数がゼロの場合はGNU拡張機能です'
# '#line number greater than 32767 is incompatible with C++98'
HF9B195DC3866: '#line の行番号が32767より大きい場合、C++98と互換性がありません'
# '#pragma %0(".drectve") has undefined behavior, use #pragma comment(linker, ...) instead'
H6CC89C517043: '#pragma %0(").drectve") は未定義動作です。代わりに #pragma comment(linker, ...) を使用してください'
# '#pragma %0(pop, ...) failed: %1'
H1F44FB9E690A: '#pragma %0(pop, ...) は失敗しました: %1'
# '#pragma align(packed) may not be compatible with objects generated with AIX XL C/C++'
H19CC6269DA45: '#pragma align(packed) はAIX XL C/C++で生成されたオブジェクトと互換性がない可能性があります'
# '#pragma entered here'
H4EB06A1F820E: '#pragma がここに設定されました'
# "#pragma execution_character_set expected '%0'"
H3700F774625D: "#pragma execution_character_set には'%0'が期待されます"
# "#pragma execution_character_set expected 'push' or 'pop'"
HF944C9D4F311: "#pragma execution_character_set には'push'または'pop'が期待されます"
# "#pragma execution_character_set invalid value '%0', only 'UTF-8' is supported"
HF7B9B86DDFE7: "#pragma execution_character_set の無効な値'%0'。サポートされているのは'UTF-8'のみです"
# '#pragma hdrstop filename not supported, /Fp can be used to specify precompiled header filename'
HB20EE88D126A: '#pragma hdrstop でファイル名を指定する機能はサポートされていません。プリコンパイル済みヘッダーファイルの名前を指定するには/Fpオプションを使用してください'
# '#pragma hdrstop not seen while attempting to use precompiled header'
H482D12372789: 'プリコンパイル済みヘッダーを使用しようとしたが、#pragma hdrstop が見つかりませんでした'
# '#pragma once in main file'
H9D36B8727C26: 'メインファイルで #pragma once が使用されています'
# '#pragma options align=reset failed: %0'
H3024180A558C: '#pragma options align=reset の設定に失敗しました: %0'
# '#pragma redefine_extname is applicable to external C declarations only; not applied to %select{function|variable}0 %1'
HAF6CFAD80C5F: '#pragma redefine_extname は外部C宣言のみに適用されます；%select{関数|変数}0 %1 には適用されませんでした'
# '#pragma system_header ignored in main file'
HE58DA574E5C2: 'メインファイルでは #pragma system_header が無視されます'
# '#pragma visibility pop with no matching #pragma visibility push'
H3EDA32C5E985: '対応する #pragma visibility push がないにもかかわらず #pragma visibility pop が使用されました'
# '#pragma visibility push with no matching #pragma visibility pop'
HB15E579A68AB: '対応する #pragma visibility pop がないにもかかわらず #pragma visibility push が使用されました'
# "#pragma warning expected '%0'"
HE762E253E06E: '#pragma warning の後に "%0" が期待されます'
# "#pragma warning expected 'push', 'pop', 'default', 'disable', 'error', 'once', 'suppress', 1, 2, 3, or 4"
HBCB4550F177A: '#pragma warning の後に "push", "pop", "default", "disable", "error", "once", "suppress", 1, 2, 3, または 4 を指定する必要があります'
# '#pragma warning expected a warning number'
HB9A465F10016: '#pragma warning の後に警告番号が期待されます'
# '#pragma warning(push, level) requires a level between 0 and 4'
H99A37FD4A6D8: '#pragma warning(push, level) はレベルを0から4の範囲で指定する必要があります'
# '#warning is a %select{C23|C++23}0 extension'
H0F157EC51CD6: '#warning は%select{C23|C++23}0 の拡張機能です'
# '#warning is incompatible with C standards before C23'
H447994BFEB83: '#warning はC23より前のC言語規格と互換性ありません'
# '#warning is incompatible with C++ standards before C++23'
H42FA898C6606: '#warning はC++23より前のC++言語規格と互換性ありません'
# '%0 %select{parameter|return}1 type is unsupported; support for vector types for this target is introduced in %2'
HDC6BFCFF388E: '%0 の%select{パラメータ|戻り値}1 型はサポートされていません。このターゲットでのベクタータイプのサポートは%2で導入されました'
# "%0 '%1' is acquired exclusively and shared in the same scope"
H7390A9DF88C0: '%0 "%1" は同じスコープ内で排他と共有の両方で取得されています'
# "%0 '%1' is not held on every path through here"
H6674AA570899: '%0 "%1" がすべてのパスで保持されていません'
# "%0 '%1' is still held at the end of function"
HC378A7D8C58E: '%0 "%1" が関数の終了時にまだ保持されています'
# "%0 '%1' must be acquired before '%2'"
H1AA537616F4E: '%0 "%1" は"%2" の前に取得する必要があります'
# "%0 '%2' not managed by '%1'"
H7EC62D1C1AF9: "%0 '%2' は '%1' によって管理されていません"
# "%0 (%1) exceeds limit (%2) in '%3'"
HE73AA4C10244: "%0 (%1) は '%3' の制限 (%2) を超えています"
# '%0 acquired here'
HEA3E3310E736: "'%0' はここですでに取得されています"
# '%0 additional files entered using a total of %1B (%human1B) of space'
HBB08F5A2D9D4: '%0 追加のファイルが、合計 %1B (%human1B) の容量を使用して読み込まれました'
# '%0 and %1%select{ attributes|}2 are not compatible'
H3E0737276230: '%0 と %1%select{属性|}2 は互換性がありません'
# '%0 appears multiple times in clauses on the same declare target directive'
H71D418F6E9B9: "'%0' は同じ declare ターゲット ディレクティブの句で複数回出現しています"
# '%0 applied to an expression is a GNU extension'
HE4B8DDF4E86C: "'%0' を式に適用するのは GNU の拡張機能です"
# '%0 argument must be a constant unsigned integer expression'
HD9AE42B82C9D: "'%0' 引数は定数の符号なし整数式でなければなりません"
# '%0 argument of MTE builtin function must be a null or a pointer (%1 invalid)'
H1FAF65C9963B: 'MTE 内部関数の %0 引数は NULL またはポインタでなければなりません (%1 無効)'
# '%0 argument of MTE builtin function must be a pointer (%1 invalid)'
H0BF1182D2AC8: 'MTE 内部関数の %0 引数はポインタでなければなりません (%1 無効)'
# '%0 argument of MTE builtin function must be an integer type (%1 invalid)'
H2B10B0C97CC4: 'MTE 内部関数の %0 引数は整数型でなければなりません (%1 無効)'
# '%0 argument to %1 must be of vector type'
H61B90BC8950E: "'%1' の '%0' 引数はベクター型でなければなりません"
# '%0 attribute %plural{0:takes no arguments|1:takes one argument|:requires exactly %1 arguments}1'
H8625FD5B48BC: "'%0' 属性 %plural{0:引数を必要としません|1:1つの引数が必要です|:正確に %1 個の引数が必要です}1"
# '%0 attribute applied to non-RVV type %1'
H49243AEFBCDB: "'%0' 属性は非RVV型 '%1' には適用できません"
# '%0 attribute applied to non-SVE type %1'
H7CA8225CCF33: "'%0' 属性は非SVE型 '%1' には適用できません"
# "%0 attribute applies to function parameters only if their type is a reference to a 'scoped_lockable'-annotated type"
H8F04340A3021: "'%0' 属性は、その型が 'scoped_lockable' でアノテーションされた型への参照である場合にのみ関数パラメータに適用されます"
# "%0 attribute argument '%1' not supported on a global variable"
H12B4D27D7798: "'%0' 属性の引数 '%1' はグローバル変数にはサポートされていません"
# '%0 attribute argument is invalid: %select{max must be 0 since min is 0|min must not be greater than max}1'
HD3E478873102: "'%0' 属性の引数は無効です: %select{min が0のため max は0でなければなりません|min は max より大きくはできません}1"
# '%0 attribute argument may only refer to a function parameter of integer type'
H05E563701DF2: "'%0' 属性の引数は整数型の関数パラメータを指すものに限定されます"
# '%0 attribute argument must be a string literal specifying a Swift function name'
H056A97564B83: "'%0' 属性の引数はスイフト関数名を指定する文字列リテラルでなければなりません"
# '%0 attribute argument not supported: %1'
HB519160711B1: '%0属性の引数はサポートされていません：%1'
# "%0 attribute can only be applied in a context annotated with 'capability' attribute"
H9411040D8420: "%0属性は'capability'属性で注釈が付けられたコンテキストでのみ適用できます"
# '%0 attribute can only be applied once per parameter'
H3C2BAB720741: '%0属性はパラメータごとに1回のみ適用できます'
# '%0 attribute can only be applied to a %select{function|method}1 with an error parameter'
H5477D07BA320: '%0属性はエラーパラメータを持つ%select{関数|メソッド}1のみに適用できます'
# '%0 attribute can only be applied to a ARM, HLSL or RISC-V builtin'
H63E9059C2A3F: '%0属性はARM、HLSL、またはRISC-Vの組み込み関数のみに適用できます'
# '%0 attribute can only be applied to instance variables or properties'
H30E90B5958C9: '%0属性はインスタンス変数またはプロパティのみに適用できます'
# "%0 attribute cannot be applied to %select{a function parameter|a variable with 'register' storage class|a 'catch' variable|a bit-field|an enumeration}1"
HD202D2E58321: '%0属性は%select{関数パラメータ|registerストレージクラスの変数|catch変数|ビットフィールド|列挙型}1には適用できません'
# '%0 attribute cannot be applied to %select{methods in protocols|dealloc}1'
HC18046C82752: '%0属性は%select{プロトコル内のメソッド|dealloc}1には適用できません'
# '%0 attribute cannot be applied to a %select{function|method}1 with no parameters'
H9F395B21D226: '%0属性はパラメータのない%select{関数|メソッド}1には適用できません'
# '%0 attribute cannot be applied to a module'
H6CF918E64873: '%0属性はモジュールには適用できません'
# '%0 attribute cannot be applied to a module import'
H3AD0DE140148: '%0属性はモジュールインポートには適用できません'
# '%0 attribute cannot be applied to non-static member functions'
HCA6FA0E6C0E4: '%0属性は静的でないメンバ関数には適用できません'
# '%0 attribute cannot be applied to sizeless type %1'
H60D82BB85EBA: '%0属性はサイズレス型%1には適用できません'
# '%0 attribute cannot be applied to this declaration'
H1A106E97EE94: '%0属性はこの宣言には適用できません'
# '%0 attribute cannot be repeated'
H1FB2864F8926: '%0属性は繰り返し指定できません'
# '%0 attribute cannot be used from %select{a block|an Objective-C function|this context}1'
HFCD2CCA9A22B: '%0属性は%select{ブロック|Objective-C関数|このコンテキスト}1からは使用できません'
# '%0 attribute cannot be used with pointers to members'
H828AE7C76F14: '%0属性はメンバーへのポインタには使用できません'
# "%0 attribute cannot specify more than one 'self:' parameter"
HC2B60D257432: '%0属性は複数の"self:"パラメータを指定できません'
# '%0 attribute does not appear on the first declaration'
HE84901B6BFC0: '%0属性は最初の宣言に付いていません'
# '%0 attribute expression never produces a constant expression'
H6DB854C2324C: '%0属性式は定数式を生成しません'
# "%0 attribute for 'subscript' getter cannot have a 'newValue:' parameter"
HEBB5613EEF15: "'subscript'のgetter用%0属性は'newValue:'パラメータを指定できません"
# "%0 attribute for 'subscript' must %select{be a getter or setter|have at least one parameter|have a 'self:' parameter}1"
H445CA4D5B31B: "'subscript'の%0属性は%select{ゲッタまたはセッタでなければなりません|少なくとも1つのパラメータを指定する必要があります|'self:'パラメータを指定する必要があります}1"
# "%0 attribute for 'subscript' setter cannot have multiple 'newValue:' parameters"
H2C95053B8BED: "'subscript'のセッタ用%0属性は複数の'newValue:'パラメータを指定できません"
# "%0 attribute for 'subscript' setter must have a 'newValue:' parameter"
HD3A5819D09C5: "'subscript'のセッタ用%0属性は'newValue:'パラメータを指定する必要があります"
# "%0 attribute for getter must not have any parameters besides 'self:'"
HA628A2E87201: "%0属性は'getter'には'self:'以外のパラメータを指定できません"
# '%0 attribute for setter must have one parameter for new value'
H349FB00769DE: "'setter'用%0属性は新しい値のための1つのパラメータを指定する必要があります"
# '%0 attribute has invalid identifier for the %select{base|context|parameter}1 name'
HC37D287D1C6D: '%0属性の%select{ベース|コンテキスト|パラメータ}1の名前の識別子が無効です'
# '%0 attribute has no effect on defaulted or deleted functions'
HDFBEF81FB2EF: '%0属性はデフォルトまたは削除済みの関数では効果がありません'
# '%0 attribute ignored'
HCD3BE326728C: '%0属性が無視されました'
# '%0 attribute ignored because Clang does not yet support this attribute signature'
HB0B12C0AB26E: 'Clangはこの属性シグネチャをまだサポートしていないため、%0属性が無視されました'
# '%0 attribute ignored for field of type %1'
HBE46E60BBC6F: '型%1のフィールドに対して%0属性が無視されました'
# '%0 attribute ignored on a non-definition declaration'
H208A7E24C5FA: '非定義宣言に対して%0属性が無視されました'
# '%0 attribute ignored on inline function'
H96102C6ED34D: 'インライン関数に対して%0属性が無視されました'
# '%0 attribute ignored on local class%select{| member}1'
HFF01D57072C2: 'ローカルクラス%select{|メンバー}1に対して%0属性が無視されました'
# '%0 attribute ignored when parsing type'
HD37333D19CA5: '型の解析中に%0属性が無視されました'
# '%0 attribute is deprecated and ignored in %1'
HEFE3D7F726A1: '%0属性は%1で非推奨となり、無視されました'
# '%0 attribute is ignored because %1 is not a function pointer'
H4475E1120012: '%1が関数ポインタでないため、%0属性が無視されました'
# '%0 attribute is ignored because there exists no call expression inside the statement'
H7E65A2DFE3B4: 'ステートメント内に呼び出し式がないため、%0属性が無視されました'
# '%0 attribute is ignored in non-aggregate type %1'
HDDFDF4BAA343: '集約型でない%1型では%0属性が無視されました'
# '%0 attribute is invalid for the implicit this argument'
H2D89A7CAF8E9: '暗黙のthis引数に対して%0属性は無効です'
# '%0 attribute is missing parameter label clause'
HD08320D115DE: '%0属性はパラメータラベル句がありません'
# '%0 attribute is not supported in %select{C|C++|Objective-C}1'
H40645DEA04DB: '%0属性は%select{C|C++|Objective-C}1ではサポートされていません'
# "%0 attribute is not supported on '%1'"
H46128D024C15: "%0属性は'%1'にはサポートされていません"
# '%0 attribute is not supported on targets missing %1; specify an appropriate -march= or -mcpu='
H8B26915B3400: '%0属性は%1をサポートしていないターゲットでは使用できません；適切な-march=または-mcpu=を指定してください'
# '%0 attribute is not yet supported on AIX'
H09BE0575B2ED: '%0属性はAIXではまだサポートされていません'
# '%0 attribute is only allowed on empty statements'
H523B4DCA9F57: '%0属性は空のステートメントのみに使用可能です'
# '%0 attribute is permitted on definitions only'
H7BE8228ED388: '%0属性は定義のみに許可されます'
# "%0 attribute isn't implemented by this Objective-C runtime"
H4540FD7320B4: '%0属性はこのObjective-Cランタイムで実装されていません'
# '%0 attribute may not be used with no-return-attribute functions'
H9936965C5605: '%0属性はno-return-attribute関数と併用できません'
# '%0 attribute may not be used with variadic functions'
HC4348E6FE2CB: '%0属性は可変長関数と併用できません'
# '%0 attribute minimum and maximum arguments are equal'
HCEAC369F8447: '%0属性の最小と最大引数が等しい'
# "%0 attribute must be applied to a %select{function|method}1 annotated with non-'none' attribute 'swift_async'"
H1EED532B31A7: "%0属性は、'swift_async'属性（'none'以外）が付与された%select{function|method}1に適用する必要があります"
# '%0 attribute must be greater than 0'
H2544E0569FB3: '%0属性は0より大きくなければなりません'
# '%0 attribute on entry function does not match the target profile'
H789CC95F4AD2: 'エントリ関数の%0属性はターゲットプロファイルと一致しません'
# '%0 attribute only applies to %select{Objective-C object|pointer|pointer-to-CF-pointer|pointer/reference-to-OSObject-pointer}1 parameters'
H5089073C0897: '%0属性は%select{Objective-Cオブジェクト|ポインタ|CFポインタへのポインタ|OSObjectポインタへのポインタ/リファレンス}1パラメータのみに適用されます'
# '%0 attribute only applies to %select{Objective-C object|pointer|pointer-to-CF-pointer}1 parameters'
HF1529765C253: '%0属性は%select{Objective-Cオブジェクト|ポインタ|CFポインタへのポインタ}1パラメータのみに適用されます'
# '%0 attribute only applies to %select{functions|methods|properties}1 that return %select{an Objective-C object|a pointer|a non-retainable pointer}2'
H0AEFAD59CD2C: '%0属性は、%select{Objective-Cオブジェクト|ポインタ|保持不可ポインタ}2を返す%select{functions|methods|properties}1のみに適用されます'
# '%0 attribute only applies to %select{pointer|integer}1 arguments'
H3971FB6B9374: '%0属性は%select{ポインタ|整数}1型の引数のみに適用されます'
# '%0 attribute only applies to a pointer or reference (%1 is invalid)'
HC8C4E00A6BE4: '%0属性はポインタまたはリファレンスのみに適用されます（%1は無効です）'
# '%0 attribute only applies to return values that are pointers'
H83B4DE3C5663: '%0属性はポインタ型の戻り値にのみ適用されます'
# '%0 attribute only applies to return values that are pointers or references'
HA603B89762A9: '%0属性は、ポインタまたはリファレンス型の戻り値にのみ適用可能です'
# '%0 attribute only applies to%select{| constant}1 pointer arguments'
H1E90BC4B3746: '%0属性は%select{|定数}1ポインタ引数にのみ適用可能です'
# '%0 attribute parameter %1 is negative and will be ignored'
HB94334A9F06D: '%0属性のパラメータ%1は負の値であり無視されます'
# '%0 attribute parameter %1 is out of bounds'
H9C7D1C19F9DB: '%0属性のパラメータ%1は範囲外です'
# '%0 attribute parameter %1 is out of bounds: %plural{0:no parameters to index into|1:can only be 1, since there is one parameter|:must be between 1 and %2}2'
HF05125794562: '%0属性のパラメータ%1は範囲外です：%plural{0:インデックス可能なパラメータがありません|1:1つのみ存在するため1でなければなりません|:1から%2までの間でなければなりません}2'
# '%0 attribute parameter types do not match: parameter %1 of function %2 has type %3, but parameter %4 of function %5 has type %6'
H4FBE5E81E84C: '%0属性のパラメータ型が一致しません: 関数%2のパラメータ%1は型%3ですが、関数%5のパラメータ%4は型%6です'
# '%0 attribute parameters do not match the previous declaration'
HBB1E6D667EEA: '%0属性のパラメータは以前の宣言と一致しません'
# '%0 attribute references function %1, which %plural{0:takes no arguments|1:takes one argument|:takes exactly %2 arguments}2'
HC6916839EF90: '%0属性が参照する関数%1は%plural{0:引数を取らない|1:1つの引数を取る|:正確に%2つの引数を取る}2必要があります'
# '%0 attribute references parameter %1, but the function %2 has only %3 parameters'
H95C6EBBF3D05: '%0属性が参照するパラメータ%1ですが、関数%2には%3つのパラメータしかありません'
# '%0 attribute requires %select{int or bool|an integer constant|a string|an identifier}1'
H4D660FD4970F: '%0属性は%select{intまたはbool|整数定数|文字列|識別子}1を必要とします'
# '%0 attribute requires a %select{positive|non-negative}1 integral compile time constant expression'
H88B2A4A1C6F1: '%0属性は%select{正|非負}1の整数のコンパイル時定数式を必要とします'
# '%0 attribute requires an integer argument which is a constant power of two between %1 and %2 inclusive; provided argument was %3'
HBE3281153430: '%0属性は%1から%2までの整数定数の2のべき乗を必要としますが、指定された値は%3でした'
# "%0 attribute requires arguments whose type is annotated with 'capability' attribute; type here is %1"
H6A637254187D: "%0属性は'type'が'capability'属性で修飾された型を必要としますが、ここでは%1です"
# '%0 attribute requires integer constant between %1 and %2 inclusive'
HEAC447E72E0E: '%0属性は%1から%2までの整数定数を必要とします'
# '%0 attribute requires parameter %1 to be %select{int or bool|an integer constant|a string|an identifier|a constant expression|a builtin function}2'
H410FC41452B2: '%0属性はパラメータ%1が%select{intまたはbool|整数定数|文字列|識別子|定数式|組み込み関数}2である必要があります'
# '%0 attribute requires that both caller and callee functions have a prototype'
H16EEA1808E57: '%0属性は呼び出し元と呼び出される関数の両方にプロトタイプ宣言が必要です'
# '%0 attribute requires that the return value is the result of a function call'
H374EE3F9FB1E: '%0属性は戻り値が関数呼び出しの結果である必要があります'
# '%0 attribute takes at least %1 argument%s1'
HADEF6E200C29: '%0属性には少なくとも%1つの引数が必要です'
# '%0 attribute takes no more than %1 argument%s1'
H19CAD7127F59: '%0属性には最大%1つの引数しか指定できません'
# "%0 attribute with '%1' convention can only be applied to a %select{function|method}2 returning %select{an integral type|a pointer}3"
HD834E8E626F3: "%0属性の'%1'規約は%select{関数|メソッド}2で戻り値が%select{整数型|ポインタ}3である場合にのみ適用可能です"
# "%0 attribute with '%1' convention must have an integral-typed parameter in completion handler at index %2, type here is %3"
HA510BC647385: "%0属性は'%1'規約を持つため、コンプリーションハンドラのインデックス%2で整数型のパラメータが必要です。ここでの型は%3です"
# "%0 attribute with 'nonnull_error' convention can only be applied to a %select{function|method}1 with a completion handler with an error parameter"
HB02ECE112485: "%0の'nonnull_error'規約は、エラーパラメータを持つコンプリーションハンドラを備えた%select{関数|メソッド}1のみに適用できます"
# '%0 attribute without capability arguments can only be applied to non-static methods of a class'
H1A6503974C19: '%0属性は機能引数なしでは、クラスの静的でないメソッドのみに適用できます'
# "%0 attribute without capability arguments refers to 'this', but %1 isn't annotated with 'capability' or 'scoped_lockable' attribute"
H4FEFB6A31DD8: "%0属性（機能引数なし）は'this'を指しますが、%1には'capability'または'scoped_lockable'属性が付与されていません"
# "%0 availability is ignored without a valid 'SDKSettings.json' in the SDK"
H44C1644AD110: "%0の有効性はSDKに有効な'SDKSettings.json'がない場合無視されます"
# '%0 begins here'
H3AEE48765E33: '%0はここから始まります'
# '%0 bridges to %1, not %2'
HF3302ECAA235: '%0は%1に橋渡ししますが%2ではありません'
# "%0 byte order mark detected in '%1', but encoding is not supported"
H4406B8F3C975: "%0 '%1'でバイトオーダーマークが検出されましたが、エンコーディングはサポートされていません"
# '%0 calling convention is not supported %select{for this target|on variadic function|on constructor/destructor|on builtin function}1'
HEDD5B64E1439: '%0コールコンベンションは%select{このターゲットでは|可変長関数では|コンストラクタ/デストラクタでは|組み込み関数では}1サポートされていません'
# '%0 can appear only once in a capture list'
H17CCB4C13684: '%0はキャプチャリストに一度しか現れない必要があります'
# "%0 cannot appear before '::' because it is not a class%select{ or namespace|, namespace, or enumeration}1; did you mean ':'?"
H95866D5EB8E3: "%0は'::'の前に現れないでください。これはクラス%select{または名前空間|、名前空間、または列挙体}1ではないためです。意図したのは':'ですか？"
# '%0 cannot appear here'
H7B57CA319863: '%0はここに現れないでください'
# '%0 cannot appear here, place it after "%select{class|struct|interface|union|enum}1" to apply it to the type declaration'
H2B1210C2EB9F: '%0はここに現れないでください。%select{クラス|構造体|インターフェース|ユニオン|列挙体}1の後に配置して、型宣言に適用してください'
# '%0 cannot be a template'
H09B919FC579B: '%0はテンプレートにはできません'
# '%0 cannot be applied to a module'
HED10CE4A1D68: '%0はモジュールには適用できません'
# '%0 cannot be applied to a module import'
HE5DD1D7C816C: '%0はモジュールインポートには適用できません'
# '%0 cannot be captured because it does not have automatic storage duration'
HBA5ABB384993: '%0は自動ストレージ期間を持っていないためキャプチャできません'
# "%0 cannot be declared 'weak_import' because its definition has been provided"
HE0A69210AAA7: "%0は定義が提供されているため'weak_import'として宣言できません"
# '%0 cannot be declared consteval'
H16F780D20CBE: "%0は'consteval'として宣言できません"
# '%0 cannot be declared inside a namespace'
H52C308DDDEAD: '%0は名前空間内で宣言できません'
# '%0 cannot be declared static in global scope'
HE95F0FB30315: '%0 はグローバル スコープで static として宣言できません'
# '%0 cannot be defined in a condition'
H4D213A54365F: '%0 は条件内では定義できません'
# '%0 cannot be defined in a parameter type'
H73A9723882B3: '%0 はパラメータ型内では定義できません'
# '%0 cannot be defined in a type alias template'
H481A328DC270: '%0 はタイプエイリアス テンプレート内では定義できません'
# '%0 cannot be defined in a type specifier'
H66CFEB606651: '%0 はタイプ修飾子内では定義できません'
# '%0 cannot be defined in an enumeration'
H9015777D8EDA: '%0 は列挙型内では定義できません'
# '%0 cannot be defined in the result type of a function'
HBCF321DF1229: '%0 は関数の戻り値型内では定義できません'
# '%0 cannot be specialized%select{|: %2}1'
H2F24480223D6: '%0 は特化できません%select{|: %2}1'
# '%0 cannot be the name of a parameter'
H86909FCB5AFA: '%0 はパラメータの名前に使用できません'
# '%0 cannot be the name of a variable or data member'
H97536A002E4D: '%0 は変数またはデータメンバの名前に使用できません'
# '%0 cannot be used as the type of a kernel parameter'
H4649232301DD: '%0 はカーネル パラメータの型として使用できません'
# '%0 cannot bridge to %1'
H223FE9046675: '%0 は %1 に橋渡しできません'
# '%0 cannot have a dependent return type; use %1 instead'
H622C863D5758: '%0 は依存する戻り型を使用できません; %1 を代わりに使用してください'
# '%0 cannot take a dependent type as first parameter; use %1 instead'
HA474A1ABAD69: '%0 は最初のパラメータとして依存する型を受け付けません; %1 を代わりに使用してください'
# '%0 cannot take a dependent type as first parameter; use size_t (%1) instead'
H54AA7CDA647F: '%0 は最初のパラメータとして依存する型を受け付けません; size_t (%1) を代わりに使用してください'
# "%0 cannot use 'super' because it is a root class"
HCB7FBC7D0FE7: "%0 はルートクラスであるため 'super' を使用できません"
# '%0 causes a section type conflict with %1'
HC2A4EF19BEEF: '%0 は %1 とセクション型の競合を引き起こします'
# '%0 clause previously used here'
HB8E770744C3C: '%0 句は以前ここで使用されました'
# '%0 clause should not be followed by arguments; tokens will be ignored'
HC180595F601D: '%0 句は引数を伴ってはいけません; トークンは無視されます'
# '%0 command failed due to signal (use -v to see invocation)'
H6D5905ABD1C8: '%0 コマンドはシグナルにより失敗しました（-v オプションで実行内容を確認してください）'
# '%0 command failed with exit code %1 (use -v to see invocation)'
H4949FF66B370: '%0 コマンドが終了コード %1 で失敗しました（-v オプションで詳細を表示）'
# '%0 currently has no effect on a using declaration'
HF72F1D74D1D1: '%0 現在、using宣言には効果がありません'
# '%0 declared as a reference to a reference'
H6B7D1478B098: '%0 は参照の参照として宣言されています'
# '%0 declared here'
HF5B76F9106FA: '%0 はここで宣言されています'
# '%0 defined here'
HAF9360C4877D: '%0 はここで定義されています'
# "%0 differs in AST file '%1' vs. current file"
H2B8E15EA63E3: "ASTファイル '%1' と現在のファイルで %0 が異なっています"
# '%0 dimension is outside the allowed range [1, %1]'
H082ED204EAD0: '%0 次元は許可範囲 [1, %1] の外です'
# '%0 does not have a member named %1'
H9A87A68C56D5: '%0 は名前 %1 のメンバーを持っていません'
# '%0 does not have a member named %1; did you mean %2?'
HB35AA56437F0: '%0 は名前 %1 のメンバーを持っていません；%2 の意図でしたでしょうか？'
# '%0 does not identify a valid pointer authentication key for the current target'
H788DB99BF41E: '%0 は現在のターゲット用の有効なポインタ認証キーを指定していません'
# '%0 does not name a template but is followed by template arguments'
H33B12988518D: '%0 はテンプレートを指す名前ではありませんが、テンプレート引数が続きます'
# '%0 does not name a template but is followed by template arguments; did you mean %1?'
H4461F93F60D6: '%0 はテンプレートを指す名前ではありませんが、テンプレート引数が続きます；%1 の意図でしたでしょうか？'
# '%0 does not point into a class'
H54F4142F16BD: '%0 はクラスを指すものではありません'
# '%0 does not refer to a type name in pseudo-destructor expression; expected the name of type %1'
H439E7BF75B12: '疑似デストラクタ式で %0 は型名を指していません；型 %1 の名前が期待されます'
# '%0 does not refer to a value'
H21D124F292F8: '%0 は値を指していません'
# '%0 does not refer to the name of a parameter pack'
H84CFFC360255: '%0 はパラメータパックの名前を指していません'
# '%0 does not refer to the name of a parameter pack; did you mean %1?'
H833E3DFEF469: '%0 はパラメータパックの名前を指していません；%1 の意図でしたでしょうか？'
# "%0 does not support the '%1' %select{type qualifier|storage class specifier}2"
H0775C84F5711: "「%0」は '%1' %select{型修飾子|ストレージクラス仕様}2 をサポートしていません"
# "%0 does not support the option '%1'"
HCC61DEFC8375: '%0 はオプション "%1" をサポートしていません'
# '%0 has C-linkage specified, but returns incomplete type %1 which could be incompatible with C'
H36CF04C5AD21: '%0 はCリンケージが指定されていますが、不完全な型 %1 を返し、Cとの互換性がなくなる可能性があります'
# '%0 has C-linkage specified, but returns user-defined type %1 which is incompatible with C'
H33D15C91E278: '%0 はC言語のリンケージが指定されていますが、Cと互換性のないユーザ定義型 %1 を返却します'
# '%0 has a non-throwing exception specification but can still throw'
H115C08CCD253: '%0 は例外投出不可指定をしていますが、それでも例外を投出する可能性があります'
# '%0 has been explicitly marked %select{unavailable|deleted|deprecated}1 here'
H8BC49D6916A0: '%0 はここで %select{利用不可|削除済み|非推奨}1 のマークが明示的に設定されています'
# '%0 has been marked as being introduced in %1 %2 %select{|in %5 environment }4here, but the deployment target is %1 %3%select{| %6 environment }4'
H0D47117119FF: '%0 はここで %1 %2 %select{|%5環境で}4 引入されたとマークされていますが、展開ターゲットは %1 %3%select{| %6環境}4 です'
# "%0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%select{no super class|super class with type %5}4|instance variable '%4' access control is %select{|@private|@protected|@public|@package}5}3"
H8AC2F2F00B17: "%0 の定義が異なるモジュール間で異なります; 最初の違いは %select{モジュール '%2' の定義|ここに定義されています}1 で、%select{%select{スーパークラスなし|スーパークラスの型 %5}4|インスタンス変数 '%4' のアクセス制御は %select{なし|@private|@protected|@public|@package}5}3 が見つかりました"
# '%0 has lower precedence than %1; %1 will be evaluated first'
HFFF20BD3A51A: '%0 の優先度は%1より低いです；%1が先に評価されます'
# '%0 has no out-of-line virtual method definitions; its vtable will be emitted in every translation unit'
HF80DD309C805: '%0 は外付け仮想メソッド定義を持っていません；そのvtableはすべての翻訳単位で生成されます'
# '%0 has unknown return type; cast the call to its declared return type'
H98622C79AEFA: '%0 の戻り値型が不明確です；宣言された戻り型にキャストしてください'
# '%0 has unknown type, which is not supported for this kind of declaration'
H62292154D971: '%0 の型が不明確で、この種の宣言ではサポートされていません'
# '%0 has unknown type; cast it to its declared type to use it'
HB47BA1F1A811: '%0 の型が不明確です；宣言された型にキャストしてから使用してください'
# '%0 has virtual functions but non-virtual destructor'
HE7971ACC4D33: '%0 は仮想関数を持ちますが破棄関数が非仮想です'
# '%0 in capture list does not name a variable'
HDBFB52EAD640: 'キャプチャリストの%0 は変数名ではありません'
# '%0 is a %select{struct|interface|union|class|enum}1 here'
H03376E721EF2: '%0 はここで %select{構造体|インターフェース|共用体|クラス|列挙型}1 です'
# '%0 is a builtin with type %1'
HF5D497B12074: '%0 は型%1を持つ組み込み関数です'
# '%0 is a core feature in %select{OpenCL C|C++ for OpenCL}1 version %2 but not supported on this target'
HB2B1D8E45B2F: '%0 は%select{OpenCL C|OpenCL用C++}1 %2バージョンのコア機能ですが、このターゲットではサポートされていません'
# '%0 is a large (%1 bytes) pass-by-value argument; pass it by reference instead ?'
H3328D1D6C300: '%0 は大容量(%1バイト)の値渡し引数です；参照渡しに変更してください ?'
# '%0 is a reserved attribute identifier'
HA23BACAA2167: '%0 は予約済みの属性識別子です'
# '%0 is a reserved name for a module'
H539795173149: '%0 はモジュールの予約名です'
# '%0 is an %select{unsafe pointer used for buffer access|unsafe buffer that does not perform bounds checks}1'
HD2DA3F5D5287: '%0 は %select{バッファアクセス用の危険なポインタ|境界チェックをしない危険なバッファ}1 です'
# '%0 is an immediate %select{function|constructor}5 because %select{its body|the%select{| default}7 initializer of %8}6 %select{evaluates the address of %select{an immediate|a consteval}2 function %1|contains a call to %select{an immediate|a consteval}2 %select{function|constructor}4 %1 and that call is not a constant expression}3'
H2D11120EB0CD: '%0 は%select{関数|コンストラクタ}5 として即時扱いされます。%select{その本体|the%select{|デフォルト}7 初期化子 %8 の}6 %select{%select{即時|consteval}2 関数 %1 のアドレスを評価する|%select{即時|consteval}2 %select{関数|コンストラクタ}4 %1 の呼び出しを含んでおり、その呼び出しは定数式ではありません}3 ためです'
# '%0 is an implicit parameter'
H18B31C3BE2ED: '%0 は暗黙のパラメータです'
# '%0 is an incomplete type'
H23B2652D4493: '%0 は未完成な型です'
# '%0 is an invalid name for a module'
H04BC4C58E825: '%0 はモジュールの無効な名前です'
# "%0 is currently enabled, but was not in the AST file '%1'"
H4A72404ECC3D: "%0 は現在有効ですが、AST ファイル '%1' では無効でした"
# '%0 is defined here; did you mean %1?'
H3B788FE6A551: '%0 はここに定義されています; %1 の意味でないですか?'
# '%0 is deprecated'
HFB3435CCEF09: '%0 は非推奨です'
# '%0 is deprecated: %1'
HBBBFE1910250: '%0 は非推奨です: %1'
# '%0 is expected to be a non-type template, but instantiated to a %select{class|type alias}1 template'
H0D2CA33F6096: '%0 は非型テンプレートが期待されましたが、%select{クラス|型エイリアス}1 テンプレートにインスタンス化されました'
# '%0 is incompatible with selectors that return a %select{struct|union|vector}1 type'
HF29FF6DC9511: '%0 は%select{構造体|共用体|ベクター}1 型を返すセレクタと互換性ありません'
# '%0 is incomplete'
HE1EB0B2A5FDF: '%0 は未完成です'
# "%0 is missing exception specification '%1'"
HFEFEB7B90D08: "%0 は例外指定 '%1' を欠いています"
# '%0 is no longer a pack expansion but a pack indexing type; add a name to specify a pack expansion'
H52ECBB1B9A17: '%0 はパック展開ではなくパックインデックス型になりました; パック展開を指定するには名前を追加してください'
# '%0 is not a class type'
H5598919CD04A: '%0 はクラス型ではありません'
# '%0 is not a class%select{ or namespace|, namespace, or enumeration}1'
H6791F56D81BD: '%0 はクラス%select{または名前空間|、名前空間、または列挙体}1 ではありません'
# '%0 is not a direct base of %1, cannot inherit constructors'
H9090F9B02C3F: '%0 は%1 の直接の基底クラスではありません; コンストラクタを継承できません'
# '%0 is not a global variable, static local variable or static data member'
HC570BF566E38: '%0 はグローバル変数、静的ローカル変数、または静的データメンバではありません'
# '%0 is not a global variable, static local variable or static data member; did you mean %1'
H32A3026BA924: '%0 はグローバル変数、静的ローカル変数、または静的データメンバではありません; %1 の意味でないですか'
# '%0 is not a recognized builtin%select{|; consider including <intrin.h> to access non-builtin intrinsics}1'
HB8FF0E17F733: '%0 は認識された組み込みではありません%select{|; <intrin.h> を含めることで非組み込みイントリンシックにアクセスできます}1'
# '%0 is not a structural type because it has a %select{non-static data member|base class}1 of non-structural type %2'
HF393BE38CC50: '%0は構造的型ではありません。非構造的型%2の%select{非静的データメンバ|基底クラス}1を持っているため'
# '%0 is not a structural type because it has a %select{non-static data member|base class}1 that is not public'
H7772D2C2337B: '%0は構造的型ではありません。%select{非静的データメンバ|基底クラス}1が公開されていないため'
# '%0 is not a structural type because it has a mutable non-static data member'
HF8F430793986: '%0は構造的型ではありません。ミュータブルな非静的データメンバを持っているため'
# '%0 is not a structural type because it has a non-static data member of rvalue reference type'
H3FC432618326: '%0は構造的型ではありません。非静的データメンバがrvalue参照型であるため'
# '%0 is not a valid SYCL kernel name type; a non-union class type is required'
H0BC00170201E: '%0は有効なSYCLカーネル名型ではありません；非ユニオンクラス型が必要です'
# '%0 is not a valid literal type for NSNumber'
H994AF662B0D5: '%0はNSNumberのリテラル型ではありません'
# '%0 is not a valid property name (accessing an object of type %1)'
HA0D8AFF85380: '%0は有効なプロパティ名ではありません（%1型のオブジェクトをアクセスしています）'
# "%0 is not an availability stage; use 'introduced', 'deprecated', or 'obsoleted'"
H5FED6488A0D9: '%0は利用可能なステージではありません；"introduced", "deprecated", または"obsoleted"を使用してください'
# '%0 is not an enumerated type'
H7F1BAB170C64: '%0は列挙型ではありません'
# '%0 is not defined, but forward declared here; conversion would be valid if it was derived from %1'
H176B6CEA9A74: '%0は定義されていませんが、ここで前方宣言されています；%1を基底としている場合に変換が可能です'
# '%0 is not defined, evaluates to 0'
HBDB44DE505CF: '%0は定義されていません；評価結果は0になります'
# '%0 is not literal because it has a non-trivial destructor'
HC9535B0A1692: '%0はリテラル型ではありません。非自明なデストラクタを持っているため'
# '%0 is not literal because it has a user-provided destructor'
H35BFFB66B4EF: '%0はリテラル型ではありません。ユーザー提供のデストラクタを持っているため'
# '%0 is not literal because it has base class %1 of non-literal type'
H41CFD9851FA8: '%0はリテラル型ではありません。非リテラル型の基底クラス%1を持っているため'
# '%0 is not literal because it has data member %1 of %select{non-literal|volatile}3 type %2'
H39754ECC239F: '%0はリテラル型ではありません。%select{非リテラル|volatile}3型%2のデータメンバ%1を持っているため'
# '%0 is not literal because it is not an aggregate and has no constexpr constructors other than copy or move constructors'
HD7160BA9A570: '%0はリテラル型ではありません。アグリゲートでなく、constexprコンストラクタが存在しません（コピーまたはムーブコンストラクタを除く）'
# '%0 is not literal because its destructor is not constexpr'
HEAC0F5C26B7E: '%0はリテラル型ではありません。デストラクタがconstexprでないため'
# '%0 is not polymorphic'
H67C71DB95F18: '%0はポリモーフィックではありません'
# '%0 is not supported on HVX %1'
H7927AD732A30: '%0はHVX %1ではサポートされていません'
# '%0 is not supported on this target'
H331CCFBB5DA0: '%0はこのターゲットではサポートされていません'
# '%0 is not supported with -fembed-bitcode'
H580226EF44DA: '%0 は -fembed-bitcode と組み合わせて使用できません'
# '%0 is not virtual and cannot be declared pure'
HFCE20933CC31: '%0 は仮想関数ではありませんので pure として宣言できません'
# '%0 is only available %select{|in %4 environment }3on %1 %2 or newer'
H1926B8ADA9BD: '%0 は %1 %2 またはそれ以降の %select{|%4環境の}3中でのみ利用可能です'
# '%0 is only supported when \'-mrvv-vector-bits=<bits>\' is specified with a value of "zvl" or a power 2 in the range [64,65536]'
H714177E08C3D: "%0 を使用するには '-mrvv-vector-bits=<bits>' で zvl または [64,65536] の範囲の2のべき乗値を指定する必要があります"
# "%0 is only supported when '-msve-vector-bits=<bits>' is specified with a value of 128, 256, 512, 1024 or 2048"
H5256E220BB0F: "%0 を使用するには '-msve-vector-bits=<bits>' で 128, 256, 512, 1024 または 2048 の値を指定する必要があります"
# "%0 is required to declare the member 'unhandled_exception()'"
H72F7248FC774: "%0 はメンバー 'unhandled_exception()' を宣言する必要があります"
# "%0 is required to declare the member 'unhandled_exception()' when exceptions are enabled"
HA2F4C1A14DF7: "%0 は例外処理が有効な場合、メンバー 'unhandled_exception()' を宣言する必要があります"
# "%0 is required to have a non-throwing noexcept specification when the promise type declares 'get_return_object_on_allocation_failure()'"
H267685A6E8FC: "%0 は promise 型が 'get_return_object_on_allocation_failure()' を宣言する場合、noexcept の非投出手続き仕様を指定する必要があります"
# '%0 is unavailable'
HD9DCE040D90B: '%0 は利用できません'
# '%0 is unavailable in ARC'
H5A0EF77D1311: '%0 は ARC で利用できません'
# '%0 is unavailable: %1'
H3F1A4B4C46AF: '%0 は利用不可: %1'
# '%0 is unsupported with LoongArch linker relaxation (-mrelax)'
H711EE6DE37A1: '%0 は LoongArch リンカ緩和オプション (-mrelax) と互換性ありません'
# '%0 is unsupported with RISC-V linker relaxation (-mrelax)'
H7184497D9FBD: '%0 は RISC-V リンカ緩和オプション (-mrelax) と互換性ありません'
# '%0 is used as a header guard here, followed by #define of a different macro'
HD1F7F8F6EEEE: '%0 はここでのヘッダガードとして使用され、後に異なるマクロの #define が定義されています'
# "%0 layout not recognized. Must be a non-polymorphic class type with no bases and two fields: a 'const E *' and either another 'const E *' or a 'std::size_t'"
HED28B381356F: "%0 レイアウトが認識できません。非ポリモーフィックなクラス型で、ベースクラスを持たず、'const E *' と 'const E *' または 'std::size_t' の2つのフィールドを持つ必要があります"
# '%0 macro redefined'
H137240D8643E: '%0 マクロが再定義されています'
# "%0 managed by '%1' is '%3' instead of '%2'"
H2BF1BAAD2D9C: "%0 は '%1' によって '%3' として管理されており、'%2' である必要があります"
# "%0 marked 'override' but does not override any member functions"
H4E355023D40F: "%0 は 'override' が指定されていますが、オーバーライドするメンバー関数がありません"
# '%0 may be deprecated because the receiver type is unknown'
H33FCAE6FB142: '%0 はレシーバータイプが不明のため廃止対象になる可能性があります'
# '%0 may be duplicated when built into a shared library: it is mutable, has hidden visibility, and external linkage'
H5AAA1A09F587: '%0 は共有ライブラリにビルド時に重複する可能性があります: 変更可能な変数で、hidden 可視性かつ外部リンク指定がされています'
# '%0 may be unavailable because the receiver type is unknown'
H5F639AF749BC: '%0は、受信者型が不明のため使用できない可能性があります'
# '%0 may not be nested in a struct due to flexible array member'
H56A636FEC1E0: '%0は、flexible array memberのためstruct内ではネストできません'
# '%0 may not be used as an array element due to flexible array member'
H4CE3DAD3A8F2: '%0は、flexible array memberのため配列要素として使用できません'
# '%0 may not intend to support class template argument deduction'
H3F1AA6022CE0: '%0は、適切なテンプレート引数を持つclass templateからのインスタンス化を必要としているため、template argument deductionを意図していない可能性があります'
# '%0 may not respond to %1'
HE863B7C4E09E: '%0は%1に応答できません'
# '%0 must be explicitly converted to %1; use %select{%objcclass2|%objcinstance2}3 method for this conversion'
H7B5D141884DB: '%0は%1に明示的に変換する必要があります。この変換には%select{%objcclass2|%objcinstance2}3メソッドを使用してください'
# '%0 must be name of an Objective-C class to be able to convert %1 to %2'
HF9706A398326: '%0は、%1を%2に変換するためにはObjective-Cクラスの名前でなければなりません'
# '%0 must be specified on definition if it is specified on any declaration'
H593384CDC4FD: '%0は、宣言のどこかで指定されている場合、定義でも指定する必要があります'
# '%0 must be used within a preprocessing directive'
HAA08D126AF16: '%0はプリプロセスディレクティブ内で使用する必要があります'
# '%0 must have at least one parameter'
H2488FE597801: '%0は少なくとも1つのパラメータを必要とします'
# "%0 must not appear in both clauses 'to' and 'link'"
HC3403F617C92: '%0は「to」句と「link」句の両方に出現してはなりません'
# '%0 must return type %1'
H561F31EBFB23: '%0は%1型を返す必要があります'
# '%0 needs target feature %1'
H5236119E54CB: '%0はターゲット機能%1を必要とします'
# '%0 needs to be instantiated from a class template with proper template arguments'
H6CDDF6DD374E: '%0は適切なテンプレート引数を持つclass templateからのインスタンス化を必要とします'
# '%0 needs to have exactly %1 template parameters'
HD0C675913338: '%0は正確に%1つのテンプレートパラメータを必要とします'
# '%0 only allowed in __except block or filter expression'
H5D665A901228: '%0は__exceptブロックまたはfilter式内でしか使用できません'
# '%0 only allowed in __except filter expression'
H6152837B25ED: '%0は__except filter式内でしか使用できません'
# '%0 only allowed in __finally block'
H4B415A24C89A: '%0は__finallyブロック内でしか使用できません'
# '%0 only applies to pointer types; type here is %1'
HAB4FE8662D8D: '%0はポインタ型のみに適用されます。ここで使用されている型は%1です'
# "%0 overrides a destructor but is not marked 'override'"
HEE01F5122D86: "%0 は 'override' 修飾子が付いていないにもかかわらずデストラクタをオーバーライドしています"
# "%0 overrides a member function but is not marked 'override'"
H7449F9821D96: "%0 は 'override' 修飾子が付いていないにもかかわらずメンバ関数をオーバーライドしています"
# "%0 parameter marked 'called_once' is called twice"
H9B0F1F204498: "%0 パラメータは 'called_once' 修飾子が付いていますが、2回呼び出されています"
# "%0 parameter marked 'called_once' is never %select{used|called}1 when %select{taking true branch|taking false branch|handling this case|none of the cases applies|entering the loop|skipping the loop|taking one of the branches}2"
HBB87206669E4: "%0 パラメータが 'called_once' でマークされていますが、%select{使用|呼び出され}1 されません。%select{真の分岐を取るとき|偽の分岐を取るとき|このケースを処理するとき|どのケースにも該当しないとき|ループに進入するとき|ループをスキップするとき|いずれかの分岐を取るとき}2"
# "%0 redeclared with '%1' access"
H6D05457F8E04: "%0 を '%1' アクセス修飾子で再宣言しました"
# '%0 released here'
H2E4FF4BE13D1: '%0 はここで解放されました'
# "%0 requires %1 type support, but ABI '%2' does not support it"
H03B0999A3C3B: '%0 は %1 型のサポートを必要としますが、ABI "%2" ではサポートされていません'
# "%0 requires %select{|%2 bit size}1 %3 %select{|return }4type support, but target '%5' does not support it"
HE937C1210F37: '%0 は %select{|%2 ビットサイズ}1 %3 %select{|戻り値 }4型のサポートが必要ですが、ターゲット "%5" ではサポートされていません'
# '%0 requires HVX, use -mhvx/-mhvx= to enable it'
H9F7369C63134: '%0 は HVX が必要です。有効にするには -mhvx/-mhvx= オプションを使用してください'
# "%0 requires debug info. Use %1 or debug options that enable debugger's stepping function; option ignored"
H985F4F582A8C: '%0 はデバッグ情報が必要です。%1 オプションまたはデバッガーのステップ実行機能を有効にするデバッグオプションを使用してください；オプションが無視されました'
# '%0 requires more than 1 template argument; provide the remaining arguments explicitly to use it here'
H33A930D763B0: '%0 は1つより多くのテンプレート引数が必要です。ここで使用するには、残りの引数を明示的に提供してください'
# '%0 returns a reference'
H81B0F21DCC91: '%0 はリファレンスを返します'
# '%0 should be declared prior to the call site%select{| or in %2| or in an associated namespace of one of its arguments}1'
H80A1DB32BBA2: '%0 は呼び出しサイトの前に宣言する必要があります%select{|または %2 内|またはその引数の関連する名前空間内}1'
# "%0 should not return a null pointer unless it is declared 'throw()'%select{| or 'noexcept'}1"
HD6330A6C968B: '%0 は "throw()" %select{|または "noexcept"}1 として宣言されていない限り、nullポインタを返してはいけません'
# '%0 size too large'
HC155B92BBDDE: '%0 サイズが大きすぎます'
# '%0 specified here'
H2793186BA8E0: '%0 はここに指定されています'
# '%0 takes type size_t (%1) as first parameter'
H994A3A678C5B: '%0 の最初のパラメータは size_t (%1) 型です'
# '%0 template must have at least two parameters'
HC33714C2985B: '%0 テンプレートは少なくとも2つのパラメータを必要とします'
# '%0 type %1 not found; include the base header with -finclude-default-header'
HB4775AA2AD70: '%0 型 %1 が見つかりません；-finclude-default-header オプションでベースヘッダーを含めてください'
# '%0 type was not found; include <coroutine> before defining a coroutine'
H89DE99125E80: "'%0' タイプが見つかりません; コルーチンを定義する前に <coroutine> を含めてください"
# '%0 used as the name of the previous parameter rather than as part of the selector'
HAA86630AF908: '%0 はセレクタの一部としてではなく、前のパラメータの名前として使用されています'
# '%0 used in array declarator outside of function prototype'
H667299EFB745: '%0 は関数プロトタイプ外の配列宣言子で使用されています'
# '%0 used in declare target directive is not a variable or a function name'
H56AD7716F4DF: '%0 は宣言ターゲットディレクティブで変数または関数名ではありません'
# '%0 used in non-outermost array type derivation'
H7D46A3E1139D: '%0 は外側の配列型導出以外で使用されています'
# '%0 variable cannot be %1'
H88684475A953: '%0 変数は %1 にできません'
# "%0 variable cannot be in a %1 clause in '#pragma omp %2' directive"
HF56ADE356ADE: "'#pragma omp %2' ディレクティブの %1 クラウス内で %0 変数は使用できません"
# '%0 variable must be %1'
H2457271DFCB0: '%0 変数は %1 でなければなりません'
# "%0 was %select{disabled|enabled}1 in AST file '%3' but is currently %select{disabled|enabled}2"
HC0632CD5FF96: "%0 は AST ファイル '%3' で %select{無効化|有効化}1 されていましたが、現在は %select{無効化|有効化}2 されています"
# '%0 was deserialized'
H39D399F5AEF8: '%0 は逆シリアル化されました'
# '%0 was marked unused but was used'
H40B831F8FB51: '%0 は未使用とマークされていましたが使用されました'
# '%0%select{ attribute|}1 cannot be applied to a base specifier'
H11035A3B905C: '%0%select{ 属性|}1 はベース指定子に適用できません'
# '%0%select{ attribute|}1 cannot be applied to a declaration'
H127063747A92: '%0%select{ 属性|}1 は宣言に適用できません'
# '%0%select{ attribute|}1 cannot be applied to a statement'
H1C3F2544F25A: '%0%select{ 属性|}1 は文に適用できません'
# '%0%select{ attribute|}1 cannot be applied to types'
H96D80DF95948: '%0%select{ 属性|}1 は型に適用できません'
# '%0%select{ attribute|}1 only applies to %2'
H45C12381C633: '%0%select{ 属性|}1 は %2 のみに適用されます'
# '%0%select{ attribute|}1 only applies to %select{functions|unions|variables and functions|functions and methods|functions, methods and blocks|functions, methods, and parameters|variables|variables and fields|variables, data members and tag types|types and namespaces|variables, functions and classes|kernel functions|non-K&R-style functions|for loop statements|virtual functions|parameters and implicit object parameters|non-member functions|functions, classes, or enumerations|classes|typedefs}2'
H9D37840D3CB2: '%0%select{ 属性|}1 は %select{関数|ユニオン|変数と関数|関数とメソッド|関数、メソッド、ブロック|関数、メソッド、パラメータ|変数|変数とフィールド|変数、データメンバ、タグ型|型と名前空間|変数、関数、クラス|カーネル関数|K&Rスタイル以外の関数|for文ステートメント|仮想関数|パラメータとインプリシットオブジェクトパラメータ|メンバー関数でない関数|関数、クラス、または列挙型|クラス|typedef}2 のみに適用されます'
# "%0%select{| following the 'template' keyword}1 cannot refer to a dependent template"
HA18DA36B7236: "%0%select{| 'template' キーワードの後に続く}1 は依存テンプレートを指すことはできません"
# "%0%select{| following the 'template' keyword}1 does not refer to a template"
HCADF8F759262: "%0%select{| 'template' キーワードの後に続く}1 はテンプレートを指していません"
# "%0: '%1' input unused in cpp mode"
HF14789F9D841: "%0: '%1' 入力はcppモードで未使用です"
# "%0: '%1' input unused%select{ when '%3' is present|}2"
HA6B5E8785AC8: "%0: '%1' 入力は%select{'%3'が存在する場合に未使用|}2"
# "%0: 'get_return_object_on_allocation_failure()' must be a static member function"
HB26892211ABD: "%0: 'get_return_object_on_allocation_failure()'は静的メンバ関数でなければなりません"
# "%0: previously preprocessed input%select{ unused when '%2' is present|}1"
H1EB52EB9DA3B: "%0: 事前処理済み入力%select{'%2'が存在する場合に未使用|}1"
# "%0; allow reordering by specifying '#pragma clang loop vectorize(enable)' before the loop or by providing the compiler option '-ffast-math'"
H50F1AE498158: "%0; ループ前に'#pragma clang loop vectorize(enable)'を指定するか'-ffast-math'オプションを指定して再順序化を許可してください"
# "%0; allow reordering by specifying '#pragma clang loop vectorize(enable)' before the loop; if the arrays will always be independent, specify '#pragma clang loop vectorize(assume_safety)' before the loop or provide the '__restrict__' qualifier with the independent array arguments -- erroneous results will occur if these options are incorrectly applied"
H696063533F0E: "%0; ループ前に'#pragma clang loop vectorize(enable)'を指定してください。配列が常に独立している場合は'#pragma clang loop vectorize(assume_safety)'を指定するか独立した配列引数に'__restrict__'修飾子を付けてください。これらのオプションを誤用すると誤った結果が発生します"
# '%0B (%human0B) in local locations, %1B (%human1B) in locations loaded from AST files, for a total of %2B (%human2B) (%3%% of available space)'
H9B3C5907D274: 'ローカル領域で%0B (%human0B)、ASTファイルからロードされた領域で%1B (%human1B)、合計%2B (%human2B) (%3%%の使用可能領域)'
# '%1 %0 is hidden by a non-type declaration of %0 here'
HC05432050C69: '%1 %0 はここでの非型宣言の%0によって隠蔽されています'
# '%1 is a %select{private|protected}0 member of %3'
H4162E2E8D4C1: '%1 は%3 の%select{プライベート|プロテクテッド}0 メンバです'
# '%2 defined as %select{a struct|an interface|a class}0%select{| template}1 here but previously declared as %select{a struct|an interface|a class}3%select{| template}1; this is valid, but may result in linker errors under the Microsoft C++ ABI'
H65DDB76661CA: '%2 はここでは%select{構造体|インターフェース|クラス}0%select{|テンプレート}1 として定義されましたが、以前は%select{構造体|インターフェース|クラス}3%select{|テンプレート}1 として宣言されていました。これは有効ですが、Microsoft C++ ABIではリンカーエラーが発生する可能性があります'
# '%diff{$ and $ are not pointers to compatible types|pointers to incompatible types}0,1'
HE4DF3395C0FE: '%diff{ポインタの互換性のない型$と$|互換性のないポインタ型}0,1 です'
# '%diff{promoted type $ of K&R function parameter is not compatible with the parameter type $|promoted type of K&R function parameter is not compatible with parameter type}0,1 declared in a previous prototype'
HBE91EA4F0CCD: '%diff{K&R関数パラメータのプロモート型$が、事前のプロトタイプで宣言されたパラメータ型$と互換性ありません|K&R関数パラメータのプロモート型は事前のプロトタイプで宣言されたパラメータ型と互換性ありません}0,1'
# '%diff{return type $ must match previous return type $|return type must match previous return type}0,1 when %select{block literal|lambda expression}2 has unspecified explicit return type'
H503B0717AF47: '%diff{戻り値の型$は、前の戻り値の型$と一致する必要があります|戻り値の型は前の戻り値の型と一致する必要があります}0,1 %select{ブロックリテラル|ラムダ式}2が明示的な戻り値型を指定していない場合'
# "%ordinal0 argument must be a %select{|scalar|vector|matrix|vector of|scalar or vector of}1%plural{[2,3]:%plural{0:|:%plural{0:|:,}2}3|:}1%plural{0:|: }1%select{|integer|signed integer|unsigned integer|'int'|pointer to a valid matrix element}2%plural{0:|: }2%plural{0:|:%plural{0:|:or }2}3%select{|floating-point}3%plural{0:|: }3%plural{[0,3]:type|:types}1 (was %4)"
HEE73BAE75429: "%ordinal0 引数は%select{|スカラ|ベクタ|マトリクス|ベクタの|スカラまたはベクタの}1%plural{[2,3]:%plural{0:|:%plural{0:|:,}2}3|:}1%plural{0:|: }1%select{|整数|符号付き整数|符号なし整数|'int'|有効なマトリクス要素へのポインタ}2%plural{0:|: }2%plural{0:|:%plural{0:|:または }2}3%select{|浮動小数点}3%plural{0:|: }3%plural{[0,3]:型|:型}1 (現在%4)でなければなりません"
# '%ordinal0 argument must be a WebAssembly table'
HF0E3AF42C5DD: '%ordinal0 引数はWebAssemblyテーブルでなければなりません'
# '%ordinal0 argument must be an integer'
HB74677AB0CCF: '%ordinal0 引数は整数でなければなりません'
# '%ordinal0 argument must match the element type of the WebAssembly table in the %ordinal1 argument'
HCC6BF06B970F: '%ordinal0 引数は%ordinal1 引数のWebAssemblyテーブルの要素型と一致する必要があります'
# '%plural{1:enumeration value %1 not explicitly handled in switch|2:enumeration values %1 and %2 not explicitly handled in switch|3:enumeration values %1, %2, and %3 not explicitly handled in switch|:%0 enumeration values not explicitly handled in switch: %1, %2, %3...}0'
HE8DAC9A52D87: '%plural{1:switchで明示的に処理されていない列挙値%1|2:switchで明示的に処理されていない列挙値%1と%2|3:switchで明示的に処理されていない列挙値%1、%2、および%3|:%0 個の列挙値がswitchで明示的に処理されていません：%1、%2、%3...}0'
# '%plural{1:enumeration value %1 not handled in switch|2:enumeration values %1 and %2 not handled in switch|3:enumeration values %1, %2, and %3 not handled in switch|:%0 enumeration values not handled in switch: %1, %2, %3...}0'
H0E3F79F6C010: '%plural{1:switchで処理されていない列挙値%1|2:switchで処理されていない列挙値%1と%2|3:switchで処理されていない列挙値%1、%2、および%3|:%0 個の列挙値がswitchで処理されていません：%1、%2、%3...}0'
# "%plural{2:'delete' used to delete pointer to object allocated with 'std::allocator<...>::allocate'|:%select{non-array delete|array delete|'std::allocator<...>::deallocate'}0 used to delete pointer to %select{array object of type %2|non-array object of type %2|object allocated with 'new'}0}1"
H1294E54BD6EF: "%plural{2:'delete'は'std::allocator<...>::allocate'で割り当てたオブジェクトのポインタに対して使用されました|:%select{配列削除でない削除|配列削除|'std::allocator<...>::deallocate'}0は%select{型%2の配列オブジェクト|型%2の非配列オブジェクト|'new'で割り当てられたオブジェクト}0のポインタに対して使用されました}1"
# '%plural{[0,2]:must use a qualified name when declaring|3:cannot declare}0 a %select{constructor|destructor|conversion operator|deduction guide}0 as a friend'
H180E877A4B1E: '%plural{[0,2]:明示的な名前を付けて宣言する必要があります|3:宣言できません}0 %select{コンストラクタ|デストラクタ|変換演算子|推論ガイド}0 としてのフレンド'
# "%q0 %select{with definition in module '%2'|defined here}1 has different definitions in different modules; first difference is this %select{||||static assert|field|method|type alias|typedef|data member|friend declaration|function template|method|instance variable|property|unexpected decl}3"
HC2ECA20D4E80: "%q0 %select{モジュール'%2'内の定義で|ここに定義されています}1 が異なるモジュールで異なる定義を持っています；最初の相違点はこの%select{||||static assert|フィールド|メソッド|型エイリアス|typedef|データメンバ|フレンド宣言|関数テンプレート|メソッド|インスタンス変数|プロパティ|予期しない宣言}3です"
# '%q0 cannot be thread local when declared %q1'
H1F0205F4AD29: '%q0は、%q1で宣言された場合、スレッド局所的（thread local）にできません'
# "%q0 from module '%1' is not present in definition of %q2%select{ in module '%4'| provided earlier}3"
H9DF776E318FF: "%q0 モジュール'%1'からのものは、%q2%select{モジュール'%4'内での定義|以前に提供された}3で存在しません"
# "%q0 has different definitions in different modules; %select{definition in module '%2' is here|defined here}1"
HB3D6EB7685C3: "%q0 が異なるモジュールで異なる定義を持っています；%select{モジュール'%2'の定義はここにあります|ここに定義されています}1"
# "%q0 has different definitions in different modules; %select{definition in module '%2'|defined here}1 first difference is %select{enum that is %select{not scoped|scoped}4|enum scoped with keyword %select{struct|class}4|enum %select{without|with}4 specified type|enum with specified type %4|enum with %4 element%s4|%ordinal4 element has name %5|%ordinal4 element %5 %select{has|does not have}6 an initializer|%ordinal4 element %5 has an initializer|}3"
H39CEC8B6DBEB: "%q0が異なるモジュールで異なる定義を持っています; %select{モジュール'%2'の定義|ここに定義されています}1 最初の相違点は%select{スコープ指定の有無が異なるenum|enumのキーワード%select{struct|class}4でスコープ指定|enumに%select{指定なし|指定された}4型|enumの指定型%4|enumの%4要素%select{s4|}|%ordinal4要素の名前が%5|%ordinal4要素%5が%select{初期化子なし|初期化子あり}6|%ordinal4要素%5が初期化子を有する|}3"
# "%q0 has different definitions in different modules; %select{definition in module '%2'|defined here}1 first difference is %select{return type is %4|%ordinal4 parameter with name %5|%ordinal4 parameter with type %5%select{| decayed from %7}6|%ordinal4 parameter with%select{out|}5 a default argument|%ordinal4 parameter with a default argument|function body}3"
H68AA8A549FAA: "%q0 が異なるモジュールで異なる定義を持っています；%select{モジュール'%2'の定義|ここに定義されています}1 最初の相違点は%select{戻り値の型は%4|%ordinal4引数名%5|%ordinal4引数型%5%select{|%7への変換}6|%ordinal4引数%select{out|}5デフォルト引数|%ordinal4引数のデフォルト引数|関数本体}3です"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%4 base %plural{1:class|:classes}4|%4 virtual base %plural{1:class|:classes}4|%ordinal4 base class with type %5|%ordinal4 %select{non-virtual|virtual}5 base class %6|%ordinal4 base class %5 with %select{public|protected|private|no}6 access specifier}3"
HC4303FABC437: "%q0 が異なるモジュールで異なる定義を持っています；最初の相違点は%select{モジュール'%2'|ここに定義されています}1 %select{%4基底%plural{1:クラス|:クラス}4|%4仮想基底%plural{1:クラス|:クラス}4|%ordinal4基底クラス型%5|%ordinal4%select{非仮想|仮想}5基底クラス%6|%ordinal4基底クラス%5の%select{public|protected|private|なし}6アクセス指定子}3が見つかりました"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%4 referenced %plural{1:protocol|:protocols}4|%ordinal4 referenced protocol with name %5}3"
HC9695A16C965: "%q0が異なるモジュールで異なる定義を持っています; 最初の相違点は%select{モジュール'%2'の定義|ここに定義されています}1 %select{%4参照%plural{1:プロトコル|:プロトコル}4|%ordinal4参照されたプロトコル名%5}3が見つかりました"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%select{method %5|constructor|destructor}4 that has %6 parameter%s6|%select{method %5|constructor|destructor}4 with %ordinal6 parameter of type %7%select{| decayed from %9}8|%select{method %5|constructor|destructor}4 with %ordinal6 parameter named %7}3"
HA17814A91726: "%q0 が異なるモジュールで異なる定義を持っています；最初の相違点は%select{モジュール'%2'|ここに定義されています}1 %select{%select{メソッド%5|コンストラクタ|デストラクタ}4が%6引数%s6|%select{メソッド%5|コンストラクタ|デストラクタ}4の%ordinal6引数型%7%select{|%9への変換}8|%select{メソッド%5|コンストラクタ|デストラクタ}4の%ordinal6引数名%7}3が見つかりました"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{%select{typedef|type alias}4 name %5|%select{typedef|type alias}4 %5 with underlying type %6}3"
H290AB6198D53: "%q0 が異なるモジュールで異なる定義を持っています；最初の相違点は%select{モジュール'%2'|ここに定義されています}1 %select{%select{typedef|型エイリアス}4名%5|%select{typedef|型エイリアス}4%5のベース型%6}3が見つかりました"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{data member with name %4|data member %4 with type %5|data member %4 with%select{out|}5 an initializer|data member %4 with an initializer|data member %4 %select{is constexpr|is not constexpr}5}3"
H3C6A067820A4: "%q0 が異なるモジュールで異なる定義を持っています；最初の相違点は%select{モジュール'%2'|ここに定義されています}1 %select{データメンバ名%4|データメンバ%4型%5|データメンバ%4%select{out|}5初期化子|データメンバ%4初期化子あり|データメンバ%4が%select{constexpr|非constexpr}5}3が見つかりました"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{end of class|public access specifier|private access specifier|protected access specifier|static assert|field|method|type alias|typedef|data member|friend declaration|function template|method|instance variable|property}3"
HC7FCD2470FA2: "%q0 が異なるモジュールで異なる定義を持っています；最初の相違点は%select{モジュール'%2'|ここに定義されています}1 %select{クラス末尾|publicアクセス指定子|privateアクセス指定子|protectedアクセス指定子|static assert|フィールド|メソッド|型エイリアス|typedef|データメンバ|フレンド宣言|関数テンプレート|メソッド|インスタンス変数|プロパティ}3が見つかりました"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{field %4|field %4 with type %5|%select{non-|}5bit-field %4|bit-field %4 with one width expression|%select{non-|}5mutable field %4|field %4 with %select{no|an}5 initializer|field %4 with an initializer}3"
H60D85DC0E685: "%q0 が異なるモジュールで異なる定義を持っています；最初の相違点は%select{モジュール'%2'|ここに定義されています}1 %select{フィールド%4|フィールド%4型%5|%select{非|}5ビットフィールド%4|1ビット幅式のフィールド%4|%select{非|}5mutableフィールド%4|フィールド%4%select{なし|}5初期化子|フィールド%4初期化子あり}3が見つかりました"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{method %4 with return type %5|%select{class|instance}5 method %4|%select{no|'required'|'optional'}4 method control|method %4 with %select{no designated initializer|designated initializer}5|%select{regular|direct}5 method %4|method %4}3"
H5AECB1226BDE: "%q0 が異なるモジュールで異なる定義を持っています；最初の相違点は%select{モジュール'%2'|ここに定義されています}1 %select{メソッド%4戻り値型%5|%select{クラス|インスタンス}5メソッド%4|%select{なし|'required'|'optional'}4メソッド制御|メソッド%4%select{なし|指定子付き}5初期化子|%select{通常|直接}5メソッド%4|メソッド%4}3が見つかりました"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{property %4|property %4 with type %5|%select{no|'required'|'optional'}4 property control|property %4 with %select{default |}6'%select{none|readonly|getter|assign|readwrite|retain|copy|nonatomic|setter|atomic|weak|strong|unsafe_unretained|nullability|null_resettable|class|direct}5' attribute}3"
H47E62251068F: "%q0が異なるモジュールで異なる定義を持っています; 最初の相違点は%select{モジュール'%2'の定義|ここに定義されています}1 %select{プロパティ%4|プロパティ%4に型%5|%select{必須ではない|オプショナル|必須}4プロパティ制御|%select{デフォルト|}'%select{none|readonly|getter|assign|readwrite|retain|copy|nonatomic|setter|atomic|weak|strong|unsafe_unretained|nullability|null_resettable|class|direct}5属性を有するプロパティ%4}3が見つかりました"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{static assert with condition|static assert with message|static assert with %select{|no }4message|%select{method %5|constructor|destructor}4|%select{method %5|constructor|destructor}4 is %select{not deleted|deleted}6|%select{method %5|constructor|destructor}4 is %select{not defaulted|defaulted}6|%select{method %5|constructor|destructor}4 is %select{|pure }6%select{not virtual|virtual}7|%select{method %5|constructor|destructor}4 is %select{not static|static}6|%select{method %5|constructor|destructor}4 is %select{not volatile|volatile}6|%select{method %5|constructor|destructor}4 is %select{not const|const}6|%select{method %5|constructor|destructor}4 is %select{not inline|inline}6|%select{method %5|constructor|destructor}4 with %ordinal6 parameter with%select{out|}7 a default argument|%select{method %5|constructor|destructor}4 with %ordinal6 parameter with a default argument|%select{method %5|constructor|destructor}4 with %select{no |}6template arguments|%select{method %5|constructor|destructor}4 with %6 template argument%s6|%select{method %5|constructor|destructor}4 with %6 for %ordinal7 template argument|%select{method %5|constructor|destructor}4 with %select{no body|body}6|%select{method %5|constructor|destructor}4 with body|friend %select{class|function}4|friend %4|friend function %4|function template %4 with %5 template parameter%s5|function template %4 with %ordinal5 template parameter being a %select{type|non-type|template}6 template parameter|function template %4 with %ordinal5 template parameter %select{with no name|named %7}6|function template %4 with %ordinal5 template parameter with %select{no |}6default argument|function template %4 with %ordinal5 template parameter with default argument %6|function template %4 with %ordinal5 template parameter with one type|function template %4 with %ordinal5 template parameter %select{not |}6being a template parameter pack|}3"
HCEB41952ED68: "%q0は異なるモジュールで異なる定義を持ちます; 最初の相違点は%select{モジュール'%2'の定義|ここに定義}1が%select{条件付きstatic assert|メッセージ付きstatic assert|static assertの%select{|なし}4メッセージ|%select{メソッド%5|コンストラクタ|デストラクタ}4|%select{メソッド%5|コンストラクタ|デストラクタ}4が%select{削除されていない|削除済み}6|%select{メソッド%5|コンストラクタ|デストラクタ}4が%select{デフォルト化されていない|デフォルト化済み}6|%select{メソッド%5|コンストラクタ|デストラクタ}4が%select{|純粋な}6%select{非仮想|仮想}7|%select{メソッド%5|コンストラクタ|デストラクタ}4が%select{静的でない|静的}6|%select{メソッド%5|コンストラクタ|デストラクタ}4が%select{volatileでない|volatile}6|%select{メソッド%5|コンストラクタ|デストラクタ}4が%select{constでない|const}6|%select{メソッド%5|コンストラクタ|デストラクタ}4が%select{インラインでない|インライン}6|%select{メソッド%5|コンストラクタ|デストラクタ}4の%ordinal6パラメータに%select{出力|}7デフォルト引数|%select{メソッド%5|コンストラクタ|デストラクタ}4の%ordinal6パラメータにデフォルト引数|%select{メソッド%5|コンストラクタ|デストラクタ}4の%select{テンプレート引数なし|}6テンプレート引数|%select{メソッド%5|コンストラクタ|デストラクタ}4の%6テンプレート引数%s6|%select{メソッド%5|コンストラクタ|デストラクタ}4の%ordinal7テンプレート引数として%6|%select{メソッド%5|コンストラクタ|デストラクタ}4の%select{本体なし|本体あり}6|%select{メソッド%5|コンストラクタ|デストラクタ}4の本体|フレンド%select{クラス|関数}4|フレンド%4|フレンド関数%4|テンプレート関数%4の%5テンプレートパラメータ%s5|テンプレート関数%4の%ordinal5テンプレートパラメータが%select{型|非型|テンプレート}6テンプレートパラメータ|テンプレート関数%4の%ordinal5テンプレートパラメータ%select{名前なし|名前%7}6|テンプレート関数%4の%ordinal5テンプレートパラメータ%select{デフォルト引数なし|デフォルト引数あり}6|テンプレート関数%4の%ordinal5テンプレートパラメータのデフォルト引数%6|テンプレート関数%4の%ordinal5テンプレートパラメータに1つの型|テンプレート関数%4の%ordinal5テンプレートパラメータが%select{テンプレートパラメータパックではない|}6テンプレートパラメータパック|}3"
# "%q0 has different definitions in different modules; first difference is %select{definition in module '%2'|defined here}1 found %select{unnamed template parameter|template parameter %5|template parameter with %select{no |}4default argument|template parameter with default argument}3"
HA9E92FE31082: "%q0 が異なるモジュールで異なる定義を持っています；最初の相違点は%select{モジュール'%2'|ここに定義されています}1 %select{名前のないテンプレート引数|テンプレート引数%5|テンプレート引数%select{なし|}4デフォルト引数|テンプレート引数デフォルト引数}3が見つかりました"
# '%q0 hides overloaded virtual %select{function|functions}1'
H2FDDD909C4BF: '%q0がオーバーロードされた仮想%select{関数|関数}1を隠蔽しています'
# '%q0 is not a member of class %1'
H76BB7974AA85: '%q0はクラス%1のメンバーではありません'
# '%q0 must have external linkage when declared %q1'
HEEACDE119817: '%q0は%q1として宣言される場合外部リンクを必須とします'
# '%q0 redeclared inline; %1 attribute ignored'
HE698B2D72430: '%q0が再宣言時にインライン属性を指定; %1属性は無視されました'
# '%q0 redeclared without %1 attribute: previous %1 ignored'
HD8FE54A130EE: '%q0が%1属性なしで再宣言されました: 前の%1属性を無視します'
# "%q0 redeclared without 'dllimport' attribute: 'dllexport' attribute added"
H6D76D4BE2232: "%q0が'dllimport'属性なしで再宣言されました: 'dllexport'属性が追加されました"
# '%select{#elif|#elifdef|#elifndef}0 after #else'
H66B8B159F15D: '%select{#elif|#elifdef|#elifndef}0が#elseの後に指定されました'
# '%select{#elif|#elifdef|#elifndef}0 without #if'
HF4D335F3B905: '%select{#elif|#elifdef|#elifndef}0が#ifなしで使用されました'
# '%select{#line|GNU line marker}0 directive interprets number as decimal, not octal'
HDF9BCDB36B4E: '%select{#line|GNU line marker}0ディレクティブは数値を8進ではなく10進で解釈します'
# '%select{#line|GNU line marker}0 directive requires a simple digit sequence'
H065F2C4ACA47: '%select{#line|GNU line marker}0ディレクティブには単純な数字列が必要です'
# '%select{%1 and |}0%2 tokens %select{introducing statement expression|terminating statement expression|introducing attribute|terminating attribute|forming pointer to member type}3 appear in different macro expansion contexts'
H64A1AC254D6A: '%select{%1と |}0%2トークンの%select{式表現導入|式表現終了|属性導入|属性終了|メンバーポインタ型形成}3が異なるマクロ展開コンテキストで出現しています'
# '%select{%1 and |}0%2 tokens %select{introducing statement expression|terminating statement expression|introducing attribute|terminating attribute|forming pointer to member type}3 are separated by whitespace'
H9C7F5E5CC536: '%select{%1と |}0%2トークンの%select{式表現導入|式表現終了|属性導入|属性終了|メンバーポインタ型形成}3が空白で区切られています'
# '%select{%1 is a virtual base class of base class %2 declared here|virtual base class %1 declared here}0'
H0907DB13630C: '%select{基底クラス%2の仮想基底クラス%1がここに宣言されています|仮想基底クラス%1がここに宣言されています}0'
# '%select{%2 has subobjects that are|%3 has type %2 that is}0 non-trivial to %select{default-initialize|destruct|copy}1'
H48AF719C5841: '%select{%2はサブオブジェクトが存在する|%3の型%2が}0、%select{デフォルト初期化|破棄|コピー}1が非自明です'
# '%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes address space of nested pointer'
H229282294F90: '%select{%diff{値$を$に代入しています|異なる型への代入}1,0|%diff{パラメータの型$に値$を渡しています|異なる型のパラメータへの渡し}0,1|%diff{関数の戻り値型$から値$を返却しています|戻り値型が異なる関数からの返却}0,1|%diff{型$を型$に変換しています|型間の変換}0,1|%diff{式の型$で型$を初期化しています|異なる型の式による初期化}0,1|%diff{パラメータの型$に値$を送信しています|異なる型のパラメータへの送信}0,1|%diff{型$を型$にキャストしています|型間のキャスト}0,1}2のネストポインタのアドレス空間が変化します'
# '%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes address space of pointer'
H34858D5559B9: '%select{%diff{値$を$に代入しています|異なる型への代入}1,0|%diff{パラメータの型$に値$を渡しています|異なる型のパラメータへの渡し}0,1|%diff{関数の戻り値型$から値$を返却しています|戻り値型が異なる関数からの返却}0,1|%diff{型$を型$に変換しています|型間の変換}0,1|%diff{式の型$で型$を初期化しています|異なる型の式による初期化}0,1|%diff{パラメータの型$に値$を送信しています|異なる型のパラメータへの送信}0,1|%diff{型$を型$にキャストしています|型間のキャスト}0,1}2のポインタのアドレス空間が変化します'
# '%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes retain/release properties of pointer'
HCD0B002FCAD8: '%select{%diff{値$を$に代入しています|異なる型への代入}1,0|%diff{パラメータの型$に値$を渡しています|異なる型のパラメータへの渡し}0,1|%diff{関数の戻り値型$から値$を返却しています|戻り値型が異なる関数からの返却}0,1|%diff{型$を型$に変換しています|型間の変換}0,1|%diff{式の型$で型$を初期化しています|異なる型の式による初期化}0,1|%diff{パラメータの型$に値$を送信しています|異なる型のパラメータへの送信}0,1|%diff{型$を型$にキャストしています|型間のキャスト}0,1}2のポインタのretain/releaseプロパティが変更されます'
# "%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 converts between pointers to integer types %select{with different sign|where one is of the unique plain 'char' type and the other is not}3"
H1F24CCDCD587: "%select{%diff{を から に代入しています|異なる型の代入}0,1|%diff{引数の型 に が渡されています|異なる型の引数渡し}0,1|%diff{戻り値の型 から という戻り値を返却しています|戻り値の型が不一致}0,1|%diff{ を型 に変換しています|型間変換}0,1|%diff{ の初期化式に型 の式が使用されています|異なる型の初期化}0,1|%diff{引数の型 に が渡されています|異なる型の引数渡し}0,1|%diff{ を型 にキャストしています|型間キャスト}0,1}2 整数型ポインタ間の変換を行っています %select{符号の異なる|一方が'char'型で他方が異なる}3"
# '%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 converts between void pointer and function pointer'
HA7C5AA745059: '%select{%diff{異なる型$への$への代入|異なる型への代入}0,1|%diff{パラメータの型$に値$を渡しています|異なる型のパラメータへの渡し}0,1|%diff{関数の戻り値型$から値$を返却しています|戻り値型が異なる関数からの返却}0,1|%diff{型$を型$に変換しています|型間の変換}0,1|%diff{式の型$で型$を初期化しています|異なる型の式による初期化}0,1|%diff{パラメータの型$に値$を送信しています|異なる型のパラメータへの送信}0,1|%diff{型$を型$にキャストしています|型間のキャスト}0,1}2はvoidポインタと関数ポインタ間の変換です'
# '%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers'
H7F0C4095C720: '%select{%diff{異なる型$への$への代入|異なる型への代入}0,1|%diff{パラメータの型$に値$を渡しています|異なる型のパラメータへの渡し}0,1|%diff{関数の戻り値型$から値$を返却しています|戻り値型が異なる関数からの返却}0,1|%diff{型$を型$に変換しています|型間の変換}0,1|%diff{式の型$で型$を初期化しています|異なる型の式による初期化}0,1|%diff{パラメータの型$に値$を送信しています|異なる型のパラメータへの送信}0,1|%diff{型$を型$にキャストしています|型間のキャスト}0,1}2は修飾子を破棄します'
# '%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers in nested pointer types'
HA6738ACC7EBA: '%select{%diff{異なる型$への$への代入|異なる型への代入}0,1|%diff{パラメータの型$に値$を渡しています|異なる型のパラメータへの渡し}0,1|%diff{関数の戻り値型$から値$を返却しています|戻り値型が異なる関数からの返却}0,1|%diff{型$を型$に変換しています|型間の変換}0,1|%diff{式の型$で型$を初期化しています|異なる型の式による初期化}0,1|%diff{パラメータの型$に値$を送信しています|異なる型のパラメータへの送信}0,1|%diff{型$を型$にキャストしています|型間のキャスト}0,1}2はネストポインタ型の修飾子を破棄します'
# '%select{%diff{assigning to $ from incompatible type $|assigning to type from incompatible type}0,1|%diff{passing $ to parameter of incompatible type $|passing type to parameter of incompatible type}0,1|%diff{returning $ from a function with incompatible result type $|returning type from a function with incompatible result type}0,1|%diff{converting $ to incompatible type $|converting type to incompatible type}0,1|%diff{initializing $ with an expression of incompatible type $|initializing type with an expression of incompatible type}0,1|%diff{sending $ to parameter of incompatible type $|sending type to parameter of incompatible type}0,1|%diff{casting $ to incompatible type $|casting type to incompatible type}0,1}2'
HCAB9D3041C51: '%select{%diff{不整合な型$から$への代入|不整合な型への代入}0,1|%diff{不整合な型$のパラメータに値$を渡しています|不整合な型のパラメータへの渡し}0,1|%diff{不整合な戻り値型$から値$を返却しています|不整合な戻り値型からの返却}0,1|%diff{不整合な型$への型$変換|不整合な型への変換}0,1|%diff{不整合な型$の式で型$を初期化しています|不整合な型の式による初期化}0,1|%diff{不整合な型$のパラメータに値$を送信しています|不整合な型のパラメータへの送信}0,1|%diff{不整合な型$への型$キャスト|不整合な型へのキャスト}0,1}2'
# '%select{%diff{assigning to $ from incompatible type $|assigning to type from incompatible type}0,1|%diff{passing $ to parameter of incompatible type $|passing type to parameter of incompatible type}0,1|%diff{returning $ from a function with incompatible result type $|returning type from a function with incompatible result type}0,1|%diff{converting $ to incompatible type $|converting type to incompatible type}0,1|%diff{initializing $ with an expression of incompatible type $|initializing type with an expression of incompatible type}0,1|%diff{sending $ to parameter of incompatible type $|sending type to parameter of incompatible type}0,1|%diff{casting $ to incompatible type $|casting type to incompatible type}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3%select{|: different classes%diff{ ($ vs $)|}5,6|: different number of parameters (%5 vs %6)|: type mismatch at %ordinal5 parameter%diff{ ($ vs $)|}6,7|: different return type%diff{ ($ vs $)|}5,6|: different qualifiers (%5 vs %6)|: different exception specifications}4'
H5631F8DA82CD: '%select{%diff{不整合な型 $ から $ への代入|不整合な型から型への代入}0,1|%diff{パラメータの不整合な型 $ に $ を渡しています|パラメータの不整合な型への型の渡し}0,1|%diff{不整合な戻り値型 $ を戻す関数から $ を返しています|戻り値型の不整合な関数からの戻り値の返却}0,1|%diff{不整合な型 $ から $ への変換|型から不整合な型への変換}0,1|%diff{不整合な型 $ の初期化に式 $ を使用|型の初期化における不整合な式の使用}0,1|%diff{パラメータの不整合な型 $ に $ を送信|パラメータの不整合な型への型の送信}0,1|%diff{不整合な型 $ から $ へのキャスト|型から不整合な型へのキャスト}0,1}2%select{|; * でデリファレンス|; アドレスを取得|; * を削除|; & を削除}3%select{|: 違いのあるクラス%diff{ ($ vs $)|}5,6|: パラメータ数の不整合 (%5 vs %6)|: %ordinal5 パラメータの型不一致%diff{ ($ vs $)|}6,7|: 返り値型の不一致%diff{ ($ vs $)|}5,6|: 質 qualifiers の不一致 (%5 vs %6)|: exception 規定の不一致}4'
# '%select{%select{increment|decrement}1 of readonly property|no setter method %2 for %select{increment|decrement}1 of property}0'
HAF55C5B7D9CC: '%select{読み取り専用プロパティの%select{インクリメント|デクリメント}|プロパティの%select{インクリメント|デクリメント}用セットメソッド%2が存在しません}0'
# "%select{%select{reference|'std::initializer_list'}0 member|member with %select{reference|'std::initializer_list'}0 subobject}1 declared here"
H1B5CDFE7B6DA: "%select{%select{参照|'std::initializer_list'}0 メンバー|%select{参照|'std::initializer_list'}0 サブオブジェクトを有するメンバー}1 ここに宣言されています"
# "%select{'#pragma clang fp eval_method'|option 'ffp-eval-method'}0 cannot be used with %select{option 'fapprox-func'|option 'mreassociate'|option 'freciprocal'|option 'ffp-eval-method'|'#pragma clang fp reassociate'|'#pragma clang fp reciprocal'}1"
HD4A3AC42422A: "%select{'#pragma clang fp eval_method'|オプション'ffp-eval-method'}0は%select{'fapprox-func'オプション|'mreassociate'オプション|'freciprocal'オプション|'ffp-eval-method'オプション|#pragma clang fp reassociate|#pragma clang fp reciprocal}1と同時に使用できません"
# "%select{'auto'|'decltype(auto)'|'__auto_type'|template arguments}0 deduced as %1 in declaration of %2 and deduced as %3 in declaration of %4"
H11DB7A31A7DA: "%select{'auto'|'decltype(auto)'|'__auto_type'|テンプレート引数}0は%2の宣言では%1、%4の宣言では%3と推論されました"
# "%select{'auto'|'decltype(auto)'|'__auto_type'|use of %select{class template|function template|variable template|alias template|template template parameter|concept|template}2 %3 requires template arguments; argument deduction}0 not allowed %select{in function prototype|in non-static struct member|in struct member|in non-static union member|in union member|in non-static class member|in interface member|in exception declaration|in template parameter until C++17|in block literal|in template argument|in typedef|in type alias|in function return type|in conversion function type|here|in lambda parameter|in type allocated by 'new'|in K&R-style function parameter|in template parameter|in friend declaration|in function prototype that is not a function declaration|in requires expression parameter|in array declaration|in declaration of conversion function template|in lambda parameter before C++14}1"
H7226E87E7B56: "%select{'auto'|'decltype(auto)'|'__auto_type'|%select{クラステンプレート|関数テンプレート|変数テンプレート|エイリアステンプレート|テンプレートテンプレートパラメータ|コンセプト|テンプレート}2 %3はテンプレート引数が必要です；引数推論}0は%select{関数プロトタイプ|非静的構造体メンバ|構造体メンバ|非静的共用体メンバ|共用体メンバ|非静的クラスメンバ|インターフェースメンバ|例外宣言|C++17以前のテンプレートパラメータ|ブロックリテラル|テンプレート引数|typedef|型エイリアス|関数戻り値型|変換関数型|ここ|ラムダパラメータ|'new'で割り当てた型|K&Rスタイルの関数パラメータ|テンプレートパラメータ|フレンド宣言|関数プロトタイプが関数宣言でない場合|要件式パラメータ|配列宣言|変換関数テンプレート宣言|C++14以前のラムダパラメータ}1で使用できません"
# "%select{'mutable'|'static'|'constexpr'|'consteval'}0 cannot appear multiple times in a lambda declarator"
HA9F29290F39F: "%select{'mutable'|'static'|'constexpr'|'consteval'}0はラムダ宣言子に複数指定できません"
# "%select{'size' argument to memset is '0'|setting buffer to a 'sizeof' expression}0; did you mean to transpose the last two arguments?"
HBE450D9F2F6C: "%select{memsetの'size'引数が'0'|'sizeof'式でバッファを設定}0; 最後の2つの引数を逆にしていませんか？"
# '%select{<ERROR>|constexpr|consteval|constinit}0 can only be used in %select{|variable and function|function|variable}0 declarations'
H8ABC77B14403: '%select{<ERROR>|constexpr|consteval|constinit}0は%select{|変数および関数|関数|変数}0宣言でのみ使用できます'
# '%select{<ERROR>|equality|three-way|equality|relational}0 comparison operator is not a friend of %select{|incomplete class }1%2'
HFE0AE74FD7A7: '%select{<error>|等値|三項|等値|比較}0演算子は%select{|不完全クラス }1%2のフレンドではありません'
# '%select{<error>|function template|variable template|alias template|template template parameter|concept|template}0 %1 requires template arguments; argument deduction only allowed for class templates or alias templates'
HDE23AA7C6E82: '%select{エラー|関数テンプレート|変数テンプレート|エイリアステンプレート|テンプレートテンプレートパラメータ|コンセプト|テンプレート}0 %1 はテンプレート引数が必要です；引数推論はクラステンプレートまたはエイリアステンプレートのみ有効です'
# '%select{@available|__builtin_available}0 does not guard availability here; use if (%select{@available|__builtin_available}0) instead'
HBA44F219FD20: '%select{@available|__builtin_available}0はここをガードしません；if (%select{@available|__builtin_available}0)を使用してください'
# "%select{AST file '%1' was|current translation unit is}0 compiled with the target feature '%2' but the %select{current translation unit is|AST file '%1' was}0 not"
H5C12AF216CA3: "%select{ASTファイル'%1'が|現在の翻訳ユニットは}0ターゲット機能'%2'でコンパイルされていますが、%select{現在の翻訳ユニットは|ASTファイル'%1'は}0そうではありません"
# "%select{MIPS|MSP430|RISC-V|AVR}0 '%select{interrupt|signal}1' attribute only applies to functions that have %select{no parameters|a 'void' return type}2"
HC530D462FB18: "%select{MIPS|MSP430|RISC-V|AVR}0 '%select{interrupt|signal}1' 属性は %select{引数を取らない|戻り値の型が'void'である}2 関数にのみ適用可能です"
# "%select{OpenACC '%3' construct|while loop|do loop}0 cannot appear in intervening code of a '%1' with a '%2' clause"
HB2C5F39C46C3: "%select{OpenACC '%3'構文|whileループ|doループ}0 は'%1'の'%2'句間のコード内では使用できません"
# "%select{OpenACC 'gang' clause with a 'dim' value greater than 1|OpenACC 'reduction' clause}0 cannot appear on the same '%1' construct as a %select{'reduction' clause|'gang' clause with a 'dim' value greater than 1}0"
H3449F0200ABB: "%select{OpenACC 'gang'句（dim値が1より大きい場合）|OpenACC 'reduction'句}0 は同じ'%1'構文で %select{'reduction'句|'gang'句（dim値が1より大きい場合）}0 と共存できません"
# '%select{OpenACC sub-array|OpenMP array section}0 is not allowed here'
H8129F6E36883: '%select{OpenACCサブ配列|OpenMP配列セクション}0 ここでは使用できません'
# '%select{PCH|current translation unit}0 has no VFS overlays'
H1F8E7EA59762: '%select{PCH|現在の翻訳単位}0 にはVFSオーバーレイがありません'
# '%select{PCH|current translation unit}0 has the following VFS overlays:\n%1'
HF3357458F7A1: '%select{PCH|現在の翻訳単位}0 には以下のVFSオーバーレイがあります:\n%1'
# "%select{PCH|module|AST}0 file '%1' built from a different branch (%2) than the compiler (%3)"
H47225B26A402: "%select{PCH|モジュール|AST}0 ファイル'%1'はコンパイラ(%3)と異なるブランチ(%2)から生成されました"
# "%select{PCH|module|AST}0 file '%1' contains compiler errors"
H70FD1E0F0771: "%select{PCH|モジュール|AST}0 ファイル'%1'にコンパイルエラーが含まれています"
# "%select{PCH|module|AST}0 file '%1' is out of date and needs to be rebuilt%select{|: %3}2"
H1F11095B483F: "%select{PCH|モジュール|AST}0 ファイル'%1'は古い状態です。再ビルドが必要です%select{|: %3}2"
# "%select{PCH|module|AST}0 file '%1' not found%select{|: %3}2"
HA37A363A734E: "%select{PCH|モジュール|AST}0 ファイル'%1'が見つかりません%select{|: %3}2"
# "%select{PCH|module|AST}0 file '%1' uses a newer format that cannot be read"
H80665252BAE8: "%select{PCH|モジュール|AST}0 ファイル'%1'は読み込めない新しいフォーマットを使用しています"
# "%select{PCH|module|AST}0 file '%1' uses an older format that is no longer supported"
HB4B0734241D0: "%select{PCH|モジュール|AST}0 ファイル'%1'はサポートされていない古いフォーマットを使用しています"
# '%select{__block variables|global variables|fields|instance variables}0 cannot have __autoreleasing ownership'
H8459C5DA92C1: '%select{__block変数|グローバル変数|フィールド|インスタンス変数}0 は__autoreleasingオーナーシップを指定できません'
# '%select{__device__|__global__|__host__|__host__ __device__}0 function %1 cannot overload %select{__device__|__global__|__host__|__host__ __device__}2 function %3'
HD56CBB05D1A2: '%select{__device__|__global__|__host__|__host__ __device__}0 関数%1 は%select{__device__|__global__|__host__|__host__ __device__}2 関数%3 とオーバーロードできません'
# '%select{a reference type|an array type|a non-vector or non-vectorizable scalar type}0 is an invalid argument to attribute %1'
H9A7D97DDD421: '%select{参照型|配列型|ベクターやベクタライズ可能なスカラータイプでない型}0 は属性%1 の有効な引数ではありません'
# "%select{a variable|a parameter|'this'}0 cannot appear in more than one %1 clause"
HE09D18DCA51A: "%select{変数|パラメータ|'this'}0 は複数の%1 句に出現できません"
# '%select{address of|reference to}0 stack memory associated with %select{local variable|parameter|compound literal}2 %1 %select{returned|passed to musttail function}3'
HDE8352A90808: '%select{スタックメモリのアドレス|リファレンス}0 %select{ローカル変数|パラメータ|複合リテラル}2 %1 %select{を返却|musttail 関数に渡す}3'
# '%select{alias|ifunc}0 definition is part of a cycle'
H75F8799A172C: '%select{エイリアス|ifunc}0 の定義が循環構造になっています'
# '%select{alias|ifunc}0 must point to a defined %select{variable or |}1function'
HA8FBD807C04A: '%select{エイリアス|ifunc}0 は定義済みの %select{変数または |}1 関数を指さなければなりません'
# "%select{alias|ifunc}1 will not be in section '%0' but in the same section as the %select{aliasee|resolver}2"
H14919DB80F8A: "%select{エイリアス|ifunc}1 はセクション '%0' ではなく、%select{エイリアス先|リゾルバ}2 と同じセクションになります"
# '%select{alias|ifunc}2 will always resolve to %0 even if weak definition of %1 is overridden'
H739E4FBA0F0D: '%select{エイリアス|ifunc}2 は %1 の弱い定義が上書きされても常に %0 を解決します'
# '%select{aligning a value|the result of checking whether a value is aligned}0 to 1 byte is %select{a no-op|always true}0'
H6A34843E702F: '%select{1 バイトへの値のアラインメント|値のアラインメントチェック結果}0 は %select{無効な操作|常に true}0 です'
# '%select{alignment of|offset of the aligned pointer from}0 the base pointee object (%1 %plural{1:byte|:bytes}1) is %select{less than|not a multiple of}0 the asserted %2 %plural{1:byte|:bytes}2'
H473934A0D013: '%select{ベースポイントオブジェクトからのアライメント|ベースポイントオブジェクトからのアライン済みポインタのオフセット}0 (%1 %plural{1:バイト|:バイト}1) は、主張された %2 %plural{1:バイト|:バイト}2 より %select{小さい|倍数ではない}0'
# '%select{alignment|size}0 of field %1 (%2 bits) does not match the %select{alignment|size}0 of the first field in transparent union; transparent_union attribute ignored'
HF5A022BDF3DB: '%select{アライメント|サイズ}0 フィールド %1 (%2 ビット) は、透明結合体の最初のフィールドの %select{アライメント|サイズ}0 と一致しません; transparent_union 属性は無視されます'
# '%select{alignment|size}0 of first field is %1 bits'
H996CEE2D3252: '最初のフィールドの %select{アラインメント|サイズ}0 は %1 ビットです'
# '%select{all|second and third}0 arguments to %1 must be of scalar or vector type with matching scalar element type%diff{: $ vs $|}2,3'
HE09C48EB126A: '%select{すべての|3番目と4番目の}0 引数 %1 は互換するスカラまたはベクタ型でなければなりません%diff{: $ vs $|}2,3'
# '%select{an attribute specifier sequence|%0}1 in this position is a C++23 extension'
H561F9F6DB91B: '%select{属性仕様シーケンス|%0}1 はこの位置での C++23 の拡張機能です'
# '%select{an attribute specifier sequence|%1}0 in this position is incompatible with C++ standards before C++23'
HEF130F97BB12: '%select{属性仕様シーケンス|%1}0 は C++23 より前の標準では互換しません'
# '%select{and|because}0 %1 does not satisfy %2'
H1152B396A251: '%select{および|理由として}0 %1 は %2 を満たしません'
# '%select{and|because}0 %1 does not satisfy %2:'
H7FDA8323151A: '%select{および|理由として}0 %1 は %2 を満たしません:'
# "%select{and|because}0 '%1' (%2 %3 %4) evaluated to false"
H5A2EAB383E7A: "%select{および|理由として}0 '%1' (%2 %3 %4) の評価結果が false です"
# "%select{and|because}0 '%1' evaluated to false"
HD9EC26C0E6B0: "%select{および|理由として}0 '%1' の評価結果が false です"
# "%select{and|because}0 '%1' may throw an exception"
HA87D7335D9EB: "%select{および|理由として}0 '%1' は例外を送出します"
# "%select{and|because}0 '%1' would be invalid"
HAD3CC48247E5: "%select{および|理由として}0 '%1' は無効となります"
# "%select{and|because}0 '%1' would be invalid%2"
HEF46AC24BE27: "%select{および|なぜなら}0 '%1' は無効になる%2"
# "%select{and|because}0 '%1' would be invalid: %2"
HD3831227C190: "%select{および|なぜなら}0 '%1' は無効になるため: %2"
# "%select{and|because}0 type constraint '%1' was not satisfied:"
HD561B1DB876A: "%select{および|なぜなら}0 型制約 '%1' が満たされませんでした:"
# '%select{anonymous struct|union}0 member %1 has a non-trivial %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}2'
H443C398B6494: '%select{匿名構造体|ユニオン}0 メンバ %1 は非自明な %select{デフォルトコンストラクタ|コピーコンストラクタ|ムーブコンストラクタ|コピー代入演算子|ムーブ代入演算子|デストラクタ}2 を持っています'
# '%select{anonymous struct|union}0 member %1 with a non-trivial %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}2 is incompatible with C++98'
HE6728E1CAD49: '%select{匿名構造体|ユニオン}0 メンバ %1 の %select{デフォルトコンストラクタ|コピーコンストラクタ|ムーブコンストラクタ|コピー代入演算子|ムーブ代入演算子|デストラクタ}2 は C++98 と互換性ありません'
# '%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 %select{floating-point|enumeration}1 type %2 %plural{2:with|4:from|:and}0 %select{enumeration|floating-point}1 type %3'
H510A2D2A82E0: '%select{間の算術演算|間のビット演算|間の比較|間の条件式|間の複合代入}0 %select{浮動小数点|列挙型}1 型 %2 %plural{2:と|4:から|:と}0 %select{列挙型|浮動小数点}1 型 %3'
# '%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 %select{floating-point|enumeration}1 type %2 %plural{2:with|4:from|:and}0 %select{enumeration|floating-point}1 type %3 is deprecated'
H08C01E0FFD79: '%select{間の算術演算|間のビット演算|間の比較|間の条件式|間の複合代入}0 %select{浮動小数点|列挙型}1 型 %2 %plural{2:と|4:から|:と}0 %select{列挙型|浮動小数点}1 型 %3 は非推奨です'
# '%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2'
H15481858FE39: '%select{間の算術演算|間のビット演算|間の比較|間の条件式|間の複合代入}0 違う列挙型%diff{ ($と$)|}1,2'
# '%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2 is deprecated'
HB2E74DC62C72: '%select{間の算術演算|間のビット演算|間の比較|間の条件式|間の複合代入}0 違った列挙型%diff{ ($と$)|}1,2 は非推奨です'
# '%select{assignment to readonly property|no setter method %1 for assignment to property}0'
H7FB56A6FE5D6: '%select{読み取り専用プロパティへの代入|プロパティへの代入用のセッターメソッド %1 が存在しません}0'
# '%select{base class|inherited virtual base class}0 %1 has %select{private|protected}3 %select{default |copy |move |*ERROR* |*ERROR* |*ERROR*|}2constructor'
H3EE5604475F7: '%select{基底クラス|継承された仮想基底クラス}0 %1 は %select{プライベート|プロテクテッド}3 %select{デフォルト |コピー |ムーブ |*ERROR* |*ERROR* |*ERROR*|}2コンストラクタを持っています'
# '%select{bit-field %1|anonymous bit-field}0 is too wide (%2 bits)'
H4CB82469419C: '%select{ビットフィールド %1|匿名ビットフィールド}0 が大きすぎです (%2 ビット)'
# "%select{block pointer|pointer|reference}0 to function type %select{%2 |}1cannot have '%3' qualifier"
H0BABB964A63A: "%select{ブロックポインタ|ポインタ|参照}0 %select{関数型 %2 |}1 は '%3' クオリファイアーを持つことはできません"
# '%select{call to non-static member function|use of non-static data member}0 %2 of %1 from nested type %3'
H4DA493B4F5FF: '%select{非静的メンバ関数の呼び出し|非静的データメンバの使用}0 %2 の %1 からネスト型 %3 での使用'
# '%select{cannot assign to return value because function %1 returns a const value|cannot assign to variable %1 with const-qualified type %2|cannot assign to %select{non-|}1static data member %2 with const-qualified type %3|cannot assign to non-static data member within const member function %1|cannot assign to %select{variable %2|non-static data member %2|lvalue}1 with %select{|nested }3const-qualified data member %4|read-only variable is not assignable}0'
H957C121C1C4E: '%select{const値を返す関数 %1 の戻り値への代入は不可能|const修飾付き型 %2 の変数 %1 への代入はできません|const修飾付き型 %3 の%select{非|}1静的データメンバ %2 への代入はできません|constメンバ関数 %1 内での非静的データメンバへの代入はできません|%select{変数 %2|非静的データメンバ %2|左辺値}1 の%select{|ネストした }3const修飾データメンバ %4 により読み取り専用です|読み取り専用変数は代入できません}0'
# "%select{case value|enumerator value|non-type template argument|non-type parameter of template template parameter|array size|explicit specifier argument|noexcept specifier argument|call to 'size()'|call to 'data()'}0 %select{cannot be narrowed from type %2 to %3|evaluates to %2, which cannot be narrowed to type %3}1"
HECF4733C9DA0: "%select{case値|列挙子値|非型テンプレート引数|テンプレートテンプレートパラメータの非型パラメータ|配列サイズ|explicit specifier引数|noexcept specifier引数|'size()'の呼び出し|'data()'の呼び出し}0 %select{型 %2 から %3 への Narrowing 不可|評価値 %2 は型 %3 に Narrowing できません}1"
# "%select{case value|enumerator value|non-type template argument|non-type parameter of template template parameter|array size|explicit specifier argument|noexcept specifier argument|call to 'size()'|call to 'data()'}0 is not a constant expression"
HFB41B693F137: "%select{case value|列挙子値|非型テンプレート引数|テンプレートテンプレートパラメータの非型パラメータ|配列サイズ|explicit修飾子引数|noexcept修飾子引数|'size()'の呼び出し|'data()'の呼び出し}0 は定数式ではありません"
# '%select{cast|implicit conversion}0 of %select{Objective-C|block|C}1 pointer type %2 to %select{Objective-C|block|C}3 pointer type %4 requires a bridged cast'
H312933E2115D: '%select{キャスト|暗黙の変換}0 %select{Objective-C|ブロック|C}1 ポインタ型%2 を%select{Objective-C|ブロック|C}3 ポインタ型%4 に変換するにはブリッジキャストが必要です'
# '%select{category %1|class extension}0 cannot conform to protocol %2 because of direct members declared in interface %3'
H86E18740A145: '%select{カテゴリ %1|クラスエクステンション}0 はインターフェース%3 で宣言された直接メンバのため、プロトコル%2 に適合しません'
# '%select{category|class extension}0 conforms to protocol %1 which defines method %2'
H1219B6B58D30: '%select{カテゴリ|クラスエクステンション}0 はプロトコル%1 を実装していますが、そのプロトコルはメソッド%2 を定義しています'
# '%select{character|integer}0 literal with user-defined suffix cannot be used in preprocessor constant expression'
HF3B4B5DEEBAB: '%select{文字|整数}0 文字列リテラルのユーザー定義接尾辞はプリプロセッサ定数式で使用できません'
# '%select{class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration}0 specialization of %1 must occur at global scope'
HB1B7C78CE71E: '%select{クラステンプレート|クラステンプレート部分|変数テンプレート|変数テンプレート部分|関数テンプレート|メンバ関数|静的データメンバ|メンバクラス|メンバ列挙型}0 専門化%1 はグローバルスコープで発生する必要があります'
# '%select{class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration}0 specialization of %1 not in %select{a namespace enclosing %2|class %2 or an enclosing namespace}3'
HFB74AB926D65: '%select{クラステンプレート|クラステンプレート部分|変数テンプレート|変数テンプレート部分|関数テンプレート|メンバ関数|静的データメンバ|メンバクラス|メンバ列挙型}0 専門化%1 は%select{%2 を包含する名前空間|クラス%2 や包含する名前空間}3 内にありません'
# '%select{class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration}0 specialization of %1 not in %select{a namespace enclosing %2|class %2 or an enclosing namespace}3 is a Microsoft extension'
H61AEC4FCDF68: '%select{クラステンプレート|クラステンプレート部分|変数テンプレート|変数テンプレート部分|関数テンプレート|メンバ関数|静的データメンバ|メンバクラス|メンバ列挙型}0 専門化%1 が%select{%2 を包含する名前空間|クラス%2 や包含する名前空間}3 外にあるのはMicrosoft拡張です'
# '%select{class|instance}0 method %1 also declared here'
H40D03C99413F: '%select{クラス|インスタンス}0 メソッド%1 ここにも宣言されています'
# '%select{class|instance}0 method %1 has a different number of parameters in different translation units (%2 vs. %3)'
H1C2BED5A5D12: '%select{クラス|インスタンス}0 メソッド%1 のパラメータ数が異なる翻訳単位間で異なっています（%2 対 %3）'
# '%select{class|instance}0 method %1 has a parameter with a different types in different translation units (%2 vs. %3)'
H27FF7F628706: '%select{クラス|インスタンス}0 メソッド%1 のパラメータの型が異なる翻訳単位間で異なっています（%2 対 %3）'
# '%select{class|instance}0 method %1 has incompatible result types in different translation units (%2 vs. %3)'
H81568F1228D2: '%select{クラス|インスタンス}0 メソッド%1 の戻り値型が異なる翻訳単位間で異なっています（%2 対 %3）'
# '%select{class|instance}0 method %1 is assumed to return an instance of its receiver type (%2)'
H57512855C27C: '%select{クラス|インスタンス}0 メソッド%1 は受信オブジェクトの型（%2）を返すと想定されています'
# '%select{class|instance}0 method %1 is variadic in one translation unit and not variadic in another'
HF51A27778394: '%select{クラス|インスタンス}0 メソッド%1 は1つの翻訳単位では可変長であり、別の単位ではそうではありません'
# '%select{class|protocol|category|class extension|implementation|category implementation}0 started here'
HB972B56B97CE: '%select{クラス|プロトコル|カテゴリ|クラスエクステンション|実装|カテゴリ実装}0 のここから開始'
# '%select{class|struct|interface|union|enum|enum class|enum struct}0 cannot be marked %select{<ERROR>|constexpr|consteval|constinit}1'
H6CC4F10FF6EF: '%select{クラス|構造体|インターフェース|ユニオン|enum|enum class|enum struct}0 は%select{<ERROR>|constexpr|consteval|constinit}1 修飾子を付けられません'
# '%select{class|type alias}0 template declared here'
HC92E96CB1535: '%select{クラス|型エイリアス}0 テンプレートはここに宣言されています'
# '%select{class|variable}0 template partial specialization contains %select{a template parameter|template parameters}1 that cannot be deduced; this partial specialization will never be used'
H8F8D0B49DE65: '%select{クラス|変数}0 テンプレート部分専門化は%select{推論不可能なテンプレートパラメータ|推論不可能なテンプレートパラメータ複数}1 を含んでいます；この部分専門化は使用されません'
# '%select{class|variable}0 template partial specialization does not specialize any template argument; to %select{declare|define}1 the primary template, remove the template argument list'
HC805ED783ADF: '%select{クラス|変数}0 テンプレートの部分特殊化は、テンプレート引数を特殊化していません; メインテンプレートを%select{宣言|定義}1するには、テンプレート引数リストを削除してください'
# '%select{class|variable}0 template partial specialization is not more specialized than the primary template'
HD6682742D913: '%select{クラス|変数}0 テンプレートの部分特殊化は、メインテンプレートよりも特化度が高くありません'
# '%select{codeseg|section}0 does not match previous declaration'
H9AFE01E1A06A: '%select{codeseg|section}0 の宣言が以前の宣言と一致しません'
# "%select{command line contains|AST file '%1' was built with}0 '-detailed-preprocessing-record' but %select{AST file '%1' was not built with it|it is not present on the command line}0"
H668E0E039D43: "%select{コマンドラインに '-detailed-preprocessing-record' が含まれる|ASTファイル '%1' が '-detailed-preprocessing-record' で構築された}0 が、%select{ASTファイル '%1' がそのオプションで構築されていない|コマンドラインに存在しない}0"
# "%select{command line contains|AST file '%1' was built with}0 '-undef' but %select{AST file '%1' was not built with it|it is not present on the command line}0"
H8E60AF265E55: "%select{コマンドラインに '-undef' が含まれる|ASTファイル '%1' が '-undef' で構築された}0 が、%select{ASTファイル '%1' がそのオプションで構築されていない|コマンドラインに存在しない}0"
# '%select{comparison between %diff{ ($ and $)|}0,1|arithmetic operation with operands of type %diff{ ($ and $)|}0,1|conditional operator with the second and third operands of type %diff{ ($ and $)|}0,1}2 which are pointers to non-overlapping address spaces'
H47A4B5F7D5D9: '%select{型%diff{ ($ と $)|}0,1の比較|型%diff{ ($ と $)|}0,1のオペランドを使用した算術演算|2番目と3番目のオペランドが型%diff{ ($ と $)|}0,1の条件演算子}2のいずれかが非重複アドレス空間を指すポインタです'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 from %1 to %2 converts between mismatching address spaces'
HB50BD1C6F363: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 で%1から%2へのキャストはアドレススペースが一致しません'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 from %1 to %2 is not allowed'
H0994EC770949: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 で%1から%2へのキャストは許可されていません'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 from rvalue to reference type %2'
H79F10447DC2A: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 から参照型%2へのrvalueキャスト'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2 casts away qualifiers'
H56EB9B5EABD1: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 で%1から%2へのキャストは修飾子を削除します'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2, which are not related by inheritance, is not allowed'
HC3DB71EF3442: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 で%1から%2へのキャストは継承関係がないため許可されていません'
# '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from bit-field lvalue to reference type %2'
H1DAD5B4DA5AC: '%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 からビットフィールドlvalueへの参照型%2へのキャスト'
# '%select{const_cast||||C-style cast|functional-style cast|}0 to %2, which is not a reference, pointer-to-object, or pointer-to-data-member'
H2773305E9004: '%select{const_cast||||C-style cast|functional-style cast|}0 で%2へのキャストはリファレンス、オブジェクトポインタ、データメンバーポインタでありません'
# "%select{constexpr|consteval}0 function's return type %1 is not a literal type"
H8C05F94E8F5F: '%select{constexpr|consteval}0 関数の戻り値型%1はリテラル型ではありません'
# '%select{constexpr|consteval}1 %select{function|constructor}0 never produces a constant expression'
H022CBA14DE42: '%select{constexpr|consteval}1 %select{関数|コンストラクタ}0 は定数式を生成しません'
# "%select{constexpr|consteval}2 %select{function|constructor}1's %ordinal0 parameter type %3 is not a literal type"
H6B5DAAD976BB: '%select{constexpr|consteval}2 %select{関数|コンストラクタ}1の%ordinal0引数の型%3はリテラル型ではありません'
# '%select{constructor for %1 must explicitly initialize the|implicit default constructor for %1 must explicitly initialize the|cannot use constructor inherited from base class %4;}0 %select{base class|member}2 %3 %select{which|which|of %1}0 does not have a default constructor'
HE93B407A4DE4: '%select{%1のコンストラクタはベースクラス|暗黙のデフォルトコンストラクタは%1のメンバー|ベースクラス%4から継承したコンストラクタは使用できません}0 %select{ベースクラス|メンバー}2 %3 %select{がデフォルトコンストラクタを持っていません|が明示的に初期化する必要があります|の%1にはデフォルトコンストラクタがありません}0'
# '%select{constructor for %1|implicit default constructor for %1|cannot use constructor inherited from %1:}0 must explicitly initialize the %select{reference|const}2 member %3'
H5DD624CAFF41: '%select{コンストラクタ %1|暗黙のデフォルトコンストラクタ %1|基底クラス %1 の継承コンストラクタを使用できません:}0 は明示的に %select{リファレンス|const}2 メンバー %3 を初期化する必要があります'
# '%select{constructor|destructor}1 %0 must not return void expression'
H76E14738E327: '%select{コンストラクタ|デストラクタ}1 %0 はvoid式を返すことはできません'
# '%select{const|reference}0 member %1 will never be initialized'
H67E2118A2E7C: '%select{const|リファレンス}0 メンバ%1は初期化されません'
# '%select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1 invokes deleted constructor'
HE9CE7E623BF3: '%select{変数のコピー|パラメータのコピー|テンプレートパラメータの初期化|オブジェクトの返却|ステートメント式結果の初期化|オブジェクトのスロー|メンバー部分オブジェクトのコピー|配列要素のコピー|オブジェクトのアロケーション|一時オブジェクトのコピー|ベース部分オブジェクトの初期化|ベクタ要素の初期化|値のキャプチャ}0 の%1型は削除されたコンストラクタを呼び出します'
# '%select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}1 of type %2 when binding a reference to a temporary would %select{invoke an inaccessible constructor|find no viable constructor|find ambiguous constructors|invoke a deleted constructor}0 in C++98'
H29AE4DB3DE15: '%select{コンストラクタを無効なアクセス修飾子を持つ|適切なコンストラクタが存在しない|複数の適切なコンストラクタが存在する|削除されたコンストラクタを呼び出す}0 という問題がC++98では発生します - %select{変数|パラメータ|テンプレートパラメータ|オブジェクトの返却|ステートメント式結果の初期化|オブジェクトのスロー|メンバー部分オブジェクトのコピー|配列要素のコピー|オブジェクトのアロケーション|一時オブジェクトのコピー|ベース部分オブジェクトの初期化|ベクタ要素の初期化|値のキャプチャ}1 の%2型を一時オブジェクトにバインドする際の参照'
# '%select{copy|move}0 assignment operator of %1 is implicitly deleted because field %2 is of %select{reference|const-qualified}4 type %3'
HA5E40C813D22: '%select{コピー|ムーブ}0代入演算子は、%select{参照|const修飾}4型%3のフィールド%2があるため%1で暗黙的に削除されました'
# '%select{data member %1|base class %2}0 declared here'
HC9ED4A45B57E: '%select{データメンバー %1|基底クラス %2}0 はここで宣言されています'
# '%select{data member |non-public member function |static member function |user-declared constructor|user-declared destructor|operator |nested class }0%1 is not permitted within an interface type'
H9EC34E188C56: '%select{データメンバー |非公開メンバー関数 |静的メンバー関数 |ユーザー定義コンストラクタ|ユーザー定義デストラクタ|オペレーター |ネストクラス }0%1 はインターフェース型内では許可されていません'
# '%select{declaration|definition|default argument declared|explicit specialization declared|partial specialization declared}0 here is not %select{visible|reachable|reachable|reachable|reachable|reachable}0'
H804351062C9E: '%select{宣言|定義|デフォルト引数の宣言|明示的特殊化の宣言|部分特殊化の宣言}0 はここでは%select{非表示|到達不能|到達不能|到達不能|到達不能|到達不能}0です'
# "%select{declaration|definition|default argument|explicit specialization|partial specialization}0 of %1 must be imported from module '%2' before it is required"
HC491502A3888: "%select{宣言|定義|デフォルト引数|明示的特殊化|部分特殊化}0 %1 は必要になる前にモジュール '%2' からインポートする必要があります"
# '%select{declaration|definition|default argument|explicit specialization|partial specialization}0 of %1 must be imported from one of the following modules before it is required:%2'
HA8E1DF60359B: '%select{宣言|定義|デフォルト引数|明示的特殊化|部分特殊化}0 %1 は必要になる前に以下のモジュールのいずれかからインポートする必要があります:%2'
# '%select{declaration|definition}0 of %select{struct|interface|union|class|enum}1 in a dependent scope'
H690477FDDE60: '%select{宣言|定義}0 の%select{構造体|インターフェース|共用体|クラス|列挙型}1 は依存スコープ内にあります'
# '%select{decremented|incremented}0 here'
HD8461A402F1F: '%select{ここで減算|ここで加算}0 が行われています'
# '%select{decrement|increment}0 of object of volatile-qualified type %1 is deprecated'
H57C759966E48: '%select{減算|加算}0 の volatile 修飾型%1 オブジェクトは非推奨です'
# '%select{default construction|assignment}0 of lambda is incompatible with C++ standards before C++20'
H3C92D92BB26F: '%select{デフォルト構築|代入}0 ラムダはC++20以前の標準では互換しません'
# '%select{default constructor of|constructor inherited by}0 %1 is implicitly deleted because all %select{data members|data members of an anonymous union member}2 are const-qualified'
HF80E1E94C448: '%select{%1のデフォルトコンストラクタ|匿名ユニオンメンバーの}0 %select{全データメンバ|データメンバ}2 がconst修飾されているため、暗黙に削除されました'
# '%select{default constructor of|constructor inherited by}0 %1 is implicitly deleted because field %2 of %select{reference|const-qualified}4 type %3 would not be initialized'
H3F45472DFCD6: '%select{のデフォルトコンストラクタ|継承されたコンストラクタ}0 %1 は、%select{reference|const-qualified}4 型 %3 のフィールド %2 が初期化されないため暗黙的に削除されました'
# '%select{default constructor of|copy constructor of|move constructor of|copy assignment operator of|move assignment operator of|destructor of|constructor inherited by}0 %1 is implicitly deleted because %select{base class %3|%select{||||variant }4field %3}2 %select{has %select{no|a deleted|multiple|an inaccessible|a non-trivial}4 %select{%select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|%select{default|corresponding|default|default|default}4 constructor}0|destructor}5%select{||s||}4|is an ObjC pointer}6'
H1BB10C6BA0EA: '%select{のデフォルトコンストラクタ|コピーコンストラクタ|ムーブコンストラクタ|代入演算子|ムーブ代入演算子|デストラクタ|継承されたコンストラクタ}0 %1 は、%select{基底クラス %3|%select{||||variant }4フィールド %3}2 %select{が%select{存在しない|削除済み|複数存在する|非公開|非トレイシー}4 %select{%select{デフォルトコンストラクタ|コピーコンストラクタ|ムーブコンストラクタ|代入演算子|ムーブ代入演算子|デストラクタ|%select{デフォルト|対応する|デフォルト|デフォルト|デフォルト}4 コンストラクタ}0|デストラクタ}5%select{||s||}4|ObjC ポインタです}6 のため暗黙的に削除されました'
# "%select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot be 'constexpr' in a class with virtual base class"
HAA0AD1F4C5AC: "仮想基底クラスを持つクラスでは、%select{デフォルトコンストラクタ|コピー コンストラクタ|ムーブ コンストラクタ|代入演算子|ムーブ代入演算子|デストラクタ}0 は 'constexpr' にできません"
# '%select{defaulted|deleted}0 function definitions are a C++11 extension'
H2588FE2C83FF: '%select{デフォルト化|削除化}0 関数定義はC++11拡張機能です'
# '%select{defaulted|deleted}0 function definitions are incompatible with C++98'
HE7CB963644EA: '%select{デフォルト化|削除化}0 関数定義はC++98と互換性ありません'
# "%select{definition|#undef}0 of configuration macro '%1' has no effect on the import of '%2'; pass '%select{-D%1=...|-U%1}0' on the command line to configure the module"
H20DEB068BA86: "%select{定義|#undef}0 の構成マクロ '%1' はモジュールの '%2' のインポートに影響しません; コマンドラインで '%select{-D%1=...|-U%1}0' を指定してモジュールを構成してください"
# '%select{delete|destructor}0 called on %1 that is abstract but has non-virtual destructor'
HD3B2B405330A: '%select{削除|デストラクタ}0 が抽象クラス %1 の非仮想デストラクタを呼び出しました'
# '%select{delete|destructor}0 called on non-final %1 that has virtual functions but non-virtual destructor'
HD186820BFF8C: '%select{削除|デストラクタ}0 が非最終クラス %1 の仮想関数を呼び出しましたが、非仮想デストラクタです'
# '%select{delimited|named}0 escape sequences are a %select{C++23|C2y|Clang}1 extension'
HDBE05BE4D14B: '%select{区切り文字列|名前指定}0 のエスケープシーケンスは%select{C++23|C2y|Clang}1 拡張機能です'
# '%select{delimited|named}0 escape sequences are incompatible with C++ standards before C++23'
HFB62920439FF: '%select{区切り文字列|名前指定}0 のエスケープシーケンスはC++23より前のバージョンでは使用できません'
# '%select{destination for|source of|first operand of|second operand of}0 this %1 call is a pointer to %select{|class containing a }2dynamic class %3; vtable pointer will be %select{overwritten|copied|moved|compared}4'
H63A8D05F544B: '%select{この %1 呼び出しの宛先|ソース|第一オペランド|第二オペランド}0 は動的クラス %3 の %select{|包含クラスの}2ポインタです; vtable ポインタは %select{上書きされます|コピーされます|移動されます|比較されます}4'
# '%select{destination for|source of|first operand of|second operand of}0 this %1 call is a pointer to record %2 that is not trivial to %select{primitive-default-initialize|primitive-copy}3'
HB6A0DAA8C1C8: '%select{この %1 呼び出しの宛先|ソース|第一オペランド|第二オペランド}0 は %2 レコードへのポインタですが、これが %select{プリミティブのデフォルト初期化|プリミティブのコピー}3 に対して単純ではありません'
# '%select{destination for|source of}0 this %1 call is a pointer to ownership-qualified type %2'
HEE4DB03498AC: '%select{この %1 呼び出しの宛先|ソース}0 は所有権修飾型 %2 のポインタです'
# '%select{destructor|deallocator}0 has a %select{non-throwing|implicit non-throwing}1 exception specification'
H78E56ACB6245: '%select{デストラクタ|デロケータ}0 は%select{例外なし|暗黙の例外なし}1 削除指定を持ちます'
# '%select{dictionary|array}1 subscript base type %0 is not an Objective-C object'
HE2828D54BB1B: '%select{辞書|配列}1 のサブスクリプト基底型%0 はObjective-Cオブジェクトではありません'
# '%select{equality|inequality|relational|three-way}0 comparison result unused'
H69C6598EFBD9: '%select{等価性|不等|順序|三項}0 比較結果が未使用です'
# '%select{expected an expression statement|expected built-in assignment operator|expected expression of scalar type|expected lvalue expression}0'
H7F94DE3BA105: '%select{式文が期待されます|組み込み代入演算子が期待されます|スカラ型の式が期待されます|左辺値式が期待されます}0'
# "%select{expected an expression statement|expected built-in binary or unary operator|expected unary decrement/increment operation|expected expression of scalar type|expected assignment expression|expected built-in binary operator|expected one of '+', '*', '-', '/', '&', '^', '%|', '<<', or '>>' built-in operations|expected in right hand side of expression}0"
H13014A5049BE: "%select{式文を期待|組み込みの二項または単項演算子を期待|単項増減演算子を期待|スカラ型の式を期待|代入式を期待|組み込みの二項演算子を期待|'+', '*', '-', '/', '&', '^', '%|', '<<', or '>>' の組み込み演算を期待|式の右辺で期待}0"
# '%select{expected assignment expression|expected compound statement|expected exactly two expression statements|expected in right hand side of the first expression}0'
H71EE048AAB44: '%select{代入式を期待|複合式を期待|正確に2つの式文を期待|最初の式の右辺で期待}0'
# "%select{expected compound statement|expected exactly one expression statement|expected assignment statement|expected conditional operator|expect result value to be at false expression|expect binary operator in conditional expression|expect '<', '>' or '==' as order operator|expect comparison in a form of 'x == e', 'e == x', 'x ordop expr', or 'expr ordop x'|expect lvalue for result value|expect scalar value|expect integer value|unexpected 'else' statement|expect '==' operator|expect an assignment statement 'v = x'|expect a 'if' statement|expect no more than two statements|expect a compound statement|expect 'else' statement|expect a form 'r = x == e; if (r) ...'}0"
H2BEDF1CDD9ED: "%select{複合式を期待|正確に1つの式文を期待|代入文を期待|条件演算子を期待|false式の結果値を期待|条件式の二項演算子を期待|'<' '>' '==' として順序演算子を期待|'x == e', 'e == x', 'x ordop expr', or 'expr ordop x' 形式の比較を期待|lvalueを結果値として期待|スカラ値を期待|整数値を期待|予期しない 'else' 文|'==' 演算子を期待|'v = x' 形式の代入文を期待|'if' 文を期待|最大2つの文を期待|複合文を期待|'else' 文を期待|'r = x == e; if (r) ...' 形式を期待}0"
# '%select{explicit|friend}0 specialization cannot have a trailing requires clause unless it declares a function template'
H4B8C1F1CA2BB: '%select{explicit|friend}0 スペシャル化は関数テンプレートを宣言する場合を除き、末尾のrequires句を含めることができません'
# '%select{expression|base type|declaration type|data member type|bit-field size|static assertion|fixed underlying type|enumerator value|using declaration|friend declaration|qualifier|initializer|default argument|non-type template parameter type|exception type|explicit specialization|partial specialization|__if_exists name|__if_not_exists name|lambda|block|type constraint|requirement|requires clause}0 contains%plural{0: an|:}1 unexpanded parameter pack%plural{0:|1: %2|2:s %2 and %3|:s %2, %3, ...}1'
HE9A8E0B2E8F5: '%select{式|基底型|宣言型|データメンバ型|ビットフィールドサイズ|static断言|固定基礎型|列挙子値|using宣言|friend宣言|修飾子|イニシャライザ|デフォルト引数|非型テンプレートパラメータ型|例外型|explicit特殊化|partial特殊化|__if_exists 名前|__if_not_exists 名前|lambda|block|型制約|要件|requires句}0 に%plural{0: 1つの|:}1 %plural{0:展開されていないパラメータパック|1: %2|2:%2と%3|: %2, %3, ...}1 が含まれています'
# '%select{extension|category}0 of non-parameterized class %1 cannot have type parameters'
H6F4F8CBFDF9B: '%select{拡張|カテゴリ}0 の非パラメータ化クラス %1 は型パラメータを含めることができません'
# '%select{fewer|more}0 specifiers in format string than expected'
H294968301C0D: '%select{少ない|多くの}0 書式文字列の仕様子があります'
# "%select{field width|precision}0 used with '%1' conversion specifier, resulting in undefined behavior"
H2CF9930D6217: "%select{フィールド幅|精度}0 が '%1' 変換仕様子と共に使用され、未定義動作を引き起こします"
# '%select{field|base class}0 %1 will be initialized after %select{field|base}2 %3'
HE92BDD84B944: '%select{フィールド|基底クラス}0 %1 は %select{フィールド|基底}2 %3 の後に初期化されます'
# '%select{first two|all}1 arguments to %0 must be vectors'
HF5292D19FFBC: '%select{最初の2つの|すべての}1 %0 の引数はベクタでなければなりません'
# '%select{first two|all}1 arguments to %0 must have the same type'
H648C1151AF74: '%select{最初の2つの|すべての}1 %0 の引数は同じ型でなければなりません'
# "%select{first|second|third|fourth}0 parameter of 'main' (%select{argument count|argument array|environment|platform-specific data}0) must be of type %1"
HF5B9D5CD8E73: "%select{最初の|第二の|第三の|第四の}0 'main' パラメータ (%select{引数カウント|引数配列|環境|プラットフォーム固有データ}0) は %1 型でなければなりません"
# '%select{first|second|third}0 parameter has unexpected type %1 (should be %2)'
HB94305DC6AD8: '%select{第一|第二|第三}0 パラメータは予期しない型 %1 です（%2 でなければなりません）'
# '%select{first|second}0 operand was implicitly converted to type %1'
HBF77ADC8F095: '%select{第一|第二}0 オペランドは型 %1 に暗黙変換されました'
# '%select{forward class declaration|class definition|category|extension}0 has too %select{few|many}1 type parameters (expected %2, have %3)'
HF027D432E158: '%select{フォワードクラス宣言|クラス定義|カテゴリ|エクステンション}0 の型パラメータが %select{不足|多すぎ}1 です（%2 が必要ですが %3 あります）'
# '%select{function %1 which returns const-qualified type %2 declared here|variable %1 declared const here|%select{non-|}1static data member %2 declared const here|member function %q1 is declared const here|%select{|nested }1data member %2 declared const here}0'
HA9209A7005BD: '%select{const修飾型 %2 を返す %1 関数がここに宣言されています|%1 変数が const に宣言されています|%select{非-|}1 静的データメンバ %2 が const に宣言されています|%q1 メンバ関数が const に宣言されています|%select{|ネストした }1 データメンバ %2 が const に宣言されています}0'
# '%select{function parameter|typedef}0 cannot be %select{<ERROR>|constexpr|consteval|constinit}1'
H86C3A8B0C257: '%select{関数パラメータ|typedef}0 は %select{<ERROR>|constexpr|consteval|constinit}1 にできません'
# '%select{function template|class template|variable template|type alias template|template template parameter}0 %1 declared here'
H91E08CCD64B6: '%select{関数テンプレート|クラステンプレート|変数テンプレート|型エイリアステンプレート|テンプレートテンプレートパラメータ}0 %1 がここに宣言されています'
# '%select{function with deduced return type|declaration with trailing return type}0 must be the only declaration in its group'
HA1CB6C2DD073: '%select{戻り値が推論される関数|トレーリング戻り値型付き宣言}0 はグループ内で唯一の宣言でなければなりません'
# "%select{function|block|lambda|coroutine}0 declared 'noreturn' should not return"
HBB674CBF2E79: "%select{関数|ブロック|ラムダ|コルーチン}0 に 'noreturn' 属性が付与された場合、戻り値を返すべきではありません"
# "%select{function|class|variable}0 cannot be defined in an explicit instantiation; if this declaration is meant to be a %select{function|class|variable}0 definition, remove the 'template' keyword"
HF2F19E25243A: "%select{関数|クラス|変数}0 は明示的なインスタンチエーションで定義できません；この宣言が %select{関数|クラス|変数}0 の定義を意図している場合は 'template' キーワードを削除してください"
# "%select{function|constructor|destructor|lambda|block|member initializer of constructor}0 with '%1' attribute must not %select{allocate or deallocate memory|throw or catch exceptions|have static local variables|use thread-local variables|access ObjC methods or properties}2"
H8DE43E9D40B0: "%select{関数|コンストラクタ|デストラクタ|ラムダ|ブロック|コンストラクタのメンバー初期化子}0 に '%1' 属性が付与された場合、%select{メモリの確保または解放|例外の送出またはキャッチ|静的ローカル変数の使用|スレッド局所変数の使用|ObjC メソッドまたはプロパティのアクセス}2 を行うことはできません"
# "%select{function|constructor|destructor|lambda|block|member initializer of constructor}0 with '%1' attribute must not call non-'%1' %select{function|constructor|destructor|lambda|block}2 '%3'"
HD57CFC80D164: "%select{関数|コンストラクタ|デストラクタ|ラムダ|ブロック|コンストラクタのメンバー初期化子}0 に '%1' 属性が付与された場合、非-'%1' %select{関数|コンストラクタ|デストラクタ|ラムダ|ブロック}2 '%3' を呼び出すことはできません"
# "%select{function|constructor|destructor|lambda|block|member initializer of constructor}0 with '%1' attribute must not call non-'%1' expression"
H5BD0868978EA: "%select{関数|コンストラクタ|デストラクタ|ラムダ|ブロック|コンストラクタのメンバー初期化子}0 に '%1' 属性が付与された場合、非-'%1' 式を呼び出すことはできません"
# "%select{function|constructor|destructor|lambda|block|member initializer}0 cannot be inferred '%1' because it %select{allocates or deallocates memory|throws or catches exceptions|has a static local variable|uses a thread-local variable|accesses an ObjC method or property}2"
H2867CEC6E928: "%select{関数|コンストラクタ|デストラクタ|ラムダ|ブロック|メンバー初期化子}0 の '%1' 属性は推論できません（%select{メモリを確保または解放|例外を送出またはキャッチ|静的ローカル変数を有する|スレッド局所変数を使用|ObjC メソッドまたはプロパティにアクセス}2 のため）"
# "%select{function|constructor|destructor|lambda|block|member initializer}0 cannot be inferred '%1' because it calls non-'%1' %select{function|constructor|destructor|lambda|block}2 '%3'"
H314F30794920: "%select{関数|コンストラクタ|デストラクタ|ラムダ|ブロック|メンバイニシャライザ}0 の'%1'推論は、非'%1'型%select{関数|コンストラクタ|デストラクタ|ラムダ|ブロック}2 '%3'を呼び出しているため不可能です"
# "%select{function|constructor|destructor|lambda|block}0 does not permit inference of '%1' because it is declared '%2'"
HB9A03E541F67: '%select{関数|コンストラクタ|デストラクタ|lambda|ブロック}0 は、%2 で宣言されているため、%1 の推論を許可しません'
# "%select{function|constructor|destructor|lambda|block}0 with '%1' attribute should be declared noexcept"
HB030E37D6AD6: "%select{関数|メソッド|デストラクタ|ラムダ|ブロック}0 の'%1'属性はnoexcept宣言が必要です"
# "%select{function|kernel}0 cannot be called 'main'"
H12368C59A019: "%select{関数|カーネル}0 は'main'と名付けられません"
# '%select{function|method|block}0 has been explicitly marked sentinel here'
H02C89F36F346: '%select{関数|メソッド|ブロック}0 は明示的にsentinel属性が設定されています'
# "%select{function|method}0 %1 could be declared with attribute 'noreturn'"
H2A06C5AB5A01: '%select{関数|メソッド}0 %1はnoreturn属性で宣言できる可能性があります'
# "%select{function|parameter}0 declared '[[carries_dependency]]' after its first declaration"
HA7BEBD006826: "%select{関数|パラメータ}0 の'[[carries_dependency]]'属性は最初の宣言でなければなりません"
# '%select{function|variable}0 %1 is not needed and will not be emitted'
HF8ADE574A433: '%select{関数|変数}0 %1は必要なく、コンパイル時に省略されます'
# '%select{function|variable}0 %q1 has internal linkage but is not defined'
H45C099CD2E21: '%select{関数|変数}0 %q1は内部リンクを持ちますが定義されていません'
# '%select{function|variable}0 %q1 is used but not defined in this translation unit, and cannot be defined in any other translation unit because its type does not have linkage'
H4CCCEB729733: '%select{関数|変数}0 %q1はこの翻訳単位で使用されていますが定義されておらず、他の単位でも定義できません（その型はリンク属性を持たないため）'
# '%select{global|private}0 module fragment cannot be exported'
H32D31F303DCC: '%select{グローバル|プライベート}0 モジュールフラグメントはエクスポートできません'
# '%select{hex|octal}0 escape sequence out of range'
HD900722CD654: '%select{16進|8進}0 エスケープシーケンスが範囲外です'
# '%select{if|switch}0 initialization statements are incompatible with C++ standards before C++17'
H48F2A35749E7: '%select{if|switch}0 初期化ステートメントはC++17以前では非対応です'
# '%select{implicit conversion|cast}0 of %select{%2|a non-Objective-C pointer type %2|a block pointer|an Objective-C pointer|an indirect pointer to an Objective-C pointer}1 to %3 is disallowed with ARC'
H2BE56E173B04: '%select{暗黙の変換|キャスト}0 で %select{%2|%2 を含むクラスの非Objective-Cポインタ型|ブロックポインタ|Objective-Cポインタ|Objective-Cポインタへの間接ポインタ}1 を ARC で %3 に変換することは禁止されています'
# '%select{implicit conversion|cast}0 of weak-unavailable object of type %1 to a __weak object of type %2'
H5E0A61E4DC2C: '%select{暗黙の変換|キャスト}0 で、型 %1 の weak-unavailable オブジェクトを型 %2 の __weak オブジェクトに変換しようとしました'
# '%select{implicitly |}2captured%select{| by reference}3%select{%select{ due to use|}2 here| via initialization of lambda capture %0}1'
H0BA3D7D599E5: '%select{暗黙的に |}2キャプチャ%select{|参照で}3%select{%select{ ここでの使用により| ラムダキャプチャ %0 の初期化経由で}2 |}1'
# '%select{implicit|explicit}0 instantiation first required here'
HB12903FE55DA: '%select{暗黙の|明示的な}0 インスタンス化が必要な最初の場所'
# '%select{implicit|explicit}0 instantiation of template %1 within its own definition'
H0FEA9F8C421A: '%select{暗黙の|明示的な}0 テンプレート %1 自身の定義内でインスタンス化されました'
# '%select{implicit|explicit}0 instantiation of undefined template %1'
H04E01542E9F2: '%select{暗黙の|明示的な}0 定義されていないテンプレート %1 のインスタンス化'
# "%select{incompatible|duplicate}0 directives '%1' and '%2'"
HEFD5CC9864D7: '%select{互換性のない|重複した}0 ディレクティブ "%1" と "%2"'
# '%select{instance variable|property}2 with %0 attribute must be an object type (invalid %1)'
HFD8E12A874BC: '%select{インスタンス変数|プロパティ}2 の %0 属性はオブジェクト型でなければなりません（無効な %1）'
# '%select{instance|class}1 method %0 not found ; did you mean %2?'
H113C6B0985AF: '%select{インスタンス|クラス}1 メソッド %0 が見つかりません；%2 を指定した意図でしたか？'
# '%select{integer|integral}1 constant expression must have %select{integer|integral or unscoped enumeration}1 type, not %0'
H07847569345A: '%select{整数|積分}1 定数式は %select{整数|積分またはスコープ外列挙}1 型でなければなりませんが、%0 ではありません'
# "%select{interrupt service routine|function with attribute 'no_caller_saved_registers'}0 should only call a function with attribute 'no_caller_saved_registers' or be compiled with '-mgeneral-regs-only'"
HE2C243372C8E: '%select{割り込みサービスルーチン|属性 "no_caller_saved_registers" を持つ関数}0 は、属性 "no_caller_saved_registers" を持つ関数か "-mgeneral-regs-only" でコンパイルされた関数のみを呼び出す必要があります'
# "%select{invalid use of|unknown}2 attribute subject matcher sub-rule '%0'; '%1' matcher %select{does not support sub-rules|supports the following sub-rules: %3}2"
H8BFF482F0D6A: "%select{属性対象の無効な使用|不明な}2 マッチャー副規則 '%0'; '%1' マッチャー %select{サブ規則をサポートしていません|次のサブ規則をサポートします: %3}2"
# "%select{invalid value '%0'; must be positive|value '%0' is too large}1"
HEC3DA4A69943: '%select{無効な値 "%0"；正の値である必要があります|値 "%0" が大きすぎます}1'
# "%select{invalid|missing}0 option%select{ %1|}0; expected 'contract', 'reassociate', 'reciprocal', or 'exceptions'"
H280D64C6E2E8: '%select{無効な|不足する}0 オプション%select{ %1|}0；"contract", "reassociate", "reciprocal", または "exceptions" を指定してください'
# '%select{invalid|missing}0 option%select{ %1|}0; expected vectorize, vectorize_width, interleave, interleave_count, unroll, unroll_count, pipeline, pipeline_initiation_interval, vectorize_predicate, or distribute'
HC3AB036EF44A: '%select{無効な|存在しない}0 オプション%select{ %1|}0; ベクタライズ、ベクタライズ幅、インターリーブ、インターリーブ回数、アンロール、アンロール回数、パイプライン、パイプライン初期遅延、ベクタライズ予測子、またはディストリビュート が期待されます'
# '%select{in|co|contra}0variant type parameter %1 conflicts with previous %select{in|co|contra}2variant type parameter %3'
H893590D91D8F: '%select{in|co|contra}0variant 型パラメータ %1 は、前の %select{in|co|contra}2variant 型パラメータ %3 と衝突しています'
# '%select{left |right |}0operand to %select{assignment|compound assignment|increment|decrement}1 expression must be %select{an l-value|of scalar type (was %3)}2'
H115469577E3D: '%select{左|右|}0オペランドの%select{代入|複合代入|インクリメント|デクリメント}1式は%select{左辺値である必要があります|スカラ型でなければなりません（実際は%3）}2'
# '%select{left|right}0 side of operator converted from negative value to unsigned: %1'
H1DC6B6DA95C3: '%select{左|右}0 オペランドを符号なし値に変換: %1'
# '%select{left|right}1 operand to ? is void, but %select{right|left}1 operand is of type %0'
H8125EE82CC5A: '%select{右|左}1 オペランドが void 型ですが、%select{左|右}1 オペランドは型 %0 です'
# '%select{loading directly from|assigning directly to}0 pointer to type %1 requires cl_khr_fp16. Use vector data %select{load|store}0 builtin functions instead'
H66CF7FCAA26B: '%select{ポインタから直接読み取り|ポインタに直接代入}0 の場合、型 %1 は cl_khr_fp16 が必要です。ベクタデータ %select{読み出し|書き出し}0 ビルトイン関数を使用してください'
# '%select{local variable|parameter|typedef}0 %1 cannot be declared __module_private__'
H1DE6DC0BF8C5: '%select{ローカル変数|パラメータ|typedef}0 %1 は __module_private__ を宣言できません'
# "%select{map type '%1' is not allowed|map type must be specified}0 for '#pragma omp %2'"
HA49CE3340880: "%select{マップ型 '%1' は許可されていません|マップ型を指定する必要があります}0 '#pragma omp %2' に対して"
# "%select{missing '#include'|missing '#include %3'}2; %select{||default argument of |explicit specialization of |partial specialization of }0%1 must be %select{declared|defined|defined|declared|declared}0 before it is used"
H0EC06C773CD9: '%select{#include %3 の欠落|#include の欠落}2; %select{||デフォルト引数の |明示的特殊化の |部分特殊化の }0%1 は使用前に%select{宣言|定義|定義|宣言|宣言}0 する必要があります'
# '%select{no_destroy|always_destroy}0 attribute can only be applied to a variable with static or thread storage duration'
H7D17D7EDA6B0: '%select{no_destroy|always_destroy}0 属性は、静的またはスレッド ストレージ期間を持つ変数にのみ適用できます'
# '%select{non-constexpr|constexpr|consteval}1 declaration of %0 follows %select{non-constexpr|constexpr|consteval}2 declaration'
H2DCC831B3932: '%select{非constexpr|constexpr|consteval}1 宣言 %0 は %select{非constexpr|constexpr|consteval}2 宣言に続きました'
# '%select{non-constexpr|undefined}0 %select{function|constructor}1 %2 cannot be used in a constant expression'
H338EAA31FD42: '%select{非constexpr|未定義}0 %select{関数|コンストラクタ}1 %2 は定数式で使用できません'
# '%select{non-const|volatile}0 lvalue reference %diff{to type $ cannot bind to a temporary of type $|cannot bind to incompatible temporary}1,2'
HD89DCBC20587: '%select{非const|volatile}0 lvalue 参照 %diff{型 $ は、型 $ の一時オブジェクトにバインドできません|不整合な一時オブジェクトにバインドできません}1,2'
# '%select{non-const|volatile}0 lvalue reference %diff{to type $ cannot bind to a value of unrelated type $|cannot bind to a value of unrelated type}1,2'
H1777D1633EE8: '%select{非const|volatile}0 lvalue 参照 %diff{型 $ は、無関係な型 $ にバインドできません|無関係な型にバインドできません}1,2'
# '%select{non-const|volatile}0 lvalue reference to type %1 cannot bind to an initializer list temporary'
H3CF62E12AA3E: '%select{非const|volatile}0 lvalue参照型%1は、初期化子リストの一時オブジェクトにバインドできません'
# '%select{non-const|volatile}0 reference cannot bind to bit-field%select{| %1}2'
H8AF09902E67B: '%select{非const|volatile}0参照はビットフィールド%select{| %1}2にバインドできません'
# '%select{non-const|volatile}0 reference cannot bind to matrix element'
HA82833F246FF: '%select{非const|volatile}0参照はマトリックス要素にバインドできません'
# '%select{non-const|volatile}0 reference cannot bind to vector element'
H6E26FD01A944: '%select{非const|volatile}0参照はベクタ要素にバインドできません'
# '%select{non-integral type %0|%0}1 is an invalid underlying type'
HAB3E494D65F5: '%select{非整数型%0|%0}1は無効な基底型です'
# '%select{non-kernel function|function scope}0 variable cannot be declared in %1 address space'
H0866366952CF: '%select{非カーネル関数|関数スコープ}0変数は%1アドレス空間で宣言できません'
# "%select{non-member function|static member function|explicit object member function|deduction guide}0 %select{of type %2 |}1cannot have '%3' qualifier"
HFB817CBCD184: "%select{非メンバ関数|静的メンバ関数|明示的オブジェクトメンバ関数|型推論ガイド}0 %select{の型%2 |}1は'%3'修飾子を持つことはできません"
# '%select{non-member|member}0 %select{<ERROR>|equality|three-way|equality|relational}1 comparison operator must have %select{2|1}0 parameters'
HB5C9D99264DA: '%select{非メンバ|メンバ}0 %select{<ERROR>|等価|3-way|等価|関係}1比較演算子は%select{2|1}0パラメータが必要です'
# '%select{non-member|static member|non-static member}0 function cannot perform a tail call to %select{non-member|static member|non-static member|pointer-to-member}1 function%select{| %3}2'
HE869F55E570F: '%select{非メンバ|静的メンバ|非静的メンバ}0関数は%select{非メンバ|静的メンバ|非静的メンバ|メンバポインタ}1関数%select{| %3}2への尾呼び出しを実行できません'
# "%select{non-pointer|function pointer|void pointer}0 argument to '__builtin_launder' is not allowed"
H5F5CB4F84C85: "%select{非ポインタ|関数ポインタ|voidポインタ}0引数の'%__builtin_launder'は許可されません"
# "%select{non-struct type|non-class type|non-union type|non-enum type|typedef|type alias|template|alias template|template template argument}1 %0 cannot be referenced with the '%select{struct|interface|union|class|enum}2' specifier"
HA353FC8D883A: "%select{非構造体型|非クラス型|非ユニオン型|非列挙型|typedef|型エイリアス|テンプレート|エイリアステンプレート|テンプレートテンプレート引数}1 %0は'%select{struct|interface|union|class|enum}2'修飾子で参照できません"
# '%select{non-virtual|virtual}0 derivation here'
H7895E4BCBED9: '%select{非仮想|仮想}0継承ここ'
# "%select{non-|function }0pointer argument to '__builtin_is_within_lifetime' is not allowed"
HEC6E2A0FBA29: "%select{非|関数 }0ポインタ引数の'%__builtin_is_within_lifetime'は許可されません"
# "%select{no|too many}0 integer expression arguments provided to OpenACC 'num_gangs' %select{|clause: '%1' directive expects maximum of %2, %3 were provided}0"
HDF54FE517944: "%select{0|過剰}0の整数式引数がOpenACC 'num_gangs' %select{|句'%1'ディレクティブは最大%2を受け付けますが、%3が提供されました}0に渡されました"
# "%select{orphaned 'omp section' directives are prohibited, it|'omp section' directive}0 must be closely nested to a sections region%select{|, not a %1 region}0"
HF07F4A64D372: "%select{孤立した'omp section'ディレクティブは禁止されています。それ|'omp section'ディレクティブ}0はsections領域に直近でネストする必要があります%select{|、%1領域ではありません}0"
# "%select{overridden|current}0 method is explicitly declared 'instancetype'%select{| and is expected to return an instance of its class type}0"
HB89C11914779: "%select{上書き|現在}0メソッドは明示的に'instancetype'として宣言されています%select{|、そのクラス型のインスタンスを返す必要があります}0"
# "%select{overridden|current}0 method is part of the '%select{|alloc|copy|init|mutableCopy|new|autorelease|dealloc|finalize|release|retain|retainCount|self}1' method family%select{| and is expected to return an instance of its class type}0"
HB76B1E081BAA: "%select{上書きされた|現在の}0 メソッドは '%select{|alloc|copy|init|mutableCopy|new|autorelease|dealloc|finalize|release|retain|retainCount|self}1' メソッドファミリーの一部です%select{|、そのクラス型のインスタンスを返す必要があります}0"
# '%select{parameters|function return value}0 cannot have __fp16 type; did you forget * ?'
H3BDED28AD784: '%select{パラメータ|関数の戻り値}0 に __fp16 型は使用できません; * を忘れたのでしょうか？'
# '%select{parameter|non-static data member}3 %0 %select{|of %1 }3shadows member inherited from type %2'
H35412B47BBE2: '%select{パラメータ|非静的データメンバ}3 %0 %select{|の %1 における}3 は、型 %2 から継承されたメンバーを隠蔽しています'
# '%select{parameter|parameter pack}0 declared here'
H2699C14A1A0C: '%select{パラメータ|パラメータパック}0 はここに宣言されています'
# "%select{parenthesize the third argument|cast the second argument to 'int'}0 to silence"
H798E3A404637: "%select{第三引数を括弧でくくる|第二引数を'int'にキャストする}0 で警告を抑制できます"
# '%select{partial specialization|explicit specialization|explicit instantiation}0 of alias templates is not permitted'
H336DD87FEE99: '%select{部分特別化|明示的特別化|明示的インスタンチエーション}0 はエイリアステンプレートでは許可されていません'
# '%select{pointers|references}0 are unsupported in HLSL'
H134DDEB0FD66: '%select{ポインタ|リファレンス}0 はHLSLでサポートされていません'
# '%select{pointers|references}0 to functions are not allowed'
H30519C3FCFC8: '%select{ポインタ|リファレンス}0 は関数には使用できません'
# '%select{pointer|block pointer|member pointer}0 is missing a nullability type specifier (_Nonnull, _Nullable, or _Null_unspecified)'
HF29961D95705: '%select{ポインタ|ブロックポインタ|メンバーポインタ}0 に nullability 型修飾子 (_Nonnull, _Nullable, or _Null_unspecified) が指定されていません'
# '%select{pointer|reference}0 to %select{|subobject of }1%select{temporary|%3}2 is not a constant expression'
H7F2DE7357BB3: '%select{ポインタ|リファレンス}0 は %select{|サブオブジェクトの}1%select{一時オブジェクト|%3}2 には定数式ではありません'
# "%select{pointer|reference}0 to %select{|subobject of }1%select{type_info object|string literal|temporary object|predefined '%3' variable}2 is not allowed in a template argument"
HD8CE51EB9A3E: "%select{ポインタ|リファレンス}0 は %select{|サブオブジェクトの}1%select{type_info オブジェクト|文字列リテラル|一時オブジェクト|予約済み'%3'変数}2 にはテンプレート引数では許可されていません"
# '%select{pointer|reference}0 to %select{|subobject of }1heap-allocated object is not a constant expression'
H9D1E7F5B4FD5: '%select{ポインタ|リファレンス}0 は %select{|サブオブジェクトの}1ヒープ割り当てオブジェクトには定数式ではありません'
# '%select{pointer|reference}0 to WebAssembly reference type is not allowed'
HECDCB166B532: '%select{ポインタ|リファレンス}0 はWebAssembly リファレンスタイプには使用できません'
# '%select{pointer|reference}0 to a consteval declaration is not a constant expression'
H8FC8E4B28636: '%select{ポインタ|リファレンス}0 はconsteval宣言には定数式ではありません'
# '%select{pointer|reference}1 to non-const type %0 with no explicit ownership'
H0FF342784C44: '%select{ポインタ|リファレンス}1 は非const型 %0 に明示的な所有権修飾がありません'
# '%select{precompiled header|module}0 uses __DATE__ or __TIME__'
H2637E05CCFD6: '%select{プリコンパイルドヘッダー|モジュール}0 で__DATE__または__TIME__を使用しています'
# '%select{program scope|static local|extern}0 variable must reside in %1 address space'
H8250A4383E97: '%select{プログラムスコープ|静的ローカル|extern}0 変数は %1 アドレス空間に配置する必要があります'
# '%select{property|instance variable}0 access cannot be qualified with %1'
H8153C2BE3904: '%select{プロパティ|インスタンス変数}0のアクセスに%1で修飾することはできません'
# "%select{public|private|project}1 umbrella header file not found in input: '%0'"
HFB4B45B92460: "%select{public|private|project}1のアンビラヘダー・ファイルが入力に見つかりません: '%0'"
# "%select{qualifier in |static |}0array size %select{||'[*] '}0is a C99 feature"
H5561702CDE0D: "%select{修飾子付き|static |}0配列サイズ%select{||'[*] '}0はC99の機能です"
# "%select{qualifier in |static |}0array size %select{||'[*] '}0is a C99 feature, not permitted in C++"
HD9EDD0C87400: "%select{修飾子付き|static |}0配列サイズ%select{||'[*] '}0はC++では許可されていないC99の機能です"
# '%select{read of|read of|assignment to|increment of|decrement of|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>}0 volatile %select{temporary|object %2|member %2}1 is not allowed in a constant expression'
H88BF34501395: '%select{読み取り|読み取り|代入|インクリメント|デクリメント|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>}0 volatile %select{一時オブジェクト|オブジェクト %2|メンバ %2}1は定数式では許可されません'
# '%select{read of|read of|assignment to|increment of|decrement of|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>}0 volatile-qualified type %1 is not allowed in a constant expression'
HFA8AACB1DC9D: '%select{読み取り|読み取り|代入|インクリメント|デクリメント|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>|<ERROR>}0 volatile修飾型%1は定数式では許可されません'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of subobject of|destruction of|read of}0 %select{object outside its lifetime|uninitialized object}1 is not allowed in a constant expression'
H030F1EA383B2: '%select{読み取り|読み取り|代入|インクリメント|デクリメント|メンバ呼び出し|dynamic_cast|typeid適用|サブオブジェクトの構築|破棄|読み取り}0 %select{そのライフタイム外のオブジェクト|初期化されていないオブジェクト}1は定数式では許可されません'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of subobject of|destruction of|read of}0 member %1 of union with %select{active member %3|no active member}2 is not allowed in a constant expression'
HAA36C87281CE: '%select{読み取り|読み取り|代入|インクリメント|デクリメント|メンバ呼び出し|dynamic_cast|typeid適用|構築|破棄|読み取り}0 ユニオンの%select{アクティブメンバ %3があるとき|アクティブメンバがないとき}2メンバ%1は定数式では許可されません'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 %select{temporary|variable}1 whose %plural{8:storage duration|:lifetime}0 has ended'
H1E2EE7FC7CDC: '%select{読み取り|読み取り|代入|インクリメント|デクリメント|メンバ呼び出し|dynamic_cast|typeid適用|構築|破棄|読み取り}0 %plural{8:ストレージ期間|:ライフタイム}0が終了した%select{一時|変数}1'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 dereferenced null pointer is not allowed in a constant expression'
H22FE9FDFDD6D: '%select{読み取り|読み取り|代入|インクリメント|デクリメント|メンバ呼び出し|dynamic_cast|typeid適用|構築|破棄|読み取り}0 NULLポインタの参照は定数式では許可されません'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 dereferenced one-past-the-end pointer is not allowed in a constant expression'
H0D344CA7C10F: '%select{読み取り|読み取り|代入|インクリメント|デクリメント|メンバ呼び出し|dynamic_cast|typeid適用|構築|破棄|読み取り}0 配列末尾の次のポインタ参照は定数式では許可されません'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 element of array without known bound is not allowed in a constant expression'
H5DD079C28614: '%select{読み取り|読み取り|代入|インクリメント|デクリメント|メンバ呼び出し|dynamic_cast|typeid適用|構築|破棄|読み取り}0 知らない境界の配列要素は定数式では許可されません'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 heap allocated object that has been deleted'
H0F4326DA1EA9: '%select{読み取り|読み取り|代入|インクリメント|デクリメント|メンバ呼び出し|dynamic_cast|typeid適用|構築|破棄|読み取り}0 削除された動的オブジェクト'
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 mutable member %1 is not allowed in a constant expression'
H08EBC2661AFA: '%select{読み取り|読み取り|代入|インクリメント|デクリメント|メンバ呼び出し|dynamic_cast|typeid適用|構築|破棄|読み取り}0 ムーテーブルメンバ%1は定数式では許可されません'
# "%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 object '%1' whose value is not known"
H2547ED9973E0: "%select{読み取り|読み取り|代入|インクリメント|デクリメント|メンバ呼び出し|dynamic_cast|typeid適用|構築|破棄|読み取り}0 値が不明なオブジェクト'%1'"
# '%select{read of|read of|assignment to|increment of|decrement of|member call on|dynamic_cast of|typeid applied to|construction of|destruction of|read of}0 temporary is not allowed in a constant expression outside the expression that created the temporary'
H1A04D5C0C6D4: '%select{読み取り|読み取り|代入|インクリメント|デクリメント|メンバ呼び出し|dynamic_cast|typeid適用|構築|破棄|読み取り}0 生成式の外では一時オブジェクトは定数式では許可されません'
# '%select{reading|writing}1 the value pointed to by %0 requires holding %select{any mutex|any mutex exclusively}1'
H20B2C79559EA: '%select{読み取り|書き込み}1 %0が指す値を処理するには%select{任意のミューテックス|排他的ミューテックス}1を保持する必要があります'
# '%select{reading|writing}1 variable %0 requires holding %select{any mutex|any mutex exclusively}1'
HAB41C50F5547: '%select{読み取り|書き込み}1 変数%0を処理するには%select{任意のミューテックス|排他的ミューテックス}1を保持する必要があります'
# "%select{reading|writing}3 the value pointed to by %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
HA3CF53D5D321: "%select{読み取り|書き込み}3 %1が指す値を処理するには%0 %select{'%2'|'%2'排他}3を保持する必要があります"
# "%select{reading|writing}3 variable %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
HBF61FE4FFCA3: "%select{読み取り|書き込み}3 変数%1を処理するには%0 %select{'%2'|'%2'排他}3を保持する必要があります"
# "%select{reference|backing array for 'std::initializer_list'}2 %select{|subobject of }1member %0 %select{binds to|is}2 a temporary object whose lifetime is shorter than the lifetime of the constructed object"
H31A36503387B: '%select{参照|std::initializer_listのバックイング配列}2 %select{|メンバー %0 のサブオブジェクト}1 %select{はバインドされます|は}2 、構築されたオブジェクトの生存期間よりも短い一時オブジェクトです'
# "%select{reference|backing array for 'std::initializer_list'}2 %select{|subobject of }1member %0 %select{binds to|is}2 a temporary object whose lifetime would be shorter than the lifetime of the constructed object"
H54C5751F42B3: '%select{参照|std::initializer_listのバックイング配列}2 %select{|メンバー %0 のサブオブジェクト}1 %select{はバインドされます|は}2 、構築されたオブジェクトの生存期間よりも短くなる可能性のある一時オブジェクトです'
# '%select{reference|pointer}0 member declared here'
H8AC5A0A64CFD: '%select{参照|ポインタ}0 型のメンバーがここに宣言されています'
# '%select{reinterpret_cast|C-style cast}0 from %1 to %2 changes address space of nested pointers'
HDAB148B74E30: '%select{reinterpret_cast|Cスタイルキャスト}0 による%1から%2への変換により、ネストされたポインタのアドレス空間が変更されます'
# '%select{reinterpret_cast|dynamic_cast|%select{this conversion|cast that performs the conversions of a reinterpret_cast}1|cast from %1}0 is not allowed in a constant expression%select{| in C++ standards before C++20||}0'
H1688ED0E5178: '%select{reinterpret_cast|dynamic_cast|%select{this conversion|cast that performs the conversions of a reinterpret_cast}1|cast from %1}0 は定数式内で使用できません%select{| (C++20未満)||}0'
# '%select{remainder|division}0 by zero is undefined'
HDDF6DBF3AFB2: '%select{余り|除算}0 をゼロで実行することは未定義です'
# '%select{returning|passing}0 a VL-dependent argument %select{from|to}0 a function with a different streaming-mode is undefined behaviour when the streaming and non-streaming vector lengths are different at runtime'
HD835E99E7B94: '%select{戻す|渡す}0 VL依存の引数%select{から|へ}0 ストリーミングモードの異なる関数間での操作は、実行時のストリーミングと非ストリーミングベクターレングスが異なる場合、未定義動作です'
# '%select{returning|passing}0 a VL-dependent argument %select{from|to}0 a locally streaming function is undefined behaviour when the streaming and non-streaming vector lengths are different at runtime'
H78DE8F398FA2: '%select{戻す|渡す}0 VL依存の引数%select{から|へ}0 ローカルストリーミング関数間での操作は、実行時のストリーミングと非ストリーミングベクターレングスが異なる場合、未定義動作です'
# '%select{return|parameter|variable|field|instance variable|synthesized instance variable}0 type %1 is an abstract class'
H83DAE33A1A29: '%select{戻り値|パラメータ|変数|フィールド|インスタンス変数|合成インスタンス変数}0 の型%1は抽象クラスです'
# "%select{self-|array |pointer }0comparison always evaluates to %select{a constant|true|false|'std::strong_ordering::equal'}1"
H25C7EE9B164E: "%select{自己-|配列 |ポインタ }0比較は常に%select{定数|true|false|'std::strong_ordering::equal'}1に評価されます"
# "%select{shader model|Vulkan environment|shader stage}0 '%1' in target '%2' is invalid for HLSL code generation"
H559D5EF03AE6: "%select{シェーダーモデル|Vulkan環境|シェーダーステージ}0 '%1' はターゲット'%2'でHLSLコード生成に無効です"
# "%select{shader model|Vulkan environment|shader stage}0 is required as %select{OS|environment}1 in target '%2' for HLSL code generation"
H2955A7AC1204: "%select{シェーダーモデル|Vulkan環境|シェーダーステージ}0 は、ターゲット'%2'のHLSLコード生成において%select{OS|環境}1として必須です"
# '%select{signed value|extra discriminator|blended pointer|blended integer}0 must have %select{pointer|integer|pointer or integer}1 type; type here is %2'
HA4822404707C: '%select{符号付き値|追加の判別子|ブレンデッドポインタ|ブレンデッド整数}0 は%select{ポインタ|整数|ポインタまたは整数}1型である必要があります; ここでは%2型です'
# "%select{signed |}0'size_t' literal is out of range of possible %select{signed |}0'size_t' values"
HADACA5CF45B7: "%select{符号付き |}0'size_t'リテラルは、可能な%select{符号付き |}0'size_t'値の範囲外です"
# '%select{signed|unsigned}0 _BitInt must have a bit size of at least %select{2|1}0'
H866585566251: '%select{符号付き|符号なし}0 _BitIntは少なくとも%select{2|1}0ビットのビットサイズを指定する必要があります'
# '%select{signed|unsigned}0 _BitInt of bit sizes greater than %1 not supported'
HB66515AEE2F3: '%select{符号付き|符号なし}0 _BitIntの%1ビットを超えるビットサイズはサポートされていません'
# "%select{source|destination}2 of '%select{%select{memcpy|wmemcpy}1|%select{memmove|wmemmove}1}0' is %3"
H752C91AB4DE4: '%select{%select{memcpy|wmemcpy}1|%select{memmove|wmemmove}1}0の%select{ソース|デスティネーション}2が%3です'
# "%select{statement after '#pragma omp %1' must be a for loop|expected %2 for loops after '#pragma omp %1'%select{|, but found only %4}3}0"
H5AE78EDFB051: '%select{#pragma omp %1後のステートメントはforループでなければなりません|#pragma omp %1後の%2ループが期待されます%select{|、しかし%4しか見つかりませんでした}3}0'
# '%select{statement|directive}0 outside teams construct here'
HCEC20E30EFC9: '%select{ステートメント|ディレクティブ}0 がチーム構造体外に存在しています'
# "%select{static data member is predetermined as shared|variable with static storage duration is predetermined as shared|loop iteration variable is predetermined as private|loop iteration variable is predetermined as linear|loop iteration variable is predetermined as lastprivate|constant variable is predetermined as shared|global variable is predetermined as shared|non-shared variable in a task construct is predetermined as firstprivate|variable with automatic storage duration is predetermined as private}0%select{|; perhaps you forget to enclose 'omp %2' directive into a parallel or another task region?}1"
HF1446F769957: "%select{静的データメンバは共有が予定されています|静的ストレージ期間の変数は共有が予定されています|ループ反復変数はprivateが予定されています|ループ反復変数はlinearが予定されています|ループ反復変数はlastprivateが予定されています|定数変数は共有が予定されています|グローバル変数は共有が予定されています|タスク構造体内の非共有変数はfirstprivateが予定されています|自動ストレージ期間の変数はprivateが予定されています}0%select{|; おそらく'omp %2'ディレクティブを並行またはタスク構造体内に含めていませんか？}1"
# "%select{string|character|boolean|numeric}0 literal must be prefixed by '@' in a collection"
H437BC3E10750: "%select{文字列|文字|論理値|数値}0 リテラルはコレクション内では'@'でプレフィックスする必要があります"
# "%select{string|numeric}0 literal must be prefixed by '@'"
HE32E641B2BF1: "%select{文字列|数値}0 リテラルは'@'でプレフィックスする必要があります"
# '%select{struct|interface|class}0 with virtual base %plural{1:class|:classes}1 is not a literal type'
H74349A7BD7CA: '%select{struct|interface|class}0 の仮想基底 %plural{1:class|:classes}1 を持つものはリテラル型ではありません'
# '%select{struct|interface|class}0%select{| template}1 %2 was previously declared as a %select{struct|interface|class}3%select{| template}1; this is valid, but may result in linker errors under the Microsoft C++ ABI'
H2D10AD8D0564: '%select{struct|interface|class}0%select{|テンプレート}1 %2 は以前 %select{struct|interface|class}3%select{|テンプレート}1 として宣言されていました; これは有効ですが、Microsoft C++ ABI ではリンカーエラーが発生する可能性があります'
# '%select{struct|interface|union|class|enum}0 %1 does not declare any constructor to initialize its non-modifiable members'
HAB227F7E6966: '%select{struct|interface|union|class|enum}0 %1には、その変更不可メンバーを初期化するコンストラクタが宣言されていません'
# '%select{struct|union}0 kernel parameters may not contain pointers'
H1723C50B8752: '%select{struct|union}0 カーネルパラメータにはポインタを含めることはできません'
# '%select{struct|union}0 without named members is a GNU extension'
HBECD0A183C46: 'メンバー名を持たない %select{struct|union}0 はGNU拡張です'
# '%select{subtraction|addition}0 of address-of-label expressions is not supported with ptrauth indirect gotos'
H131327EB0D0D: 'ptrauth間接gotoでアドレスオブラベル式の%select{減算|加算}0 はサポートされていません'
# '%select{template type|non-type template|template template}0 parameter%select{| pack}1 conflicts with previous %select{template type|non-type template|template template}0 parameter%select{ pack|}1'
HACD51B91D6D5: '%select{テンプレート型|非型テンプレート|テンプレートテンプレート}0 パラメータ%select{|パック}1 は前の %select{テンプレート型|非型テンプレート|テンプレートテンプレート}0 パラメータ%select{パック|}1 と競合します'
# '%select{template type|non-type template|template template}0 parameter%select{| pack}1 does not match %select{template type|non-type template|template template}0 parameter%select{ pack|}1 in template argument'
H42D8D01F5E06: '%select{テンプレート型|非型テンプレート|テンプレートテンプレート}0 パラメータ%select{|パック}1 はテンプレート引数の %select{テンプレート型|非型テンプレート|テンプレートテンプレート}0 パラメータ%select{パック|}1 と一致しません'
# '%select{template|partial|member}0 specialization cannot be declared __module_private__'
H0A90D5264D30: '%select{テンプレート|部分|メンバー}0 特殊化は__module_private__属性を指定できません'
# '%select{temporary %select{whose address is used as value of|%select{|implicitly }2bound to}4 %select{%select{|reference }4member of local variable|local %select{variable|reference}4}1|array backing %select{initializer list subobject of local variable|local initializer list}1}0 %select{%3 |}2will be destroyed at the end of the full-expression'
H1685FEE7827D: '%select{一時オブジェクト %select{のアドレスが値として使用されている|%select{|暗黙に }2束縛されている}4 %select{%select{|リファレンス }4メンバのローカル変数|ローカル %select{変数|リファレンス}4}1|配列の %select{ローカル変数の初期化リストサブオブジェクト|ローカル初期化リスト}1}0 %select{%3 |}2は、完全式の終了時に破棄されます'
# "%select{the message|the expression}0 in %select{a static assertion|this asm operand}0 must be a string literal or an object with 'data()' and 'size()' member functions"
H320EEB9B1530: "%select{メッセージ|式}0 は%select{静的アサーション|このアセンブリオペランド}0 で文字列リテラル、または'data()'と'size()'メンバ関数を持つオブジェクトである必要があります"
# '%select{the message|the expression}0 in %select{a static assertion|this asm operand}0 must be produced by a constant expression'
H9571480E2335: '%select{メッセージ|式}0 は%select{静的アサーション|このアセンブリオペランド}0 で定数式でなければなりません'
# "%select{the message|the expression}0 in %select{a static assertion|this asm operand}0 must have a '%select{size|data}1()' member function returning an object convertible to '%select{std::size_t|const char *}1'"
HE077A8EBD022: "%select{メッセージ|式}0 は%select{静的アサーション|このアセンブリオペランド}0 で'%select{size|data}1()'メンバ関数を所有し、'%select{std::size_t|const char *}1'に変換可能なオブジェクトを返す必要があります"
# '%select{the message|the expression}0 in %select{this static assertion|this asm operand}0 is not a constant expression'
H1136016D414E: '%select{メッセージ|式}0 は%select{この静的アサーション|このアセンブリオペランド}0 で定数式ではありません'
# '%select{too few|too many}0 template arguments for %select{class template|function template|variable template|alias template|template template parameter|concept|template}1 %2'
HA3BFC0466346: '%select{テンプレート引数が少なすぎます|テンプレート引数が多すぎます}0 %select{クラステンプレート|関数テンプレート|変数テンプレート|エイリアステンプレート|テンプレートテンプレートパラメータ|コンセプト|テンプレート}1 %2'
# '%select{too few|too many}0 template parameters in template %select{|template parameter }1redeclaration'
H2FC8E4427754: '%select{テンプレートパラメータが少なすぎます|テンプレートパラメータが多すぎます}0 テンプレート %select{|テンプレートパラメータ }1 再宣言'
# '%select{too few|too many}0 template parameters in template template argument'
HEDDF73011D6C: '%select{テンプレートパラメータが少なすぎます|テンプレートパラメータが多すぎます}0 テンプレートテンプレート引数'
# '%select{too many|too few}0 elements in vector %select{initialization|operand}3 (expected %1 elements, have %2)'
HEB48F48C2E39: 'ベクトル%select{初期化|演算子}3の要素数が%select{多すぎ|少なすぎ}0です（%1要素が必要ですが%2要素があります）'
# '%select{type tag|argument}0 index %1 is greater than the number of arguments specified'
H7C0418F179E9: '%select{型タグ|引数}0のインデックス%1は指定された引数の数を超えています'
# '%select{typedef|type alias|type alias template}0 redefinition with different types%diff{ ($ vs $)|}1,2'
H7F72DD3ED811: '%select{typedef|type alias|type alias template}0の再定義では異なる型が指定されています%diff{ ($2 vs $1)|}1,2'
# '%select{uninitialized use occurs|variable is captured by block}0 here'
H80571A54148A: '%select{未初期化の使用がここに発生|ブロックで変数がキャプチャされました}0'
# '%select{unknown|unsupported}0 machine mode %1'
HB579643BB1CB: '%select{不明な|非対応の}0マシンモード %1'
# '%select{unsafe pointer operation|unsafe pointer arithmetic|unsafe buffer access|function introduces unsafe buffer manipulation|unsafe invocation of %1|field %1 prone to unsafe buffer manipulation}0'
HD969AD0BDB13: '%select{危険なポインタ操作|危険なポインタ算術|危険なバッファアクセス|関数が危険なバッファ操作を導入|危険な%1の呼び出し|%1フィールドがバッファ操作に脆弱}0'
# "%select{unsupported|duplicate|unknown}0%select{| CPU| tune CPU}1 '%2' in the '%select{target|target_clones|target_version}3' attribute string;"
H8412993B41A2: "%select{サポートされていない|重複した|不明な}0%select{|CPU| tune CPU}1 '%2' が'%select{target|target_clones|target_version}3'属性文字列に含まれています;"
# "%select{unsupported|duplicate|unknown}0%select{| CPU| tune CPU}1 '%2' in the '%select{target|target_clones|target_version}3' attribute string; '%select{target|target_clones|target_version}3' attribute ignored"
H952DC46C8259: "%select{サポートされていない|重複した|不明な}0%select{|CPU| tune CPU}1 '%2' が'%select{target|target_clones|target_version}3'属性文字列に含まれています; '%select{target|target_clones|target_version}3'属性は無視されました"
# '%select{using this character in an identifier|starting an identifier with this character}0 is incompatible with C99'
H2BC4F8FF7FD4: '%select{識別子でのこの文字の使用|識別子の最初の文字としてこの文字の使用}0はC99と互換性がありません'
# "%select{values of type|enum values with underlying type}2 '%0' should not be used as format arguments; add an explicit cast to %1 instead"
H74FA7B9CE6BC: "%select{型|基底型を持つ列挙体}2 '%0' の値はフォーマット引数として使用しないでください；明示的なキャスト %1 を追加してください"
# '%select{value|type}0-dependent expression passed as an argument to debug command'
HF8F02B43BB62: 'デバッグコマンドの引数として%select{値|型}0依存式が渡されました'
# '%select{variable|static data member}0 instantiated with function type %1'
HE6193A7D74C4: '%select{変数|静的データメンバ}0が関数型%1でインスタンス化されました'
# '%select{via initialization of|binding reference}0 variable %select{%2 |}1here'
HB0440A5001E5: '%select{変数の初期化による|リファレンスのバインディング}0 %select{%2 |}1ここ'
# "%select{virtual method|function pointer}0 cannot be inferred '%1'"
H57712FD11644: "%select{バーチャルメソッド|関数ポインタ}0は'%1'を推論できません"
# '%select{void function|void method|constructor|destructor}1 %0 must not return a value'
HE90DDC8579B5: '%select{void関数|voidメソッド|コンストラクタ|デストラクタ}1 %0は値を返してはなりません'
# '%select{void function|void method|constructor|destructor}1 %0 should not return a value'
H917D4EA3DC61: '%select{void関数|voidメソッド|コンストラクタ|デストラクタ}1 %0は値を返すべきではありません'
# '%select{wide|Unicode}0 character literals may not contain multiple characters'
HEBA1B65B6166: '%select{ワイド|Unicode}0文字リテラルには複数の文字を含めることはできません'
# "%select{x86|x86-64}0 'interrupt' attribute only applies to functions that have %select{a 'void' return type|only a pointer parameter optionally followed by an integer parameter|a pointer as the first parameter|a %2 type as the second parameter}1"
H6EAE552C7EA8: "%select{x86|x86-64}0 'interrupt'属性は、%select{void戻り値を持つ関数|ポインタパラメータのみを持つ関数（オプションで整数パラメータを含む）|最初のパラメータがポインタの関数|2番目のパラメータが%2型の関数}1の場合のみ適用されます"
# "%select{|'%1-%2' }0diagnostics %select{with '%2' severity |}0%select{expected|seen}3 but not %select{seen|expected}3: %4"
H6E1DC1644300: "%select{|'%1-%2' }0診断 %select{'%2' 严重度の|}0%select{予想された|検出された}3 ではなく %select{検出された|予想された}3: %4"
# '%select{|a template declaration|an explicit template specialization|an explicit template instantiation}0 can only %select{|declare|declare|instantiate}0 a single entity'
HCEE3630F178B: '%select{|テンプレート宣言|明示的テンプレート特殊化|明示的テンプレートインスタンス化}0 は単一のエンティティのみを %select{|宣言|宣言|インスタンス化}0 できます'
# "%select{|captured }1%0 parameter marked 'called_once' is never called"
H5EDD8753404F: "%select{|キャプチャされた }1%0 パラメータが 'called_once' 修飾されていますが呼び出されません"
# '%select{|captured }1completion handler is never called'
H31A1FA39F285: '%select{|キャプチャされた }1コンプリーションハンドラが呼び出されません'
# "%select{|change to 'snprintf' for explicit bounds checking | buffer pointer and size may not match|string argument is not guaranteed to be null-terminated|'va_list' is unsafe}0"
H071DEF637982: "%select{|'snprintf' への変更で明示的な境界チェックを追加 | バッファポインタとサイズが一致しない可能性|文字列引数がNULL終端でない可能性|'va_list' の危険性}0"
# '%select{|direct }0%select{method|property}1 declaration conflicts with previous %select{|direct }2declaration of %select{method|property}1 %3'
H1D02391D3A58: '%select{|直接 }0%select{メソッド|プロパティ}1 の宣言は、前の %select{|直接 }2%select{メソッド|プロパティ}1 %3 の宣言と衝突します'
# '%select{|empty }0%select{struct|union}1 has size 0 in C, %select{size 1|non-zero size}2 in C++'
HEA8D8C4B49F9: '%select{|空 }0%select{構造体|ユニオン}1 はCではサイズ0ですが、C++では%select{サイズ1|非ゼロサイズ}2 です'
# "%select{|implicit }0use of 'this' pointer is only allowed within the evaluation of a call to a 'constexpr' member function"
HE1347141F3D2: "%select{|暗黙の }0'this' ポインタの使用は、'constexpr' メンバ関数の呼び出し評価中にのみ許可されます"
# '%select{|implicitly }1declared %select{private|protected}0 here'
H8D12655CD9C3: '%select{|暗黙に }1宣言された %select{private|protected}0 ここ'
# "%select{|incremented }0enumerator value which exceeds the range of 'int' is a C23 extension (%1 is too %select{small|large}2)"
H7317CEFA834D: "%select{|増加した }0列挙子値が'int'の範囲を超えるのはC23拡張 (%1 が%select{小さすぎる|大きすぎる}2)"
# "%select{|incremented }0enumerator value which exceeds the range of 'int' is incompatible with C standards before C23 (%1 is too %select{small|large}2)"
H02CD4F5E389B: "%select{|増加した }0列挙子値が'int'の範囲を超えるのはC23以前の標準と互換性ありません (%1 が%select{小さすぎる|大きすぎる}2)"
# '%select{|member|base class}0 %1 declared here'
H83331E20A1A3: '%select{|メンバ|基底クラス}0 %1 ここに宣言'
# '%select{|member}0 using declaration %1 instantiates to an empty pack'
H03EFD19ED92A: '%select{|メンバ}0 using宣言 %1 は空のパックに展開されます'
# '%select{|non-aggregate }0type %1 cannot be initialized with an initializer list'
H94A9DAA06E2F: '%select{|非集約型 }0%1 は初期化リストで初期化できません'
# '%select{|overriding }1method cannot be unavailable on %0 when %select{the protocol method it implements|its overridden method}1 is available'
H11BFB9C90008: '%select{|オーバーライド }1メソッドは、%select{実装するプロトコルメソッド|オーバーライド元のメソッド}1 が利用可能である場合、%0 で利用不可にできません'
# '%select{|overriding }4method %select{introduced after|deprecated before|obsoleted before}0 %select{the protocol method it implements|overridden method}4 on %1 (%2 vs. %3)'
H3102E4185799: '%select{|オーバーライドする }4メソッド %select{が後に導入された|廃止予定の|廃止された}0 %select{実装するプロトコルのメソッド|オーバーライドされたメソッド}4 に %1 (%2 対 %3)'
# '%select{|pointer to |reference to }0incomplete type %1 is not allowed in exception specification'
HBD4554E2864A: '%select{|不完全型へのポインタ|不完全型へのリファレンス }0 %1 は例外仕様で使用できません'
# "%select{|previous }0'hint' clause with value '%1'"
HBBFA3E1A9C6B: "%select{|以前の }0'hint'句の値 '%1'"
# "%select{|previous }0directive with no 'hint' clause specified"
H8CE1C8734C39: "%select{|以前の }0'directive'句に'hint'指定がありません"
# '%select{|previous }0using declaration'
H5AE3701DBB92: '%select{|以前の }0using宣言'
# '%select{|previous }0using-enum declaration'
H5BC63E8C8F5E: '%select{|以前の }0using-enum宣言'
# '%select{|reference to }0sizeless type %1 is not allowed in exception specification'
H3E89611A15B6: '%select{|サイズなし型へのリファレンス }0 %1 は例外仕様で使用できません'
# '%select{|second }0%1 token is here'
H00E98F1D44F7: '%select{|2つ目の }0%1トークンはここ'
# '%select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2 uses deleted function%select{|: %4}3'
HD806C936F5D9: '%select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 %1 から %2 へのキャストで削除された関数を使用しています%select{|: %4}3'
# '%select{|success |failure }0memory order argument to atomic operation is invalid'
HFAC869D2863E: '%select{|成功 |失敗 }0原子操作のメモリオーダー引数が無効です'
# "%select{|umbrella }0header '%1' not found"
H3FDB64D57A92: '%select{|アンバrella }0ヘッダーファイル "%1" が見つかりません'
# '%select{|unsafe_unretained|strong|weak}1 property %0 may not also be declared %select{|__unsafe_unretained|__strong|__weak|__autoreleasing}2'
HC9D6BEED9F9F: '%select{|unsafe_unretained|strong|weak}1 プロパティ %0 は %select{|__unsafe_unretained|__strong|__weak|__autoreleasing}2 と同時に宣言できません'
# '%select{||reinterpret_cast||C-style cast||}0 from scalar %1 to vector %2 of different size'
HFF11D1B4EA50: '%select{||reinterpret_cast||C-style cast||}0 スカラ型 %1 から要素数の異なるベクタ型 %2 へのキャスト'
# '%select{||reinterpret_cast||C-style cast||}0 from vector %1 to scalar %2 of different size'
H4BC2B3E593E1: '%select{||reinterpret_cast||C-style cast||}0 要素数の異なるベクタ型 %1 からスカラ型 %2 へのキャスト'
# '%select{||reinterpret_cast||C-style cast||}0 from vector %1 to vector %2 of different size'
H855233AE0D42: '%select{||reinterpret_cast||C-style cast||}0 要素数の異なるベクタ型 %1 からベクタ型 %2 へのキャスト'
# "%select{|||||virtual function called on|dynamic_cast applied to|typeid applied to|construction of|destruction of}0 object '%1' whose dynamic type is not constant"
H292A692F3948: "%select{|||||バーチャル関数の呼び出し|dynamic_castの適用|typeidの適用|構築|破棄}0 オブジェクト '%1' の動的型が定数ではありません"
# "'##' cannot appear at end of __VA_OPT__ argument"
H2B78B6D67ACA: "'##' は__VA_OPT__引数の末尾に使用できません"
# "'##' cannot appear at end of macro expansion"
H0D880CABAC3F: "'##' はマクロ展開の末尾に使用できません"
# "'##' cannot appear at start of __VA_OPT__ argument"
H2F2411264E60: "'##' は __VA_OPT__ 引数の先頭で使用できません"
# "'##' cannot appear at start of macro expansion"
H49669D0F3359: "'##' はマクロ展開の先頭で使用できません"
# "'#include <filename>' attaches the declarations to the named module '%0', which is not usually intended; consider moving that directive before the module declaration"
HE8759FB5FF70: "'#include <ファイル名>' は指定されたモジュール '%0' に宣言を関連付けますが、通常は意図した動作ではありません; このディレクティブをモジュール宣言の前に移動してください"
# "'#pragma %0' can only appear at file scope"
HCE0F9341D433: "'#pragma %0' はファイルスコープでしか使用できません"
# "'#pragma %0' can only appear at file scope or at the start of a compound statement"
HD3947EF6D864: "'#pragma %0' はファイルスコープまたは複合ステートメントの開始部でしか使用できません"
# "'#pragma %0' is not supported on this target - ignored"
H10F342B08150: "'#pragma %0' はこのターゲットではサポートされていません - 無視されます"
# "'#pragma STDC FENV_ACCESS ON' is illegal when precise is disabled"
H17CE846EF8B0: "'#pragma STDC FENV_ACCESS ON' はpreciseが無効の場合は使用できません"
# "'#pragma alloc_text' is applicable only to functions"
H29BA150C71BF: "'#pragma alloc_text' は関数のみ対象です"
# "'#pragma alloc_text' is applicable only to functions with C linkage"
H8053A181B977: "'#pragma alloc_text' はC言語リンクの関数のみ対象です"
# "'#pragma clang arc_cf_code_audited' was not ended within this file"
H3175433AA2FB: "'#pragma clang arc_cf_code_audited' はこのファイル内で終了されていません"
# "'#pragma clang assume_nonnull' was not ended within this file"
H344021929D5B: "'#pragma clang assume_nonnull' はこのファイル内で終了されていません"
# "'#pragma clang attribute %select{%1.|}0pop' with no matching '#pragma clang attribute %select{%1.|}0push'"
H170B16ACF46E: "'#pragma clang attribute %select{%1.|}0pop' に対応する '#pragma clang attribute %select{%1.|}0push' が見つかりません"
# "'#pragma clang attribute push' regions ends here"
HF6A5F5655AB0: "'#pragma clang attribute push' リージョンはここで終了します"
# "'#pragma clang attribute' attribute with no matching '#pragma clang attribute push'"
HAAE6327E2566: "'#pragma clang attribute' 属性に対応する '#pragma clang attribute push' が見つかりません"
# "'#pragma comment %0' ignored"
HEB14674C1594: "'#pragma comment %0' は無視されました"
# "'#pragma float_control push/pop' can only appear at file or namespace scope or within a language linkage specification"
H053264F8F924: "'#pragma float_control push/pop' はファイルまたはネームスペーススコープ、または言語リンク指定内でのみ使用できます"
# "'#pragma float_control(except, on)' is illegal when precise is disabled"
H28022D025F51: "'#pragma float_control(except, on)' はpreciseが無効の場合は使用できません"
# "'#pragma float_control(precise, off)' is illegal when except is enabled"
H922887ACFECE: "'#pragma float_control(precise, off)' はexceptが有効の場合は使用できません"
# "'#pragma float_control(precise, off)' is illegal when fenv_access is enabled"
HAFA440F76585: "'#pragma float_control(precise, off)' はfenv_accessが有効の場合は使用できません"
# "'#pragma init_seg' is only supported when targeting a Microsoft environment"
H4E91F2EF3757: "'#pragma init_seg' はMicrosoft環境をターゲットにした場合のみサポートされています"
# "'#pragma omp %0' %select{|with '%2' clause }1cannot be an immediate substatement"
HA805BCE4C312: "'#pragma omp %0' %select{|'%2'句を伴う }1は直下のサブステートメントとして使用できません"
# "'#pragma omp %0' directive must appear only in file scope"
H3C04CBDE708E: "'#pragma omp %0' ディレクティブはファイルスコープ内でのみ出現可能"
# "'#pragma omp %0' must appear in the scope of the %q1 variable declaration"
HCD521713958F: "'#pragma omp %0' は%q1変数宣言のスコープ内にのみ出現可能"
# "'#pragma omp %0' must precede all references to variable %q1"
HA982E769431D: "'#pragma omp %0' は変数%q1へのすべての参照前に出現する必要があります"
# "'#pragma omp declare %select{simd|variant}0' can only be applied to functions"
HC2DB961C6B39: "'#pragma omp declare %select{simd|variant}0' は関数にのみ適用可能です"
# "'#pragma omp declare variant' cannot be applied for function after first usage; the original function might be used"
H504957D176C7: "'#pragma omp declare variant' は関数が最初に使用された後は適用できません（元の関数が使用される可能性があります）"
# "'#pragma omp declare variant' cannot be applied to the function that was defined already; the original function might be used"
HB5A7CD5EEB6F: "'#pragma omp declare variant' は既に定義された関数には適用できません（元の関数が使用される可能性があります）"
# "'#pragma omp declare variant' does not support %select{function templates|virtual functions|deduced return types|constructors|destructors|deleted functions|defaulted functions|constexpr functions|consteval function}0"
H240B964685D1: "'#pragma omp declare variant' は%select{関数テンプレート|仮想関数|推論された戻り値型|コンストラクタ|デストラクタ|削除された関数|デフォルト化された関数|constexpr関数|consteval関数}0をサポートしません"
# "'#pragma omp declare variant' is not compatible with any target-specific attributes"
HDFFC2CD6FA69: "'#pragma omp declare variant' はターゲット固有の属性と互換性ありません"
# "'#pragma omp end assumes' with no matching '#pragma omp begin assumes'"
HAF63C041427E: "'#pragma omp end assumes' に対応する'#pragma omp begin assumes'がありません"
# "'#pragma omp end declare variant' with no matching '#pragma omp begin declare variant'"
HD60959180819: "'#pragma omp end declare variant' に対応する'#pragma omp begin declare variant'がありません"
# "'#pragma unsafe_buffer_usage' was not ended"
H8FB2F039CC57: "'#pragma unsafe_buffer_usage' の終了がありません"
# "'$' in identifier"
HB5654708DC14: "識別子内の'$'文字"
# "'%%n' specifier not supported on this platform"
HC8B8AD4E064B: "'%%n'仕様はこのプラットフォームでサポートされていません"
# "'%0' %select{length modifier|conversion specifier}1 is not supported by ISO C"
H5FE655A569EF: "ISO Cでは'%0' %select{長さ修飾子|変換指定子}1 はサポートされていません"
# "'%0' ABI is not supported with FPU"
H0E4CA678D6B9: "'%0' ABIはFPUと互換性ありません"
# "'%0' action ignored; '%1' action specified previously"
H140C3ABC4AE4: "'%0' アクションは無視されました；'%1' アクションが以前に指定されています"
# "'%0' and '%1' clause are mutually exclusive and may not appear on the same directive"
H124967FEEE58: "'%0' と'%1' 句は排他的であり、同一ディレクティブに同時に出現できません"
# "'%0' argument on '%1' clause is not permitted on a%select{|n orphaned}2 '%3' construct%select{| associated with a '%5' compute construct}4"
H43AC213E21A0: "'%1' 句の'%0' 引数は%select{|孤児の}2 '%3' コンストラクト%select{| '%5' コンピュートコンストラクトに関連付けられた}4には許可されていません"
# "'%0' argument to '%1' clause not allowed on a '%2' construct%select{| associated with a '%4' construct}3 that has a '%5' clause"
H08457CF75CEB: "'%0' 引数は '%1'句で'%2'構造体%select{| '%4'構造体に関連付けられた}3 に使用できません。'%5'句が指定されている場合"
# "'%0' as a module map name is deprecated, rename it to %select{module.modulemap|module.private.modulemap}1%select{| in the 'Modules' directory of the framework}2"
H871445ACDF0B: "'%0'をモジュールマップ名として使用することは非推奨です。%select{module.modulemap|module.private.modulemap}1%select{|フレームワークの'Modules'ディレクトリ内に}2名前を変更してください"
# "'%0' attribute cannot be specified on a definition"
H3887172CED45: "'%0'属性は定義に指定できません"
# "'%0' call operates on objects of type %1 while the size is based on a different type %2"
H9E506A66F2D3: "'%0'呼び出しは%1型のオブジェクトに対して行われますが、サイズは異なる%2型に基づいています"
# "'%0' can only be used if the target supports the mfhc1 and mthc1 instructions"
HD98657B082CC: "'%0'を使用するにはターゲットがmfhc1とmthc1命令をサポートする必要があります"
# "'%0' can only be used with the '%1' ABI"
HAC173E806F23: "'%0'は'%1'ABIと組み合わせて使用する必要があります"
# "'%0' cannot be a part of nested name specifier; did you mean ':'?"
H6E2E8EF01102: "'%0'はネストした名前指定子の一部にできません。':'を意図したのではないでしょうか？"
# "'%0' cannot be called with %select{a null pointer|a one-past-the-end pointer|a pointer to an object whose lifetime has not yet begun}1"
H9E6A8072EAD3: "'%0'は%select{nullポインタ|配列末尾のポインタ|未開始のオブジェクトのポインタ}1で呼び出せません"
# "'%0' cannot be signed or unsigned"
HE82DC08D960E: "'%0'は符号付きまたは符号なしにできません"
# "'%0' cannot be used in an unevaluated context"
HACCAB0092430: "'%0'は未評価コンテキストでは使用できません"
# "'%0' cannot be used in the handler of a try block"
HCC6C7DE7C0DC: "'%0'はtryブロックのハンドラ内で使用できません"
# "'%0' cannot be used outside a function"
HF038C50615EF: "'%0'は関数外では使用できません"
# "'%0' casts have no effect when not using ARC"
H0985DFE3C8AA: "'%0'キャストはARCを使用しない場合、効果がありません"
# "'%0' clause is specified here"
H573F42F97FF4: "'%0'句はここで指定されています"
# "'%0' clause not allowed on a 'kernels loop' construct that has a '%1' clause with a%select{n| 'num'}2 argument"
HA63B4E6AC69A: "'%0'句は'%1'句（%select{n|'num'}2引数）を有する'kernels loop'構造体には使用できません"
# "'%0' clause requires 'dispatch' context selector"
H94FAB67C930A: "'%0'句は'dispatch'コンテキストセレクタを要求します"
# "'%0' clause specifies a loop count greater than the number of available loops"
H13BED1AA5B60: "'%0'句は利用可能なループ数を超えるループカウントを指定しています"
# "'%0' clause used here"
HC259BC00C8FD: "'%0'句はここで使用されています"
# "'%0' clause with '%1' modifier cannot be specified if an 'ordered' clause is specified"
HFFE6A9A75740: "'%0'句（'%1'修飾子付き）は'ordered'句が指定されている場合使用できません"
# "'%0' clauses cannot be mixed with '%1' clause"
H0A2484D8EEB5: "'%0'句は'%1'句と併用できません"
# "'%0' construct is here"
H4E6A1EF91E1B: "'%0' 構造体はここにあります"
# "'%0' declared as a member pointer to a reference of type %1"
HF4FF87D5007C: "'%0' は型 %1 の参照へのメンバー ポインタとして宣言されました"
# "'%0' declared as a member pointer to void"
HB8704C365E55: "'%0' はvoidへのメンバー ポインタとして宣言されました"
# "'%0' declared as a pointer to a reference of type %1"
H95E780665FDE: "'%0' は型 %1 の参照へのポインタとして宣言されました"
# "'%0' declared as an array with a negative size"
H44D9A6FDB5F3: "'%0' は負のサイズを持つ配列として宣言されました"
# "'%0' declared as array of functions of type %1"
HF167BCD9180C: "'%0' は型 %1 の関数配列として宣言されました"
# "'%0' declared as array of references of type %1"
H07B7977DE9AC: "'%0' は型 %1 の参照配列として宣言されました"
# "'%0' directive cannot follow %select{'%2' directive|other expected directives}1"
H81459AA5C045: "'%0' ディレクティブは %select{'%2' ディレクティブ|他の予期されるディレクティブ}1 の後に使用できません"
# "'%0' directive found here"
H689CAA47B15F: "'%0' ディレクティブがここに存在します"
# "'%0' does not contain a GCC installation"
H5EA2B901E3DD: "'%0' にはGCCインストールが含まれません"
# "'%0' does not support '-%1'; flag ignored"
H5F193B6442A3: "'%0' は '-%1' をサポートしていません; フラグが無視されました"
# "'%0' does not support '-moutline'; flag ignored"
H8FCF49E8EFFE: "'%0' は '-moutline' をサポートしていません; フラグが無視されました"
# "'%0' evaluates to a null function pointer"
HC166C9B46BC9: "'%0' はNULL関数ポインタとして評価されました"
# "'%0' file not found"
HE40852833202: "'%0' ファイルが見つかりません"
# '\'%0\' file not found with <angled> %select{include|import}1; use "quotes" instead'
HB65E7D8C29D0: "'%0' ファイルは <angled> の %select{インクルード|インポート}1 で見つかりません; 「引用符」を使用してください"
# "'%0' file not found, did you mean '%1'?"
HA3BAEA90173D: "'%0' ファイルが見つかりません。'%1' を指定されたのではないでしょうか？"
# "'%0' function must have a prototype"
H161348B5A00F: "'%0' 関数にはプロトタイプが必要です"
# "'%0' ignored on this declaration"
H3A73EC6937F0: "'%0' はこの宣言では無視されます"
# "'%0' included multiple times, additional include site here"
H67346CC37DF8: "'%0' が複数回インクルードされました、追加のインクルード場所がここにあります"
# "'%0' included multiple times, additional include site in header from module '%1'"
HC2226976DFB3: "'%0' が複数回インクルードされました、追加のインクルード場所はモジュール '%1' のヘッダーからです"
# "'%0' invalid for input of type %1"
H0F254F5D0DEC: "'%0'は型%1の入力として無効です"
# "'%0' is a C11 extension"
HACD9CD0EB9B2: "'%0'はC11拡張機能です"
# "'%0' is a C2y extension"
H46F684F39EE1: "'%0'はC2y拡張機能です"
# "'%0' is a C99 extension"
H553903351EEE: "'%0'はC99拡張機能です"
# "'%0' is a context %select{set|selector|property}1 not a context %select{set|selector|property}2"
H0E6818DF21E4: "'%0'はコンテキスト%select{セット|セレクタ|プロパティ}1ですが、コンテキスト%select{セット|セレクタ|プロパティ}2ではありません"
# "'%0' is a keyword in C++11"
H6E1B6EF2D90A: "'%0'はC++11のキーワードです"
# "'%0' is a keyword in C++20"
HED77874B7FB4: "'%0'はC++20のキーワードです"
# "'%0' is a keyword in C23"
H55337290EE76: "'%0'はC23のキーワードです"
# "'%0' is a keyword in C99"
H305C2462E219: "'%0'はC99のキーワードです"
# "'%0' is bound to current loop, GCC binds it to the enclosing loop"
H6C2FAF9A98CF: "'%0'は現在のループに束縛されています。GCCは外側のループに束縛します"
# "'%0' is ignored since it is only supported for HIP"
HAF6605CCA46F: "'%0'はHIPでサポートされるため無視されます"
# "'%0' is incompatible with C standards before C11"
H0DA1AA64E023: "'%0'はC11以前の標準と互換性がありません"
# "'%0' is incompatible with C standards before C23"
HDD86BE78B3D0: "'%0'はC23以前の標準と互換性がありません"
# "'%0' is incompatible with C standards before C2y"
H1CC83438FCCD: "'%0'はC2y以前の標準と互換性がありません"
# "'%0' is invalid in friend declarations"
H3D161449A142: "'%0'はfriend宣言では無効です"
# "'%0' is not a valid Unicode character name"
H469DC75B6244: "'%0'は有効なUnicode文字名ではありません"
# "'%0' is not a valid builtin name for %1"
H4BF3E4DBB43C: "'%0'は%1の有効な組み込み名ではありません"
# "'%0' is not a valid context property for the context selector '%1' and the context set '%2'; property ignored"
HEB6F750CA90C: "'%0'はコンテキストセレクタ'%1'とコンテキストセット'%2'のプロパティではありません；プロパティは無視されます"
# "'%0' is not a valid context selector for the context set '%1'; selector ignored"
H6CA470A4E352: "'%0'はコンテキストセット'%1'の有効なセレクタではありません；セレクタは無視されます"
# "'%0' is not a valid context set in a `declare variant`; set ignored"
HA1E62D28111D: "'%0'は`declare variant`で有効なコンテキストセットではありません；セットは無視されます"
# "'%0' is not a valid object format flag"
H0558CE31CE90: "'%0'は有効なオブジェクト形式フラグではありません"
# "'%0' is not permitted on a declaration of a type"
H43ABF8D7D74B: "'%0'は型の宣言では許可されていません"
# "'%0' is not supported in C++ for OpenCL"
HDCEA34FAF8C7: "'%0'はC++のOpenCLでサポートされていません"
# "'%0' is only allowed on variable declarations"
H6BFADFD542E9: "'%0'は変数宣言でのみ許可されています"
# "'%0' is only available in %1"
H468F8034CF09: "'%0'は%1でのみ利用可能です"
# "'%0' is used without '-mstack-protector-guard-offset', and there is no default"
H8812B24333D0: "'%0'は'-mstack-protector-guard-offset'オプションなしに使用され、デフォルト値もありません"
# "'%0' keyword is a C++11 extension"
H23175F3671E1: "'%0'キーワードはC++11の拡張機能です"
# "'%0' keyword is incompatible with C++98"
HCFDB7E16EAB8: "'%0'キーワードはC++98と互換性がありません"
# "'%0' keyword not permitted with interface types"
HFAA4A308281C: "'%0'キーワードはインターフェース型では許可されていません"
# "'%0' may overflow; destination buffer in argument %1 has size %2, but the corresponding specifier may require size %3"
H45D6462C38BC: "'%0'がオーバーフローする可能性があります；引数%1の宛先バッファのサイズは%2ですが、対応する仕様ではサイズ%3が必要になる可能性があります"
# "'%0' not supported, please use -iquote instead"
HD03640F49183: "'%0'はサポートされていません。代わりに-iquoteを使用してください"
# "'%0' only applies to %select{function|pointer|Objective-C object or block pointer}1 types; type here is %2"
H76B771A1DA3E: "'%0'は%select{関数|ポインタ|Objective-Cオブジェクトまたはブロックポインタ}1型にのみ適用されます；ここでの型は%2です"
# "'%0' only applies to medium and large code models"
H2B43B16BADDB: "'%0'は中規模および大規模コードモデルでのみ適用されます"
# "'%0' option requires target HLSL Version >= 2018%select{| and shader model >= 6.2}1, but HLSL Version is '%2'%select{| and shader model is '%3'}1"
H73FD169C1664: "'%0'オプションはターゲットHLSLバージョンが2018%select{|以上でシェーダーモデルが6.2}1以上を必要としますが、現在のHLSLバージョンは'%2'%select{|、シェーダーモデルは'%3}1です"
# "'%0' parameter can only be used with swiftcall%select{ or swiftasynccall|}1 calling convention%select{|s}1"
H7F6C0A7A9011: "'%0'パラメータはswiftcall%select{またはswiftasynccall|}1コールコンベンション%select{|s}1でのみ使用できます"
# "'%0' parameter must have pointer%select{| to unqualified pointer}1 type; type here is %2"
HA49C073BB7A8: "'%0'パラメータはpointer%select{|非修飾ポインタへの}1型でなければなりません；ここでの型は%2です"
# "'%0' previously encountered here"
HC082D10D967F: "'%0'は以前ここで検出されています"
# "'%0' qualifier is not allowed on a constructor"
HD3C37F48AA10: "'%0'修飾子はコンストラクタでは許可されていません"
# "'%0' qualifier is not allowed on a destructor"
H63A821EC7A98: "'%0'修飾子はデストラクタでは許可されていません"
# "'%0' qualifier may not appear after the virtual specifier '%1'"
HC82C66448381: "'%0'修飾子は仮想指定子'%1'の後に出現できません"
# "'%0' qualifier may not be applied to a reference"
H39DF4A724F57: "修飾子'%0'はリファレンスには適用できません"
# "'%0' qualifier on function type %1 has no effect"
HCA4F5C288E32: "関数型%1における'%0'修飾子は効果がありません"
# "'%0' qualifier on function type %1 has no effect and is a Clang extension"
HA82B1E90695B: "関数型%1における'%0'修飾子は効果がありませんが、これはClang拡張機能です"
# "'%0' qualifier on omitted return type %1 has no effect"
H226C520C0A5C: "省略された戻り値型%1における'%0'修飾子は効果がありません"
# "'%0' qualifier on reference type %1 has no effect"
H9D5F7EA85F79: "リファレンス型%1における'%0'修飾子は効果がありません"
# "'%0' qualifier%s1 on base class type %2 %plural{1:has|:have}1 no effect"
HB4BF74C2E9A3: "基底クラス型%2における'%0'修飾子%s1%plural{1:は|:は}1効果がありません"
# "'%0' region encountered before requires directive with '%1' clause"
HAC48A5EE380D: "'%1'句を含むrequiresディレクティブより前に'%0'リージョンが出現しました"
# "'%0' required by '%1'"
H149191A7D780: "'%1'により'%0'が必要とされます"
# "'%0' required for precompiled header not found"
HBDA853057C16: "プリコンパイルヘッダ用'%0'が見つかりません"
# "'%0' size argument is too large; destination buffer has size %1, but size argument is %2"
H1B04445BBECB: "'%0'サイズ引数が大きすぎます; バッファサイズ%1に対し引数は%2です"
# "'%0' specifier is not allowed outside a class definition"
H496E8612120E: "'%0'修飾子はクラス定義外では使用できません"
# "'%0' statement cannot be used in OpenMP for loop"
HB1E296AE95BC: "OpenMP forループ内で'%0'ステートメントを使用できません"
# "'%0' statement cannot be used in OpenMP simd region"
H1C587C7353B1: "OpenMP simd領域内で'%0'ステートメントを使用できません"
# "'%0' type not found; include <omp.h>"
H4CF50F4E769F: "'%0'型は見つかりません; <omp.h>を含めてください"
# "'%0' type qualifier%s1 on return type %plural{1:has|:have}1 no effect"
H065A9C128711: "'%0' の型修飾子%s1 は戻り値の型 %plural{1:には効果がありません|:には効果がありません}1"
# "'%0' type specifier is incompatible with C++98"
HB674C3599FA0: "'%0'修飾子はC++98と互換性がありません"
# "'%0' variables must have global storage"
H08EBA7A5907F: "'%0'変数にはグローバルストレージが必要です"
# "'%0' will always be truncated; specified size is %1, but format string expands to at least %2"
H0AA6DDAAABA2: "'%0'は常に切り捨てられます; 指定サイズ%1に対しフォーマット文字列は%2以上必要です"
# "'%0' will always evaluate to 'true' in a manifestly constant-evaluated expression"
H75D7A83FFEC6: "'%0'はマニフェスト定数評価式において常に'true'に評価されます"
# "'%0' will always overflow; destination buffer has size %1, but format string expands to at least %2"
H6C8DA523F6B3: "'%0'は常にオーバーフローします; バッファサイズ%1に対しフォーマット文字列は%2以上必要です"
# "'%0' will always overflow; destination buffer has size %1, but size argument is %2"
H6A8E065AE173: "'%0' は常にオーバーフローします; 宛先バッファのサイズは%1ですが、サイズ引数は%2です"
# "'%0' will always overflow; destination buffer has size %1, but the source string has length %2 (including NUL byte)"
H4E1F13141ECB: "'%0' は常にオーバーフローします; 宛先バッファのサイズは%1ですが、ソース文字列の長さは%2（ヌルバイトを含む）です"
# "'%0' will return the size of the pointer, not the array itself"
H10D34141626D: "'%0' は配列自体ではなくポインタのサイズを返します"
# "'%0' within '%1'"
HFD060F45F3E4: "'%0' は'%1'の内部で使用されています"
# "'%0': selected processor lacks floating point registers"
H5E83058CA4FE: "'%0'：選択されたプロセッサには浮動小数点レジスタがありません"
# "'%0': unable to pass LLVM bit-code files to linker"
H5B7DB64DAEE9: "'%0'：リンカにLLVMビットコードファイルを渡すことができません"
# "'%0': unable to use AST files with this tool"
HEA339F2E046F: "'%0'：このツールではASTファイルを使用できません"
# "'%0': unable to use module files with this tool"
H25C074B573CF: "'%0'：このツールではモジュールファイルを使用できません"
# "'%0(%select{source|sink:vec}1)' clause%select{|s}1 cannot be mixed with '%0(%select{sink:vec|source}1)' clause%select{s|}1"
H081C849E3FF9: "'%0(%select{sink:vec|source}1)'句%select{s|}1と'%0(%select{source|sink:vec}1)'句%select{を|}1混在させることはできません"
# "'%1' attribute on property %0 does not match the property inherited from %2"
H0392738DA622: "'%1'属性プロパティ%0は%2から継承されたプロパティと一致しません"
# "'%1' cannot be used in %select{a constructor|a destructor|the 'main' function|a constexpr function|a function with a deduced return type|a varargs function|a consteval function}0"
HB2DCA2D92D0E: "'%1' を %select{コンストラクタ|デストラクタ|'main' 関数|constexpr 関数|戻り値型が推論される関数|可変長引数関数|consteval 関数}0 で使用できません"
# "'%select{#|#@}0' is not followed by a macro parameter"
HFFC615C42B6A: "'%select{#|#@}0' の後にマクロパラメータが続きません"
# "'%select{%select{memcpy|wmemcpy}1|%select{memmove|wmemmove}1}0' not supported: %select{size to copy (%4) is not a multiple of size of element type %3 (%5)|source is not a contiguous array of at least %4 elements of type %3|destination is not a contiguous array of at least %4 elements of type %3}2"
HEE3F2A4E1A36: "'%select{%select{memcpy|wmemcpy}1|%select{memmove|wmemmove}1}0' のサポート対象外: %select{コピーするサイズ (%4) が要素型 %3 (%5) の倍数ではありません|ソースが要素型 %3 の少なくとも %4 要素の連続配列ではありません|宛先が要素型 %3 の少なくとも %4 要素の連続配列ではありません}2"
# "'%select{*|.*}0' specified field %select{width|precision}0 is missing a matching 'int' argument"
H0D1F0E4F63B2: "'%select{*|.*}0' で指定された %select{幅|精度}0 に一致する'int'引数がありません"
# "'%select{--|++}0' on an object of complex type is a C2y extension"
HDA93C21904C8: "複素型のオブジェクトへの '%select{--|++}0' はC2y拡張です"
# "'%select{--|++}0' on an object of complex type is incompatible with C standards before C2y"
H20E81B85B020: "複素型のオブジェクトへの '%select{--|++}0' はC2y以前の仕様と互換性ありません"
# "'%select{\\|@}0%1' command does not terminate a verbatim text block"
H42F81A2BAA36: "'%select{\\|@}0%1' コマンドはverbatimテキストブロックを終了しません"
# "'%select{\\|@}0%1' command has %plural{0:no|:%2}2 word argument%s2, expected %3"
HBEDC67E6720C: "'%select{\\|@}0%1' コマンドは %plural{0:パラメータがありません|:パラメータが%2個あります}2、%3個が必要です"
# "'%select{\\|@}0%1' command used in a comment that is attached to a %select{function returning void|constructor|destructor|method returning void}2"
HFBFA65D15A47: "'%select{\\|@}0%1' コマンドは %select{voidを返す関数|コンストラクタ|デストラクタ|voidを返すメソッド}2 に付随するコメントで使用されています"
# "'%select{\\|@}0%1' command used in a comment that is not attached to a function or method declaration"
H9A9CB5F0CECC: "'%select{\\|@}0%1' コマンドは関数またはメソッド宣言に付随するコメントでなければなりません"
# "'%select{\\|@}0%select{classdesign|coclass|dependency|helper|helperclass|helps|instancesize|ownership|performance|security|superclass}1' command should not be used in a comment attached to a non-container declaration"
H63CA64568B3F: "'%select{\\|@}0%select{classdesign|coclass|dependency|helper|helperclass|helps|instancesize|ownership|performance|security|superclass}1' コマンドはコンテナ宣言以外に使用できません"
# "'%select{\\|@}0%select{class|interface|protocol|struct|union}1' command should not be used in a comment attached to a non-%select{class|interface|protocol|struct|union}2 declaration"
H2B2D23C85C31: "'%select{\\|@}0%select{class|interface|protocol|struct|union}1' コマンドは %select{class|interface|protocol|struct|union}2 型以外の宣言に使用できません"
# "'%select{\\|@}0%select{function|functiongroup|method|methodgroup|callback}1' command should be used in a comment attached to %select{a function|a function|an Objective-C method|an Objective-C method|a pointer to function}2 declaration"
H30965075CCD3: "'%select{\\|@}0%select{function|functiongroup|method|methodgroup|callback}1' コマンドは %select{関数|関数|Objective-Cメソッド|Objective-Cメソッド|関数ポインタ}2 宣言に使用する必要があります"
# "'%select{\\|@}0param' command used in a comment that is not attached to a function declaration"
HA6D99227D713: "'%select{\\|@}0param' コマンドは関数宣言に付随するコメントでなければなりません"
# "'%select{\\|@}0tparam' command used in a comment that is not attached to a template declaration"
H78D96F6B0A65: "'%select{\\|@}0tparam' コマンドはテンプレート宣言に付随するコメントでなければなりません"
# "'%select{auto|decltype(auto)}0' in return type deduced as %1 here but deduced as %2 in earlier return statement"
HDFEF08FDDF8E: "'%select{auto|decltype(auto)}0' 戻り値の型はここでは%1、以前のreturn文では%2と推論されました"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' argument cannot refer to a union member"
HF50BCD9CECE6: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' 引数はユニオンメンバを参照できません"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' argument must be a simple declaration reference"
HF6AC15305460: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' 引数は単純な宣言参照でなければなりません"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' cannot be applied to a union member"
H01022C27C2BB: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' はユニオンメンバには適用できません"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' only applies to pointers%select{ or C99 flexible array members|||}0%select{|; did you mean to use 'counted_by'?}1"
H077E0A5BF4C4: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' はポインタ%select{またはC99の柔軟配列メンバ|||}0%select{|; 'counted_by'を使うべきではありませんか？}1 のみに適用されます"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' requires a non-boolean integer type argument"
H69D52A4DAF87: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}0' は非論理型の整数型引数が必要です"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}1' field %0 isn't within the same struct as the annotated %select{pointer|flexible array}2"
HBD3F5637D173: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}1' のフィールド%0は、アノテーションされた%select{pointer|flexible array}2と同じ構造体にありません"
# "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}4' %select{cannot|should not}3 be applied to %select{a pointer with pointee|an array with element}0 of unknown size because %1 is %select{an incomplete type|a sizeless type|a function type|a struct type with a flexible array member%select{|. This will be an error in a future compiler version}3}2"
HEFA740A9E276: "'%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}4' は%select{cannot|should not}3、サイズ不明の%select{a pointer with pointee|an array with element}0に適用できません。なぜなら%1は%select{未完了の型|サイズなしの型|関数型|flexible array memberを含む構造体型%select{|. これには将来のコンパイラでエラーになります}3}2だからです"
# "'%select{if|switch}0' initialization statements are a C++17 extension"
HBFF569602D2E: "'%select{if|switch}0' の初期化ステートメントはC++17の拡張機能です"
# "'%select{make_unsigned|make_signed}0' is only compatible with non-%select{bool|_BitInt(1)}1 integers and enum types, but was given %2%select{| whose underlying type is %4}3"
H89BC3FB5059E: "'%select{make_unsigned|make_signed}0' は、%select{bool|_BitInt(1)}1ではない整数型または列挙型のみと互換性がありますが、%2%select{| の基本型は %4}3が指定されました"
# "'%select{memcpy|wmemcpy}0' between overlapping memory regions"
HF4936F4E6501: "'%select{memcpy|wmemcpy}0' が重複するメモリ領域間で実行されました"
# "'%select{pure|const}0' attribute on function returning 'void'; attribute ignored"
H219A6665B476: "'%select{pure|const}0'属性はvoidを返す関数では使用できません。属性が無視されました"
# "'%select{|short|long|long long}0 %1' is invalid"
H4742130B5F6C: "'%select{|short|long|long long}0 %1' は無効な宣言です"
# "'&&' of a value and its negation always evaluates to false"
H35E9DA987909: "値とその否定の'&&'は常にfalseになります"
# "'&&' within '||'"
H8790A025A3C5: "'||'内の'&&'は論理式の優先順位が逆転しています"
# "'&' cannot precede a capture when the capture default is '&'"
HA416D7E37193: "キャプチャデフォルトが'&'の時、キャプチャ前に'&'を置くことはできません"
# "'&' must precede a capture when the capture default is '='"
HC2B64117C04B: "キャプチャデフォルトが'='の時、キャプチャ前に'&'を明示的に置かなければなりません"
# "'*' query has already been specified"
H24FF63F5C6A0: "'*'クエリは既に指定されています"
# "'--hip-path' must be specified when offloading to SPIR-V unless '-nogpuinc' is given"
HF39C24E57C93: "'-nogpuinc'を指定しない限り、SPIR-Vへのオフロード時は'--hip-path'を指定する必要があります"
# "'->' applied to return value of the operator->() declared here"
H2D7F207160DF: "'->'がここに宣言されたoperator->()の戻り値に適用されました"
# "'-fopenmp-targets' must be used in conjunction with a '-fopenmp' option compatible with offloading; e.g., '-fopenmp=libomp' or '-fopenmp=libiomp5'"
HECE3FA60C323: "'-fopenmp-targets'はオフロードに適した'-fopenmp'オプションと併用する必要があります。例：'-fopenmp=libomp'または'-fopenmp=libiomp5'"
# "'-fsanitize=memtag-stack' requires hardware support (+memtag). For Armv8 or Armv9, try compiling with -march=armv8a+memtag or -march=armv9a+memtag"
H3869C74238EE: "'-fsanitize=memtag-stack'は+memtagハードウェアサポートが必要です。Armv8/Armv9では'-march=armv8a+memtag'または'-march=armv9a+memtag'でコンパイルしてください"
# "'-ftrivial-auto-var-init-max-size=*' is used without '-ftrivial-auto-var-init=zero' or '-ftrivial-auto-var-init=pattern'"
H85D7452F85FC: "'-ftrivial-auto-var-init-max-size=*'は'-ftrivial-auto-var-init=zero'または'-ftrivial-auto-var-init=pattern'と併用する必要があります"
# "'-ftrivial-auto-var-init-max-size=*' only accepts positive integers (in bytes)"
H15368DD22E8B: "'-ftrivial-auto-var-init-max-size=*'はバイト単位の正の整数のみ受け付けます"
# "'-ftrivial-auto-var-init-stop-after=*' is used without '-ftrivial-auto-var-init=zero' or '-ftrivial-auto-var-init=pattern'"
HA64F3C5CF11D: "'-ftrivial-auto-var-init-stop-after=*' は、'-ftrivial-auto-var-init=zero' または '-ftrivial-auto-var-init=pattern' と共に使用する必要があります"
# "'-ftrivial-auto-var-init-stop-after=*' only accepts positive integers"
H964D5FF3D330: "'-ftrivial-auto-var-init-stop-after=*' は正の整数のみを受け付けます"
# "'-fuse-ld=' taking a path is deprecated; use '--ld-path=' instead"
H24009BC2E029: "'-fuse-ld=' にパスを指定する機能は非推奨です; '--ld-path=' を使用してください"
# "'-mbranch-protection=' option is incompatible with the '%0' architecture"
H4CC02B48C139: "'-mbranch-protection=' オプションは '%0' アーキテクチャと互換性ありません"
# "'-mindirect-jump=%0' is unsupported with the '%1' architecture"
HA019BCF52E06: "'-mindirect-jump=%0' は '%1' アーキテクチャではサポートされていません"
# "'-x %0' after last input file has no effect"
H37D74D222DAD: "'-x %0' は最終入力ファイル以降では無効です"
# "'.  Try: '"
H3E571CE448AB: "'.  を試してください: '"
# "'...' as the only parameter of a function is incompatible with C standards before C23"
H0778011D458B: "関数の唯一のパラメータとして '...' は、C23以前のC規格と互換性ありません"
# "'...' in this location creates a C-style varargs function%select{, not a function parameter pack|}0"
HDE7D8371A836: "この位置の '...' はCスタイルの可変長関数を作成します%select{、関数パラメータパックではありません|}0"
# "'...' must %select{immediately precede declared identifier|be innermost component of anonymous pack declaration}0"
H636262C7094A: "'...' は%select{宣言された識別子の直前に配置する必要があります|匿名パック宣言の最も内側の構成要素でなければなりません}0"
# "'/*' within block comment"
HF2D384BEFA1C: "ブロックコメント内の '/*'"
# "'/U%0' treated as the '/U' option"
HE813F64217D5: "'/U%0' は '/U' オプションとして扱われます"
# "':' without preceding '?'"
H8AFE0C8D8DEE: "前置されない '?' の ': '"
# "'<::' is treated as digraph '<:' (aka '[') followed by ':' in C++98"
H79B7386C3992: "C++98では '::<' は '<:'（つまり'['）の文字記号として処理され、その後に':'が続きます"
# "'<=>' is a single token in C++20; add a space to avoid a change in behavior"
HA94282EE55ED: "'<=>' はC++20で単一トークンです; 行為の変化を回避するにはスペースを追加してください"
# "'<=>' operator is incompatible with C++ standards before C++20"
H95F1D52E2E7F: "'<=>' オペレーターはC++20以前のC++規格と互換性ありません"
# "'= %select{default|delete}0' is a function definition and must occur in a standalone declaration"
H500D10ACAD58: "'= %select{default|delete}0' は関数定義であり、単独の宣言内で発生する必要があります"
# "'= delete' with a message is a C++2c extension"
H31210BBF787E: "メッセージ付きの '= delete' はC++2c拡張機能です"
# "'= delete' with a message is incompatible with C++ standards before C++2c"
HF4121BB98E1E: "メッセージ付きの '= delete' はC++2c以前のC++規格と互換性ありません"
# "'@encode' of incomplete type %0"
H26BBB8B07598: "'@encode の不完全型 %0'"
# "'@end' appears where closing brace '}' is expected"
H0D104C2A47DE: "@end は閉じカッコ '}' が期待される場所に出現しています"
# "'@end' must appear in an Objective-C context"
H53F73799BBFE: '@end はObjective-Cコンテキスト内で使用する必要があります'
# "'NSObject' attribute is for pointer types only"
HB79535A35025: 'NSObject 属性はポインタ型専用です'
# "'NSObject' attribute may be put on a typedef only; attribute is ignored"
H5749529C7AA1: 'NSObject 属性はtypedefにのみ適用できます; 属性は無視されます'
# "'[[%select{nodiscard|gnu::warn_unused_result}0]]' attribute ignored when applied to a typedef; consider using '__attribute__((warn_unused_result))' or '[[clang::warn_unused_result]]' instead"
HC050BA19FE21: "'[[%select{nodiscard|gnu::warn_unused_result}0]]' 属性はtypedefに適用した場合無視されます; 代わりに '__attribute__((warn_unused_result))' または '[[clang::warn_unused_result]]' を使用してください"
# "'[[carries_dependency]]' attribute only allowed on parameter in a function declaration or lambda"
HA6D310EC7345: '[[carries_dependency]] 属性は関数宣言またはラムダのパラメータにのみ許可されます'
# "'[]' after delete interpreted as 'delete[]'; add parentheses to treat this as a lambda-expression"
H9FAF75D55EEF: "'[]' 後のdeleteは'delete[]'として解釈されます; ラムダ式として扱う場合は括弧を追加してください"
# "'_BitInt' %select{vector|matrix}0 element width must be %select{a power of 2|at least as wide as 'CHAR_BIT'}1"
H0C14DAF989FF: '_BitInt %select{ベクタ|行列}0の要素幅は%select{2のべき乗|CHAR_BIT以上}1である必要があります'
# "'_BitInt' in %select{C17 and earlier|C++}0 is a Clang extension"
HDE7EEC66FEFB: "「'_BitInt'」は%select{C17以前|C++}0ではClangの拡張機能です"
# "'_BitInt' suffix for literals is a C23 extension"
HA6733F109D23: '_BitIntのリテラル接尾辞はC23拡張です'
# "'_BitInt' suffix for literals is a Clang extension"
HE33869F03EE8: '_BitIntのリテラル接尾辞はClang拡張です'
# "'_BitInt' suffix for literals is incompatible with C standards before C23"
H8F9C2C09F088: 'C23以前のC規格では_BitIntのリテラル接尾辞は互換性ありません'
# "'_Complex %0' is invalid"
HF4E888A73841: "'_Complex %0' は無効です"
# "'_Countof' requires an argument of array type; %0 invalid"
H8DD99C0DA777: '_Countofは配列型の引数を必要とします; %0は無効です'
# "'_ExtInt' is deprecated; use '_BitInt' instead"
H6A2C7F4FE8E7: '_ExtIntは非推奨です; _BitIntを使用してください'
# "'_Noreturn' can only appear on functions"
H8C4082088BE9: '_Noreturn属性は関数にのみ適用できます'
# "'_Noreturn' keyword must precede function declarator"
HC448318DE5F1: '_Noreturnキーワードは関数宣言子の前に配置する必要があります'
# "'_Sat' specifier is only valid on '_Fract' or '_Accum', not '%0'"
H43A3B4233E86: "_Sat修飾子は'_Fract'または'_Accum'にのみ有効です; '%0'では無効"
# "'_Static_assert' with no message is a C23 extension"
H1BCF5D7E02AE: '_Static_assertにメッセージを省略した形式はC23拡張です'
# "'_Static_assert' with no message is incompatible with C standards before C23"
H977D55CE0649: "メッセージを指定しない「'_Static_assert'」はC23以前の標準仕様と互換性ありません"
# "'__FLT_EVAL_METHOD__' cannot be expanded inside a scope containing '#pragma clang fp eval_method'"
H2CAB7A2D4110: "「'__FLT_EVAL_METHOD__'」は「#pragma clang fp eval_method」を含むスコープ内で展開できません"
# "'__auto_type' is a GNU extension"
H2094509BC6E5: "「'__auto_type'」はGNU拡張機能です"
# "'__builtin_bit_cast' %select{source|destination}0 type must be trivially copyable"
H90D0B71921CD: "「'__builtin_bit_cast'」の%select{ソース|先}0の型はトラビアルにコピー可能でなければなりません"
# "'__builtin_choose_expr' requires a constant expression"
H090BF417F6DF: "「'__builtin_choose_expr'」には定数式が必要です"
# "'__builtin_counted_by_ref' argument cannot have side-effects"
HD566565DD11F: "「'__builtin_counted_by_ref'」の引数に副作用は許可されません"
# "'__builtin_counted_by_ref' argument must reference a flexible array member"
HABF270462F6F: "「'__builtin_counted_by_ref'」の引数はフレキシブル配列メンバを参照する必要があります"
# "'__builtin_ms_va_start' used in System V ABI function"
H007690BB92E1: '__builtin_ms_va_startがSystem V ABI関数で使用されています'
# "'__clang__' is a predefined macro name, not an attribute scope specifier; did you mean '_Clang' instead?"
HE8F991CDE8C6: "「'__clang__'」は予約済みマクロ名であり属性スコープ指定子ではありません。'_Clang'の意団でしたか？"
# "'__clang_arm_builtin_alias' attribute can only be applied to an ARM builtin"
H79EABB0EF1E5: "「'__clang_arm_builtin_alias'」属性はARM組み込み関数のみに適用できます"
# "'__clang_arm_mve_strict_polymorphism' attribute can only be applied to an MVE/NEON vector type"
H202E8786A308: "「'__clang_arm_mve_strict_polymorphism'」属性はMVE/NEONベクタータイプのみに適用できます"
# "'__declspec' attributes are not enabled; use '-fdeclspec' or '-fms-extensions' to enable support for __declspec attributes"
H465DF3E43560: "__declspec属性は有効になっていません。サポートするには'-fdeclspec'または'-fms-extensions'を指定してください"
# "'__declspec(dllexport)' cannot be applied to more than one default constructor in %0"
HB67031034443: "'__declspec(dllexport)'は%0のデフォルトコンストラクタに複数適用できません"
# "'__declspec(thread)' applied to variable that already has a thread-local storage specifier"
HFE6629E646D9: "'__declspec(thread)'は既にスレッド局所格納指定子が存在する変数には適用できません"
# "'__funcref' attribute can only be applied to a function pointer type"
H5101424932DE: "'__funcref'属性は関数ポインタ型のみに適用可能です"
# "'__kindof' specifier cannot be applied to non-object type %0"
HBB66D4C1FC38: "'__kindof'指定子は非オブジェクト型%0には適用できません"
# "'__kindof' type specifier must precede the declarator"
H111C48694838: "'__kindof'タイプ指定子は宣言子の前に配置する必要があります"
# "'__leave' statement not in __try block"
HA19FB1CE432F: "'__leave'文は__tryブロック外では使用できません"
# "'__local' variable cannot have an initializer"
H0B1BBFD1CDEA: '__local変数には初期化子を指定できません'
# "'__pixel' must be preceded by '__vector'.  '%0' declaration specifier not allowed here"
H88B3B9C40157: "__pixelは__vectorの前に置く必要があります。ここでの宣言仕様子'%0'は使用できません"
# "'__super' cannot be used with a using declaration"
HE7865E9E15F7: '__superはusing宣言と併用できません'
# "'__thread' before '%0'"
H4E940DC3AE07: "__threadが'%0'の前にあります"
# "'abi_tag' %0 missing in original declaration"
H1628165A1258: "オリジナル宣言に'abi_tag' %0が存在しません"
# "'abi_tag' attribute on %select{non-inline|anonymous}0 namespace ignored"
HDBC2CCB057F1: "'abi_tag'属性は%select{non-inline|anonymous}0名前空間では無視されます"
# "'abstract' keyword is a Microsoft extension"
HA16E3E3ED791: 'abstractキーワードはMicrosoftの拡張機能です'
# "'adjust_arg' argument %0 used in multiple clauses"
H05E9C9F203D8: "'adjust_arg'引数%0が複数の句で使用されています"
# "'align_value' attribute requires integer constant"
H6853424EF803: "'align_value'属性は整数定数が必要です"
# "'alignas' is incompatible with C++98"
H0BBFE28F35BF: 'alignasはC++98と互換性ありません'
# "'aligned' attribute requires integer constant"
H1ADA356A8681: "'aligned'属性は整数定数が必要です"
# "'alignof' on an incomplete array type is a C2y extension"
HFD6D41C433A2: '未完成配列型のalignofはC2y拡張機能です'
# "'alignof' on an incomplete array type is incompatible with C standards before C2y"
HF644B202EC9A: '未完成配列型のalignofはC2y以前のC規格と互換性ありません'
# "'append_args' is not allowed with varargs functions"
H99449471B7D4: "'append_args'は可変長引数関数では使用できません"
# "'assign' property of object type may become a dangling reference; consider using 'unsafe_unretained'"
H7256F2B86929: "オブジェクト型のassignプロパティはdangling参照になる可能性があります。'unsafe_unretained'の使用を検討してください"
# "'atomic capture' with a compound statement only supports two statements"
H0E46970C2D96: "'atomic capture'は複合ステートメントで2つのステートメントのみサポートされます"
# "'auto' as a functional-style cast is incompatible with C++ standards before C++23"
HD4DCD08E6C51: 'autoを関数風キャストとして使用することはC++23以前の規格と互換性ありません'
# "'auto' deduced as 'id' in declaration of %0"
HD22AA217F352: "'auto'は%0の宣言において'id'と推論されました"
# "'auto' return without trailing return type; deduced return types are a C++14 extension"
H2CC514506858: 'auto戻り値にトレーリング返り値型がありません。推論返り値型はC++14拡張機能です'
# "'auto' storage class specifier is not permitted in C++11, and will not be supported in future releases"
H51939B968318: 'autoストレージクラス仕様子はC++11では許可されず、今後のリリースでもサポートされません'
# "'auto' storage class specifier is redundant and incompatible with C++11"
HFAD8EB4C5407: '「auto」ストレージ修飾子は余分で、C++11と互換性ありません'
# "'auto' type specifier is a %select{C++11|HLSL 202y}0 extension"
H96C499C3C66C: '「auto」型指定子は%select{C++11|HLSL 202y}0の拡張機能です'
# "'auto' type specifier is incompatible with C++98"
HA4F3AA6BB021: '「auto」型指定子はC++98と互換性ありません'
# "'auto' variable template instantiation is not allowed"
H7677E31876EE: '「auto」変数テンプレートのインスタンス化は許可されていません'
# "'begin' and 'end' returning different types (%0 and %1) is a C++17 extension"
H440F964925D8: '「begin」と「end」が異なる型（%0 と %1）を返すことはC++17の拡張機能です'
# "'begin' and 'end' returning different types (%0 and %1) is incompatible with C++ standards before C++17"
HCE5BB9C433E6: '「begin」と「end」が異なる型（%0 と %1）を返すことはC++17以前の標準と互換性ありません'
# "'break' is bound to loop, GCC binds it to switch"
HB56827FEFDD0: '「break」はループに束縛されますが、GCCはスイッチに束縛します'
# "'break' statement not in loop or switch statement"
HD351562F6355: '「break」文はループまたはスイッチ文の外で使用できません'
# "'break' will never be executed"
H6E907B3877AE: '「break」は実行されません'
# "'callback' argument at position %0 references unavailable implicit 'this'"
HFC4B047896FC: '「callback」引数の位置%0で、利用できない暗黙の「this」を参照しています'
# "'callback' attribute argument %0 is not a known function parameter"
H5112D2E8FE1B: '「callback」属性の引数%0は、既知の関数パラメータではありません'
# "'callback' attribute callee does not have function type"
H11C2E7DC48A0: '「callback」属性の呼び出し元には関数型がありません'
# "'callback' attribute callee may not be variadic"
H5339D3799089: '「callback」属性の呼び出し元は可変長関数です'
# "'callback' attribute specifies invalid callback callee"
HAE51B1A6C397: '「callback」属性が無効なコールバック呼び出し元を指定しています'
# "'callback' attribute specifies no callback callee"
HC67CEF8B86D2: '「callback」属性がコールバック呼び出し元を指定していません'
# "'called_once' attribute only applies to function-like parameters"
HFCB51789AAF0: '「called_once」属性は関数のようなパラメータにのみ適用されます'
# "'case' statement not in switch statement"
H3C29CC73E754: '「case」文はswitch文の外で使用できません'
# "'char8_t' type specifier is incompatible with C++ standards before C++20"
H6EF68EF28349: '「char8_t」型指定子はC++20以前の標準と互換性ありません'
# "'cleanup' argument %select{|%1 |%1 }0is not a %select{||single }0function"
HF9B0713C400E: '「cleanup」引数%select{|%1 |%1 }0は%select{||単一の }0関数ではありません'
# "'cleanup' function %0 must take 1 parameter"
H70C0FCE6BEDE: '「cleanup」関数%0は1つのパラメータを取る必要があります'
# "'cleanup' function %0 parameter has %diff{type $ which is incompatible with type $|incompatible type}1,2"
H24491DE4E886: "'cleanup' 関数 %0 のパラメータは %diff{型 $ は型 $ と互換性がありません|互換性のない型}1,2 を持っています"
# "'cmse_nonsecure_entry' cannot be applied to functions with internal linkage"
H36BD2CDFCAC5: "'cmse_nonsecure_entry' は内部リンク付きの関数には適用できません"
# "'co_await' modifier can only be applied to range-based for loop"
H23B6AEBD1B5B: "'co_await' モディファイアは範囲ベースの for ループのみに適用できます"
# "'const' attribute imposes more restrictions; 'pure' attribute ignored"
HAC8EEAA61CD9: "'const' 属性により制約が追加されます；'pure' 属性は無視されます"
# "'consteval' specifier is incompatible with C++ standards before C++20"
HFAB40415D777: "'consteval' 指定子はC++20以前のC++標準と互換性がありません"
# "'constexpr' can only be used in variable declarations"
HCCD21640DBE9: "'constexpr' は変数宣言でのみ使用できます"
# "'constexpr' non-static member function will not be implicitly 'const' in C++14; add 'const' to avoid a change in behavior"
H23AE1DDB6BF2: "C++14では 'constexpr' 非静的メンバ関数は暗黙のうちに 'const' とみなされなくなります；動作の変更を避けるには 'const' を追加してください"
# "'constexpr' on lambda expressions is a C++17 extension"
H99E246301B16: "ラムダ式での 'constexpr' はC++17の拡張機能です"
# "'constexpr' specifier is incompatible with C++98"
H26D17B863D82: "'constexpr' 指定子はC++98と互換性がありません"
# "'constinit' specifier added after initialization of variable"
H941EB6451F6C: "変数の初期化後に 'constinit' 指定子が追加されました"
# "'constinit' specifier is incompatible with C++ standards before C++20"
HA94D78D91751: "'constinit' 指定子はC++20以前のC++標準と互換性がありません"
# "'constinit' specifier missing on initializing declaration of %0"
H55C3572EEC7C: "%0 の初期化宣言に 'constinit' 指定子がありません"
# "'continue' statement not in loop statement"
HCD539EA88B8F: "'continue' 文がループ文に含まれていません"
# "'copy' attribute must be specified for the block property when -fobjc-gc-only is specified"
H87791A0AEA62: "-fobjc-gc-only を指定した場合、ブロックプロパティには 'copy' 属性を指定する必要があります"
# "'counted_by' cannot refer to the flexible array member %0"
H5B04880F56A4: "'counted_by' は柔軟な配列メンバー %0 を参照できません"
# "'counted_by' on arrays only applies to C99 flexible array members"
HB17E489D7021: "配列における 'counted_by' はC99の柔軟な配列メンバーのみに適用されます"
# "'cpu_dispatch' function redeclared with different CPUs"
HCA2FB0047F16: "異なるCPUで 'cpu_dispatch' 関数が再宣言されました"
# "'decltype' type specifier is incompatible with C++98"
H06E59DDEED89: "'decltype' 型指定子はC++98と互換性がありません"
# "'decltype(auto)' can only be used as a return type in a function declaration"
H5356DF2FE6D3: "'decltype(auto)' は関数宣言の戻り値型としてのみ使用できます"
# "'decltype(auto)' cannot be combined with other type specifiers"
H139F443827AC: "'decltype(auto)' は他の型指定子と組み合わせて使用できません"
# "'decltype(auto)' not allowed here"
HA795F2923798: "ここでは'decltype(auto)'は使用できません"
# "'decltype(auto)' type specifier is a C++14 extension"
H7E1DB4CB833F: "'decltype(auto)'型修飾子はC++14の拡張機能です"
# "'decltype(auto)' type specifier is incompatible with C++ standards before C++14"
HA38CAC8829B9: "C++14以前の標準では'decltype(auto)'型修飾子は互換性がありません"
# "'default' statement not in switch statement"
H1133498536DD: "'default'ステートメントはswitch文外では使用できません"
# "'defined' cannot appear within this context"
HDAE80537A1D3: "このコンテキスト内では'defined'を使用できません"
# "'defined' cannot be used as a macro name"
HB4BA3900B80E: "'defined'はマクロ名として使用できません"
# "'delete%select{|[]}0' applied to a pointer that was allocated with 'new%select{[]|}0'; did you mean 'delete%select{[]|}0'?"
H84CC0C534191: "'delete%select{|[]}0'は'new%select{[]|}0'で割り当てられたポインタに対して使用できません; 'delete%select{[]|}0'を意図したのではないでしょうか？"
# "'delete' applied to a pointer-to-array type %0 treated as 'delete[]'"
H011BFAE8BB84: "ポインタ配列型%0に対する'delete'は'delete[]'として扱われます"
# "'delete' cannot delete objects of type %0 in address space '%1'"
H7E66A4AF7B26: "アドレス空間'%1'内の型%0のオブジェクトを'delete'で削除することはできません"
# "'depend' clause for 'ordered' is deprecated; use 'doacross' instead"
HB07DCDAB27B1: "'ordered'の'depend'句は廃止されました; 代わりに'doacross'を使用してください"
# "'depend' clause requires the 'targetsync' interop type"
H2DD7E54EBF24: "'depend'句は'targetsync'インターパップタイプが必要です"
# "'deprecated' attribute on anonymous namespace ignored"
HE49B32CE23AF: "匿名ネームスペースにおける'deprecated'属性は無視されます"
# "'device_type(%0)' does not match previously specified 'device_type(%1)' for the same declaration"
HDE923438E688: "同じ宣言で以前に指定された'device_type(%1)'と'device_type(%0)'が一致しません"
# "'diagnose_if' is a clang extension"
H6ABE610AE6BE: "'diagnose_if'はclangの拡張機能です"
# "'dllexport' attribute ignored on explicit instantiation definition"
H5570C9EC211D: "明示的なインスタンテーション定義における'dllexport'属性は無視されます"
# "'enable_if' is a clang extension"
HF8D51A54A3FE: "'enable_if'はclangの拡張機能です"
# "'explicit' can only appear on non-static member functions"
H4ED84C1B6695: "'explicit'は非静的メンバ関数にのみ使用できます"
# "'explicit' can only be applied to a constructor or conversion function"
H31AF261810E7: "'explicit'はコンストラクタまたは変換関数にのみ適用できます"
# "'explicit' can only be specified inside the class definition"
H4954093357D9: "'explicit'はクラス定義内でのみ指定できます"
# "'explicit' is not permitted on top-level modules"
HDAE06689A152: "'explicit'はトップレベルのモジュールでは使用できません"
# "'extern' variable has an initializer"
HB91B40E25B4C: '「extern」変数には初期化子が指定できません'
# "'extern' variable may not be referenced by '%0' clause on an OpenACC 'declare' directive"
H270234BE5B42: '「extern」変数はOpenACC「declare」ディレクティブの「%0」句で参照できません'
# "'flush' directive with memory order clause '%0' cannot have the list"
HC2158D6851BB: 'メモリオーダー句「%0」を持つ「flush」ディレクティブにはリストを指定できません'
# "'for co_await' belongs to CoroutineTS instead of C++20, which is deprecated"
H6DA54D0F5428: '「for co_await」はC++20ではなくCoroutineTSに属し、廃止予定です'
# "'friend' must appear first in a non-function declaration"
HEBE4422274B2: '非関数宣言では「friend」が最初に現れる必要があります'
# "'friend' used outside of class"
HABD952B07FCB: '「friend」はクラスの外で使用できません'
# "'gnu_inline' attribute requires function to be marked 'inline', attribute ignored"
HEDCF2C7F36F0: '「gnu_inline」属性は関数が「inline」でマークされている必要があります。属性は無視されました'
# "'gnu_inline' attribute without 'extern' in C++ treated as externally available, this changed in Clang 10"
H021467CD0886: 'C++の「gnu_inline」属性に「extern」がない場合、Clang 10以降では外部で利用可能と見なされます'
# "'hybrid_patchable' is ignored on functions without external linkage"
H0ADF7398ED3A: '外部リンクがない関数では「hybrid_patchable」が無視されます'
# "'inline' can only appear on functions%select{| and non-local variables}0"
H89E78E1738F9: '「inline」は関数%select{|および非ローカル変数}0にのみ使用できます'
# "'inscan' modifier can be used only in 'omp for', 'omp simd', 'omp for simd', 'omp parallel for', or 'omp parallel for simd' directive"
HD994FA838907: '「inscan」修飾子は「omp for」、「omp simd」、「omp for simd」、「omp parallel for」、または「omp parallel for simd」ディレクティブでしか使用できません'
# "'internal_linkage' attribute on a non-static local variable is ignored"
H66A8BF53EA8F: '非静的ローカル変数の「internal_linkage」属性は無視されます'
# "'lifetime_capture_by' argument references itself"
H3627CC1FAD24: '「lifetime_capture_by」属性の引数が自分自身を参照しています'
# "'lifetime_capture_by' argument references unavailable implicit 'this'"
HCCCF5641FC93: '「lifetime_capture_by」属性の引数が利用できない暗黙の「this」を参照しています'
# "'lifetime_capture_by' attribute argument %0 is not a known function parameter; must be a function parameter, 'this', 'global' or 'unknown'"
H3A8F776F3ADB: "「lifetime_capture_by」属性の引数%0は既知の関数パラメータではありません; 関数パラメータ、'this'、'global'、または'unknown'でなければなりません"
# "'lifetime_capture_by' attribute specifies no capturing entity"
HA61E4C8D2E68: '「lifetime_capture_by」属性のキャプチャエンティティが指定されていません'
# "'lifetimebound' attribute cannot be applied to a %select{constructor|destructor}0"
H67DD72C3F644: '「lifetimebound」属性は%select{コンストラクタ|デストラクタ}0に適用できません'
# "'lifetimebound' attribute cannot be applied to a parameter of a function that returns void; did you mean 'lifetime_capture_by(X)'"
H7AF0F9960FBE: '「lifetimebound」属性はvoidを返す関数のパラメータには適用できません; 「lifetime_capture_by(X)」が意図でしたか？'
# "'lifetimebound' attribute cannot be applied to an implicit object parameter of a function that returns void; did you mean 'lifetime_capture_by(X)'"
H246C1F79D057: '「lifetimebound」属性はvoidを返す関数の暗黙オブジェクトパラメータには適用できません; 「lifetime_capture_by(X)」が意図でしたか？'
# "'lifetimebound' attribute cannot be applied; %select{non-|static |explicit object }0member function has no implicit object parameter"
H4EDB6AB20113: '「lifetimebound」属性は適用できません; %select{非-|static |explicit object }0メンバー関数には暗黙オブジェクトパラメータがありません'
# "'linear' clause cannot be specified along with 'ordered' clause with a parameter"
H20416EEA599F: '「linear」句は、パラメータ付きの「ordered」句と同時に指定できません'
# "'long long' is a C++11 extension"
HC63DB1FBE144: '「long long」はC++11の拡張機能です'
# "'long long' is an extension when C99 mode is not enabled"
H90F12D1B1D4D: 'C99モードが有効でない場合、「long long」は拡張機能となります'
# "'long long' is incompatible with C++98"
H0DAB29466D2C: '「long long」はC++98と互換性がありません'
# "'main' cannot be a multiversioned function"
HAFF8B40A53DE: '「main」関数はマルチバージョン化できません'
# "'main' is not allowed to be declared %select{constexpr|consteval}0"
H13F25D825A17: '「main」は%select{constexpr|consteval}0として宣言できません'
# "'main' is not allowed to be declared _Noreturn"
HE455B9A59591: '「main」は_Noreturnとして宣言できません'
# "'main' is not allowed to be declared inline"
HBC0A4A59C65E: '「main」はinlineとして宣言できません'
# "'main' is not allowed to be declared static"
HB1B95BDA01B7: '「main」はstaticとして宣言できません'
# "'main' is not allowed to be declared variadic"
HD3EE247E6A72: '「main」は変数引数として宣言できません'
# "'main' is not allowed to be deleted"
HB0C6AFB93EDB: '「main」は削除できません'
# "'main' must return 'int'"
HD54CCE2AF684: "「main」は'int'を返す必要があります"
# '\'main\' should not be \'extern "%select{C|C++}0"\''
H19102C631788: '「main」は\'extern "%select{C|C++}0"\'であってはいけません'
# "'main' should not be declared static"
H9A6B59304912: '「main」はstaticとして宣言すべきではありません'
# "'malloc' argument %0 must take a pointer type as its first argument"
HEF17CC57A675: '「malloc」引数%0は最初の引数としてポインタ型を取る必要があります'
# "'malloc' argument %select{for deallocator |%1 |%1 }0is not a %select{||single }0function"
HC684E8204794: '「malloc」引数%select{解放用の|%1 |%1 }0は%select{||単一の }0関数ではありません'
# "'malloc' argument '%0' refers to non-pointer type %1 of %2"
HFD06C554D4E6: "「malloc」引数'%0'は%2の非ポインタ型%1を指しています"
# "'mig_server_routine' attribute only applies to routines that return a kern_return_t"
HF1C5C16FC7E6: '「mig_server_routine」属性はkern_return_tを返すルーチンにのみ適用されます'
# "'module' declaration found while building header unit"
HA86B9DC6C734: 'ヘッダーユニットを構築中に「module」宣言が見つかりました'
# "'module' declaration found while building module from module map"
H880BB7F53078: 'モジュールマップからモジュールを構築中に「module」宣言が見つかりました'
# "'module;' introducing a global module fragment can appear only at the start of the translation unit"
H617DC2BE71CE: '「module;」で導入されるグローバル・モジュール・フラグメントは、翻訳単位の開始部にしか置けません'
# "'musttail' attribute for this call is impossible because %select{long calls cannot be tail called on PPC|indirect calls cannot be tail called on PPC|external calls cannot be tail called on PPC}0"
H14240DA28AAD: '「musttail」属性は、%select{ PPCでは長い呼び出しはテールコールできません| PPCでは間接呼び出しはテールコールできません| PPCでは外部呼び出しはテールコールできません}0 のため、この呼び出しには適用できません'
# "'musttail' attribute is not supported on AIX"
H92717FE13CEF: 'AIXでは「musttail」属性はサポートされていません'
# "'mutable' and 'const' cannot be mixed"
H6CE01BCA1797: '「mutable」と「const」は併用できません'
# "'mutable' can only be applied to member variables"
HC1CD8F78BDE1: '「mutable」はメンバ変数にのみ適用できます'
# "'mutable' cannot be applied to functions"
H9B6452717014: '「mutable」は関数には適用できません'
# "'mutable' cannot be applied to references"
H7CCDA0B2596A: '「mutable」は参照には適用できません'
# "'mutable' on a reference type is a Microsoft extension"
H6E975C04AF4E: '参照型に対する「mutable」はMicrosoftの拡張機能です'
# "'mutexinoutset' modifier not allowed in 'depend' clause on 'taskwait' directive"
H54D9DFD0A59D: '「taskwait」ディレクティブの「depend」節では「mutexinoutset」修飾子は許可されていません'
# "'new' cannot allocate an array of %0 with no explicit ownership"
H01CEEA4215DD: '明示的な所有権がない%0の配列を「new」で割り当てることはできません'
# "'new' cannot allocate object of variably modified type %0"
HB68377C1CB34: '可変長修飾型%0のオブジェクトを「new」で割り当てることはできません'
# "'new' cannot allocate objects of type %0 in address space '%1'"
H8F2EE8209986: 'アドレス空間「%1」内の型%0のオブジェクトを「new」で割り当てることはできません'
# "'new' expression with placement arguments refers to non-placement 'operator delete'"
H9A938FDFCB36: '配置引数を伴う「new」式が配置を伴わない「operator delete」を参照しています'
# "'nocf_check' attribute ignored; use -fcf-protection to enable the attribute"
HCD98AFA044EC: '「nocf_check」属性は無視されました; 属性を有効にするには -fcf-protection を使用してください'
# "'noderef' can only be used on an array or pointer type"
H265BDBEEC1EC: '「noderef」は配列またはポインタ型にのみ使用できます'
# "'noexcept' can only be used in a compound requirement (with '{' '}' around the expression)"
H88CA64B4E3F6: '「noexcept」は複合要件（式を「{」「}」で囲む形）でのみ使用できます'
# "'nonmonotonic' modifier can only be specified with 'dynamic' or 'guided' schedule kind"
H60F2BCD19874: '「nonmonotonic」修飾子は「dynamic」または「guided」スケジュール種別と共に指定する必要があります'
# "'nonnull' attribute applied to function with no pointer arguments"
H0D4CBB499E30: 'ポインタ引数のない関数に「nonnull」属性が適用されました'
# "'nonnull' attribute when used on parameters takes no arguments"
H8544A5398585: 'パラメータに「nonnull」属性を使用する場合、引数は必要ありません'
# "'nothrow' attribute conflicts with exception specification; attribute ignored"
HA43C7748DBD1: '「nothrow」属性は例外指定と競合しています; 属性は無視されました'
# "'nowait' clause is here"
H4C9748BD1A0B: "'nowait'句はここにあります"
# "'nullptr' is a C23 extension"
H0CCA94E13259: "'nullptr'はC23拡張機能です"
# "'nullptr' is incompatible with C++98"
HA3F1CF3D3055: "'nullptr'はC++98と互換性がありません"
# "'objc_bridge(id)' is only allowed on structs and typedefs of void pointers"
H19339C3149E3: "'objc_bridge(id)'はvoidポインタの構造体型またはtypedefにのみ使用可能です"
# "'objc_class_stub' attribute cannot be specified on a class that does not have the 'objc_subclassing_restricted' attribute"
H131E98846FD9: "'objc_class_stub'属性は'objc_subclassing_restricted'属性がないクラスには指定できません"
# "'objc_designated_initializer' attribute only applies to init methods of interface or class extension declarations"
H0C4330D28BB6: "'objc_designated_initializer'属性はインターフェースまたはクラス拡張宣言のinitメソッドにのみ適用されます"
# "'objc_direct' attribute cannot be applied to %select{methods|properties}0 declared in an Objective-C protocol"
H0E0D013ED449: "'objc_direct'属性はObjective-Cプロトコル内で宣言された%select{メソッド|プロパティ}0には適用できません"
# "'objc_externally_retained' can only be applied to local variables %select{of retainable type|with strong ownership}0"
H863E7A12B731: "'objc_externally_retained'は%select{retain可能な型の|strong所有権の}0ローカル変数にのみ適用可能です"
# "'objc_independent_class' attribute may be put on Objective-C object pointer type only; attribute is ignored"
H917C3A1684AC: "'objc_independent_class'属性はObjective-Cオブジェクトポインタ型にのみ付与可能; 属性は無視されました"
# "'objc_independent_class' attribute may be put on a typedef only; attribute is ignored"
HCF5FB9401D67: "'objc_independent_class'属性はtypedefにのみ付与可能; 属性は無視されました"
# "'omp_interop_t' must be defined when 'append_args' clause is used; include <omp.h>"
H584E24086261: "'omp_interop_t'は'append_args'句を使用する場合に定義が必要です; <omp.h>を含めること"
# "'ompx_attribute' clause only allows 'amdgpu_flat_work_group_size', 'amdgpu_waves_per_eu', and 'launch_bounds'; %0 is ignored"
H15379B8D06F4: "'ompx_attribute'句は'amdgpu_flat_work_group_size', 'amdgpu_waves_per_eu', 'launch_bounds'のみ許可; %0は無視されました"
# "'ompx_bare' clauses requires explicit grid size via 'num_teams' and 'thread_limit' clauses"
HC78DCADADB1C: "'ompx_bare'句は'num_teams'および'thread_limit'句を通じて明示的なグリッドサイズを指定する必要があります"
# "'operator new' provided by %0 is not usable with the function signature of %1"
HC75862C47BD1: "%0で提供された'operator new'は%1の関数シグネチャと互換性がありません"
# "'operator->' declared here produces an object of type %0"
HC1D7E6DA4A9D: "ここで宣言された'operator->'は型%0のオブジェクトを生成します"
# "'ordered' clause with a parameter cannot be specified in '#pragma omp %0' directive"
HE291A06801DB: "'ordered'句でパラメータを指定することは'#pragma omp %0'ディレクティブではできません"
# "'ordered' clause%select{| with specified parameter}0"
H337028DA61A4: "'ordered'句%select{|指定されたパラメータ付き}0"
# "'ordered' directive %select{without any clauses|with 'threads' clause}0 cannot be closely nested inside ordered region with specified parameter"
HB16FD1003ED0: "'ordered'ディレクティブ%select{句なし|'threads'句付き}0は指定されたパラメータ付きordered領域内に近接ネストできません"
# "'ordered' directive with '%0' clause cannot be closely nested inside ordered region without specified parameter"
H1845D44BB3DE: "'%0'句付きの'ordered'ディレクティブはパラメータなしのordered領域内に近接ネストできません"
# "'overloadable' function %0 must have a prototype"
HA041210B9619: "'overloadable'関数%0にはプロトタイプが必要です"
# "'ownership_returns' attribute index does not match; here it is %0"
H1C0451B398DB: "'ownership_returns'属性のインデックスが一致しません; ここでは%0です"
# "'ownership_returns' attribute only applies to functions that return a pointer"
HE96B6120100D: "'ownership_returns'属性はポインタを返す関数にのみ適用されます"
# "'ownership_takes' attribute class does not match; here it is '%0'"
H2E44647C4A59: "'ownership_takes'属性のクラスが一致しません; ここでは'%0'です"
# "'packed' attribute was ignored on bit-fields with single-byte alignment in older versions of GCC and Clang"
H8DB05E11AD0A: "'packed'属性は古いバージョンのGCCやClangでは、単一バイトアライメントのビットフィールドに対して無視されていました"
# "'reduction' clause cannot be used with 'nogroup' clause"
H186A32581806: "'reduction'句は'nogroup'句と同時に使用できません"
# "'reduction' clause not allowed with '#pragma omp loop bind(teams)'"
H4981CB6A6643: "'#pragma omp loop bind(teams)'では'reduction'句の使用が許可されていません"
# "'reduction' clause with 'inscan' modifier is used here"
HE04EBCC11985: "'reduction'句に'inscan'修飾子が使用されています"
# "'reduction' clause with 'task' modifier allowed only on non-simd parallel or worksharing constructs"
HD0FEE7231060: "'task'修飾子付き'reduction'句は非シムド並列またはワークシェアリング構文でのみ許可されます"
# "'register' storage class specifier is deprecated and incompatible with C++17"
HDBC08F071224: "'register'ストレージクラス指定子は非推奨で、C++17と互換性がありません"
# "'register' storage specifier on @catch parameter will be ignored"
H4232960B8CCE: "@catchパラメータの'register'ストレージ指定子は無視されます"
# "'regparm' is not valid on this platform"
H1E534F14C852: "'regparm'はこのプラットフォームでは有効ではありません"
# "'regparm' parameter must be between 0 and %0 inclusive"
H63349C70781C: "'regparm'パラメータは0以上%0以下の数値でなければなりません"
# "'reinterpret_cast' %select{from|to}3 class %0 %select{to|from}3 its %select{virtual base|base at non-zero offset}2 %1 behaves differently from 'static_cast'"
HF87527FE7FBB: "'reinterpret_cast' %select{から|への}3クラス%0 %select{への|からの}3その%select{仮想ベース|オフセット付き基底}2 %1は'static_cast'と異なります"
# "'require_constant_initialization' attribute added after initialization of variable"
HCCF005312D01: "'require_constant_initialization'属性は変数の初期化後に追加されました"
# "'restrict' qualifier on an array of pointers is a C23 extension"
H831A2BF01322: "ポインタ配列の'restrict'修飾子はC23拡張です"
# "'restrict' qualifier on an array of pointers is incompatible with C standards before C23"
H7AB582A89AF4: "ポインタ配列の'restrict'修飾子はC23より前の仕様と互換性ありません"
# "'return' will never be executed"
HF9D8B2478204: "'return'は実行されません"
# "'sealed' keyword is a Microsoft extension"
H2371564F3064: "'sealed'キーワードはマイクロソフトの拡張です"
# "'selectany' can only be applied to data items with external linkage"
H0D95115281D5: "'selectany'は外部リンカブルなデータ項目にのみ適用されます"
# "'sentinel' attribute only supported for variadic %select{functions|blocks}0"
H0C7CDE5CC83E: "'sentinel'属性は可変長%select{関数|ブロック}0でのみ有効です"
# "'sentinel' attribute requires named arguments"
HB4DB8DB54C63: "'sentinel'属性には名前付き引数が必要です"
# "'sentinel' parameter 1 less than zero"
HE854964454A6: "'sentinel'のパラメータ1は0未満です"
# "'sentinel' parameter 2 not 0 or 1"
H99541E948450: "'sentinel'のパラメータ2は0または1でない"
# "'size' argument to bzero is '0'"
H50A840FAEA15: "bzeroの'size'引数は'0'です"
# "'size_t' suffix for literals is a C++23 extension"
HE55B1E186F37: "文字列リテラルの'size_t'接尾辞はC++23の拡張機能です"
# "'size_t' suffix for literals is a C++23 feature"
HFE4E8B889F8C: "文字列リテラルの'size_t'接尾辞はC++23の機能です"
# "'size_t' suffix for literals is incompatible with C++ standards before C++23"
H01C26A9D5D7B: "文字列リテラルの'size_t'接尾辞はC++23以前のC++規格では互換性ありません"
# "'static' can only be specified inside the class definition"
HC2C3574A2AC5: "'static'はクラス定義内でしか指定できません"
# "'static' function %0 declared in header file should be declared 'static inline'"
HAC6B8325923D: "ヘッダーファイルで宣言された'static'関数%0は'static inline'で宣言すべきです"
# "'static' may not be used with an unspecified variable length array size"
H8C886B8B17D3: "配列サイズが未指定の場合は'static'を使用できません"
# "'static' may not be used without an array size"
H3CD973765C05: "配列サイズが未指定の場合は'static'を使用できません"
# "'static' member function %0 overrides a virtual function in a base class"
H917973A36E2C: "'static'メンバ関数%0は基本クラスの仮想関数をオーバーライドしています"
# "'static_assert' declarations are incompatible with C++98"
HEBCFD6945359: "'static_assert'宣言はC++98と互換性がありません"
# "'static_assert' with a user-generated message is a C++26 extension"
HFCA41F0C6554: "'static_assert'宣言はC++98では互換性ありません"
# "'static_assert' with a user-generated message is incompatible with C++ standards before C++26"
H71F257CCE8FF: "ユーザー生成メッセージ付き'static_assert'はC++26拡張機能です"
# "'static_assert' with no message is a C++17 extension"
H89070CD2F991: "ユーザー生成メッセージなしの'static_assert'はC++26以前のC++規格では互換性ありません"
# "'static_assert' with no message is incompatible with C++ standards before C++17"
HFE8F37E6AE5C: "メッセージなしの'static_assert'はC++17拡張機能です"
# "'std::allocator<...>::deallocate' used to delete a null pointer"
HF2B279909DBC: "'std::allocator<...>::deallocate'がNULLポインタを削除するために使用されました"
# "'std::source_location::__impl' must be standard-layout and have only two 'const char *' fields '_M_file_name' and '_M_function_name', and two integral fields '_M_line' and '_M_column'"
HCA27D3915F0B: "'std::allocator<...>::deallocate'がNULLポインタを解放しようとしました"
# "'std::source_location::__impl' was not found; it must be defined before '__builtin_source_location' is called"
HD0F806FB73A8: "'std::source_location::__impl'は標準レイアウトで、'_M_file_name'と'_M_function_name'というconst char*フィールド2つ、'_M_line'と'_M_column'という整数型フィールド2つしか持てません"
# "'super' is only valid in a method body"
HB06D73D4C0E7: "'super'はメソッド本文でのみ有効です"
# "'swift_async' completion handler parameter must have block type returning 'void', type here is %0"
H9874890FB098: "'swift_async'完了ハンドラパラメータは'returning 'void''のブロック型でなければなりません。ここでの型は%0です"
# "'swift_error_result' parameter must follow 'swift_context' parameter"
HFA5F4F66F83B: "'swift_error_result'パラメータは'swift_context'パラメータの後に配置する必要があります"
# "'swift_indirect_result' parameters must be first parameters of function"
H624EF03C7676: "'swift_indirect_result'パラメータは関数の最初のパラメータでなければなりません"
# "'switch' missing 'default' label"
H855B85E209CE: "'switch'に'default'ラベルがありません"
# "'sycl_kernel' attribute only applies to a function template with at least two template parameters"
H5AFFA7408711: "'sycl_kernel'属性は、少なくとも2つのテンプレートパラメータを持つ関数テンプレートにのみ適用されます"
# "'sycl_kernel_entry_point' attribute cannot be added to a function after the function is defined"
H018E12D5A5B2: "'sycl_kernel_entry_point'属性は関数が定義された後に追加できません"
# "'sycl_kernel_entry_point' attribute cannot be applied to a %select{non-static member function|variadic function|deleted function|defaulted function|constexpr function|consteval function|function declared with the 'noreturn' attribute|coroutine|function defined with a function try block}0"
H86CAEB999295: "'sycl_kernel_entry_point'属性は%select{非静的メンバ関数|変数引数関数|削除された関数|デフォルトされた関数|constexpr関数|consteval関数|'noreturn'属性で宣言された関数|コルーチン|関数トライブロックで定義された関数}0の関数には適用できません"
# "'sycl_kernel_entry_point' attribute only applies to functions with a 'void' return type"
H99CA3F9B2DC2: "'sycl_kernel_entry_point'属性は'return type'が'void'である関数にのみ適用されます"
# "'sycl_kernel_entry_point' attribute only applies to functions with a non-deduced 'void' return type"
H14251E8B39CA: "'sycl_kernel_entry_point'属性は'return type'が推論されない'void'である関数にのみ適用されます"
# "'sycl_kernel_entry_point' kernel name argument conflicts with a previous declaration"
HFAE6DB6B8BBB: "'sycl_kernel_entry_point'カーネル名引数が以前の宣言と競合しています"
# "'sycl_kernel_entry_point' kernel name argument does not match prior declaration%diff{: $ vs $|}0,1"
H6714A3237372: "'sycl_kernel_entry_point'カーネル名引数は以前の宣言と一致しません%diff{: $ と $ が一致しません|}0,1"
# "'target_clones' attribute does not match previous declaration"
HBD2CF88C376B: "'target_clones'属性は以前の宣言と一致しません"
# "'target_clones' multiversioning requires a default target"
HCC23909A82CE: "'target_clones'マルチバージョニングにはデフォルトターゲットが必要です"
# "'template' cannot be used after a declarative nested name specifier"
H7173607CA62C: "'template'は宣言的なネスト名指定子の後に使用できません"
# "'template' keyword not permitted after 'using' keyword"
H026D09D01933: "'template'キーワードは'using'キーワードの後に使用できません"
# "'template' keyword not permitted here"
HF55CDE212145: "'template'キーワードはここでは使用できません"
# "'template' keyword not permitted in destructor name"
H67CEB40C2F65: "'template' キーワードはデストラクタ名では使用できません"
# "'template' keyword outside of a template"
H5580CDE2DB12: "'template' キーワードはテンプレートの外では使用できません"
# "'template<>' header not required for explicitly-specialized class %0 declared here"
H3FF5BAF37ECE: "'template<>' ヘッダーは明示的に特殊化されたクラス %0 で必要ありません"
# "'this' argument to member function %0 has type %1, but function is not marked %select{const|restrict|const or restrict|volatile|const or volatile|volatile or restrict|const, volatile, or restrict}2"
HB5D291C13072: "'this' 引数のメンバ関数 %0 の型は %1 ですが、関数は %select{const|restrict|constまたはrestrict|volatile|constまたはvolatile|volatileまたはrestrict|const、volatile、またはrestrict}2 としてマークされていません"
# "'this' argument to member function %0 is an %select{lvalue|rvalue}1, but function has %select{non-const lvalue|rvalue}2 ref-qualifier"
H0AF4BFFD004C: "'this' 引数のメンバ関数 %0 は %select{左辺値|右辺値}1 ですが、関数は %select{constではない左辺値|右辺値}2 ref-qualifier を持っています"
# "'this' cannot be %select{implicitly |}0captured in this context"
H0697D44E3441: "'this' はこの文脈で%select{暗黙に |}0キャプチャできません"
# "'this' cannot be captured by reference"
H13B6762030CD: "'this' を参照でキャプチャすることはできません"
# "'this' cannot be%select{| implicitly}0 used in a static member function declaration"
H4C9AC15A6831: "'this' は静的メンバ関数宣言で%select{ |暗黙に}0使用できません"
# "'this' pointer cannot be null in well-defined C++ code; comparison may be assumed to always evaluate to %select{true|false}0"
HC979F6DEC864: "'this' ポインタは、明確に定義されたC++コードではnullになることはありません; 比較は常に%select{true|false}0と評価されるものとみなされる場合があります"
# "'this' pointer cannot be null in well-defined C++ code; pointer may be assumed to always convert to true"
HE4633A40CE28: "'this' ポインタは、明確に定義されたC++コードではnullになることはありません; ポインタは常にtrueに変換されるものとみなされる場合があります"
# "'this' pointer references not allowed in naked functions"
H95FED6FF2C73: "ヌード関数では'this'ポインタへの参照は許可されていません"
# "'trivial_abi' cannot be applied to %0"
H39CEA0BB8E5A: "'trivial_abi' は%0に適用できません"
# "'trivial_abi' is disallowed on %0 because %select{its copy constructors and move constructors are all deleted|it is polymorphic|it has a base of a non-trivial class type|it has a virtual base|it has a __weak field|it has a field of a non-trivial class type}1"
HD222FF73C208: "'trivial_abi' は%0に適用できない理由: %select{コピーコンストラクタとムーブコンストラクタがすべて削除されています|ポリモーフィックである|非自明なクラス型の基底クラスを有する|仮想基底を有する|__weakフィールドを有する|非自明なクラス型のフィールドを有する}1"
# "'true' is not defined, evaluates to 0"
HEC6C8880A6A3: "'true' は定義されておらず、0として評価されます"
# "'type_tag_for_datatype' attribute requires the initializer to be an %select{integer|integral}0 constant expression"
H2191B1B324E8: "'type_tag_for_datatype' 属性は、初期化子を%select{整数|整数型}0定数式でなければならない"
# "'type_tag_for_datatype' attribute requires the initializer to be an %select{integer|integral}0 constant expression that can be represented by a 64 bit integer"
HD8F7C3D572F8: "'type_tag_for_datatype' 属性は、初期化子を%select{整数|整数型}0定数式でなければならないが、64ビット整数で表現可能なものを必要とします"
# "'typeid' of incomplete type %0"
H9D618623D4E9: "'typeid' は未完了の型%0"
# "'typeid' of variably modified type %0"
HB7FBFC93B3FA: "'typeid' は可変長修飾型%0"
# "'typename' is redundant; base classes are implicitly types"
HD8EB6D904937: "'typename' は冗長です; 基底クラスは暗黙の型です"
# "'typename' keyword used on a non-type"
HEFF0F4A3C4F6: "'typename' キーワードは非型に対して使用されました"
# "'typename' outside of a template is a C++11 extension"
H2C5188CF8D58: "'typename' テンプレートの外で使用すると、C++11の拡張機能となります"
# "'typename' outside of a template is incompatible with C++98"
H89322C630BA2: "'typename' テンプレートの外で使用すると、C++98と互換性がありません"
# "'unavailable' availability overrides all other availability information"
H321E5EA6571D: "'unavailable' の可用性情報は、他のすべての可用性情報を上書きします"
# "'using namespace' is not allowed in classes"
H133BFD711C94: "クラス内では'using namespace'を指定できません"
# "'using_if_exists' attribute cannot be applied to an inheriting constructor"
H551D8C76B087: "'using_if_exists' 属性は継承コンストラクタには適用できません"
# "'va_start' cannot be used in a captured statement"
H7AC0FC921988: "キャプチャされたステートメント内で'va_start'を使用することはできません"
# "'va_start' cannot be used outside a function"
HFCBDF5268E7D: "関数の外で'va_start'を使用することはできません"
# "'va_start' used in %select{System V|Win64}0 ABI function"
HCA2FE8C64692: "'va_start' が%select{System V|Win64}0 ABI関数内で使用されました"
# "'va_start' used in function with fixed args"
HDCEB40407EDC: "固定引数の関数内で'va_start'が使用されました"
# "'vec_step' requires built-in scalar or vector type, %0 invalid"
H2D0A081561E0: "'vec_step' は組込みスカラまたはベクタ型が必要です。%0 は無効です"
# "'virtual' can only appear on non-static member functions"
HB1449ED6BD56: "'virtual' は非静的メンバ関数にのみ指定できます"
# "'virtual' can only be specified inside the class definition"
HC2C042A27D12: "'virtual' はクラス定義内でのみ指定できます"
# "'virtual' cannot be specified on member function templates"
H345B16C9EDA3: "'virtual' はメンバ関数テンプレートには指定できません"
# "'void' as parameter must not have type qualifiers"
H3B7FE1A42F0E: "'void' パラメータとして使用する場合、型修飾子を付けることはできません"
# "'void' must be the first and only parameter if specified"
H7DDAB71DFE28: "'void' を指定する場合、最初で唯一のパラメータでなければなりません"
# "'||' of a value and its negation always evaluates to true"
H067D990351EF: "値とその否定の'||'演算は常にtrueになります"
# "'~' in destructor name should be after nested name specifier"
H85ED3FE9838A: "デストラクタ名の'~'はネストした名前修飾子の後に配置する必要があります"
# "(Deprecated) Controls whether '-Winvalid-gnu-asm-cast' defaults to an error or a warning"
HBE7A04BC29B9: "(非推奨) '-Winvalid-gnu-asm-cast' のデフォルトをエラーまたは警告に設定します"
# "(For new pass manager) 'per-pass': one report for each pass; 'per-pass-run': one report for each pass invocation"
H0C49717D08C4: "(新しいパスマネージャ用) 'per-pass': 各パスにつき1レポート; 'per-pass-run': 各パス実行につき1レポート"
# '(integrated-as) Emit an object file which can be used with an incremental linker'
HC13894BE0052: '(統合アセンブラ) インクリメンタルリンカと使用可能なオブジェクトファイルを出力します'
# '(integrated-as) Emit an object file which cannot be used with an incremental linker'
H902BD058678C: '(integrated-as) インクリメンタルリンカと使用できないオブジェクトファイルを出力します'
# '(integrated-as) Relax all machine instructions'
H523BAD847EDC: '(integrated-as) 全てのマシン命令を緩和します'
# "(skipping %0 'operator->'%s0 in backtrace)"
H3980AA6C4367: "(バックトレースで %0 'operator->'%s0 を省略)"
# '(skipping %0 call%s0 in backtrace; use -fconstexpr-backtrace-limit=0 to see all)'
HD7D8BC5DDF54: '(バックトレースで %0 呼び出し%s0 を省略; 全てを表示するには -fconstexpr-backtrace-limit=0 を使用してください)'
# '(skipping %0 context%s0 in backtrace; use -ftemplate-backtrace-limit=0 to see all)'
H1BB10F671BF7: '(バックトレースで %0 コンテキスト%s0 を省略; 全てを表示するには -ftemplate-backtrace-limit=0 を使用してください)'
# '*no default*'
H01EF8BE8DE07: '*デフォルトなし*'
# '--rtlib=libgcc requires --unwindlib=libgcc'
HED8A5F89C398: '--rtlib=libgcc を使用するには --unwindlib=libgcc を指定する必要があります'
# '-E or -x required when input is from standard input'
H5AC04D68943E: '標準入力からの入力時は -E または -x オプションが必要です'
# '-O4 is equivalent to -O3'
H0B5239D5C711: '-O4 は -O3 と同等です'
# '-Wa,--allow-experimental-crel must be specified to use -Wa,--crel. CREL is experimental and uses a non-standard section type code'
HB2A451FA1760: '-Wa,--crel を使用するには -Wa,--allow-experimental-crel を指定する必要があります。CREL は実験的で、非標準のセクションタイプコードを使用しています'
# '-dealloc is being overridden in a category'
H75DBC0C062A1: '-dealloc はカテゴリで上書きされています'
# '-dependency-file requires at least one -MT or -MQ option'
HF99E1B6F31F8: '-dependency-file には -MT または -MQ オプションを少なくとも1つ指定する必要があります'
# '-emit-llvm cannot be used when linking'
H8745DC614FEB: 'リンキング時は -emit-llvm を使用できません'
# '-fdelayed-template-parsing is deprecated after C++20'
HD52CE72E55C9: 'C++20以降では -fdelayed-template-parsing は非推奨です'
# '-fembed-bitcode is not supported on versions of iOS prior to 6.0'
HD9B9277DB1F5: 'iOS 6.0 未満のバージョンでは -fembed-bitcode はサポートされていません'
# '-fexperimental-omit-vtable-rtti call only be used with -fno-rtti'
H27AC8E91BEE0: '-fexperimental-omit-vtable-rtti は -fno-rtti と併用する必要があります'
# "-fglobal-isel support for the '%0' architecture is incomplete"
HB8576FBD6C6A: "'%0' アーキテクチャに対する -fglobal-isel のサポートは未完成です"
# '-fglobal-isel support is incomplete for this architecture at the current optimization level'
HD08F381A1C6F: '現在の最適化レベルでは、このアーキテクチャに対する -fglobal-isel のサポートは不完全です'
# '-fjmc works only for ELF; option ignored'
H862E3BB749F5: '-fjmc はELFでのみ機能します; オプションを無視します'
# '-fobjc-arc is not supported on platforms using the legacy runtime'
HE6B9338AE9F6: '旧バージョンのランタイムを使用するプラットフォームでは -fobjc-arc はサポートされていません'
# '-fobjc-arc is not supported on versions of OS X prior to 10.6'
H0AF526E18958: 'OS X 10.6以前のバージョンでは、-fobjc-arcはサポートされていません'
# '-fobjc-weak is not supported in Objective-C garbage collection'
H7AD62E69E380: '-fobjc-weakはObjective-Cのガベージコレクションではサポートされていません'
# '-fobjc-weak is not supported on the current deployment target'
H062C1F6DCD65: '-fobjc-weakは現在のデプロイメントターゲットではサポートされていません'
# '-fsanitize-address-field-padding applied to %0'
H3C21F4C44A7E: '-fsanitize-address-field-paddingが%0に適用されました'
# '-fsanitize-address-field-padding ignored for %0 because it %select{is not C++|is packed|is a union|is trivially copyable|has trivial destructor|is standard layout|is in a ignorelisted file|is ignorelisted}1'
H6C62B9F141CF: '-fsanitize-address-field-paddingは%0に対して無視されました。その理由は、%select{C++ではない|パックされている|ユニオンである|単純コピー可能である|単純破棄子を持つ|標準配置である|無効リストファイル内にある|無効リストされている}1からです'
# "-ftest-module-file-extension argument '%0' is not of the required form 'blockname:major:minor:hashed:user info'"
HA7F31D279886: "-ftest-module-file-extension引数'%0'は、必要な形式'blockname:major:minor:hashed:user info'ではありません"
# '-ftrivial-auto-var-init-stop-after=%0 has been enabled to limit the number of times ftrivial-auto-var-init=%1 gets applied.'
HA5103A32F2CB: '-ftrivial-auto-var-init-stop-after=%0が有効化され、ftrivial-auto-var-init=%1の適用回数を制限するためです。'
# '-mcmse is not supported for %0'
HBC9BABD34806: '-mcmseは%0にはサポートされていません'
# '-mharden-sls is only supported on armv7-a or later'
H370C2A9E9085: '-mharden-slsはarmv7-a以降でのみサポートされています'
# '-mtocdata option is ignored for %0 because %1'
HFF374450D777: '-mtocdataオプションは%0に対して無視されました。その理由は%1です'
# '-mxcoff-roptr is not supported with -shared'
H6DCDD2D9C271: '-mxcoff-roptrは-sharedと併用できません'
# '-mxcoff-roptr is supported only with -fdata-sections'
H64F8AE7E83F9: '-mxcoff-roptrは-fdata-sectionsと併用する場合のみサポートされています'
# '-verify prefixes must start with a letter and contain only alphanumeric characters, hyphens, and underscores'
H52220FBA1BD4: '-verifyプレフィックスはアルファベットで始まり、アルファベットまたは数字、ハイフン、アンダースコアのみを含む必要があります'
# '.dwo output filename'
HEF051A2EFA9C: '.dwo出力ファイル名'
# '// comments are not allowed in this language'
HC63D7ED8A253: '//コメントはこの言語では許可されていません'
# '/arm64EC has been overridden by specified target: %0; option ignored'
HD52B23C67DCF: '/arm64ECは指定されたターゲット%0によって上書きされました。オプションは無視されます'
# '32-bit targets are not supported when building for Mac Catalyst'
H2B5ECA150DDF: 'Mac Catalystでビルドする際、32ビットターゲットはサポートされていません'
# '90th percentile durations'
HCFF900413C06: '90パーセンタイルの所要時間'
# '99th percentile durations'
H401BE67F4D43: '99パーセンタイルの所要時間'
# ": Did you mean '"
HF9464896A916: "：おそらく意図したのは'"
# ': Not enough positional command line arguments specified!\n'
H41F31955D402: ': 指定された位置引数が不足しています！\n'
# ': See: '
HAF76FB12E339: ': 参照: '
# ': Too many positional arguments specified!\n'
H166421801500: ': 指定された位置引数が多すぎます！\n'
# ': Unknown '
H62CC89B124B8: ': 不明な '
# '<INDEX FILE>'
HA21BDF8C3F73: '<インデックス ファイル>'
# '<Line Number>'
H6986C655554D: '<行番号>'
# '<Line Number>.<Discriminator>'
H9B952BEB1010: '<行番号>.<Discriminator>'
# '<Line Number>:<Column Number>'
H3D8D3ACA02BF: '<行番号>:<列番号>'
# '<Line Number>:<Column Number>.<Discriminator> (default)'
HF63B70CCE643: '<行番号>:<列番号>.<Discriminator> (デフォルト)'
# '<PROJECT ROOT>'
H49C3DE6F4DBC: '<プロジェクト ルート>'
# '<Search Root Directory>'
H6D7091309552: '<検索ルート ディレクトリ>'
# '<Source file>'
H6EC586CC52E3: '<ソース ファイル>'
# '<Source files>'
H3C1CECBB7A05: '<ソース ファイル>'
# '<arguments to be passed to front end>...'
H60720E11CCAF: '<フロントエンドに渡す引数>...'
# '<base profile file>'
H8C88CD489F08: '<ベース プロファイル ファイル>'
# '<check-file>'
HAFAA29ACBEA3: '<チェック ファイル>'
# '<data file>'
HF37127A33D60: '<データ ファイル>'
# '<demangler-path>|<demangler-option>'
H7D9510852764: '<demanglerパス>|<demanglerオプション>'
# '<destination>'
H10F397C9B9E7: '<宛先>'
# '<diagnostic-name>'
H48ABA509B551: '<診断名>'
# '<executable>'
H194C8BA9DC59: '<実行可能ファイル>'
# '<fdata1> [<fdata2>]...'
H31B7871CCFAC: '<fdata1> [<fdata2>]...'
# '<filename...>'
HFE7069E9DD18: '<ファイル名...>'
# '<filename>'
HB80C8D77FF58: '<ファイル名>'
# '<first file>'
H701B2C95DDEA: '<最初のファイル>'
# '<from>,<to> Map coverage data paths to local source file paths'
HA29C275A5689: '<from>,<to> カバレッジ データ パスをローカル ソース ファイル パスにマッピング'
# '<gcc-tool arguments>...'
H14ED68F16708: '<gcc-tool 引数...>'
# '<globals to compare>'
HDCFEFCD16186: '<比較対象のグローバル変数>'
# '<gpu executable>'
HE3D4861759AD: '<GPU 実行可能ファイル>'
# '<high>,<low> value indicate thresholds for high and lowcoverage watermark'
HEAFB910E7206: '<high>,<low> ハイとローのカバレッジ ウォーターマークのしきい値を示す値'
# '<input .ll file>'
HBDCA7FE10EAC: '<入力 .ll ファイル>'
# '<input IR file>'
H7E82294FE4BC: '<入力 IR ファイル>'
# '<input PDB file>'
H709A48456EF7: '<入力 PDB ファイル>'
# '<input PDB files>'
H126A4B67EBAB: '<入力 PDB ファイル>'
# '<input YAML file>'
H7A7A324B78FC: '<入力 YAML ファイル>'
# '<input bitcode file>'
H0498EDBECDA2: '<入力 ビットコード ファイル>'
# '<input bitcode files>'
H18F82A53F250: '<入力 ビットコード ファイル>'
# '<input bitcode>'
HC1462E145577: '<入力 ビットコード>'
# '<input brainf>'
H925565A9DFB3: '<入力 brainf ファイル>'
# '<input file #1>'
H8FA0EC745E89: '<入力ファイル #1>'
# '<input file #2>'
H09D1580255E0: '<入力ファイル #2>'
# '<input file>'
HC2587AA6902C: '<入力ファイル>'
# '<input files>'
H9415F263685E: '<入力ファイル>'
# '<input kernel json file>'
HF85B67BC3727: '<入力カーネル JSON ファイル>'
# '<input llvm ll/bc file>'
HC39181A9A624: '<入力 LLVM ll/bc ファイル>'
# '<input llvm ll/bc files>'
H41A5FA014705: '<入力 LLVM ll/bc ファイル>'
# '<input object files or .dSYM bundles>'
HDA6B96681ECA: '<入力オブジェクト ファイルまたは .dSYM バンドル>'
# '<input object files>'
HD219B490846E: '<入力オブジェクト ファイル>'
# '<input symbols>'
H45D1386EF577: '<入力シンボル>'
# '<input toy file>'
H84A385940941: '<入力 Toy ファイル>'
# '<input>'
H89C4EB09495F: '<入力>'
# '<list of one or more header list files>'
H27C475BB767E: '<1つまたは複数のヘッダーリスト ファイルのリスト>'
# '<maxsize>'
H327F70512C50: '<maxsize>'
# '<module summary index>'
HC647DB885E7B: '<モジュール サマリ インデックス>'
# '<opt arguments>...'
HCE37C5C87525: '<opt 引数>...'
# '<output file>'
H44B468338EC5: '<出力ファイル>'
# '<path to index file | remote:server.address>'
H55C1FC4669FC: '<インデックス ファイルへのパス | remote:サーバー.アドレス>'
# '<profdata-file>'
H83762F3A8AFE: '<profdata ファイル>'
# '<program arguments>...'
H9648B06044BF: '<プログラム引数>...'
# '<program to run>'
H9127819F0F1D: '<実行するプログラム>'
# '<safe-tool arguments>...'
H5EABB33684C4: '<safe-tool引数>...'
# '<second file>'
H59A18696A728: '<2番目のファイル>'
# '<source0> [... <sourceN>]'
H4D671F64A81C: '<source0> [... <sourceN>]'
# '<source>'
HE6634DF59D09: '<source>'
# "<start line>:<end line> - format a range of\nlines (both 1-based).\nMultiple ranges can be formatted by specifying\nseveral -lines arguments.\nCan't be used with -offset and -length.\nCan only be used with one input file."
HDEA3B9BD2A49: '<開始行>:<終了行> - 行の範囲を指定（両方1ベース）。\n複数の範囲を指定するには複数の-lines引数を指定してください。\n-offsetと-lengthと同時に使用できません。\n入力ファイルは1つのみ使用可能です。'
# '<symbol-file>'
H6E5CDBA6FB29: '<シンボルファイル>'
# '<test profile file>'
H11468CAF4D7F: '<テストプロファイルファイル>'
# '<tool arguments>...'
HF6F458922E63: '<ツール引数>...'
# '<topdown|bottomup>'
H9180E4B0E8C6: '<topdown|bottomup>'
# '<weight>,<filename>'
HCEE927C66E78: '<ウェイト>,<ファイル名>'
# '<xray fdr mode log>'
H4907FD73C66B: '<xray fdrモードログ>'
# '<xray log file 1>'
HB4D281AAED36: '<xrayログファイル1>'
# '<xray log file 2>'
H1C142C095FCF: '<xrayログファイル2>'
# '<xray log file>'
HE9A7E93A5C35: '<xrayログファイル>'
# '<xray trace>'
HA7901FE618F5: '<xrayトレース>'
# '= *cannot print option value*\n'
HE274379BF9C1: '= *オプション値を表示できません*\n'
# '= *unknown option value*\n'
H164C5812BA3B: '= *不明なオプション値*\n'
# '?: operator with omitted middle operand cannot be mangled'
H3E44EE9DABB8: '?: 演算子の中央のオペランドが省略されているため、マングリングできません'
# '@%0 must be followed by a number to form an NSNumber object'
HDF1E414372F2: '@%0の後に数値を指定してNSNumberオブジェクトを形成する必要があります'
# "@catch parameter cannot have storage specifier '%0'"
HAEB289D52AD8: "@catchパラメータにはストレージ指定子'%0'を指定できません"
# '@catch parameter declarator cannot be qualified'
H9BAC8F95B81C: '@catch パラメータ宣言子には修飾子を付けることはできません'
# '@catch parameter is not a pointer to an interface type'
HE87FCFF30D0A: '@catch パラメータはインターフェース型へのポインタでありません'
# '@defs is not supported in Objective-C++'
H64B526C3172C: 'Objective-C++で@defsはサポートされていません'
# '@implementation cannot have type parameters'
HA936A031AC88: '@implementationには型パラメータを指定できません'
# '@implementation declaration cannot be protocol qualified'
H4CA986D1E0F8: '@implementation宣言はプロトコル修飾を指定できません'
# "@import of module '%0' in implementation of '%1'; use #import"
H16AC87FD7968: "'%1'の実装内でモジュール'%0'を@importすることはできません；#importを使用してください"
# '@protocol is using a forward protocol declaration of %0'
H0D6847EE9BAD: '@protocolで%0の前方プロトコル宣言を使用しています'
# '@selector expression formed with direct selector %0'
HB5C475EA47ED: '@selector式は直接選択子%0で作成されています'
# '@selector expression formed with potentially direct selector %0'
H7FC0DE89B5F4: '@selector式は潜在的に直接選択子%0で作成されています'
# '@synchronized requires an Objective-C object type (%0 invalid)'
H4E94A0FBFD2A: '@synchronizedはObjective-Cオブジェクト型を必要とします（%0は無効です）'
# "@synthesize not allowed in a category's implementation"
HAD49CB90931E: 'カテゴリの実装内で@synthesizeは使用できません'
# '@synthesize not allowed on a class property %0'
H37538A67AC33: 'クラスプロパティ%0に対して@synthesizeは使用できません'
# '@throw (rethrow) used outside of a @catch block'
HAB2C03614B94: '@catchブロック外で@throw (rethrow)を使用しています'
# '@throw requires an Objective-C object type (%0 invalid)'
HF85FCC60471E: '@throwはObjective-Cオブジェクト型を必要とします（%0は無効です）'
# '@try statement without a @catch and @finally clause'
H0097E9BE678E: '@catchおよび@finally句を省略した@try文です'
# 'A CSV file containing (JITDylib, Function) pairs tospeculatively look up'
H27E7912AA129: '(JITDylib、Function)ペアを含むCSVファイルで、推測的に検索します'
# 'A No-Op Barrier Pass'
H189EA9AAB8E2: '何もしない障壁パス（No-Op Barrier Pass）'
# 'A boolean option to show CFG dag or text with block profile counts and branch probabilities right after PGO profile annotation step. The profile counts are computed using branch probabilities from the runtime profile data and block frequency propagation algorithm. To view the raw counts from the profile, use option -pgo-view-raw-counts instead. To limit graph display to only one function, use filtering option -view-bfi-func-name.'
H1F6AD91CDAD1: 'PGOプロファイルアノテーションのステップ直後にCFGダグまたはテキストを表示するためのブールオプション。プロファイルカウントは、ランタイムプロファイルデータの分岐確率とブロック頻度伝播アルゴリズムを使用して計算されます。プロファイルからの生カウントを表示するには、オプション-pgo-view-raw-countsを使用してください。特定の関数のみを表示するには、フィルタリングオプション-view-bfi-func-nameを使用してください。'
# 'A boolean option to show CFG dag or text with raw profile counts from profile data. See also option -pgo-view-counts. To limit graph display to only one function, use filtering option -view-bfi-func-name.'
H84462D2AF2CA: 'プロファイルデータの生カウントを表示するためのブールオプション。オプション-pgo-view-countsも参照してください。特定の関数のみを表示するには、フィルタリングオプション-view-bfi-func-nameを使用してください。'
# 'A comma-separated list of regexes to match against suffix of a header, and disable analysis if matched.'
HC652CCDF0460: 'ヘッダの接尾辞と一致する正規表現のコンマ区切りリスト。一致した場合、解析を無効にします。'
# 'A comma-separated list of regexes to match against suffix of a header. Only headers that match will be analyzed.'
H98978B75D13A: 'ヘッダの接尾辞に一致するための正規表現のカンマ区切りリスト。一致するヘッダのみが解析されます。'
# 'A count is cold if it is below the minimum count to reach this percentile of total counts.'
H2339A8FDD5A8: 'このパーセンタイルの総カウントに到達するために必要な最小カウントを下回っている場合、そのカウントは「cold」と判定されます。'
# 'A count is hot if it exceeds the minimum count to reach this percentile of total counts.'
H7D01FE9FC1EB: 'このパーセンタイルの総カウントに到達するために必要な最小カウントを超える場合、そのカウントは「hot」と判定されます。'
# 'A debug option to add additional penalty to the computed one.'
H2D6A17BDE0D3: '計算された値に追加のペナルティを付加するデバッグオプション。'
# 'A file containing a list of files to process, one per line.'
H3723DB39ACD6: '処理対象のファイルの一覧を1行ずつ記述したファイル。'
# 'A file containing list of basic blocks to extract'
HBF68C649BA33: '抽出する基本ブロックの一覧を含むファイル。'
# 'A file containing list of symbol names to preserve'
HCBA362E0A436: '保持するシンボル名の一覧を含むファイル。'
# 'A file containing regexes of symbol names that are not expected to be updated when changing namespaces around them.'
HE689FDC11988: '周囲のネームスペースを変更しても更新されないシンボル名の正規表現を含むファイル。'
# 'A file in which to write minimized bitcode for the thin link only'
HC50A535724B5: 'Thin Link用に最小化されたビットコードを書き込むためのファイル。'
# 'A fixed cold count that overrides the count derived from profile-summary-cutoff-cold'
H6BD0A927E583: 'profile-summary-cutoff-coldから導出されたカウントを上書きする固定coldカウント。'
# 'A fixed hot count that overrides the count derived from profile-summary-cutoff-hot'
HDDA22CC4FF28: 'profile-summary-cutoff-hotから導出されたカウントを上書きする固定hotカウント。'
# "A flag that overrides the target's expected cost for an instruction to a single constant value. Mostly useful for getting consistent testing."
HB9C94533EB20: 'ターゲットの命令の予想コストを単一の定数値に上書きするフラグ。主に一貫したテストのために有用です。'
# "A flag that overrides the target's max interleave factor for scalar loops."
H8C8153E64ADB: 'スカラーループの最大インターリーブ係数を上書きするフラグ。'
# "A flag that overrides the target's max interleave factor for vectorized loops."
H3505D260BD96: 'ベクタライズされたループの最大インターリーブ係数を上書きするフラグ。'
# "A flag that overrides the target's number of scalar registers."
HFF8F958A02D3: 'ターゲットのスカラーレジスタ数を上書きするフラグ。'
# "A flag that overrides the target's number of vector registers."
HEC99B1D21B33: 'ターゲットのベクタレジスタ数を上書きするフラグ。'
# "A flag that overrides the target's preferred addressing mode."
H7B1AA7CE93D4: 'ターゲットの好ましいアドレッシングモードを上書きするフラグ。'
# 'A function is considered hot for staleness error check if its total sample count is above the specified percentile'
H652DA545BF0D: '全サンプルカウントが指定されたパーセンタイルを超える場合、その関数はstalenessエラーチェックにおいてhotと見なされます。'
# 'A function name, assumed to be global, which will be treated as the root of an interesting graph, which will be profiled independently from other similar graphs.'
H3FD0C1E415AD: 'グローバルであると想定される関数名。これには興味深いグラフのルートとして扱われ、他の類似したグラフとは独立してプロファイリングされます。'
# 'A huge scheduling region will have maps reduced by this many nodes at a time. Defaults to HugeRegion / 2.'
HAEEA6B54FAD5: '巨大スケジューリング領域のマップは、この数のノードずつ削減されます。デフォルトはHugeRegion / 2です。'
# 'A lexical block (Function, Class, etc.).'
HC41EB530ACBA: '語彙的ブロック（Function、Classなど）。'
# "A list of mangled vtable type info names. Classes specified by the type info names and their derived ones will not be vtable-ICP'ed. Useful when the profiled types and actual types in the optimized binary could be different due to profiling limitations. Type info names are those string literals used in LLVM type metadata"
HB3A60F3783C6: 'マングルされたvtable型情報名のリスト。指定された型情報名を持つクラスとその派生クラスはvtable-ICP化されません。プロファイル収集対象の型と最適化対象バイナリの実際の型がプロファイリング制約により異なる場合に便利です。型情報名はLLVMの型メタデータで使用される文字列リテラルです'
# 'A list of symbol names to preserve'
HC033F70F7A4D: '保持するシンボル名のリスト'
# "A multiplier on top of cycle savings to decide whether the savings won't justify the cost"
H6A89F885E7F6: 'サイクル節約量に基づく乗数。これにより、節約分がコストに見合っていないかどうかを判断します'
# "A string that'll be prepended to all log statements. Useful when running multiple instances on same host."
HE0B8D8E429AE: 'すべてのログ記述の先頭に付加される文字列。同じホスト上で複数のインスタンスを実行する場合に便利です。'
# 'A textual description of the alias analysis pipeline for handling managed aliasing queries'
H4D54EF8DEC89: 'マネージドのエイリアス照会を処理するためのエイリアス分析パイプラインのテキスト形式の記述'
# 'A textual description of the cgscc pass pipeline inserted at the CGSCCOptimizerLate extension point into default pipelines'
HFA3CF56CCD45: 'CGSCCOptimizerLate拡張ポイントにデフォルトパイプラインに挿入するcgsccパスパイプラインのテキスト形式の記述'
# 'A textual description of the function pass pipeline inserted at the Peephole extension points into default pipelines'
H1744F3F7F9B4: 'Peephole拡張ポイントにデフォルトパイプラインに挿入する関数パスパイプラインのテキスト形式の記述'
# 'A textual description of the function pass pipeline inserted at the ScalarOptimizerLate extension point into default pipelines'
HA2E18C3D97E7: 'ScalarOptimizerLate拡張ポイントにデフォルトパイプラインに挿入する関数パスパイプラインのテキスト形式の記述'
# 'A textual description of the function pass pipeline inserted at the VectorizerEnd extension point into default pipelines'
HD2BE547AE303: 'VectorizerEnd拡張ポイントにデフォルトパイプラインに挿入するループパスパイプラインのテキスト形式の記述'
# 'A textual description of the function pass pipeline inserted at the VectorizerStart extension point into default pipelines'
HA843C3B1B6F5: 'VectorizerStart拡張ポイントにデフォルトパイプラインに挿入する関数パスパイプラインのテキスト形式の記述'
# 'A textual description of the loop pass pipeline inserted at the LateLoopOptimizations extension point into default pipelines'
H081E56CD31AA: 'LateLoopOptimizations拡張ポイントにデフォルトパイプラインに挿入するループパスパイプラインのテキスト形式の記述'
# 'A textual description of the loop pass pipeline inserted at the LoopOptimizerEnd extension point into default pipelines'
HFDB774C5E68A: 'LoopOptimizerEnd拡張ポイントにデフォルトパイプラインに挿入するループパスパイプラインのテキスト形式の記述'
# 'A textual description of the module pass pipeline inserted at the EarlySimplification extension point into default pipelines'
HADF08723EA0B: 'EarlySimplification拡張ポイントにデフォルトパイプラインに挿入するモジュールパスパイプラインのテキスト形式の記述'
# 'A textual description of the module pass pipeline inserted at the FullLinkTimeOptimizationEarly extension point into default pipelines'
HBAAC4BEB26E7: 'FullLinkTimeOptimizationEarly拡張ポイントにデフォルトパイプラインに挿入するモジュールパスパイプラインのテキスト形式の記述'
# 'A textual description of the module pass pipeline inserted at the FullLinkTimeOptimizationLast extension point into default pipelines'
HC7A2BAD76212: 'FullLinkTimeOptimizationLast拡張ポイントにデフォルトパイプラインに挿入するモジュールパスパイプラインのテキスト形式の記述'
# 'A textual description of the module pass pipeline inserted at the OptimizerEarly extension point into default pipelines'
H556744FF114A: 'OptimizerEarly拡張ポイントにデフォルトパイプラインに挿入するモジュールパスパイプラインのテキスト形式の記述'
# 'A textual description of the module pass pipeline inserted at the OptimizerLast extension point into default pipelines'
H97AB14D6A40C: 'OptimizerLast拡張ポイントにデフォルトパイプラインに挿入するモジュールパスパイプラインのテキスト形式の記述'
# 'A textual description of the module pass pipeline inserted at the PipelineStart extension point into default pipelines'
H5D27DE009EB3: 'PipelineStart拡張ポイントにデフォルトパイプラインに挿入するモジュールパスパイプラインのテキスト形式の記述'
# 'A textual description of the pass pipeline for testing'
H07C815591653: 'テスト用のパスパイプラインのテキスト形式の記述'
# "A textual description of the pass pipeline, same as what's passed to `opt -passes`."
HAD654D568007: 'パスパイプラインのテキスト形式の説明、`opt -passes` に渡されるものと同じです。'
# 'A textual description of the pass pipeline. To have analysis passes available before a certain pass, add "require<foo-analysis>".'
H799364B80DF3: "特定のパスの前に分析パスを有効にするには、'require<foo-analysis>' を追加してください。"
# "A textual description of the pass pipeline. To have analysis passes available before a certain pass, add 'require<foo-analysis>'."
HB92573A0FB9B: "特定のパスの前に分析パスを有効にするには、'require<foo-analysis>' を追加してください。'-passes' は '--opt-level=O?' (O2がデフォルト) を指定した場合の clang-linker-wrapper のパスパイプラインを上書きします（すべての効果を上書きするわけではありません）。'-passes' に適切な 'default<O?>' を含める必要があります。"
# "A textual description of the pass pipeline. To have analysis passes available before a certain pass, add 'require<foo-analysis>'. '-passes' overrides the pass pipeline (but not all effects) from specifying '--opt-level=O?' (O2 is the default) to clang-linker-wrapper.  Be sure to include the corresponding 'default<O?>' in '-passes'."
H4608F37A5D56: "特定のパスの前に分析パスを有効にするには、'require<foo-analysis>' を追加してください。'-passes' は '--opt-level=O?' (O2がデフォルト) を指定した場合の clang-linker-wrapper のパスパイプラインを上書きします（すべての効果を上書きするわけではありません）。'-passes' に適切な 'default<O?>' を含める必要があります。"
# 'A threshold controls whether an indirect call will be specialized'
HE03B79F00E10: '間接呼び出しの特殊化を制御する閾値です'
# 'A threshold of live range size which may cause high compile time cost in global splitting.'
H1C364B861BCF: 'グローバル分割で高コンパイルコストが発生する可能性がある有効範囲のサイズの閾値です。'
# 'A throughput of the processor floating-point arithmetic units expressed in the number of vector fused multiply-add instructions per clock cycle.'
H419471CCE4DF: 'ベクターフューズド乗算加算命令の数/クロックサイクルで表されるプロセッサの浮動小数点演算ユニットのスループットです。'
# 'A tile size for each loop dimension, filled with --polly-default-tile-size'
H104573A3D1B6: '--polly-default-tile-size で埋められた各ループ次元のタイルサイズです。'
# 'A tile size for each loop dimension, filled with --polly-register-tile-size'
H8DEB87E7711B: '--polly-register-tile-size で埋められた各ループ次元のタイルサイズです。'
# 'A tool to bundle several input files of the specified type <type> \nreferring to the same source file but different targets into a single \none. The resulting file can also be unbundled into different files by \nthis tool if -unbundle is provided.\n'
HD409DEDBF7C5: '同じソースファイルを指すが異なるターゲット向けの複数の入力ファイルを、一つにバンドルするツールです。\nこのツールに -unbundle を指定することで、バンドルされたファイルを再び個別のファイルに分解することもできます。\n'
# 'A tool to detect the presence of AMDGPU devices on the system. \n\nThe tool will output each detected GPU architecture separated by a\nnewline character. If multiple GPUs of the same architecture are found\na string will be printed for each\n'
H8EA7CFE7591E: 'システムに存在する AMDGPU デバイスを検出するツールです。\n\n検出された各 GPU アーキテクチャは改行文字で区切られ出力されます。同じアーキテクチャの複数の GPU が見つかった場合、それぞれの文字列が表示されます。\n'
# 'A tool to detect the presence of NVIDIA devices on the system. \n\nThe tool will output each detected GPU architecture separated by a\nnewline character. If multiple GPUs of the same architecture are found\na string will be printed for each\n'
H813C62D59D1D: 'システムに存在する NVIDIA デバイスを検出するツールです。\n\n検出された各 GPU アーキテクチャは改行文字で区切られ出力されます。同じアーキテクチャの複数の GPU が見つかった場合、それぞれの文字列が表示されます。\n'
# 'A tool to format C/C++/Java/JavaScript/JSON/Objective-C/Protobuf/C# code.\n\nIf no arguments are specified, it formats the code from standard input\nand writes the result to the standard output.\nIf <file>s are given, it reformats the files. If -i is specified\ntogether with <file>s, the files are edited in-place. Otherwise, the\nresult is written to the standard output.\n'
HBD33E3D62435: 'C/C++/Java/JavaScript/JSON/Objective-C/Protobuf/C# のコードを整形するツールです。\n\n引数が指定されていない場合、標準入力からコードを整形し標準出力に結果を出力します。\n<file> を指定するとファイルを整形します。-i を一緒に指定するとファイルを直接上書きします。そうでない場合は標準出力に結果を出力します。\n'
# 'A tool to generate an optimization report from YAML optimization record files.\n'
HACA86A981224: 'YAML 最適化記録ファイルから最適化レポートを生成するツールです。\n'
# 'A utility for bundling several object files into a single binary.\nThe output binary can then be embedded into the host section table\nto create a fatbinary containing offloading code.\n'
H87DB5533D231: '複数のオブジェクトファイルを単一のバイナリにバンドルするユーティリティです。\n出力バイナリはホストセクションテーブルに埋め込まれ、オフロードコードを含むファットバイナリを作成できます。\n'
# 'A utility used to launch unit tests built for a GPU target. This is\nintended to provide an intrface simular to cross-compiling emulators\n'
H43DC1BE6F67F: 'GPU ターゲット用にビルドされたユニittest を実行するために使用されるユーティリティです。\nクロスコンパイルエミュレータと同様のインターフェースを提供することを目的としています\n'
# 'AArch64 A57 FP Load-Balancing'
H89C796F20C61: 'AArch64 A57 FP ロードバランス'
# 'AArch64 Branch Targets'
H9304B7C9D5D8: 'AArch64 ブランチターゲット'
# 'AArch64 CCMP Pass'
HD86F88A4A107: 'AArch64 CCMP パス'
# 'AArch64 CondOpt Pass'
H57677EA713E0: 'AArch64 CondOpt パス'
# 'AArch64 Conditional Branch Tuning'
H22AFD058BC38: 'AArch64条件分岐チューニング'
# 'AArch64 Dead register definitions'
HDD34EEF0A0FD: 'AArch64死活レジスタ定義'
# 'AArch64 Instruction Selection'
H5E1BF7DD5E18: 'AArch64命令選択'
# 'AArch64 Local Dynamic TLS Access Clean-up'
H60D83F556D1C: 'AArch64ローカルダイナミックTLSアクセスのクリーンアップ'
# 'AArch64 MI Peephole Optimization'
H5CB8022D53B1: 'AArch64 MI ピーヒール最適化'
# 'AArch64 Pointer Authentication'
H3B42C021D00A: 'AArch64ポインタ認証'
# 'AArch64 Post Coalescer Pass'
H06C95CD832E0: 'AArch64ポストコーカーサーパス'
# 'AArch64 Promote Constant Pass'
H70B4D04F132C: 'AArch64定数昇格パス'
# 'AArch64 SIMD instructions optimization pass'
H407FCE4191EB: 'AArch64 SIMD命令最適化パス'
# 'AArch64 Stack Tagging'
HE4582C5513D0: 'AArch64スタックタグ付け'
# 'AArch64 Stack Tagging PreRA Pass'
H576B6E1D60C6: 'AArch64スタックタグ付けPreRAパス'
# 'AArch64 Store Pair Suppression'
HD68B4FD8992D: 'AArch64ストアペア抑制'
# 'AArch64 compress jump tables pass'
HB1CD15516755: 'AArch64ジャンプテーブル圧縮パス'
# 'AArch64 fix for A53 erratum 835769'
HBBD9D2E5295C: 'AArch64 A53 Erratum 835769修正'
# 'AArch64 homogeneous prolog/epilog lowering pass'
H2B5E843A360C: 'AArch64均質プロローグ/エピローグ低減パス'
# 'AArch64 load / store optimization pass'
HC1E1B5661C2B: 'AArch64ロード/ストア最適化パス'
# 'AArch64 pseudo instruction expansion pass'
H39C8B02C1D58: 'AArch64擬似命令展開パス'
# 'AArch64 redundant copy elimination pass'
HAEB13D1AFB9C: 'AArch64冗長コピー除去パス'
# 'AArch64 sls hardening pass'
H988D224CDB63: 'AArch64 SLSハードニングパス'
# 'AArch64 speculation hardening pass'
H7D2AB26196EE: 'AArch64推測実行ハードニングパス'
# 'AArch64Arm64ECCallLowering'
H73581D76FB10: 'AArch64 Arm64 ECコールの低次変換'
# "ABI '%0' is not supported for '%1'"
H7FF392C86EBF: "ABI '%0' は '%1' に対してサポートされていません"
# "ABI '%0' is not supported on CPU '%1'"
H1189F24D3D62: "ABI '%0' は CPU '%1' ではサポートされていません"
# 'AMD vector math library'
HA177FC4B0F5A: 'AMD ベクターマスライブラリ'
# 'AMDGPU Address space based Alias Analysis'
HEE464CD5CFF9: 'AMDGPU アドレス空間ベースのエイリアス分析'
# 'AMDGPU Address space based Alias Analysis Wrapper'
HA70F43663430: 'AMDGPU アドレス空間ベースのエイリアス分析ラッパー'
# 'AMDGPU Attributor'
HB96C03301054: 'AMDGPU アトリビューター'
# 'AMDGPU CFG Structurizer'
HFAE00DA66175: 'AMDGPU CFG構造化'
# 'AMDGPU DAG->DAG Pattern Instruction Selection'
H1C6011A1E507: 'AMDGPU DAG→DAGパターン命令選択'
# 'AMDGPU GlobalISel divergence lowering'
H60A2AE965388: 'AMDGPU GlobalISel 分岐の低次変換'
# 'AMDGPU IR late optimizations'
H2A662801978F: 'AMDGPU IR 後期最適化'
# 'AMDGPU IR optimizations'
H6CEDA43B5424: 'AMDGPU IR 最適化'
# 'AMDGPU Image Intrinsic Optimizer'
H28FFA260019F: 'AMDGPU イメージ組み込み最適化'
# 'AMDGPU Inline All Functions'
HFBEEFEAD43D4: 'AMDGPU 全関数インライン化'
# 'AMDGPU Insert Delay ALU'
HD712301B82FE: 'AMDGPU ディレイ ALU挿入'
# 'AMDGPU Insert waits for SGPR read hazards'
H3CE801DC5FBE: 'AMDGPU SGPR読み取りハザード用待機挿入'
# 'AMDGPU Kernel Attributes'
H5B736779332B: 'AMDGPU カーネル属性'
# 'AMDGPU Lower Kernel Arguments'
H345C5C7C45FB: 'AMDGPU カーネル引数の低次変換'
# 'AMDGPU Mark last scratch load'
H570A9C93F411: 'AMDGPU 最終スクラッチロードのマーク'
# 'AMDGPU Pre-RA Long Branch Reg'
HF352DB9ED395: 'AMDGPU Pre-RAロングブランチレジスタ'
# 'AMDGPU Pre-RA optimizations'
HB1D166D82990: 'AMDGPU Pre-RA 最適化'
# 'AMDGPU Preload Kernel Arguments Prolog'
HA4C7048C1EF3: 'AMDGPU カーネル引数のプリロード プロローグ'
# 'AMDGPU Printf lowering'
H9F0BCA780CE7: 'AMDGPU printf の下位変換'
# 'AMDGPU Promote Kernel Arguments'
HAD6BF4A8858C: 'AMDGPU カーネル引数のプロモーション'
# 'AMDGPU Register Bank Legalize'
HD913B83CEA2C: 'AMDGPU レジスタバンクの合法化'
# 'AMDGPU Register Bank Select'
H910A7C3E575C: 'AMDGPU レジスタバンク選択'
# 'AMDGPU Remove Incompatible Functions'
H697AE5C583A4: 'AMDGPU 非互換関数の削除'
# 'AMDGPU Reserve WWM Registers'
H9CD9A7466F8D: 'AMDGPU WWM レジスタの予約'
# 'AMDGPU Rewrite Out Arguments'
H1EE5CA590389: 'AMDGPU アウト引数の書き換え'
# 'AMDGPU Software lowering of LDS'
H06C3E98E4BA5: 'AMDGPU LDS のソフトウェア最適化'
# 'AMDGPU atomic optimizations'
HD4C4B30A81C8: 'AMDGPU 原子的最適化'
# 'AMDGPU promote alloca to vector'
H76A58E341CF5: 'AMDGPU alloca をベクタにプロモーション'
# 'AMDGPU promote alloca to vector or LDS'
H505D453A0AB0: 'AMDGPU alloca をベクタまたは LDS にプロモーション'
# 'ANALYSIS'
HB0D5F3D274BF: '分析'
# 'ANALYSIS_ALIASING'
H652422606A7D: 'エイリアシング分析'
# 'ANALYSIS_FP_COMMUTE'
H5B6E5D0BD096: 'FP コミュート分析'
# 'API notes replacement type %0 has a different size from original type %1'
HB87A25B6CDE7: 'API ノートの置換タイプ %0 は元のタイプ %1 のサイズと異なります'
# 'ARC %select{unused|__unsafe_unretained|__strong|__weak|__autoreleasing}0 lifetime qualifier on return type is ignored'
H4E4E8ED8984D: 'ARC 戻り値の型における %select{未使用|__unsafe_unretained|__strong|__weak|__autoreleasing}0 の lifetime 質問は無視されます'
# 'ARC DAG->DAG Pattern Instruction Selection'
H40C54AF1B605: 'ARC DAG→DAG パターンの命令選択'
# 'ARC finalize branches'
H275EE97FB8AE: 'ARC 分岐の最終化'
# 'ARC forbids %select{implementation|synthesis}0 of %1'
HC91D535AD424: 'ARCは%select{実装|合成}0の%1を禁止しています'
# 'ARC forbids explicit message send of %0'
H35558B925DCC: 'ARCは%0の明示的なメッセージ送信を禁止しています'
# 'ARC forbids flexible array members with retainable object type'
HBA6CEB1E81A4: 'ARCは保持可能なオブジェクト型の柔軟な配列メンバーを禁止しています'
# 'ARC forbids synthesizing a property of an Objective-C object with unspecified ownership or storage attribute'
H8E9C79FD3192: 'Objective-Cオブジェクトの未指定の所有権またはストレージ属性を持つプロパティの合成はARCで禁止されています'
# 'ARC forbids use of %0 in a @selector'
H9E100CA24C33: '%0の使用は@selector内でARCで禁止されています'
# 'ARM Branch Targets'
H320FDCF5D874: 'ARM ブランチ・ターゲット'
# 'ARM EHABI exceptions'
HF924BFE7B7BB: 'ARM EHABI例外'
# 'ARM Execution Domain Fix'
H8BB9925360D9: 'ARM 実行ドメイン修正'
# 'ARM Instruction Selection'
HD4C5D9A9956F: 'ARM インストラクション選択'
# 'ARM Low Overhead Loops pass'
HF8B8270CD0E0: 'ARM 低オーバーヘッドループ パス'
# 'ARM MVE TailPred and VPT Optimisations pass'
HE6A4A21F0251: 'ARM MVE TailPredおよびVPT 最適化 パス'
# 'ARM MVE VPT block pass'
HE579D00C5557: 'ARM MVE VPT ブロック パス'
# 'ARM block placement'
HE7AFE256FA69: 'ARM ブロック配置'
# 'ARM constant island placement and branch shortening pass'
H12503A372FDC: 'ARM コンスタント・アイランド配置と分岐短縮 パス'
# 'ARM fix for Cortex-A57 AES Erratum 1742098'
HFB722C2D2741: 'ARM Cortex-A57 AES エラタ1742098 対策 パス'
# 'ARM load / store optimization pass'
HFAD45B23E308: 'ARM ロード/ストア最適化 パス'
# 'ARM pre- register allocation load / store optimization pass'
HAF68B491BF25: 'ARM レジスタ割り当て前 ロード/ストア最適化 パス'
# 'ARM pseudo instruction expansion pass'
H77670EF47A4C: 'ARM プセウド命令展開 パス'
# 'ARM sls hardening pass'
H7DDE5DF1D5E8: 'ARM sls ハードニング パス'
# 'AST and IR generation'
H9BC428E8F3F3: 'ASTおよびIR生成'
# "AST file '%0' was compiled for the %1 '%2' but the current translation unit is being compiled for target '%3'"
HCADF9CC20080: "ASTファイル'%0'は'%2'の%1用にコンパイルされましたが、現在の翻訳ユニットはターゲット'%3'でコンパイルされています"
# "AST file '%0' was not built as a module"
HF2D0BB327E40: "ASTファイル'%0'はモジュールとしてビルドされていません"
# "AST file '%2' was compiled with module cache path '%0', but the path is currently '%1'"
H5B70E03C1FF3: "ASTファイル'%2'は'%0'のモジュールキャッシュパスでコンパイルされましたが、現在のパスは'%1'です"
# 'AVR DAG->DAG Instruction Selection'
H8D3BB39761E3: 'AVR DAG→DAG命令選択'
# 'AVR Shift Expansion'
HB0A514A46417: 'AVRシフト展開'
# 'AVR pseudo instruction expansion pass'
H957B71DEFB30: 'AVR仮指令展開パス'
# "AVX vector %select{return|argument}0 of type %1 without '%2' enabled changes the ABI"
HA1797A0B7AA1: "AVXベクトル%select{返却値|引数}0が型%1で'%2'が有効でない場合、ABIが変更されます"
# 'Abbreviation for -input-style=delimited -pretty -log=verbose. Intended to simplify lit tests'
H80629E8FC6D8: '-input-style=delimited -pretty -log=verboseを一括設定。litテストの簡素化を目的'
# 'Abort if an isl error is encountered'
HA9BB62CCA982: 'ISLエラーが発生した場合に終了'
# 'Abort if any reduction results in invalid IR'
HE190E2B8E3A2: '無効なIRが生成された減算結果がある場合に終了'
# 'Abort when the max iterations for devirtualization CGSCC repeat pass is reached'
H625080B5E512: 'デバーチャル化CGSCC反復パスの最大繰り返し回数に達した場合に終了'
# 'Absolute error tolerated'
H0DDBDDDD2804: '絶対誤差許容範囲'
# 'Abstract subprograms'
HE11B4671C4D0: '抽象サブプログラム'
# 'Accelerate framework'
HC4987E7BA17F: 'Accelerateフレームワーク'
# 'Accept a PCH file that was created with a different modules cache path'
H30FC52342749: '異なるモジュールキャッシュパスで作成されたPCHファイルを許可'
# 'Accept a PCH file that was created with compiler errors'
H3D9D9492A95B: 'コンパイルエラーを含むPCHファイルを許可'
# 'Accept a PCM file that was created with compiler errors'
H491D98E75DB9: 'コンパイルエラーを含むPCMファイルを許可'
# 'Accept in ARM, reject in Thumb'
H947CDAFC2217: 'ARMでは受け入れ、Thumbでは拒否'
# 'Accept in both ISAs, emit implicit ITs in Thumb'
H1A576FCAF9D9: '両方のISAで受け入れ、Thumbでは暗黙のITを発行'
# 'Accept non-standard constructs supported by the Borland compiler'
HA22BD3681EC1: 'Borlandコンパイラがサポートする非標準構文を許可'
# 'Accept some non-standard constructs supported by the Microsoft compiler'
HECEF41C80814: 'Microsoftコンパイラーでサポートされる非標準の構文を許可する'
# 'Accept some non-standard constructs supported by the z/OS compiler'
H043675240BDC: 'z/OSコンパイラーでサポートされる非標準の構文を許可する'
# 'Access dynamic shadow through an ifunc global on platforms that support this'
HB6225A3E2790: 'サポートされているプラットフォームで、ifuncグローバルを通じてダイナミックシャドウにアクセスする'
# 'Act like old LiveDebugValues did'
HFD5F11157A46: '古いLiveDebugValuesと同じように動作する'
# 'Action to perform on deprecated def'
H5D2AEBD499B4: '非推奨の定義に対する処理方法'
# 'Action to perform:'
H0985CD6D5E8B: '実行するアクション：'
# 'Add !range metadata to NVVM intrinsics.'
H210E13100D6D: 'NVVM intrinsicsに!rangeメタデータを追加する。'
# 'Add -rpath with architecture-specific resource directory to the linker flags. When --hip-link is specified, also add -rpath with HIP runtime library directory to the linker flags'
H0E7215A9DCD3: '-rpathとアーキテクチャ固有のリソースディレクトリをリンカーフラグに追加します。--hip-linkが指定された場合、HIPランタイムライブラリディレクトリを含む-rpathもリンカーフラグに追加します'
# 'Add .note.gnu.property with BTI to assembly files'
HD58C1F70322E: '.note.gnu.property with BTIをアセンブリファイルに追加する'
# 'Add .note.gnu.property with BTI to assembly files (AArch64 only)'
H497BB320D249: '.note.gnu.property with BTIをアセンブリファイルに追加する（AArch64のみ）'
# 'Add <dir> to system include search path, as if in %INCLUDE%'
H8CB70533A0CD: 'システムのインクルード検索パスに<dir>を追加します。%INCLUDE%にある場合と同じように'
# 'Add AMDGPU function attributes'
H4A9EBA76009C: 'AMDGPU関数属性を追加する'
# 'Add AMDGPU uniform metadata'
HE950C74F7CBF: 'AMDGPU uniformメタデータを追加する'
# 'Add C++ implicit destructors to CFGs for all analyses'
H7BE6C1575B4A: 'すべての分析用のCFGにC++の暗黙のデストラクタを追加する'
# 'Add Contextual/Debug comments to all C++ predicates'
H23C6808D6E2D: 'すべてのC++の述語にコンテクスト/デバッグコメントを追加する'
# 'Add DW_AT_linkage_name to function declaration DIEs referenced by DW_AT_call_origin attributes. Enabled by default for -gsce debugger tuning.'
H71407E50301C: 'DW_AT_call_origin属性で参照される関数宣言DIEにDW_AT_linkage_nameを追加します。-gsceデバッガータイニングではデフォルトで有効です。'
# 'Add MIR Flow Sensitive Discriminators'
H2C6CDC724E3F: 'MIRフロー依存判別子を追加する'
# 'Add OpenCL builtin function declarations (experimental)'
HC7FA758DA63E: 'OpenCLビルトイン関数宣言を追加します（実験的）'
# 'Add TBAA tags to direct variables'
HAAED7844B106: '直接変数にTBAAタグを追加する'
# 'Add TBAA tags to dummy arguments'
H3C7A729C0FA0: 'ダミーアルゴリズムにTBAAタグを追加する'
# 'Add TBAA tags to global variables'
HE3F5E682DA95: 'グローバル変数にTBAAタグを追加します'
# 'Add TBAA tags to local allocations. UNSAFE.'
H91FE178A4638: 'ローカル割り当てにTBAAタグを追加します。危険です。'
# 'Add __emutls_[vt]. variables for emultated TLS model'
H0F84398949DD: 'エミュレートされたTLSモデル用に__emutls_[vt]. 変数を追加します'
# 'Add a call to __hwasan_add_frame_record for storing into the stack ring buffer'
H42AEFE2097E5: 'スタックリングバッファへの書き込み時に__hwasan_add_frame_record呼び出しを追加します'
# 'Add a note for each bug report to denote their analysis entry points'
H540B9CECB600: '各バグ報告に分析エントリーポイントを示すためのメモを追加します'
# "Add a preheader to a hardware loop if one doesn't exist"
H90D8EF6E5EFA: 'ハードウェアループにプリヘッダが存在しない場合に追加します'
# "Add an attribute to a function. This can be a pair of 'function-name:attribute-name', to apply an attribute to a specific function. For example -force-attribute=foo:noinline. Specifying only an attribute will apply the attribute to every function in the module. This option can be specified multiple times."
H025869CF3D3D: '関数に属性を追加します。これは、"function-name:attribute-name"のペアとして指定し、特定の関数に属性を適用できます。例: -force-attribute=foo:noinline。属性のみを指定すると、モジュール内のすべての関数に適用されます。このオプションは複数回指定可能です。'
# 'Add an implicit negative check with this pattern to every\npositive check. This can be used to ensure that no instances of\nthis pattern occur which are not matched by a positive pattern'
H9C46F681BD1E: 'このパターンの明示的なネガティブチェックを各ポジティブチェックに追加します。これにより、ポジティブパターンにマッチしないこのパターンのインスタンスがないことを確認できます。'
# 'Add block information to the output of -streams'
H31B10635B121: ' -streams の出力にブロック情報を追加します'
# 'Add comments to directives.'
HB60639F27CEA: 'ディレクティブにコメントを追加します。'
# 'Add cs prefix to call and jmp to indirect thunk'
HF4B763BF676A: '間接サンドイッチ呼び出しとjmpにcsプレフィックスを追加します'
# 'Add debug loc information when generating tables for '
HFC939A7BE90F: 'テーブルを生成する際にデバッグロケーション情報を追加します'
# 'Add dependent library'
H340E932EB390: '依存ライブラリを追加します'
# 'Add dir to the list of library search paths'
HAF0260DD25B2: 'ライブラリ検索パスのリストにdirを追加します'
# 'Add directory to AFTER include search path'
HC2FABF8EF08B: 'QUOTE包含検索パスにディレクトリを追加します'
# 'Add directory to QUOTE include search path'
H24E806E38760: 'AFTER包含検索パスにディレクトリを追加します'
# 'Add directory to SYSTEM framework search path'
H8A929D35C6A7: 'システムフレームワーク検索パスにディレクトリを追加します'
# 'Add directory to SYSTEM framework search path, absolute paths are relative to -isysroot'
H690B2B7E95FE: 'システムフレームワーク検索パスにディレクトリを追加します。絶対パスは-isysrootに相対します'
# 'Add directory to SYSTEM include search path'
H87F8A546FC28: 'システム包含検索パスにディレクトリを追加します'
# 'Add directory to SYSTEM include search path, absolute paths are relative to -isysroot'
HCAEDF5228592: 'システム包含検索パスにディレクトリを追加します。絶対パスは-isysrootに相対します'
# 'Add directory to embed search path'
H6605669711E5: '埋め込み検索パスにディレクトリを追加'
# 'Add directory to end of the SYSTEM include search path'
HD7B48A7E62C9: 'SYSTEM インクルード検索パスの末尾にディレクトリを追加'
# 'Add directory to framework include search path'
H18A8E8D0F71C: 'フレームワーク インクルード検索パスにディレクトリを追加'
# 'Add directory to include search path'
H8E2DBDC224AD: 'インクルード検索パスにディレクトリを追加'
# 'Add directory to include search path with warnings suppressed'
H3D1B9139D392: '警告を抑制しつつインクルード検索パスにディレクトリを追加'
# 'Add directory to library search path'
H7382A4AE54AB: 'ライブラリ検索パスにディレクトリを追加'
# 'Add directory to the API notes search path referenced by module name'
H15347B13D121: 'モジュール名で参照されるAPIノート検索パスにディレクトリを追加'
# 'Add directory to the C SYSTEM include search path'
H04DB229B7703: 'C SYSTEM インクルード検索パスにディレクトリを追加'
# 'Add directory to the C++ SYSTEM include search path'
H99AF1D3B47BB: 'C++ SYSTEM インクルード検索パスにディレクトリを追加'
# 'Add directory to the ObjC SYSTEM include search path'
H4AD0218E28C9: 'ObjC SYSTEM インクルード検索パスにディレクトリを追加'
# 'Add directory to the ObjC++ SYSTEM include search path'
H4E8397371575: 'ObjC++ SYSTEM インクルード検索パスにディレクトリを追加'
# 'Add directory to the end of the list of include search paths'
HA9C01D5A6394: 'インクルード検索パスのリストの末尾にディレクトリを追加'
# 'Add directory to the internal system include search path with implicit extern "C" semantics; these are assumed to not be user-provided and are used to model system and standard headers\' paths.'
HA6F738C6C497: '暗黙のextern "C"セマンティクスを持つ内部システムインクルード検索パスにディレクトリを追加。これらはユーザー提供ではないと想定され、システムおよび標準ヘッダのパスをモデル化するために使用されます'
# "Add directory to the internal system include search path; these are assumed to not be user-provided and are used to model system and standard headers' paths."
H76AF34D02BE9: '内部システムインクルード検索パスにディレクトリを追加。これらはユーザー提供ではないと想定され、システムおよび標準ヘッダのパスをモデル化するために使用されます'
# 'Add dirs in env var <var> to include search path with warnings suppressed'
HFB17BE810349: '環境変数<var>のディレクトリを警告を抑制しつつインクルード検索パスに追加'
# 'Add extra TOC register dependencies'
HB5EA8815333D: '追加のTOCレジスタ依存関係を指定'
# 'Add informational comments to the .ll file'
H1430FC8452EC: '.llファイルに情報用コメントを追加'
# 'Add instruction count to a LSR cost model'
H35835E4FFD3B: 'LSRコストモデルに命令カウントを追加'
# 'Add library.'
H87317E57D7DD: 'ライブラリを追加。'
# 'Add linker option'
HEB1AFB3AB781: 'リンカーオプションを追加'
# 'Add missing headers to depfile'
H874052E89FC5: '欠落しているヘッダーを依存ファイルに追加します'
# 'Add no-alias annotation for instructions that are disambiguated by memchecks'
H7736CFB59CC2: 'memchecksにより曖昧さが解消された命令に no-alias アノテーションを追加します'
# 'Add printf calls that print the statement being executed'
H09CC61D8FD2B: '実行中のステートメントを印刷する printf 呼び出しを追加します'
# 'Add printf calls that print the values of all scalar values used in a statement. Requires -polly-codegen-trace-stmts.'
H955E9733D080: 'ステートメントで使用されるすべてのスカラ値の値を印刷する printf 呼び出しを追加します。-polly-codegen-trace-stmts が必要です。'
# 'Add printf calls that show the values loaded/stored.'
H7361CFCA90ED: 'ロード/ストアされた値を表示する printf 呼び出しを追加します'
# 'Add prototypes to prototypes-less functions'
H129252A67396: 'プロトタイプのない関数にプロトタイプを追加します'
# 'Add relocations to function pointers to the current function'
HC90D5751B49C: '現在の関数への関数ポインタに再配置を追加します'
# 'Add run-time performance monitoring'
H67AB397B08D2: '実行時パフォーマンス監視を追加します'
# 'Add system library paths to library search paths'
H444464D6D9E2: 'ライブラリ検索パスにシステムライブラリパスを追加します'
# 'Add the view as compare context.'
H9E4AA9613AAE: 'ビューを比較コンテキストとして追加します'
# 'Additional IR scalar types (always includes i1, i8, i16, i32, i64, float and double)'
H0A5D563266B6: '追加のIRスカラータイプ（i1、i8、i16、i32、i64、float、doubleを含む）'
# 'Additional argument to append to the compiler command line'
HEBA0B777F61D: 'コンパイラコマンドラインの末尾に追加する追加の引数'
# 'Additional argument to prepend to the compiler command line'
H6170CF05A381: 'コンパイラコマンドラインの先頭に追加する追加の引数'
# "Additional arguments to forward to LLVM's option processing"
HF5FFCDFCC6A2: 'LLVMのオプション処理に転送する追加の引数'
# "Additional arguments to forward to MLIR's option processing"
HF4553A1AE254: 'MLIRのオプション処理に転送する追加の引数'
# 'Additional arguments to pass to the linker'
H4F377C1D9775: 'リンカに渡す追加の引数'
# 'Additional shared objects to load into executing programs'
HE9D3E5D77A09: '実行中のプログラムに読み込む追加の共有オブジェクト'
# 'Address of the invoked server.'
H6E702787A95D: '呼び出されたサーバーのアドレス'
# 'Address of the invoked server. Defaults to 0.0.0.0:50051'
H54519DAF9B40: '呼び出されたサーバーのアドレス。デフォルトは 0.0.0.0:50051'
# 'Address sinking in CGP using GEPs.'
HC7C32F638F6D: 'GEP を使用した CGP 内のアドレスシンキング'
# "AddressSanitizer doesn't support linking with debug runtime libraries yet"
H46222370DDE7: 'AddressSanitizer はまだデバッグ ランタイム ライブラリとのリンクをサポートしていません'
# 'Adjust basic block layout to better use TB[BH]'
HB4BC97D1857E: 'TB[BH]の使用を最適化するための基本ブロック配置の調整'
# 'Adjust wave priority'
HBA116352E062: 'Wave プライオリティの調整'
# 'AdvSIMD Scalar Operation Optimization'
H45225A2C5722: 'AdvSIMD スカラ操作最適化'
# 'Advanced attributes alias.'
HA39A91E5AAD4: 'Advanced属性のエイリアス'
# 'Aggregate arguments to code-extracted functions'
H328995968B2E: 'コード抽出関数への引数の集約'
# 'Aggregate stack times across threads'
H5CF510D1EBBA: 'スレッド間でのスタック時間の集計'
# 'Aggressive extension optimization'
HA4AE7C7FBB62: '積極的な拡張最適化'
# 'Aggressively try to fuse everything'
H9E616808E7EC: 'すべてを融合させるために積極的に試みる'
# 'Algorithm to use for splitting basic blocks into multiple statements'
H077B22383231: '基本ブロックを複数のステートメントに分割するために使用するアルゴリズム'
# 'Alias Analysis Pipeline'
HE33821D525F2: 'エイリアス分析パイプライン'
# 'Alias for --'
HA3FB2C7B610D: '--のエイリアス'
# 'Alias for --blocks-x'
H57C6A0E441DA: '--blocks-xのエイリアス'
# 'Alias for --demangled-names'
HE840FF95BF7A: '--demangled-namesのエイリアス'
# 'Alias for --dry-run'
H0FA96A999664: '--dry-runのエイリアス'
# 'Alias for --help'
HF39AA3CC9361: '--helpのエイリアス'
# 'Alias for --indirect-call-promotion'
HDBD75B583A13: '--indirect-call-promotionのエイリアス'
# 'Alias for --input-files'
HDFC325842CEB: '--input-filesのエイリアス'
# 'Alias for --intermediate-format'
HD7D86B4F5A3A: '--intermediate-formatのエイリアス'
# 'Alias for --no-warn'
H6C7B7F57DEA7: '--no-warnのエイリアス'
# 'Alias for --num-threads'
HE9977CCA0811: '--num-threadsの別名'
# 'Alias for --output'
HA7011D865212: '--outputの別名'
# 'Alias for --output-dir'
HC51012922C34: '--output-dirの別名'
# 'Alias for --perfdata'
H136FC40E1E00: '--perfdataの別名'
# 'Alias for --perfscript'
H3EE8965681A7: '--perfscriptの別名'
# 'Alias for --remapping-file'
H24A193959D48: '--remapping-fileの別名'
# 'Alias for --save-temps=cwd'
HB0770869E271: '--save-temps=cwdの別名'
# 'Alias for --threads-x'
H2B37E4881B6D: '--threads-xの別名'
# 'Alias for --unsymbolized-profile'
HAAA114F8EC1E: '--unsymbolized-profileの別名'
# 'Alias for -Xclang'
HCD7F2ECE0041: '-Xclangの別名'
# 'Alias for -all-stacks'
HBF7B049FB306: '-all-stacksの別名'
# 'Alias for -check-prefix permitting multiple comma separated values'
HD103BAE71227: '-check-prefix（複数のカンマ区切り値を許可）の別名'
# 'Alias for -color-edges'
HC19B12CB2430: '-color-edgesの別名'
# 'Alias for -deduce-sibling-calls'
H2E10ADB53A0A: '-deduce-sibling-callsの別名'
# 'Alias for -deduce-sibling-calls-1'
HF24D573B4E93: '-deduce-sibling-calls-1の別名'
# 'Alias for -deduce-sibling-calls-2'
H4800F023F658: '-deduce-sibling-calls-2の別名'
# 'Alias for -deduce_sibling_calls'
HFE68AA381CCA: '-deduce_sibling_callsの別名'
# 'Alias for -edge-color'
H5FEAD1AEB73F: '-edge-colorの別名'
# 'Alias for -edge-label'
HAFADF6FC17E1: '-edge-labelの別名'
# 'Alias for -fextend-variable-liveness=all.'
H2B2334ED3B9F: '-fextend-variable-liveness=all.の別名'
# 'Alias for -fsanitize-ignorelist='
H6624562D7869: '-fsanitize-ignorelist= のエイリアス'
# 'Alias for -help'
HEA697AFD46B7: '-help のエイリアス'
# 'Alias for -instr-map'
HB57A8B70724F: '-instr-map のエイリアス'
# 'Alias for -instr-map-1'
H6F2C86FF53ED: '-instr-map-1 のエイリアス'
# 'Alias for -instr-map-2'
HD9A737CB2F17: '-instr-map-2 のエイリアス'
# 'Alias for -instr_map'
H13EC2B696DE5: '-instr_map のエイリアス'
# 'Alias for -keep-going'
HC2FBFBC9B1BF: '-keep-going のエイリアス'
# 'Alias for -keep-going-1'
HFC1713D60AC5: '-keep-going-1 のエイリアス'
# 'Alias for -keep-going-2'
HB73DA9252C0A: '-keep-going-2 のエイリアス'
# 'Alias for -keep_going'
H25546D53A1D1: '-keep_going のエイリアス'
# 'Alias for -mllvm'
HE5CF0AF34303: '-mllvm のエイリアス'
# 'Alias for -output'
H11E85BC44369: '-output のエイリアス'
# 'Alias for -output-format'
HCE5EA67FACF7: '-output-format のエイリアス'
# 'Alias for -passes'
HAC9042256B8B: '-passes のエイリアス'
# 'Alias for -sort'
H439A5386F45B: '-sort のエイリアス'
# 'Alias for -sortorder'
H29F0D261B98A: '-sortorder のエイリアス'
# 'Alias for -symbolize'
HD9D9FFEE4D20: '-symbolize のエイリアス'
# 'Alias for -top'
H0697652EC65F: '-top のエイリアス'
# 'Alias for -version'
HD2E0461080FA: '-version のエイリアス'
# 'Alias for -vertex-color'
HB336A9FE055A: '-vertex-color のエイリアス'
# 'Alias for -vertex-label'
HB5305BD11A1C: '「-vertex-label」のエイリアス'
# 'Alias for -vertex-label-trun'
HBB4740B7076F: '「-vertex-label-trun」のエイリアス'
# 'Alias of -format'
HD5F8D2C37C5D: '「-format」のエイリアス'
# 'Align ARM NEON spills in prolog and epilog'
HA6EB49748CD3: 'プロローグとエピローグにおけるARM NEONのspillをアライメント調整'
# 'Align branches within 32-byte boundaries to mitigate the performance impact of the Intel JCC erratum.'
H5A28F46326DE: 'IntelのJCCエラタによるパフォーマンスへの影響を軽減するために、32バイト境界内のブランチをアライメント調整します。'
# 'Align constant islands in code'
H461BA6D2D6E3: 'コード内の定数アイランドをアライメント調整'
# 'Align doubles to two words in structs (x86 only)'
HEDC15B5DDF59: '構造体内でdoubleを2ワードにアライメント（x886のみ）'
# 'Align selected branches (fused, jcc, jmp) within 32-byte boundary'
H61C864267E04: '選択されたブランチ（fused、jcc、jmp）を32バイト境界内にアライメント'
# "Align selected instructions to mitigate negative performance impact of Intel's micro code update for errata skx102.  May break assumptions about labels corresponding to particular instructions, and should be used with caution."
H4F2747860017: 'Intelのマイクロコード更新（errata skx102対策）によるネガティブなパフォーマンス影響を軽減するために選択された命令をアライメント。ラベルが特定の命令に対応しなくなる可能性があり、注意して使用してください。'
# 'Aligned allocation/deallocation functions are unavailable'
H93CADD3D554F: 'アライメント調整されたアロケーション/ディアルロケーション関数は利用できません'
# 'Alignment of bundle for binary files'
H746C20CFEB90: 'バンドルのアライメント (バイナリファイル用)'
# "All compile commands come from LSP and 'compile_commands.json' files are ignored"
H35E96D7E99B1: 'すべてのコンパイルコマンドはLSPから取得し、"compile_commands.json"ファイルは無視されます'
# "All compile commands come from the 'compile_commands.json' files"
H2E03660ADBFF: 'すべてのコンパイルコマンドは"compile_commands.json"ファイルから取得されます'
# 'All decisions not in replay are inlined'
H9B15B2C90AE0: 'replayに含まれないすべての決定をインライン化'
# 'All decisions not in replay are not inlined'
H1838D4DFB9C1: 'replayに含まれないすべての決定をインライン化しません'
# 'All decisions not in replay send to original advisor (default)'
H8494FD0B179D: 'replayに含まれないすべての決定を元のアドバイザーに送信（デフォルト）'
# 'All edges.'
HA0232E12FF85: 'すべてのエッジ'
# 'All elements.'
HD1FF88F0C212: 'すべての要素'
# 'All input lines'
HAA2659CBF3BE: 'すべての入力行'
# 'All known subsections'
H605028076261: 'すべての既知のサブセクション'
# 'All non-critical edges.'
H4DF2A4AF93D9: '非クリティカルなすべてのエッジ。'
# 'All of the above and take the minimum of measurements'
H8D49782EBA5E: '上記すべてに加え、測定値の最小値を採用する'
# 'All outputs.'
HA29C21D07A12: 'すべての出力。'
# 'All possible int comparisons in GPRs.'
H166898BCED35: 'GPR 内での可能なすべての整数比較。'
# 'All suitable variables will have the TOC data transformation applied'
H5309722D6033: '適切な変数にはTOC データ変換が適用されます'
# 'All vtables have type infos'
H69D2DF6DECC5: 'vtable すべてに型情報がある'
# 'All warnings.'
H294EA62DA621: 'すべての警告。'
# 'Allocate all arrays of unknown size and temporary arrays in stack memory'
H3AE89D60479D: '不明なサイズの配列と一時配列をすべてスタックメモリに配置'
# 'Allocate array temporaries on the heap (default)'
HF192F6B25D6C: '配列の一時領域をヒープに配置（既定値）'
# 'Allocate from a slab of the given size (allowable suffixes: Kb, Mb, Gb. default = Kb)'
H8D1230E33C0D: '指定サイズのスラブから確保（許容される接尾辞: Kb, Mb, Gb. 既定値はKb）'
# 'Allocate memory upfront rather than on-demand'
H067B160BE7A4: '必要に応じるのではなく事前にメモリを確保'
# 'Allocate to an enum type only as many bytes as it needs for the declared range of possible values'
H5482421F99A5: 'enum 型には、宣言された値範囲に必要なだけバイト数を割り当てる'
# "Allow '$' in identifiers"
H6DB82DC47410: '識別子に $ を許可'
# 'Allow (may be subject to certain conditions) conversion of memcpy to TP loop.'
HF0E5B5A536C5: '条件付きながら memcpy を TP ループに変換を許可'
# 'Allow AArch64 Local Dynamic TLS code generation'
H307A55AE7B7F: 'AArch64 ローカルダイナミック TLS コード生成を許可'
# 'Allow DSE to optimize memory accesses.'
H6047B03BEC73: 'DSE によるメモリアクセスの最適化を許可'
# 'Allow GNU-extension keywords regardless of language standard'
H2947F99E638F: '言語仕様に関わらず GNU 拡張キーワードを許可'
# 'Allow G_INSERT to be considered an artifact. Hack around AMDGPU test infinite loops.'
H8D40AAA978F4: 'G_INSERT をアーティファクトとみなす. AMDGPU テストの無限ループ回避のためのハック'
# 'Allow JumpThreading to thread across loop headers, for testing'
H0966C1037306: 'JumpThreading でループヘッダを跨いだスレッド化を許可（テスト用）'
# 'Allow Objective-C array and dictionary subscripting in legacy runtime'
HCDF0596C06B7: '従来のランタイムで Objective-C 配列とディクショナリのサブスクリプティングを許可'
# 'Allow SimplifyCFG to merge invokes together when appropriate'
H6D05BDC01566: '適切な場合、SimplifyCFG が invoke をマージできるようにする'
# 'Allow __declspec as a keyword'
HCB246A7067C5: '__declspec をキーワードとして有効にする'
# 'Allow aggressive, lossy floating-point optimizations'
H0FAF2AF8BF00: '積極的で、浮動小数点数の精度を犠牲にする最適化を許可する'
# 'Allow atomic operations to ignore denormal mode'
HCF502E940887: '原子操作がデノーマル モードを無視することを許可する'
# 'Allow calls to the specified functions in SCoPs even if their side-effects are unknown. This can be used to do debug output in Polly-transformed code.'
H1410ADCFCAA7: 'SCoPs 内で指定された関数を呼び出すことを許可します。副作用が未知でも可。これにより、Polly 変換後のコードでのデバッグ出力が可能です。'
# 'Allow certain math function calls to be replaced with an approximately equivalent calculation'
H7E6336F3B5B7: '特定の数学関数の呼び出しを近似的に同等の計算に置き換えることを許可する'
# 'Allow cloning of callsites involved in recursive cycles'
HF572EEE2B09E: '再帰的サイクルに関与するコールサイトの複製を許可する'
# 'Allow cloning of contexts having recursive cycles'
H599BF96DBCB9: '再帰的サイクルを有するコンテキストの複製を許可する'
# 'Allow cloning of contexts through recursive cycles'
HB9EECACDCD85: '再帰的サイクルを通じたコンテキストの複製を許可する'
# 'Allow combining of BaseGV field in Address sinking.'
H2D77F4CB6201: 'Address sinking での BaseGV フィールドの結合を許可する'
# 'Allow combining of BaseOffs field in Address sinking.'
HF852DDC4F55A: 'Address sinking での BaseOffs フィールドの結合を許可する'
# 'Allow combining of BaseReg field in Address sinking.'
H26B9669FA2AC: 'Address sinking での BaseReg フィールドの結合を許可する'
# 'Allow combining of ScaledReg field in Address sinking.'
HDEF3EE554628: 'Address sinking での ScaledReg フィールドの結合を許可する'
# 'Allow compiler to merge handlers for all sanitizers'
H5230AC99F094: 'コンパイラがすべての Sanitizer ハンドラをマージできるようにする'
# 'Allow compiler to merge handlers for specified sanitizers'
HD4BB34899488: 'コンパイラが指定された Sanitizer ハンドラをマージできるようにする'
# 'Allow conditional instructions outside of an IT block'
H08E49F0EFDBF: 'IT ブロック外での条件付き命令を許可する'
# 'Allow counter promotion across the whole loop nest.'
HD6A96DE259B4: 'ループネスト全体でのカウンタープロモーションを許可する'
# 'Allow creation of Phis in Address sinking.'
HE9D1F49BEE6D: 'Address sinking での Φ ノードの作成を許可する'
# 'Allow creation of selects in Address sinking.'
HF3DF8C2D011E: 'Address sinking での select 命令の作成を許可する'
# 'Allow device side init function in HIP (experimental)'
HBC635735388C: 'HIP でのデバイス側初期化関数を許可（実験的）'
# 'Allow different element types for array accesses'
HE3FBA82C5731: '配列アクセスに対して異なる要素型を許可'
# 'Allow division operations to be reassociated'
HAD0D8D2448AD: '除算演算を再結合させることを許可'
# 'Allow enabling loop hints to reorder FP operations during vectorization.'
HD2BC949EEEE2: 'ベクトル化中にFP演算の順序を変更するループヒントを有効化することを許可'
# 'Allow exactly one expensive instruction to be speculatively executed'
H2182F06086EB: '正確に1つの高コスト命令を推測実行することを許可'
# 'Allow floating-point optimizations that assume arguments and results are not NaNs or +-inf. This defines the \\_\\_FINITE\\_MATH\\_ONLY\\_\\_ preprocessor macro.'
H49916D802745: 'NaNや+-infではない引数と結果を仮定した浮動小数点最適化を許可します。\\_\\_FINITE\\_MATH\\_ONLY\\_\\_というプリプロセッサマクロを定義します。'
# 'Allow for a mixture of Mips16 and Mips32 code in a single output file'
H85A1B3521C3C: '単一の出力ファイル内にMips16とMips32コードを混在させることを許可'
# 'Allow functions with known modref behavior'
HE8FEED2897E6: '既知の変更/参照挙動を持つ関数を許可'
# 'Allow generation of a loop remainder (extra iterations) when unrolling a loop.'
HA9A95BA27CAD: 'ループの展開時にループ余分な反復（ループ余り）を生成することを許可'
# 'Allow generation of complex IT blocks.'
H0C587C47350A: '複雑なITブロックの生成を許可'
# 'Allow generation of data access to code sections (AArch64/ARM only)'
H4E803F81C9B5: 'コードセクションへのデータアクセスの生成を許可（AArch64/ARMのみ）'
# 'Allow header insertions'
H94D83C00667E: 'ヘッダの挿入を許可'
# 'Allow header removals'
H47A033C84B47: 'ヘッダの削除を許可'
# 'Allow incomplete IR on a best effort basis (references to unknown metadata will be dropped)'
H05F1B598EC8B: '不完全なIRを最善の努力で許可（不明なメタデータへの参照は破棄されます）'
# "Allow inlining when caller has a superset of callee's nobuiltin attributes."
H21EB86A2A3AB: '呼び出し元が呼び出し先のnobuiltin属性のスーパー集合を有する場合のインライン化を許可'
# 'Allow loop rotation multiple times in order to reach a better latch exit'
HE5B48E5AC62B: 'より良いラッチ出口に達するために、ループ回転を複数回実行することを許可'
# 'Allow mapping symbol at section beginning to be implicit, lowering number of mapping symbols at the expense of some portability. Recommended for projects that can build all their object files using this option'
HE30942163DF4: 'セクションの先頭にあるマッピングシンボルを暗黙的に扱い、マッピングシンボルの数を減らす（一部の移植性を犠牲に）。このオプションを使用してすべてのオブジェクトファイルをビルドできるプロジェクト向けに推奨されます'
# 'Allow memory accesses to be unaligned (AArch32/MIPSr6 only)'
H4DACD884827E: '非アラインメモリアクセスを許可（AArch32/MIPSr6のみ）'
# 'Allow memory accesses to be unaligned (AArch64/LoongArch/RISC-V only)'
H075169115FA2: '非アラインメモリアクセスを許可（AArch64/LoongArch/RISC-Vのみ）'
# 'Allow mergefunc to create aliases'
H96D31DA83FB1: 'mergefuncがエイリアスを作成することを許可'
# 'Allow merging of constants'
H7B7B2A69B6A1: '定数のマージを許可'
# 'Allow non affine access functions in arrays'
H1B750054F6AE: '配列に非直線形アクセス関数を許可します'
# 'Allow non affine conditions for branches'
H02FFF4B1AF5A: 'ブランチの非直線形条件を許可します'
# 'Allow non affine conditions for loops'
H7C67DD81E47E: 'ループの非直線形条件を許可します'
# 'Allow non-power-of-2 vectorization.'
HA2D0D7F2C7BF: '非2のべき乗ベクタライゼーションを許可します。'
# 'Allow non-solo packetization of volatile memory references'
H5792B0D4B6CC: 'volatileメモリ参照のソロでないパケット化を許可します'
# 'Allow operation with no registered dialects'
H7A999A69E320: '未登録の方言を操作する機能を許可します'
# 'Allow operation with no registered dialects (discouraged: testing only!)'
HF9B2D65D3FE4: '未登録の方言を操作する機能を許可します（推奨されません：テスト専用！）'
# 'Allow operations coming from an unregistered dialect'
HC8673F2EA652: '未登録の方言から来た操作を許可します'
# 'Allow optimization to assume there are no NaNs.'
H4027A2790C01: 'NaNがないことを仮定した最適化を許可します。'
# 'Allow optimization to assume there are no infinities.'
H2F8AEF326E4D: '無限大がないことを仮定した最適化を許可します。'
# 'Allow optimizations that ignore the sign of floating point zeros'
H74EA3796D9B9: '浮動小数点ゼロの符号を無視する最適化を許可します'
# 'Allow partial writes'
H36F20305E82F: '部分的な書き込みを許可します'
# 'Allow passing GC Pointer arguments in callee saved registers'
HAAA2F5C160B0: 'GCポインタ引数をcallee保存レジスタで渡すことを許可します'
# 'Allow placing main program variables on the stack (default)'
HFA7AA687FA70: 'スタックにメインプログラム変数を配置（デフォルト）'
# 'Allow prefixes to be specified but not appear in the test.'
HE9A068B65F59: 'プレフィックスを指定するがテストに現れない場合を許可します'
# 'Allow reassociation transformations for floating-point instructions'
H69FAD124BA17: '浮動小数点命令の再結合変換を許可します'
# 'Allow relaxed uniform region checks'
HECAF51D715EB: '緩和された一様領域チェックを許可します'
# 'Allow reordering across at most this many instructions when hoisting'
H03C130FA1582: 'ホイスタリング時に命令をこの数まで並べ替えることを許可します'
# 'Allow runtime unroll for AMDGPU if local memory used in a loop'
H6AD964FBACC9: 'AMDGPUでループ内でローカルメモリを使用する場合の実行時アンロールを許可します'
# 'Allow runtime unrolled loops to be unrolled with epilog instead of prolog.'
H402D9BD954E3: 'プロローグの代わりにエピローグを使用して、実行時アンロールされたループをアンロールを許可します。'
# 'Allow runtime unrolling for loops with multiple exits, when epilog is generated'
H612B7424A810: 'エピローグが生成される場合、複数の出口を有するループの実行時アンロールを許可します。'
# 'Allow sample loader inliner to inline recursive calls.'
HA6530F6AAC71: 'サンプルローダーインラインが再帰呼び出しをインライン化することを許可します。'
# 'Allow scalar memory accesses to be unaligned (RISC-V only)'
HFC86196CBA64: 'RISC-Vのみ：スカラメモリアクセスがアンアライドであることを許可します。'
# 'Allow slot1 store and slot0 load'
H7437ACC71E24: 'slot1ストアとslot0ロードを許可します。'
# 'Allow speculation of preheader instructions'
H363DA7F8452D: 'プリヘッダ命令の推測を許可します。'
# 'Allow spill in spill slot of greater size than register size'
H9CD29F6A2A53: 'レジスタサイズよりも大きいスpillスロットでのスpillを許可します。'
# 'Allow static variables in .sdata'
H770981D5F907: '.sdataセクションに静的変数を許可します。'
# 'Allow the Attributor to create shallow wrappers for non-exact definitions.'
HB6DC09C0C648: '非厳密な定義に対して、Attributorが浅いラッパーを作成することを許可します。'
# 'Allow the Attributor to do call site specific analysis'
H2595BA1E26D0: 'Attributorがコールサイト固有の解析を行うことを許可します。'
# 'Allow the Attributor to use IP information derived from non-exact functions via cloning'
H0E8CFBCDE797: 'クローン経由で非厳密関数から得られたIP情報を使用することをAttributorに許可します。'
# 'Allow the detection of full functions'
H6DD82ED565A3: '完全な関数の検出を許可します。'
# 'Allow the formation of VW_W operations (e.g., VWADD_W) with splat constants'
H845C6DF92D8C: 'splat定数を使用したVW_Wオペレーション（例：VWADD_W）の形成を許可します。'
# 'Allow the input file to be empty. This is useful when making\nchecks that some error message does not occur, for example.'
H658BEA7D8D36: '入力ファイルが空の場合を許可します。例えば特定のエラーメッセージが発生しないことを確認する場合に便利です。'
# 'Allow the loop remainder to be unrolled.'
H54EBCBE4781C: 'ループの余り部分をアンロールを許可します。'
# 'Allow the use of FMAs if available and profitable. This may result in different results, due to less rounding error.'
H996DA0DE6CCE: '利用可能な場合、効果的なFMAを使用を許可します。丸め誤差が少ないため、結果が異なる場合があります。'
# 'Allow to search for module maps in subdirectories of search paths'
H4C313304A657: '検索パスのサブディレクトリからモジュールマップを検索することを許可します。'
# "Allow to speculate on the execution of 'error blocks'."
H88DB79B94D55: 'エラーブロックの実行に対する推測を許可します。'
# 'Allow unsafe floating-point math optimizations which may decrease precision'
H67E450B90F32: '精度を低下させる可能性のある危険な浮動小数点最適化を許可します。'
# 'Allow unsigned operations such as comparisons or zero-extends.'
H33CDECA8CBA8: '無符号操作（比較やゼロ拡張など）を許可します。'
# 'Allow use of CMSE (Armv8-M Security Extensions)'
H21EADF8CC690: 'Armv8-M セキュリティ拡張（CMSE）の使用を許可します。'
# 'Allow use of CRC instructions (ARM/Mips only)'
H0928C2372DB2: 'CRC命令（ARM/Mipsのみ対応）の使用を許可します。'
# 'Allow using blocks with parameters of more specific type than the type system guarantees when a parameter is qualified id'
HEADAE3890D46: 'パラメータが修飾識別子（qualified id）である場合、型システムが保証するより具体的な型を持つblocksの使用を許可します。'
# 'Allow using registers for gc pointer in landing pad'
H6D19D992878A: 'landing pad内のgc ポインターをレジスタで使用することを許可します。'
# 'Allow using registers for non pointer deopt args'
HD185DF4F0E95: '非ポインターのdeopt引数をレジスタで使用することを許可します。'
# 'Allow variadic functions in CUDA device code.'
H918161EF13F5: 'CUDA デバイスコード内で可変長関数を許可します。'
# 'Allow vector memory accesses to be unaligned (RISC-V only)'
HB7E7D4EF733A: '未アラインのベクタメモリアクセスを許可します（RISC-Vのみ）。'
# 'Allow widening of indvars to eliminate s/zext'
HC582FEBF6EC9: 's/zextの削除を目的としたindvarsの拡張を許可します。'
# 'Allowed symbol scopes (comma-separated list)'
H09C539E5B693: '許可されるシンボルスコープ（カンマ区切りリスト）'
# 'Allows assuming by-value parameters do not alias any other value. Has no effect on non-trivially-copyable classes in C++.'
HA18120EB5360: '値渡しパラメータが他の値とアリasingしないことを仮定します。C++では非単純コピー可能なクラスには効果ありません。'
# 'Allows control over excess precision on targets where native support for BFloat16 precision types is not available. By default, excess precision is used to calculate intermediate results following the rules specified in ISO C99.'
HBB6845887CAC: 'ネイティブBFloat16精度型サポートが無いプラットフォームで過剰精度の制御を行います。デフォルトではISO C99のルールに従い中間結果の計算に過剰精度を使用します。'
# 'Allows control over excess precision on targets where native support for Float16 precision types is not available. By default, excess precision is used to calculate intermediate results following the rules specified in ISO C99.'
HC49D9EDA0518: 'ネイティブFloat16精度型サポートが無いプラットフォームで過剰精度の制御を行います。デフォルトではISO C99のルールに従い中間結果の計算に過剰精度を使用します。'
# 'Allows control over excess precision on targets where native support for the precision types is not available. By default, excess precision is used to calculate intermediate results following the rules specified in ISO C99.'
HF60814E6692A: 'ネイティブサポートのない精度型プラットフォームで過剰精度を制御します。デフォルトではISO C99のルールに従い中間結果計算に過剰精度を使用します。'
# 'Allows loop nests to be peeled.'
HFE032116CB53: 'ループネストのpeelingを許可します。'
# 'Allows loops to be partially unrolled until -unroll-threshold loop size is reached.'
HAAF79FCD3521: '-unroll-threshold サイズに達するまでループを部分的にアンロールします。'
# 'Allows loops to be peeled when the dynamic trip count is known to be low.'
HE4D86D272F84: '動的ループ回数が低いことが確定した場合にループをpeelingします。'
# 'Allows loops to be unroll-and-jammed.'
H08E5D5835443: 'ループのunroll-and-jammedを許可します。'
# 'Allows to add additional results to private functions to return ownership of returned memrefs to callers. This can avoid spurious buffer clones in the callee.'
H2478745EEA16: 'private関数に追加の結果を追加し、呼び出し元に返却されたmemrefsの所有権を返却します。これにより呼び出し先での不必要なバッファクローンを回避できます。'
# 'Allows using features specific to Hugo'
H5D750A78EC0D: 'Hugo固有の機能を使用可能にします'
# 'Also show functions without any scops'
H8AA7DD878BF3: 'スコープのない関数も表示します'
# 'Also write profiles with all-zero counters. Intended for testing/debugging.'
HC00EF438F6CF: 'すべてのカウンタがゼロのプロファイルも書き込みます。テスト/デバッグ用です。'
# 'Always Step Into.'
H2D9E73855459: '常にステップインします。'
# 'Always convert memcpy to TP loop.'
H43BC365E404A: 'TPループにmemcpyを常に変換します'
# 'Always detect stack use after return.'
HAA3BC6D7C687: '戻り値後のスタック使用を常に検出します'
# 'Always dump input'
HA3473C53D75A: '常に入力をダンプします'
# 'Always emit EH frame entries'
HDDDD83A3567E: '常にEHフレームエントリを生成します'
# 'Always emit __xray_customevent(...) calls even if the containing function is not always instrumented'
H3096C16CDC52: '含む関数が常にインストルメントされていない場合でも、__xray_customevent(...)呼び出しを常に生成します'
# 'Always emit __xray_typedevent(...) calls even if the containing function is not always instrumented'
H2E61DC30BF81: '含む関数が常にインストルメントされていない場合でも、__xray_typedevent(...)呼び出しを常に生成します'
# 'Always emit a debug frame section'
HB80937D1780A: '常にデバッグフレームセクションを生成します'
# 'Always emit a debug frame section.'
H23A9192A38F7: '常にデバッグフレームセクションを生成します。'
# 'Always exclude wrong side overloads in overloading resolution for CUDA/HIP'
HA5AB629FB85E: 'CUDA/HIPのオーバーロード解決で誤った側のオーバーロードを常に除外します'
# 'Always generate function calls for address sanitizer instrumentation'
HA25586514168: 'アドレスサンitizerのインストルメント用の関数呼び出しを常に生成します'
# 'Always modify dest registers regardless of color'
H58E66AB0CF8C: '色に関係なくdestレジスタを常に変更します'
# 'Always set the bit'
H9287AFC9334D: 'ビットを常に設定します'
# 'Always track the overflow bit.'
H577F71683BBC: 'オーバーフロー ビットを常に追跡します'
# 'Always use $gp as the global base register.'
HC4090BE1945A: '$gpをグローバルベースレジスタとして常に使用します'
# 'Always use DW_AT_ranges in DWARFv5 whenever it could allow more address pool entry sharing to reduce relocations/object size'
H5C1DD29350B5: 'DWARFv5で、アドレスプールエントリ共有を増やし、relocations/objectサイズを削減できる場合、常にDW_AT_rangesを使用します'
# 'Always use compact branches if possible.'
H9248BC8A7969: '可能な場合、コンパクトなブランチを常に使用します'
# 'Always use descriptors for POINTER and ALLOCATABLE'
H088038A3E688: 'POINTERおよびALLOCATABLEには常にディスクリプタを使用します'
# 'Always used text-based completion'
H186681547B61: '常にテキストベースの補完を使用します'
# 'Always write temporary files as bitcode instead of textual IR'
H1C24DC778992: '一時ファイルは常にビットコードとして書き込み、テキスト形式のIRを使用しない'
# 'An ID for compilation unit, which should be the same for the same compilation unit but different for different compilation units. It is used to externalize device-side static variables for single source offloading languages CUDA and HIP so that they can be accessed by the host code of the same compilation unit.'
HEAEE5FF78DA6: 'コンパイルユニットのID。同じコンパイルユニットに対しては同じ値を使用し、異なるユニットに対しては異なる値を使用します。CUDAやHIPのような単一ソースオフローディング言語において、デバイス側の静的変数を外部参照可能にするために使用され、同じコンパイルユニットのホストコードからアクセス可能にするためです。'
# 'An additional cost threshold that must be exceeded for merging to be considered beneficial.'
H80CD60A8D728: 'マージを有益と考えるためには超える必要がある追加のコスト閾値'
# 'An allocatable left-hand side of an intrinsic assignment is assumed to be allocated and match the shape/type of the right-hand side'
H80F5410F8454: 'インtrinsic代入の左辺としてのallocatable変数は、右辺のshape/typeと一致していると仮定されます'
# 'An integer in percent used to specify the hot blocks/edges to be displayed in red: a block or edge whose frequency is no less than the max frequency of the function multiplied by this percent.'
H785F9B56BA61: '熱いブロック/エッジを赤色で表示するために使用されるパーセンテージ。ブロックまたはエッジの周波数が、このパーセンテージに関数の最大周波数を乗じた値以上の場合、赤色で表示されます'
# 'Analysis'
H62C7FCF46E27: '分析'
# 'Analysis containing CSE Info'
H844D68401590: 'CSE情報が含まれる分析'
# 'Analysis for ComputingKnownBits'
H7CC4A0AB7F2C: 'ComputingKnownBitsのための分析'
# 'Analysis if a function is memory bound'
H4D110E7E06DE: '関数がメモリーバウンドであるかどうかの分析'
# 'Analyze Machine Code For Garbage Collection'
H9DF9D8E23EF5: 'ガベージコレクションのためのマシンコードの分析'
# 'Analyze array contents for load forwarding'
H400B26D98EF4: 'ロードフォワーディングのために配列の内容を分析'
# 'Annotate LTO phase (prelink / postlink), or main (no LTO) for sample-profile inline pass name.'
HE2E0B6955283: 'LTOフェーズ（prelink/postlink）またはmain（LTOなし）をアノテートし、サンプルプロファイルインラインパスの名前を特定します'
# 'Annotate SI Control Flow'
H917E9747DC24: 'SI制御フローをアノテート'
# 'Annotate call sites of function declarations.'
H117120C6D4F8: '関数宣言のコールサイトをアノテート'
# 'Annotate table jump instruction to correlate it with the jump table.'
H49774B77C4AA: 'ジャンプテーブルの命令をアノテートし、ジャンプテーブルと関連付けます'
# 'Any subsection not covered by another option'
HE0257BE6772D: '他のオプションでカバーされていない任意のサブセクション'
# 'Append function hash to the name of COMDAT function to avoid function hash mismatch due to the preinliner'
HFFA3462002F7: 'preinlinerによるハッシュ不一致を回避するために、COMDAT関数の名前に関数ハッシュを追加'
# "Append the exit code to the output so it gets diff'd too"
H9E3A9D6959C1: '出力に終了コードを追加し、diff対象に含めるようにします'
# 'Append vectorize enable/disable metadata from polly'
H9E5D3061A26C: 'Pollyからベクタライズの有効/無効メタデータを追加します'
# 'Appends one trailing underscore to external names'
HD2751F46D9D1: '外部名の末尾にアンダースコアを1つ追加します'
# 'Apple'
H476432A3E85A: 'Apple'
# 'Applies path clonings for the -basic-block-sections=list option'
H2424A194F26C: 'オプション -basic-block-sections=list に対してパスのクローンを適用します'
# 'Apply CHR for all functions'
H577A52B0B7CC: 'すべての関数に対してCHRを適用します'
# 'Apply an iterative post-processing to infer correct BFI counts'
H66ADFA49B9E1: '正しくBFIのカウントを推論するために反復的なポスト処理を適用します'
# 'Apply edits to analyzed source files'
HFDE3C74EED4D: '解析済みソースファイルに対して編集を適用します'
# 'Apply first slot optimization for stack tagging (eliminate ADDG Rt, Rn, 0, 0).'
H2ADE0B593B04: 'スタックタグ付け用の最初のスロット最適化を適用（ADDG Rt, Rn, 0, 0 を削除します）'
# 'Apply fix-it advice creating a file with the given suffix'
H2BD66E062CA1: '指定された接尾辞を付加したファイルを作成するfix-itアドバイスを適用'
# 'Apply fix-it advice even in the presence of unfixable errors'
H011FCA2E909C: '修正不可能なエラーがあってもfix-itアドバイスを適用'
# 'Apply fix-it advice only for warnings, not errors'
H6ED66F770BAD: '警告には適用するが、エラーには適用しません'
# 'Apply fix-it advice to the input source'
HFFEDA0075E38: '入力ソースにfix-itアドバイスを適用'
# 'Apply fix-it changes and recompile'
H6D9BFB4F5F51: 'fix-it変更を適用して再コンパイル'
# 'Apply fix-it changes to temporary files'
HF35652D64499: '一時ファイルにfix-it変更を適用'
# 'Apply given attribute to all functions'
H0A840E827150: 'すべての関数に指定された属性を適用'
# 'Apply global symbol visibility to external declarations without an explicit visibility'
HB6DB5D64D7AE: '明示的な可視性が指定されていない外部宣言にグローバルシンボル可視性を適用'
# 'Apply no_sanitize to the whole file'
H1820034AB28F: 'no_sanitizeを全体のファイルに適用'
# 'Apply post-rescheduling optimizations such as tiling (requires -polly-reschedule)'
HD42F33B0AD22: 'プロファイルガイドされたサイズ最適化を、作業セットサイズが大きい場合にのみ適用（コールドコードは除く）'
# 'Apply the profile guided size optimizations only if the working set size is large (except for cold code.)'
HCAA14E2BEA3D: 'instrumentation PGOの下で、プロファイルガイドされたサイズ最適化をコールドコードのみに適用'
# 'Apply the profile guided size optimizations only to cold code under instrumentation PGO.'
H88E35D1AFA04: 'プロファイルガイドされたサイズ最適化を、インストゥルメンテーション PGO の下でコールド コードにのみ適用します。'
# 'Apply the profile guided size optimizations only to cold code under partial-profile sample PGO.'
HA712F1C73153: 'プロファイルガイドされたサイズ最適化を、部分プロファイル サンプル PGO の下でコールド コードにのみ適用します。'
# 'Apply the profile guided size optimizations only to cold code under sample PGO.'
H15AF6FCF8AC2: 'プロファイルガイドされたサイズ最適化を、サンプル PGO の下でコールド コードにのみ適用します。'
# 'Apply the profile guided size optimizations only to cold code.'
HFC7E2CE1D9BB: 'プロファイルガイドされたサイズ最適化を、コールド コードにのみ適用します。'
# 'Apply the terminal rule'
HE81B9410B1C9: '終端ルールを適用'
# 'Apply user-directed transformation from metadata'
HC2B25CDB2B7C: 'メタデータからのユーザー指定変換を適用'
# 'Approximately limit number of return registers for replacing out arguments'
H004F37FECEE5: 'アウト引数を置換するための戻り値レジスタの数を概算で制限'
# 'Architecture to generate code for (see --version)'
H3DBAAEAEDF16: 'コードを生成するアーキテクチャ (詳細は --version を参照)'
# 'Argument Register Usage Information Storage'
H5FFD7A67FE89: '引数レジスタ使用情報の格納'
# 'Argument Stack Rebase'
HAB61ED834BD0: '引数スタックのベース再設定'
# 'Argument to pass to the CompilerInvocation'
H3D79343D82D3: 'CompilerInvocation に渡す引数'
# 'Arguments passed onto the interesting-ness test'
H2C80A4DD32DD: '興味の有無テストに渡される引数'
# 'Arm Performance Libraries'
H044D40FECAA8: 'Armパフォーマンス・ライブラリ'
# 'Array subrange.'
HC09EA244D244: '配列のサブレンジ。'
# 'Array.'
H75555184EF20: '配列。'
# 'As secure log file name'
H1E6AE7BB635A: 'セキュア ログ ファイル名として'
# 'As we import functions called from hot callsite, multiply the `import-instr-limit` threshold by this factor before processing newly imported functions'
HFC6F5302C981: 'ホット コール サイトから呼び出された関数をインポートする際に、新しくインポートされた関数を処理する前に、この係数で `import-instr-limit` の閾値を乗じる'
# 'As we import functions, multiply the `import-instr-limit` threshold by this factor before processing newly imported functions'
H807021E7830C: '関数をインポートする際に、新しくインポートされた関数を処理する前に、この係数で `import-instr-limit` の閾値を乗じる'
# 'Asm comments indentation'
HA72479C6AB4B: 'アセンブリコメントのインデント'
# 'Assemble a .s file (default)'
H6369F207FAFB: 'アセンブリファイル (.s) をアセンブル (デフォルト)'
# 'Assembler instructions.'
H66538D7A1ED5: 'アセンブラー命令。'
# 'Assembler line.'
H85B24622E0B1: 'アセンブラー行。'
# 'Assert no nested parallel regions in the GPU'
H418AEEF6FF3F: 'GPU内でネストされた並列領域が存在しないことを保証します'
# 'Assert no thread in a parallel region modifies an ICV'
HBA986658A86D: '並列領域内のスレッドがICVを変更しないことを保証します'
# 'Assert that the compilation takes place in a freestanding environment'
H511BD8C1C674: 'フリース탠ディング環境でコンパイルが行われることを保証します'
# 'Assign reference type allocas to local address space'
H59903DB020B4: '参照型のallocaをローカルアドレス空間に割り当てる'
# 'Assign register bank of generic virtual registers'
H2974E89C9B08: '汎用仮想レジスタのレジスタバンクを割り当てる'
# 'Assign valid PTX names to globals'
HB126730FBD94: 'グローバルに有効なPTX名を割り当てる'
# 'Assignment Tracking Analysis'
H52ADB4784DA7: '割り当て追跡解析'
# 'Assigns WebAssembly register numbers for virtual registers'
H3989AF635266: '仮想レジスタのWebAssemblyレジスタ番号を割り当てる'
# 'Assume SVE vector registers are at least this big, with zero meaning no minimum size is assumed.'
H2E16603634C1: 'SVEベクタレジスタがこれより大きいと仮定します。0は最小サイズを仮定しないことを示します。'
# 'Assume SVE vector registers are at most this big, with zero meaning no maximum size is assumed.'
H9D138AF1C883: 'SVEベクタレジスタがこれより大きくないことを仮定します。0は最大サイズを仮定しないことを示します。'
# 'Assume V extension vector registers are at least this big, with zero meaning no minimum size is assumed. A value of -1 means use Zvl*b extension. This is primarily used to enable autovectorization with fixed width vectors.'
HD680D88BB0DC: 'V拡張ベクタレジスタがこれより大きいと仮定します。0は最小サイズを仮定しない、-1はZvl*b拡張を使用します。主に固定幅ベクターでの自動ベクター化を有効にするために使用されます。'
# 'Assume V extension vector registers are at most this big, with zero meaning no maximum size is assumed.'
H72E88FB1B9F8: 'V拡張ベクタレジスタがこれより大きくないことを仮定します。0は最大サイズを仮定しません。'
# 'Assume all functions may be convergent.'
H4C995A5519E7: 'すべての関数がconvergentであると仮定します。'
# 'Assume all functions with C linkage do not unwind'
H687362EE1CE8: 'Cリンケージを持つすべての関数がアンワインドしないと仮定します'
# 'Assume all non-trivial loops are finite.'
HE8DEA9F53022: '非自明なループが有限であると仮定します'
# 'Assume data segments are relative to text segment'
HDE84E251972D: 'データセグメントがテキストセグメントを基準としていると仮定します'
# 'Assume distributed loops do not have more iterations than participating teams.'
H40EE5717199D: '分散ループが参加チームよりも多くの反復をしないと仮定します'
# 'Assume no atomic operations on fine-grained memory'
H63C989F614F3: '細粒度メモリ上でアトミック操作がないと仮定します'
# 'Assume no atomic operations on remote memory'
H0DEE4D7E8196: 'リモートメモリ上でアトミック操作がないと仮定します'
# "Assume that exception objects' destructors are non-throwing"
HA13DECB16694: '例外オブジェクトのデストラクタは例外を投げないと仮定します'
# 'Assume that execution stops at trap instruction'
HFD7E94900060: 'トラップ命令で実行が停止すると仮定します'
# 'Assume that externally defined data is in the small data if it meets the -G <size> threshold (MIPS)'
H79ED681B6E82: '-G <size> サイズの閾値を満たす場合、外部定義されたデータは小さなデータ領域にあると仮定します（MIPS向け）'
# 'Assume that kernels are launched with uniform block sizes (default true for CUDA/HIP and false otherwise)'
HA763A763DA9A: 'カーネルが一様のブロックサイズで起動されたと仮定します（デフォルトではCUDA/HIPでtrue、それ以外はfalse）'
# 'Assume that no thread in a parallel region will encounter a parallel region.'
HCB2AEFAC7594: '並列領域内のどのスレッドも別の並列領域に遭遇しないと仮定します'
# 'Assume that no thread in a parallel region will modify an ICV.'
HF1302F78B04D: '並列領域内のどのスレッドもICV（Integration Control Variable）を変更しないと仮定します'
# 'Assume that overflowing float-to-int casts are undefined (default)'
HCD9EDFDB1A53: '浮動小数点から整数へのキャストのオーバーフローは未定義と仮定します（デフォルト）'
# 'Assume that the precompiled header is a precompiled preamble covering the first N bytes of the main file'
H9D4E9ACCBF56: 'プリコンパイルドヘッダがメインファイルの最初のNバイトをカバーするプリコンパイルドプレアンブルであると仮定します'
# 'Assume that the product of the two iteration trip counts will never overflow'
HE37E63049A0E: '2つの反復回数の積がオーバーフローしないと仮定します'
# 'Assume that top byte of an address is ignored'
H9BFCB8929B9A: 'アドレスの上位バイトが無視されるとして仮定します'
# 'Assume the input has already undergone ThinLTO function importing and the other pre-optimization pipeline changes.'
H2CA2E2C1C103: '入力がThinLTO関数インポートや事前最適化パイプラインの変更を既に受けたものであると仮定します'
# 'Assume the module is loaded at the specified address'
H85B7A3226995: 'モジュールが指定されたアドレスでロードされていると仮定します'
# 'Assume the non latch exit block to be predictable'
HEBCC8B6F378D: 'ノンラッチ出口ブロックが予測されるとして仮定します'
# 'Assume thread-local variables are defined in the executable'
H9F2FA53E0530: 'スレッド局所変数が実行可能ファイル内で定義されていると仮定します'
# 'Assume work-shared loops do not have more iterations than participating threads.'
HF6F555EC0542: 'ワークシェアードループの反復回数が参加するスレッド数を超えないとして仮定します'
# 'Assumed aligned memory accesses.'
H1F99EB0F5177: 'アライメントされたメモリアクセスが仮定されています'
# 'Assumed extra stack use if there are any variable sized objects (in bytes)'
HC8C97CA4569F: '変数長オブジェクトがある場合の追加スタック使用量（バイト単位）'
# 'Assumed stack use of any external call (in bytes)'
H4EA740EFEAD0: '外部呼び出しのスタック使用量の仮定値（バイト単位）'
# 'Assumption Cache Tracker'
HD200FE62329F: '仮定キャッシュトラッカー'
# 'At top of block or after label'
H305A8BE31E6D: 'ブロックの先頭またはラベルの後'
# 'Attach debug info to a function'
H08A666FD7289: '関数にデバッグ情報を付与する'
# 'Attach debug info to everything'
HED658EC60D0F: 'すべてのものにデバッグ情報を付与する'
# 'Attempt coalescing during PBQP register allocation.'
H7648F369F9C7: 'PBQPレジスタ割り当て中にレジスタ結合を試みる'
# 'Attempt to allocate array temporaries on the stack, no matter their size'
H1898E5AD9AA7: '配列の一時変数をスタック上に配置するように試みる（サイズに関係なく）'
# 'Attempt to drop solution if it is less profitable'
H339D061FB39B: '利益が低い解は破棄するように試みる'
# 'Attempt to match the ABI of Clang <version>'
H0603A0819A4F: 'Clang <version> のABIに一致するように試みる'
# 'Attempt to vectorize for this register size in bits'
HC4E22D3921AE: 'このレジスタサイズ（ビット単位）のベクトル化を試みる'
# 'Attempt to vectorize horizontal reductions'
H7D29B593C54B: '水平削減のベクトル化を試みる'
# 'Attempt to vectorize horizontal reductions feeding into a store'
H86C2FB57AC78: 'ストアに供給される水平削減のベクトル化を試みる'
# 'Attribute Options'
H80A446F5E125: '属性オプション'
# "Attribute all functions' range with zero count even it's not hit by any samples."
H6A8CFBBE8142: 'サンプルでヒットされない場合でも、すべての関数の範囲にゼロカウントの属性を付与する'
# 'Auto-generates preprocessed source files and a reproduction script'
H2B36EB61E3F1: 'プリプロセス済みソースファイルと再現スクリプトを自動生成'
# 'Automatically put hot code on 2MB page(s) (hugify) at runtime. No manual call to hugify is needed in the binary (which is what --hot-text relies on).'
H0155A65DE424: '実行時にホットコードを2MBページ (hugify) に自動配置。バイナリ内でのhugifyの手動コールは不要（--hot-textが依存するのとは異なる）'
# 'Auxiliary target triple.'
H7C66B9F24C8E: '補助ターゲットトリプル'
# 'Average inst/cycle when no target itinerary exists.'
HAC1A1866B355: 'ターゲットのイタineraryがない場合の平均inst/cycle'
# 'Avoid FPU mode dependent operations when used with the O32 ABI'
HFD29595F0062: 'O32 ABIと使用する場合、FPUモード依存の操作を回避'
# 'Avoid logging potentially-sensitive request details'
H7AE408773694: '潜在的に敏感なリクエストの詳細を記録しない'
# 'Avoid optimizing x86 call frames for size'
HEAFF156A02EB: 'x86コールフレームのサイズ最適化を回避'
# 'Avoid translating the elements of DICompositeTypes during the LLVM IR import (discouraged: testing only!)'
H92E0AEF9C7F0: 'LLVM IRのインポート中にDICompositeTypesの要素を翻訳しないでください（非推奨：テスト用のみ！）'
# 'Avoid using scaled registers with vscale-relative addressing'
H9CD1A0FBC370: 'vscale相対アドレス指定とスケーリングレジスタの使用を避ける'
# 'BAT dump options'
HE7548A5409DC: 'BATダンプオプション'
# 'BC Analyzer Options'
H4B23BE663585: 'BCアナライザーオプション'
# 'BOLT - Binary Optimization and Layout Tool\n'
H01223DC88456: 'BOLT - バイナリ最適化とレイアウトツール\n'
# 'BOLT generic options'
H833927334F93: 'BOLT汎用オプション'
# 'BOLT instrumentation options'
H236274761B58: 'BOLTインストルメンテーションオプション'
# 'BOLT optimization options'
HF7FB7C2D71C6: 'BOLT最適化オプション'
# 'BOLT options in relocation mode'
H72F40B1DAEF4: 'BOLTの再配置モードオプション'
# 'BOLTDIFF generic options'
HBCE6535FC79B: 'BOLTDIFF汎用オプション'
# 'BPF Check And Adjust IR'
H4D7204899754: 'BPF IRのチェックと調整'
# 'BPF DAG->DAG Pattern Instruction Selection'
H7C44CC075E35: 'BPF DAG→DAGパターン命令選択'
# 'BPF MachineSSA Peephole Optimization For ZEXT Eliminate'
H1FCC7FDAD7BB: 'ZEXT除去のためのBPF MachineSSAピーヒール最適化'
# 'BPF PreEmit Checking'
H9D3E8CD483F5: 'BPF事前発行チェック'
# 'BPF PreEmit Peephole Optimization'
H9917446E38FB: 'BPF事前発行ピーヒール最適化'
# 'BPF PreEmit SimplifyPatchable'
HD1C3DD579B0E: 'BPF事前発行単純化パッチ可能'
# 'BPF: Disable Avoiding Speculative Code Motion.'
HA01C55FDDABF: 'BPF: 予測コード移動の回避を無効にする'
# 'BPF: Disable Serializing ICMP insns.'
H688F09F03EC9: 'BPF: ICMP命令のシリアル化を無効にする'
# 'Bail out on unprofitable SCoPs before rescheduling'
HD7D2870382BF: '再スケジューリング前に非効率なSCoPsを放棄'
# 'Base Directory for generated documentation.\nURLs will be rooted at this directory for HTML links.'
HD430D315BE29: '生成されたドキュメントの基本ディレクトリ。\nHTMLリンク用のURLはこのディレクトリをルートとして使用します。'
# 'Base Type (int, bool, etc.).'
H7F681232E46A: '基本型（int、boolなど）。'
# 'Base cost of vector insert/extract element'
HA29AACEEF76F: 'ベクタ要素の挿入/抽出の基本コスト'
# 'Base file path for the interactive mode. The incoming filename should have the name <inliner-interactive-channel-base>.in, while the outgoing name should be <inliner-interactive-channel-base>.out'
HED13A1932932: 'インタラクティブ モード用の基本ファイルパス。入力ファイル名は<inliner-interactive-channel-base>.in、出力ファイル名は<inliner-interactive-channel-base>.outにする必要があります'
# 'Base file path for the interactive mode. The incoming filename should have the name <regalloc-evict-interactive-channel-base>.in, while the outgoing name should be <regalloc-evict-interactive-channel-base>.out'
HEEBA85373FA8: 'インタラクティブ モード用の基本ファイルパス。入力ファイル名は<regalloc-evict-interactive-channel-base>.in、出力ファイル名は<regalloc-evict-interactive-channel-base>.outにする必要があります'
# 'Base file path for the interactive mode. The incoming filename should have the name <regalloc-priority-interactive-channel-base>.in, while the outgoing name should be <regalloc-priority-interactive-channel-base>.out'
H9411EE803DAA: 'インタラクティブ モード用の基本ファイルパス。入力ファイル名は<regalloc-priority-interactive-channel-base>.in、出力ファイル名は<regalloc-priority-interactive-channel-base>.outにする必要があります'
# 'Base penalty for splitting cold code (as a multiple of TCC_Basic)'
H9A157E9C325A: 'TCC_Basicの倍数として、cold codeの分割にかかる基本ペナルティ'
# 'Base types (int, bool, etc.).'
H6DA8FED6F2CE: '基本型（int、boolなど）。'
# 'Basic Alias Analysis (stateless AA impl)'
H5B13D0BE4C70: '基本エイリアス分析（stateless AA実装）'
# 'Basic Block Frequency'
H288285DDFDA1: '基本ブロック頻度'
# 'Basic Block Placement Stats'
H907EA5CFB1D6: '基本ブロック配置統計'
# 'Basic Register Allocator'
H79DC6E995B15: '基本レジスタ割り当て器'
# 'Basic algebraic expansions of complex arithmetic operations involving are disabled.'
HDF7A39346B61: '複素数の算術演算を含む基本代数展開が無効化されています。'
# 'Basic algebraic expansions of complex arithmetic operations involving are enabled.'
H262F35B467F4: '複素数の算術演算を含む基本代数展開が有効化されています。'
# 'Basic attributes alias.'
HE45CB3A77EAA: '基本属性エイリアス。'
# 'Basic block limit for a function for RDF optimizations'
H4FCE83C0EE11: 'RDF最適化のための関数の基本ブロック制限'
# 'Basic block.'
H0E36AB3035D5: '基本ブロック。'
# 'Basic register allocator'
HAA9EC9D57F33: '基本レジスタ割り当て器'
# 'Be more conservative in ARM load/store opt'
HDDB9289EB602: 'ARMのロード/ストア最適化でより保守的になる'
# 'Before everything'
HD2BEA8D1D530: 'すべての最初に'
# 'Best scheduler for the target'
H5C9427319FEA: 'ターゲット用の最適なスケジューラ'
# 'Binary encoding'
H2B45E735D11B: 'バイナリエンコーディング'
# 'Binary encoding (default)'
H75E6792272B3: 'バイナリエンコーディング (デフォルト)'
# 'BinaryAnalysis\n'
HC08403F87EF1: 'バイナリ分析\n'
# 'BinaryAnalysis options'
H0030C9E3CDAC: 'バイナリ分析 オプション'
# 'Bit simplification'
HD2769EDD49F1: 'ビット単純化'
# 'Bit size of immediate TLS offsets'
HE94155328C5F: '即時TLSオフセットのビットサイズ'
# 'Bitstream'
HA8A9704FB47E: 'ビットストリーム'
# 'Bitwidth of the index type for the host (warning this should be 64 until the GPU layering is fixed)'
H1A2F700B75FE: 'ホストのインデックスタイプのビット幅（警告：GPUのレイヤリングが修正されるまで64に設定する必要があります）'
# 'Block Frequency Analysis'
H0F710FC006A0: 'ブロック周波数分析'
# 'Block frequency percentage a loop exit block needs over the original exit to be considered the new exit.'
H1B72423F0425: '元の出口ブロックを上回るパーセンテージで、ループ出口ブロックが新しい出口と見なされるブロック周波数の閾値'
# 'Block until the parser can be used'
H1C8FDBE8C1C0: 'パーサーが使用可能になるまでブロックする'
# 'Bottom-up register pressure aware list scheduling which tries to balance ILP and register pressure'
H9D996A6F7F40: 'レジスタ圧力とILPのバランスを考慮した逆順レジスタ圧力配慮リストスケジューリング'
# 'Bottom-up register pressure aware list scheduling which tries to balance latency and register pressure'
H394C581D41AA: 'レジスタ圧力とレイテンシのバランスを考慮した逆順レジスタ圧力配慮リストスケジューリング'
# 'Bottom-up register reduction list scheduling'
H669DA6589497: '逆順レジスタ削減リストスケジューリング'
# 'Bound on stack depth while inlining (4 by default)'
H517AFAFA9D42: 'インライン処理中のスタック深度の上限（デフォルトは4）'
# 'Bound the dependence analysis by a maximal amount of computational steps (0 means no bound)'
H649A261EB1B0: '計算ステップの最大値で依存関係解析を制限（0は制限なしを意味）'
# 'Bound the scheduler by maximal amountof computational steps. '
H51E6C0F8C158: '計算ステップの最大値でスケジューラを制限'
# 'Bound the scop analysis by a maximal amount of computational steps (0 means no bound)'
H82EB650E9442: '計算ステップの最大値でスコープ解析を制限（0は制限なしを意味）'
# 'Branch Coalescing'
H2DBEA167A999: 'ブランチ結合'
# 'Branch Probability'
HC336B7481E8C: 'ブランチ確率'
# 'Branch Probability Analysis'
HE38E9B0A525A: 'ブランチ確率分析'
# 'Branch Probability Basic Block Placement'
H87FA8A5489AA: 'ブランチ確率に基づく基本ブロック配置'
# 'Branch relaxation pass'
H6AFFC7671D8D: 'ブランチ緩和パス'
# 'Break backedge through symbolic execution of 1st iteration attempting to prove that the backedge is never taken'
HE2539A780F40: '最初のイテレーションのシンボリック実行を通じてバックエッジを分解し、バックエッジが取り得ないことを証明を試みる'
# 'Break critical edges in CFG'
HD9D1E732D541: '制御フローグラフのクリティカルエッジを分解'
# 'Break large PHI nodes for DAGISel'
HCF5413A8839F: 'DAGISel用の大規模PHIノードを分解'
# 'Break post-RA scheduling anti-dependencies: "critical", "all", or "none"'
H75472E865DE3: 'RA後のスケジューリングにおけるアンチ依存を分解: "critical", "all", または "none"'
# 'BreakFalseDeps'
H5FF559A5250F: 'BreakFalseDeps'
# 'Breakdown the count by function name taking into consideration the filepath info from the DebugLoc of the remark.'
HC1EFEB5BC743: 'DebugLocのremarkからファイルパス情報を考慮し、関数名別にカウントを分解'
# 'Breakdown the count by function name.'
H55D8DD7267D8: '関数名別にカウントを分解'
# 'Bucket number per loop for PPC loop chain common'
H095EE2A27794: 'PPCループチェーン共通のループごとのバケット数'
# 'Buffer the last N characters of debug output until program termination. [default 0 -- immediate print-out]'
HEA243B6BB971: 'プログラム終了までデバッグ出力の最後のN文字をバッファリング。[デフォルト0 — 即時出力]'
# "BugPoint Test Pass - Intentionally 'misoptimize' CallInsts"
H89AAE42B7AE6: 'BugPointテストパス — CallInstを意図的に誤最適化'
# 'BugPoint Test Pass - Intentionally crash on CallInsts'
HDE32B6B83F4F: 'BugPointテストパス — CallInstで意図的にクラッシュ'
# 'BugPoint Test Pass - Intentionally crash on declared functions'
H42F2EE82DA8D: 'BugPointテストパス — 宣言された関数で意図的にクラッシュ'
# 'BugPoint Test Pass - Intentionally crash on fabs calls with fpmath metadata and an fadd as argument'
H1E926C1BB889: 'fpmathメタデータを持つfabs呼び出しとfadd引数で意図的にクラッシュ'
# "BugPoint Test Pass - Intentionally crash on function attribute 'bugpoint-crash'"
H05C0FF4CFB70: 'BugPointテストパス — function attribute "bugpoint-crash"で意図的にクラッシュ'
# 'BugPoint Test Pass - Intentionally crash on too many CUs'
H8C6E2ED6A47E: 'BugPointテストパス — 多すぎるCUで意図的にクラッシュ'
# 'Build ASTs and convert to LLVM, discarding output'
HFD98A9A1FB1A: 'ASTを構築してLLVMに変換し、出力を破棄'
# 'Build ASTs and print the list of declaration node qualified names'
HCB31A5A33A8E: 'ASTを構築し、宣言ノードの修飾名リストを出力'
# 'Build ASTs and then debug dump their name lookup tables'
HB898C7F894F2: 'AST を構築し、その後その名前検索テーブルをデバッグダンプします'
# 'Build ASTs and then debug dump them'
H7902F2D13330: 'AST を構築し、その後それらをデバッグダンプします'
# 'Build ASTs and then debug dump them in the specified format, forcing deserialization. Supported formats include: default, json'
HE96A00FC958F: 'AST を構築し、その後指定された形式でそれらをデバッグダンプします。逆シリアル化を強制します。サポートされる形式には default、json があります'
# 'Build ASTs and then debug dump them in the specified format. Supported formats include: default, json'
H92BA7F1490EF: 'AST を構築し、その後指定された形式でそれらをデバッグダンプします。サポートされる形式には default、json があります'
# 'Build ASTs and then debug dump them, forcing deserialization'
HEE028C067F24: 'AST を構築し、その後逆シリアル化を強制してそれらをデバッグダンプします'
# 'Build ASTs and then lower to ClangIR'
HDF4F258BFB65: 'AST を構築し、その後 ClangIR に変換します'
# 'Build ASTs and then pretty-print them'
H9599366C5CC9: 'AST を構築し、その後それらを整形表示します'
# 'Build ASTs and view them with GraphViz'
H03B49E6509AA: 'AST を構築し、その後 GraphViz で表示します'
# 'Build ASTs then convert to LLVM, emit .bc file'
H3D999491C902: 'AST を構築し、その後 LLVM に変換し、.bc ファイルを出力します'
# 'Build VPlan for every supported loop nest in the function and bail out right after the build (stress test the VPlan H-CFG construction in the VPlan-native vectorization path).'
HE361DC02BCE3: '関数内のサポートされているすべてのループネストに対して VPlan を構築し、構築直後に終了します（VPlan-native ベクトル化パスにおける VPlan H-CFG の構築をストレステストする）'
# 'Build a C++20 Header Unit from a header'
H9A493A45835C: 'ヘッダから C++20 ヘッダーユニットを構築します'
# 'Build a C++20 Header Unit from a header that should be found in the user (fmodule-header=user) or system (fmodule-header=system) search path.'
H0DC1129B500A: 'ユーザー（fmodule-header=user）またはシステム（fmodule-header=system）検索パスから見つかったヘッダから C++20 ヘッダーユニットを構築します'
# 'Build for HVX v60'
H5F194250AE06: 'HVX v60 用に構築します'
# 'Build for HVX v62'
HAFED34899A8C: 'HVX v62 用に構築します'
# 'Build for HVX v65'
H207B9B2D5225: 'HVX v65 用に構築します'
# 'Build for HVX v66'
HEA3895BB213D: 'HVX v66 用に構築します'
# 'Build for HVX v67'
H42B647301419: 'HVX v67 用に構築します'
# 'Build for HVX v68'
H77FF21179BCC: 'HVX v68 用に構築します'
# 'Build for HVX v69'
H905F9940179D: 'HVX v69 用に構築します'
# 'Build for HVX v71'
H165F94AD0A42: 'HVX v71 用に構築します'
# 'Build for HVX v73'
H67E019A7BE26: 'HVX v73用にビルド'
# 'Build for HVX v75'
HEB883439B283: 'HVX v75用にビルド'
# 'Build for HVX v79'
H231DD2C4D603: 'HVX v79用にビルド'
# 'Build for Hexagon V5'
H1C71E9B94F5C: 'Hexagon V5用にビルド'
# 'Build for Hexagon V55'
H58046BC87A11: 'Hexagon V55用にビルド'
# 'Build for Hexagon V60'
H05D6BD8DE043: 'Hexagon V60用にビルド'
# 'Build for Hexagon V62'
H397E863A80C2: 'Hexagon V62用にビルド'
# 'Build for Hexagon V65'
HD1EC00E09426: 'Hexagon V65用にビルド'
# 'Build for Hexagon V66'
HE5554963D68F: 'Hexagon V66用にビルド'
# 'Build for Hexagon V67'
H87AB7CC8B603: 'Hexagon V67用にビルド'
# 'Build for Hexagon V67T'
HB3C7C60D0839: 'Hexagon V67T用にビルド'
# 'Build for Hexagon V68'
H712B082469B0: 'Hexagon V68用にビルド'
# 'Build for Hexagon V69'
H33FDB62409F4: 'Hexagon V69用にビルド'
# 'Build for Hexagon V71'
HF8AB85CAF9EB: 'Hexagon V71用にビルド'
# 'Build for Hexagon V71T'
H6AC6FBE66236: 'Hexagon V71T用にビルド'
# 'Build for Hexagon V73'
H7840346BDBBB: 'Hexagon V73用にビルド'
# 'Build for Hexagon V75'
HB923BD289BC7: 'Hexagon V75用にビルド'
# 'Build for Hexagon V79'
H860D9669E777: 'Hexagon V79用にビルド'
# 'Build path'
H51B665BD227F: 'ビルドパス'
# 'Build the parse tree, then lower it to FIR'
H5AA5D4111927: 'パースツリーをビルドし、それをFIRに変換する'
# 'Build the parse tree, then lower it to HLFIR'
H209B3028A0CD: 'パース木を構築し、その後それをHLFIRに変換します'
# 'Build this module as a system module. Only used with -emit-module'
HF896829DCA95: 'このモジュールをシステムモジュールとして構築します。-emit-moduleオプションと併用する場合のみ使用されます'
# 'Bundle Machine CFG Edges'
H7815BA6F9789: 'マシンのCFGエッジをバンドル'
# 'Bundle output files of HIP device compilation'
HCA7306204A95: 'HIPデバイスコンパイルの出力ファイルをバンドル'
# 'Burnside Bridge Compiler\n'
H5B149431AA40: 'Burnside Bridge コンパイラ\n'
# 'By default, we analyze the benchmarks for the triple/CPU they were measured for, but if you want to analyze them for some other combination (specified via -mtriple/-mcpu), you can pass this flag.'
H76350EEAD124: 'デフォルトでは、ベンチマークは計測されたtriple/CPUに対して分析しますが、別の組み合わせ（-mtriple/-mcpuオプションで指定）を分析したい場合はこのフラグを指定できます。'
# 'Bypass the profitability model of load slicing'
H3E3A7818BD1C: 'ロードスライシングの利益性モデルをバイパス'
# 'C does not support default arguments'
H9634D9BB0DF6: 'C言語はデフォルト引数をサポートしません'
# 'C requires #line number to be less than %0, allowed as extension'
H2FF7FD761591: 'Cでは#line番号は%0未満でなければなりません。拡張機能として許可されています'
# 'C requires a comma prior to the ellipsis in a variadic function type'
HF2B9DE1954B1: 'Cでは可変長関数タイプでは、ellipsisの前にカンマが必要です'
# "C++ ABI '%0' is not supported on target triple '%1'"
H00336F051C87: "C++ ABI '%0'はターゲットtriple '%1'ではサポートされていません"
# 'C++ ABI to use. This will override the target C++ ABI.'
H9B471B29FD3A: '使用するC++ ABI。これによりターゲットのC++ ABIが上書きされます'
# 'C++ implementation file name'
HE4F416D1C66F: 'C++実装ファイル名'
# 'C++ operator %0 (aka %1) used as a macro name'
H2A2A24E029F0: 'C++演算子%0（別名%1）をマクロ名として使用'
# 'C++ standard library to use'
HEE4D104DB34B: '使用するC++標準ライブラリ'
# 'C++11 only allows consecutive left square brackets when introducing an attribute'
H2040F8CA0C12: 'C++11では属性を導入する際に、連続した左方括弧[]のみを許可します'
# 'C++98 requires an accessible copy constructor for class %2 when binding a reference to a temporary; was %select{private|protected}0'
H89F3A4330FF6: 'C++98では、一時オブジェクトへのリファレンスを束縛する際、クラス%2にはアクセス可能なコピーコンストラクタが必要です。実際は%select{private|protected}0でした'
# 'C99 forbids casting nonscalar type %0 to the same type'
H26E6559D43AC: 'C99では非スカラータイプ%0を同じ型にキャストすることは禁止されています'
# 'C99 forbids conditional expressions with only one void side'
HD3A412BC601A: 'C99では、void型の一方の条件式のみを持つ条件式は禁止されています'
# 'CF object of type %0 is bridged to %1, which is not an Objective-C class'
H41EE49AD057C: 'タイプ%0のCFオブジェクトは、Objective-Cクラスではない%1にブリッジされています'
# 'CFGuard'
H6826B8A9825A: 'CFGuard'
# 'CFI Verify Options'
H72E6B238AC79: 'CFI 検証オプション'
# 'CFString literal is not a string constant'
H89C093890935: 'CFString リテラルは文字列定数ではありません'
# 'CHR considers a branch bias greater than this ratio as biased'
HDF87AB6569F2: 'CHR は、この比率を超えるブランチバイアスをバイアス付きとみなします'
# 'CHR merges a group of N branches/selects where N >= this value'
H5C657F973B2B: 'CHR は、N >= この値である N ブランチ/セレクトのグループをマージします'
# 'CIR module verification error before running CIR-to-CIR passes'
H045DC8C3B34D: 'CIR-to-CIR パスを実行する前の CIR モジュール検証エラー'
# 'CIR-to-CIR transformation failed'
H9F8DAC16F05E: 'CIR-to-CIR 変換に失敗しました'
# 'CL.EXE COMPATIBILITY OPTIONS'
H505EEFB93C8E: 'CL.EXE 互換性オプション'
# 'COFF Symbol RVAs (DEBUG_S_COFF_SYMBOL_RVA subsection)'
HFE26A86E5CFD: 'COFF シンボル RVA (DEBUG_S_COFF_SYMBOL_RVA サブセクション)'
# "CPU '%0' does not support '%1' execution mode"
H489FB3B6F514: "CPU '%0' は '%1' 実行モードをサポートしていません"
# 'CPU list contains duplicate entries; attribute ignored'
H40F374760829: 'CPU リストに重複エントリが含まれています; 属性は無視されます'
# 'CSKY DAG->DAG Pattern Instruction Selection'
H21AAA3835725: 'CSKY DAG->DAG パターン命令選択'
# 'CSKY constant island placement and branch shortening pass'
H1AC93DA4EF44: 'CSKY 定数アイランド配置とブランチ短縮 パス'
# 'CSS stylesheets to extend the default styles.'
H9DE4F76128DB: '既定のスタイルを拡張するための CSS スタイルシート'
# 'CUDA device code does not support va_arg'
H3A59FE235409: 'CUDA デバイス コードは va_arg をサポートしていません'
# 'CUDA device code does not support variadic functions'
H218B98CDADDE: 'CUDA デバイス コードは可変長関数をサポートしていません'
# 'CUDA does not support global %0 for __device__ functions'
H8DC2F94408E4: 'CUDA は __device__ 関数のグローバル %0 をサポートしていません'
# 'CUDA installation path'
H42DE34B3E373: 'CUDA インストールパス'
# 'CUDA offload target is supported only along with --emit-llvm'
H1424A8C5858B: 'CUDA オフロード ターゲットは --emit-llvm と共に使用する必要があります'
# 'CUDA older than 10.0 does not support .alias'
H4BD47BC9C21A: '10.0 より前の CUDA バージョンでは .alias をサポートしていません'
# "CUDA special function '%0' must have scalar return type"
H4386F29D7C1C: "CUDAの特殊関数'%0'はスカラータイプの戻り値を必須です"
# 'CUDA version %0 is only partially supported'
HABB5F3AD45B9: 'CUDAバージョン%0は部分的にサポートされています'
# 'CUDA version%0 is newer than the latest%select{| partially}1 supported version %2'
HC8470F3A3C10: 'CUDAバージョン%0は、サポートされている最新バージョン%2よりも新しい%select{|です}1'
# 'CXX Dump Options'
HEC70FF6EBB76: 'CXXダンプオプション'
# 'CXX Map Options'
H4ACF6390C9B8: 'CXXマップオプション'
# 'Cache Directory'
HBD7A05972161: 'キャッシュディレクトリ'
# 'Calculate the intrinsic cost based only on argument types'
H204B60BE4CD1: 'インラインコストを引数の型のみに基づいて計算する'
# 'Call nonlazybind functions via direct GOT load for Mach-O'
H734541906E0F: 'Mach-Oでnonlazybind関数を直接GOTロード経由で呼び出す'
# 'Call penalty that is applied per callsite when inlining'
HF8A8A3618DB8: 'インライン時に各コールサイトに適用される呼び出しペナルティ'
# 'Call score power (when --split-strategy=cdsplit)'
H657B2E4D7127: '分割戦略cdsplitを使用時におけるコールスコアのべき乗'
# 'Call score scale coefficient (when --split-strategy=cdsplit)'
H3C68D9A52C2C: '分割戦略cdsplitを使用時におけるコールスコアのスケール係数'
# 'Call site block.'
H1A44C6CE10A5: 'コールサイトブロック。'
# 'Call site parameter.'
H13AFDEB70D71: 'コールサイトパラメータ。'
# 'CallGraph Construction'
H59F475A8E976: 'コールグラフ構築'
# 'Can specify at most '
H04A2B40FE103: '最大で指定可能'
# 'Canonicalize Freeze Instructions in Loops'
HA0687B0F1DED: 'ループ内のFreeze命令を標準化'
# 'Canonicalize natural loops'
H36CFB482F86F: '自然なループを標準化'
# 'Capture the number of times a stack was invoked. In flamegraph mode, this count also includes invocations of all callees.'
HC70FACC6E899: 'スタックの呼び出しどきを記録します。フレームグラフモードでは、このカウントにはすべてのサブルーチンの呼び出しどきも含まれます'
# 'Capture the total time spent in an all invocations of a stack.'
H44E274E610C2: 'スタックの全呼び出しにおける総実行時間を記録します'
# 'Causes the backend to crash instead of generating a nop VSX copy'
H3232545B99E1: 'nop VSXコピーを生成する代わりにバックエンドでクラッシュを強制'
# 'Change byte and word instructions to larger sizes'
HEF144CF00477: 'バイトとワードの命令をより大きなサイズに変更'
# 'Change diagnostic formatting to match IDE and command line tools'
H8A6273359475: '診断形式をIDEおよびコマンドラインツールに合わせて変更'
# 'Change indirect jump instructions to inhibit speculation'
H3608CF11CF48: '間接ジャンプ命令をspeculationを抑制するように変更'
# 'Change namespace.'
H43653D361A25: '名前空間を変更'
# 'Change the C++ ABI to returning `this` pointer from constructors and non-deleting destructors. (No effect on Microsoft ABI)'
H33EEEB0B1310: 'C++のABIを、コンストラクタとnon-deletingデストラクタから`this`ポインタを返却するように変更 (Microsoft ABIには影響なし)'
# "Change the greedy register allocator's live range priority calculation to make the AllocationPriority of the register class more important then whether the range is global"
H8D990FD681E2: 'レジスタクラスのAllocationPriorityを、範囲がグローバルかどうかよりも重要なものにするように、貪欲レジスタアロケータの生存範囲の優先度計算を変更'
# 'Change variadic calling convention'
HD4EADD7ABB24: '可変長呼び出し規約を変更'
# 'Check CFA info and insert CFI instructions if needed'
HB1FAB917FF49: 'CFA情報のチェックを行い、必要に応じてCFI命令を挿入'
# 'Check debug info from -debugify'
H8AF6D59AB27A: '-debugifyからデバッグ情報のチェック'
# 'Check debug info from -debugify-function'
HE67C041D8BED: '-debugify-functionからデバッグ情報のチェック'
# 'Check elements integrity.'
HEA4B7C7680A0: '要素の整合性をチェック'
# 'Check floating-point load'
H7623BFCEEC52: '浮動小数点ロードのチェック'
# 'Check floating-point return values'
H59EBDCF68E8C: '浮動小数点戻り値のチェック'
# 'Check floating-point stores'
H27184F67D1D6: '浮動小数点ストアのチェック'
# 'Check for parallel loops'
H86C1DC29F0D4: '並列ループのチェック'
# 'Check for vectorizable loops'
H3CD8604AF754: 'ベクタ化可能なループのチェック'
# 'Check if block frequency is queried for an unknown block for debugging missed BFI updates'
H105B69431A40: '不明なブロックに対してブロック周波数がクエリされた場合の、見逃されたBFI更新のデバッグ用チェック'
# 'Check if input heterogeneous archive is valid in terms of TargetID rules.\n'
HA0A80D536062: '入力の異種アーキビのTargetIDルールに基づく有効性をチェック'
# 'Check module hash using the argument as a string table'
H43F3CCEA9F64: '引数を文字列テーブルとして使用して、モジュールハッシュをチェック'
# 'Check pointer authentication auth/resign failures'
HBEEB7E32E077: 'ポインタ認証のauth/resign失敗をチェック'
# 'Check stack-use-after-scope'
H899C3D082FBF: 'スタックのスコープ外での使用をチェック'
# 'Check that emitted diagnostics match expected-* lines on the corresponding line'
H0CFA18038D08: '対応する行のexpected-*行と診断情報が一致しているかを確認'
# 'Check the input source files from C++20 modules explicitly'
HA2774E416A4F: '明示的にC++20モジュールからの入力ソースファイルを確認'
# 'Chip to use to serialize to cubin.'
H07B7361E60E0: 'CUBINにシリアル化するために使用するチップを選択。'
# 'Choose DWARF debug sections compression:'
H2B65135A807B: '圧縮するDWARFデバッグセクションを選択:'
# 'Choose a file type (not all types are supported by all targets):'
HAA6114F47F11: '選択するファイルタイプ（すべてのターゲットがすべてのタイプをサポートしているわけではありません）：'
# 'Choose an output file type:'
H92BDEF215C75: '出力ファイルタイプを選択：'
# 'Choose analyzer checkers to disable'
H77983530DA75: '無効にする分析チェックャーを選択'
# 'Choose analyzer checkers to enable'
H41B48112BDF6: '有効にする分析チェックャーを選択'
# 'Choose analyzer options to enable'
HCB7427D52FDE: '有効にする分析オプションを選択'
# 'Choose code model'
HA2B6154EBE1C: 'コードモデルを選択'
# 'Choose float ABI type'
HA37D38E85873: 'float ABIタイプを選択'
# 'Choose large data threshold for x86_64 medium code model'
HE1DFA96AAF80: 'x86_64 mediumコードモデルの大きなデータしきい値を選択'
# 'Choose level of diagnostic information'
HD8EA761DDF80: '診断情報のレベルを選択'
# 'Choose relocation model'
HD54EDB40A370: 'リロケーションモデルを選択'
# 'Choose speculation scheme'
HCB6C8E99AC45: '予測スキームを選択'
# 'Choose style of NEON code to emit from AArch64 backend:'
H2D6E1D10E2D8: 'AArch64バックエンドから発行するNEONコードのスタイルを選択：'
# 'Choose the OpenMP library to use:'
HE50F5292F771: '使用するOpenMPライブラリを選択：'
# 'Choose the dynamic linker/loader.'
H10D084FE139A: 'ダイナミックリンカ/ローダを選択。'
# 'Choose the number of compile threads (jit-kind=orc-lazy only)'
H098814BE3E37: '(jit-kind=orc-lazyのみ)コンパイルスレッド数を選択'
# 'Choose the priority mode to use in module inline'
H3DB5A6B44603: 'モジュール内インラインで使用するプライオリティ モードを選択'
# 'Choose the report output format:'
HAA84783D1EFB: 'レポート出力形式を選択:'
# 'Choose the strategy to replace exit value in IndVarSimplify'
H3B106241E759: 'IndVarSimplifyでexit値を置換する戦略を選択'
# 'Choose threading model'
HC20B03302377: 'スレッド モデルを選択'
# 'Choose to use MD5 to represent string in name table (only meaningful for -extbinary)'
H2AF20046DB81: '名前テーブルで文字列をMD5で表すかどうかを選択 (extbinaryオプションのみ有効)'
# 'Choose underlying JIT kind.'
HCA7AB9E73E1E: '基になるJITの種類を選択'
# 'Chunksize to use by the OpenMP runtime calls'
H9BE7E3A1146E: 'OpenMPランタイム呼び出しで使用するチャンクサイズ'
# "Clang permits use of type 'double' regardless pragma if 'cl_khr_fp64' is supported"
H36E837B04A86: "cl_khr_fp64がサポートされている場合、Clangはpragmaを無視して'double'型の使用を許可"
# 'Clang-format options'
H5807AFA36D8E: 'Clangフォーマット オプション'
# 'ClangIR code gen Not Yet Implemented: %0'
HC54E3E6A2065: 'ClangIR コード生成 未実装: %0'
# 'ClangIR code gen Not Yet Implemented: %0: %1'
H56E1FD5A9575: 'ClangIR コード生成 未実装: %0: %1'
# 'ClangIR: Disable MLIR module verifier'
H751870E4D956: 'ClangIR: MLIR モジュール バリデータを無効化'
# 'Class definition format'
HDB879BF08A12: 'クラス定義形式'
# 'Class recursion depth (0=no limit)'
HB9C55ABE5CC8: 'クラス再帰深度 (0=無制限)'
# 'Class sort order'
H85CBA379BBF6: 'クラスのソート順'
# 'Class, Structure or Union.'
H496FA9D4B718: 'クラス、構造体、または共用体。'
# 'Class.'
H148765CD0A8E: 'クラス。'
# 'Cleanup of TFRs/COPYs'
H9B2D2779E91B: 'TFRs/COPYsのクリーンアップ'
# 'Clear call-used registers upon function return (AArch64/x86 only)'
H477A7A2C3A31: '関数リターン時にcall-usedレジスタをクリア (AArch64/x86のみ有効)'
# 'Clear the Clang AST before running backend code generation'
H25C2CBF7F396: 'バックエンド コード生成実行前にClang ASTをクリア'
# 'Clearance between two register writes for inserting XOR to avoid partial register update'
H72C3AC434C02: 'XOR挿入用の2つのレジスタ書き込み間のクリアランス（部分レジスタ更新を回避するため）'
# 'Clone multicolor basic blocks but do not demote cross scopes'
H6C8216BC2E37: 'マルチカラーベーシックブロックを複製するが、クロススコープを降格しない'
# 'Coalesce copies (default=true)'
H8F39652946C0: 'コピーの統合（既定=true）'
# 'Coalesce copies by rescheduling (default=true)'
H0B50CD5328B9: 'リスケジューリングによりコピーを統合（既定=true）'
# 'Coalesce copies on split edges (default=subtarget)'
H9B11258186AA: '分割エッジでのコピーの統合（既定=subtarget）'
# 'Coalesce copies that span blocks (default=subtarget)'
H60E87F9D68CA: 'ブロックをまたぐコピーの統合（既定=subtarget）'
# 'Code and read-only data relocatable, accessed PC-relative'
H7787A55DE1DB: 'コードと読み取り専用データは再配置可能、PC相対でアクセス'
# 'Code growth limit for address mode optimization'
H68CE7F106A6D: 'アドレスモード最適化のためのコード増加制限'
# 'Code sinking'
H7049DF5F2CFA: 'コードシンキング'
# 'Code size'
H555486354DDF: 'コードサイズ'
# 'Code size and latency'
H66FA420C1EB1: 'コードサイズとレイテンシ'
# 'CodeGen (expected to match llc)'
HD2FDC55840F0: 'CodeGen（llcと一致する必要があります）'
# "Codegen optimization level (0, 1, 2 or 3, default = '2')"
H0604F43896B4: "Codegenの最適化レベル（0、1、2、または3、既定='2'）"
# 'Collect access count histograms'
HEFDB6DB25681: 'アクセスカウントヒストグラムの収集'
# 'Collect control flow of function'
HECF6D002A2F5: '関数の制御フローを収集'
# 'Collect probability-driven block placement stats'
H3B3A74A7C1CA: '確率駆動型ブロック配置の統計を収集'
# "Collect these seeds. Use empty for none or a comma-separated list of '"
H6FDC6608AD13: 'これらのシードを収集します。空文字列で無しを指定、またはカンマ区切りリストを使用します"'
# 'Collects information ahead of time for MC lowering'
H247A53130B24: 'MCの低階層化のための情報を事前収集'
# 'Color Options'
HF1A7AFA23440: '色のオプション'
# 'Color for dot-cfg after elements'
HE6BC004D0C08: '要素後のdot-cfgの色'
# 'Color for dot-cfg before elements'
HCBAF257C085C: '要素の前のdot-cfgの色'
# 'Color for dot-cfg common elements'
H49F473D0D7F3: 'dot-cfgの共通要素の色'
# 'Colored disassembly of strings of hex bytes'
H4E6D0548B4D8: '色付けされた16進バイトの文字列のディスアセンブリ'
# 'Combination of ropi and rwpi'
HFA6236DECFF7: 'ropiとrwpiの組み合わせ'
# 'Combine AArch64 MachineInstrs after legalization'
HD7E343321E16: 'legalization 後のAArch64 MachineInstrsの統合'
# 'Combine AArch64 machine instrs before legalization'
H4D22AAB36024: 'legalization 前のAArch64 machine instrsの統合'
# 'Combine AMDGPU machine instrs after legalization'
H2FD87CC8B39B: 'legalization 後のAMDGPU machine instrsの統合'
# 'Combine AMDGPU machine instrs after regbankselect'
H372E81B03355: 'regbankselect 後のAMDGPU machine instrsの統合'
# 'Combine AMDGPU machine instrs before legalization'
H6682D3768EA0: 'legalization 前のAMDGPU machine instrsの統合'
# 'Combine Mips machine instrs after legalization'
HA03CAB5DCA3D: 'legalization 後のMips machine instrsの統合'
# 'Combine Mips machine instrs before legalization'
H7EFE7A48A439: 'legalization 前のMips machine instrsの統合'
# 'Combine RISC-V MachineInstrs after legalization'
H4BDB10B3DC9C: 'legalization 後のRISC-V MachineInstrsの統合'
# 'Combine RISC-V machine instrs before legalization'
H358426A68073: 'legalization 前のRISC-V machine instrsの統合'
# 'Combine SPIRV machine instrs before legalization'
H7E2252FE6075: 'legalization 前のSPIRV machine instrsの統合'
# 'Combine ext and trunc to TBL'
H8DCB8DB3D191: 'extとtruncをTBLに統合'
# 'Combine extends of AArch64 masked gather intrinsics'
HF9B54CB5AC6B: 'AArch64のmasked gather intrinsicの拡張の統合'
# 'Combine interleaved loads into wide loads and shufflevector instructions'
HC7C7ED4923BB: 'インターリーブされたロードをワイドロードとshufflevector命令に統合'
# 'Combine redundant instructions'
H6A7B591C5F01: '冗長な命令の統合'
# 'Combine the label of the offset with the label of the pointer when doing pointer arithmetic.'
HB7BD5BAE0A94: 'ポインタ算術を行う際、オフセットのラベルをポインタのラベルと統合する'
# 'Combine the label of the pointer with the label of the data when loading from memory.'
H4B6E43BF4FF7: 'メモリからロードする際に、ポインタのラベルをデータのラベルと統合する'
# 'Combine the label of the pointer with the label of the data when storing in memory.'
H66A9D747B5EF: 'メモリに格納する際に、ポインターのラベルをデータのラベルと組み合わせます。'
# 'Comma separated list of attribute names that are allowed to be seeded.'
H725610B9DAC4: 'シーダとして許可される属性名のコンマ区切りリスト。'
# 'Comma separated list of debug counter skip and count'
H9FAFDA93ACE1: 'デバッグ・カウンタのskipとcountのコンマ区切りリスト。'
# 'Comma separated list of debug counter skip and count arguments'
H6FCA88B30FCF: 'デバッグ・カウンタのskipとcountの引数のコンマ区切りリスト。'
# 'Comma separated list of files containing a new line separated list of API symbols to ignore when extracting API information.'
H4521BA006280: 'API情報の抽出時に無視するAPIシンボルの一覧を含むファイルのコンマ区切りリスト（各行区切り）。'
# 'Comma separated list of function names that are allowed to be seeded.'
HD18F456FDFD5: 'シーダとして許可される関数名のコンマ区切りリスト。'
# 'Comma separated list of functions to replace with native, or all'
HFF9C64BB9821: 'ネイティブまたはallで置き換える関数のコンマ区切りリスト。'
# 'Comma separated list of globs for white-listing gcc-compatible drivers that are safe to execute. Drivers matching any of these globs will be used to extract system includes. e.g. /usr/bin/**/clang-*,/path/to/repo/**/g++-*'
H454E7FBEF67B: 'セーフに実行可能なgcc互換ドライバをホワイトリストとするglobsのコンマ区切りリスト。これらのglobsに一致するドライバはシステムインクルードを抽出するために使用されます。例: /usr/bin/**/clang-*,/path/to/repo/**/g++-*'
# 'Comma separated list of locations to filter actions from logging'
H089CBD249A00: 'ログからアクションをフィルタするための場所のコンマ区切りリスト。'
# "Comma-separated list of comment prefixes to use from check file\n(defaults to 'COM,RUN'). Please avoid using this feature in\nLLVM's LIT-based test suites, which should be easier to\nmaintain if they all follow a consistent comment style. This\nfeature is meant for non-LIT test suites using FileCheck."
H40AA0BE08629: 'チェックファイルで使用するコメントプレフィックスのコンマ区切りリスト（デフォルトは"COM,RUN"）。この機能はLLVMのLITベースのテストスイートで使用を避けてください。一貫したコメントスタイルを採用すると維持が容易になります。この機能はFileCheckを使用する非LITテストスイート向けです。'
# "Comma-separated list of globs describing the list of callbacks to output. Globs are processed in order of appearance. Globs with the '-' prefix remove callbacks from the set. e.g. '*,-Macro*'."
HB2EA0F3C4C38: '出力対象のコールバックを説明するglobsのコンマ区切りリスト。globsは出現順に処理されます。"-"プレフィックスのglobsはコールバックをセットから除去します。例: "*,-Macro*"'
# 'Comma-separated list of vectorizer passes. If not set we run the predefined pipeline.'
H5F9267E8F02A: 'ベクター化のパスのコンマ区切りリスト。設定されていない場合は事前定義されたパイプラインが実行されます。'
# 'Command line options to pass to the downstream compiler.'
H24FC3F9175A2: 'ダウンストリームコンパイラに渡すコマンドラインオプション。'
# 'Command to compile the bitcode (use with -compile-custom) (default: llc)'
H3748E1E74688: 'ビットコードをコンパイルするコマンド（-compile-customと併用）（デフォルト: llc）'
# 'Command to execute and then exit.'
H9D395E8BC35F: 'ビットコードを実行して終了するコマンド。'
# 'Command to execute the bitcode (use with -run-custom) (default: simulate)'
H8B8E553AB463: 'ビットコードを実行するコマンド（-run-customと併用）（デフォルト: simulate）'
# 'CommonOptionsParser: failed to parse command-line arguments. '
H6D048D13358D: 'CommonOptionsParser: コマンドライン引数の解析に失敗しました。'
# 'Compare Options'
H10812CD37717: '比較オプション'
# 'Compare all elements.'
HD1160DBAE7C6: 'すべての要素を比較します。'
# 'Compare bits 62 and 61 of address (TBI should be disabled)'
HC1881DEFBF5A: 'アドレスの62ビットと61ビットを比較（TBIは無効にする必要があります）。'
# 'Compare with the result of XPAC (requires Armv8.3-a)'
HBA5A269FECBF: 'XPAC の結果と比較（Armv8.3-aが必要です）'
# 'Compare with the result of XPACLRI'
HAAF036306B3E: 'XPACLRI の結果と比較'
# 'Compilation YAML databases containing additional compilation information for .pdll files'
HE9807E72350C: 'コンパイル用の YAML データベース（.pdll ファイルの追加コンパイル情報が含まれます）'
# 'Compilation YAML databases containing additional compilation information for .td files'
HFBD096AE492B: 'コンパイル用の YAML データベース（.td ファイルの追加コンパイル情報が含まれます）'
# 'Compilation format to use to serialize to cubin.'
HB1FF55993026: 'cubin にシリアル化するために使用するコンパイル形式。'
# 'Compile CUDA code for both host and device (default). Has no effect on non-CUDA compilations.'
H77D43CB7BF77: 'CUDA コードをホストとデバイスの両方用にコンパイル（デフォルト）。CUDA でないコンパイルには影響しません。'
# 'Compile CUDA code for device only'
H15DCB9A13744: 'CUDA コードをデバイス専用にコンパイル'
# 'Compile CUDA code for host only. Has no effect on non-CUDA compilations.'
H0F42A4E8A53F: 'CUDA コードをホスト専用にコンパイル（CUDA でないコンパイルには影響しません）'
# 'Compile HIP source to relocatable'
HDC4174A29E78: 'HIP ソースを再配置可能な形式にコンパイル'
# 'Compile SYCL code for device only'
HC13E70999744: 'SYCL コードをデバイス専用にコンパイル'
# 'Compile SYCL code for host only. Has no effect on non-SYCL compilations'
HEB697C17E8BD: 'SYCL コードをホスト専用にコンパイル（SYCL でないコンパイルには影響しません）'
# "Compile all functions that don't use floating point as Mips 16"
H5CC84DC9C7B5: '浮動小数点を使用しないすべての関数を Mips 16 としてコンパイル'
# 'Compile common globals like normal definitions'
HD71FBB30E436: '共通グローバルを通常の定義のようにコンパイル'
# 'Compile for both the offloading host and device (default).'
H9A1D25E1163E: 'オフローディング ホストとデバイスの両方用にコンパイル（デフォルト）。'
# 'Compile only'
H8E8E6B258925: 'コンパイルのみ'
# 'Compile unit.'
HD0B9CF45B690: 'コンパイル単位。'
# 'Compile with LLC'
H0F009B4F1879: 'LLC を使用してコンパイル'
# 'Compile with LLC with integrated assembler'
HEC7B02DFBAC4: '統合アッセンブラー付き LLC を使用してコンパイル'
# 'Compiler generated elements.'
HCD76E8AFE5EE: 'コンパイラ生成要素。'
# 'Compiler runtime library to use'
H8A88FADF9B7C: '使用するコンパイラ ランタイム ライブラリ'
# 'Complex Deinterleaving'
H7404ACD7E023: '複雑なデインタレーブ'
# 'Compress all sections when writing the profile (only meaningful for -extbinary)'
HCB671C4254BD: 'プロファイルを書き込む際にすべてのセクションを圧縮（-extbinaryでのみ意味があります）'
# 'Compress offload device binaries (HIP only)'
H500BC9AF0B40: 'オフロードデバイスバイナリを圧縮（HIPのみ）'
# 'Compress output file when bundling.\n'
HFEA3EDE7947A: 'バンドルする際に出力ファイルを圧縮。\n'
# 'Compressing recursion by deduplicating adjacent frame sequences up to the specified size. -1 means no size limit.'
H30029AFB7F05: '指定されたサイズまでの隣接するフレームシーケンスの重複を除去して再帰を圧縮します。-1はサイズ制限なしを意味します。'
# 'Compression level for offload device binaries (HIP only)'
HAD420748A1D9: 'オフロードデバイスバイナリの圧縮レベル（HIPのみ）'
# 'Compute and report stale profile statistical metrics.'
H8415583C1A20: '古いプロファイルの統計メトリクスを計算して報告します。'
# "Compute and store the hash of input files used to build an AST. Files with mismatching mtime's are considered valid if both contents is identical"
H9585117CC641: 'ASTを構築するために使用される入力ファイルのハッシュを計算して格納します。mtimeが一致しないファイルでも、内容が同一であれば有効と見なします'
# 'Compute dead symbols'
H06FD59310A4C: '死活シンボルを計算'
# 'Compute known content of array elements'
HF867A4592891: '配列要素の既知の内容を計算'
# 'Compute mean of all readings'
H8282EDF1CC14: 'すべての読み取り値の平均を計算'
# 'Compute stale profile statistical metrics and write it into the native object file(.llvm_stats section).'
H2211EA0D1BE2: '古いプロファイルの統計メトリクスを計算し、ネイティブオブジェクトファイル(.llvm_statsセクション)に書き込みます。'
# 'Compute the full inline cost of a call site even when the cost exceeds the threshold.'
HF635A2D8BE0B: 'インラインコストの閾値を超える場合でも、呼び出しサイトの完全なインラインコストを計算します。'
# 'Conditions to use when printing elements.'
H57BD843032A5: '要素を表示する際の条件。'
# 'Configure the polly loop optimizer'
H40019CBBC00E: 'ポーリーのループ最適化を設定'
# 'Connect to an out-of-process executor through a TCP socket'
H89D591EB992E: 'TCPソケットを通じてプロセス外の実行エンジンに接続'
# 'Connect to an out-of-process executor via TCP'
H84FC6B32A5A3: 'TCPを介してプロセス外の実行エンジンに接続'
# 'Consider R1 caller preserved so stack saves of caller preserved registers can be LICM candidates'
H7A2CC0A44257: 'R1の呼び出し元が保持されているため、呼び出し元の保持レジスタのスタック保存がLICM候補になるように考慮'
# 'Consider a profile matches a function if the similarity of their callee sequences is above the specified percentile.'
HE02A66F58798: '指定のパーセンタイルを超える呼び出しシーケンスの類似度を持つプロファイルが関数と一致すると判定'
# 'Consider all leaf descendants of internal nodes of the suffix tree as candidates for outlining (if false, only leaf children are considered)'
HCFBF788CDF8F: 'サフィックスツリーの内部ノードのすべての葉の子孫をアウトライン化の候補と考慮（falseの場合、葉の子だけが考慮されます）'
# 'Consider calls to be predicable'
HF4AE01562CCA: 'コールを予測可能であるものとみなす'
# 'Constant Hoisting'
HA20E9E7B7D12: '定数持ち上げ'
# 'Constant specifier.'
H27C86387B88E: '定数修飾子。'
# 'Constant.'
H69328F1434C8: '定数。'
# 'Context sensitive profile file path'
H6AAD89B511B3: 'コンテキスト依存のプロファイルファイルのパス'
# 'Contiguously Lay Out Funclets'
H35F4CF635E0B: 'Funcletsを連続的に配置'
# 'Continue if files are not mapped correctly.'
H0AB9362D475E: 'ファイルが正しくマッピングされていない場合にも継続する'
# 'Control Flow Optimizer'
H072A594766A3: '制御フロー最適化'
# 'Control conversion of memcpy to Tail predicated loops (WLSTP)'
HE778B3B33793: 'memcpyをテール予測ループ（WLSTP）に変換する制御（デフォルト有効）'
# 'Control emission of Swift async extended frame info'
H02D3442EBA23: 'Swift非同期拡張フレーム情報の出力制御'
# "Control how the assembler should align branches with NOP. If the boundary's size is not 0, it should be a power of 2 and no less than 32. Branches will be aligned to prevent from being across or against the boundary of specified size. The default value 0 does not align branches."
H8B5A4A325A23: 'アセンブラがNOPで分岐を整列させる方法を制御します。境界サイズが0でない場合は、32以上で2の累乗数である必要があります。分岐を一致させて、指定されたサイズの境界をまたがったり逆らったりしないようにします。デフォルトの0は分岐を整列しません。'
# 'Control jump table emission on Hexagon target'
H6602FAB1D723: 'Hexagonターゲットでのジャンプテーブル出力制御'
# 'Control lookup table emission on Hexagon target'
HAAA735B3BA36: 'Hexagonターゲットでのルックアップテーブル出力制御'
# 'Control the CR-bit tracking feature on PowerPC. ``-mcrbits`` (the enablement of CR-bit tracking support) is the default for POWER8 and above, as well as for all other CPUs when optimization is applied (-O2 and above).'
H81C5A0E206B5: 'PowerPCにおけるCRビット追跡機能を制御します。``-mcrbits``（CRビット追跡サポートの有効化）はデフォルトでPOWER8以降、および最適化オプション（-O2以上）が指定された他のCPUで有効になります。'
# 'Control the amount of inlining in pre-instrumentation inliner (default = 75)'
H601514BCD01B: 'インストルメンテーション前のインライン化の量を制御します（デフォルト = 75）'
# 'Control the amount of inlining to perform (default = 225)'
H54F72241070E: 'インライン化の実行量を制御します（デフォルト = 225）'
# 'Control the amount of phi node folding to perform (default = 2)'
H27887A938BFF: 'φノードの折り畳み実行量を制御します（デフォルト = 2）'
# 'Control the maximal conditional load/store that we are willing to speculatively execute to eliminate conditional branch (default = 6)'
HEA5F4A80FEFE: '条件付きロード/ストアの最大範囲を指定して、条件分岐を排除するための推測実行を制御します（デフォルト = 6）'
# 'Control the maximal total instruction cost that we are willing to speculatively execute to fold a 2-entry PHI node into a select (default = 4)'
H57D2DDD9FD2C: '2エントリφノードをselectに折り込むために推測実行する最大命令コストを指定（デフォルト = 4）'
# 'Control the number of bonus instructions (default = 1)'
H7BC9F590620F: 'ボーナス命令数を制御します（デフォルト = 1）'
# 'Control the rules which are enabled. These options all take a comma separated list of rules to disable and may be specified by number or number range (e.g. 1-10).'
H7704451C821B: '有効なルールを制御します。これらのオプションはすべて、無効にするルールのカンマ区切りリストを指定し、番号または番号範囲（例: 1-10）で指定できます。'
# 'Control the use of vectorisation using tail-folding for SVE where the option is specified in the form (Initial)[+(Flag1|Flag2|...)]:\ndisabled      (Initial) No loop types will vectorize using tail-folding\ndefault       (Initial) Uses the default tail-folding settings for the target CPU\nall           (Initial) All legal loop types will vectorize using tail-folding\nsimple        (Initial) Use tail-folding for simple loops (not reductions or recurrences)\nreductions    Use tail-folding for loops containing reductions\nnoreductions  Inverse of above\nrecurrences   Use tail-folding for loops containing fixed order recurrences\nnorecurrences Inverse of above\nreverse       Use tail-folding for loops requiring reversed predicates\nnoreverse     Inverse of above'
H48B9B6BA5047: 'SVEにおけるtail-foldingを用いたベクトル化の使用を制御します。オプションは(Initialized)[+(Flag1|Flag2|...)]: の形式で指定します:\ndisabled      (初期値) tail-foldingを使用したループタイプのベクトル化は無効\ndefault       (初期値) ターゲットCPUのデフォルトのtail-folding設定を使用\nall           (初期値) 法的すべてのループタイプでtail-foldingを使用したベクトル化を有効\nsimple        (初期値) 簡単なループ（還元または再帰を含まないもの）に対してtail-foldingを使用\nreductions    還元を含むループに対してtail-foldingを使用\nnoreductions  上記の逆\nrecurrences   一定の順序を伴う再帰ループに対してtail-foldingを使用\nnorecurrences 上記の逆\nreverse       逆転した述語を必要とするループに対してtail-foldingを使用\nnoreverse     上記の逆'
# "Control use of approximate reciprocal and reciprocal square root instructions followed by <n> iterations of Newton-Raphson refinement. <value> = ( ['!'] ['vec-'] ('rcp'|'sqrt') [('h'|'s'|'d')] [':'<n>] ) | 'all' | 'default' | 'none'"
HC7E65C6B3833: "近似逆数と逆平方根命令に続くニュートン・ラフソン法の反復回数<n>を制御します。<value> = ( ['!'] ['vec-'] ('rcp'|'sqrt') [('h'|'s'|'d')] [':'<n>] ) | 'all' | 'default' | 'none'"
# 'Control vtordisp placement'
HE1318392829D: 'vtordispの配置を制御します'
# 'Control vtordisp placement on win32 targets'
H1B28D470DA9E: 'win32ターゲットでのvtordisp配置を制御します'
# "Control where files for distributed backends are created. Expects 'oldprefix;newprefix' and if path prefix of output file is oldprefix it will be replaced with newprefix."
HC0263D605A37: '分散バックエンド用のファイルの作成場所を制御します。「oldprefix;newprefix」の形式で指定し、出力ファイルのパスプレフィックスがoldprefixの場合、newprefixに置換されます。'
# 'Control whether the compiler can use scalable vectors to vectorize a loop'
H6A90BC2050A3: 'ループのベクトル化でスケーラブルベクターを使用できるようにするかを制御します'
# 'Control whether unstable and experimental library features are enabled. This option enables various library features that are either experimental (also known as TSes), or have been but are not stable yet in the selected Standard Library implementation. It is not recommended to use this option in production code, since neither ABI nor API stability are guaranteed. This is intended to provide a preview of features that will ship in the future for experimentation purposes'
H292802AB79DD: '不安定かつ実験的なライブラリ機能を有効にするかを制御します。このオプションは、実験的（TSと呼ばれるものも含む）または選択された標準ライブラリ実装で安定していない機能を有効にします。本番コードでこのオプションを使用することは推奨されません（ABI/APIの安定性は保証されません）。これは、今後のリリースで提供される機能のプレビューを実験目的で提供するためのものです'
# 'Controls Negator transformations in InstCombine pass'
H08542ADEE520: 'InstCombineパスでのNegator変換を制御します'
# 'Controls how scalar integer arguments are extended in calls to unprototyped and varargs functions'
H7A8FE1AC1071: 'プロトタイプなし関数および可変長引数関数へのスカラ整数引数の拡張方法を制御します'
# 'Controls the backend parallelism of -flto=thin (default of 0 means the number of threads will be derived from the number of CPUs detected)'
H6966D13FD63C: '-flto=thinのバックエンド並列性を制御します（0のデフォルトは検出されたCPU数に基づいてスレッド数を決定します）'
# 'Controls the semantics of floating-point calculations.'
H71E38C97DF72: '浮動小数点計算のセマンティクスを制御します'
# 'Controls transformations in div-rem-pairs pass'
HECF2FCF96025: 'div-rem-pairsパスでのトランスフォームを制御します'
# 'Controls transformations in partially-inline-libcalls'
HD0E8FE10DABD: 'partially-inline-libcallsでのトランスフォームを制御します'
# 'Controls whether PPC per opcode peephole is performed on a MI'
HE5F923C4F31C: 'MI上でPPC perオペコードのpeephole最適化を実行するかを制御します'
# 'Controls whether PPC reg+reg to reg+imm peephole is performed on a MI'
HE845FFE9D736: 'MI上でreg+reg to reg+immのpeephole最適化を実行するかを制御します'
# 'Controls whether a DAG combine is performed for a node'
H093B59DCA1FC: 'ノードに対するDAGコンビン合併を実行するかを制御します'
# 'Controls whether rewriteCandidateWithBasis is executed.'
H07C470C4B05C: 'rewriteCandidateWithBasisを実行するかを制御します'
# 'Controls whether to select function with GlobalISel'
HBD7BF3862B9C: 'GlobalISelを使用して関数を選択するかを制御します'
# 'Controls which MemoryDefs are eliminated.'
H791CB4538D1F: '削除対象のMemoryDefsを制御します'
# 'Controls which SLP graphs should be vectorized.'
H3651F2112EDB: 'ベクター化すべきSLPグラフを制御します。'
# 'Controls which assumes gets created'
HC60E96036F48: '作成されるassumesを制御します'
# 'Controls which checks to insert'
H85AB8C69F0A9: '挿入するチェックを制御します'
# 'Controls which conditions are eliminated'
HCCAC8F989163: '省略する条件を制御します'
# 'Controls which instruction to instrument'
HC782D790D691: 'instrumentする命令を制御します'
# 'Controls which instructions are eliminated'
H11684921476B: '省略する命令を制御します'
# 'Controls which instructions are removed'
HAA6FE4D6ECC8: '削除する命令を制御します'
# 'Controls which instructions are value numbered'
HB785D2555BC9: '値番号付けされる命令を制御します'
# 'Controls which instructions are visited'
H636F2545BF3D: '探索対象の命令を制御します'
# 'Controls which instructions we create phi of ops for'
HE27BA11ED3BE: 'phiのオペランドとして作成する変数を制御します'
# 'Controls which pairs are considered for renaming'
HD4F491A48E58: 'リネーム対象のペアを制御します'
# 'Controls which register COPYs are forwarded'
H3AAE7A42C897: 'フォワーディングされるレジスタCOPYを制御します'
# 'Controls which tag collisions are avoided'
H425F30EA7D35: '回避するタグの衝突を制御します'
# 'Controls which variables C++ static destructors are registered for'
HBD9C8A005FBD: 'C++静的デストラクタを登録する変数を制御します'
# 'Controls which variables are renamed with predicateinfo'
H64B5B42BA3C1: 'predicateinfoによるリネーム対象の変数を制御します'
# 'Conventional ABI instrumentation for sanitizer runtime. Default: Conventional'
HAE6876018E56: 'Sanitizerランタイム用の従来のABIインストルメンテーション。デフォルト: Conventional'
# 'Convert align attributes to assumptions during inlining.'
H3BBD1D4AD52A: 'インライン時にalign属性をassumptionに変換します。'
# 'Convert all cmovs to branches.'
HC3FD80CE54EF: 'すべてのcmovを分岐命令に変換します。'
# 'Convert available_externally into locals, renaming them to avoid link-time clashes.'
H719EAE04A8AC: 'available_externallyをローカルに変換し、リンク時衝突を避けるために名前を変更します。'
# 'Convert cmovs to branches whenever they have memory operands.'
HF77C545DF219: 'メモリオペランドを持つcmovを分岐に変換します。'
# 'Convert eligible reg+reg instructions to reg+imm'
HC9D049FFF42E: '該当するreg+reg命令をreg+immに変換します'
# 'Convert i1 constants to i32/i64 if they are returned'
HB5295C482B89: '戻り値として返されるi1定数をi32/i64に変換します'
# 'Convert irreducible control-flow into natural loops'
HE7DC2EC0D50F: '非簡約的制御フローを自然なループに変換します'
# 'Convert noalias attributes to metadata during inlining.'
H693AF480BD18: 'インライン処理中にnoalias属性をメタデータに変換します'
# 'Convert registers to WebAssembly locals'
H42DF7CAF4C71: 'レジスタをWebAssemblyのローカルに変換します'
# 'Convert switches into an integer range comparison (default = false)'
HDCDA8562FA9F: 'switch文を整数範囲比較に変換します（デフォルト=false）'
# 'Convert switches to lookup tables (default = false)'
H5FE1320AA9A1: 'switch文をルックアップテーブルに変換します（デフォルト=false）'
# 'Convert the generated profile to a profile with a new layout'
H7167152F0FAC: '生成されたプロファイルを新しいレイアウトのプロファイルに変換します'
# 'Cost for first time use of callee-saved register.'
H378B86E985E0: 'callee-saved レジスタの最初の使用時のコスト'
# 'Cost multiplier to multiply onto inlined call sites where the new call was previously an intra-SCC call (not relevant when the original call was already intra-SCC). This can accumulate over multiple inlinings (e.g. if a call site already had a cost multiplier and one of its inlined calls was also subject to this, the inlined call would have the original multiplier multiplied by intra-scc-cost-multiplier). This is to prevent tons of inlining through a child SCC which can cause terrible compile times'
H698CAA7A18F5: '関数内SCCコールであった場合のインライン化されたコールサイトに適用されるコスト乗数（元のコールが既にintra-SCCだった場合は無関係です）。複数のインライン処理で積算されます（例：コールサイトに既にコスト乗数があり、そのインラインされたコールの一つがこれに該当する場合、インラインコールには元の乗数にintra-scc-cost-multiplierを乗算されます）。これにより、子SCCを通じた過剰なインライン化による長大なコンパイル時間を防ぐためです'
# 'Cost of a single instruction when inlining'
H036B559D08B8: 'インライン処理時の単一命令のコスト'
# 'Cost of alloca argument'
HC1E9D60217AE: 'alloca引数のコスト'
# 'Cost of jump instructions.'
H7ED2E2DD5641: 'ジャンプ命令のコスト'
# 'Cost of load/store instruction when inlining'
H4C8BA9CE961B: 'インライン処理時のロード/ストア命令のコスト'
# 'Cost penalty for blocks that can avoid breaking CFG by copying. Copying can increase fallthrough, but it also increases icache pressure. This parameter controls the penalty to account for that. Percent as integer.'
HC9F72F77D39D: 'ブロックがコピーによりCFGの破壊を回避できる場合のペナルティコスト。コピーはフォールスルーを増加させますが、同時にicacheの負荷も増加します。このパラメータはそのペナルティを制御します。整数値でパーセント指定'
# 'Cost that models the probabilistic risk of an instruction misfetch due to a jump comparing to falling through, whose cost is zero.'
H84CCB8356D8E: 'ジャンプ命令による命令フェッチミスの確率的リスクをモデル化したコスト（フォールスルー時のコストは0）'
# 'Costing strategy for intrinsic instructions'
H8D22576D5E28: '組み込み命令のコスト計算戦略'
# 'Count statements with scalar accesses as not optimizable'
H20E33614C70B: 'スカラーアクセスを伴う文を最適化不可能とカウント'
# 'Count the induction variable only once when interleaving'
HDCB004AC534E: '織り交ぜる際に誘導変数を1回のみカウント'
# 'Counts based on the value each specified argument has. The argument has to have a number value to be considered.'
HE174F4DEB8D5: '指定された各引数の値に基づいたカウント。考慮には引数が数値を保持している必要があります'
# 'Counts individual remarks based on how many of the remark exists.'
H16283CDE8F40: '個々のリマインダーを、そのリマインダーが存在する数に基づいてカウントします。'
# 'Coverage executable or object file'
H2B8E5F52400C: 'カバレッジ実行可能ファイルまたはオブジェクトファイル'
# 'Covered executable or object file.'
H20476C00EDC5: 'カバレッジ測定済みの実行可能ファイルまたはオブジェクトファイル。'
# 'Create DLL'
H8F2F15C96BC4: 'DLLを作成する'
# 'Create Garbage Collector Module Metadata'
H7493F37F2CB6: 'ガベージコレクターモジュールのメタデータを作成する'
# 'Create a copy of byval function arguments early.'
HFD4F400F3DC5: 'byval関数引数のコピーを早期に作成する。'
# 'Create a dot file of CFGs with block coverage inference information'
HEAFA159C65C9: 'ブロックカバレッジ推論情報付きのCFGのdotファイルを作成する'
# 'Create a table of coverage-instrumented PCs'
HE002CE3DC7B7: 'カバレッジ測定済みPCのテーブルを作成する'
# 'Create a website with graphical changes'
H01E9364CFCA0: 'グラフィカルな変更を含むウェブサイトを作成する'
# 'Create a website with graphical changes in quiet mode'
H70CA1F4FAB9C: '静穏モードでグラフィカルな変更を含むウェブサイトを作成する'
# 'Create cfi directives that assume the code might be more than 2gb away'
H558862C2332B: 'コードが2GB以上離れている可能性を想定したCFIディレクティブを作成する'
# 'Create debug DLL'
H983B4E5552B9: 'デバッグDLLを作成する'
# 'Create empty files if bundles are missing when unbundling.\n'
H57F1E8EF31C0: 'アンバンドル時にバンドルが不足している場合は空ファイルを作成する。\n'
# 'Create hotpatchable image'
HA0C5E8AB1DC6: 'ホットパッチ可能なイメージを作成する'
# 'Create lane mask for data only, using active.lane.mask intrinsic'
HFF5BD5C1DCB1: 'active.lane.maskインtrinsicを使用してデータのみのレーンマスクを作成する'
# 'Create lane mask using active.lane.mask intrinsic, and use it for both data and control flow'
H1B146FBA9B46: 'active.lane.mask intrinsicを使用してレーンマスクを作成し、データと制御フローの両方に使用する'
# 'Create lane mask with compare/stepvector'
HE51056AA8ABD: 'compare/stepvectorを使用したレーンマスクを作成する'
# 'Create phony target for each dependency (other than main file)'
H49C550B30EC3: '各依存関係（メインファイルを除く）のフェイクターゲットを作成する'
# 'Create pi-block nodes.'
H3DDF1DCDF3C3: 'pi-block ノードを作成する。'
# 'Create redzones for byval arguments (extra copy required)'
HF6B190018549: 'byval引数のレッドゾーンを作成（追加のコピーが必要）'
# 'Create unit-strided versions of loops'
H1EF207263F28: 'ループのユニットストライド版を作成します'
# "Creates .debug_names section, if the input binary doesn't have it already, for DWARF5 CU/TUs."
HFA262F88083F: '.debug_namesセクションを作成します（入力バイナリに既に含まれていない場合）、DWARF5 CU/TUs用です'
# 'Cross module exports (DEBUG_S_CROSSSCOPEEXPORTS subsection)'
HE827878921EC: 'モジュール間のエクスポート（DEBUG_S_CROSSSCOPEEXPORTSサブセクション）'
# 'Cross module imports (DEBUG_S_CROSSSCOPEIMPORTS subsection)'
HE6104A2735AD: 'モジュール間のインポート（DEBUG_S_CROSSSCOPEIMPORTSサブセクション）'
# 'Cull hazards on function boundaries'
HD35403A45243: '関数境界でのハザードを削減'
# 'Cull hazards on memory waits'
HF9A83C7746B5: 'メモリウェイトでのハザードを削減'
# 'Cutoff for generating "extract" instructions'
HF67D76A2F279: 'extract命令を生成するための閾値'
# 'Cutoff percentages (times 10000) for generating detailed summary'
HF12B62925337: '詳細なサマリを生成するためのパーセンテージの閾値（10000倍）'
# 'Cutoff value about how many symbols in profile symbol list will be used. This is very useful for performance debugging'
H866011BDFA50: 'プロファイルシンボルリストで使用するシンボル数の閾値。パフォーマンスデバッグに非常に役立ちます'
# 'Cycle Info Analysis'
HD7B2CE61522D: 'サイクル情報分析'
# 'DAG combiner enable load/<replace bytes>/store with a narrower store'
H7A381CB1EB04: 'DAGコンビナーが、より狭いストアを使用してload/<replace bytes>/storeを有効にします'
# 'DAG combiner enable merging multiple stores into a wider store'
H9B98909FAA22: 'DAGコンビナーが複数のストアをより幅の広いストアにマージする機能を有効にします'
# 'DAG combiner enable reducing the width of load/op/store sequence'
H56650D4975A5: 'DAGコンビナーがロード/オペレーション/ストアのシーケンスの幅を縮小する機能を有効にします'
# 'DAG combiner force override the narrowing profitable check when reducing the width of load/op/store sequences'
HA751CC58B87A: 'DAGコンビナーが、ロード/オペレーション/ストアのシーケンスの幅縮小時に利益検査を強制的に上書きします'
# 'DAG combiner limit number of steps when searching DAG for predecessor nodes'
HEF62B0854706: 'DAGコンビナーがDAGのpredecessorノードを検索するステップ数を制限します'
# 'DAG combiner may split indexing from loads'
HFB4258B46B3C: 'DAGコンビナーがロードからインデックスを分割する可能性があります'
# 'DEBUG/DEVELOPMENT OPTIONS'
H43B5FBE6C89C: 'デバッグ/開発オプション'
# "DEPRECATED: Filename defining the whitelist for imbuing the 'always instrument' XRay attribute."
HC9A9C6768A2E: "非推奨: 'always instrument' XRay属性を付与するホワイトリストを定義するファイル名"
# "DEPRECATED: Filename defining the whitelist for imbuing the 'never instrument' XRay attribute."
H640211D9F2F8: "非推奨: 'never instrument' XRay属性を付与するホワイトリストを定義するファイル名"
# 'DRIVER OPTIONS'
H8F860C8326CF: 'ドライバーオプション'
# 'DWARF'
HDD71DBDFB287: 'DWARF'
# 'DWARF debug sections compression type'
H91FF9BE5328B: 'DWARFデバッグセクションの圧縮形式'
# 'DWARF-like CFI based exception handling'
HC32F13DA0A07: 'DWARF方式のCFIに基づく例外処理'
# 'DWO output filename'
H6E851EAFE0D8: 'DWO出力ファイル名'
# 'DXContainer Global Emitter'
H7800E8E1E097: 'DXContainerグローバル発行者'
# 'DXIL Array Flattener'
H8F82D482C158: 'DXIL配列フラットナー'
# 'DXIL Data Scalarization'
H8CA416EED877: 'DXILデータスカラライゼーション'
# 'DXIL Finalize Linkage'
H674F973B6F8F: 'DXILリンクエイジ最終化'
# 'DXIL Intrinsic Expansion'
H92F9B358ADE0: 'DXIL組み込み関数展開'
# 'DXIL Legalizer'
HB4D0483DF9F7: 'DXILレーガライザ'
# 'DXIL Metadata Pretty Printer'
HF96947D33548: 'DXILメタデータ整形印刷機'
# 'DXIL Module Metadata analysis'
HA9F2740D603A: 'DXILモジュールメタデータ分析'
# 'DXIL Op Lowering'
HEEFF9D70DBBF: 'DXILオペレーションローティング'
# 'DXIL Prepare Module'
HF62B7360E273: 'DXILモジュール準備'
# 'DXIL Resource Access'
HF5E458A33121: 'DXILリソースアクセス分析'
# 'DXIL Resource Binding Analysis'
HC92CD4D22E79: 'DXILリソースバインディング分析'
# 'DXIL Resource Type Analysis'
HF10ABCFBFE52: 'DXILリソースタイプ分析'
# 'DXIL Root Signature Analysis'
HBF76A637272F: 'DXILルートシグネチャ分析'
# 'DXIL Shader Flag Analysis'
H7A214ED13A39: 'DXILシェーダーフラグ分析'
# 'DXIL Translate Metadata'
HF4C419C952DF: 'DXILメタデータ変換'
# 'DXIL validator installation path'
H9657CC613141: 'DXIL バリデータのインストールパス'
# 'Darwin libsystem_m'
H91DFA86D618A: 'Darwin libsystem_m'
# 'Data aggregation options'
H2670869C509A: 'データ集約オプション'
# 'Dbi Stream Options'
HD27A954F7342: 'Dbi ストリーム オプション'
# 'Dead Argument Elimination'
HA9265D7501D4: 'Dead引数削除'
# 'Dead Argument Hacking (BUGPOINT USE ONLY; DO NOT USE)'
HDA7D75078335: 'Dead引数ハック (BugPoint専用；使用禁止)'
# 'Dead Code Elimination'
HF23F9DE62329: 'Deadコード削除'
# 'Debug Variable Analysis'
H4B43DA399B8A: 'Debug変数分析'
# 'Debug control MBBs that are scheduled'
HFA489B3CE974: 'スケジュールされたMBBsのデバッグ制御'
# 'Debug control for aggressive anti-dep breaker'
HDCDB4687E0FE: '積極的なanti-depブレイカーのデバッグ制御'
# 'Debug dumping for the orc-lazy JIT.'
HB541A1485401: 'orc-lazy JITのデバッグダンプ'
# 'Debug func'
H4ECA9A2353F4: 'デバッグ関数'
# 'Debug information offset.'
H34EB3EE5B41D: 'デバッグ情報オフセット'
# 'Debug information tags.'
H2591856B760C: 'デバッグ情報タグ'
# 'Debug line.'
HC0773DFAAF93: 'デバッグ行'
# 'Debug lines that are zero.'
H28A0CEC425F6: 'ゼロのデバッグ行'
# 'Debug location ranges.'
H40716F5089BC: 'デバッグロケーション範囲'
# 'Debug max inst'
H8671ED460AD3: 'デバッグ最大命令'
# 'Debug min inst'
H10F353058E6B: 'デバッグ最小命令'
# 'Debug option to outline greedily, without restriction that calculated benefit outweighs cost'
H173943EFDB58: '計算された利益がコストを上回るという制限なしに貪欲にアウトライン化するデバッグオプション'
# 'Debugify MIR before and Strip debug after each pass except those known to be unsafe when debug info is present'
H0F54403815FA: 'デバッグ情報を存在させることが安全な場合、各パス実行前後にMIRをデバッグ化し、デバッグ情報を削除します'
# 'Debugify MIR before, by checking and stripping the debug info after, each pass except those known to be unsafe when debug info is present'
HC24A7BC34E88: 'デバッグ情報を存在させることが安全な場合、各パス実行前後にMIRをデバッグ化し、デバッグ情報をチェックして削除します'
# 'Decided the kind of output desired'
H734A5ED4813F: '生成する出力の種類を指定します'
# 'Declare callbacks extern weak, and only call if non-null.'
H2C4EDA19C0CD: 'コールバックをextern weakとして宣言し、非NULLの場合は呼び出します'
# 'Declare variables at top when emitting C/C++'
HB43A4E22EF20: 'C/C++の発行時に変数を先頭に宣言します'
# "Decreases 'x86-br-merging-base-cost' in cases that it is unlikely that all conditionals will be executed. For example for merging the conditionals (a == b && c > d), if its known that a == b is unlikely, then it is unlikely that if the conditionals are split both sides will be executed, so it may be desirable to decrease the instruction cost threshold. Set to -1 to never merge unlikely branches."
H63754944E6A3: "'x86-br-merging-base-cost'を、すべての条件式が実行される可能性が低い場合に減少させます。例えば条件式の結合 (a == b && c > d) の場合、a == bが稀な場合、条件式を分割しても両方の分岐が実行される可能性が低いため、指令コストのしきい値を下げた方が望ましい場合があります。-1を指定すると、稀な分岐の結合を行いません。"
# 'Deduce sibling calls when unrolling function call stacks'
HDD364524269F: '関数呼び出しスタックのアンロール時にシスターコールを推論します'
# 'Default (no attribute)'
H2C9C1DE32DAB: 'デフォルト（属性なし）'
# 'Default DWARF version to use, if a -g option caused DWARF debug info to be produced'
HFF353DB7A2F1: 'DWARFデバッグ情報が生成される場合のデフォルトDWARFバージョン'
# 'Default address minimization strategy'
H1000E773EFCF: 'デフォルトのアドレス最小化戦略'
# 'Default alignment for loops'
HFA44E84983F7: 'ループのデフォルトアライメント'
# 'Default amount of inlining to perform'
H05B97F3AF721: 'デフォルトのインライン化量'
# 'Default for platform'
H91B018E0FAE2: 'プラットフォームのデフォルト'
# 'Default for platform and JIT-kind'
H0675076F20CF: 'プラットフォームとJIT種類のデフォルト'
# 'Default max threads per block for kernel launch bounds for HIP'
HDE6E6DE6B0D5: 'HIPのカーネル起動境界におけるブロックごとの最大スレッド数'
# 'Default mispredict rate (initialized to 25%).'
HA90859109DC8: '不正予測率（初期値25%）'
# 'Default register allocator'
HF2112AFDE4A0: 'デフォルトレジスタ割り当てャー'
# 'Default threshold (max size of unrolled loop), used in all but O3 optimizations'
H450E3D6B5565: 'O3最適化以外で使用されるアンロールループの最大サイズのしきい値'
# 'Default type visibility'
H7E06B3502FFA: 'デフォルトの型可視性'
# 'Defer host/device related diagnostic messages for CUDA/HIP'
HD7B0D94624F9: 'CUDA/HIPのホスト/デバイス関連の診断メッセージを遅延表示します'
# "Define '__STDC__' to '1' in MSVC Compatibility mode"
HE12E4DC30513: "MSVC互換モードで'__STDC__'を'1'に定義"
# 'Define <macro> to <value> (or 1 if <value> omitted)'
HC9C0FAB29C48: '<macro>を<value>に定義（<value>が省略された場合は1）'
# 'Define __STDC__'
H403D03CBAA5E: '__STDC__を定義'
# 'Define a value for a symbol'
HF0BE0602E7DD: 'シンボルの値を定義'
# 'Define a variable to be used in capture patterns.'
H430D1D820ECC: 'キャプチャパターンで使用する変数を定義'
# 'Define custom MSan AndMask'
H293D08EE84D2: 'カスタムMSan AndMaskを定義'
# 'Define custom MSan OriginBase'
H8FF05FDD24B0: 'カスタムMSan OriginBaseを定義'
# 'Define custom MSan ShadowBase'
H936AD234A7BD: 'カスタムMSan ShadowBaseを定義'
# 'Define custom MSan XorMask'
HE0448D308359: 'カスタムMSan XorMaskを定義'
# 'Define macro'
H1A169BE8E69A: 'マクロを定義'
# 'Define threshold for number of checks per debug location to force origin update.'
H97F94F0D6F64: 'デバッグロケーションごとのチェック数のしきい値を設定して、元の情報を更新する'
# 'Define where potential integer overflows in generated expressions should be tracked.'
H76CDAC079D12: '生成された式での潜在的な整数オーバーフローを追跡する場所を定義'
# 'Defined the specified macros to their specified definition. The syntax is <macro>=<definition>'
H8B59655A675D: '指定されたマクロを指定された定義に設定します。構文は<macro>=<definition>です'
# 'Defines a symbol to be an integer constant'
H876930F92D82: 'シンボルを整数定数として定義'
# 'Defines the __DEPRECATED macro'
H49D43A572A26: '__DEPRECATEDマクロを定義'
# 'Delete specified Globals from Module'
HB4A9BA47E594: 'モジュールから指定されたGlobalsを削除'
# 'Delinearize array access functions'
HA9C6C1714FE6: '配列アクセス関数の線形化を解除'
# 'Delta passes to not run, separated by commas. By default, run all delta passes.'
H76B8D7EFA5BE: '実行しないDeltaパスをカンマ区切りで指定。デフォルトではすべてのDeltaパスを実行'
# 'Delta passes to run, separated by commas. By default, run all delta passes.'
H192F0FF37D50: '実行するDeltaパスをカンマ区切りで指定。デフォルトではすべてのDeltaパスを実行'
# 'Demangle function names'
H0F5F6B77621B: '関数名のデマングル'
# 'Demote catchswitch BBs only (for wasm EH)'
H0707EDF1B004: 'wasm EH用にcatchswitch BBのみを降格'
# 'Dependence Analysis'
H1CE69C87EFED: '依存関係分析'
# 'Dependences should be simplified (yes/no)'
HFE9403DC8E00: '依存関係を簡略化する必要があります（はい/いいえ）'
# 'Dependency filename'
H48F0BFFD012C: '依存関係ファイル名'
# 'Deprecated (like /Og /Oi /Ot /Oy /Ob2); use /O2'
HC8F13BE3A9B1: '非推奨（/Og /Oi /Ot /Oy /Ob2などと同じ）; /O2を使用してください'
# 'Deprecated (like not passing /EH)'
HB203EF80F1D6: '非推奨（/EHを指定しない場合など）'
# 'Deprecated (set output file name); use /Fe or /Fe'
H43E83CDF9C2D: '非推奨（出力ファイル名を設定する）; /Feを使用してください'
# "Deprecated; use '-O3 -ffast-math -fstack-arrays' for the same behavior, or '-O3 -fstack-arrays' to enable only conforming optimizations"
H894A29167B0A: "非推奨; 同じ挙動を得るには'-O3 -ffast-math -fstack-arrays'を使用、または準拠した最適化のみ有効にする場合は'-O3 -fstack-arrays'を使用"
# "Deprecated; use '-O3 -ffast-math' for the same behavior, or '-O3' to enable only conforming optimizations"
H68FB98DB67B0: "非推奨; 同じ挙動を得るには'-O3 -ffast-math'を使用、または準拠した最適化のみ有効にする場合は'-O3'を使用"
# 'Deprecated; use /EHsc'
H0521F1C5E495: '非推奨; /EHscを使用してください'
# 'Depth limit for finding address space through traversal'
HD8946F32E697: '探索によるアドレス空間特定の深さ制限'
# 'Depth limit when simplifying vector instructions and their operands'
H77D06B036D51: 'ベクタ命令およびそのオペランドを簡略化する際の深さ制限'
# 'Deref attributes and metadata infer facts at definition only'
HA8F233351C69: 'Deref属性とメタデータは定義時のみ事実を推論'
# 'Details for each and every function'
HC3D59D83E7DB: 'すべての関数の詳細'
# 'Detect Dead Lanes'
H72FCA4FFA4F4: 'Dead Lanesの検出'
# 'Detect and exploit reductions'
HE6789AB23B98: 'reductionsの検出と活用'
# 'Detect parallelism'
H2FE6FC8C4E2A: '並列性の検出'
# 'Detect single entry single exit regions'
H9F71476F6AF4: '単一入口単一出口領域の検出'
# "Detect stack use after return if binary flag 'ASAN_OPTIONS=detect_stack_use_after_return' is set."
H52A7D51EA3C5: "バイナリフラグ'ASAN_OPTIONS=detect_stack_use_after_return'が設定されている場合、戻り後のスタック使用を検出"
# 'Determine based on deployment target'
H73C787FF3B61: '展開ターゲットに基づいて決定'
# 'Determine what attributes are manifested in the IR'
H535B6DB54DEC: 'IRで表現される属性を特定します'
# 'Determine when the Swift async frame pointer should be set'
H0BCAA17B1F0F: 'Swift非同期スタックポインターが設定されるタイミングを特定します'
# 'Determines whether the optimizer honors parentheses when floating-point expressions are evaluated'
HD46386982C52: '最適化プロセスが浮動小数点式の評価時に括弧を尊重するかどうかを判断します'
# 'Diagnostic ID mapping utility'
HC6CDFACE6E9C: '診断IDマッピングユーティリティ'
# 'Diff Options'
H28F8A773273E: 'Diff オプション'
# 'Directly create compilation output files. This may lead to incorrect incremental builds if the compiler crashes'
H2C3E48B98787: 'コンパイル出力ファイルを直接作成します。コンパイラがクラッシュした場合、インクリメンタルビルドが正しくない結果になる可能性があります'
# 'Directories referenced in the debug information.'
HA9318D60737D: 'デバッグ情報で参照されるディレクトリ'
# 'Directories to search for object files by build ID'
HC9E3A565BEEA: 'ビルドIDでオブジェクトファイルを探すディレクトリ'
# 'Directory for crash diagnostic files.'
H168FC0AAB4F7: 'クラッシュ診断ファイルのディレクトリ'
# 'Directory for outputting generated files.'
H8BAEDDCD56DA: '生成ファイルを出力するディレクトリ'
# 'Directory in which coverage information is written out'
HE36AE6B0A9D2: 'カバレッジ情報を書き出すディレクトリ'
# 'Directory in which to emit symbol graphs.'
HD25DF8577F21: 'シンボルグラフを出力するディレクトリ'
# 'Directory of include files'
H4769C553D95E: 'インクルードファイルのディレクトリ'
# 'Directory to dump module dependencies to'
H34B714818DA5: 'モジュール依存関係をダンプするディレクトリ'
# "Directory to output dSYM's (if any) to"
H6E5284514F1A: 'dSYMファイル（存在する場合）を出力するディレクトリ'
# 'Directory to store cached object files (must be user writable)'
HF3C59BF42111: 'キャッシュされたオブジェクトファイルを格納するディレクトリ（ユーザーが書き込み可能でなければなりません）'
# 'Directory used as a base for relative coverage mapping paths'
H60985D18A905: '相対カバレッジマッピングパスの基になるディレクトリ'
# 'Disable BPF_ST (immediate store) insn'
HD28C63C4DB63: 'BPF_ST（即時ストア）命令を無効にする'
# 'Disable C++ access control'
H88EE329A1455: 'C++のアクセス制御を無効にする'
# 'Disable C++ builtin type char8_t'
HE8005A3ED4D9: 'C++の組み込み型char8_tを無効にする'
# 'Disable C++ builtin type wchar_t'
H2F081FBCFFCE: 'C++の組み込み型wchar_tを無効にする'
# 'Disable C++ copy constructor elision'
H7BE31CDC2832: 'C++のコピー コンストラクタの省略を無効にする'
# 'Disable C++ static destructor registration'
H2B2B7EA1E24C: 'C++の静的デストラクタの登録を無効にする'
# 'Disable C++14 sized global deallocation functions'
H31DC24E25DC3: 'C++14のサイズ指定グローバル解放関数を無効にする'
# 'Disable C++17 aligned allocation functions'
H45EDF7CE8D2D: 'C++17のアライン済み割り当て関数を無効にする'
# 'Disable CHR for all functions'
HE1BB044E9400: 'すべての関数に対するCHRを無効にする'
# 'Disable CIR transformations pipeline'
H0D1EAB308F4D: 'CIR変換パイプラインを無効にする'
# 'Disable CTR loops for PPC'
HFB1BF72E3D56: 'PPC用のCTRループを無効にする'
# 'Disable Codegen Prepare'
H9DF18DE3903B: 'コードジェネレート準備を無効にする'
# 'Disable ConstantHoisting'
HA432AE659D39: '定数持ち出し最適化を無効にする'
# 'Disable Copy Propagation pass'
H6FAF844B65AE: 'コピー伝播最適化を無効にする'
# 'Disable Dealloc Return for Hexagon target'
HC23D9F3300FD: 'Hexagonターゲット向けのDealloc Returnを無効にする'
# 'Disable Early If-conversion'
H0D9C330086F8: 'Early If変換を無効にする'
# 'Disable GC optimizations in CodeGenPrepare'
HFD8A99D7BFCD: 'CodeGenPrepareのGC最適化を無効にする'
# 'Disable GNU style inline asm'
H1CF933954FC2: 'GNUスタイルのインラインアセンブリを無効にする'
# 'Disable Hardware Loops for Hexagon target'
H783975C3C5DB: 'Hexagonターゲット向けのハードウェアループを無効にする'
# 'Disable Hexagon Addressing Mode Optimization'
H071B2E4C0FD8: 'Hexagonアドレスモード最適化を無効にする'
# 'Disable Hexagon CFG Optimization'
HEF36B4E6BB85: 'Hexagon CFG最適化を無効にする'
# 'Disable Hexagon HVX IEEE floating-point'
H506C4D61FBA6: 'Hexagon HVXのIEEE浮動小数点を無効にする'
# 'Disable Hexagon HVX QFloat instructions'
HF256A44FD3F5: 'Hexagon HVXのQFloat命令を無効にする'
# 'Disable Hexagon MI Scheduling'
HA39B5931FB8D: 'Hexagon MI スケジューリングを無効にする'
# 'Disable Hexagon Vector eXtensions'
HDECA543F8233: 'Hexagon ベクタ拡張機能を無効にする'
# 'Disable Hexagon constant propagation'
HED97EBD49929: 'Hexagon 定数伝播を無効にする'
# 'Disable Hexagon instruction shuffling'
HC9709908CDDF: 'Hexagon 命令のシャッフルを無効にする'
# 'Disable Hexagon loop alignment pass'
HCE964D02A0A9: 'Hexagon ループアライメント パス を無効にする'
# 'Disable Hexagon packetizer pass'
HCB5AE1AB8542: 'Hexagon パケット化 パス を無効にする'
# 'Disable Hexagon specific Mask generation pass'
H8E1C9C7C8EC3: 'Hexagon 専用のマスク生成 パス を無効にする'
# 'Disable JIT lazy compilation'
H24C8D24310DC: 'JIT 遅延コンパイルを無効にする'
# 'Disable LTO mode (default)'
H508DDA148F38: 'LTO モードを無効にする (既定値)'
# 'Disable LTO mode (default) for offload compilation'
H7985601FAE0D: 'オフロード コンパイル用の LTO モードを無効にする (既定値)'
# 'Disable Linear Function Test Replace optimization'
HA3DA3179BF69: '直線関数テスト置換 最適化を無効にする'
# 'Disable Loongson Advanced SIMD Extension (LASX).'
HEC68A6D43B64: 'Loongson 高度なSIMD拡張 (LASX) を無効にする'
# 'Disable Loongson SIMD Extension (LSX).'
H51EB682DB218: 'Loongson SIMD拡張 (LSX) を無効にする'
# 'Disable Loop Idiom Vectorize Pass.'
HCD6AF30D16E4: 'ループイディオムベクター化 パス を無効にする'
# 'Disable Loop Strength Reduction Pass'
HFDE52CD02ECB: 'ループ強度削減 パス を無効にする'
# 'Disable MC/DC coverage criteria'
H5A71DE0EA17B: 'MC/DC カバレッジ基準を無効にする'
# 'Disable MIRProfileLoader before BlockPlacement'
H7119CF48A829: 'BlockPlacement の前の MIRProfileLoader パスを無効にする'
# 'Disable MIRProfileLoader before RegAlloc'
HCEBEE56EAD41: 'RegAlloc の前の MIRProfileLoader パスを無効にする'
# 'Disable MSA ASE (MIPS only)'
H771BF5C8F84F: 'MIPS専用の MSA ASE を無効にする'
# 'Disable MT ASE (MIPS only)'
H1B6CF37939E2: 'MIPS専用の MT ASE を無効にする'
# 'Disable Machine Common Subexpression Elimination'
H600985BEDBBF: 'マシン共通部分式削除を無効にする'
# 'Disable Machine Dead Code Elimination'
H436919B5DD6D: 'マシンデッド コード削除を無効にする'
# 'Disable Machine LICM'
HCA4B000FCB0F: 'マシンLICMを無効にする'
# 'Disable Machine Sinking'
H84436D44017D: 'マシンシンクを無効にする'
# 'Disable MergeICmps Pass'
H127BD98A6338: 'MergeICmps パスを無効にする'
# 'Disable New Value Jumps'
H3397AA24247F: '新しい値ジャンプを無効にする'
# 'Disable ODR indicator globals'
H2F9A01FFB645: 'ODR インジケータ グローバル変数を無効にする'
# 'Disable OpenMP optimizations involving SPMD-ization.'
HAF8239BD178C: 'SPMD化を含むOpenMPの最適化を無効にする'
# 'Disable OpenMP optimizations involving deglobalization.'
H74B4ADA2F47B: 'deglobalizationを含むOpenMPの最適化を無効にする'
# 'Disable OpenMP optimizations involving folding.'
HBD10CEF55EEF: 'フォールディングを含むOpenMPの最適化を無効にする'
# 'Disable OpenMP optimizations that eliminate barriers.'
H5C4E1057F8BD: 'バリアを削除するOpenMPの最適化を無効にする'
# 'Disable OpenMP optimizations that replace the state machine.'
HC78F7C4114D3: 'ステート マシンを置き換えるOpenMPの最適化を無効にする'
# 'Disable OpenMP specific optimizations.'
HA40A50850068: 'OpenMP固有の最適化を無効にする'
# 'Disable OpenMP support'
HFCB159BB2AD0: 'OpenMPのサポートを無効にする'
# 'Disable Optimization of PNotP'
HE9DF380BE58C: 'PNotPの最適化を無効にする'
# 'Disable Optimization of Sign/Zero Extends'
H821C42065D98: '符号/ゼロ拡張の最適化を無効にする'
# 'Disable Optimization of extensions to i64.'
HD38C1BE50891: 'i64への拡張の最適化を無効にする'
# 'Disable PPC loop instr form prep'
H8547684E746B: 'PPCループ命令形式の準備を無効にする'
# 'Disable Partial Libcall Inlining'
HDD48CA4D7B3E: 'Partial Libcallインライン化を無効にする'
# 'Disable Peephole Optimization'
H6E6615A7A740: 'ピーホール最適化を無効にする'
# 'Disable Post Regalloc Scheduler'
HD739F0016551: 'ポストレジサロケーションスケジューラを無効にする'
# 'Disable PostRA Machine Sinking'
HBB5CB09CF7E3: 'PostRAマシンシンキングを無効にする'
# 'Disable SVR4-style position-independent code (Mips only)'
HA6D44538AD07: 'SVR4スタイルの位置依存コードを無効にする (Mipsのみ)'
# 'Disable SYCL C++ extensions'
H66EB15B22DDA: 'SYCL C++拡張機能を無効にする'
# 'Disable Sparc leaf procedure optimization.'
H4EAE17DB87E5: 'Sparcリーフプロシージャ最適化を無効にする'
# 'Disable Stack Slot Coloring'
HC67B1F734851: 'スタックスロットカラリングを無効にする'
# 'Disable V8+ mode'
HF617D77F2415: 'V8+モードを無効にする'
# 'Disable VSX FMA instruction mutation'
HEA8BD8C0F7FD: 'VSX FMA命令の変異を無効にする'
# 'Disable VSX Swap Removal for PPC'
H5BF6CF30BC27: 'PPC用のVSXスワップ除去を無効にする'
# 'Disable Value Profiling'
H0CA8694E7036: '値プロファイリングを無効にする'
# 'Disable XMM8-XMM15 register usage'
H1FBE9270DAE0: 'XMM8-XMM15レジスタの使用を無効にする'
# 'Disable adding the optnone attribute to functions at O0'
H7B7D0B68A353: 'O0で関数にoptnone属性を追加しないようにする'
# 'Disable advance peeling. Issues for convergent targets (D134803).'
H96D4946929C2: 'Advance peelingを無効にする. 収束ターゲットで問題が発生します (D134803)'
# 'Disable advanced copy optimization'
H450999EB2A6C: '高度なコピー最適化を無効にする'
# 'Disable aliasing mode in HWAddressSanitizer'
HDA55D81C7ABD: 'HWAddressSanitizerのエイリアシングモードを無効にする'
# 'Disable all Clang extensions for OpenMP directives and clauses'
HAECEE0FE6723: 'OpenMPディレクティブと句に対するClang拡張機能をすべて無効にする'
# 'Disable all options'
H2FCF77933240: 'すべてのオプションを無効にする'
# 'Disable all outlining'
H452D85B48206: 'すべてのアウトライン化を無効にする'
# 'Disable all rules in the '
H96795369E1EA: '指定されたルール全体を無効にする'
# 'Disable all static analyzer checks'
H8DC2486B7F10: '静的解析チェックをすべて無効にする'
# 'Disable all vector combine transforms'
H63388692148E: 'ベクター統合変換をすべて無効にする'
# 'Disable all warnings'
H113C54A4E2E2: 'すべての警告を無効にする'
# 'Disable amcas[_db].{b/h/w/d}'
H4094C4B64BFB: 'amcas[_db].{b/h/w/d} を無効にする'
# 'Disable amswap[_db].{b/h} and amadd[_db].{b/h}'
HF02B3FF824A2: 'amswap[_db].{b/h} および amadd[_db].{b/h} を無効にする'
# 'Disable analysis for CTR loops'
H4E1A550B8424: 'CTR ループの解析を無効にする'
# 'Disable analyzing function argument and return types for mandatory definedness'
H035F5FA49F38: '関数引数と戻り値の型の必須定義状態の分析を無効にする'
# 'Disable annotate table jump instruction to correlate it with the jump table.'
HE3C86797416A: 'ジャンプテーブルと関連付けるためのテーブルジャンプ命令へのアノテーションを無効にする'
# 'Disable any #pragma clang __debug that can lead to crashing behavior. This is meant for testing.'
H22EE3114285C: 'クラッシュを引き起こす可能性のある #pragma clang __debug をすべて無効にする. これはテスト用です。'
# 'Disable atomic operations instrumentation in ThreadSanitizer'
H436F5749CCF4: 'ThreadSanitizer での原子操作のインストルメンテーションを無効にする'
# 'Disable atomic optimizer'
H91DDEC6A5CA5: '原子最適化を無効にする'
# 'Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash'
HCBAE420C8090: 'clang のクラッシュ時にプリプロセス済みソースファイルと再現用スクリプトの自動生成を無効にする'
# 'Disable automatic bitcode upgrade for version mismatch'
H5A3DEE200EB5: 'バージョン不一致時のビットコードの自動アップグレードを無効にする'
# 'Disable autoupgrade of debug info'
HC2D0BCF7F57C: 'デバッグ情報の自動アップグレードを無効にする'
# 'Disable backend optimizations'
HB773D8B41328: 'バックエンド最適化を無効にする'
# 'Disable binop extract to shuffle transforms'
H6FB234E00070: '二項演算子抽出からシャッフル変換を無効にする'
# 'Disable block signature string)'
H0B1A3707BF42: 'ブロックシグネチャーストリングを無効にする'
# 'Disable both standard system #include directories and builtin #include directories'
H7E21F38033ED: '標準システム #include ディレクトリと組み込み #include ディレクトリの両方を無効にする'
# 'Disable branch folding'
HF6094945EF27: 'ブランチ折り畳みを無効にする'
# 'Disable branch optimizations in CodeGenPrepare'
H9E934B1894F9: 'CodeGenPrepare でのブランチ最適化を無効にする'
# 'Disable bswap insns'
HEC30AD38E748: 'bswap 指令を無効にする'
# 'Disable buffer security check'
H8BA30D52B9A7: 'バッファ セキュリティ チェックを無効にする'
# 'Disable builtin #include directories only'
HF9A61F76A5C0: 'ビルトイン #include ディレクトリのみを無効にする'
# 'Disable calling convention lowering pass'
H9858ACECE04B: 'コール コンベンション ローティング パスを無効にする'
# 'Disable caret diagnostics but keep column info'
H597AC3D9E291: 'ケアット診断を無効にするが、列情報を保持する'
# 'Disable char8_t from c++2a'
H5E206E934042: 'C++2a の char8_t を無効にする'
# 'Disable checking of constexpr function bodies for validity within a constant expression context'
H6ABC0DD0EC14: '定数式コンテキスト内の有効性を検証する constexpr 関数本体のチェックを無効にする'
# 'Disable checks that try to statically verify validity of delinearized subscripts. Enabling this option may result in incorrect dependence vectors for languages that allow the subscript of one dimension to underflow or overflow into another dimension.'
H5CACAB20797B: 'デリニアライズされたサブスクリプトの有効性を静的に検証するチェックを無効にします。このオプションを有効にすると、1つの次元のサブスクリプトが他の次元にアンダーフローまたはオーバーフローを許可する言語では、依存ベクターが不正確になる可能性があります。'
# 'Disable clustered low occupancy rescheduling for ILP scheduling stage.'
HA583E3ADAB6E: 'ILP スケジューリング段階でのクラスタリング ロー占用率 リスケジューリングを無効にする'
# 'Disable code coverage analysis'
H7E958EA264B1: 'コード カバレッジ 分析を無効にする'
# "Disable codegen and compile-time checks for C++23's [[assume]] attribute"
H8CC8CAFE3A4B: 'C++23 の [[assume]] アトリビュートのコード生成とコンパイル時チェックを無効にする'
# 'Disable codegen data for function merging. Local merging is still enabled within a module.'
HA6F585942D4A: '関数マージ用のコード生成データを無効にする。モジュール内のローカル マージは有効のまま。'
# 'Disable colors in diagnostics'
HDC4DB95966A6: '診断メッセージの色付けを無効にする'
# 'Disable column and caret diagnostics'
H66ABD4DABB22: '列情報とケアット診断を無効にする'
# 'Disable combining of interleaved loads'
HDC89DC5720AF: 'インターレーブ ロードの結合を無効にする'
# 'Disable command line arguments round-trip.'
H529251337527: 'コマンドライン引数の往復復元を無効にする'
# 'Disable compare instruction optimization'
HCA46CE080B75: '比較命令最適化を無効にする'
# 'Disable control flow integrity (CFI) checks for cross-DSO calls.'
HBA298571E50D: '異なる DSO 間のコールに対する制御フロー整合性 (CFI) チェックを無効にする'
# 'Disable control-flow mitigations for Load Value Injection (LVI)'
HC84915AF941B: 'ロード バリュー インジェクション (LVI) 対策の制御フロー対策を無効にする'
# 'Disable convert to D suffix'
HEE0A84D95394: 'D サフィックスへの変換を無効にする'
# 'Disable coverage pruning (i.e. instrument all blocks/edges)'
HF9991A3D9D32: 'カバレッジ プルーニングを無効にする（すべてのブロック/エッジを計測する）'
# 'Disable creation of CodeFoundation-type constant strings'
H8A3AF608A73D: 'CodeFoundationタイプの定数文字列の作成を無効にします'
# 'Disable critical edge splitting during PHI elimination'
HF87FC46C993D: 'PHI 削除中にクリティカルエッジの分割を無効にします'
# 'Disable critical path priority in sched=list-ilp'
H2CD6F07C5299: 'sched=list-ilp でクリティカルパスの優先度を無効にします'
# 'Disable custom behaviour (use the default class which does nothing).'
HDD6103F48106: 'カスタム動作を無効にします（デフォルトのクラスを使用し、何もしません）'
# 'Disable cycle-level precision during preRA scheduling'
HF9826B2C9560: 'preRA スケジューリング中にサイクル単位の精度を無効にします'
# 'Disable delayed template parsing'
H78E92B7DA979: '遅延テンプレート解析を無効にします'
# 'Disable detection of uninitialized parameters and return values'
H58D5476F7351: '初期化されていないパラメータと戻り値の検出を無効にします'
# 'Disable diagnostic notes.'
HC94928475428: '診断情報のノートを無効にします'
# 'Disable direct TLS access through segment registers'
H458A3D5DF9C8: 'セグメントレジスタを通じた直接 TLS アクセスを無効にします'
# 'Disable elimination of dead PHI nodes.'
HC1471E3BABD6: '死んだ PHI ノードの削除を無効にします'
# 'Disable emission .debug_ranges section.'
H8261A262490A: '.debug_ranges セクションの生成を無効にします'
# 'Disable emission of core files if possible'
H5CA16DE0180D: '可能な場合、core ファイルの生成を無効にします'
# 'Disable emission of the extended flags in .loc directives.'
HC16B51206891: '.loc ディレクティブの拡張フラグの生成を無効にします'
# 'Disable emitting complete constructors and destructors as aliases when possible'
H4E4DBEA88413: '可能な場合、完全なコンストラクタとデストラクタをエイリアスとして生成しないようにします'
# 'Disable emitting metadata for binary analysis sanitizers'
H9438B3F5F3E7: 'バイナリ分析用のセーフティチェックツールのメタデータ生成を無効にします'
# 'Disable experimental bounds safety extension for C'
H949767942150: 'C 言語の実験的な境界安全拡張機能を無効にします'
# 'Disable experimental late parsing of attributes'
HAEA82819E6DD: '属性の実験的な遅延解析を無効にします'
# 'Disable ext(promotable(ld)) -> promoted(ext(ld)) optimization in CodeGenPrepare'
HFA8DE3453A19: 'CodeGenPrepare における ext(promotable(ld)) -> promoted(ext(ld)) 最適化を無効にします'
# 'Disable external API notes support'
H4877A26CE44B: '外部 API ノートのサポートを無効にします'
# 'Disable fat LTO object support'
HECD714B1BF31: 'fat LTO オブジェクトのサポートを無効にします'
# 'Disable features of APX'
H69A07C7EF30D: 'APXの機能を無効にする'
# 'Disable features of coverage instrumentation for Sanitizers'
H0B74A3F5C9BC: 'Sanitizersのカバレッジインストルメンテーションの機能を無効にする'
# 'Disable fixed point types'
H9D07DD6F2288: '定点数型を無効にする'
# 'Disable fixing up resolved relocations for Hexagon'
H2F59DE7595A3: 'Hexagon向けの解決済み再配置の修正を無効にする'
# 'Disable frame pointer elimination'
H163B87ED062D: 'フレームポインタ除去を無効にする'
# 'Disable frame pointer elimination for non-leaf frame'
HAF65627719BE: '非リーフフレーム向けのフレームポインタ除去を無効にする'
# 'Disable frame pointer omission (x86 only, default)'
H1E0AE27D951E: 'フレームポインタの省略を無効にする (x86専用、既定値)'
# 'Disable frecipe.{s/d} and frsqrte.{s/d}'
H62E54664CC80: 'frecipe.{s/d}とfrsqrte.{s/d}を無効にする'
# 'Disable freeing of memory on exit'
HF1F277AF14E7: '終了時のメモリ解放を無効にする'
# 'Disable function entry/exit instrumentation in ThreadSanitizer'
H1351B571C7D6: 'ThreadSanitizerでの関数エントリ/エグジットインストルメンテーションを無効にする'
# 'Disable function inlining'
H5A7ECCE87EED: '関数インライン化を無効にする'
# 'Disable function internalization.'
H8C418ABB3A74: '関数の内部化を無効にする'
# 'Disable function multiversioning'
H1ECFC327C1B3: '関数のマルチバージョニングを無効にする'
# 'Disable function outlining (AArch64 only)'
H3491F6797D9A: '関数アウトライン化を無効にする (AArch64専用)'
# 'Disable fusing of spill code into instructions'
H7DEB69686DC1: 'スpillコードを命令に統合する機能を無効にする'
# 'Disable generation of RTTI data'
H41B72E945CBF: 'RTTIデータの生成を無効にする'
# 'Disable generation of const64'
HE3959EA50320: 'const64の生成を無効にする'
# 'Disable generation of discriminator information.'
HC17557FCC17F: 'ディスクリミネータ情報の生成を無効にする'
# 'Disable generation of gather instructions in auto-vectorization(x86 only)'
H983AEC35DB6E: 'オートベクター化でのgather命令の生成を無効にする (x86専用)'
# 'Disable generation of instruction packets'
H1BEE193809E5: '命令パケットの生成を無効にする'
# 'Disable generation of linker directives for automatic library linking'
HD9086365BC76: '自動ライブラリリンクのためのリンカーディレクティブの生成を無効にします'
# 'Disable generation of memcpy in loop idiom recognition'
H75B5FDDE583A: 'ループイディオムの認識におけるmemcpyの生成を無効にします'
# 'Disable generation of memmove in loop idiom recognition'
HBDF5135E8486: 'ループイディオムの認識におけるmemmoveの生成を無効にします'
# 'Disable generation of memop instructions'
H58306072EDD8: 'memop命令の生成を無効にします'
# 'Disable generation of new-value jumps'
H7CFC8831E9E7: '新しい値を使用したジャンプの生成を無効にします'
# 'Disable generation of new-value stores'
HD912422CF388: '新しい値を使用したストア命令の生成を無効にします'
# 'Disable generation of profile instrumentation.'
H91EE299476D4: 'プロファイリングのインストルメンテーションの生成を無効にします'
# 'Disable generation of rtti information'
HD27D5DABC1FC: 'RTTI情報の生成を無効にします'
# 'Disable generation of scatter instructions in auto-vectorization(x86 only)'
HE3E5F2C6BEE2: 'x86での自動ベクトル化におけるスキャタ命令の生成を無効にします'
# 'Disable global outlining only by ignoring the codegen data generation or use'
H9030F85E3C32: 'コード生成データの生成または使用を無視することで、グローバルアウトラインを無効にします'
# 'Disable gotol insn'
HA056175A68C0: 'gotol命令の生成を無効にします'
# 'Disable hazard detection during preRA scheduling'
H42E4A02F5152: 'preRAスケジューリング中のハザード検出を無効にします'
# 'Disable heap memory profiling'
HD2AF1D7462E3: 'ヒープメモリのプロファイリングを無効にします'
# 'Disable hoisting instructions to hotter blocks'
HECAA5605738C: 'ホットブロックへの命令のアップリフティングを無効にします'
# 'Disable identical code folding (default)'
H2724011BEF3B: '同一コードの折り畳みを無効にします (既定値)'
# 'Disable implicit addition of a top-level module op during parsing'
H38ED3CECF1BE: 'パース時にトップレベルモジュールオペレーションの暗黙の追加を無効にします'
# 'Disable implicit builtin knowledge of a specific function'
H72774275D87A: '特定の関数の暗黙のビルトイン知識を無効にします'
# 'Disable implicit builtin knowledge of functions'
H4AC3CF326B03: '関数の暗黙のビルトイン知識を無効にします'
# 'Disable implicit builtin knowledge of math functions'
H19E24A418BA8: '数学関数の暗黙のビルトイン知識を無効にします'
# 'Disable inclusion of timestamp in precompiled headers'
H0CF0F2D88326: '事前コンパイル済みヘッダーへのタイムスタンプの包含を無効にします'
# 'Disable indirect call promotion'
HEA9F9E3D24D2: '間接呼び出しのプロモーションを無効にする'
# 'Disable instrumentation manager (use the default class which ignores instruments.).'
HFBC374870D12: 'インストゥルメンテーション マネージャを無効にする（インストルメンツを無視するデフォルトクラスを使用）'
# 'Disable integer(KIND=16) from TargetCharacteristics'
H1BFDF2763387: 'TargetCharacteristicsからKIND=16の整数を無効にする'
# 'Disable integer(KIND=2) from TargetCharacteristics'
HBBF18B435116: 'TargetCharacteristicsからKIND=2の整数を無効にする'
# 'Disable integrated assembler'
HA16408310A5F: '統合アセンブリを無効にする'
# 'Disable isel of shifter-op'
H7D5BCC95A13C: 'shifter-opのiselを無効にする'
# 'Disable just-my-code debugging (default)'
H32F1427A6837: '自分のコードのみのデバッグを無効にする（既定値）'
# 'Disable keeping all variables that have a persistent storage duration, including global, static and thread-local variables, to guarantee that they can be directly addressed'
H49BC5C7A9B8E: '永続的なストレージ期間を持つすべての変数（グローバル、静的、スレッド局所変数を含む）を保持して直接アドレス指定を保証する機能を無効にする'
# 'Disable last run tracking'
HC4C7223E1ECA: '最終実行追跡を無効にする'
# 'Disable late function splitting using profile information (x86 and aarch64 ELF)'
HE4A96F3E3F80: 'プロファイル情報を使用した遅延関数分割を無効にする（x86およびaarch64 ELF）'
# 'Disable lazy module loading'
HEF9F9437498A: '遅延モジュール読み込みを無効にする'
# 'Disable ldsx insns'
H5394D7A0EA62: 'ldsx命令を無効にする'
# 'Disable lifetime-markers emission even when optimizations are enabled'
HBD15CF06A54D: '最適化が有効の場合でもlifetime-markersの出力を無効にする'
# 'Disable linemarker output and preprocess to stdout'
HA445684726D8: 'ラインマーカー出力を無効にし、標準出力へプリプロセス'
# 'Disable linemarker output in -E mode'
HF1226A7F981C: '-Eモードでのラインマーカー出力を無効にする'
# 'Disable linker dead stripping of globals in AddressSanitizer'
H529E513B965C: 'AddressSanitizerのグローバル変数のリンカーデッドストリッピングを無効にする'
# 'Disable linker relaxation'
H1AC503411592: 'リンカーリラクセーションを無効にする'
# 'Disable live use priority in sched=list-ilp'
H265D7EB1A110: 'sched=list-ilpでのlive use priorityを無効にする'
# 'Disable load widening'
HE007529C1391: 'ロード幅拡大を無効にする'
# 'Disable load-acquire and store-release insns'
HC50A5A53467A: 'ロード・アキュアとストア・リリース命令を無効にする'
# 'Disable load/store vectorizer'
H0E242722155F: 'ベクタライザの読み込み/書き込みを無効にする'
# 'Disable loading default configuration files'
H3C44B12DD359: 'デフォルトの設定ファイルの読み込みを無効にする'
# 'Disable looking for compound instructions for Hexagon'
HD818D391C2CA: 'Hexagonの複合命令の検出を無効にする'
# 'Disable looking for duplex instructions for Hexagon'
H3BEF6EB4C76F: 'Hexagonのデュプレックス命令の検出を無効にする'
# 'Disable loop unrolling in all relevant passes'
H8679BDFD2EE8: '関連するすべてのパスでのループ展開を無効にする'
# 'Disable loop-level heuristics.'
H3756953B43F4: 'ループレベルのヒューリスティクスを無効にする'
# 'Disable machine peepholes for BPF'
H195E092FC1CB: 'BPFのマシン・ピープホール最適化を無効にする'
# 'Disable machine peepholes for PPC'
HD0AFF1F89154: 'PPCのマシン・ピープホール最適化を無効にする'
# 'Disable memory access instrumentation in ThreadSanitizer'
H29829654F38C: 'ThreadSanitizerのメモリアクセスインストルメンテーションを無効にする'
# 'Disable memory promotion in LICM pass'
HFD9EDE137232: 'LICMパスでのメモリプロモーションを無効にする'
# 'Disable merging into combines'
H1147057C0FDD: 'コンビンの結合を無効にする'
# 'Disable merging of globals'
H0911384E3022: 'グローバル変数の結合を無効にする'
# 'Disable minimum alignment of 1 for arguments passed by value on stack'
HAF9C1AF67E2F: 'スタック値渡し引数の最小アライメント1を無効にする'
# 'Disable mitigations for Load Value Injection (LVI)'
HE89F1385E864: 'Load Value Injection (LVI) 対策を無効にする'
# 'Disable module-based external API notes support'
H8FEB52AFA393: 'モジュールベースの外部APIメモサポートを無効にする'
# 'Disable modules for C++'
H95B7103D9331: 'C++のモジュールを無効にする'
# 'Disable movsx insns'
H904B978BABF1: 'movsx命令を無効にする'
# 'Disable multi-region partial inlining'
H11B004AA7429: '複数領域部分内包を無効にする'
# 'Disable multi-threading within MLIR, overrides any further call to MLIRContext::enableMultiThreading()'
HE606F0AD2719: 'MLIR内のマルチスレッドを無効にし、MLIRContext::enableMultiThreading()の後続呼び出しを上書きします'
# 'Disable multiplicative reductions'
H68023B4BA449: '乗算簡約化を無効にする'
# 'Disable no-stall priority in sched=list-ilp'
H41669C812FF9: 'sched=list-ilpのno-stallプライオリティを無効にする'
# 'Disable non conforming code from compiling (default)'
HC27C523454B5: '非準拠コードのコンパイルを無効にする（デフォルト）'
# 'Disable non-allocatable physical register copy optimization'
H9F6E8121BA35: '非割り当て可能物理レジスタのコピー最適化を無効にする'
# 'Disable odd single-precision floating point registers'
HC69012E33908: '奇数の単精度浮動小数点レジスタを無効にする'
# "Disable omitting 'dls lr, lr' instructions"
HBB8A633ECC4C: "'dls lr, lr'命令の省略を無効にする"
# 'Disable on-demand initialization of thread-local variables'
HD53AA5AC4AC6: 'スレッド局所変数のオンデマンド初期化を無効にする'
# 'Disable one or more combiner rules temporarily in '
HD45ADA00F46A: '一時的に以下のcombinerルールを無効にする '
# 'Disable optimization'
HD31C9965E766: '最適化を無効にする'
# 'Disable optimizations based on strict aliasing rules'
H0CE3F6B4E092: '厳密な別名ルールに基づく最適化を無効にする'
# 'Disable optimizations based on vtable pointer identity'
HB754D32A5739: 'vtableポインタ同一性に基づく最適化を無効にする'
# 'Disable optimize'
H7A717771741E: '最適化を無効にする'
# 'Disable optimized frm insertion.'
HC173F38AB5E6: '最適化されたfrm挿入を無効にする'
# 'Disable origins tracking in MemorySanitizer'
H6CD4173EEC53: 'MemorySanitizerのorigins追跡を無効にする'
# 'Disable output'
H10D88D0CF0F6: '出力の生成を無効にする'
# 'Disable partial inlining'
H928A39907BEB: '部分的インライン化を無効にする'
# 'Disable physreg def-use affinity'
HC8A2DB30E27A: 'physregの定義-使用アフィニティを無効にする'
# 'Disable platform support explicitly'
H0A0D6D39B390: '明示的にプラットフォームサポートを無効にする'
# 'Disable poisoning array cookies when using custom operator new[] in AddressSanitizer'
H04ADC5D02283: 'AddressSanitizerでカスタムオペレーターnew[]を使用する際の配列cookieの汚染を無効にする'
# 'Disable polly legality check'
H4B855C14E497: 'Pollyの合法性チェックを無効にする'
# 'Disable pre-instrumentation inliner'
H6AAEA4B38739: 'プリインストゥルメンテーションインライナーを無効にする'
# 'Disable pre-register allocation tail duplication'
H74925BF6B59C: 'プリレジスタ割り当て後の末尾重複を無効化'
# 'Disable precise memory mode (AMDGPU only)'
H638CDA8718C5: '正確なメモリモードを無効化（AMDGPU専用）'
# 'Disable precompiled headers, overrides /Yc and /Yu'
HA85F69F96408: 'プリコンパイルド ヘッダを無効化（/Yc および /Yu の設定を上書き）'
# 'Disable predefined and command line preprocessor macros'
HB44C3311DC89: '事前定義済みおよびコマンドラインプリプロセッサマクロを無効化'
# 'Disable predefined target OS macros'
H55CEC6079E93: '事前定義済みターゲットOSマクロを無効化'
# "Disable printing the 'ready' prompt"
H60B484C23636: "'ready' プロンプトの出力を無効化"
# 'Disable probability-driven block placement'
H99FD887473AA: '確率に基づくブロック配置を無効化'
# 'Disable promote alloca to LDS'
H12640892E5F6: 'allocaをLDSへのプロモーションを無効化'
# 'Disable promote alloca to vector'
H58F548447B08: 'allocaをベクターへのプロモーションを無効化'
# 'Disable protection against removing loop preheaders'
H11458F88A73B: 'ループプリヘッダー削除防止を無効化'
# 'Disable raw string literals'
H5372647D5F22: '生文字列リテラルを無効化'
# 'Disable real(KIND=10) from TargetCharacteristics'
H7AB18BD04A08: 'TargetCharacteristicsからreal(KIND=10)を無効化'
# 'Disable real(KIND=3) from TargetCharacteristics'
H184DC371A7A3: 'TargetCharacteristicsからreal(KIND=3)を無効化'
# 'Disable recovery for specified sanitizers'
HA007863682E4: '指定されたサンitizerの回復機能を無効化'
# 'Disable regpressure priority in sched=list-ilp'
HF6314D19EB9F: 'sched=list-ilpでのレジスタプレッシャー優先度を無効化'
# 'Disable removal of sext.w'
HB0977BC6B970: 'sext.w削除を無効化'
# 'Disable removal of sign-extend insn'
H484EAB4F216F: '符号拡張命令の削除を無効化'
# 'Disable replace with vector math call pass'
HC8A504A99877: 'ベクターマスコール置換パスを無効化'
# "Disable retain SubstTemplateTypeParmType nodes in the AST's representation of alias template specializations"
H7BAFBB14B677: 'エイリアステンプレート固有化のAST表現におけるSubstTemplateTypeParmTypeノードの保持を無効化'
# 'Disable sanitizer coverage instrumentation for modules and functions that match the provided special case list, even the allowed ones'
H8AE573AF38D9: '特別なケースリストに一致するモジュールや関数（許可されたものも含む）に対するsanitizerカバレッジインストルメンテーションを無効化'
# 'Disable sanitizer metadata for modules and functions that match the provided special case list'
H09C17F700040: '提供された特殊ケースリストに一致するモジュールと関数のsanitizerメタデータを無効にします'
# 'Disable sanitizer statistics gathering.'
HFB69298094E2: 'sanitizerの統計収集を無効にします'
# 'Disable sc.q instruction.'
H283A06DB04BD: 'sc.q命令を無効にします'
# 'Disable schedule adjustment for new value stores.'
H391300C49ACE: '新しい値のストアのスケジュール調整を無効にします'
# 'Disable scheduled-height priority in sched=list-ilp'
H9402AC53BA7A: 'sched=list-ilpでのscheduled-height優先度を無効にします'
# "Disable scheduler's two-address hack"
HE3E8E40A1932: 'スケジューラのtwo-address hackを無効にします'
# 'Disable scheduling addi instruction beforeload for ppc'
H06295571D2AE: 'ppc向けのaddi命令のbeforeloadスケジューリングを無効にします'
# 'Disable sdiv/smod insns'
HE1C6E99EA2FD: 'sdiv/smod命令を無効にします'
# 'Disable select to branch conversion.'
H3543CDE71CB9: 'selectからブランチへの変換を無効にします'
# 'Disable sharing the FileManager when building a module implicitly'
H8B60BD26410A: '暗黙的なモジュール構築時にFileManagerの共有を無効にします'
# 'Disable simplify-libcalls'
H49E652857C1A: 'simplify-libcallsを無効にします'
# 'Disable small data sections sorting'
H8333FC4754B0: '小規模データセクションの並べ替えを無効にします'
# 'Disable specific target library builtin function'
HC0FDBC3C7F0C: '特定のターゲットライブラリ組み込み関数を無効にします'
# 'Disable speculative execution side effect suppression (SESES)'
HC1901080B0A5: '投機実行の副作用抑制（SESES）を無効にします'
# 'Disable spell-checking'
HF73309AEBDCA: 'スペルチェックを無効にします'
# 'Disable splitting double registers'
H5E3AECE38535: 'ダブルレジスタの分割を無効にします'
# 'Disable stack clash protection'
H8811AFD259AC: 'スタッククラッシュ保護を無効にします'
# 'Disable stack coloring'
HC094CB265B68: 'スタックの色付けを無効にします'
# 'Disable stack probes which are enabled by default'
H7F863834E502: 'デフォルトで有効になっているスタックプローブを無効にします'
# 'Disable standard #include directories for the C++ standard library'
HED953CC1E7C1: 'C++標準ライブラリの標準#includeディレクトリを無効にします'
# 'Disable standard system #include directories'
HAB8A8040E467: '標準システム #include ディレクトリを無効にする'
# 'Disable standard system #include directories only'
HA5DB077BC490: '標準システム #include ディレクトリのみを無効にする'
# 'Disable store widening'
H4BB106975BD7: 'ストア拡張を無効にする'
# 'Disable store(extract) optimizations in CodeGenPrepare'
HD78BB1861BFD: 'CodeGenPrepare での store(extract) 最適化を無効にする'
# 'Disable string pooling'
HC733A3918F74: '文字列プールを無効にする'
# 'Disable strip W suffix'
HF34CE2AC1BA4: 'W サフィックスの除去を無効にする'
# 'Disable support for K&R C function declarations'
HEA32A58B7196: 'K&R C 関数宣言のサポートを無効にする'
# 'Disable support for exception handling'
HAC5AC768AAF8: '例外処理のサポートを無効にする'
# 'Disable support for int128_t type'
H064E25645BF2: 'int128_t 型のサポートを無効にする'
# 'Disable symbolizing crash backtraces.'
HA299A2AEAED6: 'クラッシュ バックトレースのシンボル化を無効にする'
# 'Disable tail call optimization, keeping the call stack accurate'
H8EF83315B758: 'Tail call 最適化を無効にする（コール スタックの正確性を維持）'
# 'Disable tail duplication'
HACA1C01DCC7A: 'Tail 重複を無効にする'
# 'Disable tail folding'
HA81C7EA6791A: 'Tail 折り畳みを無効にする'
# 'Disable tail-predication in the ARM LowOverheadLoop pass'
HF132A6CB93FD: 'ARM LowOverheadLoop パスでの Tail プレデイケーションを無効にする'
# 'Disable that single precision floating-point divide and sqrt used in '
H475D4ABE9D62: 'シングル プレシジョン 浮動小数点除算と sqrt の使用を無効にする'
# 'Disable the ARM Parallel DSP pass'
H8178C8159BC2: 'ARM Parallel DSP パスを無効にする'
# 'Disable the CFI fixup pass'
H170DD55153F0: 'CFI fixup パスを無効にする'
# 'Disable the Sparc delay slot filler.'
HDE8C0A85D477: 'Sparc デリーブ スロット フィラーを無効にする'
# 'Disable the abort'
H9CB580C2DD7C: 'abort を無効にする'
# 'Disable the abort but emit a diagnostic on failure'
H84A7D406A5F3: 'abort を無効にするが、失敗時には診断を出力する'
# 'Disable the emission of assembler pseudo instructions'
H9E100408BFFF: 'アセンブリ仮命令の生成を無効にします'
# 'Disable the expand reduction intrinsics pass from running'
H040AA8C3CBF5: 'reduction intrinsicの展開を無効にします'
# 'Disable the generation of 4-operand madd.s, madd.d and related instructions.'
HB91438C02652: '4オペランドのmadd.s、madd.dおよび関連命令の生成を無効にします'
# 'Disable the generation of low-overhead loops'
H1104A5C142EF: '低オーバーヘッドループの生成を無効にします'
# 'Disable the integrated assembler'
H779AD38A6D36: '統合アセンブラの使用を無効にします'
# 'Disable the loop interchange pass'
H8A139F798C85: 'ループ順置換最適化を無効にします'
# 'Disable the loop vectorization passes'
H55BB6EBCE09F: 'ループベクタライゼーションの最適化を無効にします'
# 'Disable the module hash'
H7FE90FAE4F03: 'モジュールハッシュの使用を無効にします'
# 'Disable the parsing of an implicit top-level module op'
HF5D65FFCFADF: 'トップレベルのモジュールopの暗黙のパースを無効にします'
# 'Disable the pass entirely'
HA841AC9C39A5: '最適化全体を無効にします'
# 'Disable the peephole optimizer'
H5AEFA90F7A64: 'マクロ命令最適化を無効にします'
# 'Disable the select-optimization pass from running'
H0DA28C5C19DF: 'select最適化パスの実行を無効にします'
# 'Disable the usage of LEB128 directives, and generate .byte instead.'
HFFB7D99931FD: 'LEB128ディレクティブの使用を無効にし、代わりに.byteを使用します'
# 'Disable the use of non-volatile CR register fields'
H01F2C9F9FECF: '非揮発性CRレジスタフィールドの使用を無効にします'
# 'Disable the use of stack protectors'
HCC816F874533: 'スタックプロテクタの使用を無効にします'
# 'Disable the vector mask scheduling mutation'
H6FF8BC95F625: 'ベクターマスクスケジューリング変異を無効にします'
# 'Disable the verifier on parsing (very unsafe)'
H314B68416CA8: 'パース時の検証を無効にします（非常に危険）'
# 'Disable the wasm-opt optimizer'
H214565A17764: 'wasm-opt最適化を無効にします'
# 'Disable thread-safe initialization of static variables'
H9A6053E9675B: '静的変数のスレッドセーフ初期化を無効にします'
# 'Disable threadgroup split execution mode (AMDGPU only)'
HFE9B2C98E16A: 'AMDGPU専用のスレッドグループ分割実行モードを無効にします'
# 'Disable trapping for all sanitizers'
H434CA7F72650: 'すべてのsanitizersのトラッピングを無効にします'
# 'Disable trapping for specified sanitizers'
H8374BC4644FA: '指定したsanitizersのトラッピングを無効にします'
# 'Disable treating throwing global C++ operator new as always returning valid memory (annotates with __attribute__((returns_nonnull)) and throw()). This is detectable in source.'
H1293614D97E9: 'グローバルなC++オペレーターnewが常に有効なメモリを返すとみなさないようにする（__attribute__((returns_nonnull))とthrow()でアノテーションされます）。ソースコード内で検出可能です。'
# 'Disable trigraphs (default)'
H739A08E7CEDE: 'Trigraphを無効に（デフォルト）'
# 'Disable two address hints for register allocation'
H82ADA80F88F5: 'レジスタ割り当てのためのtwo address hintsを無効にします'
# 'Disable two-phase name lookup in templates (default)'
HB877DF6B6337: 'テンプレートでのtwo-phase名前解決を無効に（デフォルト）'
# 'Disable type promotion pass'
HE0F6634D8D16: '型のプロモーションパスを無効にします'
# 'Disable unclustered high register pressure reduction scheduling stage.'
HAE3C6A80BF96: 'クラスタ化されていない高レジスタプレッシャー削減スケジューリング段階を無効にします'
# 'Disable unused template argument warnings.'
H8A2178DF0ED5: '使用されていないテンプレート引数の警告を無効にします'
# 'Disable use of DFA during scheduling'
HFCEBEB8744EF: 'スケジューリング中にDFAを使用しないようにする'
# 'Disable use of LD/ST pairs for SME2 or SVE2p1'
H886738D62F05: 'SME2またはSVE2p1のためのLD/STペアの使用を無効にします'
# 'Disable use of builtin functions'
H6011A85599FF: '組み込み関数の使用を無効にします'
# 'Disable use-after-destroy detection in MemorySanitizer'
H76DBA1F549C7: 'MemorySanitizerでのuse-after-destroy検出を無効にします'
# 'Disable use-after-scope detection in AddressSanitizer'
HDEA7FE9A7621: 'AddressSanitizerでのuse-after-scope検出を無効にします'
# 'Disable using constant pool for large integers.'
H8489E618879C: '大規模な整数のための定数プールの使用を無効にします'
# 'Disable using instrumentation data for profile-guided optimization'
H0DABDB711ED0: 'プロファイルガイド最適化のためのインストゥルメンテーションデータの使用を無効にします'
# 'Disable using library calls for save and restore'
HABD1CF6BBA21: '保存と復元のためのライブラリコールの使用を無効にします'
# 'Disable validation'
H26FB09D2AB0A: '検証を無効にします'
# 'Disable validation of precompiled headers'
H2DA6E28812C6: 'プリコンパイル済みヘッダーの検証を無効にします'
# 'Disable validation of the diagnostic options when loading the module'
HE4C65ABEFA0D: 'モジュールのロード時に診断オプションの検証を無効にします'
# 'Disable vector double new-value-stores'
H46E40B609BEA: 'ベクターダブル new-value-stores を無効にする'
# 'Disable verification of LLVM IR'
H1AB74862104E: 'LLVM IR の検証を無効にする'
# 'Disable virtual register cycle interference checks'
H2BA1419A0C46: '仮想レジスタのサイクル干渉チェックを無効にする'
# 'Disable whole program visibility (overrides enabling options)'
H1D60C5E310B2: '全プログラム可視性を無効にする（有効化オプションを上書きします）'
# 'Disable writing diagnostic options'
H37E0E37A8998: '診断オプションの記録を無効にする'
# 'Disable writing header search paths'
HCFD8074000E3: 'ヘッダ検索パスの記録を無効にする'
# 'Disable x86 relax relocations'
HB7F95908656B: 'x86 の relax 再配置を無効にする'
# 'Disabled.'
HBC2D62F7229F: '無効化されました。'
# 'Disables -fvisibility-inlines-hidden-static-local-var (this is the default on non-darwin targets)'
H2552506748D2: 'オプション -fvisibility-inlines-hidden-static-local-var を無効にします（darwin 以外のターゲットでは既定値です）'
# 'Disables combining addressing modes with different parts in optimizeMemoryInst.'
H1A57049BF682: 'optimizeMemoryInst で異なる部分を組み合わせるアドレッシング モードを無効にします'
# 'Disables debug printing for the new pass manager'
H92F40F826D39: '新しいパス マネージャのデバッグ出力を無効にします'
# 'Disables evaluation of GetElementPtr with constant operands'
H5A42772B82EF: '定数オペランドを持つ GetElementPtr の評価を無効にします'
# 'Disables inttoptr/ptrtoint roundtrip optimization'
H03E816B33DC1: 'inttoptr/ptrtoint ラウンドトリップ オプティマイゼーションを無効にします'
# 'Disables potentially expensive checks in the transform interpreter, providing more speed at the expense of potential memory problems and silent corruptions'
H8C53B2F32644: '変換インタプリタの高コストなチェックを無効にし、潜在的なメモリ問題や無音の破損のリスクを負う代わりに速度向上を図ります'
# 'Disables the global instruction selector'
HD7298FC773DA: 'グローバル命令セレクタを無効にします'
# "Disallow '$' in identifiers"
HEC529DE7E6EB: '識別子での "$" の使用を禁止します'
# 'Disallow MIPS delay filler to search backward.'
H93B2211830F9: 'MIPS ディレイ フィラーが後方検索することを禁止します'
# 'Disallow MIPS delay filler to search forward.'
H0A7403D7CADA: 'MIPS ディレイ フィラーが前方検索することを禁止します'
# 'Disallow MIPS delay filler to search successor basic blocks.'
H806FD91060E7: 'MIPS ディレイ フィラーが後続の基本ブロックを検索することを禁止します'
# 'Disallow __declspec as a keyword'
HC17ADE50EB84: '__declspec をキーワードとして使用することを禁止します'
# "Disallow alternative token representations '<:', ':>', '<%', '%>', '%:', '%:%:'"
HF519C51A2110: "代替トークン表現 '<:', ':>', '<%', '%>', '%:', '%:%:' の使用を禁止"
# 'Disallow atomic operations to ignore denormal mode'
HE8CD8EB9071A: 'デノーマル モードを無視する原子操作を禁止'
# 'Disallow complex IT blocks'
H020AA42EE64B: '複雑な IT ブロックの使用を禁止'
# 'Disallow converting instructions with negative immediates to their negation or inversion.'
H4A70CE206CB7: '負の即値をもつ命令をその否定または反転に変換することを禁止'
# 'Disallow generation of complex IT blocks. It is off by default.'
HB67D63CAAB67: '複雑な IT ブロックの生成を禁止. デフォルトでは無効です'
# 'Disallow generation of data access to code sections (AArch64/ARM only)'
HF9C8C76A5FB2: 'コード セクションへのデータ アクセスの生成を禁止 (AArch64/ARM 専用)'
# 'Disallow merging of constants'
H70C4FD1FC35B: '定数のマージを禁止'
# 'Disallow use of CRC instructions (ARM only)'
HB840DEC2FEB5: 'CRC命令の使用を禁止 (ARM 専用)'
# 'Disallow use of CRC instructions (Mips only)'
H9E92A4FAF94C: 'CRC命令の使用を禁止 (Mips 専用)'
# 'Disallow use of movt/movw pairs (ARM only)'
H1C82DB59E408: 'movt/movw ペアの使用を禁止 (ARM 専用)'
# 'Disassemble strings of hex bytes'
H613CDE699EC0: '16進バイトの文字列を逆アセンブル'
# 'Disassembler Options'
H4DCD7C09D805: 'ディアセンブラー オプション'
# 'Disassembler options'
H44D3EF88EF05: 'ディアセンブラー オプション'
# 'Discard names from Value (other than GlobalValue).'
H742AC63D224D: 'GlobalValue 以外の Value から名前を削除'
# 'Discard value names in LLVM IR'
HCD7AD84832F7: 'LLVM IR 内の値名を削除'
# 'Discarded elements by the linker.'
HD3934CD11684: 'リンカによって削除された要素'
# 'Discriminator.'
H206A9AC4C507: 'ディスクリミネーター'
# 'Discriminators for inlined function instances.'
HCFDAECEFD17E: 'インライン化された関数インスタンスのディスクリミネーター'
# "Display PDB's MS system elements."
H9055330B7E79: 'MS システム要素を表示 (PDB)'
# 'Display all available options'
H4F3544FDA0B5: '利用可能なすべてのオプションを表示'
# 'Display all basic blocks'
H75BB63BE80F7: 'すべての基本ブロックを表示します'
# 'Display all class members including data, constants, typedefs, functions, etc'
HCA18E04B4029: 'クラスのメンバーすべてを表示（データ、定数、typedef、関数なども含む）'
# 'Display all symbols (default)'
H809598610BD8: 'すべてのシンボルを表示（デフォルト）'
# 'Display all types (implies -classes, -enums, -typedefs)'
H5D20AC3AE6F6: 'すべてのタイプを表示（-classes、-enums、-typedefsを含む）'
# 'Display any symbol or type with the specified exact name'
H2B91D0A39EC5: '指定された正確な名前のシンボルまたはタイプを表示'
# 'Display arrays'
HDC2B25BF5710: '配列を表示'
# 'Display available options'
H46A7DC1788BB: '利用可能なオプションを表示'
# 'Display available options (--help-hidden for more)'
HB2294B093626: '利用可能なオプションを表示 (--help-hiddenで詳細を表示)'
# 'Display branch counts instead of percentages (requires -b)'
HE5D58860A9A5: '分岐回数を表示（パーセンテージではなく）（-bオプションが必要）'
# 'Display branch probabilities'
H1A848099A8E1: '分岐確率を表示'
# 'Display class types'
H4B4B15B36D12: 'クラス型を表示'
# 'Display compilands'
H98204E2FD2A3: 'コンパイル対象を表示'
# 'Display data symbols'
HE0831CC1C7E5: 'データシンボルを表示'
# 'Display each error as well as a summary. [default]'
HB4E9ED4A232D: '各エラーと要約を表示します。[デフォルト]'
# 'Display each error in detail but no summary.'
H84BA445E865B: '各エラーを詳細に表示しますが、要約は表示しません。'
# 'Display enum types'
H7D0238663B0A: 'enum型を表示'
# 'Display execution times'
HA3302D5C387F: '実行時間を表示'
# 'Display exploded graph using GraphViz'
H57BD4170B555: 'GraphVizを使用した爆発グラフを表示'
# 'Display function signatures'
H616CCB32163A: '関数シグネチャを表示'
# 'Display function symbols'
H2496573880E0: '関数シンボルを表示'
# 'Display help for hidden options'
H64D149DE5706: '非表示オプションのヘルプを表示'
# 'Display include stacks for diagnostic notes'
HBF49F525A9C8: '診断ノートのインクルードスタックを表示'
# 'Display injected sources'
H615D1D35669F: '埋め込まれたソースを表示'
# 'Display list of all available options'
HC3085F81E368: '利用可能なすべてのオプションの一覧を表示'
# 'Display list of available options (--help-list-hidden for more)'
H6C69B229E72D: '利用可能なオプションの一覧を表示 (--help-list-hiddenで詳細)'
# "Display lists of good files (no compile errors), problem files, and a combined list with problem files preceded by a '#'."
HC6E030BB5330: "コンパイルエラーのないファイル、問題があるファイル、および問題ファイルを'#'で始まるリストと統合した一覧を表示します。"
# 'Display method for pass statistics'
H93E064D4A3FD: 'passの統計情報を表示する方法を表示'
# 'Display method for timing data'
H6D05268C903F: 'タイミングデータを表示する方法を表示'
# 'Display more information when dumping selection DAG nodes.'
H7335ABA75176: '選択DAGノードのダンプ時に詳細情報を表示'
# 'Display only a summary of the errors found.'
HD9988E75DBC1: '検出されたエラーの要約のみを表示'
# 'Display patch-like changes'
H944897EBC1CF: 'パッチ形式の変更を表示'
# 'Display patch-like changes in quiet mode'
H1874C26C00E8: 'クイートモードでパッチ形式の変更を表示'
# 'Display patch-like changes in quiet mode with color'
HDA3927492A7C: 'クイートモードで色付けしてパッチ形式の変更を表示'
# 'Display patch-like changes with color'
HC5827DF84A7E: '色付けしたパッチ形式の変更を表示'
# 'Display pointer types'
H5EE2D9F1E113: 'ポインタータイプを表示'
# 'Display statistics as json data'
H332F68176CB1: 'JSON形式で統計情報を表示'
# 'Display suggestions to update code associated with -Wunsafe-buffer-usage warnings'
H5B046555524E: '危険なバッファ使用に関する警告(-Wunsafe-buffer-usage)と関連するコードの更新案を表示'
# 'Display symbols for each compiland'
H087A1D8A2407: '各コンパイルユニットのシンボルを表示'
# 'Display the SLP trees with Graphviz'
H5A01A170758F: 'Graphvizを使用してSLPツリーを表示'
# "Display the compiler's target processor"
HFDA3133B76AB: 'コンパイラのターゲットプロセッサを表示'
# 'Display the count broken down by the filepath of each remark emitted. Requires remarks to have DebugLoc information.'
HDD5492CA6C68: '各リマークのファイルパスごとにカウントを分解して表示します。リマークにはDebugLoc情報が必要です。'
# 'Display the list of -analyzer-config options. These are meant for development purposes only!'
HEEAD9A5EE121: '-analyzer-config オプションのリストを表示します。これらは開発目的専用です!'
# 'Display the list of analyzer checkers that are available'
H74EADAEE0F8E: '利用可能なアナライザーチェッカのリストを表示します'
# 'Display the list of checker and package options'
H9FD261E9343C: 'チェッカとパッケージのオプションのリストを表示します'
# 'Display the list of checker and package options meant for development purposes only'
H99D575B08548: '開発目的専用のチェッカとパッケージのオプションのリストを表示します'
# 'Display the list of developer-only checkers such as modeling and debug checkers'
H5D875C21A22A: 'モデリングやデバッグチェッカなど、開発者専用のチェッカのリストを表示します'
# 'Display the list of enabled analyzer checkers'
HDD1AC8873D07: '有効になっているアナライザーチェッカのリストを表示します'
# 'Display the list of in development analyzer checkers. These are NOT considered safe, they are unstable and will emit incorrect reports. Enable ONLY FOR DEVELOPMENT purposes'
H9701D9AE6717: '開発中のアナライザーチェッカのリストを表示します。これらは安全と見なされず、不安定で誤った報告を発行する可能性があります。開発目的でのみ有効にしてください'
# 'Display the list of in development checker and package options. These are NOT considered safe, they are unstable and will emit incorrect reports. Enable ONLY FOR DEVELOPMENT purposes'
H44975E30827B: '開発中のチェッカとパッケージのオプションのリストを表示します。これらは安全と見なされず、不安定で誤った報告を発行する可能性があります。開発目的でのみ有効にしてください'
# 'Display the statistics of each pass'
HC9CD9384324F: '各パスの統計情報を表示します'
# 'Display the version of the compiler'
H5C279623CA4C: 'コンパイラのバージョンを表示します'
# 'Display the version of this program'
H5228B6ADFC09: 'このプログラムのバージョンを表示します'
# 'Display thunk symbols'
H60D32CD26A79: 'スラックシンボルを表示します'
# 'Display typedef types'
H80D29E660696: 'typedefタイプを表示します'
# 'Display unconditional branch info (requires -b)'
H860C02BEA720: '無条件ブランチ情報の表示（-bオプションが必要です）'
# 'Display vftable shapes'
H0BAEA6CF044D: 'VFTABLEの形状を表示します'
# 'Displays only those classes which have at least the specified amount of immediate padding, ignoring padding internal to bases and aggregates.'
H4365E41B0200: '基底クラスや聚合型内のパディングを無視し、指定された量以上の直接的なパディングを有するクラスのみを表示します。'
# 'Displays only those classes which have at least the specified amount of padding.'
HC457A02E6744: '指定された量以上のパディングを有するクラスのみを表示します。'
# 'Displays only those types which are greater than or equal to the specified size.'
H939E231DB942: '指定されたサイズ以上である型のみを表示します。'
# 'Divisor of cold branch probability.BranchProbability = 1/ColdBranchProbDenom'
HFEB48317469C: 'Cold branch probabilityの除数。BranchProbability = 1/ColdBranchProbDenom'
# 'Do PGO instrumentation sampling'
H20E4EAC6B490: 'PGO instrumentation sampling を実行する'
# 'Do counter register promotion'
H9B115D4FE5B7: 'カウンタレジスタのプロモーションを実行する'
# 'Do counter update using atomic fetch add  for promoted counters only'
H7767713DC2D0: 'プロモーションされたカウンタのみに、atomic fetch add を使用してカウンタを更新する'
# 'Do more PHI writes than necessary in order to avoid partial accesses'
HE1D29CA7DAB8: '一部のアクセスを回避するために、必要な以上の PHI 書き込みを実行する'
# 'Do not accept non-standard constructs supported by the z/OS compiler'
HD8F703A83AED: 'z/OS コンパイラでサポートされている非標準構文を受け付けない'
# 'Do not add %INCLUDE% to include search path'
H7E3445F24099: '%INCLUDE% をインクルード検索パスに追加しない'
# 'Do not add -rpath with architecture-specific resource directory to the linker flags. When --hip-link is specified, do not add -rpath with HIP runtime library directory to the linker flags'
H98822B20FC31: 'アーキテクチャ固有のリソースディレクトリを指定する -rpath をリンカーフラグに追加しない. --hip-link が指定された場合、HIP ランタイムライブラリディレクトリを指定する -rpath もリンカーフラグに追加しない'
# 'Do not add a BTI instruction after a setjmp or other return-twice construct (Arm/AArch64 only)'
H97946DA95B7B: 'setjmp または他の return-twice 構文の後に BTI 指令を追加しない (Arm/AArch64 専用)'
# 'Do not add include paths for CUDA/HIP and do not include the default CUDA/HIP wrapper headers'
HCB5DBE4305C2: 'CUDA/HIP のインクルードパスを追加せず、デフォルトの CUDA/HIP ウララーヘッダーも含めない'
# 'Do not add instruction count to lsr cost model'
HE7651E5EC0B1: 'lsr コストモデルに命令数を追加しない'
# 'Do not add parameter bounds and do no gist simplify sets accordingly'
HC6FB1327B189: 'パラメータの境界を追加せず、gist 簡略化セットも対応して行わない'
# 'Do not align and prefetch loops'
HFA5D85E291BA: 'ループのアライメントとプリフェッチを実行しない'
# 'Do not allocate the LR register for general purpose usage, only for calls. (AArch64 only)'
H80E0CE8F43D2: 'LR レジスタを汎用使用ではなく、呼び出し専用とする (AArch64 専用)'
# 'Do not allow compiler to merge handlers for any sanitizers'
HC4FB93EDAFBC: 'どのサンイザラもを対象としたハンドラのマージをコンパイラに許可しない'
# 'Do not allow compiler to merge handlers for specified sanitizers'
H14D0727FA9D4: '指定されたサンイザラもを対象としたハンドラのマージをコンパイラに許可しない'
# 'Do not assume C++ operator new may not return NULL'
H1F6F59A37FC5: 'C++ のオペレータ new が NULL を返さないことを想定しない'
# 'Do not assume that any loop is finite.'
H5580E1E87EBF: 'どのループも有限であると想定しない'
# 'Do not assume that externally defined data is in the small data if it meets the -G <size> threshold (MIPS)'
HAD54547B8D0E: '-G <size> のしきい値を満たす場合でも、外部定義データが small data にあると想定しない (MIPS)'
# 'Do not automatically generate or update the global module index'
H6DB4D9D7E3EF: 'グローバル モジュール インデックスを自動生成または更新しない'
# 'Do not automatically import modules for error recovery'
H8260A94CB46D: 'エラー回復用にモジュールを自動インポートしない'
# 'Do not build run-time checks to proof absence of integer wrapping'
H067730FFEE80: '整数オーバーフローがないことを検証するためのランタイムチェックを構築しない'
# 'Do not bundle output files of HIP device compilation'
H3591F62084D9: 'HIPデバイスコンパイルの出力ファイルをバンドルしない'
# 'Do not check authenticated address'
H0709C5934F02: '認証済みアドレスをチェックしない'
# 'Do not color Edges'
HAA019B0E453C: 'エッジの色付けを行わない'
# 'Do not color Vertices'
HCD93BE0D4AC9: '頂点の色付けを行わない'
# 'Do not color vertices'
H1FA039A4B956: '頂点の色付けを行わない'
# 'Do not combine ALU and memory operators'
H22D1C7806EDC: 'ALUとメモリオペレーターを組み合わせない'
# 'Do not consider inline-asm a scheduling/packetization boundary.'
H930DAD5CB7A3: 'インラインアセンブリをスケジューリング/パケット化の境界と見なさない'
# 'Do not convert branches that may exit the loop'
H912C8CC5220C: 'ループを脱出する可能性のある分岐を変換しない'
# 'Do not convert find-first-byte loop(s).'
H586B9EEE9F17: '最初のバイトを探すループを変換しない'
# 'Do not create a host fallback if offloading to the device fails.'
HFCABEED29F02: 'デバイスへのオフロードが失敗した場合、ホストのフォールバックを作成しない'
# 'Do not create extra branches to split comparison logic.'
H67D6951DD9C2: '比較ロジックを分割するために追加の分岐を作成しない'
# 'Do not create unit-strided loops (default)'
HA7BFEC1D48BB: '単一ストライドのループを作成しない（既定値）'
# 'Do not discard comments when preprocessing'
HF9B5FA45AABB: 'プリプロセス時にコメントを破棄しない'
# 'Do not discard value names in LLVM IR'
H4D77D8B34317: 'LLVM IRで値の名前を破棄しない'
# 'Do not dllexport/dllimport inline member functions of dllexport/import classes'
H178235CEFFFB: 'dllexport/importクラスのインラインメンバー関数にdllexport/dllimportを適用しない'
# 'Do not drop any type tests'
H0426A41590E9: '型テストをすべて削除しない'
# 'Do not dump MSF file headers'
H5B5B36671D5C: 'MSFファイルのヘッダーをダンプしない'
# 'Do not elide types when printing diagnostics'
HAAA41F99F968: '診断情報を表示する際に型の省略を行わない'
# 'Do not eliminate read instrumentation for read-before-writes'
HFAB29E5FAAB8: '読み取り前に書き込む場合の読み取りインストルメンテーションを削除しない'
# 'Do not embed'
H58D31A15C486: '埋め込みをしない'
# 'Do not emit  debug info for defined but unused types'
HB04F2AC6377B: '定義されたが使用されていない型のデバッグ情報を生成しない'
# 'Do not emit RTTI data'
H0669AFF65C8F: 'RTTI データを生成しない'
# "Do not emit a trap instruction for 'unreachable' IR instructions after noreturn calls, even if --trap-unreachable is set."
HB71318F0BBDA: "--trap-unreachableが設定されていても、noreturn呼び出し後の'unreachable' IR命令に対してトラップ命令を生成しない"
# 'Do not emit code that uses the red zone.'
H4923C3F307F8: 'レッドゾーンを使用するコードを生成しない'
# 'Do not emit code to make initialization of local statics thread safe'
HB028FFDC42D1: 'ローカル静的変数の初期化をスレッドセーフにするコードを生成しない'
# 'Do not emit code to perform on-demand initialization of thread-local variables'
HC624E884FFD9: 'スレッド局所変数のオンデマンド初期化を実行するコードを生成しない'
# 'Do not emit macro debug information'
H8F91A57AE16C: 'マクロのデバッグ情報を生成しない'
# 'Do not emit metadata containing compiler name and version'
HAB66E1C6275C: 'コンパイラ名とバージョンを含むメタデータを生成しない'
# 'Do not emit pseudo probes for sample profiling'
H98592A339F09: 'サンプルプロファイリング用の仮のプローブを生成しない'
# 'Do not emit remarks about assumptions that are known'
H0F5A09E813C1: '既知の仮定に関するリマインダーを出力しない'
# 'Do not enforce -fmodules-decluse and private header restrictions for textual headers. This flag will be removed in a future Clang release.'
H0CAD9E73AF57: 'テキストベースのヘッダーファイルに対して、-fmodules-decluseとプライベートヘッダー制限を強制しません。このフラグは将来的なClangリリースで削除されます。'
# 'Do not error on use of NSAllocateCollectable/NSReallocateCollectable'
HFB2D301661F8: 'NSAllocateCollectable/NSReallocateCollectableの使用時にエラーを出さない'
# 'Do not execute loaded code'
HAC6A8BA715B2: 'ロードされたコードを実行しない'
# 'Do not extend the -G behaviour to object local data (MIPS)'
HE38064F00B03: '-Gの動作をオブジェクトローカルデータに拡張しない（MIPS専用）'
# 'Do not fail and just print warnings.'
H194F6AFAEB48: 'エラーを終了せずに警告のみを表示する'
# 'Do not fail on the first error.'
H09A7570CEE99: '最初のエラーで終了しない'
# 'Do not follow the AAPCS standard requirement stating that volatile bit-field width is dictated by the field container type. (ARM only).'
H33C6AFA87C27: 'AAPCS規格で定義された揮発性ビットフィールドの幅がフィールドコンテナ型に依存することを要求しない（ARMのみ）'
# 'Do not generate code for uses of this PCH that assumes an explicit object file will be built for the PCH'
H882EA3DF4A8E: 'このPCHの使用時にPCHのための明示的なオブジェクトファイルが生成されることを仮定するコードを生成しない'
# 'Do not generate comments'
H64C7ECF357DC: 'コメントを生成しない'
# 'Do not generate debug info for types in an object file built from this PCH and do not generate them elsewhere'
H4C63A76D37C7: 'このPCHから作成されたオブジェクトファイル内の型のデバッグ情報を生成せず、他の場所でも生成しない'
# 'Do not generate load-load barrier instructions (dbar 0x700)'
H2C61D7A4E1E5: 'ロード-ロード バリア命令（dbar 0x700）を生成しない'
# 'Do not globally set the denormals-are-zero (DAZ) and flush-to-zero (FTZ) bits in the floating-point control register on program startup'
H792FD67CD9D7: 'プログラム起動時に浮動小数点制御レジスタのdenormals-are-zero（DAZ）およびflush-to-zero（FTZ）ビットをグローバルに設定しない'
# 'Do not hoist instructions if targetblock is N times hotter than the source.'
HFE3581AD2058: 'ターゲットブロックがソースのN倍ホットな場合、命令を引き上げない'
# "Do not include PTX for the following GPU architecture (e.g. sm_35) or 'all'. May be specified more than once."
H3358F862A98F: "以下のGPUアーキテクチャ（例: sm_35）または'all'のPTXを含めない。複数指定可能。"
# 'Do not include column number on diagnostics'
H6BC5ADEE7CCD: '診断情報に列番号を含めない'
# 'Do not include declarations inside namespaces (incl. global namespace) in the code-completion results.'
HB945B735ADE9: 'ネームスペース内（グローバルネームスペースを含む）の宣言をコード補完結果から除外する'
# 'Do not include fixit information in diagnostics'
H9F028B9AB9A0: '診断に修正情報（fixit）を含めない'
# 'Do not include global declarations in code-completion results.'
H5184034D4282: 'コード補完結果にグローバル宣言を含めない'
# 'Do not include source location information with diagnostics'
HC43E127B525B: '診断情報にソース位置情報を含めない'
# 'Do not include the default HIP wrapper headers and include paths'
HF033C0F0A8BE: 'デフォルトのHIPラッパー・ヘッダとインクルードパスを含めない'
# 'Do not inline functions with a stack size that exceeds the specified limit'
HF6E40440F4E2: '指定された制限を超えるスタックサイズを持つ関数をインライン化しない'
# 'Do not inline recursive functions with a stack size that exceeds the specified limit'
HE8D9228D38D0: '指定された制限を超えるスタックサイズを持つ再帰関数をインライン化しない'
# 'Do not instrument callsites to functions in this list. Intended for testing.'
HEEE67A6ADD3A: 'このリストの関数のコールサイトを計測対象から除外。テスト用。'
# 'Do not instrument functions smaller than this threshold.'
H0676C97A079B: 'この閾値より小さい関数を計測対象から除外'
# 'Do not instrument functions with the number of critical edges  greater than this threshold.'
HAC5F841AADEE: 'クリティカルエッジ数がこの閾値を超える関数を計測対象から除外'
# 'Do not instrument promotable allocas'
HFE692DA83BC2: 'promotable allocasの計測を無効化'
# 'Do not label Edges'
H02B067792434: 'Edgesにラベルを付与しない'
# 'Do not label Vertices'
HF8CF06D59C0D: 'Verticesにラベルを付与しない'
# 'Do not let object file auto-link default libraries'
H77A1B6D3EF99: 'オブジェクトファイルがデフォルトライブラリを自動リンクしないようにする'
# 'Do not link against HIP runtime libraries'
H29FEC2BA3B74: 'HIPランタイムライブラリへのリンカをリンクさせない'
# 'Do not link device library for CUDA/HIP device compilation'
HEC768FBA7D56: 'CUDA/HIPデバイスコンパイル用のデバイスライブラリをリンクしない'
# 'Do not make the jump table addresses canonical in the symbol table'
H6138F7A3816E: 'シンボルテーブルでジャンプテーブルのアドレスを標準化しない'
# 'Do not modify integer comparisons.'
H85B2E33EE3E8: '整数比較を変更しない'
# 'Do not omit the RTTI component from virtual tables'
H29D8FAD7370D: 'バーチャルテーブルからRTTIコンポーネントを省略しない'
# 'Do not optimize lifetime zones that are broken'
HDB8A084545A8: '破損したlifetime zonesの最適化を行わない'
# 'Do not output any .gcov files'
H5B1E0C37199B: '.gcovファイルを出力しない'
# 'Do not override toolchain to compile HIP source to relocatable'
H67099DA33091: 'HIPソースをリロケータブルにコンパイルするためにツールチェーンを上書きしない'
# 'Do not place constants in the .rodata section instead of the .sdata if they meet the -G <size> threshold (MIPS)'
H21A91E9ACB5C: '-G <サイズ> の閾値を満たす場合、.rodataセクションではなく.sdataセクションに定数を配置しない（MIPS限定）'
# 'Do not preserve comments in inline assembly'
H942DAB64A211: 'インラインアセンブリ内のコメントを保持しない'
# 'Do not prevent DecoderTable duplications caused by HwModes'
H38CABD41B4CC: 'HwModesによって引き起こされるDecoderTableの重複を防がない'
# 'Do not print instruction tables'
HF7003F2ECEFB: '指令テーブルを出力しない'
# 'Do not print per-code histogram'
HC08155C4172C: 'コードごとのヒストグラムを出力しない'
# 'Do not print the name of each compiled file (default)'
H5DF4E1712DEF: 'コンパイルされた各ファイルの名前を表示しない（既定値）'
# 'Do not process trigraph sequences'
H0D43C57804DE: 'トリグラフシーケンスを処理しない'
# 'Do not produce relaxation hints for linkers to try optimizing PIC call sequences into direct calls (MIPS only)'
HCE5BC5F9BE43: 'リンカにPICコールシーケンスを直接コールに最適化を試みさせるためのrelaxation hintsを生成しない（MIPSのみ）'
# 'Do not prune non-affecting module map files when writing module files'
H5ABD84685A1F: 'モジュールファイルを書く際、影響のないmodule mapファイルを削除しない'
# 'Do not put each data item in its own section (default)'
HF88D281A3FD5: '各データアイテムを個別のセクションに配置しない（既定値）'
# 'Do not put each function in its own section (default)'
HCE20256E9133: '各関数を個別のセクションに配置しない（既定値）'
# 'Do not re-analyze paths leading to exhausted nodes with a different strategy (may decrease code coverage)'
HDFE0F346053C: '異なる戦略で枯渇ノードに至るパスを再分析しない（コードカバレッジが低下する可能性あり）'
# 'Do not read real performance counters, use dummy values (for testing)'
H85D51A611E68: '実際のパフォーマンス カウンターを読み取らない。テスト用のダミー値を使用する（テスト用）'
# 'Do not rebase if number of dependent constants of a Base is less than this number.'
H5F4C154B55E1: 'ベースの依存定数の数がこの数未満の場合、rebase を行わない'
# 'Do not record stack ring history'
HFF15CDD011A3: 'スタック リングの履歴を記録しない'
# 'Do not remove finalize method in gc mode'
H986F722192B5: 'gc モードで finalize メソッドを削除しない'
# 'Do not remove function attributes'
HAF5DC7041092: '関数属性を削除しない'
# 'Do not remove global named metadata'
H8C721AA4D60E: 'グローバルな名前付きメタデータを削除しない'
# 'Do not remove global variables'
H715B487CBBAD: 'グローバル変数を削除しない'
# 'Do not remove implausible terminators or other similar cleanups'
HFBFADCCB2615: '不条理な終端や他の類似のクリーンアップを削除しない'
# 'Do not report an error for non-bitcode files in archives'
H656A3544880E: 'アーカイブ内のビットコードではないファイルに対してエラーを報告しない'
# 'Do not require member pointer base types to be complete if they would be significant under the Microsoft ABI'
H7A0FDA03C4CD: 'Microsoft ABI でそれらが重要である場合、メンバー ポインターのベース型が完全である必要がないようにする'
# "Do not resolve lli process symbols in JIT'd code"
HF4ADB638CB76: 'JIT コードで lli プロセス シンボルを解決しない'
# 'Do not resolve to llvm-jitlink process symbols'
H0C15A19D6DA3: 'llvm-jitlink プロセス シンボルを解決しない'
# 'Do not run the verifier'
H227D5D3081B9: '検証プログラムを実行しない'
# 'Do not run the verifier during the optimization pipeline'
H812C7F5AE104: '最適化パイプライン中に検証プログラムを実行しない'
# 'Do not run verifier on input LLVM (dangerous!)'
H91033F23321D: '入力のLLVM に対して検証プログラムを実行しない（危険！）'
# 'Do not separate the constant offset from a GEP instruction'
H1A5B4ED53276: 'GEP 指令から定数オフセットを分離しない'
# 'Do not set the default structure layout to be compatible with the Microsoft compiler standard'
H9523EC62FA32: 'デフォルトの構造配置をMicrosoft コンパイラ スタンダードと互換にする設定をしない'
# 'Do not sink instructions that have too many uses.'
H7989366B848B: '使用する場所が多すぎる命令をシンクしない'
# 'Do not sink instructions that require cloning unless they execute less than this percent of the time.'
HFCE852F940A6: '実行頻度がこのパーセント未満でない限り、複製が必要な命令をシンクしない'
# 'Do not split loads or stores'
H5C77F77F7EDB: 'ロードやストアを分割しない'
# 'Do not strip debug info metadata'
H72442AB7AE2C: 'デバッグ情報のメタデータを除去しない'
# 'Do not strip debug type info metadata'
H773E596FDA32: 'デバッグタイプ情報のメタデータを除去しない'
# 'Do not take inbounds assumptions at all'
H3B09FD23C9A9: 'inboundsの仮定を一切取り込まない'
# 'Do not treat C++ operator name keywords as synonyms for operators'
HF45D733F49BB: 'C++のオペレーター名キーワードをオペレーターの同義語と見なさない'
# 'Do not treat all horizontal whitespace as equivalent'
H821E9671833B: '水平方向の空白文字をすべて同等と見なさない'
# 'Do not treat usage of null pointers as undefined behavior'
H81D67D4AE33E: 'ヌルポインタの使用を未定義動作と見なさない'
# 'Do not treat warnings as errors (default)'
H9D2EBEBFE5AF: '警告をエラーと見なさない（既定値）'
# 'Do not try to find alias store for a load if the block number in the straight line is higher than this threshold.'
HA9F23FA6536D: '直線コードパス内のブロック番号がこのしきい値を超える場合、ロードのエイリアスストアを探すのをやめます'
# 'Do not try to find alias store for a load if there is a in-path block whose instruction number is higher than this threshold.'
H9F8822A4702E: 'パス内のブロックの命令番号がこのしきい値を超える場合、ロードのエイリアスストアを探すのをやめます'
# 'Do not use CSPGO.'
HF15B70CBCC17: 'CSPGOを使用しない'
# 'Do not use GP relative accesses for symbols known to be in a small data section (MIPS)'
HD0753F3CDAB8: '小規模データセクションにあることが明らかなシンボルに対してGP相対アクセスを使用しない（MIPS）'
# 'Do not use HLFIR lowering (deprecated)'
HE332EA8EB38E: 'HLFIRのローディングを使用しない（廃止予定）'
# 'Do not use PGO.'
H19DC80776155: 'PGOを使用しない'
# 'Do not use an early exit if isLiveOutPastPHIs returns true.'
HA74DFEC29B52: 'isLiveOutPastPHIsがtrueを返す場合、早期終了を使用しない'
# 'Do not use compact branches if possible.'
H541C69D3E8C0: 'コンパクトな分岐を使用しない（可能な場合）'
# 'Do not use div.w[u] and mod.w[u] instructions with input not sign-extended.'
H5B65DD1D4E29: '入力がサイン拡張されていない場合、div.w[u]およびmod.w[u]命令を使用しない'
# 'Do not use hardware multiplier'
H2D984261D820: 'ハードウェアマルチプライヤを使用しない'
# 'Do not use jump tables for lowering switches'
H553BE5736ED7: 'スイッチのローディングにジャンプテーブルを使用しない'
# 'Do not use more megabytes of memory'
HABD5A40DFA1B: 'より多くのメガバイトのメモリを使用しない'
# 'Do not use the -dce pass to reduce testcases'
HAA57D41E6E51: '-dce パスを使用してテストケースを削減しない'
# 'Do not use the -simplifycfg pass to reduce testcases'
H29CCC0670DF0: '-simplifycfg パスを使用してテストケースを削減しないでください'
# 'Do not use the analyzed objects when unparsing'
H83CE402540D9: 'アンパース時に解析対象オブジェクトを使用しないでください'
# 'Do not use the experimental C++ class ABI for classes with virtual tables'
H6D985C46C06C: '仮想テーブルを持つC++クラスに対して実験的なABIを使用しないでください'
# 'Do not validate testcase is interesting after counting chunks (may speed up reduction)'
HA696CDBE3AE6: 'サンプルプロファイル読み込み時にコールグラフのトップダウン順序で関数のプロファイリングとインライン化を実行（削減速度向上の可能性があります）'
# 'Do not verify input module'
H39AA36F540E0: '入力モジュールを検証しない'
# 'Do not warn about individual formatting changes needed. Used only with --dry-run or -n'
H754226DD39F9: '必要なフォーマット変更を個別に警告しない。--dry-runまたは-nオプションと併用する場合のみ有効'
# 'Do not write current time into COFF output (breaks link.exe /incremental)'
HBABC5A49FA79: 'COFF出力に現在時刻を書き込まない（link.exe /incrementalが壊れる）'
# 'Do not write result bitcode file'
H22D616F37560: '結果ビットコードファイルを書き出さない'
# 'Do not zero initialize globals without default initialization'
HECF1970A8089: 'デフォルト初期化がないグローバル変数をゼロ初期化しない'
# 'Do nothing'
HD268BA5209C4: '何も実行しない'
# 'Do profile annotation and inlining for functions in top-down order of call graph during sample profile loading. It only works for new pass manager. '
HF43D143A0C90: 'サンプルプロファイルの読み込み時にコールグラフのトップダウン順序で関数のプロファイリングアノテーションとインライン化を実行します。新しいパスマネージャでのみ有効です'
# 'Do pseudo probe verification'
HC942827254CC: '疑似プローブ検証を実行'
# 'Do static counter allocation for value profiler'
H465B564B215B: 'バリュープロファイラーの静的カウンターアロケーションを実行'
# 'Document only public declarations.'
HAA6808E72416: '公開宣言のみをドキュメント化する'
# 'Documentation in HTML format.'
H35BAD16C1698: 'HTML形式のドキュメント'
# 'Documentation in MD format.'
HA974194AB003: 'MD形式のドキュメント'
# 'Documentation in YAML format.'
H5814855B30B7: 'YAML形式のドキュメント'
# 'Dominance Frontier Construction'
H0D043E29B031: 'ドミナンスフロンティア構築'
# 'Dominator Tree Construction'
HD7B4E93722B4: 'ドミネーター木構築'
# "Don't Use the new driver for offloading compilation."
H348818D3A16A: 'オフロードコンパイルのために新しいドライバを使用しないでください'
# "Don't allow device side init function in HIP (experimental)"
H8D56505F6239: 'HIP (実験的) でデバイス側初期化関数を許可しない'
# "Don't allow loop unrolling to simulate more than this number of iterations when checking full unroll profitability"
HA88E0E56432E: 'ループ展開でこの数以上のイテレーションをシミュレートすることを許可しない (完全な展開の利益を検証する際に)'
# "Don't assume assembly file starts in the text section"
HFEF6F05E02CF: 'アセンブリファイルがテキストセクションから始まると仮定しない'
# "Don't assume data segments are relative to text segment"
H1D0D36BE1FD6: 'データセグメントがテキストセグメントに相対的だと仮定しない'
# "Don't assume that C++'s global operator new can't alias any pointer"
HC32AE2553730: 'C++のグローバルoperator newがどのポインタともアリーシングしないと仮定しない'
# "Don't assume that kernels are launched with uniform block sizes (default true for CUDA/HIP and false otherwise)"
H328B84E6AEC0: 'CUDA/HIPではtrue (デフォルト)、それ以外ではfalse (カーネルが一様なブロックサイズで起動されたと仮定しない)'
# "Don't automatically start assembly file with a text section"
HB573B3460C18: 'アセンブリファイルをテキストセクションから自動的に開始しない'
# "Don't clear counters across dumps (use with instrumentation-sleep-time option)"
HFB41C45D3123: 'ダンプ間でカウンタをクリアしない (instrumentation-sleep-time オプションと併用)'
# "Don't clear the Clang AST before running backend code generation"
H438A0AAAB7E0: 'バックエンドコード生成前にClang ASTをクリアしない'
# "Don't convert memcpy to TP loop."
H4B53144272CD: 'memcpyをTPループに変換しない。'
# "Don't defer host/device related diagnostic messages for CUDA/HIP"
H9AB401869BF7: 'CUDA/HIPのホスト/デバイス関連の診断メッセージを遅延させない'
# "Don't demangle function names"
H618F1A05266D: '関数名のデマングルをしない'
# "Don't disable block signature string)"
HD22256B8D923: 'ブロックシグネチャーストリングを無効にしない'
# "Don't disable features used for crash debugging (crash reports, llvm-symbolizer and core dumps)"
HA02320B35AF6: 'クラッシュデバッグ用の機能 (クラッシュレポート、llvm-symbolizer、コアダンプ) を無効にしない'
# "Don't discard temporary labels"
H59AD35796471: '一時ラベルを破棄しない'
# "Don't display class definitions"
HF6C8FDDA5009: 'クラス定義を表示しない'
# "Don't display full enum definitions"
HB5A6C783A07D: 'enumの完全定義を表示しない'
# "Don't do the coverage check."
H193F8F133737: 'カバレッジチェックを行わない'
# "Don't dump anything."
HA287D365311B: '何もダンプしない'
# "Don't emit an address-significance table"
H7A772E673769: 'アドレス重要性テーブルを生成しない'
# "Don't emit anything (for timing purposes)"
H097B7300276D: '何も出力しない（パフォーマンス計測のため）'
# "Don't emit compiler path and command line into CodeView debug information"
H76DE26A5896D: 'コンパイラのパスとコマンドラインをCodeViewデバッグ情報に含めない'
# "Don't emit errors on invalid analyzer-config inputs"
H344F10286BA2: '無効なanalyzer-config入力に対するエラーを表示しない'
# "Don't emit inline line tables."
H18C272BB702A: 'インライン行テーブルを生成しない'
# "Don't emit warning for unused driver arguments"
HCD60E199F7C0: '未使用なドライバ引数に関する警告を表示しない'
# "Don't emit warnings about unused arguments for the following arguments"
H2C209A90E709: '以下の引数に対して未使用な引数に関する警告を表示しない'
# "Don't error out if the detected version of the CUDA install is too low for the requested CUDA gpu architecture."
H16AC4195802C: '要求されたCUDA GPUアーキテクチャに対応するCUDAインストールの検出バージョンが低い場合でもエラーを出さない'
# "Don't expand conditional move related pseudos for Mips 16"
H68A3ACC276BC: 'Mips 16で条件移動関連の擬指令を展開しない'
# "Don't export branch data (LCOV)"
H15B1E91EF10C: 'LCOVのブランチデータをエクスポートしない'
# "Don't export expanded source regions"
H4609EDADC332: '展開されたソース領域をエクスポートしない'
# "Don't export per-function data"
H2769FE377EEE: '各関数のデータをエクスポートしない'
# "Don't extract blocks when searching for miscompilations"
H82D476F902A7: 'ミスコンパイルを検索する際にブロックを抽出しない'
# "Don't extract loops when searching for miscompilations"
H9384DB503321: 'ミスコンパイルを検索する際にループを抽出しない'
# "Don't generate implicit floating point or vector instructions"
H54B5124D5D1B: '暗黙の浮動小数点やベクタ命令を生成しない'
# "Don't generate local calls to out-of-line atomic operations"
H96F508547438: 'アウト・オブ・ライン原子操作に対するローカルコールを生成しない'
# "Don't include vectorization factors, etc."
HB5557A169D42: 'ベクトル化係数などは含めない'
# "Don't instrument functions with loops unless they also meet the minimum function size"
H574C69576F45: 'ループを含む関数でも最小関数サイズを満たさない場合、関数をインストルメントしない'
# "Don't instrument scalar globals"
H6894CA3DD417: 'スカラーグローバル変数をインストルメントしない'
# "Don't instrument scalar stack variables"
H87D069F48ECC: 'スカラースタック変数をインストルメントしない'
# "Don't keep static const variables even if unused"
H286AB8A3B099: '未使用でもstatic const変数を保持しない'
# "Don't match or outline intrinsics"
H34D78D938C2B: '_INTRINSICS_ を一致させたり、アウトライン化しない'
# "Don't mutate strict-float node to a legalize node"
H6DCCA4AAE41B: 'strict-float ノードを合法化ノードに変換しない'
# "Don't output the .ll file"
H1B261E3A62B3: '.ll ファイルを出力しない'
# "Don't perform type checking of the assembly code (wasm only)"
HDF197C4FAB89: 'アセンブリコードの型検査を実行しない (wasm 専用)'
# "Don't place zero initialized data in BSS"
H2108D326FE0B: 'BSS セクションにゼロ初期化データを配置しない'
# "Don't place zero-initialized symbols into bss section"
H6FEBA18EB379: 'ゼロ初期化シンボルを bss セクションに配置しない'
# "Don't prefer any addressing mode"
H8ABFDD32EA98: 'どのアドレッシングモードも優先しない'
# "Don't preserve line numbers (default)"
H9468F0C93544: '行番号を保持しない (デフォルト)'
# "Don't preserve order of LLVM use-lists when serializing"
HC0EBF389C575: 'シリアライズ時に LLVM の use-list の順序を保持しない'
# "Don't propagate function-attrs in thinLTO"
HA4C570976962: 'thinLTO で function-attrs を伝播させない'
# "Don't relax loads to long loads - for testing purposes"
H30C29761BE41: 'ロードを long loads に変換しない - テスト用'
# "Don't run the LLVM IR verifier pass"
H5E9DB83319CA: 'LLVM IR バリデータ パスを実行しない'
# "Don't run the LLVM verifier during the optimization pipeline"
HBB1839A83C81: '最適化パイプライン中に LLVM バリデータを実行しない'
# "Don't show any SymIndexId fields (overrides -hierarchy)"
H9033D913589F: 'SymIndexId フィールドを表示しない (-hierarchy を上書き)'
# "Don't show compiler generated types and symbols"
H6CE8BA80D4D4: 'コンパイラが生成したタイプとシンボルを表示しない'
# "Don't show symbols from system libraries"
H1D2970DB0285: 'システムライブラリのシンボルを表示しない'
# "Don't specialize functions that have less than this number of instructions"
H6394C9853CC0: 'この数未満の命令を持つ関数を特殊化しない'
# "Don't specify that kernel argument names are preserved (HIP only)"
H682A59EE1E8F: 'カーネル引数名を保持する指定をしない (HIP 専用)'
# "Don't specify that single precision floating-point divide and sqrt used in the program source are correctly rounded (HIP device compilation only)"
HAC5422C51310: 'プログラムソースで使用される単精度浮動小数点除算と平方根が正しく丸められるように指定しない (HIP デバイスコンパイル専用)'
# "Don't tail-predicate loops"
H2D6501929AEC: 'テイル予測ループをしない'
# "Don't tail-predicate loops, create scalar epilogue"
H9B8DA5043D54: 'ループの末尾で予測条件付きループを使用せず、スカラーエピローグを作成します'
# "Don't treat conditional branches as disclosure gadgets. This may improve performance, at the cost of security."
H9B8D554F070F: '条件分岐を情報漏洩ガジェットとして扱わない。これによりパフォーマンスが向上する可能性がありますが、セキュリティに影響する場合があります。'
# "Don't treat control flow paths that fall off the end of a non-void function as unreachable"
H5D4780A60912: '非void関数の末尾で終了する制御フローパスを到達不能とは扱わない'
# "Don't treat unattributed constexpr functions as __host__ __device__."
HE736239C2F73: '属性のないconstexpr関数を__host__ __device__として扱わない'
# "Don't try to avoid heapifying local blocks"
HA0E5E1480194: 'ローカルブロックのヒープ化を回避しようとしない'
# "Don't use GOT indirection to reference external data symbols"
H446ED22B127C: '外部データシンボルへの参照にGOT間接参照を使用しない'
# "Don't use LLVM/Offload as portable offloading runtime."
H993CF148793E: 'LLVM/Offloadをポータブルオフロードランタイムとして使用しない'
# "Don't use __cxa_atexit for calling destructors"
HB9FAC41CF208: 'デストラクタの呼び出しに__cxa_atexitを使用しない'
# "Don't use a const qualified type for string literals in C and ObjC"
H45BD6EFBF0D7: 'CおよびObjCの文字列リテラルで定数修飾された型を使用しない'
# "Don't use a uniquing type map for debug info"
HD459DA46855B: 'デバッグ情報用にユニーク化型マップを使用しない'
# "Don't use approximate transcendental functions"
H0ED50C803EDB: '近似超越関数を使用しない'
# "Don't use atexit or __cxa_atexit to register global destructors"
HC46180126A88: 'グローバルデストラクタの登録にatexitまたは__cxa_atexitを使用しない'
# "Don't use constructor homing for debug info"
HD49F3B3625FB: 'デバッグ情報にコンストラクタ定位を使用しない'
# "Don't use ignorelist file for sanitizers"
HFDCDF48F9121: 'sanitizers用の無視リストファイルを使用しない'
# "Don't use new kernel launching API for HIP"
HFB5E65669ABA: 'HIPの新しいカーネル起動APIを使用しない'
# "Don't use the new driver for OpenMP offloading."
H301CA6785230: 'OpenMPオフロード用の新しいドライバを使用しない'
# "Don't use unique names for text and data sections"
H8E78A20B661E: 'テキストおよびデータセクションに一意の名前を使用しない'
# "Don't verify input files for the modules if the module has been successfully validated or loaded during this build session"
HE1A69C7730A8: 'このビルドセッションでモジュールが正常に検証または読み込まれた場合、モジュールの入力ファイルを検証しない'
# "Don't verify that MIR is fully legal between GlobalISel passes"
H2547A49B1E5F: 'GlobalISelパス間でMIRが完全に合法化されていることを検証しない'
# "Don't work around Cortex-A57 Erratum 1742098 (ARM only)"
H3E4B9BDEA672: 'Cortex-A57 Erratum 1742098（ARMのみ）の回避策を実行しない'
# "Don't work around Cortex-A72 Erratum 1655431 (ARM only)"
HBBA28409C8FE: 'Cortex-A72 エラータ 1655431 を回避しない (ARM専用)'
# "Don't work around VLLDM erratum CVE-2021-35465 (ARM only)"
H2D48982037C5: 'VLLDM エラータ CVE-2021-35465 を回避しない (ARM専用)'
# "Don't workaround Cortex-A53 erratum 835769 (AArch64 only)"
H674F1B2934BD: 'Cortex-A53 エラータ 835769 を回避しない (AArch64専用)'
# "Don't write fields with default values"
HDC62F7F06017: 'デフォルト値を持つフィールドを書き込まない'
# "Dot-separated value representing the Microsoft compiler version number to report in _MSC_VER (0 = don't define it (default))"
H3158063BCCC4: '_MSC_VERで報告するMicrosoftコンパイラーのバージョン番号を表すドット区切り値（0 = 定義しない（既定値））'
# 'Dr. Watson Assassin.\n'
H2FDABEFA9036: 'Dr. Watson Assassin.\n'
# 'Drop all type test sequences'
HA428B8584F95: 'すべてのタイプテストシーケンスを削除'
# 'Drop the profile symbol list when merging AutoFDO profiles (only meaningful for -sample)'
HF313BEF9935A: 'AutoFDOプロファイルをマージする際にプロファイルシンボルリストを削除（-sampleオプションでのみ意味がある）'
# 'Drop type test assume sequences'
HB2138C89F2F0: 'タイプテストの仮定シーケンスを削除'
# 'DummyCGSCCPass'
H4B94DA391D3F: 'DummyCGSCCPass'
# 'Dump AMDGPU HSA Metadata'
HAD21DA71DA94: 'AMDGPU HSA メタデータをダンプ'
# 'Dump C11 CodeView debug chunks'
HE18236D9F17D: 'C11 CodeView デバッグ チャンクをダンプ'
# 'Dump C13 CodeView debug chunk subsection'
H0E6AB0F1E2CC: 'C13 CodeView デバッグ チャンクのサブセクションをダンプ'
# 'Dump CallingContextGraph to stdout after each stage.'
HE2FF79E701CA: '各ステージの後にCallingContextGraphを標準出力にダンプ'
# 'Dump IR after transformation happens'
H27451FBBE078: '変換が発生した後のIRをダンプ'
# 'Dump IR from modules to stderr on shutdown'
H16357A60101D: 'シャットダウン時にモジュールからのIRを標準エラー出力にダンプ'
# 'Dump IR to reproduce successful transformations.'
H30BFC03DFD55: '成功した変換を再現するためのIRをダンプ'
# 'Dump JITted-compiled object to file <input file>.o'
HCEEB046B9401: 'JITコンパイルされたオブジェクトをファイル <入力ファイル>.o にダンプ'
# 'Dump JITted-compiled object to file specified with -object-filename (<input file>.o by default).'
HF39EA47FD712: '-object-filenameで指定されたファイルにJITコンパイルされたオブジェクトをダンプ（既定値は <input file>.o）'
# 'Dump MIR with SPIR-V dependencies info'
H3C877ECA1BED: 'SPIR-V依存関係情報と共にMIRをダンプ'
# 'Dump __jit_debug_descriptor contents to stdout'
HEDC251CD7F96: 'の内容を標準出力にダンプします __jit_debug_descriptor'
# 'Dump __jit_debug_descriptor in-memory debug objects as tool output'
HEFEA598ED348: 'メモリ内のデバッグ・オブジェクトをツール出力としてダンプします __jit_debug_descriptor'
# 'Dump a detailed breakdown of IPI types usage/size'
HE1625844BBC6: '詳細なIPI種類の使用量/サイズの分解をダンプします'
# 'Dump a detailed breakdown of S_UDT record usage / stats'
HFAECE5B8125B: '詳細なS_UDTレコードの使用状況/統計の分解をダンプします'
# 'Dump a detailed breakdown of symbol usage/size for each module'
HC9A6B5A07738: '各モジュールのシンボルの使用量/サイズの詳細な分解をダンプします'
# 'Dump a detailed breakdown of type usage/size'
H55DC9D5447F4: '型の使用量/サイズの詳細な分解をダンプします'
# "Dump all declarations in old header (JSON format) to stdout. If the option is specified, other command options will be ignored. An empty JSON will be returned if old header isn't specified."
H716B07B285CE: '古いヘッダー（JSON形式）内のすべての宣言を標準出力にダンプします。このオプションが指定された場合、他のコマンド・オプションは無視されます。古いヘッダーが指定されていない場合、空のJSONが返されます。'
# 'Dump all records as machine-readable JSON'
HC8D3646E5507: 'マシン可読なJSON形式で全レコードをダンプします'
# 'Dump all substituted intrs'
H17F291CCDE2E: 'すべての置換intrsをダンプします'
# 'Dump array types'
H49086B41135B: '配列型をダンプします'
# 'Dump binary data from specified range of blocks.'
H84E1DDB15414: '指定されたブロック範囲からのバイナリ・データをダンプします'
# 'Dump binary data from specified range of bytes'
H8032C8C6B89F: '指定されたバイト範囲からのバイナリ・データをダンプします'
# 'Dump binary data from specified streams.  Format is SN[:Start][@Size]'
H025773DC5489: '指定されたストリームからのバイナリ・データをダンプします。形式はSN[:Start][@Size]です'
# 'Dump bytes of PDB Name Map'
HEA0DA34178F3: 'PDB Name Mapのバイトをダンプします'
# 'Dump code-completion information at a location'
HAD967F4C2789: '特定の場所でのコード補完情報をダンプします'
# 'Dump compiland information'
HC4F8C0431CDD: 'コンパイル情報（compiland）をダンプします'
# 'Dump configuration options to stdout and exit.\nCan be used with -style option.'
HC24D568EFEC0: '設定オプションを標準出力にダンプして終了します。\n-style オプションと併用可能です。'
# 'Dump declarations that are deserialized from PCH, for testing'
HE581DC659FD7: 'テスト用にPCHから逆シリアル化された宣言をダンプします'
# 'Dump dropped debug variables stats'
H85E673327785: 'ドロップされたデバッグ変数の統計をダンプします'
# 'Dump dropped debug variables stats for MIR passes'
HEA66796E7964: 'MIR パスのドロップされたデバッグ変数の統計をダンプします'
# "Dump each stream's block map (implies -stream-metadata)"
H5165BD588D74: '各ストリームのブロックマップをダンプ（-stream-metadata を含む）'
# 'Dump edit and continue map'
HBCE09E7C4018: '編集と継続マップをダンプ'
# 'Dump enum types'
HB104D7EA4F5F: 'enumタイプをダンプ'
# 'Dump everything we know how to dump.'
H37AD9BC8A78E: '知り得る全ての情報をダンプします。'
# 'Dump exploded graph to the specified file'
H77D296A430F7: '指定したファイルに爆発グラフをダンプ'
# 'Dump external symbols'
HA768DB613A32: '外部シンボルをダンプ'
# 'Dump free page map'
HE90F56D21A38: 'フリーページマップをダンプ'
# 'Dump function names to stdout.'
H13D3781376F8: 'stdout に関数名をダンプ'
# 'Dump function signature information'
H1625F7D7A62D: '関数シグネチャ情報をダンプ'
# 'Dump global symbols'
H4E004D714E1B: 'グローバルシンボルをダンプ'
# 'Dump graphs for each function/round in the compilation unit.'
H2EA9EDCA4026: 'コンパイル単位内の各関数/ラウンドのグラフをダンプ'
# 'Dump image section headers'
H01B54D632FED: 'イメージセクションヘッダーをダンプ'
# 'Dump input on failure'
H6F31E933D50C: 'エラー時に入力をダンプ'
# "Dump input to stderr, adding annotations representing\ncurrently enabled diagnostics.  When there are multiple\noccurrences of this option, the <value> that appears earliest\nin the list below has precedence.  The default is 'fail'.\n"
H768FAF2A8E36: "入力を stderr に出力し、有効な診断を表す注釈を追加します。\nこのオプションが複数回指定された場合、リストの最初に現れる <value> が優先されます。\nデフォルトは 'fail' です。\n"
# 'Dump list of actions to perform'
HD3BA4698DD33: '実行するアクションの一覧をダンプ'
# 'Dump low level bitcode trace'
H1754A9E4C373: '低レベルビットコードトレースをダンプ'
# 'Dump module after Polly transformations into a file suffixed with "-after"'
HDF35672E1E22: "Polly 変換後のモジュールを、'-after' で終わるファイルにダンプ"
# 'Dump module after Polly transformations to the given file'
HFE02E969722D: 'Polly 変換後のモジュールを指定されたファイルにダンプ'
# 'Dump module before Polly transformations into a file suffixed with "-before"'
HF0A6CA5B945A: "Polly 変換前のモジュールを、'-before' で終わるファイルにダンプ"
# 'Dump module before Polly transformations to the given file'
H3D5A0282D19D: 'Polly 変換前のモジュールを指定されたファイルにダンプ'
# 'Dump module info'
H35667204516C: 'モジュール情報をダンプする'
# 'Dump modules to stdout.'
HAFE4570AAD96: '標準出力にモジュールをダンプします。'
# 'Dump modules to the current working directory. (WARNING: will overwrite existing files).'
H5DEA08F3B824: '現在の作業ディレクトリにモジュールをダンプします。（警告: 既存のファイルを上書きします）'
# 'Dump new file contents in YAML, if specified.'
H0F661C11A2F3: '指定された場合、YAML形式で新しいファイルの内容をダンプします。'
# 'Dump provenance'
H0B7FC19C4E7C: 'プロvenience情報をダンプ'
# 'Dump record layout information'
H1A9181305386: 'レコードのレイアウト情報をダンプ'
# 'Dump record layout information for all complete types'
HFF3CB6AA485A: 'すべての完全な型に対するレコードのレイアウト情報をダンプします'
# 'Dump record layout information in a simple form used for testing'
HEC89F4D9A445: 'テスト用のシンプルな形式でレコードのレイアウト情報をダンプします'
# 'Dump record layout information with canonical field types'
H371339BFDE60: '正規化されたフィールド型を用いてレコードのレイアウト情報をダンプします'
# 'Dump register information to help debugging'
HA4313634E698: 'デバッグを助けるためにレジスタ情報をダンプします'
# 'Dump resource usage at schedule boundary.'
H8B22EBFC198A: 'スケジュール境界でのリソース使用状況をダンプ'
# 'Dump results in JSON format to stdout.'
H76D763966BEB: 'JSONフォーマットで結果を標準出力にダンプします。'
# 'Dump section contributions'
HDC1D19FADC7C: 'セクションへの貢献情報をダンプ'
# 'Dump section map'
HBED8393F6931: 'セクションマップをダンプ'
# 'Dump source file info'
H9D1B330F5346: 'ソースファイル情報をダンプ'
# 'Dump sum of timings for all stacks. By default separates stacks per-thread.'
H39EFC1DB7865: 'デフォルトではスレッドごとに区別する形で、すべてのスタックのタイミング合計をダンプします。'
# 'Dump symbol record substream'
H254B4E85A075: 'シンボル記録サブストリームをダンプ'
# 'Dump symbols after the semantic analysis'
HDA7B67B72F4C: 'セマンティック解析後のシンボルをダンプ'
# 'Dump symbols and the parse tree after the semantic checks'
H8BBAF59A717D: 'セマンティックチェック後のシンボルとパース木をダンプ'
# 'Dump symbols and their source code locations'
H8E456C399A58: 'シンボルとそのソースコード位置情報をダンプ'
# 'Dump templight information to stdout'
H1AD586FAA55A: '標準出力にtemplight情報をダンプする'
# 'Dump the DBI Stream Headers (Stream 2)'
H129FA94CBB86: 'DBI ストリーム ヘッダー（ストリーム2）をダンプする'
# 'Dump the FIR created by lowering and exit'
H91B777999917: 'loweringによって生成されたFIRをダンプし、終了する'
# 'Dump the HLFIR created by lowering and exit'
H2BFC1CB7ACAA: 'loweringによって生成されたHLFIRをダンプし、終了する'
# 'Dump the IPI Stream (Stream 5)'
H0EC59D4B528C: 'IPI ストリーム（ストリーム5）をダンプする'
# 'Dump the PDB Stream (Stream 1)'
H4577B257A885: 'PDB ストリーム（ストリーム1）をダンプする'
# 'Dump the PDB String Table'
H46D5A974F1C3: 'PDB 文字列テーブルをダンプする'
# 'Dump the Publics Stream'
H9A8FF0F8500C: 'Publics ストリームをダンプする'
# "Dump the SCCs in the ThinLTO index's callgraph"
H05F63DC7879B: 'ThinLTO インデックスのコールグラフ内のSCCsをダンプする'
# 'Dump the TPI Stream (Stream 3)'
H838873B9AC8D: 'TPI ストリーム（ストリーム3）をダンプする'
# 'Dump the compiler configuration options'
H3D1A24CE8D0E: 'コンパイラの設定オプションをダンプする'
# 'Dump the cooked character stream in -E mode'
H7DB9E0B6C82A: '-E モードでの加工済み文字ストリームをダンプする'
# 'Dump the coverage mapping records, for testing'
H95CDC790B673: 'テスト用のカバレッジ マッピング レコードをダンプする'
# 'Dump the dependency graph to dot files.'
HF4BCFC89AF2D: '依存関係グラフをdotファイルにダンプする'
# 'Dump the gcov file to stderr'
H58322A4E2763: 'gcovファイルをstderrに出力する'
# 'Dump the id record with the given type index'
H759F0D055070: '指定されたtype indexのidレコードをダンプする'
# 'Dump the layouts of all vtables that will be emitted in a translation unit'
H5286BCB58A1F: '翻訳単位で生成されるすべてのvtablesのレイアウトをダンプする'
# 'Dump the list of input files and their weights, then exit'
HFD20CED5CA14: '入力ファイルのリストとその重みをダンプし、終了する'
# "Dump the number of streams and each stream's size"
HD36F7FCDEEBC: 'ストリームの数と各ストリームのサイズをダンプする'
# 'Dump the parse tree'
H64405164E18C: 'パースツリーをダンプする'
# 'Dump the parse tree (skips the semantic checks)'
H65A5DE3C84CD: 'パース木をダンプします（セマンティックチェックをスキップ）'
# 'Dump the pre-FIR tree'
H313B5A95699E: 'pre-FIR木をダンプします'
# 'Dump the pre-fir parse tree'
HA7DC87D10265: 'pre-firパース木をダンプします'
# "Dump the source files that contribute to each module's."
H804482274E2A: '各モジュールに寄与するソースファイルをダンプします'
# 'Dump the type record with the given type index'
H8A9E9857BE0A: '指定された型インデックスの型レコードをダンプします'
# 'Dump the unsymbolized profile to the output file. It will show unwinder output for CS profile generation.'
H9822074C616B: 'シンボルなしプロファイルを出力ファイルにダンプします。CSプロファイル生成のためのアンワインダー出力を表示します。'
# 'Dump type server map'
HA60CB6E2EBD6: 'タイプサーバーマップをダンプします'
# 'Dump typedefs'
HB4499E4CA24E: 'typedefをダンプします'
# 'Dump udt types'
H4EEAE7678976: 'UDTタイプをダンプします'
# 'Dump virtual table shapes'
H94754C1D9BD7: 'バーチャルテーブルの形状をダンプします'
# 'Duplicate the snippet'
HB2CC4A27F6FB: 'スニペットを複製します'
# 'During rematerialization for a copy, if the def instruction has many other copy uses to be rematerialized, delay the multiple separate live interval update work and do them all at once after all those rematerialization are done. It will save a lot of repeated work. '
H2B948F8A8B8A: 'コピー用の再生成中に、定義命令が複数のコピー使用を再生成する場合、複数のライブインターバル更新処理を遅延させて、すべての再生成が完了後に一括処理します。これにより繰り返し作業が大幅に削減されます。'
# 'Dwarf version'
H5862F01F0C5E: 'DWARFバージョン'
# 'Dynamic libraries to load before linking'
H926C9AA42A23: 'リンカ前に読み込む動的ライブラリ'
# 'Dynamic scheduling'
H762ACA0C3351: 'ダイナミックスケジューリング'
# 'Dynamically link the sanitizer runtime'
HE0360B0DDF0D: 'sanitizerランタイムを動的リンクする'
# 'EABI GNU'
H7E2A3B789B36: 'EABI GNU'
# 'EABI version 4'
H3C615C59EEA1: 'EABIバージョン4'
# 'EABI version 5'
HDD2C36FB7B3F: 'EABIバージョン5'
# 'Eagerly compute live intervals for all physreg units.'
H8BDCB87E4D2E: 'すべてのphysregユニットに対してライブインターバルを積極的に計算する'
# 'Eagerly invalidate more analyses in default pipelines'
HC29BAEFB7500: 'デフォルトパイプラインでより多くの解析を積極的に無効化します'
# 'Early CSE'
H7995F9E82B8F: '早期CSE'
# 'Early CSE w/ MemorySSA'
HA097BFA29921: 'MemorySSAを使用した早期CSE'
# 'Early If Converter'
HEACD98DB3CB0: 'Early Ifコンバータ'
# 'Early If Predicator'
H3899A5E56B26: 'Early Ifプレディケータ'
# 'Early Machine Loop Invariant Code Motion'
H93B90001D05A: 'Early Machineループの不変コード移動'
# 'Early Tail Duplication'
H9F05343E7731: 'Early Tail複製'
# 'Early expansion of MUX'
HC9BB5C4937A3: 'Early MUX展開'
# 'Element attributes.'
HA3DEA8BD288F: '要素属性。'
# 'Element debug location.'
HDDAB4BDAA546: '要素のデバッグ位置。'
# 'Element declaration and definition references.'
HF82FBA3D05B2: '要素の宣言と定義の参照。'
# 'Element referenced across Compile Units.'
H6E34E57CF7C6: 'コンパイルユニット間で参照されている要素。'
# 'Element referenced only in the Compile Unit.'
HB0C2FAF86940: 'コンパイルユニット内でしか参照されていない要素。'
# 'Element to print.'
H1150FC4D6BB7: '印刷する要素。'
# 'Elements to compare.'
H7D8A91E768C7: '比較する要素。'
# 'Elide ElementsAttrs with "..." that have more elements than the given upper limit'
HE475543A5C00: '指定された上限を超える要素数を持つ「...」を伴うElementsAttrsを省略'
# 'Elide printing value of resources if string is too long in chars.'
H89DF7B30813D: '文字数が長すぎる場合、リソースの値の出力を省略'
# 'Elide resources when generating bytecode'
HE18501EFA3FF: 'バイトコード生成時にリソースを省略'
# 'Eliminate PHI nodes for register allocation'
H951E7DE45FDF: 'レジスタ割り当てのためのPHIノードを削除'
# 'Eliminate scalar loop carried dependences'
H57EB486234E9: 'スカラループのキャリード依存関係を削除'
# 'Embed DXIL'
H07B28C451A5A: 'DXILを埋め込む'
# 'Embed LLVM IR bitcode as data'
H595F481498B5: 'LLVM IRビットコードをデータとして埋め込む'
# 'Embed LLVM bitcode'
H4AADB26DC12B: 'LLVMビットコードを埋め込む'
# 'Embed LLVM bitcode in object files produced by LTO'
H16F1861B6BE7: 'LTOによって生成されたオブジェクトファイルにLLVMビットコードを埋め込む'
# 'Embed Offloading device-side binary into host object file as a section.'
H5475B2E44660: 'オフローディングのデバイス側バイナリをホストオブジェクトファイルのセクションとして埋め込む'
# 'Embed PDB in shader container (ignored)'
HEF26692F47BE: 'シェーダーコンテナにPDBを埋め込む（無視）'
# 'Embed after all optimization passes'
HD4E0BFB5C58B: '最適化パスのすべての後に埋め込む'
# 'Embed function arity information into the KCFI patchable function prefix'
H9B1AB0019717: 'KCFIのパッチ可能な関数プレフィックスに関数アリティ情報を埋め込む'
# 'Embed placeholder LLVM IR data as a marker'
HCFCB6093DA4B: 'マーカーとしてのLLVM IRデータのプレースホルダを埋め込む'
# 'Embed post merge, but before optimizations'
HEA0EFEB4A060: 'マージ後、最適化前に埋め込む'
# 'Embed source text in DWARF debug sections'
HC2C8736B7263: 'DWARFデバッグセクションにソーステキストを埋め込む'
# 'Embed the contents of all files read by this compilation into the produced module file.'
HECD9878DE365: 'このコンパイルによって読み込まれたすべてのファイルの内容を生成されるモジュールファイルに埋め込む'
# 'Embed the contents of the specified file into the module file being compiled.'
H5C7A5481DBF2: 'コンパイル中のモジュールファイルに指定されたファイルの内容を埋め込む'
# 'Emit  debug info for defined but unused types'
H4259F2A07B2E: '定義されたが使用されていない型のデバッグ情報を生成する'
# 'Emit (experimental) loops (with sparse.iterate).'
H6558C2381246: '（実験的）ループ（sparse.iterateを使用）を生成する'
# 'Emit .secure_log_unique directives to this filename.'
HA73462D861E9: '.secure_log_uniqueディレクティブをこのファイル名に出力'
# 'Emit .su file containing information on function stack sizes'
H17B887378AAE: '関数スタックサイズの情報を含む.suファイルを生成'
# 'Emit AT&T-style assembly'
HED9E24C24759: 'AT&Tスタイルのアセンブリを生成'
# 'Emit Apple-style NEON assembly'
H45694CDA7EC7: 'AppleスタイルのNEONアセンブリを生成'
# 'Emit Clang AST files for source inputs'
H2EA489E49444: 'ソース入力用のClang ASTファイルを生成'
# 'Emit CodeGen Data into custom sections'
H363A7576BA25: 'カスタムセクションにCodeGenデータを生成する'
# 'Emit GNU Assembly Syntax on z/OS.'
H56A1FC66D6EC: 'z/OS上でGNUアセンブリ構文を生成する'
# 'Emit GOTPCRELX/REX_GOTPCRELX/CODE_4_GOTPCRELX instead of GOTPCREL on x86-64 ELF'
HA621D70D3E80: 'x86-64 ELFでGOTPCRELの代わりにGOTPCRELX/REX_GOTPCRELX/CODE_4_GOTPCRELXを生成する'
# 'Emit IR to support LTO unit features (CFI, whole program vtable opt)'
H1C0C26CCDFE7: 'LTOユニット機能（CFI、全プログラムvtable最適化）をサポートするIRを生成する'
# 'Emit Import Call sections on supported targets that can be used by the Windows kernel to enable import call optimization'
HD73224065892: 'Windowsカーネルがインポート呼び出し最適化を有効にするのに使用できるインポート呼び出しセクションをサポート対象ターゲットで生成する'
# 'Emit Intel-style assembly'
HD0D98D71E373: 'Intelスタイルのアセンブリを生成する'
# 'Emit JSON-formatted debug info quality metrics.'
HE95341B061E7: 'JSON形式のデバッグ情報品質メトリクスを生成する'
# 'Emit LLVM textual assembly'
H5687C7B339C1: 'LLVMテキストアセンブリを生成する'
# 'Emit OpenMP code only for SIMD-based constructs.'
H566FF0EF84C2: 'SIMDベースの構築物のみに対してOpenMPコードを生成する'
# 'Emit PCs for atomic operations used by binary analysis sanitizers'
H1D074F0F258F: '二進解析sanitizerが使用する原子操作のPCを生成する'
# 'Emit PCs for atomic operations.'
H62316BF0E45F: '原子操作のPCを生成する'
# 'Emit PCs for code covered with binary analysis sanitizers'
H3D28246BA2B9: '二進解析sanitizerが適用されたコードのPCを生成する'
# 'Emit PCs for covered functions.'
H831FD59B3528: 'カバレッジ対象の関数のPCを生成する'
# 'Emit PCs for start of functions that are subject for use-after-return checking'
H797088C91ACC: '使用後戻り検出対象の関数の開始位置のPCを生成する'
# 'Emit PCs for start of functions that are subject for use-after-return checking.'
HEC66708B7812: '使用後戻り検出対象の関数の開始位置のPCを生成する'
# 'Emit RTTI data (default)'
H28F26C2AAAEF: 'RTTIデータを生成（既定値）'
# 'Emit R_RISCV_SET_ULEB128/E_RISCV_SUB_ULEB128 if appropriate'
H2DC3F5A68E91: '適切な場合R_RISCV_SET_ULEB128/E_RISCV_SUB_ULEB128を生成する'
# 'Emit SPIR-V NonSemantic.Shader.DebugInfo.100 instructions'
H3620039F4736: 'SPIR-V NonSemantic.Shader.DebugInfo.100命令を生成する'
# 'Emit VPU instructions for VE'
H336AA1A757FD: 'VE用のVPU命令を生成する'
# 'Emit Windows Control Flow Guard tables and checks'
H2B3A6CDD77E1: 'Windows制御フローガードテーブルとチェックを生成する'
# 'Emit Windows Control Flow Guard tables only (no checks)'
H12EF1A548A1C: 'Windows Control Flow Guardテーブルのみを生成する（チェックなし）'
# 'Emit Windows EH Continuation Guard tables'
H7CFD101BE344: 'Windows EH Continuation Guardテーブルを生成する'
# 'Emit `[first]private` variables as clauses on the MLIR ops.'
HDAD278A55FD1: 'MLIRオペレーションに`[first]private`変数をクリアスとして追加する。'
# 'Emit a call to trap function rather than a trap instruction'
H7926ECB4152F: 'トラップ命令ではなく、トラップ関数の呼び出しを生成する'
# 'Emit a compilation database fragment to the specified directory'
HBAB9D592240A: '指定されたディレクトリにコンパイルデータベースのフラグメントを生成する'
# 'Emit a diagnostic when "fast" instruction selection falls back to SelectionDAG.'
H88EB0DEF1034: '「高速」命令選択がSelectionDAGに回帰した場合、診断を発行する。'
# 'Emit a fatal error if format parsing fails'
H0EBAF7E7ADAA: 'フォーマット解析に失敗した場合、致命的エラーを発行する'
# "Emit a native object ('.o') file"
HAE97C70DDD39: 'ネイティブオブジェクトファイル（".o"）を生成する'
# 'Emit a section containing jump table addresses and sizes'
H0281F291EFBA: 'ジャンプテーブルのアドレスとサイズを含むセクションを生成する'
# 'Emit a section containing remark diagnostics metadata. By default, this is enabled for the following formats: yaml-strtab, bitstream.'
H75D67E9CFF88: 'リマーカーディагノスティックメタデータを含むセクションを生成する。デフォルトでは、yaml-strtab、bitstream形式で有効になっています。'
# 'Emit a section containing stack size metadata'
H698AD84DCB32: 'スタックサイズメタデータを含むセクションを生成する'
# 'Emit a warning if less than N% of records in the input profile are matched to the IR.'
HB962CC606D2C: '入力プロファイルのレコードのうちN%未満がIRと一致した場合、警告を発行する'
# 'Emit a warning if less than N% of samples in the input profile are matched to the IR.'
HED39F9DCFD05: '入力プロファイルのサンプルのうちN%未満がIRと一致した場合、警告を発行する'
# 'Emit all declarations, even if unused'
HF5BC1521C99D: '未使用の宣言もすべて生成する'
# 'Emit an address-significance table'
H378504D13B46: 'アドレス重要性テーブルを生成する'
# "Emit an assembly ('.s') file"
H34226183B99D: 'アセンブリファイル（".s"）を生成する'
# 'Emit an error if a C++ static local initializer would need a guard variable'
HA81110278BFB: 'C++の静的ローカル初期化子にガード変数が必要な場合、エラーを発行する'
# 'Emit analyzer results as errors rather than warnings'
H3B5E1411AD19: '分析結果を警告ではなくエラーとして発行する'
# 'Emit basic blocks into separate sections'
H67EB14D9E7DC: 'ベーシックブロックを別々のセクションに生成する'
# 'Emit bytecode when generating output'
H6A294EDCD1D8: '出力生成時にバイトコードを生成する'
# 'Emit call site debug information, if debug information is enabled.'
H4DFAA1C6FE5A: 'デバッグ情報が有効な場合、コール サイトのデバッグ情報を出力します。'
# 'Emit code that can be JIT compiled for OpenMP offloading. Implies -foffload-lto=full'
HCB19BAB5F044: 'OpenMP オフローディング用にJITコンパイル可能なコードを出力します。-foffload-lto=full を暗黙に指定します。'
# 'Emit code that prints the runtime check result dynamically.'
H83A96897A283: 'ランタイム チェックの結果を動的に出力するコードを生成します。'
# 'Emit codegen data into the object file. LLD for MachO (currently) merges them into default.cgdata.'
HE5A9DF802056: 'オブジェクト ファイルにcodegenデータを出力します。LLD for MachO (現在) は、それらをdefault.cgdataにマージします。'
# 'Emit codegen data into the object file. LLD for MachO (currently) merges them into the specified <path>.'
HB514733CE70A: 'オブジェクト ファイルにcodegenデータを出力します。LLD for MachO (現在) は、指定された<path>にマージします。'
# 'Emit colored output (default=autodetect)'
H1C348B34C157: 'カラフルな出力を有効にする（デフォルトは自動検出）'
# 'Emit compiler path and command line into CodeView debug information'
H252107FF70F1: 'CodeView デバッグ情報にコンパイラ パスとコマンドラインを出力します。'
# 'Emit complete descriptions of template parameters in forward declarations'
H73932760DABC: 'テンプレート パラメータの完全な説明を前方宣言に含める'
# 'Emit data into separate sections'
HF75AE625B842: 'データを別セクションに出力する'
# 'Emit debug info that places array-bounds instrumentation in an inline function called __ubsan_check_array_bounds.'
HCA08BC9E900F: 'インライン関数 __ubsan_check_array_bounds 内に配置するためのarray-bounds instrumentation用デバッグ情報を出力します。'
# 'Emit debug line info directives only'
HE3308044AB2D: 'デバッグ行情報ディレクティブのみを出力します'
# 'Emit debug line number tables only'
H8174B5298FE7: 'デバッグ ライン番号テーブルのみを出力します'
# 'Emit emitc.file ops with matching id'
H236B850BC868: '一致するidを持つemitc.fileオペレーションを出力します'
# 'Emit emptylines and comment lines as skipped regions (only disable it on test)'
H7D7A380200FE: '空行とコメント行をスキップ領域としてマーク（テストでのみ無効化可能）'
# 'Emit error if a specific declaration is deserialized from PCH, for testing'
H2CD80B3DD8B2: 'PCHからの宣言の逆シリアル化時にエラーを発生させる（テスト用）'
# 'Emit expensive warnings during LLVM IR import (discouraged: testing only!)'
H04DDF8C7828C: 'LLVM IRインポート時の高コスト警告を出力（テスト用！非推奨）'
# 'Emit extra debug info to make sample profile more accurate'
H367D707A9507: 'サンプル プロファイルの精度向上のための追加デバッグ情報を出力'
# 'Emit final result as bitcode instead of text IR'
H7F4BFD221CF3: 'テキストIRではなくbitcode形式で最終結果を出力'
# 'Emit full debug info for all types used by the program'
H30220D4F255D: 'プログラムで使用されるすべての型の完全なデバッグ情報を出力'
# 'Emit functional code (with scf.for/while).'
HB278CDF9ABA9: 'scf.for/whileを使用した機能コードを生成'
# 'Emit functional code or interfaces (to debug) for sparse loops'
HBDA72C0CBE39: 'スパースループ用のデバッグ用関数コードまたはインターフェースを生成'
# 'Emit functions into separate sections'
H09C9B71236EA: '関数を別セクションに生成'
# 'Emit generic NEON assembly'
H39274034DB2D: '汎用NEONアセンブリを生成'
# 'Emit hermetic module files (no nested USE association)'
HD5D99550F319: 'ネストされたUSE関連なしのhermeticモジュールファイルを生成'
# 'Emit hexagon jump tables in function section'
HEE6DA2F43CCC: '関数セクション内でhexagonジャンプテーブルを生成します'
# 'Emit hexagon lookup tables in function section'
H100801A51219: '関数セクション内でhexagonルックアップテーブルを生成します'
# 'Emit homogeneous prologue and epilogue for the size optimization (default = off)'
H835061FF9BD7: 'サイズ最適化用均一なプロローグ/エピローグを生成（既定: 無効）'
# 'Emit imports files for distributed backends.'
H99F865E8CA6D: '分散されたバックエンド用インポートファイルを生成'
# 'Emit information about accumulator register spills and copies'
H99CD32F2A0A4: 'アキュムレータレジスタのスパイルとコピーに関する情報を生成'
# 'Emit internal instruction representation to assembly file'
H61E38F521500: 'アセンブリファイルに内部命令表現を出力'
# 'Emit kernels to call ctor/dtor globals.'
HF3F0CC8F9DC0: 'ctor/dtorグローバル関数を呼び出すためのカーネルを生成'
# 'Emit limited coverage mapping information (experimental)'
H42E2BE163D31: '制限付きカバレッジマッピング情報の生成（実験的）'
# 'Emit log of dataflow analysis. With no arg, writes textual log to stderr. With an arg, writes HTML logs under the specified directory (one per analyzed function).'
HFAAFE42FF67A: 'データフロー解析のログを出力。引数なしで実行すると標準エラー出力にテキストログを出力。引数を指定すると、指定ディレクトリ配下にHTMLログを関数ごとに生成'
# 'Emit macro debug information'
H5AADCC833ADB: 'マクロデバッグ情報の生成'
# 'Emit metadata containing compiler name and version'
H02D252B322FC: 'コンパイラ名とバージョンを含むメタデータを生成'
# 'Emit module hash'
H8D92949B5594: 'モジュールハッシュを生成'
# 'Emit module summary index'
H81A5D22F1814: 'モジュール要約インデックスを生成'
# 'Emit native object files'
HD1D98EAD4C67: 'ネイティブオブジェクトファイルを生成'
# 'Emit non-functional but easy-to-read interfaces to debug.'
HFB7CBF2DAD9A: '機能不全だが読みやすいデバッグ用インターフェースを生成'
# 'Emit nothing, for performance testing'
H59E0020EF2FE: 'パフォーマンステスト用に何も生成しない'
# 'Emit numeric info in dump even if symbolic info is available'
H44DA13315AA2: 'シンボル情報が利用可能でもダンプで数値情報を出力'
# 'Emit output in the selected format if supported'
HDFDB7BBE51F4: 'サポートされている場合、選択された形式で出力'
# 'Emit pretty printed symbol graphs'
H9D5251957AE9: '整形したシンボルグラフを出力'
# 'Emit pristine LLVM IR from the frontend by not running any LLVM passes at all.Same as -S + -emit-llvm + -disable-llvm-passes.'
H4945F63ADF72: 'フロントエンドでLLVMパスを一切実行せずに未加工のLLVM IRを出力します。-S + -emit-llvm + -disable-llvm-passesと同じ。'
# 'Emit pseudo probes for sample profiling'
HEE6673E22F38: 'サンプルプロファイリング用の擬似プローブを出力'
# 'Emit pseudo probes to enable PGO profile generation.'
H68FBB431D14A: 'PGOプロファイル生成を有効にするための擬似プローブを出力'
# 'Emit reproducer on (option: off, crash (default), error, always)'
HA45B571A7690: '再現用出力の対象 (オプション: off, crash (デフォルト), error, always)'
# 'Emit section containing metadata on function stack sizes'
H55BB0296572C: '関数のスタックサイズに関するメタデータを含むセクションを出力'
# 'Emit special compound instrumentation for reads-before-writes'
H7C94AB6DD4CB: '読み取り優先書き込みのための特別な複合インストルメンテーションを出力'
# 'Emit special debug info to enable PGO profile generation.'
H92226FB5F865: 'PGOプロファイル生成を有効にするための特別なデバッグ情報を出力'
# 'Emit special instrumentation for accesses to volatiles'
H807EB1BCE795: 'volatileへのアクセスのための特別なインストルメンテーションを出力'
# 'Emit the GNU .debug_macro format with DWARF <5'
H05986F777FFF: 'DWARF 5未満の場合、GNU .debug_macroフォーマットを出力'
# 'Emit the XCOFF traceback table'
H2AD67289821E: 'XCOFFトレースバックテーブルを出力'
# 'Emit the basic block address map section'
HE67CB0846DD5: '基本ブロックアドレスマップセクションを出力'
# 'Emit the basic block address map section.'
HD66B24BE91BF: '基本ブロックアドレスマップセクションを出力'
# 'Emit the specified combiners'
HD6132B919401: '指定されたコンビナーを出力'
# 'Emit type record hashes in a .debug$H section'
HE5D98DDE9AE9: '.debug$Hセクションにタイプレコードハッシュを出力'
# "Emit verbose output about the analyzer's progress"
HF03ADA31D285: '分析器の進行状況に関する詳細な出力を行う'
# 'Emit xray_fn_idx section'
HCE1B25AEB13C: 'xray_fn_idx セクションを生成します'
# 'Emits more virtual tables to improve devirtualization'
HEF76217E9284: 'デバーチャル化を改善するためにより多くのバーチャルテーブルを生成します'
# 'Emulate weak link against library X. Must resolve to a TextAPI file, and all symbols in the interface will resolve to null.'
H1586C40C45A2: 'ライブラリXに対して弱いリンクをエミュレートします。XはTextAPIファイルを指す必要があります。このインターフェースに存在するすべてのシンボルはNULLに解決されます'
# 'Emulate weak link against library X. X must point to a TextAPI file, and all symbols in the interface will resolve to null'
HDE0D8058522D: 'ライブラリXに対して弱いリンクをエミュレートします。XはTextAPIファイルを指す必要があります。このインターフェースに存在するすべてのシンボルはNULLに解決されます'
# 'Enable -Wall'
HFE182F701ACC: 'すべての警告を有効にする(-Wall)を有効にします'
# 'Enable -Wall and -Wextra'
HCCDF3CF2B538: 'すべての警告を有効にする(-Wall)と追加警告(-Wextra)を有効にします'
# 'Enable -Weverything'
H85639A20AE92: 'すべての警告を有効にする(-Weverything)を有効にします'
# 'Enable -Wsystem-headers'
HCF6CBF83669C: 'システムヘッダの警告を有効にします(-Wsystem-headers)'
# 'Enable -Wsystem-headers when building <module>'
H7BD118FCCA2F: 'モジュール<module>をビルドする際に-Wsystem-headersを有効にします'
# 'Enable -time-passes memory tracking (this may be slow)'
HCD77711AC848: 'パスごとのメモリ追跡を有効にします(-time-passes)。ただし、これによりパフォーマンスが低下する可能性があります'
# 'Enable .XOR. as a synonym of .NEQV.'
H26B24A90CE2E: '.XOR.を.NEQV.の別名として有効にします'
# 'Enable / disable ARM interworking (for debugging only)'
H0E7C6271B7D5: 'ARM相互動作を有効/無効にします(デバッグ用のみ)'
# 'Enable / disable SVE scalable vectors in Global ISel'
H2EC78B18E661: 'Global ISelでSVEスケーラブルベクタを有効/無効にします'
# 'Enable / disable promotion of unnamed_addr constants into constant pools'
HFAE28EE53BD3: 'unnamed_addr定数を定数プールに昇格させる機能を有効/無効にします'
# 'Enable 16-bit types and disable min precision types.Available in HLSL 2018 and shader model 6.2.'
HAAC77E9561C2: '16ビット型を有効にして最小精度型を無効にします。HLSL 2018およびシェーダーモデル6.2で利用可能です'
# 'Enable <feature> in module map requires declarations'
H5C8DA92AFFD8: 'モジュールマップで<feature>を有効にするには宣言が必要です'
# 'Enable AArch64 SME memory operations to lower to librt functions'
H2DE7C9221C4E: 'AArch64の論理的即値命令の最適化を有効にします'
# 'Enable AArch64 logical imm instruction optimization'
H3E7D3BE3C68D: 'AArch64論理即値命令の最適化を有効にする'
# 'Enable AMDGPU Alias Analysis'
H6232FED85C51: 'AMDGPUエイリアス分析を有効にする'
# 'Enable AMDGPU function call support'
HA046043EEDCA: 'AMDGPU関数呼び出しサポートを有効にする'
# 'Enable AMDGPUAttributorPass'
H9BDDE4ABB4D1: 'AMDGPUAttributorPassを有効にする'
# 'Enable ARC-style weak references in Objective-C'
H9B793CE9E824: 'Objective-CでARC方式の弱参照を有効にする'
# 'Enable ARM 2-addr to 3-addr conv'
HFA9A2110C825: 'ARM 2-addrから3-addrへの変換を有効にする'
# 'Enable ARM load/store optimization pass'
HF1C1057F91DB: 'ARMロード/ストア最適化パスを有効にする'
# 'Enable AddressSanitizer'
H10A93E69F908: 'AddressSanitizerを有効にする'
# 'Enable AltiVec vector initializer syntax'
H39CF1AD1DDBB: 'AltiVecベクタ初期化子構文を有効にする'
# 'Enable Apple gcc-compatible #pragma pack handling'
HF6255EFF4697: 'Apple gcc互換の#pragma pack処理を有効にする'
# 'Enable BFI update verification for CodeGenPrepare.'
HDEF1BBE64E03: 'CodeGenPrepareのBFI更新検証を有効にする'
# 'Enable C++ builtin type char8_t'
HB51A1047EAD1: 'C++組み込み型char8_tを有効にする'
# 'Enable C++ builtin type wchar_t (default)'
H2E6A98E0A8E9: 'C++組み込み型wchar_tを有効にする（既定値）'
# 'Enable C++ exceptions'
HD8120A0570B1: 'C++例外を有効にする'
# 'Enable C++14 sized global deallocation functions'
HA9B36C7CDED1: 'C++14サイズ付きグローバル解放関数を有効にする'
# 'Enable C++17 aligned allocation functions'
H3A997E1CD1C0: 'C++17アライメント付き割り当て関数を有効にする'
# 'Enable C-SKY asm compressed instruction'
HE6033CE9D615: 'C-SKYアセンブリ圧縮命令を有効にする'
# 'Enable CABAC instructions'
HCAFDAD7AAC69: 'CABAC命令を有効にする'
# 'Enable CREL relocation format (ELF only)'
H0C82A363E7CF: 'CREL再配置形式を有効にする（ELFのみ）'
# 'Enable CodeView debug information in object files'
H190F12E62C0D: 'オブジェクトファイルでCodeViewデバッグ情報を有効にする'
# 'Enable Control Flow Guard with /guard:cf, or only the table with /guard:cf,nochecks. Enable EH Continuation Guard with /guard:ehcont'
H0DCA490E39F9: '/guard:cfでコントロール・フロー・ガードを有効化、または/guard:cf,nochecksでテーブルのみ有効化。/guard:ehcontでEH継続ガードを有効化'
# 'Enable CopyToPhi DAG Mutation'
H795903E75A63: 'CopyToPhi DAGムーテーションを有効化'
# "Enable DAG combiner's use of IR alias analysis"
HEFB2E9C4316E: 'DAGコンビナーがIRエイリアス解析を使用するように有効化'
# "Enable DAG combiner's use of TBAA"
HC13D2DED69A7: 'DAGコンビナーがTBAAを使用するように有効化'
# 'Enable DFA jump threading'
HDA1B9DF0576D: 'DFA jumpスレッディングを有効化'
# 'Enable DPP combiner'
H1C2845754879: 'DPPコンビナーを有効化'
# 'Enable Debug Info Metadata preservation testing in optimizations.'
H261A5A2FD07D: '最適化中にデバッグ情報メタデータの保持テストを有効化'
# 'Enable Debugger hook for debugging MLIR Actions'
H7236F64CF290: 'MLIRアクションのデバッグ用デバッグハックを有効化'
# 'Enable EH Asynchronous exceptions'
H2CA5CA1CFDC6: 'EH非同期例外を有効化'
# 'Enable FP math optimizations that assume approx func'
HA55AFA6BF75B: '近似関数を仮定するFP数値最適化を有効化'
# 'Enable FP math optimizations that assume no +-Infs'
H3B25285FD614: '±無限大がないと仮定するFP数値最適化を有効化'
# 'Enable FP math optimizations that assume no NaNs'
H9640D97F95AD: 'NaNがないと仮定するFP数値最適化を有効化'
# 'Enable FP math optimizations that assume the sign of 0 is insignificant'
HE827F0FDD8E0: '0の符号を無視すると仮定するFP数値最適化を有効化'
# 'Enable Fast Math processing'
H2F61C44B4052: '高速マス処理を有効化'
# 'Enable Freestanding (disable builtins / TLI) during LTO'
H4C62FBB216B5: 'LTO中にFreestandingモード（builtins/TLI無効）を有効化'
# 'Enable GPU Mode managed|unified'
H1342A6457C14: 'GPUモード managed|unified を有効化'
# 'Enable Global-ISel Big Endian Lowering'
H51843BE1AC18: 'Global-ISelビッグエンディアン変換を有効化'
# 'Enable GlobalISel at or below an opt level (-1 to disable)'
HD97724CE8B7C: 'GlobalISelを最適化レベル以下で有効化（-1で無効化）'
# "Enable GlobalISel's post-legalizer load/store optimization pass"
H6BA2F1588338: 'GlobalISelのポスト・レガリナイザ ロード/ストア最適化パスを有効化'
# "Enable GlobalISel's pre-legalizer load/store optimization pass"
H7E199DBC971A: 'GlobalISelのpre-legalizerロード/ストア最適化パスを有効にする'
# 'Enable HIP Standard Parallelism Offload support'
H1C99F32D38F4: 'HIP標準並列化オフロードサポートを有効にする'
# 'Enable HIP acceleration for standard parallel algorithms'
H03CDA0DFF566: '標準並列アルゴリズムのHIPアクセラレーションを有効にする'
# 'Enable HVX IEEE floating point extensions'
HEDB94BF0B878: 'HVXのIEEE浮動小数点拡張機能を有効にする'
# 'Enable HVX vector combining'
HDFF35C9FE78C: 'HVXベクター結合を有効にする'
# 'Enable Hexagon HVX IEEE floating-point'
HB190E3ACA8B9: 'Hexagon HVXのIEEE浮動小数点を有効にする'
# 'Enable Hexagon HVX QFloat instructions'
HD10ED4BFBA4F: 'Hexagon HVXのQFloat命令を有効にする'
# 'Enable Hexagon SDNode scheduling'
H421486189A34: 'Hexagon SDNodeスケジューリングを有効にする'
# 'Enable Hexagon Vector eXtensions'
H849D45B20815: 'Hexagonベクター拡張機能を有効にする'
# 'Enable Hexagon Vector print instr pass'
HF6F3126A4402: 'Hexagonベクター印刷命令パスを有効にする'
# 'Enable Hexagon constant-extender optimization'
HB232046E41EF: 'Hexagon定数拡張最適化を有効にする'
# 'Enable Hexagon copy hoisting'
H52502969FA5F: 'Hexagonコピーハイステインを有効にする'
# 'Enable Hexagon-specific memcpy for volatile destination.'
H37F33A534B6A: 'Hexagon固有のvolatile宛先用memcpyを有効にする'
# 'Enable IBM XL #pragma pack handling'
H56C08FC94B0D: 'IBM XLの#pragma pack処理を有効にする'
# 'Enable ICMP_EQ to ICMP_S(L|G)T conversion.'
H50B860EE6750: 'ICMP_EQをICMP_S(L|G)Tに変換する機能を有効にする'
# 'Enable JumpTableToSwitch pass (default = off)'
H595911A42177: 'JumpTableToSwitchパスを有効にする (デフォルト: 無効)'
# 'Enable KernelAddressSanitizer instrumentation'
HDC17AF33380B: 'KernelAddressSanitizerのインストゥルメンテーションを有効にする'
# 'Enable KernelHWAddressSanitizer instrumentation'
HE6892C669196: 'KernelHWAddressSanitizerのインストゥルメンテーションを有効にする'
# 'Enable KernelMemorySanitizer instrumentation'
H98BCB50602AD: 'KernelMemorySanitizerのインストゥルメンテーションを有効にする'
# 'Enable LSR phi elimination'
H6F6B88180DCF: 'LSR phi除去を有効にする'
# "Enable LTO in 'full' mode"
HDE2B72E90D39: 'フル モードでLTOを有効にする'
# "Enable LTO in 'full' mode for offload compilation"
H1AD130930D3D: 'オフロード コンパイル用にフル モードでLTOを有効にする'
# 'Enable Loongson Advanced SIMD Extension (LASX).'
H8708BF686447: 'Loongson Advanced SIMD拡張(LASX)を有効にする。'
# 'Enable Loongson SIMD Extension (LSX).'
H9319CC082DD4: 'Loongson SIMD拡張(LSX)を有効にする。'
# 'Enable MASM-style hex float initializers (3F800000r)'
H44F2E6A19192: 'MASMスタイルの16進数浮動小数点初期化子(3F800000r)を有効にする'
# 'Enable MC/DC criteria when generating code coverage'
HDDD25377703C: 'コード カバレッジ生成時にMC/DC基準を有効にする'
# 'Enable ML policy for inliner. Currently trained for -Oz only'
H4BD737EDDE37: 'インライナに対してMLポリシーを有効にする。現在は-Ozでのみ訓練済み'
# 'Enable MSA ASE (MIPS only)'
HF57FBC9A1C49: 'MSA ASE(MIPS専用)を有効にする'
# 'Enable MT ASE (MIPS only)'
H4037C7D0B0DC: 'MT ASE(MIPS専用)を有効にする'
# 'Enable Machine Pipeliner for AArch64'
HC2A6D688CFC7: 'AArch64用Machine Pipelinerを有効にする'
# 'Enable Machine Pipeliner for PPC'
H533D989E39D2: 'PPC用Machine Pipelinerを有効にする'
# 'Enable Machine Pipeliner for RISC-V'
H06DAB50244BB: 'RISC-V用Machine Pipelinerを有効にする'
# 'Enable MemProf context disambiguation'
H31287310FC75: 'MemProfコンテキストの不整合を解消する'
# 'Enable MemProf support for summarizing and cloning indirect calls'
H467E2FD95CC9: 'MemProfが間接呼び出しの要約と複製をサポートする'
# 'Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size'
H305D879EAD05: 'ODR違反報告の誤検出を回避するためにODRインジケーター_globalsを有効にする。部分的にsanitizeされたプログラムでの対応だが、バイナリサイズが増加する'
# 'Enable Objective-C Ivar layout bitmap print trace'
H8E7C0A4EC106: 'Objective-C Ivar配置ビットマップのトレース出力を有効にする'
# 'Enable Objective-C exceptions'
HC28B4C97C29D: 'Objective-C例外を有効にする'
# 'Enable Objective-C garbage collection'
HC3AA6362E4C5: 'Objective-Cガベージ コレクションを有効にする'
# 'Enable OpenACC'
HFA0D5CED023C: 'OpenACCを有効にする'
# 'Enable OpenMP support'
HBFD2A2659227: 'OpenMPサポートを有効にする'
# 'Enable OpenMP support with experimental SIMD support'
H3F6D5F2001FE: '実験的なSIMDサポートを有効にしてOpenMPを有効化'
# 'Enable PC tracing in sanitizer coverage'
H63A67D8CBA77: 'sanitizer coverageでPCトレースを有効化'
# 'Enable PC tracing with guard in sanitizer coverage'
HF28D97CE20BD: 'sanitizer coverageでガード付きのPCトレースを有効化'
# 'Enable PGO instrumentation'
H275AC31A4E6B: 'PGOインストルメンテーションを有効化'
# 'Enable Passing SSP Canary info in Trackback on AIX'
HF2D40BF85363: 'AIXのTrackbackでSSP Canary情報を渡す機能を有効化'
# 'Enable PatchPoint Liveness Analysis Pass'
HC23201EA3F30: 'PatchPoint Live分析パスを有効化'
# 'Enable PostRA load and store clustering in the machine scheduler'
H7DBDA92CD831: 'マシンスケジューラでPostRAのロードとストアクラスタリングを有効化'
# 'Enable Pre-RA optimizations pass'
HBF2BE955A63C: 'Pre-RA最適化パスを有効化'
# 'Enable RDF-based optimizations'
HB93D1CE5916C: 'RDFベースの最適化を有効化'
# 'Enable SDWA peepholer'
HAA3AA4CDEBA5: 'SDWAピーヒーラを有効化'
# 'Enable SVE intrinsic opts'
HC49B4494813B: 'SVE intrinsic最適化を有効化'
# 'Enable SVR4-style position-independent code (Mips only)'
H39A5D03E5D80: 'SVR4スタイルの位置独立コードを有効化（Mipsのみ）'
# 'Enable SWP at Os.'
HE7BF8843A5BE: 'OsでSWPを有効化'
# 'Enable SYCL C++ extensions'
HB66B108F597C: 'SYCL C++拡張機能を有効化'
# 'Enable Software Pipelining'
H701BBA1060C2: 'ソフトウェアパイプラインを有効化'
# 'Enable System z vector language extension'
H0ADCFE4F5EB1: 'System zベクタ言語拡張を有効化'
# 'Enable ThinLTO caching.'
H4E40230CBB89: 'ThinLTOキャッシュを有効化'
# 'Enable Unroll And Jam Pass'
HC78C6B520033: 'Unroll And Jam パスを有効化'
# 'Enable V8+ mode, allowing use of 64-bit V9 instructions in 32-bit code'
H51CF3B974577: 'V8+モードを有効化（32ビットコードで64ビットV9命令を使用可能）'
# 'Enable VGPR liverange optimizations for if-else structure'
H7A56B298E40B: 'if-else構造のVGPR Live範囲最適化を有効化'
# 'Enable VOPD, dual issue of VALU in wave32'
H89877353D212: 'VOPDを有効化、wave32におけるVALUのデュアル発行を有効化'
# 'Enable VPlan-native vectorization path with support for outer loop vectorization.'
H5546DBF9A313: '外側ループのベクタライゼーションをサポートするVPlanネイティブベクタライゼーションパスを有効化'
# 'Enable X86 indirect branch tracking pass.'
H9D4BDB5AD7B9: 'X86の間接分岐トラッキングパスを有効化します。'
# 'Enable a 2nd level loop of loop tiling'
HCA8FDA365AE9: 'ループタイルの2段階目のループを有効化します。'
# 'Enable a specific type of debug output (comma separated list of types)'
H3151AFA58B61: '特定の種類のデバッグ出力を有効化（タイプのカンマ区切りリスト）'
# 'Enable abort calls when "fast" instruction selection fails to lower an instruction: 0 disable the abort, 1 will abort but for args, calls and terminators, 2 will also abort for argument lowering, and 3 will never fallback to SelectionDAG.'
H1EC44B72B380: '「fast」命令選択が命令を低次化できなかった場合、abortコールを有効化します: 0はabortを無効化、1は引数、コール、終端命令に対してabort、2は引数の低次化でもabort、3はSelectionDAGへの後退を決して行わない。'
# 'Enable abort calls when "global" instruction selection fails to lower/select an instruction'
HC411401F6CE3: '「global」命令選択が命令を低次化/選択できなかった場合、abortコールを有効化します。'
# 'Enable adding flow sensitive discriminators'
H127CCD0CABA6: 'フローセンシティブなdiscriminatorを追加する機能を有効化します。'
# 'Enable adding inline-remark attribute to callsites processed by inliner but decided to be not inlined'
HFF28D2651FAF: 'インライン処理でインライン化されなかったコールサイトにinline-remark属性を追加する機能を有効化します。'
# 'Enable additional debug output'
HBEA92C1C802B: '追加のデバッグ出力を有効化します。'
# 'Enable address discrimination of function pointers in init/fini arrays'
H45A216E54E14: 'init/fini配列内の関数ポインタのアドレス区別を有効化します。'
# 'Enable address discrimination of vtable pointers'
H248ADBB468B0: 'vtableポインタのアドレス区別を有効化します。'
# 'Enable aggressive formation of fused FP ops'
HD91A957036F5: '融合FPオペレーションの積極的な形成を有効化します。'
# 'Enable aliasing mode in HWAddressSanitizer'
HFC48EEE3F6A8: 'HWAddressSanitizerのエイリアシングモードを有効化します。'
# 'Enable all Clang extensions for OpenMP directives and clauses'
H1D7ED18ACD09: 'OpenMPディレクティブと句に対するすべてのClang拡張機能を有効化します。'
# 'Enable all mitigations for Load Value Injection (LVI)'
H62EE869ADC27: 'Load Value Injection (LVI)に対するすべての軽減策を有効化します。'
# 'Enable all options'
HEE8F72CD2211: 'すべてのオプションを有効化します。'
# 'Enable all traces.'
H57C177E41601: 'すべてのトレースを有効化します。'
# "Enable alternative token representations '<:', ':>', '<%', '%>', '%:', '%:%:' (default)"
H4DF4837FAB61: "代替トークン表現 '<:', ':>', '<%', '%>', '%:', '%:%:' を有効化（デフォルト）"
# 'Enable amcas[_db].{b/h/w/d}'
H63806DAD9D8C: 'amcas[_db].{b/h/w/d} を有効化します。'
# 'Enable amdgpu library simplifications'
HECCE410BA86E: 'amdgpuライブラリの単純化を有効にする'
# 'Enable amswap[_db].{b/h} and amadd[_db].{b/h}'
H8299FC02710F: 'amswap[_db].{b/h} と amadd[_db].{b/h} を有効にする'
# 'Enable analysis of vscale-relative immediates in LSR'
H82C5A0E019DD: 'LSRでのvscale相対即値の分析を有効にする'
# 'Enable analyzing function argument and return types for mandatory definedness'
HF2001822C16A: '関数引数と戻り値の型の必須定義性を分析する機能を有効にする'
# 'Enable annotate table jump instruction to correlate it with the jump table.'
HFDE9D12C2ECD: 'ジャンプテーブルと関連付けるためのアノテーションテーブルジャンプ命令を有効にする'
# 'Enable array bounds checking'
HD533CAFCE917: '配列境界チェックを有効にする'
# 'Enable assumed rank lowering'
H38B9CF78153E: '仮定ランクの低減を有効にする'
# 'Enable atomic operations instrumentation in ThreadSanitizer (default)'
H28E05B9D8B0A: 'ThreadSanitizerでの原子操作のインストルメンテーションを有効にする（デフォルト）'
# 'Enable authentication of pointers from GOT (ELF only)'
HEE1192FA1CBD: 'GOT（ELFのみ）からのポインタ認証を有効にする'
# 'Enable auto-vectorization of floatint point types on v68.'
H407986FED01C: 'v68での浮動小数点型のオートベクタライゼーションを有効にする'
# 'Enable basic block tracing in sanitizer coverage'
HB288E3CF4716: 'サニタイザーカバレッジでの基本ブロックトレースを有効にする'
# 'Enable binary and hex Motorola integers (%110 and $ABC)'
H929D942FA2B2: 'バイナリとヘックスのMotorola整数 (%110 と $ABC) の有効化'
# 'Enable binary and hex masm integers (0b110 and 0ABCh)'
H299555A297D6: 'バイナリとヘックスのmasm整数 (0b110 と 0ABCh) の有効化'
# 'Enable binary output on terminals'
HB1EFC8602261: '端末でのバイナリ出力を有効にする'
# 'Enable bottleneck analysis (disabled by default)'
H0EF8CE1914F9: 'ボトルネック分析を有効にする（デフォルトでは無効）'
# 'Enable branch hint.'
HA68C6AA0EC92: 'ブランチヒントを有効にする'
# 'Enable branch prediction'
HA09824F26C29: 'ブランチ予測を有効にする'
# 'Enable branch probability info'
HACC86396C5DC: 'ブランチ確率情報を有効にする'
# 'Enable buffer security check (default)'
HC4E83D1F5690: 'バッファーセキュリティチェックを有効にする（デフォルト）'
# 'Enable builtin #include directories even when -nostdinc is used before or after -ibuiltininc. Using -nobuiltininc after the option disables it'
H03545481E610: '-nostdincが-ibuiltinincの前後で使用されても、組み込みの#includeディレクトリを有効にします。このオプション後に-nobuiltinincを使用すると無効になります'
# 'Enable caret and column diagnostics (default)'
HB9B531DB1BD2: 'caretと列番号の診断を有効にする (既定)'
# 'Enable casting unknown expression results to id'
H1BB41E97517E: '未知の式の結果をidにキャストすることを有効にする'
# "Enable cf-protection in 'full' mode"
HB3ADE4BC6E10: "'full' モードでcf-protectionを有効にする"
# 'Enable chain commoning in PPC loop prepare pass.'
HA72C1C0CBB48: 'PPCループ準備パスでのチェーン コモンイングを有効にする'
# 'Enable char8_t from C++2a'
HE9352E073F40: 'C++2aからchar8_tを有効にする'
# 'Enable checking for cache bank conflicts'
HD40C33D97687: 'キャッシュ バンクの衝突を検出する機能を有効にする'
# "Enable checking of SDNode's single-use status"
H2C3A08FCCF0D: 'SDNodeの単一使用状態のチェックを有効にする'
# 'Enable checking of constexpr function bodies for validity within a constant expression context'
HD3707040DC7C: 'constexpr関数の本体が定数式コンテキストで有効かどうかをチェックする機能を有効にする'
# 'Enable cmp instruction tracing in sanitizer coverage'
H903963183CE2: 'sanitizer coverageでcmp命令のトレースを有効にする'
# 'Enable code sinking'
HC9AEC37E0425: 'コード シンキングを有効にする'
# 'Enable cold function only instrumentation.'
H103EC2AD6CD5: 'cold関数専用のインストルメンテーションを有効にする'
# 'Enable collecting coverage from system headers'
H14D681672737: 'システム ヘッダーからのカバレッジ収集を有効にする'
# 'Enable colors in diagnostics'
H2602C065FC54: '診断メッセージでの色使用を有効にする'
# 'Enable command line arguments round-trip.'
H0FC588FEB00A: 'コマンドライン引数の round-trip (往復) を有効にする'
# 'Enable commoning of GEP instructions'
H21E18391E092: 'GEP命令のコモンイングを有効にする'
# 'Enable communicating debuginfo positions through iterators, eliminating intrinsics. Has no effect if --preserve-input-debuginfo-format=true.'
H99F0E8039EFB: 'イテレーターを通じてデバッグ情報の位置を伝達し、組み込み関数を削除する機能を有効にする。--preserve-input-debuginfo-format=trueの場合、効果なし。'
# 'Enable conflict detection in loop-access analysis'
H9866609C7AAA: 'ループ アクセス分析での競合検出を有効にする'
# 'Enable consecutive memop optimization in AArch64PostLegalizerCombiner'
H8A9AB4FF7791: 'AArch64PostLegalizerCombinerでの連続メモオプの最適化を有効にする'
# 'Enable continuous instrumentation profiling mode'
HCFE5EA586D23: '継続的なインストルメンテーション プロファイリング モードを有効にする'
# 'Enable control flow (and PHI) hoisting in LICM'
H655AACCB94AB: 'LICMでの制御フロー（およびPHI）のHoistingを有効にする'
# 'Enable control flow integrity (CFI) checks for cross-DSO calls.'
H65983BF9B362: 'クロス-DSOコールに対する制御フロー整合性（CFI）チェックを有効にする'
# 'Enable control height reduction optimization (CHR)'
H0F0478FE42AF: '制御高さ削減最適化（CHR）を有効にする'
# 'Enable conversion of arithmetic operations to predicate instructions'
H0A4B03E5BC23: '算術演算を述語命令に変換する機能を有効にする'
# 'Enable converting conditional transfers into MUX instructions'
HC372E511555B: '条件付き転送をMUX命令に変換する機能を有効にする'
# 'Enable converting phi types in CodeGenPrepare'
H646E9AD5179B: 'CodeGenPrepareでのphi型の変換を有効にする'
# 'Enable crash diagnostic reporting (default)'
H57A29C53DDA2: 'クラッシュ診断報告を有効にする（既定値）'
# 'Enable cross-cu references in DWO files'
H371A16C91C53: 'DWOファイルでのcross-cu参照を有効にする'
# 'Enable cyclic critical path analysis.'
HF81A62B6A5A8: '巡回クリティカルパス分析を有効にする'
# 'Enable debug info for the debug entry values.'
H62773C4101CF: 'デバッグエントリ値のデバッグ情報を有効にする'
# 'Enable debug messages while writing module files'
H8923A1076553: 'モジュールファイルの書き込み中にデバッグメッセージを有効にする'
# 'Enable debug output'
H8FF327476155: 'デバッグ出力を有効にする'
# 'Enable debug output for only polly passes.'
HBDB1EA3DBD28: 'Pollyパス専用のデバッグ出力を有効にする'
# 'Enable debugger suppport (default = !-noexec)'
H835D3E853677: 'デバッガーサポートを有効にする（既定値=!-noexec）'
# 'Enable debugging in the OpenMP offloading device RTL'
H333C6CC1A821: 'OpenMPオフローディングデバイスRTLでのデバッグを有効にする'
# 'Enable debuginfod'
H6FC46DBD1099: 'debuginfodを有効にする'
# 'Enable deferred inlining'
H2F93ACD0E23A: '遅延インラインを有効にする'
# 'Enable dense outer loop sparse parallelization.'
H9C0E69F4C10C: '密集した外側ループの疎な並列化を有効にする'
# 'Enable dense parallelization for any loop.'
H966B38C95DEA: '任意のループに対して密集した並列化を有効にする'
# 'Enable detailed timing of insert generation'
H2B4DFBE7DA6E: '挿入生成の詳細なタイミング測定を有効にする'
# 'Enable detection of uninitialized parameters and return values'
H37967C89985E: '未初期化パラメータと戻り値の検出を有効にする'
# 'Enable device-side debug info generation. Disables ptxas optimizations.'
HBE33969C4B31: 'デバイス側のデバッグ情報生成を有効にします。ptxasの最適化を無効にします。'
# 'Enable direct TLS access through segment registers (default)'
H6B41286A3288: 'セグメントレジスタを介した直接TLSアクセスを有効にする（既定値）'
# 'Enable div instruction tracing in sanitizer coverage'
H70F6EE4DB4D3: 'sanitizer カバレッジでのdiv命令のトレースを有効にする'
# 'Enable early if-conversion'
HCD88FA9972DA: '早期のif-conversionを有効にする'
# 'Enable early if-conversion on X86'
H54EA1744EB53: 'X86上で早期のif-conversionを有効にする'
# 'Enable elimination of non-kernel functions and unused globals'
H565DB5148508: '非カーネル関数と未使用グローバル変数の削除を有効にする'
# 'Enable emitting RISC-V ELF attributes for ABI features'
HEE2BA9740DE2: 'ABI機能用のRISC-V ELF属性を出力する'
# 'Enable emitting complete constructors and destructors as aliases when possible'
HD806A5232009: '可能な場合、完全なコンストラクタとデストラクタをエイリアスとして出力する'
# 'Enable enhanced struct-path aware Type Based Alias Analysis'
HB0D34B7D8979: '強化された構造体パス認識型ベースのエイリアス解析を有効にする'
# 'Enable experimental bounds safety extension for C'
H19BF4377E02E: 'C用の実験的境界安全性拡張を有効にする'
# 'Enable experimental late parsing of attributes'
H9BF048F97F63: '属性の遅延パースを有効にする（実験的）'
# 'Enable extended information within the SHT_LLVM_BB_ADDR_MAP that is extracted from PGO related analysis.'
H90477C1DC52F: 'PGO関連分析から抽出されるSHT_LLVM_BB_ADDR_MAP内の拡張情報の出力'
# 'Enable external API notes support'
H5E8A30586330: '外部APIノートサポートを有効にする'
# 'Enable fat LTO object support'
H21F1B6309F52: 'fat LTOオブジェクトサポートを有効にする'
# 'Enable features of APX'
HD328EFFFB9A0: 'APXの機能を有効にする'
# 'Enable fixed point types'
H0490DFC8424C: '定点数型を有効にする'
# 'Enable formatting of code changed by applying replacements.\nUse -style to choose formatting style.\n'
H8F0F987DA270: '置換の適用で変更されたコードのフォーマットを有効化します。\n-styleオプションでフォーマットスタイルを指定します。\n'
# 'Enable frame pointer elimination'
HAEAFB8EDDF71: 'フレームポインタの削除を有効にする'
# 'Enable frame pointer elimination, but reserve the frame pointer register'
HE8BA912638EF: 'フレームポインタレジスタを保持したままフレームポインタ削除を有効にする'
# 'Enable frame pointer omission (x86 only)'
H4DBA3F274530: 'x86のみでフレームポインタの省略を有効にする'
# 'Enable frecipe.{s/d} and frsqrte.{s/d}'
H3977CB98EF0D: 'frecipe.{s/d} および frsqrte.{s/d} の有効化'
# 'Enable frequency counters in sanitizer coverage'
H5B9962B0B423: 'sanitizer カバレッジでの周波数カウンタの有効化'
# 'Enable full Microsoft Visual C++ compatibility'
H12B2EDEE6E67: '全米式Microsoft Visual C++との互換性を有効にする'
# 'Enable function entry/exit instrumentation in ThreadSanitizer (default)'
H852113DDBCFA: 'ThreadSanitizerでの関数の開始/終了のインストルメンテーションを有効化（既定値）'
# 'Enable function merging as part of the optimization pipeline'
H3BF73DD457C7: '最適化パイプラインにおける関数マージを有効化'
# 'Enable function outlining (AArch64 only)'
H15FFCDCECD61: 'AArch64のみで関数アウトライン化を有効にする'
# 'Enable function specialization on the address of global values'
H46D83DE2E772: 'グローバル値のアドレスに対して関数の特殊化を有効化'
# 'Enable garbage-collecting empty basic blocks'
H82096BB5EF83: '空の基本ブロックのガベージコレクションを有効化'
# 'Enable generating trap for unreachable'
HA93A4015EC75: '到達不能コードでトラップを生成するようにする'
# 'Enable generation of complex instructions'
HD949F4B874C3: '複雑な命令の生成を有効化'
# 'Enable generation of instruction packets'
H9270F92493EE: '命令パケットの生成を有効化'
# 'Enable generation of memop instructions'
HA7AE5A0F239A: 'memop命令の生成を有効化'
# 'Enable generation of new-value jumps'
H88666002BB2B: '新値ジャンプの生成を有効化'
# 'Enable generation of new-value stores'
HE01CC1564066: '新値ストアの生成を有効化'
# 'Enable gep instruction tracing in sanitizer coverage'
H24F638FE5491: 'sanitizer カバレッジでのgep命令のトレーシングを有効化'
# 'Enable global load scalarization'
HEACC856F3BB8: 'グローバルロードスカラライゼーションを有効化'
# 'Enable global merge functions that are based on hash function'
H5280CEF67BB7: 'ハッシュ関数に基づくグローバル関数マージを有効化'
# 'Enable global merge pass on constants'
H16452CA5347D: '定数に対するグローバルマージパスを有効化'
# 'Enable global merge pass on external linkage'
HB636A98A47D2: '外部リンケージに対するグローバルマージパスを有効化'
# 'Enable global value internalization in LTO'
HD751EE9A7CD2: 'LTO内のグローバル値の内部化を有効にする'
# 'Enable gp-relative addressing of mips small data items'
H4B029B95E3C4: 'mipsの小さなデータ項目に対するgp相対アドレス指定を有効にする'
# 'Enable hashing of all compiler options that could impact the semantics of a module in an implicit build'
H3D8DF6DE718C: '暗黙のビルドにおけるモジュールの意味論に影響を与える可能性のあるすべてのコンパイラオプションのハッシュ化を有効にする'
# 'Enable hashing the content of a module file'
H181E6C00680E: 'モジュールファイルの内容のハッシュ化を有効にする'
# 'Enable heap memory profiling'
H80510263BC9C: 'ヒープメモリのプロファイリングを有効にする'
# 'Enable heap memory profiling and dump results into <directory>'
H29A449A8CDB1: 'ヒープメモリのプロファイリングを有効にし、結果を<directory>にダンプします'
# 'Enable hexagon-qdsp6 backward compatibility'
HC33E9FDD1F01: 'HEXAGON-QDSP6の後方互換性を有効にする'
# 'Enable hot-cold splitting pass'
H303E669D24AE: 'ホット-コールド分割パスを有効にする'
# 'Enable hot/cold operator new library calls'
HC2E3EA90629E: 'hot/cold operator newライブラリコールを有効にする'
# 'Enable identical code folding'
H28BAA680F117: '同一コードの折り畳みを有効にする'
# 'Enable if predication of stores during vectorization.'
HA5E79DD1344A: 'ベクトル化中にストアのif予測を有効にする'
# 'Enable if-conversion during vectorization.'
H0446E14EDCAC: 'ベクトル化中のif変換を有効にする'
# 'Enable image intrinsic optimizer pass'
H97E756CD1450: '画像固有の最適化パスを有効にする'
# 'Enable implicit vector bit-casts'
HEB80538424B3: '暗黙のベクタビットキャストを有効にする'
# "Enable import metadata like 'thinlto_src_module' and 'thinlto_src_file'"
H2A8113D65BE4: "'thinlto_src_module'や'thinlto_src_file'などのメタデータのインポートを有効にする"
# 'Enable imprecision in EarlyCSE in pathological cases, in exchange for faster compile. Caps the MemorySSA clobbering calls.'
HAA73048B5B86: '病的ケースにおけるEarlyCSEの不正確さを有効にし、より高速なコンパイルを交換します。MemorySSAのclobberingコールを制限します。'
# 'Enable imprecision in LICM in pathological cases, in exchange for faster compile. Caps the MemorySSA clobbering calls.'
H636968D53932: '病的ケースにおけるLICMの不正確さを有効にし、高速コンパイルを交換します。MemorySSAのclobberingコールを制限します。'
# 'Enable incremental processing extensions such as processing statements on the global scope.'
H6BA53F1C325A: 'グローバルスコープのステートメント処理など、インクリメンタル処理拡張機能を有効にする'
# 'Enable inline 8-bit counters in sanitizer coverage'
H519F01E8620F: 'インライン8ビットカウンタをsanitizerカバレッジに有効にする'
# 'Enable inline bool flag in sanitizer coverage'
HC8EAB045EC47: 'インラインboolフラグをsanitizerカバレッジに有効にする'
# 'Enable inline deferral during PGO'
H66E4DB2AD29F: 'PGO中にインライン遅延を有効にします'
# 'Enable inliner stats for imported functions'
H0D332728E36F: 'インポートされた関数のインライン統計情報を有効にします'
# 'Enable instsimplify'
HB39E8D05245E: 'instsimplifyを有効にします'
# 'Enable inter-procedural analyses'
H528C6719D608: 'Inter-procedural解析を有効にします'
# 'Enable interleave MVE vector operation lowering'
H8E26ADE70A0E: 'MVEベクター操作の順序入れ子化を有効にします'
# 'Enable interprocedural register allocation to reduce load/store at procedure calls.'
H6F0CA76DA224: 'プロシージャ呼び出し時のロード/ストアを削減するためにプロシージャ間レジスタ割り当てを有効にします'
# 'Enable ir outliner pass'
H06C93577A2B7: 'IRアウトラインパスを有効にします'
# 'Enable just-my-code debugging'
H59918B7E8599: 'Just My Codeデバッグを有効にします'
# 'Enable keeping all variables that have a persistent storage duration, including global, static and thread-local variables, to guarantee that they can be directly addressed'
H04E5C2AB8675: '一貫したストレージ期間を持つ変数（グローバル、静的、スレッド局所変数を含む）をすべて保持し、それらが直接参照可能になるようにします'
# 'Enable late function splitting using profile information (x86 and aarch64 ELF)'
H4664498771BF: 'プロファイル情報を使用した遅延関数分割を有効にします（x86およびaarch64 ELF）'
# 'Enable lazy compilation when using the MCJIT engine'
H1A4A6063E46C: 'MCJITエンジンを使用する場合、遅延コンパイルを有効にします'
# 'Enable linker dead stripping of globals in AddressSanitizer'
H9E8C5D19A202: 'AddressSanitizerでグローバル変数のデッドストリップをリンカーで有効にします'
# 'Enable linker job to emit a static library.'
H1300A9593E8D: 'リンカーのジョブを有効にし、静的ライブラリを出力します'
# 'Enable linker relaxation'
H4AD9A11300BE: 'リンカーリラクセーションを有効にします'
# 'Enable load and store clustering in the machine scheduler'
H9A7A3DC7E082: 'マシンスケジューラでのロード/ストアクラスタリングを有効にします'
# 'Enable load store vectorizer'
H6C9482FFD1BF: 'ロードストアベクタイザを有効にします'
# 'Enable logical abbreviations'
H0D1D59444F4E: '論理的略記を有効にします'
# 'Enable long calls for save-restore stubs.'
H12EA9151A98D: 'セーブ/リストアスタブ用のロングコールを有効にします'
# 'Enable loop data prefetch on AMDGPU'
H4B4F5CE87A14: 'AMDGPUでループデータプリフェッチを有効にする'
# 'Enable loop data prefetch on Hexagon'
H90194BED7184: 'Hexagonでループデータプリフェッチを有効にする'
# 'Enable loop header duplication at any optimization level'
H88A7D3561B15: '任意の最適化レベルでループヘッダーデュプリケーションを有効にする'
# 'Enable loop interleaving in Loop vectorization passes'
H437D1745A932: 'ループベクター化のパスでループのインターリーブを有効にする'
# 'Enable loop iv regalloc heuristic'
H2FAF4EF1BAC2: 'ループivレジスタ割り当てのヒューリスティックを有効にする'
# 'Enable loop tiling'
HF3F1904F445C: 'ループタイリングを有効にする'
# 'Enable loop vectorizer for HVX'
H0E3AC61CFA2F: 'HVX用のループベクター化を有効にする'
# 'Enable lower module lds pass'
H5FAE08416AEA: 'モジュールLDSの下位パスを有効にする'
# 'Enable lowering interleaved accesses to intrinsics'
H848C570E6895: 'インターリーブされたアクセスをintrinsic関数に変換する機能を有効にする'
# 'Enable lowering math functions to their corresponding MASS (scalar) entries'
H87849497C3F3: 'MASS（スカラ）エントリに数学関数を変換する機能を有効にする'
# 'Enable lowering of lds to global memory pass and asan instrument resulting IR.'
H778C2CAE9787: 'LDSをグローバルメモリに変換するパスと、結果のIRにASANを挿入する機能を有効にする'
# 'Enable lowering of the matrix intrinsics'
HFC73281BE936: 'マトリクスintrinsic関数の変換を有効にする'
# 'Enable machine DCE inside regalloc'
H59DAE158F032: 'レジスタ割り当て中にマシンDCEを有効にする'
# 'Enable machine block placement based on the ext-tsp model, optimizing I-cache utilization.'
HE6CB65616359: 'ext-tspモデルに基づくマシンブロック配置を有効にし、Iキャッシュの効率を最適化する'
# 'Enable masked loads/stores for HVX'
H9199C5705B41: 'HVX用のマスク付きロード/ストアを有効にする'
# 'Enable matrix data type and related builtin functions'
H43FB20CC8C7B: 'マトリクスデータ型と関連する組み込み関数を有効にする'
# 'Enable max stack depth tracing'
H509FC7F703A3: '最大スタック深度のトレースを有効にする'
# 'Enable mcount instrumentation'
H29618381AE6B: 'mcountの挿入を有効にする'
# 'Enable mcount instrumentation with prof'
H0C1503D1A868: 'profを使用したmcountインストルメンテーションを有効にする'
# 'Enable memcpyopt even when libcalls are disabled'
HF4D685F00134: 'libcallsが無効化されている場合でもmemcpyoptを有効にする'
# 'Enable memop clustering.'
H4CE08B6CBECC: 'メモリオペレーションクラスタリングを有効にする'
# 'Enable memory access instrumentation in ThreadSanitizer (default)'
H40FD5983A03D: 'ThreadSanitizerでのメモリアクセスインストルメンテーションを有効にする（既定値）'
# 'Enable merging Loop End and Dec instructions.'
H2EA5947F6FF8: 'ループエンドとデクリメント命令を統合する'
# 'Enable merging of globals'
H626AD7B90529: 'グローバル変数の統合を有効にする'
# 'Enable merging of redundant sexts when one is dominating the other.'
H1BD2BF0E8B4D: '一方が他方を支配する場合の冗長なsextを統合する'
# 'Enable mips16 constant islands.'
HC33E1B95CA7C: 'mips16の定数アイランドを有効にする'
# 'Enable mips16 hard float.'
H077B35DE76F5: 'mips16のハード・フロートを有効にする'
# 'Enable missed optimization remarks from passes whose name match the given regular expression'
H5892F9670CED: '指定の正規表現に一致する名前のパスからの最適化漏れ警告を有効にする'
# 'Enable mode register pass'
H1263C2240107: 'モードレジスタパスを有効にする'
# 'Enable module inliner'
H809D724384CF: 'モジュールインライナーを有効にする'
# 'Enable module-based external API notes support'
HAD6C2BA49C14: 'モジュールベースの外部APIメモのサポートを有効にする'
# 'Enable modules for C++'
HBB0113F4D937: 'C++用のモジュールを有効にする'
# 'Enable name/filename string compression'
H9667A6AB14A5: '名前/ファイル名文字列の圧縮を有効にする'
# 'Enable non legal immediates (for testing purposes only)'
H2DA699F30B71: '非合法な即値（テスト目的のみ）を有効にする'
# 'Enable odd single-precision floating point registers'
H6A9DE1E88E0D: '奇数単精度浮動小数点レジスタを有効にする'
# 'Enable on-demand initialization of thread-local variables'
H7700944705A7: 'スレッド局所変数のオンデマンド初期化を有効にする'
# 'Enable only control-flow mitigations for Load Value Injection (LVI)'
HF9542EDE9001: 'ロード値注入（LVI）に対する制御フロー対策のみを有効にする'
# 'Enable operand tree forwarding'
HB93EA483D9C3: 'オペランドツリーフォワーディングを有効にします'
# 'Enable optimization analysis remarks from passes whose name match the given regular expression'
H2B83EB5BDF40: '指定された正規表現と名前が一致するパスから最適化分析のリマーカーを有効にします'
# 'Enable optimization of existing hot/cold operator new library calls'
H7F82E9E27CD9: '既存のホット/コールドのoperator newライブラリ呼び出しの最適化を有効にします'
# 'Enable optimization remarks from passes whose name match the given regular expression'
H2198D7418FE6: '指定された正規表現と名前が一致するパスから最適化リマーカーを有効にします'
# 'Enable optimizations'
H5D736AD67AD6: '最適化を有効にします'
# 'Enable optimizations based on strict aliasing rules'
HCF0A62237B7C: '厳格なエイリアシング規則に基づく最適化を有効にします'
# "Enable optimizations based on the strict definition of an enum's value range"
H186F36BCDB9E: 'enumの値範囲の厳密な定義に基づく最適化を有効にします'
# 'Enable optimizations based on the strict definition of flexible arrays'
HA59BB0439AAE: '柔軟な配列の厳密な定義に基づく最適化を有効にします'
# 'Enable optimizations based on the strict rules for overwriting polymorphic C++ objects'
H13CA0465139C: 'ポリモーフィックC++オブジェクトの上書きに関する厳格なルールに基づく最適化を有効にします'
# 'Enable optimizations on complex GEPs'
H50EEF415122A: '複雑なGEPへの最適化を有効にします'
# 'Enable optimizations that may decrease FP precision'
H67D78B43979D: 'FP精度を低下させる可能性のある最適化を有効にします'
# 'Enable optimized register allocation compilation path.'
H0059F32A3970: '最適化されたレジスタ割り当てコンパイルパスを有効にします'
# 'Enable or disable Control Flow Guard checks and guard tables emission'
H20C0331A083C: 'Control Flow Guardのチェックとガードテーブルの発行を有効または無効にします'
# 'Enable origins tracking in MemorySanitizer'
H2743C4FAB786: 'MemorySanitizerでの起源追跡を有効にします'
# 'Enable overlapping among matches in a group of consecutive\nCHECK-DAG directives.  This option is deprecated and is only\nprovided for convenience as old tests are migrated to the new\nnon-overlapping CHECK-DAG implementation.\n'
HA5495662EA0A: '連続したCHECK-DAGディレクティブのグループ内のマッチ間でのオーバーラップを有効にします。このオプションは廃止予定で、古いテストを新しい非オーバーラップCHECK-DAG実装に移行する際の利便性のためのみ提供されています。\n'
# 'Enable parser support for the __unknown_anytype type; for testing purposes only'
H4226A11EC54A: 'パーサーが__unknown_anytype型をサポートするようにします（テスト目的のみ）'
# 'Enable partial store merging in DSE'
HEF8E935B1092: 'DSEでの部分的なストアマージングを有効にします'
# 'Enable partial-overwrite tracking in DSE'
H4283D5D63662: 'DSE (Dead Store Elimination) 内の一部上書き追跡を有効にする'
# 'Enable pass to eliminate conditions based on linear constraints'
H59888AB6AA6D: '線形制約に基づく条件の削除用の pass を有効にする'
# 'Enable perf profiling support'
H6FDDBD2502B8: 'perf プロファイリングのサポートを有効にする'
# 'Enable phi-translation of add instructions'
H2871DDB08B81: '加算命令の phi 変換を有効にする'
# 'Enable placement of extracted cold functions into a separate section after hot-cold splitting.'
HC9DB0E175EB1: 'hot-cold 分割後に抽出された cold 関数を別セクションに配置する機能を有効にする'
# 'Enable pointer authentication intrinsics'
H367806655729: 'ポインタ認証 intrinsic を有効にする'
# 'Enable poisoning array cookies when using custom operator new[] in AddressSanitizer'
HC79D664C6E42: 'AddressSanitizer でカスタム演算子 new[] を使用する際、配列のクッキーを破壊する機能を有効にする'
# 'Enable pre-link mode optimizations'
H20BCBBC300E0: 'pre-link モードの最適化を有効にする'
# 'Enable precise memory mode (AMDGPU only)'
HE9548687DBB5: '(AMDGPU 専用) 精密メモリ モードを有効にする'
# 'Enable predefined and command line preprocessor macros'
H69A47E977056: '事前に定義されたプリプロセッサ マクロとコマンドライン マクロを有効にする'
# 'Enable predefined target OS macros'
H9D44D77675A5: '事前に定義されたターゲット OS マクロを有効にする'
# 'Enable profile hotness information in diagnostic line'
H6ECB1E31250D: '診断行内のプロファイルのホットネス情報を有効にする'
# 'Enable profile instrumentation sampling (default = off)'
H16EB6D513222: 'プロファイル インストルメンテーション サンプリングを有効にする (デフォルトはオフ)'
# 'Enable promoting aligned anyext load to wider load'
H1CA89F41F132: 'アライン済み anyext ロードをより広いロードに昇格する機能を有効にする'
# 'Enable promotion of flat kernel pointer arguments to global'
H4206A6231E2E: 'フラット カーネル ポインター引数をグローバルに昇格する機能を有効にする'
# 'Enable quadword atomics ABI on AIX (AIX PPC64 only). Uses lqarx/stqcx. instructions.'
H01E0F762B340: 'AIX (AIX PPC64 専用) 上で quadword アトミック ABI を有効にする。lqarx/stqcx 命令を使用します。'
# 'Enable raw string literals'
H8C8B44AEB3E9: '生文字列リテラルを有効にする'
# 'Enable reassociation of accumulation chains'
H35D68C90E430: '累積チェーンの再結合を有効にする'
# 'Enable reciprocal sqrt optimization'
H6556F5DE61D3: '逆平方根最適化を有効にする'
# 'Enable recognition of non-constant strided pointer induction variables.'
H95B2F8C1B69F: '定数ではないストライド付きポインタ誘導変数の検出を有効にする'
# 'Enable recovery for specified sanitizers'
H2A20F3F3EA12: '指定されたsanitizerの回復機能を有効にする'
# 'Enable recovery mode (continue-after-error).'
HBD337CDF104A: 'エラー後処理継続（エラー発生後も処理を続ける）モードを有効にする'
# 'Enable regalloc advisor mode'
H7AE29F2A8C3F: 'レジスタ割り当てアドバイザーモードを有効にする'
# 'Enable register pressure scheduling.'
HC0DF1D86F80E: 'レジスタプレッシャーに基づくスケジューリングを有効にする'
# 'Enable register reassign optimizations on gfx10+'
H2EA748D732DD: 'gfx10+向けレジスタ再割り当て最適化を有効にする'
# 'Enable register tiling'
H02ACF2158ECD: 'レジスタタイルを有効にする'
# 'Enable relocating counters at runtime.'
H1C98545F997D: '実行時にrelocatingカウンタを再配置する'
# 'Enable removal of functions when theyuse features not supported by the target GPU'
HA60D39957FD6: 'ターゲットGPUがサポートしない機能を使用する関数を削除する'
# 'Enable required s_wait_alu on SGPR hazards'
H5931DB0CC40E: 'SGPRハザードに対する必須のs_wait_aluを有効にする'
# "Enable retain SubstTemplateTypeParmType nodes in the AST's representation of alias template specializations"
HB02FA0B87AE4: 'エイリアステンプレート特化のAST表現におけるSubstTemplateTypeParmTypeノードを保持する'
# 'Enable rewrite partial reg uses pass'
HC2E09FB1800A: '部分レジスタ使用の書き換えパスを有効にする'
# 'Enable runtime checks for stack overflow.'
H20B19FA46C02: 'スタックオーバーフローのランタイムチェックを有効にする'
# 'Enable runtime interleaving until load/store ports are saturated'
H83E188A2297B: 'ロード/ストアポートが飽和するまで実行時インターリーブを有効にする'
# 'Enable s_delay_alu insertion'
H8A9476D62164: 's_delay_alu挿入を有効にする'
# 'Enable safe identical code folding'
H31D3779CB68C: '安全な同一コードのフォールディングを有効にする'
# 'Enable sample-based profile guided optimizations'
H96541402ED68: 'サンプルベースのプロファイル駆動最適化を有効にする'
# 'Enable sanitizer coverage for indirect calls'
HB591DDDA07BD: '間接呼び出しのためのサンタライザ カバレッジを有効にする'
# 'Enable sanitizer for supported offloading devices'
HFDA0060284A3: 'サポートされているオフロードデバイス向けのサンタライザを有効にする'
# 'Enable sanitizer statistics gathering.'
HC1E74A5D06CE: 'サンタライザの統計収集を有効にする'
# 'Enable sc.q instruction.'
H657B7BD0EB9D: 'sc.q 指令を有効にする'
# 'Enable scalar IR passes'
HD2045AE5F150: 'スカラ IR パスを有効にする'
# 'Enable scheduling addi instruction as earlyas possible post ra'
H3324B351B51A: 'RA 後にaddi指令を可能な限り早期にスケジューリングする機能を有効にする'
# 'Enable scheduling after register allocation'
H142271112BA0: 'レジスタ割り当て後のスケジューリングを有効にする'
# 'Enable scheduling for macro fusion.'
H3396D13A8F30: 'マクロフージョンのためのスケジューリングを有効にする'
# 'Enable select to branch optimizations'
H7DB0FCE3CF68: 'select to branch 最適化を有効にする'
# 'Enable setting constant bits to reduce size of mask immediates'
HD06E3ECAB947: 'マスク即値のサイズを減らすために定数ビットを設定する機能を有効にする'
# 'Enable setting lr as a predicate in tail predication regions.'
H5D3D99EE631D: 'テール予測リージョン内の予測子としてlrを設定する機能を有効にする'
# 'Enable setting the FP exceptions build attribute not to use exceptions'
H29262DC5BE27: 'FP例外のビルド属性を例外を使用しないように設定する機能を有効にする'
# 'Enable shared library instrumentation with XRay'
HBB7CC7BAF352: 'XRayを使用した共有ライブラリのインストゥルメンテーションを有効にする'
# 'Enable signing and authentication of all indirect calls'
H85AEAA3DF7E2: 'すべての間接呼び出しの署名と認証を有効にする'
# 'Enable signing and authentication of indirect goto targets'
H7778174B9D56: '間接gotoターゲットの署名と認証を有効にする'
# 'Enable signing and authentication of return addresses'
HB69C655EC5B4: '戻りアドレスの署名と認証を有効にする'
# 'Enable signing of function pointers in init/fini arrays'
HF447A017CA1C: 'init/fini配列内の関数ポインタの署名を有効にする'
# 'Enable simple copy propagation during register reloading'
HB0CCABAD4B9C: 'レジスタ再ロード中に単純なコピー伝播を有効にする'
# 'Enable single byte coverage'
HCE6038C8EF64: 'シングルバイトカバレッジを有効にする'
# 'Enable sinking and folding of instruction copies'
HAFBBC2D2907E: '命令コピーの沈降と折り畳みを有効にする'
# 'Enable sinking and/cmp into branches.'
HC2C79127C7B6: '沈降とcmpの分岐への組み込みを有効にする'
# 'Enable some non conforming code to compile'
H97500F6CC226: '非適合コードのコンパイルを有効にする'
# 'Enable some traditional CPP emulation'
H86897CE40B49: '伝統的なCPPエミュレーションを有効にする'
# 'Enable sparse parallelization for any storage and loop.'
H86D1CE3B297F: '任意のストレージとループに対するスパース並列化を有効にする'
# 'Enable sparse parallelization regardless of storage for the outer loop.'
HD78181DC6B92: '外側のループに対するストレージに関係なくスパース並列化を有効にする'
# 'Enable special debugger support behavior'
H526152B74AA2: '特別なデバッガサポートの動作を有効にする'
# 'Enable special debugger support for Objective-C subscripting and literals'
H40F60E7DDF05: 'Objective-Cのサブスクリプトとリテラルのための特別なデバッガサポートを有効にする'
# 'Enable specialization of functions that take a literal constant as an argument'
H8CB997684347: 'リテラル定数を引数に取る関数の特殊化を有効にする'
# 'Enable specifying registers without the % prefix'
H4FA626EAB19A: '%プレフィックスなしでレジスタを指定する機能を有効にする'
# 'Enable speculative execution side effect suppression (SESES). Includes LVI control flow integrity mitigations'
H8F91025B1797: '推測実行の副作用抑制(SESES)を有効にする。LVI制御フロー整合性緩和を含む'
# 'Enable spilling SGPRs to VGPRs'
HBC64889F75D9: 'SGPRをVGPRにspillする機能を有効にする'
# 'Enable spilling VGPRs to AGPRs'
HCAAEDB0207AA: 'VGPRをAGPRにspillする機能を有効にする'
# 'Enable spills from gpr to vsr rather than stack'
H93A49F7D7A81: 'スタックではなくvsrへのgprのスpillを有効にする'
# 'Enable spills in prologue to vector registers.'
H14C00957A630: 'プロローグでのベクタレジスタへのspillを有効にする'
# 'Enable splitting large offset of GEP.'
HC17E8C448D7B: 'GEPの大きなオフセットを分割する機能を有効にする'
# 'Enable splitting of a ThinLTO LTOUnit'
HD2FEBF5117B2: 'ThinLTO LTOUnitの分割を有効にする'
# 'Enable stack clash protection'
HD6B8B4D2B61B: 'スタッククラッシュ保護を有効にする'
# 'Enable stack frame shrink wrapping'
H96A0AAD52568: 'スタックフレームの縮小ラップを有効にする'
# 'Enable stack probes'
H2C8F59EB6B80: 'スタックプローブを有効にする'
# 'Enable stack protectors'
H92CD4261F56E: 'スタックプロテクタを有効にする'
# 'Enable stack protectors for all functions'
H4AAD4C1AF839: 'すべての関数に対してスタックプロテクタを有効にする'
# 'Enable stack protectors for some functions vulnerable to stack smashing. Compared to -fstack-protector, this uses a stronger heuristic that includes functions containing arrays of any size (and any type), as well as any calls to alloca or the taking of an address from a local variable'
H01F993B30A66: 'スタックスミッシングに脆弱な一部の関数でスタックプロテクタを有効にします。-fstack-protectorと比べ、このオプションはより厳密なヒューリスティックを使用します。これは、任意のサイズ（および任意の型）の配列を含む関数やallocaの固定サイズの呼び出し、ローカル変数のアドレス取りを行う関数を含めます'
# "Enable stack protectors for some functions vulnerable to stack smashing. This uses a loose heuristic which considers functions vulnerable if they contain a char (or 8bit integer) array or constant sized calls to alloca , which are of greater size than ssp-buffer-size (default: 8 bytes). All variable sized calls to alloca are considered vulnerable. A function with a stack protector has a guard value added to the stack frame that is checked on function exit. The guard value must be positioned in the stack frame such that a buffer overflow from a vulnerable variable will overwrite the guard value before overwriting the function's return address. The reference stack guard value is stored in a global variable."
H216044E73536: 'スタックスミッシングに脆弱な一部の関数でスタックプロテクタを有効にします。このオプションは緩いヒューリスティックを使用し、char（または8ビット整数）の配列やallocaの固定サイズの呼び出しを含む関数を脆弱と判定します（ssp-buffer-size以上：デフォルト8バイト）。allocaの変数サイズの呼び出しはすべて脆弱と見なされます。スタックプロテクタが適用された関数には、関数終了時にチェックされるスタックフレーム内のガード値が追加されます。このガード値は、脆弱な変数のバッファオーバーフローがリターンアドレスより先にガード値を上書きするようにスタックフレーム内に配置されます。参照ガード値はグローバル変数に格納されます'
# 'Enable static hinting of branches on ppc'
H1318D7CF750E: 'ppcでのブランチの静的ヒントを有効にする'
# 'Enable statistics output from program (available with Asserts)'
H7E1E434B51DE: 'アサート有効時、プログラムからの統計出力を有効にする'
# 'Enable stress test of coldcc by adding calling conv to all internal functions.'
H864C98F93D8C: 'すべての内部関数にコールングコンベンションを追加し、coldccのストレステストを有効にする'
# 'Enable stricter verification with -verify-scev is passed'
HA0BAD2CA5C13: '-verify-scevが指定された場合、より厳密な検証を有効にする'
# 'Enable string pooling (default)'
H01420F7F4ED8: '文字列プーリングを有効にする（デフォルト）'
# 'Enable subreg liveness tracking'
H59D79C24D746: 'サブレジスタのライブネス追跡を有効にする'
# 'Enable subregister liveness tracking for SystemZ (experimental)'
H278D5FB962A3: 'SystemZ 用のサブレジスタの有効性追跡を有効にする (実験的)'
# 'Enable subregister liveness tracking.'
HA8D796B2328B: 'サブレジスタの有効性追跡を有効にする'
# 'Enable support for exception handling'
HFB1350CAA576: '例外処理のサポートを有効にする'
# 'Enable support for ignoring exception handling constructs'
H1F7624DB7FC3: '例外処理構造を無視するためのサポートを有効にする'
# 'Enable support for int128_t type'
H8EC6E7CC318F: '128ビット整数型 int128_t のサポートを有効にする'
# 'Enable support for the C++ Coroutines'
H7925EA35B0A4: 'C++ コルーチンのサポートを有効にする'
# 'Enable symbolic stride memory access versioning'
H614C3C8C780E: 'シンボル ストライド メモリ アクセス バージョニングを有効にする'
# 'Enable tail-predication, but not for reduction loops'
H7759A373B899: 'リダクション ループを除くテール予測を有効にする'
# 'Enable tail-predication, but not for reduction loops, and force this which might be unsafe'
HEC8679DD9C06: 'リダクション ループを除くテール予測を強制的に有効にする（危険な可能性あり）'
# 'Enable tail-predication, including reduction loops'
H9E0011DEC062: 'リダクション ループを含むテール予測を有効にする'
# 'Enable tail-predication, including reduction loops, and force this which might be unsafe'
H65CA4B853D34: 'リダクション ループを含むテール予測を強制的に有効にする（危険な可能性あり）'
# 'Enable that single precision floating-point divide and sqrt used in '
H40916D94286B: '単精度浮動小数点除算と sqrt を有効にする'
# 'Enable the "fast" instruction selector'
HB827608C6F32: '「fast」命令選択子を有効にする'
# 'Enable the "global" instruction selector'
HC28B60B42675: '「global」命令選択子を有効にする'
# "Enable the 'blocks' language feature"
H8A0F69B5F85C: '「blocks」言語機能を有効にする'
# "Enable the 'modules' language feature"
H047278B48AFB: '「modules」言語機能を有効にする'
# 'Enable the AArch64 branch target pass'
H288D5F3BECED: 'AArch64 ブランチ ターゲット パスを有効にする'
# 'Enable the AIX Extended Altivec ABI.'
H2F5C4C6F1979: 'AIX拡張Altivec ABIを有効にする'
# 'Enable the CCMP formation pass'
HD0F0CA1649A7: 'CCMP形成パスを有効にする'
# 'Enable the GVN hoisting pass (default = off)'
HEAFC22E87450: 'GVN hoisting パスを有効にする（デフォルトはオフ）'
# 'Enable the GVN sinking pass (default = off)'
H58E31BED29F9: 'GVN sinking パスを有効にする（デフォルトはオフ）'
# 'Enable the IR outliner on linkonceodr functions'
H040BEC05F858: 'linkonceodr関数でのIRアウトライン化を有効にする'
# 'Enable the LoopFlatten Pass'
HAC22881851DD: 'LoopFlatten パスを有効にする'
# 'Enable the LoopInterchange Pass'
HDD03023B6FBB: 'LoopInterchange パスを有効にする'
# 'Enable the OpenMP region merging optimization.'
HE96DB2508A4B: 'OpenMP領域のマージ最適化を有効にする'
# 'Enable the Polly DOT printer in -O3'
H4E0A173B05AF: '-O3オプティマイゼーションでPolly DOTプリンターを有効にする'
# 'Enable the Polly DOT printer in -O3 (no BB content)'
HEAA8FA2DC249: '-O3オプティマイゼーションでPolly DOTプリンターを有効にする（BBの内容なし）'
# 'Enable the RISC-V VL Optimizer pass'
HC773BD141E4D: 'RISC-V VLオプティマイザーパスを有効にする'
# 'Enable the VR4300 mulmul bug fix.'
HF647968864FA: 'VR4300 mulmul バグ修正を有効にする'
# 'Enable the X86 cmov-to-branch optimization.'
HA57709995537: 'X86 cmov-to-branch 最適化を有効にする'
# 'Enable the abort'
HF630F0E0D97E: 'abortを有効にする'
# 'Enable the attributor inter-procedural deduction pass'
HC3A4293C13B2: 'attributor関数間推論パスを有効にする'
# 'Enable the condition optimizer pass'
H9D8DD66B429A: '条件最適化パスを有効にする'
# 'Enable the conditional branch tuning pass'
H08843D4DB1BA: '条件分岐チューニングパスを有効にする'
# 'Enable the copy propagation with AArch64 copy instr'
H7A7BF4C2FF44: 'AArch64のコピー命令を使用したコピー伝搬を有効にする'
# 'Enable the copy propagation with RISC-V copy instr'
H8FDD7DCFE43D: 'RISC-Vのコピー命令を使用したコピー伝搬を有効にする'
# 'Enable the cost-benefit analysis for the inliner'
H4A32DF87AC31: 'インライン展開のコスト・ベネフィット分析を有効にする'
# 'Enable the early if converter pass'
HC1AB5BB544BB: '早期if変換パスを有効にする'
# 'Enable the experimental Loop Versioning LICM pass'
HAC7286F63BD3: '実験的ループバージョニングLICMパスを有効にする'
# 'Enable the experimental new constant interpreter'
HA94181FC4D28: '実験的新しい定数インタプリタを有効にする'
# 'Enable the extended Altivec ABI on AIX. Use volatile and nonvolatile vector registers'
H6369C2DE5BEE: 'AIX上で拡張Altivec ABIを有効にする。volatileおよびnonvolatileベクタレジスタを使用する'
# 'Enable the generation of 4-operand madd.s, madd.d and related instructions.'
H2954D704DCA6: '4オペランドmadd.s、madd.dおよび関連命令の生成を有効にする'
# 'Enable the generation of WLS loops'
HB0BD6C355304: 'WLSループの生成を有効にする'
# 'Enable the generation of masked gathers and scatters'
H69417D79F86A: 'マスク付き収集と分散の生成を有効にする'
# 'Enable the generation of masked loads and stores'
H8811F179AC8C: 'マスク付きロードとストアの生成を有効にする'
# 'Enable the global merge pass'
HF3A16D1A310B: 'グローバルマージパスを有効にする'
# 'Enable the initializes attr improvement in DSE'
H2C13638D3B7A: 'DSEでの初期化属性の改善を有効にする'
# 'Enable the integrated assembler'
H6897999B76AE: '統合アセンブラを有効にする'
# 'Enable the legacy pass manager. This is strictly for bugpoint due to it not working with the new PM, please do not use otherwise.'
H4ACF17F9F060: 'レガシーパスマネージャーを有効にする。これはbugpoint専用です（新しいPMでは動作しないため）。他の用途では使用しないでください。'
# 'Enable the live debug variables pass'
H97C40BB61A18: 'ライブデバッグ変数パスを有効にする'
# 'Enable the load/store pair optimization pass'
HAF961AA83173: 'ロード/ストアペア最適化パスを有効にする'
# 'Enable the loop data prefetch pass'
H1F5F62A8C420: 'ループ データ プリフェッチ パスを有効にする'
# 'Enable the loop interchange pass'
HACD3CEF0E137: 'ループ入れ替えパスを有効にする'
# 'Enable the loop vectorization passes'
HD80457B01B02: 'ループベクター化パスを有効にする'
# 'Enable the machine combiner pass'
H6170C8360FA8: 'マシン コンバイン パスを有効にする'
# 'Enable the machine instruction scheduling pass.'
H5ED9F17A2AD8: 'マシン命令スケジューリング パスを有効にする。'
# 'Enable the machine outliner'
H6AA5708D3CBD: 'マシン アウトライン機能を有効にする'
# 'Enable the machine outliner on linkonceodr functions'
HC9ED1CD426C7: 'linkonceodr 関数でマシン アウトライン機能を有効にする'
# 'Enable the new pass manager'
H93E040EA4A3C: '新しいパス マネージャーを有効にする'
# 'Enable the new, experimental LoopDistribution Pass'
H349A804BD347: '新しい実験的なループ ディストリビューション パスを有効にする'
# 'Enable the old style PARAMETER statement'
H17563270F079: '古いスタイルのPARAMETER文を有効にする'
# 'Enable the pass that emits the linker optimization hints (LOH)'
HA4C27576F1AF: 'リンカ最適化ヒント (LOH) を出力するパスを有効にする'
# 'Enable the pass that removes dead definitions and replaces stores to them with stores to the zero register'
HB91327722E91: '不要な定義を削除し、それらへのストアをゼロレジスタへのストアに置き換えるパスを有効にする'
# 'Enable the pass that removes dead definitions and replaces stores to them with stores to x0'
H3F4AC3AD0D0C: '不要な定義を削除し、それらへのストアをx0へのストアに置き換えるパスを有効にする'
# 'Enable the pass that removes dead definitons and replaces stores to them with stores to r0'
H8430D489B8AD: '不要な定義を削除し、それらへのストアをr0へのストアに置き換えるパスを有効にする'
# 'Enable the polly optimizer (with -O1, -O2 or -O3)'
H2F44BA5CB43F: 'Polly オプティマイザ ( -O1、-O2、または -O3 と組み合わせて) を有効にする'
# 'Enable the post-ra machine instruction scheduling pass.'
H81A625E2EDC2: 'RA 後のマシン命令スケジューリング パスを有効にする。'
# 'Enable the profile guided size optimizations. '
HD0F54569CD57: 'プロファイル ドリブン サイズ最適化を有効にする'
# 'Enable the promote constant pass'
H39117666C528: '定数プロモーション パスを有効にする'
# 'Enable the redundant copy elimination pass'
HCC7E809780AA: '不要なコピー削除パスを有効にする'
# 'Enable the scheduler to generate .cur'
H9F36FFDB648E: 'scheduler が .cur を生成するように有効にする'
# 'Enable the specified remark'
HF163370BA2BE: '指定されたリマークを有効にする'
# 'Enable the specified warning'
HB465ABA562BF: '指定された警告を有効にする'
# 'Enable the superword-level parallelism vectorization passes'
H03A53AF6091A: 'Superwordレベルの並列化ベクトル化のパスを有効にする'
# 'Enable the tile register allocation pass'
H8BFDE65405FB: 'タイルレジスタ割り当てのパスを有効にする'
# 'Enable the use of AA during codegen.'
H330FE8DFBA44: 'codegen中にAAを使用するように有効にする'
# 'Enable the use of TLS Descriptors'
HC87014CCBA07: 'TLS ディスクリプタを使用するように有効にする'
# 'Enable the use of the block frequency analysis to access PGO heuristics minimizing code growth in cold regions and being more aggressive in hot regions.'
H6383E4E8CC05: 'ブロック周波数分析を使用してPGOヒューリスティックを活用し、冷たい領域でのコードの成長を最小化し、ホット領域ではより積極的な動作を可能にするように有効にする'
# 'Enable the use of the block frequency analysis to reduce the chance to execute const materialization more frequently than without hoisting.'
H05FE62E1BC2A: 'ブロック周波数分析を使用して、定数マテリアル化の実行頻度を、ホイストしない場合よりも減らすように有効にする'
# 'Enable the vectorisation of loops with in-order (strict) FP reductions'
HC23A0D871AA8: 'in-order (strict) FP 減少量のループのベクトル化を有効にする'
# 'Enable the wasm-opt optimizer (default)'
H66A2CFFFDC43: 'wasm-opt オプティマイザを有効にする（デフォルト）'
# 'Enable the widening of global strings to alignment boundaries'
HEA83816331AB: 'グローバル文字列をアライメント境界まで拡張するように有効にする'
# 'Enable the workaround for OCL name mangling mismatch.'
H76DA67C39D2D: 'OCLの名前マングリングの不一致に対する回避策を有効にする'
# 'Enable thread-safe initialization of static variables'
H50C0425B9069: 'スレッドセーフな静的変数の初期化を有効にする'
# 'Enable threadgroup split execution mode (AMDGPU only)'
H94C846ABEAAC: 'スレッドグループ分割実行モードを有効にする（AMDGPUのみ）'
# 'Enable timing class latency'
H68F7539AA86E: 'タイミングクラスの遅延を計測するように有効にする'
# 'Enable timing of insert generation'
HF299FBD7AEA4: 'インサート生成のタイミングを計測するように有効にする'
# 'Enable tls optimization peephole'
H5607F3078246: 'TLS最適化のピーホールを有効にする'
# 'Enable tracing of loads'
HFCB6983FD21E: 'ロードのトレースを有効にする'
# 'Enable tracing of stores'
HE51956EA02F1: 'ストアのトレースを有効にする'
# 'Enable trapping for all sanitizers'
H797FF784214D: 'すべてのsanitizersに対してトラップを有効にする'
# 'Enable trapping for specified sanitizers'
H8D7750937E63: '指定されたsanitizersのトラッピングを有効にする'
# 'Enable traps on authentication failures'
HB1958D1E9CCE: '認証失敗時のトラップを有効にする'
# 'Enable treating throwing global C++ operator new as always returning valid memory (annotates with __attribute__((returns_nonnull)) and throw()). This is detectable in source.'
H98A09520B600: 'スローするグローバルC++オペレーターnewを常に有効なメモリを返すものとして扱う（__attribute__((returns_nonnull))とthrow()でアノテーションします。これはソースで検出可能です。'
# 'Enable trigraphs'
HD29B31F12F2E: 'Trigraphを有効にする'
# 'Enable two-phase name lookup in templates'
H808ED9B492E8: 'テンプレートでの2段階名前検索を有効にする'
# 'Enable two-round ThinLTO code generation. The first round emits codegen data, while the second round uses the emitted codegen data for further optimizations.'
H4183BCD4B48B: 'ThinLTOコード生成の2段階実行を有効にします。最初の段階ではコード生成データを出力し、第二段階ではそのデータを使用してさらに最適化します。'
# 'Enable type and address discrimination of vtable pointer of std::type_info'
H10834C3F61A6: 'std::type_infoのvtableポインタの型とアドレスの区別を有効にする'
# 'Enable type discrimination of vtable pointers'
H5E406CE94798: 'vtableポインタの型の区別を有効にする'
# 'Enable type discrimination on C function pointers'
HB262A3E07E79: 'C関数ポインタの型の区別を有効にする'
# 'Enable unsafe double to float shrinking for math lib calls'
HADD895A7C263: 'マスライブラリ呼び出しでのunsafe double to floatの縮小を有効にする'
# 'Enable unswitch cost multiplier that prohibits exponential explosion in nontrivial unswitch.'
H05E336233C05: '非自明なunswitchでの指数的爆発を防ぐunswitchコスト乗数を有効にする'
# 'Enable use of AA during MI DAG construction'
H13EA04236348: 'MI DAG構築中のAAの使用を有効にする'
# 'Enable use of AdvSIMD scalar integer instructions'
H2C1BB8E0F766: 'AdvSIMDスカラ整数命令の使用を有効にする'
# 'Enable use of GPR32 in inline assembly for APX'
HD4DD583F3412: 'APXのインラインアセンブリでのGPR32の使用を有効にする'
# 'Enable use of TBAA during MI DAG construction'
H8EF1EE9B884D: 'MI DAG構築中のTBAAの使用を有効にする'
# 'Enable use of a base pointer for complex stack frames'
H6F6CB09044A3: '複雑なスタックフレーム用のベースポインタの使用を有効にする'
# 'Enable use of builtin functions'
H6E647497900D: 'ビルトイン関数の使用を有効にする'
# 'Enable use of experimental RISC-V extensions.'
H16ED2241C9C1: '実験的なRISC-V拡張機能の使用を有効にする'
# 'Enable use of hot hints (only supported for unambigously hot allocations)'
H80EB4017A5F5: 'hot hintsの使用を有効にする（未曖昧なhotアロケーションのみサポートされています）'
# 'Enable use of the DWARFv5 DW_OP_convert operator'
H68201FB3FEC3: 'DWARFv5のDW_OP_convertオペレーターの使用を有効にする'
# 'Enable use of the MCJIT object caching'
H8DEBC9578EBC: 'MCJIT オブジェクトキャッシュの使用を有効にする'
# 'Enable use-after-destroy detection in MemorySanitizer'
H9D193DAF1144: 'MemorySanitizer での使用後破棄検出を有効にする'
# 'Enable use-after-scope detection in AddressSanitizer'
H57E5EACCD6DF: 'AddressSanitizer でのスコープ外使用検出を有効にする'
# 'Enable using coldcc calling conv for cold internal functions'
H2D564DBF6E20: 'cold 内部関数に coldcc コールコンベンションを使用する機能を有効にする'
# 'Enable using library calls for save and restore'
H5D8D6E37F3DB: 'セーブと復元用のライブラリコールを使用する機能を有効にする'
# 'Enable value profiling'
HC22D05737DD8: '値プロファイリングを有効にする'
# 'Enable vec acc forwarding'
H5E7B35E50AEB: 'ベクターアキュムレータ転送を有効にする'
# 'Enable vec alu forwarding'
HB58D78835B76: 'ベクターALU転送を有効にする'
# 'Enable vectorization for wider vector utilization'
HA93E4FD1B769: 'より広いベクター利用のためのベクタライゼーションを有効にする'
# 'Enable vectorization of early exit loops with uncountable exits.'
H5BAE1D5D430F: '数えられない終了を有する早期終了ループのベクタライゼーションを有効にする'
# 'Enable vectorization of epilogue loops.'
H633875436202: 'エピローグループのベクタライゼーションを有効にする'
# 'Enable vectorization on interleaved memory accesses in a loop'
HAC5648620E31: 'ループ内のインターリーブメモリアクセスでのベクタライゼーションを有効にする'
# 'Enable vectorization on masked interleaved memory accesses in a loop'
H043FDB797D48: 'ループ内のマスクされたインターリーブメモリアクセスでのベクタライゼーションを有効にする'
# 'Enable verbose debugging for Loop Fusion'
H0D6210EADA30: 'Loop Fusion の詳細なデバッグを有効にする'
# 'Enable verbose output'
H11B3BB594E91: '詳細出力を有効にする'
# 'Enable verbose output (results, IR, etc.) to stderr'
HCCA7B2AA9E71: '詳細出力（結果、IR など）を stderr に表示する機能を有効にする'
# 'Enable verification of LLVM IR'
H21971438C1F9: 'LLVM IR の検証を有効にする'
# 'Enable verification of MemorySSA.'
H0C498CC2C452: 'MemorySSA の検証を有効にする'
# 'Enable verification of assumption cache'
HA1CDE46C471E: '仮定キャッシュの検証を有効にする'
# 'Enable vextract optimization'
HEA51F4DB759E: 'vextract 最適化を有効にする'
# 'Enable virtual function elimination'
HB0B4C26F8F08: '仮想関数の削除を有効にする'
# 'Enable vtune profiling support'
H19C598762536: 'Vtuneプロファイリングサポートを有効にする'
# 'Enable warnings for deprecated constructs and define __DEPRECATED'
H141A6A5BBE2F: '非推奨の構文に関する警告と__DEPRECATEDの定義を有効にする'
# 'Enable warnings for undefined macros with a prefix in the comma separated list <arg>'
HCD611C0CC9C3: 'カンマ区切りリスト<arg>で指定されたプレフィックスを持つ未定義マクロに関する警告を有効にする'
# 'Enable whole program visibility'
HED7D14DA2E46: '全プログラム可視化を有効にする'
# 'Enable whole program visibility during LTO'
H467630D788B8: 'LTO実行時に全プログラム可視化を有効にする'
# 'Enable workarounds for GR712RC errata'
H12F1DF5F1AA6: 'GR712RC Errataの回避策を有効にする'
# 'Enable workarounds for UT700 errata'
HEED588686E0F: 'UT700 Errataの回避策を有効にする'
# 'Enable/disable fusing matrix instructions.'
HCF6BF736057E: '行列命令の融合を有効/無効にします。'
# 'Enable/disable matrix shape verification.'
HBF4777571623: '行列形状検証を有効/無効にします。'
# 'Enables DWARF32 format for ELF binaries, if debug information emission is enabled.'
HC14824860E5E: 'デバッグ情報の出力が有効な場合、ELFバイナリ用にDWARF32形式を有効にします。'
# 'Enables DWARF64 format for ELF binaries, if debug information emission is enabled.'
H636F6BB5F153: 'デバッグ情報の出力が有効な場合、ELFバイナリ用にDWARF64形式を有効にします。'
# 'Enables UNSIGNED type'
H12352306E73A: 'UNSIGNED型を有効にします'
# 'Enables autovectorization of some loops containing histograms'
HC9BA8F6B64F6: 'ヒストグラムを含む一部のループのオートベクタライゼーションを有効にします'
# 'Enables dead virtual function elimination optimization. Requires -flto=full'
HF54593F712BA: '死仮想関数削除最適化を有効にします。-flto=fullが必要です'
# 'Enables more verbose remarks.'
H247202E5D41C: 'より詳細なリマーカブルを出力します。'
# "Enables scope for regex variables. Variables with names that\ndo not start with '$' will be reset at the beginning of\neach CHECK-LABEL block."
H1C0B00C976AB: '正規表現変数のスコープを有効にします。\n変数名が「$」で始まらない場合、各CHECK-LABELブロックの開始時にリセットされます。'
# 'Enables spilling/reloading SVE predicates as data vectors (ZPRs)'
H7E00B4776D94: 'SVE予測レジスタ(ZPRs)としてSVE予測をスパイリング/再ロードする'
# 'Enables splitting of the LTO unit'
H14642BDE0542: 'LTOユニットの分割を有効にします'
# 'Enables strict availability diagnostic mode for HLSL built-in functions.'
H68650E3ED1FE: 'HLSL組み込み関数の厳密な可用性診断モードを有効にします。'
# 'Enables the global instruction selector'
H6762200C8D35: 'グローバル命令選択器を有効にします'
# 'Enables the use of non-default rounding modes and non-default exception handling on targets that are not currently ready.'
H405A02EF316C: 'ターゲットが準備されていない場合、非デフォルトの丸めモードと非デフォルトの例外処理の使用を有効にします'
# 'Enables tracing of vector stores'
H5763CA739FFE: 'ベクターストアのトレースを有効にします'
# 'Enables whole-program vtable optimization. Requires -flto'
H251D67CF92D1: '全プログラム vtable 最適化を有効にします。-flto が必要です'
# 'End sequence.'
H06B975DED7C7: 'シーケンス終了。'
# 'Enforce name visibility rules across submodules of the same top-level module.'
H3A526080F9BF: '同じトップレベル モジュールのサブモジュール間で名前可視性規則を強制します'
# 'Enforce targets of indirect branches and function returns'
H01AC3BBC07B8: '間接分岐と関数戻り先のターゲットを強制します'
# "Enqueue and re-visit child loops in the loop PM after unrolling. This shouldn't typically be needed as child loops (or their clones) were already visited."
H26C9D96CFA95: 'ループ PM でアンローリング後に子ループの enqueue と再訪問を有効にします。通常は必要ないはずです。子ループ（またはそのクローン）はすでに訪問されていたはずです'
# 'Ensure that all functions can be hotpatched at runtime'
H2573A45755AF: 'すべての関数が実行時にホットパッチ可能であることを確認します'
# 'Ensure that llvm.experimental.noalias.scope.decl for identical scopes are not dominating'
H529A91904E5D: '同じスコープの llvm.experimental.noalias.scope.decl が支配していないことを確認します'
# 'Ensure that the global variables are in the global address space'
HE46C47C5C88F: 'グローバル変数がグローバル アドレス空間にあることを確認します'
# "Ensures debug_value's that have been stackified become stack relative"
H7ED7A97DC8DC: 'スタック化された debug_value がスタック相対となることを保証します'
# 'Entry point name'
H289D7303E351: 'エントリーポイント名'
# 'Entry point name for hlsl'
HE591D017B2D3: 'hlsl のエントリーポイント名'
# 'Enumerate different FRM and VXRM'
H01FEC6A04D14: '異なる FRM と VXRM を列挙'
# 'Enumeration.'
H14D4DDE07BE9: '列挙体。'
# 'Enumerator.'
H1BB8B827F47C: '列挙子。'
# 'Epilogue begin.'
HAB658397C42F: 'エピローグ開始。'
# "Equivalent to '-mrecip=all'"
H732521E2A55F: " '-mrecip=all' に相当"
# 'Equivalent to -march=mips1'
H7FC3E35D9090: '-march=mips1 に相当'
# 'Equivalent to -march=mips2'
HE867B04F1EDA: 'これは -march=mips2 と同等です'
# 'Equivalent to -march=mips3'
H2E91BF8C7F63: 'これは -march=mips3 と同等です'
# 'Equivalent to -march=mips32'
HD42FF697CA84: 'これは -march=mips32 と同等です'
# 'Equivalent to -march=mips32r2'
H1346CAA8E004: 'これは -march=mips32r2 と同等です'
# 'Equivalent to -march=mips32r3'
H1F78C0BD4227: 'これは -march=mips32r3 と同等です'
# 'Equivalent to -march=mips32r5'
H46694C52E140: 'これは -march=mips32r5 と同等です'
# 'Equivalent to -march=mips32r6'
H7EF21D815E8D: 'これは -march=mips32r6 と同等です'
# 'Equivalent to -march=mips4'
H28139C7F49F1: 'これは -march=mips4 と同等です'
# 'Equivalent to -march=mips5'
H677B666B87C9: 'これは -march=mips5 と同等です'
# 'Equivalent to -march=mips64'
H4A78C54743DE: 'これは -march=mips64 と同等です'
# 'Equivalent to -march=mips64r2'
HAA2577781717: 'これは -march=mips64r2 と同等です'
# 'Equivalent to -march=mips64r3'
H5285D4DA9B3F: 'これは -march=mips64r3 と同等です'
# 'Equivalent to -march=mips64r5'
H271253ED3AFA: 'これは -march=mips64r5 と同等です'
# 'Equivalent to -march=mips64r6'
H9AB4B9314716: 'これは -march=mips64r6 と同等です'
# 'Equivalent to -verify=expected'
H8E09CC7EDD92: 'これは -verify=expected と同等です'
# 'Erase GP Operand'
HB8F1F7E9AA26: 'GP オペランドを削除'
# 'Erase the existing functions'
H8F328C294A4D: '既存の関数を削除'
# 'Errata workaround pass'
H882D2A8DC3F5: 'エラータ回避パス'
# 'Error collecting HIP undefined fatbin symbols: %0'
H8A6EDE3371D0: 'HIP の未定義 fatbin シンボルを収集中にエラーが発生しました: %0'
# 'Error for missing parenthesis around predicate registers'
H227937134E2E: '述語レジスタの周囲に括弧が不足しているエラー'
# "Error for register names that aren't contigious"
H8D6DA19266F4: '非連続のレジスタ名のエラー'
# 'Error in reading profile %0: %1'
H431D01FCD538: 'プロファイル %0 の読み込みエラー: %1'
# 'Error messages only'
H0A7E083717DD: 'エラーメッセージのみ'
# 'Error on use'
HD221DA4D89E6: '使用時のエラー'
# 'Errors and warnings'
H2848EBF5EBC2: 'エラーと警告'
# 'Errors only'
H970D9ABE25E2: 'エラーのみ'
# 'Errors, warnings and remarks'
HF85336965841: 'エラー、警告、およびリマインダー'
# 'Evenly re-distribute flow among unknown subgraphs.'
H5604C90F2BE4: '未知のサブグラフ間でフローを均等に再配分します。'
# 'Exact dependences without transitive dependences'
HA1B7947727A7: 'トランスITIVE依存関係を除く正確な依存関係'
# 'Exception catch block.'
H6264B2F9B33C: '例外キャッチ ブロック。'
# 'Exception try block.'
H5C51BB50B6C6: '例外トライ ブロック。'
# 'Exclude compilands by regular expression'
HE55B6BA9D8DC: '正規表現でコンパイル対象を除外'
# 'Exclude functions matching the filter from the output.'
H1D0BAA0AC132: 'フィルターに一致する関数を出力から除外します。'
# 'Exclude sanitization for the top hottest code responsible for the given fraction of PGO counters (0.0 [default] = skip none; 1.0 = skip all). Argument format: <sanitizer1>=<value1>,<sanitizer2>=<value2>,...'
H7D028CB3230B: 'PGO カウンターの指定された分数を担当する最もホットなコードの上位部分のサニタイゼーションを除外（0.0 [デフォルト] = 何もスキップしない；1.0 = 全てスキップ）。引数形式: <sanitizer1>=<value1>,<sanitizer2>=<value2>,...'
# 'Exclude symbols by regular expression'
H599455B9067B: '正規表現でシンボルを除外'
# 'Exclude types by regular expression'
H40334405F17A: '正規表現でタイプを除外'
# 'Exclude wrong side overloads only if there are same side overloads in overloading resolution for CUDA/HIP'
H5AA1CC8C618A: 'CUDA/HIP のオーバーロード解決で同じ側のオーバーロードが存在する場合のみ、誤った側のオーバーロードを除外'
# "Execute MCJIT'ed code in a separate process."
HC2E4E9BA2FB9: 'MCJIT で生成されたコードを別プロセスで実行します。'
# 'Execute graph viewer in the background. Creates tmp file litter.'
HA7075AF10C7F: 'グラフビューアをバックグラウンドで実行します。一時ファイルを散らかします。'
# 'Execute with JIT'
HE5464053A6D4: 'JIT を使用して実行'
# 'Execute with the interpreter'
HEC3165B8EAB3: 'インタプリタで実行'
# 'Executes the snippets within the same process'
H22C3FC000703: '同一プロセス内でフラグメントを実行'
# 'Execution model (WebAssembly only)'
H41BAD8F12174: '実行モデル（WebAssembly専用）'
# 'Exhaustive Search for registers bypassing the depth and interference cutoffs of last chance recoloring'
H3536DA79C20E: 'レジスタの完全探索（最後の機会の再着色の深さと干渉カットオフを越える）'
# 'Exit early if an unpredictable value come from the same loop'
H1F5EDB8C4566: '同一ループから発生した不確実な値が存在した場合、早期終了'
# 'Exit with an error when an instruction is unsupported for any reason (default)'
HDA0C7DD7EA63: 'サポートされていない命令が存在した場合、エラーで終了（既定値）'
# 'Expand 64-bit division in AMDGPUCodeGenPrepare'
HEA34070476C9: 'AMDGPUCodeGenPrepareでの64ビット除算の展開'
# 'Expand Atomic instructions'
H30D3E9ACF190: 'アトミック命令を展開'
# 'Expand certain fp instructions'
H98876AA7B147: '特定の浮動小数点命令を展開'
# 'Expand constant expressions to instructions for testing purposes'
H9BED0D03A404: 'テスト目的で定数式を命令に展開'
# 'Expand double precision loads and stores to their single precision counterparts'
H09525D3EC7B4: 'ダブルプレシジョンのロード/ストアをシングルプレシジョンの対応物に展開'
# 'Expand eligible cr-logical binary ops to branches'
H785023B9F185: '適格なCR論理二項演算を分岐命令に展開'
# 'Expand fp'
H2ACDE0C56583: '浮動小数点命令の展開'
# 'Expand hlfir.matmul as elemental operation'
HB8FB6378B2A3: 'hlfir.matmulを要素単位の操作として展開'
# 'Expand indirectbr instructions'
H0645EC041241: 'indirectbr命令を展開'
# 'Expand large div/rem'
H6BA324BB9D05: '大規模なdiv/rem命令を展開'
# 'Expand macros without full preprocessing'
H13AAEB743C7B: 'フルプリプロセスなしでマクロを展開'
# 'Expand memcmp() to load/stores'
H44E3E46EDFEB: 'memcmp()をロード/ストアに展開'
# 'Expand memcpy into load/store pairs in order'
H9B1207BABDAD: 'memcpyを順次ロード/ストアペアに展開'
# "Expand operand's MIOperandInfo DAG into suboperands"
H0AED692FCB12: 'オペランドのMIOperandInfo DAGをサブオペランドに展開'
# 'Expand out of range branch instructions and fix forbidden slot hazards'
HB54E4CE04809: '範囲外のブランチ命令を展開し、禁止されたスロットの危険を修正します'
# 'Expand out of range branches'
H08752DCA250D: '範囲外のブランチを展開します'
# 'Expand reduction intrinsics'
H9287AE31FDD0: 'reduction内在関数を展開します'
# 'Expand variadic functions'
HC0CCC1B4F1F9: '可変長関数を展開します'
# 'Expect external char-aligned symbols to be without ABI alignment (SystemZ only)'
HEE285623EE10: '外部のcharアラインメントされたシンボルがABIアラインメントがないことを想定（SystemZのみ）'
# 'Experimental pc tracing'
H45FAF05767D2: '実験的pcトレース'
# 'Explain input dump and quit'
HB398CAAA9E7D: '入力ダンプの説明と終了'
# 'Explain why a node was skipped (default=true)'
H51DC101E0A71: 'ノードがスキップされた理由を説明（デフォルトはtrue）'
# 'Explain why a pattern was skipped for inclusion in the GlobalISel selector'
HAC0A3B68049F: 'GlobalISelセレクターへの包含のためにパターンがスキップされた理由を説明'
# 'Exploit reductions in dependence analysis'
H76A87C10B6BB: '依存関係解析におけるreductionsを活用する'
# 'Export debug info (by testing original Debug Info) failures into specified (JSON) file (should be abs path as we use append mode to insert new JSON objects).'
H632F15D60721: 'デバッグ情報（元のDebug Infoのテストによる）の失敗を指定されたJSONファイル（絶対パスを指定する必要があります。appendモードを使用して新しいJSONオブジェクトを挿入するため）に出力します。'
# 'Export debug info preservation failures into specified (JSON) file (should be abs path as we use append mode to insert new JSON objects)'
HD135A5123609: 'デバッグ情報の保存の失敗を指定されたJSONファイル（絶対パスを指定する必要があります。appendモードを使用して新しいJSONオブジェクトを挿入するため）に出力します。'
# 'Export full callsite graph'
H8538ECACAB5E: 'フルコールサイトグラフを出力'
# 'Export graph to dot files.'
H314220D2E444: 'グラフをdotファイルに出力'
# 'Export only nodes with contexts feeding given -memprof-dot-alloc-id'
H11F3042B06F8: '指定された -memprof-dot-alloc-id にコンテキストを供給するノードのみを出力'
# 'Export only nodes with given -memprof-dot-context-id'
H910BF34B1ED8: '-memprof-dot-context-id で指定されたコンテキストを持つノードのみを出力'
# 'Export only summary information for each source file'
HD9DCC346A6DB: '各ソースファイルのサマリ情報のみを出力'
# 'Export per-pass debugify statistics to this file'
H798BCDB12E0E: '各passのdebugify統計をこのファイルに出力'
# 'Export the polyhedral description of the detected Scops'
H517A4767D0DE: '検出されたScopsのポリエドライクな記述を出力'
# 'Export typeid resolutions to summary and globals'
H705A17261B58: 'typeid解決をサマリとグローバルに出力'
# 'Exporting options'
HA28E86F82A20: 'オプションのエクスポート'
# 'Extend the -G behaviour to object local data (MIPS)'
H807C41A2617A: 'ローカルデータ向けに -G ビヘイビアを拡張 (MIPS)'
# 'Extend the liveness of user variables through optimizations to prevent stale or optimized-out variable values when debugging.'
HE9566864B09C: '最適化時のユーザー変数の有効期間を延長し、デバッグ時に古いまたは最適化で削除された変数値を防ぎます。'
# 'Extensible binary encoding'
H16E285BD9929: '拡張可能なバイナリエンコーディング'
# 'Extensible binary encoding (default)'
HBCE99B0D176C: '拡張可能なバイナリエンコーディング（既定値）'
# 'External Alias Analysis'
H99D45183AADE: '外部のエイリアス分析'
# 'Externalize enqueued block runtime handles'
HD158E9A6F40A: 'キューに格納されたブロックのランタイムハンドルを外部化'
# 'Extra archive files to be loaded'
HD60827C100DD: '読み込む追加のアーカイブファイル'
# 'Extra directory of include files'
H401E9781A70C: '読み込む追加のインクルードファイルディレクトリ'
# 'Extra modules to be loaded'
H4905A00383B5: '読み込む追加のモジュール'
# 'Extra object files to be loaded'
HFBB158EB888B: '読み込む追加のオブジェクトファイル'
# 'Extract API information'
HAD16D93996E0: 'API 情報の抽出'
# 'Extract HwModes-specific instructions into new DecoderTables, significantly reducing Table Duplications'
HF76D682A9D15: 'HwModes 専用命令を新しい DecoderTables に抽出し、テーブルの重複を大幅に削減'
# 'Extract at most one loop into a new function'
H2D39B07FBC4D: '最大 1 つのループを新しい関数に抽出'
# 'Extract from <file>.'
H4A68D5BEAE14: '<file> から抽出します。'
# 'Extract loops into new functions'
H053EB2868DBF: 'ループを新しい関数に抽出'
# 'FAILURE'
HF9C22E097EEB: '失敗'
# 'FILECHECK_OPTS'
H2A422AA39933: 'FILECHECK_OPTS'
# 'FIX-IT applied suggested code changes'
H19B769DF31D9: 'FIX-IT が提案されたコード変更を適用しました'
# 'FIX-IT detected an error it cannot fix'
HD809189A8863: 'FIX-IT が修正できないエラーを検出'
# 'FIX-IT detected errors it could not fix; no output will be generated'
HEE3E7F0F9BA0: 'FIX-ITは修正不可能なエラーを検出しました；出力は生成されません'
# 'FIX-IT unable to apply suggested code changes'
H2B4E9FB21753: 'FIX-ITは提案されたコード変更を適用できませんでした'
# 'FIX-IT unable to apply suggested code changes in a macro'
H3E3C2FB702A6: 'マクロ内で提案されたコード変更を適用できませんでした'
# 'Factor for the unroll threshold to account for code simplifications still taking place'
HBD6D5665E545: 'コード簡略化が継続する場合のアンロール閾値係数'
# 'Factor to apply to what qualifies as a long branch to reserve a pair of scalar registers. If this value is 0 the long branch registers are never reserved. As this value grows the greater chance the branch distance will fall within the threshold and the registers will be marked to be reserved. We lean towards always reserving a register for  long jumps'
H106A273943F9: '長い分岐として判定される閾値に適用する係数。この値が0の場合、長い分岐レジスタは予約されない。この値が大きくなるほど、分岐距離が閾値内に入る確率が上がり、レジスタが予約マークされる。長いジャンプにはレジスタを予約する傾向がある'
# "Fail if an object couldn't be found for a binary ID in the profile"
H4235E7E596D5: 'プロファイルのバイナリIDに対応するオブジェクトが見つからなかった場合にエラーを発生'
# 'Fail if any profile is invalid.'
HFB8AB051E56E: '無効なプロファイルが存在する場合にエラーを発生'
# 'Fail only if all profiles are invalid.'
HF5E080277997: 'すべてのプロファイルが無効な場合のみエラーを発生'
# 'Failure mode:'
H1A58BCEE2CF5: 'エラー発生モード:'
# 'Falkor HW Prefetch Fix'
H323CD584CC0F: 'Falkor HW Prefetch Fix'
# 'Falkor HW Prefetch Fix Late Phase'
H682A690E57FE: 'Falkor HW Prefetch Fix 後工程フェーズ'
# 'Fallback style for reformatting after inserting new\nheaders if there is no clang-format config file found.'
H581E7F83176F: 'clang-format構成ファイルが見つからない場合、新しいヘッダを挿入後に再整形する際のfallbackスタイル'
# 'Fallback to indirect when incorrect'
HD59C4BCB012E: '不正確な場合にindirectにfallback'
# 'Fast Register Allocator'
H749535234AA8: '高速レジスタ割り当て'
# 'Fast Tile Register Configure'
HE2B5F0EAEB3A: '高速タイルレジスタ構成'
# 'Fast Tile Register Preconfigure'
H049C9C8DDC88: '高速タイルレジスタ事前構成'
# 'Fast register allocator'
H0FB6B67552E0: '高速レジスタ割り当て器'
# 'Fast suboptimal list scheduling'
HE44BDB59069E: '高速非最適解リストスケジューリング'
# 'Features to use to serialize to cubin.'
H480406601DAF: 'cubinにシリアル化する際に使用する機能'
# 'File checksums (DEBUG_S_CHECKSUMS subsection)'
H0341151319EC: 'ファイルチェックサム (DEBUG_S_CHECKSUMS サブセクション)'
# 'File containing RuntimeDyld verifier checks.'
H91AFD2697B81: 'RuntimeDyld バリデーターチェックを含むファイル'
# 'File containing diagnostic suppression mappings. See user manual for file format.'
H65FE3D35314C: '診断抑制マッピングを含むファイル。ファイル形式についてはユーザーマニュアルを参照してください'
# 'File containing entry point of the transform script, if different from the input file'
H6B64668AC58F: '入力ファイルと異なる場合の変換スクリプトのエントリーポイントを含むファイル'
# 'File containing verifier checks'
H4CA0F6F72C6E: '検証チェックを含むファイル'
# "File doesn't need an exec stack"
H9CC2858800DD: 'execスタックは不要です'
# 'File for serializing diagnostics in a binary format'
H94768CE895D7: 'バイナリ形式でシリアル化された診断を含むファイル'
# 'File holding the seed used by the randomize structure layout feature'
HE8D1A6EACA51: '構造配置ランダマイズ機能に使用されるシードを保持するファイル'
# 'File is for a position independent executable'
HC6398B79E913: '位置独立実行可能ファイル用のファイル'
# 'File listing native ABI functions and how the pass treats them'
H779A21941187: 'ネイティブABI関数とパスの処理方法を列挙したファイル'
# 'File name to use for YAML optimization record output'
HDFBB63F1AC25: 'YAML最適化レコード出力に使用するファイル名'
# 'File name to use for split dwarf debug info output'
H6FBC3D7AD088: '分割DWARFデバッグ情報出力に使用するファイル名'
# 'File path for cold function only instrumentation(requires use with --pgo-instrument-cold-function-only)'
H833BBD566D2F: 'コールド関数のみの計測用パス（--pgo-instrument-cold-function-onlyとの併用が必要）'
# 'File path to where .cgdata file is read'
HD25E7479AD77: '.cgdataファイルを読み込むパス'
# 'File to append -stats and -timer output to'
H8C0548CC1115: '-statsと-timer出力を追記するファイル'
# 'File to check (defaults to stdin)'
H44D35D906559: 'チェック対象のファイル（デフォルトは標準入力）'
# 'File to emit dot graph of new summary into'
HB22275C53F6F: '新しいサマリーのdotグラフを出力するファイル'
# 'File to read (analysis mode) or write (latency/uops/inverse_throughput modes) benchmark results. “-” uses stdin/stdout.'
H44970F94DF2D: '分析モードで読み込むか、遅延/遅延逆伝播モードで書くベンチマーク結果のファイル。"-"は標準入出力を使用します'
# 'File to record the coroutines got elided'
H175805F86595: '省略されたコルーチンを記録するファイル'
# 'File with the profile data obtained after an instrumented run'
HD4AF1660449E: 'インストゥルメンテーション実行後のプロファイルデータを含むファイル'
# 'File(s) containing definitions of additional transform script symbols'
HF1DBCA863288: '追加の変換スクリプトシンボルの定義を含むファイル'
# 'Filename (or -) to log diagnostics to'
HDACB45AABD12: '診断情報を記録するためのファイル名（または -）'
# 'Filename (or -) to write dependency output to'
H8BC9F30BC52B: '依存関係の出力を書き込むためのファイル名（または -）'
# 'Filename (or -) to write header include output to'
H5BF600319EF5: 'ヘッダーインクルード出力を書き込むためのファイル名（または -）'
# 'Filename (or -) to write stack usage output to'
H3BC188E55BBD: 'スタック使用量の出力を書き込むためのファイル名（または -）'
# 'Filename defining the list of functions/files to instrument. The file uses the sanitizer special case list format.'
HC15DFAEF876C: 'Sanitizerの特殊ケースリスト形式を使用する関数/ファイルの一覧を定義するファイル名。'
# 'Filename defining the list of functions/types for imbuing XRay attributes.'
H59E8B9411DF9: 'XRay属性を付与する関数/タイプの一覧を定義するファイル名。'
# 'Filename to pipe in as stdin (default: /dev/null)'
HBE65800DDA37: '標準入力としてパイプで読み込むファイル名（デフォルト: /dev/null）'
# 'Filename to write DOT-formatted header dependencies to'
HA2996F065595: 'DOT形式のヘッダ依存関係を書き込むファイル名'
# 'Filename to write statistics to'
HE239C00D43A5: '統計情報を書き込むファイル名'
# 'Filename where the element is defined.'
H1FDF8DE162D7: '要素が定義されているファイル名。'
# 'Files referenced in the debug information.'
HBAB8680F7972: 'デバッグ情報に参照されているファイル。'
# 'Fill Lanai delay slots with NOPs.'
H5DF685F1DB1E: 'LanaiのディレイスロットをNOPで埋める。'
# 'Fill a percentage of the latency between neighboring MFMA with s_nops.'
H17E41E561253: '近接するMFMA間の遅延のパーセンテージをs_nopsで埋める。'
# 'Fill all delay slots with NOPs.'
HDA6B69446833: '全てのディレイスロットをNOPで埋める。'
# 'Fill delay slot for MIPS'
HAFAF170DC965: 'MIPSのディレイスロットをNOPで埋める。'
# 'Filter all non-error diagnostics (discouraged: testing only!)'
H9EF0422D020C: '非エラーダiagnosticsをフィルタ（テスト用のみ！非推奨）'
# 'Filter the benchmarks before analysing them'
H30E98BA4CBDB: 'ベンチマークを分析する前にフィルタリングする'
# 'Filtering and Sorting Options'
HAE5C92A1E57B: 'フィルタリングおよびソートオプション'
# 'Finalize ISel and expand pseudo-instructions'
HAC66FC917CAA: 'ISelの最終化と疑似命令の展開'
# 'Finalize machine instruction bundles'
H54F93CB22051: 'マシン命令のバンドルを最終化'
# 'Find methods that overrides a virtual method.'
H26E803BD2E38: '仮想メソッドをオーバーライドするメソッドを検索します。'
# "Find objects in DIR or based on FILE's path"
H4D2FE19AC654: 'DIRまたはFILEのパスに基づいてオブジェクトを検索します。'
# 'Find subclasses of a class.'
HC1D51E00B82D: 'クラスのサブクラスを検索します。'
# 'Fix copies between 32 and 16 bit registers by extending to 32 bit'
H2E54AD53EEA9: '32ビットと16ビットレジスタ間のコピーを修正し、32ビットに拡張します'
# 'Fix function entry count in profile use.'
H99125FC0562C: 'プロファイル使用時の関数エントリーカウントを修正します。'
# 'Fix mismatching bitcasts for WebAssembly'
H6D3A5F07020F: 'WebAssemblyの不整合なビットキャストを修正します。'
# 'Fixup Statepoint Caller Saved'
H2BF0C8053839: 'ステートポイント・コールャーセーブを修正します。'
# 'Fixup each natural loop to have a single exit block'
H866DA2E73BC2: '自然なループを単一の出口ブロックを持つように修正します'
# 'Flatten the CFG'
H68BF16D61F64: 'CFG（制御フローグラフ）を平坦化します。'
# 'Flow Sensitive profile file name.'
HD4BF3081650C: 'フロー感度プロファイルファイル名。'
# 'Flow Sensitive profile remapping file name.'
H21713A45D881: 'フロー感度プロファイル再マッピングファイル名。'
# 'Flush denormal floating point values to zero in CUDA/HIP device mode.'
HF25D292D7C52: 'CUDA/HIPデバイスモードで非正規浮動小数点値をゼロにフラッシュします。'
# 'Fold memory accesses to model more possible delinearizations (does not scale well)'
HC5006CA24C2C: 'メモリアクセスを折り畳み、より多くのデリニアライズをモデル化（スケーリングがよくない）'
# 'Fold null checks into faulting memory operations'
HC5500C22FC68: 'NULLチェックをエラー発生メモリ操作に統合します。'
# 'Folder name for view splitting.'
HE1AD57EFF1BD: 'ビュー分割用のフォルダ名。'
# 'Folds all regular instructions (including pre-outputs)'
HB765A3FB1AB5: '通常の命令をすべて折り畳み（プリアウトプットを含む）'
# 'Follow Fortran 2003 rules for (re)allocating the LHS of the intrinsic assignment'
H1CD29CD7E654: 'Fortran 2003規則に準拠して、固有の代入の左辺を(再)割り当てます。'
# 'Follow the AAPCS standard requirement stating that volatile bit-field width is dictated by the field container type. (ARM only).'
H318AB39D2C02: 'AAPCS標準要件に準拠：volatileビットフィールドの幅はフィールドコンテナータイプによって決定されます（ARMのみ）。'
# 'Follows the AAPCS standard that all volatile bit-field write generates at least one load. (ARM only).'
HBE2099993756: 'AAPCS標準に準拠：すべてのvolatileビットフィールド書き込みは少なくとも1つのロードを生成します（ARMのみ）。'
# 'For -verify only: Inject a symbol into the extern symbol table.'
H691B584BF08D: '-verifyオプション専用：シンボルをexternシンボルテーブルに挿入します。'
# 'For -verify only: Map a section to a specific address.'
H943A8FBB7A51: '-verify専用: セクションを特定のアドレスにマッピングします。'
# 'For -verify only: Separation between sections in phony target address space.'
HFFEB26CFD553: '-verify専用: フォニー・ターゲット・アドレス空間内のセクション間の区切り。'
# 'For -verify only: end of phony target address range.'
H2C3EAFFA8499: '-verify専用: フォニー・ターゲット・アドレス範囲の終了。'
# 'For -verify only: start of phony target address range.'
H1B0A5AC1E801: '-verify専用: フォニー・ターゲット・アドレス範囲の開始。'
# 'For MachO, disable atexit()-based global destructor lowering'
HFC5FF11ED2AC: 'MachOの場合、atexit()ベースのグローバルデストラクタの最適化を無効にします。'
# 'For a large interval, if it is coalesced with other live intervals many times more than the threshold, stop its coalescing to control the compile time. '
H31454C2664AA: '大規模な区間の場合、しきい値を超える回数他の生存区間と結合された場合、コンパイル時間を制御するために結合を停止します。'
# "For a list of available CPUs for the target use '-mcpu=help'"
HFB257544DEA1: "対象のCPUリストを表示するには '-mcpu=help' を使用してください。"
# "For a list of available architectures for the target use '-mcpu=help'"
HCFFD910F1E45: "対象のアーキテクチャリストを表示するには '-mcpu=help' を使用してください。"
# 'For all options that iterate over modules, ignore modules from system libraries'
HF30AFF2F9F8C: 'モジュールを反復処理するすべてのオプションで、システムライブラリのモジュールを無視します。'
# 'For all options that iterate over modules, limit to the specified module'
H076A99AD2B76: 'モジュールを反復処理するすべてのオプションで、指定されたモジュールに制限します。'
# 'For cold function instrumentation, skip instrumenting functions whose entry count is above the given value.'
HE6D6C775176E: 'Cold関数のインストルメンテーションでは、エントリカウントが指定値を超える関数のインストルメンテーションをスキップします。'
# 'For cold function instrumentation, treat count unknown(e.g. unprofiled) functions as cold.'
H063B03A52387: 'Cold関数のインストルメンテーションでは、カウント不明（例: 非プロファイリング）の関数をcoldとして扱います。'
# 'For context sensitive PGO counts. Does not work with CSSPGO.'
HBBB3E8C601A8: 'コンテキスト依存のPGOカウント用。CSSPGOと併用できません。'
# 'For each function, emit a dot graph depicting potential LVI gadgets'
H57E599CB6769: '各関数に対して、潜在的なLVIガジェットを示すdotグラフを出力します。'
# 'For each function, emit a dot graph depicting potential LVI gadgets, and do not insert any fences'
HAC353EF77E07: '各関数に対して、潜在的なLVIガジェットを示すdotグラフを出力し、フェンスの挿入を行いません。'
# 'For each function, emit a dot graph to stdout depicting potential LVI gadgets, used for testing purposes only'
H3C8BB209ABDE: '各関数に対して、標準出力に潜在的なLVIガジェットを示すdotグラフを出力します（テスト用のみ）。'
# 'For merge, use the provided unstripped binary to correlate the raw profile.'
H5C641C769774: 'マージ時、提供されたストリップされていないバイナリを使用して生プロファイルを関連付けます。'
# 'For partially supported constructs, emit `[first]private` variables as clauses on the MLIR ops.'
H6182FD8E07DA: '部分的にサポートされている構造体の場合、MLIRオペレーションの句として`[first]private`変数を出力します。'
# 'For paths in debug info, remap directory <old> to <new>. If multiple options match a path, the last option wins'
H3D3679C30C18: 'デバッグ情報内のパスに対して、ディレクトリ<old>を<new>にリマップします。複数のオプションがパスに一致する場合、最後のオプションが優先されます。'
# 'For sample profiles, list function names (with calling context for csspgo) for overlapped functions with similarities below the cutoff (percentage times 10000).'
H463D2852BF2F: 'サンプルプロファイルの場合、しきい値（パーセンテージ×10000）以下の類似度を有する重複関数の関数名（csspgo用のコールコンテキストを含む）を一覧表示します。'
# 'For shared library loaded with the main program, change local-dynamic access(es) to initial-exec access(es) at the function level (AIX 64-bit only).'
HD94E43E648D1: 'メインプログラムで読み込まれた共有ライブラリに対して、関数レベルでローカル・ダイナミック・アクセスを初期実行アクセスに変更します（AIX 64ビット専用）。'
# 'For show, read and extract profile metadata from debug info and show the functions it found. For merge, use the provided debug info to correlate the raw profile.'
H3F78033E8267: 'showの場合はデバッグ情報からプロファイルメタデータを抽出し見つかった関数を表示、mergeの場合は提供されたデバッグ情報を用いて生プロファイルを関連付けます。'
# 'For symbols in profile symbol list, regard their profiles to be accurate. It may be overridden by profile-sample-accurate. '
H960468D026B4: 'プロファイルシンボルリスト内のシンボルについてはそのプロファイルを正確とみなします。profile-sample-accurateによって上書きされる可能性があります。'
# "For test - keep the ML Inline advisor's FunctionPropertiesInfo cache"
H68E3D966BDA0: 'テスト用 - ML Inline アドバイザーのFunctionPropertiesInfoキャッシュを保持する'
# "For testing purposes, always break large PHIs even if it isn't profitable."
H0BECF527CC8D: 'テスト用に、利益がなくても大規模なPHIノードを分割します。'
# 'For the function which is cold in instr profile but hot in sample profile, if the ratio of the number of zero counters divided by the total number of counters is above the threshold, the profile of the function will be regarded as being harmful for performance and will be dropped.'
H326030B813BD: 'インストゥルメントプロファイルでは寒いがサンプルプロファイルではホットな関数に対して、ゼロカウンタの数/全カウンタ数の比率が閾値を超える場合、そのプロファイルをパフォーマンスに悪影響と見なし破棄します。'
# 'For the module ID for the file to process, useful to match what is in the index.'
HB6A96C6D31C3: 'インデックス内の内容と一致させるための処理対象ファイルのモジュールIDを指定します。'
# 'For use with /winsysroot, defaults to newest found'
H9FFDA74D3CE8: '/winsysrootと併用、デフォルトは最新バージョンを採用'
# 'Force a peel count regardless of profiling information.'
H6BA57EBF2817: 'プロファイリング情報に関係なく特定のピール回数を強制指定します。'
# 'Force a specific generic_v<N> flag to be added. For testing purposes only.'
H12597D7C787F: 'テスト用に特定のgeneric_v<N>フラグを追加します。'
# 'Force align the stack to the minimum alignment'
H6ABD893EDD1A: 'スタックを最小アライメントで強制配置します'
# 'Force all edges in the function summary to cold'
HF7516A69CF5A: '関数サマリ内の全てのエッジをコールドと見なします'
# 'Force all functions to be noinline'
HB0A34849A65E: '全ての関数にnoinline属性を強制付与します'
# 'Force all indexed operations to be legal for the GlobalISel combiner'
H8B4D9E88A547: 'GlobalISelコンバインが合法とみなすインデックス付き演算を強制します'
# 'Force all memory accesses to be aligned (AArch32/MIPSr6 only)'
HB9DB3E9A0275: 'メモリアクセスがアラインメント済みと仮定（AArch32/MIPSr6専用）'
# 'Force all memory accesses to be aligned (AArch64/LoongArch/RISC-V only)'
H592DBE5D5A8A: 'メモリアクセスがアラインメント済みと仮定（AArch64/LoongArch/RISC-V専用）'
# 'Force all scalar memory accesses to be aligned (RISC-V only)'
H47C5C3723D44: 'スカラーメモリアクセスがアラインメント済みと仮定（RISC-V専用）'
# 'Force all vector memory accesses to be aligned (RISC-V only)'
H8477BA8471BC: 'ベクターメモリアクセスがアラインメント済みと仮定（RISC-V専用）'
# 'Force all waitcnt instrs to be emitted as s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)'
H687C328A88F2: '全てのwaitcnt命令をs_waitcnt vcnt(0) expcnt(0) lgkmcnt(0)形式で出力します'
# 'Force all waitcnt load counters to wait until 0'
H896788DC2080: '全てのwaitcntロードカウンタを0になるまで待機します'
# 'Force allowance of nested hardware loops'
HAD8E45F66910: 'ネストされたハードウェアループの使用を強制的に許可'
# 'Force analysis to continue in the presence of unsupported instructions'
H0386966E38DA: 'サポートされていない命令が存在する場合でも解析を継続するように強制'
# 'Force behavior as if the user specified pragma omp requires unified_shared_memory.'
H0D0C1138BD58: 'ユーザーがpragma omp requires unified_shared_memoryを指定したかのように振る舞うように強制'
# 'Force bidirectional post reg-alloc list scheduling'
H2AB733A479DE: 'レジスタ割り当て後のリストスケジューリングを双方向にするように強制'
# 'Force bidirectional pre reg-alloc list scheduling'
H9527EDFB6708: 'レジスタ割り当て前のリストスケジューリングを双方向にするように強制'
# 'Force bottom-up post reg-alloc list scheduling'
HC9A155CC7DD9: 'レジスタ割り当て後のリストスケジューリングをボトムアップ方式で行うように強制'
# 'Force bottom-up pre reg-alloc list scheduling'
HD5FFAD3EC478: 'レジスタ割り当て前のリストスケジューリングをボトムアップ方式で行うように強制'
# 'Force codegen to assume rounding mode can change dynamically'
H5694C07468F1: 'コード生成時に丸めモードが動的に変化するものと仮定するように強制'
# 'Force disable the lazy-loading on-demand of metadata when loading bitcode for importing.'
H2329A45D867C: 'ビットコードの読み込み時にメタデータの遅延読み込みを無効にする'
# 'Force double to be <n> bits'
H6A3CAE57D5DB: '倍精度浮動小数点型を<n>ビットとするように強制'
# 'Force each unsigned fixed point type to have an extra bit of padding to align their scales with those of signed fixed point types'
H2DB086248971: '符号なし定点型に符号付き定点型のスケールと一致するようにパディングビットを追加するように強制'
# 'Force emit s_waitcnt expcnt(0) instrs'
H88E5FE04F072: 's_waitcnt expcnt(0)命令を出力するように強制'
# 'Force emit s_waitcnt lgkmcnt(0) instrs'
HE8A3AAF43D8E: 's_waitcnt lgkmcnt(0)命令を出力するように強制'
# 'Force emit s_waitcnt vmcnt(0) instrs'
H38DB94C17996: 's_waitcnt vmcnt(0)命令を出力するように強制'
# 'Force enable speculative execution side effect suppression. (Note: User must pass -mlvi-cfi in order to mitigate indirect branches and returns.)'
H5C45F8896F6A: '投機実行の副作用を抑制する機能を有効化（注：間接分岐/戻りを軽減するには-mlvi-cfiを指定する必要があります）'
# 'Force enable speculative load hardening'
HE35AC46B0548: '投機的ロード強化機能を有効化'
# 'Force function reduction to keep main'
H0BB63C069108: 'main関数を保持する関数簡約化を強制'
# 'Force function specialization for every call site with a constant argument'
H16827AFD0E0F: '定数引数を持つすべての呼び出しサイトで関数の特殊化を強制'
# 'Force function to be mips32'
H47CC37388F1A: '関数をmips32に設定するように強制'
# 'Force generation of loop guard intrinsic'
H660425C561DD: 'ループガードインtrinsicの生成を強制'
# 'Force generation of thread parallel code ignoring any cost model'
HD5652803169B: 'コストモデルを無視してスレッド並列コードを生成するように強制'
# 'Force hardware loop counter to be updated through a phi'
H6034A18A690A: 'ハードウェアループカウンタをphiを通じて更新するように強制'
# 'Force hardware loops intrinsics to be inserted'
H526108F8C3D0: 'ハードウェアループ_INTRINSICSを挿入するように強制'
# 'Force interpretation: disable JIT'
HE0B08266ED91: 'インタプリテーションを強制: JITを無効化'
# 'Force linking the clang builtins runtime library'
H602A2DB51D2C: 'clangビルトインランタイムライブラリのリンケージを強制'
# 'Force long double to be 128 bits'
HF5330D6B0F62: 'long doubleを128ビットに設定するように強制'
# 'Force long double to be 64 bits'
HF1CEF43473D8: 'long doubleを64ビットに設定するように強制'
# 'Force long double to be 80 bits, padded to 128 bits for storage'
H2FBC78A0A1C7: 'long doubleを80ビットに設定し、格納時には128ビットパディングを強制'
# 'Force machine combiner to use a specific strategy for machine trace metrics evaluation.'
H8D7274D95AD0: 'マシントレースメトリクス評価用のマシンコンビナー戦略を指定して強制'
# 'Force matrix instruction fusion even if not profitable.'
HABD067814D75: '効果的でない場合でも行列命令の融合を強制'
# 'Force optimization experiment (for testing)'
H23001FDFF697: '最適化実験を強制（テスト用）'
# 'Force outline regions with live exits'
H13A02DD93B7D: 'ライブ出口を伴う領域のアウトライン化を強制'
# 'Force outlining cold blocks from loops.'
H04711024D9E9: 'ループからコールドブロックのアウトライン化を強制'
# 'Force pipeliner to use specified II.'
H17E89A49B48C: 'パイプライン処理のIIを指定して強制'
# 'Force pipeliner to use specified issue width.'
HA8DD64472E32: 'パイプライン処理のissue幅を指定して強制'
# 'Force realign the stack at entry to every function'
H31A8B99D0D70: 'すべての関数エントリでスタックの再アライメントを強制'
# 'Force store splitting no matter what the target query says.'
H7A397BF735D5: 'ターゲットクエリに関わらずストア分割を強制'
# 'Force the (profiled-guided) size optimizations. '
HA4B424DB2FF9: 'プロファイルガイド型サイズ最適化を強制'
# 'Force the alignment of all blocks in the function in log2 format (e.g 4 means align on 16B boundaries).'
HB1C496FAEC2F: '関数内のすべてのブロックのアライメントをlog2形式で設定（例：4は16B境界にアライメント）'
# "Force the alignment of all blocks that have no fall-through predecessors (i.e. don't add nops that are executed). In log2 format (e.g 4 means align on 16B boundaries)."
HEC173CEDA264: 'fall-through predecessor（フールルー接続のない predecessor）がないすべてのブロックのアラインメントを強制（つまり実行されるnopを追加しない）。log2 形式で指定（例: 4は16B境界へのアラインメントを意味します）。'
# 'Force the alignment of all functions in log2 format (e.g. 4 means align on 16B boundaries).'
HAC694582BD7C: '関数のアラインメントをlog2形式で強制（例: 4は16B境界へのアラインメントを意味します）。'
# 'Force the interpretation of -stream as a string, even if it is a valid integer'
HD1DE45392158: '-streamを整数としてではなく文字列として解釈するように強制（有効な整数でもある場合でも）'
# 'Force the static analyzer to analyze functions defined in header files'
HAB6B5ACFD382: 'ヘッダーファイルで定義された関数を静的解析対象に強制'
# 'Force the tail folding style'
HA1C7FE88ED1D: 'テイルフォールディングスタイルの使用を強制'
# 'Force the use of a base pointer in every function'
HBE1018F652C4: 'すべての関数でベースポインタの使用を強制'
# 'Force the use of precise cost loop rotation strategy.'
HEC5F52CCB084: '正確なコストに基づくループ回転戦略の使用を強制'
# 'Force the use of resource intervals in the schedule model'
HC146F04B90B5: 'スケジュールモデルにリソース区間の使用を強制'
# 'Force the use of streaming code for all functions'
H9D121C14481F: 'すべての関数でストリーミングコードを使用するように強制'
# 'Force the use of streaming-compatible code for all functions'
H3939F502979A: 'すべての関数でストリーミング互換コードを使用するように強制'
# 'Force thread model single in LICM pass'
H95CEFB645311: 'LICM パスでスレッドモデル single を強制'
# 'Force to instrument function entry basicblock.'
HCB64281E774F: '関数のエントリーベーシックブロックを強制的に計測'
# 'Force to instrument loop entries.'
H3FF84C8727C9: 'ループエントリを強制的に計測'
# 'Force top-down post reg-alloc list scheduling'
H624C5BFC69FE: 'レジスタ割り当て後のトップダウンリストスケジューリングを強制'
# 'Force top-down pre reg-alloc list scheduling'
HF7823207CF83: 'レジスタ割り当て前のトップダウンリストスケジューリングを強制'
# 'Force use of AdvSIMD scalar instructions everywhere'
H5BE24FD8EC8D: 'AdvSIMDスカラ命令の全域的な使用を強制'
# 'Force using MLIR complex operations instead of libm complex operations'
HE874B9895802: 'libmの複素数操作ではなくMLIR複素数操作を使用するように強制'
# 'Force wchar_t to be a short unsigned int'
H344B5212E317: 'wchar_t を short unsigned int として強制'
# 'Force wchar_t to be an unsigned int'
H43342C927949: 'wchar_t を unsigned int として強制'
# 'Force whether the StructurizeCFG pass skips uniform regions'
H1E4EFD3EA072: 'StructurizeCFG パスが一様領域をスキップするかどうかを強制'
# 'Forces the maximum bytes allowed to be emitted when padding for alignment'
H3B4D326FCA22: 'アラインメントのためのパディング時に発行可能な最大バイト数を強制指定します'
# 'Forcibly enables non-trivial loop unswitching rather than following the configuration passed into the pass.'
H2E9D92A16FC3: '非自明なループアンスイッチングを、パスに渡された設定に従わず強制的に有効にします。'
# 'Forget everything in SCEV when doing LoopUnroll, instead of just the current top-most loop. This is sometimes preferred to reduce compile time.'
HDBEAD86F6F49: 'ループアンロールを行う際にSCEVのすべてをリセット（現在の最上位ループだけではなく）。コンパイル時間を短縮するために有用な場合があります。'
# 'Form fused FP ops (e.g. FMAs)'
H88EF5D85058D: '融合されたFP演算（例: FMA）を生成'
# 'Format a range of this length (in bytes).\nMultiple ranges can be formatted by specifying\nseveral -offset and -length pairs.\nWhen only a single -offset is specified without\n-length, clang-format will format up to the end\nof the file.\nCan only be used with one input file.'
H93D871018723: 'この長さ（バイト単位）の範囲を整形します。\n複数の範囲を処理するには、複数の-offsetと-lengthペアを指定できます。\n-offsetのみが1つ指定され-lengthが指定されない場合は、clang-formatはファイルの末尾まで整形します。\nこのオプションは1つの入力ファイルのみで使用可能です。'
# 'Format a range starting at this byte offset.\nMultiple ranges can be formatted by specifying\nseveral -offset and -length pairs.\nCan only be used with one input file.'
H28E3CD62FED9: 'このバイトオフセットから始まる範囲を整形します。\n複数の範囲を処理するには、複数の-offsetと-lengthペアを指定できます。\nこのオプションは1つの入力ファイルのみで使用可能です。'
# "Format consumable by Brendan Gregg's FlameGraph tool. Only valid with -all-stacks."
HE769F9BDFBAB: 'Brendan GreggのFlameGraphツールで利用可能な形式。-all-stacksと併用する必要があります。'
# 'Format for outputted docs.'
HC5A8B725033A: '出力されるドキュメントの形式。'
# 'Format message diagnostics so that they fit within N columns'
H5F2F2FEC74C8: '診断メッセージをNカラム以内に収まるように整形'
# 'Format of index export'
H9AED5C1C80E8: 'インデックスのエクスポート形式'
# 'Format of output profile'
HAE3C92A81F31: '出力プロファイルの形式'
# 'Format of the index to be written'
H036107DC230C: '書き込まれるインデックスの形式'
# 'Formatting Options'
H7C2DC2E6B392: '整形オプション'
# 'Forward options to the linker'
H0E5969703D2A: 'リンカにオプションを転送'
# 'Forward switch condition to phi ops (default = false)'
HB7C76B2E6FA2: 'phi演算子にスイッチ条件を転送（デフォルトはfalse）'
# 'Four-byte version string for gcov files.'
H32782AC0D44C: 'gcovファイル用の4バイトのバージョン文字列。'
# 'Frame Data (DEBUG_S_FRAMEDATA subsection)'
H4EACA6AC6ABA: 'フレームデータ（DEBUG_S_FRAMEDATAサブセクション）'
# 'Fuchsia API Level prohibits specifying a minor or sub-minor version'
H73A16BC6357D: 'Fuchsia APIレベルでは、マイナーバージョンまたはサブマイナーバージョンの指定が禁止されています'
# 'Full version of the Windows SDK, defaults to newest found'
HD00F6CBB0217: 'Windows SDKの完全バージョン（見つかった最新バージョンが既定値）'
# 'Fully encode c++ class template specialization'
H83B6D3243278: 'C++クラステンプレートの特殊化を完全にエンコード'
# 'Fully expand the memory accesses of the detected Scops'
H41926418D084: '検出されたScopsのメモリアクセスを完全に展開します'
# 'Fully relocatable, position independent code'
H2EE1300E53E0: '完全に再配置可能な、位置独立コード'
# 'Function Alias Analysis Results'
H5E305706D9B2: '関数エイリアス分析結果'
# 'Function Entry Count'
HF80E7DCD1642: '関数エントリカウント'
# 'Function attribute to apply to cold functions as determined by PGO'
H345451AD326B: 'PGOによって決定されたcold functionsに適用する関数属性'
# 'Function entry point.'
HAD67FD8DA947: '関数エントリポイント。'
# 'Function filtering options'
H71383E432CB7: '関数フィルタリングオプション'
# 'Function level overlap information for every function (with calling context for csspgo) in test profile with max count value greater than the parameter value'
H66ADA33E3E20: 'テストプロファイルで最大カウント値がパラメータ値を超えるすべての関数（csspgoの呼び出しコンテキストを含む）の関数レベルのオーバーラップ情報'
# 'Function mem bound threshold in %'
HC48D6911C0B3: '% での関数メモリ制限閾値'
# 'Function names that are public.'
H1CBBD51F21AA: 'パブリックな関数名。'
# 'Function number to canonicalize.'
H14E5011F4FDD: '正規化する関数番号。'
# 'Function register usage analysis'
HC45FBE8F1495: '関数レジスタ使用分析'
# 'Function to call as entry point.'
H9A688E8595B8: 'エントリポイントとして呼び出す関数。'
# 'Function type.'
HC8800532CD60: '関数タイプ。'
# 'Function.'
H7375AFF85987: '関数。'
# 'Fuse FP ops whenever profitable'
H9F1BE3BC2E20: 'FP演算を有利な場合に結合'
# 'GC Lowering'
HB5C53C8FC4DB: 'GC Lowering'
# 'GCC does not allow %0 attribute in this position on a function definition'
H6258B157AA4F: 'GCCは関数定義のこの位置で%0属性を許可しません'
# 'GCC does not allow an attribute in this position on a function declaration'
H6328F86D9296: 'GCCは関数宣言のこの位置で属性を許可しません'
# 'GCC does not allow the %0 attribute to be written on a type'
HAF18361FDD0D: 'GCCはタイプに%0属性を書くことを許可しません'
# "GCC does not allow the 'cleanup' attribute argument to be anything other than a simple identifier"
HB0EE895D3D5D: "GCCは'cleanup'属性の引数を単純な識別子以外にすることは許可しません"
# 'GCC does not allow variable declarations in for loop initializers before C99'
HD212EAC451BD: 'C99より前のバージョンでは、forループ初期化子内で変数宣言はGCCで許可されません'
# 'GCC encoding (only meaningful for -sample)'
H893D2EDBC511: 'GCCエンコーディング（-sampleオプションでのみ有効）'
# 'GCC requires a function with the %0 attribute to be variadic'
H4044A123EF83: 'GCCは%0属性を持つ関数が可変長引数関数であることを要求します'
# 'GCN Create VOPD Instructions'
HD50B13295BAC: 'GCN VOPD命令生成'
# 'GCN DPP Combine'
H19E8A5665832: 'GCN DPP統合'
# 'GCN NSA Reassign'
H506D8BF350C1: 'GCN NSA再割り当て'
# 'GLIBC Vector Math library'
HFDA2A482B5C5: 'GLIBCベクターマスライブラリ'
# 'GNU OpenMP'
H7F5648C19468: 'GNU OpenMP'
# 'GNU decimal type extension not supported'
HE1719E002830: 'GNU十進数型拡張はサポートされていません'
# 'GNU vector conditional operand cannot be %select{void|a throw expression}0'
H5DF13110207F: 'GNUベクター条件付きオペランドは%select{void|スロー式}0にはできません'
# 'GNU-style inline assembly is disabled'
H2E56E6455BF0: 'GNUスタイルのインラインアセンブリは無効化されています'
# 'GNUstep Objective-C runtime version %0 incompatible with target binary format'
HBFB3FAB065B9: 'GNUstep Objective-Cランタイムバージョン%0はターゲットのバイナリ形式と互換性ありません'
# "GPU arch %0 is supported by CUDA versions between %1 and %2 (inclusive), but installation at %3 is %4; use '--cuda-path' to specify a different CUDA install, pass a different GPU arch with '--cuda-gpu-arch', or pass '--no-cuda-version-check'"
HA444373A0822: "GPUアーキテクチャ%0はCUDAバージョン%1から%2（両端含む）でサポートされていますが、%3のインストールは%4です。別のCUDAインストールを指定するには'--cuda-path'、別のGPUアーキテクチャを指定するには'--cuda-gpu-arch'、またはバージョンチェックを無効化するには'--no-cuda-version-check'を指定してください"
# 'Gang up loads and stores generated by inlining of memcpy'
HE535C0271E93: 'memcpyインライン化で生成された一括読み出し/書き込みをまとめる'
# 'Gate the invocation of the tracing callbacks on a global variable. Currently only supported for trace-pc-guard and trace-cmp.'
HE7375E04E4A1: 'トレースコールバックの呼び出しをグローバル変数で制御します。現在はtrace-pc-guardとtrace-cmpのみサポートされています'
# 'Generalize pointers in CFI indirect call type signature checks'
H05CAF1DC1C80: 'CFI間接呼び出しタイプシグネチャチェックにおけるポインタを汎用化'
# 'Generate "extract" instructions'
HC571F6794268: 'Extract命令を生成'
# 'Generate "insert" instructions'
H783E8CF7431F: 'Insert命令を生成'
# 'Generate ARM CDE builtin code-generator for clang'
H5A5EC1A5B6C3: 'ARM CDEビルトインコードジェネレータをclangに実装'
# 'Generate ARM CDE builtin definitions for clang'
H4D955CE0B09F: 'clang用ARM CDE組み込み定義を生成'
# 'Generate ARM CDE builtin sema checks for clang'
H322C3CB145B5: 'clang用ARM CDE組み込みセマ検査を生成'
# 'Generate ARM MVE builtin code-generator for clang'
H51464E4006BA: 'clang用ARM MVE組み込みコード生成器を生成'
# 'Generate ARM MVE builtin definitions for clang'
HB30829C9D62F: 'clang用ARM MVE組み込み定義を生成'
# 'Generate ARM MVE builtin sema checks for clang'
H9EB24BD38363: 'clang用ARM MVE組み込みセマ検査を生成'
# 'Generate ARM NEON sema support for clang'
HB47F65A392BE: 'clang用ARM NEONセマサポートを生成'
# 'Generate ARM NEON tests for clang'
HB3324D2A49FC: 'clang用ARM NEONテストを生成'
# 'Generate AST expressions for unmodified and modified accesses'
H729F2BA5C5BE: '修正されていないアクセスと修正されたアクセスのAST式を生成'
# 'Generate C++20 header units from header files'
H8199E8EA3A2D: 'ヘッダーファイルからC++20 ヘッダーユニットを生成'
# 'Generate CXX11 attributes info'
H008C47C9924C: 'CXX11属性情報を生成'
# 'Generate Clang AST comment nodes'
H1A2137DB81DD: 'Clang ASTコメントノードを生成します'
# 'Generate Clang AST declaration nodes'
H0D831097F249: 'Clang AST宣言ノードを生成します'
# 'Generate Clang AST statement nodes'
H9DA2A7F822D1: 'Clang ASTステートメントノードを生成します'
# 'Generate Clang AST type nodes'
H6C40DA5710E5: 'Clang ASTタイプノードを生成します'
# 'Generate Clang AbstractTypeReader class'
H0B517D2DC9BE: 'Clang AbstractTypeReaderクラスを生成します'
# 'Generate Clang AbstractTypeWriter class'
H3C1A155F700F: 'Clang AbstractTypeWriterクラスを生成します'
# 'Generate Clang BasicReader classes'
HCAC9D912FD7C: 'Clang BasicReaderクラスを生成します'
# 'Generate Clang BasicWriter classes'
H7777A854222B: 'Clang BasicWriterクラスを生成します'
# 'Generate Clang Static Analyzer checkers'
HAF44CF1570A7: 'Clang Static Analyzer チェッカを生成します'
# 'Generate Clang constexpr interpreter opcodes'
HCE00FBA3D9DA: 'Clang constexprインタプリタオペコードを生成します'
# 'Generate Clang diagnostic enums for selects'
HFF484ABCD39B: 'Clangのselect用診断enumを生成します'
# 'Generate Clang diagnostic groups'
HD491E8E3F838: 'Clang診断グループを生成します'
# 'Generate Clang diagnostic name index'
H26D83AD60FA3: 'Clang診断名インデックスを生成します'
# 'Generate Clang diagnostics definitions'
H42FB0D88C678: 'Clang診断定義を生成します'
# 'Generate CodeView debug information'
H5E04C2FAE7DA: 'CodeViewデバッグ情報を生成します'
# 'Generate DWARF4 type units.'
H93A2FEDB326C: 'DWARF4タイプユニットを生成します'
# 'Generate Extract API information as a side effect of compilation.'
H35927234EEF2: 'コンパイルの副作用としてAPI情報を抽出します'
# 'Generate IR involving scalable vector types'
HBFD721B3719E: 'スケーラブルベクタータイプを含むIRを生成します'
# 'Generate Interface Stub Files, emit merged text not binary.'
H48D6D551365C: 'Interface Stubファイルを生成（結合テキストを出力し、バイナリは出力しません）'
# 'Generate Interface Stub Files.'
H93E694C37FB8: 'Interface Stubファイルを生成します'
# 'Generate LBR info with perf itrace argument'
H63A1CBFF2B95: 'perf itrace引数を使用してLBR情報を生成'
# 'Generate M NOPs before function entry'
H411052747AED: '関数エントリ直前にM NOPを生成'
# 'Generate M NOPs before function entry and N-M NOPs after function entry'
HCAAC0B0CBF62: '関数エントリ直前にM NOPを生成し、エントリ後にはN-M NOPを生成'
# 'Generate Metal library'
H30181B8F806A: 'Metalライブラリを生成'
# 'Generate Offload API header contents'
H228CB18FCD9A: 'オフロードAPIのヘッダ内容を生成'
# 'Generate Offload API print header'
HDB1F685BA2FE: 'オフロードAPIのプリントヘッダを生成'
# 'Generate Offload API wrapper function definitions'
HE6C5D6F8A8FB: 'オフロードAPIのラッパー関数定義を生成'
# 'Generate OpenCL builtin declaration handlers'
HA18DDE5AEDF3: 'OpenCLビルトイン宣言ハンドラを生成'
# 'Generate OpenCL builtin declaration tests'
H5DAE86CEEBCA: 'OpenCLビルトイン宣言テストを生成'
# 'Generate OpenCL builtin header'
H2590CD761606: 'OpenCLビルトインヘッダを生成'
# 'Generate SPIR-V code'
HC1B38B428E45: 'SPIR-Vコードを生成'
# 'Generate Scalar MASS entries'
H428973D80E2B: 'スカラMASSエントリを生成'
# 'Generate XRay instrumentation sleds on function entry and exit'
H3016D234FBA9: '関数エントリとエグジットでXRayインストルメンテーションスレッドを生成'
# 'Generate a .mlir reproducer file at the given output path if the pass manager crashes or fails'
HBC83C0234127: 'パスマネージャがクラッシュまたは失敗した場合、指定された出力パスに.mlir再現ファイルを生成'
# 'Generate a YAML optimization record file'
H1942B716CF27: 'YAML最適化記録ファイルを生成'
# 'Generate a __mcount_loc section entry for each __fentry__ call.'
HE460D06CF31F: '各__fentry__コールに対して__mcount_locセクションエントリを生成する'
# 'Generate a clang attribute list'
H89A583ECD8F5: 'clang属性リストを生成'
# 'Generate a clang attribute spelling index'
HE19534D90FCA: 'clang属性スペルインデックスを生成'
# 'Generate a clang attribute spelling list'
H4F8740D65FE7: 'clang属性スペルリストを生成'
# 'Generate a clang attribute subject match rule list'
HC95A81873DA9: 'clang属性サブジェクトマッチ規則リストを生成'
# 'Generate a clang parsed attribute kinds'
H78888371BD55: 'clangが解析した属性の種類を生成します'
# 'Generate a clang parsed attribute list'
HD97B596A50F3: 'clangが解析した属性のリストを生成します'
# 'Generate a clang template instantiate code'
H961D4AD666CA: 'clangのテンプレートインスタンテーションコードを生成します'
# 'Generate a list of all Offload API function names'
H3DB190C217E7: 'すべてのオフロードAPI関数名のリストを生成します'
# 'Generate a list of attributes supported by #pragma clang attribute for testing purposes'
HE3D52A2C4CA9: 'テスト目的で#pragma clang attributeでサポートされる属性のリストを生成します'
# 'Generate a list of regular keyword attributes with info about their arguments'
H86F657FC95B7: '引数に関する情報と共に通常のキーワード属性のリストを生成します'
# 'Generate a partial profile (only meaningful for -extbinary)'
H8B3C403992F1: '部分的なプロファイルを生成します（-extbinaryでのみ意味があります）'
# 'Generate a pch file for all code up to and including <filename>'
H3A6818A5EE16: '<filename>を含むすべてのコードのpchファイルを生成します'
# 'Generate a recursive AST visitor for clang attributes'
HD2CD27931B90: 'clang属性のための再帰的なAST訪問者を生成します'
# 'Generate a sparse profile (only meaningful for -instr)'
H2390B2DEB1A2: 'スパースプロファイルを生成します（-instrでのみ意味があります）'
# 'Generate a table of attribute documentation'
H4075E225B4D0: '属性のドキュメントテーブルを生成します'
# 'Generate absolute set instructions'
HD09B902A76CD: '絶対設定命令を生成します'
# 'Generate additional symbol graphs for extended modules.'
H621EAE5CB426: '拡張モジュールのための追加シンボルグラフを生成します'
# 'Generate all instruction with TC'
HCB4E103EFF3E: 'TCを使用したすべての命令を生成します'
# 'Generate all parser-related attribute string switches'
HBC7D18EAD0C4: 'すべてのパーサ関連の属性文字列スイッチを生成します'
# 'Generate all parser-related attribute subject match rulestring switches'
H3DDA6CE234B8: 'すべてのパーサ関連の属性サブジェクトマッチルール文字列スイッチを生成します'
# 'Generate all reports.'
H56F361794B7A: 'すべてのレポートを生成します'
# 'Generate an mlir reproducer at the provided filename (no crash required)'
HEF652CF84C8A: '指定されたファイル名でmlir再現ファイルを生成します（クラッシュ不要）'
# 'Generate an optimization record file in a specific format'
H93DDC23AE075: '特定の形式での最適化記録ファイルを生成します'
# 'Generate an optimized version of the match table'
HB99621634FE9: '一致テーブルの最適化されたバージョンを生成します'
# 'Generate any type of IT block'
H3521C624C6E3: 'IT ブロックの生成'
# 'Generate arm_bf16.h for clang'
H4049A4CCEEB2: 'clang用のarm_bf16.hを生成します'
# 'Generate arm_cde.h for clang'
H20C9AE949999: 'clang用のarm_cde.hを生成します'
# 'Generate arm_fp16.h for clang'
HA003409EA627: 'clang用のarm_fp16.hを生成します'
# 'Generate arm_immcheck_types.inc (immediate range check types) for clang'
H3E399A3BC5ED: 'clang用のarm_immcheck_types.inc（即値範囲チェックタイプ）を生成します'
# 'Generate arm_mve.h for clang'
H9B02FDBF61FE: 'clang用のarm_mve.hを生成します'
# 'Generate arm_neon.h for clang'
HBC7A4B2C0607: 'clang用のarm_neon.hを生成します'
# 'Generate arm_sme.h for clang'
HE4D6EF6670EF: 'clang用のarm_sme.hを生成します'
# 'Generate arm_sme_builtin_cg_map.inc for clang'
H9942231BE658: 'clang用のarm_sme_builtin_cg_map.incを生成します'
# 'Generate arm_sme_builtins.inc for clang'
HB5A0445595D2: 'clang用のarm_sme_builtins.incを生成します'
# 'Generate arm_sme_builtins_za_state.inc for clang'
H1A92D0667981: 'clang用のarm_sme_builtins_za_state.incを生成します'
# 'Generate arm_sme_sema_rangechecks.inc for clang'
H934D5C9C551E: 'clang用のarm_sme_sema_rangechecks.inc（セマンティクス範囲チェック）を生成します'
# 'Generate arm_sme_streaming_attrs.inc for clang'
HB0ACDD97739D: 'clang用のarm_sme_streaming_attrs.incを生成します'
# 'Generate arm_sve.h for clang'
HA4A04F03FE49: 'clang用のarm_sve.hを生成します'
# 'Generate arm_sve_builtin_cg_map.inc for clang'
H85004239686F: 'clang用のarm_sve_builtin_cg_map.incを生成します'
# 'Generate arm_sve_builtins.inc for clang'
H521827D71962: 'clang用のarm_sve_builtins.incを生成します'
# 'Generate arm_sve_sema_rangechecks.inc for clang'
H7845A0DBDBD3: 'clang用のarm_sve_sema_rangechecks.inc（セマンティクス範囲チェック）を生成します'
# 'Generate arm_sve_streaming_attrs.inc for clang'
H0E1FDBC6C09B: 'clang用のarm_sve_streaming_attrs.incを生成します'
# 'Generate arm_sve_typeflags.inc for clang'
HACE26ADDC9C9: 'clang用のarm_sve_typeflags.incを生成します'
# 'Generate arm_vector_types.h for clang'
H7C1E9F56F891: 'clang用のarm_vector_types.hを生成します'
# 'Generate attribute documentation'
H5EECEC688125: '属性ドキュメントを生成する'
# 'Generate attributes for this dialect'
HE3FD9C3103CA: 'この方言用の属性を生成する'
# 'Generate bitsplit instructions'
HE0B4AD43ABB0: 'ビットスプリット命令を生成する'
# 'Generate branches with extended addressability, usually via indirect jumps.'
H84AA69F9BF2B: '拡張アドレス指定機能を有する分岐を生成（通常は間接ジャンプを介して）'
# 'Generate calls to instrument function entry and exit'
HFC18B10AD85D: '関数のエントリとエグジットを監視するための呼び出しを生成する'
# 'Generate clang PCH attribute reader'
HACB0FB3DEE14: 'clang PCH属性リーダーを生成する'
# 'Generate clang PCH attribute writer'
H0829BFECBA6A: 'clang PCH属性ライターを生成する'
# 'Generate clang attribute clases'
HCAA1C36C6E17: 'clang属性クラスを生成する'
# 'Generate clang attribute implementations'
H58D8D7EF6BF7: 'clang属性の実装を生成する'
# 'Generate clang attribute text node dumper'
H7B79A1565130: 'clang属性テキストノードダンパを生成する'
# 'Generate clang attribute traverser'
H82452D8DFFBB: 'clang属性トラバーサーを生成する'
# 'Generate clang builtins list'
H7DD3DD5CD09E: 'clangビルトイン関数リストを生成する'
# 'Generate code for CUDA device'
H28657BCC831E: 'CUDAデバイス用のコードを生成する'
# 'Generate code for SYCL device.'
HFDECAC3EE76F: 'SYCLデバイス用のコードを生成する'
# 'Generate code for an additional runtime variant of the deployment target'
HC009196F06DE: '配備ターゲットの追加ランタイムバリアント用のコードを生成する'
# 'Generate code for statically linking libclosure (BlocksRuntime)'
H655EBC8C95D8: 'libclosure（BlocksRuntime）を静的リンクするためのコードを生成する'
# 'Generate code for the given target'
H978948BBCF74: '指定されたターゲット用のコードを生成する'
# 'Generate code for uses of this PCH that assumes an explicit object file will be built for the PCH'
H73D5D7524BBC: 'このPCHを使用する際、明示的なオブジェクトファイルをPCHと共に生成することを想定したコードを生成する'
# 'Generate code for uses of this module that assumes an explicit object file will be built for the module'
H0A914343419E: 'このモジュールを使用する際、明示的なオブジェクトファイルをモジュールと共に生成することを想定したコードを生成する'
# 'Generate code only for an OpenMP target device.'
H22275002B232: 'OpenMPターゲットデバイス専用のコードを生成する'
# 'Generate code which only uses the general purpose registers (AArch64/x86 only)'
HE13BDFDB4618: '汎用レジスタのみを使用するコードを生成 (AArch64/x86 対象のみ)'
# 'Generate command properties for commands that are used in documentation comments'
HDF34DF8FD98C: 'ドキュメンテーションコメントで使用されるコマンドのプロパティを生成'
# 'Generate coverage instrumentation for GlobalISel'
H98DAD8E8562B: 'GlobalISel のためのカバレッジ instrumentation を生成'
# 'Generate coverage mapping to enable code coverage analysis'
H3FA8EAFBA329: 'コードカバレッジ分析を有効にするためのカバレッジ マッピングを生成'
# 'Generate data collectors for AST nodes'
HB676E426CC9E: 'AST ノード用のデータ収集器を生成'
# 'Generate debug info for types in an object file built from this PCH and do not generate them elsewhere'
H2C592F95A21D: 'この PCH から作成したオブジェクトファイルの型用のデバッグ情報を生成し、他の場所では生成しない'
# 'Generate debug info for types in an object file built from this module and do not generate them elsewhere'
HE7EB6B773956: 'このモジュールから作成したオブジェクトファイルの型用のデバッグ情報を生成し、他の場所では生成しない'
# 'Generate debug info with external references to clang modules or precompiled headers'
HAD4093E5621B: 'clang モジュールまたは事前コンパイル済みヘッダーへの外部参照を含むデバッグ情報を生成'
# 'Generate debugging info in the 64-bit DWARF format'
H70C04792FFA2: '64ビット DWARF 形式のデバッグ情報を生成'
# 'Generate declarations for Offload API implementation functions'
H36074FE5A628: 'オフロード API 実装関数の宣言を生成'
# 'Generate definitions of Clang Syntax Tree node clasess'
H83004344D792: 'Clang シンタックスツリー ノードクラスの定義を生成'
# 'Generate diagnostic documentation'
H376A46B39692: '診断ドキュメンテーションを生成'
# 'Generate directives for this dialect'
HF8CA4ECC7825: 'この方言用のディレクティブを生成'
# 'Generate dot files into specified directory for changed IRs'
HD4CB202E81D5: '変更された IR 用に指定されたディレクトリに dot ファイルを生成'
# 'Generate dwarf aranges'
H6F048344D108: 'dwarf aranges を生成'
# 'Generate dwarf debugging info for assembly source files'
H5645E7139B8A: 'アセンブリソースファイル用の DWARF デバッグ情報を生成'
# 'Generate efficient matchers for HTML tag names that are used in documentation comments'
H20BDF8097FEE: 'ドキュメンテーションコメントで使用される HTML タグ名のための効率的なマッチャーを生成'
# 'Generate efficient matchers for HTML tag properties'
H7F720B1F0148: 'HTML タグプロパティのための効率的なマッチャーを生成'
# 'Generate explicit import from anonymous namespace to containing scope'
HAFE44C2C60BD: '匿名名前空間から包含スコープへの明示的なインポートを生成'
# 'Generate export file for the Offload library'
H1A8F89282970: 'オフロード ライブラリのエクスポートファイルを生成'
# 'Generate extract instructions'
HABD4DCD38172: '抽出命令を生成'
# 'Generate function to translate named character references to UTF-8 sequences'
H2212027837CC: '名前付き文字参照をUTF-8シーケンスに変換する関数を生成'
# 'Generate hot text symbols. Apply this option to a precompiled binary that manually calls into hugify, such that at runtime hugify call will put hot code into 2M pages. This requires relocation.'
HE07FCEA6613B: 'ホットテキストシンボルを生成。hugifyに手動で呼び出すプリコンパイル済みバイナリにこのオプションを適用すると、実行時にhugifyコールがホットコードを2Mページに配置します。リロケーションが必要です。'
# 'Generate instrumented code to collect context sensitive execution counts into <directory>/default.profraw (overridden by LLVM_PROFILE_FILE env var)'
H10A2DF54F49A: 'コンテキスト依存の実行カウントを集計するためのインストゥルメンテーションされたコードを生成し、<directory>/default.profraw に格納します（LLVM_PROFILE_FILE環境変数で上書きされます）'
# 'Generate instrumented code to collect context sensitive execution counts into default.profraw (overridden by LLVM_PROFILE_FILE env var)'
HCBAB6F9C9B4D: 'コンテキスト依存の実行カウントを集計するためのインストゥルメンテーションされたコードを生成し、default.profraw に格納します（LLVM_PROFILE_FILE環境変数で上書きされます）'
# 'Generate instrumented code to collect coverage info for cold functions into <directory>/default.profraw (overridden by LLVM_PROFILE_FILE env var)'
H389023BECF0C: 'コールド関数のカバレッジ情報を収集するためのインストゥルメンテーションされたコードを生成し、<directory>/default.profraw に格納します（LLVM_PROFILE_FILE環境変数で上書きされます）'
# "Generate instrumented code to collect coverage info for cold functions into default.profraw file (overridden by '=' form of option or LLVM_PROFILE_FILE env var)"
H40F8D1777D6C: "コールド関数のカバレッジ情報を収集するためのインストゥルメンテーションされたコードを生成し、default.profraw ファイルに格納します（('=')形式のオプションまたはLLVM_PROFILE_FILE環境変数で上書きされます）"
# 'Generate instrumented code to collect execution counts into <directory>/default.profraw (overridden by LLVM_PROFILE_FILE env var)'
H884AE4DB8A23: '実行カウントを集計するためのインストゥルメンテーションされたコードを生成し、<directory>/default.profraw に格納します（LLVM_PROFILE_FILE環境変数で上書きされます）'
# 'Generate instrumented code to collect execution counts into <file> (overridden by LLVM_PROFILE_FILE env var)'
HF1CDB71BC3BA: '実行カウントを集計するためのインストゥルメンテーションされたコードを生成し、<file> に格納します（LLVM_PROFILE_FILE環境変数で上書きされます）'
# 'Generate instrumented code to collect execution counts into default.profraw (overridden by LLVM_PROFILE_FILE env var)'
HEDA64E6D9E58: '実行カウントを集計するためのインストゥルメンテーションされたコードを生成し、default.profraw に格納します（LLVM_PROFILE_FILE環境変数で上書きされます）'
# "Generate instrumented code to collect execution counts into default.profraw file (overridden by '=' form of option or LLVM_PROFILE_FILE env var)"
HCED0768BDFD7: "実行カウントを集計するためのインストゥルメンテーションされたコードを生成し、default.profraw ファイルに格納します（('=')形式のオプションまたはLLVM_PROFILE_FILE環境変数で上書きされます）"
# 'Generate instrumented code to collect temporal information'
H454449192474: '一時情報を収集するためのインストゥルメンテーションされたコードを生成'
# 'Generate intrinsics with this target prefix'
H5CEC7C3808CA: 'このターゲットプレフィックスを使用した組み込み関数を生成'
# 'Generate invalid output'
H668CF0E474FA: '無効な出力を生成'
# 'Generate list of Clang Syntax Tree node types'
H3A9E31163210: 'Clang構文木ノードタイプの一覧を生成'
# 'Generate list of commands that are used in documentation comments'
H55166381B0A4: 'ドキュメンテーションコメントで使用されるコマンドの一覧を生成'
# 'Generate list of valid ARM CDE builtin aliases for clang'
H1E92420752F1: 'clang用のARM CDEビルトインエイリアスの一覧を生成'
# 'Generate list of valid ARM MVE builtin aliases for clang'
H18CC5313A2F6: 'clang用のARM MVEビルトインエイリアスの一覧を生成'
# 'Generate lldb option definitions'
HF07E69C59A11: 'lldbオプション定義を生成'
# 'Generate lldb property definitions'
HBD76019A4518: 'lldbプロパティ定義を生成'
# 'Generate lldb property enum definitions'
H4D3EB8680DC4: 'LLDBプロパティenum定義を生成します'
# 'Generate load-load barrier instructions (dbar 0x700)'
HB092D2DF4B79: 'ロード-ロード バリア命令(dbar 0x700)を生成します'
# 'Generate local calls to out-of-line atomic operations'
H160B36160D89: '行外のアトミック演算に対するローカル呼び出しを生成します'
# 'Generate loop nest for tiling.'
H40BB5343F902: 'タイリング用のループネストを生成します'
# 'Generate low-precision inline sequences for some float libcalls'
HA2542185A00F: '一部のfloatライブラリコール用の低精度インラインシーケンスを生成します'
# 'Generate machine code, but discard output'
HA74064264324: 'マシンコードを生成するが、出力を破棄します'
# 'Generate mcount/__fentry__ calls as nops. To activate they need to be patched in.'
HE3A927985452: 'mcount/__fentry__コールをnopとして生成します。有効にするにはパッチを適用する必要があります。'
# 'Generate nested function profiles for CSSPGO'
H267DA13728E4: 'CSSPGO用のネスト関数プロファイルを生成します'
# 'Generate option documentation'
HF1C9A7ED3825: 'オプションのドキュメントを生成します'
# 'Generate output compatible with the standard GNU Objective-C runtime'
H0A3E1D413F6F: '標準のGNU Objective-Cランタイムと互換性のある出力を生成します'
# 'Generate pre-compiled header file'
H6076A415050D: 'プリコンパイル済みヘッダーファイルを生成します'
# 'Generate pre-compiled module file from a module map'
H32E4ACE09217: 'モジュールマップからプリコンパイル済みモジュールファイルを生成します'
# 'Generate pre-compiled module file from a standard C++ module interface unit'
H332BF5CFA1C0: '標準C++モジュールインターフェースユニットからプリコンパイル済みモジュールファイルを生成します'
# 'Generate random hotness values'
H5B6B1D07D43D: 'ランダムなホットネス値を生成します'
# 'Generate read-only position independent code (ARM only)'
H8619C4BF8421: '読み取り専用の位置独立コード(ARM専用)を生成します'
# 'Generate read-write position independent code (ARM only)'
H49DE9A8DC6D7: '読み書き可能な位置独立コード(ARM専用)を生成します'
# 'Generate reduced prebuilt module interface from a standard C++ module interface unit'
HBCD3850127B9: '標準C++モジュールインターフェースユニットから簡略化されたプリビルドモジュールインターフェースを生成します'
# 'Generate relocatable device code, also known as separate compilation mode'
H2AB415613F7B: 'リロケータブルデバイスコード（別名：別コンパイルモード）を生成します'
# 'Generate riscv_sifive_vector_builtin_cg.inc for clang'
H2F882B6DED2D: 'clang用のriscv_sifive_vector_builtin_cg.incを生成します'
# 'Generate riscv_sifive_vector_builtin_sema.inc for clang'
HD872420A09E4: 'clang用のriscv_sifive_vector_builtin_sema.incを生成します'
# 'Generate riscv_sifive_vector_builtins.inc for clang'
HD182FA023D72: 'clang用のriscv_sifive_vector_builtins.incを生成します'
# 'Generate riscv_vector.h for clang'
HECE8F71BFB56: 'clang用のriscv_vector.hを生成します'
# 'Generate riscv_vector_builtin_cg.inc for clang'
H5A79CE9F1F74: 'clang用のriscv_vector_builtin_cg.incを生成します'
# 'Generate riscv_vector_builtin_sema.inc for clang'
HA3230378A26C: 'clang用のriscv_vector_builtin_sema.incを生成します'
# 'Generate riscv_vector_builtins.inc for clang'
H5D02D25DD210: 'clang用のriscv_vector_builtins.incを生成します'
# 'Generate software floating point library calls'
H05167BC54E72: 'ソフトウェア浮動小数点ライブラリ呼び出しを生成します'
# 'Generate source-level debug information'
HAEF3BF8D74CD: 'ソースレベルデバッグ情報を生成します'
# 'Generate source-level debug information with dwarf version 2'
HD2B80CB88FC9: 'DWARFバージョン2を使用してソースレベルデバッグ情報を生成します'
# 'Generate source-level debug information with dwarf version 3'
HA4075062488F: 'DWARFバージョン3を使用してソースレベルデバッグ情報を生成します'
# 'Generate source-level debug information with dwarf version 4'
H248AE385BE0D: 'DWARFバージョン4を使用してソースレベルデバッグ情報を生成します'
# 'Generate source-level debug information with dwarf version 5'
HE4BA3B14D0D7: 'DWARFバージョン5を使用してソースレベルデバッグ情報を生成します'
# 'Generate source-level debug information with the default dwarf version'
H938AF5B9960A: 'デフォルトのDWARFバージョンを使用してソースレベルデバッグ情報を生成します'
# 'Generate the clang parsed attribute helpers'
HFA9E86870CB2: 'clangの解析済み属性ヘルパーを生成します'
# 'Generate the profile for Linux kernel binary.'
HB596668CB82B: 'Linuxカーネルのバイナリ用のプロファイルを生成します'
# 'Generate the reduced BMI'
HED698C3C66EE: 'Reduced BMIを生成します'
# 'Generate thread parallel code (isl codegen only)'
H34625E399986: 'スレッド並列コードを生成（ isl コードジェネレーターのみ）'
# 'Generate types for this dialect'
H62C541A61A79: 'この方言用の型を生成します'
# 'Generate unique debug info for each instruction with a memory operand. Should be enabled for profile-driven cache prefetching, both in the build of the binary being profiled, as well as in the build of the binary consuming the profile.'
H337DAB1315D8: 'メモリオペランドを伴う各命令に対して一意のデバッグ情報を生成します。プロファイル駆動型キャッシュプレフェッチには、プロファイリング対象のバイナリのビルド時だけでなく、プロファイルを利用するバイナリのビルド時にも有効にする必要があります'
# 'Generate unoptimized CFGs for all analyses'
HA85B8A701BAB: 'すべての解析用の最適化されていないCFGを生成します'
# 'Generate unwinding tables for all functions'
HF1490D883AAC: 'すべての関数用のアンワインディングテーブルを生成します'
# 'Generate verbose assembly output'
H0B7F9E41E63B: '詳細なアセンブリ出力を生成します'
# 'Generated inlined abstract references.'
H21A52BEF39EC: 'インライン抽象参照が生成されました'
# 'Generates tables to help identify patterns matched'
HD3439779FA7F: '一致したパターンを特定するのに役立つテーブルを生成します'
# 'Generator to run'
H9B18D7EC4146: '実行するジェネレーター'
# 'Generic Options'
H5EEF255AAE70: '汎用オプション'
# 'Generic memory optimizations'
H800F1622EB9A: '汎用メモリ最適化'
# 'Get the symbol definition from <line> <start-column> <end-column>'
H9C96E5C80114: '指定された行、開始列、終了列からシンボルの定義を取得します'
# 'Give each function an independent TBAA tree (default)'
H7A952E99A7FC: '各関数に独立したTBAAツリーを割り当てます（既定値）'
# 'Give global C++ operator new and delete declarations hidden visibility'
HAD504B33021E: 'グローバルなC++のoperator newおよびdelete宣言に非表示の可視性を割り当てます'
# "Give global types 'default' visibility and global functions and variables 'hidden' visibility by default"
H095BFBCE25DF: 'グローバルな型には"default"可視性、グローバルな関数および変数には"hidden"可視性を既定で割り当てます'
# 'Give inline C++ member functions hidden visibility by default'
HAF1CF839FC8A: 'インラインC++メンバ関数に既定で非表示の可視性を割り当てます'
# 'Give the maximum number of instructions that we will use for creating a floating-point immediate value'
HB7780EA795D5: '浮動小数点即時値を作成するために使用する命令の最大数を指定します'
# 'Give the maximum size (in number of nodes) of the web of instructions that we will consider for VW expansion'
H6AD97D209EFA: 'VW展開の対象とする命令のネットワークの最大サイズ（ノード数）を指定します'
# 'Give unique names to every basic block section'
HE9E6E34AE2B8: '基本ブロックセクションの各セクションに一意の名前を割り当てます'
# 'Give unique names to every section'
HAE1CB86AEAE6: '各セクションに一意の名前を割り当てます'
# 'Global Pointer Addressing Size.  The default size is 8.'
H7DA66DD4C059: 'グローバルポインターアドレッシングサイズ。既定のサイズは8です'
# 'Global Value Numbering'
H7BB46D78F883: 'グローバルバリューナンバリング'
# 'Global merge function pass'
H22AF90C7A55F: 'グローバルマージ関数パス'
# 'GlobalISel Combiner'
H204136E4EB5C: 'GlobalISelコンビナー'
# 'Globally set the denormals-are-zero (DAZ) and flush-to-zero (FTZ) bits in the floating-point control register on program startup'
H3BA6F3373251: 'プログラム起動時に浮動小数点制御レジスタのdenormals-are-zero (DAZ)およびflush-to-zero (FTZ)ビットをグローバルに設定します'
# 'Globals Alias Analysis'
H9A682873774C: 'グローバルの別名解析'
# 'Good Bye World Pass'
H6716A126CB42: 'Good Bye World パス'
# 'Gradient gain threshold (%).'
H28D3EF05A6AB: '勾配ゲイン閾値（％）。'
# 'Greedy Register Allocator'
HB8463656EACF: 'グレイディアス レジスタ アロケータ'
# 'Greedy register allocator'
HE2214CA75FBC: 'グレイディアス レジスタ アロケータ'
# 'Guard UBSAN checks with `llvm.allow.ubsan.check()`.'
H368DFFFB3230: 'UBSANチェックは `llvm.allow.ubsan.check()` で保護されます。'
# 'Guard against compiler/runtime version mismatch.'
HA3897596A344: 'コンパイラ/ランタイムのバージョン不一致を防止する'
# 'Guided scheduling'
H4B9648519786: 'ガイド付きスケジューリング'
# 'HIP Standard Parallel Algorithm Acceleration library path, used for finding and implicitly including the library header'
H8403B00ECFB8: 'HIP標準並列アルゴリズム加速ライブラリのパス。ライブラリのヘッダーを見つけて暗黙的に含めるために使用されます'
# 'HIP device library'
H14BC304940A6: 'HIPデバイスライブラリ'
# 'HIP does not support OpenMP target directives; directive has been ignored'
H0DF90C6E349C: 'HIPはOpenMPターゲットディレクティブをサポートしていません。ディレクティブは無視されました'
# 'HIP runtime installation path, used for finding HIP version and adding HIP include path.'
HD2A8F00A760F: 'HIPランタイムのインストールパス。HIPバージョンの検出とHIPインクルードパスの追加に使用されます'
# 'HIP version in the format of major.minor.patch'
H4C1B608415FC: 'HIPバージョンは「メジャーバージョン.マイナーバージョン.パッチ」形式で指定します'
# 'HLSL Version'
HB3FA8D10C87C: 'HLSL バージョン'
# "HLSL code generation is unsupported for target '%0'"
HE92A9C826849: "ターゲット '%0' ではHLSLコード生成がサポートされていません"
# 'HLSL only. Disables all standard includes containing non-native compiler types and functions.'
H1F13E0FA5ECA: 'HLSL専用。ネイティブでないコンパイラ型や関数を含むすべての標準インクルードを無効にします'
# 'HLSL resource needs to have [[hlsl::resource_class()]] attribute'
HAC100FF02618: 'HLSLリソースには[[hlsl::resource_class()]]属性が必要です'
# "HTML end tag '%0' is forbidden"
H685A0F5F60EA: "HTML終了タグ '%0' は禁止されています"
# 'HTML end tag does not match any start tag'
H04F1BAAABD62: 'HTML終了タグは開始タグと一致しません'
# 'HTML output'
H9222F90CA7BE: 'HTML出力'
# "HTML start tag '%0' closed by '%1'"
H5D28040DFF0A: "HTML開始タグ'%0'は'%1'で閉じられました"
# "HTML start tag prematurely ended, expected attribute name or '>'"
HB396911AC86C: "HTML開始タグが予期せず終了、属性名または'>'が必要です"
# "HTML tag '%0' requires an end tag"
HC3A525011E51: "HTMLタグ'%0'には終了タグが必要です"
# 'HTML tag started here'
H3CB5C9051AF3: 'ここからHTMLタグが開始されました'
# 'HWASan shadow mapping dynamic offset location'
H0D34082EDF7B: 'HWASan シャドウマッピング動的オフセット位置'
# 'HWASan shadow mapping offset [EXPERIMENTAL]'
H2991A813E596: 'HWASan シャドウマッピングオフセット [実験的]'
# 'Handle <= and >= in finite loops'
H5AA1FAB9586D: '有限ループでの <= および >= の処理'
# 'Handle C++ exceptions (insert cleanup blocks for unwinding)'
H250354C717B0: 'C++例外の処理（アンワインディング用クリーンアップブロックの挿入）'
# 'Handle C++ initializer order'
HC63CC32922AA: 'C++初期化子順序の処理'
# 'Handle global objects'
H5D8738E4497F: 'グローバルオブジェクトの処理'
# 'Handle stack memory'
H9B9B06338F2E: 'スタックメモリの処理'
# 'Hard float ABI (uses FP registers)'
HEEAB4CE3F0BA: 'ハードフロートABI（FPレジスタを使用）'
# 'Hard-coded mapping'
H6EC79E37D2B2: '固定マッピング'
# 'Harden indirect calls and jumps against using speculatively stored attacker controlled addresses. This is designed to mitigate Spectre v1.2 style attacks.'
H64FF4BC73D36: '予測実行で保存された攻撃者コントロールアドレスを使用した間接コールとジャンプを強化。Spectre v1.2方式の攻撃を軽減するための設計です'
# 'Harden inline assembly code that may be vulnerable to Load Value Injection (LVI). This feature is experimental.'
H9EF1510D3F11: 'Load Value Injection (LVI)に脆弱な可能性のあるインラインアセンブリコードを強化。この機能は実験的です'
# 'Harden interprocedurally by passing our state in and out of functions in the high bits of the stack pointer.'
HD67DA497275B: '関数の高ビットを通じてスタックポインタの上位ビットに状態を渡すことで相互プロシージャ的に強化'
# 'Harden the value loaded *after* it is loaded by flushing the loaded bits to 1. This is hard to do in general but can be done easily for GPRs.'
HC7A0E024F604: '読み込んだ後の値を強化するため読み出したビットを1にフラッシュ。一般的には困難だがGPRでは容易に実装可能'
# 'Hardware Loop Insertion'
HD9C10B054698: 'ハードウェアループ挿入'
# 'Hardware multiplier use mode for MSP430'
HE8A05395F9BD: 'MSP430のハードウェアマルチプライヤ使用モード'
# 'Hash long pathnames'
H2984D386D5E0: '長いパス名のハッシュ化'
# 'Hazard size for streaming mode memory accesses. 0 = disabled.'
H4C73818D60FE: 'ストリーミング モードのメモリ アクセス用のハザード サイズ。0 = 無効'
# 'Heatmap options'
H6D36D04383CD: 'ヒートマップ オプション'
# 'Helps find bugs by verifying the IR whenever we emit new instructions (*very* expensive).'
H92F16AA997F0: '新しい命令を生成するたびにIRを検証することでバグを特定するのに役立ちます（*非常に* 高価な処理です）'
# 'Heuristics-based inliner version'
H91CCDBD88F85: 'ヒューリスティクスに基づくインライン化バージョン'
# 'Hexagon Branch Relaxation'
HE56E26D71726: 'Hexagon ブランチ リラクセーション'
# 'Hexagon CFG Optimizer'
HADEAF8F4224F: 'Hexagon コントロール フロー グラフ最適化'
# 'Hexagon Common GEP'
H7416FD0F0215: 'Hexagon コモン GEP'
# 'Hexagon Constant Propagation'
H4545D96F56E6: 'Hexagon 定数伝播'
# 'Hexagon Copy-To-Combine Pass'
HA9D6C5272766: 'Hexagon コピーから結合 パス'
# 'Hexagon DAG->DAG Pattern Instruction Selection'
H8C61F3028012: 'Hexagon DAG→DAG パターン命令選択'
# 'Hexagon Expand Condsets'
H77C9EE5ECE10: 'Hexagon Condsets 展開'
# 'Hexagon Generate Load/Store Set Absolute Address Instruction'
HDCC2529025E3: 'Hexagon ロード/ストア セット絶対アドレス命令生成'
# 'Hexagon Hardware Loops'
H430E0FA91788: 'Hexagon ハードウェア ループ'
# 'Hexagon Hardware Loops Fixup'
HEBB89CCF449D: 'Hexagon ハードウェア ループ 修正'
# 'Hexagon Load Widening'
H629EAC297715: 'Hexagon ロード 幅拡大'
# 'Hexagon Loop Rescheduling'
H9B5F9E54FF64: 'Hexagon ループ 再スケジューリング'
# 'Hexagon LoopAlign pass'
H079823890488: 'Hexagon ループアライン パス'
# 'Hexagon NewValueJump'
HD050A64FD350: 'Hexagon NewValueJump'
# 'Hexagon Packetizer'
HD80045280EC2: 'Hexagon パケット化'
# 'Hexagon Peephole'
H96F1818D0A76: 'Hexagon ピープホール 最適化'
# 'Hexagon RDF optimizations'
H0E48883DC0AC: 'Hexagon RDF 最適化'
# 'Hexagon Split Const32s and Const64s'
HE37A260C9D82: 'Hexagon Const32s と Const64s の分割'
# 'Hexagon Split Double Registers'
H6CA85CE5559C: 'Hexagon ダブル レジスタの分割'
# 'Hexagon Store Widening'
H23CE261CD27B: 'Hexagon ストア幅拡張'
# 'Hexagon TFR Cleanup'
H6ECA189DB2DB: 'Hexagon TFR クリーンアップ'
# 'Hexagon Vector Combine'
H9F8DB4B385EA: 'Hexagon ベクタ コンビネーション'
# 'Hexagon VectorPrint pass'
H540A5ECB5448: 'Hexagon VectorPrint パス'
# 'Hexagon bit simplification'
HF73F7F5D57C5: 'Hexagon ビット単位の単純化'
# 'Hexagon call frame information'
H93CA35321D07: 'Hexagon コール フレーム情報'
# 'Hexagon constant-extender optimization'
H1C0F5065601C: 'Hexagon 定数拡張 最適化'
# 'Hexagon early if conversion'
H5C9514E28A85: 'Hexagon 早期 if 変換'
# 'Hexagon generate "extract" instructions'
H7636CC8F55F3: 'Hexagon "extract" 指令の生成'
# 'Hexagon generate "insert" instructions'
H3778EAC02853: 'Hexagon "insert" 指令の生成'
# 'Hexagon generate mux instructions'
H5C45CA2F85F2: 'Hexagon mux 指令の生成'
# 'Hexagon generate predicate operations'
H40F613387EB4: 'Hexagon 予測子操作の生成'
# 'Hexagon mask'
HEEBCEB3469AC: 'Hexagon マスク'
# 'Hexagon move phi copy'
HDCDB2AA0AED1: 'Hexagon phi コピー移動'
# 'Hexagon optimize vextract'
H278043636EF5: 'Hexagon vextract の最適化'
# 'Hexagon-specific predictive commoning for HVX vectors'
H536F10F1AEBD: 'Hexagon 専用の HVX ベクタ予測共通化'
# 'Hide blocks with relative frequency below the given value'
H3675151E5C00: '指定された値以下の相対頻度を持つブロックを非表示にする'
# 'Hide nodes with more predecessor/successor than cutoff'
HBFFDABE2C9B6: '閾値を超える前駆ノード/後続ノードを持つノードを非表示にする'
# 'High level execution tracing'
HEC0DB93568EB: '高レベルの実行トレース'
# 'High level qualifier for z/OS C++RT side deck datasets'
HAA6C6806CE9D: 'z/OS C++RTサイドデッキデータセットの高レベル限定符'
# 'High level qualifier for z/OS CSSLIB dataset'
H3CB003A4AC08: 'z/OS CSSLIBデータセットの高レベル限定符'
# 'High level qualifier for z/OS Language Environment datasets'
HF68A673FB7E5: 'z/OS Language Environment データセットの高レベル限定符'
# 'High register pressure threhold.'
H72FE4FE03B96: '高いレジスタプレッシャーの閾値.'
# 'Highlight the code regions that will be optimized in a (CFG BBs and LLVM-IR instructions)'
H011F5431A825: '(CFG BBsとLLVM-IR命令)で最適化されるコード領域を強調表示する'
# 'Highlight the code regions that will be optimized in a (CFG only BBs)'
H8868F2ACA588: '(CFGのみのBBs)で最適化されるコード領域を強調表示する'
# 'Hoist common instructions up to the parent block'
H626E78174BD3: '親ブロックまで共通命令を上昇させる'
# 'Hoist conditional stores even if an unconditional store does not precede - hoist multiple conditional stores into a single predicated store'
HAF676B43A7DA: '条件付きストアを単一の予測付きストアにまとめるために、先行する無条件ストアがなくても条件付きストアを上昇させる'
# 'Hoist conditional stores if an unconditional store precedes'
H051D0419768A: '先行する無条件ストアが存在する場合、条件付きストアを上昇させる'
# 'Hoist inner loop runtime memory checks to outer loop if possible'
H1896B47EDC00: '可能な場合、内側ループのランタイムメモリチェックを外側ループに上昇させる'
# 'Hoist instructions from the beginning of the BB up to the maximum specified depth (default = 100, unlimited = -1)'
H19FF88ADEF86: 'BBの開始部から最大指定深度まで命令を上昇させる（デフォルト=100、無制限=-1）'
# 'Hoist invariant loads'
H04F2E5FA708B: '不変ロード命令を上昇させる'
# 'Hoist invariant loads.'
HFD3073FAF6A0: '不変ロード命令を上昇させる。'
# 'Hoist invariant stores'
H37B16BDD134A: '不変ストア命令を上昇させる'
# 'Hoist loads if the target supports conditional faulting'
HFE6E57FFE11D: 'ターゲットが条件付きフォルティングをサポートする場合、ロード命令を上昇させる'
# 'Hoist loads/stores if the target supports conditional faulting (default = false)'
H360599A9B4F2: 'ターゲットが条件付きフォルティングをサポートする場合、ロード/ストア命令を上昇させる（デフォルト=false）'
# 'Hoist stores if the target supports conditional faulting'
HD60C7781C619: 'ターゲットが条件付きフォルティングをサポートする場合、ストア命令を上昇させる'
# 'Hoisting alloca instructions in non-entry blocks to the entry block'
H1611B6B7938C: '非エントリーブロックのalloca命令をエントリーブロックに上昇させる'
# 'Hot callsite threshold for proirity-based sample profile loader inlining.'
HF203067F3822: '優先度基盤に基づくサンプルプロファイルローダーインラインのホットコールサイトしきい値。'
# 'Hot percentile cutoff.'
HCEE9FC61C4DD: 'ホットパーセンタイルのカットオフ。'
# 'How cgscc inline replay file is formatted'
HD50D41502699: 'cgsccインラインリプレイファイルのフォーマット方法'
# "How cgscc inline replay treats sites that don't come from the replay. Original: defers to original advisor, AlwaysInline: inline all sites not in replay, NeverInline: inline no sites not in replay"
H6F8523C009E8: 'cgsccインラインリプレイがリプレイから来ないサイトをどのように扱うか。Original: 元のアドバイザーに委譲、AlwaysInline: リプレイにないすべてのサイトをインライン化、NeverInline: リプレイにないサイトをインライン化しない'
# "How many functions in a module could be used for MergeFunctions to pass a basic correctness check. '0' disables this check. Works only with '-debug' key."
H65C2FF1A291C: "MergeFunctionsが基本的な正しさチェックをパスするためにモジュール内で使用可能な関数の数。'0'でこのチェックを無効化。'-debug' キーとのみ有効。"
# 'How many idle instructions we would like before certain undef register reads'
HAF5EEC679340: '特定の未定義レジスタ読み出しの前に配置するアイドル命令の数'
# 'How many kernel arguments to preload onto SGPRs'
H2C2BF298A146: 'SGPRにプリロードするカーネル引数の数'
# 'How many lifetime ends to handle for a single alloca.'
H1A9776E5D001: '1つのallocaに対して処理するライフタイムエンドの数'
# 'How much code-generation to perform'
HB6C2FA93092D: 'どの程度のコード生成を行うか'
# 'How sample profile inline replay file is formatted'
H7CB1B737EC5A: 'サンプルプロファイルインラインリプレイファイルのフォーマット方法'
# "How sample profile inline replay treats sites that don't come from the replay. Original: defers to original advisor, AlwaysInline: inline all sites not in replay, NeverInline: inline no sites not in replay"
H023EFDA855FF: 'サンプルプロファイルインラインリプレイがリプレイから来ないサイトをどのように扱うか。Original: 元のアドバイザーに委譲、AlwaysInline: リプレイにないすべてのサイトをインライン化、NeverInline: リプレイにないサイトをインライン化しない'
# 'How to aggregate multi-values result'
HE0FCAEDB7A77: '複数値結果をどのように集約するか'
# 'How wide an instruction window to bypass looking for another guard'
H190528E1E0D0: '別のガードを探すのをバイパスするための命令ウィンドウの幅'
# 'HowToUseLLJIT'
H56EB31810445: 'LLJITの使用方法'
# 'Human readable output. Only valid without -all-stacks.'
H1D2D4ECF9DBD: '人間可読形式の出力。-all-stacksオプションなしでのみ有効。'
# 'Human-readable format'
H5B717FB38D2F: '人間可読形式'
# 'IBM MASS vector library'
HC5A8A1BFD3A5: 'IBM MASSベクタライブラリ'
# 'IBOutletCollection properties should be copy/strong and not assign'
H91B04B0AEDF0: 'IBOutletCollectionプロパティはcopy/strongで、assignにしないでください'
# 'IEEE 754 denormal numbers'
HB645808304FA: 'IEEE 754 デノーマル数'
# 'IRDL file to register before processing the input'
H9ADEB68395C9: '入力処理前に登録するIRDLファイル'
# 'IRTranslator LLVM IR -> MI'
HA8BDC735DCBC: 'IRTranslator LLVM IR → MI の変換'
# 'ISO C does not allow indirection on operand of type %0'
HC4C25916B558: 'ISO C は、型 %0 のオペランドに対して間接参照を許可しません'
# "ISO C does not support '~' for complex conjugation of %0"
H592FB210723A: "ISO C は、%0 の複素数共役のために '~' を使用することをサポートしていません"
# "ISO C forbids forward references to 'enum' types"
H3A2E43246AF1: "ISO C は、'enum' 型の前宣言を禁止しています"
# "ISO C forbids taking the address of an expression of type 'void'"
H5DC6DC421D10: "ISO C では、'void' 型の式のアドレスを取得することはできません"
# "ISO C requires a named parameter before '...'"
HAAD7320B82D0: "ISO C では、'...' の前に名前付きパラメータを指定する必要があります"
# 'ISO C requires a translation unit to contain at least one declaration'
HD453AE5DFC44: 'ISO C では、翻訳単位には少なくとも1つの宣言を含める必要があります'
# 'ISO C++ considers this destructor name lookup to be ambiguous'
H51664244F36F: 'ISO C++ では、この破壊子の名前解決が曖昧であると判定されます'
# 'ISO C++ does not allow %select{an attribute list|%0}1 to appear here'
H6EEF885F4392: 'ISO C++ では、ここに %select{属性リスト|%0}1 を使用することは許可されていません'
# 'ISO C++ does not allow %select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2 because it casts away qualifiers, even though the source and destination types are unrelated'
HA24736A782D5: 'ISO C++ では、%1 から %2 への %select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 のキャストは、ソースと目的の型が関連していない場合でも修飾子を外すため禁止されます'
# "ISO C++ does not permit the 'bool' keyword after 'concept'"
HED15AAEA01CD: "ISO C++ では、'concept' 後に 'bool' キーワードを使用することは許可されていません"
# "ISO C++ forbids forward references to 'enum' types"
H565E6A76B7E7: "ISO C++ は、'enum' 型の前宣言を禁止しています"
# "ISO C++ only allows ':' in member enumeration declaration to introduce a fixed underlying type, not an anonymous bit-field"
HD765E30339DE: "ISO C++ では、メンバ列挙体宣言における ':' は匿名ビットフィールドではなく、固定の基底型を指定するために使用する必要があります"
# 'ISO C++ requires a definition in this translation unit for %select{function|variable}0 %q1 because its type does not have linkage'
HCF564C1243BB: 'ISO C++ では、型にリンケージがないため、%select{関数|変数}0 %q1 の定義をこの翻訳単位内に定義する必要があります'
# 'ISO C++ requires field designators to be specified in declaration order; field %1 will be initialized after field %0'
HF7272CADD93F: 'ISO C++ では、宣言順序でフィールド指定子を指定する必要があります。フィールド %0 の後に %1 が初期化されます'
# "ISO C++ requires the name after '::~' to be found in the same scope as the name before '::~'"
H1B12535D9EA0: "ISO C++ では、'::~' の後の名前は、'::~' の前の名前と同じスコープで見つける必要があります"
# "ISO C++ specifies that qualified reference to %0 is a constructor name rather than a %select{template name|type}1 in this context, despite preceding %select{'typename'|'template'}2 keyword"
H0AEAB31369D3: "ISO C++は、この文脈では%0の修飾された参照がコンストラクタ名であると規定しており、%select{テンプレート名|型}1ではなく、前方にある%select{'typename'|'template'}2 キーワードにもかかわらずです"
# 'ISO C++ standards before C++17 do not allow new expression for type %0 to use list-initialization'
H36A45BAF91C7: 'C++17 以前の ISO C++ 標準では、型 %0 の new 表現でリスト初期化を使用することは許可されていません'
# 'ISO C++11 does not allow access declarations; use using declarations instead'
H949947FDD999: 'ISO C++11 では、アクセス宣言の使用を禁止しています。代わりに using ディレクティブを使用してください'
# 'ISO C++11 does not allow conversion from string literal to %0'
HDCEA926F7FF8: 'ISO C++11 では、文字列リテラルから %0 への変換は禁止されています'
# 'ISO C++11 requires a parenthesized pack declaration to have a name'
H70DD46DED2FB: 'ISO C++11では括弧で囲まれたパック宣言に名前が必要です'
# "ISO C++17 does not allow 'register' storage class specifier"
HFBD7E25436E2: "ISO C++17では'register'ストレージクラス指定子は許可されません"
# 'ISO C++17 does not allow a decomposition group to be empty'
H38C9A47FB6B4: 'ISO C++17では分解グループが空であることは許可されません'
# 'ISO C++17 does not allow dynamic exception specifications'
HDA1158B635F1: 'ISO C++17ではダイナミック例外仕様は許可されません'
# 'ISO C++17 does not allow incrementing expression of type bool'
H8CE1E8E6EA54: 'ISO C++17ではbool型の式のインクリメントは許可されません'
# "ISO C++20 considers use of overloaded operator '%0' (with operand types %1 and %2) to be ambiguous despite there being a unique best viable function%select{ with non-reversed arguments|}3"
HE2B331A9C128: "ISO C++20では、オーバーロードされた演算子'%0' (オペランドの型は%1と%2) の使用は一意の最適な有効関数%select{非逆転の引数を有する|}3が存在するにもかかわらず曖昧とみなされます"
# "ISO C++20 requires return type of selected 'operator==' function for rewritten '%1' comparison to be 'bool', not %0"
H96DD21560E53: "ISO C++20では、再書記された'%1'比較の選択された'operator=='関数の戻り値の型は'bool'でなければならず、%0ではいけません"
# 'ISO C90 does not allow subscripting non-lvalue array'
HB75A7925DCA5: 'ISO C90では非lvalue配列の添字指定は許可されません'
# 'ISO C99 requires whitespace after the macro name'
HDC593F4C1475: 'ISO C99ではマクロ名の後に空白が必要です'
# 'IT block support'
H110A8754A4BC: 'ITブロックサポート'
# 'Id of alloc to export if -memprof-dot-scope=alloc or to highlight if -memprof-dot-scope=all'
HB6A8CDFE5726: '-memprof-dot-scope=allocでエクスポートするallocのID、または-scope=allで強調表示する対象のalloc ID'
# 'Id of context to export if -memprof-dot-scope=context or to highlight otherwise'
H0412058D0B19: '-memprof-dot-scope=contextでエクスポートするコンテキストID、またはそれ以外で強調表示する対象のコンテキストID'
# "Identifies whether Control Flow Integrity protects all indirect control flow instructions in the provided object file, DSO or binary.\nNote: Anything statically linked into the provided file *must* be compiled with '-g'. This can be relaxed through the '--ignore-dwarf' flag."
H7027E6C59DD5: "提供されたオブジェクトファイル/DSO/バイナリにおける全間接制御フロー命令が制御フロー整合性で保護されているかを特定します。\n注意: 提供されたファイルに静的にリンクされたものはすべて'-g'でコンパイルされなければなりません。これは'--ignore-dwarf'フラグで緩和可能です"
# 'If Converter'
H8621034DF5DA: 'Ifコンバーター'
# "If ThinLTO and WPD is enabled and this option is true, vtable profiles will be used by ICP pass for more efficient indirect call sequence. If false, type profiles won't be used."
H97A5D327A1D2: 'ThinLTOとWPDが有効でこのオプションがtrueの場合、vtableプロファイルはICPパスにより間接呼び出しシーケンスの効率化に使用されます。falseの場合、型プロファイルは使用されません'
# 'If a personality routine is marked uninstrumented from the ABI list, do not create a wrapper for it.'
H830E42B2D102: 'ABIリストから不具合処理済みとマークされたパーソナリティルーチンに対してラッパーを作成しません'
# 'If an allocatable left-hand side of an intrinsic assignment is unallocated or its shape/type does not match the right-hand side, then it is automatically (re)allocated'
HFF2E7612E3B3: '内在的代入の左辺がallocatableで、右辺の形状/型と一致せず未割り当ての場合、自動的に再割り当てされます'
# 'If enabled, drop make.implicit metadata in unswitched implicit null checks to save time analyzing if we can keep it.'
H84A812339ADF: '有効時はunswitched implicit null checkのmake.implicitメタデータを削除し、保持可否の分析時間を節約します'
# 'If enabled, simple loop unswitching will also consider llvm.experimental.guard intrinsics as unswitch candidates.'
H0DECF1F15908: '有効時は単純ループunswitchingがllvm.experimental.guardインストラクションをunswitch候補として考慮します'
# 'If enabled, the freeze instruction will be added to condition of loop unswitch to prevent miscompilation.'
H29F9314FFE86: '有効にすると、freeze命令がループのunswitch条件に追加され、誤った最適化を防ぎます'
# 'If present, forces/disables the use of long calls'
H244BD3DDA186: '指定すると、long callsの使用を強制/無効にします'
# 'If present, stops packetizing after N instructions'
HC908BB95C55F: '指定すると、N命令後にpacketizingを停止します'
# 'If profile count information is used in tail duplication cost model, the gained fall through number from tail duplication should be at least this percent of hot count.'
H4BE057670DD8: 'Tail duplication cost modelでプロファイルカウント情報を使用する場合、Tail duplicationから得られるfall through数は、この割合のhot count以上である必要があります'
# 'If set to true, IRCE may eliminate wide range checks in loops with narrow latch condition.'
HC7CC2CE2097F: 'trueに設定すると、IRCEはnarrow latch条件を持つループ内の幅広い範囲チェックを削除する可能性があります'
# 'If set, and on a color-capable terminal controls whether or not to print diagnostics in color'
H22D7A9441E62: '設定され、カラーターミナルの場合は、診断情報を色で出力するかどうかを制御します'
# 'If set, assume that loads and stores do not alias'
H938298BEB1B1: '設定すると、ロードとストアがエイリアスしないと仮定します'
# 'If set, benchmark all sizes from sweep-min-size to sweep-max-size'
H918C41E05E1C: '設定すると、sweep-min-sizeからsweep-max-sizeまでのすべてのサイズをベンチマークします'
# 'If set, changes formatting warnings to errors'
HF6B939F6D70E: '設定すると、フォーマット関連の警告をエラーに変更します'
# 'If set, do not actually make the formatting changes'
H11412975A779: '設定すると、実際のフォーマット変更を行いません'
# "If set, don't error out on the specified warning type."
H94EED0D743F6: '設定すると、指定された警告タイプでエラーを出しません'
# 'If set, fail with exit code 1 on incomplete format.'
H3940587B501D: '設定すると、フォーマットが不完全な場合に終了コード1で失敗します'
# 'If set, overrides the include sorting behavior\ndetermined by the SortIncludes style flag'
HA0F9A020C51D: '設定すると、SortIncludesスタイルフラグで決定されるインクルードソートの動作を上書きします'
# 'If set, overrides the qualifier alignment style\ndetermined by the QualifierAlignment style flag'
H7D8374F39C0A: '設定すると、QualifierAlignmentスタイルフラグで決定される修飾子配置のスタイルを上書きします'
# 'If set, shows the list of processed files'
HB1247E3D1FC1: '設定すると、処理されたファイルの一覧を表示します'
# 'If set, unknown format options are only warned about.\nThis can be used to enable formatting, even if the\nconfiguration contains unknown (newer) options.\nUse with caution, as this might lead to dramatically\ndiffering format depending on an option being\nsupported or not.'
HB78C3D57EF8C: '設定すると、不明なフォーマットオプションは警告のみが出力されます。この設定は、設定ファイルに未知の（新しい）オプションが含まれている場合でもフォーマットを有効にするのに使用できます。ただし、オプションのサポート状況によってフォーマットが大幅に異なる可能性があるため、注意して使用してください'
# 'If specified, IR printed using the -print-[before|after]{-all} options will be dumped into files in this directory rather than written to stderr'
HC6C4D32713B0: '指定すると、-print-[before|after]{-all} オプションで出力されるIRは、stderrではなくこのディレクトリのファイルにダンプされます'
# 'If stats should be appended to stats-file instead of overwriting it'
H7B41C07F5D40: 'stats-fileに統計を追加書き込みする場合（上書きしない）'
# 'If the function being instrumented contains more than this number of memory accesses, use callbacks instead of inline checks (-1 means never use callbacks).'
HD30970E83223: 'instrumentation対象の関数がこの数以上のメモリアクセスを含む場合、インラインチェックの代わりにコールバックを使用します（-1はコールバックを使用しないを意味します）'
# 'If the function being instrumented requires more than this number of checks and origin stores, use callbacks instead of inline checks (-1 means never use callbacks).'
H5B3AA5D69CF8: 'インストルメント対象の関数が必要とするチェックとオリジンストレージの数がこの数を超える場合、インラインチェックではなくコールバックを使用します（-1はコールバックを使用しないことを示します）。'
# 'If the function being instrumented requires more than this number of origin stores, use callbacks instead of inline checks (-1 means never use callbacks).'
H3A18D04548FF: 'インストルメント対象の関数が必要とするオリジンストレージの数がこの数を超える場合、インラインチェックではなくコールバックを使用します（-1はコールバックを使用しないことを示します）。'
# 'If the profile density is below the given threshold, it will be suggested to increase the sampling rate.'
HDF4D3E04985A: 'プロファイル密度が指定された閾値を下回った場合、サンプリングレートを増加させることが推奨されます。'
# 'If the runtime tripcount for the loop is lower than the threshold, the loop is considered as flat and will be less aggressively unrolled.'
HAC4BCB57FDE7: 'ループのランタイムトリップカウントが閾値を下回った場合、そのループは平坦と見なされ、より積極的にアンロールされなくなります。'
# 'If the sample profile is accurate, we will mark all un-sampled branches and calls as having 0 samples. Otherwise, treat them conservatively as unknown. '
H815D8C5F471D: 'サンプルプロファイルが正確な場合、未サンプルのブランチとコールは0サンプルとマークされます。そうでない場合は、未知として保守的に扱います。'
# 'If the sample profile is accurate, we will mark all un-sampled callsite and function as having 0 samples. Otherwise, treat un-sampled callsites and functions conservatively as unknown. '
H196C3B85DE70: 'サンプルプロファイルが正確な場合、未サンプルのコールサイトと関数は0サンプルとマークされます。そうでない場合は、未サンプルのコールサイトと関数を未知として保守的に扱います。'
# "If the size of a function is smaller than the threshold, assume it can be inlined by PGO early inliner and it won't be adjusted based on sample profile."
HE6D98DD47634: '関数のサイズが閾値より小さい場合、PGO早期インラインャーによるインラインが可能であると仮定し、サンプルプロファイルに基づく調整を行いません。'
# 'If the total count of context profile is smaller than the threshold, it will be merged into context-less base profile.'
H78D9F132106C: 'コンテクストプロファイルの総カウントが閾値を下回った場合、ベースプロファイルに統合されます。'
# 'If the total count of the profile is smaller than threshold, it will be trimmed.'
H29DFE55539B7: 'プロファイルの総カウントが閾値を下回った場合、プロファイルが切り捨てられます。'
# 'If the valnos size of an interval is larger than the threshold, it is regarded as a large interval. '
H65099468E23D: '区間のvalnosサイズが閾値を超える場合、その区間は大規模区間と見なされます。'
# 'If true, annotate inline advisor remarks with LTO and pass information.'
HBCBB7977FE78: 'Trueの場合、LTOとパス情報でインラインアドバイザーリマクをアノテーションします。'
# 'If true, artificially skip inline transformation in sample-loader pass, and merge (or scale) profiles (as configured by --sample-profile-merge-inlinee).'
HB64A7E1DFEB3: 'Trueの場合、サンプルローダーパスでのインライン変換を人工的にスキップし、プロファイルをマージ（またはスケーリング）します（--sample-profile-merge-inlineeで設定に基づく）。'
# 'If true, basic blocks are re-numbered before MBP layout is printed into a dot graph. Only used when a function is being printed.'
HBEE86CE05AA8: 'Trueの場合、MBPレイアウトをドットグラフに出力する前にベーシックブロックを再番号化します。関数の出力時にのみ使用されます。'
# 'If true, import function declaration as fallback if the function definition is not imported.'
HD7D070FB023F: 'Trueの場合、関数定義がインポートされない場合、関数宣言を代替としてインポートします。'
# 'If true, keep the vtable symbols in indexed profiles'
H52D48DA006BE: 'Trueの場合、インデックス付きプロファイルにvtableシンボルを保持します。'
# 'If true, scale the working set size of the partial sample profile by the partial profile ratio to reflect the size of the program being compiled.'
HBDDA0894BE03: 'Trueの場合、部分サンプルプロファイルのワークセットサイズを部分プロファイル比率でスケーリングし、コンパイル対象のプログラムサイズを反映させます。'
# 'If true, the virtual table address will be instrumented to know the types of a C++ pointer. The information is used in indirect call promotion to do selective vtable-based comparison.'
H3E8FA9464A37: 'Trueの場合、C++ポインタの種類を知るためにvtableアドレスをインストルメントします。この情報は間接コールプロモーションで選択的なvtableベースの比較に使用されます。'
# 'If using a contextual profile in this module, and an indirect call target is marked as alwaysinline, perform indirect call promotion for that target. If multiple targets for an indirect call site fit this description, they are all promoted.'
H51C56F762F1D: 'このモジュールでコンテクストプロファイルを使用し、間接コールターゲットがalwaysinlineとしてマークされている場合、そのターゲットに対して間接コールプロモーションを実行します。複数のターゲットが該当する場合、すべてがプロモーションされます。'
# 'Ignore #line directives when displaying diagnostic locations'
HD98F069577E5: '#lineディレクティブを診断位置の表示時に無視します。'
# 'Ignore RecMII'
H2050B14C1C4D: 'RecMIIを無視します。'
# 'Ignore TTI attributes compatibility check between callee/caller during inline cost calculation'
H6DBD3A9D0CF3: 'インラインコスト計算中に呼び出し元/呼び出され元間のTTI属性の互換性チェックを無視する'
# "Ignore all DWARF data. This relaxes the requirements for all statically linked libraries to have been compiled with '-g', but will result in false positives for 'CFI unprotected' instructions."
H39BB8E06FB84: "DWARFデータを全て無視する。これにより、静的リンクライブラリが'-g'オプションでコンパイルされた必要を緩和しますが、'CFI未保護'命令の誤検出が発生する可能性があります。"
# 'Ignore attribute objc_direct so that direct methods can be tested'
HCF66187C2621: '属性objc_directを無視し、直接メソッドのテストを可能にする'
# 'Ignore balance information, always return (1: Even, 2: Odd).'
HFC882D591A40: 'バランス情報を無視し、常に(1: 偶数、2: 奇数)を返す'
# 'Ignore bit-field types when aligning structures'
H37A6736DD441: '構造体のアライメント時にビットフィールドの型を無視する'
# 'Ignore call stack samples for hybrid samples and produce context-insensitive profile.'
H7E47B7D4BE2D: 'ハイブリッドサンプルのコールスタックサンプルを無視し、コンテキスト非依存プロファイルを生成する'
# 'Ignore case distinctions when searching.'
H17840E450A3A: '大文字小文字の区別を無視して検索する'
# 'Ignore element line number.'
H68F79AF97A49: '要素の行番号を無視する'
# 'Ignore environment variables to detect CUDA installation'
HAC9812BECEE3: 'CUDAインストール検出用の環境変数を無視する'
# 'Ignore existing branch weights on IR and always overwrite.'
HB7CA4D0B2FB1: 'IR上の既存のブランチウェイトを無視し、常に上書きする'
# 'Ignore functions that match a regex. Multiple regexes can be comma separated. Scop detection will ignore all functions that match ANY of the regexes provided.'
HDF7F5F41C8A9: '正規表現に一致する関数を無視する。複数の正規表現はカンマ区切りで指定可能。スコープ検出は、提供された正規表現のいずれかに一致する関数を全て無視する'
# 'Ignore insert conflict and keep running to fix.'
HABB3F2EDAFC7: 'インサートの競合を無視し、修正を続けながら実行を続ける'
# 'Ignore possible aliasing of the array bases'
H64EE4A3BEF1A: '配列ベースのポインタアリasingを無視する'
# 'Ignore redundant instrumentation'
H4E0E4A3BF250: '冗長なインストゥルメンテーションを無視する'
# 'Ignore the definition of the given macro when building and loading modules'
H7770258C460D: '指定されたマクロの定義をモジュール構築時に無視する'
# 'Ignore the whitespace from the input file when emitting preprocessor output. It will only contain whitespace when necessary, e.g. to keep two minus signs from merging into to an increment operator. Useful with the -P option to normalize whitespace such that two files with only formatting changes are equal.\n\nOnly valid with -E on C-like inputs and incompatible with -traditional-cpp.'
HD37ED8478D7E: '入力ファイルの空白をプリプロセッサ出力時に無視する。必要最小限の空白のみを含む（例：2つのマイナス記号がインクリメント演算子にならないように）。-Pオプションと組み合わせて使用すると、フォーマット変更のみの2ファイルを等しくするように空白を正規化できます。\n\nC/C++入力での-Eオプションのみ有効で、-traditional-cppと互換性ありません'
# 'Ignore unexpected diagnostic messages'
H81B938CFE11E: '想定外の診断メッセージを無視する'
# 'Ignore warnings from system headers (default)'
H7D4D3672A31D: 'システムヘッダからの警告を無視する（既定値）'
# "Implement the 'patchable-function' attribute"
H53EFAEE072B9: "'patchable-function'属性を実装する"
# 'Implicit null checks'
H40CAC5790CAC: '暗黙のnullチェック'
# 'Implicitly search the file system for module map files.'
HA09A2D8486F2: 'ファイルシステムを暗黙的に検索してモジュールマップファイルを検索します。'
# "Implies all other options in 'Symbol Types' category"
HA831AAE57383: '「シンボルタイプ」カテゴリの他のすべてのオプションを含意します'
# 'Implies most other options.'
H6CE9D8EF9C43: '他のほとんどのオプションを含意します。'
# 'Implies the SAVE attribute for non-automatic local objects in subprograms unless RECURSIVE'
H4C9AEE72AB8A: 'RECURSIVEを除き、サブプログラム内の非自動ローカルオブジェクトに対してSAVE属性を含意します。'
# 'Import all external functions in index.'
H6AA576FCF40F: 'インデックス内のすべての外部関数をインポートします。'
# 'Import constant global variables with references'
H2A392B0AB0D3: '参照を持つ定数グローバル変数をインポートします。'
# 'Import declaration.'
H4A43ED2EE433: '宣言をインポートします。'
# 'Import full type definitions for ThinLTO.'
HC44C755DA4C3: 'ThinLTO用の完全な型定義をインポートします。'
# 'Import functions with noinline attribute'
HD198F1298814: 'noinline属性を持つ関数をインポートします。'
# 'Import module.'
H6E01604A8D9D: 'モジュールをインポートします。'
# 'Import summary to use for testing the ThinLTO backend via opt'
HED7EEF5C6F9E: 'optを介してThinLTOバックエンドのテストに使用する要約をインポートします。'
# 'Import the polyhedral description of the detected Scops'
H5D0606A7CB94: '検出されたScopsの多面体説明をインポートします。'
# 'Import typeid resolutions from summary and globals'
HC32DC5EADEE2: '要約およびグローバルからtypeid解決をインポートします。'
# 'Import.'
H0E5CF36B48DC: 'インポート。'
# 'Improve global merge pass to ignore globals only used alone'
H26A9763EC62A: '単独で使用されるグローバルを無視するようにグローバルマージパスを改善します。'
# 'Improve global merge pass to look at uses'
HA9CE9E94603C: '使用状況を確認するようにグローバルマージパスを改善します。'
# 'Improve the code quality by splitting alternate instructions'
H103FED3C5FE8: '代替命令を分割することでコードの品質を向上します。'
# 'In all cases'
HCC1A697CD02F: 'すべての場合において'
# 'In conjunection with -type-index and -id-index, dumps the entire dependency graph for the specified index instead of just the single record with the specified index'
H835459E7E97D: '-type-indexおよび-id-indexと併用して、指定されたインデックスの単一レコードではなく、指定されたインデックスの依存関係グラフ全体をダンプします。'
# "In profiling mode like sampleFDO, if a function doesn't have profile, we cannot tell the function is cold for sure because it may be a function newly added without ever being sampled. With the flag enabled, compiler can put such profile unknown functions into a special section, so runtime system can choose to handle it in a different way than .text section, to save RAM for example. "
H4571B587B651: 'sampleFDOなどプロファイリングモードでは、関数がプロファイルを持っていない場合、サンプリングされたことがない新規追加された関数である可能性があるため、その関数がコールドであるかどうかを確実に判断できません。このフラグを有効にすると、コンパイラはそのようなプロファイル不明の関数を特別なセクションに配置し、ランタイムシステムは.textセクションとは異なる方法で扱う選択が可能になり、RAMの節約などに利用できます。'
# 'In the Lint pass, abort on errors.'
H4B98027DD134: 'Lint パス中にエラーが発生した場合、処理を中断します。'
# 'In the OpenMP data clauses treat `a(N)` as `a(N:N)`.'
H1CA9E31B3F5D: 'OpenMP のデータ句で、`a(N)` を `a(N:N)` として扱います。'
# 'In the dump requested by -dump-input, print <N> input lines\nbefore and <N> input lines after any lines specified by\n-dump-input-filter.  When there are multiple occurrences of\nthis option, the largest specified <N> has precedence.  The\ndefault is 5.\n'
HEB48ED43B50E: '-dump-input で要求されたダンプで、-dump-input-filter で指定された行の前後にそれぞれ<N>行ずつ入力行を表示します。\nこのオプションが複数回指定された場合、最大の<N>が優先されます。デフォルトは5です。\n'
# "In the dump requested by -dump-input, print only input lines of\nkind <value> plus any context specified by -dump-input-context.\nWhen there are multiple occurrences of this option, the <value>\nthat appears earliest in the list below has precedence.  The\ndefault is 'error' when -dump-input=fail, and it's 'all' when\n-dump-input=always.\n"
H9104E1DEC417: "-dump-input で要求されたダンプで、-dump-input-context で指定されたコンテキストを含む、<value> 種類の入力行のみを表示します。\nこのオプションが複数回指定された場合、下記のリストで最初に現れた<value>が優先されます。\nデフォルトは、-dump-input=fail の場合 'error', -dump-input=always の場合 'all' です。\n"
# 'In the report, sort the timers in each group in wall clock time order'
H2F13A69F022D: 'レポートでは、各グループのタイマーをウォールクロック時間の順に並べ替えます。'
# 'Include BLOCKINFO details in low level dump'
H27C5E3DE841C: 'BLOCKINFO の詳細をローレベルのダンプに含める。'
# "Include PTX for the following GPU architecture (e.g. sm_35) or 'all'. May be specified more than once."
H2031AC36E8FB: "以下のGPUアーキテクチャ（例: sm_35）または 'all' のPTXを含める。このオプションは複数回指定可能です。"
# 'Include Parameters in templates.'
H8654E7CEAC51: 'テンプレートにパラメータを含める。'
# 'Include all attributes.'
H5307C43E1D9E: 'すべての属性を含める。'
# 'Include and chain a header file after turning it into PCH'
HBFEBA9B95050: 'ヘッダーファイルをPCHに変換した後、そのPCHをチェーンして含める。'
# 'Include brief documentation comments in code-completion results.'
H235F6D6F7048: 'コード補完結果に簡略なドキュメントコメントを含める。'
# 'Include code completion results which require small fix-its.'
HFB6D833443A2: '修正が必要な小規模なコード補完結果を含める。'
# 'Include code patterns in code-completion results'
H22A7B204F988: 'コード補完結果にコードパターンを含める。'
# 'Include comments from within macros in preprocessed output'
H6B3D5AD18D24: 'プリプロセス済み出力にマクロ内のコメントを含める。'
# 'Include comments in preprocessed output'
H5CEC03939D7C: 'プリプロセス済み出力にコメントを含める。'
# 'Include declaration types in AST dumps'
H327A3B852BC1: 'AST ダンプに宣言タイプを含める。'
# 'Include default header file for OpenCL and HLSL'
H5BEB3A92485B: 'OpenCL および HLSL のデフォルトのヘッダーファイルを含める。'
# 'Include file before parsing'
H9043E8EF9CD8: '解析前にファイルを含める。'
# "Include line table offset in function's debug info and emit end sequence after each function's line data."
H98EA6A67A95E: '関数のデバッグ情報にラインテーブルオフセットを含め、各関数のラインデータ後にエンドシーケンスを出力する。'
# 'Include macros from file before parsing'
H36D4DE65DD21: '解析前にファイルからマクロを含める。'
# 'Include macros in code-completion results'
H3EC7A0C589B9: 'コード補完結果にマクロを含める'
# 'Include module files in dependency output'
H1900641C3AE2: '依存関係出力にモジュールファイルを含める'
# 'Include only compilands those which match a regular expression'
H077919CD113F: '正規表現に一致するコンパイル対象のみを含める'
# 'Include only symbols which match a regular expression'
HC57ED85CA0C0: '正規表現に一致するシンボルのみを含める'
# 'Include only types which match a regular expression'
HF1FE163F1EFB: '正規表現に一致する型のみを含める'
# 'Include path for coverage check.'
HCF44564AEDD8: 'カバレッジチェック用のパスを含める'
# 'Include precompiled header file'
HCCC9D73787DC: 'プリコンパイルヘッダーファイルを含める'
# 'Include system headers in dependency output'
HA0C79FE37C8B: '依存関係出力にシステムヘッダーを含める'
# 'Include what you use. Insert the owning header for top-level symbols, unless the header is already directly included or the symbol is forward-declared'
H8E18AB6F55BF: '使用するもののみを含める。ヘッダーが既に直接包含されていないかシンボルが前方宣言されていない場合、トップレベルシンボルの所有ヘッダーを挿入する'
# 'Incorporate CUDA device-side binary into host object file.'
HC64F11374476: 'CUDAデバイス側のバイナリをホストオブジェクトファイルに組み込む'
# 'Increase alignment of LDS if it is not on align boundary'
H6B6D9E0BE911: 'LDSがアライメント境界にない場合、アライメントを増やす'
# "Increases 'x86-br-merging-base-cost' in cases that it is likely that all conditionals will be executed. For example for merging the conditionals (a == b && c > d), if its known that a == b is likely, then it is likely that if the conditionals are split both sides will be executed, so it may be desirable to increase the instruction cost threshold. Set to -1 to never merge likely branches."
H9238554A10FA: "'x86-br-merging-base-cost'を、条件分岐がすべて実行される可能性が高い場合に増加します。例えば、(a == b && c > d)のような条件分岐を結合する場合、a == bが確実だとわかっている場合、条件分岐を分割すると両方の分岐が実行される可能性が高いため、命令コストの閾値を増加させたいかもしれません。-1に設定すると、確実な分岐は決して結合されません。"
# "Increases 'x86-br-merging-base-cost' in cases that the target supports conditional compare instructions."
H0EFC5555FAAB: "ターゲットが条件比較命令をサポートする場合、'x86-br-merging-base-cost'を増加します"
# 'Incremental depth computation will be used for basic blocks with more instructions.'
HE1566572AE0C: '命令数が多い基本ブロックには、インクリメンタル深度計算を使用します'
# 'Index of module to extract'
H61BCB37228FB: '抽出するモジュールのインデックス'
# 'Indicate the sample profile being used is flattened, i.e., no inline hierarchy exists in the profile'
H8CEB9B04AD89: '使用するサンプルプロファイルがフラット化されていることを示す（すなわち、プロファイルにインライン階層が存在しない）'
# 'Indirect access memory instruction weight'
H4459013C64C1: '間接アクセスメモリ命令の重み'
# 'Induction Variable Users'
HCAD9EC424CF6: '誘導変数ユーザー'
# 'Infer address spaces'
H384231A2B40A: 'アドレス空間を推論する'
# 'Infer counts from stale profile data.'
H68A503AAE479: '古いプロファイルデータからカウントを推論する'
# 'Infer missing call frames due to compiler tail call elimination.'
H3DAC7DFCC466: 'コンパイラのテールコール消去により欠落したコールフレームを推論します。'
# 'Infer nuw/nsw flags using context where suitable'
H6B2FAC7DF345: '適切な文脈でnuw/nswフラグを推論します'
# 'Inheritance.'
H21B03FF2F5DB: '継承。'
# 'Inhibit optimization of S->D register accesses on A15'
H9EE07FA9B2FD: 'A15上でS->Dレジスタへのアクセスの最適化を抑制します'
# 'Init Undef Pass'
HA592C8476F8C: 'Undef パスの初期化'
# "Initialize trivial automatic stack variables. Defaults to 'uninitialized'"
H413F6C855E54: "単純な自動スタック変数を初期化します。既定値は'uninitialized'です"
# 'Inject absolute symbol definitions (syntax: <name>=<addr>)'
HD553F9022403: '絶対シンボル定義を注入します（構文: <name>=<addr>）'
# 'Inject symbol aliases (syntax: <alias-name>=<aliasee>)'
H4CF0C6E38779: 'シンボルのエイリアスを注入します（構文: <alias-name>=<aliasee>）'
# 'Inline all applicable functions on the device.'
H843E2B29FDA6: 'デバイス上で適用可能なすべての関数をインライン化します。'
# 'Inline all functions early'
HBFFBF85B1F6E: '早期にすべての関数をインライン化します'
# "Inline cold call sites in profile loader if it's beneficial for code size."
H86BDD048441C: 'プロファイルローダー内の非頻繁なコールサイトをコードサイズに有益な場合にインライン化します。'
# 'Inline functions as deemed beneficial by the compiler'
H648E731FB641: 'コンパイラが有益と判断した関数をインライン化します'
# 'Inline functions which are (explicitly or implicitly) marked inline'
H8CD71C20FEE1: '(明示的または暗黙的)にinlineとしてマークされた関数をインライン化します'
# 'Inline shadow poisoning for blocks up to the given size in bytes.'
HD3284F467146: '指定されたバイト数までのブロックに対するシャドウポイズニングをインライン化します。'
# 'Inline suitable functions'
H8AADDFE804BD: '適切な関数をインライン化します'
# 'Inline threshold for device compilation for CUDA/HIP'
H94D1EB14515E: 'CUDA/HIP用デバイスコンパイルのインラインしきい値'
# 'Inlined function.'
H5766708CD3DD: 'インライン化された関数。'
# 'Inlinee lines (DEBUG_S_INLINEELINES subsection)'
H605540E4F837: 'インライン元の行（DEBUG_S_INLINEELINESサブセクション）'
# 'Inliner for always_inline functions'
H228DE039DDE2: 'always_inline関数用のインライナ'
# 'Inner loop block size threshold to analyze in unroll for AMDGPU'
H2139A958B6DF: 'AMDGPUのアンロール分析における内部ループブロックサイズのしきい値'
# 'Inplace edit <file>s'
H1E18B41D725B: 'ファイルをインプレイス編集します'
# 'Inplace edit <file>s, if specified.'
H469713E2DE1D: '指定された場合、ファイルをインプレイス編集します'
# 'Input JSON stream encoding'
HDA67A1195E8E: '入力JSONストリームのエンコーディング'
# 'Input file. Can be specified multiple times for multiple input files.'
H5D0C7337A0AA: '入力ファイルです。複数の入力ファイルを指定する場合は、複数回指定できます。'
# "Input file. The format is an array of contexts.\nEach context is a dictionary with the following keys:\n'Guid', mandatory. The value is a 64-bit integer.\n'Counters', mandatory. An array of 32-bit ints. These are the counter values.\n'Contexts', optional. An array containing arrays of contexts. The context array at a position 'i' is the set of callees at that callsite index. Use an empty array to indicate no callees."
H53610FB0F715: "入力ファイルです。形式はコンテキストの配列です。\n各コンテキストは、次のキーを持つディクショナリです:\n'Guid', 必須。値は64ビット整数です。\n'Counters', 必須。32ビット整数の配列です。これらはカウンタ値です。\n'Contexts', オプション。コンテキストの配列を含む配列です。位置'i'のコンテキスト配列は、その呼び出しサイトインデックスの呼び出し先のセットです。空の配列を使用して、呼び出し元がないことを示します。"
# "Input language ('ir' or 'mir')"
HAAA3662FD097: '入力言語 (irまたはmir)'
# 'Input lines with annotations'
H7B5B0A60C876: '注釈付きの入力行'
# 'Input lines with starting points of annotations'
H2C5EEFB1318C: '注釈の開始位置を含む入力行'
# 'Input lines with starting points of error annotations'
H738B96DDE138: 'エラー注釈の開始位置を含む入力行'
# 'Input remark format to parse'
H719353F24FE9: '解析するリマーカ形式の入力'
# 'Insert BLOCK/LOOP/TRY/TRY_TABLE markers for WebAssembly scopes'
H7D3A208C7E5E: 'WebAssemblyスコープのためのBLOCK/LOOP/TRY/TRY_TABLEマーカーを挿入します'
# 'Insert CFI remember/restore state instructions'
H6E95A98450BA: 'CFIの状態を記憶/復元する命令を挿入します'
# 'Insert KCFI indirect call checks'
H9190E8521B57: 'KCFI間接呼び出しチェックを挿入します'
# 'Insert XRay ops'
HB3BFBF584BC3: 'XRayオペレーションを挿入します'
# 'Insert a break point on the last enabled count of a chunks list'
H14F2710F0183: 'チャンクリストの最後の有効なカウントにブレークポイントを挿入します'
# 'Insert a specific header. This should run with STDIN mode.\nThe result is written to stdout. It is currently used for\neditor integration. Support YAML/JSON format:\n  -insert-header="{\n     FilePath: "/path/to/foo.cc",\n     QuerySymbolInfos: [\n       {RawIdentifier: foo,\n        Range: {Offset: 0, Length: 3}}\n     ],\n     HeaderInfos: [ {Headers: "\\"foo_a.h\\"",\n                     QualifiedName: "a::foo"} ]}"'
HAF484669F973: '特定のヘッダーを挿入。STDINモードで実行されます。\n結果はstdoutに出力されます。現在エディタ統合で使用されています。YAML/JSONフォーマットに対応:\n  -insert-header="{\n     FilePath: "/path/to/foo.cc",\n     QuerySymbolInfos: [\n       {RawIdentifier: foo,\n        Range: {Offset: 0, Length: 3}}\n     ],\n     HeaderInfos: [ {Headers: "\\"foo_a.h\\"",\n                     QualifiedName: "a::foo"} ]}"'
# 'Insert calls to __dfsan_*_callback functions on data events.'
HBF62B008B7B5: 'データイベント時に__dfsan_*_callback関数を呼び出します。'
# 'Insert calls to __dfsan_nonzero_label on observing a parameter, load or return with a nonzero label'
HCF1838FEBC0F: 'パラメータ、ロード、または非ゼロラベルでの戻り値を観測した際に__dfsan_nonzero_labelを呼び出します。'
# 'Insert calls to callback functions on conditionals.'
H462621715E94: '条件式でコールバック関数を呼び出します。'
# 'Insert calls to callback functions on data reaching a function.'
H874EB16726E7: 'データが関数に到達した際にコールバック関数を呼び出します。'
# 'Insert calls to fentry at function entry (x86/SystemZ only)'
H5602F1E7FC9F: '関数のエントリポイントでfentry呼び出しを挿入（x86/SystemZのみ対応）'
# 'Insert checks for constant shadow values'
HEF594A46B3BD: '定数シャドウ値のチェックを挿入'
# 'Insert fentry calls'
HCD006A416E6E: 'fentry呼び出しを挿入'
# 'Insert instructions into the prologue for storing into the stack ring buffer'
H46F958F6D7F3: 'スタックリングバッファへの保存用命令をプロローグに挿入'
# 'Insert instructions into the prologue for storing into the stack ring buffer directly'
H31D52AECD84E: 'スタックリングバッファへの直接保存用命令をプロローグに挿入'
# 'Insert pseudo probe annotations for value profiling'
H219A8D7D9F81: '値プロファイリング用の擬似プローブアノテーションを挿入'
# 'Insert required mode register values'
HA0E87197EB1B: '必要なモードレジスタ値を挿入'
# 'Insert sanitizers on OptimizerEarlyEP.'
HC54CCA49CF20: 'OptimizerEarlyEPでsanitizerを挿入'
# 'Insert stack protectors'
H2189E21FAD58: 'スタック保護機能を挿入'
# 'Insert stores for EH state numbers'
HAFD53ADD3CBA: '例外処理（EH）の状態番号用ストア命令を挿入'
# 'Insert symbols at valid longjmp targets for /guard:cf'
H36BD6FBCD02B: '/guard:cf 用の有効なlongjmpターゲットにシンボルを挿入'
# 'Insert symbols at valid targets for /guard:ehcont'
H071F81C54D78: '/guard:ehcont 用の有効なターゲットにシンボルを挿入'
# 'Insert the experimental `assertalign` node.'
H893CAC606686: '実験的な`assertalign`ノードを挿入'
# 'Insert vsetvlis before vmvNr.vs to ensure vtype is valid and vill is cleared'
H0091B7D0D6C7: 'vtypeの有効性とvillクリアを保証するため、vmvNr.vsの前にvsetvliを挿入'
# 'Instantiate templates already while building a PCH'
H9EE0E3239942: 'PCH構築時にテンプレートを事前に展開'
# 'Instead of emitting the pipelined code, annotate instructions with the generated schedule for feeding into the -modulo-schedule-test pass'
HD7DD1AFC4508: 'モジュロスケジューリングテスト用に、生成されたスケジュール情報を命令にアノテーションとして付与（パイプラインコードの生成を抑制）'
# 'Instead of expanding system headers when emitting preprocessor output, preserve the #include directive. Useful when producing preprocessed output for test case reduction. May produce incorrect output if preprocessor symbols that control the included content (e.g. _XOPEN_SOURCE) are defined in the including source file. The portability of the resulting source to other compilation environments is not guaranteed.\n\nOnly valid with -E.'
H2BDDF0355665: 'プレプロセッサ出力生成時にシステムヘッダーを展開せず#includeディレクティブを保持。テストケース削減用にプリプロセス済み出力を作成する際に有用。包含内容を制御するプリプロセッサシンボル（例:_XOPEN_SOURCE）が包含元ファイルで定義されている場合、不正な出力が生成される可能性があります。他のコンパイル環境への移植性は保証されません。\n\n-Eオプションと併用のみ有効'
# 'Instead of running LTO, list the dependent libraries in each IR file'
H03C32E83B1C7: 'LTO実行を抑制し、各IRファイルの依存ライブラリを一覧表示'
# 'Instead of running LTO, list the symbols in each IR file'
HA0AFB51F310C: 'LTO実行を抑制し、各IRファイルのシンボルを一覧表示'
# 'Instead of running LTO, print the mach-o cpu in each IR file'
HE9DA1147E6B8: 'LTOを実行する代わりに、各IRファイル内のmach-o CPUを表示します'
# 'Instead of spilling a variable right away, defer the actual code insertion to the end of the allocation. That way the allocator might still find a suitable coloring for this variable because of other evicted variables.'
HFC03D1ABDED7: '変数をすぐに一時退避する代わりに、実際のコード挿入を割り当ての終了まで遅延させます。これにより、他の退避された変数の影響で、アロケーターがこの変数に対して適切な色付けを見つける可能性が残ります'
# 'Instruction Inverse Throughput'
H08AC91953156: '命令逆スループット'
# 'Instruction Latency'
HFD97D6973432: '命令レイテンシ'
# "Instruction cutoff for aggressive tail duplication during layout. Used at -O3. Tail merging during layout is forced to have a threshold that won't conflict."
H0BFD5BDD2709: '-O3で使用される、レイアウト時の積極的テール複製の閾値。レイアウト時のテール統合は、競合しない閾値を強制されます'
# "Instruction cutoff for tail duplication during layout. Tail merging during layout is forced to have a threshold that won't conflict."
HCFA67B310DAB: 'レイアウト時のテール複製の閾値。レイアウト時のテール統合は、競合しない閾値を強制されます'
# 'Instruction latency'
H6CD53FB2E731: '命令レイテンシ'
# 'Instruction schedulers available (before register allocation):'
H4C7D1036B846: 'レジスタ割り当て前に利用可能な命令スケジューラ:'
# 'Instructions, lines, scopes, symbols and types.'
HD37C6649C311: '命令、行、スコープ、シンボル、および型。'
# 'Instrument (context sensitive) the IR to generate profile.'
HAAB0AE0AE781: '(文脈依存)プロファイルを生成するために、IRを計測します'
# 'Instrument - operations with pointer operands'
HDBC71D3E6754: 'ポインター操作のオペランドを計測します'
# 'Instrument <, <=, >, >= with pointer operands'
H6DA2CC308CCE: 'ポインタオペランドを持つ<, <=, >, >=を計測します'
# 'Instrument <, <=, >, >=, - with pointer operands'
H012240D9415C: 'ポインタオペランドを持つ<, <=, >, >=, -を計測します'
# 'Instrument atomics'
HBB3D2F3D5275: 'アトミック操作を計測します'
# 'Instrument code to produce gcov data files (*.gcda)'
HFE3A9A25C96C: 'gcovデータファイル(*.gcda)を生成するためにコードを計測します'
# 'Instrument control-flow architecture protection'
H2142469CBC51: '制御フロー構造保護を計測します'
# 'Instrument device library for HIP, which is a LLVM bitcode containing __cyg_profile_func_enter and __cyg_profile_func_exit'
H24C9537239C3: 'HIP用のデバイスライブラリを計測します。HIPは__cyg_profile_func_enterと__cyg_profile_func_exitを含むLLVMビットコードです'
# 'Instrument floating-point comparisons'
HFB5DAE0497FE: '浮動小数点比較を計測します'
# 'Instrument function entry and exit'
H744C2AF9F0F5: '関数のエントリとエキスティを計測します'
# 'Instrument function entry only, after inlining, without arguments to the instrumentation call'
H10B2DF0B7A61: 'インライン処理後の関数エントリのみを、計測呼び出しの引数なしで計測します'
# 'Instrument function entry with call to __CheckForDebuggerJustMyCode'
H38C50073F978: '関数のエントリに__CheckForDebuggerJustMyCodeの呼び出しを追加する'
# 'Instrument function entry/exit with calls to e.g. mcount() (post inlining)'
H41E9F3846338: '関数のエントリ/エグジットにmcount()などの呼び出しを追加（インライン展開後）'
# 'Instrument functions with a call to __CheckForDebuggerJustMyCode'
H179F36D1CDA5: '関数に__CheckForDebuggerJustMyCodeの呼び出しを追加する'
# 'Instrument globals'
HF9B96A5EACA6: 'グローバル変数をインストゥルメンテーションする'
# 'Instrument memintrinsics (memset/memcpy/memmove)'
HE6033F8FFDF9: 'memintrinsics（memset/memcpy/memmove）をインストゥルメンテーションする'
# 'Instrument memory accesses'
H9382264E0AFD: 'メモリアクセスをインストゥルメンテーションする'
# "Instrument only functions from files where names don't match all the regexes separated by a semi-colon"
HD8259B6217C3: 'セミコロン区切りの正規表現すべてに一致しないファイル名の関数のみを対象とする'
# 'Instrument only functions from files where names match any regex separated by a semi-colon'
H261C37210502: 'セミコロン区切りの正規表現のいずれかに一致するファイル名の関数のみを対象とする'
# 'Instrument scalar stack variables'
HC15A017384F6: 'スカラースタック変数をインストゥルメンテーションする'
# 'Instrument the IR to generate profile.'
H5521F08582E8: 'プロファイルを生成するためのIRをインストゥルメンテーションする'
# 'Instrument the same temp just once'
H47FE01195CE1: '同じテンポラリ変数を一度だけインストゥルメンテーションする'
# 'Instrumentation profile (default)'
H8B8FBAF3F224: 'インストゥルメンテーションプロファイル（デフォルト）'
# 'Intel SVML library'
H43C24287102B: 'Intel SVMLライブラリ'
# 'Interchange if you gain more than this number'
H1A5217DD30CE: 'この数値以上の利益を得られる場合に交換する'
# 'Internal Options'
HE6B42A71FEB4: '内部オプション'
# 'Internal and debugging options'
H1AFE239C87EF: '内部オプションとデバッグ用オプション'
# 'Internal traces and extra debugging code.'
HFC2113D2B3C3: '内部トレースと追加のデバッグコード'
# 'Internalize linked symbols'
H4254AEAF9E4E: 'リンクローメンシンボルを内部化する'
# 'Intrinsics Generator Options'
H4BD784F50D5F: 'INTRINSICS生成オプション'
# 'Introduce mul24 intrinsics in AMDGPUCodeGenPrepare'
H3C667C2E6C53: 'AMDGPUCodeGenPrepareでmul24イントライン関数を導入する'
# 'Invalid code ranges.'
H1F42CA5A3D9B: '無効なコード範囲です。'
# 'Invalid symbol coverages values.'
H3E269D60065B: '無効なシンボル カバレッジ値です。'
# 'Invalid symbol locations.'
H5E97A467E1AD: '無効なシンボルの位置です。'
# 'Issue call to specified function rather than a trap instruction'
HA69FCF5CDF0A: '指定された関数への呼び出しを発行する代わりにトラップ命令を使用しない'
# 'Iterate to a fixed point when attempting to convert reg-reg instructions to reg-imm'
HD223D51415E6: 'レジスタ-レジスタ命令をレジスタ-即値命令に変換する際に固定点まで反復する'
# 'Iterative inference: delta convergence precision; smaller values typically lead to better results at the cost of worsen runtime'
H1328F2EA33BA: '反復推論: デルタ収束精度。より小さな値は通常、実行時間の悪化を伴いますが、より良い結果をもたらします'
# 'Iterative inference: maximum number of update iterations per block'
H5F6BCC565010: '反復推論: 各ブロックあたりの更新反復の最大数'
# 'JIT the code and run it by invoking the main function'
HC922A3A5E7D1: 'コードをJITコンパイルし、main関数を呼び出して実行する'
# 'JITLink Options'
H759F3B87058B: 'JITLink オプション'
# 'JSON format'
H5766BFD5841D: 'JSON フォーマット'
# 'Join isolated components having positive flow.'
HA5D28D00BB60: 'ポジティブなフローを持つ分離されたコンポーネントを結合する'
# 'Jump score power (when --split-strategy=cdsplit)'
H4F864F9914B4: 'ジャンプ スコア パワー（--split-strategy=cdsplit 時）'
# 'Just print the preprocessed file'
H19C52BC87B22: 'プリプロセス済みファイルを単に印刷する'
# 'Just run preprocessor, no output (for timings)'
HA774A3EF0AA6: 'プリプロセッサを実行し、出力を生成しない（実行時間計測用）'
# 'Kaleidoscope example program\n'
HCF3536F4FAAB: 'Kaleidoscope の例プログラム\n'
# 'Keep all benchmarks (default)'
HD3F623D56EDC: 'すべてのベンチマークを保持する（既定値）'
# 'Keep all non-cold contexts (increases cloning overheads)'
H4544ED3678BF: 'すべての非コールド コンテキストを保持する（クローンのオーバーヘッドが増加します）'
# 'Keep aside the last <num-test-traces> traces in the profile when computing the function order and instead use them to evaluate that order'
H77D85A9D26A6: 'プロファイルで関数順序を計算する際に、最後の<num-test-traces>トレースを一時的に保持し、代わりにそれらを使用してその順序を評価する'
# 'Keep copies of symbols in LTO indexing'
HB94AF3670BCE: 'LTO インデックス内のシンボルのコピーを保持する'
# 'Keep going on errors encountered'
H418BF6CA6A97: '発生したエラーを無視して処理を継続する'
# 'Keep going on errors encountered in trace 1'
H99638570EFA7: 'エラーが発生した場合でもトレース1の処理を継続'
# 'Keep going on errors encountered in trace 2'
HCFE6CEB4DFCA: 'エラーが発生した場合でもトレース2の処理を継続'
# 'Keep initializers of constants'
H36ACE3809A61: '定数の初期化子を保持'
# 'Keep max reading'
H5A60CCC0248E: '最大読み取りを保持'
# 'Keep min reading'
H6EAFD9A719C6: '最小読み取りを保持'
# 'Keep only the benchmarks that *DO* involve memory'
HF9706AF3813D: 'メモリを扱うベンチマークのみを保持 *DO*'
# 'Keep only those benchmarks that do *NOT* involve memory'
H135A99676AA8: 'メモリに関わらないベンチマークのみを保持 *NOT*'
# 'Keep readings set with min-variance'
H09D9C8B784B4: '最小分散で設定された読み取りを保持'
# 'Keep static const variables even if unused'
H6813EA88BF1D: 'static const 変数を未使用でも保持'
# 'Keep the last K contexts while merging cold profile. 1 means the context-less base profile'
H3B3B98C36252: 'cold profile をマージする際、最後の K コンテキストを保持。1 はコンテキストのないベースプロファイルを示す'
# 'Keep the last K contexts while merging profile. -1 means no depth limit.'
HE51374D52FCC: 'プロファイルをマージする際、最後の K コンテキストを保持。-1 は深度制限なしを示す'
# 'Keep the last K contexts while merging unsymbolized profile. -1 means no depth limit.'
HCA7356B0D5FB: 'unsymbolized プロファイルをマージする際、最後の K コンテキストを保持。-1 は深度制限なしを示す'
# 'Keep the last K frames while merging cold profile. 1 means the context-less base profile'
H4AC5A2FF5CAD: 'cold profile をマージする際、最後の K フレームを保持。1 はコンテキストのないベースプロファイルを示す'
# 'Kernel code model'
H99C64FCE935F: 'カーネル コード モデル'
# 'Kernel limit wave threshold in %'
H670F8AEC39A0: 'カーネルの制限ウェーブ閾値（%）'
# 'Kind of debug info to add'
HBD02ACC04B34: '追加するデバッグ情報の種類'
# 'LCSSA Verifier'
HF121CA5D89C7: 'LCSSA バリデータ'
# 'LLDB Instrumentation Generator'
H3C61B845C07E: 'LLDB インストルメンテーション ジェネレーター'
# 'LLJITDumpObjects'
H6958140CABBB: 'LLJIT オブジェクトダンプ'
# 'LLJITWithCustomObjectLinkingLayer'
H632B9B1CBCE5: 'カスタム オブジェクト リンク レイヤーを有する LLJIT'
# 'LLJITWithGDBRegistrationListener'
HB6D370668767: 'LLJIT-GDB登録リスナー'
# 'LLJITWithInitializers'
HACE516CC94B0: 'LLJIT-初期化子'
# 'LLJITWithLazyReexports'
H3A104CF605C4: 'LLJIT-遅延再エクスポート'
# 'LLJITWithObjectCache'
H71A8C9D07573: 'LLJIT-オブジェクトキャッシュ'
# 'LLJITWithObjectLinkingLayerPlugin'
H748539F4EA26: 'LLJIT-オブジェクトリンカーレイヤープラグイン'
# 'LLJITWithRemoteDebugging'
H3A8FDD7C38FF: 'LLJIT-リモートデバッグ'
# 'LLJITWithThinLTOSummaries'
HE8A81BB7479F: 'LLJIT-スリムLTOサマリーズ'
# 'LLVM C++ ABI Data Dumper\n'
HEF94C326E777: 'LLVM C++ ABI データダンプツール\n'
# 'LLVM C++ mangled name remapper\n'
H374D96C0B2FD: 'LLVM C++ マングルド名変換ツール\n'
# 'LLVM Contextual Profile Utils\n'
H96B79F1155FF: 'LLVM コンテキストプロファイルユーティリティ\n'
# 'LLVM IR Similarity Visualizer\n'
H1B7F78E6F996: 'LLVM IR類似度可視化ツール\n'
# 'LLVM OpenMP'
H6A5AC73C091C: 'LLVM OpenMP'
# 'LLVM PDB Dumper\n'
HD0867800CD16: 'LLVM PDBダンプツール\n'
# 'LLVM automatic testcase reducer.\n'
HF2C9C9289AA4: 'LLVM 自動テストケース削減ツール。\n'
# 'LLVM automatic testcase reducer. See\nhttp://llvm.org/cmds/bugpoint.html for more information.\n'
H28E8E607A645: 'LLVM 自動テストケース削減ツール。詳細は\nhttp://llvm.org/cmds/bugpoint.html を参照してください。\n'
# 'LLVM code coverage tool\n'
HB94353E136F7: 'LLVM コードカバレッジツール\n'
# 'LLVM module splitter\n'
H99370B462DED: 'LLVM モジュールスプリッタ\n'
# 'LLVM profile data\n'
H799B04E164DC: 'LLVM プロファイルデータ\n'
# 'LMUL argument must be in the range [0,3] or [5,7]'
H3949F7728682: 'LMUL引数は範囲 [0,3] または [5,7] で指定する必要があります'
# 'LSR search space complexity limit'
H6C951DA0F280: 'LSR検索空間複雑度制限'
# 'LTO Options'
H45ADD610F25F: 'LTO オプション'
# 'LTO requires -fuse-ld=lld'
H1F6F6CBC7560: 'LTO では -fuse-ld=lld が必要です'
# 'Label.'
H213B873A2E3C: 'ラベル。'
# 'Lanai DAG->DAG Pattern Instruction Selection'
HF0BD56FB7903: 'Lanai DAG->DAG パターン命令選択'
# 'Lanai memory ALU combiner pass'
H6ECAF3A1B377: 'Lanai メモリ ALU コンビナー パス'
# 'Language standard to compile for'
HC9609252D3B1: 'コンパイル対象の言語規格'
# 'Large code model'
H6118BEDCF561: 'Large コード モデル'
# 'Large stride memory access threshold'
H0DDCC23DCFC1: 'Large ストライド メモリ アクセス閾値'
# 'Large stride memory access weight'
HD5651F61773D: 'Large ストライド メモリ アクセス重み'
# 'Last chance recoloring max depth'
HF4F4F97F3F0A: '最終チャンス リカラーの最大深さ'
# 'Last chance recoloring maximum number of considered interference at a time'
HB5BF2EA66D0A: '一括で考慮する最終チャンス リカラーの最大干渉数'
# 'Launch an out-of-process executor to run code'
HB7F275AE5070: 'コードを実行するためのプロセス外エグゼキュータを起動'
# 'Lazy Block Frequency Analysis'
HAEAE6F9C4ECD: 'Lazy ブロック頻度解析'
# 'Lazy Branch Probability Analysis'
H0F9273E7A928: 'Lazy ブランチ確率解析'
# 'Lazy Machine Block Frequency Analysis'
H58403538D0D3: 'Lazy マシン ブロック頻度解析'
# 'Lazy Value Information Analysis'
HD066D1FABC77: 'Lazy バリュー情報解析'
# 'Least BB number of huge function.'
H5201BDD0F5FF: '巨大関数の最小BB数。'
# 'Leave out unnecessary information when printing MIR'
HEE7C41A11713: 'MIR を出力する際不要な情報を省略'
# "Legalize the Machine IR a function's Machine IR"
H082594DE8633: '関数のマシン IR の合法化'
# 'Level of field padding for AddressSanitizer'
H02387EE95AC8: 'AddressSanitizer のフィールドパディングレベル'
# 'Lex file in raw mode and dump raw tokens'
H9BBDD925BA53: '原始モードでファイルを解析し、原始トークンをダンプする'
# 'Lex tokens from a .s file'
H4216F66AFBE5: '.sファイルからトークンを解析する'
# 'Lexical block.'
HDAAEFA6A8637: '語彙的ブロック。'
# 'Lexical scope level (File=0, Compile Unit=1).'
H7F636BA87B45: '語彙スコープレベル（ファイル=0、コンパイルユニット=1）。'
# 'Libraries to link dynamically'
H9E0097DC803F: '動的にリンクするライブラリ'
# "Like 'ExecutorNative' if ORC runtime provided, otherwise like 'GenericIR'"
H4792AD158E44: "ORCランタイムが提供されている場合'ExecutorNative'、そうでない場合は'GenericIR'に似たもの"
# 'Like -MD, but also implies -E and writes to stdout by default'
H09E4A86636C3: "'-MD'と同様だが、'-E'を暗黙に指定し、デフォルトで標準出力に書き込む"
# 'Like -MMD, but also implies -E and writes to stdout by default'
H3264A1580B97: "'-MMD'と同様だが、'-E'を暗黙に指定し、デフォルトで標準出力に書き込む"
# 'Like -O2 but optimize for code size above all else. Similar to clang -Oz. Same as -passes="default<Oz>"'
H2F3FC31B4B90: '\'-O2と同様だが、コードサイズを最優先に最適化。clang -Ozと類似。-passes="default<Oz>" と同じ\''
# 'Like -O2 but size-conscious. Similar to clang -Os. Same as -passes="default<Os>"'
H17C4D6C7AE33: '\'-O2と同様だが、サイズを意識した最適化。clang -Osと類似。-passes="default<Os>" と同じ\''
# 'Like -finstrument-functions, but insert the calls after inlining'
H71DE1A83F0E0: "'-finstrument-functions'と同様だが、インライン展開後に呼び出しを挿入する"
# 'Like -fmodules-decluse but requires all headers to be in modules'
H9B04279148C1: "'-fmodules-decluse'と同様だが、すべてのヘッダがモジュールである必要がある"
# "Like -fno-semantic-interposition but don't use local aliases"
H1E8DA2527D1D: "'-fno-semantic-interposition'と同様だが、ローカルエイリアスを使用しない"
# 'Like -printlineinfo but does not load the object first'
H4419DBB99339: "'-printlineinfo'と同様だが、オブジェクトを最初にロードしない"
# 'Like /Z7'
H4FD8854D9F4E: '/Z7に似た指定'
# 'Like /showIncludes but omit system headers'
H688724C80945: "'/showIncludes'と同様だが、システムヘッダを省略する"
# 'Limit all regclasses to N registers'
H63DA69AD987D: 'すべてのレジスタクラスをNレジスタに制限する'
# 'Limit block size to analyze in load/store widening pass'
H7ECB2D63C850: 'ロード/ストア拡張パスで解析するブロックサイズを制限する'
# 'Limit cases to analyze when converting a switch to select'
H4850FF8E3DC7: 'switchをselectに変換する際に解析するケースを制限する'
# 'Limit debug information produced to reduce size of debug binary'
H538935517F09: 'デバッグバイナリのサイズを削減するため、生成されるデバッグ情報を制限する'
# 'Limit float precision to the given value'
HF96C59869298: '指定された値に浮動小数点精度を制限します'
# 'Limit maximum recursion depth when calculating costs of speculatively executed instructions'
H66110CD9CA1F: '仮想実行される命令のコスト計算時の最大再帰深さを制限します'
# 'Limit on instruction search range in frame index elimination'
HBC1B1C08E702: 'フレームインデックス消去における命令検索範囲を制限します'
# 'Limit on the cost of instructions that can be repeated due to loop flattening'
HD92D80EEAC82: 'ループフラットニングによる繰り返しが可能な命令のコストを制限します'
# 'Limit on the number of reused registers in frame index elimination'
H607E68347FE8: 'フレームインデックス消去における再利用レジスタの数を制限します'
# 'Limit options in the Modules category to the specified module index'
HB070B9863405: 'モジュール カテゴリのオプションを指定されたモジュール インデックスに制限します'
# 'Limit ready list to N instructions'
H5F2D4380F5BB: 'N 個の命令にレディリストを制限します'
# 'Limit register pressure of scheduled loop'
H7D5776BBBD61: 'スケジュール済みループのレジスタプレッシャーを制限します'
# 'Limit the length of PHI chains to lookup'
H44DF903D7B74: '検索する PHI チェーンの長さを制限します'
# 'Limit the number of collected seeds groups in a BB to cap compilation time.'
HCB093C287DF8: 'BB 内の収集したシード グループの数を制限してコンパイル時間を抑制します'
# 'Limit the number of instructions to process (0 for no limit)'
H0F105AAF8005: '処理する命令の数を制限します（0 で制限なし）'
# 'Limit the number of loads analysed'
H27294DA00A2A: '解析するロードの数を制限します'
# 'Limit the number of operands to inline for Token Factors'
HEA9F8176A261: 'Token Factors のインライン化に使用するオペランドの数を制限します'
# 'Limit the number of registers available for integer arguments'
HD3D75863FAEB: '整数引数に利用可能なレジスタの数を制限します'
# 'Limit the number of times for the same StoreNode and RootNode to bail out in store merging dependence check'
H611EA77C379A: 'ストア マージング 依存関係チェックにおいて、同じ StoreNode と RootNode での中止回数を制限します'
# 'Limit the recursion depth when building a vectorizable tree'
HAF7BB4678550: 'ベクタライズ可能なツリーを構築する際の再帰深さを制限します'
# 'Limit the size of the SLP scheduling region per block'
HEAF5A10A6293: 'SLP スケジューリング領域のサイズをブロックごとに制限します'
# 'Limit the size of the seed bundle to cap compilation time.'
H4DFB40A73CC1: 'シード バンドルのサイズを制限してコンパイル時間を抑制します'
# 'Limits the range of tokens in -check file on which various features are tested. Example --check-lines=3-7 restricts testing to lines 3 to 7 (inclusive) or --check-lines=5 to restrict to one line. Default is testing entire file.'
H2A6188976AA0: 'チェック ファイルのトークン範囲を制限し、その範囲で機能テストを実行します。例: --check-lines=3-7 は3行から7行（両端含む）までをテスト対象に限定、または --check-lines=5 は1つの行のみを限定します。デフォルトはファイル全体をテストします。'
# 'Linalg ODS Gen from YAML'
H78D204B7569D: 'YAML から Linalg ODS Gen を生成します'
# 'Line kind to use when printing lines.'
H1ECE7CAA5A71: '行を出力する際に使用する行の種類。'
# 'Line qualifiers (Newstatement, BasicBlock, etc.).'
H20226D797BE3: '行修飾子 (Newstatement、BasicBlock など)。'
# 'Line tables'
H4C16BA3AF07D: '行テーブル'
# 'Linearize DAG, no scheduling'
HD1B44C093366: 'DAGを線形化、スケジューリングなし'
# 'Lines (DEBUG_S_LINES subsection)'
H916009E842F5: 'デバッグ情報のサブセクション DEBUG_S_LINES の行。'
# 'Lines referenced in the debug information.'
H59B1C9901129: 'デバッグ情報で参照される行。'
# 'Lines.'
HC7986E72D11E: '行。'
# 'Link Options'
HCC3832473F0F: 'リンカ オプション'
# 'Link XRay runtime library when -fxray-instrument is specified (default)'
H3CD4BCB6EB07: 'オプション -fxray-instrument 指定時に XRay ランタイム ライブラリをリンク (デフォルト)'
# 'Link against library X in the library search paths'
HCEDA0BA2279F: 'ライブラリ検索パス内のライブラリ X とリンク'
# 'Link against library X in the library search paths with hidden visibility'
H0C1A37003713: 'ライブラリ検索パス内のライブラリ X と hidden visibility を使用してリンク'
# 'Link against library X with hidden visibility'
H7FCFC84F1391: 'ライブラリ X を hidden visibility を使用してリンク'
# 'Link and internalize needed symbols from the given bitcode file before performing optimizations.'
H592432E99C1A: '最適化を実行する前に、指定されたビットコード ファイルから必要なシンボルをリンクし、内部化する。'
# 'Link as a hybrid ARM64X image'
H741A1167C632: 'ハイブリッド ARM64X イメージとしてリンク'
# 'Link builtin bitcodes after the optimization pipeline'
HA396158ACBD5: '最適化パイプラインの後に組み込みビットコードをリンク'
# 'Link clang-offload-bundler bundles for HIP'
HB7831777CE51: 'HIP のための clang-offload-bundler バンドルをリンク'
# 'Link device libraries for GPU device compilation'
H585B50C49350: 'GPU デバイス コンパイル用のデバイス ライブラリをリンク'
# 'Link only needed symbols'
H7CCE9D08A2A1: '必要なシンボルのみをリンク'
# 'Link stack frames through backchain on System Z'
H0C4B76743142: 'System Z でバックチェーンを通じてスタック フレームをリンク'
# 'Link the LLVM C Library for GPUs'
HD105C9964C21: 'GPU 用の LLVM C ライブラリをリンク'
# 'Link the following file lazily'
HB68406E1D5AC: '指定されたファイルを遅延リンクします'
# 'Link the given bitcode file before performing optimizations.'
H1729D1922ED4: '最適化を実行する前に、指定されたbitcodeファイルをリンクします。'
# 'Link two nested MLIR modules into a single LLVM IR module. Useful if both the host and device code can be run on the same CPU, as in SPIR-V CPU Runner tests.'
HF4FD097D1426: 'ネストした2つのMLIRモジュールを単一のLLVM IRモジュールにリンクします。ホストとデバイスコードが同じCPU上で実行可能な場合（例：SPIR-V CPUランナーのテスト）に便利です。'
# 'Linkage name.'
HC775F1647BB7: 'リンケージ名。'
# 'Linking with hot/cold operator new interfaces'
H1970EBF2160A: 'hot/cold operator new interfacesとのリンケージ'
# 'List bundle IDs in the bundled file.\n'
H3D67FC934FB6: 'バンドルファイル内のbundle IDの一覧を表示します。\n'
# 'List each file/graph name if/when it is linked'
H0D70E4352A2A: 'リンクされる際にファイル/グラフ名とそのリンク状況を表示します'
# 'List ignored files.'
H1A394A6B07E1: '無視されたファイルの一覧を表示します。'
# 'List of files with compilation or modularization problems for assistant mode.  This will be excluded.'
H7F26F6260A72: 'アシスタントモードでコンパイルまたはモジュライゼーションに問題のあるファイルの一覧。このリストの内容は除外されます。'
# 'List of functions to print disassembly for. Accept demangled names only. Only work with show-disassembly-only'
H3054F37FF6EE: '逆アセンブリを表示する関数の一覧。デマングル名のみを許可します。show-disassembly-onlyオプションと併用する必要があります'
# "List of key and value arguments. Required keywords are 'file' and 'triple'."
H45A6C5D3DB8C: "fileとtripleという必須キーワードを含むキーと値の引数リスト。必要なキーワードは'file'と'triple'です。"
# 'List of modes to link in by default into XRay instrumented binaries.'
HA0397880FB9D: 'XRayインストゥルメンテーション済みバイナリにデフォルトでリンクするモードの一覧。'
# 'List of symbols to export from the resulting object file'
H1BA25E23CBFD: '結果のオブジェクトファイルからエクスポートするシンボルのリスト'
# 'Live DEBUG_VALUE analysis'
H61CCF64E7BF9: 'DEBUG_VALUEのライブ分析'
# 'Live Interval Analysis'
H1E8AD554BB44: 'ライブ区間解析'
# 'Live Range Shrink Pass'
H1774992DE87F: 'ライブレンジ収縮パス'
# 'Live Register Matrix'
H01100D0853E2: 'ライブレジスタ行列'
# 'Live Stack Slot Analysis'
H2C770BB0409B: 'ライブスタックスロット分析'
# 'Live Variable Analysis'
HDDDE0A8181A8: 'ライブ変数解析'
# 'Load MIR Sample Profile'
HE68192F483EE: 'MIRサンプルプロファイルをロード'
# 'Load a pch file and use it instead of all code up to and including <filename>'
H2B4B69D546AF: 'pchファイルを読み込み、そのファイルまでを含むすべてのコードの代わりに使用します'
# 'Load all members of static archives'
H37DC6D24F9AF: '静的アーカイブのすべてのメンバーを読み込みます'
# 'Load all members of static archives that implement Objective-C classes or categories, or Swift structs, classes or extensions'
HCC377DE628E7: 'Objective-Cのクラスやカテゴリ、またはSwiftの構造体、クラス、拡張を実装する静的アーカイブのメンバーを読み込みます'
# 'Load and verify that a pre-compiled header file is not stale'
H71047E98C4FB: 'プリコンパイル済みヘッダーファイルを読み込み、古いバージョンでないことを確認します'
# 'Load bitcode directly into the new debug info format (regardless of input format)'
H5768E297180F: '入力形式に関わらず、ビットコードを新しいデバッグ情報フォーマットに直接読み込みます'
# 'Load dialects from plugin library'
H4452CA7D250C: 'プラグインライブラリからディアレクトを読み込みます'
# 'Load module without materializing metadata, then materialize only the metadata'
H43A90C52B97C: 'メタデータを実体化せずにモジュールを読み込み、その後メタデータのみを実体化します'
# 'Load pass plugin from a dynamic shared object file (only with new pass manager).'
HDC805E376CE5: 'ダイナミック共有オブジェクトファイルからpassプラグインを読み込みます（新しいpassマネージャーでのみ有効）'
# 'Load passes from plugin library'
H8D748D07CDD6: 'プラグインライブラリからpassesを読み込みます'
# 'Load shadow address into a local variable for each function'
HFDF300DF287B: '各関数に対してローカル変数にshadowアドレスを読み込みます'
# 'Load target address from GOT'
H9E377C7D35D0: 'GOT（Global Offset Table）からターゲットアドレスを読み込みます'
# 'Load the clang builtins module map file.'
H593B89CC5BB8: 'clangのbuiltinsモジュールマップファイルを読み込みます'
# 'Load the named plugin (dynamic shared object)'
HB2664DBBD1D2: '指定された名前のプラグイン（ダイナミック共有オブジェクト）を読み込みます'
# 'Load the specified plugin'
H92708A3C1B95: '指定されたプラグインを読み込みます'
# 'Load this module map file'
HF58B1913A1B8: 'このモジュールマップファイルを読み込みます'
# 'Load top-level profiles that the sample reader initially skipped for the call-graph matching (only meaningful for extended binary format)'
H98AEC89E8CA3: 'サンプルリーダーが最初に読み飛ばしたトップレベルのプロファイルを、コールグラフの一致用に読み込みます（拡張バイナリ形式でのみ意味があります）'
# 'Load, link and verify the resulting memory image.'
H9DA1560B06F8: '結果のメモリイメージを読み込み、リンクし、検証します'
# 'Load, link, and execute the inputs.'
H33C79A8E17E5: '入力ファイルを読み込み、リンクし、実行します'
# 'Load, link, and print line information for each function using the debug object'
HD0FE71B40225: 'デバッグオブジェクトを使用し、各関数の行情報を読み込み、リンクし、出力します'
# 'Load, link, and print line information for each function.'
HD0F8E4BC3426: '各関数の行情報を読み込み、リンクし、出力します'
# 'Local Stack Slot Allocation'
H9064C8611F98: 'ローカル・スタックスロットの割り当て'
# 'Local reassignment can yield better allocation decisions, but may be compile time intensive'
HDA7A0257A39E: 'ローカルの再割り当てはより良い割り当て決定をもたらす可能性がありますが、コンパイル時間が長くなる可能性があります'
# 'Local strategy.'
H69F9DACD1EB4: 'ローカル戦略。'
# 'Locations and Variables'
HAAA0526E734E: 'ロケーションと変数'
# 'Locations only'
H997812E5B96A: 'ロケーションのみ'
# "Log action execution to a file, or stderr if  '-' is passed"
H7DDDF7706229: 'アクションの実行をファイルに記録します。"-"が指定された場合はstderrに記録します'
# 'Look up implicit modules in the prebuilt module path'
H7389FC31B294: '事前構築モジュールパスから暗黙のモジュールを検索する'
# 'LoongArch DAG->DAG Pattern Instruction Selection'
HCE16825D2625: 'LoongArch DAG→DAGパターン命令選択'
# 'LoongArch Dead register definitions'
HAC29789F40DC: 'LoongArch 死んだレジスタの定義'
# 'LoongArch Merge Base Offset'
H4ADCE551F44A: 'LoongArch マージベースオフセット'
# 'LoongArch Optimize W Instructions'
HE6925B9D5E46: 'LoongArch W命令の最適化'
# 'LoongArch Pre-RA pseudo instruction expansion pass'
HABF2FA12711A: 'LoongArch プリRA仮命令展開パス'
# 'LoongArch atomic pseudo instruction expansion pass'
H9277CF038FA3: 'LoongArch アトミック仮命令展開パス'
# 'Loop Data Prefetch'
H4A7486BE5EE1: 'ループデータプリフェッチ'
# 'Loop Invariant Code Motion'
H1F7B4F47808C: 'ループ不変コード移動'
# 'Loop Strength Reduction'
HD2B0D185F01F: 'ループ強度低減'
# 'Loop Terminator Folding'
HA587F9DFACE9: 'ループ終端命令の折り畳み'
# 'Loop over the snippet'
H8CE72D20104F: 'スニペットをループする'
# 'Loop rescheduling'
H3C5B4019E9D4: 'ループの再スケジューリング'
# 'Loop-Closed SSA Form Pass'
HA93B03345334: 'ループクローズ SSA 形式パス'
# "LoopVersioningLICM's minimum allowed percentage of possible invariant instructions per loop"
H9A2539A9680F: 'LoopVersioningLICMの各ループの可能な不変命令の最小許可パーセンテージ'
# "LoopVersioningLICM's threshold for maximum allowed loop nest/depth"
H17B01644371B: 'LoopVersioningLICMの最大許可ループネスト/深さの閾値'
# 'Loops with a constant trip count smaller than this value will not use the count register.'
H9C4270A71595: 'この値未満の定数ループ回数を持つループは、カウントレジスタを使用しません。'
# 'Loops with a constant trip count that is smaller than this value are vectorized only if no scalar iteration overheads are incurred.'
HEB5EC35573F1: 'この値未満の定数ループ回数を持つループは、スカラ反復オーバーヘッドが発生しない場合にのみベクトル化されます。'
# 'Low level details'
H736A60384473: '低レベルの詳細'
# 'Lower @llvm.global_dtors via `__cxa_atexit`'
H38BCAF8DE61E: '@llvm.global_dtors を `__cxa_atexit` を通じて変換'
# 'Lower AArch64 MachineInstrs after legalization'
HAA249D8E7311: 'legalization 後の AArch64 MachineInstrs を変換'
# 'Lower Alloca'
H607A1E54E99B: 'Alloca を変換'
# 'Lower GPU ctor / dtors to globals on the device.'
HAFC608781787: 'デバイス上のグローバルに GPU コンストラクタ/デストラクタを変換'
# 'Lower MASSV entries'
HA1CC2E7E8DB7: 'MASSV エントリを変換'
# "Lower SwitchInst's to branches"
H254491D92394: 'SwitchInst を分岐に変換'
# 'Lower Unreachable'
H28B0408D99E5: 'Unreachable を変換'
# 'Lower aggregate copies, and llvm.mem* intrinsics into loops'
HF50CBF4651A2: 'アグリゲートコピーとllvm.mem* 組み込み関数をループに変換'
# 'Lower all intrinsic procedure implementation in their own functions'
H898AB0478AF6: '各関数内ですべての組込みプロシージャ実装を変換'
# 'Lower allocations to fortran runtime calls'
H567EFB84A4D9: '割り当てをFortranランタイムコールに変換'
# 'Lower arguments (NVPTX)'
H0BEAE5323F8F: '引数を変換 (NVPTX)'
# 'Lower atomic intrinsics to non-atomic form'
H691AF9D6E735: '原子的組み込み関数を非原子形式に変換'
# 'Lower atomics of local memory to simple load/stores'
H26EEFC4DB3B1: 'ローカルメモリの原子操作を単純なロード/ストアに変換'
# 'Lower bound for a buffer to be considered for stack protection'
HD34EE96BB584: 'スタック保護の対象となるバッファの下限'
# 'Lower ctors and dtors for AMDGPU'
HF7F8D40F075B: 'AMDGPU のコンストラクタとデストラクタを変換'
# 'Lower ctors and dtors for NVPTX'
HFEBDC177145F: 'NVPTX用のctorsとdtorsを下位に分解'
# 'Lower interleaved memory accesses to target specific intrinsics'
H47470ECDFD4E: 'ターゲット固有の組み込み関数に交互メモリアクセスを変換'
# 'Lower invoke and unwind, for unwindless code generators'
H0DB5191C7AE1: 'unwindを必要としないコード生成器向けにinvokeとunwindを下位に分解'
# 'Lower kernel argument loads in IR pass'
H46087569AE6A: 'IRパスでのカーネル引数の読み出しを下位に分解'
# 'Lower thread local variables'
HCFB0F36689FE: 'スレッドローカル変数を下位に分解'
# 'Lower threshold (in bytes) for widening to HVX vectors'
H2F815B7CEA99: 'HVXベクタへの拡張のためのしきい値（バイト単位）を設定'
# 'Lower to high level FIR'
H5AA0AFC0202E: '高レベルFIRへの変換'
# 'Lower uses of LDS variables from non-kernel functions'
H08631E6900A9: '非カーネル関数からのLDS変数の使用を下位に分解'
# 'Lower variables reachable from one kernel, otherwise abort'
H53F0B2E74B9F: '1つのカーネルから到達可能な変数を下位に分解、それ以外は中止'
# 'Lower via HLFIR transformational intrinsic operations such as hlfir.sum'
H6FB7E3DD0B99: 'hlfir.sumのようなHLFIR変換組み込み関数を経由して下位に分解'
# 'Lower via mixture of above strategies'
HC2846B7FC01C: '上記の戦略の混合を経由して下位に分解'
# 'Lower via module struct'
HA8D215D9A1DE: 'モジュール構造体を経由して下位に分解'
# 'Lower via table lookup'
HDC139AA56721: 'テーブル検索を経由して下位に分解'
# 'Lowers br_unless into inverted br_if'
H7B5FDAFDDAB0: 'br_unlessを逆転したbr_ifに変換'
# 'M68k DAG->DAG Pattern Instruction Selection'
H81D40D6EAF4E: 'M68k用のDAG→DAGパターン命令選択'
# 'M68k MOVEM collapser pass'
H0AB275B2A2C5: 'M68k MOVEM圧縮パス'
# 'M68k PIC Global Base Reg Initialization'
HD01B16D18C62: 'M68k PICグローバルベースレジスタ初期化'
# 'M68k pseudo instruction expansion pass'
H8C1C2FF3E960: 'M68k仮想命令展開パス'
# 'MC Options'
HF844BA7E67B9: 'MCオプション'
# 'MCJIT'
H06F256016480: 'MCJIT'
# 'MIPS DAG->DAG Pattern Instruction Selection'
H4A85ADA9A35B: 'MIPS DAG→DAGパターン命令選択'
# 'MIPS Specific: Compact branch policy.'
HDB7172F0C6EB: 'MIPS固有オプション: コンパクトブランチポリシー'
# "MIPS: Don't trap on integer division by zero."
H3C2E18133FF5: 'MIPS: 整数除算によるゼロ除算でトラップしない'
# 'MIPS: Emit R_{MICRO}MIPS_JALR relocation with jalr'
HED32A15E03DE: 'MIPS: jalr命令と共にR_{MICRO}MIPS_JALR再配置を生成'
# 'MIPS: Expand all branches to long format.'
H441E04A7504F: 'MIPS: すべての分岐を長形式に拡張'
# 'MIPS: Skip branch expansion pass.'
HDA9370733E14: 'MIPS: 分岐拡張パスをスキップ'
# 'MIPS: Try to allocate variables in the following sections if possible: .rodata, .sdata, .data .'
HE9B7319D8937: 'MIPS: 可能であれば、以下のセクションに変数を割り当てます: .rodata, .sdata, .data .'
# 'MIPS: Use gp_rel for data that is not defined by the current object.'
HD75E517CA71E: 'MIPS: 現在のオブジェクトで定義されていないデータにはgp_relを使用'
# 'MIPS: Use gp_rel for object-local data.'
H545674F997F2: 'MIPS: オブジェクトローカルデータにはgp_relを使用'
# 'MIPS: permit tail calls.'
H0C7FED214ED3: 'MIPS: 末尾コールを許可'
# 'MIR Printer'
H94EFB069787F: 'MIRプリンタ'
# 'MISSED'
HD46F0E6CE802: 'MISSED'
# 'MLIR CPU execution driver\n'
H6CE30C11490B: 'MLIR CPU実行ドライバー\n'
# 'MLIR LSP Language Server'
HC4C223FFD5B8: 'MLIR LSP言語サーバー'
# 'MLIR test case query tool.\n'
H55F5673383F5: 'MLIRテストケースクエリツール。\n'
# 'MLIR test case reduction tool.\n'
H51C59AF94F1B: 'MLIRテストケース削減ツール。\n'
# 'MS-style inline assembly is not available: %0'
H730B2A8B0BD8: 'MSスタイルのインラインアセンブリは利用できません: %0'
# 'MSF Container Options'
H3C329400C4C7: 'MSFコンテナーオプション'
# 'MSF File Options'
H4EFCF40C1C07: 'MSFファイルオプション'
# 'MSP430 DAG->DAG Pattern Instruction Selection'
H9B855DBB6F56: 'MSP430 DAG→DAGパターン命令選択'
# 'MVE gather/scattering lowering pass'
HEFE04D3A4063: 'MVE ガザ/スキャッタ ローリング パス'
# 'MVE lane interleaving'
H439E688DEBCA: 'MVE レーン インターリーブ'
# 'MVE tail-predication pass options'
H401525ED37E3: 'MVE テイル プレデイケーション パス オプション'
# 'Mach-O: dump the raw contents of the listed segments instead of parsing them:'
HD2ADEEA8E714: 'Mach-O: リストされたセグメントの生内容を解析する代わりにダンプします:'
# 'Machine Block Frequency Analysis'
H7E1FF2D34591: 'マシン ブロック頻度解析'
# 'Machine Branch Probability Analysis'
HDAEAA64E78E7: 'マシン 分岐確率解析'
# 'Machine CFG Printer Pass'
HEFF257D542EC: 'マシン CFG プリンター パス'
# 'Machine Check Debug Module'
H5340142C3573: 'マシン チェック デバッグ モジュール'
# 'Machine Common Subexpression Elimination'
H4C5AC03D0280: 'マシン 共通部分式除去'
# 'Machine Copy Propagation Pass'
H4162739F0E51: 'マシン コピー伝播 パス'
# 'Machine Cycle Info Analysis'
H573F9920FA64: 'マシン サイクル情報解析'
# 'Machine Debugify Module'
H1918B0E46C7D: 'マシン デバッグ用 モジュール'
# 'Machine Dominance Frontier Construction'
HACFFF417BF5C: 'マシン 優越フロンティア構築'
# 'Machine Function Outliner'
HEAF804C2398F: 'マシン 関数アウトライン'
# 'Machine Function Printer'
H5377EFCC5465: 'マシン 関数プリンター'
# 'Machine InstCombiner'
H33E9EB463E41: 'マシン InstCombiner'
# 'Machine Instruction Scheduler'
H83994F7A225C: 'マシン 命令スケジューラ'
# 'Machine Late Instructions Cleanup Pass'
H85C102FDCCD8: 'マシン 遅延命令クリーンアップ パス'
# 'Machine Loop Invariant Code Motion'
H4BBB4B53869D: 'マシン ループ不変コード移動'
# 'Machine Module Information'
HD424C5585BBC: 'マシン モジュール情報'
# 'Machine Natural Loop Construction'
H18E1BBE724BC: 'マシン・ナチュラル・ループ構造'
# 'Machine Sanitizer Binary Metadata'
H981195858AEF: 'マシン サニタイザ バイナリ メタデータ'
# 'Machine Strip Debug Module'
HC906EF4D8D67: 'マシン デバッグ モジュールの除去'
# 'Machine Trace Metrics'
HD6F5807E2725: 'マシン トレース メトリクス'
# 'Machine Uniformity Info Analysis'
HF8ED9A64EFA7: 'マシン 一様性情報解析'
# 'Machine code sinking'
H8D9C4D604139: 'マシン コード サンキング'
# 'Machine instruction scheduler to use'
H6D20879B4B16: '使用するマシン インストラクション シーダ'
# 'MachineDominator Tree Construction'
H0EB86F56D320: 'マシンDominator木構築'
# 'MachineLICM should avoid speculation'
HA9CBAFDEBFAA: 'MachineLICMは憶測を避けるべき'
# 'MachineLICM should hoist even cheap instructions'
H98697F2D8341: 'MachineLICMは安価な命令を含めすべて持ち上げる'
# 'MachinePostDominator Tree Construction'
H556CF668A622: 'マシンPostDominator木構築'
# 'Main file name to use for debug info and source if missing'
H28B54D392A83: 'デバッグ情報やソースが不足している場合に使用するメインファイル名'
# 'Make -gen-asm-parser emit assembly parser #N'
HE5BFEAE0A31B: '-gen-asm-parserを使用してアセンブリ・パーサ #N を生成'
# 'Make -gen-asm-writer emit assembly writer #N'
H1EC4E0DFB493: '-gen-asm-writerを使用してアセンブリ・ライター #N を生成'
# 'Make StdCall calling convention the default'
H597E577C2DF9: 'StdCall呼び出し規約をデフォルトにする'
# 'Make all profile counter updates atomic (for testing only)'
HF170445DE3AF: 'すべてのプロファイル・カウンタ更新を原子的に行う（テスト用のみ）'
# 'Make an absence of debug location information explicit.'
H9B828535ADE5: 'デバッグ位置情報の欠如を明示的に示す'
# 'Make assembler not emit warnings'
HE1F052382E9E: 'アセンブラが警告を出力しないようにする'
# 'Make assembler warnings fatal'
HE5A6B0140C8A: 'アセンブラの警告を致命的エラーとする'
# 'Make char type unsigned'
H0811C60DAE54: 'char型を符号なし型にする'
# 'Make counter updates atomic'
HF0DF6FDD3F46: 'カウンタの更新を原子的に行う'
# 'Make small offsets be this amount for testing purposes'
HA8D9F86D01B4: 'テスト目的で、小さなオフセットをこの量に設定する'
# 'Make the jump table addresses canonical in the symbol table'
H96E8C8D2BE5D: 'シンボルテーブル内のジャンプテーブルアドレスを標準化する'
# 'Make the x10 register call-saved (AArch64 only)'
HBF2D2B8AB5A7: 'x10 レジスタをcall-savedとする（AArch64専用）'
# 'Make the x11 register call-saved (AArch64 only)'
H361FBEA409F7: 'x11 レジスタをcall-savedとする（AArch64専用）'
# 'Make the x12 register call-saved (AArch64 only)'
HC22300ADD634: 'x12 レジスタをcall-savedとする（AArch64専用）'
# 'Make the x13 register call-saved (AArch64 only)'
H115B747B671D: 'x13 レジスタをcall-savedとする（AArch64専用）'
# 'Make the x14 register call-saved (AArch64 only)'
H3E53A0765B94: 'x14 レジスタをcall-savedとする（AArch64専用）'
# 'Make the x15 register call-saved (AArch64 only)'
HBD1C266220AD: 'x15 レジスタをcall-savedとする（AArch64専用）'
# 'Make the x18 register call-saved (AArch64 only)'
HFB92CC39C02E: 'x18 レジスタをcall-savedとする（AArch64専用）'
# 'Make the x8 register call-saved (AArch64 only)'
H346589ED29E7: 'x8 レジスタをcall-savedとする（AArch64専用）'
# 'Make the x9 register call-saved (AArch64 only)'
H2A86BF8B5845: 'x9 レジスタをcall-savedとする（AArch64専用）'
# 'Make time trace capture verbose event details (e.g. source filenames). This can increase the size of the output by 2-3 times'
HAFFB278A14B8: '時間トレースキャプチャの詳細なイベント情報を記録（例: ソースファイル名）。これにより出力サイズが2-3倍になる可能性があります'
# 'Mangling number exceeds limit (65535)'
HB23269E224B2: 'マングリング番号が制限値（65535）を超えています'
# 'Manifest Attributor internal string attributes.'
H94BF7FE1AB16: 'Attributorの内部文字列属性を明示します'
# 'Manually specify the CUDA feature to use'
HDDA17BF1758B: '使用するCUDA機能を手動で指定する'
# 'Map file source paths in debug info'
H1AD32AEEC75F: 'デバッグ情報内のマップファイルソースパスを設定する'
# 'Mapping between default visibility and export'
H9B100E19B599: 'デフォルトの可視性とエクスポート間のマッピング'
# 'Margin representing the unused percentage of the register pressure limit'
HC98A7EB598BA: 'レジスタ圧力制限の未使用パーセンテージを表すマージン'
# 'Mark code section jump table data regions.'
H820E75B4A88C: 'コードセクションのジャンプテーブルデータ領域をマークする'
# 'Mark cold functions with minsize.'
H17C76AA34906: 'minsize属性を使用してcold関数をマークします。'
# 'Mark cold functions with optnone.'
H16FE57B8D4DF: 'optnone属性を使用してcold関数をマークします。'
# 'Mark cold functions with optsize.'
H10A3EEBA4167: 'optsize属性を使用してcold関数をマークします。'
# 'Mark intrinsics that match the specified regexp as taking alias.scopes, noalias, and tbaa metadata'
H2D0DBCB8116B: '指定されたregexpに一致する組み込み関数を、alias.scopes、noalias、およびtbaaメタデータを取るようマークします。'
# 'Mark intrinsics that match the specified regexp as taking an access group metadata'
HFCB2F343E2E0: '指定されたregexpに一致する組み込み関数を、アクセスグループメタデータを取るようマークします。'
# 'Mark outline function calls with ColdCC'
H4A447EEA400F: 'ColdCC属性を使用してアウトライン関数コールをマークします。'
# 'Mark some metadata features uncovered in functions with associated no_sanitize attributes.'
H04B3B3707DAA: '関数内で見つかった一部のメタデータ機能を、関連するno_sanitize属性と共にマークします。'
# 'Mark the file as not needing an executable stack'
H4B702846F054: '実行可能スタックを必要としないファイルとしてマークします。'
# 'Marked up disassembly of strings of hex bytes'
HEACC40B7D059: '16進バイト列のディスアセンブリをマークアップします。'
# 'Match allocation profiles onto existing hot/cold operator new calls'
H6EADDFEDDECF: '既存のhot/coldオペレーターnewコールに割り当てプロファイルを一致させます。'
# 'Match functions using namespace and edit distance'
HE4F3BAC888AB: '名前空間と編集距離を使用して関数を一致させます。'
# 'Match functions with call graph'
HBB25B5D67EE6: 'コールグラフを使用して関数を一致させます。'
# 'Match profile with function hash'
H34EA8794C102: 'ハッシュ値を使用してプロファイルと関数を一致させます。'
# 'Match string for rename'
HFCC0109CD543: 'リネーム用の文字列を一致させます。'
# 'Max #stores to inline memcpy'
HD503383C20D0: 'インラインmemcpyに使用する最大ストア数'
# 'Max #stores to inline memmove'
HBA55FF5D30C1: 'インラインmemmoveに使用する最大ストア数'
# 'Max #stores to inline memset'
H2710D6276878: 'インラインmemsetに使用する最大ストア数'
# 'Max PHIs in BB to duplicate for jump threading'
H877E847520D6: 'ジャンプスレッディング用に複製するBB内のPHIの最大数'
# 'Max average trip count which will cause loop peeling.'
HF3BB048901AF: 'ループピーリングを引き起こす平均ループ回数の最大値'
# 'Max block size to duplicate for jump threading'
HBFBAF7D2C906: 'ジャンプスレッディング用に複製するブロックの最大サイズ'
# 'Max coefficients in AddRec during evolving'
H3496AC43AF41: 'AddRecの進化的最適化中の最大係数数'
# 'Max count of stack frame shrink-wraps'
H837664B5CADB: 'スタックフレームの縮小ラップの最大回数'
# 'Max depth to recursively search for missing frames through tail calls.'
HF33980EA2977: 'テ 尾呼出しが通じて欠落したフレームを再帰的に検索する最大深さ'
# 'Max integer bitwidth to consider in float2int(default=64)'
H564282CBC7AC: 'float2intで考慮する最大整数ビット幅 (デフォルト=64)'
# 'Max num VGPRs for whole-wave register allocation.'
H7B8CA4EA95B5: '全ウェーブレジスタ割り当てにおける最大VGPR数'
# 'Max num uses visited for identifying load invariance in loop using invariant start (default = 8)'
H482EC7115683: '不变開始を使用してループ内のロード不変性を特定する際に参照する最大使用数 (デフォルト=8)'
# 'Max number counter promotions per loop to avoid increasing register pressure too much'
H57369D9DCC7A: 'レジスタ圧力を過度に増加させないために、ループごとに許可されるカウンタープロモーションの最大数'
# 'Max number of BBs to explore for reachability analysis'
H59AE85966A2A: '到達可能性解析で探索する最大BB数'
# 'Max number of VRegs allowed to pass GC pointer meta args in'
HFCD4D70A5FD8: 'GCポインタメタ引数を渡すために許可される最大VRegs数'
# 'Max number of address users to look at'
H5E86D74534B7: 'アドレスユーザを確認する最大数'
# 'Max number of allowed counter promotions'
H870A811CD7E4: '許可されるカウンタープロモーションの最大数'
# 'Max number of annotations for a single indirect call callsite'
HEA902A4CD336: '単一の間接呼び出し呼び出しサイトあたりの注釈の最大数'
# 'Max number of basic blocks on the path between hoisting locations (default = 4, unlimited = -1)'
H48EFC5F46396: 'ヒーティング位置間のパス上の基本ブロックの最大数 (デフォルト=4、無制限=-1)'
# 'Max number of blocks searched to find a threading path'
HF1261B57416B: 'スレッディングパスを探すために探索するブロックの最大数'
# 'Max number of blocks to be partially inlined'
H7AAFBCD2FD5C: '部分インライン化されるブロックの最大数'
# 'Max number of blocks visited while enumerating paths around a switch'
H3917E93C3F69: 'スイッチ周辺のパスを列挙中に訪問するブロックの最大数'
# "Max number of blocks we're willing to speculate on (and recurse into) when deducing if a value is fully available or not in GVN (default = 600)"
HCC0B004EA3EE: 'GVNで値が完全に利用可能かどうかを推論する際に、想定して探索する（再帰する）ブロックの最大数 (デフォルト=600)'
# 'Max number of dependences to attempt Load PRE (default = 100)'
HAEF9EFC0D587: 'Load PREを試行する依存関係の最大数 (デフォルト=100)'
# 'Max number of devirtualizations for devirt module pass'
H37CF7FA70B53: 'devirtモジュールパスにおけるデバーチャル化の最大数'
# 'Max number of duplications by CHR for a region'
HB5C21E0295E9: 'CHRによる領域内の複製の最大数'
# 'Max number of instructions to hoist (default unlimited = -1)'
H1E95E88763B1: 'ホイストする命令の最大数 (デフォルトは無制限 = -1)'
# 'Max number of instructions to scan for aggressive instcombine.'
H5E9EDAFCAA29: 'アグレッシブ instcombine 用にスキャンする命令の最大数。'
# 'Max number of instructions to scan for vector combining.'
H596CAD742579: 'ベクター結合用にスキャンする命令の最大数。'
# 'Max number of instructions to scan in each basic block in GVN (default = 100)'
H8FA4F608C594: 'GVN で各基本ブロックでスキャンする命令の最大数 (デフォルト = 100)'
# 'Max number of iterations to be peeled from a loop, such that fusion can take place'
HA1B7957932D5: '融合を可能にするため、ループから分離する反復回数の最大値'
# 'Max number of iterations to prefetch ahead'
H74DE81E5BEDC: '事前取得する反復回数の最大値'
# 'Max number of memchecks allowed per eliminated load on average'
H929763545CE5: '1回の削除されたロードあたり平均で許可されるメモリチェックの最大数'
# 'Max number of memory uses to explore during partial unswitching analysis'
H5E2B4A7FE9D0: '部分的アンスイッチ分析中に探索するメモリ使用の最大数'
# 'Max number of mux expansions'
H413CD17EDBFC: 'mux展開の最大数'
# 'Max number of partial inlining. The default is unlimited'
HEF03ECFDE4EE: '部分インラインの最大数 (デフォルトは無制限)'
# 'Max number of paths enumerated around a switch'
H733A7744C96C: 'スイッチ周辺で列挙されるパスの最大数'
# 'Max number of precise value annotations for a single memopintrinsic'
H43400B846308: '1つの memopintrinsic に付与される正確な値の注釈の最大数'
# 'Max number of predecessors to consider tail merging'
H077931C4B5A6: 'テールマージを考慮するプレデケッサの最大数'
# 'Max number of promotions for a single indirect call callsite'
H1160EEB59410: '単一の間接呼び出し呼び出しサイトにおけるプロモーションの最大数'
# 'Max number of promotions for a single indirect call callsite in sample profile loader'
H05F78FEA2FAF: 'サンプルプロファイルローダにおける単一の間接呼び出し呼び出しサイトにおけるプロモーションの最大数'
# 'Max number of promotions for this compilation'
HBE53E07F67D3: 'このコンパイルにおけるプロモーションの最大数'
# 'Max number of segment coalescings'
H76831528316D: 'セグメント結合の最大数'
# 'Max number of statepoints allowed to pass GC Ptrs in registers'
HBF13380980F5: 'レジスタで GC ポインタを渡すためのステートポイントの最大数'
# 'Max number of stores to be predicated behind an if.'
HC838F9655113: 'if 文の後ろで条件付きにするストアの最大数。'
# 'Max number of visited instructions when trying to find dominating value of select dependency (default = 100)'
H9E6FEA476B9C: 'select 依存関係の支配値を特定する際の訪問命令の最大数 (デフォルト = 100)'
# 'Max number of vtables annotated for a vtable load instruction.'
H1F81EEE11A92: 'vtable読み込み命令に対するvtableの注釈の最大数。'
# 'Max results to display'
HB76D3DEE4518: '表示する結果の最大数。'
# 'Max size of a block which is still considered small enough to thread through'
H36A8554A7A20: 'スレッド処理に適した十分に小さなブロックの最大サイズ。'
# 'Max total number of preprocessed tokens for -Wmax-tokens.'
HC95A06179FBD: '-Wmax-tokensオプションのプリプロセス済みトークンの最大総数。'
# 'Maximal number of attributor iterations.'
HD46DDBA87859: 'Attributorの反復回数の最大値。'
# 'Maximal number of callees specialized for a call base'
HA4B29DB6599A: '呼び出しベースの呼び出し先関数の特殊化の最大数。'
# 'Maximal number of chained initializations (to avoid stack overflows)'
H907C6E291577: '連鎖した初期化の最大数（スタックオーバーフローを防ぐため）'
# 'Maximal number of fixpoint iterations.'
HD4791B6062DE: '固定点反復の最大回数。'
# 'Maximal number of uses to explore.'
H3B80E7F90921: '探索対象の使用箇所の最大数。'
# 'Maximize bandwidth when selecting vectorization factor which will be determined by the smallest type in loop.'
H1FD207584DE2: 'ループ内の最も小さな型によって決定されるベクトル化係数を選択する際、帯域幅を最大化する。'
# 'Maximize the band depth (yes/no)'
H16AE46F8C5D0: 'バンド深さを最大化する（はい/いいえ）'
# 'Maximum SLP vectorization factor (0=unlimited)'
HFDC1B422DFB3: 'SLPベクトル化係数の最大値（0=無制限）'
# 'Maximum alloca size to use for inline cost'
H85D97309D239: 'インラインコスト計算用のallocaサイズの最大値。'
# 'Maximum allowed iterations to unroll under pragma unroll full.'
H369A26E92574: '#pragma unroll fullで展開する際の最大反復回数。'
# 'Maximum amount of memory to use. 0 disables check. Defaults to 400MB (800MB under valgrind, 0 with sanitizers).'
HD9F29E050069: '使用するメモリ量の最大値。0に設定するとチェックが無効。デフォルトは400MB（valgrind下では800MB、sanitizers使用時は0）。'
# 'Maximum amount of nodes to process while searching SCEVUnknown Phi strongly connected components'
H733D2DA20417: 'SCEVUnknown Phiの強連結成分を検索する際の処理ノード数の最大値。'
# 'Maximum amount of shared memory to use.'
H87E40E4A881F: '共有メモリの使用量の最大値。'
# 'Maximum array size considered when doing a combine'
HA910C2785634: 'コンビネーション最適化を行う際の配列サイズの最大値。'
# "Maximum block frequency, expressed as a percentage of caller's entry frequency, for a call site to be considered cold for enabling coldcc"
H39E2E109FC72: 'コールサイトがcoldccを有効にするために「cold」であると見なされるブロックの頻度の最大パーセンテージ（呼び出し元のエントリーブロックの頻度に対する百分率）。'
# "Maximum block frequency, expressed as a percentage of caller's entry frequency, for a callsite to be cold in the absence of profile information."
HDD8AD6EFCAAB: 'プロファイル情報がない場合の「cold」コールサイト判定に使用するブロック頻度の最大パーセンテージ（呼び出し元のエントリーブロックの頻度に対する百分率）。'
# 'Maximum byte size to consider promote alloca to vector'
HDC8E89EF71AD: 'ベクターに昇格するため考慮するallocaの最大バイトサイズ'
# 'Maximum codesize growth allowed per function'
H78609FC7BCF8: '関数ごとに許可されるコードサイズの増加の最大値'
# 'Maximum cost accepted for the transformation'
H83731968FC73: '変換に受け入れられる最大コスト'
# 'Maximum cost multiplier of TCC_expensive for the dependence slice of a cold operand to be considered inexpensive.'
H6DFC35CF6D50: '冷たさオペランドの依存スライスが安価と見なされる場合のTCC_expensiveの最大コスト乗数'
# 'Maximum cost of combining conditions when folding branches'
H781B5E7517C1: 'ブランチの折り畳み時に条件を結合する際の最大コスト'
# 'Maximum depth allowed for the recursive algorithm used to explore MIV direction vectors.'
H1A8D3D915439: 'MIV方向ベクトルを探索するために使用される再帰アルゴリズムの最大深さ'
# 'Maximum depth for recursive loop guard collection'
H30DB13FC6626: '再帰ループガード収集の最大深さ'
# 'Maximum depth of loop nest considered for the transform'
HB49D9378BE58: '変換の対象となるループネストの最大深さ'
# 'Maximum depth of recursive SCEV complexity comparisons'
H91C70931DE15: '再帰的SCEV複雑さ比較の最大深さ'
# 'Maximum depth of recursive SCEV operations implication analysis'
H11D5122A9F0A: '再帰的SCEV操作の暗示分析の最大深さ'
# 'Maximum depth of recursive SExt/ZExt/Trunc'
HC985D30DDFD4: '再帰的SExt/ZExt/Truncの最大深さ'
# 'Maximum depth of recursive arithmetics'
HAE0E4B668E3D: '再帰的算術の最大深さ'
# 'Maximum depth of recursive constant evolving'
H729F236B8A12: '再帰的定数進化の最大深さ'
# 'Maximum depth of recursive value complexity comparisons'
HF2B077915503: '再帰的値複雑さ比較の最大深さ'
# 'Maximum distance between a tfr feeding a store we consider the store still to be newifiable'
HA3A3AE754AA0: 'ストアがまだnewifiableであると見なされる場合の、ストアにデータを供給するtfrまでの最大距離'
# 'Maximum distance of loop carried dependences that are handled'
HC5B916D346C8: '処理されるループキャリー依存の最大距離'
# 'Maximum factor by which expected native size may increase before blocking any further inlining.'
H1A06B982376C: 'インライン化をブロックする前に、予想されるネイティブサイズが増加する最大倍率'
# 'Maximum factor for an interleaved access group (default = 8)'
HCB89C86317C6: '(デフォルト=8) のインターリーブアクセスグループの最大倍率'
# 'Maximum frequency of path for an operand to be considered cold.'
H229E4B064589: 'オペランドが冷たさと見なされるパスの最大頻度'
# 'Maximum global merge offset'
HDC72CED70E8A: 'グローバルマージオフセットの最大値'
# 'Maximum input DBG_VALUE insts supported by debug range extension'
H5626CEECD47D: 'デバッグ範囲拡張機能でサポートされる最大入力 DBG_VALUE 命令数'
# 'Maximum input basic blocks before DBG_VALUE limit applies'
H05C4A13D67D8: 'DBG_VALUE 制限が適用される前の入力基本ブロックの最大数'
# 'Maximum instructions to analyze per moved initialization'
H28DB4399F2D2: '移動された初期化ごとに解析する最大命令数'
# 'Maximum instructions to consider tail duplicating'
H4A94E8A5FC9B: 'テール重複を検討するための最大命令数'
# 'Maximum instructions to consider tail duplicating blocks that end with indirect branches.'
H24A02DE8C7F1: '間接分岐で終わるテール重複ブロックを検討するための最大命令数'
# 'Maximum interleave factor for MVE VLDn to generate.'
H213FF805CEF2: 'MVE VLDn を生成する際の最大インターリーブ係数'
# 'Maximum length of a memory clause, instructions'
H7D54283EC716: 'メモリ句の最大長（命令数）'
# 'Maximum length of dependent chains to hoist (default = 10, unlimited = -1)'
HC4AAAE7F5958: '持ち上げるための依存チェーンの最大長（デフォルト = 10、無制限 = -1）'
# 'Maximum length of recurrence chain when evaluating the benefit of commuting operands'
H84087A27148D: 'オペランドの交換による利益を評価する際の再帰チェーンの最大長'
# 'Maximum nesting level for parentheses, brackets, and braces'
H62138B784DC3: '括弧、方括弧、波括弧の最大ネストレベル'
# 'Maximum num basic blocks before debug info dropped'
HF7FD1D6C6637: 'デバッグ情報が破棄される前の基本ブロックの最大数'
# "Maximum number of 'operator->'s to call for a member access"
H2363B77A7D06: "メンバアクセスのために呼び出す 'operator->' の最大数"
# 'Maximum number of BBs allowed in a function after inlining (compile time constraint)'
H02A0499B6C90: 'インライン後に関数内で許可される基本ブロックの最大数'
# 'Maximum number of ISL operations to invest for known analysis; 0=no limit'
H1E380A641D89: '既知の分析に投資する ISL 操作の最大数; 0=制限なし'
# 'Maximum number of base-updates to check generating postindex.'
HA9EAB9913B99: 'ポストインデックスを生成する際にチェックするベース更新の最大数'
# 'Maximum number of basic blocks in a function to run ext-TSP block placement.'
HEAD0A5AFAB52: 'ext-TSP ブロック配置を実行するための関数内の基本ブロックの最大数'
# 'Maximum number of branches in the accumulator tree'
HE163718A2F82: 'アキュムレータ木内の分岐の最大数'
# 'Maximum number of call targets per call site to enable branch funnels'
H2188104092EB: '呼び出しサイトごとにブランチファンネルを有効にする呼び出しターゲットの最大数'
# 'Maximum number of comparisons done when trying to merge runtime memory checks. (default = 100)'
H9FAF3F7149E1: 'ランタイムメモリチェックをマージしようとする際の比較回数の最大値（デフォルト = 100）'
# 'Maximum number of conditions in MC/DC coverage'
H6395D2BBFABE: 'MC/DC カバレッジにおける条件の最大数'
# 'Maximum number of cycles in the timeline view, or 0 for unlimited. Defaults to 80 cycles'
H17E412044F75: 'タイムライン ビュー内の最大サイクル数、または 0 で無制限。デフォルトは 80 サイクル'
# 'Maximum number of dataflow edges to traverse when evaluating the benefit of commuting operands'
H635DA15AA164: '代数的順序交換の利益を評価する際に走査するデータフロー エッジの最大数'
# 'Maximum number of dependences collected by loop-access analysis (default = 100)'
H498CAFF81EAD: 'ループ アクセス分析によって収集される依存関係の最大数（デフォルト = 100）'
# 'Maximum number of instruction to generate when lowering constant multiplication instead of calling library function [default=14]'
HA8EBACF52A9C: 'ライブラリ関数の呼び出しではなく展開する際に生成する命令の最大数 [デフォルト=14]'
# 'Maximum number of instructions for ObjectSizeOffsetVisitor to look at'
H87E9B845C1F1: 'ObjectSizeOffsetVisitor が確認する命令の最大数'
# 'Maximum number of instructions per speculated block.'
H9257791CBCD4: '各予測ブロックの最大命令数。'
# 'Maximum number of isl operations to invest for lifetime analysis; 0=no limit'
HEF3BE03FC67D: 'ライフタイム分析に投資する isl 演算の最大数; 0=制限なし'
# 'Maximum number of iterations SCEV will symbolically execute a constant derived loop'
H2F35B8D580F6: 'SCEV が定数派生ループを記号実行する際の最大反復回数'
# 'Maximum number of iterations to go through when propagating sample block/edge weights through the CFG.'
H76A911EDD837: '制御フロー グラフ (CFG) を通じてサンプル ブロック/エッジの重みを伝播する際の最大反復回数'
# 'Maximum number of iterations to print in timeline view'
H61122E3872D7: 'タイムライン ビューで表示する最大反復回数'
# 'Maximum number of iterations we keep dismantling potential values.'
HACE4628A8A6D: 'ポテンシャル値を削除し続ける最大反復回数'
# 'Maximum number of load-store instructions that should be handled in the dependency matrix. Higher value may lead to more interchanges at the cost of compile-time'
HC041FD354820: '依存関係行列で処理する負荷/ストア命令の最大数. 高い値はコンパイル時間を増加させますが, より多くのループ交換が行われる可能性があります'
# 'Maximum number of parameters for a split function'
H21349A957046: '関数分割に使用可能なパラメーターの最大数'
# 'Maximum number of physical registers which can be used for register mappings'
HDA7C27C95D63: 'レジスタ マッピングに使用可能な物理レジスタの最大数'
# 'Maximum number of potential values to be tracked for each position.'
H955218AAB793: '各位置で追跡するポテンシャル値の最大数'
# 'Maximum number of predicated jumps to be converted to New Value Jump'
HF3F6203AD570: 'プレディケート付きジャンプを New Value Jump に変換する最大数'
# 'Maximum number of prefixes to use for padding'
H7458F00CCA26: 'パディングに使用するプレフィックスの最大数'
# 'Maximum number of ptr states the optimizer keeps track of'
HB7E5E43FBE1D: '最適化が追跡するポインタ状態の最大数'
# 'Maximum number of replacements'
H6F2E3DB8E40F: '置換操作の最大数'
# "Maximum number of results to stream as a response to single request. Limit is to keep the server from being DOS'd. Defaults to 10000."
H8CFDD20881AA: 'シングル リクエストに対するレスポンスとしてストリーム化される結果の最大数。サーバーの DOS 攻撃防止のための制限です。デフォルトは 10000。'
# 'Maximum number of rows to keep in constraint system'
H99BCC72F0CE0: '制約システムに保持する行の最大数'
# 'Maximum number of simplification steps in HLIR'
H8BBD18037D20: 'HLIRでの簡略化ステップの最大数'
# 'Maximum number of split partitions'
HFE60C6DE65ED: '分割パーティションの最大数'
# 'Maximum number of test vectors in MC/DC coverage'
HAFD4B8816F42: 'MC/DC カバレッジにおけるテストベクターの最大数'
# 'Maximum number of threads (for emulation thread-local storage)'
H0870E5A4F08E: 'スレッドの最大数（エミュレーション用スレッドローカルストレージ用）'
# 'Maximum number of threads to use to process chunks. Set to 1 to disable parallelism.'
H35B2504140C1: 'チャンクを処理するために使用するスレッドの最大数。並列化を無効にするには1に設定してください。'
# 'Maximum number of times to run the full set of delta passes (default=5)'
H2DC8A9AE4C6B: 'デルタ パスの完全セットを実行する回数の最大値（デフォルト=5）'
# 'Maximum number of undroppable users for instruction sinking'
H51772496A3DD: '指令のシンキング（instruction sinking）でドロップ不可のユーザーの最大数'
# 'Maximum number phis to handle in intptr/ptrint folding'
H8EB042BFB02C: 'intptr/ptrintのフォールディングで処理するphiの最大数'
# 'Maximum of xors'
H1D5D83FA6AD6: 'XORの最大数'
# 'Maximum optimization to perform'
HE99B191AFFD1: '実行する最適化の最大レベル'
# 'Maximum predecessors (maximum successors at the same time) to consider tail duplicating blocks.'
HEA56889501D6: 'テール デュプリケーションのブロックを考慮する際の最大の predecessor（同時に最大の successor）'
# 'Maximum recursion depth when finding forked SCEVs (default = 5)'
H0BFBD51E5518: 'forked SCEV を検出する際の再帰の最大深さ（デフォルト=5）'
# 'Maximum recursion level'
HE3B9BD0F99EA: '再帰レベルの最大値'
# 'Maximum search distance for definition of CR bit spill on ppc'
H3E64147E3DA7: 'ppcでCRビット スpillの定義を探す最大距離'
# 'Maximum size for the name of non-global values.'
HD0F170A76DAC: '非グローバル値の名前の最大サイズ'
# 'Maximum size of ALL constants to promote into a constant pool'
H601F886CFD14: '定数プールに昇格するすべての定数の最大サイズ'
# 'Maximum size of IFMap'
H36B1B6A77B2F: 'IFMapの最大サイズ'
# 'Maximum size of OrderedRegisterList'
H272C7A54D906: 'OrderedRegisterListの最大サイズ'
# 'Maximum size of constant to promote into a constant pool'
H64D76AF05D3E: '定数プールに昇格する定数の最大サイズ'
# "Maximum size of range check type for which can be produced runtime overflow check of its limit's computation"
H186E992A3695: 'ランタイムオーバーフロー検査を生成できる範囲チェック型の最大サイズ'
# 'Maximum stages allowed in the generated scheduled.'
H48FD271D1F26: '生成されたスケジュールで許可されるステージの最大数。'
# 'Maximum successors (maximum predecessors at the same time) to consider tail duplicating blocks.'
H43B65927F125: 'テール重複化対象ブロックとして考慮する後続ブロック（同時に前駆ブロック）の最大数。'
# 'Maximum throughput from the decoders (instructions per cycle)'
H7563F8838724: 'デコーダからの最大スループット（1サイクルあたりの命令数）'
# 'Maximum time a channel may stay idle until server closes the connection, in seconds. Defaults to 480.'
HAA88BB6FEBEE: 'サーバーが接続を切断するまでチャンネルがアイドル状態でいる最大秒数。デフォルトは480秒です。'
# 'Maximum users to visit in copy from constant transform'
H0BCD40F173F6: '定数変換からコピーする際の最大ユーザー数'
# 'Maximum vector size (in 32b registers) to use when promoting alloca'
HBBF17E62FD6E: 'allocaをプロモートする際に使用する最大ベクターサイズ（32ビットレジスタ単位）'
# 'May have atomic operations on fine-grained memory'
HADF7ECC58A34: '細粒度メモリでアトミック操作が許可される'
# 'May have atomic operations on remote memory'
H32B8F16B1079: 'リモートメモリでアトミック操作が許可される'
# 'Measure the parse tree'
HCE9EAC149D17: 'パースツリーを計測'
# 'Medium code model'
H72290D3E5AED: '中間コードモデル'
# 'MemProf memory access profile'
H1BF9427AF0C9: 'MemProfメモリアクセスプロファイル'
# 'Member.'
H2A50D724340B: 'メンバ。'
# 'Memory Dependence Analysis'
H4CBD5FC4ABBF: 'メモリ依存性解析'
# 'Memory SSA'
H3A3FEB09FB66: 'メモリSSA'
# 'Memory reference level analysis that distinguish access instructions in the same statement'
H0AE95D83B775: '同じステートメント内のアクセス命令を区別するメモリ参照レベルの解析'
# 'Memory reference level analysis that distinguish accessed references in the same statement'
H4E1E23E6B24B: '同じステートメント内のアクセスされた参照を区別するメモリ参照レベルの解析'
# 'Merge all const globals without looking at uses'
H6449013A03CB: '使用箇所を確認せずにすべてのconstグローバルをマージ'
# 'Merge and hoist M0 initializations'
H2D268DBDEF86: 'M0の初期化をマージして上位に持ち上げる'
# 'Merge context profiles before calculating thresholds.'
H1C9DF3097EF8: 'しきい値を計算する前にコンテキストプロファイルをマージ'
# 'Merge context sample profiles whose count is below cold threshold'
HC6C3845D54A1: '冷閾値未満のカウントを持つコンテキストサンプルプロファイルを統合'
# 'Merge contiguous icmps into a memcmp'
H7D045C95D910: '連続したicmpをmemcmpに統合'
# 'Merge disjoint stack slots'
HC48D29B2D11A: '非連続のスタックスロットを統合'
# 'Merge global variables'
HBC9C437F360A: 'グローバル変数を統合'
# "Merge past inlinee's profile to outline version if sample profile loader decided not to inline a call site. It will only be enabled when top-down order of profile loading is enabled. "
H647C9F0ED977: 'サンプルプロファイルローダーがコールサイトをインライン化しないと判断した場合、アウトライン化されたバージョンにインライン関数のプロファイルを統合します。これは、プロファイル読み込みのトップダウン順序が有効な場合にのみ有効になります。'
# 'Merge the given AST file into the translation unit being compiled.'
H044732F67319: 'コンパイル中の翻訳単位に指定されたASTファイルを統合'
# "Method to generate ID's for compilation units for single source offloading languages CUDA and HIP: 'hash' (ID's generated by hashing file path and command line options) | 'random' (ID's generated as random numbers) | 'none' (disabled). Default is 'hash'. This option will be overridden by option '-cuid=[ID]' if it is specified."
HF56CB8DC51CB: "CUDA/HIPの単一ソースオフロード言語用コンパイル単位のID生成方法：'hash'（ファイルパスとコマンドラインオプションのハッシュからID生成） | 'random'（ランダムな数値でID生成） | 'none'（無効）。デフォルトは'hash'。'-cuid=[ID]'オプションが指定された場合は上書きされます。"
# 'MicroMips instruction size reduce pass'
H43AA98943979: 'MicroMips命令サイズ削減処理'
# "Microsoft compiler version number to report in _MSC_VER (0 = don't define it (default))"
H84908CA49591: 'Microsoftコンパイラで_MSC_VERに設定するバージョン番号（0=定義しない（デフォルト））'
# 'Middle half duplicate mode'
H18C80D21224E: '中間半分重複モード'
# 'Middle half loop mode'
H43135A085735: '中間半分ループモード'
# 'Min number of instructions to consider tail merging'
HCFE1247214B4: 'テールマージ対象とする最小命令数'
# 'Min percent of cold bytes matched to hint allocation cold'
HF5A0792EF995: '冷領域割り当てを示唆する最小冷バイト一致率'
# 'Min percent of cold bytes to hint alloc cold during cloning'
H30A19A7158C7: '複製時に冷領域割り当てを示唆する最小冷バイト率'
# 'Min stride to add prefetches'
H9E2620BA9D60: 'プレフェッチを追加する最小ストライド'
# 'MinGW specific. Disable support for automatic dllimport in code generation and linking'
H3256426D82B0: 'MinGW固有。コード生成とリンカでの自動dllimportサポートを無効化'
# 'MinGW specific. Enable code generation support for automatic dllimport, and enable support for it in the linker. Enabled by default.'
H2BCAB89FF663: 'MinGW固有。コード生成における自動dllimportサポートとリンカ側の対応を有効化（デフォルト有効）'
# 'MinInstrCount strategy.'
H611D13E20CE8: 'MinInstrCount戦略。'
# 'Minimal Transform dialect driver\n'
H4CF75EEC17A9: '最小変換方言ドライバ\n'
# 'Minimal common base load/store instructions triggering DS/DQ form preparation'
H0EEF17599CF6: 'DS/DQフォーム準備を触発する最小共通ベースの読み書き命令'
# 'Minimal common base load/store instructions triggering chain commoning preparation. Must be not smaller than 4'
H8810625AE483: 'チェーン共通化準備をトリガーする最小共通ベースのロード/ストア命令。4未満にはならない必要があります'
# 'Minimize AVX to SSE transition penalty'
H8DBDD3BC94CA: 'AVXからSSEへの移行ペナルティを最小化'
# 'Minimize number of registers used'
H4957842A8433: '使用するレジスタの数を最小化'
# 'Minimum BranchProbability to consider a region cold.'
HD5C5EDF501D8: 'ブロックをcold（低温）とみなすための最小BranchProbability値'
# 'Minimum block executions to consider its BranchProbabilityInfo valid'
HC699EC9E0880: 'BranchProbabilityInfoを有効とみなすための最小ブロック実行回数'
# "Minimum block frequency, expressed as a multiple of caller's entry frequency, for a callsite to be hot in the absence of profile information."
H7B3632E358D5: 'プロファイル情報がない場合、コールサイトをhot（高温）とみなすためのブロックの最小頻度。これは呼び出し元のエントリ頻度の倍数で表されます'
# 'Minimum density for building a jump table in a normal function'
H0D43760047E0: '通常の関数でジャンプテーブルを構築するための最小密度'
# 'Minimum density for building a jump table in an optsize function'
H6EFB80EE1C35: 'optsize関数でジャンプテーブルを構築するための最小密度'
# 'Minimum depth of loop nest considered for the transform'
H277B1F275C2D: '変換適用を考慮するループネストの最小深さ'
# 'Minimum distance between predicate definition and farther of the two predicated uses'
HBAA80BA0F268: '予測子定義と、2つの条件付き使用点のうちより遠いものの間の最小距離'
# 'Minimum gain per loop (in cycles) threshold.'
H563FE7251C8B: 'ループごとのゲイン（サイクル数）の最小閾値'
# 'Minimum length of accumulator chains required for the optimization to kick in'
HE6E58DA8C268: '最適化を発動するために必要なアキュムレータチェーンの最小長'
# 'Minimum number of extenders to trigger replacement'
HA7EB99ED5DCC: '置換をトリガーするために必要なエクステンダの最小数'
# 'Minimum number of similar functions with the same hash required for merging.'
H332DB9D9B554: '結合するために必要な同じハッシュを持つ類似関数の最小数'
# 'Minimum number of times a block must be executed to be retained.'
H78B91828296F: 'ブロックを保持するために必要な最小実行回数'
# "Minimum priority, runs on idle CPUs. May leave 'performance' cores unused."
H2308F82368EA: '最小優先度。アイドルCPU上で実行されます。これにより「パフォーマンス」コアが未使用になる場合があります'
# "Minimum profile count required for an optimization remark to be output. Use 'auto' to apply the threshold from profile summary"
H3D2B4D99467F: '最適化リマーカーを出力するために必要なプロファイルカウントの最小値。「auto」を使用すると、プロファイルサマリからしきい値を適用します'
# "Minimum profile count required for an optimization remark to be output. Use 'auto' to apply the threshold from profile summary."
H05750FA1DE8F: '最適化リマーカーを出力するために必要なプロファイルカウントの最小値。「auto」を使用すると、プロファイルサマリからしきい値を適用します。'
# 'Minimum ratio comparing relative sizes of each outline candidate and original function'
H4C5E36FE2F68: '各アウトライン候補と元の関数の相対的なサイズの最小比率'
# 'Minimum relative gain per loop threshold (1/X). Defaults to 12.5%'
H2DECB545864A: 'ループごとの相対ゲインの最小閾値（1/X）。デフォルトは12.5%'
# 'Minimum time granularity (in microseconds) traced by time profiler'
H82ABB54FDFA0: 'タイムプロファイラーで追跡される時間の最小単位（マイクロ秒単位）'
# 'Minimum type size in bits for breaking large PHI nodes'
HB05B1AF899B8: 'PHI ノードを分割する際の最小の型サイズ（ビット単位）'
# 'Mips VR4300 mulmul bugfix'
HBC6DCC9857CF: 'Mips VR4300 mulmulバグ修正'
# 'Miscellaneous Options'
HE9A41E28CF82: 'その他のオプション'
# 'Missing debug location (gaps).'
HCFAF9A1705D6: 'デバッグ位置の欠損（空白がある）'
# 'Mode for reading thread pointer'
H56EB4841FF26: 'スレッド ポインタを読み取るモード'
# 'Mode of the RegBankSelect pass'
HC6D74CC5D13F: 'RegBankSelect パスのモード'
# 'Model read-only scalar values in the scop description'
HEF37BBE0A859: 'scop 説明で読み取り専用スカラ値をモデル化する'
# 'Model the cost of loop rotation more precisely by using profile data.'
H5615ACF94C6A: 'プロファイル データを使用してループ回転のコストをより正確にモデル化します。'
# 'Modextract Options'
H29E9EFFE5231: 'Modextract オプション'
# 'Module & File Options'
HDFC5298823CB: 'モジュールとファイルのオプション'
# 'Module Options'
H15D7561EF70B: 'モジュール オプション'
# 'Module Summary Analysis'
H35F5D0BFCE0A: 'モジュール サマリー アナリシス'
# 'Module Verifier'
HB268B018B769: 'モジュール バリデータ'
# 'Module concatenation'
H521219EE1D9E: 'モジュールの連結'
# 'Module extractor'
HDE0289089F3A: 'モジュール エクストラクタ'
# 'Module summary index filename'
H3224F1E17512: 'モジュール サマリー インデックス ファイル名'
# 'Module summary info'
HCFDC7E39A72C: 'モジュール サマリー情報'
# 'Modulo Schedule test pass'
H9F5185006F74: 'モジュロ スケジューリング テスト パス'
# 'Modulo Software Pipelining'
HC40B97D6B9FA: 'モジュロ ソフトウェア ピペットライン'
# 'Move ARGUMENT instructions for WebAssembly'
H688758DE208F: 'WebAssembly用にARGUMENT命令を移動'
# 'Move/duplicate certain instructions close to their use'
HD38286726698: '特定の命令をその使用箇所に近づけて移動または複製'
# 'Multiplier to apply to threshold when determining whether or not to fold branch to common destination when vector operations are present'
HC6051096B6ED: 'ベクター演算が存在する場合、共通の宛先へのブランチを折り込むかどうかを判断する際の閾値に適用する乗数'
# 'Multiplier to bump up callsite threshold for previous inlining.'
H80636EF6462B: '前のインラインのためのcallsite閾値を増加させるための乗数'
# 'Multiplier to multiply cycle savings by during inlining'
H1D068428F9A5: 'インライン処理中にサイクルの節約量を乗じるための乗数'
# 'Multiply the `import-instr-limit` threshold for cold callsites'
HC6AF6BE5F0E1: 'cold callsitesのための`import-instr-limit`閾値を乗じる'
# 'Multiply the `import-instr-limit` threshold for critical callsites'
HA6A6A6EE28A9: 'critical callsitesのための`import-instr-limit`閾値を乗じる'
# 'Multiply the `import-instr-limit` threshold for hot callsites'
H4850606E5CF1: 'hot callsitesのための`import-instr-limit`閾値を乗じる'
# 'Must specify at least '
HEC0DF6B1AD3C: '少なくとも を指定する必要があります'
# 'My Pass Name'
H68A400666676: 'My Pass Name'
# 'N must be a power of two. Align loops to the boundary'
H2A7AB317ED00: 'Nは2のべき乗でなければなりません。ループを境界に合わせる'
# 'NVPTX Address space based Alias Analysis'
H9D1213E22820: 'NVPTX アドレス空間に基づくエイリアス解析'
# 'NVPTX Address space based Alias Analysis Wrapper'
HB227AE568CB7: 'NVPTX アドレス空間に基づくエイリアス解析ラッパー'
# 'NVPTX DAG->DAG Pattern Instruction Selection'
HB23F4D978D1F: 'NVPTX DAG->DAGパターン命令選択'
# 'NVPTX Forward Params'
H3B9CC422F869: 'NVPTX パラメータ転送'
# 'NVPTX Peephole'
H5BF795D76A44: 'NVPTX ピーヒール最適化'
# 'NVPTX ProxyReg Erasure'
HDFA70554F191: 'NVPTX ProxyReg削除'
# 'NVPTX Specific: 0 use sqrt.approx, 1 use sqrt.rn.'
H11B08A79FA4D: 'NVPTX固有: 0でsqrt.approxを使用、1でsqrt.rnを使用。'
# 'NVPTX Specific: Disable generation of f16 math ops.'
HDAF968D22832: 'NVPTX固有: f16数学演算の生成を無効化。'
# "NVPTX Specific: FMA contraction (0: don't do it 1: do it  2: do it aggressively"
HD36FDD8676CA: 'NVPTX固有オプション: FMAの結合 (0: 無効 1: 有効 2: エージェンシーベースで有効)'
# 'NVPTX Specific: force 4-byte minimal alignment for byval params of device functions.'
H40664A3C3B0F: 'NVPTX固有オプション: デバイス関数のbyval引数に対して4バイトの最小アライメントを強制する。'
# 'NVPTX Specific: schedule for register pressue'
H0940771EECAF: 'NVPTX固有オプション: レジスタ圧力に基づくスケジューリングを行う。'
# 'NVPTX Specific: whether to use lg2.approx for log2'
HDC539A3BEBE1: 'NVPTX固有オプション: log2計算でlg2.approxを使用するかどうか。'
# 'NVPTX Specifies: 0 use div.approx, 1 use div.full, 2 use IEEE Compliant F32 div.rnd if available.'
HADD307B6A067: 'NVPTX固有オプション: 0=div.approxを使用, 1=div.fullを使用, 2=利用可能な場合IEEE準拠F32 div.rndを使用。'
# 'NVPTX target requires CUDA 9.2 or above; CUDA %0 detected'
HC81CA29CBF97: 'NVPTXターゲットにはCUDA 9.2以上が必要です; 検出されたCUDAバージョンは%0です'
# 'NVVM reflection, enabled by default'
H0FD65ACF0E14: 'NVVMリフレクション (デフォルト有効)'
# 'Name for native GCC compiler'
H0AD88C41A101: 'ネイティブGCCコンパイラの名称'
# 'Name for the section containing cold functions extracted by hot-cold splitting.'
H350954655BC3: 'ホット-コールド分割で抽出したコールド関数を格納するセクション名。'
# 'Name of checks to match against'
HAD04C40729DF: '一致対象のチェック名'
# 'Name of op to match on'
H9F76B5F57ED0: '一致対象の演算子名'
# 'Name of project.'
HD47E84631ECF: 'プロジェクト名。'
# 'Name of the entry point transform symbol'
H9FE29477F41B: 'エントリポイント変換シンボル名'
# 'Name of the interesting-ness test to be run'
H01AA1C566B65: '実行する興味テストの名称'
# 'Name of the macro to be defined'
H74E9FD90F24A: '定義するマクロ名'
# 'Name of the macro to be defined -- ignored by mlir-pdll'
H03D44F059B30: '定義するマクロ名 -- mlir-pdllでは無視されます'
# 'Name of the macro to be defined -- ignored by mlir-src-sharder'
H3F90161CF695: '定義するマクロ名 -- mlir-src-sharderでは無視されます'
# 'Name of the split dwarf debug info file to encode in the object file'
HCFEFDA365E00: 'オブジェクトファイルにエンコードする分割DWARFデバッグ情報ファイル名'
# 'Namespace.'
HD451EBBFFEAD: 'ネームスペース。'
# 'Narrow LSR complex solution using expectation of registers number'
H13DBBF2C516C: 'レジスタ数の期待値に基づくLSR複合解の狭義化'
# 'Narrow LSR search space by filtering non-optimal formulae with the same ScaledReg and Scale'
HBD4BDD760DFA: 'ScaledReg と Scale が同じ最適でない式をフィルタリングして LSR の検索空間を絞り込む'
# 'Nary reassociation'
HAC5287C54D8E: 'N-ary 再結合'
# 'Natural Loop Information'
HB731CE00868C: '自然ループ情報'
# 'Neon vector size must be 64 or 128 bits'
H97DBFE49CD6B: 'Neon ベクターサイズは64ビットまたは128ビットでなければなりません'
# 'Nested profile, the input should be CS flat profile'
HA55917D514EC: 'ネストされたプロファイル。入力はCSフラットプロファイルである必要があります'
# 'Never'
H80C3052D33CC: '決してしない'
# 'Never Step Into.'
HA04C48D1B790: 'ステップインしない'
# 'Never detect stack use after return.'
HC4D92AB5F1A8: '戻り後にスタック使用を検出しない'
# 'Never dump input'
H182384737343: '入力をダンプしない'
# 'Never emit tail calls'
H295822EA6C7C: 'テールコールを生成しない'
# 'Never insert #include directives as part of code completion'
H6893E7F599D8: '#include ディレクティブをコード補完の一環として挿入しない'
# 'Never set the bit'
H77A3923DD75B: 'ビットを設定しない'
# 'Never track the overflow bit.'
HF22B430EF914: 'オーバーフロー ビットを追跡しない'
# 'New FS discriminators encoding (incompatible with the original encoding)'
H525B7044D16E: '新しい FS discriminator エンコーディング（オリジナルのエンコーディングと互換性なし）'
# 'New namespace.'
H7E03703F3B39: '新しい名前空間'
# 'New statement.'
HBA1639E60F46: '新しいステートメント'
# 'No Vectorization'
H1F3B2817613C: 'ベクタ化しない'
# 'No action'
HF34AC77F7E82: 'アクションなし'
# 'No checking'
H4F955C5DB2D5: 'チェックなし'
# 'No code generation'
H3AC7DD01B6EE: 'コード生成なし'
# 'No compression'
HB3E344B2C4BB: '圧縮なし'
# 'No constructors'
HAD09B30D8B5D: 'コンストラクタなし'
# 'No destructors'
H24AE7DC3B6A4: 'デストラクタなし'
# 'No effect'
H7ED12CB7B709: '効果なし'
# 'No extract instruction with offset 0'
HEB2933468549: 'オフセット0のextract命令はありません'
# 'No implicit externals allowed'
H6CDA41F7B635: '暗黙の外部宣言は許可されていません'
# 'No implicit typing allowed unless overridden by IMPLICIT statements'
HA46325FCDDD6: 'IMPLICITステートメントで上書きされない限り、暗黙の型推論を許可しません'
# 'No offloading entry generated while offloading is mandatory.'
H4E35CC32EE7C: 'オフローディングが必須の状態で、オフローディングエントリが生成されませんでした。'
# 'No optimizer'
HF1ED527BC3E1: '最適化なし'
# 'No profile correlation'
H7B0904A6A54F: 'プロファイル相関がありません'
# 'No speculation'
H4F7A24022364: '予測なし'
# 'No vector functions library'
H42FA0B1EA03D: 'ベクタ関数ライブラリなし'
# 'No verification'
H41C637F6055E: '検証がありません'
# 'Non-relocatable code'
H9A85EA682847: '再配置不可コード'
# 'None.'
H9A9707BE07DA: 'なし。'
# 'Normalize integers in CFI indirect call type signature checks'
H47F05B50721C: 'CFI間接コールの型シグネチャチェックで整数を正規化する'
# "Not emit the visibility attribute for asm in AIX OS or give all symbols 'unspecified' visibility in XCOFF object file"
H98251062C447: "AIX OSでのasmには可視性属性を出力しないか、XCOFFオブジェクトファイルで全てのシンボルに'unspecified'可視性を付与する"
# 'Number limit for gluing ld/st of memcpy.'
HD8077326B9B0: 'memcpyのld/st結合の数値制限'
# 'Number of addresses from which to enable MIMG NSA.'
HCE8A8E1997D3: 'MIMG NSAを有効にするアドレスの数'
# 'Number of backend threads'
HE56514D09150: 'バックエンドスレッドの数'
# "Number of blocks in the 'x' dimension"
H76CD51A21746: "'x'次元のブロック数"
# "Number of blocks in the 'y' dimension"
H6D16D2BE9F69: "'y'次元のブロック数"
# "Number of blocks in the 'z' dimension"
H2E857E7750A0: "'z'次元のブロック数"
# 'Number of compile threads'
H083DE0C34AB1: 'コンパイルスレッドの数'
# 'Number of cycles to assume for a call instruction'
H48B171D665C7: 'コール命令の実行サイクル数'
# 'Number of entries in the micro-op queue'
H6A848E9631B1: 'マイクロオペコードキューのエントリ数'
# 'Number of instructions to allow ahead of the critical path in sched=list-ilp'
H6B314605368E: 'sched=list-ilpでクリティカルパスより先に許可する命令数'
# 'Number of instructions to prefetch ahead'
HF2FFA16038B4: '事前読み込みで先読みする命令数'
# 'Number of interferences after which we declare an interference unevictable and bail out. This is a compilation cost-saving consideration. To disable, pass a very large number.'
H7D7A199C7C69: '干渉の数がこの閾値を超えると、その干渉を逐出不能と宣言しコンパイルコストを節約します。無効にするには非常に大きな数を指定してください。'
# 'Number of intervals to track'
HB4B7D2AC3D9C: '追跡する間隔の数'
# 'Number of iterations to run'
HE50757CD0D43: '実行する反復回数'
# 'Number of materialization threads to use'
H7A97C7DA89FF: '使用するマテリアル化スレッドの数'
# 'Number of merge threads to use (default: autodetect)'
H2EA5A0F7B460: '使用するマージスレッドの数（デフォルト：自動検出）'
# 'Number of metadatas above which we emit an index to enable lazy-loading'
H4896D21A9235: 'レイジーロードを有効にするためのメタデータ数の閾値'
# 'Number of output files'
H5DDB526BD36F: '出力ファイルの数'
# 'Number of partitions to use for parallel full LTO codegen, ld.lld only.'
HEC293753B227: 'ld.lldでのみ有効な並列完全LTOコード生成用パーティション数'
# 'Number of registers to limit to when printing regmask operands in IR dumps. unlimited = -1'
H0373C047E939: 'IRダンプでレジスタマスクオペランドを表示する際のレジスタ数制限値。無制限 = -1'
# 'Number of seconds program is allowed to run before it is killed (default is 300s), 0 disables timeout'
HE6EB2161F536: 'プログラムの実行許可時間（秒単位。デフォルト300秒）。0でタイムアウトを無効化'
# "Number of threads in the 'x' dimension"
H07DD57A90CC5: "'x'次元のスレッド数"
# "Number of threads in the 'y' dimension"
H986B3D9F34E9: "'y'次元のスレッド数"
# "Number of threads in the 'z' dimension"
HFC9646CFE097: 'z次元のスレッド数'
# 'Number of threads to use (0 = auto)'
H9A06154F2AD2: '使用するスレッド数（0 = 自動）'
# 'Number of times to divide chunks prior to first test'
H4AB8A9674250: '最初のテスト前にチャンクを分割する回数'
# 'Number of times to rerun the outliner after the initial outline'
H45429D789C93: '初期アウトライン後にアウトライナーを再実行する回数'
# 'Number of times to shuffle and verify use-lists'
HEBDA566F30F3: '使用リストをシャッフルして検証する回数'
# 'Number of tracked SGPRs before initiating hazard cull on memory wait'
H34DB613CB239: 'メモリウェイトで危険除去を開始する前の追跡SGPR数'
# "Number of triangle-shaped-CFG's that need to be in a row for the triangle tail duplication heuristic to kick in. 0 to disable."
HAF152F5B6E3F: '三角形CFGが連続する必要回数。0で無効化。三角形テール複製ヒューリスティックを有効にするためには、連続する三角形形CFGの数が必要です。0で無効化。'
# 'Number of unswitch candidates that are ignored when calculating cost multiplier.'
H4873CA41A98E: 'コスト乗数を計算する際に無視するアンスイッチ候補の数'
# 'Number of uses of a base pointer to check before it is no longer considered for post-indexing.'
H02421600E168: 'ポストインデックスの対象外になるまでベースポインタの使用回数をチェック'
# 'OBJECT_MODE setting %0 is not recognized and is not a valid setting'
HEC8A063EC23B: 'OBJECT_MODE設定%0は認識されず、有効な設定ではありません'
# 'ODS output filename'
H1E3A5BE01485: 'ODS出力ファイル名'
# 'OPTIONS:\n'
H90A71B46515B: 'オプション:\n'
# 'OVERVIEW: '
H41828FCAB87A: '概要: '
# 'ObjC ARC contraction'
H3B8218111844: 'ObjC ARC コンテクストの簡略化'
# 'Object file format name.'
H116E706BF6D9: 'オブジェクトファイル形式の名前'
# 'Objective-C GC does not allow weak variables on the stack'
H501EF197353A: 'Objective-CのGCはスタック上の弱い変数を許可しません'
# 'Objective-C declarations may only appear in global scope'
HBE7743C7A3D5: 'Objective-Cの宣言はグローバルスコープにのみ出現可能です'
# 'Objective-C dispatch method to use'
H71CD5643C8D8: '使用するObjective-Cディスパッチメソッド'
# 'Objective-C index expression has incomplete class type %0'
H3BF9CC2B38D9: 'Objective-Cのインデックス式は未完全なクラス型%0を持っています'
# 'Objective-C message has incomplete result type %0'
HA58AB6CD0922: 'Objective-Cメッセージは未完全な結果型%0を持っています'
# 'Objective-C methods as coroutines are not yet supported'
H197AF4BB9670: 'Objective-Cのメソッドとしてのコルーチンはまだサポートされていません'
# 'Objective-C object of type %0 is bridged to %1, which is not valid CF object'
HC21532E95928: '型%0のObjective-Cオブジェクトは、無効なCFオブジェクトである%1にブリッジされています'
# 'Objective-C++ Automatic Reference Counting standard library kind'
HBD2739B5128E: 'Objective-C++のARC (オートメーション参照カウント) 標準ライブラリの種類'
# 'Offloading entry for declare target variable %0 is incorrect: the address is invalid.'
H44B1C3BF0A67: 'declareターゲット変数%0のオフローディングエントリが不正です: アドレスが無効です'
# 'Offloading entry for declare target variable is incorrect: the address is invalid.'
H3668F9F00CF1: 'declareターゲット変数のオフローディングエントリが不正です: アドレスが無効です'
# 'Offloading entry for target region in %0 is incorrect: either the address or the ID is invalid.'
HB922AD26B2CB: 'ターゲット領域%0のオフローディングエントリが不正です: アドレスまたはIDが無効です'
# 'Offset element to print.'
HCA7A2283660F: '印刷するオフセット要素'
# 'Offsets are in UTF-16 code units'
H3B426E622CC8: 'オフセットはUTF-16コードユニットで表されます'
# 'Offsets are in UTF-8 bytes'
HB9A6C5C455E1: 'オフセットはUTF-8バイトで表されます'
# 'Offsets are in unicode codepoints'
H0151FBB5A950: 'オフセットはUnicodeコードポイントで表されます'
# 'Old namespace.'
HC6DBF56DB427: '古い名前空間'
# 'Omit all lfences before branch instructions.'
H64285876BCDE: 'ブランチ命令前のすべてのlfencesを省略'
# 'Omit all lfences other than the first to be placed in a basic block.'
HF3797EC0A201: 'ベーシックブロック内で配置される最初のlfence以外をすべて省略'
# 'Omit frame pointer setup for leaf functions'
HE755622424D0: 'リーフ関数のフレームポインタセットアップを省略'
# 'Omit function index section at the expense of single-function patching performance'
HE5E5A5FAB8F1: '単一関数パッチングのパフォーマンスを犠牲にし、関数インデックスセクションを省略'
# 'Omit the RTTI component from virtual tables'
H4D1372C43A35: 'バーチャルテーブルからRTTIコンポーネントを省略'
# "Omit the frame pointer from functions that don't need it. Some stack unwinding cases, such as profilers and sanitizers, may prefer specifying -fno-omit-frame-pointer. On many targets, -O1 and higher omit the frame pointer by default. -m[no-]omit-leaf-frame-pointer takes precedence for leaf functions"
H40ED6B28D90F: '不要な関数からフレームポインタを省略します。スタックアンワインディングの一部のケース（プロファイラーやサンタイザなど）では、-fno-omit-frame-pointerを指定する方が好ましい場合があります。多くのターゲットでは、-O1以上でデフォルトでフレームポインタを省略します。リーフ関数では、-m[no-]omit-leaf-frame-pointerオプションが優先されます'
# 'On AIX, request creation of a build-id string, "0xHEXSTRING", in the string table of the loader section inside the linked binary'
H9CC108588817: 'AIX上で、リンクされたバイナリ内のローダーセクションのストリングテーブルにbuild-id文字列「0xHEXSTRING」を作成するように要求'
# 'On Windows, do not emit /defaultlib: directives to link compiler-rt libraries'
H9E62CED5E13B: 'Windows上で、コンパイラ-RTライブラリをリンクするために/defaultlib:ディレクティブを発行しない'
# 'On Windows, emit /defaultlib: directives to link compiler-rt libraries (default)'
H84415BE98E65: 'Windows上で、コンパイラ-RTライブラリをリンクするために/defaultlib:ディレクティブを発行する（デフォルト）'
# 'One completion item for each semantically distinct completion, with full type information'
HE890AD8AA9F7: '意味的に区別される各補完ごとに、完全な型情報を持つ1つの補完項目'
# 'One shadow type id for each of `float`, `double`, `long double`. `d`,`l`,`q`,`e` mean double, x86_fp80, fp128 (quad) and ppc_fp128 (extended double) respectively. The default is to shadow `float` as `double`, and `double` and `x86_fp80` as `fp128`'
H95084AA4612D: '`float`、`double`、`long double`のそれぞれに対して1つの影の型ID。`d`、`l`、`q`、`e`はそれぞれ`double`、x86_fp80、fp128（quad）およびppc_fp128（extended double）を表します。デフォルトでは`float`を`double`、`double`とx86_fp80をfp128として影付けます'
# 'One statement per basic block'
HD6EC7448F7DB: '各基本ブロックごとに1つのステートメント'
# 'Only AST generation'
HCF69EA2C9F2B: 'AST生成のみ'
# 'Only a certain kind of dependences (all/raw)'
HDDC1270FFF46: '特定の種類の依存関係のみ（all/raw）'
# 'Only allow instructions before a call, if their cost is below DuplicationThreshold'
HF553DB6BFC41: 'そのコストがDuplicationThreshold以下の場合のみ、呼び出し前の命令を許可する'
# 'Only check if the module has objective-C defined in it'
H77EBD1C814CB: 'モジュールにObjective-Cが定義されているかどうかのみチェックする'
# "Only comparisons where inputs don't need [sz]ext."
HF4DF79025CD9: '[sz]extが不要な比較のみ'
# 'Only comparisons with sext result.'
H4718DE1FE775: 'sext結果を持つ比較のみ'
# 'Only comparisons with zext result.'
H13645F5A29D7: 'zext結果を持つ比較のみ'
# 'Only compile for the offloading device.'
H215BF96D8531: 'オフロードデバイス専用にコンパイルする'
# 'Only compile for the offloading host.'
H064D887D36F7: 'オフロードホスト専用にコンパイルする'
# 'Only consider IR changes for passes whose names match the specified value. No-op without -print-changed'
HEBE7550E221C: '指定された値と名前が一致するパスのIR変更のみを考慮する。-print-changedがない場合は何もしない'
# 'Only count the calls that are recursive'
H531F12291A31: '再帰的な呼び出しのみをカウントする'
# 'Only display members that contribute to class size.'
HAA83522F47FE: 'クラスサイズに寄与するメンバのみを表示する'
# 'Only display the basic block whose name matches this for all view-*-dags options'
HB71A82047A43: 'view-*-dagsオプションすべてで、名前が一致する基本ブロックのみを表示する'
# 'Only display whether errors occurred.'
HDB4BCEB24DBE: 'エラーが発生したかどうかのみを表示する'
# 'Only do the coverage check.'
HD8B2B9D841CB: 'カバレッジチェックのみ実行する'
# 'Only dump files with relative paths or absolute paths with the prefix specified by -s'
HD834488625EB: '-sで指定されたプレフィックスを持つ相対パスまたは絶対パスのファイルのみダンプする'
# 'Only emit EH frame entries when compact unwind is not available'
HBF3C0E4970CD: 'コンパクトアンワインドが利用できない場合のみ、EHフレームエントリを生成する'
# 'Only emit checks for arguments of functions whose names match the given regular expression'
HA389B7E0BDB5: '指定された正規表現に一致する関数名の引数に対してのみチェックを出力する'
# 'Only enable generating memmove in non-nested loops'
H29441902D683: 'ネストされていないループでのみ memmove の生成を有効にする'
# 'Only enumerate VLMAX for VL operand'
H6E315308AF5A: 'VL オペランドに対して VLMAX のみを列挙する'
# 'Only execute frontend initialization'
H918B5DDB51E1: 'フロントエンド初期化のみを実行する'
# 'Only functions matching the filter are shown in the output. For overlapping CSSPGO, this takes a function name with calling context.'
H189EF6F2A967: 'フィルターに一致する関数のみ出力に表示されます。重複する CSSPGO の場合は、コールコンテキストを含む関数名を指定します。'
# "Only fuse 'blessed' FP ops."
H7765353506F0: "'blessed' に指定された FP オペレーションのみを融合する"
# "Only fuse FP ops when the result won't be affected."
HDA090F75D8FD: '結果に影響がない場合のみ FP オペレーションを融合する'
# 'Only generate the minimal instruction sequence'
H0CBFA1B64E41: '最小の命令シーケンスのみを生成する'
# 'Only has an effect when specified with -print-pipeline-passes. Disables verifying that the textual pipeline generated by -print-pipeline-passes can be used to create a pipeline.'
HD2EDB018C926: '-print-pipeline-passes と併用した場合のみ有効。-print-pipeline-passes で生成されたテキストパイプラインがパイプラインを作成できるかの検証を無効化する'
# 'Only i32 comparisons in GPRs.'
HC06CC3A659A2: 'GPRs 内でのみ i32 比較を行う'
# 'Only i32 comparisons with sext result.'
HAF411A709509: 'sext 結果を持つ i32 比較のみを行う'
# 'Only i32 comparisons with zext result.'
HF0A9D937090A: 'zext 結果を持つ i32 比較のみを行う'
# 'Only i64 comparisons in GPRs.'
HD8F85598F6F1: 'GPRs 内でのみ i64 比較を行う'
# 'Only i64 comparisons with sext result.'
H43DD157FC439: 'sext 結果を持つ i64 比較のみを行う'
# 'Only i64 comparisons with zext result.'
H32746962EC6F: 'zext 結果を持つ i64 比較のみを行う'
# 'Only import first N functions if N>=0 (default -1)'
H22AE4A1BA0B0: 'N >= 0 の場合、最初の N 関数のみをインポートする（デフォルト -1）'
# 'Only import functions with less than N instructions'
HFF880FC2904D: 'N より少ない命令を持つ関数のみをインポートする'
# 'Only include passes which match a specified regular expression in the generated optimization record (by default, include all passes)'
H8C18E65FDB94: '生成された最適化レコードに、指定された正規表現に一致するパスのみを含める（デフォルトではすべてのパスを含む）'
# 'Only inline functions explicitly or implicitly marked inline'
H4FB05EC4AB48: '明示的または暗黙的にインライン指定された関数のみインライン化する'
# 'Only instrument 1 of N groups'
HE6DD6434319A: 'N グループのうち 1 グループのみをインストゥルメンテーションする'
# 'Only keep the intrinsics with the specified substring in their record name'
HCC2CC4639600: '指定されたサブストリングをレコード名に含む組み込み関数のみを保持する'
# 'Only lfence before groups of terminators where at least one branch instruction has an input to the addressing mode that is a register other than %rip.'
H7E6136B9D7D9: 'アドレスモードの入力として%rip以外のレジスタを使用する分岐命令が1つでも含まれる終端命令グループの直前にlfenceを挿入します。'
# 'Only loops with vectorization factor equal to or larger than the specified value are considered for epilogue vectorization.'
H4A61EE8AECF1: '指定された値と等しいかそれ以上のベクター化係数を有するループのみがエピローグのベクター化の対象となります。'
# 'Only match instructions with the given prefix'
H83B563F0FFD8: '指定されたプレフィックスを持つ命令のみを一致させる'
# 'Only output names of functions whose max count values are below the cutoff value'
HC54ECBB9C757: '最大カウント値が閾値未満の関数の名前のみを出力する'
# 'Only precompile the input'
H8B49F001F9E2: '入力を事前コンパイルのみ行う'
# 'Only print IR for functions whose name match this for all print-[before|after][-all] options'
HBF4D64D1868D: 'print-[before|after][-all] オプションのすべてのケースにおいて、名前が一致する関数のIRのみを出力する'
# 'Only print to a depth of N elements.'
HFC218BA7E9C0: '要素数Nまでの深さでのみ出力する'
# 'Only process files that match this filter. This flag only applies to all-TUs.'
H9C7DF00BB84A: 'このフィルターに一致するファイルのみ処理します。このフラグはすべてのTU（Translation Unit）に対してのみ有効です。'
# 'Only read thinlto index and print the index as LLVM assembly.'
H4D1BB8D241C8: 'thinltoインデックスのみを読み取り、LLVMアセンブリ形式でインデックスを出力します。'
# 'Only record optimization remarks from passes whose names match the given regular expression'
HB7A5156C3AD3: '指定された正規表現に一致する名前のパスからだけ最適化のメモを記録する'
# 'Only record remark information for passes whose names match the given regular expression'
H53791F3D3835: '指定された正規表現に一致する名前のパスに対してのみリマーク情報（注釈情報）を記録する'
# 'Only rename namespaces in files that match the given pattern.'
H3FFAEADCD3A9: '指定されたパターンに一致するファイル内の名前空間のみをリネームする'
# 'Only reorder expressions within a basic block when exposing CSE opportunities'
HEC96777F89E9: 'CSE（共通サブエクスプレッション）の機会を明確にする場合にのみ、ベーシックブロック内の式の順序を変更する'
# "Only run on certain regions (The provided identifier must appear in the name of the region's entry block"
H88F1D2665F48: '特定の領域のみで実行する（提供された識別子は領域のエントリーブロックの名前に含まれていなければなりません）'
# 'Only run on functions that match a regex. Multiple regexes can be comma separated. Scop detection will run on all functions that match ANY of the regexes provided.'
H1DBFD722220A: '正規表現に一致する関数のみで実行します。複数の正規表現はカンマで区切ります。Scop検出は、提供された正規表現のいずれかに一致する関数すべてに対して実行されます。'
# 'Only run ordered assignment scheduling with no codegen'
HD5721C8545D7: 'コード生成を行わずに、順序付けられた割り当てスケジューリングのみを実行する'
# 'Only run preprocess and compilation steps'
HF940D137E364: 'プリプロセスとコンパイルステップのみを実行する'
# 'Only run preprocess, compile, and assemble steps'
H81C1E28BCD95: 'プリプロセス、コンパイル、アセンブルステップのみを実行する'
# 'Only run scop detection, but no other optimizations'
HBD3276584517: 'スコープ検出のみを実行し、他の最適化は行わない'
# 'Only run the driver.'
H11F300F88E2D: 'ドライバのみ実行します。'
# 'Only run the preprocessor'
HCB8008C01361: 'プリプロセッサのみ実行します。'
# 'Only schedule this MBB#'
HAAC66E179615: 'このMBB#のみをスケジュールします。'
# 'Only schedule this function'
HDDB8FF491938: 'この関数のみをスケジュールします。'
# 'Only show debug message if the branch probability is greater than this value (in percentage).'
H364FCDA181C3: '分岐確率がこの値（パーセンテージ）より大きい場合にのみデバッグメッセージを表示します。'
# 'Only show debug message if the source branch weight is greater  than this value.'
HAD26C2C5503B: 'ソースの分岐ウェイトがこの値より大きい場合にのみデバッグメッセージを表示します。'
# 'Only show error-related paths in the analysis graph'
HA2114E4FC51E: '分析グラフでエラー関連のパスのみを表示します。'
# 'Only split jump tables containing functions whose sizes are less or equal than this threshold.'
H115A29858DAD: 'このしきい値以下である関数を含むジャンプテーブルのみを分割します。'
# 'Only split jump tables with size less or equal than JumpTableSizeThreshold.'
H159246FC6C6B: 'ジャンプテーブルのサイズがJumpTableSizeThreshold以下の場合のみを分割します。'
# 'Only supported on AArch64, PowerPC, RISC-V, SPARC, SystemZ, and X86'
H6BC9222A7886: 'AArch64、PowerPC、RISC-V、SPARC、SystemZ、およびX86のみでサポートされています。'
# 'Only try to inject loop invariant conditions and unswitch on them to eliminate branches that are not-taken 1/<this option> times or less.'
H93BBEDA4C81E: 'not-takenが1/<this option>回以下の場合の分岐を削除するため、ループ不変条件を注入し、それらを利用してアンスイッチする試みはこのオプションのみに限定します。'
# 'Only use DAG-combiner alias analysis in this function'
H9A1CF1A6CF3A: 'この関数でDAG-combinerエイリアス分析のみを使用します。'
# 'Only use warnings from specified component'
H87D3AEA990F7: '指定されたコンポーネントからの警告のみを使用します。'
# 'Only vectorize if you gain more than this number '
H4BBF18444D60: 'この数値より多くのベクトル化効果がある場合のみベクトル化します。'
# 'Only vectorize small trees if they are fully vectorizable'
H374794964C3E: '完全にベクトル化可能な場合のみ、小さなツリーをベクトル化します。'
# 'Only view functions that match this pattern'
H0D8068A91934: 'このパターンに一致する関数のみを表示します。'
# 'Only warn if #include directives are inside extern or namespace blocks if the included header is in the header list.'
H9AF148F3DBE5: '#includeディレクティブが、含まれたヘッダがヘッダリストにある場合に限り、externまたは名前空間ブロック内にある場合のみ警告を表示します。'
# 'Only write combined global index for ThinLTO backends'
HDCE16F222238: 'ThinLTOバックエンド用に統合グローバルインデックスのみを書き込みます。'
# 'Only write output if it changed'
H89C2A6721B4D: '出力が変更された場合のみ書き込みます。'
# 'Only write to the output file if it changed'
H82DD0380BC4C: '出力ファイルが変更された場合のみ書き込みます。'
# "OpenACC %select{clause '%1'|directive '%2'|sub-array bound}0 requires expression of integer type (%3 invalid)"
H24F0AB7B1FF3: "OpenACC %select{句 '%1'|ディレクティブ '%2'|サブ配列境界}0は整数型の式を必要とします (%3 が無効)"
# "OpenACC '%0' clause cannot appear on the same '%2' construct as a '%1' clause %select{inside a compute construct with a|and a}3 'num_gangs' clause with more than one argument"
H86F6667DC7E5: "OpenACC '%0' 句は '%2' コンストラクトで '%1' 句%select{コンピュート構造内の|と}3 'num_gangs' 句（引数が複数の場合）と同時に使用できません"
# "OpenACC '%0' clause on a 'declare' directive is not allowed at global or namespace scope"
H0D95AB23A6A9: "OpenACC 'declare' ディレクティブの '%0' 句はグローバルまたはネームスペースのスコープで使用できません"
# "OpenACC '%0' construct can only be applied to a 'for' loop"
H7F39DD2F9D48: "OpenACC '%0' コンストラクトは 'for' ループにのみ適用できます"
# "OpenACC '%0' construct must have a terminating condition"
HA5F584B3696E: "OpenACC '%0' コンストラクトには終了条件が必要です"
# "OpenACC '%0' construct must have at least one %1 clause"
H5108FA0063F8: "OpenACC '%0' コンストラクトには少なくとも1つの %1 句が必要です"
# "OpenACC '%0' construct must have initialization clause in canonical form ('var = init' or 'T var = init')"
HB6396996D535: "OpenACC '%0' 変数の初期化句は正規形式('var = init'または'T var = init')でなければなりません"
# "OpenACC '%0' variable must monotonically increase or decrease ('++', '--', or compound assignment)"
H4842B31AA1BD: "OpenACC '%0' 変数は単調増加または単調減少する必要があります('++', '--',または複合代入演算子)"
# "OpenACC '%1' clause %select{|with more than 1 argument }0may not appear on a '%2' construct with a '%3' clause%select{ with more than 1 argument|}0"
HE77D7FA4A4F6: "OpenACC '%1' 句%select{|引数が複数の場合 }0は '%2' コンストラクトの '%3' 句%select{の複数引数と|}0同時に使用できません"
# "OpenACC '%1' clause cannot appear more than once on a '%0' directive"
H22BA6A918DDE: "OpenACC '%1' 句は '%0' ディレクティブに複数回指定できません"
# "OpenACC '%1' clause is not valid on '%0' directive"
H226495157F78: "OpenACC '%1' 句は '%0' ディレクティブには無効です"
# "OpenACC 'bind' clause on a declaration must bind to the same name as previous bind clauses"
H9E597FA760BB: "OpenACC 'bind' 句は宣言で前回のbind句と同名のバインド先を指定する必要があります"
# "OpenACC 'collapse' clause loop count must be a %select{constant expression|positive integer value, evaluated to %1}0"
HF187F732137C: "OpenACC 'collapse' 句のループカウントは%select{定数式|正の整数値（%1に評価される）}0でなければなりません"
# "OpenACC 'gang' clause may have at most one %select{unnamed or 'num'|'dim'|'static'}0 argument"
HC064C4557CFE: "OpenACC 'gang' 句は%select{名前なしまたは'num'|'dim'|'static'}0引数を1つまで指定できます"
# "OpenACC 'reduction' composite variable must not have non-scalar field"
H9A717A5BB65E: "OpenACC 'reduction' 複合変数には非スカラフィールドを含めることはできません"
# "OpenACC 'reduction' variable must be a composite of scalar types; %1 %select{is not a class or struct|is incomplete|is not an aggregate}0"
HD35F9CAD567D: "OpenACC 'reduction' 変数はスカラ型の複合体でなければなりません;%1 %select{クラスまたは構造体ではありません|未完了型です|集約型ではありません}0"
# "OpenACC 'reduction' variable must be of scalar type, sub-array, or a composite of scalar types;%select{| sub-array base}1 type is %0"
HEC7D1B479B8F: "OpenACC 'reduction' 変数はスカラ型、サブ配列、またはスカラ型の複合体でなければなりません;%select{|サブ配列ベース}1の型は%0です"
# "OpenACC 'reduction' variable must have the same operator in all nested constructs (%0 vs %1)"
H28C388119D4E: "OpenACC 'reduction' 変数はネストしたコンストラクト全体で同一の演算子を使用する必要があります (%0 vs %1)"
# "OpenACC 'routine' directive with a name refers to a function with the same name as the function on the following line; this may be unintended"
H18CDEE7EFD75: "OpenACC 'routine' ディレクティブの名前指定は、次の行の関数と同じ名前の関数を指しています。意図しない可能性があります"
# "OpenACC 'tile' clause size expression must be %select{an asterisk or a constant expression|positive integer value, evaluated to %1}0"
HA638C30812B2: "OpenACC 'tile' 句のサイズ式は%select{アスタリスクまたは定数式|正の整数値（%1に評価される）}0でなければなりません"
# "OpenACC 'update' construct may not appear in place of the statement following a%select{n if statement| while statement| do statement| switch statement| label statement}0"
H3E931AFE1E4E: "OpenACCの'update'構造体は、%select{n if文| while文| do文| switch文| ラベル文}0の後のステートメントの代わりに使用できません"
# "OpenACC clause '%0' may not appear on the same construct as a '%1' clause on a '%2' construct"
HFD5E5BF152EC: "OpenACCの句'%0'は、'%2'構造体の'%1'句と同じ構造体で使用できません"
# "OpenACC clause '%0' may not follow a '%1' clause in a '%2' construct"
H3810BDC5F66B: "OpenACCの'%2'構造体において、'%0'句は'%1'句の後に続くことはできません"
# "OpenACC clause '%0' on '%1' construct conflicts with previous data dependence clause"
HD0EC8D82D89C: "OpenACCの'%1'構造体における'%0'句は、以前のデータ依存性句と衝突します"
# "OpenACC clause name '%0' is a deprecated clause name and is now an alias for '%1'"
H0277741A1F9D: "OpenACCの句名'%0'は非推奨の句名であり、現在'%1'のエイリアスです"
# "OpenACC construct '%0' cannot be used here; it can only be used in a statement context"
HCF6F4162FC42: "OpenACCの構造体'%0'はここでは使用できません。ステートメントコンテキストでのみ使用可能です"
# "OpenACC construct 'routine' with implicit function not yet implemented, pragma ignored"
H861502AB5841: "OpenACC構造体 'routine' に暗黙の関数が未実装のため、pragma が無視されました"
# "OpenACC construct 'self' has no effect when an 'if' clause evaluates to true"
H4B8F857AB30C: "OpenACCの構造体'self'は、'if'句がtrueを評価した場合、効果はありません"
# 'OpenACC integer expression has incomplete class type %0'
H5F66C1830606: 'OpenACCの整数式には未完了のクラス型%0があります'
# 'OpenACC integer expression requires explicit conversion from %0 to %1'
H20507033806F: 'OpenACCの整数式は%0から%1への明示的な変換が必要です'
# "OpenACC routine name '%0' does not name a function"
H5802CAE72248: "OpenACCのルーチン名'%0'は関数を指定していません"
# "OpenACC routine name '%0' names a set of overloads"
HEC7D774C632B: "OpenACCのルーチン名'%0'はオーバーロードの一連を指定しています"
# 'OpenACC sub-array %select{lower bound|length}0 evaluated to a value (%1) that would be out of the range of the subscripted array size of %2'
HD993EBC2FF56: 'OpenACCのサブ配列の%select{下限|長さ}0が、添字付き配列のサイズ%2の範囲外となる値(%1)に評価されました'
# 'OpenACC sub-array %select{lower bound|length}0 evaluated to negative value %1'
H9C42001B0E35: 'OpenACCのサブ配列の%select{下限|長さ}0が負の値%1に評価されました'
# 'OpenACC sub-array base is of incomplete type %0'
H568C42694CA4: 'OpenACCのサブ配列ベースは未完了の型%0です'
# 'OpenACC sub-array cannot be of function type %0'
H1F4C209C1D7A: 'OpenACCのサブ配列は関数型%0を指定できません'
# 'OpenACC sub-array length is unspecified and cannot be inferred because the subscripted value is %select{not an array|an array of unknown bound}0'
H3D8516DAE66C: 'OpenACCのサブ配列の長さは未指定で、推論できません。添字付き値が%select{配列ではありません|境界不明の配列}0のためです'
# 'OpenACC sub-array specified range [%0:%1] would be out of the range of the subscripted array size of %2'
H7C8F28679BDB: 'OpenACCのサブ配列の指定された範囲[%0:%1]は、添字付き配列のサイズ%2の範囲外です'
# 'OpenACC sub-array subscripted value is not an array or pointer'
H64A7517C6764: 'OpenACCのサブ配列の添字付き値は配列またはポインタではありません'
# "OpenACC variable %select{in 'use_device' clause|on 'declare' construct}0 is not a valid variable name or array name"
H5FFA8811F2EF: "OpenACCの変数%select{'use_device'句内の|'declare'構造体における}0は有効な変数名または配列名ではありません"
# 'OpenACC variable in cache directive is not a valid sub-array or array element'
H0DEC3018E66D: 'cacheディレクティブのOpenACC変数は、有効なサブ配列または配列要素ではありません'
# 'OpenACC variable is not a valid variable name, sub-array, array element,%select{| member of a composite variable,}0 or composite variable member'
HA8B26141C7C6: 'OpenACC変数は有効な変数名、サブ配列、配列要素%select{| 複合変数のメンバー,}0 または複合変数のメンバーではありません'
# 'OpenCL extension %0 is core feature or supported optional core feature - ignoring'
H1E2DAA7C8DD9: 'OpenCL拡張機能%0 はコア機能またはサポートされるオプション機能です - 無視されます'
# 'OpenCL extension %0 unknown or does not require pragma - ignoring'
HB7D9C7E097C0: 'OpenCL拡張%0が未知またはpragmaを必要としない - 無視します'
# 'OpenCL language standard to compile for.'
H165955277EF6: 'コンパイル対象のOpenCL言語仕様。'
# 'OpenCL only. Allow denormals to be flushed to zero.'
H8AAB3F5FE401: 'OpenCL専用。非正規数をゼロにフラッシュすることを許可。'
# 'OpenCL only. Allow floating-point optimizations that assume arguments and results are not NaNs or +-Inf.'
HD11F5701CC10: 'OpenCL専用。引数や結果にNaNや±Infが含まれないという前提の浮動小数点最適化を許可。'
# 'OpenCL only. Allow unsafe floating-point optimizations.  Also implies -cl-no-signed-zeros and -cl-mad-enable.'
HF643B16A83F5: 'OpenCL専用。危険な浮動小数点最適化を許可。同時に-cl-no-signed-zeros と -cl-mad-enable も設定されます。'
# 'OpenCL only. Allow use of less precise MAD computations in the generated binary.'
H9C454BE02287: 'OpenCL専用。生成されるバイナリで精度の低いMAD計算を使用することを許可。'
# 'OpenCL only. Allow use of less precise no signed zeros computations in the generated binary.'
H8DE8DC71375B: 'OpenCL専用。符号なしゼロ計算の精度を落として使用することを許可。'
# 'OpenCL only. Defines that the global work-size be a multiple of the work-group size specified to clEnqueueNDRangeKernel'
H3AFC0A3E3E23: 'OpenCL専用。グローバルワークサイズがclEnqueueNDRangeKernelで指定されたワークグループサイズの倍数であることを定義'
# 'OpenCL only. Disables all standard includes containing non-native compiler types and functions.'
H89344E39C234: 'OpenCL専用。ネイティブコンパイラー型や関数を含む標準インクルードを無効化します。'
# "OpenCL only. Enable or disable OpenCL extensions/optional features. The argument is a comma-separated sequence of one or more extension names, each prefixed by '+' or '-'."
H2870B3BCDE72: "OpenCL専用。OpenCL拡張機能/オプション機能を有効または無効にします。引数は'+'または'-'で始まる拡張名のカンマ区切りリストです。"
# 'OpenCL only. Generate kernel argument metadata.'
HD27868AF8559: 'OpenCL専用。カーネル引数のメタデータを生成します。'
# 'OpenCL only. Sets -cl-finite-math-only and -cl-unsafe-math-optimizations, and defines __FAST_RELAXED_MATH__.'
HA1D24030C687: 'OpenCL専用。-cl-finite-math-only と -cl-unsafe-math-optimizations を設定し__FAST_RELAXED_MATH__ を定義します。'
# 'OpenCL only. Specify that single precision floating-point divide and sqrt used in the program source are correctly rounded.'
H2DD948248943: 'OpenCL専用。プログラムソース内の単精度浮動小数点除算と平方根が正しく四捨五入されることを指定します'
# 'OpenCL only. This option disables all optimizations. By default optimizations are enabled.'
HB24BF4359851: 'OpenCL専用。このオプションで全ての最適化を無効化します。デフォルトでは最適化が有効です。'
# 'OpenCL only. This option is added for compatibility with OpenCL 1.0.'
HEF34F847970F: 'OpenCL専用。OpenCL 1.0との互換性のために追加されました。'
# 'OpenCL only. Treat double precision floating-point constant as single precision constant.'
H9F9807A3E0E7: 'OpenCL専用。倍精度浮動小数点定数を単精度定数として扱います。'
# 'OpenMP array shaping operation is not allowed here'
H6B78DAFB84E5: 'OpenMPの配列整形操作はここでは許可されません'
# 'OpenMP captured regions are not yet supported in %select{streaming functions|functions with ZA state|functions with ZT0 state}0'
HBFAEB31DF5F3: 'OpenMPキャプチャ領域は%select{ストリーミング関数|ZA状態の関数|ZT0状態の関数}0で未サポート'
# "OpenMP clause '%0' is only available as extension, use '-fopenmp-extensions'"
H7D732B734761: "OpenMP句'%0'は拡張機能のみで使用可、'-fopenmp-extensions'を指定"
# 'OpenMP constructs may not be nested inside a simd region%select{| except for ordered simd, simd, scan, or atomic directive}0'
HC65424272817: 'OpenMP構造体はsimd領域内でネスト不可%select{|ordered simd/simd/scan/atomicディレクティブは除く}0'
# 'OpenMP constructs may not be nested inside an atomic region'
HE2C47884F9E6: 'OpenMP構造体はatomic領域内でネスト不可'
# "OpenMP extension clause '%0' only allowed with '#pragma omp %1'"
HB7695EC8B674: "OpenMP拡張句'%0'は'#pragma omp %1'でのみ許可"
# 'OpenMP iterator is not allowed here'
HB9668BC52F3C: 'OpenMPイテレーターはここでは許可されません'
# 'OpenMP loop iteration variable cannot have more than 64 bits size and will be narrowed'
H85A842BD8107: 'OpenMPループ変数は64ビット超不可、縮小されます'
# "OpenMP offloading target '%0' is similar to target '%1' already specified; will be ignored"
H66F93F9F54F1: "OpenMPターゲット'%0'は既存'%1'と類似、無視されます"
# 'OpenMP only allows an ordered construct with the simd clause nested in a simd construct'
H52C83AA3C087: 'OpenMPはsimd構造体内でのsimd句付きordered構造体のみ許可'
# 'OpenMP standard version'
HA403864CFA0F: 'OpenMP標準バージョン'
# 'OpenMP support in flang is still experimental'
HA42DEF114A36: 'flangでのOpenMPサポートは実験的'
# "OpenMP target architecture '%0' pointer size is incompatible with host '%1'"
HF18160FDA94C: "OpenMPターゲットアーキテクチャ'%0'のポインターサイズはホスト'%1'と互換不可"
# "OpenMP target is invalid: '%0'"
H6461D2D7A8F6: "OpenMPターゲット無効: '%0'"
# 'Optimise without changing ABI'
H19D2D13E9ED7: 'ABI変更なしで最適化'
# 'Optimization level 0. Similar to clang -O0. Same as -passes="default<O0>"'
H809F6417B5CD: '最適化レベル0。clang -O0と同様。-passes="default<O0>"と同じ'
# 'Optimization level 1. Similar to clang -O1. Same as -passes="default<O1>"'
H563E0780E60E: '最適化レベル1。clang -O1と同様。-passes="default<O1>"と同じ'
# 'Optimization level 2. Similar to clang -O2. Same as -passes="default<O2>"'
H71099B09BC66: '最適化レベル2。clang -O2と同様。-passes="default<O2>"と同じ'
# 'Optimization level 3. Similar to clang -O3. Same as -passes="default<O3>"'
H73EA61C4E41D: '最適化レベル3。clang -O3と同様です。-passes="default<O3>"に相当します'
# 'Optimization level for NVVM compilation'
HA23F3D2204EA: 'NVVMコンパイル用の最適化レベル'
# "Optimization level. [-O0, -O1, -O2, or -O3] (default = '-O2')"
H8F5A63304993: "最適化レベル。[-O0, -O1, -O2, or -O3] (デフォルト = '-O2')"
# 'Optimization remarks file containing inline remarks to be replayed by cgscc inlining.'
HEFDDA07D8CA1: 'cgsccインライン処理で再現するインライン注釈を含む最適化注釈ファイル'
# 'Optimization remarks file containing inline remarks to be replayed by inlining from sample profile loader.'
H7FC66DD3A1D4: 'サンプルプロファイルローダーのインライン処理で再現するインライン注釈を含む最適化注釈ファイル'
# 'Optimizations available (use "-passes=" for the new pass manager)'
H61E922DB15A6: '利用可能な最適化 (新しいパスマネージャーを使用する場合は「-passes=」を指定してください)'
# 'Optimize AArch64 selected instructions'
HC4CE467B7223: 'AArch64の選択された命令を最適化'
# 'Optimize LiveIntervals for WebAssembly'
H18D7A3DF4B0B: 'WebAssembly用のLiveIntervalsを最適化'
# 'Optimize SCoPs using ISL'
HCB9C725F1344: 'ISLを使用したSCoPsの最適化'
# 'Optimize addressing mode'
HD2F645235970: 'アドレスモードを最適化'
# 'Optimize callbacks'
H4FA5D57DC24A: 'コールバックを最適化'
# 'Optimize calls with "returned" attributes for WebAssembly'
H77D4D84768F4: 'WebAssembly用のreturned属性付き呼び出しを最適化'
# 'Optimize for code generation'
HB09B7FAA4243: 'コード生成向けに最適化'
# 'Optimize for size'
H36D83A6CA81E: 'サイズ最適化'
# 'Optimize for size  (like /Og     /Os /Oy /Ob2 /GF /Gy)'
H45F672EE3075: 'サイズ最適化 (例: /Og /Os /Oy /Ob2 /GF /Gy)'
# 'Optimize for size (like clang -Os)'
HFB8E68DF5FCB: 'サイズ最適化 (clang -Osと同様)'
# 'Optimize for speed'
H56E47BC17587: '速度最適化'
# 'Optimize for speed (like /Og /Oi /Ot /Oy /Ob2 /GF /Gy)'
HC5F6A322D605: '速度最適化 (例: /Og /Oi /Ot /Oy /Ob2 /GF /Gy)'
# 'Optimize for speed (like clang -O3)'
HA3959EB2D045: '速度最適化（clang -O3 のような）'
# 'Optimize instrumentation'
H4C86894C9330: 'インストゥルメンテーションの最適化'
# 'Optimize machine instruction PHIs'
H86D600E2A81C: 'マシン命令のPHIsの最適化'
# 'Optimize memory intrinsic result values for WebAssembly'
HFC7D2A9B2DB2: 'WebAssembly向けのメモリ固有関数の結果値の最適化'
# 'Optimize selects'
H2F525E20DF58: 'Select命令の最適化'
# 'Optimize spill slots'
HE31BB3136FBC: 'スpillスロットの最適化'
# 'Optimize the memop size <= this value'
HD160B7A51C58: 'メモリオペレーションのサイズがこの値以下の場合の最適化'
# 'Optimizer Pipeline'
H226573EDB1C0: '最適化パイプライン'
# 'Option passed to ISL'
HA7C0FFCC5B20: 'ISLに渡されたオプション'
# 'Optional remark arg to filter collection by (accepts regular expressions).'
H3E0D571E2D16: 'オプションのリマーカー引数でコレクションをフィルタリング（正規表現を許可）。'
# 'Optional remark arg to filter collection by.'
H4BB3B1D09826: 'オプションのリマーカー引数でコレクションをフィルタリング。'
# 'Optional remark name to filter collection by (accepts regular expressions).'
H1C5E04FF9D98: 'オプションのリマーカー名でコレクションをフィルタリング（正規表現を許可）。'
# 'Optional remark name to filter collection by.'
H660F0832C261: 'オプションのリマーカー名でコレクションをフィルタリング。'
# 'Optional remark pass name to filter collection by (accepts regular expressions).'
H2B175B559D90: 'オプションのリマーカー パス名でコレクションをフィルタリング（正規表現を許可）。'
# 'Optional remark pass name to filter collection by.'
H4733818447B2: 'オプションのリマーカー パス名でコレクションをフィルタリング。'
# 'Optional remark type to filter collection by.'
HA70FC86A45D5: 'オプションのリマーカー種別でコレクションをフィルタリング。'
# 'Options for -gen-(attrdef|typedef|enum|op|dialect)-doc'
H639716290785: '-gen-(attrdef|typedef|enum|op|dialect)-doc のオプション'
# 'Options for -gen-asm-matcher'
H01AF394D0C16: '-gen-asm-matcher のオプション'
# 'Options for -gen-asm-parser'
H9ACA7721D57A: '-gen-asm-parser のオプション'
# 'Options for -gen-asm-writer'
HC2084E3135D4: '-gen-asm-writer のオプション'
# 'Options for -gen-attrdef-*'
H904334F41DE4: '-gen-attrdef-* のオプション'
# 'Options for -gen-bytecode'
H6F6AAAD1A1D2: '-gen-bytecode のオプション'
# 'Options for -gen-dag-isel'
H28817938BEA9: '-gen-dag-isel のオプション'
# 'Options for -gen-dialect-*'
HA2A748C26694: '-gen-dialect-* のオプション'
# 'Options for -gen-disassembler'
H7B14D2A69B34: '-gen-disassembler のオプション'
# 'Options for -gen-global-isel'
HAE024C7C3B27: '-gen-global-isel のオプション'
# 'Options for -gen-global-isel-combiner'
H4132B3D1DEF9: '-gen-global-isel-combiner のオプション'
# 'Options for -gen-instr-info'
H0D7A354B88C3: '-gen-instr-info のオプション'
# 'Options for -gen-intrinsic-enums'
H65B201D59766: '-gen-intrinsic-enums のオプション'
# 'Options for -gen-irdl-dialect'
HAAF45CF21F4C: '-gen-irdl-dialect のオプション'
# 'Options for -gen-pass-capi-header and -gen-pass-capi-impl'
H849A90D3FA97: '-gen-pass-capi-header および -gen-pass-capi-impl のオプション'
# 'Options for -gen-pass-decls'
HD4DF70DE63FF: '-gen-pass-decls のオプション'
# 'Options for -gen-python-op-bindings'
HFFB2EE013BDE: '-gen-python-op-bindings のオプション'
# 'Options for -gen-register-info'
H1593471B9CB0: '-gen-register-info のオプション'
# 'Options for -gen-sdnode-info'
H1CDBACD50609: '-gen-sdnode-info のオプション'
# 'Options for -gen-typedef-*'
H9F13AB96225A: '-gen-typedef-* のオプション'
# 'Options for -print-enums'
HCC367BFA06F6: 'オプション -print-enums'
# 'Options for gen-directive-decl'
HB3B2620C73DD: 'gen-directive-decl のオプション'
# 'Options for op definition generators'
H563831A68B15: 'オペレーション定義ジェネレーターのオプション'
# 'Options to disable Loop Idiom Recognize Pass.'
HEC1AFA3F201E: 'ループ・イディオム認識パスを無効にするオプション'
# 'Options to pass to the fuzzer'
H35D63FFBE491: 'フジッタに渡すオプション'
# 'Options: <empty>'
H86F57A40CF46: 'オプション: <empty>'
# 'Options: <empty>|Legal|Discard|Convert. If non-empty, ignore TargetTransformInfo and always use this transformation for the %evl parameter (Used in testing).'
H04319FFE1FD4: 'オプション: <empty>|Legal|Discard|Convert. これらの値が空でない場合、TargetTransformInfoを無視し、この変換を%evlパラメータで常に使用します（テスト用）。'
# 'Orc JIT'
H76C72319C493: 'Orc JIT'
# 'Orc-based lazy JIT.'
H732AA2A7BDF4: 'Orcベースの遅延JIT'
# 'Orc-specific linker'
HCE705FE1F603: 'Orc固有のリンカ'
# 'Order local stack symbols.'
H1D5554EC3474: 'ローカル・スタック・シンボルの順序付け'
# 'Other Options'
H9CB6F2FB01DF: 'その他のオプション'
# 'Outline loop blocks from loop chain if (frequency of loop) / (frequency of block) is greater than this ratio'
HB57131BBFAC5: 'ループ・チェーンからループ・ブロックを抽出するには、(ループの頻度)/(ブロックの頻度)がこの比率を超える場合'
# 'Output'
H4BED336194A9: '出力'
# 'Output .gcov in intermediate text format'
HF37052F8B66C: '.gcovファイルを中間テキスト形式で出力'
# 'Output Filename'
H253060EBAB8E: '出力ファイル名'
# 'Output Options'
HFCD12607F17F: '出力オプション'
# 'Output a side-by-side diff in HTML.'
H57654452ACF4: 'HTML形式で並列表示の差分を出力'
# 'Output assembly code file during compilation'
H6310B853EF5F: 'コンパイル中にアセンブリコードファイルを出力'
# 'Output assembly listing file'
H1DE8B74129C4: 'アセンブリリストファイルを出力'
# 'Output dwarf accelerator tables.'
H13E79CD2B348: 'DWARF アクセラレータテーブルを出力します。'
# 'Output file'
HB6AEEF874B66: '出力ファイル'
# 'Output file for export'
HF9225788216E: 'エクスポート用の出力ファイル'
# 'Output file. Can be specified multiple times for multiple output files.'
HEE2A7A1E3079: '出力ファイル。複数の出力ファイルを指定するには複数回指定できます。'
# 'Output filename'
H85DF5E35434C: '出力ファイル名'
# 'Output filename for pass remarks'
HB92A0E8D19B1: 'passの注釈用の出力ファイル名'
# 'Output filename for the reduced test case'
HD417AF7888E3: '簡略化されたテストケース用の出力ファイル名'
# 'Output format for line-based coverage reports'
H556FF7AB0CB0: '行ベースのカバレッジレポートの出力形式'
# 'Output format for timing data'
H55AABD7334B6: 'タイミングデータの出力形式'
# 'Output graphs with edge colors determined by this field'
H794FD3A570E0: 'このフィールドに基づいてエッジの色を決定するグラフを出力します'
# 'Output graphs with edges colored by this field'
HF746FFB4D465: 'このフィールドでエッジを色付けしたグラフを出力します'
# 'Output graphs with edges labeled with this field'
H24D87E28CEB2: 'このフィールドでエッジをラベル付けしたグラフを出力します'
# 'Output graphs with vertex colors determined by this field'
H074479A80832: 'このフィールドに基づいて頂点の色を決定するグラフを出力します'
# 'Output graphs with vertices colored by this field'
H2DF9C4C8C65F: 'このフィールドで頂点を色付けしたグラフを出力します'
# 'Output graphs with vertices labeled with this field'
HE53D4D1DCDFD: '頂点にこのフィールドのラベルを付けてグラフを出力します'
# "Output in chrome's trace event format. May be visualized with the Catapult trace viewer."
H9A05A1436798: 'Chromeのトレースイベント形式で出力します。Catapultトレースビューアで可視化できます。'
# 'Output input source as HTML'
HE9E58C4AFE0A: '入力ソースをHTMLとして出力します'
# 'Output instructions per ScopStmt'
H0963CFA695BF: 'ScopStmtごとの命令を出力します'
# 'Output object file'
H427E379BB7CB: 'オブジェクトファイルを出力します'
# 'Output options'
HCA4409BA27DC: '出力オプション'
# 'Output profile file'
H3C5CF3CF6071: 'プロファイル ファイルを出力'
# 'Output replacements as XML.'
H1724D4877353: 'XMLとして置換内容を出力'
# 'Output resource usage of launched kernels'
H76E82EB3BAF1: '起動したカーネルのリソース使用状況を出力'
# 'Output the total number corresponding to the count for the provided input file.'
H8049C03B1803: '提供された入力ファイルに対応するカウントの総数を出力'
# "Output trace to the given file name or '-' for stdout."
H8DCBEA863061: '指定されたファイル名または"-"（stdout）にトレースを出力'
# 'Outputs for view.'
H377C2CC892EF: 'ビューモード用の出力'
# 'Overapproximation of dependences'
HEFB667282405: '依存関係の過近似'
# 'Overlay the virtual filesystem described by file over the real file system'
H291889337D71: 'ファイルで記述された仮想ファイルシステムを実際のファイルシステムに重ねる'
# 'Overlay the virtual filesystem described by file over the real file system. Additionally, pass this overlay file to the linker if it supports it'
HAFADC554CE4B: 'ファイルで記述された仮想ファイルシステムを実際のファイルシステムに重ねます。さらに、リンカがサポートする場合はこのオーバーレイ ファイルを渡します'
# 'Override cost based safe divisor widening for div/rem instructions'
H81D91B0A076D: 'div/rem命令のコストに基づく安全な除数拡大を上書き'
# 'Override default dump names'
H7A6C6DC9BBC4: 'デフォルトのダンプ名を上書き'
# 'Override host target triple'
HF3CC7F9CE700: 'ホストのターゲット トリプルを上書き'
# 'Override inferred gcda file'
H68DED86E4EE4: '推論されたgcdaファイルを上書き'
# 'Override inferred gcno file'
H756521C312EE: '推論されたgcnoファイルを上書き'
# 'Override optimization level for codegen hooks, legacy PM only'
HCB07980F5249: 'codegenフックの最適化レベルを上書き（レガシ PMのみ）'
# 'Override output filename'
HAFF5159DAF01: '出力ファイル名を上書き'
# 'Override record layouts with those in the given file'
H3D9B83089303: '指定されたファイルのレコード配置を使用して上書き'
# "Override source file's content (in the overlaying\nvirtual file system) with input from <stdin> and run\nthe tool on the new content with the compilation\noptions of the source file. This mode is currently\nused for editor integration."
H9F6FADB4D508: 'オーバーレイ仮想ファイルシステム内のソース ファイルの内容を標準入力からの入力で上書きし、ソース ファイルのコンパイル オプションを使用してツールを実行します。このモードは現在エディター統合に使用されています'
# 'Override target triple detection'
H3331B75D4B40: 'ターゲット トリプルの検出を上書き'
# 'Override target triple for module'
HAD133DEC039A: 'モジュールのターゲット トリプルを上書き'
# "Override the 'argv[0]' value passed into the executing program"
HD3C4FA0CA7DA: "実行プログラムに渡される 'argv[0]' 値を上書きします"
# 'Override the behaviour of '
H053262A576A2: 'の動作を上書きします'
# 'Override the behaviour of expand-variadics'
H8E4D335E1CAD: 'expand-variadicsの動作を上書きします'
# 'Override the default ABI to return all structs on the stack'
H796683BA46B0: 'スタック上にすべての構造体を返すようにデフォルトのABIを上書きします'
# 'Override the default ABI to return small structs in registers'
H14D9E95511EF: 'レジスタに小さな構造体を返すようにデフォルトのABIを上書きします'
# 'Override the path to the output spec json file. See -ml-inliner-model-under-training documentation for the specification of that file.'
HA0B2BFC5945E: '出力仕様JSONファイルのパスを上書きします。そのファイルの仕様については、-ml-inliner-model-under-training のドキュメントを参照してください'
# 'Override the processor dispatch width'
HBBE12C3A519F: 'プロセッサのディスパッチ幅を上書きします'
# 'Override the profitability heuristics for Machine CSE'
H05022840BC44: 'Machine CSEの利益性ヘューリスティクスを上書きします'
# 'Override the variant of check applied to authenticated LR during tail call'
H929544275FD6: 'テールコール時に認証LRに適用されるチェックのバリエーションを上書きします'
# 'Override the vector register size in bits, which is otherwise found by querying TTI.'
H8FCFAFF95563: 'ベクタレジスタのサイズ（ビット単位）を上書きします。これは、通常はTTIの照会によって見つかります'
# 'Override the visibility of globals based on their final DLL storage class.'
HB70286716DCC: '最終的なDLLストレージクラスに基づいてグローバルの可視性を上書きします'
# 'Override unique ID of ctor/dtor globals.'
HA514528D025F: 'コンストラクタ/デストラクタグローバルの一意のIDを上書きします'
# 'Override use of color (default = isatty)'
HFB4A1E45D51F: '色の使用を上書き（デフォルト = isatty）'
# 'Override validator version for module. Format: <major.minor>;Default: DXIL.dll version or current internal version'
H29DBA8820EEB: 'モジュールのバリデータバージョンを上書きします。フォーマット: <major.minor>; デフォルト: DXIL.dll バージョンまたは現在の内部バージョン'
# 'Overrides result used for getMaximumVF query which is used exclusively by SLP vectorizer.'
H790D0193AFF1: 'SLP ベクタイザによって排他的に使用される getMaximumVF クエリで使用される結果を上書きします'
# 'Overrides the _OPENACC macro value for experimental testing during OpenACC support development'
H1F6C8876A478: 'OpenACC サポート開発中の実験テスト用に _OPENACC マクロの値を上書きします'
# 'Overwrite edited files.'
HA46F1C96B7DC: '編集されたファイルを上書きします'
# 'PASSED'
H75168D9452E2: 'PASSED'
# 'PBQP register allocator'
HC52F58BD0440: 'PBQP レジスタ割り当て器'
# 'PCH was compiled with different VFS overlay files than are currently in use'
H6654F3AEB3F7: 'PCH は、現在使用されているものと異なる VFS オーバーレイ ファイルでコンパイルされました'
# 'PDB Stream Options'
HE58091817322: 'PDB ストリーム オプション'
# 'PDLL Frontend'
H667EECC1B90F: 'PDLL フロントエンド'
# 'PDLL LSP Language Server'
HCB7860D44409: 'PDLL LSP ランゲージ サーバー'
# 'PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace, preprocessed source, and associated run script.\n'
H3E1C9F287454: 'PLEAE は、バグ報告を https://github.com/llvm/llvm-project/issues/ に提出してください。クラッシュ バックトレース、事前処理されたソース、関連する実行スクリプトを含めてください。\n'
# 'PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\n'
H0DE59CCB7CD2: 'PLEAE は、バグ報告を https://github.com/llvm/llvm-project/issues/ に提出してください。クラッシュ バックトレースを含めてください。\n'
# 'POSIX thread model'
HAAFA3F8D71A1: 'POSIX スレッド モデル'
# 'Pack non-contiguous assummed shape arrays into contiguous memory'
H3E0440CD78CB: '非連続の仮定形状配列を連続メモリにパックする'
# 'Pad previous instructions to implement align directives'
H461F83B5992B: 'アライン指定子を実装するために、前の命令をパディングする'
# 'Pad previous instructions to implement branch alignment'
H9A3FD2CE91B3: 'ブランチ アラインメントのために前の命令をパディングする'
# 'Pair of function name and filename, where function should be imported from bitcode in filename'
H0856646593E7: '関数名とファイル名のペア。関数は該当ファイル名のビットコードからインポートされます。'
# 'Parameter.'
H78B17095F0E6: 'パラメーター。'
# 'Parse OpenMP pragmas and generate parallel code.'
H203F2D0AAEA4: 'OpenMPのpragmaを解析し、並列コードを生成します。'
# 'Parse and pretty-print the input'
HE106679F4FE4: '入力を解析し整形表示する'
# 'Parse templated function definitions at the end of the translation unit'
H187BB681FD43: '翻訳単位の末尾にあるテンプレート関数定義を解析する'
# 'Partially inline calls to library functions'
HD08FDB669104: 'ライブラリ関数への呼び出しを部分的にインライン化する'
# 'Partition data sections using profile information.'
HBDB4D3B42575: 'プロファイル情報を利用してデータセクションを分割する。'
# 'Partition functions into N groups and select only functions in group i to be instrumented using -fprofile-selected-function-group'
H245EBE517AA5: '-fprofile-selected-function-group を使用して関数を N グループに分割し、グループ i のみをインストゥルメント化する'
# 'Partition functions into N groups using -fprofile-function-groups and select only functions in group i to be instrumented. The valid range is 0 to N-1 inclusive'
HE1BA0DFA9946: '-fprofile-function-groups を使用して関数を N グループに分割し、グループ i のみをインストゥルメント化する。有効な範囲は 0 から N-1（両端含む）です'
# 'Pascal string is too long'
HDF5B602956C9: 'Pascal 文字列が長すぎます'
# 'Pass -b <arg> to the linker on AIX'
HC027AB59908D: 'AIX のリンカに -b <arg> を渡す'
# 'Pass -z <arg> to the linker'
HC96FADA8EF05: 'リンカに-z <arg> を渡します'
# 'Pass <arg> to clang -cc1'
H7056B37839B2: 'clang -cc1 に <arg> を渡します'
# 'Pass <arg> to fatbinary invocation'
HE6E06CC967E5: 'fatbinary呼び出しに <arg> を渡します'
# 'Pass <arg> to plugin <name>'
H194FFD6DEF4E: 'プラグイン <name> に <arg> を渡します'
# 'Pass <arg> to the CUDA/HIP device compilation'
H6E93CAC5A2A4: 'CUDA/HIPデバイスコンパイルに <arg> を渡します'
# 'Pass <arg> to the CUDA/HIP host compilation'
HBD5864C8EAAC: 'CUDA/HIPホストコンパイルに <arg> を渡します'
# 'Pass <arg> to the assembler'
H260454350861: 'アセンブラに <arg> を渡します'
# 'Pass <arg> to the clang driver'
H0BA43F60ADF1: 'clangドライバに <arg> を渡します'
# 'Pass <arg> to the compilation if the target matches <arch>'
H28A6957698C7: 'ターゲットが <arch> と一致する場合コンパイル時に <arg> を渡します'
# 'Pass <arg> to the flang compiler'
HA8F1AD31AB5E: 'flangコンパイラに <arg> を渡します'
# 'Pass <arg> to the linker'
H47C4E471D4CC: 'リンカに <arg> を渡します'
# 'Pass <arg> to the offload linkers or the ones identified by -<triple>'
HF43CE14F52D9: '-<triple> で指定されたオフロードリンカやリンカに <arg> を渡します'
# 'Pass <arg> to the preprocessor'
HECFF1F09AA70: 'プリプロセッサに <arg> を渡します'
# 'Pass <arg> to the ptxas assembler'
HDA10BB61A91B: 'PTXアセンブラ ptxas に <arg> を渡します'
# 'Pass <arg> to the static analyzer'
H665CD83A1EA3: '静的解析器に <arg> を渡します'
# 'Pass <arg> to the target offloading toolchain identified by <triple>.'
HD393E82FA340: '<triple> で指定されたターゲットオフロードツールチェインに <arg> を渡します。'
# 'Pass <arg> to the target offloading toolchain.'
H786E5FF9D985: 'ターゲットオフロードツールチェインに <arg> を渡します。'
# 'Pass a workload definition. This is a file containing a JSON dictionary. The keys are root functions, the values are lists of functions to import in the module defining the root. It is assumed -funique-internal-linkage-names was used, to ensure local linkage functions have unique names. For example: \n{\n  "rootFunction_1": ["function_to_import_1", "function_to_import_2"], \n  "rootFunction_2": ["function_to_import_3", "function_to_import_4"] \n}'
H8F2A17B54334: 'ワークロード定義を指定します。これはJSONディクショナリを含むファイルです。キーはルート関数、値はルートを定義するモジュールにインポートする関数のリストです。-funique-internal-linkage-names オプションが使用されることを前提とし、ローカルリンケージ関数が一意な名前を持つようにします。例:\n{\n  "rootFunction_1": ["function_to_import_1", "function_to_import_2"], \n  "rootFunction_2": ["function_to_import_3", "function_to_import_4"] \n}'
# 'Pass all reduction arguments by reference'
H1F6E6E7DA880: 'すべての削減引数を参照渡しで渡す'
# 'Pass the comma separated arguments in <arg> to the assembler'
H0BB4ECAE0BD9: 'アセンブラに<arg>のカンマ区切り引数を渡します。'
# 'Pass the comma separated arguments in <arg> to the linker'
H01CAEC128AC9: 'リンカに<arg>のカンマ区切り引数を渡します。'
# 'Pass the comma separated arguments in <arg> to the preprocessor'
H596C87A5B391: 'プレプロセッサに<arg>のカンマ区切り引数を渡します。'
# 'Passes available:'
H13989372E812: '利用可能なパス:'
# 'Path and name to DWP file.'
H6E3C7CBCF218: 'DWPファイルのパスと名前。'
# 'Path of .dwp file. When not specified, it will be <binary>.dwp in the same directory as the main binary.'
H743B0B321E91: 'DWPファイルのパス。指定されない場合、メインバイナリと同じディレクトリ内の<binary>.dwpが使用されます。'
# 'Path of debug info binary, llvm-profgen will load the DWARF info from it instead of the executable binary.'
H7CB4490678CE: 'デバッグ情報用のバイナリのパス。llvm-profgenは実行可能ファイルではなくこのバイナリからDWARF情報を読み込みます。'
# 'Path of perf-script trace created by Linux perf tool with `script` command(the raw perf.data should be profiled with -b)'
H3DEF1722D3DA: 'Linux perfツールの`script`コマンドで作成したperf-scriptトレースのパス（raw perf.dataは-bオプションでプロファイル化する必要があります）。'
# 'Path of profiled executable binary.'
H3B42E7676CEA: 'プロファイリング済み実行可能バイナリのパス。'
# 'Path of raw perf data created by Linux perf tool (it should be profiled with -b)'
HFDF5B6ACDEB6: 'Linux perfツールで作成したraw perfデータのパス（-bオプションでプロファイリングする必要があります）。'
# 'Path of the LLVM sample profile'
H33F3BE9ADD2D: 'LLVMサンプルプロファイルのファイルパス。'
# 'Path of the unsymbolized profile created by `llvm-profgen` with `--skip-symbolization`'
H946923D050AC: 'プロファイリング用に`llvm-profgen`が`--skip-symbolization`オプションで作成したシンボルなしプロファイルのパス。'
# 'Path to CSV file containing lines of function names and attributes to add to them in the form of `f1,attr1` or `f2,attr2=str`.'
HAA93B63D725F: '関数名とそれらに追加する属性の一覧が記載されたCSVファイルのパス。形式は`f1,attr1`または`f2,attr2=str`です。'
# 'Path to SavedModel from the previous training iteration.\nThe directory is also expected to contain a JSON specification of the \noutputs expected to be logged, where the first entry must be the \ninlining decision. The file containing the specification should be \ncalled output_spec.json. The expected JSON value is an array of \ndictionaries. Each dictionary should have 2 keys: \n\n- "tensor_spec, followed by the TensorSpec description of the\noutput; and \n- "logging_name", a string indicating the name to use when\nlogging the output values. \n\nExample:\n[\n  {\n    "logging_name" : "some_name", \n    "tensor_spec" : { \n      "name" : "model_name", \n      "port" : 0,\n      "shape" : [2, 3],\n      "type" : "float"\n      }\n  }\n]\n\nThe first value must always correspond to the decision.'
H9AB7FF7DDB14: '前のトレーニングイテレーションからのSavedModelのパス。\nこのディレクトリには、出力として記録すべき仕様を記述したJSONファイルも存在することが期待されます。最初のエントリはインライン決定でなければなりません。\n仕様ファイルはoutput_spec.jsonという名前で保存されます。\nJSONの値は配列の辞書で、それぞれの辞書は以下の2つのキーを持たなければなりません:\n\n- "tensor_spec"、テンソルの仕様を記述する\n- "logging_name"、出力値を記録する際に使用する名前を示す文字列\n\n例:\n[\n  {\n    "logging_name" : "some_name", \n    "tensor_spec" : { \n      "name" : "model_name", \n      "port" : 0,\n      "shape" : [2, 3],\n      "type" : "float"\n      }\n  }\n]\n\n最初の値は必ずインライン決定に対応する必要があります。'
# 'Path to a directory containing a .clang-format file\ndescribing a formatting style to use for formatting\ncode when -style=file.\n'
H1C68FD05289D: 'フォーマットスタイルを指定する.clang-formatファイルが含まれるディレクトリのパス。\n-style=fileオプションでコード整形を行う際に使用されます。\n'
# 'Path to a system assembler, picked up on AIX only'
HD76EB0189931: 'AIXで使用されるシステムアセンブラのパス'
# 'Path to binary from which the profile was collected.'
HDF7F0FA583A9: 'プロファイルが収集されたバイナリのパス。'
# 'Path to file containing newline-separated [<weight>,]<filename> entries'
H39AF8CCE2C18: '各行に[<weight>,]<filename>で記述されたエントリが含まれるファイルのパス'
# 'Path to file containing the list of function symbols used to populate profile symbol list'
H85546B6474C7: 'プロファイルのシンボルリストを生成するために使用する関数シンボルの一覧ファイルのパス'
# 'Path to ignorelist file for sanitizers'
H685EED5F185D: 'sanitizers用のignorelistファイルのパス'
# 'Path to libomptarget-amdgcn bitcode library'
H409595E6068A: 'libomptarget-amdgcnビットコードライブラリへのパス'
# 'Path to libomptarget-nvptx bitcode library'
H1DFEDD2BDCE9: 'libomptarget-nvptxビットコードライブラリへのパス'
# 'Path to libomptarget-spirv bitcode library'
H17C48C664B7B: 'libomptarget-spirvビットコードライブラリへのパス'
# "Path to opt. (default: search path for 'opt'.)"
H87E2E1DC35F9: "optへのパス (デフォルト: 'opt' の検索パス)"
# 'Path to ptxas (used for compiling CUDA code)'
H902CF64E7382: 'ptxasへのパス（CUDAコードのコンパイルに使用）'
# 'Path to saved model evaluating native size from IR.'
H90E4D367F618: 'IRからネイティブサイズを評価する保存済みモデルへのパス。'
# 'Path to system headers on z/OS'
H858924F171F6: 'z/OS上のシステムヘッダへのパス'
# 'Path to system ignorelist file for sanitizers'
H6EB010D2085A: 'sanitizers用のシステムignorelistファイルへのパス'
# 'Path to the DIA SDK'
HEE09636C6E6A: 'DIA SDKへのパス'
# 'Path to the IR file produced by the frontend for the host.'
H6108420B0DC9: 'フロントエンドによって生成されたホスト用のIRファイルへのパス。'
# 'Path to the VCToolChain'
H5C43C23950E7: 'VCToolChainへのパス'
# 'Path to the Windows SDK'
H6252659C1D52: 'Windows SDKへのパス'
# 'Path to the YAML configuration file to be used for multilib selection'
H370257D7FAE7: 'マルチリブ選択に使用するYAML構成ファイルへのパス'
# 'Path to the file where tracer logs will be stored'
HB84166BE320D: 'トレーサーログが保存されるファイルへのパス'
# 'Path to the instrumented context sensitive profile.'
H374A91784042: 'インストゥルメンテーション済みコンテキスト依存プロファイルへのパス。'
# 'Path to the memory profile.'
H0F3D8AAD8CB7: 'メモリプロファイルへのパス。'
# 'Path to the prefetch hints profile. See also -x86-discriminate-memops'
HC95B0BC0D2ED: 'prefetchヒントプロファイルへのパス。-x86-discriminate-memopsも参照してください'
# 'Path to the profile remapping file.'
H16575118DC15: 'プロファイルリマップファイルへのパス。'
# 'Path to the profile.'
H327691C6666D: 'プロファイルのパス。'
# 'Path to the project. Required when connecting using remote index.'
HD4FC494735F6: 'プロジェクトのパス。リモート インデックスを使用して接続する場合に必要です。'
# 'Path to where .dwo files will be written out to.'
H41452088F682: 'dwo ファイルが書き込まれる場所のパス。'
# 'Path where the development - mode inlining log is saved.'
H72974DF4C8AA: '開発モード インライン ログが保存されるパス。'
# 'Pathname where the element is defined.'
H33A4EFF1B837: '要素が定義されているパス名。'
# 'Peephole Optimizations'
H6FFA8D4ADC02: 'ピープホール最適化'
# 'Penalty of calling a function that requires a change to PSTATE.SM'
H135B935B6400: 'PSTATE.SMの変更を必要とする関数を呼び出す際のペナルティ'
# 'Penalty of inlining a call that requires a change to PSTATE.SM'
HF8B0216049CB: 'PSTATE.SMの変更を必要とする呼び出しをインライン化する際のペナルティ'
# 'Percentage of prologue execution count to use as threshold when evaluating whether a block is cold enough to be profitable to move eligible spills there'
HB814EF09C393: 'ブロックが十分に寒い（cold）かどうかを評価する際、その移動が利益になるかどうかを判断するために使用するプロローグ実行カウントの割合'
# 'Percentage threshold for splitting single-instruction critical edge. If the branch threshold is higher than this threshold, we allow speculative execution of up to 1 instruction to avoid branching to splitted critical edge'
HF3E418A57D78: '単一命令のクリティカル エッジを分割するための百分率閾値。この閾値を超える分岐閾値がある場合、分割されたクリティカル エッジへの分岐を避けるために最大1つの命令の推測実行を許可します。'
# 'Percentage threshold of matched basic blocks at which stale profile inference is executed.'
H38AE58F6A0A2: '一致した基本ブロックの割合の閾値。この閾値を超える場合、古いプロファイル推論が実行されます。'
# 'Percentile of profile quality distributions over hottest functions to report.'
H5CD854B0BEDF: '最も熱い関数のプロファイル品質分布のパーセンタイルを報告します。'
# 'Percentile profile summary cutoff used to determine cold blocks. Unused if set to zero.'
H3E03792B2D91: 'パーセンタイル プロファイル サマリーのカットオフ値。これを使用して寒いブロックを特定します。0に設定すると無視されます。'
# 'Perform ODR checks for decls in the global module fragment.'
H69A7B0ED61B4: 'グローバル モジュール フラグメント内の decl に対して ODR チェックを実行します。'
# 'Perform SME peephole optimization'
HCDB7263D2CEF: 'SME ピープホール最適化を実行します。'
# 'Perform ThinLTO end-to-end'
H303BC754B9A0: 'ThinLTO のエンドツーエンド処理を実行します。'
# 'Perform ThinLTO importing using provided function summary index'
HC1B8CB3D2919: '提供された関数サマリ インデックスを使用して ThinLTO のインポートを実行します。'
# 'Perform ThinLTO optimizations.'
H801619F35DAD: 'ThinLTO 最適化を実行します。'
# 'Perform a single ThinLTO stage:'
H6083E399B9A6: '単一の ThinLTO ステージを実行します：'
# 'Perform both promotion and cross-module importing (requires -thinlto-index).'
H625E880C0440: 'プロモーションとクロスモジュールインポートの両方を実行します（-thinlto-indexが必要です）。'
# 'Perform branch folding during placement. Reduces code size.'
HC83634EE199F: '配置中にブランチ折り畳みを実行します。コードサイズを削減します。'
# 'Perform context sensitive PGO instrumentation'
H9FA2FCAD28BD: 'コンテキスト依存型のPGOインストルメンテーションを実行します。'
# 'Perform dummy load from authenticated address'
H53EA500A8E1C: '認証済みアドレスからのダミーロードを実行します。'
# 'Perform expensive assert validation on every query to Instruction Precedence Tracking'
HB66C9831C0D5: 'Instruction Precedence Trackingへの各クエリで高コストなアサーション検証を実行します。'
# "Perform extra assertion checking to verify that PHINodes's hash function is well-behaved w.r.t. its isEqual predicate"
HC9E8890BCE7F: 'PHINodesのハッシュ関数がisEqual述語に対して適切に動作することを検証するための追加のアサーションチェックを実行します。'
# "Perform extra assertion checking to verify that SimpleValue's hash function is well-behaved w.r.t. its isEqual predicate"
H56A34E9BD071: 'SimpleValueのハッシュ関数がisEqual述語に対して適切に動作することを検証するための追加のアサーションチェックを実行します。'
# 'Perform frequent verification checks on nodes.'
H17FE3747FAAC: 'ノードに対して頻繁な検証チェックを実行します。'
# 'Perform internalization driven by -exported-symbol (requires -thinlto-index).'
H1934C0B7F9D0: '-exported-symbolによるドライバの内部化を実行（-thinlto-indexが必要です）。'
# 'Perform link through clang-sycl-linker via the target offloading toolchain.'
H3D0FA081F298: 'ターゲットオフローディングツールチェーンを介してclang-sycl-linkerを経由しリンキングを実行します。'
# 'Perform mandatory inlinings module-wide, before performing inlining'
HBFA39AA6F76F: 'インライン実行前にモジュール全体で必須インラインを実行します。'
# 'Perform optimizations based on pattern matching'
H48981223D558: 'パターンマッチングに基づく最適化を実行します。'
# 'Perform optimizations of matrix multiplications based on pattern matching'
H175644A4FF20: '行列乗算のパターンマッチングに基づく最適化を実行します。'
# 'Perform optimizations of tensor contractions based on pattern matching'
H07134EDA2398: 'テンソル収縮のパターンマッチングに基づく最適化を実行します。'
# 'Perform pre-import promotion (requires -thinlto-index).'
HD57DCDC50753: 'プリインポートプロモーションを実行（-thinlto-indexが必要です）。'
# 'Perform tail duplication during placement. Creates more fallthrough opportunities in outline branches.'
HF926F65659FB: 'テール複製を実行し、アウトラインブランチにおけるフォールスルーの機会を増やします。'
# 'Perform verification checks on CallingContextGraph.'
H0D2194DF6309: 'CallingContextGraphを検証チェックします。'
# 'Performs lazy compilation on whole module boundaries rather than individual functions'
H0286F9E0FE8F: 'モジュール境界全体に対して遅延コンパイルを実行（個々の関数ではなく）。'
# 'Permit merging of identical functions when optimizing.'
H3F2353AD4C4D: '最適化時に同一関数のマージを許可します。'
# 'Phi Values Analysis'
H4E3B42E3B884: 'Phi値の分析'
# 'Place ASan constructors in comdat sections'
H88C0022D413C: 'ASanコンストラクタをcomdatセクションに配置'
# 'Place Backedge Safepoints'
H8C4883CA47B7: 'Backedge Safepointsを配置'
# 'Place MSan constructors in comdat sections'
H3E7B76D6C9CA: 'MSanコンストラクタをcomdatセクションに配置'
# 'Place all main program variables in static memory (otherwise scalars may be placed on the stack)'
HC378DD7FF55D: 'メインプログラムのすべての変数を静的メモリに配置（スカラ変数がスタックに配置されるのを防ぐ）'
# 'Place constant objects with relocatable address values in the RO data section and add -bforceimprw to the linker flags (AIX only)'
HD2C46719D2EF: 'リロケート可能なアドレス値を持つ定数オブジェクトをROデータセクションに配置し、リンカーフラグに-bforceimprwを追加（AIX専用）'
# 'Place constants in the .rodata section instead of the .sdata section even if they meet the -G <size> threshold (MIPS)'
H509FF0828C91: '-G <size>のしきい値を満たしても、定数を.rodataセクションに配置し、.sdataセクションを使用しない（MIPS向け）'
# 'Place debug types in their own section (ELF Only)'
H73B21ADBA4FE: 'デバッグタイプを独自のセクションに配置（ELFのみ）'
# 'Place each data in its own section'
H7C2A5E2E04CE: '各データを独自のセクションに配置'
# 'Place each function in its own section'
H9BBADC5A5281: '各関数を独自のセクションに配置'
# "Place each function's basic blocks in unique sections (ELF Only)"
H517D3F2B0E57: '各関数の基本ブロックを一意のセクションに配置（ELFのみ）'
# 'Place uninitialized global variables in a common block'
H97F2AD11B476: '初期化されていないグローバル変数をコモンブロックに配置'
# 'Platform to use with LLJIT'
HAEF32BE4B3F4: 'LLJITで使用するプラットフォーム'
# 'Pointer to member.'
HDE1D650C630F: 'メンバへのポインタ。'
# 'Pointer.'
H2EBACB6EF9AE: 'ポインタ。'
# 'Polly - Calculate dependences'
H6CAD158D9763: 'Polly - 依存関係の計算'
# 'Polly - Calculate dependences for all the SCoPs of a function'
H32F2275306BF: 'Polly - 関数のすべてのSCoPsの依存関係を計算'
# 'Polly - Create LLVM-IR from SCoPs'
H64A957DE1EE7: 'Polly - SCoPsからLLVM-IRを作成'
# 'Polly - Create polyhedral description of Scops'
HFD5B7E2064CE: 'Polly - Scopsの多面体記述を作成'
# 'Polly - Create polyhedral description of all Scops of a function'
H3225EA9E728D: 'Polly - 関数のすべてのScopsのpolyhedral記述を作成'
# 'Polly - DeLICM/DePRE'
H209DA16A8BB4: 'Polly - DeLICM/DePRE'
# 'Polly - Detect static control parts (SCoPs)'
HFF16BBB95B79: 'Polly - SCoPs（静的制御部分）を検出'
# 'Polly - Dump Function'
HF98ECB8A4F3A: 'Polly - 関数をダンプ'
# 'Polly - Dump Module'
H406314AC52B6: 'Polly - モジュールをダンプ'
# 'Polly - Dump polyhedral description of Scops optimized with the isl scheduling optimizer and the set of post-scheduling transformations is applied on the schedule tree'
H29D7996B3B49: 'Polly - islスケジューリング最適化で最適化されたScopのpolyhedral記述をダンプ（スケジュールツリーへの後処理変換を適用）'
# 'Polly - Export Scops as JSON (Writes a .jscop file for each Scop)'
H20651143EB75: 'Polly - ScopsをJSON形式でエクスポート（各Scopに対し.jscopファイルを作成）'
# 'Polly - Flatten schedule'
HB1962B7EDBD9: 'Polly - スケジュールを平坦化'
# 'Polly - Forward operand tree'
HBFECA734FD00: 'Polly - オペランドツリーを前方伝播'
# 'Polly - Generate an AST from the SCoP (isl)'
HDBF9CF6A0C48: 'Polly - SCoP（isl）からASTを生成'
# 'Polly - Generate an AST of the SCoP (isl)'
H12CE909F63DA: 'Polly - SCoP（isl）のASTを生成'
# 'Polly - Import Scops from JSON (Reads a .jscop file for each Scop)'
H16E203839258: 'Polly - JSONからScopsをインポート（各Scopの.jscopファイルを読み込み）'
# 'Polly - Interface to polyhedral analysis engine'
HEE4D2D43660E: 'Polly - Polyhedral解析エンジンとのインターフェース'
# 'Polly - Maximal static expansion of SCoP'
H0CA779A2D7D3: 'Polly - SCoPの最大静的展開'
# 'Polly - Optimize schedule of SCoP'
H377579EA76A0: 'Polly - SCoPのスケジュールを最適化'
# 'Polly - Prepare code for polly'
HA31E0A502467: 'Polly - Polly用コード準備'
# 'Polly - Print DeLICM/DePRE'
HE392A0315DF8: 'Polly - DeLICM/DePREの結果を表示'
# 'Polly - Print Scop import result'
H4A167D1D4274: 'Polly - Scopインポート結果を表示'
# 'Polly - Print Scops of function'
H31ABAE6ABC4E: 'Polly - 関数のScopsを表示'
# 'Polly - Print Scops of function (with no function bodies)'
HF9B4E2CB9C70: 'Polly - 関数のScopsを表示（関数本体なし）'
# 'Polly - Print Simplify actions'
H5741448BF9F8: 'Polly - Simplifyアクションを表示'
# 'Polly - Print dependences'
HD5CEBA14DA9B: 'Polly - 依存関係を表示'
# 'Polly - Print dependences for all the SCoPs of a function'
HD7464B6EDE01: 'Polly - 関数のすべてのSCoPの依存関係を表示'
# 'Polly - Print flattened schedule'
H33EAB5733200: 'Polly - 平坦化スケジュールを表示'
# 'Polly - Print forward operand tree result'
H7CD855EC5084: 'Polly - フォワードオペランドツリーリザルトを表示'
# 'Polly - Print interface to polyhedral analysis engine analysis'
HF7F243A50BCB: 'Polly - ポリエデル分析エンジンのインターフェースを表示'
# 'Polly - Print optimizer schedule of SCoP'
HB4511056F80D: 'Polly - SCoPの最適化スケジュールを表示'
# 'Polly - Print polyhedral description of Scops'
HE3A4EE9454B0: 'Polly - Scopsのポリエデル記述を表示'
# 'Polly - Print polyhedral description of all Scops of a function'
H23C591077544: 'Polly - 関数のすべてのScopsのポリエデル記述を表示'
# 'Polly - Print static control parts (SCoPs)'
H2CB7C4BBD709: 'Polly - 静的制御部分（SCoPs）を表示'
# 'Polly - Print the AST from a SCoP (isl)'
H984A4B6D2819: 'Polly - SCoPからのASTを表示（isl）'
# 'Polly - Prune unprofitable SCoPs'
HB8C0844D69B4: 'Polly - 非効率なSCoPsを削除'
# 'Polly - Remove dead iterations'
H67A46F65DA9E: 'Polly - 死活繰り返しを削除'
# 'Polly - Run canonicalization passes'
H0C8C62952E1F: 'Polly - カノニカル化パスを実行'
# 'Polly - Simplify'
HE98E9DE36187: 'Polly - 簡略化'
# 'Polly - View Scops of function'
HD3BFFB69003F: 'Polly - 関数のScopsを表示'
# 'Polly - View Scops of function (with no function bodies)'
H8C7475C4A4E8: 'Polly - 関数のScopsを表示（関数本体なし）'
# 'Polly Options'
H4116368BA8CD: 'Polly オプション'
# 'Pop up a window to show MISched dags after they are processed'
HAAFE046654B3: '処理後のMISched DAGを表示するためのウィンドウを開きます。'
# 'Pop up a window to show SUnit dags after they are processed'
HDD5439EA4C3E: '処理後のSUnit DAGを表示するためのウィンドウを開きます。'
# 'Pop up a window to show a dag displaying MBP layout and associated block frequencies of the CFG.'
HBC76A8873486: 'CFGのMBPレイアウトと関連するブロック周波数を示すDAGを表示するためのウィンドウを開きます。'
# 'Pop up a window to show a dag displaying how block frequencies propagation through the CFG.'
H5017224EFFF8: 'CFGを伝播するブロック周波数の方法を示すDAGを表示するためのウィンドウを開きます。'
# 'Pop up a window to show a dag displaying how machine block frequencies propagate through the CFG.'
H06EB3103BBDD: 'CFGを伝播するマシンブロック周波数の方法を示すDAGを表示するためのウィンドウを開きます。'
# 'Pop up a window to show dags before legalize'
HCEEBF08E9304: 'legalize前のDAGを表示するためのウィンドウを開きます。'
# 'Pop up a window to show dags before legalize types'
H7DF81922AFEE: 'legalize types前のDAGを表示するためのウィンドウを開きます。'
# 'Pop up a window to show dags before the first dag combine pass'
HD6B32ED73930: '最初のDAG統合パス前のDAGを表示するためのウィンドウを開きます。'
# 'Pop up a window to show dags before the post legalize types dag combine pass'
H411955B7261A: 'legalize types後のDAG統合パス前のDAGを表示するためのウィンドウを開きます。'
# 'Pop up a window to show dags before the second dag combine pass'
HC7BCA3632D13: '2番目のDAG統合パス前のDAGを表示するためのウィンドウを開きます。'
# 'Pop up a window to show edge bundle graphs'
H5831F520A8FB: 'エッジバンドルグラフを表示するためのウィンドウを開きます。'
# 'Pop up a window to show isel dags as they are selected'
HA52C2A41472F: '選択中のisel DAGを表示するためのウィンドウを開きます。'
# 'Pop up a window to show sched dags as they are processed'
H1FD861E7E0A4: '処理中のsched DAGを表示するためのウィンドウを開きます。'
# 'Populate profile symbol list (only meaningful for -extbinary)'
HB40FFCA64E8B: 'プロファイルシンボルリストを初期化します（-extbinaryでのみ意味があります）'
# 'Position independent'
H3F7792F17E68: '位置独立'
# 'Post RA hazard recognizer'
H03992384B25F: 'RA（レジスタ割り当て）後のハザード認識器'
# 'Post RA top-down list latency scheduler'
H59EA1D628EE5: 'RA後のトップダウン遅延スケジューラ'
# 'Post reg-alloc list scheduling direction'
H4071BC55C6A4: 'レジスタ割り当て後のリストスケジューリング方向'
# 'Post-Dominator Tree Construction'
HEC3645FCF915: 'ポスト支配木構築'
# 'Post-RA pseudo instruction expansion pass'
H3AEF4966A271: 'Post-RA仮命令展開パス'
# 'PostRA Machine Instruction Scheduler'
H0087D700C0B6: 'PostRAマシン命令スケジューラ'
# 'PostRA Machine Sink'
H2B8A5A72B764: 'PostRAマシンシンク'
# 'Postfix to append to the import .jsop files.'
H00F609EA3C78: 'インポート.jsopファイルに追加する接尾辞'
# 'Potential PHI threshold per loop for PPC loop prep of DQ form'
HD78EEEDE2049: 'PPCループ準備のDQ形式ごとのループあたりのポテンシャルPHI閾値'
# 'Potential PHI threshold per loop for PPC loop prep of DS form'
H88F3C7B998C1: 'PPCループ準備のDS形式ごとのループあたりのポテンシャルPHI閾値'
# 'Potential PHI threshold per loop for PPC loop prep of update form'
HFA306C3E0204: 'PPCループ準備のアップデート形式ごとのループあたりのポテンシャルPHI閾値'
# 'Potential common base number threshold per function for PPC loop prep'
H1CB6AA07DE6F: 'PPCループ準備の関数ごとのポテンシャル共通基数閾値'
# 'PowerPC Branch Selector'
H9BA07427B81D: 'PowerPCブランチセレクター'
# 'PowerPC CTR Loops Verify'
H6280529F23F2: 'PowerPC CTRループ検証'
# 'PowerPC CTR loops generation'
HFCFC8E19EA44: 'PowerPC CTRループ生成'
# 'PowerPC DAG->DAG Pattern Instruction Selection'
H52FD8AB73B79: 'PowerPC DAG→DAGパターン命令選択'
# 'PowerPC Early-Return Creation'
HFB276D43768D: 'PowerPC Early-Return作成'
# 'PowerPC Expand Atomic'
HE518E2C5903E: 'PowerPCアトミック展開'
# 'PowerPC MI Peephole Optimization'
HD03B52E2308F: 'PowerPC MIピーホール最適化'
# 'PowerPC Pre-Emit Peephole'
H690293F011C6: 'PowerPCプリ・エミットピーホール'
# 'PowerPC Reduce CR logical Operation'
H604BA96457F7: 'PowerPC CR論理演算簡素化'
# 'PowerPC TLS Dynamic Call Fixup'
H754F83D11B51: 'PowerPC TLSダイナミックコール修正'
# 'PowerPC TOC Register Dependencies'
HBE3F61F91CCA: 'PowerPC TOCレジスタ依存関係'
# 'PowerPC VSX Copy Legalization'
HCE743C058611: 'PowerPC VSXコピー合法化'
# 'PowerPC VSX FMA Mutation'
H934573D30FC1: 'PowerPC VSX FMA 変換'
# 'PowerPC VSX Swap Removal'
H61E16EA71951: 'PowerPC VSX スワップ削除'
# 'Pre reg-alloc list scheduling direction'
HBAA66F24441A: 'レジスタ割り当て前のリストスケジューリング方向'
# 'Pre-ISel Intrinsic Lowering'
H2F5309EAAE70: 'Pre-ISel 組み込み関数の低階層化'
# 'Pre-RA optimizations'
H81B4ED48A8E1: 'レジスタ割り当て前の最適化'
# 'Pre-load dynamic libraries (e.g. language runtimes required by the ORC runtime)'
HDF44F8CD7956: '動的ライブラリを事前ロード（例：ORC ランタイムが必要とする言語ランタイム）'
# 'Predicate conditions in read only loops'
H0D01A5F11CC3: '読み取り専用ループでの予測条件'
# 'Prefer add+cnt over addvl/inc/dec'
H791228095B74: 'addvl/inc/dec の代わりに add+cnt を優先'
# 'Prefer aligned allocation for C++ Coroutines'
HF3DEE91EAA7A: 'C++ コルーチンにはアラインメントされた割り当てを優先'
# 'Prefer hex format for immediate values'
H5AF7A8CAAB05: '即値の表示に16進数形式を優先'
# 'Prefer hex format when printing immediate values'
H641A692609DF: '即値を表示する際に16進数形式を優先'
# 'Prefer in-loop vector reductions, overriding the targets preference.'
HC3384EBFEDE5: 'ターゲットの選好を上書きし、ループ内のベクターリダクションを優先'
# 'Prefer post-indexed addressing mode'
HFA137A1FDE64: '後インデックス付きアドレッシングモードを優先'
# 'Prefer pre-indexed addressing mode'
HCF74AFA989EA: '前インデックス付きアドレッシングモードを優先'
# 'Prefer predicated Move to CSEL'
H29D20CBEE6CD: 'CSEL の代わりに予測付き Move を優先'
# 'Prefer predicating a reduction operation over an after loop select.'
HE552FE7410D6: 'ループ後の select の代わりに、リダクション操作を予測するように優先'
# 'Prefer translating all intrinsics into llvm.call_intrinsic instead of using dialect supported intrinsics'
H35AE35D12C89: '各組み込み関数を llvm.call_intrinsic に変換し、ダイアレクトでサポートされている組み込み関数の使用を避ける'
# 'Prefer whole register move for vector registers.'
HD64DE7AD7D41: 'ベクター レジスターにはレジスター全体の移動を優先'
# 'Prefetch write addresses'
HD84230748C7F: '書き込みアドレスのプリフェッチ'
# 'Prefix filenames with the main file'
HFC5DC735C294: 'メインファイルの前にファイル名を接頭辞として付ける'
# 'Prefix for feature names.'
H2B0C0B21A30C: '機能名のプレフィックス'
# 'Prefix for memory access callbacks'
H4F526B73B916: 'メモリアクセスコールバック用のプレフィックス'
# 'Prefix of line code for repository.'
H1C11371CF193: 'リポジトリの行コードのプレフィックス'
# "Prefix to use for outputs (default: 'bugpoint')"
H51241093AFDE: '出力に使用するプレフィックス（デフォルト: "bugpoint"）'
# "Prefix to use from check file (defaults to 'CHECK')"
HC4A6D5922731: 'チェックファイルから使用するプレフィックス（デフォルトは "CHECK"）'
# "Prefixes for aliases that don't need to be renamed, separated by a comma"
H93C76DC96906: '再定義不要なエイリアスのプレフィックス（カンマ区切り）'
# "Prefixes for functions that don't need to be renamed, separated by a comma"
H8D84AAE61D99: '再定義不要な関数のプレフィックス（カンマ区切り）'
# "Prefixes for global values that don't need to be renamed, separated by a comma"
H25F3716C6D6C: '再定義不要なグローバル値のプレフィックス（カンマ区切り）'
# "Prefixes for structs that don't need to be renamed, separated by a comma"
HFF2FE350C63E: '再定義不要な構造体のプレフィックス（カンマ区切り）'
# 'Preload commands from file and start interactive mode'
HF342699558DE: 'ファイルからコマンドを事前読み込みし、インタラクティブモードを開始'
# "Prepare '-aux-triple' only without populating '-aux-target-cpu' and '-aux-target-feature'."
H5F5A3F872C66: "'-aux-triple' のみを準備し、'-aux-target-cpu' と '-aux-target-feature' を設定しない"
# 'Prepare DWARF exceptions'
H95C39A5915AA: 'DWARF例外の準備'
# 'Prepare SjLj exceptions'
HCA47286F067B: 'SjLj例外の準備'
# 'Prepare WebAssembly exceptions'
H90B1A43A5B08: 'WebAssembly例外の準備'
# 'Prepare Windows exceptions'
H09ADD0F6BE1B: 'Windows例外の準備'
# 'Prepare callbr'
H28D8A749A5F8: 'callbrを準備'
# 'Prepares for basic block sections, by splitting functions into clusters of basic blocks.'
H6AFC803DF7AB: '関数をベーシックブロックのクラスタに分割し、ベーシックブロックセクションの準備を行う'
# 'Prepend header file paths with this prefix. If not specified, the files are considered to be relative to the header list file.'
HB8A4FB692FE7: 'ヘッダーファイルのパスにこのプレフィックスを付加します。指定されない場合、ファイルはヘッダーリストファイルに対する相対パスと見なされます'
# 'Preprocess to file'
HADD296905BBE: '事前処理をファイルに保存'
# 'Preprocess to stdout'
HB9E8D78ECAA1: 'stdoutに事前処理の結果を出力'
# 'Preserve Comments in outputted assembly'
H6543E9060512: 'アセンブリ出力にコメントを保持する'
# 'Preserve canonical loop structure (default = true)'
H9226DB4F030F: '標準的なループ構造を保持する (デフォルト = true)'
# 'Preserve debug info in thunk when mergefunc transformations are made.'
HC15D6215FF01: 'mergefunc変換が行われた場合、サード内のデバッグ情報を保持する'
# 'Preserve expressions in AST rather than dropping them when encountering semantic errors'
H606CF076FD66: '意味エラーを検出してもAST内で式を保持し、それらを削除しない'
# 'Preserve line numbers'
HF7C338130FB4: '行番号を保持する'
# 'Preserve order of LLVM use-lists when serializing'
HE297D90494BB: 'LLVMアセンブリを書き込む際に、use-listの順序を保持する'
# 'Preserve path components'
HA8274603DA36: 'パスのコンポーネントを保持する'
# 'Preserve subregisters in tied operands'
HB16CD82DFFE2: '結合されたオペランド内のサブレジスタを保持する'
# 'Preserve the type for recovery expressions when possible'
HB104FC8C2A4B: '可能な場合は回復式の型を保持する'
# 'Preserve use-list order when writing LLVM assembly.'
HA8838E5FAEE3: 'LLVMアセンブリを書き込む際に、use-listの順序を保持する'
# 'Preserve use-list order when writing LLVM bitcode.'
HED82044E4F6B: 'LLVMビットコードを書き込む際に、use-listの順序を保持する'
# 'Preserves original instruction order'
H08B5F35B74C3: '元の命令順序を保持する'
# 'Pretend that scalable vectors are supported, even if the target does not support them. This flag should only be used for testing.'
HE0B0560A96EA: 'ターゲットがサポートしていない場合でもスケーラブルベクタをサポートしていることにする。このフラグはテスト用のみに使用すべきである'
# 'Pretty print debug locations of instructions when dumping'
HFD520C9CFE2C: 'ダンプ時に命令のデバッグ位置を整形して出力する'
# 'Pretty print perf data (branch weights, etc) when dumping'
H25D67F8F93BF: 'ダンプ時にパフォーマンスデータ（ブランチの重みなど）を整形して出力する'
# 'Pretty-print JSON'
HED0E5D700CC6: 'JSONを整形して出力する'
# 'Pretty-print JSON output'
HF19F323787A0: 'JSON出力を整形して出力する'
# 'Pretty-print JSON output in the trace'
HE76D2162F789: 'トレース内のJSON出力を整形して出力する'
# 'Prevent expanding floating point division in AMDGPUCodeGenPrepare'
H5221E44BB247: 'AMDGPUCodeGenPrepareで浮動小数点除算の展開を防止する'
# 'Prevent expanding integer division in AMDGPUCodeGenPrepare'
HA00F77EDC803: 'AMDGPUCodeGenPrepareで整数除算の展開を防止する'
# 'Prevent function(s) from being devirtualized'
HF36ABB428107: '仮想化解除を防ぐ関数(複数可)'
# 'Prevent misexpect diagnostics from being output if the profile counts are within N% of the expected. '
HAB811F421D71: 'プロファイルカウントが予想値のN%以内の場合はmisexpect診断の出力を防止します。'
# "Prevent optimization remarks from being output if they do not have at least this profile count. Use 'auto' to apply the threshold from profile summary"
H80EFE9F96F6F: 'プロファイルカウントがこの値未満の場合は最適化リマインダーを出力しない。"auto"を指定するとプロファイルサマリのしきい値が適用されます'
# 'Prevents emitting diagnostics when profile counts are within N% of the threshold..'
H77AE0CC1048E: 'しきい値のN%以内のプロファイルカウントの場合、診断の発行を防止します。'
# 'Primary key when ordering logical view (default: line).'
H7BB0C9861C88: '論理ビューを並べ替える際の主キー (デフォルト: 行)'
# 'Print (but do not run) the commands to run for this compilation'
HCEF688AF1304: 'このコンパイルに使用するコマンドを表示するが実行はしません'
# "Print Attributor's internal call graph"
H256F97E689ED: 'Attributorの内部コールグラフを表示'
# 'Print DenseElementsAttrs with a hex string that have more elements than the given upper limit (use -1 to disable)'
H4B4EB65A8AF9: '与えられた上限を超える要素数を持つDenseElementsAttrsの16進文字列を表示 (-1を指定すると無効化)'
# 'Print Enum list for this class'
HB3042274A9F1: 'このクラスのEnum一覧を表示'
# 'Print ExecutionSession state after resolving entry point'
HA2AA771729BC: 'エントリポイント解決後のExecutionSessionの状態を表示'
# 'Print ExecutionSession state before resolving entry point'
H66A839FE6545: 'エントリポイント解決前のExecutionSessionの状態を表示'
# 'Print IR after each pass'
HA5EFB8CE8B9F: '各パス実行後のIRを表示'
# 'Print IR after specified passes'
H3D9D708F1675: '指定されたパス実行後のIRを表示'
# 'Print IR after the pass with this number as reported by print-pass-numbers'
HB20A8CE7B1FD: 'print-pass-numbersで報告された番号のパス実行後のIRを表示'
# 'Print IR before each pass'
HDA98FFA60DB4: '各パス実行前のIRを表示'
# 'Print IR before specified passes'
H328B86DC8BAB: '指定されたパス実行前のIRを表示'
# 'Print IR before the pass with this number as reported by print-pass-numbers'
H67F2CC34678A: 'print-pass-numbersで報告された番号のパス実行前のIRを表示'
# 'Print IR to path when opt-bisect-limit is reached'
H1CC46248A49A: 'iselパスへのLLVM IR入力を表示'
# 'Print LLVM IR input to isel pass'
HB1E12014CD83: 'LLVM IR入力のiselパスを表示'
# 'Print MIR debug-locations'
H23CF1A75AA16: 'MIRのデバッグロケーションを表示'
# 'Print Machine Cycle Info Analysis'
H9577B97D25AE: 'マシン・サイクル情報分析を表示'
# 'Print Machine Uniformity Info Analysis'
HFCF3D928DF44: 'マシン一様性情報分析を表示'
# 'Print Options'
H183A70DB44AF: 'オプションを表示'
# 'Print SSA IDs using NameLocs as prefixes'
H17EB8F4CEEED: 'NameLocs をプレフィックスとして使用してSSA IDを表示'
# "Print a '-passes' compatible string describing the pipeline (best-effort only)."
H4C4CBF86A7C9: "パイプラインを説明する'-passes'互換の文字列を表示（最善を尽くすのみ）。"
# 'Print a template comparison tree for differing templates'
H94B203D5EC04: '異なるテンプレートのテンプレート比較ツリーを表示'
# 'Print absolute paths in diagnostics'
H3475474B9AF0: '診断情報に絶対パスを表示'
# 'Print addresses of MachineInstrs when dumping'
H3F08CE170EBB: 'ダンプ時にMachineInstrsのアドレスを表示'
# 'Print addresses of instructions when dumping'
HF2156C7D4A91: 'ダンプ時に命令のアドレスを表示'
# 'Print all cost kinds'
HCAA4E47DE719: 'すべてのコスト種類を表示'
# 'Print all hardware statistics'
H14BBD9376F77: 'すべてのハードウェア統計を表示'
# "Print all of Clang's warning options"
HF45E26CFBC96: 'Clangのすべての警告オプションを表示'
# 'Print all option values after command line parsing'
HB0F721DC4298: 'コマンドライン解析後のすべてのオプション値を表示'
# 'Print all records to stdout (default)'
H8BF745CB973A: 'すべてのレコードをstdoutに表示（既定値）'
# 'Print all results from files matching this regular expression.'
H37B62E065C22: 'この正規表現に一致するファイルからのすべての結果を表示。'
# 'Print all views including hardware statistics'
H8A87BEED0121: 'ハードウェア統計を含むすべてのビューを表示'
# 'Print allocation requests made to the memory manager by RuntimeDyld'
H36E2ACD7E011: 'RuntimeDyldによるメモリマネージャへの割り当て要求を表示'
# 'Print any external commands that are to be executed instead of actually executing them - for testing purposes.\n'
HF77F09852A60: '実行する代わりに外部コマンドを表示（テスト用）。\n'
# 'Print architectural register names rather than the ABI names (such as r14 instead of sp)'
H9E57937A3E1F: 'ABI名ではなくアーキテクチャレジスタ名を表示（例: spの代わりにr14）'
# 'Print assembly as linked'
HF50C5F3BF962: 'リンカされたアセンブリを表示'
# 'Print assembly as parsed'
H75C25DD05B7B: 'パースされたアセンブリを出力'
# 'Print attribute dependencies'
HDE5247667B07: '属性の依存関係を出力'
# 'Print available passes that can be specified in -passes=foo and exit'
HE05D65950FB2: '指定可能な-passes=fooで指定できる可用なパスを表示し、終了する'
# 'Print before passes that change them'
HAEB698616AF4: 'それらを変更するパスの前に出力'
# 'Print binary blobs using hex escapes'
H0160E60E08F5: '16進エスケープを使用してバイナリ・ブロブを出力'
# 'Print binary load events.'
H2F65BD41A1E8: 'バイナリ読み込みイベントを出力'
# "Print call graph to 'dot' file"
H699252A05887: '「dot」ファイルにコールグラフを出力'
# 'Print canonical function name.'
H39DE0BCE8940: '標準的な関数名を出力'
# 'Print changed IRs'
HB7CE030FBB95: '変更されたIRを出力'
# 'Print cl.exe style /showIncludes to stdout'
H84DEF3CD15ED: '標準出力にcl.exe形式の/showIncludesを出力'
# 'Print command line.'
H1C5C42AF6D29: 'コマンドラインを出力'
# 'Print critical path length to stdout'
H8F78BF714145: '標準出力にクリティカルパス長を出力'
# 'Print debug info in MLIR output'
H6859C4B3FF46: 'MLIR出力にデバッグ情報を含める'
# 'Print debug information.\n'
HB8A507E6D179: 'デバッグ情報を出力。\n'
# 'Print demangled function name'
HC4B0C0E810C3: 'デマングルされた関数名を出力'
# 'Print detailed output about what is being run to stderr.'
HE984DCC7A8C4: '実行中の詳細情報をstderrに出力'
# 'Print diagnostic category'
HCF5E624088CE: '診断カテゴリを出力'
# 'Print directive pattern matches, or add them to the input dump\nif enabled.\n'
H928F89E57268: 'ディレクティブパターンの一致を表示するか、有効な場合入力ダンプに追加します。\n'
# 'Print disassembled code.'
HDACEC7EBFD41: '逆アセンブルされたコードを出力'
# 'Print dispatch statistics'
H2DF0F56E2112: 'ディスパッチ統計を出力'
# "Print dominance tree of function to 'dot' file"
HFDEAF60A0F86: "関数のドミナンスツリーを'dot'ファイルに出力"
# "Print dominance tree of function to 'dot' file (with no function bodies)"
H255806455D28: "関数のドミナンスツリーを'dot'ファイルに出力（関数本体なし）"
# 'Print embed directives in -E mode in addition to normal output'
HA988C571D048: '-Eモードで通常の出力に加えて埋め込みディレクティブを出力'
# 'Print encoding information in the instruction info view'
HDDF771C744F8: '命令情報ビューでエンコーディング情報を表示'
# 'Print extra debugging information'
HFF9ED81B933D: '追加のデバッグ情報を出力'
# 'Print extra information about adaptors and pass managers'
H8E608CF10762: 'アダプタとパスマネージャに関する追加情報を出力'
# 'Print final code'
H91C18F74D9CF: '最終的なコードを出力'
# 'Print fix-its in machine parseable form'
H8FDA449E8857: '修正提案をマシンパース可能形式で出力'
# 'Print function to stderr'
H4E08D51481D2: '標準エラー出力に関数を出力'
# 'Print graphs around indirect CF instructions in DOT format.'
HF75F04A7E3C5: '間接CF命令周辺のグラフをDOT形式で出力'
# 'Print imported functions'
H3746D79A84CE: 'インポートされた関数を出力'
# 'Print include directives in -E mode in addition to normal output'
HD07C75D32665: '-Eモードで通常の出力に加えて#includeディレクティブを出力'
# 'Print index-based devirtualization messages'
HBF58405294ED: 'インデックスベースのデバーチャル化メッセージを出力'
# 'Print info about included files to stderr'
H622C6A0F6DB5: '標準エラー出力に含むファイルに関する情報を表示'
# 'Print information about actions taken'
H1ED18B4AD272: '実行されたアクションに関する情報を出力'
# 'Print information about the activities of Polly'
HCF30D81D0973: 'Pollyの活動に関する情報を出力'
# 'Print information for functions rejected for importing'
HBD21C28A83D7: 'インポート拒否された関数に関する情報を出力'
# 'Print information helpful in diagnosing internal FileCheck\nissues, or add it to the input dump if enabled.  Implies\n-v.\n'
H651EBEE00CDE: '内部のFileCheck問題の診断に役立つ情報を出力するか、有効な場合入力ダンプに追加します。-vを含む。\n'
# 'Print instruction latencies as verbose asm comments'
HD27FB6BC6036: '命令のレイテンシーを詳細なアセンブリコメントとして出力'
# 'Print instruction tables'
H2620BE69E6DD: '命令テーブルを出力'
# 'Print instruction tables with additional information: bypass latency, LLVM opcode, used resources'
HFB383E77CA64: '追加情報を含む命令テーブルを印刷：バイパス遅延、LLVMオペコード、使用リソース'
# "Print instructions that the allocator wants to fuse, but the X86 backend currently can't"
HE530C7C7214A: '融合させたい命令をアロケーターが表示しますが、現在のX86バックエンドではできません'
# 'Print internal analyzer statistics.'
HAE4856542BC1: '内部解析統計情報を表示します。'
# 'Print legacy PassManager debugging information'
HDFED9BD864B2: 'レガシーパスマネージャのデバッグ情報を印刷'
# 'Print list of delta passes, passable to --delta-passes as a comma separated list'
H93E693FB4735: 'カンマ区切りリストとして--delta-passesに渡せるdeltaパスのリストを表示'
# 'Print machine instrs after ISel'
H555E49FB33C1: 'ISel後のマシン命令を印刷'
# 'Print machine verifier errors on invalid reduction attempts triple'
HE100DF904ED4: '無効な削減試行トリプルでのマシン検証エラーを印刷'
# 'Print macro definitions in -E mode in addition to normal output'
H0486B7210917: '通常出力に加え、-Eモードでのマクロ定義を表示'
# 'Print macro definitions in -E mode instead of normal output'
HB1EFD9100CC5: '-Eモードでマクロ定義のみを表示し、通常出力を省略'
# "Print matching stats for each allocation context in this module's profiles"
H8ED3695B4B5D: 'このモジュールのプロファイルにおける各アロケーションコンテキストのマッチング統計を表示'
# 'Print memory access functions'
H2D490B90F012: 'メモリアクセス関数を印刷'
# 'Print memory barrier information in the instruction info view'
H565E0827BDFD: '命令情報ビュー内のメモリバリア情報を表示'
# 'Print module to stderr'
HFFEB1D6642AE: 'モジュールを標準エラー出力(stderr)に印刷'
# 'Print name of local stack variable'
H5190847365AF: 'ローカルスタック変数の名前を印刷'
# 'Print non-default options after command line parsing'
HEA27B7232530: 'コマンドライン解析後の非デフォルトオプションを印刷'
# 'Print numeric register names rather than the ABI names (such as $r0 instead of $zero)'
H165530C50853: '$r0などの数値レジスタ名をABI名（例：$zero）の代わりに表示'
# 'Print only the CFG without blocks body'
H75782D2B7733: 'ブロックの本体を省略した制御フローグラフ(CFG)のみを印刷'
# 'Print option name with mappable diagnostics'
H158CBF9FD24C: 'マッピング可能な診断情報と共にオプション名を表示'
# 'Print out debug counter info after all counters accumulated'
H2CE0455E9D85: 'すべてのカウンタが蓄積された後のデバッグカウンタ情報を表示'
# 'Print out debug counter information after all counters have been accumulated'
H94A5B1103F3F: 'すべてのカウンタが蓄積された後のデバッグカウンタ情報を表示'
# 'Print out mismatched BFI counts after setting profile metadata The print is enabled under -Rpass-analysis=pgo, or internal option -pass-remarks-analysis=pgo.'
H3025AA257D2E: 'プロファイル メタデータを設定した後に不一致のBFIカウントを表示します。この表示は、-Rpass-analysis=pgoまたは内部オプション-pass-remarks-analysis=pgoの下で有効になります。'
# 'Print out the non-match BFI count if a hot raw profile count becomes non-hot, or a cold raw profile count becomes hot. The print is enabled under -Rpass-analysis=pgo, or internal option -pass-remarks-analysis=pgo.'
HDD8F14466662: 'ホットな生プロファイルカウントがノンホットになった場合、またはコールドな生プロファイルカウントがホットになった場合に、非一致BFIカウントを表示します。この表示は、-Rpass-analysis=pgoまたは内部オプション-pass-remarks-analysis=pgoの下で有効になります。'
# 'Print out the parsed ODS information from the input file'
H863FE61CF758: '入力ファイルから解析されたODS情報を表示します。'
# 'Print pass management debugging information'
H639A1D9CCF1A: 'パス管理のデバッグ情報を表示します。'
# 'Print pass names and their ordinals'
H333E30843F56: 'パスの名前とそれらの順序番号を表示します。'
# 'Print performance metrics and statistics'
HE4EAA5755D11: 'パフォーマンス メトリクスと統計を表示します。'
# "Print postdominance tree of function to 'dot' file"
HB29C66E944CC: "関数のpostdominanceツリーを'dot'ファイルに出力します。"
# "Print postdominance tree of function to 'dot' file (with no function bodies)"
HD6176265DDFA: "関数のpostdominanceツリーを'dot'ファイルに出力します（関数本体なし）"
# 'Print pretty debug info in MLIR output'
H1D9ED83CA568: 'MLIR出力における整形されたデバッグ情報を表示します。'
# 'Print pseudo probe section and disassembled info.'
H32640273947C: '擬似プローブ セクションと逆アセンブル情報を表示します。'
# "Print regions of function to 'dot' file"
HA2F7AC936E9B: "関数の領域を'dot'ファイルに出力します。"
# "Print regions of function to 'dot' file (with no function bodies)"
HB4D8B8B65FF0: "関数の領域を'dot'ファイルに出力します（関数本体なし）"
# 'Print register file statistics'
HD3E0FCA5570D: 'レジスタ ファイルの統計情報を表示します。'
# 'Print registered symbol, section, got and stub addresses'
H4788FF394730: '登録済みシンボル、セクション、got、およびstubのアドレスを表示します。'
# 'Print retire control unit statistics'
HD5CFA03245CF: 'retire制御ユニットの統計情報を表示します。'
# 'Print schedule DAGs'
HCD1F3A6E0736: 'スケジュールDAGを表示します。'
# 'Print scheduler statistics'
HEAC85495C43E: 'スケジューラの統計情報を表示します。'
# 'Print setting flow sensitive branch probabilities'
H93BFBD2C1FA2: 'フロー依存のブランチ確率の設定を表示します。'
# 'Print source locations.'
H1D581A019738: 'ソース ロケーションを表示します。'
# 'Print source range spans in numeric form'
H6EBB5160F7AF: '数値形式でソース レンジのスパンを表示します。'
# 'Print statistic for the index in every input files'
H269BBBFD3979: '各入力ファイルのインデックスの統計情報を表示します'
# 'Print subprocess statistics'
HFA43D801ECBB: 'サブプロセスの統計情報を表示します'
# 'Print summary view (enabled by default)'
HC78BAF3172BC: '要約ビューを表示（デフォルトで有効）'
# 'Print supported -march extensions (RISC-V, AArch64 and ARM only)'
HFE614E88285A: 'サポートされている -march 拡張機能を表示 (RISC-V、AArch64、ARM 専用)'
# 'Print supported cpu models for the given target (if target is not specified,it will print the supported cpus for the default target)'
H83F7E7816369: '指定されたターゲットのサポートされている CPU モデルを表示します。ターゲットが指定されていない場合は、デフォルトのターゲットのサポート CPU を表示します'
# 'Print symbolic changes'
HEBF2FA11F574: 'シンボルの変更点を表示します'
# 'Print the "preamble" of a file, which is a candidate for implicit precompiled headers.'
H70A29FD77B18: 'インプリシットプリコンパイルドヘッダーの候補となるファイルの preamble を表示します'
# 'Print the blame context (if possible) for BAD instructions. This specifies the number of lines of context to include, where zero disables this feature.'
HBD7D1281AF22: 'BAD 指令のブレームコンテキスト（可能な場合）を表示します。このオプションは包含するコンテキスト行数を指定します。0を指定するとこの機能を無効にします'
# 'Print the block frequency info.'
HC5D2B22203B4: 'ブロックの頻度情報を表示します'
# 'Print the branch probability info.'
H9D987607E791: '分岐確率情報を表示します'
# 'Print the canonical YAML for this file.'
HE1A3AA010C12: 'このファイルの正規 YAML を表示します'
# 'Print the compiler version'
HB74950BD8E88: 'コンパイラのバージョンを表示'
# 'Print the current module after OpenMP optimizations.'
HF02AEAC96CD7: 'OpenMP 最適化後の現在のモジュールを表示'
# 'Print the current module before OpenMP optimizations.'
H8661FCFF114F: 'OpenMP 最適化前の現在のモジュールを表示'
# "Print the directory pathname containing Clang's runtime libraries"
HCF6BD300D146: 'Clang のランタイムライブラリが含まれるディレクトリのパスを表示します'
# 'Print the effective target triple'
H651D58C4EE40: '有効なターゲットトリプルを表示'
# 'Print the extensions enabled by the given target and -march/-mcpu options. (AArch64 and RISC-V only)'
HBF8F8BB9DED1: '指定されたターゲットと -march/-mcpu オプションで有効にされた拡張機能を表示 (AArch64 と RISC-V 専用)'
# 'Print the flags used for selecting multilibs (experimental)'
H99D8793DE319: 'マルチリブ選択用フラグを表示 (実験的)'
# 'Print the full library path of <file>'
H996FD2BF6EA4: 'ファイル <file> の完全なライブラリパスを表示'
# 'Print the full program path of <name>'
H6425BA00826B: 'プログラム名 <name> の完全なパスを表示'
# 'Print the generic op form'
H393E4B90F6FC: '汎用オペレーション形式を表示'
# 'Print the global id for each value when reading the module summary'
H017C8976AB50: 'モジュールサマリを読み込む際の各値のグローバルIDを表示'
# 'Print the instruction info view (enabled by default)'
HFDE24D0249FD: '命令情報ビューを表示（既定で有効）'
# 'Print the internal representation of the AST as JSON.'
H4463E0E4D8B4: 'ASTの内部表現をJSON形式で表示'
# 'Print the internal representation of the AST.'
H034FD53E1499: 'ASTの内部表現を表示'
# 'Print the last form of the IR before crash (use -print-on-crash-path to dump to a file)'
H05148AD74D0F: 'クラッシュ直前のIRの最終形式を表示（-print-on-crash-pathオプションでファイルにダンプ）'
# 'Print the last form of the IR before crash to a file'
H41B3ECBC245F: 'クラッシュ直前のIRの最終形式をファイルに出力'
# 'Print the library path for the currently used compiler runtime library ("libgcc.a" or "libclang_rt.builtins.*.a")'
H1C5056AC3308: '現在使用中のコンパイラランタイムライブラリ（"libgcc.a"または"libclang_rt.builtins.*.a"）のパスを表示'
# 'Print the list of headers to insert and remove'
H9F64205F2D86: '挿入および削除するヘッダーリストを表示'
# 'Print the list of registered dialects and exit'
H8D48045AF8B2: '登録済みの方言リストを表示して終了'
# 'Print the list of registered passes and exit'
HC59B7DDDC5DA: '登録済みのパスリストを表示して終了'
# 'Print the machine block frequency info.'
HD84FA75ACBC1: 'マシンブロック周波数情報を表示'
# 'Print the matched nodes.'
H4BB21D1928B8: '一致したノードを表示'
# 'Print the name of each compiled file'
HDCE85FDCBE9D: 'コンパイルされた各ファイルの名前を表示'
# 'Print the normalized target triple'
H96ECE7DAB2DE: '正規化されたターゲットトリプルを表示'
# 'Print the output in json format'
H7346664F1361: 'JSON形式で出力'
# 'Print the output of crashing program'
H8E49BCDD2D2A: 'クラッシュしたプログラムの出力を表示'
# 'Print the output of the dependency directives source minimizer'
HF8EAF7DCE928: '依存関係ディレクティブソースミニマイザの出力を表示'
# 'Print the overhead of checks matching this glob'
HC2F8104B88AF: 'このglobに一致するチェックのオーバーヘッドを表示'
# 'Print the path for the C++ Standard library module manifest'
H8EDB3804EDF6: 'C++標準ライブラリモジュールマニフェストのパスを表示'
# 'Print the paths used for finding ROCm installation'
H5DE6FB91D815: 'ROCMインストールを検出するために使用されるパスを表示します'
# 'Print the paths used for finding libraries and programs'
H88A6C4296147: 'ライブラリとプログラムを検出するために使用されるパスを表示します'
# 'Print the pipeline that will be run'
HB9A00F6CD048: '実行されるパイプラインを表示します'
# 'Print the registered targets'
H0D2C6AE9215B: '登録されているターゲットを表示します'
# 'Print the resource directory pathname'
HA37C029422E4: 'リソースディレクトリのパス名を表示します'
# 'Print the resource directory pathname that contains lib and include directories with the runtime libraries and MODULE files.'
HA7ED2E95EC04: 'リソースディレクトリのパス名を表示します。このディレクトリには、ランタイムライブラリとMODULEファイルを含むlibディレクトリとincludeディレクトリが含まれます。'
# 'Print the resource pressure view (enabled by default)'
HEECE83A65DB5: 'リソースプレッシャービューを表示（既定で有効）'
# 'Print the summary only.'
H174D6B098765: '要約のみを表示します。'
# 'Print the symbol being queried and all its relevant headers in\nJSON format to stdout:\n  {\n    "FilePath": "/path/to/foo.cc",\n    "QuerySymbolInfos": [\n       {"RawIdentifier": "foo",\n        "Range": {"Offset": 0, "Length": 3}}\n    ],\n    "HeaderInfos": [ {"Header": "\\"foo_a.h\\"",\n                      "QualifiedName": "a::foo"} ]\n  }'
H5CB3BBFB3D04: 'クエリされたシンボルとその関連するすべてのヘッダーをJSON形式で標準出力に表示：\n  {\n    "FilePath": "/path/to/foo.cc",\n    "QuerySymbolInfos": [\n       {"RawIdentifier": "foo",\n        "Range": {"Offset": 0, "Length": 3}}\n    ],\n    "HeaderInfos": [ {"Header": "\\"foo_a.h\\"",\n                      "QualifiedName": "a::foo"} ]\n  }'
# 'Print the timeline view'
H7E4B03837F1C: 'タイムラインビューを表示します'
# 'Print the tokenization of the file.'
H0F40582164F4: 'ファイルのトークン化を表示します。'
# 'Print to stdout'
H002EC692CF47: '標準出力に表示します。'
# 'Print type inference debug logs'
H97D56E58C1ED: '型推論デバッグログを表示します'
# 'Print unique SSA ID numbers for values, block arguments and naming conflicts across all regions'
H3CF739160E73: 'すべての領域における値、ブロック引数、および名前衝突のための一意のSSA ID番号を表示します'
# 'Print unique element ID'
H4EAB338925EE: '一意の要素IDを表示します'
# 'Print users of operation results and block arguments as a comment'
HFE8B9CDAE8D0: '操作結果とブロック引数の使用箇所をコメントとして表示します'
# 'Print version information'
H2471C1D1E728: 'バージョン情報を表示します'
# 'Print warnings as well as errors'
H5031BC87FCBE: 'エラーと警告を表示します'
# 'Print with local scope and inline information (eliding aliases for attributes, types, and locations)'
H7DD376461997: 'ローカルスコープとインライン情報を表示（属性、型、位置のエイリアスを省略）'
# 'Printing a logical representation of low-level debug information.\n'
HC0290F8303A5: '低レベルデバッグ情報の論理的表現を表示します。\n'
# "Prints 'unknown' intrinsics that were handled heuristically. Use -msan-dump-strict-instructions to print intrinsics that could not be handled exactly nor heuristically."
HE08944C3B0E2: "'unknown'イントリンクが推論処理された場合にその情報を出力します。-msan-dump-strict-instructionsオプションを使用すると、厳密な処理が不可能なイントリンクも出力されます。"
# 'Prints comments for instruction based on inline cost analysis'
H8F93FDBF8523: 'インラインコスト分析に基づく命令用のコメントを出力します'
# 'Prints debug information for the new pass manager'
H2612FCB765F4: '新しいpass managerのデバッグ情報を出力します'
# 'Prints full register names with percent'
HE6A6B46C9FA7: 'パーセント記号を含む完全なレジスタ名を出力します'
# 'Prints full register names with vs{31-63} as v{0-31}'
HBBE64D4048A6: 'vs{31-63}をv{0-31}として表示する完全なレジスタ名を出力します'
# 'Prints the blame context (if possible) for ALL instructions. This specifies the number of lines of context for non-BAD instructions (see --blame-context). If --blame-context is unspecified, it prints this number of contextual lines for BAD instructions as well.'
H1C7BC51D6E48: 'すべての命令のブレイムコンテキスト（可能であれば）を出力します。非BAD命令のコンテキスト行数を指定します（--blame-context参照）。--blame-contextが指定されていない場合、BAD命令のコンテキスト行数としてもこの値が使用されます。'
# 'Prints the combined library module before the output'
HF27FB27BCDA7: '出力前に結合されたライブラリモジュールを出力します'
# 'Prints the pass pipeline and returns.'
HB0A215EA899E: 'パスパイプラインを出力し終了します'
# 'Prioritize increasing vectorization opportunity over cache cost when determining profitability'
H3BBA969790D8: 'キャッシュコストではなくベクタライゼーションの機会を優先して最適化の利益を判定します'
# 'Probability value in the range [0.0, 1.0] of unconditional pseudo-random checks.'
HE60D8EB808AB: '[0.0, 1.0]の範囲における無条件の疑似ランダムチェックの確率値'
# 'Probability value in the range [0.0, 1.0] to keep instrumentation of a function. Note: instrumentation can be skipped randomly OR because of the hot percentile cutoff, if both are supplied.'
H055D3EE8123A: '[0.0, 1.0]の範囲における関数のインストルメンテーション保持確率値。注意: 両方指定された場合、インストルメンテーションはランダムにスキップされたり、ホットパーセンタイルのカットオフによりスキップされる可能性があります。'
# 'Proceed with Loop Idiom Vectorize Pass, but do not convert byte-compare loop(s).'
H5DD9E25ED00B: 'バイト比較ループを変換せずにループイディオムベクタライズPassを実行します'
# 'Proceed with loop idiom recognize pass, but do not convert loop(s) to memcpy.'
H0FF75025AEC2: 'memcpyにループを変換せずにループイディオム認識Passを実行します'
# 'Proceed with loop idiom recognize pass, but do not convert loop(s) to memset.'
H5ED765213633: 'memsetにループを変換せずにループイディオム認識Passを実行します'
# 'Proceed with loop idiom recognize pass, but do not convert loop(s) to strlen.'
HF94C8F5C3643: 'strlenにループを変換せずにループイディオム認識Passを実行します'
# 'Proceed with loop idiom recognize pass, enable conversion of loop(s) to wcslen.'
H3D374F7E71F0: 'wcslenへのループ変換を有効にした状態でループイディオム認識Passを実行します'
# 'Process Id for the profiled executable binary.'
HEAA24D9E11FE: 'プロファイル化された実行可能バイナリのプロセスID'
# 'Process Implicit Definitions'
H436E5B2FC994: 'インライン定義を処理します'
# 'Process functions in a top-down order defined by the profiled call graph when -sample-profile-top-down-load is on.'
HCCB8730D9A20: '-sample-profile-top-down-loadが有効な場合、プロファイル化されたコールグラフで定義されたトップダウン順序で関数を処理します'
# 'Process scops that are unlikely to benefit from Polly optimizations.'
H97882415014C: 'Polly最適化がほとんど利益をもたらさない可能性のあるscopsを処理します'
# 'Process source files in fixed form'
H83D6F8A6F254: '固定形式のソースファイルを処理する'
# 'Process source files in free form'
H00F60A25C21E: 'フリーフォームのソースファイルを処理する'
# 'Process trigraph sequences'
HE92D60C3DD89: 'トリグラフシーケンスを処理する'
# 'Processor register names.'
H69E6140DD062: 'プロセッサのレジスタ名。'
# 'Produce a faster access sequence for local-dynamic TLS variables where the offset from the TLS base is encoded as an immediate operand (AIX 64-bit only). This access sequence is not used for variables larger than 32KB.'
H96608A9C1D3A: 'local-dynamic TLS変数に対して、TLSベースからのオフセットを即値オペランドとしてエンコードするより高速なアクセスシーケンスを生成します（AIX 64ビットのみ）。このアクセスシーケンスは32KBを超える変数には使用されません。'
# 'Produce a faster access sequence for local-exec TLS variables where the offset from the TLS base is encoded as an immediate operand (AIX 64-bit only). This access sequence is not used for variables larger than 32KB.'
HDB020B6BCE8A: 'local-exec TLS変数に対して、TLSベースからのオフセットを即値オペランドとしてエンコードするより高速なアクセスシーケンスを生成します（AIX 64ビットのみ）。このアクセスシーケンスは32KBを超える変数には使用されません。'
# 'Produce gcov notes files (*.gcno)'
HA873BCAA45B3: 'gcov ノートファイル（*.gcno）を生成します'
# 'Produce progress indicator when performing measurements'
H2B5CD09D6FEE: '計測を実行する際に進捗インジケーターを生成します'
# 'Produce relaxation hints for linkers to try optimizing PIC call sequences into direct calls (MIPS only)'
HA18E999EA6E6: 'リンカがPICコールシーケンスを直接コールに最適化しようと試みるためのリラクセーションヒントを生成します（MIPSのみ）'
# "Produced object files can use all ELF features supported by this binutils version and newer. If -fno-integrated-as is specified, the generated assembly will consider GNU as support. 'none' means that all ELF features can be used, regardless of binutils support. Defaults to 2.26."
H0EBB90A612ED: '生成されたオブジェクトファイルは、このbinutilsバージョンとそれ以降でサポートされているすべてのELF機能を使用できます。-fno-integrated-asが指定された場合、生成されたアセンブリはGNU asのサポートを考慮します。"none"は、binutilsのサポートに関係なくすべてのELF機能が使用できることを意味します。デフォルトは2.26です。'
# "Produced object files can use all ELF features supported by this binutils version and newer.If -no-integrated-as is specified, the generated assembly will consider GNU as support.'none' means that all ELF features can be used, regardless of binutils support"
H1E14DD582B2D: '生成されたオブジェクトファイルは、このbinutilsバージョンとそれ以降でサポートされているすべてのELF機能を使用できます。-no-integrated-asが指定された場合、生成されたアセンブリはGNU asのサポートを考慮します。"none"は、binutilsのサポートに関係なくすべてのELF機能が使用できることを意味します'
# 'Produces individual indexes for distributed backends.'
H3927BD641AFE: '分散されたバックエンド用に個別のインデックスを生成します。'
# 'ProfGen Options'
HA88661D355E6: 'ProfGen オプション'
# "Profile action execution to a file, or stderr if  '-' is passed"
HF893EEFBCD55: 'ファイル（または"-"が指定された場合、標準エラー出力）にプロファイルアクションの実行を記録します'
# 'Profile file loaded by -sample-profile'
HD83B6219FC6C: '-sample-profileで読み込まれるプロファイルファイル'
# 'Profile kind supported by show:'
H1EF9A7F6A57E: 'show:でサポートされるプロファイル種類'
# 'Profile kind:'
H8083370A6330: 'プロファイル種類:'
# 'Profile remapping file loaded by -sample-profile'
H0C4B9EDC4542: '-sample-profileで読み込まれるプロファイルリマッピングファイル'
# 'Profile summary info'
H60C73C1F9C77: 'プロファイルサマリ情報'
# 'Profile uses flow sensitive discriminators'
H238CF0A82CE7: 'プロファイルはフローセンシティブディスクリミネーターを使用します'
# 'Profile with nested inlinee flatten out'
HDCD21980624B: 'ネストされたインラインのプロファイルを平坦化'
# 'Prologue end.'
HCA56411EA86A: 'プロローグの終了'
# 'Prologue/Epilogue Insertion'
H8D5DD8D22319: 'プロローグ/エピローグの挿入'
# 'Prologue/Epilogue Insertion & Frame Finalization'
HA5A6E86B1573: 'プロローグ/エピローグの挿入とフレームの最終化'
# 'Promote Memory to Register'
H8DCCB244621C: 'メモリをレジスタに昇格'
# 'Promote all vector constants'
HC242F7743ACD: 'すべてのベクタ定数を昇格'
# 'Propagate attributes in index'
HA59CB2A030BF: 'インデックス内の属性の伝搬'
# 'Propagate labels from condition values of select instructions to results.'
H2CDE89FF2376: 'select命令の条件値からラベルを結果に伝播'
# 'Propagate non floating-point const stores as floating point values.For debugging purposes only'
HE1F8858006F6: '非浮動小数点定数のストアを浮動小数点値として伝播。デバッグ目的のみ'
# 'Provide additional constraints on the context parameters'
H7259373CFB29: 'コンテキスト パラメーターへの追加の制約を指定'
# 'Provide information about a particular module file'
HA7807B5E312C: '特定のモジュールファイルに関する情報を提供'
# 'Provide minimal debug info in the object/executable to facilitate online symbolication/stack traces in the absence of .dwo/.dwp files when using Split DWARF'
HD5C39FAF7423: 'Split DWARFを使用し、.dwo/.dwpファイルがない場合でもオンラインシンボル化/スタックトレースを容易にするために、オブジェクト/実行可能ファイルに最小限のデバッグ情報を提供'
# 'Provide the index produced by a ThinLink, required to perform the promotion and/or importing.'
HF72EED5DEBD8: 'ThinLinkで生成されたインデックスを提供。昇格と/またはインポートを行うために必要'
# 'Prune dependences between unrelated Phi nodes.'
HF00163550893: '無関係なPhiノード間の依存関係を剪定'
# 'Prune loop carried order dependences.'
H49F00DC5D681: 'ループ伝播の順序依存関係を剪定'
# 'Put MODULE files in <dir>'
HEED5CC89CC67: 'MODULEファイルを<dir>に配置'
# 'Put crash-report files in <dir>'
H837FCDFF092D: 'クラッシュ レポート ファイルを<dir>に配置'
# 'Put each data item in its own section'
HF905C168CBCB: '各データ アイテムをそれぞれのセクションに配置'
# 'Put each function in its own section'
H169F18C51BFF: '各関数をそれぞれのセクションに配置'
# 'Put global and static data smaller than the limit into a special section'
H7B737FFA3469: '制限以下のグローバルおよび静的データを特別なセクションに配置'
# 'Put objects of at most <size> bytes into small data section (MIPS / Hexagon)'
HB5EE66FF14A5: '<size>バイト以下のオブジェクトをsmall dataセクションに配置します (MIPS/Hexagon)'
# 'Putting Jump Table in function section'
H0F2B2856EA39: 'Jump Tableを関数セクションに配置します'
# 'Qualified name of the symbol being queried.'
H4AFFA7C26BA4: '照会対象のシンボルの修飾名。'
# 'Qualified name to look up.'
H93CF54DB05CD: '検索する修飾名。'
# 'Queries LTOModule::hasCtorDtor() on each IR file'
HDD169C16F456: '各IRファイルに対してLTOModule::hasCtorDtor()を問い合わせます'
# 'Query a given symbol (e.g. "a::b::foo") in\ndatabase directly without parsing the file.'
H8F2B84E16EA3: 'ファイルを解析せずにデータベースから指定されたシンボル（例: "a::b::foo"）を直接問い合わせます。'
# 'Query string to be fuzzy-matched'
HA5E343EDC113: '曖昧一致させるためのクエリ文字列'
# 'Quotient that is obtained by dividing Nc, the parameter of themacro-kernel, by Nr, the parameter of the micro-kernel'
HFC3149B97C2A: 'マクロカーネルのパラメータNcをマイクロカーネルのパラメータNrで割った商'
# 'R600 Clause Merge'
HFCF9C3C3445E: 'R600 句マージ'
# 'R600 Control Flow Finalizer'
H19DB6E58B0FB: 'R600制御フロー最終処理'
# 'R600 Emit Clause Markers'
H668E900B8AFA: 'R600句のマーカーを出力'
# 'R600 Expand Special Instrs'
H12D8DBCC740A: 'R600特殊命令の展開'
# 'R600 Packetizer'
H38622892495A: 'R600パケット化'
# 'R600 Vector Reg Merger'
H9C6C89BC6C1D: 'R600ベクタレジスタマージ'
# 'R600ExpandSpecialInstrs'
HD068997DE698: 'R600特殊命令展開'
# 'RISC-V CodeGenPrepare'
H405FA7A845BC: 'RISC-V コード生成準備'
# 'RISC-V DAG->DAG Pattern Instruction Selection'
H1C9181DFD79E: 'RISC-V DAG→DAGパターン命令選択'
# 'RISC-V Dead register definitions'
HC73090960463: 'RISC-V死レジスタ定義'
# 'RISC-V Fold Masks'
H0F357F81783D: 'RISC-Vマスクの折り畳み'
# 'RISC-V Fold Memory Offset'
HBC0E6B2D64FC: 'RISC-Vメモリオフセットの折り畳み'
# 'RISC-V Insert Read/Write CSR Pass'
H05452489D81B: 'RISC-V 読み書きCSR挿入Pass'
# 'RISC-V Insert VSETVLI pass'
H38C90053B8F4: 'RISC-V VSETVLI挿入pass'
# 'RISC-V Insert Write VXRM Pass'
H73DBEFBC725F: 'RISC-V VXRM書き込み挿入Pass'
# 'RISC-V Landing Pad Setup'
HAD75D026A39E: 'RISC-V Landing Padセットアップ'
# 'RISC-V Late Branch Optimisation Pass'
HED8417E9F658: 'RISC-V 遅延分岐最適化Pass'
# 'RISC-V Load / Store Optimizer'
H10B62FA90EDD: 'RISC-V ロード/ストア最適化'
# 'RISC-V Make Compressible'
H0497794478D9: 'RISC-V 圧縮可能化'
# 'RISC-V Merge Base Offset'
HA38F1E005B04: 'RISC-V ベースオフセット統合'
# 'RISC-V Optimize W Instructions'
H2B91D1998005: 'RISC-V W命令最適化'
# 'RISC-V Redundant Copy Elimination'
HD915B17CC89F: 'RISC-V 不要なコピー削除'
# 'RISC-V VL Optimizer'
H811C35753CA5: 'RISC-V VL最適化'
# 'RISC-V VMV0 Elimination'
H474A6943E72F: 'RISC-V VMV0削除'
# 'RISC-V Zacas ABI fix'
HF1D5344F95CB: 'RISC-V Zacas ABI修正'
# 'RISC-V Zcmp Push/Pop optimization pass'
HD89E7CCB5461: 'RISC-V Zcmp Push/Pop最適化pass'
# 'RISC-V Zcmp move merging pass'
H9FBA8B3D1AEE: 'RISC-V Zcmpムーブマージpass'
# 'RISC-V atomic pseudo instruction expansion pass'
H3692DAF330DE: 'RISC-V アトミック仮命令展開pass'
# 'RISC-V gather/scatter lowering pass'
H05AC68772FF6: 'RISC-V ゲッター/スキャターローワリングpass'
# "RISC-V interrupt attribute '%0' requires extension '%1'"
H6CFF2777C071: "RISC-V割り込み属性'%0'は拡張'%1'が必要です"
# 'RISC-V post-regalloc pseudo instruction expansion pass'
H7D576AB43EFF: 'RISC-V レジスタ割り当て後の仮命令展開pass'
# 'RISC-V pseudo instruction expansion pass'
H0A43861EEE99: 'RISC-V 仮命令展開pass'
# "RISC-V type %0 requires the '%1' extension"
HD2DE400562E4: "RISC-Vのタイプ%0には拡張'%1'が必要です"
# 'ROCm device library path. Alternative to rocm-path.'
H671F96D79AC7: 'ROCmデバイスライブラリのパス。rocm-pathの代替。'
# 'ROCm installation path, used for finding and automatically linking required bitcode libraries.'
HF802D566C208: 'ROCmのインストールパス。必要なビットコードライブラリを検索し自動的にリンクするために使用します。'
# 'ROPI is not compatible with c++'
HF729D02F7368: 'ROPIはC++と互換性がありません。'
# 'RTDyld Options'
HE939F729D84E: 'RTDyld オプション'
# 'Random hotness seed to use (0 to generate new seed)'
H8A5B93398F3C: '使用するランダムhotnessシード（0で新しいシードを生成）'
# 'Range reduction is disabled for complex arithmetic operations'
H2F5A5383A90A: '複素数の算術演算ではレンジリダクションが無効になっています。'
# 'Range reduction is enabled for complex arithmetic operations.'
H9F0817B3FD56: '複素数の算術演算ではレンジリダクションが有効になっています。'
# 'Range to search for II'
HFC1D9F881BD5: 'IIを検索する範囲'
# 'Ratio of VGPRs to budget for promoting alloca to vectors'
H825278A853D1: 'allocaをベクタに昇格するためのVGPRsの割合を予算に設定します'
# 'Re-materialize load from stub in PIC mode'
H3683BABDE7E9: 'PICモードでstubからロードを再マテリアル化します。'
# 'ReachingDefAnalysis'
H10A4CB1F102D: 'ReachingDefAnalysis'
# 'Read commands from file'
HDC06C8ECE255: 'ファイルからコマンドを読み込む'
# 'Read specified document from input (default = 1)'
H289DB22297D5: '入力から指定されたドキュメントを読み込みます（デフォルトは1）'
# 'Read summary from given YAML file before running pass'
HA5D8047CC861: 'パスの実行前に指定されたYAMLファイルからサマリを読み込みます'
# 'Read summary from given bitcode or YAML file before running pass'
HF2C570D041A3: 'パスの実行前に指定されたビットコードまたはYAMLファイルからサマリを読み込みます'
# 'Read-write data relocatable, accessed relative to static base'
HDB933E15EC9A: '読み書き可能な再配置可能なデータ、静的ベースに対する相対アクセス'
# 'Reads and parses a basic block sections profile.'
HB98EF81EB7F2: 'ベーシックブロックセクションプロファイルを読み取り解析します。'
# 'Realign stack to the value of this flag (power of two)'
H85DCE488EFC2: 'このフラグの値（2のべき乗）にスタックを再整列します'
# 'Reassociate expressions'
H525BB5A9D397: '式を再結合する'
# 'Rebalance address calculation trees to improve instruction selection'
HD14562B4E0A1: 'アドレス計算ツリーを再バランス化して、命令選択を改善する'
# 'Rebalance address tree only if it is imbalanced'
HB25FBDDE88D4: 'アドレスツリーが不均衡な場合のみ再バランス化する'
# 'Rebalance address tree only if this allows optimizations'
H15A2B09D172E: '最適化が可能である場合のみアドレスツリーを再バランス化する'
# 'Reciprocal throughput'
H5BE31D7872D9: '逆数スループット'
# 'Recognize Hexagon-specific loop idioms'
H0CB87B633349: 'Hexagon固有のループイディオムを認識する'
# 'Recognize and construct Pascal-style string literals'
HA6AC1DFB5663: 'Pascalスタイルの文字列リテラルを認識し構築する'
# 'Recognize reduction patterns.'
H8EBBA21EF01B: '削減パターンを認識する。'
# 'Record GlobalISel rule coverage files of this prefix if instrumentation was generated'
HB262A353ECFE: 'インストルメンテーションが生成された場合、このプレフィックスのGlobalISelルールカバレッジファイルを記録する'
# 'Record stack frames with tagged allocations in a thread-local ring buffer'
H1B5FE744704A: 'スレッドローカルのリングバッファにタグ付きアロケーションを持つスタックフレームを記録する'
# 'Record time trace'
H572EF7DA605F: 'タイムトレースを記録する'
# 'Recursively extract all called functions'
H04C195C76643: '再帰的に呼び出されたすべての関数を抽出する'
# 'Redirect output to the specified file.'
H7E10ABCF17E8: '出力を指定されたファイルにリダイレクトする。'
# 'Reduce named metadata without taking its type into account'
H057F6A50F385: 'その型を考慮せずに名前付きメタデータを削減する'
# 'Reduce terminal output'
H77FB68186DA4: 'ターミナル出力を削減する'
# 'Reduce the number of instrumented blocks'
HCA859F9847BF: 'インストルメント化されたブロックの数を削減する'
# 'Reduced priority compared to interactive work.'
H7591B998C026: 'インタラクティブ作業に比べて優先度が低い。'
# 'Refactoring options'
HF98C4D962B99: 'リファクタリングオプション'
# 'Reference type.'
HECBDD73B4748: '参照型。'
# 'Refrain from using FP whenever possible'
H567347A5F936: '可能な限りFPを使用しない'
# 'Regalloc eviction policy'
HF2E6FE69E8A8: 'Regalloc排出ポリシー'
# 'Regalloc priority policy'
H20E1A4B298F4: 'レジスタ割り当ての優先度ポリシー'
# 'Regard unreachable functions as possible devirtualize targets.'
HC7FBD9EBE035: '到達不能な関数を仮想化解除の対象として扱う'
# "Regex of name of op's to exclude (no filter if empty)"
HA7F3D7BB58EA: '除外対象のオペレーション名の正規表現（空の場合はフィルタなし）'
# "Regex of name of op's to include (no filter if empty)"
H5284DD90C012: '包含対象のオペレーション名の正規表現（空の場合はフィルタなし）'
# 'Register Allocation Scoring Pass'
H4ED04651AE8B: 'レジスタ割り当てスコアリングパス'
# 'Register Coalescer'
HAC4DFBDFBBCC: 'レジスタ結合アルゴリズム'
# 'Register Usage Information Collector'
HE69ABB0B3B23: 'レジスタ使用状況情報収集'
# 'Register Usage Information Propagation'
H3B0328B5CFCB: 'レジスタ使用状況情報伝播'
# 'Register Usage Information Storage'
H9CFCD5C04174: 'レジスタ使用状況情報格納'
# 'Register allocator to use'
H01245B8A9746: '使用するレジスタ割り当てアルゴリズム'
# 'Register allocator to use for RVV register.'
H16A5AC5915C9: 'RVV レジスタに使用するレジスタ割り当てアルゴリズム'
# 'Register allocator to use for SGPRs'
H14FE52F5159B: 'SGPRs用のレジスタ割り当てアルゴリズム'
# 'Register allocator to use for VGPRs'
HB6E601BA3FB0: 'VGPRs用のレジスタ割り当てアルゴリズム'
# 'Register allocator to use for WWM registers'
H2FF0F90865DC: 'WWM レジスタ用のレジスタ割り当てアルゴリズム'
# 'Register allocator to use for new pass manager'
H2F824F849DFC: '新しいパスマネージャ用のレジスタ割り当てアルゴリズム'
# 'Reject specializations whose codesize savings are less than this much percent of the original function size'
H6EAED91C8037: '元の関数サイズのこのパーセンテージ未満のコードサイズ削減をもつ特殊化を拒否'
# 'Reject specializations whose inlining bonus is less than this much percent of the original function size'
H6A8C88532B88: '元の関数サイズのこのパーセンテージ未満のインラインボーナスをもつ特殊化を拒否'
# 'Reject specializations whose latency savings are less than this much percent of the original function size'
H289ADC17A173: '元の関数サイズのこのパーセンテージ未満のレイテンシ削減をもつ特殊化を拒否'
# 'Reject the profile if the mismatch percent is higher than the given number.'
H8455CF01EC30: '指定された数値より不一致パーセンテージが高いプロファイルを拒否'
# 'Relation kind for the predicate.'
HA372CC9D1BF6: '述語の種類関係'
# 'Relative error tolerated'
HA4C6C4674C77: '許容される相対誤差'
# 'Relative frequency of outline region to the entry block'
H22B3E2A06E70: 'エントリーブロックに対するアウトライン領域の相対頻度'
# 'Relative hotness percentage threshold for indirect call promotion in proirity-based sample profile loader inlining.'
H046C25DB3427: '優先度ベースのサンプルプロファイルローダーインラインにおける間接呼び出しの昇格のためのホットネスのパーセンテージしきい値'
# 'Relax checks of new-value validity'
H6708AC4FB40C: '新しい値の有効性に関するチェックを緩和'
# "Relax language rules and try to match the behavior of the target's native float-to-int conversion instructions"
HC867ACE28A09: '言語規則を緩和し、ターゲットのネイティブなfloat-to-int変換命令の動作に一致するように試みる'
# 'Relax occupancy targets for kernels which are memory bound (amdgpu-membound-threshold), or Wave Limited (amdgpu-limit-wave-threshold).'
HF2EE3E994ED5: 'メモリーバウンド（amdgpu-membound-threshold）またはWave Limited（amdgpu-limit-wave-threshold）なカーネルに対する占有目標を緩和'
# 'Relax out of range conditional branches'
H0294D6B1AD74: '範囲外の条件分岐を緩和'
# 'Relocatable external references, non-relocatable code'
H5C17064AB794: '再配置可能な外部参照、非再配置可能なコード'
# 'Remapping file'
H3732B171A6F4: 'リマッピングファイル'
# 'Remark file utilities\n'
HF16F906278C7: 'リマークファイルのユーティリティ\n'
# 'Remote execution (rsh/ssh) extra options'
H866585C76383: 'リモート実行（rsh/ssh）の追加オプション'
# 'Remote execution (rsh/ssh) host'
HBAFCAFBDA09E: 'リモート実行（rsh/ssh）のホスト'
# 'Remote execution (rsh/ssh) port'
HF897190244A2: 'リモート実行（rsh/ssh）のポート'
# 'Remote execution (rsh/ssh) user id'
H34FEDDEF1D08: 'リモート実行（rsh/ssh）のユーザーID'
# 'Remote execution client (rsh/ssh)'
H9FB0D35F3462: 'リモート実行情報クライアント（rsh/ssh）'
# 'Remove .symtab section'
HDFF82FC1A75B: '.symtabセクションを削除'
# "Remove CUDA/HIP offloading device architecture (e.g. sm_35, gfx906) from the list of devices to compile for. 'all' resets the list to its default value."
HC1BC07C832AB: 'CUDA/HIPオフロードデバイスアーキテクチャ（例: sm_35, gfx906）をコンパイル対象リストから削除。"all"はリストをデフォルト値に戻します。'
# 'Remove Loads Into Fake Uses'
H633E035AD42E: 'フェイクユースへのロードを削除'
# 'Remove Redundant DEBUG_VALUE analysis'
H9B54876630EC: '余分なDEBUG_VALUE分析を削除'
# 'Remove Sign and Zero Extends for Args'
H7F0FDF466871: '引数のサインおよびゼロ拡張を削除'
# "Remove an attribute from a function. This can be a pair of 'function-name:attribute-name' to remove an attribute from a specific function. For example -force-remove-attribute=foo:noinline. Specifying only an attribute will remove the attribute from all functions in the module. This option can be specified multiple times."
HC96183D47DE8: '関数から属性を削除します。これは、特定の関数から属性を削除する「function-name:attribute-name」のペアにすることができます。例: -force-remove-attribute=foo:noinline. 単に属性のみを指定すると、モジュール内のすべての関数から属性を削除します。このオプションは複数回指定可能です。'
# 'Remove dead machine instructions'
H849DB0ECAC7B: '不要なマシン命令を削除します。'
# 'Remove duplicate DecoderTable entries generated due to HwModes'
HA7463EA0ACB3: 'HwModesによる重複したDecoderTableエントリを削除します。'
# 'Remove pseudo-probe after sample profile annotation.'
H6C8C4BABBDBA: 'サンプルプロファイル注釈後に擬似プローブを削除します。'
# 'Remove redundant Address-Size override prefix'
H8CDB6DE4DE72: '不要なAddress-Sizeオーバーライドプレフィックスを削除します。'
# 'Remove redundant instructions'
HC432DEAE7361: '不要な命令を削除します。'
# 'Remove the change description files regardless of successful\nmerging/replacing.'
HE8F5AA354FF8: '変更説明ファイルを削除し、マージまたは置換の成功に関わらず行います。'
# 'Remove unreachable blocks from the CFG'
H71C9E890BAC6: '制御フローグラフ(CFG)から到達不能ブロックを削除します。'
# 'Remove unreachable machine basic blocks'
H6EBEC50FE707: '到達不能なマシン基本ブロックを削除します。'
# 'Removes debug compile units which reference to non-existing global constants'
HEC2FF74E6087: '存在しないグローバル定数を参照するデバッグコンパイルユニットを削除します。'
# 'Removes empty basic blocks and redirects their uses to their fallthrough blocks.'
H1E3948BB5559: '空の基本ブロックを削除し、それらの使用をフォールスルー・ブロックに転送します。'
# 'Removes irreducible control flow'
HD2920C925B96: '不可約な制御フローを削除します。'
# 'Removes range checks and sets br_table default targets'
H2B9F2567CD82: 'レンジチェックを削除し、br_tableのデフォルトターゲットを設定します。'
# 'Rename Independent Subregisters'
HE4B797E90A33: '独立したサブレジスタを名前変更します。'
# 'Rename Register Operands'
H1AB17AA29EA4: 'レジスタオペランドを名前変更します。'
# 'Rename Register Operands Canonically'
H9BD8A9C1263B: 'レジスタオペランドを正規化して名前変更します。'
# 'Rename counter variable of a comdat function based on cfg hash'
HB71CC1C2B75A: 'cfgハッシュに基づいてcomdat関数のカウンタ変数を名前変更します。'
# 'Renames all instructions (including user-named)'
H357FB4296AFA: 'すべての命令を名前変更します（ユーザー指定の名前も含む）。'
# 'Reorder instructions to use the WebAssembly value stack'
H6D195AC096F5: 'WebAssembly値スタックを使用するために命令を再配置します。'
# 'Reorders blocks in topological order'
H903DAE6FC729: 'トポロジカル順序にブロックを再配置します。'
# 'Repack arrays that are non-contiguous in any dimension. If set to false, only the arrays non-contiguous in the leading dimension will be repacked'
H16B0416B17A1: 'どの次元でも非連続な配列を再パックします。falseに設定した場合、先頭次元で非連続な配列のみが再パックされます'
# 'Repeat compilation N times for timing'
HD8053595EBB4: 'タイム測定のため、コンパイルをN回繰り返す'
# "Replace 'mul x, Const' with more effective instructions like SHIFT, LEA, etc."
HC54A5626311D: "'mul x, Const'をSHIFT、LEAなどのより効果的な命令に置き換えます"
# 'Replace ARM non-local ADR instructions with ADRP'
H4558533FD5F3: 'ARMの非ローカルADR命令をADRPに置き換えます'
# 'Replace PHIs by their incoming values'
H49377A409B02: 'PHIを入力値で置き換えます'
# 'Replace all memory allocation / deallocation calls with hipManagedMalloc / hipFree equivalents'
HC778D804F89A: 'すべてのメモリ割り当て/解放コールをhipManagedMalloc/hipFreeの対応物に置き換えます'
# 'Replace intrinsics with calls to vector library'
H4BF82E4A463A: '組み込み関数をベクタライブラリのコールに置き換えます'
# 'Replace narrow shifts with wider shifts.'
HF4525F5A5F2E: '狭いシフトをより広いシフトに置き換えます'
# 'Replace occurrences of __nvvm_reflect() calls with 0/1'
H9A0C0F0562E0: '__nvvm_reflect()の呼び出しを0/1で置き換えます'
# 'Replace physical registers with virtual registers'
H2480E837105C: '物理レジスタを仮想レジスタに置き換えます'
# 'Replace pointer out arguments with struct returns for non-private address space'
H8307543C4AE7: '非プライベートアドレス空間のポインタ出力引数を構造体型の戻り値に置き換えます'
# 'Replace returns with jumps to ``__x86_return_thunk`` (x86 only, error otherwise)'
H59B021D12978: '戻り値を``__x86_return_thunk``へのジャンプに置き換えます（x86のみ対応、それ以外ではエラー）'
# 'Replace string for rename'
H722DD7E4F6B2: 'リネーム用の文字列を置き換えます'
# 'Replace target triples in input files with this triple'
H1FCD419A56EC: '入力ファイル内のターゲットトリプルをこのトリプルで置き換えます'
# 'Replace the contents of the <from> file with the contents of the <to> file'
H96ECB37ACA86: '<from>ファイルの内容を<to>ファイルの内容で置き換えます'
# 'Replace unspecified target triples in input files with this triple'
H1555B263A14F: '入力ファイル内の未指定のターゲットトリプルをこのトリプルで置き換えます'
# 'Replacement Options'
H70C1BA182651: '置換オプション'
# 'Replay on functions that have remarks associated with them (default)'
H318EBF2AE0C8: 'リマーカーが関連する関数で再実行（デフォルト）'
# 'Replay on the entire module'
H7E3D6FBCD48C: 'モジュール全体で再実行'
# 'Replay previous inlining and adjust context profile accordingly'
HC992566EB323: '以前のインラインを再実行し、コンテキストプロファイルをそれに合わせて調整'
# 'Report Options'
HB03D5D95141E: 'レポート オプション'
# 'Report host JIT support'
HD82BFA66FA55: 'ホストJITサポートのレポートを出力'
# 'Report missed transformations by optimization passes whose name matches the given POSIX regular expression'
H38AEDA823701: '指定されたPOSIX正規表現に一致する名前の最適化パスによる見逃された変換を報告'
# 'Report top stacks within each thread id'
H9AC494BD87C5: '各スレッドID内のトップスタックを報告'
# 'Report top/bottom cycles when dumping SUnit instances'
H06A96EFDD1F5: 'SUnitインスタンスをダンプする際にトップ/ボトムのサイクルを報告'
# 'Report total allocation sizes of hinted allocations'
H900F23D3261D: 'ヒント付きアロケーションの合計割り当てサイズを報告'
# 'Report transformation analysis from optimization passes whose name matches the given POSIX regular expression'
HB0E9E547E094: '指定されたPOSIX正規表現に一致する名前の最適化パスからの変換分析を報告'
# 'Report transformations performed by optimization passes whose name matches the given POSIX regular expression'
H815014839294: '指定されたPOSIX正規表現に一致する名前の最適化パスが実行した変換を報告'
# 'Reports layout used for print, compare and select.'
HF32D32507443: 'プリント、比較、選択に使用されるレイアウトを報告します。'
# 'Require & in extract patterns'
H9F971AAB4945: '抽出パターンに&を必須'
# 'Require all positive matches to cover an entire input line.\nAllows leading and trailing whitespace if --strict-whitespace\nis not also passed.'
HA9004341F6EF: '正規表現の一致が入力行全体をカバーする必要があります。\n--strict-whitespaceが指定されていない場合、先頭と末尾の空白を許可します。'
# 'Require declaration of modules used within a module'
HE82DE2BF2262: 'モジュール内で使用されるモジュール宣言を要求'
# 'Require math functions to indicate errors by setting errno'
HE643AF2E91DD: 'errnoを設定して数学関数がエラーを示すように要求'
# 'Require member pointer base types to be complete if they would be significant under the Microsoft ABI'
HF98EE3CAFBC8: 'Microsoft ABIで重要な場合、メンバーポインタのベース型が完全であることを要求'
# 'Require target function definition when promoting indirect calls'
H559562EE460E: '間接呼び出しをプロモートする際にターゲット関数定義を要求'
# 'Reserve application registers (%g2-%g4)'
H9C435D2EFFB6: '%g2-%g4のアプリケーションレジスタを予約'
# "Reserve physical registers, so they can't be used by register allocator. Should only be used for testing register allocator."
HB426310B498F: '物理レジスタを予約し、レジスタオーバロケータがそれらを使用できないようにします。レジスタオーバロケータのテストにのみ使用してください。'
# 'Reserve register r19 (Hexagon only)'
HDD745592B167: 'レジスタr19を予約 (Hexagonのみ)'
# 'Reserve the G1 register (SPARC only)'
H20A9F2798EED: 'G1レジスタを予約 (SPARCのみ)'
# 'Reserve the G2 register (SPARC only)'
HF2BF8B6A9338: 'G2レジスタを予約 (SPARCのみ)'
# 'Reserve the G3 register (SPARC only)'
HEFD5459112F2: 'G3 レジスタを予約する (SPARC専用)'
# 'Reserve the G4 register (SPARC only)'
HED0501965935: 'G4 レジスタを予約する (SPARC専用)'
# 'Reserve the G5 register (SPARC only)'
H484BE92A9AAA: 'G5 レジスタを予約する (SPARC専用)'
# 'Reserve the G6 register (SPARC only)'
H3E53244E7E33: 'G6 レジスタを予約する (SPARC専用)'
# 'Reserve the G7 register (SPARC only)'
H8A30A1691BA0: 'G7 レジスタを予約する (SPARC専用)'
# 'Reserve the I0 register (SPARC only)'
H42D22EDC8263: 'I0 レジスタを予約する (SPARC専用)'
# 'Reserve the I1 register (SPARC only)'
HDC1C8763F288: 'I1 レジスタを予約する (SPARC専用)'
# 'Reserve the I2 register (SPARC only)'
HF4C9D78BA277: 'I2 レジスタを予約する (SPARC専用)'
# 'Reserve the I3 register (SPARC only)'
H6F74928ECDE5: 'I3 レジスタを予約する (SPARC専用)'
# 'Reserve the I4 register (SPARC only)'
H96A8F3461A2B: 'I4 レジスタを予約する (SPARC専用)'
# 'Reserve the I5 register (SPARC only)'
H2CC0E7760C25: 'I5 レジスタを予約する (SPARC専用)'
# 'Reserve the L0 register (SPARC only)'
HE5E9B59351B3: 'L0 レジスタを予約する (SPARC専用)'
# 'Reserve the L1 register (SPARC only)'
HC7B2711CCD38: 'L1 レジスタを予約する (SPARC専用)'
# 'Reserve the L2 register (SPARC only)'
HE3E6D3620DCE: 'L2 レジスタを予約する (SPARC専用)'
# 'Reserve the L3 register (SPARC only)'
H2079C316B58D: 'L3 レジスタを予約する (SPARC専用)'
# 'Reserve the L4 register (SPARC only)'
HFDCEA5E83E9A: 'L4 レジスタを予約する (SPARC専用)'
# 'Reserve the L5 register (SPARC only)'
H0DAAEFB046EA: 'L5 レジスタを予約する (SPARC専用)'
# 'Reserve the L6 register (SPARC only)'
HA3AB8DC9562A: 'L6 レジスタを予約する (SPARC専用)'
# 'Reserve the L7 register (SPARC only)'
HCB368E5B3769: 'L7 レジスタを予約する (SPARC専用)'
# 'Reserve the O0 register (SPARC only)'
H23D89F231DEE: 'O0 レジスタを予約する (SPARC専用)'
# 'Reserve the O1 register (SPARC only)'
H565A40459A05: 'O1 レジスタを予約 (SPARCのみ)'
# 'Reserve the O2 register (SPARC only)'
H36A0BD878A7A: 'O2 レジスタを予約 (SPARCのみ)'
# 'Reserve the O3 register (SPARC only)'
H254E112FF4DF: 'O3 レジスタを予約 (SPARCのみ)'
# 'Reserve the O4 register (SPARC only)'
H1284739ABBC2: 'O4 レジスタを予約 (SPARCのみ)'
# 'Reserve the O5 register (SPARC only)'
H855A27DC8B76: 'O5 レジスタを予約 (SPARCのみ)'
# 'Reserve the a0 register (M68k only)'
HC6CC635B6FFE: 'a0 レジスタを予約 (M68kのみ)'
# 'Reserve the a1 register (M68k only)'
H1017DAEE99AB: 'a1 レジスタを予約 (M68kのみ)'
# 'Reserve the a2 register (M68k only)'
H7621CB376F01: 'a2 レジスタを予約 (M68kのみ)'
# 'Reserve the a3 register (M68k only)'
HE22C009182A1: 'a3 レジスタを予約 (M68kのみ)'
# 'Reserve the a4 register (M68k only)'
H3178F7022236: 'a4 レジスタを予約 (M68kのみ)'
# 'Reserve the a5 register (M68k only)'
HA629301B0BC6: 'a5 レジスタを予約 (M68kのみ)'
# 'Reserve the a6 register (M68k only)'
H94D9B1D39C5A: 'a6 レジスタを予約 (M68kのみ)'
# 'Reserve the d0 register (M68k only)'
H9890925E1B8B: 'd0 レジスタを予約 (M68kのみ)'
# 'Reserve the d1 register (M68k only)'
H9D44B760CA90: 'd1 レジスタを予約 (M68kのみ)'
# 'Reserve the d2 register (M68k only)'
H7A1C1C89C2E5: 'd2 レジスタを予約 (M68kのみ)'
# 'Reserve the d3 register (M68k only)'
H2D88664BB126: 'd3 レジスタを予約 (M68kのみ)'
# 'Reserve the d4 register (M68k only)'
HA604540B0E07: 'd4 レジスタを予約 (M68kのみ)'
# 'Reserve the d5 register (M68k only)'
H90F714B743C6: 'd5 レジスタを予約 (M68kのみ)'
# 'Reserve the d6 register (M68k only)'
H39C48EDA520F: 'd6 レジスタを予約 (M68kのみ)'
# 'Reserve the d7 register (M68k only)'
H02BEF5875762: 'd7 レジスタを予約 (M68kのみ)'
# 'Reserve the r9 register (ARM only)'
H32BC76F3A5B8: 'r9 レジスタを予約 (ARMのみ)'
# 'Reserve the x1 register (AArch64/RISC-V only)'
H017A3C6C7049: 'x1 レジスタを予約 (AArch64/RISC-Vのみ)'
# 'Reserve the x10 register (AArch64/RISC-V only)'
H2D00D0C6D8F6: 'x10 レジスタを予約 (AArch64/RISC-Vのみ)'
# 'Reserve the x11 register (AArch64/RISC-V only)'
H22733F8F5483: 'x11 レジスタを予約 (AArch64/RISC-Vのみ)'
# 'Reserve the x12 register (AArch64/RISC-V only)'
HAA70056FA5B7: 'x12 レジスタを予約 (AArch64/RISC-Vのみ)'
# 'Reserve the x13 register (AArch64/RISC-V only)'
H50BB54A67F09: 'x13 レジスタを予約 (AArch64/RISC-Vのみ)'
# 'Reserve the x14 register (AArch64/RISC-V only)'
HE826489CFC34: 'x14 レジスタを予約 (AArch64/RISC-Vのみ)'
# 'Reserve the x15 register (AArch64/RISC-V only)'
HC23E86C037A9: 'x15 レジスタを予約 (AArch64/RISC-Vのみ)'
# 'Reserve the x16 register (AArch64/RISC-V only)'
H86953DAD10E7: 'x16 レジスタを予約 (AArch64/RISC-Vのみ)'
# 'Reserve the x17 register (AArch64/RISC-V only)'
HE02356B0C142: 'x17 レジスタを予約 (AArch64/RISC-Vのみ)'
# 'Reserve the x18 register (AArch64/RISC-V only)'
HF2317F641E49: 'x18 レジスタを予約 (AArch64/RISC-Vのみ)'
# 'Reserve the x19 register (AArch64/RISC-V only)'
H8F6A7020EC68: 'x19 レジスタを予約 (AArch64/RISC-Vのみ)'
# 'Reserve the x2 register (AArch64/RISC-V only)'
HDEC6D50548DB: 'x2 レジスタを予約 (AArch64/RISC-Vのみ)'
# 'Reserve the x20 register (AArch64/RISC-V only)'
H45338EFD5444: 'x20 レジスタを予約 (AArch64/RISC-Vのみ)'
# 'Reserve the x21 register (AArch64/RISC-V only)'
HA93990937323: 'x21 レジスタを予約 (AArch64/RISC-Vのみ)'
# 'Reserve the x22 register (AArch64/RISC-V only)'
H26B62228E618: 'x22 レジスタを予約 (AArch64/RISC-Vのみ)'
# 'Reserve the x23 register (AArch64/RISC-V only)'
HF22114CBFC6D: 'x23 レジスタを予約 (AArch64/RISC-Vのみ)'
# 'Reserve the x24 register (AArch64/RISC-V only)'
H83F65EC51004: 'x24 レジスタを予約 (AArch64/RISC-Vのみ)'
# 'Reserve the x25 register (AArch64/RISC-V only)'
H2B3946E5495E: 'x25 レジスタを予約 (AArch64/RISC-Vのみ)'
# 'Reserve the x26 register (AArch64/RISC-V only)'
H094A3CECAC3C: 'x26 レジスタを予約 (AArch64/RISC-Vのみ)'
# 'Reserve the x27 register (AArch64/RISC-V only)'
H061585C0784C: 'x27レジスタを予約します (AArch64/RISC-Vのみ)'
# 'Reserve the x28 register (AArch64/RISC-V only)'
H1DF10547E904: 'x28レジスタを予約します (AArch64/RISC-Vのみ)'
# 'Reserve the x29 register (AArch64/RISC-V only)'
H87F78D168B6D: 'x29レジスタを予約します (AArch64/RISC-Vのみ)'
# 'Reserve the x3 register (AArch64/RISC-V only)'
H725FF72DC894: 'x3レジスタを予約します (AArch64/RISC-Vのみ)'
# 'Reserve the x30 register (AArch64/RISC-V only)'
H59143D663AD6: 'x30レジスタを予約します (AArch64/RISC-Vのみ)'
# 'Reserve the x31 register (AArch64/RISC-V only)'
HFFDF93DA3671: 'x31レジスタを予約します (AArch64/RISC-Vのみ)'
# 'Reserve the x4 register (AArch64/RISC-V only)'
H9F239EBCD413: 'x4レジスタを予約します (AArch64/RISC-Vのみ)'
# 'Reserve the x5 register (AArch64/RISC-V only)'
H2EA831621531: 'x5レジスタを予約します (AArch64/RISC-Vのみ)'
# 'Reserve the x6 register (AArch64/RISC-V only)'
HCE48DE527FE3: 'x6レジスタを予約します (AArch64/RISC-Vのみ)'
# 'Reserve the x7 register (AArch64/RISC-V only)'
HD802526DCF57: 'x7レジスタを予約します (AArch64/RISC-Vのみ)'
# 'Reserve the x8 register (AArch64/RISC-V only)'
H37CBBA5AD749: 'x8レジスタを予約します (AArch64/RISC-Vのみ)'
# 'Reserve the x9 register (AArch64/RISC-V only)'
H0CB86AACC5EE: 'x9レジスタを予約します (AArch64/RISC-Vのみ)'
# 'Reset machine function if ISel failed'
H7A45CC070EB3: 'ISelが失敗した場合、マシン関数をリセット'
# 'Resolution-based LTO test harness'
HFC41C14199C7: '解決に基づくLTOテストハーネス'
# 'Resolve file paths relative to the specified directory'
HB397A2AE991E: '指定されたディレクトリを基にファイルパスを相対パスとして解決'
# 'Restore original linkage of globals prior to CodeGen'
H30AC23ACCA7B: 'CodeGen前にグローバルの元のlinkageを復元'
# 'Restore the default behavior of not embedding source text in DWARF debug sections'
H98E5316CC560: 'DWARFデバッグセクションにソーステキストを埋め込まないデフォルト動作を復元'
# 'Restore the default behaviour of not generating long calls'
H49E0BF0F6145: 'ロングコールを生成しないデフォルト動作を復元'
# 'Restrict DWARF features to those defined in the specified version, avoiding features from later versions.'
H3EFE36E674FA: '指定されたバージョンで定義されたDWARF機能のみを使用し、後続のバージョンの機能を回避します'
# 'Restrict all prior -I flags to double-quoted inclusion and remove current directory from include path'
H3D88078880FD: '前のすべての-Iフラグをダブルクォートで囲まれたインクルージョンに限定し、現在のディレクトリをインクルードパスから削除'
# 'Restrict code to those available for App Extensions'
H187919D11FCC: 'アプリ拡張機能で利用可能なコードに制限します'
# 'Restrict range of B instructions (DEBUG)'
HC083C6F4C8EE: 'B命令の範囲を制限（デバッグ）'
# 'Restrict range of BPcc/FBPfcc instructions (DEBUG)'
H85B5CACDDD43: 'BPcc/FBPfcc命令の範囲を制限（デバッグ）'
# 'Restrict range of BPr instructions (DEBUG)'
H0FAB44C44A31: 'BPr命令の範囲を制限（デバッグ）'
# 'Restrict range of Bcc instructions (DEBUG)'
H400749DA0205: 'Bcc命令の範囲を制限（デバッグ）'
# 'Restrict range of CB instructions (DEBUG)'
HE052E990A1F8: 'CB命令の範囲を制限（デバッグ）'
# 'Restrict range of CB[N]Z instructions (DEBUG)'
HCAA4E790CDDA: 'CB[N]Z命令の範囲を制限（デバッグ）'
# 'Restrict range of TB[N]Z instructions (DEBUG)'
H8319D33A4041: 'TB[N]Z命令の範囲を制限（デバッグ）'
# 'Restrict range of branch instructions (DEBUG)'
H80C66F8F6D0A: '分岐命令の範囲を制限（デバッグ）'
# 'Restrict range of loopN instructions (testing only)'
HDC7B8D8739B5: 'loopN命令の範囲を制限（テスト用のみ）'
# 'Restrict remat for statepoint operands'
H915A155B8538: 'statepointオペランドのrematを制限'
# 'Restrict sanitizer coverage instrumentation exclusively to modules and functions that match the provided special case list, except the blocked ones'
HF665154F84D1: '指定された特別なケースリストに一致するモジュールと関数のみにsanitizer coverage instrumentationを限定し、ブロックされたものは除く'
# 'Restrict specifier.'
H0429709567D5: 'specifierを制限'
# 'Resume compilation after a specific pass'
H0C491338806A: '特定のパスの後にコンパイルを再開'
# 'Resume compilation before a specific pass'
H1BE82678A264: '特定のパスの前にコンパイルを再開'
# 'Retain macro definitions in /E mode'
HED02F9B02911: '/Eモードでマクロ定義を保持'
# 'Return all structs in memory (PPC32 only)'
H1FA38C42BEE4: 'メモリ上ですべての構造体を返却（PPC32のみ）'
# 'Return small structs in registers (PPC32 only)'
H2418E605C08F: 'レジスタで小さな構造体を返却（PPC32のみ）'
# 'Reverse allocation order of local live ranges, such that shorter local live ranges will tend to be allocated first'
HB6873693AAD6: 'ローカルライブレンジの割り当て順序を逆転し、より短いローカルライブレンジが先に割り当てられるようにする'
# 'Rewrite Legacy Objective-C source to C++'
H756144AF61D7: '従来のObjective-CソースをC++に書き換え'
# 'Rewrite Objective-C source to C++'
H97D2AC714B44: 'Objective-CソースをC++に書き換え'
# 'Rewrite Partial Register Uses'
HCE6FCECEDA90: '部分的なレジスタ使用を書き換え'
# 'Rewrite unaligned loads as a pair of aligned loads'
HB7B2CD3A9808: 'アラインメントされていない読み出しを2つのアラインメントされた読み出しに書き換え'
# 'Rewrite undef for PHI'
HD99A47BCF5A8: 'PHIノードの undef を書き換え'
# 'Rewriter playground'
HE6E28450C65C: 'リライタープレイグラウンド'
# 'Rewriter to run'
HD27186628DE0: '実行するリライター'
# 'Right before the vectorizer'
HE1F20E3A6191: 'ベクタライザ直前の段階'
# 'Root for relative input paths'
H44AB7F76C38B: '相対入力パスのルートディレクトリ'
# 'Root.'
H81747C7D336A: 'ルートディレクトリ'
# "Roughly estimate the number of cycles that 'long latency' instructions take for targets with no itinerary"
HEEDD34050A74: "スケジューリング情報を持たないターゲット向けに'long latency'命令の遅延サイクル数を概算"
# 'Round section sizes up to the section alignment'
HE0CCC8143863: 'セクションアラインメントに合わせてセクションサイズを切り上げ'
# 'Round-trip the IR after parsing and ensure it succeeds'
HB85D02D3E83D: 'パース後のIRを再出力し、成功を確認'
# 'Run GCN iterative scheduler for ILP scheduling (experimental)'
H1C7DB026D127: 'ILPスケジューリング用にGCN反復スケジューラを実行（実験的）'
# 'Run GCN iterative scheduler for minimal register usage (experimental)'
HEE1CE35E76A1: 'レジスタ使用量最小化用にGCN反復スケジューラを実行（実験的）'
# 'Run GCN scheduler to maximize ilp'
HFF1542675A34: 'ILP最大化のためにGCNスケジューラを実行'
# 'Run GCN scheduler to maximize memory clause'
H7E5277DF8B56: 'メモリ句最大化のためにGCNスケジューラを実行'
# 'Run GCN scheduler to maximize occupancy'
H55CABD9DC534: '占有率最大化のためにGCNスケジューラを実行'
# 'Run GCN scheduler to maximize occupancy (experimental)'
H2546364E49BB: '占有率最大化用にGCNスケジューラを実行（実験的）'
# "Run Hexagon's custom scheduler"
HD930CA19D3B9: 'Hexagon用カスタムスケジューラを実行'
# 'Run MachineScheduler post regalloc (independent of preRA sched)'
H2FBC06B95112: 'レジスタ割り当て後（post regalloc）にマシンスケジューラを実行（preRA schedとは独立）'
# 'Run PGO context sensitive IR instrumentation'
HF2D51A482F76: 'PGO コンテキスト センシティブなIRインストルメンテーションを実行'
# 'Run Partial inlining pass'
H67505263F683: '部分インライン化パスを実行'
# 'Run PowerPC PostRA specific scheduler'
H78B21F1324B5: 'PostRA後のPowerPC用特定スケジューラを実行'
# 'Run PowerPC PreRA specific scheduler'
H394DF3D974FB: 'PreRA前のPowerPC用特定スケジューラを実行'
# "Run R600's custom scheduler"
H72CC1BA879B5: 'R600のカスタムスケジューラを実行'
# "Run SI's custom scheduler"
HD076B4B4194B: 'SIのカスタムスケジューラを実行'
# 'Run SimplifyCFG after expanding atomic operations to make use of cmpxchg flow-based information'
H0C90ACC17582: 'cmpxchgフローに基づく情報を利用するため、原子操作展開後のSimplifyCFGを実行'
# 'Run a global pre-inliner to merge context profile based on estimated global top-down inline decisions'
H5BFD65B47642: '推定グローバルトップダウンインライン決定に基づくコンテキストプロファイルを統合するためのグローバルプリインライン化を実行'
# 'Run a quick verification useful for regression testing'
H47645E615F6C: '回帰テスト用の簡易検証を実行'
# 'Run all passes twice, re-using the same pass manager (legacy PM only).'
HD061B5F25379: '同じパスマネージャ（レガシPMのみ）を再利用して全パスを2回実行'
# 'Run amdgpu-regbankselect and amdgpu-regbanklegalize instead of regbankselect'
H5E9AEFE2CEF6: 'regbankselectの代わりにamdgpu-regbankselectとamdgpu-regbanklegalizeを実行'
# 'Run an early inliner pass before Polly'
H54AEF889D7EF: 'Polly前に早期インライン化パスを実行'
# 'Run analysis on specific function (for C++ include parameters in name)'
H3C6F4C08F518: '特定の関数に対する分析実行（C++インクルードパラメータを名前に含む）'
# 'Run asan instrumentation on LDS instructions lowered to global memory'
H9EB47AECF813: 'グローバルメモリに変換されたLDS命令に対してasanインストルメンテーションを実行'
# 'Run cc1 in-process'
H9A5B5F4BB70B: 'cc1をプロセス内実行'
# 'Run cleanup optimization passes after vectorization'
HD6645D1D40DA: 'ベクタライゼーション後のクリーンアップ最適化パスを実行'
# 'Run code-completion at each point (slow)'
HF356338EEEA8: '各ポイントでコード補完を実行（遅い）'
# 'Run compiler only for specified passes (comma separated list)'
H08D41AC776F1: '指定されたパスのみを実行（カンマ区切りのリスト）'
# 'Run early if-conversion'
H7D7CDDBB010E: '早期if-conversionを実行'
# 'Run everything twice, re-using the same pass manager and verify the result is the same.'
H7032E14A02BE: '同じパスマネージャを再利用して全処理を2回実行し、結果が一致することを確認'
# 'Run in quiet mode'
HE4D4F6750673: 'クイートモードで実行します'
# 'Run indirect-call promotion for call instructions only'
H8967C75A35F7: '呼び出し命令のみに対して間接呼び出し促進を実行します'
# 'Run indirect-call promotion for invoke instruction only'
H4BE6E5960D01: 'インボイク命令のみに対して間接呼び出し促進を実行します'
# 'Run indirect-call promotion in LTO mode'
HD86948C0B3ED: 'LTOモードで間接呼び出し促進を実行します'
# 'Run indirect-call promotion in SamplePGO mode'
HFD50D337E7CB: 'SamplePGOモードで間接呼び出し促進を実行します'
# 'Run instrumented parse and dump the parsing log'
HB71F9FFCCF1A: 'インストルメンテーションされた解析を実行し、パースログをダンプします'
# 'Run live interval analysis earlier in the pipeline'
H35280A9E9FE7: 'ライブインターバル解析をパイプラインの早い段階で実行します'
# 'Run loop-rotation in the prepare-for-lto stage. This option should be used for testing only.'
HF3A983596CA9: 'ループ回転をprepare-for-lto段階で実行します。このオプションはテスト用にのみ使用してください。'
# 'Run many different optimization sequences on program to find bugs'
H612ED68363A4: '多くの異なる最適化シーケンスを実行してバグを検出します'
# 'Run on all functions guaranteed to be beneficial'
HE1FEAE7130C4: '有益であることが保証されたすべての関数に対して実行します'
# 'Run only CodeGen passes and translate FIR to LLVM IR'
H1A5B7B8CBB9C: 'CodeGen パスのみを実行し、FIRをLLVM IRに変換します'
# 'Run opt passes and codegen at O0'
H81E08FD2A09C: 'O0でoptパスとコード生成を実行します'
# 'Run opt passes and codegen at O1'
H474C4A7BA297: 'O1でoptパスとコード生成を実行します'
# 'Run opt passes and codegen at O2'
H3F347B539B5D: 'O2でoptパスとコード生成を実行します'
# 'Run opt passes and codegen at O3'
H59E1D82AC2DB: 'O3でoptパスとコード生成を実行します'
# 'Run optimizations through valgrind'
HE1CE530E789B: 'valgrindを通じて最適化を実行します'
# 'Run pre-RA exec mask optimizations'
H3C26C74A3208: 'RA前の実行マスク最適化を実行します'
# 'Run pre-emit peephole optimizations.'
H4E182C271921: '発行前のポホール最適化を実行します。'
# 'Run preprocessor, dump internal rep of tokens'
H45922516F2A2: 'プリプロセッサを実行し、トークンの内部表現をダンプします'
# 'Run program Just-In-Time'
H7E1CCE7CE553: 'Just-In-Timeでプログラムを実行します'
# 'Run static analysis engine'
H84EF43F50B25: '静的解析エンジンを実行します'
# 'Run the Fast mode (default mapping)'
HFFDBC5733152: '高速モード（デフォルトのマッピング）を実行します'
# 'Run the InputOuputTest action. Use for development and testing only.'
H0B55FCB86E0F: 'InputOuputTest アクションを実行します。開発とテストのみに使用してください'
# 'Run the LLVM verifier after every LLVM pass'
H136DF2CC2C10: '各LLVM パスの後にLLVM検証器を実行します'
# 'Run the Loop vectorization passes'
H593612B18031: 'ループベクトル化のパスを実行します'
# 'Run the NewGVN pass'
HB971140FD767: 'NewGVN パスを実行します'
# 'Run the SLP vectorization passes'
H568F60BAF50F: 'SLPベクトル化のパスを実行します'
# 'Run the dead code elimination'
H072ED3EF8554: '死コード除去を実行します'
# 'Run the loop rotation transformation after PGO instrumentation'
H99F728F7A8D4: 'PGOインストルメンテーションの後にループ回転変換を実行します'
# 'Run the pipeline stored in the reproducer'
HE376D46CB8F5: 'reproducerに保存されているパイプラインを実行します'
# 'Run the preprocessor, parser and semantic analysis stages'
HC4E9B82FB80F: 'プリプロセッサ、パーサー、およびセマンティック解析の各ステージを実行します'
# 'Run the static analyzer'
H12842C536C2E: '静的解析ツールを実行します'
# "Run the vectorizer only on file paths that match any in the list of comma-separated regex's."
H4461671734B6: 'コンマ区切りの正規表現リストのいずれかに一致するファイルパスのみに対してベクター化を実行します'
# 'Run the verifier after each transformation pass'
H1D9EDA842E47: '各変換パスの後に検証器を実行します'
# 'Runs certain features (e.g. hover) at each point in the file. Somewhat slow.'
H5799AB4D2B8E: 'ファイルの各ポイントで特定の機能（例：ホバー）を実行します。やや遅い場合があります'
# 'Runtime determined (OMP_SCHEDULE)'
H89C96D1C59A0: '実行時決定（OMP_SCHEDULE）'
# 'RuntimeDyld'
HB046756B987A: 'RuntimeDyld'
# 'Rvalue reference.'
H1006B6835AD7: 'Rvalue参照。'
# 'SCE targets (e.g. PS4)'
H24C3BD16186C: 'SCEターゲット（例：PS4）'
# "SDK does not contain 'libarclite' at the path '%0'; try increasing the minimum deployment target"
HBB626BB3124D: "SDKパス '%0' に'libarclite'が含まれていません。最小デプロイメントターゲットを増やしてください"
# "SDK settings were ignored as 'SDKSettings.json' could not be parsed"
HF609237E0BEB: "SDK設定は、'SDKSettings.json' を解析できなかったため無視されました"
# "SEH '__try' is not supported on this target"
H06D89FCA39AA: "SEH '__try' はこのターゲットではサポートされていません"
# 'SI Fix SGPR copies'
HDB9A9026CAAF: 'SI SGPRコピーの修正'
# 'SI Fix VGPR copies'
H0BCE6618F46C: 'SI VGPRコピーの修正'
# 'SI Fold Operands'
H2A817B2075A4: 'SI オペランドの折り畳み'
# 'SI Form memory clauses'
H4B75CB116FD5: 'SI メモリ句の形成'
# 'SI Insert Hard Clauses'
H0DD59BBBCDBF: 'SI ハード句の挿入'
# 'SI Insert Waitcnts'
HE04885DD4D00: 'SI Waitcntの挿入'
# 'SI Load Store Optimizer'
H267BF961C532: 'SI ロード/ストア最適化'
# 'SI Lower WWM Copies'
HEE5F5720909B: 'SI WWMコピーの展開'
# 'SI Lower i1 Copies'
H5A7C0C9EA184: 'SI i1コピーの展開'
# 'SI Memory Legalizer'
H0FE7146D147C: 'SI メモリの合法化'
# 'SI Optimize VGPR LiveRange'
H8E8730AB73D6: 'SI VGPRの生存範囲最適化'
# 'SI Peephole SDWA'
H2175B3F2C8E1: 'SI SDWAの小さな窓最適化'
# 'SI Pre-allocate WWM Registers'
H4206E704E134: 'SI WWMレジスタの事前確保'
# 'SI Shrink Instructions'
HBAF7A342AB3A: 'SI インストラクションの縮小'
# 'SI Whole Quad Mode'
HFFEC46D8FF13: 'SI クォード全体モード'
# 'SI insert s_cbranch_execz instructions'
HDC4FDC149030: 'SI s_cbranch_execz命令の挿入'
# 'SI lower SGPR spill instructions'
H3F5058866166: 'SI SGPRスpill命令の展開'
# 'SI lower control flow'
H9237847AA8B8: 'SI コントロールフローの展開'
# 'SI optimize exec mask operations'
H3185D5441AB0: 'SI execマスク操作の最適化'
# 'SI optimize exec mask operations pre-RA'
H08D9A111CF96: 'SI pre-RAでのexecマスク操作の最適化'
# 'SI peephole optimizations'
H1E6ED6F3445E: 'SI ピーホール最適化'
# 'SI post-RA bundler'
H6FF7F01FEB53: 'SI post-RAバンドラー'
# 'SIMD Library for Evaluating Elementary Functions'
H4F65620685F5: '基本関数の評価用SIMDライブラリ'
# 'SME Peephole Optimization'
HB6505176089D: 'SMEピーホール最適化'
# 'SOURCEFILE'
H4695CE0F3CCA: 'SOURCEFILE'
# 'SPARC DAG->DAG Pattern Instruction Selection'
HEB1F489D0073: 'SPARC DAG→DAGパターン命令選択'
# 'SPIR-V Regularizer'
HA3F8831A4FED: 'SPIR-V正規化'
# 'SPIR-V Shader capability'
H3F602E05A4A8: 'SPIR-Vシェーダ機能'
# 'SPIR-V Translator compatibility mode'
HF7AF8DE76675: 'SPIR-Vトランスレータ互換性モード'
# 'SPIR-V capabilities to avoid if there are other options enabling a feature'
H9E1D87EB2349: '他のオプションで機能を有効にしている場合に回避すべきSPIR-V機能'
# 'SPIRV NonSemantic.Shader.DebugInfo.100 emitter'
H16A3D5391B31: 'SPIRV NonSemantic.Shader.DebugInfo.100 エミッター'
# 'SPIRV convergence regions analysis'
HB13555632C11: 'SPIRV収束領域分析'
# 'SPIRV emit intrinsics'
H98E5DCAE36C2: 'SPIRV _INTRINSICの発行'
# 'SPIRV legalize bitcast pass'
H9940486F0CC0: 'SPIRV bitcast合法化パス'
# 'SPIRV module analysis'
HD4BE1FB1BEF1: 'SPIRVモジュール分析'
# 'SPIRV post legalizer'
HF7EB3FED68B9: 'SPIRV ポスト合法化'
# 'SPIRV pre legalizer'
HD74E28A77753: 'SPIRV プリ合法化'
# 'SPIRV prepare functions'
H17164FF97DDE: 'SPIRV 関数準備'
# 'SPIRV split region exit blocks'
H2A782FAE48E8: 'SPIRV 領域出口ブロックの分割'
# 'SPIRV strip convergent intrinsics'
HDA93080C3642: 'SPIRV 統一型イントリンシックの削除'
# 'STOKE pass options'
H4008C64D6703: 'STOKE パスオプション'
# "SUBCOMMAND '"
H49B0CF838F29: "サブコマンド '"
# 'SUBCOMMANDS:\n\n'
H5B04A2FD12F5: 'サブコマンド:\n\n'
# 'SVE vector type %0 cannot be used in a non-streaming function'
H9A5DD8A133CA: 'SVE ベクタータイプ %0 はストリーミングでない関数では使用できません'
# 'SVE vector type %0 cannot be used in a target without sve'
H9A595E01748A: 'SVE ベクタータイプ %0 はSVE非対応ターゲットでは使用できません'
# 'SYCL host compilation'
H61E19C960525: 'SYCL ホストコンパイル'
# 'SYCL language standard to compile for.'
HD9004BF51D18: 'SYCL 言語規格のコンパイル対象。'
# 'Safe Stack instrumentation pass'
H90200C1EBE5D: 'Safe Stack インストルメンテーション パス'
# 'Safepoint IR Verifier'
H55862F19A9A2: 'Safepoint IR バリデータ'
# 'Salvage stale MemProf profile'
H99E23DAB6376: '古いMemProfプロファイルを回収'
# 'Salvage stale profile by fuzzy matching and use the remapped location for sample profile query.'
H5090826C05A6: '曖昧一致により古いプロファイルを回収し、サンプルプロファイル照会に再マッピングされた場所を使用します'
# 'Salvage unused profile by matching with new functions on call graph.'
H21FAAE36AF70: 'コールグラフ上で新しい関数と一致させることで未使用プロファイルを回収'
# 'Same as "/diasdkdir <dir>/DIA SDK" /vctoolsdir <dir>/VC/Tools/MSVC/<vctoolsversion> "/winsdkdir <dir>/Windows Kits/10"'
HEB5E99FA660E: '"/diasdkdir <dir>/DIA SDK" /vctoolsdir <dir>/VC/Tools/MSVC/<vctoolsversion> "/winsdkdir <dir>/Windows Kits/10" と同じ動作'
# 'Same as /Ob2'
H8A3F940C0EB5: '/Ob2と同じ'
# 'Same as prepare-and-assemble-snippet, but also creates the full sequence that can be dumped to a file using --dump-object-to-disk'
H77B67B5A93B5: 'prepare-and-assemble-snippetと同じ動作だが、--dump-object-to-diskを使用してファイルにダンプ可能な完全なシーケンスを作成します'
# 'Same as prepare-measured-code, but also runs the measurement (default)'
H1BADD228E79D: 'prepare-measured-codeと同じ動作だが、計測を実行します（既定値）'
# 'Same as prepare-snippet, but also dumps an excerpt of the sequence (hex encoded)'
H329F8CE6355E: 'prepare-snippetと同じ動作だが、シーケンスの抜粋（16進符号化）をダンプします'
# 'Same priority as other clangd work.'
H91A607AFE9B7: '他のclangd作業と同じ優先度'
# 'Sample profile'
H06DF786C2443: 'サンプル プロファイル'
# 'Sanitize loads from memory.'
H0BDA70010B81: 'メモリからの読み取りを検証する'
# 'Sanitize loads from memory. When disable, no significant security is provided.'
H6827B410126B: 'メモリからの読み取りを検証する。無効にした場合、重要なセキュリティ機能は提供されません'
# 'Sanitizer Coverage. 0: none, 1: entry block, 2: all blocks, 3: all blocks and critical edges'
H6153504BE2F9: 'Sanitizer カバレッジ。0: なし、1: エントリ ブロック、2: 全てのブロック、3: 全てのブロックとクリティカル エッジ'
# 'Sanitizer Statistics Processing Tool'
H8F91AACBD96D: 'Sanitizer 統計処理ツール'
# 'Sanitizer coverage type'
HB92F228F8C30: 'Sanitizer カバレッジ タイプ'
# 'Save ThinLTO generated object files using filenames created in the given directory.'
HC53E73C90B26: '指定されたディレクトリで作成されたファイル名を使用して、ThinLTO が生成したオブジェクト ファイルを保存します'
# 'Save ThinLTO temp files using filenames created by adding suffixes to the given file path prefix.'
H2E31524DF75E: '指定されたファイル パス プレフィックスに接尾辞を追加することによって作成されたファイル名を使用して、ThinLTO の一時ファイルを保存します'
# 'Save arguments passed by registers to ABI-defined stack positions'
H9D88220945B3: 'ABIで定義されたスタック位置にレジスタで渡された引数を保存する'
# "Save intermediate compilation results. <arg> can be set to 'cwd' for current working directory, or 'obj' which will save temporary files in the same directory as the final output file"
H353A183FAD67: '中間コンパイル結果を保存します。<arg> は「cwd」（現在の作業ディレクトリ）または「obj」（最終出力ファイルと同じディレクトリに一時ファイルを保存）を指定できます'
# 'Save intermediate module file results when compiling a standard C++ module unit.'
HC4664B3AE862: '標準 C++ モジュール単位をコンパイルする際に、中間モジュール ファイルの結果を保存します'
# 'Save llvm statistics.'
H5CC2FF1F8C02: 'LLVM 統計を保存'
# 'Save selected temporary files. Cannot be specified together with -save-temps'
H9B274443882B: '選択された一時ファイルを保存します。-save-temps と同時に指定できません'
# 'Save statistics to the specified file'
H869C572478B5: '指定されたファイルに統計を保存'
# 'Save subprocess statistics to the given file'
HBB6AB7F311A5: '指定されたファイルにサブプロセスの統計を保存'
# 'Save temp files'
H4A37FEDB9D14: '一時ファイルを保存'
# 'Save temporary files'
H57B3E4133626: '一時ファイルを保存'
# "Save temporary labels in the symbol table. Note this may change .s semantics and shouldn't generally be used on compiler-generated code."
H93DB00E1BEA2: 'シンボル テーブルに一時ラベルを保存します。この機能は .s のセマンティクスを変更する可能性があり、コンパイラ生成コードには一般的に使用しないでください'
# 'Save the IR before running optimizations'
H4A2342002AC8: '最適化実行前の IR を保存'
# 'Save the device memory output of the replayed kernel execution.'
H6C85C6C553C1: '再生されたカーネル実行のデバイス メモリ出力を保存します'
# 'Scalable vectorization is available and favored when the cost is inconclusive.'
H66BDF3C7947B: 'スケーラブルなベクタライゼーションは、コストが明確でない場合に利用可能で優先されます。'
# 'Scalable vectorization is disabled.'
HEDA81875966D: 'スケーラブルなベクタライゼーションは無効になっています。'
# 'Scalar Evolution Analysis'
H8691C6809389: 'スカラーエボリューション分析'
# 'Scalar Replacement Of Aggregates'
HC922609C7C15: '集合体のスカラーリプレースメント'
# 'Scalar independence heuristic'
H6DBF46490571: 'スカラーアイデペンデンスのヒューリスティック'
# 'ScalarEvolution-based Alias Analysis'
HB1C967D70FE5: 'スカラーエボリューションに基づくエイリアス分析'
# 'Scalarize unsupported masked memory intrinsics'
H4C20D577FF69: 'サポートされていないマスクされたメモリ内蔵関数をスカラー化する'
# 'Scalarize vector operations'
H31C547703795: 'ベクター操作をスカラー化'
# 'Scale the memop size counts using the basic  block count value'
H77E1E3932329: '基本ブロックカウント値を使用してメモプ サイズのカウントをスケーリングする'
# 'Scale to limit the cost of inline deferral'
HEB04CD55185A: 'インライン延期のコストを制限するためのスケーリング'
# 'Scavenge virtual registers inside basic blocks'
HDFF735ACD536: '基本ブロック内の仮想レジスタを回収'
# 'Schedule VSX FMA instruction mutation early'
HCC0329BA7D34: 'VSX FMA命令の変異を早期にスケジューリング'
# 'Schedule bottom-up for max ILP'
HD1699FACAF31: '最大ILPを目的としたボトムアップスケジューリング'
# 'Schedule bottom-up for min ILP'
H10AC8BD5ECDA: '最小ILPを目的としたボトムアップスケジューリング'
# 'Scheduling type of parallel OpenMP for loops'
H999BCCD4C603: '並列OpenMP forループのスケジューリングタイプ'
# 'Scope contributions to the debug information.'
H9BF0B0DDBE12: 'デバッグ情報へのスコープの貢献'
# 'Scope kind to use when printing scopes.'
H494C78291AB2: 'スコープを印刷する際のスコープ種別'
# 'Scope of graph to export to dot'
H9536D6B1D873: 'dot形式にエクスポートするグラフのスコープ'
# 'Scoped NoAlias Alias Analysis'
HB6BD5D72C4B3: 'Scoped NoAliasエイリアス分析'
# 'Scopes.'
H4E6EE0359B5C: 'スコープ。'
# 'Search $prefix$file for executables, libraries, and data files. If $prefix is a directory, search $prefix/$file'
H6DC87438E4A7: '実行可能ファイル、ライブラリ、およびデータファイルを検索します。$prefixがディレクトリの場合、$prefix/$fileを検索します'
# 'Search elements matching the given pattern.'
H98914CD94E9A: '指定されたパターンに一致する要素を検索します'
# 'Search even non-imported modules to resolve references'
H1FD982ACF76B: '参照を解決するために、非インポートモジュールも検索します'
# 'Search for the GCC installation with the specified triple.'
H74F06477D6B9: '指定されたtripleを持つGCCのインストールを探します'
# 'Section-specific Dump Options'
H9E36553E678B: 'セクション固有のダンプオプション'
# 'Seed for the random number generator'
H9C3EECBF2BE5: '乱数生成器のシード値'
# 'Seed used for randomness'
H228A43C8FFBC: 'ランダム性に使用されるシード'
# 'Select DPP or Iterative strategy for scan'
HE53499864EE5: 'スキャン用のDPPまたは反復戦略を選択'
# 'Select Options'
HD84BE9DE2F9E: 'オプションを選択'
# 'Select Windows run-time library'
HAC106D381AC2: 'Windowsランタイムライブラリを選択'
# 'Select custom AMDGPU scheduling strategy.'
H64E4378BB72D: 'AMDGPUスケジューリングストラテジーをカスタムで選択'
# 'Select label scheme for branch control-flow architecture protection'
H7B3CA40CA6B3: 'ブランチ制御フロー構造保護のためのラベル方式を選択'
# "Select math operations' runtime behavior:"
HBD0952A00DD6: '数学演算のランタイム動作を選択:'
# 'Select return address signing scope'
H4F99B374ECF5: '戻りアドレス署名範囲を選択'
# 'Select straight-line speculation hardening scope (ARM/AArch64/X86 only). <arg> must be: all, none, retbr(ARM/AArch64), blr(ARM/AArch64), comdat(ARM/AArch64), nocomdat(ARM/AArch64), return(X86), indirect-jmp(X86)'
H7FE74692FDC9: 'ストレートライン推測強化範囲を選択（ARM/AArch64/X86のみ）。<arg>は次のいずれかでなければなりません：all, none, retbr(ARM/AArch64), blr(ARM/AArch64), comdat(ARM/AArch64), nocomdat(ARM/AArch64), return(X86), indirect-jmp(X86)'
# 'Select target instructions out of generic instructions'
H687BF304766B: '汎用命令からターゲット命令を選択'
# 'Select the HWAddressSanitizer ABI to target (interceptor or platform, default interceptor). This option is currently unused.'
H2E53C4CE5E14: 'ターゲットとするHWAddressSanitizer ABIを選択（interceptorまたはplatform、デフォルトはinterceptor）。このオプションは現在未使用です'
# "Select the SIMD extension(s) to be enabled in LoongArch either 'none', 'lsx', 'lasx'."
H58773894FD9F: "LoongArchで有効にするSIMD拡張を次のいずれかで選択：'none', 'lsx', 'lasx'"
# 'Select the asm variant (integer) to use for output (3: unspecified)'
H269BE00B3354: '出力に使用するasmバリアント（整数）を選択（3: 未指定）'
# 'Select the assembly style for input'
HC379BD26B358: '入力用のアセンブリスタイルを選択'
# "Select the container format for clang modules and PCH. Supported options are 'raw' and 'obj'."
H35A81EACF6D7: "clang モジュールとPCH用のコンテナ形式を選択します。サポートされているオプションは'raw'と'obj'です。"
# 'Select the frame chain model used to emit frame records (Arm only).'
H6E15DFB39F91: 'フレームレコードを出力するために使用するフレームチェーンモデルを選択します（Armのみ）。'
# 'Select the kind of output desired'
H4B7026DCAB45: '必要に応じた出力の種類を選択します。'
# 'Select the mode of detecting stack use-after-return in AddressSanitizer'
H18AC10CFE63E: 'AddressSanitizerでスタックのuse-after-returnを検出するモードを選択します。'
# 'Select the scheduling optimizer'
HF3643F4F750F: 'スケジューリングオプティマイザを選択します。'
# 'Select the vectorization strategy'
HF0DE7753D578: 'ベクトル化戦略を選択します。'
# 'Select tutorial version'
HA1F9E472551C: 'チュートリアルのバージョンを選択します。'
# 'Select underlying type for wchar_t'
H871CFB3D3DBF: 'wchar_tのベース型を選択します。'
# "Select which XRay instrumentation points to emit. Options: all, none, function-entry, function-exit, function, custom. Default is 'all'.  'function' includes both 'function-entry' and 'function-exit'."
HF1CF9325D610: "XRayのインストルメンテーションポイントを出力する種類を選択します。オプション：all、none、function-entry、function-exit、function、custom。デフォルトは'all'です。 'function'は'function-entry'と'function-exit'の両方を含みます。"
# 'Select which denormal numbers the code is permitted to require'
H2AC882EF26F4: 'コードが要求することができる不正規数を選択します。'
# 'Select which denormal numbers the code is permitted to require for float'
HE697FDB681DE: 'floatに対する不正規数を選択します。'
# 'Selected elements are displayed in a tabular format.'
HEA919FEE4B68: '選択された要素はテーブル形式で表示されます。'
# 'Selected elements are displayed in a tree view (Include children)'
H177003785A78: '選択された要素はツリービューで表示されます（子要素を含む）'
# 'Selected elements are displayed in a tree view. (Include parents)'
HDF9A5F80B1E1: '選択された要素はツリービューで表示されます。（親要素を含む）'
# 'Selects the execution mode to use for running snippets'
HD1AD171EDC3B: 'スニペットを実行するために使用する実行モードを選択します。'
# 'Serialize compiler diagnostics to a file'
HDAE0DE265E80: 'コンパイラの診断情報をファイルにシリアル化します。'
# 'Set CPU for optimization without affecting instruction set'
H4812860590FE: '命令セットを変更せずに最適化用のCPUを設定します。'
# 'Set DWARF fission mode'
HA6B185D6C1A5: 'DWARF fissionモードを設定します。'
# 'Set EABI type (default depends on triple):'
HE8D11354B2F8: 'EABIの種類を設定します（デフォルトはトリプルに依存します）:'
# 'Set EABI type. Default depends on triple)'
H10E2EAF33A04: 'EABIの種類を設定します。デフォルトはトリプルに依存します)'
# 'Set Fuchsia API level'
H6549E92FCDF2: 'Fuchsia API レベルを設定します'
# 'Set Hexagon Vector Length'
H7AAC4AA29051: 'Hexagon ベクタ長を設定します'
# 'Set LTO mode'
HC407FF843F6C: 'LTO モードを設定します'
# 'Set LTO mode for offload compilation'
HAFC85CCA6F44: 'オフロードコンパイル用のLTOモードを設定します'
# 'Set OpenMP version (e.g. 45 for OpenMP 4.5, 51 for OpenMP 5.1). Default value is 11 for Flang'
HB4B241AD39C3: 'OpenMP バージョンを設定します（例: OpenMP 4.5には45、OpenMP 5.1には51）。デフォルト値はFlangの場合11です'
# 'Set OpenMP version (e.g. 45 for OpenMP 4.5, 51 for OpenMP 5.1). Default value is 51 for Clang'
H81EB65FB7662: 'OpenMP バージョンを設定します（例: OpenMP 4.5には45、OpenMP 5.1には51）。デフォルト値はClangの場合51です'
# 'Set ThinLTO cache entry expiration time.'
HAC92585FAE36: 'ThinLTOキャッシュエントリの有効期限を設定します'
# 'Set ThinLTO cache pruning directory maximum number of files.'
H5D4AE530977A: 'ThinLTOキャッシュのプルーニングディレクトリの最大ファイル数を設定します'
# 'Set ThinLTO cache pruning directory maximum size in bytes.'
H28BB199174A5: 'ThinLTOキャッシュのプルーニングディレクトリの最大サイズ（バイト単位）を設定します'
# 'Set ThinLTO cache pruning interval.'
H4990BDC788D5: 'ThinLTOキャッシュのプルーニング間隔を設定します'
# 'Set __cdecl as a default calling convention'
H0DA21BF93B54: '__cdeclをデフォルトの呼び出し規約として設定します'
# 'Set __fastcall as a default calling convention'
H407DDA0187F9: '__fastcallをデフォルトの呼び出し規約として設定します'
# 'Set __regcall as a default calling convention'
HBA376537ABE7: '__regcallをデフォルトの呼び出し規約として設定します'
# 'Set __regcall4 as a default calling convention to respect __regcall ABI v.4'
H58F2490637FE: '__regcall4をデフォルトの呼び出し規約として設定し、__regcall ABIバージョン4を尊重します'
# 'Set __stdcall as a default calling convention'
HE1D6B80E6229: '__stdcallをデフォルトの呼び出し規約として設定します'
# 'Set __vectorcall as a default calling convention'
H37C4705F7696: '__vectorcallをデフォルトの呼び出し規約として設定します'
# 'Set architecture for code generation'
HAC7DFD303E5D: 'コード生成用のアーキテクチャを設定します'
# 'Set assembly output file name (with /FA)'
H342E214704DE: 'アセンブリ出力ファイル名を設定します（/FAオプションを使用）'
# 'Set build target to arm64ec'
H05FB1FB7BA76: 'ビルドターゲットをarm64ecに設定します'
# 'Set default AMDHSA Code Object Version (module flag or asm directive still take priority if present)'
H146533C17448: 'デフォルトのAMDHSAコードオブジェクトバージョンを設定します（モジュールフラグまたはアセンブリディレクティブが存在する場合は優先されます）'
# "Set default MTE mode to 'sync' (default) or 'async'"
H20B84E4CC1C3: "デフォルトのMTEモードを'sync'(デフォルト)または'async'に設定します"
# 'Set default calling convention'
HDE29EF09B114: 'デフォルトのコール規約を設定'
# 'Set default maximum struct packing alignment'
HB9DF8419AE20: '構造体のパッキングアライメントの最大値を設定'
# 'Set default maximum struct packing alignment to 1'
H4F682E117F17: '構造体のパッキングアライメントの最大値を1に設定'
# 'Set directory to SYSTEM include search path with prefix'
H68EB156B894F: 'プレフィックス付きディレクトリをシステム用インクルード検索パスに設定'
# 'Set directory to include search path with prefix'
H949A45EF9093: 'プレフィックス付きディレクトリをインクルード検索パスに設定'
# 'Set endian conversion of data for unformatted files'
H5882EA320C88: '非フォーマットファイルのデータのエンディアン変換を設定'
# 'Set exception handling model'
HBE5ECEAC70BC: '例外処理モデルを設定'
# 'Set filename used to determine the language and to find\n.clang-format file.\nOnly used when reading from stdin.\nIf this is not passed, the .clang-format file is searched\nrelative to the current working directory when reading stdin.\nUnrecognized filenames are treated as C++.\nsupported:\n  CSharp: .cs\n  Java: .java\n  JavaScript: .js .mjs .cjs .ts\n  Json: .json\n  Objective-C: .m .mm\n  Proto: .proto .protodevel\n  TableGen: .td\n  TextProto: .txtpb .textpb .pb.txt .textproto .asciipb\n  Verilog: .sv .svh .v .vh'
H76F2B4A51C95: '標準入力から読み込む際に使用するファイル名を設定。\nこのオプションが指定されない場合、標準入力時は現在の作業ディレクトリ relatives で.clang-format ファイルを検索します。\n未認識のファイル名はC++として扱われます。\n対応ファイル形式:\n  CSharp: .cs\n  Java: .java\n  JavaScript: .js .mjs .cjs .ts\n  Json: .json\n  Objective-C: .m .mm\n  Proto: .proto .protodevel\n  TableGen: .td\n  TextProto: .txtpb .textpb .pb.txt .textproto .asciipb\n  Verilog: .sv .svh .v .vh'
# 'Set hexagon hvx loop upper bound align limit'
HE4A380690C61: 'hexagon hvxループの上側境界アライメントの制限値を設定'
# 'Set hexagon loop align bundle limit'
H16F9FCEB4FD8: 'hexagonループアライメントバンドルの制限値を設定'
# 'Set hexagon loop align edge threshold'
HB0E799C9958F: 'hexagonループアライメントのエッジしきい値を設定'
# 'Set hexagon loop lower bound align limit'
H191108F43D31: 'hexagonループの下側境界アライメントの制限値を設定'
# 'Set hexagon loop upper bound align limit'
HAC06445A5323: 'hexagonループの上側境界アライメントの制限値を設定'
# 'Set hexagon tiny-core loop align bundle limit'
HC2C9248FD7B4: 'hexagon tiny-coreループアライメントバンドルの制限値を設定'
# 'Set hexagon tiny-core loop upper bound align limit'
HB3D8449C583E: 'hexagon tiny-coreループの上側境界アライメントの制限値を設定'
# 'Set how to use window scheduling algorithm.'
H38DFCE09E411: '窓スケジューリングアルゴリズムの使用方法を設定'
# 'Set iOS deployment target'
HF07609B74103: 'iOSデプロイメントターゲットを設定'
# 'Set inclusive limit count of TLS local-dynamic access(es) in a function to use initial-exec'
H219EA990A3B9: '関数内でinitial-execを使用するために、TLS local-dynamicアクセスの包含的上限カウントを設定'
# 'Set language version (c++14,c++17,c++20,c++23preview,c++latest,c11,c17)'
H7E89784949AD: '言語バージョンを設定 (c++14,c++17,c++20,c++23preview,c++latest,c11,c17)'
# 'Set lazy loading to pretend to import a module'
H618CB094A526: '遅延読み込みをモジュールのインポートを装わせるように設定します'
# 'Set level of crash diagnostic reporting, (option: off, compiler, all)'
HCE18F9865CAD: 'クラッシュ診断の報告レベルを設定します（オプション: off, compiler, all）'
# 'Set macOS deployment target'
H19A10025F765: 'macOS のデプロイメント ターゲットを設定します'
# 'Set max number of processed functions per pass.'
HEC89F562858B: '各パスあたりの処理対象関数の最大数を設定します'
# 'Set maximum number of loads used in expanded memcmp'
HB5230B1550BF: '拡張された memcmp に使用される読み取り操作の最大数を設定します'
# 'Set maximum number of loads used in expanded memcmp for -Os/Oz'
H8B44477BDB6F: ' -Os/Oz オプションでの拡張された memcmp に使用される読み取り操作の最大数を設定します'
# 'Set maximum offset for global merge pass'
HC56716718D87: 'グローバル マージ パスの最大オフセットを設定します'
# 'Set maximum runtime in seconds. Defaults to infinite.'
HF2324CC71F76: '最大実行時間を秒単位で設定します。デフォルトは無限大です。'
# 'Set maximum size of jump tables.'
H8A331A3A6A26: 'ジャンプテーブルの最大サイズを設定します'
# 'Set minimum jump tables'
H5B26E9EE289B: '最小のジャンプテーブルを設定します'
# 'Set minimum mem intrinsic size to expand in IR'
H0E2DA83065C4: 'IR 内での展開対象メモリ固有関数の最小サイズを設定します'
# 'Set minimum number of entries to use a jump table on AArch64'
H5D2DDCBDE91E: 'AArch64 でジャンプテーブルを使用する最小のエントリ数を設定します'
# 'Set minimum number of entries to use a jump table on PPC'
H695C03675C01: 'PPC でジャンプテーブルを使用する最小のエントリ数を設定します'
# 'Set minimum number of entries to use a jump table on RISCV'
H747561D1A3EA: 'RISCV でジャンプテーブルを使用する最小のエントリ数を設定します'
# 'Set minimum number of entries to use a jump table.'
HB0CDB46F3718: 'ジャンプテーブルを使用する最小のエントリ数を設定します'
# "Set multiple /O flags at once; e.g. '/O2y-' for '/O2 /Oy-'"
HEBA0D85CE2CB: "複数の /O フラグを一度に設定します。例: '/O2y-' で '/O2 /Oy-' を指定"
# 'Set output executable file name'
H82C970101BA4: '出力実行可能ファイル名を設定します'
# 'Set output object file (with /c)'
HBAF5373A221F: 'オブジェクトファイルの出力先を設定します（/c オプションと併用）'
# 'Set page size for slab (requires -slab-allocate and -noexec)'
H674467BA0F71: 'スラブのページサイズを設定します（-slab-allocate および -noexec オプションが必要）'
# 'Set pch file name (with /Yc and /Yu)'
H0833DDB5ABF7: 'pch ファイル名を設定します（/Yc および /Yu オプションと併用）'
# 'Set preprocess output file name (with /P)'
H13AACC04AA24: 'プリプロセス出力ファイル名を設定（/P オプションを使用）'
# 'Set project title for the coverage report'
HBA2F951324E5: 'カバレッジ レポートのプロジェクトタイトルを設定'
# 'Set runtime encoding, supports only UTF-8'
HE66D162F5CCB: 'ランタイムエンコーディングを設定（UTF-8 のみ対応）'
# 'Set slab target address (requires -slab-allocate and -noexec)'
H20F55BE4E6F3: 'スラブターゲットアドレスを設定（-slab-allocate および -noexec が必要）'
# 'Set source and runtime encoding to UTF-8 (default)'
H652EEA8353CA: 'ソースおよびランタイムエンコーディングを UTF-8 に設定（既定値）'
# 'Set source encoding, supports only UTF-8'
H3F8729E6E52F: 'ソースエンコーディングを設定（UTF-8 のみ対応）'
# 'Set stack probe size (default 4096)'
HD0B9F95D20C7: 'スタックプローブサイズを設定（既定値 4096）'
# 'Set tab expansion size for html coverage reports (default = 2)'
H020BCDC65A3D: 'HTML カバレッジ レポートのタブ展開サイズを設定（既定値 2）'
# 'Set target profile'
H5E78CA7AD76D: 'ターゲットプロファイルを設定'
# 'Set the -iwithprefix/-iwithprefixbefore prefix'
HE253558596E6: '-iwithprefix/-iwithprefixbefore プレフィックスを設定'
# 'Set the Data Stream Control Register.'
H13FF9AB8D2D0: 'データストリーム制御レジスタを設定。'
# 'Set the case probability threshold for peeling the case from a switch statement. A value greater than 100 will void this optimization'
H4CFCB81E6294: 'switch 文から case を除去する確率閾値を設定。100 を超える値はこの最適化を無効にします'
# 'Set the count value cutoff. Functions with the maximum count less than this value will not be printed out. (Default is 0)'
H314CB3F4FF30: 'カウント値のカットオフ値を設定。最大カウントがこの値未満の関数は出力されません（既定値 0）'
# 'Set the default double precision kind to an 8 byte wide type'
H826E52CBA80A: 'デフォルトダブルプレシジョン種別を8 バイト幅の型に設定'
# 'Set the default integer and logical kind to an 8 byte wide type'
HBB03F45115A1: 'デフォルト整数および論理種別を8 バイト幅の型に設定'
# 'Set the default most-general representation to multiple inheritance'
H4BB3649A0500: 'デフォルトの最も一般的な表現を多重継承に設定'
# 'Set the default most-general representation to single inheritance'
HD5A0F69F41ED: 'デフォルトの最も一般的な表現を単一継承に設定'
# 'Set the default most-general representation to virtual inheritance'
H106974060665: 'デフォルトの最も一般的な表現をバーチャル継承に設定'
# 'Set the default real kind to an 8 byte wide type'
H7B0DABF8B0EB: 'デフォルトの実数種別を8 バイト幅の型に設定'
# 'Set the default structure layout to be compatible with the Microsoft compiler standard'
H10F147D00248: 'デフォルト構造体配置をMicrosoft コンパイラ基準と互換性のある形式に設定'
# 'Set the default symbol visibility for all global definitions'
HFCD98D3F8272: 'すべてのグローバル定義のデフォルトのシンボル可視性を設定します'
# 'Set the deployment target to be the specified OS and OS version'
H814D918A5F74: '展開ターゲットとして指定されたOSおよびOSバージョンを設定します'
# 'Set the device id.'
H4C967743D4CC: 'デバイスIDを設定します'
# "Set the driver mode to either 'gcc', 'g++', 'cpp', 'cl' or 'flang'"
HD0838A0BABB3: 'ドライバーモードを「gcc」、「g++」、「cpp」、「cl」、または「flang」のいずれかに設定します'
# 'Set the kind of module destructors emitted by AddressSanitizer instrumentation. These destructors are emitted to unregister instrumented global variables when code is unloaded (e.g. via `dlclose()`).'
H83083E1D2A16: 'AddressSanitizer instrumentationによって発行されるモジュールデストラクタの種類を設定します。これらのデストラクタは、コードがアンロードされる際に（例：`dlclose()`経由で）インストルメンテーションされたグローバル変数を解除登録するために発行されます。'
# 'Set the loop counter bitwidth'
H9F5F138BD1EC: 'ループカウンタのビット幅を設定します'
# 'Set the loop decrement value'
H5680DA5C48FB: 'ループデクリメント値を設定します'
# 'Set the lower bound of a trip count to decide on vectorization while tail-folding.'
H098C7B4E7AF1: 'tail-folding中にベクトル化を決定するためのループ回数の下限を設定します'
# 'Set the max unroll count for full unrolling, for testing purposes'
HF7A0139ED19B: 'テスト目的で完全アンロールの最大アンロールカウントを設定します'
# 'Set the max unroll count for partial and runtime unrolling, fortesting purposes'
H9B56B49168A1: 'テスト目的で部分的および実行時アンロールの最大アンロールカウントを設定します'
# 'Set the maximum bitwidth for _BitInt (this option is expected to be removed in the future)'
HA5D88B68C72D: '_BitIntの最大ビット幅を設定します（このオプションは将来削除される予定です）'
# 'Set the maximum depth of recursive constexpr function calls'
HBB90EC0111F9: 'constexpr関数の再帰呼び出しの最大深さを設定します'
# 'Set the maximum depth of recursive template instantiation'
H80FAEB4CB009: 'テンプレートインスタンティエーションの再帰的最大深さを設定します'
# 'Set the maximum number of clang-format errors to emit\nbefore stopping (0 = no limit).\nUsed only with --dry-run or -n'
HCC14B05C0F0B: 'clang-formatエラーの出力最大数を設定し、その数に達すると停止します（0 = 無制限）。--dry-runまたは-nオプションと併用する場合のみ有効'
# 'Set the maximum number of entries to print in a constexpr evaluation backtrace (0 = no limit)'
H894E58266D5D: 'constexpr評価のバックトレースに表示するエントリの最大数を設定します（0 = 無制限）'
# 'Set the maximum number of entries to print in a macro expansion backtrace (0 = no limit)'
H41EB48896694: 'マクロ展開のバックトレースに表示するエントリの最大数を設定します（0 = 無制限）'
# 'Set the maximum number of entries to print in a template instantiation backtrace (0 = no limit)'
H0B1001101AD7: 'テンプレートインスタンティエーションのバックトレースに表示するエントリの最大数を設定します（0 = 無制限）'
# 'Set the maximum number of errors to emit before stopping (0 = no limit).'
H4B9FB4A77BFC: 'エラーの出力最大数を設定し、その数に達すると停止します（0 = 無制限）'
# 'Set the maximum number of outgoing blocks for using a boolean value to record the exiting block in the ControlFlowHub.'
H72D58573A0FE: 'ControlFlowHubで退出ブロックを記録するためにブール値を使用する場合の出力ブロックの最大数を設定します'
# 'Set the maximum number of source lines to show in a caret diagnostic (0 = no limit).'
H501810E09B46: 'ケアット診断で表示するソース行の最大数を設定します（0 = 無制限）'
# 'Set the maximum number of steps in constexpr function evaluation'
H220ED2A089D9: 'constexpr関数評価におけるステップの最大数を設定します'
# 'Set the maximum number of times to perform spell checking on unrecognized identifiers (0 = no limit)'
HAFFC709D0C08: '未認識の識別子に対してスペルチェックを実行する最大回数を設定します（0 = 無制限）'
# 'Set the maximum path length when checking whether a basic block is followed by a block that either has a terminating deoptimizing call or is terminated with an unreachable'
H332DCFF60584: '基本ブロックが終端となる最適化解除コールを有するブロックかunreachableで終端されるブロックに続く場合の最大パス長を設定します'
# 'Set the minimum number of repetitions of a divisor to allow transformation to multiplications by the reciprocal'
HC1FEBC49F8C7: '逆数を用いた乗算への変換を許可する除数の繰り返し回数の最小値を設定します'
# 'Set the mode for address space map based mangling; OpenCL testing purposes only'
HD09BAE7AD91C: 'アドレス空間マップに基づくマングリングのモードを設定します（OpenCLテスト用のみ）'
# 'Set the number of scavenger slots'
H180660FD5B55: 'scavengerスロットの数を設定します'
# 'Set the number of teams.'
H7688CE2C3ADF: 'チームの数を設定します'
# 'Set the number of threads.'
H6EBBEB07E8B0: 'スレッドの数を設定します'
# 'Set the out-of-process executor'
HAF02B074B342: 'プロセス外のエグゼキューターを設定します'
# 'Set the output <file> for debug infos'
HA5E541919277: 'デバッグ情報の出力ファイル<file>を設定します'
# 'Set the p2align operands for WebAssembly loads and stores'
H7736F9C56939: 'WebAssemblyのロードとストアのp2alignオペランドを設定します'
# 'Set the parallelization strategy'
HF0A794612D46: '並列化戦略を設定します'
# "Set the profile instrumentation burst duration, which can range from 1 to the value of 'sampled-instr-period' (0 is invalid). This number of samples will be recorded for each 'sampled-instr-period' count update. Setting to 1 enables simple sampling, in which case it is recommended to set 'sampled-instr-period' to a prime number."
H5CA10C80C24A: "'sampled-instr-period'の値から1までの範囲でプロファイルインストルメンテーションのバースト期間を設定します（0は無効）。各'sampled-instr-period'カウント更新ごとにこの数のサンプルを記録します。1に設定すると単純サンプリングが有効になり、その際'sampled-instr-period'を素数に設定することを推奨します"
# "Set the profile instrumentation sample period. A sample period of 0 is invalid. For each sample period, a fixed number of consecutive samples will be recorded. The number is controlled by 'sampled-instr-burst-duration' flag. The default sample period of 65536 is optimized for generating efficient code that leverages unsigned short integer wrapping in overflow, but this is disabled under simple sampling (burst duration = 1)."
HC029DE20A3E1: "プロファイルインストルメンテーションのサンプル期間を設定します。サンプル期間0は無効です。各サンプル期間ごとに一定数の連続したサンプルが記録され、その数は'sampled-instr-burst-duration'フラグで制御されます。デフォルトのサンプル期間65536はunsigned shortのオーバーフローで巻き戻しを利用した効率的なコード生成を最適化していますが、単純サンプリング（burst期間=1）では無効です"
# "Set the rsp quoting to either 'posix', or 'windows'"
HFF7A11383873: "'posix'または'windows'のいずれかでrspクオートを設定します"
# 'Set the stack alignment'
HAAE3F7EC9ADE: 'スタックアラインメントを設定します'
# 'Set the stack probe size'
H188751A74B18: 'スタックプローブサイズを設定します'
# 'Set the system root directory (usually /)'
H9329C47A6507: 'システムルートディレクトリ（通常は/）を設定します'
# 'Set the tab stop distance.'
HC9DBC229821F: 'タブストップ距離を設定します'
# 'Set the target triple'
H886553395ADD: 'ターゲットトリプルを設定します'
# 'Set the threshold for pgo-verify-bfi:  only print out mismatched BFI if the difference percentage is greater than this value (in percentage).'
H467C6DAEB903: 'pgo-verify-bfiの閾値を設定：この値（パーセンテージ）を超える差分率がある場合にのみ、不整合なBFIを出力します。'
# 'Set the threshold for pgo-verify-bfi: skip the counts whose profile count value is below.'
HCF37C352FCE6: 'pgo-verify-bfiの閾値を設定：プロファイルカウント値がこれより下回るカウントをスキップします。'
# 'Set the unroll peeling count, for testing purposes'
H00413175E081: 'アンロールピーリングカウントを設定（テスト目的用）'
# 'Set the z/OS release of the runtime environment'
HD212DAE31048: 'ランタイム環境のz/OSリリースバージョンを設定'
# 'Set up preprocessor for static analyzer (done automatically when static analyzer is run).'
HE7E0E6B1AE87: '静的アナライザ用のプリプロセッサを設定（静的アナライザを実行時に自動で行われます）'
# 'Set update method of profile counters'
HA14B65C6D0B2: 'プロファイルカウンタの更新方法を設定'
# 'Set upper limit for the number of transformations performed during a single round of hoisting the reassociated expressions.'
HC739332F82AA: 'reassociated expressionsの持ち上げ処理中に1回のループで実行される変換の最大数を設定'
# 'Set wave priority'
HBB7FE34C07C2: 'ウェーブの優先度を設定'
# 'Set width of the columns showing resource booking.'
HC849BD248519: 'リソース予約を表示する列の幅を設定'
# 'Set width of the columns with the resources and schedule units'
H67C4E5790866: 'リソースとスケジュール単位を含む列の幅を設定'
# 'Sets the ASan constructor kind'
H7243B87BA43D: 'ASanコンストラクタの種類を設定'
# 'Sets the ASan destructor kind. The default is to use the value provided to the pass constructor'
H3151987CC244: 'ASanデストラクタの種類を設定。デフォルトはpassコンストラクタに提供された値を使用します。'
# 'Sets the IEEE bit in the expected default floating point  mode register. Floating point opcodes that support exception flag gathering quiet and propagate signaling NaN inputs per IEEE 754-2008. This option changes the ABI. (AMDGPU only)'
H40BE9F55402A: '期待されるデフォルト浮動小数点モードレジスタのIEEEビットを設定。IEEE 754-2008準拠の例外フラグ収集とシグナルNaN入力の伝播をサポートする浮動小数点オペコード。このオプションはABIを変更します（AMDGPUのみ）。'
# 'Sets the SIMD width. Zero is autoselect.'
HA8F45CFC1E01: 'SIMD幅を設定。0の場合は自動選択。'
# 'Sets the bias which adds weight to occupancy vs latency. Set it to 100 to chase the occupancy only.'
HDE531962A442: 'occupancy対latencyのバランスにバイアスを設定。100に設定するとoccupancyのみを追求します。'
# 'Sets the cost threshold for when multiple conditionals will be merged into one branch versus be split in multiple branches. Merging conditionals saves branches at the cost of additional instructions. This value sets the instruction cost limit, below which conditionals will be merged, and above which conditionals will be split. Set to -1 to never merge branches.'
H908B80F5C5DD: '複数の条件式を1つのブランチに統合するか、複数のブランチに分割するかどうかのコスト閾値を設定。条件式の統合は追加命令のコストを伴いますが、ブランチ数を減らします。この値は命令コストの上限を設定し、閾値以下では統合、閾値を超えると分割されます。-1に設定するとブランチの統合を完全に無効にします。'
# 'Sets the default matrix layout'
HB552288B1A94: 'デフォルトの行列配置を設定'
# 'Sets the maximum allowed output size (0 means no limit) [ELF only]'
H7FE764745013: '許可される最大出力サイズを設定（0は制限なし） [ELFのみ]'
# 'Sets the minimum function size to instrument with XRay'
HF47DF90C1776: 'XRayで測定する関数の最小サイズを設定'
# 'Sets the mode of detection for stack-use-after-return.'
H3FEDDC9474EF: 'stack-use-after-returnの検出モードを設定'
# 'Sets the preferable loop alignment for experiments (as log2 bytes) for innermost loops only. If specified, this option overrides alignment set by x86-experimental-pref-loop-alignment.'
H0A768F10FB45: '実験用のループアライメントを設定します（log2バイト単位）最内層ループに限定されます。指定された場合、このオプションはx86-experimental-pref-loop-alignmentで設定されたアライメントを上書きします。'
# 'Sets the vectorization interleave count. Zero is autoselect.'
H0275ABE673BB: 'ベクトル化のインターレーブカウントを設定します。0は自動選択です。'
# 'Sets various macros to claim compatibility with the given GCC version (default is 4.2.1)'
HF256B239FB01: '指定されたGCCバージョン（デフォルトは4.2.1）との互換性を主張するためのマクロを設定します'
# 'Shadow Stack GC Lowering'
H04B76D4FEDB5: 'Shadow Stack GC Lowering'
# 'Should __STATIC__ be defined'
H46691D14FB8F: '__STATIC__を定義する必要がありますか？'
# 'Should a closed world be assumed, or not. Default if not set.'
H5AB58A4464B6: 'クローズドワールドを仮定する必要がありますか。設定されていない場合、既定値が適用されます。'
# 'Should enable CSE in Legalizer'
H77887DE8DF92: 'LegalizerでCSEを有効にしますか？'
# 'Should enable CSE in irtranslator'
H91C4D8FE802C: 'irtranslatorでCSEを有効にしますか？'
# 'Should mir-strip-debug only strip debug info from debugified modules by default'
H3DC291F161A1: 'デフォルトでは、mir-strip-debugはデバッグ化されたモジュールからデバッグ情報のみを削除する必要がありますか？'
# 'Should we attempt to sink negations?'
HA914A0DB2603: '否定を沈めるように試みますか？'
# 'Show FailedToMaterialize errors'
HE9058727A1A0: 'FailedToMaterializeエラーを表示しますか？'
# 'Show MCDC statistics in summary table'
HC702D8A97A6E: '要約表にMCDC統計を表示しますか？'
# 'Show True/False counts'
HFE8C8190B143: 'True/Falseのカウントを表示しますか？'
# 'Show True/False percent'
H07C8D556E1B3: 'True/Falseの割合を表示しますか？'
# 'Show binary counters (1/0) in lines and branches instead of integer execution counts'
HB45D3670503F: '行と分岐において、整数の実行カウントではなく1/0の二進カウンタを表示しますか？'
# 'Show binary ids in the profile. '
HB609CBDF46B1: 'プロファイルにバイナリIDを表示しますか？'
# 'Show bindings of tools to actions'
H25DE8385EB09: 'ツールとアクションの関連付けを表示しますか？'
# 'Show branch condition statistics in summary table'
H231A08B7A99F: '分岐条件の統計を要約表に表示しますか？'
# 'Show call-multigraph (do not remove parallel edges)'
HCC8B57A6B12A: '平行エッジを削除せずcall-multigraphを表示しますか？'
# 'Show code coverage only for functions listed in the given file'
H0D504442CF50: '指定されたファイルにリストされている関数のコードカバレッジのみを表示しますか？'
# 'Show code coverage only for functions that match the given regular expression'
H6E2F7500DDDA: '指定された正規表現に一致する関数のコードカバレッジのみを表示'
# 'Show code coverage only for functions with line coverage greater than the given threshold'
H6945238A4869: '指定されたしきい値を超える行カバレッジを持つ関数のコードカバレッジのみを表示'
# 'Show code coverage only for functions with line coverage less than the given threshold'
H1A772B15E654: '指定されたしきい値未満の行カバレッジを持つ関数のコードカバレッジのみを表示'
# 'Show code coverage only for functions with region coverage greater than the given threshold'
HF06D994C900A: '指定されたしきい値を超える領域カバレッジを持つ関数のコードカバレッジのみを表示'
# 'Show code coverage only for functions with region coverage less than the given threshold'
H4FA285578577: '指定されたしきい値未満の領域カバレッジを持つ関数のコードカバレッジのみを表示'
# 'Show code coverage only for functions with the given name'
H9786810746F0: '指定された名前の関数のコードカバレッジのみを表示'
# 'Show commands to run and use verbose output'
HE1D432762909: '実行するコマンドと詳細出力を表示'
# 'Show context sensitive counts'
HE2280C2DDA17: '文脈依存のカウントを表示'
# 'Show counter values for shown functions'
H129F56F5FD53: '表示された関数のカウンタ値を表示'
# 'Show coverage for branch conditions'
HC96F564B6A82: '分岐条件のカバレッジを表示'
# 'Show coverage for each function'
H3CCABA0A8100: '各関数のカバレッジを表示'
# 'Show coverage summaries for each function'
HBAF14E467A0F: '各関数のカバレッジサマリを表示'
# 'Show created time for each page.'
H321E973C4182: '各ページの作成時間を表示'
# 'Show detailed profile summary'
HEDDF2BF2C691: '詳細なプロファイルサマリを表示'
# 'Show detailed warning message.'
H9E7102D900DA: '詳細な警告メッセージを表示'
# 'Show details of invoking getNextResoufceCycle.'
HA4F0023B8FF3: 'getNextResoufceCycleの呼び出し詳細を表示'
# 'Show directory coverage'
H83933D919BBD: 'ディレクトリのカバレッジを表示'
# 'Show edges labeled with weights'
H376FB60A851E: '重み付きラベルのエッジを表示'
# 'Show encoding in .s output'
HB528C74F2189: '.s出力でのエンコーディングを表示'
# 'Show expanded source regions'
H387D478FCAFF: '展開されたソース領域を表示'
# 'Show function instantiations'
HCFC0922F8DE2: '関数のインスタンス化を表示'
# 'Show header includes and nesting depth'
HFC379692A313: 'ヘッダの包含とネスト深さを表示'
# 'Show heat colors in CFG'
HF38DE9931AB9: 'CFGにヒートカラーマップを表示'
# 'Show heat colors in call-graph'
HDDDF3F1C338F: 'コールグラフにヒートカラーマップを表示'
# 'Show indirect call site target values for shown functions'
H4D99B80D7C36: '表示された関数の間接呼び出しサイトのターゲット値を表示'
# 'Show instantiation statistics in summary table'
HAD4D78E39FA9: 'サマリーテーブルにインスタンス化統計を表示'
# 'Show instr profile data in text dump format'
HE77B1EB739B5: 'テキストダンプ形式で指令プロファイルデータを表示'
# 'Show instruction encoding information in transliterate mode'
H15214D90288C: 'Transliterateモードで命令エンコーディング情報を表示'
# 'Show instruction encodings'
H76A361C43AC1: '命令エンコーディングを表示'
# 'Show instructions operands as parsed'
HE4EAD3961196: 'パースされた命令のオペランドを表示'
# 'Show internal debug dump'
H79FC9F317159: '内部デバッグダンプを表示'
# 'Show internal instruction representation'
H969E08C4B063: '内部命令表現を表示'
# 'Show internal instruction representation in transliterate mode'
HCF07E4857D2B: 'Transliterateモードで内部命令表現を表示'
# 'Show lexical and class parents'
H2CD760A9C080: '語彙的な親とクラスの親を表示'
# 'Show line numbers in diagnostic code snippets'
H08938EFDB15B: '診断コードスニペットに行番号を表示'
# 'Show only simple regions in the graphviz viewer'
H09E6F5F4BBB1: 'Graphvizビューアでシンプルな領域のみを表示'
# 'Show only the configs matching this regex'
H2BD050A28852: 'この正規表現に一致する設定のみを表示'
# 'Show only the functions that have been executed.'
HD6154133C806: '実行された関数のみを表示'
# 'Show profile summary of a list of hot functions'
H0361C5298777: 'ホット関数リストのプロファイルサマリーを表示'
# 'Show profile symbol list if it exists in the profile. '
HC84B87BCF81B: 'プロファイルに存在する場合、プロファイルシンボルリストを表示。'
# 'Show profile version. '
HD8D6C82AA426: 'プロファイルのバージョンを表示します。'
# 'Show region statistics in summary table'
H3D65F3DC6E98: '要約テーブルにリージョンの統計情報を表示'
# 'Show sample profile data in the JSON format (deprecated, please use --show-format=json)'
H828A9B7D7ACC: 'JSON形式でサンプルプロファイルデータを表示 (非推奨、--show-format=jsonを使用してください)'
# 'Show skipped includes in -H output.'
H2CB52D019FEC: '-H出力でスキップされたインクルードを表示します。'
# 'Show temporal profile traces in the profile.'
H72096941B959: 'プロファイル内の一時的なプロファイルトレースを表示します。'
# 'Show the MCDC Coverage for each applicable boolean expression'
HD1B4BD4AF9D7: '各適用可能なブール式のMCDCカバレッジを表示'
# 'Show the Polly CFG right after code generation'
H029F6C967468: 'コード生成直後のPolly CFGを表示'
# 'Show the collected coverage object files'
H31D89D92BF30: '集計されたカバレッジオブジェクトファイルを表示'
# 'Show the collected paths to source files'
H26A34004C8C4: '集計されたソースファイルへのパスを表示'
# 'Show the execution counts for each line'
HBDA134A1E3B8: '各行の実行カウントを表示'
# 'Show the execution counts for each line, or the execution counts for each region on lines that have multiple regions'
H9AF77074F9BE: '各行の実行カウントを表示、または複数のリージョンがある行の各リージョンの実行カウントを表示'
# 'Show the execution counts for each region'
HE82C34C08B90: '各リージョンの実行カウントを表示'
# 'Show the information of each section in the sample profile. The flag is only usable when the sample profile is in extbinary format'
HF5346C9B396B: 'サンプルプロファイル内の各セクションの情報を表示。このフラグはサンプルプロファイルがextbinary形式の場合のみ使用可能です'
# 'Show the list of functions with the largest internal counts'
HDB413363F895: '内部カウントが最も大きい関数の一覧を表示'
# 'Show the profiled sizes of the memory intrinsic calls for shown functions'
HEACDF1B2720A: '表示された関数のメモリintrinsicコールのプロファイルサイズを表示'
# 'Show the sizes of all debug sections, expressed in bytes.'
H78A0DAA47053: 'すべてのデバッグセクションのサイズをバイト単位で表示'
# 'Show the sources across all compilation units.'
H9382C23DCF90: '全てのコンパイル単位のソースを表示'
# 'Show times for llvm-jitlink phases'
HD3302520BB6D: 'llvm-jitlinkフェーズの時間を表示'
# 'Show times for llvm-rtdyld phases'
HB7BC3C6A17C2: 'llvm-rtdyldフェーズの時間を表示'
# 'Show verbose output when opt-bisect-limit is set'
H8536EE8B8C8C: 'opt-bisect-limitが設定されている場合、詳細出力を表示'
# 'Show vtable names for shown functions'
H79407841F063: '表示された関数のvtable名を表示'
# 'Shrink Wrap Pass'
HE4743C131F02: 'Shrink Wrap パス'
# 'Shuffle machine instructions alternating directions'
H3D7E0E8AF77B: 'マシン命令を交互に方向を変えてシャッフル'
# 'Silence ObjC rewriting warnings'
HDDBF5BEB68D8: 'ObjCのリライトに関する警告を抑制'
# 'Similar completion items (e.g. function overloads) are combined. Type information shown where possible'
H1DEA188ACC34: '類似の補完項目（例: 関数のオーバーロード）をまとめる。可能な場合は型情報を表示'
# 'Similar to -ftime-trace. Specify the JSON file or a directory which will contain the JSON file'
H53211B2FCAB2: '-ftime-traceに似た機能。JSONファイルまたはそのファイルを含むディレクトリを指定'
# 'Similar to data-and-control, but remove the runtime check'
HDAE5253998D0: 'data-and-controlに似ているが、ランタイムチェックを削除'
# 'Similar to list-burr but schedules in source order when possible'
H322EBF2ED613: 'list-burrに似ているが、可能な場合ソース順でスケジューリング'
# 'Simple speculation'
H736302864F3E: 'シンプルなスペキュレーション'
# 'Simplify DDG by merging nodes that have less interesting edges.'
H140319D98680: 'DDGを単純化（興味の薄いエッジを持つノードをマージ）'
# 'Simplify SCoP after optimizations'
H9435BBE6A7ED: '最適化後にSCoPを単純化'
# 'Simplify the CFG'
H3F01631183F4: 'CFGを単純化'
# 'Simplify the CFG after atomic expansion pass'
H4B39E0A8393B: 'アトミック展開パスの後にCFGを単純化'
# 'Simply drop type test sequences'
H6F563FE46789: '型テストのシーケンスを単純に削除'
# 'Simulate installation in the given directory'
H2E8832D0BC0E: '指定されたディレクトリでのインストールをシミュレート'
# 'Single thread model'
H0A1A3414EA60: 'シングルスレッドモデル'
# 'Sink common instructions (default = false)'
H458310DD7CCF: '共通命令を沈め（既定値=false）'
# 'Sink common instructions down to the end block'
HB6833655C393: '共通命令を終端ブロックまで沈める'
# 'Sink instructions into cycles to avoid register spills'
HA19B07EB7A73: 'レジスタスpillを避けるために命令をサイクル内に沈める'
# 'Size limit for the MII.'
HFE4E64539F6A: 'MIIのサイズ制限'
# 'Size limit in Hexagon early if-conversion'
HEE45F9DDA387: 'Hexagon早期if変換でのサイズ制限'
# 'Size of the expression which is considered huge'
H4AAD9C3152F7: '非常に大きいと見なされる式のサイズ'
# 'Size of the load queue'
H51731E4081C2: 'ロードキューのサイズ'
# 'Size of the store queue'
H7CD5021D4D3E: 'ストアキューのサイズ'
# 'Size-specialize memcmp and bcmp calls'
H4D487410E126: 'サイズに基づいてmemcmpとbcmp呼び出しを特殊化'
# 'SjLj exception handling'
HA2DEA63BE575: 'SjLj例外処理'
# 'Skip 64-bit divide for dynamic 32-bit values'
HBC981EB66354: '動的32ビット値のための64ビット除算をスキップ'
# 'Skip Callsite up to this number for this compilation'
HD2D3E00B6C18: 'このコンパイルでのこの数までのコールサイトをスキップ'
# 'Skip Cost Analysis'
HEBC9E235FCC3: 'コスト分析をスキップ'
# 'Skip ODR checks for decls in the global module fragment.'
H3261F074F5AE: 'グローバルモジュールフラグメント内の宣言に対するODRチェックをスキップ'
# 'Skip checks for relocated modules when loading PCM files'
HD81AE42FB9F0: 'PCMファイルの読み込み時に再配置されたモジュールに対するチェックをスキップ'
# "Skip emitting basic block entries in the SHT_LLVM_BB_ADDR_MAP section. It's used to save binary size when BB entries are unnecessary for some PGOAnalysisMap features."
H71707934B534: 'SHT_LLVM_BB_ADDR_MAPセクションでの基本ブロックエントリの出力をスキップ。これは、BBエントリが一部のPGOAnalysisMap機能では不要な場合にバイナリサイズを節約するために使用されます。'
# 'Skip function bodies when possible'
HC6384E72882E: '可能な場合、関数本体をスキップ'
# 'Skip instructions on input which lack scheduling information'
H0CA4A6B1674E: '入力にあるスケジューリング情報のない命令をスキップ'
# 'Skip instructions or lines on input which are unsupported for any reason'
H66EA3C6B0D85: '入力にある、いかなる理由でもサポートされていない命令または行をスキップ'
# 'Skip lines on the input which fail to parse for any reason'
HF1FE9D6E74D2: '入力にある、いかなる理由でもパースに失敗する行をスキップ'
# 'Skip merging empty blocks if (frequency of empty block) / (frequency of destination block) is greater than this ratio'
HD3ACA543F291: '空ブロックの頻度/宛先ブロックの頻度がこの比を超える場合、空ブロックのマージをスキップ'
# 'Skip merging functions with no parameters.'
H4C33F6695ED3: 'パラメータがない関数のマージをスキップ'
# 'Skip op verification when using custom printers'
HE99716DCF0A6: 'カスタムプリンタを使用する際、オペレーション検証をスキップ'
# 'Skip pass list reduction steps'
H94E9DA2F7021: 'パスリストの削減ステップをスキップ'
# 'Skip printing info about analyses'
H89B96A0AA8C3: '解析に関する情報の印刷をスキップ'
# 'Skip regions when printing ops.'
HE9909BB5AB83: 'オペレーションを印刷する際、リージョンをスキップ'
# 'Skip relative hotness check for ICP up to given number of targets.'
H1CF24D29FE78: 'ICPの相対的なホットネスチェックを、指定されたターゲット数までスキップ'
# 'Skip setting up RAX register when passing variable arguments (x86 only)'
H88536767AEC5: '可変引数を渡す際にRAXレジスタの設定をスキップ (x86のみ)'
# 'Skip source code files with file paths that match the given regular expression'
HF5248544A184: '与えられた正規表現に一致するファイルパスを持つソースコードファイルをスキップ'
# 'Skip the check if the number of hot functions is smaller than the specified number.'
HC72D43FB0410: 'ホット関数の数が指定された数未満の場合はチェックをスキップ'
# 'Skip the dependency check for pragma-based transformations'
H9266BB52380C: 'プリプロセス指示子（#pragma）に基づく変換の依存関係チェックをスキップします'
# 'Slot index numbering'
H25CDF44B807D: 'スロットインデックスの番号付け'
# 'Small code model'
HDBB10FAFE07D: '小型コードモデル'
# 'Small data and bss section threshold size (default=0)'
HCE054C60032A: 'small dataセクションとBSSセクションのしきい値サイズ（デフォルト=0）'
# 'Small data and bss section threshold size (default=8)'
HD23849593CCC: 'small dataセクションとBSSセクションのしきい値サイズ（デフォルト=8）'
# 'Soft float ABI (implied by -soft-float)'
HC0C86A6BE8AC: 'ソフトフロートABI（-soft-floatオプションで暗黙に指定）'
# 'Sort by element kind.'
H873DE05DDF9E: '要素の種類でソート'
# 'Sort by element line number.'
HE0D755567860: '要素の行番号でソート'
# 'Sort by element name.'
H0C2C0BB04670: '要素の名前でソート'
# 'Sort by element offset.'
HAEFFB6AFF193: '要素のオフセットでソート'
# 'Sort classes by amount of immediate padding'
HC0D1B98A168E: '即値のパディング量でクラスをソート'
# 'Sort classes by amount of padding'
H6740525F2A73: 'パディング量でクラスをソート'
# 'Sort classes by name'
H525546C671ED: '名前でクラスをソート'
# 'Sort classes by percentage of space consumed by immediate padding'
H807712AAABEC: '即値のパディングが消費するスペースのパーセンテージでクラスをソート'
# 'Sort classes by percentage of space consumed by padding'
H2970C3CE6488: 'パディングで消費されるスペースのパーセンテージでクラスを並べ替え'
# 'Sort classes by size'
H4175309835B2: 'サイズでクラスを並べ替え'
# 'Sort profiled recursion by edge weights.'
HDC0AFFCFAE60: 'プロファイルされた再帰をエッジの重みで並べ替え'
# 'Sort symbols by name'
HEF9C9A551533: 'シンボルの名前で並べ替え'
# 'Sort symbols by size'
H194BBF71E1B6: 'シンボルのサイズで並べ替え'
# 'Sort the resources printed in the dump trace'
H66B4BBE5718F: 'ダンプトレースに出力されるリソースを並べ替え'
# 'Sorts and reorders operands in commutative instructions'
H74BB35674C4A: '可換命令のオペランドを並べ替え並び替えます'
# 'Source Code Analysis - Dead Symbol Removal Frequency'
H658C75F7C985: 'ソースコード分析 - 死んだシンボルの削除頻度'
# 'Source Code Analysis - Output Options'
H418F37A89230: 'ソースコード分析 - 出力オプション'
# 'Source Code Analysis - Symbolic Constraint Engines'
HD8341B8B44B5: 'ソースコード分析 - シンボル制約エンジン'
# 'Source prefix to elide'
HF556E14613B2: '省略するソースプレフィックス'
# "Source-level compatibility for Altivec vectors (for PowerPC targets). This includes results of vector comparison (scalar for 'xl', vector for 'gcc') as well as behavior when initializing with a scalar (splatting for 'xl', element zero only for 'gcc'). For 'mixed', the compatibility is as 'gcc' for 'vector bool/vector pixel' and as 'xl' for other types. Current default is 'mixed'."
HCF923B012626: "PowerPCターゲット向けのAltivecベクタのソースレベル互換性（デフォルト）。これには、ベクタ比較の結果（'xl'の場合スカラ、'gcc'の場合ベクタ）やスカラで初期化した際の動作（'xl'の場合スプラッティング、'gcc'の場合要素0のみ）が含まれます。'mixed'の場合、'vector bool/vector pixel'は'gc'の互換性、他の型は'xl'の互換性となります。現在のデフォルトは'mixed'です。"
# 'SourceLocation in file %0 at offset %1 is invalid'
H2A6519004798: '%0 ファイルのオフセット %1 でのソースロケーションが無効です'
# 'Spawn a separate process for each cc1'
H4079AEA987DF: '各cc1ごとに別プロセスを起動'
# 'Spawns a subprocess for each snippet execution, allows for the use of memory annotations'
HB0B29965076D: '各スニペット実行ごとにサブプロセスを起動し、メモリアノテーションを使用可能にします'
# 'Specifies PowerPC native vector element order (default)'
HE6ABC638069C: 'PowerPCネイティブベクタ要素順序を指定（デフォルト）'
# 'Specifies PowerPC non-native vector element order'
H1D9287995DAC: 'PowerPC非ネイティブベクタ要素順序を指定'
# 'Specifies a list of variables to be exempt from the TOC data transformation.'
HAF01AE884575: 'TOCデータ変換から除外する変数のリストを指定'
# 'Specifies a list of variables to which the TOC data transformation will be applied.'
H33958769FAEF: 'TOCデータ変換を適用する変数のリストを指定'
# "Specifies preferred vector width for auto-vectorization. Defaults to 'none' which allows target specific decisions."
H30D4DB622AB0: "auto-vectorization用の推奨ベクタ幅を指定。デフォルトは'target固有の決定を許可する'の'none'"
# 'Specifies that the sample profile is accurate'
H3A3F53CE7955: 'サンプルプロファイルが正確であることを指定'
# 'Specifies the JITDylib to be used for any subsequent -extra-module arguments.'
HFDCED35F4977: '-extra-module引数に続く使用するJITDylibを指定'
# 'Specifies the JITDylib to be used for any subsequent input file, -L<seacrh-path>, and -l<library> arguments'
H72683DE0AF39: '入力ファイル、-L<検索パス>、-l<ライブラリ> 引数に続く使用するJITDylibを指定'
# "Specifies the debug info's compilation dir"
H64EB79AAF220: 'デバッグ情報のコンパイルディレクトリを指定'
# 'Specifies the evaluation method to use for floating-point arithmetic.'
HB1694AF39E4A: '浮動小数点算術の評価方法を指定'
# 'Specifies the exception behavior of floating-point operations.'
HF7A17A05FFEE: '浮動小数点操作の例外挙動を指定'
# "Specifies the largest alignment guaranteed by '::operator new(size_t)'"
H7C74E7BEFD7B: "'::operator new(size_t)'が保証する最大アライメントを指定"
# 'Specifies the name we should consider the input file'
H048BF6366B06: '入力ファイルの名前を指定'
# 'Specifies the size of batches for processing CUs. Higher number has better performance, but more memory usage. Default value is 1.'
HE1BE8B43F7F0: 'CUsの処理バッチサイズを指定。数値が大きいほど性能向上だがメモリ使用量増加。デフォルトは1'
# 'Specify "safe" i.e. known-good backend:'
H8A9DA72ACD37: '"safe"（信頼できるバックエンド）を指定:'
# 'Specify <function, basic block1[;basic block2...]> pairs to extract.\nEach pair will create a function.\nIf multiple basic blocks are specified in one pair,\nthe first block in the sequence should dominate the rest.\neg:\n  --bb=f:bb1;bb2 will extract one function with both bb1 and bb2;\n  --bb=f:bb1 --bb=f:bb2 will extract two functions, one with bb1, one with bb2.'
H849E2CD57584: '<関数, ベーシックブロック1[;ベーシックブロック2...]>のペアを指定して抽出。\n各ペアは1つの関数を作成。\n1つのペアに複数のベーシックブロックを指定した場合、\n最初のブロックが他のブロックを支配する必要があります。\neg:\n  --bb=f:bb1;bb2 は両方のブロックを持つ関数を1つ作成します;\n  --bb=f:bb1 --bb=f:bb2 はそれぞれ単独で2つの関数を作成します。'
# 'Specify <script> as linker script'
HE790F52CC3F0: '<script>をリンカースクリプトとして指定'
# 'Specify CU wavefront execution mode (AMDGPU only)'
H0AC391ACF1B8: 'AMDGPU専用: CUウェーブフロント実行モードを指定'
# 'Specify O2(not Os) spill func threshold'
HEC690666E75E: 'O2（Osでない）のspill関数しきい値を指定'
# 'Specify Os spill func threshold'
H2796D0A3FC8E: 'Osのspill関数しきい値を指定'
# 'Specify WGP wavefront execution mode (AMDGPU only)'
H1A9B58D9172E: 'AMDGPU専用: WGPウェーブフロント実行モードを指定'
# 'Specify a SamplePGO profile file'
H5B1BF8C410B3: 'サンプルPGOプロファイルファイルを指定'
# 'Specify a context sensitive PGO profile file'
H6CD3C27C7374: 'コンテキスト依存PGOプロファイルファイルを指定'
# "Specify a default target triple when it's not available in the module"
H8905580ACB2D: 'モジュールにない場合のデフォルトのターゲットトリプルを指定します'
# "Specify a directory where Clang can find 'include' and 'lib{,32,64}/gcc{,-cross}/$triple/$version'. Clang will use the GCC installation with the largest version"
H5F9EC5F91118: "Clangが'include'と'lib{,32,64}/gcc{,-cross}/$triple/$version'を見つけるディレクトリを指定します。Clangは最も新しいバージョンのGCCインストールを使用します"
# "Specify a directory where Flang can find 'lib{,32,64}/gcc{,-cross}/$triple/$version'. Flang will use the GCC installation with the largest version"
H59AA0290DBA6: "Flangが'lib{,32,64}/gcc{,-cross}/$triple/$version'を見つけるディレクトリを指定します。Flangは最も新しいバージョンのGCCインストールを使用します"
# 'Specify a plugin to optimize LFENCE insertion'
H749CB0E11874: 'LFENCE挿入を最適化するプラグインを指定します'
# 'Specify a reference program output (for miscompilation detection)'
H7D6525B849BF: '誤コンパイル検出用の参照プログラム出力を指定します'
# 'Specify a symbol resolution: filename,symbolname,resolution\nwhere "resolution" is a sequence (which may be empty) of the\nfollowing characters:\n p - prevailing: the linker has chosen this definition of the\n     symbol\n l - local: the definition of this symbol is unpreemptable at\n     runtime and is known to be in this linkage unit\n x - externally visible: the definition of this symbol is\n     visible outside of the LTO unit\nA resolution for each symbol must be specified'
HFA08A87A55A4: '解決を指定：filename,symbolname,resolution\n「resolution」は以下の文字の列（空でも可）:\n p - 主要：リンカがこのシンボル定義を選択\n l - ローカル：このシンボルの定義は実行時に予約不能で、このリンカユニット内にある\n x - 外部可視：このシンボルの定義はLTOユニット外でも見える\n各シンボルの解決を指定する必要があります'
# 'Specify alias to extract'
H4D5920CD11AC: '抽出するエイリアスを指定します'
# 'Specify alias(es) to extract using a regular expression'
H5A885E78EEAE: '正規表現を使用して抽出するエイリアス（複数可）を指定します'
# "Specify an offloading device architecture for CUDA, HIP, or OpenMP. (e.g. sm_35). If 'native' is used the compiler will detect locally installed architectures. For HIP offloading, the device architecture can be followed by target ID features delimited by a colon (e.g. gfx908:xnack+:sramecc-). May be specified more than once."
H03D163E89A58: 'CUDA、HIP、またはOpenMPのオフロード用デバイスアーキテクチャを指定（例：sm_35）。"native"を指定するとコンパイラがローカルにインストールされたアーキテクチャを検出します。HIPオフロードではデバイスアーキテクチャにターゲットIDの機能をコロン区切りで追加可能です（例：gfx908:xnack+:sramecc-）。複数指定可能です。'
# 'Specify an output filename for an HTML report. This describes both recommendations and reasons for changes.'
H8B1F64A00015: '推奨事項と変更理由を説明するHTMLレポートの出力ファイル名を指定します'
# 'Specify bit size of immediate TLS offsets (AArch64 ELF only): 12 (for 4KB) | 24 (for 16MB, default) | 32 (for 4GB) | 48 (for 256TB, needs -mcmodel=large)'
H26411589DDDC: '直既定数TLSオフセットのビットサイズ（AArch64 ELF専用）を指定：12（4KB） | 24（16MB、デフォルト） | 32（4GB） | 48（256TB、-mcmodel=largeが必要）'
# 'Specify code object ABI version. Defaults to 6. (AMDGPU only)'
HA8698B7A4F07: 'コードオブジェクトABIバージョンを指定（AMDGPU専用）。デフォルトは6です'
# 'Specify comma-separated list of offloading target triples (CUDA and HIP only)'
H4646687E209A: 'CUDA/HIP用オフロードターゲットトリプルのリストをカンマ区切りで指定します'
# 'Specify comma-separated list of triples OpenMP offloading targets to be supported'
H3568A2B2B198: 'サポートするOpenMPオフロードターゲットのトリプルリストをカンマ区切りで指定します'
# 'Specify command to run'
H1E332E02D801: '実行コマンドを指定します'
# 'Specify configuration file'
HF189739D324B: '設定ファイルを指定します'
# "Specify default stream. The default value is 'legacy'. (CUDA/HIP only)"
H9CAF3E629210: 'デフォルトストリームを指定（デフォルトは「legacy」。CUDA/HIP専用）'
# 'Specify file to retrieve coverage information from'
HF677E8D618FB: 'カバレッジ情報を取得するファイルを指定します'
# 'Specify file to retrieve the list of functions to apply CHR to'
H43EA914C6AE3: 'CHRを適用する関数リストを含むファイルを指定します'
# 'Specify file to retrieve the list of modules to apply CHR to'
HB6D52312D695: 'CHRを適用するモジュールの一覧を取得するためのファイルを指定します'
# 'Specify frame pointer elimination optimization'
HCB5E3F71D5CB: 'フレームポインタ除去最適化を指定します'
# 'Specify function to extract'
H6994C514E482: '抽出する関数を指定します'
# 'Specify function(s) to extract using a regular expression'
H807560CFE84D: '正規表現を使用して抽出する関数を指定します'
# 'Specify global to extract'
HDBAFDC1CCA62: '抽出するグローバル変数を指定します'
# 'Specify global(s) to extract using a regular expression'
H3D4D2BF99055: '正規表現を使用して抽出するグローバル変数を指定します'
# 'Specify gotol lower bound'
H0CEAACB24E44: 'gotol の下限を指定します'
# 'Specify how to interpret the input file'
H8145E9D12D4E: '入力ファイルの解釈方法を指定します'
# 'Specify input format'
H2E3E293CB7F2: '入力形式を指定します'
# 'Specify list of enabled SPIR-V extensions'
H3D0774E8209D: '有効にする SPIR-V の拡張機能の一覧を指定します'
# 'Specify lowering strategy for function LDS access:'
H5D945C2F2C1F: '関数の LDS アクセスのための削減戦略を指定します'
# 'Specify maximum number of prefixes to use for padding'
H3374CFFFC8CB: 'パディングに使用するプレフィックスの最大数を指定します'
# 'Specify name of main file output in depfile'
HA7D009581C27: 'depfile に出力するメインファイルの名前を指定します'
# 'Specify name of main file output to quote in depfile'
H50F02814EC9E: 'depfile で引用形式で出力するメインファイルの名前を指定します'
# 'Specify output filename'
H1761FE158718: '出力ファイル名を指定します'
# 'Specify remark argument/s to count (accepts regular expressions).'
H822EAE5D54AB: 'カウントする remark 引数を指定します（正規表現を受け付けます）'
# 'Specify remark argument/s to count by.'
HAEE8EE4F6186: 'remark 引数をカウントする基準を指定します。'
# 'Specify target SDNode namespace (default=<Target>ISD)'
H929FE737DC80: 'ターゲットの SDNode ネームスペースを指定します（デフォルトは <Target>ISD）'
# 'Specify target triple (e.g. i686-apple-darwin9)'
HB87754B01AFD: 'ターゲット triple を指定します（例: i686-apple-darwin9）'
# 'Specify that backslash in string introduces an escape character'
H5D6C9DDA7494: '文字列内のバックスラッシュがエスケープ文字を表すように指定'
# 'Specify that floating-point optimizations are not allowed that assume arguments and results are not +-inf.'
H8BEEB06E6F67: '引数や結果が±無限大ではないと仮定する浮動小数点最適化を許可しないように指定'
# 'Specify that floating-point optimizations are not allowed that assume arguments and results are not NANs.'
H8FA0A762F433: '引数や結果がNANではないと仮定する浮動小数点最適化を許可しないように指定'
# 'Specify that kernel argument names are preserved (HIP only)'
H623A10E0D7BD: 'カーネル引数名を保持するように指定（HIPのみ有効）'
# 'Specify that single precision floating-point divide and sqrt used in the program source are correctly rounded (HIP device compilation only)'
H6D7A7AAF7A65: 'シングルプレシジョン浮動小数点除算と平方根が正しく四捨五入されているように指定（HIPデバイスコンパイルのみ有効）'
# 'Specify that the assembler should encode SSE instructions with VEX prefix'
HE1B00D0701B9: 'アsemblerにVEXプレフィックス付きSSE命令をエンコードさせることを指定'
# 'Specify the "test" i.e. suspect back-end:'
HECCC4473972C: '"test"（つまり疑わしいバックエンド）を指定:'
# 'Specify the BPF stack size limit'
HDC6898D3AB44: 'BPFスタックサイズの制限値を指定'
# 'Specify the Swift version to use when filtering API notes'
HC09727464228: 'APIノートをフィルタリングするためのSwiftバージョンを指定'
# "Specify the boundary's size to align branches"
H7FCB2E0E7262: '分岐のアラインメント用の境界サイズを指定'
# 'Specify the class to use for constant Objective-C string objects.'
H3B4E080AFF98: 'ソースファイルのデフォルト文字セットを指定'
# 'Specify the compression level (integer)'
HA372218D9884: '構造体のパッキングアラインメントのデフォルト最大値を指定'
# 'Specify the current profile is used as a partial profile.'
H3B5AA73241EA: 'darwinターゲット変種トリプルを指定'
# 'Specify the darwin target variant triple'
H1C214E10868A: 'ソースファイルのデフォルト文字セットを指定'
# 'Specify the default character set for source files'
H23A2C73FDF8A: '構造体のパッキングアラインメントのデフォルト最大値を指定'
# 'Specify the default maximum struct packing alignment'
HA57D1AA26D37: "実行可能ファイルのエントリ関数を指定（デフォルトは'main'）"
# "Specify the entry function (default = 'main') of the executable"
H95F6DBF9D7B0: "実行可能ファイルのエントリ関数を指定 (デフォルトは 'main')"
# 'Specify the filename of the process to launch for remote MCJIT execution.  If none is specified,\n\tremote execution will be simulated in-process.'
HB6260E716DE3: 'リモート MCJIT 実行で起動するプロセスのファイル名を指定。指定がない場合は、プロセス内シミュレーションが行われます。'
# 'Specify the function selection heuristic used during inlining'
H700459284955: 'オーバーフロー時に呼び出す関数を指定'
# 'Specify the function to be called on overflow'
H514658550A0D: 'オーバーフロー時に呼び出す関数を指定'
# 'Specify the interval (in seconds) after which a module file will be considered unused'
H7EDAFDC5BFCC: 'モジュールファイルが未使用と見なされるまでの間隔（秒単位）を指定'
# 'Specify the interval (in seconds) between attempts to prune the module cache'
HC07FD162EBA7: 'モジュールキャッシュのクリーンアップ試行間隔（秒単位）を指定'
# 'Specify the mapping of module name to precompiled module file, or load a module file if name is omitted.'
H9433E5C683C8: 'モジュール名とプリコンパイル済みモジュールファイルの対応付け、または名前を省略してモジュールファイルを読み込みます。'
# 'Specify the maximum alignment to enforce on pointers lacking an explicit alignment'
H46AC799A7735: '明示的なアライメントを指定しないポインタに適用する最大アライメントを指定'
# 'Specify the maximum amount of instructions to inspect when searching for a conditional branch from an indirect control flow.'
H6CFBC17F5A5D: '間接制御フローから条件付き分岐を検索する際に調べる命令の最大数を指定'
# 'Specify the maximum amount of instructions to inspect when searching for an undefined instruction from a conditional branch.'
HBCCACE2ACD35: '条件付き分岐から未定義命令を検索する際に調べる命令の最大数を指定'
# 'Specify the module cache path'
H2FE40A911909: 'モジュールキャッシュのパスを指定'
# 'Specify the module user build path'
HE6E81535FDBA: 'モジュールのユーザー構築パスを指定'
# 'Specify the name of an IR file to load for function definitions'
H66FD8DF154C5: '関数定義用に読み込む IR ファイルの名前を指定'
# 'Specify the name of the .dwo file to encode in the DWARF output'
HFD25A07F8173: '.dwo ファイルの名前を DWARF 出力にエンコードするための指定'
# 'Specify the name of the module to build'
HC274D886E608: '構築するモジュールの名前を指定'
# 'Specify the name of the root module.'
H385C12B5E6FA: 'ルートモジュールの名前を指定'
# "Specify the output file type ('asm', 'null', or 'obj')"
H908E78C67406: "出力ファイルの種類を指定 ('asm', 'null', または 'obj')"
# 'Specify the output file. default: reduced.ll|.bc|.mir'
HDB7BE70A48BF: '出力ファイルを指定。デフォルト: reduced.ll|.bc|.mir'
# 'Specify the output filename'
H3C3BD1616514: '出力ファイル名を指定'
# 'Specify the output name of the file containing the optimization remarks. Implies -fsave-optimization-record. On Darwin platforms, this cannot be used with multiple -arch <arch> options.'
HD73FD36131DB: '最適化リマインダーを含むファイルの出力名を指定。-fsave-optimization-record を暗黙的に有効にします。Darwin プラットフォームでは、複数の -arch <arch> オプションと同時に使用できません。'
# 'Specify the overflow patterns to exclude from arithmetic sanitizer instrumentation'
H317E2D4E0BC0: '算術検証器のインストルメンテーションから除外するオーバーフローパターンを指定'
# 'Specify the path of profile data file. This is mainly for test purpose.'
HE901E0A55767: 'プロファイルデータファイルのパスを指定します。これは主にテスト用です。'
# 'Specify the path of profile remapping file. This is mainly for test purpose.'
H853E5B17061C: 'プロファイル リマッピング ファイルのパスを指定します。これは主にテスト用です。'
# 'Specify the path prefix of the MemProf dot files.'
H5392A6A236E7: 'MemProf ドット ファイルのパスプレフィックスを指定します。'
# 'Specify the path to the "safe" backend program'
HD696058226F4: '「safe」バックエンド プログラムのパスを指定します'
# 'Specify the prebuilt module path'
H3FAB39F2C50D: '事前に構築されたモジュールのパスを指定します'
# 'Specify the printf lowering scheme (AMDGPU only), allowed values are "hostcall"(printing happens during kernel execution, this scheme relies on hostcalls which require system to support pcie atomics) and "buffered"(printing happens after all kernel threads exit, this uses a printf buffer and does not rely on pcie atomic support)'
H36B6C5D95ECD: 'AMDGPU専用：printfの最適化方法を指定します。有効な値は「hostcall」（カーネル実行中に出力が行われ、PCIeアトミックをサポートするシステムが必要）と「buffered」（すべてのカーネル スレッド終了後に出力が行われ、PCIeアトミックのサポートは不要）です'
# 'Specify the profile path in PGO use compilation'
H383968EDB0F3: 'PGO 使用コンパイル時のプロファイル パスを指定します'
# 'Specify the property to collect remarks by.'
H8278427A48F9: '収集するリマーカーのプロパティを指定します。'
# 'Specify the property to group remarks by.'
HE59A5BD76AE3: 'リマーカーをグループ化するプロパティを指定します。'
# 'Specify the size in bits of an RVV vector register'
H0AB4126F0C29: 'RVVベクタレジスタのビット数を指定します'
# 'Specify the size in bits of an SVE vector register. Defaults to the vector length agnostic value of "scalable". (AArch64 only)'
H2F3DFF504736: 'SVE ベクタ レジスタのビット数を指定します。デフォルトはベクタ長に依存しない「scalable」値です。（AArch64 専用）'
# 'Specify the stackmap encoding version (default = 3)'
H7CF270813613: 'Stackmap エンコーディングのバージョンを指定します（デフォルト = 3）'
# 'Specify the target Objective-C runtime kind and version'
HFE1F1D7E8E7B: 'Objective-C ランタイムの種類とバージョンを指定します'
# 'Specify the target environment'
H62189CA73425: 'ターゲット環境を指定します'
# 'Specify the type of coverage instrumentation for Sanitizers'
HCCE91ECD2AD5: 'Sanitizers用のカバレッジ インストルメンテーションの種類を指定します'
# 'Specify the type of metadata to emit for binary analysis sanitizers'
HCEF5AB90855A: 'バイナリ分析 Sanitizers 用に発行するメタデータの種類を指定します'
# 'Specify the types of comparisons to emit GPR-only code for.'
HDBA609305F00: 'GPR だけを使用するコードを生成する比較の種類を指定します'
# 'Specify the version of the memprof format to use'
H1B82817FBBA6: '使用する memprof フォーマットのバージョンを指定します'
# 'Specify the vscale maximum. Defaults to the vector length agnostic value of "0". (AArch64/RISC-V only)'
HA66591A80BFB: 'vscale の最大値を指定します。デフォルトはベクタ長に依存しない「0」です。（AArch64/RISC-V 専用）'
# 'Specify the vscale minimum. Defaults to "1". (AArch64/RISC-V only)'
H0C205532C01D: 'vscale の最小値を指定します。デフォルトは「1」です。（AArch64/RISC-V 専用）'
# 'Specify time trace file destination'
HC99CB0CDDE38: 'タイムトレースファイルの出力先を指定します'
# 'Specify types of branches to align'
H8693C7688390: 'アライメント対象の分岐タイプを指定します'
# 'Specify types of branches to align (plus separated list of types):\njcc      indicates conditional jumps\nfused    indicates fused conditional jumps\njmp      indicates direct unconditional jumps\ncall     indicates direct and indirect calls\nret      indicates rets\nindirect indicates indirect unconditional jumps'
H3D330EC77559: 'アライメント対象の分岐タイプを指定します（タイプをプラス区切りでリスト）:\njcc      条件付きジャンプを指定\nfused    フューズされた条件付きジャンプを指定\njmp      直接的な無条件ジャンプを指定\ncall     直接/間接呼び出しを指定\nret      関数終了を指定\nindirect 間接無条件ジャンプを指定'
# 'Specify wavefront size 32 mode (AMDGPU only)'
HA9AC5ACEB8A1: 'ウェーブフロントサイズ32モードを指定（AMDGPU専用）'
# 'Specify wavefront size 64 mode (AMDGPU only)'
H33E655B3FFCB: 'ウェーブフロントサイズ64モードを指定（AMDGPU専用）'
# 'Specify where to find the compiled intrinsic modules'
H60F443A1A2B8: 'コンパイル済み_INTRINSICモジュールの検索パスを指定します'
# 'Specify which frame pointers to retain.'
H899F4C930DBE: '保持するフレームポインタの種類を指定します'
# 'Speculate that non-constant strides are unit in LAA'
HD4B90FE88764: 'LAAで非定数ストライドを単位ストライドと仮定します'
# 'Speculate unpredictable branches (default = false)'
HBDC5587A6F17: '予測不可能な分岐を仮定（既定値: false）'
# 'Speculative execution is applied only to targets with divergent branches, even if the pass was configured to apply only to all targets.'
HA74AC4F303A4: 'パス設定が全ターゲットに適用されても、分岐の収束するターゲットのみに予測実行を適用します'
# 'Speculative execution is not applied to basic blocks where the cost of the instructions to speculatively execute exceeds this limit.'
HE2B4F7F554AA: '予測実行する命令コストがこの制限を超える基本ブロックには適用されません'
# 'Speculative execution is not applied to basic blocks where the number of instructions that would not be speculatively executed exceeds this limit.'
H9EB9A3987580: '予測実行されない命令数がこの制限を超える基本ブロックには適用されません'
# 'SpeculativeJIT'
H6F038D1D3644: 'SpeculativeJIT'
# 'Speculatively execute instructions'
HF1EBCFA9992F: '命令の予測実行を有効にします'
# 'Spill Code Placement Analysis'
HC707A69CEDE9: 'スパイラコード配置解析'
# 'Spill mode for splitting live ranges'
H33C680059059: 'ライブレンジ分割用スパイラモード'
# 'Split GEPs to a variadic base and a constant offset for better CSE'
HCB9C6A238522: '定数オフセットを含むGEPを分解しCSEを改善します'
# 'Split Options'
H33A61DDF11E4: '分割オプション'
# 'Split all critical edges during PHI elimination'
H4A2C55331EC3: 'PHI除去時に全クリティカルエッジを分割します'
# 'Split all partitions'
H2671573A0660: 'すべてのパーティションを分割する'
# 'Split critical edges during machine sinking'
H4AC49C950879: 'マシン サンキング中にクリティカル エッジを分割する'
# 'Split machine functions using profile information'
HD03C9F1F9730: 'プロファイル情報を使用してマシン関数を分割する'
# 'Split marker to use for merging the ouput'
H5ED0DBD3456A: '出力を結合するために使用する分割マーカー'
# 'Split out cold basic blocks from machine functions based on profile information'
H1074CBD18EC9: 'プロファイル情報に基づいてマシン関数からコールド基本ブロックを分割する'
# 'Split out cold blocks from machine functions based on profile information.'
H59A610956F3E: 'プロファイル情報に基づいてマシン関数からコールド ブロックを分割する。'
# 'Split static data'
HAD68510283FA: '静的データを分割する'
# 'Split static data sections into hot and cold sections using profile information'
H0855E4DC6A4D: 'プロファイル情報を使用してホットとコールドのセクションに静的データ セクションを分割します'
# 'Split the input file into chunks using the given or default marker and process each chunk independently'
H630FB595F295: '指定またはデフォルトのマーカーを使用して入力ファイルをチャンクに分割し、各チャンクを独立して処理します'
# 'Split the output by Compile Units.'
H6C6E1FDA7719: 'コンパイル ユニットごとに出力を分割します。'
# 'Split the profile to two sections with one containing sample profiles with inlined functions and the other without (only meaningful for -extbinary)'
H4FBB422A3FD9: '-extbinary と組み合わせて使用するプロファイルを 2 つのセクションに分割（インライン関数を含むサンプル プロファイルを 1 つのセクション、含まないものをもう 1 つのセクション）'
# 'Split without externalizing locals'
H8A331352F2E7: 'ローカル変数の外部化なしで分割'
# "Splits all EH code and it's descendants by default."
HA93F604541F1: 'デフォルトでは、すべての EH コードとその子孫を分割します。'
# 'Stable  ABI instrumentation for sanitizer runtime. Default: Conventional'
H1B5D3202D1AE: 'sanitizer ランタイム向けの安定 ABI インストルメンテーション。デフォルト: Conventional'
# 'Stack Frame Layout'
H33A25E80B45A: 'スタック フレーム レイアウト'
# 'Stack Slot Coloring'
H85960DF4AF9A: 'スタック スロット カラーリング'
# 'StackMap Liveness Analysis'
H6CCE8B66D5C3: 'StackMap ライブネス解析'
# 'Standard converging scheduler.'
HA7AD7FEE5D0B: '標準の収束スケジューラ。'
# 'Start each pass with collecting and end it with checking of debug info preservation.'
H3F51E578F392: '各パスをデバッグ情報の保持の収集で開始し、チェックで終了します。'
# 'Start each pass with debugify and end it with check-debugify'
H2D5ADDBBEEF2: '各パスをデバッグ化で開始し、デバッグチェックで終了します'
# 'Start emitting warnings for unused driver arguments'
HE346B2A53C42: '未使用のドライバ引数に関する警告を開始'
# 'Start the pipeline with collecting and end it with checking of debug info preservation.'
HE5F5305CC00C: '収集からパイプラインを開始し、デバッグ情報の保持チェックで終了します'
# 'Start the pipeline with debugify and end it with check-debugify'
H0175081FA86E: 'debugifyからパイプラインを開始し、check-debugifyで終了'
# 'Statement-level analysis'
H08A2201C3BBE: 'ステートメントレベルの分析'
# 'Static Data Annotator'
H8F3F11306A56: '静的データアノテーション'
# 'Static Data Profile Info'
H42C5E08B9C8C: '静的データプロファイル情報'
# 'Static analyzer report output format (html|plist|plist-multi-file|plist-html|sarif|sarif-html|text).'
HA5BB1BCA30A0: '静的解析レポートの出力形式 (html|plist|plist-multi-file|plist-html|sarif|sarif-html|text)'
# 'Static scheduling'
H9688287692D9: '静的スケジューリング'
# 'Statically link the sanitizer runtime (Not supported for ASan, TSan or UBSan on darwin)'
H5D51614B7830: '静的リンカーでsanitizerランタイムをリンク (darwinでのASan、TSan、またはUBSanではサポートされていません)'
# 'Statically resolve calls to versioned functions from non-versioned callers.'
HDACBD3DAB33D: 'バージョン管理されていないコールャーからのバージョン管理された関数への呼び出しを静的に解決'
# 'Stop PCH generation after including this file.  When using a PCH, skip tokens until after this file is included.'
HEE422676F0B0: 'このファイルを含めた後にPCH生成を停止。PCHを使用する場合、このファイルが含まれるまでトークンをスキップ'
# 'Stop compilation after a specific pass'
HD6BD4366BCBC: '特定のパス後にコンパイルを停止'
# 'Stop compilation before a specific pass'
H50FA55AE29C2: '特定のパスの前にコンパイルを停止'
# 'Stop inferring nofree attribute during function-attrs pass'
HAF941AF0C8A5: 'function-attrs パス中にnofree属性の推論を停止'
# 'Stop inferring nounwind attribute during function-attrs pass'
H8B6C2FE67EDE: 'function-attrs パス中にnounwind属性の推論を停止'
# 'Stop initializing trivial automatic stack variables after the specified number of instances'
H023CB238F8AC: '指定されたインスタンス数に達した後に、単純な自動スタック変数の初期化を停止'
# 'Stop initializing trivial automatic stack variables if var size exceeds the specified number of instances (in bytes)'
HFF75ED2CDFB4: '変数のサイズが指定されたバイト数を超えた場合、単純な自動スタック変数の初期化を停止'
# 'Stop processing after parsing rules and dump state'
HC94659F6E6B6: 'ルールの解析後に処理を停止し、状態をダンプ'
# 'Stop removing an empty block if removing it will introduce more than this number of phi entries in its successor'
H9A65443D39E6: 'その削除が後続ブロックにこの数を超えるphiエントリを導入する場合、空のブロックの削除を停止'
# 'Stop scheduling after N instructions'
H9C405DA9723C: 'N命令後にスケジューリングを停止'
# 'Store string literals as writable data'
HAB4FC207616D: 'リテラル文字列を書き込み可能なデータとして保存'
# 'Store-level granularity'
H6039083A6A50: 'ストアレベルの粒度'
# 'Straight line strength reduction'
H31FF5C722167: 'ストレートラインの強度削減'
# 'Stress Options'
HB2B1AD1DE1DF: 'ストレステスト オプション'
# 'Stress test LSR IV chains'
H1CC9D49F4B69: 'LSR IV チェーンのストレステスト'
# 'Stress test ext(promotable(ld)) -> promoted(ext(ld)) optimization in CodeGenPrepare'
HB72AD83333E7: 'CodeGenPrepareでの ext(promotable(ld)) → promoted(ext(ld)) 最適化のストレステスト'
# 'Stress test instruction scheduling'
HA55B8E05F17D: '命令スケジューリングのストレステスト'
# 'Stress test store(extract) optimizations in CodeGenPrepare'
HBA93839DF706: 'CodeGenPrepareでの store(extract) 最適化のストレステスト'
# 'String Table (DEBUG_S_STRINGTABLE subsection) (not typically present in PDB file)'
H346701412AE3: '文字列テーブル（DEBUG_S_STRINGTABLE サブセクション）（PDBファイルには通常含まれません）'
# 'String to initialize the database'
H3CBC3A337427: 'データベースを初期化する文字列'
# 'Strip (or keep only, if negative) a given number of path components when emitting check metadata.'
H95EB3AD2C385: 'チェック メタデータを生成する際に、パス コンポーネントの指定された数を削除（または、負の場合保持）します。'
# 'Strip debugger symbol info from translation unit'
HE92E5C253ED7: 'デバッグ シンボル情報を翻訳単位から削除'
# 'Strip module-level named metadata'
HDD827ABBE60A: 'モジュール レベルの名前付きメタデータを削除'
# 'Strip names from Value during LTO (other than GlobalValue).'
HC04AE0DCC2F5: 'LTO中（GlobalValueを除く）Valueから名前を削除'
# 'Strip prefix of the fully qualified names'
HC496A1D3FAD4: '完全修飾名のプレフィックスを削除'
# 'Strip specified level of directory name from source path in the profile counter name for static functions.'
HB9A6EFA2E4BB: '静的関数のプロファイル カウンタ名のソースパスから、指定されたディレクトリ名のレベルを削除'
# 'Strip-mine outer loops for the loop-vectorizer to trigger'
HA84FED7AAA88: 'ループベクタライザをトリガーするために、外側のループをストリップマイン'
# 'Structure.'
H12CCB9A83FCE: '構造。'
# 'Structurize the CFG'
H86D5CD019397: 'CFG（制御フローグラフ）の構造化'
# 'Stuff'
H226D042D922D: 'その他の項目'
# 'Subprogram.'
H5A13F062C508: 'サブプログラム。'
# 'Subrange encoding information for arrays.'
H9B8612490EAE: '配列のサブレンジエンコード情報。'
# 'Summary of elements missing/added/matched/printed.'
HE867CEA332FA: '欠落/追加/一致/出力の要素の要約。'
# 'Supplement an instr profile with sample profile, to correct the profile unrepresentativeness issue. The sample profile is the input of the flag. Output will be in instr format (The flag only works with -instr)'
HB26399824318: 'サンプルプロファイルでインストプロファイルを補足し、プロファイルの不適切性問題を修正します。サンプルプロファイルはフラグの入力です。出力はインスト形式になります（フラグは-instrオプションと併用する必要があります）'
# 'Support POSIX threads in generated code'
H519A7A85C373: '生成されたコードでPOSIXスレッドをサポート'
# 'Suppress STP for AArch64'
H0D98334CA140: 'AArch64のSTPを抑制'
# 'Suppress all deprecated warnings'
HE5E64D48AF93: '非推奨の警告をすべて抑制'
# 'Suppress all linking warnings'
H012398BE48C2: 'リンク警告をすべて抑制'
# 'Suppress all warnings'
HE2E5B3B89DBD: 'すべての警告を抑制'
# 'Suppress counter promotion if exit blocks contain ret.'
H69AEA135B910: 'エクスィットブロックにretが含まれる場合、カウンタープロモーションを抑制'
# 'Suppress duplication of instrs into per-HwMode decoder tables'
HC365469D96E4: 'HwModeごとのデコーダーテーブルへのインストの複製を抑制'
# 'Suppress inlining of functions whose stack size exceeds the given value'
H25336627EFCB: 'スタックサイズが指定値を超える関数のインライン化を抑制'
# 'Suppress output of running passes (both stdout and stderr)'
H777CD18B4BD8: 'パスの実行時の出力（stdoutとstderrの両方）を抑制'
# 'Suppress rematerialization of dynamic shadow address by passing it through inline asm in prologue.'
H9476840CC1D4: 'プロローグのインラインアセンブリを通じて動的シャドウアドレスの再マテリアル化を抑制'
# 'Suppress slot sharing during stack coloring'
H734CB119B295: 'スタック着色中にスロット共有を抑制'
# 'Suppress type errors (Wasm)'
H63BEE3B3DE32: 'タイプエラーを抑制（Wasm）'
# 'Suppress verbose debugify output'
H650FEBD3E6CA: 'デバッグ出力の詳細表示を抑制'
# 'Swap target blocks of a conditional branch for MVE expander'
H6042CB5BEBAE: 'MVEエクスパンダ用に条件分岐のターゲットブロックを交換'
# 'Switch to fast cluster algorithm with the lost of some fusion opportunities'
H3997C1BEC2C0: '一部の融合機会を失う代わりに高速クラスターアルゴリズムに切り替え'
# 'Symbol ID of the symbol being queried (hex).'
H06F2A7E436A9: 'クエリ対象のシンボルのシンボルID（16進数）。'
# 'Symbol ID to look up (hex)'
H98F75068720A: '(16進数形式の)検索対象のシンボルID'
# 'Symbol Options'
HBFC1F4F0A88E: 'シンボル オプション'
# 'Symbol Rewrite Map'
H1CDA542441BA: 'シンボル リライト マップ'
# 'Symbol Type Options'
H035FC129AB6C: 'シンボル タイプ オプション'
# 'Symbol kind to use when printing symbols.'
HB4C2F9BD84AD: 'シンボルを表示する際に使用するシンボルの種類'
# 'Symbol location coverage.'
H80C30D273074: 'シンボルの位置情報のカバレッジ'
# 'Symbol remapping file'
H3423735D2CB7: 'シンボル リマッピング ファイル'
# 'Symbol to call as main entry point'
H39AD275C387D: 'メイン エントリポイントとして呼び出すシンボル'
# 'Symbol to put in the symtab in the resulting dso'
HFB4EE7AEFE5C: '結果のDSOに symtab に配置するシンボル'
# 'Symbols (DEBUG_S_SYMBOLS subsection) (not typically present in PDB file)'
HDB1B5EBB0319: 'シンボル (DEBUG_S_SYMBOLS サブセクション) (PDB ファイルには通常含まれない)'
# 'Symbols (Variable, Members, etc.).'
HE394D83CA76F: 'シンボル (変数、メンバーなど)'
# 'Symbols.'
H73E0811A7FD7: 'シンボル。'
# 'Syntax variant to use for output printing'
HDCC1F5EAEC7B: '出力表示に使用する構文のバリアント'
# 'Synthesize retain and release calls for Objective-C pointers'
H40E12820EB61: 'Objective-C ポインタの retain と release 呼び出しを合成する'
# 'System directory for configuration files'
H2B1CA8129B49: '構成ファイルのシステム ディレクトリ'
# 'SystemZ Comparison Elimination'
HA6D4515C513E: 'SystemZ 比較削除'
# 'SystemZ Copy Physregs'
HBF6729EB5D82: 'SystemZ 物理レジスタ コピー'
# 'SystemZ DAG->DAG Pattern Instruction Selection'
H66AEC705D460: 'SystemZ DAG→DAG パターン命令選択'
# 'SystemZ Instruction Shortening'
H75E7D5BFB7B2: 'SystemZ 命令短縮'
# 'SystemZ Local Dynamic TLS Access Clean-up'
H860F0223FC41: 'SystemZ ローカル動的 TLS アクセス クリーンアップ'
# 'SystemZ Long Branch'
H20A34CC2B958: 'SystemZ 長ブランチ処理'
# 'SystemZ Post Rewrite pass'
H26F388ADE65D: 'SystemZ Post Rewrite パス'
# 'SystemZ Test Data Class optimization'
H7C47CE39188C: 'SystemZ テストデータクラス最適化'
# 'TableGen LSP Language Server'
H927DAB993B40: 'TableGen LSP言語サーバー'
# 'Tail Call Elimination'
H783C2FABF530: 'テールコール除去'
# 'Tail Duplication'
H71C746D731D5: 'テール複製'
# 'Tail-folding and predication preferences over creating a scalar epilogue loop.'
HC5BDD1DF7A2D: 'Tail-foldingとpredicationの優先を、スカラーエピローグループの生成よりも選択する'
# 'Take more precise inbounds assumptions (do not scale well)'
H08762D9FA006: 'より正確なinbounds仮定を使用 (拡張性が低い)'
# 'Take raw hexadecimal bytes as input for disassembly. Whitespace is ignored'
H21819087D66E: '逆アセンブルの入力として生の16進数バイトを受け取ります。空白文字は無視されます'
# 'Takes a posix regex and prints the link graphs of all files matching that regex after fixups have been applied'
HB3F945A20F78: 'posix regexを指定し、修正が適用された後に一致するすべてのファイルのリンクグラフを出力します'
# 'Target CPU, ignored if --mtriple is not used'
H9C0D15DCF3BD: '対象CPU、--mtripleを使用しない場合は無視されます'
# 'Target Library Information'
H5C80DD9524F8: 'ターゲットライブラリ情報'
# 'Target Pass Configuration'
HE8EFE346FCF6: 'ターゲットパス構成'
# 'Target Transform Information'
H381DDCC824B8: 'ターゲット変換情報'
# 'Target a particular ABI type'
H8CB1D450BB9C: '特定のABIタイプを指定'
# 'Target a specific auxiliary cpu type'
HC63DF9647BBE: '特定の補助CPUタイプを指定'
# 'Target a specific cpu type'
HA6E72D889CDB: '特定のCPUタイプを指定'
# 'Target a specific cpu type (-mcpu=help for details)'
HB995589A2608: '特定のCPUタイプを指定 (-mcpu=helpで詳細を参照)'
# 'Target arch to assemble for, see -version for available targets'
H6A0D4D1161C4: 'アセンブル対象のアーキテクチャ、利用可能なターゲットは-versionで確認'
# 'Target architecture. See -version for available targets'
HDD6FE0D72BD5: 'ターゲットアーキテクチャ。利用可能なターゲットは-versionで確認'
# 'Target cost kind'
HDAD667E32250: 'ターゲット コストの種類'
# 'Target default float ABI type'
HEAFE690D5657: 'ターゲット デフォルト フロート ABI タイプ'
# 'Target linker version'
H57EDF14C8F4F: 'ターゲット リンカ バージョン'
# 'Target specific attributes'
H8E47E4436FE2: 'ターゲット固有の属性'
# 'Target specific attributes (-mattr=help for details)'
HAB90F22130BF: 'ターゲット固有の属性 (-mattr=help で詳細を参照)'
# 'Target specific auxiliary attributes'
H2BA14C72345A: 'ターゲット固有の付随する属性'
# 'Target triple for disassembler'
H83C90E391152: 'ディアセンブラー用のターゲット triple'
# 'Target triple to assemble for, see -version for available targets'
HC643C7A09170: 'アセンブル用のターゲット triple. 使用可能なターゲットは -version を参照してください'
# 'Target triple. See -version for available targets'
H3857DE6DE1E0: 'ターゲット triple. 使用可能なターゲットは -version を参照してください'
# 'Target triple. When present, a TargetMachine is created and TargetMachine::splitModule is used instead of the common SplitModule logic.'
H2B7CF41128A9: 'ターゲット triple. 存在する場合、TargetMachine が作成され、TargetMachine::splitModule が一般的な SplitModule ロジックの代わりに使用されます'
# 'Template Parameter.'
HF63F96014E9F: 'テンプレート パラメータ。'
# 'Template alias.'
H3C8CFAE8AE20: 'テンプレートのエイリアス。'
# 'Template arguments encoded in the template name.'
H1C3D42D15648: 'テンプレート名にエンコードされたテンプレート引数。'
# 'Template functions or specializations without host, device and global attributes have implicit host device attributes (CUDA/HIP only)'
HA4C9090C9925: '(CUDA/HIP 専用) テンプレート関数または特殊化、ホスト、デバイス、グローバル属性がない場合、暗黙のホスト デバイス属性が割り当てられます'
# 'Template pack.'
HA1E3326A0AE4: 'テンプレート パック。'
# 'Template parameters replaced by its arguments.'
H2B376AF57DB4: 'テンプレート引数によって置き換えられたテンプレート パラメータ。'
# 'Template template parameter.'
HB1F99591F368: 'テンプレート テンプレート パラメータ。'
# 'Template type parameter.'
H16F66C4F3D61: 'テンプレート型パラメータ。'
# 'Template value parameter.'
H128B1A19518C: 'テンプレート値パラメータ。'
# 'Template.'
H0518E81F03C2: 'テンプレート。'
# 'Temporary development switch used to gradually uplift SimplifyCFG into preserving DomTree,'
HBE52749BCFE7: 'DomTreeを維持するために、SimplifyCFGを段階的に向上させるための一時的な開発スイッチ'
# 'Terminate process if it loads user32.dll.'
H3BC023827DF8: 'プロセスがuser32.dllを読み込んだ場合、プロセスを終了します。'
# 'Test harness files'
HA4814F3A55AD: 'テストハーネスファイル'
# 'Text encoding'
H104683D616E5: 'テキストエンコーディング'
# 'Text output'
H722885D8D390: 'テキスト出力'
# 'Textual description of the function type to be called'
HFA8DBC9DB008: '呼び出す関数の種類のテキスト形式の説明'
# 'Textual description of the pass pipeline to run'
HE98FE702D92A: '実行するパスパイプラインのテキスト形式の説明'
# 'The CPU number that the benchmarking process should executon on'
H67AECA2CBAEE: 'ベンチマーク処理が実行されるCPU番号'
# 'The InteractiveModelRunner will echo back to stderr the data received from the host (for debugging purposes).'
HA27F90224438: 'InteractiveModelRunnerは、ホストから受け取ったデータをデバッグ目的でstderrにエコー表示します。'
# 'The LMUL to use for getRegisterBitWidth queries. Affects LMUL used by autovectorized code. Fractional LMULs are not supported.'
H065EFBB6A92E: 'getRegisterBitWidthクエリで使用するLMUL。autovectorizedコードで使用されるLMULに影響します。分数LMULはサポートされていません。'
# 'The OOO window for processor resources during scheduling.'
H7F8CE8011253: 'スケジューリング中のプロセッサリソースのアウトオブオーダーウィンドウ'
# 'The alignment to use when accessing the buffers\nDefault is unaligned\nUse 0 to disable address randomization'
H9D92202DC06A: 'バッファへのアクセス時に使用するアライメント\nデフォルトはアンアライニ\n0を使用するとアドレスのランダム化を無効にします'
# 'The amount of branches that we are willing to explore withthe exact algorithm before giving up.'
H46BDE8E006FD: '正確なアルゴリズムで探索する前に断念するまでに許容する分岐の数'
# 'The associativity of the first cache level.'
H091472E28B2B: '最初のキャッシュレベルのアソシエイティビティ'
# 'The associativity of the second cache level.'
HEE9D38673E97: '2番目のキャッシュレベルのアソシエイティビティ'
# 'The average lifetime (s) for an allocation to be considered cold'
H31CAA2FC4467: 'コールドと見なされる割り当ての平均寿命（秒）'
# 'The average number of profile counters allocated per value profiling site.'
H3EFF8568FB96: '各値プロファイルサイトごとに割り当てられたプロファイルカウンターの平均数'
# 'The base class for the ops in the dialect we are planning to emit'
HA507EEDE87C4: '発行予定の方言のオペレーションのための基底クラス'
# 'The bonus weight of users of allocas within loop when sorting profitable allocas'
HBDF3A84E4987: 'ループ内のallocasのユーザーのボーナス重み（利益の高いallocasをソートする場合）'
# 'The clause simdlen must fit the %0-bit lanes in the architectural constraints for SVE (min is 128-bit, max is 2048-bit, by steps of 128-bit)'
H637FD9B0F74C: 'SVEのアーキテクチャ制約における%0ビットレーンに適合する必要があります（最小128-bit, 最大2048-bit, 128-bitステップで指定）'
# 'The clause simdlen(1) has no effect when targeting aarch64.'
H28E8D9873AFA: 'simdlen(1)句はaarch64ターゲットでは効果がありません。'
# 'The code working set size is considered huge if the number of blocks required to reach the -profile-summary-cutoff-hot percentile exceeds this count.'
H1D058B3A0D64: '-profile-summary-cutoff-hotパーセンタイルに到達するために必要なブロック数がこのカウントを超える場合、コードの作業セットサイズは巨大と見なされます。'
# 'The code working set size is considered large if the number of blocks required to reach the -profile-summary-cutoff-hot percentile exceeds this count.'
H0799198BEFDB: '-profile-summary-cutoff-hotパーセンタイルに到達するために必要なブロック数がこのカウントを超える場合、コードの作業セットサイズは大規模と見なされます。'
# 'The coefficient used when initializing II in the window algorithm.'
H8ABBDA1465FF: '窓アルゴリズムでIIを初期化する際に使用される係数。'
# 'The compilation directory to embed in the coverage mapping.'
HC40AB6D0A1C3: '被覆マッピングに埋め込むコンパイルディレクトリ'
# 'The compilation directory to embed in the debug info'
H7AE615281122: 'デバッグ情報に埋め込むコンパイルディレクトリ'
# 'The compilation directory to embed in the debug info and coverage mapping.'
HAD4DB13A434F: 'デバッグ情報と被覆マッピングに埋め込むコンパイルディレクトリ'
# 'The cost of a histcnt instruction'
HC55AE2001899: 'histcnt命令のコスト'
# "The cost of a loop that is considered 'small' by the interleaver."
HF5F932DA0017: 'interleaverが「small」と判断するループのコスト'
# 'The cost of a step in a different basic block than the killing MemoryDef(default = 5)'
H38215D7CEF6B: 'MemoryDefの殺傷ベーシックブロックとは異なるベーシックブロックにおけるステップのコスト（デフォルト=5）'
# 'The cost of a step in the same basic block as the killing MemoryDef(default = 1)'
HA3C397AE67B6: 'MemoryDefの殺傷ベーシックブロックと同じベーシックブロックにおけるステップのコスト（デフォルト=1）'
# 'The cost of decreasing a block count by one.'
HBA666F36C915: 'ブロックのカウントを1減らすコスト。'
# "The cost of decreasing a block's count by one."
H9FCF3A04FBC3: 'ブロックのカウントを1減らすコスト。'
# 'The cost of decreasing a jump count by one.'
H01994AC78D25: 'ジャンプカウントを1減らすコスト。'
# "The cost of decreasing the entry block's count by one."
HCE46A7F305CE: 'エントリーブロックのカウントを1減らすコスト。'
# 'The cost of increasing a block count by one.'
HAE44BF594D73: 'ブロックのカウントを1増やすコスト。'
# "The cost of increasing a block's count by one."
H35BD66941EB2: 'ブロックのカウントを1増やすコスト。'
# 'The cost of increasing a count of zero-weight block by one.'
H15D3659B2D6D: '零ウェイトブロックのカウントを1増やすコスト。'
# 'The cost of increasing a jump count by one.'
HBEF3551C10D0: 'ジャンプカウントを1増やすコスト。'
# 'The cost of increasing an unknown block count by one.'
H70FD1895A2F3: '未知のブロックのカウントを1増やすコスト。'
# "The cost of increasing an unknown block's count by one."
H058C9FB6BA79: '不明ブロックのカウントを1増加させるコスト。'
# 'The cost of increasing an unknown fall-through jump count by one.'
H8E3789B6B289: '不明なfall-throughジャンプのカウントを1増加させるコスト。'
# 'The cost of increasing an unknown jump count by one.'
H08B8AF9F180A: '不明なジャンプのカウントを1増加させるコスト。'
# "The cost of increasing the entry block's count by one."
H199FDB30E747: 'エントリーブロックのカウントを1増加させるコスト。'
# 'The cost threshold for call sites that get inlined without the cost-benefit analysis'
HBDFEA6BEED2A: 'コスト便益分析なしでインライン化されるコールサイトのコストしきい値'
# 'The cost threshold for loop unrolling'
H4E87362F1A39: 'ループ展開のコストしきい値'
# 'The cost threshold for loop unrolling when optimizing for size'
H3ADA25107614: 'サイズ最適化時にループ展開のコストしきい値'
# 'The cost threshold for partial loop unrolling'
H467DE32D1CDF: '部分的なループ展開のコストしきい値'
# 'The cost threshold for unswitching a loop.'
HEDD158AF26CA: 'ループのunswitchingのコストしきい値'
# 'The current shard index'
H876C17A38CA1: '現在のシャードインデックス'
# 'The default 2nd-level tile size (if not enough were provided by --polly-2nd-level-tile-sizes)'
H1853EDCB107B: 'デフォルトの2nd-level tileサイズ（--polly-2nd-level-tile-sizesで十分提供されなかった場合）'
# 'The default address space is assumed as the flat address space. This is mainly for test purpose.'
HE348DDF306A6: 'デフォルトのアドレス空間はflatアドレス空間と見なされます。これは主にテスト用です。'
# 'The default associativity of the first cache level (if not enough were provided by the TargetTransformInfo).'
HCCD8A81B4765: '1段目のキャッシュのデフォルトアソシエーション（TargetTransformInfoで十分提供されなかった場合）'
# 'The default associativity of the second cache level (if not enough were provided by the TargetTransformInfo).'
HEEAD0D6C75FB: '2段目のキャッシュのデフォルトアソシエーション（TargetTransformInfoで十分提供されなかった場合）'
# 'The default maximum header size for automatic loop rotation'
HF0260F4FDAA5: '自動ループ回転のためのデフォルトのヘッダーサイズ'
# 'The default memprof options'
H38DAB40B2AAC: 'デフォルトのmemprofオプション'
# 'The default register tile size (if not enough were provided by --polly-register-tile-sizes)'
H64576F36AC63: 'レジスタタイルサイズのデフォルト値（--polly-register-tile-sizesで十分提供されなかった場合）'
# 'The default size of the first cache level specified in bytes (if not enough were provided by the TargetTransformInfo).'
H868C869C4E16: 'バイト単位で指定された1段目のキャッシュのデフォルトサイズ（TargetTransformInfoで十分提供されなかった場合）'
# 'The default size of the second cache level specified in bytes (if not enough were provided by the TargetTransformInfo).'
HD12A54581382: 'バイト単位で指定された2段目のキャッシュのデフォルトサイズ（TargetTransformInfoで十分提供されなかった場合）'
# 'The default tile size (if not enough were provided by --polly-tile-sizes)'
HE4A483AAF938: 'タイルサイズのデフォルト値（--polly-tile-sizesで十分提供されなかった場合）'
# 'The desired fields order.'
HFD5615C7395D: '必要とするフィールドの順序。'
# 'The dialect to gen for'
H28E806FCDC03: '生成対象の方言'
# 'The dialect to run the generator for'
H6FB81B13F4F4: '生成ツールを実行する対象の方言'
# 'The directory to import the .jscop files from.'
H46C31664F90D: 'インポートする.jscopファイルのディレクトリ。'
# 'The directory which holds the compiler resource files'
HD211B444AC1B: 'コンパイラのリソースファイルを格納するディレクトリ。'
# 'The element type include parents in its name.'
H2A080E537B74: '要素タイプの名前に親を含む。'
# 'The estimated size of the generated function (# of instrs)'
HF9641D0FB6D1: '生成された関数の推定サイズ（命令数）'
# 'The exception model'
HE9B3D391FF5A: '例外モデル'
# 'The file offset to explain'
HBBF973A12DBA: '説明対象のファイルオフセット'
# 'The file to write the stream to'
HCE306C17C319: 'ストリームを書き込むファイル'
# 'The float ABI to use'
HD1594C861A1C: '使用するfloat ABI'
# 'The format of the remarks.'
H4E4CD6B16734: 'リマーカの形式。'
# 'The format that output stacks should be output in. Only applies with all-stacks.'
H212557A1C0DC: '出力スタックを出力する形式。all-stacksと併用時のみ有効。'
# 'The format used for serializing remarks (default: YAML)'
H5541A330FC11: 'リマーカをシリアル化する形式（デフォルト: YAML）'
# 'The function to be called'
H3E644E558FC4: '呼び出す関数'
# 'The gcc binary to use.'
H0F09D1C4ABDE: '使用するgccバイナリ。'
# 'The index or name of the stream whose contents to export'
H516360D4E007: 'エクスポートするストリームの内容のインデックスまたは名前'
# 'The isl scheduling optimizer'
H0188CDF20DCD: 'islスケジューリング最適化'
# 'The kind of context sensitive profile guided optimization'
H057E88E7BF63: 'コンテキスト依存のプロファイルガイド最適化の種類'
# 'The kind of dependence analysis to use'
HAC9C6B2E0446: '使用する依存関係解析の種類'
# 'The kind of profile guided optimization'
H930EACDC046E: 'プロファイラー駆動最適化の種類'
# 'The level of dependence analysis'
HDB7D1F3D8221: '依存関係分析のレベル'
# 'The limit on recursion depth for LSRs setup cost'
H429ADCFB8F2B: 'LSRsのセットアップコストに対する再帰深度の制限'
# 'The limit to use while constructing the DAG prior to scheduling, at which point a trade-off is made to avoid excessive compile time.'
H7C463E6FF16B: 'スケジューリング前のDAG構築時に使用する制限。ここで、過剰なコンパイル時間を避けるため、トレードオフが行われます。'
# 'The list of function names in which Emscripten-style exception handling is enabled (see emscripten EMSCRIPTEN_CATCHING_ALLOWED options)'
H0AFF9B181379: 'Emscriptenスタイルの例外処理が有効な関数名のリスト（emscriptenのEMSCRIPTEN_CATCHING_ALLOWEDオプションを参照）'
# 'The list of the names of classes being moved, e.g. "Foo,a::Foo,b::Foo".'
HC13468BE141E: '移動されているクラスの名前のリスト（例: "Foo,a::Foo,b::Foo"）'
# 'The lower bound of size growth limit for proirity-based sample profile loader inlining.'
HA4426ABB67AB: '優先度に基づくサンプルプロファイラー読み込みインラインのサイズ増加制限の下限'
# 'The lower limit of the difference between best II and base II in the window algorithm. If the difference is smaller than this lower limit, window scheduling will not be performed.'
H2D09F1B7EEED: '窓アルゴリズムにおける最良IIとベースIIの差の下限。この下限値未満の場合、窓スケジューリングは実行されません。'
# 'The lower limit of the scheduling region in the window algorithm.'
H40693E0BEF44: '窓アルゴリズムにおけるスケジューリング領域の下限'
# 'The max number of exiting blocks of a loop to allow  speculative counter promotion'
H126EBD7EDF69: '推測カウンタープロモーションを許可するループの出口ブロックの最大数'
# 'The max number of instructions to consider hoisting loads over (the algorithm is quadratic over this number)'
HB921741F8462: 'ロードを持ち上げる際の考慮対象となる命令の最大数（アルゴリズムはこの数の2乗に比例します）'
# 'The max number of iteration for converge'
HD528CDF78026: '収束のための最大反復回数'
# 'The max of trip count upper bound that is considered in unrolling'
HD5BFA5564179: 'アンロール時に考慮されるトリップカウントの上限値の最大'
# 'The max version for the optimized memory  intrinsic calls'
H2E88F9E75F60: '最適化メモリ内蔵コールの最大バージョン'
# 'The maximal coefficient allowed (-1 is unlimited)'
H09B28C36A559: '許可される最大係数（-1は無制限を表します）'
# 'The maximal constant term allowed (-1 is unlimited)'
HF9153E8F373E: '許可される最大定数項（-1は無制限を表します）'
# 'The maximal number of arrays to compare in each alias group.'
HE46CCE04E50E: '各エイリアスグループで比較する配列の最大数'
# 'The maximal number of disjunts allowed in memory accesses to to build RTCs.'
H810D09DBDCF0: 'RTCを構築する際のメモリアクセスにおける許可される最大disjuncts数'
# 'The maximal number of parameters allowed in RTCs.'
HD93322BFBD09: 'RTCで許可されるパラメーターの最大数'
# "The maximum 'boost' (represented as a percentage >= 100) applied to the threshold when aggressively unrolling a loop due to the dynamic cost savings. If completely unrolling a loop will reduce the total runtime from X to Y, we boost the loop unroll threshold to DefaultThreshold*std::min(MaxPercentThresholdBoost, X/Y). This limit avoids excessive code bloat."
H02A5B75E496D: '最大のブースト（100%以上の百分率で表される）を、動的コスト削減によりループを積極的にアンロールする際の閾値に適用します。ループを完全にアンロールすると実行時間XがYに削減される場合、ループアンロール閾値をDefaultThreshold*std::min(MaxPercentThresholdBoost, X/Y)にブーストします。この制限はコードの過剰増加を防ぎます。'
# 'The maximum LMUL value to use for fixed length vectors. Fractional LMUL values are not supported.'
H8B177E0FA80A: '固定長ベクタ用に使用する最大LMUL値。分数LMUL値はサポートされていません。'
# 'The maximum allowed number of runtime memory checks'
HF580EDA4AA2E: 'ランタイムメモリチェックの最大許可数'
# 'The maximum cost used for building integers.'
H61DA215B1301: '整数構築に使用する最大コスト'
# 'The maximum distance (in bytes) of a backward jump for ExtTSP'
H1AADC32AA7A5: 'ExtTSPの後方ジャンプにおける最大距離（バイト単位）'
# 'The maximum distance (in bytes) of a forward jump for ExtTSP'
H8BF30ACF7ADE: 'ExtTSPの前方ジャンプにおける最大距離（バイト単位）'
# 'The maximum distance (in bytes) of backward jumps for ExtTSP value'
H7CD48ED835E9: 'ExtTSPの後方ジャンプにおける最大距離（バイト単位）の値'
# 'The maximum interleave count to use when interleaving a scalar reduction in a nested loop.'
H672121274D43: 'ネストループ内でスカラーリダクションをインターリーブする際の最大インターリーブ数'
# 'The maximum length of a constant string for a builtin string cmp call eligible for inlining. The default value is 3.'
H6551F5EAB050: 'インライン化対象のビルトイン文字列比較コール用の定数文字列の最大長。デフォルト値は3です。'
# 'The maximum length of a constant string to inline a memchr call.'
HAAA048CEEC02: 'memchrコールをインライン化する定数文字列の最大長'
# 'The maximum length of a single temporal profile trace (default: 10000)'
HFAF4CED9A0E5: '単一の一時プロファイルトレースの最大長（デフォルト: 10000）'
# 'The maximum levels the DFS-based missing frame search should go with'
H45092EF73D81: 'DFSベースの欠落フレーム検索で到達する最大レベル数'
# 'The maximum look-ahead depth for operand reordering scores'
H3909DC008995: 'オペランド順序再配置スコアのための最大先読み深度'
# 'The maximum look-ahead depth for searching best rooting option'
H23AE19C8EFE0: '最適なルーティングオプション探索のための最大先読み深度'
# 'The maximum nesting depth allowed for assembly macros.'
H59D58A80D82C: 'アセンブリマクロのネスト深度の最大許可値'
# 'The maximum number candidates that only partially overwrite the killing MemoryDef to consider (default = 5)'
HF74C3F17FA82: '部分的に killing MemoryDef を上書きする候補の最大数（デフォルト = 5）'
# 'The maximum number of SCEV checks allowed for Loop Distribution'
H6ED62802FFA5: 'ループ分布におけるSCEVチェックの最大許可数'
# 'The maximum number of SCEV checks allowed for Loop Distribution for loop marked with #pragma clang loop distribute(enable)'
H4DE7DF87A45B: '#pragma clang loop distribute(enable)でマークされたループに対するループ分布のSCEVチェック最大数'
# 'The maximum number of SCEV checks allowed for Loop Load Elimination'
H7F641B62EEBD: 'ループロード消去におけるSCEVチェックの最大許可数'
# 'The maximum number of SCEV checks allowed with a vectorize(enable) pragma'
H4BEEB9147A41: 'ベクテクトリゼーションを有効にする pragma で許可される SCEV チェックの最大数'
# 'The maximum number of SCEV checks allowed.'
HAB10FFD86827: 'SCEVチェックの許可最大数'
# 'The maximum number of blocks to check when trying to prove that all paths to an exit go through a killing block (default = 50)'
HE588309A8379: 'exitブロックに至るすべてのパスが殺傷ブロックを通るかどうかを証明する際にチェックするブロックの最大数（デフォルト=50）'
# 'The maximum number of callsites in a function, above which stale profile matching will be skipped.'
H22730C5AA352: '関数内のcallsitesの最大数。この数を超える場合、古いプロファイルの一致をスキップします。'
# 'The maximum number of clones allowed for a single function specialization'
H9DEE4E0B8275: '特殊化された単一関数に対するclonesの最大数'
# 'The maximum number of functions to track per lattice value'
HCD37A486700C: '各格子値ごとに追跡する関数の最大数'
# 'The maximum number of heap allocations to consider in one function before skipping (to save compilation time). Set to 0 for no limit.'
H9E920C5F07AD: '1つの関数内で考慮するヒープ割り当ての最大数。0に設定すると制限なし。'
# 'The maximum number of incoming values a PHI node can have to be considered during the specialization bonus estimation'
H03E2B05D3E4E: 'specialization bonus推定中に考慮されるPHIノードのincoming valuesの最大数'
# 'The maximum number of instructions considered for cycle sinking.'
HEC82079C9F71: 'サイクルシンキング用に考慮される命令の最大数'
# 'The maximum number of iterations allowed when searching for transitive phis'
H0F558354650E: '転移PHIを検索する際のイテレーションの最大回数'
# 'The maximum number of iterations function specialization is run'
H8854F37807C4: '関数の特殊化が実行される最大回数'
# 'The maximum number of parameters allowed when merging functions.'
H24D089F01734: '関数をマージする際のパラメータの最大数'
# 'The maximum number of predecessors a basic block can have to be considered during the estimation of dead code'
HFD5552B5CF15: 'デッドコードの推定中に考慮される基本ブロックのpredecessorsの最大数'
# 'The maximum number of scheduling group conflicts which we attempt to solve with the exponential time exact solver. Problem sizes greater than this willbe solved by the less accurate greedy algorithm. Selecting solver by size is superseded by manually selecting the solver (e.g. by amdgpu-igrouplp-exact-solver'
H071D666725DB: 'スケジューリンググループの衝突で、指数時間の正確なソルバーで解決しようとする最大数。これより大きいサイズの問題は、精度の低いグリーディアルゴリズムで解決します。サイズによるソルバーの選択は、手動でソルバーを指定（例: amdgpu-igrouplp-exact-solver）した場合に上書きされます。'
# 'The maximum number of steps while walking upwards to find MemoryDefs that may be killed (default = 90)'
HA207F5C7ADD1: 'MemoryDefsが殺されているかどうかを検出するために上方向に移動する際の最大ステップ数（デフォルト=90）'
# 'The maximum number of stored temporal profile traces (default: 100)'
H6A4CCB113506: '保存される一時的なプロファイルトレースの最大数（デフォルト:100）'
# 'The maximum number of stores/phis MemorySSAwill consider trying to walk past (default = 100)'
H0C4FBDD67710: 'MemorySSAが通過試行で考慮するstores/phisの最大数（デフォルト=100）'
# 'The maximum number of times a live range can be evicted before preventing it from being evicted'
HEF28AF0C80C6: 'ライブレンジが強制排除される最大回数。この回数を超えると、強制排除が禁止されます'
# 'The maximum number of times the analyzer will go through a loop'
H82DC4EFFB765: 'analyerがループを通過する最大回数'
# 'The maximum number of vtable for the last candidate.'
H839DD45E9E74: '最後の候補のvtableの最大数'
# 'The maximum number of warnings to emit when correlating profile from debug info (0 = no limit)'
H710123CD3CA7: 'デバッグ情報からのプロファイル相関時に発行する警告の最大数（0=無制限）'
# 'The maximum ratio between densities of two chains for merging'
H459D99ED8D7D: 'マージする2つのチェーンの密度比の最大値'
# "The maximum size of a callee that get's inlined without sufficient cycle savings"
H37B172BFF744: '十分なサイクルの節約がない場合にインライン化される呼び出し先の最大サイズ'
# 'The maximum size of a chain to apply splitting'
H74E01FDFE4C4: '分割を適用するチェーンの最大サイズ'
# 'The maximum size of a chain to create'
H29DFAD1C81AC: '作成するチェーンの最大サイズ'
# 'The maximum size of a function to consider for inference.'
HEC9218936482: '推論の対象とする関数の最大サイズ'
# 'The maximum size of an object in the sdata section'
HE9CFD8856EDF: 'sdataセクション内のオブジェクトの最大サイズ'
# 'The maximum size to use in sweep-mode'
HC4DABE2321EB: 'スウィープモードで使用する最大サイズ'
# 'The maximum stride, considered to be profitable.'
H091F45C95DD9: '利益があると見なされるストライドの最大値'
# 'The maximum total number of memory locations alias sets may contain before degradation'
H926FBF01198C: '劣化する前のエイリアスセットが含めることができるメモリ場所の総最大数'
# 'The minimal number of cycles between issuing two dependent consecutive vector fused multiply-add instructions.'
H4AA5B2DBB66A: '依存する連続したベクターフューズされた乗算加算命令を発行する間の最小サイクル数'
# 'The minimal number of per-loop instructions before a single loop region is considered profitable'
H4CE0D632999A: '単一ループ領域が利益があると見なされる前のループごとの最小命令数'
# 'The minimum TotalLifetimeAccessDensity / AllocCount for an allocation to be considered hot'
HA94E6199F898: '割り当てがホットと見なされるためのTotalLifetimeAccessDensity / AllocCountの最小値'
# 'The minimum count to optimize memory intrinsic calls'
HEF63EC815D8B: 'メモリ固有の呼び出しを最適化するための最小回数'
# 'The minimum instruction count required when merging functions.'
HB052AF91D102: '関数をマージする際に必要な最小命令数'
# 'The minimum number of arguments a function call must have before it is considered having many arguments.'
H384F6CF79650: '多くの引数を持っていると見なされる前の関数呼び出しの最小引数数'
# 'The minimum number of basic blocks required for a function to run stale profile call graph matching.'
H6DFC7FF9B6F4: '古いプロファイル呼び出しグラフマッチングを実行するために関数が必要とする基本ブロックの最小数'
# 'The minimum number of call anchors required for a function to run stale profile call graph matching.'
HA0900373C45C: '古いプロファイル呼び出しグラフマッチングを実行するために関数が必要とする呼び出しアンカーの最小数'
# 'The minimum number of instructions a basic block should contain before being considered big.'
H35A15684714E: '大きな基本ブロックと見なされる前の基本ブロックが含むべき最小命令数'
# 'The minimum number of instructions a basic block should contain before being considered medium-sized.'
HE3CFEDACCE84: '中程度のサイズの基本ブロックと見なされる前の基本ブロックが含むべき最小命令数'
# 'The minimum number of instructions that are outlined in a frame helper (default = 2)'
HDCE9324580BB: 'フレームヘルパーに要約される命令の最小数 (デフォルト = 2)'
# 'The minimum number of instructions that should be included in the snippet'
HD8B3E130AB22: 'スニペットに含められるべき命令の最小数'
# 'The minimum number of loads, which should be considered strided, if the stride is > 1 or is runtime value'
HA691E257E6C6: 'ストライドが1より大きいまたはランタイム値の場合、ストライドとして考慮されるべき読み出し命令の最小数'
# 'The minimum size in bytes before an outlining candidate is accepted'
H382DFDE541E3: '要約候補が受け入れられる前のバイト単位の最小サイズ'
# 'The minimum size in bytes of each global that should considered in merging.'
HAE0FA4D9E816: 'マージ時に考慮されるべき各グローバルのバイト単位の最小サイズ'
# 'The minimum size to use in sweep-mode'
HA2F6EC5B505C: 'スイープモードで使用する最小サイズ'
# 'The model being trained for register allocation eviction'
H7FEA0D631D24: 'レジスタ割り当ての排出に使用されるトレーニング中のモデル'
# 'The model being trained for register allocation priority'
H417CF14D5A6E: 'レジスタ割り当ての優先度に使用されるトレーニング中のモデル'
# 'The name for this study'
H400FDCCEAC14: 'このスタディの名前'
# 'The name of a function (or its substring) whose CFG is viewed/printed.'
HD3E3246593FE: 'CFGが表示/印刷される関数 (またはその部分文字列) の名前'
# 'The name of a validation counter to run concurrently with the main counter to validate benchmarking assumptions'
HABCFB9B683CF: 'ベンチマーク仮定を検証するためにメインカウンターと並列に実行する検証カウンターの名前'
# 'The name of the ABI to be targeted from the backend.'
H3EC72F95FC35: 'バックエンドから対象とするABIの名前'
# 'The name of the distribution to use'
HF09A01C5BE8E: '使用するディストリビューションの名前'
# 'The name of the executor to use.'
H9A67A8D34CB5: '使用するエグゼキューターの名前'
# "The name of the predefined style used as a\nfallback in case clang-format is invoked with\n-style=file, but can not find the .clang-format\nfile to use. Defaults to 'LLVM'.\nUse -fallback-style=none to skip formatting."
H605E77115F2D: "clang-formatが-style=fileで呼び出された場合、.clang-formatファイルが見つからない場合に使用する事前定義されたスタイルの名前。\nデフォルトは'LLVM'です。\nフォーマットをスキップするには-fallback-style=noneを使用してください。"
# 'The name of the struct/class.'
HA728CE8CB2EB: '構造体/クラスの名前'
# 'The name of this group of passes'
HE53A929D4575: 'このパスグループの名前'
# 'The number of MemoryDefs we consider as candidates to eliminated other stores per basic block (default = 5000)'
HB4E81F98BD76: '各基本ブロックあたり、他のストアを排除する候補として考慮されるMemoryDefsの数 (デフォルト = 5000)'
# 'The number of benchmarks run to perform'
H643296C3A4C1: '実行するベンチマークの数'
# 'The number of blocks to scan during memory dependency analysis (default = 200)'
HD2242DBDE5D7: 'メモリ依存関係分析中にスキャンするブロック数（デフォルト = 200）'
# 'The number of instructions to scan in a block in memory dependency analysis (default = 100)'
H2BC6010D3D27: 'ブロック内のメモリ依存関係分析中にスキャンする命令数（デフォルト = 100）'
# 'The number of instructions to search for a redundant dmb'
HD7126DC70D5E: '冗長なdmbを検索するために探索する命令数'
# 'The number of loads per basic block for inline expansion of memcmp that is only being compared against zero.'
HE7402F9BFD73: 'ゼロと比較するためのmemcmpのインライン展開用、基本ブロックあたりのロード数'
# 'The number of loop iterations to strip-mine for pre-vectorization'
H73D394A3273E: 'プリベクタライゼーションのためのループ反復をstrip-mineする回数'
# 'The number of memory instructions to scan for dead store elimination (default = 150)'
H0D792B752EF6: 'デッドストア除去のためのメモリ命令をスキャンする数（デフォルト = 150）'
# 'The number of precise steps between two approximating iterations. (A value of -1 schedules another approximation stage before the actual dead code elimination.'
H795458185A22: '2つの近似反復間の正確なステップ数。-1の場合、実際のデッドコード除去の前に別の近似段階がスケジュールされます。'
# 'The number of predecessors to search for a stronger condition to use to thread over a weaker condition'
H7527D41A84C6: 'より強い条件を検索するために探索するプレデケッサーの数'
# 'The number of searches per loop in the window algorithm. 0 means no search number limit.'
H1DDD94D0908A: '窓アルゴリズムにおけるループごとの検索回数。0の場合、検索回数の制限なし。'
# 'The number of shards into which the op classes will be divided'
H2AD8480DFFBC: 'オペレーションクラスが分割されるシャードの数'
# 'The number of threads used to process all files in parallel. Set to 0 for hardware concurrency. This flag only applies to all-TUs.'
H14270C0E6B74: '並列処理に使用するスレッド数。0の場合、ハードウェアの並列性に合わせます。このフラグはall-TUsのみに適用されます。'
# 'The number of times to repeat measurements on the benchmark k before aggregating the results'
HEB3E720640C3: 'ベンチマークkに対して結果を集約する前に測定を繰り返す回数'
# 'The option is used to turn on/off warnings about hash mismatch for comdat or weak functions.'
HB9E7F6492359: 'comdatまたはweak関数のハッシュ不一致に関する警告を有効/無効にするオプション'
# 'The option to specify the name of the function whose CFG will be displayed.'
H14BF30CA9694: '表示する制御フローグラフ（CFG）を持つ関数の名前を指定するオプション'
# 'The option to specify the name of the function whose block frequency info is printed.'
H669D97AE9C69: 'ブロック頻度情報を表示する関数の名前を指定するオプション'
# 'The option to specify the name of the function whose branch probability info is printed.'
H64FA83ADF33F: '分岐確率情報を表示する関数の名前を指定するオプション'
# 'The option to specify the name of the functions to verify.'
H99F22C3FC88F: '検証対象の関数の名前を指定するオプション'
# 'The overhead cost associated with each function call when merging functions.'
HFC522517EF09: '関数をマージする際の各関数呼び出しに関連するオーバーヘッドコスト'
# 'The overhead cost associated with each instruction when lowering to machine instruction.'
H77BF5CB5FA41: 'マシン命令に変換する際の各命令に関連するオーバーヘッドコスト'
# 'The overhead cost associated with each parameter when merging functions.'
H1DB7993015A4: '関数をマージする際、各パラメータに関連するオーバーヘッドコスト'
# 'The page size of the target in bytes'
H1B53A7D2781D: 'ターゲットのページサイズ（バイト単位）'
# 'The percentage threshold against remaining unpromoted indirect call count for the promotion'
HE86B36D2F491: 'プロモーションのための未プロモートの間接呼び出しの残り件数に対するパーセンテージしきい値'
# 'The percentage threshold against remaining unpromoted indirect call count for the promotion for calls'
H781076CED89A: 'プロモーションのための呼び出しに対する未プロモートの間接呼び出しの残り件数に対するパーセンテージしきい値'
# 'The percentage threshold against remaining unpromoted indirect call count for the promotion for jump tables'
H136B41571D6C: 'ジャンプテーブルに対するプロモーションのための未プロモートの間接呼び出しの残り件数に対するパーセンテージしきい値'
# 'The percentage threshold against total count for the promotion'
H6676D5E1FF86: 'プロモーションのための総件数に対するパーセンテージしきい値'
# 'The percentage threshold against total count for the promotion for calls'
H48EACF9E7526: 'プロモーションのための呼び出しに対する総件数に対するパーセンテージしきい値'
# 'The percentage threshold against total count for the promotion for jump tables'
HA1920C4CE7DC: 'ジャンプテーブルに対するプロモーションのための総件数に対するパーセンテージしきい値'
# 'The percentage threshold for the memory intrinsic calls optimization'
HED02E6485AF5: 'メモリ固有の呼び出しの最適化に対するパーセンテージしきい値'
# 'The percentage threshold of vtable-count / function-count for cost-benefit analysis.'
H65D337CD6C45: 'コスト便益分析におけるvtable-count / function-countのパーセンテージしきい値'
# 'The position of the cursor when invoking\nclang-format from an editor integration'
H2456492C399B: 'エディタ統合からclang-formatを起動する際のカーソルの位置'
# 'The power exponent for the distance-based locality'
HE2E30EB8297B: '距離に基づくローカリティのためのべき指数'
# 'The prefix of the dialect extension'
HB374D232EB61: '方言拡張のプレフィックス'
# 'The prefix to use for this group of passes. The form will be mlirCreate<prefix><passname>, the prefix can avoid conflicts across libraries.'
HDCE2477640BC: 'このパスのグループに使用するプレフィックス。形式はmlirCreate<prefix><passname>となり、プレフィックスはライブラリ間での衝突を回避するために使用されます。'
# 'The prefix used for the CFG dot file names.'
H3299C4982B02: 'CFG dot ファイル名に使用されるプレフィックス'
# 'The prefix used for the CallGraph dot file names.'
HAC819E10CA1B: 'コールグラフ dot ファイル名に使用されるプレフィックス'
# 'The prefix used for the DDG dot file names.'
HF593C1E1F184: 'DDG dot ファイル名に使用されるプレフィックス'
# 'The prefix used for the Machine CFG dot file names.'
H54988740C957: 'マシン CFG dot ファイル名に使用されるプレフィックス'
# 'The probability of a guard failing is assumed to be the reciprocal of this value (default = 1 << 20)'
H54F7AFA0E05B: 'guardの失敗確率は、この値の逆数と仮定されます（デフォルト = 1 << 20）'
# 'The probability threshold of enabling branch hint.'
HDA416C9E705B: '分岐ヒントを有効にするための確率閾値'
# 'The profile guided size optimization profile summary cutoff for instrumentation profile.'
H416C25DD1085: 'インストルメンテーションプロファイル用のプロファイルガイド型サイズ最適化プロファイルサマリーカットオフ'
# 'The profile guided size optimization profile summary cutoff for sample profile.'
H7CFAC61196B3: 'サンプルプロファイル用のプロファイルガイド型サイズ最適化プロファイルサマリーカットオフ'
# 'The ratio of searches per loop in the window algorithm. 100 means search all positions in the loop, while 0 means not performing any search.'
H69F36D760102: '窓関数アルゴリズムにおけるループごとの探索回数の比率。100はループ内の全位置を探索を意味し、0は探索を行わないことを示します'
# 'The relative/absolute file path of new cc.'
HE0F45871CC31: '新しいccへの相対/絶対ファイルパス'
# 'The relative/absolute file path of new header.'
H4D4C2CCB6DC7: '新しいヘッダーファイルへの相対/絶対ファイルパス'
# 'The relative/absolute file path of old cc.'
H9627E5223A5E: '古いccへの相対/絶対ファイルパス'
# 'The relative/absolute file path of old header.'
H13E40B3B27E1: '古いヘッダーファイルへの相対/絶対ファイルパス'
# 'The relocation model to use'
H8DE955C1B327: '使用するリロケーションモデル'
# 'The sample period (nbranches/sample), used for LBR sampling'
H61D3CFB88363: 'LBRサンプリングに使用するサンプル周期（nbranches/sample）'
# 'The scale factor for the frequency-based locality'
H4C2907D8364D: '頻度ベースのローカリティのスケーリング係数'
# 'The scale factor used to scale the working set size of the partial sample profile along with the partial profile ratio. This includes the factor of the profile counter per block and the factor to scale the working set size to use the same shared thresholds as PGO.'
H7BF4A788068D: '部分プロファイル比と共に部分サンプルプロファイルのワークセットサイズをスケーリングする係数。ブロックごとのプロファイルカウンタ係数と共有しきい値を使用するためのワークセットスケーリング係数を含みます'
# 'The seed used by the randomize structure layout feature'
H3D8BA8E60ECF: '構造体配置ランダム化機能で使用するシード値'
# 'The selected source range in which the refactoring should be initiated (<file>:<line>:<column>-<line>:<column> or <file>:<line>:<column>)'
H9B806B9A88F2: 'リファクタリングを開始する選択ソース範囲（<file>:<line>:<column>-<line>:<column>または<file>:<line>:<column>形式）'
# 'The size growth ratio limit for proirity-based sample profile loader inlining.'
H93A8BBE0A03D: 'プライオリティベースのサンプルプロファイルローダーインラインのサイズ増加率限界'
# "The size in bits of a vector register (if not set, this information is taken from LLVM's target information."
H4457D4EEB097: 'ベクタレジスタのビット数（設定されていない場合、LLVMのターゲット情報から取得されます）'
# 'The size of a line in the cache'
H3FC377B654FB: 'キャッシュのラインサイズ'
# 'The size of the cache'
H1AFA9403E784: 'キャッシュのサイズ'
# 'The size of the first cache level specified in bytes.'
H79C5863504EE: 'バイト単位で指定された最初のキャッシュレベルのサイズ'
# 'The size of the first level cache line size specified in bytes.'
H0A19D3F7EF60: 'バイト単位で指定された最初のレベルのキャッシュラインのサイズ'
# 'The size of the second level specified in bytes.'
HE64C9129467C: 'バイト単位で指定された2段目のキャッシュのサイズ'
# 'The string to embed in the .LLVM.command.line section.'
H96651B0831DF: '.LLVM.command.lineセクションに埋め込む文字列'
# 'The string to embed in the Dwarf debug AT_producer record.'
H309333DFFAC0: 'DWARFデバッグAT_producerレコードに埋め込む文字列'
# 'The string to embed in the Dwarf debug flags record.'
H8A887C2C292E: 'DWARFデバッグのフラグレコードに埋め込む文字列'
# 'The style name used for reformatting.'
H6C1DBF661954: '再整形に使用するスタイル名'
# 'The style name used for reformatting. Default is "llvm"'
H6E46319C3C34: '再整形に使用するスタイル名。デフォルトは"llvm"'
# 'The summary file to use for function importing.'
H956C0535484D: '関数インポートに使用するサマリーファイル'
# 'The target Objective-C runtime supports ARC weak operations'
HDFF376EEF6B3: '対象のObjective-CランタイムがARCの弱い操作をサポート'
# 'The text prefix to use for cold basic block clusters'
H9A41E3E09F36: 'Coldベーシックブロッククラスターに使用するテキストプレフィックス'
# "The thread model to use. Defaults to 'posix')"
HBBA4CDE4A320: "使用するスレッドモデル。デフォルトは'posix'です"
# 'The threshold (unit M) for flushing LLVM bitcode.'
H38AA697B02D6: 'LLVMビットコードをフラッシュする閾値（単位：M）'
# 'The threshold for fast cluster'
HC068F875B090: '高速クラスターの閾値'
# 'The threshold for splitting a virtual register with a hint, in percentage'
H722FAD4D0C5E: 'ヒント付き仮想レジスタを分割するための閾値（パーセンテージ）'
# 'The threshold the lifetime access density (accesses per byte per lifetime sec) must be under to consider an allocation cold'
HDA979A1E26A3: '割り当てをColdとみなすため、lifetimeアクセス密度（lifetime秒あたりバイトあたりのアクセス数）が下回る閾値'
# 'The type of aggregation to do on call stacks.'
H148D7C9D6F12: 'コールスタックの集計に使用するタイプ'
# 'The type of output desired'
HD9FFCDBCB5F5: '必要な出力の種類'
# 'The upper bound of size growth limit for proirity-based sample profile loader inlining.'
H4AEDA738C805: '優先度に基づくサンプルプロファイルローダーインラインのサイズ増加の上限値'
# 'The upper limit of II in the window algorithm.'
H6259F5DF8819: '窓アルゴリズムにおけるIIの上限値'
# 'The value specified in simdlen must be a power of 2 when targeting Advanced SIMD.'
HAAC03787F717: 'simdlenで指定された値は、Advanced SIMDをターゲットにした場合、2のべき乗でなければなりません。'
# 'The vectorization factor for byte-compare patterns.'
H892AED0C291C: 'バイト比較パターンのベクトル化係数'
# 'The vectorization style for loop idiom transform.'
HEB4892D4C0B2: 'ループイディオム変換のベクトル化スタイル'
# 'The version of darwin target variant SDK used for compilation'
H11C241DE938D: 'コンパイルに使用されるdarwinターゲット変種SDKのバージョン'
# 'The version of target SDK used for compilation'
H4C1FC7BD91CD: 'コンパイルに使用されるターゲットSDKのバージョン'
# 'The visibility for definitions without an explicit DLL storage class. If Keep is specified the visibility is not adjusted [-fvisibility-from-dllstorageclass]'
H5B42685299F4: '明示的なDLLストレージクラスがない定義の可視性。Keepが指定された場合、可視性は調整されません。 [-fvisibility-from-dllstorageclass]'
# 'The visibility for dllexport definitions. If Keep is specified the visibility is not adjusted [-fvisibility-from-dllstorageclass]'
H89FA30D717F3: 'dllexport定義の可視性。Keepが指定された場合、可視性は調整されません。 [-fvisibility-from-dllstorageclass]'
# 'The visibility for dllimport external declarations. If Keep is specified the visibility is not adjusted [-fvisibility-from-dllstorageclass]'
H67F478EEEC59: 'dllimport外部宣言の可視性。Keepが指定された場合、可視性は調整されません。 [-fvisibility-from-dllstorageclass]'
# 'The visibility for external declarations without an explicit DLL storage class. If Keep is specified the visibility is not adjusted [-fvisibility-from-dllstorageclass]'
H64D964A1CD05: '明示的なDLLストレージクラスがない外部宣言の可視性。Keepが指定された場合、可視性は調整されません。 [-fvisibility-from-dllstorageclass]'
# "The visibility for global C++ operator new and delete declarations. If 'source' is specified the visibility is not adjusted"
H9A7A28615088: 'グローバルC++オペレーターnewとdelete宣言の可視性。"source"が指定された場合、可視性は調整されません'
# 'The weight of backward jumps for ExtTSP value'
H0E7F2365F191: 'ExtTSP値の逆向きジャンプの重み'
# 'The weight of conditional backward jumps for ExtTSP value'
H1A51FA791B5C: 'ExtTSP値の条件付き逆向きジャンプの重み'
# 'The weight of conditional fallthrough jumps for ExtTSP value'
H17243DA21A4A: 'ExtTSP値の条件付きフォールスルージャンプの重み'
# 'The weight of conditional forward jumps for ExtTSP value'
H37AE1F715474: 'ExtTSP値の条件付き前向きジャンプの重み'
# 'The weight of unconditional backward jumps for ExtTSP value'
HF65A2E202044: 'ExtTSP値の無条件逆向きジャンプの重み'
# 'The weight of unconditional fallthrough jumps for ExtTSP value'
HAE55A03F6662: 'ExtTSP値の無条件フォールスルージャンプの重み'
# 'The weight of unconditional forward jumps for ExtTSP value'
HAB44DC9D2D01: 'ExtTSP値の無条件前向きジャンプの重み'
# 'These control extra attributes that are added when the element is printed.'
HB2159F65700A: '要素を印刷する際に追加される追加の属性を制御します。'
# 'These control how the elements are printed.'
H28147009F248: '要素の印刷方法を制御します。'
# 'These control the generated warnings.'
H7F9E68DBF772: 'これらは生成される警告を制御します。'
# 'These control the output generated.'
HFE9BA932DCA9: 'これらは生成される出力を制御します。'
# 'These control the view comparison.'
H014A13BA2172: 'これらはビューコンパリッションを制御します。'
# 'These control which elements are printed.'
H47E80A7E5CE7: 'これらは出力される要素を制御します。'
# 'These control which elements are selected.'
H093D8C9A169D: 'これらは選択される要素を制御します。'
# 'These control which sections are dumped. Where applicable these parameters take an optional =<offset> argument to dump only the entry at the specified offset.'
H4A05AC913F89: 'これらはダンプされるセクションを制御します。適切な場合、これらのパラメーターはオプションの =<offset> 引数を受け取り、指定されたオフセットのエントリのみをダンプします。'
# 'ThinLink: produces the index by linking only the summaries.'
H0F627A52D002: 'ThinLink: サマリーのみをリンクしてインデックスを生成します。'
# "This appends the content hash to the globally outlined function name. It's beneficial for enhancing the precision of the stable hash and for ordering the outlined functions."
H53B60C3E684B: 'この機能は、グローバルにアウトライン化された関数名にコンテンツハッシュを追加します。これにより、安定したハッシュの精度が向上し、アウトライン化された関数の順序付けが可能になります。'
# 'This argument does not take a value.\n\tInstead, it consumes any positional arguments until the next recognized option.'
H3C3E5BFE7ADE: 'この引数は値を受け取りません。\n\t代わりに、次の認識されるオプションまで、ポジショナル引数を消費します。'
# 'This checks if there is a fdo instr. profile hash mismatch for this function'
HFBA287CE45D4: 'この関数のFDOインストルメンテーションプロファイルハッシュが不一致かどうかをチェックします。'
# 'This compilation is part of building a PCH with corresponding object file.'
H26F9EC33106E: 'このコンパイルは、対応するオブジェクトファイルと共にPCHを構築する一部です。'
# 'This flag controls the behaviour of fcmp equality comparisons.For equality comparisons such as `x == 0.0f`, we can perform the '
HF143A3F023BD: 'このフラグはfcmp等価比較の動作を制御します。`x == 0.0f`などの等価比較において、次のように処理できます'
# 'This is the default. TOC data transformation is not applied to any variables. Only variables specified explicitly in -mtocdata= will have the TOC data transformation.'
HEF7B686F6202: 'デフォルト設定です。TOCデータ変換は、明示的に-mtocdata=で指定された変数以外には適用されません。'
# 'This option is for testing purposes only. It forces BOLT to convert low_pc/high_pc to ranges always.'
H46D236F6D0BE: 'このオプションはテスト用のみです。BOLTを常にlow_pc/high_pcを範囲に変換させます。'
# "Thread pointer access method. For AArch32: 'soft' uses a function call, or 'tpidrurw', 'tpidruro' or 'tpidrprw' use the three CP15 registers. 'cp15' is an alias for 'tpidruro'. For AArch64: 'tpidr_el0', 'tpidr_el1', 'tpidr_el2', 'tpidr_el3' or 'tpidrro_el0' use the five system registers. 'elN' is an alias for 'tpidr_elN'."
H7A1A2BC28705: "スレッドポインタアクセス方法。AArch32の場合、'soft'は関数コールを使用し、'tpidrurw'、'tpidruro'、または'tpidrprw'は3つのCP15レジスタを使用します。'cp15'は'tpidruro'のエイリアスです。AArch64の場合、'tpidr_el0'、'tpidr_el1'、'tpidr_el2'、'tpidr_el3'、または'tpidrro_el0'は5つのシステムレジスタを使用します。'elN'は'tpidr_elN'のエイリアスです。"
# 'Threshold (in bytes) for the runtime check guarding the memmove.'
HD35FCD3FC79E: 'memmoveのランタイムチェックのしきい値（バイト単位）'
# 'Threshold (in bytes) to perform the transformation, if the runtime loop count (mem transfer size) is known at compile-time.'
H1AD5098411FA: 'コンパイル時によく知られているループカウント（メモリ転送サイズ）の場合、変換を実行するためのしきい値（バイト単位）'
# 'Threshold (max size of unrolled loop) to use in aggressive (O3) optimizations'
H18A6C6D55082: 'アグレッシブ（O3）最適化で使用するしきい値（アンロールループの最大サイズ）'
# 'Threshold for hot callsites '
H362D13EBB118: 'ホットコールサイトのしきい値'
# 'Threshold for inlining addition operands into a SCEV'
HB303871617D0: 'SCEVへの追加オペランドのインライン化の閾値'
# 'Threshold for inlining cold callsites'
H250BE680BE10: 'コールドコールサイトのインライン化閾値'
# 'Threshold for inlining functions with cold attribute'
H574FD1578D90: 'cold属性を持つ関数のインライン化閾値'
# 'Threshold for inlining functions with inline hint'
H393692A6F6FF: 'インラインヒントを持つ関数のインライン化閾値'
# 'Threshold for inlining multiplication operands into a SCEV'
H07C5BF953E30: 'SCEVへの乗算オペランドのインライン化閾値'
# 'Threshold for locally hot callsites '
H1A9D72E0CF73: '局所的にホットなコールサイトの閾値 '
# 'Threshold for partial unrolling'
H6543FABE0767: '部分的アンロールの閾値'
# 'Threshold for switching to iteratively computing SCEV ranges'
H887AD3A95DC6: 'SCEV範囲を反復的に計算する切替閾値'
# 'Threshold for the size of CSUses'
H30C9036D7937: 'CSUsesのサイズに対する閾値'
# 'Threshold for triggering vextract replacement'
HF1A005DB3C4F: 'vextract置換を触発する閾値'
# 'Threshold to use for inner loop when doing unroll and jam.'
HE4FFB8758E97: 'アンロールアンドジャム時に内部ループで使用するタイルサイズ'
# 'Thumb IT blocks insertion pass'
HD5E87C90A3F2: 'Thumb IT ブロック挿入パス'
# 'Thumb2 instruction size reduce pass'
HDFB1F7BB57C2: 'Thumb2命令サイズ縮小パス'
# 'Tile Copy Lowering'
HD512AA776C9C: 'タイルコピー低階層化'
# 'Tile Register Configure'
HE55B620CE39A: 'タイルレジスタ構成'
# 'Tile Register Pre-configure'
H093374BD2768: 'タイルレジスタ前構成'
# 'Tile size for matrix instruction fusion using square-shaped tiles.'
H77BEE628E9E0: '正方形のタイルを使用した行列命令融合のためのタイルサイズ'
# 'Tilikum Crossing Optimizer\n'
H56081A939218: 'Tilikum Crossing オプティマイザ'
# 'Time each pass run, printing elapsed time for each run on exit'
H9DEAE5CE8A5D: '各パス実行時間を計測し、終了時に各実行の経過時間を表示'
# 'Time each pass, printing elapsed time for each on exit'
H6752B4F3ED5A: '各パスの実行時間を計測し、終了時に各パスの経過時間を表示'
# 'Time individual commands'
H84A9CD566359: '個々のコマンドの実行時間を計測'
# 'Time phases of parser and backend'
HC89B41C0C2D0: 'パーサーとバックエンドのフェーズの実行時間を計測'
# 'Time to be used in __DATE__, __TIME__, and __TIMESTAMP__ macros'
H972ECB48D75B: '__DATE__、__TIME__、__TIMESTAMP__マクロで使用する時刻'
# 'Time when the current build session started'
H702F4D424F4D: '現在のビルドセッションが開始された時刻'
# 'Tiny code model'
H84F95E67A022: 'Tinyコードモデル'
# 'Tool Options'
HCB6E15CE20D4: 'ツールのオプション'
# 'Tool options'
H6AA40067A445: 'ツールのオプション'
# 'Tool used for detecting AMD GPU arch in the system.'
HF986F57FE389: 'システム内のAMD GPUアーキテクチャを検出するために使用するツール'
# 'Tool used for detecting NVIDIA GPU arch in the system.'
H3CE78A0FD186: 'システム内のNVIDIA GPUアーキテクチャを検出するために使用するツール'
# 'Toolchain identification name.'
H577F665D266E: 'ツールチェーンの識別名'
# 'Toplevel siblings divisor for cost multiplier.'
H47B1D12D6302: 'コスト乗数用のトップレベル兄弟割合'
# 'Total samples cutoff for functions used to calculate profile density.'
H4F0CF57C68FB: 'プロファイル密度を計算するために使用される関数の総サンプルカットオフ'
# 'Total size of all blocks (including zero-fill) in all graphs (post-fixup)'
HA9F2ACABE207: 'すべてのグラフ（ポスト・フィックスアップ後）内のすべてのブロック（ゼロ埋めを含む）の総サイズ'
# 'Total size of all blocks (including zero-fill) in all graphs (pre-pruning)'
H33F7C5E01044: 'すべてのグラフ（プリ・プリニング前）内のすべてのブロック（ゼロ埋めを含む）の総サイズ'
# 'Trace global value placement'
H3F11F16F204E: 'グローバル値の配置をトレース'
# 'Trace the hash of the function with this name.'
H2FA3F2871F69: 'この名前の関数のハッシュをトレース'
# 'Traces to enable.'
H5DD3783FD8E4: '有効にするトレース'
# 'Tracing of CMP and similar instructions'
H46B2C1DD8A24: 'CMPおよび類似命令のトレース'
# 'Tracing of DIV instructions'
H6C4B7FBBDB1C: 'DIV命令のトレース'
# 'Tracing of GEP instructions'
H9495E0A41197: 'GEP命令のトレース'
# 'Tracing of load instructions'
H9296E34AACB7: '負荷命令のトレース'
# 'Tracing of store instructions'
HD37453D2BD66: 'ストア命令のトレース'
# 'Track failure strings in detecting scop regions'
HA2AAD146A60C: 'スコープ領域検出での失敗文字列を追跡'
# 'Track origins (allocation sites) of poisoned memory'
H3D9C4DED10A1: '中毒メモリの起源（割り当てサイト）を追跡'
# 'Track origins of labels'
H6DEEA7E74FFD: 'ラベルの起源を追跡'
# 'Track reg pressure and switch priority to in-depth'
HD40E656EBBE9: 'レジスタ圧力に基づき優先度を深さ優先に変更'
# 'Track the overflow bit if requested.'
H6AA670469C83: '要求された場合にオーバーフロー ビットを追跡'
# 'Training log for the register allocator eviction model'
H6E2B0424977E: 'レジスタアロケータ排出モデルのトレーニングログ'
# 'Training log for the register allocator priority model'
HDBA649A1B080: 'レジスタアロケータプライオリティモデルのトレーニングログ'
# 'Transform functions to use DSP intrinsics'
H926BA6FE32A4: 'DSPのイントリンシック関数を使用するように関数を変換'
# "Transitional flag to turn off NVPTX's requirement on preserving structured CFG. The requirement should be disabled only when unexpected regressions happen."
H280C497E1DC8: 'NVPTXの構造化CFG保持要件を無効化する移行フラグ。この要件は予期しない回帰が発生した場合のみ無効化可能です。'
# 'Translations to perform'
HD6F4D5A5B7BD: '実行する変換処理'
# 'Trap on integer division by zero.'
HDD1ADB807B39: '整数除算によるゼロ除算時にトラップ'
# 'Trap on integer overflow'
H912BF1C6F685: '整数オーバーフロー時にトラップ'
# 'Trap when incorrect'
H9EC2646A38E0: '正しくない状態時にトラップ'
# 'Treat <file> as C source file'
H5AAFC1A35AEE: '<file>をCソースファイルとして処理'
# 'Treat <file> as C++ source file'
H467B7FCAE3B7: '<file>をC++ソースファイルとして処理'
# 'Treat INCLUDE lines like #include directives in -E mode'
H8BB5A80B42A6: '-EモードでINCLUDE行を#includeディレクティブのように扱う'
# 'Treat all #include paths starting with <prefix> as including a system header.'
H4CD79E350724: '<prefix>で始まるすべての#includeパスをシステムヘッダーとして扱う'
# 'Treat all #include paths starting with <prefix> as not including a system header.'
H7FC347478B10: '<prefix>で始まるすべての#includeパスをシステムヘッダーとして扱わない'
# 'Treat all parameters to functions that are pointers as dereferencible. This is useful for invariant load hoisting, since we can generate less runtime checks. This is only valid if all pointers to functions are always initialized, so that Polly can choose to hoist their loads. '
H01E314D59C27: '関数のすべてのポインタを参照可能なものとして扱う。これは不変ロードの持ち上げにとって有用で、より少ない実行時チェックを生成できる。ただし、全ての関数ポインタが常に初期化されている場合のみ有効で、Pollyがロードを持ち上げるための選択ができる'
# 'Treat all source files as C'
H55FA85BDA2A5: 'すべてのソースファイルをC言語として扱う'
# 'Treat all source files as C++'
H7EEC5BB50052: 'すべてのソースファイルをC++として扱う'
# 'Treat any <pattern> strings as regular expressions when selecting instead of just as an exact string match.'
HB8CFB19C5C18: '<パターン>文字列を正確な文字列一致ではなく正規表現として扱う'
# 'Treat each comma separated argument in <arg> as a documentation comment block command'
HCB49DF1FFB5A: '<arg>のコンマ区切り引数をドキュメントコメントブロックコマンドとして扱う'
# 'Treat editor placeholders as valid source code'
H5F226C718000: 'エディタプレースホルダーを有効なソースコードとして扱う'
# "Treat fixed form lines with 'd' or 'D' in the first column as blank."
HADC0D4FE88CA: "固定形式の行で最初の列に'd'または'D'がある場合、空白として扱う"
# "Treat fixed form lines with 'd' or 'D' in the first column as comments."
H3F2B7A8C2293: "固定形式の行で最初の列に'd'または'D'がある場合、コメントとして扱う"
# 'Treat hip and hipv4 offload kinds as compatible with openmp kind, and vice versa.\n'
HC9954ACD9B9E: 'hipとhipv4のオフロード種類をopenmp種類と互換とみなす\n'
# 'Treat input as a PDB file (default)'
H24602D862E82: '入力をPDBファイルとして処理（デフォルト）'
# 'Treat input as raw contents of /names named stream'
H2F74766FAAE9: '入力を/namesネームドストリームの生内容として扱う'
# 'Treat input as raw contents of DBI stream'
H56798B0B0190: '入力をDBIストリームの生内容として扱う'
# 'Treat input as raw contents of PDB stream'
H6E74D779FAE8: '入力をPDBストリームの生内容として扱う'
# 'Treat input as raw contents of a module stream'
H720BDBA3C128: '入力をモジュールストリームの生内容として扱う'
# 'Treat issues where a fixed-width property is requested from a scalable type as a warning, instead of an error'
HE3ED92F98BA0: 'スケーラブル型からの固定幅プロパティ要求で発生する問題を警告として扱い、エラーとしない'
# "Treat pointer overflow as two's complement"
HF00886F33282: 'ポインタオーバーフローを2の補数として扱う'
# "Treat signed integer overflow as two's complement"
H1BAF0BBFDBF6: '符号付き整数のオーバーフローを2の補数として扱う'
# 'Treat source input files as Objective-C inputs'
H10D7DE6018B0: '入力ソースファイルをObjective-C入力として扱う'
# 'Treat source input files as Objective-C++ inputs'
HF4443D8F9187: '入力ソースファイルをObjective-C++入力として扱う'
# 'Treat stack lifetimes as starting on first use, not on START marker.'
H1D5DFE08E7A8: 'スタック lifetime をSTART マーカーではなく最初の使用時に開始されたものとして扱う'
# 'Treat string literals as const'
H79E1F4486D77: '文字列リテラルをconstとして扱う'
# 'Treat subsequent input files as having type <language>'
HC2DB15026570: 'その後の入力ファイルを型<language>として扱う'
# 'Treat usage of null pointers as undefined behavior (default)'
HEF76E5F5F913: 'NULL ポインタの使用を未定義動作として扱う（既定値）'
# 'Treat warnings as errors'
H518C417B2786: '警告をエラーとして扱う'
# 'Trim cold functions until profile size is below specified limit in bytes. This uses a heursitic and functions may be excessively trimmed'
H9C86C77C9C88: 'プロファイルのサイズが指定されたバイト数の制限を下回るまで、cold 関数を切り詰めます。これはヒューリスティックを使用し、関数が過度に切り詰められる可能性があります'
# 'Trim context sample profiles whose count is below cold threshold'
HD98B893B0D67: 'cold 閾値未満のカウントを持つコンテキストのサンプルプロファイルを切り詰める'
# 'Triple default EABI version'
H929ED20C3916: 'トリプルのデフォルトEABIバージョン'
# 'Triple to use to serialize to cubin.'
HCE48A7F9471E: 'cubin にシリアル化するために使用するトリプル'
# 'Try emitting Compact-Unwind for non-canonical entries. Maybe overridden by other constraints'
H3E74499232A9: '非標準エントリに対してCompact-Unwindを試みる。他の制約によって上書きされる可能性があります'
# 'Try hoisting constant gep expressions'
HEBF48C3AF674: '定数 gep 式をhoistingするのを試みる'
# 'Try to avoid heapifying local blocks'
HD9B64861AC5A: 'ローカルブロックのヒープ化を回避するのを試みる'
# 'Try to avoid reuse of byte array addresses using aliases'
HD4627CAE2B4C: 'エイリアスを使用してバイト配列アドレスの再利用を回避するのを試みる'
# 'Try to construct schedules where the outer member of each band satisfies the coincidence constraints (yes/no)'
H60DF39720CB5: '各バンドの外側メンバーが一致制約を満たすスケジュールを構築するのを試みる（yes/no）'
# 'Try to delinearize array references.'
H2EA0163561FB: '配列参照をdelinearizeするのを試みる'
# 'Try to evenly distribute flow when there are multiple equally likely options.'
HAEBC34FD2276: '複数の同程度にありそうなオプションがある場合、流れを均等に分配するのを試みる'
# 'Try to propagate nonnull argument attributes from callsites to caller functions.'
H020E4D562B19: 'コールサイトから呼び出し元の関数にnonnull引数属性を伝播しようとする。'
# 'Try to simplify all loads.'
HBDC33CA86746: 'すべてのロードを単純化しようとする。'
# 'Try to vectorize with non-power-of-2 number of elements.'
H0125A5F09D1C: '要素数が2のべき乗でない場合にもベクトル化を試みる。'
# 'Try wider VFs if they enable the use of vector variants'
H26EA4E292B56: 'より広いVFを使用可能にすることでベクトル変種を使用できる場合、試す。'
# 'Tune debug info for a particular debugger'
H77BC7AA0BB02: '特定のデバッガ用にデバッグ情報を調整する'
# 'Tune for a specific cpu type'
H3345FF3520DA: '特定のCPUタイプ用に調整する'
# 'Turn all knobs to 11'
H1AC91DEDAC4E: 'すべての調整ツマミを11に設定する'
# 'Turn fastcc calls into tail calls by (potentially) changing ABI.'
HF62148DE9C4D: 'ABIを変更する可能性があるが、fastccコールをテールコールに変換する。'
# 'Turn off Type Based Alias Analysis'
H63440B325F63: 'タイプベースのエイリアス分析を無効化'
# 'Turn off loop unroller'
H0C19FC5B8215: 'ループアンローラーを無効化'
# 'Turn off sparse parallelization.'
H32757C1F23A6: 'スパースな並列化を無効化'
# 'Turn off struct-path aware Type Based Alias Analysis'
H8E0ED82C6CEB: '構造体パスを考慮したタイプベースのエイリアス分析を無効化'
# 'Turn off window algorithm.'
H6D475479FF1D: 'ウィンドウアルゴリズムを無効化'
# 'Turn on DominatorTree and LoopInfo verification after Loop Distribution'
H14C9F8E485D6: 'ループ分布後のDominatorTreeとLoopInfoの検証を有効化'
# 'Turn on loop unroller'
H189401528396: 'ループアンローラーを有効化'
# 'Turn on module map output and specify output path or file name. If no path is specified and if prefix option is specified, use prefix for file path.'
H6B0988247E72: 'モジュールマップ出力を有効化し、出力パスまたはファイル名を指定します。パスが指定されていない場合でもprefixオプションが指定されていれば、prefixを使用します。'
# 'Turn on runtime checks for various forms of undefined or suspicious behavior. See user manual for available checks'
H44BD445B1D2C: '未定義または怪しい動作に対するランタイムチェックを有効化します。利用可能なチェックについてはユーザーマニュアルを参照してください。'
# 'Turn on time profiler. Generates JSON file based on output filename.'
H605BD513ED60: 'タイムプロファイラを有効化します。出力ファイル名に基づいてJSONファイルを生成します。'
# 'Turns on stale matching with block pseudo probes.'
HFFCF05795EA6: 'ブロックの疑似プローブを使用した古いマッチングを有効化します。'
# 'Two-Address instruction pass'
HD8164AEBCCB3: 'Two-Address instruction パス'
# 'Type Options'
H7C8D98E334E0: 'タイプ オプション'
# 'Type Promotion'
H4F87D1DD8D47: '型のプロモーション'
# 'Type Record Options'
H979D586C9237: 'タイプ レコード オプション'
# 'Type definition.'
H37A26D2D1A2C: '型定義。'
# 'Type kind to use when printing types.'
H3F4786926275: '型を表示する際の型の種類。'
# 'Type of checking for incorrect devirtualizations'
HB2F8536F04B5: '不正なデバイーチャライゼーションの検証の種類'
# 'Type of symbols to dump (default all)'
HDEE9A9BDCFC8: 'ダンプするシンボルの種類 (デフォルトはすべて)'
# 'Type of the files to be bundled/unbundled.\nCurrent supported types are:\n  i    - cpp-output\n  ii   - c++-cpp-output\n  cui  - cuda-cpp-output\n  hipi - hip-cpp-output\n  d    - dependency\n  ll   - llvm\n  bc   - llvm-bc\n  s    - assembler\n  o    - object\n  a    - archive of objects\n  gch  - precompiled-header\n  ast  - clang AST file'
H23DE32DB4F4F: 'バンドルされるファイルの種類。\n現在サポートされている種類は次の通りです:\n  i    - cpp-output\n  ii   - c++-cpp-output\n  cui  - cuda-cpp-output\n  hipi - hip-cpp-output\n  d    - dependency\n  ll   - llvm\n  bc   - llvm-bc\n  s    - assembler\n  o    - object\n  a    - オブジェクトのアーカイブ\n  gch  - precompiled-header\n  ast  - clang AST ファイル'
# 'Type-Based Alias Analysis'
H432902366273: 'タイプベースのエイリアス分析'
# 'Types (Pointer, Reference, etc.).'
H09ADEF8BEED1: 'タイプ (ポインタ、参照など)。'
# 'Types.'
H1145E1A9F2E2: 'タイプ。'
# 'UNKOWN'
HD91DF451ADF1: '不明'
# 'USAGE: '
H4060E2625813: '使用法: '
# 'Unbundle bundled file into several output files.\n'
H1DD69F0F0D6F: 'バンドルされたファイルを複数の出力ファイルに展開します。\n'
# 'Unconditionally apply unchecked-ld-st optimization (even for large stack frames, or in the presence of variable sized allocas).'
H26BF316F7B25: 'unchecked-ld-st オプティマイゼーションを無条件で適用します（大規模なスタックフレームでも、または可変長のallocaが存在する場合も）'
# 'UndName Options'
H2ACB6A59624D: 'UndName オプション'
# 'Undefine macro'
H85ECFBA229C4: 'マクロを未定義にする'
# 'Undefine macro <macro>'
HE9FB0C5A98C8: 'マクロ <macro> を未定義にする'
# 'Undefined / no particular sort order'
H2DF8FA5D8D5C: '未定義 / 特定のソート順序なし'
# 'Undefines the __DEPRECATED macro'
HFAB714AB2388: '__DEPRECATEDマクロを未定義にします'
# 'Underlying type for type definitions.'
HE810C104AEFC: '型定義の基底型。'
# 'Unexpected vftable component type %0 for component number %1'
H40151C08E668: 'コンポーネント番号%1のvftableコンポーネント型%0が予期しない形式です'
# 'Uniformity Analysis'
H18CD82918982: '一様性分析'
# 'Unify divergent function exit nodes'
H8B72079558B4: '分岐した関数終了ノードを統一する'
# 'Unify multiple OpenCL metadata due to linking'
H1E880963D2AC: 'リンキングによる複数のOpenCLメタデータを統一する'
# 'Union.'
H8AC81596AB6F: 'ユニオン。'
# 'Uniqueify Internal Linkage Symbol Names by appending the MD5 hash of the module path'
HE20B29760EEF: 'モジュールパスのMD5ハッシュを追加して、内部リンク記号名を一意化する'
# 'Unpack machine instruction bundles'
H6975BC91D598: 'マシン命令バンドルを展開する'
# 'Unparse and stop (skips the semantic checks)'
HB65257706E07: 'パースを解除して終了（セマンティックチェックをスキップ）'
# 'Unparse and stop.'
H8A6570E46B2D: 'パースを解除して終了。'
# 'Unparse with dependent modules and stop.'
HDFEBDFAE4C78: '依存モジュールを含めてパースを解除して終了。'
# 'Unparse with symbols and stop.'
H0D9F89477381: 'シンボルを含めてパースを解除して終了。'
# 'Unroll factor (affecting 4x32-bit operations) to use for memory operations when lowering memcpy as a loop'
HE43C43B147A4: 'memcpyをループとして展開する際、4x32ビット操作に影響を与えるメモリ操作用のアンロール係数'
# 'Unroll loops'
H14907BD20FBA: 'ループのアンロール'
# 'Unroll loops with run-time trip counts'
H094122EA378B: '実行時反復回数を持つループのアンロール'
# 'Unroll threshold for AMDGPU if local memory used in a loop'
H9E766FE7E2B8: 'ループ内でローカルメモリが使用される場合のAMDGPUのアンロール閾値'
# 'Unroll threshold for AMDGPU if private memory used in a loop'
HAC396B9BAD8B: 'ループ内でプライベートメモリが使用される場合のAMDGPUのアンロール閾値'
# 'Unroll threshold increment for AMDGPU for each if statement inside loop'
H93579CFAA697: 'ループ内の各if文に対してAMDGPUのアンロールしきい値を増加させる'
# 'Unrolled size limit for loops with an unroll(full) or unroll_count pragma.'
H455348AAE5AE: 'unroll(full) または unroll_count pragma を持つループのアンロールサイズの制限'
# 'Unrolled size limit for loops with an unroll_and_jam(full) or unroll_count pragma.'
H83703E1D1FC8: 'unroll_and_jam(full) または unroll_count pragma を持つループのアンロールサイズの制限'
# 'Unspecified parameter.'
H12B0F3A3DD19: '未指定のパラメータ。'
# 'Unspecified type.'
HEE55D6208E96: '未指定の型。'
# 'Unwind library to use'
HAF3990494241: '使用するアンワインドライブラリ'
# 'Uop Decomposition'
H84228E8F31C8: 'Uop分解'
# 'Update pseudo probe distribution factor'
H95A61EF626F6: '疑似プローブ分布係数を更新'
# 'Update total samples by accumulating all its body samples.'
H4ABB921FD931: '全サンプルをそのボディの全サンプルを累積して更新する'
# 'Use #line in preprocessed output'
H61A0DD59549D: 'プリプロセス出力に#lineを使用する'
# "Use 'mips.ccmov' instruction"
HDC01AC60098B: "'mips.ccmov'命令を使用する"
# 'Use -compile-command to define a command to compile the bitcode. Useful to avoid linking.'
H45B889E18E9F: '-compile-commandオプションを使用してビットコードをコンパイルするコマンドを定義します。リンカ回避に便利です。'
# 'Use -exec-command to define a command to execute the bitcode. Useful for cross-compilation.'
HBBC97C4993AA: '-exec-commandオプションを使用してビットコードを実行するコマンドを定義します。クロスコンパイルに便利です。'
# 'Use .ctors instead of .init_array.'
HEFD53B18D4A2: '.ctorsセクションの代わりに.init_arrayを使用する'
# 'Use .ctors/.dtors instead of .init_array/.fini_array'
H89195E513795: '.ctors/.dtorsセクションの代わりに.init_array/.fini_arrayを使用する'
# 'Use .file directives with an explicit directory'
H9DEC86EE53C8: '明示的なディレクトリを持つ.fileディレクティブを使用する'
# 'Use 16-bit hardware multiplier'
HE39242B4C409: '16ビットハードウェアマルチプライヤを使用する'
# 'Use 32-bit floating point registers (MIPS only)'
HE9E46E3267C7: 'MIPSでのみ有効な32ビット浮動小数点レジスタを使用する'
# 'Use 32-bit hardware multiplier'
H48A0735D6EC9: '32ビットハードウェアマルチプライヤを使用する'
# 'Use 32-bit pointers for accessing const/local/shared address spaces'
HEBB1FFB0999C: 'const/local/sharedアドレス空間へのアクセスに32ビットポインタを使用する'
# 'Use 32-bit pointers for accessing const/local/shared address spaces.'
H1C423A27FAD4: 'const/local/sharedアドレス空間へのアクセスに32ビットポインタを使用する。'
# 'Use 64-bit floating point registers (MIPS only)'
H4492AB59FFA0: '64ビット浮動小数点レジスタを使用する (MIPSのみ)'
# 'Use <dumpfpx> as a prefix to form auxiliary and dump file names'
H3DFDBA26A67C: '<dumpfpx>を接頭辞として補助ファイルとダンプファイルの名前を形成する'
# 'Use <suffix> as the suffix for module files (the default value is `.mod`)'
H0754CF14DB5E: 'モジュールファイルの接尾辞として<suffix>を使用する (デフォルト値は`.mod`)'
# 'Use <value> as character line width in fixed mode'
HAF90606EAD0C: '固定モードでの文字行幅として<value>を使用する'
# 'Use ANSI escape codes for diagnostics'
HF4E88E8746F8: '診断情報でANSIエスケープコードを使用する'
# "Use Apple's kernel extensions ABI"
H707C74B2A986: 'Appleのカーネル拡張ABIを使用する'
# 'Use CREL relocation format for ELF'
H01BA06F9BEE0: 'ELF用のCREL再配置形式を使用する'
# "Use ConstantFP's native fixed-length vector splat support."
H45D6CB612C50: 'ConstantFPのネイティブな固定長ベクタースプライトサポートを使用する。'
# "Use ConstantFP's native scalable vector splat support."
H019F3DB4B516: 'ConstantFPのネイティブなスケーラブルベクタースプライトサポートを使用する。'
# "Use ConstantInt's native fixed-length vector splat support."
HEE201C750BB5: 'ConstantIntのネイティブな固定長ベクタースプライトサポートを使用する。'
# "Use ConstantInt's native scalable vector splat support."
H205BD3049DE6: 'ConstantIntのネイティブなスケーラブルベクタースプライトサポートを使用する。'
# 'Use DLL debug run-time'
H09CE8A3B2FF2: 'DLLデバッグランタイムを使用する'
# 'Use DLL run-time'
HFFC5F85F16E2: 'DLLランタイムを使用する'
# 'Use DPP operations for scan'
HA25C31D46A88: 'スキャン用にDPPオペレーションを使用する'
# 'Use DWARF base address selection entries in .debug_ranges'
H785682C5C939: '.debug_rangesセクションにDWARFベースアドレス選択エントリを使用する'
# 'Use DWARF style exceptions'
H37CB53594E9C: 'DWARF スタイルの例外を使用する'
# 'Use Decision Forest model to rank completion items'
H05DCA5EC7686: 'コード補完アイテムのランキングに決定木フォレストモデルを使用する'
# 'Use EH-safe code when synthesizing retains and releases in -fobjc-arc'
H36FC7089F28D: '-fobjc-arc の retain と release の合成時に EH セーフ コードを使用する'
# 'Use F5 series hardware multiplier'
H2733E473C4B3: 'F5 シリーズのハードウェア乗算器を使用する'
# 'Use GC exclusively for Objective-C related memory management'
H2B28F501A8B5: 'Objective-C に関連するメモリ管理に GC を排他的に使用する'
# "Use GCC installation in the specified directory. The directory ends with path components like 'lib{,32,64}/gcc{,-cross}/$triple/$version'. Note: executables (e.g. ld) used by the compiler are not overridden by the selected GCC installation"
HA7E84A833041: "指定されたディレクトリにある GCC インストールを使用します。ディレクトリの末尾には 'lib{,32,64}/gcc{,-cross}/$triple/$version' などのパスコンポーネントが含まれます。注意: コンパイラが使用する実行可能ファイル (例: ld) は、選択された GCC インストールによって上書きされません"
# 'Use GCNDownwardRPTracker for GCNRegPressurePrinter pass'
HC666D46EACA0: 'GCNRegPressurePrinter パスに GCNDownwardRPTracker を使用する'
# 'Use GOT indirection instead of PLT to make external function calls (x86 only)'
H813651BE1DF2: '外部関数呼び出しには GOT インダイレクションを使用し PLT を使用しない (x86専用)'
# 'Use GOT indirection to reference external data symbols'
H9C63E198FEC5: '外部データシンボルを参照する際に GOT インダイレクションを使用する'
# 'Use GP relative accesses for symbols known to be in a small data section (MIPS)'
H16E3D5EA2597: 'Small Data セクションにあることがわかっているシンボルを参照する際に GP 相対アクセスを使用する (MIPS向け)'
# 'Use GPR indexing mode instead of movrel for vector indexing'
H65B8C362AD34: 'ベクタインデックスで movrel の代わりに GPR インデックスモードを使用する'
# 'Use GlobalISel desired legality, rather than try to userules compatible with selection patterns'
HCD3F9F572B30: '選択パターンと互換性のあるルールを使用する代わりに、GlobalISel の望ましい合法性基準を使用する'
# 'Use HLFIR lowering (experimental)'
HBF33CE828D70: 'HLFIR 下位変換を使用する (実験的)'
# 'Use IEEE 754 quadruple-precision for long double'
H52864CA1A557: 'long double に IEEE 754 四重精度を使用する'
# 'Use INTEGER(KIND=8) for the result type in size-related intrinsics'
H31BCF654D576: 'サイズ関連の組み込み関数の結果型に INTEGER(KIND=8) を使用する'
# 'Use InstrItineraryData for latency lookup'
HE819C1D764CF: '遅延検索に InstrItineraryData を使用する'
# 'Use Intel MCU ABI'
H047785ECB956: 'Intel MCU ABI を使用する'
# 'Use Iterative approach for scan'
HB2B560B747FE: 'スキャンに反復的なアプローチを使用する'
# 'Use JSON as the output format.'
H22CC5D346911: 'JSONを出力フォーマットとして使用'
# 'Use LFENCE along each conditional edge to harden against speculative loads rather than conditional movs and poisoned pointers.'
H417B6B21B3DF: '条件付きmovや中毒ポインタではなく思惑的ロードに対する強化を施すために、各条件枝分かれの辺にLFENCEを使用'
# 'Use LLJITGenericIRPlatform'
H25BF0FFFB5D6: 'LLJITGenericIRPlatformを使用する'
# 'Use LLVM-IR names when deriving statement names'
H7614196F2CF1: 'ステートメント名を導出する際にLLVM-IRの名前を使用する'
# 'Use LLVM/Offload as portable offloading runtime.'
HE33C03962BCE: 'LLVM/Offloadをポータブルなオフロードランタイムとして使用する'
# 'Use MD5 for file checksums in debug info (default)'
H96424B977A6D: 'デバッグ情報内のファイルのチェックサムにMD5を使用（既定値）'
# 'Use ML.'
HFB1C0C51C398: 'MLを使用'
# 'Use NMake/Jom format for the depfile'
H2770540BA1FF: 'depfileにNMake/Jomフォーマットを使用'
# 'Use ORC runtime from given path'
H0B3C6C26BF5D: '指定されたパスからORCランタイムを使用'
# 'Use SEH style exceptions'
HF73D39350799: 'SEHスタイルの例外を使用する'
# 'Use SHA1 for file checksums in debug info'
H18018B318301: 'デバッグ情報内のファイルのチェックサムにSHA1を使用'
# 'Use SHA256 for file checksums in debug info'
HF98F43EAE9BB: 'デバッグ情報内のファイルのチェックサムにSHA256を使用'
# 'Use SjLj style exceptions'
H44AA3EF8F7F8: 'SjLjスタイルの例外を使用する'
# 'Use Stable Hashing for MIR VReg Renaming'
H093C21DF7C9E: 'MIR VRegのリネームに安定ハッシュを使用する'
# 'Use Stack Safety analysis results'
HCE2D7641DBD9: 'スタックセーフティ分析の結果を使用する'
# 'Use StructurizeCFG IR pass'
HA25675EEF575: 'StructurizeCFG IRパスを使用'
# 'Use TLS'
HF5C26334C370: 'TLS を使用する'
# 'Use TargetSchedModel for latency lookup'
HC9F59D7F1E0C: '遅延の照会に TargetSchedModel を使用する'
# 'Use TargetTransformInfo::getInstructionCost'
H4974E1B043EE: 'TargetTransformInfo::getInstructionCost を使用する'
# 'Use TargetTransformInfo::getIntrinsicInstrCost'
H85A8617C4E16: 'TargetTransformInfo::getIntrinsicInstrCost を使用する'
# 'Use VP intrinsics'
H7B0B6BAFD1AA: 'VP インtrinsic を使用する'
# 'Use WebAssembly style exceptions'
H0F092371B645: 'WebAssembly スタイルの例外を使用する'
# 'Use a best-case representation method for member pointers'
H7AE6BEFD1C8A: 'メンバー ポインタの最適な表現方法を使用する'
# 'Use a const qualified type for string literals in C and ObjC'
HBFF97FAA6C53: 'C 言語と ObjC での文字列リテラルに const 質問型を使用する'
# 'Use a diagnostic handler to test the handler interface'
H3C822F398929: 'ハンドラ インターフェースのテストに診断ハンドラを使用する'
# 'Use a fake address space map; OpenCL testing purposes only'
H9DCA916816C8: '偽のアドレス スペース マップを使用する（OpenCL テスト専用）'
# 'Use a free form text output.'
HA312842C43C5: '自由形式テキスト出力を使用する'
# 'Use a full speculation fence to harden both call and ret edges rather than a lighter weight mitigation.'
H600ECC7683CF: 'コールとリターン エッジの両方を強化するために、軽量な軽減策ではなく完全な推測フェンスを使用する'
# 'Use a most-general representation for member pointers'
H0E7635ED3666: 'メンバー ポインタの最も汎用的な表現を使用する'
# 'Use a rematerializable pseudoinstruction for 2 instruction constant materialization'
H3A40020AE1F7: '2命令定数マテリアル化に再マテリアル化可能な仮命令を使用する'
# 'Use a signed type for wchar_t'
H48F702933B27: 'wchar_t に符号付き型を使用する'
# 'Use a single TBAA tree for all functions and do not use the FIR alias tags pass'
HC642932368D3: 'すべての関数に対して単一の TBAA 木を使用し、FIR エイリアス タグ パスを使用しない'
# 'Use absolute paths for invoking subcommands (default)'
HFDEA884CA19F: 'サブコマンドを実行する際に絶対パスを使用する（既定値）'
# 'Use addrx+offset extension form for any address with a prior base address'
H5B85C96D3B22: '事前にベースアドレスを持つアドレスに対してaddrx+offset拡張形式を使用する'
# 'Use all available analyses'
H8DB3578A8858: '利用可能なすべての解析を使用する'
# 'Use all discriminator bits (default)'
H568FAF6786A5: 'すべてのdiscriminatorビットを使用する（デフォルト）'
# 'Use an unsigned type for wchar_t'
HE6D72C7A4E59: 'wchar_tにunsigned型を使用する'
# 'Use approximate transcendental functions'
HC80164348ADD: '近似超越関数を使用する'
# 'Use arc callee save/restore functions'
HDC1738B5E10F: 'ARCのcallee save/restore関数を使用する'
# 'Use atexit or __cxa_atexit to register global destructors'
HD6A435F1A848: 'グローバルデストラクタを登録するためにatexitまたは__cxa_atexitを使用する'
# 'Use atomic fetch add for first counter in a function (usually the entry counter)'
HE1A472AB0CD6: '関数内の最初のカウンタ（通常はエントリーカウンタ）にatomic fetch addを使用する'
# 'Use base address specifiers in debug_ranges'
H16F9B262870C: 'debug_rangesでベースアドレスペックファイアを使用する'
# 'Use base and pass 1 discriminators'
HFD9F1E3E9AB6: 'ベースとpass 1のdiscriminatorを使用する'
# 'Use base and pass 1-2 discriminators'
H8235CCC718A7: 'ベースとpass 1-2のdiscriminatorを使用する'
# 'Use base and pass 1-3 discriminators'
HF4182389B253: 'ベースとpass 1-3のdiscriminatorを使用する'
# 'Use base discriminators only'
HF3EBCD1C0036: 'ベースのみのdiscriminatorを使用する'
# 'Use best guess'
H868B8A8130DA: '最良の推測を使用する'
# 'Use binary to correlate'
H72FD9C9D9781: 'バイナリを使用して相関させる'
# 'Use block frequency info to find successors to sink'
H76D3FF42212F: 'ブロック頻度情報を使用してシンクする後の後続を見つける'
# 'Use cache manager to save/load modules'
HA5972065E561: 'キャッシュマネージャを使用してモジュールを保存/読み込む'
# 'Use call site prioritized inlining for sample profile loader. Currently only CSSPGO is supported.'
H91095FED309C: 'サンプルプロファイルローダーでコールサイト優先インラインを使用する。現在はCSSPGOのみ対応しています。'
# 'Use callbacks instead of inline instrumentation sequences.'
H3EC6C04656EA: 'インストルメンテーションシーケンスの代わりにコールバックを使用する'
# 'Use callee size priority.'
H959C69EC2106: '被呼関数サイズ優先を使用する'
# 'Use case-insensitive matching'
HCBB3CB058AC9: '大文字小文字を区別しないマッチングを使用する'
# 'Use codegen data read from default.cgdata to optimize the binary'
HEFC973859186: 'デフォルトのcgdataから読み込んだcodegenデータを使用してバイナリを最適化する'
# 'Use codegen data read from the specified <path>.'
HA873FDC06A7F: '指定された<path>から読み込んだcodegenデータを使用する'
# 'Use colors in detailed AST output. If not set, colors\nwill be used if the terminal connected to\nstandard output supports colors.'
H3428909B1528: '詳細AST出力に色を使用する。設定されていない場合、\n標準出力に接続されたターミナルが色をサポートしている場合は色を使用します。'
# 'Use colors in output (default=autodetect)'
H036C59DCDCFA: '出力に色を使用する（デフォルト=自動検出）'
# 'Use column-major layout'
H798E10981CB2: '列優先配置を使用する'
# 'Use compact approach for aligning functions'
H53E4E0949D55: '関数のアラインメントにコンパクトな手法を使用する'
# 'Use compact branches where appropriate (default).'
HE80CC6815708: '適切な場所でコンパクトな分岐を使用する（デフォルト）'
# 'Use compressed jump tables in Thumb-1 by synthesizing an equivalent to the TBB/TBH instructions'
H2165E804582A: 'Thumb-1で圧縮されたジャンプテーブルを使用してTBB/TBH命令に相当するものを合成する'
# 'Use constructor homing if we are using limited debug info already'
H62F93DEE0ADD: '限定されたデバッグ情報を利用する場合、コンストラクタのホーム化を使用する'
# 'Use context'
H3D56A8B500FF: 'コンテキストを使用する'
# 'Use context-sensitive byte size cost for preinliner decisions'
H7FD64165B9B4: 'コンテキスト感度のあるバイトサイズコストを使用してプリインラインの決定を行う'
# 'Use cost-benefit ratio.'
H9D7EE37E6691: 'コスト利益率を使用する'
# 'Use debug info or binary file to correlate profiles.'
H2E074CAAD7C0: 'デバッグ情報またはバイナリファイルを使用してプロファイルを相関させる'
# 'Use debug info to correlate'
HEC4020684722: 'デバッグ情報を使用して関連付けます'
# 'Use debug info to correlate profiles. (Deprecated, use -profile-correlate=debug-info)'
H3760EBF147CB: 'デバッグ情報でプロファイルを関連付けます（非推奨、-profile-correlate=debug-infoを使用してください）'
# 'Use debug-info or binary correlation to correlate profiles with build id fetcher'
HE51EAC7876DD: 'ビルドID取得機能と共に、デバッグ情報またはバイナリ相関を使用してプロファイルを関連付けます'
# 'Use debuginfod to look up object files from profile'
HF7500F4663E6: 'プロファイルからオブジェクトファイルを検索する際、debuginfodを使用します'
# 'Use default code inlining logic for the address sanitizer'
HB70EC9805527: 'アドレスサンitizerのインラインロジックにデフォルトコードを使用します'
# 'Use development mode (runtime-loadable model)'
H1078C08F764F: '開発モードを使用（ランタイムロード可能モデル）'
# 'Use directory as the C++ standard library include path'
H323DACFD356C: 'C++標準ライブラリのインクルードパスとしてディレクトリを使用します'
# 'Use distinct LTO pipelines'
H5CC3AC1C99CE: '区別されたLTOパイプラインを使用します'
# 'Use div.w[u] and mod.w[u] instructions with input not sign-extended.'
HCBB92DFD904B: '入力が符号拡張されていない場合、div.w[u]とmod.w[u]命令を使用します'
# 'Use dot format instead of plain text when dumping VPlans'
HE98D975C012B: 'VPlansをダンプする際にテキスト形式の代わりにdot形式を使用します'
# 'Use dwarf for profile correlation even when binary contains pseudo probe.'
HB77EAFFEBB88: 'バイナリに疑似プローブが含まれる場合でもDWARFを使用してプロファイルを関連付けます'
# 'Use dynamic alloca to represent stack variables'
H0BD8D88B6D44: 'スタック変数を動的allocaで表現します'
# 'Use emulated TLS model'
H1BBC4DA9A238: 'エミュレートされたTLSモデルを使用します'
# 'Use emutls functions to access thread_local variables'
HF38CD5C8C963: 'thread_local変数にアクセスするためにemutls関数を使用する'
# 'Use experimental new value-tracking variable locations'
H5A1E1B70E9BC: '実験的な新しい値追跡変数ロケーションを使用します'
# 'Use exprloc addrx+offset expressions for any address with a prior base address'
H8B37A6DB17E6: '基底アドレスを持つアドレスに対してexprloc addrx+オフセット式を使用します'
# 'Use ext-tsp for size-aware block placement.'
H6EBF1A8427C5: 'ext-tspを使用してサイズ意識型ブロック配置を行います'
# 'Use external machine object code emitter.'
H863F828BD310: '外部のマシンオブジェクトコードエミッタを使用する'
# 'Use fast short rep mov in memcpy lowering'
H51A6C031B64D: 'memcpyの最適化時にfast short rep movを使用する'
# 'Use filesystem locks for implicit modules builds to avoid duplicating work in competing clang invocations.'
H0BC43223C7F4: '暗黙のモジュールビルドでファイルシステムロックを使用し、競合するclang呼び出し間での重複作業を回避する'
# 'Use first loadable segment address as base address for offsets in unsymbolized profile. By default first executable segment address is used'
H4F1992DBF3B6: '非シンボル化プロファイルのオフセットのベースアドレスとして最初の読み込み可能なセグメントアドレスを使用する。デフォルトでは最初の実行可能セグメントアドレスが使用される'
# 'Use full module build paths in the profile counter names for static functions.'
H8EE12193DAD1: '静的関数のプロファイルカウンタ名にモジュールビルドパス全体を使用する'
# 'Use full register names when printing assembly'
HCA77C0C5AF9C: 'アセンブリの出力時に完全なレジスタ名を使用する'
# 'Use full register names when writing assembly output'
H3BE94F5363AA: 'アセンブリ出力を書き込む際に完全なレジスタ名を使用する'
# 'Use global'
HB9509FD003D3: 'グローバルを使用する'
# 'Use global constructors'
HF07EDAA4A037: 'グローバルコンストラクタを使用する'
# 'Use global destructors'
HDD719F630B29: 'グローバルデストラクタを使用する'
# 'Use hardened lowering for jump-table dispatch'
H7DCC0D09290B: 'ジャンプテーブルディスパッチのための強化されたloweringを使用する'
# 'Use heuristics to rank code completion items'
HDEA303833606: 'コード完成アイテムの順位付けにヒューリスティクスを使用する'
# 'Use if conversion pass'
HBFF84704F0B4: 'if変換パスを使用する'
# 'Use ifunc global'
H9FA2DD7E729C: 'ifuncグローバルを使用する'
# 'Use indirect register addressing for divergent indexes'
HF60A83099C5E: '分岐するインデックス用に間接レジスタアドレッシングを使用する'
# 'Use inline cost priority.'
H496F98AFF787: 'インラインコストの優先度を使用する'
# 'Use inlined strings rather than string section.'
H7753024EA72C: '文字列セクションの代わりに内包文字列を使用する'
# 'Use instruction-ref based LiveDebugValues with normal DBG_VALUE inputs'
H2DC2FFE65115: '通常のDBG_VALUE入力と共にinstruction-refに基づくLiveDebugValuesを使用する'
# 'Use instrumentation data for profile-guided optimization'
H9DC257CB2810: 'プロファイリングガイド最適化にインストルメンテーションデータを使用する'
# 'Use instrumentation data for profile-guided optimization. If pathname is a directory, it reads from <pathname>/default.profdata. Otherwise, it reads from file <pathname>.'
HDBC8B9085819: 'プロファイリングガイド最適化にインストルメンテーションデータを使用する。pathnameがディレクトリの場合、<pathname>/default.profdataから読み込み、そうでない場合はファイル<pathname>から読み込む。'
# 'Use instrumented (context sensitive) profile to guide PGO.'
HF618D20FE941: '文脈依存プロファイルを使用してPGOをガイドする'
# 'Use instrumented profile to guide PGO.'
H479023987FBB: 'インストルメンテーションプロファイルを使用してPGOをガイドする'
# 'Use internal machine object code emitter.'
H45C76DB103C3: '内部マシンオブジェクトコードエミッタを使用する'
# 'Use jump tables for lowering switches'
HFFDBCF7C79DB: 'スイッチを展開する際にジャンプテーブルを使用する'
# 'Use large-integer access for consecutive bitfield runs.'
HAFC147F2F63A: '連続したビットフィールド実行に対して大規模整数アクセスを使用する'
# 'Use linker features to support dead code stripping of globals'
H25F0988FF38D: 'グローバルのデッドコードストリッピングをサポートするリンカーフEATUREを使用する'
# 'Use loop idiom recognition code size heuristics when compiling with -Os/-Oz'
H16B2DB694C4C: '-Os/-Ozでコンパイルする際にループイディオム認識のコードサイズのヒューリスティックを使用する'
# 'Use masked vector intrinsics'
HD66DB2015BA3: 'マスク付きベクターイントラinsicsを使用する'
# 'Use md5 to represent function names in the output profile (only meaningful for -extbinary)'
HE791F5E32608: '出力プロファイル（-extbinaryでのみ有効）で関数名をMD5で表す'
# 'Use memory profile for profile-guided memory optimization'
H5A1906ADE19C: 'プロファイリングガイドメモリ最適化にメモリプロファイルを使用する'
# 'Use more powerful methods of sharpening expression ranges. May be costly in terms of compile time'
HD0AB27E80870: '式の範囲を厳密化するためのより強力な方法を使用する。コンパイル時間にコストがかかる可能性があります'
# 'Use native PDB reader instead of DIA'
H9315B56556F2: 'DIAの代わりにネイティブPDBリーダーを使用する'
# 'Use new kernel launching API for HIP'
HB4F88B0BE07A: 'HIPの新しいカーネル起動APIを使用する'
# 'Use odr indicators to improve ODR reporting'
H74C4F000003D: 'ODRレポートを改善するためにODRインジケーターを使用する'
# 'Use old-style Thumb2 if-conversion heuristics'
H98BE9934D232: '古いスタイルのThumb2 if変換ヒューリスティックを使用する'
# 'Use one trap block per function'
HAC8964692418: '各関数に対して1つのトラップブロックを使用する'
# 'Use only doxygen-style comments to generate docs.'
H609A25655FBA: 'ドキュメントを生成するにはdoxygenスタイルのコメントのみを使用する'
# 'Use only register numbers when writing assembly output'
H3A4857A621C3: 'アセンブリ出力を書く場合、レジスタ番号のみを使用する'
# "Use optimistic attributes describing 'as-if' properties of runtime calls."
H4E943E97F387: 'ランタイム呼び出しの"as-if"プロパティを説明する楽観的な属性を使用する'
# 'Use packed stack layout (SystemZ only).'
HD83EA715FFB0: 'パックされたスタックレイアウトを使用する (SystemZ専用)'
# 'Use page aliasing in HWASan'
H4A8E0010EDA7: 'HWASanでページエイリアシングを使用する'
# 'Use pipes between commands, when possible'
HE3D5879BAE89: 'コマンド間で可能な場合はパイプを使用する'
# 'Use post increment control-dependent ranges in IndVarSimplify'
H911B15838A45: 'IndVarSimplifyでポストインクリメント制御依存範囲を使用する'
# 'Use predicated EVL instructions for tail folding. If EVL is unsupported, fallback to data-without-lane-mask.'
HED0757D8A6A8: 'テイルフォールディングにpredicated EVL命令を使用する。EVLがサポートされていない場合は、data-without-lane-maskにフォールバックする'
# 'Use preferred fixed label for all labels'
H89BB5704EA97: 'すべてのラベルに対して推奨固定ラベルを使用する'
# 'Use prefix for memory intrinsics in KASAN mode'
HA3237877312E: 'KASANモードのメモリ固有関数にプレフィックスを使用する'
# 'Use private aliases for global variables'
H7796ADF97BE6: 'グローバル変数にプライベートエイリアスを使用する'
# 'Use profi to infer block and edge counts'
H65DAA2E87B9C: 'ブロックとエッジのカウントを推論するためにprofiを使用する'
# 'Use profi to infer block and edge counts.'
H8CD455D93A81: 'ブロックとエッジのカウントを推論するためにprofiを使用する'
# 'Use profile info to add section prefix for hot/cold functions'
HC0D88E37E898: 'ホット/コールド関数にセクションプレフィックスを追加するためにプロファイル情報を使用する'
# 'Use pseudo probes in profile generation'
H0886E88805AB: 'プロファイル生成に疑似プローブを使用する'
# 'Use public LTO visibility for classes in std and stdext namespaces'
H0471C4CC8A6A: 'stdまたはstdext名前空間内のクラスにpublic LTO可視性を使用する'
# 'Use raw weights for labels. Use percentages as default.'
H84E197A50BE8: 'ラベルには生の重みを使用。デフォルトではパーセンテージを使用'
# 'Use register sized accesses to bit-fields, when possible.'
HEC8949CF52C8: '可能な場合、ビットフィールドにレジスタサイズのアクセスを使用'
# 'Use relative paths for invoking subcommands'
HF3DBC88EA771: 'サブコマンドを実行する際の相対パスを使用'
# 'Use release mode (AOT-compiled model)'
H3C1DD2917917: 'リリースモード（AOTコンパイル済みモデル）を使用'
# 'Use ring buffer for stack allocations'
H1D67F21B8816: 'スタック割り当てにリングバッファを使用'
# 'Use rnglists for contiguous ranges if that allows using a pre-existing base address'
H0FA2B904A3EB: '既存のベースアドレスを使用可能にする場合は、連続した範囲にrnglistsを使用'
# 'Use round-robin distribution of functions to modules instead of the default name-hash-based one'
H2DC1323199D5: 'デフォルトの名前ハッシュベースではなく、モジュールへの関数の配分にラウンドロビン方式を使用'
# 'Use row-major layout'
HE68D3A295C31: '行優先配置を使用'
# 'Use runtime alias checks to resolve possible aliasing.'
H74ED44C8AB6B: 'ポテンシャルなエイリアシングを解決するために実行時エイリアスチェックを使用'
# 'Use sampled profile to guide PGO.'
H83EE2F7AD7E3: 'PGOをガイドするためにサンプルプロファイルを使用'
# 'Use sections+offset as references rather than labels.'
HC0250DDB1574: 'ラベルではなく、sections+offsetを参照として使用'
# 'Use segment set for the computation of the live ranges of physregs.'
H297ADEEDAC19: 'physregsの生存範囲の計算にセグメントセットを使用'
# 'Use segmented stack'
H45E75CED74E8: 'セグメントスタックを使用'
# 'Use separate accesses for consecutive bitfield runs with legal widths and alignments.'
HDAEB15795B56: '合法的な幅とアライメントを持つ連続ビットフィールド実行に対して、個別のアクセスを使用'
# 'Use separate unique sections for named sections'
HBA19BDB53714: '名前付きセクションに個別のユニークなセクションを使用'
# 'Use separate unique sections for named sections (ELF Only)'
H966D46021E86: '名前付きセクションに個別のユニークなセクションを使用する（ELFのみ）'
# 'Use shared memory to transfer generated code and data'
H5DE48C3CC472: '共有メモリを使用して生成されたコードとデータを転送する'
# 'Use simple template names in DWARF, or include the full template name with a modified prefix for validation'
HCADD22C917E1: 'DWARFでシンプルなテンプレート名を使用するか、検証用に修正されたプレフィックスを含む完全なテンプレート名を含める'
# 'Use smallest entry possible for jump tables'
H51B906CF7E2B: 'ジャンプテーブルに可能な最小のエントリを使用する'
# 'Use software floating point'
HE54F4CA19BBF: 'ソフトウェア浮動小数点を使用する'
# 'Use specified bytecode when generating output'
H6F1FA0ED25C1: '出力生成時に指定されたバイトコードを使用する'
# 'Use stack probes (default)'
HBB884418570D: 'スタックプローブを使用する（既定）'
# 'Use static debug run-time'
HC2C965E8960E: '静的デバッグランタイムを使用する'
# 'Use static run-time'
H53E3F295A611: '静的ランタイムを使用する'
# 'Use target platform default'
H1C5D924DE4CE: 'ターゲットプラットフォームの既定を使用する'
# 'Use text-based completion if the parser is not ready'
H2FD4CB6E479F: 'パーサーが準備されていない場合、テキストベースの補完を使用する'
# 'Use the AMDGPU specific RPTrackers during scheduling'
HA779151F216B: 'スケジューリング中にAMDGPU固有のRPTrackersを使用する'
# 'Use the AST -> LLVM pipeline to compile'
H4DBFD65A7D65: 'AST -> LLVMパイプラインを使用してコンパイルする'
# 'Use the BLOCK_INFO from the given file'
HF8FF5F8C2E3C: '指定されたファイルからBLOCK_INFOを使用する'
# 'Use the ClangIR pipeline to compile'
H3E61FEC2858B: 'ClangIRパイプラインを使用してコンパイルする'
# 'Use the DFA based hazard recognizer.'
HB08DE21B4CC4: 'DFAベースのハザード認識器を使用する'
# 'Use the FDPIC ABI'
HAD67F08A6522: 'FDPIC ABIを使用する'
# 'Use the Greedy mode (best local mapping)'
H86402D6079EC: 'Greedyモード（最良のローカルマッピング）を使用'
# 'Use the LLVM representation for assembler and object files'
H598F01E104A3: 'アセンブリファイルとオブジェクトファイルに対してLLVM表現を使用する'
# 'Use the MVE code generator for software pipelining'
H07D34F141A55: 'ソフトウェアパイプラインにMVEコード生成器を使用する'
# "Use the basic-block-sections profile to determine the text section prefix for hot functions. Functions with basic-block-sections profile will be placed in `.text.hot` regardless of their FDO profile info. Other functions won't be impacted, i.e., their prefixes will be decided by FDO/sampleFDO profiles."
H7751642AFC12: 'basic-block-sectionsプロファイルを使用して、ホット関数のテキストセクションプレフィックスを決定します。basic-block-sectionsプロファイルを持つ関数は、FDOプロファイル情報に関わらず`.text.hot`に配置されます。他の関数は影響を受けず、そのプレフィックスはFDO/sampleFDOプロファイルで決まります。'
# 'Use the current working directory as the base directory of compiled module files.'
HC4A3722E1C1D: 'コンパイルされたモジュールファイルの基準ディレクトリとして現在の作業ディレクトリを使用する'
# 'Use the current working directory as the home directory of module maps specified by -fmodule-map-file=<FILE>'
H8AE9B0359BD7: '-fmodule-map-file=<FILE>で指定されたモジュールマップのホームディレクトリとして現在の作業ディレクトリを使用する'
# 'Use the dependence analysis interface'
HDF3A2E881A47: '依存関係解析インターフェースを使用する'
# 'Use the experimental C++ class ABI for classes with virtual tables'
HBFD90D3B3FDE: 'バーチャルテーブルを持つクラスに対して実験的なC++クラスABIを使用する'
# 'Use the experimental OpenMP-IR-Builder codegen path.'
H0A44AF245C92: '実験的なOpenMP-IR-Builderコード生成パスを使用する'
# 'Use the experimental peeling code generator for software pipelining'
H14186C9F73CB: 'ソフトウェアパイプラインに実験的なピーリングコード生成器を使用する'
# 'Use the first input module as the merged module'
H8EEE69848E3D: '最初の入力モジュールをマージされたモジュールとして使用する'
# 'Use the full schema for serialization'
HFE88B8373E59: 'シリアライズに完全なスキーマを使用する'
# 'Use the given guard (global, tls) for addressing the stack-protector guard'
H1CBDB2D23600: 'スタックプロテクターガードのアドレス指定に与えられたguard（global、tls）を使用する'
# 'Use the given offset for addressing the stack-protector guard'
H5EC45CECD53A: 'スタックプロテクターガードのアドレス指定に与えられたオフセットを使用する'
# 'Use the given reg for addressing the stack-protector guard'
H2907454E4058: 'スタックプロテクターガードのアドレス指定に与えられたレジスタを使用する'
# 'Use the given symbol for addressing the stack-protector guard'
HB4E7196A5294: 'スタックプロテクターガードのアドレス指定に与えられたシンボルを使用する'
# 'Use the given vector functions library'
H8A7DC0CD5F6E: '与えられたベクターファンクションライブラリを使用する'
# 'Use the given vector functions library. Note: -fveclib={ArmPL,SLEEF} implies -fno-math-errno'
HB6448F1B4907: '指定されたベクタ関数ライブラリを使用します。注: -fveclib={ArmPL,SLEEF} は -fno-math-errno を含むことを示します'
# 'Use the gnu89 inline semantics'
H86341C44D7F1: 'gnu89インラインセマンティクスを使用する'
# "Use the host's platform-specific path separator character when expanding the __FILE__ macro"
H19B5E5B63186: '__FILE__マクロを展開する際にホストのプラットフォーム固有のパス区切り文字を使用'
# 'Use the implementation defaults'
H46CDBE8DC11A: '実装のデフォルトを使用する'
# 'Use the last modification time of <file> as the build session timestamp'
HC4A79FF67275: '<file>の最終変更時刻をビルドセッションのタイムスタンプとして使用'
# 'Use the llvm.experimental.noalias.scope.decl intrinsic during inlining.'
H9063D587CE9C: 'インライン時にllvm.experimental.noalias.scope.declインtrinsicを使用する'
# 'Use the named plugin action in addition to the default action'
H2C8F63F64ACF: '既定のアクションに加えて指定されたプラグインアクションを使用'
# 'Use the named plugin action instead of the default action (use "help" to list available options)'
HEB1C020DB399: '既定のアクションの代わりに指定されたプラグインアクションを使用（利用可能なオプションを表示するには"help"を使用）'
# 'Use the native __fp16 type for arguments and returns (and skip ABI-specific lowering)'
H638090B7484A: '引数と戻り値に対してネイティブの__fp16型を使用（ABI固有の変換をスキップ）'
# 'Use the native half type for __fp16 instead of promoting to float'
HF8914EF176E5: '__fp16に対してネイティブのhalf型を使用し、floatへの昇格を省略'
# 'Use the native platform for the executor.Requires -orc-runtime'
HA522D7482E1A: 'エグゼキューターにネイティブプラットフォームを使用。-orc-runtimeが必要'
# 'Use the new driver for OpenMP offloading.'
H4FEA64EFDBD7: 'OpenMPオフロード用の新しいドライバーを使用'
# 'Use the new driver for offloading compilation.'
H2C38A94F0FE6: 'オフロードコンパイル用の新しいドライバーを使用'
# 'Use the new method of lowering partial reductions.'
H67B6026FF0E7: '部分的な削減の新しいローディング方法を使用'
# 'Use the new offloading linker to perform the link job.'
HBE633D219689: 'リンカジョブに新しいオフロードリンカを使用'
# 'Use the old (incorrect) instruction latency calculation'
H2E61A14D081C: '古い（誤りのある）命令のラテンシ計算を使用'
# 'Use the preinliner decisions stored in profile context.'
HD0A0D412FA60: 'プロファイルコンテクストに保存されたpreinlinerの決定を使用'
# 'Use the remappings described in <file> to match the profile data against names in the program'
HD47D317FB40F: 'プログラム内の名前とプロファイルデータを一致させるために、<file>で説明されたリマッピングを使用します'
# 'Use the scalar evolution interface'
HD228C1FFC83E: 'スカラーエボリューションインターフェースを使用します'
# 'Use the specified contextual profile file'
H21441E080C2A: '指定されたコンテクストプロファイルファイルを使用します'
# 'Use the static host OpenMP runtime while linking.'
H409015ECE8E9: 'リンカ段階で静的ホストOpenMPランタイムを使用します'
# "Use the target's default scheduler choice."
HEF05D039293B: 'ターゲットのデフォルトのスケジューラ選択を使用します'
# "Use the target's platform-specific path separator character when expanding the __FILE__ macro"
H7C74BA846E17: '__FILE__マクロを展開する際に、ターゲットのプラットフォーム固有のパス区切り文字を使用します'
# 'Use the unified LTO pipeline'
H95AFD66F1EAB: '統合LTOパイプラインを使用します'
# 'Use this option to enable basic block coverage instrumentation'
H0CDE08096A2C: '基本ブロックのカバレッジ instrumentation を有効にするためのオプション'
# 'Use this option to enable function entry coverage instrumentation.'
HD78AD2BC6F5D: '関数エントリのカバレッジ instrumentation を有効にするためのオプション'
# 'Use this option to enable temporal instrumentation'
HAB3379855655: '一時的な instrumentation を有効にするためのオプション'
# 'Use this option to turn off/on warnings about function with samples but without debug information to use those samples. '
H511084B41E5F: 'サンプルがあるがデバッグ情報を使用できない関数に関する警告をオフ/オンにするためのオプション'
# 'Use this option to turn off/on warnings about profile cfg mismatch.'
H1D04CE0F6A8E: 'プロファイル CFG 不整合に関する警告をオフ/オンにするためのオプション'
# 'Use this option to turn on/off SELECT instruction instrumentation. '
HDC5EDE7DE3E2: 'SELECT命令の instrumentation を有効/無効にするためのオプション'
# 'Use this option to turn on/off memory intrinsic size profiling.'
HF19744FEF2C8: 'メモリ内蔵関数のサイズプロファイリングを有効/無効にするためのオプション'
# 'Use this option to turn on/off warnings about incorrect usage of llvm.expect intrinsics.'
H3723F53142CC: 'llvm.expect内蔵関数の誤用に関する警告を有効/無効にするためのオプション'
# 'Use this option to turn on/off warnings about missing profile data for functions.'
H78D4B914E121: '関数のプロファイルデータ不足に関する警告を有効/無効にするためのオプション'
# 'Use this to override the target cache line size when specified by the user.'
H43C33F17EAA5: 'ユーザーが指定した場合にターゲットキャッシュラインサイズを上書きするために使用します'
# "Use this to override the target's minimum page size."
HEA1997AE00E5: 'ターゲットの最小ページサイズを上書きする場合に使用します'
# "Use this to override the target's predictable branch threshold (%)."
H9102D958180E: '予測可能な分岐閾値(%)をターゲットが指定する値で上書きするために使用します'
# 'Use this to skip inserting cache invalidating instructions.'
HE32E1CC26F2E: 'キャッシュ無効化命令の挿入をスキップするために使用します'
# 'Use this to specify the default maximum number of instructions to scan backward from a given instruction, when searching for available loaded value'
H673F71583921: '指定された命令から逆方向に探索する際の、利用可能な読み出し値の最大命令数を指定するために使用します'
# 'Use this to specify the default trip count of a loop'
HEB778E135667: 'ループのデフォルト反復回数を指定するために使用します'
# 'Use this to specify the max. distance between array elements accessed in a loop so that the elements are classified to have temporal reuse'
HABE5835F827F: 'ループ内でアクセスされた配列要素間の最大距離を指定し、要素が一時的な再利用性を持つと分類されるようにします'
# 'Use this unroll count for all loops including those with unroll_and_jam_count pragma values, for testing purposes'
HD799D9D7B870: 'テスト目的で、unroll_and_jam_count pragma 値を持つループを含むすべてのループに対してこのアンロールカウントを使用'
# 'Use this unroll count for all loops including those with unroll_count pragma values, for testing purposes'
HEF3DD1B9175D: 'テスト目的で、unroll_count pragma 値を持つループを含むすべてのループに対してこのアンロールカウントを使用'
# 'Use together with -emit-llvm to get pristine LLVM IR from the frontend by not running any LLVM passes at all'
H80E48E5F4285: '-emit-llvmと組み合わせて、LLVMパスを実行せずにフロントエンドから純粋なLLVM IRを取得するため使用'
# 'Use undef when generating programs.'
HD1F883A2CCED: 'プログラム生成時にundefを使用します'
# 'Use unified LTO piplines. Ignored unless -thinlto-bc is also specified.'
H84A36B27E595: '統合型LTOパイプラインを使用します。-thinlto-bcを指定しない場合無効'
# 'Use unique names for basic block sections (ELF Only)'
HDE45C38B60C6: '基本ブロックセクションに一意の名前を使用（ELFのみ有効）'
# 'Use verbose output'
H579A705CE0A4: '詳細出力を使用します'
# 'Use window algorithm after SMS algorithm fails.'
H29FAE7BBDC36: 'SMSアルゴリズムが失敗した場合にウィンドウアルゴリズムを使用します'
# 'Use window algorithm instead of SMS algorithm.'
H0091F49C954B: 'SMSアルゴリズムの代わりにウィンドウアルゴリズムを使用します'
# 'Use with -ast-dump or -ast-print to dump/print only AST declaration nodes having a certain substring in a qualified name. Use -ast-list to list all filterable declaration node names.'
H03F2BB85517F: '-ast-dumpまたは-ast-printと組み合わせ、修飾名に特定のサブ文字列を含むAST宣言ノードのみをダンプ/出力します。-ast-listでフィルタ可能な宣言ノード名の一覧を表示します'
# 'Use zlib'
H7267EE40AF01: 'zlibを使用します'
# 'Use zstd'
HADE0CBD533EE: 'zstdを使用する'
# 'Used for test purpuses'
H143A636D4E4C: 'テスト目的で使用する'
# 'User directory for configuration files'
HD1D0604448D4: '設定ファイル用のユーザー指定ディレクトリ'
# 'User specified cold threshold for instr profile which will override the cold threshold got from profile summary. '
H921527455582: 'ユーザーが指定したcold threshold（instr profile用）で、プロファイルサマリから得られるcold thresholdを上書きします'
# 'User supplied asset path to override the default css and js files for html output'
H11CFB81E3E7B: 'HTML出力のデフォルトcssとjsファイルを上書きするためのユーザー指定のアセットパス'
# 'Uses the source file name instead of the Module hash. This requires that the source filename has a unique name / path to avoid name collisions.'
HEFB279BA9297: 'モジュールハッシュの代わりにソースファイル名を使用します。これは、名前衝突を避けるためにソースファイル名が一意な名前/パスを持っている必要があります'
# 'VALU instruction count threshold for adjusting wave priority'
H323BECA8255D: 'ウェーブ優先度調整用のVALU命令カウント閾値'
# 'VE DAG->DAG Pattern Instruction Selection'
H31A1129B2EDC: 'VE DAG→DAGパターン命令選択'
# 'VLIW scheduler'
H04220C47ABF0: 'VLIW シーデューラ'
# 'Validate PCH input files based on content if mtime differs'
H5B0B3696A2CD: 'mtimeが異なる場合、PCH入力ファイルの内容に基づいて検証する'
# 'Validate PCM input files based on content if mtime differs'
HE7966DE5A8B2: 'mtimeが異なる場合、PCM入力ファイルの内容に基づいて検証する'
# 'Validate that all vtables have type infos in LTO'
H66B413E67029: 'LTOでvtablesがすべて型情報を持っていることを検証する'
# 'Validate the system headers that a module depends on when loading the module'
HEE36D448D56F: 'モジュールを読み込む際に、そのモジュールが依存するシステムヘッダを検証する'
# 'Value for __PIC__'
H760023C619A3: '__PIC__の値'
# 'Value to pass to hot/cold operator new for cold allocation'
H6DAF60C415A6: 'cold割り当て用にhot/coldオペレーターnewに渡す値'
# 'Value to pass to hot/cold operator new for hot allocation'
HD1597DC64127: 'ホット割り当て用にhot/cold operator newに渡す値'
# 'Value to pass to hot/cold operator new for notcold (warm) allocation'
HE0D30EC39F19: 'notcold (warm)割り当て用にhot/cold operator newに渡す値'
# 'Variable.'
H7236856976D0: '変数。'
# 'Vector functions library'
H22962FC6DC51: 'ベクタ関数ライブラリ'
# 'Vectorization cost threshold.'
HCD21FCE9A5E0: 'ベクタライゼーションコストのしきい値'
# 'Vectorize if the invocation count is < than this. 0 disables vectorization.'
H282E25ADE422: '呼び出し回数がこれより少ない場合にベクタライズします。0の場合、ベクタライズは無効になります。'
# 'Vectorize load and Store instructions'
HC110C6BBCB5B: 'LoadとStore命令のベクタライズ'
# 'Vectorize load and store instructions'
HBBECD678BBBC: 'LoadおよびStore命令をベクタライズ'
# 'Vectorize up to this many bundles.'
H5F30F00C03B7: 'この数までのバンドルをベクタライズします。'
# 'Verbosity level of the contextual profile printer pass.'
H635358C62DFB: 'コンテクストプロファイルプリンターパスの出力詳細レベル'
# 'Verbosity of log messages written to stderr'
H2E24D6564DA8: 'stderrに書き込まれるログメッセージの詳細レベル'
# 'Verfiy VPlans after VPlan transforms.'
HE7FC42CC42C7: 'VPlanトランスフォーム後のVPlanの検証'
# 'Verify AMDGPU HSA Metadata'
H65A2759AA257: 'AMDGPU HSAメタデータの検証'
# 'Verify Call Frame Information instructions'
H027197CC37B3: 'Call Frame Information命令の検証'
# 'Verify IR correctness when making sensitive SCEV queries (slow)'
H42A1AB630381: '繊細なSCEVクエリ時にIRの整合性を確認 (遅い)'
# 'Verify PredicateInfo in legacy printer pass.'
H799D5E295653: 'レガシープリンターパスでのPredicateInfoの検証'
# "Verify ScalarEvolution's backedge taken counts (slow)"
HA5864D8AB4F8: 'ScalarEvolutionのバックエッジ実行回数の検証（遅い）'
# 'Verify after each transform'
H357D460E1502: '各変換後の検証'
# 'Verify device memory post execution against the original output.'
HE16F0A0EAC54: '実行後のデバイスメモリを元の出力と照合して検証'
# 'Verify diagnostic output using comment directives that start with prefixes in the comma-separated sequence <prefixes>'
HC54A2E24270E: 'コンマ区切りのシーケンス<prefixes>で指定されたプレフィックスから始まるコメントディレクティブを使用した診断出力の検証'
# 'Verify dominator info (time consuming)'
H7265FCA24E7A: '支配情報の検証（時間がかかる）'
# 'Verify domtree after unrolling'
H9FB6F655E747: 'アンロール後のdomtreeの検証'
# 'Verify during register allocation'
HA235BE2313EF: 'レジスタ割り当て中の検証'
# 'Verify generated machine code'
HAB7C952A6204: '生成されたマシンコードの検証'
# 'Verify legalizations'
H442690F32499: '合法化の検証'
# 'Verify legalizations and artifact combines'
H810B83C40C92: '合法化とアーティファクトの組み合わせの検証'
# 'Verify loop info (time consuming)'
H7C86EDFCE360: 'ループ情報の検証（時間がかかる）'
# 'Verify loop lcssa form (time consuming)'
H0CAAF184E14A: 'ループのLCSSA形式の検証（時間がかかる）'
# 'Verify loopinfo after unrolling'
H03E2A3EBA62D: 'アンロール後のループ情報の検証'
# 'Verify loops generated Loop Idiom Vectorize Pass.'
H8FE13960BD12: 'Loop Idiom Vectorize Passによって生成されたループの検証'
# 'Verify machine code after expanding ARM pseudos'
H4928DCB0BD05: 'ARM の疑似命令を展開後のマシンコードを検証'
# 'Verify machine dominator info (time consuming)'
H7DB30C69D5DA: 'マシンドミネーター情報を検証 (時間がかかる)'
# 'Verify machine instrs before and after machine scheduling'
H13FA77C833AC: 'マシンスケジューリング前後のマシン命令を検証'
# 'Verify machine instrs before and after register coalescing'
HDD83DA18C7C7: 'レジスタの統合前後のマシン命令を検証'
# 'Verify region info (time consuming)'
H9292DD1C4B56: 'リージョン情報を検証 (時間がかかる)'
# 'Verify sanity of PHI instructions during taildup'
H0D6EE6D76E64: 'taildup 時に PHI 命令の整合性を検証'
# 'Verify that computeKnownBits() and SimplifyDemandedBits() are consistent'
HD464B311F8B5: 'computeKnownBits() と SimplifyDemandedBits() が整合していることを検証'
# 'Verify that debug locations are handled'
H5157BEF03DC8: 'デバッグロケーションが適切に処理されていることを検証'
# 'Verify that narrow int args are properly extended per the SystemZ ABI.'
H7B81C58E5DE9: 'SystemZ ABI に従い、狭い整数引数が適切に拡張されていることを検証'
# 'Verify that the generated patterns are ordered by increasing latency'
HB35BF620F949: '生成されたパターンが遅延の増加に従って並べ替えられていることを検証'
# 'Verify the binary representation of debug output'
HD5EDEFE1C648: 'デバッグ出力のバイナリ表現を検証'
# 'Verify the detected SCoPs after each transformation'
H577B4C82C33A: '各変換後に検出された SCoPs を検証'
# 'Verify the function generated by Polly'
H36FACBAA370A: 'Polly によって生成された関数を検証'
# 'Verify this pass produces no dead code'
HD157362652B5: 'この pass がデッドコードを生成しないことを検証'
# 'Version loops if flattened loop could overflow'
H2ED0232BC13B: 'フラット化されたループがオーバーフローする可能性がある場合、ループのバージョンを生成'
# 'View BFI after MIR loader'
H70176654BA61: 'MIRローダー後のBFIを表示'
# 'View BFI before MIR loader'
HD24CF0251C0D: 'MIRローダー前のBFIを表示'
# 'View Options'
HDA1AEDD5C0C0: 'オプションを表示'
# 'View call graph'
HC3CF5708A682: 'コールグラフを表示'
# 'View dominance tree of function'
H8CAAE8FCD27E: '関数の優勢木を表示'
# 'View dominance tree of function (with no function bodies)'
HB12C18D29169: '関数の優勢木を表示（関数本文を含まない）'
# 'View postdominance tree of function'
H5144E7801A69: '関数の後方優勢木を表示'
# 'View postdominance tree of function (with no function bodies)'
H6016FE3E7B20: '関数の後方優勢木を表示（関数本文を含まない）'
# 'View regions of function'
HC65478A71B23: '関数の領域を表示'
# 'View regions of function (with no function bodies)'
H5ECE0F8FFA1A: '関数の領域を表示（関数本文を含まない）'
# 'View the CFG before DFA Jump Threading'
H7CED97AC3765: 'DFAジャンプスレッディング前の制御フローグラフ（CFG）を表示'
# 'View the dependency graph.'
H4CD0E62026DC: '依存関係グラフを表示'
# 'Viewing options'
H4109B1BD7A45: '表示オプション'
# 'Virtual Register Map'
HBAB873C35568: 'バーチャルレジスタマップ'
# 'Virtual Register Rewriter'
H70230BEE99F4: 'バーチャルレジスタリライター'
# 'Volatile loads and stores have acquire and release semantics'
HA2D66EAC62AA: 'volatile読み出しと書き込みには取得と解放のセマンティクスがあります'
# 'Volatile loads and stores have standard semantics'
H3FC4BC9157CA: 'volatile読み出しと書き込みには標準のセマンティクスがあります'
# 'Volatile specifier.'
H5BCC57A6F6B7: 'volatile修飾子。'
# 'Vreg distance cutoff for insert generation.'
HE65C5AFBE2C8: '挿入生成のVreg距離の閾値。'
# 'Vreg# cutoff for insert generation.'
H69051D37244E: '挿入生成のVreg#の閾値。'
# 'WARNING: This option will replace your input file with the reduced version!'
HA6B4706DBC98: '警告: このオプションは、入力ファイルを簡略化されたバージョンで置き換えます!'
# "WARNING: You're attempting to print out a bitcode file.\nThis is inadvisable as it may cause display problems. If\nyou REALLY want to taste LLVM bitcode first-hand, you\ncan force output with the `-f' option.\n\n"
HD29B4F840F03: "警告: ビットコードファイルを表示しようとしています。\nこれには表示上の問題が発生する可能性があります。本当にLLVMビットコードを直接表示する場合は\n`-f'オプションを強制指定してください。\n\n"
# 'Wait for user input before entering JITed code'
HE997D4A27F4E: 'JITコードに入る前にユーザー入力を待つ'
# 'Wait until all forks of instrumented process will finish (use with instrumentation-sleep-time option)'
H29419FC27D66: 'インストルメンテーションされたプロセスのすべてのフォークが終了するまで待機（instrumentation-sleep-timeオプションと併用）'
# 'Warn for mismatching a signed and unsigned value'
H2A8E011548FA: '符号付きと符号なしの値の不整合を検出時に警告'
# 'Warn for missing parenthesis around predicate registers'
HE7943720E0D3: '述語レジスタの周りの不足した丸カッコを検出時に警告'
# "Warn for register names that aren't contigious"
HFB31626439DD: '連続していないレジスタ名を検出時に警告'
# 'Warn if a function definition returns or accepts an object larger in bytes than a given value'
H8990A87A623D: '関数定義が与えられた値以上のバイト数のオブジェクトを返すまたは受け取る場合に警告'
# 'Warn in ARM, emit implicit ITs in Thumb'
HC57002E0EFBF: 'ARMで、Thumbでは暗黙のITを発行'
# 'Warn in ARM, reject in Thumb'
H4EFFA07355E3: 'ARMで、Thumbでは拒否'
# 'Warn on equivalent symbols in the output symbol list'
H88E497B15A1B: '出力シンボルリスト内の同等のシンボルで警告を表示'
# 'Warn on input symbols missing from output symbol list'
HE4D0B0A892DF: '入力シンボルが输出シンボルリストに存在しない場合に警告を表示'
# 'Warn on language extensions'
HCCA103ACA6B2: '言語拡張機能の使用時に警告を表示'
# 'Warn on use'
HE0ABF7E28126: '使用時に警告を表示'
# 'Warning Options'
HEA0EF30FD9BD: '警告オプション'
# 'Warnings about individual formatting changes needed. Used only with --dry-run or -n'
HA24BD5E41E3E: '個々のフォーマット変更が必要な場合の警告。--dry-run または -n のみで使用'
# 'Warnings detected.'
H9BB1C52DB1D8: '検出された警告'
# 'Warnings to generate.'
H0499BE5B2273: '生成する警告'
# 'Weakly link in the blocks runtime'
H32E4B9C0D02B: 'blocks ランタイムを弱いリンクで結合'
# 'WebAssembly Clean Code After Trap'
H5004FAB71B78: 'WebAssembly Clean Code After Trap'
# 'WebAssembly Emscripten-style exception handling'
HB909CEF50795: 'WebAssembly Emscriptenスタイルの例外処理'
# 'WebAssembly Emscripten-style setjmp/longjmp handling'
HB327E2AC0CF6: 'WebAssembly Emscriptenスタイルのsetjmp/longjmp処理'
# 'WebAssembly Exception Information'
HB914447C6B3D: 'WebAssembly例外情報'
# 'WebAssembly Instruction Selection'
H6897B43BD95A: 'WebAssembly命令選択'
# 'WebAssembly Late Exception Preparation'
H2CE3575C6DB6: 'WebAssembly遅延例外準備'
# 'WebAssembly Lower Emscripten Exceptions / Setjmp / Longjmp'
HBA47203A675C: 'WebAssembly：Emscripten例外/setjmp/longjmpを下位に変換'
# 'WebAssembly Lower RefTypes Int-Ptr Conversions'
HFE0286340D39: 'WebAssembly：参照型のint-ポインタ変換を下位に変換'
# 'WebAssembly Nullify DBG_VALUE_LISTs'
HA5294064B53B: 'WebAssembly：DBG_VALUE_LISTのNULL化'
# 'WebAssembly exception handling'
H886CFE14EC29: 'WebAssembly例外処理'
# 'WebAssembly exception handling (legacy)'
H7E31087C50F3: 'WebAssembly例外処理（旧バージョン）'
# 'WebAssembly peephole optimizations'
H430AF441595E: 'WebAssemblyペアホール最適化'
# 'WebAssembly reference type not allowed in exception specification'
H14B705277A94: 'WebAssembly：例外仕様内で参照型が使用できません'
# 'WebAssembly setjmp/longjmp handling'
H9F0C3575883B: 'WebAssembly setjmp/longjmp処理'
# 'WebAssembly table cannot be declared within a function'
H085E37C320EB: 'WebAssemblyテーブルは関数内に宣言できません'
# 'WebAssembly table must be static'
H23C0F2D20589: 'WebAssemblyテーブルはstaticでなければなりません'
# 'WebAssembly: Disable EH pad-first sort order. Testing purpose only.'
HBC8CFE10E3BC: 'WebAssembly：EH pad-first ソート順序を無効化（テスト用のみ）'
# 'WebAssembly: Disable fallthrough-return optimizations.'
H8B46242EE529: 'WebAssembly：fallthrough-return最適化を無効化'
# 'WebAssembly: output implicit locals in instruction output for test purposes only.'
HBD0CCB517ABD: 'WebAssembly：テスト用に命令出力に暗黙のローカルを出力'
# 'WebAssembly: output stack registers in instruction output for test purposes only.'
HCAF0317DF2F0: 'WebAssembly：テスト用に命令出力にスタックレジスタを出力'
# 'Weight of the branch likely to be taken (default = 2000)'
H39B8B6D520C6: '取り込まれるブランチが優先される重み（デフォルト = 2000）'
# 'Weight of the branch unlikely to be taken (default = 1)'
H2A04B39F2CCF: '取られる可能性の低いブランチの重み（デフォルト = 1）'
# 'What is the maximal lookup depth when trying to check for viability of negation sinking.'
H7F1CA4DE1A48: '否定沈めの可能性をチェックする際の最大探索深さを設定'
# 'What length to truncate vertex labels to '
H3DED4F5FCF91: '頂点ラベルの切り詰め長さを設定'
# 'What to do with the summary when running this pass'
H42E595F78536: 'このパス実行時のサマリーの処理方法'
# 'When -fvisibility-inlines-hidden is enabled, static variables in inline C++ member functions will also be given hidden visibility by default'
HC9E644F8BF87: '-fvisibility-inlines-hiddenが有効な場合、インラインC++メンバー関数内の静的変数もデフォルトでhidden visibilityを設定'
# 'When a diagnostic is emitted on an operation, also print the operation as an attached note'
H2ECC08973193: 'オペレーションで診断が発行された場合、そのオペレーションを添付ノートとして表示'
# 'When a diagnostic is emitted, also print the stack trace as an attached note'
H76C424E9438C: '診断が発行された場合、スタックトレースを添付ノートとして表示'
# 'When creating a PCH, stop PCH generation after #pragma hdrstop.'
HD38248648BFF: 'PCHを作成する際、#pragma hdrstop後にPCH生成を停止'
# 'When dfsan-combine-offset-labels-on-gep and/or dfsan-combine-pointer-labels-on-load are false, this flag can be used to re-enable combining offset and/or pointer taint when loading specific constant global variables (i.e. lookup tables).'
H081A797A7BB7: 'dfsan-combine-offset-labels-on-gepおよび/またはdfsan-combine-pointer-labels-on-loadがfalseの場合、このフラグを設定することで、特定の定数グローバル変数（例: ルックアップテーブル）を読み込む際、オフセットおよび/またはポインタータイントの結合を再有効化できます。'
# 'When discriminating instructions with memory operands, ignore prefetch instructions. This ensures the other memory operand instructions have the same identifiers after inserting prefetches, allowing for successive insertions.'
H7E4D0664626F: 'メモリオペランドを持つ命令を区別する際、prefetch命令を無視します。これにより、prefetchを挿入した後に他のメモリオペランド命令が同じ識別子を保持し、連続した挿入が可能になります。'
# 'When displaying an injected source, display the file content'
H3DDBC39BBF92: '注入されたソースを表示する際、ファイルの内容を表示'
# 'When dumping a SymIndexId, dump the full details of the corresponding record'
HE9EC08CB2E15: 'SymIndexIdをダンプする際、対応するレコードの詳細情報を完全にダンプ'
# 'When dumping debug chunks, show a different section for each chunk'
HFD526CCFAF68: 'デバッグチャンクをダンプする際、各チャンクごとに異なるセクションを表示'
# "When dumping type records for classes, unions, enums, and structs, don't try to resolve forward references"
HBD90D91A2AFF: 'クラス、ユニオン、列挙型、構造体の型レコードをダンプする際、前方参照の解決を試みない'
# 'When epilogue vectorization is enabled, and a value greater than 1 is specified, forces the given VF for all applicable epilogue loops.'
H9B19DBFD9697: 'エピローグベクトル化が有効で、1より大きいVFが指定された場合、該当するすべてのエピローグループに対して指定されたVFを強制的に適用'
# 'When generating a crash reproducer, attempt to generated a reproducer with the smallest pipeline.'
H527701909117: 'クラッシュ再現を作成する際、可能な最小パイプラインを使用した再現を作成しようとします'
# 'When generating nested context-sensitive profiles, always generate extra base profile for function with all its context profiles merged into it.'
H4E82789DA6E1: 'ネストしたコンテキスト依存プロファイルを生成する際、関数とそのすべてのコンテキストプロファイルをマージした基本プロファイルを常に生成します'
# 'When merging conditional stores, do so even if the resultant basic blocks are unlikely to be if-converted as a result'
H33EB082F4E55: '条件付きストアをマージする際、結果の基本ブロックがその結果if変換されない可能性が高い場合でもマージします'
# 'When performing SCEV expansion only if it is cheap to do, this controls the budget that is considered cheap (default = 4)'
H6E8B9FA2EB34: 'SCEV展開をコストが低い場合のみ行う場合、このオプションで「安価」と判定される予算を制御します（デフォルト = 4）'
# 'When performing memory disambiguation checks at runtime do not generate more than this number of comparisons (default = 8).'
HBB48DD13984F: 'メモリアンダミゲーションの実行時チェックで、生成する比較の数をこの数値未満に制限します（デフォルト = 8）'
# 'When printing IR for print-[before|after]{-all} always print a module IR'
HEE9A6FDE189D: 'print-[before|after]{-all}でIRを印刷する際、常にモジュールIRを印刷します'
# 'When printing IR for print-[before|after]{-all} for a loop pass, always print function IR'
HD8F4D915AAB6: 'ループパースのprint-[before|after]{-all}でIRを印刷する際、常に関数IRを印刷します'
# 'When printing IR for print-ir-[before|after]{-all} always print the top-level operation'
H58BBC34B4C5E: 'print-ir-[before|after]{-all}でIRを印刷する際、常にトップレベルのオペレーションを印刷します'
# 'When printing analysis, include information on every instruction'
H27AFC0602C62: '分析情報を印刷する際、すべての命令に関する情報を含める'
# 'When printing machine IR, annotate instructions and blocks with SlotIndexes when available'
H8B62DF7E25E7: 'マシンIRを印刷する際、利用可能な場合SlotIndexesで命令とブロックに注釈を付ける'
# 'When printing the IR after a pass, only print if the IR changed'
H0B8C96DE116C: 'パス後のIRを印刷する際、IRが変更された場合のみ印刷する'
# 'When printing the IR after a pass, only print if the pass failed'
H42128FB51A38: 'パス後のIRを印刷する際、パスが失敗した場合のみ印刷する'
# 'When printing the IR before/after a pass, print file tree rooted at this directory. Use in conjunction with mlir-print-ir-* flags'
HC069026BC657: 'パスの前後でIRを印刷する際、このディレクトリをルートとするファイルツリーを印刷します。mlir-print-ir-*フラグと併用してください'
# 'When set to true, IR files will be processed and printed in their current debug info format, regardless of default behaviour or other flags passed. Has no effect if input IR does not contain debug records or intrinsics. Ignored in llvm-link, llvm-lto, and llvm-lto2.'
H75C824D62FD2: 'trueに設定すると、デバッグ情報のフォーマットは現在の形式で処理され印刷され、デフォルト動作や他のフラグを無視します。入力IRにデバッグレコードや固有表現がない場合、効果はありません。llvm-link、llvm-lto、llvm-lto2では無視されます'
# 'When set to true, const objects with relocatable address values are put into the RO data section.'
H66324957E3F0: 'trueに設定すると、再配置可能なアドレス値を持つconstオブジェクトはROデータセクションに配置されます'
# 'When stubbing functions, replace all uses will null'
HBC6C3A0A1E4B: '関数をスタブ化する際、すべての使用箇所をnullに置き換えます'
# 'When the basic block contains not more than this number of PHI nodes, perform a (faster!) exhaustive search instead of set-driven one.'
H95DC35D4BF29: '基本ブロックが PHI ノードをこれより少ない数含む場合、集合駆動型ではなく（高速な！）網羅的検索を実行します。'
# 'When the option is false, if the target block is in a loop, the promotion will be disallowed unless the promoted counter  update can be further/iteratively promoted into an acyclic  region.'
HFCDA16D52A31: 'このオプションがfalseの場合、ターゲットブロックがループ内にある場合、プロモーションが許可されるのは、プロモートされたカウンターアップデートがさらにイテレーティブに非巡回領域にプロモートできる場合に限ります。'
# 'When this option is on, the annotated branch probability will be emitted as optimization remarks: -{Rpass|pass-remarks}=pgo-instrumentation'
H5E55F3D7A2DD: 'このオプションが有効な場合、注釈された分岐確率は最適化メモとして出力されます：- {Rpass | pass-remarks} = pgo-instrumentation'
# 'When to emit DWARF unwind (EH frame) info'
H0DBCF1BE684C: 'DWARFアンウインド（EHフレーム）情報の出力タイミング'
# 'When to use colors in diagnostics'
HBE3593F16E43: '診断で色を使用するタイミング'
# 'When true, SLP vectorizer bypasses profitability checks based on heuristics and makes vectorization decision via cost modeling.'
H05B0C2731561: 'SLP ベクタライザーが、利益率のヒューリスティック基準のチェックをバイパスし、コストモデルによるベクタライズ決定を行うかどうか。'
# 'When used with filetype=obj, emit an object file which can be used with an incremental linker'
HE96BEC53314D: 'filetype=objと併用した場合、インクリメンタルリンカで使用可能なオブジェクトファイルを出力します'
# 'When used with filetype=obj, relax all fixups in the emitted object file'
H167CB844A0DE: 'filetype=objと併用した場合、生成されるオブジェクトファイルの全フィクスアップを緩和します'
# 'When using -fxray-function-groups, select which group of functions to instrument. Valid range is 0 to fxray-function-groups - 1'
H763EF25FAB59: ' -fxray-function-groups を使用する場合、どのグループの関数をインストルメントするか指定します。有効範囲は0からfxray-function-groups -1まで'
# 'When using a PCH, skip tokens until after a #pragma hdrstop.'
H0A2ABCA96B55: 'PCHを使用する場合、#pragma hdrstop以降のトークンをスキップします'
# 'Where to run polly in the pass pipeline'
H9B2F95971D75: 'ポリがパスパイプラインで実行される場所'
# 'Whether has closed-world assumption at link time'
H99F1999EDDBD: 'リンカータイムでクローズドワールド仮定を使用するかどうか'
# 'Whether inline replay should be applied to the entire Module or just the Functions (default) that are present as callers in remarks during cgscc inlining.'
HD26538F942D7: 'インラインリプレイをモジュール全体に適用するか（デフォルトではcgsccインライン中のリマーカーで呼び出し元として存在する関数のみ）'
# 'Whether inline replay should be applied to the entire Module or just the Functions (default) that are present as callers in remarks during sample profile inlining.'
H694D5B29DF1C: 'サンプルプロファイルインライン中のリマーカーで呼び出し元として存在する関数のみ（デフォルト）か、モジュール全体にインラインリプレイを適用するか'
# 'Whether new header will depend on old header. If true, clang-move will add #include of old header to new header.'
HEAD603DC16D2: '新しいヘッダが古いヘッダに依存するかどうか。trueの場合、clang-moveは新しいヘッダに古いヘッダの#includeを追加します'
# 'Whether old header will depend on new header. If true, clang-move will add #include of new header to old header.'
H3B1BCC2BCADE: '古いヘッダが新しいヘッダに依存するかどうか。trueの場合、clang-moveは古いヘッダに新しいヘッダの#includeを追加します'
# 'Whether or not to compute detailed function properties.'
H665EA58EEFEB: '詳細な関数プロパティを計算するかどうか'
# 'Whether or not to enable features under development for the ML regalloc advisor'
HF0690434B74D: 'MLレジストアロケータアドバイザーの開発中の機能を有効にするかどうか'
# 'Whether or not we should insert assumes of conditions of predicated guards'
H825B30E48FC9: '予測可能ガードの条件にassumeを挿入するかどうか'
# 'Whether or not we should predicate guards expressed as widenable branches to deoptimize blocks'
H3D40391D0BD5: 'デオプティマイズブロックへのwidenable条件分岐を表現するガードを予測可能にするかどうか'
# 'Whether or not we should widen guards  expressed as branches by widenable conditions'
HFD8C2DB7CA08: 'widenable条件を表現する分岐として表現されたガードを拡張するかどうか'
# 'Whether to apply ext-tsp placement for instances w/o profile'
H77F1EF844B16: 'プロファイルなしのインスタンスにext-tsp配置を適用するかどうか'
# 'Whether to build a relocatable precompiled header'
HB03E5614FB01: '再配置可能なプリコンパイルドヘッダを構築するかどうか'
# 'Whether to distribute into a loop that may not be if-convertible by the loop vectorizer'
HB249A06C5F2F: 'ループベクター化で必ずしもif-convertibleでないループに展開するかどうか'
# 'Whether to emit DWARF EH frame entries.'
HDDECD32989A5: 'DWARF EHフレームエントリを生成するかどうか'
# 'Whether to generate default bounds for arrays.'
HA8699205DACC: '配列のデフォルト境界を生成するかどうか'
# 'Whether to minimize added include paths'
HC7C82427C36C: '追加されたインクルードパスを最小化するかどうか'
# 'Whether to perform binary concatenation'
H4B115FCD938B: 'バイナリ結合を実行するかどうか'
# 'Whether to perform binary extraction'
H9D6252A4435A: 'バイナリ抽出を実行するかどうか'
# 'Whether to try to emit Compact Unwind for non canonical entries.'
H55500B1ACFA7: '非標準エントリに対してCompact Unwindを発行するかどうか'
# 'Whether to use the address from fix.box in data clause operations.'
H17A5E7DCB500: 'データ句の操作でfix.boxからアドレスを使用するかどうか'
# 'Whether to use the bareptr calling convention on the host (warning this should be false until the GPU layering is fixed)'
HEF14896C6BC2: 'ホストでbareptrコールコンベンションを使用する（警告：GPUのレイヤリングが修正されるまでfalseにする必要があります）'
# 'Whether to use the bareptr calling convention on the kernel (warning this should be false until the GPU layering is fixed)'
H99F227DA714B: 'カーネルでbareptrコールコンベンションを使用する（警告：GPUのレイヤリングが修正されるまでfalseにする必要があります）'
# 'Whether to use the cost heuristic to make choices as we traverse the search space using the exact solver. Defaulted to on, and if turned off, we will use the node order -- attempting to put the later nodes in the later sched groups. Experimentally, results are mixed, so this should be set on a case-by-case basis.'
HF1BAF3533D97: '検索空間を正確なソルバーを使用して探索する際に、選択にコストヒューリスティックを使用するかどうか。デフォルトは有効。無効にすると、ノード順序を使用し、後続のノードを後続のスケジュールグループに配置しようとする。実験的に結果はまちまちなので、ケースバイケースで設定する必要があります'
# 'Whether to use the exponential time solver to fit the instructions to the pipeline as closely as possible.'
H086A0DF8B27C: '指数時間のソルバーを使用して、命令をパイプラインに可能な限り近接配置するかどうか'
# 'Whether we should inject new invariants and unswitch them to eliminate some existing (non-invariant) conditions.'
H3C32643D02A0: '既存の非不変条件を削除するために、新しい不変量を注入し、それらをunswitchするかどうか'
# 'Which DWARF linkage-name attributes to emit.'
H09FB4F2415AD: 'どのDWARFリンク名属性を発行するか'
# 'Which dependence analysis should loop fusion use?'
HAD495CD6F62E: 'ループ融合でどの種類の依存関係解析を使用するか'
# "Which overload candidates to show when overload resolution fails. Defaults to 'all'"
H3E34CE4DE5D1: "オーバーロード解決に失敗した場合に表示するオーバーロード候補の選択。デフォルトは'all'"
# 'Which thread-local storage dialect to use for dynamic accesses of TLS variables'
H811A2F4F5EAE: 'TLS変数の動的アクセスにどのスレッド局所貯蔵方言を使用するか'
# 'Which unit to use for fp math'
HE5F83035EE94: '浮動小数点数計算にどの単位を使用するか'
# 'Widen sub-dword constant address space loads in AMDGPUCodeGenPrepare'
HA61656982921: 'AMDGPUCodeGenPrepareでサブdword定数アドレス空間ロードを拡張する'
# 'Widen sub-dword constant address space loads in AMDGPULateCodeGenPrepare'
H16C37A921AE2: 'AMDGPULateCodeGenPrepareでサブdword定数アドレス空間ロードを拡張する'
# "Widen the loop induction variables, if possible, so overflow checks won't reject flattening"
HF84F6515DE2A: '必要に応じてループ誘導変数を拡張し、オーバーフロー検査が平坦化を拒否しないようにする'
# 'Widen uniform 16-bit instructions to 32-bit in AMDGPUCodeGenPrepare'
H46D2473C38FB: 'AMDGPUCodeGenPrepare で一様な 16 ビット命令を 32 ビットに拡張'
# 'Windows exception model'
H86EB91F51633: 'Windows の例外モデル'
# 'With -globals, only dump globals whose name matches the given value'
H08E7C52DD63F: '-globals オプションを使用する場合、指定された値と名前が一致するグローバルのみをダンプ'
# 'With PGO, include profile count in optimization remarks'
HA68492B41822: 'PGO を使用する場合、最適化のメモにプロファイルカウントを含める'
# 'Work around Cortex-A57 Erratum 1742098 (ARM only)'
H2CF5C8E79954: 'Cortex-A57 の Erratum 1742098 (ARM のみ) の回避策'
# 'Work around Cortex-A72 Erratum 1655431 (ARM only)'
HB9954D8E1844: 'Cortex-A72 の Erratum 1655431 (ARM のみ) の回避策'
# 'Work around VLLDM erratum CVE-2021-35465 (ARM only)'
H6484FD8B0341: 'VLLDM の Erratum CVE-2021-35465 (ARM のみ) の回避策'
# 'Work with `--skip-symbolization` or `--unsymbolized-profile` to write/read the offset instead of virtual address.'
H1CA65028F454: 'オフセットを仮想アドレスの代わりに書き込む/読み込むには `--skip-symbolization` または `--unsymbolized-profile` と併用'
# 'Workaround Cortex-A53 erratum 835769 (AArch64 only)'
H479486F0F64D: 'Cortex-A53 の erratum 835769 (AArch64 のみ) の回避策'
# "Wouldn't use segmented stack"
HF45022A557BC: 'セグメントスタックを使用しません'
# 'Write Bitcode'
H6EB243E1EECC: 'Bitcode を書き出す'
# 'Write a compilation database entry per input'
H69BE4C131EAE: '入力ごとにコンパイルデータベースエントリを書き出す'
# 'Write a depfile containing user and system headers'
HDB1957B0249A: 'ユーザーとシステムのヘッダーを含む depfile を書き出す'
# 'Write a depfile containing user headers'
H294C0D501665: 'ユーザーのヘッダーを含む depfile を書き出す'
# 'Write assembly to file for input to assemble jobs'
H7C079FE214C7: 'アセンブルジョブの入力としてファイルにアセンブリを書き出す'
# 'Write current time into COFF output (default)'
HF98DECE931FC: 'COFF出力に現在時刻を書き込む（既定）'
# 'Write debug info in the new non-intrinsic format. Has no effect if --preserve-input-debuginfo-format=true.'
H438D54E25242: '新しい非内蔵形式でデバッグ情報を書き出す。--preserve-input-debuginfo-format=trueを指定した場合は効果なし。'
# 'Write depfile output from -MMD, -MD, -MM, or -M to <file>'
H7F1DEF2B183F: '-MMD/-MD/-MM/-Mによる依存関係ファイルの出力を<file>に書き出す'
# 'Write extracted files to a static archive'
H167164B5BAE5: '静的アーカイブに抽出されたファイルを書き出す'
# 'Write lazy-function executions to a CSV file as (JITDylib, function) pairs'
HEA5DEA15DFD8: 'JITDylibとfunctionペアとしてCSVファイルに遅延関数実行を書き出す'
# 'Write linked LTO module to file before optimize'
HCE5CCE000DB8: '最適化前に最適化前のLTOモジュールをファイルに書き出す'
# 'Write merged LTO module to file before CodeGen'
HD65008F3EA67: 'コード生成前に統合済みLTOモジュールをファイルに書き出す'
# 'Write minimized bitcode to <file> for the ThinLTO thin link only'
H675031C72335: 'ThinLTOスリムリンク時の最小限のビットコードを<file>に書き出す'
# 'Write out individual imports files via InProcessThinLTO. Has no effect unless specified with -thinlto-emit-indexes or -thinlto-distributed-indexes'
H19E7DA782B06: 'InProcessThinLTOを介して個々のインポートファイルを出力する。-thinlto-emit-indexesまたは-thinlto-distributed-indexesと同時に指定されていない場合は効果なし'
# 'Write out individual index and import files for the distributed backend case'
H2A414F2C0CA7: '分散バックエンドケース用に個々のインデックスおよびインポートファイルを出力する'
# 'Write out individual index files via InProcessThinLTO'
H04EFB23839D1: 'InProcessThinLTOを介して個々のインデックスファイルを出力する'
# 'Write output as LLVM assembly'
HC401168D9C72: 'LLVMアセンブリ形式で出力する'
# 'Write output as ThinLTO-ready bitcode'
H81BE69D83D3F: 'ThinLTO準備完了ビットコードとして出力する'
# 'Write output to <file>'
HCABB93CE5040: '出力を<file>に書き出す'
# 'Write output to <file>.'
HA5CAFFC7A76E: '出力を<file>に書き出す。'
# 'Write relative block frequency to function summary '
H61EDFA1BBE67: '関数サマリに相対ブロック頻度を書き出す'
# 'Write summary to given YAML file after running pass'
H2786584E85AF: 'パス実行後に指定されたYAMLファイルにサマリを書き出す'
# 'Write summary to given bitcode or YAML file after running pass. Output file format is deduced from extension: *.bc means writing bitcode, otherwise YAML'
HF422AA3A57C9: 'パス実行後に指定されたビットコードまたはYAMLファイルにサマリを書き出す。出力ファイル形式は拡張子から推論される：*.bcはビットコード形式、それ以外はYAML形式'
# 'Write the previous version of indexed format, to enable some forward compatibility.'
H214BE48CC62F: '一部の将来互換性を有効にするため、以前のバージョンのインデックス形式を書き出す。'
# 'Writes always set the type'
H90F97A092B90: 'タイプを常に設定する'
# 'X86 Call Frame Optimization'
H6C1AD91D1BC8: 'X86 コール フレーム 最適化'
# 'X86 DAG->DAG Instruction Selection'
H7AF1958AB670: 'X86 DAG→DAG 指令選択'
# 'X86 Domain Reassignment Pass'
H208A2EDE1B82: 'X86 ドメイン再割り当て パス'
# 'X86 DynAlloca Expander'
H1CB6E843E202: 'X86 DynAlloca エクスパンダー'
# 'X86 EFLAGS copy lowering'
H478602C51D49: 'X86 EFLAGS コピーの低階層化'
# 'X86 Execution Domain Fix'
HB1A8033FDC96: 'X86 実行ドメイン修正'
# 'X86 FP Stackifier'
HB70E458DAF08: 'X86 FP スタック化'
# 'X86 LVI load hardening'
HE886300056CC: 'X86 LVI ロード強化'
# 'X86 LVI ret hardener'
H7BB1121F99C0: 'X86 LVI ret 強化'
# 'X86 Partial Reduction'
H71421E3EAECA: 'X86 部分削減'
# 'X86 Return Thunks'
HB7A0BD877623: 'X86 リターン サンク'
# 'X86 Speculative Execution Side Effect Suppression'
HAC95FD71C1F3: 'X86 予測実行副作用抑制'
# 'X86 cmov Conversion'
H459397A41EF1: 'X86 cmov 変換'
# 'X86 optimize LEA pass'
HA2592D9DB191: 'X86 LEA 最適化 パス'
# 'X86 pseudo instruction expansion pass'
H90C7B8C811FD: 'X86 準指令展開 パス'
# 'X86 speculative load hardener'
H2A7987566821: 'X86 予測ロード強化'
# 'X86: Disable LEA optimizations.'
H9A76B9360F40: 'X86: LEA 最適化を無効にします。'
# 'X86: Disable Store Forwarding Blocks fixup.'
H182CD9732E25: 'X86: ストア転送ブロックの修正を無効にします。'
# 'X86: Disable Virtual Register Reassignment.'
H12CE3299B81B: 'X86: 仮レジスタ再割り当てを無効にします。'
# 'X86: Number of instructions backward to inspect for store forwarding blocks.'
HEFF525BFF565: 'X86: ストア転送ブロックの検査に逆方向に遡る命令数。'
# 'X86: enable AMX scalarizition.'
HCECBA05C8A45: 'X86: AMX スカラライゼーションを有効にします。'
# 'XCore DAG->DAG Pattern Instruction Selection'
H581ED762EAE6: 'XCore DAG→DAG パターン命令選択'
# 'XRay Tools\n\n  This program consolidates multiple XRay trace processing tools for convenient access.\n'
HFB113E3ACE56: 'XRayツール\n\nこのプログラムは、XRayトレース処理ツールを複数統合し、利便性を向上させたものです。\n'
# 'YAML'
HFFBCB202B09D: 'YAML'
# 'Yaml database created by find-all-symbols'
H338C17AD7D21: 'YAMLデータベース (find-all-symbols によって作成)'
# 'Yaml database, with fuzzy-matched names'
H858A2F00C528: 'YAMLデータベース (あいまい一致した名前を含む)'
# 'Zero initialize globals without default initialization'
H16BF774B86E6: 'デフォルト初期化なしでグローバル変数をゼロ初期化します'
# 'Zero initialize globals without default initialization (default)'
H49398887AE1B: 'デフォルト初期化なしでグローバル変数をゼロ初期化します (デフォルト)'
# 'Zero line numbers.'
HBDDF04B8DE1F: '行番号をゼロに設定します。'
# 'Zero out the discriminator bits for the FS discrimiantor pass beyond this value. The enum values are defined in Support/Discriminator.h'
H86161643B09B: 'FSディスクリミネーターパスのこの値を超えるディスクリミネータービットをゼロに設定します。enum値はSupport/Discriminator.hで定義されています。'
# '[<input file>,...] (deprecated)'
HBAF2C191067E: '([<入力ファイル>,...]) (非推奨)'
# '[<offload kind>-<target triple>,...]'
HE5C00640F67F: '([<オフロード種別>-<ターゲットトリプル>,...])'
# '[<output file>,...] (deprecated)'
H701132FD6E40: '([<出力ファイル>,...]) (非推奨)'
# '[@<file>] [<file> ...]'
HA0A725D8D937: '([@<ファイル>] [<ファイル> ...])'
# '[LICM & MemorySSA] When MSSA in LICM is disabled, this has no effect. When MSSA in LICM is enabled, then this is the maximum number of accesses allowed to be present in a loop in order to enable memory promotion.'
H15A8950FC7AE: '[LICM & MemorySSA] LICM内のMSSAが無効の場合、この設定は無効です。有効の場合、ループ内でメモリープロモーションを有効にするために許可されるアクセスの最大数が設定されます。'
# '[WIP] Tries to hide the latency of host to device memory transfers'
HC6732C3722E0: '[WIP] ホストからデバイスのメモリ転送のレイテンシを隠蔽しようとしています'
# '[[]] attributes are a C++11 extension'
H8246F8EB1C38: '[[]]属性はC++11の拡張機能です'
# '[[]] attributes are a C23 extension'
H65C81736C143: '[[]]属性はC23の拡張機能です'
# '[[]] attributes are incompatible with C standards before C23'
HFCBAAA359BD9: '[[]]属性はC23以前のC規格と互換性がありません'
# '[[]] attributes are incompatible with C++ standards before C++11'
H963EC793AF1E: '[[]]属性はC++11以前のC++規格と互換性がありません'
# '[code to run]'
HBFD9181194E0: '[実行するコード]'
# '[ignorelist file]'
H5547568B1A46: '[無視リスト ファイル]'
# '[input bitcode]...'
H8C715EEC26A7: '[入力bitcode]...'
# '[no]neon is not accepted as modifier, please use [no]simd instead'
H34DCBA8F9AA1: '[no]neonは修飾子として使用できません。[no]simdを使用してください'
# '\\%0 used with no following hex digits'
H4ACD9688DA19: '\\%0は16進数の桁が続きません'
# "\\%0 used with no following hex digits; treating as '\\' followed by identifier"
H34C9A007F8A0: "\\%0に続く16進数の桁がありません; '\\'に続く識別子として扱います"
# '^^ is a reserved operator in OpenCL'
H0C0A23A57F10: '^^はOpenCLの予約済み演算子です'
# '_Atomic cannot be applied to %select{incomplete |array |function |reference |atomic |qualified |sizeless ||integer |}0type %1 %select{|||||||which is not trivially copyable||in C23}0'
H323CC2CB8E5D: '_Atomicは%select{不完全な |配列 |関数 |参照 |アトミック |修飾済み |サイズなし ||整数型 |}0型%1 %select{|||||||コピー可能ではないため||C23では}0使用できません'
# '_GLOBAL_OFFSET_TABLE_'
HE310DB69A9CE: '_GLOBAL_OFFSET_TABLE_'
# '_Pragma takes a parenthesized string literal'
HC3D115F3D6CB: '_Pragmaは括弧付きの文字列リテラルが必要です'
# '__DATA'
H6F22B9326AE7: '__DATA'
# '__LINKEDIT'
H1EA417FFF11E: '__LINKEDIT'
# '__VA_ARGS__ can only appear in the expansion of a C99 variadic macro'
HA5D98E4DA6FF: '__VA_ARGS__はC99可変長マクロの展開中にのみ使用できます'
# '__VA_OPT__ can only appear in the expansion of a variadic macro'
HCDC494FE863F: '__VA_OPT__は可変長マクロの展開中にのみ使用できます'
# '__VA_OPT__ cannot be nested within its own replacement tokens'
H7C3979F48311: '__VA_OPT__は置換トークン内でネストできません'
# '__arm_agnostic("sme_za_state") cannot share ZA state with its caller'
H3F5679E58734: '__arm_agnostic("sme_za_state")は呼び出し元とZA状態を共有できません'
# '__arm_agnostic("sme_za_state") is not supported together with __arm_new("za") or __arm_new("zt0")'
H1551D9BB8B08: '__arm_agnostic("sme_za_state")は__arm_new("za")または__arm_new("zt0")と同時に使用できません'
# '__asm used with no assembly instructions'
H8FE87A3A5F53: '__asmにアセンブリ命令が指定されていません'
# '__block attribute not allowed on declaration with a variably modified type'
H10FB78A8E9A5: '可変長型の宣言に__block属性は使用できません'
# '__block attribute not allowed, only allowed on local variables'
HE188099287CD: '__block属性はローカル変数にのみ使用できます'
# '__block variable %0 cannot be captured in a %select{lambda expression|captured statement}1'
HD7DB9752FAAD: '__block変数%0は%select{lambda式|キャプチャされたステートメント}1内でキャプチャできません'
# '__builtin_btf_type_id argument %0 not a constant'
H48F1BECDC866: '__builtin_btf_type_idの引数%0は定数ではありません'
# '__builtin_longjmp is not supported for the current target'
H53A6EFDFCD17: '__builtin_longjmpは現在のターゲットではサポートされていません'
# "__builtin_mul_overflow does not support 'signed _BitInt' operands of more than %0 bits"
H24B9AB05270A: "__builtin_mul_overflowは%0ビットを超える'signed _BitInt'オペランドをサポートしていません"
# '__builtin_preserve_enum_value argument %0 invalid'
H341194DCABD7: '__builtin_preserve_enum_valueの引数%0は無効です'
# '__builtin_preserve_enum_value argument %0 not a constant'
HCADD1D27CE0B: '__builtin_preserve_enum_valueの引数%0は定数ではありません'
# '__builtin_preserve_field_info argument %0 not a constant'
HA3DE67421A5E: '__builtin_preserve_field_infoの引数%0は定数ではありません'
# '__builtin_preserve_field_info argument %0 not a field access'
H153927D1D427: '__builtin_preserve_field_infoの引数%0はフィールドアクセスではありません'
# '__builtin_preserve_type_info argument %0 invalid'
H92B5B29F2F9A: '__builtin_preserve_type_infoの引数%0は無効です'
# '__builtin_preserve_type_info argument %0 not a constant'
H57FE08B33075: '__builtin_preserve_type_infoの引数%0は定数ではありません'
# '__builtin_setjmp is not supported for the current target'
H08E9B75B93D5: '__builtin_setjmpは現在のターゲットではサポートされていません'
# '__constant__, __device__, and __managed__ are not allowed on non-static local variables'
H4A2DC7998EB3: '__constant__, __device__, および__managed__は静的でないローカル変数には使用できません'
# '__declspec attribute %0 is not supported'
H4B7BDD3DADC0: '__declspec属性%0はサポートされていません'
# '__declspec attributes must be an identifier or string literal'
HBBCBBEE3784E: '__declspec属性は識別子または文字列リテラルでなければなりません'
# '__final is a GNU extension, consider using C++11 final'
H9019DE700CF0: '__finalはGNU拡張機能です。C++11のfinalを使用してください'
# '__grid_constant__ is only allowed on const-qualified kernel parameters'
HDE081328BF07: '__grid_constant__はconst修飾されたカーネルパラメータでのみ使用できます'
# '__has_warning expected option name (e.g. "-Wundef")'
H96068DA3D4D1: '__has_warningはオプション名（例: "-Wundef"）を指定してください'
# '__shared__ local variables not allowed in %select{__device__|__global__|__host__|__host__ __device__}0 functions'
H0BA8A02BD0B3: '__shared__ローカル変数は%select{__device__|__global__|__host__|__host__ __device__}0関数では使用できません'
# "__shared__ variable %0 cannot be 'extern'"
H76DC43AF246B: "__shared__変数%0は'extern'を指定できません"
# '__spirv_backend_service_fun'
HEC37DE49A8CD: '__spirv_backend_service_fun'
# '__sync builtin operation must have natural alignment (consider using __atomic)'
HFAE067F4A98D: '__syncのビルドイン演算には自然アライメントが必要です（__atomicを使用するか検討してください）'
# '__weak attribute cannot be specified on a field declaration'
HAD92983EAEB2: '__weak属性はフィールド宣言に指定できません'
# '__weak attribute cannot be specified on an automatic variable when ARC is not enabled'
HC15AE9021482: '__weak属性はARCが有効でない場合、自動変数に指定できません'
# '`#pragma const_seg` for section %1 will not apply to %0 due to the presence of a %select{mutable field||non-trivial constructor|non-trivial destructor}2'
H8811D5F6122A: '`#pragma const_seg`セクション%1は%select{ミュータブルフィールド||非トレビアルコンストラクタ|非トレビアルデストラクタ}2の存在により、%0には適用されません'
# 'a %select{function|block}0 declaration without a prototype is deprecated %select{in all versions of C|}0'
HA427D7F1B8D9: '%select{関数|ブロック}0のプロトタイプなし宣言は、Cの全バージョンで非推奨です %select{ |とC23ではサポートされません}0'
# "a %select{pack indexing|'decltype'}0 specifier cannot be used in a declarative nested name specifier"
H505B17716528: '%select{パックインデックス|`decltype`}0修飾子は宣言的ネスト名指定子で使用できません'
# 'a concept definition cannot refer to itself'
H3304727AB46C: 'コンセプト定義は自身を参照できません'
# 'a constant expression cannot modify an object that is visible outside that expression'
H91A285505D66: '定数式は、その式の外から見えるオブジェクトを変更できません'
# 'a declarative nested name specifier cannot name an alias template'
H09803710CDAC: '宣言的ネスト名指定子はエイリアステンプレートを名前付けできません'
# 'a firstprivate variable with incomplete type %0'
H893794AB5FB9: '未完全型%0を持つfirstprivate変数'
# 'a friend declaration that befriends a template must contain exactly one type-specifier'
HDEE648B4A187: 'テンプレートを友達として宣言するfriend宣言には正確に1つの型修飾子が必要です'
# 'a function %select{declaration|definition}0 without a prototype is deprecated in all versions of C %select{and is not supported in C23|and is treated as a zero-parameter prototype in C23, conflicting with a %select{previous|subsequent}2 %select{declaration|definition}3}1'
HB3E1938E8933: 'プロトタイプがない関数%select{宣言|定義}0は、すべてのCバージョンで非推奨であり、C23では%select{サポートされません|明示的な0パラメータプロトタイプとして扱われ、%select{以前の|後の}2%select{宣言|定義}3と衝突します}1'
# 'a function type is not allowed here'
HE650A35390C3: '関数型はここで許可されません'
# 'a getter method is needed to perform a compound assignment on a property'
HEDE5FCF91532: 'プロパティへの複合代入にはゲッターメソッドが必要です'
# 'a lambda expression cannot appear in this context'
H979A7AF92A65: 'この文脈ではラムダ式を使用できません'
# 'a lambda expression may not appear inside of a constant expression'
HB0755DD5F929: '定数式内ではラムダ式を使用できません'
# 'a lambda parameter cannot shadow an explicitly captured entity'
H65FE428CB516: 'キャプチャされたエンティティを影付けするラムダパラメータは禁止です'
# 'a lambda with an explicit object parameter cannot be mutable'
HF1252DDC6E4B: '明示的なオブジェクトパラメータを持つラムダ式はmutableにできません'
# 'a lastprivate variable with incomplete type %0'
H8324467E21DA: '不完全な型%0のlastprivate変数'
# 'a linear variable with incomplete type %0'
HE61951ED0B99: '不完全な型%0のlinear変数'
# 'a module can only be re-exported as another top-level module'
H272C723A8726: 'モジュールは別の最上位モジュールとしてのみ再エクスポート可能です'
# 'a non-type template parameter cannot have type %0'
H4D4081CB8796: '非型テンプレートパラメータは型%0を持つことはできません'
# 'a non-type template parameter cannot have type %0 before C++20'
HEEE0AA3066FD: 'C++20以前では非型テンプレートパラメータは型%0を持つことはできません'
# 'a parameter list without types is only allowed in a function definition'
H52BB0DED62AC: '型のないパラメータリストは関数定義内でのみ許可されます'
# 'a parameter pack may not be accessed at an out of bounds index'
H3E85B76262B3: '配列パックの範囲外のインデックスを参照することはできません'
# 'a private variable with incomplete type %0'
H0A7C86E8874A: '不完全な型%0のprivate変数'
# 'a randomized struct can only be initialized with a designated initializer'
H4615845B3A9F: 'ランダム化構造体は指定子初期化子のみで初期化できます'
# 'a reduction list item with incomplete type %0'
H06AA7BC953CB: '不完全な型%0のreductionリスト項目'
# 'a requires expression cannot have an explicit object parameter'
H86B74E3E67C6: 'requires式は明示的なオブジェクトパラメータを持つことはできません'
# 'a requires expression must contain at least one requirement'
HA35998709F70: 'requires式には少なくとも1つの要件が必要です'
# "a space is required between a right angle bracket and an equals sign (use '> =')"
H9BFA1E21C4F4: '右角括弧の後に等号がある場合はスペースが必要です（"> = "を使用）'
# "a space is required between consecutive right angle brackets (use '> >')"
H529B67153B9E: '連続した右角括弧の間にはスペースが必要です（"> > "を使用）'
# 'a static lambda cannot have any captures'
H2E5388A18076: '静的ラムダはキャプチャできません'
# 'a static_assert declaration cannot be a template'
HA1124669302F: 'static_assert宣言はテンプレートとして使用できません'
# 'a template argument list is expected after a name prefixed by the template keyword'
HF4A21ADFAB4E: 'templateキーワードで修飾された名前の後にテンプレート引数リストが必須です'
# 'a type named %0 is hidden by a declaration in a different namespace'
H26CC1C864C4C: '%0という名前の型は、異なる名前空間の宣言によって隠蔽されています'
# 'a type specifier is required for all declarations'
HA2239D7DA67E: '全ての宣言には型指定子が必要です'
# 'a typedef cannot be a template'
H878607247E5C: 'typedefはテンプレートにできません'
# 'absolute value function %0 given an argument of type %1 but has parameter of type %2 which may cause truncation of value'
H2B4AC1EEC989: '絶対値関数%0に型%1の引数が渡されていますが、パラメータは型%2のため、値の切り捨てが発生する可能性があります'
# "abstract class is marked '%select{final|sealed}0'"
H9546D737D23E: "抽象クラスに'%select{final|sealed}0'修飾子が付与されています"
# 'access declarations are deprecated; use using declarations instead'
H3431BA5113E5: 'アクセス宣言は非推奨です；代わりにusing宣言を使用してください'
# 'access qualifier %0 cannot be used for %1 %select{|prior to OpenCL C version 2.0 or in version 3.0 and without __opencl_c_read_write_images feature}2'
HC43552CB1BAC: 'アクセス修飾子%0は%1には使用できません%select{|OpenCL C 2.0以前のバージョン、または3.0で__opencl_c_read_write_images機能がない場合}2'
# 'access qualifier can only be used for pipe and image type'
HCF9598AD42BA: 'アクセス修飾子はpipeと画像型にのみ使用できます'
# 'access specifier can only have annotation attributes'
H00A8BDFCED49: 'アクセス仕様子にはアノテーション属性のみを指定できます'
# 'access specifiers are a clang HLSL extension'
H23D01BBD184F: 'アクセス仕様子はclang HLSL拡張機能です'
# 'accessing a member of an atomic structure or union is undefined behavior'
H1C0790EC0EC6: 'アトミック構造体またはユニオンのメンバーにアクセスすることは未定義動作です'
# 'accessing inaccessible direct base %0 of %1 is a Microsoft extension'
H76AFA5796E64: '直接ベース%0の%1へのアクセスが不可能なのはMicrosoftの拡張機能です'
# "acquiring %0 '%1' requires negative capability '%2'"
HC095E2CF1B84: "%0 '%1' を取得するには、ネガティブなキャパビリティ'%2'が必要です"
# "acquiring %0 '%1' that is already held"
H4DA573668147: "既に保持中の%0 '%1' を再取得しています"
# 'action %0 not compiled in'
HA82E8BAC3ED2: 'アクション%0 はコンパイルされていません'
# "active '%0' clause defined here"
H5264E053D9D8: "アクティブ句'%0'はここに定義されています"
# 'add \'__arm_preserves("za")\' to the callee if it preserves ZA'
HD939B5A83F36: 'calleeがZAを保存する場合は\'__arm_preserves("za")\'を追加してください'
# "add 'constexpr'"
H48500D7C1CF8: "'constexpr'を追加してください"
# "add 'export' here if this is intended to be a module interface unit"
H8499B2C3202C: "これがモジュールインターフェース単位である場合、ここに'export'を追加してください"
# "add 'module;' to the start of the file to introduce a global module fragment"
H1399A9153C66: "ファイルの先頭に'module;'を追加してグローバルモジュールフラグメントを導入します"
# "add 'typename' to treat this using declaration as a type"
H2514B140BEE5: "この using 宣言を型として扱うには 'typename' を追加してください"
# "add 'u8' prefix to form a 'char8_t' string literal"
H8C73CF0B8333: "この 'char8_t' 文字列リテラルを形成するために 'u8' プレフィックスを追加"
# "add 'void' to the parameter list to turn an old-style K&R function declaration into a prototype"
H460C61046151: "古いスタイルの K&R 関数宣言をプロトタイプに変換するにはパラメータリストに 'void' を追加"
# "add a '@synthesize' directive"
H11A117C94448: '@synthesize ディレクティブを追加'
# 'add a deduction guide to suppress this warning'
H4B93D4018373: 'この警告を抑制するには推論ガイドを追加'
# 'add a deprecation attribute to the declaration to silence this warning'
HE29FCC14DCE0: "この警告を無効にするには宣言に 'deprecated' 属性を明示的に追加"
# 'add a pair of parentheses to declare a variable'
H9B65CA134C28: '変数を宣言するために丸括弧を追加'
# 'add a super class to fix this problem'
HD3A4A44147E8: 'この問題を修正するにはスーパークラスを追加'
# 'add a variable name to declare a %0 initialized with %1'
HBF079F80BA92: '変数名を追加して %1 で初期化される %0 を宣言'
# "add an explicit capture of 'this' to capture '*this' by reference"
H44758706CE87: "'*this' を参照としてキャプチャするには 'this' の明示的なキャプチャを追加"
# 'add an explicit instantiation declaration to suppress this warning if %q0 is explicitly instantiated in another translation unit'
HA69020D4B8A0: '%q0 が他の翻訳単位で明示的にインスタンス化されている場合、この警告を抑制するには明示的なインスタンス化宣言を追加'
# 'add any string to tag this execution in the output binary via bolt info section'
HF4F001FFA024: 'bolt情報セクションを介してこの実行をタグ付けするために出力バイナリに任意の文字列を追加'
# 'add basic block instructions as tool tips on nodes'
H4A2F65627544: 'ノードのツールチップとして基本ブロック命令を追加'
# 'add enclosing parentheses to perform a function-style cast'
H3C4C77285B3F: '関数スタイルキャストを実行するには包含用の括弧を追加'
# 'add explicit braces to avoid dangling else'
H912E67080844: 'ダングリング else を回避するには明示的な波括弧を追加'
# 'add masking cost for i1 vectors'
H3E72A2897B81: 'i1 ベクターのマスキングコストを追加'
# "add parentheses after the '!' to evaluate the %select{comparison|bitwise operator}0 first"
H7D8E708D64E0: "この %select{比較|ビット演算子}0 を最初に評価するには '!' の後に括弧を追加"
# 'add parentheses around left hand side expression to silence this warning'
HB1B6850C2A11: '警告を無効化するには左辺式の周りに括弧を追加'
# "add the %select{'require_constant_initialization' attribute|'constinit' specifier}0 to the initializing declaration here"
HFE1D4C8144BF: "この初期化宣言に %select{'require_constant_initialization'属性|'constinit'仕様}0 を追加"
# 'adding %0 to %1 might cause circular dependency in container'
H157957572465: '%0 を %1 に追加すると、コンテナ内で循環依存が発生する可能性があります'
# 'adding %0 to a string does not append to the string'
H98175222693E: '文字列に%0を追加しても、文字列に追加されません'
# 'adding %0 to a string pointer does not append to the string'
HE53429791B46: '文字列ポインタに%0を追加しても、文字列に追加されません'
# 'addition of default argument on redeclaration makes this constructor a %select{default|copy|move}0 constructor'
H540EC7EBFA01: '再宣言時にデフォルト引数を追加すると、このコンストラクタは%select{デフォルト|コピー|ムーブ}0コンストラクタになります'
# 'address argument to atomic builtin cannot be const-qualified (%0 invalid)'
H05DD72B70C0D: '原子的ビルトイン関数のアドレス引数はconst修飾できません (%0無効)'
# 'address argument to atomic builtin must be a pointer %select{|to a non-zero-sized object }1(%0 invalid)'
H25FC8322E786: '原子的ビルトイン関数のアドレス引数は、%select{|非ゼロサイズのオブジェクトへの }1ポインタでなければなりません (%0無効)'
# 'address argument to atomic builtin must be a pointer to 1,2,4,8 or 16 byte type (%0 invalid)'
H8F0926664FBC: '原子的ビルトイン関数のアドレス引数は、1/2/4/8/16バイト型へのポインタでなければなりません (%0無効)'
# 'address argument to atomic builtin must be a pointer to integer or pointer (%0 invalid)'
H05518FC9E223: '原子的ビルトイン関数のアドレス引数は整数またはポインタへのポインタでなければなりません (%0無効)'
# 'address argument to atomic builtin must be a pointer to integer, floating-point or pointer (%0 invalid)'
H4BE1CF542714: '原子的ビルトイン関数のアドレス引数は整数/浮動小数点数/ポインタへのポインタでなければなりません (%0無効)'
# 'address argument to atomic operation must be a pointer to %select{|atomic }0integer (%1 invalid)'
H45F0D7833F1F: '原子演算のアドレス引数は%select{|原子 }0整数へのポインタでなければなりません (%1無効)'
# 'address argument to atomic operation must be a pointer to %select{|atomic }0integer or pointer (%1 invalid)'
HD792403A7931: '原子演算のアドレス引数は%select{|原子 }0整数またはポインタへのポインタでなければなりません (%1無効)'
# 'address argument to atomic operation must be a pointer to %select{|atomic }0integer or supported floating point type (%1 invalid)'
H645D002EEC1B: '原子演算のアドレス引数は%select{|原子 }0整数またはサポート対象の浮動小数点型へのポインタでなければなりません (%1無効)'
# 'address argument to atomic operation must be a pointer to %select{|atomic }0integer, pointer or supported floating point type (%1 invalid)'
HF8B6B0144FE9: '原子演算のアドレス引数は%select{|原子 }0整数、ポインタ、またはサポート対象の浮動小数点型へのポインタでなければなりません (%1無効)'
# 'address argument to atomic operation must be a pointer to _Atomic type (%0 invalid)'
HED971913A5AB: '原子演算のアドレス引数は_Atomic型へのポインタでなければなりません (%0無効)'
# 'address argument to atomic operation must be a pointer to a trivially-copyable type (%0 invalid)'
H0F2B276FBFF5: '原子演算のアドレス引数は簡易コピー可能型へのポインタでなければなりません (%0無効)'
# 'address argument to atomic operation must be a pointer to non-%select{const|constant}0 _Atomic type (%1 invalid)'
H77D9C30AD097: '原子演算のアドレス引数は非-%select{const|定数}0 _Atomic型へのポインタでなければなりません (%1無効)'
# 'address argument to atomic operation must be a pointer to non-const type (%0 invalid)'
HA961ACF648B8: '原子演算のアドレス引数は非const型へのポインタでなければなりません (%0無効)'
# 'address argument to load or store exclusive builtin must be a pointer to 1,2,4 or 8 byte type (%0 invalid)'
H7473631C7DCE: '排他的読み出し/書き込みビルトインのアドレス引数は1/2/4/8バイト型へのポインタでなければなりません (%0無効)'
# 'address argument to nontemporal builtin must be a pointer (%0 invalid)'
H15C0E2A98779: '非テンポラルビルトインのアドレス引数はポインタでなければなりません (%0無効)'
# 'address argument to nontemporal builtin must be a pointer to integer, float, pointer, or a vector of such types (%0 invalid)'
H411242986562: '非テンポラルビルトインのアドレス引数は整数/float/ポインタ、またはそれらのベクタータイプへのポインタでなければなりません (%0無効)'
# "address of %select{'%1'|function '%1'|array '%1'|lambda function pointer conversion operator}0 will always evaluate to 'true'"
H17F3EBE2635E: "「%select{'%1'|関数'%1'|配列'%1'|ラムダ関数ポインタ変換演算子}0」のアドレスは常に'true'になります"
# 'address of %select{bit-field|vector element|property expression|register variable|matrix element}0 requested'
HD8B1334D046A: '%select{ビットフィールド|ベクタ要素|プロパティ式|レジスタ変数|行列要素}0 のアドレスが要求されました'
# "address of non-static constexpr variable %0 may differ on each invocation of the enclosing function; add 'static' to give it a constant address"
HE51DD27041F6: "非静的 constexpr 変数 %0 のアドレスは、包含関数の各呼び出しで異なる可能性があります。定数アドレスを与えるには 'static' を追加してください"
# 'address of overloaded function %0 cannot be cast to type %1'
H358904EBF6FD: 'オーバーロードされた関数 %0 のアドレスを型 %1 にキャストできません'
# 'address of overloaded function %0 cannot be converted to type %1'
HCCA08BC04209: 'オーバーロードされた関数 %0 のアドレスを型 %1 に変換できません'
# 'address of overloaded function %0 cannot be static_cast to type %1'
HE4591559B0BB: 'オーバーロードされた関数 %0 のアドレスを static_cast で型 %1 にできません'
# 'address of overloaded function %0 does not match required type %1'
H11264D1F1C79: 'オーバーロードされた関数 %0 のアドレスは要求された型 %1 と一致しません'
# 'address of overloaded function %0 is ambiguous'
H33C49268724E: 'オーバーロードされた関数 %0 のアドレスは曖昧です'
# 'address space is larger than the maximum supported (%0)'
HFA6456E815BE: 'アドレス空間がサポートされる最大値 (%0) を超えています'
# 'address space is negative'
H7DA3DAA44B98: 'アドレス空間が負の値です'
# 'address taken in non-type template argument for template parameter of reference type %0'
HD465BC48688F: 'テンプレートパラメータの参照型 %0 の非型テンプレート引数でアドレスが取得されました'
# 'address-of operator cannot be applied to a call to a function with unknown return type'
HA9D761CAF77E: '未定義の戻り値型を持つ関数への呼び出しにはアドレス演算子を適用できません'
# 'adjust block counts based on outgoing branch counts'
H117EF7587146: 'ブランチカウントに基づいてブロックカウントを調整'
# 'adjust function counts based on basic blocks execution count'
H14DEF224A29B: 'ベーシックブロックの実行カウントに基づいて関数カウントを調整'
# 'adjust function profile after inlining'
HDCFC372259BA: 'インライン後に関数プロファイルを調整'
# "after modifying system headers, please delete the module cache at '%0'"
H01FFB29D96B3: "システムヘッダーを変更した場合は、モジュールキャッシュを削除してください ('%0')"
# 'aggregate basic samples (without LBR info)'
H9B9419C851BC: 'LBR 情報なしの基本サンプルを集約'
# 'aggregate initialization of type %0 from a parenthesized list of values is a C++20 extension'
H6B5CF381E65A: 'ユーザーが宣言したコンストラクタを持つ型 %0 の集約初期化は C++20 の拡張機能です'
# 'aggregate initialization of type %0 with user-declared constructors is incompatible with C++20'
HC24621DDDD5F: 'ユーザーが宣言したコンストラクタを持つ型 %0 の集約初期化は C++20 と互換性ありません'
# 'aggressive strategy'
H5CB7E66C0F79: 'アグレッシブな戦略'
# 'aggressively inline everything'
HF506129362A1: 'すべてを積極的にインライン化'
# 'aggressively split jump tables section based on usage of the tables'
HF15D48A1547F: 'テーブルの使用状況に基づいてジャンプテーブルセクションを積極的に分割する'
# 'algorithm used to reorder data sections'
H5E8D0AEA074C: 'データセクションの再配置に使用するアルゴリズム'
# 'alias declaration cannot be a pack expansion'
H7E12EB8475DC: 'エイリアス宣言はパック展開であってはなりません'
# 'alias declaration in this context is a C++23 extension'
H91EDBE36B117: 'このコンテキストでのエイリアス宣言はC++23の拡張機能です'
# 'alias declaration in this context is incompatible with C++ standards before C++23'
HC4280923DB99: 'このコンテキストでのエイリアス宣言はC++23以前の標準と互換性がありません'
# 'alias declarations are a C++11 extension'
HE9649A76CF28: 'エイリアス宣言はC++11の拡張機能です'
# 'alias declarations are incompatible with C++98'
H47305448BB21: 'エイリアス宣言はC++98と互換性がありません'
# 'alias definition of %0 after tentative definition'
HBC2E292F4F78: 'tentative 定義後の %0 のエイリアス定義'
# 'alias for --icp-jump-tables-targets'
H3295D8EF4BCC: '--icp-jump-tables-targets のエイリアス'
# 'alias for --indirect-call-promotion-calls-topn'
H056F07540EAC: '--indirect-call-promotion-calls-topn のエイリアス'
# 'alias for --indirect-call-promotion-jump-tables-topn'
H48FD0DD2A352: '--indirect-call-promotion-jump-tables-topn のエイリアス'
# 'alias for --indirect-call-promotion-mispredict-threshold'
H69D659FF6417: '--indirect-call-promotion-mispredict-threshold のエイリアス'
# 'alias for --indirect-call-promotion-topn'
H2CDF1F6846ED: '--indirect-call-promotion-topn のエイリアス'
# 'alias for --indirect-call-promotion-use-mispredicts'
H6632963673FD: '--indirect-call-promotion-use-mispredicts のエイリアス'
# 'alias for -aarch64-streaming-hazard-size'
H6DD0A61F8614: '-aarch64-streaming-hazard-size のエイリアス'
# 'alias for -data'
H18AAC29B91E1: '-data のエイリアス'
# 'alias for -instr_map'
H8C404A340D69: '-instr_map のエイリアス'
# 'alias for -perfdata'
H4AA3F61C654A: '-perfdata のエイリアス'
# 'alias for -symbolize'
HF105886B4E32: '-symbolize のエイリアス'
# 'alias to a variable in a common section is not allowed'
H93F6002973E0: 'common セクション内の変数へのエイリアスは許可されていません'
# 'aliases are not supported on darwin'
H41CBE942EE33: 'darwinではエイリアスはサポートされていません'
# 'align basic blocks'
H546676202A2D: '基本ブロックをアライメント'
# 'align functions at a given value (relocation mode)'
HA06778A68136: '指定された値で関数をアライメント (relocation mode)'
# 'align only blocks with frequency larger than containing function execution frequency specified in percent. E.g. 1000 means aligning blocks that are 10 times more frequently executed than the containing function.'
H9CD01CD0B966: '指定されたパーセンテージ以上に実行頻度が高いブロックのみをアライメントします。例: 1000は、包含関数の実行頻度の10倍以上実行されるブロックをアライメントします。'
# "aligned %select{allocation|deallocation}0 function of type '%1' is %select{only|not}4 available on %2%select{ %3 or newer|}4"
H9703DDF7875E: "アライン済みの%select{割り当て|解放}0関数'%1'は%2%select{ %3以降|}4で%select{のみ|非}4利用可能です"
# 'aligned clause will be ignored because the requested alignment is not a power of 2'
HC3A503B9038C: '要求されたアライメントが2の累乗でないため、アラインメント句は無視されます'
# 'alignment (%0) of thread-local variable %1 is greater than the maximum supported alignment (%2) for a thread-local variable on this target'
H9951DC0F93CA: 'スレッド局所変数%1のアライメント(%0)は、このターゲットでスレッド局所変数にサポートされる最大アライメント(%2)を超えています'
# "alignment is not a power of 2 in '%0'"
HB7B2FF437212: "'%0' におけるアライメントは2の累乗ではありません"
# 'alignment of .text section'
H7D89ABD80F0F: '.text セクションのアライメント'
# 'alignment of 16 bytes for a struct member is not binary compatible with IBM XL C/C++ for AIX 16.1.0 or older'
H79A5A88D17D7: '16バイトのアライメントの構造体メンバーは、IBM XL C/C++ for AIX 16.1.0以前とのバイナリ互換性がありません'
# 'alignof expressions are incompatible with C++98'
H5F21C338A420: 'alignof式はC++98と互換性ありません'
# 'all paths through this function will call itself'
H40E0BDFB048F: 'この関数を通過するすべてのパスが自身を呼び出します'
# "allocate directive specifies %select{default|'%1'}0 allocator while previously used %select{default|'%3'}2"
HC639234B285B: "'allocate'ディレクティブは%select{デフォルト|'%1'}0のアロケータを指定していますが、以前に%select{デフォルト|'%3'}2を使用していました"
# 'allocated size %0 is not a multiple of size %1 of element type %2'
H279696362CDE: '割り当てサイズ%0は要素型%2のサイズ%1の倍数ではありません'
# "allocated with 'new%select{[]|}0' here"
H1AA44259E5AA: "ここでは 'new%select{[]|}0' で割り当て"
# 'allocating an object of abstract class type %0'
H07CDBA71F9A5: '抽象クラス型%0のオブジェクトを割り当てています'
# 'allocation of %select{incomplete|sizeless}0 type %1'
HD40A80B2E772: '%select{未完了|サイズレス}0型%1の割り当て'
# 'allocation performed here was not deallocated%plural{0:|: (along with %0 other memory leak%s0)}0'
H04A2F923450C: 'この場所で行われた割り当ては解放されませんでした%plural{0:|: (%0他のメモリリーク%s0を含む)}0'
# "allocator must be specified in the 'uses_allocators' clause"
H6A6EDC2E2834: "'uses_allocators'句でアロケータを指定する必要があります"
# "allocator with the 'thread' trait access has unspecified behavior on '%0' directive"
HDC686C65C1AA: "'thread'特性を持つアロケータのアクセスは'%0'ディレクティブでは未定義の動作となります"
# "allocators used in 'uses_allocators' clause cannot appear in other data-sharing or data-mapping attribute clauses"
H3D9F65EE1204: "'uses_allocators'句で使用するアロケータは、他のデータ共有またはデータマッピング属性句に出現できません"
# 'allow processing of stripped binaries'
H7C4A1D362E89: 'stripped バイナリの処理を許可する'
# 'allow to snippet generator to generate at most that many configs'
H8A45202314E0: 'スニペット生成器が生成する最大数を指定する'
# "allowable client missing from %0: '%1'"
H1792F22F4481: "%0 に許可されるクライアントが見つかりません: '%1'"
# "allowable clients do not match: '%0' (provided) vs '%1' (found)"
H73C7C1046F8D: "'%0'（提供された）と '%1'（見つかった）が一致しません"
# "already inside '#pragma clang arc_cf_code_audited'"
H490BE327E34C: "既に '#pragma clang arc_cf_code_audited' 内部に存在します"
# "already inside '#pragma clang assume_nonnull'"
H59F0A861C85D: "既に '#pragma clang assume_nonnull' 内部に存在します"
# "already inside '#pragma unsafe_buffer_usage'"
H94EE60235FE3: "既に '#pragma unsafe_buffer_usage' 内部に存在します"
# 'also accessed here'
H4EBEB7641C26: 'ここでもアクセスされています'
# 'also found'
HAE6F7F952B68: '他の場所にも存在'
# 'always apply unchecked-ld-st'
HA7AE478F69D8: '常に非チェック済みロード/ストアを使用'
# 'always perform sctc'
H55817EEE47EB: '常にSCTC（Store-Conditional to Compare）を実行'
# 'always replace exit value whenever possible'
H0EF1BA8B58B0: '可能な限り終了値を常に置換'
# 'always use long jumps/nops for Linux kernel static keys'
H61DBDABC6D73: 'Linuxカーネル静的キーキーでロングジャンプ/ NOPを使用'
# 'always_inline function %0 has new za state'
H42D69F5E4613: 'always_inline 関数 %0 の za ステートが変更されました'
# 'always_inline function %0 has new zt0 state'
HC0C33866F167: 'always_inline 関数 %0 の zt0 ステートが変更されました'
# 'always_inline function %1 and its caller %0 have mismatching %2 attributes'
H623539F9CF4D: 'always_inline 関数 %1 とその呼び出し元 %0 には %2 属性が一致しません'
# 'always_inline function %1 and its caller %0 have mismatching %2 attributes, inlining may change runtime behaviour'
H784367C8E6F8: 'always_inline 関数 %1 とその呼び出し元 %0 の %2 属性が一致せず、インライン化で実行時挙動が変わる可能性があります'
# "always_inline function %1 requires target feature '%2', but would be inlined into function %0 that is compiled without support for '%2'"
H6E58755C709F: "always_inline 関数 %1 はターゲット機能 '%2' を必要としますが、'%2' サポートのない %0 関数にインライン化されます"
# 'ambiguity is between a regular call to this operator and a call with the argument order reversed'
H5C4216FCB55D: 'この演算子への通常の呼び出しと、引数の順序を逆にした呼び出しとのあいだで曖昧さが生じています'
# 'ambiguous candidate function with reversed arguments'
H1A80B7778D2B: '引数が逆転した曖昧な候補関数'
# 'ambiguous cast from base %0 to derived %1:%2'
H7F294DF4B6DC: '基底クラス %0 から派生クラス %1 へのキャストが曖昧です:%2'
# 'ambiguous constructor call when %select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1'
H33854A224B06: '型 %1 の %select{変数のコピー|パラメータのコピー|テンプレートパラメータの初期化|オブジェクトの返却|ステートメント式結果の初期化|オブジェクトのスロー|メンバー部分オブジェクトのコピー|配列要素のコピー|オブジェクトの確保|一時オブジェクトのコピー|基底部分オブジェクトの初期化|ベクタ要素の初期化|値のキャプチャ}0 の際にコンストラクタ呼び出しに曖昧さが生じました'
# 'ambiguous conversion for %select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2'
H1B069BDA73DD: '%select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 による %1 から %2 への変換が曖昧です'
# 'ambiguous conversion from derived class %0 to base class %1:%2'
H64259C430314: '派生クラス %0 から基底クラス %1 への変換が曖昧です:%2'
# 'ambiguous conversion from pointer to member of %select{base|derived}0 class %1 to pointer to member of %select{derived|base}0 class %2:%3'
H3B96453BA992: '%select{基底|派生}0 クラス %1 のメンバーポインタから %select{派生|基底}0 クラス %2 のメンバーポインタへの変換が曖昧です:%3'
# 'ambiguous conversion from type %0 to an integral or unscoped enumeration type'
H78D40490F0F2: '型 %0 を整数型またはスコープなし列挙型に変換する際に曖昧さが生じました'
# 'ambiguous conversion of array size expression of type %0 to an integral or enumeration type'
H568A4E6CFAC2: '配列サイズ式の型 %0 を整数型または列挙型に変換する際に曖昧さが生じました'
# 'ambiguous conversion of delete expression of type %0 to a pointer'
HCF8DE9DD6D85: '型 %0 の delete 式をポインタに変換する際に曖昧さが生じました'
# 'ambiguous deduction for template arguments of %0'
HE14C8899D7D7: '%0 のテンプレート引数の推論に曖昧さが生じました'
# 'ambiguous expansion of macro %0'
H401A5AED8233: 'マクロ %0 の展開が曖昧です'
# "ambiguous marker '%0' is defined here"
HF269BA6422ED: "曖昧なマーカー '%0' はここに定義されています"
# 'ambiguous member function specialization %q0 of %q1'
H6A3405722F76: '%q1 のメンバー関数の特殊化 %q0 が曖昧です'
# 'ambiguous partial specializations of %0'
HDEE2005B7D3C: '%0 の部分的特殊化が曖昧です'
# "ambiguous reference to placeholder '_', which is defined multiple times"
HBD26597B24D2: "複数の場所で定義されているプレースホルダー '_' への曖昧な参照"
# 'ambiguous use of internal linkage declaration %0 defined in multiple modules'
HE31133550012: '%0 の内部リンケージ宣言が複数のモジュールで定義されているため、使用に曖昧さが生じました'
# 'ambiguous vftable component for %0 introduced via covariant thunks; this is an inherent limitation of the ABI'
HB0361B37BEF3: '共変サムクスを介して導入された %0 の vftable コンポーネントが曖昧です。これはABIの固有の制限です'
# 'amdgpu-arch options'
HA34A9F0AE01E: 'amdgpu-arch オプション'
# 'an array type is not allowed here'
HCA0201F3FA96: 'ここでは配列型は使用できません'
# 'an attribute list cannot appear here'
H49F3FA1B7ED5: 'ここでは属性リストを指定できません'
# 'an attribute specifier sequence attached to a structured binding declaration is a C++2c extension'
H9EBA62889A30: '構造化バインディング宣言に付与された属性指定子シーケンスはC++2cの拡張機能です'
# 'an attribute specifier sequence attached to a structured binding declaration is incompatible with C++ standards before C++2c'
H3AB5357520EE: 'C++2c以前のC++規格では、構造化バインディング宣言に属性指定子シーケンスを付与できません'
# 'an explicit object parameter can only appear as the first parameter of a member function'
HB251EBFE2CF5: '明示的なオブジェクトパラメータはメンバ関数の最初のパラメータとしてのみ使用できます'
# 'an explicit object parameter can only appear as the first parameter of the %select{function|lambda}0'
H7FA58E3ABF3F: '明示的なオブジェクトパラメータは%select{関数|ラムダ}0の最初のパラメータとしてのみ使用できます'
# 'an explicit object parameter cannot appear in a %select{constructor|destructor}0'
H75A07B3C23F5: '%select{コンストラクタ|デストラクタ}0には明示的なオブジェクトパラメータを指定できません'
# 'an explicit object parameter cannot appear in a %select{static|virtual|non-member}0 %select{function|lambda}1'
HF679F4DDA00F: '%select{静的|仮想|非メンバー}0 %select{関数|ラムダ}1には明示的なオブジェクトパラメータを指定できません'
# "an explicitly-defaulted %select{copy|move}0 assignment operator may not have 'const'%select{, 'constexpr'|}1 or 'volatile' qualifiers"
HC61798127DDC: "明示的にデフォルト化された%select{コピー|ムーブ}0代入演算子は'const'%select{, 'constexpr'|}1または'volatile'修飾子を指定できません"
# 'an explicitly-defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot be variadic'
HE8693CE23671: '明示的にデフォルト化された%select{デフォルト コンストラクタ|コピー コンストラクタ|ムーブ コンストラクタ|コピー代入演算子|ムーブ代入演算子|デストラクタ}0は可変長パラメータを指定できません'
# 'an explicitly-defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot have default arguments'
H41B0D6AF186A: '明示的にデフォルト化された%select{デフォルト コンストラクタ|コピー コンストラクタ|ムーブ コンストラクタ|コピー代入演算子|ムーブ代入演算子|デストラクタ}0はデフォルト引数を指定できません'
# 'an initializer for a delegating constructor must appear alone'
H5506BF1F155E: 'デリゲートコンストラクタの初期化子は単独でなければなりません'
# 'an inline asm block cannot have an operand which is a bit-field'
HD4AB7ACF49E9: 'インラインアセンブリ ブロックにはビットフィールドをオペランドとして指定できません'
# 'an unevaluated string literal cannot be a user-defined literal'
H7294D821E112: '評価されない文字列リテラルはユーザー定義リテラルにできません'
# 'an unevaluated string literal cannot have an encoding prefix'
HFC8ECFF25368: '評価されない文字列リテラルにはエンコーディングプレフィックスを指定できません'
# "analyzer constraint manager 'z3' is only available if LLVM was built with -DLLVM_ENABLE_Z3_SOLVER=ON"
H156EC948497C: "analyzer constraint manager 'z3'はLLVMを-DLLVM_ENABLE_Z3_SOLVER=ONでビルドした場合にのみ利用可能です"
# "analyzer-config option '%0' has a key but no value"
H5FB74FAA9043: "analyzer-configオプション'%0'は値がありません"
# "analyzer-config option '%0' should contain only one '='"
HC4A2A9D28ED1: "analyzer-configオプション'%0'は1つの'='のみが許可されます"
# 'angle brackets contain both a %select{type|protocol}0 (%1) and a %select{protocol|type}0 (%2)'
H6C951E1E776A: '角括弧内には%select{タイプ|プロトコル}0 (%1)と%select{プロトコル|タイプ}0 (%2)が含まれています'
# 'angle-bracketed include <%0> cannot be aliased to double-quoted include "%1"'
H6DC7B4C3CA94: '角括弧で囲まれたインクルード <%0> は、ダブルクォートで囲まれたインクルード "%1" にエイリアスできません'
# 'annotate %select{%1|anonymous %1}0 with an availability attribute to silence this warning'
H1B283AC48C5C: 'この警告を沈黙させるには、利用可能属性を%select{%1|匿名の%1}0にアノテーション付けしてください'
# "annotating the 'if %select{constexpr|consteval}0' statement here"
HE2CC6E318B60: 'ここに「if %select{constexpr|consteval}0」ステートメントへのアノテーションを追加'
# 'annotating the infinite loop here'
H4CC614D1531D: 'ここに無限ループへのアノテーションを追加'
# 'annotation-type remark to collect count for'
HF59035A1D641: 'アノテーションタイプのリマク：カウント収集のため'
# 'anonymous %select{structs|structs and classes}0 must be %select{struct or union|class}0 members'
HFBD532892EC0: '匿名の%select{構造体|構造体とクラス}0は、%select{構造体またはユニオン|クラス}0のメンバーでなければなりません'
# 'anonymous %select{structs|unions}0 are a Microsoft extension'
HFF401250AB40: '匿名の%select{構造体|ユニオン}0はMicrosoftの拡張機能です'
# 'anonymous %select{struct|union}0 can only contain non-static data members'
H31B46249C247: '匿名の%select{構造体|ユニオン}0は、静的でないデータメンバーのみを含めることができます'
# "anonymous %select{struct|union}0 cannot be '%1'"
HF58A2EC09112: "匿名の%select{構造体|ユニオン}0は'%1'にできません"
# 'anonymous %select{struct|union}0 cannot contain a %select{private|protected}1 data member'
HA1E08BDB3E65: '匿名の%select{構造体|ユニオン}0は、%select{private|protected}1データメンバーを含めることはできません'
# 'anonymous bit-field cannot have a default member initializer'
H71090C776F50: '匿名ビットフィールドにはデフォルトメンバー初期化子を指定できません'
# 'anonymous bit-field cannot have qualifiers'
H6D3AB87CE804: '匿名ビットフィールドには修飾子を指定できません'
# 'anonymous bit-field has negative width (%0)'
HFC2DC27C32DA: '匿名ビットフィールドの幅が負の値です (%0)'
# 'anonymous bit-field has non-integral type %0'
HCAEF6F6FBF6D: '匿名ビットフィールドの型%0は整数型ではありません'
# 'anonymous namespace begins here'
H131F22F8B917: '匿名ネームスペースの開始ここ'
# 'anonymous namespaces cannot be exported'
HD9CECEFAA4C6: '匿名ネームスペースはエクスポートできません'
# 'anonymous non-C-compatible type given name for linkage purposes by %select{typedef|alias}0 declaration after its linkage was computed; add a tag name here to establish linkage prior to definition'
H4E07DEF6B927: 'C互換性のない匿名型が、リンク用の名前を%select{typedef|alias}0宣言によってリンクが計算された後に付与されました。定義前にリンクを確立するために、ここでタグ名を追加してください'
# 'anonymous non-C-compatible type given name for linkage purposes by %select{typedef|alias}0 declaration; add a tag name here'
H5233EEEB5041: 'C互換性のない匿名型が、リンク用の名前を%select{typedef|alias}0宣言によって付与されています。ここでタグ名を追加してください'
# 'anonymous property is not supported'
HBEA1F99304A4: '匿名プロパティはサポートされていません'
# 'anonymous structs are a C11 extension'
H1E3F733CCCB4: '匿名構造体はC11の拡張機能です'
# 'anonymous structs are a GNU extension'
H006E53420443: '匿名構造体はGNU拡張機能です'
# 'anonymous types declared in an anonymous %select{struct|union}0 are an extension'
H3F386C85263B: '匿名の%select{struct|union}0内で宣言された匿名型は拡張機能です'
# 'anonymous union at class scope must not have a storage specifier'
H7518631D05B0: 'クラススコープにある匿名unionはストレージ修飾子を指定できません'
# 'anonymous unions are a C11 extension'
HDFE9E6E6FE09: '匿名unionはC11拡張機能です'
# "anonymous unions at namespace or global scope must be declared 'static'"
H3FE1C37A16FD: "名前空間またはグローバルスコープにある匿名unionは'static'で宣言する必要があります"
# 'append PID to saved profile file name (default: false)'
HFDE8729E14B7: 'プロファイル保存ファイル名にPIDを追加（デフォルト: false）'
# "application of '%select{alignof|sizeof}1' to interface %0 is not supported on this architecture and platform"
H7F7758BA5771: 'インターフェース%0への%select{alignof|sizeof}1の適用は、このアーキテクチャ/プラットフォームでサポートされていません'
# 'apply additional analysis to remove stores (experimental)'
H0FDD6748AD67: 'ストアの削除に追加の解析を適用（実験的）'
# 'apply unchecked-ld-st when the target is definitely within range'
H75826487B47E: 'ターゲットが確実に範囲内にある場合、unchecked-ld-stを適用'
# 'applying attribute %0 to a declaration is deprecated; apply it to the type instead'
H1F568760A093: '宣言に属性%0を適用することは非推奨です；代わりに型に適用してください'
# "architecture '%0' does not support '%1' execution mode"
H341F2DD78603: "アーキテクチャ'%0'には実行モード'%1'がサポートされていません"
# "architectures do not match: '%0' (provided) vs '%1' (found)"
H1E0CF63FB0D6: "アーキテクチャが一致しません: '%0'（指定値） vs '%1'（検出値）"
# 'architectures of the coverage mapping binaries'
HC4DF8B556ACB: 'カバレッジマッピングバイナリのアーキテクチャ'
# 'argument %0 is not an unqualified class type'
H5DB23C0A38DF: '引数%0は修飾されていないクラス型ではありません'
# 'argument %0 must be constant integer 1 or -1'
H4812A4DC04E0: '引数%0は定数整数1または-1でなければなりません'
# 'argument %0 of type %1 with mismatched bound'
HDE368B7DDAF1: '型%1の引数%0が境界不一致です'
# 'argument %0 to %1 must be a 2-bit unsigned literal (i.e. 0, 1, 2 or 3)'
HD2DEDD810BB8: '%1への引数%0は2ビット符号なしリテラルでなければなりません（0, 1, 2, 3のいずれか）'
# "argument %0 to 'preferred_name' attribute is not a typedef for a specialization of %1"
H873B3444BA19: "'preferred_name'属性への引数%0は、%1の特殊化に対するtypedefではありません"
# 'argument %0 value should represent a contiguous bit field'
H004B84FF9E91: '引数%0の値は連続したビットフィールドを表現する必要があります'
# "argument '%0' is deprecated%select{|, use '%2' instead}1"
H549CE16A2419: "引数'%0'は非推奨です%select{|、'%2'を使用してください}1"
# "argument '%0' is deprecated, %1"
HFF8BB35E32E8: "引数 '%0' は非推奨になりました、%1"
# "argument '%0' requires profile-guided optimization information"
HE99C51820EC7: "引数 '%0' にはプロファイリングによる最適化情報が必要です"
# "argument '%select{X|Y|Z}0' to numthreads attribute cannot exceed %1"
H50D13BA82E10: "numthreads属性の引数'%select{X|Y|Z}0'は%1を超過できません"
# "argument '-Ofast' is deprecated; use '-O3 -ffast-math -fstack-arrays' for the same behavior, or '-O3 -fstack-arrays' to enable only conforming optimizations"
HBBD3AEA705D1: "引数 '-Ofast' は非推奨になりました；同じ動作を得るには '-O3 -ffast-math -fstack-arrays' を使用し、または準拠した最適化のみ有効にするには '-O3 -fstack-arrays' を使用してください"
# "argument '-Ofast' is deprecated; use '-O3 -ffast-math' for the same behavior, or '-O3' to enable only conforming optimizations"
H9474F0404E53: "引数 '-Ofast' は非推奨になりました；同じ動作を得るには '-O3 -ffast-math' を使用し、または準拠した最適化のみ有効にするには '-O3' を使用してください"
# "argument may not have 'void' type"
HC935448BE70B: "引数は'void'型をもつことはできません"
# 'argument must be a function'
H4B920E91F120: '引数は関数でなければなりません'
# 'argument must be a string literal%select{| of char type}0'
HE9E2C9450B76: '引数は文字列リテラル%select{| char型の}0でなければなりません'
# "argument not in expected state; expected '%0', observed '%1'"
H081944E631B6: '引数が予期された状態ではありません；%0が予期され、%1が観測されました'
# "argument of OpenMP clause '%0' must reference the same object in all threads"
HD18A730DC43E: "OpenMPの'%0'クラウスの引数は、すべてのスレッドで同じオブジェクトを参照する必要があります"
# 'argument of a linear clause should be of integral or pointer type, not %0'
HDE23CDEBD40A: 'リニアクラウスの引数は整数型またはポインタ型でなければなりませんが、%0です'
# 'argument of a reduction clause of a %0 construct must not appear in a firstprivate clause on a task construct'
HE3DB6952581D: '%0構造体の減少数クラウスの引数は、タスク構造体のfirstprivateクラウスに現れてはなりません'
# 'argument of aligned clause should be array%select{ or pointer|, pointer, reference to array or reference to pointer}1, not %0'
H3A22487A8E2A: 'アラインドクラウスの引数は配列%select{またはポインタ|、ポインタ、配列への参照、またはポインタへの参照}1でなければなりませんが、%0です'
# 'argument required after attribute'
HE013B38B3C7C: '属性の後に引数が必要です'
# 'argument sensitivity is %select{unspecified|private|public|sensitive}0, but it should be %select{unspecified|private|public|sensitive}1'
H086D890B37E5: '引数の感度は%select{unspecified|private|public|sensitive}0ですが、%select{unspecified|private|public|sensitive}1である必要があります'
# 'argument should be a multiple of %0'
H17E1DE63FD3F: '引数は%0の倍数である必要があります'
# 'argument should be a power of 2'
H41CDA1F42637: '引数は2の冪乗である必要があります'
# 'argument should be an 8-bit value shifted by a multiple of 8 bits'
H3C662F06BF97: '引数は8ビット値を8ビットの倍数でシフトした値である必要があります'
# 'argument should be an 8-bit value shifted by a multiple of 8 bits, or in the form 0x??FF'
H188AFDB4C91E: '引数は8ビット値を8ビットの倍数でシフトしたもの、または0x??FFという形式でなければなりません'
# 'argument should be the value 0, 90, 180 or 270'
H8AAE066502E7: '引数は0、90、180、または270の値である必要があります'
# 'argument should be the value 90 or 270'
HE33BB0F80B1B: '引数は90または270のいずれかである必要があります'
# 'argument to #pragma section is not valid for this target: %0'
HC2C201A8E9D6: '#pragma section の引数はこのターゲットには適していません: %0'
# 'argument to %0 must be a constant integer'
H66325C1A3398: '%0 の引数は定数整数でなければなりません'
# "argument to %select{'code_seg'|'section'}1 attribute is not valid for this target: %0"
H35898B1EF5C2: "属性 %select{'code_seg'|'section'}1 の引数はこのターゲットには適していません: %0"
# "argument to '#pragma unroll' should not be in parentheses in CUDA C/C++"
HBE77A0717D85: "CUDA C/C++では '#pragma unroll' の引数に括弧を使用しないでください"
# "argument to '%0' clause must be a %select{non-negative|strictly positive}1 integer value"
H93740956E9C9: "句 '%0' の引数は%select{非負|正}1の整数値でなければなりません"
# "argument to '%0' is missing (expected %1 value%s1)"
HEA17C0D34C2C: "'%0' の引数が不足しています（%1 値%s1が期待されます）"
# "argument to 'gang' clause dimension must be %select{a constant expression|1, 2, or 3: evaluated to %1}0"
H970EFD35B5B1: "'gang' 句の次元は%select{定数式|1, 2, または 3: %1 に評価されました}0でなければなりません"
# "argument to 'operator<=>' %select{cannot be narrowed from type %1 to %2|evaluates to %1, which cannot be narrowed to type %2}0"
HAE154D16E74A: 'operator<=> の引数は%select{型 %1 を型 %2 に狭義変換できません|型 %1 に評価され、型 %2 に狭義変換できません}0'
# "argument to 'sizeof' in %0 call is the same pointer type %1 as the %select{destination|source}2; expected %3 or an explicit length"
H35BB4F2B1E83: "%0 の呼び出しにおける 'sizeof' の引数は、%select{宛先|ソース}2と同じポインタ型 %1 です。%3 または明示的な長さが期待されます"
# 'argument to __builtin_longjmp must be a constant 1'
HE5F0C7B028D7: '__builtin_longjmp の引数は定数1でなければなりません'
# 'argument to __builtin_verbose_trap must %select{be a pointer to a constant string|not contain $}0'
HADE59279CC5F: '__builtin_verbose_trap の引数は%select{定数文字列へのポインタでなければなりません| $ を含んではいけません}0'
# "argument to atomic builtin of type '_BitInt' is not supported"
HB64B7DD3183B: "型 '_BitInt' の atomic 建ち込み関数の引数はサポートされていません"
# 'argument to ptrauth_sign_constant must refer to a global variable or function'
HC3F35A99F4A4: 'ptrauth_sign_constant の引数はグローバル変数または関数を指す必要があります'
# "argument type %0 doesn't match specified %1 type tag %select{that requires %3|}2"
H3BF4CB740E62: '引数の型 %0 は指定された %1 タイプ タグ%select{（%3 を必要とします）|}2と一致しません'
# 'argument type %0 is incomplete'
HAB2CACB541C5: '引数の型 %0 は未完成です'
# 'argument type %0 is not a real floating point type'
H00F62D550C19: '引数の型 %0 は実数浮動小数点型ではありません'
# "argument unused during compilation: '%0'"
HA1050D6985F0: "コンパイル時に使用されなかった引数: '%0'"
# 'argument value %0 is outside the valid range [%1, %2]'
HB96DE207738E: '引数値 %0 は有効範囲 [%1, %2] の外です'
# 'argument value %0 will result in undefined behaviour'
H274A3E69FEAC: '引数値 %0 は未定義動作を引き起こします'
# 'arguments are of different types%diff{ ($ vs $)|}0,1'
HE1B214C1584C: '異なる型の引数%diff{ ($ vs $)|}0,1が指定されています'
# "arguments of '#pragma omp %0' cannot be of reference type %1"
HF10A8B7C87FB: '#pragma omp %0の引数は参照型%1を指定できません'
# "arguments of '#pragma omp %0' must have %select{global storage|static storage duration}1"
H6F3268D97079: '#pragma omp %0の引数には%select{グローバルストレージ|静的ストレージ期間}1が必要です'
# "arguments of OpenMP clause '%0' for 'min' or 'max' must be of %select{scalar|arithmetic}1 type"
HCCCABB9B57BC: "OpenMP句'%0'の'min'または'max'の引数は%select{スカラ|算術}1型でなければなりません"
# "arguments of OpenMP clause '%0' in '#pragma omp %2' directive cannot be of variably-modified type %1"
HCB3B0D762A59: '#pragma omp %2ディレクティブのOpenMP句%0の引数はvariably-modified型%1を指定できません'
# "arguments of OpenMP clause '%0' with bitwise operators cannot be of floating type"
H7CE92A7D3184: 'ビット単位の演算子を持つOpenMP句%0の引数は浮動小数点型を指定できません'
# 'arguments to __annotation must be wide string constants'
H123CD58AB412: '__annotationへの引数はワイド文字列定数でなければなりません'
# "arithmetic involving unrelated objects '%0' and '%1' has unspecified value"
H620CC2CD5C97: "関係ないオブジェクト'%0'と'%1'の算術演算の値は未定義です"
# 'arithmetic on a null pointer treated as a cast from integer to pointer is a GNU extension'
HBFE8701B60FF: '空ポインタの算術演算を整数からポインタへのキャストとして扱うことはGNU拡張です'
# 'arithmetic on a pointer to %select{an incomplete|sizeless}0 type %1'
H81F0120B9A69: '%select{不完全|サイズなし}0型%1へのポインタの算術演算'
# 'arithmetic on addresses of potentially overlapping literals has unspecified value'
H84236342B8A2: 'ポテンシャルに重なるリテラルのアドレス間の算術演算は未定義値になります'
# 'arithmetic on pointer to interface %0, which is not a constant size for this architecture and platform'
H9C9B045DAD4E: 'インターフェース%0へのポインタの算術演算は、このアーキテクチャやプラットフォームでは定数サイズではありません'
# 'arithmetic on%select{ a|}0 pointer%select{|s}0 to void'
H58D09A5B5E7F: 'voidへの%select{ a|}0ポインタ%select{|s}0の算術演算'
# 'arithmetic on%select{ a|}0 pointer%select{|s}0 to void is a GNU extension'
HB4BACD25A732: 'voidへの%select{ a|}0ポインタ%select{|s}0の算術演算はGNU拡張です'
# 'arithmetic on%select{ a|}0 pointer%select{|s}0 to%select{ the|}2 function type%select{|s}2 %1%select{| and %3}2'
H1FD9A476B84E: '%select{ the|}2関数型%select{|s}2 %1%select{|と%3}2への%select{ a|}0ポインタ%select{|s}0の算術演算'
# 'arithmetic on%select{ a|}0 pointer%select{|s}0 to%select{ the|}2 function type%select{|s}2 %1%select{| and %3}2 is a GNU extension'
H94DE585BA344: '%select{ the|}2関数型%select{|s}2 %1%select{|と%3}2への%select{ a|}0ポインタ%select{|s}0の算術演算はGNU拡張です'
# 'array %0 declared here'
HD94D934376D0: 'ここに配列%0が宣言されています'
# "array 'new' cannot have initialization arguments"
H5708CAC5AB7B: '配列用newは初期化引数を指定できません'
# 'array argument is too small; %select{contains %0 elements|is of size %0}2, callee requires at least %1'
H8A66ED6F9EE3: '配列引数は小さすぎます；%select{%0要素を含む|サイズ%0}2、呼び出し元は少なくとも%1が必要です'
# 'array backing %select{initializer list subobject of the allocated object|the allocated initializer list}0 will be destroyed at the end of the full-expression'
H7FC8ADC3508D: '%select{アロケートされたオブジェクトの初期化リストサブオブジェクトの初期化リスト|アロケートされた初期化リスト}0のバックアップ配列は、完全式の終了時に破棄されます'
# 'array bound cannot be deduced from a default member initializer'
H6E170EF5C23C: '配列の境界はデフォルトのメンバー初期化子から推論できません'
# 'array designator cannot initialize non-array type %0'
H0BB48B48E929: '配列指定子は非配列型%0を初期化できません'
# 'array designator index (%0) exceeds array bounds (%1)'
HF8952A3F237D: '配列指定子のインデックス(%0)が配列の境界(%1)を超えています'
# 'array designator range [%0, %1] is empty'
HFAC24EA6FC3D: '配列指定子の範囲[%0, %1]は空です'
# "array designator value '%0' is negative"
H02A61A71BE5A: "配列指定子の値'%0'が負の値です"
# 'array designators are a C99 extension'
H09604E6E8FF6: '配列指定子はC99の拡張機能です'
# 'array has %select{incomplete|sizeless}0 element type %1'
H513D9739D1E9: '配列は要素型%1が%select{不完全|サイズなし}0です'
# 'array index %0 is before the beginning of the array'
HE66AD6A3EEDD: '配列のインデックス%0が配列の先頭より前です'
# 'array index %0 is past the end of the array (that has type %1%select{|, cast to %3}2)'
HB32CD52AC2F7: '配列のインデックス%0が配列の末尾を越えています（型%1%select{|、%3にキャストされた}2）'
# 'array index %0 refers past the last possible element for an array in %1-bit address space containing %2-bit (%3-byte) elements (max possible %4 element%s5)'
H8C89DC3E13D9: '%1ビットアドレス空間内の要素%2ビット（%3バイト）要素を含む配列の最後の可能な要素を越えて、配列のインデックス%0が参照されています（最大%4要素%s5）'
# 'array initializer must be an initializer list%select{| or string literal| or wide string literal}0'
H4C9486DBC430: '配列の初期化子には初期化リスト%select{|または文字列リテラル|またはワイド文字列リテラル}0が必要です'
# 'array is too large (%0 elements)'
H898DDC47DE13: '配列が大きすぎます（%0要素）'
# 'array of %0 type is invalid in OpenCL'
H394630398D52: '%0型の配列はOpenCLでは無効です'
# 'array of abstract class type %0'
HD205577BDFE7: '%0型の抽象クラスの配列は無効です'
# 'array of interface %0 is invalid (probably should be an array of pointers)'
H26CB6BC11BB2: 'インターフェース%0の配列は無効です（おそらくポインタの配列にする必要があります）'
# 'array parameter is missing a nullability type specifier (_Nonnull, _Nullable, or _Null_unspecified)'
HF62708756DE6: '配列パラメータにnullabilityタイプ指定子（_Nonnull、_Nullable、または_Null_unspecified）がありません'
# 'array section %select{lower bound|length}0 is not an integer'
H54C64A3BE980: '配列セクションの%select{下限|長さ}0が整数ではありません'
# "array section %select{lower bound|length}0 is of type 'char'"
H553F40D88798: '配列セクションの%select{下限|長さ}0は「char」型です'
# 'array section does not specify contiguous storage'
HD0B03CAA79AA: '配列セクションは連続したストレージを指定していません'
# 'array section does not specify length for outermost dimension'
HDEBFF7152057: '配列セクションは最外側の次元の長さを指定していません'
# 'array section must be a subset of the original array'
H9DAB88506A15: '配列のセクションは元の配列のサブセットでなければなりません'
# 'array shaping dimension is evaluated to a non-positive value %0'
H6C186AF92991: '配列の形状次元は非正の値%0に評価されました'
# 'array shaping operation dimension is not an integer'
H521C171EF9F9: '配列の形状操作の次元は整数ではありません'
# 'array size expression has incomplete class type %0'
H48253C816CFD: '配列サイズ式は未完了のクラス型%0を持っています'
# 'array size expression must have integral or %select{|unscoped }0enumeration type, not %1'
H46181D36F61E: '配列サイズ式には整数型または%select{|未スコープ }0列挙型が必要です。%1ではありません'
# 'array size expression of type %0 requires explicit conversion to type %1'
H08A74EE986A3: '型%0の配列サイズ式は型%1への明示的な変換が必要です'
# 'array size is negative'
H2357C6CBC81F: '配列サイズが負です'
# 'array size must be specified in new expression with no initializer'
HC377DBA39626: '初期化子のないnew式では配列サイズを指定する必要があります'
# 'array subscript is not an integer'
HCA57C5D6E89C: '配列の添字は整数ではありません'
# "array subscript is of type 'char'"
HF94CCD2B1ECE: "配列の添字の型は'char'です"
# 'array type %0 is not assignable'
H89C95FEC605F: '配列型%0は代入できません'
# 'array types cannot be value-initialized'
HA2673E710254: '配列型は値初期化できません'
# 'array-to-pointer decay of array member without known bound is not supported'
HAB3F18D32404: '既知の境界を有さない配列メンバーの配列からポインタへの変換はサポートされていません'
# "as specified in %select{'collapse'|'ordered'|'collapse' and 'ordered'}0 clause%select{||s}0"
H1ABDD2AD30EB: '%select{「collapse」句|「ordered」句|「collapse」と「ordered」句}0%select{||s}0に指定されていますように'
# 'ascending'
HF393CC9965C7: '昇順'
# 'asm constraint has an unexpected number of alternatives: %0 vs %1'
HF38699D505AA: 'アセンブリ制約の代替案の数が予期せず:%0対%1'
# 'asm operand has incomplete type %0'
HAA2952BA222F: 'アセンブリオペランドは未完了の型%0を持っています'
# 'asm operand name "%0" first referenced here'
H8FB938C946B0: 'アセンブリオペランド名"%0"はここが最初の参照です'
# 'asm-specifier for input or output variable conflicts with asm clobber list'
H99E324C19D00: '入力または出力変数のアセンブリ仕様はアセンブリ破壊リストと衝突しています'
# 'assigning %select{array literal|dictionary literal|numeric literal|boxed expression|<should not happen>|block literal}0 to a weak %select{property|variable}1; object will be released after assignment'
H8FFA1E619C25: '弱い %select{プロパティ|変数}1 に %select{配列リテラル|ディクショナリリテラル|数値リテラル|ボックス化された式|<発生しないべき>|ブロックリテラル}0 を代入しています; 代入後にオブジェクトが解放されます'
# 'assigning %select{field|instance variable}0 to itself'
H9230F521B121: '%select{フィールド|インスタンス変数}0 を自分自身に代入しています'
# 'assigning retained object to %select{weak|unsafe_unretained}0 %select{property|variable}1; object will be released after assignment'
H250CD1E6F903: '保持されたオブジェクトを %select{weak|unsafe_unretained}0 %select{プロパティ|変数}1 に代入しています; 代入後にオブジェクトが解放されます'
# 'assigning retained object to unsafe property; object will be released after assignment'
H8135CA913359: '保持されたオブジェクトをunsafeプロパティに代入しています; 代入後にオブジェクトが解放されます'
# "assigning to 'readonly' return result of an Objective-C message not allowed"
H87457323E0B9: "'読み取り専用' 戻り値へのObjective-Cメッセージの代入は許可されていません"
# 'assigning value of signed enum type %1 to unsigned bit-field %0; negative enumerators of enum %1 will be converted to positive values'
H03B45829D6A4: '符号付き列挙型 %1 の値を符号なしビットフィールド %0 に代入しています; enum %1 の負の列挙子は正の値に変換されます'
# 'assignment of a weak-unavailable object to a __weak object'
H270A68B29DDC: '__weak オブジェクトに利用不可能な弱いオブジェクトを代入しています'
# "assignment to Objective-C's isa is deprecated in favor of object_setClass()"
H4989286009CB: 'Objective-Cのisaへの代入は object_setClass() の使用に廃止予定です'
# 'assignment to cast is illegal, lvalue casts are not supported'
HADC1B6BE18D9: 'キャストへの代入は違法です; 左辺値キャストはサポートされていません'
# 'assignment would change active union member during the initialization of a different member of the same union'
HE419D89C08F2: '同じユニオンの別のメンバーの初期化中に、有効なユニオンメンバーが変更されます'
# 'assume the ABI is never violated'
H2875C70D4F37: 'ABIが違反されないと仮定します'
# 'assumption evaluated to false'
H4B3BD75DFF9D: '仮定がfalseに評価されました'
# 'assumption is ignored because it contains (potential) side-effects'
H2E58C9356572: '仮定は（潜在的な）副作用を含むため無視されました'
# 'at least one argument of MTE builtin function must be a pointer (%0, %1 invalid)'
H9293CC0B9621: 'MTEビルトイン関数の引数の少なくとも1つはポインタでなければなりません（%0, %1 は無効）'
# 'at most one defaultmap clause for each variable-category can appear on the directive'
H95E39CFC8758: '各変数カテゴリごとにディレクティブにdefaultmap句を最大1つだけ記述できます'
# "at most one overload for a given name may lack the 'overloadable' attribute"
H9206D4731FC1: '特定の名前に対して overloadable 属性を欠くオーバーロードは1つだけ可能です'
# "at most three expressions are allowed in '%0' clause in 'target teams ompx_bare' construct"
HC1194A65DC15: "'target teams ompx_bare' 構造の '%0' 句では式を最大3つまで記述できます"
# 'atomic %select{load|store}0 requires runtime support that is not available for this target'
HD7BAEC48A8AF: '原子的 %select{読み出し|書き込み}0 には、このターゲットで利用できないランタイムサポートが必要です'
# "atomic by default property %0 has a user defined %select{getter|setter}1 (property should be marked 'atomic' if this is intended)"
H5A9A236EC6A5: 'デフォルトで原子的なプロパティ %0 にユーザー定義の %select{getter|setter}1 が存在します（意図した場合はプロパティを atomic でマークしてください）'
# "atomic constraint must be of type 'bool' (found %0)"
H69DAA34C1AB6: '原子的制約は bool 型でなければなりません（%0 が見つかりました）'
# 'atomic memory operand must have a power-of-two size'
HB13C6FA40316: 'アトミック メモリ オペランドには2の累乗のサイズが必要です'
# 'atomic property of reference type %0 cannot have non-trivial assignment operator'
HFC34A950A835: '参照型%0のアトミックプロパティには非自明な代入演算子を指定できません'
# "atomic types are not supported in '%0'"
H97C63071B5D3: "'%0'ではアトミック型はサポートされていません"
# 'atomic variable can be %select{assigned|initialized}0 to a variable only in global address space'
HCB0951EAACB6: 'アトミック変数はグローバルアドレス空間内の変数にのみ%select{代入|初期化}0できます'
# 'attempt to call %0 on non-heap %select{object %2|object: block expression|object: lambda-to-function-pointer conversion}1'
H6E5B5738458E: '非ヒープの%select{オブジェクト%2|ブロック式のオブジェクト|ラムダ→関数ポインタ変換のオブジェクト}1の%0を呼び出そうとしました'
# 'attempt to specialize declaration here'
HF06CAF52936D: 'ここでの宣言の特殊化を試みました'
# 'attempt to use a deleted function%select{|: %1}0'
HA9C947D267C4: '削除された関数%select{|: %1}0を使用しようとしました'
# 'attempt to use a poisoned identifier'
H3643F70789A4: '中毒化された識別子を使用しようとしました'
# 'attempting to use the forward class %0 as superclass of %1'
H994AA508EDDF: '%1のスーパークラスとして前方宣言クラス%0を使用しようとしています'
# 'attribute %0 after definition is ignored'
H5CD4712D502F: '定義後の属性%0は無視されます'
# 'attribute %0 can be used only on HLSL intangible type %1'
HF8261011AFDE: '属性%0はHLSLの非物質型%1のみに使用できます'
# 'attribute %0 can only be applied to @protocol definitions, not forward declarations'
H308DB757AA67: '属性%0は@protocol定義にのみ適用でき、前方宣言には使えません'
# 'attribute %0 can only be applied to an OpenCL kernel function'
HCB6BF3FC512F: '属性%0はOpenCLカーネル関数にのみ適用できます'
# 'attribute %0 cannot appear more than once on a declaration'
HB715D0AA3201: '宣言内で属性%0は複数回指定できません'
# 'attribute %0 cannot be applied to %1'
H3AE597187391: '属性%0は%1に適用できません'
# 'attribute %0 cannot be applied to %select{functions|Objective-C method}1 without return value'
H1C83B6EE306A: '戻り値のない%select{関数|Objective-Cメソッド}1には属性%0を適用できません'
# "attribute %0 cannot be applied to a 'void' parameter"
H6A5920736ACF: "'void'パラメータには属性%0を適用できません"
# 'attribute %0 cannot be used as an attribute pack'
HE6BA361D74BF: '属性%0は属性パックとして使用できません'
# 'attribute %0 cannot have an argument list'
HA4D8BF32DC8E: '属性%0には引数リストを指定できません'
# 'attribute %0 does not support argument pack expansion'
H09CC6A21F4B4: '属性%0は引数パック展開をサポートしていません'
# "attribute %0 has no effect when annotating an 'if %select{constexpr|consteval}1' statement"
H409C4714E4F9: "属性 %0 は 'if %select{constexpr|consteval}1' ステートメントを注釈付ける際に効果がありません"
# 'attribute %0 has no effect when annotating an infinite loop'
HB06D2414EAF4: '属性 %0 は無視されました。この属性は無限ループには適用できません'
# 'attribute %0 ignored, because it cannot be applied to a type'
H5708F2759194: '属性 %0 は無視されました。この属性は型には適用できません'
# 'attribute %0 ignored, because it cannot be applied to omitted return type'
H547B25BBFFDA: '属性 %0 は無視されました。この属性は省略された戻り値型には適用できません'
# 'attribute %0 ignored, because it is not attached to a declaration'
H14902C950EC7: '属性 %0 は無視されました。この属性は宣言にアタッチされていません'
# 'attribute %0 is already applied'
HC7BD790A19A9: '属性 %0 は既に適用されています'
# 'attribute %0 is already applied with different arguments'
H11C03822A58E: '属性 %0 は異なる引数で既に適用されています'
# 'attribute %0 is ignored, place it after "%select{class|struct|interface|union|enum|enum class|enum struct}1" to apply attribute to type declaration'
HB89779883F0D: '属性 %0 は無視されました。この属性を適用するには「%select{class|struct|interface|union|enum|enum class|enum struct}1」の後に配置してください'
# "attribute %0 is not supported by '#pragma clang attribute'"
H38205446BD5C: "属性 %0 は '#pragma clang attribute' でサポートされていません"
# 'attribute %0 is supported in the OpenCL version %1%select{| onwards}2'
H50454061E7F3: '属性 %0 は OpenCL バージョン %1%select{|以降}2 でサポートされています'
# "attribute %0 is unsupported in '%1' shaders, requires %select{|one of the following: }2%3"
HFE781A72AFCA: "属性 %0 は '%1' シェーダーではサポートされていません。%select{|以下のいずれかが必要です }2%3"
# 'attribute %0 only applies to %1'
HC6318570485F: '属性 %0 は %1 のみに適用可能です'
# "attribute %0 only applies to a field or parameter of type '%1'"
H552F45F43B85: "属性 %0 は '%1' 型のフィールドまたはパラメータのみに適用可能です"
# 'attribute %0 requires shader model %1 or greater'
H06BEB9F659D8: '属性 %0 はシェーダーモデル %1 以上が必要です'
# 'attribute %0 with %1 arguments requires shader model %2 or greater'
H51393292A866: '引数 %1 を持つ属性 %0 はシェーダーモデル %2 以上が必要です'
# 'attribute %q0 cannot be applied to a deleted function'
HCB37B8A40CF9: '属性 %q0 は削除された関数には適用できません'
# 'attribute %q0 cannot be applied to member of %q1 class'
HFBD033ADD565: '属性 %q0 は %q1 クラスのメンバーには適用できません'
# "attribute '%0' on function does not match previous declaration"
HF59632E17268: "関数の属性 '%0' は前の宣言と一致しません"
# "attribute '%0' on overriding function does not match base declaration"
H19F6EB5D2707: "オーバーライド関数の属性 '%0' は基底宣言と一致しません"
# "attribute '%0' should not be added via type conversion"
HD3474317FB81: "属性 '%0' は型変換を通じて追加すべきではありません"
# "attribute '%select{|target|cpu_specific|cpu_dispatch|target_clones|target_version}0' multiversioned functions do not yet support %select{function templates|virtual functions|deduced return types|constructors|destructors|deleted functions|defaulted functions|constexpr functions|consteval function|lambdas}1"
HF5E6CA9178D8: "属性 '%select{|target|cpu_specific|cpu_dispatch|target_clones|target_version}0' を持つマルチバージョン関数は、%select{関数テンプレート|仮想関数|推論戻り値型|コンストラクタ|デストラクタ|削除関数|デフォルト化関数|constexpr関数|consteval関数|ラムダ}1 のサポートがまだありません"
# "attribute '%select{|target|cpu_specific|cpu_dispatch|target_clones|target_version}0' multiversioning cannot be combined with attribute %1"
HA264FE94729F: "属性 '%select{|target|cpu_specific|cpu_dispatch|target_clones|target_version}0' のマルチバージョン化は、属性 %1 と組み合わせることはできません"
# "attribute 'msvc::constexpr' cannot be applied to the %select{constexpr|consteval|virtual}0 function %1"
HAC0996F3C628: "属性 'msvc::constexpr' は %select{constexpr|consteval|仮想}0 関数 %1 には適用できません"
# "attribute 'readonly' of property %0 restricts attribute 'readwrite' of property inherited from %1"
HEB32CB97F1A3: "属性 'readonly' のプロパティ %0 は、%1 から継承された 'readwrite' 属性を制限します"
# 'attribute declaration must precede definition'
H83850ED606E9: '属性宣言は定義より前に置く必要があります'
# 'attribute is here'
HD14867328E83: '属性はここにあります'
# "attribute is ignored on this statement as it only applies to functions; use '%0' on statements"
H8C71964DA95C: "この文に適用される属性は関数専用です; 文に適用する場合は '%0' を使用してください"
# 'attribute only applies to output parameters'
H05F9B2ABFA42: 'この属性は出力パラメータにのみ適用可能です'
# 'attribute with scope specifier cannot follow default scope specifier'
HFC36C268C353: 'デフォルトのスコープ指定子に続くスコープ指定子は使用できません'
# 'attributes \'%0("%2")\' and \'%1("%2")\' are mutually exclusive'
H56F1BA7862B2: '属性 \'%0("%2")\' と \'%1("%2")\' は排他的です'
# 'attributes cannot be specified on a nested namespace definition'
H4264DC0CBC46: 'ネストされた名前空間定義には属性を指定できません'
# 'attributes cannot be specified on namespace alias'
H4F2E4C4430E8: '名前空間エイリアスには属性を指定できません'
# 'attributes on %select{a namespace|an enumerator}0 declaration are a C++17 extension'
H034995816099: '%select{名前空間|列挙子}0の宣言の属性はC++17の拡張機能です'
# 'attributes on %select{a namespace|an enumerator}0 declaration are incompatible with C++ standards before C++17'
H8BB41AEA1EC6: '%select{名前空間|列挙子}0の宣言の属性はC++17以前のC++規格と互換性ありません'
# 'authenticating a null pointer will almost certainly trap'
HB0AE642AC2E4: 'NULL ポインタを認証するとほぼ確実にトラップします'
# 'auto property synthesis is synthesizing property not explicitly synthesized'
H0B109C7F8F74: 'オートプロパティ合成は明示的に合成されていないプロパティを合成します'
# 'auto property synthesis will not synthesize property %0 because it cannot share an ivar with another synthesized property'
HB5E0DEB40CE6: 'オートプロパティ合成は、他の合成プロパティと共有できない ivar のため、プロパティ %0 を合成しません'
# "auto property synthesis will not synthesize property %0 because it is 'readwrite' but it will be synthesized 'readonly' via another property"
H2BD61AD864B9: 'プロパティ %0 は「readwrite」ですが別のプロパティ経由で「readonly」に合成されるため、オートプロパティ合成は合成しません'
# 'auto property synthesis will not synthesize property %0 declared in protocol %1'
HA0C341D1A812: 'プロトコル %1 で宣言されたプロパティ %0 はオートプロパティ合成では合成されません'
# 'auto property synthesis will not synthesize property %0; it will be implemented by its superclass, use @dynamic to acknowledge intention'
H0457D53851AF: 'プロパティ %0 はスーパークラスで実装されるため、合成されません。意図を明示するには @dynamic を使用してください'
# 'automatic variable qualified with an%select{| invalid}0 address space'
H122ACAE25198: '自動変数が%select{|無効な}0アドレス空間で修飾されています'
# 'autosynthesized property %0 will use %select{|synthesized}1 instance variable %2, not existing instance variable %3'
H4495EA68D322: '自動合成プロパティ%0は、存在しないインスタンス変数%3ではなく、%select{|合成された}1インスタンス変数%2を使用します'
# 'availability does not match previous declaration'
H583F2A1BC062: '利用可能性が以前の宣言と一致しません'
# 'available multilibs are:%0'
H0F052B7170DD: '利用可能なmultilibsは:%0'
# "backend data layout '%0' does not match expected target description '%1'"
H82DEBC38BED7: "バックエンドのデータレイアウト'%0'は、期待されるターゲット記述'%1'と一致しません"
# 'backslash and newline separated by space'
HD4F9A252F950: 'バックスラッシュと改行がスペースで区切られています'
# 'bad receiver type %0'
HE40F679E3605: '不正な受信者型%0'
# "base %0 is marked '%select{final|sealed}1'"
HE6BCB4D05CEC: "基底%0は'%select{final|sealed}1'でマークされています"
# 'base class %0 has %select{private|protected}1 destructor'
HEB04CB913679: '基底クラス%0には%select{private|protected}1修飾子のデストラクタがあります'
# 'base class %0 has a flexible array member'
HD71C5E7037F5: '基底クラス%0には柔軟な配列メンバがあります'
# 'base class %0 is uninitialized when used here to access %q1'
H6E433F27AF21: 'ここでの%q1へのアクセスで使用される基底クラス%0は初期化されていません'
# 'base class %0 specified here'
HE35763C73750: 'ここで指定された基底クラス%0'
# 'base class %0 specified more than once as a direct base class'
HC14516852948: '基底クラス%0は直接基底クラスとして複数回指定されています'
# 'base class has incomplete type'
H4B76670DCEA2: '基底クラスの型が未完了です'
# 'base class initializer %0 names both a direct base class and an inherited virtual base class'
HAE21C251743B: '基底クラス初期化子%0は直接基底クラスと継承された仮想基底クラスの両方を指定しています'
# 'base of member reference is a function; perhaps you meant to call it%select{| with no arguments}0?'
H224FA72A413F: 'メンバ参照の基底は関数です。おそらく、%select{|引数なしで}0呼び出すつもりだったかもしれませんか？'
# 'base specifier must name a class'
HBDBF7667EBAE: '基底指定子はクラスを指定する必要があります'
# 'basic register allocator'
HFEA9765B5A50: '基本レジスタ割り当て'
# 'basic statistics'
HAA78894D50F2: '基本統計情報'
# 'because %select{base class of |field of |}0type %1 has a user-provided %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}2'
HA75BA84DF85B: 'because %select{ベースクラスの |フィールドの |}0型%1は、ユーザー提供の%select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}2があります'
# 'because %select{base class of |field of |}0type %1 has no default constructor'
HC07ABEF26326: 'because %select{ベースクラスの |フィールドの |}0型%1にはデフォルト コンストラクタがありません'
# 'because field %0 has an initializer'
H7DB53EF856A5: 'because フィールド%0には初期化子があります'
# 'because it has a default argument'
H4C6DC4DA1E45: 'because デフォルト引数が存在するため'
# 'because it is a variadic function'
H640DA969741B: 'because 可変長関数であるため'
# 'because its parameter is %diff{of type $, not $|of the wrong type}2,3'
H5CB13170AE2B: 'because %diff{型$のパラメータが、$ではなく|不正な型の}2,3ため'
# 'because no %select{<<ERROR>>|constructor|constructor|assignment operator|assignment operator|<<ERROR>>}2 can be used to %select{<<ERROR>>|copy|move|copy|move|<<ERROR>>}2 %select{base class|field|an object}0 of type %3'
HD9E44C137738: '%select{基底クラス|フィールド|オブジェクト}0の型%3に%select{<<ERROR>>|コピー|ムーブ|コピー|ムーブ|<<ERROR>>}2するために、%select{<<ERROR>>|コンストラクタ|コンストラクタ|代入演算子|代入演算子|<<ERROR>>}2が見つかりません'
# 'because of ambiguity in conversion %diff{of $ to $|between types}0,1'
HB064B974A1C3: 'because %diff{の$から$への|タイプ間の}0,1変換の曖昧さにより'
# 'because substituted constraint expression is ill-formed%0'
H708967A94C80: 'because 置換された制約式が不完全なため%0'
# 'because the function selected to %select{construct|copy|move|copy|move|destroy}2 %select{base class|field}0 of type %1 is not trivial'
H1F152D129667: 'because %select{construct|copy|move|copy|move|destroy}2 %select{ベースクラス|フィールド}0の型%1を選択した関数が非自明であるため'
# 'because type %0 has a member with %select{no|no|__strong|__weak|__autoreleasing}1 ownership'
HE992EBFC669B: 'because 型%0が%select{なし|なし|__strong|__weak|__autoreleasing}1オーナーシップを持つメンバーを含むため'
# 'because type %0 has a virtual %select{member function|base class}1'
H45351AACBEF7: 'because 型%0が仮想%select{メンバー関数|ベースクラス}1を持つため'
# "befriending %1 without '%select{struct|interface|union|class|enum}0' keyword is incompatible with C++98"
HDE958FBB8995: "befriending %1時に'%select{struct|interface|union|class|enum}0'キーワードを使用しないとC++98と互換性がありません"
# 'binary RIFF format'
H555066C6C2A6: 'バイナリ RIFF フォーマット'
# 'binary fold expression has unexpanded parameter packs in both operands'
HBE3AEFF67350: 'binary fold expression の両方のオペランドに展開されていないパラメータパックが含まれています'
# 'binary integer literals are a C++14 extension'
H12BBB01421DF: 'binary integer literals はC++14の拡張機能です'
# 'binary integer literals are a C23 extension'
HC848A482B4CC: 'binary integer literals はC23の拡張機能です'
# 'binary integer literals are incompatible with C standards before C23'
H60CB9502C648: 'binary integer literals はC23以前の標準と互換性がありません'
# 'binary integer literals are incompatible with C++ standards before C++14'
H039AFCF983A6: '2進整数リテラルはC++14以前の標準規格と互換性ありません'
# 'binary operator not supported, only +, *, -, /, &, ^, |, <<, or >> are permitted'
H947D153F3B10: 'サポートされている二項演算子は+、*、-、/、&、^、|、<<、または>>のみです'
# 'binary with the instrumentation map, or a separate instrumentation map'
HC4FD0057C615: 'インストルメンテーションマップと共に、または別のインストルメンテーションマップを使用'
# 'binary with the instrumentation map, or a separate instrumentation map for graph'
H2CC2C500D553: 'インストルメンテーションマップと共に、またはグラフ用の別のインストルメンテーションマップを使用'
# 'binary with the instrumentation map, or a separate instrumentation map for graph 1'
HAEE5C542170E: 'インストルメンテーションマップと共に、またはグラフ1用の別のインストルメンテーションマップを使用'
# 'binary with the instrumentation map, or a separate instrumentation map for graph 2'
HC231E43E4B06: 'インストルメンテーションマップと共に、またはグラフ2用の別のインストルメンテーションマップを使用'
# 'binary with the instrumrntation map, or a separate instrumentation map'
H0A39B12683BE: 'インストルメンテーションマップと共に、または別のインストルメンテーションマップを使用'
# 'binding %0 cannot appear in the initializer of its own decomposition declaration'
H672061929029: '%0のバインディングは、自身の分解宣言の初期化子中に出現できません'
# 'binding dereferenced null pointer to reference has undefined behavior'
H95EC0F6A8A66: 'nullポインタの解除結果を参照にバインドすることは未定義動作です'
# 'binding reference %diff{of type $ to value of type $|to value}0,1 %select{drops %3 qualifier%plural{1:|2:|4:|:s}4|changes address space|not permitted due to incompatible qualifiers}2'
H55C0D80172E9: '参照のバインディング %diff{of type $ to value of type $|to value}0,1 %select{drops %3 qualifier%plural{1:|2:|4:|:s}4|changes address space|not permitted due to incompatible qualifiers}2'
# 'binding reference member %0 to stack allocated %select{variable|parameter}2 %1'
H6CEDF6C3E571: '参照メンバー%0をスタックに配置された%select{変数|パラメータ}2 %1にバインド'
# "binding type '%0' is invalid"
HD0FB3A3589D6: "バインディングタイプ'%0'は無効です"
# "binding type '%select{t|u|b|s|c|i}0' cannot be applied more than once"
H9FC4B2C35AB9: "バインディングタイプ'%select{t|u|b|s|c|i}0'は一度以上適用できません"
# "binding type '%select{t|u|b|s|c}0' only applies to %select{SRV resources|UAV resources|constant buffer resources|sampler state|numeric variables in the global scope}0"
H9DB6D490A30A: "バインディングタイプ'%select{t|u|b|s|c}0'は%select{SRVリソース|UAVリソース|定数バッファリソース|サンプラー状態|グローバルスコープの数値変数}0にのみ適用されます"
# "binding type '%select{t|u|b|s|c}0' only applies to types containing %select{SRV resources|UAV resources|constant buffer resources|sampler state|numeric types}0"
H1CE73AE71EA5: "バインディングタイプ'%select{t|u|b|s|c}0'は%select{SRVリソース|UAVリソース|定数バッファリソース|サンプラー状態|数値型}0を含む型にのみ適用されます"
# "binding type 'b' only applies to constant buffers. The 'bool constant' binding type is no longer supported"
HC83E5E495198: "バインディングタイプ'b'は定数バッファにのみ適用されます。'bool constant'バインディングタイプは現在サポートされていません"
# "binding type 'c' ignored in buffer declaration. Did you mean 'packoffset'?"
H937D8317B6A5: "バインディングタイプ'c'はバッファ宣言で無視されます。'packoffset'を意味したのでしょうか？"
# "binding type 'i' ignored. The 'integer constant' binding type is no longer supported"
H2F0190E0856D: "バインディングタイプ'i'は無視されました。'integer constant'バインディングタイプは現在サポートされていません"
# "bit fields cannot be used to specify storage in a '%0' clause"
H5C9BE7997F9C: "ビットフィールドは'%0'句のストレージ指定に使用できません"
# 'bit-field %0 has negative width (%1)'
HA6B3D52AF212: 'ビットフィールド %0 の幅は負の値 (%1) です'
# 'bit-field %0 has non-integral type %1'
H1F66B27F57D3: 'ビットフィールド %0 の型 %1 は整数型ではありません'
# 'bit-field %0 is not wide enough to store all enumerators of %1'
H1E7885609E9C: '%0 ビットフィールドは %1 のすべての列挙子を格納するには十分な幅ではありません'
# 'bit-field is declared here'
HE5CFF566169E: 'ビットフィールドはここに宣言されています'
# 'bit-fields are not supported in OpenCL'
H752654865932: 'OpenCL ではビットフィールドはサポートされていません'
# 'bit_cast %select{from|to}0 a %select{|type with a }1%select{union|pointer|member pointer|volatile|reference}2 %select{type|member}1 is not allowed in a constant expression'
H0C9C7C0B5093: 'bit_cast %select{from|to}0 a %select{|type with a }1%select{union|pointer|member pointer|volatile|reference}2 %select{type|member}1 は定数式では使用できません'
# 'bit_cast involving type %0 is not allowed in a constant expression; element size %1 * element count %2 is not a multiple of the byte size %3'
H3BD534784507: 'type %0 を含む bit_cast は定数式では許可されません。要素サイズ %1 × 要素数 %2 はバイトサイズ %3 の倍数ではありません'
# "bitcode library '%0' does not exist"
H551B33870D5D: "bitcode ライブラリ '%0' は存在しません"
# 'bitmasking for introspection of Objective-C object pointers is strongly discouraged'
H7CE8DAA0A6CB: 'Objective-C オブジェクトポインタの内部状態を調べるためにビットマスクを使用することは強く非推奨です'
# 'bitwise comparison always evaluates to %select{false|true}0'
H8A4398170F46: 'ビット単位の比較は常に %select{false|true}0 となります'
# "bitwise negation of a boolean expression%select{;| always evaluates to 'true';}0 did you mean logical negation?"
HE532D6128324: '論理式のビット単位の否定%select{;|は常に true となります;}0 論理否定を意図したのではないでしょうか？'
# 'bitwise or with non-zero value always evaluates to true'
H6F8F36ACC41B: '非ゼロの値とのビット単位の OR は常に true となります'
# 'block cannot return %select{array|function}0 type %1'
H91AB8D594327: 'ブロックは %select{配列|関数}0 型 %1 を返すことはできません'
# 'block captures an autoreleasing out-parameter, which may result in use-after-free bugs'
H835D51AA87F3: 'ブロックは自動解放のアウトパラメータをキャプチャするため、use-after-free バグが発生する可能性があります'
# "block could be declared with attribute 'noreturn'"
H9307EF042F77: "ブロックは 'noreturn' 属性で宣言できます"
# "block implicitly retains 'self'; explicitly mention 'self' to indicate this is intended behavior"
H094C5FEF2D2A: "ブロックは 'self' を暗黙的に保持します。意図した動作であることを明示するため、'self' を明示的に記述してください"
# 'block pointer to non-function type is invalid'
H9EFC2777265D: '非関数型へのブロックポインタは無効です'
# 'block pointer variable %0 is %select{uninitialized|null}1 when captured by block'
H5DFD2F29C16B: 'ブロックがキャプチャする際、ブロックポインタ変数 %0 は %select{初期化されていません|null です}1'
# 'block type cannot be used as expression in ternary expression in OpenCL'
HE91DFBCBC336: 'OpenCL の三項演算子ではブロック型を式として使用できません'
# 'block will be retained by %select{the captured object|an object strongly retained by the captured object}0'
H659E73E5BC81: 'ブロックは%select{キャプチャされたオブジェクトによって|キャプチャされたオブジェクトによって強く保持されているオブジェクトによって}0保持されます'
# 'blocks support disabled - compile with -fblocks or %select{pick a deployment target that supports them|for OpenCL C 2.0 or OpenCL C 3.0 with __opencl_c_device_enqueue feature}0'
H870F6FD76494: 'ブロックのサポートは無効です - -fblocksオプションでコンパイルするか、%select{対応しているターゲットを選択する|OpenCL C 2.0またはOpenCL C 3.0（__opencl_c_device_enqueue機能付き）を使用する}0'
# "blocks used in enqueue_kernel call are expected to have parameters of type 'local void*'"
H5A1C0A69E254: "enqueue_kernel呼び出しで使用されるブロックは、パラメータの型が'local void*'である必要があります"
# 'blocks with parameters are not accepted in this prototype of enqueue_kernel call'
H6F73FE38020E: "'enqueue_kernel'のこのプロトタイプではパラメータを伴うブロックは受け付けません"
# 'body of cpu_dispatch function will be ignored'
H8CCA48E04008: 'cpu_dispatch関数の本体は無視されます'
# "bool literal returned from 'main'"
H65A070E22BD6: "'main'から返されたboolリテラル"
# 'both arms of conditional operator are unable to produce a constant expression'
H42234192A750: '条件演算子の両方の枝は定数式を生成できません'
# 'boundary to use for alignment of basic blocks'
H8D491EEC35CA: '基本ブロックのアラインメントに使用する境界'
# 'brace elision for designated initializer is a C99 extension'
H98B26CB02BEA: '指定子初期化子のための波括弧の省略はC99の拡張です'
# 'braces around %select{scalar |}0initializer'
H5FA1CA5D46EC: '初期化子を囲む波括弧（%select{スカラ用の |}0）'
# 'bracket nesting level exceeded maximum of %0'
HAE0DB07D013C: '括弧のネストレベルが%0を超えた'
# 'brackets are not allowed here; to declare an array, place the brackets after the %select{identifier|name}0'
H9FD98F06E7EB: 'ここに括弧は使用できません。配列を宣言するには、%select{識別子|名前}0の後に括弧を置きます'
# 'branch probability threshold in percentage to be considered very likely'
H4385A55B36C8: '非常に確実なと見なされる分岐確率の閾値（パーセンテージ）'
# 'branch probability threshold in percentage to be considered very likely when profile is available'
H7FFFD5CE40B4: 'プロファイルがある場合の非常に確実な分岐確率閾値（パーセンテージ）'
# 'branch relax asm'
HC2E42E8DC7A2: 'ブランチ・リラックス・アセンブリ'
# "build a shadowed submodule '%0'"
H9D79CC95EF50: "シャドウされたサブモジュール'%0'を構築"
# "building module '%0' as '%1'"
H765D28E7D6EF: "モジュール'%0'を'%1'として構築"
# 'built-in candidate %0'
H70FA60F84316: '組み込み候補%0'
# 'builtin %0 is deprecated; use %1 instead'
H3145BB7C5706: '組み込み%0は非推奨になりました；代わりに%1を使用してください'
# 'builtin call is not valid when calling from a function without active ZA state'
H7B974CCBB78F: 'アクティブなZA状態がない関数から呼び出す場合、組み込み呼び出しは無効です'
# 'builtin call is not valid when calling from a function without active ZT0 state'
H1B7C49833DEE: 'アクティブなZT0状態がない関数から呼び出す際、ビルトイン呼び出しは有効ではありません'
# 'builtin can only be called from a %0 function'
H2DDDDEB70C80: 'ビルトイン関数は%0関数から呼び出す必要があります'
# 'builtin feature check macro requires a parenthesized identifier'
HA88BFEE47095: 'ビルトイン機能チェックマクロには括弧付き識別子が必要です'
# 'builtin functions must be directly called'
HABBC844A5E58: 'ビルトイン関数は直接呼び出さなければなりません'
# 'builtin headers belong to system modules, and _Builtin_ modules are ignored for cstdlib headers'
HFC2F5B50372D: 'ビルトインヘッダーはシステムモジュールに属し、cstdlibヘッダーの_Builtin_モジュールは無視されます'
# 'builtin is not supported on this target'
H6C31A7E5443F: 'このターゲットではこのビルトイン機能はサポートされていません'
# 'builtin requires%select{| at least one of the following extensions}0: %1'
HBE3E35E72C33: 'ビルトイン機能には%select{|次に挙げる拡張の少なくとも1つ}0が必要です: %1'
# "but in %select{'%1'|definition here}0 found %select{%3 referenced %plural{1:protocol|:protocols}3|%ordinal3 referenced protocol with different name %4}2"
HD3683C05282A: "しかし、%select{'%1'|ここでの定義}0 では、%select{%3 が参照された %plural{1:プロトコル|:プロトコル}3|%ordinal3 番目のプロトコルが異なる名前 %4 を参照}2 を見つかりました"
# "but in %select{'%1'|definition here}0 found %select{%select{method %4|constructor|destructor}3 that has %5 parameter%s5|%select{method %4|constructor|destructor}3 with %ordinal5 parameter of type %6%select{| decayed from %8}7|%select{method %4|constructor|destructor}3 with %ordinal5 parameter named %6}2"
HF69A42480F6D: "ただし、%select{'%1'|定義ここ}0 で %select{%select{メソッド %4|コンストラクタ|デストラクタ}3 が %5 パラメータ%s5 を持っています|%select{メソッド %4|コンストラクタ|デストラクタ}3 の %ordinal5 番目のパラメータの型は%6%select{| %8 から変換されました}7|%select{メソッド %4|コンストラクタ|デストラクタ}3 の %ordinal5 番目のパラメータは%6 という名前を持っています}2 を見つけました"
# "but in %select{'%1'|definition here}0 found %select{%select{no super class|super class with type %4}3|instance variable '%3' access control is %select{|@private|@protected|@public|@package}4}2"
H07A5F408116E: "ただし、%select{'%1'|定義ここ}0 で %select{%select{スーパークラスなし|スーパークラスの型 %4}3|インスタンス変数 '%3' のアクセス制御は %select{|@private|@protected|@public|@package}4}2 を見つけました"
# "but in %select{'%1'|definition here}0 found %select{end of class|public access specifier|private access specifier|protected access specifier|static assert|field|method|type alias|typedef|data member|friend declaration|function template|method|instance variable|property}2"
H901B5EFBD082: "しかし%select{'%1'|ここでの定義}0では%select{クラス終了|パブリックアクセス仕様|プライベートアクセス仕様|プロテクテッドアクセス仕様|静的アサーション|フィールド|メソッド|タイプエイリアス|typedef|データメンバ|フレンド宣言|関数テンプレート|メソッド|インスタンス変数|プロパティ}2が見つかりました"
# "but in %select{'%1'|definition here}0 found %select{field %3|field %3 with type %4|%select{non-|}4bit-field %3|bit-field %3 with different width expression|%select{non-|}4mutable field %3|field %3 with %select{no|an}4 initializer|field %3 with a different initializer}2"
H4C900A5437EA: "しかし、%select{'%1'|ここでの定義}0 では %select{フィールド %3|型 %4 を持つフィールド %3|%select{非-|}4ビット・フィールド %3|幅式が異なるビット・フィールド %3|%select{非-|}4mutable フィールド %3|初期化子を%select{持たない|持つ}4フィールド %3|初期化子が異なるフィールド %3}2 を見つけました"
# "but in %select{'%1'|definition here}0 found %select{method %3 with different return type %4|method %3 as %select{class|instance}4 method|%select{no|'required'|'optional'}3 method control|method %3 with %select{no designated initializer|designated initializer}4|%select{regular|direct}4 method %3|different method %3}2"
H9C08666CA7C3: "しかし%select{'%1'|ここでの定義}0では%select{異なる戻り値型%4を持つメソッド%3|%select{クラス|インスタンス}4メソッドとしてのメソッド%3|%select{なし|'required'|'optional'}3メソッド制御|%select{指定イニシャライザなし|指定イニシャライザあり}4メソッド%3|%select{通常|直接}4メソッド%3|異なるメソッド%3}2が見つかりました"
# "but in %select{'%1'|definition here}0 found %select{property %3|property %3 with type %4|%select{no|'required'|'optional'}3 property control|property %3 with different '%select{none|readonly|getter|assign|readwrite|retain|copy|nonatomic|setter|atomic|weak|strong|unsafe_unretained|nullability|null_resettable|class|direct}4' attribute}2"
HFF656A371ACE: "しかし%select{'%1'|ここでの定義}0では%select{プロパティ%3|型%4を持つプロパティ%3|%select{なし|'required'|'optional'}3プロパティ制御|'%select{none|readonly|getter|assign|readwrite|retain|copy|nonatomic|setter|atomic|weak|strong|unsafe_unretained|nullability|null_resettable|class|direct}4'属性を持つ異なるプロパティ%3}2が見つかりました"
# "but in %select{'%1'|definition here}0 found %select{||||different static assert|different field|different method|different type alias|different typedef|different data member|different friend declaration|different function template|different method|different instance variable|different property|another unexpected decl}2"
HF376197A4A03: "しかし%select{'%1'|ここでの定義}0では%select{||||異なる静的アサーション|異なるフィールド|異なるメソッド|異なるタイプエイリアス|異なるtypedef|異なるデータメンバ|異なるフレンド宣言|異なる関数テンプレート|異なるメソッド|異なるインスタンス変数|異なるプロパティ|別の予期しない宣言}2が見つかりました"
# "but in '%0' found %select{%2 base %plural{1:class|:classes}2|%2 virtual base %plural{1:class|:classes}2|%ordinal2 base class with different type %3|%ordinal2 %select{non-virtual|virtual}3 base class %4|%ordinal2 base class %3 with %select{public|protected|private|no}4 access specifier}1"
H86407D9382F4: "ただし、'%0' で %select{%2 基底 %plural{1:クラス|:クラス}2|%2 バーチャル基底 %plural{1:クラス|:クラス}2|%ordinal2 番目の基底クラスの型が異なる %3|%ordinal2 番目の %select{非バーチャル|バーチャル}3 基底クラス %4|%ordinal2 番目の基底クラス %3 のアクセス指定子は %select{パブリック|プロテクテッド|プライベート|なし}4}1 を見つけました"
# "but in '%0' found %select{%select{typedef|type alias}2 name %3|%select{typedef|type alias}2 %3 with different underlying type %4}1"
H5285292325BC: "ただし、'%0' で %select{%select{typedef|型エイリアス}2 の名前 %3|%select{typedef|型エイリアス}2 %3 の異なる基底型 %4}1 を見つけました"
# "but in '%0' found %select{data member with name %2|data member %2 with different type %3|data member %2 with%select{out|}3 an initializer|data member %2 with a different initializer|data member %2 %select{is constexpr|is not constexpr}3}1"
HB02EC39C6642: "ただし、'%0' で %select{名前 %2 のデータメンバ|データメンバ %2 の異なる型 %3|データメンバ %2 に%select{アウト|}3 初期化子|データメンバ %2 の初期化子が異なる|データメンバ %2 は%select{constexpr|constexprではない}3}1 を見つけました"
# "but in '%0' found %select{different return type %2|%ordinal2 parameter with name %3|%ordinal2 parameter with type %3%select{| decayed from %5}4|%ordinal2 parameter with%select{out|}3 a default argument|%ordinal2 parameter with a different default argument|a different body}1"
H926097C3EBA4: "ただし、'%0' で %select{異なる戻り値の型 %2|%ordinal2 番目のパラメータの名前 %3|%ordinal2 番目のパラメータの型 %3%select{| %5 から変換されました}4|%ordinal2 番目のパラメータに%select{アウト|}3 デフォルト引数|%ordinal2 番目のパラメータのデフォルト引数が異なる|異なる本体}1 を見つけました"
# "but in '%0' found %select{enum that is %select{not scoped|scoped}2|enum scoped with keyword %select{struct|class}2|enum %select{without|with}2 specified type|enum with specified type %2|enum with %2 element%s2|%ordinal2 element has name %3|%ordinal2 element %3 %select{has|does not have}4 an initializer|%ordinal2 element %3 has different initializer|}1"
H44D066860BB7: "しかし '%0' で%select{スコープされていないenum|スコープされたenum|キーワード%select{struct|class}2でスコープされたenum|指定タイプ%select{なし|あり}2のenum|指定タイプ%2を持つenum|%2要素を持つenum%select{}2|%ordinal2番目の要素に%3がある|%ordinal2番目の要素%3が%select{初期化子あり|初期化子なし}4|%ordinal2番目の要素%3が異なる初期化子|}1が見つかりました"
# "but in '%0' found %select{static assert with different condition|static assert with different message|static assert with %select{|no }2message|%select{method %3|constructor|destructor}2|%select{method %3|constructor|destructor}2 is %select{not deleted|deleted}4|%select{method %3|constructor|destructor}2 is %select{not defaulted|defaulted}4|%select{method %3|constructor|destructor}2 is %select{|pure }4%select{not virtual|virtual}5|%select{method %3|constructor|destructor}2 is %select{not static|static}4|%select{method %3|constructor|destructor}2 is %select{not volatile|volatile}4|%select{method %3|constructor|destructor}2 is %select{not const|const}4|%select{method %3|constructor|destructor}2 is %select{not inline|inline}4|%select{method %3|constructor|destructor}2 with %ordinal4 parameter with%select{out|}5 a default argument|%select{method %3|constructor|destructor}2 with %ordinal4 parameter with a different default argument|%select{method %3|constructor|destructor}2 with %select{no |}4template arguments|%select{method %3|constructor|destructor}2 with %4 template argument%s4|%select{method %3|constructor|destructor}2 with %4 for %ordinal5 template argument|%select{method %3|constructor|destructor}2 with %select{no body|body}4|%select{method %3|constructor|destructor}2 with different body|friend %select{class|function}2|friend %2|friend function %2|function template %2 with %3 template parameter%s3|function template %2 with %ordinal3 template paramter being a %select{type|non-type|template}4 template parameter|function template %2 with %ordinal3 template parameter %select{with no name|named %5}4|function template %2 with %ordinal3 template parameter with %select{no |}4default argument|function template %2 with %ordinal3 template parameter with default argument %4|function template %2 with %ordinal3 template parameter with different type|function template %2 with %ordinal3 template parameter %select{not |}4being a template parameter pack|}1"
H650FCD73F7BC: "しかし '%0' では %select{異なる条件を持つstatic assert|異なるメッセージを持つstatic assert|%select{メッセージなし|メッセージ有り}2static assert|%select{メソッド%3|コンストラクタ|デストラクタ}2|%select{メソッド%3|コンストラクタ|デストラクタ}2が%select{削除されていない|削除されている}4|%select{メソッド%3|コンストラクタ|デストラクタ}2が%select{デフォルトではない|デフォルト化されている}4|%select{メソッド%3|コンストラクタ|デストラクタ}2が%select{pure |}4%select{非仮想|仮想}5|%select{メソッド%3|コンストラクタ|デストラクタ}2が%select{静的でない|静的}4|%select{メソッド%3|コンストラクタ|デストラクタ}2が%select{volatileでない|volatile}4|%select{メソッド%3|コンストラクタ|デストラクタ}2が%select{constでない|const}4|%select{メソッド%3|コンストラクタ|デストラクタ}2が%select{インラインでない|インライン}4|%select{メソッド%3|コンストラクタ|デストラクタ}2が%ordinal4パラメータに%select{デフォルト引数なし|}5デフォルト引数を持つ|%select{メソッド%3|コンストラクタ|デストラクタ}2が%ordinal4パラメータに異なるデフォルト引数を持つ|%select{メソッド%3|コンストラクタ|デストラクタ}2が%select{テンプレート引数なし|テンプレート引数有り}4|%select{メソッド%3|コンストラクタ|デストラクタ}2が%4テンプレート引数%s4を持つ|%select{メソッド%3|コンストラクタ|デストラクタ}2が%ordinal5テンプレート引数として%4を持つ|%select{メソッド%3|コンストラクタ|デストラクタ}2が%select{本体なし|本体有り}4|%select{メソッド%3|コンストラクタ|デストラクタ}2が異なる本体を持つ|フレンド%select{クラス|関数}2|フレンド%2|フレンド関数%2|テンプレート関数%2が%3テンプレートパラメータ%s3を持つ|テンプレート関数%2が%ordinal3テンプレートパラメータが%select{型|非型|テンプレート}4タイプである|テンプレート関数%2が%ordinal3テンプレートパラメータ%select{名なし|%5という名前}4を持つ|テンプレート関数%2が%ordinal3テンプレートパラメータに%select{デフォルト引数なし|}4デフォルト引数を持つ|テンプレート関数%2が%ordinal3テンプレートパラメータにデフォルト引数%4を持つ|テンプレート関数%2が%ordinal3テンプレートパラメータの型が異なる|テンプレート関数%2が%ordinal3テンプレートパラメータが%select{テンプレートパラメータパックでない|}4|}1"
# "but in '%0' found %select{unnamed template parameter %2|template parameter %3|template parameter with %select{no |}2default argument|template parameter with different default argument}1"
HA18966A0FC1B: "ただし、'%0' で %select{名前のないテンプレート引数 %2|テンプレート引数 %3|テンプレート引数に%select{ない|}2デフォルト引数|テンプレート引数のデフォルト引数が異なる}1 を見つけました"
# "by value capture of '*this' is incompatible with C++ standards before C++17"
H60BDFA125D23: "'*this' の値キャプチャは C++17 より前の C++ 標準と互換性がありません"
# 'by-copy capture of value of abstract type %0'
H69470A21D7A2: '抽象型 %0 の値をコピーでキャプチャ'
# 'by-copy capture of variable %0 with %select{incomplete|sizeless}1 type %2'
H0B21D37A79AB: '%select{未完了|サイズなし}1 型 %2 の変数 %0 をコピーでキャプチャ'
# 'cache-aware duplication strategy'
HF9F924A27610: 'キャッシュ意識型複製戦略'
# 'calculate and print various metrics for instruction cache'
HE98D77A3BA25: '命令キャッシュの様々なメトリクスを計算して表示'
# 'call to %0 implicitly required by coroutine function here'
H58DB024E2029: 'ここでのコルーチン関数によって暗黙的に要求された %0 の呼び出し'
# 'call to %0 is ambiguous'
HE4A087079576: '%0への呼び出しは曖昧です'
# 'call to %select{immediate|consteval}1 function %q0 is not a constant expression'
H00D075778CD9: '%select{即時|consteval}1 関数 %q0 の呼び出しは定数式ではありません'
# 'call to %select{non-static|explicit}0 member function without an object argument'
H63B47EF20C66: '%select{静的でない|明示的}0 メンバ関数へのオブジェクト引数なしの呼び出し'
# 'call to %select{placement|class-specific}0 %1'
H295DBDE7B5BD: '%select{配置|クラス固有}0 %1への呼び出し'
# "call to '%0' declared with 'error' attribute: %1"
HDBB58BF71CEC: "'%0' の 'error' 属性で宣言された呼び出し: %1"
# "call to '%0' declared with 'warning' attribute: %1"
H3865B6C0D901: "'%0' の 'warning' 属性で宣言された呼び出し: %1"
# "call to '%select{__builtin_operator_new|__builtin_operator_delete}0' selects non-usual %select{allocation|deallocation}0 function"
H676581AF4E96: "'%select{__builtin_operator_new|__builtin_operator_delete}0' は非通常の%select{割り当て|解放}0 関数を選択しました"
# "call to '%select{initial_suspend|final_suspend}0' implicitly required by the %select{initial suspend point|final suspend point}0"
H1C6B1E5ADCED: "'%select{initial_suspend|final_suspend}0' の呼び出しは%select{初期保留ポイント|最終保留ポイント}0 によって暗黙的に要求されました"
# "call to 'await_transform' implicitly required by 'co_await' here"
HA0503466B398: "ここでの 'co_await' により 'await_transform' の呼び出しが暗黙的に要求されました"
# "call to a function that shares state other than 'za' from a function that has live 'za' state requires a spill/fill of ZA, which is not yet implemented"
H8FF6C74595CF: "'za' 以外の状態を共有する関数への呼び出しは、呼び出し元でアクティブな 'za' 状態を持つ場合、未実装の ZA スpill/fill を要求します"
# 'call to a shared ZA function requires the caller to have ZA state'
H755688EF43BB: '共有 ZA 関数への呼び出しは、呼び出し元で ZA 状態を保持する必要があります'
# 'call to a shared ZT0 function requires the caller to have ZT0 state'
H89ACEBE543C2: '共有 ZT0 関数への呼び出しは、呼び出し元で ZT0 状態を保持する必要があります'
# "call to a streaming function requires 'sme'"
H41309CFB27F8: "ストリーミング関数への呼び出しには 'sme' が必要です"
# 'call to constructor of %0 is ambiguous'
H00A38B0315FF: '%0 のコンストラクタへの呼び出しは曖昧です'
# 'call to deleted constructor of %0%select{|: %2}1'
HAA8E5FBCBA79: '削除された %0 のコンストラクタへの呼び出し%select{|: %2}1'
# 'call to deleted function call operator in type %0%select{|: %2}1'
H8F857BEAC26F: 'タイプ %0 内の削除された呼び出し演算子への呼び出し%select{|: %2}1'
# 'call to deleted%select{| member}0 function %1%select{|: %3}2'
H6B002A51A7D4: '削除された%select{|メンバー}0 関数 %1への呼び出し%select{|: %3}2'
# 'call to function %0 that is neither visible in the template definition nor found by argument-dependent lookup'
H225588528963: 'テンプレート定義では見えず、引数依存検索でも見つからない関数 %0 への呼び出し'
# 'call to global function %0 not configured'
HC08574A55FB5: '%0 グローバル関数への呼び出しは構成されていません'
# 'call to implicitly-deleted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|function}0 of %1'
H4C623CF7C837: '%1 の暗黙に削除された %select{デフォルトコンストラクタ|コピー コンストラクタ|ムーブ コンストラクタ|コピー代入演算子|ムーブ代入演算子|デストラクタ|関数}0 を呼び出しました'
# 'call to member function %0 is ambiguous'
H60EE3A6ABF6A: '%0 メンバ関数の呼び出しが曖昧です'
# 'call to object of type %0 is ambiguous'
H3783B2A8DBDC: '%0 タイプのオブジェクトへの呼び出しが曖昧です'
# "call to pointer to member function of type %0 drops '%1' qualifier%s2"
HC75C3E40313D: "%0 型のメンバ関数ポインタの呼び出しは '%1' 質問子を失っています"
# 'call to pseudo-destructor cannot have any arguments'
H6ECE40631FC9: '疑似デストラクタの呼び出しは引数をもてません'
# 'call to pure virtual member function %0 has undefined behavior; overrides of %0 in subclasses are not available in the %select{constructor|destructor}1 of %2'
HDC8AD43C5C1C: '%2 の %select{コンストラクタ|デストラクタ}1 内で、純粋仮想メンバ関数 %0 の呼び出しは未定義動作です。%0 のサブクラスでのオーバーライドは利用できません'
# 'call to subscript operator of type %0 is ambiguous'
H1E29AAB6AD84: '%0 タイプのサブスクリプト演算子の呼び出しが曖昧です'
# 'call to undeclared function %0; ISO C99 and later do not support implicit function declarations'
HEBF384E2E2A6: '宣言されていない関数 %0 を呼び出しました; ISO C99 以降では暗黙の関数宣言がサポートされません'
# "call to undeclared library function '%0' with type %1; ISO C99 and later do not support implicit function declarations"
HF288A58FA40B: "宣言されていないライブラリ関数 '%0' (%1 型) の呼び出し; ISO C99以降では暗黙の関数宣言がサポートされません"
# 'call to unsupported expression with unknown type'
H239ACE39DA12: '未知の型を持つ非サポートされている式の呼び出し'
# 'called by %0'
HDC9A013B796D: '%0 から呼び出されました'
# 'called object type %0 is not a function or function pointer'
H5E3F97BDB14E: '呼び出し可能オブジェクト型 %0 は関数または関数ポインタではありません'
# 'callee declares array parameter as static here'
H80DA3F678F9A: '呼び出し元はここに静的配列パラメータを宣言しています'
# "calling %0 is a violation of trusted computing base '%1'"
HF890EA6739C7: '%0 の呼び出しは信頼されたコンピューティングベース %1 の違反です'
# 'calling %0 with incomplete return type %1'
H218BBBD759BD: '%1 不完全戻り値型を持つ %0 を呼び出しました'
# "calling '%0' with a nonzero argument is unsafe"
H373CF9276563: '0以外の引数を持つ %0 の呼び出しは安全ではありません'
# 'calling a %select{private|protected}0 constructor of class %2'
H1D7B9B5BEE0D: 'クラス %2 の %select{プライベート|プロテクテッド}0 コンストラクタの呼び出し'
# 'calling a %select{private|protected}1 destructor of class %0'
H2870B0B82BD7: 'クラス %0 の %select{プライベート|プロテクテッド}1 デストラクタの呼び出し'
# "calling function %0 requires negative capability '%1'"
HB81388BC5C94: "%0 のネガティブな能力 '%1' を要求する関数呼び出し"
# "calling function %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
HF6312AC18647: "%1 関数の呼び出しは %0 %select{'%2'|'%2' を排他に}3 を保持する必要があります"
# 'calling function with incomplete return type %0'
H47066D05EDB3: '%0 不完全型の戻り値を返す関数を呼び出しました'
# 'calls the given entry-point on a new thread (jit-kind=orc-lazy only)'
HD909298BB334: 'jit-kind=orc-lazy のみで、新しいスレッド上での指定エントリーポイントを呼び出します'
# 'calls to OpenMP runtime API are not allowed within a region that corresponds to a construct with an order clause that specifies concurrent'
HF0FE255D765C: 'order句で concurrent を指定した構文に対応する領域内でOpenMPランタイムAPIの呼び出しは許可されません'
# 'can only access this member on an object of type %0'
H97DBB9710EB7: '型 %0 のオブジェクト上でのみこのメンバにアクセスできます'
# 'can only poison identifier tokens'
HBA757282B22F: '識別子トークンのみを破壊できます'
# 'can only provide an explicit specialization for a class template, function template, variable template, or a member function, static data member, %select{or member class|member class, or member enumeration}0 of a class template'
H705307E2F906: 'クラステンプレート、関数テンプレート、変数テンプレート、またはクラステンプレートの %select{メンバ関数、静的データメンバ、またはメンバクラス|メンバ関数、静的データメンバ、メンバクラス、またはメンバ列挙型}0 の明示的な特殊化のみを指定できます'
# "can only use 'init_priority' attribute on file-scope definitions of objects of class type"
H2C248D12A320: "'init_priority' 属性はクラス型のファイルスコープ定義のみに使用できます"
# 'candidate %select{constructor|template}0 ignored: inherited constructor cannot be used to %select{copy|move}1 object'
HA2E8E747932F: '候補 %select{コンストラクタ|テンプレート}0 が無視されました: 継承コンストラクタは %select{コピー|ムーブ}1 オブジェクトに使用できません'
# 'candidate %select{constructor|template}0 ignored: instantiation %select{takes|would take}0 its own class type by value'
H5F81F51806D8: '候補 %select{コンストラクタ|テンプレート}0 が無視されました: インスタンス化 %select{その|その}0 自分自身のクラス型を値として受け取ります'
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 has been %select{explicitly made unavailable|explicitly deleted|implicitly deleted}3"
HDF3920A3A1F2: '%select{関数|関数|引数順が逆の関数|コンストラクタ|暗黙のデフォルトコンストラクタ|暗黙のコピーコンストラクタ|暗黙のムーブコンストラクタ|暗黙のコピー代入演算子|暗黙のムーブ代入演算子|operator<=>に対応する暗黙のoperator==|継承コンストラクタ}0%select{|テンプレート| %2}1 は %select{明示的に利用不可|明示的に削除|暗黙的に削除}3 されています'
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %ordinal5 argument (%3) would lose %select{const|restrict|const and restrict|volatile|const and volatile|volatile and restrict|const, volatile, and restrict}4 qualifier%select{||s||s|s|s}4"
H95E4AEB3B23E: '%select{関数|関数|引数順が逆の関数|コンストラクタ|暗黙のデフォルトコンストラクタ|暗黙のコピーコンストラクタ|暗黙のムーブコンストラクタ|暗黙のコピー代入演算子|暗黙のムーブ代入演算子|operator<=>に対応する暗黙のoperator==|継承コンストラクタ}0%select{|テンプレート| %2}1 は %ordinal5 番目の引数 (%3) が %select{const|restrict|constとrestrict|volatile|constとvolatile|volatileとrestrict|const, volatile, およびrestrict}4 質問子%select{||s||s|s|s}4 を失うため不可行です'
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %select{%ordinal7|'this'}6 argument (%3) has %select{no|__unsafe_unretained|__strong|__weak|__autoreleasing}4 ownership, but parameter has %select{no|__unsafe_unretained|__strong|__weak|__autoreleasing}5 ownership"
H8D414CDC2F4E: "%select{関数|関数|引数の順序が逆の関数|コンストラクタ|暗黙のデフォルトコンストラクタ|暗黙のコピーコンストラクタ|暗黙のムーブコンストラクタ|暗黙のコピー代入演算子|暗黙のムーブ代入演算子|暗黙の'operator<=>'用'operator==|継承コンストラクタ}0%select{|テンプレート| %2}1の候補は不適切です：%select{%ordinal7|%this'}6引数（%3）が%select{なし|__unsafe_unretained|__strong|__weak|__autoreleasing}4オーナーシップを持っていますが、パラメータは%select{なし|__unsafe_unretained|__strong|__weak|__autoreleasing}5オーナーシップを持っています"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %select{%ordinal7|'this'}6 argument (%3) has %select{no|__weak|__strong}4 ownership, but parameter has %select{no|__weak|__strong}5 ownership"
HFD1E148AC849: '候補 %select{function|function|引数の順序逆転function|constructor|暗黙のデフォルトコンストラクタ|暗黙のコピーコンストラクタ|暗黙のムーブコンストラクタ|暗黙のコピー代入演算子|暗黙のムーブ代入演算子|operator<=>用の暗黙のoperator==|継承コンストラクタ}0%select{|テンプレート| %2}1 は不適格：%select{%ordinal7|this}6引数 (%3) は%select{なし|__weak|__strong}4 所有権を持っていますが、パラメータは%select{なし|__weak|__strong}5 所有権を持っています'
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %select{cannot convert initializer list|too few initializers in list|too many initializers in list}7 argument to %4"
H4C57102C9323: '候補 %select{function|function|引数の順序逆転function|constructor|暗黙のデフォルトコンストラクタ|暗黙のコピーコンストラクタ|暗黙のムーブコンストラクタ|暗黙のコピー代入演算子|暗黙のムーブ代入演算子|operator<=>用の暗黙のoperator==|継承コンストラクタ}0%select{|テンプレート| %2}1 は不適格：%select{イニシャライザリスト変換不可|イニシャライザリストが少なすぎ|イニシャライザリストが多すぎ}7 引数を%4に変換できません'
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: %select{requires at least|allows at most single|requires single}3 %select{|non-object }6argument %4, but %plural{0:no|:%5}5 arguments were provided"
H8AD4B8B6097C: "%select{関数|関数|引数の順序が逆の関数|コンストラクタ|暗黙のデフォルトコンストラクタ|暗黙のコピーコンストラクタ|暗黙のムーブコンストラクタ|暗黙のコピー代入演算子|暗黙のムーブ代入演算子|暗黙の'operator==' (operator<=>用)|継承コンストラクタ}0%select{|テンプレート| %2}1 の候補は有効ではありません: %select{少なくとも|最大1つの|単一の}3 %select{|非オブジェクト}6 引数%4 が必要ですが、%plural{0:なし|:%5}5 引数が提供されました"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: 'this' argument has type %3, but method is not marked %select{const|restrict|const or restrict|volatile|const or volatile|volatile or restrict|const, volatile, or restrict}4"
HE6BBB39EEE68: '候補 %select{function|function|引数の順序逆転function|constructor|暗黙のデフォルトコンストラクタ|暗黙のコピーコンストラクタ|暗黙のムーブコンストラクタ|暗黙のコピー代入演算子|暗黙のムーブ代入演算子|operator<=>用の暗黙のoperator==|継承コンストラクタ}0%select{|テンプレート| %2}1 は不適格：this引数の型は%3ですが、メソッドは%select{const|restrict|constまたはrestrict|volatile|constまたはvolatile|volatileまたはrestrict|const, volatile, restrict}4 でマークされていません'
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: 'this' object is in %3, but method expects object in %4"
H7EDBF536C9E0: '候補 %select{function|function|引数の順序逆転function|constructor|暗黙のデフォルトコンストラクタ|暗黙のコピーコンストラクタ|暗黙のムーブコンストラクタ|暗黙のコピー代入演算子|暗黙のムーブ代入演算子|operator<=>用の暗黙のoperator==|継承コンストラクタ}0%select{|テンプレート| %2}1 は不適格：thisオブジェクトは%3にありますが、メソッドは%4を必要とします'
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: call to %select{__device__|__global__|__host__|__host__ __device__|invalid}3 function from %select{__device__|__global__|__host__|__host__ __device__|invalid}4 function"
HB286FD7ADB16: '候補 %select{function|function|引数の順序逆転function|constructor|暗黙のデフォルトコンストラクタ|暗黙のコピーコンストラクタ|暗黙のムーブコンストラクタ|暗黙のコピー代入演算子|暗黙のムーブ代入演算子|operator<=>用の暗黙のoperator==|継承コンストラクタ}0%select{|テンプレート| %2}1 は不適格：%select{__device__|__global__|__host__|__host__ __device__|無効}3 関数を%select{__device__|__global__|__host__|__host__ __device__|無効}4 関数から呼び出せません'
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: cannot %select{convert from|convert from|bind}3 %select{base class pointer|superclass|base class object of type}3 %4 to %select{derived class pointer|subclass|derived class reference}3 %5 for %ordinal6 argument"
H9EF538024430: "%select{関数|関数|引数の順序が逆の関数|コンストラクタ|暗黙のデフォルトコンストラクタ|暗黙のコピーコンストラクタ|暗黙のムーブコンストラクタ|暗黙のコピー代入演算子|暗黙のムーブ代入演算子|暗黙の'operator==' (operator<=>用)|継承コンストラクタ}0%select{|テンプレート| %2}1 の候補は有効ではありません: %select{ベースクラスポインタ|スーパークラス|ベースクラスオブジェクトの型}3 %4 を %select{派生クラスポインタ|サブクラス|派生クラスリファレンス}3 %5 に %select{変換できません|変換できません|バインドできません}3 ため、%ordinal6 番目の引数で使用できません"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: cannot %select{pass pointer to|bind reference in}5 %3 %select{as a pointer to|to object in}5 %4 in %ordinal6 argument"
HEE13EA6B12B0: "%select{関数|関数|パラメータ順序逆の関数|コンストラクタ|暗黙のデフォルトコンストラクタ|暗黙のコピーコンストラクタ|暗黙のムーブコンストラクタ|暗黙のコピー代入演算子|暗黙のムーブ代入演算子|暗黙の'operator<=>'用'operator=='|継承コンストラクタ}0%select{|テンプレート| %2}1不可: %ordinal6引数で%select{を%4に指すポインタを|のオブジェクトに%3のリファレンスを}5%select{渡せません|バインドできません}5"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: cannot convert argument of incomplete type %diff{$ to $|to parameter type}3,4 for %select{%ordinal6 argument|object argument}5%select{|; dereference the argument with *|; take the address of the argument with &|; remove *|; remove &}7"
H3F2CD3D64E80: "候補 %select{関数|関数|引数の順序逆の関数|コンストラクタ|暗黙のデフォルトコンストラクタ|暗黙のコピーコンストラクタ|暗黙のムーブコンストラクタ|暗黙のコピー代入演算子|暗黙のムーブ代入演算子|暗黅の 'operator<=>' 用 'operator=='|継承コンストラクタ}0%select{|テンプレート| %2}1 は不適格: 不完全型 %diff{$ から $への変換|パラメータ型への変換}3,4 ができないため %select{%ordinal6 引数|オブジェクト引数}5%select{|; アドレスを解除して * を付ける|; アドレスを取得して & を付ける|; * を削除|; & を削除}7"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: cannot implicitly convert argument %diff{of type $ to $|type to parameter type}3,4 for %select{%ordinal6 argument|object argument}5 under ARC"
H2B5B49758162: "%select{関数|関数|引数の順序が逆の関数|コンストラクタ|暗黙のデフォルトコンストラクタ|暗黙のコピーコンストラクタ|暗黙のムーブコンストラクタ|暗黙のコピー代入演算子|暗黙のムーブ代入演算子|暗黙の'operator==' (operator<=>用)|継承コンストラクタ}0%select{|テンプレート| %2}1 の候補は有効ではありません: ARC の下で %diff{ $ から $ への|パラメータ型への}3,4 の %select{%ordinal6 番目の引数|オブジェクト引数}5 を暗黙的に変換できません"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: constraints not satisfied"
H01514E19EB13: '候補 %select{function|function|引数の順序逆転function|constructor|暗黙のデフォルトコンストラクタ|暗黙のコピーコンストラクタ|暗黙のムーブコンストラクタ|暗黅のコピー代入演算子|暗黙のムーブ代入演算子|operator<=>用の暗黙のoperator==|継承コンストラクタ}0%select{|テンプレート| %2}1 は不適格：テンプレート制約が満たされません'
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: expects an %select{lvalue|rvalue}5 for %select{%ordinal4 argument|object argument}3"
H5778CD649B7A: '候補 %select{function|function|引数の順序逆転function|constructor|暗黙のデフォルトコンストラクタ|暗黙のコピーコンストラクタ|暗黙のムーブコンストラクタ|暗黅のコピー代入演算子|暗黙のムーブ代入演算子|operator<=>用の暗黙のoperator==|継承コンストラクタ}0%select{|テンプレート| %2}1 は不適格：%select{lvalue|rvalue}5が%select{%ordinal4引数|オブジェクト引数}3必要ですが'
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: no known conversion %diff{from $ to $|from argument type to parameter type}3,4 for %select{%ordinal6 argument|object argument}5%select{|; dereference the argument with *|; take the address of the argument with &|; remove *|; remove &}7"
H2C02021665E8: '候補 %select{function|function|引数の順序逆転function|constructor|暗黙のデフォルトコンストラクタ|暗黙のコピーコンストラクタ|暗黙のムーブコンストラクタ|暗黅のコピー代入演算子|暗黙のムーブ代入演算子|operator<=>用の暗黙のoperator==|継承コンストラクタ}0%select{|テンプレート| %2}1 は不適格：%select{%ordinal6引数|オブジェクト引数}5%diff{ $から$|引数型からパラメータ型}3,4への暗黙変換なし%select{|; アスタリスクでデリファレンス|; アンド記号でアドレス取得|; アスタリスク削除|; アンド記号削除}7'
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: no overload of %4 matching %3 for %ordinal5 argument"
H327F9AFBF1B4: "%select{関数|関数|引数の順序が逆の関数|コンストラクタ|暗黙のデフォルトコンストラクタ|暗黙のコピーコンストラクタ|暗黙のムーブコンストラクタ|暗黙のコピー代入演算子|暗黙のムーブ代入演算子|暗黙の'operator==' (operator<=>用)|継承コンストラクタ}0%select{|テンプレート| %2}1 の候補は有効ではありません: %ordinal5 番目の引数の %3 に %4 が一致しません"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1 not viable: requires%select{ at least| at most|}3 %4 %select{|non-object }6argument%s4, but %5 %plural{1:was|:were}5 provided"
HE70B20B055FA: "候補 %select{function|function|function (reversed parameter order)|constructor|implicit default constructor|implicit copy constructor|implicit move constructor|implicit copy assignment operator|implicit move assignment operator|implicit 'operator==' for this 'operator<=>'|inherited constructor}0%select{| template| %2}1 は非有効: %select{少なくとも|最大|}3 %4 %select{|non-object }6 引数%s4 が必要ですが %5 %plural{1:1個が|:が}5 提供されました"
# "candidate %select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %3}1%select{| has different class%diff{ (expected $ but has $)|}5,6| has different number of parameters (expected %5 but has %6)| has type mismatch at %ordinal5 parameter%diff{ (expected $ but has $)|}6,7| has different return type%diff{ ($ expected but has $)|}5,6| has different qualifiers (expected %5 but found %6)| has different exception specification}4"
H8C85DA7348D1: '候補 %select{function|function|引数の順序逆転function|constructor|暗黙のデフォルトコンストラクタ|暗黙のコピーコンストラクタ|暗黙のムーブコンストラクタ|暗黅のコピー代入演算子|暗黙のムーブ代入演算子|operator<=>用の暗黙のoperator==|継承コンストラクタ}0%select{|テンプレート| %3}1%select{|クラスが異なる%diff{（期待：$ 実際：$）|}|パラメータ数が異なる（期待：%5 実際：%6）|%ordinal5引数の型が異なる%diff{（期待：$ 実際：$）|}6,7|戻り型が異なる%diff{（期待：$ 実際：$）|}5,6|修飾子が異なる（期待：%5 実際：%6）|例外仕様が異なる}4'
# 'candidate address cannot be taken because parameter %0 has pass_object_size attribute'
H9C284929AC5A: 'アドレスを取得できません: パラメータ %0 は pass_object_size 属性を持ちます'
# 'candidate constructor ignored: cannot be used to construct an object in address space %0'
H02A4FA176268: 'アドレス空間 %0 でオブジェクトを構築するには使用できません'
# 'candidate disabled: %0'
H7028C3991AD2: '候補は無効です: %0'
# 'candidate found by name lookup is %q0'
H25F5CFEAA3CA: '名前解決で見つかった候補は %q0 です'
# 'candidate function made ineligible by enable_if'
HF67E18BC374D: 'enable_ifによる有効化不能な候補関数'
# 'candidate function with non-reversed arguments'
H8514B0198804: '引数の順序が逆転していない候補関数'
# 'candidate ignored: %select{not a function template|not a member of the enclosing %select{class template|namespace; did you mean to explicitly qualify the specialization?}1}0'
H46E51FE9BF5C: '候補が無視されました: %select{関数テンプレートではありません|包含する %select{クラステンプレート|名前空間; クラスの修飾が必要でしょうか?}1 のメンバーではありません}0'
# 'candidate template ignored: cannot deduce a type for %0 that would make %2 equal %1'
H7E4350C35AB8: '%0の型を推論できませんでしたので %2が%1と等しくなるようにできません — 候補テンプレートは無視されました'
# 'candidate template ignored: constraints not satisfied%0'
H6E9C2A6AF9DA: 'テンプレート候補が無視されました: 約束が満たされませんでした%0'
# 'candidate template ignored: could not match %diff{$ against $|types}0,1'
HBFC6A5130527: 'テンプレート候補が無視されました: %diff{$ と $ を|タイプ}0,1 が一致しません'
# 'candidate template ignored: could not match %q0 against %q1'
H95615A85BC94: 'テンプレート候補が無視されました: %q0 と %q1 が一致しません'
# "candidate template ignored: couldn't infer template argument %0"
H0865F809FC7F: 'テンプレート候補が無視されました: テンプレート引数 %0 を推論できませんでした'
# 'candidate template ignored: deduced %select{conflicting types|conflicting values|conflicting templates|packs of different lengths}0 for parameter %1%diff{ ($ vs. $)|}2,3'
HC96827B6C1DA: 'テンプレート候補が無視されました: パラメータ %1 の %select{競合する型|競合する値|競合するテンプレート|異なる長さのパック}0 が %diff{ ($ と $)|}2,3 で推論されました'
# 'candidate template ignored: deduced too few arguments for expanded pack %0; no argument for %ordinal1 expanded parameter in deduced argument pack %2'
HCCA72493BB47: 'テンプレート候補無効: 展開パック%0 に十分な引数が推論されませんでした; 展開パラメータ%ordinal1 のための引数が%2 に存在しません'
# 'candidate template ignored: deduced type %diff{$ of %select{|element of }4%ordinal0 parameter does not match adjusted type $ of %select{|element of }4argument|of %select{|element of }4%ordinal0 parameter does not match adjusted type of %select{|element of }4argument}1,2%3'
HF6006A393B95: '候補テンプレートは無視されました: deduced type %diff{%select{|要素の}4%ordinal0パラメータの$が調整済み型$の%select{|要素の}4引数と一致しません|of %select{|element of }4%ordinal0 parameter does not match adjusted type of %select{|element of }4argument}1,2%3'
# 'candidate template ignored: deduced values %diff{of conflicting types for parameter %0 (%1 of type $ vs. %3 of type $)|%1 and %3 of conflicting types for parameter %0}2,4'
H300B96CC7A66: 'テンプレート候補が無視されました: パラメータ %0 の推論値 %diff{が競合しています (%1 の型 $ と %3 の型 $)|%1 と %3 が競合する型で %0 の値を推論できません}2,4'
# 'candidate template ignored: disabled by %0%1'
H0A4EC193E9D6: 'テンプレート候補が無視されました: %0%1 によって無効にされました'
# 'candidate template ignored: failed template argument deduction'
HF2D6EBE56EA1: 'テンプレート候補を無視: テンプレート引数推論に失敗'
# 'candidate template ignored: invalid explicitly-specified argument for %ordinal0 template parameter'
H7C80ECA5E832: 'テンプレート候補を無視: %ordinal0 テンプレート引数の明示的指定が無効'
# 'candidate template ignored: invalid explicitly-specified argument for template parameter %0'
HEDC828688F33: 'テンプレート候補を無視: テンプレート引数 %0 の明示的指定が無効'
# "candidate template ignored: requirement '%0' was not satisfied%1"
HB155E3417C9D: "テンプレート候補を無視: 要件 '%0' が満たされませんでした%1"
# 'candidate template ignored: substitution exceeded maximum template instantiation depth'
H6065ACD0EE36: 'テンプレート候補を無視: テンプレートインスタンス化深さの最大値を超えました'
# 'candidate template ignored: substitution failure%0%1'
HF32FE861D856: 'テンプレート候補を無視: 代入失敗%0%1'
# 'candidate template ignored: target attributes do not match'
H8F2E4648A7AB: 'テンプレート候補を無視: ターゲット属性が一致しません'
# "cannot %select{#include files|import headers}0 inside '#pragma clang arc_cf_code_audited'"
HE8C6864AFFBD: " '#pragma clang arc_cf_code_audited' 内で %select{#include ファイル|ヘッダをインポート}0 することはできません"
# "cannot %select{#include files|import headers}0 inside '#pragma clang assume_nonnull'"
H5A02E21DB221: " '#pragma clang assume_nonnull' 内で %select{#include ファイル|ヘッダをインポート}0 することはできません"
# 'cannot %select{access base class of|access derived class of|access field of|access array element of|ERROR|access real component of|access imaginary component of}0 pointer past the end of object'
HBEBB0813D273: ' %select{基底クラスの|派生クラスの|フィールドの|配列要素の|ERROR|実部の|虚部の}0 ポインタをオブジェクトの末尾の先にアクセスできません'
# 'cannot %select{access base class of|access derived class of|access field of|access array element of|perform pointer arithmetic on|access real component of|access imaginary component of}0 null pointer'
H2E784B2C1B28: ' %select{基底クラスの|派生クラスの|フィールドの|配列要素の|ポインタ算術の|実部の|虚部の}0 NULL ポインタをアクセスできません'
# 'cannot %select{assign|return|throw|subscript}0 a WebAssembly table'
H1D574B1BA9C6: 'WebAssembly テーブルを %select{代入|戻す|スロー|サブスクリプト}0することはできません'
# 'cannot %select{capture|take address of}0 WebAssembly reference'
H1706BDA5F276: 'WebAssembly リファレンスを %select{キャプチャできません|アドレスを取得できません}0'
# 'cannot %select{decrement|increment}0 expression of enum type %1'
H9709AF91935B: 'enum 型 %1 の %select{減算|加算}0 式はできません'
# 'cannot %select{decrement|increment}1 value of type %0'
H7C6ED23E2E9F: '%select{減算|加算}1 演算子の型 %0 は使用できません'
# 'cannot %select{form pointer to|form reference to|form array of|form function returning|use parentheses when declaring variable with}0 deduced class template specialization type'
HAF4CF818160D: '%select{ポインタを形成できません|参照を形成できません|配列を形成できません|戻り値として関数を宣言できません|変数宣言に丸カッコを使用できません}0 選択されたテンプレート型'
# 'cannot %select{throw|catch}0 a WebAssembly reference type'
H3CB66A7D1B81: 'WebAssembly リファレンスタイプを %select{スローできません|キャッチできません}0'
# "cannot %select{use builtin operator '<=>'|default 'operator<=>'}1 because type '%0' was not found; include <compare>"
H40A5A6DFAC87: "'%0'型が見つからないため%select{ビルトイン演算子'<=>'を使用|'operator<=>'をデフォルト}1できません；<compare>を含めること"
# 'cannot %select{use type %1 for a function/method parameter|use type %1 for function/method return|default-initialize an object of type %1|declare an automatic variable of type %1|copy-initialize an object of type %1|assign to a variable of type %1|construct an automatic compound literal of type %1|capture a variable of type %1|cannot use volatile type %1 where it causes an lvalue-to-rvalue conversion}3 since it %select{contains|is}2 a union that is non-trivial to %select{default-initialize|destruct|copy}0'
H72F7777296D1: '%select{デフォルト初期化|破棄|コピー}0が非自明なユニオンを%select{含む|である}2ため、%select{関数/メソッドの引数として%1型を使用|関数/メソッドの戻り値として%1型を使用|%1型のオブジェクトをデフォルト初期化|オート変数として%1型を宣言|オブジェクト%1をコピー初期化|%1型の変数に代入|%1型のオート複合リテラルを作成|変数%1をキャプチャ|volatile型%1をlvalue→rvalue変換が必要な場所で使用}3できません'
# 'cannot %select{||reinterpret_cast||C-style cast||}0 from member pointer type %1 to member pointer type %2 of different size'
H4DC29F600065: '%select{||reinterpret_cast||Cスタイルキャスト||}0で%1から%2へメンバーポインタ型変換できません（サイズ異なる）'
# "cannot add 'abi_tag' attribute in a redeclaration"
H48F70104AB1E: 'ABIタグ属性を再宣言で追加できません'
# 'cannot add a default template argument to the definition of a member of a class template'
H770ED38EE4A2: 'クラステンプレートのメンバー定義にテンプレート引数のデフォルト値を追加できません'
# 'cannot allocate %select{function|reference}1 type %0 with new'
HA111D2195E5D: '%select{関数|参照}1型%0はnewで割り当てられません'
# "cannot allocate array of 'auto'"
H63BE6FF3ACD1: "'auto'型の配列を割り当てられません"
# "cannot allocate array; evaluated array bound %0 exceeds the limit (%1); use '-fconstexpr-steps' to increase this limit"
H786F30B07D61: "配列割り当て失敗：計算された要素数%0が制限値(%1)を超えています；'-fconstexpr-steps'オプションで制限値を変更"
# 'cannot allocate array; evaluated array bound %0 is negative'
H5D0D0D0008CA: '配列割り当て失敗：計算された要素数%0が負の値です'
# 'cannot allocate array; evaluated array bound %0 is too large'
H7762F6A6D3EC: '配列割り当て失敗：計算された要素数%0が大きすぎます'
# 'cannot allocate array; evaluated array bound %0 is too small to hold %1 explicitly initialized elements'
H33075FED0F6C: '配列割り当て失敗：明示的初期化要素%1が%0要素の最小サイズを下回っています'
# 'cannot allocate memory of %select{incomplete|function}0 type %1'
H1CE3476A2AA9: '%select{未完全|関数}0型%1はメモリ割り当てできません'
# "cannot allocate untyped memory in a constant expression; use 'std::allocator<T>::allocate' to allocate memory of type 'T'"
H659085361859: "'std::allocator<T>::allocate'で型'T'のメモリを割り当てて定数式で扱う必要があります"
# "cannot apply AST actions to LLVM IR file '%0'"
HB65858D558EB: "LLVM IRファイル'%0'にはASTアクションを適用できません"
# 'cannot apply asm label to %select{variable|function}0 after its first use'
H75A6849C042D: 'その最初の使用後、%select{変数|関数}0 にアセンブリラベルを適用できません'
# "cannot assign to 'self' in a class method"
HA56E4ED9D1F5: "'self' をクラスメソッド内で代入できません"
# "cannot assign to 'self' outside of a method in the init family"
HC5091C795252: "'self' を init メソッド族外で代入できません"
# 'cannot assign to a variable captured by copy in a non-mutable lambda'
H135A3A08A93B: 'コピーによる非可変lambdaでコピーされた変数を代入できません'
# 'cannot assign to class object (%0 invalid)'
H25AF70C115F7: 'クラスオブジェクト (%0 無効) に代入できません'
# "cannot assign to this %select{dictionary|array}1 because assigning method's 2nd parameter of type %0 is not an Objective-C pointer type"
H33D10E761543: 'この %select{辞書|配列}1 に代入できません: 代入メソッドの2番目の引数%0 はObjective-Cポインタ型ではありません'
# 'cannot befriend target of using declaration'
H72752EB56616: 'using宣言の対象を友達指定できません'
# 'cannot bind non-lvalue argument %0 to %select{|in}1out paramemter'
HD7C1DD47E42B: '非lvalue引数%0 を%select{|in}1outパラメータにバインドできません'
# 'cannot build range expression with array function parameter %0 since parameter with array type %1 is treated as pointer type %2'
H882392B5B8E6: '配列関数パラメータ%0 は配列型%1 をポインタ型%2 として扱うため範囲式を構築できません'
# "cannot call function '%1' while %0 '%2' is held"
HE0B68C2EF3F0: "%0 '%2' が保持されている間、関数 '%1' を呼び出せません"
# 'cannot call operator __uuidof on a type with multiple GUIDs'
H6DB6EE36C688: '複数のGUIDを持つ型に対して__uuidof演算子を適用できません'
# 'cannot call operator __uuidof on a type with no GUID'
HCAE7CA56FF69: 'GUIDを持たない型に対して__uuidof演算子を適用できません'
# 'cannot capture __autoreleasing variable in a %select{block|lambda by copy}0'
H9DA2D963C91D: '__autoreleasing変数を%select{ブロック|コピーによるlambda}0 内でキャプチャできません'
# 'cannot cast %0 to %1 via virtual base %2'
H794ABE3B9398: '仮想基底クラス%2経由で%0を%1にキャストできません'
# 'cannot cast %0 to its %select{private|protected}2 base class %1'
H7E4D1C189883: '%select{プライベート|プロテクテッド}2基底クラス %1を%0にキャストできません'
# 'cannot cast %select{private|protected}2 base class %1 to %0'
HEB1FE12D1532: '%select{プライベート|プロテクテッド}2基底クラス%1から%0をキャストできません'
# 'cannot cast %select{to|from}0 a WebAssembly table'
H608D936A86AA: '%select{to|from}0WebAssemblyテーブルにキャストできません'
# "cannot cast 'super' (it isn't an expression)"
H77DA1D89D4EF: "'super'をキャストできません（これは式ではありません）"
# "cannot cast an object of type %select{'nullptr_t' to %1|%1 to 'nullptr_t'}0"
H379020AFC623: "%select{'nullptr_t'から%1に|%1を'nullptr_t'に}0キャストできません"
# 'cannot cast from lvalue of type %1 to rvalue reference type %2; types are not compatible'
HD498E8671ADF: 'lvalue型%1をrvalueリファレンスタイプ%2にキャストできません（型は互換ではありません）'
# 'cannot cast from rvalue of type %1 to rvalue reference type %2; types are not compatible'
H81F8D1E74E50: 'rvalue型%1をrvalueリファレンスタイプ%2にキャストできません（型は互換ではありません）'
# 'cannot cast from type %1 to member pointer type %2'
HC0F42A4D9625: '型%1をメンバーポインタ型%2にキャストできません'
# 'cannot cast from type %1 to pointer type %2'
H1C20AF9781FF: '型%1をポインタ型%2にキャストできません'
# "cannot cast non-zero value '%0' to 'event_t'"
HB63F6FC3F823: "イベント型'event_t'に非ゼロ値'%0'をキャストできません"
# 'cannot cast object of dynamic type %0 to type %1'
H29A99B2195B9: '動的型%0のオブジェクトを型%1にキャストできません'
# 'cannot catch %select{|reference to }0sizeless type %1'
HFDB51E9BFE05: '%select{|参照先の}0型%1（サイズなし）をキャッチできません'
# 'cannot catch an Objective-C object by value'
HE53524ADBBC8: '値でObjective-Cオブジェクトをキャッチできません'
# 'cannot catch an exception thrown with @throw in C++ in the non-unified exception model'
HA5FD18981E9C: '非統一例外モデルにおいて、C++で@throwで投げられた例外をキャッチできません'
# 'cannot catch exceptions by rvalue reference'
H5BF423F821AB: 'rvalue参照で例外をキャッチできません'
# 'cannot catch incomplete type %0'
H712DCF7BC1DF: '未完了型%0をキャッチできません'
# 'cannot catch pointer to incomplete type %0'
H555C8CE71019: '未完了型%0へのポインタをキャッチできません'
# 'cannot catch reference to incomplete type %0'
HAB26C8BE4E6D: '未完了型%0への参照をキャッチできません'
# 'cannot catch variably modified type %0'
H3E0D097A06D0: '可変長型%0をキャッチできません'
# 'cannot combine GNU and %select{SVE|RVV}0 vectors in expression, result is ambiguous (%1 and %2)'
H6D9DAA9A57DC: 'GNUと%select{SVE|RVV}0ベクタを式で組み合わせることはできません（%1と%2の結果が曖昧です）'
# 'cannot combine fixed-length and sizeless %select{SVE|RVV}0 vectors in expression, result is ambiguous (%1 and %2)'
H3EDDFBE7A4DF: '固定長とサイズなし%select{SVE|RVV}0ベクタを式で組み合わせることはできません（%1と%2の結果が曖昧です）'
# "cannot combine with previous '%0' declaration specifier"
H4EE2F7A93C38: "前の'%0'宣言指定子と組み合わせることはできません"
# "cannot combine with previous '%0' declaration specifier. '__vector' must be first"
H856686567DB2: "前の'%0'宣言指定子と組み合わせることはできません。 '__vector'は最初に指定する必要があります"
# 'cannot compile this %0 yet'
H395022428A23: 'この%0はまだコンパイルできません'
# 'cannot compress debug sections (%0 not enabled)'
HB2DFAB48BA84: 'デバッグセクションを圧縮できません（%0 が有効になっていません）'
# 'cannot compute offset of bit-field %0'
H55C2FB73C827: 'ビットフィールド %0 のオフセットを計算できません'
# "cannot constant evaluate '%select{memcpy|memmove}0' between objects of incomplete type %1"
H474B41288CFB: "'%select{memcpy|memmove}0' の不完全型 %1 のオブジェクト間での定数評価が不可能です"
# "cannot constant evaluate '%select{memcpy|memmove}0' between objects of non-trivially-copyable type %1"
H4AA44A4233D2: "'%select{memcpy|memmove}0' の非単純コピー可能型 %1 のオブジェクト間での定数評価が不可能です"
# "cannot constant evaluate '%select{memcpy|memmove}0' from object of type %1 to object of type %2"
H6FAB8AA1F441: "'%select{memcpy|memmove}0' の型 %1 オブジェクトから型 %2 オブジェクトへの定数評価が不可能です"
# 'cannot constant evaluate the result of adjusting alignment to %0'
H8F0F0485C85D: 'アラインメント %0 への調整結果の定数評価が不可能です'
# 'cannot constant evaluate whether run-time alignment is at least %0'
H8DC5B278E189: 'ランタイムアラインメントが %0 以上であるかの定数評価が不可能です'
# 'cannot construct object of type %0 with virtual base class in a constant expression'
H7DD1FDBBEF06: '仮想基底クラスを含む型 %0 の定数式でのオブジェクト作成が不可能です'
# 'cannot convert %0 token to an identifier'
H18B9F6746EBF: '%0 タークンを識別子に変換できません'
# 'cannot convert %1 to %2 without a conversion operator'
H703415593D2A: '変換演算子なしでは %1 を %2 に変換できません'
# 'cannot convert between %select{scalar|vector}0 type %1 and vector type %2 as implicit conversion would cause truncation'
HF046F296A9B0: '%select{スカラ|ベクター}0 型 %1 とベクター型 %2 の暗黙変換は切り詰めを引き起こすためできません'
# 'cannot convert between vector and non-scalar values (%0 and %1)'
HD81F5D7E2B16: 'スカラとベクターの値の間の変換が不可能 (%0 と %1)'
# 'cannot convert between vector values of different size (%0 and %1)'
H8810EF643AA5: '異なるサイズのベクター値間の変換が不可能 (%0 と %1)'
# 'cannot create __weak reference because the current deployment target does not support weak references'
H54D605FEB00B: '現在のデプロイメントターゲットが弱参照をサポートしていないため __weak リファレンスを作成できません'
# 'cannot create __weak reference in file using manual reference counting'
H98AD8AE899EB: '手動参照カウントを使用しているファイルでは __weak リファレンスを作成できません'
# 'cannot create a non-constant pointer to member function'
H909CEC9754E8: 'メンバ関数への非定数ポインタを作成できません'
# 'cannot create includes file for module %0: %1'
H521EA5757B62: 'モジュール %0 のインクルードファイル作成に失敗: %1'
# 'cannot create object of function type %0'
HB6BCDD252F4D: '関数型 %0 のオブジェクトを作成できません'
# 'cannot declare a class template with no name'
H86275B9FD8C9: '名前のないクラステンプレートを宣言することはできません'
# 'cannot declare an explicit specialization in a friend'
H8E19851C2991: 'friend内で明示的な特殊化を宣言することはできません'
# 'cannot declare class extension for %0 after class implementation'
H472ADAE23CEA: '%0のクラス実装後にクラス拡張を宣言することはできません'
# "cannot declare implementation of a class declared with the 'objc_class_stub' attribute"
H831B35F688CB: "'objc_class_stub'属性で宣言されたクラスの実装を宣言することはできません"
# "cannot declare the namespace 'std' to be inline"
H1345EF64CB88: "'std'名前空間をinlineと宣言することはできません"
# 'cannot declare variable inside @interface or @protocol'
H11D626BF5B37: '@interfaceまたは@protocol内で変数を宣言することはできません'
# 'cannot decompose %select{private|protected}0 member %1 of %3'
HAF5B2F15564E: '%select{private|protected}0メンバ%1の%3を分解できません'
# 'cannot decompose %select{union|non-class, non-array}1 type %2'
HD213477C2A3A: '%select{union|非クラス、非配列}1型%2を分解できません'
# 'cannot decompose class type %0 because it has an anonymous %select{struct|union}1 member'
H687FA194A579: '匿名%select{struct|union}1メンバを持つクラス型%0を分解できません'
# 'cannot decompose class type %1: %select{its base classes %2 and|both it and its base class}0 %3 have non-static data members'
HBC0288C04290: '基底クラス%2と%select{その基底クラスと|}0%3の非静的データメンバにより、クラス型%1を分解できません'
# 'cannot decompose lambda closure type'
H3C6B1EAC26ED: 'lambdaクロージャ型を分解できません'
# 'cannot decompose members of ambiguous base class %1 of %0:%2'
HE08DBE349649: '%0の曖昧な基底クラス%1のメンバを分解できません:%2'
# 'cannot decompose members of inaccessible base class %1 of %0'
HA6ED46C6B298: '%0のアクセスできない基底クラス%1のメンバを分解できません'
# "cannot decompose this type; 'std::tuple_element<%0>::type' does not name a type"
H4AD140BFCF3D: "この型を分解できません;'std::tuple_element<%0>::type'は型を指しません"
# "cannot decompose this type; 'std::tuple_size<%0>::value' is not a valid integral constant expression"
HE140F3EE6033: "この型を分解できません;'std::tuple_size<%0>::value'は有効な整数定数式ではありません"
# 'cannot decrement expression of type bool'
H9DABD4A4074A: 'bool型の式をデクリメントできません'
# "cannot deduce 'decltype(auto)' from initializer list"
H0294CF60338E: "'decltype(auto)'の初期化子リストからの型推論が不可能です"
# 'cannot deduce actual type for %1 from %select{parenthesized|nested}0 initializer list'
H1C99EC9B7047: '%select{括弧付き|ネストした}0初期化子リストから%1の実際の型を推論できません'
# 'cannot deduce actual type for variable %0 with type %1 from initializer list'
HA7FCCDD3352E: 'イニシャライザリストから変数%0の型%1の実際の型を推論できません'
# 'cannot deduce implicit triple value for -Xopenmp-target, specify triple using -Xopenmp-target=<triple>'
HBB4FDAD01556: '-Xopenmp-targetのトリプル値を暗黙には推論できません。-Xopenmp-target=<triple>でトリプルを指定してください'
# 'cannot deduce lambda return type from initializer list'
HBF4499B07FAC: 'イニシャライザリストからラムダの戻り値型を推論できません'
# 'cannot deduce return type %0 for function with no return statements'
H4A0B0541DA05: '戻り命令がない関数では戻り型%0を推論できません'
# 'cannot deduce return type %0 from omitted return expression'
HF76745F04CDD: '省略された戻り式から戻り型%0を推論できません'
# 'cannot deduce return type %0 from returned value of type %1'
HFF6A0873771C: '型%1の戻り値から戻り型%0を推論できません'
# 'cannot deduce return type from initializer list'
HD33E533A8026: 'イニシャライザリストから戻り値型を推論できません'
# 'cannot deduce template arguments for %0 from %1'
H59FFC4EE513D: '%1からテンプレート引数%0を推論できません'
# 'cannot deduce type for lambda capture %0 from initializer list'
HD1B46B897454: 'イニシャライザリストからラムダキャプチャ%0の型を推論できません'
# 'cannot deduce type for lambda capture %0 from initializer of type %2'
H5BED86131FDB: '%0のlambdaキャプチャの型を%2型の初期化子から推論できません'
# 'cannot deduce type for lambda capture %1 from %select{parenthesized|nested}0 initializer list'
HBAF719ACD121: '%select{括弧付き|ネストされた}0イニシャライザリストからキャプチャ%1の型を推論できません'
# 'cannot deduce type for variable %1 with type %2 from %select{parenthesized|nested}0 initializer list'
HDBF6BFDD94D3: '%select{括弧付き|ネストされた}0イニシャライザリストから変数%1の型%2を推論できません'
# 'cannot deduce type of initializer list because std::initializer_list was not found; include <initializer_list>'
H61AB50323785: 'std::initializer_listが見つからないためイニシャライザリストの型を推論できません; <initializer_list>を含めます'
# 'cannot define %select{category|class extension}0 for undefined class %1'
H075CA56C0949: '未定義のクラス%1の%select{カテゴリ|クラス拡張}0を定義できません'
# 'cannot define a type in a friend declaration'
H90F602DED3B4: 'フレンド宣言内で型を定義することはできません'
# 'cannot define friend function %0 in a local class definition; did you mean %3?'
H40B3F3B5FBB1: 'ローカルクラス定義内でフレンド関数%0を定義できません; %3を指定しましたか？'
# 'cannot define friend function in a local class definition'
HB60D03F3A5C5: 'ローカルクラス定義内でフレンド関数を定義できません'
# 'cannot define non-inline dllimport template specialization'
HF67617A49B06: '非インラインのdllimportテンプレート特別化を定義できません'
# 'cannot define or redeclare %0 here because namespace %1 does not enclose namespace %2'
HFA38E82744C2: 'ネームスペース%1はネームスペース%2を包含しないため、ここでは%0を定義または再宣言できません'
# 'cannot define the implicit copy assignment operator for %0, because non-static %select{reference|const}1 member %2 cannot use copy assignment operator'
H50812469123A: '%2の非静的%select{参照|const}1メンバがコピー代入演算子を使用できないため、%0の暗黙のコピー代入演算子を定義できません'
# 'cannot delete expression of type %0'
H8F9B57A837EE: '%0型の式を解放できません'
# "cannot delete expression with pointer-to-'void' type %0"
HCCFA093E9DE2: "ポインタ-to-'void'型%0の式を解放できません"
# 'cannot delete pointer to incomplete type %0'
H7E32F7F5C2AD: '未完成型%0のポインタを解放できません'
# "cannot determine %0 architecture: %1; consider passing it via '%2'; environment variable CLANG_TOOLCHAIN_PROGRAM_TIMEOUT specifies the tool timeout (integer secs, <=0 is infinite)"
H9E1578DA83DB: "%0アーキテクチャを特定できません: %1; '%2'経由で明示的に指定してください; 環境変数CLANG_TOOLCHAIN_PROGRAM_TIMEOUTはツールタイムアウトを指定（整数秒、0以下は無限）"
# 'cannot determine allocated array size from initializer'
H3573086C6F39: '初期化子から配列の確保サイズを特定できません'
# 'cannot determine number of elements for sizeless vectors in a constant expression'
HAFC6AFA63009: '定数式でのサイズなしベクタの要素数を特定できません'
# 'cannot determine underlying type of incomplete enumeration type %0'
H486DE8FE7D9E: '未完成列挙型%0の基底型を特定できません'
# 'cannot emit module %0: %select{size|mtime}1 must be explicitly specified for missing header file "%2"'
H4AFEE6C7D624: '存在しないヘッダーファイル"%2"の%select{サイズ|最終変更時刻}1を明示的に指定する必要がありますのでモジュール%0を発行できません'
# 'cannot evaluate call to virtual function in a constant expression in C++ standards before C++20'
HC06FC1196550: 'C++20以前のC++基準では定数式で仮想関数を呼び出すことはできません'
# 'cannot evaluate this expression if rounding mode is dynamic'
HC673B661CF5A: '丸めモードが動的の場合この式を評価できません'
# 'cannot export %0 as it is not at namespace scope'
H49EEB2061C19: '名前空間スコープ外にあるため%0をエクスポートできません'
# 'cannot export redeclaration %0 here since the previous declaration %select{is not exported|has internal linkage|has module linkage}1'
H805545AFF107: '前の宣言%select{がエクスポートされていない|が内部リンケージ|がモジュールリンケージ}1ため、%0の再宣言をここでエクスポートできません'
# "cannot find CUDA installation; provide its path via '--cuda-path', or pass '-nocudainc' to build without CUDA includes"
H483DC86F4594: "CUDAインストールが見つかりません; '--cuda-path'でパスを指定、または'-nocudainc'オプションでCUDAインクルードなしでビルドしてください"
# "cannot find HIP Standard Parallelism Acceleration library; provide it via '--hipstdpar-path'"
H20ABDE201926: "'--hipstdpar-path'でHIP標準並列化ライブラリの場所を指定してください"
# "cannot find HIP device library%select{| for %1}0; provide its path via '--hip-path' or '--hip-device-lib-path', or pass '-nogpulib' to build without HIP device library"
H74B6BE24033A: "HIPデバイスライブラリ%select{ |%1用}0が見つかりません; '--hip-path'または'--hip-device-lib-path'でパスを指定、または'-nogpulib'オプションでHIPデバイスライブラリなしでビルドしてください"
# "cannot find HIP runtime; provide its path via '--rocm-path', or pass '-nogpuinc' to build without HIP runtime"
H11EBFA045BE3: "'--rocm-path'でHIPランタイムのパスを指定、または'-nogpuinc'オプションでHIPランタイムなしでビルドしてください"
# "cannot find ROCm device library%select{| for %1| for ABI version %1}0; provide its path via '--rocm-path' or '--rocm-device-lib-path', or pass '-nogpulib' to build without ROCm device library"
H7B7F4A357272: "ROCMデバイスライブラリ%select{ |%1用|ABIバージョン%1用}0が見つかりません; '--rocm-path'または'--rocm-device-lib-path'でパスを指定、または'-nogpulib'オプションでROCMデバイスライブラリなしでビルドしてください"
# 'cannot find a valid user-defined mapper for type %0 with name %1'
H0907A5973C27: '%0 という名前の型 %1 用のユーザー定義マッパーが見つかりません'
# "cannot find end ('%1') of expected %0"
H53A2AE90D9C0: "予期される %0 の終了 ('%1') が見つかりません"
# 'cannot find interface declaration for %0'
H7325D139C40F: '%0 のインターフェース宣言が見つかりません'
# 'cannot find interface declaration for %0, superclass of %1'
HDDF90FE7BE8F: '%1 のスーパークラスである %0 のインターフェース宣言が見つかりません'
# 'cannot find interface declaration for %0, superclass of %1; did you mean %2?'
H691319D1E232: '%1 のスーパークラスである %0 のインターフェース宣言が見つかりません; %2 の意図ではないでしょうか？'
# 'cannot find interface declaration for %0; did you mean %1?'
H3FD5BD5869C6: '%0 のインターフェース宣言が見つかりません; %1 の意図ではないでしょうか？'
# "cannot find libdevice for %0; provide path to different CUDA installation via '--cuda-path', or pass '-nocudalib' to build without linking with libdevice"
H9C8FBD27D916: "'%0' 用のlibdeviceが見つかりません; 有効なCUDAインストールパスを'--cuda-path'で指定、または'-nocudalib'でlibdeviceリンクを省略してビルドしてください"
# 'cannot find protocol declaration for %0'
H8559765777E9: '%0 のプロトコル宣言が見つかりません'
# 'cannot find protocol declaration for %0; did you mean %1?'
H39967D7F0C23: '%0 のプロトコル宣言が見つかりません; %1 の意図ではないでしょうか？'
# 'cannot find protocol definition for %0'
H30EC809C2E8C: '%0 のプロトコル定義が見つかりません'
# "cannot find re-exported %select{framework|library}0: '%1'"
HFF74F7CAAAC8: "再エクスポートされた %select{フレームワーク|ライブラリ}0: '%1' が見つかりません"
# "cannot find rocPrim, which is required by the HIP Standard Parallelism Acceleration library; provide it via '--hipstdpar-prim-path'"
H7420A8DBF79F: "HIP並列処理アクセラレーションライブラリで要求されるrocPrimが見つかりません; '--hipstdpar-prim-path'で指定してください"
# "cannot find rocThrust, which is required by the HIP Standard Parallelism Acceleration library; provide it via '--hipstdpar-thrust-path'"
HF20DC196E1CB: "HIP並列処理アクセラレーションライブラリで要求されるrocThrustが見つかりません; '--hipstdpar-thrust-path'で指定してください"
# "cannot find start ('{{') of expected %0"
H727EB43115FC: "予期される %0 の開始 ('{{') が見つかりません"
# "cannot find start of regex ('{{') in %0"
HD5BDA70A3617: "%0 内の正規表現開始 '{{' が見つかりません"
# 'cannot find suitable %select{getter|setter}0 for property %1'
H0F811370E791: 'プロパティ %1 用の適切な %select{getter|setter}0 を見つかりません'
# "cannot form %select{pointer to|reference to|array of}0 'decltype(auto)'"
H7F41F0A9CCC7: "'decltype(auto)' に対する %select{ポインタ|参照|配列}0 を作成できません"
# 'cannot form a %select{pointer|reference}0 to a WebAssembly table'
H3C39E76E28BC: 'WebAssemblyテーブルに対する %select{ポインタ|参照}0 を作成できません'
# 'cannot form a pointer-to-member to member %0 of reference type %1'
H45A1DB7A6AF3: '参照型 %1 のメンバー %0 に対するメンバーポインタを作成できません'
# "cannot form a reference to 'void'"
H6E82068C4FE4: 'void への参照は作成できません'
# "cannot form member pointer of type %0 without '&' and class name"
HA98A1BC7CEC4: "'&' を省略した状態で %0 型のメンバーポインタを作成できません"
# 'cannot generate code for reduction on %select{|array section, which requires a }0variable length array'
H328E15AAC013: '変数長配列を必要とする %select{|配列セクションの }0 変数長配列のリダクションにはコードを生成できません'
# 'cannot have both throw() and noexcept() clause on the same function'
H93A58AAAE480: '同一の関数に throw() および noexcept() の句を両方持てません'
# 'cannot implement a category for class %0 that is only visible via the Objective-C runtime'
H93EA111FC5EC: 'Objective-C ランタイムのみ経由して可視なクラス %0 のカテゴリを実装できません'
# 'cannot implement subclass %0 of a superclass %1 that is only visible via the Objective-C runtime'
H0C79ADD5940E: 'Objective-C ランタイムのみ経由して可視なスーパークラス %1 のサブクラス %0 を実装できません'
# 'cannot import unsupported AST node %0'
H4E75F3A5019B: 'サポートされていない AST ノード %0 をインポートできません'
# 'cannot initialize %select{a variable|a parameter|template parameter|return object|statement expression result|an exception object|a member subobject|an array element|a new value|a value|a base class|a constructor delegation|a vector element|a block element|a block element|a complex element|a lambda capture|a compound literal initializer|a related result|a parameter of CF audited function|a structured binding|a member subobject}0 %diff{of type $ with an %select{rvalue|lvalue}2 of type $|with an %select{rvalue|lvalue}2 of incompatible type}1,3%select{|: different classes%diff{ ($ vs $)|}5,6|: different number of parameters (%5 vs %6)|: type mismatch at %ordinal5 parameter%diff{ ($ vs $)|}6,7|: different return type%diff{ ($ vs $)|}5,6|: different qualifiers (%5 vs %6)|: different exception specifications}4'
H5225AD7ABD6B: '%select{変数|パラメータ|テンプレートパラメータ|戻り値オブジェクト|ステートメント式結果|例外オブジェクト|メンバー部分オブジェクト|配列要素|新しい値|値|基底クラス|コンストラクタのデリゲーション|ベクター要素|ブロック要素|ブロック要素|複素数要素|ラムダキャプチャ|複合リテラル初期化子|関連結果|CF検証関数のパラメータ|構造化バインディング|メンバー部分オブジェクト}0 %diff{の型 $ に %select{rvalue|lvalue}2 型 $ の値を|不整合な型の%select{rvalue|lvalue}2 で}1,3%select{|: 違うクラス%diff{ ($ vs $)|}5,6|: パラメータ数の不一致 (%5 vs %6)|: %ordinal5 番目のパラメータの型不一致%diff{ ($ vs $)|}6,7|: 戻り値の型が異なる%diff{ ($ vs $)|}5,6|: 質 qualifiers (%5 vs %6) が異なる|: 例外指定子が異なる}4 を指定できません'
# 'cannot initialize %select{non-class|reference}0 type %1 with a parenthesized initializer list'
HE63727C8C08B: '%select{非クラス|リファレンス}0 型 %1 は丸括弧で囲まれた初期化子リストで初期化できません'
# 'cannot initialize Objective-C class type %0'
HA709360A8ABC: 'Objective-C クラス型 %0 は初期化できません'
# 'cannot initialize array %diff{of type $ with array of type $|with different type of array}0,1'
HA759EFFA1CC7: '型$の配列で初期化できません%diff{ ($ vs $)|}0,1'
# 'cannot initialize array %diff{of type $ with non-constant array of type $|with different type of array}0,1'
HAEED299DACD1: '定数ではない配列型$で初期化できません%diff{ ($ vs $)|}0,1'
# 'cannot initialize object parameter of type %0 with an expression of type %1'
H01F0C7FE2242: '%0 型のオブジェクトパラメータを %1 型の式で初期化できません'
# 'cannot instantiate %0 yet'
H3C23130222AC: '%0 をまだインスタンス化できません'
# 'cannot jump from switch statement to this case label'
H0147E81C1C5E: 'switch 文からこの case ラベルにジャンプできません'
# 'cannot jump from this %select{indirect|asm}0 goto statement to one of its possible targets'
HA7FDD21785F4: 'この %select{間接|アセンブリ}0 goto 文の可能なターゲットのいずれかにジャンプできません'
# 'cannot jump from this continue statement to the loop increment; jump bypasses initialization of loop condition variable'
HF65BBB33CB19: 'ループ条件変数の初期化を飛ばすこの continue 文からループのインクリメント部にジャンプできません'
# 'cannot jump from this goto statement to its label'
HF7AC509BA0D6: 'このgotoステートメントからラベルにジャンプできません'
# 'cannot jump from this goto statement to label %0 inside an inline assembly block'
HBD667F79ECB9: 'この goto 文からインラインアセンブリ ブロック内のラベル %0 にジャンプできません'
# "cannot link module '%0': %1"
H957779E89D24: "モジュール'%0'のリンクに失敗しました: %1"
# 'cannot locate code-completion file %0'
H00AA0E96170A: 'コードコンプリーションファイル%0が見つかりません'
# 'cannot mangle fixed point literals yet'
H175F8CE0FB1D: '固定小数点リテラルのマングルはまだできません'
# 'cannot mangle this %0 %1 yet'
H50F33B0E4B4E: '%0 %1のマングルはまだできません'
# 'cannot mangle this %0 yet'
H1C98A95C714E: '%0のマングルはまだできません'
# 'cannot mangle this dependent fixed-length RVV vector type yet'
H01F50B3350B7: '依存する固定長RVVベクタータイプのマングルはまだできません'
# 'cannot mangle this dependent fixed-length SVE vector type yet'
H53C22EA00769: '依存する固定長SVEベクタータイプのマングルはまだできません'
# 'cannot mangle this dependent neon vector type yet'
H566B620CDB5E: '依存するNEONベクタータイプのマングルはまだできません'
# 'cannot mangle this requires-expression containing a substitution failure'
H9EEE8BF3FF53: '置換失敗を含むrequires式のマングルはできません'
# 'cannot mangle this unnamed union NTTP yet'
HC67F1942B567: '名前のないユニオンNTTPのマングルはまだできません'
# 'cannot mix packoffset elements with nonpackoffset elements in a cbuffer'
H5F5AED65EDDB: 'cbuffer内でpackoffset要素と非packoffset要素を混在させることはできません'
# 'cannot mix positional and non-positional arguments in format string'
HC2203B0385F9: '書式文字列で位置指定と非位置指定の引数を混在させることはできません'
# 'cannot mix vectors and extended vectors in a vector conditional'
H0C69F5DF40B4: 'ベクターコンディショナルでベクターと拡張ベクターを混在させることはできません'
# "cannot nest 'critical' regions having the same name %0"
HB0FDA4DB5B6B: "同じ名前%0を持つネストされた'critical'領域は使用できません"
# "cannot open file '%0': %1"
H7B318395BD4F: "ファイル'%0'を開けません: %1"
# "cannot overload a member function %select{without a ref-qualifier|with ref-qualifier '&'|with ref-qualifier '&&'}0 with a member function %select{without a ref-qualifier|with ref-qualifier '&'|with ref-qualifier '&&'}1"
H3E720DF8A96F: 'リファレンス修飾子%select{なし|&を伴う|&&を伴う}0をもつメンバ関数と、リファレンス修飾子%select{なし|&を伴う|&&を伴う}1をもつメンバ関数はオーバーロードできません'
# 'cannot override a method that is declared direct by a superclass'
H8D083337F734: 'スーパークラスによって直接宣言されたメソッドをオーバーライドすることはできません'
# 'cannot parenthesize the name of a method when forming a member pointer'
H733C76C89DE9: 'メンバポインタを形成する際にメソッド名を丸括弧で囲むことはできません'
# 'cannot pass %select{expression of type %1|initializer list}0 to variadic %select{function|block|method|constructor}2'
H25763FEA732A: '%select{%1型の式|イニシャライザリスト}0を可変長%select{関数|ブロック|メソッド|コンストラクタ}2に渡すことはできません'
# 'cannot pass %select{expression of type %1|initializer list}0 to variadic %select{function|block|method|constructor}2; expected type from format string was %3'
H6A81C62CC358: '%select{%1型の式|イニシャライザリスト}0を可変長%select{関数|ブロック|メソッド|コンストラクタ}2に渡せません; フォーマット文字列の期待する型は%3です'
# 'cannot pass %select{non-POD|non-trivial}0 object of type %1 to variadic %select{function|block|method|constructor}2; expected type from format string was %3'
HB3C416B2C325: '可変長 %select{関数|ブロック|メソッド|コンストラクタ}2 に非POD/非単純な %select{non-POD|non-trivial}0 型 %1 のオブジェクトを渡せません。フォーマット文字列の期待する型は %3 です'
# 'cannot pass a pointer-to-member through register-constrained inline assembly parameter'
H1A2FFC7DC3D0: 'インラインアセンブリパラメータのレジスタ制約を通じてメンバーポインタを渡すことはできません'
# 'cannot pass bit-field as __auto_type initializer in C'
HC2EE224C8229: 'Cの__auto_type初期化子においてビットフィールドを渡すことはできません'
# 'cannot pass non-trivial C object of type %0 by value to variadic %select{function|block|method|constructor}1'
H2C5461696894: '非trivial Cオブジェクト%0を値渡しで可変長%select{関数|ブロック|メソッド|コンストラクタ}1に渡すことはできません'
# 'cannot pass object of %select{non-POD|non-trivial}0 type %1 through variadic %select{function|block|method|constructor}2; call will abort at runtime'
H03C685EEC43F: '%select{非POD|non-trivial}0型%1のオブジェクトを可変長%select{関数|ブロック|メソッド|コンストラクタ}2に渡すことはできません。実行時に処理が中止されます'
# 'cannot pass object with interface type %0 by value through variadic %select{function|block|method|constructor}1'
HFFB4BE108833: 'インターフェース型%0の値を可変長%select{関数|ブロック|メソッド|コンストラクタ}1に値渡しで渡すことはできません'
# 'cannot pass object with interface type %1 by value to variadic %select{function|block|method|constructor}2; expected type from format string was %3'
HFCF01B48F1C2: 'インターフェース型%1の値を可変長%select{関数|ブロック|メソッド|コンストラクタ}2に値渡しで渡すことはできません。フォーマット文字列で指定された型は%3です'
# "cannot pass undiscriminated type %0 to '__builtin_ptrauth_type_discriminator'"
HCF5D52D0F4BA: '非区別型%0を「__builtin_ptrauth_type_discriminator」に渡すことはできません'
# 'cannot perform a tail call %select{from|to}0 a %select{constructor|destructor}1'
H92D6BE5E0D10: '%select{from|to}0 %select{コンストラクタ|デストラクタ}1へのテールコールはできません'
# 'cannot perform a tail call from this return statement'
HD566EFBB0F10: 'このreturn文からテールコールを実行できません'
# 'cannot perform a tail call to function%select{| %1}0 because it uses an incompatible calling convention'
H32E425482ACE: '関数%select{| %1}0が互換性のない呼び出し規約を使用しているためテールコールできません'
# 'cannot perform a tail call to function%select{| %1}0 because its signature is incompatible with the calling function'
HB6791E3481C6: '関数%select{| %1}0のシグネチャが呼び出し元関数と不一致のためテールコールできません'
# 'cannot perform atomic operation on a pointer to type %0: type has non-trivial ownership'
H33A9E57472E9: '非トレイivialな所有権を持つ型%0へのポインタに対するアトミック操作はできません'
# "cannot read configuration file '%0': %1"
H0AF7279B0969: "構成ファイル '%0' を読み込めません: %1"
# "cannot read randomize layout seed file '%0'"
H97BBD89360BC: "ランダム化レイアウトシードファイル '%0' を読み込めません"
# "cannot rebuild module '%0' as it is already finalized"
H80C2AA3A79E5: "すでに最終化されているためモジュール '%0' を再構築できません"
# 'cannot redeclare builtin function %0'
HC3E811B65243: '組込み関数%0を再宣言することはできません'
# 'cannot refer to a block inside block'
HEC4D55F7E1FA: 'ブロック内で内部ブロックを参照することはできません'
# 'cannot refer to a non-static member from the handler of a %select{constructor|destructor}0 function try block'
H7C221E1899F1: '%select{コンストラクタ|デストラクタ}0 関数のtryブロックのハンドラ内で静的でないメンバを参照できません'
# 'cannot refer to declaration of structure variable with flexible array member inside block'
H861E195F8EA8: 'フレキシブル配列メンバを含む構造体変数の宣言をブロック内で参照できません'
# 'cannot refer to declaration with a variably modified type inside block'
H3ACCC42BDE35: '可変型の宣言をブロック内で参照できません'
# 'cannot refer to declaration with an array type inside block'
HBA9381EF3C23: '配列型の宣言をブロック内で参照できません'
# 'cannot refer to element %0 of %select{array of %2 element%plural{1:|:s}2|non-array object}1 in a constant expression'
H97B7B294ED7C: '定数式において %select{要素数 %2 の配列%plural{1:|:s}2|非配列オブジェクト}1 の要素 %0 にアクセスできません'
# "cannot refer to member %0 in %1 with '%select{.|->}2'"
HF25CD96D4723: "%1 のメンバ %0 に '%select{.|->}2' でアクセスできません"
# "cannot refer to type member %0 in %1 with '%select{.|->}2'"
H982BCA02E9FD: "%1 のタイプメンバ %0 に '%select{.|->}2' でアクセスできません"
# 'cannot reference member of primary template because deduced class template specialization %0 is %select{instantiated from a partial|an explicit}1 specialization'
HF04074EDD691: '推論されたクラステンプレートの特殊化 %0 が %select{部分的特殊化から生成された|明示的特殊化}1 のため、プライマリテンプレートのメンバを参照できません'
# 'cannot resolve lock expression'
H9831838AB057: 'ロック式を解決できません'
# 'cannot return from %0'
HDE7181BDC39D: '%0 からreturnできません'
# 'cannot set vtable pointer authentication on %0 which is a subclass of polymorphic type %1'
H8615F820D27E: 'ポリモーフィック型 %1 のサブクラス %0 に対してvtableポインタ認証を設定できません'
# 'cannot set vtable pointer authentication on an incomplete type %0'
H50389542B8AD: '未完成型 %0 に対してvtableポインタ認証を設定できません'
# 'cannot set vtable pointer authentication on monomorphic type %0'
H365AD22227CA: '単型 %0 に対してvtableポインタ認証を設定できません'
# "cannot specialize %select{|(with 'template<>') }0a member of an unspecialized template"
H21C951459621: "%select{|(with 'template<>') }0未特殊化テンプレートのメンバを特殊化できません"
# 'cannot specialize a %select{dependent template|template template parameter}0'
HC5BFF931F55D: '%select{依存テンプレート|テンプレートテンプレートパラメータ}0 を特殊化できません'
# "cannot specify '%0%1' when compiling multiple source files"
HFD3172559132: "複数のソースファイルをコンパイルする際には'%0%1'を指定できません"
# "cannot specify '%1' along with '%0'"
H9F94923DAC7E: "'%0'と共に'%1'を指定できません"
# 'cannot specify -o when generating multiple output files'
HE249C344BFD2: '複数の出力ファイルを生成する際は -o オプションを指定できません'
# 'cannot specify a default vtable pointer authentication %select{key|address discrimination mode|discriminator}0 with no default set'
H3A1B9264D760: 'デフォルトが設定されていない状態で、vtableポインタ認証のデフォルト%select{キー|アドレス判別モード|ディスクリミネーター}0 を指定できません'
# "cannot specify any part of a return type in the declaration of a conversion function%select{; put the complete type after 'operator'|; use a typedef to declare a conversion to %1|; use an alias template to declare a conversion to %1|}0"
HAA40A3FFF9F4: '変換関数の宣言で戻り値の型の一部を指定できません%select{; 完全な型を「operator」の後に配置|; %1 への変換を typedef で宣言|; %1 への変換をエイリアステンプレートで宣言|}0'
# 'cannot specify any part of a return type in the declaration of a deduction guide'
H390B6E7B14DB: '推論ガイドの宣言で戻り値の型の一部を指定できません'
# 'cannot specify deduction guide for %select{<error>|function template|variable template|alias template|template template parameter|concept|dependent template name}0 %1'
H8A234F5E78B1: '%select{<エラー>|関数テンプレート|変数テンプレート|エイリアステンプレート|テンプレートテンプレートパラメータ|コンセプト|依存テンプレート名}0 %1 の推論ガイドを指定できません'
# "cannot specify parameter '%0' twice in the same '#embed' directive"
HD1DC8056B121: "'#embed' ディレクティブ内でパラメータ '%0' を2回指定できません"
# 'cannot store matrix to read-only pointer'
H425886F44B36: '読み取り専用ポインタに行列を格納できません'
# "cannot subclass a class that was declared with the 'objc_subclassing_restricted' attribute"
H5638A6FF93B7: "'objc_subclassing_restricted' 属性が指定されたクラスを継承できません"
# 'cannot synthesize property %0 with incomplete type %1'
H71A1173D4045: '未完了型 %1 のプロパティ %0 を合成できません'
# 'cannot synthesize weak property because the current deployment target does not support weak references'
H38DCEFEFA216: '現在のデプロイメントターゲットでは弱参照がサポートされていないため、弱プロパティを合成できません'
# 'cannot synthesize weak property in file using manual reference counting'
H0734CFB3421A: 'マニュアル参照カウントを使用しているファイル内では弱プロパティを合成できません'
# 'cannot take address of %select{immediate|consteval}2 %select{function|call operator of}1 %0 outside of an immediate invocation'
H530D63A21A7A: '%select{即時|consteval}2 %select{関数|の呼び出し演算子}1 %0 のアドレスを即時呼び出しの外側で取得できません'
# 'cannot take address of function %0 because it has one or more non-tautological enable_if conditions'
H23DB8FEDBD81: '非自明な enable_if 条件を1つ以上持つため、関数 %0 のアドレスを取得できません'
# 'cannot take address of function %0 because its constraints are not satisfied'
H4014F85A3BA5: '制約が満たされないため、関数 %0 のアドレスを取得できません'
# 'cannot take address of function %0 because parameter %1 has pass_object_size attribute'
H6872B0BADEA4: 'pass_object_size 属性を持つパラメータ %1 のため、関数 %0 のアドレスを取得できません'
# 'cannot take an address of a virtual member function if its return or argument types are incomplete'
HF3A5696A9EB7: '戻り値または引数の型が未完了であるため、仮想メンバー関数のアドレスを取得できません'
# 'cannot take the address of an rvalue of type %0'
H60F39E1B8F38: '%0型のr値のアドレスを取得できません'
# 'cannot template a using %select{directive|declaration}0'
H7E5220347031: 'using %select{宣言|ディレクティブ}0をテンプレート化できません'
# 'cannot throw an object of abstract type %0'
H1AA71488C1EF: '抽象型%0のオブジェクトをthrowできません'
# 'cannot throw object of incomplete type %0'
H5A0A40D72DE8: '未完全型%0のオブジェクトをthrowできません'
# 'cannot throw object of sizeless type %0'
HA8B5689740C7: 'サイズ不明型%0のオブジェクトをthrowできません'
# 'cannot throw object of type %0 with a potentially-throwing destructor'
HC355469628A0: '破棄時に例外が発生する可能性のある型%0のオブジェクトをthrowできません'
# 'cannot throw pointer to object of incomplete type %0'
H079B08EA2D25: '未完全型%0のオブジェクトへのポインタをthrowできません'
# 'cannot type cast @selector expression'
H485C835C56BA: '@selector式を型変換できません'
# "cannot use %select{'auto'|<ERROR>|'__auto_type'}0 with %select{initializer list|array}1 in C"
HE2E4F9E6D620: "C言語では%select{'auto'|<ERROR>|'__auto_type'}0を%select{初期化子リスト|配列}1と共に使用できません"
# "cannot use %select{C++ 'try'|Objective-C '@try'}0 in the same function as SEH '__try'"
H455974313E2A: "SEH '__try'と%select{C++ 'try'|Objective-C '@try'}0を同じ関数内で使用できません"
# 'cannot use %select{dot|arrow}0 operator on a type'
H546BD63E07E0: '型に対して%select{ドット|アロー}0演算子を使用できません'
# "cannot use %select{unicode|wide}0 string literal in 'asm'"
HD3FDC775E04A: "'asm'内で%select{Unicode|ワイド}0文字列リテラルを使用できません"
# "cannot use '%0' in %select{__device__|__global__|__host__|__host__ __device__}1 function"
H92A38A76E58C: "'%0'を%select{__device__|__global__|__host__|__host__ __device__}1関数内で使用できません"
# "cannot use '%0' output with multiple -arch options"
H1A59A50BBDD4: "'%0'出力を複数の-archオプションと共に使用できません"
# "cannot use '%0' with '__vector bool'"
HB212313EEF9A: "'%0'を'__vector bool'と共に使用できません"
# "cannot use '%0' with Objective-C exceptions disabled"
H633899DC0353: "Objective-C例外を無効にした状態で'%0'を使用できません"
# "cannot use '%0' with exceptions disabled"
H0F6B73A63960: "例外を無効にした状態で'%0'を使用できません"
# "cannot use '_Complex' with '__vector'"
HCFEB59CAC054: "'__vector'と'_Complex'を組み合わせることはできません"
# "cannot use 'float' with '__vector'"
H8772A8A87C32: "'float' と '__vector' を一緒に使用できません"
# "cannot use 'long double' with '__vector'"
HD41E42BADD92: "'long double' と '__vector' を一緒に使用できません"
# "cannot use 'long' with '__vector'"
H0DD309217BB4: "'long' と '__vector' を一緒に使用できません"
# "cannot use SEH '__try' in a coroutine when C++ exceptions are enabled"
H0484D634DF37: "C++例外が有効なコルーチン内で SEH '__try' を使用できません"
# "cannot use SEH '__try' in blocks, captured regions, or Obj-C method decls"
HAED8CA9442A3: "ブロック、キャプチャ領域、またはObj-Cメソッド宣言内で SEH '__try' を使用できません"
# 'cannot use WebAssembly table as a function parameter'
H70C162E9FD41: 'WebAssemblyテーブルを関数引数として使用できません'
# 'cannot use a WebAssembly table within a branch of a conditional expression'
H4CC748CB0567: '条件式の分岐内で WebAssemblyテーブルを使用できません'
# "cannot use a protocol declared 'objc_non_runtime_protocol' in a @protocol expression"
H22D18CFED6B9: "'objc_non_runtime_protocol' で宣言されたプロトコルを @protocol 式で使用できません"
# "cannot use an empty string literal in 'asm'"
H9269C6D18FCF: "'asm' 内で空の文字列リテラルを使用できません"
# 'cannot use dynamic_cast to convert from %0 to %1'
H5749CC5204B8: 'dynamic_cast で %0 から %1 への変換はできません'
# 'cannot use incomplete type %0 as a range'
H779605C5A805: '未完全型 %0 をレンジとして使用できません'
# 'cannot use initializer list at the beginning of a macro argument'
HFB12BDAF6D6F: 'マクロ引数の先頭で初期化リストを使用できません'
# 'cannot use type %0 as a range'
H9F644F56E9E3: '%0 型をレンジとして使用できません'
# 'cannot use type %0 as an iterator'
H45599EAAF2D8: '%0 型をイテレーターとして使用できません'
# "cannot use type '%0' within '#pragma clang fp eval_method'; type is set according to the default eval method for the translation unit"
HD91CCA267FD1: "'#pragma clang fp eval_method' 内で '%0' を使用できません; 評価メソッドのデフォルトに従います"
# 'cannot use variable %1 in collapsed imperfectly-nested loop %select{init|condition|increment}0 statement'
H40887EDB8E4A: 'ネストされていないループ %select{init|condition|increment}0 文で変数 %1 を使用できません'
# 'cannot use variable-length arrays in %select{__device__|__global__|__host__|__host__ __device__}0 functions'
H33A7639314BD: '%select{__device__|__global__|__host__|__host__ __device__}0 関数内で可変長配列を使用できません'
# "cannot write file '%0': %1"
H57D82DC5A945: "ファイル '%0' の書き込みに失敗: %1"
# 'cannot yet @encode type %0'
H5CF1C5265DEE: 'タイプ %0 の @encode はまだ対応していません'
# 'cannot yet compile %0 in this ABI'
H7B123038B924: 'このABIでは %0 のコンパイルはまだ対応していません'
# 'cannot yet mangle %0 expression'
HA255CBB16444: '%0 式のマングリングはまだ対応していません'
# 'cannot yet mangle OpenACC Asterisk Size expression'
H2D31700B7C49: 'OpenACC アスタリスクサイズ式のマングリングはまだ対応していません'
# 'cannot yet mangle expression type %0'
HF4D45A826D3A: '式タイプ %0 のマングリングはまだ対応していません'
# 'capture %0 by %select{value|reference}1'
HD0ACA3E1F2BB: '%select{値|参照}1 でキャプチャ %0'
# 'capture default must be first'
HBD6F708D5FEC: 'キャプチャのデフォルトは最初に指定する必要があります'
# 'capture host side class data member by this pointer in device or host device lambda function may result in invalid memory access if this pointer is not accessible on device side'
HA00333F0A82E: 'デバイスまたはホストデバイスラムダ関数で、ホスト側のクラスのデータメンバをthisポインタでキャプチャすると、thisポインタがデバイス側で使用できない場合に無効なメモリアクセスが発生する可能性があります'
# 'capture host variable %0 by reference in device or host device lambda function'
H4218AAE93F26: 'デバイスまたはホストデバイスラムダ関数で、ホスト変数 %0 を参照でキャプチャしています'
# "capture of '*this' by copy is a C++17 extension"
H9C3948693023: "'*this' を値でキャプチャすることはC++17の拡張機能です"
# "capture of variable '%0' as type %1 calls %select{private|protected}3 %select{default |copy |move |*ERROR* |*ERROR* |*ERROR* |}2constructor"
H6489D0544330: "型%1として'%0'をキャプチャする際に%select{private|protected}3 %select{デフォルト コンストラクタ|コピー コンストラクタ|ムーブ コンストラクタ|*ERROR* |*ERROR* |*ERROR* |}2が呼び出されました"
# 'captured structured bindings are a C++20 extension'
HED60DD4C6A62: '構造化バインディングのキャプチャはC++20の拡張機能です'
# 'captured structured bindings are incompatible with C++ standards before C++20'
HA1967A579A6F: '構造化バインディングのキャプチャはC++20未満のC++標準では互換性ありません'
# 'capturing %0 strongly in this block is likely to lead to a retain cycle'
H495EA167E92F: 'このブロックで %0 を強くキャプチャするとリテン・サイクルが発生する可能性があります'
# 'capturing a structured binding is not yet supported in OpenMP'
H3DD2898A017E: '構造化バインディングのキャプチャはOpenMPでまだ対応していません'
# 'case ranges are a C2y extension'
H022E1C3F4097: 'ケース範囲はC2y拡張機能です'
# 'case ranges are a GNU extension'
H0ADA830DF441: 'ケース範囲はGNU拡張機能です'
# 'case ranges are incompatible with C standards before C2y'
H94092A9759CB: 'C2y未満のC標準ではケース範囲は互換性ありません'
# 'case value not in enumerated type %0'
H4866E4105494: '列挙型 %0 にないケース値です'
# 'cast %diff{from $ to $ |}0,1converts to incompatible function type'
HAE54FE7B3C1C: 'キャスト %diff{を $ から $ へ |}0,1不整合な関数型への変換'
# "cast between incompatible calling conventions '%0' and '%1'; calls through this pointer may abort at runtime"
HB4A395B83746: "呼び出し規約'%0'と'%1'の間のキャストは互換性なし; このポインタを通じた呼び出しは実行時に中止する可能性があります"
# 'cast between pointer-to-function and pointer-to-object is an extension'
H276B46B48964: '関数ポインタとオブジェクトポインタの間のキャストは拡張機能です'
# 'cast between pointer-to-function and pointer-to-object is incompatible with C++98'
HD37948261117: 'C++98では関数ポインタとオブジェクトポインタの間のキャストは互換性ありません'
# 'cast expression to void to silence warning'
H1D7499C23CFE: 'voidへの型キャストでこの警告を無効にします'
# 'cast from %0 is not allowed in a constant expression %select{in C++ standards before C++2c|because the pointed object type %2 is not similar to the target type %3}1'
H542ED6DEC45B: '%select{C++2c以前のC++規格で|指標対象オブジェクト型%2がターゲット型%3と類似していないため}1定数式での%0からのキャストは許可されません'
# 'cast from %0 to %1 drops %select{const and volatile qualifiers|const qualifier|volatile qualifier}2'
HA3B03023258D: '%0から%1へのキャストで%select{constとvolatile修飾子|const修飾子|volatile修飾子}2が失われます'
# 'cast from %0 to %1 increases required alignment from %2 to %3'
H4A02BB23383F: '%0から%1へのキャストで必要アライメントが%2から%3に増加します'
# 'cast from %0 to %1 must have all intermediate pointers const qualified to be safe'
HB7DFA89AF07B: '%0から%1への安全なキャストには中間ポインタ全てがconst修飾が必要です'
# 'cast from function call of type %0 to non-matching type %1'
H8CE3B0EB72DC: '型%0の関数呼び出しを非一致型%1にキャスト'
# 'cast from pointer to smaller type %2 loses information'
H60D928000B5D: 'より小さな型%2へのポインタキャストで情報が失われます'
# 'cast of %select{Objective-C|block|C}0 pointer type %1 to %select{Objective-C|block|C}2 pointer type %3 cannot use %select{__bridge|__bridge_transfer|__bridge_retained}4'
H2F5F45B60576: '%select{Objective-C|ブロック|C}0のポインタ型%1を%select{Objective-C|ブロック|C}2のポインタ型%3にキャストするには%select{__bridge|__bridge_transfer|__bridge_retained}4を使用できません'
# 'cast of type %0 to %1 is deprecated; use sel_getName instead'
HC7428E5162D0: '型%0から%1へのキャストは非推奨; sel_getNameを使用してください'
# 'cast one or both operands to int to silence this warning'
H49949EF0EEB5: '両方のオペランドをint型にキャストしてこの警告を無効にします'
# 'cast to %1 from smaller integer type %0'
HF29EC08A2098: 'より小さな整数型%0から%1へのキャスト'
# 'cast to incomplete type %0'
HB29014F052FD: '未完成型%0へのキャスト'
# 'cast to smaller integer type %1 from %0'
H3EAB0F6AAF90: 'より小さな整数型%1から%0へのキャスト'
# 'cast to union type from type %0 not present in union'
H26129A704E2A: 'ユニオン型へのキャスト元の型%0はユニオンに存在しません'
# 'cast to union type is a GNU extension'
H07ADEAB6CDD8: 'ユニオン型へのキャストはGNU拡張です'
# 'casting from randomized structure pointer type %0 to %1'
H760D7A3D8C24: 'ランダム化された構造体ポインター型%0から%1へのキャスト'
# "casting to dereferenceable pointer removes 'noderef' attribute"
H435CE65222D6: "参照可能なポインターへのキャストで'noderef'属性が削除されます"
# 'casting to type %0 is not allowed'
H05073823504A: '%0型へのキャストは許可されていません'
# 'catch-all handler must come last'
H18423565AC35: 'catch-allハンドラは最後に配置する必要があります'
# 'category is implementing a method which will also be implemented by its primary class'
H12CCDCE8A3DF: 'このカテゴリは、プライマリクラスでも実装されるメソッドを実装しています'
# "chained comparison 'X %0 Y %1 Z' does not behave the same as a mathematical expression"
HF2403FB0CB87: "チェーン比較'X %0 Y %1 Z'は数式と動作が異なります"
# 'change layout of basic blocks in a function'
HFA932943E87E: '関数内の基本ブロックのレイアウトを変更してください'
# "change return type to 'int'"
H2DD08C8E9ADD: '戻り値型をintに変更してください'
# 'change size argument to be the size of the destination'
HC31A5632ABB1: 'サイズ引数を宛先のサイズに変更してください'
# 'change the argument to be the free space in the destination buffer minus the terminating null byte'
H66702CDAA7E2: '宛先バッファの空きスペースから終端ヌルバイトを差し引いた値に引数を変更してください'
# "change this ',' to a ';' to call %0"
H5A1EAB3B7F87: "この','を';'に変更して%0を呼び出してください"
# "change type of %0 to '%select{std::span' to preserve bounds information|std::array' to label it for hardening|std::span::iterator' to preserve bounds information}1%select{|, and change %2 to '%select{std::span|std::array|std::span::iterator}1' to propagate bounds information between them}3"
H1123F3B73559: "変数%0の型を'%select{std::span'で境界情報を保持|std::array'で保護ラベルを付与|std::span::iterator'で境界情報を保持}1%select{|、%2も'%select{std::span|std::array|std::span::iterator}1'に変更して境界情報を伝搬させる}3'に変更してください"
# "change type of %0 to '%select{std::span' to preserve bounds information|std::array' to label it for hardening|std::span::iterator' to preserve bounds information}1%select{|, and change %2 to safe types to make function %4 bounds-safe}3"
H9C76AEF6C221: "変数%0の型を'%select{std::span'で境界情報を保持|std::array'で保護ラベルを付与|std::span::iterator'で境界情報を保持}1%select{|、%2を安全な型に変更して関数%4を境界安全にする}3'に変更してください"
# 'char is signed'
H28989E053B4F: 'charは符号付きです'
# 'char is unsigned'
H2C9C5C4D7121: 'charは符号なしです'
# "character '%0' cannot be specified by a universal character name"
H9FDECB7636A6: "文字'%0'はユニバーサル文字名で指定できません"
# 'character <U+%0> not allowed %select{in|at the start of}1 an identifier'
H0604F74F1073: '<U+%0>文字は識別子%select{内|の先頭}1で使用できません'
# 'character constant too long for its type'
H99E005D8F34A: '文字定数が型の長さを超えています'
# 'character literal with user-defined suffix cannot be used here'
HB73A18549E7B: 'ユーザー定義接尾辞を伴う文字リテラルはここでは使用できません'
# 'character too large for enclosing character literal type'
HFC3FA51117BB: '包含する文字リテラルの型に収まらない文字が使用されました'
# 'characters names in Unicode escape sequences are sensitive to case and whitespaces'
H6FEF0F08A2BB: 'Unicodeエスケープシーケンス内の文字名は大文字小文字と空白に敏感です'
# 'charizing operator #@ is a Microsoft extension'
H374F252BD0E9: 'charizing演算子 #@はMicrosoftの拡張機能です'
# 'check arguments and return values at function call boundaries'
H68B4A050C0B9: '関数呼び出し境界で引数と戻り値をチェックします'
# "checker '%0' has no option called '%1'"
H473E877D384D: "'%0' チェッカーには'%1'というオプションがありません"
# "checker cannot be enabled with analyzer option '%0' == %1"
H9705343670F8: "アナライザーオプション '%0' == %1 でチェッカーを有効にできません"
# "checker plugin '%0' is not compatible with this version of the analyzer"
H6AAE762D0724: "'%0' チェッカープラグインはこのバージョンのアナライザーと互換性ありません"
# 'chosen constructor is explicit in copy-initialization'
H0B94DB59D2D8: 'コピー初期化では選択されたコンストラクタがexplicitです'
# 'circular pointer delegation detected'
H16A98512E3BA: '円形ポインタ委譲が検出されました'
# 'clang LLVM compiler'
HFB02B9C0A298: 'clang LLVM コンパイラー'
# 'clang-check options'
HEBD1BCAEB597: 'clang-check オプション'
# 'clang-diff options'
HC57563571B39: 'clang-diff オプション'
# 'clang-doc options'
H711FBA0260F1: 'clang-doc オプション'
# 'clang-extdefmapgen options'
HD98304B7C5E5: 'clang-extdefmapgen オプション'
# 'clang-move options'
H51D1273C1656: 'clang-move オプション'
# 'clang-offload-bundler options'
H2BBBC154A925: 'clang-offload-bundler オプション'
# 'clang-offload-packager options'
HBBA0DBA3D90F: 'clang-offload-packager オプション'
# 'clang-query options'
HEE4551CABF87: 'clang-query オプション'
# 'clang-rename could not find symbol %0'
H72B95322F623: 'clang-rename はシンボル %0 を見つかりませんでした'
# 'clang-rename could not find symbol (offset %0)'
H9B2484C454C5: 'clang-rename はシンボルを見つかりませんでした (オフセット %0)'
# 'clang-reorder-fields options'
HB5EDCC7DF359: 'clang-reorder-fields オプション'
# 'clang-tidy options'
H123FF2E74AC8: 'clang-tidy オプション'
# 'clangd compilation flags options'
H9BB98137F26A: 'clangd コンパイル フラグ オプション'
# 'class %0 defined without specifying a base class'
H3A2FB228D84B: 'クラス %0 は基底クラスを指定せずに定義されました'
# 'class %0 has incompatible superclasses'
HAE8DDB1E1535: 'クラス %0 には互換性のないスーパークラスがあります'
# 'class %0 previously declared with type parameters'
H5BCC48BDFD6B: 'クラス %0 は以前に型パラメータと共に宣言されています'
# "class already marked '%0'"
HCB141E8798E7: 'クラスは既に "%0" とマークされています'
# 'class extension has no primary class'
H14396A81AB6D: 'クラス拡張には主クラスがありません'
# 'class has %0 base %plural{1:class|:classes}0'
HD719F68B2E7D: 'クラスには %0 基底 %plural{1:クラス|:クラス}0 があります'
# 'class has base type %0'
H55F5972959B4: 'クラスの基底型は %0 です'
# 'class implementation is declared here'
HFDD816FBE31D: 'クラスの実装はここに宣言されています'
# 'class implementation may not have super class'
HF88305654764: 'クラスの実装にはスーパークラスを含めることはできません'
# 'class is declared here'
H1CB72009FE78: 'クラスはここに宣言されています'
# 'class is incompatible with __weak references'
H5D4A2732A59E: 'クラスは __weak リファレンスと互換性がありません'
# 'class member %0 cannot appear in capture list as it is not a variable'
HB01A6BF35CAF: 'クラスのメンバー %0 は変数ではないため、キャプチャ リストに出現できません'
# "class member already marked '%0'"
H8651C68C3085: 'クラスのメンバーは既に "%0" とマークされています'
# 'class member cannot be redeclared'
H011ED139495E: 'クラスのメンバーは再宣言できません'
# "class method %objcclass0 not found (return type defaults to 'id')"
HA1F101EC915B: 'クラス メソッド %objcclass0 が見つかりませんでした (戻り値の型は "id" に設定されます)'
# "class method %objcclass0 not found (return type defaults to 'id'); did you mean %objcclass2?"
H4EC4BD008AC8: "クラスメソッド %objcclass0 が見つかりません (戻り値の型は'id'にデフォルト); %objcclass2 を指すつもりでしたか？"
# 'class property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this category'
H70F68CFFF089: 'クラスプロパティ %0 にはメソッド %1 を定義する必要があります - @dynamic を使用するか、このカテゴリでメソッド実装を提供してください'
# 'class property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this class implementation'
HC6D0854C646B: 'クラスプロパティ %0 にはメソッド %1 を定義する必要があります - @dynamic を使用するか、このクラス実装でメソッド実装を提供してください'
# 'class template %0 was explicitly specialized here'
HAF7828F4534C: 'クラステンプレート %0 はここで明示的に特殊化されました'
# 'class template %0 was instantiated here'
H67A993394D9A: 'クラステンプレート %0 はここでインスタンチエートされました'
# 'class template argument deduction for %0 selected a deleted constructor'
H2F3153B3F0E2: 'クラステンプレート引数の推論で %0 から選択されたコンストラクタは削除されています'
# 'class template argument deduction for %0 selected an explicit %select{constructor|deduction guide}1 for copy-list-initialization'
HC409A532BB3A: 'クラステンプレート引数の推論で %0 から明示的な %select{コンストラクタ|推論ガイド}1 がコピー/リスト初期化で選択されました'
# 'class template argument deduction for alias templates is incompatible with C++ standards before C++20'
H0A109AC10809: 'クラステンプレート引数の推論はC++20以前のC++標準と互換性がありません'
# 'class template argument deduction is incompatible with C++ standards before C++17%select{|; for compatibility, use explicit type name %1}0'
HCFEDA0AEF7C1: 'クラステンプレート引数の推論はC++17以前のC++標準と互換性がありません%select{|; 互換性を確保するには明示的な型名 %1 を使用してください}0'
# 'class template partial specialization %0 cannot be redeclared'
HD6C67286FA78: 'クラステンプレートの部分特殊化 %0 は再宣言できません'
# "class with destructor marked '%select{final|sealed}0' cannot be inherited from"
H8F6FAE53F32D: "'%select{final|sealed}0' が指定されたデストラクタを持つクラスは継承できません"
# 'class with specified objc_requires_property_definitions attribute is declared here'
H42C6E2F16E82: 'objc_requires_property_definitions属性が指定されたクラスの宣言はここです'
# 'cmse is not compatible with %select{RWPI|ROPI}0'
HC391A16C0EBD: 'CMSEは%select{RWPI|ROPI}0と互換性ありません'
# "code model '%0' is not supported on this target"
HCF39144044A7: "このターゲットではコードモデル '%0' はサポートされていません"
# 'code snippets to measure'
HC114C78CBCD4: '測定するコードのスニペット'
# 'code will never be executed'
H2586D13FCD3D: 'このコードは決して実行されません'
# 'collect control flow for each function'
H88E591AFCC3E: '各関数の制御フローを収集'
# 'collection element of type %0 is not an Objective-C object'
H8FFDEDA7A274: 'コレクション要素の型 %0 はObjective-Cオブジェクトではありません'
# 'collection expression type %0 is a forward declaration'
HDDCD4086A7F8: 'コレクション式の型 %0 は前進宣言です'
# 'collection expression type %0 may not respond to %1'
H8F39224B1450: 'コレクション式の型%0は%1に対応していない可能性があります'
# 'comma expressions are not allowed as indices in matrix subscript expressions'
H3F02FDCEC720: '行列の添字式において、カンマ式は許可されていません'
# 'comma operator in operand of #if'
HDC042AF8F218: '#ifのオペランドにおけるカンマ演算子'
# 'comma separating Objective-C messaging arguments'
HAB4747C7C927: 'Objective-Cメッセージング引数を区切るカンマ'
# 'comma-separated list of OpenMP offloading triples'
HB9DA81E6157C: 'OpenMPオフローディングトリプルのカンマ区切りリスト'
# 'comma-separated list of opcodes to measure, by name'
HC296D61A5AC3: '名前で指定した計測対象のオペコードのカンマ区切りリスト'
# 'comma-separated list of target architecture features'
H115643195B7E: 'ターゲットアーキテクチャ機能のカンマ区切りリスト'
# 'command line argument'
H13C820D51A04: 'コマンドライン引数'
# 'commas at the end of enumerator lists are a C++11 extension'
H2EA69DF0ADB4: '列挙子リストの末尾のカンマはC++11の拡張機能です'
# 'commas at the end of enumerator lists are a C99-specific feature'
H1F877ED68177: '列挙子リストの末尾のカンマはC99固有の機能です'
# 'commas at the end of enumerator lists are incompatible with C++98'
H28609FC0503F: '列挙子リストの末尾のカンマはC++98と互換性がありません'
# 'comparing a pointer to a null character constant; did you mean to compare to %select{NULL|(void *)0}0?'
H5D12051B65A0: 'ヌル文字定数へのポインタと比較しています；%select{NULL|(void *)0}0と比較する意図だったのではないでしょうか？'
# 'comparing floating point with == or != is unsafe'
H1DE5EF3912E1: '浮動小数点数を==または!=で比較することは安全ではありません'
# 'comparing with this %select{specifier|format string}0'
H0EA8BCD476F7: 'この%select{specifier|format string}0と比較しています'
# "comparison against address of weak declaration '%0' can only be performed at runtime"
H3C6EE2D92685: "weak宣言'%0'のアドレスとの比較は実行時にのみ実行可能です"
# "comparison against opaque constant address '%0' can only be performed at runtime"
HAC7288F66309: "不透明定数アドレス'%0'との比較は実行時にのみ実行可能です"
# "comparison against pointer '%0' that points past the end of a complete object has unspecified value"
H3D15A3D98DF0: "完全なオブジェクトの末尾を越えたポインタ'%0'との比較は値が未定義です"
# 'comparison against pointer to weak member %q0 can only be performed at runtime'
HFCA39B812783: 'weakメンバ%q0へのポインタとの比較は実行時にのみ実行可能です'
# 'comparison between NULL and non-pointer %select{(%1 and NULL)|(NULL and %1)}0'
H20F85EBECAC2: 'NULLと非ポインタ型%select{(%1 and NULL)|(NULL and %1)}0の間の比較'
# 'comparison between pointer and integer (%0 and %1)'
H9205163E9BD4: 'ポインタと整数（%0と%1）間の比較'
# "comparison between pointers to unrelated objects '%0' and '%1' has unspecified value"
H722AC288816C: "関連しないオブジェクトのポインタ間の比較 '%0' と '%1' は未定義の値になります"
# "comparison between two arrays compare their addresses and will be deprecated in c++20; to compare array addresses, use unary '+' to decay operands to pointers"
H5D551E6212F9: "C++20で廃止予定の配列同士のアドレス比較です；アドレスを比較する場合は一項演算子'+'を使用してオペランドをポインタに分解してください"
# "comparison between two arrays is deprecated; to compare array addresses, use unary '+' to decay operands to pointers"
H4D3F55AAB37F: "配列同士の比較は廃止予定です；アドレスを比較する場合は一項演算子'+'を使用してオペランドをポインタに分解してください"
# "comparison between two arrays is ill-formed in C++26; to compare array addresses, use unary '+' to decay operands to pointers"
H20B4EE22A6C2: "C++26では配列同士の比較は不適格です；アドレスを比較する場合は一項演算子'+'を使用してオペランドをポインタに分解してください"
# "comparison of %select{address of|function|array}0 '%1' %select{not |}2equal to a null pointer is always %select{true|false}2"
H61B7557646A7: "%select{アドレスの|関数|配列}0 '%1' %select{非 |}2等価性がNULLポインタとの比較は常に%select{true|false}2となります"
# 'comparison of address of base class subobject %0 of class %1 to field %2 has unspecified value'
HCEA4BEB9DFF0: 'クラス %1 の基底クラスサブオブジェクト %0 のアドレスとフィールド %2 の比較は未定義の値になります'
# 'comparison of address of fields %0 and %2 of %4 with differing access specifiers (%1 vs %3) has unspecified value'
H30BB5DCF7738: '異なるアクセス仕様子 (%1 vs %3) を持つ %4 のフィールド %0 と %2 のアドレス比較は未定義の値になります'
# 'comparison of addresses of potentially overlapping literals has unspecified value'
H59EF9C14B9AF: '重な可能性のあるリテラルのアドレス比較は未定義の値になります'
# 'comparison of addresses of subobjects of different base classes has unspecified value'
HA10192E66EB6: '異なる基底クラスのサブオブジェクトのアドレス比較は未定義の値になります'
# 'comparison of different enumeration types in switch statement%diff{ ($ and $)|}0,1'
H820D2D4F7522: 'swith文における異なる列挙型の比較%diff{ ($ と $)|}0,1'
# 'comparison of distinct block types%diff{ ($ and $)|}0,1'
HA2CFC62DE473: '異なるブロック型の比較%diff{ ($ と $)|}0,1'
# 'comparison of distinct pointer types%diff{ ($ and $)|}0,1'
H1D24D97A54FF: '異なるポインタ型の比較%diff{ ($ と $)|}0,1'
# 'comparison of integers of different signs: %0 and %1'
H8C3AA027FA1B: '符号の異なる整数間の比較: %0 と %1'
# "comparison of nonnull %select{function call|parameter}0 '%1' %select{not |}2equal to a null pointer is '%select{true|false}2' on first encounter"
H9EDFDB49F3E3: "nonnull %select{関数呼び出し|パラメータ}0 '%1' %select{非 |}2等価性がNULLポインタとの比較は最初の判定時に'%select{true|false}2'になります"
# "comparison of numeric address '%0' with pointer '%1' can only be performed at runtime"
HFBF28443EB32: "数値アドレス '%0' とポインタ '%1' の比較はランタイムでしか実行できません"
# 'comparison of pointer to virtual member function %0 has unspecified value'
HDF5F345093AE: '仮想メンバ関数 %0 のポインタ比較は未定義の値になります'
# "comparison of pointers '%0' and '%1' to unrelated zero-sized objects"
H0C0F9C2F76E9: "関連しないゼロサイズオブジェクトのポインタ '%0' と '%1' の比較"
# 'comparison operator template cannot be defaulted'
HC75525ADCB07: '比較演算子テンプレートはデフォルト指定できません'
# "compatibility_version does not match: '%0' (provided) vs '%1' (found)"
H96AD79FF790D: "compatibility_versionが一致しません: '%0' (指定) 対 '%1' (検出)"
# 'compatible type %0 specified here'
HA0D702990A9A: '互換性のある型 %0 がここに指定されています'
# "compilation database '%0' could not be opened: %1"
H55D78247B7D8: "コンパイルデータベース '%0' を開けませんでした: %1"
# 'compile time floating point arithmetic suppressed in strict evaluation modes'
H1CBDE348A919: '厳密評価モードではコンパイル時の浮動小数点演算は抑制されます'
# 'compiler has implicitly changed method %0 return type'
HA0BE2730FEEE: 'コンパイラは暗黙にメソッド %0 の戻り値の型を変更しました'
# 'completion handler is called twice'
HA50FDB30A90B: 'コンプリーションハンドラが2回呼び出されました'
# 'completion handler is never %select{used|called}1 when %select{taking true branch|taking false branch|handling this case|none of the cases applies|entering the loop|skipping the loop|taking one of the branches}2'
HF3977C617098: 'コンプリーションハンドラは%select{真のブランチを選ぶとき|falseブランチを選ぶとき|このケースを処理するとき|どのケースにも当てはまらないとき|ループに入るとき|ループをスキップするとき|どちらかのブランチを選ぶとき}2のいずれかの場合に%select{使用されない|呼ばれない}1'
# 'complex initialization specifying real and imaginary components is an extension'
H4D2B224EF174: '実部と虚部を指定する複素数初期化は拡張機能です'
# 'complex integer types are a GNU extension'
H69724ED89FCA: '複素整数型はGNU拡張機能です'
# 'complex numbers are an extension in a freestanding C99 implementation'
HC53143A84579: 'フリースタンディングC99実装における複素数は拡張機能です'
# 'compound binary operator not supported, only +=, *=, -=, /=, &=, ^=, |=, <<=, or >>= are permitted'
H7DD0E2130464: '複合二項演算子はサポートされていません。許可されているのは +=, *=, -=, /=, &=, ^=, |=, <<=, >>= のみです'
# 'compound literal cannot be of variable-length array type'
H35B29277CD5B: '変数長配列型の複合リテラルは使用できません'
# 'compound literal in function scope may not be qualified with an address space'
H5D92A895F54C: '関数スコープ内の複合リテラルにはアドレス空間修飾子を付与できません'
# 'compound literals are a C99-specific feature'
H89109EF1C578: '複合リテラルはC99固有の機能です'
# 'concatenated NSString literal for an NSArray expression - possibly missing a comma'
H05B938722790: 'NSArray式用の連結されたNSStringリテラル - おそらくカンマが不足しています'
# 'concept cannot have associated constraints'
H2D3AA7366D73: 'コンセプトには関連する制約を指定できません'
# 'concept declarations may only appear in global or namespace scope'
HC471DCAA93F1: 'コンセプト宣言はグローバルまたはネームスペーススコープのみで使用可能です'
# 'concept named in type constraint is not a type concept'
H745ADE930837: '型制約で指定された名前は型コンセプトではありません'
# 'concept template parameter list must have at least one parameter; explicit specialization of concepts is not allowed'
HBDA562F258A9: 'コンセプトのテンプレートパラメータリストは少なくとも1つのパラメータを必要とします。コンセプトの明示的な特殊化は許可されていません'
# "condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', %select{or '>='|'>=', or '!='}0) of loop variable %1"
H8BF46A7D7B10: 'OpenMPループの条件式はループ変数 %1 の関係演算子 (<, <=, >, %select{>=, !=|!= または >=}0) でなければなりません'
# 'conditional expression is ambiguous; %diff{$ and $|types}0,1 can be converted to several common types'
H9909B5566589: '条件式は曖昧です；%diff{$ と $|型}0,1 は複数の共通型に変換可能です'
# 'conditional expression is ambiguous; %diff{$ can be converted to $ and vice versa|types can be convert to each other}0,1'
HD6EF4047D3B6: '条件式は曖昧です；%diff{$ と $ は相互変換可能|2つの型は相互に変換可能}0,1'
# "configuration file '%0' cannot be found"
HF43B1D62E529: "構成ファイル'%0'が見つかりません"
# "configuration file '%0' cannot be opened: %1"
H91238BB29F2B: "構成ファイル'%0'を開くことができません: %1"
# 'configuration macros are only allowed in top-level modules'
HC1EFBD1A6AB2: 'トップレベルのモジュール以外ではコンフィギュレーションマクロは許可されません'
# 'conflicting %0 here'
H178724C0754B: 'ここに競合する%0があります'
# 'conflicting __device__ function declared here'
H6D42767A98E2: '競合する__device__関数がここに宣言されています'
# 'conflicting address space qualifiers are provided between types %0 and %1'
HA444D7C677AE: '型%0と%1のアドレス空間修飾子が競合しています'
# 'conflicting asm label'
H08C5ACC499B8: '競合するアセンブリラベル'
# 'conflicting attribute is here'
HB210D5E7919C: '競合する属性がここにあります'
# 'conflicting attributes %0 are ignored'
H43DE73EC415F: '競合する属性%0は無視されます'
# "conflicting attributes for state '%0'"
H30B7C9BA9F57: "状態'%0'の属性が競合しています"
# 'conflicting code segment specifiers'
HF81F9823233E: '競合するコードセグメント指定子'
# 'conflicting declaration'
H9D2B5D5AA66E: '競合する宣言'
# 'conflicting deduction %diff{$ against $|types}0,1 for parameter'
H0919F4EB4F97: 'パラメータの%diff{0と1|タイプ}0,1の競合する推論があります'
# "conflicting deployment targets, both '%0' and '%1' are present in environment"
H8F50D7638091: "環境に両方'%0'と'%1'が存在するため、対応する展開ターゲットが競合しています"
# 'conflicting distributed object modifiers on parameter type in declaration of %0'
H4CB94BB5639A: '宣言の%0におけるパラメータ型の分散オブジェクト修飾子が競合しています'
# 'conflicting distributed object modifiers on parameter type in implementation of %0'
HA9E88E86F6C2: '実装の%0におけるパラメータ型の分散オブジェクト修飾子が競合しています'
# 'conflicting distributed object modifiers on return type in declaration of %0'
HBE23CBB42FFE: '宣言の%0における戻り値型の分散オブジェクト修飾子が競合しています'
# 'conflicting distributed object modifiers on return type in implementation of %0'
HBB60CEE9C2B2: '実装の%0における戻り値型の分散オブジェクト修飾子が競合しています'
# 'conflicting instance variable names: %0 vs %1'
H088E6A0E59D6: 'インスタンス変数名の競合: %0 vs %1'
# 'conflicting loop attribute %0'
H69465530AFA7: 'ループ属性%0が競合しています'
# 'conflicting nullability specifier on parameter types, %0 conflicts with existing specifier %1'
H11AC0D03E320: 'パラメータタイプのnullability指定子が衝突しています。%0 は既存の指定子 %1 と矛盾しています'
# 'conflicting nullability specifier on return types, %0 conflicts with existing specifier %1'
H9D01BC58F478: '戻り値タイプのnullability指定子が衝突しています。%0 は既存の指定子 %1 と矛盾しています'
# "conflicting option '-fcoro-aligned-allocation' and '-fno-aligned-allocation'"
HD53AB264ABE6: "オプション '-fcoro-aligned-allocation' と '-fno-aligned-allocation' が衝突しています"
# 'conflicting parameter qualifier %0 on parameter %1'
HC7B786535E39: 'パラメータ %1 のパラメータ修飾子 %0 が衝突しています'
# 'conflicting parameter types in declaration of %0%diff{: $ vs $|}1,2'
HCBD5D6ED758A: '宣言におけるパラメータ型の競合: %0%diff{: $ vs $|}1,2'
# 'conflicting parameter types in declaration of %0: %1 vs %2'
HF405BA99A067: '宣言における %0 のパラメータ型が衝突しています: %1 vs %2'
# 'conflicting parameter types in implementation of %0%diff{: $ vs $|}1,2'
H64F50A39ECB1: '実装におけるパラメータ型の競合: %0%diff{: $ vs $|}1,2'
# 'conflicting parameter types in implementation of %0: %1 vs %2'
HC0C8356B7475: '実装における %0 のパラメータ型が衝突しています: %1 vs %2'
# 'conflicting pass_object_size attributes on parameters'
H99CE421CA443: 'パラメータのpass_object_size属性が衝突しています'
# 'conflicting prototype is here'
HF896EFD79698: '衝突するプロトタイプはここです'
# "conflicting re-export of module '%0' as '%1' or '%2'"
H8B0F3A29C0A1: "モジュール '%0' を '%1' または '%2' としての再エクスポートが衝突しています"
# 'conflicting return type in declaration of %0%diff{: $ vs $|}1,2'
H2BB3153B6C50: '宣言における戻り値型の競合: %0%diff{: $ vs $|}1,2'
# 'conflicting return type in declaration of %0: %1 vs %2'
H5D783A189DCF: '宣言における %0 の戻り値型が衝突しています: %1 vs %2'
# 'conflicting return type in implementation of %0%diff{: $ vs $|}1,2'
HEB354C372ED1: '実装における戻り値型の競合: %0%diff{: $ vs $|}1,2'
# 'conflicting return type in implementation of %0: %1 vs %2'
H5C54E8625E6A: '実装における %0 の戻り値型が衝突しています: %1 vs %2'
# 'conflicting super class name %0'
HF493EF2E1E41: '基底クラス名 %0 が衝突しています'
# 'conflicting types for %0'
H5E0475C2D7BC: '%0 の型が衝突しています'
# 'conflicting types for alias %0'
HCE7DAE70AA85: 'エイリアス %0 の型が衝突しています'
# 'conflicting variadic declaration of method and its implementation'
H2A0A12EA2AF3: 'メソッドの可変長宣言とその実装が衝突しています'
# 'conformance of forward class %0 to protocol %1 cannot be confirmed'
H978A4E78BB8C: '前方クラス %0 のプロトコル %1 への適合は確認できません'
# "consecutive right angle brackets are incompatible with C++98 (use '> >')"
H77515E521F08: "C++98では連続した右角括弧が非対応です（'> >'を使用してください）"
# 'conservative handling of inline assembly'
H316430B34522: 'インラインアセンブリの保守的な処理'
# "consider adding '%0' to the header search path"
HCE15ED850DE4: "'%0'をヘッダ検索パスに追加してください"
# "consider defining %0 with the '%1' calling convention"
H6A4F6FD30F2D: "'%1'コール規約で%0を定義してください"
# 'consider making the bit-field type %select{unsigned|signed}0'
HDAE81431A685: 'ビットフィールドの型を%select{unsigned|signed}0にする'
# "consider using __builtin_trap() or qualifying pointer with 'volatile'"
H002E765592F2: "__builtin_trap()を使用するか、ポインタに'volatile'修飾を追加してください"
# 'consider using vld1_%0%1() to initialize a vector from memory, or vcreate_%0%1() to initialize from an integer constant'
H3E54619F1458: 'メモリからベクタを初期化するにはvld1_%0%1()を使用、または整数定数から初期化するにはvcreate_%0%1()を使用'
# 'consider using vld1q_%0%1() to initialize a vector from memory, or vcombine_%0%1(vcreate_%0%1(), vcreate_%0%1()) to initialize from integer constants'
H0B91FFD90BE8: 'メモリからベクタを初期化するにはvld1q_%0%1()を使用、または整数定数から初期化するにはvcombine_%0%1(vcreate_%0%1(), vcreate_%0%1())を使用'
# 'const variable cannot be emitted on device side due to dynamic initialization'
H2D4E40F2FA4A: 'ダイナミック初期化のためデバイス側でconst変数を出力できません'
# 'const-qualified list item cannot be %0'
HABDF81BBC813: 'const修飾されたリスト要素は%0できません'
# 'const-qualified variable cannot be %0'
H02E8DDC8D310: 'const修飾された変数は%0できません'
# 'const-qualified variable without mutable fields cannot be %0'
HF38DA802B6DD: 'const修飾された変数（可変フィールドなし）は%0できません'
# 'constant evaluation of %0 between arrays of types %1 and %2 is not supported; only arrays of narrow character types can be compared'
H42EAC15FC487: '配列間の型%1と%2の定数評価%0はサポートされていません。狭義文字型のみ比較可能です'
# 'constant evaluation of %0 on array of type %1 is not supported; only arrays of narrow character types can be searched'
HCF9A8296188E: '配列型%1の配列の定数評価%0はサポートされていません。狭義文字型のみ検索可能です'
# 'constant expression evaluates to %0 which cannot be narrowed to type %1'
HE08100927247: '定数評価は型%1に狭義変換できない値%0を生成しました'
# 'constant expression evaluates to %0 which cannot be narrowed to type %1 in C++11'
H3A70E9ED4BE6: '定数評価はC++11で型%1に狭義変換できない値%0を生成しました'
# 'consteval function %0 cannot override a non-consteval function'
HD9788F98961F: 'consteval関数%0は、非consteval関数をオーバーライドできません'
# 'consteval if is a C++23 extension'
H32DA4F52DDFE: 'consteval ifはC++23の拡張機能です'
# 'consteval if is always true in an %select{unevaluated|immediate}0 context'
HFA38139DBCC5: 'consteval ifは%select{未評価|即時}0コンテキストでは常にtrueです'
# 'consteval if is incompatible with C++ standards before C++23'
H3BF3B6976984: 'consteval ifはC++23以前のC++規格と互換性がありません'
# 'constexpr %select{member function|constructor}0 not allowed in %select{struct|interface|class}1 with virtual base %plural{1:class|:classes}2'
HA87030D3447E: 'constexpr %select{メンバ関数|コンストラクタ}0は、virtual基底%plural{1:クラス|:クラス}2が存在する%select{struct|interface|class}1で使用できません'
# 'constexpr bit cast involving type %0 is not yet supported'
H93DC3AD734F6: '型%0を含むconstexprビットキャストは未サポートです'
# 'constexpr bit_cast involving bit-field is not yet supported'
HCF05A23F6C40: 'ビットフィールドを含むconstexpr bit_castは未サポートです'
# 'constexpr constructor that does not initialize all members is a C++20 extension'
H6D6AAEF0CE01: 'すべてのメンバを初期化しないconstexprコンストラクタはC++20の拡張機能です'
# 'constexpr constructor that does not initialize all members is incompatible with C++ standards before C++20'
H6CD8A3688EC0: '全メンバーを初期化しないconstexprコンストラクタはC++20以前のC++規格と互換性がありません'
# 'constexpr evaluation exceeded maximum depth of %0 calls'
H71A1AF77C8D7: 'constexpr評価が%0回の最大呼び出し深さを超過しました'
# 'constexpr evaluation hit maximum call limit'
H2D336AD5FC66: 'constexpr評価が最大呼び出し回数の制限に達しました'
# 'constexpr evaluation hit maximum heap allocation limit'
HEA6F0C77C92E: 'constexpr評価が最大ヒープ割り当て制限に達しました'
# 'constexpr evaluation hit maximum step limit; possible infinite loop?'
H3A9C6A5C602B: 'constexpr評価が最大ステップ数の制限に達しました。無限ループの可能性がありますか？'
# 'constexpr function %0 without __host__ or __device__ attributes cannot overload __device__ function with the same signature; add a __host__ attribute, or build with -fno-cuda-host-device-constexpr'
HAF2225A9BAA0: 'constexpr関数%0に__host__または__device__属性がない場合、同じシグネチャの__device__関数とオーバーロードできません。__host__属性を追加するか、-fno-cuda-host-device-constexprでビルドしてください'
# 'constexpr function with no return statements is incompatible with C++ standards before C++14'
H60A27D48D081: 'return文がないconstexpr関数はC++14以前の規格と互換性ありません'
# 'constexpr if condition is not a constant expression'
H9AC357BF4F5E: 'constexpr ifの条件式は定数式ではありません'
# 'constexpr if is a C++17 extension'
H8C78EE861C25: 'constexpr ifはC++17の拡張機能です'
# 'constexpr if is incompatible with C++ standards before C++17'
H518345725A13: 'constexpr ifはC++17以前のC++規格と互換性がありません'
# 'constexpr initializer evaluates to %0 which is not exactly representable in type %1'
HFD7668DF8CE8: 'constexpr初期化子は型%1では正確に表現できない%0という値を評価しました'
# 'constexpr initializer for type %0 is of type %1'
H57EA50C1B712: '型%0のconstexpr初期化子は型%1です'
# 'constexpr on lambda expressions is incompatible with C++ standards before C++17'
H2F64715F9E19: 'lambda式のconstexprはC++17以前のC++規格と互換性がありません'
# 'constexpr pointer initializer is not null'
HA90F435C9DCD: 'constexprポインタ初期化子はnullではありません'
# 'constexpr union constructor that does not initialize any member is a C++20 extension'
HDA9656DF3125: 'メンバーを初期化しないconstexprユニオンコンストラクタはC++20拡張機能です'
# 'constexpr union constructor that does not initialize any member is incompatible with C++ standards before C++20'
H42AB5A6736FE: 'メンバーを初期化しないconstexprユニオンコンストラクタはC++20以前のC++規格と互換性がありません'
# 'constexpr variable %0 must be initialized by a constant expression'
H22D6867A6C46: 'constexpr変数%0は定数式で初期化する必要があります'
# 'constexpr variable %0 must have constant destruction'
H0CB1A9F457E9: 'constexpr変数%0は定数破棄を必要とします'
# 'constexpr variable cannot have non-literal type %0'
H8CA68B10BD1E: '非リテラル型%0を持つconstexpr変数はできません'
# 'constexpr variable cannot have type %0'
H9CBE3FDAF244: '型%0を持つconstexpr変数はできません'
# 'constexpr variable declaration must be a definition'
H28D5C206A058: 'constexpr変数宣言は定義でなければなりません'
# 'constrained by %select{|implicitly }1%select{private|protected}0 inheritance here'
HA215ECA901D4: '%select{|暗點の }1%select{private|protected}0継承ここに制約されています'
# "constrained placeholder types other than simple 'auto' on non-type template parameters not supported yet"
HA5CE432D2BF4: "'auto'以外の非型テンプレートパラメータの制約付きプレースホルダ型はまだサポートされていません"
# "constraint '%0' is already present here"
HDBC0B5C441D3: "制約'%0'はここで既に存在しています"
# 'constraint depends on a previously diagnosed expression'
HE3836E579C9B: '制約は以前に診断された式に依存しています'
# 'constraint variable %0 cannot be used in an evaluated context'
H553F40E512D9: '制約変数%0は評価されたコンテキストで使用できません'
# 'constraints not satisfied for %select{class template|function template|variable template|alias template|template template parameter|template}0 %1%2'
H81A668F064ED: '%select{クラステンプレート|関数テンプレート|変数テンプレート|エイリアステンプレート|テンプレートテンプレートパラメータ|テンプレート}0 %1%2の制約が満たされていません'
# "construct '%0' not allowed in a region associated with a directive with 'order' clause"
HC4C995E5BA30: "'order'句を伴うディレクティブに関連する領域では、構文'%0'は許可されていません"
# 'construction of individual component of complex number is not yet supported in constant expressions'
H0E4CD910394F: '定数式では複素数の個々のコンポーネントの初期化はまだサポートされていません'
# 'constructor call from initializer list is incompatible with C++98'
HB192963D1DEE: 'イニシャライザ リストからのコンストラクタ呼び出しはC++98と互換性ありません'
# "constructor cannot be declared '%0'"
HC6A3768462FF: "コンストラクタは'%0'と宣言できません"
# 'constructor cannot be redeclared'
H55F24B0BC81F: 'コンストラクタは再宣言できません'
# 'constructor cannot have a return type'
H859AAE558539: 'コンストラクタは戻り値の型を指定できません'
# 'constructor for %0 creates a delegation cycle'
H475456925F83: '%0のコンストラクタはデリゲーション サイクルを作成します'
# 'constructor from base class %0 inherited here'
H1711561364CF: 'ベースクラス%0のコンストラクタがここに継承されました'
# 'constructor inherited by %0 from base class %1 is implicitly deleted'
H97CFC0CC7D39: '%0がベースクラス%1から継承したコンストラクタは暗黙的に削除されました'
# 'constructor inherited from base class %0 cannot be used in a constant expression; derived class cannot be implicitly initialized'
HC12464115FAE: 'ベースクラス%0から継承したコンストラクタは定数式では使用できません; 派生クラスは暗黙的に初期化できません'
# 'constructor initializer %0 does not name a class'
HCFC849237163: 'コンストラクタ イニシャライザ%0はクラスを指定していません'
# 'constructor of %0 inherited from multiple base class subobjects'
HC9F4CC1EE50E: '%0のコンストラクタは複数のベース クラス サブオブジェクトから継承されました'
# 'constructor of base class %0 is not called'
H3174F7100ABA: 'ベースクラス%0のコンストラクタが呼び出されませんでした'
# 'constructor parameter %0 shadows the field %1 of %2'
H11CEF1CBDAF0: 'コンストラクタ パラメータ%0は%2のフィールド%1を隠蔽しています'
# "constructs with the same name must have a 'hint' clause with the same value"
H0760234C4455: '同じ名前の構文には、同じ値を持つ「hint」句が必要です'
# "consumed analysis attribute is attached to member of class %0 which isn't marked as consumable"
H05C072713E0E: 'クラス%0のメンバーに「consumed」分析属性が適用されていますが、このメンバーは消費可能としてマークされていません'
# 'container access result unused - container access should not be used for side effects'
H8AF2586DAD21: 'コンテナ アクセスの結果が未使用です - コンテナ アクセスは副作用のために使用しないでください'
# 'context %select{set|selector|property}0 options are: %1'
H10E910F395AC: 'コンテキスト %select{set|selector|property}0 のオプションは: %1'
# 'continue even if build-ids in input binary and perf.data mismatch'
HF64C3EBD8AC2: '入力バイナリとperf.dataのbuild-idsが一致しない場合でも継続します'
# 'control flows through the definition of a %select{static|thread_local}0 variable'
HBD024CE03438: '%select{static|thread_local}0変数の定義を制御フローが通過しています'
# 'control reached end of constexpr function'
HE6815340E241: '制御がconstexpr関数の末尾に達しました'
# 'controlling expression type %0 compatible with %1 generic association types'
HB8A1ADD97071: '制御式の型%0は%1の汎用関連型と互換性があります'
# 'controlling expression type %0 not compatible with any generic association type'
H55E9ACCD45B7: '%0 型の制御式は、どの汎用関連型とも互換性がありません'
# "convenience initializer missing a 'self' call to another initializer"
HF14170AD5005: "別のイニシャライザに対する 'self' 呼び出しを省略しています"
# "convenience initializer should not invoke an initializer on 'super'"
HA39139A75170: "'super' に対するイニシャライザの呼び出しは避けるべきです"
# 'conversion %diff{from $ to $|between types}0,1 is ambiguous'
HDD7803D6F7A1: '型%diff{から $ への|間の}0,1変換が曖昧です'
# 'conversion between fixed point and %0 is not yet supported'
HF68AF1DBEB64: '定点数と%0間の変換はまだサポートされていません'
# 'conversion between matrix type %0 and incompatible type %1 is not allowed'
H499A22E2DD8F: '行列型%0と互換性のない型%1間の変換は許可されていません'
# 'conversion between matrix types%diff{ $ and $|}0,1 of different size is not allowed'
H82DF9F4CF265: '異なるサイズの行列型%diff{ $ と $|}0,1間の変換は許可されていません'
# 'conversion candidate %0 not viable: constraints not satisfied'
H1A87D3FA633E: '変換候補%0は有効ではありません: 制約が満たされません'
# 'conversion candidate of type %0'
H1704891C4D79: '型%0の変換候補'
# 'conversion from %0 to %1 in converted constant expression would bind reference to a temporary'
H22C174FA2D9C: '%0から%1への変換が、変換定数式内で一時オブジェクトへの参照を束縛します'
# 'conversion from %0 to %1 is not allowed in a converted constant expression'
H64DA1E381CAE: '変換定数式内で%0から%1への変換は許可されていません'
# 'conversion from pointer to member of class %0 to pointer to member of class %1 via virtual base %2 is not allowed'
HC6DC2FD11DE6: '%0クラスのメンバポインタから、バーチャル基底%2を介して%1クラスのメンバポインタへの変換は許可されていません'
# 'conversion from string literal to %0 is deprecated'
H1DEAC81E3C65: '文字列リテラルから%0への変換は非推奨になりました'
# 'conversion function %diff{from $ to $|between types}0,1 invokes a deleted function%select{|: %3}2'
H302A0E48B3BA: '型%diff{から $ への|間の}0,1変換関数が削除された関数%select{|: %3}2を呼び出しています'
# 'conversion function cannot be redeclared'
HA31D9D61E048: '変換関数は再宣言できません'
# 'conversion function cannot be variadic'
H28A6D9FD4C07: '変換関数は可変長関数にできません'
# 'conversion function cannot convert to a function type'
H61F51031942B: '関数型への変換関数はできません'
# 'conversion function cannot convert to an array type'
H431E774C8920: '配列型への変換関数はできません'
# 'conversion function cannot have a return type'
H846A21D09489: '戻り値型を持つ変換関数はできません'
# 'conversion function cannot have any parameters'
H9E24A8535723: '変換関数はパラメータをもってはいけません'
# 'conversion function converting %0 to %1 will never be used'
H960F42AADA51: '%0 を %1 に変換する変換関数は決して使用されません'
# 'conversion function converting %0 to its base class %1 will never be used'
H1FE504FD028F: '%0 をその基底クラス %1 に変換する変換関数は決して使用されません'
# 'conversion function converting %0 to itself will never be used'
HC22DB2DAD0D5: '%0 を自身に変換する変換関数は決して使用されません'
# 'conversion function must be a non-static member function'
HCACC98687D9A: '変換関数は非静的メンバ関数でなければなりません'
# 'conversion to %select{integral|enumeration}0 type %1'
H52D400CB1F4D: '%select{積分型|列挙型}0 の型 %1 への変換'
# 'conversion to %select{integral|enumeration}0 type %1 declared here'
H126F1D6252B2: '%select{積分型|列挙型}0 の型 %1 への変換はここに宣言されています'
# 'conversion to pointer type %0'
H88631D898FE3: 'ポインタ型 %0 への変換'
# 'convert moves with rbp stack memory operand (unsafe, must be off for binaries compiled with -fomit-frame-pointer)'
H9F1E879B6ED5: 'rbp スタックメモリオペランドを使用したムーブ変換 (危険、-fomit-frame-pointer でコンパイルされたバイナリでは無効にしなければなりません)'
# 'convert moves with stack memory operand (potentially unsafe)'
HC5050FEB738B: 'スタックメモリオペランドを使用したムーブ変換 (潜在的に危険)'
# 'converting delete expression from type %0 to type %1 invokes an explicit conversion function'
HFA594BB552D0: '型 %0 から型 %1 への削除式の変換は明示的な変換関数を呼び出します'
# 'converting the enum constant to a boolean'
HC26D67935F61: '列挙定数をブール値に変換'
# "converting the result of '<<' to a boolean always evaluates to %select{false|true}0"
H66F90B0804A0: "'<<' の結果をブール値に変換すると常に %select{false|true}0 になります"
# "converting the result of '<<' to a boolean; did you mean '(%0) != 0'?"
HB5F0E9F35B11: "'<<' の結果をブール値に変換; '(%0) != 0' を意図したかもしれません"
# "converting the result of '?:' with integer constants to a boolean always evaluates to 'true'"
H0B52D2457927: "整数定数を使用した '?:' の結果をブール値に変換すると常に 'true' になります"
# 'converting to boxing syntax requires casting %0 to %1'
HDE90319BAAF3: 'ボクシング構文への変換には %0 を %1 にキャストする必要があります'
# 'coprocessor %0 must be configured as %select{GCP|CDE}1'
H4C456D50EC55: 'コプロセッサー %0 を %select{GCP|CDE}1 として設定する必要があります'
# 'copy %select{constructor|assignment operator}0 is implicitly deleted because %1 has a user-declared move %select{constructor|assignment operator}2'
HBE99D1D6F119: 'コピー %select{コンストラクタ|代入演算子}0 は、%1 がユーザー定義のムーブ %select{コンストラクタ|代入演算子}2 を持つため暗黙のうちに削除されます'
# 'copy constructor must pass its first argument by reference'
H3ABFF716FBF3: 'コピー コンストラクタは最初の引数を参照で渡さなければなりません'
# 'copy constructor of %0 is implicitly deleted because field %1 is of rvalue reference type %2'
H5B9C818EF5D6: '%0 のコピー コンストラクタは、フィールド %1 が右辺値参照型 %2 のため暗黙のうちに削除されます'
# 'copying a temporary object of incomplete type %0'
H4C050E15C304: '不完全型 %0 の一時オブジェクトをコピーしています'
# "coroutine %0 cannot be declared 'noreturn' as it always returns a coroutine handle"
H7F1772343EA2: "%0 コルーチンは、常にコルーチンハンドルを返すため、'noreturn' として宣言できません"
# "could not acquire lock file for module '%0': %1"
H0C3259D0CAD4: "モジュール '%0' のロックファイルを取得できませんでした: %1"
# "could not build module '%0'"
H0F4C1C79774B: "モジュール '%0' をビルドできませんでした"
# "could not calculate number of iterations calling 'operator-' with upper and lower loop bounds"
H55F92FED58CA: "'operator-' を使用して上位と下位ループ境界を呼び出した際、イテレーション数を計算できませんでした"
# 'could not determine the original source location for %0:%1:%2'
H596D1B547578: '%0:%1:%2 の元のソース位置を特定できませんでした'
# "could not find ';' after @import"
H808D2C4625A0: "';' が @import の後に見つかりませんでした"
# 'could not find Objective-C class %0 to convert %1 to %2'
H8A434A2F54F7: 'Objective-C クラス %0 を見つけることができませんでした。%1 を %2 に変換するため'
# 'could not match %diff{$ against $|types}0,1'
HB17669DA1C41: '型 %diff{$ と $|types}0,1 が一致しません'
# "could not open '%0' for embedding"
HF452E067B4E2: "埋め込みのために '%0' を開くことができませんでした"
# "could not read %0 input list '%1': %2"
H67879BBD7E88: "%0 入力リスト '%1' を読み込めませんでした: %2"
# "could not read directory '%0': %1"
HBA8BA2C7E279: "ディレクトリ '%0' を読み込めませんでした: %1"
# "could not remap file '%0' to the contents of file '%1'"
H154079BD4163: "ファイル '%0' をファイル '%1' の内容に再マップできませんでした"
# 'covariant thunk required by %0'
H96E8ACBA5464: 'covariant thunk が必要です: %0'
# "cpu '%0' does not support rv%select{32|64}1"
HB22CC79010F2: "CPU '%0' は rv%select{32|64}1 をサポートしていません"
# 'create a static PC table'
HA9821FD0C9F2: '静的 PC テーブルを作成'
# "current API version is '%0', but plugin was compiled with version '%1'"
H399ED19E4A74: "現在の API バージョンは '%0' ですが、プラグインはバージョン '%1' でコンパイルされました"
# 'current file is older than dependency %0'
HCE89B30434E7: '現在のファイルは依存関係 %0 よりも古いです'
# "current handling of vector bool and vector pixel types in this context are deprecated; the default behaviour will soon change to that implied by the '-altivec-compat=xl' option"
H2144886C992F: "このコンテキストでのベクターブールおよびベクターピクセル型の現在の処理は非推奨です。既定の動作は、'-altivec-compat=xl' オプションで示されるように近日中に変更されます"
# "current_version does not match: '%0' (provided) vs '%1' (found)"
H84F45A8B13FB: "current_version が一致しません: '%0' (提供) 対 '%1' (検出)"
# "cycle in acquired_before/after dependencies, starting with '%0'"
HCB49175AA5FC: "acquired_before/afterの依存関係でサイクルが検出されました。開始点は'%0'です"
# "cyclic dependency in module '%0': %1"
H2C783846485B: "モジュール'%0'に循環依存関係があります: %1"
# 'data argument not used by format string'
HB79E446EA7A1: 'データ引数がフォーマット文字列で使用されていません'
# "data argument position '%0' exceeds the number of data arguments (%1)"
H3A25FAA1F4B4: 'データ引数の位置"%0"がデータ引数の総数(%1)を超えています'
# 'data layout string to use'
HBFBB6DFFCFDF: '使用するデータレイアウト文字列'
# 'data member instantiated with function type %0'
HE2AF1A6B9D7C: '関数型%0で実体化されたデータメンバです'
# "data-sharing attribute '%0' in '%1' clause requires OpenMP version %2 or above"
H12FB4E840EF7: "'%1'句におけるデータ共有属性'%0'はOpenMPバージョン%2以上が必要です"
# 'dbx'
H362301DA6431: 'dbx'
# "dealloc return type must be correctly specified as 'void' under ARC, instead of %0"
HF5C8E84C253E: "ARC下ではdeallocの戻り値型は'void'として指定する必要があります。%0ではなく"
# 'debug'
H32FAAECAC742: 'デバッグ'
# "debug information option '%0' is not supported for target '%1'"
H53B68E933A49: "ターゲット'%1'ではデバッグ情報オプション'%0'がサポートされていません"
# "debug information option '%0' is not supported; requires DWARF-%2 but target '%1' only provides DWARF-%3"
HBD9D2872B134: "デバッグ情報オプション'%0'はサポートされていません。DWARF-%2が必要ですが、ターゲット'%1'ではDWARF-%3しか提供できません"
# 'debug print callable symbols defined by materialization units'
H976885EE0BAB: 'マテリアル化ユニットによって定義された呼び出し可能なシンボルをデバッグ出力'
# 'debug print data symbols defined by materialization units'
H68EF51B0D840: 'マテリアル化ユニットによって定義されたデータシンボルをデバッグ出力'
# 'debug print hidden symbols defined by materialization units'
H29FF2691850E: 'マテリアル化ユニットによって定義された隠しシンボルをデバッグ出力'
# 'debug stack'
HF8D202225993: 'デバッグ スタック'
# "declaration %0 attached to named module '%1' cannot be attached to other modules"
H238E4BEFC413: "名前付きモジュール'%1'にアタッチされている宣言%0は他のモジュールにアタッチできません"
# "declaration %0 is detected to be defined in multiple module units, first is from '%1' and second is from '%2'; the compiler may not be good at merging the definitions. "
H96F07A99E632: "宣言%0が複数のモジュールユニットで定義されていることが検出されました。最初は'%1'から、次は'%2'からです。コンパイラが定義をマージできず、問題が生じる可能性があります。"
# "declaration '%0' is %select{weak defined|thread local}1, but symbol is not in dynamic library"
HFB32CBE0F1C5: "宣言'%0'は%select{弱い定義|スレッド局所}1ですが、シンボルが動的ライブラリに含まれていません"
# "declaration '%0' is marked %select{available|unavailable}1, but symbol is %select{not |}2exported in dynamic library"
H01B92D3A7F34: "宣言 '%0' は %select{利用可能|利用不可}1 としてマークされていますが、シンボルはダイナミックライブラリで %select{エクスポートされていません|}2 エクスポートされています"
# "declaration cannot be inferred '%0' because it has no definition in this translation unit"
HFACBBC5D211B: "この翻訳単位内に定義がないため、'%0' の宣言を推論できません"
# 'declaration conflicts with target of using declaration already in scope'
HF0A04A0DD736: '宣言は既存スコープの using 宣言のターゲットと衝突しています'
# 'declaration does not declare a parameter'
HAB6C8E5E5B42: 'この宣言はパラメータを宣言していません'
# 'declaration does not declare anything'
HCF31319302C2: 'この宣言は何も宣言していません'
# "declaration has external linkage, but dynamic library doesn't have symbol '%0'"
H867521795963: "外部リンクを保持していますが、ダイナミックライブラリにシンボル '%0' がありません"
# "declaration has external linkage, but symbol has internal linkage in dynamic library '%0'"
H51741F52DD27: "外部リンクを保持していますが、ダイナミックライブラリ '%0' では内部リンクです"
# 'declaration hides type'
HBEC56FF31D60: '宣言は型を隠蔽しています'
# 'declaration in interface'
HA49C5D70160C: 'インターフェース内の宣言'
# "declaration in interface is not in the '%select{alloc|copy|init|new}0' family because %select{its result type is not an object pointer|its result type is unrelated to its receiver type}1"
H135EF0608D60: "宣言は '%select{alloc|copy|init|new}0' ファミリーに属していません。%select{戻り型がオブジェクトポインタでない|戻り型がレシーバータイプと関連していない}1 のため"
# "declaration is marked with '%select{\\|@}0deprecated' command but does not have a deprecation attribute"
H7C7F3BB153A5: "'%select{\\|@}0deprecated' コマンドでマークされていますが、非推奨属性がありません"
# 'declaration is not declared in any declare target region'
H519107FB97C7: 'この宣言はどの宣言ターゲット領域にも含まれていません'
# 'declaration marked as declare target after first use, it may lead to incorrect results'
HB5487BD38E68: '宣言ターゲットは最初の使用後に指定されたため、不正確な結果が発生する可能性があります'
# "declaration missing '[[carries_dependency]]' attribute is here"
H0D046CE0EB0D: "'[[carries_dependency]]' 属性が欠落しています → ここ"
# 'declaration of %0 does not match'
H12CB12FACAA5: '%0 の宣言が一致しません'
# 'declaration of %0 has a different language linkage'
HB8AA7E6F59F0: '%0 の宣言の言語リンクが異なります'
# 'declaration of %0 in %select{the global module|module %2}1 follows declaration in %select{the global module|module %4}3'
HCB7EF6CCFFAA: '%0 の宣言は %select{グローバルモジュール|モジュール %2}1 で、%select{グローバルモジュール|モジュール %4}3 の宣言後に出現しています'
# 'declaration of %0 is missing in %1 class'
HCE379B9B6B0B: '%1 クラス内に %0 の宣言がありません'
# "declaration of %0 overrides a '%select{final|sealed}1' function"
H49FDD9D92060: "%0 の宣言は '%select{final|sealed}1' 関数をオーバーライドしています"
# 'declaration of %0 shadows template parameter'
HB1AA8E00948E: '%0の宣言はテンプレートパラメータを覆っています'
# 'declaration of %0 will not be visible outside of this function'
H1E299D7E36E1: '%0の宣言はこの関数の外では参照できません'
# 'declaration of %0 with internal linkage cannot be exported'
HB1BC44F22B13: '内部リンケージを有する%0の宣言はエクスポートできません'
# 'declaration of %1 %select{with C language linkage|in global scope}0 conflicts with declaration %select{in global scope|with C language linkage}0'
HADF36ADC7505: '%1の%select{C言語リンケージを有する|グローバルスコープの}0宣言は、%select{グローバルスコープの|C言語リンケージを有する}0宣言と競合しています'
# "declaration of a variadic function without a comma before '...' is deprecated"
HF12988516A95: "可変長引数関数の宣言に、'...'の前のコンマがありません。これは非推奨です"
# 'declaration of anonymous %0 must be a definition'
H1EBFCC5461F9: '匿名の%0の宣言は定義でなければなりません'
# 'declaration of block scope identifier with linkage cannot have an initializer'
HDD3AC9280BE3: 'ブロックスコープの識別子（リンケージを有する）は初期化子を指定できません'
# "declaration of built-in function '%0' requires the declaration of the 'jmp_buf' type, commonly provided in the header <setjmp.h>"
H8F1CDE7D22C0: "組み込み関数'%0'の宣言には、通常<setjmp.h>ヘッダで提供される'jmp_buf'型の宣言が必要です"
# "declaration of built-in function '%1' requires inclusion of the header <%0>"
H059DBCAF4C02: "組み込み関数'%1'の宣言には、ヘッダ<%0>の包含が必要です"
# 'declaration of constexpr static data member %0 requires an initializer'
HCFAE74ED9FCD: 'constexpr静的データメンバ%0の宣言には初期化子が必要です'
# 'declaration of instance variables in the interface is deprecated'
HF2C25CBD493E: 'インターフェースでのインスタンス変数の宣言は非推奨です'
# "declaration of non-local variable in 'for' loop"
HBFAC0B86B48E: "'for'ループでの非ローカル変数の宣言"
# "declaration of non-local variable in 'for' loop is a C23 extension"
H82E18D14C9A2: "'for'ループでの非ローカル変数の宣言はC23拡張機能です"
# "declaration of non-local variable in 'for' loop is incompatible with C standards before C23"
H1C8715C3541C: "'for'ループでの非ローカル変数の宣言はC23以前の規格と互換性ありません"
# 'declaration of reference variable %0 requires an initializer'
H8635EDA9A8C6: 'リファレンス変数%0の宣言には初期化子が必要です'
# 'declaration of variable %0 with deduced type %1 requires an initializer'
H737154EADE2A: '型推論を使用した変数%0 %1の宣言には初期化子が必要です'
# 'declaration requires a global constructor'
H55DC760EFFEA: 'この宣言にはグローバルコンストラクタが必要です'
# 'declaration requires a global destructor'
H7852FAA15ED5: 'この宣言にはグローバルデストラクタが必要です'
# 'declaration requires an exit-time destructor'
H86CA276EEC00: 'この宣言には終了時デストラクタが必要です'
# 'declaration shadows a %select{local variable|variable in %2|static data member of %2|field of %2|typedef in %2|type alias in %2|structured binding}1'
H68CDFAD663DD: '宣言は%select{ローカル変数|変数%2|静的データメンバ%2|フィールド%2|typedef %2|型エイリアス%2|構造化バインディング}1を隠蔽しています'
# 'declaration uses __weak, but ARC is disabled'
H1C8188316ADE: '__weakを使用していますが、ARCが無効になっています'
# 'declaration uses __weak, which the current deployment target does not support'
HEB22F5D20508: '__weakを使用していますが、現在のデプロイメントターゲットではサポートされていません'
# 'declaration uses type that is ill-formed in ARC'
H522AD27CDFBF: 'ARCでは不適切な型を使用しています'
# 'declarator requires an identifier'
HB85D316E7D82: '宣言子は識別子が必要です'
# "declare 'static' if the %select{variable|function}0 is not intended to be used outside of this translation unit"
H5D50A42530DC: "%select{変数|関数}0のこの翻訳単位外での使用が意図されていない場合は'static'を宣言してください"
# 'declare the parameter __strong or capture a __block __strong variable to keep values alive across autorelease pools'
H9B7134A463BB: 'autoreleaseプールをまたいで値を保持するには、パラメータを__strongで宣言するか、__block __strong変数をキャプチャします'
# "declared %select{'returns_nonnull'|'nonnull'}0 here"
H9D136543BAF2: "ここで%select{'returns_nonnull'|'nonnull'}0を宣言"
# 'declared %select{in global scope|with C language linkage}0 here'
H3DB72872F2B8: 'ここで%select{グローバルスコープで|C言語リンケージで}0宣言'
# 'declared as a non-template here'
H65BA70C7322E: 'ここでテンプレートではないと宣言'
# 'declared here'
HA1E35E29C81D: 'ここで宣言されています'
# 'declared here with type %0'
H880F1F3D3828: 'ここで型%0で宣言されています'
# "declared here%select{ in module '%1'|}0"
HD4C36AE9FEF2: 'ここで宣言%select{ |モジュール"%1"で}0されています'
# 'declared with %0 attribute here'
H98D954FCA941: 'ここで%0属性で宣言'
# "declared with class '%0' here"
HA2F652501D84: 'ここでクラス"%0"で宣言'
# 'declared with index %0 here'
H29E8DAE209C5: 'ここでインデックス%0で宣言'
# 'declaring function parameter of type %0 is not allowed%select{; did you forget * ?|}1'
H45BA30613376: '型%0の関数パラメータの宣言は許可されていません%select{; *を忘れていませんか？|}1'
# 'declaring function return value of type %0 is not allowed %select{; did you forget * ?|}1'
HC0F56D942DA5: '型%0の関数戻り値の宣言は許可されていません%select{; *を忘れていませんか？|}1'
# "declaring overloaded %0 as 'static' is a C++23 extension"
H3416DF62F662: "オーバーロードされた%0を'static'として宣言はC++23の拡張機能です"
# "declaring overloaded %0 as 'static' is incompatible with C++ standards before C++23"
HE846DD4F137C: "C++23以前のC++の標準ではオーバーロードされた%0を'static'として宣言することは互換性ありません"
# 'declaring variable of type %0 is not allowed'
HCC1ADB51903E: '型%0の変数宣言は許可されていません'
# 'decode probes section from binary'
H61AE631A7106: 'バイナリからプローブセクションをデコード'
# 'decomposition declaration %0 requires an initializer'
H745CF12AB2DC: '分解宣言%0にはイニシャライザが必要です'
# 'decomposition declaration cannot be a template'
H12444CAF9EB2: '分解宣言はテンプレートになることはできません'
# "decomposition declaration cannot be declared %plural{1:'%1'|:with '%1' specifiers}0"
HEDAF4E9407D4: "分解宣言は%plural{1:'%1'|:「%1」修飾子を付けて}0宣言することはできません"
# "decomposition declaration cannot be declared with constrained 'auto'"
H33CAEB57113F: '分解宣言は制約付きの「auto」で宣言することはできません'
# 'decomposition declaration cannot be declared with parentheses'
H02314396E4F0: '分解宣言は括弧で宣言することはできません'
# "decomposition declaration cannot be declared with type %0; declared type must be 'auto' or reference to 'auto'"
H3DD0947995B7: '%0の型で分解宣言することはできません。宣言する型は「auto」または「auto」への参照でなければなりません'
# "decomposition declaration declared %plural{1:'%1'|:with '%1' specifiers}0 is a C++20 extension"
HED6397EE7170: "%plural{1:'%1'|:「%1」修飾子を付けて}0宣言された分解宣言はC++20拡張です"
# "decomposition declaration declared %plural{1:'%1'|:with '%1' specifiers}0 is incompatible with C++ standards before C++20"
H3B1B7DD7D4A6: "%plural{1:'%1'|:「%1」修飾子を付けて}0宣言された分解宣言はC++20未満のC++標準と互換性ありません"
# 'decomposition declaration must be the only declaration in its group'
H36F7861E46A5: '分解宣言はグループ内で唯一の宣言でなければなりません'
# 'decomposition declaration not permitted in this context'
HE332CBDAE8B6: 'このコンテキストでは分解宣言は許可されていません'
# 'decomposition declarations are a C++17 extension'
H41B58BACEDBD: '分解宣言はC++17拡張機能です'
# 'decomposition declarations are incompatible with C++ standards before C++17'
H6F6939D7899C: '分解宣言はC++17未満のC++標準と互換性ありません'
# 'deduced conflicting types %diff{($ vs $) |}0,1for initializer list element type'
H41EB8FB5647B: 'イニシャライザリスト要素型の推論された衝突する型%diff{($ vs $)|}0,1'
# 'deduced incomplete pack %0 for template parameter %1'
H03080CBC4C1A: 'テンプレートパラメータ%1のための未完了なパック%0が推論されました'
# 'deduced non-type template argument does not have the same type as the corresponding template parameter%diff{ ($ vs $)|}0,1'
H6489085BE16C: '非型テンプレート引数の推論された型は、対応するテンプレートパラメータ%diff{ ($ vs $)|}0,1と同一ではありません'
# "deduced return type for defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator must be 'auto', not %1"
H209B0E7EFC40: 'デフォルト化された%select{<ERROR>|equality|three-way|equality|relational}0比較演算子の推論された戻り値型は%1ではなく「auto」でなければなりません'
# 'deduced return types are a C++14 extension'
HB07F9BCAC63A: '推論された戻り値型はC++14拡張機能です'
# 'deduced type %0 does not satisfy %1'
H9431BF910A33: '推論された型%0は%1を満たしません'
# 'deduced type %1 of deduction guide is not %select{|written as }2a specialization of template %0'
H902D2FE80122: 'deduction guideの推論された型%1は、テンプレート%0の特殊化%select{|として書かれていません}2'
# 'deduction guide cannot be %select{explicitly instantiated|explicitly specialized}0'
HA3A632F69A86: 'deduction guideは%select{明示的にインスタンス化することはできません|明示的に特殊化することはできません}0'
# "deduction guide cannot be declared '%0'"
HF6365CFA8B89: "deduction guideは'%0'として宣言できません"
# 'deduction guide cannot have a function definition'
H7D3F7544A5EA: 'deduction guideには関数定義を含めることはできません'
# 'deduction guide declaration without trailing return type'
H4EE056EE4349: '後方戻り値型のない deduction guide宣言'
# 'deduction guide declared %0 by intervening access specifier'
HBCF8F59E9812: '中間のアクセス指定子%0によって宣言された deduction guide'
# 'deduction guide has different access from the corresponding member template'
H1030B70A50CA: 'deduction guideは対応するメンバー・テンプレートと異なるアクセス権を持っています'
# 'deduction guide must be declared in the same scope as template %q0'
H1F6362B2A695: 'deduction guideはテンプレート%q0と同じスコープ内で宣言する必要があります'
# 'deduction guide template contains %select{a template parameter|template parameters}0 that cannot be deduced'
H9078590D8224: 'deduction guideテンプレートには%select{推論できないテンプレートパラメータ|推論できないテンプレートパラメータ}0が含まれています'
# 'default %select{argument|non-type template argument}0 may not use a GNU statement expression'
HB2A0E2C3CEAE: 'デフォルトの%select{引数|非型テンプレート引数}0ではGNUステートメント式を使用できません'
# 'default alignment for functions'
HDB8C50704025: '関数のデフォルトアラインメント'
# 'default argument declared here'
HDD61CA193DBE: 'ここにデフォルト引数が宣言されています'
# 'default argument not permitted on an explicit %select{instantiation|specialization}0 of function %1'
HA5116018194A: '関数%1の明示的な%select{インスタンス化|特殊化}0ではデフォルト引数を許可しません'
# "default argument references 'this'"
H743C3B172B68: "デフォルト引数が'this'を参照しています"
# 'default argument references local variable %0 of enclosing function'
HAA8CD5949FC3: 'デフォルト引数が包含関数のローカル変数%0を参照しています'
# 'default argument references parameter %0'
H573EB7C93602: 'デフォルト引数がパラメータ%0を参照しています'
# 'default argument used here'
H2C2A14271D90: 'デフォルト引数がここに使用されています'
# 'default arguments can only be specified for parameters in a function declaration'
H910FAD8C4EA4: 'デフォルト引数は関数宣言のパラメータに対してのみ指定できます'
# 'default arguments cannot be added to a function template that has already been declared'
H2AD8ADEE046B: 'すでに宣言されている関数テンプレートにはデフォルト引数を追加できません'
# 'default arguments cannot be added to an out-of-line definition of a member of a %select{class template|class template partial specialization|nested class in a template}0'
H2A1897D12086: '%select{クラステンプレート|クラステンプレートの部分特殊化|テンプレート内のネストされたクラス}0のメンバーの外部定義にはデフォルト引数を追加できません'
# 'default arguments not allowed for parameters of a requires expression'
H8AAADF6A99AF: 'requires式のパラメータにはデフォルト引数を指定できません'
# 'default assign attribute on property %0 which implements NSCopying protocol is not appropriate with -fobjc-gc[-only]'
H8248EDB07821: 'NSCopyingプロトコルを実装するプロパティ%0にデフォルトのassign属性は、-fobjc-gc[-only]では適切ではありません'
# 'default capture by %select{value|reference}0'
H472BB89BA278: 'デフォルトのキャプチャ方式は%select{値|参照}0'
# 'default constructed field %0 declared here'
H948E9DA6EBAF: 'ここで宣言されたデフォルト構築されたフィールド%0'
# 'default exception handling model'
H9659057B9931: 'デフォルトの例外処理モデル'
# 'default initialization of an object of const type %0%select{| without a user-provided default constructor}1'
H303212CBDF84: 'const型%0のオブジェクトのデフォルト初期化%select{|ユーザー提供のデフォルトコンストラクタなしで}1'
# 'default initialization of an object of const type %0%select{| without a user-provided default constructor}1 is a Microsoft extension'
H48E5A1B64C89: 'const型%0のオブジェクトのデフォルト初期化%select{|ユーザー提供のデフォルトコンストラクタなしで}1はMicrosoft拡張機能です'
# 'default label in switch which covers all enumeration values'
HF1A67825B6F5: 'すべての列挙値をカバーするswitch内のデフォルトラベル'
# 'default member initializer declared here'
H09B30FC3540B: 'ここで宣言されたデフォルトメンバー初期化子'
# 'default member initializer for %0 uses itself'
H62A9561A4498: '%0のデフォルトメンバー初期化子は自身を使用しています'
# 'default member initializer for %1 needed within definition of enclosing class %0 outside of member functions'
HB4FBDC93A96D: '外側のクラス%0の定義内でメンバー関数の外で、%1のデフォルトメンバー初期化子が必要です'
# 'default member initializer for bit-field is a C++20 extension'
H960B2B591D79: 'ビットフィールドのデフォルトメンバー初期化子はC++20拡張機能です'
# 'default member initializer for bit-field is incompatible with C++ standards before C++20'
H85717DD87366: 'ビットフィールドのデフォルトメンバー初期化子はC++20以前の標準では非互換です'
# 'default member initializer for non-static data member is a C++11 extension'
HB1974A6508C8: '非静的データメンバーのデフォルトメンバー初期化子はC++11拡張機能です'
# 'default member initializer for non-static data members is incompatible with C++98'
H75DECF5B5D30: '非静的データメンバーのデフォルトメンバー初期化子はC++98では非互換です'
# "default property attribute 'assign' not appropriate for object"
HBAC11B3F8368: "オブジェクトに対してデフォルトのプロパティ属性'assign'は適切ではありません"
# 'default scope specifier for attributes is a C++17 extension'
H9959B28B39FE: '属性のデフォルトスコープ指定子はC++17拡張機能です'
# 'default scope specifier for attributes is incompatible with C++ standards before C++17'
HCB10ABA8102F: '属性のデフォルトスコープ指定子はC++17以前の標準では非互換です'
# 'default template argument for a template template parameter must be a class template'
H3FA43EDB90ED: 'テンプレートテンプレートパラメータのデフォルトテンプレート引数はクラステンプレートでなければなりません'
# 'default template argument in a class template partial specialization'
H57E58A1F67E6: 'クラステンプレートの部分特別化におけるデフォルトテンプレート引数'
# 'default template argument not permitted on a friend template'
H1B3D975772BB: 'デフォルトのテンプレート引数はフレンドテンプレートでは許可されていません'
# 'default template arguments for a function template are a C++11 extension'
H94B1EDF48980: '関数テンプレートのデフォルトテンプレート引数はC++11拡張機能です'
# 'default template arguments for a function template are incompatible with C++98'
H688888558286: '関数テンプレートのデフォルトテンプレート引数はC++98と互換性がありません'
# 'defaulted %0 is implicitly deleted because %2 is a %select{union-like class|union}1 with variant members'
HAADBD633A7F2: 'デフォルト化された%0は、%2が変異メンバーを持つ%select{ユニオンのようなクラス|ユニオン}1であるため、暗黙に削除されます'
# 'defaulted %0 is implicitly deleted because a builtin comparison function using this conversion would be the best match for the comparison'
H6F959181B71C: 'デフォルト化された%0は、この変換を使用する組み込み比較関数が比較の最良の一致となるため、暗黙に削除されます'
# 'defaulted %0 is implicitly deleted because class %1 has a reference member'
HDDAEEF62F6DD: 'デフォルト化された%0は、クラス%1にリファレンスメンバがあるため、暗黙に削除されます'
# "defaulted %0 is implicitly deleted because implied %select{|'==' |'<' }1comparison %select{|for member %3 |for base class %3 }2is ambiguous"
H8204A4BEFE67: 'デフォルト化された%0は、%select{|メンバー%3 |基底クラス%3 }2のための%select{ |"==" |"<" }1比較が曖昧であるため、暗黙に削除されます'
# 'defaulted %0 is implicitly deleted because it would invoke a %select{private|protected}3 %4%select{ member of %6| member of %6 to compare member %2| to compare base class %2}1'
HA2763C071EBA: 'デフォルト化された%0は、%select{private|protected}3 %4%select{ %6のメンバー| %6のメンバー%2を比較するために| 基底クラス%2を比較するために}1が呼び出されるため、暗黙に削除されます'
# 'defaulted %0 is implicitly deleted because it would invoke a deleted comparison function%select{| for member %2| for base class %2}1'
H73AE2279ECF2: 'デフォルト化された%0は、%select{|メンバー%2|基底クラス%2}1の削除された比較関数を呼び出すため、暗黙に削除されます'
# "defaulted %0 is implicitly deleted because there is no viable %select{three-way comparison function|'operator=='}1 for %select{|member |base class }2%3"
HC9957DD8DD53: 'デフォルト化された%0は、%select{three-way comparison function|"operator=="}1が%select{|メンバー |基底クラス }2%3に対して存在しないため、暗黙に削除されます'
# 'defaulted %0 is implicitly deleted because this non-rewritten comparison function would be the best match for the comparison'
H5A66B2776E93: 'デフォルト化された%0は、この再書式化されていない比較関数が比較の最良の一致となるため、暗黙に削除されます'
# 'defaulted comparison function must not be volatile'
H50500CCE550F: 'デフォルト化された比較関数はvolatileを宣言してはなりません'
# 'defaulted comparison operators are a C++20 extension'
H17EA10D2ACC2: 'デフォルト化された比較演算子はC++20拡張機能です'
# 'defaulted comparison operators are incompatible with C++ standards before C++20'
H38C2AF56B86F: 'デフォルト化された比較演算子はC++20以前のC++標準と互換性がありません'
# "defaulted definition of %select{%select{<ERROR>|equality|three-way|equality|relational}1 comparison operator|three-way comparison operator}0 cannot be declared %select{constexpr|consteval}2 because %select{it|for which the corresponding implicit 'operator==' }0 invokes a non-constexpr comparison function"
HDA596C603C53: "デフォルト定義の%select{%select{<ERROR>|等価|三項|等価|関係}1比較演算子|三項比較演算子}0を%select{constexpr|consteval}2として宣言できません。%select{その定義|対応する暗黙の'operator=='}0が非constexpr比較関数を呼び出すためです"
# 'defaulted definition of %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 cannot be marked %select{constexpr|consteval}1 before C++23'
H5C1B0C179374: '%select{デフォルトコンストラクタ|コピーコンストラクタ|ムーブコンストラクタ|コピー代入演算子|ムーブ代入演算子|デストラクタ}0のデフォルト化された定義は、C++23以前では%select{constexpr|consteval}1を指定できません'
# 'defaulted member %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator must be const-qualified'
H8A22F945F946: 'デフォルト化された%select{<ERROR>|等価性|three-way|等価性|関係}0比較演算子はconst修飾されなければなりません'
# 'defaulted move assignment operator of %0 will move assign virtual base class %1 multiple times'
HC302B71D801C: '%0のデフォルト化されたムーブ代入演算子は、虚基底クラス%1を複数回ムーブ代入します'
# "defaulting %select{this %select{<ERROR>|equality|three-way|equality|relational}1 comparison operator|the corresponding implicit 'operator==' for this defaulted 'operator<=>'}0 would delete it after its first declaration"
HCBD1D13B7A08: "この%select{デフォルト化された%select{<ERROR>|等価|三項|等価|関係}1比較演算子|対応する暗黙の'operator=='のこのデフォルト化された'operator<=>' }0のデフォルト化は、最初の宣言後に削除されます"
# 'defaulting this %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator is not allowed because it was already declared outside the class'
H21E3B4CFF46D: 'この%select{<ERROR>|等価性|three-way|等価性|関係}0比較演算子のデフォルト化は、クラス外で既に宣言されているため許可されていません'
# 'defaulting this %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 would delete it after its first declaration'
H7E7544692CE2: 'この%select{デフォルトコンストラクタ|コピーコンストラクタ|ムーブコンストラクタ|コピー代入演算子|ムーブ代入演算子|デストラクタ}0のデフォルト化は、最初の宣言後に削除されます'
# 'defined as %0'
H95D82B9347CA: '%0として定義されています'
# "defining a type within '%select{__builtin_offsetof|offsetof}0' is a C23 extension"
HB6CCA72E4AE1: "'%select{__builtin_offsetof|offsetof}0'内の型定義はC23拡張機能です"
# 'definition %0 cannot also be an %select{alias|ifunc}1'
HEAC49AC815B1: '%0の定義は%select{エイリアス|IFn}1としても定義できません'
# 'definition has no member %0'
HF2870D3EBBD2: '定義にメンバー%0はありません'
# "definition in module '%0' is here"
HD03996A6AE5C: "モジュール'%0'の定義はここにあります"
# "definition of %0 is not complete until the closing '}'"
H6A431AA48FA1: "クラス%0の定義は閉じカッコ'}'まで完成しません"
# 'definition of a %select{static|thread_local}1 variable in a constexpr %select{function|constructor}0 is a C++23 extension'
H398F375C6A6A: 'constexpr %select{関数|コンストラクタ}0 内の %select{static|thread_local}1 変数の定義は C++23 の拡張機能です'
# 'definition of a %select{static|thread_local}1 variable in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++23'
HE9C5585842AA: 'constexpr %select{関数|コンストラクタ}0 内の %select{static|thread_local}1 変数の定義は C++23 以前の標準では互換性ありません'
# 'definition of a variable of non-literal type in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++23'
H53017D331C6A: 'constexpr %select{関数|コンストラクタ}0内の非リテラル型の変数の定義はC++23以前の標準と互換性ありません'
# 'definition of builtin function %0'
HC9CC697C220C: '組み込み関数%0の定義'
# 'definition of class %0 must be available to use Objective-C %select{array literals|dictionary literals|numeric literals|boxed expressions|string literals}1'
H852A8FF09E04: 'Objective-C %select{配列リテラル|辞書リテラル|数値リテラル|ボックス化式|文字列リテラル}1を使うにはクラス%0の定義が必要です'
# 'definition of dllimport data'
HBDC4BCE4EB33: 'dllimportデータの定義'
# 'definition of dllimport static field'
H64DF6CE31868: 'dllimport静的フィールドの定義'
# 'definition of dllimport static field not allowed'
H8C1897964645: 'dllimport静的フィールドの定義は許可されません'
# 'definition of explicitly defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|function}0'
H1522F98BEB4D: '明示的にデフォルト化された%select{デフォルトコンストラクタ|コピーコンストラクタ|ムーブコンストラクタ|コピー代入演算子|ムーブ代入演算子|デストラクタ|関数}0の定義'
# 'definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-declared copy %select{assignment operator|constructor}1'
H069CBC304A15: '%0のための暗黙のコピー%select{コンストラクタ|代入演算子}1の定義は、ユーザーが宣言したコピー%select{代入演算子|コンストラクタ}1があるため非推奨です'
# 'definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-declared destructor'
H423281D39FA7: '%0のための暗黙のコピー%select{コンストラクタ|代入演算子}1の定義は、ユーザーが宣言したデストラクタがあるため非推奨です'
# 'definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-provided copy %select{assignment operator|constructor}1'
H3C23BCA5B3D2: '%0 に対する暗黙のコピー %select{コンストラクタ|代入演算子}1 の定義は、ユーザー提供のコピー %select{代入演算子|コンストラクタ}1 の存在により非推奨です'
# 'definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-provided destructor'
H396EB4CE9202: '%0 に対する暗黙のコピー %select{コンストラクタ|代入演算子}1 の定義は、ユーザー提供のデストラクタの存在により非推奨です'
# 'definition of implicitly declared %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|function}1'
H86596A04E020: '暗黙に宣言された %select{デフォルトコンストラクタ|コピーコンストラクタ|ムーブコンストラクタ|コピー代入演算子|ムーブ代入演算子|デストラクタ|関数}1 の定義'
# 'definition of macro %0 does not match definition in precompiled header'
H79B9B4BA8FFF: 'マクロ %0 の定義はプリコンパイル済みヘッダーと一致しません'
# "definition of macro '%0' differs between the AST file '%3' ('%1') and the command line ('%2')"
H40BB23B29C3F: "マクロ '%0' の定義はASTファイル '%3' ('%1') とコマンドライン ('%2') で異なっています"
# "definition of module '%0' is not available; use -fmodule-file= to specify path to precompiled module interface"
H1ED33479DE5D: "モジュール '%0' の定義は利用できません。-fmodule-file= を使ってプリコンパイル済みモジュールインターフェースのパスを指定してください"
# 'definition of type %0 conflicts with %select{typedef|type alias}1 of the same name'
H5C3C4CCA94AB: '型 %0 の定義は同じ名前の %select{typedef|型エイリアス}1 と競合しています'
# 'definition of variable with array type needs an explicit size or an initializer'
H79E09A4784DB: '配列型の変数の定義には、明示的なサイズまたは初期化子が必要です'
# 'definition or redeclaration of %0 cannot name the global scope'
H3AC58FC9EA5A: 'グローバルスコープを名付ける %0 の定義または再宣言はできません'
# 'definition or redeclaration of %0 not allowed inside a block'
HD4328CF55600: 'ブロック内での %0 の定義または再宣言は許可されていません'
# 'definition or redeclaration of %0 not allowed inside a function'
H26DE3CAC54F0: '関数内での %0 の定義または再宣言は許可されていません'
# "definition with same mangled name '%0' as another definition"
H9CD626C8B999: "同じマングル名 '%0' を持つ別の定義と競合しています"
# 'defsym must be of the form: sym=value: %0'
H633B95A139C3: 'defsym は sym=value: %0 の形式でなければなりません'
# 'delegating constructors are incompatible with C++98'
H57A554A5A2B8: 'デリゲートコンストラクタはC++98と互換性ありません'
# 'delegating constructors are permitted only in C++11'
H859BD39058E0: 'デリゲートコンストラクタはC++11以降でのみ許可されます'
# 'delete of object with dynamic type %1 through pointer to base class type %0 with non-virtual destructor'
H2817C3914B5E: '非仮想デストラクタを持つ基底クラス型 %0 のポインタを介して動的型 %1 のオブジェクトを削除しました'
# "delete of pointer '%0' that does not point to a heap-allocated object"
H8B4F3ED0F000: 'ヒープ割り当てされていないオブジェクトを指すポインタ "%0" の削除'
# 'delete of pointer that has already been deleted'
H42BC8DFBCECC: '既に削除されたポインタを削除しました'
# "delete of pointer%select{ to subobject|}1 '%0' %select{|that does not point to complete object}1"
H4DFF941C0746: "サブオブジェクト%select{への| }1ポインタ'%0' %select{|が完全オブジェクトを指していない}1の削除"
# 'deleted definition must be first declaration'
H0F602982588E: '削除された定義は最初の宣言でなければなりません'
# 'deleted function %0 cannot override a non-deleted function'
H3FCDC44C217B: '削除された関数%0は非削除関数をオーバーライドできません'
# 'deleting incomplete class type %0; no conversions to pointer type'
H9074591E0AF3: '未完全なクラス型%0の削除; ポインタ型への変換はありません'
# 'deleting pointer to incomplete type %0 is incompatible with C++2c and may cause undefined behavior'
H0FC4BDC8CA1F: '未完全な型%0へのポインタの削除はC++2cと互換性なく、未定義な動作を引き起こす可能性があります'
# 'delimited escape sequence cannot be empty'
H5E38AA141B13: '区切られたエスケープシーケンスは空にできません'
# 'delimited escape sequences are incompatible with C standards before C2y'
H21BCF42E1D91: 'C2yより前のC規格とは区切られたエスケープシーケンスが互換性ありません'
# 'delinearize'
HB90F234569ED: '線形化解除'
# 'demangle symbols (default)'
H49846FF32EAF: 'シンボルのデマングル（デフォルト）'
# 'denormals are flushed to positive zero'
H38FDA7EF72DB: 'デノーマル値は正のゼロにフラッシュされます'
# 'denormals have unknown treatment'
HBDD387FC03A4: 'デノーマル値の扱いが不明です'
# 'dense YAML representation'
HA97D8413D319: '密なYAML表現'
# "depend modifier cannot be used with 'sink' or 'source' depend type"
H92A125FCC1F2: "'sink'または'source'依存型と共にdepend修飾子を使用できません"
# 'dependent %select{__if_not_exists|__if_exists}0 declarations are ignored'
H7E0205C30EB0: '依存%select{__if_not_exists|__if_exists}0宣言は無視されます'
# 'dependent nested name specifier %0 for friend class declaration is not supported; turning off access control for %1'
H6C7EBDCCA541: 'friendクラス宣言の依存ネスト名指定子%0はサポートされていません; %1のアクセス制御を無効にします'
# 'dependent nested name specifier %0 for friend template declaration is not supported; ignoring this friend declaration'
H5BCC077F4A6E: 'friendテンプレート宣言の依存ネスト名指定子%0はサポートされていません; このfriend宣言を無視します'
# "dependent using declaration resolved to type without 'typename'"
H9473A34B51B9: "dependent using宣言が'typename'なしで解決されました"
# 'dereference of pointer to incomplete type %0'
H2DF43C211998: '未完全な型%0へのポインタのデリファレンス'
# 'dereference of type %1 that was reinterpret_cast from type %0 has undefined behavior'
H90FCF362143A: '型%0からreinterpret_castされた型%1のデリファレンスは未定義動作を引き起こします'
# 'dereferenced pointer past the end of %select{|subobject of }0%select{temporary|%2}1 is not a constant expression'
H22AD60D3A378: 'デリファレンスされたポインタが%select{|サブオブジェクトの}0%select{一時|%2}1の末尾を越えており、定数式ではありません'
# "dereferencing %0; was declared with a 'noderef' type"
H77B30DE9BC36: "%0 のデリファレンス; 'noderef' 型で宣言されています"
# 'dereferencing a __weak pointer is not allowed due to possible null value caused by race condition, assign it to strong variable first'
H69A87CE8BA55: '競合条件により NULL 値が発生する可能性があるため、__weak ポインタのデリファレンスは許可されていません。まず strong 変数に代入してください'
# "dereferencing expression marked as 'noderef'"
HB6D67B14D60F: "'noderef' としてマークされた式をデリファレンスしています"
# 'derived class must specify the same code segment as its base classes'
HF7C9EF85294D: '派生クラスは基底クラスと同じコードセグメントを指定する必要があります'
# 'descending'
H486093918FF3: '降順'
# 'designated initializer invoked a non-designated initializer'
H504DCC34F2E8: '指定子初期化子が非指定子初期化子を呼び出しました'
# "designated initializer missing a 'super' call to a designated initializer of the super class"
H94AB45A96460: "スーパークラスの指定子初期化子に対する 'super' 呼び出しが指定子初期化子でありません"
# "designated initializer should only invoke a designated initializer on 'super'"
H2306DCB92F88: "指定子初期化子は 'super' に対して指定子初期化子のみを呼び出す必要があります"
# 'designated initializers are a C++20 extension'
H868FB6A7DCFA: '指定子初期化子は C++20 の拡張機能です'
# 'designated initializers are a C99 feature'
HCE690B2EFB92: '指定子初期化子は C99 の機能です'
# 'designated initializers are incompatible with C++ standards before C++20'
HB212F1F17A19: '指定子初期化子は C++20 以前の C++ 標準と互換性がありません'
# 'designator in initializer for %select{scalar|indivisible sizeless}0 type %1'
HDC0C952FB90A: '%select{スカラ型|分割不可能なサイズレス型}0 の %1 型に対する指定子の初期化子'
# 'designator into flexible array member subobject'
H596716C96072: '柔軟な配列メンバー サブオブジェクトに対する指定子初期化子'
# "destroying object '%0' whose lifetime has already ended"
H480FFC7A6CDF: "既に終了したライフタイムを持つオブジェクト '%0' を破棄しています"
# 'destroying operator delete can have only an optional size and optional alignment parameter'
H05866AB32F25: '破棄用オペレーター delete はオプションのサイズとオプションのアライメント パラメータのみをもてます'
# 'destruction of individual component of complex number is not yet supported in constant expressions'
H6533BAA0653D: '定数式内で複素数の個々のコンポーネントの破棄は未対応です'
# 'destruction of object that is already being destroyed'
HBC86CD58BD53: '既に破棄中のオブジェクトを破棄しています'
# 'destructor cannot be declared %select{<ERROR>|constexpr|consteval|constinit}0'
H39B25D41B01F: 'デストラクタは %select{<ERROR>|constexpr|consteval|constinit}0 として宣言することはできません'
# 'destructor cannot be declared %select{<ERROR>|constexpr|consteval|constinit}0 because %select{data member %2|base class %3}1 does not have a constexpr destructor'
HEA62090F1654: 'デストラクタは %select{<ERROR>|constexpr|consteval|constinit}0 として宣言することはできません。%select{データメンバ %2|基底クラス %3}1 が constexpr デストラクタを持っていないため'
# "destructor cannot be declared '%0'"
H18788E54B072: "デストラクタは '%0' として宣言することはできません"
# 'destructor cannot be declared as a template'
H2A9016676C0B: 'デストラクタはテンプレートとして宣言できません'
# 'destructor cannot be declared using a %select{typedef|type alias}1 %0 of the class name'
HD2E86EDB043A: 'デストラクタは、クラス名の%select{typedef|type alias}1%0を使用して宣言できません'
# 'destructor cannot be redeclared'
H7C102E557BD9: 'デストラクタは再宣言できません'
# 'destructor cannot be variadic'
H3060C3D6CE56: 'デストラクタは可変長引数を持つことはできません'
# 'destructor cannot have a return type'
HB61BE667BB0D: 'デストラクタは戻り値の型を指定できません'
# 'destructor cannot have any parameters'
H27289F072FC5: 'デストラクタは引数をとれません'
# 'destructor for %0 is not trivial because it is virtual'
H695A7FB4C51A: 'クラス%0のデストラクタはバーチャルであるため、単純ではありません'
# 'destructor must be a non-static member function'
HE5AA51DEFC74: 'デストラクタは非静的メンバ関数でなければなりません'
# 'destructor name %0 does not refer to a template'
H6A0A4776F7D0: 'デストラクタ名%0はテンプレートを指しません'
# 'destructor of class %0 is ambiguous'
H29DC1463BFE1: 'クラス%0のデストラクタは曖昧です'
# 'destructor type %0 in object destruction expression does not match the type %1 of the object being destroyed'
HCA02CE698CF6: 'デストラクタの型%0は、破棄対象のオブジェクトの型%1と一致しません'
# 'detect use after scope within function'
H76CE675503B0: '関数内のスコープ外での使用を検出'
# 'detected while default synthesizing properties in class implementation'
HDACD480D581B: 'クラス実装のプロパティのデフォルト合成時に検出'
# 'determine if lfence instruction should exist in the retpoline'
HC723EAB1C806: 'lfence命令がretpolineに存在するかどうかを決定します'
# 'determine the availability of r11 before indirect branches'
H095D2FB8BA79: '間接分岐の前にr11の可用性を決定します'
# 'determines whether to demangle function name when symbolizing function ids from the input log'
H55938C1F7AEA: '入力ログから関数IDをシンボル化する際に、関数名をデマングルするかどうかを決定します'
# 'determines whether to sort input log records by timestamp'
HF854EBCB0FF7: '入力ログレコードをタイムスタンプでソートするかどうかを決定します'
# "device clause with ancestor device-modifier used without specifying 'requires reverse_offload'"
H7C03F0398F87: 'ancestor device-modifierを使用したdevice句で、requires reverse_offloadが指定されていません'
# 'diagnostic formatting in SARIF mode is currently unstable'
HADEECC0D1814: 'SARIFモードでの診断フォーマットは現在不安定です'
# 'diagnostic msg: %0'
H1318B5E4A90B: '診断メッセージ: %0'
# 'diagtool find-diagnostic-id options'
H0E16FA84CCEE: 'diagtool find-diagnostic-id オプション'
# "did not expect %0 '%2' to be managed by '%1'"
H41E6876DEC05: "'%1'によって管理されるものとして'%2'という%0は想定されていませんでした"
# "did not find header '%0' in framework '%1' (loaded from '%2')"
H33EA4C9E31A5: "フレームワーク'%1'の'%0'というヘッダファイルが見つかりませんでした（'%2'から読み込まれました）"
# "did you forget ';'?"
H5762CA5BE293: ';を忘れていませんか？'
# "did you intend to use '#pragma pack (pop)' instead of '#pragma pack()'?"
H38F2C3CF1911: "'#pragma pack()'ではなく'#pragma pack (pop)'を使用する意図でしたか？"
# "did you mean %0 ('%2' U+%1)?"
H034E19BAF4DB: "%0を意味していましたか（'%2' U+%1）？"
# 'did you mean %0?'
H0AFE75F407BD: '%0を意味していましたか？'
# 'did you mean %select{struct|interface|class}0 here?'
H2F94B54CE3AD: 'ここでは%select{struct|interface|class}0を意味していましたか？'
# "did you mean '%0'?"
HC2D29273BC0C: "'%0'を意味していましたか？"
# "did you mean 'using namespace'?"
H7384271A4FC4: "'using namespace'を使用する意図でしたか？"
# "did you mean to %select{dereference the argument to 'sizeof' (and multiply it by the number of elements)|remove the addressof in the argument to 'sizeof' (and multiply it by the number of elements)|provide an explicit length}0?"
H206E38ACCE90: '%select{sizeofの引数をデリファレンスする（要素数で掛ける）|sizeofの引数のアドレスを除去する（要素数で掛ける）|明示的な長さを指定する}0ことを意図していましたか？'
# 'did you mean to call the %0 method?'
H0FF3D4ADDC94: '%0メソッドを呼び出す意図でしたか？'
# 'did you mean to compare the result of %0 instead?'
HA27A0B6056FB: '代わりに%0の結果を比較する意図でしたか？'
# "did you mean to use '%0'?"
H18F66684E290: "'%0'を使用する意図でしたか？"
# "did you mean to use '.' instead?"
HE2F23CD42B59: "代わりに'.'を使用する意図でしたか？"
# "did you mean to use '\\u'?"
H8EB1B38F64B3: "'\\u'を使用する意図でしたか？"
# "did you mean to use 'typename'?"
HA177681AD789: "'typename'を使用する意図でしたか？"
# 'did you mean to use __block %0?'
H6A59F85FFA80: '__block %0を指定する意図でしたか？'
# "differing user-defined suffixes ('%0' and '%1') in string literal concatenation"
HD69068F6D5EE: "文字列リテラルの連結で異なるユーザー定義の接尾辞（'%0'と'%1'）があります"
# 'digit separator cannot appear at %select{start|end}0 of digit sequence'
HC90158811A8B: '数字シーケンスの%select{先頭|末尾}0で区切り文字が使用できません'
# 'digit separators are incompatible with C standards before C23'
H45FD89D6E3CC: 'C23以前のC規格では数字の区切り文字は互換性ありません'
# 'digit separators are incompatible with C++ standards before C++14'
H14907D30B29E: 'C++14以前のC++規格では数字の区切り文字は互換性ありません'
# 'dimension expression does not evaluate to a constant unsigned int'
H7ABEC48E09A3: '次元式が定数の符号なし整数に評価されません'
# "direct access to Objective-C's isa is deprecated in favor of object_getClass()"
H9F7CC297D241: 'Objective-Cのisaへの直接アクセスはobject_getClass()を使用することを推奨します'
# 'direct attribute on property %0 ignored (not implemented by this Objective-C runtime)'
H4EFEDE46DF56: 'プロパティ %0 のdirect属性は無視されました（このObjective-Cランタイムでは未実装）'
# 'direct base %0 is inaccessible due to ambiguity:%1'
HB8D80890A48E: '直接基底 %0 は曖昧のためアクセスできません:%1'
# 'direct comparison of %select{an array literal|a dictionary literal|a numeric literal|a boxed expression|}0 has undefined behavior'
HB492D0D3EB6E: '%select{配列リテラル|辞書リテラル|数値リテラル|箱リテラル|}0 の直接比較は未定義動作です'
# 'direct comparison of a string literal has undefined behavior'
H32F54A871B25: '文字列リテラルの直接比較は未定義動作です'
# 'direct member declared here'
H29E544F12128: '直接メンバはここに宣言されています'
# 'direct method %0 declared here'
HFC16D00B1613: '直接メソッド %0 はここに宣言されています'
# 'direct method implementation was previously declared not direct'
HD4855D6E8730: '直接メソッド実装は以前「非直接」と宣言されていました'
# 'direct method was declared in %select{the primary interface|an extension|a category}0 but is implemented in %select{the primary interface|a category|a different category}1'
HE6AB93C50673: '直接メソッドは%select{プライマリインターフェース|エクステンション|カテゴリ}0で宣言されましたが、%select{プライマリインターフェース|カテゴリ|異なるカテゴリ}1で実装されています'
# 'direct property cannot be @dynamic'
HE7907E55F6FD: 'direct属性プロパティは@dynamicを指定できません'
# "directive '#pragma omp %0' cannot contain more than one '%1' clause%select{| with '%3' name modifier| with 'source' dependence}2"
H4FF8713761CF: "#pragma omp %0 ディレクティブには'%1'句を%select{1つ以上|名前修飾子'%3'と共に|source従属と共に}2含めることはできません"
# "directive '#pragma omp %0' cannot contain more than one 'seq_cst',%select{ 'relaxed',|}1 'acq_rel', 'acquire' or 'release' clause"
HAC63F783B13F: "#pragma omp %0 ディレクティブには'seq_cst',%select{ 'relaxed',|}1 'acq_rel', 'acquire'または'release'句を複数含めることはできません"
# "directive '#pragma omp %0' requires the '%1' clause"
H54115AA95D6F: "#pragma omp %0 ディレクティブには'%1'句が必要です"
# "directive '#pragma omp atomic%select{ %0|}1' cannot be used with '%2' clause"
H007A29406786: "#pragma omp atomic%select{ %0|}1 ディレクティブは'%2'句と併用できません"
# "directive '#pragma omp atomic' cannot contain more than one 'read', 'write', 'update', 'capture', or 'compare' clause"
HE9B44E8E263B: "#pragma omp atomic ディレクティブには'read', 'write', 'update', 'capture',または'compare'句を複数含めることはできません"
# "directive '#pragma omp taskwait' cannot use 'nowait' clause without 'depend' clause"
H6E17817BFD4B: "ディレクティブ '#pragma omp taskwait' は 'depend' 句がない場合、'nowait' 句を使用できません"
# 'directive may only be specified in protocols only'
H164583DA86CB: 'ディレクティブはプロトコル内でのみ指定可能です'
# 'directive must be at file or namespace scope'
H1C3ABA756D9B: 'ディレクティブはファイルまたはネームスペースのスコープでなければなりません'
# "directive name modifier '%0' is not allowed for '#pragma omp %1'"
H92E146113514: "ディレクティブ名修飾子 '%0' は '#pragma omp %1' では使用できません"
# 'directory to dump objects to'
HD09DDF1651F9: 'オブジェクトをダンプするディレクトリ'
# 'disable '
HEEBCA72FCF98: '無効にする'
# 'disable P10 store forward-friendly conversion'
HB86702B7FAD9: 'P10のストアフォワーディングフレンドリーな変換を無効にする'
# 'disable all inlining (overrides other inlining options)'
HFF8B88EEABDB: '全てのインライン化を無効にする（他のインラインオプションを上書きします）'
# 'disable attaching TBAA tags to memory accessing operations to override default Flang behavior'
H90AD861FB58A: 'メモリアクセス操作にTBAAタグを付与しないことで、デフォルトのFlang動作を上書きします'
# 'disable attributor runs'
H6B93977370B5: 'attributorの実行を無効にする'
# 'disable automatically generated 32byte paired vector stores'
H37D64DB7E6AE: '自動生成された32byteのペアベクターストアを無効にする'
# 'disable constant hoisting on PPC'
H653549C49999: 'PPCでの定数持ち出しを無効にする'
# 'disable debug output'
H9D7E26590F03: 'デバッグ出力を無効にする'
# 'disable generation of structured FIR'
H021ABE4FA052: '構造化FIRの生成を無効にする'
# 'disable instrumentation optimizations that sacrifice profile accuracy (for debugging, default: false)'
H2E999F6F69E3: 'プロファイル精度を犠牲にするインストルメンテーション最適化を無効にする（デバッグ用、既定値: false）'
# 'disable multithreading'
H29487A51C4F2: 'マルチスレッドを無効にする'
# 'disable outlining indirect calls.'
H3A6314FB1E19: '間接呼び出しのアウトライン化を無効にする'
# 'disable peepholes'
H199828204162: 'ピープホール最適化を無効にする'
# 'disable preincrement load/store generation on PPC'
H137DF3A43000: 'PPCでの事前インクリメントロード/ストアの生成を無効にする'
# 'disable setting the node scheduling preference to ILP on PPC'
H1F9B89B13D72: 'PPCでノードのスケジューリング優先順位をILPに設定しない'
# 'disable sibling call optimization on ppc'
HCCF134132CAF: 'ppcでのSibling Call最適化を無効にする'
# 'disable similarity matching, and outlining, across branches for debugging purposes.'
H62E4BE9FF57F: 'デバッグ目的で、各ブランチをまたがる類似マッチングとアウトラインを無効にする'
# 'disable the default synthesis of Objective-C properties'
H72E5F763EC4E: 'Objective-Cプロパティのデフォルトの合成を無効にする'
# 'disable the feature'
H89A827DA533D: 'その機能を無効にする'
# 'disable unaligned load/store generation on PPC'
H6B2367F2761C: 'PPCでのアラインメントなしロード/ストア命令の生成を無効にする'
# 'disable vector permute decomposition'
HB72EC10B2CEE: 'ベクターパーミュート分解を無効にする'
# 'disabled expansion of recursive macro'
H7E32A887A37D: '再帰マクロの展開を無効にしました'
# 'disables externalization of functions whose addresses are taken'
HA22CB7ECC7FF: 'アドレスが取得されている関数の外部化を無効にします'
# 'disables externalization of global variable with local linkage; may cause globals to be duplicated which increases binary size'
HFB10DDFC11CF: 'ローカルリンケージを持つグローバル変数の外部化を無効にします。これにより、グローバル変数が複製され、バイナリサイズが増加する可能性があります'
# 'discriminator argument to ptrauth_sign_constant must be a constant integer, the address of the global variable where the result will be stored, or a blend of the two'
H24D055782EF6: 'ptrauth_sign_constantのdiscriminator引数は、定数整数、結果を格納するグローバル変数のアドレス、またはその両方の組み合わせでなければなりません'
# 'display a graph using the fractional block frequency representation.'
H0E0DF92DD5CF: '分数ブロック周波数表現を使用してグラフを表示します'
# 'display a graph using the raw integer fractional block frequency representation.'
H48B34855A7C6: '原始整数分数ブロック周波数表現を使用してグラフを表示します'
# 'display a graph using the real profile count if available.'
H40F8C199B975: '利用可能な場合は実際のプロファイルカウントを使用してグラフを表示します'
# 'display the encoded probes in binary section'
H2AB55984C4D7: 'バイナリセクション内のエンコードされたプローブを表示します'
# 'display the results in JSON format'
H181ED368406C: '結果をJSON形式で表示します'
# 'display the results in a list sorted by total time'
HD124AAE398C8: '総時間でソートされたリストで結果を表示します'
# 'display the results in a merged list sorted by pass name'
HD6270C003FAF: 'パス名でソートされた結合リストで結果を表示します'
# 'display the results in text format'
H5126F4AC6EE2: 'テキスト形式で結果を表示します'
# 'display the results ina with a nested tree view'
H3B01C53C285F: 'ネストされたツリービューで結果を表示します'
# 'display the results with a nested pipeline view'
HD3FB89799811: 'ネストされたパイプラインビューで結果を表示します'
# 'div and rem instructions on integers with more than <N> bits are expanded.'
H9085E8D323A2: 'N ビットを超える整数に対する div と rem 指令は展開されます。'
# 'division by zero'
H3658877899CE: 'ゼロ除算'
# 'division by zero in preprocessor expression'
H312B477ACFDB: 'プリプロセッサ式におけるゼロ除算'
# 'dllexport/dllimport inline member functions of dllexport/import classes (default)'
H138D0C477A7F: 'dllexport/import クラスの inline メンバ関数に dllexport/dllimport を適用 (デフォルト)'
# 'dllimport cannot be applied to non-inline function definition'
H1B629BAD5F55: 'dllimport を非 inline 関数定義に適用することはできません'
# 'do not apply'
HB502CD3A2C1B: '適用しない'
# 'do not diff functions whose contents have not been changed from one binary to another'
H30A32C42CDF9: '1 つのバイナリから別のバイナリへの変更がない関数の diff を行わない'
# 'do not display graphs.'
H0D6F782C8BD3: 'グラフを表示しない'
# 'do not infer Objective-C related result type based on method family'
HA72282825A47: 'メソッドファミリーに基づいて Objective-C 関連の戻り値タイプを推論しない'
# 'do not optimize PLT calls'
H790DE86EF643: 'PLT 呼び出しを最適化しない'
# 'do not optimize functions with jump tables'
HCB3EB74717E1: 'ジャンプテーブルを使用する関数を最適化しない'
# 'do not perform frame optimization'
HA057BC463383: 'フレーム最適化を行わない'
# 'do not perform indirect call promotion'
H868459C436A1: '間接呼び出しのプロモーションを行わない'
# 'do not print merged data to stdout'
H7F153D59BE8A: 'stdout にマージされたデータを出力しない'
# 'do not print objects/functions'
H6FEA94329728: 'オブジェクト/関数を出力しない'
# 'do not reorder basic blocks'
HDB47587E0803: 'basic blocks の再配置を行わない'
# 'do not reorder functions'
H80129F5CF747: '関数の再配置を行わない'
# 'do not scan cold functions for external references (may result in slower binary)'
H06D0BAB57AFF: '外部参照のための cold 関数のスキャンを行わない (これによりバイナリが遅くなる可能性があります)'
# 'do not show.'
H410E3DC30FB6: '表示しない'
# 'domain argument %0 does not point to an NSString or CFString constant'
H04276D1D8088: 'ドメイン引数 %0 は NSString または CFString の定数を指しません'
# 'domain argument %select{|%1 }0does not refer to global constant'
H427CD3AEDAC3: 'ドメイン引数%select{|%1 }0はグローバル定数を指しません'
# "don't always align innermost loop to 32 bytes on ppc"
H8446540436C8: 'ppcでは内側のループを32バイトに常にアライメントしません'
# "don't demangle symbols"
HFD596F32C278: 'シンボルのデマングルをしない'
# "don't report bad accesses via pointers with this tag"
HC0582E9D5000: 'このタグを持つポインタを介した不正なアクセスを報告しない'
# "don't test for failure"
H2CD70DD9AB50: '失敗の検出をしない'
# 'double precision constant requires %select{cl_khr_fp64|cl_khr_fp64 and __opencl_c_fp64}0, casting to single precision'
H4D72ED1FA64B: '倍精度定数は%select{cl_khr_fp64|cl_khr_fp64および__opencl_c_fp64}0が必要です。単精度にキャストします'
# 'double-quoted include "%0" cannot be aliased to angle-bracketed include <%1>'
H136E4A788F48: 'ダブルクォートで囲まれたインクルード"%0"を角括弧表記のインクルード<%1>にエイリアスできません'
# 'double-quoted include "%0" in framework header, expected angle-bracketed instead'
H2D4306614026: 'フレームワークヘッダー内のダブルクォートで囲まれたインクルード"%0"は、角括弧表記のインクルードが期待されます'
# 'due to %0 being dllexported%select{|; try compiling in C++11 mode}1'
HB6A4EDE022F4: '%0がdllexportedであるため%select{|; C++11モードでコンパイルするように試してください}1'
# 'due to lvalue conversion of the controlling expression, association of type %0 will never be selected because it is %select{of array type|qualified}1'
HE4CE0D7DDF88: 'コントローリング式の左辺値変換により、タイプ%0の関連付けは%select{配列型である|修飾されている}1ため、決して選択されません'
# 'dump CFG of functions with unknown control flow'
HDBCCF42DD8E1: '不明な制御フローを持つ関数のCFGをダンプ'
# 'dump CodeView symbol record raw bytes'
HAEF5CAE11C43: 'CodeViewシンボルレコードの生データをダンプ'
# 'dump CodeView type record raw bytes from IPI stream'
H689D664ADF5F: 'IPIストリームからのCodeViewタイプレコードの生データをダンプ'
# 'dump CodeView type record raw bytes from TPI stream'
H0FC07B9E3139: 'TPIストリームからのCodeViewタイプレコードの生データをダンプ'
# 'dump CodeView type records from IPI stream'
H7E10374C5E74: 'IPIストリームからのCodeViewタイプレコードをダンプ'
# 'dump CodeView type records from TPI stream'
H4737840A6120: 'TPIストリームからのCodeViewタイプレコードをダンプ'
# 'dump FPO records'
H341F7F9C33EE: 'FPOレコードをダンプ'
# 'dump Globals hashes'
H39246A122E5B: 'グローバルハッシュをダンプ'
# 'dump Globals symbol records'
H9634A6AB6723: 'グローバルシンボルレコードをダンプ'
# 'dump Linux alternative instructions info'
H92A80825B346: 'Linuxの代替命令情報ダンプ'
# 'dump Linux kernel PCI fixup table'
H0391F2419EB1: 'LinuxカーネルPCIフィクスアップテーブルをダンプします'
# 'dump Linux kernel SMP locks'
HF372737C565A: 'LinuxカーネルSMPロックをダンプします'
# 'dump Linux kernel exception table'
HD3701232B9AB: 'Linuxカーネル例外テーブルをダンプします'
# 'dump Linux kernel paravitual patch sites'
HAD29F02859C4: 'Linuxカーネルパラバーチャルパッチサイトをダンプします'
# 'dump Linux kernel static calls'
HBDFDCB9108E1: 'Linuxカーネル静的コールをダンプします'
# 'dump Linux kernel static keys jump table'
HF51D39901B0D: 'Linuxカーネル静的キーのジャンプテーブルをダンプします'
# 'dump PDB String Table'
H21DF5A80DD1F: 'PDB文字列テーブルをダンプします'
# 'dump PDB String Table Details'
H5264906CCB27: 'PDB文字列テーブルの詳細をダンプします'
# 'dump PDB named stream table'
HD3F8AEE8FAA4: 'PDBネームドストリームテーブルをダンプします'
# 'dump Publics hashes and address maps'
H982F0D86E5A4: 'Publicsハッシュとアドレスマップをダンプします'
# 'dump Publics stream data'
H77C736E1764D: 'Publicsストリームデータをダンプします'
# 'dump all BAT tables'
H2473A7E7E1DA: 'すべてのBATテーブルをダンプします'
# 'dump backreferences'
H60EF9FD249CA: 'バックリファレンスをダンプします'
# 'dump callgraph to the given file'
H3F328C977475: '指定されたファイルにコールグラフをダンプします'
# 'dump compiland information'
H6229647CD528: 'コンパイル対象のコンパイルド情報をダンプします'
# 'dump cross module exports (DEBUG_S_CROSSSCOPEEXPORTS subsection)'
HBA659F46571B: 'クロスモジュールエクスポートをダンプします（DEBUG_S_CROSSSCOPEEXPORTSサブセクション）'
# 'dump cross module imports (DEBUG_S_CROSSSCOPEIMPORTS subsection)'
H26F5B6DD5D0E: 'クロスモジュールインポートをダンプします（DEBUG_S_CROSSSCOPEIMPORTSサブセクション）'
# 'dump file information'
HE35AD70400C4: 'ファイル情報をダンプします'
# 'dump file summary'
HBC127C99D732: 'ファイルのサマリーをダンプします'
# "dump function CFGs to graphviz format after each stage;enable '-print-loops' for color-coded blocks"
H790226C2A523: "各ステージ後に関数CFGをgraphviz形式でダンプします；色分けされたブロックを有効にするには'-print-loops'を有効にします"
# 'dump function into assembly'
H160A471B29E4: 'アセンブリに関数をダンプ'
# 'dump id hashes and index offsets'
H45ABCE63A690: 'IDのハッシュ値とインデックスオフセットをダンプ'
# 'dump inlinee line information (DEBUG_S_INLINEELINES subsection)'
HD3FD0B06365E: 'インライン情報の行情報をダンプ（DEBUG_S_INLINEELINESサブセクション）'
# 'dump jitted objects'
HC6CCA4501C84: 'jitされたオブジェクトをダンプ'
# 'dump module symbols'
H1047966FD40D: 'モジュールシンボルをダンプ'
# 'dump parsed bolt data for debugging'
H1E6D3BB027F8: 'デバッグ用のBoltデータをダンプ'
# 'dump public / global common record stream'
H582CCEB02839: 'public / global commonレコードストリームをダンプ'
# 'dump raw ORC unwind information (sorted)'
H3C7746AFAC8F: 'ORCアンワインド情報の生データをダンプ（ソート済み）'
# 'dump section contributions'
HD1F222CEF84F: 'セクションへの貢献をダンプ'
# 'dump section map'
H3816E8108BF5: 'セクションマップをダンプ'
# 'dump source file/line information (DEBUG_S_LINES subsection)'
HD995BB7B3DC0: 'ソースファイル/行情報をダンプ（DEBUG_S_LINESサブセクション）'
# 'dump statistics on the number and size of types transitively referenced by symbol records'
H63F7F6E11F53: 'シンボルレコードによって間接参照されるタイプの数とサイズの統計をダンプ'
# "dump subsections from each module's debug stream"
HFC99948BE195: '各モジュールのデバッグストリームのサブセクションをダンプ'
# 'dump summary of the PDB streams'
H81F82DCB9C94: 'PDBストリームのサマリーをダンプ'
# 'dump the Pre-FIR tree prior to FIR generation'
H1C6BBDF08715: 'FIR生成前のPre-FIRツリーをダンプ'
# 'dump the preprocessed tokens'
H80F7445EE14A: 'プリプロセス済みトークンをダンプ'
# 'dump the symbol table'
H8EF419A2DB2C: 'シンボルテーブルをダンプ'
# "dump the symbols record's all children."
HB63145DD7309: 'シンボルレコードのすべての子をダンプ'
# "dump the symbols record's all parents."
H7B31FDBBCCB3: 'シンボルレコードのすべての親をダンプ'
# 'dump the syntax tree'
H63FBC9209EA6: '構文木をダンプ'
# 'dump type hashes and index offsets'
H02D59206CDC4: '型ハッシュとインデックス オフセットをダンプする'
# 'dumps the generated benchmark object to disk and prints a message to access it'
H7BC6D646456E: '生成されたベンチマーク オブジェクトをディスクにダンプし、アクセスするためのメッセージを出力する'
# "duplicate %0 clause in an 'external_source_symbol' attribute"
H3523FE9C404F: "'external_source_symbol'属性内の%0句が重複しています"
# "duplicate '%0' declaration specifier"
HD8ED5E5CBF0B: "'%0'宣言仕様子が重複しています"
# "duplicate 'virtual' in base specifier"
HA0A16A07E97F: "基底指定子内に'virtual'が重複しています"
# "duplicate asm qualifier '%0'"
HE8EA4F072983: "アセンブラ修飾子'%0'が重複しています"
# "duplicate attribute subject matcher '%0'"
H1D5786B873EA: "属性対象マッチャー'%0'が重複しています"
# "duplicate case value '%0'"
H4BDEA82874BB: "'case'値'%0'が重複しています"
# "duplicate case value: '%0' and '%1' both equal '%2'"
HCE899F8A3E5C: "'case'値'%0'と'%1'が両方とも'%2'と等しいため重複しています"
# 'duplicate code segment specifiers'
HBEFD6978776A: 'コードセグメント指定子が重複しています'
# 'duplicate declaration of method %0'
HA0EF6CBBD7AC: 'メソッド%0の宣言が重複しています'
# 'duplicate default generic association'
H2C51601AE456: 'デフォルト汎用アソシエーションが重複しています'
# 'duplicate definition of category %1 on interface %0'
HECFD78DC0BC9: 'インターフェース%0に対するカテゴリ%1の定義が重複しています'
# 'duplicate explicit instantiation of %0'
HDBC529CD9977: '%0の明示的なインスタンチエーションが重複しています'
# 'duplicate explicit instantiation of %0 ignored as a Microsoft extension'
HDA2A4AABFB51: 'Microsoft拡張機能として%0の明示的なインスタンチエーションを無視します'
# 'duplicate interface definition for class %0'
H95CB7C0C6F7F: 'クラス%0のインターフェース定義が重複しています'
# 'duplicate key in dictionary literal'
H048B82F688D2: '辞書リテラル内の重複したキー'
# 'duplicate macro parameter name %0'
H066136189F8C: 'マクロパラメータ名%0が重複しています'
# 'duplicate member %0'
HC0ECCD41D310: 'メンバー%0が重複しています'
# "duplicate modifier '%0' in '%1' clause"
HF11C4EF9CA32: "'%1'句内の修飾子'%0'が重複しています"
# "duplicate module file extension block name '%0'"
HCCAD463A8663: "モジュール ファイル拡張ブロック名 '%0' の重複"
# 'duplicate nullability specifier %0'
HBA9CD0A409AC: 'nullability修飾子 %0 の重複'
# 'duplicate parameter modifier %0'
H6D49784340BA: 'パラメータ修飾子 %0 の重複'
# 'duplicate protocol definition of %0 is ignored'
HD20F74839349: '%0 の重複プロトコル定義は無視されます'
# 'duplicate unconditional branches that cross a cache line'
H33FDED0520CF: 'キャッシュラインをまたぐ重複の無条件分岐'
# 'duplicate use of asm operand name "%0"'
H3EAACD3C87CF: 'asm オペランド名 "%0" の重複使用'
# "duplicated command '%select{\\|@}0%1'"
H76B78FD8FF48: "コマンド '%select{\\|@}0%1' の重複"
# 'during field initialization in %select{this|the implicit default}0 constructor'
H865BE3842864: '%select{この|暗黙のデフォルト}0 コンストラクタのフィールド初期化中に'
# 'during template argument deduction for %select{class|variable}0 template %select{partial specialization |}1%2 %3'
H7650D46B8E2E: '%select{クラス|変数}0 テンプレート %select{部分特殊化 |}1%2 %3 のテンプレート引数推論中に'
# 'dxc compatibility options.'
H3AF127D95E36: 'Dxc 互換性オプション。'
# 'dxv not found; resulting DXIL will not be validated or signed for use in release environment'
H6BC661D7D75A: 'dxv が見つかりません; 生成された DXIL はリリース環境で使用するための検証や署名が行われません'
# 'dynamic exception specifications are deprecated'
H37FC9EB13E92: '動的例外仕様は非推奨です'
# 'dynamic exception specifications with types are currently ignored in wasm'
H3D36CC52AFBF: 'wasmでは現在、型付きの動的例外仕様は無視されます'
# 'dynamic initialization is not supported for __device__, __constant__, __shared__, and __managed__ variables'
H6251875A88D3: '__device__, __constant__, __shared__, および __managed__ 変数の動的初期化はサポートされていません'
# "dynamic library symbol '%0' is %select{weak defined|thread local}1, but its declaration is not"
H876356229227: "動的ライブラリシンボル '%0' は%select{弱い定義|スレッド局所}1ですが、その宣言にはそうではありません"
# 'dynamic memory allocation is not permitted in constant expressions until C++20'
H63A7F05406AD: '定数式では C++20 まで動的メモリ割り当てが許可されていません'
# 'dynamic property cannot have instance variable specification'
HD37DA789564D: '動的プロパティにはインスタンス変数仕様を指定できません'
# 'dynamic_cast will not work since RTTI data is disabled by %select{-fno-rtti-data|/GR-}0'
HBD4085CEECCB: '%select{-fno-rtti-data|/GR-}0 により RTTI データが無効化されているため dynamic_cast は機能しません'
# 'editor placeholder in source file'
H8455BF28630F: 'ソースファイル内のエディタプレースホルダー'
# "effects conflict when merging declarations; kept '%0', discarded '%1'"
H73408A047417: "宣言を統合する際に効果が衝突; '%0' を保持し '%1' を破棄"
# 'elaborated enum specifier cannot be declared as a friend'
H7321A1B2921E: 'elaborated enum specifierはフレンドとして宣言できません'
# 'element %0 also has value %1'
HFCF33BA58954: '要素%0も値%1を持っています'
# 'element %0 has been implicitly assigned %1 which another element has been assigned'
H72D209AC7B7A: '要素%0には、別の要素が割り当てられた%1が暗黙のうちに割り当てられています'
# 'eliminate unreachable code'
H5CECE35D9DC9: '到達不能なコードを除去'
# 'ellipsis in pack %select{|init-}0capture must appear %select{after|before}0 the name of the capture'
H6C27D3CFC7C1: 'パック%select{|init-}0キャプチャの楕円記法は、キャプチャの名前の%select{後ろ|前}0に現れる必要があります'
# 'embedded and GOT-based position independence are incompatible'
H471F7EE0F065: '埋め込みとGOTベースの位置独立性は互いに互換性ありません'
# 'embedding a #%0 directive within macro arguments is not supported'
HB9B077BA7EC9: 'マクロの引数内に#%0ディレクティブを埋め込むことはサポートされていません'
# 'embedding a directive within macro arguments has undefined behavior'
HD8530107105F: 'マクロの引数内にディレクティブを埋め込むことは未定義の動作を引き起こします'
# 'emit JSON'
H65D5678CB372: 'JSONを出力'
# 'emit YAML'
H54F0FFD710F0: 'YAMLを出力'
# 'emit normal text output (default)'
HED43B52325DA: '通常のテキスト出力（デフォルト）'
# 'emit warnings'
H020A72B2E05B: '警告を出力'
# 'empty %0 cannot be composed with named ones'
HE7EB612973FC: '%0の空のものは、名前付きのものと組み合わせることはできません'
# 'empty %select{struct|union}0 is a GNU extension'
H758BF913FE7C: '%select{struct|union}0が空の場合、これはGNU拡張機能です'
# 'empty case range specified'
H15C9A1C7CC9D: '指定されたケース範囲が空です'
# 'empty character constant'
H277FE12896EE: '空の文字定数'
# "empty delimited universal character name; treating as '\\' '%0' '{' '}'"
HF9BFC93E5104: '区切り文字のないユニバーサル文字名; "\\" "%0" "{" "}" として処理されます'
# "empty expression statement has no effect; remove unnecessary ';' to silence this warning"
HE7735A8B2ADE: '空の式ステートメントは効果がありません; 不要な";"を削除してこの警告を抑制してください'
# 'empty filename'
H1CC4DB7178D7: '空のファイル名'
# "empty initialization statement of '%select{if|switch|range-based for}0' has no effect"
HCB0D32A02160: "'%select{if|switch|range-based for}0'の空の初期化ステートメントは効果がありません"
# 'empty macro arguments are a C99 feature'
HD178344D06D5: '空のマクロ引数はC99の機能です'
# 'empty macro arguments are incompatible with C++98'
HE94FA0985A16: '空のマクロ引数はC++98と互換性がありません'
# 'empty modifier-specification-list is not allowed'
HB0857A4C55BC: '空の修飾子指定リストは許可されていません'
# "empty paragraph passed to '%select{\\|@}0%1' command"
H38E7CAD895AE: "'%select{\\|@}0%1'コマンドに空のパラグラフが渡されました"
# 'empty parentheses interpreted as a function declaration'
H058E44413EA1: '空の括弧が関数宣言として解釈されました'
# 'empty symbolic operand name in inline assembly string'
H2DC9E2773A21: 'インラインアセンブリ文字列のシンボリックオペランド名が空です'
# 'enable '
H15F13B12A39B: '有効にする '
# 'enable CUDA Fortran'
H7782720B2BB2: 'CUDA Fortranを有効にする'
# 'enable PC Relative linker optimization'
HB16456951215: 'PC相対リンク最適化を有効にする'
# 'enable all attributor runs'
HDC600719482C: 'すべてのattributor実行を有効にする'
# 'enable all debugging printout'
H74F2F5BCE1B3: 'すべてのデバッグ出力機能を有効にする'
# 'enable all peephole optimizations'
HDB0605F9FA2D: 'すべてのピープホール最適化を有効にする'
# 'enable call graph SCC attributor runs'
H3201C4D45BA3: 'コールグラフ SCC attributor実行を有効にする'
# 'enable coalescing of duplicate branches for PPC'
HF8CFF517B8BE: 'PPCの重複ブランチの統合を有効にする'
# 'enable const and copy propagation after tail duplication'
H9919F0504195: 'テイル複製後のconst伝播とコピー伝播を有効にする'
# 'enable elimination of sign-extensions'
HF1685FA60FF7: '符号拡張の削除を有効にする'
# 'enable elimination of zero-extensions'
H64FB2468ED4F: 'ゼロ拡張の削除を有効にする'
# 'enable extended encoding of block type signature'
HCB2363578F85: 'ブロックタイプシグネチャの拡張エンコーディングを有効にする'
# 'enable fixed form'
H94C246A27D7E: '固定形式を有効にする'
# 'enable load elimination using memory profiling data when performing ICP'
HF69B8E887DB3: 'ICP を実行中にメモリプロファイリングデータを使用したロード削除を有効にする'
# 'enable module-wide attributor runs'
H6A1678301319: 'attributor の実行をモジュール全体で有効にする'
# 'enable openacc'
HCDE854697CA7: 'OpenACC を有効にする'
# 'enable openmp'
H1CFA464A8305: 'OpenMP を有効にする'
# 'enable openmp GPU target codegen'
HFFBCDE42BA97: 'OpenMP GPUターゲットのコード生成を有効にする'
# 'enable openmp device compilation'
H87F22E3808C9: 'OpenMP デバイスコンパイルを有効にする'
# 'enable optimization of conditional traps'
HE76CA42D1102: '条件付きトラップの最適化を有効にする'
# 'enable peephole optimizations'
HCB5CF649C604: 'ピーホール最適化を有効にする'
# 'enable preservation of all attributes. even those that are unlikely to be useful'
H13B51E3CE008: '全ての属性を保持する. 役立たない可能性のあるものも含む'
# 'enable preservation of attributes throughout code transformation'
H580FCE5CF0E9: 'コード変換全体にわたって属性を保持する'
# 'enable register pressure reduce in machine combiner pass.'
H357058DB4C32: 'マシンコンビナー パスでレジスタプレッシャーの削減を有効にする'
# 'enable safe stack coloring'
H95A282232AD0: 'セーフスタック カラーを有効にする'
# 'enable safe stack layout'
HCB2AFC2C2D37: 'セーフスタック レイアウトを有効にする'
# 'enable software prefetching on PPC'
H5C8D5DA8AA2D: 'PPC 上でソフトウェアプリフェッチを有効にする'
# 'enable splitting of the restore block if possible'
HFB2E82BFA087: '復元ブロックの分割を可能であれば有効にする'
# 'enable the feature when using profile data'
H983F48A83B4D: 'プロファイルデータを使用する場合に機能を有効にする'
# 'enable the feature with/wo profile data'
HA9F0B8DA8301: 'プロファイルデータの有無にかかわらず機能を有効にする'
# 'enable the shrink-wrapping pass'
H7A4C304F5A12: 'シュリンクラッピング パスを有効にする'
# 'enable use of redzone on AArch64'
H0CF57E62B75D: 'AArch64 上でレッドゾーンを使用する'
# 'enable/disable all ARC Optimizations'
H0DFE6EE5AB14: 'ARC最適化を有効/無効にします'
# 'enclose %0 in %select{an @available|a __builtin_available}1 check to silence this warning'
HC0011ACD5CEF: '%0を%select{@availableによる|__builtin_availableによる}1チェックで囲むことでこの警告を沈黙させることができます'
# 'encoding of %0 type is incomplete because %1 component has unknown encoding'
HE63ED9F43B42: '%0型のエンコードが未完了です。%1コンポーネントのエンコードが不明のためです'
# "encoding prefix '%0' on an unevaluated string literal has no effect%select{| and is incompatible with c++2c}1"
HFB264777D8F6: "評価されない文字列リテラルのエンコードプレフィックス'%0'は効果がありません%select{|、そしてC++2cと互換性ありません}1"
# 'end tag'
HE76165194C35: '終了タグ'
# "entering module '%0' due to this pragma"
H00CF7F723C1C: "このpragmaによりモジュール'%0'に移動しました"
# 'enum %0 was explicitly specialized here'
H888313DD02EB: 'enum %0は明示的に特殊化されました'
# 'enumeration %0 is incomplete'
HACD4B99390E7: '列挙型%0は未完了です'
# 'enumeration cannot be a template'
H0777CF5091AE: '列挙型はテンプレートとして使用できません'
# 'enumeration previously declared as %select{un|}0scoped'
H979505490BD1: '列挙型は以前%select{非|}0スコープとして宣言されました'
# 'enumeration previously declared with %select{non|}0fixed underlying type'
H8C078F2C2E0F: '列挙型は%select{非|}0固定ベース型で宣言されました'
# 'enumeration redeclared with different underlying type %0 (was %1)'
H67E555152513: '列挙型は異なるベース型%0（以前は%1）で再宣言されました'
# 'enumeration type %0 is not allowed in a vector conditional'
H71F136014B3C: '列挙型%0はベクタ条件式では使用できません'
# 'enumeration type in nested name specifier is incompatible with C++98'
HA088A8B3CD7F: 'ネストされた名前指定子の列挙型はC++98と互換性ありません'
# 'enumeration types with a fixed underlying type are a C++11 extension'
HFFCCC841103E: '固定ベース型を持つ列挙型はC++11拡張機能です'
# 'enumeration types with a fixed underlying type are a C23 extension'
H463F9486C53D: '固定ベース型を持つ列挙型はC23拡張機能です'
# 'enumeration types with a fixed underlying type are a Microsoft extension'
H6BC03602C783: '固定ベース型を持つ列挙型はMicrosoft拡張機能です'
# 'enumeration types with a fixed underlying type are incompatible with C standards before C23'
H39FE50255F32: '固定ベース型を持つ列挙型はC23以前の規格と互換性ありません'
# 'enumeration types with a fixed underlying type are incompatible with C++98'
H73924A0CCAED: '固定ベース型を持つ列挙型はC++98と互換性ありません'
# 'enumeration value %0 is out of range of flags in enumeration type %1'
H4F8DF0E727E1: '列挙値%0は列挙型%1のフラグの範囲外です'
# 'enumeration values exceed range of largest integer'
HC084754F6A8B: '列挙子の値が最大整数型の範囲を超えています'
# 'enumerations cannot be explicitly instantiated'
H997CA3993586: '列挙型は明示的なインスタンス化できません'
# 'enumerator %0 does not exist in instantiation of %1'
H3D7F75D140F9: '%1 のインスタンス化において、列挙子 %0 は存在しません'
# 'enumerator %0 with value %1 here'
HD8CCFA398CFA: 'ここでの列挙子 %0 の値 %1'
# 'enumerator value %0 is not representable in the underlying type %1'
HAB7EC95F417E: '列挙子の値 %0 は基底型 %1 で表現できません'
# 'enumerator value is not representable in the underlying type %0'
H9CDAE4E68DA9: '列挙子の値は基底型 %0 で表現できません'
# 'enums in the Microsoft ABI are signed integers by default; consider giving the enum %0 an unsigned underlying type to make this code portable'
HB2071E0C6A67: 'Microsoft ABI での列挙型はデフォルトで符号付き整数です；enum %0 に符号なし基底型を指定して移植性を確保することを検討してください'
# "environment '%0' is not supported: '%1'"
H88874600742B: "環境 '%0' はサポートされていません: '%1'"
# "environment variable 'SOURCE_DATE_EPOCH' ('%0') must be a non-negative decimal integer <= %1"
H4F81D6E33B46: "環境変数 'SOURCE_DATE_EPOCH' ('%0') は %1 以下の非負の10進整数である必要があります"
# 'environment variable CC_PRINT_HEADERS_%select{FORMAT|FILTERING}0 has invalid value %1'
H69C68EA8FAC0: '環境変数 CC_PRINT_HEADERS_%select{FORMAT|FILTERING}0 の値 %1 は無効です'
# 'epsilon for benchmark point clustering'
HA3C9480C7F62: 'ベンチマークポイントクラスタリングの閾値'
# 'epsilon for detection of when the cluster is different from the LLVM schedule profile values'
HBE4394643CF5: 'クラスタがLLVMスケジュールプロファイル値と異なる場合の検出閾値'
# 'equality comparison between function pointer and void pointer (%0 and %1)'
HD61C2409F0EE: '関数ポインタとvoidポインタ (%0 と %1) の等値比較'
# 'equality comparison with extraneous parentheses'
H461F5EF9D3AE: '余分な括弧を伴う等値比較'
# 'error in backend: %0'
H5E9564F574A6: 'バックエンドエラー: %0'
# "error in loading module '%0' from prebuilt module path"
H9CB0C604EFA6: "事前構築モジュールパスからのモジュール '%0' の読み込みエラー"
# "error opening '%0': %1"
H14F257DDD829: "'%0' のオープンに失敗: %1"
# "error opening '%0': required by the CrossTU functionality"
HD1F59176156D: "CrossTU機能で必要とされる '%0' のオープンエラー"
# "error opening file '%0': %1"
H36FA208EA1D0: "ファイル '%0' のオープンに失敗: %1"
# "error parsing index file: '%0' line: %1 '<USR-Length>:<USR> <File-Path>' format expected"
HDAED7E913418: "インデックスファイルの解析エラー: '%0' 行 %1 には '<USR-Length>:<USR> <File-Path>' 形式が期待されます"
# "error reading '%0': %1"
HB78815388E3E: "読み取りエラー: '%0': %1"
# 'error reading stdin: %0'
HFD3376140ADC: '標準入力の読み取りエラー: %0'
# 'escaped newline between */ characters at block comment end'
H16A52D2449DE: '*/文字列間のエスケープされた改行がブロックコメントの終わりに存在します'
# 'exact handling of relational integer ICmp'
H083F931E8E9B: '整数ICmpの関係演算子の正確な処理'
# "exactly one '%0' directive must appear in the loop body of an enclosing directive"
H3C9E45F0564B: "外側のディレクティブのループ本文内に'%0' ディレクティブが正確に1つ必要です"
# "exactly one of 'depend', 'destroy', or 'update' clauses is expected"
H41134C7D7A6A: "'depend', 'destroy', または 'update' クラウスのうち正確に1つが必要です"
# "exactly one of 'inclusive' or 'exclusive' clauses is expected"
H43DE08BE23B9: "'inclusive' または 'exclusive' クラウスのうち正確に1つが必要です"
# 'exception declarator cannot be qualified'
H9E73B1CE7174: '例外宣言子は修飾できません'
# 'exception model'
HB1632BFA78F0: '例外モデル'
# 'exception object of type %0 has %select{private|protected}1 destructor'
H45EFA39B1650: '型%0の例外オブジェクトは%select{private|protected}1 デストラクタを有しています'
# 'exception of type %0 will be caught by earlier handler'
H63736AC525A3: '型%0の例外はより前のハンドラーによってキャッチされます'
# 'exception specification in declaration does not match previous declaration'
H02068091298F: '宣言における例外指定が以前の宣言と一致しません'
# 'exception specification in explicit instantiation does not match instantiated one'
HB42947FF7AB7: '明示的インスタンテーションにおける例外指定がインスタンス化されたものと一致しません'
# 'exception specification is not available until end of class definition'
HD568DD20B09E: '例外指定はクラス定義の終了まで利用できません'
# 'exception specification needed for member of incomplete class %0'
H64C22CA14EC7: '未完全なクラス%0のメンバには例外指定が必要です'
# 'exception specification of %0 uses itself'
H8B7B4ED4974B: '%0の例外指定は自身を利用しています'
# "exception specification of '...' is a Microsoft extension"
H50C368DB8633: "'...'の例外指定はMicrosoftの拡張です"
# 'exception specification of overriding function is more lax than base version'
HBB63D54D7089: 'オーバーライド関数の例外指定がベースバージョンよりも緩いです'
# 'exception specifications are not allowed beyond a single level of indirection'
HB84B4B7EA104: '間接参照の1レベルを超えて例外指定を使用することはできません'
# 'exception specifications are not allowed in %select{typedefs|type aliases}0'
HBAC9EC08A3E9: '%select{typedefs|type aliases}0において例外指定を使用することはできません'
# 'exception specifications of %select{return|argument}0 types differ'
H04931F9B5864: '例外指定の%select{戻り値|引数}0の型が異なります'
# 'excess elements in %select{array|vector|scalar|union|struct}0 initializer'
H6B059251CDF0: '%select{配列|ベクトル|スカラ|ユニオン|構造体}0の初期化子に余剰な要素があります'
# 'excess elements in char array initializer'
H65240A881DB2: 'char配列の初期化子に余剰な要素があります'
# 'excess elements in initializer for indivisible sizeless type %0'
HF6B0539A54ED: '分割不可能なサイズなし型%0の初期化子に余剰な要素があります'
# 'excess precision is requested but the target does not support excess precision which may result in observable differences in complex division behavior%select{|, additional uses where the requested higher precision cannot be honored were found but not diagnosed}0'
H46192DCC4FC7: '過剰な精度が要求されていますが、ターゲットでは過剰な精度をサポートしないため、複素数除算の動作に観測可能な差異が生じる可能性があります%select{|、要求されたより高い精度を保持できない追加の使用例が見つかりましたが診断されませんでした}0'
# 'exe called with module IR after each pass that changes it'
H9DCF33C92D4F: 'モジュールIRを変更する各パスの後にexeが呼び出されました'
# 'execute only is not supported for the %0 sub-architecture'
H355C6C44365F: 'サブアーキテクチャ%0ではexecute onlyがサポートされていません'
# 'existing instance variable %1 for __weak property %0 must be __weak'
HBE1A4247ED95: '__weakプロパティ%0の既存のインスタンス変数%1は__weakでなければなりません'
# 'existing instance variable %1 for property %0 with %select{unsafe_unretained|assign}2 attribute must be __unsafe_unretained'
H45768C1508E1: '属性が%select{unsafe_unretained|assign}2のプロパティ%0の既存のインスタンス変数%1は__unsafe_unretainedでなければなりません'
# 'existing instance variable %1 for strong property %0 may not be %select{|__unsafe_unretained||__weak}2'
H98A6ABD1A54E: 'strongプロパティ%0の既存のインスタンス変数%1は%select{|__unsafe_unretained||__weak}2であってはなりません'
# 'existing instance variable %1 for strong property %0 may not be __weak'
HD554DEC7881B: 'strongプロパティ%0の既存のインスタンス変数%1は__weakであってはなりません'
# 'exit after writing aggregated data file'
H8BF29D13B0F2: '集約データファイルの書き込み後に終了'
# 'expanding this definition of %0'
H5BA1B50B21D1: '%0のこの定義を展開中'
# 'expansion of date or time macro is not reproducible'
H816E771096AD: '日付または時刻のマクロの展開は再現できません'
# 'expansion of macro %0 requested here'
H97F2144252C9: 'ここでのマクロ%0の展開が要求されました'
# "expansion of predefined identifier '%0' to a string literal is a Microsoft extension"
H89888E84B8EB: "予約済み識別子'%0'を文字列リテラルに展開することはMicrosoft拡張です"
# 'expected "FILENAME" or <FILENAME>'
H6038B7E6D091: '"FILENAME"または<FILENAME>が期待されます'
# "expected #pragma pack parameter to be '1', '2', '4', '8', or '16'"
HA00C06644234: '#pragma packパラメータは"1"、"2"、"4"、"8"、または"16"でなければなりません'
# 'expected %0'
H1C2353E37609: '%0が期待されます'
# 'expected %0 at end of module'
H0F6B0905AE5F: 'モジュールの終了時に%0が期待されます'
# "expected %0 in OpenMP clause '%1'"
HC79E103ACDFE: "OpenMP句'%1'に%0が期待されました"
# 'expected %0 or %1'
HC08F459555DA: '%0または%1が期待されます'
# 'expected %0; %1 is a keyword in Objective-C++'
H62A445966708: '%0を期待しました;%1はObjective-C++のキーワードです'
# 'expected %1 after %0'
H5879CE8F4818: '%0の後%1が期待されます'
# "expected %select{'enable', 'disable', 'begin' or 'end'|'disable'}0 - ignoring"
H1B18CF6CA096: "%select{'disable', 'enable', 'begin'または'end'|'disable'}0を指定してください - 無視しました"
# "expected %select{'match'|'match', 'adjust_args', or 'append_args'}0 clause on 'omp declare variant' directive"
HED7B3D66D419: "'omp declare variant'ディレクティブに%select{'match'|'match', 'adjust_args',または'append_args'}0句が期待されます"
# "expected %select{'val' modifier|one of 'ref', val' or 'uval' modifiers}0"
HCC26F8F297FB: "%select{'val'修飾子|'ref', 'val',または'uval'修飾子のいずれか}0が期待されます"
# 'expected %select{assignment|assignment, compound assignment, increment, or decrement}0 expression'
H2BC7EE32B904: '%select{代入式|代入,複合代入,インクリメント,またはデクリメント}0式が期待されます'
# "expected %select{identifier after '.' in |}0module name"
HF095089F6D4D: '%select{.以降の識別子|}0モジュール名が期待されます'
# 'expected %select{identifier|unqualified-id}0'
HC1969BE019B7: '%select{識別子|未修飾識別子}0が期待されます'
# 'expected %select{library|framework}0 name as a string'
H5FD987168935: '文字列として%select{ライブラリ|フレームワーク}0名が期待されます'
# "expected %select{module exclusion with 'exclude'|'export *'}0"
H4175E9BAE37D: "%select{'exclude'によるモジュール除外|'export *'}0が期待されます"
# "expected '#pragma omp end declare %select{target|variant}0'"
H7B3C6216417A: '#pragma omp end declare %select{target|variant}0を期待しました'
# "expected '#pragma omp end declare target' at end of file to match '#pragma omp %0'"
H25BEC71CAA92: "ファイル末尾で'#pragma omp %0'に対応する'#pragma omp end declare target'が見つかりませんでした"
# "expected '#pragma unused' argument to be a variable name"
HE4429A749432: "'#pragma unused'引数は変数名である必要があります"
# "expected '%0' after the %1; '%0' assumed"
HB08F71D9B939: "%1の後に'%0'が期待されました; '%0'を仮定しました"
# "expected '%0' clause with an argument on '#pragma omp %1' construct"
HA803E7993B4F: "'#pragma omp %1'構造に引数付き'%0'句が期待されます"
# "expected '(' after '%0'"
HA365863454FD: "'%0'の後に'('が期待されました"
# "expected '(' for function-style cast or type construction"
H95D0E6661AB2: "関数スタイルキャストまたは型構築のための'('が期待されます"
# "expected ')' after '%0'"
H068274655B04: "'%0'の後に')'が期待されました"
# "expected ')' in preprocessor expression"
H9FA29BAED1EF: "プリプロセッサ式で ')' が必要です"
# "expected ')' or ',' after '%0'"
HD115318388CA: "'%0' 後に ')' または ',' が必要です"
# "expected ')' or ',' in '#pragma %0'"
H97FBD869E75F: "'#pragma %0' 内で ')' または ',' が必要です"
# "expected '+' or '-' operation"
H193C159A95C7: "'+' または '-' 演算子が必要です"
# "expected ',' after conflicting module name"
H307B5FE6EEA1: "競合するモジュール名の後に ',' が必要です"
# "expected ',' after interop modifier"
HBE15766F267C: "interop修飾子の後に ',' が必要です"
# "expected ',' in '#pragma %0'"
H80B3D004C35A: "'#pragma %0' 内で ',' が必要です"
# "expected ',' or ')' after iterator specifier"
H5B885E53A966: "イテレータ指定子の後に ',' または ')' が必要です"
# "expected ',' or ')' at end of property accessor list"
H90761748BDB7: "プロパティアクセスリストの末尾で ',' または ')' が必要です"
# "expected ',' or ')' in '%0' %select{clause|directive}1"
H27E43F9D4E4C: "'%0' %select{clause|directive}1 内で ',' または ')' が必要です"
# "expected ',' or '>' in template-parameter-list"
HE6FA48C9A81A: "テンプレートパラメータリスト内で ',' または '>' が必要です"
# "expected ',' or ']' in lambda capture list"
H01C14BB9E6E5: "ラムダキャプチャリスト内で ',' または ']' が必要です"
# "expected '->' before expression type requirement"
H25053402E92B: "式の型要件の前に '->' が必要です"
# "expected '.' after pragma attribute namespace %0"
H6D0DBF9112AD: "pragma属性名前空間 %0 後に '.' が必要です"
# "expected '::' after '__super'"
HFBD8EE4CC424: "'__super' 後に '::' が必要です"
# "expected ';' after %0 statement"
H26F61B7787AD: "%0 文の後に ';' が必要です"
# "expected ';' after '%0'"
HC22BB7A01636: "'%0' 後に ';' が必要です"
# "expected ';' after attribute list"
HC367299E9BFD: "属性リストの後に ';' が必要です"
# "expected ';' after expression"
H26209FD52998: "式の後に ';' が必要です"
# "expected ';' after method prototype"
H4DCD5C7E2BCB: "メソッドプロトタイプの後に ';' が必要です"
# "expected ';' after module name"
H20B27913626E: "モジュール名の後に';'が期待されました"
# "expected ';' after namespace name"
HAAD5C65924B6: "namespace名の後に';'が期待されました"
# "expected ';' after private module fragment declaration"
H868380AB5A37: "privateモジュールフラグメント宣言の後に';'が期待されました"
# "expected ';' after top level declarator"
H3A247DA7CE56: "トップレベル宣言子の後に';'が期待されました"
# "expected ';' at end of declaration"
HA8E976B320DC: "宣言の末尾で';'が期待されました"
# "expected ';' at end of declaration list"
HA684210D419F: "宣言リストの末尾で';'が期待されました"
# "expected ';' at end of requirement"
HDCCCFEC70AB1: "リクエアメントの末尾で';'が期待されました"
# "expected ';' in 'for' statement specifier"
H2C47358FD75D: "'for'ステートメント指定子中に';'が期待されました"
# "expected '<' after '%0'"
H1010291C9C7B: "'%0'の後に'<'が期待されました"
# "expected '= constant-expression' or end of enumerator definition"
H01AC9A3D13F6: "'= constant-expression'または列挙子定義の末尾が期待されました"
# "expected '=' after '%0'"
H46EA9025A033: "'%0'の後に'='が期待されました"
# "expected '=' after diagnostic option"
HEF7733E47109: "診断オプションの後に'='が期待されました"
# "expected '=' following '#pragma %select{align|options align}0' - ignored"
HCE08A9B54E2F: "'#pragma %select{align|options align}0'の後に'='が期待されました - 無視されました"
# "expected '=' following '#pragma clang section %select{invalid|bss|data|rodata|text|relro}0'"
H5BC8FFE8057E: "'#pragma clang section %select{invalid|bss|data|rodata|text|relro}0'の後に'='が期待されました"
# "expected '=' for Objective-C getter"
H60371309B60A: "Objective-Cのgetterに'='が期待されました"
# "expected '=' for Objective-C setter"
H8ACB8C307A32: "Objective-Cのsetterに'='が期待されました"
# "expected '=' in iterator specifier"
H160A5CC58E68: "イテレータ指定子中に'='が期待されました"
# "expected '=' or another designator"
H0EFFC0B249A7: "'='または別の指定子が期待されました"
# "expected '==' operator for 'weak' clause"
H3CB2580D57FE: "'weak'句における'=='オペレーターが期待されました"
# "expected 'ON' or 'OFF' or 'DEFAULT' in pragma"
HE0167BADEC73: "pragma内の'ON'または'OFF'または'DEFAULT'が期待されました"
# "expected ']' to close attribute"
H21FBE19AC5CE: "属性を閉じるために']'が期待されました"
# "expected '__except' or '__finally' block"
HF5A94EBD6434: "'__except'または'__finally'ブロックが期待されました"
# "expected 'align' following '#pragma options' - ignored"
H851698FD662C: "'#pragma options'の後に'align'が期待されました - 無視されました"
# "expected 'auto' or 'decltype(auto)' after concept name"
H0C6E25C16A3C: "コンセプト名の後に'auto'または'decltype(auto)'が期待されました"
# "expected 'begin' or 'end'"
HE7122B95D2E3: "'begin'または'end'が期待されました"
# "expected 'bind' clause for 'loop' construct without an enclosing OpenMP construct"
H5C3B8520C88C: "'loop'構造体（囲むOpenMP構造体がない場合）の'bind'句が期待されました"
# "expected 'case' keyword before expression"
H2E3235608C64: "式の前に'case'キーワードが期待されました"
# "expected 'compare' clause with the '%0' modifier"
H19AACB74DA99: "'%0'修飾子と共に'compare'句が期待されました"
# "expected 'compiler', 'lib', 'user', or a string literal for the section name in '#pragma %0' - ignored"
H516A6D363B4D: "'#pragma %0'のセクション名として'compiler'、'lib'、'user'、または文字列リテラルが期待されました - 無視されました"
# "expected 'get' or 'put' in property declaration"
HB1588A447E94: "プロパティ宣言中に'get'または'put'が期待されました"
# "expected 'introduced', 'deprecated', or 'obsoleted'"
HA5AD3805D7B0: "'introduced'、'deprecated'、または'obsoleted'が期待されました"
# "expected 'language', 'defined_in', 'generated_declaration', or 'USR'"
HC6089B1E2A7C: "'language'、'defined_in'、'generated_declaration'、または'USR'が期待されました"
# "expected 'push', 'pop', or '(' after '#pragma clang attribute'"
H6F226585166A: "'#pragma clang attribute'の後に'push'、'pop'、または'('が期待されました"
# "expected 'reduction' clause with the 'inscan' modifier"
H2220AF809CD1: "'inscan'修飾子と共に'reduction'句が期待されました"
# "expected 'this' following '*' in lambda capture list"
HAD95524E40D1: "ラムダキャプチャリストの'*'の後に'this'が期待されました"
# "expected 'this' subscript expression on map clause to be 'this[0]'"
HC4A77B8603BE: "map句のサブスクリプト式として'this[0]'が期待されました"
# "expected 'volatile', 'inline', 'goto', or '('"
H4AA4A0DEF946: "'volatile'、'inline'、'goto'、または'('が期待されました"
# "expected 'while' in do/while loop"
H93A6CFE12887: "do/whileループ中に'while'が期待されました"
# "expected '{' after '\\%0' escape sequence"
H8BB332D21D67: "'\\%0'エスケープシーケンスの後に'{'が期待されました"
# "expected '{' after base class list"
HF135F437918B: "基底クラスリストの後に'{'が期待されました"
# "expected '{' in compound literal"
H19B6D0E23043: "複合リテラルで '{' が期待されました"
# "expected '{' to start inferred submodule"
H195C51C6292B: "推論されたサブモジュールを開始するために '{' が必要です"
# "expected '{' to start module '%0'"
H68A4A0E12840: "モジュール '%0' を開始するために '{' が必要です"
# "expected '}'"
HC6CF963022AD: "'}' が必要です"
# 'expected HLSL Semantic identifier'
H26323C15C7D3: 'HLSL Semantic識別子が必要です'
# 'expected OpenACC directive'
HC6E13DDCDF20: 'OpenACCディレクティブが必要です'
# "expected a 'float', 'double' or '__float128' for the first argument"
H4A7F993B766C: "最初の引数に 'float'、'double'、または '__float128' が期待されます"
# 'expected a callable expression as %ordinal0 argument to %1, found %2'
H9D110F1CBE18: '%1の%ordinal0引数として呼び出し可能な式が期待されましたが、%2が見つかりました'
# 'expected a clang compiler command'
HFF7E5AC24A63: 'clangコンパイラのコマンドが必要です'
# "expected a class method selector with single argument, e.g., 'colorWithCGColor:'"
H747F5E4807D4: "単一引数のクラスメソッドセレクタが必要です。例: 'colorWithCGColor:'"
# "expected a class name after '~' to name a destructor"
H0B5DBF4FC4A5: "デストラクタを名付けるために '~' の後にクラス名が必要です"
# 'expected a feature name'
H83F9EEF32768: '機能名が必要です'
# "expected a field designator, such as '.field = 4'"
HE811DCDC9E5C: "フィールド指定子（例: '.field = 4'）が必要です"
# 'expected a foldable binary operator in fold expression'
H442801240371: 'フォールド式内で折り畳める二項演算子が必要です'
# "expected a for, while, or do-while loop to follow '%0'"
H6905E348753C: "'%0' の後に for、while、または do-while ループが続く必要があります"
# "expected a header attribute name ('size' or 'mtime')"
H7FCC0389B837: "ヘッダ属性名（'size' または 'mtime'）が必要です"
# "expected a header name after '%0'"
HC5548A9AEA32: "'%0' の後にヘッダ名が必要です"
# 'expected a memory order clause'
H8A1509342CF4: 'メモリオーダー句が必要です'
# "expected a message describing the conflict with '%0'"
H3712B62CAC8D: "'%0' との競合を説明するメッセージが必要です"
# 'expected a module map file name'
H34A1748EFBBA: 'モジュールマップファイル名が必要です'
# "expected a module name after '%select{module|import}0'"
H60B4E74C4DAA: "'%select{module|import}0'の後にモジュール名が必要です"
# "expected a module name in '__building_module' expression"
H3E7D4309A80A: "'__building_module'式にはモジュール名が必要です"
# "expected a module name or '*'"
HA872E74CF2C8: "モジュール名または'*'が必要です"
# 'expected a platform name here'
HB3E385166F04: 'ここにはプラットフォーム名が必要です'
# "expected a platform name, e.g., 'macos'"
H451496142CA8: "プラットフォーム名が必要です。例: 'macos'"
# 'expected a property name in @synthesize'
HFCD01091BCD1: '@synthesize内でプロパティ名が必要です'
# "expected a qualified name after 'typename'"
H3D60DB7C4A2E: "'typename'の後に修飾名が必要です"
# "expected a reference to a parameter specified in a 'uniform' clause"
HE4C3AD103D8E: "'uniform'句で指定されたパラメータへの参照が必要です"
# 'expected a reference to an integer-typed parameter'
HD574D7423FC7: '整数型のパラメータへの参照が必要です'
# "expected a related Objective-C class name, e.g., 'NSColor'"
H1B15D42F8530: "関連するObjective-Cクラス名が必要です。例: 'NSColor'"
# "expected a stack label or a string literal for the section name in '#pragma %0' - ignored"
HC98188AB663C: "'#pragma %0'でのセクション名にはスタックラベルまたは文字列リテラルが必要です - 無視されました"
# "expected a string literal for the section name in '#pragma %0' - ignored"
HE785ABE9BD3E: "'#pragma %0'でのセクション名には文字列リテラルが必要です - 無視されました"
# 'expected a type'
HBF18848DB5D9: '型が必要です'
# "expected a version of the form 'major[.minor[.subminor]]'"
HD227DA64159B: "'major[.minor[.subminor]]'という形式のバージョンが必要です"
# 'expected access to data field'
HB984B4DED1F3: 'データフィールドへのアクセスが必要です'
# "expected action or ')' in '#pragma %0' - ignored"
HA826DA8C7E15: "'#pragma %0'内でアクションまたは')'が必要です - 無視されました"
# "expected addressable lvalue expression, array element%select{ or array section|, array section or array shaping expression}0%select{| of non 'omp_depend_t' type}1"
H064E98F2C05F: "アドレス可能なlvalue式、配列要素%select{または配列セクション|、配列セクションまたは配列形成式}0%select{|非'omp_depend_t'型の}1が必要です"
# "expected addressable lvalue in '%0' clause"
H5CFFB735C83B: "'%0'句内でアドレス可能なlvalueが必要です"
# 'expected addressable reduction item for the task-based directives'
H317F6E6ED5F4: 'タスクベースのディレクティブ用のアドレス可能な削減項目が必要です'
# "expected an 'allocator' clause inside of the target region; provide an 'allocator' clause or use 'requires' directive with the 'dynamic_allocators' clause"
H22C155652414: "ターゲット領域内の'allocator'句を指定してください；'allocator'句を指定するか、'requires'句と共に'dynamic_allocators'句を使用してください"
# "expected an Objective-C directive after '@'"
H89CC9A1752F3: '@の後にObjective-Cディレクティブが期待されました'
# "expected an OpenMP 'directive' or 'sequence' attribute argument"
HB4C47A9C1389: "OpenMPの'directive'または'sequence'属性引数が期待されました"
# 'expected an OpenMP directive'
H633B99B897DC: 'OpenMPディレクティブが期待されました'
# "expected an allocator expression inside of the target region; provide an allocator expression or use 'requires' directive with the 'dynamic_allocators' clause"
H3E40EF451DD7: "ターゲット領域内の動的割り当て式が見つかりません。allocator式を指定するか、'requires'ディレクティブで'dynamic_allocators'句を使用してください"
# "expected an attribute after '('"
H1D3F08841FED: "'('の後に属性が期待されました"
# 'expected an attribute name'
HD93294E62460: '属性名が期待されます'
# "expected an attribute that is specified using the GNU, C++11 or '__declspec' syntax"
H022D0FCF0401: "GNU、C++11または'__declspec'構文で指定される属性が必要です"
# "expected an environment name, e.g., 'compute'"
HFC224EAC2A19: "環境名（例:'compute'）が期待されます"
# "expected an identifier or template-id after '::'"
H640FB5DADE2C: "'::'の後に識別子またはテンプレート識別子が期待されます"
# "expected an identifier that corresponds to an attribute subject matcher sub-rule; '%0' matcher %select{does not support sub-rules|supports the following sub-rules: %2|}1"
H9C057C572CE2: '%0 マッチャー %select{サブルールをサポートしていません|以下のサブルールをサポートします: %2|}1 に対応する属性対象マッチャーが期待されます'
# 'expected an identifier that corresponds to an attribute subject rule'
H294E4D252009: '属性対象ルールに該当する識別子が期待されます'
# "expected an integer argument in '#pragma %0'"
H8B88B2FBB6B4: "'#pragma %0'の整数引数が期待されます"
# "expected an integer or a pointer type of the outer loop counter '%0' for non-rectangular nests"
H7B769AB4785B: "非矩形ネストの外側ループカウンタ'%0'には整数またはポインタ型が必要です"
# "expected at least one %0 clause for '#pragma omp %1'"
H7235197EF029: "'#pragma omp %1'には少なくとも1つの%0句が必要です"
# "expected at least one %select{'enter' or 'link'|'enter', 'link' or 'indirect'}0 clause"
H068B5F15FD0D: "%select{'enter'または'link'|'enter'、'link'または'indirect'}0句が少なくとも1つ必要です"
# "expected at least one %select{'to' or 'link'|'to', 'link' or 'indirect'}0 clause"
HCCB831884601: "%select{'to'または'link'|'to'、'link'または'indirect'}0句が少なくとも1つ必要です"
# "expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'"
HD1F834BB93F7: "'#pragma omp target update'に'to'句または'from'句が指定されていません"
# "expected at least one clause on '#pragma omp %0' directive"
HF2F95AA7B57B: "'#pragma omp %0'ディレクティブに少なくとも1つの句が必要です"
# "expected attribute subject set specifier 'apply_to'"
H235FBF52B9D6: "属性対象セット指定子'apply_to'がありません"
# 'expected binary operation on right hand side of assignment operator'
H56333C6C1143: '代入演算子の右辺に二項演算が期待されました'
# 'expected body of lambda expression'
HD20C4511EEC4: 'ラムダ式の本文が期待されました'
# "expected canonical name for private module '%0'"
H1D8AC0E6D7DF: "プライベートモジュール '%0' の標準名が期待されました"
# 'expected catch'
H0CF63E912EE1: 'catch が期待されました'
# 'expected class member or base class name'
H3D5CC6CC3E58: 'クラスメンバーまたはベースクラスの名前が期待されました'
# 'expected class name'
HE76725D4157E: 'クラス名が期待されました'
# 'expected clause-list or newline in OpenACC directive'
H545847ADF7FD: 'OpenACC ディレクティブで句リストまたは改行が期待されました'
# 'expected comma in macro parameter list'
HDA341FE611DA: 'マクロパラメータリストでコンマが期待されました'
# 'expected concept name with optional arguments'
H5D07B2CBA3F4: 'オプションの引数を伴う概念名が期待されました'
# "expected configuration macro name after ','"
HAB95DA27DF2F: 'コンマ後の構成マクロ名が期待されました'
# "expected constant sized array of 'omp_alloctrait_t' elements, not %0"
H05FAEDD71E4D: "'omp_alloctrait_t' 要素の定数サイズの配列が期待されましたが、%0 ではありませんでした"
# "expected declarator on 'omp declare mapper' directive"
HB22F9750894D: "'omp declare mapper' ディレクティブで宣言子が期待されました"
# 'expected depobj expression'
HE3D01E0D4DF5: 'depobj 式が期待されました'
# 'expected end of directive in pragma'
HCC93595992BD: 'pragma 内でディレクティブの終端が期待されました'
# 'expected end of line in preprocessor expression'
HD41DF7404CF0: 'プリプロセッサ式で行末が期待されました'
# 'expected excluded module name'
H6CF70735EF8C: '除外モジュールの名前が期待されました'
# 'expected expression'
HF6BF3F627CA1: '式が期待されました'
# 'expected expression containing only member accesses and/or array sections based on named variables'
HB19E72D8D293: '名前付き変数に基づくメンバーアクセスと/または配列セクションのみを含む式が期待されました'
# 'expected expression with a pointer to a complete type as a base of an array shaping operation'
HB89169C408E0: '配列整形操作の基底として完全な型へのポインタを持つ式が期待されました'
# 'expected external declaration'
HC14A3D6A28C9: '外部宣言が期待されました'
# 'expected function body after function declarator'
HF961A21CDC61: '関数宣言子の後に関数本体が期待されます'
# "expected function or lambda declaration for 'routine' construct"
H6E72FAB495F6: '「routine」構造体の関数またはlambda宣言が期待されます'
# "expected identifier in '#pragma %0' - ignored"
H05B1FBF9EBC9: 'pragma %0 の中の識別子が期待されませんでした - 無視されました'
# 'expected identifier in macro parameter list'
H94E463CD5EE5: 'マクロパラメータリスト中の識別子が期待されました'
# "expected identifier or one of the following operators: '+', '-', '*', '&', '|', '^', '&&', or '||'"
H7E170CC2FF20: "識別子または次のオペレーターのいずれかが期待されます: '+', '-', '*', '&', '|', '^', '&&', または '||'"
# 'expected identifier or string literal'
H0AF1E0FEC1A8: '識別子または文字列リテラルが期待されます'
# 'expected identifier or string literal describing a context %select{set|selector|property}0; %select{set|selector|property}0 skipped'
HE89AF4D1E70E: 'コンテキスト %select{set|selector|property}0 を説明する識別子または文字列リテラルが期待されます; %select{set|selector|property}0 はスキップされました'
# "expected identifier specifying the name of the 'omp critical' directive"
HDAF324FC0746: "'omp critical' ディレクティブの名前を指定する識別子が期待されます"
# 'expected identifier that represents an attribute name'
H4FF5B028471D: '属性名を表す識別子が期待されました'
# 'expected initializer'
HC06E564F6549: '初期化子が期待されます'
# "expected integer between %0 and %1 inclusive in '#pragma %2' - ignored"
HD3B45551DCCD: "%0 から %1 の整数が '#pragma %2' で期待されました - 無視されました"
# "expected integer literal as value for header attribute '%0'"
H664A6DF4E15C: "ヘッダ属性 '%0' の値として整数リテラルが期待されました"
# "expected integer or identifier in '#pragma pack' - ignored"
H76DF3F452A3B: "整数または識別子が '#pragma pack' で期待されました - 無視されました"
# 'expected integral or pointer type as the iterator-type, not %0'
H630D7FF60D9F: 'iterator-type として整数型またはポインタ型が期待されましたが、%0 が指定されました'
# "expected interop type: 'target' and/or 'targetsync'"
H4B471B15641F: "インターロップ型 'target' と/または 'targetsync' が期待されます"
# 'expected iterator specification as depend modifier'
HDCFF4384248D: 'depend モディファイアーとしてイテレータ仕様が期待されます'
# 'expected iterator specification as map modifier'
H1207336B4021: 'map モディファイアーとしてイテレータ仕様が期待されます'
# "expected length on mapping of 'this' array section expression to be '1'"
HAB830A5B0BE8: "'this' 配列セクション式のマッピングにおける長さが '1' である必要があります"
# "expected list item of scalar type in 'lastprivate' clause with 'conditional' modifier"
HA9ADDE114CE9: "'conditional' モディファイアー付き 'lastprivate' クラウス中のリスト項目がスカラ型である必要があります"
# 'expected loop invariant expression'
H5CDAE0534BDA: 'ループ不変式が期待されます'
# "expected loop invariant expression or '<invariant1> * %0 + <invariant2>' kind of expression"
HB9C142C1B0A5: "ループ不変式式、または '<invariant1> * %0 + <invariant2>' 形式の式が期待されます"
# "expected lower bound on mapping of 'this' array section expression to be '0' or not specified"
H191C7ACE16C2: "'this' 配列セクション式のマッピングの下限が '0' か未指定である必要があります"
# "expected lvalue expression%select{ of 'omp_depend_t' type, not %1|}0"
H766F59D547C6: "lvalue式が%select{必要です。'omp_depend_t'型でない%1|}0"
# "expected member name or ';' after declaration specifiers"
HB82CEE80D58C: "宣言仕様子の後にメンバー名か ';' が必要です"
# "expected member name or ';' after declaration specifiers; %0 is a keyword in Objective-C++"
H44CFB0200081: "宣言仕様子の後にメンバー名か ';' が必要です; %0 は Objective-C++ でのキーワードです"
# 'expected method body'
HA77E865AEFEF: 'メソッド本文が期待されます'
# 'expected method to %select{read|write}1 %select{dictionary|array}2 element not found on object of type %0'
H7AD9AA6CC51A: '型 %0 のオブジェクトに %select{読み取り|書き込み}1 %select{辞書|配列}2 要素を処理するメソッドが見つかりません'
# "expected modifier in '%0' clause"
HCD7B280DF3B2: "句 '%0' 内で修飾子が期待されます"
# 'expected module declaration'
H01C99835EAB8: 'モジュール宣言が必要です'
# 'expected module name'
H1C43BA17D195: 'モジュール名が必要です'
# 'expected name of accessor method'
HC25216EA2EAE: 'アクセサメソッドの名前が必要です'
# 'expected namespace name'
H4C29A4057DC9: '名前空間名が必要です'
# "expected non-wide string literal in '#pragma %0'"
H47A50F5F135C: "'#pragma %0' 内でワイド文字列リテラル以外の文字列リテラルが期待されます"
# "expected one of [bss|data|rodata|text|relro] section kind in '#pragma %0'"
HD85488A58A29: "'#pragma %0' 内で [bss|data|rodata|text|relro] のいずれかのセクション種別が指定されていません"
# "expected one of the predefined allocators for the variables with the static storage: 'omp_default_mem_alloc', 'omp_large_cap_mem_alloc', 'omp_const_mem_alloc', 'omp_high_bw_mem_alloc', 'omp_low_lat_mem_alloc', 'omp_cgroup_mem_alloc', 'omp_pteam_mem_alloc' or 'omp_thread_mem_alloc'"
H8611A8451129: "静的ストレージを持つ変数用のプリファイネッド割り当て関数のいずれかが指定されていません。指定可能なのは 'omp_default_mem_alloc', 'omp_large_cap_mem_alloc', 'omp_const_mem_alloc', 'omp_high_bw_mem_alloc', 'omp_low_lat_mem_alloc', 'omp_cgroup_mem_alloc', 'omp_pteam_mem_alloc', または 'omp_thread_mem_alloc' です"
# 'expected parameter declarator'
HE400FE627646: 'パラメータ宣言子が必要です'
# 'expected parentheses around type name in %0 expression'
H29C3C3BEE053: '%0 式内では型名の周囲に括弧が必要です'
# "expected parenthesized parameter pack name in 'sizeof...' expression"
H872448706A49: "'sizeof...' 式内ではパラメータパック名の括弧が必要です"
# "expected pointer in '%0' clause, type is %1"
HA28C1D2864FB: "句 '%0' 内ではポインタが期待されますが、型 %1 が指定されました"
# "expected pointer or reference to pointer in 'use_device_ptr' clause"
H8CE170DA7DFD: "'use_device_ptr' 句内ではポインタまたはポインタへの参照が指定されなければなりません"
# 'expected pointer to struct as %ordinal0 argument to %1, found %2'
H2E1D0CCC5B02: '構造体型へのポインタが%1の%ordinal0引数として必要ですが、%2が見つかりました'
# "expected pointer, array, reference to pointer, or reference to array in 'is_device_ptr clause'"
H529E9DB350DF: "ポインタ、配列、ポインタへの参照、または配列への参照が'is_device_ptr句'で必要です"
# 'expected property name'
H849B19CD5A49: 'プロパティ名が必要です'
# "expected push, pop or a string literal for the section name in '#pragma %0' - ignored"
H4F1921BA3641: "'#pragma %0'のセクション名としてpush、pop、または文字列リテラルが期待されましたが、無視されました"
# 'expected quoted string after equals sign'
H2D60229D01D0: '等号後の引用符で囲まれた文字列が期待されました'
# "expected reference to one of the parameters of function %0%select{| or 'this'}1"
HD78611AD5D12: "関数%0のパラメータのいずれかへの参照が%select{|または'this'}1必要です"
# 'expected selector for Objective-C %select{setter|getter}0'
HFB2F00048645: 'Objective-Cの%select{setter|getter}0メソッドのセレクタが必要です'
# 'expected selector for Objective-C method'
HC4CCDD47D676: 'Objective-Cメソッドのセレクタが必要です'
# 'expected statement'
HFEEF58AA5565: 'ステートメントが必要です'
# "expected string literal %select{in %1|for diagnostic message in static_assert|for optional message in 'availability' attribute|for %select{language name|source container name|USR}1 in 'external_source_symbol' attribute|as argument of '%1' attribute}0"
HD61709E5D47F: "文字列リテラルが%select{必要です。%1内|'static_assert'の診断メッセージ用|'availability'属性のオプションメッセージ用|'external_source_symbol'属性の%select{言語名|ソースコンテナ名|USR}1用|'%1'属性の引数として}0"
# "expected string literal %select{or parenthesized constant expression |}0in 'asm'"
H87FD9C867F0C: 'アセンブリ文の文字列リテラル%select{または括弧で囲まれた定数式|}0が期待されました'
# "expected string literal in '#pragma %0' - ignoring"
H0A31A7BE2E40: "'#pragma %0'内の文字列リテラルが期待されましたが、無視されました"
# "expected string literal in 'clause %0' - ignoring"
H25BCA649E0CB: '句%0内の文字列リテラルが期待されましたが、無視されました'
# 'expected template'
H15B15916EEBA: 'テンプレートが必要です'
# "expected template name after 'template' keyword in nested name specifier"
H49E8E5AAE6BB: "ネスト名指定子の'template'キーワードの後にテンプレート名が必要です"
# 'expected template parameter'
H112129FF4EB6: 'テンプレートパラメータが必要です'
# "expected the class name after '~' to name the enclosing class"
HD0B1F9262E8D: "'~'の後に外側のクラス名が必要です"
# 'expected the name of a parameter pack'
H259207509382: 'パラメータパックの名前が必要です'
# 'expected type parameter name'
H009E83554F48: '型パラメータ名が必要です'
# 'expected umbrella, header, submodule, or module export'
H13F866613F7D: 'umbrella、header、submodule、またはmodule exportが予期されました'
# 'expected valid context selector in %0'
HF9402AD88CE1: '%0 内で有効なコンテキストセレクタが予期されました'
# 'expected value in expression'
HC052EF0BAA44: '式の値が予期されました'
# 'expected variable name as a base of the array %select{subscript|section}0'
HBE410C345F41: '配列 %select{サブスクリプト|セクション}0 の基底として変数名が予期されました'
# "expected variable name or 'this' in lambda capture list"
H9A94F049DF94: 'lambda キャプチャリストで this や変数名が予期されました'
# 'expected variable name%select{| or data member of current class}0'
H829F4F463842: '現在のクラスのデータメンバ%select{または|}0 を持つ変数名が予期されました'
# 'expected variable name%select{|, data member of current class}0, array element or array section'
HEAE159C816D1: '現在のクラスの静的データメンバまたは非静的データメンバ%select{、または|}0 配列要素または配列セクションが予期されました'
# 'expected variable of pointer type'
H396A94544855: 'ポインタ型の変数が予期されました'
# "expected variable of the '%0' type%select{|, not %2}1"
H3293A68C1535: '%0 タイプ%select{、または|}1 %2 ではなく、変数が予期されました'
# "expected variable%select{| or static data member|, static data member, or non-static data member of current class}0 of type '%1'"
H54FC8A6038F8: "現在のクラスの静的メンバ変数%select{|または静的メンバ変数|, 静的メンバ変数、または非静的メンバ変数}0型'%1'の変数が期待されます"
# 'expected%select{| %1}0 loop iteration variable'
H9F489F0C181E: '%select{ループ反復変数| %1 ループ反復変数}0 が予期されました'
# "expected%select{| non-const}0 variable of type 'omp_interop_t'"
H7FA31289BDF2: '%select{非定数|}0 型の omp_interop_t 変数が予期されました'
# 'expected%select{| one of}0 %1 directive name modifier%select{|s}0'
HF9EF92E2746A: '%select{のいずれかの|}0 %1 ディレクティブ名修飾子%select{が|}0 予期されました'
# "expecting %0 '%1' to be held at start of each loop"
HFDC07BD9FDE6: '各ループの開始時に %0 %1 を保持することが必要です'
# "expecting %0 '%1' to be held at the end of function"
H696ED076811B: '関数の終了時に %0 %1 を保持することが必要です'
# 'explicit %select{constructor|conversion function|deduction guide}0 is not a candidate%select{| (explicit specifier evaluates to true)}1'
H1B61513FD8B6: '明示的な%select{コンストラクタ|変換関数|推論ガイド}0は候補ではありません%select{| (explicit修飾子がtrueを評価する)}1'
# 'explicit %select{constructor|deduction guide}0 declared here'
H110462FEE829: '明示的 %select{コンストラクタ|推論ガイド}0 はここで宣言されています'
# 'explicit %select{specialization|instantiation}0 of %select{non-|undeclared }3template %1 %2'
H3111D59957AC: '%select{非|未宣言 }3 テンプレート %1 %2 の %select{明示的特殊化|明示的インスタンス化}0'
# 'explicit call to +initialize results in duplicate call to +initialize'
H39AD5352EF13: '+initialize の明示的呼び出しにより、+initialize の重複呼び出しが発生します'
# 'explicit call to [super initialize] should only be in implementation of +initialize'
H9E99F53BFF8C: '[super initialize] の明示的呼び出しは +initialize の実装内でのみ使用可能です'
# "explicit capture of 'this' with a capture default of '=' is a C++20 extension"
HAF0F203BEF2F: "'='のキャプチャデフォルトを持つthisの明示的キャプチャはC++20拡張機能です"
# "explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++20"
H671AAB21DB7A: "'='のキャプチャデフォルトを持つthisの明示的キャプチャはC++20以前の標準と互換性ありません"
# 'explicit constructor calls are a Microsoft extension'
H07E486E825A8: '明示的なコンストラクタ呼び出しはMicrosoft拡張機能です'
# 'explicit conversion functions are a C++11 extension'
H6D402C6A81B4: '明示的な変換関数はC++11拡張機能です'
# 'explicit conversion functions are incompatible with C++98'
H325DB8CE82A7: '明示的な変換関数はC++98と互換性ありません'
# 'explicit data sharing attribute requested here'
HC278594BF276: 'ここで明示的なデータ共有属性が指定されました'
# 'explicit data sharing attribute, data mapping attribute, or is_device_ptr clause requested here'
H5EF926721360: 'ここで明示的なデータ共有属性、データマッピング属性、またはis_device_ptr句が指定されました'
# 'explicit initialization of field %1 will not be enforced in C++20 and later because %2 has a user-declared constructor, making the type no longer an aggregate'
HF3AC30340626: "'%2'がユーザー定義コンストラクタを持つため、集約型不再是るためC++20以降ではフィールド%1の明示的初期化は強制されなくなります"
# 'explicit instantiation candidate function %q0 template here %1'
H23B5BDCD19CC: 'テンプレートここ%1で明示的インスタンス化候補関数%q0'
# "explicit instantiation cannot be 'constexpr'"
H9A1E5AE786E4: "明示的インスタンス化は'constexpr'であってはなりません"
# "explicit instantiation cannot be 'inline'"
HD5DCEA693BA1: "明示的インスタンス化は'inline'であってはなりません"
# 'explicit instantiation cannot have a storage class'
H2C3AA857F69D: '明示的インスタンス化にはストレージクラスを指定できません'
# "explicit instantiation declaration (with 'extern') follows explicit instantiation definition (without 'extern')"
HB1AC2FFED2CF: "'extern'付き明示的インスタンス化宣言が'extern'なしの明示的インスタンス化定義に続きました"
# 'explicit instantiation declaration of %0 with internal linkage'
HF062EFD01A1B: "'%0'の内部リンケージを持つ明示的インスタンス化宣言"
# 'explicit instantiation declaration requires a name'
HB6C2B5BBA7F4: '明示的インスタンス化宣言には名前が必要です'
# "explicit instantiation declaration should not be 'dllexport'"
H2015D0FC9EDD: "'dllexport'を明示的インスタンス化宣言には付けてはなりません"
# 'explicit instantiation definition is here'
H296BCB0F591A: '明示的インスタンス化定義はここです'
# 'explicit instantiation has dependent template arguments'
H0CCD42687978: '明示的インスタンス化には依存テンプレート引数が含まれています'
# 'explicit instantiation of %0 does not refer to a function template, variable template, member function, member class, or static data member'
H33CB49EB02C6: '%0の明示的インスタンス化は、関数テンプレート、変数テンプレート、メンバ関数、メンバクラス、または静的データメンバを指しません'
# 'explicit instantiation of %0 in class scope'
HC730DBDD7AE4: '%0のクラススコープ内の明示的インスタンス化'
# 'explicit instantiation of %0 must occur at global scope'
H0F240F08C055: '%0の明示的インスタンス化はグローバルスコープで発生する必要があります'
# 'explicit instantiation of %0 not in a namespace enclosing %1'
HE49D377AF72F: '%0の明示的インスタンス化は、%1を包含する名前空間外に存在します'
# 'explicit instantiation of %0 that occurs after an explicit specialization has no effect'
HB36244473793: '%0の明示的インスタンス化は、明示的な特化後に発生した場合、効果がありません'
# 'explicit instantiation of %q0 must occur in namespace %1'
HB00768729F8E: '%q0の明示的インスタンス化は、名前空間%1内で発生する必要があります'
# 'explicit instantiation of %q0 must specify a template argument list'
HE88FD9250BA0: '%q0の明示的インスタンス化には、テンプレート引数リストを指定する必要があります'
# 'explicit instantiation of non-templated type %0'
H31C2727CC2AA: '非テンプレート型%0の明示的インスタンス化'
# 'explicit instantiation of typedef %0'
H2C42F0D827C6: '%0のtypedefの明示的インスタンス化'
# 'explicit instantiation of undefined %select{member class|member function|static data member}0 %1 of class template %2'
HCF3C5A632D34: '%2のクラステンプレートの未定義%select{メンバクラス|メンバ関数|静的データメンバ}0 %1の明示的インスタンス化'
# 'explicit instantiation of undefined function template %0'
H5300C0092131: '未定義関数テンプレート%0の明示的インスタンス化'
# 'explicit instantiation of undefined variable template %q0'
H38D285C06249: '未定義変数テンプレート%q0の明示的インスタンス化'
# 'explicit instantiation refers here'
HBCDCC7E0C7EF: '明示的インスタンス化はここを指します'
# 'explicit instantiation refers to member function %q0 that is not an instantiation'
H500C2DC642A9: '%q0というインスタンス化でないメンバ関数を指しています'
# 'explicit instantiation refers to static data member %q0 that is not an instantiation'
H07ED3DC3915D: '%q0というインスタンス化でない静的データメンバを指しています'
# "explicit object parameter cannot have 'void' type"
H5DECA4F1B2FA: "'void'型の明示的オブジェクトパラメータは使用できません"
# 'explicit object parameters are incompatible with C++ standards before C++2b'
H32F147DF3434: '明示的オブジェクトパラメータはC++2b以前のC++規格と互換性がありません'
# 'explicit ownership qualifier on cast result has no effect'
H3D013C01B086: 'キャスト結果の明示的所有権修飾子は効果がありません'
# 'explicit qualification required to use member %0 from dependent base class'
H469187ADD22A: '依存基底クラスのメンバ%0を使用するには、明示的な修飾が必要です'
# 'explicit specialization cannot have a storage class'
HADDD65B5ED76: '明示的特化はストレージクラスを指定できません'
# 'explicit specialization of %0 after instantiation'
HDBBF37665EBE: 'インスタンス化後の%0の明示的な特殊化'
# 'explicit specialization of %0 in function scope'
H4AB8E368275F: '%0の関数スコープ内の明示的な特殊化'
# "explicit template instantiation cannot have a definition; if this definition is meant to be an explicit specialization, add '<>' after the 'template' keyword"
H88A1F449C08B: "明示的テンプレートインスタンス化には定義が含まれてはいけません。この定義が明示的な特殊化を意図する場合は、'template' キーワードの後に '<>' を追加してください"
# 'explicit template parameter list for lambdas is a C++20 extension'
HF9AE6F1B9252: 'ラムダに対する明示的なテンプレートパラメータリストはC++20拡張機能です'
# 'explicit template parameter list for lambdas is incompatible with C++ standards before C++20'
H57BCAF2B0340: 'ラムダに対する明示的なテンプレートパラメータリストはC++20以前のC++規格と互換性がありません'
# 'explicit(bool) is a C++20 extension'
H07C70F747BCD: 'explicit(bool)はC++20拡張機能です'
# 'explicit(bool) is incompatible with C++ standards before C++20'
H2A0E673F4AE0: 'explicit(bool)はC++20以前のC++規格と互換性がありません'
# 'explicitly assigning value of variable of type %0 to itself%select{|; did you mean to assign to member %2?}1'
HB1C6DD04C662: '型%0の変数の値を自身に明示的に代入しています%select{|;メンバー%2への代入を意図したでしょうか？}1'
# "explicitly capture 'this'"
HCF140BF35536: '明示的にthisをキャプチャしています'
# 'explicitly cast the argument to size_t to silence this warning'
HBB0D273571B1: 'この警告を抑止するには引数をsize_tに明示的にキャストしてください'
# 'explicitly cast the pointer to silence this warning'
H8E24FB4D1062: 'ポインタを明示的にキャストしてこの警告を抑止してください'
# "explicitly declare getter %objcinstance0 with '%1' to return an 'unowned' object"
H4E2F7B8127D2: "'%1'を使用して、'unowned'オブジェクトを返すゲッター%objcinstance0を明示的に宣言してください"
# 'explicitly defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator is implicitly deleted'
H811330B8F313: '明示的にデフォルト化された%select{<ERROR>|等価性|3方向|等価性|関係}0比較演算子は暗黙的に削除されました'
# 'explicitly defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 is implicitly deleted'
H4A686915F9DC: '明示的にデフォルト化された%select{デフォルトコンストラクタ|コピーコンストラクタ|ムーブコンストラクタ|コピー代入演算子|ムーブ代入演算子|デストラクタ}0は暗黙的に削除されました'
# 'explicitly defaulted function was implicitly deleted here'
HF8EF8D3E0A6F: '明示的にデフォルト化された関数はここで暗黙的に削除されました'
# 'explicitly defaulting this %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 with a type different from the implicit type is incompatible with C++ standards before C++20'
H5E5EF3FDD4E3: 'この%select{デフォルトコンストラクタ|コピーコンストラクタ|ムーブコンストラクタ|コピー代入演算子|ムーブ代入演算子|デストラクタ}0は、暗黙の型と異なる型を使用して明示的にデフォルト化されているため、C++20以前のC++規格と互換性がありません'
# 'explicitly moving variable of type %0 to itself%select{|; did you mean to move to member %2?}1'
H35CC5A2B002D: '型%0の変数を自身に明示的にムーブしています%select{|;メンバー%2へのムーブを意図したでしょうか？}1'
# 'explicitly specialized declaration is here'
H0E01C428C014: '明示的に特殊化された宣言はここにあります'
# 'explicitly-defaulted %select{copy|move}0 assignment operator must return %1'
H36FB5B74F68A: '明示的にデフォルト化された%select{コピー|ムーブ}0代入演算子は%1を返さなければなりません'
# 'exponent has no digits'
H17C521E1F810: '指数部分に桁がありません'
# 'export block begins here'
HBA4BC250A89B: 'エクスポート ブロックはここから始まります'
# 'export declaration appears within anonymous namespace'
H2CCBA9D1C7AA: 'エクスポート宣言が匿名名前空間内に出現しています'
# 'export declaration appears within another export declaration'
HECEB46AE53AF: 'エクスポート宣言が別のエクスポート宣言内に出現しています'
# 'export declaration can only be used on functions'
H2A1BE3778EEF: 'エクスポート宣言は関数にのみ使用できます'
# 'export declaration can only be used within a module purview'
HA59173758635: 'エクスポート宣言はモジュールの範囲内にのみ使用できます'
# 'export declaration cannot be empty'
H571FAB6A011E: 'エクスポート宣言は空にできません'
# 'export declaration cannot be used in a private module fragment'
H22322B0D3EA4: 'エクスポート宣言はプライベートモジュールフラグメント内で使用できません'
# 'exported templates are unsupported'
H6166D4F14CA1: 'エクスポートされたテンプレートはサポートされていません'
# 'expose the ANDI glue bug on PPC'
HC579FD8E0F1D: 'PPC上のANDI glueバグを示します'
# 'expression cannot be followed by a postfix %0 operator; add parentheses'
HBEECC801546A: '式の後ろにポストフィックス%0オペレーターを付けることはできません；括弧を追加してください'
# 'expression does not compute the number of elements in this array; element type is %0, not %1'
H23C233069DBB: 'この配列の要素数を計算する式ではありません；要素型は%0であり%1ではありません'
# "expression evaluates to '%0 %1 %2'"
H64BCD859D7BF: '式の評価結果は"%0 %1 %2"です'
# 'expression has incomplete class type %0'
H58E1F9927C3B: '式は未完全なクラス型%0を持っています'
# 'expression is not a string literal'
H3935D8B321FF: '式は文字列リテラルではありません'
# 'expression is not an %select{integer|integral}0 constant expression'
H03AFF9CF4CF8: '式は%select{整数|整数型}0の定数式ではありません'
# 'expression is not an %select{integer|integral}0 constant expression; folding it to a constant is a GNU extension'
H5CBB867EA1E8: '式は%select{整数|整数型}0の定数式ではありません；それを定数に折りたたつ機能はGNUの拡張機能です'
# 'expression is not assignable'
H5F8670A31719: '式は代入できません'
# 'expression must have integral or unscoped enumeration type, not %0'
H17B3769F086B: '式は整数型またはスコープなし列挙型でなければなりません；%0ではありません'
# 'expression not permitted as operand of fold expression'
H291A77DD522F: '式はフォールド式のオペランドとして許可されていません'
# 'expression requires explicit conversion from %0 to %1'
HB376E0297A16: '%0から%1への明示的な変換が必要です'
# 'expression result unused'
HC432FEDE1001: '式の結果が使用されていません'
# 'expression result unused; assign into a variable to force a volatile load'
HB7AF8EB968E8: '式の結果が使用されていません; 変数に代入することで volatile 読み取りを強制します'
# "expression result unused; should this cast be to 'void'?"
HBBF825FCCB8B: "このキャストは 'void' にすべきでしょうか？"
# 'expression which evaluates to zero treated as a null pointer constant of type %0'
H0240527F1E90: '0 に評価される式が型 %0 のヌルポインタ定数として扱われました'
# 'expression with side effects has no effect in an unevaluated context'
H186C82044D81: '副作用を持つ式は評価されない文脈で効果がありません'
# "expression with side effects will be evaluated despite being used as an operand to 'typeid'"
H9C60337CD3B8: "'typeid' のオペランドとして使用されているにもかかわらず、この式は評価されます"
# 'extension used'
HD363255C0A95: '拡張機能が使用されました'
# 'extern "C" language linkage specification begins here'
H7A156727F19D: 'extern "C" 言語リンケージ指定がここから始まります'
# 'extern declaration of %0 follows non-extern declaration'
HD31A31C8A91F: '非 extern 宣言に続く extern 宣言の %0'
# 'extern templates are a C++11 extension'
H1884BE10DDD8: 'extern テンプレートは C++11 拡張機能です'
# 'extern templates are incompatible with C++98'
H1796556A5B60: 'extern テンプレートは C++98 と互換性ありません'
# 'external function %0 declared with incompatible types in different translation units (%1 vs. %2)'
HE651F889FA02: '異なる翻訳単位で異なる型で外部関数 %0 を宣言 (%1 対 %2)'
# 'external variable %0 declared with incompatible types in different translation units (%1 vs. %2)'
H15B2E1B8C6FC: '異なる翻訳単位で異なる型で外部変数 %0 を宣言 (%1 対 %2)'
# 'external variable %0 defined in multiple translation units'
H1F8D107DE885: '複数の翻訳単位で外部変数 %0 が定義されています'
# "extra '&' taking address of overloaded function"
H9A83B3B4D92C: "オーバーロード関数のアドレスを取得する際に余分な '&' が含まれています"
# "extra ';' %select{outside of a function|inside a %1|inside instance variable list|after member function definition}0"
HE280E1BDB8CF: "余分な ';' %select{関数外| %1 内| インスタンス変数リスト内| メンバ関数定義の後}0"
# "extra ';' after member function definition"
H3CA5397D9B51: 'メンバ関数定義の後の余分な ";"'
# "extra ';' outside of a function is a C++11 extension"
HEE30E6FFD401: '関数外での余分な ";" は C++11 拡張機能です'
# "extra ';' outside of a function is incompatible with C++98"
HB50929FF19FE: '関数外での余分な ";" は C++98 と互換性ありません'
# 'extra qualification on member %0'
HEB926F36FA1F: 'メンバ %0 への余分な修飾'
# "extra tokens after attribute in a '#pragma clang attribute push'"
H0F837D0B4BE4: '#pragma clang attribute push 内の属性の後に余分なトークンが含まれています'
# 'extra tokens at end of #%0 directive'
HBFAC5EAA75A7: 'ディレクティブ #%0 の末尾に余分なトークンが含まれています'
# "extra tokens at end of '#pragma %0' - ignored"
H2F08FDE9AD4F: '#pragma %0 の末尾に余分なトークンが含まれています - 無視されました'
# "extra tokens at the end of '#pragma omp %0' are ignored"
HA0D9244B087C: '#pragma omp %0 の末尾の余分なトークンは無視されます'
# "extraneous '%0' before ';'"
H8BD122A76CFA: "; の前に余分な '%0' が含まれています"
# "extraneous ')' after condition, expected a statement"
HFFE185AD544D: "条件の後に余分な ')' が含まれています。ステートメントが期待されます"
# "extraneous 'template<>' in declaration of %0 %1"
HE8DEA9984DC2: "%0 %1 の宣言における余分な 'template<>'"
# "extraneous 'template<>' in declaration of member %0"
H828C24444273: "メンバー %0 の宣言における余分な 'template<>'"
# "extraneous 'template<>' in declaration of variable %0"
HFFC1753865A1: "変数 %0 の宣言における余分な 'template<>'"
# "extraneous closing brace ('}')"
H3D189A013717: "余分な閉じカッコ ('}')"
# 'extraneous template parameter list in alias template declaration'
HAA68A1EAD59F: 'エイリアス テンプレート宣言における余分なテンプレートパラメータリスト'
# 'extraneous template parameter list in concept definition'
HE58F30339D76: 'コンセプト定義における余分なテンプレートパラメータリスト'
# 'extraneous template parameter list in template specialization'
H37A5BAADFAAC: 'テンプレート特化における余分なテンプレートパラメータリスト'
# 'extraneous template parameter list in template specialization or out-of-line template definition'
HBFB0FFADD00D: 'テンプレート特化またはアウトオブライン テンプレート定義における余分なテンプレートパラメータリスト'
# "failed requirement '%0'; 'enable_if' cannot be used to disable this declaration"
H6A26091751B1: "'enable_if' を使用してこの宣言を無効化できません。要件 '%0' の失敗"
# "failed to deduce triple for target architecture '%0'; specify the triple using '-fopenmp-targets' and '-Xopenmp-target' instead"
HAEA08639936D: "ターゲットアーキテクチャ '%0' のトリプルを推論できませんでした。代わりに '-fopenmp-targets' と '-Xopenmp-target' を使用してトリプルを指定してください"
# 'failed to expand response file: %0'
H14746831D212: 'レスポンス ファイルの展開に失敗しました: %0'
# "failed to find module file for module '%0'"
H265A065BBB4D: "モジュール '%0' のモジュールファイルを検出できませんでした"
# "failed to hash content for '%0' because memory buffer cannot be retrieved"
H13A2DD939D67: "'%0' のコンテンツのハッシュ化に失敗しました。メモリ バッファを取得できなかったためです"
# "failed to process suppression mapping file '%0': %1"
H61E7856A5801: "抑制マッピングファイル '%0' の処理に失敗しました: %1"
# "failing because %select{environment variable 'FORCE_CLANG_DIAGNOSTICS_CRASH' is set|'-gen-reproducer' is used}0"
HE0DD8241D56F: "失敗しました。%select{環境変数 'FORCE_CLANG_DIAGNOSTICS_CRASH' が設定されています|'-gen-reproducer' オプションが使用されています}0"
# 'failure when lexing a character literal'
H36FAC94ACBBF: '文字リテラルの解析中にエラーが発生しました'
# 'failure when lexing a numeric literal'
H514A5139F05F: '数値リテラルの解析中にエラーが発生しました'
# 'failure when lexing a string literal'
H628F82057288: '文字列リテラルの解析中にエラーが発生しました'
# 'fallthrough annotation does not directly precede switch label'
H0941315663A3: 'fallthrough アノテーションが switch ラベルの直前に存在しません'
# 'fallthrough annotation in unreachable code'
HF1B980EE596A: '到達不能なコード内の fallthrough アノテーション'
# 'fallthrough annotation is outside switch statement'
H1D7245256264: 'switch 文の外側で fallthrough アノテーションが使用されました'
# 'fast enumeration variables cannot be modified in ARC by default; declare the variable __strong to allow this'
H0BD569725A75: 'ARC では、高速列挙変数はデフォルトで変更できません; 変更を許可するには、変数を __strong で宣言してください'
# 'fast register allocator'
HD75005D5488A: '高速レジスタ割り当て器'
# 'feature %0 requires support of %1 feature'
HA4C52697EC12: '機能 %0 には、機能 %1 のサポートが必要です'
# 'feature cannot be %select{introduced|deprecated|obsoleted}0 in %1 version %2 before it was %select{introduced|deprecated|obsoleted}3 in version %4; attribute ignored'
H18649406044A: '機能は、%1バージョン%2で%select{導入|非推奨|廃止}0する前に、バージョン%4で%select{導入|非推奨|廃止}3する必要があります。属性は無視されます'
# "feature flag '%0' is ignored since the feature is read only"
H67D49FF0C7F8: "機能フラグ '%0' は機能が読み取り専用のため無視されます"
# "feature flag '%0' must start with either '+' to enable the feature or '-' to disable it; flag ignored"
HE0833D141647: "機能フラグ '%0' は機能を有効にする '+' または無効にする '-' で始める必要があります; フラグは無視されます"
# 'field %0 can overwrite instance variable %1 with variable sized type %2 in superclass %3'
H6914F3D605AE: 'フィールド %0 は、スーパークラス %3 の変数長型 %2 を持つインスタンス変数 %1 を上書きします'
# 'field %0 declared as a function'
HEA705CD2A4BF: 'フィールド %0 が関数として宣言されています'
# 'field %0 declared here'
HBC2A949CCB44: 'フィールド %0 はここに宣言されています'
# 'field %0 declared with incompatible types in different translation units (%1 vs. %2)'
H9B5B1B6B054E: '異なる翻訳単位でのフィールド %0 の宣言が不整合な型 (%1 対 %2) です'
# 'field %0 has type %1 here'
H3B91A03ADD90: 'フィールド %0 はここでは型 %1 です'
# "field %0 in '%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}1' not inside structure"
H161B48990AE3: "'%0' が '%select{counted_by|sized_by|counted_by_or_null|sized_by_or_null}1' で指定されているが、構造体の外側です"
# 'field %0 is uninitialized when used here'
H215FDF8256E9: 'フィールド %0 はここでの使用時に初期化されていません'
# 'field %0 with variable sized type %1 is not at the end of class'
H33E4FFCBD3EE: '可変長型 %1 を持つフィールド %0 はクラスの末尾に配置されていません'
# 'field %0 with variable sized type %1 is not visible to subclasses and can conflict with their instance variables'
HF18E29D99032: '可変長型 %1 を持つフィールド %0 はサブクラスから不可視であり、そのインスタンス変数と競合する可能性があります'
# 'field %0 with variable sized type %1 not at the end of a struct or class is a GNU extension'
H4A43BA47311C: '構造体またはクラスの末尾にない可変長型 %1 を持つフィールド %0 は GNU 拡張機能です'
# 'field %1 within %0 is less aligned than %2 and is usually due to %0 being packed, which can lead to unaligned accesses'
HA45C4FF93B3E: '%0 内のフィールド %1 は %2 よりもアライメントが低く、通常は %0 がパックされているためで、非アライメントアクセスを引き起こす可能性があります'
# 'field %select{%1|in %1}0 requires explicit initialization but is not explicitly initialized'
H84C1F3A9AA55: '%select{%1| %1 内の}0 フィールドは明示的な初期化が必要ですが、明示的に初期化されていません'
# 'field %select{width|precision}0 should have type %1, but argument has type %2'
H8AF459399447: '%select{幅|精度}0 フィールドは型 %1 を持つ必要がありますが、引数の型は %2 です'
# 'field designator %0 does not refer to a non-static data member'
HC04EA556E581: 'フィールド指定子 %0 は静的データメンバを指しません'
# 'field designator %0 does not refer to any field in type %1'
H2BAA71F8012E: '型 %1 のフィールド指定子 %0 は存在しません'
# 'field designator %0 does not refer to any field in type %1; did you mean %2?'
HE8FCC93993E6: '型 %1 のフィールド指定子 %0 は存在しません；%2 を意図した可能性があります'
# 'field designator cannot initialize a %select{non-struct, non-union|non-class}0 type %1'
H22AF1F955E3D: 'フィールド指定子は %select{非構造体・非共用体|非クラス}0 型 %1 を初期化できません'
# 'field designator refers here'
H4EC4B8573557: 'フィールド指定子はここを指しています'
# 'field has %select{incomplete|sizeless}0 type %1'
HAB06B0829266: 'フィールドは %select{未完了|サイズなし}0 型 %1 を持っています'
# 'field has name %0 here'
H5D746560C0CD: 'フィールドにはこの場所で名前 %0 が付いています'
# 'field has non-trivial ownership qualification'
HC3F83642EF10: 'フィールドは非自明な所有権修飾を保持しています'
# 'field is non-trivial to %select{copy|default-initialize}0'
H1D2827B95FDF: 'フィールドは %select{コピー|デフォルト初期化}0 が非自明です'
# 'field may not be qualified with an address space'
H8FECB3E29FF3: 'フィールドはアドレス空間修飾子を付与できません'
# 'field of illegal %select{type|pointer type}0 %1 declared here'
H7B96A2670B39: '非許可の %select{型|ポインタ型}0 %1 のフィールドがここで宣言されました'
# 'field of type %0 has %select{private|protected}2 %select{default |copy |move |*ERROR* |*ERROR* |*ERROR* |}1constructor'
H3E9701CFFDEE: 'タイプ%0のフィールドには%select{プライベート|プロテクテッド}2の%select{デフォルト |コピー |ムーブ |*ERROR* |*ERROR* |*ERROR* |}1コンストラクタがあります'
# 'field of type %1 has %select{private|protected}2 destructor'
H40B677C32C44: 'タイプ%1のフィールドには%select{プライベート|プロテクテッド}2のデストラクタがあります'
# "fields must have a constant size: 'variable length array in structure' extension will never be supported"
H4D0FA4262CAB: 'フィールドは定数サイズをもたねばなりません: 「構造体内の変数長配列」拡張は決してサポートされません'
# "file '%0' could not be located in expected %1"
H3AFCF68EDB4D: "ファイル'%0'は指定された%1で検出できませんでした"
# "file '%0' from the precompiled header has been overridden"
H0CD8B8C2C117: "プリコンパイルドヘッダから参照されたファイル'%0'が上書きされました"
# "file '%0' has been modified since the %select{precompiled header|module file|AST file}1 '%2' was built: %select{size|mtime|content}3 changed%select{| (was %5, now %6)}4"
H031EEE30BF07: "ファイル '%0' は、%select{事前コンパイル済みヘッダー|モジュールファイル|AST ファイル}1 '%2' が構築された後で変更されました: %select{サイズ|最終変更時刻|コンテンツ}3 が変更されました%select{| (以前は %5、現在は %6)}4"
# "file '%0' is not a module file"
H5DD90DFEF976: "'%0'ファイルはモジュールファイルではありません"
# "file '%0' is too large for Clang to process"
H9AA7CD92D17E: "'%0'ファイルはClangで処理可能なサイズを超えています"
# "file '%0' modified since it was first processed"
H1DA05AEA2D52: "'%0'ファイルは最初の処理後に変更されました"
# "file '%0' specified by '--extract-api-ignores=' not found"
HC79263152CF4: "'--extract-api-ignores='で指定されたファイル'%0'が見つかりません"
# "file '%0' specified by '-fmodules-embed-file=' not found"
HE609B0415A4D: "'-fmodules-embed-file='で指定されたファイル'%0'が見つかりません"
# "file '%1' is not a valid precompiled %select{PCH|module|AST}0 file: %2"
H208E3D0A2BB0: "'%1'は有効な%select{PCH|モジュール|AST}0ファイルではありません: %2"
# 'file containing an ordered list of functions to use for function reordering'
HAA6E189FC7DA: '関数再配置で使用する関数の順序付きリストを含むファイル'
# 'file entered %0 time%s0 using %1B (%human1B) of space%plural{0:|: plus %2B (%human2B) for macro expansions}2'
H6D5FEB2AA58C: 'ファイルが%0回目%s0に%1B (%human1B) のスペースを使用しました%plural{0:|: %2B (%human2B) のマクロ展開を追加}2'
# 'file name for generated dot file'
H3426DAEC804D: '生成されたドットファイルのファイル名'
# 'file name where instrumented profile will be saved (default: /tmp/prof.fdata)'
H3FCF6422DD03: '保存されるインストゥルメントプロファイルのファイル名 (デフォルト: /tmp/prof.fdata)'
# 'file to dump the ordered list of functions to use for function reordering'
HA4F935C41DEC: '関数再配置で使用する関数の順序リストを出力するファイル'
# 'file with list of functions to frame optimize'
H9B6AF2961BE8: 'フレーム最適化対象関数リストを含むファイル'
# 'file with list of functions to optimize'
HE0011E0AAAF5: '最適化対象関数リストを含むファイル'
# 'file with list of functions to optimize (non-regex)'
H03B4E7AB601D: '最適化する関数のリストを含むファイル (非正規表現)'
# 'file with list of functions to skip'
HCF75D26C4EAE: 'スキップする関数のリストを含むファイル'
# 'filter expression has non-integral type %0'
H8F952076C959: 'フィルター式の型は %0 で整数型ではありません'
# 'final overrider of %q0 in %1'
H0C345A3BEA34: ' %1 内の %q0 の最終オーバーライダー'
# 'find_all_symbols options'
H390ECCC2C1D8: 'find_all_symbols オプション'
# "finished building module '%0'"
H243A4EC2890E: "モジュール '%0' の構築が完了しました"
# 'first argument in call to %0 is a pointer to non-trivially copyable type %1'
HD27C5E590173: ' %0 の呼び出しにおける最初の引数は、非単純コピー可能型 %1 のポインタです'
# 'first argument to %0 must be a pipe type'
H3249D08A7B4F: ' %0 の最初の引数はパイプ型でなければなりません'
# "first argument to 'swift_async' must be either 'none', 'swift_private', or 'not_swift_private'"
HF444E5B58050: " 'swift_async' の最初の引数は 'none'、'swift_private'、または 'not_swift_private' でなければなりません"
# "first argument to 'va_arg' is of type %0 and not 'va_list'"
H18598D04D35B: " 'va_arg' の最初の引数は型 %0 ですが、'va_list' でなければなりません"
# 'first argument to __builtin_annotation must be an integer'
H2F65E4EF2060: ' __builtin_annotation の最初の引数は整数でなければなりません'
# 'first argument to __builtin_call_with_static_chain must be a non-member call expression'
HF21FFE70E0AD: ' __builtin_call_with_static_chain の最初の引数は非メンバ呼び出し式でなければなりません'
# 'first argument to __builtin_call_with_static_chain must not be a block call'
HAAFE474DF4AA: ' __builtin_call_with_static_chain の最初の引数はブロック呼び出しであってはなりません'
# 'first argument to __builtin_call_with_static_chain must not be a builtin call'
HF06ABEE7311C: ' __builtin_call_with_static_chain の最初の引数は組み込み関数呼び出しであってはなりません'
# 'first argument to __builtin_call_with_static_chain must not be a pseudo-destructor call'
HFC90CCCE3212: ' __builtin_call_with_static_chain の最初の引数は疑似デストラクタ呼び出しであってはなりません'
# 'first argument to __builtin_convertvector must be a vector'
HF416CD096831: ' __builtin_convertvector の最初の引数はベクター型でなければなりません'
# 'first field of a transparent union cannot have %select{floating point|vector}0 type %1; transparent_union attribute ignored'
HCF8EE366AB6A: '透過型共用体の最初のフィールドは %select{浮動小数点|ベクター}0 型 %1 を持てません; transparent_union 属性が無視されました'
# 'first non-designated initializer is here'
H3AA2DBB89701: '最初の非指定初期化子はここにあります'
# 'first parameter of %0 must have type %1'
HE845E4B59857: '%0の最初の引数は%1型でなければなりません'
# 'first two arguments to __builtin_convertvector must have the same number of elements'
HF134017C1A48: '__builtin_convertvectorの最初の2つの引数は要素数が同じでなければなりません'
# "flag '%0' is ignored when flag '%1' is present"
H83C2C7BB9944: "フラグ'%0'はフラグ'%1'が存在する場合に無視されます"
# "flag '%0' results in undefined behavior with '%1' conversion specifier"
H3E280AED1AE3: "フラグ'%0'は'%1'変換指定子と共に未定義動作を引き起こします"
# 'flat namespace libraries are not supported'
H5F018FAC5A55: 'フラットネームスペースライブラリはサポートされていません'
# 'flexible array initialization is a GNU extension'
H2B7FB7A2090E: '柔軟な配列初期化はGNU拡張です'
# 'flexible array initialization is not yet supported'
H4465FD687CED: '柔軟な配列初期化は未実装です'
# 'flexible array member %0 in a union is a GNU extension'
H87BF69264D2B: 'ユニオン内の柔軟な配列メンバ%0はGNU拡張です'
# 'flexible array member %0 in a union is a Microsoft extension'
HFF7472E02D1C: 'ユニオン内の柔軟な配列メンバ%0はMicrosoft拡張です'
# 'flexible array member %0 in otherwise empty %select{struct|interface|union|class|enum}1 is a GNU extension'
HADE10FBB32E9: '空の%select{構造体|インターフェース|ユニオン|クラス|列挙体}1内の柔軟な配列メンバ%0はGNU拡張です'
# 'flexible array member %0 in otherwise empty %select{struct|interface|union|class|enum}1 is a Microsoft extension'
H9C2765356C50: '空の%select{構造体|インターフェース|ユニオン|クラス|列挙体}1内の柔軟な配列メンバ%0はMicrosoft拡張です'
# 'flexible array member %0 not allowed in %select{struct|interface|union|class|enum}1 which has a virtual base class'
HEF0666641494: 'バーチャル基底クラスを持つ%select{構造体|インターフェース|ユニオン|クラス|列挙体}1内に柔軟な配列メンバ%0は許可されません'
# 'flexible array member %0 of type %1 with non-trivial destruction'
H07E92B7CB701: '非自明な破棄を伴う型%1の柔軟な配列メンバ%0は許可されません'
# 'flexible array member %0 with type %1 is not at the end of %select{struct|interface|union|class|enum}2'
HC60DC08C387B: '柔軟な配列メンバ%0 (型%1) は%select{構造体|インターフェース|ユニオン|クラス|列挙体}2の末尾に配置されていません'
# 'flexible array members are a C99 feature'
H04521DEE401E: '柔軟な配列メンバはC99の機能です'
# 'flexible array requires brace-enclosed initializer'
H8CC54601E715: '柔軟な配列には波括弧で囲まれた初期化子が必要です'
# "float ABI '%0' is not supported by current library"
H4A77B1741C96: "float ABI '%0'は現在のライブラリでサポートされていません"
# 'floating point arithmetic produces %select{an infinity|a NaN}0'
HE17E4C75C5CF: '浮動小数点算術は%select{無限大|NaN}0を生成しました'
# 'floating point classification requires argument of floating point type (passed in %0)'
HD0C7777CBCB2: '浮動小数点分類には浮動小数点型の引数が必要です（%0に渡されました）'
# 'floating point literal in preprocessor expression'
HB66AC9BD4411: 'プリプロセッサ式中の浮動小数点リテラル'
# 'floating-point comparison is always %select{true|false}0; constant cannot be represented exactly in type %1'
HCE8BE2CDB468: '浮動小数点比較は常に%select{真|偽}0です; 定数は型%1で正確に表現できません'
# 'fold functions with identical code'
H57C9420813A5: '同一コードを持つ関数を折り畳みます'
# 'fold jcc+mov into cmov'
H1F495E977B3A: 'jcc+movをcmovに折り畳みます'
# 'for fuzzer data'
H8CC95526ECAB: 'fuzzerデータ用'
# 'for jump tables, optimize indirect jmp targets instead of indices'
H4D3A2CC709AA: 'ジャンプテーブルの場合、インデックスの代わりに間接jmpターゲットを最適化'
# 'for loop has empty body'
HE73C4C3A1FCE: 'forループのボディが空です'
# 'for range declaration must declare a variable'
HCCF9CE851541: 'for範囲宣言では変数を宣言する必要があります'
# 'for training'
H23FBBEB90B89: 'トレーニング用'
# 'for type %0'
HE30274CCC76F: '型%0の場合'
# 'force openmp unified shared memory mode'
H98550220A417: 'OpenMP統合共有メモリモードを強制'
# 'force patching of original entry points to ensure execution follows only the new/optimized code.'
HAA8249C8D974: '実行が新規/最適化されたコードのみに従うように、元のエントリポイントのパッチを強制'
# 'force relocations to data sections to always be processed'
H790511D970BB: 'データセクションへのrelocationを常に処理するように強制'
# 'force the body of a loop to execute at least once'
H6C72E59E822C: 'ループのボディを少なくとも1回実行するように強制'
# 'force_cuda_host_device end pragma without matching force_cuda_host_device begin'
H8F7AF4F2F3B0: '一致する force_cuda_host_device begin が存在しない force_cuda_host_device 終了 pragma'
# 'format argument is %select{a value|an indirect field width|an indirect precision|an auxiliary value}0, but it should be %select{a value|an indirect field width|an indirect precision|an auxiliary value}1'
H26324CE63C64: 'フォーマット引数は%select{値|間接フィールド幅|間接精度|補助値}0ですが、%select{値|間接フィールド幅|間接精度|補助値}1である必要があります'
# 'format argument modifies specifier at position %0, but it should modify specifier at position %1'
HE2EBF92B2A88: 'フォーマット引数は位置%0のspecifierを変更していますが、位置%1のspecifierを変更する必要があります'
# 'format argument not a string type'
H84E99A867F54: 'フォーマット引数が文字列型ではありません'
# 'format attribute cannot specify the implicit this argument as the format string'
H6DFBB5CF7F53: 'フォーマット属性はフォーマット文字列として暗黙のthis引数を指定できません'
# "format specifier '%0' is incompatible with '%1'"
H4D29848904BC: "フォーマット仕様符'%0'は'%1'と互換性ありません"
# 'format specifies type %0 but the argument has %select{type|underlying type}2 %1'
H2B1918042742: 'フォーマット指定の%0型ですが、引数は%select{型|基本型}2%1です'
# "format string contains '\\0' within the string body"
H262604652293: "フォーマット文字列に文字列本文中に'\\0'が含まれています"
# 'format string is defined here'
H2D8041B9330A: 'フォーマット文字列はここに定義されています'
# 'format string is empty'
HCF4821840281: 'フォーマット文字列が空です'
# 'format string is not a string literal'
HA31C16ADFE78: 'フォーマット文字列は文字列リテラルではありません'
# 'format string is not a string literal (potentially insecure)'
HC6BB1E1C18C5: 'フォーマット文字列は文字列リテラルではありません（セキュリティリスクの可能性）'
# 'format string is not null-terminated'
H1BFF49AB9B87: 'フォーマット文字列がNULLで終端されていません'
# 'format string missing'
HF57059BFF07F: 'フォーマット文字列が指定されていません'
# 'format string should not be a wide string'
H5D46A69914C2: 'フォーマット文字列はワイド文字列であるべきではありません'
# 'format to dump profile output in aggregation mode, default is fdata'
H4B4189014528: '集約モードでのプロファイル出力のためのフォーマット指定、デフォルトはfdata'
# 'forward declaration of %0'
H9E3BA9144F24: '%0の前方宣言'
# 'forward declaration of %0 cannot have a nested name specifier'
HED9D019594EF: '%0の前方宣言にはネストした名前指定子を含めることはできません'
# 'forward declaration of class here'
H169D8B5BC4E6: 'クラスの前方宣言ここ'
# 'forward declaration of non-parameterized class %0 cannot have type parameters'
H5EA8F1567F5D: 'テンプレートパラメータを持たないクラス%0の前方宣言には型パラメータを含めることはできません'
# 'forward declaration of template entity is here'
H61734FDBAB98: 'テンプレートエンティティの前方宣言ここ'
# "forward references to 'enum' types are a Microsoft extension"
H747D15D3C5A0: "'enum'型への前方参照はMicrosoft拡張機能です"
# "found '<::' after a %select{template name|addrspace_cast|const_cast|dynamic_cast|reinterpret_cast|static_cast}0 which forms the digraph '<:' (aka '[') and a ':', did you mean '< ::'?"
HFDE68D3C1582: "%select{テンプレート名|addrspace_cast|const_cast|dynamic_cast|reinterpret_cast|static_cast}0の後に '<::' が見つかり、これはdigraph '<:'（つまり'['）と':'を形成しています。意図したのは '< ::' ではありませんか？"
# "found near match '%0'"
HE96C9DD0F351: "近似一致'%0'が見つかりました"
# 'fp convert instructions on integers with more than <N> bits are expanded.'
HBF7A8F526E5F: '<N>ビットを超える整数型の浮動小数点変換命令は展開されます'
# "friend cannot be declared in an explicit instantiation; if this declaration is meant to be a friend declaration, remove the 'template' keyword"
H2CA4FF8AC2DD: "テンプレートの明示的インスタンティエーション内でフレンド宣言はできません。この宣言がフレンド宣言である場合は'template'キーワードを削除してください"
# 'friend declaration cannot be a concept'
HB24446765643: 'フレンド宣言は概念（concept）を指定できません'
# 'friend declaration cannot have a pure-specifier'
HC11ADC45D1D2: 'フレンド宣言に純粋仕様子（pure-specifier）を指定できません'
# 'friend declaration expands pack %0 that is declared it its own template parameter list'
H7F18F2309FFC: 'フレンド宣言で自身のテンプレートパラメータリストに宣言されたパック%0が展開されています'
# 'friend declaration naming a member of the declaring class is incompatible with C++98'
H785F5E24B496: '宣言クラスのメンバーを指定するフレンド宣言はC++98と互換性ありません'
# 'friend declaration of %0 does not match any declaration in %1'
H31DFE021DF93: '%1内の宣言と一致しないフレンド宣言%0'
# 'friend declaration specifying a default argument must be a definition'
H55D4B490E76D: 'デフォルト引数を指定するフレンド宣言は定義でなければなりません'
# 'friend declaration specifying a default argument must be the only declaration'
H21926C78D225: 'デフォルト引数を指定するフレンド宣言は唯一の宣言でなければなりません'
# 'friend declaration with a constraint that depends on an enclosing template parameter must be a definition'
HC3DC9462CF4B: '周囲のテンプレートパラメータに依存する制約を伴うフレンド宣言は定義でなければなりません'
# 'friend declared here'
H4C2593C39E2F: 'ここで宣言されたフレンド'
# 'friend function %0 retaining previous language linkage is an extension'
H45895F884047: '以前の言語リンクを保持するフレンド関数%0は拡張機能です'
# 'friend function %1 is a %select{private|protected}0 member of %3'
H559C2702128F: '%3 の %select{プライベート|プロテクテッド}0 メンバーである %1 関数はフレンド関数として宣言されています'
# 'friend function cannot be defined in a local class'
H01D22F1D90F1: 'ローカルクラス内でフレンド関数を定義できません'
# 'friend function definition cannot be qualified with %0'
H87D42EF13E75: '資格修飾子%0で修飾されたフレンド関数定義はできません'
# 'friend function specialization cannot be defined'
HE48A55696A0C: 'フレンド関数の特殊化は定義できません'
# 'friend type templates must use an elaborated type'
H81BB485691B6: 'フレンド型テンプレートには拡張型を指定する必要があります'
# 'friends can only be classes or functions'
HABE505726BE2: 'フレンドはクラスまたは関数のみを指定できます'
# 'friends cannot be members of the declaring class'
H0C1CF26733ED: 'フレンドは宣言クラスのメンバーとして定義できません'
# "from 'diagnose_if' attribute on %0:"
HB7602983E09F: '%0 の diagnose_if 属性による診断:'
# 'func1,func2,func3,...'
H6E12F3399F53: 'func1,func2,func3,...'
# "function %0 declared 'noreturn' should not return"
H05EC2FA28594: 'ノーリターン属性が指定された関数 %0 は戻り値を返すべきではありません'
# 'function %0 is unsafe'
H16AE74CB24AD: '関数 %0 は安全ではありません'
# 'function %0 with deduced return type cannot be used before it is defined'
H55B75567CEBA: '推論された戻り値型を持つ関数 %0 は定義前に使用できません'
# 'function %0 with unknown type must be given a function type'
H5580EE2709E6: '型が不明な関数 %0 には関数型を指定する必要があります'
# 'function by that name is mangled as "%0"'
HD8E36422062F: 'その名前の関数はマングル名 "%0" になります'
# 'function call counts'
HC411DF133023: '関数呼び出し回数'
# 'function cannot return %select{array|function}0 type %1'
H00D7FE6EC486: '%select{配列|関数}0 型 %1 を返すことはできません'
# 'function cannot return qualified void type %0'
H6C0F9155F7F7: '修飾 void 型 %0 を返すことはできません'
# 'function declaration cannot become a multiversioned function after first usage'
HC4FCD39E4392: '最初の使用後にマルチバージョン関数に変更することはできません'
# 'function declaration cannot have variably modified type'
HC763DB755E39: '可変長型を持つ関数宣言は許可されていません'
# "function declaration is expected after 'declare %select{simd|variant}0' directive"
HCE4F7AEAC2D0: " 'declare %select{simd|variant}0'ディレクティブの後に関数宣言が期待されます"
# "function declaration is missing %select{'target'|'cpu_specific' or 'cpu_dispatch'|'target_version'}0 attribute in a multiversioned function"
H3FE487F1B347: "multiversioned function内のfunction declarationは、%select{'target'|'cpu_specific' or 'cpu_dispatch'|'target_version'}0属性が欠落しています"
# 'function declared %0 was previously declared %1, which has different SME function attributes'
HF900531E932D: '%0で宣言された関数は、以前に異なるSME関数属性の%1で宣言されていました'
# "function declared '%0' here was previously declared %select{'%2'|without calling convention}1"
H2073EFB350A2: "ここで'%0'として宣言された関数は、以前に%select{'%2'|calling conventionなし}1で宣言されていました"
# "function declared in block scope cannot have 'static' storage class"
H60B5EC75E0B8: "ブロックスコープ内で宣言された関数は'static'ストレージクラスを指定できません"
# 'function declared non-throwing here'
H03F3D9700027: 'ここでは非スロー関数として宣言されています'
# 'function declared with %0 attribute was previously declared without the %0 attribute'
H5B84619C2423: '%0属性で宣言された関数は、以前には%0属性なしで宣言されていました'
# 'function declared with regparm(%0) attribute was previously declared %plural{0:without the regparm|:with the regparm(%1)}1 attribute'
HF6A7160FBDE6: 'regparm(%0)属性で宣言された関数は、以前には%plural{0:regparm属性なし|:regparm(%1)属性}1で宣言されていました'
# "function definition declared 'typedef'"
H4E2B82F177E3: "'typedef'で宣言された関数定義"
# 'function definition does not declare parameters'
HD54A2FF99A28: '関数定義にパラメータが宣言されていません'
# 'function definition inside an Objective-C container is deprecated'
HE7254FE08BD0: 'Objective-Cコンテナ内の関数定義は非推奨です'
# 'function definition is not allowed here'
HE3336279F815: 'ここでの関数定義は許可されていません'
# 'function definition with pure-specifier is a Microsoft extension'
HDD1E7812B50D: 'pure-specifierを伴う関数定義はMicrosoft拡張です'
# 'function does not return %0'
H7977746969A8: '関数は%0を返しません'
# "function executed in streaming-SVE mode requires 'sme'"
H6F533435BD63: "ストリーミングSVEモードで実行された関数は'sme'が必要です"
# 'function id'
H68D2D6A5A6D7: '関数ID'
# "function is a coroutine due to use of '%0' here"
H3E5959ADA928: "ここでの'%0'の使用により、関数はコルーチンとなっています"
# 'function is implicitly deleted because its declared type does not match the type of an implicit %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0'
H2629CD02AC41: '宣言型が暗黙の%select{デフォルトコンストラクタ|コピーコンストラクタ|ムーブコンストラクタ|コピー代入演算子|ムーブ代入演算子|デストラクタ}0の型と一致しないため、関数は暗黙に削除されました'
# 'function multiversioning caused by this declaration'
HF2D62F7767DB: 'この宣言により関数マルチバージョニングが発生'
# "function multiversioning doesn't support %select{feature|architecture}0 '%1'"
H9210168C8D12: "function multiversioningは%select{機能|アーキテクチャ}0 '%1' のサポートを提供しません"
# 'function multiversioning is currently only supported on Linux'
H16DA1069458D: 'function multiversioningは現在Linuxでのみサポートされています'
# 'function multiversioning is not supported on the current target'
H7E39D7302E01: '現在のターゲットではfunction multiversioningがサポートされていません'
# "function name is not allowed in 'link' clause"
H0E47E3134914: "'link'句で関数名は許可されません"
# 'function names'
HDC0A95620EA5: '関数名'
# 'function parameter %0 with unknown value cannot be used in a constant expression'
H01EB1CAEE1FB: '不明な値をもつ関数パラメータ%0は定数式で使用できません'
# 'function previously declared with an %select{explicit|implicit}0 exception specification redeclared with an %select{implicit|explicit}0 exception specification'
H74E61DFB1137: '%select{explicit|implicit}0例外仕様で宣言された関数が、%select{implicit|explicit}0例外仕様で再宣言されました'
# 'function returns a type %0 marked with [[clang::coro_return_type]] but is neither a coroutine nor a coroutine wrapper; non-coroutines should be marked with [[clang::coro_wrapper]] to allow returning coroutine return type'
H6390B743719E: '[[clang::coro_return_type]]でマークされた型%0を返す関数は、コルーチンでもコルーチンラッパーでもありません；非コルーチンは[[clang::coro_wrapper]]でマークする必要があります'
# 'function scope depth exceeded maximum of %0'
H7DB5DD972DEA: '関数スコープの深さが%0を超えました'
# "function static variables are not permitted in functions to which an OpenACC 'routine' directive applies"
HE3AED765A103: "OpenACC 'routine' ディレクティブが適用された関数では静的変数が許可されません"
# 'function template %q0 matches specialization %1'
HA3A32C570475: '関数テンプレート%q0は特殊化%1と一致します'
# 'function template partial specialization is not allowed'
HA3F0ADD5EDBB: '関数テンプレートの部分特殊化は許可されません'
# 'function template specialization %0 ambiguously refers to more than one function template; explicitly specify%select{| additional}1 template arguments to identify a particular function template'
H64BC13156614: '関数テンプレート特殊化%0は複数の関数テンプレートを指すため曖昧です；特定の関数テンプレートを識別するため%select{|追加}1テンプレート引数を明示的に指定してください'
# "function template with 'sycl_kernel' attribute must have a 'void' return type"
HE8E9EA85C4E9: "'sycl_kernel'属性を持つ関数テンプレートは'return type void'を必要とします"
# "function template with 'sycl_kernel' attribute must have a single parameter"
H852CD6495192: "'sycl_kernel'属性を持つ関数テンプレートは単一のパラメータを必要とします"
# 'function try block in constexpr %select{function|constructor}0 is a C++20 extension'
H5EFE05C3D7E9: 'constexpr %select{関数|コンストラクタ}0のfunction tryブロックはC++20の拡張機能です'
# 'function try block in constexpr %select{function|constructor}0 is incompatible with C++ standards before C++20'
HACF74D9C1B64: '%select{関数|コンストラクタ}0 内のconstexpr関数トライブロックはC++20以前の標準と互換性がありません'
# 'function type may not be qualified with an address space'
H193B814022E3: '関数型にはアドレス空間修飾を付けることはできません'
# 'function type with %0 attribute must have C linkage'
H39A9B5046A90: '%0属性を有する関数型はC言語のリンケージを必須とします'
# "function using ZA state requires 'sme'"
H355762BCE254: "ZA状態を使用する関数は'sme'を必要とします"
# "function using ZT0 state requires 'sme2'"
H00330EB861A8: "ZT0状態を使用する関数は'sme2'を必要とします"
# "function with '#pragma omp declare variant' has a different %select{calling convention|return type|constexpr specification|inline specification|storage class|linkage}0"
H77243261DC29: "'#pragma omp declare variant'を有する関数は%select{呼び出し規約|戻り値型|constexpr仕様|インライン指定|ストレージクラス|リンケージ}0が異なっています"
# "function with '#pragma omp declare variant' must have a prototype when 'append_args' is used"
H6A83415B36DA: "'append_args'を使用する場合'#pragma omp declare variant'を有する関数にはプロトタイプを指定する必要があります"
# "function with 'device_type(%0)' is not available on %select{device|host}1"
HB35512790F72: "'device_type(%0)'を指定した関数は%select{デバイス|ホスト}1では利用できません"
# 'function with deduced return type cannot be virtual'
H4BED7E854F85: '戻り値型を推論した関数は仮想関数として宣言できません'
# 'function with no prototype cannot use the %0 calling convention'
H83A590AC3D6C: '%0呼び出し規約を使用するためにはプロトタイプを有する必要があります'
# "function with trailing return type must specify return type 'auto', not %0"
HBA312AD67336: '後置戻り値型指定では戻り値型として%0ではなくautoを指定する必要があります'
# 'function-like macro %0 is not defined'
H7F9F07CB89B9: 'マクロ関数%0は定義されていません'
# 'function-style cast to a builtin type can only take one argument'
H5995CF0D518F: '組み込み型への関数スタイルキャストは引数を1つしか指定できません'
# 'functional-style cast to %0 has incompatible initializer of type %1'
H0F52DA9B703F: '%0への関数スタイルのキャストは%1型の非互換な初期化子を持ちます'
# 'functions cannot be declared in an anonymous %select{struct|union}0'
H50EACF1C1B1C: '匿名%select{構造体|共用体}0内で関数を宣言することはできません'
# "functions may not be declared with 'cmse_nonsecure_call' attribute"
H21052FB1BA63: "'cmse_nonsecure_call'属性を用いた関数宣言はできません"
# 'functions that differ only in their return type cannot be overloaded'
H24E04D8DAB80: '戻り値型のみが異なる関数はオーバーロードできません'
# 'gdb'
H8EAD6354003C: 'gdb'
# 'generalized initializer lists are a C++11 extension'
HA239925474B5: '一般化された初期化リストはC++11拡張です'
# 'generalized initializer lists are incompatible with C++98'
HCEA06465013C: '汎用の初期化リストはC++98と互換性ありません'
# 'generate a C++ source file containing the patterns for the input file'
H0E649CF6B515: '入力ファイルのパターンを含むC++ソースファイルを生成'
# 'generate a list of function sections in a format suitable for inclusion in a linker script'
H26853D1AF334: 'リンカースクリプトへの埋め込みに適した形式で関数セクションの一覧を生成'
# 'generate code for binaries <128MB on AArch64'
H5478C82F0746: 'AArch64向けに128MB未満のバイナリ用のコードを生成'
# 'generate loops for copy-in/copy-out of objects with descriptors'
HEE6A80E60F2B: 'デスクリプタ付きオブジェクトのcopy-in/copy-out用ループを生成'
# 'generate new tags with runtime library calls'
HE354D1286E8B: 'ランタイムライブラリコールを使用した新しいタグを生成'
# 'generate the AST for the input file'
H8D81796BB792: '入力ファイルのAST（抽象構文木）を生成'
# 'generate the PDL MLIR for the input file'
H13DC370300BA: '入力ファイルのPDL MLIRを生成'
# 'generated arguments #%0 in round-trip: %1'
H9232807EF50E: '往復処理 #%0 で生成された引数: %1'
# 'generated arguments do not match in round-trip'
HDDB24B24E48C: '往復処理中に生成された引数が一致しません'
# 'generated arguments parse failed in round-trip'
HA646C4AED02A: '往復処理中の生成引数の解析に失敗しました'
# 'generic lambdas are incompatible with C++11'
H0E2372801126: '汎用ラムダ式はC++11と互換性ありません'
# 'getter name mismatch between property redeclaration (%1) and its original declaration (%0)'
HCB66D133764C: 'プロパティの再宣言(%1)と元の宣言(%0)のgetter名が一致しません'
# 'given <sectname>,<filename>[@<sym>=<offset>,...]  add the content of <filename> to <sectname>'
HB3C96722F67D: '<sectname>,<filename>[@<sym>=<offset>,...] を指定し、<filename>の内容を<sectname>に追加'
# "glob '%0' did not match any header file"
H7F85F549D444: "glob '%0' に一致するヘッダーファイルが見つかりません"
# 'global sampler requires a const or constant address space qualifier'
H418F4CC80105: 'グローバルサンプラーにはconstまたはconstantアドレススペース修飾子が必要です'
# 'granularity of memprof shadow mapping'
H3EDB20D758D1: 'memprofシャドウマッピングの粒度'
# 'greedy register allocator'
H682B2DF6B406: '貪欲レジスタアロケータ'
# 'growRegion() does not scale with the number of BB edges, so limit its budget and bail out once we reach the limit.'
HA399861C464F: 'BBエッジの数に比例せずgrowRegion()がスケーラビリティ不足のため、予算を制限しリミット到達時に処理を中止します'
# 'guarded_by declared here'
H0D3E968182E3: 'guarded_by はここで宣言されています'
# 'half precision constant requires cl_khr_fp16'
H4CC0B372F96B: '半精度定数にはcl_khr_fp16が必要です'
# 'hardware TLS register is not supported for the %0 sub-architecture'
HDE3B68F7C8A6: 'ハードウェアTLSレジスタは%0サブアーキテクチャでサポートされていません'
# "header attribute '%0' specified multiple times"
H7E7CB9EE75BF: 'ヘッダ属性"%0"が複数回指定されています'
# "header file %0 (aka '%1') cannot be imported because it is not known to be a header unit"
H0A389CC3DB5F: "%0 (別名'%1')のヘッダファイルは、ヘッダーユニットとして認識されないためインポートできません"
# "header file '%0' input '%1' does not match the type of prior input in api extraction; use '-x %2' to override"
HCC1F871B655D: "'%0'のヘッダファイルの入力'%1'はAPI抽出における前回の入力のタイプと一致しません；オーバーライドするには'-x %2'を使用してください"
# "header file '%0' input type '%1' does not match type of prior input in module compilation; use '-x %2' to override"
H089F6388D5E8: "'%0'のヘッダファイルの入力タイプ'%1'はモジュールコンパイルにおける前回の入力のタイプと一致しません；オーバーライドするには'-x %2'を使用してください"
# 'heap allocation performed here'
H3CBBD5C4CC88: 'ヒープ割り当てはここで行われました'
# 'hexadecimal floating %select{constant|literal}0 requires %select{an exponent|a significand}1'
HEA69D9247DD1: '16進浮動小数点%select{定数|リテラル}0には%select{指数が必要です|有効数部が必要です}1'
# 'hexadecimal floating constants are a C99 feature'
H42D5F9E3F4DF: '16進浮動小数点定数はC99の機能です'
# 'hexadecimal floating literals are a C++17 feature'
H37A919BEDE1E: '16進浮動小数点リテラルはC++17の機能です'
# 'hexadecimal floating literals are incompatible with C++ standards before C++17'
HDD6000DF6583: '16進浮動小数点リテラルはC++17以前のC++標準と互換性がありません'
# 'hidden overloaded virtual function %q0 declared here%select{|: different classes%diff{ ($ vs $)|}2,3|: different number of parameters (%2 vs %3)|: type mismatch at %ordinal2 parameter%diff{ ($ vs $)|}3,4|: different return type%diff{ ($ vs $)|}2,3|: different qualifiers (%2 vs %3)|: different exception specifications}1'
HAF71C2F007E8: '隠蔽されたオーバーロードされた仮想関数%q0はここで宣言されています%select{|: 違うクラス%diff{ ($ vs $)|}2,3|: パラメータ数の違い (%2 vs %3)|: %ordinal2パラメータでの型不一致%diff{ ($ vs $)|}3,4|: 戻り値型の違い%diff{ ($ vs $)|}2,3|: クオリファイアの違い (%2 vs %3)|: 例外指定の違い}1'
# "hidden visibility cannot be applied to 'dllexport' declaration"
HF663B246106D: "'dllexport'宣言にはhidden可視性を適用できません"
# 'higher order bits are zeroes after implicit conversion'
H69351DA797D5: '高次ビットは暗黙の変換後、ゼロになっています'
# 'hoist common instructions (default = false)'
HAA6396EA7649: '共通命令の持ち上げ（デフォルト=false）'
# 'host variable declared here'
H46B0F8E7BD93: 'ホスト変数はここで宣言されています'
# 'hot data symbols support (relocation mode)'
H654F967DBBD4: 'ホットデータシンボルのサポート（再配置モード）'
# 'how to repeat the instruction snippet'
HA06BE48BF68E: 'インストラクションのスニペットを再現する方法'
# 'hugify'
H4C1045D46DF7: 'hugify'
# 'human-readable YAML format'
HE74AE57FF6C4: '人間が読みやすいYAML形式'
# "identifier %0 after '~' in destructor name does not name a type"
H83FECEE0EB8D: 'デストラクタ名の "~" の後の識別子 %0 は型を指しません'
# 'identifier %0 in object destruction expression does not name a type'
H9BF7AFAC2ABF: 'オブジェクト破棄式の識別子 %0 は型を指しません'
# 'identifier %0 in object destruction expression does not name the type %1 of the object being destroyed'
H3AA5F97C4B64: 'オブジェクト破棄式の識別子 %0 は破棄中のオブジェクトの型 %1 を指しません'
# "identifier %0 is reserved because %select{<ERROR>|it starts with '_' at global scope|it starts with '_' and has C language linkage|it starts with '__'|it starts with '_' followed by a capital letter|it contains '__'}1"
HB25A0B12A970: '識別子 %0 は予約されています。理由: %select{<ERROR>|グローバル スコープで "_" で始まります|"_" で始まり、C 言語のリンクを有します|"__" で始まります|"_" に続き文字の大文字で始まります|(U+__) を含みます}1'
# 'identifier %0 preceded by whitespace in a literal operator declaration is deprecated'
H0DD590ABAF7E: 'リテラル演算子宣言で空白の前にある識別子 %0 は非推奨です'
# 'identifier after literal will be treated as a reserved user-defined literal suffix in C++11'
HC12CCB91962D: 'C++11 ではリテラルの後の識別子は予約されたユーザー定義リテラル接尾辞として扱われます'
# 'identifier after literal will be treated as a user-defined literal suffix in C++11'
HBE6CD4B6A8AE: 'C++11 ではリテラルの後の識別子はユーザー定義リテラル接尾辞として扱われます'
# 'identifier contains Unicode character <U+%0> that is invisible in some environments'
H5D7B884070AB: '識別子に一部の環境で不可視な Unicode 文字 <U+%0> が含まれています'
# "identifier followed by '<' indicates a class template specialization but %0 %select{does not refer to a template|refers to a function template|<unused>|refers to a variable template|<unused>|<unused>|refers to a concept}1"
HAF5607DFBCE7: "'<' を付ける識別子はクラス テンプレートの特殊化を示しますが、%0 は %select{テンプレートを指しません|関数テンプレートを指します|<未使用>|変数テンプレートを指します|<未使用>|<未使用>|概念を指します}1"
# "if processing a memory profile, filter out stack or heap accesses that won't be useful for BOLT to reduce profile file size"
HECF8ECDF0776: 'メモリ プロファイルを処理する場合、BOLT に役立たないスタックまたはヒープ アクセスをフィルタリングしてプロファイル ファイルのサイズを減らします'
# 'if reorder-functions is used, order functions putting hottest last'
HD0E8BDE8B867: 'reorder-functions を使用する場合、最もホットな関数を最後に配置します'
# 'if statement has empty body'
H1093D3B0523A: 'if 文の本文が空です'
# 'if the caller is not cold'
H4C9CA904F4C7: 'コール元が cold でない場合'
# 'if the input is dwp file, parse .debug_info section and use it to populate DW_SECT_INFO contributions in cu-index. For DWARF5 it also populated TU Index.'
HEE68D0DE6C99: '入力が dwp ファイルの場合、.debug_info セクションを解析し、cu-index の DW_SECT_INFO 寄与を充填します。DWARF5 の場合、さらに TU Index も充填します'
# 'if there is more than one benchmark for an opcode, said benchmarks may end up not being clustered into the same cluster if the measured performance characteristics are different. by default all such opcodes are filtered out. this flag will instead show only such unstable opcodes'
H1E3EED942083: 'オペコードあたりのベンチマークが複数ある場合、計測されたパフォーマンス特性が異なる場合、それらのベンチマークは同じクラスタにまとめられなくなります。デフォルトでは、このようなオペコードはすべてフィルタリングされます。このフラグを設定すると、不安定なオペコードのみを表示します'
# 'if you supply your own aligned allocation functions, use -faligned-allocation to silence this diagnostic'
H71B886D5B0E4: '独自のアラインメント付きアロケーション関数を提供する場合、この診断を抑制するため -faligned-allocation を使用してください'
# 'ifunc resolver function must return a pointer'
H3E2AB07FAA23: 'ifunc リゾルバ関数はポインタを返す必要があります'
# 'ignore failures to find derived type descriptors when translating FIR to LLVM'
H6805B42BCC88: 'FIR を LLVM に翻訳する際、派生型のディスクリプタ検索失敗を無視'
# 'ignore hash while reading function profile'
H414AB7A86B98: '関数プロファイル読み込み時にハッシュを無視'
# 'ignore instructions that do not define a sched class'
H4673E599AC01: 'スケジュールクラスを定義しない命令を無視'
# 'ignore kernel interrupt LBR that happens asynchronously'
H65FF6B663DAF: '非同期に発生するカーネル割り込み LBR を無視'
# 'ignore lto_priv or const suffixes when matching functions'
H482A47671C74: '関数マッチング時に lto_priv や const 接尾辞を無視'
# 'ignore recursive calls when constructing the call graph'
H79AFD225957D: 'コールグラフ構築時に再帰呼び出しを無視'
# "ignored 'inline' attribute on kernel function %0"
HD7F59CCBC545: "カーネル関数 %0 の 'inline' 属性を無視"
# "ignored asm label '%0' on automatic variable"
H457253219067: "自動変数の asm ラベル '%0' を無視"
# 'ignored trigraph would end block comment'
HC0EDD32FEF14: '無視されたトリグラフがブロックコメントを終了します'
# 'ignoring %0 attribute because its argument is invalid'
H5CBA55A0FD5C: '引数が無効のため %0 属性を無視'
# 'ignoring %select{return value|temporary}0 of type %2 declared with %1 attribute%select{|: %4}3'
H18EB408CFE62: '%select{戻り値|一時}0 の型 %2 を %1 属性で宣言したものは無視します%select{|: %4}3'
# "ignoring '%0' as it conflicts with that implied by '%1' (%2)"
HB9837B039EA4: "'%0' は '%1' (%2) と競合するため無視"
# "ignoring '%0' option as it cannot be used with %select{implicit usage of|}1 -mabicalls and the N64 ABI"
H17CC723C2497: "'%0' オプションは %select{暗黙の使用|}1 -mabicalls と N64 ABI と併用不可のため無視"
# "ignoring '%0' option as it is not currently supported for processor '%1'"
H14E6B917A2E6: "プロセッサ '%1' では非対応のため '%0' オプションを無視"
# "ignoring '%0' option as it is not currently supported for target '%1'"
H4AA39F54EF26: "ターゲット '%1' では非対応のため '%0' オプションを無視"
# "ignoring '%0' option for offload arch '%1' as it is not currently supported there. Use it with an offload arch containing '%2' instead"
H788152E08844: "'%1' オフロードアーキテクチャでは非対応のため '%0' オプションを無視。'%2' を含むオフロードアーキテクチャで使用してください"
# "ignoring '%select{static|inline}0' keyword on explicit template instantiation"
H8A80FA7727CA: '明示的テンプレートインスタンテーションにおける %select{static|inline}0 キーワードを無視'
# "ignoring '-f%select{no-|}0raw-string-literals', which is only valid for C and C++ standards before C++11"
H135D75731B01: "'-f%select{no-|}0raw-string-literals' は C++11 以前の C/C++ 標準でのみ有効なため無視"
# "ignoring '-mabs=2008' option because the '%0' architecture does not support it"
H5F88EE5F0A3D: "'%0' アーキテクチャでは非対応のため '-mabs=2008' オプションを無視"
# "ignoring '-mabs=legacy' option because the '%0' architecture does not support it"
HE0FE9F3B46CA: "アーキテクチャ'%0'が'-mabs=legacy'オプションをサポートしないため、無視します"
# "ignoring '-mcompact-branches=' option because the '%0' architecture does not support it"
H60C9F0D89DB6: "アーキテクチャ'%0'が'-mcompact-branches='オプションをサポートしないため、無視します"
# "ignoring '-mgpopt' option as it cannot be used with %select{|the implicit usage of }0-mabicalls"
H2A6F793FDFBC: '%select{|the implicit usage of }0-mabicallsの使用により-mgpoptオプションが使用できないため、無視されます'
# "ignoring '-mlong-calls' option as it is not currently supported with %select{|the implicit usage of }0-mabicalls"
HD076A9DC69A3: "%select{|the implicit usage of }0-mabicallsの使用により'-mlong-calls'オプションは現在サポートされていません"
# "ignoring '-mnan=2008' option because the '%0' architecture does not support it"
H29C27F0049E3: "アーキテクチャ'%0'が'-mnan=2008'オプションをサポートしないため、無視します"
# "ignoring '-mnan=legacy' option because the '%0' architecture does not support it"
HADAF322768AC: "アーキテクチャ'%0'が'-mnan=legacy'オプションをサポートしないため、無視します"
# 'ignoring -fapple-kext which is valid for C++ and Objective-C++ only'
H88A745D4B73F: 'C++およびObjective-C++でのみ有効な-fapple-kextオプションを無視します'
# 'ignoring -fdiscard-value-names for LLVM Bitcode'
HC86237F887FA: 'LLVMビットコードでは-fdiscard-value-namesオプションを無視します'
# "ignoring -fverify-debuginfo-preserve-export=%0 because -fverify-debuginfo-preserve wasn't enabled"
H36FCA7FF86DB: '-fverify-debuginfo-preserveが有効でないため、-fverify-debuginfo-preserve-export=%0を無視します'
# 'ignoring __declspec(allocator) because the function return type %0 is not a pointer or reference type'
H6AAEF2701683: '関数戻り値の型%0がポインタまたはリファレンスタイプでないため__declspec(allocator)を無視します'
# "ignoring availability attribute %select{on '+load' method|with constructor attribute|with destructor attribute}0"
H24871179ED63: '%select{+loadメソッドでの|コンストラクタ属性と共に|デストラクタ属性と共に}0利用可能なavailability属性を無視します'
# "ignoring extension '%0' because the '%1' architecture does not support it"
HD131D7C5772F: "アーキテクチャ'%1'が'%0'拡張機能をサポートしないため、無視します"
# "ignoring invalid -ftabstop value '%0', using default value %1"
H55F6E19B595A: "無効な-ftabstop値'%0'を検出、デフォルト値%1を使用します"
# "ignoring invalid /arch: argument '%0'; for %select{64|32}1-bit expected one of %2"
HF5AE60D7E4BF: "/arch:引数'%0'を無視します (%select{64|32}1ビットモードでは%2を指定してください)"
# 'ignoring redefinition of Objective-C qualifier macro'
HE01ADCD1C19E: 'Objective-C修飾マクロの再定義を無視します'
# 'ignoring return value of function declared with %0 attribute'
H0B36C4D66510: '%0属性で宣言された関数の戻り値を無視しています'
# 'ignoring return value of function declared with %0 attribute%select{|: %2}1'
H9DECD2C6A7A4: '%0属性で宣言された関数の戻り値を無視しています%select{|: %2}1'
# 'ignoring temporary created by a constructor declared with %0 attribute%select{|: %2}1'
H0FFFAF84F31C: '%0属性で宣言されたコンストラクタによって作成された一時変数を無視しています%select{|: %2}1'
# "ignoring the 'branch-protection' attribute because the '%0' architecture does not support it"
HF5FC687425B2: "アーキテクチャ'%0'が'branch-protection'属性をサポートしないため、無視します"
# 'illegal OpenMP user-defined mapper identifier'
H4FE25A4B348F: '不正なOpenMPユーザー定義マッパ識別子'
# 'illegal call to %0, expected %1 argument type'
H4DEE4185FC7F: '不正な%0への呼び出し、%1型の引数が期待されます'
# 'illegal call to enqueue_kernel, incorrect argument types'
H96AA6DCB3DCC: 'enqueue_kernelへの不正な呼び出し、引数の型が不正です'
# 'illegal call to enqueue_kernel, parameter needs to be specified as integer type'
H8F7144077DA2: 'enqueue_kernelへの不正な呼び出し、パラメータは整数型で指定する必要があります'
# 'illegal character encoding in character literal'
H44B6CA76305B: '文字リテラル内の不正な文字エンコーディング'
# 'illegal character encoding in string literal'
H2EE26865FBAD: '文字列リテラル内の不正な文字エンコーディング'
# 'illegal device builtin %select{surface|texture}0 reference class template %1 declared here'
H7BB2FD0ACCED: '不正なデバイスビルトイン%select{surface|texture}0参照クラステンプレート%1がここに宣言されています'
# 'illegal device builtin %select{surface|texture}0 reference type %1 declared here'
H1DEC140E0334: '不正なデバイスビルトイン%select{surface|texture}0参照型%1がここに宣言されています'
# 'illegal initializer (only variables can be initialized)'
H371A1BFF13F4: '不正な初期化子 (初期化できるのは変数のみです)'
# 'illegal initializer type %0'
H000E8C02D9A4: '不正な初期化子タイプ%0'
# 'illegal interface qualifier'
H247C18DEFCA4: '@catchパラメータに不正な修飾子が付与されています'
# 'illegal operation on Objective-C container subscripting'
H1CDC7C944B48: 'Objective-Cコンテナのサブスクリプト操作が不正です'
# 'illegal qualifiers on @catch parameter'
H2C6EDFE337AA: '@catchパラメータに不正な修飾子が付与されています'
# "illegal redeclaration of 'readwrite' property in class extension %0 (perhaps you intended this to be a 'readwrite' redeclaration of a 'readonly' public property?)"
H77F956612F13: "クラス拡張%0で'readwrite'プロパティの不正な再宣言 (おそらく、'readonly'のパブリックプロパティを'readwrite'として再宣言する意図だったかもしれません？)"
# "illegal redeclaration of property in class extension %0 (attribute must be 'readwrite', while its primary must be 'readonly')"
HA09E774D29B3: "クラス拡張%0でのプロパティの不正な再宣言 (属性は'readwrite'でなければならない一方、元のプロパティは'readonly'でなければなりません)"
# 'illegal scalar extension cast on argument %0 to %select{|in}1out paramemter'
HF91E5CAEA96B: '引数%0に対するスカラーエクステンションキャストは%select{|in}1outパラメータでは不正です'
# 'illegal storage class on file-scoped variable'
H601564466459: 'ファイルスコープ変数に対する不正なストレージクラス'
# 'illegal storage class on function'
H930E494BEBBE: '関数に対する不正なストレージクラス'
# 'illegal type %0 used in a boxed expression'
H5782BEFABE5B: 'ボックス表現で使用された不正なタイプ%0'
# 'illegal vector component name %0'
H6F3BE393AEDE: '無効なベクター要素名%0'
# 'illegal visibility specification'
H39F781806C46: '無効な可視性指定'
# 'imaginary constants are a C2y extension'
HAF201E910158: '虚数定数はC2y拡張機能です'
# 'imaginary constants are a GNU extension'
H539EC610843E: '虚数定数はGNU拡張機能です'
# 'imaginary constants are incompatible with C standards before C2y'
H8F7EDEA31FE9: '虚数定数はC2y以前のC規格と互換性がありません'
# 'imaginary types are not supported'
H8AEF701858F7: '虚数型はサポートされていません'
# 'immediate function %0 used before it is defined'
H1A240E8F6E49: '即時関数%0が定義前に使用されました'
# 'implementing deprecated %select{method|class|category}0'
H9AA979884A67: '非推奨の%select{メソッド|クラス|カテゴリ}0を実装しています'
# 'implementing unavailable method'
H0D7D4644123A: '使用できないメソッドを実装しています'
# 'implicit %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 inferred target collision: call to both %select{__device__|__global__|__host__|__host__ __device__}1 and %select{__device__|__global__|__host__|__host__ __device__}2 members'
HDD95624FC57A: '暗黙の%select{デフォルトコンストラクタ|コピーコンストラクタ|ムーブコンストラクタ|コピー代入演算子|ムーブ代入演算子|デストラクタ}0推論ターゲット衝突: %select{__device__|__global__|__host__|__host__ __device__}1と%select{__device__|__global__|__host__|__host__ __device__}2メンバーの両方に呼び出し'
# 'implicit boolean conversion of Objective-C object literal always evaluates to true'
HFAC6148E9355: 'オブジェクトCオブジェクトリテラルの暗黙のブール変換は常にtrueを評価します'
# "implicit capture of 'this' with a capture default of '=' is deprecated"
H7D01BFC1D4A1: "'this'をキャプチャデフォルト'='で暗黙的にキャプチャすることは非推奨になりました"
# 'implicit capture of lambda object due to conversion to block pointer here'
H9CBFA98934C5: 'ここでのブロックポインタへの変換により、ラムダオブジェクトを暗黙的にキャプチャしました'
# 'implicit cast from type %0 to type %1 drops __unaligned qualifier'
HBCE299280FC0: '型%0から型%1への暗黙のキャストで__unaligned修飾子が削除されました'
# 'implicit conversion between pointer-to-function and pointer-to-object is a Microsoft extension'
HE1B9297E3DCF: '関数ポインタとオブジェクトポインタ間の隠蔽変換はMicrosoft拡張機能です'
# "implicit conversion between vector types ('%0' and '%1') is deprecated; in the future, the behavior implied by '-fno-lax-vector-conversions' will be the default"
HD9008DAA3AF0: '符号が変わります: %0から%1への暗黙の変換'
# 'implicit conversion changes signedness: %0 to %1'
H2AEC008E19C8: '虚数成分が破棄されました: %0から%1への暗黙の変換'
# 'implicit conversion discards imaginary component: %0 to %1'
H5E6175D2FC4A: '隠蔽変換により虚数成分が破棄されます: %0 から %1 へ'
# 'implicit conversion from %0 cannot fit within the range of values for %1'
HC3B95ADC5255: '%0 は %1 の値の範囲内に収まりません'
# 'implicit conversion from %0 to %1 changes non-zero value from %2 to %3'
H5699AB9A4A11: '%0 から %1 への隠蔽変換により、0以外の値が %2 から %3 に変化します'
# 'implicit conversion from %0 to %1 changes value from %2 to %3'
H3C62B43256C2: '%0 から %1 への隠蔽変換により、値が %2 から %3 に変化します'
# 'implicit conversion from %0 to %1 is not permitted in C++'
HD43915D50111: 'C++では %0 から %1 への隠蔽変換は許可されていません'
# 'implicit conversion from %0 to %1 may lose precision'
H1D559B11094C: '%0 から %1 への隠蔽変換で精度が失われる可能性があります'
# 'implicit conversion from %2 to %3 changes value from %0 to %1'
H9616CD29DFC9: '%2 から %3 への隠蔽変換により、値が %0 から %1 に変化します'
# 'implicit conversion from array size expression of type %0 to %select{integral|enumeration}1 type %2 is a C++11 extension'
H1C73815D89AE: '配列サイズ式の型%0から%select{integral|enumeration}1型%2への隠蔽変換はC++11拡張機能です'
# 'implicit conversion from array size expression of type %0 to %select{integral|enumeration}1 type %2 is incompatible with C++98'
HBA0FE5371598: '配列サイズ式の型%0から%select{integral|enumeration}1型%2への隠蔽変換はC++98と互換性がありません'
# "implicit conversion from constant value %0 to 'BOOL'; the only well defined values for 'BOOL' are YES and NO"
H9F3E57EE843E: "定数値 %0 から 'BOOL' への隠蔽変換です；'BOOL' の明確に定義された値は YES と NO のみです"
# 'implicit conversion from enumeration type %0 to different enumeration type %1'
HEE824DA3A047: '要素列挙型 %0 から異なる要素列挙型 %1 への隠蔽変換'
# "implicit conversion from floating-point type %0 to 'BOOL'"
H4747E2EB6787: "浮動小数点型 %0 から 'BOOL' への隠蔽変換"
# "implicit conversion from integral type %0 to 'BOOL'"
H2BF4B2ABD201: "整数型 %0 から 'BOOL' への隠蔽変換"
# 'implicit conversion from nullable pointer %0 to non-nullable pointer type %1'
H2C9C47D2B30E: 'NULL可能なポインタ %0 から NULL不可ポインタ型 %1 への隠蔽変換'
# 'implicit conversion increases floating-point precision: %0 to %1'
HA48CBAE7D71E: '隠蔽変換により浮動小数点精度が増加: %0 から %1 へ'
# 'implicit conversion loses floating-point precision: %0 to %1'
H8151E8B82266: '隠蔽変換により浮動小数点精度が失われます: %0 から %1 へ'
# 'implicit conversion loses integer precision: %0 to %1'
H7E75B58A91F6: '隠蔽変換により整数精度が失われます: %0 から %1 へ'
# 'implicit conversion of %select{NULL|nullptr}0 constant to %1'
H81DB38ED2223: '%select{NULL|nullptr}0 定数を %1 へ変換した際の隠蔽変換'
# 'implicit conversion of out of range value from %0 to %1 is undefined'
H60829B0B819C: '%0 から %1 への範囲外の値の暗黙の変換は未定義です'
# 'implicit conversion truncates vector: %0 to %1'
H678147335701: '%0 から %1 への暗黙の変換でベクターが切り詰められます'
# 'implicit conversion turns floating-point number into bool: %0 to %1'
HBD45EEBA1C30: '浮動小数点数をブール値に変換: %0 から %1'
# 'implicit conversion turns floating-point number into integer: %0 to %1'
H1859EAB52A1F: '浮動小数点数を整数値に変換: %0 から %1'
# 'implicit conversion turns string literal into bool: %0 to %1'
H0BABC92466FD: '文字列リテラルをブール値に変換: %0 から %1'
# 'implicit conversion turns vector to scalar: %0 to %1'
HB2E373F67C4B: 'ベクターからスカラへの暗黙の変換: %0 から %1'
# 'implicit conversion when assigning computation result loses floating-point precision: %0 to %1'
H063DB898AD67: '計算結果の代入時に浮動小数点精度が失われます: %0 から %1'
# 'implicit conversions between vector types (%0 and %1) are not permitted'
HDD25DAA03F93: 'ベクター型 (%0 と %1) 間の暗黙の変換は許可されていません'
# 'implicit declaration introduced by elaborated type conflicts with a %select{non-struct type|non-class type|non-union type|non-enum type|typedef|type alias|template|type alias template|template template argument}0 of the same name'
H0AA0DBCCB1F5: '詳細な型指定子によって導入された暗黙の宣言が、同じ名前の %select{非構造体型|非クラス型|非共用体型|非列挙型|typedef|型エイリアス|テンプレート|型エイリアス テンプレート|テンプレート テンプレート引数}0 と競合しています'
# 'implicit declaration of function %0'
H1E9139CA3E1D: '関数 %0 の暗黙の宣言'
# "implicit deduction guide declared as '%0'"
H2EE915923496: "暗黙のデDUCTIONガイドが'%0'として宣言されています"
# 'implicit default constructor suppressed by user-declared constructor'
H2B519469152F: 'ユーザーが宣言したコンストラクタにより、暗黙のデフォルト コンストラクタが抑制されました'
# 'implicit instantiation of undefined member %0'
H2427990A2EAB: '定義されていないメンバー %0 の暗黙のインスタンティエーション'
# 'implicit truncation from %2 to a one-bit wide bit-field changes value from %0 to %1'
H46C1BDEE4300: '%2 から 1ビット幅のビットフィールドへの暗黙の切り詰めにより値が %0 から %1 に変化します'
# 'implicit truncation from %2 to bit-field changes value from %0 to %1'
HB32D8742297B: '%2 からビットフィールドへの暗黙の切り詰めにより値が %0 から %1 に変化します'
# 'implicit use of sequentially-consistent atomic may incur stronger memory barriers than necessary'
H162AB39C9F24: 'シーケンシャル コンシステントな原子的演算は、必要なよりも強いメモリ バリアを引き起こす可能性があります'
# "implicitly declaring library function '%0' with type %1"
H452F7C0F821A: 'ライブラリ関数 "%0" を型 %1 で暗黙に宣言'
# 'implicitly determined as %0'
HD0131FA6D64A: '暗黙的に %0 と決定されました'
# "implicitly disabling vptr sanitizer because rtti wasn't enabled"
HABA9C105D8F8: 'RTTIが有効でないため、vptr サニタイザを暗黙的に無効にします'
# 'import %select{module|name}0 (%1) does not match the import %select{module|name}0 (%2) of the previous declaration'
HE913E2E83F88: '%select{モジュール|名前}0 (%1) は、前の宣言の%select{モジュール|名前}0 (%2)と一致しません'
# 'import %select{module|name}0 cannot be applied to a function with a definition'
HB24CB23A8286: '%select{モジュール|名前}0 の import は定義を伴う関数には適用できません'
# 'import of C++ module \'%0\' appears within extern "C" language linkage specification'
HDAEE51A4DB06: 'C++モジュール\'%0\'のインポートは、extern "C"言語リンケージ指定の内部に現れています'
# "import of module '%0' appears within %1"
H08448256C67A: "モジュール'%0'のインポートは%1の内部に現れています"
# "import of module '%0' appears within its own %select{interface|implementation}1"
HBF7F549ECBD5: "モジュール'%0'のインポートはその%select{インターフェース|実装}1の内部に現れています"
# "import of module '%0' appears within same top-level module '%1'"
H25D86D4DF122: "モジュール'%0'のインポートは同じトップレベルモジュール'%1'の内部に現れています"
# "import of module '%0' imported non C++20 importable modules"
H861EDFB67C5B: "モジュール'%0'のインポートは非C++20互換モジュールをインポートしています"
# "import of shadowed module '%0'"
HECE190C4501D: "影付けられたモジュール'%0'のインポート"
# "imported AST from '%0' had been generated for a different target, current: %1, imported: %2"
H30A99270FD50: "'%0'からのインポートASTは異なるターゲット用に生成されました。現在:%1、インポート:%2"
# "imported by %select{|module '%2' in }1'%0'"
HBA6CF98B38A4: "%select{|モジュール'%2'の}1'%0'によってインポートされました"
# 'importing an implementation partition unit in a module interface is not recommended. Names from %0 may not be reachable'
H4BCD18B5E018: 'モジュールインターフェースで実装パーティションユニットをインポートすることは推奨されません。%0 からの名前が到達できない可能性があります'
# "importing module '%0'%select{| into '%3'}2 from '%1'"
HD074A7D9BA2D: "モジュール'%0'%select{|を'%3'に}2インポート中('%1'から)"
# 'imports must immediately follow the module declaration'
H25C0CF982742: 'インポートはモジュール宣言の直後に配置する必要があります'
# 'impossible constraint in asm: cannot store value into a register'
HEC9C616BA3F9: 'アセンブリの制約が不可能：レジスタに値を格納できません'
# 'in %select{implicit|defaulted}0 %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}1 for %2 first required here'
H7F88B1ED021A: 'in %select{暗黙の|デフォルト化された}0 %select{デフォルトコンストラクタ|コピー コンストラクタ|ムーブ コンストラクタ|コピー代入演算子|ムーブ代入演算子|デストラクタ}1 for %2 初めて必要とされる場所'
# "in call to '%0'"
H5F44B6591F5A: "'%0'を呼び出す際に"
# "in call to printing function with arguments '(%0)' while dumping struct"
H5B10BE57CF69: "構造体のダンプ中に引数'(%0)'を持つプリント関数を呼び出す際に"
# 'in defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator for %1 first required here'
H41C2C013E2E2: '%select{<ERROR>|等価比較|3-way比較|等価比較|関係比較}0 比較演算子をデフォルト化した%1 初めて必要とされる場所'
# 'in evaluating default argument here'
HA6EC671D8C49: 'ここでデフォルト引数を評価中に'
# 'in evaluation of exception specification for %q0 needed here'
H94CE96486393: '%q0 の例外仕様の評価が必要な箇所で'
# 'in first definition, possible difference is here'
HAF3474709EF4: '最初の定義における可能性のある違いはここです'
# "in implicit call to 'operator%select{!=|*|++}0' for iterator of type %1"
HA1274A4A4765: "型%1のイテレータに対して'operator%select{!=|*|++}0'の暗黙の呼び出し中"
# 'in implicit initialization for inherited constructor of %0'
HE4CCA87F39AA: '%0 の継承コンストラクタの暗黙の初期化中に'
# 'in implicit initialization of %select{array element %1 with omitted initializer|field %1 with omitted initializer|trailing array elements in runtime-sized array new}0'
HD4BCA75D333B: '%select{初期化子を省略した配列要素 %1|初期化子を省略したフィールド %1|ランタイムサイズ配列の新要素}0 の暗黙の初期化中に'
# 'in implicit initialization of binding declaration %0'
H6B3B1A4A0790: '省略された初期化子のためのバインディング宣言 %0 の暗黙の初期化中に'
# 'in initialization of temporary of type %0 created to list-initialize this reference'
H5C5815C0F326: 'このリファレンスをリスト初期化するために作成された %0 型の一時オブジェクトの初期化中に'
# "in instantiation of default argument for '%0' required here"
H920C89F748D0: "ここで要求された '%0' のデフォルト引数のインスタンテーション中に"
# "in instantiation of default function argument expression for '%0' required here"
H05CBF7F0C1EE: "ここで要求された '%0' のデフォルト関数引数式のインスタンテーション中に"
# 'in instantiation of default member initializer %q0 requested here'
HD2F44CDF38B1: 'ここで要求されたメンバー初期化子 %q0 のインスタンテーション中に'
# 'in instantiation of enumeration %q0 requested here'
H6EB646EE227A: 'ここで要求された列挙体 %q0 のインスタンテーション中に'
# 'in instantiation of exception specification for %0 requested here'
H3C01A542E6EB: 'ここで要求された %0 の例外仕様のインスタンテーション中に'
# 'in instantiation of function template specialization %q0 requested here'
HAEB9C4D2EE7B: 'ここで要求された関数テンプレート特殊化 %q0 のインスタンテーション中に'
# 'in instantiation of member class %q0 requested here'
H5CE23327E7F1: 'ここで要求されたメンバークラス %q0 のインスタンテーション中に'
# 'in instantiation of member function %q0 requested here'
H748A89FD0314: 'ここで要求されたメンバー関数 %q0 のインスタンテーション中に'
# 'in instantiation of requirement here'
HE12670012001: '要件のインスタンテーション中に'
# 'in instantiation of requirement parameters here'
HCD143B7FE64F: '要件パラメータのインスタンテーション中に'
# 'in instantiation of static data member %q0 requested here'
H0491530140D7: 'ここで要求されたテンプレート静的データメンバ%q0のインスタンチエーション中'
# 'in instantiation of template class %q0 requested here'
H65B85839EF55: 'ここで要求されたテンプレートクラス%q0のインスタンチエーション中'
# 'in instantiation of template type alias %0 requested here'
HAECA7764FC0E: 'ここで要求されたテンプレート型エイリアス%0のインスタンチエーション中'
# 'in instantiation of variable template specialization %q0 requested here'
H0FA1B781E861: 'ここで要求されたテンプレート変数特殊化%q0のインスタンチエーション中'
# 'in lowering create ArrayCoorOp instead of CoordinateOp'
H38357B1F88DE: 'lowering処理中にCoordinateOpの代わりにArrayCoorOpを作成'
# 'in non-LBR mode, guess edge counts using iterative technique'
H7372BDB68057: '非LBRモードで反復技術を用いてエッジカウントを推測'
# "in pattern '%1': %0"
H2F43FF1537BC: "パターン'%1'中: %0"
# 'in relocation mode trap upon entry to any function that uses AVX-512 instructions'
H082BA4E3D29F: 'AVX-512命令を使用する任意の関数へのエントリで再配置モードトラップを発生'
# 'in second definition, possible difference is here'
HEC9D50C16660: '2番目の定義ではここに差異がある可能性'
# 'in template expansion here'
H1E2D3625EAB4: 'ここでテンプレート展開'
# 'in the default initializer of %0'
H6D9691DC0D28: '型%0のデフォルト初期化子中'
# 'in value-initialization of type %0 here'
H74E349C94BB1: '型%0の値初期化中ここに'
# 'in%select{| implicit}0 constructor here'
H24F20A5C047E: 'in%select{|暗黙の}0コンストラクタ中'
# 'in-class initializer for static data member is not a constant expression'
H9B69A27F211E: '静的データメンバのクラス内初期化子は定数式ではありません'
# 'in-class initializer for static data member is not a constant expression; folding it to a constant is a GNU extension'
HA2848C2F37A8: '静的データメンバのクラス内初期化子は定数式ではありませんが、定数へのフォールディングはGNU拡張'
# 'in-class initializer for static data member of type %0 is a GNU extension'
H46A5C414A183: '静的データメンバの型%0のクラス内初期化子はGNU拡張'
# "in-class initializer for static data member of type %0 requires 'constexpr' specifier"
H7E9F22B76B86: "静的データメンバの型%0のクラス内初期化子には'constexpr'修飾子が必要"
# 'in_reduction variable must have the same reduction operation as in a task_reduction clause'
H7647CFB2C410: 'in_reduction変数は、task_reduction句と同じ削減演算をもたなければなりません'
# 'include a detailed record of preprocessing actions'
H4B25771F85AC: '詳細なプレプロセス処理記録を含める'
# "include location '%0' is unsafe for cross-compilation"
H62F3D6400A8A: "クロスコンパイル用には非安全なインクルードロケーション'%0'です"
# 'include module search paths'
HFFA588262B00: 'インクルードモジュール検索パス'
# "include of non-modular header inside framework module '%0': '%1'"
H82B29FF5B7DD: "フレームワークモジュール'%0'内のモジュール外ヘッダ'%1'のインクルード"
# "include of non-modular header inside module '%0': '%1'"
H747C5EDF3216: "モジュール'%0'内のモジュール外ヘッダ'%1'のインクルード"
# "include path for libstdc++ headers not found; pass '-stdlib=libc++' on the command line to use the libc++ standard library instead"
H45B1E0C04AB4: "libstdc++ヘッダのインクルードパスが見つかりません; libc++標準ライブラリを使用する場合はコマンドラインで'-stdlib=libc++'を指定してください"
# 'include search path'
H43B868761DFC: 'インクルード検索パス'
# "include the header <%0> or explicitly provide a declaration for '%1'"
HBFC18315E2CB: "ヘッダ<%0>をインクルードするか、'%1'の宣言を明示的に提供してください"
# 'incompatible block pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2'
HA4D550DCCECE: '互換性のないブロックポインタ型 %select{%diff{$から$への割り当て|異なる型への割り当て}0,1|%diff{パラメータ型$への$の渡し|パラメータ型の異なる型への渡し}0,1|%diff{戻り値型$の関数から$を返却|戻り値型の異なる型を返却}0,1|%diff{$を$型に変換|タイプ間の変換}0,1|%diff{タイプ$の式で$を初期化|異なる型の式で初期化}0,1|%diff{パラメータ型$への$の送信|パラメータ型の異なる型への送信}0,1|%diff{$を$型にキャスト|タイプ間のキャスト}0,1}2'
# 'incompatible constant for this __builtin_neon function'
H338324E39A33: '__builtin_neon関数に不適切な定数'
# 'incompatible function pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3'
H803DA0209C00: '関数ポインタの互換性がない %select{%diff{$から$への割り当て|異なる型への割り当て}0,1|%diff{パラメータ型$への$の渡し|パラメータ型の異なる型への渡し}0,1|%diff{戻り値型$の関数から$を返却|戻り値型の異なる型を返却}0,1|%diff{$を$型に変換|タイプ間の変換}0,1|%diff{タイプ$の式で$を初期化|異なる型の式で初期化}0,1|%diff{パラメータ型$への$の送信|パラメータ型の異なる型への送信}0,1|%diff{$を$型にキャスト|タイプ間のキャスト}0,1}2%select{|; *でデリファレンスする|; &でアドレスを取得する|; *を削除する|; &を削除する}3'
# 'incompatible integer to pointer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3'
H48B50F4A5A68: '整数とポインタ間の不適切な型変換 %select{%diff{$から$への割り当て|異なる型への割り当て}0,1|%diff{パラメータ型$への$の渡し|パラメータ型の異なる型への渡し}0,1|%diff{戻り値型$の関数から$を返却|戻り値型の異なる型を返却}0,1|%diff{$を$型に変換|タイプ間の変換}0,1|%diff{タイプ$の式で$を初期化|異なる型の式で初期化}0,1|%diff{パラメータ型$への$の送信|パラメータ型の異なる型への送信}0,1|%diff{$を$型にキャスト|タイプ間のキャスト}0,1}2%select{|; *でデリファレンスする|; &でアドレスを取得する|; *を削除する|; &を削除する}3'
# 'incompatible operand types (%0 and %1)'
HCEE400E94353: '互換性のない演算子の型 (%0と%1)'
# 'incompatible operand types%diff{ ($ and $)|}0,1'
H1FD3FD989888: '互換性のない演算子の型%diff{ ($と$)|}0,1'
# 'incompatible pointer to integer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3'
HFD878F5F2922: 'ポインタと整数間の不適切な型変換 %select{%diff{$から$への割り当て|異なる型への割り当て}0,1|%diff{パラメータ型$への$の渡し|パラメータ型の異なる型への渡し}0,1|%diff{戻り値型$の関数から$を返却|戻り値型の異なる型を返却}0,1|%diff{$を$型に変換|タイプ間の変換}0,1|%diff{タイプ$の式で$を初期化|異なる型の式で初期化}0,1|%diff{パラメータ型$への$の送信|パラメータ型の異なる型への送信}0,1|%diff{$を$型にキャスト|タイプ間のキャスト}0,1}2%select{|; *でデリファレンスする|; &でアドレスを取得する|; *を削除する|; &を削除する}3'
# 'incompatible pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3'
HBA7B4F7FCD76: 'ポインタ間の互換性がない %select{%diff{$から$への割り当て|異なる型への割り当て}0,1|%diff{パラメータ型$への$の渡し|パラメータ型の異なる型への渡し}0,1|%diff{戻り値型$の関数から$を返却|戻り値型の異なる型を返却}0,1|%diff{$を$型に変換|タイプ間の変換}0,1|%diff{タイプ$の式で$を初期化|異なる型の式で初期化}0,1|%diff{パラメータ型$への$の送信|パラメータ型の異なる型への送信}0,1|%diff{$を$型にキャスト|タイプ間のキャスト}0,1}2%select{|; *でデリファレンスする|; &でアドレスを取得する|; *を削除する|; &を削除する}3'
# 'incompatible pointer types passing retainable parameter of type %0to a CF function expecting %1 type'
H85C3F4475A3D: 'Core Foundation関数が%1型を期待するのに%0型のretain可能なパラメータを渡しています'
# 'incompatible redeclaration of library function %0'
H4DCB8A7133E4: 'ライブラリ関数%0の不整合な再宣言'
# 'incompatible types casting %0 to %1 with a %select{__bridge|__bridge_transfer|__bridge_retained}2 cast'
HA70D951974C7: '%select{__bridge|__bridge_transfer|__bridge_retained}2キャストで%0を%1にキャストすることはできません'
# 'incompatible vector types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2'
H349444057F6C: '互換性のないベクタータイプ %select{%diff{左辺$に右辺$を代入|異なる型の代入}0,1|%diff{パラメータ型$に$を渡す|異なる型のパラメータに渡し}0,1|%diff{戻り値型$の関数から$を返却|戻り値型の異なる関数から返却}0,1|%diff{型$への変換を試行|異なる型間の変換}0,1|%diff{型$の式で$を初期化|異なる型の式で初期化}0,1|%diff{パラメータ型$に$を送信|異なる型のパラメータに送信}0,1|%diff{型$へのキャストを試行|異なる型間のキャスト}0,1}2'
# 'incomplete definition of type %0'
H74F733EC60E9: '型%0の定義が不完全です'
# "incomplete delimited universal character name; treating as '\\' '%0' '{' identifier"
H45A3D640545C: '未完了の区切り付きユニバーサル文字列; 「\\」と「%0」、「{」の後に続く識別子として扱います'
# 'incomplete format specifier'
HC2682570C017: '不完全なフォーマット仕様子'
# 'incomplete receiver type %0'
H6C117CF6E37A: '不完全な受信者型%0'
# 'incomplete result type %0 in function definition'
HA8E1F3068B20: '関数定義における戻り値型%0が不完全です'
# 'incomplete result type %0 in lambda expression'
H69E2641DED85: 'ラムダ式における戻り値型%0が不完全です'
# "incomplete type %0 in a '_Generic' association is a C2y extension"
H7D3852AE4A16: '「_Generic」の関連付けにおける型%0の不完全型はC2y拡張機能です'
# 'incomplete type %0 is not a literal type'
H8AFDEC1F2348: 'リテラル型ではない不完全型%0'
# 'incomplete type %0 is not assignable'
HF862B3215822: '代入不可な不完全型%0'
# 'incomplete type %0 named in nested name specifier'
HCA7665DF5910: 'ネストした名前指定子に指定された不完全型%0'
# 'incomplete type %0 used in a boxed expression'
HF426C73BD83F: 'ボックス化された式で不完全型%0を使用'
# 'incomplete type %0 used in type trait expression'
H4539C0CCBFB9: '型特性式で不完全型%0を使用'
# 'incomplete type %0 where a complete type is required'
H95C11FF1D056: '完全型が必要な場所で不完全型%0が使用されました'
# 'incomplete type in call to object of type %0'
HB57B0356D109: 'オブジェクト型%0の呼び出し先が不完全です'
# 'incomplete universal character name'
H0184822E59BB: '未完了のユニバーサル文字列'
# "incomplete universal character name; treating as '\\' followed by identifier"
H5B8C01DBAD90: '未完了のユニバーサル文字列; 「\\」に続く識別子として扱います'
# 'inconsistent number of instance variables specified'
H7EB07F9DCA1E: 'インスタンス変数の数が一貫しません'
# "incorrect adjust_args type, expected 'need_device_ptr' or 'nothing'"
H34BB37A9E639: "'need_device_ptr'または'nothing'が期待されます（adjust_args型不正）"
# 'incorrect format for -preamble-bytes=N,END'
HD764A19076F3: 'オプション-preamble-bytes=N,ENDの書式が不正です'
# "incorrect map type modifier, expected one of: 'always', 'close', 'mapper'%select{|, 'present'|, 'present', 'iterator'}0%select{|, 'ompx_hold'}1%select{|, 'self'}2"
H6BCE6C4F91C6: "mapタイプ修飾子が不正です、次のいずれかを指定してください: 'always', 'close', 'mapper'%select{|, 'present'|, 'present', 'self'}0%select{|, 'ompx_hold'}1%select{|, 'self'}2"
# "incorrect map type, expected one of 'to', 'from', 'tofrom', 'alloc', 'release', or 'delete'"
HFC0556B7E292: "mapタイプが不正です。'to', 'from', 'tofrom', 'alloc', 'release', または 'delete' のいずれかを指定してください。"
# 'incorrect number of bits in integer (expected %0 bits, have %1)'
H39F86512F6F1: '整数のビット数が不正です（%0ビットが必要ですが、%1ビットがあります）'
# 'incorrect number of bits in vector operand (expected %select{|a multiple of}0 %1 bits, have %2)'
HDF4134C84931: 'ベクター演算子のビット数が正しくありません（%select{|の倍数である必要があります}0 %1 ビットが期待されましたが、%2 ビットがあります）'
# "incorrect reduction identifier, expected one of '+', '*', '&', '|', '^', '&&', '||', 'min' or 'max' or declare reduction for type %0"
HD90D2B65D413: "不正な削減識別子です。'+', '*', '&', '|', '^', '&&', '||', 'min', 'max' のいずれか、または型%0の削減を宣言してください。"
# "incorrect reduction identifier, expected one of '+', '-', '*', '&', '|', '^', '&&', '||', 'min' or 'max' or declare reduction for type %0"
HC80B58A26C84: "不正な削減識別子です。'+', '-', '*', '&', '|', '^', '&&', '||', 'min', 'max' のいずれか、または型%0の削減を宣言してください。"
# 'incorrect use of #pragma clang force_cuda_host_device begin|end'
HB4E983FB1A7D: '#pragma clang force_cuda_host_device begin|end の使用が不正です'
# "incorrect use of '#pragma fenv_access (on|off)' - ignored"
HB0DD6B333D8B: '#pragma fenv_access (on|off) の使用が不正です - 無視されました'
# "incorrect use of '#pragma ms_struct on|off' - ignored"
HB1C2DABF7753: '#pragma ms_struct on|off の使用が不正です - 無視されました'
# 'increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable %0'
H1F62FE8343E9: 'OpenMP forループのincrement句ではループ変数%0に対して単純な加算または減算を行う必要があります'
# 'increment expression must cause %0 to %select{decrease|increase}1 on each iteration of OpenMP for loop'
H6AE9805023F0: 'increment式では、OpenMP forループの各反復で%0を%select{減少させる|増加させる}1する必要があります'
# 'incremented enumerator value %0 is not representable in the largest integer type'
H33F55260A9EF: '増加した列挙子値%0は、最も大きな整数型で表現できません'
# 'incrementing expression of type bool is deprecated and incompatible with C++17'
HB438D9D07956: 'bool型のインクリメント式は非推奨であり、C++17と互換性ありません'
# 'increments 8-bit counter for every edge'
H286B107846BC: '各エッジごとに8ビットカウンタをインクリメントします'
# "indeterminate value can only initialize an object of type 'unsigned char'%select{, 'char',|}1 or 'std::byte'; %0 is invalid"
H26C79B7B3090: "不明確な値は'type 'unsigned char'%select{, 'char',|}1または'std::byte'のオブジェクトのみ初期化できます; %0は無効です"
# 'index %0 must appear exactly once in the permutation clause'
H907BCB3D7A64: 'index%0はpermutation句に正確に1回出現する必要があります'
# 'index for __builtin_shufflevector must be a constant integer'
H2AA72873C8D9: '__builtin_shufflevectorのindexは定数整数でなければなりません'
# 'index for __builtin_shufflevector must be less than the total number of vector elements'
HDC5D16284BAC: '__builtin_shufflevectorのindexはベクター要素の総数よりも小さくなければなりません'
# 'index for __builtin_shufflevector not within the bounds of the input vectors; index of -1 found at position %0 is not permitted in a constexpr context'
H0F3D61BA78F9: '入力ベクターの範囲外の __builtin_shufflevector のインデックスが指定されました; constexpr コンテキストでは位置 %0 の -1 のインデックスは許可されていません'
# 'indexing expression is invalid because subscript type %0 has multiple type conversion functions'
H28D375C7CDB6: 'サブスクリプト型 %0 には複数の型変換関数があるため、添字表現が無効です'
# 'indexing expression is invalid because subscript type %0 is not an Objective-C pointer'
H76E63693A71C: 'サブスクリプト型 %0 は Objective-C ポインタではないため、添字表現が無効です'
# 'indexing expression is invalid because subscript type %0 is not an integral or Objective-C pointer type'
H5DB003FBDC67: 'サブスクリプト型 %0 は整数型または Objective-C ポインタ型ではないため、添字表現が無効です'
# 'indexing of array without known bound is not allowed in a constant expression'
HE2B8FD1CE633: '既知の境界がない配列の添字は定数式では許可されていません'
# 'indirect call promotion'
H63A9B36F7D0A: '間接呼び出しのプロモーション'
# 'indirect goto in function with no address-of-label expressions'
H145FEAAFA432: 'ラベルのアドレスを取得する式がない関数で間接 goto が使用されました'
# 'indirection not permitted on operand of type %0'
H2DF3DCAF7C13: '型 %0 のオペランドには間接参照が許可されていません'
# 'indirection of non-volatile null pointer will be deleted, not trap'
H016B5CE240D6: '非 volatile の null ポインタの間接参照はトラップではなく、破棄されます'
# 'indirection requires pointer operand (%0 invalid)'
H17A67BCCC65A: '間接参照にはポインタ型のオペランドが必要です (%0 は無効です)'
# 'infer execution count for fall-through blocks'
H5D8BF838CEAA: 'fall-through ブロックの実行回数を推論'
# "inferred framework modules cannot be 'explicit'"
HAC0CEE5A9591: "推論されたフレームワーク モジュールは 'explicit' にできません"
# 'inferred submodule cannot be a framework submodule'
H3C9148B14284: '推論されたサブモジュールはフレームワーク サブモジュールにできません'
# 'inferred submodules require a module with an umbrella'
HB4F6C039EA5A: '推論されたサブモジュールにはアンバrellaモジュールを持つモジュールが必要です'
# "inferring '_Nonnull' for pointer type within %select{array|reference}0 is deprecated"
H0BCF4D33599B: "配列または参照内のポインタ型に対する '_Nonnull' の推論は非推奨になりました (%select{array|reference}0)"
# 'inheritance model does not match %select{definition|previous declaration}0'
H6F4F77A5056C: '継承モデルが %select{定義|以前の宣言}0 と一致しません'
# 'inheritance model ignored on %select{primary template|partial specialization}0'
H5E5E4985C4D2: '%select{プライマリ テンプレート|部分専用化}0 で継承モデルが無視されました'
# 'inherited from base class %0 here'
H942CB9135C88: 'ここでの基底クラス %0 から継承されました'
# 'inherited virtual base class %1 has %select{private|protected}2 destructor'
HC776172C0FE5: '継承された仮想基底クラス %1 は %select{private|protected}2 デストラクタを持っています'
# 'inheriting constructors are incompatible with C++98'
H811CC4188AC3: 'コンストラクタの継承はC++98と互換性がありません'
# 'inherits from superclass %0 here'
HFC19FC83A6FB: 'ここでスーパークラス %0 を継承しています'
# 'init method must return a type related to its receiver type'
HE0B5DF2EAC96: 'initメソッドは、その受信者の型に関連する型を返さなければなりません'
# 'init methods must return a type related to the receiver type'
H77EF2E241D1F: 'initメソッドは、受信者の型に関連する型を返さなければなりません'
# 'init methods must return an object pointer type, not %0'
HA49BF476668F: 'initメソッドはオブジェクトポインタ型を返さなければならず、%0 は不可です'
# "initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')"
H55BD0EE327C7: "OpenMPのforループの初期化句は、標準形式（'var = init'または'T var = init'）ではありません"
# 'initialization is not supported for __shared__ variables'
H36A01643C5A6: '__shared__変数の初期化はサポートされていません'
# 'initialization of %0 may run twice when built into a shared library: it has hidden visibility and external linkage'
H8FC0CAE3AC23: '%0 の初期化は共有ライブラリにビルドした場合、2回実行される可能性があります: 隠蔽可視性と外部リンケージを持っています'
# "initialization of %select{|signed }0char array with UTF-8 string literal is not permitted by %select{'-fchar8_t'|C++20}1"
H2A8B3176C3CF: "%select{|signed }0char配列をUTF-8文字列リテラルで初期化することは、%select{'-fchar8_t'|C++20}1 によって許可されていません"
# 'initialization of an array %diff{of type $ from a compound literal of type $|from a compound literal}0,1 is a GNU extension'
HA729653B7153: '%diff{型 $ の配列を、型 $ の複合リテラルからの初期化|複合リテラルからの初期化}0,1 はGNU拡張です'
# 'initialization of flexible array member is not allowed'
H080F42BFBE3B: 'フレキシブル配列メンバの初期化は許可されていません'
# 'initialization of incomplete type %0'
H8382A60542C7: '未完全な型 %0 の初期化'
# 'initialization of initializer_list object is incompatible with C++98'
HB868A7DFE86A: 'initializer_listオブジェクトの初期化はC++98と互換性がありません'
# 'initialization of non-aggregate type %0 with a designated initializer list'
HD9BEB3E28681: '非集約型 %0 を指定子付き初期化子リストで初期化'
# 'initialization of non-aggregate type %0 with an initializer list'
HD61976EAB0C6: '非集約型 %0 を初期化子リストで初期化'
# 'initialization of pointer of type %0 to null from a constant boolean expression'
HF7B6BD10B980: '定数ブール式から型 %0 のポインタをnull初期化'
# 'initialization statement is not supported when iterating over Objective-C collection'
H6990A52E0D21: 'Objective-Cコレクションを反復処理中に初期化ステートメントはサポートされていません'
# 'initialize the variable %0 to silence this warning'
HFBFEA45EAD29: '変数 %0 を初期化してこの警告を抑制してください'
# 'initialized flexible array member %0 is here'
H040CBD4967B6: 'flexible array member %0がここで初期化されています'
# 'initialized here %0'
H6E543F660366: 'ここで%0が初期化されています'
# 'initialized lambda capture packs are incompatible with C++ standards before C++20'
H4508A321B7A7: '初期化されたlambdaキャプチャパックはC++20以前のC++規格と互換性がありません'
# 'initialized lambda captures are a C++14 extension'
HE17291BEDE3D: '初期化されたlambdaキャプチャはC++14拡張機能です'
# 'initialized lambda captures are incompatible with C++ standards before C++14'
H4B4A5D06C778: '初期化されたlambdaキャプチャはC++14以前のC++規格と互換性がありません'
# 'initialized lambda pack captures are a C++20 extension'
H7BA4847E4BDF: '初期化されたlambdaパックキャプチャはC++20拡張機能です'
# 'initializer %0 does not name a non-static data member or base class; did you mean the %select{base class|member}1 %2?'
HBFA8CB0E43F8: '初期化子%0は非静的データメンバーまたは基底クラスを指しません；%select{基底クラス|メンバー}1の%2を指す意図でしたか？'
# 'initializer %select{partially |}0overrides prior initialization of this subobject'
H5DE4CB24B2D2: '初期化子%select{一部で|}0このサブオブジェクトの事前の初期化を上書きしています'
# 'initializer element is not a compile-time constant'
H132D68BCCE73: '初期化子要素はコンパイル時定数ではありません'
# 'initializer for aggregate is not a compile-time constant'
H6A5ECCAF1E62: '集約型に対する初期化子はコンパイル時定数ではありません'
# 'initializer for aggregate with no elements requires explicit braces'
H2820D73AEF2F: '要素のない集約型に対する初期化子には明示的な波括弧が必要です'
# 'initializer for functional-style cast to %0 contains multiple expressions'
H98881129A20C: '%0への関数スタイルキャストの初期化子には複数の式が含まれています'
# 'initializer for functional-style cast to %0 is empty'
H4EA4C8E23F55: '%0への関数スタイルキャストの初期化子は空です'
# 'initializer for lambda capture %0 contains multiple expressions'
H66A3A7273E8A: 'lambdaキャプチャ%0の初期化子には複数の式が含まれています'
# 'initializer for sizeless type %0 cannot be empty'
H8FFA617F38FD: 'サイズなし型%0の初期化子は空にできません'
# 'initializer for thread-local variable must be a constant expression'
HD7C0523C87D0: 'スレッド局所変数の初期化子は定数式でなければなりません'
# 'initializer for variable %0 with type %1 contains multiple expressions'
HA7D83169E121: '型%1の変数%0に対する初期化子には複数の式が含まれています'
# 'initializer for variable %0 with type %1 is empty'
HD6A61B62F49C: '型%1の変数%0に対する初期化子は空です'
# 'initializer for virtual base class %0 of abstract class %1 will never be used'
H377D13F4BA4B: '抽象クラス%1のバーチャル基底クラス%0に対する初期化子は使用されません'
# "initializer list cannot be used on the %select{left|right}0 hand side of operator '%1'"
H08A1BB46A564: "演算子 '%1' の%select{左|右}0側に初期化子リストを使用することはできません"
# 'initializer missing for lambda capture %0'
H362962332DA4: 'lambda キャプチャ %0 に初期化子がありません'
# 'initializer of %0 is not a constant expression'
HF34500BAECA9: '%0 の初期化子は定数式ではありません'
# 'initializer of %0 is unknown'
H4815D272C20B: '%0 の初期化子は未定義です'
# 'initializer of weak variable %0 is not considered constant because it may be different at runtime'
HBD6BC73EA44F: 'weak 変数 %0 の初期化子は、実行時に異なる可能性があるため定数と見なされません'
# 'initializer on function does not look like a pure-specifier'
H79A85F4AF5C7: '関数の初期化子は pure-specifier のような形式ではありません'
# 'initializer order does not match the declaration order'
HBA21FCA776B9: '初期化順序が宣言順序と一致しません'
# 'initializer priorities are not supported in HLSL'
HFAA073E424F4: 'HLSL では初期化子の優先度はサポートされていません'
# 'initializer would partially override prior initialization of object of type %1 with non-trivial destruction'
H52C4E394B1C2: '非自明な破棄を伴う型 %1 の対象の以前の初期化を一部上書きします'
# 'initializer-string for char array is too long'
HF948F6263A8D: 'char 配列の初期化文字列が長すぎます'
# 'initializer-string for char array is too long, array size is %0 but initializer has size %1 (including the null terminating character)'
H17CD335B9F9F: 'char 配列の初期化文字列が長すぎます、配列サイズは%0ですが初期化子のサイズは%1（ヌル終端文字を含む）です'
# 'initializing %0 from an empty initializer list is incompatible with C++98'
H822723DC0E42: '空の初期化子リストから %0 を初期化することは C++98 と互換性ありません'
# "initializing 'char8_t' array with plain string literal"
H1EA4AB240813: 'char8_t 配列を通常の文字列リテラルで初期化しようとしています'
# "initializing an array from a '%0' predefined identifier is a Microsoft extension"
H8573434E16CF: 'プリディファインド識別子 "%0" から配列を初期化することは Microsoft の拡張機能です'
# 'initializing char array with wide string literal'
H698D73717CFB: 'ワイド文字列リテラルで char 配列を初期化しようとしています'
# 'initializing field %0 with default member initializer'
HC1BC6A14F9CB: 'デフォルトのメンバ初期化子でフィールド %0 を初期化しています'
# 'initializing multiple members of union'
HC7C97F10525A: 'ユニオンの複数メンバーを初期化しています'
# 'initializing parameter %0 with default argument'
H20102CE039A6: 'デフォルト引数でパラメータ %0 を初期化しています'
# 'initializing pointer member %0 to point to a temporary object whose lifetime is shorter than the lifetime of the constructed object'
H705DCA77F9DC: '構築対象のオブジェクトの寿命よりも短い一時オブジェクトを指すように、メンバー %0 を初期化しようとしています'
# 'initializing pointer member %0 with the stack address of %select{variable|parameter}2 %1'
HF09BD5727610: 'ポインター メンバ %0 を、%select{変数|パラメータ}2 %1 のスタック アドレスで初期化しています'
# 'initializing wide char array with incompatible wide string literal'
HA0905D8F9102: '互換性のないワイド文字列リテラルでワイド文字配列を初期化しています'
# 'initializing wide char array with non-wide string literal'
H708EA2B0EAB3: '非ワイド文字列リテラルでワイド文字配列を初期化しています'
# 'inline all checks'
HF0EA4880CACC: 'すべてのチェックをインライン化'
# 'inline all functions'
HEE76F6E2509B: 'すべての関数をインライン化'
# 'inline assembly label %0 declared here'
H1FAD9492270E: 'ここで宣言されたインラインアセンブリラベル %0'
# 'inline declaration of %0 follows non-inline definition'
H9E262DCDBF26: '非インライン定義に続く%0のインライン宣言'
# 'inline declaration of %0 not allowed in block scope'
H0812ED282234: 'ブロックスコープ内で%0のインライン宣言は許可されていません'
# 'inline function %q0 is not defined'
HC9FA92373F42: '%q0 のインライン関数が定義されていません'
# 'inline function not defined%select{| before the private module fragment}0'
H195EBE25939A: '定義されていないインライン関数%select{|プライベート モジュール フラグメントの前に}0'
# 'inline function performs a conversion which is forbidden in ARC'
H46AB09EDECD4: 'ARCで禁止されている変換を実行するインライン関数'
# 'inline functions based on how much of the function is a scop.'
H1DDDFC8B898C: '関数のscop部分の大きさに基づいて関数をインライン化'
# 'inline functions if increase in size is less than defined by -inline-small-functions-bytes'
HF2FBAE9C268E: 'サイズの増加分が -inline-small-functions-bytes で定義された値未満の場合、関数をインライン化'
# 'inline functions with CFI programs (can break exception handling)'
H6C3FCE1081BE: 'CFI プログラムとのインライン関数 (例外処理が破られる可能性があります)'
# 'inline leaf functions with CFI programs (can break unwinding)'
H8B9275AE6FE3: 'CFI プログラムとの葉関数のインライン化 (アンウインドが破られる可能性があります)'
# "inline memcpy using 'rep movsb' instruction (X86-only)"
H1E31B40E5C1D: "'rep movsb'命令を使用してmemcpyをインライン化 (X86専用)"
# 'inline namespace reopened as a non-inline namespace'
H46A1E728D683: 'インラインネームスペースが非インラインネームスペースとして再オープンされました'
# 'inline namespaces are a C++11 feature'
H39D356D1A5FD: 'インラインネームスペースはC++11の機能です'
# 'inline namespaces are incompatible with C++98'
HFE4E3495E8EA: 'インラインネームスペースはC++98と互換性ありません'
# 'inline nested namespace definition is a C++20 extension'
HF12053D31358: 'インラインネスト名前空間の定義はC++20の拡張機能です'
# 'inline nested namespace definition is incompatible with C++ standards before C++20'
HDC23554C291A: 'インラインネスト名前空間の定義はC++20以前の標準と互換性ありません'
# 'inline variable %q0 is not defined'
H2B60738BBC75: 'インライン変数 %q0 は定義されていません'
# 'inline variables are a C++17 extension'
H427269D7064C: 'インライン変数はC++17の拡張機能です'
# 'inline variables are incompatible with C++ standards before C++17'
HCE89C300F33E: 'インライン変数はC++17以前の標準と互容性ありません'
# "inner loops must be tightly nested inside a '%0' clause on a '%1' construct"
HE18366CA8367: "内部ループは、'%1'構造の'%0'句内に密接にネストする必要があります"
# 'input bitcode file which can override previously defined symbol(s)'
HDFE5316187C5: '既存の定義済みシンボルを上書きすることができる入力bitcodeファイル'
# 'input conversion stopped due to an input byte that does not belong to the input codeset UTF-8'
HC2B0606B1239: '入力バイトが入力コードセットUTF-8に含まれていないため、入力変換が停止しました'
# 'input files'
H69B53967F9CE: '入力ファイル'
# "input is not a PCH file: '%0'"
H0BA9CA2C72E0: "入力はPCHファイルではありません: '%0'"
# 'input objects'
H6ADBB11C54B0: '入力オブジェクト'
# "insert '%0;' to silence this warning"
H7C4DAFCB5A75: "この警告を抑止するには'%0;'を挿入してください"
# "insert '%select{_Nonnull|_Nullable|_Null_unspecified}0' if the %select{pointer|block pointer|member pointer|array parameter}1 %select{should never be null|may be null|should not declare nullability}0"
H95F6AD57B128: "%select{ポインタ|ブロックポインタ|メンバーポインタ|配列パラメータ}1 が %select{nullになるべきではない|nullになる可能性がある|nullabilityを宣言すべきではない}0 場合は、'%select{_Nonnull|_Nullable|_Null_unspecified}0'を挿入してください"
# "insert ',' before '...' to silence this warning"
H84706E906BF0: "この警告を抑止するには'...'の前に','を挿入してください"
# "insert 'break;' to avoid fall-through"
H4EC7EA05AEDF: "fall-throughを避けるため'break;'を挿入してください"
# 'insert an explicit cast to silence this issue'
H21D74C2B0346: 'この問題を抑止するため明示的なキャストを挿入してください'
# 'insert tail call traps'
H8C2E3910BD93: 'tail call trapsを挿入してください'
# 'insert traps in old function bodies (relocation mode)'
H625478AB58CF: 'relocation modeでは古い関数本体内にtrapsを挿入します'
# "install_name does not match: '%0' (provided) vs '%1' (found)"
H748B1AE34A35: "install_nameが一致しません: '%0'（指定） vs '%1'（検出）"
# 'instance method %0 found instead of class method %1'
H1FCFE23050D1: 'クラス メソッド %1 の代わりにインスタンス メソッド %0 が見つかりました'
# "instance method %0 is being used on 'Class' which is not in the root class"
H214A12BD7783: "instance method %0 が 'Class' で使用されていますが、これはルート クラスに含まれていません"
# "instance method %objcinstance0 not found (return type defaults to 'id')"
HAFE085EFCB1C: "instance method %objcinstance0 が見つかりません (戻り値の型は 'id' に設定されます)"
# "instance method %objcinstance0 not found (return type defaults to 'id'); did you mean %objcinstance2?"
H44E31EFE4C27: "instance method %objcinstance0 が見つかりません (戻り値の型は 'id' に設定されます); 意図したのは %objcinstance2 ではありませんか？"
# 'instance variable %0 accessed in class method'
H3EADF48ACA9A: 'クラス メソッドでインスタンス変数 %0 にアクセスしています'
# 'instance variable %0 declared with incompatible types in different translation units (%1 vs. %2)'
HBFCDBA937742: '異なる翻訳ユニット (%1 対 %2) でインスタンス変数 %0 を非互換の型で宣言しています'
# 'instance variable %0 has conflicting bit-field width'
H2B77404519CC: 'インスタンス変数 %0 のビットフィールド幅が競合しています'
# 'instance variable %0 has conflicting type%diff{: $ vs $|}1,2'
H9D5CF719769D: 'インスタンス変数 %0 の型%diff{: $ vs $|}1,2が競合しています'
# 'instance variable %0 is being directly accessed'
H3F2D0ABA6990: 'インスタンス変数 %0 が直接アクセスされています'
# 'instance variable %0 is private'
HDB3564656CA2: 'インスタンス変数 %0 はプライベートです'
# 'instance variable %0 is protected'
HD16F20CBE669: 'インスタンス変数 %0 はプロテクテッドです'
# 'instance variable is already declared'
H801D25BC5C9A: 'インスタンス変数は既に宣言されています'
# 'instance variable is declared here'
H1FC75F163FBE: 'インスタンス変数はここに宣言されています'
# 'instance variable of type %0 has %select{private|protected}1 destructor'
HA9F26F512B98: '型 %0 のインスタンス変数には %select{private|protected}1 デストラクタがあります'
# 'instance variables cannot be of reference type'
HCCF4E9A4856E: 'インスタンス変数は参照型になることはできません'
# 'instance variables may not be placed in %select{categories|class extension}0'
H0D800B785119: 'インスタンス変数は %select{categories|class extension}0 に配置できません'
# 'instance variables must have a constant size'
H99AB003B5614: 'インスタンス変数は定数サイズでなければなりません'
# 'instantiated into assembly here'
H396FFF689BB5: 'ここにインスタンス化されたアセンブリ'
# 'instantiating fold expression with %0 arguments exceeded expression nesting limit of %1'
H467EDA4122CE: '%0 個の引数で fold expression をインスタンス化する際に、式のネスト制限 %1 を超えました'
# 'instantiation of %q0 is different in different modules'
H7179BAA1427A: '異なるモジュール間で%q0のインスタンス化が異なっています'
# "instantiation of '%0' not supported yet"
H5578212F4DA3: "'%0'のインスタンス化はまだサポートされていません"
# 'instantiation of function %q0 required here, but no definition is available'
H88BC3AB38294: 'ここで%q0関数のインスタンス化が必要ですが、定義が見つかりません'
# 'instantiation of variable %q0 required here, but no definition is available'
H4C7FC0EFFE4E: 'ここで%q0変数のインスタンス化が必要ですが、定義が見つかりません'
# 'instrument atomic instructions (rmw, cmpxchg)'
H9BDE4655B194: 'rmw、cmpxchgを含む原子命令を分析対象とする'
# 'instrument byval arguments'
H6881238D18AA: 'byval引数を分析対象とする'
# 'instrument byval call arguments'
H6F6BC27C3374: 'byval呼び出し引数を分析対象とする'
# 'instrument code to generate accurate profile data'
HE308C13DB62F: '正確なプロファイルデータを生成するためにコードを分析対象とする'
# 'instrument dynamic allocas'
HBD70EB33F966: '動的allocaを分析対象とする'
# 'instrument landing pads'
HEB0B3F6EFDA4: 'landing padsを分析対象とする'
# 'instrument memory intrinsics'
HA6D9147CFA12: 'メモリ固有関数を分析対象とする'
# 'instrument personality functions'
HD5594587E387: 'personality関数を分析対象とする'
# 'instrument read instructions'
H064E58E10C74: '読み取り命令を分析対象とする'
# 'instrument reads and writes with callbacks'
H29E9BA5B8A64: 'コールバックを使用して読み書きを分析対象とする'
# 'instrument stack (allocas)'
HD0DD117BE7BA: 'スタック(allocas)を分析対象とする'
# 'instrument write instructions'
HA31AFF85F744: '書き込み命令を分析対象とする'
# 'instrumentation map used to identify function ids. Currently supports elf file instrumentation maps.'
HABD136211445: '関数IDを特定するために使用される分析マップ。現在、elfファイル用の分析マップをサポートしています。'
# 'integer constant expression evaluates to value %0 that cannot be represented in a %1-bit %select{signed|unsigned}2 integer type'
HA689EA8A19CC: '%1ビットの%select{符号付き|符号なし}2整数型では表現できない値%0に評価された整数定数式です'
# 'integer constant not in range of enumerated type %0'
H38F9A13FA923: '列挙型%0の範囲外の整数定数です'
# 'integer literal is too large to be represented in a signed integer type, interpreting as unsigned'
H510046C2B2ED: '整数リテラルは符号付き整数型で表現するのに大きすぎます。符号なしとして解釈します'
# 'integer literal is too large to be represented in any %select{signed |}0integer type'
H586D057CD6B8: '整数リテラルは%select{符号付き |}0整数型のいずれかで表現するのに大きすぎます'
# "integer literal is too large to be represented in type 'long' and is subject to undefined behavior under C++98, interpreting as 'unsigned long'; this literal will %select{have type 'long long'|be ill-formed}0 in C++11 onwards"
H84C22AB83CDC: 'long型で表現するのに大きいため、C++98ではunsigned longとして解釈します。C++11以降ではこのリテラルは%select{long long型になります|無効になります}0'
# "integer literal is too large to be represented in type 'long', interpreting as 'unsigned long' per C++98; this literal will %select{have type 'long long'|be ill-formed}0 in C++11 onwards"
H4C2C8A72E536: 'long型で表現するのに大きいため、C++98ではunsigned longとして解釈します。C++11以降ではこのリテラルは%select{long long型になります|無効になります}0'
# "integer literal is too large to be represented in type 'long', interpreting as 'unsigned long' per C89; this literal will %select{have type 'long long'|be ill-formed}0 in C99 onwards"
H58DBBF3A9BD1: 'long型で表現するのに大きいため、C89ではunsigned longとして解釈します。C99以降ではこのリテラルは%select{long long型になります|無効になります}0'
# 'integer overflow in preprocessor expression'
H24214C6EA913: 'プリプロセッサ式で整数オーバーフローが発生しました'
# 'integer sequences must have integral element type'
H16392B2B25B5: '整数シーケンスには整数型の要素型が必要です'
# 'integer sequences must have non-negative sequence length'
HC3DBF19F94A9: '整数シーケンスには非負のシーケンス長が必要です'
# 'integer value %0 is outside the valid range of values [%1, %2] for the enumeration type %3'
HB6C02E17F94C: '列挙型%3の有効範囲[%1, %2]の外の整数値%0が指定されました'
# 'integral constant expression has incomplete class type %0'
H52768B5A0D44: '整数定数式には不完全なクラス型%0が含まれています'
# 'integral constant expression requires explicit conversion from %0 to %1'
H482F498F126E: '%0から%1への明示的な変換が必要です'
# 'interface type %1 cannot be %select{returned|passed}0 by value; did you forget * in %1?'
H5F16699831A7: 'インターフェース型 %1 は値渡しで %select{戻せません|渡せません}0; %1 に * を忘れましたか？'
# 'interface type cannot be statically allocated'
HFB7A102C4547: 'インターフェース型は静的確保できません'
# 'interface type cannot inherit from %select{struct|non-public interface|class}0 %1'
HE603DB4B7CDD: 'インターフェース型は%select{構造体|非公開インタフェース|クラス}0 %1から継承できません'
# "interface types cannot specify '%select{private|protected}0' access"
H5BB34D1AC02B: 'インターフェース型では"%select{private|protected}0"アクセスを指定できません'
# "interop type '%0' cannot be specified more than once"
H92EFF909211E: 'インターペロptype "%0"は複数回指定できません'
# 'interop variable %0 used in multiple action clauses'
H6D1E048E9343: 'インターペロプ変数%0は複数のアクション句で使用されています'
# "interop variable must be of type 'omp_interop_t'"
H4EE913CC5003: 'インターペロプ変数は型"omp_interop_t"でなければなりません'
# 'interrupt service routine cannot be called directly'
H0EEEBB03E095: 'インタラプトサービスルーチンを直接呼び出せません'
# "interrupt service routine with vfp enabled may clobber the interruptee's vfp state"
H55034798B0BD: 'vfp が有効な中断サービスルーチンは、interruptee の vfp ステートを破壊する可能性があります'
# 'interval between profile writes (default: 0 = write only at program end).  This is useful for service workloads when you want to dump profile every X minutes or if you are killing the program and the profile is not being dumped at the end.'
H3081FD16F975: 'プロファイル書き込み間隔（デフォルト: 0 = プログラム終了時にのみ書き込む）。これは、X 分間隔でプロファイルをダンプしたいサービスワークロードや、プログラム終了時にプロファイルがダンプされない場合に役立ちます'
# 'intrinsic module directory'
H68E291291712: '_INTRINSIC モジュール ディレクトリ'
# 'intrinsic module search paths'
H9C8DEF0487D6: '_INTRINSIC モジュールの検索パス'
# 'introduce a module file extension for testing purposes. The argument is parsed as blockname:major:minor:hashed:user info'
HC4A3048AAD1F: 'テスト用のモジュール ファイル拡張子を導入します。引数は blockname:major:minor:hashed:user info として解析されます'
# 'introduce a parameter name to make %0 part of the selector'
HF88F126D64B8: '%0 をセレクタの一部にするパラメータ名を導入します'
# 'invalid #ident directive'
H33DD8376B05A: '無効な #ident ディレクティブ'
# 'invalid %% escape in inline assembly string'
HDBE197B56289: 'インラインアセンブリ文字列内の無効な %% エスケープ'
# "invalid %0 at end of declaration; did you mean '='?"
H6911F0CCF565: "宣言の終端における無効な %0; '=' を意図しませんでしたか？"
# 'invalid %select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 %select{floating-point|enumeration}1 type %2 %plural{2:with|4:from|:and}0 %select{enumeration|floating-point}1 type %3'
H06A881D8D9FE: '無効な %select{浮動小数点|列挙型}1 型 %2 の %select{算術演算|ビット演算|比較|条件式|複合代入}0%plural{2:と|4:から|:および}0 %select{列挙型|浮動小数点}1 型 %3'
# 'invalid %select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0 different enumeration types%diff{ ($ and $)|}1,2'
H796D4C8F35F6: '異なる列挙型間の無効な %select{算術演算|ビット演算|比較|条件式|複合代入}0%diff{ ($ と $)|}1,2'
# 'invalid %select{branch|return|throw}0 %select{out of|into}1 OpenACC Compute/Combined Construct'
H898CA374F6B7: 'OpenACC Compute/Combined Construct %select{内|外}1 の無効な %select{分岐|戻り値|throw}0'
# 'invalid %select{constructor|destructor}0 declaration'
HDEF8993ADCB9: '無効な %select{コンストラクタ|デストラクタ}0 宣言'
# "invalid 'this' expression on 'map' clause"
H008D791665EC: "'map' クラウスにおける 'this' 式が無効です"
# "invalid -Xopenmp-target argument: '%0', options requiring arguments are unsupported"
H705427655A77: "無効な -Xopenmp-target 引数: '%0'; 引数が必要なオプションはサポートされていません"
# "invalid C++ ABI name '%0'"
H8F1C2E5DB890: "無効な C++ ABI 名 '%0'"
# "invalid CoreFoundation Runtime ABI '%0'; must be one of 'objc', 'standalone', 'swift', 'swift-5.0', 'swift-4.2', 'swift-4.1'"
H91493C3284DF: "無効な CoreFoundation Runtime ABI '%0'; 'objc', 'standalone', 'swift', 'swift-5.0', 'swift-4.2', 'swift-4.1' のいずれかでなければなりません"
# 'invalid Darwin version number: %0'
HA0C57A49CA76: 'Darwin バージョン番号が無効です: %0'
# "invalid OS value '%0' in '%1'"
H00BD3F016742: "'%1' 内のOS値'%0'が無効です"
# 'invalid OpenACC clause %0'
HA3099393E590: '無効なOpenACC句%0'
# "invalid OpenACC directive %select{%1|'%1 %2'}0"
H74A42ADBF419: "無効なOpenACCディレクティブ %select{%1|'%1 %2'}0"
# 'invalid PCS type'
H696D824B4D2C: '無効なPCS型'
# "invalid RVV vector size '%0', expected size is '%1' based on LMUL of type and '-mrvv-vector-bits'"
H96A03531A0AD: "'%0' は無効なRVVベクトルサイズです。タイプのLMULと'-mrvv-vector-bits'に基づくと、期待されるサイズは'%1'です"
# "invalid SVE vector size '%0', must match value set by '-msve-vector-bits' ('%1')"
HF993CA8A3093: "'%0' は無効なSVEベクトルサイズです。'-msve-vector-bits' ('%1')で設定された値と一致する必要があります"
# 'invalid UTF-8 in comment'
H58EB41DE8F48: 'コメント内のUTF-8が無効です'
# "invalid Xarch argument: '%0', not all driver options can be forwared via Xarch argument"
HA12658A01ACA: "無効なXarch引数：'%0'、すべてのドライバーオプションがXarch引数経由で転送できるわけではありません"
# "invalid Xarch argument: '%0', options requiring arguments are unsupported"
H7917BEC4B42C: "無効なXarch引数：'%0'、引数を要求するオプションはサポートされていません"
# 'invalid __hlsl_resource_t type attributes'
H9A97FF7B54BE: '__hlsl_resource_t型の属性が無効です'
# 'invalid address discrimination mode %0'
H1D217687F248: '%0のアドレス判別モードが無効です'
# "invalid alignment option in '#pragma %select{align|options align}0' - ignored"
H410475644E70: "'#pragma %select{align|options align}0' 内のアライメントオプションが無効で無視されました"
# "invalid application of '%0' to %select{an incomplete|sizeless}1 type %2"
H3984632B643A: "'%0' を%select{未完成|サイズなし}1型%2に適用することはできません"
# "invalid application of '%0' to WebAssembly table"
HA443432F106F: "'%0' をWebAssemblyテーブルに適用することはできません"
# "invalid application of '%0' to a function type"
HFD1A077F0D84: "'%0' を関数型に適用することはできません"
# "invalid application of '%0' to a void type"
H3290D1C688B6: "'%0' をvoid型に適用することはできません"
# "invalid application of '%select{sizeof|alignof|typeof|typeof_unqual}0' to bit-field"
H4D97635BE644: "'%select{sizeof|alignof|typeof|typeof_unqual}0' をビットフィールドに適用することはできません"
# "invalid application of '__builtin_omp_required_simd_align' to an expression, only type is allowed"
H0F35C466B34C: '__builtin_omp_required_simd_alignの適用対象は型のみです。式には適用できません'
# "invalid application of 'alignof' to a field of a class still being defined"
H584C8A2541E4: 'alignof をまだ定義中のクラスのフィールドに適用することはできません'
# "invalid application of 'offsetof' to a field of a virtual base"
H7E5DD90FD952: "'offsetof'をバーチャルベースのフィールドに不適切な適用"
# "invalid arch name '%0'"
H053EB6DE40C8: "無効なアーキテクチャ名 '%0'"
# "invalid arch name '%0', %1"
HAF3A77CFBCF8: "無効なアーキテクチャ名 '%0', %1"
# 'invalid argument %0 to function: %1, expecting a generic pointer argument'
H45B49DB90594: '関数 %1 への引数 %0 が無効: 一般的なポインタ引数が期待されます'
# "invalid argument '%0' not allowed with '%1'"
H5F814EC912CC: "引数 '%0' は '%1' と一緒に使用できません"
# "invalid argument '%0' only allowed with '%1'"
HCD365CC8E5D4: "引数 '%0' は '%1' のみで許可されています"
# "invalid argument '%0' to -%1"
H8405E80D8137: "オプション -%1 への引数 '%0' が無効"
# "invalid argument '%0' to -malign-branch=; each element must be one of: %1"
H20657E1CDBBF: "無効な引数 '%0' が -malign-branch= に渡されました；各要素は %1 のいずれかでなければなりません"
# "invalid argument '%0' to -mfpu=; must be one of: 64, 32, none, 0 (alias for none)"
HF131652C4C29: "無効な引数 '%0' が -mfpu= に渡されました；使用可能なオプションは 64, 32, none, 0 (none のエイリアス) です"
# "invalid argument '%0' to -msimd=; must be one of: none, lsx, lasx"
H2BA112BC46B6: "無効な引数 '%0' が -msimd= に渡されました；使用可能なオプションは none, lsx, lasx です"
# "invalid argument '%0' to atomic attribute; valid options are: 'remote_memory', 'fine_grained_memory', 'ignore_denormal_mode' (optionally prefixed with 'no_')"
H438B1A442EF4: "無効な引数 '%0' がアトミック属性に渡されました；有効なオプションは 'remote_memory', 'fine_grained_memory', 'ignore_denormal_mode' です（オプションで 'no_' で始まる場合もあります）"
# "invalid argument '-mno-amdgpu-ieee' only allowed with relaxed NaN handling"
H507F0448DDCC: "オプション '-mno-amdgpu-ieee' は緩和されたNaN処理のみで許可されます"
# "invalid argument in '%0', only integer or 'auto' is supported"
H40210717B247: "引数 '%0' は整数または'auto'のみがサポートされています"
# "invalid argument in '%0', only integers are supported"
H7CC5EAE0927D: "引数 '%0' は整数のみがサポートされています"
# 'invalid argument of type %0; expected an integer type'
HDC97D348BCF9: '引数の型%0は無効: 整数型が期待されます'
# 'invalid argument to convert to character'
H035CE8B39D0F: '文字への変換が無効'
# 'invalid argument type %0 to unary expression'
HB7A2329B026C: '単項式への引数の型%0が無効'
# 'invalid argument type to function %0 (expecting %1 having %2)'
H740D8FB32D84: '関数%0 (期待される%1は%2を持つ必要があります)'
# 'invalid argument: symbol must be a device-side function or global variable'
HB29E0DD1BCB5: 'シンボルはデバイス側の関数またはグローバル変数でなければなりません'
# "invalid argument; expected 'disable'"
H14256C1A2363: "無効な引数；'disable' が期待されます"
# "invalid argument; expected 'enable'%select{|, 'full'}0%select{|, 'assume_safety'}1 or 'disable'"
H369903756AB7: "無効な引数；'enable'%select{|, 'full'}0%select{|, 'assume_safety'}1 または 'disable' が期待されます"
# 'invalid authentication key %0'
H1380B8ED725A: '無効な認証キー %0'
# 'invalid block pointer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2'
H1E4447440EDF: 'ブロックポインタ変換が無効です %select{%diff{$から$への割り当て|異なる型の割り当て}0,1|%diff{パラメータの型$への引数$の渡し|異なる型への渡し}0,1|%diff{戻り値の型$の関数から$を返却|異なる戻り値型からの返却}0,1|%diff{型$への$の変換|異なる型間の変換}0,1|%diff{型$の式で$を初期化|異なる型の式による初期化}0,1|%diff{パラメータの型$への$の送信|異なる型への送信}0,1|%diff{型$への$のキャスト|異なる型間のキャスト}0,1}2'
# 'invalid block variable declaration - must be %select{const qualified|initialized}0'
HF892D907A5A7: 'ブロック変数宣言が無効です - %select{const修飾|初期化}0 が必要です'
# "invalid block variable declaration - using 'extern' storage class is disallowed"
H2029EAB9FA9A: "ブロック変数宣言が無効です - 'extern' ストレージクラスの使用は禁止されています"
# 'invalid branch into OpenACC Compute/Combined Construct'
HC49FDF0B5C89: 'OpenACC Compute/Combined コンストラクト内への無効なブランチ'
# 'invalid branch out of OpenACC Compute/Combined Construct'
H921800904C81: 'OpenACC Compute/Combined コンストラクトからの無効なブランチ'
# "invalid branch protection option '%0' in '%1'"
H69A222420F22: "ブランチ保護オプション '%0' が '%1' 内で無効です"
# "invalid character '%0' in raw string delimiter; use PREFIX( )PREFIX to delimit raw string"
H82170E32D0E4: "生文字列区切りに無効なキャラクター '%0' が使用されました；PREFIX( )PREFIX を使用して生文字列を区切る必要があります"
# "invalid comparison flag %0; use 'layout_compatible' or 'must_be_null'"
H677EA1A68EB0: "無効な比較フラグ %0；'layout_compatible' または 'must_be_null' を使用してください"
# "invalid component '%0' used; expected 'x', 'y', 'z', or 'w'"
H32632D0CDE2F: "無効なコンポーネント '%0' が使用されました；'x', 'y', 'z', または 'w' を指定する必要があります"
# 'invalid constructor from class in system header, should not be explicit'
HEFC602372E3E: 'システムヘッダー内のクラスからのコンストラクタは、explicit にしてはなりません'
# 'invalid conversion between ext-vector type %0 and %1'
H4E43BF77A891: 'ext-vector型 %0 と %1 の間での変換は無効です'
# 'invalid conversion between vector type %0 and integer type %1 of different size'
HAD5A2EB8C76E: 'ベクタータイプ %0 と異なるサイズの整数型 %1 の間での変換は無効です'
# 'invalid conversion between vector type %0 and scalar type %1'
H0E21BE8324C1: 'ベクタータイプ %0 とスカラータイプ %1 の間で無効な変換です'
# 'invalid conversion between vector type%diff{ $ and $|}0,1 of different size'
H62FB40425AFD: '異なるサイズのベクター型%diff{ $ と $|}0,1の間での無効な変換'
# "invalid conversion specifier '%0'"
H36DE3CE25255: "無効な変換指定子 '%0' です"
# 'invalid covariant return for virtual function: %1 is a %select{private|protected}2 base class of %0'
HB307942D226E: '仮想関数の共変戻り値が無効です: %1 は %0 の %select{private|protected}2 ベースクラスです'
# 'invalid cpu feature string for builtin'
H63D2023D3150: 'ビルトイン用の無効な CPU フィーチャー文字列です'
# 'invalid cpu name for builtin'
HD2B5E0F427CF: 'ビルトイン用の無効な CPU 名です'
# 'invalid custom discrimination'
HBF55CC3D0D6C: '無効なカスタム判別です'
# 'invalid declaration inside %select{tbuffer|cbuffer}0'
H75299BE36932: '%select{tbuffer|cbuffer}0 内の無効な宣言です'
# 'invalid declaration specifier in template non-type parameter'
HE0A0675789D7: 'テンプレート非型パラメータの無効な宣言仕様です'
# 'invalid diagnostic type for \'diagnose_if\'; use "error" or "warning" instead'
HD2E5D476D869: 'diagnose_if の無効な診断タイプです；代わりに "error" または "warning" を使用してください'
# "invalid digit '%0' in %select{decimal|octal|binary}1 constant"
H6F9BD80EC0BE: "%select{decimal|octal|binary}1 定数内の無効な数字 '%0'"
# "invalid digit '%0' in escape sequence"
HF729B18CD0D2: "エスケープシーケンス内の無効な数字 '%0'"
# "invalid escape sequence '%0' in an unevaluated string literal"
HF58F976119B7: "評価されない文字列リテラル内の無効なエスケープシーケンス '%0'"
# "invalid exception model '%select{none|sjlj|seh|dwarf|wasm}0' for target '%1'"
H00FCEE8853CC: "ターゲット '%1' に対する無効な例外モデル '%select{none|sjlj|seh|dwarf|wasm}0'"
# 'invalid expected %0: %1'
HE0DC8B702320: '予期される %0 の無効な形式: %1'
# 'invalid explicit object parameter type %0 in lambda with capture; the type must be the same as, or derived from, the lambda'
H98E01B807F8E: 'キャプチャを伴うラムダ内の明示的オブジェクトパラメータタイプ %0 が無効です；このタイプはラムダと同じか、または派生したものでなければなりません'
# 'invalid explicit object parameter type %0 in lambda with capture; the type must derive publicly from the lambda'
H607716F86E02: 'キャプチャを伴うラムダ内の明示的オブジェクトパラメータタイプ %0 が無効です；このタイプはラムダからパブリックに派生したものでなければなりません'
# 'invalid extra discrimination selection %0'
HAC5AAEAB2B1D: '無効な追加の判別選択 %0'
# 'invalid feature combination: %0'
H53E34DDB7754: '無効なフィーチャーの組み合わせ: %0'
# 'invalid field is here'
H6F033E1FBEC9: '無効なフィールドがここにあります'
# 'invalid filename for #line directive'
H5BFFCF48D855: '#lineディレクティブ用の無効なファイル名'
# 'invalid filename for line marker directive'
H6AF3C8643D27: 'line markerディレクティブ用の無効なファイル名'
# 'invalid flag line marker directive'
H5CC65A10A5E0: '無効なフラグ line marker ディレクティブ'
# "invalid float ABI '%0'"
H606FAE3A11E2: "無効なfloat ABI '%0'"
# "invalid iOS deployment version '%0', iOS 10 is the maximum deployment target for 32-bit targets"
HD422F25540A2: "無効なiOSデプロイメントバージョン '%0'、32ビットターゲットではiOS 10が最大のデプロイメントターゲットです"
# 'invalid index %0 for pack %1 of size %2'
H1627FB393F43: 'サイズ%2のpack %1に対する無効なインデックス%0'
# "invalid input constraint '%0' in asm"
H09D927559067: "asmにおける無効な入力制約'%0'"
# "invalid input for analyzer-config option '%0', that expects %1 value"
HB14EB9C7A93F: "analyzer-configオプション'%0'の無効な入力、%1値が必要です"
# "invalid input for checker option '%0', that expects %1"
H784B521FDFA9: "checkerオプション'%0'の無効な入力、%1が必要です"
# "invalid input size for constraint '%0'"
H8F6CDB6F0449: "制約'%0'に対する無効な入力サイズ"
# "invalid integral value '%1' in '%0'"
H6E04ED0681B7: "'%0'内の無効な積分値'%1'"
# "invalid invocation of method '%0' on a temporary object while it is in the '%1' state"
H6C0DF8705FCA: "一時オブジェクトが'%1'状態にある間、メソッド'%0'の無効な呼び出し"
# "invalid invocation of method '%0' on object '%1' while it is in the '%2' state"
HD38690B94C13: "オブジェクト'%1'が'%2'状態にある間、メソッド'%0'の無効な呼び出し"
# "invalid library name in argument '%0'"
H64F3D932433A: "引数'%0'内の無効なライブラリ名"
# "invalid line marker flag '2': cannot pop empty include stack"
H37DFD44E19FB: "line markerフラグ'2'が無効: 空のincludeスタックをpopできません"
# "invalid linker name in argument '%0'"
HC2FCA31CF12C: "引数'%0'内の無効なリンカ名"
# 'invalid literal operator parameter type %0, did you mean %1?'
H0C90111229B8: 'リテラルオペレーターのパラメータタイプ%0は無効です、%1を指定されましたか？'
# "invalid lvalue in asm input for constraint '%0'"
H2CA59C9EF59C: "constraint '%0' の asm 入力に無効な lvalue"
# 'invalid lvalue in asm output'
HED6C7D31AA01: 'asm 出力に無効な lvalue'
# 'invalid matrix element type %0'
H9CDCD6DAE3BE: '無効な行列要素の型 %0'
# 'invalid newline character in raw string delimiter; use PREFIX( )PREFIX to delimit raw string'
HF6C358E90110: 'raw string デリミタに改行文字が含まれています; raw string を区切るには PREFIX( )PREFIX を使用してください'
# 'invalid number of arguments to function: %0'
H3D5EA8973A6F: '関数への無効な引数の数: %0'
# "invalid offload arch combinations: '%0' and '%1' (for a specific processor, a feature should either exist in all offload archs, or not exist in any offload archs)"
H92F337A26551: "無効なオフロードアーキテクチャの組み合わせ: '%0' と '%1' (特定のプロセッサの場合、機能はすべてのオフロードアーキテクチャで存在するか、または存在しない必要があります)"
# 'invalid operand number in inline asm string'
H3DCCD1026997: 'インライン asm 文字列の無効なオペランド番号'
# 'invalid operand of type %0 where %1 or a vector of such type is required'
HD52C15C02D70: '必要な型 %1 またはその型のベクターが必要な場所に、型 %0 の無効なオペランド'
# 'invalid operand of type %0 where floating, complex or a vector of such types is required'
HC1A341FFC462: '浮動小数点、複素数、またはそれらの型のベクターが必要な場所に、型 %0 の無効なオペランド'
# 'invalid operand of type %0%select{| where a scalar or vector is required}1'
H848780E5A063: '無効なタイプのオペランド %0%select{| スカラーまたはベクターが必要です}1'
# 'invalid operands to binary expression (%0 and %1)'
HC5560B091967: '二項式 (%0 と %1) への無効なオペランド'
# "invalid option '%0' for %select{cpu_specific|cpu_dispatch}1"
HEFAAB35E81AF: "%select{cpu_specific|cpu_dispatch}1 のための無効なオプション '%0'"
# "invalid option '%0' not of the form <from-file>;<to-file>"
HCB5BB85712F1: "形式 <from-file>;<to-file> でないため、オプション '%0' が無効"
# 'invalid option combination; LASX depends on LSX'
H7E946D645C29: '無効なオプションの組み合わせ; LASX は LSX に依存しています'
# "invalid or misplaced branch protection specification '%0'"
H9377B8FCDAC3: "無効または配置が間違った branch protection 指定 '%0'"
# "invalid or unsupported offload target: '%0'"
H4E7457AF1786: "サポートされていないオフロードターゲット: '%0'"
# "invalid or unsupported rounding mode in '#pragma STDC FENV_ROUND' - ignored"
HDB0B7F11E503: '無効またはサポートされていない丸めモード #pragma STDC FENV_ROUND - 無視されました'
# "invalid output constraint '%0' in asm"
H686C32E03A9D: "asm 内の無効な出力制約 '%0'"
# "invalid output size for constraint '%0'"
HA9017C3CAD23: "制約 '%0' の無効な出力サイズ"
# "invalid output type '%0' for use with gcc tool"
H1AE0ECD8B562: "gccツールで使用する際、無効な出力タイプ '%0'"
# "invalid parameter name: '%0' is a keyword"
HBA4C66D8A8AA: "無効なパラメータ名: '%0' はキーワードです"
# 'invalid parameter type for defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator; found %1, expected %2%select{| or %4}3'
H1333988BA8FC: 'デフォルト化された %select{<ERROR>|同一性|三項比較|同一性|関係}0 比較演算子のパラメータタイプが無効です；%1 が見つかり、%2%select{|または %4}3 が必要です'
# 'invalid parameter type for non-member defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator; found %1, expected class or reference to a constant class'
HEB967961C960: '非メンバのデフォルト化された %select{<ERROR>|同一性|三項比較|同一性|関係}0 比較演算子のパラメータタイプが無効です；%1 が見つかり、クラスまたは定数クラスへの参照が必要です'
# 'invalid pipe access modifier (expecting %0)'
HA4FFF117B821: '無効なパイプ アクセス修飾子（%0 を指定する必要があります）'
# 'invalid position specified for %select{field width|field precision}0'
H5DF564C1B18C: '%select{フィールド幅|フィールド精度}0 の指定された位置が無効です'
# "invalid preprocessing directive%select{|, did you mean '#%1'?}0"
H852ECDD7D2C3: '無効なプリプロセス ディレクティブ%select{|、 ’#%1’ を指定する必要がありますか?}0'
# 'invalid profile : %0'
H35AB0F2CB838: '無効なプロファイル : %0'
# 'invalid protocol qualifiers on non-ObjC type'
H3723A726B37F: 'ObjC 型でない対象にプロトコル修飾子が指定されています'
# 'invalid prototype, variadic arguments are not allowed in OpenCL'
H5E1888FFA26E: '無効なプロトタイプ: OpenCL では可変長引数は許可されていません'
# "invalid range expression of type %0; did you mean to dereference it with '*'?"
H1FCBEB4D2213: 'タイプ %0 の無効なレンジ式です；’*’ でデリファレンスする必要がありますか？'
# "invalid range expression of type %0; no viable '%select{begin|end}1' function available"
H76B630AFA57F: 'タイプ %0 の無効なレンジ式です；有効な ’%select{begin|end}1’ 関数がありません'
# "invalid range following '-' in expected %0"
H99FD9B7E0352: '’-’ の後に続く無効なレンジ式です；%0 が必要です'
# "invalid reduction operator,  expected '+', '*', 'max', 'min', '&', '|', '^', '&&', or '||'"
H3407BE2F5E5D: '無効な減算演算子: ’+’, ’*’, ’max’, ’min’, ’&’, ’|’, ’^’, ’&&’, または ’||’ のいずれかが必要です'
# 'invalid reference to function %0: constraints not satisfied'
H9E6FAF3D6010: '制約が満たされていないため、関数 %0 への参照が無効です'
# 'invalid reinterpretation: sizes of %0 and %1 must match'
HC6E0606A101D: '無効な再解釈: %0 と %1 のサイズが一致しません'
# "invalid resource class specifier '%0' for packoffset, expected 'c'"
H2B96C40BB1F0: 'packoffset のリソース修飾子 ’%0’ が無効です；’c’ を指定する必要があります'
# 'invalid rounding argument'
HD77BD554C068: '無効な四捨五入引数'
# "invalid runtime library name in argument '%0'"
HCC4F20591ADF: '引数 ’%0’ 内の無効なランタイム ライブラリ名'
# 'invalid size value'
H41C03C7DB477: '無効なサイズ値'
# "invalid space specifier '%0' used; expected 'space' followed by an integer, like space1"
HB8CFB0AAB2CD: "無効な space 指定子 '%0' が使用されました；'space' の後に整数を指定する必要があります（例: space1）"
# 'invalid special register for builtin'
H26E533E2D360: 'built-in 関数用の無効な特殊レジスタ'
# 'invalid storage class specifier in function declarator'
HF2FD2E42B318: '関数宣言子内の無効なストレージクラス指定子'
# "invalid string literal, ignoring final '\\'"
H550F921F116D: "無効な文字列リテラル、末尾の'\\'を無視します"
# "invalid suffix '%0' on %select{integer|floating|fixed-point}1 constant"
HFE61994BB7A3: "'%select{整数|浮動小数点|固定小数点}1 定数'の接尾辞 '%0' が無効です"
# 'invalid suffix on literal; C++11 requires a space between literal and identifier'
H3AC3DC712C63: 'リテラルの接尾辞が無効です；C++11 ではリテラルと識別子の間にスペースが必要です'
# "invalid tag %0 on '%1' %select{directive|clause}2"
HB6EF4B837656: "'%1' %select{ディレクティブ|句}2 のタグ %0 が無効です"
# "invalid target ID '%0'; format is a processor name followed by an optional colon-delimited list of features followed by an enable/disable sign (e.g., 'gfx908:sramecc+:xnack-')"
HF2F065F66FFD: "無効なターゲット ID '%0'；フォーマットはプロセッサ名に続いて、オプションでコロン区切りの機能リストを追加し、有効/無効の符号を付ける必要があります（例: 'gfx908:sramecc+:xnack-'）"
# 'invalid target type %0 for dynamic_cast; target type must be a reference or pointer type to a defined class'
HFE4D2B7D8E06: 'dynamic_cast の対象型 %0 が無効です；対象型は定義済みのクラスへの参照またはポインタ型でなければなりません'
# "invalid thread model '%0' in '%1' for this target"
HE75965380195: "このターゲットの '%1' 内で無効なスレッドモデル '%0'"
# "invalid thread pointer reading mode '%0'"
H602D0823E0FB: "無効なスレッドポインタ読み取りモード '%0'"
# 'invalid token at start of a preprocessor expression'
HAAFAB4DB043C: 'プリプロセッサ式の開始部分で無効なトークンが検出されました'
# 'invalid token in macro parameter list'
HA6A8BDC08D89: 'マクロパラメータリスト内の無効なトークン'
# 'invalid transaction abort code'
H75E4D8742736: '無効なトランザクション終了コード'
# 'invalid type %0 as argument of iboutletcollection attribute'
HE41F37E3851B: 'iboutletcollection 属性の引数としての型 %0 が無効です'
# 'invalid type %0 in asm %select{input|output}1'
H2A71CC82E6A7: 'asm %select{入力|出力}1 の中の型 %0 が無効です'
# "invalid type %0 in asm input for constraint '%1'"
H1E6A37C4D619: "制約 '%1' の asm 入力中の型 %0 が無効です"
# 'invalid type %0 is a %select{member|base}1 of %2'
HB6D9D0DC110A: '型 %0 は %2 の %select{メンバ|基底}1 として無効です'
# 'invalid type %0 to %1 operator'
H4C8C1A65C2A4: '無効な%0から%1演算子の型'
# 'invalid universal character'
H73C6676CA247: '無効なユニバーサル文字'
# "invalid unwind library name in argument '%0'"
HD675186A50F6: "引数'%0'に無効なunwindライブラリ名があります"
# "invalid use of '__funcref' keyword outside the WebAssembly triple"
H5B018C340841: "WebAssembly triple外で'__funcref'キーワードを使用することはできません"
# "invalid use of '__super', %0 has no base classes"
HC8BFC8F3D816: "'__super'の無効な使用、%0には基底クラスがありません"
# "invalid use of '__super', this keyword can only be used inside class or member function scope"
H02BB07D5882C: "'__super'の無効な使用、このキーワードはクラスまたはメンバ関数スコープ内でしか使用できません"
# "invalid use of 'this' %select{outside of a non-static member function|in a function with an explicit object parameter}0"
H9633100217CB: 'thisの不正な使用 %select{静的でないメンバ関数の外で|明示的なオブジェクトパラメータを持つ関数内で}0'
# 'invalid use of PPC MMA type'
H23BD562DB2DF: 'PPC MMA型の無効な使用'
# 'invalid use of a cast in an inline asm context requiring an lvalue'
H5D073F64410B: 'インラインアセンブリコンテキストでlvalueが必要な場所でキャストを使用することはできません'
# 'invalid use of incomplete type %0'
H7FE8554F5009: '未完成の型%0の無効な使用'
# 'invalid use of member %0 in %select{static|explicit object}1 member function'
H50EBCD910232: '%0 の不正な使用: %select{静的|明示的なオブジェクト}1 メンバ関数内で'
# 'invalid use of non-static data member %0'
H59D616D352F1: '静的でないデータメンバ%0の無効な使用'
# 'invalid use of pointer to member type after %select{.*|->*}0'
H48A2AD1643D5: '%select{.*|->*}0後のメンバータイプへのポインタの無効な使用'
# 'invalid validator version : %0; format of validator version is "<major>.<minor>" (ex:"1.4")'
H4B1AA82F67A0: "検証バージョン%0の形式は'<major>.<minor>'（例:'1.4'）でなければなりません"
# 'invalid validator version : %0; if validator major version is 0, minor version must also be 0'
HD365448B0579: '検証バージョン%0、メジャーバージョンが0の場合、マイナーバージョンも0でなければなりません'
# 'invalid validator version : %0; validator version must be less than or equal to current internal version'
HED613B352B91: '検証バージョン%0は現在の内部バージョン以下でなければなりません'
# "invalid value '%1' in '%0'"
H7E000E39503F: "'%0'の値'%1'が無効"
# "invalid value '%1' in '%0', expected one of: %2"
H22924648CBBA: "'%0'の値'%1'が無効、%2のいずれかである必要があります"
# "invalid value '%1' in '%0', value must be '%2' or greater"
H38383851595E: "'%0'の値'%1'が無効、%2以上でなければなりません"
# "invalid value '%1' in '%0', value must be 'none' or a positive integer"
H9E8659EA6C7E: "無効な値 '%1' が '%0' で指定されています。値は 'none' か正の整数である必要があります"
# "invalid value '%1' in '%0'; alignment must be a power of 2"
H2DA82E98A2A4: "無効な値 '%1' が '%0' で指定されています。アライメントは2のべき乗である必要があります"
# "invalid value for 'default' clause; expected 'present' or 'none'"
H8D0169FE239F: "デフォルト句の値が無効です。'present'または'none'を指定してください"
# 'invalid vector element type %0'
HEFB9A08F90A0: 'ベクタ要素型 %0 は無効です'
# "invalid version number in '%0'"
H561E007CCA86: " '%0' 内のバージョン番号が無効です"
# "invalid virtual filesystem overlay file '%0'"
HBFF79FC3240A: "仮想ファイルシステムのオーバーレイファイル '%0' が無効です"
# "invoking a pointer to a 'const &' member function on an rvalue is a C++20 extension"
HDCED919CDE9E: "rvalueに対して'const &'メンバ関数へのポインタを呼び出すことはC++20の拡張機能です"
# "invoking a pointer to a 'const &' member function on an rvalue is incompatible with C++ standards before C++20"
H06659E61779A: "C++20以前の標準では、rvalueに対して'const &'メンバ関数へのポインタを呼び出すことは互換性がありません"
# "isa trait '%0' is not known to the current target; verify the spelling or consider restricting the context selector with the 'arch' selector further"
H0ED9A7F36C30: "'isa trait' '%0'は現在のターゲットでは認識されません。スペルを確認するか、'arch'セレクタでコンテキストを制限してください"
# "it could also be property %select{of type %1|without attribute '%1'|with attribute '%1'|with getter %1|with setter %1}0 declared here"
H91A939A34A63: "属性%select{型%1のプロパティ|'%1'属性を持たないプロパティ|'%1'属性を持つプロパティ|ゲッタ%1を持つプロパティ|セッタ%1を持つプロパティ}0 としてここに宣言されている可能性があります"
# 'it delegates to'
H01E41C702CFA: 'デリゲートしています'
# 'it is possible to stop the benchmarking process after some phase'
H3F4A63E67588: 'あるフェーズ後にベンチマーク処理を停止することができます'
# 'iterator step expression %0 evaluates to 0'
H68A0F13C3B50: 'イテレータステップ式 %0 は0に評価されます'
# 'iterator step expression %0 is not the integral expression'
H5E0FE51F5C8D: 'イテレータステップ式 %0 は整数式ではありません'
# "ivar %0 which backs the property is not referenced in this property's accessor"
HB68211D86C75: 'このプロパティのアクセサで、プロパティのバックを支えるiVar %0 が参照されていません'
# "joined argument expects additional value: '%0'"
H67B5A91D2948: "連結引数は追加の値 '%0' を必要とします"
# "joined argument treated as '%0'; did you mean '%1'?"
HAC9E756384DA: "連結引数は'%0'として扱われます。'%1'を意味しましたか？"
# 'jump bypasses OpenMP structured block'
H38D141B68E15: 'OpenMP構造化ブロックの初期化をジャンプで飛び越えています'
# 'jump bypasses auto release push of @autoreleasepool block'
H673B2CE5E964: '@autoreleasepool ブロックのauto release pushの初期化をジャンプで飛び越えています'
# 'jump bypasses initialization of @catch block'
HBE63405914D4: '@catch ブロックの初期化をジャンプで飛び越えています'
# 'jump bypasses initialization of @finally block'
HC258EB27DC7D: '@finally ブロックの初期化をジャンプで飛び越えています'
# 'jump bypasses initialization of @synchronized block'
HB49518EF658F: '@synchronized ブロックの初期化をジャンプで飛び越えています'
# 'jump bypasses initialization of @try block'
H4F2203657B83: '@try ブロックの初期化をジャンプで飛び越えています'
# 'jump bypasses initialization of VLA type alias'
H06AE800C9022: 'VLA型別名の初期化をジャンプで飛び越えています'
# 'jump bypasses initialization of VLA typedef'
H539D32051794: 'VLA typedefの初期化をジャンプで飛び越えています'
# 'jump bypasses initialization of __except block'
H8945BA31631C: '__except ブロックの初期化をジャンプで飛び越えています'
# 'jump bypasses initialization of __finally block'
HDC8606BFB8A0: '__finally ブロックの初期化をジャンプで飛び越えています'
# 'jump bypasses initialization of __strong variable'
H4091D3DFA80B: '__strong変数の初期化をジャンプで飛び越えています'
# 'jump bypasses initialization of __try block'
H17A1FDC40633: '__try ブロックの初期化をジャンプで飛び越えています'
# 'jump bypasses initialization of __weak variable'
H2D2E5414450F: '__weak変数の初期化をジャンプで飛び越えています'
# 'jump bypasses initialization of catch block'
H1AD4DA299533: 'catch ブロックの初期化をジャンプで飛び越えています'
# 'jump bypasses initialization of non-POD variable'
H7894E3C8480C: '非POD型の変数の初期化をジャンプで飛び越えています'
# 'jump bypasses initialization of try block'
H35C99F3D2CF6: 'try ブロックの初期化をジャンプで飛び越えています'
# 'jump bypasses initialization of variable length array'
HD2CC21B5B2B9: '可変長配列 (VLA) の初期化をジャンプで飛び越えています'
# 'jump bypasses initialization of variable of non-trivial C struct type'
H8DC117DB27D9: '非単純なC構造体型の変数の初期化をジャンプで飛び越えています'
# 'jump bypasses initialization of variable with __attribute__((cleanup))'
H816408F197AB: 'ジャンプが__attribute__((cleanup))を持つ変数の初期化を迂回しました'
# 'jump bypasses setup of __block variable'
H8FF055D54D20: 'ジャンプが__block変数のセットアップを迂回しました'
# 'jump bypasses variable initialization'
HDE484302CFDD: 'ジャンプが変数の初期化を迂回しました'
# 'jump bypasses variable with a non-trivial destructor'
H65EAD2757089: 'ジャンプが非自明なデストラクタを持つ変数を迂回しました'
# 'jump enters Objective-C fast enumeration loop'
H0B68A5227D3D: 'ジャンプがObjective-Cの高速列挙ループに入ります'
# 'jump enters a statement expression'
HAF0C1FFF2BB0: 'ジャンプがステートメント式に入ります'
# 'jump enters controlled statement of consteval if'
H9FCC3E0998D5: 'ジャンプがconsteval ifの制御された文に入ります'
# 'jump enters controlled statement of constexpr if'
H53B0DD3B4BCF: 'ジャンプがconstexpr ifの制御された文に入ります'
# 'jump enters controlled statement of if available'
H0D6B49E1C06A: 'ジャンプがif availableの制御された文に入ります'
# 'jump enters lifetime of a compound literal that is non-trivial to destruct'
H84D2F4FDA1F2: 'ジャンプが非自明なデストラクタを持つ複合リテラルの生存期間に入ります'
# 'jump enters lifetime of block which captures a C struct that is non-trivial to destroy'
HB60961C86BE4: 'ジャンプが破棄が非自明なC構造体をキャプチャするブロックの生存期間に入ります'
# 'jump enters lifetime of block which captures a destructible C++ object'
HFA59EFDF1B62: 'ジャンプが破棄可能なC++オブジェクトをキャプチャするブロックの生存期間に入ります'
# 'jump enters lifetime of block which strongly captures a variable'
H2E28FE1D13B9: 'ジャンプが変数を強制キャプチャするブロックの生存期間に入ります'
# 'jump enters lifetime of block which weakly captures a variable'
H8ED7B1ED0204: 'ジャンプが変数を弱参照キャプチャするブロックの生存期間に入ります'
# 'jump exits @catch block'
H00823EBB1453: '@catchブロックを退出するジャンプ'
# 'jump exits @finally block'
HDE9FECD28D12: '@finallyブロックを退出するジャンプ'
# 'jump exits @synchronized block'
H2C2C500585D3: '@synchronizedブロックを退出するジャンプ'
# 'jump exits @try block'
H60631B3B104F: '@tryブロックを退出するジャンプ'
# 'jump exits __except block'
HF0ECDC1D667A: '__exceptブロックを退出するジャンプ'
# 'jump exits __finally block'
HEF15A26AC2B4: '__finallyブロックを退出するジャンプ'
# 'jump exits __try block'
HA371EC6EABEF: 'ジャンプが__tryブロックを脱出しています'
# 'jump exits autoreleasepool block'
HFA1102E13121: 'ジャンプがautoreleasepoolブロックを脱出しています'
# 'jump exits catch block'
HB15A540E97C0: 'ジャンプがcatchブロックを脱出しています'
# 'jump exits lifetime of a compound literal that is non-trivial to destruct'
H581CCAF33BA1: 'ジャンプが破棄が非自明なコンパウンドリテラルのライフタイムを脱出しています'
# 'jump exits lifetime of block which captures a C struct that is non-trivial to destroy'
H145F09CDB728: 'ジャンプが破棄が非自明なC構造体をキャプチャするブロックのライフタイムを脱出しています'
# 'jump exits lifetime of block which captures a destructible C++ object'
HFD90BDF2A71A: 'ジャンプが破壊可能なC++オブジェクトをキャプチャするブロックのライフタイムを脱出しています'
# 'jump exits lifetime of block which strongly captures a variable'
H633C0158D8CE: 'ジャンプが変数を強制キャプチャするブロックのライフタイムを脱出しています'
# 'jump exits lifetime of block which weakly captures a variable'
H3C3B445ACF96: 'ジャンプが変数を弱参照キャプチャするブロックのライフタイムを脱出しています'
# 'jump exits scope of OpenMP structured block'
H3960249ABF56: 'ジャンプがOpenMP構造化ブロックのスコープを脱出しています'
# 'jump exits scope of __block variable'
HCAFFF794B0B7: 'ジャンプが__block変数のスコープを脱出しています'
# 'jump exits scope of __strong variable'
H09130C2189DF: 'ジャンプが__strong変数のスコープを脱出しています'
# 'jump exits scope of __weak variable'
H425A195D6F14: 'ジャンプが__weak変数のスコープを脱出しています'
# 'jump exits scope of lifetime-extended temporary with non-trivial destructor'
H18BAD42D7AAF: 'ジャンプが非自明なデストラクタを持つライフタイム延長一時オブジェクトのスコープを脱出しています'
# 'jump exits scope of variable with __attribute__((cleanup))'
H4BF0CCE50F51: 'ジャンプが__attribute__((cleanup))を持つ変数のスコープを脱出しています'
# 'jump exits scope of variable with non-trivial destructor'
HD66C6E5AB564: 'ジャンプがデストラクタが非自明な変数のスコープを脱出しています'
# 'jump exits try block'
HE15267C61E24: 'ジャンプがtryブロックを脱出しています'
# 'jump from switch statement to this case label is incompatible with C++98'
HFD45DFD4341B: 'このcaseラベルへのswitchステートメントからのジャンプはC++98と互換性ありません'
# 'jump from this %select{indirect|asm}0 goto statement to one of its possible targets is incompatible with C++98'
H6B5196F09490: 'この%select{indirect|asm}0 gotoステートメントからその可能なターゲットの一つにジャンプするのはC++98と互換性ありません'
# 'jump from this goto statement to its label is a Microsoft extension'
HF443D2C187C8: 'このgotoステートメントのラベルへのジャンプはMicrosoft拡張機能です'
# 'jump from this goto statement to its label is incompatible with C++98'
H91A60091F523: 'このgotoステートメントのラベルへのジャンプはC++98と互換性ありません'
# 'jump out of __finally block has undefined behavior'
HC63318A29EFB: '__finally ブロックからジャンプすることは未定義の動作です'
# 'jump tables support (default=basic)'
H004CDF2FB54A: 'ジャンプテーブルのサポート (デフォルト=basic)'
# 'just the yaml representation of the profile'
H77CB9F525531: 'プロファイルのYAML表現のみ'
# 'keep going after reporting a UMR'
H5D280A550689: 'UMRを報告した後もコンパイルを継続'
# 'keep no-op instructions. By default they are removed.'
H5294B5B42559: 'no-op命令を保持する。デフォルトではこれらは削除されます。'
# 'keep or generate .debug_aranges section if .gdb_index is written'
HF46D8AA36DF8: '.gdb_indexが書き込まれた場合、.debug_arangesセクションを保持または生成します'
# 'kernel call to non-global function %0'
HE2C1F06E4669: '非グローバル関数%0に対するカーネル呼び出し'
# 'kernel function %0 is a member function; this may not be accepted by nvcc'
H6C2BA696CEAF: 'カーネル関数%0はメンバ関数です。nvccでは受け付けられない可能性があります'
# 'kernel function %0 must be a free function or static member function'
H16FEF3B5D436: 'カーネル関数%0はフリーファンクションまたは静的メンバ関数でなければなりません'
# 'kernel function type %0 must have void return type'
H95AC5DFCBCA0: 'カーネル関数の型%0はvoidの戻り値型でなければなりません'
# 'kernel functions cannot be class members'
H49F7A4460E40: 'カーネル関数はクラスメンバとして使用できません'
# 'kernel functions cannot be declared static'
H4969597F9236: 'カーネル関数はstaticとして宣言できません'
# 'kernel functions cannot be used in a template declaration, instantiation or specialization'
HD5AD84DAA9C6: 'カーネル関数はテンプレート宣言、インスタンチエーション、または特化で使用できません'
# 'kernel must have void return type'
H2245CF70F0F9: 'カーネルはvoidの戻り値型でなければなりません'
# 'kernel parameter cannot be declared as a pointer to a pointer'
HA03E5339986E: 'カーネルパラメータはポインタへのポインタとして宣言できません'
# "keyword '%0' will be made available as an identifier %select{here|for the remainder of the translation unit}1"
HB2136B9BC89D: "キーワード'%0'は%select{ここ|翻訳単位の残りの部分}1で識別子として利用可能になります"
# 'keyword is hidden by macro definition'
HB53596605CAF: 'マクロ定義によってキーワードが隠蔽されています'
# 'kind mapping string to set kind precision'
HE046AE1AA112: '種類マッピング文字列で種類の精度を設定'
# "known but unsupported action '%1' for '#pragma %0' - ignored"
H07B6796F45BE: "サポートされていないアクション'%1'が'#pragma %0'で指定されました - 無視されました"
# "label '%0' is reserved: use a different label name for -X<label>"
H0A75EFF64B4C: "ラベル'%0'は予約済みです: -X<label>で異なるラベル名を使用してください"
# 'label at end of compound statement is a C++23 extension'
H696C9202732B: '複合ステートメントの末尾のラベルはC++23の拡張機能です'
# 'label at end of compound statement is a C23 extension'
H24E471EE8FE1: '複合ステートメントの末尾のラベルはC23の拡張機能です'
# 'label at end of compound statement is incompatible with C standards before C23'
H8E280A51EBD5: 'C23以前のCの規格では複合ステートメントの末尾のラベルは互換性がありません'
# 'label at end of compound statement is incompatible with C++ standards before C++23'
H1F208E16CB25: 'C++23以前のC++の規格では複合ステートメントの末尾のラベルは互換性がありません'
# 'label followed by a declaration is a C23 extension'
HE476C0C2BE2F: '宣言に続くラベルはC23の拡張機能です'
# 'label followed by a declaration is incompatible with C standards before C23'
H8299673D895A: 'C23以前のCの規格では宣言に続くラベルは互換性がありません'
# 'lambda %0 is inaccessible due to ambiguity:%1'
H165915C96E61: 'ラムダ%0は曖昧さのためアクセス不能です:%1'
# 'lambda call operator should not be explicitly specialized or instantiated'
H3541695AB458: 'ラムダのコールオペレーターは明示的に特殊化またはインスタンス化しないでください'
# 'lambda cannot be both mutable and static'
H057D935E257D: 'ラムダはmutableとstaticの両方を指定できません'
# 'lambda cannot be declared %0'
H523BA4919111: 'ラムダは"%0"として宣言できません'
# 'lambda capture %0 is not %select{used|required to be captured for this use}1'
HED12D4324492: 'ラムダのキャプチャ%0は%select{使用されていません|この使用のためにキャプチャされる必要があります}1'
# 'lambda closure types are non-literal types before C++17'
H3BDD817E383F: 'C++17以前ではラムダクロージャータイプはリテラルタイプではありません'
# 'lambda expression begins here'
H0582B6A6C9FD: 'ラムダ式はここから始まります'
# 'lambda expression in an unevaluated operand'
H2B5A38CCEDAB: '評価されないオペランド内のラムダ式'
# 'lambda expression in default argument cannot capture any entity'
H31423DFF8FC2: 'デフォルト引数内のラムダ式はいかなるエンティティもキャプチャできません'
# 'lambda expressions are incompatible with C++98'
HAE0AFEA72154: 'ラムダ式はC++98と互換性がありません'
# 'lambda template parameter list cannot be empty'
H33C909CD1D80: 'ラムダテンプレートパラメータリストは空にできません'
# 'lambda without a parameter clause is a C++23 extension'
HD70498A5F3EC: 'パラメータ句のないラムダはC++23の拡張機能です'
# 'lambdas are a %select{C++11|clang HLSL}0 extension'
HD58884723190: 'ラムダは%select{C++11|clang HLSL}0の拡張機能です'
# "language not recognized: '%0'"
H102C1DB9CB0E: '認識できない言語:"%0"'
# 'large atomic operation may incur significant performance penalty; the access size (%0 bytes) exceeds the max lock-free size (%1 bytes)'
H31655F77BD73: '大規模なアトミック操作は大幅なパフォーマンス低下を引き起こす可能性があります；アクセスサイズ (%0 バイト) は最大ロックフリー サイズ (%1 バイト) を超えています'
# 'layout blocks in reverse order'
H19EE0FFEC518: 'レイアウト ブロックが逆順で配置されています'
# 'lcov tracefile output'
HCE669C9CA888: 'lcov トレースファイル出力'
# 'left hand operand of type %0 to compound assignment cannot be truncated when used with right hand operand of type %1'
H00D9FE7F4F87: '右辺の型%1と組み合わせる際に、左辺の型%0の複合代入オペランドが切り捨てられません'
# 'left hand operand to %0 must be a %select{|pointer to }1class compatible with the right hand operand, but is %2'
HE8A81161D486: '%0 の左辺オペランドは%select{|ポインタ型の }1クラスで右辺オペランドと互換性をもたねばなりませんが、%2となっています'
# "left hand side of assignment operation('%0') must match one side of the sub-operation on the right hand side('%1' and '%2')"
HA99FEEFA45D5: "代入演算の左辺('%0')は右辺のサブ演算('%1'と'%2')のいずれか一方と一致する必要があります"
# 'left operand of comma operator has no effect'
H1D36CC5E4D5A: 'カンマ演算子の左辺オペランドは効果がありません'
# 'left shift of negative value %0'
HF788BD55C118: 'ネガティブ値%0の左シフト'
# "length modifier '%0' results in undefined behavior or no effect with '%1' conversion specifier"
HDCB24BE7C9E8: "長さ修飾子'%0'は'%1'変換仕様子との使用時に未定義動作または効果なしを引き起こします"
# 'libclc builtin preparation tool\n'
H8679FDE4DA62: 'libclc組み込み準備ツール\n'
# 'limit number of targets to consider when doing indirect call promotion on calls. 0 = no limit'
HD2EF861DC5DB: '間接呼び出しプロモーション時に考慮するターゲット数の上限を設定（0=無制限）'
# 'limit number of targets to consider when doing indirect call promotion on jump tables. 0 = no limit'
H039F79707FDF: 'ジャンプテーブルの間接呼び出しプロモーション時に考慮するターゲット数の上限を設定（0=無制限）'
# 'limit number of targets to consider when doing indirect call promotion. 0 = no limit'
H5880E8C77FBD: '間接呼び出しプロモーション時に考慮するターゲット数の上限を設定（0=無制限）'
# 'limit optimizations to functions from the list'
HF1AAD3BC1D5B: '指定された関数リストに限定して最適化を実行'
# 'limit optimizations to functions from the list (non-regex)'
H4820DAC9F83B: '指定された正規表現を使用しない関数リストに限定して最適化を実行'
# 'line marker directive requires a positive integer argument'
H8A0833C758AF: '行マーカー指令には正の整数引数が必要です'
# 'line splicing in Doxygen comments are not supported'
HD6510289D84D: 'Doxygen コメントでの行の結合はサポートされていません'
# "linking module '%0': %1"
H78786E2D2737: "モジュール'%0'のリンカ処理: %1"
# 'linking options'
H1E4F081C74A1: 'リンカ オプション'
# 'list item of type %0 is not valid for specified reduction operation: unable to provide default initialization value'
H5FEA755CA374: '指定された減少演算に有効な型%0のリスト アイテムはありません: デフォルト初期化値を提供できません'
# 'list of functions to always consider for inlining'
H00FB00D60661: 'インライン化対象として常に考慮する関数リスト'
# 'list of functions to apply frame opts'
H723CBEBF937F: 'フレーム最適化を適用する関数リスト'
# 'list of functions to core dump on (debugging)'
HFF95EE476741: '(デバッグ用)コアダンプ対象の関数リスト'
# 'list of functions to enable ICP for'
H4EBB92971A75: 'ICPを有効にする関数リスト'
# 'list of functions to never consider for inlining'
HE127B8F1CD43: 'インライン化対象として絶対に考慮しない関数リスト'
# 'list of functions to pad with amount of bytes'
H296C1F5DDCF1: 'バイト数分のパディングを追加する関数リスト'
# 'list of functions to print'
H1C3AE7A6EC95: '出力対象の関数リスト'
# 'list of functions to skip'
HED4CB34A956C: 'スキップする関数リスト'
# 'list of functions with call sites for which to specialize memcpy() for size 1'
HD7F5B54EFF49: 'memcpy()のサイズ1用に特殊化する呼び出し元を持つ関数リスト'
# "list of sections containing functions used for hugifying hot text. BOLT makes sure these functions are not placed on the same page as the hot text. (default='.stub,.mover')."
H07A4ADB5443D: "hotテキスト用にhugifyする関数を含むセクションリスト。BOLTはこれらの関数がhotテキストと同じページに配置されないようにします。(デフォルト='.stub,.mover')"
# 'list of sections to reorder'
HE8B5B16B7FA7: '再配置対象のセクションリスト'
# 'list of symbol names that can be reordered'
H6F9EE9EC82ED: '再配置可能なシンボル名リスト'
# 'list of symbol names that cannot be reordered'
H9016DB56BAB4: '再配置不可のシンボル名リスト'
# 'literal construction method %0 has incompatible signature'
H9A98E6827407: 'リテラル構築メソッド%0のシグネチャが不整合です'
# 'literal operator %0 must be in a namespace or global scope'
H6F0C93D8CF92: 'リテラルオペレータ%0は名前空間またはグローバルスコープに置かなければなりません'
# 'literal operator cannot have a default argument'
H2D253A373F0C: 'デフォルト引数をもつリテラルオペレータはできません'
# 'literal operator must have C++ linkage'
HACF64718BD51: 'リテラルオペレータはC++リンケージをもたなければなりません'
# 'literal operator template cannot have any parameters'
HDB57FAFF64D9: 'リテラルオペレータテンプレートはパラメータをもてません'
# 'literal operators are incompatible with C++98'
HC63AE1FBA425: 'リテラルオペレータはC++98と互換性ありません'
# 'lldb'
H23F2598B46BF: 'lldb'
# 'llvm .bc -> .bc modular optimizer and analysis printer\n'
H5E0E5487AF50: 'llvm .bc -> .bc モジュール最適化ツールと分析出力ツール\n'
# 'llvm .bc -> .ll disassembler\n'
H6C7F6E9C06C4: 'llvm .bc -> .ll ディスアセンブラ\n'
# 'llvm .ll -> .bc assembler\n'
HD4712D9BC53E: 'llvm .ll -> .bc アセンブラ\n'
# 'llvm LTO linker\n'
H2892DC655E08: 'llvm LTOリンカ\n'
# 'llvm MC-JIT tool\n'
H06636F581609: 'llvm MC-JITツール\n'
# 'llvm SPGO profile generator\n'
H701BD947180F: 'llvm SPGOプロファイル生成ツール\n'
# 'llvm codegen stress-tester\n'
HA26868605BE5: 'llvm コード生成ストレステスター\n'
# 'llvm extractor\n'
HFF048809A3CA: 'llvm エクストラクター\n'
# 'llvm host machine instruction characteristics measurment and analysis.\n'
HF3F3BF01E352: 'llvm ホストマシンの命令特性測定と分析ツール。\n'
# 'llvm interpreter & dynamic compiler\n'
H0649CD7E70C5: 'llvm インタプリタと動的コンパイラー\n'
# 'llvm jit event listener test utility\n'
HC7AAB55CF667: 'llvm jitイベントリスナーテストユーティリティ\n'
# 'llvm jitlink tool'
H2709B44451E8: 'LLVM jitlink ツール'
# 'llvm linker\n'
HC9DC12DE7069: 'llvm リンカ\n'
# 'llvm machine code performance analyzer.\n'
H684FDD543DA3: 'llvm マシンコードパフォーマンス分析ツール。\n'
# 'llvm machine code playground\n'
H2F51084FBDF0: 'llvm マシンコード実験環境\n'
# 'llvm system compiler\n'
H8181CA7521BB: 'llvm システムコンパイラ\n'
# 'llvm tool to verify use-list order\n'
HAC60F05F36A9: 'llvm use-list順序検証ツール\n'
# 'llvm-as Options'
HCEBF82BEB0E9: 'llvm-as オプション'
# 'llvm-bcanalyzer file analyzer\n'
HECC62C366128: 'llvm-bcanalyzer ファイルアナライザ\n'
# 'llvm-boltdiff - BOLT binary diff tool\n\nEXAMPLE: llvm-boltdiff -data=a.fdata -data2=b.fdata exec1 exec2\n'
HB49452FEF405: 'llvm-boltdiff - BOLTバイナリ差分ツール\n\nEXAMPLE: llvm-boltdiff -data=a.fdata -data2=b.fdata exec1 exec2\n'
# 'llvm-cat Options'
H3A2E2CA997D5: 'llvm-cat オプション'
# 'llvm-exegesis analysis options'
H89DF2607CBEA: 'llvm-exegesis 分析オプション'
# 'llvm-exegesis benchmark options'
HC43701CE0D82: 'llvm-exegesis ベンチマークオプション'
# 'llvm-exegesis options'
HAF6D3F27C196: 'llvm-exegesis オプション'
# 'llvm-extract Options'
H25F0C853A66B: 'llvm-extract オプション'
# 'llvm-omp-kernel-replay Options'
H90111C7D3334: 'llvm-omp-kernel-replay オプション'
# 'llvm-opt-report options'
HCF4237251086: 'llvm-opt-report オプション'
# 'llvm-reduce options'
H9B15C3D059EC: 'llvm-reduce オプション'
# 'load the input file as a Toy source.'
H8076D5B81C5F: '入力ファイルをToyソースとして読み込みます。'
# 'load the input file as an MLIR file'
HAC00602D295B: '入力ファイルをMLIRファイルとして読み込みます'
# 'loader options'
HA2203CDD473C: 'ローダーオプション'
# 'local %select{struct|interface|union|class|enum}0 cannot be declared __module_private__'
H4E0562614A60: 'ローカル %select{struct|interface|union|class|enum}0 を __module_private__ で宣言することはできません'
# 'local declaration nearly matches'
HA030BEFE649C: 'ローカル宣言がほぼ一致しています'
# 'local declaration of %0 hides instance variable'
H09900D49A0E3: 'ローカル宣言 %0 はインスタンス変数を隠蔽します'
# 'local type %0 as template argument is incompatible with C++98'
H6116FD3EFF04: 'テンプレート引数としてのローカル型 %0 は C++98 と互換性がありません'
# "local variable '%0' should not be used in 'declare target' directive;"
HF2D2B034481C: "'declare target' ディレクティブでローカル変数 '%0' を使用してはいけません;"
# "local variable cannot be declared 'constinit'"
HE35DCF249418: "ローカル変数を 'constinit' で宣言することはできません"
# "locking '%0' to build module '%1'"
H36ABFAB03219: "モジュール '%1' を構築するため '%0' をロックしています"
# 'logical expression with vector %select{type %1 and non-vector type %2|types %1 and %2}0 is only supported in C++'
H1200F428FBB0: 'ベクター %select{型%1 とベクターでない型%2|型%1 と%2}0 の論理式はC++でのみサポートされています'
# 'logical not is only applied to the left hand side of this %select{comparison|bitwise operator}0'
H9E8ECD267F25: 'この%select{比較演算子|ビット単位の演算子}0の左辺のみに論理否定が適用されます'
# 'lookup from the current scope refers here'
H9AFA3EAEA36F: '現在のスコープからの参照はここを指します'
# 'lookup in the object type %0 refers here'
H3FD57FB46E2B: '%0のオブジェクト型での参照はここを指します'
# 'lookup of %0 in member access expression is ambiguous'
H52F57D0BB44E: 'メンバーアクセス式での%0の参照が曖昧です'
# 'lookup of %0 in member access expression is ambiguous; using member of %1'
H632E112FD2AD: 'メンバーアクセス式での%0の参照が曖昧です；%1のメンバーを使用します'
# "loop iteration variable in the associated loop of 'omp %1' directive may not be %0, predetermined as %2"
H777624FA6F75: 'omp %1 ディレクティブの関連ループ内のループ反復変数は、事前に%2と定義されているため%0にすることができません'
# 'loop step is expected to be %select{negative|positive}0 due to this condition'
HF9B9B19EF744: 'この条件によりループステップは%select{負|正}0である必要があります'
# 'loop to be fully unrolled must have a constant trip count'
HF58CAD452050: '完全にアンロールされるループには定数の反復回数が必要です'
# 'loop variable %0 %diff{of type $ binds to a temporary constructed from type $|binds to a temporary constructed from a different type}1,2'
H8E540E772339: 'ループ変数%0は%diff{タイプ$から作成された一時的なものにバインドされます|異なるタイプの一時的なものにバインドされます}1,2'
# 'loop variable %0 binds to a temporary value produced by a range of type %1'
HDD2F7E9780FE: '%0のループ変数は、%1型のレンジによって生成された一時的な値にバインドされます'
# 'loop variable %0 creates a copy from type %1'
H0EB738A6DA64: '%0のループ変数は%1型からのコピーを作成します'
# "loop variable %0 may not be declared %select{'extern'|'static'|'__private_extern__'|'auto'|'register'|'constexpr'|'thread_local'}1"
HD1C2B82FE9FA: "ループ変数%0は%select{'extern'|'static'|'__private_extern__'|'auto'|'register'|'constexpr'|'thread_local'}1として宣言することはできません"
# "loop variable of loop associated with an OpenACC '%0' construct must be of integer, pointer, or random-access-iterator type (is %1)"
HDE685F11E1FA: "OpenACC '%0'構造に関連するループのループ変数は整数、ポインタ、またはランダムアクセスイテレータ型でなければなりません（%1です）"
# 'loop will run at most once (loop increment never executed)'
H41A7771F3080: 'このループは最大1回実行されます（ループのインクリメントは実行されません）'
# "loop with a '%0' clause may not exist in the region of a '%1' clause%select{| on a '%3' construct}2"
H31D69B81DD7A: "'%0'句を含むループは、'%1'句の%select{|'%3'構造上の}2領域内に存在できません"
# 'lower transpose without using a runtime call'
H1DC7FFF629C0: 'ランタイムコールを使用せずに下位トランスポーズを実行'
# 'mac68k alignment pragma is not supported on this target'
H13A22B895D9E: 'mac68kアライメントpragmaはこのターゲットではサポートされていません'
# 'macro %0 defined here'
H224BD0DEAAD4: 'マクロ%0はここに定義されています'
# 'macro %0 has been marked as deprecated%select{|: %2}1'
HB9E9BBB38434: 'マクロ%0は非推奨としてマークされています%select{|: %2}1'
# 'macro %0 has been marked as final and should not be %select{undefined|redefined}1'
H416ADCAF4BDC: 'マクロ%0は最終的としてマークされており、%select{未定義に|再定義して}1はしないでください'
# 'macro %0 has been marked as unsafe for use in headers%select{|: %2}1'
H0BD2BA6647E5: 'マクロ%0はヘッダーでの使用に危険とマークされています%select{|: %2}1'
# "macro '%0' contains embedded newline; text after the newline is ignored"
HCA29C3134207: "マクロ'%0'には埋め込まれた改行が含まれています; 改行後のテキストは無視されます"
# "macro '%0' was %select{defined|undef'd}1 in the AST file '%2' but %select{undef'd|defined}1 on the command line"
HEF8B87D78B88: "マクロ'%0'はASTファイル'%2'で%select{定義|undef'd}1されていましたが、コマンドラインでは%select{undef'd|defined}1されています"
# "macro expansion producing 'defined' has undefined behavior"
H6CE80CBEAD13: "'defined'を生成するマクロ展開は未定義の動作です"
# 'macro is not used'
HB7A93ECCBE4F: 'マクロは使用されていません'
# "macro marked '%select{deprecated|restrict_expansion|final}0' here"
H36EC3D2C5C8F: "macro marked '%select{非推奨|拡張制限|最終的}0' here"
# 'macro name is a reserved identifier'
H75F2505E76F7: 'マクロ名は予約済み識別子です'
# 'macro name missing'
H64036DCA4179: 'マクロ名がありません'
# 'macro name must be an identifier'
HA83E076252EC: 'マクロ名は識別子でなければなりません'
# "macro was %select{defined|#undef'd}0 here"
H90411BE5521B: "マクロはここに%select{定義|#undef'd}0されました"
# 'magnitude of floating-point constant too large for type %0; maximum is %1'
HC45BAE211EEF: '浮動小数点定数の大きさが型%0の最大値%1を超えています'
# 'magnitude of floating-point constant too small for type %0; minimum is %1'
H77948F2AADFE: '浮動小数点定数の大きさが型%0の最小値%1を下回っています'
# 'main cannot be declared as a variable %select{in the global scope|with C language linkage}0'
HDFAAFDDA66C4: 'mainは変数として%select{グローバルスコープで|C言語のリンケージを指定して}0宣言できません'
# 'main file cannot be included recursively when building a preamble'
HFA8D0D05FC55: 'メインファイルはプレアンブルを構築中に再帰的に包含できません'
# 'make jump tables size smaller at the cost of using more instructions at jump sites'
HFB74BDFA805D: 'ジャンプテーブルのサイズを小さくする代わりに、ジャンプサイトでより多くの命令を使用します'
# 'make the interpreter print every volatile load and store'
H89B411120801: 'インタプリタにvolatileロードとストアをすべて表示させる'
# "malformed block record in PCH file: '%0'"
H89FF1C99B4CC: "PCHファイル'%0'のブロックレコードが不正です"
# "malformed or corrupted AST file: '%0'"
HCB00083D669D: "破損または不正なASTファイル'%0'です"
# "malformed sanitizer coverage allowlist: '%0'"
HA08307F61916: "不正なsanitizer coverage allowlist '%0'です"
# "malformed sanitizer coverage ignorelist: '%0'"
HF4CE0A42147C: "不正なsanitizer coverage ignorelist '%0'です"
# "malformed sanitizer ignorelist: '%0'"
H98473149CB24: "不正なsanitizer ignorelist '%0'です"
# "malformed sanitizer metadata ignorelist: '%0'"
H7E49790904E8: "不正なsanitizerメタデータignorelist '%0'です"
# 'mangled name of %0 will change in C++17 due to non-throwing exception specification in function signature'
HC8027193700F: '%0のメタ名は、関数シグネチャにおけるスローしない例外指定によりC++17で変更されます'
# "map type '%0' is previous specified here"
H3204C79CA043: "マップタイプ'%0'はここに以前に指定されています"
# 'map type is already specified'
HF4D36EA9229E: 'マップタイプはすでに指定されています'
# "map type modifier '%0' is not allowed for '#pragma omp %1'"
H5A1E07271479: "'#pragma omp %1'に対してマップタイプ修飾子'%0'は許可されていません"
# 'mapper type must be of struct, union or class type'
H3D3958379C94: 'マッパータイプは構造体、共用体、またはクラス型でなければなりません'
# 'mapping of union members is not allowed'
HD27CBEC61BC1: '共用体メンバのマッピングは許可されていません'
# "mark %0 as '%select{final|sealed}1' to silence this warning"
HF7273FC85EE1: '%0を"%select{final|sealed}1"としてマークしてこの警告を抑制してください'
# "mark 'operator==' as const or add a matching 'operator!=' to resolve the ambiguity"
H5A25A1F05320: "'operator=='をconstとしてマークするか、対応する'operator!='を追加してください"
# "mark function boundaries with break instruction to make sure we accidentally don't cross them"
H5B830E6175D2: '関数境界をbreak命令でマークし、誤って境界を越えないようにします'
# 'marked %0 here'
HE33E97AC0225: 'ここに%0がマークされました'
# "marked as 'declare variant' here"
H721AFFF82622: "'declare variant'としてここにマークされました"
# "marked as 'device_type(%0)' here"
HF283C800233B: "'device_type(%0)'としてここにマークされました"
# 'mask type size must be between 1-byte and 8-bytes'
HA5CB60FF0FBF: 'マスクタイプのサイズは1バイトから8バイトの間でなければなりません'
# 'match functions in binary 2 to binary 1 if they have the same hash of a function in binary 1'
HAF6822E35564: 'バイナリ2の関数を、バイナリ1の関数と同じハッシュを持つ場合、バイナリ1に一致させます'
# "math errno enabled by '%0' after it was implicitly disabled by '%1', this may limit the utilization of the vector library"
HE93B3822306D: "数学errnoが'%1'によって暗黙のうちに無効化された後に'%0'によって有効化されました。これによりベクターライブラリの利用が制限される可能性があります"
# 'mathematical notation character <U+%0> in an identifier is a Clang extension'
H0378BC9B5A74: '識別子内の数学表記文字<U+%0>はClangの拡張機能です'
# 'matrix %select{row|column}0 index is not an integer'
H46FD8A206DB4: '行列の%select{row|column}0インデックスは整数ではありません'
# 'matrix %select{row|column}0 index is outside the allowed range [0, %1)'
H847B8076D2C2: '行列の%select{row|column}0インデックスは許可された範囲[0, %1)の外です'
# 'matrix row and column subscripts cannot be separated by any expression'
H5ED6E19FD5C5: '行列の行と列の添字は、いかなる式で分離できません'
# 'matrix types extension is disabled. Pass -fenable-matrix to enable it'
H4F1847B4A9E6: '行列タイプの拡張機能は無効化されています。有効にするには-fenable-matrixを指定してください'
# 'max depth when checking alias info in GatherAllAliases()'
HB91994902F54: 'GatherAllAliases()でエイリアス情報をチェックする際の最大深さ'
# 'max number of bytes for the function to be considered small for inlining purposes'
H5D6C3AFD428B: 'インラインの目的で関数が小さなと見なされる最大バイト数'
# 'max stack depth tracing'
H293E22C2DAE9: '最大スタック深度トレース'
# 'maxclusterrank requires sm_90 or higher, CUDA arch provided: %0, ignoring %1 attribute'
H49A2942ECE44: 'maxclusterrankはsm_90以降が必要です。提供されたCUDAアーキテクチャ:%0、%1属性を無視します'
# 'maximal number of instructions to instrument in any given BB'
H65055BD64342: '任意のBBにおいてインストゥルメンテーションする最大命令数'
# 'maximum address considered valid for heatmap (default 4GB)'
H617E4DDA7E48: 'ヒートマップで有効と見なされる最大アドレス（デフォルト: 4GB）'
# 'maximum function durations'
H6F70690AFB07: '最大関数実行時間'
# 'maximum number of bytes to reorder'
H584FBF1D94C1: '再配置するバイト数の最大値'
# 'maximum number of bytes to use to align functions'
H20C9D30AEBA6: '関数をアライメントするために使用するバイト数の最大値'
# 'maximum number of call sites to inline'
H4BA4C864A650: 'インライン化するコールサイトの数の最大値'
# 'maximum number of data relocations to process'
HD03C0F0EA38B: '処理するデータの再配置数の最大値'
# 'maximum number of functions to print in top called functions section'
HB5333D52E6C6: '最も多く呼ばれた関数のセクションに出力する関数の数の最大値'
# 'maximum number of functions to process'
H09D081159F9B: '処理する関数の数の最大値'
# 'maximum number of hot basic blocks in a function for which to use a precise TSP solution while re-ordering basic blocks'
HA8A2B1281362: '基本ブロックの再配置時に、精密なTSP解法を使用する関数内のホットな基本ブロックの数の最大値'
# 'maximum number of inline iterations'
HF9B3A8E58122: 'インライン化の反復回数の最大値'
# 'maximum number of samples to read from LBR profile'
H39D9A5AFA87A: 'LBRプロファイルから読み込むサンプル数の最大値'
# 'maximum number of symbols to reorder'
HB1688A460BA8: '再配置するシンボル数の最大値'
# 'maximum percentage of stale functions to tolerate (default: 100)'
H9341327D8697: '許容する古い関数の割合の最大値（デフォルト: 100%）'
# 'maximum search depth. 0 forces a greedy approach. warning: the algorithm is up to O(2^N), where N is the max depth.'
H61B898BD8A31: '最大探索深さ。0を指定すると貪欲な手法が強制されます。警告: アルゴリズムはO(2^N)の計算量となり得ます（Nは最大深さです）。'
# "meaningless '%0' on asm outside function"
H7C9CC9A0FF49: '関数外のアセンブリで"%0"を使用することは意味をなしません'
# 'median function durations'
H4412290B83EA: '中央値の関数実行時間'
# 'member %0 cannot have template arguments'
H7530E8235E69: 'メンバ%0にはテンプレート引数を指定できません'
# 'member %0 declared here'
H523D63E160D3: 'メンバ%0はここに宣言されています'
# 'member %0 first declared here'
H53F314C373D4: 'メンバー %0 はここに初めて宣言されました'
# 'member %0 found in multiple base classes of different types'
HE96F2F88498F: 'メンバー %0 は異なる型の複数の基底クラスで見つかりました'
# 'member %0 has the same name as its class'
HBDCB2F361AEB: 'メンバー %0 はそのクラスと同じ名前を持っています'
# 'member %0 of %1 is not a template; did you mean %select{|simply }2%3?'
H88F478FC5C17: '%1 のメンバー %0 はテンプレートではありません；%select{|単に }2%3 をお考えでしたか？'
# 'member %0 used before its declaration'
H21EA4914C844: 'メンバー %0 はその宣言前に使用されています'
# 'member access into incomplete type %0'
H3F51F529F796: '不完全な型 %0 へのメンバーアクセス'
# 'member declaration does not match because it %select{is|is not}0 const qualified'
HB51C7FC5370B: 'メンバー宣言は一致しません。なぜなら、%select{const修飾されています|const修飾されていません}0 のためです'
# 'member declaration nearly matches'
HA07B45D5B59A: 'メンバー宣言はほぼ一致します'
# 'member found by ambiguous name lookup'
H1816E255A34E: '曖昧な名前検索によりメンバーが見つかりました'
# 'member function %0 is not needed and will not be emitted'
HC39E7B7627B2: 'メンバー関数 %0 は不要のため、生成されません'
# 'member function specialization matches %0'
HCDF99A0E6C9D: 'メンバー関数の特殊化は %0 と一致します'
# 'member initializer %0 does not name a non-static data member or base class'
H35E3E12D1C39: 'メンバー初期化子 %0 は非静的データメンバーまたは基底クラスを指しません'
# 'member is declared here'
H08E5DDE7EA19: 'メンバーはここに宣言されています'
# "member is not a candidate because range type %0 has no '%select{end|begin}1' member"
HE822EBF784D6: "range型 %0 に'%select{end|begin}1'メンバーが存在しないため、メンバーは候補になりません"
# 'member not initialized by constructor'
H26EC51B7C7A4: 'コンストラクタによって初期化されていないメンバー'
# 'member of anonymous %select{struct|union}0 redeclares %1'
H9C0924E1182A: '匿名の%select{構造体|ユニオン}0のメンバーが%1を再宣言しています'
# 'member pointer has incomplete base type %0'
H9CA90CC9D193: 'メンバーポインタの基底型 %0 は不完全です'
# 'member pointer representation requires a complete class type for %0 to perform this expression'
HA14D1B995CD2: '%0 でこの式を実行するには、メンバーポインタ表現には完全なクラス型が必要です'
# 'member reference base type %0 is not a structure or union'
HDDC7E94D7C4D: 'メンバー参照のベース型%0は構造体または共用体ではありません'
# "member reference type %0 is %select{a|not a}1 pointer; did you mean to use '%select{->|.}1'?"
HCE4396C30D63: "メンバー参照型%0は%select{a|not a}1ポインタです; '%select{->|.}1'を使う意図だったかもしれませんか？"
# 'member reference type %0 is not a pointer'
H1067A041C0C1: 'メンバー参照型%0はポインタではありません'
# 'member template declared %0 here'
H81FEA7456BEB: 'ここでメンバーテンプレート%0が宣言されています'
# 'member type %0 found by ambiguous name lookup'
H1BDBA1C8E5BA: '曖昧な名前検索によりメンバー型%0が見つかりました'
# 'member using declaration naming a non-member enumerator is incompatible with C++ standards before C++20'
HFDD47D4DEC61: 'メンバーusing宣言で非メンバー列挙子を指定することは、C++20以前のC++規格と互換性ありません'
# "member using declaration naming non-class '%0' enumerator is incompatible with C++ standards before C++20"
H3AC79AC99394: "非クラス'%0'の列挙子を指定するメンバーusing宣言は、C++20以前のC++規格と互換性ありません"
# 'memory order argument to atomic operation is invalid'
H10A1EB7E5921: 'アトミック操作へのメモリ順序引数が無効です'
# "memory order clause '%0' is specified here"
HEB7229373BDB: "メモリ順序句'%0'はここに指定されています"
# 'merge multiple fdata into a single file'
H166CAC1CDA7E: '複数のfdataを単一のファイルにマージ'
# 'merge settag instruction in function epilog'
H69388C044859: '関数エピローグでのsettag命令のマージ'
# 'merge stack variable initializers with tagging when possible'
H3914158550BF: '可能な場合、スタック変数初期化子をタグ付けとマージ'
# 'merge-fdata options'
H84D7D36EDADD: 'merge-fdata オプション'
# 'messages delimited by --- lines, with # comment support'
H35F2755289E5: '#コメントをサポートし、---行で区切られたメッセージ'
# 'messages delimited by `// -----` lines, with // comment support'
HFC97CA453D6E: '//コメントをサポートし、`// -----`行で区切られたメッセージ'
# 'messaging a Class with a method that is possibly direct'
H3E9374E93BAC: '可能性のある直接メソッドを持つClassへのメッセージング'
# 'messaging super with a direct method'
H76B5A067ADF0: '直接メソッドを使用したsuperへのメッセージング'
# 'messaging unqualified id'
H25CF081972C3: '修飾のない識別子へのメッセージング'
# 'messaging unqualified id with a method that is possibly direct'
H52C4ECCB3445: '資格なしIDに対するメッセージングが、直接的なメソッドを使用しています'
# 'method %0 declared here'
H0A29C282008D: 'メソッド%0はここに宣言されています'
# 'method %0 in protocol %1 not implemented'
H3B6F9A4CA03E: 'プロトコル%1のメソッド%0が実装されていません'
# 'method %0 is used for the forward class'
H9C1FB20B5554: 'メソッド%0はフォワードクラスに使用されています'
# 'method %0 that returns %1 declared here'
H81FA72B87C9D: '戻り値が%1のメソッド%0はここに宣言されています'
# 'method definition for %0 not found'
H2A6463515852: 'メソッド%0の定義が見つかりません'
# 'method for accessing %select{dictionary|array}1 element must have Objective-C object return type instead of %0'
H2A6E5DD7828B: '%select{dictionary|array}1要素にアクセスするメソッドは、%0の代わりにObjective-Cオブジェクト戻り値タイプを指定する必要があります'
# "method has no return type specified; defaults to 'id'"
HD11D99B1C083: 'メソッドの戻り値タイプが指定されていません; デフォルトで"id"を使用します'
# 'method implementation does not match its declaration'
H2D5D386F5AFB: 'メソッドの実装が宣言と一致しません'
# 'method index parameter type %0 is not integral type'
H630B60C086B7: 'メソッドのインデックスパラメータタイプ%0は整数型ではありません'
# 'method is expected to return an instance of its class type %diff{$, but is declared to return $|, but is declared to return different type}0,1'
H4EBF90DD6088: 'メソッドはクラスの型%diff{のインスタンスを返す必要がありますが、宣言された戻り値は$ | 異なる型を返す必要がありますが、宣言された戻り値は}0,1'
# 'method key parameter type %0 is not object type'
H93D8788321DF: 'メソッドのキーのパラメータタイプ%0はオブジェクトタイプではありません'
# 'method marked as designated initializer of the class here'
H6D873EC57BBB: 'この場所でクラスの指定コンストラクタとしてマークされたメソッド'
# "method name referenced in property setter attribute must end with ':'"
H48FC25BCA089: 'プロパティセッターアトリビュートで参照されたメソッド名は":"で終わらなければなりません'
# 'method object parameter type %0 is not object type'
H7C5EC09F4D4E: 'メソッドのオブジェクトパラメータタイプ%0はオブジェクトタイプではありません'
# 'method override for the designated initializer of the superclass %objcinstance0 not found'
H353D09FC8C8A: 'スーパークラス%objcinstance0の指定コンストラクタをオーバーライドするメソッドが見つかりません'
# 'method parameter of type %0 with no explicit ownership'
H012CAADA6E5A: '明示的な所有権がないタイプ%0のメソッドパラメータ'
# 'method parameter type %diff{$ does not match super class method parameter type $|does not match super class method parameter type}0,1'
H52F29D4B5323: 'メソッドパラメータタイプ%diff{ $はスーパークラスのメソッドパラメータタイプ$と一致しません | スーパークラスのメソッドパラメータタイプと一致しません}0,1'
# 'method possibly missing a [super %0] call'
HF2DE0E720AA4: 'メソッドが[super %0]呼び出しを欠いている可能性があります'
# 'method returns unexpected type %0 (should be an object type)'
HDA228B7E04A3: 'メソッドは予期しない型%0を返しています（オブジェクト型である必要があります）'
# "method type specifier must start with '-' or '+'"
H60683402DB43: "メソッドタイプ指定子は'-'または'+'で始まる必要があります"
# "method was declared as %select{an 'alloc'|a 'copy'|an 'init'|a 'new'}0 method, but its implementation doesn't match because %select{its result type is not an object pointer|its result type is unrelated to its receiver type}1"
H0332DF98668A: "メソッドは%select{an 'alloc'|a 'copy'|an 'init'|a 'new'}0メソッドとして宣言されていますが、実装が一致しません。その理由は%select{戻り値の型がオブジェクトポインタでない|戻り値の型がレシーバータイプと関係ない}1からです"
# 'methods that %select{override superclass methods|implement protocol requirements}0 cannot be direct'
H10E1F7CDD559: '%select{スーパークラスメソッドをオーバーライドする|プロトコル要件を実装する}0メソッドは直接呼び出せません'
# "micromips is not supported for target CPU '%0'"
H17AAF1CF7567: "Target CPU '%0'ではmicromipsはサポートされていません"
# 'minimal size of the basic block that should be aligned'
H9310AFA3C7C1: 'アラインメントすべき基本ブロックの最小サイズ'
# 'minimum address considered valid for heatmap (default 0)'
HB0C898B37318: '有効なheatmapアドレスの最小値（デフォルト0）'
# 'minimum condition bias (pct) to perform a CMOV conversion, -1 to not account bias'
HF9B056CCAAE3: 'CMOV変換の最小条件バイアス（％）-1でバイアス無視'
# 'minimum function durations'
H9FA9BE32CDEF: '関数の最小実行時間'
# 'minimum misprediction rate (pct) to perform a CMOV conversion, -1 to not account misprediction rate'
H0816E5149451: 'CMOV変換の最小誤予測率（％）-1で誤予測率無視'
# 'minimum number of points in an analysis cluster (dbscan only)'
H24AF23851D8A: '分析クラスタの最小ポイント数（dbscan専用）'
# 'minimum offset needed between block and successor to allow duplication'
H75F42A78BFD9: '複製を許可するブロックと後続の間の最小オフセット'
# 'minimum vscale must be an unsigned integer greater than 0'
H97D216C9F9DC: '最小vscaleは0より大きい符号なし整数でなければなりません'
# 'minus(-) operator for reductions is deprecated; use + or user defined reduction instead'
HB503599C3686: '減算演算子（-）を使ったリダクションは非推奨です；+またはユーザー定義のリダクションを使用してください'
# 'misaligned atomic operation may incur significant performance penalty; the expected alignment (%0 bytes) exceeds the actual alignment (%1 bytes)'
HB642C05FEFCE: '不整合アライメントの原子演算はパフォーマンス低下の原因になる可能性があります。期待されるアライメント(%0バイト)が実際のアライメント(%1バイト)を超えています'
# "misleading indentation; statement is not part of the previous '%select{if|else|for|while}0'"
H2D720E07A9B5: "誤解を招くインデント；ステートメントは前の'%select{if|else|for|while}0'の一部ではありません"
# "mismatch between architecture and environment in target triple '%0'; did you mean '%1'?"
HFB1C45E0F3D8: "target triple '%0'のアーキテクチャと環境が一致しません；'%1'の意図でしたか？"
# 'mismatch in number of block parameters and local size arguments passed'
H297CC009BE30: 'ブロックパラメータの数と渡されたローカルサイズ引数の数が一致しません'
# 'misplaced %0; expected %0 here'
H6EEF8ABBCBBD: '%0が不適切な位置です；ここでは%0が期待されます'
# 'misplaced attributes; expected attributes here'
H71DF23AD8094: '属性が不適切な位置です；ここでは属性が期待されます'
# 'misprediction threshold for skipping ICP on an indirect call'
H2799B1202BB8: '間接呼び出しでのICPスキップ用の誤推定しきい値'
# 'missing %1 after %0'
H71A0939C10D8: '%0の後に%1がありません'
# "missing '(' after '#pragma %0' - ignoring"
H9BCF4D2D832C: "'#pragma %0'の後に'('がありません - 無視します"
# "missing '(' following __VA_OPT__"
HFEF64C94E397: "__VA_OPT__の後に'('がありません"
# "missing ')' after '#pragma %0' - ignoring"
HD628B31A25D9: "'#pragma %0'の後に')'がありません - 無視します"
# "missing ')' in macro parameter list"
HBA1269832ABB: "マクロパラメータリスト内の')'がありません"
# "missing '*' in type bound %0 for type parameter %1"
H0FC1C4510683: "型パラメータ%1の型境界%0で'*'がありません"
# "missing ',' after %0"
H36D833E1BE2F: "%0の後の','がありません"
# "missing ',' between base or member initializers"
HC0E2DA10BD59: "ベースまたはメンバ初期化子の間の','がありません"
# "missing ',' between enumerators"
H3BCFAD409136: "列挙子の間の','がありません"
# "missing ':' after %0 - ignoring"
H6D49C0F56471: "%0の後の':'がありません - 無視します"
# "missing ':' after %0 modifier"
H1C42316D6361: "%0修飾子の後の':'がありません"
# "missing ':' in %0"
HB39748BAFE7C: "%0内の':'がありません"
# "missing ':' or ')' after %0 - ignoring"
HA24B4C500D05: "%0後の')'または':'がありません - 無視します"
# "missing '@end'"
H91CC5F3C7087: "'@end'がありません"
# "missing '[' at start of message send expression"
H352486DC1A63: "メッセージ送信式の開始の'['がありません"
# "missing 'export module' declaration in module interface unit"
H43BE56C41167: "モジュールインターフェースユニット内の'export module'宣言がありません"
# "missing 'export' specifier in module declaration while building module interface"
H73E9D7F0EE4B: "モジュール宣言で'export'指定子が不足しています（モジュールインターフェースの構築中）"
# "missing 'get=' or 'put='"
H5BBBF3CA84C4: '"get="または"put="が不足しています'
# "missing 'module' declaration at end of global module fragment introduced here"
HECF75AD1494B: "グローバルモジュールフラグメントの終わりに'module'宣言が不足しています（ここに導入されました）"
# "missing 'template' keyword prior to dependent template name %0"
H6110BBE085CA: '従属テンプレート名%0の前に"template"キーワードが不足しています'
# "missing 'typename' prior to dependent type name %0"
H1584997CE5DB: '従属型名%0の前に"typename"が不足しています'
# "missing 'typename' prior to dependent type name %0; implicit 'typename' is a C++20 extension"
H15976F1154C9: '従属型名%0の前に"typename"が不足しています;"typename"の暗黙の宣言はC++20の拡張機能です'
# "missing 'typename' prior to dependent type template name %0"
HB65342C255DD: '従属型テンプレート名%0の前に"typename"が不足しています'
# "missing '}' at end of definition of %q0"
HAF73F9C8E8E7: '%q0の定義の終わりに"}"が不足しています'
# 'missing actual type specifier for pipe'
H369BCA42F29A: 'パイプの実際の型指定子が不足しています'
# "missing argument to '#pragma %0'%select{|; expected %2}1"
H85D43DEA45AB: '"#pragma %0"に引数が不足しています%select{|; %2が期待されます}1'
# "missing argument to '%0'"
H52AC6CD34BC9: '"%0"に引数が不足しています'
# "missing argument to debug command '%0'"
H68E5FEB79890: 'デバッグコマンド"%0"に引数が不足しています'
# "missing argument; expected %select{an integer value|'enable'%select{|, 'full'}1%select{|, 'assume_safety'}2 or 'disable'}0"
H6DC6E5CF70F4: "引数が不足しています; %select{整数値|'enable'%select{|, 'full'}1%select{|, 'assume_safety'}2または'disable'}0が期待されます"
# 'missing context for method declaration'
HDB791FF5D00C: 'メソッド宣言のコンテキストが不足しています'
# 'missing context for property implementation declaration'
HB2B46E5EAE97: 'プロパティ実装宣言のコンテキストが不足しています'
# 'missing custom discrimination'
H8E91DD601C8B: 'カスタム判別子が不足しています'
# 'missing debug command'
HC4112B242494: 'デバッグコマンドが不足しています'
# 'missing default argument on parameter'
H8EC917CC5F93: 'パラメータのデフォルト引数が不足しています'
# 'missing default argument on parameter %0'
H8F4C6F0521D4: 'パラメータ%0のデフォルト引.argsが不足しています'
# 'missing field %0 initializer'
HBCFF05CA88FD: '%0 フィールドの初期化子が見つかりません'
# 'missing map type'
H4AA13FCA7666: 'マップ型が見つかりません'
# 'missing map type modifier'
H60251948404E: 'マップ型修飾子が見つかりません'
# 'missing numthreads attribute for %0 shader entry'
HFADE160C1BC1: '%0 シェーダーエントリにnumthreads属性が見つかりません'
# 'missing object format flag'
HD57D82290D05: 'オブジェクト形式フラグが見つかりません'
# "missing or invalid line number following '@' in expected %0"
H296CBDA95848: "予期される%0の後に'@'が付いた行番号が見つかりませんか、または無効です"
# 'missing parentheses around the size of parameter pack %0'
HA558CBB9F294: 'パラメータパック%0のサイズの周りの括弧が見つかりません'
# 'missing plugin argument for plugin %0 in %1'
H8600AE8C89F9: '%1のプラグイン%0の引数が見つかりません'
# 'missing plugin name in %0'
H4A2F8D6C22D3: '%0のプラグイン名が見つかりません'
# "missing reduction operator, expected '+', '*', 'max', 'min', '&', '|', '^', '&&', or '||', follwed by a ':'"
H9DF20C9098D2: "還元演算子が見つかりません。期待されるのは '+'、'*'、'max'、'min'、'&'、'|'、'^'、'&&'、または '||' に続けて':'です"
# 'missing return type for function %0; did you mean the constructor name %1?'
H0096A8359309: '関数%0の戻り値型が見つかりません。コンストラクタ名%1を意図しましたか？'
# "missing sanitizer ignorelist: '%0'"
HE7971DD1E969: "sanitizerの無視リストが見つかりません: '%0'"
# 'missing sentinel in %select{function call|method dispatch|block call}0'
H10D39CEB9167: '%select{関数呼び出し|メソッドディスパッチ|ブロック呼び出し}0のsentinelが見つかりません'
# 'missing state for %0'
HCF224168FF82: '%0の状態が見つかりません'
# "missing submodule '%0'"
H4FF2783EAA28: "サブモジュール'%0'が見つかりません"
# 'missing symbol graph output directory, defaulting to working directory'
H1ACFD82E27C5: 'シンボルグラフ出力ディレクトリが見つかりません。作業ディレクトリを使用します'
# 'missing terminating %select{\'|\'"\'}0 character'
HC91AE5B6C664: '終端の%select{\'|"}0文字が見つかりません'
# "missing terminating ')' character"
H110B9B84BD50: "終端の')'文字が見つかりません"
# 'missing type bound %0 for type parameter %1 in %select{@interface|@class}2'
HCB937BA83DD0: '%select{@interface|@class}2の型パラメータ%1に対する型制限%0が見つかりません'
# 'mixed CUDA and HIP compilation is not supported'
HDE7D3706C5B5: 'CUDAとHIPの混在コンパイルはサポートされていません'
# "mixing 'target_clones' specifier mechanisms is permitted for GCC compatibility; use a comma separated sequence of string literals, or a string literal containing a comma-separated list of versions"
H65625B3622E8: "'target_clones'指定メカニズムを混在使用する場合、GCC互換性のために、カンマ区切りの文字列リテラル列、またはカンマ区切りリストを含む文字列リテラルを使用してください"
# 'mixing declarations and code is a C99 extension'
H509E36ADC1D7: '宣言とコードの混在はC99の拡張機能です'
# 'mixing declarations and code is incompatible with standards before C99'
HD580E194E35D: '宣言とコードの混在はC99以前の規格と互換性がありません'
# 'mixture of designated and non-designated initializers in the same initializer list is a C99 extension'
H29C32AE72D18: '同じ初期化子リストで指定子付きと指定子なし初期化子を混在使用することはC99の拡張機能です'
# 'mlir-query options'
HE19598DC2C40: 'mlir-query オプション'
# 'mlir-reduce options'
H3CAB90C0AD8E: 'mlir-reduce オプション'
# 'mode %0 is not supported for enumeration types'
H9D1986A84BDA: '列挙型ではモード%0はサポートされていません'
# 'mode attribute only supported for integer and floating-point types'
H759A20BD1268: 'モード属性は整数型および浮動小数点型のみでサポートされています'
# 'mode for simplify conditional tail calls'
H7E2CD8BDAB86: '条件付きテールコールの簡略化のためのモード'
# 'moderate strategy'
H73892DAB539F: '中程度戦略'
# 'modification of object of const-qualified type %0 is not allowed in a constant expression'
H403821CE466D: '定数式ではconst修飾型%0のオブジェクトを変更することはできません'
# "modifier '%0' cannot be used along with modifier '%1'"
HDE467CEB2037: "修飾子'%0'は修飾子'%1'と同時に使用できません"
# 'modifying constructor parameter %0 that shadows a field of %1'
H1430708B59D6: 'フィールド%1を影付けているコンストラクタ引数%0を変更しています'
# 'modularize.\n'
HA1E9FFD28E50: 'モジュール化。\n'
# "module %0 does not depend on a module exporting '%1'"
H85DEF90A3AE0: "モジュール%0は'%1'をエクスポートするモジュールに依存していません"
# "module %0 does not directly depend on a module exporting '%1', which is part of indirectly-used module %2"
H9D50309367F5: "モジュール%0は'%1'を要求する直接依存モジュールを持っておらず、これは間接的に使用されるモジュール%2の一部です"
# "module '%0' %select{in|imported by}4 AST file '%1' found in a different module map file (%2) than when the importing AST file was built (%3)"
H7F407C161851: "モジュール'%0' %select{in|imported by}4 AST ファイル'%1'は、インポートASTファイルがビルドされた時のモジュールマップファイル(%3)とは異なるモジュールマップファイル(%2)に存在します"
# "module '%0' %select{is incompatible with|requires}1 feature '%2'"
H4440A0170E90: "モジュール'%0' %select{is incompatible with|requires}1 機能'%2'"
# "module '%0' %select{uses|does not use}1 additional module map '%2'%select{| not}1 used when the module was built"
HAC53C3FABCDA: "モジュール '%0' は%select{使用|使用していない}1 追加のモジュールマップ '%2'%select{| ではない}1 を構築時に使用しています"
# "module '%0' already re-exported as '%1'"
H6556B7A46703: "モジュール '%0' はすでに '%1' として再エクスポートされています"
# "module '%0' conflicts with already-imported module '%1': %2"
HED958876B86C: "モジュール '%0' は既にインポートされたモジュール '%1' と競合しています: %2"
# "module '%0' in AST file '%1' %select{(imported by AST file '%2') |}4is not defined in any loaded module map file; maybe you need to load '%3'?"
H951252F32734: "AST ファイル '%1' のモジュール '%0' は%select{(AST ファイル '%2' によってインポートされました) |}4どの読み込まれたモジュールマップファイルにも定義されていません。'%3' を読み込む必要があるかもしれません？"
# "module '%0' is defined in both '%1' and '%2'"
H9937FAC6E395: "モジュール '%0' は '%1' と '%2' の両方で定義されています"
# "module '%0' is needed but has not been provided, and implicit use of module files is disabled"
H8C7DAF453831: "モジュール '%0' が必要ですが、提供されていません。また、モジュールファイルの暗黙の使用は無効になっています"
# "module '%0' not found"
H55DF0ED78DC5: "モジュール '%0' が見つかりません"
# "module '%0' was built in directory '%1' but now resides in directory '%2'"
H38AD29640B23: "モジュール '%0' はディレクトリ '%1' でビルドされましたが、現在はディレクトリ '%2' に存在しています"
# "module compilation requires '-fmodules'"
H6A96D77D9F41: "モジュールコンパイルには '-fmodules' が必要です"
# 'module declaration can only appear at the top level'
HB03E6C215813: 'モジュール宣言はトップレベルでのみ使用できます'
# 'module declaration must occur at the start of the translation unit'
HA7783A63FE0B: 'モジュール宣言は翻訳単位の開始時に発生する必要があります'
# 'module defined here'
HDB50FF2BF5A8: 'ここに定義されたモジュール'
# 'module file %0 cannot be loaded due to a configuration mismatch with the current compilation'
H469015AF9879: 'モジュールファイル %0 は現在のコンパイルとの設定不一致のため読み込めません'
# "module file '%0' is missing its top-level submodule"
HFA537775278A: "モジュールファイル '%0' は最上位のサブモジュールを欠いています"
# "module file '%0' was validated as a system module and is now being imported as a non-system module; any difference in diagnostic options will be ignored"
H13B637DDA3AA: "モジュールファイル '%0' はシステムモジュールとして検証されましたが、非システムモジュールとしてインポートされています。診断オプションの違いは無視されます"
# 'module file suffix override'
H69E50E2734CF: 'モジュールファイルのサフィックスオーバーライド'
# "module header file '%0' not found"
HDA48886085ED: "モジュールヘッダーファイル '%0' が見つかりません"
# 'module imported here'
HA3A8055B303E: 'ここにインポートされたモジュール'
# "module interface compilation requires '-std=c++20'"
HA34462B55274: "モジュールインターフェースコンパイルには '-std=c++20' が必要です"
# "module loaded from '%0'"
H07E2BBCF1C1E: "モジュールを'%0'から読み込み"
# "module map file '%0' not found"
HD693305F9871: "モジュールマップファイル'%0'が見つかりません"
# "module name '%0' specified on command line does not match name of module"
H0F48D36629AC: "コマンドラインで指定されたモジュール名'%0'はモジュールの名前と一致しません"
# 'module output directory (default .)'
H445A6DEE34DF: 'モジュール出力ディレクトリ（デフォルトは .）'
# 'module partition implementations cannot be exported'
HFE1B8CB7B1E9: 'モジュールパーティションの実装はエクスポートできません'
# 'module partition imports must be within a module purview'
H99C430D138F5: 'モジュールパーティションのインポートは、モジュールの範囲内に存在する必要があります'
# 'module partitions are only supported for C++20 onwards'
HB98F31FF7B9A: 'モジュールパーティションはC++20以降でのみサポートされています'
# 'module search directory'
H3FAA97FDA5D1: 'モジュール検索ディレクトリ'
# 'module%select{| partition}0 imports cannot be in the %select{global|private}1 module fragment'
HE6F2588D0369: 'モジュール%select{| パーティション}0のインポートは、%select{グローバル|プライベート}1モジュールフラグメント内に存在できません'
# "more '%%' conversions than data arguments"
H9766AC9D490A: "データ引数よりも'%%'コンバージョンが多い"
# "more than one 'device_type' clause is specified"
H018E0AE39152: "複数の'device_type'句が指定されています"
# "more than one for-loop in a loop associated with OpenACC '%0' construct with a '%1' clause"
H30D49A113B6A: "OpenACCの'%0'構造体に'%1'句が関連付けられたループ内で複数のforループが存在しています"
# 'more than one framework/dynamic library found'
H611E8232270A: 'フレームワーク/動的ライブラリが複数見つかりました'
# "more than one input constraint matches the same output '%0'"
H4D494A49ED15: "同じ出力'%0'に対応する入力制約が複数存在します"
# 'move jump tables to a separate section'
HC21B261E02F6: 'ジャンプテーブルを別セクションに移動'
# 'moving a local object in a return statement prevents copy elision'
H928AEBBA3589: 'return文内のローカルオブジェクトを移動するとコピー省略が行われなくなります'
# 'moving a temporary object prevents copy elision'
H7FCDBDAE9C59: '一時オブジェクトを移動するとコピー省略が行われなくなります'
# 'ms_struct may not produce Microsoft-compatible layouts for classes with base classes or virtual functions'
H0D36DB1654BA: '基底クラスや仮想関数を有するクラスに対して、ms_structはMicrosoft互換のレイアウトを生成できない場合があります'
# "ms_struct may not produce Microsoft-compatible layouts with fundamental data types with sizes that aren't a power of two"
H9013C05CB59B: 'サイズが2の累乗でない基本データ型を使用すると、ms_structはMicrosoft互換のレイアウトを生成できない場合があります'
# 'mtriple'
H7584397F39BE: 'mtriple'
# 'multi-character character constant'
H8914BC0B6E30: '複数文字の文字定数'
# 'multi-dimensional arrays of WebAssembly references are not allowed'
HDC4921C402A6: 'WebAssembly リファレンスの多次元配列は許可されていません'
# 'multi-line // comment'
HC0A7D2EE8599: '複数行の // コメント'
# 'multilib configuration error: %0'
H51BCFF1832A0: 'multilib 設定エラー: %0'
# "multiple %0 architectures are detected: %1; only the first one is used for '%2'"
HF49114F051BF: "%0 アーキテクチャが複数検出されました: %1; '%2' には最初のもののみが使用されます"
# "multiple %select{'step size'|'linear modifier'}0 found in linear clause"
H6C58F45C9F56: "linear句で %select{'step size'|'linear modifier'}0 が複数見つかりました"
# "multiple 'callback' attributes specified"
H9EF4CEF4A9C0: "'callback' 属性が複数指定されました"
# "multiple 'cpu_specific' functions cannot specify the same CPU: %0"
H3B8B7713681E: "'cpu_specific' 関数は同じ CPU (%0) を複数指定できません"
# "multiple 'lifetime_capture' attributes specified"
H42096CECC49E: "'lifetime_capture' 属性が複数指定されました"
# "multiple 'routine' directives with 'bind' clauses are not permitted to refer to the same function"
HDA1D710FAA21: "'bind'句を伴う複数の 'routine' ディレクティブは同じ関数を参照できません"
# 'multiple access qualifiers'
HA0304D566382: '複数のアクセス修飾子'
# 'multiple address spaces specified for type'
H4075C38BB93B: '型に対して複数のアドレス空間が指定されました'
# 'multiple array elements associated with the same variable are not allowed in map clauses of the same construct'
H289BE95E22C4: '同じ構造内の map句において、同じ変数に関連付けられた複数の配列要素は許可されません'
# 'multiple conversions from expression type %0 to an integral type'
H80B8D963ECA1: '式の型 %0 から整数型への複数の変換が行われています'
# 'multiple conversions from switch condition type %0 to an integral or enumeration type'
H23301D5B9A53: 'switch条件の型 %0 から整数型または列挙型への複数の変換が行われています'
# 'multiple declarations of method %0 found and ignored'
HA50D97FB9EC5: 'メソッド %0 の多重宣言が検出され、無視されました'
# 'multiple default labels in one switch'
H1F979F2765D2: 'switch文内で複数のデフォルトラベルが存在します'
# 'multiple definitions are found for the same key in index '
HBED55B0B868B: 'インデックス内の同じキーに対して複数の定義が見つかりました'
# 'multiple ellipses in pack capture'
H2EAABC9D1825: 'パックキャプチャに複数の省略記号があります'
# 'multiple garbage collection attributes specified for type'
H8DF299790474: '型に対して複数のガベージコレクション属性が指定されました'
# 'multiple identical address spaces specified for type'
H2A39AD934787: '型に対して同一のアドレス空間が複数指定されました'
# 'multiple initializations given for base %0'
H6C502C93AC06: '基底クラス%0に対して複数の初期化が指定されました'
# 'multiple initializations given for non-static member %0'
HF2A12907FBDA: '非静的メンバ%0に対して複数の初期化が指定されました'
# "multiple inputs are not valid for header units (first extra '%0')"
H85058EEFACAE: "複数の入力はヘッダーユニットに対して有効ではありません (最初の追加 '%0')"
# 'multiple methods named %0 found'
H170992E437FC: '%0という名前のメソッドが複数見つかりました'
# 'multiple methods named %0 found with mismatched result, parameter type or attributes'
HB7ACC94E443E: '結果、パラメータ型、または属性が一致しない%0という名前のメソッドが複数見つかりました'
# 'multiple overloads of %0 instantiate to the same signature %1'
H3B92DD0A02C5: '%0の複数のオーバーロードが同じシグネチャ%1に実体化されます'
# 'multiple packs in structured binding declaration'
HFE5E55E2957C: '構造化束縛宣言に複数のパックがあります'
# 'multiple return statements in constexpr function is a C++14 extension'
H4582B1A35055: 'constexpr関数内の複数のreturn文はC++14の拡張機能です'
# 'multiple return statements in constexpr function is incompatible with C++ standards before C++14'
H4061EC95BBA4: 'constexpr関数内の複数のreturn文はC++14以前の標準と互換性がありません'
# "multiple suitable %0 functions for %1; no 'operator delete' function will be invoked if initialization throws an exception"
HB304821CF54E: '%1に対する%0関数が複数適切です; 初期化で例外が発生した場合、"operator delete"関数は呼び出されません'
# 'multiple suitable %0 functions in %1'
H04588097A2D5: '%1内の%0関数が複数適切です'
# 'multiple unsequenced modifications to %0'
HBE9DFDF729B3: '%0に対する複数の非順序修飾があります'
# 'multiple vtable pointer authentication policies on %0'
H64E76C32EB13: '%0に複数のVtableポインタ認証ポリシーがあります'
# 'multiversioned function declaration has a different %select{calling convention|return type|constexpr specification|inline specification|linkage|language linkage}0'
H037AEBCE675B: 'マルチバージョン関数宣言が%select{コールコンベンション|戻り値の型|constexpr指定|インライン指定|リンケージ|言語リンケージ}0が異なっています'
# 'multiversioned function must have a prototype'
HC2FE50BE244F: 'マルチバージョン関数にはプロトタイプが必要です'
# 'multiversioned function redeclarations require identical target attributes'
H21088B0A235D: 'マルチバージョン関数の再宣言には同一のターゲット属性が必要です'
# 'multiversioning attributes cannot be combined'
HB5E9464B0FCA: 'multiversioning属性は組み合わせられません'
# "must be declared with 'noexcept'"
H987DB13AD301: "'noexcept' で宣言する必要があります"
# 'must be specified at least once!'
H226887FCC25B: '少なくとも1回指定する必要があります!'
# 'must explicitly describe intended ownership of an object array parameter'
H94C16C029EFB: 'オブジェクト配列パラメータの意図した所有権を明示的に記述する必要があります'
# 'must explicitly qualify name of member function when taking its address'
H10EC7DC2756E: 'メンバー関数のアドレスを取る際にはその名前を明示的に修飾する必要があります'
# "must handle potential future platforms with '*'"
H52CBF98EE88A: "'*' を使用して将来のプラットフォームに対応する必要があります"
# 'must name member using the type of the current context %0'
H0A063C055ADE: '現在のコンテキストの型 %0 を使用してメンバーを指定する必要があります'
# "must pass in an explicit %0 gpu architecture to '%1'"
H748BF240D8AC: "%0 GPUアーキテクチャを明示的に '%1' に渡す必要があります"
# "must provide a symbol graph output directory using '--symbol-graph-dir=<directory>'"
H7FEC01DD8141: "'--symbol-graph-dir=<ディレクトリ>' を使用してシンボルグラフ出力ディレクトリを指定する必要があります"
# 'must qualify identifier to find this declaration in dependent base class'
HB8E730405435: 'この宣言を依存ベースクラスで見つけるには識別子を修飾する必要があります'
# "must specify '-fmodule-name=%0' to enter %select{|submodule of }1this module%select{ (current module is %3)|}2"
HF0DE733FAF70: "'このモジュール%select{|のサブモジュール}1' に参加するには '-fmodule-name=%0' を指定する必要があります%select{ (現在のモジュールは %3)|}2"
# 'must specify system root with -isysroot when building a relocatable PCH file'
H530DD8BE4BB8: '再配置可能なPCHファイルを構築する際には -isysroot でシステムルートを指定する必要があります'
# "must use '%1' tag to refer to type %0%select{| in this scope}2"
H25B19F90B2A8: "型 %0%select{|このスコープ内}2 を参照するには '%1' タグを使用する必要があります"
# 'my-tool options'
H6F25BE7781B0: 'my-tool オプション'
# 'name defined in alias declaration must be an identifier'
HF20E175DA10B: 'エイリアス宣言で定義された名前は識別子でなければなりません'
# 'name defined in concept definition must be an identifier'
H9F376A6B25D8: '概念定義内で定義された名前は識別子でなければなりません'
# 'named bit-field %0 has zero width'
HB27FCD740169: '名前付きビットフィールド %0 の幅がゼロです'
# 'named variadic macros are a GNU extension'
H4A2738C3ADE2: '名前付き可変引数マクロはGNU拡張機能です'
# 'namespace %0 defined here'
H6C2973533802: '名前空間 %0 はここで定義されています'
# 'namespace alias cannot be inline'
H69290D9B2469: '名前空間の別名はインラインできません'
# 'namespace alias must be a single identifier'
HA11E2A62D886: '名前空間の別名は単一の識別子でなければなりません'
# "namespace can only apply to 'push' or 'pop' directives"
H6F30E709453F: "名前空間は 'push' または 'pop' ディレクティブにのみ適用できます"
# 'namespaces can only be defined in global or namespace scope'
HDB4E6C24AE7F: '名前空間はグローバルスコープまたは名前空間スコープ内でしか定義できません'
# "negated attribute subject matcher sub-rule '%0' contradicts sub-rule '%1'"
H92B926B255DE: "否定された属性対象マッチャーのサブルール '%0' とサブルール '%1' が矛盾しています"
# 'negative shift count %0'
HC6E4102E7BA3: '負のシフト回数 %0'
# "nested OpenMP context selector contains duplicated trait '%0' in selector '%1' and set '%2' with different score"
HC583359DCCE0: "ネストされたOpenMPコンテキストセレクタは、セレクタ '%1' とセット '%2' の異なるスコアで、特性 '%0' が重複しています"
# 'nested designators are a C99 extension'
H97E72072881F: 'ネストされた指定子はC99拡張機能です'
# 'nested name specifier %0 for declaration does not refer into a class, class template or class template partial specialization'
H326DE285E8C5: '宣言のネストされた名前指定子 %0 はクラス、クラステンプレート、またはクラステンプレートの部分特別化を指しません'
# 'nested name specifier for a declaration cannot depend on a template parameter'
H87A0C3C18BC3: '宣言のネストされた名前指定子はテンプレートパラメータに依存できません'
# "nested namespace definition cannot be 'inline'"
HB262A63F161A: "ネストされた名前空間定義は 'inline' にできません"
# 'nested namespace definition is a C++17 extension; define each namespace separately'
HEFB4B9AD8E01: 'ネストされた名前空間定義はC++17拡張機能です; 各名前空間を個別に定義してください'
# 'nested namespace definition is incompatible with C++ standards before C++17'
H0E35039F1D67: 'ネストされた名前空間定義はC++17以前のC++規格と互換性がありません'
# 'nested parentheses not permitted in %0'
H34953581058C: '%0 内ではネストされた括弧は許可されていません'
# 'nested redefinition of %0'
H0AC10F45C385: '%0 のネストされた再定義'
# 'nested teams construct here'
HF6BEE2475F61: 'ネストされた teams コンストラクトはここです'
# 'nested user conditions in OpenMP context selector not supported (yet)'
H4C0B107BB3D4: 'ネストされたユーザー条件はOpenMPコンテキストセレクタではサポートされていません（まだ）'
# 'never apply unchecked-ld-st'
HBB179F0E1AB0: 'unchecked-ld-st を決して適用しない'
# 'never print'
H669835729B5F: '決してプリントしない'
# 'never replace exit value'
H0750F0A2D157: 'exit値を決して置換しない'
# 'new expression for type %0 contains multiple constructor arguments'
H0D34CDEC5737: '型 %0 の new 式には複数のコンストラクタ引数が含まれています'
# 'new expression for type %0 has incompatible constructor argument of type %1'
H8E7FF8B53FFB: '型 %0 の new 式には型 %1 の非互換なコンストラクタ引数があります'
# 'new expression for type %0 requires a constructor argument'
H55FA18FEEE0E: '型 %0 の new 式にはコンストラクタ引数が必要です'
# 'next %select{instance variable declaration|synthesized instance variable}0 is here'
H6502100189C0: '次の %select{インスタンス変数宣言|合成インスタンス変数}0 はここです'
# 'next field declaration is here'
H589A37214DA3: '次のフィールド宣言はここです'
# 'no %select{getter|setter}0 defined for property %1'
HDA010EA6C052: 'プロパティ %1 には %select{getter|setter}0 が定義されていません'
# 'no %select{struct|interface|union|class|enum}0 named %1 in %2'
HCA856DA687CE: '名前空間 %2 の中に %select{struct|interface|union|class|enum}0 %1 は存在しません'
# "no 'assign', 'retain', or 'copy' attribute is specified - 'assign' is assumed"
H5D9A45CF4470: "属性 'assign', 'retain', または 'copy' が指定されていません - 'assign' が仮定されます"
# 'no @interface declaration found in class messaging of %0'
H39108401F4F8: '@interface宣言がクラスメッセージの %0 で見つかりませんでした'
# "no MCU device specified, but '-mhwmult' is set to 'auto', assuming no hardware multiply; use '-mmcu' to specify an MSP430 device, or '-mhwmult' to set the hardware multiply type explicitly"
HF3E9B95BB7DD: "MCUデバイスが指定されていませんが、'-mhwmult' が 'auto' に設定されているため、ハードウェア乗算を有効としません; '-mmcu' を使用してMSP430デバイスを指定するか、'-mhwmult' を使用して明示的にハードウェア乗算タイプを設定してください"
# 'no PowerPC native vector element order.'
H49C9870074B0: 'PowerPCネイティブベクターエレメント順序がありません'
# "no analyzer checkers or packages are associated with '%0'"
H8B728EEF35B9: "アナルライザーチェッカーやパッケージが '%0' に関連付けられていません"
# 'no avr-libc installation can be found on the system, cannot link standard libraries'
H5206EA6489A5: 'システムにavr-libcインストールが見つかりません、標準ライブラリをリンクできません'
# 'no candidate function template was found for dependent %select{member|friend}0 function template specialization'
HC620314BA8FA: '依存する %select{member|friend}0 関数テンプレートの特殊化に候補となる関数テンプレートが見つかりませんでした'
# "no case matching constant switch condition '%0'"
HBFE1788B232F: "定数スイッチ条件 '%0' に一致するケースがありません"
# "no closing ']' for '%%[' in scanf format string"
H5E8D81CB9C26: "'%' の後の '[' に対応する']'がありません"
# 'no corresponding base class here'
HBBF529A4447F: 'ここに対応する基底クラスはありません'
# 'no corresponding enumerator here'
HCF6777617E14: 'ここに対応する列挙子はありません'
# 'no corresponding field here'
H8BC5689EEC5A: 'ここに対応するフィールドはありません'
# 'no corresponding friend here'
H0544B78403CC: 'ここに対応するフレンドはありません'
# 'no corresponding superclass here'
HE11938993661: 'ここに対応するスーパークラスはありません'
# "no declaration found for exported symbol '%0' in dynamic library"
H247D438751B2: "動的ライブラリでエクスポートされたシンボル '%0' の宣言が見つかりませんでした"
# "no declaration was found for exported symbol '%0' in dynamic library"
H01E907352618: "動的ライブラリでエクスポートされたシンボル '%0' の宣言が見つかりませんでした"
# "no expected directives found: consider use of '%0-no-diagnostics'"
H60C61DB5DCD2: "期待されるディレクティブが見つかりません: '%0-no-diagnostics' の使用を検討してください"
# 'no function template matches function template specialization %0'
H783C344DF4FC: '関数テンプレートの特殊化 %0 に一致する関数テンプレートはありません'
# 'no getter method %1 for %select{increment|decrement}0 of property'
H27A03BEFDE9D: 'プロパティの%select{インクリメント|デクリメント}0 のためのゲッターメソッド %1 がありません'
# 'no getter method for read from property'
HC653B7766A2E: 'プロパティの読み取り用のゲッターメソッドがありません'
# "no handler registered for module format '%0'"
H54F9399D659E: "モジュールフォーマット '%0' 用のハンドラが登録されていません"
# 'no input files'
HFFB86B2450DC: '入力ファイルがありません'
# 'no install name specified: add -install_name <path>'
H183DF472D6DF: 'インストール名が指定されていません: -install_name <パス> を追加してください'
# 'no known %select{instance|class}1 method for selector %0'
H41C44394DC27: '既知の %select{インスタンス|クラス}1 メソッド %0 がありません'
# "no known method %select{%objcinstance1|%objcclass1}0; cast the message send to the method's return type"
HD141497E30B9: 'メソッドの戻り値の型にキャストしてください; %select{%objcinstance1|%objcclass1}0 のメッセージ送信'
# "no library '%0' found in the default clang lib directory or in LIBRARY_PATH; use '--libomptarget-%1-bc-path' to specify %1 bitcode library"
H56082C491F7D: "デフォルトのclangライブラリディレクトリまたはLIBRARY_PATHにライブラリ '%0' が見つかりません; '--libomptarget-%1-bc-path' を使用して %1 ビットコードライブラリを指定してください"
# 'no macro named %0'
HDBF2015FF73B: '名前%0のマクロはありません'
# 'no matching %0 function for non-allocating placement new expression; include <new>'
H7020E0B0AF12: '非割り当て型の配置new式用に%0関数が見つかりません; <new>を含めてください'
# "no matching '#pragma clang module begin' for this '#pragma clang module end'"
HCC39D351076F: "この '#pragma clang module end' に対応する '#pragma clang module begin' が見つかりません"
# "no matching '#pragma clang module end' for this '#pragma clang module begin'"
H688037E203CF: "この '#pragma clang module begin' に対応する '#pragma clang module end' が見つかりません"
# "no matching '#pragma clang module endbuild' for this '#pragma clang module build'"
H4D6A2C63F3F1: "この '#pragma clang module build' に対応する '#pragma clang module endbuild' が見つかりません"
# 'no matching constructor for initialization of %0'
H60A16B350ED3: '%0の初期化用の適切なコンストラクタがありません'
# 'no matching conversion for %select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2'
HB6FD5E96FCBB: '対応する%select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0からの%1から%2への変換がありません'
# 'no matching function for call to %0'
HF7D6FEC7B803: '%0への呼び出し用に適切な関数がありません'
# 'no matching function for call to object of type %0'
H4AB0B7C8D656: '型%0のオブジェクトに対する適切な関数がありません'
# "no matching literal operator for call to %0%select{| with argument of type %2| with arguments of types %2 and %3}1%select{| or 'const char *'}4%select{|, and no matching literal operator template}5"
H1F7F02224823: '%0%select{|に型%2の引数|に型%2と%3の引数}1%select{|または「const char *」}4%select{|を指定した呼び出し用のリテラル演算子がありません、またテンプレートも見つかりません}5'
# 'no matching member function for call to %0'
HACEA313A920D: '%0への呼び出し用に適切なメンバー関数がありません'
# "no matching target found for target variant '%0'"
H2CC48DEFF159: "ターゲット変種'%0'に対応するターゲットが見つかりません"
# 'no member %0 in %1; it has not yet been instantiated'
H6800794A683C: '%1のメンバー%0はありません; まだインスタンス化されていません'
# 'no member named %0 in %1'
H85214E062B3A: '%1のメンバー%0はありません'
# 'no member named %0 in %1; did you mean %select{|simply }2%3?'
H5B97925635DE: '%1のメンバー%0はありません; %select{|単に}2%3をご存知ですか？'
# "no member named %0 in %1; did you mean to use '->' instead of '.'?"
HBE0974E3EE78: '%1のメンバー%0はありません; 「->」代わりに「.」を使っているかもしれません'
# 'no method with selector %0 is implemented in this translation unit'
H0CDD4F98E18F: 'この翻訳ユニットにセレクタ%0を持つメソッドが実装されていません'
# 'no module map available for module %0'
HF688B8490C1B: 'モジュール%0用のモジュールマップが見つかりません'
# 'no module name provided; specify one with -fmodule-name='
H99A7BF8D2824: 'モジュール名が指定されていません; -fmodule-name=で指定してください'
# "no module named '%0' %select{found|in '%2'}1, parent module must be defined before the submodule"
H86A38EF918F2: "モジュール'%0'が見つかりません %select{が見つかりませんでした|'%2'内}0、親モジュールはサブモジュールより前に定義する必要があります"
# "no module named '%0' declared in module map file '%1'"
HABF2F4633281: "モジュールマップファイル'%1'にモジュール'%0'が宣言されていません"
# "no module named '%0' in '%1'"
H658500ACD8C1: "'%1'にモジュール'%0'がありません"
# "no module named '%0' visible from '%1'"
HA7094B5AEB21: "'%1'から可視なモジュール'%0'がありません"
# "no more 'if' clause is allowed"
H8F7A1C6703AA: "'if'節をさらに記述できません"
# "no more than one option '--config' is allowed"
H3089388E4475: "オプション'--config'は1つだけ指定できます"
# 'no multilib found matching flags: %0'
HCDE4340CFBD3: 'フラグ%0に一致するmultilibが見つかりませんでした'
# 'no namespace named %0 in %1; did you mean %select{|simply }2%3?'
HF6FEAE5E55D9: "%1に名前空間'%0'はありません；%select{ |単純に }2%3を指す意図でしたか？"
# 'no namespace named %0; did you mean %1?'
H81CE4465B841: "名前空間'%0'はありません；%1を指す意図でしたか？"
# 'no newline at end of file'
HC3F31DC1712E: 'ファイルの終わりに改行がありません'
# 'no output file specified'
HA94EBB9ACB5A: '出力ファイルが指定されていません'
# 'no previous extern declaration for non-static variable %0'
H8B284B72F880: '非静的変数%0のextern宣言がありません'
# 'no previous prototype for function %0'
H03B77D9B5049: '関数%0のプロトタイプ宣言がありません'
# 'no profile data available for file "%0"'
H59152796471E: 'ファイル"%0"のプロファイルデータが利用できません'
# 'no return statement in %select{constexpr|consteval}0 function'
H6CABFAB2482E: '%select{constexpr|consteval}0関数内にreturn文がありません'
# "no submodule named %0 in module '%1'"
H2B7BA310F788: "モジュール'%1'にサブモジュール'%0'がありません"
# "no submodule named %0 in module '%1'; did you mean '%2'?"
H7D6A5E92FB55: "モジュール'%1'にサブモジュール'%0'がありません；'%2'を指す意図でしたか？"
# "no submodule named %0 in module '%1'; using top level '%2'"
H5C502E1660AA: "モジュール'%1'にサブモジュール'%0'がありません；最上位の'%2'を使用します"
# "no such %select{public|private|project}1 header file: '%0'"
H6EFAEBB81765: "そのような%select{公開|プライベート|プロジェクト}1ヘッダーファイルがありません: '%0'"
# "no such excluded %select{public|private}0 header file: '%1'"
HED06FD077272: "除外された%select{public|private}0のヘッダーファイル'%1'が存在しません"
# "no such file or directory: '%0'"
HE170FBCF53FC: "ファイルまたはディレクトリがありません: '%0'"
# "no such file or directory: '%0'; did you mean '%1'?"
HE112F2418E57: "ファイルまたはディレクトリがありません: '%0'; '%1'を指す場合はありませんか？"
# "no such include directory: '%0'"
H7E37FF613F8F: "そのようなインクルードディレクトリがありません: '%0'"
# "no such sysroot directory: '%0'"
H7EBC246FEEA8: "sysrootディレクトリがありません: '%0'"
# 'no suitable member %0 in %1'
H3750344F18EF: '適切なメンバー%0が%1に存在しません'
# "no suitable precompiled header file found in directory '%0'"
HC9D05A0684EB: "ディレクトリ'%0'に適切なプリコンパイルヘッダーファイルが見つかりません"
# 'no target microcontroller specified, please pass -mmcu=<mcu name>'
H861E68DCEBF9: 'ターゲットマイクロコントローラーが指定されていません。-mmcu=<マイコン名>を指定してください'
# 'no template named %0'
HFC0C70B06D89: "テンプレート'%0'がありません"
# 'no template named %0 in %1'
H16DB7E6BC24D: "%1内にテンプレート'%0'がありません"
# 'no template named %0 in %1; did you mean %select{|simply }2%3?'
HCDFE5581F7D6: "%1内にテンプレート'%0'がありません; %select{|単に }2%3を指す場合はありませんか？"
# 'no template named %0; did you mean %1?'
H32AFF6E21FDC: "テンプレート'%0'がありません; %1を指す場合はありませんか？"
# 'no type named %0 in %1'
H6E87E8CAFF42: "%1内に型'%0'がありません"
# 'no type named %0 in %1; did you mean %select{|simply }2%3?'
H014C7B262D03: "%1内に型'%0'がありません; %select{|単に }2%3を指す場合はありませんか？"
# "no type named 'type' in %0; 'enable_if' cannot be used to disable this declaration"
H03B3775679FC: "%0内に'type'という型がありません; 'enable_if'はこの宣言を無効にするために使用できません"
# 'no type or protocol named %0'
HFF0D89AB2752: "型またはプロトコル'%0'がありません"
# "no valid clauses specified in OpenACC 'declare' directive"
H136795D57206: "OpenACC 'declare'ディレクティブに有効な句が指定されていません"
# 'no variable template matches specialization; did you mean to use %0 as function template instead?'
H702E78FBEC31: '変数テンプレートの特殊化に一致するものがありません；%0を関数テンプレートとして使用するつもりでしたか？'
# 'no variable template matches%select{| partial}0 specialization'
H0903C7695A91: '変数テンプレートに一致する%select{| 部分}0特殊化がありません'
# 'no viable candidate for explicit instantiation of %0'
HAEBC7520AFB0: '%0の明示的なインスタンテーションのための有効な候補がありません'
# 'no viable constructor %select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1'
HC9B75808C9E9: '%select{変数のコピー|パラメータのコピー|テンプレートパラメータの初期化|オブジェクトの戻り値|ステートメント式結果の初期化|オブジェクトのスロー|メンバーのサブオブジェクトのコピー|配列要素のコピー|オブジェクトのアロケーション|一時オブジェクトのコピー|ベースサブオブジェクトの初期化|ベクタ要素の初期化|値のキャプチャ}0の型%1に対する有効なコンストラクタがありません'
# 'no viable constructor %select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0 of type %1; C++98 requires a copy constructor when binding a reference to a temporary'
HBD2DEF3D3EA1: '%select{変数のコピー|パラメータのコピー|テンプレートパラメータの初期化|オブジェクトの戻り値|ステートメント式結果の初期化|オブジェクトのスロー|メンバーのサブオブジェクトのコピー|配列要素のコピー|オブジェクトのアロケーション|一時オブジェクトのコピー|ベースサブオブジェクトの初期化|ベクタ要素の初期化|値のキャプチャ}0の型%1に対する有効なコンストラクタがありません；C++98では一時オブジェクトにリテラルを束縛する際にはコピーコンストラクタが必要です'
# 'no viable constructor or deduction guide for deduction of template arguments of %0'
HECA595B57B5C: '%0のテンプレート引数の推論のための有効なコンストラクタまたは推論ガイドがありません'
# 'no viable conversion%diff{ from $ to incomplete type $|}0,1'
H0DDC152C267D: '不完全型$への変換が可能です%diff{ $から $|}0,1'
# 'no viable conversion%select{%diff{ from $ to $|}1,2|%diff{ from returned value of type $ to function return type $|}1,2}0'
H742AD0829398: '%select{%diff{ $から $への変換が可能です|}1,2|%diff{ 戻り値の型$から関数の戻り値型$への変換が可能です|}1,2}0'
# 'no viable destructor found for class %0'
HE8AA8B1D9E66: 'クラス%0の有効なデストラクタがありません'
# "no viable overloaded '%0'"
H85F4D23A3BAD: "オーバーロード可能な'%0'がありません"
# 'no viable overloaded operator[] for type %0'
H2EF71DBEE631: '型%0に対する有効なオーバーロードされたoperator[]はありません'
# 'no visible @interface for %0 declares the selector %1'
HF35FE2A8D9B7: 'セレクタ%1を宣言する@interfaceが%0に見つかりません'
# 'noexcept expressions are incompatible with C++98'
H770DCD42AD88: 'noexcept式はC++98と互換性ありません'
# 'noexcept specifications are incompatible with C++98'
HCDFCAD5EB464: 'noexcept仕様はC++98と互換性ありません'
# 'non-ASM statement in naked function is not supported'
H13FAFC759C77: 'naked関数内の非ASMステートメントはサポートされていません'
# 'non-class friend type %0 is a C++11 extension'
HD60A5C8C49AC: 'クラスではないフレンド型%0はC++11拡張です'
# 'non-class friend type %0 is incompatible with C++98'
H4D0DB388513A: 'クラスではないフレンド型%0はC++98と互換性ありません'
# 'non-const static data member must be initialized out of line'
HFA5187DD3DCB: 'constでない静的データメンバは行外で初期化する必要があります'
# 'non-constant static local variable in inline function may be different in different files'
HDAC621E8867A: 'インライン関数内の定数でない静的ローカル変数は異なるファイルで異なる値になる可能性があります'
# 'non-constant-expression cannot be narrowed from type %0 to %1 in initializer list'
H48217DABAA7D: '定数式ではない式は、初期化子リストで型%0から%1に縮小できません'
# 'non-constant-expression cannot be narrowed from type %0 to %1 in initializer list in C++11'
H996365ACA997: 'C++11で初期化子リストで型%0から%1に縮小できません'
# 'non-consteval function %0 cannot override a consteval function'
H3BE45C7BF2C1: 'consteval関数ではない関数%0は、consteval関数をオーバーライドできません'
# 'non-constexpr comparison function declared here'
H6CDFA8CCBBD8: 'constexprではない比較関数がここで宣言されています'
# 'non-constexpr comparison function would be used to compare %select{|member %1|base class %1}0'
HFFB83E06B051: 'constexprではない比較関数が%select{|メンバー%1|基底クラス%1}0を比較するために使用されます'
# 'non-deducible template parameter %0'
HD419F387C770: '推論不可能なテンプレートパラメータ%0'
# 'non-default #pragma pack value changes the alignment of struct or union members in the included file'
H2C52662649BE: 'デフォルト以外の#pragma pack値は、包含ファイルの構造体または共用体のメンバーのアライメントを変更します'
# "non-default visibility cannot be applied to 'dllimport' declaration"
H2A9EC7D43705: "デフォルト以外の可視性は、'dllimport'宣言には適用できません"
# 'non-defining declaration of enumeration with a fixed underlying type is only permitted as a standalone declaration%select{|; missing list of enumerators?}0'
H4D151B6B2BF9: '固定された基礎型を有する列挙型の定義を伴わない宣言は、単独の宣言としてのみ許可されます%select{|; 列挙子の一覧が不足していますか？}0'
# 'non-deleted function %0 cannot override a deleted function'
H2F21A881D5B2: '削除されていない関数%0は、削除された関数をオーバーライドできません'
# 'non-extern declaration of %0 follows extern declaration'
H7E386503A2B6: "'extern'宣言の後に、%0のexternでない宣言があります"
# 'non-friend class member %0 cannot have a qualified name'
H01BBFAF999D6: '友達でないクラスメンバ%0には修飾名を指定できません'
# 'non-inline external definitions are not permitted in C++ header units'
H0E67412E5EDC: 'インラインでない外部定義は、C++ヘッダユニットでは許可されていません'
# 'non-inline namespace cannot be reopened as inline'
H43CE8E47A824: 'インラインでない名前空間は、インラインとして再開できません'
# 'non-literal type %0 cannot be used in a constant expression'
HFCBBB3F7D771: 'リテラル型でない型%0は、定数式では使用できません'
# 'non-local lambda expression cannot have a capture-default'
H2B075ACEF012: 'ローカル外のラムダ式にはキャプチャデフォルトを指定できません'
# 'non-local variable with sizeless type %0'
H92600D86A0C5: 'サイズのない型%0を持つローカル外の変数'
# 'non-namespace scope %0 cannot have a literal operator member'
H266845A5FE4C: '名前空間以外のスコープ%0にはリテラル演算子メンバを定義できません'
# 'non-object type %0 is not assignable'
H8FB33F67F675: 'オブジェクト型でない型%0は代入できません'
# "non-pointer argument to '__builtin_assume_aligned' is not allowed"
HD960D71E3301: "'__builtin_assume_aligned'へのポインタでない引数は許可されていません"
# 'non-pointer operand type %0 incompatible with %select{NULL|nullptr}1'
H90B6AFB986DF: 'ポインタではない操作数の型%0は%select{NULL|nullptr}1と互換性がない'
# "non-portable path to file '%0'; specified path differs in case from file name on disk"
H43FE55A52897: "ファイル'%0'への移植性のないパス; 指定されたパスはディスク上のファイル名のケースと異なります"
# 'non-predefined allocator must have traits specified'
HFFB74BA64E52: 'プリコンパイルされていないアロケータには特性を指定する必要があります'
# 'non-static data member %0 cannot be declared as a template'
HEE38B2049618: '静的でないデータメンバ%0はテンプレートとして宣言できません'
# 'non-static data member cannot be constexpr%select{; did you intend to make it %select{const|static}0?|}1'
H19D13A6885F4: '静的でないデータメンバはconstexprにできません%select{; %select{const|static}0にする意図ですか？|}1'
# 'non-static data member defined out-of-line'
HC4D58BAF82DF: '静的でないデータメンバは外付けで定義されています'
# 'non-static declaration of %0 follows static declaration'
H25169BF9CE09: '%0の静的でない宣言が静的な宣言の後に続きます'
# 'non-static member %0 found in multiple base-class subobjects of type %1:%2'
H1D1EE8E2CCD9: '静的でないメンバ%0がタイプ%1の複数の基底クラスサブオブジェクト%2で見つかりました'
# 'non-template declaration found by name lookup'
HF380F2D95EAA: 'テンプレートでない宣言が名前検索によって見つかりました'
# 'non-template friend declaration with a requires clause must be a definition'
H95DF301285CD: 'requires句を伴うnon-templateのフレンド宣言は定義でなければならない'
# 'non-template literal operator must have one or two parameters'
HAB8D25BD0598: 'テンプレートでないリテラル演算子には1つまたは2つのパラメータが必要です'
# 'non-templated declaration is here'
H5E1276462F94: 'テンプレートでない宣言はここにあります'
# 'non-templated function cannot have a requires clause'
H82190871139C: 'テンプレートでない関数はrequires句を持つことはできません'
# 'non-thread-local declaration of %0 follows thread-local declaration'
H015D893F1487: '%0のスレッドローカルでない宣言がスレッドローカル宣言の後に続きます'
# 'non-trivial destruction of lifetime-extended temporary with type %0 used in the result of a constant expression is not yet supported'
HD2339C077B90: '定数式の結果で使用されるlifetime-extended一時オブジェクト%0の非自明な破棄はまだサポートされていません'
# 'non-trivial destruction of type %0 in a constant expression is not supported'
HE2CD4D9E53E2: 'タイプ%0の定数式内の非自明な破棄はサポートされていません'
# 'non-trivially copyable type %0 cannot be used in a boxed expression'
HB2216F42639D: '非自明にコピー可能なタイプ%0はboxed式で使用できません'
# 'non-type declaration found by destructor name lookup'
HB02DCE8A7FF1: '型でない宣言がデストラクタ名検索によって見つかりました'
# "non-type template argument '%0' is invalid"
H2399CD2B5610: "非型テンプレート引数'%0'は無効です"
# 'non-type template argument containing a dereference operation is a Microsoft extension'
HD4EF29A775AB: '非型テンプレート引数にデリファレンス演算を含むものはMicrosoftの拡張です'
# 'non-type template argument does not refer to an object or function'
HE77C0A012513: '非型テンプレート引数はオブジェクトまたは関数を指していません'
# 'non-type template argument does not refer to any declaration'
HB25807F91411: '非型テンプレート引数はどの宣言にも指していません'
# 'non-type template argument for template parameter of pointer type %0 must have its address taken'
H8D4CDD97C49D: 'ポインタ型%0のテンプレートパラメータ用の非型テンプレート引数にはアドレスを取得する必要があります'
# 'non-type template argument is not a pointer to member constant'
HDC21F0C558EB: 'ポインター型のメンバー定数への非型テンプレート引数ではありません'
# 'non-type template argument of reference type %0 is not an object'
H50574CDA0DAD: 'リファレンスタイプ%0の非型テンプレート引数はオブジェクトではありません'
# 'non-type template argument of type %0 cannot be converted to a value of type %1'
HDF1742D8033F: '型%0の非型テンプレート引数は型%1への値の変換が可能です'
# 'non-type template argument of type %0 is not a constant expression'
H075FB8D7A63A: '型%0の非型テンプレート引数は定数式ではありません'
# 'non-type template argument of type %0 is not an integral constant expression'
HE2EA0C6B3858: '型%0の非型テンプレート引数は整数定数式ではありません'
# 'non-type template argument of type %0 must have an integral or enumeration type'
H06D35F5E0195: '型%0の非型テンプレート引数には整数型または列挙型が必要です'
# 'non-type template argument referring to %select{function|object}0 %1 with internal linkage is a C++11 extension'
HEFF3308ED7FE: '内部リンケージを持つ%select{関数|オブジェクト}0 %1を指す非型テンプレート引数はC++11の拡張機能です'
# 'non-type template argument referring to %select{function|object}0 %1 with internal linkage is incompatible with C++98'
H2F0100862103: '内部リンケージを持つ%select{関数|オブジェクト}0 %1を指す非型テンプレート引数はC++98と互換性ありません'
# 'non-type template argument refers here'
HA953EF53E7DD: 'ノンタイプテンプレート引数はここを指します'
# 'non-type template argument refers to %select{function|object}0 %1 that does not have linkage'
H600BCDFEE43D: 'リンケージを持たない%select{関数|オブジェクト}0 %1を指す非型テンプレート引数'
# 'non-type template argument refers to %select{function|object}0 here'
H9ED37B3451CC: '非型テンプレート引数はここで%select{関数|オブジェクト}0を指しています'
# 'non-type template argument refers to non-static data member %0'
H2465AB2AA5B5: '非型テンプレート引数は静的でないデータメンバ%0を指しています'
# 'non-type template argument refers to non-static member function %0'
H6A037F433017: '非型テンプレート引数は静的でないメンバ関数%0を指しています'
# "non-type template argument refers to subobject '%0'"
HD30CEA1C7504: "非型テンプレート引数はサブオブジェクト'%0'を指しています"
# 'non-type template argument refers to thread-local object'
H1DFBA6B66CEF: '非型テンプレート引数はスレッド局所オブジェクトを指しています'
# 'non-type template argument specializes a template parameter with dependent type %0'
H77D31AA373EF: '依存型%0のテンプレートパラメータを特殊化する非型テンプレート引数'
# "non-type template argument value '%0' truncated to '%1' for template parameter of type %2"
H5466021B086C: "テンプレートパラメータの型%2のため、非型テンプレート引数値'%0'が'%1'に切り詰められました"
# "non-type template argument with value '%0' converted to '%1' for unsigned template parameter of type %2"
H4635C03C8C36: "ノンタイプテンプレート引数の値'%0'が'%1'に変換されました（型%2の符号なしテンプレートパラメータ用）"
# 'non-type template parameter %0 with type %1 has incompatible initializer of type %2'
H36B37E5D284B: '型%1のテンプレートパラメータ%0には型%2の初期化子は互換性がありません'
# 'non-type template parameter declared with incompatible types in different translation units (%0 vs. %1)'
H349C88186DB6: '異なる翻訳単位で非互換の型で宣言されたノンタイプテンプレートパラメータ（%0 対 %1）'
# 'non-type template parameter has incomplete type %0'
H67B9597CFD9A: 'ノンタイプテンプレートパラメータは未完全な型%0を持ちます'
# 'non-type template parameter has non-literal type %0'
H271C87C2E376: 'ノンタイプテンプレートパラメータは非リテラル型%0を持ちます'
# 'non-type template parameter has rvalue reference type %0'
H8258CBB4119D: 'ノンタイプテンプレートパラメータはrvalue参照型%0を持ちます'
# 'non-type template parameter of reference type %diff{$ cannot bind to template argument of type $|cannot bind to template of incompatible argument type}0,1'
H4F089D7DCBD1: '参照型の非型テンプレートパラメータ%diff{$は型$のテンプレート引数に束縛できません|互換性のない引数型のテンプレートに束縛できません}0,1'
# 'non-type template parameter of type %0 is incompatible with C++ standards before C++20'
H76F7D38734C2: 'C++20以前のC++標準では型%0のノンタイプテンプレートパラメータは非互換です'
# 'non-type template parameter of variably modified type %0'
HDB7696E83E21: '可変長修飾された型%0のノンタイプテンプレートパラメータ'
# 'non-type template parameters declared with %0 are incompatible with C++ standards before C++17'
H4034BC5F4762: 'C++17以前のC++標準では%0で宣言されたノンタイプテンプレートパラメータは非互換です'
# 'non-usual %0 declared here'
H9B44D0E82E0B: '非通常な%0がここに宣言されています'
# "non-variable declaration in 'for' loop"
HE2801E92B8D8: "'for'ループにおける変数ではない宣言"
# "non-variable declaration in 'for' loop is a C23 extension"
H861D242B28D2: "'for'ループにおける変数ではない宣言はC23拡張機能です"
# "non-variable declaration in 'for' loop is incompatible with C standards before C23"
H1A5C6F3C6A58: "'for'ループにおける変数ではない宣言はC23以前のC標準では非互換です"
# "non-virtual member function marked '%0' hides virtual member %select{function|functions}1"
H6156F12DC3F9: '非仮想メンバ関数%0は%select{関数|関数たち}1を隠蔽しています'
# 'non-void %select{constexpr|consteval}1 function %0 should return a value'
HCF55E17BA989: '非void %select{constexpr|consteval}1関数%0には値を返す必要があります'
# 'non-void %select{function|block|lambda|coroutine}0 does not return a value%select{| in all control paths}1'
H75EE618D1AA4: '非void %select{関数|ブロック|ラムダ|コルーチン}0は値を返しません%select{|すべての制御パスで}1'
# 'non-void %select{function|method}1 %0 should return a value'
HEE95067001EB: '非void %select{関数|メソッド}1 %0には値を返す必要があります'
# 'non-void block should return a value'
H66594B013217: '非voidブロックは値を返す必要があります'
# "nonnull %select{function call|parameter}0 '%1' will evaluate to 'true' on first encounter"
H925BCFBBE426: "nonnull %select{関数呼び出し|パラメータ}0 '%1'は最初の評価時に'true'となります"
# 'not a Doxygen trailing comment'
HB02E938B9DEC: 'Doxygenの末尾コメントではありません'
# "not currently inside '#pragma clang arc_cf_code_audited'"
HD79C4D940185: '#pragma clang arc_cf_code_auditedの内部にありません'
# "not currently inside '#pragma clang assume_nonnull'"
HF77D5E6601B3: '#pragma clang assume_nonnullの内部にありません'
# "not currently inside '#pragma unsafe_buffer_usage'"
H658512A345D7: '#pragma unsafe_buffer_usageの内部にありません'
# 'not enough variable arguments in %0 declaration to fit a sentinel'
H9930B56495BC: '%0宣言にsentinelを収めるのに十分な可変引数がありません'
# 'not packing field %0 as it is non-POD for the purposes of layout'
H7FBA81FDAA18: 'レイアウトの目的でPODではないため、フィールド%0はパックされません'
# 'not-yet-instantiated member is declared here'
HACFD1F41F676: 'まだインスタンス化されていないメンバーがここに宣言されています'
# 'null character ignored'
H6B4B3A47C8AC: 'ヌル文字が無視されました'
# 'null character(s) preserved in %select{char|string}0 literal'
H062C86F6116B: 'ヌル文字が%select{char|string}0リテラルに保持されています'
# 'null non-type template argument must be cast to template parameter type %0'
HDDA635486EF3: 'null非型テンプレート引数はテンプレートパラメータ型%0にキャストする必要があります'
# 'null non-type template argument of type %0 does not match template parameter of type %1'
HCF293B48A07C: '型%0のnull非型テンプレート引数は型%1のテンプレートパラメータと一致しません'
# 'null passed to a callee that requires a non-null argument'
H5F7D096FCE08: '非null引数を要求する呼び出し先にnullが渡されました'
# 'null returned from %select{function|method}0 that requires a non-null return value'
HEA9F26CD4560: '%select{関数|メソッド}0から非null戻り値を要求するがnullが返されました'
# 'nullability keyword %0 cannot be applied to multi-level pointer type %1'
H9F63F0EFF7CC: 'nullabilityキーワード%0は多重ポインタ型%1に適用できません'
# 'nullability specifier %0 cannot be applied to non-pointer type %1'
HA1F5D87BE3DF: 'nullability指定子%0はポインタ型以外の%1に適用できません'
# 'nullability specifier %0 cannot be applied to non-pointer type %1; did you mean to apply the specifier to the %select{pointer|block pointer|member pointer|function pointer|member function pointer}2?'
H3E269F064E84: 'nullability指定子%0はポインタ型以外の%1に適用できません; %select{ポインタ|ブロックポインタ|メンバーポインタ|関数ポインタ|メンバーメソッドポインタ}2に指定子を適用する意図ではありませんか？'
# 'nullability specifier %0 conflicts with existing specifier %1'
H4421DC48369F: 'nullability指定子%0は既存の指定子%1と競合します'
# 'number of elements must be either one or match the size of the vector'
H2A474F4275FA: '要素数は1またはベクターのサイズと一致する必要があります'
# 'number of entries per line (default 256)'
H7D63977C73C8: '1行あたりのエントリ数（デフォルトは256）'
# 'number of functions to display when printing the top largest differences in function activity'
H4322F776E088: '関数活動の上位の最大差分を表示する際の表示する関数の数'
# 'number of hottest functions to print aggregated profile quality stats of.'
H5B5E76B4AA88: '集計されたプロファイル品質統計を表示する最もホットな関数の数'
# 'number of tasks to be created per thread'
HE2569802814C: 'スレッドごとに作成されるタスクの数'
# 'number of threads'
HE591548912FE: 'スレッドの数'
# 'numeric literal with user-defined suffix cannot be used here'
H6D6640DAD12D: 'ユーザー定義の接尾辞を持つ数値リテラルはここでは使用できません'
# "nvcc does not allow '__%0__' to appear after the parameter list in lambdas"
H052A23E5C9DE: "nvccでは、ラムダのパラメータリスト後に'__%0__'を記述できません"
# 'nvptx-arch options'
H195E97C080C6: 'nvptx-アーキテクチャ オプション'
# 'obj2yaml Options'
HDEB46CD09A6E: 'obj2yaml オプション'
# 'objc_precise_lifetime is not meaningful for %select{__unsafe_unretained|__autoreleasing}0 objects'
H3B4A7538E1D6: 'objc_precise_lifetimeは%select{__unsafe_unretained|__autoreleasing}0オブジェクトに対して意味をなしません'
# 'objc_precise_lifetime only applies to retainable types; type here is %0'
HCB888D9DBEF6: 'objc_precise_lifetimeはretain可能なタイプにのみ適用されます。ここでの型は%0です'
# 'objc_root_class attribute may only be specified on a root class declaration'
H8B7E866F5F47: 'objc_root_class属性はルートクラス宣言にのみ指定できます'
# 'object backing %select{|the pointer }0%1 will be destroyed at the end of the full-expression'
H4CCEF5B24A9C: 'オブジェクトのバックキング%select{|ポインタ }0%1は、完全式の終了時に破棄されます'
# 'object backing the pointer %0 will be destroyed at the end of the full-expression'
H4314D747B320: 'ポインタ%0のバックキングオブジェクトは、完全式の終了時に破棄されます'
# 'object backing the pointer will be destroyed at the end of the full-expression'
HCBDFA4406EFB: 'ポインタのバックキングオブジェクトは、完全式の終了時に破棄されます'
# 'object expression of non-scalar type %0 cannot be used in a pseudo-destructor expression'
H8E297F831414: '非スカラータイプ%0のオブジェクト式は、擬似デストラクタ式では使用できません'
# "object format flags cannot be used with '%0' conversion specifier"
HAF558B2410E4: "オブジェクト書式フラグは'%0'コンバージョン指定子と併用できません"
# 'object of type %0 cannot be %select{constructed|copied|moved|assigned|assigned|destroyed}1 because its %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}1 is implicitly deleted'
H828A944AA309: '%0型のオブジェクトは、その%select{デフォルトコンストラクタ|コピー コンストラクタ|ムーブ コンストラクタ|コピー代入演算子|ムーブ代入演算子|デストラクタ}1が暗黙のうちに削除されているため、%select{作成|コピー|移動|代入|代入|破棄}1できません'
# 'object of type %0 cannot be compared because its %1 is implicitly deleted'
H4465935A9154: '%0型のオブジェクトは、%1が暗黙のうちに削除されているため比較できません'
# 'object of type %0 cannot be placed in read-only memory'
HD27A532EA3C9: '%0型のオブジェクトは読み取り専用メモリに配置できません'
# 'object of type %0 is not compatible with %select{array element type|dictionary key type|dictionary value type}1 %2'
HBDF524B06F4F: '%0型のオブジェクトは、%select{配列要素の型|辞書のキーの型|辞書の値の型}1の%2と互換性ありません'
# "object whose reference is captured by '%0' will be destroyed at the end of the full-expression"
H1329A74CEAA1: "'%0'によってキャプチャされた参照のオブジェクトは、完全式の終了時に破棄されます"
# 'object whose reference is captured will be destroyed at the end of the full-expression'
H04404B93E557: 'キャプチャされた参照のオブジェクトは、完全式の終了時に破棄されます'
# 'octal integer literals are a C2y extension'
HCB95FC190C42: '8進数リテラルはC2y拡張機能です'
# 'octal integer literals are a Clang extension'
H0A7A0AD8FA23: '8進数リテラルはClang拡張機能です'
# 'octal integer literals are incompatible with standards before C2y'
HFF58B98B1092: '8進数リテラルはC2y以前の規格と互換性ありません'
# "octal literals without a '0o' prefix are deprecated"
H297C91C7799F: "'0o'プレフィックスのない8進数リテラルは非推奨になりました"
# 'offset of asan shadow mapping [EXPERIMENTAL]'
HB87160E3C269: 'asanシャドウマッピングのオフセット [実験的]'
# 'offset of on non-POD type %0'
H3798D618C09F: 'POD型でない型%0のoffsetof'
# 'offset of on non-standard-layout type %0'
H1C1DF95C948D: '標準レイアウト型でない型%0のoffsetof'
# 'offset-based plaintext format'
H4A173EEFA114: 'オフセットベースの平文形式'
# 'offsetof of incomplete type %0'
H01B4054FE86A: '未完全型%0のoffsetof'
# 'offsetof requires array type, %0 invalid'
H72E546984F9B: 'offsetofには配列型が必要です。%0は無効です'
# 'offsetof requires struct, union, or class type, %0 invalid'
H1EED7971DB36: 'offsetofには構造体、共用体、クラス型が必要です。%0は無効です'
# "old syntax '%0' on '%1' clause was deprecated, use new syntax '%2'"
H62AFC50986BB: "'%1'句における古い構文'%0'は非推奨になりました。新しい構文'%2'を使用してください"
# 'omit the namespace to add attributes to the most-recently pushed attribute group'
H33451023019A: '最新にプッシュされた属性グループに属性を追加する場合は名前空間を省略してください'
# 'omitting the parameter name in a function definition is a C23 extension'
H239CD59B1E97: '関数定義でパラメータ名を省略することはC23拡張機能です'
# 'on M-profile architectures %0 attribute is not supported on targets missing %1; specify an appropriate -march= or -mcpu='
HF63DAE65A9BA: 'Mプロファイルアーキテクチャでは%1を備えていないターゲットでは%0属性がサポートされません。適切な-march=または-mcpu=を指定してください'
# 'one cluster per opcode'
H571A5AC320D2: '各オペコード1つのクラスタ'
# "one of 'for', 'parallel', 'sections' or 'taskgroup' is expected"
HA318D6E65846: "'for'、'parallel'、'sections'、または'taskgroup'のいずれかが期待されます"
# 'one possibility'
HF5AE3D1F7A2D: '可能性の1つです'
# "only %select{'omp_priv' or 'omp_orig'|'omp_in' or 'omp_out'}0 variables are allowed in %select{initializer|combiner}0 expression"
HBFBFE733ACC9: "「%select{'omp_priv'または'omp_orig'|'omp_in'または'omp_out'}0」の変数のみ、%select{イニシャライザ|コンバイナ}0式で使用可能です"
# "only '*' can be exported from an inferred submodule"
HB1E7869E1AA8: "推論サブモジュールからは'*'のみをエクスポートできます"
# "only 'device_type(any)' clause is allowed with indirect clause"
H60FE040D9778: "'indirect句と共に'device_type(any)'句のみが許可されます"
# "only 'unavailable' and 'deprecated' are supported for Swift availability"
H711C14834055: "Swiftの可用性には'unavailable'と'deprecated'のみがサポートされています"
# 'only a single match extension allowed per OpenMP context selector'
H54ED4E173E0C: 'OpenMP コンテキストセレクタごとに1つのみマッチ拡張が許可されます'
# 'only allow matching call instructions if the name and type signature match.'
HA22B2A05D450: '名前と型シグネチャが一致する場合にのみ、一致する呼び出し命令を許可します'
# 'only apply branch boundary alignment in hot code'
H486A9C1A43ED: 'ホットコードでのみブランチ境界アライメントを適用します'
# 'only constructors take base initializers'
HDB605C258726: '基本初期化子はコンストラクタのみが取ります'
# 'only dump ids with the specified hexadecimal type index'
H5475CDF64D0B: '指定された16進数型インデックスを持つIDのみをダンプします'
# 'only dump symbol record with the specified symbol offset'
H990FE7E1637C: '指定されたシンボルオフセットを持つシンボルレコードのみをダンプします'
# 'only dump types with the specified hexadecimal type index'
HF6EF25D1A99D: '指定された16進数型インデックスを持つ型のみをダンプします'
# 'only enumeration types have underlying types'
H35007289C6D1: '基本型を有する型は列挙型のみです'
# 'only function and template parameters can be parameter packs'
HE058E90890AE: 'パラメータ・パックは関数とテンプレートパラメータのみが可能です'
# 'only functions can have deleted definitions'
H0BDC0C1C20D8: '削除定義は関数のみが持てます'
# 'only insert instrumentation on hot functions (needs profile, default: false)'
H6921A5326E9E: 'ホット関数のみにインストルメンテーションを挿入（プロファイルが必要、デフォルト: false）'
# "only loop iteration variables are allowed in 'lastprivate' clause in 'omp %0' directives"
H93109DDAC062: "'omp %0'ディレクティブの'lastprivate'句ではループ反復変数のみが許可されます"
# "only loop iteration variables are allowed in 'linear' clause in distribute directives"
HB4FBF6AB0B0A: "distributeディレクティブの'linear'句ではループ反復変数のみが許可されます"
# 'only one %0 clause can appear on a requires directive in a single translation unit'
H67EC4B23D848: '単一の翻訳単位内のrequiresディレクティブで%0句は1つしか指定できません'
# 'only one element declaration is allowed'
HB7E0C8F27CB5: '要素宣言は1つだけが許可されます'
# "only one expression allowed in '%0' clause"
H200100A1AF70: '%0句では1つの式のみが許可されます'
# 'only one offload target is supported'
H36578B307452: 'サポートされているオフロードターゲットは1つだけです'
# "only one parameter on 'main' declaration"
H09469DD0E50E: "'main'宣言にはパラメータは1つだけ許可されます"
# 'only perform sctc when branch direction is preserved'
HF40E26771C18: 'ブランチ方向が保持されている場合にのみSCTCを実行します'
# 'only promote call targets eligible for inlining'
H48B4D984BB43: 'インライン化可能な呼び出しターゲットのみを優先します'
# 'only recurse to a depth of N when displaying children of a symbol record.'
H9AF5A4C86831: 'シンボルレコードの子要素を表示する際には、深さNまで再帰します'
# 'only recurse to a depth of N when displaying parents of a symbol record.'
HFD73DE6E2DEF: 'シンボルレコードの親要素を表示する際には、深さNまで再帰します'
# 'only rename the instructions in the function'
H255C85A34C1B: '関数内の命令をリネームする場合は、それのみを対象とします'
# 'only replace exit value when it is an unused induction variable in the loop and has cheap replacement cost'
H4F514B4EF001: 'ループ内で未使用の誘導変数であり、置換コストが低い場合にのみ出口値を置換します'
# 'only replace exit value when the cost is cheap'
H8C5F857AAD22: 'コストが低い場合にのみ出口値を置換します'
# 'only replace exit values when loop def likely dead'
H1F90A0F5DC05: 'ループ定義がおそらくデッドな場合にのみ出口値を置換します'
# 'only show the top N results'
H31C65CA913F9: '上位N件のみを表示します'
# 'only special member functions %select{|and comparison operators }0may be defaulted'
H7676F4E831FD: '特殊メンバー関数%select{|および比較演算子 }0のみがデフォルトで指定可能です'
# 'only submodules and framework modules may be inferred with wildcard syntax'
HB41F304027AC: 'ワイルドカード構文で推論できるのはサブモジュールとフレームワークモジュールのみです'
# 'only the first dimension of an allocated array may have dynamic size'
HCC4AF93D4D25: '動的サイズを持つのは配列の最初の次元のみです'
# 'only top-level modules can be re-exported as public'
H35599F0992E5: 'トップレベルのモジュールのみがpublicとして再エクスポート可能です'
# 'only use samples from process with specified PID'
HE4657121A5A3: '指定されたPIDを持つプロセスからのサンプルのみを使用します'
# "only variable %0 is allowed in map clauses of this 'omp declare mapper' directive"
HCD77D6699FCF: "この'omp declare mapper'ディレクティブのマップ句では変数%0のみが許可されます"
# "only variables can be arguments to '#pragma unused'"
H454069F49B2C: "'#pragma unused'の引数として使用できるのは変数のみです"
# "only virtual member functions can be marked '%0'"
H88BCFFA5846F: "仮想メンバ関数のみが '%0' としてマークできます"
# 'only zero-length WebAssembly tables are currently supported'
H834ECF2F9D5B: '現在、長さ0のWebAssemblyテーブルのみがサポートされています'
# 'opcode to measure, by index, or -1 to measure all opcodes'
H04C71CF551B6: '測定対象のオペコードのインデックス、または全オペコードを測定する場合は-1'
# "operand argument to %select{overflow builtin|checked integer operation}0 must be an integer type %select{|other than plain 'char', 'bool', bit-precise, or an enumeration }0(%1 invalid)"
H232C02FD2560: "オーバーフロー組み込み関数|チェック付き整数操作%select{の}0オペランド引数は整数型%select{|'char'、'bool'、ビット精度、または列挙型以外の}0(%1 無効) が必要です"
# 'operand of ? changes signedness: %0 to %1'
H034F94202BD7: '? 演算子のオペランドの符号が変化しました：%0 から %1 に'
# 'operand of type %0 cannot be cast to a pointer type'
H39550A20AC28: '%0 型のオペランドはポインタ型にキャストできません'
# 'operand of type %0 where arithmetic or pointer type is required'
H73F559724DF8: '算術型またはポインタ型が必要な場所に%0 型のオペランドが使用されています'
# 'operands to conditional of types%diff{ $ and $|}0,1 are incompatible in ARC mode'
HA7936DDDD636: '条件式のオペランドの型%diff{ $ と $|}0,1 はARCモードで互換性ありません'
# "operator '%0' has lower precedence than '%1'; '%1' will be evaluated first"
H7655BF3550EE: "演算子'%0'は'%1'よりも優先順位が低いので、'%1'が先に評価されます"
# "operator '?:' has lower precedence than '%0'; '%0' will be evaluated first"
HFCE2B46187B8: "演算子'?:'は'%0'よりも優先順位が低いので、'%0'が先に評価されます"
# 'operators in fold expression must be the same'
H1479CC2CDE54: 'fold式内の演算子はすべて同じでなければなりません'
# 'opt-like flags'
H2AE16EED276B: 'optのようなフラグ'
# "optimization flag '%0' is not supported"
HED6E92EF31B3: "最適化フラグ'%0'はサポートされていません"
# "optimization flag '%0' is not supported for target '%1'"
H7BA15DDB49BE: "ターゲット'%1'に対して最適化フラグ'%0'はサポートされていません"
# "optimization level '%0' is not supported; using '%1%2' instead"
H6D18AF90D4BB: "最適化レベル'%0'はサポートされていません；代わりに'%1%2'を使用します"
# 'optimize PLT calls (requires linking with -znow)'
H1C6C02B1FC92: 'PLTコールを最適化（-znowオプションでリンカをリンクが必要）'
# 'optimize all PLT calls'
H729D15249489: 'すべてのPLTコールを最適化'
# 'optimize executed (hot) PLT calls'
HB328EE466E4E: '実行された（ホット）PLTコールを最適化'
# 'optimize functions with jump tables'
H1F9747FD82E4: 'ジャンプテーブルを使用する関数を最適化'
# 'optimize hottest calls until at least this percentage of all indirect calls frequency is covered. 0 = all callsites'
H770180548F4F: 'すべての間接コールの頻度の少なくともこのパーセンテージまでをカバーするまで、ホットコールを最適化。0=すべてのコールサイト'
# 'optimize stack frame accesses'
H72DEC23B9CC3: 'スタック・フレームへのアクセスを最適化'
# "option '%0' cannot be specified on this target"
H1BE1A4C28B5B: "このターゲットではオプション '%0' を指定できません。"
# "option '%0' cannot be specified with '%1'"
H70F63315B132: "オプション '%0' は '%1' と共に指定できません。"
# "option '%0' cannot be specified with '%1' for the %2 sub-architecture"
HBBDD552F5F1A: "サブ・アーキテクチャ %2 では、オプション '%0' は '%1' と共に指定できません。"
# "option '%0' cannot be specified without '%1'"
H583C3C9DA6E7: "オプション '%0' は '%1' を指定しないと使用できません。"
# "option '%0' requires input to be LLVM bitcode"
HA5B4E61775E4: "オプション '%0' は入力がLLVMビットコードである必要があります。"
# "option '%0' was ignored by the %1 toolchain, using '-fPIC'"
H22B2E1051C0B: "ツールチェーン %1 によってオプション '%0' は無視され、'-fPIC' が使用されました。"
# "option '-MG' requires '-M' or '-MM'"
HCCC4BA63CA80: "オプション '-MG' は '-M' または '-MM' を必要とします。"
# "option '-ffine-grained-bitfield-accesses' cannot be enabled together with a sanitizer; flag ignored"
H4FD110105D82: "オプション '-ffine-grained-bitfield-accesses' はサンitizerと同時に有効にできません；フラグは無視されました。"
# "option '-fmodule-output' cannot be used with multiple arch options"
H67AC45523A0C: "オプション '-fmodule-output' は複数のアーキテクチャ・オプションと共に使用できません。"
# "option '-fmodules-validate-once-per-build-session' requires '-fbuild-session-timestamp=<seconds since Epoch>' or '-fbuild-session-file=<file>'"
H5685B0FE4474: "オプション '-fmodules-validate-once-per-build-session' は '-fbuild-session-timestamp=<エポックからの秒数>' または '-fbuild-session-file=<ファイル>' を必要とします。"
# "option 'ffp-eval-method' cannot be used with option %select{'fapprox-func'|'mreassociate'|'freciprocal'}0"
H1D986A148023: "オプション 'ffp-eval-method' はオプション %select{'fapprox-func'|'mreassociate'|'freciprocal'}0 と共に使用できません。"
# 'options %0 and %1 are set to different values'
H15DAE6B37541: 'オプション %0 と %1 が異なる値に設定されています。'
# 'or because setter is declared here, but no getter method %0 is found'
H9306685E39B6: 'または、setter はここに宣言されていますが、getter メソッド %0 が見つかりません。'
# "or insert whitespace before ':' to use %0 as parameter name and have an empty entry in the selector"
H09DF98AB0B6F: "または、パラメータ名として %0 を使用し、セレクタに空のエントリを追加するには、':' の前に空白を挿入してください。"
# 'order by execution count'
H7EA3A097FEC2: '実行回数による並べ替え'
# 'ordered compare requires two args of floating point type%diff{ ($ and $)|}0,1'
HC6DBD7D802C7: '順序比較には、2つの引数が浮動小数点型%diff{ ($ と $)|}0,1 である必要があります。'
# 'ordered comparison between pointer and integer (%0 and %1)'
HCE8E7EA44A15: 'ポインタと整数 (%0 と %1) の間の順序比較'
# 'ordered comparison between pointer and zero (%0 and %1)'
H08DE668CB79E: 'ポインタとゼロ (%0 と %1) の間の順序比較'
# 'ordered comparison between pointer and zero (%0 and %1) is an extension'
HEFA21113E58A: 'ポインタとゼロ (%0 と %1) の間の順序比較は拡張機能です。'
# 'ordered comparison of function pointers (%0 and %1)'
H6623D571A716: '%0 と %1 との関数ポインタ間の順序比較'
# 'original arguments in round-trip: %0'
H88D576AD9392: 'round-trip における元の引数: %0'
# 'original arguments parse failed, then succeeded in round-trip'
H4354C394D0BE: '元の引数の解析に失敗しましたが、round-trip では成功しました'
# 'original storage of expression in data environment is shared but data environment do not fully contain mapped expression storage'
H8588EE9D0D77: 'データ環境内の式の元のストレージは共有されていますが、データ環境はマッピングされた式のストレージを完全には含んでいません'
# "orphaned 'omp %0' directives are prohibited; perhaps you forget to enclose the directive into a %select{|||target |teams|for, simd, for simd, parallel for, or parallel for simd }1region?"
H09B89CE1DDFB: "'omp %0' ディレクティブの孤児化は禁止されています。おそらく、ディレクティブを %select{|||target |teams|for, simd, for simd, parallel for, or parallel for simd }1 リージョンに含めるのを忘れていますか？"
# "os '%0' is not supported: '%1'"
HD285B7E47AB6: "OS '%0' はサポートされていません: '%1'"
# "os_log() '%%n' format specifier is not allowed"
HA308C5A1A678: "os_log() の '%%n' フォーマット仕様子は使用できません"
# 'os_log() argument %0 is too big (%1 bytes, max %2)'
H93B7553E2DE5: 'os_log() の引数 %0 が大きすぎます (%1 バイト、最大 %2)'
# 'os_log() format argument is not a string constant'
H6ABC3AD79FAA: 'os_log() のフォーマット引数は文字列定数ではありません'
# 'other definition of %0'
HFB23FE3FA4F8: '%0 の他の定義'
# 'out-of-line %select{declaration|definition}2 of %0 does not match any declaration in %1'
HC3CEC6EF88DD: '%0 の out-of-line %select{宣言|定義}2 が %1 のどの宣言とも一致しません'
# 'out-of-line %select{declaration|definition}2 of %0 does not match any declaration in %1; did you mean %3?'
H6724D4146D60: '%0 の out-of-line %select{宣言|定義}2 が %1 のどの宣言とも一致しません; %3 を指定した意図でしたか？'
# 'out-of-line constructor for %0 cannot have template arguments'
H33FE02CBF6A6: '%0 の out-of-line コンストラクタにはテンプレート引数を指定できません'
# 'out-of-line declaration of a member must be a definition'
HBCC796880D79: 'メンバの out-of-line 宣言は定義でなければなりません'
# 'out-of-line definition of %0 from class %1 without definition'
H3397C2717560: 'クラス %1 から %0 の out-of-line 定義が存在しません'
# 'out-of-line definition of constexpr static data member is redundant in C++17 and is deprecated'
HF4242355CFAD: 'constexpr static データメンバの out-of-line 定義は C++17 で不要となり、非推奨になりました'
# 'outline as many cold basic blocks as possible'
HA720A2B172BB: '可能な限り多くの cold basic blocks をアウトライン化'
# "output data (.csv) for Stoke's use"
H566F7B66D7EF: 'Stoke の使用のための出力データ（.csv）'
# 'output file to write out a summary of the partitions created for each module'
H9036C41EDFF6: '各モジュールで作成されたパーティションの要約を書き出すための出力ファイル'
# 'output file to write out the dotgraph representation of the input module'
H491BF84F04E2: '入力モジュールの dot グラフ表現を書き出すための出力ファイル'
# "output file; use '-' for stdout"
H239A9905E956: "出力ファイル; '-' を指定すると stdout に出力"
# 'output format'
H8D3CACC9A576: '出力形式'
# 'output in binary'
HF1C94F4E5F08: 'バイナリ形式で出力'
# 'output in yaml'
HFFA9E62F70D8: 'YAML 形式で出力'
# 'output the AST dump'
HE5094C7EDA7B: 'AST ダンプを出力'
# 'output the LLVM IR dump'
H722A785E838D: 'LLVM IR ダンプを出力'
# 'output the MLIR dump'
H5AB21662EF6D: 'MLIR ダンプを出力'
# 'output the MLIR dump after affine lowering'
H412D35179012: 'アフィンの下位変換後に MLIR ダンプを出力'
# 'output the MLIR dump after llvm lowering'
H5560C4070D86: 'LLVM の下位変換後に MLIR ダンプを出力'
# 'overflow converting case value to switch condition type (%0 to %1)'
HF36747707003: 'case 値を switch 条件型 (%0 から %1) に変換中にオーバーフローしました'
# 'overflow in expression; result is %0 with type %1'
H5FE3FC44898D: '式のオーバーフロー; 結果は型 %1 の %0'
# 'overlapping comparisons always evaluate to %select{false|true}0'
H9631A49EAD2B: '比較範囲の重複により常に %select{false|true}0 を返します'
# "overload resolution selected deleted operator '%0'%select{|: %2}1"
HB844E51E83EA: 'オーバーロード解消で削除された演算子 "%0" が選択されました%select{|: %2}1'
# 'overloaded %0 cannot be a static member function'
HE25D37D77FD9: 'オーバーロードされた %0 は静的メンバ関数にできません'
# 'overloaded %0 cannot be variadic'
H49C83B8BBB4E: 'オーバーロードされた %0 は可変長パラメータ不可'
# 'overloaded %0 cannot have %select{no|a defaulted|more than one}1 parameter before C++23'
H1FC62986EC90: 'C++23以前では %0 パラメータは %select{存在しない|デフォルト|複数}1 の場合が禁止されています'
# 'overloaded %0 must be a %select{unary|binary|unary or binary}2 operator (has %1 parameter%s1)'
HA142B5DEA04D: 'オーバーロード演算子 %0 は %select{一項|二項|その両方}2 演算子でなければなりません（%1 個のパラメータが指定されました）'
# 'overloaded %0 must be a non-static member function'
H359B48F5CEFF: 'オーバーロード演算子 %0 は静的でないメンバ関数でなければなりません'
# 'overloaded %0 must have at least one parameter of class or enumeration type'
H329B9199B7C8: 'オーバーロード演算子 %0 にはクラスまたは列挙型のパラメータが必要です'
# 'overloaded %0 with %select{no|a defaulted|more than one}1 parameter is a C++23 extension'
H9DE4D96FF9C0: '%0 のオーバーロードされた %select{0|1デフォルト|複数の}1 パラメータはC++23拡張です'
# 'overloaded operator %select{>>|<<}0 has higher precedence than comparison operator'
H3D68DF30B083: '優先順位が高い比較演算子に対して %select{>>|<<}0 オーバーロード演算子が使用されています'
# 'overridden method is here'
H33E209C67E48: 'オーバーライド元のメソッドはここにあります'
# 'overridden method returns an instance of its class type'
HA983C03A495A: 'オーバーライドされたメソッドはそのクラス型のインスタンスを返却します'
# 'overridden virtual function is here'
HFA2BCE5F4E2A: 'オーバーライドされた仮想関数はここにあります'
# 'override the name of the default PROGRAM entry (may be helpful for using other runtimes)'
HDBB3DF8CB32F: 'デフォルトのPROGRAMエントリ名を上書き（他のランタイムを使う場合に有効）'
# 'overrides DW_AT_comp_dir, and provides an alternative base location, which is used with DW_AT_dwo_name to construct a path to *.dwo files.'
HB19702484022: 'DW_AT_comp_dir を上書きし、DW_AT_dwo_name と組み合わせて*.dwoファイルのパスを構築するためのベースロケーションを提供します'
# "overriding '%0' option with '%1'"
H0BEA2CFA1C71: "'%0' オプションを '%1' で上書きしています"
# 'overriding currently unsupported rounding mode on this target'
HE764C7911186: '現在サポートされていないこのターゲットでの丸めモードを上書きしています'
# 'overriding currently unsupported use of floating point exceptions on this target'
H4E019EDC5E1E: '現在サポートされていないこのターゲットでの浮動小数点例外の使用を上書きしています'
# 'overriding method has mismatched ns_consumed attribute on its parameter'
H94209C3B1D29: 'パラメータの ns_consumed 属性が上位メソッドと不一致です'
# 'overriding method has mismatched ns_returns_%select{not_retained|retained}0 attributes'
HFA26D6769DAD: 'ns_returns_%select{not_retained|retained}0 属性が上位メソッドと不一致です'
# 'overriding the module target triple with %0'
H7A3B62788722: 'モジュールのターゲットトリプルを %0 で上書きしています'
# 'overriding virtual function must specify the same code segment as its overridden function'
HD38E3F8D7591: '仮想関数のオーバーライドは元の関数と同じコードセグメントを指定する必要があります'
# 'p'
H516B9783FCA5: 'p'
# 'pack declaration outside of template'
HDF7BB0B67932: 'テンプレート外でのパック宣言'
# 'pack expansion contains parameter pack %0 that has a different length (%1 vs. %select{|at least }2%3) from outer parameter packs'
H41600DB01010: '外側のパラメータパックと異なる長さ (%1 vs. %select{|最小 }2%3) のパラメータパック %0 が展開中に含まれています'
# 'pack expansion contains parameter pack %0 that has a different length (at least %1 vs. %2) from outer parameter packs'
H477211AA8361: '外側のパラメータパックと異なる長さ（最小 %1 vs. %2）のパラメータパック %0 が展開中に含まれています'
# 'pack expansion contains parameter packs %0 and %1 that have different lengths (%2 vs. %select{|at least }3%4)'
H4F8FA8F98117: '外側のパラメータパックと異なる長さ (%2 vs. %select{|最小 }3%4) のパラメータパック %0 と %1 が存在します'
# 'pack expansion does not contain any unexpanded parameter packs'
H8BAD94174D96: '展開中のパラメータパックが未展開のままです'
# 'pack expansion for initialization of member %0'
HBD2872B50273: 'メンバー %0 の初期化のためのパック展開'
# 'pack expansion of using declaration is a C++17 extension'
H1BE8FC7C5774: 'using宣言のパック展開はC++17の拡張機能です'
# 'pack expansion used as argument for non-pack parameter of %select{alias template|concept}0'
HBF85ED181091: 'パック展開が%select{エイリアス テンプレート|コンセプト}0の非パックパラメータの引数として使用されました'
# 'pack expansion using declaration is incompatible with C++ standards before C++17'
HFDB9F5A38038: 'C++17以前のC++規格では、using宣言のパック展開は互換性がありません'
# 'pack fold expression is a C++17 extension'
H7820808CC9E4: 'パック折り畳み式はC++17の拡張機能です'
# 'pack fold expression is incompatible with C++ standards before C++17'
H2F52B697F3BE: 'パック折り畳み式はC++17以前のC++規格と互換性がありません'
# 'pack indexing is a C++2c extension'
H1086B8F449EB: 'パックインデックスはC++2cの拡張機能です'
# 'pack indexing is incompatible with C++ standards before C++2c'
H9DAE09EBBEA1: 'C++2c以前のC++規格ではパックインデックスは互換性がありません'
# 'packed attribute is unnecessary for %0'
H08493DD022D1: '%0 に対してpacked属性は不要です'
# "packoffset at 'y' not match alignment %0 required by %1"
H1D68367EC4D7: "'y' での packoffset は %1 が必要とするアライメント %0 と一致しません"
# 'packoffset cannot cross register boundary'
HA00AFB61162C: 'packoffset はレジスタ境界を越えることはできません'
# 'packoffset overlap between %0, %1'
H8FBBA6B5715E: '%0 と %1 の間で packoffset が重複しています'
# 'padding %select{struct|interface|class}0 %1 with %2 %select{byte|bit}3%s2 to align %4'
HB4806E10E325: '%select{struct|interface|class}0 %1 をアライメント %4 にするため、%2 %select{byte|bit}3%s2 をパディングしています'
# 'padding %select{struct|interface|class}0 %1 with %2 %select{byte|bit}3%s2 to align anonymous bit-field'
HE333A36DBC3C: 'アノニマスビットフィールドへのアライメントのために、%select{struct|interface|class}0 %1 に %2 %select{byte|bit}3%s2 をパディングしています'
# 'padding %select{struct|interface|class}0 %1 with %2 %select{byte|bit}3%s2 to align anonymous field'
H1B5890218438: 'アノニマスフィールドへのアライメントのために、%select{struct|interface|class}0 %1 に %2 %select{byte|bit}3%s2 をパディングしています'
# 'padding size of %0 with %1 %select{byte|bit}2%s1 to alignment boundary'
H5BCCA44B6E5B: 'アライメント境界に合わせるために、%0 のパディングサイズを %1 %select{byte|bit}2%s1 で設定しています'
# 'parameter %0 must have a complete type to use function %1 with the %2 calling convention'
H35B9EA765265: '%2 コールコンベンションを使用して関数 %1 を使用するには、パラメータ %0 は完全な型をもたなければなりません'
# 'parameter %0 set but not used'
HB6BB1AF1B37E: 'パラメータ %0 は設定されていますが使用されていません'
# "parameter %0 was not declared, defaults to 'int'; ISO C99 and later do not support implicit int"
H41790618129F: 'パラメータ %0 は宣言されていません；デフォルトで「int」になります。ISO C99以降では暗黙のintはサポートされていません'
# "parameter '%0' is already documented"
HF9B7DF355428: 'パラメータ「%0」は既に文書化されています'
# "parameter '%0' not found in the function declaration"
HD7CC3BBE6634: "関数宣言にパラメータ '%0' が見つかりません"
# "parameter '%0' not in expected state when the function returns: expected '%1', observed '%2'"
H6EE5C60DD591: "関数が返却時にパラメータ '%0' の状態が予期した状態と一致しません: 期待値 '%1', 実際 '%2'"
# "parameter cannot be named '%select{global|unknown}0' while using 'lifetime_capture_by(%select{global|unknown}0)'"
H56545E5909EB: "パラメータを '%select{グローバル|不明}0' と名付けることは 'lifetime_capture_by(%select{グローバル|不明}0)' を使用中にできません"
# 'parameter declarator cannot be qualified'
HEB6B080E8792: 'パラメータ宣言子は修飾できません'
# 'parameter kind mismatch; parameter is %select{not a|a}0 parameter pack'
H53E71EC45244: 'パラメータの種類が一致しません; パラメータは%select{パックではありません|パックです}0'
# 'parameter may not be qualified with an address space'
HFB13BD25F7E6: 'パラメータはアドレス空間修飾子を付与できません'
# 'parameter name cannot have template arguments'
H4AE4E444760E: 'パラメータ名にはテンプレート引数を付与できません'
# 'parameter named %0 is missing'
HE41EE5512047: 'パラメータ名「%0」が見つかりません'
# "parameter of %0 attribute must be 'id' when used on a typedef"
H95DFECC378EF: '%0 属性が typedef で使用される場合、パラメータは「id」でなければなりません'
# 'parameter of %0 attribute must be a single name of an Objective-C %select{class|protocol}1'
H6E3911EE67CF: '%0 属性のパラメータは Objective-C の %select{クラス|プロトコル}1 の単一の名前でなければなりません'
# 'parameter of %0 cannot have a default argument'
H9997206462BD: '%0 のパラメータにはデフォルト引数を指定できません'
# "parameter of literal operator must have type 'unsigned long long', 'long double', 'char', 'wchar_t', 'char16_t', 'char32_t', or 'const char *'"
H18EF0BD0BEB6: 'リテラル演算子のパラメータは「unsigned long long」「long double」「char」「wchar_t」「char16_t」「char32_t」または「const char *」の型でなければなりません'
# 'parameter of overloaded %0 cannot have a default argument'
H31033CF29CE2: 'オーバーロードされた %0 のパラメータにはデフォルト引数を指定できません'
# "parameter of overloaded post-%select{increment|decrement}1 operator must have type 'int' (not %0)"
H42A579D6B7B0: 'オーバーロードされた post-%select{インクリメント|デクリメント}1 演算子のパラメータは「int」型でなければなりません（%0 ではありません）'
# 'parameter of overridden method is annotated with __attribute__((noescape))'
H1DC2A8B6BA41: 'オーバーライド元のメソッドのパラメータが __attribute__((noescape)) で修飾されています'
# 'parameter of overriding method should be annotated with __attribute__((noescape))'
HD9E0E2EF69AC: 'オーバーライドするメソッドのパラメータは __attribute__((noescape)) で修飾する必要があります'
# "parameter of the 'collapse' clause"
H978C7D7597CF: "'collapse' クラウスのパラメータ"
# 'parameter of type %0 is declared here'
HB0D7D36BAAD5: '型 %0 のパラメータはここに宣言されています'
# 'parameter pack %0 declared here'
HF649CEA110D0: 'パラメータ パック %0 はここに宣言されています'
# 'parameter pack cannot have a default argument'
H220429408CBD: 'パラメータパックにはデフォルト引数を指定できません'
# 'parameter references not allowed in naked functions'
HE9A90AF8CF8F: 'ヌード関数ではパラメータの参照は許可されていません'
# "parameterized class %0 already conforms to the protocols listed; did you forget a '*'?"
H0F239CE68A40: "パラメータ化されたクラス%0はすでにリストされたプロトコルに準拠しています；'*'を忘れたかもしれませんか？"
# 'parameters for defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator must have the same type%diff{ (found $ vs $)|}1,2'
H34C46A5FC53A: 'デフォルト指定された%select{<ERROR>|等価性|三項|等価性|比較}0比較演算子のパラメータには同じ型が必要です%diff{（$ と $ が見つかりました）|}1,2'
# "parent region for 'omp %select{cancellation point|cancel}0' construct cannot be nowait"
H10627ACFF3E1: "'omp %select{キャンセル ポイント|キャンセル}0'構造体の親リージョンはnowaitにできません"
# "parent region for 'omp %select{cancellation point|cancel}0' construct cannot be ordered"
H2F8AAD55F0CC: "'omp %select{キャンセル ポイント|キャンセル}0'構造体の親リージョンはorderedにできません"
# "parent umbrella does not match: '%0' (provided) vs '%1' (found)"
H38C90C7CC02F: "親のアンバrellaは一致しません：'%0'（指定） vs '%1'（見つかった）"
# "parent umbrella missing from %0: '%1'"
HCD77F7184E7F: "%0から親アンバrellaが見つかりません：'%1'"
# 'parentheses are required around macro argument containing braced initializer list'
H41A73FF55953: 'brace initializerリストを含むマクロ引数の周囲には括弧が必要です'
# 'parentheses are required around this expression in a requires clause'
H8DF4B4E0E5BD: 'requires句内のこの式の周囲には括弧が必要です'
# 'parentheses around address non-type template argument are a C++11 extension'
H55DF42498A9B: 'アドレス非型テンプレート引数の周囲の括弧はC++11の拡張機能です'
# 'parentheses around address non-type template argument are incompatible with C++98'
H8ACABCA7F85D: 'アドレス非型テンプレート引数の周囲の括弧はC++98と互換性ありません'
# "parentheses must be omitted if %0 attribute's argument list is empty"
H90F4FD29334C: '%0属性の引数リストが空の場合、括弧を省略しなければなりません'
# 'parentheses were disambiguated as a function declaration'
H329AE7B68E6C: '括弧は関数宣言として解消されました'
# 'parentheses were disambiguated as redundant parentheses around declaration of variable named %0'
H911B6F6318F6: '括弧は変数宣言%0の冗長な括弧として解消されました'
# 'parenthesize the second argument to silence'
HB3431A17CC77: '警告を抑制するには第二引数を括弧で囲んでください'
# 'parenthesized initialization of a member array is a GNU extension'
HD07F8AE496CA: 'メンバ配列の初期化における括弧の使用はGNU拡張機能です'
# 'parse the input, create a PFT, dump it, and exit'
H8632144C8313: '入力を解析し、PFTを作成し、ダンプして終了する'
# 'partial ordering for explicit instantiation of %0 is ambiguous'
HE38D1382AB5B: '%0の明示的インスタンス化の部分順序が曖昧です'
# 'partial specialization cannot be declared as a friend'
HA147DDFF5AB9: '部分専用化はフレンドとして宣言できません'
# 'partial specialization matches %0'
HA30AC1C7D740: '%0の部分特殊化が一致します'
# 'partial specialization of %0 does not use any of its template parameters'
H84CBC790F3FB: '%0の部分特殊化はそのテンプレートパラメータを全く使用していません'
# 'pass -fsafe-buffer-usage-suggestions to receive code hardening suggestions'
HB623B7D5D4C9: 'コードの強化に関する提案を受けるには-fsafe-buffer-usage-suggestionsを指定してください'
# 'passing %0-byte aligned argument to %1-byte aligned parameter %2%select{| of %4}3 may result in an unaligned pointer access'
H8E7373BFAB19: '%0バイトアライメントの引数を%1バイトアライメントのパラメータ%2%select{|の%4}3に渡すとアライメントされていないポインタアクセスが発生する可能性があります'
# 'passing %select{address of|reference to}0 local temporary object to musttail function'
H185CAE78405D: 'ローカル一時オブジェクトの%select{アドレス|参照}0をmusttail関数に渡しています'
# "passing %select{an object that undergoes default argument promotion|an object of reference type|a parameter declared with the 'register' keyword}0 to 'va_start' has undefined behavior"
H71043E0BAFE6: "'va_start'に%select{デフォルト引数プロモーションを受けるオブジェクト|参照型のオブジェクト|'register'キーワードで宣言されたパラメータ}0を渡すことは未定義動作です"
# "passing '%0' format string where '%1' format string is expected"
HB0DCC631BCB0: "'%1が期待されるフォーマット文字列の場所に'%0'フォーマット文字列を渡しています"
# "passing a type argument as the first operand to '_Generic' is a C2y extension"
H9B0C1A1B2AAD: "'_Generic'の最初のオペランドとして型引数を渡すのはC2y拡張です"
# "passing a type argument as the first operand to '_Generic' is incompatible with C standards before C2y"
H0B03D58A8538: "'_Generic'の最初のオペランドとして型引数を渡すことはC2y以前のC規格では互換性ありません"
# 'passing address of %select{non-local|non-scalar}0 object to __autoreleasing parameter for write-back'
H8F97A19F11B3: '%select{非ローカル|非スカラ}0 オブジェクトのアドレスを、書き戻し用の__autoreleasingパラメータに渡しています'
# 'passing argument to parameter %0 here'
H30E4C5FD05FE: 'ここでパラメータ%0に引数を渡しています'
# 'passing argument to parameter here'
HC7C3DD07B432: 'ここでパラメータに引数を渡しています'
# 'passing arguments to %select{a function|%1}0 without a prototype is deprecated in all versions of C and is not supported in C23'
H192BBFFB4918: 'プロトタイプなしで%select{関数|%1}0に引数を渡すことはCのすべてのバージョンで非推奨で、C23ではサポートされません'
# 'passing byval argument %0 with potentially incompatible alignment here'
H730F797EFCA9: 'ここで互換性のないアライメントを持つbyval引数%0を渡しています'
# "passing no argument for the '...' parameter of a variadic macro is a C++20 extension"
H6D5DB0C5BBB6: "variadicマクロの'...'パラメータに引数を渡さないことはC++20拡張です"
# "passing no argument for the '...' parameter of a variadic macro is a C23 extension"
H0F0C361742D6: "variadicマクロの'...'パラメータに引数を渡さないことはC23拡張です"
# "passing no argument for the '...' parameter of a variadic macro is incompatible with C standards before C23"
HCA1A72FB669A: "variadicマクロの'...'パラメータに引数を渡さないことはC23以前のC規格では互換性ありません"
# "passing no argument for the '...' parameter of a variadic macro is incompatible with C++ standards before C++20"
H2B8F35860B3B: "variadicマクロの'...'パラメータに引数を渡さないことはC++20以前のC++規格では互換性ありません"
# 'passing non-generic address space pointer to %0 may cause dynamic conversion affecting performance'
HAEF068C749A4: '%0に非汎用アドレス空間ポインタを渡すと実行時変換によるパフォーマンス影響が発生する可能性があります'
# "passing object of class type %0 through variadic %select{function|block|method|constructor}1%select{|; did you mean to call '%3'?}2"
H39C1EFFB876B: "%0クラス型のオブジェクトを変数長%select{関数|ブロック|メソッド|コンストラクタ}1%select{|経由で渡しています; '%3'を呼び出す意図でしたか？}2"
# 'passing object of trivial but non-POD type %0 through variadic %select{function|block|method|constructor}1 is incompatible with C++98'
HD5D2FE67C0FC: 'C++98と互換性のない非PODタイプの単純型%0を変数長%select{関数|ブロック|メソッド|コンストラクタ}1に渡しています'
# "passing only one argument to 'va_start' is incompatible with C standards before C23"
H0DFF95F6ABB1: 'C23以前のC規格と互換性のない理由でva_startに1つの引数を渡しています'
# "passing pointer %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
H9E268E19A549: "ロック%0を%select{'%2'|'%2'排他的に}3保持する必要がありますが、ポインタ%1を渡しています"
# "passing pointer to variable %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
H0E1F82092409: "ロック%0を%select{'%2'|'%2'排他的に}3保持する必要がありますが、変数%1へのポインタを渡しています"
# "passing the value that %1 points to by reference requires holding %0 %select{'%2'|'%2' exclusively}3"
HFB2B4F9A02B6: "ポインタ%1が指す値を参照で渡すため、ロック%0を%select{'%2'|'%2'排他的に}3保持する必要があります"
# 'passing union across security boundary via %select{parameter %1|return value}0 may leak information'
HA1E50C08E561: 'セキュリティ境界を越えて%select{パラメータ%1|戻り値}0経由でユニオンを渡すことで情報漏洩の可能性があります'
# "passing variable %1 by reference requires holding %0 %select{'%2'|'%2' exclusively}3"
HB011E968C37B: "ロック%0を%select{'%2'|'%2'排他的に}3保持する必要がありますが、変数%1を参照で渡しています"
# "pasting formed '%0', an invalid preprocessing token"
H17B929BA26C6: "'%0'という無効なプリプロセス処理トークンが生成されました"
# "pasting two '/' tokens into a '//' comment is a Microsoft extension"
HBFF0AAF786C4: "2つの'/'トークンを'//'コメントとして接合するのはMicrosoft拡張です"
# 'path to a pass plugin for HIP to SPIR-V passes.'
HF42DFD9FA413: 'HIPからSPIR-Vへのパスプラグインのパス。'
# 'path to instrumented binary in case if /proc/self/map_files is not accessible due to access restriction issues'
H9C547FEDA325: '/proc/self/map_filesへのアクセスが制限されている場合のインストゥルメント済みバイナリのパス'
# 'pc tracing with a guard'
H66AAE93ED197: 'ガード付きPCトレース'
# 'perf2bolt - BOLT data aggregator\n\nEXAMPLE: perf2bolt -p=perf.data executable -o data.fdata\n'
H64C11174A75F: 'perf2bolt - BOLTデータ集計ツール\n\n例: perf2bolt -p=perf.data 実行ファイル -o data.fdata\n'
# 'perform FOP on all functions'
H2A14A47C13E8: 'すべての関数でFOPを実行'
# 'perform FOP on hot functions'
H4C1838B87112: 'ホットな関数のみでFOPを実行'
# 'perform ICP on calls and jump tables'
H58DE93FE6F76: '間接呼び出しとジャンプテーブル向けICP実行'
# 'perform ICP on indirect calls'
HBCFC7E630187: '間接呼び出し向けICP実行'
# 'perform ICP on jump tables'
HF431F48B1DC7: 'ジャンプテーブル向けICP実行'
# 'perform layout optimizing I-cache behavior'
H978D4EED4690: 'Iキャッシュ動作の最適化を行うレイアウト最適化を実行'
# 'perform optimal layout based on profile'
HC1766F39AC7E: 'プロファイルに基づいた最適なレイアウトを実行'
# 'perform optimal layout prioritizing I-cache behavior'
HBDF007516F2C: 'Iキャッシュ動作を優先する最適なレイアウトを実行'
# 'perform optimal layout prioritizing branch predictions'
HB3E593E231FA: '分岐予測を優先する最適なレイアウトを実行'
# 'perform profiling accuracy-sensitive optimizations only if function execution count >= the threshold (default: 0)'
HFF64335273A6: '関数の実行回数が閾値以上の場合のみ、プロファイリング精度に敏感な最適化を実行（デフォルト: 0）'
# 'perform random layout of clusters'
H7C7C380E5354: 'クラスタのランダムなレイアウトを実行'
# 'perform verification of LLVM instruction encoding/decoding. Every instruction in the input is decoded and re-encoded. If the resulting bytes do not match the input, a warning message is printed.'
H52D0672FF953: 'LLVM命令のエンコード/デコードの検証を実行。入力のすべての命令をデコードして再エンコードします。結果のバイトが入力と一致しない場合、警告メッセージが表示されます。'
# 'performSelector may cause a leak because its selector is unknown'
H653C9447EE92: 'performSelectorが未知のセレクタのため、リークが発生する可能性があります'
# 'performSelector names a selector which retains the object'
HF51E4C8347B0: 'performSelectorはオブジェクトを保持するセレクタを指定しています'
# 'performing pointer arithmetic on a null pointer has undefined behavior%select{| if the offset is nonzero}0'
HA288389E9F6A: 'NULLポインタでのポインタ算術は未定義の動作です%select{|オフセットが非ゼロの場合}0'
# 'performing pointer subtraction with a null pointer %select{has|may have}0 undefined behavior'
HB725A707608F: 'NULLポインタとのポインタ減算は%select{未定義の動作です|未定義の動作する可能性があります}0'
# 'performs disassembly sequentially'
HDD6DFBE032D2: '順次逆アセンブルを実行'
# 'permutation index must be at least 1 and at most %0'
H0297CCE3F38F: '順列インデックスは1以上%0以下でなければなりません'
# 'pick register allocator based on -O option'
H46CB03DD1B68: '-Oオプションに基づいてレジスタアロケータを選択'
# 'pipes packet types cannot be of reference type'
H354A6AC50D78: 'パイプパケット型は参照型にすることができません'
# "place '...' %select{immediately before declared identifier|here}0 to declare a function parameter pack"
HD82CBB258C12: "関数パラメータパックを宣言するには、'...'を%select{宣言された識別子の直前に|ここに}0配置してください"
# 'place all array allocations more than <size> elements on the heap'
H7583F9BA4C9F: '要素数が<size>を超える配列の配置をヒープ上に配置'
# 'place all array allocations of dynamic size on the heap'
H1E67C0E84EC2: '動的サイズの配列配置をすべてヒープ上に配置'
# 'place parentheses around comparison expression to evaluate it first'
H1021BF49A48F: '比較式を最初に評価するには、丸カッコで囲んでください'
# 'place parentheses around the %0 expression to evaluate it first'
HD79F2195D659: '式の評価を優先するには%0式の周囲に丸括弧を追加してください'
# "place parentheses around the '%0' expression to silence this warning"
H7195F835EC30: "この警告を抑制するには'%0'式の周囲に丸括弧を追加してください"
# "place parentheses around the '?:' expression to evaluate it first"
H9605DB1A560A: "評価を優先するには'?:'式の周囲に丸括弧を追加してください"
# 'place parentheses around the assignment to silence this warning'
HE705E4D071BD: 'この警告を抑制するには代入の周囲に丸括弧を追加してください'
# 'place parentheses around the string literal to silence warning'
H876899527936: '警告を抑制するには文字列リテラルの周囲に丸括弧を追加してください'
# 'placeholder declared here'
H7E34AEC856E5: 'プレイスホルダはここに宣言されています'
# 'placeholder variables are a C++2c extension'
H4C0235C28642: 'プレイスホルダ変数はC++2cの拡張機能です'
# 'placeholder variables are incompatible with C++ standards before C++2c'
H6BE10CEEDF1B: 'プレイスホルダ変数はC++2cより前のC++規格と互換性がありません'
# 'placement new would change type of storage from %0 to %1'
H83FB1C107237: 'placement newを使用すると、%0から%1へのストレージの型が変更されます'
# "plain '_Complex' requires a type specifier; assuming '_Complex double'"
HBC4E2F0D8FF6: '_Complex単体では型指定子が必要です。"_Complex double"を仮定します'
# "platform does not match: '%0' (provided) vs '%1' (found)"
H5C64A2FB6312: "プラットフォームが一致しません:'%0'(指定) vs '%1'(検出)"
# "please rebuild precompiled header '%0'"
HFBA0A20CA8AF: "'%0'のプリコンパイルヘッダーを再構築してください"
# 'plt'
H8B8091C3AD1A: 'plt'
# 'pointer %0 declared here'
H22E4F3576FCE: '%0ポインタはここに宣言されています'
# "pointer arguments to kernel functions must reside in '__global', '__constant' or '__local' address space"
HEE966568F6BF: "カーネル関数へのポインタ引数は'__global'、'__constant'、または'__local'アドレス空間に存在する必要があります"
# 'pointer cannot be cast to type %0'
H0546695B4A22: 'ポインタを%0型にキャストできません'
# 'pointer cannot be mapped along with a section derived from itself'
HAF06E92DEBA3: 'ポインタは自身から派生したセクションと同時にマップできません'
# 'pointer comparisons before C11 need to be between two complete or two incomplete types; %0 is %select{|in}2complete and %1 is %select{|in}3complete'
H4DB22EDB67C8: 'C11以前のポインタ比較では、完全または不完全な2つの型同士である必要があります;%0は%select{|in}2complete、%1は%select{|in}3completeです'
# "pointer to function type %0 may not be 'restrict' qualified"
H909D3E85FCFF: '%0型の関数ポインタは"restrict"修飾できません'
# 'pointer to type %0 is invalid in OpenCL'
HEF9B07C9C640: '%0型のポインタはOpenCLでは無効です'
# 'pointer type mismatch%diff{ ($ and $)|}0,1'
H8EAA8DFC686A: 'ポインタ型の不一致%diff{ ($0 と $1)|}0,1'
# 'pointer-to-member function type %0 can only be called on an %select{rvalue|lvalue}1'
H08EA28E0562A: 'ポインタ-メンバ関数型 %0 は %select{rvalue|lvalue}1 に対してのみ呼び出せます'
# 'pointer/integer type mismatch in conditional expression%diff{ ($ and $)|}0,1'
HC15C6EF198BF: '条件式におけるポインタ/整数型の不一致%diff{ ($0 と $1)|}0,1'
# 'poison on failure'
HE44AF8732393: '失敗時の poison'
# 'poison undef temps'
H7A7B675BE411: '未定義のテンポラリ変数に poison を適用'
# 'poison uninitialized stack variables'
H47518342CB8C: '初期化されていないスタック変数に poison を適用'
# 'poison uninitialized stack variables with a call'
H429653491DDF: '呼び出しを使用して初期化されていないスタック変数に poison を適用'
# 'poison uninitialized stack variables with the given pattern'
H338B60F2873D: '指定されたパターンを使用して初期化されていないスタック変数に poison を適用'
# 'poisoning existing macro'
HDD8F2D4A6FAB: '既存のマクロに poison を適用'
# 'position arguments in format strings start counting at 1 (not 0)'
HC64922328C30: 'フォーマット文字列の位置引数は 1 から数えます（0 ではありません）'
# "position-independent code requires '-mabicalls'"
H69FA922C5B49: '位置独立コードには "-mabicalls" が必要です'
# 'positional arguments are not supported by ISO C'
HE496161E3DDA: 'ISO C では位置引数はサポートされていません'
# 'possible misuse of comma operator here'
H0A8E98669706: 'ここでのコンマ演算子の誤用の可能性'
# 'possible target for call'
H16BA315A6C23: '呼び出しの可能なターゲット'
# 'possible target of %select{indirect|asm}0 goto statement'
H03DE80F51E17: '%select{indirect|asm}0 goto 文の可能なターゲット'
# 'postfix attributes are not allowed on Objective-C directives'
HA57AC12B1C85: 'Objective-C ディレクティブには接尾辞属性は許可されていません'
# "postfix attributes are not allowed on Objective-C directives, place them in front of '%select{@interface|@protocol}0'"
H83C11CD38B50: 'Objective-C ディレクティブには接尾辞属性は許可されていません、%select{@interface|@protocol}0 の前に配置してください'
# 'potential performance regression from use of __builtin_expect(): annotation was correct on %0 of profiled executions'
HD6474E353C24: '__builtin_expect() の使用による潜在的なパフォーマンス劣化: プロファイリング実行の %0 でアノテーションが正しかった'
# 'pp-trace options'
H87829B6B5E89: 'pp-trace オプション'
# 'pragma %0 requires a parenthesized string'
H25DF715FB71D: 'pragma %0 には括弧で囲まれた文字列が必要です'
# 'pragma %select{message|warning|error}0 requires parenthesized string'
H58AE415DBC7A: 'pragma %select{message|warning|error}0 は括弧で囲まれた文字列を必要とします'
# 'pragma STDC FENV_ROUND is not supported'
HF7A928CE98B4: 'pragma STDC FENV_ROUND はサポートされていません'
# 'pragma comment requires parenthesized identifier and optional string'
HD6BA08D64805: 'pragma comment は括弧で囲まれた識別子とオプションの文字列を必要とします'
# 'pragma detect_mismatch is malformed; it requires two comma-separated string literals'
H82A7E617FBD6: 'pragma detect_mismatch の構文が正しくありません；2つのカンマ区切りの文字列リテラルが必要です'
# "pragma diagnostic expected 'error', 'warning', 'ignored', 'fatal', 'push', or 'pop'"
HD2286608AABA: "pragma diagnostic には 'error', 'warning', 'ignored', 'fatal', 'push', または 'pop' を指定する必要があります"
# 'pragma diagnostic expected option name (e.g. "-Wundef")'
HF5C6654FAE5F: 'pragma diagnostic にはオプション名（例: "-Wundef"）が指定されていません'
# 'pragma diagnostic pop could not pop, no matching push'
H6F8E683545E5: 'pragma diagnostic pop は対応する push が見つからないため実行できません'
# "pragma float_control is malformed; use 'float_control({push|pop})' or 'float_control({precise|except}, {on|off} [,push])'"
HDD83603CAD05: "pragma float_control の構文が正しくありません；'float_control({push|pop})' もしくは 'float_control({precise|except}, {on|off} [,push])' を使用してください"
# "pragma include_alias expected '%0'"
H01DD8237CC21: "pragma include_alias には '%0' が指定されていません"
# 'pragma include_alias expected include filename'
H08BDBEAABFC9: 'pragma include_alias にはインクルードファイル名が指定されていません'
# "pragma pop_macro could not pop '%0', no matching push_macro"
HF67398D54EBA: "pragma pop_macro は対応する push_macro が見つからないため '%0' をポップできません"
# "preceding '...' declares a function parameter pack"
HB271FF2CAE5F: "前の '...' は関数パラメータパックを宣言しています"
# 'precompiled'
H5B5680CDE56B: 'プリコンパイル済み'
# "precompiled header '%0' was ignored because '%1' is not first '-include'"
H47051C658E08: "プリコンパイルヘッダー '%0' は、'%1' が最初の '-include' でないため無視されました"
# "precompiled header '%0' was ignored because it is not a clang PCH file"
HC110D52BBD02: "プリコンパイルヘッダー '%0' は clang PCH ファイルではないため無視されました"
# "precompiled header directory '%0' was ignored because it contains no clang PCH files"
H3E91139CDF42: "プリコンパイルヘッダーディレクトリ '%0' は clang PCH ファイルが含まれていないため無視されました"
# 'predefined allocator cannot have traits specified'
H8666F51519BE: 'プリディファインド アロケータにはトレイトを指定できません'
# 'predefined identifier is only valid inside function'
HF82196FF10EA: 'プリディファインド識別子は関数内でのみ有効です'
# "predefined trait '%0' used here"
H55566D31A8B9: "プリディファインド特性 '%0' がここに使用されています"
# 'predetermined as a firstprivate in a task construct here'
H405D7D760401: 'タスク構文内で事前に firstprivate として指定されています'
# 'prefer tail-folding, create scalar epilogue if tail folding fails.'
HD0E4E0A8CB08: 'tail-foldingを優先し、tail-foldingが失敗した場合はscalar epilogueを生成します。'
# 'prefer update form when ds form is also a update form'
HEA9A1D5F496C: 'ds formが更新形式の場合、更新形式を優先します。'
# 'prefer_list item must be a string literal or constant integral expression'
HCAFE9C287B6C: 'prefer_listの項目は文字列リテラルまたは定数整数式でなければなりません。'
# "prefers tail-folding, don't attempt vectorization if tail-folding fails."
H12E0DCDDA093: 'tail-foldingを優先し、tail-foldingが失敗した場合、ベクトル化を試みません。'
# 'prefix attribute must be followed by an interface, protocol, or implementation'
H129BA69DE7F2: 'prefix属性はinterface、protocol、またはimplementationを続きでなければなりません。'
# 'prefix with the address-of operator to silence this warning'
H51278B3A983C: 'この警告を抑制するにはアドレスオブジェクト演算子でプレフィックスを付けてください。'
# 'prepare update form when the load/store increment is a loop invariant non-const value.'
H7F0464394BFE: 'ロープイナリアント非定数値のload/storeインクリメントがある場合、更新形式を準備します。'
# 'preserve intermediate .o file'
HBCF9A92B45C8: '中間の.oファイルを保持する'
# 'pretty-print DWARF debug information in object files and debug info archives.\n'
HFF4E6027BC6C: 'オブジェクトファイルやデバッグ情報アーカイブ内のDWARFデバッグ情報を整形して表示します。\n'
# 'previous %select{template type|non-type template|template template}0 parameter%select{| pack}1 declared here'
HEDFC0D57E1AE: '前の%select{テンプレート型|非型テンプレート|テンプレートテンプレート}0パラメータ%select{| pack}1はここに宣言されています。'
# 'previous %select{unmarked |}0overload of function is here'
HAE3E66A916BE: '前の%select{未指定 |}0オーバーロード関数はここにあります。'
# "previous '#pragma pack' directive that modifies alignment is here"
H39F3F82E0571: 'alignementを変更する前の#pragma packディレクティブはここにあります。'
# "previous '%0' directive used here"
HE7A8B08DD5DE: "前の'%0'ディレクティブはここに使用されています。"
# "previous 'critical' region starts here"
H3FBC82C6CFEF: "前の'critical'領域はここから始まります。"
# 'previous allocator is specified here'
H065261987D15: '前のアロケータはここに指定されています。'
# 'previous attribute is here'
H6E32F6609895: '前の属性はここにあります。'
# 'previous binding pack specified here'
H720F62C2E50B: '前のバインディングパックはここに指定されています。'
# 'previous call is here%select{; set to nil to indicate it cannot be called afterwards|}0'
HE8A56E8F5AF3: '前の呼び出しはここにあります%select{; 後続の呼び出し不可能を示すためにnilに設定します|}0'
# 'previous case defined here'
H67B17B33B89D: '前のケースはここに定義されています。'
# 'previous clause is here'
HE9FAFB90DAE5: '前の節はここにあります。'
# 'previous clause with directive name modifier specified here'
H59743B40EF38: 'ここに指定されたディレクティブ名修飾子を伴う前の句'
# "previous command '%select{\\|@}0%1' (an alias of '\\%2') here"
HE969B475A653: "前のコマンド '%select{\\|@}0%1' (アリIAS '\\%2'の別名) はここです"
# "previous command '%select{\\|@}0%1' here"
H5B43AF8F451D: "前のコマンド '%select{\\|@}0%1' はここです"
# 'previous declaration is here'
H9CAB5B6B1715: '前の宣言はここです'
# 'previous declaration of class template partial specialization %0 is here'
H8EF5BDE072C8: 'クラステンプレートの部分専用化 %0 の前の宣言はここです'
# 'previous declaration of variable template partial specialization is here'
H5A936ED6E7F5: '変数テンプレートの部分専用化の前の宣言はここです'
# 'previous default generic association is here'
H5A119A508D2B: '前のデフォルトの汎用関連付けはここです'
# 'previous default template argument defined here'
H828BBDD8C7F9: 'ここに定義された前のデフォルトテンプレート引数'
# 'previous default template argument defined in module %0'
H2F92B57F5F02: 'モジュール %0 で定義された前のデフォルトテンプレート引数'
# 'previous definition is here'
H0AC845A11A85: '前の定義はここです'
# 'previous documentation'
H8053B03861AE: '前のドキュメンテーション'
# 'previous equal key is here'
H916F7D758598: '前の等しいキーはここです'
# 'previous explicit instantiation is here'
HCA86CACA9800: '前の明示的インスタンチエーションはここです'
# 'previous expression is here'
H72EA4DC42083: '前の式はここです'
# 'previous implicit declaration is here'
H2F8B22E01C4A: '前の暗黙の宣言はここです'
# 'previous inheritance model specified here'
HDD10F14D9687: 'ここに指定された前の継承モデル'
# 'previous initialization %select{|with side effects }0is here%select{| (side effects will not occur at run time)}0'
HFE059F4FA2A1: '前の初期化 %select{|副作用を伴う }0はここです%select{| (実行時に副作用は発生しません)}0'
# 'previous initialization for field %0 is here'
HEF0E98EA391B: 'フィールド %0 の前の初期化はここです'
# 'previous module declaration is here'
HD052ACC784A7: '前のモジュール宣言はここです'
# 'previous non-type template parameter with type %0 is here'
H5A88D83E2220: '型 %0 の非型テンプレートパラメータの前の宣言はここです'
# 'previous reference is here'
HEFAE6804D795: '前の参照はここです'
# 'previous return statement is here'
H147041BC8FB0: '前のreturn文はここです'
# 'previous statement is here'
H94AB14DFE365: '前のステートメントはここです'
# 'previous template %select{declaration|template parameter}0 is here'
H94CA97347769: '前の%select{宣言|テンプレート パラメータ}0はここです'
# 'previous template specialization is here'
H0FDA24AE451B: '前のテンプレートの特殊化はここです'
# 'previous use is here'
H39A31F8B143F: '前の使用はここです'
# 'previous uuid specified here'
H8206D7044433: 'ここで指定された前のuuid'
# "previously declared '%0' here"
H4ECE9D2CF70E: "以前に宣言された'%0'はここです"
# "previously declared '%1' here"
H6BFF38DE7EEF: "以前に宣言された'%1'はここです"
# 'previously declared as %0 here'
HEA5BCF07D9E2: 'ここに以前に%0として宣言されました'
# 'previously defined as an alias for %0'
HC8CE8DE52E3E: '%0へのエイリアスとして定義済み'
# 'previously defined here'
H0787B53F4571: 'ここに以前に定義済み'
# 'previously marked as task_reduction with different reduction operation'
HFE3CA309C947: '異なる削減演算でtask_reductionが以前に指定されていました'
# 'previously referenced here'
H8ADE478F0E44: '以前に参照されました'
# 'primary property declaration is implicitly strong while redeclaration in class extension is weak'
H331A66416F47: 'プライマリプロパティ宣言がクラス拡張の再宣言でweakであるのに対しimplicit strongでした'
# 'print ORC unwind information for instructions'
H4E31B5E474E7: '命令のためのORCアンワインド情報を印刷'
# 'print aliases when printing objects'
HF92219983E87: 'オブジェクトを印刷する際にエイリアスを表示'
# 'print all SDT markers'
H98709AE1B551: 'すべてのSDTマーカーを印刷'
# 'print all proposals received and whether they were rejected or accepted'
H04A22263A041: '受け取ったすべての提案を印刷（拒否/承認の結果付き）'
# 'print all registered sections'
H8FAB43011447: '登録済みのすべてのセクションを表示'
# 'print clusters'
H9B37594EE600: 'クラスタを表示'
# 'print debug info when printing functions'
HFF8256E364B3: '関数を表示する際、デバッグ情報を表示'
# 'print dyno stats after each stage'
H9275B8D7E627: '各ステージ後にdyno statsを表示'
# 'print everything - most verbose'
H1BEA0BEF5E2F: 'すべてを表示 - 最も詳細'
# 'print exception handling data'
H8F7DF5B5AC2D: '例外処理データを表示'
# 'print execution info based on profile'
H93C84C9D44B9: 'プロファイルに基づいて実行情報を表示'
# 'print function after CFG is finalized'
H87F7D6E5ADA5: 'CFGが最終化後の関数を表示'
# 'print function after disassembly'
H6524D80C8BFA: '逆アsemblし後の関数を表示'
# 'print function after edge counts are set for no-LBR profile'
H3061E9C9E191: 'no-LBRプロファイルのエッジカウントが設定された後の関数を表示'
# 'print function after fixing local branches'
H1402AC66D1C0: 'ローカルブランチを修正した後の関数を表示'
# 'print function after instruction lowering'
H612727DB3C18: '命令のlowering後の関数を表示'
# 'print function after jt-footprint-reduction pass'
HDF747925B28E: 'jt-footprint-reductionパス後の関数を表示'
# 'print functions after ADR Relaxation pass'
H380909F95FC6: 'ADR Relaxationパス後の関数を表示'
# 'print functions after CFG construction'
HCF99E2AF5C10: 'CFG構築後の関数を表示'
# 'print functions after CFG is normalized'
H52A0761BF0A3: 'CFGが正規化された後の関数を表示'
# 'print functions after ICF optimization'
H0BC917F969E4: 'ICF最適化後の関数を表示'
# 'print functions after PLT optimization'
HF2CB032C6433: 'PLT最適化後の関数を表示'
# 'print functions after attaching profile'
HD8A5C41FAD15: 'プロファイルをアタッチした後の関数を表示'
# 'print functions after bodyless optimization'
HBA38B0532A13: 'ボディレス最適化後の関数を表示'
# 'print functions after clustering'
H867D3C181C5B: 'クラスタリング後の関数を表示'
# 'print functions after code splitting'
HFFE83E7C36B6: 'コード分割後の関数を表示'
# 'print functions after conditional tail call simplification'
H0EFD18F8B1CE: '条件付きテールコールの単純化後の関数を表示'
# 'print functions after each stage'
H6F2DBD4C3BE5: '各ステージ終了後に関数を表示'
# 'print functions after fix RISCV calls pass'
HA11DE9F7CABB: 'RISCVコール修正パス後の関数を表示'
# 'print functions after fix relaxations pass'
H9A6C75CABE6B: 'リラクセーション修正パス後の関数を表示'
# 'print functions after frame optimizer pass'
H37293007159E: 'フレーム最適化パス後の関数を表示'
# 'print functions after indirect call promotion'
H6777ED6D8688: '間接呼び出しの昇格後の関数を表示'
# 'print functions after inlining optimization'
H849DB929CE9A: 'インライン展開最適化後の関数を表示'
# 'print functions after layout optimization'
H1EAABA34176F: 'レイアウト最適化後の関数を表示'
# 'print functions after longjmp pass'
H2C02F65E2B10: 'longjmpパス後の関数を表示'
# 'print functions after peephole optimization'
HF6F27EE243F4: 'ピープホール最適化後の関数を表示'
# 'print functions after regreassign pass'
H205E59625248: 'regreassignパス後の関数を表示'
# 'print functions after retpoline insertion pass'
H348587451657: 'retpoline挿入パス後の関数を表示'
# 'print functions after simplification of RO data loads'
HA796FD5DA60B: 'ROデータロード単純化後の関数を表示'
# 'print functions after stoke analysis'
H090E8674EC1A: 'Stoke分析後の関数を表示'
# 'print functions after unreachable code elimination'
HC31930E74334: '到達不能コード削除パス後の関数を表示'
# 'print functions after veneer elimination pass'
HD9F864AE57D7: 'veneer削除パス後の関数を表示'
# 'print functions of binary 2 that were not matched to any function in binary 1'
H74494F9D492B: 'バイナリ2の関数でバイナリ1のどの関数とも一致しなかったものを表示'
# 'print functions sorted by execution count'
HB0992E5F3DD7: '実行回数でソートされた関数を表示'
# 'print functions sorted by order of dyno stats'
H0A27E3FA15F0: 'dyno統計の順序でソートされた関数を表示'
# 'print functions sorted by total branch count'
H58EE9BACA77C: 'トータルのブランチ数に基づいてソートされた関数を表示'
# 'print functions that could not be overwritten due to excessive size'
H64A4A3141F70: '過剰なサイズのため上書きできなかった関数を表示'
# 'print functions that have profile in binary 1 but do not in binary 2'
H8FB878E6408D: 'バイナリ1にプロファイルを持つがバイナリ2にはない関数を表示'
# 'print global symbols after disassembly'
H6F71EE919FF4: '逆アセンブル後のグローバルシンボルを表示'
# 'print jump tables'
HE7814FCDE82F: 'ジャンプテーブルを表示'
# 'print loop related information'
H1CC87F1B29B5: 'ループ関連の情報を表示'
# 'print mappings in the legend, between characters/blocks and text sections (default false)'
HAB49FA127C23: 'legend内のcharacters/blocksとテクストセクション間のマッピングを表示（既定値false）'
# 'print memory data annotations when printing functions'
HE37470A2DD9C: '関数を表示する際にメモリデータのアノテーションを表示'
# 'print names of functions with unknown control flow'
H02687E68D720: '不明な制御フローを持つ関数の名前を表示'
# 'print no details'
HE1459B6CBBDF: '詳細を表示しない'
# 'print out instructions with default strict semantics'
HBF6B61DB25E4: 'デフォルトの厳密なセマンティクスを持つ命令を表示'
# 'print output address range for each basic block in the function whenBinaryFunction::print is called'
H4D2F05339EF5: 'BinaryFunction::printが呼び出された際に、関数内の各基本ブロックのアドレス範囲を表示'
# "print pass arguments to pass to 'opt'"
H6E943315CBC7: 'optに渡すパスの引数を表示'
# 'print pass details when it is executed'
H76B02F3EE5E5: 'パスが実行される際の詳細を表示'
# 'print pass name before it is executed'
H741AF7A7B7D4: 'パスが実行される前に名前を表示'
# 'print pass structure before run()'
HF0D6992C747F: 'パスの構造をrun()の前に表示'
# 'print per instruction opcode dyno stats and the functionnames:BB offsets of the nth highest execution counts'
HED6C36296EF9: '各命令のオペコードdyno統計と、nth番目に高い実行カウントを持つfunctionnames:BBオフセットを表示'
# 'print profile quality/bias analysis'
H2BA901542885: 'プロファイル品質/バイアス分析を表示'
# 'print pseudo probe info'
H497835ACD698: '疑似プローブ情報を表示'
# 'print regions in detail with block_iterator'
HC53F268C8D37: 'block_iteratorを使用して領域を詳細に表示'
# 'print regions in detail with element_iterator'
HEED2CD6BB906: '要素イテレータを使用して領域を詳細に表示'
# 'print register usage details collected for analysis.'
H852E76ABE034: '分析のために収集したレジスタ使用詳細を表示'
# 'print relocations when printing functions/objects'
HC7882ECBD016: '関数/オブジェクトを表示する際に再配置を表示'
# 'print section contents after reordering'
HBFCEFB46E060: '再配置後のセクション内容を表示'
# 'print statistics about basic block ordering'
HD0B0C3B01A36: '基本ブロックの並び替えに関する統計を表示'
# 'print the CFG of important functions that changed in binary 2'
H50C9F66DBC43: 'バイナリ2で変更された重要な関数の制御フローグラフを表示'
# 'print the basic blocks showed in top differences'
H1DA154B840C3: '上位の差分に表示された基本ブロックを表示'
# 'print the list of functions with stale profile'
HE912214BA092: '古いプロファイルを持つ関数の一覧を表示'
# 'print the list of objects with count to stderr'
H2C756772AFAF: 'カウントを含むオブジェクトの一覧をstderrに出力'
# 'print time spent constructing binary functions'
H5978E6E15455: 'バイナリ関数の構築にかかった時間を表示'
# 'print time spent in each optimization'
H0BBB239D4108: '各最適化にかかった時間を表示'
# 'print time spent in rewriting passes'
H40857EC64F6B: '書き換えパスにかかった時間を表示'
# 'print top <uint> functions with suboptimal code layout on input'
HBFD8DED23E2E: '入力で非最適なコード配置を持つ上位<uint>関数を表示'
# 'printing of statistics for each inlined function'
HCEA14F1643A5: 'インライン関数ごとの統計の表示'
# 'prints out offsets for abbrev and debug_info of Skeleton CUs that get patched.'
H71912C66C3FC: 'パッチ適用されたスケルトンCUのabbrevとデバッグ情報のオフセットを表示'
# 'prioritize low virtual register numbers for test and debug'
H0A6C1C201BCE: 'テストとデバッグ用に仮想レジスタ番号を低番号優先に'
# "private API notes file for module '%0' should be named '%0_private.apinotes', not '%1'"
HB68113D2F79A: "モジュール'%0'のプライベートAPIノートファイルは'%0_private.apinotes'と名前を付ける必要があります。'%1'は使用しないでください"
# 'private field %0 is not used'
H3584A3B50C2A: 'プライベートフィールド%0は使用されていません'
# 'private module fragment begins here'
H3A617A73B3A6: 'プライベートモジュールフラグメントはここから始まります'
# 'private module fragment declaration with no preceding module declaration'
H1202B7565A2E: '事前のモジュール宣言がないプライベートモジュールフラグメント宣言'
# 'private module fragment in module implementation unit'
H48CE0D8A14BD: 'モジュール実装ユニット内のプライベートモジュールフラグメント'
# 'private module fragment redefined'
H1427CFAECC58: 'プライベートモジュールフラグメントが再定義されました'
# "private submodule '%0' in private module map, expected top-level module"
HCB6CC643EA83: "プライベートモジュールマップ内のプライベートサブモジュール '%0'、トップレベルモジュールが期待されます"
# 'probability argument to __builtin_expect_with_probability is outside the range [0.0, 1.0]'
HFB32BCF3AB99: '関数 __builtin_expect_with_probability の確率引数は範囲 [0.0, 1.0] の外側です'
# 'probability argument to __builtin_expect_with_probability must be constant floating-point expression'
H828E266CB5B1: '関数 __builtin_expect_with_probability の確率引数は定数浮動小数点式でなければなりません'
# 'process functions with stack pointer arithmetic'
H56D80573022C: 'スタックポインタ算術を伴う関数を処理'
# 'profile data may be incomplete: of %0 function%s0, %1 %plural{1:has|:have}1 no data'
H8ACA9571B75F: 'プロファイルデータが不完全である可能性があります: %0関数のうち、%1 %plural{1:は|:が}1データがありません'
# 'profile data may be out of date: of %0 function%s0, %1 %plural{1:has|:have}1 mismatched data that will be ignored'
HBED3698588C8: 'プロファイルデータが古くなっている可能性があります: %0関数のうち、%1 %plural{1:は|:が}1不整合なデータが無視されます'
# 'propagate shadow through ICmpEQ and ICmpNE'
HB09C108C7674: 'ICmpEQ と ICmpNE を通じてシャドウを伝播'
# 'propagating dll attribute to %select{already instantiated|explicitly specialized}0 base class template without dll attribute is not supported'
H6A4E6175A865: 'dll 属性を %select{すでにインスタンス化された|明示的に特殊化された}0 ベースクラステンプレートに伝播することはサポートされていません（dll 属性がありません）'
# 'property %0 attempting to use instance variable %1 declared in super class %2'
HDDED40707D8D: 'プロパティ %0 が、スーパークラス %2 で宣言されたインスタンス変数 %1 を使用しようとしています'
# 'property %0 cannot be found in forward class object %1'
H503270AA1975: 'プロパティ %0 はフォワードクラスオブジェクト %1 で見つかりません'
# 'property %0 declared with incompatible types in different translation units (%1 vs. %2)'
H2F559B93D7CB: '異なる翻訳ユニットで宣言されたプロパティ %0 の型が互換性ありません（%1 対 %2）'
# 'property %0 found on object of type %1; did you mean to access it with the "." operator?'
H0A371D1A94C3: '型 %1 のオブジェクトでプロパティ %0 が見つかりました。. オペレーターでアクセスする必要があるかもしれません'
# 'property %0 has a variably modified type'
H81C9932A69B3: 'プロパティ %0 の型は可変長変数です'
# "property %0 is a class property; did you mean to access it with class '%1'?"
HFC5FD97AFD4C: "プロパティ %0 はクラスプロパティです。クラス '%1' を使用してアクセスする必要がありますか？"
# 'property %0 is already implemented'
H4ECC248CA95F: 'プロパティ %0 は既に実装されています'
# 'property %0 is declared %select{deprecated|unavailable|partial}1 here'
HC2D276377832: 'この場所でプロパティ %0 は %select{非推奨|使用不可|部分的}1 として宣言されています'
# 'property %0 is implemented with %select{@synthesize|@dynamic}1 here'
H43FFE47B4C6F: 'この場所でプロパティ %0 は %select{@synthesize|@dynamic}1 で実装されています'
# 'property %0 is implemented with %select{@synthesize|@dynamic}1 in one translation but %select{@dynamic|@synthesize}1 in another translation unit'
H7C85E91BA02D: 'プロパティ %0 は 1 つの翻訳ユニットでは %select{@synthesize|@dynamic}1 で、別の翻訳ユニットでは %select{@dynamic|@synthesize}1 で実装されています'
# 'property %0 is synthesized to different ivars in different translation units (%1 vs. %2)'
HE49921A78EC2: 'プロパティ %0 は異なる翻訳単位で異なるインスタンス変数に合成されています (%1 と %2)'
# 'property %0 not found on object of type %1'
H2822C5946CF1: 'タイプ %1 のオブジェクトにプロパティ %0 は存在しません'
# 'property %0 not found on object of type %1; did you mean %2?'
HBDBDE3E27B96: 'タイプ %1 のオブジェクトにプロパティ %0 は存在しません; %2 を指す意図でしたか？'
# 'property %0 not found on object of type %1; did you mean to access instance variable %2?'
H8C5C6406F710: 'タイプ %1 のオブジェクトにプロパティ %0 は存在しません; インスタンス変数 %2 にアクセスする意図でしたか？'
# 'property %0 not found on object of type %1; did you mean to access property %2?'
H9C85D93EEE02: 'タイプ %1 のオブジェクトにプロパティ %0 は存在しません; プロパティ %2 にアクセスする意図でしたか？'
# 'property %0 refers to an incomplete Objective-C class %1 (with no @interface available)'
H5BDCDB941EFA: 'プロパティ %0 は未完成のObjective-Cクラス %1 (利用可能な@interfaceなし)を指します'
# 'property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this category'
HD9354003F0AB: 'プロパティ %0 はメソッド %1 を定義する必要があります - @dynamicを使用するかこのカテゴリに実装を追加してください'
# 'property %0 requires method %1 to be defined - use @synthesize, @dynamic or provide a method implementation in this class implementation'
HD343415F7FA6: 'プロパティ %0 はメソッド %1 を定義する必要があります - @synthesize、@dynamicを使用するかこのクラス実装に実装を追加してください'
# "property %select{of type %1|with attribute '%1'|without attribute '%1'|with getter %1|with setter %1}0 was selected for synthesis"
HAD70544BC938: "%select{タイプ %1 のプロパティ|属性 '%1' を持つプロパティ|属性 '%1' を持たないプロパティ|ゲッター %1 を持つプロパティ|セッター %1 を持つプロパティ}0 が合成に選択されました"
# 'property access is using %0 method which is deprecated'
HC446F861F2EE: 'プロパティ アクセスは非推奨の %0 メソッドを使用しています'
# 'property access is using %0 method which is unavailable'
H61B587B99038: 'プロパティ アクセスは利用不可の %0 メソッドを使用しています'
# 'property access result unused - getters should not be used for side effects'
H1D3B4CAFB27A: 'プロパティ アクセスの結果が未使用です - ゲッターは副作用のために使用しないでください'
# 'property attribute in class extension does not match the primary class'
H928CE0C5C480: 'クラス拡張のプロパティ属性は主クラスと一致しません'
# "property attributes '%0' and '%1' are mutually exclusive"
H4A7BE0C59F5F: "プロパティ属性 '%0' と '%1' は排他的です"
# 'property cannot have array or function type %0'
HE68B6C09E364: 'プロパティは配列または関数タイプ %0 を持てません'
# 'property declaration cannot have a default member initializer'
H5272D8E5D57E: 'プロパティ宣言はデフォルトのメンバ初期化子を指定できません'
# "property declaration specifies '%0' accessor twice"
H0E68E4E4BA05: "プロパティ宣言は'%0' アクセサーを2回指定しています"
# 'property declared as returning non-retained objects; getter returning retained objects'
H53034807D818: 'プロパティは非保持オブジェクトを返すように宣言されています; ゲッターは保持されたオブジェクトを返します'
# 'property declared here'
H69D70856EBD1: 'プロパティはここに宣言されています'
# 'property declared in category %0 cannot be implemented in class implementation'
H04FE1B1065E1: 'カテゴリ%0で宣言されたプロパティはクラスの実装で実装できません'
# 'property does not specify a getter or a putter'
HD0F5818FB6C8: 'getterまたはputterを指定していません'
# "property follows Cocoa naming convention for returning 'owned' objects"
HEBB6CB98CE86: "'owned'オブジェクトを返すためのCocoaの命名規則に従うプロパティ"
# 'property has a previous declaration'
H28BB0E9D9F7A: 'プロパティは以前の宣言を持っています'
# 'property implementation in a category with no category declaration'
HF42022DEA14A: 'カテゴリ宣言がないカテゴリでプロパティを実装しています'
# 'property implementation must be in a class or category implementation'
HD59CD2B75162: 'プロパティの実装はクラスまたはカテゴリの実装内で行う必要があります'
# 'property implementation must have its declaration in interface %0 or one of its extensions'
HFCF842D4EB86: 'プロパティの実装には、インターフェース%0またはその拡張のいずれかで宣言が必要です'
# 'property implementation must have its declaration in the category %0'
H761B0BB38838: 'プロパティの実装には、カテゴリ%0での宣言が必要です'
# 'property is assumed atomic by default'
H2882A0CD4FD8: 'プロパティはデフォルトで原子的とみなされます'
# 'property is assumed atomic when auto-synthesizing the property'
HC5E58A6AB217: 'プロパティを自動合成する際は原子的とみなされます'
# 'property is synthesized to ivar %0 here'
H7E91E310D399: 'プロパティはここでivar %0に合成されています'
# 'property name cannot be a bit-field'
H8E1C0549C2E5: 'プロパティ名はビットフィールドにできません'
# 'property requires fields to be named'
H9C4AAD2700BB: 'プロパティではフィールドに名前を付ける必要があります'
# 'property should be changed to be readwrite'
H32DF2D479322: 'プロパティはreadwriteに変更する必要があります'
# 'property synthesized here'
H0BB379E6C96C: 'プロパティはここで合成されています'
# 'property type %0 is incompatible with type %1 inherited from %2'
HDE3695134102: 'プロパティの型%0は、%2から継承された型%1と互換性がありません'
# "property with '%0' attribute must be of object type"
H44EF18C35C26: "'%0'属性を持つプロパティはオブジェクト型でなければなりません"
# 'protected %select{constructor|destructor}0 can only be used to %select{construct|destroy}0 a base class subobject'
H8490EFD629C0: 'protected %select{コンストラクタ|デストラクタ}0 は、基底クラスのサブオブジェクトを%select{作成|破棄}0するためにのみ使用できます'
# 'protocol %0 has no definition'
H3F201B2D647A: 'プロトコル %0 は定義されていません'
# 'protocol has circular dependency'
HBFCB55FB9C5B: 'プロトコルには循環依存関係があります'
# "protocol has no object type specified; defaults to qualified 'id'"
H79AE64D3788F: 'プロトコルにはオブジェクトタイプが指定されていません；デフォルトでは修飾された「id」が使用されます'
# 'protocol is declared here'
H63C66770E070: 'プロトコルはここに宣言されています'
# 'protocol method is expected to return an instance of the implementing class, but is declared to return %0'
HCECBCE2ED619: 'プロトコルメソッドは実装クラスのインスタンスを返す必要がありますが、%0 を返すように宣言されています'
# 'protocol method is here'
H850DBE7D30DB: 'プロトコルメソッドはここにあります'
# 'protocol qualifiers must precede type arguments'
HE1585F9267E6: 'プロトコルの修飾子は型引数の前に置く必要があります'
# "provided host compiler IR file '%0' is required to generate code for OpenMP target regions but cannot be found"
H4ECB10C5BABB: '提供されたホストコンパイラIRファイル「%0」はOpenMPターゲット領域のコード生成に必要ですが、見つかりませんでした'
# 'pseudo-destructor call is not permitted in constant expressions until C++20'
HFC660C022DFD: 'C++20まで、定数式内で疑似デストラクタの呼び出しは許可されていません'
# 'pseudo-destructor destroys object of type %0 with inconsistently-qualified type %1'
HFC3306882505: '疑似デストラクタは、一貫性のない修飾タイプ %1 の型 %0 のオブジェクトを破棄します'
# 'pseudo-destructors on type void are a Microsoft extension'
H6C76EC18D3A0: 'void型の疑似デストラクタはMicrosoftの拡張機能です'
# "public framework header includes private framework header '%0'"
H7F0AEF01704E: 'パブリックフレームワークヘッダーがプライベートフレームワークヘッダー「%0」を含んでいます'
# 'pure virtual function %q0 called'
H3187DE144A64: '純粋仮想関数 %q0 が呼び出されました'
# 'put the semicolon on a separate line to silence this warning'
HD2A85AED0A2F: 'この警告を抑制するには、セミコロンを別行に配置してください'
# "putter for property must be specified as 'put', not 'set'"
H65FA70517FA4: 'プロパティのputterは「set」ではなく「put」として指定する必要があります'
# 'qualified call to %0::%1 is treated as a virtual call to %1 due to -fapple-kext'
HAEBB9D60FCD1: '-fapple-kextのため、%0::%1への修飾呼び出しは%1への仮想呼び出しとして扱われます'
# 'qualified destructor name only found in lexical scope; omit the qualifier to find this type name by unqualified lookup'
H95040EDE1833: '修飾デストラクタ名はレキシカルスコープ内でのみ見つかります；この型名を未修飾検索で探すには修飾子を省略してください'
# 'qualified member access refers to a member in %0'
H69C8244E4885: '修飾メンバーアクセスは%0のメンバーを指します'
# 'qualified module name can only be used to define modules at the top level'
HCDFABF1A81DD: '修飾モジュール名は、トップレベルでのみモジュールを定義するために使用できます'
# 'qualified name refers into a specialization of %select{function|variable}0 template %1'
H4C7D694E4A70: '修飾名はテンプレート %1 の %select{関数|変数}0 の特殊化を参照しています'
# 'qualified reference to %0 is a constructor name rather than a %select{template name|type}1 in this context'
H08AE31B94F15: 'このコンテキストでは %0 の修飾参照は %select{テンプレート名|型}1 ではなくコンストラクタ名です'
# "qualifier 'const' is needed for variables in address space '%0'"
HADB69D493623: 'アドレス空間 "%0" の変数には "const" 修飾子が必要です'
# 'qualifier in explicit instantiation of %q0 requires a template-id (a typedef is not permitted)'
HB21409C3C5FB: '%q0 の明示的インスタンス化修飾子にはテンプレート識別子が必要です（typedefは許可されません）'
# 'qualifiers after comma in declarator list are ignored'
H09D49C9D12E0: '宣言子リストのカンマ後の修飾子は無視されます'
# 'qualify call to silence this warning'
HDB3D8B807347: 'この警告を抑制するには修飾付き呼び出しを使用してください'
# 'r11 available before calls and jumps'
H69431C8A884E: 'r11は呼び出しとジャンプの前に利用可能です'
# 'r11 available before calls but not before jumps'
HAF3B1E936CB4: 'r11は呼び出しの前に利用可能ですが、ジャンプの前には利用できません'
# 'r11 not available'
HD51A31809CB5: 'r11は利用できません'
# "range-based 'for' statement uses ':', not '='"
HC53E3757D97C: "範囲ベースの 'for' 文は ':', ではなく '=' を使用します"
# 'range-based for loop has empty body'
H2C4FFAA3CE47: '範囲ベースの for ループの本体が空です'
# 'range-based for loop initialization statements are a C++20 extension'
H77FF5523C4B8: '範囲ベースの for ループの初期化ステートメントはC++20拡張機能です'
# 'range-based for loop initialization statements are incompatible with C++ standards before C++20'
H529EE263FDB4: '範囲ベースの for ループの初期化ステートメントはC++20以前の標準と互換性がありません'
# 'range-based for loop is a C++11 extension'
HE56D92957A6D: '範囲ベースの for ループはC++11拡張機能です'
# 'range-based for loop is incompatible with C++98'
H2229A30F511E: '範囲ベースの for ループはC++98と互換性がありません'
# 'range-based for loop requires type for loop variable'
H07E32C6E46BC: '範囲ベースの for ループにはループ変数の型が必要です'
# 'raw string delimiter longer than 16 characters; use PREFIX( )PREFIX to delimit raw string'
H00B2DC6A7B32: '生文字列の区切り記号が16文字を超えています。区切りには PREFIX( )PREFIX を使用してください'
# 'raw string literals are incompatible with C++98'
H1C93D8A83CA2: '生文字列リテラルはC++98と互換性がありません'
# 'raw string missing terminating delimiter )%0"'
H7FD087037BE3: '生文字列の終端区切り記号 )%0" がありません'
# "re-exported libraries do not match: '%0' (provided) vs '%1' (found)"
H6C320DEC171A: "再エクスポートされたライブラリが一致しません: '%0' (提供) と '%1' (検出)"
# "re-exported library missing from %0: '%1'"
H552D4BA598A3: "%0 から再エクスポートされたライブラリが見つかりません: '%1'"
# 're-use space in old .text if possible (relocation mode)'
H05BFF380B5E6: '可能な場合、古い .text セクションの領域を再利用します（再配置モード）'
# 'read of incomplete type %0 is not allowed in a constant expression'
HCA641211FEEB: '定数式では未完全な型 %0 の読み取りは許可されていません'
# 'read of non-const variable %0 is not allowed in a constant expression'
HD99D6E4F37A4: '定数式では非const変数 %0 の読み取りは許可されていません'
# 'read of non-constexpr variable %0 is not allowed in a constant expression'
HF3D92222C519: '定数式では constexpr でない変数 %0 の読み取りは許可されていません'
# 'read of variable %0 of non-integral, non-enumeration type %1 is not allowed in a constant expression'
H33BFBE7CF01D: '定数式では積分型でも列挙型でもない型 %1 の変数 %0 の読み取りは許可されていません'
# "readonly IBOutlet property %0 when auto-synthesized may not work correctly with 'nib' loader"
H582EA0DF024A: "auto-synthesized時にreadonlyのIBOutletプロパティ %0 は、'nib' ローダーと正しく動作しない可能性があります"
# 'reassign registers so as to avoid using REX prefixes in hot code'
HE2FFC9EC6F02: 'ホットコード内でREXプレフィックスを使用しないようにレジスタを再割り当てします'
# 'received warning after diagnostic serialization teardown was underway: %0'
H60ECB032353D: '診断シリアリゼーションの終了処理中に警告が受け取られました: %0'
# 'receiver %0 for class message is a forward declaration'
HAE87B957CEBD: 'クラスメッセージの受信者 %0 は前方宣言です'
# 'receiver %0 is a forward class and corresponding @interface may not exist'
H2EFCADD231BF: '受信者 %0 は前方宣言クラスであり、対応する @interface が存在しない可能性があります'
# 'receiver expression is here'
H16AA23E5E187: '受信者式はここにあります'
# 'receiver is instance of class declared here'
H063C50E49E8E: '受信者はここで宣言されたクラスのインスタンスです'
# "receiver is treated with 'id' type for purpose of method lookup"
H23B037191711: "メソッド検索の目的で受信者は 'id' 型として扱われます"
# 'receiver type %0 for instance message is a forward declaration'
H4107B7B01A42: 'インスタンスメッセージの受信者型 %0 は前方宣言です'
# "receiver type %0 is not 'id' or interface pointer, consider casting it to 'id'"
HC44380DEE815: "受信者型 %0 は 'id' またはインターフェースポインタではありません。'id' にキャストする必要があります"
# 'receiver type %0 is not an Objective-C class'
HDF1E1AF5B7B2: '受信者型 %0 はObjective-Cクラスではありません'
# 'record profile for inter-function control flow activity (default: true)'
HB3410F96E4B8: '関数間の制御フロー活動のプロファイルを記録（デフォルト: true）'
# 'recursive evaluation of default argument'
H9D22EE24805A: 'デフォルト引数の再帰評価'
# 'recursive template instantiation exceeded maximum depth of %0'
H9F7DB4D308D0: '再帰テンプレートインスタンティエーションが最大深さ %0 を超えました'
# "redeclaration cannot add 'loader_uninitialized' attribute"
H70EFB9FBF448: "再宣言では'loader_uninitialized'属性を追加できません"
# 'redeclaration has different alignment requirement (%1 vs %0)'
H2965974DE860: '再宣言のアラインメント要件が異なります（%1 vs %0）'
# "redeclaration of %0 must %select{not |}1have the 'overloadable' attribute"
H9C609286F3D1: "%0の再宣言は%select{not |}1'overloadable'属性を有する必要があります"
# 'redeclaration of %0 with a different type%diff{: $ vs $|}1,2'
HEB05B74B4F52: '%0の再宣言は異なる型%diff{：$ vs $|}1,2'
# 'redeclaration of %q0 cannot add %q1 attribute'
H437273BF8230: '%q0の再宣言では%q1属性を追加できません'
# 'redeclaration of %q0 should not add %q1 attribute'
HBC3EEF68F79F: '%q0の再宣言では%q1属性を追加すべきではありません'
# "redeclaration of C++ built-in type 'bool'"
H4DE1B64751F8: "C++の組み込み型'bool'の再宣言"
# 'redeclaration of already-defined enum %0 is a GNU extension'
H3B72AE37DEEE: '既に定義されたenum %0の再宣言はGNU拡張です'
# 'redeclaration of deduction guide'
H6C137FDA5914: '推論ガイドの再宣言'
# 'redeclaration of method parameter %0'
H0D9F6CE9B2EA: 'メソッドパラメータ%0の再宣言'
# 'redeclaration of type parameter %0'
HC29DAC039CAB: '型パラメータ%0の再宣言'
# 'redeclaration of using declaration'
H96E43918A485: 'using宣言の再宣言'
# 'redeclaration of using-enum declaration'
H7EA3B309B6C8: 'using-enum宣言の再宣言'
# 'redeclaring non-static %0 as static is a Microsoft extension'
H853738CC6C0D: '非静的%0を静的に再宣言することはMicrosoft拡張です'
# 'redefining builtin macro'
H6021415EA4BB: '組み込みマクロの再定義'
# 'redefinition of %0'
HB70C986DD184: '%0の再定義'
# 'redefinition of %0 as an alias for a different namespace'
H97345A757B2F: '%0を異なる名前空間のエイリアスとして再定義'
# 'redefinition of %0 as different kind of symbol'
H9380CBD04275: '%0を異なる種類のシンボルとして再定義'
# 'redefinition of %0 will not be visible outside of this function'
H6605A7137B7E: '%0の再定義はこの関数の外では見えません'
# 'redefinition of %0 with a different type%diff{: $ vs $|}1,2'
HB1C0A119B95E: '%0の異なる型%diff{：$ vs $|}1,2での再定義'
# 'redefinition of %select{typedef|type alias}0 for variably-modified type %1'
HB599B51A5F4D: '%select{typedef|type alias}0のvariably-modified type %1に対する再定義です'
# "redefinition of a 'extern inline' function %0 is not supported in %select{C99 mode|C++}1"
HF158368144B8: "%select{C99モード|C++}1では、'extern inline' 関数 %0 の再定義はサポートされていません"
# 'redefinition of concept %0 with different template parameters or requirements'
H4C4283523181: 'テンプレートパラメータまたは要件が異なるコンセプト %0 の再定義です'
# 'redefinition of default argument'
H6507C3F7227D: 'デフォルト引数の再定義です'
# 'redefinition of enumerator %0'
H1EE462BB5E46: '列挙子 %0 の再定義です'
# 'redefinition of forward class %0 of a typedef name of an object type is ignored'
H06040CF8C316: 'オブジェクト型のtypedef名のための前方宣言クラス %0 の再定義は無視されます'
# 'redefinition of inferred submodule'
H43BB40E423BF: '推論されたサブモジュールの再定義です'
# 'redefinition of label %0'
HD4F4A928D72C: 'ラベル %0 の再定義です'
# 'redefinition of method parameter %0'
HE18AEF27C9A1: 'メソッド引数 %0 の再定義です'
# "redefinition of module '%0'"
H6249FB58D003: "モジュール '%0' の再定義です"
# 'redefinition of parameter %0'
H88BE534E3F7A: 'パラメータ %0 の再定義です'
# 'redefinition of typedef %0 is a C11 feature'
H8B88EC5F6F5C: 'typedef %0 の再定義はC11の機能です'
# 'redefinition of user-defined mapper for type %0 with name %1'
HADE614C371DA: '名前 %1 を持つ型 %0 のユーザー定義マッパーの再定義です'
# 'redefinition of user-defined reduction for type %0'
H4B307482E8CD: '型 %0 のユーザー定義リダクションの再定義です'
# 'redirect journaling to a file instead of stdout/stderr'
H5FEA9D013494: 'stdout/stderrではなくファイルにジャーナルをリダイレクトします'
# "reduction type cannot be %select{qualified with 'const', 'volatile' or 'restrict'|a function|a reference|an array}0 type"
H2D2C74F27FDF: 'リダクション型は%select{const、volatile、またはrestrictで修飾された型|関数型|参照型|配列型}0であることはできません'
# 'reduction variables may not be accessed in an explicit task'
H233496630504: '明示的なタスク内でリダクション変数にアクセスすることはできません'
# "redundant #include of module '%0' appears within %1"
H3B45950DD3A3: "%1 内にモジュール '%0' の重複#includeが存在します"
# 'redundant %0 availability change; only the last specified change will be used'
HE2065BD86C26: '%0 の使用可能変更の重複；最後に指定された変更のみが使用されます'
# "redundant 'sycl_kernel_entry_point' attribute"
H89B952CF4093: "'sycl_kernel_entry_point' 属性の重複です"
# "redundant attribute subject matcher sub-rule '%0'; '%1' already matches those declarations"
HE12FF717092C: "冗長な属性サブルール '%0'; '%1' は既にそれらの宣言に一致しています"
# 'redundant move in return statement'
HC34A9F2066D1: 'return 文における冗長な移動'
# 'redundant parentheses surrounding declarator'
H47E8307AF60E: 'declaratorを取り囲む冗長な括弧'
# "ref-qualifier '%select{&&|&}0' is not allowed on a constructor"
H5FB2827C1F13: "コンストラクタには参照修飾子 '%select{&&|&}0' を使用できません"
# "ref-qualifier '%select{&&|&}0' is not allowed on a destructor"
H0C7698A4B274: "デストラクタには参照修飾子 '%select{&&|&}0' を使用できません"
# "ref-qualifier '&&' is not allowed on a defaulted comparison operator"
HE95322EAF78E: "デフォルトされた比較演算子には参照修飾子 '&&' を使用できません"
# 'refactoring action cannot be initiated without a selection'
H24ED847BB22A: '選択が行われていないため、リファクタリング操作を開始できません'
# 'reference %0 is not yet bound to a value when used here'
HF3E8D22129FD: 'この場所で使用される際、参照 %0 はまだ値に束縛されていません'
# 'reference %0 is not yet bound to a value when used within its own initialization'
HB4996BB1A27E: 'その初期化の内部で使用される際、参照 %0 はまだ値に束縛されていません'
# 'reference %diff{to %select{type|incomplete type}1 $ could not bind to an %select{rvalue|lvalue}2 of type $|could not bind to %select{rvalue|lvalue}2 of incompatible type}0,3'
HFAC2C332E9F4: '参照 %diff{の %select{型|未完成型}1 $ は、型 $ の %select{rvalue|lvalue}2 に束縛できません|互換性のない型の %select{rvalue|lvalue}2 に束縛できません}0,3'
# 'reference binding of non-type template parameter %diff{of type $ to template argument of type $|to template argument}0,1 ignores qualifiers'
H093001BBE364: '非型テンプレートパラメータ %diff{の型 $ をテンプレート引数の型 $ への参照の束縛|テンプレート引数への参照の束縛}0,1 は修飾子を無視します'
# 'reference cannot be bound to dereferenced null pointer in well-defined C++ code; comparison may be assumed to always evaluate to %select{true|false}0'
H136F139EE8E6: 'C++の明確なコードにおいて、参照は null ポインタの解除参照に束縛できません; 比較は常に %select{true|false}0 と評価されるものと見なされる場合があります'
# 'reference cannot be bound to dereferenced null pointer in well-defined C++ code; pointer may be assumed to always convert to true'
H5320A7915E7F: '参照は null ポインタの解除参照に束縛できません; C++の明確なコードにおいて、ポインタは常に true に変換されるものと見なされる場合があります'
# 'reference cannot be initialized with multiple values'
HE7DB5FCEC436: '複数の値で参照を初期化することはできません'
# 'reference cannot bind to bit-field in converted constant expression'
HF5063530D4A6: '参照は変換された定数式内のビットフィールドに束縛できません'
# 'reference dynamic_cast failed: %select{static type %1 of operand is a non-public base class of dynamic type %2|dynamic type %2 of operand does not have a base class of type %3|%3 is an ambiguous base class of dynamic type %2 of operand|%3 is a non-public base class of dynamic type %2 of operand}0'
H4859449FAD67: 'dynamic_castの参照が失敗しました: %select{オペランドの静的型%1は動的型%2の非公開ベースクラスです|オペランドの動的型%2は型%3のベースクラスを持っていません|%3はオペランドの動的型%2のアンビグラスベースクラスです|%3はオペランドの動的型%2の非公開ベースクラスです}0'
# 'reference initialization of type %0 with initializer of type %1 is ambiguous'
HB988A3E86777: '型%0の参照初期化子に型%1の初期化子を使用すると曖昧です'
# 'reference initialized from initializer list is incompatible with C++98'
HCD4C182EF998: 'C++98では初期化子リストから参照を初期化できません'
# 'reference member of type %0 uninitialized'
HC2805DCE0AFC: 'アドレス空間の不一致により、型 %0 の参照は一時オブジェクトに束縛できません'
# 'reference of type %0 cannot bind to a temporary object because of address space mismatch'
HF0C3B633C49A: 'アドレス空間の不一致により一時オブジェクトに参照型%0を束縛できません'
# 'reference qualifiers on functions are a C++11 extension'
H41B9EC19F32B: '関数の参照修飾子はC++11拡張機能です'
# 'reference qualifiers on functions are incompatible with C++98'
HF044E58F9C25: '関数の参照修飾子はC++98と互換性ありません'
# 'reference to %0 is ambiguous'
H97A6825DEB56: '参照%0は曖昧です'
# 'reference to %select{__device__|__global__|__host__|__host__ __device__}0 %select{function|variable}1 %2 in %select{__device__|__global__|__host__|__host__ __device__}3 function'
H43094BC1789F: '%select{__device__|__global__|__host__|__host__ __device__}0 %select{関数|変数}1 %2 が %select{__device__|__global__|__host__|__host__ __device__}3 関数内で参照されました'
# 'reference to %select{__device__|__global__|__host__|__host__ __device__}0 function %1 in global initializer'
H76762B8F478F: '%select{__device__|__global__|__host__|__host__ __device__}0 関数 %1 がグローバル初期化子内で参照されました'
# 'reference to %select{destructor|pseudo-destructor}0 must be called%select{|; did you mean to call it with no arguments?}1'
H3484C551C20A: 'デストラクタ/疑似デストラクタ %select{デストラクタ|疑似デストラクタ}0 の参照は呼び出されなければなりません%select{|; 引数なしで呼び出すべきではありませんか?}1'
# 'reference to %select{overloaded|multiversioned}1 function could not be resolved; did you mean to call it%select{| with no arguments}0?'
HA7DE06C12730: '%select{オーバーロード|マルチバージョン}1 関数の参照が解決されませんでした; %select{| 引数なしで呼び出す}0 べきではありませんか？'
# "reference to a %select{bit-field|vector element|global register variable}0 in asm %select{input|output}1 with a memory constraint '%2'"
HCCFE4F550EEB: "アセンブリ %select{入力|出力}1 のメモリ制約 '%2' で %select{ビットフィールド|ベクタ要素|グローバルレジスタ変数}0 を参照しています"
# "reference to enumeration must use 'enum' not 'enum %select{struct|class}0'"
HDC33545DFD9E: "enum %select{struct|class}0 ではなく 'enum' を使用する必要があります"
# 'reference to local %select{variable|binding}1 %0 declared in enclosing %select{%3|block literal|lambda expression|context}2'
H9B72122A433C: '囲み %select{%3|ブロックリテラル|ラムダ式|コンテキスト}2 内で宣言されたローカル %select{変数|バインディング}1 %0 を参照しています'
# "reference to marker '%0' is ambiguous"
HD452BD6D3FB0: "マーク'%0'への参照は曖昧です"
# 'reference to non-static member function must be called%select{|; did you mean to call it with no arguments?}0'
H472EE5EB17CD: '非静的メンバ関数の参照は呼び出されなければなりません%select{|; 引数なしで呼び出すべきではありませんか?}0'
# 'reference to type %0 cannot bind to an initializer list'
H9194F3CD2BD5: '型%0の参照は初期化リストに束縛できません'
# 'reference to type %0 requires an initializer'
HD97076E9024C: '型%0の参照には初期化が必要です'
# 'reference to unresolved using declaration'
H4256A6DE4B09: '未解決の使用宣言への参照'
# 'referenced %0 is declared here'
HE1EBB7B8DBAD: '参照された %0 はここで宣言されています'
# 'referenced member %0 is declared here'
H8DB9210452D3: '参照されたメンバ %0 はここで宣言されています'
# "referring to 'main' within an expression is a Clang extension"
H5EC3F4017EE7: "式内で 'main' を参照することはClangの拡張機能です"
# "region cannot be%select{| closely}0 nested inside '%1' region%select{|; perhaps you forget to enclose 'omp %3' directive into a parallel region?|; perhaps you forget to enclose 'omp %3' directive into a for or a parallel for region with 'ordered' clause?|; perhaps you forget to enclose 'omp %3' directive into a target region?|; perhaps you forget to enclose 'omp %3' directive into a teams region?|; perhaps you forget to enclose 'omp %3' directive into a for, simd, for simd, parallel for, or parallel for simd region?}2"
H9F4A9870BA07: "領域'%1'内%select{| closely}0 にネストされています%select{|; 'omp %3' ディレクティブをパラレル領域内に含めるのを忘れていませんか？|; 'omp %3' ディレクティブをordered句を含むforまたはparallel for領域内に含めるのを忘れていませんか？|; 'omp %3' ディレクティブをtarget領域内に含めるのを忘れていませんか？|; 'omp %3' ディレクティブをteams領域内に含めるのを忘れていませんか？|; 'omp %3' ディレクティブをfor, simd, for simd, parallel for, または parallel for simd領域内に含めるのを忘れていませんか？}2"
# "register '%0' unsuitable for global register variables on this target"
HAC3AEFE8413B: "このターゲットではグローバルレジスタ変数用に適切なレジスタ '%0' です"
# 'register number should be an integer'
H932EE02D1B8E: 'レジスタ番号は整数でなければなりません'
# 'register pressure factor for the transformations.'
H44776CA40899: '変換のためのレジスタ圧力係数'
# 'register space cannot be specified on global constants'
H7D24E3150A81: 'グローバル定数ではレジスタ空間を指定できません'
# 'reimplementation of category %1 for class %0'
H30BD90819E63: 'クラス%0のカテゴリ%1の再実装'
# 'reimplementation of class %0'
HD4142B86FCD9: 'クラス %0 の再実装'
# 'reinterpret_cast cannot resolve overloaded function %0 to type %1'
H60D5F589023C: 'reinterpret_castはオーバーロード関数 %0 を型 %1 に解決できません'
# 'reinterpret_cast from %0 to %1 has undefined behavior'
H1A1328A6B1E4: '%0から%1へのreinterpret_castは未定義の動作を引き起こします'
# 'reinterpret_cast of a %0 to %1 needs its address, which is not allowed'
H8633F993884D: '%0への%1のreinterpret_castにはアドレスが必要ですが、これは許可されていません'
# "releasing %0 '%1' that was not held"
HD16686A7FEA7: "保持されていない%0 '%1'を解放しています"
# "releasing %0 '%1' using %select{shared|exclusive}2 access, expected %select{shared|exclusive}3 access"
H2106963D41B0: "%select{shared|exclusive}2 アクセスを使用して%0 '%1'を解放していますが、%select{shared|exclusive}3 アクセスが期待されます"
# 'remainder by zero in preprocessor expression'
HE098B5222CAD: 'プリプロセッサ式でのゼロによる剰余'
# 'remaining %0 candidate%s0 omitted; pass -fshow-overloads=all to show them'
HD0784BB8E50F: '残りの%0候補%s0は省略されています; -fshow-overloads=allを指定して表示します'
# 'remap file source paths <old> to <new> in coverage mapping. If there are multiple options, prefix replacement is applied in reverse order starting from the last one'
HD493DCAA04BC: 'カバレッジ マッピングでのファイル ソース パスの<old>から<new>へのリマップ。複数のオプションがある場合、末尾から逆順にプレフィックス置換が適用されます'
# 'remap file source paths in debug info, coverage mapping, predefined preprocessor macros and __builtin_FILE(). Implies -ffile-reproducible.'
HD15C7DEA6A6F: 'デバッグ情報、カバレッジ マッピング、事前に定義されたプリプロセッサ マクロ、および__builtin_FILE()でのファイル ソース パスのリマップ。-ffile-reproducibleを含みます'
# 'remap file source paths in predefined preprocessor macros and __builtin_FILE(). Implies -ffile-reproducible.'
H6FA3D7D85AF9: '事前に定義されたプリプロセッサ マクロと__builtin_FILE()でのファイル ソース パスのリマップ。-ffile-reproducibleを含みます'
# 'remarks_a'
H1F5563CE509E: 'remarks_a'
# 'remarks_b'
H40EB09D856D2: 'remarks_b'
# "remove '_Noreturn'"
H4CD6C2426BE8: "'_Noreturn'を削除"
# "remove 'enum%select{| struct| class}0' to befriend an enum"
H9CF5F9198489: 'enum%select{| struct| class}0を削除してenumと友好的になる'
# "remove 'u8' prefix to avoid a change of behavior; Clang encodes unprefixed narrow string literals as UTF-8"
H40BFCE51D12C: 'u8プレフィックスを削除して動作の変更を避ける; Clangはプレフィックスのない狭い文字列リテラルをUTF-8としてエンコードします'
# 'remove call to max function and unsigned zero argument'
H746EE2CAAC37: 'max関数と符号なしゼロ引数の呼び出しを削除'
# 'remove constant to silence this warning'
H8233E14B9765: 'この警告を黙らせるために定数を削除'
# 'remove double jumps when able'
H144AFE550114: '可能な場合、ダブルジャンプを削除'
# 'remove extraneous parentheses around the comparison to silence this warning'
H7C576B6A85C7: 'この警告を黙らせるために比較周りの余分な括弧を削除'
# 'remove parentheses to declare a variable'
H29AB7F8F0D04: '変数を宣言するために括弧を削除'
# 'remove parentheses to silence this warning'
HBB1C1AF59745: 'この警告を無効にするには括弧を削除してください'
# 'remove std::move call here'
H87B3A4171A2A: 'ここでのstd::move呼び出しを削除してください'
# "remove the %select{'%1' if its condition|condition if it}0 is always %select{false|true}2"
HE5C66C3841AD: "条件が常に%select{false|true}2である場合、%select{'%1'の条件部分|条件}0を削除してください"
# "remove the call to '%0' since unsigned values cannot be negative"
H3BE7257796E7: 'unsigned値は負にはならないため、%0への呼び出しを削除してください'
# 'remove the kernel-info pass at the end of the full LTO pipeline'
HE9CC6C17C11E: 'フルLTOパイプラインの最後のkernel-infoパスを削除してください'
# 'remove useless conditional branches'
H7F773F483924: '不要な条件分岐を削除してください'
# "rename '%0' to ensure it can be found by name"
H730151DC5720: '名前で検出できるように%0を名前を変更してください'
# 'reorder and cluster functions (works only with relocations)'
HB96EDA278BFF: '関数を再配置しクラスタリングする（再配置時にのみ有効）'
# 'reorder data sections in place'
HCACEBAE7CFC3: 'データセクションをその場で再配置する'
# 'reorder functions randomly'
HA61C4AF88653: '関数をランダムに再配置する'
# 'reorder three way branches'
HF6331B33926D: '3分岐を再配置する'
# 'reorder unconditional jump instructions in loops optimization'
H61D641F1F0CA: 'ループ最適化における無条件ジャンプ命令を再配置する'
# "repeated RISC-V 'interrupt' attribute"
HE9564BE7AF0F: 'RISC-Vのinterrupt属性が重複しています'
# "repeated RISC-V 'interrupt' attribute is here"
H2C65B1A1835B: 'RISC-Vのinterrupt属性の重複はここにあります'
# 'repeated evaluation of the same literal expression can produce different objects'
H816EF14DCA64: '同じリテラル式の再評価で異なるオブジェクトが生成される可能性があります'
# "replace 'default' with 'delete'"
H6143A5F8A323: 'defaultをdeleteに置き換えます'
# "replace expression with '%0' %select{|or use 'xor' instead of '^' }1to silence this warning"
H8BD6D24EAB4A: '式を"%0"に置き換え、%select{|または"^"の代わりに"xor"を使用して }1この警告を無効にします'
# 'replace parentheses with an initializer to declare a variable'
H1CB1AEAC6164: '変数宣言のために括弧を初期化子に置き換えます'
# "replacement function %0 cannot be declared 'inline'"
H8E774898376D: '%0という置換関数は"inline"として宣言できません'
# 'report accesses through a pointer which has poisoned shadow'
HDB29EEB5BF15: 'poisoned shadowを持つポインタを介したアクセスを報告します'
# 'report stats in csv'
H4FBFD3CEA227: 'CSV 形式で統計情報を出力'
# 'report stats in text'
HDFF33DBA8938: 'テキスト形式で統計情報を出力'
# "requested 'init_priority' %0 is reserved for internal use"
H2E025E570ED5: "要求された 'init_priority' %0 は内部使用専用です"
# 'requested alignment %0 is not a positive power of two'
H9C01C430B004: '要求されたアライメント %0 は正の 2 の累乗ではありません'
# 'requested alignment is dependent but declaration is not dependent'
H9D546DA38E42: '要求されたアライメントは依存型ですが、宣言は依存型ではありません'
# 'requested alignment is less than minimum alignment of %1 for type %0'
H9E0857E89F1F: '要求されたアライメントは、型 %0 の最小アライメント %1 よりも小さいです'
# 'requested alignment is not a power of 2'
HC6B6240D895B: '要求されたアライメントは 2 の累乗ではありません'
# 'requested alignment must be %0 bytes or smaller'
H7B9D334BA24B: '要求されたアライメントは %0 バイト以下でなければなりません'
# 'requested alignment must be %0 bytes or smaller; maximum alignment assumed'
HCDB68D900AC4: '要求されたアライメントは %0 バイト以下でなければなりません; 最大アライメントを使用します'
# 'requested alignment must be %0 or greater'
H097A66E5C9B7: '要求されたアライメントは %0 以上でなければなりません'
# 'requested alignment must be %0 or less for type %1; %2 is invalid'
H6B97FB634040: '型 %1 のアライメントは %0 以下でなければなりません; %2 は無効です'
# 'requested alignment must be %0 or smaller'
HEC3786C66ADB: '要求されたアライメントは %0 以下でなければなりません'
# 'requested shift is a vector of type %0 but the first operand is not a vector (%1)'
H149741EFCCA5: '要求されたシフトは型 %0 のベクターですが、最初のオペランドはベクターではありません (%1)'
# 'required alignment of type %0 (%1 bytes) is larger than the supported alignment of C++ exception objects on this target (%2 bytes)'
HFFCA5AAB79EE: '型 %0 の必要アライメント (%1 バイト) は、このターゲットで C++ 例外オブジェクトがサポートするアライメント (%2 バイト) よりも大きいです'
# "required by %select{'require_constant_initialization' attribute|'constinit' specifier}0 here"
H669C2D015B6E: 'ここでは %select{require_constant_initialization 属性|constinit 指定子}0 によって要求されています'
# 'requires clause differs in template redeclaration'
H3C91EEDA34FA: 'テンプレートの再宣言で requires 句が異なっています'
# "requires expression in requirement body; did you intend to place it in a nested requirement? (add another 'requires' before the expression)"
H818E1323CB5B: "要件本文での requires 式; ネストされた要件に配置する意図でしたか? (式の前に別の 'requires' を追加してください)"
# "reserved locator 'omp_all_memory' cannot be specified more than once"
HBB5542941955: "'omp_all_memory' 予約ロケーターは複数回指定できません"
# "reserved locator 'omp_all_memory' requires 'out' or 'inout' dependency types"
H98614BF4F5B5: "'omp_all_memory' 予約ロケーターには 'out' または 'inout' 依存種類が必要です"
# 'resolve all otherwise unresolved externals to null'
H0D8FB57C5D95: 'その他の未解決の外部参照をすべてヌルに解決します'
# 'respect alignment requirements provided by input IR'
H3C9B5ECCDE76: '入力IRが指定するアライメント要件を尊重します'
# 'restrict requires a pointer or reference'
H044B0871CB3F: 'restrictはポインタまたはリファレンスが必要です'
# 'restrict requires a pointer or reference (%0 is invalid)'
HB4AA3977DC42: 'restrictはポインタまたはリファレンスが必要です (%0は無効)'
# "result argument to %select{overflow builtin|checked integer operation}0 must be a pointer to a non-const integer type %select{|other than plain 'char', 'bool', bit-precise, or an enumeration }0(%1 invalid)"
HD81ECBB4661A: "%select{オーバーフロー組み込み関数|チェック付き整数演算}0の結果引数は、%select{plain 'char'/'bool'/ビット精度/列挙型以外の|}0constでない整数型へのポインタでなければなりません (%1無効)"
# "result of '%0' is %1; did you mean '%2' (%3)?"
H369683737B3D: "'%0'の結果は%1です。'%2' (%3)を意図したのでしょうか？"
# "result of '%0' is %1; did you mean '%2'?"
H1B6516041439: "'%0'の結果は%1です。'%2'を意図したのでしょうか？"
# "result of '%0' is %1; did you mean exponentiation?"
H6BDF285BA0FF: "'%0'の結果は%1です。累乗を意図したのでしょうか？"
# 'result of comparison %select{%3|%1}0 %2 %select{%1|%3}0 is always %4'
H3D76D2CD2831: '%select{%3|%1}0 %2 %select{%1|%3}0 の比較結果は常に%4です'
# 'result of comparison against %select{a string literal|@encode}0 is unspecified (use an explicit string comparison function instead)'
H42F5B6822163: '%select{文字列リテラル|@encode}0 との比較結果は未規定です（明示的な文字列比較関数を使用してください）'
# 'result of comparison of %select{%3|char expression}0 %2 %select{char expression|%3}0 is always %4, since char is interpreted as unsigned'
H2652DE195D69: 'char式 %2 %select{char式|%3}0 との%select{%3|char式}0 の比較結果は常に%4です（charは符号なしとして解釈されるため）'
# 'result of comparison of %select{%3|unsigned enum expression}0 %2 %select{unsigned enum expression|%3}0 is always %4'
H86DA5A0E3154: 'unsigned enum式 %2 %select{unsigned enum式|%3}0 との%select{%3|unsigned enum式}0 の比較結果は常に%4です'
# 'result of comparison of %select{%3|unsigned expression}0 %2 %select{unsigned expression|%3}0 is always %4'
HABA37A2C23DF: 'unsigned式 %2 %select{unsigned式|%3}0 との%select{%3|unsigned式}0 の比較結果は常に%4です'
# 'result of comparison of %select{%4|%1-bit %select{signed|unsigned}2 value}0 %3 %select{%1-bit %select{signed|unsigned}2 value|%4}0 is always %5'
H3E54DBA92461: '比較の結果 %select{%4|%1ビット %select{符号付き|符号なし}2 値}0 %3 %select{%1ビット %select{符号付き|符号なし}2 値|%4}0 は常に %5 です'
# 'result of comparison of %select{constant %0|true|false}1 with %select{expression of type %2|boolean expression}3 is always %4'
H0604EEA5685E: '%select{定数 %0|true|false}1 と %select{型 %2 の式|真偽式}3 の比較結果は常に %4 です'
# "result of comparison of constant %0 with expression of type 'BOOL' is always %1, as the only well defined values for 'BOOL' are YES and NO"
H641A75823917: "'BOOL'型式の式との定数%0の比較結果は常に%1です（'BOOL'の定義済み値はYES/NOのみ）"
# "retain'ed block property does not copy the block - use copy attribute instead"
HD7F1D5C5B0F0: "'retain'属性のブロックプロパティはブロックをコピーしません（copy属性を使用してください）"
# 'return in the catch of a function try block of a constructor is illegal'
HBC7FDA21A80E: 'コンストラクタの関数トライブロックのcatchでreturn文を使用することは違法です'
# "return state set for an unconsumable type '%0'"
H2753EF9C9B3B: "消費不可能な型'%0'に対して戻り値状態が設定されました"
# "return statement not allowed in coroutine; did you mean 'co_return'?"
HD15AAC2A320B: 'コルーチン内で return 文は許可されていません；「co_return」を指定したつもりでは？'
# "return type %0 of selected 'operator==' function for rewritten '%1' comparison is not 'bool'"
HC9853B2276CB: 'リライトされた「%1」比較の選択された「operator==」関数の戻り値型 %0 は「bool」ではありません'
# 'return type cannot be qualified with address space'
H90249355EB7F: '戻り値型にアドレス空間修飾子を付けることはできません'
# 'return type deduction is incompatible with C++ standards before C++14'
HB4A5F5EFADA6: '戻り値型推論は C++14 以前の標準と互換性がありません'
# "return type for defaulted %select{<ERROR>|equality|three-way|equality|relational}0 comparison operator must be 'bool', not %1"
H2EF639AB940D: 'デフォルト化された %select{<ERROR>|等価|三項|等価|順序}0 比較演算子の戻り値型は「bool」でなければなりません（%1 ではありません）'
# "return type of 'await_ready' is required to be contextually convertible to 'bool'"
H043CECD8EB91: '「await_ready」の戻り値型は文脈的に「bool」に変換可能でなければなりません'
# "return type of 'await_suspend' is required to be 'void' or 'bool' (have %0)"
H64AB2C323A61: '「await_suspend」の戻り値型は「void」または「bool」でなければなりません（現在 %0）'
# "return type of 'coroutine_handle<>::address should be 'void*' (have %0) in order to get capability with existing async C API"
HA713CB41D910: '「coroutine_handle<>::address」の戻り値型は「void*」でなければならないため（現在 %0）、既存の非同期 C API との互換性を確保できません'
# "return type of 'main' is not 'int'"
HFBAC240E8034: '「main」の戻り値型は「int」でありません'
# "return type of defaulted 'operator<=>' cannot be deduced because return type %2 of three-way comparison for %select{|member|base class}0 %1 is not a standard comparison category type"
H424FC8A53CC9: 'デフォルト化された「operator<=>」の戻り値型は推論できません；%select{|メンバー|基底クラス}0 %1 の三項比較の戻り値型 %2 は標準比較カテゴリ型ではありません'
# "return type of defaulted 'operator<=>' cannot be deduced because three-way comparison for %select{|member|base class}0 %1 has a deduced return type and is not yet defined"
H0105A22E2A8D: 'デフォルト化された「operator<=>」の戻り値型は推論できません；%select{|メンバー|基底クラス}0 %1 の三項比較は戻り値型を推論しており未定義です'
# 'return type of out-of-line definition of %q0 differs from that in the declaration'
H469315680A98: '宣言と定義の戻り値型が %q0 で一致しません'
# 'return type of virtual function %0 is not covariant with the return type of the function it overrides (%1 has different qualifiers than %2)'
H00BA4129869D: 'オーバーライドする関数 %0 の戻り値型との共変性がありません（%1 と %2 の修飾子が異なります）'
# 'return type of virtual function %0 is not covariant with the return type of the function it overrides (%1 is incomplete)'
HE8582E3BF357: 'オーバーライドする関数 %0 の戻り値型との共変性がありません（%1 は未完全型です）'
# 'return type of virtual function %0 is not covariant with the return type of the function it overrides (%1 is not derived from %2)'
H5A21B37900C4: 'オーバーライドする関数 %0 の戻り値型との共変性がありません（%1 は %2 から派生していません）'
# 'return type of virtual function %0 is not covariant with the return type of the function it overrides (class type %1 does not have the same cv-qualification as or less cv-qualification than class type %2)'
H2AB9EE663373: 'オーバーライドする関数 %0 の戻り値型との共変性がありません（クラス型 %1 はクラス型 %2 に比べて同じもしくはより少ない修飾子を持ちません）'
# 'return type of virtual function %3 is not covariant with the return type of the function it overrides (ambiguous conversion from derived class %0 to base class %1:%2)'
H94F1AF985110: 'オーバーライドする関数 %3 の戻り値型との共変性がありません（基底クラス %1 への派生クラス %0 の変換が曖昧です：%2）'
# "return value not in expected state; expected '%0', observed '%1'"
H8EF54209E2EA: '期待される値の状態「%0」と観測値「%1」が一致しません'
# 'return value of %0 is a large (%1 bytes) pass-by-value object; pass it by reference instead ?'
HA1B074D05D38: '%0 の戻り値は大規模な (%1 バイト) 値渡しオブジェクトです；参照渡しに変更すべきです ?'
# 'returning %select{address of|reference to}0 local temporary object'
H0D9CD7C30605: 'ローカルの一時オブジェクトの%select{アドレス|参照}0を返却しています'
# 'returning address of label, which is local'
H7C6FDC7A79CE: 'ローカルのラベルのアドレスを返却しています'
# 'returning block that lives on the local stack'
HFB5C6DCAD180: 'ローカルスタック上にあるブロックを返却しています'
# "returning pointer %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
H524B3D4E5221: "ポインタ %1 を返却するには %0 を %select{'%2'|'%2'排他に}3 保持する必要があります"
# "returning pointer to variable %1 requires holding %0 %select{'%2'|'%2' exclusively}3"
HC47B423E80E3: "変数 %1 のポインタを返却するには %0 を %select{'%2'|'%2'排他に}3 保持する必要があります"
# 'returning reference to local temporary object'
H3C7B38DADD40: 'ローカルの一時オブジェクトへの参照を返却しています'
# "returning the value that %1 points to by reference requires holding %0 %select{'%2'|'%2' exclusively}3"
HDFB7294684C5: "%1 が指す値を参照で返却するには %0 を %select{'%2'|'%2'排他に}3 保持する必要があります"
# "returning variable %1 by reference requires holding %0 %select{'%2'|'%2' exclusively}3"
H5E5D0E85F387: "変数 %1 を参照で返却するには %0 を %select{'%2'|'%2'排他に}3 保持する必要があります"
# "rewriter doesn't support user-specified control flow semantics for @try/@finally (code may not execute properly)"
H9C522D3EEF6D: '@try/@finally のユーザー指定制御フロー意味論はリライターがサポートしていません（コードが正しく動作しない可能性があります）'
# 'rewriting block literal declared in global scope is not implemented'
HC8DC37202696: 'グローバルスコープで宣言されたブロックリテラルの再書き換えは未実装です'
# 'rewriting sub-expression within a macro (may not be correct)'
H72B7281F7712: 'マクロ内のサブ式の再書き換え（正しくない可能性があります）'
# 'right hand operand to %0 has non-pointer-to-member type %1'
H53A963FA3084: '%0 の右辺オペランドは非メンバポインタ型 %1 です'
# "right shifting a 'bool' implicitly converts it to 'int'"
HEDBEE20D2831: "'bool' の右シフトは暗黙的に'int'に変換されます"
# 'rocPrim path, required by the HIP Standard Parallel Algorithm Acceleration library, used to implicitly include the rocPrim library'
HD40BA7FFEFEE: 'HIP並列アルゴリズム加速ライブラリで要求されるrocPrimパスは、このライブラリを暗黙的に含むものとして使用されます'
# 'rocThrust path, required by the HIP Standard Parallel Algorithm Acceleration library, used to implicitly include the rocThrust library'
H2F4B1626A7F1: 'HIP並列アルゴリズム加速ライブラリで要求されるrocThrustパスは、このライブラリを暗黙的に含むものとして使用されます'
# 'run retpoline insertion pass'
H57D5B6539CD2: 'リタポリン挿入パスを実行'
# 'run veneer elimination pass'
HC2BE3F62417A: 'ベナー除去パスを実行'
# "runpath search paths do not match: '%0' (provided) vs '%1' (found)"
H2CB428691FF3: "ランパス検索パスが一致しません: '%0' (指定) 対 '%1' (検出)"
# "runpath search paths missing from %0: '%1'"
H427437B03484: "runpath検索パスが%0から見つかりません: '%1'"
# 'rvalue reference %diff{to type $ cannot bind to lvalue of type $|cannot bind to incompatible lvalue}0,1'
H5D62614FC181: 'rvalue参照%diff{タイプ$へのものはlvalueタイプ$にバインドできません|互換性のないlvalueにバインドできません}0,1'
# 'rvalue reference type %0 is not allowed in exception specification'
H63B188C37A7C: '例外指定ではrvalue参照タイプ%0を使用できません'
# 'rvalue references are a C++11 extension'
HE6F99D294F8D: 'rvalue参照はC++11の拡張機能です'
# 'rvalue references are incompatible with C++98'
HBB045EE53C13: 'rvalue参照はC++98と互換性ありません'
# 'safe buffers debug: %0'
H6B8774B1FDA7: 'セーフバッファーデバッグ: %0'
# 'safety buffer size'
H48F48464759C: '安全バッファーサイズ'
# 'same map type modifier has been specified more than once'
HE40C50BE338F: '同じマップタイプ修飾子が複数回指定されました'
# 'same motion modifier has been specified more than once'
H855EE2722E18: '同じモーション修飾子が複数回指定されました'
# 'same pointer dereferenced in multiple different ways in map clause expressions'
H176F03468FDB: 'マップ句式の式で同じポインタが異なる方法で複数回参照されています'
# 'sampler initializer has invalid %0 bits'
H18D45D49E7B9: 'サンプラー初期化子は無効な%0ビットを持っています'
# 'sampler type cannot be used with the __local and __global address space qualifiers'
H2695DF30EE8D: '__localおよび__globalアドレス空間修飾子と組み合わせてサンプラータイプは使用できません'
# 'sampler_t initialization requires 32-bit integer, not %0'
HB7C873D08ECC: 'サンプラー_t初期化は32ビット整数を必要とします(%0は不正)'
# 'sampler_t variable required - got %0'
H54F7785F9F3D: 'サンプラー_t変数が必要です - %0が指定されました'
# 'sanstats Options'
H8526EFD0A943: 'sanstatsオプション'
# "satisfaction of constraint '%0' depends on itself"
H3716B39C40C1: "制約'%0'の充足は自分自身に依存しています"
# 'save recorded profile to a file'
H0DD7B7A894BB: '記録済みプロファイルをファイルに保存'
# 'scalar initialized from empty initializer list is incompatible with C++98'
H4040E7512491: '初期化子リストが空のスカラ初期化はC++98と互換性ありません'
# 'scalar initializer cannot be empty'
HD3067EEE76AC: 'スカラ初期化子は空にできません'
# 'scalar operand type has greater rank than the type of the vector element. (%0 and %1)'
H2C50DCFF8689: 'スカラオペランドタイプのランクはベクタ要素タイプのランクより大きい (%0と%1)'
# 'scale argument must be 1, 2, 4, or 8'
H325DB8FF3A78: 'scale引数は1、2、4、または8でなければなりません'
# 'scale factor for the latch probability. Value should be greater than 1. Lower values are ignored'
HAACE1BBE5003: 'latch確率のスケール係数。値は1より大きくなければなりません。より小さい値は無視されます'
# 'scale of asan shadow mapping'
H538257B2498C: 'ASanシャドウマッピングのスケール'
# 'scale of memprof shadow mapping'
H256DA014D3E2: 'memprofシャドウマッピングのスケール'
# 'scale to be applied while reporting dyno stats'
H9327CA23C998: 'dyno統計を報告する際に適用されるスケール'
# 'scoped enumeration requires a name'
H38F857947248: 'スコープ付き列挙型には名前が必要です'
# 'scoped enumerations are a C++11 extension'
H880FA70730D4: 'スコープ付き列挙型はC++11の拡張機能です'
# 'scoped enumerations are incompatible with C++98'
H8FFFE671E01D: 'スコープ付き列挙型はC++98と互換性がありません'
# 'score expressions in the OpenMP context selector need to be constant; %0 is not and will be ignored'
HBAE673BA4B11: 'OpenMPコンテキストセレクタのscore式は定数でなければなりません; %0はそうでないため無視されます'
# "search path used: '%0'"
H5005F53FE066: "使用された検索パス: '%0'"
# "second argument to 'va_arg' is of ARC ownership-qualified type %0"
H5B02CB112F2F: "'va_arg'の2番目の引数はARCの所有権修飾型%0です"
# "second argument to 'va_arg' is of abstract type %0"
HB0CBA3C6712C: "'va_arg'の2番目の引数は抽象型%0です"
# "second argument to 'va_arg' is of array type %0; this va_arg has undefined behavior because arguments will never be compatible with array type"
H0271D72D02D0: "'va_arg'の2番目の引数は配列型%0です。このva_argは、引数が配列型と互換性がないため未定義動作になります"
# "second argument to 'va_arg' is of incomplete type %0"
HBAB6DD203AC7: "'va_arg'の2番目の引数は未完全型%0です"
# "second argument to 'va_arg' is of non-POD type %0"
H6E23523199DB: "'va_arg'の2番目の引数は非POD型%0です"
# "second argument to 'va_arg' is of promotable type %0; this va_arg has undefined behavior because arguments will be promoted to %1"
HD77AAC429CAF: "'va_arg'の2番目の引数はプロモーション可能な型%0です。このva_argは、引数が%1にプロモーションされるため未定義動作になります"
# "second argument to 'va_start' is not the last non-variadic parameter"
H37CA82AB0144: "'va_start'の2番目の引数は最後の非可変引数パラメータではありません"
# 'second argument to __builtin_alloca_with_align is supposed to be in bits'
HF3ADBC91450B: '__builtin_alloca_with_alignの2番目の引数はビット単位で指定される必要があります'
# 'second argument to __builtin_annotation must be a non-wide string constant'
HB28F8D41E677: '__builtin_annotationの2番目の引数は幅なし文字列定数でなければなりません'
# 'second argument to __builtin_call_with_static_chain must be of pointer type'
H9D3B291ADD1F: '__builtin_call_with_static_chainの2番目の引数はポインタ型でなければなりません'
# 'section attribute is specified on redeclared variable'
H4BE9B9505588: 'セクション属性が再宣言された変数に指定されています'
# 'section length is evaluated to a negative value %0'
HDAA24A68E89D: 'セクション長が負の値%0に評価されました'
# 'section length is unspecified and cannot be inferred because subscripted value is %select{not an array|an array of unknown bound}0'
HD324F8149A40: 'サブスクリプト値が%select{配列ではありません|要素数が不明な配列}0であるため、セクション長が未指定で推論できません'
# 'section of pointer to function type %0'
HDFC73840E7DC: '関数型%0へのポインタのセクション'
# 'section of pointer to incomplete type %0'
HFA4996C0EBB1: '未完成型 %0 のポインタのセクション'
# 'section stride is evaluated to a non-positive value %0'
H2C7B2A05B911: 'セクションの歩幅が非正の値%0に評価されました'
# 'see attribute on parameter here'
HDD0675B1BF06: 'パラメータの属性を参照してください'
# 'seed for randomization'
HD63DCBC599F4: '乱数のシード'
# "selected '%select{begin|end}0' %select{function|template }1%2 with iterator type %3"
H752B6650220E: 'イテレータ型%3を持つ%select{begin|end}0%select{関数|テンプレート}1%2が選択されました'
# "selected 'operator<=>' for %select{|member|base class}0 %1 declared here"
H810A0D73AD55: "'operator<=>'が%select{|メンバー|基底クラス}0 %1がここで宣言されたため選択されました"
# 'selector element is not a valid lvalue'
H0BFE26B0616A: '選択子要素が有効な左辺値ではありません'
# 'selector element of type %0 cannot be a constant lvalue expression'
H9F3EFE55FA69: '型%0の選択子要素は定数左辺値式にはできません'
# 'selector element type %0 is not a valid object'
HED5168FB3348: '選択子要素の型%0は有効なオブジェクトではありません'
# 'semantic annotations must be present for all parameters of an entry function or patch constant function'
H8F1EA44B7AC0: 'エントリ関数またはパッチ定数関数のすべてのパラメータに対して、セマンティックアノテーションが存在する必要があります'
# 'semicolon before method body is ignored'
H600E31190711: 'メソッド本体前のセミコロンは無視されます'
# 'semicolon terminating header import declaration cannot be produced by a macro'
HD5CFDD7201E4: 'ヘッダインポート宣言を終了するセミコロンはマクロによって生成できません'
# 'set format in which header info is emitted'
H2BE1FC27A3B2: 'ヘッダ情報の出力形式を設定'
# 'set the flag that enables filtering header information'
H433BB7B2C953: 'ヘッダ情報をフィルタリングするためのフラグを設定'
# 'set the incremental array construction buffer size (default=32)'
H062EDCFEADF9: 'インクリメンタル配列構築バッファサイズを設定（デフォルト=32）'
# 'set verbosity level for diagnostic output'
HA7F31A34A582: '診断出力の詳細レベルを設定'
# 'sets a boolean flag for every edge'
H5B3492ACEF7D: '各エッジに対してブール値のフラグを設定します'
# 'setter and getter must both be synthesized, or both be user defined, or the property must be nonatomic'
H13B288111B84: 'setter と getter はどちらも合成されるか、どちらもユーザー定義されるか、またはプロパティは nonatomic でなければなりません'
# 'setter cannot be specified for a readonly property'
H0B75386E5DBF: 'readonly プロパティには setter を指定できません'
# 'setting the floating point evaluation method to `source` on a target without SSE is not supported'
H3CBE26190DE7: 'SSE を持たないターゲットで浮動小数点評価メソッドを `source` に設定することはサポートされていません'
# 'several methods with selector %0 of mismatched types are found for the @selector expression'
H992F0A773FBB: '@selector 式に対して、選択子 %0 を持つ非互換の型のメソッドが複数見つかりました'
# 'share stubs across functions'
H4D76BB47577B: '関数間でスタブを共有する'
# 'shift count %0 >= width of type %1 (%2 bit%s2)'
HF6F9C4B1183E: 'シフトカウント %0 >= 型 %1 の幅 (%2 ビット%s2)'
# 'shift count >= width of type'
H64BC6739BC0B: 'シフトカウントが型の幅を超えています'
# 'shift count is negative'
H49401E14D24E: 'シフトカウントが負の値です'
# 'shifting a negative signed value is undefined'
H08F0D0D67884: '負の符号付き値をシフトすることは未定義です'
# 'shorten instructions'
H31FAC4015C01: '命令を短縮する'
# 'show a graph.'
HDBFEE5F65752: 'グラフを表示します'
# 'show execution count of functions in binary 2 as a ratio of the total samples in binary 1 - make sure both profiles have equal collection time and sampling rate for this to make sense'
H7302A3496B1D: 'バイナリ2の関数の実行回数を、バイナリ1の総サンプル数に対する比率で表示します - この表示が意味をなすためには、両方のプロファイルが等しい収集時間とサンプリングレートを持っている必要があります'
# 'show in text.'
H8201270E0209: 'テキスト形式で表示'
# 'show profile density details'
HA588BE6E194B: 'プロファイルの密度詳細を表示'
# 'show section contents after fixups have been applied'
HF6C65D702470: '修正が適用された後のセクションの内容を表示'
# 'signed bit-field %0 needs an extra bit to represent the largest positive enumerators of %1'
HE118008121A9: '符号付きビットフィールド %0 は、%1 の最大の正の列挙子を表現するために、追加のビットが必要です'
# 'signed left shift discards bits'
HD469BF80AF3C: '符号付き左シフトはビットを破棄します'
# 'signed shift result (%0) requires %1 bits to represent, but %2 only has %3 bits'
HC5B9F5083ED5: '符号付きシフト結果 (%0) を表現するには %1 ビットが必要ですが、%2 には %3 ビットしかありません'
# "signed shift result (%0) sets the sign bit of the shift expression's type (%1) and becomes negative"
H95CD10E060D8: '符号付きシフト結果 (%0) がシフト式の型 (%1) の符号ビットを設定し、負の値になります'
# "signedness of format specifier '%0' is incompatible with '%1'"
H0E3D0B14B46F: "フォーマット指定子 '%0' の符号属性は '%1' と互換性ありません"
# 'signing a null pointer will yield a non-null pointer'
H25C3D501EB46: 'null ポインタを符号付けすると非 null ポインタになります'
# 'silence by adding parentheses to mark code as explicitly dead'
H99754744B060: '警告を抑制するには括弧を追加し、明示的に死コードとしてマークしてください'
# 'similar constraint expression here'
HC25A9009F181: '同様の制約式がここに存在します'
# 'similar constraint expressions not considered equivalent; constraint expressions cannot be considered equivalent unless they originate from the same concept'
H671259A4BAC3: '同様の制約式は同一視されません。制約式は同じ概念から派生しない限り、同一視されません'
# "similar to '-lite-threshold-pct' but specify threshold using absolute function call count. I.e. limit processing to functions executed at least the specified number of times."
HAE7D7FD96C23: "'-lite-threshold-pct' に似ていますが、閾値を絶対関数呼び出し回数で指定します。つまり、指定された回数以上実行された関数のみを処理対象にします"
# 'simple ddg dot graph'
H18F32B7E23D9: 'シンプルな DDG ドットグラフ'
# 'simple-rename options'
H99366DD6F3BD: 'simple-rename オプション'
# 'simplify conditional tail calls by removing unnecessary jumps'
H041707E8A1C3: '不要なジャンプを削除して条件付きテールコールを単純化します'
# 'simplify loads from read-only sections by replacing the memory operand with the constant found in the corresponding section'
H05E90663FB35: '読み取り専用セクションからのロードを単純化し、対応するセクションの定数でメモリオペランドを置き換えます'
# "single declaration is expected after 'declare %select{simd|variant}0' directive"
H178440D95E1D: "'declare %select{simd|variant}0' ディレクティブ後に単一の宣言が期待されます"
# 'single subscript expressions are not allowed for matrix values'
H6751A19F6DB9: '行列値に対して単一の添字式は許可されていません'
# 'size argument in %0 call appears to be size of the source; expected the size of the destination'
HA69933A2CC96: '%0 の呼び出しにおけるサイズ引数はソースのサイズに見えますが、目的のサイズが期待されます'
# 'size argument in %0 call is a comparison'
HAC4E42C8E89B: '%0 の呼び出しにおけるサイズ引数は比較式になっています'
# "size argument in 'strncat' call appears to be size of the source"
HBE6DF8480F3A: 'strncat の呼び出しにおけるサイズ引数はソースのサイズに見えます'
# 'size must be %select{1, 2, or 4|1, 2, 4, 12 or 16}0'
H5666676F632D: 'サイズは %select{1、2、または4|1、2、4、12、または16}0 でなければなりません'
# "size of '__builtin_bit_cast' source type %0 does not match destination type %1 (%2 vs %3 bytes)"
HE2800B62712B: '__builtin_bit_cast のソース型 %0 のサイズは、目的型 %1 と一致しません (%2 バイト vs %3 バイト)'
# 'size of a heat map block in bytes (default 64)'
HF50CC8CAD0AC: 'ヒートマップ ブロックのサイズ（バイト単位、デフォルト64）'
# "size of array element of type %0 (%1 bytes) isn't a multiple of its alignment (%2 bytes)"
H64B3D7C6AA54: '型 %0 の配列要素のサイズ（%1 バイト）は、配置境界 %2 バイトの倍数ではありません'
# 'size of array has non-integer type %0'
HE09F852059B1: "配列のサイズが整数型以外の型'%0'です"
# 'size of feature field in .altinstructions'
H2B6C1D1A943E: '.altinstructionsファイル内の機能フィールドのサイズ'
# "size of register '%0' does not match variable size"
HECA9BDA68860: "レジスタ'%0'のサイズが変数のサイズと一致しません"
# 'sizeof on array function parameter will return size of %0 instead of %1'
HFA0A8C5A6400: '配列関数パラメータでのsizeofは、%1の代わりに%0のサイズを返します'
# 'sizeof on pointer operation will return size of %0 instead of %1'
H23C83EADD90C: 'ポインタ操作でのsizeofは、%1の代わりに%0のサイズを返します'
# 'skip access specifiers'
HB22E60CB51DB: 'アクセス修飾子のスキップ'
# 'skip calling convention'
HA89A2E2093C7: 'コールコンベンションのスキップ'
# 'skip member types'
HE3F86CF4D54B: 'メンバー型のスキップ'
# 'skip non-simple functions in reporting'
H7F9F6F20766F: 'レポートでの非単純関数のスキップ'
# 'skip perf and read data from a pre-aggregated file format'
H38F758DFB377: '事前集計済みファイル形式からパフォーマンスと読み取りデータを取得'
# 'skip perf event collection by supplying a perf-script output in a textual format'
HD6505A3AF86B: 'テキスト形式のperf-script出力を使用してパフォーマンスイベント収集をスキップ'
# 'skip processing of cold functions'
H2FAB1AD4A339: 'コールド関数の処理のスキップ'
# 'skip return types'
H3988159D97D2: '戻り値型のスキップ'
# 'skip variable types'
H1C4CB11B7B2B: '変数型のスキップ'
# "skipping '%0' because module declaration of '%1' lacks the 'framework' qualifier"
H07A078D1E04E: "モジュール宣言'%1'に'framework'修飾子が存在しないため、'%0'をスキップします"
# 'skipping stray token'
HF5D19BFCA4A8: '余分なトークンのスキップ'
# 'sort hot data by hot function usage and count'
H35D38C633287: 'ホット関数の使用状況とカウントでホットデータを並べ替え'
# 'sort hot data by read counts'
HC3E7276E6170: '読み取りカウントでホットデータを並べ替え'
# 'sort ordering'
HE318259881C5: '並べ替え順序'
# 'sort output by this field'
H610F666D308E: 'このフィールドで出力を並べ替え'
# 'sort stack allocations'
HB4DFBCC44FE6: 'スタック割り当てをソート'
# 'sorted by all names'
H8915B99CE6ED: 'すべての名前でソート済み'
# 'source file is not valid UTF-8'
HDC95C446AFAD: 'ソースファイルが有効なUTF-8ではありません'
# 'source manager location address space usage:'
H7D02F3625956: 'ソースマネージャの場所アドレス空間の使用状況：'
# 'specialization of member %q0 does not specialize an instantiated member'
H7EB7CDEAD3CD: 'メンバー%q0の特殊化は、インスタンス化されたメンバーを特殊化しません'
# 'specified %0 type tag requires a null pointer'
HEFCCEFE3C17F: '指定された%0タイプタグにはNULLポインタが必要です'
# 'specifies thread count for the multithreading for updating DWO debug info'
H230218760941: 'DWOデバッグ情報を更新するためのマルチスレッドのスレッド数を指定'
# 'specify a target CPU'
H6DAAF9946704: 'ターゲットCPUを指定'
# 'specify a target triple'
H91E21A4D2F5C: 'ターゲットトリプルを指定'
# 'specify a tune CPU'
H484461AF94A8: 'チューニング用CPUを指定'
# 'specify path of the runtime hugify library'
H05DF4B0878FF: 'ランタイムhugifyライブラリのパスを指定'
# 'specify path of the runtime instrumentation library'
HC0D79561313D: 'ランタイムインストゥルメンテーションライブラリのパスを指定'
# 'specify that .altinstructions has padlen field'
H09DED786C540: 'altinstructionsがpadlenフィールドを持つことを指定'
# 'specify the target features'
H68C8195F1EB5: 'ターゲット機能を指定'
# "specifying 'uuid' as an ATL attribute is deprecated; use __declspec instead"
H12B975086F19: "'uuid'をATL属性として指定することは非推奨です；代わりに__declspecを使用してください"
# 'specifying OpenMP directives with [[]] is an OpenMP 5.1 extension'
H4B0556017370: '[]]を使用したOpenMPディレクティブの指定はOpenMP 5.1拡張機能です'
# 'specifying OpenMP directives with [[]] is incompatible with OpenMP standards before OpenMP 5.1'
H8022C700FE36: '[]]を使用したOpenMPディレクティブの指定はOpenMP 5.1以前のOpenMP標準と互換性ありません'
# 'specifying an identifier within `#pragma pack` is not supported on this target'
H6F2B8F9FE9C4: '#pragma pack`内で識別子を指定することはこのターゲットではサポートされていません'
# "specifying both a name and alignment to 'pop' is undefined"
HC71C880E8806: "'pop'に名前とアラインメントの両方を指定することは未定義です"
# "specifying character '%0' with a universal character name is incompatible with C standards before C23"
H9E4A97D8B259: "%0'のユニバーサル文字名を使用した文字の指定はC23以前のC標準と互換性ありません"
# "specifying character '%0' with a universal character name is incompatible with C++98"
H2678BC1F681E: "ユニバーサル文字名を使用して文字 '%0' を指定することは C++98 と互換性ありません"
# "specifying vector types with the 'mode' attribute is deprecated; use the 'vector_size' attribute instead"
H29212F917029: "'mode' 属性を使用してベクター型を指定することは非推奨です。代わりに 'vector_size' 属性を使用してください"
# 'speculative load hardening does not protect functions with asm goto'
H95EDE5332D8C: 'speculative load hardening は asm goto を持つ関数を保護しません'
# 'spirv.$TypedPointerType'
HDE833BFC0A0D: 'spirv.$TypedPointerType'
# 'split C++ exception handling code'
H77F537E188DE: 'C++例外処理コードを分割します'
# 'split all basic blocks of each function into fragments such that each fragment contains exactly a single basic block'
H4736D758A4A7: '各関数のすべての基本ブロックを、それぞれが単一の基本ブロックを正確に含むように分割します'
# 'split each function into N fragments at a randomly chosen split points (ignoring any available profiling information)'
H5EA52FAFF0B6: 'プロファイリング情報（存在する場合）を無視して、各関数をランダムな分割ポイントで N 個のフラグメントに分割します'
# 'split each function into a hot and cold fragment at a randomly chosen split point (ignoring any available profiling information)'
H2575993535E9: 'プロファイリング情報（存在する場合）を無視して、各関数をランダムな分割ポイントでホットとコールドのフラグメントに分割します'
# 'split each function into a hot and cold fragment using profiling information'
H6FB4CEE61F8E: 'プロファイリング情報を利用して、各関数をホットとコールドのフラグメントに分割します'
# 'split each function into a hot, warm, and cold fragment using profiling information'
H39753BA1C3E6: 'プロファイリング情報を利用して、各関数をホット、ウォーム、コールドのフラグメントに分割します'
# 'split function only if its main size is reduced by more than given amount of bytes. Default value: 0, i.e. split iff the size is reduced. Note that on some architectures the size can increase after splitting.'
H80577181729E: '関数の主要サイズが指定されたバイト数より大幅に減少する場合のみ分割します。デフォルト値: 0（分割はサイズの減少時にのみ行われます）。一部のアーキテクチャでは分割後にサイズが増加する可能性があります'
# 'split functions into fragments'
HE833096B1246: '関数をフラグメントに分割します'
# 'split jump tables section into hot and cold based on function execution frequency'
H593FAF497273: 'ジャンプテーブルセクションを関数の実行頻度に基づいてホットとコールドに分割します'
# 'split-file Options'
HDBFADA679092: '分割ファイル オプション'
# "stack frame size (%0) exceeds limit (%1) in '%2'"
HCF0AF62F4A65: "スタックフレームサイズ (%0) が制限 (%1) を超えています ('%2' 内)"
# 'stack nearly exhausted; compilation time may suffer, and crashes due to stack overflow are likely'
HD310C1B31961: 'スタックがほぼ枯渇しています。コンパイル時間が悪化し、スタックオーバーフローによるクラッシュが発生する可能性があります'
# "standard library implementation of %0 is not supported; %select{member '%2' does not have expected form|member '%2' is missing|the type is not trivially copyable|the type does not have the expected form}1"
H8A51A30A514F: "%0 の標準ライブラリ実装はサポートされていません；%select{メンバー '%2' は期待された形式を持っていません|メンバー '%2' が存在しません|型は単純コピー可能ではありません|型は期待された形式を持っていません}1"
# 'standard library not linked and so no interrupt vector table or compiler runtime routines will be linked'
H3B6E22A7AD97: '標準ライブラリがリンクされていないため、割り込みベクターテーブルやコンパイラランタイムルーチンがリンクされません'
# 'star modifier used outside of function prototype'
HA2B9806ED1A1: '関数プロトタイプ外で星修飾子 (*) が使用されました'
# "state of variable '%0' must match at the entry and exit of loop"
H7D285ABC5B72: "変数 '%0' の状態はループの開始と終了で一致する必要があります"
# "statement after '#pragma omp dispatch' must be a direct call to a target function or an assignment to one"
H172FE1A4272E: '#pragma omp dispatch 後のステートメントはターゲット関数への直接呼び出しまたは代入式でなければなりません'
# "statement associated with OpenACC 'atomic%select{| %1}0' directive is invalid"
H42056AC9B64A: "OpenACC 'atomic%select{| %1}0' ディレクティブに関連するステートメントは無効です"
# "statement attribute %0 has higher precedence than function attribute '%select{always_inline|flatten|noinline}1'"
H0AF92FCED836: "ステートメント属性%0は関数属性'%select{always_inline|flatten|noinline}1'よりも優先順位が高くなります"
# 'statement expression not allowed at file scope'
HB4FE90B7D7C8: 'ファイルスコープではステートメント式を使用できません'
# "statement in 'omp %0' directive must be enclosed into a section region"
H69791FF123D5: "'omp %0' ディレクティブ内のステートメントはセクション領域内に配置する必要があります"
# 'statement not allowed in %select{constexpr|consteval}1 %select{function|constructor}0'
HD56C75E5841E: '%select{constexpr|consteval}1 %select{function|constructor}0内でステートメントを使用できません'
# 'statement requires expression of integer type (%0 invalid)'
H752828F0ECD0: '整数型の式が必要です（%0は無効です）'
# 'statement requires expression of scalar type (%0 invalid)'
HFBBF3A578FA4: 'スカラ型の式が必要です（%0は無効です）'
# 'static %0 runtime is not supported on darwin'
H52FFB37B4DFA: 'darwinではstatic %0 ランタイムはサポートされていません'
# 'static %select{function|variable}0 %1 is used in an inline function with external linkage'
HBAA29A669BB7: '静的 %select{関数|変数}0 %1 は、外部リンク付きのインライン関数内で使用されています'
# 'static and non-static member functions with the same parameter types cannot be overloaded'
H455410FE204F: 'staticアサーション式は整数定数式ではありません'
# 'static assertion expression is not an integral constant expression'
H4896ABC370E3: '静的断言式は整数定数式ではありません'
# "static assertion failed due to requirement '%0'%select{: %2|}1"
H3D43CA56F16F: "静的断言が要求 '%0' のため失敗しました%select{: %2|}1"
# 'static assertion failed%select{: %1|}0'
H4F7EABF6B0DD: '静的断言が失敗しました%select{: %1|}0'
# 'static const volatile data member must be initialized out of line'
H407C919E04E8: '静的な const volatile データメンバは、外から初期化する必要があります'
# 'static data member %0 already has an initializer'
H6ACB0F956377: 'ユニオン内の静的データメンバ%0はC++11の拡張機能です'
# 'static data member %0 in union is a C++11 extension'
HA330F37BE63B: 'ユニオン内の静的データメンバ%0はC++98と互換性ありません'
# 'static data member %0 in union is incompatible with C++98'
HEBF9EACD8366: 'ユニオン内の静的データメンバ %0 は C++98 と互換性ありません'
# 'static data member %0 not allowed in anonymous %select{struct|interface|union|class|enum}1'
HC964FFEFDD87: '匿名の %select{struct|interface|union|class|enum}1 内では静的データメンバ %0 は許可されません'
# 'static data member %0 not allowed in local %select{struct|interface|union|class|enum}2 %1'
HA56CE2DF143E: 'ローカル %select{struct|interface|union|class|enum}2 %1 内では静的データメンバ %0 は許可されません'
# 'static data member definition cannot specify a storage class'
HF3222609AACF: '静的データメンバの定義ではストレージクラスを指定できません'
# 'static data member of type %0 must be initialized out of line'
H4598A36D5110: '%0 型の静的メンバは、外から初期化する必要があります'
# 'static declaration of %0 follows non-static declaration'
H2C721D0B8C3C: '静的宣言 %0 が非静的宣言の後に続きます'
# 'static lambdas are a C++23 extension'
H0728106ADDA2: '静的ラムダは C++23 の拡張機能です'
# 'static lambdas are incompatible with C++ standards before C++23'
H81C85F6C724E: '静的ラムダは C++23 以前の標準と互換性ありません'
# 'static member %0 cannot be a bit-field'
HDFCBA261B7FE: '静的メンバ %0 はビットフィールドにできません'
# 'static members cannot be declared in an anonymous %select{struct|union}0'
HF2CC0A1A3C82: '匿名の %select{struct|union}0 内では静的メンバを宣言できません'
# 'static variable %0 is suspiciously used within its own initialization'
H1CCD7A0167D8: '静的変数 %0 は、自身の初期化内で不審に使用されています'
# 'static_cast between pointer-to-function and pointer-to-object is a Microsoft extension'
H747267A37B70: '関数ポインタとオブジェクトポインタ間の static_cast は Microsoft の拡張機能です'
# "std::coroutine_handle isn't a class template"
H20FD07579F32: 'std::coroutine_handle はクラステンプレートではありません'
# "std::coroutine_handle must have a member named '%0'"
HC01B7EC5D8D7: 'std::coroutine_handle はメンバー "%0" を持たなければなりません'
# "std::coroutine_traits isn't a class template"
H3D3F8F520E5F: 'std::coroutine_traits はクラステンプレートではありません'
# 'std::initializer_list must be a class template with a single type parameter'
H57E56532E11C: 'std::initializer_listは単一の型パラメータを持つクラステンプレートでなければなりません'
# 'std::nothrow must be a valid variable declaration'
H81985EEDEA6B: 'std::nothrowは有効な変数宣言でなければなりません'
# 'std::nothrow was not found; include <new> before defining a coroutine which uses get_return_object_on_allocation_failure()'
H553185766FEB: 'std::nothrowが見つかりません; get_return_object_on_allocation_failure()を使用するコルーチンを定義する前に<new>を含めてください'
# "step simple modifier is exclusive and cannot be use with 'val', 'uval' or 'ref' modifier"
H61FE9B0F27A0: "ステップ単純修飾子は排他的で、'val'、'uval'、または'ref'修飾子と同時に使用できません"
# 'still within definition of %q0 here'
HE0627D20A1B5: 'ここでの%q0の定義の範囲内にまだあります'
# 'stop processing once we have enough to compare two binaries'
H5E734E25A522: '2つのバイナリを比較するために十分な情報を得た時点で処理を停止します'
# 'storage class specified for a member declaration'
HE2F76CA3682F: 'メンバ宣言に対してストレージクラスが指定されました'
# 'store PCHs in memory'
HAE2E8E366E23: 'メモリにPCHを保存'
# 'store PCHs on disk'
HB5252992D5B4: 'ディスクにPCHを保存'
# 'strategy used to partition blocks into fragments'
H892362B1790A: 'ブロックをフラグメントに分割するために使用される戦略'
# 'stress rotate selection in aggressive ppc isel for bit permutations'
HAC5B66207D31: 'ビット順序変換のための攻撃的 ppc isel での stress rotate 選択'
# 'strftime format attribute requires 3rd parameter to be 0'
H48F53118805C: 'strftime フォーマット属性では3番目のパラメータを0にする必要があります'
# 'stride must be greater or equal to the number of rows'
H8F8F20EB9F60: 'ストライドは行の数以上でなければなりません'
# 'string is ill-formed as UTF-8 and will become a null %0 when boxed'
H978281414E51: 'UTF-8 として不正な文字列は、ボックス化時にnull %0になります'
# "string literal after 'operator' cannot have an encoding prefix"
HE2D46EB90348: 'operatorの後の文字列リテラルにはエンコーディングプレフィックスを付けることはできません'
# 'string literal after \'operator\' must be \'""\''
HB2C541BB7B81: 'operatorの後の文字列リテラルは""でなければなりません'
# 'string literal of length %0 exceeds maximum length %1 that %select{C90|ISO C99|C++}2 compilers are required to support'
H446F1FE51F67: '長さ%0の文字列リテラルは、%select{C90|ISO C99|C++}2コンパイラがサポートする最大長%1を超えています'
# 'string literal operator templates are a GNU extension'
HC7C4AAEBD81D: '文字列リテラルオペレーターテンプレートはGNU拡張機能です'
# 'string literal with user-defined suffix cannot be used here'
H0A403620271A: 'ユーザー定義接尾辞を持つ文字列リテラルはここでは使用できません'
# 'string literals that exceed this length will use a hash value as their symbol name'
HA27BA101BC94: 'この長さを超える文字列リテラルはハッシュ値をシンボル名として使用します'
# 'string to set default kind values'
H7121B365791A: '既定の種類の値を設定するための文字列'
# "strip 'repz' prefix from 'repz retq' sequence (on by default)"
H5E0A0D55638D: "「repz」プレフィックスを'repz retq'シーケンスから除去 (既定では有効)"
# 'structured binding declaration in a condition is a C++2c extension'
H7AF1E5D1A2D0: '条件内の構造化バインディング宣言はC++2c拡張機能です'
# 'structured binding declaration in a condition is incompatible with C++ standards before C++2c'
HD456E18D0B36: '条件内の構造化バインディング宣言はC++2cより前のC++規格と互換性ありません'
# 'structured binding packs are a C++2c extension '
H041F82FB15BE: '構造化バインディング・パックはC++2c拡張機能です'
# 'structured binding packs are incompatible with C++ standards before C++2c'
HD48DDFF6186B: '構造化バインディング・パックはC++2cより前のC++規格と互換性ありません'
# 'structurize SPIRV'
H886FBF76EA85: 'SPIRVの構造化'
# 'style of printing regions'
H063C50F12566: '領域の出力スタイル'
# 'subcommand'
H146947FFD26E: 'サブコマンド'
# 'subexpression not valid in a constant expression'
H9779A11486AE: '定数式ではサブ式が有効ではありません'
# 'submodule %0.%1 not declared in module map'
H1DA53EDBF661: 'サブモジュール%0.%1がモジュールマップに宣言されていません'
# "submodule of top-level module '%0' implicitly imported here"
HDAE6F5126C46: "トップレベルのモジュール'%0'のサブモジュールがここに暗黙的にインポートされました"
# 'subobject %select{of type |}0%1 is not initialized'
HF2C7BC6C2C0D: 'サブオブジェクト%select{の型|}0%1は初期化されていません'
# 'subobject declared here'
H554F161157BC: 'ここに宣言されたサブオブジェクト'
# 'subscript of a pointer to void is a GNU extension'
H3CC7AA95FFD8: 'voidへのポインタの添字はGNU拡張機能です'
# 'subscript of pointer to %select{incomplete|sizeless}0 type %1'
H1AFEC4E5E6B6: '%select{未完了|サイズなし}0型%1へのポインタの添字'
# 'subscript of pointer to function type %0'
H768DEE928692: '関数型%0へのポインタの添字'
# 'subscript of svbool_t is not allowed'
H8F54745267C0: 'svbool_tへの添字は許可されていません'
# 'subscript requires size of interface %0, which is not constant for this architecture and platform'
H10B94DBD4388: 'インターフェース%0のサイズが必要ですが、このアーキテクチャとプラットフォームでは定数ではありません'
# 'subscripted value is not an array or pointer'
HFC1E308C6B30: '添字が付いた値は配列またはポインタではありません'
# 'subscripted value is not an array, pointer, or vector'
H1F892D50B541: '添字演算子の適用対象は配列、ポインタ、またはベクターではありません'
# 'substitution failure due to access control is incompatible with C++98'
H09899E5F733A: 'アクセス制御による置換失敗はC++98と互換性ありません'
# 'substitution into constraint expression resulted in a non-constant expression'
H0CC3DD33E92E: '制約式への置換により非定数式が生成されました'
# 'subtracted pointers are not elements of the same array'
HBF5BC0994673: '減算されたポインタは同じ配列の要素ではありません'
# 'subtraction of pointers to type %0 of zero size'
HAE88E507C99F: '%0型のゼロサイズのポインタ間の減算'
# 'subtraction of pointers to type %0 of zero size has undefined behavior'
H238100FAEBF4: '%0型のゼロサイズのポインタ間の減算は未定義動作です'
# 'suffix with parentheses to turn this into a function call'
HBA5C36C9B0F9: 'この構文を関数呼び出しに変換するにはパラメータ付きの接尾辞が必要です'
# 'suggest braces around initialization of subobject'
H122DA545D844: 'サブオブジェクトの初期化にブレースを使用することを推奨します'
# 'sum of call durations'
H97819C630794: '呼び出し時間の合計'
# "support for '/Yc' and '/Yu' with different filenames not implemented yet; flags ignored"
HC924164CBDE2: "'/Yc'と'/Yu'で異なるファイル名をサポートする機能は未実装です; フラグは無視されます"
# "support for '/Yc' with more than one source file not implemented yet; flag ignored"
H7450874B7BA1: "'/Yc'で複数のソースファイルをサポートする機能は未実装です; フラグは無視されます"
# 'support for HLSL language version %0 is incomplete, recommend using %1 instead'
H68BB4F93A02C: 'HLSL言語バージョン%0のサポートは未完です。代わりに%1を使用することを推奨します'
# "support for linking stdlibs for microcontroller '%0' is not implemented"
H8995E8434A04: "マイコン'%0'用のstdlibリンカーのサポートは未実装です"
# "support for passing the data section address to the linker for microcontroller '%0' is not implemented"
H870D8231D796: "マイコン'%0'のデータセクションアドレスをリンカーに渡す機能は未実装です"
# 'surrounding namespace with visibility attribute ends here'
H4297D0DA8CEA: 'この場所で可視性属性を付与した名前空間が終了します'
# 'surrounding namespace with visibility attribute starts here'
HA543A7B12EEA: 'この場所で可視性属性を付与した名前空間が開始します'
# 'suspicious concatenation of string literals in an array initialization; did you mean to separate the elements with a comma?'
HE00F78FF32CA: '配列初期化において文字列リテラルの怪しげな連結が検出されました。要素をカンマで区切る意図でしたか？'
# 'switch condition has boolean value'
HA563E9019204: 'スイッチ条件は論理値です'
# 'switch condition has incomplete class type %0'
HD68BA6071310: 'スイッチ条件は未完全なクラス型%0です'
# 'switch condition type %0 requires explicit conversion to %1'
HF719378BC596: 'スイッチ条件の型%0は明示的な%1への変換が必要です'
# 'switch statement has empty body'
HD379C27E8554: 'switch 文の本体が空です'
# "symbol exported in dynamic library, but marked hidden in declaration '%0'"
H493627372D47: "動的ライブラリでエクスポートされたシンボルが、宣言 '%0' で隠蔽されています"
# 'symbol sort order'
H13E171348CDC: 'シンボルの並べ替え順序'
# 'symbolize function ids from the input log'
HBDC90FB5E310: '入力ログから関数IDをシンボル化します'
# 'symbolize functions'
H4B741D643A7C: '関数をシンボル化します'
# 'synchronization scope argument to atomic operation is invalid'
HE1E237FB50C9: 'アトミック操作の同期スコープ引数が無効です'
# 'synthesized properties %0 and %1 both claim instance variable %2'
H9EA52B48540E: '合成されたプロパティ %0 と %1 が共にインスタンス変数 %2 を要求しています'
# 'synthesized properties %0 and %1 both claim setter %2 - use of this setter will cause unexpected behavior'
HA9255CAB38EC: '合成されたプロパティ %0 と %1 が共にセッター %2 を要求しています - このセッターの使用は予期しない動作を引き起こします'
# 'synthesized property %0 must either be named the same as a compatible instance variable or must explicitly name an instance variable'
HC10D22B3B816: '合成されたプロパティ %0 は、互換性のあるインスタンス変数と同じ名前か、明示的にインスタンス変数を指定する必要があります'
# 'synthesized property with variable size type %0 requires an existing instance variable'
H594CC555D195: '可変サイズ型 %0 を持つ合成されたプロパティは、既存のインスタンス変数が必要です'
# 'synthesized setter %0 for null_resettable property %1 does not handle nil'
H95960177BFF3: 'null_resettable プロパティ %1 の合成されたセッター %0 は nil を処理しません'
# 'synthesizing __weak instance variable of type %0, which does not support weak references'
H1E4EBACF7211: '__weak インスタンス変数 %0 の生成は、弱参照をサポートしていません'
# 'system diff used by change reporters'
HBA4E429740F6: '変更レポート用システムの diff'
# 'system dot used by change reporters'
H9A7274B114C8: '変更レポート用システムの dot'
# 'tail blocks whose size (in bytes) exceeds the value are never duplicated'
HDC606CA00EBA: 'サイズ（バイト単位）が値を超えるテール ブロックは決して複製されません'
# 'tail blocks with size (in bytes) not exceeding the value are always duplicated'
H2F3A5FED8EF0: 'サイズ（バイト単位）が値を超えないテール ブロックは常に複製されます'
# 'tail call required by %0 attribute here'
H9FB91CA4B73B: '%0 属性で要求されたテール コールが必要です'
# 'tail call requires that the return value, all parameters, and any temporaries created by the expression are trivially destructible'
HE303C40B04A3: 'テール コールでは、戻り値、すべてのパラメータ、式によって作成された一時変数が単純に破棄可能である必要があります'
# 'taking address of a capture is not allowed'
H35418F9DEF58: 'キャプチャのアドレスを取得することは許可されていません'
# 'taking address of function is not allowed'
H4A30B839C6AB: '関数のアドレスを取得することは許可されていません'
# 'taking address of non-addressable standard library function'
H3ACD682CFC45: '標準ライブラリ関数のアドレスを取得できません'
# 'taking address of non-addressable standard library function is incompatible with C++20'
H888C6C415192: 'C++20 と互換性がありません'
# 'taking address of packed member %0 of class or structure %q1 may result in an unaligned pointer value'
HD700C27ED0FC: '構造体またはクラス %q1 のパック済みメンバー %0 のアドレスを取得すると、アンアラインしたポインタ値になる可能性があります'
# 'taking the absolute value of %select{pointer|function|array}0 type %1 is suspicious'
HDEB21F2512CF: '%select{ポインタ|関数|配列}0 の型 %1 の絶対値を取ることは疑わしい可能性があります'
# 'taking the absolute value of unsigned type %0 has no effect'
H8F6DAEC8BECD: '符号なし型 %0 の絶対値を取ることは効果がありません'
# 'taking the address of a destructor'
H7B853F7C78AC: 'デストラクタのアドレスを取得しています'
# 'taking the address of a temporary object of type %0'
HD39DC5626A0A: '一時的なオブジェクトのアドレスを取得しています (型%0)'
# 'taking the max of %select{a value and unsigned zero|unsigned zero and a value}0 is always equal to the other value'
H75EF0725015B: '%select{値と符号なしゼロ|符号なしゼロと値}0 の最大値を取るのは、常にもう一方の値と同じになります'
# 'target %select{constructor|destructor}0 is declared here'
HD59E728E618B: '対象の%select{コンストラクタ|デストラクタ}0はここで宣言されています'
# "target '%0' does not support exception handling; 'catch' block is ignored"
H06DD0F5375FE: "ターゲット'%0'は例外処理をサポートしていません；'catch'ブロックは無視されます"
# "target '%0' does not support exception handling; 'throw' is assumed to be never reached"
H29FDCCFA5847: "ターゲット'%0'は例外処理をサポートしていません；'throw'は到達不能と仮定されます"
# "target '%0' is not a supported OpenMP host target"
H6B6204612E53: "ターゲット'%0'はサポートされていないOpenMPホストターゲットです"
# "target '%0' is unsupported by -fsanitize-kcfi-arity"
HCFEF0540C5A0: "ターゲット'%0'は-fsanitize-kcfi-arityでサポートされていません"
# 'target construct with nested teams region contains statements outside of the teams construct'
HB05FDB001094: 'ターゲット構造体内のネストされたチームズ領域に、チームズ構造体外のステートメントが含まれています'
# "target does not support 'protected' visibility; using 'default'"
H9354CE031F68: "ターゲットは'protected'可視性をサポートしていません；'default'を使用します"
# 'target exception specification is not superset of source'
H14AD31786EFD: 'ターゲット例外仕様はソースのスーパー セットではありません'
# 'target function %select{is a member of different class%diff{ (expected $ but has $)|}1,2|has different number of parameters (expected %1 but has %2)|has type mismatch at %ordinal3 parameter%diff{ (expected $ but has $)|}1,2|has different return type%diff{ ($ expected but has $)|}1,2}0'
HFEFD6F95E799: 'ターゲット関数%select{異なるクラスのメンバーです%diff{ (期待: $ だが $ があります)|}1,2|パラメータ数が異なります (期待: %1 だが %2 個あります)|%ordinal3番目のパラメータの型が異なります%diff{ (期待: $ だが $ があります)|}1,2|戻り値の型が異なります%diff{ ($ 期待だが $ です)|}1,2}0'
# 'target function has calling convention %1 (expected %0)'
HE7D037C49FE5: 'ターゲット関数の呼び出し規約は%1 (期待%0) です'
# 'target of using declaration'
HCB1C9C62D72D: 'using宣言の対象'
# 'target of using declaration conflicts with declaration already in scope'
H5C1974A3FA23: 'using宣言の対象はスコープ内の宣言と競合しています'
# 'target profile option (-T) is missing'
HD96117F3AEE8: 'オプション -T を指定するターゲット プロファイルがありません'
# 'target-attribute based function overloads are not supported by NVCC and will be treated as a function redeclaration:new declaration is %select{__device__|__global__|__host__|__host__ __device__}0 function, old declaration is %select{__device__|__global__|__host__|__host__ __device__}1 function'
H48B3A7876AE7: 'NVCCではターゲット属性による関数オーバロードはサポートされません。関数の再宣言として扱われます：新しい宣言は%select{__device__|__global__|__host__|__host__ __device__}0関数、古い宣言は%select{__device__|__global__|__host__|__host__ __device__}1関数'
# 'tbd'
H1D9C8AC0B205: '未定'
# 'template %0 has no definition and no %select{|viable }1deduction guides for deduction of template arguments'
H39A2D17F6485: 'テンプレート %0 には定義がなく、テンプレート引数の推論に%select{|有効な }1推論ガイドもありません'
# 'template argument / label address difference / what did you expect?'
H4022196FB5B0: 'テンプレート引数 / ラベルアドレスの差分 / 何を期待しましたか？'
# 'template argument does not refer to a class or alias template, or template template parameter'
H10B27B45B43C: 'テンプレート引数はクラスやエイリアステンプレート、またはテンプレートテンプレートパラメータを指しません'
# 'template argument for non-type template parameter is treated as function type %0'
HF7C463216541: '非型テンプレートパラメータのテンプレート引数は関数型%0として扱われます'
# 'template argument for non-type template parameter must be an expression'
HA6F518CB9F6F: '非型テンプレートパラメータのテンプレート引数には式を指定する必要があります'
# 'template argument for template template parameter must be a class template%select{| or type alias template}0'
H4605CB1853A3: 'テンプレートテンプレートパラメータのテンプレート引数にはクラステンプレート%select{|または型エイリアステンプレート}0を指定する必要があります'
# 'template argument for template type parameter must be a type'
H9FFBB255FD4F: 'テンプレート型パラメータのテンプレート引数には型を指定する必要があります'
# "template argument for template type parameter must be a type; did you forget 'typename'?"
H477EE50BCF4B: "テンプレート型パラメータのテンプレート引数には型を指定する必要があります；'typename' を忘れた可能性があります"
# "template argument for template type parameter must be a type; omitted 'typename' is a Microsoft extension"
H0CC2569F4810: "テンプレート型パラメータのテンプレート引数には型を指定する必要があります；'typename' の省略はMicrosoft拡張機能です"
# 'template argument is the type of an unresolved overloaded function'
H1DDFBAF8CEBB: 'テンプレート引数は解決できないオーバーロード関数の型です'
# 'template argument refers to function template %0, here'
H59E0A4B6EEC0: 'テンプレート引数は関数テンプレート%0を指します'
# 'template argument uses local type %0'
H8CFAA5F55F9C: 'テンプレート引数は局所型%0を使用しています'
# 'template argument uses unnamed type'
H1A9FF29A8094: 'テンプレート引数は名前なし型を使用しています'
# 'template declaration from hidden source: %0'
H607A13711E91: '隠蔽されたソースからのテンプレート宣言: %0'
# 'template is declared here'
H8B583108C6ED: 'テンプレートはここに宣言されています'
# 'template name refers to non-type template %0'
HD8E4D2A7EC89: 'テンプレート名は非型テンプレート%0を指します'
# 'template non-type parameter has a different type %0 in template %select{|template parameter }1redeclaration'
H29D49A380D2B: 'テンプレートの非型テンプレートパラメータ%0は、テンプレート%select{|テンプレートパラメータ }1の再宣言で異なる型を持っています'
# 'template non-type parameter has a different type %0 in template argument'
H83C8844C296B: 'テンプレート非型パラメータは、テンプレート引数での型%0が異なります'
# "template parameter '%0' is already documented"
H4188A9C61053: "テンプレートパラメータ'%0'は既に文書化されています"
# "template parameter '%0' not found in the template declaration"
H1A80B68DAC8D: "テンプレート宣言においてテンプレートパラメータ'%0'が見つかりません"
# 'template parameter declared here'
HC6CFA91EE1C1: 'テンプレートパラメータはここで宣言されています'
# 'template parameter default argument is inconsistent with previous definition'
H6440E4D1834B: 'テンプレートパラメータのデフォルト引数は以前の定義と不一致です'
# 'template parameter from hidden source: %0'
HE652270F3F6D: 'テンプレートパラメータの隠蔽ソース:%0'
# 'template parameter has a different kind in template %select{|template parameter }0redeclaration'
HBF82CEEA37C8: 'テンプレートパラメータは、テンプレート%select{|テンプレートパラメータ}0再宣言において異なる種類を持っています'
# 'template parameter has a different kind in template argument'
H8F8F50E907A1: 'テンプレートパラメータはテンプレート引数において異なる種類を持っています'
# 'template parameter has different kinds in different translation units'
H8BA5D6787AFF: 'テンプレートパラメータは異なる翻訳ユニットにおいて異なる種類を持っています'
# 'template parameter is declared here'
H6B3C8DC0FA6A: 'テンプレートパラメータはここで宣言されています'
# 'template parameter is used in default argument declared here'
HF0F9ED98885D: 'テンプレートパラメータはここで宣言されたデフォルト引数で使用されています'
# 'template parameter list also declared here'
H1F8E29374B19: 'テンプレートパラメータリストはここでも宣言されています'
# "template parameter list for literal operator must be either 'char...' or 'typename T, T...'"
H409CCC2DB745: "リテラル演算子用のテンプレートパラメータリストは'char...'または'typename T, T...'のいずれかでなければなりません"
# "template parameter list matching the non-templated nested type %0 should be empty ('template<>')"
HE4D93F6B6699: '非テンプレート化ネスト型%0に一致するテンプレートパラメータリストは空でなければなりません（"template<>"）'
# 'template parameter lists have a different number of parameters (%0 vs %1)'
HB5785F1417CF: 'テンプレートパラメータリストのパラメータ数が異なります（%0対%1）'
# 'template parameter missing a default argument'
H5BFE290A5AC0: 'テンプレートパラメータにデフォルト引数がありません'
# "template parameter of a function template with the 'sycl_kernel' attribute cannot be a non-type template parameter"
H7625BE567F07: "'sycl_kernel'属性を持つ関数テンプレートのテンプレートパラメータは非型テンプレートパラメータを指定できません"
# 'template parameter pack cannot have a default argument'
HD1F9E9063EB7: 'テンプレートパラメータパックにはデフォルト引数を指定できません'
# 'template parameter pack must be the last template parameter'
HD5749F5C7756: 'テンプレートパラメータパックは最後のテンプレートパラメータでなければなりません'
# 'template parameter redefines default argument'
H8C66CF577C62: 'テンプレートパラメータがデフォルト引数を再定義しています'
# 'template specialization declaration cannot be a friend'
HA8ECAC04AF8C: 'テンプレートの特殊化宣言はフレンドできません'
# 'template specialization or definition requires a template parameter list corresponding to the nested type %0'
HC868EA3957FF: 'テンプレートの特殊化または定義には、ネストされた型%0に対応するテンプレートパラメータリストが必要です'
# "template specialization requires 'template<>'"
H1ADEE7A736DF: "テンプレートの特殊化には'template<>'が必要です"
# 'template template argument %0 is more constrained than template template parameter %1'
HE3F8D9BFA908: '%0のテンプレートテンプレート引数は、%1のテンプレートテンプレートパラメータよりも制約が厳しいです'
# 'template template argument has different template parameters than its corresponding template template parameter'
HB7542BD3C1FF: 'テンプレートテンプレート引数は、対応するテンプレートテンプレートパラメータと異なるテンプレートパラメータを持っています'
# 'template template parameter must have its own template parameters'
H2E8B286B021F: 'テンプレートテンプレートパラメータには、その自前のテンプレートパラメータが必要です'
# "template template parameter requires 'class'%select{| or 'typename'}0 after the parameter list"
HC7B5002008B5: 'テンプレートテンプレートパラメータには、パラメータリストの後に"class"%select{|または"typename"}0が必要です'
# "template template parameter using 'typename' is a C++17 extension"
HD13D228AA386: '"typename"を使用したテンプレートテンプレートパラメータはC++17の拡張機能です'
# "template template parameter using 'typename' is incompatible with C++ standards before C++17"
H2724DAD0662B: '"typename"を使用したテンプレートテンプレートパラメータはC++17以前の標準とは互換性がありません'
# 'templates can only be declared in namespace or class scope'
H549BBF1A776B: 'テンプレートは、名前空間またはクラスのスコープ内でしか宣言できません'
# 'templates cannot be declared inside of a local class'
H9817A58D9951: 'テンプレートはローカルクラス内では宣言できません'
# 'templates must have C++ linkage'
H7DA4A8DB6A41: 'テンプレートにはC++のリンケージが必要です'
# 'temporary bound to reference member of allocated object will be destroyed at the end of the full-expression'
H013054578BC3: 'アロケーションされたオブジェクトのリファレンスメンバーに束縛された一時オブジェクトは、完全式の終了時に破棄されます'
# 'temporary created here'
H6CF924D32FF7: 'ここで作成された一時オブジェクト'
# 'temporary of type %0 has %select{private|protected}1 destructor'
HA776568AF253: '型%0の一時オブジェクトは%select{private|protected}1のデストラクタを持っています'
# 'tentative array definition assumed to have one element'
H1578DBDB8944: '推定配列定義は1要素を持つと仮定されます'
# 'tentative definition has type %0 that is never completed'
H2533423DBC92: '推定定義は%0という型を持っており、完成しません'
# 'tentative definition of variable with internal linkage has incomplete non-array type %0'
H137EE1AFC5D6: '内部リンケージを持つ変数の推定定義は、非配列の未完成型%0を持っています'
# 'tenths of percents of main entry frequency to use as a threshold when evaluating whether a basic block is cold (0 means it is only considered cold if the block has zero samples). Default: 0 '
HB4A505AFFDA6: '基本ブロックがColdかどうかを評価する際の閾値として使用する、メインエントリーフレキランスの百分率の十分位 (0はブロックがサンプル0の場合のみColdとみなされます。デフォルト:0)'
# "test module file extension '%0' has different version (%1.%2) than expected (%3.%4)"
HD419260C8BE7: 'テストモジュールファイル拡張子"%0"は予期されたバージョン(%3.%4)とは異なるバージョン(%1.%2)を持っています'
# 'the #__include_macros directive is only for internal use by -imacros'
H1FBDC6FD510E: '#__include_macros ディレクティブは、-imacros による内部使用専用です'
# 'the %0 sub-architecture does not support unaligned accesses'
H8EEF78B6F581: '%0 サブアーキテクチャはアラインメントのないアクセスをサポートしていません'
# 'the %0 type cannot be used to declare a program scope variable'
HCC2A02E45E01: '%0 型はプログラムスコープの変数宣言には使用できません'
# 'the %0 type cannot be used to declare a structure or union field'
H3AA824360E4A: '%0 型は構造体またはユニオンのフィールド宣言には使用できません'
# 'the %select{1st|2nd|3rd}1 template parameter of %0 needs to be %select{a type|an integer or enum value}2'
HC15D25E5BA46: '%0 のテンプレートパラメータの %select{1番目|2番目|3番目}1 は %select{型|整数または列挙値}2 である必要があります'
# 'the %select{function or variable|function}0 specified in an %select{alias|ifunc}1 must refer to its mangled name'
H2A963C3F164E: '指定された %select{関数または変数|関数}0 の %select{エイリアス|イフンク}1 は、そのマングル名を参照する必要があります'
# "the %select{message|string}0 object in %select{this static assertion|this asm operand}0 is missing %select{a 'size()' member function|a 'data()' member function|'data()' and 'size()' member functions}1"
HF8EFF7FCD3A1: "%select{この静的アサーション|このアセンブリオペランド}0 の %select{メッセージ|文字列}0 オブジェクトは、%select{'size()' メンバ関数|'data()' メンバ関数|'data()' と 'size()' メンバ関数}1 がありません"
# "the '%0' unit is not supported with this instruction set"
H66612647AED8: "'%0' ユニットはこの命令セットではサポートされていません"
# "the '%select{&|*|->}0' operator is unsupported in HLSL"
H831B25ED6E8C: "'%select{&|*|->}0' オペレーターはHLSLではサポートされていません"
# "the '[[_Noreturn]]' attribute spelling is deprecated in C23; use '[[noreturn]]' instead"
H584C1C164ECE: "'[[Noreturn]]' 属性の綴りはC23で非推奨になりました。代わりに'[[noreturn]]'を使用してください"
# "the 'copyprivate' clause must not be used with the 'nowait' clause"
H026F61D558F6: "'copyprivate'句は'nowait'句と併用できません"
# "the 'static' modifier for the array size is not legal in new expressions"
H285525BB6E11: "配列サイズの'static'修飾子はnew式では有効ではありません"
# "the ApplicationExtensionSafe flag does not match: '%0' (provided) vs '%1' (found)"
H74ECAC68920E: "ApplicationExtensionSafeフラグが一致しません: '%0' (指定値) と '%1' (検出値)"
# 'the GNU address of label extension is not allowed in coroutines'
HEE9FFF3C021C: 'コルーチンではGNUのラベルアドレス拡張機能は使用できません'
# "the NotForDyldSharedCache flag does not match: '%0' (provided) vs '%1' (found)"
HAD9256F7D2F3: "NotForDyldSharedCacheフラグが一致しません: '%0' (指定値) と '%1' (検出値)"
# 'the __block storage type is not permitted'
H2951C6144658: '__block ストレージタイプは許可されていません'
# 'the address of a declaration with unknown type can only be cast to a pointer type'
H6D4B76B01E9C: '未知の型の宣言のアドレスはポインタ型へのキャストのみ可能です'
# "the argument '%0' is not supported for option '%1'. Mapping to '%1%2'"
HA4EFCA49DC99: "オプション'%1'の引数'%0'はサポートされていません。'%1%2'にマッピングされます"
# "the clang compiler does not support '%0'"
HCB0DF6FD34A3: "clangコンパイラーは'%0'をサポートしていません"
# "the clang compiler does not support '%0' for C++ on Darwin/i386"
HAB9E0C38E134: "clangコンパイラーはDarwin/i386向けC++で'%0'をサポートしていません"
# "the clang compiler does not support '%0', %1"
H70791B1776AF: "clangコンパイラは'%0'をサポートしていません、%1"
# 'the clang compiler does not support -pg option on %select{Darwin|versions of OS X 10.9 and later}0'
HEC221F97986E: 'clangコンパイラは%select{Darwin|OS X 10.9以降のバージョン}0で-pg オプションをサポートしていません'
# 'the clustering algorithm to use'
HEE034B797939: '使用するクラスタリングアルゴリズム'
# "the combination of '%0' and '%1' is incompatible"
H04D1D2EB3A72: "'%0'と'%1'の組み合わせは互換性がありません"
# "the context %select{set|selector|property}0 '%1' was used already in the same 'omp declare variant' directive; %select{set|selector|property}0 ignored"
H6268D8504255: "同じ'omp declare variant'ディレクティブ内で、コンテキスト%select{セット|セレクタ|プロパティ}0 '%1'が既に使用されています；%select{セット|セレクタ|プロパティ}0は無視されます"
# "the context property '%0' can be nested in the context selector '%1' which is nested in the context set '%2'; try 'match(%2={%1(%0)})'"
HAA758F7206BE: "コンテキストプロパティ'%0'は、コンテクストセレクタ'%1'でネストされ、コンテクストセット'%2'でネストされています；'match(%2={%1(%0)})'を試してください"
# "the context property '%0' is not valid for the context selector '%1' and the context set '%2'; property ignored"
H88A5B848CED9: "コンテキストプロパティ'%0'はコンテクストセレクタ'%1'とコンテクストセット'%2'には無効です；プロパティは無視されました"
# "the context selector '%0' can be nested in the context set '%1'; try 'match(%1={%0%select{|(property)}2})'"
HDD6FFFA1FE6E: "コンテクストセレクタ'%0'はコンテクストセット'%1'でネストできます；'match(%1={%0%select{|(property)}2})'を試してください"
# "the context selector '%0' in context set '%1' requires a context property defined in parentheses; selector ignored"
H4359A48C4F70: "コンテクストセット'%1'内のコンテクストセレクタ'%0'には、括弧内に定義されたコンテキストプロパティが必要です；セレクタは無視されました"
# "the context selector '%0' in the context set '%1' cannot have a score ('%2'); score ignored"
H98F3D66A37F6: "コンテクストセット'%1'内のコンテクストセレクタ'%0'にはスコア'%2'を指定できません；スコアは無視されました"
# "the context selector '%0' is not valid for the context set '%1'; selector ignored"
HDF7A50F1E9D4: "コンテクストセット'%1'内のコンテクストセレクタ'%0'は無効です；セレクタは無視されました"
# "the coroutine promise type %0 declares both 'return_value' and 'return_void'"
H089B386C28E8: "コルーチンプロミス型%0は'return_value'と'return_void'の両方を宣言しています"
# 'the current #pragma pack alignment value is modified in the included file'
H1259B6694648: '#pragma packのアラインメント値が包含ファイル内で変更されました'
# 'the event_t type can only be used with __private address space qualifier'
HF7753CC750DA: 'event_t型は__privateアドレス空間修飾子のみで使用できます'
# 'the experimental clang interpreter failed to evaluate an expression'
H0E50C442ED03: '実験的なclangインタプリタは式の評価に失敗しました'
# 'the explicit object parameter cannot be a function parameter pack'
HAC332D9FE6A2: '明示的オブジェクトパラメータは関数パラメータパックにできません'
# 'the explicit object parameter cannot have a default argument'
HEF646D36FD87: '明示的オブジェクトパラメータにはデフォルト引数を指定できません'
# "the expression 'co_await __promise.final_suspend()' is required to be non-throwing"
HBE8E0E1AD063: "'co_await __promise.final_suspend()'式はthrowしない必要があります"
# "the flag '%0' has been deprecated and will be ignored"
H97F3754670BE: "フラグ'%0'は非推奨となり、無視されます"
# "the form '-fmodule-file=<BMI-path>' is deprecated for standard C++ named modules; consider to use '-fmodule-file=<module-name>=<BMI-path>' instead"
H9E11832D49AD: "標準のC++ネームドモジュールに対して、'-fmodule-file=<BMI-path>'の形式は非推奨です。代わりに'-fmodule-file=<module-name>=<BMI-path>'をご利用ください"
# "the given MCU does not support hardware multiply, but '-mhwmult' is set to %0"
HBC73BCBB2AD5: "指定されたMCUはハードウェア乗算をサポートしていませんが、'-mhwmult'が%0に設定されています"
# "the given MCU supports %0 hardware multiply, but '-mhwmult' is set to %1"
H33683D593A85: "指定されたMCUは%0のハードウェア乗算をサポートしていますが、'-mhwmult'が%1に設定されています"
# 'the host cannot update a declare target variable that is not externally visible'
H626F4DD8E816: 'ホストは、外部から見える変数でない宣言ターゲット変数を更新できません'
# 'the ignored %select{set|selector|property}0 spans until here'
H78F2F2873540: '無視された%select{セット|セレクタ|プロパティ}0はここまでの範囲です'
# 'the ignored tokens spans until here'
HE724FD8D9E24: '無視されたトークンはここまでの範囲です'
# 'the implementation of header units is in an experimental phase'
H822B183C153E: 'ヘッダーユニットの実装は実験段階です'
# "the implicit output of reduced BMI may be overrided by the output file specified by '--precompile'. please consider use '-fmodule-output=' to specify the output file for reduced BMI explicitly"
HC77BA90C9A9E: "reduced BMIの暗黙の出力は、'--precompile'で指定された出力ファイルによって上書きされる可能性があります。reduced BMIの出力ファイルを明示的に指定するには'-fmodule-output='をご利用ください"
# "the inscan reduction list item must appear as a list item in an 'inclusive' or 'exclusive' clause on an inner 'omp scan' directive"
H5A6903CB5B88: "inscan reduction list itemは、内側の'omp scan'ディレクティブの'inclusive'または'exclusive'句のリストアイテムとして現れる必要があります"
# "the last '/TC' or '/TP' option takes precedence over earlier instances"
H1D4C07143ED6: "最後に指定された'/TC'または'/TP'オプションが、以前の指定を上書きします"
# "the library '%0=%1' is not supported, OpenMP will not be enabled"
H8332E220148A: "ライブラリ'%0=%1'はサポートされていません。OpenMPは有効になりません"
# "the list item must appear in 'reduction' clause with the 'inscan' modifier of the parent directive"
H331559E5A96C: "このリストアイテムは、親ディレクティブの'inscan'修飾子付き'reduction'句に現れる必要があります"
# 'the loop %select{initializer|condition}0 expression depends on the current loop control variable'
H092C392BA41E: 'ループの%select{初期化|条件}0式は、現在のループ制御変数に依存しています'
# 'the maximum number of instructions analyzed for may throw during attribute inference in inlined body'
HDB567B6559C9: 'インライン本文での属性推論中に、may throwを分析するための最大命令数'
# 'the mode to run'
H1067F4A3FF41: '実行モード'
# 'the name of the PDB file to write'
H3B634F1D4C6F: '書き込むPDBファイルの名前'
# "the name of the construct must be specified in presence of 'hint' clause"
HF664729B6FC3: "'hint'句が存在する場合、構造体の名前を指定する必要があります"
# 'the number of preprocessor source tokens (%0) exceeds this token limit (%1)'
H205DE1F2F79F: 'プリプロセッサソーストークンの数(%0)が、制限値(%1)を超えています'
# 'the object size sanitizer has no effect at -O0, but is explicitly enabled: %0'
H314C428C1C64: '-O0ではオブジェクトサイズサンitizerの効果はありませんが、明示的に有効になっています: %0'
# "the option '-flto=thin' is a work in progress"
H5F57C367214A: "オプション'-flto=thin'は開発中です"
# "the other acquisition of %0 '%1' is here"
HF9475FC44959: "この%0 '%1'の別の宣言はここにあります"
# 'the parameter for an explicitly-defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0 may not be volatile'
HEAA7EB9FB2E0: '明示的にデフォルト化された%select{デフォルトコンストラクタ|コピー コンストラクタ|ムーブ コンストラクタ|コピー代入演算子|ムーブ代入演算子|デストラクタ}0のパラメータはvolatileであってはなりません'
# 'the parameter for an explicitly-defaulted copy assignment operator must be an lvalue reference type'
H7CAB648A4737: '明示的にデフォルト化されたコピー代入演算子のパラメータはlvalue参照型でなければなりません'
# 'the parameter for an explicitly-defaulted move %select{constructor|assignment operator}0 may not be const'
H34E3C1F201FC: '明示的にデフォルト化されたムーブ%select{コンストラクタ|代入演算子}0のパラメータはconstであってはなりません'
# 'the parameter for this explicitly-defaulted copy %select{constructor|assignment operator}0 is const, but a member or base requires it to be non-const'
H7307965D0004: 'この明示的にデフォルト化されたコピー%select{コンストラクタ|代入演算子}0のパラメータはconstですが、メンバーまたは基底が非constである必要があります'
# "the parameter of the 'ordered' clause must be greater than or equal to the parameter of the 'collapse' clause"
H21ACD6E7D4C2: 'ordered句のパラメータはcollapse句のパラメータ以上でなければなりません'
# 'the pointee of the 2nd argument must match the element type of the 1st argument (%0 != %1)'
H13AC040EDF7B: '2番目の引数のポインティールは1番目の引数の要素型と一致しなければなりません (%0 != %1)'
# 'the pointer decremented by %0 refers before the beginning of the array'
H9FD5D86B7BD7: 'ポインタ%0減算後の位置は配列の先頭より前を指しています'
# 'the pointer incremented by %0 refers past the end of the array (that has type %1)'
H2098AEB20194: 'ポインタ%0増加後の位置は配列の末尾を越えています（配列の型は%1です）'
# 'the pointer incremented by %0 refers past the last possible element for an array in %1-bit address space containing %2-bit (%3-byte) elements (max possible %4 element%s5)'
H85FE07542C80: 'ポインタ%0増加後の位置は%1ビットアドレス空間内の要素が%2ビット（%3バイト）である配列の最後の可能性のある要素を越えています（最大%4要素%s5）'
# "the previous context %select{set|selector|property}0 '%1' used here"
H995F32331A92: "前のコンテキスト%select{set|selector|property}0 '%1'がここに使用されています"
# 'the provided selection does not overlap with the AST nodes of interest'
H10756E8D2178: '指定された選択はASTノードの対象範囲と重なりません'
# 'the referenced item is not found in any private clause on the same directive'
HBDA357C86E91: '参照された項目は同じディレクティブ内のprivate句に存在しません'
# "the result of a delegate init call must be immediately returned or assigned to 'self'"
HA6A6824B2746: "delegate init呼び出しの結果はすぐに返却または'self'に代入されなければなりません"
# 'the resulting value is always non-negative after implicit conversion'
H9908ECBF3885: '暗黙の変換後の値は常に非負です'
# "the second argument of '-fpatchable-function-entry' must be smaller than the first argument"
HEC0EC1D581E8: "オプション'-fpatchable-function-entry'の2番目の引数は1番目の引数より小さくなければなりません"
# "the selected code is not a part of a function's / method's body"
H09129ED39DF9: '選択されたコードは関数/メソッドの本体の一部ではありません'
# 'the selected expression cannot be extracted'
HC3B7DF91CF84: '選択された式は抽出できません'
# 'the selected expression is too simple to extract'
HEFB1186DBBA0: '選択された式は単純すぎて抽出できません'
# 'the semantics of this intrinsic changed with GCC version 4.4 - the newer semantics are provided here'
H1D55F6813757: 'この組み込み関数のセマンティクスはGCC 4.4で変更されました - ここでは新しいセマンティクスが提供されています'
# 'the sign of a  flushed-to-zero number is preserved in the sign of 0'
HE7436E3F21CE: 'flushed-to-zero数値の符号は、0の符号に保持されます'
# 'the specified comparator type does not provide a viable const call operator'
H327A107A2A90: '指定された比較子型には有効なconst呼び出し演算子がありません'
# 'the specified hash functor does not provide a viable const call operator'
H7B4F603F77A3: '指定されたハッシュ関数には有効なconst呼び出し演算子がありません'
# "the statement for '#pragma omp %0' must be a compound statement"
H8597FC2B3D8A: "'#pragma omp %0'のステートメントは複合文でなければなりません"
# "the statement for 'atomic capture' must be a compound statement of form '{v = x; x binop= expr;}', '{x binop= expr; v = x;}', '{v = x; x = x binop expr;}', '{v = x; x = expr binop x;}', '{x = x binop expr; v = x;}', '{x = expr binop x; v = x;}' or '{v = x; x = expr;}', '{v = x; x++;}', '{v = x; ++x;}', '{++x; v = x;}', '{x++; v = x;}', '{v = x; x--;}', '{v = x; --x;}', '{--x; v = x;}', '{x--; v = x;}' where x is an lvalue expression with scalar type"
H0E1E5BD56218: "'atomic capture'のステートメントは、xがスカラ型の左辺値式である次の形式の複合文でなければなりません：'{v = x; x binop= expr;}'、'{x binop= expr; v = x;}'、'{v = x; x = x binop expr;}'、'{v = x; x = expr binop x;}'、'{x = x binop expr; v = x;}'、'{x = expr binop x; v = x;}'、'{v = x; x = expr;}'、'{v = x; x++;}'、'{v = x; ++x;}'、'{++x; v = x;}'、'{x++; v = x;}'、'{v = x; x--;}'、'{v = x; --x;}'、'{--x; v = x;}'、'{x--; v = x;}'"
# "the statement for 'atomic capture' must be an expression statement of form 'v = ++x;', 'v = --x;', 'v = x++;', 'v = x--;', 'v = x binop= expr;', 'v = x = x binop expr' or 'v = x = expr binop x', where x and v are both lvalue expressions with scalar type"
H47D428195CE9: "'atomic capture'のステートメントは、xとvが両方スカラ型の左辺値式である次の形式の式ステートメントでなければなりません：'v = ++x;'、'v = --x;'、'v = x++;'、'v = x--;'、'v = x binop= expr;'、'v = x = x binop expr'、または'v = x = expr binop x'"
# "the statement for 'atomic compare capture' must be a compound statement of form '{v = x; cond-up-stmt}', ''{cond-up-stmt v = x;}', '{if(x == e) {x = d;} else {v = x;}}', '{r = x == e; if(r) {x = d;}}', or '{r = x == e; if(r) {x = d;} else {v = x;}}', where 'cond-update-stmt' can have one of the following forms: 'if(expr ordop x) {x = expr;}', 'if(x ordop expr) {x = expr;}', 'if(x == e) {x = d;}', or 'if(e == x) {x = d;}' where 'x', 'r', and 'v' are lvalue expressions with scalar type, 'expr', 'e', and 'd' are expressions with scalar type, and 'ordop' is one of '<' or '>'"
H09C6A6DB560B: "'atomic compare capture'のステートメントは、x、r、vがスカラ型の左辺値式、expr、e、dがスカラ型の式、ordopが'<'または'>'の次の形式の複合文でなければなりません：'{v = x; cond-up-stmt}'、'{cond-up-stmt v = x;}'、'{if(x == e) {x = d;} else {v = x;}}'、'{r = x == e; if(r) {x = d;}}'、または'{r = x == e; if(r) {x = d;} else {v = x;}}'。ここでcond-update-stmtは次のいずれかの形式：'if(expr ordop x) {x = expr;}'、'if(x ordop expr) {x = expr;}'、'if(x == e) {x = d;}'、または'if(e == x) {x = d;}'"
# "the statement for 'atomic compare' must be a compound statement of form '{x = expr ordop x ? expr : x;}', '{x = x ordop expr? expr : x;}', '{x = x == e ? d : x;}', '{x = e == x ? d : x;}', or 'if(expr ordop x) {x = expr;}', 'if(x ordop expr) {x = expr;}', 'if(x == e) {x = d;}', 'if(e == x) {x = d;}' where 'x' is an lvalue expression with scalar type, 'expr', 'e', and 'd' are expressions with scalar type, and 'ordop' is one of '<' or '>'"
H4091D9BED6D2: "'atomic compare'のステートメントは、xがスカラ型の左辺値式、expr、e、dがスカラ型の式、ordopが'<'または'>'である次の形式の複合文でなければなりません：'{x = expr ordop x ? expr : x;}'、'{x = x ordop expr ? expr : x;}'、'{x = x == e ? d : x;}'、'{x = e == x ? d : x;}'、'if(expr ordop x) {x = expr;}'、'if(x ordop expr) {x = expr;}'、'if(x == e) {x = d;}'、または'if(e == x) {x = d;}'"
# "the statement for 'atomic read' must be an expression statement of form 'v = x;', where v and x are both lvalue expressions with scalar type"
HDAD21CA5AD66: "'atomic read'のステートメントは、vとxが両方スカラ型の左辺値式である次の形式の式ステートメントでなければなりません：'v = x;'"
# "the statement for 'atomic update' must be an expression statement of form '++x;', '--x;', 'x++;', 'x--;', 'x binop= expr;', 'x = x binop expr' or 'x = expr binop x', where x is an lvalue expression with scalar type"
H106E8810ABCE: "'atomic update'のステートメントは、xがスカラ型の左辺値式である次の形式の式ステートメントでなければなりません：'++x;'、'--x;'、'x++;'、'x--;'、'x binop= expr;'、'x = x binop expr'、または'x = expr binop x'"
# "the statement for 'atomic write' must be an expression statement of form 'x = expr;', where x is a lvalue expression with scalar type"
HAEE051C701D8: "'atomic write'のステートメントは、xがスカラ型の左辺値式である次の形式の式ステートメントでなければなりません：'x = expr;'"
# "the statement for 'atomic' must be an expression statement of form '++x;', '--x;', 'x++;', 'x--;', 'x binop= expr;', 'x = x binop expr' or 'x = expr binop x', where x is an lvalue expression with scalar type"
H182C909CFBBD: "'atomic'のステートメントは、xがスカラ型の左辺値式である次の形式の式ステートメントでなければなりません：'++x;'、'--x;'、'x++;'、'x--;'、'x binop= expr;'、'x = x binop expr'、または'x = expr binop x'"
# "the target architecture '%0' is not supported by the target '%1'"
H9EB5284C09D2: "ターゲットアーキテクチャ '%0' はターゲット '%1' でサポートされていません"
# 'the total number of preprocessor source tokens (%0) exceeds the token limit (%1)'
H8A02325A6920: 'プレプロセッサのソーストークンの総数 (%0) がトークン制限 (%1) を超えています'
# 'the two-parameter std::span construction is unsafe as it can introduce mismatch between buffer size and the bound information'
HB6B2C19333E2: '2パラメータ版のstd::span構築は危険です。バッファサイズと境界情報の不一致が生じる可能性があります'
# 'the type %0 is already explicitly ownership-qualified'
H462F56962031: '型%0は高速列挙可能なオブジェクトへのポインタではありません'
# 'the type %0 is not a pointer to a fast-enumerable object'
HF043D197C95F: '型%0は速い列挙可能なオブジェクトへのポインタではありません'
# 'the type of object expression %diff{($) does not match the type being destroyed ($)|does not match the type being destroyed}0,1 in pseudo-destructor expression'
HF8245CD4DD36: '疑似デストラクタ式における破棄対象の型との一致がありません。オブジェクト式の型%diff{($0) は破棄対象の型 ($1)|と破棄対象の型}0,1が一致しません'
# 'the type of the explicit object parameter of an explicitly-defaulted %select{copy|move}0 assignment operator should be reference to %1'
H48B3F2D609BF: '明示的にデフォルト化された%select{コピー|ムーブ}0代入演算子の明示的オブジェクトパラメータの型は%1への参照でなければなりません'
# 'the user condition in the OpenMP context selector needs to be constant; %0 is not'
H518CAE3CEA63: 'OpenMPコンテキストセレクタのユーザー条件は定数でなければなりません。%0は定数ではありません'
# "the value of 'simdlen' parameter must be less than or equal to the value of the 'safelen' parameter"
H05F684C1DEC1: "'simdlen'パラメータの値は'safelen'パラメータの値以下でなければなりません"
# "the value of the size argument in 'strncat' is too large, might lead to a buffer overflow"
H7CBEE5BA8363: "'strncat'のサイズ引数の値が大きすぎます。バッファオーバーフローの可能性があります"
# "the value of the size argument to 'strncat' is wrong"
H10EE22A40549: "'strncat'のサイズ引数の値が不正です"
# 'the vecreturn attribute can only be used on a POD (plain old data) class or structure (i.e. no virtual functions)'
HB24B6E1BF839: 'vecreturn属性はPOD（古いデータ型）クラスまたは構造体（仮想関数を含まないもの）にのみ使用できます'
# 'the vecreturn attribute can only be used on a class or structure with one member, which must be a vector'
H91431B029CC5: 'vecreturn属性は単一のメンバーをもち、そのメンバーがベクタータイプである構造体またはクラスにのみ使用できます'
# "the warning option '-%0' is not supported"
H961C96696067: '警告オプション「-%0」はサポートされていません'
# 'there is no external assembler that can be used on this platform'
H36CA569B9742: 'このプラットフォームで使用できる外部アセンブラが存在しません'
# 'there is no symbol at the given location'
H99C4AECFC4C8: '指定された位置にシンボルが存在しません'
# 'this builtin is available only on AIX 7.2 and later operating systems'
H6E604B084F43: 'このビルトイン関数はAIX 7.2以降のオペレーティングシステムでのみ利用可能です'
# 'this builtin is only available on 32-bit targets'
H56D31FAC556E: 'このビルトイン関数は32ビットターゲットでのみ利用可能です'
# 'this builtin is only available on 64-bit targets'
HC0C706B2D8E7: 'このビルトイン関数は64ビットターゲットでのみ利用可能です'
# 'this builtin is only available on x86-64 and aarch64 targets'
H81BF150D8949: 'このビルトイン関数はx86-64およびaarch64ターゲットでのみ利用可能です'
# "this builtin requires 'dsp r2' ASE, please use -mdspr2"
HF59F7FBACC6E: "'dsp r2' ASEが必要です。-mdspr2オプションを使用してください"
# "this builtin requires 'dsp' ASE, please use -mdsp"
H2B317AB4FDC4: "'dsp' ASEが必要です。-mdspオプションを使用してください"
# "this builtin requires 'msa' ASE, please use -mmsa"
H25EA8026E312: "このビルトイン関数には'msa' ASEが必要です。-mmsaオプションを使用してください"
# 'this builtin requires ABI -mabi=%0'
H6643558E97E9: 'このビルトイン関数にはABI -mabi=%0が必要です'
# 'this coroutine may be split into pieces; not every piece is guaranteed to be inlined'
HEF5E3EA3F783: 'このコルーチンは分割される可能性があります。分割された各部分がインライン展開される保証はありません'
# "this declaration is not a prototype; add %select{'void'|parameter declarations}0 to make it %select{a prototype for a zero-parameter function|one}0"
HDD90A70940A7: 'この宣言はプロトタイプではありません。%select{void|パラメータ宣言}0を追加して、%select{パラメータのない関数のプロトタイプ|その宣言}0にします'
# 'this expression will be parsed as explicit(bool) in C++20'
HE2974A48FA92: 'この式はC++20ではexplicit(bool)として解析されます'
# 'this function cannot be a coroutine: %0 is an incomplete type'
HEB887A198DFF: 'この関数はコルーチンにはできません: %0は未完全な型です'
# 'this function cannot be a coroutine: %0 is not a class'
HF896DD5CD9DB: 'この関数はコルーチンにはできません: %0はクラスではありません'
# "this function cannot be a coroutine: %q0 has no member named 'promise_type'"
HAD42B5488901: "この関数はコルーチンにはできません: %q0には'promise_type'というメンバーがありません"
# 'this function cannot be a coroutine: missing definition of specialization %0'
HFC5D41C5C0FA: 'この関数はコルーチンにはできません: 特殊化%0の定義がありません'
# 'this is generally caused by modules with the same name found in multiple paths'
HB435423839CE: 'これは通常、複数のパスに同じ名前のモジュールが存在するためです'
# 'this placement new expression is not supported in constant expressions %select{|before C++2c}0'
HFED2CB8F9A5D: 'このplacement new式は定数式ではサポートされていません%select{|C++2c以前では}0'
# 'this pragma cannot appear in %0 declaration'
HCE58A657A4E9: 'この pragma は %0 の宣言内で使用できません'
# 'this style of line directive is a GNU extension'
H0B9D785486F6: 'この形式の行ディレクティブはGNU拡張機能です'
# 'this target does not support pointer authentication'
HB298CA51FDBD: 'このターゲットではポインターオーソリティケーションがサポートされていません'
# 'this type tag was not designed to be used with this function'
H6E259EADA90E: 'この型タグはこの関数と組み合わせて使用するように設計されていません'
# 'this use of statement expressions is not supported in a constant expression'
H15F3A7193C9C: 'このステートメント式の使用は定数式ではサポートされていません'
# 'this value is too large for this fixed point type'
HC641D92F0E57: 'この値はこの定点数型の範囲を超えています'
# 'this warning is no longer in use and will be removed in the next release'
H0EF268B5B2F9: 'この警告は使用されておらず、次回リリースで削除されます'
# 'thread safety beta warning'
HB0419777F950: 'スレッドセーフ性のベータ版警告'
# 'thread safety verbose warning'
H313BE85969C3: 'スレッドセーフ性の詳細警告'
# 'thread warning in function %0'
H36B44B602302: '関数 %0 内でスレッド関連の警告'
# 'thread-local declaration of %0 follows non-thread-local declaration'
HEFF70126975B: '%0 のスレッドローカル宣言は、非スレッドローカル宣言の後に続きません'
# 'thread-local declaration of %0 with %select{static|dynamic}1 initialization follows declaration with %select{dynamic|static}1 initialization'
H912C45CDB374: '%0 のスレッドローカル宣言（%select{static|dynamic}1 初期化）は、%select{dynamic|static}1 初期化を持つ宣言の後に続きません'
# 'thread-local storage is not supported for the current target'
H98D675ADC45A: '現在のターゲットではスレッドローカルストレージがサポートされていません'
# 'thread-local variable has non-trivial ownership: type is %0'
H6F11C930F55E: 'スレッドローカル変数には非自明な所有権があります: 型は %0 です'
# 'threadprivate variable with incomplete type %0'
HCB733257A55A: '型 %0 が未完了の threadprivate 変数です'
# "threadprivate variables are not allowed in '%0' clause"
HEEB356882606: "'%0' クローズ内では threadprivate 変数は許可されていません"
# 'threadprivate variables cannot be used in target constructs'
HB21F31B22998: 'ターゲット構造体内で threadprivate 変数を使用できません'
# 'three-way comparison between pointer and zero'
HD3520571E10A: 'ポインタとゼロとの三項比較'
# 'three-way comparison between vectors is not supported'
H00B5B249986A: 'ベクター間の三項比較はサポートされていません'
# "three-way comparison cannot be synthesized because there is no viable function for %select{'=='|'<'}0 comparison"
H6263B6389D1C: "three-way comparison cannot be synthesized because there is no viable function for %select{'=='|'<'}0 comparison"
# 'threshold (in percent) for selecting functions to process in lite mode. Higher threshold means fewer functions to process. E.g threshold of 90 means only top 10 percent of functions with profile will be processed.'
HC3919B9CBB6D: '(パーセント単位)の閾値。ライトモードで処理対象の関数を選ぶ際に使用されます。閾値が高くなるほど処理される関数は少なくなります。例: 90% の閾値の場合、プロファイル付き関数の上位 10% だけが処理されます。'
# 'tile arguments must refer to different tiles'
HC74F5110780C: 'タイル引数は異なるタイルを指さなければなりません'
# 'time BOLT aggregator'
H034122EC1DF6: 'BOLT アグリゲーターの時間を計測'
# 'time frame analysis steps'
H18422D3F506F: 'タイムフレーム解析ステップ'
# 'time icf steps'
H17EA53E3423A: 'ICF ステップの時間を計測'
# "timed out waiting to acquire lock file for module '%0'"
HD7ADFA168199: "モジュール '%0' のロックファイル取得にタイムアウトしました"
# 'tls_model must be "global-dynamic", "local-dynamic", "initial-exec" or "local-exec"'
H2BCDC88FA47E: 'tls_model は "global-dynamic", "local-dynamic", "initial-exec", または "local-exec" でなければなりません'
# 'to match this %0'
HDA13A5D2D868: 'この %0 に一致させるため'
# "to match this ']'"
HEF9A1EC0D665: "to match this ']'"
# "to match this '{'"
H013B6E508561: "to match this '{'"
# 'token is not a valid binary operator in a preprocessor subexpression'
H93EB0C533EDF: 'token is not a valid binary operator in a preprocessor subexpression'
# "token pasting of ',' and __VA_ARGS__ is a GNU extension"
H13889DCFA50D: "token pasting of ',' and __VA_ARGS__ is a GNU extension"
# 'too %select{few|many}0 arguments in call to %1'
H55C9E37AE906: 'too %select{few|many}0 arguments in call to %1'
# 'too %select{few|many}0 initializers in list for type %1 (expected %2 but found %3)'
HD545C2517E80: 'too %select{few|many}0 initializers in list for type %1 (expected %2 but found %3)'
# 'too %select{few|many}0 parameters in the signature specified by the %1 attribute (expected %2; got %3)'
H6F4276FDBDF1: 'too %select{few|many}0 parameters in the signature specified by the %1 attribute (expected %2; got %3)'
# 'too %select{many|few}0 type arguments for class %1 (have %2, expected %3)'
H35A08DFD5F2A: 'too %select{many|few}0 type arguments for class %1 (have %2, expected %3)'
# 'too few %select{|||execution configuration }0%select{|non-object }2arguments to %select{function|block|method|kernel function}0 call, at least argument %1 must be specified'
HF6BA10037D33: 'too few %select{|||execution configuration }0%select{|non-object }2arguments to %select{function|block|method|kernel function}0 call, at least argument %1 must be specified'
# 'too few %select{|||execution configuration }0%select{|non-object }2arguments to %select{function|block|method|kernel function}0 call, single argument %1 was not specified'
H9CA8A408A5C7: 'too few %select{|||execution configuration }0%select{|non-object }2arguments to %select{function|block|method|kernel function}0 call, single argument %1 was not specified'
# 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2'
H5939FAB31ED6: 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2'
# 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2; did you mean %4?'
HF20F679C52F2: 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2; did you mean %4?'
# 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at least %1, have %2'
HD24171A04B0B: 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at least %1, have %2'
# 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at least %1, have %2; did you mean %4?'
HD3BBC6D9EFC0: 'too few %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at least %1, have %2; did you mean %4?'
# 'too few arguments provided to function-like macro invocation'
H1E346A7B8B3C: 'too few arguments provided to function-like macro invocation'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2'
H90F884ECB318: 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2; did you mean %4?'
HCA745DFE1FDF: 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2; did you mean %4?'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at most %1, have %2'
H94A2619722A2: 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at most %1, have %2'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at most %1, have %2; did you mean %4?'
HE9A38EF19888: 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected at most %1, have %2; did you mean %4?'
# 'too many %select{|||execution configuration }0%select{|non-object }3arguments to %select{function|block|method|kernel function}0 call, expected single argument %1, have %2 arguments'
HDBD2C1E2CE61: '%select{|||実行構成 }0%select{|非オブジェクト }3引数が%select{関数|ブロック|メソッド|カーネル関数}0の呼び出しに渡りすぎです。期待される引数は%1の1つですが、%2個の引数があります'
# 'too many %select{|||execution configuration }0arguments to %select{function|block|method|kernel function}0 call, expected at most single %select{|non-object }3argument %1, have %2%select{|non-object}3 arguments'
HDAC13624D426: '%select{|||実行構成 }0引数が%select{関数|ブロック|メソッド|カーネル関数}0の呼び出しに渡りすぎです。最大1つの%select{|非オブジェクト }3引数%1を期待していましたが、%2%select{|非オブジェクト}3の引数があります'
# 'too many arguments provided to function-like macro invocation'
HBB5E8EFBFD08: '関数風マクロの呼び出しに渡された引数が多すぎます'
# 'too many braces around %select{scalar |}0initializer'
H5C95D607138A: '%select{スカラ |}0初期化子の周りに多くの波括弧があります'
# 'too many errors emitted, stopping now'
H208E3BCCF078: '発行されたエラーが多すぎます。処理を終了します'
# 'too many function parameters; subsequent parameters will be ignored'
H803517A338E0: '関数のパラメータが多すぎます。以降のパラメータは無視されます'
# "too many parameters (%0) for 'main': must be 0, 2, or 3"
H39E16B39631F: "'main'のパラメータが多すぎます (%0) : 0、2、または3でなければなりません"
# 'tool-template options'
HBCF3F3069BB4: 'ツールテンプレート オプション'
# 'top-level comma expression in array subscript is deprecated in C++20 and unsupported in C++23'
HE89EE6B0F334: '配列サブスクリプトのトップレベルのカンマ式はC++20で非推奨、C++23ではサポートされません'
# 'total number of threads cannot exceed %0'
H1884DB567221: 'スレッドの総数は%0を超えることはできません'
# 'total token limit set here'
HC6BF74A3FD57: 'ここで設定されたトークンの総数制限'
# 'toy compiler\n'
H2EDD43662B08: 'トイ コンパイラ\n'
# 'trailing requires clause can only be used when declaring a function'
H084306C3877A: 'トレーリング requires節は関数を宣言する際にのみ使用できます'
# 'trailing requires clause should be placed outside parentheses'
H548F58E8723A: 'トレーリング requires節は括弧の外に配置する必要があります'
# 'trailing return type may not be nested within parentheses'
HC76578BE367C: 'トレーリング戻り値型は括弧内でネストすることはできません'
# 'trailing return type must appear before trailing requires clause'
HA5D12CC5013B: 'トレーリング戻り値型はトレーリング requires節の前に表示されなければなりません'
# 'trailing return types are incompatible with C++98'
H32DC951D7875: 'トレーリング戻り値型はC++98と互換性ありません'
# 'translate addresses using BAT'
HDDEE1DC9B85A: 'BATを使用してアドレスを変換'
# 'translation unit contains multiple module declarations'
HF895A4F45EF2: '翻訳単位には複数のモジュール宣言が含まれています'
# 'translation unit is too large for Clang to process: ran out of source locations'
H8B3695BCDB65: 'Clangが処理できる範囲を超える大きさの翻訳単位: ソース位置が不足しました'
# 'transparent union definition must contain at least one field; transparent_union attribute ignored'
H140F1B74DF83: 'transparent union定義には少なくとも1つのフィールドが必要です；transparent_union属性は無視されました'
# 'transparent_union attribute can only be applied to a union definition; attribute ignored'
HD786E3576B74: 'transparent_union属性はユニオン定義にのみ適用可能です；属性は無視されました'
# 'trap on failure'
H4518B36E2611: '失敗時のトラップ'
# 'treat the string as an argument to avoid this'
H276A4BE7C44E: 'このエラーを避けるには文字列を引数として扱ってください'
# "treating #%select{include|import|include_next|__include_macros}0 as an import of module '%1'"
HCF878B660176: "#%select{include|import|include_next|__include_macros}0をモジュール'%1'のインポートとして扱っています"
# "treating '%0' input as '%1' when in C++ mode, this behavior is deprecated"
H0FA024F7C782: "C++モードで'%0'入力を'%1'として扱っていますが、この動作は非推奨です"
# 'treating Ctrl-Z as end-of-file is a Microsoft extension'
H2B9F3B693225: 'Ctrl-ZをEOF（終端）として扱うのはMicrosoftの拡張機能です'
# "treating Unicode character <U+%0> as an identifier character rather than as '%1' symbol"
H50914464E633: "ユニコード文字<U+%0>を識別子文字として扱い、'%1'記号と見なさないようにしました"
# 'treating Unicode character as whitespace'
HF7B2E2527DE4: 'ユニコード文字を空白として扱っています'
# "trigraph converted to '%0' character"
HED476D72F781: "トリグラフが'%0'文字に変換されました"
# 'trigraph ends block comment'
H52594FE74E90: 'トリグラフがブロックコメントを終了しました'
# 'trigraph ignored'
H1C535A7D3139: 'トリグラフが無視されました'
# 'trust the input to be from a well-formed source'
H9D6FAC2CFAB6: '入力が適切なソースから来ていると信頼してください'
# "try 'match(%0={%1%2})'"
H766B462800CF: "'%0={%1%2}'をmatch()内で試してください"
# 'try to preserve basic block alignment'
H8B07C548FF85: '基本ブロックのアライメントを保持するように試してください'
# 'trying to recursively use %0 as superclass of %1'
H22C1DF007CBE: '%0を%1のスーパークラスとして再帰的に使用しようとしています'
# 'turn on the stoke analysis'
H0C2490B9B2A0: 'ストーク解析を有効にする'
# 'type %0 can only be used as a function parameter in OpenCL'
H43CCACC05DF1: 'OpenCLでは%0型は関数パラメータとしてのみ使用できます'
# 'type %0 cannot be decomposed'
HAD575CEF4CDD: '型 %0 は分解できません'
# 'type %0 cannot be narrowed to %1 in initializer list'
HA66630D471E5: '初期化子リストで型 %0 を %1 に狭めることはできません'
# 'type %0 cannot be narrowed to %1 in initializer list in C++11'
H121C0CF66257: 'C++11の初期化子リストで型 %0 を %1 に狭めることはできません'
# "type %0 cannot be used prior to '::' because it has no members"
HB29A2AE6A5EB: '型 %0 は :: の前に使用できません。その型にはメンバーがありません'
# 'type %0 decomposes into %3 %plural{1:element|:elements}2, but %select{%plural{0:no|:only %1}1|%1}4 %plural{1:name was|:names were}1 provided'
HF59CA2FD696F: '型 %0 は %3 %plural{1:要素|:要素}2 に分解されますが、%select{%plural{0:名前がありません|:のみ %1}1|%1}4 %plural{1:名前が指定されました|:名前が指定されました}1'
# 'type %0 does not provide a %select{subscript|call}1 operator'
HCAF6714D32F7: '型 %0 は %select{添字演算子|呼び出し演算子}1 を提供しません'
# 'type %0 found by destructor name lookup'
H35BD375D3364: '破壊子名の検索により型 %0 が見つかりました'
# 'type %0 has incompatible definitions in different translation units'
HB192C667507F: '異なる翻訳単位で型 %0 の定義が互換性ありません'
# 'type %0 has unexpected layout'
H8C8909F11F0A: '型 %0 のレイアウトが予期されていません'
# 'type %0 in generic association compatible with previously specified type %1'
H1178A958ED5C: '汎用結合における型 %0 は、以前に指定された型 %1 と互換性があります'
# 'type %0 in generic association is a variably modified type'
HCA8F3A82743E: '汎用結合における型 %0 は可変修飾型です'
# 'type %0 in generic association not an object type'
H9CBDAFFFD0D2: '汎用結合における型 %0 はオブジェクト型ではありません'
# 'type %0 is incomplete'
H68C687943CFB: '型 %0 は未完全型です'
# 'type %0 is not a direct or virtual base of %1'
HA6EFF9DEE3C5: '型 %0 は %1 の直接的または仮想ベースではありません'
# 'type %0 is not trivially copyable and not guaranteed to be mapped correctly'
HA6A4CD2AE815: '型 %0 は単純にコピー可能ではなく、正しくマッピングされる保証はありません'
# 'type %0 of function parameter pack does not contain any unexpanded parameter packs'
H5D64B61067E5: '関数パラメータパックの型 %0 には未展開のパラメータパックが含まれていません'
# 'type %0 of non-type template parameter is not a structural type'
H546F4F02218C: '非型テンプレートパラメータの型 %0 は構造的型ではありません'
# 'type %0 requires %1 bytes of alignment and the default allocator only guarantees %2 bytes'
H82A5F7C1A758: '型 %0 は %1 バイトのアライメントが必要ですが、デフォルトのアロケータは %2 バイトのみを保証します'
# 'type %2 of %select{explicit instantiation|explicit specialization|partial specialization|redeclaration}0 of %1 does not match expected type %3'
H34154FB5D28F: '%select{明示的なインスタンチエーション|明示的な特殊化|部分的な特殊化|再宣言}0 の %1 の型 %2 は期待された型 %3 と一致しません'
# "type argument %0 cannot be qualified with '%1'"
HF21B2C8937B4: "型引数 %0 は '%1' で修飾できません"
# 'type argument %0 cannot explicitly specify nullability'
H1330164CF91E: '型引数%0は明示的にnullabilityを指定できません'
# 'type argument %0 does not satisfy the bound (%1) of type parameter %2'
H3669CF5C9A7D: '型引数%0は型パラメータ%2の制約(%1)を満たしません'
# 'type argument %0 is neither an Objective-C object nor a block type'
HC89732C094A1: '型引数%0はObjective-Cオブジェクトでもブロック型でもありません'
# "type argument %0 must be a pointer (requires a '*')"
HF674997DE917: '型引数%0はポインタでなければなりません（"*"が必要です）'
# 'type argument of iboutletcollection attribute cannot be a builtin type'
H26C24AC03DB8: 'iboutletcollection属性の型引数は組み込み型を指定できません'
# 'type arguments cannot be applied to already-specialized class type %0'
H67EB09767F26: '型引数はすでに特殊化されたクラス型%0には適用できません'
# 'type arguments cannot be applied to non-class type %0'
H41CCF55FF38B: '型引数はクラス型でない%0には適用できません'
# 'type arguments cannot be applied to non-parameterized class %0'
HC40C2F44A862: '型引数はパラメータ化されていないクラス%0には適用できません'
# 'type bound %0 for type parameter %1 conflicts with %select{implicit|previous}2 bound %3%select{for type parameter %5|}4'
H7F10FC1165B9: '型パラメータ%1の型制約%0は%select{暗黙の|前の}2制約%3%select{型パラメータ%5に対して|}4と矛盾しています'
# 'type bound %0 for type parameter %1 is not an Objective-C pointer type'
H80B67C4F94CD: '型パラメータ%1の型制約%0はObjective-Cポインタ型ではありません'
# "type bound %1 for type parameter %0 cannot be qualified with '%2'"
H3CC7E562DE4D: '型パラメータ%0の型制約%1には"%2"を修飾できません'
# 'type constraint differs in template redeclaration'
HA94E71A6CC7A: 'テンプレートの再宣言で型制約が異なっています'
# 'type conversion function declared here'
H7B0CCA1F5818: 'ここで型変換関数が宣言されています'
# 'type declaration hidden'
H161A31411076: '型宣言が隠蔽されています'
# 'type definition in a constexpr %select{function|constructor}0 is a C++14 extension'
HB61A32D40D4A: 'constexpr %select{関数|コンストラクタ}0内の型定義はC++14の拡張機能です'
# 'type definition in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14'
H51291DDF6B58: 'constexpr %select{関数|コンストラクタ}0内の型定義はC++14以前の標準と互換性ありません'
# 'type inference of a declaration other than a plain identifier with optional trailing attributes is a Clang extension'
HB4EF9FC7F52F: '単純な識別子以外（オプションの末尾属性を含む）の宣言の型推論はClangの拡張機能です'
# 'type is given name %0 for linkage purposes by this %select{typedef|alias}1 declaration'
HFEABA5A13E20: 'この%select{typedef|エイリアス}1宣言により、型にはリンクリンクのための名前%0が与えられています'
# 'type is not C-compatible due to this %select{base class|default member initializer|lambda expression|friend declaration|member declaration}0'
H8BEB926AC2A7: 'この%select{基底クラス|デフォルトのメンバ初期化子|ラムダ式|フレンド宣言|メンバ宣言}0のため、型はCと互換性ありません'
# 'type name does not allow %select{<ERROR>|constexpr|consteval|constinit}0 specifier to be specified'
H2BAC4BD9B411: '型名では %select{<ERROR>|constexpr|consteval|constinit}0 修飾子を指定できません'
# 'type name does not allow function specifier to be specified'
H63933758FA41: '型名では関数修飾子を指定できません'
# 'type name does not allow storage class to be specified'
HD221C2943356: '型名ではストレージクラスを指定できません'
# 'type name requires a specifier or qualifier'
H9BCBB335F47F: '型名には修飾子または指定子が必要です'
# 'type nullability specifier %0 is a Clang extension'
HFDBD8198839C: '型の nullability 修飾子 %0 は Clang の拡張機能です'
# 'type of %ordinal0 parameter of local declaration does not match definition%diff{ ($ vs $)|}1,2'
HC35F751A0E20: 'ローカル宣言の %ordinal0 番目のパラメータの型は定義と一致しません%diff{ ($ vs $)|}1,2'
# 'type of %ordinal0 parameter of member declaration does not match definition%diff{ ($ vs $)|}1,2'
H6D265791AD7D: 'メンバー宣言の %ordinal0 番目のパラメータの型は定義と一致しません%diff{ ($ vs $)|}1,2'
# 'type of UTF-8 string literal will change from array of char to array of char8_t in C23'
HDD96729D3F80: 'C23 で UTF-8 文字列リテラルの型は char 配列から char8_t 配列に変更されます'
# 'type of UTF-8 string literal will change from array of const char to array of const char8_t in C++20'
H2FF4EC88FBDF: 'C++20 で UTF-8 文字列リテラルの型は const char 配列から const char8_t 配列に変更されます'
# 'type of machine mode does not match type of base type'
HCC37C6223BD0: 'マシンモードの型と基底型の型が一致しません'
# 'type of machine mode does not support base vector types'
HC82FE5FB775E: '基底ベクタータイプにはこのマシンモードが使用できません'
# 'type of property %0 (%1) does not match type of accessor %2 (%3)'
H588E7AE2B664: 'プロパティ %0 (%1) の型はアクセサ %2 (%3) の型と一致しません'
# 'type of property %0 (%1) does not match type of instance variable %2 (%3)'
H73BAE4F8734B: 'プロパティ %0 (%1) の型はインスタンス変数 %2 (%3) の型と一致しません'
# 'type of property %0 does not match type of accessor %1'
H270F876040C0: 'プロパティ %0 の型はアクセサ %1 の型と一致しません'
# 'type of property %0 in class extension does not match property type in primary class'
H132F7594C298: 'クラス拡張におけるプロパティ %0 の型はプライマリクラスのプロパティ型と一致しません'
# 'type of setter must be void'
HD41AE4C60492: 'セッタの戻り値型は void でなければなりません'
# 'type of specialized non-type template argument depends on a template parameter of the partial specialization'
HBDE8FF32FC3A: '部分専用化のテンプレートパラメータに依存する特殊化された非型テンプレート引数の型'
# 'type of thread-local variable has non-trivial destruction'
H8E6776B80F65: 'スレッド局所変数の型は非単純な破棄を伴います'
# "type operand %0 of 'typeid' cannot have '%1' qualifier"
HBE87B8BABE8E: "'typeid' の型オペランド %0 には '%1' 修飾子を付けることはできません"
# 'type parameter %0 bound %1 cannot explicitly specify nullability'
H73C9FD2AB78B: '型パラメータ%0の制約%1は明示的にnull性を指定できません'
# 'type parameter %0 declared here'
HFF5B8C2A68FC: '型パラメータ%0はここに宣言されています'
# "type specifier missing, defaults to 'int'"
H4B268E82A57A: "型指定子が省略されています。デフォルトでは'int'になります"
# "type specifier missing, defaults to 'int'; ISO C99 and later do not support implicit int"
H8CEE1B0F6CB9: "型指定子が省略されています。デフォルトでは'int'になります；ISO C99以降では暗黙の'int'はサポートされていません"
# 'type trait requires %0%select{| or more}1 argument%select{|s}2; have %3 argument%s3'
H5F2DEBC2DD6F: '型特性は%0%select{またはそれ以上の|}1引数%select{が必要です|}2; %3引数%s3が指定されています'
# 'type was declared read-only here'
HAFE8C580C1C1: 'この型はここに読み取り専用として宣言されています'
# 'type-id cannot have a name'
H0F4A38BF6BC0: 'type-idには名前を指定できません'
# 'type-less parameter names in function declaration'
H4275A67CD2BD: '関数宣言における型なしパラメータの名前'
# 'typedef declarator cannot be qualified'
H13CBEB4EC130: 'typedef宣言子は修飾できません'
# 'typedef member %0 cannot be a bit-field'
HF1C17DDE556A: 'typedefメンバー%0はビットフィールドにできません'
# 'typedef name must be an identifier'
H0FF9C8135AE0: 'typedef名は識別子でなければなりません'
# 'typedef requires a name'
HD4A732841C3B: 'typedefには名前が必要です'
# 'typeid applied to expression of polymorphic type %0 is not allowed in a constant expression in C++ standards before C++20'
H56E5AEAEB4DB: 'C++20以前のC++規格では、多相型%0の式に対してtypeidを定数式内で使用することはできません'
# 'typeid will not work since RTTI data is disabled by %select{-fno-rtti-data|/GR-}0'
H44DAF1F1B628: 'RTTIデータが%select{-fno-rtti-data|/GR-}0によって無効化されているため、typeidは機能しません'
# 'typename is allowed for identifiers only'
HEE2C4836DC27: 'typenameは識別子のみに使用できます'
# 'typename specifier refers to %select{class template|function template|variable template|alias template|template template parameter|template}0 member in %1; argument deduction not allowed here'
H15F65651B175: 'typename指定子は%1の%select{クラステンプレート|関数テンプレート|変数テンプレート|エイリアステンプレート|テンプレートテンプレートパラメータ|テンプレート}0メンバを指します; この場所では引数の推論は許可されていません'
# 'typename specifier refers to %select{class template|function template|variable template|alias template|template template parameter|template}0; argument deduction not allowed here'
HDDA5FA8262A7: 'typename指定子は%select{クラステンプレート|関数テンプレート|変数テンプレート|エイリアステンプレート|テンプレートテンプレートパラメータ|テンプレート}0を指します; この場所では引数の推論は許可されていません'
# 'typename specifier refers to a dependent using declaration for a value %0 in %1'
HA4640204C28B: 'typename指定子は%1内の値%0に対する依存using宣言を指します'
# 'typename specifier refers to a non-type template'
HDA01E7DE1981: 'typename指定子は非型テンプレートを指しています'
# 'typename specifier refers to non-type %0'
H68FFAB15F6B4: 'typename指定子は非型%0を指しています'
# 'typename specifier refers to non-type member %0 in %1'
HAD3AB5D3DF5D: 'typename 指定子は、%1 の非型メンバー %0 を参照しています'
# 'types cannot be declared in an anonymous %select{struct|union}0'
HB8A6E3596B04: '匿名の%select{struct|union}0内で型を宣言することはできません'
# 'types declared in an anonymous %select{struct|union}0 are a Microsoft extension'
H10CD33288972: '匿名の%select{struct|union}0内の型宣言はMicrosoft拡張機能です'
# 'types may not be defined in a for range declaration'
HA0579AB1E4A8: 'forループ宣言内で型を定義することはできません'
# "types with 'sycl_special_class' attribute must have one and only one '__init' method defined"
H49F85977919C: "'sycl_special_class'属性を持つ型は__initメソッドを1つだけ定義する必要があります"
# "umbrella directory '%0' not found"
H7F60E99942C1: "アンバレラディレクトリ '%0' が見つかりません"
# "umbrella for module '%0' already covers this directory"
HAE8DEE1E4013: "モジュール '%0' のアンバレラはこのディレクトリを既にカバーしています"
# "umbrella header for module '%0' does not include header '%1'"
H803B3F536D5A: "モジュール '%0' のアンバレラヘッダはヘッダ '%1' を含んでいません"
# "unable to create target: '%0'"
H48D73D54C838: "ターゲットを作成できませんでした: '%0'"
# 'unable to execute command: %0'
H1274C3267D8B: 'コマンドの実行に失敗しました: %0'
# "unable to find %0 directory, expected to be in '%1' found via %2"
HFA08DE02A86A: "指定の%0ディレクトリが見つかりませんでした。'%1'が存在しませんでした (%2 経由で検索)"
# "unable to find %select{'::operator new(size_t, nothrow_t)'|'::operator new(size_t, align_val_t, nothrow_t)'}1 for %0"
HD53B43D38AB3: "'%0' 用の%select{'::operator new(size_t, nothrow_t)'|'::operator new(size_t, align_val_t, nothrow_t)'}1が見つかりません"
# 'unable to find a Visual Studio installation; try running Clang from a developer command prompt'
HD5A60BEBFC34: 'Visual Studioのインストールが見つかりません；開発者コマンドプロンプトからClangを実行してください'
# "unable to find module '%0'"
H4F4B8FBAA599: "モジュール '%0' が見つかりません"
# "unable to find plugin '%0'"
H694242203542: "プラグイン '%0' が見つかりません"
# "unable to handle compilation, expected exactly one compiler job in '%0'"
H0ED90FBA3001: "'%0' 内に正確に1つのコンパイラジョブが存在することを期待しましたが処理できません"
# 'unable to interface with target machine'
H48913BEFE8AE: 'ターゲットマシンとの接続に失敗しました'
# 'unable to load PCH file'
H0C8F5802F259: '前処理済みヘッダファイル(PCH)をロードできませんでした'
# "unable to load basic block sections function list: '%0'"
H3C61D53F0989: "関数リストをロードできませんでした: '%0' のbasic block sections"
# "unable to load plugin '%0': '%1'"
HEABDF34863F0: "プラグイン '%0' をロードできませんでした: '%1'"
# 'unable to make temporary file: %0'
HB69A4D68B994: "一時ファイル '%0' の作成に失敗しました"
# "unable to merge a subprocess's serialized diagnostics"
H0736A846C8D2: 'サブプロセスのシリアル化診断をマージできませんでした'
# 'unable to open CC_LOG_DIAGNOSTICS file: %0 (using stderr)'
H5386FA1E767C: "CC_LOG_DIAGNOSTICS ファイル '%0' を開けませんでした (stderr を使用します)"
# 'unable to open CC_PRINT_HEADERS file: %0 (using stderr)'
H9ABA30151CEC: "CC_PRINT_HEADERS ファイル '%0' を開けませんでした (stderr を使用します)"
# 'unable to open CC_PRINT_OPTIONS file: %0'
HEA741366E890: "CC_PRINT_OPTIONS ファイル '%0' を開けませんでした"
# 'unable to open file %0 for serializing diagnostics (%1)'
HD09A684B5E47: "診断のシリアル化用ファイル '%0' を開けませんでした (%1)"
# "unable to open output file '%0': '%1'"
H1FD155FFBE98: "出力ファイル '%0' を開けませんでした: '%1'"
# "unable to open statistics output file '%0': '%1'"
HDC9884A86150: "統計出力ファイル '%0' を開けませんでした: '%1'"
# 'unable to overwrite file %0: %1'
HF040F371E4DB: 'ファイル %0 を上書きできませんでした: %1'
# 'unable to protect inline asm that clobbers stack pointer against stack clash'
H57F37138A9DF: 'スタック衝突からスタックポインタを破壊するインラインアセンブリを保護できませんでした'
# "unable to read PCH file %0: '%1'"
H53BCE7FDE626: "PCH ファイル %0 を読み込めませんでした: '%1'"
# 'unable to remove file: %0'
HA87F741C0BFD: 'ファイル %0 を削除できませんでした'
# "unable to rename temporary '%0' to output file '%1': '%2'"
H621AA5D0DBAB: "一時ファイル '%0' を出力ファイル '%1' にリネームできませんでした: '%2'"
# 'unable to resolve declare reduction construct for type %0'
H4CBC0B2EAEEC: '型 %0 の declare reduction 構造を解決できませんでした'
# 'unable to set working directory: %0'
H1915AC32A7BB: '作業ディレクトリを設定できませんでした: %0'
# 'unannotated fall-through between switch labels'
HD2F0C0FDF581: 'switch ラベル間のアンノテーションなしの fall-through'
# 'unannotated fall-through between switch labels in partly-annotated function'
H8BA6FF77BB8B: '部分的にアノテーションされた関数内の switch ラベル間のアンノテーションなしの fall-through'
# "unary fold expression has empty expansion for operator '%0' with no fallback value"
HE62A3703EA3A: "一元fold式のオペレーター '%0' に対して展開が空で、fallback値がありません"
# 'unary operator not supported, only increment and decrement operations permitted'
HCFDDCEAA7D4F: '一元オペレーターはサポートされていません。インクリメントとデクリメント操作のみが許可されます'
# 'undeclared identifier %0 in destructor name'
H9E161BF60045: 'デストラクタ名での未宣言の識別子 %0'
# 'undeclared selector %0'
H76DFE4FB888F: '未宣言のセレクタ %0'
# 'undeclared selector %0; did you mean %1?'
HFF50CB7951F9: '未宣言のセレクタ %0；%1 の意図ではなかったでしょうか？'
# "undeclared variable %0 used as an argument for '#pragma unused'"
H1A926D40EA78: '#pragma unused の引数として使用された未宣言の変数 %0'
# 'undef all system defines'
H5E817AACEB7A: 'すべてのシステム定義を undef にする'
# 'undefining builtin macro'
H855B9F8C6AE6: 'ビルトインマクロの undef はできません'
# 'under -fcoro-aligned-allocation, the non-aligned allocation function for the promise type %0 has higher precedence than the global aligned allocation function'
H677A6074184D: '-fcoro-aligned-allocation で、プロミス型 %0 の非アライメント確保関数がグローバルなアライメント確保関数よりも優先されます'
# 'underaligned exception object thrown'
H67F3421C41BE: 'アンダライメントされた例外オブジェクトがスローされました'
# "unelaborated friend declaration is a C++11 extension; specify '%select{struct|interface|union|class|enum}0' to befriend %1"
H85486A35A143: "非詳細な友好的宣言はC++11の拡張機能です；%1 に友達にするには '%select{struct|interface|union|class|enum}0' を指定してください"
# 'unexpected %0 in function call; perhaps remove the %0?'
HF91D5DDAC941: '関数呼び出しで予期しない %0 が検出されました；%0 を削除するべきではありませんか？'
# "unexpected %0, expected to see one of %select{|'best_case', 'full_generality', }1'single_inheritance', 'multiple_inheritance', or 'virtual_inheritance'"
H715E4C7A8362: "予期しない %0；%select{|'best_case', 'full_generality', }1'single_inheritance', 'multiple_inheritance', または 'virtual_inheritance' のいずれかが必要です"
# "unexpected '#pragma acc ...' in program"
H1E1E01704393: "プログラム内に予期しない '#pragma acc ...' があります"
# "unexpected '#pragma omp ...' in program"
H46D7021997C2: "プログラム内に予期しない '#pragma omp ...' があります"
# "unexpected '%0' clause, '%1' is specified already"
H5B200478E6AE: "予期しない '%0' クローズ；'%1' は既に指定されています"
# "unexpected '%0' clause, only %select{'device_type'|'enter' or 'link'|'enter', 'link' or 'device_type'|'device_type', 'indirect'|'enter', 'link', 'device_type' or 'indirect'}1 clauses expected"
H3763BE9D9C9F: "予期しない '%0' クローズ；%select{'device_type'|'enter' または 'link'|'enter', 'link' または 'device_type'|'device_type', 'indirect'|'enter', 'link', 'device_type' または 'indirect'}1 クローズのみが許可されています"
# "unexpected '%0' clause, only %select{'device_type'|'to' or 'link'|'to', 'link' or 'device_type'|'device_type', 'indirect'|'to', 'link', 'device_type' or 'indirect'}1 clauses expected"
H1A9F6651CC12: "予期しない '%0' クローズ；%select{'device_type'|'to' または 'link'|'to', 'link' または 'device_type'|'device_type', 'indirect'|'to', 'link', 'device_type' または 'indirect'}1 クローズのみが許可されています"
# "unexpected '(', only 'to', 'link' or 'device_type' clauses expected for 'begin declare target' directive"
H5361030EF185: "'begin declare target' ディレクティブのためには 'to', 'link' または 'device_type' クローズのみが許可されますが、'(' が検出されました"
# "unexpected ':' in nested name specifier; did you mean '::'?"
HC8B611B07937: "ネストした名前指定子中の予期しない ':'； '::' を意図したのではないでしょうか？"
# "unexpected ';' before %0"
H257D20769B88: "%0 の前に予期しない ';' が検出されました"
# "unexpected '@' in member specification"
HFD6F988E847A: "メンバー仕様内の予期しない '@'"
# "unexpected '@' in program"
H0E6C2D976254: "プログラム中に予期しない '@' が検出されました"
# "unexpected 'enter' clause, use 'to' instead"
H005905027939: "予期しない 'enter' クローズです。代わりに 'to' を使用してください"
# "unexpected 'execution' modifier in non-executable context"
HA6BB9CA468FA: "実行不可能な文脈で予期しない 'execution' モディファイアが検出されました"
# "unexpected 'to' clause, use 'enter' instead"
H48CD21AE4031: "予期しない 'to' クローズです。代わりに 'enter' を使用してください"
# "unexpected OpenACC directive %select{|'#pragma acc %1'}0"
H996256861627: "予期しない OpenACC ディレクティブ %select{|'#pragma acc %1'}0"
# "unexpected OpenMP clause '%0' in directive '#pragma omp %1'"
H1C5752C27ACF: "ディレクティブ '#pragma omp %1' 内で予期しない OpenMP クローズ '%0' が検出されました"
# "unexpected OpenMP directive %select{|'#pragma omp %1'}0"
HEF8086A19118: "予期しない OpenMP ディレクティブ %select{|'#pragma omp %1'}0"
# "unexpected argument '%0' to '#pragma %1'%select{|; expected %3}2"
HB8C385DE07A5: "'#pragma %1' の引数 '%0' が予期しませんでした%select{|; %3 が期待されます}2"
# "unexpected argument '%0' to '#pragma clang attribute'; expected 'push' or 'pop'"
H3133E5143B09: "'#pragma clang attribute' の引数 '%0' が予期しませんでした。'push' または 'pop' を指定してください"
# "unexpected argument '%0' to '#pragma clang fp %1'; expected %select{'fast' or 'on' or 'off'|'on' or 'off'|'on' or 'off'|'ignore', 'maytrap' or 'strict'|'source', 'double' or 'extended'}2"
H371571C43BD4: "'#pragma clang fp %1' の引数 '%0' が予期しませんでした。%select{'fast' または 'on' または 'off'|'on' または 'off'|'on' または 'off'|'ignore', 'maytrap' または 'strict'|'source', 'double' または 'extended'}2 を指定してください"
# "unexpected argument '%0' to '#pragma clang optimize'; expected 'on' or 'off'"
H1485FAA86056: "'#pragma clang optimize' の引数 '%0' が予期しませんでした。'on' または 'off' を指定してください"
# 'unexpected argument to debug command'
H3827CC068DE1: 'デバッグ コマンドへの予期しない引数'
# 'unexpected character <U+%0>'
H5B9099D7894E: '予期しない文字 <U+%0> が検出されました'
# "unexpected clause after an implicit 'enter' clause"
H3710E8F80D5B: "暗黙の 'enter' クローズの後に予期しないクローズが検出されました"
# "unexpected clause after an implicit 'to' clause"
H2010F6D7C809: "暗黙の 'to' クローズの後に予期しないクローズが検出されました"
# "unexpected debug command '%0'"
H8054F9A13F94: "予期しないデバッグ コマンド '%0' が検出されました"
# 'unexpected end of default argument expression'
H2637B90369AC: 'デフォルト引数式の予期しない終了'
# 'unexpected end of exception specification'
HE58D2A2E3875: '例外指定子の予期しない終了'
# 'unexpected expression: number of expressions is larger than the number of associated loops'
H7A04530C8247: '予期しない式: 式の数が関連するループの数よりも多い'
# "unexpected extra argument '%0' to '#pragma clang optimize'"
HD169A0238D64: "'#pragma clang optimize' への予期しない追加引数 '%0'"
# 'unexpected extra tokens at end of @import declaration'
HC94D2D8555A6: '@import宣言の末尾に予期しない追加トークンがあります'
# 'unexpected interface name %0: expected expression'
HD34771026F11: '予期しないインターフェース名%0: 式が予期されています'
# 'unexpected namespace name %0: expected expression'
HD2F7F8269F1D: '予期しないネームスペース名%0: 式が予期されています'
# 'unexpected namespace scope prior to decltype'
H276642EE3F52: 'decltype前に予期しないネームスペースのスコープがあります'
# "unexpected operation specified in 'append_args' clause, expected 'interop'"
H7343FC2DA837: "'append_args'句で予期しない操作が指定されました。interopが予期されます"
# "unexpected output symbol graph '%1'; please provide '--symbol-graph-dir=<directory>' instead"
H16E9C665ACBA: "予期しない出力シンボルグラフ'%1'; 代わりに'--symbol-graph-dir=<ディレクトリ>'をご提供ください"
# "unexpected parameter '%0' in availability attribute, not permitted in %select{HLSL|C/C++}1"
H3A2F294B2383: "availability属性の予期しないパラメータ'%0'; %select{HLSL|C/C++}1では許可されていません"
# 'unexpected token after Objective-C string'
H279452517A7B: 'Objective-C文字列後の予期しないトークン'
# 'unexpected token in pragma diagnostic'
HF7F8BD94B55D: 'pragma diagnostic中の予期しないトークン'
# 'unexpected type name %0: expected expression'
H5096D6005D2D: '予期しない型名%0: 式が予期されます'
# 'unexpected type name %0: expected identifier'
HECE4BA85049C: '予期しない型名%0: 識別子が予期されます'
# "unexpected value; use 'true' or 'false'"
HBC54A5A54D19: '予期しない値です。"true"または"false"を使用してください'
# 'unguarded header; consider using #ifdef guards or #pragma once'
H1B291D4D56CA: '保護されていないヘッダーファイルです。#ifdefガードまたは#pragma onceを使用するか検討してください'
# 'unicode literals are incompatible with C standards before C23'
H7CE9D5273D56: 'C23以前のC規格ではUnicodeリテラルは互換性がありません'
# 'unicode literals are incompatible with C++ standards before C++17'
H41D963C4F029: 'C++17以前のC++規格ではUnicodeリテラルは互換性がありません'
# 'unicode literals are incompatible with C++98'
H63FE9D503E73: 'C++98ではUnicodeリテラルは互換性がありません'
# 'unicode literals are incompatible with C99'
H413288F05A72: 'C99ではUnicodeリテラルは互換性がありません'
# 'unimplemented constexpr lambda feature: %0 (coming soon!)'
H49A46ED86D09: '未実装のconstexprラムダ機能:%0 (近日実装予定！)'
# 'unimplemented pure virtual method %0 in %1'
H6BCBAEFB56A1: '%1内の未実装の純粋仮想メソッド%0'
# 'uninitialized reference member is here'
HD2F77230D93D: '初期化されていないリファレンスメンバがここにあります'
# 'uninitialized variable in a constexpr %select{function|constructor}0 is a C++20 extension'
HD0E4F93C0D47: 'constexpr %select{関数|コンストラクタ}0 内で初期化されていない変数はC++20拡張機能です'
# 'uninitialized variable in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++20'
HB023F58DC7FA: 'C++20以前の標準では、constexpr %select{関数|コンストラクタ}0 内の初期化されていない変数は互換性ありません'
# 'union member %0 has reference type %1'
H0725C5FA90A3: 'ユニオンのメンバ %0 は参照型 %1 を持っています'
# 'union member %0 has reference type %1, which is a Microsoft extension'
H717E84EDF789: 'ユニオンのメンバ %0 は参照型 %1 を持っています。これはMicrosoftの拡張機能です'
# 'unions cannot be base classes'
H3537D21C3F62: 'ユニオンは基底クラスとして利用できません'
# 'unions cannot have base classes'
HC69C8BA7958A: 'ユニオンには基底クラスをもてません'
# 'unions cannot have virtual functions'
HE6462B703CAB: 'ユニオンには仮想関数を定義できません'
# 'universal character name referring to a control character is incompatible with C standards before C23'
H443795B4C160: '制御文字を指すユニバーサル文字名はC23以前の標準では互換性ありません'
# 'universal character name referring to a control character is incompatible with C++98'
H441444D5A2FF: '制御文字を指すユニバーサル文字名はC++98では互換性ありません'
# 'universal character name refers to a control character'
H0A302EE7A7D5: 'ユニバーサル文字名は制御文字を指しています'
# 'universal character name refers to a surrogate character'
H38343641D115: 'ユニバーサル文字名はサロゲート文字を指しています'
# 'universal character names are only valid in C99 or C++'
H6C064E2FEAA1: 'ユニバーサル文字名はC99またはC++でのみ有効です'
# "universal character names are only valid in C99 or C++; treating as '\\' followed by identifier"
H57AF83D90AE3: "ユニバーサル文字名はC99またはC++でのみ有効です；'\\'に続けて識別子として扱います"
# "unknown %0 warning specifier: '%1'"
HE021FCA9FD45: "不明な%0警告指定子: '%1'"
# 'unknown %select{type|class}1 name %0; did you mean %2?'
H3C8376ED6B78: '不明な%select{タイプ|クラス}1名 %0；%2を指定したつもりでは？'
# "unknown %select{warning|remark}0 option '%1'%select{|; did you mean '%3'?}2"
HE86784D7A808: "不明な%select{警告|メモ}0 オプション '%1'%select{|；'%3'を指定したつもりでは？}2"
# "unknown '-mindirect-jump=' option '%0'"
H632D52B85B4D: "不明な'-mindirect-jump='オプション '%0'"
# "unknown FP unit '%0'"
HC0D93947CA5F: "不明なFPユニット'%0'"
# 'unknown HLSL semantic %0'
H173D19A6AD63: "不明なHLSLのセマンティクス'%0'"
# "unknown action '%1' for '#pragma %0' - ignored"
HD5134EB4614C: "'#pragma %0' に対する不明なアクション'%1' — 無視されました"
# "unknown action for '#pragma %0' - ignored"
HC6ADA3F7938E: '#pragma %0の未知のアクション - 無視されました'
# "unknown analyzer-config '%0'"
H50FE6AD53FF0: "未知のanalyzer-config '%0'"
# "unknown argument '%0'; did you mean '%1'?"
HBDB4C2710C85: "未知の引数'%0'; '%1'を指定した意図でしたか？"
# "unknown argument ignored in clang-cl '%0'; did you mean '%1'?"
HFC74C4C6226A: "clang-clで無視された未知の引数 '%0'; '%1'を指定した意図でしたか？"
# "unknown argument ignored in clang-cl: '%0'"
HC759BFBE35F6: "clang-clで無視された未知の引数: '%0'"
# "unknown argument: '%0'"
HA16D3B1BF1E9: "未知の引数: '%0'"
# "unknown assumption string '%0' may be misspelled; attribute is potentially ignored, did you mean '%1'?"
H50CF8A7A4EC4: "不明な仮定文字列'%0'が誤記されている可能性があります; 属性は無効となる可能性があります。'%1'を指定した意図でしたか？"
# "unknown assumption string '%0'; attribute is potentially ignored"
H585A62063A9D: "不明な仮定文字列'%0'; 属性は無効となる可能性があります"
# 'unknown attribute %0 ignored'
H2C00F439265B: '未知の属性%0は無視されました'
# "unknown attribute '%0'"
HB9EC0CD4D3F9: "未知の属性'%0'"
# "unknown attribute subject rule '%0'"
H3D3386816A55: "未知の属性対象ルール'%0'"
# 'unknown cast annotation __bridge_retain; did you mean __bridge_retained?'
H99CA4EEB19EE: '__bridge_retainは不明なキャストアノテーションです; __bridge_retainedを指定した意図でしたか？'
# 'unknown command tag name'
H11BCD33A99AD: '不明なコマンドタグ名'
# "unknown command tag name '%0'; did you mean '%1'?"
H7FD2FDFA8A87: "不明なコマンドタグ名'%0'; '%1'を指定した意図でしたか？"
# 'unknown diagnostic option'
HB8C73037AA51: '不明な診断オプション'
# 'unknown environment %0 in availability macro'
HAEC8AEED3CAD: '利用可能マクロ内の未知の環境%0'
# "unknown escape sequence '\\%0'"
H4849F8435E28: "未知のエスケープシーケンス'\\%0'"
# 'unknown kind of pragma comment'
HA06D4573713E: '不明な種類のpragma comment'
# 'unknown linkage language'
H6501D0DE4EA8: '不明なリンケージ言語'
# "unknown module '%0'"
H99985C296846: "未知のモジュール'%0'"
# "unknown or ill-formed Objective-C runtime '%0'"
HDD07911A4A21: "不明なまたは不正な Objective-C ランタイム '%0'"
# 'unknown platform %0 in availability macro'
HD5C8076C5089: '利用可能性マクロ内の未知のプラットフォーム %0'
# 'unknown platform, assuming -mfloat-abi=%0'
HE055695902FF: '不明なプラットフォームです。-mfloat-abi=%0 と仮定します'
# 'unknown pragma ignored'
H2A263E84EA76: '未知の #pragma を無視しました'
# 'unknown pragma in STDC namespace'
HB8BAEB9D2633: 'STDC 名前空間内の未知の #pragma'
# 'unknown property attribute %0'
HA552B52A5631: '未知のプロパティ属性 %0'
# 'unknown receiver %0; did you mean %1?'
HF53B2435A683: '未知のレシーバ %0; %1 をお望みではありませんか？'
# "unknown register name '%0' in asm"
H0A30B49D2F93: "アセンブリ内の未知のレジスタ名 '%0'"
# "unknown remark serializer format: '%0'"
H4745BF37BA54: "未知の remark シリアライザ形式: '%0'"
# "unknown sanitizer '%0' ignored"
H7A7513A62BEF: "未知の sanitizer '%0' は無視されました"
# "unknown state '%0'"
HBCA6965044DA: "不明な状態 '%0'"
# 'unknown symbolic operand name in inline assembly string'
HA556FD6AA91E: 'インラインアセンブリ文字列内の未知のシンボル演算子名'
# "unknown target ABI '%0'"
HCA5838C6F428: "不明なターゲット ABI '%0'"
# "unknown target CPU '%0'"
H70DCB9C1156C: "不明なターゲット CPU '%0'"
# "unknown target triple '%0'"
HF45924A5A477: "不明なターゲットトリプル '%0'"
# 'unknown template name %0'
HF6FA1BD9E3B7: '未知のテンプレート名 %0'
# 'unknown type name %0'
HE3210F6A77D6: '未知の型名 %0'
# 'unknown type name %0; did you mean %1?'
H2AA39E457B1F: '未知の型名 %0; %1 をお望みではありませんか？'
# 'unknown visibility %0'
HD580631FB230: '不明な可視性 %0'
# "unknown warning group '%0'"
H8B8A3DBA2D6F: "不明な警告グループ '%0'"
# "unknown warning group '%0', ignored"
H9E42BAF52A2D: "不明な警告グループ '%0'、無視されました"
# "unknown%select{ | embed}0 preprocessor parameter '%1'"
HD697EE356FF3: "不明な%select{ | embed}0プリプロセッサ パラメーター '%1'"
# 'unnamed enumeration must be a definition'
H4B9605BBAC49: '名前のない列挙型は定義でなければなりません'
# 'unnamed type as template argument is incompatible with C++98'
HCF539CBCF367: '名前のない型をテンプレート引数として使用することはC++98と互換性ありません'
# 'unnamed type used in template argument was declared here'
H766AB8914B51: 'テンプレート引数で使用された名前のない型はここに宣言されました'
# 'unnamed variable cannot be implicitly captured in a lambda expression'
HC2AE531DDA32: '名前のない変数はラムダ式で暗黙的にキャプチャできません'
# 'unparsed tokens following type'
H64EC0A0DBA9B: '型の後に未解析のトークンがあります'
# 'unqualified base initializer of class templates is a Microsoft extension'
H18E0D4547A36: 'クラス テンプレートの修飾なし基底初期化子はMicrosoftの拡張機能です'
# "unqualified call to '%0'"
HA083B268F3B3: "修飾なし呼び出し '%0'"
# 'unqualified friend declaration referring to type outside of the nearest enclosing namespace is a Microsoft extension; add a nested name specifier'
H99771505062C: '最も近い包含名前空間外の型を指す修飾なしフレンド宣言はMicrosoftの拡張機能です; ネストした名前指定子を追加してください'
# 'unreachable declaration of template entity is here'
H8957FB46EC11: 'テンプレート エンティティの到達不能な宣言はここにあります'
# "unrecognized parameter passing direction, valid directions are '[in]', '[out]' and '[in,out]'"
H451D99C06285: "認識できないパラメーター渡し方向です。有効な方向は '[in]', '[out]'、および '[in,out]' です"
# 'unrecognized platform name %0'
H3352495501E4: '認識できないプラットフォーム名 %0'
# 'unsequenced modification and access to %0'
HF69B798309CF: '%0に対する非順序修飾とアクセス'
# 'unsupported %0 gpu architecture: %1'
HFE203A3E528C: 'サポートされていない %0 GPU アーキテクチャ: %1'
# "unsupported '%0' value '%1'; use 'ios-macabi' instead"
H4B7365627CB3: "サポートされていない '%0' 値 '%1'; 代わりに 'ios-macabi' を使用してください"
# 'unsupported CUDA gpu architecture: %0'
HBDA907ABC960: 'サポートされていないCUDA GPU アーキテクチャ: %0'
# 'unsupported MC/DC boolean expression; contains an operation with a nested boolean expression. Expression will not be covered'
H0E188D9916C4: 'サポートされていないMC/DCブール式; ネストしたブール式を含む操作を含んでいます。式はカバーされません'
# 'unsupported MC/DC boolean expression; number of conditions (%0) exceeds max (%1). Expression will not be covered'
H97B49477D381: 'サポートされていないMC/DCブール式; 条件数 (%0) が最大値 (%1) を超えています。式はカバーされません'
# 'unsupported MC/DC boolean expression; number of test vectors (%0) exceeds max (%1). Expression will not be covered'
HA1952652ED2D: 'サポートされていないMC/DCブール式; テスト ベクター数 (%0) が最大値 (%1) を超えています。式はカバーされません'
# 'unsupported OpenCL extension %0 - ignoring'
H90715CF4E48F: 'サポートされていないOpenCL拡張機能%0 - 無視します'
# "unsupported architecture '%0' for MS-style inline assembly"
H4CDA8CDAE447: "MSスタイルのインラインアセンブリ用のサポートされていないアーキテクチャ'%0'"
# "unsupported architecture '%0' for host compilation"
HF6B9D10A3CB2: "サポートされていないホストコンパイル用のアーキテクチャ'%0'"
# "unsupported argument '%1' to option '%0'"
HF8679865943E: "オプション'%0'へのサポートされていない引数'%1'"
# "unsupported argument '%1' to option '%0' for target '%2'"
H4C786BC0FD2F: "ターゲット'%2'用のオプション'%0'へのサポートされていない引数'%1'"
# "unsupported branch protection specification '%0'"
H2A7469D4D5C2: "サポートされていない枝保護仕様'%0'"
# 'unsupported combination: -header-include-format=%0 and -header-include-filtering=%1'
HDE5448E6CD09: 'サポートされていない組み合わせ: -header-include-format=%0と-header-include-filtering=%1'
# 'unsupported combination: CC_PRINT_HEADERS_FORMAT=%0 and CC_PRINT_HEADERS_FILTERING=%1'
H2798CD78D9FC: 'CC_PRINT_HEADERS_FORMAT=%0とCC_PRINT_HEADERS_FILTERING=%1のサポートされていない組み合わせ'
# 'unsupported expression with unknown type'
H3F334416D50C: '不明な型のサポートされていない式'
# 'unsupported inline asm: input with type %diff{$ matching output with type $|}0,1'
HA68AF7F61C41: 'サポートされていないインラインアセンブリ: 型%diff{が一致する出力の型$との入力$|}0,1'
# 'unsupported non-standard concatenation of string literals'
H5B7E63184569: '非標準の文字列リテラルの連結はサポートされていません'
# "unsupported option '%0'"
H76DA0BF83FA2: "サポートされていないオプション'%0'"
# "unsupported option '%0' for language mode '%1'"
HFB2A15C316AA: "言語モード'%1'用のサポートされていないオプション'%0'"
# "unsupported option '%0' for target '%1'"
H3BBDE17AAC2A: "ターゲット'%1'用のサポートされていないオプション'%0'"
# "unsupported option '%0'; did you mean '%1'?"
H4AD874895A11: "サポートされていないオプション'%0'; '%1'を意味したのではないでしょうか？"
# "unsupported runtime library '%0' for platform '%1'"
HE43F5A0809F2: "プラットフォーム'%1'用のサポートされていないランタイムライブラリ'%0'"
# 'unsupported signature for %q0'
H15BCEB35CA2A: '%q0のサポートされていないシグネチャ'
# "unsupported standard library implementation: 'std::%0' is not a class template"
HA2971F6C2CFB: "標準ライブラリ実装がサポートされていません:'std::%0'はクラステンプレートではありません"
# 'unsupported type for named register variable'
H1A238AEF63D8: '名前付きレジスタ変数用のサポートされていない型'
# "unsupported unwind library '%0' for platform '%1'"
H36E9F0E6CE47: "プラットフォーム'%1'用のサポートされていないアンウィンドライブラリ'%0'"
# 'unsupported vector cast from %0 to %1 in a constant expression'
H0EB0D2450B52: '定数式内で%0から%1へのサポートされていないベクターキャスト'
# 'unsupported: anonymous type given name for linkage purposes by %select{typedef|alias}0 declaration after its linkage was computed; add a tag name here to establish linkage prior to definition'
H912212F218D9: 'リンク目的で%select{typedef|alias}0宣言によって匿名型に名前が付けられましたが、リンクが計算された後に実行されました; タグ名をここに追加して定義前にリンクを確立してください'
# "unterminated '#pragma clang attribute push' at end of file"
HAA76B77750A8: "ファイルの終わりで未終了の '#pragma clang attribute push'"
# "unterminated '#pragma pack (push, ...)' at end of file"
H95BE59428151: "ファイルの終わりで未終了の '#pragma pack (push, ...)'"
# 'unterminated /* comment'
H43A167D7F07E: '未終了の /* コメント'
# 'unterminated conditional directive'
H9448FAFF2F9A: '未終了の条件付きディレクティブ'
# 'unterminated function-like macro invocation'
HD9DD62FCE328: '未終了の関数型マクロの呼び出し'
# 'unterminated symbolic operand name in inline assembly string'
HBE23072A59B4: 'インラインアセンブリ文字列内のシンボル操作子名の未終了'
# 'unused %select{function|variable}0 template %1'
H1A13AD1AD99E: '使用されていない %select{function|variable}0 テンプレート %1'
# 'unused %select{typedef|type alias}0 %1'
HF81285298D17: '使用されていない %select{typedef|type alias}0 %1'
# "unused attribute %0 in '#pragma clang attribute push' region"
HE033EC53FB54: "'#pragma clang attribute push'領域内の使用されていない属性%0"
# 'unused exception parameter %0'
H53C55F431BFF: '未使用の例外パラメータ%0'
# 'unused function %0'
H452452A2578C: '使用されていない関数%0'
# 'unused label %0'
H876AC9FC8066: '使用されていないラベル%0'
# 'unused member function %0'
HCD85BCD73655: '使用されていないメンバ関数%0'
# 'unused parameter %0'
HA3441FCB7F5E: '未使用のパラメータ%0'
# 'unused variable %0'
HC6697F7C70D3: '使用されていない変数%0'
# 'unwind clobber cannot be used with asm goto'
HF66EC6AC58F5: 'asm gotoと共にunwind clobberを使用することはできません'
# 'update DWARF debug sections of the executable'
HED8DED50ECC0: '実行可能ファイルのDWARFデバッグセクションを更新'
# 'update address2ProbesMap with output block address'
H5AFCEC7A601F: '出力ブロックアドレスでaddress2ProbesMapを更新'
# 'use %select{__bridge_retained|CFBridgingRetain call}1 to make an ARC object available as a +1 %0'
H2F547772958A: 'ARCオブジェクトを+1 %0として利用可能にするには、%select{__bridge_retained|CFBridgingRetainコール}1を使用してください'
# 'use %select{__bridge_transfer|CFBridgingRelease call}1 to transfer ownership of a +1 %0 into ARC'
HF8A351DB4284: '+1 %0のオーナーシップをARCに移転するには、%select{__bridge_transfer|CFBridgingReleaseコール}1を使用してください'
# 'use %select{an alias declaration|a typedef declaration|a reference|a const variable|a constexpr variable}0 instead'
H31FA52067035: '代わりに%select{エイリアス宣言|typedef宣言|リファレンス|const変数|constexpr変数}0を使用してください'
# "use '!=' to turn this compound assignment into an inequality comparison"
HFF11B4D027A3: "この複合代入を不等比較に変換するには'!='を使用してください"
# "use '%0' for a bitwise operation"
HC5B930A30B61: "ビット操作には'%0'を使用してください"
# "use '%0' instead"
H3E25F181DE0F: "代わりに'%0'を使用してください"
# "use '%0'%select{| or '%3'|, '%3', or '%4'|, '%3', '%4', or '%5'}2 for '%1' standard"
H8EF0F3BAA8D4: "'%1'規格に対応するには、'%0'%select{|または'%3'|、'%3'、または'%4'|、'%3'、'%4'、または'%5'}2を使用してください"
# "use '--' to treat subsequent arguments as filenames"
H6A626367FC6F: "'--'を使用して以降の引数をファイル名として扱う"
# "use '=' to turn this equality comparison into an assignment"
H59DEE49ECF0A: "この等価比較を代入に変換するには'='を使用してください"
# "use '==' to turn this assignment into an equality comparison"
H00083B312DD9: "この代入を等価比較に変換するには'=='を使用してください"
# "use 'framework module' to declare module '%0'"
H4A41FDAB21BC: "モジュール'%0'を宣言するには'framework module'を使用してください"
# "use 'isEqual:' instead"
H4DB59E9DD438: "代わりに'isEqual:'を使用してください"
# "use 'static' to give inline function %0 internal linkage"
HFF537B0E0104: "インライン関数%0に内部リンケージを与えるには'static'を使用してください"
# "use 'static_cast' to adjust the pointer correctly while %select{upcasting|downcasting}0"
H11DA11C5BD86: "ポインタを正しく調整するには、%select{上位キャスト|下位キャスト}0を行う際、'static_cast'を使用してください"
# "use 'template' keyword to treat '%0' as a dependent template name"
H7991087B2538: "'%0'を依存テンプレート名として扱うには'template'キーワードを使用してください"
# "use 'thread_local' to allow this"
H797BF646E244: "これを行うには'thread_local'を使用してください"
# "use '|=' to turn this inequality comparison into an or-assignment"
H080693EB5666: "この不等比較をor代入に変換するには'|='を使用してください"
# 'use -analyzer-disable-all-checks to disable all static analyzer checkers'
H352E7076CB09: "すべての静的解析チェックを無効化するには'-analyzer-disable-all-checks'オプションを使用してください"
# 'use -fbracket-depth=N to increase maximum nesting level'
H336E5F530373: "最大ネストレベルを増やすには'-fbracket-depth=N'オプションを使用してください"
# "use -foperator-arrow-depth=N to increase 'operator->' limit"
HF5AE9E6C2AED: "'operator->'の制限を増加させるには'-foperator-arrow-depth=N'オプションを使用してください"
# 'use -ftemplate-depth=N to increase recursive template instantiation depth'
HB6D1F29D249C: '-ftemplate-depth=N オプションを使用して再帰テンプレートインスタンス化の深さを増やしてください'
# 'use /Tc or /Tp to set input type for standard input'
HA357D9386AFC: '/Tcまたは/Tp オプションで標準入力のタイプを設定してください'
# 'use DBSCAN/OPTICS algorithm'
HD85FBF4157B0: 'DBSCAN/OPTICS アルゴリズムを使用してください'
# 'use DFS order for YAML profile'
H3B1260947C69: 'YAMLプロファイルにDFS順序を使用してください'
# 'use DFS ordering when using -icf option'
HBAAC1CA2D23D: '-icf オプションを使用する際はDFS順序を使用してください'
# 'use GNU_STACK program header for new segment (workaround for issues with strip/objcopy)'
H43641118D1BF: 'strip/objcopyとの問題回避のため、新しいセグメント用にGNU_STACKプログラムヘッダーを使用します'
# 'use Machine Branch Probability Info'
H2ADCBE6C2DCD: 'マシン分岐確率情報を使用します'
# 'use Pettis-Hansen algorithm'
H5F85980D861E: 'Pettis-Hansen アルゴリズムを使用してください'
# 'use __attribute__((visibility("hidden"))) attribute instead'
H69E62EF34DBF: '代わりに__attribute__((visibility("hidden")))属性を使用してください'
# 'use __bridge to convert directly (no change in ownership)'
HF999F719DC1E: '所有権の変更なしに直接変換するには__bridgeを使用してください'
# 'use __bridge with C-style cast to convert directly (no change in ownership)'
H25381B224554: '所有権の変更なしに直接変換するにはCスタイルキャストと__bridgeを使用してください'
# 'use __bridge_retained with C-style cast to make an ARC object available as a +1 %0'
H89038B186CBF: 'ARCオブジェクトを+1 %0として利用可能にするには、Cスタイルキャストと__bridge_retainedを使用してください'
# 'use __bridge_transfer with C-style cast to transfer ownership of a +1 %0 into ARC'
H0BF38DCCAF48: '+1 %0のオーナーシップをARCに移転するには、Cスタイルキャストと__bridge_transferを使用してください'
# "use a function's hot size when doing clustering"
H10032CBF870F: 'クラスタリングを行う際に関数のホットサイズを使用します'
# 'use a lock file so only one process in the system can run this pass at once. useful to avoid mangled debug output in multithreaded environments.'
H7CB74F0F7BF5: 'マルチスレッド環境でデバッグ出力が破損しないように、システム内のプロセスが一度に1つしかこのパスを実行できないようロックファイルを使用します'
# 'use a modified clustering algorithm geared towards minimizing branches'
HFDD79DC87D1A: '分岐の最小化を目的とした修正されたクラスタリングアルゴリズムを使用します'
# 'use absolute jump tables on ppc'
H88706E2F52B2: 'ppcアーキテクチャで絶対ジャンプテーブルを使用します'
# 'use aggressive ppc isel for bit permutations'
H99649C2F1B01: 'ビット順列のためにアグレッシブなppc iselを使用します'
# 'use array indexing to silence this warning'
H85B32746AF01: 'この警告を抑制するには配列インデックスを使用してください'
# 'use ascending or descending order when printing functions ordered by dyno stats'
HF0A78325BB17: 'dyno統計による関数の並べ替え時に昇順または降順を使用します'
# 'use branch prediction data to control sctc'
H2D5E124AB149: 'sctcを制御するためにブランチ予測データを使用します'
# 'use cache-directed sort'
H993E2A52F48B: 'キャッシュ指向のソートを使用します'
# 'use constraint modifier "%0"'
H96B4F36A2D84: '%0制約修飾子を使用してください'
# 'use declarations are only allowed in top-level modules'
HB528050B8967: 'use宣言はトップレベルのモジュールでのみ許可されます'
# 'use edge count data when doing clustering'
H6F3C614822A7: 'クラスタリングを行う際にエッジカウントデータを使用します'
# 'use fast runtime behavior'
H2D5F50DA24D3: '高速ランタイム動作を使用します'
# "use function '%0' instead"
H30EA9A5A15F6: '代わりに関数"%0"を使用してください'
# 'use function order specified by -function-order'
H517260D51513: '-function-orderで指定された関数順序を使用します'
# 'use hfsort algorithm'
H6D5DE1F47100: 'hfsortアルゴリズムを使用します'
# 'use hot/cold data on basic blocks to determine hot sizes for call graph functions'
H898A061653FE: 'コールグラフ関数のホットサイズを決定するために、ベーシックブロックのhot/coldデータを使用します'
# 'use instrumentation with slow path for all accesses'
H244914CD834D: 'すべてのアクセスに対して遅延パス付きのインストルメンテーションを使用します'
# 'use misprediction frequency for determining whether or not ICP should be applied at a callsite.  The -indirect-call-promotion-mispredict-threshold value will be used by this heuristic'
H3115132EB120: 'ICPがコールサイトで適用されるかどうかを決定するための不正予測周波数を使用します。このヒューリスティックでは、-indirect-call-promotion-mispredict-threshold値が使用されます'
# 'use non-reference type %0'
HE4A5CE8520B2: '非参照型%0を使用してください'
# 'use non-reference type %0 to make construction explicit or type %1 to prevent copying'
HAB8A2938766C: '構築を明示的にするために非参照型%0、またはコピーを防ぐために型%1を使用してください'
# 'use nullability type specifier %0 to affect the innermost pointer type of %1'
HA9A4302606C7: '%1の最も内側のポインタータイプに影響を与えるために、nullability型指定子%0を使用してください'
# 'use of %0 with tag type that does not match previous declaration'
H4AAB2FCDDAB1: '前の宣言と一致しないタグ型で%0を使用しました'
# 'use of %select{class template|function template|variable template|alias template|template template parameter|concept|template}0 %1 requires template arguments'
H8F99144D2E34: '%select{class template|function template|variable template|alias template|template template parameter|concept|template}0 %1の使用にはテンプレート引数が必要です'
# 'use of %select{infinity|NaN}0%select{| via a macro}1 is undefined behavior due to the currently enabled floating-point options'
H18AE2A8F681F: '現在有効な浮動小数点オプションにより、%select{無限大|NaN}0%select{|マクロ経由の}1使用は未定義の動作です'
# 'use of %select{type|declaration}0 %1 requires %2 support'
H39DB55887936: '%select{型|宣言}0 %1 の使用には %2 サポートが必要です'
# "use of '@import' in framework header is discouraged, including this header requires -fmodules"
H455C5312D820: "'@import' をフレームワーク ヘッダ内で使用することは推奨されません。このヘッダを含めるには -fmodules オプションが必要です"
# "use of '@import' when modules are disabled"
HE80AA99C30B1: "'@import' を使用するにはモジュールを有効にする必要があります"
# "use of '__int128' with '__vector bool' requires VSX support enabled (on POWER10 or later)"
HBB36DE187BFD: "'__int128' と '__vector bool' を組み合わせるには、VSX サポート（POWER10 以降）を有効にする必要があります"
# "use of '__int128' with '__vector' requires extended Altivec support (available on POWER8 or later)"
H02493A6B8143: "'__int128' と '__vector' を組み合わせるには、拡張 Altivec サポート（POWER8 以降対応）が必要です"
# "use of '__super' inside a lambda is unsupported"
H5812045C24A5: "'__super' の使用は lambda 内部ではサポートされていません"
# "use of 'double' with '__vector' requires VSX support to be enabled (available on POWER7 or later)"
HFF794EBE240D: "'double' と '__vector' を組み合わせるには、VSX サポート（POWER7 以降対応）を有効にする必要があります"
# "use of 'long long' with '__vector' requires VSX support (available on POWER7 or later) to be enabled"
HEDE074D6F05D: "'long long' と '__vector' を組み合わせるには、VSX サポート（POWER7 以降対応）を有効にする必要があります"
# "use of 'long' with '__vector' is deprecated"
H194F4A31DAD4: "'long' と '__vector' を組み合わせる使用は非推奨になりました"
# "use of 'operator->' on type %0 would invoke a sequence of more than %1 'operator->' calls"
HE55B12BF8DE6: "型 %0 に対して 'operator->' を使用すると、%1 回を超える 'operator->' 呼び出しが連鎖します"
# "use of 'static_assert' without inclusion of <assert.h> is a Microsoft extension"
HFC681B3993FC: "<assert.h> を含めずに 'static_assert' を使用することは、Microsoft の拡張機能です"
# "use of 'template' keyword outside of a template is incompatible with C++98"
HADE615C257C6: "テンプレート外で 'template' キーワードを使用することは、C++98 と互換性がありません"
# 'use of @defs is not supported on this architecture and platform'
HA2315B23A421: '@defs の使用は、このアーキテクチャおよびプラットフォームではサポートされていません'
# 'use of C-style parameters in Objective-C method declarations is deprecated'
H124575A24936: 'Objective-C メソッド宣言で C スタイルのパラメータを使用することは非推奨になりました'
# "use of GNU 'missing =' extension in designator"
HE3037B23921A: "設計子における GNU の 'missing =' 拡張機能の使用"
# 'use of GNU ?: conditional expression extension, omitting middle operand'
H0DE762B90B0D: '中間オペランドを省略する GNU の ?: 条件式拡張機能の使用'
# 'use of GNU address-of-label extension'
HA7B26095AD53: 'GNU アドレス・オブ・ラベル拡張機能の使用'
# 'use of GNU array range extension'
H678FC3DF1C6F: 'GNU 配列範囲拡張機能の使用'
# 'use of GNU indirect-goto extension'
H3D429B23EFAC: 'GNU 間接 goto 拡張機能の使用'
# 'use of GNU old-style field designator extension'
H85575BE49C11: 'GNUの旧式フィールド指定子拡張機能を使用'
# 'use of GNU statement expression extension'
HD7924EDC2399: 'GNUのステートメント式拡張機能を使用'
# 'use of GNU statement expression extension from macro expansion'
HDFF296407839: 'マクロ展開からGNUのステートメント式拡張機能を使用'
# 'use of NULL in arithmetic operation'
H72A441293B63: 'NULLの算術演算における使用'
# 'use of Objective-C property in function nested in Objective-C container not supported, move function outside its container'
H1B2603FEAF82: 'Objective-C コンテナ内にネストされた関数でのObjective-Cプロパティの使用はサポートされていません。関数をコンテナ外に移動してください'
# 'use of __private_extern__ on a declaration may not produce external symbol private to the linkage unit and is deprecated'
HC7A56E0EB4D2: '__private_extern__ を宣言で使用するとリンケージ単位に固有の外部シンボルが生成されなくなり、非推奨となっています'
# "use of a '#%select{<BUG IF SEEN>|elifdef|elifndef}0' directive is a C++23 extension"
H6A5DD5BE1302: "'%select{<バグの可能性>|elifdef|elifndef}0' ディレクティブはC++23拡張です"
# "use of a '#%select{<BUG IF SEEN>|elifdef|elifndef}0' directive is a C23 extension"
H0BF82439932C: "'%select{<バグの可能性>|elifdef|elifndef}0' ディレクティブはC23拡張です"
# "use of a '#%select{<BUG IF SEEN>|elifdef|elifndef}0' directive is incompatible with C standards before C23"
HDFCC088F181F: "'%select{<バグの可能性>|elifdef|elifndef}0' ディレクティブはC23以前のC規格と互換性ありません"
# "use of a '#%select{<BUG IF SEEN>|elifdef|elifndef}0' directive is incompatible with C++ standards before C++23"
H16A663A66375: "'%select{<バグの可能性>|elifdef|elifndef}0' ディレクティブはC++23以前のC++規格と互換性ありません"
# 'use of address-of-label extension outside of a function body'
HEBDAFDF05EDA: '関数本体外でのラベルアドレス拡張機能を使用'
# 'use of an empty initializer is a C23 extension'
HD0F8B4BA3FB2: '空の初期化子の使用はC23拡張です'
# 'use of an empty initializer is incompatible with C standards before C23'
H28862631C8FD: '空の初期化子の使用はC23以前のC規格と互換性ありません'
# "use of bitwise '%0' with boolean operands"
H3DCD98477290: '真偽値オペランドとのビット単位の「%0」使用'
# 'use of default argument to function %0 that is declared later in class %1'
HBEFC6E561806: 'クラス%1で後で宣言された関数%0のデフォルト引数を使用しています。この機能は推奨されません'
# 'use of dynamic_cast requires -frtti'
HE86B35BE234A: 'dynamic_castの使用には-frttiオプションが必要です'
# 'use of empty enum'
H0A3EEAE0C204: '空のenumを使用'
# 'use of enumeration in a nested name specifier is a C++11 extension'
H9F1C227C8017: 'ネスト名指定子内の列挙型使用はC++11拡張です'
# 'use of function %0 is discouraged; there is no way to check for failure but failure may still occur, resulting in a possibly exploitable security vulnerability'
H123B46BAB412: '関数%0の使用は推奨されません。失敗を検出する方法がなく、脆弱性を招く可能性があります'
# 'use of function template name with no prior declaration in function call with explicit template arguments is a C++20 extension'
H17E19DFB3C7C: '明示的なテンプレート引数を伴う関数呼び出しで、事前の宣言のない関数テンプレート名を使用することはC++20の拡張機能です'
# 'use of function template name with no prior declaration in function call with explicit template arguments is incompatible with C++ standards before C++20'
H640DD80A631A: '明示的なテンプレート引数を伴う関数呼び出しで、事前の宣言のない関数テンプレート名を使用することはC++20以前の標準では互換性ありません'
# "use of implicit 'typename' is incompatible with C++ standards before C++20"
HFA6B14FF689A: "暗黙の'typename'の使用はC++20以前の標準では互換性ありません"
# "use of incomplete type %0 in a '_Generic' association is incompatible with C standards before C2y"
H805F57844181: "'_Generic'の関連付けで未完成の型%0を使用することはC2y以前のC標準では互換性ありません"
# "use of logical '%0' with constant operand"
H91174008E58D: "定数オペランドと組み合わせた論理演算子'%0'の使用"
# 'use of member %0 before its declaration is a Microsoft extension'
HF1849841B9E7: '宣言より前でメンバー%0を使用することはMicrosoftの拡張機能です'
# 'use of member %0 found via unqualified lookup into dependent bases of class templates is a Microsoft extension'
H8CD447C8CC3A: 'テンプレートクラスの依存ベースへの非修飾探索で見つかったメンバー%0を使用することはMicrosoftの拡張機能です'
# 'use of multiple declarators in a single using declaration is a C++17 extension'
H82698382734A: '単一のusing宣言で複数の宣言子を使用することはC++17の拡張機能です'
# 'use of multiple declarators in a single using declaration is incompatible with C++ standards before C++17'
HF5A1B33A1986: '単一のusing宣言で複数の宣言子を使用することはC++17以前の標準では互換性ありません'
# "use of non-standard escape character '\\%0'"
H8F21313E1DFF: "非標準のエスケープ文字'\\%0'の使用"
# 'use of non-static data member %0 in an unevaluated context is incompatible with C++98'
H47868E15CED8: '非静的データメンバ%0を評価されない文脈で使用することはC++98では互換性ありません'
# 'use of null pointer as non-type template argument is incompatible with C++98'
H6944D3B803C2: 'NULLポインタを非型テンプレート引数として使用することはC++98では互換性ありません'
# 'use of old-style cast'
H0C8605CE0E58: '古いスタイルのキャストの使用'
# 'use of out-of-scope declaration of %0%select{| whose type is not compatible with that of an implicit declaration}1'
H9DFA1FDF94B0: '範囲外の宣言%0%select{| の型は暗黙の宣言の型と互換性ありません}1を使用'
# "use of overloaded operator '%0' is ambiguous (operand type %1)"
H4300BB2DDBA6: "オーバーロードされた演算子'%0'の使用は曖昧です（オペランドの型%1）"
# "use of overloaded operator '%0' is ambiguous (with operand types %1 and %2)"
H792DBC228D1F: "オーバーロードされた演算子'%0'の使用は曖昧です（%1型と%2型のオペランド）"
# 'use of placement new requires explicit declaration'
H992499F64501: 'placement newを使用するには明示的な宣言が必要です'
# "use of private header from outside its module: '%0'"
H4B3CFE33871D: "モジュール外からプライベートヘッダーを使用：'%0'"
# 'use of reference outside its lifetime is not allowed in a constant expression'
H2C7D8C6358B3: '参照の生存期間外で参照を使用することは定数式では許可されていません'
# 'use of result of assignment to object of volatile-qualified type %0 is deprecated'
H0FD6FA3111E8: 'volatile修飾型%0のオブジェクトへの代入の結果を使用することは非推奨です'
# "use of right-shift operator ('>>') in template argument will require parentheses in C++11"
H4B1C2F8BF668: "テンプレート引数で右シフト演算子('>>')を使用する場合、C++11では括弧が必要です"
# 'use of the %0 attribute is a C++14 extension'
HD7333826DEB8: '%0属性の使用はC++14拡張機能です'
# 'use of the %0 attribute is a C++17 extension'
H9D6E9F75124A: '%0属性の使用はC++17拡張機能です'
# 'use of the %0 attribute is a C++20 extension'
H85EE1317CADA: '%0属性の使用はC++20拡張機能です'
# 'use of the %0 attribute is a C++23 extension'
H3769FB94DD63: '%0属性の使用はC++23拡張機能です'
# 'use of this expression in an %0 attribute requires parentheses'
H4B6BF2EAA0DF: '%0属性内でこの式を使用する場合、括弧が必要です'
# 'use of this statement in a constexpr %select{function|constructor}0 is a C++14 extension'
H009816A3B264: 'constexpr %select{function|constructor}0 内でこのステートメントを使用することはC++14拡張機能です'
# 'use of this statement in a constexpr %select{function|constructor}0 is a C++20 extension'
H383EABB05A34: 'constexpr %select{function|constructor}0 内でこのステートメントを使用することはC++20拡張機能です'
# 'use of this statement in a constexpr %select{function|constructor}0 is a C++23 extension'
H3CD433F9DEED: 'constexpr %select{function|constructor}0 内でこのステートメントを使用することはC++23拡張機能です'
# 'use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14'
HDB9F101C6FD8: 'C++14以前のC++基準と互換性のないステートメントがconstexpr %select{function|constructor}0 内で使用されました'
# 'use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++20'
H10E657C568DA: 'C++20以前のC++基準と互換性のないステートメントがconstexpr %select{function|constructor}0 内で使用されました'
# 'use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++23'
HBB6862211968: 'C++23以前のC++基準と互換性のないステートメントがconstexpr %select{function|constructor}0 内で使用されました'
# 'use of typeid requires -frtti'
H6516CAF74372: 'typeidの使用には-frttiオプションが必要です'
# 'use of unary operator that may be intended as compound assignment (%0=)'
H52686183E946: '単項演算子の使用（複合代入 %0= として意図された可能性があります）'
# 'use of undeclared %0'
H4249B6D3D66A: '宣言されていない%0の使用'
# 'use of undeclared %0; did you mean %1?'
H152AECD0CF73: '宣言されていない%0の使用; %1を意図したかもしれません'
# 'use of undeclared identifier %0'
H2DA2A4EF5956: '宣言されていない識別子%0の使用'
# 'use of undeclared identifier %0; did you mean %1?'
H448AE4CE2F58: '宣言されていない識別子%0の使用; %1を意図したかもしれません'
# 'use of undeclared identifier %0; unqualified lookup into dependent bases of class template %1 is a Microsoft extension'
HB6A34859F540: '宣言されていない識別子%0の使用; クラステンプレート%1の依存ベースの無資格検索はMicrosoft拡張機能です'
# 'use of undeclared label %0'
H685C1928674B: '宣言されていないラベル%0の使用'
# "use of undefined marker '%0'"
HAEC3C6045C74: "定義されていないマーカー '%0' の使用"
# 'use of unknown builtin %0'
HBFCE16721923: '未知の組み込み関数 %0 の使用'
# 'use old code sequence for promoted calls'
H27311E45E8D5: 'プロモートされたコール用の古いコードシーケンスを使用'
# 'use perf data directly when constructing the call graph for stale functions'
H9C843E88A00A: '古い関数のコールグラフ構築時にパフォーマンスデータを直接使用'
# 'use precise runtime behavior'
H864CB2EB7B9A: '厳密なランタイム動作を使用'
# 'use reference type %0 to prevent copying'
H96F12D2BC3F2: 'コピーを防止するためリファレンスタイプ %0 を使用'
# 'use register liveness analysis to try to find more opportunities for -reg-reassign optimization'
H7BCD305B01BE: '-reg-reassign 最適化の機会を増やすためにレジスタ有効性解析を使用'
# 'use regular size pages for code alignment'
H041AAF5448A5: 'コードアライメント用に通常サイズのページを使用'
# 'use relaxed runtime behavior'
H386C9EF15D8D: '緩和されたランタイム動作を使用'
# 'use relocations in the binary (default=autodetect)'
HA2145EBF1AF4: 'バイナリ内でリロケーションを使用（デフォルト=autodetect）'
# 'use same count for BBs that should have equivalent count (used in non-LBR and shrink wrapping)'
H2FCA1FC45D12: '同等カウントが必要なBBには同じカウントを使用（非LBRと縮小ラッピングで使用）'
# "use same version number separators '_' or '.'; as in 'major[.minor[.subminor]]'"
H152CFF6748B3: "同じバージョン番号区切り文字 '_' または '.' を使用；例：'major[.minor[.subminor]]'"
# 'use short granules in allocas and outlined checks'
H1D7871DD27F1: 'allocaとアウトラインチェックで短いグランールを使用'
# 'use strict dwarf'
HD69F3507E82F: '厳密なDWARFを使用'
# 'use stricter verifier for HLFIR intrinsic operations'
H7296989D6AE9: 'HLFIR組み込み操作の検証に厳密な検証を使用'
# "use the GNU '__attribute__' syntax"
H7DBF5BB23C34: "GNU '__attribute__' シンタックスを使用"
# 'used here'
H1359FF249380: 'ここですでに使用済み'
# 'used in initialization here'
H9614905D4DE2: 'ここでの初期化で使用済み'
# 'used type %0 where __hlsl_resource_t is required'
HB0299AD4C891: '__hlsl_resource_t が必要な場所にタイプ %0 を使用'
# 'used type %0 where arithmetic or pointer type is required'
HEF054774D419: '算術型またはポインタ型が必要な場所で型%0を使用しました'
# 'used type %0 where floating point type is not allowed'
HF095E0FB08EE: '浮動小数点型が禁止されている場所で型%0を使用しました'
# 'used type %0 where integer is required'
HCD053F3A5F86: '整数型が必要な場所で型%0を使用しました'
# 'used type %0 where integer or floating point type is required'
H46DF1623ED73: '整数型または浮動小数点型が必要な場所で型%0を使用しました'
# 'used%select{| in pointer arithmetic| in buffer access}0 here'
H2D0FA9F859F9: 'ここで%select{|ポインタ算術|バッファアクセス}0に渡されました'
# "user-defined literal suffixes %select{<ERROR>|not starting with '_'|containing '__'}0 are reserved%select{; no literal will invoke this operator|}1"
H414028466FC2: "ユーザー定義のリテラル接尾辞%select{<ERROR>|アンダースコア'_'で始まっていない|二重アンダースコア'__'を含む}0は予約されています%select{;この演算子を呼び出すリテラルはありません|}1"
# 'using'
H92BD75EBD8FD: '使用'
# 'using %0 directive in %select{NSString|CFString}1 which is being passed as a formatting argument to the formatting %select{method|CFfunction}2'
HFA21A8452E12: '%select{NSString|CFString}1がフォーマッティング引数として渡されたフォーマッティング%select{メソッド|CF関数}2で%0ディレクティブを使用'
# 'using %0 with a literal is redundant'
HA26F40AA0176: 'リテラルと組み合わせる%0は冗長です'
# 'using %select{integer|floating point|complex}1 absolute value function %0 when argument is of %select{integer|floating point|complex}2 type'
H2A1C61EF88A1: '%select{整数|浮動小数点|複素}1型の絶対値関数%0を使用していますが、引数は%select{整数|浮動小数点|複素}2型です'
# "using '%%P' format specifier with an Objective-C pointer results in dumping runtime object structure, not object value"
H513C1ECC12E7: "Objective-Cポインタで'%%P'フォーマット指定子を使用すると、オブジェクトの値ではなくランタイムオブジェクト構造がダンプされます"
# "using '%%P' format specifier without precision"
HE89A56274479: "'%%P'フォーマット指定子に精度が指定されていません"
# "using '%0' format specifier annotation outside of os_log()/os_trace()"
H2CE6DDE79E74: "os_log()/os_trace()の外で'%0'フォーマット指定子のアノテーションを使用"
# "using '%0' format specifier, but argument has boolean value"
HDDBB822724E7: "'%0'フォーマット指定子を使用していますが、引数はブーリアン値です"
# "using declaration annotated with 'using_if_exists' here"
HDB8ACBC0FBF5: "ここで'using_if_exists'で修飾されたusing宣言を使用"
# 'using declaration cannot refer to a constructor'
HF62840A086D5: 'using宣言はコンストラクタを指すことはできません'
# 'using declaration cannot refer to a destructor'
HE836ECBAB540: 'using宣言はデストラクタを指すことはできません'
# 'using declaration cannot refer to a namespace'
H0DDDFEE0D0FD: 'using宣言は名前空間を指すことはできません'
# 'using declaration cannot refer to a template specialization'
H99346E56FD07: 'using宣言はテンプレートの特殊化を指すことはできません'
# 'using declaration cannot refer to class member'
H667DB55E8D61: 'using宣言はクラスメンバを指すことはできません'
# 'using declaration in class refers into %0, which is not a class'
H703FE2D02B05: 'クラス内のusing宣言が%0を参照していますが、これはクラスではありません'
# 'using declaration naming a scoped enumerator is a C++20 extension'
H5CF0B64CDA35: 'スコープ付き列挙子を名前付けるusing宣言はC++20の拡張機能です'
# 'using declaration naming a scoped enumerator is incompatible with C++ standards before C++20'
H52802307DDAC: 'C++20以前のC++標準では、スコープ付き列挙子を名前付けるusing宣言は互換性がありません'
# 'using declaration pack expansion at block scope produces multiple values'
HFC5BC61E58BC: 'ブロックスコープでのusing宣言のパック展開は複数の値を生成します'
# 'using declaration referring to %1 with %select{internal|module|unknown}0 linkage cannot be exported'
HFDD1D0A3610E: '%1への参照のusing宣言は%select{internal|module|unknown}0リンクadgeを持ち、エクスポートできません'
# "using declaration referring to inaccessible member '%0' (which refers to accessible member '%1') is a Microsoft compatibility extension"
HA7AB89787DCC: "非公開メンバー'%0'（アクセシブルなメンバー'%1'を参照するもの）を指すusing宣言はMicrosoft互換性拡張機能です"
# 'using declaration refers into %0, which is not a base class of %1'
HE8EC9FE5FD16: '%1の基底クラスではない%0を参照するusing宣言'
# 'using declaration refers to its own class'
H435B6D84F0D6: '自分のクラスを参照するusing宣言'
# 'using declaration requires a qualified name'
H9CE75E7C4CF5: 'using宣言には修飾名が必要です'
# "using directive refers to implicitly-defined namespace 'std'"
H5C8831D062A8: 'usingディレクティブは暗黙的に定義されたstd名前空間を参照しています'
# 'using enum %select{requires an enum or typedef name|does not permit an elaborated enum specifier}0'
H07DCC7345590: 'using enumは%select{enumまたはtypedef名が必要|拡張されたenum指定子は許可されない}0'
# 'using enum declaration is a C++20 extension'
H30E94CBBC49F: 'using enum宣言はC++20の拡張機能です'
# 'using enum declaration is incompatible with C++ standards before C++20'
HA6B3DF063338: 'using enum宣言はC++20以前のC++標準では互換性がありません'
# "using length modifier '%0' with conversion specifier '%1' is not supported by ISO C"
HCAD96DA2A48D: "'%0'の長さ修飾子を'%1'の変換指定子と組み合わせることはISO Cでサポートされていません"
# 'using namespace directive in global context in header'
HDFF3F4F00DD3: 'ヘッダファイルのグローバルコンテクストでのusing namespaceディレクティブ'
# "using sysroot for '%0' but targeting '%1'"
H23CBFE9436FA: 'バージョン付けられていないAndroidターゲットディレクトリ%0を使用していますが、ターゲットは%1です'
# 'using the result of an assignment as a condition without parentheses'
HD808A1E3A9FB: '括弧なしで代入の結果を条件として使用'
# 'using the undeclared type %0 as a default template argument is a Microsoft extension'
H9BAAEE7535FA: '未宣言の型%0をデフォルトテンプレート引数として使用するのはMicrosoftの拡張機能'
# 'using unversioned Android target directory %0 for target %1; unversioned directories will not be used in Clang 19 -- provide a versioned directory for the target version or lower instead'
H120D3110B47A: 'ターゲット %1 に対してバージョンなしAndroidターゲットディレクトリ %0 を使用中です；バージョンなしディレクトリはClang 19以降で使用されなくなります。ターゲットバージョン用のバージョン付きディレクトリを指定するか、代わりにバージョンを下げてください'
# 'using-enum cannot name a dependent type'
H3DC57F2168E8: 'using-enumは依存型を名前付けできません'
# 'usual LSP protocol'
H562B11D542B5: '通常のLSPプロトコル'
# 'uuid attribute contains a malformed GUID'
H1FAF5254B686: 'uuid属性に不正なGUIDが含まれています'
# 'uuid does not match previous declaration'
H1E8E115FA4D8: 'uuidが以前の宣言と一致しません'
# 'valid %0 clauses start with %1; %select{token|tokens}2 will be ignored'
HA977999237FF: '有効な%0句は%1で始まります；%select{トークン|トークン}2は無視されます'
# 'valid target CPU values are: %0'
HB573A028A656: '有効なターゲットCPU値は次の通りです: %0'
# 'value %0 is outside the range of representable values of type %1'
H76B206381D68: '値 %0 は型 %1 の表現可能な範囲外です'
# 'value %1 cannot be represented in type %0'
H0FCCEC09B538: '値 %1 は型 %0 に表現できません'
# "value '%0' out of range for constraint '%1'"
H2964C78586A1: "制約 '%1' の範囲外の値'%0'が指定されました"
# 'value is not an integer: %0'
HDF6724275715: '整数ではありません: %0'
# 'value of #pragma pack(show) == %0'
H78F0B6172824: '#pragma pack(show) の値は %0 です'
# 'value of the aligned pointer (%0) is not a multiple of the asserted %1 %plural{1:byte|:bytes}1'
HCBC69FE1B218: 'アラインされたポインタの値 (%0) は主張された %1 %plural{1:バイト|:バイト}1 の倍数ではありません'
# "value of type %0 is not contextually convertible to 'bool'"
H8D6D08CCD77E: '型 %0 は文脈的にboolに変換できません'
# 'value of type %0 is not implicitly convertible to %1'
H7F07136EE80D: '型 %0 は暗黙のうちに%1に変換できません'
# "value returned by '__builtin_counted_by_ref' cannot be %select{assigned to a variable|passed into a function|returned from a function}0"
H0D53FCA7346F: "'__builtin_counted_by_ref' の返り値は%select{変数に代入|関数に渡す|関数から返す}0ことはできません"
# "value returned by '__builtin_counted_by_ref' cannot be used in %select{an array subscript|a binary}0 expression"
H4F263548602C: "'__builtin_counted_by_ref' の返り値は%select{配列サブスクリプト|二項}0演算子で使用できません"
# 'value size does not match register size specified by the constraint and modifier'
H45E5585EA0B2: '制約と修飾子で指定されたレジスタサイズと値サイズが一致しません'
# 'varargs not allowed in requires expression'
H65BA20F3C0FC: 'リクエアズ式では可変長引数(varargs)は許可されません'
# "variable %0 cannot be declared both 'extern' and with the 'loader_uninitialized' attribute"
H66B3CD6187EF: "'extern'と'loader_uninitialized'属性の両方を変数%0に宣言することはできません"
# 'variable %0 cannot be implicitly captured in a lambda with no capture-default specified'
H17BA614E3EF4: 'キャプチャデフォルトが指定されていないlambda内で、変数%0は暗黙のキャプチャできません'
# 'variable %0 cannot be threadprivate because it is %select{thread-local|a global named register variable}1'
HF72C764C6D1B: '変数 %0 は、%select{スレッド局所的|名前付きグローバルレジスタ変数}1 であるため、threadprivate にできません。'
# 'variable %0 declared with deduced type %1 cannot appear in its own initializer'
H9648530537F2: '推論型 %1 で宣言された変数 %0 は、自身の初期化子内に出現できません。'
# 'variable %0 is %select{decremented|incremented}1 both in the loop header and in the loop body'
H5880C36D679C: '変数 %0 はループヘッダーとループ本体の両方で%select{減少数値|増加数値}1されています。'
# "variable %0 is %select{used|captured}1 uninitialized whenever %select{'%3' condition is %select{true|false}4|'%3' loop %select{is entered|exits because its condition is false}4|'%3' loop %select{condition is true|exits because its condition is false}4|switch %3 is taken|its declaration is reached|%3 is called}2"
H5B3E786190C7: "変数 %0 は%select{使用されるとき|キャプチャされるとき}1、%select{'%3' 条件が%select{真|偽}4|'%3' ループが%select{開始される|条件が偽で終了する}4|'%3' ループの%select{条件が真|条件が偽で終了する}4|スイッチ %3 が選択されたとき|宣言に達するとき|%3 が呼ばれるとき}2 の際に初期化されていません"
# 'variable %0 is declared here'
H9C1D29CE922D: '変数 %0 はここですでに宣言されています。'
# 'variable %0 is uninitialized when %select{used here|captured by block}1'
HC11F7DAD1A0E: '変数 %0 は%select{ここに使用されるとき|ブロックによってキャプチャされるとき}1、初期化されていません。'
# 'variable %0 is uninitialized when passed as a const reference argument here'
H12F79B618200: '変数 %0 はここで定数参照引数として渡される際に初期化されていません。'
# 'variable %0 is uninitialized when used within its own initialization'
H9B3210B51205: '変数 %0 は自身の初期化中に使用される際に初期化されていません。'
# 'variable %0 is%select{| explicitly}1 captured here'
HC5A87C36FF05: '変数 %0 はここですでに%select{|明示的に}1キャプチャされています。'
# 'variable %0 may be uninitialized when %select{used here|captured by block}1'
HC0A7D9F9078D: '変数 %0 は%select{ここに使用されるとき|ブロックによってキャプチャされるとき}1、初期化されていない可能性があります。'
# 'variable %0 must have explicitly specified data sharing attributes'
H9EFAEC625413: '変数 %0 にはデータ共有属性を明示的に指定する必要があります。'
# 'variable %0 must have explicitly specified data sharing attributes, data mapping attributes, or in an is_device_ptr clause'
H577354E45CD4: '変数 %0 にはデータ共有属性、データマッピング属性を明示的に指定するか、is_device_ptr句を含める必要があります。'
# 'variable %0 set but not used'
H9EEEA592434A: '変数 %0 は設定されていますが使用されていません。'
# 'variable %0 with flexible array member cannot be captured in a lambda expression'
HEE231707A80F: '柔軟配列メンバーを持つ変数 %0 はラムダ式でキャプチャできません。'
# 'variable %0 with type %1 has incompatible initializer of type %2'
HECE6754B3154: '型 %1 の変数 %0 は、互換性のない型 %2 の初期化子を持っています。'
# 'variable %0 with unknown type cannot be given a function type'
HBD6B0E34602F: '不明な型の変数 %0 には関数型を付与できません。'
# "variable %select{|in unary expression|on right hand side of assignment|on left hand side of assignment|on left hand side of compound assignment|on left hand side of assignment}2('%3') must match variable used %select{|in unary expression|on right hand side of assignment|<not possible>|on left hand side of compound assignment|on left hand side of assignment}0('%1') from the first statement"
H68D8E5C8B649: "変数%select{|単項式中|代入の右辺|代入の左辺|複合代入の左辺|代入の左辺}2('%3')は、最初の文の%select{|単項式中|代入の右辺|<不可能>|複合代入の左辺|代入の左辺}0('%1')と一致する必要があります"
# 'variable already marked as mapped in current construct'
HA15930719644: '変数は現在の構造体で既にマップ済みとしてマークされています。'
# "variable appearing in '%0' clause of OpenACC 'declare' directive must be in the same scope as the directive"
H32CD6FB44C7B: "OpenACC 'declare'ディレクティブの'%0'句に現れる変数は、そのディレクティブと同じスコープ内に存在する必要があります。"
# "variable can appear only once in OpenMP '%0' clause"
H084B181F0F6F: "変数はOpenMPの'%0'句に一度だけ現れる必要があります。"
# "variable can appear only once in OpenMP 'target update' construct"
H78D2AF4A7A62: "変数はOpenMPの'target update'構造内で1回のみ出現できます"
# 'variable captured in declare target region must appear in a to clause'
H2004C3E36B6D: 'declare target領域でキャプチャされた変数は、to句に現れる必要があります'
# 'variable declaration in a constexpr %select{function|constructor}0 is a C++14 extension'
H953C3A7294B8: 'constexpr %select{function|constructor}0 内の変数宣言はC++14の拡張機能です'
# 'variable declaration in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14'
H5037F674FC7B: 'constexpr %select{function|constructor}0 内の変数宣言はC++14以前の標準と互換性がありません'
# 'variable declaration in condition cannot have a parenthesized initializer'
HA7027EDD1E14: '条件内での変数宣言は括弧で囲まれた初期化子を持つことはできません'
# 'variable declaration in condition must have an initializer'
H031DEC12DA47: '条件内での変数宣言には初期化子が必要です'
# 'variable declaration in for loop is a C99-specific feature'
HCED2B7B23919: 'forループ内の変数宣言はC99固有の機能です'
# 'variable declared constinit here'
HBD9CCEC96BCC: 'ここでの変数宣言はconstinit属性を使用しています'
# "variable declared with 'objc_externally_retained' cannot be modified in ARC"
H47C52BC3E77D: "'objc_externally_retained'属性で宣言された変数はARCで変更できません"
# 'variable does not have a constant initializer'
HB267A973AA07: '変数には定数初期化子がありません'
# 'variable has incomplete type %0'
HF07B48579A53: '変数は未完成な型%0を持っています'
# 'variable in constant address space must be initialized'
H66FDD0998C58: '定数アドレス空間内の変数は初期化する必要があります'
# 'variable is not assignable (missing __block type specifier)'
HAA0B269B98F3: '変数は割り当てできません（__block型修飾子が不足しています）'
# 'variable length array cannot be formed during template argument deduction'
HF26A880CF088: '変数長配列はテンプレート引数推論中に形成できません'
# "variable length array declaration cannot have 'extern' linkage"
H2436B28C5991: "変数長配列宣言は'extern'リンケージを持つことはできません"
# "variable length array declaration cannot have 'static' storage duration"
H9C9D3E1402A9: "変数長配列宣言は'static'ストレージ期間を持つことはできません"
# 'variable length array declaration not allowed at file scope'
H01CDB7349FFD: 'ファイルスコープでの変数長配列宣言は許可されていません'
# 'variable length array folded to constant array as an extension'
H861F6896A4A9: '変数長配列は拡張機能として定数配列に変換されます'
# 'variable length array must be bound in function definition'
HACDD33225FC5: '変数長配列は関数定義内で束縛する必要があります'
# 'variable length array used'
HFCB17814F664: '変数長配列が使用されています'
# 'variable length arrays are a C99 feature'
H82A7E9913A2F: '変数長配列はC99の機能です'
# "variable length arrays are not supported %select{for the current target|in '%1'}0"
H5707BCACEAC8: "変数長配列は%select{現在のターゲットではサポートされていません|'%1'ではサポートされていません}0"
# 'variable length arrays are not supported for the current target'
H50B2A4B545B7: '変数長配列は現在のターゲットではサポートされていません'
# 'variable length arrays are not supported in OpenCL'
H201996231D1A: 'OpenCLでは変数長配列がサポートされていません'
# "variable length arrays are not supported in OpenMP tasking regions with 'untied' clause"
H20FB8AB94029: "'untied'句を伴うOpenMPタスク領域では変数長配列がサポートされていません"
# 'variable length arrays in C++ are a Clang extension'
HCD7C2CD01723: 'C++における変数長配列はClang拡張機能です'
# "variable length arrays in C++ are a Clang extension; did you mean to use 'static_assert'?"
H53E1EE683577: "C++における変数長配列はClang拡張機能です；'static_assert'を使うことを意図しませんでしたか？"
# 'variable length arrays in a coroutine are not supported'
HD279E72346CE: 'コルーチン内の変数長配列はサポートされていません'
# 'variable must be of integer or %select{pointer|random access iterator}0 type'
H4F34EF5C94E2: '変数は整数または%select{ポインタ|ランダムアクセスイテレータ}0の型でなければなりません'
# "variable named 'main' with external linkage has undefined behavior"
H38BA25ED2BA1: "外部リンケージを持つ'main'という名前の変数は未定義の動作を引き起こします"
# 'variable of non-literal type %1 cannot be defined in a constexpr %select{function|constructor}0 before C++23'
H5F89C6201D7E: 'C++23以前では、C++のconstexpr %select{関数|コンストラクタ}0内で非リテラル型%1の変数を定義することはできません'
# "variable of non-reference type %0 can be used only with 'val' modifier, but used with '%1'"
HFF57CDDBE63D: "非参照型%0の変数は'val'修飾子のみで使用できますが、'%1'が使用されました"
# 'variable of type %1 has %select{private|protected}2 destructor'
H8BC8C9632B1A: '型%1の変数には%select{private|protected}2のデストラクタがあります'
# "variable referenced by 'link' clause not in global or namespace scope must be marked 'extern'"
HF7968BA9CE92: "'link'句で参照された変数がグローバルまたはネームスペーススコープにない場合、'extern'で修飾する必要があります"
# "variable referenced in '%0' clause of OpenACC 'declare' directive was already referenced"
H8FFABBD53A56: "OpenACC 'declare'ディレクティブの'%0'句で参照された変数はすでに参照されています"
# 'variable template partial specialization %0 cannot be redefined'
HB5621CB8D5D4: '変数テンプレートの部分特殊化%0は再定義できません'
# 'variable templates are a C++14 extension'
H031A6133F773: '変数テンプレートはC++14の拡張機能です'
# 'variable templates are incompatible with C++ standards before C++14'
HC36BFC632A54: '変数テンプレートはC++14より前の規格とは互換性ありません'
# "variable with 'loader_uninitialized' attribute cannot have an initializer"
H9908D11CFEF9: "'loader_uninitialized'属性を持つ変数にはイニシャライザを指定できません"
# "variable with 'loader_uninitialized' attribute must have a trivial default constructor"
H30559420B01D: "'loader_uninitialized'属性を持つ変数にはトリビアルなデフォルトコンストラクタが必要です"
# 'variable with local storage in initial value of threadprivate variable'
H06BE1F004442: 'スレッドプライベート変数の初期値にローカル ストレージを持つ変数'
# 'variable%select{s| %1|s %1 and %2|s %1, %2, and %3|s %1, %2, %3, and %4}0 used in loop condition not modified in loop body'
H78CB81888F63: 'ループ条件で使用される変数%select{s| %1|s %1 と %2|s %1, %2, および %3|s %1, %2, %3, および %4}0 はループ本文で変更されていません'
# 'variable-sized object may not be initialized'
HF22D786D9F31: '変数サイズのオブジェクトは初期化できません'
# 'variables in function scope cannot be declared static'
H588D8DBF6957: '関数スコープ内の変数はstaticとして宣言できません'
# 'variables in the %0 address space can only be declared in the outermost scope of a kernel function'
H077534025BE2: '%0 アドレス スペースの変数は、カーネル関数の最上位スコープ内で宣言する必要があります'
# 'variably modified type %0 cannot be used as a template argument'
H43ADD4446C3D: '可変変化型%0はテンプレート引数として使用できません'
# "variably modified type declaration cannot have 'extern' linkage"
H31174A21A725: "可変変化型宣言は'extern'リンケージをもてません"
# 'variably modified type declaration not allowed at file scope'
H0326E5892284: 'ファイル スコープで可変変化型宣言は許可されません'
# 'variably-modified type %0 cannot be used in a constexpr %select{function|constructor}1'
HA78DFABA86CF: 'variably-modified型%0はconstexpr %select{関数|コンストラクタ}1で使用できません'
# "variadic 'friend' declarations are a C++2c extension"
H3D2FFF66A145: '変数友達宣言はC++2c拡張機能です'
# "variadic 'friend' declarations are incompatible with C++ standards before C++2c"
H365CB532BF3E: '変数友達宣言はC++2c以前のC++規格と互換性がありません'
# 'variadic function cannot use %0 calling convention'
HEC894E082768: '可変引数関数では%0コール コンベンションを使用できません'
# 'variadic macros are a C99 feature'
H6AA48F3D31FE: '可変マクロはC99の機能です'
# 'variadic macros are a Clang extension in OpenCL'
H1CAB7A29DC4C: '可変マクロはOpenCLでのClang拡張機能です'
# 'variadic macros are incompatible with C++98'
H4BD20CD6A5E1: '可変マクロはC++98と互換性がありません'
# 'variadic templates are a C++11 extension'
H499FA3A280B8: '可変テンプレートはC++11拡張機能です'
# 'variadic templates are incompatible with C++98'
H4B7B3608CF46: '可変テンプレートはC++98と互換性がありません'
# "variant function in '#pragma omp declare variant' is itself marked as '#pragma omp declare variant'"
H82A01F59E7E3: "'#pragma omp declare variant'のvariant関数は、自体が'#pragma omp declare variant'でマークされています"
# "variant in '#pragma omp declare variant' is the same as the base function"
HEC73C56687BA: "'#pragma omp declare variant'のvariantはベース関数と同じです"
# "variant in '#pragma omp declare variant' with type %0 is incompatible with type %1%select{| with appended arguments}2"
H443E0ACFD62A: "'#pragma omp declare variant'のvariantタイプ%0はタイプ%1と互換性がありません%select{|追加された引数と共に}2"
# 'vector component access exceeds type %0'
HA6E77B2F0A3C: 'ベクター要素アクセスが型%0を超えています'
# 'vector component access has invalid length %0; supported lengths are: 1,2,3,4,8,16'
HCB71F9B8CFBC: 'ベクター要素アクセスの長さ%0は無効です。サポートされる長さは: 1,2,3,4,8,16'
# "vector component name '%0' is a feature from OpenCL version 3.0 onwards"
H6B53729D7A1D: "ベクター要素名'%0'はOpenCL 3.0以降の機能です"
# 'vector condition type %0 and result type %1 do not have elements of the same size'
H9FFA8360C1AF: 'ベクター条件型%0と結果型%1の要素サイズが一致しません'
# 'vector condition type %0 and result type %1 do not have the same number of elements'
H48693917C57D: 'ベクター条件型%0と結果型%1の要素数が一致しません'
# 'vector initializers are not compatible with NEON intrinsics in big endian mode'
H20E090504D21: 'ビッグエンディアンモードでのNEONイントラインク与えと互換性がありません'
# 'vector is not assignable (contains duplicate components)'
HA13B723E09E4: 'ベクターには重複する要素が含まれているため割り当てできません'
# 'vector operands do not have the same elements sizes (%0 and %1)'
H20CF2F14B1AB: 'ベクター操作数の要素サイズが一致しません（%0と%1）'
# 'vector operands do not have the same number of elements (%0 and %1)'
H02E2D0489C4C: 'ベクター操作数の要素数が一致しません（%0と%1）'
# 'vector operands to the vector conditional must be the same type %diff{($ and $)|}0,1}'
HBD47DE4A7313: 'ベクター条件式の操作数は同じ型%diff{($および$)|}0,1}でなければなりません'
# 'vector size not an integral multiple of component size'
H77E12186A8E0: 'ベクターサイズが要素サイズの整数倍ではありません'
# "vectorize_width loop hint malformed; use vectorize_width(X, fixed) or vectorize_width(X, scalable) where X is an integer, or vectorize_width('fixed' or 'scalable')"
H52976DB4C3C0: "ベクター化幅のループヒントが不正です。vectorize_width(X, fixed)やvectorize_width(X, scalable)（Xは整数）またはvectorize_width('fixed'または'scalable')を使用してください"
# "vendor '%0' is not supported: '%1'"
HEF7F8EFDE1D2: 'ベンダー"%0"はサポートされていません: "%1"'
# 'verbose'
H3F73A838273F: '詳細出力'
# 'verify structure of the log'
HA2B07D4BBAB9: 'ログの構造を検証'
# 'verify the CFG after every pass'
H94E54A437791: '各パス後にCFGを検証'
# 'verify-uselistorder Options'
HBF754C1F763D: 'useListOrder検証オプション'
# "version '%0' in target triple '%1' is invalid"
H638A2A1C27BA: 'ターゲットトリプル"%1"のバージョン"%0"は無効です'
# 'version 1'
H58A74A7AA4A0: 'バージョン1'
# 'version 2'
H85DE840F8B53: 'バージョン2'
# 'version 3'
HA54E81A648CA: 'バージョン3'
# 'version control conflict marker in file'
H58D6C666A33F: 'ファイル内のバージョン管理の競合マーク'
# "version for '%0' already specified"
HD1955B4EAF6D: "'%0' のバージョンはすでに指定されています"
# 'version list contains duplicate entries'
HDC1A5F99BC1B: 'バージョンリストに重複するエントリが含まれています'
# "version list contains entries that don't impact code generation"
H346B24B0B01F: 'バージョンリストにコード生成に影響しないエントリが含まれています'
# 'version number must have non-zero major, minor, or sub-minor version'
H32D5C8ECFF2D: 'バージョン番号には、メジャー、マイナー、またはサブマイナーのいずれかが非ゼロでなければなりません'
# 'violations found for %0'
HC357EBB7E4D0: '%0 で違反が見つかりました'
# 'virtual base class declared here'
H2738AB0FED80: 'ここで仮想基底クラスが宣言されています'
# 'virtual constexpr functions are incompatible with C++ standards before C++20'
H0CA73C06B6D5: 'C++20以前のC++規格では仮想constexpr関数は互換性がありません'
# "virtual destructor requires an unambiguous, accessible 'operator delete'"
H23281750E023: "仮想デストラクタには、曖昧でないかつアクセス可能な 'operator delete' が必要です"
# "virtual filesystem overlay file '%0' not found"
H26F74FB8B8C2: "仮想ファイルシステムのオーバレイファイル '%0' が見つかりません"
# 'virtual function %0 has a different return type %diff{($) than the function it overrides (which has return type $)|than the function it overrides}1,2'
HD8B18D2DDADC: '仮想関数 %0 の戻り値の型が %diff{($) オーバーライド元の関数と異なります（オーバーライド元の戻り値の型は $ です）|オーバーライド元の関数と異なります}1,2'
# 'virtual function %0 has different attributes %diff{($) than the function it overrides (which has $)|than the function it overrides}1,2'
H105CB368BBFA: '仮想関数 %0 の属性が %diff{($) オーバーライド元の関数と異なります（オーバーライド元の属性は $ です）|オーバーライド元の関数と異なります}1,2'
# 'virtual function %0 has different calling convention attributes %diff{($) than the function it overrides (which has calling convention $)|than the function it overrides}1,2'
HB03FA37606B1: '仮想関数 %0 のコールコンベンション属性が %diff{($) オーバーライド元の関数と異なります（オーバーライド元のコールコンベンションは $ です）|オーバーライド元の関数と異なります}1,2'
# 'virtual function %q0 has more than one final overrider in %1'
H80394FC58D1D: '仮想関数 %q0 は %1 で複数の最終オーバライダーを持ちます'
# 'virtual function cannot be constexpr'
H01635D482A33: '仮想関数はconstexprにできません'
# 'virtual function cannot have a requires clause'
H138054D4510B: 'OpenCLのC++では仮想関数がサポートされていません'
# 'virtual functions are not supported in C++ for OpenCL'
H820F01CD9896: 'HLSLでは仮想関数がサポートされていません'
# 'virtual functions are unsupported in HLSL'
H207695B65E04: 'HLSLでは仮想継承がサポートされていません'
# 'virtual inheritance is unsupported in HLSL'
H8C2B278220B7: 'HLSLではバーチャル継承はサポートされていません'
# "virtual method %0 is inside a 'final' class and can never be overridden"
HAC30D95A1570: "'final' クラス内のバーチャルメソッド %0 は決してオーバーライドされません"
# 'visibility does not match previous declaration'
H17040BB5EC03: '以前の宣言と可視性が一致しません'
# 'void %select{function|method|block}1 %0 should not return void expression'
HCA9EAB88160F: 'void %select{関数|メソッド|ブロック}1 %0 はvoid式を返すべきではありません'
# 'void block should not return a value'
H1C0762ECEC55: 'voidブロックは値を返すべきではありません'
# 'volatile %select{temporary created|object declared|member declared}0 here'
HBA1E3AEA8BE2: 'ここにvolatile %select{一時的に作成された|宣言されたオブジェクト|宣言されたメンバー}0 があります'
# 'volatile qualifier in structured binding declaration is deprecated'
H8119BA6E8068: '構造化バインディング宣言におけるvolatile修飾子は非推奨になりました'
# 'volatile-qualified parameter type %0 is deprecated'
H9F774F8B8E15: 'volatile修飾されたパラメータ型 %0 は非推奨になりました'
# 'volatile-qualified return type %0 is deprecated'
H34762436C2FA: 'volatile修飾された戻り値型 %0 は非推奨になりました'
# 'warn on trailing characters'
H82F663F8D48C: '末尾の文字列がある場合に警告'
# 'warnings are errors'
HB9FCBCA0C7DE: '警告をエラーとして扱う'
# 'was searched for in the directory: %0'
H4B8949005850: 'ディレクトリ %0 で検索されました'
# 'wave good bye'
H29B5647E64A4: 'wave good bye'
# 'weak %select{variable|property|implicit property|instance variable}0 %1 is accessed multiple times in this %select{function|method|block|lambda}2 but may be unpredictably set to nil; assign to a strong variable to keep the object alive'
H7F2B64A607B2: 'weak %select{変数|プロパティ|暗黙のプロパティ|インスタンス変数}0 %1 はこの %select{関数|メソッド|ブロック|ラムダ}2 内で複数回アクセスされますが、予期せずnilに設定される可能性があります。オブジェクトを保持するには、strong変数に代入してください'
# 'weak %select{variable|property|implicit property|instance variable}0 %1 may be accessed multiple times in this %select{function|method|block|lambda}2 and may be unpredictably set to nil; assign to a strong variable to keep the object alive'
H301C12832949: 'weak %select{変数|プロパティ|暗黙のプロパティ|インスタンス変数}0 %1 はこの %select{関数|メソッド|ブロック|ラムダ}2 内で複数回アクセスされる可能性があり、予期せずnilに設定される場合があります。オブジェクトを保持するには、strong変数に代入してください'
# 'weak attribute declared on a __strong type property in GC mode'
H088D436307D2: 'GCモードにおける__strong型プロパティにweak属性が宣言されました'
# 'weak declaration cannot have internal linkage'
HC1895405FFA7: 'weak宣言は内部リンクを指定できません'
# 'weak identifier %0 never declared'
H22A978739C8D: 'weak識別子 %0 は未宣言です'
# 'weakref declaration must have internal linkage'
H8016E3683340: 'weakref宣言は内部リンクを指定する必要があります'
# 'weakref declaration of %0 must also have an alias attribute'
H101799E65B31: '%0 のweakref宣言にはalias属性も指定する必要があります'
# 'weakref declaration of %0 must be in a global context'
HDA1EB6DAD24A: '%0のweakref宣言はグローバルコンテキストに置かなければなりません'
# 'webassembly: disables the fix  irreducible control flow optimization pass'
HA0B81E145B1D: 'webassembly: 無効にした修正不可解制御フロー最適化パス'
# 'when a function is considered for merging into a partition that already contains some of its callees, do the merge if at least n% of the code it can reach is already present inside the partition; e.g. 0.7 means only merge >70%'
HB679EAE1AA06: '関数がその呼び出し先の一部を含むパーティションへのマージ対象として検討される場合、そのコードが到達可能なコードのn%以上がパーティション内に既に存在する場合にマージします。例えば、0.7は70%を超える場合のみマージします'
# 'when applied to this declaration'
HA6DB04448955: 'この宣言が適用された場合'
# 'when deciding to split a function, apply this alignment while doing the size comparison (see -split-threshold). Default value: 2.'
HD6693F2AB0CA: '関数を分割するかどうか判断する際、サイズ比較時にこのアライメントを使用します（-split-threshold参照）。既定値：2。'
# 'when emitting large string tables, prefer string literals over comma-separated char literals. This can be a readability and compile-time performance win, but upsets some compilers'
H2D23BA9375B5: '可能な場合、スコープ変数をスコープ開始時にpoisonします（遅いが正確）'
# 'when implemented by class %0'
H9F7ED2DB900A: 'クラス%0で実装された場合'
# "when looking up '%select{begin|end}0' function for range expression of type %1"
HC4C870329421: "型%1のレンジ式用に'%select{begin|end}0'関数を検索中に"
# 'when max depth is reached and we can no longer branch out, this value determines if a function is worth merging into an already existing partition to reduce code duplication. This is a factor of the ideal partition size, e.g. 2.0 means we consider the function for merging if its cost (including its callees) is 2x the size of an ideal partition.'
HC50D6FBB78F2: '最大深さに達し、さらに分岐できなくなった場合、この値は関数が既存のパーティションと統合されてコード重複を減らす価値があるかどうかを決定します。これは理想的なパーティションサイズの係数です。例えば2.0の場合、そのコスト（呼び出し元を含む）が理想的なパーティションの2倍であれば、この関数を統合対象とします。'
# 'when possible, poison scoped variables at the beginning of the scope (slower, but more precise)'
H00AA44541919: '最大深さに達しさらに分岐できなくなった場合、この値はコード重複を減らすために既存パーティションにマージする価値があるかを判断します。これは理想パーティションサイズの係数です。例：2.0の場合、その関数のコスト（呼び出し先を含む）が理想パーティションサイズの2倍であればマージ対象とします'
# 'when repeating the instruction snippet by looping over it, duplicate the snippet until the loop body contains at least this many instruction'
HED512258C903: 'ループで命令スニペットを繰り返す場合、ループ本体内に少なくともこの数の命令が含まれるまでスニペットを複製します'
# 'when type is in parentheses, array cannot have dynamic size'
HBDE59C8D782B: 'タイプが括弧で囲まれている場合、配列は動的サイズを指定できません'
# 'which delegates to'
H90C5BED46FE0: '使用するガジェットスキャナ'
# 'which gadget scanners to run'
HF9F26A96F310: '実行するガジェットスキャナの指定'
# 'while building implicit deduction guide first needed here'
HD4658CE20D59: '暗黙の推論ガイド構築中にここが必要とされた際'
# 'while calculating associated constraint of template %0 here'
HD4CBA036E98A: 'テンプレート%0の関連制約を計算中に'
# 'while checking a default template argument used here'
H7E4F64D4A848: 'ここに使用されるデフォルトテンプレート引数をチェック中に'
# "while checking constraint satisfaction for class template partial specialization '%0' required here"
H190F26B4DB43: "クラステンプレートの部分専用化'%0'の制約充足確認中に必要とされた際"
# "while checking constraint satisfaction for function '%0' required here"
H1A3A707B1D73: "関数'%0'の制約充足確認中に必要とされた際"
# "while checking constraint satisfaction for template '%0' required here"
H19BE8EB0741D: "テンプレート'%0'の制約充足確認中に必要とされた際"
# "while checking constraint satisfaction for variable template partial specialization '%0' required here"
HD73CEE0E62DB: "ここでの要件変数テンプレートの部分特殊化'%0'の制約充足を確認中に"
# "while checking implicit 'delete this' for virtual destructor"
H738DE49AA679: "仮想デストラクタの暗黙の'delete this'を確認中に"
# "while checking the satisfaction of concept '%0' requested here"
HE2FF74B26A28: "ここでの要請概念'%0'の充足を確認中に"
# 'while checking the satisfaction of nested requirement requested here'
HE3D634694184: 'ここでのネスト要件の充足を確認中に'
# "while declaring the corresponding implicit 'operator==' for this defaulted 'operator<=>'"
H332A7297AC58: "このデフォルト化された'operator<=>'に対応する暗黙の'operator=='を宣言中に"
# 'while declaring the implicit %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}1 for %0'
HAC5877F575DC: '%0の暗黙の%select{デフォルトコンストラクタ|コピーコンストラクタ|ムーブコンストラクタ|コピー代入演算子|ムーブ代入演算子|デストラクタ}1を宣言中に'
# 'while loop has empty body'
H374FEF617D4F: 'whileループのボディが空です'
# 'while loop outside of a function'
HAB96332E82A6: '関数外のwhileループ'
# 'while printing functions output dyno-stats and skip instructions'
HF414286E0A36: 'dyno-statsを出力し、命令をスキップする関数の印刷中に'
# "while rewriting comparison as call to 'operator<=>' declared here"
H9A478A9E2AA1: "ここで宣言された'operator<=>'への呼び出しとして比較を書き換え中に"
# 'while substituting deduced template arguments into function template %0 %1'
H4E16912522F9: '推論されたテンプレート引数を関数テンプレート%0 %1に代入中に'
# 'while substituting explicitly-specified template arguments into function template %0 %1'
H862C7E7129FA: '明示的に指定されたテンプレート引数を関数テンプレート%0 %1に代入中に'
# 'while substituting into a lambda expression here'
H154EA9F3EDC1: 'ここでのラムダ式への代入中に'
# 'while substituting into concept arguments here; substitution failures not allowed in concept arguments'
HAC706623FF86: 'ここでの概念引数への代入中に; 概念引数での代入失敗は許可されません'
# 'while substituting prior template arguments into %select{non-type|template}0 template parameter%1 %2'
HF0EDCF82D09D: '%select{non-type|template}0テンプレートパラメータ%1 %2への前のテンプレート引数の代入中に'
# 'while substituting template arguments into constraint expression here'
H19C71987DC07: 'ここでの制約式へのテンプレート引数の代入中に'
# 'whitespace is not allowed in parameter passing direction'
H82BD58AB277F: 'パラメータの渡し方向には空白文字を含めることはできません'
# 'whitespace recommended after macro name'
H47F8347E0371: 'マクロ名の後に空白文字を付けることを推奨します'
# 'whitespace required after macro name'
H2F43B2E26F3A: 'マクロ名の後に空白文字を付ける必要があります'
# 'widen this field to %0 bits to store all values of %1'
HD1698255B212: 'このフィールドを%0ビットに拡張して%1のすべての値を格納してください'
# 'width of bit-field %0 (%1 bits) exceeds the width of its type; value will be truncated to %2 bit%s2'
H8896C13CC6D9: 'ビットフィールド%0 (%1ビット)の幅はその型の幅を超えています。値は%2ビットに切り捨てられます%s2'
# 'width of%select{ anonymous|}0 bit-field%select{| %1}0 (%2 bits) exceeds the %select{width|size}3 of its type (%4 bit%s4)'
H02B50746D7D1: 'タイプ%select{匿名|}0ビットフィールド%select{| %1}0 (%2ビット)の幅はその型の%select{幅|サイズ}3 (%4ビット%s4)を超えています'
# 'with jt-footprint-reduction, only process PIC jumptables and turn off other transformations that increase code size'
H3BB007DE5DDB: 'jt-footprint-reductionを使用する場合、PICジャンプテーブルのみを処理し、コードサイズを増加させる他の変換を無効にします'
# 'within field of type %0 declared here'
HEC6FDC220283: 'ここに宣言された型%0のフィールド内で'
# 'writable atomic property %0 cannot pair a synthesized %select{getter|setter}1 with a user defined %select{getter|setter}2'
HA65A16D8E26B: '書き込み可能な原子プロパティ%0は、合成された%select{getter|setter}1とユーザー定義の%select{getter|setter}2をペアにすることができません'
# 'write BOLT Address Translation tables'
H1540FEF77408: 'BOLTアドレス変換テーブルを書き込む'
# 'write bolt info section in the output binary'
H5BC44776C33F: '出力バイナリにBOLT情報セクションを書き込む'
# 'wrong argument format for hlsl attribute, use %0 instead'
H514518256D51: 'hlsl属性の引数形式が正しくありません。代わりに%0を使用してください'
# 'wrong fpu width; %select{LSX|LASX}0 depends on 64-bit FPU'
H65FC5C473561: 'FPUの幅が正しくありません;%select{LSX|LASX}0は64ビットFPUに依存しています'
# 'yaml2obj Options'
H095AAC30EBC3: 'yaml2obj オプション'
# "you need to include <typeinfo> before using the 'typeid' operator"
H64B8C0D4E612: "'typeid'オペレーターを使用する前に、<typeinfo>を含める必要があります"
# 'z/OS target level "%0" is discontinued'
HB5BA348592D3: 'z/OSターゲットレベル"%0"は廃止されました'
# 'z/OS target level "%0" is invalid'
H0080755EFA11: 'z/OSターゲットレベル"%0"は無効です'
# 'zero %0 size'
HF7816CFF7955: '%0のサイズがゼロです'
# 'zero as null pointer constant'
H824A61FB1C48: 'ゼロをヌルポインタ定数として使用'
# 'zero field width in scanf format string is unused'
H122ACCFBBD62: 'scanfフォーマット文字列内のゼロフィールド幅は未使用です'
# 'zero linear step (%0 %select{|and other variables in clause }1should probably be const)'
HDA0E059C273A: 'ゼロの線形ステップ (%0 %select{ |句の他の変数も }1おそらくconstにする必要があります)'
# 'zero size arrays are an extension'
H49512BBF0CE4: 'ゼロサイズの配列は拡張機能です'
# "zero-length array section is not allowed in 'depend' clause"
HC5FAF4CE6159: "'depend'句ではゼロ長配列のセクションは許可されていません"
# 'zero-length arrays are not permitted in %select{C++|SYCL device code|HIP device code}0'
H2F083F032372: '%select{C++|SYCL デバイス コード|HIP デバイス コード}0では、ゼロ長配列は許可されていません'
